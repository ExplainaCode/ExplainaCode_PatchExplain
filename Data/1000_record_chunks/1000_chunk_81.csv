record_number,buggy_code,fixed_code,code_similarity
80001,"@Override public void performDataSync(OSyncAdapter adapter,Bundle extras,OUser user){
  if (adapter.getModel().getModelName().equals(""String_Node_Str"")) {
    ODomain domain=new ODomain();
    domain.add(""String_Node_Str"",""String_Node_Str"",user.getUser_id());
    adapter.setDomain(domain).syncDataLimit(10);
    adapter.onSyncFinish(this);
  }
}","@Override public void performDataSync(OSyncAdapter adapter,Bundle extras,OUser user){
  if (adapter.getModel().getModelName().equals(""String_Node_Str"")) {
    ODomain domain=new ODomain();
    domain.add(""String_Node_Str"",""String_Node_Str"",user.getUser_id());
    adapter.setDomain(domain).syncDataLimit(10);
    adapter.onSyncFinish(this).syncDataLimit(50);
  }
}",0.9746478873239436
80002,"@Override public void performDataSync(OSyncAdapter adapter,Bundle extras,OUser user){
  if (adapter.getModel().getModelName().equals(""String_Node_Str"")) {
    ODomain domain=new ODomain();
    SaleOrder saleOrder=new SaleOrder(getApplicationContext(),user);
    List<Integer> newIds=new ArrayList<>();
    for (    ODataRow row : saleOrder.select(new String[]{},""String_Node_Str"",new String[]{""String_Node_Str"",""String_Node_Str""})) {
      newIds.add(row.getInt(""String_Node_Str""));
    }
    if (newIds.size() > 0) {
      domain.add(""String_Node_Str"",""String_Node_Str"",newIds);
    }
    if (!firstSync)     adapter.onSyncFinish(this);
    domain.add(""String_Node_Str"",""String_Node_Str"",user.getUser_id());
    adapter.setDomain(domain);
  }
  if (adapter.getModel().getModelName().equals(""String_Node_Str"")) {
    adapter.onSyncFinish(syncFinishListener);
  }
}","@Override public void performDataSync(OSyncAdapter adapter,Bundle extras,OUser user){
  if (adapter.getModel().getModelName().equals(""String_Node_Str"")) {
    ODomain domain=new ODomain();
    SaleOrder saleOrder=new SaleOrder(getApplicationContext(),user);
    List<Integer> newIds=new ArrayList<>();
    for (    ODataRow row : saleOrder.select(new String[]{},""String_Node_Str"",new String[]{""String_Node_Str"",""String_Node_Str""})) {
      newIds.add(row.getInt(""String_Node_Str""));
    }
    if (newIds.size() > 0) {
      domain.add(""String_Node_Str"",""String_Node_Str"",newIds);
    }
    if (!firstSync)     adapter.onSyncFinish(this);
    domain.add(""String_Node_Str"",""String_Node_Str"",user.getUser_id());
    adapter.setDomain(domain).syncDataLimit(50);
  }
  if (adapter.getModel().getModelName().equals(""String_Node_Str"")) {
    adapter.onSyncFinish(syncFinishListener);
  }
}",0.9896907216494846
80003,"public OValues handleResult(int requestCode,int resultCode,Intent data){
  if (resultCode == Activity.RESULT_OK) {
switch (requestCode) {
case REQUEST_CAMERA:
      OValues values=getURIDetails(newImageUri);
    if (values.getLong(""String_Node_Str"") < IMAGE_MAX_SIZE) {
      values.put(""String_Node_Str"",BitmapUtils.uriToBase64(newImageUri,mContext.getContentResolver()));
      return values;
    }
 else {
      values=new OValues();
      values.put(""String_Node_Str"",true);
    }
  break;
case REQUEST_IMAGE:
values=getURIDetails(data.getData());
if (values.getLong(""String_Node_Str"") < IMAGE_MAX_SIZE) {
values.put(""String_Node_Str"",BitmapUtils.uriToBase64(data.getData(),mContext.getContentResolver()));
return values;
}
 else {
values=new OValues();
values.put(""String_Node_Str"",true);
}
break;
}
}
return null;
}","public OValues handleResult(int requestCode,int resultCode,Intent data){
  if (resultCode == Activity.RESULT_OK) {
switch (requestCode) {
case REQUEST_CAMERA:
      OValues values=getURIDetails(newImageUri);
    values.put(""String_Node_Str"",BitmapUtils.uriToBase64(newImageUri,mContext.getContentResolver(),true));
  return values;
case REQUEST_IMAGE:
values=getURIDetails(data.getData());
values.put(""String_Node_Str"",BitmapUtils.uriToBase64(data.getData(),mContext.getContentResolver(),true));
return values;
}
}
return null;
}",0.4814814814814814
80004,"public static String uriToBase64(Uri uri,ContentResolver resolver){
  String encodedBase64=""String_Node_Str"";
  try {
    byte[] bytes=readBytes(uri,resolver);
    encodedBase64=Base64.encodeToString(bytes,0);
  }
 catch (  IOException e1) {
    e1.printStackTrace();
  }
  return encodedBase64;
}","public static String uriToBase64(Uri uri,ContentResolver resolver,boolean thumbnail){
  String encodedBase64=""String_Node_Str"";
  try {
    byte[] bytes=readBytes(uri,resolver,thumbnail);
    encodedBase64=Base64.encodeToString(bytes,0);
  }
 catch (  IOException e1) {
    e1.printStackTrace();
  }
  return encodedBase64;
}",0.954983922829582
80005,"/** 
 * Read bytes.
 * @param uri      the uri
 * @param resolver the resolver
 * @return the byte[]
 * @throws IOException Signals that an I/O exception has occurred.
 */
private static byte[] readBytes(Uri uri,ContentResolver resolver) throws IOException {
  InputStream inputStream=resolver.openInputStream(uri);
  ByteArrayOutputStream byteBuffer=new ByteArrayOutputStream();
  int bufferSize=1024;
  byte[] buffer=new byte[bufferSize];
  int len=0;
  while ((len=inputStream.read(buffer)) != -1) {
    byteBuffer.write(buffer,0,len);
  }
  return byteBuffer.toByteArray();
}","/** 
 * Read bytes.
 * @param uri      the uri
 * @param resolver the resolver
 * @return the byte[]
 * @throws IOException Signals that an I/O exception has occurred.
 */
private static byte[] readBytes(Uri uri,ContentResolver resolver,boolean thumbnail) throws IOException {
  InputStream inputStream=resolver.openInputStream(uri);
  ByteArrayOutputStream byteBuffer=new ByteArrayOutputStream();
  if (!thumbnail) {
    int bufferSize=1024;
    byte[] buffer=new byte[bufferSize];
    int len=0;
    while ((len=inputStream.read(buffer)) != -1) {
      byteBuffer.write(buffer,0,len);
    }
  }
 else {
    Bitmap imageBitmap=BitmapFactory.decodeStream(inputStream);
    int thumb_width=imageBitmap.getWidth() / 2;
    int thumb_height=imageBitmap.getHeight() / 2;
    if (thumb_width > THUMBNAIL_SIZE) {
      thumb_width=THUMBNAIL_SIZE;
    }
    if (thumb_width == THUMBNAIL_SIZE) {
      thumb_height=((imageBitmap.getHeight() / 2) * THUMBNAIL_SIZE) / (imageBitmap.getWidth() / 2);
    }
    imageBitmap=Bitmap.createScaledBitmap(imageBitmap,thumb_width,thumb_height,false);
    imageBitmap.compress(Bitmap.CompressFormat.JPEG,100,byteBuffer);
  }
  return byteBuffer.toByteArray();
}",0.6184284906726965
80006,"@Override public void onItemClick(BottomSheet sheet,MenuItem menu,Object extras){
  ODataRow row=OCursorUtils.toDatarow((Cursor)extras);
  mSheet.dismiss();
switch (menu.getItemId()) {
case R.id.menu_lead_convert_to_opportunity:
    if (inNetwork()) {
      CRMLead crmLead=(CRMLead)db();
      if (row.getInt(""String_Node_Str"") == 0) {
        OAlert.showWarning(getActivity(),""String_Node_Str"");
      }
 else {
        int count=crmLead.count(""String_Node_Str"" + OColumn.ROW_ID + ""String_Node_Str"",new String[]{""String_Node_Str"",row.getInt(""String_Node_Str"") + ""String_Node_Str"",row.getString(OColumn.ROW_ID)});
        if (count > 0) {
          convertRequestRecord=row;
          Intent intent=new Intent(getActivity(),ConvertToOpportunityWizard.class);
          intent.putExtras(row.getPrimaryBundleData());
          startActivityForResult(intent,REQUEST_CONVERT_WIZARD);
        }
 else {
          crmLead.convertToOpportunity(row,new ArrayList<Integer>(),convertDoneListener);
        }
      }
    }
 else {
      Toast.makeText(getActivity(),R.string.toast_network_required,Toast.LENGTH_LONG).show();
    }
  break;
case R.id.menu_lead_convert_to_quotation:
break;
case R.id.menu_lead_call_customer:
break;
case R.id.menu_lead_customer_location:
break;
case R.id.menu_lead_reschedule:
break;
case R.id.menu_lead_won:
break;
case R.id.menu_lead_lost:
break;
}
}","@Override public void onItemClick(BottomSheet sheet,MenuItem menu,Object extras){
  ODataRow row=OCursorUtils.toDatarow((Cursor)extras);
  mSheet.dismiss();
  ResPartner partner=new ResPartner(getActivity(),null);
switch (menu.getItemId()) {
case R.id.menu_lead_convert_to_opportunity:
    if (inNetwork()) {
      CRMLead crmLead=(CRMLead)db();
      if (row.getInt(""String_Node_Str"") == 0) {
        OAlert.showWarning(getActivity(),""String_Node_Str"");
      }
 else {
        int count=crmLead.count(""String_Node_Str"" + OColumn.ROW_ID + ""String_Node_Str"",new String[]{""String_Node_Str"",row.getInt(""String_Node_Str"") + ""String_Node_Str"",row.getString(OColumn.ROW_ID)});
        if (count > 0) {
          convertRequestRecord=row;
          Intent intent=new Intent(getActivity(),ConvertToOpportunityWizard.class);
          intent.putExtras(row.getPrimaryBundleData());
          startActivityForResult(intent,REQUEST_CONVERT_WIZARD);
        }
 else {
          crmLead.convertToOpportunity(row,new ArrayList<Integer>(),convertDoneListener);
        }
      }
    }
 else {
      Toast.makeText(getActivity(),R.string.toast_network_required,Toast.LENGTH_LONG).show();
    }
  break;
case R.id.menu_lead_convert_to_quotation:
break;
case R.id.menu_lead_call_customer:
if (!row.getString(""String_Node_Str"").equals(""String_Node_Str"")) {
String contact=partner.getContact(getActivity(),row.getInt(OColumn.ROW_ID));
if (!contact.equals(""String_Node_Str"")) {
  IntentUtils.requestCall(getActivity(),contact);
}
 else {
  Toast.makeText(getActivity(),""String_Node_Str"",Toast.LENGTH_LONG).show();
}
}
 else {
Toast.makeText(getActivity(),""String_Node_Str"",Toast.LENGTH_LONG).show();
}
break;
case R.id.menu_lead_customer_location:
if (!row.getString(""String_Node_Str"").equals(""String_Node_Str"")) {
String address=partner.getAddress(partner.browse(row.getInt(""String_Node_Str"")));
if (!address.equals(""String_Node_Str"") && !TextUtils.isEmpty(address)) {
IntentUtils.redirectToMap(getActivity(),address);
}
 else {
Toast.makeText(getActivity(),""String_Node_Str"",Toast.LENGTH_LONG).show();
}
}
 else {
Toast.makeText(getActivity(),""String_Node_Str"",Toast.LENGTH_LONG).show();
}
break;
case R.id.menu_lead_reschedule:
IntentUtils.startActivity(getActivity(),CRMDetail.class,row.getPrimaryBundleData());
break;
case R.id.menu_lead_won:
break;
case R.id.menu_lead_lost:
break;
}
}",0.7334401709401709
80007,"public OdooActivity parent(){
  return (OdooActivity)getActivity();
}","public OdooActivity parent(){
  return (OdooActivity)mContext;
}",0.8721804511278195
80008,"/** 
 * Callback invoked with the sync adapter status changes. 
 */
@Override public void onStatusChanged(int which){
  getActivity().runOnUiThread(new Runnable(){
    @Override public void run(){
      boolean syncActive=ContentResolver.isSyncActive(OUser.current(getActivity()).getAccount(),syncStatusObserverModel.authority());
      boolean syncPending=ContentResolver.isSyncPending(OUser.current(getActivity()).getAccount(),syncStatusObserverModel.authority());
      boolean refreshing=syncActive | syncPending;
      if (!refreshing) {
      }
      mSyncStatusObserverListener.onStatusChange(refreshing);
    }
  }
);
}","/** 
 * Callback invoked with the sync adapter status changes. 
 */
@Override public void onStatusChanged(int which){
  getActivity().runOnUiThread(new Runnable(){
    @Override public void run(){
      boolean syncActive=ContentResolver.isSyncActive(OUser.current(mContext).getAccount(),syncStatusObserverModel.authority());
      boolean syncPending=ContentResolver.isSyncPending(OUser.current(mContext).getAccount(),syncStatusObserverModel.authority());
      boolean refreshing=syncActive | syncPending;
      if (!refreshing) {
      }
      mSyncStatusObserverListener.onStatusChange(refreshing);
    }
  }
);
}",0.6720257234726688
80009,"public int _c(int res_id){
  return OResource.color(getActivity(),res_id);
}","public int _c(int res_id){
  return OResource.color(mContext,res_id);
}",0.8843537414965986
80010,"public int _dim(int res_id){
  return OResource.dimen(getActivity(),res_id);
}","public int _dim(int res_id){
  return OResource.dimen(mContext,res_id);
}",0.8874172185430463
80011,"public boolean inNetwork(){
  App app=(App)getActivity().getApplicationContext();
  return app.inNetwork();
}","public boolean inNetwork(){
  App app=(App)mContext.getApplicationContext();
  return app.inNetwork();
}",0.92018779342723
80012,"public String _s(int res_id){
  return OResource.string(getActivity(),res_id);
}","public String _s(int res_id){
  return OResource.string(mContext,res_id);
}",0.8903225806451613
80013,"public OUser user(){
  if (getActivity() != null)   return OUser.current(getActivity());
  return null;
}","public OUser user(){
  if (mContext != null)   return OUser.current(mContext);
  return null;
}",0.83
80014,"public OModel db(){
  Class<?> model=database();
  if (model != null) {
    return new OModel(getActivity(),null,user()).createInstance(model);
  }
  return null;
}","public OModel db(){
  Class<?> model=database();
  if (model != null) {
    return new OModel(mContext,null,user()).createInstance(model);
  }
  return null;
}",0.9473684210526316
80015,"@Override public void onItemClick(BottomSheet sheet,MenuItem menu,Object extras){
  ODataRow row=OCursorUtils.toDatarow((Cursor)extras);
  mSheet.dismiss();
switch (menu.getItemId()) {
case R.id.menu_lead_convert_to_opportunity:
    if (inNetwork()) {
      CRMLead crmLead=(CRMLead)db();
      if (row.getInt(""String_Node_Str"") == 0) {
        OAlert.showWarning(getActivity(),""String_Node_Str"");
      }
 else {
        int count=crmLead.count(""String_Node_Str"" + OColumn.ROW_ID + ""String_Node_Str"",new String[]{""String_Node_Str"",row.getInt(""String_Node_Str"") + ""String_Node_Str"",row.getString(OColumn.ROW_ID)});
        if (count > 0) {
          convertRequestRecord=row;
          Intent intent=new Intent(getActivity(),ConvertToOpportunityWizard.class);
          intent.putExtras(row.getPrimaryBundleData());
          startActivityForResult(intent,REQUEST_CONVERT_WIZARD);
        }
 else {
          crmLead.convertToOpportunity(row,new ArrayList<Integer>(),convertDoneListener);
        }
      }
    }
 else {
      Toast.makeText(getActivity(),R.string.toast_network_required,Toast.LENGTH_LONG).show();
    }
  break;
case R.id.menu_lead_convert_to_quotation:
break;
case R.id.menu_lead_call_customer:
break;
case R.id.menu_lead_customer_location:
break;
case R.id.menu_lead_reschedule:
break;
case R.id.menu_lead_won:
break;
case R.id.menu_lead_lost:
break;
}
}","@Override public void onItemClick(BottomSheet sheet,MenuItem menu,Object extras){
  ODataRow row=OCursorUtils.toDatarow((Cursor)extras);
  mSheet.dismiss();
  ResPartner partner=new ResPartner(getActivity(),null);
switch (menu.getItemId()) {
case R.id.menu_lead_convert_to_opportunity:
    if (inNetwork()) {
      CRMLead crmLead=(CRMLead)db();
      if (row.getInt(""String_Node_Str"") == 0) {
        OAlert.showWarning(getActivity(),""String_Node_Str"");
      }
 else {
        int count=crmLead.count(""String_Node_Str"" + OColumn.ROW_ID + ""String_Node_Str"",new String[]{""String_Node_Str"",row.getInt(""String_Node_Str"") + ""String_Node_Str"",row.getString(OColumn.ROW_ID)});
        if (count > 0) {
          convertRequestRecord=row;
          Intent intent=new Intent(getActivity(),ConvertToOpportunityWizard.class);
          intent.putExtras(row.getPrimaryBundleData());
          startActivityForResult(intent,REQUEST_CONVERT_WIZARD);
        }
 else {
          crmLead.convertToOpportunity(row,new ArrayList<Integer>(),convertDoneListener);
        }
      }
    }
 else {
      Toast.makeText(getActivity(),R.string.toast_network_required,Toast.LENGTH_LONG).show();
    }
  break;
case R.id.menu_lead_convert_to_quotation:
break;
case R.id.menu_lead_call_customer:
if (!row.getString(""String_Node_Str"").equals(""String_Node_Str"")) {
String contact=partner.getContact(getActivity(),row.getInt(OColumn.ROW_ID));
if (!contact.equals(""String_Node_Str"")) {
  IntentUtils.requestCall(getActivity(),contact);
}
 else {
  Toast.makeText(getActivity(),""String_Node_Str"",Toast.LENGTH_LONG).show();
}
}
 else {
Toast.makeText(getActivity(),""String_Node_Str"",Toast.LENGTH_LONG).show();
}
break;
case R.id.menu_lead_customer_location:
if (!row.getString(""String_Node_Str"").equals(""String_Node_Str"")) {
String address=partner.getAddress(partner.browse(row.getInt(""String_Node_Str"")));
if (!address.equals(""String_Node_Str"") && !TextUtils.isEmpty(address)) {
IntentUtils.redirectToMap(getActivity(),address);
}
 else {
Toast.makeText(getActivity(),""String_Node_Str"",Toast.LENGTH_LONG).show();
}
}
 else {
Toast.makeText(getActivity(),""String_Node_Str"",Toast.LENGTH_LONG).show();
}
break;
case R.id.menu_lead_reschedule:
IntentUtils.startActivity(getActivity(),CRMDetail.class,row.getPrimaryBundleData());
break;
case R.id.menu_lead_won:
break;
case R.id.menu_lead_lost:
break;
}
}",0.7334401709401709
80016,"public OdooActivity parent(){
  return (OdooActivity)getActivity();
}","public OdooActivity parent(){
  return (OdooActivity)mContext;
}",0.8721804511278195
80017,"/** 
 * Callback invoked with the sync adapter status changes. 
 */
@Override public void onStatusChanged(int which){
  getActivity().runOnUiThread(new Runnable(){
    @Override public void run(){
      boolean syncActive=ContentResolver.isSyncActive(OUser.current(getActivity()).getAccount(),syncStatusObserverModel.authority());
      boolean syncPending=ContentResolver.isSyncPending(OUser.current(getActivity()).getAccount(),syncStatusObserverModel.authority());
      boolean refreshing=syncActive | syncPending;
      if (!refreshing) {
      }
      mSyncStatusObserverListener.onStatusChange(refreshing);
    }
  }
);
}","/** 
 * Callback invoked with the sync adapter status changes. 
 */
@Override public void onStatusChanged(int which){
  getActivity().runOnUiThread(new Runnable(){
    @Override public void run(){
      boolean syncActive=ContentResolver.isSyncActive(OUser.current(mContext).getAccount(),syncStatusObserverModel.authority());
      boolean syncPending=ContentResolver.isSyncPending(OUser.current(mContext).getAccount(),syncStatusObserverModel.authority());
      boolean refreshing=syncActive | syncPending;
      if (!refreshing) {
      }
      mSyncStatusObserverListener.onStatusChange(refreshing);
    }
  }
);
}",0.6720257234726688
80018,"public int _c(int res_id){
  return OResource.color(getActivity(),res_id);
}","public int _c(int res_id){
  return OResource.color(mContext,res_id);
}",0.8843537414965986
80019,"public int _dim(int res_id){
  return OResource.dimen(getActivity(),res_id);
}","public int _dim(int res_id){
  return OResource.dimen(mContext,res_id);
}",0.8874172185430463
80020,"public boolean inNetwork(){
  App app=(App)getActivity().getApplicationContext();
  return app.inNetwork();
}","public boolean inNetwork(){
  App app=(App)mContext.getApplicationContext();
  return app.inNetwork();
}",0.92018779342723
80021,"public String _s(int res_id){
  return OResource.string(getActivity(),res_id);
}","public String _s(int res_id){
  return OResource.string(mContext,res_id);
}",0.8903225806451613
80022,"public OUser user(){
  if (getActivity() != null)   return OUser.current(getActivity());
  return null;
}","public OUser user(){
  if (mContext != null)   return OUser.current(mContext);
  return null;
}",0.83
80023,"public OModel db(){
  Class<?> model=database();
  if (model != null) {
    return new OModel(getActivity(),null,user()).createInstance(model);
  }
  return null;
}","public OModel db(){
  Class<?> model=database();
  if (model != null) {
    return new OModel(mContext,null,user()).createInstance(model);
  }
  return null;
}",0.9473684210526316
80024,"public Odoo createInstance(){
  Odoo odoo=null;
  OUser user=OUser.current(getApplicationContext());
  if (user != null) {
    try {
      if (user.isOAauthLogin()) {
        odoo=new Odoo(user.getInstanceUrl(),user.isAllowSelfSignedSSL());
        OdooInstance instance=new OdooInstance();
        instance.setInstanceUrl(user.getInstanceUrl());
        instance.setDatabaseName(user.getInstanceDatabase());
        instance.setClientId(user.getClientId());
        odoo.oauth_authenticate(instance,user.getUsername(),user.getPassword());
      }
 else {
        odoo=new Odoo(user.getHost(),user.isAllowSelfSignedSSL());
        odoo.authenticate(user.getUsername(),user.getPassword(),user.getDatabase());
      }
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
  }
  return odoo;
}","public Odoo createInstance(){
  Odoo odoo=null;
  OUser user=OUser.current(getApplicationContext());
  if (user != null) {
    try {
      if (user.isOAauthLogin()) {
        odoo=new Odoo(user.getInstanceUrl(),user.isAllowSelfSignedSSL());
        OdooInstance instance=new OdooInstance();
        instance.setInstanceUrl(user.getInstanceUrl());
        instance.setDatabaseName(user.getInstanceDatabase());
        instance.setClientId(user.getClientId());
        odoo.oauth_authenticate(instance,user.getUsername(),user.getPassword());
      }
 else {
        odoo=new Odoo(user.getHost(),user.isAllowSelfSignedSSL());
        odoo.authenticate(user.getUsername(),user.getPassword(),user.getDatabase());
      }
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
  }
  mOdooInstance=odoo;
  return odoo;
}",0.986469864698647
80025,"/** 
 * Removes the account.
 * @param context the context
 * @param username the username
 */
public static void removeAccount(Context context,String username){
  AccountManager accMgr=AccountManager.get(context);
  accMgr.removeAccount(OpenERPAccountManager.getAccount(context,username),null,null);
  App app=(App)context.getApplicationContext();
  app.setOEInstance(null);
  current_user=null;
}","/** 
 * Removes the account.
 * @param context the context
 * @param username the username 
 */
public static void removeAccount(Context context,String username){
  AccountManager accMgr=AccountManager.get(context);
  accMgr.removeAccount(OpenERPAccountManager.getAccount(context,username),null,null);
  App app=(App)context.getApplicationContext();
  app.setOEInstance(null);
  current_user=null;
}",0.998745294855709
80026,"private static boolean cancelAllSync(Account account){
  SyncWizardValues syncVals=new SyncWizardValues();
  boolean flag=false;
  for (  SyncValue sync : syncVals.syncValues()) {
    ContentResolver.cancelSync(account,sync.getAuthority());
    flag=true;
  }
  return flag;
}","private static boolean cancelAllSync(Account account){
  SyncWizardValues syncVals=new SyncWizardValues();
  for (  SyncValue sync : syncVals.syncValues()) {
    ContentResolver.cancelSync(account,sync.getAuthority());
  }
  return true;
}",0.8854368932038835
80027,"private void updateSyncSettings(){
  Log.d(TAG,""String_Node_Str"");
  PreferenceManager mPref=new PreferenceManager(mContext);
  int sync_interval=mPref.getInt(""String_Node_Str"",1440);
  List<String> default_authorities=new ArrayList<String>();
  default_authorities.add(""String_Node_Str"");
  default_authorities.add(""String_Node_Str"");
  SyncAdapterType[] list=ContentResolver.getSyncAdapterTypes();
  Account mAccount=OpenERPAccountManager.getAccount(mContext,OEUser.current(mContext).getAndroidName());
  for (  SyncAdapterType lst : list) {
    if (lst.authority.contains(""String_Node_Str"")) {
      default_authorities.add(lst.authority);
    }
  }
  for (  String authority : default_authorities) {
    boolean isSyncActive=ContentResolver.getSyncAutomatically(mAccount,authority);
    if (isSyncActive) {
      setSyncPeriodic(authority,sync_interval,1,1);
    }
  }
  Toast.makeText(this,R.string.toast_setting_saved,Toast.LENGTH_LONG).show();
}","private void updateSyncSettings(){
  Log.d(TAG,""String_Node_Str"");
  PreferenceManager mPref=new PreferenceManager(mContext);
  int sync_interval=mPref.getInt(""String_Node_Str"",1440);
  List<String> default_authorities=new ArrayList<String>();
  default_authorities.add(""String_Node_Str"");
  default_authorities.add(""String_Node_Str"");
  SyncAdapterType[] list=ContentResolver.getSyncAdapterTypes();
  Account mAccount=OpenERPAccountManager.getAccount(mContext,OEUser.current(mContext).getAndroidName());
  for (  SyncAdapterType lst : list) {
    if (lst.authority.contains(""String_Node_Str"") && lst.authority.contains(""String_Node_Str"")) {
      default_authorities.add(lst.authority);
    }
  }
  for (  String authority : default_authorities) {
    boolean isSyncActive=ContentResolver.getSyncAutomatically(mAccount,authority);
    if (isSyncActive) {
      setSyncPeriodic(authority,sync_interval,60,1);
    }
  }
  Toast.makeText(this,R.string.toast_setting_saved,Toast.LENGTH_LONG).show();
}",0.9753846153846154
80028,"private void initDrawer(List<DrawerItem> drawerItems){
  Res_PartnerDBHelper partner=new Res_PartnerDBHelper(context);
  Object obj=partner.search(partner,new String[]{""String_Node_Str""},new String[]{""String_Node_Str""},new String[]{OEUser.current(context).getPartner_id()}).get(""String_Node_Str"");
  String user_name=""String_Node_Str"";
  if (obj instanceof Boolean) {
    user_name=OEUser.current(context).getUsername();
  }
 else {
    user_name=((List<HashMap<String,Object>>)obj).get(0).get(""String_Node_Str"").toString();
  }
  mDrawerTitle=user_name;
  mDrawerSubtitle=OEUser.current(context).getHost();
  getActionBar().setHomeButtonEnabled(true);
  getActionBar().setDisplayHomeAsUpEnabled(true);
  setDrawerItems(drawerItems);
  if (mDrawerItemSelectedPosition > 0) {
    mAppTitle=mDrawerListItems.get(mDrawerItemSelectedPosition).getTitle();
    setTitle(mAppTitle);
  }
}","private void initDrawer(List<DrawerItem> drawerItems){
  if (OEUser.current(context) != null) {
    Res_PartnerDBHelper partner=new Res_PartnerDBHelper(context);
    Object obj=partner.search(partner,new String[]{""String_Node_Str""},new String[]{""String_Node_Str""},new String[]{OEUser.current(context).getPartner_id()}).get(""String_Node_Str"");
    String user_name=""String_Node_Str"";
    if (obj instanceof Boolean) {
      user_name=OEUser.current(context).getUsername();
    }
 else {
      user_name=((List<HashMap<String,Object>>)obj).get(0).get(""String_Node_Str"").toString();
    }
    mDrawerTitle=user_name;
    mDrawerSubtitle=OEUser.current(context).getHost();
    getActionBar().setHomeButtonEnabled(true);
    getActionBar().setDisplayHomeAsUpEnabled(true);
    setDrawerItems(drawerItems);
    if (mDrawerItemSelectedPosition > 0) {
      mAppTitle=mDrawerListItems.get(mDrawerItemSelectedPosition).getTitle();
      setTitle(mAppTitle);
    }
  }
}",0.9570885388375884
80029,"private void initDrawer(List<DrawerItem> drawerItems){
  Res_PartnerDBHelper partner=new Res_PartnerDBHelper(context);
  Object obj=partner.search(partner,new String[]{""String_Node_Str""},new String[]{""String_Node_Str""},new String[]{OEUser.current(context).getPartner_id()}).get(""String_Node_Str"");
  String user_name=""String_Node_Str"";
  if (obj instanceof Boolean) {
    user_name=OEUser.current(context).getUsername();
  }
 else {
    user_name=((List<HashMap<String,Object>>)obj).get(0).get(""String_Node_Str"").toString();
  }
  mDrawerTitle=user_name;
  mDrawerSubtitle=OEUser.current(context).getHost();
  getActionBar().setHomeButtonEnabled(true);
  getActionBar().setDisplayHomeAsUpEnabled(true);
  setDrawerItems(drawerItems);
}","private void initDrawer(List<DrawerItem> drawerItems){
  Res_PartnerDBHelper partner=new Res_PartnerDBHelper(context);
  Object obj=partner.search(partner,new String[]{""String_Node_Str""},new String[]{""String_Node_Str""},new String[]{OEUser.current(context).getPartner_id()}).get(""String_Node_Str"");
  String user_name=""String_Node_Str"";
  if (obj instanceof Boolean) {
    user_name=OEUser.current(context).getUsername();
  }
 else {
    user_name=((List<HashMap<String,Object>>)obj).get(0).get(""String_Node_Str"").toString();
  }
  mDrawerTitle=user_name;
  mDrawerSubtitle=OEUser.current(context).getHost();
  getActionBar().setHomeButtonEnabled(true);
  getActionBar().setDisplayHomeAsUpEnabled(true);
  setDrawerItems(drawerItems);
  if (mDrawerItemSelectedPosition > 0) {
    mAppTitle=mDrawerListItems.get(mDrawerItemSelectedPosition).getTitle();
    setTitle(mAppTitle);
  }
}",0.9096534653465348
80030,"@Override public void onStart(){
  super.onStart();
  mDrawerListView.setOnItemClickListener(this);
  int position=-1;
  if (mDrawerListItems.size() > 0) {
    if (!mDrawerListItems.get(0).isGroupTitle()) {
      mDrawerListView.setItemChecked(0,true);
      position=0;
    }
 else {
      mDrawerListView.setItemChecked(1,true);
      position=1;
    }
  }
  if (mDrawerItemSelectedPosition >= 0) {
    position=mDrawerItemSelectedPosition;
  }
  if (getIntent().getAction() != null && !getIntent().getAction().toString().equalsIgnoreCase(""String_Node_Str"")) {
    if (getIntent().getAction().toString().equalsIgnoreCase(""String_Node_Str"")) {
      startActivity(new Intent(context,MessageComposeActivty.class));
    }
    if (getIntent().getAction().toString().equalsIgnoreCase(""String_Node_Str"")) {
      startActivity(new Intent(context,ComposeNoteActivity.class));
    }
  }
 else {
    if (position > 0) {
      loadFragment(mDrawerListItems.get(position));
    }
  }
}","@Override public void onStart(){
  super.onStart();
  mDrawerListView.setOnItemClickListener(this);
  int position=-1;
  if (mDrawerListItems.size() > 0) {
    if (!mDrawerListItems.get(0).isGroupTitle()) {
      mDrawerListView.setItemChecked(0,true);
      position=0;
    }
 else {
      mDrawerListView.setItemChecked(1,true);
      position=1;
    }
  }
  if (mDrawerItemSelectedPosition >= 0) {
    position=mDrawerItemSelectedPosition;
  }
  if (getIntent().getAction() != null && !getIntent().getAction().toString().equalsIgnoreCase(""String_Node_Str"")) {
    if (getIntent().getAction().toString().equalsIgnoreCase(""String_Node_Str"")) {
      startActivity(new Intent(context,MessageComposeActivty.class));
    }
    if (getIntent().getAction().toString().equalsIgnoreCase(""String_Node_Str"")) {
      startActivity(new Intent(context,ComposeNoteActivity.class));
    }
  }
 else {
    if (position > 0) {
      if (position != mDrawerItemSelectedPosition) {
        loadFragment(mDrawerListItems.get(position));
      }
    }
  }
}",0.9687344913151364
80031,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_main);
  context=this;
  if (isStateExist == null) {
    NoteDBHelper db=new NoteDBHelper(context);
    isStateExist=String.valueOf(db.isPadExist());
  }
  if (findViewById(R.id.fragment_container) != null) {
    initDrawerControls();
    fragmentHandler=new FragmentHandler(this);
    boot=new Boot(this);
    if (savedInstanceState != null) {
      mPullToRefreshAttacher=new PullToRefreshAttacher(this);
      initDrawer(boot.getDrawerItems());
      return;
    }
    if (OpenERPAccountManager.hasAccounts(this) == false) {
      getActionBar().setDisplayHomeAsUpEnabled(false);
      getActionBar().setHomeButtonEnabled(false);
      lockDrawer(true);
      Fragment fragment=new AccountFragment();
      fragmentHandler.setBackStack(true,null);
      fragmentHandler.startNewFragmnet(fragment);
      return;
    }
 else {
      lockDrawer(false);
      Intent intent=getIntent();
      boolean reqForNewAccount=intent.getBooleanExtra(""String_Node_Str"",false);
      if (OpenERPAccountManager.isAnyUser(this) && !reqForNewAccount) {
        initDrawer(boot.getDrawerItems());
        mPullToRefreshAttacher=new PullToRefreshAttacher(this);
        if (savedInstanceState != null) {
          return;
        }
      }
 else {
        if (reqForNewAccount) {
          getActionBar().setDisplayHomeAsUpEnabled(false);
          getActionBar().setHomeButtonEnabled(false);
          Fragment fragment=new AccountFragment();
          fragmentHandler.startNewFragmnet(fragment);
          return;
        }
 else {
          Dialog dialog=onCreateDialogSingleChoice();
          dialog.setCancelable(false);
          dialog.show();
        }
      }
    }
  }
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_main);
  context=this;
  if (isStateExist == null) {
    NoteDBHelper db=new NoteDBHelper(context);
    isStateExist=String.valueOf(db.isPadExist());
  }
  if (findViewById(R.id.fragment_container) != null) {
    initDrawerControls();
    fragmentHandler=new FragmentHandler(this);
    boot=new Boot(this);
    if (savedInstanceState != null) {
      mDrawerItemSelectedPosition=savedInstanceState.getInt(""String_Node_Str"");
      mPullToRefreshAttacher=new PullToRefreshAttacher(this);
      initDrawer(boot.getDrawerItems());
      return;
    }
    if (OpenERPAccountManager.hasAccounts(this) == false) {
      getActionBar().setDisplayHomeAsUpEnabled(false);
      getActionBar().setHomeButtonEnabled(false);
      lockDrawer(true);
      Fragment fragment=new AccountFragment();
      fragmentHandler.setBackStack(true,null);
      fragmentHandler.startNewFragmnet(fragment);
      return;
    }
 else {
      lockDrawer(false);
      Intent intent=getIntent();
      boolean reqForNewAccount=intent.getBooleanExtra(""String_Node_Str"",false);
      if (OpenERPAccountManager.isAnyUser(this) && !reqForNewAccount) {
        initDrawer(boot.getDrawerItems());
        mPullToRefreshAttacher=new PullToRefreshAttacher(this);
        if (savedInstanceState != null) {
          return;
        }
      }
 else {
        if (reqForNewAccount) {
          getActionBar().setDisplayHomeAsUpEnabled(false);
          getActionBar().setHomeButtonEnabled(false);
          Fragment fragment=new AccountFragment();
          fragmentHandler.startNewFragmnet(fragment);
          return;
        }
 else {
          Dialog dialog=onCreateDialogSingleChoice();
          dialog.setCancelable(false);
          dialog.show();
        }
      }
    }
  }
}",0.9782608695652174
80032,"@Override public OEMenu menuHelper(Context context){
  OEMenu menu=new OEMenu();
  menu.setId(1);
  menu.setMenuTitle(""String_Node_Str"");
  setNoteStages(context);
  List<OEMenuItems> items=new ArrayList<OEMenuItems>();
  items.add(new OEMenuItems(""String_Node_Str"",getFragBundle(""String_Node_Str"",""String_Node_Str""),getCount(""String_Node_Str"",context)));
  items.add(new OEMenuItems(""String_Node_Str"",getFragBundle(""String_Node_Str"",""String_Node_Str""),0));
  if (stages != null) {
    int i=0;
    for (    String key : stages.keySet()) {
      if (i > tag_colors.length - 1) {
        i=0;
      }
      OEMenuItems stageMenu=new OEMenuItems(stages.get(key).toString(),getFragBundle(""String_Node_Str"",key),getCount(key,context));
      stageMenu.setAutoMenuTagColor(true);
      stageMenu.setMenuTagColor(Color.parseColor(tag_colors[i]));
      stage_colors.put(""String_Node_Str"" + key,stageMenu.getMenuTagColor());
      items.add(stageMenu);
      i++;
    }
  }
  menu.setMenuItems(items);
  return menu;
}","@Override public OEMenu menuHelper(Context context){
  db=(NoteDBHelper)databaseHelper(context);
  if (db.getOEInstance().isInstalled(""String_Node_Str"")) {
    OEMenu menu=new OEMenu();
    menu.setId(1);
    menu.setMenuTitle(""String_Node_Str"");
    setNoteStages(context);
    List<OEMenuItems> items=new ArrayList<OEMenuItems>();
    items.add(new OEMenuItems(""String_Node_Str"",getFragBundle(""String_Node_Str"",""String_Node_Str""),getCount(""String_Node_Str"",context)));
    items.add(new OEMenuItems(""String_Node_Str"",getFragBundle(""String_Node_Str"",""String_Node_Str""),0));
    if (stages != null) {
      int i=0;
      for (      String key : stages.keySet()) {
        if (i > tag_colors.length - 1) {
          i=0;
        }
        OEMenuItems stageMenu=new OEMenuItems(stages.get(key).toString(),getFragBundle(""String_Node_Str"",key),getCount(key,context));
        stageMenu.setAutoMenuTagColor(true);
        stageMenu.setMenuTagColor(Color.parseColor(tag_colors[i]));
        stage_colors.put(""String_Node_Str"" + key,stageMenu.getMenuTagColor());
        items.add(stageMenu);
        i++;
      }
    }
    menu.setMenuItems(items);
    return menu;
  }
 else {
    return null;
  }
}",0.8694469628286491
80033,"public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  setHasOptionsMenu(true);
  scope=new AppScope(MainActivity.userContext,(MainActivity)getActivity());
  db=(NoteDBHelper)getModel();
  rootView=inflater.inflate(R.layout.fragment_note,container,false);
  lstNotes=(ListView)rootView.findViewById(R.id.lstNotes);
  emptyNotesText=(TextView)rootView.findViewById(R.id.txvNoteAllArchive);
  handleArguments((Bundle)getArguments());
  return rootView;
}","public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  scope=new AppScope(MainActivity.userContext,(MainActivity)getActivity());
  db=(NoteDBHelper)getModel();
  setHasOptionsMenu(true);
  rootView=inflater.inflate(R.layout.fragment_note,container,false);
  lstNotes=(ListView)rootView.findViewById(R.id.lstNotes);
  emptyNotesText=(TextView)rootView.findViewById(R.id.txvNoteAllArchive);
  handleArguments((Bundle)getArguments());
  return rootView;
}",0.9455645161290324
80034,"/** 
 * Load base modules.
 */
private void loadBaseModules(){
  this.modules.add(new Module(""String_Node_Str"",""String_Node_Str"",new ResFragment(),0));
  this.modules.add(new Module(""String_Node_Str"",""String_Node_Str"",new AttachmentFragment(),0));
}","/** 
 * Load base modules.
 */
private void loadBaseModules(){
  this.modules.add(new Module(""String_Node_Str"",""String_Node_Str"",new ResFragment(),0));
  this.modules.add(new Module(""String_Node_Str"",""String_Node_Str"",new AttachmentFragment(),0));
  this.modules.add(new Module(""String_Node_Str"",""String_Node_Str"",new Ir_modelFragment(),0));
}",0.8412162162162162
80035,"/** 
 * Sets the stroke that will be used to draw shapes.  
 * @param s  the stroke ({@code null} not permitted).
 * @see #getStroke() 
 */
@Override public void setStroke(Stroke s){
  nullNotPermitted(s,""String_Node_Str"");
  if (s == this.stroke) {
    return;
  }
  if (stroke instanceof BasicStroke) {
    BasicStroke bs=(BasicStroke)s;
    if (bs.equals(this.stroke)) {
      return;
    }
    double lineWidth=bs.getLineWidth();
    if (lineWidth == 0.0) {
      lineWidth=this.zeroStrokeWidth;
    }
    this.gc.setLineWidth(lineWidth);
    this.gc.setLineCap(awtToJavaFXLineCap(bs.getEndCap()));
    this.gc.setLineJoin(awtToJavaFXLineJoin(bs.getLineJoin()));
    this.gc.setMiterLimit(bs.getMiterLimit());
    this.gc.setLineDashes(floatToDoubleArray(bs.getDashArray()));
    this.gc.setLineDashOffset(bs.getDashPhase());
  }
  this.stroke=s;
}","/** 
 * Sets the stroke that will be used to draw shapes.  
 * @param s  the stroke ({@code null} not permitted).
 * @see #getStroke() 
 */
@Override public void setStroke(Stroke s){
  nullNotPermitted(s,""String_Node_Str"");
  if (s == this.stroke) {
    return;
  }
  if (stroke instanceof BasicStroke) {
    BasicStroke bs=(BasicStroke)s;
    if (bs.equals(this.stroke)) {
      return;
    }
  }
  this.stroke=s;
  applyStroke(s);
}",0.6189735614307932
80036,"/** 
 * Sets the paint used to draw or fill shapes (or text).  If   {@code paint} is an instance of {@code Color}, this method will also update the current color attribute (see   {@link #getColor()}). If  you pass   {@code null} to this method, it does nothing (in accordance with the JDK specification). <br><br> Note that this implementation will map  {@link Color},   {@link GradientPaint},   {@link LinearGradientPaint} and {@link RadialGradientPaint} to JavaFX equivalents, other paint implementations are not handled.
 * @param paint  the paint ({@code null} is permitted but ignored).
 * @see #getPaint() 
 */
@Override public void setPaint(Paint paint){
  if (paint == null) {
    return;
  }
  if (paintsAreEqual(paint,this.paint)) {
    return;
  }
  this.paint=paint;
  if (paint instanceof Color) {
    setColor((Color)paint);
  }
 else   if (paint instanceof GradientPaint) {
    GradientPaint gp=(GradientPaint)paint;
    Stop[] stops=new Stop[]{new Stop(0,awtColorToJavaFX(gp.getColor1())),new Stop(1,awtColorToJavaFX(gp.getColor2()))};
    Point2D p1=gp.getPoint1();
    Point2D p2=gp.getPoint2();
    LinearGradient lg=new LinearGradient(p1.getX(),p1.getY(),p2.getX(),p2.getY(),false,CycleMethod.NO_CYCLE,stops);
    this.gc.setStroke(lg);
    this.gc.setFill(lg);
  }
 else   if (paint instanceof MultipleGradientPaint) {
    MultipleGradientPaint mgp=(MultipleGradientPaint)paint;
    Color[] colors=mgp.getColors();
    float[] fractions=mgp.getFractions();
    Stop[] stops=new Stop[colors.length];
    for (int i=0; i < colors.length; i++) {
      stops[i]=new Stop(fractions[i],awtColorToJavaFX(colors[i]));
    }
    if (paint instanceof RadialGradientPaint) {
      RadialGradientPaint rgp=(RadialGradientPaint)paint;
      Point2D center=rgp.getCenterPoint();
      Point2D focus=rgp.getFocusPoint();
      double focusDistance=focus.distance(center);
      double focusAngle=0.0;
      if (!focus.equals(center)) {
        focusAngle=Math.atan2(focus.getY() - center.getY(),focus.getX() - center.getX());
      }
      double radius=rgp.getRadius();
      RadialGradient rg=new RadialGradient(Math.toDegrees(focusAngle),focusDistance,center.getX(),center.getY(),radius,false,CycleMethod.NO_CYCLE,stops);
      this.gc.setStroke(rg);
      this.gc.setFill(rg);
    }
 else     if (paint instanceof LinearGradientPaint) {
      LinearGradientPaint lgp=(LinearGradientPaint)paint;
      Point2D start=lgp.getStartPoint();
      Point2D end=lgp.getEndPoint();
      LinearGradient lg=new LinearGradient(start.getX(),start.getY(),end.getX(),end.getY(),false,CycleMethod.NO_CYCLE,stops);
      this.gc.setStroke(lg);
      this.gc.setFill(lg);
    }
  }
 else {
  }
}","/** 
 * Sets the paint used to draw or fill shapes (or text).  If   {@code paint} is an instance of {@code Color}, this method will also update the current color attribute (see   {@link #getColor()}). If  you pass   {@code null} to this method, it does nothing (in accordance with the JDK specification). <br><br> Note that this implementation will map  {@link Color},   {@link GradientPaint},   {@link LinearGradientPaint} and {@link RadialGradientPaint} to JavaFX equivalents, other paint implementations are not handled.
 * @param paint  the paint ({@code null} is permitted but ignored).
 * @see #getPaint() 
 */
@Override public void setPaint(Paint paint){
  if (paint == null) {
    return;
  }
  if (paintsAreEqual(paint,this.paint)) {
    return;
  }
  applyPaint(paint);
}",0.4398962236955895
80037,"private void reapplyAttributes(){
  if (!paintsAreEqual(this.paint,this.savedPaint)) {
    setPaint(this.savedPaint);
  }
  if (!this.color.equals(this.savedColor)) {
    setColor(this.savedColor);
  }
  if (!this.stroke.equals(this.savedColor)) {
    setStroke(this.savedStroke);
  }
  if (!this.font.equals(this.savedFont)) {
    setFont(this.savedFont);
  }
  if (!this.transform.equals(this.savedTransform)) {
    setTransform(this.transform);
  }
  this.savedColor=null;
  this.savedFont=null;
  this.savedPaint=null;
  this.savedStroke=null;
  this.savedTransform=null;
}","private void reapplyAttributes(){
  if (!paintsAreEqual(this.paint,this.savedPaint)) {
    applyPaint(this.paint);
  }
  if (!this.color.equals(this.savedColor)) {
    applyColor(this.color);
  }
  if (!this.stroke.equals(this.savedStroke)) {
    applyStroke(this.stroke);
  }
  if (!this.font.equals(this.savedFont)) {
    applyFont(this.font);
  }
  if (!this.transform.equals(this.savedTransform)) {
    setTransform(this.transform);
  }
  this.savedColor=null;
  this.savedFont=null;
  this.savedPaint=null;
  this.savedStroke=null;
  this.savedTransform=null;
}",0.9396325459317584
80038,"/** 
 * Sets the foreground color.  This method exists for backwards  compatibility in AWT, you should use the   {@link #setPaint(java.awt.Paint)} method.
 * @param c  the color ({@code null} permitted but ignored). 
 * @see #setPaint(java.awt.Paint) 
 */
@Override public void setColor(Color c){
  if (c == null || c.equals(this.color)) {
    return;
  }
  this.color=c;
  this.paint=c;
  javafx.scene.paint.Color fxcolor=awtColorToJavaFX(c);
  this.gc.setFill(fxcolor);
  this.gc.setStroke(fxcolor);
}","/** 
 * Sets the foreground color.  This method exists for backwards  compatibility in AWT, you should use the   {@link #setPaint(java.awt.Paint)} method.
 * @param c  the color ({@code null} permitted but ignored). 
 * @see #setPaint(java.awt.Paint) 
 */
@Override public void setColor(Color c){
  if (c == null || c.equals(this.color)) {
    return;
  }
  applyColor(c);
}",0.8232611174458381
80039,"/** 
 * Creates a new   {@link GraphiteReporter}.
 * @param metricsRegistry the metrics registry
 * @param prefix          is prepended to all names reported to graphite
 * @param predicate       filters metrics to be reported
 * @param dimensions      enum of enabled dimensions to include
 * @param socketProvider  a {@link SocketProvider} instance
 * @param clock           a {@link Clock} instance
 * @throws IOException if there is an error connecting to the Graphite server
 */
public FilteredGraphiteReporter(MetricsRegistry metricsRegistry,String prefix,MetricPredicate predicate,EnumSet<Dimension> dimensions,SocketProvider socketProvider,Clock clock) throws IOException {
  super(metricsRegistry,prefix,predicate,socketProvider,clock);
  this.dimensions=dimensions;
  LOGGER.error(""String_Node_Str"",dimensions);
}","/** 
 * Creates a new   {@link GraphiteReporter}.
 * @param metricsRegistry the metrics registry
 * @param prefix          is prepended to all names reported to graphite
 * @param predicate       filters metrics to be reported
 * @param dimensions      enum of enabled dimensions to include
 * @param socketProvider  a {@link SocketProvider} instance
 * @param clock           a {@link Clock} instance
 * @throws IOException if there is an error connecting to the Graphite server
 */
public FilteredGraphiteReporter(MetricsRegistry metricsRegistry,String prefix,MetricPredicate predicate,EnumSet<Dimension> dimensions,SocketProvider socketProvider,Clock clock) throws IOException {
  super(metricsRegistry,prefix,predicate,socketProvider,clock);
  this.dimensions=dimensions;
  LOGGER.debug(""String_Node_Str"",dimensions);
}",0.993924665856622
80040,"private static void processEvent3(String raw){
  Optional<RawEvent> rawEvent=RawEvent.parse(raw);
  rawEvent.ifPresent(r -> {
    String[] conditions={};
    EnrichedEvent enriched=new EnrichedEvent(r,20.0d,conditions);
    System.out.println(enriched.asJson());
  }
);
}","private static void processEvent3(String raw){
  Optional<RawEvent> rawEvent=RawEvent.parse(raw);
  rawEvent.ifPresent(r -> {
    List<String> conditions=new ArrayList<String>();
    EnrichedEvent enriched=new EnrichedEvent(r,20.0d,conditions);
    System.out.println(enriched.asJson());
  }
);
}",0.9417989417989416
80041,"protected <T>T readObject(JsonReaderI<T> mapper) throws ParseException, IOException {
  if (c != '{')   throw new RuntimeException(""String_Node_Str"");
  Object current=mapper.createObject();
  boolean needData=false;
  boolean acceptData=true;
  for (; ; ) {
    read();
switch (c) {
case ' ':
case '\r':
case '\t':
case '\n':
      continue;
case ':':
case ']':
case '[':
case '{':
    throw new ParseException(pos,ERROR_UNEXPECTED_CHAR,c);
case '}':
  if (needData && !acceptUselessComma)   throw new ParseException(pos,ERROR_UNEXPECTED_CHAR,(char)c);
read();
return mapper.convert(current);
case ',':
if (needData && !acceptUselessComma) throw new ParseException(pos,ERROR_UNEXPECTED_CHAR,(char)c);
acceptData=needData=true;
continue;
case '""':
case '\'':
default :
if (c == '\""' || c == '\'') {
readString();
}
 else {
readNQString(stopKey);
if (!acceptNonQuote) throw new ParseException(pos,ERROR_UNEXPECTED_TOKEN,xs);
}
String key=xs;
if (!acceptData) throw new ParseException(pos,ERROR_UNEXPECTED_TOKEN,key);
skipSpace();
if (c != ':') {
if (c == EOI) throw new ParseException(pos - 1,ERROR_UNEXPECTED_EOF,null);
throw new ParseException(pos - 1,ERROR_UNEXPECTED_CHAR,c);
}
readNoEnd();
lastKey=key;
Object value=readMain(mapper,stopValue);
mapper.setValue(current,key,value);
lastKey=null;
if (c == '}') {
read();
return mapper.convert(current);
}
if (c == EOI) throw new ParseException(pos - 1,ERROR_UNEXPECTED_EOF,null);
if (c == ',') acceptData=needData=true;
 else acceptData=needData=false;
continue;
}
}
}","protected <T>T readObject(JsonReaderI<T> mapper) throws ParseException, IOException {
  if (c != '{')   throw new RuntimeException(""String_Node_Str"");
  Object current=mapper.createObject();
  boolean needData=false;
  boolean acceptData=true;
  for (; ; ) {
    read();
switch (c) {
case ' ':
case '\r':
case '\t':
case '\n':
      continue;
case ':':
case ']':
case '[':
case '{':
    throw new ParseException(pos,ERROR_UNEXPECTED_CHAR,c);
case '}':
  if (needData && !acceptUselessComma)   throw new ParseException(pos,ERROR_UNEXPECTED_CHAR,(char)c);
read();
return mapper.convert(current);
case ',':
if (needData && !acceptUselessComma) throw new ParseException(pos,ERROR_UNEXPECTED_CHAR,(char)c);
acceptData=needData=true;
continue;
case '""':
case '\'':
default :
if (c == '\""' || c == '\'') {
readString();
}
 else {
readNQString(stopKey);
if (!acceptNonQuote) throw new ParseException(pos,ERROR_UNEXPECTED_TOKEN,xs);
}
String key=xs;
if (!acceptData) throw new ParseException(pos,ERROR_UNEXPECTED_TOKEN,key);
skipSpace();
if (c != ':') {
if (c == EOI) throw new ParseException(pos - 1,ERROR_UNEXPECTED_EOF,null);
throw new ParseException(pos - 1,ERROR_UNEXPECTED_CHAR,c);
}
readNoEnd();
lastKey=key;
Object value=readMain(mapper,stopValue);
mapper.setValue(current,key,value);
lastKey=null;
skipSpace();
if (c == '}') {
read();
return mapper.convert(current);
}
if (c == EOI) throw new ParseException(pos - 1,ERROR_UNEXPECTED_EOF,null);
if (c == ',') acceptData=needData=true;
 else throw new ParseException(pos - 1,ERROR_UNEXPECTED_TOKEN,c);
}
}
}",0.9655172413793104
80042,"public boolean mustBeProtect(final String s){
  if (s == null)   return false;
  int len=s.length();
  if (len == 0)   return true;
  if (s.trim() != s)   return true;
  char ch=s.charAt(0);
  if (isSpecial(ch) || isUnicode(ch))   return true;
  for (int i=1; i < len; i++) {
    ch=s.charAt(i);
    if (isSpecialClose(ch) || isUnicode(ch))     return true;
  }
  if (isKeyword(s))   return true;
  ch=s.charAt(0);
  if (ch >= '0' && ch <= '9' || ch == '-') {
    int p=1;
    for (; p < len; p++) {
      ch=s.charAt(p);
      if (ch < '0' || ch > '9')       break;
    }
    if (p == len)     return true;
    if (ch == '.') {
      p++;
      for (; p < len; p++) {
        ch=s.charAt(p);
        if (ch < '0' || ch > '9')         break;
      }
    }
    if (p == len)     return true;
    if (ch != 'E' || ch != 'e')     return false;
    p++;
    if (p == len)     return false;
    ch=s.charAt(p);
    if (ch == '+' || ch == '-') {
      ch++;
      if (p == len)       return false;
      ch=s.charAt(p);
    }
    if (ch == '+' || ch == '-') {
      ch++;
      if (p == len)       return false;
    }
    for (; p < len; p++) {
      ch=s.charAt(p);
      if (ch < '0' || ch > '9')       break;
    }
    if (p == len)     return true;
    return false;
  }
  return false;
}","public boolean mustBeProtect(final String s){
  if (s == null)   return false;
  int len=s.length();
  if (len == 0)   return true;
  if (s.trim() != s)   return true;
  char ch=s.charAt(0);
  if (isSpecial(ch) || isUnicode(ch))   return true;
  for (int i=1; i < len; i++) {
    ch=s.charAt(i);
    if (isSpecialClose(ch) || isUnicode(ch))     return true;
  }
  if (isKeyword(s))   return true;
  ch=s.charAt(0);
  if (ch >= '0' && ch <= '9' || ch == '-') {
    int p=1;
    for (; p < len; p++) {
      ch=s.charAt(p);
      if (ch < '0' || ch > '9')       break;
    }
    if (p == len)     return true;
    if (ch == '.') {
      p++;
    }
    for (; p < len; p++) {
      ch=s.charAt(p);
      if (ch < '0' || ch > '9')       break;
    }
    if (p == len)     return true;
    if (ch == 'E' || ch == 'e') {
      p++;
      if (p == len)       return false;
      ch=s.charAt(p);
      if (ch == '+' || ch == '-') {
        p++;
        ch=s.charAt(p);
      }
    }
    if (p == len)     return false;
    for (; p < len; p++) {
      ch=s.charAt(p);
      if (ch < '0' || ch > '9')       break;
    }
    if (p == len)     return true;
    return false;
  }
  return false;
}",0.6467017401861594
80043,"public static void testInvalidJson(String json,int permissifMode,int execptionType,Class<?> cls) throws Exception {
  JSONParser p=new JSONParser(execptionType);
  try {
    if (cls == null)     p.parse(json);
 else     p.parse(json,cls);
    TestCase.assertFalse(""String_Node_Str"" + json,true);
  }
 catch (  ParseException e) {
    if (execptionType == -1)     execptionType=e.getErrorType();
    TestCase.assertEquals(execptionType,e.getErrorType());
  }
}","public static void testInvalidJson(String json,int permissifMode,int execptionType,Class<?> cls) throws Exception {
  JSONParser p=new JSONParser(permissifMode);
  try {
    if (cls == null)     p.parse(json);
 else     p.parse(json,cls);
    TestCase.assertFalse(""String_Node_Str"" + json,true);
  }
 catch (  ParseException e) {
    if (execptionType == -1)     execptionType=e.getErrorType();
    TestCase.assertEquals(execptionType,e.getErrorType());
  }
}",0.9738562091503268
80044,"/** 
 * called when json-smart done parssing a value
 */
public void setValue(Object current,String key,Object value) throws ParseException, IOException {
  throw new RuntimeException(ERR_MSG);
}","/** 
 * called when json-smart done parsing a value
 */
public void setValue(Object current,String key,Object value) throws ParseException, IOException {
  throw new RuntimeException(ERR_MSG);
}",0.9974293059125964
80045,"/** 
 * called when json-smart done parssing a value
 */
public void setValue(Object current,String key,Object value) throws ParseException, IOException {
  mapper.setValue(current,key,value);
}","/** 
 * called when json-smart done parsing a value
 */
public void setValue(Object current,String key,Object value) throws ParseException, IOException {
  mapper.setValue(current,key,value);
}",0.9974160206718348
80046,"protected <T>T readObject(AMapper<T> mapper) throws ParseException, IOException {
  if (c != '{')   throw new RuntimeException(""String_Node_Str"");
  Object current=mapper.createObject();
  boolean needData=false;
  boolean acceptData=true;
  for (; ; ) {
    read();
switch (c) {
case ' ':
case '\r':
case '\t':
case '\n':
      continue;
case ':':
case ']':
case '[':
case '{':
    throw new ParseException(pos,ERROR_UNEXPECTED_CHAR,c);
case '}':
  if (needData && !acceptUselessComma)   throw new ParseException(pos,ERROR_UNEXPECTED_CHAR,(char)c);
read();
return mapper.convert(current);
case ',':
if (needData && !acceptUselessComma) throw new ParseException(pos,ERROR_UNEXPECTED_CHAR,(char)c);
acceptData=needData=true;
continue;
case '""':
case '\'':
default :
if (c == '\""' || c == '\'') {
readString();
}
 else {
readNQString(stopKey);
if (!acceptNonQuote) throw new ParseException(pos,ERROR_UNEXPECTED_TOKEN,xs);
}
String key=xs;
if (!acceptData) throw new ParseException(pos,ERROR_UNEXPECTED_TOKEN,key);
while (c != ':' && c != EOI) {
read();
}
if (c == EOI) throw new ParseException(pos - 1,ERROR_UNEXPECTED_EOF,null);
readNoEnd();
lastKey=key;
Object value=readMain(mapper,stopValue);
mapper.setValue(current,key,value);
lastKey=null;
if (c == '}') {
read();
return mapper.convert(current);
}
if (c == EOI) throw new ParseException(pos - 1,ERROR_UNEXPECTED_EOF,null);
if (c == ',') acceptData=needData=true;
 else acceptData=needData=false;
continue;
}
}
}","protected <T>T readObject(AMapper<T> mapper) throws ParseException, IOException {
  if (c != '{')   throw new RuntimeException(""String_Node_Str"");
  Object current=mapper.createObject();
  boolean needData=false;
  boolean acceptData=true;
  for (; ; ) {
    read();
switch (c) {
case ' ':
case '\r':
case '\t':
case '\n':
      continue;
case ':':
case ']':
case '[':
case '{':
    throw new ParseException(pos,ERROR_UNEXPECTED_CHAR,c);
case '}':
  if (needData && !acceptUselessComma)   throw new ParseException(pos,ERROR_UNEXPECTED_CHAR,(char)c);
read();
return mapper.convert(current);
case ',':
if (needData && !acceptUselessComma) throw new ParseException(pos,ERROR_UNEXPECTED_CHAR,(char)c);
acceptData=needData=true;
continue;
case '""':
case '\'':
default :
if (c == '\""' || c == '\'') {
readString();
}
 else {
readNQString(stopKey);
if (!acceptNonQuote) throw new ParseException(pos,ERROR_UNEXPECTED_TOKEN,xs);
}
String key=xs;
if (!acceptData) throw new ParseException(pos,ERROR_UNEXPECTED_TOKEN,key);
skipSpace();
if (c != ':') {
if (c == EOI) throw new ParseException(pos - 1,ERROR_UNEXPECTED_EOF,null);
throw new ParseException(pos - 1,ERROR_UNEXPECTED_CHAR,c);
}
readNoEnd();
lastKey=key;
Object value=readMain(mapper,stopValue);
mapper.setValue(current,key,value);
lastKey=null;
if (c == '}') {
read();
return mapper.convert(current);
}
if (c == EOI) throw new ParseException(pos - 1,ERROR_UNEXPECTED_EOF,null);
if (c == ',') acceptData=needData=true;
 else acceptData=needData=false;
continue;
}
}
}",0.9654478362965448
80047,"/** 
 * Same as read() in memory parssing
 */
protected void readS(){
  if (++pos >= len)   this.c=EOI;
 else   this.c=(char)in[pos];
}","/** 
 * Same as read() in memory parsing
 */
protected void readS(){
  if (++pos >= len)   this.c=EOI;
 else   this.c=(char)in[pos];
}",0.9962825278810408
80048,"protected void read(){
  if (++pos >= len)   this.c=EOI;
 else   this.c=in.charAt(pos);
}","/** 
 * Read next char or END OF INPUT
 */
protected void read(){
  if (++pos >= len)   this.c=EOI;
 else   this.c=in.charAt(pos);
}",0.8054298642533937
80049,"/** 
 * Same as read() in memory parssing
 */
protected void readS(){
  if (++pos >= len)   this.c=EOI;
 else   this.c=in.charAt(pos);
}","/** 
 * Same as read() in memory parsing
 */
protected void readS(){
  if (++pos >= len)   this.c=EOI;
 else   this.c=in.charAt(pos);
}",0.996309963099631
80050,"public boolean mustBeProtect(String s){
  if (s == null)   return false;
  int len=s.length();
  if (len == 0)   return true;
  if (s.trim() != s)   return true;
  char ch=s.charAt(0);
  if (isSpecial(ch) || isUnicode(ch))   return true;
  for (int i=1; i < len; i++) {
    ch=s.charAt(i);
    if (isSpecialClose(ch) || isUnicode(ch))     return true;
  }
  if (isKeyword(s))   return true;
  ch=s.charAt(0);
  if (ch >= '0' && ch <= '9' || ch == '-') {
    int p=1;
    for (; p < s.length(); p++) {
      ch=s.charAt(p);
      if (ch < '0' || ch > '9')       break;
    }
    if (p == s.length())     return true;
    if (ch == '.') {
      p++;
      for (; p < s.length(); p++) {
        ch=s.charAt(p);
        if (ch < '0' || ch > '9')         break;
      }
    }
    if (p == s.length())     return true;
    if (ch != 'E' || ch != 'e')     return false;
    p++;
    if (p == s.length())     return false;
    ch=s.charAt(p);
    if (ch == '+' || ch == '-') {
      ch++;
      if (p == s.length())       return false;
      ch=s.charAt(p);
    }
    if (ch == '+' || ch == '-') {
      ch++;
      if (p == s.length())       return false;
    }
    for (; p < s.length(); p++) {
      ch=s.charAt(p);
      if (ch < '0' || ch > '9')       break;
    }
    if (p == s.length())     return true;
    return false;
  }
  return false;
}","public boolean mustBeProtect(final String s){
  if (s == null)   return false;
  int len=s.length();
  if (len == 0)   return true;
  if (s.trim() != s)   return true;
  char ch=s.charAt(0);
  if (isSpecial(ch) || isUnicode(ch))   return true;
  for (int i=1; i < len; i++) {
    ch=s.charAt(i);
    if (isSpecialClose(ch) || isUnicode(ch))     return true;
  }
  if (isKeyword(s))   return true;
  ch=s.charAt(0);
  if (ch >= '0' && ch <= '9' || ch == '-') {
    int p=1;
    for (; p < len; p++) {
      ch=s.charAt(p);
      if (ch < '0' || ch > '9')       break;
    }
    if (p == len)     return true;
    if (ch == '.') {
      p++;
      for (; p < len; p++) {
        ch=s.charAt(p);
        if (ch < '0' || ch > '9')         break;
      }
    }
    if (p == len)     return true;
    if (ch != 'E' || ch != 'e')     return false;
    p++;
    if (p == len)     return false;
    ch=s.charAt(p);
    if (ch == '+' || ch == '-') {
      ch++;
      if (p == len)       return false;
      ch=s.charAt(p);
    }
    if (ch == '+' || ch == '-') {
      ch++;
      if (p == len)       return false;
    }
    for (; p < len; p++) {
      ch=s.charAt(p);
      if (ch < '0' || ch > '9')       break;
    }
    if (p == len)     return true;
    return false;
  }
  return false;
}",0.5074172689235451
80051,"/** 
 * Escape special chars form String including /
 * @param s - Must not be null.
 * @param sb
 */
public void escape(String s,Appendable sb){
  try {
    for (int i=0; i < s.length(); i++) {
      char ch=s.charAt(i);
switch (ch) {
case '""':
        sb.append(""String_Node_Str"");
      break;
case '\\':
    sb.append(""String_Node_Str"");
  break;
case '\b':
sb.append(""String_Node_Str"");
break;
case '\f':
sb.append(""String_Node_Str"");
break;
case '\n':
sb.append(""String_Node_Str"");
break;
case '\r':
sb.append(""String_Node_Str"");
break;
case '\t':
sb.append(""String_Node_Str"");
break;
case '/':
sb.append(""String_Node_Str"");
break;
default :
if ((ch >= '\u0000' && ch <= '\u001F') || (ch >= '\u007F' && ch <= '\u009F') || (ch >= '\u2000' && ch <= '\u20FF')) {
sb.append(""String_Node_Str"");
String hex=""String_Node_Str"";
sb.append(hex.charAt(ch >> 12 & 0x0F));
sb.append(hex.charAt(ch >> 8 & 0x0F));
sb.append(hex.charAt(ch >> 4 & 0x0F));
sb.append(hex.charAt(ch >> 0 & 0x0F));
}
 else {
sb.append(ch);
}
}
}
}
 catch (IOException e) {
throw new RuntimeException(""String_Node_Str"");
}
}","/** 
 * Escape special chars form String including /
 * @param s - Must not be null.
 * @param sb
 */
public void escape(String s,Appendable sb){
  try {
    int len=s.length();
    for (int i=0; i < len; i++) {
      char ch=s.charAt(i);
switch (ch) {
case '""':
        sb.append(""String_Node_Str"");
      break;
case '\\':
    sb.append(""String_Node_Str"");
  break;
case '\b':
sb.append(""String_Node_Str"");
break;
case '\f':
sb.append(""String_Node_Str"");
break;
case '\n':
sb.append(""String_Node_Str"");
break;
case '\r':
sb.append(""String_Node_Str"");
break;
case '\t':
sb.append(""String_Node_Str"");
break;
case '/':
sb.append(""String_Node_Str"");
break;
default :
if ((ch >= '\u0000' && ch <= '\u001F') || (ch >= '\u007F' && ch <= '\u009F') || (ch >= '\u2000' && ch <= '\u20FF')) {
sb.append(""String_Node_Str"");
String hex=""String_Node_Str"";
sb.append(hex.charAt(ch >> 12 & 0x0F));
sb.append(hex.charAt(ch >> 8 & 0x0F));
sb.append(hex.charAt(ch >> 4 & 0x0F));
sb.append(hex.charAt(ch >> 0 & 0x0F));
}
 else {
sb.append(ch);
}
}
}
}
 catch (IOException e) {
throw new RuntimeException(""String_Node_Str"");
}
}",0.9859026830377444
80052,"/** 
 * Encode an object into JSON text and write it to out. <p> If this object is a Map or a List, and it's also a JSONStreamAware or a JSONAware, JSONStreamAware or JSONAware will be considered firstly. <p>
 * @see JSONObject#writeJSON(Map,Appendable)
 * @see JSONArray#writeJSONString(List,Appendable)
 */
@SuppressWarnings(""String_Node_Str"") public static void writeJSONString(Object value,Appendable out,JSONStyle compression) throws IOException {
  if (value == null) {
    out.append(""String_Node_Str"");
    return;
  }
  if (value instanceof String) {
    if (!compression.mustProtectValue((String)value))     out.append((String)value);
 else {
      out.append('""');
      escape((String)value,out,compression);
      out.append('""');
    }
    return;
  }
  if (value instanceof Number) {
    if (value instanceof Double) {
      if (((Double)value).isInfinite())       out.append(""String_Node_Str"");
 else       out.append(value.toString());
    }
 else     if (value instanceof Float) {
      if (((Float)value).isInfinite())       out.append(""String_Node_Str"");
 else       out.append(value.toString());
    }
 else {
      out.append(value.toString());
    }
    return;
  }
  if (value instanceof Boolean) {
    out.append(value.toString());
  }
 else   if ((value instanceof JSONStreamAware)) {
    if (value instanceof JSONStreamAwareEx)     ((JSONStreamAwareEx)value).writeJSONString(out,compression);
 else     ((JSONStreamAware)value).writeJSONString(out);
  }
 else   if ((value instanceof JSONAware)) {
    if ((value instanceof JSONAwareEx))     out.append(((JSONAwareEx)value).toJSONString(compression));
 else     out.append(((JSONAware)value).toJSONString());
  }
 else   if (value instanceof Map<?,?>) {
    JSONObject.writeJSON((Map<String,Object>)value,out,compression);
  }
 else   if (value instanceof Iterable<?>) {
    JSONArray.writeJSONString((Iterable<Object>)value,out,compression);
  }
 else   if (value instanceof Date) {
    JSONValue.writeJSONString(value.toString(),out,compression);
  }
 else   if (value instanceof Enum<?>) {
    @SuppressWarnings(""String_Node_Str"") String s=((Enum)value).name();
    if (!compression.mustProtectValue(s))     out.append(s);
 else {
      out.append('""');
      escape(s,out,compression);
      out.append('""');
    }
    return;
  }
 else   if (value.getClass().isArray()) {
    Class<?> arrayClz=value.getClass();
    Class<?> c=arrayClz.getComponentType();
    out.append('[');
    boolean needSep=false;
    if (c.isPrimitive()) {
      if (c == int.class) {
        for (        int b : ((int[])value)) {
          if (needSep)           out.append(',');
 else           needSep=true;
          appendInt(b,out);
        }
      }
 else       if (c == short.class) {
        for (        int b : ((short[])value)) {
          if (needSep)           out.append(',');
 else           needSep=true;
          appendInt(b,out);
        }
      }
 else       if (c == byte.class) {
        for (        int b : ((byte[])value)) {
          if (needSep)           out.append(',');
 else           needSep=true;
          appendInt(b,out);
        }
      }
 else       if (c == long.class) {
        for (        long b : ((long[])value)) {
          if (needSep)           out.append(',');
 else           needSep=true;
          if (b < 0) {
            out.append('-');
            b=-b;
          }
          do {
            out.append(DIGITS[(int)(b % 10)]);
            b=b / 10;
          }
 while (b > 0);
        }
      }
 else       if (c == float.class) {
        for (        float b : ((float[])value)) {
          if (needSep)           out.append(',');
 else           needSep=true;
          out.append(Float.toString((float)b));
        }
      }
 else       if (c == double.class) {
        for (        double b : ((double[])value)) {
          if (needSep)           out.append(',');
 else           needSep=true;
          out.append(Double.toString((double)b));
        }
      }
 else       if (c == boolean.class) {
        for (        boolean b : ((boolean[])value)) {
          if (needSep)           out.append(',');
 else           needSep=true;
          if (b)           out.append(""String_Node_Str"");
 else           out.append(""String_Node_Str"");
        }
      }
    }
 else {
      for (      Object o : ((Object[])value)) {
        if (needSep)         out.append(',');
 else         needSep=true;
        writeJSONString(o,out,compression);
      }
    }
    out.append(']');
  }
 else {
    try {
      Class<?> cls=value.getClass();
      boolean needSep=false;
      BeansAccess fields=BeansAccess.get(cls,JSONUtil.JSON_SMART_FIELD_FILTER);
      out.append('{');
      for (      Accessor field : fields.getAccessors()) {
        Object v=fields.get(value,field.getIndex());
        if (needSep)         out.append(',');
 else         needSep=true;
        JSONObject.writeJSONKV(field.getName(),v,out,compression);
      }
      out.append('}');
    }
 catch (    IOException e) {
      throw e;
    }
  }
}","/** 
 * Encode an object into JSON text and write it to out. <p> If this object is a Map or a List, and it's also a JSONStreamAware or a JSONAware, JSONStreamAware or JSONAware will be considered firstly. <p>
 * @see JSONObject#writeJSON(Map,Appendable)
 * @see JSONArray#writeJSONString(List,Appendable)
 */
@SuppressWarnings(""String_Node_Str"") public static void writeJSONString(Object value,Appendable out,JSONStyle compression) throws IOException {
  if (value == null) {
    out.append(""String_Node_Str"");
    return;
  }
  if (value instanceof String) {
    if (!compression.mustProtectValue((String)value))     out.append((String)value);
 else {
      out.append('""');
      escape((String)value,out,compression);
      out.append('""');
    }
    return;
  }
  if (value instanceof Number) {
    if (value instanceof Double) {
      if (((Double)value).isInfinite())       out.append(""String_Node_Str"");
 else       out.append(value.toString());
    }
 else     if (value instanceof Float) {
      if (((Float)value).isInfinite())       out.append(""String_Node_Str"");
 else       out.append(value.toString());
    }
 else {
      out.append(value.toString());
    }
    return;
  }
  if (value instanceof Boolean) {
    out.append(value.toString());
  }
 else   if ((value instanceof JSONStreamAware)) {
    if (value instanceof JSONStreamAwareEx)     ((JSONStreamAwareEx)value).writeJSONString(out,compression);
 else     ((JSONStreamAware)value).writeJSONString(out);
  }
 else   if ((value instanceof JSONAware)) {
    if ((value instanceof JSONAwareEx))     out.append(((JSONAwareEx)value).toJSONString(compression));
 else     out.append(((JSONAware)value).toJSONString());
  }
 else   if (value instanceof Map<?,?>) {
    JSONObject.writeJSON((Map<String,Object>)value,out,compression);
  }
 else   if (value instanceof Iterable<?>) {
    JSONArray.writeJSONString((Iterable<Object>)value,out,compression);
  }
 else   if (value instanceof Date) {
    JSONValue.writeJSONString(value.toString(),out,compression);
  }
 else   if (value instanceof Enum<?>) {
    @SuppressWarnings(""String_Node_Str"") String s=((Enum)value).name();
    if (!compression.mustProtectValue(s))     out.append(s);
 else {
      out.append('""');
      escape(s,out,compression);
      out.append('""');
    }
    return;
  }
 else   if (value.getClass().isArray()) {
    Class<?> arrayClz=value.getClass();
    Class<?> c=arrayClz.getComponentType();
    out.append('[');
    boolean needSep=false;
    if (c.isPrimitive()) {
      if (c == int.class) {
        for (        int b : ((int[])value)) {
          if (needSep)           out.append(',');
 else           needSep=true;
          out.append(Integer.toString(b));
        }
      }
 else       if (c == short.class) {
        for (        short b : ((short[])value)) {
          if (needSep)           out.append(',');
 else           needSep=true;
          out.append(Short.toString(b));
        }
      }
 else       if (c == byte.class) {
        for (        byte b : ((byte[])value)) {
          if (needSep)           out.append(',');
 else           needSep=true;
          out.append(Integer.toString(b));
        }
      }
 else       if (c == long.class) {
        for (        long b : ((long[])value)) {
          if (needSep)           out.append(',');
 else           needSep=true;
          out.append(Long.toString((Long)b));
        }
      }
 else       if (c == float.class) {
        for (        float b : ((float[])value)) {
          if (needSep)           out.append(',');
 else           needSep=true;
          out.append(Float.toString((float)b));
        }
      }
 else       if (c == double.class) {
        for (        double b : ((double[])value)) {
          if (needSep)           out.append(',');
 else           needSep=true;
          out.append(Double.toString((double)b));
        }
      }
 else       if (c == boolean.class) {
        for (        boolean b : ((boolean[])value)) {
          if (needSep)           out.append(',');
 else           needSep=true;
          if (b)           out.append(""String_Node_Str"");
 else           out.append(""String_Node_Str"");
        }
      }
    }
 else {
      for (      Object o : ((Object[])value)) {
        if (needSep)         out.append(',');
 else         needSep=true;
        writeJSONString(o,out,compression);
      }
    }
    out.append(']');
  }
 else {
    try {
      Class<?> cls=value.getClass();
      boolean needSep=false;
      BeansAccess fields=BeansAccess.get(cls,JSONUtil.JSON_SMART_FIELD_FILTER);
      out.append('{');
      for (      Accessor field : fields.getAccessors()) {
        Object v=fields.get(value,field.getIndex());
        if (needSep)         out.append(',');
 else         needSep=true;
        JSONObject.writeJSONKV(field.getName(),v,out,compression);
      }
      out.append('}');
    }
 catch (    IOException e) {
      throw e;
    }
  }
}",0.9664523905182804
80053,"/** 
 * use to return Primitive Type, or String, Or JsonObject or JsonArray generated by a ContainerFactory
 */
public <T>T parse(InputStream in,AMapper<T> mapper) throws ParseException {
  if (pBinStream == null)   pBinStream=new JSONParserInputStream(mode);
  return pBinStream.parse(in,mapper);
}","/** 
 * use to return Primitive Type, or String, Or JsonObject or JsonArray generated by a ContainerFactory
 */
public <T>T parse(String in,Class<T> mapTo) throws ParseException {
  return getPString().parse(in,Mapper.getMapper(mapTo));
}",0.633147113594041
80054,"protected void extractString(int beginIndex,int endIndex){
  xs=new String(in,beginIndex,endIndex);
}","protected void extractString(int beginIndex,int endIndex){
  xs=new String(in,beginIndex,endIndex - beginIndex);
}",0.9395348837209302
80055,"protected void extractStringTrim(int start,int stop){
  extractString(start,stop);
  xs=xs.trim();
}","abstract protected void extractStringTrim(int start,int stop);",0.654320987654321
80056,"/** 
 * Opens a connection.
 * @param connString
 * @return a working connection.
 * @throws SQLException
 */
public static Connection openConnection(String connString) throws SQLException {
  Connection conn=DriverManager.getConnection(""String_Node_Str"");
  return conn;
}","/** 
 * Opens a connection.
 * @param connString
 * @return a working connection.
 * @throws SQLException
 */
public static Connection openConnection(String connString) throws SQLException {
  Connection conn=DriverManager.getConnection(connString);
  return conn;
}",0.9499072356215214
80057,"@Override public Void call() throws Exception {
  BufferedImage in00=getTile(TileRenderer.getImageFile(state.inputDir,tile.x * 2,tile.y * 2,state.imageFormat));
  BufferedImage in10=getTile(TileRenderer.getImageFile(state.inputDir,tile.x * 2 + 1,tile.y * 2,state.imageFormat));
  BufferedImage in01=getTile(TileRenderer.getImageFile(state.inputDir,tile.x * 2,tile.y * 2 + 1,state.imageFormat));
  BufferedImage in11=getTile(TileRenderer.getImageFile(state.inputDir,tile.x * 2 + 1,tile.y * 2 + 1,state.imageFormat));
  if (in00 == null && in10 == null && in01 == null && in11 == null)   return null;
  Log.logDebug(""String_Node_Str"" + tile.x + ""String_Node_Str""+ tile.y);
  final int pixelFormat=state.imageFormat.hasAlpha() ? BufferedImage.TYPE_4BYTE_ABGR : BufferedImage.TYPE_3BYTE_BGR;
  BufferedImage outImg=new BufferedImage(state.tileWidth,state.tileHeight,pixelFormat);
  Graphics2D g=(Graphics2D)outImg.getGraphics();
  g.setColor(state.backgroundColor);
  g.fillRect(0,0,state.tileWidth,state.tileHeight);
  g.setRenderingHint(RenderingHints.KEY_INTERPOLATION,RenderingHints.VALUE_INTERPOLATION_BICUBIC);
  g.setRenderingHint(RenderingHints.KEY_RENDERING,RenderingHints.VALUE_RENDER_QUALITY);
  g.setRenderingHint(RenderingHints.KEY_ANTIALIASING,RenderingHints.VALUE_ANTIALIAS_ON);
  final int halfWidth=state.tileWidth / 2;
  final int halfHeight=state.tileHeight / 2;
  if (in00 != null)   g.drawImage(in00,0,0,halfWidth,halfHeight,null);
  if (in10 != null)   g.drawImage(in10,halfWidth,0,halfWidth,halfHeight,null);
  if (in01 != null)   g.drawImage(in01,0,halfHeight,halfWidth,halfHeight,null);
  if (in11 != null)   g.drawImage(in11,halfWidth,halfHeight,halfWidth,halfHeight,null);
  try {
    File outputFile=TileRenderer.getImageFile(state.outputDir,tile.x,tile.y,state.imageFormat);
    Screenshot.write(outputFile,outImg,state.imageFormat,state.imageCompressionLevel);
    changedFileList.writeLine(outputFile.getAbsolutePath());
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  return null;
}","@Override public Void call() throws Exception {
  BufferedImage in00=getTile(TileRenderer.getImageFile(state.inputDir,tile.x * 2,tile.y * 2,state.imageFormat));
  BufferedImage in10=getTile(TileRenderer.getImageFile(state.inputDir,tile.x * 2 + 1,tile.y * 2,state.imageFormat));
  BufferedImage in01=getTile(TileRenderer.getImageFile(state.inputDir,tile.x * 2,tile.y * 2 + 1,state.imageFormat));
  BufferedImage in11=getTile(TileRenderer.getImageFile(state.inputDir,tile.x * 2 + 1,tile.y * 2 + 1,state.imageFormat));
  if (in00 == null && in10 == null && in01 == null && in11 == null)   return null;
  Log.logDebug(""String_Node_Str"" + tile.x + ""String_Node_Str""+ tile.y);
  final boolean hasAlpha=state.imageFormat.hasAlpha();
  final int pixelFormat=hasAlpha ? BufferedImage.TYPE_4BYTE_ABGR : BufferedImage.TYPE_3BYTE_BGR;
  BufferedImage outImg=new BufferedImage(state.tileWidth,state.tileHeight,pixelFormat);
  Graphics2D g=(Graphics2D)outImg.getGraphics();
  if (!hasAlpha) {
    g.setColor(state.backgroundColor);
    g.fillRect(0,0,state.tileWidth,state.tileHeight);
  }
  g.setRenderingHint(RenderingHints.KEY_INTERPOLATION,RenderingHints.VALUE_INTERPOLATION_BICUBIC);
  g.setRenderingHint(RenderingHints.KEY_RENDERING,RenderingHints.VALUE_RENDER_QUALITY);
  g.setRenderingHint(RenderingHints.KEY_ANTIALIASING,RenderingHints.VALUE_ANTIALIAS_ON);
  final int halfWidth=state.tileWidth / 2;
  final int halfHeight=state.tileHeight / 2;
  if (in00 != null)   g.drawImage(in00,0,0,halfWidth,halfHeight,null);
  if (in10 != null)   g.drawImage(in10,halfWidth,0,halfWidth,halfHeight,null);
  if (in01 != null)   g.drawImage(in01,0,halfHeight,halfWidth,halfHeight,null);
  if (in11 != null)   g.drawImage(in11,halfWidth,halfHeight,halfWidth,halfHeight,null);
  try {
    File outputFile=TileRenderer.getImageFile(state.outputDir,tile.x,tile.y,state.imageFormat);
    Screenshot.write(outputFile,outImg,state.imageFormat,state.imageCompressionLevel);
    changedFileList.writeLine(outputFile.getAbsolutePath());
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  return null;
}",0.9751583049196298
80058,"public MutableConfiguration(){
  mode=Mode.CommandLine;
  rasteriserType=RasteriserType.Lwjgl;
  extractLwjglNatives=true;
  showSpawn=true;
  tileSize=512;
  maxTiles=-1;
  colourDepth=16;
  alphaBits=0;
  numSamples=0;
  numZoomLevels=8;
  signsInitiallyVisible=true;
  playersInitiallyVisible=true;
  portalsInitiallyVisible=true;
  bedsInitiallyVisible=true;
  spawnInitiallyVisible=true;
  viewsInitiallyVisible=true;
  logFile=new File(""String_Node_Str"");
  outputHtmlName=""String_Node_Str"";
  useOldColorPalette=false;
  defaultSkin=""String_Node_Str"";
  numDownsampleThreads=1;
  singlePlayerName=""String_Node_Str"";
  maps=new ArrayList<MutableMap>();
}","public MutableConfiguration(){
  mode=Mode.CommandLine;
  rasteriserType=RasteriserType.Lwjgl;
  extractLwjglNatives=true;
  showSpawn=true;
  tileSize=512;
  maxTiles=-1;
  colourDepth=16;
  alphaBits=8;
  numSamples=0;
  numZoomLevels=8;
  signsInitiallyVisible=true;
  playersInitiallyVisible=true;
  portalsInitiallyVisible=true;
  bedsInitiallyVisible=true;
  spawnInitiallyVisible=true;
  viewsInitiallyVisible=true;
  logFile=new File(""String_Node_Str"");
  outputHtmlName=""String_Node_Str"";
  useOldColorPalette=false;
  defaultSkin=""String_Node_Str"";
  numDownsampleThreads=1;
  singlePlayerName=""String_Node_Str"";
  maps=new ArrayList<MutableMap>();
}",0.9984848484848484
80059,"@Override public void addEdgeGeometry(final int x,final int y,final int z,BlockContext world,BlockTypeRegistry registry,RawChunk rawChunk,Geometry geometry){
  final int data=rawChunk.getBlockData(x,y,z);
  final boolean isHead=(data & 0x8) > 0;
  final float texel=1.0f / 64.0f;
  String xyz=""String_Node_Str"" + String.valueOf(x) + ""String_Node_Str""+ String.valueOf(y)+ ""String_Node_Str""+ String.valueOf(z);
  String color=Colors.byId(rawChunk.getBeds().get(xyz).getColor()).getName();
  SubTexture texture=world.getTexturePack().findTexture(null,""String_Node_Str"" + color);
  SubTexture headTop=new SubTexture(texture.texture,texture.u0 + texel * 6,texture.v0 + texel * 6,texture.u0 + texel * 22,texture.v0 + texel * 21.8f);
  SubTexture footTop=new SubTexture(texture.texture,texture.u0 + texel * 6,texture.v0 + texel * 28.2f,texture.u0 + texel * 22,texture.v0 + texel * 43.9f);
  SubTexture headSide=new SubTexture(texture.texture,texture.u0,texture.v0 + texel * 6.1f,texture.u0 + texel * 6,texture.v0 + texel * 21.9f);
  SubTexture footSide=new SubTexture(texture.texture,texture.u0,texture.v0 + texel * 28.1f,texture.u0 + texel * 6,texture.v0 + texel * 43.9f);
  SubTexture headEdge=new SubTexture(texture.texture,texture.u0 + texel * 6.1f,texture.v0,texture.u0 + texel * 21.9f,texture.v0 + texel * 6);
  SubTexture footEdge=new SubTexture(texture.texture,texture.u0 + texel * 22.1f,texture.v0 + texel * 22,texture.u0 + texel * 37.9f,texture.v0 + texel * 27.9f);
  SubTexture leg=new SubTexture(texture.texture,texture.u0 + texel * 50,texture.v0 + texel * 3.1f,texture.u0 + texel * 53,texture.v0 + texel * 6);
  final float lightness=Chunk.getLight(world.getLightStyle(),LightFace.Top,rawChunk,x,y,z);
  Vector4f white=new Vector4f(lightness,lightness,lightness,1);
  final float height=1.0f / 16.0f * 9.0f;
  final float legHeight=1.0f / 16.0f * 3.0f;
  SubMesh bedMesh=new SubMesh();
  SubTexture topTex=isHead ? headTop : footTop;
  bedMesh.addQuad(new Vector3f(0,height,0),new Vector3f(1,height,0),new Vector3f(1,height,1),new Vector3f(0,height,1),white,topTex);
  if (isHead) {
    bedMesh.addQuad(new Vector3f(0,legHeight,0),new Vector3f(1,legHeight,0),new Vector3f(1,height,0),new Vector3f(0,height,0),white,headEdge);
    bedMesh.addQuad(new Vector3f(1,height,0),new Vector3f(1,legHeight,0),new Vector3f(1,legHeight,1),new Vector3f(1,height,1),white,new Vector2f(headSide.u1,headSide.v0),new Vector2f(headSide.u0,headSide.v0),new Vector2f(headSide.u0,headSide.v1),new Vector2f(headSide.u1,headSide.v1));
    bedMesh.addQuad(new Vector3f(0,legHeight,0),new Vector3f(0,height,0),new Vector3f(0,height,1),new Vector3f(0,legHeight,1),white,headSide);
    SubMesh.addBlockSimple(bedMesh,0,0,0,legHeight,legHeight,legHeight,white,leg,leg,leg);
    SubMesh.addBlockSimple(bedMesh,1 - legHeight,0,0,legHeight,legHeight,legHeight,white,leg,leg,leg);
  }
 else {
    bedMesh.addQuad(new Vector3f(1,legHeight,1),new Vector3f(0,legHeight,1),new Vector3f(0,height,1),new Vector3f(1,height,1),white,footEdge);
    bedMesh.addQuad(new Vector3f(1,height,0),new Vector3f(1,legHeight,0),new Vector3f(1,legHeight,1),new Vector3f(1,height,1),white,new Vector2f(footSide.u1,footSide.v0),new Vector2f(footSide.u0,footSide.v0),new Vector2f(footSide.u0,footSide.v1),new Vector2f(footSide.u1,footSide.v1));
    bedMesh.addQuad(new Vector3f(0,legHeight,0),new Vector3f(0,height,0),new Vector3f(0,height,1),new Vector3f(0,legHeight,1),white,footSide);
    SubMesh.addBlockSimple(bedMesh,0,0,1 - legHeight,legHeight,legHeight,legHeight,white,leg,leg,leg);
    SubMesh.addBlockSimple(bedMesh,1 - legHeight,0,1 - legHeight,legHeight,legHeight,legHeight,white,leg,leg,leg);
  }
  SubMesh.Rotation rotation=Rotation.None;
  float angle=0;
  final int dir=(data & 0x3);
  if (dir == 0) {
    rotation=Rotation.AntiClockwise;
    angle=180;
  }
 else   if (dir == 1) {
    rotation=Rotation.Clockwise;
    angle=90;
  }
 else   if (dir == 2) {
  }
 else   if (dir == 3) {
    rotation=Rotation.AntiClockwise;
    angle=90;
  }
 else {
    System.err.println(""String_Node_Str"");
  }
  bedMesh.pushTo(geometry.getMesh(texture.texture,Geometry.MeshType.AlphaTest),x,y,z,rotation,angle);
}","@Override public void addEdgeGeometry(final int x,final int y,final int z,BlockContext world,BlockTypeRegistry registry,RawChunk rawChunk,Geometry geometry){
  final int data=rawChunk.getBlockData(x,y,z);
  final boolean isHead=(data & 0x8) > 0;
  final float texel=1.0f / 64.0f;
  String xyz=""String_Node_Str"" + String.valueOf(x) + ""String_Node_Str""+ String.valueOf(y)+ ""String_Node_Str""+ String.valueOf(z);
  BedEntity be=rawChunk.getBeds().get(xyz);
  String color=""String_Node_Str"";
  if (be != null)   color=Colors.byId(be.getColor()).getName();
  SubTexture texture=world.getTexturePack().findTexture(null,""String_Node_Str"" + color);
  SubTexture headTop=new SubTexture(texture.texture,texture.u0 + texel * 6,texture.v0 + texel * 6,texture.u0 + texel * 22,texture.v0 + texel * 21.8f);
  SubTexture footTop=new SubTexture(texture.texture,texture.u0 + texel * 6,texture.v0 + texel * 28.2f,texture.u0 + texel * 22,texture.v0 + texel * 43.9f);
  SubTexture headSide=new SubTexture(texture.texture,texture.u0,texture.v0 + texel * 6.1f,texture.u0 + texel * 6,texture.v0 + texel * 21.9f);
  SubTexture footSide=new SubTexture(texture.texture,texture.u0,texture.v0 + texel * 28.1f,texture.u0 + texel * 6,texture.v0 + texel * 43.9f);
  SubTexture headEdge=new SubTexture(texture.texture,texture.u0 + texel * 6.1f,texture.v0,texture.u0 + texel * 21.9f,texture.v0 + texel * 6);
  SubTexture footEdge=new SubTexture(texture.texture,texture.u0 + texel * 22.1f,texture.v0 + texel * 22,texture.u0 + texel * 37.9f,texture.v0 + texel * 27.9f);
  SubTexture leg=new SubTexture(texture.texture,texture.u0 + texel * 50,texture.v0 + texel * 3.1f,texture.u0 + texel * 53,texture.v0 + texel * 6);
  final float lightness=Chunk.getLight(world.getLightStyle(),LightFace.Top,rawChunk,x,y,z);
  Vector4f white=new Vector4f(lightness,lightness,lightness,1);
  final float height=1.0f / 16.0f * 9.0f;
  final float legHeight=1.0f / 16.0f * 3.0f;
  SubMesh bedMesh=new SubMesh();
  SubTexture topTex=isHead ? headTop : footTop;
  bedMesh.addQuad(new Vector3f(0,height,0),new Vector3f(1,height,0),new Vector3f(1,height,1),new Vector3f(0,height,1),white,topTex);
  if (isHead) {
    bedMesh.addQuad(new Vector3f(0,legHeight,0),new Vector3f(1,legHeight,0),new Vector3f(1,height,0),new Vector3f(0,height,0),white,headEdge);
    bedMesh.addQuad(new Vector3f(1,height,0),new Vector3f(1,legHeight,0),new Vector3f(1,legHeight,1),new Vector3f(1,height,1),white,new Vector2f(headSide.u1,headSide.v0),new Vector2f(headSide.u0,headSide.v0),new Vector2f(headSide.u0,headSide.v1),new Vector2f(headSide.u1,headSide.v1));
    bedMesh.addQuad(new Vector3f(0,legHeight,0),new Vector3f(0,height,0),new Vector3f(0,height,1),new Vector3f(0,legHeight,1),white,headSide);
    SubMesh.addBlockSimple(bedMesh,0,0,0,legHeight,legHeight,legHeight,white,leg,leg,leg);
    SubMesh.addBlockSimple(bedMesh,1 - legHeight,0,0,legHeight,legHeight,legHeight,white,leg,leg,leg);
  }
 else {
    bedMesh.addQuad(new Vector3f(1,legHeight,1),new Vector3f(0,legHeight,1),new Vector3f(0,height,1),new Vector3f(1,height,1),white,footEdge);
    bedMesh.addQuad(new Vector3f(1,height,0),new Vector3f(1,legHeight,0),new Vector3f(1,legHeight,1),new Vector3f(1,height,1),white,new Vector2f(footSide.u1,footSide.v0),new Vector2f(footSide.u0,footSide.v0),new Vector2f(footSide.u0,footSide.v1),new Vector2f(footSide.u1,footSide.v1));
    bedMesh.addQuad(new Vector3f(0,legHeight,0),new Vector3f(0,height,0),new Vector3f(0,height,1),new Vector3f(0,legHeight,1),white,footSide);
    SubMesh.addBlockSimple(bedMesh,0,0,1 - legHeight,legHeight,legHeight,legHeight,white,leg,leg,leg);
    SubMesh.addBlockSimple(bedMesh,1 - legHeight,0,1 - legHeight,legHeight,legHeight,legHeight,white,leg,leg,leg);
  }
  SubMesh.Rotation rotation=Rotation.None;
  float angle=0;
  final int dir=(data & 0x3);
  if (dir == 0) {
    rotation=Rotation.AntiClockwise;
    angle=180;
  }
 else   if (dir == 1) {
    rotation=Rotation.Clockwise;
    angle=90;
  }
 else   if (dir == 2) {
  }
 else   if (dir == 3) {
    rotation=Rotation.AntiClockwise;
    angle=90;
  }
 else {
    System.err.println(""String_Node_Str"");
  }
  bedMesh.pushTo(geometry.getMesh(texture.texture,Geometry.MeshType.AlphaTest),x,y,z,rotation,angle);
}",0.9845127472003812
80060,"private void loadPlayerList(Path playerFile){
  System.out.println(""String_Node_Str"" + playerFile);
  playerList=new ArrayList<String>();
  try {
    if (playerFile.toString().toLowerCase().endsWith(""String_Node_Str"")) {
      JsonArray array=new JsonParser().parse(new String(Files.readAllBytes(playerFile))).getAsJsonArray();
      for (int i=0; i < array.size(); i++) {
        String name=array.get(i).getAsJsonObject().get(""String_Node_Str"").getAsString();
        playerList.add(name.toLowerCase());
      }
    }
 else     if (playerFile.toString().toLowerCase().endsWith(""String_Node_Str"")) {
      if (Files.exists(playerFile)) {
        List<String> lines=Files.readAllLines(playerFile);
        for (        String line : lines)         playerList.add(line.trim().toLowerCase());
      }
    }
    System.out.println(""String_Node_Str"" + playerList.size() + ""String_Node_Str"");
  }
 catch (  Exception e) {
    System.out.println(""String_Node_Str"" + playerFile);
    e.printStackTrace();
  }
}","private void loadPlayerList(Path playerFile){
  System.out.println(""String_Node_Str"" + playerFile);
  playerList=new ArrayList<String>();
  try {
    if (playerFile.toString().toLowerCase().endsWith(""String_Node_Str"")) {
      JsonArray array=new JsonParser().parse(new String(Files.readAllBytes(playerFile))).getAsJsonArray();
      for (int i=0; i < array.size(); i++) {
        String name=array.get(i).getAsJsonObject().get(""String_Node_Str"").getAsString();
        playerList.add(name.toLowerCase());
      }
    }
 else     if (playerFile.toString().toLowerCase().endsWith(""String_Node_Str"")) {
      if (Files.exists(playerFile)) {
        List<String> lines=Files.readAllLines(playerFile,StandardCharsets.UTF_8);
        for (        String line : lines)         playerList.add(line.trim().toLowerCase());
      }
    }
    System.out.println(""String_Node_Str"" + playerList.size() + ""String_Node_Str"");
  }
 catch (  Exception e) {
    System.out.println(""String_Node_Str"" + playerFile);
    e.printStackTrace();
  }
}",0.9886643666830952
80061,"public void deserializeBlockstates(){
  List<BlockVariant> blockVariants=new ArrayList<>();
  try (FileSystem fs=FileSystems.newFileSystem(Paths.get(zips.getBaseFileName()),null);DirectoryStream<Path> entries=Files.newDirectoryStream(fs.getPath(""String_Node_Str""))){
    for (    Path entry : entries) {
      JsonObject json=new JsonParser().parse(Files.newBufferedReader(entry)).getAsJsonObject();
      JsonObject variants=json.get(""String_Node_Str"").getAsJsonObject();
      Set<Entry<String,JsonElement>> entrySet=variants.entrySet();
      for (      Map.Entry<String,JsonElement> e : entrySet) {
        String key=e.getKey();
        blockVariants.add(BlockVariant.deserializeVariant(key,variants.get(key)));
      }
      String name=""String_Node_Str"" + StringUtils.removeEnd(entry.getFileName().toString(),""String_Node_Str"");
      blockStates.put(name,blockVariants);
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}","public void deserializeBlockstates(){
  List<BlockVariant> blockVariants=new ArrayList<>();
  try (FileSystem fs=FileSystems.newFileSystem(Paths.get(zips.getBaseFileName()),null);DirectoryStream<Path> entries=Files.newDirectoryStream(fs.getPath(""String_Node_Str""))){
    for (    Path entry : entries) {
      JsonObject json=new JsonParser().parse(Files.newBufferedReader(entry,StandardCharsets.UTF_8)).getAsJsonObject();
      JsonObject variants=json.get(""String_Node_Str"").getAsJsonObject();
      Set<Entry<String,JsonElement>> entrySet=variants.entrySet();
      for (      Map.Entry<String,JsonElement> e : entrySet) {
        String key=e.getKey();
        blockVariants.add(BlockVariant.deserializeVariant(key,variants.get(key)));
      }
      String name=""String_Node_Str"" + StringUtils.removeEnd(entry.getFileName().toString(),""String_Node_Str"");
      blockStates.put(name,blockVariants);
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}",0.9879644165358452
80062,"public void testDrawModel() throws Exception {
  Map<Texture,Mesh> meshList=new HashMap<>();
  Rasteriser rasteriser=RasteriserFactory.createRasteriser(RasteriserType.Lwjgl,DisplayType.Window,800,800,24,8,24,4);
  BlockRegistry br=new BlockRegistry(rasteriser);
  Map<String,String> textureMap=new HashMap<>();
  BlockModel bm=br.loadModel(""String_Node_Str"",zips,textureMap);
  List<BlockElement> elements=bm.getElements();
  for (  BlockElement element : elements) {
    SubTexture tex=null;
    LwjglTexture texture=null;
    if (element.getFaces().containsKey(""String_Node_Str"")) {
      tex=element.getFaces().get(""String_Node_Str"").getTexture();
      texture=(LwjglTexture)tex.texture;
      Mesh result=null;
      result=meshList.get(texture);
      if (result == null) {
        result=new LwjglMesh(texture);
        meshList.put(texture,result);
      }
      float x1=element.getFrom().x();
      float z1=element.getFrom().z();
      float x2=element.getTo().x();
      float y2=element.getTo().y();
      float z2=element.getTo().z();
      result.addVertex(new Vector3f(x1,y2,z1),tex.u0,tex.v0);
      result.addVertex(new Vector3f(x2,y2,z1),tex.u1,tex.v0);
      result.addVertex(new Vector3f(x2,y2,z2),tex.u1,tex.v1);
      result.addVertex(new Vector3f(x1,y2,z2),tex.u0,tex.v1);
    }
  }
  for (  Mesh m : meshList.values())   m.finalise();
  resize();
  System.out.println(glGetString(GL_VERSION));
  System.out.println(glGetString(GL_VENDOR));
  glColor3f(0.0f,1.0f,0.0f);
  glFrontFace(GL_CW);
  glEnable(GL_DEPTH_TEST);
  glEnable(GL_ALPHA_TEST);
  glAlphaFunc(GL11.GL_GREATER,0.6f);
  while (!Display.isCloseRequested()) {
    if (Display.wasResized())     resize();
    getKeys();
    glClearColor(0.0f,0.0f,0.0f,0.0f);
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    for (    BlockElement element : elements) {
      float originX=element.getRotationOrigin().x();
      float originY=element.getRotationOrigin().y();
      float originZ=element.getRotationOrigin().z();
      glPushMatrix();
      if (element.getRotationAxis().equals(""String_Node_Str"")) {
        glTranslatef(originX,originY,originZ);
        glRotatef(element.getRotationAngle(),1.0f,0,0);
        glTranslatef(-originX,-originY,-originZ);
      }
 else       if (element.getRotationAxis().equals(""String_Node_Str"")) {
        glTranslatef(originX,originY,originZ);
        glRotatef(element.getRotationAngle(),0,1.0f,0);
        glTranslatef(-originX,-originY,-originZ);
      }
 else       if (element.getRotationAxis().equals(""String_Node_Str"")) {
        glTranslatef(originX,originY,originZ);
        glRotatef(element.getRotationAngle(),0,0,1.0f);
        glTranslatef(-originX,-originY,-originZ);
      }
      float x1=element.getFrom().x();
      float y1=element.getFrom().y();
      float z1=element.getFrom().z();
      float x2=element.getTo().x();
      float y2=element.getTo().y();
      float z2=element.getTo().z();
      SubTexture tex=null;
      LwjglTexture texture=null;
      if (element.getFaces().containsKey(""String_Node_Str"")) {
        tex=element.getFaces().get(""String_Node_Str"").getTexture();
        texture=(LwjglTexture)tex.texture;
        GL11.glEnable(GL11.GL_TEXTURE_2D);
        GL11.glBindTexture(GL11.GL_TEXTURE_2D,texture.getId());
        glColor3f(1.0f,1.0f,1.0f);
        glBegin(GL_QUADS);
        glTexCoord2f(tex.u0,tex.v0);
        glVertex3f(x1,y2,z1);
        glTexCoord2f(tex.u1,tex.v0);
        glVertex3f(x2,y2,z1);
        glTexCoord2f(tex.u1,tex.v1);
        glVertex3f(x2,y2,z2);
        glTexCoord2f(tex.u0,tex.v1);
        glVertex3f(x1,y2,z2);
        glEnd();
      }
      if (element.getFaces().containsKey(""String_Node_Str"")) {
        tex=element.getFaces().get(""String_Node_Str"").getTexture();
        texture=(LwjglTexture)element.getFaces().get(""String_Node_Str"").getTexture().texture;
        GL11.glEnable(GL11.GL_TEXTURE_2D);
        GL11.glBindTexture(GL11.GL_TEXTURE_2D,texture.getId());
        glColor3f(1.0f,1.0f,1.0f);
        glBegin(GL_QUADS);
        glTexCoord2f(tex.u0,tex.v0);
        glVertex3f(x2,y1,z1);
        glTexCoord2f(tex.u1,tex.v0);
        glVertex3f(x1,y1,z1);
        glTexCoord2f(tex.u1,tex.v1);
        glVertex3f(x1,y1,z2);
        glTexCoord2f(tex.u0,tex.v1);
        glVertex3f(x2,y1,z2);
        glEnd();
      }
      if (element.getFaces().containsKey(""String_Node_Str"")) {
        tex=element.getFaces().get(""String_Node_Str"").getTexture();
        texture=(LwjglTexture)element.getFaces().get(""String_Node_Str"").getTexture().texture;
        GL11.glEnable(GL11.GL_TEXTURE_2D);
        GL11.glBindTexture(GL11.GL_TEXTURE_2D,texture.getId());
        glColor3f(1.0f,1.0f,1.0f);
        glBegin(GL_QUADS);
        glTexCoord2f(tex.u0,tex.v0);
        glVertex3f(x2,y2,z1);
        glTexCoord2f(tex.u1,tex.v0);
        glVertex3f(x1,y2,z1);
        glTexCoord2f(tex.u1,tex.v1);
        glVertex3f(x1,y1,z1);
        glTexCoord2f(tex.u0,tex.v1);
        glVertex3f(x2,y1,z1);
        glEnd();
      }
      if (element.getFaces().containsKey(""String_Node_Str"")) {
        tex=element.getFaces().get(""String_Node_Str"").getTexture();
        texture=(LwjglTexture)element.getFaces().get(""String_Node_Str"").getTexture().texture;
        GL11.glEnable(GL11.GL_TEXTURE_2D);
        GL11.glBindTexture(GL11.GL_TEXTURE_2D,texture.getId());
        glColor3f(1.0f,1.0f,1.0f);
        glBegin(GL_QUADS);
        glTexCoord2f(tex.u0,tex.v0);
        glVertex3f(x1,y2,z2);
        glTexCoord2f(tex.u1,tex.v0);
        glVertex3f(x2,y2,z2);
        glTexCoord2f(tex.u1,tex.v1);
        glVertex3f(x2,y1,z2);
        glTexCoord2f(tex.u0,tex.v1);
        glVertex3f(x1,y1,z2);
        glEnd();
      }
      if (element.getFaces().containsKey(""String_Node_Str"")) {
        tex=element.getFaces().get(""String_Node_Str"").getTexture();
        texture=(LwjglTexture)element.getFaces().get(""String_Node_Str"").getTexture().texture;
        GL11.glEnable(GL11.GL_TEXTURE_2D);
        GL11.glBindTexture(GL11.GL_TEXTURE_2D,texture.getId());
        glColor3f(1.0f,1.0f,1.0f);
        glBegin(GL_QUADS);
        glTexCoord2f(tex.u0,tex.v0);
        glVertex3f(x2,y2,z2);
        glTexCoord2f(tex.u1,tex.v0);
        glVertex3f(x2,y2,z1);
        glTexCoord2f(tex.u1,tex.v1);
        glVertex3f(x2,y1,z1);
        glTexCoord2f(tex.u0,tex.v1);
        glVertex3f(x2,y1,z2);
        glEnd();
      }
      if (element.getFaces().containsKey(""String_Node_Str"")) {
        tex=element.getFaces().get(""String_Node_Str"").getTexture();
        texture=(LwjglTexture)element.getFaces().get(""String_Node_Str"").getTexture().texture;
        GL11.glEnable(GL11.GL_TEXTURE_2D);
        GL11.glBindTexture(GL11.GL_TEXTURE_2D,texture.getId());
        glColor3f(1.0f,1.0f,1.0f);
        glBegin(GL_QUADS);
        glTexCoord2f(tex.u0,tex.v0);
        glVertex3f(x1,y2,z1);
        glTexCoord2f(tex.u1,tex.v0);
        glVertex3f(x1,y2,z2);
        glTexCoord2f(tex.u1,tex.v1);
        glVertex3f(x1,y1,z2);
        glTexCoord2f(tex.u0,tex.v1);
        glVertex3f(x1,y1,z1);
        glEnd();
      }
      glPopMatrix();
    }
    Display.update();
    Display.sync(60);
  }
  Display.destroy();
}","public void testDrawModel() throws Exception {
  Map<Texture,Mesh> meshList=new HashMap<>();
  Rasteriser rasteriser=RasteriserFactory.createRasteriser(RasteriserType.Lwjgl,DisplayType.Window,800,800,24,8,24,4);
  BlockRegistry br=new BlockRegistry(rasteriser);
  Map<String,String> textureMap=new HashMap<>();
  BlockModel bm=br.loadModel(""String_Node_Str"",zips,textureMap);
  List<BlockElement> elements=bm.getElements();
  for (  BlockElement element : elements) {
    SubTexture tex=null;
    LwjglTexture texture=null;
    if (element.getFaces().containsKey(""String_Node_Str"")) {
      tex=element.getFaces().get(""String_Node_Str"").getTexture();
      texture=(LwjglTexture)tex.texture;
      Mesh result=null;
      result=meshList.get(texture);
      if (result == null) {
        result=new LwjglMesh(texture);
        meshList.put(texture,result);
      }
      float x1=element.getFrom().x();
      float z1=element.getFrom().z();
      float x2=element.getTo().x();
      float y2=element.getTo().y();
      float z2=element.getTo().z();
      Vector4f color=new Vector4f(1,1,1,1);
      result.addVertex(new Vector3f(x1,y2,z1),color,tex.u0,tex.v0);
      result.addVertex(new Vector3f(x2,y2,z1),color,tex.u1,tex.v0);
      result.addVertex(new Vector3f(x2,y2,z2),color,tex.u1,tex.v1);
      result.addVertex(new Vector3f(x1,y2,z2),color,tex.u0,tex.v1);
    }
  }
  for (  Mesh m : meshList.values())   m.finalise();
  resize();
  System.out.println(glGetString(GL_VERSION));
  System.out.println(glGetString(GL_VENDOR));
  glColor3f(0.0f,1.0f,0.0f);
  glFrontFace(GL_CW);
  glEnable(GL_DEPTH_TEST);
  glEnable(GL_ALPHA_TEST);
  glAlphaFunc(GL11.GL_GREATER,0.6f);
  while (!Display.isCloseRequested()) {
    if (Display.wasResized())     resize();
    getKeys();
    glClearColor(0.0f,0.0f,0.0f,0.0f);
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    for (    BlockElement element : elements) {
      float originX=element.getRotationOrigin().x();
      float originY=element.getRotationOrigin().y();
      float originZ=element.getRotationOrigin().z();
      glPushMatrix();
      if (element.getRotationAxis().equals(""String_Node_Str"")) {
        glTranslatef(originX,originY,originZ);
        glRotatef(element.getRotationAngle(),1.0f,0,0);
        glTranslatef(-originX,-originY,-originZ);
      }
 else       if (element.getRotationAxis().equals(""String_Node_Str"")) {
        glTranslatef(originX,originY,originZ);
        glRotatef(element.getRotationAngle(),0,1.0f,0);
        glTranslatef(-originX,-originY,-originZ);
      }
 else       if (element.getRotationAxis().equals(""String_Node_Str"")) {
        glTranslatef(originX,originY,originZ);
        glRotatef(element.getRotationAngle(),0,0,1.0f);
        glTranslatef(-originX,-originY,-originZ);
      }
      float x1=element.getFrom().x();
      float y1=element.getFrom().y();
      float z1=element.getFrom().z();
      float x2=element.getTo().x();
      float y2=element.getTo().y();
      float z2=element.getTo().z();
      SubTexture tex=null;
      LwjglTexture texture=null;
      if (element.getFaces().containsKey(""String_Node_Str"")) {
        tex=element.getFaces().get(""String_Node_Str"").getTexture();
        texture=(LwjglTexture)tex.texture;
        GL11.glEnable(GL11.GL_TEXTURE_2D);
        GL11.glBindTexture(GL11.GL_TEXTURE_2D,texture.getId());
        glColor3f(1.0f,1.0f,1.0f);
        glBegin(GL_QUADS);
        glTexCoord2f(tex.u0,tex.v0);
        glVertex3f(x1,y2,z1);
        glTexCoord2f(tex.u1,tex.v0);
        glVertex3f(x2,y2,z1);
        glTexCoord2f(tex.u1,tex.v1);
        glVertex3f(x2,y2,z2);
        glTexCoord2f(tex.u0,tex.v1);
        glVertex3f(x1,y2,z2);
        glEnd();
      }
      if (element.getFaces().containsKey(""String_Node_Str"")) {
        tex=element.getFaces().get(""String_Node_Str"").getTexture();
        texture=(LwjglTexture)element.getFaces().get(""String_Node_Str"").getTexture().texture;
        GL11.glEnable(GL11.GL_TEXTURE_2D);
        GL11.glBindTexture(GL11.GL_TEXTURE_2D,texture.getId());
        glColor3f(1.0f,1.0f,1.0f);
        glBegin(GL_QUADS);
        glTexCoord2f(tex.u0,tex.v0);
        glVertex3f(x2,y1,z1);
        glTexCoord2f(tex.u1,tex.v0);
        glVertex3f(x1,y1,z1);
        glTexCoord2f(tex.u1,tex.v1);
        glVertex3f(x1,y1,z2);
        glTexCoord2f(tex.u0,tex.v1);
        glVertex3f(x2,y1,z2);
        glEnd();
      }
      if (element.getFaces().containsKey(""String_Node_Str"")) {
        tex=element.getFaces().get(""String_Node_Str"").getTexture();
        texture=(LwjglTexture)element.getFaces().get(""String_Node_Str"").getTexture().texture;
        GL11.glEnable(GL11.GL_TEXTURE_2D);
        GL11.glBindTexture(GL11.GL_TEXTURE_2D,texture.getId());
        glColor3f(1.0f,1.0f,1.0f);
        glBegin(GL_QUADS);
        glTexCoord2f(tex.u0,tex.v0);
        glVertex3f(x2,y2,z1);
        glTexCoord2f(tex.u1,tex.v0);
        glVertex3f(x1,y2,z1);
        glTexCoord2f(tex.u1,tex.v1);
        glVertex3f(x1,y1,z1);
        glTexCoord2f(tex.u0,tex.v1);
        glVertex3f(x2,y1,z1);
        glEnd();
      }
      if (element.getFaces().containsKey(""String_Node_Str"")) {
        tex=element.getFaces().get(""String_Node_Str"").getTexture();
        texture=(LwjglTexture)element.getFaces().get(""String_Node_Str"").getTexture().texture;
        GL11.glEnable(GL11.GL_TEXTURE_2D);
        GL11.glBindTexture(GL11.GL_TEXTURE_2D,texture.getId());
        glColor3f(1.0f,1.0f,1.0f);
        glBegin(GL_QUADS);
        glTexCoord2f(tex.u0,tex.v0);
        glVertex3f(x1,y2,z2);
        glTexCoord2f(tex.u1,tex.v0);
        glVertex3f(x2,y2,z2);
        glTexCoord2f(tex.u1,tex.v1);
        glVertex3f(x2,y1,z2);
        glTexCoord2f(tex.u0,tex.v1);
        glVertex3f(x1,y1,z2);
        glEnd();
      }
      if (element.getFaces().containsKey(""String_Node_Str"")) {
        tex=element.getFaces().get(""String_Node_Str"").getTexture();
        texture=(LwjglTexture)element.getFaces().get(""String_Node_Str"").getTexture().texture;
        GL11.glEnable(GL11.GL_TEXTURE_2D);
        GL11.glBindTexture(GL11.GL_TEXTURE_2D,texture.getId());
        glColor3f(1.0f,1.0f,1.0f);
        glBegin(GL_QUADS);
        glTexCoord2f(tex.u0,tex.v0);
        glVertex3f(x2,y2,z2);
        glTexCoord2f(tex.u1,tex.v0);
        glVertex3f(x2,y2,z1);
        glTexCoord2f(tex.u1,tex.v1);
        glVertex3f(x2,y1,z1);
        glTexCoord2f(tex.u0,tex.v1);
        glVertex3f(x2,y1,z2);
        glEnd();
      }
      if (element.getFaces().containsKey(""String_Node_Str"")) {
        tex=element.getFaces().get(""String_Node_Str"").getTexture();
        texture=(LwjglTexture)element.getFaces().get(""String_Node_Str"").getTexture().texture;
        GL11.glEnable(GL11.GL_TEXTURE_2D);
        GL11.glBindTexture(GL11.GL_TEXTURE_2D,texture.getId());
        glColor3f(1.0f,1.0f,1.0f);
        glBegin(GL_QUADS);
        glTexCoord2f(tex.u0,tex.v0);
        glVertex3f(x1,y2,z1);
        glTexCoord2f(tex.u1,tex.v0);
        glVertex3f(x1,y2,z2);
        glTexCoord2f(tex.u1,tex.v1);
        glVertex3f(x1,y1,z2);
        glTexCoord2f(tex.u0,tex.v1);
        glVertex3f(x1,y1,z1);
        glEnd();
      }
      glPopMatrix();
    }
    Display.update();
    Display.sync(60);
  }
  Display.destroy();
}",0.9931982232093282
80063,"private static boolean passesFilter(RawSign s,SignFilter filter){
  if (s.text1.trim().isEmpty() && s.text2.trim().isEmpty() && s.text3.trim().isEmpty()&& s.text4.trim().isEmpty())   return false;
  if (s.text1.startsWith(""String_Node_Str""))   return false;
  if (filter == SignFilter.None) {
    return false;
  }
 else   if (filter == SignFilter.All || filter == SignFilter.Obey) {
    return true;
  }
 else   if (filter == SignFilter.Special) {
    String line=""String_Node_Str"" + s.text1 + s.text2+ s.text3+ s.text4;
    line=line.trim();
    if (line.length() > 0) {
      final char first=line.charAt(0);
      final char last=line.charAt(line.length() - 1);
      final char[] special={'-','=','~','!'};
      return containedIn(special,first) && containedIn(special,last);
    }
 else     return false;
  }
 else {
    throw new RuntimeException(""String_Node_Str"" + filter);
  }
}","private static boolean passesFilter(RawSign s,SignFilter filter){
  if (s.text1.trim().isEmpty() && s.text2.trim().isEmpty() && s.text3.trim().isEmpty()&& s.text4.trim().isEmpty())   return false;
  if (s.text1.startsWith(""String_Node_Str"") || s.text2.startsWith(""String_Node_Str"") || s.text3.startsWith(""String_Node_Str"")|| s.text4.startsWith(""String_Node_Str"")) {
    return false;
  }
  if (filter == SignFilter.None) {
    return false;
  }
 else   if (filter == SignFilter.All || filter == SignFilter.Obey) {
    return true;
  }
 else   if (filter == SignFilter.Special) {
    String line=""String_Node_Str"" + s.text1 + s.text2+ s.text3+ s.text4;
    line=line.trim();
    if (line.length() > 0) {
      final char first=line.charAt(0);
      final char last=line.charAt(line.length() - 1);
      final char[] special={'-','=','~','!'};
      return containedIn(special,first) && containedIn(special,last);
    }
 else     return false;
  }
 else {
    throw new RuntimeException(""String_Node_Str"" + filter);
  }
}",0.9308176100628932
80064,"private void outputViews(File viewsFile,HddObjectListReader<Sign> views,tectonicus.configuration.Map map,ImageFormat imageFormat){
  System.out.println(""String_Node_Str"");
  if (viewsFile.exists())   viewsFile.delete();
  JsArrayWriter jsWriter=null;
  try {
    jsWriter=new JsArrayWriter(viewsFile,map.getId() + ""String_Node_Str"");
    Sign sign=new Sign();
    while (views.hasNext()) {
      views.read(sign);
      HashMap<String,String> args=new HashMap<String,String>();
      final float worldX=sign.getX() + 0.5f;
      final float worldY=sign.getY();
      final float worldZ=sign.getZ() + 0.5f;
      String posStr=""String_Node_Str"" + worldX + ""String_Node_Str""+ worldY+ ""String_Node_Str""+ worldZ+ ""String_Node_Str"";
      args.put(""String_Node_Str"",posStr);
      String text=""String_Node_Str"";
      for (int i=1; i < 4; i++) {
        if (!sign.getText(i).startsWith(""String_Node_Str"")) {
          text=text + sign.getText(i);
        }
      }
      text=text.trim();
      args.put(""String_Node_Str"",""String_Node_Str"" + jsEscape(text) + ""String_Node_Str"");
      String filename=map.getId() + ""String_Node_Str"" + sign.getX()+ ""String_Node_Str""+ sign.getY()+ ""String_Node_Str""+ sign.getZ()+ ""String_Node_Str""+ imageFormat.getExtension();
      args.put(""String_Node_Str"",""String_Node_Str"" + filename + ""String_Node_Str"");
      jsWriter.write(args);
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
 finally {
    if (jsWriter != null)     jsWriter.close();
  }
}","private void outputViews(File viewsFile,HddObjectListReader<Sign> views,tectonicus.configuration.Map map,ImageFormat imageFormat){
  System.out.println(""String_Node_Str"");
  if (viewsFile.exists())   viewsFile.delete();
  JsArrayWriter jsWriter=null;
  try {
    jsWriter=new JsArrayWriter(viewsFile,map.getId() + ""String_Node_Str"");
    Sign sign=new Sign();
    while (views.hasNext()) {
      views.read(sign);
      HashMap<String,String> args=new HashMap<String,String>();
      final float worldX=sign.getX() + 0.5f;
      final float worldY=sign.getY();
      final float worldZ=sign.getZ() + 0.5f;
      String posStr=""String_Node_Str"" + worldX + ""String_Node_Str""+ worldY+ ""String_Node_Str""+ worldZ+ ""String_Node_Str"";
      args.put(""String_Node_Str"",posStr);
      String text=""String_Node_Str"";
      for (int i=0; i < 4; i++) {
        if (!sign.getText(i).startsWith(""String_Node_Str"")) {
          text=text + sign.getText(i) + ""String_Node_Str"";
        }
      }
      text=text.trim();
      args.put(""String_Node_Str"",""String_Node_Str"" + jsEscape(text) + ""String_Node_Str"");
      String filename=map.getId() + ""String_Node_Str"" + sign.getX()+ ""String_Node_Str""+ sign.getY()+ ""String_Node_Str""+ sign.getZ()+ ""String_Node_Str""+ imageFormat.getExtension();
      args.put(""String_Node_Str"",""String_Node_Str"" + filename + ""String_Node_Str"");
      jsWriter.write(args);
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
 finally {
    if (jsWriter != null)     jsWriter.close();
  }
}",0.992686170212766
80065,"private static Set<String> extractSettings(Sign sign){
  String toParse=sign.getText(0);
  if (sign.getText(1).startsWith(""String_Node_Str"") && sign.getText(1).length() > 1)   toParse+=""String_Node_Str"" + sign.getText(1).substring(1);
  if (sign.getText(2).startsWith(""String_Node_Str"") && sign.getText(2).length() > 1)   toParse+=""String_Node_Str"" + sign.getText(2).substring(1);
  if (sign.getText(3).startsWith(""String_Node_Str"") && sign.getText(3).length() > 1)   toParse+=""String_Node_Str"" + sign.getText(3).substring(1);
  Set<String> settings=new HashSet<String>();
  StringTokenizer tokeniser=new StringTokenizer(toParse);
  while (tokeniser.hasMoreTokens()) {
    String token=tokeniser.nextToken();
    if (token != null) {
      token=token.trim().toLowerCase();
      settings.add(token);
    }
  }
  return settings;
}","private static Set<String> extractSettings(Sign sign){
  String toParse=""String_Node_Str"";
  if (sign.getText(0).startsWith(""String_Node_Str"") && sign.getText(0).length() > 1)   toParse+=""String_Node_Str"" + sign.getText(0).substring(1);
  if (sign.getText(1).startsWith(""String_Node_Str"") && sign.getText(1).length() > 1)   toParse+=""String_Node_Str"" + sign.getText(1).substring(1);
  if (sign.getText(2).startsWith(""String_Node_Str"") && sign.getText(2).length() > 1)   toParse+=""String_Node_Str"" + sign.getText(2).substring(1);
  if (sign.getText(3).startsWith(""String_Node_Str"") && sign.getText(3).length() > 1)   toParse+=""String_Node_Str"" + sign.getText(3).substring(1);
  Set<String> settings=new HashSet<String>();
  StringTokenizer tokeniser=new StringTokenizer(toParse);
  while (tokeniser.hasMoreTokens()) {
    String token=tokeniser.nextToken();
    if (token != null) {
      token=token.trim().toLowerCase();
      settings.add(token);
    }
  }
  return settings;
}",0.918232044198895
80066,"public boolean passesFilter(RawSign sign){
  if (type == ViewFilterType.All) {
    String start=sign.text1.trim();
    return start.startsWith(""String_Node_Str"");
  }
 else   return false;
}","public boolean passesFilter(RawSign sign){
  if (type == ViewFilterType.All) {
    String text1=sign.text1.trim();
    String text2=sign.text2.trim();
    String text3=sign.text3.trim();
    String text4=sign.text4.trim();
    return (text1.startsWith(""String_Node_Str"") || text2.startsWith(""String_Node_Str"") || text3.startsWith(""String_Node_Str"")|| text4.startsWith(""String_Node_Str"")) ? true : false;
  }
 else   return false;
}",0.5603864734299517
80067,"public static ArrayList<Player> loadPlayers(File worldDir,PlayerSkinCache playerSkinCache){
  File playersDir=Minecraft.findPlayersDir(worldDir);
  System.out.println(""String_Node_Str"" + playersDir.getAbsolutePath());
  ArrayList<Player> players=new ArrayList<Player>();
  File[] playerFiles=playersDir.listFiles();
  if (playerFiles != null) {
    for (    File playerFile : playerFiles) {
      if (playerFile.getName().endsWith(""String_Node_Str"")) {
        try {
          Player player=new Player(playerFile);
          CacheEntry ce=playerSkinCache.getCacheEntry(player.getUUID());
          if (ce != null) {
            final long age=System.currentTimeMillis() - ce.fetchedTime;
            if (age < 1000 * 60 * 60* 60) {
              player.setName(ce.playerName);
              player.setSkinURL(ce.skinURL);
            }
          }
 else {
            if (player.getUUID().equals(player.getName())) {
              player.setSkinURL(""String_Node_Str"" + player.getName() + ""String_Node_Str"");
            }
 else {
              String urlString=""String_Node_Str"" + player.getUUID();
              URL url=new URL(urlString);
              HttpURLConnection connection=(HttpURLConnection)url.openConnection();
              connection.setRequestMethod(""String_Node_Str"");
              connection.addRequestProperty(""String_Node_Str"",""String_Node_Str"");
              connection.setReadTimeout(15 * 1000);
              connection.connect();
              BufferedReader reader=new BufferedReader(new InputStreamReader(connection.getInputStream()));
              StringBuilder builder=new StringBuilder();
              String line=null;
              while ((line=reader.readLine()) != null) {
                builder.append(line + ""String_Node_Str"");
              }
              reader.close();
              JSONObject obj=new JSONObject(builder.toString());
              player.setName(obj.getString(""String_Node_Str""));
              JSONObject textures=obj.getJSONArray(""String_Node_Str"").getJSONObject(0);
              byte[] decoded=DatatypeConverter.parseBase64Binary(textures.get(""String_Node_Str"").toString());
              obj=new JSONObject(new String(decoded,""String_Node_Str""));
              boolean hasSkin=obj.getJSONObject(""String_Node_Str"").has(""String_Node_Str"");
              String textureUrl=null;
              if (hasSkin == true)               textureUrl=obj.getJSONObject(""String_Node_Str"").getJSONObject(""String_Node_Str"").getString(""String_Node_Str"");
              player.setSkinURL(textureUrl);
            }
          }
          players.add(player);
          System.out.println(""String_Node_Str"" + player.getName());
        }
 catch (        Exception e) {
          System.err.println(""String_Node_Str"" + playerFile.getName());
          System.err.println(""String_Node_Str"");
        }
      }
    }
  }
  System.out.println(""String_Node_Str"" + players.size() + ""String_Node_Str"");
  return players;
}","public static ArrayList<Player> loadPlayers(File worldDir,PlayerSkinCache playerSkinCache){
  File playersDir=Minecraft.findPlayersDir(worldDir);
  System.out.println(""String_Node_Str"" + playersDir.getAbsolutePath());
  ArrayList<Player> players=new ArrayList<Player>();
  File[] playerFiles=playersDir.listFiles();
  if (playerFiles != null) {
    for (    File playerFile : playerFiles) {
      if (playerFile.getName().endsWith(""String_Node_Str"")) {
        try {
          Player player=new Player(playerFile);
          CacheEntry ce=playerSkinCache.getCacheEntry(player.getUUID());
          if (ce != null) {
            final long age=System.currentTimeMillis() - ce.fetchedTime;
            if (age < 1000 * 60 * 60* 60) {
              player.setName(ce.playerName);
              player.setSkinURL(ce.skinURL);
            }
 else {
              player.requestPlayerInfo();
            }
          }
 else {
            player.requestPlayerInfo();
          }
          players.add(player);
          System.out.println(""String_Node_Str"" + player.getName());
        }
 catch (        Exception e) {
          System.err.println(""String_Node_Str"" + playerFile.getName());
        }
      }
    }
  }
  System.out.println(""String_Node_Str"" + players.size() + ""String_Node_Str"");
  return players;
}",0.4571428571428571
80068,"private void init(InputStream in,Compression compression) throws Exception {
  clear();
  NBTInputStream nbtIn=null;
  try {
    nbtIn=new NBTInputStream(in,compression);
    Tag tag=nbtIn.readTag();
    if (tag instanceof CompoundTag) {
      CompoundTag root=(CompoundTag)tag;
      CompoundTag level=NbtUtil.getChild(root,""String_Node_Str"",CompoundTag.class);
      if (level != null) {
        blockX=blockY=blockZ=0;
        IntTag xPosTag=NbtUtil.getChild(level,""String_Node_Str"",IntTag.class);
        if (xPosTag != null)         blockX=xPosTag.getValue().intValue();
        IntTag zPosTag=NbtUtil.getChild(level,""String_Node_Str"",IntTag.class);
        if (zPosTag != null)         blockZ=zPosTag.getValue().intValue();
        ListTag sections=NbtUtil.getChild(level,""String_Node_Str"",ListTag.class);
        if (sections != null) {
          parseAnvilData(level);
        }
 else {
          parseMcRegionData(level);
        }
        ListTag entitiesTag=NbtUtil.getChild(level,""String_Node_Str"",ListTag.class);
        if (entitiesTag != null) {
          for (          Tag t : entitiesTag.getValue()) {
            if (t instanceof CompoundTag) {
              CompoundTag entity=(CompoundTag)t;
              StringTag idTag=NbtUtil.getChild(entity,""String_Node_Str"",StringTag.class);
              if (idTag.getValue().endsWith(""String_Node_Str"")) {
                StringTag motiveTag=NbtUtil.getChild(entity,""String_Node_Str"",StringTag.class);
                IntTag xTag=NbtUtil.getChild(entity,""String_Node_Str"",IntTag.class);
                IntTag yTag=NbtUtil.getChild(entity,""String_Node_Str"",IntTag.class);
                IntTag zTag=NbtUtil.getChild(entity,""String_Node_Str"",IntTag.class);
                ByteTag dir=NbtUtil.getChild(entity,""String_Node_Str"",ByteTag.class);
                boolean is18=false;
                if (dir == null) {
                  dir=NbtUtil.getChild(entity,""String_Node_Str"",ByteTag.class);
                  is18=true;
                }
                int x=xTag.getValue();
                final int y=yTag.getValue();
                int z=zTag.getValue();
                if (is18 && dir.getValue() == 0) {
                  z=zTag.getValue() - 1;
                }
 else                 if (is18 && dir.getValue() == 1) {
                  x=xTag.getValue() + 1;
                }
 else                 if (is18 && dir.getValue() == 2) {
                  z=zTag.getValue() + 1;
                }
 else                 if (is18 && dir.getValue() == 3) {
                  x=xTag.getValue() - 1;
                }
                final int localX=x - (blockX * WIDTH);
                final int localY=y - (blockY * HEIGHT);
                final int localZ=z - (blockZ * DEPTH);
                paintings.add(new TileEntity(-1,0,x,y,z,localX,localY,localZ,motiveTag.getValue(),dir.getValue()));
              }
 else               if (idTag.getValue().equals(""String_Node_Str"")) {
                IntTag xTag=NbtUtil.getChild(entity,""String_Node_Str"",IntTag.class);
                IntTag yTag=NbtUtil.getChild(entity,""String_Node_Str"",IntTag.class);
                IntTag zTag=NbtUtil.getChild(entity,""String_Node_Str"",IntTag.class);
                ByteTag dir=NbtUtil.getChild(entity,""String_Node_Str"",ByteTag.class);
                boolean is18=false;
                if (dir == null) {
                  dir=NbtUtil.getChild(entity,""String_Node_Str"",ByteTag.class);
                  is18=true;
                }
                String item=""String_Node_Str"";
                Map<String,Tag> map=entity.getValue();
                CompoundTag itemTag=(CompoundTag)map.get(""String_Node_Str"");
                if (itemTag != null) {
                  ShortTag itemIdTag=NbtUtil.getChild(itemTag,""String_Node_Str"",ShortTag.class);
                  if (itemIdTag == null) {
                    StringTag stringItemIdTag=NbtUtil.getChild(itemTag,""String_Node_Str"",StringTag.class);
                    item=stringItemIdTag.getValue();
                  }
 else {
                    if (itemIdTag.getValue() == 358)                     item=""String_Node_Str"";
                  }
                }
                int x=xTag.getValue();
                final int y=yTag.getValue();
                int z=zTag.getValue();
                if (is18 && dir.getValue() == 0) {
                  z=zTag.getValue() - 1;
                }
 else                 if (is18 && dir.getValue() == 1) {
                  x=xTag.getValue() + 1;
                }
 else                 if (is18 && dir.getValue() == 2) {
                  z=zTag.getValue() + 1;
                }
 else                 if (is18 && dir.getValue() == 3) {
                  x=xTag.getValue() - 1;
                }
                final int localX=x - (blockX * WIDTH);
                final int localY=y - (blockY * HEIGHT);
                final int localZ=z - (blockZ * DEPTH);
                itemFrames.add(new TileEntity(-2,0,x,y,z,localX,localY,localZ,item,dir.getValue()));
              }
            }
          }
        }
        ListTag tileEntitiesTag=NbtUtil.getChild(level,""String_Node_Str"",ListTag.class);
        if (tileEntitiesTag != null) {
          for (          Tag t : tileEntitiesTag.getValue()) {
            if (t instanceof CompoundTag) {
              CompoundTag entity=(CompoundTag)t;
              StringTag idTag=NbtUtil.getChild(entity,""String_Node_Str"",StringTag.class);
              IntTag xTag=NbtUtil.getChild(entity,""String_Node_Str"",IntTag.class);
              IntTag yTag=NbtUtil.getChild(entity,""String_Node_Str"",IntTag.class);
              IntTag zTag=NbtUtil.getChild(entity,""String_Node_Str"",IntTag.class);
              if (idTag != null && xTag != null && yTag != null && zTag != null) {
                String id=idTag.getValue();
                if (id.equals(""String_Node_Str"")) {
                  String text1=NbtUtil.getChild(entity,""String_Node_Str"",StringTag.class).getValue();
                  String text2=NbtUtil.getChild(entity,""String_Node_Str"",StringTag.class).getValue();
                  String text3=NbtUtil.getChild(entity,""String_Node_Str"",StringTag.class).getValue();
                  String text4=NbtUtil.getChild(entity,""String_Node_Str"",StringTag.class).getValue();
                  if (!text1.isEmpty() && FileUtils.isJSONValid(text1)) {
                    text1=text1.replaceAll(""String_Node_Str"",""String_Node_Str"").split(""String_Node_Str"",2)[1];
                    text2=text2.replaceAll(""String_Node_Str"",""String_Node_Str"").split(""String_Node_Str"",2)[1];
                    text3=text3.replaceAll(""String_Node_Str"",""String_Node_Str"").split(""String_Node_Str"",2)[1];
                    text4=text4.replaceAll(""String_Node_Str"",""String_Node_Str"").split(""String_Node_Str"",2)[1];
                  }
                  text1=text1.replaceAll(""String_Node_Str"",""String_Node_Str"");
                  if (text1 == null || text1.equals(""String_Node_Str""))                   text1=""String_Node_Str"";
                  text2=text2.replaceAll(""String_Node_Str"",""String_Node_Str"");
                  if (text2 == null || text2.equals(""String_Node_Str""))                   text2=""String_Node_Str"";
                  text3=text3.replaceAll(""String_Node_Str"",""String_Node_Str"");
                  if (text3 == null || text3.equals(""String_Node_Str""))                   text3=""String_Node_Str"";
                  text4=text4.replaceAll(""String_Node_Str"",""String_Node_Str"");
                  if (text4 == null || text4.equals(""String_Node_Str""))                   text4=""String_Node_Str"";
                  final int x=xTag.getValue();
                  final int y=yTag.getValue();
                  final int z=zTag.getValue();
                  final int localX=x - (blockX * WIDTH);
                  final int localY=y - (blockY * HEIGHT);
                  final int localZ=z - (blockZ * DEPTH);
                  final int blockId=getBlockId(localX,localY,localZ);
                  final int data=getBlockData(localX,localY,localZ);
                  signs.add(new RawSign(blockId,data,x,y,z,localX,localY,localZ,text1,text2,text3,text4));
                }
 else                 if (id.equals(""String_Node_Str"")) {
                  IntTag dataTag=NbtUtil.getChild(entity,""String_Node_Str"",IntTag.class);
                  IntTag itemTag=NbtUtil.getChild(entity,""String_Node_Str"",IntTag.class);
                  final int item;
                  if (itemTag == null) {
                    StringTag stringIdTag=NbtUtil.getChild(entity,""String_Node_Str"",StringTag.class);
                    if (stringIdTag.getValue().equals(""String_Node_Str""))                     item=6;
 else                     if (stringIdTag.getValue().equals(""String_Node_Str""))                     item=38;
 else                     item=0;
                  }
 else {
                    item=itemTag.getValue();
                  }
                  final int x=xTag.getValue();
                  final int y=yTag.getValue();
                  final int z=zTag.getValue();
                  final int localX=x - (blockX * WIDTH);
                  final int localY=y - (blockY * HEIGHT);
                  final int localZ=z - (blockZ * DEPTH);
                  final int blockData=getBlockData(localX,localY,localZ);
                  final int itemData=dataTag.getValue();
                  flowerPots.add(new TileEntity(0,blockData,x,y,z,localX,localY,localZ,itemData,item));
                }
 else                 if (id.equals(""String_Node_Str"")) {
                  ByteTag skullType=NbtUtil.getChild(entity,""String_Node_Str"",ByteTag.class);
                  ByteTag rot=NbtUtil.getChild(entity,""String_Node_Str"",ByteTag.class);
                  StringTag nameTag=null;
                  StringTag playerId=null;
                  String name=""String_Node_Str"";
                  String UUID=""String_Node_Str"";
                  String textureURL=""String_Node_Str"";
                  StringTag extraType=NbtUtil.getChild(entity,""String_Node_Str"",StringTag.class);
                  CompoundTag owner=NbtUtil.getChild(entity,""String_Node_Str"",CompoundTag.class);
                  if (owner != null) {
                    nameTag=NbtUtil.getChild(owner,""String_Node_Str"",StringTag.class);
                    name=nameTag.getValue();
                    playerId=NbtUtil.getChild(owner,""String_Node_Str"",StringTag.class);
                    UUID=playerId.getValue().replace(""String_Node_Str"",""String_Node_Str"");
                    CompoundTag properties=NbtUtil.getChild(owner,""String_Node_Str"",CompoundTag.class);
                    ListTag textures=NbtUtil.getChild(properties,""String_Node_Str"",ListTag.class);
                    CompoundTag tex=NbtUtil.getChild(textures,0,CompoundTag.class);
                    StringTag value=NbtUtil.getChild(tex,""String_Node_Str"",StringTag.class);
                    byte[] decoded=DatatypeConverter.parseBase64Binary(value.getValue());
                    JSONObject obj=new JSONObject(new String(decoded,""String_Node_Str""));
                    textureURL=obj.getJSONObject(""String_Node_Str"").getJSONObject(""String_Node_Str"").getString(""String_Node_Str"");
                  }
 else                   if (extraType != null && !(extraType.getValue().equals(""String_Node_Str""))) {
                    name=UUID=extraType.getValue();
                    textureURL=""String_Node_Str"" + extraType.getValue() + ""String_Node_Str"";
                  }
                  final int x=xTag.getValue();
                  final int y=yTag.getValue();
                  final int z=zTag.getValue();
                  final int localX=x - (blockX * WIDTH);
                  final int localY=y - (blockY * HEIGHT);
                  final int localZ=z - (blockZ * DEPTH);
                  skulls.add(new TileEntity(skullType.getValue(),rot.getValue(),x,y,z,localX,localY,localZ,name,UUID,textureURL,null));
                }
 else                 if (id.equals(""String_Node_Str"")) {
                  IntTag levels=NbtUtil.getChild(entity,""String_Node_Str"",IntTag.class);
                  final int x=xTag.getValue();
                  final int y=yTag.getValue();
                  final int z=zTag.getValue();
                  final int localX=x - (blockX * WIDTH);
                  final int localY=y - (blockY * HEIGHT);
                  final int localZ=z - (blockZ * DEPTH);
                  beacons.add(new TileEntity(0,levels.getValue(),x,y,z,localX,localY,localZ,0,0));
                }
 else                 if (id.equals(""String_Node_Str"")) {
                  IntTag base=NbtUtil.getChild(entity,""String_Node_Str"",IntTag.class);
                  ListTag patternList=NbtUtil.getChild(entity,""String_Node_Str"",ListTag.class);
                  final int x=xTag.getValue();
                  final int y=yTag.getValue();
                  final int z=zTag.getValue();
                  final int localX=x - (blockX * WIDTH);
                  final int localY=y - (blockY * HEIGHT);
                  final int localZ=z - (blockZ * DEPTH);
                  String patterns=""String_Node_Str"";
                  final int numPatterns=patternList.getValue().size();
                  if (numPatterns > 0) {
                    patterns+=""String_Node_Str"";
                    for (int i=0; i < numPatterns; i++) {
                      CompoundTag p=NbtUtil.getChild(patternList,i,CompoundTag.class);
                      StringTag pattern=NbtUtil.getChild(p,""String_Node_Str"",StringTag.class);
                      IntTag color=NbtUtil.getChild(p,""String_Node_Str"",IntTag.class);
                      patterns+=""String_Node_Str"" + pattern.getValue() + ""String_Node_Str""+ ""String_Node_Str""+ color.getValue().toString();
                      if (i < numPatterns - 1)                       patterns+=""String_Node_Str"";
                    }
                    patterns+=""String_Node_Str"";
                  }
                  banners.add(new TileEntity(0,base.getValue(),x,y,z,localX,localY,localZ,patterns,0));
                }
              }
            }
          }
        }
      }
    }
  }
  finally {
    if (nbtIn != null)     nbtIn.close();
    if (in != null)     in.close();
  }
}","private void init(InputStream in,Compression compression) throws Exception {
  clear();
  NBTInputStream nbtIn=null;
  try {
    nbtIn=new NBTInputStream(in,compression);
    Tag tag=nbtIn.readTag();
    if (tag instanceof CompoundTag) {
      CompoundTag root=(CompoundTag)tag;
      CompoundTag level=NbtUtil.getChild(root,""String_Node_Str"",CompoundTag.class);
      if (level != null) {
        blockX=blockY=blockZ=0;
        IntTag xPosTag=NbtUtil.getChild(level,""String_Node_Str"",IntTag.class);
        if (xPosTag != null)         blockX=xPosTag.getValue().intValue();
        IntTag zPosTag=NbtUtil.getChild(level,""String_Node_Str"",IntTag.class);
        if (zPosTag != null)         blockZ=zPosTag.getValue().intValue();
        ListTag sections=NbtUtil.getChild(level,""String_Node_Str"",ListTag.class);
        if (sections != null) {
          parseAnvilData(level);
        }
 else {
          parseMcRegionData(level);
        }
        ListTag entitiesTag=NbtUtil.getChild(level,""String_Node_Str"",ListTag.class);
        if (entitiesTag != null) {
          for (          Tag t : entitiesTag.getValue()) {
            if (t instanceof CompoundTag) {
              CompoundTag entity=(CompoundTag)t;
              StringTag idTag=NbtUtil.getChild(entity,""String_Node_Str"",StringTag.class);
              if (idTag.getValue().endsWith(""String_Node_Str"")) {
                StringTag motiveTag=NbtUtil.getChild(entity,""String_Node_Str"",StringTag.class);
                IntTag xTag=NbtUtil.getChild(entity,""String_Node_Str"",IntTag.class);
                IntTag yTag=NbtUtil.getChild(entity,""String_Node_Str"",IntTag.class);
                IntTag zTag=NbtUtil.getChild(entity,""String_Node_Str"",IntTag.class);
                ByteTag oldDir=NbtUtil.getChild(entity,""String_Node_Str"",ByteTag.class);
                ByteTag dir=NbtUtil.getChild(entity,""String_Node_Str"",ByteTag.class);
                if (oldDir != null && dir == null) {
                  dir=oldDir;
                }
                boolean is18=false;
                if (dir == null) {
                  dir=NbtUtil.getChild(entity,""String_Node_Str"",ByteTag.class);
                  is18=true;
                }
                int direction=dir.getValue();
                if (oldDir != null && direction == 0) {
                  direction=2;
                }
 else                 if (oldDir != null && direction == 2) {
                  direction=0;
                }
                int x=xTag.getValue();
                final int y=yTag.getValue();
                int z=zTag.getValue();
                if (is18 && direction == 0) {
                  z=zTag.getValue() - 1;
                }
 else                 if (is18 && direction == 1) {
                  x=xTag.getValue() + 1;
                }
 else                 if (is18 && direction == 2) {
                  z=zTag.getValue() + 1;
                }
 else                 if (is18 && direction == 3) {
                  x=xTag.getValue() - 1;
                }
                final int localX=x - (blockX * WIDTH);
                final int localY=y - (blockY * HEIGHT);
                final int localZ=z - (blockZ * DEPTH);
                paintings.add(new TileEntity(-1,0,x,y,z,localX,localY,localZ,motiveTag.getValue(),direction));
              }
 else               if (idTag.getValue().equals(""String_Node_Str"")) {
                IntTag xTag=NbtUtil.getChild(entity,""String_Node_Str"",IntTag.class);
                IntTag yTag=NbtUtil.getChild(entity,""String_Node_Str"",IntTag.class);
                IntTag zTag=NbtUtil.getChild(entity,""String_Node_Str"",IntTag.class);
                ByteTag dir=NbtUtil.getChild(entity,""String_Node_Str"",ByteTag.class);
                boolean is18=false;
                if (dir == null) {
                  dir=NbtUtil.getChild(entity,""String_Node_Str"",ByteTag.class);
                  is18=true;
                }
                String item=""String_Node_Str"";
                Map<String,Tag> map=entity.getValue();
                CompoundTag itemTag=(CompoundTag)map.get(""String_Node_Str"");
                if (itemTag != null) {
                  ShortTag itemIdTag=NbtUtil.getChild(itemTag,""String_Node_Str"",ShortTag.class);
                  if (itemIdTag == null) {
                    StringTag stringItemIdTag=NbtUtil.getChild(itemTag,""String_Node_Str"",StringTag.class);
                    item=stringItemIdTag.getValue();
                  }
 else {
                    if (itemIdTag.getValue() == 358)                     item=""String_Node_Str"";
                  }
                }
                int x=xTag.getValue();
                final int y=yTag.getValue();
                int z=zTag.getValue();
                if (is18 && dir.getValue() == 0) {
                  z=zTag.getValue() - 1;
                }
 else                 if (is18 && dir.getValue() == 1) {
                  x=xTag.getValue() + 1;
                }
 else                 if (is18 && dir.getValue() == 2) {
                  z=zTag.getValue() + 1;
                }
 else                 if (is18 && dir.getValue() == 3) {
                  x=xTag.getValue() - 1;
                }
                final int localX=x - (blockX * WIDTH);
                final int localY=y - (blockY * HEIGHT);
                final int localZ=z - (blockZ * DEPTH);
                itemFrames.add(new TileEntity(-2,0,x,y,z,localX,localY,localZ,item,dir.getValue()));
              }
            }
          }
        }
        ListTag tileEntitiesTag=NbtUtil.getChild(level,""String_Node_Str"",ListTag.class);
        if (tileEntitiesTag != null) {
          for (          Tag t : tileEntitiesTag.getValue()) {
            if (t instanceof CompoundTag) {
              CompoundTag entity=(CompoundTag)t;
              StringTag idTag=NbtUtil.getChild(entity,""String_Node_Str"",StringTag.class);
              IntTag xTag=NbtUtil.getChild(entity,""String_Node_Str"",IntTag.class);
              IntTag yTag=NbtUtil.getChild(entity,""String_Node_Str"",IntTag.class);
              IntTag zTag=NbtUtil.getChild(entity,""String_Node_Str"",IntTag.class);
              if (idTag != null && xTag != null && yTag != null && zTag != null) {
                String id=idTag.getValue();
                if (id.equals(""String_Node_Str"")) {
                  String text1=NbtUtil.getChild(entity,""String_Node_Str"",StringTag.class).getValue();
                  String text2=NbtUtil.getChild(entity,""String_Node_Str"",StringTag.class).getValue();
                  String text3=NbtUtil.getChild(entity,""String_Node_Str"",StringTag.class).getValue();
                  String text4=NbtUtil.getChild(entity,""String_Node_Str"",StringTag.class).getValue();
                  if (!text1.isEmpty() && FileUtils.isJSONValid(text1)) {
                    text1=text1.replaceAll(""String_Node_Str"",""String_Node_Str"").split(""String_Node_Str"",2)[1];
                    text2=text2.replaceAll(""String_Node_Str"",""String_Node_Str"").split(""String_Node_Str"",2)[1];
                    text3=text3.replaceAll(""String_Node_Str"",""String_Node_Str"").split(""String_Node_Str"",2)[1];
                    text4=text4.replaceAll(""String_Node_Str"",""String_Node_Str"").split(""String_Node_Str"",2)[1];
                  }
                  text1=text1.replaceAll(""String_Node_Str"",""String_Node_Str"");
                  if (text1 == null || text1.equals(""String_Node_Str""))                   text1=""String_Node_Str"";
                  text2=text2.replaceAll(""String_Node_Str"",""String_Node_Str"");
                  if (text2 == null || text2.equals(""String_Node_Str""))                   text2=""String_Node_Str"";
                  text3=text3.replaceAll(""String_Node_Str"",""String_Node_Str"");
                  if (text3 == null || text3.equals(""String_Node_Str""))                   text3=""String_Node_Str"";
                  text4=text4.replaceAll(""String_Node_Str"",""String_Node_Str"");
                  if (text4 == null || text4.equals(""String_Node_Str""))                   text4=""String_Node_Str"";
                  final int x=xTag.getValue();
                  final int y=yTag.getValue();
                  final int z=zTag.getValue();
                  final int localX=x - (blockX * WIDTH);
                  final int localY=y - (blockY * HEIGHT);
                  final int localZ=z - (blockZ * DEPTH);
                  final int blockId=getBlockId(localX,localY,localZ);
                  final int data=getBlockData(localX,localY,localZ);
                  signs.add(new RawSign(blockId,data,x,y,z,localX,localY,localZ,text1,text2,text3,text4));
                }
 else                 if (id.equals(""String_Node_Str"")) {
                  IntTag dataTag=NbtUtil.getChild(entity,""String_Node_Str"",IntTag.class);
                  IntTag itemTag=NbtUtil.getChild(entity,""String_Node_Str"",IntTag.class);
                  final int item;
                  if (itemTag == null) {
                    StringTag stringIdTag=NbtUtil.getChild(entity,""String_Node_Str"",StringTag.class);
                    if (stringIdTag.getValue().equals(""String_Node_Str""))                     item=6;
 else                     if (stringIdTag.getValue().equals(""String_Node_Str""))                     item=38;
 else                     item=0;
                  }
 else {
                    item=itemTag.getValue();
                  }
                  final int x=xTag.getValue();
                  final int y=yTag.getValue();
                  final int z=zTag.getValue();
                  final int localX=x - (blockX * WIDTH);
                  final int localY=y - (blockY * HEIGHT);
                  final int localZ=z - (blockZ * DEPTH);
                  final int blockData=getBlockData(localX,localY,localZ);
                  final int itemData=dataTag.getValue();
                  flowerPots.add(new TileEntity(0,blockData,x,y,z,localX,localY,localZ,itemData,item));
                }
 else                 if (id.equals(""String_Node_Str"")) {
                  ByteTag skullType=NbtUtil.getChild(entity,""String_Node_Str"",ByteTag.class);
                  ByteTag rot=NbtUtil.getChild(entity,""String_Node_Str"",ByteTag.class);
                  StringTag nameTag=null;
                  StringTag playerId=null;
                  String name=""String_Node_Str"";
                  String UUID=""String_Node_Str"";
                  String textureURL=""String_Node_Str"";
                  StringTag extraType=NbtUtil.getChild(entity,""String_Node_Str"",StringTag.class);
                  CompoundTag owner=NbtUtil.getChild(entity,""String_Node_Str"",CompoundTag.class);
                  if (owner != null) {
                    nameTag=NbtUtil.getChild(owner,""String_Node_Str"",StringTag.class);
                    name=nameTag.getValue();
                    playerId=NbtUtil.getChild(owner,""String_Node_Str"",StringTag.class);
                    UUID=playerId.getValue().replace(""String_Node_Str"",""String_Node_Str"");
                    CompoundTag properties=NbtUtil.getChild(owner,""String_Node_Str"",CompoundTag.class);
                    ListTag textures=NbtUtil.getChild(properties,""String_Node_Str"",ListTag.class);
                    CompoundTag tex=NbtUtil.getChild(textures,0,CompoundTag.class);
                    StringTag value=NbtUtil.getChild(tex,""String_Node_Str"",StringTag.class);
                    byte[] decoded=DatatypeConverter.parseBase64Binary(value.getValue());
                    JSONObject obj=new JSONObject(new String(decoded,""String_Node_Str""));
                    textureURL=obj.getJSONObject(""String_Node_Str"").getJSONObject(""String_Node_Str"").getString(""String_Node_Str"");
                  }
 else                   if (extraType != null && !(extraType.getValue().equals(""String_Node_Str""))) {
                    name=UUID=extraType.getValue();
                    textureURL=""String_Node_Str"" + extraType.getValue() + ""String_Node_Str"";
                  }
                  final int x=xTag.getValue();
                  final int y=yTag.getValue();
                  final int z=zTag.getValue();
                  final int localX=x - (blockX * WIDTH);
                  final int localY=y - (blockY * HEIGHT);
                  final int localZ=z - (blockZ * DEPTH);
                  skulls.add(new TileEntity(skullType.getValue(),rot.getValue(),x,y,z,localX,localY,localZ,name,UUID,textureURL,null));
                }
 else                 if (id.equals(""String_Node_Str"")) {
                  IntTag levels=NbtUtil.getChild(entity,""String_Node_Str"",IntTag.class);
                  final int x=xTag.getValue();
                  final int y=yTag.getValue();
                  final int z=zTag.getValue();
                  final int localX=x - (blockX * WIDTH);
                  final int localY=y - (blockY * HEIGHT);
                  final int localZ=z - (blockZ * DEPTH);
                  beacons.add(new TileEntity(0,levels.getValue(),x,y,z,localX,localY,localZ,0,0));
                }
 else                 if (id.equals(""String_Node_Str"")) {
                  IntTag base=NbtUtil.getChild(entity,""String_Node_Str"",IntTag.class);
                  ListTag patternList=NbtUtil.getChild(entity,""String_Node_Str"",ListTag.class);
                  final int x=xTag.getValue();
                  final int y=yTag.getValue();
                  final int z=zTag.getValue();
                  final int localX=x - (blockX * WIDTH);
                  final int localY=y - (blockY * HEIGHT);
                  final int localZ=z - (blockZ * DEPTH);
                  String patterns=""String_Node_Str"";
                  final int numPatterns=patternList.getValue().size();
                  if (numPatterns > 0) {
                    patterns+=""String_Node_Str"";
                    for (int i=0; i < numPatterns; i++) {
                      CompoundTag p=NbtUtil.getChild(patternList,i,CompoundTag.class);
                      StringTag pattern=NbtUtil.getChild(p,""String_Node_Str"",StringTag.class);
                      IntTag color=NbtUtil.getChild(p,""String_Node_Str"",IntTag.class);
                      patterns+=""String_Node_Str"" + pattern.getValue() + ""String_Node_Str""+ ""String_Node_Str""+ color.getValue().toString();
                      if (i < numPatterns - 1)                       patterns+=""String_Node_Str"";
                    }
                    patterns+=""String_Node_Str"";
                  }
                  banners.add(new TileEntity(0,base.getValue(),x,y,z,localX,localY,localZ,patterns,0));
                }
              }
            }
          }
        }
      }
    }
  }
  finally {
    if (nbtIn != null)     nbtIn.close();
    if (in != null)     in.close();
  }
}",0.9813668890655788
80069,"public World(Rasteriser rasteriser,File baseDir,Dimension dimension,File minecraftJar,File texturePackFile,List<File> modJars,BiomeCache biomeCache,MessageDigest hashAlgorithm,String singlePlayerName,WorldSubsetFactory subsetFactory,PlayerSkinCache playerSkinCache){
  this.rasteriser=rasteriser;
  this.defaultBlockId=BlockIds.AIR;
  this.blockFilter=new NullBlockFilter();
  this.blockMaskFactory=new NullBlockMaskFactory();
  this.worldDir=baseDir;
  if (dimension == Dimension.Terra) {
    dimensionDir=worldDir;
  }
 else   if (dimension == Dimension.Nether) {
    dimensionDir=new File(worldDir,""String_Node_Str"");
  }
 else   if (dimension == Dimension.Ender) {
    dimensionDir=new File(worldDir,""String_Node_Str"");
  }
 else {
    dimensionDir=worldDir;
  }
  System.out.println(""String_Node_Str"" + worldDir.getPath() + ""String_Node_Str""+ dimension);
  System.out.println(""String_Node_Str"" + dimensionDir.getAbsolutePath());
  this.biomeCache=biomeCache;
  this.playerSkinCache=playerSkinCache;
  if (!Minecraft.isValidWorldDir(baseDir))   throw new RuntimeException(""String_Node_Str"" + Minecraft.findLevelDat(baseDir).getAbsolutePath());
  if (!Minecraft.isValidDimensionDir(dimensionDir))   throw new RuntimeException(""String_Node_Str"" + dimensionDir.getAbsolutePath());
  try {
    System.out.println(""String_Node_Str"");
    levelDat=new LevelDat(Minecraft.findLevelDat(baseDir),singlePlayerName);
    if (levelDat.getVersion() == LevelDat.UNKNOWN_VERSION) {
      throw new RuntimeException(""String_Node_Str"");
    }
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
  System.out.println(""String_Node_Str"");
  texturePack=new TexturePack(rasteriser,minecraftJar,texturePackFile,modJars);
  this.textureVersion=texturePack.getVersion();
  System.out.println(""String_Node_Str"");
  loadBlockRegistry(null,true);
  System.out.println(""String_Node_Str"");
  players=loadPlayers(worldDir,playerSkinCache);
  regionCache=new RegionCache(dimensionDir);
  chunkLocator=new ChunkLocator(dimensionDir,biomeCache,regionCache);
  rawLoadedChunks=new RawCache(100);
  geometryLoadedChunks=new GeometryCache(100);
  this.worldSubset=subsetFactory.create(this);
  this.lightStyle=LightStyle.None;
  this.daySkybox=SkyboxUtil.generateDaySkybox(rasteriser);
  this.nightSkybox=SkyboxUtil.generateNightSkybox(rasteriser);
}","public World(Rasteriser rasteriser,File baseDir,Dimension dimension,File minecraftJar,File texturePackFile,List<File> modJars,BiomeCache biomeCache,MessageDigest hashAlgorithm,String singlePlayerName,WorldSubsetFactory subsetFactory,PlayerSkinCache playerSkinCache){
  this.rasteriser=rasteriser;
  this.defaultBlockId=BlockIds.AIR;
  this.blockFilter=new NullBlockFilter();
  this.blockMaskFactory=new NullBlockMaskFactory();
  this.worldDir=baseDir;
  if (dimension == Dimension.Terra) {
    dimensionDir=worldDir;
  }
 else   if (dimension == Dimension.Nether) {
    dimensionDir=new File(worldDir,""String_Node_Str"");
  }
 else   if (dimension == Dimension.Ender) {
    dimensionDir=new File(worldDir,""String_Node_Str"");
  }
 else {
    dimensionDir=worldDir;
  }
  System.out.println(""String_Node_Str"" + worldDir.getPath() + ""String_Node_Str""+ dimension);
  System.out.println(""String_Node_Str"" + dimensionDir.getAbsolutePath());
  this.biomeCache=biomeCache;
  this.playerSkinCache=playerSkinCache;
  if (!Minecraft.isValidWorldDir(baseDir))   throw new RuntimeException(""String_Node_Str"" + Minecraft.findLevelDat(baseDir).getAbsolutePath());
  if (!Minecraft.isValidDimensionDir(dimensionDir))   throw new RuntimeException(""String_Node_Str"" + dimensionDir.getAbsolutePath());
  try {
    System.out.println(""String_Node_Str"");
    levelDat=new LevelDat(Minecraft.findLevelDat(baseDir),singlePlayerName);
    if (levelDat.getVersion() == LevelDat.UNKNOWN_VERSION) {
      throw new RuntimeException(""String_Node_Str"");
    }
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
  if (dimension == Dimension.Ender) {
    levelDat.setSpawnPosition(100,49,0);
  }
  System.out.println(""String_Node_Str"");
  texturePack=new TexturePack(rasteriser,minecraftJar,texturePackFile,modJars);
  this.textureVersion=texturePack.getVersion();
  System.out.println(""String_Node_Str"");
  loadBlockRegistry(null,true);
  System.out.println(""String_Node_Str"");
  players=loadPlayers(worldDir,playerSkinCache);
  regionCache=new RegionCache(dimensionDir);
  chunkLocator=new ChunkLocator(dimensionDir,biomeCache,regionCache);
  rawLoadedChunks=new RawCache(100);
  geometryLoadedChunks=new GeometryCache(100);
  this.worldSubset=subsetFactory.create(this);
  this.lightStyle=LightStyle.None;
  this.daySkybox=SkyboxUtil.generateDaySkybox(rasteriser);
  this.nightSkybox=SkyboxUtil.generateNightSkybox(rasteriser);
}",0.7703641338665544
80070,"public static String jsEscape(String text){
  text=text.replace(""String_Node_Str"",""String_Node_Str"");
  text=text.replace(""String_Node_Str"",""String_Node_Str"");
  text=text.replace(""String_Node_Str"",""String_Node_Str"");
  text=text.replace(""String_Node_Str"",""String_Node_Str"");
  return text;
}","public static String jsEscape(String text){
  text=text.replace(""String_Node_Str"",""String_Node_Str"");
  return text;
}",0.5756097560975609
80071,"private void outputViews(File viewsFile,HddObjectListReader<Sign> views,tectonicus.configuration.Map map,ImageFormat imageFormat){
  System.out.println(""String_Node_Str"");
  if (viewsFile.exists())   viewsFile.delete();
  JsArrayWriter jsWriter=null;
  try {
    jsWriter=new JsArrayWriter(viewsFile,map.getId() + ""String_Node_Str"");
    Sign sign=new Sign();
    while (views.hasNext()) {
      views.read(sign);
      HashMap<String,String> args=new HashMap<String,String>();
      final float worldX=sign.getX() + 0.5f;
      final float worldY=sign.getY();
      final float worldZ=sign.getZ() + 0.5f;
      String posStr=""String_Node_Str"" + worldX + ""String_Node_Str""+ worldY+ ""String_Node_Str""+ worldZ+ ""String_Node_Str"";
      args.put(""String_Node_Str"",posStr);
      String text=sign.getText(1) + ""String_Node_Str"" + sign.getText(2)+ ""String_Node_Str""+ sign.getText(3);
      text=text.trim();
      args.put(""String_Node_Str"",""String_Node_Str"" + jsEscape(text) + ""String_Node_Str"");
      String filename=map.getId() + ""String_Node_Str"" + sign.getX()+ ""String_Node_Str""+ sign.getY()+ ""String_Node_Str""+ sign.getZ()+ ""String_Node_Str""+ imageFormat.getExtension();
      args.put(""String_Node_Str"",""String_Node_Str"" + filename + ""String_Node_Str"");
      jsWriter.write(args);
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
 finally {
    if (jsWriter != null)     jsWriter.close();
  }
}","private void outputViews(File viewsFile,HddObjectListReader<Sign> views,tectonicus.configuration.Map map,ImageFormat imageFormat){
  System.out.println(""String_Node_Str"");
  if (viewsFile.exists())   viewsFile.delete();
  JsArrayWriter jsWriter=null;
  try {
    jsWriter=new JsArrayWriter(viewsFile,map.getId() + ""String_Node_Str"");
    Sign sign=new Sign();
    while (views.hasNext()) {
      views.read(sign);
      HashMap<String,String> args=new HashMap<String,String>();
      final float worldX=sign.getX() + 0.5f;
      final float worldY=sign.getY();
      final float worldZ=sign.getZ() + 0.5f;
      String posStr=""String_Node_Str"" + worldX + ""String_Node_Str""+ worldY+ ""String_Node_Str""+ worldZ+ ""String_Node_Str"";
      args.put(""String_Node_Str"",posStr);
      String text=""String_Node_Str"";
      for (int i=1; i < 4; i++) {
        if (!sign.getText(i).startsWith(""String_Node_Str"")) {
          text=text + sign.getText(i);
        }
      }
      text=text.trim();
      args.put(""String_Node_Str"",""String_Node_Str"" + jsEscape(text) + ""String_Node_Str"");
      String filename=map.getId() + ""String_Node_Str"" + sign.getX()+ ""String_Node_Str""+ sign.getY()+ ""String_Node_Str""+ sign.getZ()+ ""String_Node_Str""+ imageFormat.getExtension();
      args.put(""String_Node_Str"",""String_Node_Str"" + filename + ""String_Node_Str"");
      jsWriter.write(args);
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
 finally {
    if (jsWriter != null)     jsWriter.close();
  }
}",0.9301685586515308
80072,"private static Set<String> extractSettings(Sign sign){
  String toParse=sign.getText(0);
  if (sign.getText(1).startsWith(""String_Node_Str""))   toParse+=""String_Node_Str"" + sign.getText(1);
  if (sign.getText(2).startsWith(""String_Node_Str""))   toParse+=""String_Node_Str"" + sign.getText(2);
  Set<String> settings=new HashSet<String>();
  StringTokenizer tokeniser=new StringTokenizer(toParse);
  while (tokeniser.hasMoreTokens()) {
    String token=tokeniser.nextToken();
    if (token != null) {
      token=token.trim().toLowerCase();
      settings.add(token);
    }
  }
  return settings;
}","private static Set<String> extractSettings(Sign sign){
  String toParse=sign.getText(0);
  if (sign.getText(1).startsWith(""String_Node_Str"") && sign.getText(1).length() > 1)   toParse+=""String_Node_Str"" + sign.getText(1).substring(1);
  if (sign.getText(2).startsWith(""String_Node_Str"") && sign.getText(2).length() > 1)   toParse+=""String_Node_Str"" + sign.getText(2).substring(1);
  if (sign.getText(3).startsWith(""String_Node_Str"") && sign.getText(3).length() > 1)   toParse+=""String_Node_Str"" + sign.getText(3).substring(1);
  Set<String> settings=new HashSet<String>();
  StringTokenizer tokeniser=new StringTokenizer(toParse);
  while (tokeniser.hasMoreTokens()) {
    String token=tokeniser.nextToken();
    if (token != null) {
      token=token.trim().toLowerCase();
      settings.add(token);
    }
  }
  return settings;
}",0.8345021037868162
80073,"private void init(InputStream in,Compression compression) throws Exception {
  clear();
  NBTInputStream nbtIn=null;
  try {
    nbtIn=new NBTInputStream(in,compression);
    Tag tag=nbtIn.readTag();
    if (tag instanceof CompoundTag) {
      CompoundTag root=(CompoundTag)tag;
      CompoundTag level=NbtUtil.getChild(root,""String_Node_Str"",CompoundTag.class);
      if (level != null) {
        blockX=blockY=blockZ=0;
        IntTag xPosTag=NbtUtil.getChild(level,""String_Node_Str"",IntTag.class);
        if (xPosTag != null)         blockX=xPosTag.getValue().intValue();
        IntTag zPosTag=NbtUtil.getChild(level,""String_Node_Str"",IntTag.class);
        if (zPosTag != null)         blockZ=zPosTag.getValue().intValue();
        ListTag sections=NbtUtil.getChild(level,""String_Node_Str"",ListTag.class);
        if (sections != null) {
          parseAnvilData(level);
        }
 else {
          parseMcRegionData(level);
        }
        ListTag entitiesTag=NbtUtil.getChild(level,""String_Node_Str"",ListTag.class);
        if (entitiesTag != null) {
          for (          Tag t : entitiesTag.getValue()) {
            if (t instanceof CompoundTag) {
              CompoundTag entity=(CompoundTag)t;
              StringTag idTag=NbtUtil.getChild(entity,""String_Node_Str"",StringTag.class);
              if (idTag.getValue().endsWith(""String_Node_Str"")) {
                StringTag motiveTag=NbtUtil.getChild(entity,""String_Node_Str"",StringTag.class);
                IntTag xTag=NbtUtil.getChild(entity,""String_Node_Str"",IntTag.class);
                IntTag yTag=NbtUtil.getChild(entity,""String_Node_Str"",IntTag.class);
                IntTag zTag=NbtUtil.getChild(entity,""String_Node_Str"",IntTag.class);
                ByteTag oldDir=NbtUtil.getChild(entity,""String_Node_Str"",ByteTag.class);
                ByteTag dir=NbtUtil.getChild(entity,""String_Node_Str"",ByteTag.class);
                if (oldDir != null && dir == null) {
                  dir=oldDir;
                }
                boolean is18=false;
                if (dir == null) {
                  dir=NbtUtil.getChild(entity,""String_Node_Str"",ByteTag.class);
                  is18=true;
                }
                int direction=dir.getValue();
                if (oldDir != null && direction == 0) {
                  direction=2;
                }
 else                 if (oldDir != null && direction == 2) {
                  direction=0;
                }
                int x=xTag.getValue();
                final int y=yTag.getValue();
                int z=zTag.getValue();
                if (is18 && direction == 0) {
                  z=zTag.getValue() - 1;
                }
 else                 if (is18 && direction == 1) {
                  x=xTag.getValue() + 1;
                }
 else                 if (is18 && direction == 2) {
                  z=zTag.getValue() + 1;
                }
 else                 if (is18 && direction == 3) {
                  x=xTag.getValue() - 1;
                }
                final int localX=x - (blockX * WIDTH);
                final int localY=y - (blockY * HEIGHT);
                final int localZ=z - (blockZ * DEPTH);
                paintings.add(new TileEntity(-1,0,x,y,z,localX,localY,localZ,motiveTag.getValue(),direction));
              }
 else               if (idTag.getValue().equals(""String_Node_Str"")) {
                IntTag xTag=NbtUtil.getChild(entity,""String_Node_Str"",IntTag.class);
                IntTag yTag=NbtUtil.getChild(entity,""String_Node_Str"",IntTag.class);
                IntTag zTag=NbtUtil.getChild(entity,""String_Node_Str"",IntTag.class);
                ByteTag dir=NbtUtil.getChild(entity,""String_Node_Str"",ByteTag.class);
                boolean is18=false;
                if (dir == null) {
                  dir=NbtUtil.getChild(entity,""String_Node_Str"",ByteTag.class);
                  is18=true;
                }
                String item=""String_Node_Str"";
                Map<String,Tag> map=entity.getValue();
                CompoundTag itemTag=(CompoundTag)map.get(""String_Node_Str"");
                if (itemTag != null) {
                  ShortTag itemIdTag=NbtUtil.getChild(itemTag,""String_Node_Str"",ShortTag.class);
                  if (itemIdTag == null) {
                    StringTag stringItemIdTag=NbtUtil.getChild(itemTag,""String_Node_Str"",StringTag.class);
                    item=stringItemIdTag.getValue();
                  }
 else {
                    if (itemIdTag.getValue() == 358)                     item=""String_Node_Str"";
                  }
                }
                int x=xTag.getValue();
                final int y=yTag.getValue();
                int z=zTag.getValue();
                if (is18 && dir.getValue() == 0) {
                  z=zTag.getValue() - 1;
                }
 else                 if (is18 && dir.getValue() == 1) {
                  x=xTag.getValue() + 1;
                }
 else                 if (is18 && dir.getValue() == 2) {
                  z=zTag.getValue() + 1;
                }
 else                 if (is18 && dir.getValue() == 3) {
                  x=xTag.getValue() - 1;
                }
                final int localX=x - (blockX * WIDTH);
                final int localY=y - (blockY * HEIGHT);
                final int localZ=z - (blockZ * DEPTH);
                itemFrames.add(new TileEntity(-2,0,x,y,z,localX,localY,localZ,item,dir.getValue()));
              }
            }
          }
        }
        ListTag tileEntitiesTag=NbtUtil.getChild(level,""String_Node_Str"",ListTag.class);
        if (tileEntitiesTag != null) {
          for (          Tag t : tileEntitiesTag.getValue()) {
            if (t instanceof CompoundTag) {
              CompoundTag entity=(CompoundTag)t;
              StringTag idTag=NbtUtil.getChild(entity,""String_Node_Str"",StringTag.class);
              IntTag xTag=NbtUtil.getChild(entity,""String_Node_Str"",IntTag.class);
              IntTag yTag=NbtUtil.getChild(entity,""String_Node_Str"",IntTag.class);
              IntTag zTag=NbtUtil.getChild(entity,""String_Node_Str"",IntTag.class);
              if (idTag != null && xTag != null && yTag != null && zTag != null) {
                String id=idTag.getValue();
                if (id.equals(""String_Node_Str"")) {
                  String text1=NbtUtil.getChild(entity,""String_Node_Str"",StringTag.class).getValue();
                  String text2=NbtUtil.getChild(entity,""String_Node_Str"",StringTag.class).getValue();
                  String text3=NbtUtil.getChild(entity,""String_Node_Str"",StringTag.class).getValue();
                  String text4=NbtUtil.getChild(entity,""String_Node_Str"",StringTag.class).getValue();
                  if (!text1.isEmpty() && FileUtils.isJSONValid(text1)) {
                    text1=text1.replaceAll(""String_Node_Str"",""String_Node_Str"").split(""String_Node_Str"",2)[1];
                    text2=text2.replaceAll(""String_Node_Str"",""String_Node_Str"").split(""String_Node_Str"",2)[1];
                    text3=text3.replaceAll(""String_Node_Str"",""String_Node_Str"").split(""String_Node_Str"",2)[1];
                    text4=text4.replaceAll(""String_Node_Str"",""String_Node_Str"").split(""String_Node_Str"",2)[1];
                  }
                  text1=text1.replaceAll(""String_Node_Str"",""String_Node_Str"");
                  if (text1 == null || text1.equals(""String_Node_Str""))                   text1=""String_Node_Str"";
                  text2=text2.replaceAll(""String_Node_Str"",""String_Node_Str"");
                  if (text2 == null || text2.equals(""String_Node_Str""))                   text2=""String_Node_Str"";
                  text3=text3.replaceAll(""String_Node_Str"",""String_Node_Str"");
                  if (text3 == null || text3.equals(""String_Node_Str""))                   text3=""String_Node_Str"";
                  text4=text4.replaceAll(""String_Node_Str"",""String_Node_Str"");
                  if (text4 == null || text4.equals(""String_Node_Str""))                   text4=""String_Node_Str"";
                  final int x=xTag.getValue();
                  final int y=yTag.getValue();
                  final int z=zTag.getValue();
                  final int localX=x - (blockX * WIDTH);
                  final int localY=y - (blockY * HEIGHT);
                  final int localZ=z - (blockZ * DEPTH);
                  final int blockId=getBlockId(localX,localY,localZ);
                  final int data=getBlockData(localX,localY,localZ);
                  signs.add(new RawSign(blockId,data,x,y,z,localX,localY,localZ,text1,text2,text3,text4));
                }
 else                 if (id.equals(""String_Node_Str"")) {
                  IntTag dataTag=NbtUtil.getChild(entity,""String_Node_Str"",IntTag.class);
                  IntTag itemTag=NbtUtil.getChild(entity,""String_Node_Str"",IntTag.class);
                  final int item;
                  if (itemTag == null) {
                    StringTag stringIdTag=NbtUtil.getChild(entity,""String_Node_Str"",StringTag.class);
                    if (stringIdTag.getValue().equals(""String_Node_Str""))                     item=6;
 else                     if (stringIdTag.getValue().equals(""String_Node_Str""))                     item=38;
 else                     item=0;
                  }
 else {
                    item=itemTag.getValue();
                  }
                  final int x=xTag.getValue();
                  final int y=yTag.getValue();
                  final int z=zTag.getValue();
                  final int localX=x - (blockX * WIDTH);
                  final int localY=y - (blockY * HEIGHT);
                  final int localZ=z - (blockZ * DEPTH);
                  final int blockData=getBlockData(localX,localY,localZ);
                  final int itemData=dataTag.getValue();
                  flowerPots.add(new TileEntity(0,blockData,x,y,z,localX,localY,localZ,itemData,item));
                }
 else                 if (id.equals(""String_Node_Str"")) {
                  ByteTag skullType=NbtUtil.getChild(entity,""String_Node_Str"",ByteTag.class);
                  ByteTag rot=NbtUtil.getChild(entity,""String_Node_Str"",ByteTag.class);
                  StringTag nameTag=null;
                  StringTag playerId=null;
                  String name=""String_Node_Str"";
                  String UUID=""String_Node_Str"";
                  String textureURL=""String_Node_Str"";
                  StringTag extraType=NbtUtil.getChild(entity,""String_Node_Str"",StringTag.class);
                  CompoundTag owner=NbtUtil.getChild(entity,""String_Node_Str"",CompoundTag.class);
                  if (owner != null) {
                    nameTag=NbtUtil.getChild(owner,""String_Node_Str"",StringTag.class);
                    name=nameTag.getValue();
                    playerId=NbtUtil.getChild(owner,""String_Node_Str"",StringTag.class);
                    UUID=playerId.getValue().replace(""String_Node_Str"",""String_Node_Str"");
                    CompoundTag properties=NbtUtil.getChild(owner,""String_Node_Str"",CompoundTag.class);
                    ListTag textures=NbtUtil.getChild(properties,""String_Node_Str"",ListTag.class);
                    CompoundTag tex=NbtUtil.getChild(textures,0,CompoundTag.class);
                    StringTag value=NbtUtil.getChild(tex,""String_Node_Str"",StringTag.class);
                    byte[] decoded=DatatypeConverter.parseBase64Binary(value.getValue());
                    JSONObject obj=new JSONObject(new String(decoded,""String_Node_Str""));
                    textureURL=obj.getJSONObject(""String_Node_Str"").getJSONObject(""String_Node_Str"").getString(""String_Node_Str"");
                  }
 else                   if (extraType != null && !(extraType.getValue().equals(""String_Node_Str""))) {
                    name=UUID=extraType.getValue();
                    textureURL=""String_Node_Str"" + extraType.getValue() + ""String_Node_Str"";
                  }
                  final int x=xTag.getValue();
                  final int y=yTag.getValue();
                  final int z=zTag.getValue();
                  final int localX=x - (blockX * WIDTH);
                  final int localY=y - (blockY * HEIGHT);
                  final int localZ=z - (blockZ * DEPTH);
                  skulls.add(new TileEntity(skullType.getValue(),rot.getValue(),x,y,z,localX,localY,localZ,name,UUID,textureURL,null));
                }
 else                 if (id.equals(""String_Node_Str"")) {
                  IntTag levels=NbtUtil.getChild(entity,""String_Node_Str"",IntTag.class);
                  final int x=xTag.getValue();
                  final int y=yTag.getValue();
                  final int z=zTag.getValue();
                  final int localX=x - (blockX * WIDTH);
                  final int localY=y - (blockY * HEIGHT);
                  final int localZ=z - (blockZ * DEPTH);
                  beacons.add(new TileEntity(0,levels.getValue(),x,y,z,localX,localY,localZ,0,0));
                }
 else                 if (id.equals(""String_Node_Str"")) {
                  IntTag base=NbtUtil.getChild(entity,""String_Node_Str"",IntTag.class);
                  ListTag patternList=NbtUtil.getChild(entity,""String_Node_Str"",ListTag.class);
                  final int x=xTag.getValue();
                  final int y=yTag.getValue();
                  final int z=zTag.getValue();
                  final int localX=x - (blockX * WIDTH);
                  final int localY=y - (blockY * HEIGHT);
                  final int localZ=z - (blockZ * DEPTH);
                  String patterns=""String_Node_Str"";
                  final int numPatterns=patternList.getValue().size();
                  if (numPatterns > 0) {
                    patterns+=""String_Node_Str"";
                    for (int i=0; i < numPatterns; i++) {
                      CompoundTag p=NbtUtil.getChild(patternList,i,CompoundTag.class);
                      StringTag pattern=NbtUtil.getChild(p,""String_Node_Str"",StringTag.class);
                      IntTag color=NbtUtil.getChild(p,""String_Node_Str"",IntTag.class);
                      patterns+=""String_Node_Str"" + pattern.getValue() + ""String_Node_Str""+ ""String_Node_Str""+ color.getValue().toString();
                      if (i < numPatterns - 1)                       patterns+=""String_Node_Str"";
                    }
                    patterns+=""String_Node_Str"";
                  }
                  banners.add(new TileEntity(0,base.getValue(),x,y,z,localX,localY,localZ,patterns,0));
                }
              }
            }
          }
        }
      }
    }
  }
  finally {
    if (nbtIn != null)     nbtIn.close();
    if (in != null)     in.close();
  }
}","private void init(InputStream in,Compression compression) throws Exception {
  clear();
  NBTInputStream nbtIn=null;
  try {
    nbtIn=new NBTInputStream(in,compression);
    Tag tag=nbtIn.readTag();
    if (tag instanceof CompoundTag) {
      CompoundTag root=(CompoundTag)tag;
      CompoundTag level=NbtUtil.getChild(root,""String_Node_Str"",CompoundTag.class);
      if (level != null) {
        blockX=blockY=blockZ=0;
        IntTag xPosTag=NbtUtil.getChild(level,""String_Node_Str"",IntTag.class);
        if (xPosTag != null)         blockX=xPosTag.getValue().intValue();
        IntTag zPosTag=NbtUtil.getChild(level,""String_Node_Str"",IntTag.class);
        if (zPosTag != null)         blockZ=zPosTag.getValue().intValue();
        ListTag sections=NbtUtil.getChild(level,""String_Node_Str"",ListTag.class);
        if (sections != null) {
          parseAnvilData(level);
        }
 else {
          parseMcRegionData(level);
        }
        ListTag entitiesTag=NbtUtil.getChild(level,""String_Node_Str"",ListTag.class);
        if (entitiesTag != null) {
          for (          Tag t : entitiesTag.getValue()) {
            if (t instanceof CompoundTag) {
              CompoundTag entity=(CompoundTag)t;
              StringTag idTag=NbtUtil.getChild(entity,""String_Node_Str"",StringTag.class);
              if (idTag.getValue().endsWith(""String_Node_Str"")) {
                StringTag motiveTag=NbtUtil.getChild(entity,""String_Node_Str"",StringTag.class);
                IntTag xTag=NbtUtil.getChild(entity,""String_Node_Str"",IntTag.class);
                IntTag yTag=NbtUtil.getChild(entity,""String_Node_Str"",IntTag.class);
                IntTag zTag=NbtUtil.getChild(entity,""String_Node_Str"",IntTag.class);
                ByteTag oldDir=NbtUtil.getChild(entity,""String_Node_Str"",ByteTag.class);
                ByteTag dir=NbtUtil.getChild(entity,""String_Node_Str"",ByteTag.class);
                if (oldDir != null && dir == null) {
                  dir=oldDir;
                }
                boolean is18=false;
                if (dir == null) {
                  dir=NbtUtil.getChild(entity,""String_Node_Str"",ByteTag.class);
                  is18=true;
                }
                int direction=dir.getValue();
                if (oldDir != null && direction == 0) {
                  direction=2;
                }
 else                 if (oldDir != null && direction == 2) {
                  direction=0;
                }
                int x=xTag.getValue();
                final int y=yTag.getValue();
                int z=zTag.getValue();
                if (is18 && direction == 0) {
                  z=zTag.getValue() - 1;
                }
 else                 if (is18 && direction == 1) {
                  x=xTag.getValue() + 1;
                }
 else                 if (is18 && direction == 2) {
                  z=zTag.getValue() + 1;
                }
 else                 if (is18 && direction == 3) {
                  x=xTag.getValue() - 1;
                }
                final int localX=x - (blockX * WIDTH);
                final int localY=y - (blockY * HEIGHT);
                final int localZ=z - (blockZ * DEPTH);
                paintings.add(new TileEntity(-1,0,x,y,z,localX,localY,localZ,motiveTag.getValue(),direction));
              }
 else               if (idTag.getValue().equals(""String_Node_Str"")) {
                IntTag xTag=NbtUtil.getChild(entity,""String_Node_Str"",IntTag.class);
                IntTag yTag=NbtUtil.getChild(entity,""String_Node_Str"",IntTag.class);
                IntTag zTag=NbtUtil.getChild(entity,""String_Node_Str"",IntTag.class);
                ByteTag dir=NbtUtil.getChild(entity,""String_Node_Str"",ByteTag.class);
                boolean is18=false;
                if (dir == null) {
                  dir=NbtUtil.getChild(entity,""String_Node_Str"",ByteTag.class);
                  is18=true;
                }
                String item=""String_Node_Str"";
                Map<String,Tag> map=entity.getValue();
                CompoundTag itemTag=(CompoundTag)map.get(""String_Node_Str"");
                if (itemTag != null) {
                  ShortTag itemIdTag=NbtUtil.getChild(itemTag,""String_Node_Str"",ShortTag.class);
                  if (itemIdTag == null) {
                    StringTag stringItemIdTag=NbtUtil.getChild(itemTag,""String_Node_Str"",StringTag.class);
                    item=stringItemIdTag.getValue();
                  }
 else {
                    if (itemIdTag.getValue() == 358)                     item=""String_Node_Str"";
                  }
                }
                int x=xTag.getValue();
                final int y=yTag.getValue();
                int z=zTag.getValue();
                if (is18 && dir.getValue() == 0) {
                  z=zTag.getValue() - 1;
                }
 else                 if (is18 && dir.getValue() == 1) {
                  x=xTag.getValue() + 1;
                }
 else                 if (is18 && dir.getValue() == 2) {
                  z=zTag.getValue() + 1;
                }
 else                 if (is18 && dir.getValue() == 3) {
                  x=xTag.getValue() - 1;
                }
                final int localX=x - (blockX * WIDTH);
                final int localY=y - (blockY * HEIGHT);
                final int localZ=z - (blockZ * DEPTH);
                itemFrames.add(new TileEntity(-2,0,x,y,z,localX,localY,localZ,item,dir.getValue()));
              }
            }
          }
        }
        ListTag tileEntitiesTag=NbtUtil.getChild(level,""String_Node_Str"",ListTag.class);
        if (tileEntitiesTag != null) {
          for (          Tag t : tileEntitiesTag.getValue()) {
            if (t instanceof CompoundTag) {
              CompoundTag entity=(CompoundTag)t;
              StringTag idTag=NbtUtil.getChild(entity,""String_Node_Str"",StringTag.class);
              IntTag xTag=NbtUtil.getChild(entity,""String_Node_Str"",IntTag.class);
              IntTag yTag=NbtUtil.getChild(entity,""String_Node_Str"",IntTag.class);
              IntTag zTag=NbtUtil.getChild(entity,""String_Node_Str"",IntTag.class);
              if (idTag != null && xTag != null && yTag != null && zTag != null) {
                String id=idTag.getValue();
                if (id.equals(""String_Node_Str"")) {
                  String text1=NbtUtil.getChild(entity,""String_Node_Str"",StringTag.class).getValue();
                  String text2=NbtUtil.getChild(entity,""String_Node_Str"",StringTag.class).getValue();
                  String text3=NbtUtil.getChild(entity,""String_Node_Str"",StringTag.class).getValue();
                  String text4=NbtUtil.getChild(entity,""String_Node_Str"",StringTag.class).getValue();
                  if (!text1.isEmpty() && FileUtils.isJSONValid(text1)) {
                    text1=textFromJSON(text1);
                    text2=textFromJSON(text2);
                    text3=textFromJSON(text3);
                    text4=textFromJSON(text4);
                  }
 else {
                    text1=text1.replaceAll(""String_Node_Str"",""String_Node_Str"");
                    if (text1 == null || text1.equals(""String_Node_Str""))                     text1=""String_Node_Str"";
                    text2=text2.replaceAll(""String_Node_Str"",""String_Node_Str"");
                    if (text2 == null || text2.equals(""String_Node_Str""))                     text2=""String_Node_Str"";
                    text3=text3.replaceAll(""String_Node_Str"",""String_Node_Str"");
                    if (text3 == null || text3.equals(""String_Node_Str""))                     text3=""String_Node_Str"";
                    text4=text4.replaceAll(""String_Node_Str"",""String_Node_Str"");
                    if (text4 == null || text4.equals(""String_Node_Str""))                     text4=""String_Node_Str"";
                  }
                  final int x=xTag.getValue();
                  final int y=yTag.getValue();
                  final int z=zTag.getValue();
                  final int localX=x - (blockX * WIDTH);
                  final int localY=y - (blockY * HEIGHT);
                  final int localZ=z - (blockZ * DEPTH);
                  final int blockId=getBlockId(localX,localY,localZ);
                  final int data=getBlockData(localX,localY,localZ);
                  signs.add(new RawSign(blockId,data,x,y,z,localX,localY,localZ,text1,text2,text3,text4));
                }
 else                 if (id.equals(""String_Node_Str"")) {
                  IntTag dataTag=NbtUtil.getChild(entity,""String_Node_Str"",IntTag.class);
                  IntTag itemTag=NbtUtil.getChild(entity,""String_Node_Str"",IntTag.class);
                  final int item;
                  if (itemTag == null) {
                    StringTag stringIdTag=NbtUtil.getChild(entity,""String_Node_Str"",StringTag.class);
                    if (stringIdTag.getValue().equals(""String_Node_Str""))                     item=6;
 else                     if (stringIdTag.getValue().equals(""String_Node_Str""))                     item=38;
 else                     item=0;
                  }
 else {
                    item=itemTag.getValue();
                  }
                  final int x=xTag.getValue();
                  final int y=yTag.getValue();
                  final int z=zTag.getValue();
                  final int localX=x - (blockX * WIDTH);
                  final int localY=y - (blockY * HEIGHT);
                  final int localZ=z - (blockZ * DEPTH);
                  final int blockData=getBlockData(localX,localY,localZ);
                  final int itemData=dataTag.getValue();
                  flowerPots.add(new TileEntity(0,blockData,x,y,z,localX,localY,localZ,itemData,item));
                }
 else                 if (id.equals(""String_Node_Str"")) {
                  ByteTag skullType=NbtUtil.getChild(entity,""String_Node_Str"",ByteTag.class);
                  ByteTag rot=NbtUtil.getChild(entity,""String_Node_Str"",ByteTag.class);
                  StringTag nameTag=null;
                  StringTag playerId=null;
                  String name=""String_Node_Str"";
                  String UUID=""String_Node_Str"";
                  String textureURL=""String_Node_Str"";
                  StringTag extraType=NbtUtil.getChild(entity,""String_Node_Str"",StringTag.class);
                  CompoundTag owner=NbtUtil.getChild(entity,""String_Node_Str"",CompoundTag.class);
                  if (owner != null) {
                    nameTag=NbtUtil.getChild(owner,""String_Node_Str"",StringTag.class);
                    name=nameTag.getValue();
                    playerId=NbtUtil.getChild(owner,""String_Node_Str"",StringTag.class);
                    UUID=playerId.getValue().replace(""String_Node_Str"",""String_Node_Str"");
                    CompoundTag properties=NbtUtil.getChild(owner,""String_Node_Str"",CompoundTag.class);
                    ListTag textures=NbtUtil.getChild(properties,""String_Node_Str"",ListTag.class);
                    CompoundTag tex=NbtUtil.getChild(textures,0,CompoundTag.class);
                    StringTag value=NbtUtil.getChild(tex,""String_Node_Str"",StringTag.class);
                    byte[] decoded=DatatypeConverter.parseBase64Binary(value.getValue());
                    JSONObject obj=new JSONObject(new String(decoded,""String_Node_Str""));
                    textureURL=obj.getJSONObject(""String_Node_Str"").getJSONObject(""String_Node_Str"").getString(""String_Node_Str"");
                  }
 else                   if (extraType != null && !(extraType.getValue().equals(""String_Node_Str""))) {
                    name=UUID=extraType.getValue();
                    textureURL=""String_Node_Str"" + extraType.getValue() + ""String_Node_Str"";
                  }
                  final int x=xTag.getValue();
                  final int y=yTag.getValue();
                  final int z=zTag.getValue();
                  final int localX=x - (blockX * WIDTH);
                  final int localY=y - (blockY * HEIGHT);
                  final int localZ=z - (blockZ * DEPTH);
                  skulls.add(new TileEntity(skullType.getValue(),rot.getValue(),x,y,z,localX,localY,localZ,name,UUID,textureURL,null));
                }
 else                 if (id.equals(""String_Node_Str"")) {
                  IntTag levels=NbtUtil.getChild(entity,""String_Node_Str"",IntTag.class);
                  final int x=xTag.getValue();
                  final int y=yTag.getValue();
                  final int z=zTag.getValue();
                  final int localX=x - (blockX * WIDTH);
                  final int localY=y - (blockY * HEIGHT);
                  final int localZ=z - (blockZ * DEPTH);
                  beacons.add(new TileEntity(0,levels.getValue(),x,y,z,localX,localY,localZ,0,0));
                }
 else                 if (id.equals(""String_Node_Str"")) {
                  IntTag base=NbtUtil.getChild(entity,""String_Node_Str"",IntTag.class);
                  ListTag patternList=NbtUtil.getChild(entity,""String_Node_Str"",ListTag.class);
                  final int x=xTag.getValue();
                  final int y=yTag.getValue();
                  final int z=zTag.getValue();
                  final int localX=x - (blockX * WIDTH);
                  final int localY=y - (blockY * HEIGHT);
                  final int localZ=z - (blockZ * DEPTH);
                  String patterns=""String_Node_Str"";
                  final int numPatterns=patternList.getValue().size();
                  if (numPatterns > 0) {
                    patterns+=""String_Node_Str"";
                    for (int i=0; i < numPatterns; i++) {
                      CompoundTag p=NbtUtil.getChild(patternList,i,CompoundTag.class);
                      StringTag pattern=NbtUtil.getChild(p,""String_Node_Str"",StringTag.class);
                      IntTag color=NbtUtil.getChild(p,""String_Node_Str"",IntTag.class);
                      patterns+=""String_Node_Str"" + pattern.getValue() + ""String_Node_Str""+ ""String_Node_Str""+ color.getValue().toString();
                      if (i < numPatterns - 1)                       patterns+=""String_Node_Str"";
                    }
                    patterns+=""String_Node_Str"";
                  }
                  banners.add(new TileEntity(0,base.getValue(),x,y,z,localX,localY,localZ,patterns,0));
                }
              }
            }
          }
        }
      }
    }
  }
  finally {
    if (nbtIn != null)     nbtIn.close();
    if (in != null)     in.close();
  }
}",0.9751629502572898
80074,"public InteractiveRenderer(Configuration args,final int displayWidth,final int displayHeight) throws LWJGLException {
  rasteriser=RasteriserFactory.createRasteriser(args.getRasteriserType(),DisplayType.Window,displayWidth,displayHeight,24,8,8,4);
  System.out.println(""String_Node_Str"" + rasteriser);
  rasteriser.printInfo();
  viewMode=ViewMode.OrthoView;
  orthoCamPosition=new Vector3f();
  orthoCamera=new OrthoCamera(rasteriser,displayWidth,displayHeight);
  perspectiveCamera=new PerspectiveCamera(rasteriser,displayWidth,displayHeight);
  views=new ArrayList<RawSign>();
}","public InteractiveRenderer(Configuration args,final int displayWidth,final int displayHeight) throws LWJGLException {
  rasteriser=RasteriserFactory.createRasteriser(args.getRasteriserType(),DisplayType.Window,displayWidth,displayHeight,24,8,24,4);
  System.out.println(""String_Node_Str"" + rasteriser);
  rasteriser.printInfo();
  viewMode=ViewMode.OrthoView;
  orthoCamPosition=new Vector3f();
  orthoCamera=new OrthoCamera(rasteriser,displayWidth,displayHeight);
  perspectiveCamera=new PerspectiveCamera(rasteriser,displayWidth,displayHeight);
  views=new ArrayList<RawSign>();
}",0.9974204643164232
80075,"public TileRenderer(Configuration args,ProgressListener listener,MessageDigest hashAlgorithm) throws Exception {
  this.args=args;
  this.hashAlgorithm=hashAlgorithm;
  this.progressListener=listener;
  this.tileWidth=args.tileSize();
  this.tileHeight=args.tileSize();
  this.numZoomLevels=args.numZoomLevels();
  this.exportDir=args.outputDir();
  playerSkinCache=new PlayerSkinCache(args,hashAlgorithm);
  hddTileListFactory=new HddTileListFactory(new File(args.cacheDir(),""String_Node_Str""));
  System.out.println(""String_Node_Str"");
  playerIconAssembler=new PlayerIconAssembler(playerSkinCache);
  memoryMonitor=new MemoryMonitor();
{
    System.out.println(""String_Node_Str"");
    rasteriser=RasteriserFactory.createRasteriser(args.getRasteriserType(),DisplayType.Offscreen,2048,2048,args.colourDepth(),args.alphaBits(),16,args.numSamples());
    if (rasteriser != null) {
      System.out.println(""String_Node_Str"" + rasteriser);
      rasteriser.printInfo();
    }
 else {
      throw new RuntimeException(""String_Node_Str"");
    }
  }
  System.out.println(""String_Node_Str"");
  camera=new OrthoCamera(rasteriser,tileWidth,tileHeight);
  System.out.println(""String_Node_Str"");
}","public TileRenderer(Configuration args,ProgressListener listener,MessageDigest hashAlgorithm) throws Exception {
  this.args=args;
  this.hashAlgorithm=hashAlgorithm;
  this.progressListener=listener;
  this.tileWidth=args.tileSize();
  this.tileHeight=args.tileSize();
  this.numZoomLevels=args.numZoomLevels();
  this.exportDir=args.outputDir();
  playerSkinCache=new PlayerSkinCache(args,hashAlgorithm);
  hddTileListFactory=new HddTileListFactory(new File(args.cacheDir(),""String_Node_Str""));
  System.out.println(""String_Node_Str"");
  playerIconAssembler=new PlayerIconAssembler(playerSkinCache);
  memoryMonitor=new MemoryMonitor();
{
    System.out.println(""String_Node_Str"");
    rasteriser=RasteriserFactory.createRasteriser(args.getRasteriserType(),DisplayType.Offscreen,2048,2048,args.colourDepth(),args.alphaBits(),24,args.numSamples());
    if (rasteriser != null) {
      System.out.println(""String_Node_Str"" + rasteriser);
      rasteriser.printInfo();
    }
 else {
      throw new RuntimeException(""String_Node_Str"");
    }
  }
  System.out.println(""String_Node_Str"");
  camera=new OrthoCamera(rasteriser,tileWidth,tileHeight);
  System.out.println(""String_Node_Str"");
}",0.9983150800336984
80076,"public LwjglRasteriser(DisplayType type,final int displayWidth,final int displayHeight,final int colourDepth,final int alphaBits,final int depthBits,final int numSamples) throws Exception {
  this.type=type;
  this.width=displayWidth;
  this.height=displayHeight;
  keyCodeMap=new HashMap<Integer,Integer>();
  keyCodeMap.put(KeyEvent.VK_0,Keyboard.KEY_0);
  keyCodeMap.put(KeyEvent.VK_1,Keyboard.KEY_1);
  keyCodeMap.put(KeyEvent.VK_2,Keyboard.KEY_2);
  keyCodeMap.put(KeyEvent.VK_3,Keyboard.KEY_3);
  keyCodeMap.put(KeyEvent.VK_4,Keyboard.KEY_4);
  keyCodeMap.put(KeyEvent.VK_5,Keyboard.KEY_5);
  keyCodeMap.put(KeyEvent.VK_6,Keyboard.KEY_6);
  keyCodeMap.put(KeyEvent.VK_7,Keyboard.KEY_7);
  keyCodeMap.put(KeyEvent.VK_8,Keyboard.KEY_8);
  keyCodeMap.put(KeyEvent.VK_9,Keyboard.KEY_9);
  keyCodeMap.put(KeyEvent.VK_UP,Keyboard.KEY_UP);
  keyCodeMap.put(KeyEvent.VK_DOWN,Keyboard.KEY_DOWN);
  keyCodeMap.put(KeyEvent.VK_LEFT,Keyboard.KEY_LEFT);
  keyCodeMap.put(KeyEvent.VK_RIGHT,Keyboard.KEY_RIGHT);
  keyCodeMap.put(KeyEvent.VK_SPACE,Keyboard.KEY_SPACE);
  keyCodeMap.put(KeyEvent.VK_MINUS,Keyboard.KEY_MINUS);
  keyCodeMap.put(KeyEvent.VK_EQUALS,Keyboard.KEY_EQUALS);
  keyCodeMap.put(KeyEvent.VK_BACK_SPACE,Keyboard.KEY_BACK);
  keyCodeMap.put(KeyEvent.VK_A,Keyboard.KEY_A);
  keyCodeMap.put(KeyEvent.VK_B,Keyboard.KEY_B);
  keyCodeMap.put(KeyEvent.VK_C,Keyboard.KEY_C);
  keyCodeMap.put(KeyEvent.VK_D,Keyboard.KEY_D);
  keyCodeMap.put(KeyEvent.VK_E,Keyboard.KEY_E);
  keyCodeMap.put(KeyEvent.VK_F,Keyboard.KEY_F);
  keyCodeMap.put(KeyEvent.VK_G,Keyboard.KEY_G);
  keyCodeMap.put(KeyEvent.VK_H,Keyboard.KEY_H);
  keyCodeMap.put(KeyEvent.VK_I,Keyboard.KEY_I);
  keyCodeMap.put(KeyEvent.VK_J,Keyboard.KEY_J);
  keyCodeMap.put(KeyEvent.VK_K,Keyboard.KEY_K);
  keyCodeMap.put(KeyEvent.VK_L,Keyboard.KEY_L);
  keyCodeMap.put(KeyEvent.VK_M,Keyboard.KEY_M);
  keyCodeMap.put(KeyEvent.VK_N,Keyboard.KEY_N);
  keyCodeMap.put(KeyEvent.VK_O,Keyboard.KEY_O);
  keyCodeMap.put(KeyEvent.VK_P,Keyboard.KEY_P);
  keyCodeMap.put(KeyEvent.VK_Q,Keyboard.KEY_Q);
  keyCodeMap.put(KeyEvent.VK_R,Keyboard.KEY_R);
  keyCodeMap.put(KeyEvent.VK_S,Keyboard.KEY_S);
  keyCodeMap.put(KeyEvent.VK_T,Keyboard.KEY_T);
  keyCodeMap.put(KeyEvent.VK_U,Keyboard.KEY_U);
  keyCodeMap.put(KeyEvent.VK_V,Keyboard.KEY_V);
  keyCodeMap.put(KeyEvent.VK_W,Keyboard.KEY_W);
  keyCodeMap.put(KeyEvent.VK_X,Keyboard.KEY_X);
  keyCodeMap.put(KeyEvent.VK_Y,Keyboard.KEY_Y);
  keyCodeMap.put(KeyEvent.VK_Z,Keyboard.KEY_Z);
  prevKeyStates=new HashMap<Integer,Boolean>();
  Drawable drawable=Display.getDrawable();
  System.out.println(""String_Node_Str"" + drawable);
  ArrayList<PixelFormat> pixelFormats=new ArrayList<PixelFormat>();
  pixelFormats.add(new PixelFormat(colourDepth,alphaBits,depthBits,0,numSamples));
  pixelFormats.add(new PixelFormat(colourDepth,alphaBits,depthBits,0,0));
  pixelFormats.add(new PixelFormat(colourDepth,0,depthBits,0,0));
  pixelFormats.add(new PixelFormat(16,0,depthBits,0,0));
  pixelFormats.add(new PixelFormat(16,0,16,0,0));
  pixelFormats.add(new PixelFormat(0,0,1,0,0));
  PixelFormat usedPixelFormat=null;
  LWJGLException pbufferException=null;
  if (type == DisplayType.Offscreen) {
    for (    PixelFormat pf : pixelFormats) {
      try {
        pbuffer=new Pbuffer(displayWidth,displayHeight,pf,drawable);
        usedPixelFormat=pf;
        break;
      }
 catch (      LWJGLException e) {
        pbufferException=e;
      }
    }
    if (pbuffer != null) {
      System.out.println(""String_Node_Str"" + pbuffer);
      System.out.println(""String_Node_Str"" + usedPixelFormat.getBitsPerPixel() + ""String_Node_Str""+ usedPixelFormat.getDepthBits()+ ""String_Node_Str""+ usedPixelFormat.getAlphaBits()+ ""String_Node_Str""+ usedPixelFormat.getStencilBits()+ ""String_Node_Str""+ usedPixelFormat.getSamples());
    }
 else {
      System.err.println(""String_Node_Str"" + colourDepth + ""String_Node_Str""+ alphaBits+ ""String_Node_Str""+ depthBits+ ""String_Node_Str""+ numSamples+ ""String_Node_Str"");
      throw pbufferException;
    }
    pbuffer.makeCurrent();
    resetState();
  }
 else   if (type == DisplayType.Window) {
    Display.setDisplayMode(new DisplayMode(displayWidth,displayHeight));
    Display.setLocation((Display.getDisplayMode().getWidth() - displayWidth) / 2,(Display.getDisplayMode().getHeight() - displayHeight) / 2);
    Display.setTitle(""String_Node_Str"");
    Display.create(new PixelFormat(32,0,16,0,4));
  }
 else {
    throw new RuntimeException(""String_Node_Str"" + type);
  }
  System.out.println(""String_Node_Str"");
}","public LwjglRasteriser(DisplayType type,final int displayWidth,final int displayHeight,final int colourDepth,final int alphaBits,final int depthBits,final int numSamples) throws Exception {
  this.type=type;
  this.width=displayWidth;
  this.height=displayHeight;
  keyCodeMap=new HashMap<Integer,Integer>();
  keyCodeMap.put(KeyEvent.VK_0,Keyboard.KEY_0);
  keyCodeMap.put(KeyEvent.VK_1,Keyboard.KEY_1);
  keyCodeMap.put(KeyEvent.VK_2,Keyboard.KEY_2);
  keyCodeMap.put(KeyEvent.VK_3,Keyboard.KEY_3);
  keyCodeMap.put(KeyEvent.VK_4,Keyboard.KEY_4);
  keyCodeMap.put(KeyEvent.VK_5,Keyboard.KEY_5);
  keyCodeMap.put(KeyEvent.VK_6,Keyboard.KEY_6);
  keyCodeMap.put(KeyEvent.VK_7,Keyboard.KEY_7);
  keyCodeMap.put(KeyEvent.VK_8,Keyboard.KEY_8);
  keyCodeMap.put(KeyEvent.VK_9,Keyboard.KEY_9);
  keyCodeMap.put(KeyEvent.VK_UP,Keyboard.KEY_UP);
  keyCodeMap.put(KeyEvent.VK_DOWN,Keyboard.KEY_DOWN);
  keyCodeMap.put(KeyEvent.VK_LEFT,Keyboard.KEY_LEFT);
  keyCodeMap.put(KeyEvent.VK_RIGHT,Keyboard.KEY_RIGHT);
  keyCodeMap.put(KeyEvent.VK_SPACE,Keyboard.KEY_SPACE);
  keyCodeMap.put(KeyEvent.VK_MINUS,Keyboard.KEY_MINUS);
  keyCodeMap.put(KeyEvent.VK_EQUALS,Keyboard.KEY_EQUALS);
  keyCodeMap.put(KeyEvent.VK_BACK_SPACE,Keyboard.KEY_BACK);
  keyCodeMap.put(KeyEvent.VK_A,Keyboard.KEY_A);
  keyCodeMap.put(KeyEvent.VK_B,Keyboard.KEY_B);
  keyCodeMap.put(KeyEvent.VK_C,Keyboard.KEY_C);
  keyCodeMap.put(KeyEvent.VK_D,Keyboard.KEY_D);
  keyCodeMap.put(KeyEvent.VK_E,Keyboard.KEY_E);
  keyCodeMap.put(KeyEvent.VK_F,Keyboard.KEY_F);
  keyCodeMap.put(KeyEvent.VK_G,Keyboard.KEY_G);
  keyCodeMap.put(KeyEvent.VK_H,Keyboard.KEY_H);
  keyCodeMap.put(KeyEvent.VK_I,Keyboard.KEY_I);
  keyCodeMap.put(KeyEvent.VK_J,Keyboard.KEY_J);
  keyCodeMap.put(KeyEvent.VK_K,Keyboard.KEY_K);
  keyCodeMap.put(KeyEvent.VK_L,Keyboard.KEY_L);
  keyCodeMap.put(KeyEvent.VK_M,Keyboard.KEY_M);
  keyCodeMap.put(KeyEvent.VK_N,Keyboard.KEY_N);
  keyCodeMap.put(KeyEvent.VK_O,Keyboard.KEY_O);
  keyCodeMap.put(KeyEvent.VK_P,Keyboard.KEY_P);
  keyCodeMap.put(KeyEvent.VK_Q,Keyboard.KEY_Q);
  keyCodeMap.put(KeyEvent.VK_R,Keyboard.KEY_R);
  keyCodeMap.put(KeyEvent.VK_S,Keyboard.KEY_S);
  keyCodeMap.put(KeyEvent.VK_T,Keyboard.KEY_T);
  keyCodeMap.put(KeyEvent.VK_U,Keyboard.KEY_U);
  keyCodeMap.put(KeyEvent.VK_V,Keyboard.KEY_V);
  keyCodeMap.put(KeyEvent.VK_W,Keyboard.KEY_W);
  keyCodeMap.put(KeyEvent.VK_X,Keyboard.KEY_X);
  keyCodeMap.put(KeyEvent.VK_Y,Keyboard.KEY_Y);
  keyCodeMap.put(KeyEvent.VK_Z,Keyboard.KEY_Z);
  prevKeyStates=new HashMap<Integer,Boolean>();
  Drawable drawable=Display.getDrawable();
  System.out.println(""String_Node_Str"" + drawable);
  ArrayList<PixelFormat> pixelFormats=new ArrayList<PixelFormat>();
  pixelFormats.add(new PixelFormat(colourDepth,alphaBits,depthBits,0,numSamples));
  pixelFormats.add(new PixelFormat(colourDepth,alphaBits,depthBits,0,0));
  pixelFormats.add(new PixelFormat(colourDepth,0,depthBits,0,0));
  pixelFormats.add(new PixelFormat(16,0,depthBits,0,0));
  pixelFormats.add(new PixelFormat(16,0,16,0,0));
  pixelFormats.add(new PixelFormat(0,0,1,0,0));
  PixelFormat usedPixelFormat=null;
  LWJGLException pbufferException=null;
  if (type == DisplayType.Offscreen) {
    for (    PixelFormat pf : pixelFormats) {
      try {
        pbuffer=new Pbuffer(displayWidth,displayHeight,pf,drawable);
        usedPixelFormat=pf;
        break;
      }
 catch (      LWJGLException e) {
        pbufferException=e;
      }
    }
    if (pbuffer != null) {
      System.out.println(""String_Node_Str"" + pbuffer);
      System.out.println(""String_Node_Str"" + usedPixelFormat.getBitsPerPixel() + ""String_Node_Str""+ usedPixelFormat.getDepthBits()+ ""String_Node_Str""+ usedPixelFormat.getAlphaBits()+ ""String_Node_Str""+ usedPixelFormat.getStencilBits()+ ""String_Node_Str""+ usedPixelFormat.getSamples());
    }
 else {
      System.err.println(""String_Node_Str"" + colourDepth + ""String_Node_Str""+ alphaBits+ ""String_Node_Str""+ depthBits+ ""String_Node_Str""+ numSamples+ ""String_Node_Str"");
      throw pbufferException;
    }
    pbuffer.makeCurrent();
    resetState();
  }
 else   if (type == DisplayType.Window) {
    Display.setDisplayMode(new DisplayMode(displayWidth,displayHeight));
    Display.setLocation((Display.getDisplayMode().getWidth() - displayWidth) / 2,(Display.getDisplayMode().getHeight() - displayHeight) / 2);
    Display.setTitle(""String_Node_Str"");
    Display.create(new PixelFormat(32,0,depthBits,0,4));
  }
 else {
    throw new RuntimeException(""String_Node_Str"" + type);
  }
  System.out.println(""String_Node_Str"");
}",0.9987894794761748
80077,"public void lookAt(float x,float y,float z,final float zoom,final float angleOffsetRads,final float elevationAngleRads){
  this.lookAt.set(x,y,z);
  this.zoom=zoom;
  eye=calcEyePosition(lookAt,angleOffsetRads,elevationAngleRads);
{
    Vector3f forward=new Vector3f(lookAt.x - eye.x,lookAt.y - eye.y,lookAt.z - eye.z);
    forward.normalise();
    if (elevationAngleRads >= Math.PI / 2f) {
      Vector3f dummyEye=calcEyePosition(lookAt,angleOffsetRads,(float)Math.PI / 4.0f);
      Vector3f dummyForward=new Vector3f(lookAt.x - dummyEye.x,lookAt.y - dummyEye.y,lookAt.z - dummyEye.z);
      dummyForward.normalise();
      up=new Vector3f(dummyForward.x,dummyForward.y + 1,dummyForward.z);
    }
 else {
      up=new Vector3f(0,1,0);
    }
    Vector3f dir=new Vector3f(lookAt.x - eye.x,lookAt.y - eye.y,lookAt.z - eye.z);
    dir.normalise();
    Vector3f.cross(dir,up,right);
    Vector3f.cross(right,dir,up);
    right.normalise();
    up.normalise();
  }
  final float size=this.zoom / 2;
  projectionMatrix=MatrixUtil.createOrthoMatrix(-size,size,-size,size,-10000,10000);
  cameraMatrix=MatrixUtil.createLookAt(eye,lookAt,up);
  frustum.extract(projectionMatrix,cameraMatrix,windowWidth,windowHeight,viewport);
}","public void lookAt(float x,float y,float z,final float zoom,final float angleOffsetRads,final float elevationAngleRads){
  this.lookAt.set(x,y,z);
  this.zoom=zoom;
  eye=calcEyePosition(lookAt,angleOffsetRads,elevationAngleRads);
{
    Vector3f forward=new Vector3f(lookAt.x - eye.x,lookAt.y - eye.y,lookAt.z - eye.z);
    forward.normalise();
    if (elevationAngleRads >= Math.PI / 2f) {
      Vector3f dummyEye=calcEyePosition(lookAt,angleOffsetRads,(float)Math.PI / 4.0f);
      Vector3f dummyForward=new Vector3f(lookAt.x - dummyEye.x,lookAt.y - dummyEye.y,lookAt.z - dummyEye.z);
      dummyForward.normalise();
      up=new Vector3f(dummyForward.x,dummyForward.y + 1,dummyForward.z);
    }
 else {
      up=new Vector3f(0,1,0);
    }
    Vector3f dir=new Vector3f(lookAt.x - eye.x,lookAt.y - eye.y,lookAt.z - eye.z);
    dir.normalise();
    Vector3f.cross(dir,up,right);
    Vector3f.cross(right,dir,up);
    right.normalise();
    up.normalise();
  }
  final float size=this.zoom / 2;
  projectionMatrix=MatrixUtil.createOrthoMatrix(-size,size,-size,size,1000,2000);
  cameraMatrix=MatrixUtil.createLookAt(eye,lookAt,up);
  frustum.extract(projectionMatrix,cameraMatrix,windowWidth,windowHeight,viewport);
}",0.9971276159212146
80078,"private int outputPortals(File portalFile,HddObjectListReader<Portal> portalPositions,tectonicus.configuration.Map map,Vector3l spawn){
  System.out.println(""String_Node_Str"");
  if (portalFile.exists())   portalFile.delete();
  int numPortals=0;
  JsArrayWriter jsWriter=null;
  try {
    jsWriter=new JsArrayWriter(portalFile,map.getId() + ""String_Node_Str"");
    long radius=0;
    long originX=spawn.x;
    long originZ=spawn.z;
    if (map.getWorldSubsetFactory().getClass() == CircularWorldSubsetFactory.class) {
      CircularWorldSubsetFactory subset=(CircularWorldSubsetFactory)map.getWorldSubsetFactory();
      radius=subset.getRadius();
      if (subset.getOrigin() != null) {
        originX=subset.getOrigin().x;
        originZ=subset.getOrigin().z;
      }
    }
    ArrayList<Portal> portals=new ArrayList<Portal>();
    if (portalPositions.hasNext()) {
      long prevX, prevY, prevZ, firstX, firstZ;
      Portal portal=new Portal();
      portalPositions.read(portal);
      firstX=portal.getX();
      firstZ=portal.getZ();
      prevX=portal.getX();
      prevY=portal.getY();
      prevZ=portal.getZ();
      while (portalPositions.hasNext()) {
        portalPositions.read(portal);
        if ((portal.getX() == prevX && portal.getZ() == prevZ + 1) || (portal.getX() == prevX + 1 && portal.getZ() == prevZ)) {
          prevX=portal.getX();
          prevY=portal.getY();
          prevZ=portal.getZ();
        }
 else {
          portals.add(new Portal(prevX + (firstX - prevX) / 2,prevY,prevZ + (firstZ - prevZ) / 2));
          numPortals++;
          prevX=portal.getX();
          prevY=portal.getY();
          prevZ=portal.getZ();
          firstX=portal.getX();
          firstZ=portal.getZ();
        }
      }
      portals.add(new Portal(portal.getX() + ((firstX - prevX) / 2),portal.getY(),portal.getZ() + (firstZ - prevZ) / 2));
      numPortals++;
      for (      Portal p : portals) {
        final float worldX=p.getX();
        final float worldY=p.getY();
        final float worldZ=p.getZ();
        HashMap<String,String> args=new HashMap<String,String>();
        String posStr=""String_Node_Str"" + worldX + ""String_Node_Str""+ worldY+ ""String_Node_Str""+ worldZ+ ""String_Node_Str"";
        args.put(""String_Node_Str"",posStr);
        if (radius != 0 && Math.pow((p.getX() - originX),2) + Math.pow((p.getZ() - originZ),2) < Math.pow(radius,2)) {
          jsWriter.write(args);
        }
 else         if (radius == 0) {
          jsWriter.write(args);
        }
      }
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
 finally {
    if (jsWriter != null)     jsWriter.close();
  }
  System.out.println(""String_Node_Str"" + numPortals + ""String_Node_Str"");
  return numPortals;
}","private int outputPortals(File portalFile,HddObjectListReader<Portal> portalPositions,tectonicus.configuration.Map map,Vector3l spawn){
  System.out.println(""String_Node_Str"");
  if (portalFile.exists())   portalFile.delete();
  int numPortals=0;
  JsArrayWriter jsWriter=null;
  try {
    jsWriter=new JsArrayWriter(portalFile,map.getId() + ""String_Node_Str"");
    long radius=0;
    long originX=spawn.x;
    long originZ=spawn.z;
    if (map.getWorldSubsetFactory().getClass() == CircularWorldSubsetFactory.class) {
      CircularWorldSubsetFactory subset=(CircularWorldSubsetFactory)map.getWorldSubsetFactory();
      radius=subset.getRadius();
      if (subset.getOrigin() != null) {
        originX=subset.getOrigin().x;
        originZ=subset.getOrigin().z;
      }
    }
    ArrayList<Portal> portals=new ArrayList<Portal>();
    if (portalPositions.hasNext()) {
      long prevX, prevY, prevZ, firstX, firstZ;
      Portal portal=new Portal();
      portalPositions.read(portal);
      firstX=portal.getX();
      firstZ=portal.getZ();
      prevX=portal.getX();
      prevY=portal.getY();
      prevZ=portal.getZ();
      while (portalPositions.hasNext()) {
        portalPositions.read(portal);
        if ((portal.getX() == prevX && portal.getZ() == prevZ + 1) || (portal.getX() == prevX + 1 && portal.getZ() == prevZ)) {
          prevX=portal.getX();
          prevY=portal.getY();
          prevZ=portal.getZ();
        }
 else {
          portals.add(new Portal(prevX + (firstX - prevX) / 2,prevY,prevZ + (firstZ - prevZ) / 2));
          numPortals++;
          prevX=portal.getX();
          prevY=portal.getY();
          prevZ=portal.getZ();
          firstX=portal.getX();
          firstZ=portal.getZ();
        }
      }
      portals.add(new Portal(portal.getX() + ((firstX - prevX) / 2),portal.getY(),portal.getZ() + (firstZ - prevZ) / 2));
      numPortals++;
      for (      Portal p : portals) {
        final float worldX=p.getX();
        final float worldY=p.getY();
        final float worldZ=p.getZ();
        HashMap<String,String> args=new HashMap<String,String>();
        String posStr=""String_Node_Str"" + worldX + ""String_Node_Str""+ worldY+ ""String_Node_Str""+ worldZ+ ""String_Node_Str"";
        args.put(""String_Node_Str"",posStr);
        if (radius == 0 || radius != 0 && Math.pow((p.getX() - originX),2) + Math.pow((p.getZ() - originZ),2) < Math.pow(radius,2)) {
          jsWriter.write(args);
        }
      }
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
 finally {
    if (jsWriter != null)     jsWriter.close();
  }
  System.out.println(""String_Node_Str"" + numPortals + ""String_Node_Str"");
  return numPortals;
}",0.9833764314739564
80079,"public static void outputBeds(File exportDir,tectonicus.configuration.Map map,PlayerFilter filter,ArrayList<Player> players,Vector3l mapSpawn){
  File bedsFile=new File(exportDir,""String_Node_Str"");
  if (bedsFile.exists())   bedsFile.delete();
  System.out.println(""String_Node_Str"" + bedsFile.getAbsolutePath());
  int numOutput=0;
  JsArrayWriter jsWriter=null;
  try {
    jsWriter=new JsArrayWriter(bedsFile,map.getId() + ""String_Node_Str"");
    long radius=0;
    long originX=mapSpawn.x;
    long originZ=mapSpawn.z;
    if (map.getWorldSubsetFactory().getClass() == CircularWorldSubsetFactory.class) {
      CircularWorldSubsetFactory subset=(CircularWorldSubsetFactory)map.getWorldSubsetFactory();
      radius=subset.getRadius();
      if (subset.getOrigin() != null) {
        originX=subset.getOrigin().x;
        originZ=subset.getOrigin().z;
      }
    }
    if (map.getDimension() == Dimension.Terra) {
      for (      Player player : players) {
        if (filter.passesFilter(player) && player.getSpawnPosition() != null) {
          System.out.println(""String_Node_Str"" + player.getName() + ""String_Node_Str"");
          HashMap<String,String> args=new HashMap<String,String>();
          Vector3l spawn=player.getSpawnPosition();
          args.put(""String_Node_Str"",""String_Node_Str"" + player.getName() + ""String_Node_Str"");
          String posStr=""String_Node_Str"" + spawn.x + ""String_Node_Str""+ spawn.y+ ""String_Node_Str""+ spawn.z+ ""String_Node_Str"";
          args.put(""String_Node_Str"",posStr);
          if (radius != 0 && Math.pow((spawn.x - originX),2) + Math.pow((spawn.z - originZ),2) < Math.pow(radius,2)) {
            jsWriter.write(args);
          }
 else           if (radius == 0) {
            jsWriter.write(args);
          }
          numOutput++;
        }
      }
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
 finally {
    if (jsWriter != null)     jsWriter.close();
  }
  System.out.println(""String_Node_Str"" + numOutput + ""String_Node_Str"");
}","public static void outputBeds(File exportDir,tectonicus.configuration.Map map,PlayerFilter filter,ArrayList<Player> players,Vector3l mapSpawn){
  File bedsFile=new File(exportDir,""String_Node_Str"");
  if (bedsFile.exists())   bedsFile.delete();
  System.out.println(""String_Node_Str"" + bedsFile.getAbsolutePath());
  int numOutput=0;
  JsArrayWriter jsWriter=null;
  try {
    jsWriter=new JsArrayWriter(bedsFile,map.getId() + ""String_Node_Str"");
    long radius=0;
    long originX=mapSpawn.x;
    long originZ=mapSpawn.z;
    if (map.getWorldSubsetFactory().getClass() == CircularWorldSubsetFactory.class) {
      CircularWorldSubsetFactory subset=(CircularWorldSubsetFactory)map.getWorldSubsetFactory();
      radius=subset.getRadius();
      if (subset.getOrigin() != null) {
        originX=subset.getOrigin().x;
        originZ=subset.getOrigin().z;
      }
    }
    if (map.getDimension() == Dimension.Terra) {
      for (      Player player : players) {
        if (filter.passesFilter(player) && player.getSpawnPosition() != null) {
          System.out.println(""String_Node_Str"" + player.getName() + ""String_Node_Str"");
          HashMap<String,String> args=new HashMap<String,String>();
          Vector3l spawn=player.getSpawnPosition();
          args.put(""String_Node_Str"",""String_Node_Str"" + player.getName() + ""String_Node_Str"");
          String posStr=""String_Node_Str"" + spawn.x + ""String_Node_Str""+ spawn.y+ ""String_Node_Str""+ spawn.z+ ""String_Node_Str"";
          args.put(""String_Node_Str"",posStr);
          if (radius == 0 || radius != 0 && Math.pow((spawn.x - originX),2) + Math.pow((spawn.z - originZ),2) < Math.pow(radius,2)) {
            jsWriter.write(args);
          }
          numOutput++;
        }
      }
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
 finally {
    if (jsWriter != null)     jsWriter.close();
  }
  System.out.println(""String_Node_Str"" + numOutput + ""String_Node_Str"");
}",0.9757207890743552
80080,"private void outputSigns(File signFile,HddObjectListReader<Sign> signs,tectonicus.configuration.Map map,Vector3l spawn){
  System.out.println(""String_Node_Str"" + signFile.getAbsolutePath());
  if (signFile.exists())   signFile.delete();
  JsArrayWriter jsWriter=null;
  try {
    jsWriter=new JsArrayWriter(signFile,map.getId() + ""String_Node_Str"");
    long radius=0;
    long originX=spawn.x;
    long originZ=spawn.z;
    if (map.getWorldSubsetFactory().getClass() == CircularWorldSubsetFactory.class) {
      CircularWorldSubsetFactory subset=(CircularWorldSubsetFactory)map.getWorldSubsetFactory();
      radius=subset.getRadius();
      if (subset.getOrigin() != null) {
        originX=subset.getOrigin().x;
        originZ=subset.getOrigin().z;
      }
    }
    Sign sign=new Sign();
    while (signs.hasNext()) {
      signs.read(sign);
      String message=""String_Node_Str"";
      if (Float.parseFloat(Minecraft.minecraftVersion) >= 1.8f)       message=""String_Node_Str"" + sign.getText(0) + ""String_Node_Str""+ sign.getText(1)+ ""String_Node_Str""+ sign.getText(2)+ ""String_Node_Str""+ sign.getText(3)+ ""String_Node_Str"";
 else       message=""String_Node_Str"" + jsEscape(sign.getText(0)) + ""String_Node_Str""+ jsEscape(sign.getText(1))+ ""String_Node_Str""+ jsEscape(sign.getText(2))+ ""String_Node_Str""+ jsEscape(sign.getText(3))+ ""String_Node_Str"";
      HashMap<String,String> args=new HashMap<String,String>();
      final float worldX=sign.getX() + 0.5f;
      final float worldY=sign.getY();
      final float worldZ=sign.getZ() + 0.5f;
      String posStr=""String_Node_Str"" + worldX + ""String_Node_Str""+ worldY+ ""String_Node_Str""+ worldZ+ ""String_Node_Str"";
      args.put(""String_Node_Str"",posStr);
      args.put(""String_Node_Str"",message);
      if (Float.parseFloat(Minecraft.minecraftVersion) >= 1.8f) {
        args.put(""String_Node_Str"",""String_Node_Str"" + sign.getText(0) + ""String_Node_Str"");
        args.put(""String_Node_Str"",""String_Node_Str"" + sign.getText(1) + ""String_Node_Str"");
        args.put(""String_Node_Str"",""String_Node_Str"" + sign.getText(2) + ""String_Node_Str"");
        args.put(""String_Node_Str"",""String_Node_Str"" + sign.getText(3) + ""String_Node_Str"");
      }
 else {
        args.put(""String_Node_Str"",""String_Node_Str"" + jsEscape(sign.getText(0)) + ""String_Node_Str"");
        args.put(""String_Node_Str"",""String_Node_Str"" + jsEscape(sign.getText(1)) + ""String_Node_Str"");
        args.put(""String_Node_Str"",""String_Node_Str"" + jsEscape(sign.getText(2)) + ""String_Node_Str"");
        args.put(""String_Node_Str"",""String_Node_Str"" + jsEscape(sign.getText(3)) + ""String_Node_Str"");
      }
      if (radius != 0 && Math.pow((sign.getX() - originX),2) + Math.pow((sign.getZ() - originZ),2) < Math.pow(radius,2)) {
        jsWriter.write(args);
      }
 else       if (radius == 0) {
        jsWriter.write(args);
      }
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
 finally {
    if (jsWriter != null)     jsWriter.close();
  }
}","private void outputSigns(File signFile,HddObjectListReader<Sign> signs,tectonicus.configuration.Map map,Vector3l spawn){
  System.out.println(""String_Node_Str"" + signFile.getAbsolutePath());
  if (signFile.exists())   signFile.delete();
  JsArrayWriter jsWriter=null;
  try {
    jsWriter=new JsArrayWriter(signFile,map.getId() + ""String_Node_Str"");
    long radius=0;
    long originX=spawn.x;
    long originZ=spawn.z;
    if (map.getWorldSubsetFactory().getClass() == CircularWorldSubsetFactory.class) {
      CircularWorldSubsetFactory subset=(CircularWorldSubsetFactory)map.getWorldSubsetFactory();
      radius=subset.getRadius();
      if (subset.getOrigin() != null) {
        originX=subset.getOrigin().x;
        originZ=subset.getOrigin().z;
      }
    }
    Sign sign=new Sign();
    while (signs.hasNext()) {
      signs.read(sign);
      String message=""String_Node_Str"";
      if (Float.parseFloat(Minecraft.minecraftVersion) == 1.8f)       message=""String_Node_Str"" + sign.getText(0) + ""String_Node_Str""+ sign.getText(1)+ ""String_Node_Str""+ sign.getText(2)+ ""String_Node_Str""+ sign.getText(3)+ ""String_Node_Str"";
 else       message=""String_Node_Str"" + jsEscape(sign.getText(0)) + ""String_Node_Str""+ jsEscape(sign.getText(1))+ ""String_Node_Str""+ jsEscape(sign.getText(2))+ ""String_Node_Str""+ jsEscape(sign.getText(3))+ ""String_Node_Str"";
      HashMap<String,String> args=new HashMap<String,String>();
      final float worldX=sign.getX() + 0.5f;
      final float worldY=sign.getY();
      final float worldZ=sign.getZ() + 0.5f;
      String posStr=""String_Node_Str"" + worldX + ""String_Node_Str""+ worldY+ ""String_Node_Str""+ worldZ+ ""String_Node_Str"";
      args.put(""String_Node_Str"",posStr);
      args.put(""String_Node_Str"",message);
      if (Float.parseFloat(Minecraft.minecraftVersion) == 1.8f) {
        args.put(""String_Node_Str"",""String_Node_Str"" + sign.getText(0) + ""String_Node_Str"");
        args.put(""String_Node_Str"",""String_Node_Str"" + sign.getText(1) + ""String_Node_Str"");
        args.put(""String_Node_Str"",""String_Node_Str"" + sign.getText(2) + ""String_Node_Str"");
        args.put(""String_Node_Str"",""String_Node_Str"" + sign.getText(3) + ""String_Node_Str"");
      }
 else {
        args.put(""String_Node_Str"",""String_Node_Str"" + jsEscape(sign.getText(0)) + ""String_Node_Str"");
        args.put(""String_Node_Str"",""String_Node_Str"" + jsEscape(sign.getText(1)) + ""String_Node_Str"");
        args.put(""String_Node_Str"",""String_Node_Str"" + jsEscape(sign.getText(2)) + ""String_Node_Str"");
        args.put(""String_Node_Str"",""String_Node_Str"" + jsEscape(sign.getText(3)) + ""String_Node_Str"");
      }
      if (radius == 0 || radius != 0 && Math.pow((sign.getX() - originX),2) + Math.pow((sign.getZ() - originZ),2) < Math.pow(radius,2)) {
        jsWriter.write(args);
      }
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
 finally {
    if (jsWriter != null)     jsWriter.close();
  }
}",0.9851301115241636
80081,"private void init(InputStream in,Compression compression) throws Exception {
  clear();
  NBTInputStream nbtIn=null;
  try {
    nbtIn=new NBTInputStream(in,compression);
    Tag tag=nbtIn.readTag();
    if (tag instanceof CompoundTag) {
      CompoundTag root=(CompoundTag)tag;
      CompoundTag level=NbtUtil.getChild(root,""String_Node_Str"",CompoundTag.class);
      if (level != null) {
        blockX=blockY=blockZ=0;
        IntTag xPosTag=NbtUtil.getChild(level,""String_Node_Str"",IntTag.class);
        if (xPosTag != null)         blockX=xPosTag.getValue().intValue();
        IntTag zPosTag=NbtUtil.getChild(level,""String_Node_Str"",IntTag.class);
        if (zPosTag != null)         blockZ=zPosTag.getValue().intValue();
        ListTag sections=NbtUtil.getChild(level,""String_Node_Str"",ListTag.class);
        if (sections != null) {
          parseAnvilData(level);
        }
 else {
          parseMcRegionData(level);
        }
        ListTag entitiesTag=NbtUtil.getChild(level,""String_Node_Str"",ListTag.class);
        if (entitiesTag != null) {
          for (          Tag t : entitiesTag.getValue()) {
            if (t instanceof CompoundTag) {
              CompoundTag entity=(CompoundTag)t;
              StringTag idTag=NbtUtil.getChild(entity,""String_Node_Str"",StringTag.class);
              if (idTag.getValue().endsWith(""String_Node_Str"")) {
                StringTag motiveTag=NbtUtil.getChild(entity,""String_Node_Str"",StringTag.class);
                IntTag xTag=NbtUtil.getChild(entity,""String_Node_Str"",IntTag.class);
                IntTag yTag=NbtUtil.getChild(entity,""String_Node_Str"",IntTag.class);
                IntTag zTag=NbtUtil.getChild(entity,""String_Node_Str"",IntTag.class);
                ByteTag dir=NbtUtil.getChild(entity,""String_Node_Str"",ByteTag.class);
                boolean is18=false;
                if (dir == null) {
                  dir=NbtUtil.getChild(entity,""String_Node_Str"",ByteTag.class);
                  is18=true;
                }
                int x=xTag.getValue();
                final int y=yTag.getValue();
                int z=zTag.getValue();
                if (is18 && dir.getValue() == 0) {
                  z=zTag.getValue() - 1;
                }
 else                 if (is18 && dir.getValue() == 1) {
                  x=xTag.getValue() + 1;
                }
 else                 if (is18 && dir.getValue() == 2) {
                  z=zTag.getValue() + 1;
                }
 else                 if (is18 && dir.getValue() == 3) {
                  x=xTag.getValue() - 1;
                }
                final int localX=x - (blockX * WIDTH);
                final int localY=y - (blockY * HEIGHT);
                final int localZ=z - (blockZ * DEPTH);
                paintings.add(new TileEntity(-1,0,x,y,z,localX,localY,localZ,motiveTag.getValue(),dir.getValue()));
              }
 else               if (idTag.getValue().equals(""String_Node_Str"")) {
                IntTag xTag=NbtUtil.getChild(entity,""String_Node_Str"",IntTag.class);
                IntTag yTag=NbtUtil.getChild(entity,""String_Node_Str"",IntTag.class);
                IntTag zTag=NbtUtil.getChild(entity,""String_Node_Str"",IntTag.class);
                ByteTag dir=NbtUtil.getChild(entity,""String_Node_Str"",ByteTag.class);
                boolean is18=false;
                if (dir == null) {
                  dir=NbtUtil.getChild(entity,""String_Node_Str"",ByteTag.class);
                  is18=true;
                }
                String item=""String_Node_Str"";
                Map<String,Tag> map=entity.getValue();
                CompoundTag itemTag=(CompoundTag)map.get(""String_Node_Str"");
                if (itemTag != null) {
                  ShortTag itemIdTag=NbtUtil.getChild(itemTag,""String_Node_Str"",ShortTag.class);
                  if (itemIdTag == null) {
                    StringTag stringItemIdTag=NbtUtil.getChild(itemTag,""String_Node_Str"",StringTag.class);
                    item=stringItemIdTag.getValue();
                  }
 else {
                    if (itemIdTag.getValue() == 358)                     item=""String_Node_Str"";
                  }
                }
                int x=xTag.getValue();
                final int y=yTag.getValue();
                int z=zTag.getValue();
                if (is18 && dir.getValue() == 0) {
                  z=zTag.getValue() - 1;
                }
 else                 if (is18 && dir.getValue() == 1) {
                  x=xTag.getValue() + 1;
                }
 else                 if (is18 && dir.getValue() == 2) {
                  z=zTag.getValue() + 1;
                }
 else                 if (is18 && dir.getValue() == 3) {
                  x=xTag.getValue() - 1;
                }
                final int localX=x - (blockX * WIDTH);
                final int localY=y - (blockY * HEIGHT);
                final int localZ=z - (blockZ * DEPTH);
                itemFrames.add(new TileEntity(-2,0,x,y,z,localX,localY,localZ,item,dir.getValue()));
              }
            }
          }
        }
        ListTag tileEntitiesTag=NbtUtil.getChild(level,""String_Node_Str"",ListTag.class);
        if (tileEntitiesTag != null) {
          for (          Tag t : tileEntitiesTag.getValue()) {
            if (t instanceof CompoundTag) {
              CompoundTag entity=(CompoundTag)t;
              StringTag idTag=NbtUtil.getChild(entity,""String_Node_Str"",StringTag.class);
              IntTag xTag=NbtUtil.getChild(entity,""String_Node_Str"",IntTag.class);
              IntTag yTag=NbtUtil.getChild(entity,""String_Node_Str"",IntTag.class);
              IntTag zTag=NbtUtil.getChild(entity,""String_Node_Str"",IntTag.class);
              if (idTag != null && xTag != null && yTag != null && zTag != null) {
                String id=idTag.getValue();
                if (id.equals(""String_Node_Str"")) {
                  StringTag text1Tag=NbtUtil.getChild(entity,""String_Node_Str"",StringTag.class);
                  StringTag text2Tag=NbtUtil.getChild(entity,""String_Node_Str"",StringTag.class);
                  StringTag text3Tag=NbtUtil.getChild(entity,""String_Node_Str"",StringTag.class);
                  StringTag text4Tag=NbtUtil.getChild(entity,""String_Node_Str"",StringTag.class);
                  String text1=text1Tag.getValue().replaceAll(""String_Node_Str"",""String_Node_Str"");
                  if (text1 == null || text1.equals(""String_Node_Str""))                   text1=""String_Node_Str"";
                  String text2=text2Tag.getValue().replaceAll(""String_Node_Str"",""String_Node_Str"");
                  if (text2 == null || text2.equals(""String_Node_Str""))                   text2=""String_Node_Str"";
                  String text3=text3Tag.getValue().replaceAll(""String_Node_Str"",""String_Node_Str"");
                  if (text3 == null || text3.equals(""String_Node_Str""))                   text3=""String_Node_Str"";
                  String text4=text4Tag.getValue().replaceAll(""String_Node_Str"",""String_Node_Str"");
                  if (text4 == null || text4.equals(""String_Node_Str""))                   text4=""String_Node_Str"";
                  final int x=xTag.getValue();
                  final int y=yTag.getValue();
                  final int z=zTag.getValue();
                  final int localX=x - (blockX * WIDTH);
                  final int localY=y - (blockY * HEIGHT);
                  final int localZ=z - (blockZ * DEPTH);
                  final int blockId=getBlockId(localX,localY,localZ);
                  final int data=getBlockData(localX,localY,localZ);
                  signs.add(new RawSign(blockId,data,x,y,z,localX,localY,localZ,text1,text2,text3,text4));
                }
 else                 if (id.equals(""String_Node_Str"")) {
                  IntTag dataTag=NbtUtil.getChild(entity,""String_Node_Str"",IntTag.class);
                  IntTag itemTag=NbtUtil.getChild(entity,""String_Node_Str"",IntTag.class);
                  final int item;
                  if (itemTag == null) {
                    StringTag stringIdTag=NbtUtil.getChild(entity,""String_Node_Str"",StringTag.class);
                    if (stringIdTag.getValue().equals(""String_Node_Str""))                     item=6;
 else                     if (stringIdTag.getValue().equals(""String_Node_Str""))                     item=38;
 else                     item=0;
                  }
 else {
                    item=itemTag.getValue();
                  }
                  final int x=xTag.getValue();
                  final int y=yTag.getValue();
                  final int z=zTag.getValue();
                  final int localX=x - (blockX * WIDTH);
                  final int localY=y - (blockY * HEIGHT);
                  final int localZ=z - (blockZ * DEPTH);
                  final int blockData=getBlockData(localX,localY,localZ);
                  final int itemData=dataTag.getValue();
                  flowerPots.add(new TileEntity(0,blockData,x,y,z,localX,localY,localZ,itemData,item));
                }
 else                 if (id.equals(""String_Node_Str"")) {
                  ByteTag skullType=NbtUtil.getChild(entity,""String_Node_Str"",ByteTag.class);
                  ByteTag rot=NbtUtil.getChild(entity,""String_Node_Str"",ByteTag.class);
                  StringTag nameTag=null;
                  StringTag playerId=null;
                  String name=""String_Node_Str"";
                  String UUID=""String_Node_Str"";
                  String textureURL=""String_Node_Str"";
                  StringTag extraType=NbtUtil.getChild(entity,""String_Node_Str"",StringTag.class);
                  CompoundTag owner=NbtUtil.getChild(entity,""String_Node_Str"",CompoundTag.class);
                  if (owner != null) {
                    nameTag=NbtUtil.getChild(owner,""String_Node_Str"",StringTag.class);
                    name=nameTag.getValue();
                    playerId=NbtUtil.getChild(owner,""String_Node_Str"",StringTag.class);
                    UUID=playerId.getValue().replace(""String_Node_Str"",""String_Node_Str"");
                    CompoundTag properties=NbtUtil.getChild(owner,""String_Node_Str"",CompoundTag.class);
                    ListTag textures=NbtUtil.getChild(properties,""String_Node_Str"",ListTag.class);
                    CompoundTag tex=NbtUtil.getChild(textures,0,CompoundTag.class);
                    StringTag value=NbtUtil.getChild(tex,""String_Node_Str"",StringTag.class);
                    byte[] decoded=DatatypeConverter.parseBase64Binary(value.getValue());
                    JSONObject obj=new JSONObject(new String(decoded,""String_Node_Str""));
                    textureURL=obj.getJSONObject(""String_Node_Str"").getJSONObject(""String_Node_Str"").getString(""String_Node_Str"");
                  }
 else                   if (extraType != null && !(extraType.getValue().equals(""String_Node_Str""))) {
                    name=UUID=extraType.getValue();
                    textureURL=""String_Node_Str"" + extraType.getValue() + ""String_Node_Str"";
                  }
                  final int x=xTag.getValue();
                  final int y=yTag.getValue();
                  final int z=zTag.getValue();
                  final int localX=x - (blockX * WIDTH);
                  final int localY=y - (blockY * HEIGHT);
                  final int localZ=z - (blockZ * DEPTH);
                  skulls.add(new TileEntity(skullType.getValue(),rot.getValue(),x,y,z,localX,localY,localZ,name,UUID,textureURL,null));
                }
 else                 if (id.equals(""String_Node_Str"")) {
                  IntTag levels=NbtUtil.getChild(entity,""String_Node_Str"",IntTag.class);
                  final int x=xTag.getValue();
                  final int y=yTag.getValue();
                  final int z=zTag.getValue();
                  final int localX=x - (blockX * WIDTH);
                  final int localY=y - (blockY * HEIGHT);
                  final int localZ=z - (blockZ * DEPTH);
                  beacons.add(new TileEntity(0,levels.getValue(),x,y,z,localX,localY,localZ,0,0));
                }
 else                 if (id.equals(""String_Node_Str"")) {
                  IntTag base=NbtUtil.getChild(entity,""String_Node_Str"",IntTag.class);
                  final int x=xTag.getValue();
                  final int y=yTag.getValue();
                  final int z=zTag.getValue();
                  final int localX=x - (blockX * WIDTH);
                  final int localY=y - (blockY * HEIGHT);
                  final int localZ=z - (blockZ * DEPTH);
                  banners.add(new TileEntity(0,base.getValue(),x,y,z,localX,localY,localZ,0,0));
                }
              }
            }
          }
        }
      }
    }
  }
  finally {
    if (nbtIn != null)     nbtIn.close();
    if (in != null)     in.close();
  }
}","private void init(InputStream in,Compression compression) throws Exception {
  clear();
  NBTInputStream nbtIn=null;
  try {
    nbtIn=new NBTInputStream(in,compression);
    Tag tag=nbtIn.readTag();
    if (tag instanceof CompoundTag) {
      CompoundTag root=(CompoundTag)tag;
      CompoundTag level=NbtUtil.getChild(root,""String_Node_Str"",CompoundTag.class);
      if (level != null) {
        blockX=blockY=blockZ=0;
        IntTag xPosTag=NbtUtil.getChild(level,""String_Node_Str"",IntTag.class);
        if (xPosTag != null)         blockX=xPosTag.getValue().intValue();
        IntTag zPosTag=NbtUtil.getChild(level,""String_Node_Str"",IntTag.class);
        if (zPosTag != null)         blockZ=zPosTag.getValue().intValue();
        ListTag sections=NbtUtil.getChild(level,""String_Node_Str"",ListTag.class);
        if (sections != null) {
          parseAnvilData(level);
        }
 else {
          parseMcRegionData(level);
        }
        ListTag entitiesTag=NbtUtil.getChild(level,""String_Node_Str"",ListTag.class);
        if (entitiesTag != null) {
          for (          Tag t : entitiesTag.getValue()) {
            if (t instanceof CompoundTag) {
              CompoundTag entity=(CompoundTag)t;
              StringTag idTag=NbtUtil.getChild(entity,""String_Node_Str"",StringTag.class);
              if (idTag.getValue().endsWith(""String_Node_Str"")) {
                StringTag motiveTag=NbtUtil.getChild(entity,""String_Node_Str"",StringTag.class);
                IntTag xTag=NbtUtil.getChild(entity,""String_Node_Str"",IntTag.class);
                IntTag yTag=NbtUtil.getChild(entity,""String_Node_Str"",IntTag.class);
                IntTag zTag=NbtUtil.getChild(entity,""String_Node_Str"",IntTag.class);
                ByteTag dir=NbtUtil.getChild(entity,""String_Node_Str"",ByteTag.class);
                boolean is18=false;
                if (dir == null) {
                  dir=NbtUtil.getChild(entity,""String_Node_Str"",ByteTag.class);
                  is18=true;
                }
                int x=xTag.getValue();
                final int y=yTag.getValue();
                int z=zTag.getValue();
                if (is18 && dir.getValue() == 0) {
                  z=zTag.getValue() - 1;
                }
 else                 if (is18 && dir.getValue() == 1) {
                  x=xTag.getValue() + 1;
                }
 else                 if (is18 && dir.getValue() == 2) {
                  z=zTag.getValue() + 1;
                }
 else                 if (is18 && dir.getValue() == 3) {
                  x=xTag.getValue() - 1;
                }
                final int localX=x - (blockX * WIDTH);
                final int localY=y - (blockY * HEIGHT);
                final int localZ=z - (blockZ * DEPTH);
                paintings.add(new TileEntity(-1,0,x,y,z,localX,localY,localZ,motiveTag.getValue(),dir.getValue()));
              }
 else               if (idTag.getValue().equals(""String_Node_Str"")) {
                IntTag xTag=NbtUtil.getChild(entity,""String_Node_Str"",IntTag.class);
                IntTag yTag=NbtUtil.getChild(entity,""String_Node_Str"",IntTag.class);
                IntTag zTag=NbtUtil.getChild(entity,""String_Node_Str"",IntTag.class);
                ByteTag dir=NbtUtil.getChild(entity,""String_Node_Str"",ByteTag.class);
                boolean is18=false;
                if (dir == null) {
                  dir=NbtUtil.getChild(entity,""String_Node_Str"",ByteTag.class);
                  is18=true;
                }
                String item=""String_Node_Str"";
                Map<String,Tag> map=entity.getValue();
                CompoundTag itemTag=(CompoundTag)map.get(""String_Node_Str"");
                if (itemTag != null) {
                  ShortTag itemIdTag=NbtUtil.getChild(itemTag,""String_Node_Str"",ShortTag.class);
                  if (itemIdTag == null) {
                    StringTag stringItemIdTag=NbtUtil.getChild(itemTag,""String_Node_Str"",StringTag.class);
                    item=stringItemIdTag.getValue();
                  }
 else {
                    if (itemIdTag.getValue() == 358)                     item=""String_Node_Str"";
                  }
                }
                int x=xTag.getValue();
                final int y=yTag.getValue();
                int z=zTag.getValue();
                if (is18 && dir.getValue() == 0) {
                  z=zTag.getValue() - 1;
                }
 else                 if (is18 && dir.getValue() == 1) {
                  x=xTag.getValue() + 1;
                }
 else                 if (is18 && dir.getValue() == 2) {
                  z=zTag.getValue() + 1;
                }
 else                 if (is18 && dir.getValue() == 3) {
                  x=xTag.getValue() - 1;
                }
                final int localX=x - (blockX * WIDTH);
                final int localY=y - (blockY * HEIGHT);
                final int localZ=z - (blockZ * DEPTH);
                itemFrames.add(new TileEntity(-2,0,x,y,z,localX,localY,localZ,item,dir.getValue()));
              }
            }
          }
        }
        ListTag tileEntitiesTag=NbtUtil.getChild(level,""String_Node_Str"",ListTag.class);
        if (tileEntitiesTag != null) {
          for (          Tag t : tileEntitiesTag.getValue()) {
            if (t instanceof CompoundTag) {
              CompoundTag entity=(CompoundTag)t;
              StringTag idTag=NbtUtil.getChild(entity,""String_Node_Str"",StringTag.class);
              IntTag xTag=NbtUtil.getChild(entity,""String_Node_Str"",IntTag.class);
              IntTag yTag=NbtUtil.getChild(entity,""String_Node_Str"",IntTag.class);
              IntTag zTag=NbtUtil.getChild(entity,""String_Node_Str"",IntTag.class);
              if (idTag != null && xTag != null && yTag != null && zTag != null) {
                String id=idTag.getValue();
                if (id.equals(""String_Node_Str"")) {
                  StringTag text1Tag=NbtUtil.getChild(entity,""String_Node_Str"",StringTag.class);
                  StringTag text2Tag=NbtUtil.getChild(entity,""String_Node_Str"",StringTag.class);
                  StringTag text3Tag=NbtUtil.getChild(entity,""String_Node_Str"",StringTag.class);
                  StringTag text4Tag=NbtUtil.getChild(entity,""String_Node_Str"",StringTag.class);
                  String text1, text2, text3, text4;
                  if (text1Tag.getValue().charAt(0) == '{') {
                    JSONObject obj=new JSONObject(text1Tag.getValue());
                    text1=obj.getString(""String_Node_Str"");
                    obj=new JSONObject(text2Tag.getValue());
                    text2=obj.getString(""String_Node_Str"");
                    obj=new JSONObject(text3Tag.getValue());
                    text3=obj.getString(""String_Node_Str"");
                    obj=new JSONObject(text4Tag.getValue());
                    text4=obj.getString(""String_Node_Str"");
                  }
 else {
                    text1=text1Tag.getValue().replaceAll(""String_Node_Str"",""String_Node_Str"");
                    if (text1 == null || text1.equals(""String_Node_Str""))                     text1=""String_Node_Str"";
                    text2=text2Tag.getValue().replaceAll(""String_Node_Str"",""String_Node_Str"");
                    if (text2 == null || text2.equals(""String_Node_Str""))                     text2=""String_Node_Str"";
                    text3=text3Tag.getValue().replaceAll(""String_Node_Str"",""String_Node_Str"");
                    if (text3 == null || text3.equals(""String_Node_Str""))                     text3=""String_Node_Str"";
                    text4=text4Tag.getValue().replaceAll(""String_Node_Str"",""String_Node_Str"");
                    if (text4 == null || text4.equals(""String_Node_Str""))                     text4=""String_Node_Str"";
                  }
                  final int x=xTag.getValue();
                  final int y=yTag.getValue();
                  final int z=zTag.getValue();
                  final int localX=x - (blockX * WIDTH);
                  final int localY=y - (blockY * HEIGHT);
                  final int localZ=z - (blockZ * DEPTH);
                  final int blockId=getBlockId(localX,localY,localZ);
                  final int data=getBlockData(localX,localY,localZ);
                  signs.add(new RawSign(blockId,data,x,y,z,localX,localY,localZ,text1,text2,text3,text4));
                }
 else                 if (id.equals(""String_Node_Str"")) {
                  IntTag dataTag=NbtUtil.getChild(entity,""String_Node_Str"",IntTag.class);
                  IntTag itemTag=NbtUtil.getChild(entity,""String_Node_Str"",IntTag.class);
                  final int item;
                  if (itemTag == null) {
                    StringTag stringIdTag=NbtUtil.getChild(entity,""String_Node_Str"",StringTag.class);
                    if (stringIdTag.getValue().equals(""String_Node_Str""))                     item=6;
 else                     if (stringIdTag.getValue().equals(""String_Node_Str""))                     item=38;
 else                     item=0;
                  }
 else {
                    item=itemTag.getValue();
                  }
                  final int x=xTag.getValue();
                  final int y=yTag.getValue();
                  final int z=zTag.getValue();
                  final int localX=x - (blockX * WIDTH);
                  final int localY=y - (blockY * HEIGHT);
                  final int localZ=z - (blockZ * DEPTH);
                  final int blockData=getBlockData(localX,localY,localZ);
                  final int itemData=dataTag.getValue();
                  flowerPots.add(new TileEntity(0,blockData,x,y,z,localX,localY,localZ,itemData,item));
                }
 else                 if (id.equals(""String_Node_Str"")) {
                  ByteTag skullType=NbtUtil.getChild(entity,""String_Node_Str"",ByteTag.class);
                  ByteTag rot=NbtUtil.getChild(entity,""String_Node_Str"",ByteTag.class);
                  StringTag nameTag=null;
                  StringTag playerId=null;
                  String name=""String_Node_Str"";
                  String UUID=""String_Node_Str"";
                  String textureURL=""String_Node_Str"";
                  StringTag extraType=NbtUtil.getChild(entity,""String_Node_Str"",StringTag.class);
                  CompoundTag owner=NbtUtil.getChild(entity,""String_Node_Str"",CompoundTag.class);
                  if (owner != null) {
                    nameTag=NbtUtil.getChild(owner,""String_Node_Str"",StringTag.class);
                    name=nameTag.getValue();
                    playerId=NbtUtil.getChild(owner,""String_Node_Str"",StringTag.class);
                    UUID=playerId.getValue().replace(""String_Node_Str"",""String_Node_Str"");
                    CompoundTag properties=NbtUtil.getChild(owner,""String_Node_Str"",CompoundTag.class);
                    ListTag textures=NbtUtil.getChild(properties,""String_Node_Str"",ListTag.class);
                    CompoundTag tex=NbtUtil.getChild(textures,0,CompoundTag.class);
                    StringTag value=NbtUtil.getChild(tex,""String_Node_Str"",StringTag.class);
                    byte[] decoded=DatatypeConverter.parseBase64Binary(value.getValue());
                    JSONObject obj=new JSONObject(new String(decoded,""String_Node_Str""));
                    textureURL=obj.getJSONObject(""String_Node_Str"").getJSONObject(""String_Node_Str"").getString(""String_Node_Str"");
                  }
 else                   if (extraType != null && !(extraType.getValue().equals(""String_Node_Str""))) {
                    name=UUID=extraType.getValue();
                    textureURL=""String_Node_Str"" + extraType.getValue() + ""String_Node_Str"";
                  }
                  final int x=xTag.getValue();
                  final int y=yTag.getValue();
                  final int z=zTag.getValue();
                  final int localX=x - (blockX * WIDTH);
                  final int localY=y - (blockY * HEIGHT);
                  final int localZ=z - (blockZ * DEPTH);
                  skulls.add(new TileEntity(skullType.getValue(),rot.getValue(),x,y,z,localX,localY,localZ,name,UUID,textureURL,null));
                }
 else                 if (id.equals(""String_Node_Str"")) {
                  IntTag levels=NbtUtil.getChild(entity,""String_Node_Str"",IntTag.class);
                  final int x=xTag.getValue();
                  final int y=yTag.getValue();
                  final int z=zTag.getValue();
                  final int localX=x - (blockX * WIDTH);
                  final int localY=y - (blockY * HEIGHT);
                  final int localZ=z - (blockZ * DEPTH);
                  beacons.add(new TileEntity(0,levels.getValue(),x,y,z,localX,localY,localZ,0,0));
                }
 else                 if (id.equals(""String_Node_Str"")) {
                  IntTag base=NbtUtil.getChild(entity,""String_Node_Str"",IntTag.class);
                  ListTag patternList=NbtUtil.getChild(entity,""String_Node_Str"",ListTag.class);
                  final int x=xTag.getValue();
                  final int y=yTag.getValue();
                  final int z=zTag.getValue();
                  final int localX=x - (blockX * WIDTH);
                  final int localY=y - (blockY * HEIGHT);
                  final int localZ=z - (blockZ * DEPTH);
                  String patterns=""String_Node_Str"";
                  final int numPatterns=patternList.getValue().size();
                  if (numPatterns > 0) {
                    patterns+=""String_Node_Str"";
                    for (int i=0; i < numPatterns; i++) {
                      CompoundTag p=NbtUtil.getChild(patternList,i,CompoundTag.class);
                      StringTag pattern=NbtUtil.getChild(p,""String_Node_Str"",StringTag.class);
                      IntTag color=NbtUtil.getChild(p,""String_Node_Str"",IntTag.class);
                      patterns+=""String_Node_Str"" + pattern.getValue() + ""String_Node_Str""+ ""String_Node_Str""+ color.getValue().toString();
                      if (i < numPatterns - 1)                       patterns+=""String_Node_Str"";
                    }
                    patterns+=""String_Node_Str"";
                  }
                  banners.add(new TileEntity(0,base.getValue(),x,y,z,localX,localY,localZ,patterns,0));
                }
              }
            }
          }
        }
      }
    }
  }
  finally {
    if (nbtIn != null)     nbtIn.close();
    if (in != null)     in.close();
  }
}",0.938714060147615
80082,"public void lookAt(float x,float y,float z,final float zoom,final float angleOffsetRads,final float elevationAngleRads){
  this.lookAt.set(x,y,z);
  this.zoom=zoom;
  eye=calcEyePosition(lookAt,angleOffsetRads,elevationAngleRads);
{
    Vector3f forward=new Vector3f(lookAt.x - eye.x,lookAt.y - eye.y,lookAt.z - eye.z);
    forward.normalise();
    if (elevationAngleRads >= Math.PI / 2f) {
      Vector3f dummyEye=calcEyePosition(lookAt,angleOffsetRads,(float)Math.PI / 4.0f);
      Vector3f dummyForward=new Vector3f(lookAt.x - dummyEye.x,lookAt.y - dummyEye.y,lookAt.z - dummyEye.z);
      dummyForward.normalise();
      up=new Vector3f(dummyForward.x,dummyForward.y + 1,dummyForward.z);
    }
 else {
      up=new Vector3f(0,1,0);
    }
    Vector3f dir=new Vector3f(lookAt.x - eye.x,lookAt.y - eye.y,lookAt.z - eye.z);
    dir.normalise();
    Vector3f.cross(dir,up,right);
    Vector3f.cross(right,dir,up);
    right.normalise();
    up.normalise();
  }
  final float size=this.zoom / 2;
  projectionMatrix=MatrixUtil.createOrthoMatrix(-size,size,-size,size,1000,2000);
  cameraMatrix=MatrixUtil.createLookAt(eye,lookAt,up);
  frustum.extract(projectionMatrix,cameraMatrix,windowWidth,windowHeight,viewport);
}","public void lookAt(float x,float y,float z,final float zoom,final float angleOffsetRads,final float elevationAngleRads){
  this.lookAt.set(x,y,z);
  this.zoom=zoom;
  eye=calcEyePosition(lookAt,angleOffsetRads,elevationAngleRads);
{
    Vector3f forward=new Vector3f(lookAt.x - eye.x,lookAt.y - eye.y,lookAt.z - eye.z);
    forward.normalise();
    if (elevationAngleRads >= Math.PI / 2f) {
      Vector3f dummyEye=calcEyePosition(lookAt,angleOffsetRads,(float)Math.PI / 4.0f);
      Vector3f dummyForward=new Vector3f(lookAt.x - dummyEye.x,lookAt.y - dummyEye.y,lookAt.z - dummyEye.z);
      dummyForward.normalise();
      up=new Vector3f(dummyForward.x,dummyForward.y + 1,dummyForward.z);
    }
 else {
      up=new Vector3f(0,1,0);
    }
    Vector3f dir=new Vector3f(lookAt.x - eye.x,lookAt.y - eye.y,lookAt.z - eye.z);
    dir.normalise();
    Vector3f.cross(dir,up,right);
    Vector3f.cross(right,dir,up);
    right.normalise();
    up.normalise();
  }
  final float size=this.zoom / 2;
  projectionMatrix=MatrixUtil.createOrthoMatrix(-size,size,-size,size,1000,7000);
  cameraMatrix=MatrixUtil.createLookAt(eye,lookAt,up);
  frustum.extract(projectionMatrix,cameraMatrix,windowWidth,windowHeight,viewport);
}",0.9991783073130648
80083,"private int outputPortals(File portalFile,HddObjectListReader<Portal> portalPositions,tectonicus.configuration.Map map){
  System.out.println(""String_Node_Str"");
  if (portalFile.exists())   portalFile.delete();
  int numPortals=0;
  JsArrayWriter jsWriter=null;
  try {
    jsWriter=new JsArrayWriter(portalFile,map.getId() + ""String_Node_Str"");
    ArrayList<Portal> portals=new ArrayList<Portal>();
    long prevX, prevY, prevZ, firstX, firstZ;
    Portal portal=new Portal();
    portalPositions.read(portal);
    firstX=portal.getX();
    firstZ=portal.getZ();
    prevX=portal.getX();
    prevY=portal.getY();
    prevZ=portal.getZ();
    while (portalPositions.hasNext()) {
      portalPositions.read(portal);
      if ((portal.getX() == prevX && portal.getZ() == prevZ + 1) || (portal.getX() == prevX + 1 && portal.getZ() == prevZ)) {
        prevX=portal.getX();
        prevY=portal.getY();
        prevZ=portal.getZ();
      }
 else {
        portals.add(new Portal(prevX + (firstX - prevX) / 2,prevY,prevZ + (firstZ - prevZ) / 2));
        numPortals++;
        prevX=portal.getX();
        prevY=portal.getY();
        prevZ=portal.getZ();
        firstX=portal.getX();
        firstZ=portal.getZ();
      }
    }
    portals.add(new Portal(portal.getX() + ((firstX - prevX) / 2),portal.getY(),portal.getZ() + (firstZ - prevZ) / 2));
    numPortals++;
    for (    Portal p : portals) {
      final float worldX=p.getX();
      final float worldY=p.getY();
      final float worldZ=p.getZ();
      HashMap<String,String> args=new HashMap<String,String>();
      String posStr=""String_Node_Str"" + worldX + ""String_Node_Str""+ worldY+ ""String_Node_Str""+ worldZ+ ""String_Node_Str"";
      args.put(""String_Node_Str"",posStr);
      jsWriter.write(args);
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
 finally {
    if (jsWriter != null)     jsWriter.close();
  }
  return numPortals;
}","private int outputPortals(File portalFile,HddObjectListReader<Portal> portalPositions,tectonicus.configuration.Map map){
  System.out.println(""String_Node_Str"");
  if (portalFile.exists())   portalFile.delete();
  int numPortals=0;
  JsArrayWriter jsWriter=null;
  try {
    jsWriter=new JsArrayWriter(portalFile,map.getId() + ""String_Node_Str"");
    ArrayList<Portal> portals=new ArrayList<Portal>();
    if (portalPositions.hasNext()) {
      long prevX, prevY, prevZ, firstX, firstZ;
      Portal portal=new Portal();
      portalPositions.read(portal);
      firstX=portal.getX();
      firstZ=portal.getZ();
      prevX=portal.getX();
      prevY=portal.getY();
      prevZ=portal.getZ();
      while (portalPositions.hasNext()) {
        portalPositions.read(portal);
        if ((portal.getX() == prevX && portal.getZ() == prevZ + 1) || (portal.getX() == prevX + 1 && portal.getZ() == prevZ)) {
          prevX=portal.getX();
          prevY=portal.getY();
          prevZ=portal.getZ();
        }
 else {
          portals.add(new Portal(prevX + (firstX - prevX) / 2,prevY,prevZ + (firstZ - prevZ) / 2));
          numPortals++;
          prevX=portal.getX();
          prevY=portal.getY();
          prevZ=portal.getZ();
          firstX=portal.getX();
          firstZ=portal.getZ();
        }
      }
      portals.add(new Portal(portal.getX() + ((firstX - prevX) / 2),portal.getY(),portal.getZ() + (firstZ - prevZ) / 2));
      numPortals++;
      for (      Portal p : portals) {
        final float worldX=p.getX();
        final float worldY=p.getY();
        final float worldZ=p.getZ();
        HashMap<String,String> args=new HashMap<String,String>();
        String posStr=""String_Node_Str"" + worldX + ""String_Node_Str""+ worldY+ ""String_Node_Str""+ worldZ+ ""String_Node_Str"";
        args.put(""String_Node_Str"",posStr);
        jsWriter.write(args);
      }
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
 finally {
    if (jsWriter != null)     jsWriter.close();
  }
  System.out.println(""String_Node_Str"" + numPortals + ""String_Node_Str"");
  return numPortals;
}",0.8291344474931405
80084,"public static File findPlayersDir(File worldDir){
  if (worldDir == null)   return null;
  return new File(worldDir,""String_Node_Str"");
}","public static File findPlayersDir(File worldDir){
  if (worldDir == null)   return null;
  File oldDir=new File(worldDir,""String_Node_Str"");
  if (oldDir.exists())   return oldDir;
 else   return new File(worldDir,""String_Node_Str"");
}",0.6989247311827957
80085,"private void init(InputStream in,Compression compression) throws Exception {
  clear();
  NBTInputStream nbtIn=null;
  try {
    nbtIn=new NBTInputStream(in,compression);
    Tag tag=nbtIn.readTag();
    if (tag instanceof CompoundTag) {
      CompoundTag root=(CompoundTag)tag;
      CompoundTag level=NbtUtil.getChild(root,""String_Node_Str"",CompoundTag.class);
      if (level != null) {
        blockX=blockY=blockZ=0;
        IntTag xPosTag=NbtUtil.getChild(level,""String_Node_Str"",IntTag.class);
        if (xPosTag != null)         blockX=xPosTag.getValue().intValue();
        IntTag zPosTag=NbtUtil.getChild(level,""String_Node_Str"",IntTag.class);
        if (zPosTag != null)         blockZ=zPosTag.getValue().intValue();
        ListTag sections=NbtUtil.getChild(level,""String_Node_Str"",ListTag.class);
        if (sections != null) {
          parseAnvilData(level);
        }
 else {
          parseMcRegionData(level);
        }
        ListTag entitiesTag=NbtUtil.getChild(level,""String_Node_Str"",ListTag.class);
        if (entitiesTag != null) {
          for (          Tag t : entitiesTag.getValue()) {
            if (t instanceof CompoundTag) {
              CompoundTag entity=(CompoundTag)t;
              StringTag idTag=NbtUtil.getChild(entity,""String_Node_Str"",StringTag.class);
              if (idTag.getValue().endsWith(""String_Node_Str"")) {
                StringTag motiveTag=NbtUtil.getChild(entity,""String_Node_Str"",StringTag.class);
                IntTag xTag=NbtUtil.getChild(entity,""String_Node_Str"",IntTag.class);
                IntTag yTag=NbtUtil.getChild(entity,""String_Node_Str"",IntTag.class);
                IntTag zTag=NbtUtil.getChild(entity,""String_Node_Str"",IntTag.class);
                ByteTag dir=NbtUtil.getChild(entity,""String_Node_Str"",ByteTag.class);
                if (dir == null)                 dir=NbtUtil.getChild(entity,""String_Node_Str"",ByteTag.class);
                final int x=xTag.getValue();
                final int y=yTag.getValue();
                final int z=zTag.getValue();
                final int localX=x - (blockX * WIDTH);
                final int localY=y - (blockY * HEIGHT);
                final int localZ=z - (blockZ * DEPTH);
                paintings.add(new TileEntity(-1,0,x,y,z,localX,localY,localZ,motiveTag.getValue(),dir.getValue()));
              }
            }
          }
        }
        ListTag tileEntitiesTag=NbtUtil.getChild(level,""String_Node_Str"",ListTag.class);
        if (tileEntitiesTag != null) {
          for (          Tag t : tileEntitiesTag.getValue()) {
            if (t instanceof CompoundTag) {
              CompoundTag entity=(CompoundTag)t;
              StringTag idTag=NbtUtil.getChild(entity,""String_Node_Str"",StringTag.class);
              IntTag xTag=NbtUtil.getChild(entity,""String_Node_Str"",IntTag.class);
              IntTag yTag=NbtUtil.getChild(entity,""String_Node_Str"",IntTag.class);
              IntTag zTag=NbtUtil.getChild(entity,""String_Node_Str"",IntTag.class);
              if (idTag != null && xTag != null && yTag != null && zTag != null) {
                String id=idTag.getValue();
                if (id.equals(""String_Node_Str"")) {
                  StringTag text1Tag=NbtUtil.getChild(entity,""String_Node_Str"",StringTag.class);
                  StringTag text2Tag=NbtUtil.getChild(entity,""String_Node_Str"",StringTag.class);
                  StringTag text3Tag=NbtUtil.getChild(entity,""String_Node_Str"",StringTag.class);
                  StringTag text4Tag=NbtUtil.getChild(entity,""String_Node_Str"",StringTag.class);
                  String text1=text1Tag.getValue();
                  if (text1 == null)                   text1=""String_Node_Str"";
                  String text2=text2Tag.getValue();
                  if (text2 == null)                   text2=""String_Node_Str"";
                  String text3=text3Tag.getValue();
                  if (text3 == null)                   text3=""String_Node_Str"";
                  String text4=text4Tag.getValue();
                  if (text4 == null)                   text4=""String_Node_Str"";
                  final int x=xTag.getValue();
                  final int y=yTag.getValue();
                  final int z=zTag.getValue();
                  final int localX=x - (blockX * WIDTH);
                  final int localY=y - (blockY * HEIGHT);
                  final int localZ=z - (blockZ * DEPTH);
                  final int blockId=getBlockId(localX,localY,localZ);
                  final int data=getBlockData(localX,localY,localZ);
                  signs.add(new RawSign(blockId,data,x,y,z,localX,localY,localZ,text1,text2,text3,text4));
                }
 else                 if (id.equals(""String_Node_Str"")) {
                  IntTag dataTag=NbtUtil.getChild(entity,""String_Node_Str"",IntTag.class);
                  IntTag itemTag=NbtUtil.getChild(entity,""String_Node_Str"",IntTag.class);
                  final int x=xTag.getValue();
                  final int y=yTag.getValue();
                  final int z=zTag.getValue();
                  final int localX=x - (blockX * WIDTH);
                  final int localY=y - (blockY * HEIGHT);
                  final int localZ=z - (blockZ * DEPTH);
                  final int blockId=getBlockId(localX,localY,localZ);
                  final int blockData=getBlockData(localX,localY,localZ);
                  final int data=dataTag.getValue();
                  final int item=itemTag.getValue();
                  flowerPots.add(new TileEntity(blockId,blockData,x,y,z,localX,localY,localZ,data,item));
                }
              }
            }
          }
        }
      }
    }
  }
  finally {
    if (nbtIn != null)     nbtIn.close();
    if (in != null)     in.close();
  }
}","private void init(InputStream in,Compression compression) throws Exception {
  clear();
  NBTInputStream nbtIn=null;
  try {
    nbtIn=new NBTInputStream(in,compression);
    Tag tag=nbtIn.readTag();
    if (tag instanceof CompoundTag) {
      CompoundTag root=(CompoundTag)tag;
      CompoundTag level=NbtUtil.getChild(root,""String_Node_Str"",CompoundTag.class);
      if (level != null) {
        blockX=blockY=blockZ=0;
        IntTag xPosTag=NbtUtil.getChild(level,""String_Node_Str"",IntTag.class);
        if (xPosTag != null)         blockX=xPosTag.getValue().intValue();
        IntTag zPosTag=NbtUtil.getChild(level,""String_Node_Str"",IntTag.class);
        if (zPosTag != null)         blockZ=zPosTag.getValue().intValue();
        ListTag sections=NbtUtil.getChild(level,""String_Node_Str"",ListTag.class);
        if (sections != null) {
          parseAnvilData(level);
        }
 else {
          parseMcRegionData(level);
        }
        ListTag entitiesTag=NbtUtil.getChild(level,""String_Node_Str"",ListTag.class);
        if (entitiesTag != null) {
          for (          Tag t : entitiesTag.getValue()) {
            if (t instanceof CompoundTag) {
              CompoundTag entity=(CompoundTag)t;
              StringTag idTag=NbtUtil.getChild(entity,""String_Node_Str"",StringTag.class);
              if (idTag.getValue().endsWith(""String_Node_Str"")) {
                StringTag motiveTag=NbtUtil.getChild(entity,""String_Node_Str"",StringTag.class);
                IntTag xTag=NbtUtil.getChild(entity,""String_Node_Str"",IntTag.class);
                IntTag yTag=NbtUtil.getChild(entity,""String_Node_Str"",IntTag.class);
                IntTag zTag=NbtUtil.getChild(entity,""String_Node_Str"",IntTag.class);
                ByteTag dir=NbtUtil.getChild(entity,""String_Node_Str"",ByteTag.class);
                if (dir == null)                 dir=NbtUtil.getChild(entity,""String_Node_Str"",ByteTag.class);
                final int x=xTag.getValue();
                final int y=yTag.getValue();
                final int z=zTag.getValue();
                final int localX=x - (blockX * WIDTH);
                final int localY=y - (blockY * HEIGHT);
                final int localZ=z - (blockZ * DEPTH);
                paintings.add(new TileEntity(-1,0,x,y,z,localX,localY,localZ,motiveTag.getValue(),dir.getValue()));
              }
            }
          }
        }
        ListTag tileEntitiesTag=NbtUtil.getChild(level,""String_Node_Str"",ListTag.class);
        if (tileEntitiesTag != null) {
          for (          Tag t : tileEntitiesTag.getValue()) {
            if (t instanceof CompoundTag) {
              CompoundTag entity=(CompoundTag)t;
              StringTag idTag=NbtUtil.getChild(entity,""String_Node_Str"",StringTag.class);
              IntTag xTag=NbtUtil.getChild(entity,""String_Node_Str"",IntTag.class);
              IntTag yTag=NbtUtil.getChild(entity,""String_Node_Str"",IntTag.class);
              IntTag zTag=NbtUtil.getChild(entity,""String_Node_Str"",IntTag.class);
              if (idTag != null && xTag != null && yTag != null && zTag != null) {
                String id=idTag.getValue();
                if (id.equals(""String_Node_Str"")) {
                  StringTag text1Tag=NbtUtil.getChild(entity,""String_Node_Str"",StringTag.class);
                  StringTag text2Tag=NbtUtil.getChild(entity,""String_Node_Str"",StringTag.class);
                  StringTag text3Tag=NbtUtil.getChild(entity,""String_Node_Str"",StringTag.class);
                  StringTag text4Tag=NbtUtil.getChild(entity,""String_Node_Str"",StringTag.class);
                  String text1=text1Tag.getValue().replaceAll(""String_Node_Str"",""String_Node_Str"");
                  if (text1 == null || text1.equals(""String_Node_Str""))                   text1=""String_Node_Str"";
                  String text2=text2Tag.getValue().replaceAll(""String_Node_Str"",""String_Node_Str"");
                  if (text2 == null || text2.equals(""String_Node_Str""))                   text2=""String_Node_Str"";
                  String text3=text3Tag.getValue().replaceAll(""String_Node_Str"",""String_Node_Str"");
                  if (text3 == null || text3.equals(""String_Node_Str""))                   text3=""String_Node_Str"";
                  String text4=text4Tag.getValue().replaceAll(""String_Node_Str"",""String_Node_Str"");
                  if (text4 == null || text4.equals(""String_Node_Str""))                   text4=""String_Node_Str"";
                  final int x=xTag.getValue();
                  final int y=yTag.getValue();
                  final int z=zTag.getValue();
                  final int localX=x - (blockX * WIDTH);
                  final int localY=y - (blockY * HEIGHT);
                  final int localZ=z - (blockZ * DEPTH);
                  final int blockId=getBlockId(localX,localY,localZ);
                  final int data=getBlockData(localX,localY,localZ);
                  signs.add(new RawSign(blockId,data,x,y,z,localX,localY,localZ,text1,text2,text3,text4));
                }
 else                 if (id.equals(""String_Node_Str"")) {
                  IntTag dataTag=NbtUtil.getChild(entity,""String_Node_Str"",IntTag.class);
                  IntTag itemTag=NbtUtil.getChild(entity,""String_Node_Str"",IntTag.class);
                  final int x=xTag.getValue();
                  final int y=yTag.getValue();
                  final int z=zTag.getValue();
                  final int localX=x - (blockX * WIDTH);
                  final int localY=y - (blockY * HEIGHT);
                  final int localZ=z - (blockZ * DEPTH);
                  final int blockData=getBlockData(localX,localY,localZ);
                  final int data=dataTag.getValue();
                  final int item=38;
                  flowerPots.add(new TileEntity(0,blockData,x,y,z,localX,localY,localZ,data,item));
                }
              }
            }
          }
        }
      }
    }
  }
  finally {
    if (nbtIn != null)     nbtIn.close();
    if (in != null)     in.close();
  }
}",0.8709896452215243
80086,"public Sign(RawSign rawSign){
  blockId=rawSign.blockId;
  blockData=rawSign.data;
  position=new Vector3l(rawSign.x,rawSign.y,rawSign.z);
  text=new String[4];
  text[0]=rawSign.text1;
  text[1]=rawSign.text2;
  text[2]=rawSign.text3;
  text[3]=rawSign.text4;
}","public Sign(RawSign rawSign){
  blockId=rawSign.blockId;
  blockData=rawSign.blockData;
  position=new Vector3l(rawSign.x,rawSign.y,rawSign.z);
  text=new String[4];
  text[0]=rawSign.text1;
  text[1]=rawSign.text2;
  text[2]=rawSign.text3;
  text[3]=rawSign.text4;
}",0.9867674858223062
80087,"private void init(InputStream in,Compression compression) throws Exception {
  clear();
  NBTInputStream nbtIn=null;
  try {
    nbtIn=new NBTInputStream(in,compression);
    Tag tag=nbtIn.readTag();
    if (tag instanceof CompoundTag) {
      CompoundTag root=(CompoundTag)tag;
      CompoundTag level=NbtUtil.getChild(root,""String_Node_Str"",CompoundTag.class);
      if (level != null) {
        blockX=blockY=blockZ=0;
        IntTag xPosTag=NbtUtil.getChild(level,""String_Node_Str"",IntTag.class);
        if (xPosTag != null)         blockX=xPosTag.getValue().intValue();
        IntTag zPosTag=NbtUtil.getChild(level,""String_Node_Str"",IntTag.class);
        if (zPosTag != null)         blockZ=zPosTag.getValue().intValue();
        ListTag sections=NbtUtil.getChild(level,""String_Node_Str"",ListTag.class);
        if (sections != null) {
          parseAnvilData(level);
        }
 else {
          parseMcRegionData(level);
        }
        ListTag entitiesTag=NbtUtil.getChild(level,""String_Node_Str"",ListTag.class);
        if (entitiesTag != null) {
          for (          Tag t : entitiesTag.getValue()) {
            if (t instanceof CompoundTag) {
              CompoundTag entity=(CompoundTag)t;
              StringTag idTag=NbtUtil.getChild(entity,""String_Node_Str"",StringTag.class);
              if (idTag.getValue().endsWith(""String_Node_Str"")) {
                StringTag motiveTag=NbtUtil.getChild(entity,""String_Node_Str"",StringTag.class);
                IntTag xTag=NbtUtil.getChild(entity,""String_Node_Str"",IntTag.class);
                IntTag yTag=NbtUtil.getChild(entity,""String_Node_Str"",IntTag.class);
                IntTag zTag=NbtUtil.getChild(entity,""String_Node_Str"",IntTag.class);
                ByteTag dir=NbtUtil.getChild(entity,""String_Node_Str"",ByteTag.class);
                boolean is18=false;
                if (dir == null) {
                  dir=NbtUtil.getChild(entity,""String_Node_Str"",ByteTag.class);
                  is18=true;
                }
                int x=xTag.getValue();
                final int y=yTag.getValue();
                int z=zTag.getValue();
                if (is18 && dir.getValue() == 0) {
                  z=zTag.getValue() - 1;
                }
 else                 if (is18 && dir.getValue() == 1) {
                  x=xTag.getValue() + 1;
                }
 else                 if (is18 && dir.getValue() == 2) {
                  z=zTag.getValue() + 1;
                }
 else                 if (is18 && dir.getValue() == 3) {
                  x=xTag.getValue() - 1;
                }
                final int localX=x - (blockX * WIDTH);
                final int localY=y - (blockY * HEIGHT);
                final int localZ=z - (blockZ * DEPTH);
                paintings.add(new TileEntity(-1,0,x,y,z,localX,localY,localZ,motiveTag.getValue(),dir.getValue()));
              }
 else               if (idTag.getValue().equals(""String_Node_Str"")) {
                IntTag xTag=NbtUtil.getChild(entity,""String_Node_Str"",IntTag.class);
                IntTag yTag=NbtUtil.getChild(entity,""String_Node_Str"",IntTag.class);
                IntTag zTag=NbtUtil.getChild(entity,""String_Node_Str"",IntTag.class);
                ByteTag dir=NbtUtil.getChild(entity,""String_Node_Str"",ByteTag.class);
                boolean is18=false;
                if (dir == null) {
                  dir=NbtUtil.getChild(entity,""String_Node_Str"",ByteTag.class);
                  is18=true;
                }
                String item=""String_Node_Str"";
                Map<String,Tag> map=entity.getValue();
                CompoundTag itemTag=(CompoundTag)map.get(""String_Node_Str"");
                if (itemTag != null) {
                  ShortTag itemIdTag=NbtUtil.getChild(itemTag,""String_Node_Str"",ShortTag.class);
                  if (itemIdTag == null) {
                    StringTag stringItemIdTag=NbtUtil.getChild(itemTag,""String_Node_Str"",StringTag.class);
                    item=stringItemIdTag.getValue();
                  }
 else {
                    if (itemIdTag.getValue() == 358)                     item=""String_Node_Str"";
                  }
                }
                int x=xTag.getValue();
                final int y=yTag.getValue();
                int z=zTag.getValue();
                if (is18 && dir.getValue() == 0) {
                  z=zTag.getValue() - 1;
                }
 else                 if (is18 && dir.getValue() == 1) {
                  x=xTag.getValue() + 1;
                }
 else                 if (is18 && dir.getValue() == 2) {
                  z=zTag.getValue() + 1;
                }
 else                 if (is18 && dir.getValue() == 3) {
                  x=xTag.getValue() - 1;
                }
                final int localX=x - (blockX * WIDTH);
                final int localY=y - (blockY * HEIGHT);
                final int localZ=z - (blockZ * DEPTH);
                itemFrames.add(new TileEntity(-2,0,x,y,z,localX,localY,localZ,item,dir.getValue()));
              }
            }
          }
        }
        ListTag tileEntitiesTag=NbtUtil.getChild(level,""String_Node_Str"",ListTag.class);
        if (tileEntitiesTag != null) {
          for (          Tag t : tileEntitiesTag.getValue()) {
            if (t instanceof CompoundTag) {
              CompoundTag entity=(CompoundTag)t;
              StringTag idTag=NbtUtil.getChild(entity,""String_Node_Str"",StringTag.class);
              IntTag xTag=NbtUtil.getChild(entity,""String_Node_Str"",IntTag.class);
              IntTag yTag=NbtUtil.getChild(entity,""String_Node_Str"",IntTag.class);
              IntTag zTag=NbtUtil.getChild(entity,""String_Node_Str"",IntTag.class);
              if (idTag != null && xTag != null && yTag != null && zTag != null) {
                String id=idTag.getValue();
                if (id.equals(""String_Node_Str"")) {
                  StringTag text1Tag=NbtUtil.getChild(entity,""String_Node_Str"",StringTag.class);
                  StringTag text2Tag=NbtUtil.getChild(entity,""String_Node_Str"",StringTag.class);
                  StringTag text3Tag=NbtUtil.getChild(entity,""String_Node_Str"",StringTag.class);
                  StringTag text4Tag=NbtUtil.getChild(entity,""String_Node_Str"",StringTag.class);
                  String text1=text1Tag.getValue().replaceAll(""String_Node_Str"",""String_Node_Str"");
                  if (text1 == null || text1.equals(""String_Node_Str""))                   text1=""String_Node_Str"";
                  String text2=text2Tag.getValue().replaceAll(""String_Node_Str"",""String_Node_Str"");
                  if (text2 == null || text2.equals(""String_Node_Str""))                   text2=""String_Node_Str"";
                  String text3=text3Tag.getValue().replaceAll(""String_Node_Str"",""String_Node_Str"");
                  if (text3 == null || text3.equals(""String_Node_Str""))                   text3=""String_Node_Str"";
                  String text4=text4Tag.getValue().replaceAll(""String_Node_Str"",""String_Node_Str"");
                  if (text4 == null || text4.equals(""String_Node_Str""))                   text4=""String_Node_Str"";
                  final int x=xTag.getValue();
                  final int y=yTag.getValue();
                  final int z=zTag.getValue();
                  final int localX=x - (blockX * WIDTH);
                  final int localY=y - (blockY * HEIGHT);
                  final int localZ=z - (blockZ * DEPTH);
                  final int blockId=getBlockId(localX,localY,localZ);
                  final int data=getBlockData(localX,localY,localZ);
                  signs.add(new RawSign(blockId,data,x,y,z,localX,localY,localZ,text1,text2,text3,text4));
                }
 else                 if (id.equals(""String_Node_Str"")) {
                  IntTag dataTag=NbtUtil.getChild(entity,""String_Node_Str"",IntTag.class);
                  IntTag itemTag=NbtUtil.getChild(entity,""String_Node_Str"",IntTag.class);
                  final int item;
                  if (itemTag == null) {
                    StringTag stringIdTag=NbtUtil.getChild(entity,""String_Node_Str"",StringTag.class);
                    if (stringIdTag.getValue().equals(""String_Node_Str""))                     item=6;
 else                     if (stringIdTag.getValue().equals(""String_Node_Str""))                     item=38;
 else                     item=0;
                  }
 else {
                    item=itemTag.getValue();
                  }
                  final int x=xTag.getValue();
                  final int y=yTag.getValue();
                  final int z=zTag.getValue();
                  final int localX=x - (blockX * WIDTH);
                  final int localY=y - (blockY * HEIGHT);
                  final int localZ=z - (blockZ * DEPTH);
                  final int blockData=getBlockData(localX,localY,localZ);
                  final int itemData=dataTag.getValue();
                  flowerPots.add(new TileEntity(0,blockData,x,y,z,localX,localY,localZ,itemData,item));
                }
 else                 if (id.equals(""String_Node_Str"")) {
                  ByteTag skullType=NbtUtil.getChild(entity,""String_Node_Str"",ByteTag.class);
                  ByteTag rot=NbtUtil.getChild(entity,""String_Node_Str"",ByteTag.class);
                  StringTag nameTag=null;
                  StringTag playerId=null;
                  String name=""String_Node_Str"";
                  String UUID=""String_Node_Str"";
                  String textureURL=""String_Node_Str"";
                  StringTag extraType=NbtUtil.getChild(entity,""String_Node_Str"",StringTag.class);
                  CompoundTag owner=NbtUtil.getChild(entity,""String_Node_Str"",CompoundTag.class);
                  if (owner != null) {
                    nameTag=NbtUtil.getChild(owner,""String_Node_Str"",StringTag.class);
                    name=nameTag.getValue();
                    playerId=NbtUtil.getChild(owner,""String_Node_Str"",StringTag.class);
                    UUID=playerId.getValue().replace(""String_Node_Str"",""String_Node_Str"");
                    CompoundTag properties=NbtUtil.getChild(owner,""String_Node_Str"",CompoundTag.class);
                    ListTag textures=NbtUtil.getChild(properties,""String_Node_Str"",ListTag.class);
                    CompoundTag tex=NbtUtil.getChild(textures,0,CompoundTag.class);
                    StringTag value=NbtUtil.getChild(tex,""String_Node_Str"",StringTag.class);
                    byte[] decoded=DatatypeConverter.parseBase64Binary(value.getValue());
                    JSONObject obj=new JSONObject(new String(decoded,""String_Node_Str""));
                    textureURL=obj.getJSONObject(""String_Node_Str"").getJSONObject(""String_Node_Str"").getString(""String_Node_Str"");
                  }
 else                   if (extraType != null && !(extraType.getValue().equals(""String_Node_Str""))) {
                    name=UUID=extraType.getValue();
                    textureURL=""String_Node_Str"" + extraType.getValue() + ""String_Node_Str"";
                    System.out.println(textureURL);
                  }
                  final int x=xTag.getValue();
                  final int y=yTag.getValue();
                  final int z=zTag.getValue();
                  final int localX=x - (blockX * WIDTH);
                  final int localY=y - (blockY * HEIGHT);
                  final int localZ=z - (blockZ * DEPTH);
                  skulls.add(new TileEntity(skullType.getValue(),rot.getValue(),x,y,z,localX,localY,localZ,name,UUID,textureURL,null));
                }
 else                 if (id.equals(""String_Node_Str"")) {
                  IntTag levels=NbtUtil.getChild(entity,""String_Node_Str"",IntTag.class);
                  final int x=xTag.getValue();
                  final int y=yTag.getValue();
                  final int z=zTag.getValue();
                  final int localX=x - (blockX * WIDTH);
                  final int localY=y - (blockY * HEIGHT);
                  final int localZ=z - (blockZ * DEPTH);
                  beacons.add(new TileEntity(0,levels.getValue(),x,y,z,localX,localY,localZ,0,0));
                }
 else                 if (id.equals(""String_Node_Str"")) {
                  IntTag base=NbtUtil.getChild(entity,""String_Node_Str"",IntTag.class);
                  final int x=xTag.getValue();
                  final int y=yTag.getValue();
                  final int z=zTag.getValue();
                  final int localX=x - (blockX * WIDTH);
                  final int localY=y - (blockY * HEIGHT);
                  final int localZ=z - (blockZ * DEPTH);
                  banners.add(new TileEntity(0,base.getValue(),x,y,z,localX,localY,localZ,0,0));
                }
              }
            }
          }
        }
      }
    }
  }
  finally {
    if (nbtIn != null)     nbtIn.close();
    if (in != null)     in.close();
  }
}","private void init(InputStream in,Compression compression) throws Exception {
  clear();
  NBTInputStream nbtIn=null;
  try {
    nbtIn=new NBTInputStream(in,compression);
    Tag tag=nbtIn.readTag();
    if (tag instanceof CompoundTag) {
      CompoundTag root=(CompoundTag)tag;
      CompoundTag level=NbtUtil.getChild(root,""String_Node_Str"",CompoundTag.class);
      if (level != null) {
        blockX=blockY=blockZ=0;
        IntTag xPosTag=NbtUtil.getChild(level,""String_Node_Str"",IntTag.class);
        if (xPosTag != null)         blockX=xPosTag.getValue().intValue();
        IntTag zPosTag=NbtUtil.getChild(level,""String_Node_Str"",IntTag.class);
        if (zPosTag != null)         blockZ=zPosTag.getValue().intValue();
        ListTag sections=NbtUtil.getChild(level,""String_Node_Str"",ListTag.class);
        if (sections != null) {
          parseAnvilData(level);
        }
 else {
          parseMcRegionData(level);
        }
        ListTag entitiesTag=NbtUtil.getChild(level,""String_Node_Str"",ListTag.class);
        if (entitiesTag != null) {
          for (          Tag t : entitiesTag.getValue()) {
            if (t instanceof CompoundTag) {
              CompoundTag entity=(CompoundTag)t;
              StringTag idTag=NbtUtil.getChild(entity,""String_Node_Str"",StringTag.class);
              if (idTag.getValue().endsWith(""String_Node_Str"")) {
                StringTag motiveTag=NbtUtil.getChild(entity,""String_Node_Str"",StringTag.class);
                IntTag xTag=NbtUtil.getChild(entity,""String_Node_Str"",IntTag.class);
                IntTag yTag=NbtUtil.getChild(entity,""String_Node_Str"",IntTag.class);
                IntTag zTag=NbtUtil.getChild(entity,""String_Node_Str"",IntTag.class);
                ByteTag dir=NbtUtil.getChild(entity,""String_Node_Str"",ByteTag.class);
                boolean is18=false;
                if (dir == null) {
                  dir=NbtUtil.getChild(entity,""String_Node_Str"",ByteTag.class);
                  is18=true;
                }
                int x=xTag.getValue();
                final int y=yTag.getValue();
                int z=zTag.getValue();
                if (is18 && dir.getValue() == 0) {
                  z=zTag.getValue() - 1;
                }
 else                 if (is18 && dir.getValue() == 1) {
                  x=xTag.getValue() + 1;
                }
 else                 if (is18 && dir.getValue() == 2) {
                  z=zTag.getValue() + 1;
                }
 else                 if (is18 && dir.getValue() == 3) {
                  x=xTag.getValue() - 1;
                }
                final int localX=x - (blockX * WIDTH);
                final int localY=y - (blockY * HEIGHT);
                final int localZ=z - (blockZ * DEPTH);
                paintings.add(new TileEntity(-1,0,x,y,z,localX,localY,localZ,motiveTag.getValue(),dir.getValue()));
              }
 else               if (idTag.getValue().equals(""String_Node_Str"")) {
                IntTag xTag=NbtUtil.getChild(entity,""String_Node_Str"",IntTag.class);
                IntTag yTag=NbtUtil.getChild(entity,""String_Node_Str"",IntTag.class);
                IntTag zTag=NbtUtil.getChild(entity,""String_Node_Str"",IntTag.class);
                ByteTag dir=NbtUtil.getChild(entity,""String_Node_Str"",ByteTag.class);
                boolean is18=false;
                if (dir == null) {
                  dir=NbtUtil.getChild(entity,""String_Node_Str"",ByteTag.class);
                  is18=true;
                }
                String item=""String_Node_Str"";
                Map<String,Tag> map=entity.getValue();
                CompoundTag itemTag=(CompoundTag)map.get(""String_Node_Str"");
                if (itemTag != null) {
                  ShortTag itemIdTag=NbtUtil.getChild(itemTag,""String_Node_Str"",ShortTag.class);
                  if (itemIdTag == null) {
                    StringTag stringItemIdTag=NbtUtil.getChild(itemTag,""String_Node_Str"",StringTag.class);
                    item=stringItemIdTag.getValue();
                  }
 else {
                    if (itemIdTag.getValue() == 358)                     item=""String_Node_Str"";
                  }
                }
                int x=xTag.getValue();
                final int y=yTag.getValue();
                int z=zTag.getValue();
                if (is18 && dir.getValue() == 0) {
                  z=zTag.getValue() - 1;
                }
 else                 if (is18 && dir.getValue() == 1) {
                  x=xTag.getValue() + 1;
                }
 else                 if (is18 && dir.getValue() == 2) {
                  z=zTag.getValue() + 1;
                }
 else                 if (is18 && dir.getValue() == 3) {
                  x=xTag.getValue() - 1;
                }
                final int localX=x - (blockX * WIDTH);
                final int localY=y - (blockY * HEIGHT);
                final int localZ=z - (blockZ * DEPTH);
                itemFrames.add(new TileEntity(-2,0,x,y,z,localX,localY,localZ,item,dir.getValue()));
              }
            }
          }
        }
        ListTag tileEntitiesTag=NbtUtil.getChild(level,""String_Node_Str"",ListTag.class);
        if (tileEntitiesTag != null) {
          for (          Tag t : tileEntitiesTag.getValue()) {
            if (t instanceof CompoundTag) {
              CompoundTag entity=(CompoundTag)t;
              StringTag idTag=NbtUtil.getChild(entity,""String_Node_Str"",StringTag.class);
              IntTag xTag=NbtUtil.getChild(entity,""String_Node_Str"",IntTag.class);
              IntTag yTag=NbtUtil.getChild(entity,""String_Node_Str"",IntTag.class);
              IntTag zTag=NbtUtil.getChild(entity,""String_Node_Str"",IntTag.class);
              if (idTag != null && xTag != null && yTag != null && zTag != null) {
                String id=idTag.getValue();
                if (id.equals(""String_Node_Str"")) {
                  StringTag text1Tag=NbtUtil.getChild(entity,""String_Node_Str"",StringTag.class);
                  StringTag text2Tag=NbtUtil.getChild(entity,""String_Node_Str"",StringTag.class);
                  StringTag text3Tag=NbtUtil.getChild(entity,""String_Node_Str"",StringTag.class);
                  StringTag text4Tag=NbtUtil.getChild(entity,""String_Node_Str"",StringTag.class);
                  String text1=text1Tag.getValue().replaceAll(""String_Node_Str"",""String_Node_Str"");
                  if (text1 == null || text1.equals(""String_Node_Str""))                   text1=""String_Node_Str"";
                  String text2=text2Tag.getValue().replaceAll(""String_Node_Str"",""String_Node_Str"");
                  if (text2 == null || text2.equals(""String_Node_Str""))                   text2=""String_Node_Str"";
                  String text3=text3Tag.getValue().replaceAll(""String_Node_Str"",""String_Node_Str"");
                  if (text3 == null || text3.equals(""String_Node_Str""))                   text3=""String_Node_Str"";
                  String text4=text4Tag.getValue().replaceAll(""String_Node_Str"",""String_Node_Str"");
                  if (text4 == null || text4.equals(""String_Node_Str""))                   text4=""String_Node_Str"";
                  final int x=xTag.getValue();
                  final int y=yTag.getValue();
                  final int z=zTag.getValue();
                  final int localX=x - (blockX * WIDTH);
                  final int localY=y - (blockY * HEIGHT);
                  final int localZ=z - (blockZ * DEPTH);
                  final int blockId=getBlockId(localX,localY,localZ);
                  final int data=getBlockData(localX,localY,localZ);
                  signs.add(new RawSign(blockId,data,x,y,z,localX,localY,localZ,text1,text2,text3,text4));
                }
 else                 if (id.equals(""String_Node_Str"")) {
                  IntTag dataTag=NbtUtil.getChild(entity,""String_Node_Str"",IntTag.class);
                  IntTag itemTag=NbtUtil.getChild(entity,""String_Node_Str"",IntTag.class);
                  final int item;
                  if (itemTag == null) {
                    StringTag stringIdTag=NbtUtil.getChild(entity,""String_Node_Str"",StringTag.class);
                    if (stringIdTag.getValue().equals(""String_Node_Str""))                     item=6;
 else                     if (stringIdTag.getValue().equals(""String_Node_Str""))                     item=38;
 else                     item=0;
                  }
 else {
                    item=itemTag.getValue();
                  }
                  final int x=xTag.getValue();
                  final int y=yTag.getValue();
                  final int z=zTag.getValue();
                  final int localX=x - (blockX * WIDTH);
                  final int localY=y - (blockY * HEIGHT);
                  final int localZ=z - (blockZ * DEPTH);
                  final int blockData=getBlockData(localX,localY,localZ);
                  final int itemData=dataTag.getValue();
                  flowerPots.add(new TileEntity(0,blockData,x,y,z,localX,localY,localZ,itemData,item));
                }
 else                 if (id.equals(""String_Node_Str"")) {
                  ByteTag skullType=NbtUtil.getChild(entity,""String_Node_Str"",ByteTag.class);
                  ByteTag rot=NbtUtil.getChild(entity,""String_Node_Str"",ByteTag.class);
                  StringTag nameTag=null;
                  StringTag playerId=null;
                  String name=""String_Node_Str"";
                  String UUID=""String_Node_Str"";
                  String textureURL=""String_Node_Str"";
                  StringTag extraType=NbtUtil.getChild(entity,""String_Node_Str"",StringTag.class);
                  CompoundTag owner=NbtUtil.getChild(entity,""String_Node_Str"",CompoundTag.class);
                  if (owner != null) {
                    nameTag=NbtUtil.getChild(owner,""String_Node_Str"",StringTag.class);
                    name=nameTag.getValue();
                    playerId=NbtUtil.getChild(owner,""String_Node_Str"",StringTag.class);
                    UUID=playerId.getValue().replace(""String_Node_Str"",""String_Node_Str"");
                    CompoundTag properties=NbtUtil.getChild(owner,""String_Node_Str"",CompoundTag.class);
                    ListTag textures=NbtUtil.getChild(properties,""String_Node_Str"",ListTag.class);
                    CompoundTag tex=NbtUtil.getChild(textures,0,CompoundTag.class);
                    StringTag value=NbtUtil.getChild(tex,""String_Node_Str"",StringTag.class);
                    byte[] decoded=DatatypeConverter.parseBase64Binary(value.getValue());
                    JSONObject obj=new JSONObject(new String(decoded,""String_Node_Str""));
                    textureURL=obj.getJSONObject(""String_Node_Str"").getJSONObject(""String_Node_Str"").getString(""String_Node_Str"");
                  }
 else                   if (extraType != null && !(extraType.getValue().equals(""String_Node_Str""))) {
                    name=UUID=extraType.getValue();
                    textureURL=""String_Node_Str"" + extraType.getValue() + ""String_Node_Str"";
                  }
                  final int x=xTag.getValue();
                  final int y=yTag.getValue();
                  final int z=zTag.getValue();
                  final int localX=x - (blockX * WIDTH);
                  final int localY=y - (blockY * HEIGHT);
                  final int localZ=z - (blockZ * DEPTH);
                  skulls.add(new TileEntity(skullType.getValue(),rot.getValue(),x,y,z,localX,localY,localZ,name,UUID,textureURL,null));
                }
 else                 if (id.equals(""String_Node_Str"")) {
                  IntTag levels=NbtUtil.getChild(entity,""String_Node_Str"",IntTag.class);
                  final int x=xTag.getValue();
                  final int y=yTag.getValue();
                  final int z=zTag.getValue();
                  final int localX=x - (blockX * WIDTH);
                  final int localY=y - (blockY * HEIGHT);
                  final int localZ=z - (blockZ * DEPTH);
                  beacons.add(new TileEntity(0,levels.getValue(),x,y,z,localX,localY,localZ,0,0));
                }
 else                 if (id.equals(""String_Node_Str"")) {
                  IntTag base=NbtUtil.getChild(entity,""String_Node_Str"",IntTag.class);
                  final int x=xTag.getValue();
                  final int y=yTag.getValue();
                  final int z=zTag.getValue();
                  final int localX=x - (blockX * WIDTH);
                  final int localY=y - (blockY * HEIGHT);
                  final int localZ=z - (blockZ * DEPTH);
                  banners.add(new TileEntity(0,base.getValue(),x,y,z,localX,localY,localZ,0,0));
                }
              }
            }
          }
        }
      }
    }
  }
  finally {
    if (nbtIn != null)     nbtIn.close();
    if (in != null)     in.close();
  }
}",0.9979733416478292
80088,"public static ArrayList<Player> loadPlayers(File worldDir,PlayerSkinCache playerSkinCache){
  File playersDir=Minecraft.findPlayersDir(worldDir);
  System.out.println(""String_Node_Str"" + playersDir.getAbsolutePath());
  ArrayList<Player> players=new ArrayList<Player>();
  File[] playerFiles=playersDir.listFiles();
  if (playerFiles != null) {
    for (    File playerFile : playerFiles) {
      if (playerFile.getName().endsWith(""String_Node_Str"")) {
        try {
          Player player=new Player(playerFile);
          CacheEntry ce=playerSkinCache.getCacheEntry(player.getUUID());
          if (ce != null) {
            final long age=System.currentTimeMillis() - ce.fetchedTime;
            if (age < 1000 * 60 * 60* 60) {
              player.setName(ce.playerName);
              player.setSkinURL(ce.skinURL);
            }
          }
 else {
            if (player.getUUID().equals(player.getName())) {
              player.setSkinURL(""String_Node_Str"" + player.getName() + ""String_Node_Str"");
            }
 else {
              String urlString=""String_Node_Str"" + player.getUUID();
              URL url=new URL(urlString);
              HttpURLConnection connection=(HttpURLConnection)url.openConnection();
              connection.setRequestMethod(""String_Node_Str"");
              connection.addRequestProperty(""String_Node_Str"",""String_Node_Str"");
              connection.setReadTimeout(15 * 1000);
              connection.connect();
              BufferedReader reader=new BufferedReader(new InputStreamReader(connection.getInputStream()));
              StringBuilder builder=new StringBuilder();
              String line=null;
              while ((line=reader.readLine()) != null) {
                builder.append(line + ""String_Node_Str"");
              }
              reader.close();
              JSONObject obj=new JSONObject(builder.toString());
              player.setName(obj.getString(""String_Node_Str""));
              JSONObject textures=obj.getJSONArray(""String_Node_Str"").getJSONObject(0);
              byte[] decoded=DatatypeConverter.parseBase64Binary(textures.get(""String_Node_Str"").toString());
              obj=new JSONObject(new String(decoded,""String_Node_Str""));
              String textureUrl=obj.getJSONObject(""String_Node_Str"").getJSONObject(""String_Node_Str"").getString(""String_Node_Str"");
              player.setSkinURL(textureUrl);
            }
          }
          players.add(player);
          System.out.println(""String_Node_Str"" + player.getName());
        }
 catch (        Exception e) {
          System.err.println(""String_Node_Str"" + playerFile.getName());
          e.printStackTrace();
        }
      }
    }
  }
  System.out.println(""String_Node_Str"" + players.size() + ""String_Node_Str"");
  return players;
}","public static ArrayList<Player> loadPlayers(File worldDir,PlayerSkinCache playerSkinCache){
  File playersDir=Minecraft.findPlayersDir(worldDir);
  System.out.println(""String_Node_Str"" + playersDir.getAbsolutePath());
  ArrayList<Player> players=new ArrayList<Player>();
  File[] playerFiles=playersDir.listFiles();
  if (playerFiles != null) {
    for (    File playerFile : playerFiles) {
      if (playerFile.getName().endsWith(""String_Node_Str"")) {
        try {
          Player player=new Player(playerFile);
          CacheEntry ce=playerSkinCache.getCacheEntry(player.getUUID());
          if (ce != null) {
            final long age=System.currentTimeMillis() - ce.fetchedTime;
            if (age < 1000 * 60 * 60* 60) {
              player.setName(ce.playerName);
              player.setSkinURL(ce.skinURL);
            }
          }
 else {
            if (player.getUUID().equals(player.getName())) {
              player.setSkinURL(""String_Node_Str"" + player.getName() + ""String_Node_Str"");
            }
 else {
              String urlString=""String_Node_Str"" + player.getUUID();
              URL url=new URL(urlString);
              HttpURLConnection connection=(HttpURLConnection)url.openConnection();
              connection.setRequestMethod(""String_Node_Str"");
              connection.addRequestProperty(""String_Node_Str"",""String_Node_Str"");
              connection.setReadTimeout(15 * 1000);
              connection.connect();
              BufferedReader reader=new BufferedReader(new InputStreamReader(connection.getInputStream()));
              StringBuilder builder=new StringBuilder();
              String line=null;
              while ((line=reader.readLine()) != null) {
                builder.append(line + ""String_Node_Str"");
              }
              reader.close();
              JSONObject obj=new JSONObject(builder.toString());
              player.setName(obj.getString(""String_Node_Str""));
              JSONObject textures=obj.getJSONArray(""String_Node_Str"").getJSONObject(0);
              byte[] decoded=DatatypeConverter.parseBase64Binary(textures.get(""String_Node_Str"").toString());
              obj=new JSONObject(new String(decoded,""String_Node_Str""));
              boolean hasSkin=obj.getJSONObject(""String_Node_Str"").has(""String_Node_Str"");
              String textureUrl=null;
              if (hasSkin == true)               textureUrl=obj.getJSONObject(""String_Node_Str"").getJSONObject(""String_Node_Str"").getString(""String_Node_Str"");
              player.setSkinURL(textureUrl);
            }
          }
          players.add(player);
          System.out.println(""String_Node_Str"" + player.getName());
        }
 catch (        Exception e) {
          System.err.println(""String_Node_Str"" + playerFile.getName());
          System.err.println(""String_Node_Str"");
        }
      }
    }
  }
  System.out.println(""String_Node_Str"" + players.size() + ""String_Node_Str"");
  return players;
}",0.9573690621193668
80089,"public Result output() throws LWJGLException {
  progressListener.onTaskStarted(Task.StartingRenderer.toString());
  System.out.println(""String_Node_Str"");
  Date startTime=new Date();
  FileUtils.ensureExists(exportDir);
  FileUtils.ensureExists(args.cacheDir());
  TempArea tempArea=new TempArea(new File(args.cacheDir(),""String_Node_Str""));
  changedFileList=new ChangeFile(new File(args.outputDir(),""String_Node_Str""));
  for (  tectonicus.configuration.Map map : args.getMaps()) {
    File mapDir=new File(exportDir,map.getId());
    FileUtils.ensureExists(mapDir);
    BiomeCache biomeCache=CacheUtil.createBiomeCache(args.minecraftJar(),args.cacheDir(),map,hashAlgorithm);
    WorldSubsetFactory subset=map.getWorldSubsetFactory();
    World world=new World(rasteriser,map.getWorldDir(),map.getDimension(),args.minecraftJar(),args.texturePack(),biomeCache,hashAlgorithm,args.getSinglePlayerName(),subset);
    setupInitialCamera(map);
    WorldVectors worldVectors=calcWorldVectors();
    File portalsFile=tempArea.generateTempFile(""String_Node_Str"",""String_Node_Str"");
    File signsFile=tempArea.generateTempFile(""String_Node_Str"",""String_Node_Str"");
    File viewsFile=tempArea.generateTempFile(""String_Node_Str"",""String_Node_Str"");
    WorldStats worldStats=preProcess(world,map.getDimension(),map.getSignFilter(),map.getPortalFilter(),map.getViewFilter(),portalsFile,signsFile,viewsFile);
    HddTileList visibleTiles=findVisibleTiles(world,camera,worldStats.numChunks());
    System.out.println(""String_Node_Str"");
    progressListener.onTaskStarted(Task.FindChangedTiles.toString());
    outputCompass(new File(mapDir,""String_Node_Str""),map,world.getBlockTypeRegistry(),world.getTexturePack());
    outputSigns(new File(mapDir,""String_Node_Str""),signsFile,map);
    outputPlayers(new File(mapDir,""String_Node_Str""),new File(exportDir,""String_Node_Str""),map,map.getPlayerFilter(),world.players(map.getDimension()),world.getOps(),playerIconAssembler);
    outputBeds(mapDir,map,map.getPlayerFilter(),world.players(null),world.getOps());
    outputPortals(new File(mapDir,""String_Node_Str""),portalsFile,map);
    outputViews(new File(mapDir,""String_Node_Str""),viewsFile,map,map.getViewConfig().getImageFormat());
    worldStats.outputBlockStats(new File(mapDir,""String_Node_Str""),map.getId(),world.getBlockTypeRegistry());
    worldStats.outputWorldStats(new File(mapDir,""String_Node_Str""),map.getId());
    FileViewCache viewCache=createViewCache(args.cacheDir(),map,tempArea,hashAlgorithm,regionHashStore);
    ViewRenderer viewRenderer=new ViewRenderer(rasteriser,viewCache,args.getNumDownsampleThreads(),map.getViewConfig());
    viewRenderer.output(world,mapDir,viewsFile,changedFileList);
    TileCoordBounds bounds=null;
    for (    Layer layer : map.getLayers()) {
      setupWorldForLayer(layer,world);
      String optionString=FileTileCache.calcOptionsString(args);
      TileCache tileCache=createTileCache(args.useCache(),optionString,layer.getImageFormat(),args.cacheDir(),map,layer,hashAlgorithm);
      File baseTilesDir=DirUtils.getZoomDir(exportDir,layer,numZoomLevels);
      FileUtils.ensureExists(baseTilesDir);
      HddTileList changedTiles=tileCache.findChangedTiles(hddTileListFactory,visibleTiles,regionHashStore,world,map,camera,map.getClosestZoomSize(),tileWidth,tileHeight,baseTilesDir);
      changedTiles=trimTileList(changedTiles,args.maxTiles());
      renderBaseTiles(world,map,layer.getImageFormat(),layer.getImageCompressionLevel(),baseTilesDir,changedTiles,tileCache);
      bounds=downsample(changedTiles,exportDir,layer,baseTilesDir,tileCache);
    }
    outputWorldVectors(new File(mapDir,""String_Node_Str""),map.getId(),worldVectors,bounds,world.getLevelDat(),worldStats.numChunks(),world.numPlayers());
  }
  outputHtmlResources(new TexturePack(rasteriser,args.minecraftJar(),args.texturePack()),playerIconAssembler);
  outputContents(new File(new File(exportDir,""String_Node_Str""),""String_Node_Str""),args);
  final File outputHtmlFile=outputHtml();
  Date endTime=new Date();
  String time=Util.getElapsedTime(startTime,endTime);
  outputRenderStats(time);
  outputChangedFile();
  System.out.println(""String_Node_Str"" + time);
  return new Result(abort,outputHtmlFile);
}","public Result output() throws LWJGLException {
  progressListener.onTaskStarted(Task.StartingRenderer.toString());
  System.out.println(""String_Node_Str"");
  Date startTime=new Date();
  FileUtils.ensureExists(exportDir);
  FileUtils.ensureExists(args.cacheDir());
  TempArea tempArea=new TempArea(new File(args.cacheDir(),""String_Node_Str""));
  changedFileList=new ChangeFile(new File(args.outputDir(),""String_Node_Str""));
  for (  tectonicus.configuration.Map map : args.getMaps()) {
    File mapDir=new File(exportDir,map.getId());
    FileUtils.ensureExists(mapDir);
    BiomeCache biomeCache=CacheUtil.createBiomeCache(args.minecraftJar(),args.cacheDir(),map,hashAlgorithm);
    WorldSubsetFactory subset=map.getWorldSubsetFactory();
    World world=new World(rasteriser,map.getWorldDir(),map.getDimension(),args.minecraftJar(),args.texturePack(),biomeCache,hashAlgorithm,args.getSinglePlayerName(),subset);
    setupInitialCamera(map);
    WorldVectors worldVectors=calcWorldVectors();
    File portalsFile=tempArea.generateTempFile(""String_Node_Str"",""String_Node_Str"");
    File signsFile=tempArea.generateTempFile(""String_Node_Str"",""String_Node_Str"");
    File viewsFile=tempArea.generateTempFile(""String_Node_Str"",""String_Node_Str"");
    WorldStats worldStats=preProcess(world,map.getDimension(),map.getSignFilter(),map.getPortalFilter(),map.getViewFilter(),portalsFile,signsFile,viewsFile);
    HddTileList visibleTiles=findVisibleTiles(world,camera,worldStats.numChunks());
    System.out.println(""String_Node_Str"");
    progressListener.onTaskStarted(Task.FindChangedTiles.toString());
    outputCompass(new File(mapDir,""String_Node_Str""),map,world.getBlockTypeRegistry(),world.getTexturePack());
    outputSigns(new File(mapDir,""String_Node_Str""),signsFile,map);
    outputPlayers(new File(mapDir,""String_Node_Str""),new File(exportDir,""String_Node_Str""),map,map.getPlayerFilter(),world.players(map.getDimension()),world.getOps(),playerIconAssembler);
    outputBeds(mapDir,map,map.getPlayerFilter(),world.players(null),world.getOps());
    worldStats.setNumPortals((outputPortals(new File(mapDir,""String_Node_Str""),portalsFile,map)));
    outputViews(new File(mapDir,""String_Node_Str""),viewsFile,map,map.getViewConfig().getImageFormat());
    worldStats.outputBlockStats(new File(mapDir,""String_Node_Str""),map.getId(),world.getBlockTypeRegistry());
    worldStats.outputWorldStats(new File(mapDir,""String_Node_Str""),map.getId());
    FileViewCache viewCache=createViewCache(args.cacheDir(),map,tempArea,hashAlgorithm,regionHashStore);
    ViewRenderer viewRenderer=new ViewRenderer(rasteriser,viewCache,args.getNumDownsampleThreads(),map.getViewConfig());
    viewRenderer.output(world,mapDir,viewsFile,changedFileList);
    TileCoordBounds bounds=null;
    for (    Layer layer : map.getLayers()) {
      setupWorldForLayer(layer,world);
      String optionString=FileTileCache.calcOptionsString(args);
      TileCache tileCache=createTileCache(args.useCache(),optionString,layer.getImageFormat(),args.cacheDir(),map,layer,hashAlgorithm);
      File baseTilesDir=DirUtils.getZoomDir(exportDir,layer,numZoomLevels);
      FileUtils.ensureExists(baseTilesDir);
      HddTileList changedTiles=tileCache.findChangedTiles(hddTileListFactory,visibleTiles,regionHashStore,world,map,camera,map.getClosestZoomSize(),tileWidth,tileHeight,baseTilesDir);
      changedTiles=trimTileList(changedTiles,args.maxTiles());
      renderBaseTiles(world,map,layer.getImageFormat(),layer.getImageCompressionLevel(),baseTilesDir,changedTiles,tileCache);
      bounds=downsample(changedTiles,exportDir,layer,baseTilesDir,tileCache);
    }
    outputWorldVectors(new File(mapDir,""String_Node_Str""),map.getId(),worldVectors,bounds,world.getLevelDat(),worldStats.numChunks(),world.numPlayers());
  }
  outputHtmlResources(new TexturePack(rasteriser,args.minecraftJar(),args.texturePack()),playerIconAssembler);
  outputContents(new File(new File(exportDir,""String_Node_Str""),""String_Node_Str""),args);
  final File outputHtmlFile=outputHtml();
  Date endTime=new Date();
  String time=Util.getElapsedTime(startTime,endTime);
  outputRenderStats(time);
  outputChangedFile();
  System.out.println(""String_Node_Str"" + time);
  return new Result(abort,outputHtmlFile);
}",0.9952830188679244
80090,"private void outputPortals(File portalFile,HddObjectListReader<Portal> portalPositions,tectonicus.configuration.Map map){
  System.out.println(""String_Node_Str"");
  if (portalFile.exists())   portalFile.delete();
  JsArrayWriter jsWriter=null;
  try {
    jsWriter=new JsArrayWriter(portalFile,map.getId() + ""String_Node_Str"");
    Portal portal=new Portal();
    while (portalPositions.hasNext()) {
      portalPositions.read(portal);
      HashMap<String,String> args=new HashMap<String,String>();
      final float worldX=portal.getX() + 0.5f;
      final float worldY=portal.getY();
      final float worldZ=portal.getZ() + 0.5f;
      String posStr=""String_Node_Str"" + worldX + ""String_Node_Str""+ worldY+ ""String_Node_Str""+ worldZ+ ""String_Node_Str"";
      args.put(""String_Node_Str"",posStr);
      jsWriter.write(args);
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
 finally {
    if (jsWriter != null)     jsWriter.close();
  }
}","private int outputPortals(File portalFile,HddObjectListReader<Portal> portalPositions,tectonicus.configuration.Map map){
  System.out.println(""String_Node_Str"");
  if (portalFile.exists())   portalFile.delete();
  int numPortals=0;
  JsArrayWriter jsWriter=null;
  try {
    jsWriter=new JsArrayWriter(portalFile,map.getId() + ""String_Node_Str"");
    ArrayList<Portal> portals=new ArrayList<Portal>();
    long prevX, prevY, prevZ, firstX, firstZ;
    Portal portal=new Portal();
    portalPositions.read(portal);
    firstX=portal.getX();
    firstZ=portal.getZ();
    prevX=portal.getX();
    prevY=portal.getY();
    prevZ=portal.getZ();
    while (portalPositions.hasNext()) {
      portalPositions.read(portal);
      if ((portal.getX() == prevX && portal.getZ() == prevZ + 1) || (portal.getX() == prevX + 1 && portal.getZ() == prevZ)) {
        prevX=portal.getX();
        prevY=portal.getY();
        prevZ=portal.getZ();
      }
 else {
        portals.add(new Portal(prevX + (firstX - prevX) / 2,prevY,prevZ + (firstZ - prevZ) / 2));
        numPortals++;
        prevX=portal.getX();
        prevY=portal.getY();
        prevZ=portal.getZ();
        firstX=portal.getX();
        firstZ=portal.getZ();
      }
    }
    portals.add(new Portal(portal.getX() + ((firstX - prevX) / 2),portal.getY(),portal.getZ() + (firstZ - prevZ) / 2));
    numPortals++;
    for (    Portal p : portals) {
      final float worldX=p.getX();
      final float worldY=p.getY();
      final float worldZ=p.getZ();
      HashMap<String,String> args=new HashMap<String,String>();
      String posStr=""String_Node_Str"" + worldX + ""String_Node_Str""+ worldY+ ""String_Node_Str""+ worldZ+ ""String_Node_Str"";
      args.put(""String_Node_Str"",posStr);
      jsWriter.write(args);
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
 finally {
    if (jsWriter != null)     jsWriter.close();
  }
  return numPortals;
}",0.5649441340782123
80091,"private static void findPortals(RawChunk chunk,HddObjectListWriter<Portal> portals,PortalFilter filter,WorldStats stats){
  try {
    for (int x=0; x < RawChunk.WIDTH; x++) {
      for (int y=1; y < RawChunk.HEIGHT - 1; y++) {
        for (int z=0; z < RawChunk.DEPTH; z++) {
          final int id=chunk.getBlockId(x,y,z);
          final int above=chunk.getBlockId(x,y + 1,z);
          final int below=chunk.getBlockId(x,y - 1,z);
          if (id == BlockIds.PORTAL && above == BlockIds.PORTAL && below == BlockIds.PORTAL) {
            final int sum=x + z;
            if (sum % 2 == 0) {
              stats.incNumPortals();
              ChunkCoord coord=chunk.getChunkCoord();
              Vector3l pos=new Vector3l(coord.x * RawChunk.WIDTH + x,y,coord.z * RawChunk.DEPTH + z);
              if (filter.passesFilter(coord,pos)) {
                portals.add(new Portal(pos.x,pos.y,pos.z));
              }
            }
          }
        }
      }
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}","private static void findPortals(RawChunk chunk,HddObjectListWriter<Portal> portals,PortalFilter filter,WorldStats stats){
  try {
    for (int x=0; x < RawChunk.WIDTH; x++) {
      for (int y=1; y < RawChunk.HEIGHT - 1; y++) {
        for (int z=0; z < RawChunk.DEPTH; z++) {
          final int id=chunk.getBlockId(x,y,z);
          final int above=chunk.getBlockId(x,y + 1,z);
          int below=chunk.getBlockId(x,y - 1,z);
          if (id == BlockIds.PORTAL && above != BlockIds.PORTAL) {
            ChunkCoord coord=chunk.getChunkCoord();
            int tempY=y;
            while (below == BlockIds.PORTAL) {
              tempY-=1;
              below=chunk.getBlockId(x,tempY,z);
            }
            Vector3l pos=new Vector3l(coord.x * RawChunk.WIDTH + x,y - Math.round((y - (tempY + 1)) / 2),coord.z * RawChunk.DEPTH + z);
            if (filter.passesFilter(coord,pos)) {
              portals.add(new Portal(pos.x,pos.y,pos.z));
            }
          }
        }
      }
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}",0.8161305808929429
80092,"@Override public void addEdgeGeometry(int x,int y,int z,BlockContext world,BlockTypeRegistry registry,RawChunk rawChunk,Geometry geometry){
  Vector4f colour=new Vector4f(1,1,1,1);
  Colour4f testColor=new Colour4f(1,1,1,1);
  Vector4f beamColor=new Vector4f(testColor.r,testColor.g,testColor.b,testColor.a);
  final float offSet=1.0f / 16.0f;
  SubMesh glassMesh=new SubMesh();
  SubMesh beaconMesh=new SubMesh();
  SubMesh obsidianMesh=new SubMesh();
  SubMesh beamMesh=new SubMesh();
  SubMesh.addBlock(glassMesh,0,0,0,offSet * 16,offSet * 16,offSet * 16,colour,glass,glass,glass);
  SubMesh.addBlock(beaconMesh,offSet * 3,offSet * 3,offSet * 3,offSet * 10,offSet * 10,offSet * 10,colour,beacon,beacon,beacon);
  SubMesh.addBlock(obsidianMesh,offSet * 2,offSet * 0.5f,offSet * 2,offSet * 12,offSet * 3,offSet * 12,colour,obsidian,obsidian,obsidian);
  for (  TileEntity te : rawChunk.getBeacons()) {
    if (te.localX == x && te.localY == y && te.localZ == z) {
      if (te.blockData > 0) {
        for (int i=0; i < 255 - te.localY; i++) {
          SubMesh.addBlockSimple(beamMesh,offSet * 5,offSet * (16 * i),offSet * 5,offSet * 5,1,offSet * 5,beamColor,beam,null,null);
          SubMesh.addBlockSimple(beamMesh,offSet * 3,offSet * (16 * i),offSet * 3,offSet * 10,1,offSet * 10,new Vector4f(testColor.r,testColor.g,testColor.b,0.2f),beam,null,null);
        }
      }
    }
  }
  glassMesh.pushTo(geometry.getMesh(glass.texture,Geometry.MeshType.AlphaTest),x,y,z,Rotation.None,0);
  beaconMesh.pushTo(geometry.getMesh(beacon.texture,Geometry.MeshType.Solid),x,y,z,Rotation.None,0);
  obsidianMesh.pushTo(geometry.getMesh(obsidian.texture,Geometry.MeshType.Solid),x,y,z,Rotation.None,0);
  beamMesh.pushTo(geometry.getMesh(beam.texture,Geometry.MeshType.Transparent),x,y,z,Rotation.Clockwise,35);
}","@Override public void addEdgeGeometry(int x,int y,int z,BlockContext world,BlockTypeRegistry registry,RawChunk rawChunk,Geometry geometry){
  Vector4f colour=new Vector4f(1,1,1,1);
  Colour4f testColor=new Colour4f(1,1,1,1);
  Vector4f beamColor=new Vector4f(testColor.r,testColor.g,testColor.b,testColor.a);
  final float offSet=1.0f / 16.0f;
  SubMesh glassMesh=new SubMesh();
  SubMesh beaconMesh=new SubMesh();
  SubMesh obsidianMesh=new SubMesh();
  SubMesh beamMesh=new SubMesh();
  SubMesh.addBlock(glassMesh,0,0,0,offSet * 16,offSet * 16,offSet * 16,colour,glass,glass,glass);
  SubMesh.addBlock(beaconMesh,offSet * 3,offSet * 3,offSet * 3,offSet * 10,offSet * 10,offSet * 10,colour,beacon,beacon,beacon);
  SubMesh.addBlock(obsidianMesh,offSet * 2,offSet * 0.5f,offSet * 2,offSet * 12,offSet * 3,offSet * 12,colour,obsidian,obsidian,obsidian);
  for (  TileEntity te : rawChunk.getBeacons()) {
    if (te.localX == x && te.localY == y && te.localZ == z) {
      boolean isBeamBlocked=false;
      for (int i=1; i < 255 - te.localY; i++) {
        BlockType type=registry.find(world.getBlockId(rawChunk.getChunkCoord(),x,te.localY + i,z),0);
        if (type.isSolid()) {
          isBeamBlocked=true;
        }
      }
      if (te.blockData > 0 && !isBeamBlocked) {
        for (int i=0; i < 255 - te.localY; i++) {
          SubMesh.addBlockSimple(beamMesh,offSet * 5,offSet * (16 * i),offSet * 5,offSet * 5,1,offSet * 5,beamColor,beam,null,null);
          SubMesh.addBlockSimple(beamMesh,offSet * 3,offSet * (16 * i),offSet * 3,offSet * 10,1,offSet * 10,new Vector4f(testColor.r,testColor.g,testColor.b,0.2f),beam,null,null);
        }
      }
    }
  }
  glassMesh.pushTo(geometry.getMesh(glass.texture,Geometry.MeshType.AlphaTest),x,y,z,Rotation.None,0);
  beaconMesh.pushTo(geometry.getMesh(beacon.texture,Geometry.MeshType.Solid),x,y,z,Rotation.None,0);
  obsidianMesh.pushTo(geometry.getMesh(obsidian.texture,Geometry.MeshType.Solid),x,y,z,Rotation.None,0);
  beamMesh.pushTo(geometry.getMesh(beam.texture,Geometry.MeshType.Transparent),x,y,z,Rotation.Clockwise,35);
}",0.9077358005654074
80093,"@Override public void onBound(IOpenPgpService service){
  Log.d(OpenPgpApi.TAG,""String_Node_Str"");
  Intent data=new Intent();
  data.setAction(OpenPgpApi.ACTION_GET_SIGN_KEY_ID);
  data.putExtra(OpenPgpApi.EXTRA_USER_ID,mDefaultUserId);
  OpenPgpApi api=new OpenPgpApi(getContext(),mServiceConnection.getService());
  api.executeApiAsync(data,null,null,new MyCallback(REQUEST_CODE_KEY_PREFERENCE));
}","@Override public void onBound(IOpenPgpService service){
  getSignKeyId(new Intent());
}",0.3155737704918033
80094,"private void setAndPersist(long newValue){
  mKeyId=newValue;
  persistLong(mKeyId);
  notifyChanged();
}","private void setAndPersist(long newValue){
  mKeyId=newValue;
  persistLong(mKeyId);
  notifyChanged();
  setSummary(getSummary());
}",0.8823529411764706
80095,"@Override protected void onClick(){
  mServiceConnection=new OpenPgpServiceConnection(getContext().getApplicationContext(),mOpenPgpProvider,new OpenPgpServiceConnection.OnBound(){
    @Override public void onBound(    IOpenPgpService service){
      Log.d(OpenPgpApi.TAG,""String_Node_Str"");
      Intent data=new Intent();
      data.setAction(OpenPgpApi.ACTION_GET_SIGN_KEY_ID);
      data.putExtra(OpenPgpApi.EXTRA_USER_ID,mDefaultUserId);
      OpenPgpApi api=new OpenPgpApi(getContext(),mServiceConnection.getService());
      api.executeApiAsync(data,null,null,new MyCallback(REQUEST_CODE_KEY_PREFERENCE));
    }
    @Override public void onError(    Exception e){
      Log.e(OpenPgpApi.TAG,""String_Node_Str"",e);
    }
  }
);
  mServiceConnection.bindToService();
}","@Override protected void onClick(){
  mServiceConnection=new OpenPgpServiceConnection(getContext().getApplicationContext(),mOpenPgpProvider,new OpenPgpServiceConnection.OnBound(){
    @Override public void onBound(    IOpenPgpService service){
      getSignKeyId(new Intent());
    }
    @Override public void onError(    Exception e){
      Log.e(OpenPgpApi.TAG,""String_Node_Str"",e);
    }
  }
);
  mServiceConnection.bindToService();
}",0.5695364238410596
80096,"@Override public CharSequence getSummary(){
  return (mKeyId == 0) ? getContext().getString(R.string.openpgp_no_key_selected) : getContext().getString(R.string.openpgp_key_selected);
}","@Override public CharSequence getSummary(){
  return (mKeyId == NO_KEY) ? getContext().getString(R.string.openpgp_no_key_selected) : getContext().getString(R.string.openpgp_key_selected);
}",0.9812332439678284
80097,"@Override public void onReturn(Intent result){
switch (result.getIntExtra(OpenPgpApi.RESULT_CODE,OpenPgpApi.RESULT_CODE_ERROR)) {
case OpenPgpApi.RESULT_CODE_SUCCESS:
{
      Log.e(OpenPgpApi.TAG,""String_Node_Str"");
      break;
    }
case OpenPgpApi.RESULT_CODE_USER_INTERACTION_REQUIRED:
{
    PendingIntent pi=result.getParcelableExtra(OpenPgpApi.RESULT_INTENT);
    try {
      Activity act=(Activity)getContext();
      act.startIntentSenderFromChild(act,pi.getIntentSender(),requestCode,null,0,0,0);
    }
 catch (    IntentSender.SendIntentException e) {
      Log.e(OpenPgpApi.TAG,""String_Node_Str"",e);
    }
    break;
  }
case OpenPgpApi.RESULT_CODE_ERROR:
{
  OpenPgpError error=result.getParcelableExtra(OpenPgpApi.RESULT_ERROR);
  Log.e(OpenPgpApi.TAG,""String_Node_Str"" + error.getMessage());
  break;
}
}
}","@Override public void onReturn(Intent result){
switch (result.getIntExtra(OpenPgpApi.RESULT_CODE,OpenPgpApi.RESULT_CODE_ERROR)) {
case OpenPgpApi.RESULT_CODE_SUCCESS:
{
      long keyId=result.getLongExtra(OpenPgpApi.EXTRA_SIGN_KEY_ID,NO_KEY);
      save(keyId);
      break;
    }
case OpenPgpApi.RESULT_CODE_USER_INTERACTION_REQUIRED:
{
    PendingIntent pi=result.getParcelableExtra(OpenPgpApi.RESULT_INTENT);
    try {
      Activity act=(Activity)getContext();
      act.startIntentSenderFromChild(act,pi.getIntentSender(),requestCode,null,0,0,0);
    }
 catch (    IntentSender.SendIntentException e) {
      Log.e(OpenPgpApi.TAG,""String_Node_Str"",e);
    }
    break;
  }
case OpenPgpApi.RESULT_CODE_ERROR:
{
  OpenPgpError error=result.getParcelableExtra(OpenPgpApi.RESULT_ERROR);
  Log.e(OpenPgpApi.TAG,""String_Node_Str"" + error.getMessage());
  break;
}
}
}",0.9294605809128632
80098,"public boolean handleOnActivityResult(int requestCode,int resultCode,Intent data){
  if (requestCode == REQUEST_CODE_KEY_PREFERENCE && resultCode == Activity.RESULT_OK) {
    long keyId=data.getLongExtra(OpenPgpApi.EXTRA_SIGN_KEY_ID,0);
    save(keyId);
    return true;
  }
 else {
    return false;
  }
}","public boolean handleOnActivityResult(int requestCode,int resultCode,Intent data){
  if (requestCode == REQUEST_CODE_KEY_PREFERENCE && resultCode == Activity.RESULT_OK) {
    getSignKeyId(data);
    return true;
  }
 else {
    return false;
  }
}",0.7233273056057866
80099,"@Override protected Object onGetDefaultValue(TypedArray a,int index){
  return (long)a.getInteger(index,0);
}","@Override protected Object onGetDefaultValue(TypedArray a,int index){
  return (long)a.getInteger(index,NO_KEY);
}",0.968609865470852
80100,"@Override public synchronized void addAfterChild(final T parent,final T newChild,final T afterChild){
  expectNodeNotInTreeYet(newChild);
  final InMemoryTreeNode<T> node=getNodeFromTreeOrThrowAllowRoot(parent);
  final boolean visibility=getChildrenVisibility(node);
  if (afterChild == null) {
    final InMemoryTreeNode<T> added=node.add(node.getChildrenListSize(),newChild,visibility);
    allNodes.put(newChild,added);
  }
 else {
    final int index=node.indexOf(afterChild);
    final InMemoryTreeNode<T> added=node.add(index == -1 ? node.getChildrenListSize() : index,newChild,visibility);
    allNodes.put(newChild,added);
  }
  if (visibility) {
    internalDataSetChanged();
  }
}","@Override public synchronized void addAfterChild(final T parent,final T newChild,final T afterChild){
  expectNodeNotInTreeYet(newChild);
  final InMemoryTreeNode<T> node=getNodeFromTreeOrThrowAllowRoot(parent);
  final boolean visibility=getChildrenVisibility(node);
  if (afterChild == null) {
    final InMemoryTreeNode<T> added=node.add(node.getChildrenListSize(),newChild,visibility);
    allNodes.put(newChild,added);
  }
 else {
    final int index=node.indexOf(afterChild);
    final InMemoryTreeNode<T> added=node.add(index == -1 ? node.getChildrenListSize() : index + 1,newChild,visibility);
    allNodes.put(newChild,added);
  }
  if (visibility) {
    internalDataSetChanged();
  }
}",0.9971139971139972
80101,"private Drawable getDrawable(final TreeNodeInfo<T> nodeInfo){
  if (!nodeInfo.isWithChildren() || !collapsible) {
    return getDrawableOrDefaultBackground(indicatorBackgroundDrawable);
  }
  if (nodeInfo.isExpanded()) {
    return expandedDrawable;
  }
 else {
    return collapsedDrawable;
  }
}","protected Drawable getDrawable(final TreeNodeInfo<T> nodeInfo){
  if (!nodeInfo.isWithChildren() || !collapsible) {
    return getDrawableOrDefaultBackground(indicatorBackgroundDrawable);
  }
  if (nodeInfo.isExpanded()) {
    return expandedDrawable;
  }
 else {
    return collapsedDrawable;
  }
}",0.9798657718120806
80102,"@Override public synchronized T getPreviousSibling(final T id){
  final T parent=getParent(id);
  final InMemoryTreeNode<T> parentNode=getNodeFromTreeOrThrowAllowRoot(parent);
  final T previousSibling=null;
  for (  final InMemoryTreeNode<T> child : parentNode.getChildren()) {
    if (child.getId().equals(id)) {
      return previousSibling;
    }
    previousSibling=child.getId();
  }
  return null;
}","@Override public synchronized T getPreviousSibling(final T id){
  final T parent=getParent(id);
  final InMemoryTreeNode<T> parentNode=getNodeFromTreeOrThrowAllowRoot(parent);
  T previousSibling=null;
  for (  final InMemoryTreeNode<T> child : parentNode.getChildren()) {
    if (child.getId().equals(id)) {
      return previousSibling;
    }
    previousSibling=child.getId();
  }
  return null;
}",0.9925558312655088
80103,"@Override public synchronized TreeNodeInfo<T> getNodeInfo(final T id){
  final InMemoryTreeNode<T> node=getNodeFromTreeOrThrow(id);
  final List<InMemoryTreeNode<T>> children=node.getChildren();
  boolean expanded=false;
  if (children.size() > 0 && children.get(0).isVisible()) {
    expanded=true;
  }
  return new TreeNodeInfo<T>(id,node.getLevel(),children.size() > 0,node.isVisible(),expanded);
}","@Override public synchronized TreeNodeInfo<T> getNodeInfo(final T id){
  final InMemoryTreeNode<T> node=getNodeFromTreeOrThrow(id);
  final List<InMemoryTreeNode<T>> children=node.getChildren();
  boolean expanded=false;
  if (!children.isEmpty() && children.get(0).isVisible()) {
    expanded=true;
  }
  return new TreeNodeInfo<T>(id,node.getLevel(),!children.isEmpty(),node.isVisible(),expanded);
}",0.9052369077306732
80104,"private boolean getChildrenVisibility(final InMemoryTreeNode<T> node){
  boolean visibility;
  final List<InMemoryTreeNode<T>> children=node.getChildren();
  if (children.size() > 0) {
    visibility=children.get(0).isVisible();
  }
 else {
    visibility=visibleByDefault;
  }
  return visibility;
}","private boolean getChildrenVisibility(final InMemoryTreeNode<T> node){
  boolean visibility;
  final List<InMemoryTreeNode<T>> children=node.getChildren();
  if (children.isEmpty()) {
    visibility=visibleByDefault;
  }
 else {
    visibility=children.get(0).isVisible();
  }
  return visibility;
}",0.7512520868113522
80105,"public synchronized T getNextVisible(final T id){
  final InMemoryTreeNode<T> node=getNodeFromTreeOrThrowAllowRoot(id);
  if (!node.isVisible()) {
    return null;
  }
  final List<InMemoryTreeNode<T>> children=node.getChildren();
  if (children.size() > 0) {
    final InMemoryTreeNode<T> firstChild=children.get(0);
    if (firstChild.isVisible()) {
      return firstChild.getId();
    }
  }
  final T sibl=getNextSibling(id);
  if (sibl != null) {
    return sibl;
  }
  T parent=node.getParent();
  do {
    if (parent == null) {
      return null;
    }
    final T parentSibling=getNextSibling(parent);
    if (parentSibling != null) {
      return parentSibling;
    }
    parent=getNodeFromTreeOrThrow(parent).getParent();
  }
 while (true);
}","public synchronized T getNextVisible(final T id){
  final InMemoryTreeNode<T> node=getNodeFromTreeOrThrowAllowRoot(id);
  if (!node.isVisible()) {
    return null;
  }
  final List<InMemoryTreeNode<T>> children=node.getChildren();
  if (!children.isEmpty()) {
    final InMemoryTreeNode<T> firstChild=children.get(0);
    if (firstChild.isVisible()) {
      return firstChild.getId();
    }
  }
  final T sibl=getNextSibling(id);
  if (sibl != null) {
    return sibl;
  }
  T parent=node.getParent();
  do {
    if (parent == null) {
      return null;
    }
    final T parentSibling=getNextSibling(parent);
    if (parentSibling != null) {
      return parentSibling;
    }
    parent=getNodeFromTreeOrThrow(parent).getParent();
  }
 while (true);
}",0.3577127659574468
80106,"/** 
 * Adds note to parent at the level specified. But it verifies that the level is one level down than the parent!
 * @param parent parent parent
 * @param id new node id
 * @param level should always be parent's level + 1
 */
private void addNodeToParentOneLevelDown(final T parent,final T id,final int level){
  if (parent == null && level != 0) {
    throw new RuntimeException(""String_Node_Str"" + id + ""String_Node_Str""+ level+ ""String_Node_Str"");
  }
  if (parent != null && manager.getLevel(parent) != level - 1) {
    throw new RuntimeException(""String_Node_Str"" + id + ""String_Node_Str""+ level+ ""String_Node_Str""+ parent+ ""String_Node_Str""+ manager.getLevel(parent)+ ""String_Node_Str"");
  }
  manager.addAfterChild(parent,id,null);
  setLastAdded(id,level);
}","/** 
 * Adds note to parent at the level specified. But it verifies that the level is one level down than the parent!
 * @param parent parent parent
 * @param id new node id
 * @param level should always be parent's level + 1
 */
private void addNodeToParentOneLevelDown(final T parent,final T id,final int level){
  if (parent == null && level != 0) {
    throw new TreeConfigurationException(""String_Node_Str"" + id + ""String_Node_Str""+ level+ ""String_Node_Str"");
  }
  if (parent != null && manager.getLevel(parent) != level - 1) {
    throw new TreeConfigurationException(""String_Node_Str"" + id + ""String_Node_Str""+ level+ ""String_Node_Str""+ parent+ ""String_Node_Str""+ manager.getLevel(parent)+ ""String_Node_Str"");
  }
  manager.addAfterChild(parent,id,null);
  setLastAdded(id,level);
}",0.9717948717948718
80107,"private void parseAttributes(final Context context,final AttributeSet attrs,final int defStyle){
  final TypedArray a=context.obtainStyledAttributes(attrs,R.styleable.TreeViewList);
  expandedDrawable=a.getDrawable(R.styleable.TreeViewList_src_expanded);
  if (expandedDrawable == null) {
    expandedDrawable=context.getResources().getDrawable(DEFAULT_EXPANDED_RESOURCE);
  }
  collapsedDrawable=a.getDrawable(R.styleable.TreeViewList_src_collapsed);
  if (collapsedDrawable == null) {
    collapsedDrawable=context.getResources().getDrawable(DEFAULT_COLLAPSED_RESOURCE);
  }
  indentWidth=a.getDimensionPixelSize(R.styleable.TreeViewList_indent_width,DEFAULT_INDENT);
  indicatorGravity=a.getInteger(R.styleable.TreeViewList_indicator_gravity,DEFAULT_GRAVITY);
  indicatorBackgroundDrawable=a.getDrawable(R.styleable.TreeViewList_indicator_background);
  rowBackgroundDrawable=a.getDrawable(R.styleable.TreeViewList_row_background);
  collapsible=a.getBoolean(R.styleable.TreeViewList_collapsible,true);
  handleTrackballPress=a.getBoolean(R.styleable.TreeViewList_handle_trackball_press,true);
}","private void parseAttributes(final Context context,final AttributeSet attrs){
  final TypedArray a=context.obtainStyledAttributes(attrs,R.styleable.TreeViewList);
  expandedDrawable=a.getDrawable(R.styleable.TreeViewList_src_expanded);
  if (expandedDrawable == null) {
    expandedDrawable=context.getResources().getDrawable(DEFAULT_EXPANDED_RESOURCE);
  }
  collapsedDrawable=a.getDrawable(R.styleable.TreeViewList_src_collapsed);
  if (collapsedDrawable == null) {
    collapsedDrawable=context.getResources().getDrawable(DEFAULT_COLLAPSED_RESOURCE);
  }
  indentWidth=a.getDimensionPixelSize(R.styleable.TreeViewList_indent_width,DEFAULT_INDENT);
  indicatorGravity=a.getInteger(R.styleable.TreeViewList_indicator_gravity,DEFAULT_GRAVITY);
  indicatorBackgroundDrawable=a.getDrawable(R.styleable.TreeViewList_indicator_background);
  rowBackgroundDrawable=a.getDrawable(R.styleable.TreeViewList_row_background);
  collapsible=a.getBoolean(R.styleable.TreeViewList_collapsible,true);
  handleTrackballPress=a.getBoolean(R.styleable.TreeViewList_handle_trackball_press,true);
}",0.9912723932016536
80108,"@Override public void setAdapter(final ListAdapter adapter){
  if (!(adapter instanceof TreeViewAdapter)) {
    throw new RuntimeException(""String_Node_Str"");
  }
  treeAdapter=(TreeViewAdapter<?>)adapter;
  syncAdapter();
  super.setAdapter(treeAdapter);
}","@Override public void setAdapter(final ListAdapter adapter){
  if (!(adapter instanceof AbstractTreeViewAdapter)) {
    throw new TreeConfigurationException(""String_Node_Str"");
  }
  treeAdapter=(AbstractTreeViewAdapter<?>)adapter;
  syncAdapter();
  super.setAdapter(treeAdapter);
}",0.9296296296296296
80109,"public TreeViewList(final Context context,final AttributeSet attrs,final int defStyle){
  super(context,attrs,defStyle);
  parseAttributes(context,attrs,defStyle);
}","public TreeViewList(final Context context,final AttributeSet attrs,final int defStyle){
  super(context,attrs,defStyle);
  parseAttributes(context,attrs);
}",0.97196261682243
80110,"public InMemoryTreeNode<T> add(final int index,final T child,final boolean visible){
  childIdListCache=null;
  final InMemoryTreeNode<T> newNode=new InMemoryTreeNode<T>(child,getId(),getLevel() + 1,getId() == null ? true : visible);
  children.add(index,newNode);
  return newNode;
}","public synchronized InMemoryTreeNode<T> add(final int index,final T child,final boolean visible){
  childIdListCache=null;
  final InMemoryTreeNode<T> newNode=new InMemoryTreeNode<T>(child,getId(),getLevel() + 1,getId() == null ? true : visible);
  children.add(index,newNode);
  return newNode;
}",0.9776247848537004
80111,"private void internalDataSetChanged(){
  visibleListCache=null;
  unmodifiableVisibleList=null;
  for (  final DataSetObserver observer : observers) {
    observer.onChanged();
  }
}","private synchronized void internalDataSetChanged(){
  visibleListCache=null;
  unmodifiableVisibleList=null;
  for (  final DataSetObserver observer : observers) {
    observer.onChanged();
  }
}",0.9655172413793104
80112,"/** 
 * Adds new relation to existing tree. Child is set as the last child of the parent node. Parent has to already exist in the tree, child cannot yet exist. This method is mostly useful in case you add entries layer by layer - i.e. first top level entries, then children for all parents, then grand-children and so on.
 * @param parent parent id
 * @param child child id
 */
public void addRelation(final T parent,final T child){
  Log.d(TAG,""String_Node_Str"" + parent + ""String_Node_Str""+ child);
  manager.addAfterChild(parent,child,null);
  lastAddedId=child;
  lastLevel=manager.getLevel(child);
}","/** 
 * Adds new relation to existing tree. Child is set as the last child of the parent node. Parent has to already exist in the tree, child cannot yet exist. This method is mostly useful in case you add entries layer by layer - i.e. first top level entries, then children for all parents, then grand-children and so on.
 * @param parent parent id
 * @param child child id
 */
public synchronized void addRelation(final T parent,final T child){
  Log.d(TAG,""String_Node_Str"" + parent + ""String_Node_Str""+ child);
  manager.addAfterChild(parent,child,null);
  lastAddedId=child;
  lastLevel=manager.getLevel(child);
}",0.9893529893529892
80113,"@Override public void deleteSchema() throws GoraException {
  try {
    if (batchWriter != null)     batchWriter.close();
    batchWriter=null;
    conn.tableOperations().delete(mapping.tableName);
  }
 catch (  AccumuloException|AccumuloSecurityException|TableNotFoundException e) {
    LOG.error(e.getMessage(),e);
    throw new GoraException(e);
  }
}","@Override public void deleteSchema() throws GoraException {
  try {
    if (batchWriter != null)     batchWriter.close();
    batchWriter=null;
    conn.tableOperations().delete(mapping.tableName);
  }
 catch (  TableNotFoundException e) {
  }
catch (  AccumuloException|AccumuloSecurityException e) {
    LOG.error(e.getMessage(),e);
    throw new GoraException(e);
  }
}",0.9118457300275482
80114,"/** 
 * Deletes the underlying schema or table (or similar) in the datastore that holds the objects. This also deletes all the data associated with the schema.
 */
void deleteSchema() throws GoraException ;","/** 
 * Deletes the underlying schema or table (or similar) in the datastore that holds the objects. This also deletes all the data associated with the schema. If the schema does not exists, this operation is ignored.
 */
void deleteSchema() throws GoraException ;",0.8765957446808511
80115,"/** 
 * Convert Gora query to Orient DB specific query which underline API understands. And maintain it s state encapsulated to Gora implementation of the   {@link org.apache.gora.query.Query}.
 * @return a {@link OSQLSynchQuery} query executable over Orient DB.
 */
public OSQLSynchQuery<ODocument> populateOrientDBQuery(final OrientDBMapping orientDBMapping,final String[] fields,final String[] schemaFields){
  params=new HashMap<String,Object>();
  Query selectQuery=new Query();
  selectQuery.from(orientDBMapping.getDocumentClass());
  if ((this.getStartKey() != null) && (this.getEndKey() != null) && this.getStartKey().equals(this.getEndKey())) {
    selectQuery.where(projection(""String_Node_Str"").eq(Parameter.parameter(""String_Node_Str"")));
    params.put(""String_Node_Str"",this.getStartKey());
  }
 else   if (this.getStartKey() != null || this.getEndKey() != null) {
    if (this.getStartKey() != null) {
      selectQuery.where(projection(""String_Node_Str"").ge(Parameter.parameter(""String_Node_Str"")));
      params.put(""String_Node_Str"",this.getStartKey());
    }
    if (this.getEndKey() != null) {
      selectQuery.where(projection(""String_Node_Str"").le(Parameter.parameter(""String_Node_Str"")));
      params.put(""String_Node_Str"",this.getEndKey());
    }
  }
  if (fields.length == schemaFields.length) {
    selectQuery.select(Projection.ALL);
  }
 else {
    for (    String k : fields) {
      String dbFieldName=orientDBMapping.getDocumentField(k);
      if (dbFieldName != null && dbFieldName.length() > 0) {
        selectQuery.select(dbFieldName);
      }
    }
    selectQuery.select(""String_Node_Str"");
  }
  dbQuery=new OSQLSynchQuery<ODocument>(selectQuery.toString());
  return dbQuery;
}","/** 
 * Convert Gora query to Orient DB specific query which underline API understands. And maintain it s state encapsulated to Gora implementation of the   {@link org.apache.gora.query.Query}.
 * @param orientDBMapping OrientDB mapping file.
 * @param fields OrientDB query fields.
 * @param schemaFields AVRO schema fields for persistent bean.
 * @return a {@link OSQLSynchQuery} query executable over Orient DB.
 */
public OSQLSynchQuery<ODocument> populateOrientDBQuery(final OrientDBMapping orientDBMapping,final String[] fields,final String[] schemaFields){
  params=new HashMap<String,Object>();
  Query selectQuery=new Query();
  selectQuery.from(orientDBMapping.getDocumentClass());
  if ((this.getStartKey() != null) && (this.getEndKey() != null) && this.getStartKey().equals(this.getEndKey())) {
    selectQuery.where(projection(""String_Node_Str"").eq(Parameter.parameter(""String_Node_Str"")));
    params.put(""String_Node_Str"",this.getStartKey());
  }
 else   if (this.getStartKey() != null || this.getEndKey() != null) {
    if (this.getStartKey() != null) {
      selectQuery.where(projection(""String_Node_Str"").ge(Parameter.parameter(""String_Node_Str"")));
      params.put(""String_Node_Str"",this.getStartKey());
    }
    if (this.getEndKey() != null) {
      selectQuery.where(projection(""String_Node_Str"").le(Parameter.parameter(""String_Node_Str"")));
      params.put(""String_Node_Str"",this.getEndKey());
    }
  }
  if (fields.length == schemaFields.length) {
    selectQuery.select(Projection.ALL);
  }
 else {
    for (    String k : fields) {
      String dbFieldName=orientDBMapping.getDocumentField(k);
      if (dbFieldName != null && dbFieldName.length() > 0) {
        selectQuery.select(dbFieldName);
      }
    }
    selectQuery.select(""String_Node_Str"");
  }
  dbQuery=new OSQLSynchQuery<ODocument>(selectQuery.toString());
  return dbQuery;
}",0.9576601671309192
80116,"/** 
 * Returns all fields in AVRO   {@link org.apache.hadoop.io.serializer.avro.Record} record.
 * @return array of fields in string.
 */
public String[] getDocumentFields(){
  return documentToClass.keySet().toArray(new String[documentToClass.keySet().size()]);
}","/** 
 * Returns all fields in AVRO   {@link SpecificRecord} record.
 * @return array of fields in string.
 */
public String[] getDocumentFields(){
  return documentToClass.keySet().toArray(new String[documentToClass.keySet().size()]);
}",0.9141716566866268
80117,"/** 
 * Build OrientDB dataStore mapping from gora-orientdb-mapping.xml given from class path or file system location.
 */
public OrientDBMapping build(){
  if (mapping.getDocumentClass() == null)   throw new IllegalStateException(""String_Node_Str"");
  return mapping;
}","/** 
 * Build OrientDB dataStore mapping from gora-orientdb-mapping.xml given from class path or file system location.
 * @return mapping file {@link OrientDBMapping}
 */
public OrientDBMapping build(){
  if (mapping.getDocumentClass() == null)   throw new IllegalStateException(""String_Node_Str"");
  return mapping;
}",0.891156462585034
80118,"@Override public String getSchemaName(){
  return orientDBMapping.getDocumentClass();
}","/** 
 * {@inheritDoc}
 */
@Override public String getSchemaName(){
  return orientDBMapping.getDocumentClass();
}",0.87
80119,"@Override public boolean delete(K key){
  Delete delete=new Delete();
  delete.from(orientDBMapping.getDocumentClass()).where(projection(""String_Node_Str"").eq(Parameter.parameter(""String_Node_Str"")));
  Map<String,Object> params=new HashMap<String,Object>();
  params.put(""String_Node_Str"",key);
  OCommandSQL query=new OCommandSQL(delete.toString().replace(""String_Node_Str"",""String_Node_Str""));
  ODatabaseDocumentTx deleteTx=connectionPool.acquire();
  deleteTx.activateOnCurrentThread();
  try {
    int deleteCount=deleteTx.command(query).execute(params);
    if (deleteCount == 1) {
      return true;
    }
 else {
      return false;
    }
  }
  finally {
    deleteTx.close();
  }
}","/** 
 * {@inheritDoc}
 */
@Override public boolean delete(K key){
  Delete delete=new Delete();
  delete.from(orientDBMapping.getDocumentClass()).where(projection(""String_Node_Str"").eq(Parameter.parameter(""String_Node_Str"")));
  Map<String,Object> params=new HashMap<String,Object>();
  params.put(""String_Node_Str"",key);
  OCommandSQL query=new OCommandSQL(delete.toString().replace(""String_Node_Str"",""String_Node_Str""));
  ODatabaseDocumentTx deleteTx=connectionPool.acquire();
  deleteTx.activateOnCurrentThread();
  try {
    int deleteCount=deleteTx.command(query).execute(params);
    if (deleteCount == 1) {
      return true;
    }
 else {
      return false;
    }
  }
  finally {
    deleteTx.close();
  }
}",0.9815340909090908
80120,"@Override public void put(K key,T val){
  if (val.isDirty()) {
    OrientDBQuery<K,T> dataStoreQuery=new OrientDBQuery<>(this);
    dataStoreQuery.setStartKey(key);
    dataStoreQuery.setEndKey(key);
    dataStoreQuery.populateOrientDBQuery(orientDBMapping,getFieldsToQuery(null),getFields());
    ODatabaseDocumentTx selectTx=connectionPool.acquire();
    selectTx.activateOnCurrentThread();
    try {
      List<ODocument> result=selectTx.command(dataStoreQuery.getOrientDBQuery()).execute(dataStoreQuery.getParams());
      if (result.size() == 1) {
        ODocument document=updateOrientDocFromAvroBean(key,val,result.get(0));
        docBatch.add(document);
      }
 else {
        ODocument document=convertAvroBeanToOrientDoc(key,val);
        docBatch.add(document);
      }
    }
  finally {
      selectTx.close();
    }
  }
 else {
    if (LOG.isDebugEnabled()) {
      LOG.info(""String_Node_Str"" + ""String_Node_Str"",new Object[]{val});
    }
  }
}","/** 
 * {@inheritDoc}
 */
@Override public void put(K key,T val){
  if (val.isDirty()) {
    OrientDBQuery<K,T> dataStoreQuery=new OrientDBQuery<>(this);
    dataStoreQuery.setStartKey(key);
    dataStoreQuery.setEndKey(key);
    dataStoreQuery.populateOrientDBQuery(orientDBMapping,getFieldsToQuery(null),getFields());
    ODatabaseDocumentTx selectTx=connectionPool.acquire();
    selectTx.activateOnCurrentThread();
    try {
      List<ODocument> result=selectTx.command(dataStoreQuery.getOrientDBQuery()).execute(dataStoreQuery.getParams());
      if (result.size() == 1) {
        ODocument document=updateOrientDocFromAvroBean(key,val,result.get(0));
        docBatch.add(document);
      }
 else {
        ODocument document=convertAvroBeanToOrientDoc(key,val);
        docBatch.add(document);
      }
    }
  finally {
      selectTx.close();
    }
  }
 else {
    if (LOG.isDebugEnabled()) {
      LOG.info(""String_Node_Str"" + ""String_Node_Str"",new Object[]{val});
    }
  }
}",0.986639260020555
80121,"/** 
 * Deletes enforced schema over OrientDB Document class.
 */
@Override public void deleteSchema(){
  ODatabaseDocumentTx schemaTx=connectionPool.acquire();
  schemaTx.activateOnCurrentThread();
  try {
    schemaTx.getMetadata().getSchema().dropClass(orientDBMapping.getDocumentClass());
  }
  finally {
    schemaTx.close();
  }
}","/** 
 * {@inheritDoc}Deletes enforced schema over OrientDB Document class.
 */
@Override public void deleteSchema(){
  ODatabaseDocumentTx schemaTx=connectionPool.acquire();
  schemaTx.activateOnCurrentThread();
  try {
    schemaTx.getMetadata().getSchema().dropClass(orientDBMapping.getDocumentClass());
  }
  finally {
    schemaTx.close();
  }
}",0.981021897810219
80122,"@Override public long deleteByQuery(Query<K,T> query){
  Delete delete=new Delete();
  delete.from(orientDBMapping.getDocumentClass());
  Map<String,Object> params=new HashMap<String,Object>();
  if (query.getFields() == null || (query.getFields().length == getFields().length)) {
    if (query.getStartKey() != null) {
      delete.where(projection(""String_Node_Str"").ge(Parameter.parameter(""String_Node_Str"")));
      params.put(""String_Node_Str"",query.getStartKey());
    }
    if (query.getEndKey() != null) {
      delete.where(projection(""String_Node_Str"").le(Parameter.parameter(""String_Node_Str"")));
      params.put(""String_Node_Str"",query.getEndKey());
    }
    OCommandSQL dbQuery=new OCommandSQL(delete.toString().replace(""String_Node_Str"",""String_Node_Str""));
    ODatabaseDocumentTx deleteTx=connectionPool.acquire();
    deleteTx.activateOnCurrentThread();
    try {
      int deleteCount;
      if (params.isEmpty()) {
        deleteCount=deleteTx.command(dbQuery).execute();
      }
 else {
        deleteCount=deleteTx.command(dbQuery).execute(params);
      }
      if (deleteCount > 0) {
        return deleteCount;
      }
 else {
        return 0;
      }
    }
  finally {
      deleteTx.close();
    }
  }
 else {
    OrientDBQuery<K,T> dataStoreQuery=new OrientDBQuery<>(this);
    dataStoreQuery.setStartKey(query.getStartKey());
    dataStoreQuery.setEndKey(query.getEndKey());
    dataStoreQuery.populateOrientDBQuery(orientDBMapping,getFieldsToQuery(null),getFields());
    ODatabaseDocumentTx selectTx=connectionPool.acquire();
    selectTx.activateOnCurrentThread();
    try {
      List<ODocument> result=selectTx.command(dataStoreQuery.getOrientDBQuery()).execute(dataStoreQuery.getParams());
      if (result != null && result.isEmpty()) {
        return 0;
      }
 else {
        for (        ODocument doc : result) {
          for (          String docField : query.getFields()) {
            if (doc.containsField(orientDBMapping.getDocumentField(docField))) {
              doc.removeField(orientDBMapping.getDocumentField(docField));
            }
          }
          doc.save();
        }
        return result.size();
      }
    }
  finally {
      selectTx.close();
    }
  }
}","/** 
 * {@inheritDoc}
 */
@Override public long deleteByQuery(Query<K,T> query){
  Delete delete=new Delete();
  delete.from(orientDBMapping.getDocumentClass());
  Map<String,Object> params=new HashMap<String,Object>();
  if (query.getFields() == null || (query.getFields().length == getFields().length)) {
    if (query.getStartKey() != null) {
      delete.where(projection(""String_Node_Str"").ge(Parameter.parameter(""String_Node_Str"")));
      params.put(""String_Node_Str"",query.getStartKey());
    }
    if (query.getEndKey() != null) {
      delete.where(projection(""String_Node_Str"").le(Parameter.parameter(""String_Node_Str"")));
      params.put(""String_Node_Str"",query.getEndKey());
    }
    OCommandSQL dbQuery=new OCommandSQL(delete.toString().replace(""String_Node_Str"",""String_Node_Str""));
    ODatabaseDocumentTx deleteTx=connectionPool.acquire();
    deleteTx.activateOnCurrentThread();
    try {
      int deleteCount;
      if (params.isEmpty()) {
        deleteCount=deleteTx.command(dbQuery).execute();
      }
 else {
        deleteCount=deleteTx.command(dbQuery).execute(params);
      }
      if (deleteCount > 0) {
        return deleteCount;
      }
 else {
        return 0;
      }
    }
  finally {
      deleteTx.close();
    }
  }
 else {
    OrientDBQuery<K,T> dataStoreQuery=new OrientDBQuery<>(this);
    dataStoreQuery.setStartKey(query.getStartKey());
    dataStoreQuery.setEndKey(query.getEndKey());
    dataStoreQuery.populateOrientDBQuery(orientDBMapping,getFieldsToQuery(null),getFields());
    ODatabaseDocumentTx selectTx=connectionPool.acquire();
    selectTx.activateOnCurrentThread();
    try {
      List<ODocument> result=selectTx.command(dataStoreQuery.getOrientDBQuery()).execute(dataStoreQuery.getParams());
      if (result != null && result.isEmpty()) {
        return 0;
      }
 else {
        for (        ODocument doc : result) {
          for (          String docField : query.getFields()) {
            if (doc.containsField(orientDBMapping.getDocumentField(docField))) {
              doc.removeField(orientDBMapping.getDocumentField(docField));
            }
          }
          doc.save();
        }
        return result.size();
      }
    }
  finally {
      selectTx.close();
    }
  }
}",0.9941912421805184
80123,"/** 
 * Flushes locally cached to content in memory to remote OrientDB server.
 */
@Override public void flush(){
  ODatabaseDocumentTx updateTx=connectionPool.acquire();
  updateTx.activateOnCurrentThread();
  try {
    flushLock.lock();
    for (    ODocument document : docBatch) {
      updateTx.save(document);
    }
  }
  finally {
    updateTx.close();
    docBatch.clear();
    flushLock.unlock();
  }
}","/** 
 * {@inheritDoc}Flushes locally cached to content in memory to remote OrientDB server.
 */
@Override public void flush(){
  ODatabaseDocumentTx updateTx=connectionPool.acquire();
  updateTx.activateOnCurrentThread();
  try {
    flushLock.lock();
    for (    ODocument document : docBatch) {
      updateTx.save(document);
    }
  }
  finally {
    updateTx.close();
    docBatch.clear();
    flushLock.unlock();
  }
}",0.9844311377245508
80124,"@Override public List<PartitionQuery<K,T>> getPartitions(Query<K,T> query) throws IOException {
  List<PartitionQuery<K,T>> partitions=new ArrayList<>();
  PartitionQueryImpl<K,T> partitionQuery=new PartitionQueryImpl<>(query);
  partitionQuery.setConf(this.getConf());
  partitions.add(partitionQuery);
  return partitions;
}","/** 
 * {@inheritDoc}
 */
@Override public List<PartitionQuery<K,T>> getPartitions(Query<K,T> query) throws IOException {
  List<PartitionQuery<K,T>> partitions=new ArrayList<>();
  PartitionQueryImpl<K,T> partitionQuery=new PartitionQueryImpl<>(query);
  partitionQuery.setConf(this.getConf());
  partitions.add(partitionQuery);
  return partitions;
}",0.9616519174041298
80125,"@Override public T get(K key,String[] fields){
  String[] dbFields=getFieldsToQuery(fields);
  com.github.raymanrt.orientqb.query.Query selectQuery=new com.github.raymanrt.orientqb.query.Query();
  for (  String k : dbFields) {
    String dbFieldName=orientDBMapping.getDocumentField(k);
    if (dbFieldName != null && dbFieldName.length() > 0) {
      selectQuery.select(dbFieldName);
    }
  }
  selectQuery.from(orientDBMapping.getDocumentClass()).where(projection(""String_Node_Str"").eq(Parameter.parameter(""String_Node_Str"")));
  Map<String,Object> params=new HashMap<String,Object>();
  params.put(""String_Node_Str"",key);
  OSQLSynchQuery<ODocument> query=new OSQLSynchQuery<ODocument>(selectQuery.toString());
  ODatabaseDocumentTx selectTx=connectionPool.acquire();
  selectTx.activateOnCurrentThread();
  try {
    List<ODocument> result=selectTx.command(query).execute(params);
    if (result.size() == 1) {
      return convertOrientDocToAvroBean(result.get(0),dbFields);
    }
 else {
      return null;
    }
  }
  finally {
    selectTx.close();
  }
}","/** 
 * {@inheritDoc}
 */
@Override public T get(K key,String[] fields){
  String[] dbFields=getFieldsToQuery(fields);
  com.github.raymanrt.orientqb.query.Query selectQuery=new com.github.raymanrt.orientqb.query.Query();
  for (  String k : dbFields) {
    String dbFieldName=orientDBMapping.getDocumentField(k);
    if (dbFieldName != null && dbFieldName.length() > 0) {
      selectQuery.select(dbFieldName);
    }
  }
  selectQuery.from(orientDBMapping.getDocumentClass()).where(projection(""String_Node_Str"").eq(Parameter.parameter(""String_Node_Str"")));
  Map<String,Object> params=new HashMap<String,Object>();
  params.put(""String_Node_Str"",key);
  OSQLSynchQuery<ODocument> query=new OSQLSynchQuery<ODocument>(selectQuery.toString());
  ODatabaseDocumentTx selectTx=connectionPool.acquire();
  selectTx.activateOnCurrentThread();
  try {
    List<ODocument> result=selectTx.command(query).execute(params);
    if (result.size() == 1) {
      return convertOrientDocToAvroBean(result.get(0),dbFields);
    }
 else {
      return null;
    }
  }
  finally {
    selectTx.close();
  }
}",0.9879294336118848
80126,"@Override public Query<K,T> newQuery(){
  OrientDBQuery<K,T> query=new OrientDBQuery<K,T>(this);
  query.setFields(getFieldsToQuery(null));
  return new OrientDBQuery<K,T>(this);
}","/** 
 * {@inheritDoc}
 */
@Override public Query<K,T> newQuery(){
  OrientDBQuery<K,T> query=new OrientDBQuery<K,T>(this);
  query.setFields(getFieldsToQuery(null));
  return new OrientDBQuery<K,T>(this);
}",0.932642487046632
80127,"/** 
 * Releases resources which have been used dataStore. Eg:- OrientDB Client connection pool.
 */
@Override public void close(){
  docBatch.clear();
  remoteServerAdmin.close();
  connectionPool.close();
}","/** 
 * {@inheritDoc}Releases resources which have been used dataStore. Eg:- OrientDB Client connection pool.
 */
@Override public void close(){
  docBatch.clear();
  remoteServerAdmin.close();
  connectionPool.close();
}",0.9696969696969696
80128,"/** 
 * Check whether there exist a schema enforced over OrientDB document class.
 */
@Override public boolean schemaExists(){
  ODatabaseDocumentTx schemaTx=connectionPool.acquire();
  schemaTx.activateOnCurrentThread();
  try {
    return schemaTx.getMetadata().getSchema().existsClass(orientDBMapping.getDocumentClass());
  }
  finally {
    schemaTx.close();
  }
}","/** 
 * {@inheritDoc}Check whether there exist a schema enforced over OrientDB document class.
 */
@Override public boolean schemaExists(){
  ODatabaseDocumentTx schemaTx=connectionPool.acquire();
  schemaTx.activateOnCurrentThread();
  try {
    return schemaTx.getMetadata().getSchema().existsClass(orientDBMapping.getDocumentClass());
  }
  finally {
    schemaTx.close();
  }
}",0.9826435246995996
80129,"/** 
 * Create a new class of OrientDB documents if necessary. Enforce specified schema over the document class.
 */
@Override public void createSchema(){
  if (schemaExists()) {
    return;
  }
  ODatabaseDocumentTx schemaTx=connectionPool.acquire();
  schemaTx.activateOnCurrentThread();
  try {
    OClass documentClass=schemaTx.getMetadata().getSchema().createClass(orientDBMapping.getDocumentClass());
    documentClass.createProperty(""String_Node_Str"",OType.getTypeByClass(super.getKeyClass())).createIndex(OClass.INDEX_TYPE.UNIQUE);
    for (    String docField : orientDBMapping.getDocumentFields()) {
      documentClass.createProperty(docField,OType.valueOf(orientDBMapping.getDocumentFieldType(docField).name()));
    }
    schemaTx.getMetadata().getSchema().reload();
  }
  finally {
    schemaTx.close();
  }
}","/** 
 * {@inheritDoc}Create a new class of OrientDB documents if necessary. Enforce specified schema over the document class.   
 */
@Override public void createSchema(){
  if (schemaExists()) {
    return;
  }
  ODatabaseDocumentTx schemaTx=connectionPool.acquire();
  schemaTx.activateOnCurrentThread();
  try {
    OClass documentClass=schemaTx.getMetadata().getSchema().createClass(orientDBMapping.getDocumentClass());
    documentClass.createProperty(""String_Node_Str"",OType.getTypeByClass(super.getKeyClass())).createIndex(OClass.INDEX_TYPE.UNIQUE);
    for (    String docField : orientDBMapping.getDocumentFields()) {
      documentClass.createProperty(docField,OType.valueOf(orientDBMapping.getDocumentFieldType(docField).name()));
    }
    schemaTx.getMetadata().getSchema().reload();
  }
  finally {
    schemaTx.close();
  }
}",0.9903730445246692
80130,"@Override public Result<K,T> execute(Query<K,T> query){
  String[] fields=getFieldsToQuery(query.getFields());
  OrientDBQuery dataStoreQuery;
  if (query instanceof OrientDBQuery) {
    dataStoreQuery=((OrientDBQuery)query);
  }
 else {
    dataStoreQuery=(OrientDBQuery)((PartitionQueryImpl<K,T>)query).getBaseQuery();
  }
  dataStoreQuery.populateOrientDBQuery(orientDBMapping,fields,getFields());
  ODatabaseDocumentTx selectTx=connectionPool.acquire();
  selectTx.activateOnCurrentThread();
  try {
    OConcurrentResultSet<ODocument> result=selectTx.command(dataStoreQuery.getOrientDBQuery()).execute(dataStoreQuery.getParams());
    result.setLimit((int)query.getLimit());
    return new OrientDBResult<K,T>(this,query,result);
  }
  finally {
    selectTx.close();
  }
}","/** 
 * {@inheritDoc}
 */
@Override public Result<K,T> execute(Query<K,T> query){
  String[] fields=getFieldsToQuery(query.getFields());
  OrientDBQuery dataStoreQuery;
  if (query instanceof OrientDBQuery) {
    dataStoreQuery=((OrientDBQuery)query);
  }
 else {
    dataStoreQuery=(OrientDBQuery)((PartitionQueryImpl<K,T>)query).getBaseQuery();
  }
  dataStoreQuery.populateOrientDBQuery(orientDBMapping,fields,getFields());
  ODatabaseDocumentTx selectTx=connectionPool.acquire();
  selectTx.activateOnCurrentThread();
  try {
    OConcurrentResultSet<ODocument> result=selectTx.command(dataStoreQuery.getOrientDBQuery()).execute(dataStoreQuery.getParams());
    result.setLimit((int)query.getLimit());
    return new OrientDBResult<K,T>(this,query,result);
  }
  finally {
    selectTx.close();
  }
}",0.9835651074589128
80131,"/** 
 * Initialize the OrientDB dataStore by   {@link Properties} parameters.
 * @param keyClass key class type for dataStore.
 * @param persistentClass persistent class type for dataStore.
 * @param properties OrientDB dataStore properties EG:- OrientDB client credentials.
 */
@Override public void initialize(Class<K> keyClass,Class<T> persistentClass,Properties properties){
  super.initialize(keyClass,persistentClass,properties);
  try {
    orientDbStoreParams=OrientDBStoreParameters.load(properties);
    ROOT_URL=""String_Node_Str"".concat(orientDbStoreParams.getServerHost()).concat(""String_Node_Str"").concat(orientDbStoreParams.getServerPort());
    ROOT_DATABASE_URL=ROOT_URL.concat(""String_Node_Str"").concat(orientDbStoreParams.getDatabaseName());
    remoteServerAdmin=new OServerAdmin(ROOT_URL).connect(orientDbStoreParams.getUserName(),orientDbStoreParams.getUserPassword());
    if (!remoteServerAdmin.existsDatabase(orientDbStoreParams.getDatabaseName(),""String_Node_Str"")) {
      remoteServerAdmin.createDatabase(orientDbStoreParams.getDatabaseName(),""String_Node_Str"",""String_Node_Str"");
    }
    if (orientDbStoreParams.getConnectionPoolSize() != null) {
      int connPoolSize=Integer.valueOf(orientDbStoreParams.getConnectionPoolSize());
      connectionPool=new OPartitionedDatabasePoolFactory(connPoolSize).get(ROOT_DATABASE_URL,orientDbStoreParams.getUserName(),orientDbStoreParams.getUserPassword());
    }
 else {
      connectionPool=new OPartitionedDatabasePoolFactory().get(ROOT_DATABASE_URL,orientDbStoreParams.getUserName(),orientDbStoreParams.getUserPassword());
    }
    OrientDBMappingBuilder<K,T> builder=new OrientDBMappingBuilder<>(this);
    orientDBMapping=builder.fromFile(orientDbStoreParams.getMappingFile()).build();
    if (!schemaExists()) {
      createSchema();
    }
  }
 catch (  Exception e) {
    LOG.error(""String_Node_Str"",new Object[]{e.getMessage()});
    throw new RuntimeException(e);
  }
}","/** 
 * {@inheritDoc}Initialize the OrientDB dataStore by   {@link Properties} parameters.
 * @param keyClass key class type for dataStore.
 * @param persistentClass persistent class type for dataStore.
 * @param properties OrientDB dataStore properties EG:- OrientDB client credentials.
 */
@Override public void initialize(Class<K> keyClass,Class<T> persistentClass,Properties properties){
  super.initialize(keyClass,persistentClass,properties);
  try {
    orientDbStoreParams=OrientDBStoreParameters.load(properties);
    ROOT_URL=""String_Node_Str"".concat(orientDbStoreParams.getServerHost()).concat(""String_Node_Str"").concat(orientDbStoreParams.getServerPort());
    ROOT_DATABASE_URL=ROOT_URL.concat(""String_Node_Str"").concat(orientDbStoreParams.getDatabaseName());
    remoteServerAdmin=new OServerAdmin(ROOT_URL).connect(orientDbStoreParams.getUserName(),orientDbStoreParams.getUserPassword());
    if (!remoteServerAdmin.existsDatabase(orientDbStoreParams.getDatabaseName(),""String_Node_Str"")) {
      remoteServerAdmin.createDatabase(orientDbStoreParams.getDatabaseName(),""String_Node_Str"",""String_Node_Str"");
    }
    if (orientDbStoreParams.getConnectionPoolSize() != null) {
      int connPoolSize=Integer.valueOf(orientDbStoreParams.getConnectionPoolSize());
      connectionPool=new OPartitionedDatabasePoolFactory(connPoolSize).get(ROOT_DATABASE_URL,orientDbStoreParams.getUserName(),orientDbStoreParams.getUserPassword());
    }
 else {
      connectionPool=new OPartitionedDatabasePoolFactory().get(ROOT_DATABASE_URL,orientDbStoreParams.getUserName(),orientDbStoreParams.getUserPassword());
    }
    OrientDBMappingBuilder<K,T> builder=new OrientDBMappingBuilder<>(this);
    orientDBMapping=builder.fromFile(orientDbStoreParams.getMappingFile()).build();
    if (!schemaExists()) {
      createSchema();
    }
  }
 catch (  Exception e) {
    LOG.error(""String_Node_Str"",new Object[]{e.getMessage()});
    throw new RuntimeException(e);
  }
}",0.9966794380587484
80132,"/** 
 * Extraction OrientDB dataStore properties from   {@link Properties} gora.properties file.
 * @return OrientDB client properties encapsulated inside instance of {@link OrientDBStoreParameters}
 */
public static OrientDBStoreParameters load(Properties properties){
  String propMappingFile=properties.getProperty(ORIENT_DB_MAPPING_FILE,OrientDBStore.DEFAULT_MAPPING_FILE);
  String propServerHost=properties.getProperty(ORIENT_DB_SERVER_HOST);
  String propServerPort=properties.getProperty(ORIENT_DB_SERVER_PORT);
  String propUserName=properties.getProperty(ORIENT_DB_USER_USERNAME);
  String propUserPassword=properties.getProperty(ORIENT_DB_USER_PASSWORD);
  String propDatabaseName=properties.getProperty(ORIENT_DB_DB_NAME);
  String propConnPoolSize=properties.getProperty(ORIENT_DB_CONNECTION_POOL_SIZE);
  String propStorageType=properties.getProperty(ORIENT_DB_STORAGE_TYPE);
  return new OrientDBStoreParameters(propMappingFile,propServerHost,propServerPort,propUserName,propUserPassword,propDatabaseName,propConnPoolSize,propStorageType);
}","/** 
 * Extraction OrientDB dataStore properties from   {@link Properties} gora.properties file.
 * @param properties gora.properties properties related to datastore client.
 * @return OrientDB client properties encapsulated inside instance of {@link OrientDBStoreParameters}
 */
public static OrientDBStoreParameters load(Properties properties){
  String propMappingFile=properties.getProperty(ORIENT_DB_MAPPING_FILE,OrientDBStore.DEFAULT_MAPPING_FILE);
  String propServerHost=properties.getProperty(ORIENT_DB_SERVER_HOST);
  String propServerPort=properties.getProperty(ORIENT_DB_SERVER_PORT);
  String propUserName=properties.getProperty(ORIENT_DB_USER_USERNAME);
  String propUserPassword=properties.getProperty(ORIENT_DB_USER_PASSWORD);
  String propDatabaseName=properties.getProperty(ORIENT_DB_DB_NAME);
  String propConnPoolSize=properties.getProperty(ORIENT_DB_CONNECTION_POOL_SIZE);
  String propStorageType=properties.getProperty(ORIENT_DB_STORAGE_TYPE);
  return new OrientDBStoreParameters(propMappingFile,propServerHost,propServerPort,propUserName,propUserPassword,propDatabaseName,propConnPoolSize,propStorageType);
}",0.964824120603015
80133,"/** 
 * Method to insert the persistent objects with the given key to the aerospike database server. In writing the records, the policy defined in the mapping file is used to decide on the behaviour of transaction handling.
 * @param key        key of the object
 * @param persistent object to be persisted
 */
@Override public void put(K key,T persistent){
  Key recordKey=getAerospikeKey(key);
  List<Field> fields=persistent.getSchema().getFields();
  for (int i=0; i < fields.size(); i++) {
    if (persistent.isDirty(i)) {
      Object persistentValue=persistent.get(i);
      if (persistentValue == null && aerospikeClient.exists(null,recordKey)) {
        this.delete(key);
      }
    }
  }
  for (int i=0; i < fields.size(); i++) {
    if (!persistent.isDirty(i)) {
      continue;
    }
    Object persistentValue=persistent.get(i);
    if (persistentValue != null) {
      String mappingBinName=aerospikeParameters.getAerospikeMapping().getBinMapping().get(fields.get(i).name());
      if (mappingBinName == null) {
        LOG.error(""String_Node_Str"",persistent.getClass().getName(),fields.get(i).name());
        throw new RuntimeException(""String_Node_Str"" + persistent.getClass().getName() + ""String_Node_Str""+ fields.get(i).name()+ ""String_Node_Str"");
      }
      Bin bin=new Bin(mappingBinName,getSerializableValue(persistentValue,fields.get(i).schema()));
      aerospikeClient.put(aerospikeParameters.getAerospikeMapping().getWritePolicy(),recordKey,bin);
    }
  }
}","/** 
 * Method to insert the persistent objects with the given key to the aerospike database server. In writing the records, the policy defined in the mapping file is used to decide on the behaviour of transaction handling.
 * @param key        key of the object
 * @param persistent object to be persisted
 */
@Override public void put(K key,T persistent){
  Key recordKey=getAerospikeKey(key);
  List<Field> fields=persistent.getSchema().getFields();
  for (int i=0; i < fields.size(); i++) {
    if (!persistent.isDirty(i)) {
      continue;
    }
    Object persistentValue=persistent.get(i);
    String mappingBinName=aerospikeParameters.getAerospikeMapping().getBinMapping().get(fields.get(i).name());
    if (mappingBinName == null) {
      LOG.error(""String_Node_Str"",persistent.getClass().getName(),fields.get(i).name());
      throw new RuntimeException(""String_Node_Str"" + persistent.getClass().getName() + ""String_Node_Str""+ fields.get(i).name()+ ""String_Node_Str"");
    }
    Bin bin;
    if (persistentValue != null) {
      bin=new Bin(mappingBinName,getSerializableValue(persistentValue,fields.get(i).schema()));
    }
 else {
      bin=Bin.asNull(mappingBinName);
    }
    aerospikeClient.put(aerospikeParameters.getAerospikeMapping().getWritePolicy(),recordKey,bin);
  }
}",0.7484706729039223
80134,"@Override public void setUpClass() throws Exception {
  properties.setProperty(""String_Node_Str"",""String_Node_Str"");
  properties.setProperty(""String_Node_Str"",aerospikeContainer.getMappedPort(3000).toString());
}","@Override public void setUpClass() throws Exception {
  log.info(""String_Node_Str"");
  properties.setProperty(""String_Node_Str"",""String_Node_Str"");
  properties.setProperty(""String_Node_Str"",aerospikeContainer.getMappedPort(3000).toString());
}",0.9321663019693656
80135,"@Override public void tearDownClass() throws Exception {
  aerospikeContainer.stop();
}","@Override public void tearDownClass() throws Exception {
  log.info(""String_Node_Str"");
}",0.7727272727272727
80136,"/** 
 * Method to get the aerospike key from the provided K
 * @param key persistent key
 * @return aerospike key for the record
 */
public Key getAerospikeKey(K key){
  Value keyValue;
  if (keyClass.getSimpleName().equalsIgnoreCase(""String_Node_Str"")) {
    keyValue=Value.get(key.toString());
  }
 else {
    keyValue=Value.get(key);
  }
  return new Key(aerospikeParameters.getAerospikeMapping().getNamespace(),aerospikeParameters.getAerospikeMapping().getSet(),keyValue);
}","/** 
 * Method to get the aerospike key from the provided K
 * @param key persistent key
 * @return aerospike key for the record
 */
private Key getAerospikeKey(K key){
  Value keyValue;
  if (keyClass.getSimpleName().equalsIgnoreCase(""String_Node_Str"")) {
    keyValue=Value.get(key.toString());
  }
 else {
    keyValue=Value.get(key);
  }
  return new Key(aerospikeParameters.getAerospikeMapping().getNamespace(),aerospikeParameters.getAerospikeMapping().getSet(),keyValue);
}",0.9885057471264368
80137,"/** 
 * Method to create a statement
 * @param namespace the namespace
 * @param set       the set
 * @return the statement
 */
private Statement getStatement(String namespace,String set){
  Statement stmt=new Statement();
  stmt.setNamespace(namespace);
  stmt.setSetName(set);
  return stmt;
}","/** 
 * Method to create a Aerospike specific statement
 * @param namespace the namespace
 * @param set       the set
 * @return the statement
 */
private Statement getStatement(String namespace,String set){
  Statement stmt=new Statement();
  stmt.setNamespace(namespace);
  stmt.setSetName(set);
  return stmt;
}",0.9688013136289
80138,"/** 
 * Instantiate a new   {@link DataStore}. Uses 'null' schema.
 * @param keyClass The key class.
 * @param persistentClass The value class.
 * @return A new store instance.
 * @throws GoraException If an error occur in creating the data store
 */
@Override public <K,T extends Persistent>DataStore<K,T> createDataStore(Class<K> keyClass,Class<T> persistentClass) throws GoraException {
  final DataStore<K,T> dataStore=DataStoreFactory.createDataStore((Class<? extends DataStore<K,T>>)dataStoreClass,keyClass,persistentClass,conf,properties);
  dataStores.add(dataStore);
  log.info(""String_Node_Str"",persistentClass);
  return dataStore;
}","/** 
 * Instantiate a new   {@link DataStore}. Uses 'null' schema.
 * @param keyClass        The key class.
 * @param persistentClass The value class.
 * @return A new store instance.
 * @throws GoraException If an error occur in creating the data store
 */
@Override public <K,T extends Persistent>DataStore<K,T> createDataStore(Class<K> keyClass,Class<T> persistentClass) throws GoraException {
  final DataStore<K,T> dataStore=DataStoreFactory.createDataStore((Class<? extends DataStore<K,T>>)dataStoreClass,keyClass,persistentClass,conf,properties);
  dataStores.add(dataStore);
  log.info(""String_Node_Str"",persistentClass);
  return dataStore;
}",0.9945945945945946
80139,"@SuppressWarnings(""String_Node_Str"") private HBaseMapping readMapping(String filename) throws IOException {
  HBaseMappingBuilder mappingBuilder=new HBaseMappingBuilder();
  try {
    SAXBuilder builder=new SAXBuilder();
    Document doc=builder.build(getClass().getClassLoader().getResourceAsStream(filename));
    Element root=doc.getRootElement();
    List<Element> tableElements=root.getChildren(""String_Node_Str"");
    for (    Element tableElement : tableElements) {
      String tableName=tableElement.getAttributeValue(""String_Node_Str"");
      List<Element> fieldElements=tableElement.getChildren(""String_Node_Str"");
      for (      Element fieldElement : fieldElements) {
        String familyName=fieldElement.getAttributeValue(""String_Node_Str"");
        String compression=fieldElement.getAttributeValue(""String_Node_Str"");
        String blockCache=fieldElement.getAttributeValue(""String_Node_Str"");
        String blockSize=fieldElement.getAttributeValue(""String_Node_Str"");
        String bloomFilter=fieldElement.getAttributeValue(""String_Node_Str"");
        String maxVersions=fieldElement.getAttributeValue(""String_Node_Str"");
        String timeToLive=fieldElement.getAttributeValue(""String_Node_Str"");
        String inMemory=fieldElement.getAttributeValue(""String_Node_Str"");
        mappingBuilder.addFamilyProps(tableName,familyName,compression,blockCache,blockSize,bloomFilter,maxVersions,timeToLive,inMemory);
      }
    }
    List<Element> classElements=root.getChildren(""String_Node_Str"");
    for (    Element classElement : classElements) {
      if (classElement.getAttributeValue(""String_Node_Str"").equals(keyClass.getCanonicalName()) && classElement.getAttributeValue(""String_Node_Str"").equals(persistentClass.getCanonicalName())) {
        LOG.debug(""String_Node_Str"");
        String tableNameFromMapping=classElement.getAttributeValue(""String_Node_Str"");
        String tableName=getSchemaName(tableNameFromMapping,persistentClass);
        if (!tableName.equals(tableNameFromMapping)) {
          LOG.warn(""String_Node_Str"",tableNameFromMapping,tableName);
          if (tableNameFromMapping != null) {
            mappingBuilder.renameTable(tableNameFromMapping,tableName);
          }
        }
        mappingBuilder.setTableName(tableName);
        List<Element> fields=classElement.getChildren(""String_Node_Str"");
        for (        Element field : fields) {
          String fieldName=field.getAttributeValue(""String_Node_Str"");
          String family=field.getAttributeValue(""String_Node_Str"");
          String qualifier=field.getAttributeValue(""String_Node_Str"");
          mappingBuilder.addField(fieldName,family,qualifier);
          mappingBuilder.addColumnFamily(tableName,family);
        }
        break;
      }
 else {
        LOG.error(""String_Node_Str"");
      }
    }
  }
 catch (  MalformedURLException ex) {
    LOG.error(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",filename);
    LOG.error(""String_Node_Str"",Arrays.asList(((URLClassLoader)getClass().getClassLoader()).getURLs()));
    throw ex;
  }
catch (  IOException ex) {
    LOG.error(ex.getMessage(),ex);
    throw ex;
  }
catch (  Exception ex) {
    LOG.error(ex.getMessage(),ex);
    throw new IOException(ex);
  }
  return mappingBuilder.build();
}","@SuppressWarnings(""String_Node_Str"") private HBaseMapping readMapping(String filename) throws IOException {
  HBaseMappingBuilder mappingBuilder=new HBaseMappingBuilder();
  try {
    SAXBuilder builder=new SAXBuilder();
    Document doc=builder.build(getClass().getClassLoader().getResourceAsStream(filename));
    Element root=doc.getRootElement();
    List<Element> tableElements=root.getChildren(""String_Node_Str"");
    for (    Element tableElement : tableElements) {
      String tableName=tableElement.getAttributeValue(""String_Node_Str"");
      List<Element> fieldElements=tableElement.getChildren(""String_Node_Str"");
      for (      Element fieldElement : fieldElements) {
        String familyName=fieldElement.getAttributeValue(""String_Node_Str"");
        String compression=fieldElement.getAttributeValue(""String_Node_Str"");
        String blockCache=fieldElement.getAttributeValue(""String_Node_Str"");
        String blockSize=fieldElement.getAttributeValue(""String_Node_Str"");
        String bloomFilter=fieldElement.getAttributeValue(""String_Node_Str"");
        String maxVersions=fieldElement.getAttributeValue(""String_Node_Str"");
        String timeToLive=fieldElement.getAttributeValue(""String_Node_Str"");
        String inMemory=fieldElement.getAttributeValue(""String_Node_Str"");
        mappingBuilder.addFamilyProps(tableName,familyName,compression,blockCache,blockSize,bloomFilter,maxVersions,timeToLive,inMemory);
      }
    }
    List<Element> classElements=root.getChildren(""String_Node_Str"");
    boolean keyClassMatches=false;
    for (    Element classElement : classElements) {
      if (classElement.getAttributeValue(""String_Node_Str"").equals(keyClass.getCanonicalName()) && classElement.getAttributeValue(""String_Node_Str"").equals(persistentClass.getCanonicalName())) {
        LOG.debug(""String_Node_Str"");
        keyClassMatches=true;
        String tableNameFromMapping=classElement.getAttributeValue(""String_Node_Str"");
        String tableName=getSchemaName(tableNameFromMapping,persistentClass);
        if (!tableName.equals(tableNameFromMapping)) {
          LOG.warn(""String_Node_Str"",tableNameFromMapping,tableName);
          if (tableNameFromMapping != null) {
            mappingBuilder.renameTable(tableNameFromMapping,tableName);
          }
        }
        mappingBuilder.setTableName(tableName);
        List<Element> fields=classElement.getChildren(""String_Node_Str"");
        for (        Element field : fields) {
          String fieldName=field.getAttributeValue(""String_Node_Str"");
          String family=field.getAttributeValue(""String_Node_Str"");
          String qualifier=field.getAttributeValue(""String_Node_Str"");
          mappingBuilder.addField(fieldName,family,qualifier);
          mappingBuilder.addColumnFamily(tableName,family);
        }
        break;
      }
    }
    if (!keyClassMatches)     LOG.error(""String_Node_Str"");
  }
 catch (  MalformedURLException ex) {
    LOG.error(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",filename);
    LOG.error(""String_Node_Str"",Arrays.asList(((URLClassLoader)getClass().getClassLoader()).getURLs()));
    throw ex;
  }
catch (  IOException ex) {
    LOG.error(ex.getMessage(),ex);
    throw ex;
  }
catch (  Exception ex) {
    LOG.error(ex.getMessage(),ex);
    throw new IOException(ex);
  }
  return mappingBuilder.build();
}",0.9820971867007672
80140,"public static void testDeleteByQueryFields(DataStore<String,WebPage> store) throws Exception {
  Query<String,WebPage> query;
  WebPageDataCreator.createWebPageData(store);
  query=store.newQuery();
  query.setFields(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  assertNumResults(store.newQuery(),URLS.length);
  store.deleteByQuery(query);
  store.deleteByQuery(query);
  store.deleteByQuery(query);
  store.flush();
  assertNumResults(store.newQuery(),URLS.length);
  for (  String SORTED_URL : SORTED_URLS) {
    WebPage page=store.get(SORTED_URL);
    assertNotNull(page);
    assertNotNull(page.getUrl());
    assertEquals(page.getUrl().toString(),SORTED_URL);
    assertEquals(""String_Node_Str"" + ""String_Node_Str"",0,page.getOutlinks().size());
    assertEquals(0,page.getParsedContent().size());
    if (page.getContent() != null) {
      LOG.info(""String_Node_Str"" + page.getUrl().toString());
      LOG.info(""String_Node_Str"" + page.getContent().limit());
    }
 else {
      assertNull(page.getContent());
    }
  }
  WebPageDataCreator.createWebPageData(store);
  query=store.newQuery();
  query.setFields(""String_Node_Str"");
  String startKey=SORTED_URLS[NUM_KEYS];
  String endKey=SORTED_URLS[SORTED_URLS.length - NUM_KEYS];
  query.setStartKey(startKey);
  query.setEndKey(endKey);
  assertNumResults(store.newQuery(),URLS.length);
  store.deleteByQuery(query);
  store.deleteByQuery(query);
  store.deleteByQuery(query);
  assertNumResults(store.newQuery(),URLS.length);
  for (int i=0; i < URLS.length; i++) {
    store.flush();
    WebPage page=store.get(URLS[i]);
    assertNotNull(page);
    if (URLS[i].compareTo(startKey) < 0 || URLS[i].compareTo(endKey) >= 0) {
      assertWebPage(page,i);
    }
 else {
      assertNull(page.getUrl());
      assertNotNull(page.getOutlinks());
      assertNotNull(page.getParsedContent());
      assertNotNull(page.getContent());
      assertTrue(page.getOutlinks().size() > 0);
      assertTrue(page.getParsedContent().size() > 0);
    }
  }
}","public static void testDeleteByQueryFields(DataStore<String,WebPage> store) throws Exception {
  Query<String,WebPage> query;
  WebPageDataCreator.createWebPageData(store);
  query=store.newQuery();
  query.setFields(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  assertNumResults(store.newQuery(),URLS.length);
  store.deleteByQuery(query);
  store.flush();
  assertNumResults(store.newQuery(),URLS.length);
  for (  String SORTED_URL : SORTED_URLS) {
    WebPage page=store.get(SORTED_URL);
    assertNotNull(page);
    assertNotNull(page.getUrl());
    assertEquals(page.getUrl().toString(),SORTED_URL);
    assertEquals(""String_Node_Str"" + ""String_Node_Str"",0,page.getOutlinks().size());
    assertEquals(0,page.getParsedContent().size());
    if (page.getContent() != null) {
      LOG.info(""String_Node_Str"" + page.getUrl().toString());
      LOG.info(""String_Node_Str"" + page.getContent().limit());
    }
 else {
      assertNull(page.getContent());
    }
  }
  WebPageDataCreator.createWebPageData(store);
  query=store.newQuery();
  query.setFields(""String_Node_Str"");
  String startKey=SORTED_URLS[NUM_KEYS];
  String endKey=SORTED_URLS[SORTED_URLS.length - NUM_KEYS];
  query.setStartKey(startKey);
  query.setEndKey(endKey);
  assertNumResults(store.newQuery(),URLS.length);
  store.deleteByQuery(query);
  store.flush();
  assertNumResults(store.newQuery(),URLS.length);
  for (int i=0; i < URLS.length; i++) {
    WebPage page=store.get(URLS[i]);
    assertNotNull(page);
    if (URLS[i].compareTo(startKey) < 0 || URLS[i].compareTo(endKey) >= 0) {
      assertWebPage(page,i);
    }
 else {
      assertNull(page.getUrl());
      assertNotNull(page.getOutlinks());
      assertNotNull(page.getParsedContent());
      assertNotNull(page.getContent());
      assertTrue(page.getOutlinks().size() > 0);
      assertTrue(page.getParsedContent().size() > 0);
    }
  }
}",0.9656762295081968
80141,"/** 
 * {@inheritDoc} Serializes the Persistent data and saves in HBase. Topmostfields of the record are persisted in ""raw"" format (not avro serialized). This behavior happens in maps and arrays too. [""null"",""type""] type (a.k.a. optional field) is persisted like as if it is [""type""], but the column get deleted if value==null (so value read after will be null).
 * @param persistent Record to be persisted in HBase
 */
@Override public void put(K key,T persistent){
  try {
    Schema schema=persistent.getSchema();
    byte[] keyRaw=toBytes(key);
    Put put=new Put(keyRaw);
    Delete delete=new Delete(keyRaw);
    List<Field> fields=schema.getFields();
    for (int i=0; i < fields.size(); i++) {
      if (!persistent.isDirty(i)) {
        continue;
      }
      Field field=fields.get(i);
      Object o=persistent.get(i);
      HBaseColumn hcol=mapping.getColumn(field.name());
      if (hcol == null) {
        throw new RuntimeException(""String_Node_Str"" + persistent.getClass().getName() + ""String_Node_Str""+ field.name()+ ""String_Node_Str"");
      }
      addPutsAndDeletes(put,delete,o,field.schema().getType(),field.schema(),hcol,hcol.getQualifier());
    }
    if (delete.size() > 0) {
      table.delete(delete);
    }
    if (put.size() > 0) {
      table.put(put);
    }
  }
 catch (  IOException ex2) {
    LOG.error(ex2.getMessage(),ex2);
  }
}","/** 
 * {@inheritDoc} Serializes the Persistent data and saves in HBase. Topmostfields of the record are persisted in ""raw"" format (not avro serialized). This behavior happens in maps and arrays too. [""null"",""type""] type (a.k.a. optional field) is persisted like as if it is [""type""], but the column get deleted if value==null (so value read after will be null).
 * @param persistent Record to be persisted in HBase
 */
@Override public void put(K key,T persistent){
  try {
    Schema schema=persistent.getSchema();
    byte[] keyRaw=toBytes(key);
    long timeStamp=System.currentTimeMillis();
    Put put=new Put(keyRaw,timeStamp - PUTS_AND_DELETES_PUT_TS_OFFSET);
    Delete delete=new Delete(keyRaw,timeStamp - PUTS_AND_DELETES_DELETE_TS_OFFSET);
    List<Field> fields=schema.getFields();
    for (int i=0; i < fields.size(); i++) {
      if (!persistent.isDirty(i)) {
        continue;
      }
      Field field=fields.get(i);
      Object o=persistent.get(i);
      HBaseColumn hcol=mapping.getColumn(field.name());
      if (hcol == null) {
        throw new RuntimeException(""String_Node_Str"" + persistent.getClass().getName() + ""String_Node_Str""+ field.name()+ ""String_Node_Str"");
      }
      addPutsAndDeletes(put,delete,o,field.schema().getType(),field.schema(),hcol,hcol.getQualifier());
    }
    if (delete.size() > 0) {
      table.delete(delete);
    }
    if (put.size() > 0) {
      table.put(put);
    }
  }
 catch (  IOException ex2) {
    LOG.error(ex2.getMessage(),ex2);
  }
}",0.9525801952580196
80142,"public void flushCommits() throws IOException {
  BufferedMutator bufMutator=connection.getBufferedMutator(this.tableName);
  for (  ConcurrentLinkedQueue<Mutation> buffer : bPool) {
    for (    Mutation m : buffer) {
      bufMutator.mutate(m);
    }
  }
  bufMutator.flush();
  bufMutator.close();
}","public void flushCommits() throws IOException {
  BufferedMutator bufMutator=connection.getBufferedMutator(this.tableName);
  for (  ConcurrentLinkedQueue<Mutation> buffer : bPool) {
    while (!buffer.isEmpty()) {
      Mutation m=buffer.poll();
      bufMutator.mutate(m);
    }
  }
  bufMutator.flush();
  bufMutator.close();
}",0.8670886075949367
80143,"private boolean checkIfMutableFieldAndDirty(Field field){
  if (field.pos() == 0)   return false;
switch (field.schema().getType()) {
case RECORD:
case MAP:
case ARRAY:
    Object value=get(field.pos());
  return !(value instanceof Dirtyable) || value == null ? false : ((Dirtyable)value).isDirty();
case UNION:
value=get(field.pos());
return !(value instanceof Dirtyable) || value == null ? false : ((Dirtyable)value).isDirty();
default :
break;
}
return false;
}","private boolean checkIfMutableFieldAndDirty(Field field){
switch (field.schema().getType()) {
case RECORD:
case MAP:
case ARRAY:
    Object value=get(field.pos());
  return !(value instanceof Dirtyable) || value == null ? false : ((Dirtyable)value).isDirty();
case UNION:
value=get(field.pos());
return !(value instanceof Dirtyable) || value == null ? false : ((Dirtyable)value).isDirty();
default :
break;
}
return false;
}",0.954954954954955
80144,"private void clearDirynessIfFieldIsDirtyable(int fieldIndex){
  if (fieldIndex == 0)   return;
  Object value=get(fieldIndex);
  if (value instanceof Dirtyable) {
    ((Dirtyable)value).clearDirty();
  }
}","private void clearDirynessIfFieldIsDirtyable(int fieldIndex){
  Object value=get(fieldIndex);
  if (value instanceof Dirtyable) {
    ((Dirtyable)value).clearDirty();
  }
}",0.9124668435013262
80145,"/** 
 * {@inheritDoc} Serializes the Persistent data and saves in HBase. Topmostfields of the record are persisted in ""raw"" format (not avro serialized). This behavior happens in maps and arrays too. [""null"",""type""] type (a.k.a. optional field) is persisted like as if it is [""type""], but the column get deleted if value==null (so value read after will be null).
 * @param persistent Record to be persisted in HBase
 */
@Override public void put(K key,T persistent){
  try {
    Schema schema=persistent.getSchema();
    byte[] keyRaw=toBytes(key);
    Put put=new Put(keyRaw);
    Delete delete=new Delete(keyRaw);
    List<Field> fields=schema.getFields();
    for (int i=0; i < fields.size(); i++) {
      if (!persistent.isDirty(i)) {
        continue;
      }
      Field field=fields.get(i);
      Object o=persistent.get(i);
      HBaseColumn hcol=mapping.getColumn(field.name());
      if (hcol == null) {
        throw new RuntimeException(""String_Node_Str"" + persistent.getClass().getName() + ""String_Node_Str""+ field.name()+ ""String_Node_Str"");
      }
      addPutsAndDeletes(put,delete,o,field.schema().getType(),field.schema(),hcol,hcol.getQualifier());
    }
    if (delete.size() > 0) {
      table.delete(delete);
    }
    if (put.size() > 0) {
      table.put(put);
    }
  }
 catch (  IOException ex2) {
    LOG.error(ex2.getMessage(),ex2);
  }
}","/** 
 * {@inheritDoc} Serializes the Persistent data and saves in HBase. Topmostfields of the record are persisted in ""raw"" format (not avro serialized). This behavior happens in maps and arrays too. [""null"",""type""] type (a.k.a. optional field) is persisted like as if it is [""type""], but the column get deleted if value==null (so value read after will be null).
 * @param persistent Record to be persisted in HBase
 */
@Override public void put(K key,T persistent){
  try {
    Schema schema=persistent.getSchema();
    byte[] keyRaw=toBytes(key);
    long timeStamp=System.currentTimeMillis();
    Put put=new Put(keyRaw,timeStamp - PUTS_AND_DELETES_PUT_TS_OFFSET);
    Delete delete=new Delete(keyRaw,timeStamp - PUTS_AND_DELETES_DELETE_TS_OFFSET);
    List<Field> fields=schema.getFields();
    for (int i=0; i < fields.size(); i++) {
      if (!persistent.isDirty(i)) {
        continue;
      }
      Field field=fields.get(i);
      Object o=persistent.get(i);
      HBaseColumn hcol=mapping.getColumn(field.name());
      if (hcol == null) {
        throw new RuntimeException(""String_Node_Str"" + persistent.getClass().getName() + ""String_Node_Str""+ field.name()+ ""String_Node_Str"");
      }
      addPutsAndDeletes(put,delete,o,field.schema().getType(),field.schema(),hcol,hcol.getQualifier());
    }
    if (delete.size() > 0) {
      table.delete(delete);
    }
    if (put.size() > 0) {
      table.put(put);
    }
  }
 catch (  IOException ex2) {
    LOG.error(ex2.getMessage(),ex2);
  }
}",0.9525801952580196
80146,"public void flushCommits() throws IOException {
  BufferedMutator bufMutator=connection.getBufferedMutator(this.tableName);
  for (  ConcurrentLinkedQueue<Mutation> buffer : bPool) {
    for (    Mutation m : buffer) {
      bufMutator.mutate(m);
      bufMutator.flush();
    }
  }
  bufMutator.close();
}","public void flushCommits() throws IOException {
  BufferedMutator bufMutator=connection.getBufferedMutator(this.tableName);
  for (  ConcurrentLinkedQueue<Mutation> buffer : bPool) {
    while (!buffer.isEmpty()) {
      Mutation m=buffer.poll();
      bufMutator.mutate(m);
    }
  }
  bufMutator.flush();
  bufMutator.close();
}",0.7327044025157232
80147,"public static void testDeleteByQueryFields(DataStore<String,WebPage> store) throws Exception {
  Query<String,WebPage> query;
  WebPageDataCreator.createWebPageData(store);
  query=store.newQuery();
  query.setFields(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  assertNumResults(store.newQuery(),URLS.length);
  store.deleteByQuery(query);
  store.deleteByQuery(query);
  store.deleteByQuery(query);
  store.flush();
  assertNumResults(store.newQuery(),URLS.length);
  for (  String SORTED_URL : SORTED_URLS) {
    WebPage page=store.get(SORTED_URL);
    assertNotNull(page);
    assertNotNull(page.getUrl());
    assertEquals(page.getUrl().toString(),SORTED_URL);
    assertEquals(""String_Node_Str"" + ""String_Node_Str"",0,page.getOutlinks().size());
    assertEquals(0,page.getParsedContent().size());
    if (page.getContent() != null) {
      LOG.info(""String_Node_Str"" + page.getUrl().toString());
      LOG.info(""String_Node_Str"" + page.getContent().limit());
    }
 else {
      assertNull(page.getContent());
    }
  }
  WebPageDataCreator.createWebPageData(store);
  query=store.newQuery();
  query.setFields(""String_Node_Str"");
  String startKey=SORTED_URLS[NUM_KEYS];
  String endKey=SORTED_URLS[SORTED_URLS.length - NUM_KEYS];
  query.setStartKey(startKey);
  query.setEndKey(endKey);
  assertNumResults(store.newQuery(),URLS.length);
  store.deleteByQuery(query);
  store.deleteByQuery(query);
  store.deleteByQuery(query);
  assertNumResults(store.newQuery(),URLS.length);
  for (int i=0; i < URLS.length; i++) {
    store.flush();
    WebPage page=store.get(URLS[i]);
    assertNotNull(page);
    if (URLS[i].compareTo(startKey) < 0 || URLS[i].compareTo(endKey) >= 0) {
      assertWebPage(page,i);
    }
 else {
      assertNull(page.getUrl());
      assertNotNull(page.getOutlinks());
      assertNotNull(page.getParsedContent());
      assertNotNull(page.getContent());
      assertTrue(page.getOutlinks().size() > 0);
      assertTrue(page.getParsedContent().size() > 0);
    }
  }
}","public static void testDeleteByQueryFields(DataStore<String,WebPage> store) throws Exception {
  Query<String,WebPage> query;
  WebPageDataCreator.createWebPageData(store);
  query=store.newQuery();
  query.setFields(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  assertNumResults(store.newQuery(),URLS.length);
  store.deleteByQuery(query);
  store.flush();
  assertNumResults(store.newQuery(),URLS.length);
  for (  String SORTED_URL : SORTED_URLS) {
    WebPage page=store.get(SORTED_URL);
    assertNotNull(page);
    assertNotNull(page.getUrl());
    assertEquals(page.getUrl().toString(),SORTED_URL);
    assertEquals(""String_Node_Str"" + ""String_Node_Str"",0,page.getOutlinks().size());
    assertEquals(0,page.getParsedContent().size());
    if (page.getContent() != null) {
      LOG.info(""String_Node_Str"" + page.getUrl().toString());
      LOG.info(""String_Node_Str"" + page.getContent().limit());
    }
 else {
      assertNull(page.getContent());
    }
  }
  WebPageDataCreator.createWebPageData(store);
  query=store.newQuery();
  query.setFields(""String_Node_Str"");
  String startKey=SORTED_URLS[NUM_KEYS];
  String endKey=SORTED_URLS[SORTED_URLS.length - NUM_KEYS];
  query.setStartKey(startKey);
  query.setEndKey(endKey);
  assertNumResults(store.newQuery(),URLS.length);
  store.deleteByQuery(query);
  store.flush();
  assertNumResults(store.newQuery(),URLS.length);
  for (int i=0; i < URLS.length; i++) {
    WebPage page=store.get(URLS[i]);
    assertNotNull(page);
    if (URLS[i].compareTo(startKey) < 0 || URLS[i].compareTo(endKey) >= 0) {
      assertWebPage(page,i);
    }
 else {
      assertNull(page.getUrl());
      assertNotNull(page.getOutlinks());
      assertNotNull(page.getParsedContent());
      assertNotNull(page.getContent());
      assertTrue(page.getOutlinks().size() > 0);
      assertTrue(page.getParsedContent().size() > 0);
    }
  }
}",0.9656762295081968
80148,"public void flushCommits() throws IOException {
  BufferedMutator bufMutator=connection.getBufferedMutator(this.tableName);
  for (  ConcurrentLinkedQueue<Mutation> buffer : bPool) {
    for (    Mutation m : buffer) {
      bufMutator.mutate(m);
    }
  }
  bufMutator.flush();
  bufMutator.close();
}","public void flushCommits() throws IOException {
  BufferedMutator bufMutator=connection.getBufferedMutator(this.tableName);
  for (  ConcurrentLinkedQueue<Mutation> buffer : bPool) {
    for (    Mutation m : buffer) {
      bufMutator.mutate(m);
      bufMutator.flush();
    }
  }
  bufMutator.close();
}",0.9046052631578948
80149,"private void addFamilyOrColumn(Delete delete,HBaseColumn col,Schema fieldSchema){
switch (fieldSchema.getType()) {
case UNION:
    int index=getResolvedUnionIndex(fieldSchema);
  Schema resolvedSchema=fieldSchema.getTypes().get(index);
addFamilyOrColumn(delete,col,resolvedSchema);
break;
case MAP:
case ARRAY:
delete.addFamily(col.family);
break;
default :
delete.addColumn(col.family,col.qualifier);
break;
}
}","private void addFamilyOrColumn(Delete delete,HBaseColumn col,Schema fieldSchema){
switch (fieldSchema.getType()) {
case UNION:
    int index=getResolvedUnionIndex(fieldSchema);
  Schema resolvedSchema=fieldSchema.getTypes().get(index);
addFamilyOrColumn(delete,col,resolvedSchema);
break;
case MAP:
case ARRAY:
delete.addFamily(col.family);
break;
default :
delete.addColumns(col.family,col.qualifier);
break;
}
}",0.9987878787878788
80150,"private void addPutsAndDeletes(Put put,Delete delete,Object o,Type type,Schema schema,HBaseColumn hcol,byte[] qualifier) throws IOException {
switch (type) {
case UNION:
    if (isNullable(schema) && o == null) {
      if (qualifier == null) {
        delete.addFamily(hcol.getFamily());
      }
 else {
        delete.addColumn(hcol.getFamily(),qualifier);
      }
    }
 else {
      int index=getResolvedUnionIndex(schema);
      if (index > 1) {
        byte[] serializedBytes=toBytes(o,schema);
        put.addColumn(hcol.getFamily(),qualifier,serializedBytes);
      }
 else {
        Schema resolvedSchema=schema.getTypes().get(index);
        addPutsAndDeletes(put,delete,o,resolvedSchema.getType(),resolvedSchema,hcol,qualifier);
      }
    }
  break;
case MAP:
if (qualifier == null) {
  delete.addFamily(hcol.getFamily());
}
 else {
  delete.addColumn(hcol.getFamily(),qualifier);
}
@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) Set<Entry> set=((Map)o).entrySet();
for (@SuppressWarnings(""String_Node_Str"") Entry entry : set) {
byte[] qual=toBytes(entry.getKey());
addPutsAndDeletes(put,delete,entry.getValue(),schema.getValueType().getType(),schema.getValueType(),hcol,qual);
}
break;
case ARRAY:
List<?> array=(List<?>)o;
int j=0;
for (Object item : array) {
addPutsAndDeletes(put,delete,item,schema.getElementType().getType(),schema.getElementType(),hcol,Bytes.toBytes(j++));
}
break;
default :
byte[] serializedBytes=toBytes(o,schema);
put.addColumn(hcol.getFamily(),qualifier,serializedBytes);
break;
}
}","private void addPutsAndDeletes(Put put,Delete delete,Object o,Type type,Schema schema,HBaseColumn hcol,byte[] qualifier) throws IOException {
switch (type) {
case UNION:
    if (isNullable(schema) && o == null) {
      if (qualifier == null) {
        delete.addFamily(hcol.getFamily());
      }
 else {
        delete.addColumns(hcol.getFamily(),qualifier);
      }
    }
 else {
      int index=getResolvedUnionIndex(schema);
      if (index > 1) {
        byte[] serializedBytes=toBytes(o,schema);
        put.addColumn(hcol.getFamily(),qualifier,serializedBytes);
      }
 else {
        Schema resolvedSchema=schema.getTypes().get(index);
        addPutsAndDeletes(put,delete,o,resolvedSchema.getType(),resolvedSchema,hcol,qualifier);
      }
    }
  break;
case MAP:
if (qualifier == null) {
  delete.addFamily(hcol.getFamily());
}
 else {
  delete.addColumns(hcol.getFamily(),qualifier);
}
@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) Set<Entry> set=((Map)o).entrySet();
for (@SuppressWarnings(""String_Node_Str"") Entry entry : set) {
byte[] qual=toBytes(entry.getKey());
addPutsAndDeletes(put,delete,entry.getValue(),schema.getValueType().getType(),schema.getValueType(),hcol,qual);
}
break;
case ARRAY:
List<?> array=(List<?>)o;
int j=0;
for (Object item : array) {
addPutsAndDeletes(put,delete,item,schema.getElementType().getType(),schema.getElementType(),hcol,Bytes.toBytes(j++));
}
break;
default :
byte[] serializedBytes=toBytes(o,schema);
put.addColumn(hcol.getFamily(),qualifier,serializedBytes);
break;
}
}",0.9993476842791912
80151,"/** 
 * Retrieve an entry from the store with only selected fields.
 * @param key    identifier of the document in the database
 * @param fields list of fields to be loaded from the database
 */
@Override public T get(final K key,final String[] fields){
  final Map result;
  try {
    result=db.get(Map.class,key.toString());
    return newInstance(result,getFieldsToQuery(fields));
  }
 catch (  Exception e) {
    LOG.info(e.getMessage(),e);
    return null;
  }
}","/** 
 * Retrieve an entry from the store with only selected fields.
 * @param key    identifier of the document in the database
 * @param fields list of fields to be loaded from the database
 */
@Override public T get(final K key,final String[] fields){
  final Map<String,Object> result;
  try {
    result=db.get(Map.class,key.toString());
    return newInstance(result,getFieldsToQuery(fields));
  }
 catch (  Exception e) {
    LOG.info(e.getMessage(),e);
    return null;
  }
}",0.9841938883034772
80152,"/** 
 * Utility method by velocity templates to generate serialVersionUID on AVRO beans.
 * @param schema Data bean AVRO schema.
 */
public static long fingerprint64(Schema schema){
  return SchemaNormalization.parsingFingerprint64(schema);
}","/** 
 * Utility method used by velocity templates to generate serialVersionUID on AVRO beans.
 * @param schema Data bean AVRO schema.
 * @return serialVersionUID for Serializable AVRO databeans.
 */
public static long fingerprint64(Schema schema){
  return SchemaNormalization.parsingFingerprint64(schema);
}",0.88
80153,"/** 
 * @return set a {@link org.apache.gora.cassandra.query.CassandraQuery}
 */
public void setQuery(Query<K,T> query){
  this.query=query;
}","/** 
 * @param query set a {@link org.apache.gora.cassandra.query.CassandraQuery}
 */
public void setQuery(Query<K,T> query){
  this.query=query;
}",0.9619377162629758
80154,"/** 
 * Check if keyspace already exists.
 */
public boolean keyspaceExists(){
  KeyspaceDefinition keyspaceDefinition=this.cluster.describeKeyspace(this.cassandraMapping.getKeyspaceName());
  return (keyspaceDefinition != null);
}","/** 
 * Check if keyspace already exists.
 * @return if keyspace already exists return true.
 */
public boolean keyspaceExists(){
  KeyspaceDefinition keyspaceDefinition=this.cluster.describeKeyspace(this.cassandraMapping.getKeyspaceName());
  return (keyspaceDefinition != null);
}",0.9005847953216374
80155,"@SafeVarargs @SuppressWarnings(""String_Node_Str"") public static <T>void testSerializeDeserialize(T... objects) throws Exception {
  ByteBufferOutputStream os=new ByteBufferOutputStream();
  DataOutputStream dos=new DataOutputStream(os);
  ByteBufferInputStream is=null;
  DataInputStream dis=null;
  GoraMapReduceUtils.setIOSerializations(conf,true);
  try {
    for (    T before : objects) {
      IOUtils.serialize(conf,dos,before,(Class<T>)before.getClass());
      dos.flush();
    }
    is=new ByteBufferInputStream(os.getBufferList());
    dis=new DataInputStream(is);
    for (    T before : objects) {
      T after=IOUtils.deserialize(conf,dis,null,(Class<T>)before.getClass());
      if (before instanceof BoolArrayWrapper) {
        if (after instanceof BoolArrayWrapper) {
          log.info(""String_Node_Str"" + java.util.Arrays.toString(((BoolArrayWrapper)before).arr));
          log.info(""String_Node_Str"" + java.util.Arrays.toString(((BoolArrayWrapper)after).arr));
        }
      }
 else       if (before instanceof StringArrayWrapper) {
        if (after instanceof StringArrayWrapper) {
          log.info(""String_Node_Str"" + java.util.Arrays.toString(((StringArrayWrapper)before).arr));
          log.info(""String_Node_Str"" + java.util.Arrays.toString(((StringArrayWrapper)after).arr));
        }
      }
 else {
        log.info(""String_Node_Str"" + before);
        log.info(""String_Node_Str"" + before);
      }
      assertEquals(before,after);
    }
    try {
      long skipped=dis.skip(1);
      assertEquals(0,skipped);
    }
 catch (    EOFException expected) {
    }
  }
  finally {
    org.apache.hadoop.io.IOUtils.closeStream(dos);
    org.apache.hadoop.io.IOUtils.closeStream(os);
    org.apache.hadoop.io.IOUtils.closeStream(dis);
    org.apache.hadoop.io.IOUtils.closeStream(is);
  }
}","@SafeVarargs @SuppressWarnings(""String_Node_Str"") public static <T>void testSerializeDeserialize(T... objects) throws Exception {
  ByteBufferOutputStream os=new ByteBufferOutputStream();
  DataOutputStream dos=new DataOutputStream(os);
  ByteBufferInputStream is=null;
  DataInputStream dis=null;
  GoraMapReduceUtils.setIOSerializations(conf,true);
  try {
    for (    T before : objects) {
      IOUtils.serialize(conf,dos,before,(Class<T>)before.getClass());
      dos.flush();
    }
    is=new ByteBufferInputStream(os.getBufferList());
    dis=new DataInputStream(is);
    for (    T before : objects) {
      T after=IOUtils.deserialize(conf,dis,null,(Class<T>)before.getClass());
      if (before instanceof BoolArrayWrapper) {
        if (after instanceof BoolArrayWrapper) {
          log.info(""String_Node_Str"" + java.util.Arrays.toString(((BoolArrayWrapper)before).arr));
          log.info(""String_Node_Str"" + java.util.Arrays.toString(((BoolArrayWrapper)after).arr));
        }
      }
 else       if (before instanceof StringArrayWrapper) {
        if (after instanceof StringArrayWrapper) {
          log.info(""String_Node_Str"" + java.util.Arrays.toString(((StringArrayWrapper)before).arr));
          log.info(""String_Node_Str"" + java.util.Arrays.toString(((StringArrayWrapper)after).arr));
        }
      }
 else {
        log.info(""String_Node_Str"" + before);
        log.info(""String_Node_Str"" + before);
      }
      assertEquals(before,after);
    }
    long skipped=dis.skip(1);
    assertEquals(0,skipped);
  }
 catch (  EOFException expected) {
  }
 finally {
    org.apache.hadoop.io.IOUtils.closeStream(dos);
    org.apache.hadoop.io.IOUtils.closeStream(os);
    org.apache.hadoop.io.IOUtils.closeStream(dis);
    org.apache.hadoop.io.IOUtils.closeStream(is);
  }
}",0.9930843706777316
80156,"@Override public void onUpdated(Iterable<CacheEntryEvent<? extends K,? extends T>> cacheEntryEvents) throws CacheEntryListenerException {
  if (cacheEntryList == null) {
    return;
  }
  for (  CacheEntryEvent<? extends K,? extends T> event : cacheEntryEvents) {
    LOG.info(""String_Node_Str"",event.getKey().toString());
  }
}","@Override public void onUpdated(Iterable<CacheEntryEvent<? extends K,? extends T>> cacheEntryEvents) throws CacheEntryListenerException {
  for (  CacheEntryEvent<? extends K,? extends T> event : cacheEntryEvents) {
    LOG.info(""String_Node_Str"",event.getKey().toString());
  }
}",0.9210526315789472
80157,"@Override public void onExpired(Iterable<CacheEntryEvent<? extends K,? extends T>> cacheEntryEvents) throws CacheEntryListenerException {
  if (cacheEntryList == null) {
    return;
  }
  for (  CacheEntryEvent<? extends K,? extends T> event : cacheEntryEvents) {
    LOG.warn(""String_Node_Str"",event.getKey().toString());
  }
}","@Override public void onExpired(Iterable<CacheEntryEvent<? extends K,? extends T>> cacheEntryEvents) throws CacheEntryListenerException {
  for (  CacheEntryEvent<? extends K,? extends T> event : cacheEntryEvents) {
    LOG.warn(""String_Node_Str"",event.getKey().toString());
  }
}",0.9210526315789472
80158,"@Override public void onRemoved(Iterable<CacheEntryEvent<? extends K,? extends T>> cacheEntryEvents) throws CacheEntryListenerException {
  if (cacheEntryList == null) {
    return;
  }
  for (  CacheEntryEvent<? extends K,? extends T> event : cacheEntryEvents) {
    cacheEntryList.remove(event.getKey());
    LOG.info(""String_Node_Str"",event.getKey().toString());
  }
}","@Override public void onRemoved(Iterable<CacheEntryEvent<? extends K,? extends T>> cacheEntryEvents) throws CacheEntryListenerException {
  for (  CacheEntryEvent<? extends K,? extends T> event : cacheEntryEvents) {
    cacheEntryList.remove(event.getKey());
    LOG.info(""String_Node_Str"",event.getKey().toString());
  }
}",0.930835734870317
80159,"@Override public void onCreated(Iterable<CacheEntryEvent<? extends K,? extends T>> cacheEntryEvents) throws CacheEntryListenerException {
  if (cacheEntryList == null) {
    return;
  }
  for (  CacheEntryEvent<? extends K,? extends T> event : cacheEntryEvents) {
    cacheEntryList.add(event.getKey());
    LOG.info(""String_Node_Str"",event.getKey().toString());
  }
}","@Override public void onCreated(Iterable<CacheEntryEvent<? extends K,? extends T>> cacheEntryEvents) throws CacheEntryListenerException {
  for (  CacheEntryEvent<? extends K,? extends T> event : cacheEntryEvents) {
    cacheEntryList.add(event.getKey());
    LOG.info(""String_Node_Str"",event.getKey().toString());
  }
}",0.9302325581395348
80160,"public static <K,T extends PersistentBase>Factory<JCacheCacheLoader<K,T>> factoryOfCacheLoader(DataStore<K,T> dataStore){
  return new JCacheCacheLoaderFactory<>(new JCacheCacheLoader<>(dataStore));
}","public static <K,T extends PersistentBase>Factory<JCacheCacheLoader<K,T>> factoryOfCacheLoader(DataStore<K,T> dataStore,Class<K> keyClass,Class<T> persistentClass){
  return new JCacheCacheLoaderFactory<>(new JCacheCacheLoader<>(dataStore),keyClass,persistentClass);
}",0.8547008547008547
80161,"public static <K,T extends PersistentBase>Factory<JCacheCacheWriter<K,T>> factoryOfCacheWriter(DataStore<K,T> dataStore){
  return new JCacheCacheWriterFactory<>(new JCacheCacheWriter<>(dataStore));
}","public static <K,T extends PersistentBase>Factory<JCacheCacheWriter<K,T>> factoryOfCacheWriter(DataStore<K,T> dataStore,Class<K> keyClass,Class<T> persistentClass){
  return new JCacheCacheWriterFactory<>(new JCacheCacheWriter<>(dataStore),keyClass,persistentClass);
}",0.8547008547008547
80162,"public JCacheCacheLoaderFactory(JCacheCacheLoader<K,T> instance){
  LOG.info(""String_Node_Str"");
  this.instance=instance;
}","public JCacheCacheLoaderFactory(JCacheCacheLoader<K,T> instance,Class<K> keyClass,Class<T> persistentClass){
  this.keyClass=keyClass;
  this.persistentClass=persistentClass;
  LOG.info(""String_Node_Str"");
  this.instance=instance;
}",0.6946778711484594
80163,"public JCacheCacheLoader<K,T> create(){
  return (JCacheCacheLoader<K,T>)this.instance;
}","public JCacheCacheLoader<K,T> create(){
  if (this.instance != null) {
    return (JCacheCacheLoader<K,T>)this.instance;
  }
 else {
    try {
      this.instance=new JCacheCacheLoader<>(DataStoreFactory.getDataStore(keyClass,persistentClass,new Configuration()));
    }
 catch (    GoraException ex) {
      LOG.error(""String_Node_Str"",ex);
      return null;
    }
    return (JCacheCacheLoader<K,T>)this.instance;
  }
}",0.3483365949119373
80164,"public JCacheCacheWriter<K,T> create(){
  return (JCacheCacheWriter<K,T>)this.instance;
}","public JCacheCacheWriter<K,T> create(){
  if (this.instance != null) {
    return (JCacheCacheWriter<K,T>)this.instance;
  }
 else {
    try {
      this.instance=new JCacheCacheWriter<>(DataStoreFactory.getDataStore(keyClass,persistentClass,new Configuration()));
    }
 catch (    GoraException ex) {
      LOG.error(""String_Node_Str"",ex);
      return null;
    }
    return (JCacheCacheWriter<K,T>)this.instance;
  }
}",0.3483365949119373
80165,"public JCacheCacheWriterFactory(JCacheCacheWriter<K,T> instance){
  LOG.info(""String_Node_Str"");
  this.instance=instance;
}","public JCacheCacheWriterFactory(JCacheCacheWriter<K,T> instance,Class<K> keyClass,Class<T> persistentClass){
  this.keyClass=keyClass;
  this.persistentClass=persistentClass;
  LOG.info(""String_Node_Str"");
  this.instance=instance;
}",0.6946778711484594
80166,"private void populateLocalCacheEntrySet(ICache<K,T> cache){
  cacheEntryList=new ConcurrentSkipListSet<>();
  Iterator<Cache.Entry<K,T>> cacheEntryIterator=cache.iterator();
  while (cacheEntryIterator.hasNext()) {
    cacheEntryList.add(cacheEntryIterator.next().getKey());
  }
  cacheConfig=cache.getConfiguration(CacheConfig.class);
  Iterator<CacheEntryListenerConfiguration<K,T>> itr=cacheConfig.getCacheEntryListenerConfigurations().iterator();
  while (itr.hasNext()) {
    JCacheCacheEntryListenerFactory<K,T> listenerFac=(JCacheCacheEntryListenerFactory<K,T>)((MutableCacheEntryListenerConfiguration)itr.next()).getCacheEntryListenerFactory();
    listenerFac.create().setCacheEntryList(cacheEntryList);
    break;
  }
  LOG.info(""String_Node_Str"");
}","private void populateLocalCacheEntrySet(ICache<K,T> cache){
  cacheEntryList=new ConcurrentSkipListSet<>();
  Iterator<Cache.Entry<K,T>> cacheEntryIterator=cache.iterator();
  while (cacheEntryIterator.hasNext()) {
    cacheEntryList.add(cacheEntryIterator.next().getKey());
  }
  cacheConfig=cache.getConfiguration(CacheConfig.class);
  LOG.info(""String_Node_Str"");
}",0.6524822695035462
80167,"@Override public void createSchema(){
  if (manager.getCache(super.getPersistentClass().getSimpleName(),keyClass,persistentClass) == null) {
    cacheEntryList.clear();
    cache=manager.createCache(persistentClass.getSimpleName(),cacheConfig).unwrap(ICache.class);
  }
  persistentDataStore.createSchema();
  LOG.info(""String_Node_Str"",super.getPersistentClass().getSimpleName());
}","@Override public void createSchema(){
  if (manager.getCache(super.getPersistentClass().getSimpleName(),keyClass,persistentClass) == null) {
    cacheEntryList.clear();
    cache=manager.createCache(persistentClass.getSimpleName(),cacheConfig).unwrap(ICache.class);
  }
  cache.registerCacheEntryListener(new MutableCacheEntryListenerConfiguration<>(JCacheCacheFactoryBuilder.factoryOfEntryListener(new JCacheCacheEntryListener<K,T>(cacheEntryList)),null,true,true));
  persistentDataStore.createSchema();
  LOG.info(""String_Node_Str"",super.getPersistentClass().getSimpleName());
}",0.7946058091286307
80168,"@Override public void initialize(Class<K> keyClass,Class<T> persistentClass,Properties properties){
  super.initialize(keyClass,persistentClass,properties);
  CachingProvider cachingProvider=Caching.getCachingProvider(properties.getProperty(GORA_DEFAULT_JCACHE_PROVIDER_KEY));
  if (properties.getProperty(JCACHE_CACHE_NAMESPACE_PROPERTY_KEY) != null) {
    goraCacheNamespace=properties.getProperty(JCACHE_CACHE_NAMESPACE_PROPERTY_KEY);
  }
  try {
    this.persistentDataStore=DataStoreFactory.getDataStore(keyClass,persistentClass,new Configuration());
  }
 catch (  GoraException ex) {
    LOG.error(""String_Node_Str"",ex);
  }
  if (properties.getProperty(GORA_DEFAULT_JCACHE_PROVIDER_KEY).contains(HAZELCAST_SERVER_CACHE_PROVIDER_IDENTIFIER)) {
    Config config=new ClasspathXmlConfig(properties.getProperty(GORA_DEFAULT_JCACHE_HAZELCAST_CONFIG_KEY));
    hazelcastInstance=Hazelcast.newHazelcastInstance(config);
  }
 else {
    try {
      ClientConfig config=new XmlClientConfigBuilder(properties.getProperty(GORA_DEFAULT_JCACHE_HAZELCAST_CONFIG_KEY)).build();
      hazelcastInstance=HazelcastClient.newHazelcastClient(config);
    }
 catch (    IOException ex) {
      LOG.error(""String_Node_Str"",ex);
    }
  }
  Properties providerProperties=new Properties();
  providerProperties.setProperty(HazelcastCachingProvider.HAZELCAST_INSTANCE_NAME,hazelcastInstance.getName());
  try {
    manager=cachingProvider.getCacheManager(new URI(goraCacheNamespace),null,providerProperties);
  }
 catch (  URISyntaxException ex) {
    LOG.error(""String_Node_Str"",ex);
    manager=cachingProvider.getCacheManager();
  }
  if (((properties.getProperty(JCACHE_AUTO_CREATE_CACHE_PROPERTY_KEY) != null) && Boolean.valueOf(properties.getProperty(JCACHE_AUTO_CREATE_CACHE_PROPERTY_KEY))) || ((manager.getCache(super.getPersistentClass().getSimpleName(),keyClass,persistentClass) == null))) {
    cacheEntryList=new ConcurrentSkipListSet<>();
    cacheConfig=new CacheConfig<K,T>();
    cacheConfig.setTypes(keyClass,persistentClass);
    if (properties.getProperty(JCACHE_READ_THROUGH_PROPERTY_KEY) != null) {
      cacheConfig.setReadThrough(Boolean.valueOf(properties.getProperty(JCACHE_READ_THROUGH_PROPERTY_KEY)));
    }
 else {
      cacheConfig.setReadThrough(true);
    }
    if (properties.getProperty(JCACHE_WRITE_THROUGH_PROPERTY_KEY) != null) {
      cacheConfig.setWriteThrough(Boolean.valueOf(properties.getProperty(JCACHE_WRITE_THROUGH_PROPERTY_KEY)));
    }
 else {
      cacheConfig.setWriteThrough(true);
    }
    if (properties.getProperty(JCACHE_STORE_BY_VALUE_PROPERTY_KEY) != null) {
      cacheConfig.setStoreByValue(Boolean.valueOf(properties.getProperty(JCACHE_STORE_BY_VALUE_PROPERTY_KEY)));
    }
    if (properties.getProperty(JCACHE_STATISTICS_PROPERTY_KEY) != null) {
      cacheConfig.setStatisticsEnabled(Boolean.valueOf(properties.getProperty(JCACHE_STATISTICS_PROPERTY_KEY)));
    }
    if (properties.getProperty(JCACHE_MANAGEMENT_PROPERTY_KEY) != null) {
      cacheConfig.setStatisticsEnabled(Boolean.valueOf(properties.getProperty(JCACHE_MANAGEMENT_PROPERTY_KEY)));
    }
    if (properties.getProperty(JCACHE_EVICTION_POLICY_PROPERTY_KEY) != null) {
      cacheConfig.getEvictionConfig().setEvictionPolicy(EvictionPolicy.valueOf(properties.getProperty(JCACHE_EVICTION_POLICY_PROPERTY_KEY)));
    }
    if (properties.getProperty(JCACHE_EVICTION_MAX_SIZE_POLICY_PROPERTY_KEY) != null) {
      cacheConfig.getEvictionConfig().setMaximumSizePolicy(EvictionConfig.MaxSizePolicy.valueOf(properties.getProperty(JCACHE_EVICTION_MAX_SIZE_POLICY_PROPERTY_KEY)));
    }
    if (properties.getProperty(JCACHE_EVICTION_SIZE_PROPERTY_KEY) != null) {
      cacheConfig.getEvictionConfig().setSize(Integer.valueOf(properties.getProperty(JCACHE_EVICTION_SIZE_PROPERTY_KEY)));
    }
    if (properties.getProperty(JCACHE_EXPIRE_POLICY_PROPERTY_KEY) != null) {
      String expiryPolicyIdentifier=properties.getProperty(JCACHE_EXPIRE_POLICY_PROPERTY_KEY);
      if (expiryPolicyIdentifier.equals(JCACHE_ACCESSED_EXPIRY_IDENTIFIER)) {
        cacheConfig.setExpiryPolicyFactory(FactoryBuilder.factoryOf(new AccessedExpiryPolicy(new Duration(TimeUnit.SECONDS,Integer.valueOf(properties.getProperty(JCACHE_EXPIRE_POLICY_DURATION_PROPERTY_KEY))))));
      }
 else       if (expiryPolicyIdentifier.equals(JCACHE_CREATED_EXPIRY_IDENTIFIER)) {
        cacheConfig.setExpiryPolicyFactory(FactoryBuilder.factoryOf(new CreatedExpiryPolicy(new Duration(TimeUnit.SECONDS,Integer.valueOf(properties.getProperty(JCACHE_EXPIRE_POLICY_DURATION_PROPERTY_KEY))))));
      }
 else       if (expiryPolicyIdentifier.equals(JCACHE_MODIFIED_EXPIRY_IDENTIFIER)) {
        cacheConfig.setExpiryPolicyFactory(FactoryBuilder.factoryOf(new ModifiedExpiryPolicy(new Duration(TimeUnit.SECONDS,Integer.valueOf(properties.getProperty(JCACHE_EXPIRE_POLICY_DURATION_PROPERTY_KEY))))));
      }
 else       if (expiryPolicyIdentifier.equals(JCACHE_TOUCHED_EXPIRY_IDENTIFIER)) {
        cacheConfig.setExpiryPolicyFactory(FactoryBuilder.factoryOf(new TouchedExpiryPolicy(new Duration(TimeUnit.SECONDS,Integer.valueOf(properties.getProperty(JCACHE_EXPIRE_POLICY_DURATION_PROPERTY_KEY))))));
      }
    }
    if (properties.getProperty(HAZELCAST_CACHE_IN_MEMORY_FORMAT_PROPERTY_KEY) != null) {
      String inMemoryFormat=properties.getProperty(HAZELCAST_CACHE_IN_MEMORY_FORMAT_PROPERTY_KEY);
      if (inMemoryFormat.equals(HAZELCAST_CACHE_BINARY_IN_MEMORY_FORMAT_IDENTIFIER) || inMemoryFormat.equals(HAZELCAST_CACHE_OBJECT_IN_MEMORY_FORMAT_IDENTIFIER) || inMemoryFormat.equals(HAZELCAST_CACHE_NATIVE_IN_MEMORY_FORMAT_IDENTIFIER)) {
        cacheConfig.setInMemoryFormat(InMemoryFormat.valueOf(inMemoryFormat));
      }
    }
    cacheConfig.setCacheLoaderFactory(JCacheCacheFactoryBuilder.factoryOfCacheLoader(this.persistentDataStore));
    cacheConfig.setCacheWriterFactory(JCacheCacheFactoryBuilder.factoryOfCacheWriter(this.persistentDataStore));
    cacheConfig.addCacheEntryListenerConfiguration(new MutableCacheEntryListenerConfiguration<>(JCacheCacheFactoryBuilder.factoryOfEntryListener(new JCacheCacheEntryListener<K,T>(cacheEntryList)),null,true,true));
    cache=manager.createCache(persistentClass.getSimpleName(),cacheConfig).unwrap(ICache.class);
  }
 else {
    cache=manager.getCache(super.getPersistentClass().getSimpleName(),keyClass,persistentClass).unwrap(ICache.class);
    this.populateLocalCacheEntrySet(cache);
    this.populateLocalCacheConfig(cache);
  }
  LOG.info(""String_Node_Str"");
}","@Override public void initialize(Class<K> keyClass,Class<T> persistentClass,Properties properties){
  super.initialize(keyClass,persistentClass,properties);
  CachingProvider cachingProvider=Caching.getCachingProvider(properties.getProperty(GORA_DEFAULT_JCACHE_PROVIDER_KEY));
  if (properties.getProperty(JCACHE_CACHE_NAMESPACE_PROPERTY_KEY) != null) {
    goraCacheNamespace=properties.getProperty(JCACHE_CACHE_NAMESPACE_PROPERTY_KEY);
  }
  try {
    this.persistentDataStore=DataStoreFactory.getDataStore(keyClass,persistentClass,new Configuration());
  }
 catch (  GoraException ex) {
    LOG.error(""String_Node_Str"",ex);
  }
  if (properties.getProperty(GORA_DEFAULT_JCACHE_PROVIDER_KEY).contains(HAZELCAST_SERVER_CACHE_PROVIDER_IDENTIFIER)) {
    Config config=new ClasspathXmlConfig(properties.getProperty(GORA_DEFAULT_JCACHE_HAZELCAST_CONFIG_KEY));
    hazelcastInstance=Hazelcast.newHazelcastInstance(config);
  }
 else {
    try {
      ClientConfig config=new XmlClientConfigBuilder(properties.getProperty(GORA_DEFAULT_JCACHE_HAZELCAST_CONFIG_KEY)).build();
      hazelcastInstance=HazelcastClient.newHazelcastClient(config);
    }
 catch (    IOException ex) {
      LOG.error(""String_Node_Str"",ex);
    }
  }
  Properties providerProperties=new Properties();
  providerProperties.setProperty(HazelcastCachingProvider.HAZELCAST_INSTANCE_NAME,hazelcastInstance.getName());
  try {
    manager=cachingProvider.getCacheManager(new URI(goraCacheNamespace),null,providerProperties);
  }
 catch (  URISyntaxException ex) {
    LOG.error(""String_Node_Str"",ex);
    manager=cachingProvider.getCacheManager();
  }
  if (((properties.getProperty(JCACHE_AUTO_CREATE_CACHE_PROPERTY_KEY) != null) && Boolean.valueOf(properties.getProperty(JCACHE_AUTO_CREATE_CACHE_PROPERTY_KEY))) || ((manager.getCache(super.getPersistentClass().getSimpleName(),keyClass,persistentClass) == null))) {
    cacheEntryList=new ConcurrentSkipListSet<>();
    cacheConfig=new CacheConfig<K,T>();
    cacheConfig.setTypes(keyClass,persistentClass);
    if (properties.getProperty(JCACHE_READ_THROUGH_PROPERTY_KEY) != null) {
      cacheConfig.setReadThrough(Boolean.valueOf(properties.getProperty(JCACHE_READ_THROUGH_PROPERTY_KEY)));
    }
 else {
      cacheConfig.setReadThrough(true);
    }
    if (properties.getProperty(JCACHE_WRITE_THROUGH_PROPERTY_KEY) != null) {
      cacheConfig.setWriteThrough(Boolean.valueOf(properties.getProperty(JCACHE_WRITE_THROUGH_PROPERTY_KEY)));
    }
 else {
      cacheConfig.setWriteThrough(true);
    }
    if (properties.getProperty(JCACHE_STORE_BY_VALUE_PROPERTY_KEY) != null) {
      cacheConfig.setStoreByValue(Boolean.valueOf(properties.getProperty(JCACHE_STORE_BY_VALUE_PROPERTY_KEY)));
    }
    if (properties.getProperty(JCACHE_STATISTICS_PROPERTY_KEY) != null) {
      cacheConfig.setStatisticsEnabled(Boolean.valueOf(properties.getProperty(JCACHE_STATISTICS_PROPERTY_KEY)));
    }
    if (properties.getProperty(JCACHE_MANAGEMENT_PROPERTY_KEY) != null) {
      cacheConfig.setStatisticsEnabled(Boolean.valueOf(properties.getProperty(JCACHE_MANAGEMENT_PROPERTY_KEY)));
    }
    if (properties.getProperty(JCACHE_EVICTION_POLICY_PROPERTY_KEY) != null) {
      cacheConfig.getEvictionConfig().setEvictionPolicy(EvictionPolicy.valueOf(properties.getProperty(JCACHE_EVICTION_POLICY_PROPERTY_KEY)));
    }
    if (properties.getProperty(JCACHE_EVICTION_MAX_SIZE_POLICY_PROPERTY_KEY) != null) {
      cacheConfig.getEvictionConfig().setMaximumSizePolicy(EvictionConfig.MaxSizePolicy.valueOf(properties.getProperty(JCACHE_EVICTION_MAX_SIZE_POLICY_PROPERTY_KEY)));
    }
    if (properties.getProperty(JCACHE_EVICTION_SIZE_PROPERTY_KEY) != null) {
      cacheConfig.getEvictionConfig().setSize(Integer.valueOf(properties.getProperty(JCACHE_EVICTION_SIZE_PROPERTY_KEY)));
    }
    if (properties.getProperty(JCACHE_EXPIRE_POLICY_PROPERTY_KEY) != null) {
      String expiryPolicyIdentifier=properties.getProperty(JCACHE_EXPIRE_POLICY_PROPERTY_KEY);
      if (expiryPolicyIdentifier.equals(JCACHE_ACCESSED_EXPIRY_IDENTIFIER)) {
        cacheConfig.setExpiryPolicyFactory(FactoryBuilder.factoryOf(new AccessedExpiryPolicy(new Duration(TimeUnit.SECONDS,Integer.valueOf(properties.getProperty(JCACHE_EXPIRE_POLICY_DURATION_PROPERTY_KEY))))));
      }
 else       if (expiryPolicyIdentifier.equals(JCACHE_CREATED_EXPIRY_IDENTIFIER)) {
        cacheConfig.setExpiryPolicyFactory(FactoryBuilder.factoryOf(new CreatedExpiryPolicy(new Duration(TimeUnit.SECONDS,Integer.valueOf(properties.getProperty(JCACHE_EXPIRE_POLICY_DURATION_PROPERTY_KEY))))));
      }
 else       if (expiryPolicyIdentifier.equals(JCACHE_MODIFIED_EXPIRY_IDENTIFIER)) {
        cacheConfig.setExpiryPolicyFactory(FactoryBuilder.factoryOf(new ModifiedExpiryPolicy(new Duration(TimeUnit.SECONDS,Integer.valueOf(properties.getProperty(JCACHE_EXPIRE_POLICY_DURATION_PROPERTY_KEY))))));
      }
 else       if (expiryPolicyIdentifier.equals(JCACHE_TOUCHED_EXPIRY_IDENTIFIER)) {
        cacheConfig.setExpiryPolicyFactory(FactoryBuilder.factoryOf(new TouchedExpiryPolicy(new Duration(TimeUnit.SECONDS,Integer.valueOf(properties.getProperty(JCACHE_EXPIRE_POLICY_DURATION_PROPERTY_KEY))))));
      }
    }
    if (properties.getProperty(HAZELCAST_CACHE_IN_MEMORY_FORMAT_PROPERTY_KEY) != null) {
      String inMemoryFormat=properties.getProperty(HAZELCAST_CACHE_IN_MEMORY_FORMAT_PROPERTY_KEY);
      if (inMemoryFormat.equals(HAZELCAST_CACHE_BINARY_IN_MEMORY_FORMAT_IDENTIFIER) || inMemoryFormat.equals(HAZELCAST_CACHE_OBJECT_IN_MEMORY_FORMAT_IDENTIFIER) || inMemoryFormat.equals(HAZELCAST_CACHE_NATIVE_IN_MEMORY_FORMAT_IDENTIFIER)) {
        cacheConfig.setInMemoryFormat(InMemoryFormat.valueOf(inMemoryFormat));
      }
    }
    cacheConfig.setCacheLoaderFactory(JCacheCacheFactoryBuilder.factoryOfCacheLoader(this.persistentDataStore,keyClass,persistentClass));
    cacheConfig.setCacheWriterFactory(JCacheCacheFactoryBuilder.factoryOfCacheWriter(this.persistentDataStore,keyClass,persistentClass));
    cache=manager.createCache(persistentClass.getSimpleName(),cacheConfig).unwrap(ICache.class);
  }
 else {
    cache=manager.getCache(super.getPersistentClass().getSimpleName(),keyClass,persistentClass).unwrap(ICache.class);
    this.populateLocalCacheEntrySet(cache);
  }
  cache.registerCacheEntryListener(new MutableCacheEntryListenerConfiguration<>(JCacheCacheFactoryBuilder.factoryOfEntryListener(new JCacheCacheEntryListener<K,T>(cacheEntryList)),null,true,true));
  LOG.info(""String_Node_Str"");
}",0.9455918618988902
80169,"@Override public void setUpClass() throws Exception {
  super.setUpClass();
  log.info(""String_Node_Str"");
  Properties properties=new Properties();
  properties.setProperty(GORA_DEFAULT_JCACHE_PROVIDER_KEY,PROVIDER);
  properties.setProperty(GORA_DEFAULT_JCACHE_HAZELCAST_CONFIG_KEY,CONFIG);
  properties.setProperty(GORA_DEFAULT_DATASTORE_KEY,MEMSTORE);
  properties.setProperty(JCACHE_READ_THROUGH_PROPERTY_KEY,FALSE);
  properties.setProperty(JCACHE_WRITE_THROUGH_PROPERTY_KEY,FALSE);
  serverCacheProvider=new JCacheStore();
  serverCacheProvider.initialize(String.class,WebPage.class,properties);
}","@Override public void setUpClass() throws Exception {
  super.setUpClass();
  log.info(""String_Node_Str"");
  Config config=new ClasspathXmlConfig(CONFIG);
  hazelcastInstance=Hazelcast.newHazelcastInstance(config);
}",0.3121951219512195
80170,"@Override public void tearDownClass() throws Exception {
  super.tearDownClass();
  log.info(""String_Node_Str"");
  serverCacheProvider.close();
}","@Override public void tearDownClass() throws Exception {
  super.tearDownClass();
  log.info(""String_Node_Str"");
  hazelcastInstance.shutdown();
}",0.852233676975945
80171,"/** 
 * Check if keyspace already exists. If not, create it. In this method, we also utilize Hector's   {@link me.prettyprint.cassandra.model.ConfigurableConsistencyLevel} logic. It is set by passing a  {@link me.prettyprint.cassandra.model.ConfigurableConsistencyLevel} object right when the  {@link me.prettyprint.hector.api.Keyspace} is created. If we cannot find a consistency level within <code>gora.properites</code>,  then column family consistency level is set to QUORUM (by default) which permits  consistency to wait for a quorum of replicas to respond regardless of data center. QUORUM is Hector Client's default setting and we respect that here as well.
 * @see http://hector-client.github.io/hector/build/html/content/consistency_level.html
 */
public void checkKeyspace(){
  KeyspaceDefinition keyspaceDefinition=this.cluster.describeKeyspace(this.cassandraMapping.getKeyspaceName());
  if (keyspaceDefinition == null) {
    List<ColumnFamilyDefinition> columnFamilyDefinitions=this.cassandraMapping.getColumnFamilyDefinitions();
    for (    ColumnFamilyDefinition cfDef : columnFamilyDefinitions) {
      cfDef.setComparatorType(ComparatorType.BYTESTYPE);
    }
    keyspaceDefinition=HFactory.createKeyspaceDefinition(this.cassandraMapping.getKeyspaceName(),this.cassandraMapping.getKeyspaceReplicationStrategy(),this.cassandraMapping.getKeyspaceReplicationFactor(),columnFamilyDefinitions);
    this.cluster.addKeyspace(keyspaceDefinition,true);
    ConfigurableConsistencyLevel ccl=new ConfigurableConsistencyLevel();
    Map<String,HConsistencyLevel> clmap=getConsisLevelForColFams(columnFamilyDefinitions);
    ccl.setReadCfConsistencyLevels(clmap);
    ccl.setWriteCfConsistencyLevels(clmap);
    String opConsisLvl=(readOpConsLvl != null || !readOpConsLvl.isEmpty()) ? readOpConsLvl : DEFAULT_HECTOR_CONSIS_LEVEL;
    ccl.setDefaultReadConsistencyLevel(HConsistencyLevel.valueOf(opConsisLvl));
    LOG.debug(""String_Node_Str"" + opConsisLvl + ""String_Node_Str"");
    opConsisLvl=(writeOpConsLvl != null || !writeOpConsLvl.isEmpty()) ? writeOpConsLvl : DEFAULT_HECTOR_CONSIS_LEVEL;
    ccl.setDefaultWriteConsistencyLevel(HConsistencyLevel.valueOf(opConsisLvl));
    LOG.debug(""String_Node_Str"" + opConsisLvl + ""String_Node_Str"");
    HFactory.createKeyspace(""String_Node_Str"",this.cluster,ccl);
    keyspaceDefinition=null;
  }
 else {
    List<ColumnFamilyDefinition> cfDefs=keyspaceDefinition.getCfDefs();
    if (cfDefs == null || cfDefs.size() == 0) {
      LOG.warn(keyspaceDefinition.getName() + ""String_Node_Str"");
    }
 else {
      for (      ColumnFamilyDefinition cfDef : cfDefs) {
        ComparatorType comparatorType=cfDef.getComparatorType();
        if (!comparatorType.equals(ComparatorType.BYTESTYPE)) {
          LOG.warn(""String_Node_Str"" + cfDef.getName() + ""String_Node_Str""+ comparatorType.getTypeName()+ ""String_Node_Str"");
        }
 else {
          LOG.debug(""String_Node_Str"" + cfDef.getName() + ""String_Node_Str""+ comparatorType.getTypeName()+ ""String_Node_Str"");
        }
      }
    }
  }
}","/** 
 * Check if keyspace already exists. If not, create it. In this method, we also utilize Hector's  {@link me.prettyprint.cassandra.model.ConfigurableConsistencyLevel} logic.It is set by passing a {@link me.prettyprint.cassandra.model.ConfigurableConsistencyLevel} object rightwhen the  {@link me.prettyprint.hector.api.Keyspace} is created.If we cannot find a consistency level within <code>gora.properites</code>, then column family consistency level is set to QUORUM (by default) which permits consistency to wait for a quorum of replicas to respond regardless of data center. QUORUM is Hector Client's default setting and we respect that here as well.
 * @see <a href=""http://hector-client.github.io/hector/build/html/content/consistency_level.html"">Consistency Level</a>
 */
public void checkKeyspace(){
  KeyspaceDefinition keyspaceDefinition=this.cluster.describeKeyspace(this.cassandraMapping.getKeyspaceName());
  if (keyspaceDefinition == null) {
    List<ColumnFamilyDefinition> columnFamilyDefinitions=this.cassandraMapping.getColumnFamilyDefinitions();
    for (    ColumnFamilyDefinition cfDef : columnFamilyDefinitions) {
      cfDef.setComparatorType(ComparatorType.BYTESTYPE);
    }
    keyspaceDefinition=HFactory.createKeyspaceDefinition(this.cassandraMapping.getKeyspaceName(),this.cassandraMapping.getKeyspaceReplicationStrategy(),this.cassandraMapping.getKeyspaceReplicationFactor(),columnFamilyDefinitions);
    this.cluster.addKeyspace(keyspaceDefinition,true);
    ConfigurableConsistencyLevel ccl=new ConfigurableConsistencyLevel();
    Map<String,HConsistencyLevel> clmap=getConsisLevelForColFams(columnFamilyDefinitions);
    ccl.setReadCfConsistencyLevels(clmap);
    ccl.setWriteCfConsistencyLevels(clmap);
    String opConsisLvl=(readOpConsLvl != null || !readOpConsLvl.isEmpty()) ? readOpConsLvl : DEFAULT_HECTOR_CONSIS_LEVEL;
    ccl.setDefaultReadConsistencyLevel(HConsistencyLevel.valueOf(opConsisLvl));
    LOG.debug(""String_Node_Str"" + opConsisLvl + ""String_Node_Str"");
    opConsisLvl=(writeOpConsLvl != null || !writeOpConsLvl.isEmpty()) ? writeOpConsLvl : DEFAULT_HECTOR_CONSIS_LEVEL;
    ccl.setDefaultWriteConsistencyLevel(HConsistencyLevel.valueOf(opConsisLvl));
    LOG.debug(""String_Node_Str"" + opConsisLvl + ""String_Node_Str"");
    HFactory.createKeyspace(""String_Node_Str"",this.cluster,ccl);
    keyspaceDefinition=null;
  }
 else {
    List<ColumnFamilyDefinition> cfDefs=keyspaceDefinition.getCfDefs();
    if (cfDefs == null || cfDefs.size() == 0) {
      LOG.warn(keyspaceDefinition.getName() + ""String_Node_Str"");
    }
 else {
      for (      ColumnFamilyDefinition cfDef : cfDefs) {
        ComparatorType comparatorType=cfDef.getComparatorType();
        if (!comparatorType.equals(ComparatorType.BYTESTYPE)) {
          LOG.warn(""String_Node_Str"" + cfDef.getName() + ""String_Node_Str""+ comparatorType.getTypeName()+ ""String_Node_Str"");
        }
 else {
          LOG.debug(""String_Node_Str"" + cfDef.getName() + ""String_Node_Str""+ comparatorType.getTypeName()+ ""String_Node_Str"");
        }
      }
    }
  }
}",0.9936222403924776
80172,"/** 
 * Given our key, persistentClass from   {@link org.apache.gora.cassandra.store.CassandraStore#initialize(Class,Class,Properties)}we make best efforts to dictate our data model.  We make a quick check within   {@link org.apache.gora.cassandra.store.CassandraClient#checkKeyspace(String) to see if our keyspace has already been invented, this simple check prevents us from  recreating the keyspace if it already exists.  We then simple specify (based on the input keyclass) an appropriate serializer}via   {@link org.apache.gora.cassandra.serializers.GoraSerializerTypeInferer} beforedefining a mutator from and by which we can mutate this object.
 * @param keyClass the Key by which we wish o assign a record object
 * @param persistentClass the generated {@link org.apache.org.gora.persistency.Peristent} bean representing the data.
 * @param properties key value pairs from gora.properties
 * @throws Exception
 */
public void initialize(Class<K> keyClass,Class<T> persistentClass,Properties properties) throws Exception {
  this.keyClass=keyClass;
  this.persistentClass=persistentClass;
  this.cassandraMapping=CassandraMappingManager.getManager().get(persistentClass);
  Map<String,String> accessMap=null;
  if (properties != null) {
    String username=properties.getProperty(""String_Node_Str"");
    if (username != null) {
      accessMap=new HashMap<>();
      accessMap.put(""String_Node_Str"",username);
      String password=properties.getProperty(""String_Node_Str"");
      if (password != null) {
        accessMap.put(""String_Node_Str"",password);
      }
    }
  }
  this.cluster=HFactory.getOrCreateCluster(this.cassandraMapping.getClusterName(),new CassandraHostConfigurator(this.cassandraMapping.getHostName()),accessMap);
  checkKeyspace();
  this.keyspace=HFactory.createKeyspace(this.cassandraMapping.getKeyspaceName(),this.cluster);
  this.keySerializer=GoraSerializerTypeInferer.getSerializer(keyClass);
  if (this.keySerializer == null)   LOG.error(""String_Node_Str"" + keyClass + ""String_Node_Str"");
  this.mutator=HFactory.createMutator(this.keyspace,this.keySerializer);
}","/** 
 * Given our key, persistentClass from  {@link org.apache.gora.cassandra.store.CassandraStore#initialize(Class,Class,Properties)}we make best efforts to dictate our data model. We make a quick check within   {@link org.apache.gora.cassandra.store.CassandraClient#checkKeyspace() }to see if our keyspace has already been invented, this simple check prevents us from recreating the keyspace if it already exists. We then simple specify (based on the input keyclass) an appropriate serializer via   {@link org.apache.gora.cassandra.serializers.GoraSerializerTypeInferer} beforedefining a mutator from and by which we can mutate this object.
 * @param keyClass        the Key by which we wish o assign a record object
 * @param persistentClass the generated {@link org.apache.gora.persistency.Persistent} bean representing the data.
 * @param properties      key value pairs from gora.properties
 * @throws Exception
 */
public void initialize(Class<K> keyClass,Class<T> persistentClass,Properties properties) throws Exception {
  this.keyClass=keyClass;
  this.persistentClass=persistentClass;
  this.cassandraMapping=CassandraMappingManager.getManager().get(persistentClass);
  Map<String,String> accessMap=null;
  if (properties != null) {
    String username=properties.getProperty(""String_Node_Str"");
    if (username != null) {
      accessMap=new HashMap<>();
      accessMap.put(""String_Node_Str"",username);
      String password=properties.getProperty(""String_Node_Str"");
      if (password != null) {
        accessMap.put(""String_Node_Str"",password);
      }
    }
  }
  this.cluster=HFactory.getOrCreateCluster(this.cassandraMapping.getClusterName(),new CassandraHostConfigurator(this.cassandraMapping.getHostName()),accessMap);
  checkKeyspace();
  this.keyspace=HFactory.createKeyspace(this.cassandraMapping.getKeyspaceName(),this.cluster);
  this.keySerializer=GoraSerializerTypeInferer.getSerializer(keyClass);
  if (this.keySerializer == null)   LOG.error(""String_Node_Str"" + keyClass + ""String_Node_Str"");
  this.mutator=HFactory.createMutator(this.keyspace,this.keySerializer);
}",0.991900905192949
80173,"/** 
 * Delete a row within the keyspace.
 * @param key
 * @param fieldName
 * @param columnName
 */
public void deleteColumn(K key,String familyName,ByteBuffer columnName){
synchronized (mutator) {
    HectorUtils.deleteColumn(mutator,key,familyName,columnName);
  }
}","/** 
 * Delete a row within the keyspace.
 * @param key
 * @param familyName
 * @param columnName
 */
public void deleteColumn(K key,String familyName,ByteBuffer columnName){
synchronized (mutator) {
    HectorUtils.deleteColumn(mutator,key,familyName,columnName);
  }
}",0.9833024118738404
80174,"/** 
 * When doing the   {@link org.apache.gora.cassandra.store.CassandraStore#put(Object,PersistentBase)}operation, the logic is as follows: <ol> <li>Obtain the Avro   {@link org.apache.avro.Schema} for the object.</li><li>Create a new duplicate instance of the object (explained in more detail below) **.</li> <li>Obtain a  {@link java.util.List} of the {@link org.apache.avro.Schema} {@link org.apache.avro.Schema.Field}'s.</li> <li>Iterate through the field   {@link java.util.List}. This allows us to  consequently process each item.</li> <li>Check to see if the   {@link org.apache.avro.Schema.Field} is NOT dirty. If this condition is true then we DO NOT process this field.</li> <li>Obtain the element at the specified position in this list so we can  directly operate on it.</li> <li>Obtain the  {@link org.apache.avro.Schema.Type} of the element obtained above and process it accordingly. N.B. For nested type ARRAY, MAP RECORD or UNION, we shadow the checks in bullet point 5 above to infer that the  {@link org.apache.avro.Schema.Field} is either at position 0 OR it is NOT dirty. If one of these conditions is true then we DO NOT process this field. This is carried out in  {@link org.apache.gora.cassandra.store.CassandraStore#getFieldValue(Schema,Type,Object)}</li> <li>We then insert the Key and Object into the   {@link java.util.LinkedHashMap} buffer before being flushed. This performs a structural modification of the map.</li> </ol> ** We create a duplicate instance of the object to be persisted and insert processed objects into a synchronized  {@link java.util.LinkedHashMap}. This allows  us to keep all the objects in memory till flushing.
 * @see org.apache.gora.store.DataStore#put(java.lang.Object, 
   * org.apache.gora.persistency.Persistent).
 * @param key for the Avro Record (object).
 * @param value Record object to be persisted in Cassandra
 */
@Override public void put(K key,T value){
  Schema schema=value.getSchema();
  @SuppressWarnings(""String_Node_Str"") T p=(T)SpecificData.get().newRecord(value,schema);
  List<Field> fields=schema.getFields();
  for (int i=1; i < fields.size(); i++) {
    if (!value.isDirty(i)) {
      continue;
    }
    Field field=fields.get(i);
    Type type=field.schema().getType();
    Object fieldValue=value.get(field.pos());
    Schema fieldSchema=field.schema();
    fieldValue=getFieldValue(fieldSchema,type,fieldValue);
    p.put(field.pos(),fieldValue);
  }
  this.buffer.put(key,p);
}","/** 
 * When doing the  {@link org.apache.gora.cassandra.store.CassandraStore#put(Object,PersistentBase)}operation, the logic is as follows: <ol> <li>Obtain the Avro   {@link org.apache.avro.Schema} for the object.</li><li>Create a new duplicate instance of the object (explained in more detail below) **.</li> <li>Obtain a  {@link java.util.List} of the {@link org.apache.avro.Schema}{@link org.apache.avro.Schema.Field}'s.</li> <li>Iterate through the field   {@link java.util.List}. This allows us to consequently process each item.</li> <li>Check to see if the   {@link org.apache.avro.Schema.Field} is NOT dirty.If this condition is true then we DO NOT process this field.</li> <li>Obtain the element at the specified position in this list so we can directly operate on it.</li> <li>Obtain the  {@link org.apache.avro.Schema.Type} of the element obtainedabove and process it accordingly. N.B. For nested type ARRAY, MAP RECORD or UNION, we shadow the checks in bullet point 5 above to infer that the {@link org.apache.avro.Schema.Field} is either atposition 0 OR it is NOT dirty. If one of these conditions is true then we DO NOT process this field. This is carried out in {@link org.apache.gora.cassandra.store.CassandraStore#getFieldValue(Schema,Type,Object)}</li> <li>We then insert the Key and Object into the   {@link java.util.LinkedHashMap} bufferbefore being flushed. This performs a structural modification of the map.</li> </ol> ** We create a duplicate instance of the object to be persisted and insert processed objects into a synchronized  {@link java.util.LinkedHashMap}. This allows us to keep all the objects in memory till flushing.
 * @param key   for the Avro Record (object).
 * @param value Record object to be persisted in Cassandra
 * @see org.apache.gora.store.DataStore#put(java.lang.Object,org.apache.gora.persistency.Persistent)
 */
@Override public void put(K key,T value){
  Schema schema=value.getSchema();
  @SuppressWarnings(""String_Node_Str"") T p=(T)SpecificData.get().newRecord(value,schema);
  List<Field> fields=schema.getFields();
  for (int i=1; i < fields.size(); i++) {
    if (!value.isDirty(i)) {
      continue;
    }
    Field field=fields.get(i);
    Type type=field.schema().getType();
    Object fieldValue=value.get(field.pos());
    Schema fieldSchema=field.schema();
    fieldValue=getFieldValue(fieldSchema,type,fieldValue);
    p.put(field.pos(),fieldValue);
  }
  this.buffer.put(key,p);
}",0.951333740582366
80175,"/** 
 * Initialize is called when then the call to   {@link org.apache.gora.store.DataStoreFactory#createDataStore(Class<D> dataStoreClass, Class<K> keyClass, Class<T> persistent, org.apache.hadoop.conf.Configuration conf)}is made. In this case, we merely delegate the store initialization to the   {@link org.apache.gora.cassandra.store.CassandraClient#initialize(Class<K> keyClass, Class<T> persistentClass)}. 
 */
public void initialize(Class<K> keyClass,Class<T> persistent,Properties properties){
  try {
    super.initialize(keyClass,persistent,properties);
    if (autoCreateSchema) {
      colFamConsLvl=DataStoreFactory.findProperty(properties,this,COL_FAM_CL,null);
      readOpConsLvl=DataStoreFactory.findProperty(properties,this,READ_OP_CL,null);
      writeOpConsLvl=DataStoreFactory.findProperty(properties,this,WRITE_OP_CL,null);
    }
    this.cassandraClient.initialize(keyClass,persistent,properties);
  }
 catch (  Exception e) {
    LOG.error(e.getMessage(),e);
  }
}","/** 
 * Initialize is called when then the call to   {@link org.apache.gora.store.DataStoreFactory#createDataStore}is made. In this case, we merely delegate the store initialization to the   {@link org.apache.gora.cassandra.store.CassandraClient#initialize}.
 * @param keyClass
 * @param persistent
 * @param properties
 */
public void initialize(Class<K> keyClass,Class<T> persistent,Properties properties){
  try {
    super.initialize(keyClass,persistent,properties);
    if (autoCreateSchema) {
      colFamConsLvl=DataStoreFactory.findProperty(properties,this,COL_FAM_CL,null);
      readOpConsLvl=DataStoreFactory.findProperty(properties,this,READ_OP_CL,null);
      writeOpConsLvl=DataStoreFactory.findProperty(properties,this,WRITE_OP_CL,null);
    }
    this.cassandraClient.initialize(keyClass,persistent,properties);
  }
 catch (  Exception e) {
    LOG.error(e.getMessage(),e);
  }
}",0.893255443441317
80176,"/** 
 * Recognizes camel case 
 */
public static String toUpperCase(String s){
  StringBuilder builder=new StringBuilder();
  for (int i=0; i < s.length(); i++) {
    if (i > 0) {
      if (Character.isUpperCase(s.charAt(i)) && Character.isLowerCase(s.charAt(i - 1)) && Character.isLetter(s.charAt(i))) {
        builder.append(""String_Node_Str"");
      }
    }
    builder.append(Character.toUpperCase(s.charAt(i)));
  }
  return builder.toString();
}","/** 
 * Recognizes camel case
 * @param s converts the given input string to camel case
 * @return the converted camel case string
 */
public static String toUpperCase(String s){
  StringBuilder builder=new StringBuilder();
  for (int i=0; i < s.length(); i++) {
    if (i > 0) {
      if (Character.isUpperCase(s.charAt(i)) && Character.isLowerCase(s.charAt(i - 1)) && Character.isLetter(s.charAt(i))) {
        builder.append(""String_Node_Str"");
      }
    }
    builder.append(Character.toUpperCase(s.charAt(i)));
  }
  return builder.toString();
}",0.898406374501992
80177,"/** 
 * Construct given a path and a configuration. 
 */
public FsInput(Path path,Configuration conf) throws IOException {
  this.stream=path.getFileSystem(conf).open(path);
  this.len=path.getFileSystem(conf).getFileStatus(path).getLen();
}","/** 
 * Construct given a path and a configuration.
 * @param path a path on HDFS to construct
 * @param conf a Hadoop {@link org.apache.hadoop.conf.Configuration} object
 * @throws IOException if there is an error opening path, or obtaining a file status from the file system
 */
public FsInput(Path path,Configuration conf) throws IOException {
  this.stream=path.getFileSystem(conf).open(path);
  this.len=path.getFileSystem(conf).getFileStatus(path).getLen();
}",0.5410764872521246
80178,"/** 
 * Filter the key and persistent. Modification is possible.
 * @param key
 * @param persistent
 * @return <code>true</code> if the row is filtered out (excluded), <code>false</code> otherwise.
 */
public boolean filter(K key,T persistent);","/** 
 * Filter the key and persistent. Modification is possible.
 * @param key
 * @param persistent
 * @return <code>true</code> if the row is filtered out (excluded),<code>false</code> otherwise.
 */
public boolean filter(K key,T persistent);",0.997946611909651
80179,"/** 
 * Sets the input parameters for the job
 * @param job the job to set the properties for
 * @param dataStoreClass the datastore class
 * @param inKeyClass Map input key class
 * @param inValueClass Map input value class
 * @param reuseObjects whether to reuse objects in serialization
 * @throws IOException
 */
public static <K1,V1 extends Persistent>void setInput(Job job,Class<? extends DataStore<K1,V1>> dataStoreClass,Class<K1> inKeyClass,Class<V1> inValueClass,boolean reuseObjects) throws IOException {
  DataStore<K1,V1> store=DataStoreFactory.getDataStore(dataStoreClass,inKeyClass,inValueClass,job.getConfiguration());
  setInput(job,store.newQuery(),reuseObjects);
}","/** 
 * Sets the input parameters for the job
 * @param job            the job to set the properties for
 * @param dataStoreClass the datastore class
 * @param inKeyClass     Map input key class
 * @param inValueClass   Map input value class
 * @param reuseObjects   whether to reuse objects in serialization
 * @param < K1 >
 * @param < V1 >
 * @throws IOException
 */
public static <K1,V1 extends Persistent>void setInput(Job job,Class<? extends DataStore<K1,V1>> dataStoreClass,Class<K1> inKeyClass,Class<V1> inValueClass,boolean reuseObjects) throws IOException {
  DataStore<K1,V1> store=DataStoreFactory.getDataStore(dataStoreClass,inKeyClass,inValueClass,job.getConfiguration());
  setInput(job,store.newQuery(),reuseObjects);
}",0.9625970359915316
80180,"/** 
 * Deletes an entry based on its key.
 * @param key
 */
public void deleteByKey(K key){
  Map<String,String> familyMap=this.cassandraMapping.getFamilyMap();
  deleteColumn(key,familyMap.values().iterator().next().toString(),null);
}","/** 
 * Deletes an entry based on its key.
 * @param key
 */
public void deleteByKey(K key){
  Map<String,String> familyMap=this.cassandraMapping.getFamilyMap();
  deleteColumn(key,familyMap.values().iterator().next(),null);
}",0.976241900647948
80181,"public static String generateDefaultValueString(Schema schema,String fieldName){
  if (fieldName == ""String_Node_Str"") {
    return ""String_Node_Str"" + getNumberOfBytesNeededForDirtyBits(schema) + ""String_Node_Str"";
  }
 else {
    throw new IllegalArgumentException(fieldName + ""String_Node_Str"");
  }
}","public static String generateDefaultValueString(Schema schema,String fieldName){
  if (DIRTY_BYTES_FIELD_NAME.equals(fieldName)) {
    return ""String_Node_Str"" + getNumberOfBytesNeededForDirtyBits(schema) + ""String_Node_Str"";
  }
 else {
    throw new IllegalArgumentException(fieldName + ""String_Node_Str"");
  }
}",0.8867313915857605
80182,"public static String generateAppropriateWrapper(Schema schema,Field field){
  if (field.name() == ""String_Node_Str"") {
    return ""String_Node_Str"" + getNumberOfBytesNeededForDirtyBits(schema) + ""String_Node_Str"";
  }
 else {
switch (field.schema().getType()) {
case RECORD:
      return field.schema().getName() + ""String_Node_Str"";
case MAP:
    return ""String_Node_Str"" + field.pos() + ""String_Node_Str"";
case ARRAY:
  return ""String_Node_Str"" + field.pos() + ""String_Node_Str"";
default :
return ""String_Node_Str"" + field.pos() + ""String_Node_Str"";
}
}
}","public static String generateAppropriateWrapper(Schema schema,Field field){
  if (DIRTY_BYTES_FIELD_NAME.equals(field.name())) {
    return ""String_Node_Str"" + getNumberOfBytesNeededForDirtyBits(schema) + ""String_Node_Str"";
  }
 else {
switch (field.schema().getType()) {
case RECORD:
      return field.schema().getName() + ""String_Node_Str"";
case MAP:
    return ""String_Node_Str"" + field.pos() + ""String_Node_Str"";
case ARRAY:
  return ""String_Node_Str"" + field.pos() + ""String_Node_Str"";
default :
return ""String_Node_Str"" + field.pos() + ""String_Node_Str"";
}
}
}",0.9323843416370108
80183,"private Object getSuperValue(Field field,Schema fieldSchema,Type type){
  Object value=null;
switch (type) {
case ARRAY:
    List<Object> array=new ArrayList<Object>();
  for (  HColumn<ByteBuffer,ByteBuffer> hColumn : this.hSuperColumn.getColumns()) {
    Object memberValue=fromByteBuffer(fieldSchema.getElementType(),hColumn.getValue());
    array.add(memberValue);
  }
value=array;
break;
case MAP:
Map<CharSequence,Object> map=new HashMap<CharSequence,Object>();
for (HColumn<ByteBuffer,ByteBuffer> hColumn : this.hSuperColumn.getColumns()) {
CharSequence mapKey=CharSequenceSerializer.get().fromByteBuffer(hColumn.getName());
if (mapKey.toString().indexOf(CassandraStore.UNION_COL_SUFIX) < 0) {
Object memberValue=null;
if (fieldSchema.getValueType().getType().equals(Type.UNION)) {
HColumn<ByteBuffer,ByteBuffer> cc=getUnionTypeColumn(mapKey + CassandraStore.UNION_COL_SUFIX,this.hSuperColumn.getColumns());
Integer unionIndex=getUnionIndex(mapKey.toString(),cc);
Schema realSchema=fieldSchema.getValueType().getTypes().get(unionIndex);
memberValue=fromByteBuffer(realSchema,hColumn.getValue());
}
 else {
memberValue=fromByteBuffer(fieldSchema.getValueType(),hColumn.getValue());
}
map.put(mapKey,memberValue);
}
}
value=map;
break;
case RECORD:
String fullName=fieldSchema.getFullName();
Class<?> claz=null;
try {
claz=Class.forName(fullName);
}
 catch (ClassNotFoundException cnfe) {
LOG.warn(""String_Node_Str"" + fullName,cnfe);
break;
}
try {
value=claz.newInstance();
}
 catch (InstantiationException ie) {
LOG.warn(""String_Node_Str"",ie);
break;
}
catch (IllegalAccessException iae) {
LOG.warn(""String_Node_Str"",iae);
break;
}
if (value instanceof PersistentBase) {
PersistentBase record=(PersistentBase)value;
for (HColumn<ByteBuffer,ByteBuffer> hColumn : this.hSuperColumn.getColumns()) {
String memberName=StringSerializer.get().fromByteBuffer(hColumn.getName());
if (memberName.indexOf(CassandraStore.UNION_COL_SUFIX) < 0) {
if (memberName == null || memberName.length() == 0) {
LOG.warn(""String_Node_Str"");
continue;
}
Field memberField=fieldSchema.getField(memberName);
Schema memberSchema=memberField.schema();
Type memberType=memberSchema.getType();
CassandraSubColumn cassandraColumn=new CassandraSubColumn();
cassandraColumn.setField(memberField);
cassandraColumn.setValue(hColumn);
if (memberType.equals(Type.UNION)) {
HColumn<ByteBuffer,ByteBuffer> hc=getUnionTypeColumn(memberField.name() + CassandraStore.UNION_COL_SUFIX,this.hSuperColumn.getColumns().toArray());
Integer unionIndex=getUnionIndex(memberField.name(),hc);
cassandraColumn.setUnionType(unionIndex);
}
record.put(record.getSchema().getField(memberName).pos(),cassandraColumn.getValue());
}
}
}
break;
case UNION:
int schemaPos=this.getUnionType();
Schema unioSchema=fieldSchema.getTypes().get(schemaPos);
Type unionType=unioSchema.getType();
value=getSuperValue(field,unioSchema,unionType);
break;
default :
Object memberValue=null;
for (HColumn<ByteBuffer,ByteBuffer> hColumn : this.hSuperColumn.getColumns()) {
memberValue=fromByteBuffer(fieldSchema,hColumn.getValue());
}
value=memberValue;
LOG.warn(""String_Node_Str"" + type.name() + ""String_Node_Str""+ field.name());
}
return value;
}","private Object getSuperValue(Field field,Schema fieldSchema,Type type){
  Object value=null;
switch (type) {
case ARRAY:
    List<Object> array=new ArrayList<Object>();
  for (  HColumn<ByteBuffer,ByteBuffer> hColumn : this.hSuperColumn.getColumns()) {
    Object memberValue=fromByteBuffer(fieldSchema.getElementType(),hColumn.getValue());
    array.add(memberValue);
  }
value=array;
break;
case MAP:
Map<CharSequence,Object> map=new HashMap<CharSequence,Object>();
for (HColumn<ByteBuffer,ByteBuffer> hColumn : this.hSuperColumn.getColumns()) {
CharSequence mapKey=CharSequenceSerializer.get().fromByteBuffer(hColumn.getName());
if (mapKey.toString().indexOf(CassandraStore.UNION_COL_SUFIX) < 0) {
Object memberValue=null;
if (fieldSchema.getValueType().getType().equals(Type.UNION)) {
HColumn<ByteBuffer,ByteBuffer> cc=getUnionTypeColumn(mapKey + CassandraStore.UNION_COL_SUFIX,this.hSuperColumn.getColumns());
Integer unionIndex=getUnionIndex(mapKey.toString(),cc);
Schema realSchema=fieldSchema.getValueType().getTypes().get(unionIndex);
memberValue=fromByteBuffer(realSchema,hColumn.getValue());
}
 else {
memberValue=fromByteBuffer(fieldSchema.getValueType(),hColumn.getValue());
}
map.put(mapKey,memberValue);
}
}
value=map;
break;
case RECORD:
String fullName=fieldSchema.getFullName();
Class<?> claz=null;
try {
claz=Class.forName(fullName);
}
 catch (ClassNotFoundException cnfe) {
LOG.warn(""String_Node_Str"" + fullName,cnfe);
break;
}
try {
value=claz.newInstance();
}
 catch (InstantiationException ie) {
LOG.warn(""String_Node_Str"",ie);
break;
}
catch (IllegalAccessException iae) {
LOG.warn(""String_Node_Str"",iae);
break;
}
if (value instanceof PersistentBase) {
PersistentBase record=(PersistentBase)value;
for (HColumn<ByteBuffer,ByteBuffer> hColumn : this.hSuperColumn.getColumns()) {
String memberName=StringSerializer.get().fromByteBuffer(hColumn.getName());
if (memberName == null || memberName.length() == 0) {
LOG.warn(""String_Node_Str"");
continue;
}
if (!memberName.contains(CassandraStore.UNION_COL_SUFIX)) {
Field memberField=fieldSchema.getField(memberName);
Schema memberSchema=memberField.schema();
Type memberType=memberSchema.getType();
CassandraSubColumn cassandraColumn=new CassandraSubColumn();
cassandraColumn.setField(memberField);
cassandraColumn.setValue(hColumn);
if (memberType.equals(Type.UNION)) {
HColumn<ByteBuffer,ByteBuffer> hc=getUnionTypeColumn(memberField.name() + CassandraStore.UNION_COL_SUFIX,this.hSuperColumn.getColumns().toArray());
Integer unionIndex=getUnionIndex(memberField.name(),hc);
cassandraColumn.setUnionType(unionIndex);
}
record.put(record.getSchema().getField(memberName).pos(),cassandraColumn.getValue());
}
}
}
break;
case UNION:
int schemaPos=this.getUnionType();
Schema unioSchema=fieldSchema.getTypes().get(schemaPos);
Type unionType=unioSchema.getType();
value=getSuperValue(field,unioSchema,unionType);
break;
default :
Object memberValue=null;
for (HColumn<ByteBuffer,ByteBuffer> hColumn : this.hSuperColumn.getColumns()) {
memberValue=fromByteBuffer(fieldSchema,hColumn.getValue());
}
value=memberValue;
LOG.warn(""String_Node_Str"" + type.name() + ""String_Node_Str""+ field.name());
}
return value;
}",0.9669395465994962
80184,"/** 
 * Primary class for loading Cassandra configuration from the 'MAPPING_FILE'.
 * @throws JDOMException
 * @throws IOException
 */
@SuppressWarnings(""String_Node_Str"") public void loadConfiguration() throws JDOMException, IOException {
  SAXBuilder saxBuilder=new SAXBuilder();
  InputStream inputStream=getClass().getClassLoader().getResourceAsStream(MAPPING_FILE);
  if (inputStream == null) {
    LOG.warn(""String_Node_Str"" + MAPPING_FILE + ""String_Node_Str"");
    throw new IOException(""String_Node_Str"" + MAPPING_FILE + ""String_Node_Str"");
  }
  Document document=saxBuilder.build(inputStream);
  if (document == null) {
    LOG.warn(""String_Node_Str"" + MAPPING_FILE + ""String_Node_Str"");
  }
  Element root=document.getRootElement();
  List<Element> keyspaces=root.getChildren(KEYSPACE_ELEMENT);
  if (keyspaces == null || keyspaces.size() == 0) {
    LOG.error(""String_Node_Str"");
  }
 else {
    for (    Element keyspace : keyspaces) {
      String keyspaceName=keyspace.getAttributeValue(NAME_ATTRIBUTE);
      String clusterName=keyspace.getAttributeValue(CLUSTER_ATTRIBUTE);
      String hostName=keyspace.getAttributeValue(HOST_ATTRIBUTE);
      if (LOG.isDebugEnabled()) {
        LOG.debug(""String_Node_Str"" + keyspaceName + ""String_Node_Str""+ clusterName+ ""String_Node_Str""+ hostName+ ""String_Node_Str"");
      }
      if (keyspaceName == null) {
        LOG.error(""String_Node_Str"");
        continue;
      }
      keyspaceMap.put(keyspaceName,keyspace);
    }
  }
  List<Element> mappings=root.getChildren(MAPPING_ELEMENT);
  if (mappings == null || mappings.size() == 0) {
    LOG.error(""String_Node_Str"");
  }
 else {
    for (    Element mapping : mappings) {
      String className=mapping.getAttributeValue(NAME_ATTRIBUTE);
      String keyClassName=mapping.getAttributeValue(KEYCLASS_ATTRIBUTE);
      String keyspaceName=mapping.getAttributeValue(KEYSPACE_ELEMENT);
      if (LOG.isDebugEnabled()) {
        LOG.debug(""String_Node_Str"" + keyClassName + ""String_Node_Str""+ className+ ""String_Node_Str""+ keyspaceName+ ""String_Node_Str"");
      }
      if (className == null) {
        LOG.error(""String_Node_Str"");
        continue;
      }
      mappingMap.put(className,mapping);
    }
  }
}","/** 
 * Primary class for loading Cassandra configuration from the 'MAPPING_FILE'.
 * @throws JDOMException
 * @throws IOException
 */
@SuppressWarnings(""String_Node_Str"") public void loadConfiguration() throws JDOMException, IOException {
  SAXBuilder saxBuilder=new SAXBuilder();
  InputStream inputStream=getClass().getClassLoader().getResourceAsStream(MAPPING_FILE);
  if (inputStream == null) {
    LOG.warn(""String_Node_Str"" + MAPPING_FILE + ""String_Node_Str"");
    throw new IOException(""String_Node_Str"" + MAPPING_FILE + ""String_Node_Str"");
  }
  Document document=saxBuilder.build(inputStream);
  if (document == null) {
    LOG.warn(""String_Node_Str"" + MAPPING_FILE + ""String_Node_Str"");
    throw new IOException(""String_Node_Str"" + MAPPING_FILE + ""String_Node_Str"");
  }
  Element root=document.getRootElement();
  List<Element> keyspaces=root.getChildren(KEYSPACE_ELEMENT);
  if (keyspaces == null || keyspaces.size() == 0) {
    LOG.error(""String_Node_Str"");
  }
 else {
    for (    Element keyspace : keyspaces) {
      String keyspaceName=keyspace.getAttributeValue(NAME_ATTRIBUTE);
      String clusterName=keyspace.getAttributeValue(CLUSTER_ATTRIBUTE);
      String hostName=keyspace.getAttributeValue(HOST_ATTRIBUTE);
      if (LOG.isDebugEnabled()) {
        LOG.debug(""String_Node_Str"" + keyspaceName + ""String_Node_Str""+ clusterName+ ""String_Node_Str""+ hostName+ ""String_Node_Str"");
      }
      if (keyspaceName == null) {
        LOG.error(""String_Node_Str"");
        continue;
      }
      keyspaceMap.put(keyspaceName,keyspace);
    }
  }
  List<Element> mappings=root.getChildren(MAPPING_ELEMENT);
  if (mappings == null || mappings.size() == 0) {
    LOG.error(""String_Node_Str"");
  }
 else {
    for (    Element mapping : mappings) {
      String className=mapping.getAttributeValue(NAME_ATTRIBUTE);
      String keyClassName=mapping.getAttributeValue(KEYCLASS_ATTRIBUTE);
      String keyspaceName=mapping.getAttributeValue(KEYSPACE_ELEMENT);
      if (LOG.isDebugEnabled()) {
        LOG.debug(""String_Node_Str"" + keyClassName + ""String_Node_Str""+ className+ ""String_Node_Str""+ keyspaceName+ ""String_Node_Str"");
      }
      if (className == null) {
        LOG.error(""String_Node_Str"");
        continue;
      }
      mappingMap.put(className,mapping);
    }
  }
}",0.9820915321689144
80185,"@Override public Result<K,T> execute(Query<K,T> query){
  K startKey=query.getStartKey();
  K endKey=query.getEndKey();
  if (startKey == null) {
    startKey=map.firstKey();
  }
  if (endKey == null) {
    endKey=map.lastKey();
  }
  query.setFields(getFieldsToQuery(query.getFields()));
  NavigableMap<K,T> submap=map.subMap(startKey,true,endKey,true);
  return new MemResult<K,T>(this,query,submap);
}","@SuppressWarnings(""String_Node_Str"") @Override public Result<K,T> execute(Query<K,T> query){
  K startKey=query.getStartKey();
  K endKey=query.getEndKey();
  if (startKey == null) {
    startKey=(K)map.firstKey();
  }
  if (endKey == null) {
    endKey=(K)map.lastKey();
  }
  query.setFields(getFieldsToQuery(query.getFields()));
  ConcurrentNavigableMap<K,T> submap=map.subMap(startKey,true,endKey,true);
  return new MemResult<K,T>(this,query,submap);
}",0.9384436701509872
80186,"@Override public void put(K key,T obj){
  map.put(key,obj);
}","@SuppressWarnings(""String_Node_Str"") @Override public void put(K key,T obj){
  map.put(key,obj);
}",0.7672955974842768
80187,"@Override public long deleteByQuery(Query<K,T> query){
  try {
    long deletedRows=0;
    Result<K,T> result=query.execute();
    while (result.next()) {
      if (delete(result.getKey()))       deletedRows++;
    }
    return 0;
  }
 catch (  Exception e) {
    return 0;
  }
}","@Override public long deleteByQuery(Query<K,T> query){
  try {
    long deletedRows=0;
    Result<K,T> result=query.execute();
    while (result.next()) {
      if (delete(result.getKey()))       deletedRows++;
    }
    return deletedRows;
  }
 catch (  Exception e) {
    return 0;
  }
}",0.9788732394366196
80188,"@Override public T get(K key,String[] fields){
  T obj=map.get(key);
  if (obj == null) {
    return null;
  }
  return getPersistent(obj,getFieldsToQuery(fields));
}","@SuppressWarnings(""String_Node_Str"") @Override public T get(K key,String[] fields){
  T obj=(T)map.get(key);
  if (obj == null) {
    return null;
  }
  return getPersistent(obj,getFieldsToQuery(fields));
}",0.8924731182795699
80189,"@Override public void close(){
  map.clear();
}","@Override public void close(){
}",0.810126582278481
80190,"/** 
 * Persist an object into the store.
 * @param key identifier of the object in the store
 * @param obj the object to be inserted
 */
@Override public void put(K key,T obj){
  if (obj.isNew() || obj.isDirty())   putUpdate(key,obj);
 else   LOG.info(""String_Node_Str"" + ""String_Node_Str"",new Object[]{obj});
  obj.clearNew();
  obj.clearDirty();
}","/** 
 * Persist an object into the store.
 * @param key identifier of the object in the store
 * @param obj the object to be inserted
 */
@Override public void put(K key,T obj){
  if (obj.isNew() || obj.isDirty()) {
    putUpdate(key,obj);
  }
 else {
    LOG.info(""String_Node_Str"" + ""String_Node_Str"",new Object[]{obj});
    obj.clearNew();
    obj.clearDirty();
  }
}",0.9722222222222222
80191,"/** 
 * Update a object that already exists in the store. The object must exist already or the update may fail.
 * @param key identifier of the object in the store
 * @param obj the object to be inserted
 */
private void putUpdate(K key,T obj){
  DBObject qSel=new BasicDBObject(""String_Node_Str"",key);
  BasicDBObject qUpdate=new BasicDBObject();
  BasicDBObject qUpdateSet=newUpdateSetInstance(obj);
  if (qUpdateSet.size() > 0)   qUpdate.put(""String_Node_Str"",qUpdateSet);
  BasicDBObject qUpdateUnset=newUpdateUnsetInstance(obj);
  if (qUpdateUnset.size() > 0)   qUpdate.put(""String_Node_Str"",qUpdateUnset);
  mongoClientColl.update(qSel,qUpdate,true,false);
}","/** 
 * Update a object that already exists in the store. The object must exist already or the update may fail.
 * @param key identifier of the object in the store
 * @param obj the object to be inserted
 */
private void putUpdate(K key,T obj){
  DBObject qSel=new BasicDBObject(""String_Node_Str"",key);
  BasicDBObject qUpdate=new BasicDBObject();
  BasicDBObject qUpdateSet=newUpdateSetInstance(obj);
  if (qUpdateSet.size() > 0) {
    qUpdate.put(""String_Node_Str"",qUpdateSet);
  }
  BasicDBObject qUpdateUnset=newUpdateUnsetInstance(obj);
  if (qUpdateUnset.size() > 0) {
    qUpdate.put(""String_Node_Str"",qUpdateUnset);
  }
  if (!qUpdate.isEmpty()) {
    mongoClientColl.update(qSel,qUpdate,true,false);
  }
 else {
    LOG.debug(""String_Node_Str"",key);
  }
}",0.9299719887955182
80192,"private Object toDBObject(Schema fieldSchema,Type fieldType,DocumentFieldType storeType,Object value){
  Object result=null;
switch (fieldType) {
case MAP:
    if (storeType != null && storeType != DocumentFieldType.DOCUMENT) {
      throw new IllegalStateException(""String_Node_Str"" + fieldSchema.getType() + ""String_Node_Str"");
    }
  Schema valueSchema=fieldSchema.getValueType();
result=toMongoMap((Map<Utf8,?>)value,valueSchema.getType());
break;
case ARRAY:
if (storeType != null && storeType != DocumentFieldType.LIST) {
throw new IllegalStateException(""String_Node_Str"" + fieldSchema.getType() + ""String_Node_Str"");
}
Schema elementSchema=fieldSchema.getElementType();
result=toMongoList((GenericArray<?>)value,elementSchema.getType());
break;
case BYTES:
if (value != null) {
result=((ByteBuffer)value).array();
}
break;
case INT:
case LONG:
case FLOAT:
case DOUBLE:
case BOOLEAN:
result=value;
break;
case STRING:
if (storeType == DocumentFieldType.OBJECTID) {
if (value != null) {
ObjectId id;
try {
id=new ObjectId(value.toString());
}
 catch (IllegalArgumentException e1) {
throw new IllegalStateException(""String_Node_Str"" + fieldSchema.getType() + ""String_Node_Str"");
}
result=id;
}
}
 else if (storeType == DocumentFieldType.DATE) {
if (value != null) {
Calendar calendar=null;
try {
calendar=DatatypeConverter.parseDateTime(value.toString());
}
 catch (IllegalArgumentException e1) {
try {
calendar=DatatypeConverter.parseDate(value.toString());
}
 catch (IllegalArgumentException e2) {
}
}
if (calendar == null) {
throw new IllegalStateException(""String_Node_Str"" + fieldSchema.getType() + ""String_Node_Str""+ value+ ""String_Node_Str"");
}
result=calendar.getTime();
}
}
 else {
if (value != null) {
result=value.toString();
}
}
break;
case ENUM:
if (value != null) result=value.toString();
break;
case RECORD:
if (value == null) break;
BasicDBObject record=new BasicDBObject();
for (Field member : fieldSchema.getFields()) {
Object innerValue=((PersistentBase)value).get(member.pos());
String innerDoc=mapping.getDocumentField(member.name());
Type innerType=member.schema().getType();
DocumentFieldType innerStoreType=mapping.getDocumentFieldType(innerDoc);
record.put(member.name(),toDBObject(member.schema(),innerType,innerStoreType,innerValue));
}
result=record;
break;
case UNION:
Type type0=fieldSchema.getTypes().get(0).getType();
Type type1=fieldSchema.getTypes().get(1).getType();
if (!type0.equals(type1) && (type0.equals(Schema.Type.NULL) || type1.equals(Schema.Type.NULL))) {
Schema innerSchema=fieldSchema.getTypes().get(1);
DocumentFieldType innerStoreType=mapping.getDocumentFieldType(innerSchema.getName());
result=toDBObject(innerSchema,type1,innerStoreType,value);
}
break;
case FIXED:
result=value;
break;
default :
LOG.error(""String_Node_Str"" + fieldSchema.getType());
break;
}
return result;
}","private Object toDBObject(Schema fieldSchema,Type fieldType,DocumentFieldType storeType,Object value){
  Object result=null;
switch (fieldType) {
case MAP:
    if (storeType != null && storeType != DocumentFieldType.DOCUMENT) {
      throw new IllegalStateException(""String_Node_Str"" + fieldSchema.getType() + ""String_Node_Str"");
    }
  Schema valueSchema=fieldSchema.getValueType();
result=toMongoMap((Map<Utf8,?>)value,valueSchema.getType());
break;
case ARRAY:
if (storeType != null && storeType != DocumentFieldType.LIST) {
throw new IllegalStateException(""String_Node_Str"" + fieldSchema.getType() + ""String_Node_Str"");
}
Schema elementSchema=fieldSchema.getElementType();
result=toMongoList((GenericArray<?>)value,elementSchema.getType());
break;
case BYTES:
if (value != null) {
result=((ByteBuffer)value).array();
}
break;
case INT:
case LONG:
case FLOAT:
case DOUBLE:
case BOOLEAN:
result=value;
break;
case STRING:
if (storeType == DocumentFieldType.OBJECTID) {
if (value != null) {
ObjectId id;
try {
id=new ObjectId(value.toString());
}
 catch (IllegalArgumentException e1) {
throw new IllegalStateException(""String_Node_Str"" + fieldSchema.getType() + ""String_Node_Str"");
}
result=id;
}
}
 else if (storeType == DocumentFieldType.DATE) {
if (value != null) {
Calendar calendar=null;
try {
calendar=DatatypeConverter.parseDateTime(value.toString());
}
 catch (IllegalArgumentException e1) {
try {
calendar=DatatypeConverter.parseDate(value.toString());
}
 catch (IllegalArgumentException e2) {
}
}
if (calendar == null) {
throw new IllegalStateException(""String_Node_Str"" + fieldSchema.getType() + ""String_Node_Str""+ value+ ""String_Node_Str"");
}
result=calendar.getTime();
}
}
 else {
if (value != null) {
result=value.toString();
}
}
break;
case ENUM:
if (value != null) result=value.toString();
break;
case RECORD:
if (value == null) break;
BasicDBObject record=new BasicDBObject();
for (Field member : fieldSchema.getFields()) {
Object innerValue=((PersistentBase)value).get(member.pos());
String innerDoc=mapping.getDocumentField(member.name());
Type innerType=member.schema().getType();
DocumentFieldType innerStoreType=mapping.getDocumentFieldType(innerDoc);
LOG.debug(""String_Node_Str"",new Object[]{member.name(),member.schema().getType(),innerStoreType});
record.put(member.name(),toDBObject(member.schema(),innerType,innerStoreType,innerValue));
}
result=record;
break;
case UNION:
Type type0=fieldSchema.getTypes().get(0).getType();
Type type1=fieldSchema.getTypes().get(1).getType();
if (!type0.equals(type1) && (type0.equals(Schema.Type.NULL) || type1.equals(Schema.Type.NULL))) {
Schema innerSchema=fieldSchema.getTypes().get(1);
DocumentFieldType innerStoreType=mapping.getDocumentFieldType(innerSchema.getName());
LOG.debug(""String_Node_Str"",new Object[]{innerSchema.getType(),type1,innerStoreType});
result=toDBObject(innerSchema,type1,innerStoreType,value);
}
break;
case FIXED:
result=value;
break;
default :
LOG.error(""String_Node_Str"" + fieldSchema.getType());
break;
}
return result;
}",0.9681942544459644
80193,"/** 
 * Build a new instance of   {@link DBObject} from the persistence classinstance in parameter. Limit the  {@link DBObject} to the fields that aredirty and not null, that is the fields that will need to be updated in the store. <p/> This implementation mainly differs from the {@link MongoStore#newInstance(org.apache.gora.persistency.impl.PersistentBase)} one from two points:<ol> <li>the restriction to fields that are dirty and then need an update</li> <li>the qualification of field names as fully qualified names</li> </ol>
 * @param persistent a persistence class instance which content is to be serialized as a  {@link DBObject} for use as parameter of a $set operator
 * @return a {@link DBObject} which content corresponds to the fields thathave to be updated... and formatted to be passed in parameter of a $set operator
 */
private BasicDBObject newUpdateSetInstance(T persistent){
  BasicDBObject result=new BasicDBObject();
  for (  Field f : persistent.getSchema().getFields()) {
    if (persistent.isReadable(f.pos()) && persistent.isDirty(f.pos()) && (persistent.get(f.pos()) != null)) {
      String docf=mapping.getDocumentField(f.name());
      Object value=persistent.get(f.pos());
      DocumentFieldType storeType=mapping.getDocumentFieldType(docf);
      result.put(docf,toDBObject(f.schema(),f.schema().getType(),storeType,value));
    }
  }
  return result;
}","/** 
 * Build a new instance of   {@link DBObject} from the persistence classinstance in parameter. Limit the  {@link DBObject} to the fields that aredirty and not null, that is the fields that will need to be updated in the store. <p/> This implementation mainly differs from the {@link MongoStore#newInstance(org.apache.gora.persistency.impl.PersistentBase)} one from two points:<ol> <li>the restriction to fields that are dirty and then need an update</li> <li>the qualification of field names as fully qualified names</li> </ol>
 * @param persistent a persistence class instance which content is to be serialized as a  {@link DBObject} for use as parameter of a $set operator
 * @return a {@link DBObject} which content corresponds to the fields thathave to be updated... and formatted to be passed in parameter of a $set operator
 */
private BasicDBObject newUpdateSetInstance(T persistent){
  BasicDBObject result=new BasicDBObject();
  for (  Field f : persistent.getSchema().getFields()) {
    if (persistent.isReadable(f.pos()) && persistent.isDirty(f.pos()) && (persistent.get(f.pos()) != null)) {
      String docf=mapping.getDocumentField(f.name());
      Object value=persistent.get(f.pos());
      DocumentFieldType storeType=mapping.getDocumentFieldType(docf);
      LOG.debug(""String_Node_Str"",new Object[]{docf,f.schema().getType(),storeType});
      result.put(docf,toDBObject(f.schema(),f.schema().getType(),storeType,value));
    }
  }
  return result;
}",0.9699510831586304
80194,"private Object fromDBObject(final Schema fieldSchema,final DocumentFieldType storeType,final Field field,final String docf,final BSONDecorator easybson){
  Object result=null;
switch (fieldSchema.getType()) {
case MAP:
    BasicDBObject map=easybson.getDBObject(docf);
  StatefulHashMap<Utf8,Object> rmap=new StatefulHashMap<Utf8,Object>();
for (Entry<String,Object> e : map.entrySet()) {
  String oKey=e.getKey().replace(""String_Node_Str"",""String_Node_Str"");
switch (fieldSchema.getValueType().getType()) {
case STRING:
    rmap.put(new Utf8(oKey),new Utf8((String)e.getValue()));
  break;
case BYTES:
rmap.put(new Utf8(oKey),ByteBuffer.wrap((byte[])e.getValue()));
break;
default :
rmap.put(new Utf8(oKey),e.getValue());
break;
}
}
rmap.clearStates();
result=rmap;
break;
case ARRAY:
List<Object> list=easybson.getDBList(docf);
switch (fieldSchema.getElementType().getType()) {
case STRING:
ListGenericArray<Utf8> arrS=new ListGenericArray<Utf8>(fieldSchema);
for (Object o : list) arrS.add(new Utf8((String)o));
result=arrS;
break;
case BYTES:
ListGenericArray<ByteBuffer> arrB=new ListGenericArray<ByteBuffer>(fieldSchema);
for (Object o : list) arrB.add(ByteBuffer.wrap((byte[])o));
result=arrB;
break;
default :
ListGenericArray<Object> arrT=new ListGenericArray<Object>(fieldSchema);
for (Object o : list) arrT.add(o);
result=arrT;
break;
}
break;
case RECORD:
DBObject rec=easybson.getDBObject(docf);
BSONDecorator innerBson=new BSONDecorator(rec);
Class<?> clazz=null;
try {
clazz=ClassLoadingUtils.loadClass(fieldSchema.getFullName());
}
 catch (ClassNotFoundException e) {
}
Persistent record=new BeanFactoryImpl(keyClass,clazz).newPersistent();
for (Field recField : fieldSchema.getFields()) {
Schema innerSchema=recField.schema();
DocumentFieldType innerStoreType=mapping.getDocumentFieldType(innerSchema.getName());
String recDocField=mapping.getDocumentField(recField.name()) != null ? mapping.getDocumentField(recField.name()) : recField.name();
((PersistentBase)record).put(recField.pos(),fromDBObject(innerSchema,innerStoreType,recField,recDocField,innerBson));
}
result=record;
break;
case BOOLEAN:
result=easybson.getBoolean(docf);
break;
case DOUBLE:
result=easybson.getDouble(docf);
break;
case FLOAT:
result=easybson.getDouble(docf).floatValue();
break;
case INT:
result=easybson.getInt(docf);
break;
case LONG:
result=easybson.getLong(docf);
break;
case STRING:
if (storeType == DocumentFieldType.OBJECTID) {
final Object bin=easybson.get(docf);
final ObjectId id=ObjectId.massageToObjectId(bin);
result=new Utf8(id.toString());
}
 else if (storeType == DocumentFieldType.DATE) {
final Object bin=easybson.get(docf);
if (bin instanceof Date) {
Calendar calendar=Calendar.getInstance(TimeZone.getTimeZone(""String_Node_Str""));
calendar.setTime((Date)bin);
result=new Utf8(DatatypeConverter.printDateTime(calendar));
}
 else {
result=new Utf8(bin.toString());
}
}
 else {
result=easybson.getUtf8String(docf);
}
break;
case ENUM:
result=AvroUtils.getEnumValue(fieldSchema,easybson.getUtf8String(docf).toString());
break;
case BYTES:
case FIXED:
result=easybson.getBytes(docf);
break;
case NULL:
result=null;
break;
case UNION:
Type type0=fieldSchema.getTypes().get(0).getType();
Type type1=fieldSchema.getTypes().get(1).getType();
if (!type0.equals(type1) && (type0.equals(Type.NULL) || type1.equals(Type.NULL))) {
Schema innerSchema=fieldSchema.getTypes().get(1);
DocumentFieldType innerStoreType=mapping.getDocumentFieldType(innerSchema.getName());
result=fromDBObject(innerSchema,innerStoreType,field,docf,easybson);
}
break;
default :
LOG.warn(""String_Node_Str"",docf);
break;
}
return result;
}","private Object fromDBObject(final Schema fieldSchema,final DocumentFieldType storeType,final Field field,final String docf,final BSONDecorator easybson){
  Object result=null;
switch (fieldSchema.getType()) {
case MAP:
    BasicDBObject map=easybson.getDBObject(docf);
  StatefulHashMap<Utf8,Object> rmap=new StatefulHashMap<Utf8,Object>();
for (Entry<String,Object> e : map.entrySet()) {
  String oKey=e.getKey().replace(""String_Node_Str"",""String_Node_Str"");
switch (fieldSchema.getValueType().getType()) {
case STRING:
    rmap.put(new Utf8(oKey),new Utf8((String)e.getValue()));
  break;
case BYTES:
rmap.put(new Utf8(oKey),ByteBuffer.wrap((byte[])e.getValue()));
break;
default :
rmap.put(new Utf8(oKey),e.getValue());
break;
}
}
rmap.clearStates();
result=rmap;
break;
case ARRAY:
List<Object> list=easybson.getDBList(docf);
switch (fieldSchema.getElementType().getType()) {
case STRING:
ListGenericArray<Utf8> arrS=new ListGenericArray<Utf8>(fieldSchema);
for (Object o : list) arrS.add(new Utf8((String)o));
result=arrS;
break;
case BYTES:
ListGenericArray<ByteBuffer> arrB=new ListGenericArray<ByteBuffer>(fieldSchema);
for (Object o : list) arrB.add(ByteBuffer.wrap((byte[])o));
result=arrB;
break;
default :
ListGenericArray<Object> arrT=new ListGenericArray<Object>(fieldSchema);
for (Object o : list) arrT.add(o);
result=arrT;
break;
}
break;
case RECORD:
DBObject rec=easybson.getDBObject(docf);
if (rec == null) {
return result;
}
BSONDecorator innerBson=new BSONDecorator(rec);
Class<?> clazz=null;
try {
clazz=ClassLoadingUtils.loadClass(fieldSchema.getFullName());
}
 catch (ClassNotFoundException e) {
}
Persistent record=new BeanFactoryImpl(keyClass,clazz).newPersistent();
for (Field recField : fieldSchema.getFields()) {
Schema innerSchema=recField.schema();
DocumentFieldType innerStoreType=mapping.getDocumentFieldType(innerSchema.getName());
String innerDocField=mapping.getDocumentField(recField.name()) != null ? mapping.getDocumentField(recField.name()) : recField.name();
String fieldPath=docf + ""String_Node_Str"" + innerDocField;
LOG.debug(""String_Node_Str"",new Object[]{recField.name(),innerSchema.getType(),fieldPath,innerStoreType});
((PersistentBase)record).put(recField.pos(),fromDBObject(innerSchema,innerStoreType,recField,innerDocField,innerBson));
}
result=record;
break;
case BOOLEAN:
result=easybson.getBoolean(docf);
break;
case DOUBLE:
result=easybson.getDouble(docf);
break;
case FLOAT:
result=easybson.getDouble(docf).floatValue();
break;
case INT:
result=easybson.getInt(docf);
break;
case LONG:
result=easybson.getLong(docf);
break;
case STRING:
if (storeType == DocumentFieldType.OBJECTID) {
final Object bin=easybson.get(docf);
final ObjectId id=ObjectId.massageToObjectId(bin);
result=new Utf8(id.toString());
}
 else if (storeType == DocumentFieldType.DATE) {
final Object bin=easybson.get(docf);
if (bin instanceof Date) {
Calendar calendar=Calendar.getInstance(TimeZone.getTimeZone(""String_Node_Str""));
calendar.setTime((Date)bin);
result=new Utf8(DatatypeConverter.printDateTime(calendar));
}
 else {
result=new Utf8(bin.toString());
}
}
 else {
result=easybson.getUtf8String(docf);
}
break;
case ENUM:
result=AvroUtils.getEnumValue(fieldSchema,easybson.getUtf8String(docf).toString());
break;
case BYTES:
case FIXED:
result=easybson.getBytes(docf);
break;
case NULL:
result=null;
break;
case UNION:
Type type0=fieldSchema.getTypes().get(0).getType();
Type type1=fieldSchema.getTypes().get(1).getType();
if (!type0.equals(type1) && (type0.equals(Type.NULL) || type1.equals(Type.NULL))) {
Schema innerSchema=fieldSchema.getTypes().get(1);
DocumentFieldType innerStoreType=mapping.getDocumentFieldType(innerSchema.getName());
LOG.debug(""String_Node_Str"",new Object[]{innerSchema.getType(),docf,innerStoreType});
result=fromDBObject(innerSchema,innerStoreType,field,docf,easybson);
}
break;
default :
LOG.warn(""String_Node_Str"",docf);
break;
}
return result;
}",0.9596174282678002
80195,"/** 
 * Build a new instance of   {@link DBObject} from the persistence classinstance in parameter. Limit the  {@link DBObject} to the fields that aredirty and null, that is the fields that will need to be updated in the store by being removed. <p/> This implementation mainly differs from the {@link MongoStore#newInstance(org.apache.gora.persistency.impl.PersistentBase)} one from two points:<ol> <li>the restriction to fields that are dirty and then need an update</li> <li>the qualification of field names as fully qualified names</li> </ol>
 * @param persistent a persistence class instance which content is to be serialized as a  {@link DBObject} for use as parameter of a $set operator
 * @return a {@link DBObject} which content corresponds to the fields thathave to be updated... and formated to be passed in parameter of a $unset operator
 */
private BasicDBObject newUpdateUnsetInstance(T persistent){
  BasicDBObject result=new BasicDBObject();
  for (  Field f : persistent.getSchema().getFields()) {
    if (persistent.isReadable(f.pos()) && persistent.isDirty(f.pos()) && (persistent.get(f.pos()) == null)) {
      String docf=mapping.getDocumentField(f.name());
      Object value=persistent.get(f.pos());
      DocumentFieldType storeType=mapping.getDocumentFieldType(docf);
      Object o=toDBObject(f.schema(),f.schema().getType(),storeType,value);
      result.put(docf,o);
    }
  }
  return result;
}","/** 
 * Build a new instance of   {@link DBObject} from the persistence classinstance in parameter. Limit the  {@link DBObject} to the fields that aredirty and null, that is the fields that will need to be updated in the store by being removed. <p/> This implementation mainly differs from the {@link MongoStore#newInstance(org.apache.gora.persistency.impl.PersistentBase)} one from two points:<ol> <li>the restriction to fields that are dirty and then need an update</li> <li>the qualification of field names as fully qualified names</li> </ol>
 * @param persistent a persistence class instance which content is to be serialized as a  {@link DBObject} for use as parameter of a $set operator
 * @return a {@link DBObject} which content corresponds to the fields thathave to be updated... and formated to be passed in parameter of a $unset operator
 */
private BasicDBObject newUpdateUnsetInstance(T persistent){
  BasicDBObject result=new BasicDBObject();
  for (  Field f : persistent.getSchema().getFields()) {
    if (persistent.isReadable(f.pos()) && persistent.isDirty(f.pos()) && (persistent.get(f.pos()) == null)) {
      String docf=mapping.getDocumentField(f.name());
      Object value=persistent.get(f.pos());
      DocumentFieldType storeType=mapping.getDocumentFieldType(docf);
      LOG.debug(""String_Node_Str"",new Object[]{docf,f.schema().getType(),storeType});
      Object o=toDBObject(f.schema(),f.schema().getType(),storeType,value);
      result.put(docf,o);
    }
  }
  return result;
}",0.9706484641638226
80196,"/** 
 * Compute the projection of the query, that is the fields that will be retrieved from the database.
 * @return a {@link DBObject} corresponding to the list of field to beretrieved with the associated boolean
 */
public static DBObject toProjection(Query<?,?> query){
  BasicDBObject proj=new BasicDBObject();
  for (  String k : query.getFields())   proj.put(k,true);
  return proj;
}","/** 
 * Compute the projection of the query, that is the fields that will be retrieved from the database.
 * @return a {@link DBObject} corresponding to the list of field to beretrieved with the associated boolean
 */
public static DBObject toProjection(Query<?,?> query){
  BasicDBObject proj=new BasicDBObject();
  if (query.getFields() != null) {
    for (    String k : query.getFields())     proj.put(k,true);
  }
  return proj;
}",0.8993939393939394
80197,"/** 
 * Create a new collection in MongoDB if necessary.
 */
@Override public void createSchema(){
  if (mongoClientDB == null)   throw new IllegalStateException(""String_Node_Str"");
  mongoClientColl=mongoClientDB.createCollection(mapping.getCollectionName(),null);
  mongoClientColl.setDBEncoderFactory(GoraDBEncoder.FACTORY);
  LOG.info(""String_Node_Str"",new Object[]{mapping.getCollectionName(),mongoClientDB.getMongo()});
}","/** 
 * Create a new collection in MongoDB if necessary.
 */
@Override public void createSchema(){
  if (mongoClientDB == null)   throw new IllegalStateException(""String_Node_Str"");
  if (schemaExists()) {
    return;
  }
  mongoClientColl=mongoClientDB.createCollection(mapping.getCollectionName(),new BasicDBObject());
  mongoClientColl.setDBEncoderFactory(GoraDBEncoder.FACTORY);
  LOG.info(""String_Node_Str"",new Object[]{mapping.getCollectionName(),mongoClientDB.getMongo()});
}",0.9328932893289328
80198,"/** 
 * Create a new   {@link Query} to query the datastore.
 */
@Override public Query<K,T> newQuery(){
  return new MongoDBQuery<K,T>(this);
}","/** 
 * Create a new   {@link Query} to query the datastore.
 */
@Override public Query<K,T> newQuery(){
  MongoDBQuery<K,T> query=new MongoDBQuery<K,T>(this);
  query.setFields(getFieldsToQuery(null));
  return query;
}",0.7307692307692307
80199,"/** 
 * Build a new instance of   {@link DBObject} from the persistence classinstance in parameter. Limit the  {@link DBObject} to the fields that aredirty and not null, that is the fields that will need to be updated in the store. <p/> This implementation mainly differs from the {@link MongoStore#newInstance(Persistent)} one from two points:<ol> <li>the restriction to fields that are dirty and then need an update</li> <li>the qualification of field names as fully qualified names</li> </ol>
 * @param persistent a persistence class instance which content is to be serialized as a  {@link DBObject} for use as parameter of a $set operator
 * @return a {@link DBObject} which content corresponds to the fields thathave to be updated... and formated to be passed in parameter of a $set operator
 */
private BasicDBObject newUpdateSetInstance(T persistent){
  BasicDBObject result=new BasicDBObject();
  for (  Field f : persistent.getSchema().getFields()) {
    if (persistent.isReadable(f.pos()) && persistent.isDirty(f.pos()) && (persistent.get(f.pos()) != null)) {
      String docf=mapping.getDocumentField(f.name());
      DocumentFieldType storeType=mapping.getDocumentFieldType(docf);
      Object value=persistent.get(f.pos());
switch (f.schema().getType()) {
case MAP:
        if (storeType != DocumentFieldType.DOCUMENT) {
          throw new IllegalStateException(""String_Node_Str"" + f.name() + ""String_Node_Str"");
        }
      result.put(docf,toMongoMap((Map<Utf8,?>)value,f.schema().getValueType().getType()));
    break;
case ARRAY:
  if (storeType != DocumentFieldType.LIST) {
    throw new IllegalStateException(""String_Node_Str"" + f.name() + ""String_Node_Str"");
  }
result.put(docf,toMongoList((GenericArray<?>)value,f.schema().getElementType().getType()));
break;
case BYTES:
if (value != null) result.put(docf,((ByteBuffer)value).array());
break;
case STRING:
if (storeType == DocumentFieldType.OBJECTID) {
if (value != null) {
ObjectId id;
try {
id=new ObjectId(value.toString());
}
 catch (IllegalArgumentException e1) {
throw new IllegalStateException(""String_Node_Str"" + f.name() + ""String_Node_Str"");
}
result.put(docf,id);
}
}
 else if (storeType == DocumentFieldType.DATE) {
if (value != null) {
Calendar calendar=null;
try {
calendar=DatatypeConverter.parseDateTime(value.toString());
}
 catch (IllegalArgumentException e1) {
try {
calendar=DatatypeConverter.parseDate(value.toString());
}
 catch (IllegalArgumentException e2) {
}
}
if (calendar == null) {
throw new IllegalStateException(""String_Node_Str"" + f.name() + ""String_Node_Str""+ value+ ""String_Node_Str"");
}
result.put(docf,calendar.getTime());
}
}
 else {
if (value != null) {
result.put(docf,value.toString());
}
}
break;
case ENUM:
if (value != null) result.put(docf,value.toString());
break;
case RECORD:
if (value == null) break;
BasicDBObject record=new BasicDBObject();
for (Field member : f.schema().getFields()) {
Object recValue=((PersistentBase)value).get(member.pos());
switch (member.schema().getType()) {
case MAP:
record.put(member.name(),toMongoMap((Map<Utf8,?>)recValue,member.schema().getElementType().getType()));
case ARRAY:
record.put(member.name(),toMongoList((GenericArray<?>)recValue,member.schema().getElementType().getType()));
break;
case STRING:
case ENUM:
if (recValue != null) record.put(member.name(),recValue.toString());
break;
case BYTES:
if (recValue != null) record.put(member.name(),((ByteBuffer)recValue).array());
break;
case RECORD:
throw new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"");
default :
record.put(member.name(),recValue);
break;
}
}
result.put(docf,record);
break;
default :
result.put(docf,value);
break;
}
}
}
return result;
}","/** 
 * Build a new instance of   {@link DBObject} from the persistence classinstance in parameter. Limit the  {@link DBObject} to the fields that aredirty and not null, that is the fields that will need to be updated in the store. <p/> This implementation mainly differs from the {@link MongoStore#newInstance(Persistent)} one from two points:<ol> <li>the restriction to fields that are dirty and then need an update</li> <li>the qualification of field names as fully qualified names</li> </ol>
 * @param persistent a persistence class instance which content is to be serialized as a  {@link DBObject} for use as parameter of a $set operator
 * @return a {@link DBObject} which content corresponds to the fields thathave to be updated... and formated to be passed in parameter of a $set operator
 */
private BasicDBObject newUpdateSetInstance(T persistent){
  BasicDBObject result=new BasicDBObject();
  for (  Field f : persistent.getSchema().getFields()) {
    if (persistent.isReadable(f.pos()) && persistent.isDirty(f.pos()) && (persistent.get(f.pos()) != null)) {
      String docf=mapping.getDocumentField(f.name());
      DocumentFieldType storeType=mapping.getDocumentFieldType(docf);
      Object value=persistent.get(f.pos());
switch (f.schema().getType()) {
case MAP:
        if (storeType != DocumentFieldType.DOCUMENT) {
          throw new IllegalStateException(""String_Node_Str"" + f.name() + ""String_Node_Str"");
        }
      result.put(docf,toMongoMap((Map<Utf8,?>)value,f.schema().getValueType().getType()));
    break;
case ARRAY:
  if (storeType != DocumentFieldType.LIST) {
    throw new IllegalStateException(""String_Node_Str"" + f.name() + ""String_Node_Str"");
  }
result.put(docf,toMongoList((GenericArray<?>)value,f.schema().getElementType().getType()));
break;
case BYTES:
if (value != null) result.put(docf,((ByteBuffer)value).array());
break;
case STRING:
if (storeType == DocumentFieldType.OBJECTID) {
if (value != null) {
ObjectId id;
try {
id=new ObjectId(value.toString());
}
 catch (IllegalArgumentException e1) {
throw new IllegalStateException(""String_Node_Str"" + f.name() + ""String_Node_Str"");
}
result.put(docf,id);
}
}
 else if (storeType == DocumentFieldType.DATE) {
if (value != null) {
Calendar calendar=null;
try {
calendar=DatatypeConverter.parseDateTime(value.toString());
}
 catch (IllegalArgumentException e1) {
try {
calendar=DatatypeConverter.parseDate(value.toString());
}
 catch (IllegalArgumentException e2) {
}
}
if (calendar == null) {
throw new IllegalStateException(""String_Node_Str"" + f.name() + ""String_Node_Str""+ value+ ""String_Node_Str"");
}
result.put(docf,calendar.getTime());
}
}
 else {
if (value != null) {
result.put(docf,value.toString());
}
}
break;
case ENUM:
if (value != null) result.put(docf,value.toString());
break;
case RECORD:
if (value == null) break;
BasicDBObject record=new BasicDBObject();
for (Field member : f.schema().getFields()) {
Object recValue=((PersistentBase)value).get(member.pos());
switch (member.schema().getType()) {
case MAP:
record.put(member.name(),toMongoMap((Map<Utf8,?>)recValue,member.schema().getValueType().getType()));
break;
case ARRAY:
record.put(member.name(),toMongoList((GenericArray<?>)recValue,member.schema().getElementType().getType()));
break;
case STRING:
case ENUM:
if (recValue != null) record.put(member.name(),recValue.toString());
break;
case BYTES:
if (recValue != null) record.put(member.name(),((ByteBuffer)recValue).array());
break;
case RECORD:
throw new IllegalStateException(""String_Node_Str"" + ""String_Node_Str"");
default :
record.put(member.name(),recValue);
break;
}
}
result.put(docf,record);
break;
default :
result.put(docf,value);
break;
}
}
}
return result;
}",0.9974265203846676
80200,"@Override public Date deserialize(JsonElement jsonElement,Type type,JsonDeserializationContext jsonDeserializationContext) throws JsonParseException {
  String date=jsonElement.getAsString();
  try {
    return DATE_FORMAT.get().parse(date);
  }
 catch (  ParseException e) {
    throw new JsonParseException(e);
  }
}","@Override public Date deserialize(JsonElement jsonElement,Type type,JsonDeserializationContext jsonDeserializationContext){
  String date=jsonElement.getAsString();
  try {
    return DATE_FORMAT.get().parse(date);
  }
 catch (  ParseException e) {
    throw new JsonParseException(e);
  }
}",0.955665024630542
80201,"/** 
 * Star-endpoint added in Gerrit 2.8.
 */
private String createStarUrl(String id) throws RestApiException {
  return getRequestPath() + ""String_Node_Str"" + id;
}","/** 
 * Star-endpoint added in Gerrit 2.8.
 */
private String createStarUrl(String id){
  return getRequestPath() + ""String_Node_Str"" + id;
}",0.9185667752442996
80202,"public List<AccountInfo> parseAccountInfos(JsonElement result) throws RestApiException {
  if (!result.isJsonArray()) {
    return Collections.singletonList(parseAccountInfo(result));
  }
  return gson.fromJson(result,TYPE);
}","public List<AccountInfo> parseAccountInfos(JsonElement result){
  if (!result.isJsonArray()) {
    return Collections.singletonList(parseAccountInfo(result));
  }
  return gson.fromJson(result,TYPE);
}",0.9414519906323184
80203,"public AccountInfo parseAccountInfo(JsonElement result) throws RestApiException {
  return gson.fromJson(result,AccountInfo.class);
}","public AccountInfo parseAccountInfo(JsonElement result){
  return gson.fromJson(result,AccountInfo.class);
}",0.8962655601659751
80204,"public List<ChangeInfo> parseChangeInfos(JsonElement result) throws RestApiException {
  if (!result.isJsonArray()) {
    return Collections.singletonList(gson.fromJson(result,ChangeInfo.class));
  }
  return gson.fromJson(result,TYPE);
}","public List<ChangeInfo> parseChangeInfos(JsonElement result){
  if (!result.isJsonArray()) {
    return Collections.singletonList(gson.fromJson(result,ChangeInfo.class));
  }
  return gson.fromJson(result,TYPE);
}",0.9445676274944568
80205,"public Map<String,FileInfo> parseFileInfos(JsonElement jsonElement) throws RestApiException {
  return gson.fromJson(jsonElement,TYPE);
}","public Map<String,FileInfo> parseFileInfos(JsonElement jsonElement){
  return gson.fromJson(jsonElement,TYPE);
}",0.8995983935742972
80206,"public IncludedInInfo parseIncludedInInfos(JsonElement jsonElement) throws RestApiException {
  return gson.fromJson(jsonElement,IncludedInInfo.class);
}","public IncludedInInfo parseIncludedInInfos(JsonElement jsonElement){
  return gson.fromJson(jsonElement,IncludedInInfo.class);
}",0.9110320284697508
80207,"public List<ReviewerInfo> parseReviewerInfos(JsonElement result) throws RestApiException {
  if (!result.isJsonArray()) {
    return Collections.singletonList(gson.fromJson(result,ReviewerInfo.class));
  }
  return gson.fromJson(result,TYPE);
}","public List<ReviewerInfo> parseReviewerInfos(JsonElement result){
  if (!result.isJsonArray()) {
    return Collections.singletonList(gson.fromJson(result,ReviewerInfo.class));
  }
  return gson.fromJson(result,TYPE);
}",0.9460043196544276
80208,"public List<SuggestedReviewerInfo> parseSuggestReviewerInfos(JsonElement result) throws RestApiException {
  if (!result.isJsonArray()) {
    return Collections.singletonList(gson.fromJson(result,SuggestedReviewerInfo.class));
  }
  return gson.fromJson(result,TYPE);
}","public List<SuggestedReviewerInfo> parseSuggestReviewerInfos(JsonElement result){
  if (!result.isJsonArray()) {
    return Collections.singletonList(gson.fromJson(result,SuggestedReviewerInfo.class));
  }
  return gson.fromJson(result,TYPE);
}",0.9512670565302144
80209,"public SortedMap<String,ProjectInfo> parseProjectInfos(JsonElement result) throws RestApiException {
  return gson.fromJson(result,TYPE);
}","public SortedMap<String,ProjectInfo> parseProjectInfos(JsonElement result){
  return gson.fromJson(result,TYPE);
}",0.9011857707509882
80210,"private static void setContentEncoding(HttpResponse response,BinaryResult binaryResult){
  Header contentEncoding=response.getFirstHeader(""String_Node_Str"");
  if (contentEncoding != null) {
    if (""String_Node_Str"".equals(contentEncoding.getValue())) {
      binaryResult.base64();
    }
  }
}","private static void setContentEncoding(HttpResponse response,BinaryResult binaryResult){
  Header contentEncoding=response.getFirstHeader(""String_Node_Str"");
  if (contentEncoding != null && ""String_Node_Str"".equals(contentEncoding.getValue())) {
    binaryResult.base64();
  }
}",0.7770034843205574
80211,"public static String appendToUrlQuery(String query,String parameter){
  if (!Strings.isNullOrEmpty(query)) {
    query+='&';
  }
  query+=parameter;
  return query;
}","public static String appendToUrlQuery(String query,String parameter){
  if (!Strings.isNullOrEmpty(query)) {
    query+=""String_Node_Str"";
  }
  query+=parameter;
  return query;
}",0.9421965317919077
80212,"@Override protected void configure(){
  installOpenIdeDependenciesModule();
  setupSettingsProvider();
  bind(NotificationService.class);
  bind(ReviewCommentSink.class).toInstance(new ReviewCommentSink());
  bind(GerritGitUtil.class).asEagerSingleton();
  bind(GerritUtil.class).asEagerSingleton();
  bind(GerritToolWindow.class).asEagerSingleton();
  bind(GerritCheckoutProvider.class);
  bind(GerritHttpAuthDataProvider.class);
  install(new GerritActionsModule());
  install(new GerritDiffModule());
  install(new GerritRestModule());
  install(new GerritUiModule());
}","@Override protected void configure(){
  installOpenIdeDependenciesModule();
  setupSettingsProvider();
  bind(NotificationService.class);
  bind(ReviewCommentSink.class).toInstance(new ReviewCommentSink());
  bind(GerritGitUtil.class).asEagerSingleton();
  bind(GerritUtil.class).asEagerSingleton();
  bind(GerritToolWindow.class);
  bind(GerritCheckoutProvider.class);
  bind(GerritHttpAuthDataProvider.class);
  install(new GerritActionsModule());
  install(new GerritDiffModule());
  install(new GerritRestModule());
  install(new GerritUiModule());
}",0.9831410825199643
80213,"@Override public void calcData(DataKey key,DataSink sink){
  if (VcsDataKeys.CHANGES.equals(key)) {
    int[] rows=table.getSelectedRows();
    if (rows.length != 1)     return;
    int row=rows[0];
  }
}","@Override public void calcData(DataKey key,DataSink sink){
  sink.put(GerritDataKeys.TOOL_WINDOW,gerritToolWindow);
  if (VcsDataKeys.CHANGES.equals(key)) {
    int[] rows=table.getSelectedRows();
    if (rows.length != 1)     return;
    int row=rows[0];
  }
}",0.8774193548387097
80214,"public SimpleToolWindowPanel createToolWindowContent(final Project project){
  diffManager.registerDiffTool(commentsDiffTool);
  SimpleToolWindowPanel panel=new SimpleToolWindowPanel(true,true);
  ActionToolbar toolbar=createToolbar(project);
  toolbar.setTargetComponent(changeListPanel);
  panel.setToolbar(toolbar.getComponent());
  repositoryChangesBrowser=createRepositoryChangesBrowser(project);
  detailsSplitter=new Splitter(true,0.6f);
  detailsSplitter.setShowDividerControls(true);
  changeListPanel.setBorder(IdeBorderFactory.createBorder(SideBorder.TOP | SideBorder.RIGHT | SideBorder.BOTTOM));
  detailsSplitter.setFirstComponent(changeListPanel);
  detailsPanel=new GerritChangeDetailsPanel(project);
  JPanel details=detailsPanel.getComponent();
  details.setBorder(IdeBorderFactory.createBorder(SideBorder.TOP | SideBorder.RIGHT));
  detailsSplitter.setSecondComponent(details);
  Splitter horizontalSplitter=new Splitter(false,0.7f);
  horizontalSplitter.setShowDividerControls(true);
  horizontalSplitter.setFirstComponent(detailsSplitter);
  horizontalSplitter.setSecondComponent(repositoryChangesBrowser);
  panel.setContent(horizontalSplitter);
  reloadChanges(project,false);
  return panel;
}","public SimpleToolWindowPanel createToolWindowContent(final Project project){
  changeListPanel.registerChangeListPanel(this);
  diffManager.registerDiffTool(commentsDiffTool);
  SimpleToolWindowPanel panel=new SimpleToolWindowPanel(true,true);
  ActionToolbar toolbar=createToolbar(project);
  toolbar.setTargetComponent(changeListPanel);
  panel.setToolbar(toolbar.getComponent());
  repositoryChangesBrowser=createRepositoryChangesBrowser(project);
  detailsSplitter=new Splitter(true,0.6f);
  detailsSplitter.setShowDividerControls(true);
  changeListPanel.setBorder(IdeBorderFactory.createBorder(SideBorder.TOP | SideBorder.RIGHT | SideBorder.BOTTOM));
  detailsSplitter.setFirstComponent(changeListPanel);
  detailsPanel=new GerritChangeDetailsPanel(project);
  JPanel details=detailsPanel.getComponent();
  details.setBorder(IdeBorderFactory.createBorder(SideBorder.TOP | SideBorder.RIGHT));
  detailsSplitter.setSecondComponent(details);
  Splitter horizontalSplitter=new Splitter(false,0.7f);
  horizontalSplitter.setShowDividerControls(true);
  horizontalSplitter.setFirstComponent(detailsSplitter);
  horizontalSplitter.setSecondComponent(repositoryChangesBrowser);
  panel.setContent(horizontalSplitter);
  reloadChanges(project,false);
  return panel;
}",0.9802498992341796
80215,"private ActionToolbar createToolbar(final Project project){
  DefaultActionGroup group=(DefaultActionGroup)ActionManager.getInstance().getAction(""String_Node_Str"");
  DefaultActionGroup filterGroup=new DefaultActionGroup();
  Iterable<ChangesFilter> filters=changesFilters.getFilters();
  for (  ChangesFilter filter : filters) {
    filterGroup.add(filter.getAction(project));
  }
  filterGroup.add(new Separator());
  group.add(filterGroup,Constraints.FIRST);
  changesFilters.addObserver(new Observer(){
    @Override public void update(    Observable observable,    Object o){
      reloadChanges(project,true);
    }
  }
);
  return ActionManager.getInstance().createActionToolbar(""String_Node_Str"",group,true);
}","private ActionToolbar createToolbar(final Project project){
  DefaultActionGroup groupFromConfig=(DefaultActionGroup)ActionManager.getInstance().getAction(""String_Node_Str"");
  DefaultActionGroup group=new DefaultActionGroup(groupFromConfig);
  DefaultActionGroup filterGroup=new DefaultActionGroup();
  Iterable<ChangesFilter> filters=changesFilters.getFilters();
  for (  ChangesFilter filter : filters) {
    filterGroup.add(filter.getAction(project));
  }
  filterGroup.add(new Separator());
  group.add(filterGroup,Constraints.FIRST);
  changesFilters.addObserver(new Observer(){
    @Override public void update(    Observable observable,    Object o){
      reloadChanges(project,true);
    }
  }
);
  return ActionManager.getInstance().createActionToolbar(""String_Node_Str"",group,true);
}",0.9484808454425364
80216,"public Element getState(){
  log.assertTrue(!ProgressManager.getInstance().hasProgressIndicator(),""String_Node_Str"");
  try {
    if (passwordChanged && !masterPasswordRefused) {
      PasswordSafe.getInstance().storePassword(null,GerritSettings.class,GERRIT_SETTINGS_PASSWORD_KEY,getPassword());
    }
  }
 catch (  MasterPasswordUnavailableException e) {
    log.info(""String_Node_Str"" + GERRIT_SETTINGS_PASSWORD_KEY + ""String_Node_Str"",e);
    masterPasswordRefused=true;
  }
catch (  Exception e) {
    Messages.showErrorDialog(""String_Node_Str"",""String_Node_Str"");
    log.info(""String_Node_Str"" + GERRIT_SETTINGS_PASSWORD_KEY + ""String_Node_Str"",e);
  }
  passwordChanged=false;
  final Element element=new Element(GERRIT_SETTINGS_TAG);
  element.setAttribute(LOGIN,getLogin());
  element.setAttribute(HOST,getHost());
  element.setAttribute(AUTOMATIC_REFRESH,""String_Node_Str"" + getAutomaticRefresh());
  element.setAttribute(REFRESH_TIMEOUT,""String_Node_Str"" + getRefreshTimeout());
  element.setAttribute(REVIEW_NOTIFICATIONS,""String_Node_Str"" + getReviewNotifications());
  Element trustedHosts=new Element(TRUSTED_HOSTS);
  for (  String host : myTrustedHosts) {
    Element hostEl=new Element(TRUSTED_HOST);
    hostEl.setAttribute(TRUSTED_URL,host);
    trustedHosts.addContent(hostEl);
  }
  element.addContent(trustedHosts);
  return element;
}","public Element getState(){
  log.assertTrue(!ProgressManager.getInstance().hasProgressIndicator(),""String_Node_Str"");
  try {
    if (passwordChanged && !masterPasswordRefused) {
      PasswordSafe.getInstance().storePassword(null,GerritSettings.class,GERRIT_SETTINGS_PASSWORD_KEY,getPassword());
    }
  }
 catch (  MasterPasswordUnavailableException e) {
    log.info(""String_Node_Str"" + GERRIT_SETTINGS_PASSWORD_KEY + ""String_Node_Str"",e);
    masterPasswordRefused=true;
  }
catch (  Exception e) {
    Messages.showErrorDialog(""String_Node_Str"",""String_Node_Str"");
    log.info(""String_Node_Str"" + GERRIT_SETTINGS_PASSWORD_KEY + ""String_Node_Str"",e);
  }
  passwordChanged=false;
  final Element element=new Element(GERRIT_SETTINGS_TAG);
  element.setAttribute(LOGIN,(getLogin() != null ? getLogin() : ""String_Node_Str""));
  element.setAttribute(HOST,(getHost() != null ? getHost() : ""String_Node_Str""));
  element.setAttribute(AUTOMATIC_REFRESH,""String_Node_Str"" + getAutomaticRefresh());
  element.setAttribute(REFRESH_TIMEOUT,""String_Node_Str"" + getRefreshTimeout());
  element.setAttribute(REVIEW_NOTIFICATIONS,""String_Node_Str"" + getReviewNotifications());
  Element trustedHosts=new Element(TRUSTED_HOSTS);
  for (  String host : myTrustedHosts) {
    Element hostEl=new Element(TRUSTED_HOST);
    hostEl.setAttribute(TRUSTED_URL,host);
    trustedHosts.addContent(hostEl);
  }
  element.addContent(trustedHosts);
  return element;
}",0.9696753478415984
80217,"private static String getProjectName(String url){
  String path=parseUri(url).getPath();
  int index=path.indexOf('/');
  path=path.substring(index + 1);
  path=path.replace(""String_Node_Str"",""String_Node_Str"");
  return path;
}","private static String getProjectName(String repositoryUrl,String url){
  if (!repositoryUrl.endsWith(""String_Node_Str""))   repositoryUrl=repositoryUrl + ""String_Node_Str"";
  String basePath=parseUri(repositoryUrl).getPath();
  String path=parseUri(url).getPath();
  path=path.substring(basePath.length());
  path=path.replace(""String_Node_Str"",""String_Node_Str"");
  if (path.endsWith(""String_Node_Str""))   path=path.substring(0,path.length() - 1);
  return path;
}",0.3815028901734104
80218,"/** 
 * Provide information only for current project
 */
@NotNull public static List<ChangeInfo> getChangesForProject(@NotNull String url,@NotNull String login,@NotNull String password,@NotNull final Project project){
  List<GitRepository> repositories=GitUtil.getRepositoryManager(project).getRepositories();
  if (repositories.isEmpty()) {
    showAddGitRepositoryNotification(project);
    return Lists.newArrayList();
  }
  List<GitRemote> remotes=Lists.newArrayList();
  for (  GitRepository repository : repositories) {
    remotes.addAll(repository.getRemotes());
  }
  String host=parseUri(url).getHost();
  List<String> projectNames=Lists.newArrayList();
  for (  GitRemote remote : remotes) {
    for (    String repositoryUrl : remote.getUrls()) {
      String repositoryHost=parseUri(repositoryUrl).getHost();
      if (repositoryHost != null && repositoryHost.equals(host)) {
        projectNames.add(""String_Node_Str"" + getProjectName(repositoryUrl));
      }
    }
  }
  if (projectNames.isEmpty()) {
    return Collections.emptyList();
  }
  String projectQuery=Joiner.on(""String_Node_Str"").join(projectNames);
  return getChanges(url,login,password,""String_Node_Str"" + projectQuery + ')');
}","/** 
 * Provide information only for current project
 */
@NotNull public static List<ChangeInfo> getChangesForProject(@NotNull String url,@NotNull String login,@NotNull String password,@NotNull final Project project){
  List<GitRepository> repositories=GitUtil.getRepositoryManager(project).getRepositories();
  if (repositories.isEmpty()) {
    showAddGitRepositoryNotification(project);
    return Lists.newArrayList();
  }
  List<GitRemote> remotes=Lists.newArrayList();
  for (  GitRepository repository : repositories) {
    remotes.addAll(repository.getRemotes());
  }
  String host=parseUri(url).getHost();
  List<String> projectNames=Lists.newArrayList();
  for (  GitRemote remote : remotes) {
    for (    String repositoryUrl : remote.getUrls()) {
      String repositoryHost=parseUri(repositoryUrl).getHost();
      if (repositoryHost != null && repositoryHost.equals(host)) {
        projectNames.add(""String_Node_Str"" + getProjectName(url,repositoryUrl));
      }
    }
  }
  if (projectNames.isEmpty()) {
    return Collections.emptyList();
  }
  String projectQuery=Joiner.on(""String_Node_Str"").join(projectNames);
  return getChanges(url,login,password,""String_Node_Str"" + projectQuery + ')');
}",0.9983471074380166
80219,"@Nullable private static JsonElement request(@NotNull String host,@Nullable String login,@Nullable String password,@NotNull String path,@Nullable String requestBody,boolean post){
  HttpMethod method=null;
  try {
    method=doREST(host,login,password,path,requestBody,post);
    String resp=method.getResponseBodyAsString();
    if (method.getStatusCode() != 200) {
      String message=String.format(""String_Node_Str"",method.getStatusCode(),method.getStatusText());
      LOG.warn(message);
      throw new HttpStatusException(method.getStatusCode(),method.getStatusText(),message);
    }
    if (resp == null) {
      String message=String.format(""String_Node_Str"",resp);
      LOG.warn(message);
      throw new RuntimeException(message);
    }
    return parseResponse(resp);
  }
 catch (  IOException e) {
    LOG.warn(String.format(""String_Node_Str"",e.getMessage()),e);
    throw Throwables.propagate(e);
  }
 finally {
    if (method != null) {
      method.releaseConnection();
    }
  }
}","@Nullable private static JsonElement request(@NotNull String host,@Nullable String login,@Nullable String password,@NotNull String path,@Nullable String requestBody,boolean post){
  HttpMethod method=null;
  try {
    method=doREST(host,login,password,path,requestBody,post);
    String resp=method.getResponseBodyAsString();
    if (method.getStatusCode() != 200) {
      String message=String.format(""String_Node_Str"",method.getStatusText(),method.getStatusCode());
      LOG.warn(message);
      throw new HttpStatusException(method.getStatusCode(),method.getStatusText(),message);
    }
    if (resp == null) {
      String message=String.format(""String_Node_Str"",resp);
      LOG.warn(message);
      throw new RuntimeException(message);
    }
    return parseResponse(resp);
  }
 catch (  IOException e) {
    LOG.warn(String.format(""String_Node_Str"",e.getMessage()),e);
    throw Throwables.propagate(e);
  }
 finally {
    if (method != null) {
      method.releaseConnection();
    }
  }
}",0.9769539078156312
80220,"@Nullable private static HttpMethod handleCertificateExceptionAndRetry(@NotNull IOException e,@NotNull String host,@NotNull HttpClient client,@NotNull URI uri,@NotNull ThrowableConvertor<String,HttpMethod,IOException> methodCreator) throws IOException {
  if (!isCertificateException(e)) {
    throw e;
  }
  if (isTrusted(host)) {
    HostConfiguration hc=new HostConfiguration();
    String relativeUri=new URI(uri.getPathQuery(),false).getURI();
    HttpMethod method=methodCreator.convert(relativeUri);
    client.executeMethod(hc,method);
    return method;
  }
  throw e;
}","@Nullable private static HttpMethod handleCertificateExceptionAndRetry(@NotNull IOException e,@NotNull String host,@NotNull HttpClient client,@NotNull URI uri,@NotNull ThrowableConvertor<String,HttpMethod,IOException> methodCreator) throws IOException {
  if (!isCertificateException(e)) {
    throw e;
  }
  if (isTrusted(host)) {
    Protocol easyHttps=new Protocol(""String_Node_Str"",(ProtocolSocketFactory)new EasySSLProtocolSocketFactory(),443);
    HostConfiguration hc=new HostConfiguration();
    hc.setHost(host,443,easyHttps);
    String relativeUri=new URI(uri.getPathQuery(),false).getURI();
    HttpMethod method=methodCreator.convert(relativeUri);
    client.executeMethod(hc,method);
    return method;
  }
  throw e;
}",0.8826219512195121
80221,"private static void saveToTrusted(@NotNull String host){
  GerritSettings.getInstance().addTrustedHost(host);
}","private static void saveToTrusted(@NotNull String host){
  try {
    GerritSettings.getInstance().addTrustedHost(new java.net.URI(host).getHost());
  }
 catch (  URISyntaxException e) {
    throw Throwables.propagate(e);
  }
}",0.6350148367952523
80222,"@Nullable private static JsonElement request(@NotNull String host,@Nullable String login,@Nullable String password,@NotNull String path,@Nullable String requestBody,boolean post){
  HttpMethod method=null;
  try {
    method=doREST(host,login,password,path,requestBody,post);
    String resp=method.getResponseBodyAsString();
    if (method.getStatusCode() != 200) {
      String message=String.format(""String_Node_Str"",method.getStatusCode(),method.getStatusText());
      LOG.warn(message);
      throw new RuntimeException(message);
    }
    if (resp == null) {
      String message=String.format(""String_Node_Str"",resp);
      LOG.warn(message);
      throw new RuntimeException(message);
    }
    return parseResponse(resp);
  }
 catch (  IOException e) {
    LOG.warn(String.format(""String_Node_Str"",e.getMessage()),e);
    throw Throwables.propagate(e);
  }
 finally {
    if (method != null) {
      method.releaseConnection();
    }
  }
}","@Nullable private static JsonElement request(@NotNull String host,@Nullable String login,@Nullable String password,@NotNull String path,@Nullable String requestBody,boolean post){
  HttpMethod method=null;
  try {
    method=doREST(host,login,password,path,requestBody,post);
    String resp=method.getResponseBodyAsString();
    if (method.getStatusCode() != 200) {
      String message=String.format(""String_Node_Str"",method.getStatusCode(),method.getStatusText());
      LOG.warn(message);
      throw new HttpStatusException(method.getStatusCode(),method.getStatusText(),message);
    }
    if (resp == null) {
      String message=String.format(""String_Node_Str"",resp);
      LOG.warn(message);
      throw new RuntimeException(message);
    }
    return parseResponse(resp);
  }
 catch (  IOException e) {
    LOG.warn(String.format(""String_Node_Str"",e.getMessage()),e);
    throw Throwables.propagate(e);
  }
 finally {
    if (method != null) {
      method.releaseConnection();
    }
  }
}",0.9676425269645608
80223,"@NotNull private static JsonElement parseResponse(@NotNull String response){
  try {
    return new JsonParser().parse(response);
  }
 catch (  JsonSyntaxException jse) {
    if (response.startsWith(""String_Node_Str"")) {
      throw new NotFoundException();
    }
    throw new RuntimeException(String.format(""String_Node_Str"",response),jse);
  }
}","@NotNull private static JsonElement parseResponse(@NotNull String response){
  try {
    return new JsonParser().parse(response);
  }
 catch (  JsonSyntaxException jse) {
    throw new RuntimeException(String.format(""String_Node_Str"",response),jse);
  }
}",0.845771144278607
80224,"/** 
 * Support starting from Gerrit 2.7.
 */
@NotNull public static TreeMap<String,List<CommentInfo>> getComments(@NotNull String url,@NotNull String login,@NotNull String password,@NotNull String changeId,@NotNull String revision){
  final String request=""String_Node_Str"" + changeId + ""String_Node_Str""+ revision+ ""String_Node_Str"";
  try {
    JsonElement result=GerritApiUtil.getRequest(url,login,password,request);
    if (result == null) {
      return Maps.newTreeMap();
    }
    return parseCommentInfos(result);
  }
 catch (  NotFoundException e) {
    LOG.warn(""String_Node_Str"");
    return Maps.newTreeMap();
  }
}","/** 
 * Support starting from Gerrit 2.7.
 */
@NotNull public static TreeMap<String,List<CommentInfo>> getComments(@NotNull String url,@NotNull String login,@NotNull String password,@NotNull String changeId,@NotNull String revision){
  final String request=""String_Node_Str"" + changeId + ""String_Node_Str""+ revision+ ""String_Node_Str"";
  try {
    JsonElement result=GerritApiUtil.getRequest(url,login,password,request);
    if (result == null) {
      return Maps.newTreeMap();
    }
    return parseCommentInfos(result);
  }
 catch (  HttpStatusException e) {
    if (e.getStatusCode() == 404) {
      LOG.warn(""String_Node_Str"");
    }
    return Maps.newTreeMap();
  }
}",0.9523809523809524
80225,"/** 
 * Attempts to create a player account for the given player on the specified world IMPLEMENTATION SPECIFIC - if an economy plugin does not support this the global balance will be returned.
 * @return if the account creation was successful
 */
public boolean createPlayerAccount(OfflinePlayer player,String worldName);","/** 
 * Attempts to create a player account for the given player on the specified world IMPLEMENTATION SPECIFIC - if an economy plugin does not support this the global balance will be returned.
 * @param player OfflinePlayer
 * @param worldName String name of the world
 * @return if the account creation was successful
 */
public boolean createPlayerAccount(OfflinePlayer player,String worldName);",0.8944444444444445
80226,"/** 
 * Store container diagnostics if container info is available. If diagnostics information for this container already existed, it will be overwritten.
 * @param containerId id of the container
 * @param exitCode exit code reason (of type {@link ContainerExitStatus})
 * @param diagnostics any textual message
 * @param state final state of container (of type {@link StateValues})
 * @param logLink jobhistory link for a finished container or nodemanager linkfor a running one
 * @param completionTime the end time of a container (if it has completed, 0otherwise)
 */
public void storeContainerDiagnostics(String containerId,int exitCode,String diagnostics,int state,String logLink,long completionTime){
  ContainerInformation containerInfo=getApplicationDiagnostics().getContainer(containerId);
  if (containerInfo != null) {
    containerInfo.exitCode=exitCode;
    if (StringUtils.isNotBlank(diagnostics)) {
      containerInfo.diagnostics=diagnostics;
    }
 else {
      containerInfo.diagnostics=ErrorStrings.E_MISSING_DIAGNOSTICS_FROM_YARN;
    }
    containerInfo.state=state;
    if (logLink != null) {
      containerInfo.logLink=logLink;
    }
    containerInfo.completionTime=completionTime;
  }
}","/** 
 * Store container diagnostics if container info is available. If diagnostics information for this container already existed, it will be overwritten.
 * @param containerId id of the container
 * @param exitCode exit code reason (of type {@link ContainerExitStatus})
 * @param diagnostics any textual message
 * @param state final state of container (of type {@link StateValues})
 * @param logLink jobhistory link for a finished container or nodemanager linkfor a running one
 * @param completionTime the end time of a container (if it has completed, 0otherwise)
 */
public void storeContainerDiagnostics(String containerId,int exitCode,String diagnostics,int state,String logLink,long completionTime){
  ContainerInformation containerInfo=getApplicationDiagnostics().getContainer(containerId);
  if (containerInfo != null) {
    containerInfo.exitCode=exitCode;
    if (StringUtils.isNotBlank(diagnostics)) {
      containerInfo.diagnostics=diagnostics;
    }
    containerInfo.state=state;
    if (logLink != null) {
      containerInfo.logLink=logLink;
    }
    containerInfo.completionTime=completionTime;
  }
}",0.9605488850771868
80227,"@VisibleForTesting protected Metainfo getMetaInfo(String roleGroup){
  ConfTreeOperations appConf=getAmState().getAppConfSnapshot();
  String mapKey=appConf.getComponentOpt(roleGroup,ROLE_PREFIX,DEFAULT_METAINFO_MAP_KEY);
  MetainfoHolder mh=this.metaInfoMap.get(mapKey);
  if (mh == null) {
    return null;
  }
  return mh.metaInfo;
}","@VisibleForTesting protected Metainfo getMetaInfo(String roleGroup){
  String mapKey=DEFAULT_METAINFO_MAP_KEY;
  if (roleGroup != null) {
    ConfTreeOperations appConf=getAmState().getAppConfSnapshot();
    mapKey=appConf.getComponentOpt(roleGroup,ROLE_PREFIX,DEFAULT_METAINFO_MAP_KEY);
  }
  MetainfoHolder mh=this.metaInfoMap.get(mapKey);
  if (mh == null) {
    return null;
  }
  return mh.metaInfo;
}",0.889487870619946
80228,"@Override public void buildContainerLaunchContext(ContainerLauncher launcher,AggregateConf instanceDefinition,Container container,ProviderRole providerRole,SliderFileSystem fileSystem,Path generatedConfPath,MapOperations resourceComponent,MapOperations appComponent,Path containerTmpDirPath) throws IOException, SliderException {
  String roleName=providerRole.name;
  String roleGroup=providerRole.group;
  String appDef=SliderUtils.getApplicationDefinitionPath(instanceDefinition.getAppConfOperations(),roleGroup);
  initializeApplicationConfiguration(instanceDefinition,fileSystem,roleGroup);
  log.info(""String_Node_Str"");
  log.debug(instanceDefinition.toString());
  if (isYarnDockerContainer(roleGroup)) {
    launcher.setYarnDockerMode(true);
    launcher.setDockerImage(getConfigFromMetaInfo(roleGroup,""String_Node_Str""));
    launcher.setRunPrivilegedContainer(getConfigFromMetaInfo(roleGroup,""String_Node_Str""));
    launcher.setYarnContainerMountPoints(getConfigFromMetaInfoWithAppConfigOverriding(roleGroup,""String_Node_Str""));
  }
  launcher.putEnv(SliderUtils.buildEnvMap(appComponent,getStandardTokenMap(getAmState().getAppConfSnapshot(),roleName,roleGroup)));
  String workDir=ApplicationConstants.Environment.PWD.$();
  launcher.setEnv(""String_Node_Str"",workDir);
  log.info(""String_Node_Str"",workDir);
  String logDir=ApplicationConstants.LOG_DIR_EXPANSION_VAR;
  launcher.setEnv(""String_Node_Str"",logDir);
  log.info(""String_Node_Str"",logDir);
  if (System.getenv(HADOOP_USER_NAME) != null) {
    launcher.setEnv(HADOOP_USER_NAME,System.getenv(HADOOP_USER_NAME));
  }
  launcher.setEnv(SLIDER_PASSPHRASE,instanceDefinition.getPassphrase());
  launcher.setEnv(""String_Node_Str"",""String_Node_Str"");
  launcher.setEnv(""String_Node_Str"",""String_Node_Str"");
  launcher.setEnv(""String_Node_Str"",""String_Node_Str"");
  String scriptPath=new File(AgentKeys.AGENT_MAIN_SCRIPT_ROOT,AgentKeys.AGENT_MAIN_SCRIPT).getPath();
  String appHome=instanceDefinition.getAppConfOperations().getGlobalOptions().get(AgentKeys.PACKAGE_PATH);
  if (SliderUtils.isSet(appHome)) {
    scriptPath=new File(appHome,AgentKeys.AGENT_MAIN_SCRIPT).getPath();
  }
  List<String> pythonPaths=new ArrayList<String>();
  pythonPaths.add(AgentKeys.AGENT_MAIN_SCRIPT_ROOT);
  pythonPaths.add(AgentKeys.AGENT_JINJA2_ROOT);
  String pythonPath=StringUtils.join(File.pathSeparator,pythonPaths);
  launcher.setEnv(PYTHONPATH,pythonPath);
  log.info(""String_Node_Str"",pythonPath);
  Path agentImagePath=null;
  String agentImage=instanceDefinition.getInternalOperations().get(InternalKeys.INTERNAL_APPLICATION_IMAGE_PATH);
  if (SliderUtils.isUnset(agentImage)) {
    agentImagePath=new Path(new Path(new Path(instanceDefinition.getInternalOperations().get(InternalKeys.INTERNAL_TMP_DIR),container.getId().getApplicationAttemptId().getApplicationId().toString()),AgentKeys.PROVIDER_AGENT),SliderKeys.AGENT_TAR);
  }
 else {
    agentImagePath=new Path(agentImage);
  }
  if (fileSystem.getFileSystem().exists(agentImagePath)) {
    LocalResource agentImageRes=fileSystem.createAmResource(agentImagePath,LocalResourceType.ARCHIVE);
    launcher.addLocalResource(AgentKeys.AGENT_INSTALL_DIR,agentImageRes);
  }
 else {
    String msg=String.format(""String_Node_Str"",agentImagePath.toString());
    MapOperations compOps=appComponent;
    boolean relaxVerificationForTest=compOps != null ? Boolean.valueOf(compOps.getOptionBool(AgentKeys.TEST_RELAX_VERIFICATION,false)) : false;
    log.error(msg);
    if (!relaxVerificationForTest) {
      throw new SliderException(SliderExitCodes.EXIT_DEPLOYMENT_FAILED,msg);
    }
  }
  log.info(""String_Node_Str"",scriptPath);
  LocalResource appDefRes=fileSystem.createAmResource(fileSystem.getFileSystem().resolvePath(new Path(appDef)),LocalResourceType.ARCHIVE);
  launcher.addLocalResource(AgentKeys.APP_DEFINITION_DIR,appDefRes);
  for (  Package pkg : getMetaInfo().getApplication().getPackages()) {
    Path pkgPath=fileSystem.buildResourcePath(pkg.getName());
    if (!fileSystem.isFile(pkgPath)) {
      pkgPath=fileSystem.buildResourcePath(getClusterName(),pkg.getName());
    }
    if (!fileSystem.isFile(pkgPath)) {
      throw new IOException(""String_Node_Str"" + pkg.getName());
    }
    log.info(""String_Node_Str"",pkg.getName());
    LocalResourceType type=LocalResourceType.FILE;
    if (""String_Node_Str"".equals(pkg.getType())) {
      type=LocalResourceType.ARCHIVE;
    }
    LocalResource packageResource=fileSystem.createAmResource(pkgPath,type);
    launcher.addLocalResource(AgentKeys.APP_PACKAGES_DIR,packageResource);
  }
  String agentConf=instanceDefinition.getAppConfOperations().getGlobalOptions().getOption(AgentKeys.AGENT_CONF,""String_Node_Str"");
  if (SliderUtils.isSet(agentConf)) {
    LocalResource agentConfRes=fileSystem.createAmResource(fileSystem.getFileSystem().resolvePath(new Path(agentConf)),LocalResourceType.FILE);
    launcher.addLocalResource(AgentKeys.AGENT_CONFIG_FILE,agentConfRes);
  }
  String agentVer=instanceDefinition.getAppConfOperations().getGlobalOptions().getOption(AgentKeys.AGENT_VERSION,null);
  if (agentVer != null) {
    LocalResource agentVerRes=fileSystem.createAmResource(fileSystem.getFileSystem().resolvePath(new Path(agentVer)),LocalResourceType.FILE);
    launcher.addLocalResource(AgentKeys.AGENT_VERSION_FILE,agentVerRes);
  }
  if (SliderUtils.isHadoopClusterSecure(getConfig())) {
    localizeServiceKeytabs(launcher,instanceDefinition,fileSystem);
  }
  MapOperations amComponent=instanceDefinition.getAppConfOperations().getComponent(SliderKeys.COMPONENT_AM);
  boolean twoWayEnabled=amComponent != null ? Boolean.valueOf(amComponent.getOptionBool(AgentKeys.KEY_AGENT_TWO_WAY_SSL_ENABLED,false)) : false;
  if (twoWayEnabled) {
    localizeContainerSSLResources(launcher,container,fileSystem);
  }
  MapOperations compOps=appComponent;
  if (areStoresRequested(compOps)) {
    localizeContainerSecurityStores(launcher,container,roleName,fileSystem,instanceDefinition,compOps);
  }
  launcher.addLocalResources(fileSystem.submitDirectory(generatedConfPath,SliderKeys.PROPAGATED_CONF_DIR_NAME));
  if (appComponent.getOptionBool(AgentKeys.AM_CONFIG_GENERATION,false)) {
    Map<String,Map<String,String>> configurations=buildCommandConfigurations(instanceDefinition.getAppConfOperations(),container.getId().toString(),roleName,roleGroup);
    localizeConfigFiles(launcher,roleName,roleGroup,getMetaInfo(),configurations,launcher.getEnv(),fileSystem);
  }
  String label=getContainerLabel(container,roleName,roleGroup);
  CommandLineBuilder operation=new CommandLineBuilder();
  String pythonExec=instanceDefinition.getAppConfOperations().getGlobalOptions().getOption(SliderXmlConfKeys.PYTHON_EXECUTABLE_PATH,AgentKeys.PYTHON_EXE);
  operation.add(pythonExec);
  operation.add(scriptPath);
  operation.add(ARG_LABEL,label);
  operation.add(ARG_ZOOKEEPER_QUORUM);
  operation.add(getClusterOptionPropertyValue(OptionKeys.ZOOKEEPER_QUORUM));
  operation.add(ARG_ZOOKEEPER_REGISTRY_PATH);
  operation.add(getZkRegistryPath());
  String debugCmd=agentLaunchParameter.getNextLaunchParameter(roleGroup);
  if (SliderUtils.isSet(debugCmd)) {
    operation.add(ARG_DEBUG);
    operation.add(debugCmd);
  }
  operation.add(""String_Node_Str"" + ApplicationConstants.LOG_DIR_EXPANSION_VAR + ""String_Node_Str""+ AgentKeys.AGENT_OUT_FILE+ ""String_Node_Str"");
  launcher.addCommand(operation.build());
  String addonAppDefString=instanceDefinition.getAppConfOperations().getGlobalOptions().getOption(AgentKeys.ADDONS,null);
  log.debug(""String_Node_Str"",addonAppDefString);
  if (addonAppDefString != null) {
    Scanner scanner=new Scanner(addonAppDefString).useDelimiter(""String_Node_Str"");
    while (scanner.hasNext()) {
      String addonAppDef=scanner.next();
      String addonAppDefPath=instanceDefinition.getAppConfOperations().getGlobalOptions().get(addonAppDef);
      log.debug(""String_Node_Str"",addonAppDef,addonAppDefPath);
      LocalResource addonPkgRes=fileSystem.createAmResource(fileSystem.getFileSystem().resolvePath(new Path(addonAppDefPath)),LocalResourceType.ARCHIVE);
      launcher.addLocalResource(AgentKeys.ADDON_DEFINITION_DIR + ""String_Node_Str"" + addonAppDef,addonPkgRes);
    }
    log.debug(""String_Node_Str"",packageMetainfo.toString());
  }
  String appResourcesString=instanceDefinition.getAppConfOperations().getGlobalOptions().getOption(AgentKeys.APP_RESOURCES,null);
  log.info(""String_Node_Str"",appResourcesString);
  if (null != appResourcesString) {
    try (Scanner scanner=new Scanner(appResourcesString).useDelimiter(""String_Node_Str"")){
      while (scanner.hasNext()) {
        String resource=scanner.next();
        Path resourcePath=new Path(resource);
        LocalResource extraResource=fileSystem.createAmResource(fileSystem.getFileSystem().resolvePath(resourcePath),LocalResourceType.FILE);
        String destination=AgentKeys.APP_RESOURCES_DIR + ""String_Node_Str"" + resourcePath.getName();
        log.info(""String_Node_Str"",resourcePath,destination);
        launcher.addLocalResource(destination,extraResource);
      }
    }
   }
  Map<String,State> pkgStatuses=new TreeMap<>();
  for (  Metainfo appPkg : packageMetainfo.values()) {
    for (    ComponentsInAddonPackage comp : appPkg.getApplicationPackage().getComponents()) {
      log.debug(""String_Node_Str"",roleName,comp.getName());
      if (comp.getName().equals(roleGroup) || comp.getName().equals(AgentKeys.ADDON_FOR_ALL_COMPONENTS)) {
        pkgStatuses.put(appPkg.getApplicationPackage().getName(),State.INIT);
      }
    }
  }
  log.debug(""String_Node_Str"",roleName,pkgStatuses.toString());
  getComponentStatuses().put(label,new ComponentInstanceState(roleGroup,container.getId(),getClusterInfoPropertyValue(OptionKeys.APPLICATION_NAME),pkgStatuses));
}","@Override public void buildContainerLaunchContext(ContainerLauncher launcher,AggregateConf instanceDefinition,Container container,ProviderRole providerRole,SliderFileSystem fileSystem,Path generatedConfPath,MapOperations resourceComponent,MapOperations appComponent,Path containerTmpDirPath) throws IOException, SliderException {
  String roleName=providerRole.name;
  String roleGroup=providerRole.group;
  String appDef=SliderUtils.getApplicationDefinitionPath(instanceDefinition.getAppConfOperations(),roleGroup);
  initializeApplicationConfiguration(instanceDefinition,fileSystem,roleGroup);
  log.info(""String_Node_Str"");
  log.debug(instanceDefinition.toString());
  if (isYarnDockerContainer(roleGroup)) {
    launcher.setYarnDockerMode(true);
    launcher.setDockerImage(getConfigFromMetaInfo(roleGroup,""String_Node_Str""));
    launcher.setRunPrivilegedContainer(getConfigFromMetaInfo(roleGroup,""String_Node_Str""));
    launcher.setYarnContainerMountPoints(getConfigFromMetaInfoWithAppConfigOverriding(roleGroup,""String_Node_Str""));
  }
  launcher.putEnv(SliderUtils.buildEnvMap(appComponent,getStandardTokenMap(getAmState().getAppConfSnapshot(),roleName,roleGroup)));
  String workDir=ApplicationConstants.Environment.PWD.$();
  launcher.setEnv(""String_Node_Str"",workDir);
  log.info(""String_Node_Str"",workDir);
  String logDir=ApplicationConstants.LOG_DIR_EXPANSION_VAR;
  launcher.setEnv(""String_Node_Str"",logDir);
  log.info(""String_Node_Str"",logDir);
  if (System.getenv(HADOOP_USER_NAME) != null) {
    launcher.setEnv(HADOOP_USER_NAME,System.getenv(HADOOP_USER_NAME));
  }
  launcher.setEnv(SLIDER_PASSPHRASE,instanceDefinition.getPassphrase());
  launcher.setEnv(""String_Node_Str"",""String_Node_Str"");
  launcher.setEnv(""String_Node_Str"",""String_Node_Str"");
  launcher.setEnv(""String_Node_Str"",""String_Node_Str"");
  String scriptPath=new File(AgentKeys.AGENT_MAIN_SCRIPT_ROOT,AgentKeys.AGENT_MAIN_SCRIPT).getPath();
  String appHome=instanceDefinition.getAppConfOperations().getGlobalOptions().get(AgentKeys.PACKAGE_PATH);
  if (SliderUtils.isSet(appHome)) {
    scriptPath=new File(appHome,AgentKeys.AGENT_MAIN_SCRIPT).getPath();
  }
  List<String> pythonPaths=new ArrayList<String>();
  pythonPaths.add(AgentKeys.AGENT_MAIN_SCRIPT_ROOT);
  pythonPaths.add(AgentKeys.AGENT_JINJA2_ROOT);
  String pythonPath=StringUtils.join(File.pathSeparator,pythonPaths);
  launcher.setEnv(PYTHONPATH,pythonPath);
  log.info(""String_Node_Str"",pythonPath);
  Path agentImagePath=null;
  String agentImage=instanceDefinition.getInternalOperations().get(InternalKeys.INTERNAL_APPLICATION_IMAGE_PATH);
  if (SliderUtils.isUnset(agentImage)) {
    agentImagePath=new Path(new Path(new Path(instanceDefinition.getInternalOperations().get(InternalKeys.INTERNAL_TMP_DIR),container.getId().getApplicationAttemptId().getApplicationId().toString()),AgentKeys.PROVIDER_AGENT),SliderKeys.AGENT_TAR);
  }
 else {
    agentImagePath=new Path(agentImage);
  }
  if (fileSystem.getFileSystem().exists(agentImagePath)) {
    LocalResource agentImageRes=fileSystem.createAmResource(agentImagePath,LocalResourceType.ARCHIVE);
    launcher.addLocalResource(AgentKeys.AGENT_INSTALL_DIR,agentImageRes);
  }
 else {
    String msg=String.format(""String_Node_Str"",agentImagePath.toString());
    MapOperations compOps=appComponent;
    boolean relaxVerificationForTest=compOps != null ? Boolean.valueOf(compOps.getOptionBool(AgentKeys.TEST_RELAX_VERIFICATION,false)) : false;
    log.error(msg);
    if (!relaxVerificationForTest) {
      throw new SliderException(SliderExitCodes.EXIT_DEPLOYMENT_FAILED,msg);
    }
  }
  log.info(""String_Node_Str"",scriptPath);
  LocalResource appDefRes=fileSystem.createAmResource(fileSystem.getFileSystem().resolvePath(new Path(appDef)),LocalResourceType.ARCHIVE);
  launcher.addLocalResource(AgentKeys.APP_DEFINITION_DIR,appDefRes);
  for (  Package pkg : getMetaInfo(roleGroup).getApplication().getPackages()) {
    Path pkgPath=fileSystem.buildResourcePath(pkg.getName());
    if (!fileSystem.isFile(pkgPath)) {
      pkgPath=fileSystem.buildResourcePath(getClusterName(),pkg.getName());
    }
    if (!fileSystem.isFile(pkgPath)) {
      throw new IOException(""String_Node_Str"" + pkg.getName());
    }
    log.info(""String_Node_Str"",pkg.getName());
    LocalResourceType type=LocalResourceType.FILE;
    if (""String_Node_Str"".equals(pkg.getType())) {
      type=LocalResourceType.ARCHIVE;
    }
    LocalResource packageResource=fileSystem.createAmResource(pkgPath,type);
    launcher.addLocalResource(AgentKeys.APP_PACKAGES_DIR,packageResource);
  }
  String agentConf=instanceDefinition.getAppConfOperations().getGlobalOptions().getOption(AgentKeys.AGENT_CONF,""String_Node_Str"");
  if (SliderUtils.isSet(agentConf)) {
    LocalResource agentConfRes=fileSystem.createAmResource(fileSystem.getFileSystem().resolvePath(new Path(agentConf)),LocalResourceType.FILE);
    launcher.addLocalResource(AgentKeys.AGENT_CONFIG_FILE,agentConfRes);
  }
  String agentVer=instanceDefinition.getAppConfOperations().getGlobalOptions().getOption(AgentKeys.AGENT_VERSION,null);
  if (agentVer != null) {
    LocalResource agentVerRes=fileSystem.createAmResource(fileSystem.getFileSystem().resolvePath(new Path(agentVer)),LocalResourceType.FILE);
    launcher.addLocalResource(AgentKeys.AGENT_VERSION_FILE,agentVerRes);
  }
  if (SliderUtils.isHadoopClusterSecure(getConfig())) {
    localizeServiceKeytabs(launcher,instanceDefinition,fileSystem);
  }
  MapOperations amComponent=instanceDefinition.getAppConfOperations().getComponent(SliderKeys.COMPONENT_AM);
  boolean twoWayEnabled=amComponent != null ? Boolean.valueOf(amComponent.getOptionBool(AgentKeys.KEY_AGENT_TWO_WAY_SSL_ENABLED,false)) : false;
  if (twoWayEnabled) {
    localizeContainerSSLResources(launcher,container,fileSystem);
  }
  MapOperations compOps=appComponent;
  if (areStoresRequested(compOps)) {
    localizeContainerSecurityStores(launcher,container,roleName,fileSystem,instanceDefinition,compOps);
  }
  launcher.addLocalResources(fileSystem.submitDirectory(generatedConfPath,SliderKeys.PROPAGATED_CONF_DIR_NAME));
  if (appComponent.getOptionBool(AgentKeys.AM_CONFIG_GENERATION,false)) {
    Map<String,Map<String,String>> configurations=buildCommandConfigurations(instanceDefinition.getAppConfOperations(),container.getId().toString(),roleName,roleGroup);
    localizeConfigFiles(launcher,roleName,roleGroup,getMetaInfo(roleGroup),configurations,launcher.getEnv(),fileSystem);
  }
  String label=getContainerLabel(container,roleName,roleGroup);
  CommandLineBuilder operation=new CommandLineBuilder();
  String pythonExec=instanceDefinition.getAppConfOperations().getGlobalOptions().getOption(SliderXmlConfKeys.PYTHON_EXECUTABLE_PATH,AgentKeys.PYTHON_EXE);
  operation.add(pythonExec);
  operation.add(scriptPath);
  operation.add(ARG_LABEL,label);
  operation.add(ARG_ZOOKEEPER_QUORUM);
  operation.add(getClusterOptionPropertyValue(OptionKeys.ZOOKEEPER_QUORUM));
  operation.add(ARG_ZOOKEEPER_REGISTRY_PATH);
  operation.add(getZkRegistryPath());
  String debugCmd=agentLaunchParameter.getNextLaunchParameter(roleGroup);
  if (SliderUtils.isSet(debugCmd)) {
    operation.add(ARG_DEBUG);
    operation.add(debugCmd);
  }
  operation.add(""String_Node_Str"" + ApplicationConstants.LOG_DIR_EXPANSION_VAR + ""String_Node_Str""+ AgentKeys.AGENT_OUT_FILE+ ""String_Node_Str"");
  launcher.addCommand(operation.build());
  String addonAppDefString=instanceDefinition.getAppConfOperations().getGlobalOptions().getOption(AgentKeys.ADDONS,null);
  log.debug(""String_Node_Str"",addonAppDefString);
  if (addonAppDefString != null) {
    Scanner scanner=new Scanner(addonAppDefString).useDelimiter(""String_Node_Str"");
    while (scanner.hasNext()) {
      String addonAppDef=scanner.next();
      String addonAppDefPath=instanceDefinition.getAppConfOperations().getGlobalOptions().get(addonAppDef);
      log.debug(""String_Node_Str"",addonAppDef,addonAppDefPath);
      LocalResource addonPkgRes=fileSystem.createAmResource(fileSystem.getFileSystem().resolvePath(new Path(addonAppDefPath)),LocalResourceType.ARCHIVE);
      launcher.addLocalResource(AgentKeys.ADDON_DEFINITION_DIR + ""String_Node_Str"" + addonAppDef,addonPkgRes);
    }
    log.debug(""String_Node_Str"",packageMetainfo.toString());
  }
  String appResourcesString=instanceDefinition.getAppConfOperations().getGlobalOptions().getOption(AgentKeys.APP_RESOURCES,null);
  log.info(""String_Node_Str"",appResourcesString);
  if (null != appResourcesString) {
    try (Scanner scanner=new Scanner(appResourcesString).useDelimiter(""String_Node_Str"")){
      while (scanner.hasNext()) {
        String resource=scanner.next();
        Path resourcePath=new Path(resource);
        LocalResource extraResource=fileSystem.createAmResource(fileSystem.getFileSystem().resolvePath(resourcePath),LocalResourceType.FILE);
        String destination=AgentKeys.APP_RESOURCES_DIR + ""String_Node_Str"" + resourcePath.getName();
        log.info(""String_Node_Str"",resourcePath,destination);
        launcher.addLocalResource(destination,extraResource);
      }
    }
   }
  Map<String,State> pkgStatuses=new TreeMap<>();
  for (  Metainfo appPkg : packageMetainfo.values()) {
    for (    ComponentsInAddonPackage comp : appPkg.getApplicationPackage().getComponents()) {
      log.debug(""String_Node_Str"",roleName,comp.getName());
      if (comp.getName().equals(roleGroup) || comp.getName().equals(AgentKeys.ADDON_FOR_ALL_COMPONENTS)) {
        pkgStatuses.put(appPkg.getApplicationPackage().getName(),State.INIT);
      }
    }
  }
  log.debug(""String_Node_Str"",roleName,pkgStatuses.toString());
  getComponentStatuses().put(label,new ComponentInstanceState(roleGroup,container.getId(),getClusterInfoPropertyValue(OptionKeys.APPLICATION_NAME),pkgStatuses));
}",0.9990774907749076
80229,"@Override public void applyInitialRegistryDefinitions(URL amWebURI,URL agentOpsURI,URL agentStatusURI,ServiceRecord serviceRecord) throws IOException {
  super.applyInitialRegistryDefinitions(amWebURI,agentOpsURI,agentStatusURI,serviceRecord);
  try {
    URL restURL=new URL(agentOpsURI,SLIDER_PATH_AGENTS);
    URL agentStatusURL=new URL(agentStatusURI,SLIDER_PATH_AGENTS);
    serviceRecord.addInternalEndpoint(new Endpoint(CustomRegistryConstants.AGENT_SECURE_REST_API,ProtocolTypes.PROTOCOL_REST,restURL.toURI()));
    serviceRecord.addInternalEndpoint(new Endpoint(CustomRegistryConstants.AGENT_ONEWAY_REST_API,ProtocolTypes.PROTOCOL_REST,agentStatusURL.toURI()));
  }
 catch (  URISyntaxException e) {
    throw new IOException(e);
  }
  Component client=null;
  for (  Component component : getMetaInfo().getApplication().getComponents()) {
    if (component.getCategory().equals(""String_Node_Str"")) {
      client=component;
      break;
    }
  }
  if (client == null) {
    log.info(""String_Node_Str"");
    return;
  }
  ConfTreeOperations appConf=getAmState().getAppConfSnapshot();
  MapOperations clientOperations=appConf.getOrAddComponent(client.getName());
  appConf.resolve();
  if (!clientOperations.getOptionBool(AgentKeys.AM_CONFIG_GENERATION,false)) {
    log.info(""String_Node_Str"");
    return;
  }
  Map<String,Map<String,String>> configurations=new TreeMap<String,Map<String,String>>();
  Map<String,String> tokens=null;
  try {
    tokens=getStandardTokenMap(appConf,client.getName(),client.getName());
  }
 catch (  SliderException e) {
    throw new IOException(e);
  }
  for (  ConfigFile configFile : getMetaInfo().getComponentConfigFiles(client.getName())) {
    addNamedConfiguration(configFile.getDictionaryName(),appConf.getGlobalOptions().options,configurations,tokens,null,client.getName());
    if (appConf.getComponent(client.getName()) != null) {
      addNamedConfiguration(configFile.getDictionaryName(),appConf.getComponent(client.getName()).options,configurations,tokens,null,client.getName());
    }
  }
  dereferenceAllConfigs(configurations);
  for (  ConfigFile configFile : getMetaInfo().getComponentConfigFiles(client.getName())) {
    ConfigFormat configFormat=ConfigFormat.resolve(configFile.getType());
    Map<String,String> config=configurations.get(configFile.getDictionaryName());
    ConfigUtils.prepConfigForTemplateOutputter(configFormat,config,fileSystem,getClusterName(),new File(configFile.getFileName()).getName());
    PublishedConfiguration publishedConfiguration=new PublishedConfiguration(configFile.getDictionaryName(),config.entrySet());
    getAmState().getPublishedSliderConfigurations().put(configFile.getDictionaryName(),publishedConfiguration);
    log.info(""String_Node_Str"",configFile.getDictionaryName());
  }
}","@Override public void applyInitialRegistryDefinitions(URL amWebURI,URL agentOpsURI,URL agentStatusURI,ServiceRecord serviceRecord) throws IOException {
  super.applyInitialRegistryDefinitions(amWebURI,agentOpsURI,agentStatusURI,serviceRecord);
  try {
    URL restURL=new URL(agentOpsURI,SLIDER_PATH_AGENTS);
    URL agentStatusURL=new URL(agentStatusURI,SLIDER_PATH_AGENTS);
    serviceRecord.addInternalEndpoint(new Endpoint(CustomRegistryConstants.AGENT_SECURE_REST_API,ProtocolTypes.PROTOCOL_REST,restURL.toURI()));
    serviceRecord.addInternalEndpoint(new Endpoint(CustomRegistryConstants.AGENT_ONEWAY_REST_API,ProtocolTypes.PROTOCOL_REST,agentStatusURL.toURI()));
  }
 catch (  URISyntaxException e) {
    throw new IOException(e);
  }
  Component client=null;
  for (  Component component : getMetaInfo(null).getApplication().getComponents()) {
    if (component.getCategory().equals(""String_Node_Str"")) {
      client=component;
      break;
    }
  }
  if (client == null) {
    log.info(""String_Node_Str"");
    return;
  }
  ConfTreeOperations appConf=getAmState().getAppConfSnapshot();
  MapOperations clientOperations=appConf.getOrAddComponent(client.getName());
  appConf.resolve();
  if (!clientOperations.getOptionBool(AgentKeys.AM_CONFIG_GENERATION,false)) {
    log.info(""String_Node_Str"");
    return;
  }
  Map<String,Map<String,String>> configurations=new TreeMap<String,Map<String,String>>();
  Map<String,String> tokens=null;
  try {
    tokens=getStandardTokenMap(appConf,client.getName(),client.getName());
  }
 catch (  SliderException e) {
    throw new IOException(e);
  }
  for (  ConfigFile configFile : getMetaInfo(null).getComponentConfigFiles(client.getName())) {
    addNamedConfiguration(configFile.getDictionaryName(),appConf.getGlobalOptions().options,configurations,tokens,null,client.getName(),client.getName());
    if (appConf.getComponent(client.getName()) != null) {
      addNamedConfiguration(configFile.getDictionaryName(),appConf.getComponent(client.getName()).options,configurations,tokens,null,client.getName(),client.getName());
    }
  }
  dereferenceAllConfigs(configurations);
  for (  ConfigFile configFile : getMetaInfo(null).getComponentConfigFiles(client.getName())) {
    ConfigFormat configFormat=ConfigFormat.resolve(configFile.getType());
    Map<String,String> config=configurations.get(configFile.getDictionaryName());
    ConfigUtils.prepConfigForTemplateOutputter(configFormat,config,fileSystem,getClusterName(),new File(configFile.getFileName()).getName());
    PublishedConfiguration publishedConfiguration=new PublishedConfiguration(configFile.getDictionaryName(),config.entrySet());
    getAmState().getPublishedSliderConfigurations().put(configFile.getDictionaryName(),publishedConfiguration);
    log.info(""String_Node_Str"",configFile.getDictionaryName());
  }
}",0.9918149466192172
80230,"public void resolve() throws BadConfigException, IOException, BadClusterStateException {
  ConfTreeOperations appConf=instanceDescription.getAppConfOperations();
  ConfTreeOperations resources=instanceDescription.getResourceOperations();
  for (  Entry<String,Map<String,String>> entry : resources.getComponents().entrySet()) {
    if (COMPONENT_AM.equals(entry.getKey())) {
      continue;
    }
    if (entry.getValue().containsKey(ResourceKeys.COMPONENT_PRIORITY)) {
      priorities.add(Integer.parseInt(entry.getValue().get(ResourceKeys.COMPONENT_PRIORITY)));
    }
  }
  Set<String> externalComponents=getExternalComponents(appConf);
  if (!externalComponents.isEmpty()) {
    log.info(""String_Node_Str"",externalComponents);
  }
  for (  String component : externalComponents) {
    if (!isClusternameValid(component)) {
      throw new BadConfigException(component + ""String_Node_Str"" + ""String_Node_Str"");
    }
    Path componentClusterDir=coreFS.buildClusterDirPath(component);
    try {
      coreFS.verifyPathExists(componentClusterDir);
    }
 catch (    IOException e) {
      throw new BadConfigException(""String_Node_Str"" + component + ""String_Node_Str"");
    }
    AggregateConf componentConf=new AggregateConf();
    ConfPersister persister=new ConfPersister(coreFS,componentClusterDir);
    try {
      persister.load(componentConf);
    }
 catch (    Exception e) {
      throw new BadConfigException(""String_Node_Str"" + ""String_Node_Str"" + component);
    }
    ConfTreeOperations componentAppConf=componentConf.getAppConfOperations();
    String externalAppDef=componentAppConf.get(AgentKeys.APP_DEF);
    if (SliderUtils.isSet(externalAppDef)) {
      Path newAppDef=new Path(coreFS.buildAppDefDirPath(clustername),component + ""String_Node_Str"" + SliderKeys.DEFAULT_APP_PKG);
      componentAppConf.set(AgentKeys.APP_DEF,newAppDef);
      componentAppConf.append(AgentKeys.APP_DEF_ORIGINAL,externalAppDef);
      log.info(""String_Node_Str"",externalAppDef,newAppDef,component);
      externalAppDefs.put(externalAppDef,newAppDef);
      externalAppDef=newAppDef.toString();
    }
    for (    String rcomp : componentConf.getResourceOperations().getComponentNames()) {
      if (COMPONENT_AM.equals(rcomp)) {
        continue;
      }
      log.debug(""String_Node_Str"",rcomp,component);
      componentAppConf.getOrAddComponent(rcomp);
    }
    componentConf.resolve();
    for (    String rcomp : componentConf.getResourceOperations().getComponentNames()) {
      if (COMPONENT_AM.equals(rcomp)) {
        continue;
      }
      String componentAppDef=componentAppConf.getComponentOpt(rcomp,AgentKeys.APP_DEF,null);
      if (SliderUtils.isUnset(componentAppDef) || componentAppDef.equals(externalAppDef)) {
        continue;
      }
      if (externalAppDefs.containsKey(componentAppDef)) {
        log.info(""String_Node_Str"",externalAppDefs.get(componentAppDef),rcomp);
      }
 else {
        String existingPrefix=componentAppConf.getComponentOpt(rcomp,ROLE_PREFIX,null);
        if (SliderUtils.isUnset(existingPrefix)) {
          existingPrefix=""String_Node_Str"";
        }
 else {
          existingPrefix=COMPONENT_SEPARATOR + SliderUtils.trimPrefix(existingPrefix);
        }
        Path newAppDef=new Path(coreFS.buildAppDefDirPath(clustername),component + existingPrefix + ""String_Node_Str""+ SliderKeys.DEFAULT_APP_PKG);
        externalAppDefs.put(componentAppDef,newAppDef);
        log.info(""String_Node_Str"",componentAppDef,newAppDef,component + COMPONENT_SEPARATOR + rcomp);
      }
      componentAppConf.setComponentOpt(rcomp,AgentKeys.APP_DEF,externalAppDefs.get(componentAppDef).toString());
      componentAppConf.appendComponentOpt(rcomp,AgentKeys.APP_DEF_ORIGINAL,componentAppDef);
    }
    Set<Path> newAppDefs=new HashSet<>();
    newAppDefs.addAll(externalAppDefs.values());
    if (newAppDefs.size() != externalAppDefs.size()) {
      throw new IllegalStateException(""String_Node_Str"" + externalAppDefs);
    }
    log.info(""String_Node_Str"",component,externalAppDefs);
    mergeExternalComponent(appConf,componentAppConf,component,null);
    mergeExternalComponent(resources,componentConf.getResourceOperations(),component,getNextPriority());
  }
}","public void resolve() throws BadConfigException, IOException, BadClusterStateException {
  ConfTreeOperations appConf=instanceDescription.getAppConfOperations();
  ConfTreeOperations resources=instanceDescription.getResourceOperations();
  for (  Entry<String,Map<String,String>> entry : resources.getComponents().entrySet()) {
    if (COMPONENT_AM.equals(entry.getKey())) {
      continue;
    }
    if (entry.getValue().containsKey(ResourceKeys.COMPONENT_PRIORITY)) {
      priorities.add(Integer.parseInt(entry.getValue().get(ResourceKeys.COMPONENT_PRIORITY)));
    }
  }
  Set<String> externalComponents=getExternalComponents(appConf);
  if (!externalComponents.isEmpty()) {
    log.info(""String_Node_Str"",externalComponents);
  }
  for (  String component : externalComponents) {
    if (!isClusternameValid(component)) {
      throw new BadConfigException(component + ""String_Node_Str"" + ""String_Node_Str"");
    }
    Path componentClusterDir=coreFS.buildClusterDirPath(component);
    try {
      coreFS.verifyPathExists(componentClusterDir);
    }
 catch (    IOException e) {
      throw new BadConfigException(""String_Node_Str"" + component + ""String_Node_Str"");
    }
    AggregateConf componentConf=new AggregateConf();
    ConfPersister persister=new ConfPersister(coreFS,componentClusterDir);
    try {
      persister.load(componentConf);
    }
 catch (    Exception e) {
      throw new BadConfigException(""String_Node_Str"" + ""String_Node_Str"" + component);
    }
    ConfTreeOperations componentAppConf=componentConf.getAppConfOperations();
    String externalAppDef=componentAppConf.get(AgentKeys.APP_DEF);
    if (SliderUtils.isSet(externalAppDef)) {
      Path newAppDef=new Path(coreFS.buildAppDefDirPath(clustername),component + ""String_Node_Str"" + SliderKeys.DEFAULT_APP_PKG);
      componentAppConf.set(AgentKeys.APP_DEF,newAppDef);
      componentAppConf.append(AgentKeys.APP_DEF_ORIGINAL,externalAppDef);
      log.info(""String_Node_Str"",externalAppDef,newAppDef,component);
      externalAppDefs.put(externalAppDef,newAppDef);
      externalAppDef=newAppDef.toString();
    }
    for (    String rcomp : componentConf.getResourceOperations().getComponentNames()) {
      if (COMPONENT_AM.equals(rcomp)) {
        continue;
      }
      log.debug(""String_Node_Str"",rcomp,component);
      componentAppConf.getOrAddComponent(rcomp);
    }
    componentConf.resolve();
    for (    String rcomp : componentConf.getResourceOperations().getComponentNames()) {
      if (COMPONENT_AM.equals(rcomp)) {
        continue;
      }
      String componentAppDef=componentAppConf.getComponentOpt(rcomp,AgentKeys.APP_DEF,null);
      if (SliderUtils.isUnset(componentAppDef) || componentAppDef.equals(externalAppDef)) {
        continue;
      }
      if (externalAppDefs.containsKey(componentAppDef)) {
        log.info(""String_Node_Str"",externalAppDefs.get(componentAppDef),rcomp);
      }
 else {
        String existingPrefix=componentAppConf.getComponentOpt(rcomp,ROLE_PREFIX,null);
        if (SliderUtils.isUnset(existingPrefix)) {
          existingPrefix=""String_Node_Str"";
        }
 else {
          existingPrefix=COMPONENT_SEPARATOR + SliderUtils.trimPrefix(existingPrefix);
        }
        Path newAppDef=new Path(coreFS.buildAppDefDirPath(clustername),component + existingPrefix + ""String_Node_Str""+ SliderKeys.DEFAULT_APP_PKG);
        externalAppDefs.put(componentAppDef,newAppDef);
        log.info(""String_Node_Str"",componentAppDef,newAppDef,component + COMPONENT_SEPARATOR + rcomp);
      }
      componentAppConf.setComponentOpt(rcomp,AgentKeys.APP_DEF,externalAppDefs.get(componentAppDef).toString());
      componentAppConf.appendComponentOpt(rcomp,AgentKeys.APP_DEF_ORIGINAL,componentAppDef);
    }
    Set<Path> newAppDefs=new HashSet<>();
    newAppDefs.addAll(externalAppDefs.values());
    if (newAppDefs.size() != externalAppDefs.size()) {
      throw new IllegalStateException(""String_Node_Str"" + externalAppDefs);
    }
    log.info(""String_Node_Str"",component,externalAppDefs);
    SliderUtils.mergeMapsIgnoreDuplicateKeys(appConf.getConfTree().credentials,componentAppConf.getConfTree().credentials);
    mergeExternalComponent(appConf,componentAppConf,component,null);
    mergeExternalComponent(resources,componentConf.getResourceOperations(),component,getNextPriority());
  }
}",0.9854664791373652
80231,"/** 
 * Process return status for component instances
 * @param heartBeat
 * @param componentStatus
 */
protected void publishConfigAndExportGroups(HeartBeat heartBeat,ComponentInstanceState componentStatus,String componentGroup){
  List<ComponentStatus> statuses=heartBeat.getComponentStatus();
  if (statuses != null && !statuses.isEmpty()) {
    log.info(""String_Node_Str"",statuses.size());
    for (    ComponentStatus status : statuses) {
      log.info(""String_Node_Str"",status.toString());
      if (status.getConfigs() != null) {
        Application application=getMetaInfo(componentGroup).getApplication();
        if ((!canAnyMasterPublishConfig(componentGroup) || canPublishConfig(componentGroup)) && !getAmState().getAppConfSnapshot().getComponentOptBool(componentGroup,AgentKeys.AM_CONFIG_GENERATION,false)) {
          Set<String> exportedConfigs=new HashSet();
          String exportedConfigsStr=application.getExportedConfigs();
          boolean exportedAllConfigs=exportedConfigsStr == null || exportedConfigsStr.isEmpty();
          if (!exportedAllConfigs) {
            for (            String exportedConfig : exportedConfigsStr.split(""String_Node_Str"")) {
              if (exportedConfig.trim().length() > 0) {
                exportedConfigs.add(exportedConfig.trim());
              }
            }
          }
          for (          String key : status.getConfigs().keySet()) {
            if ((!exportedAllConfigs && exportedConfigs.contains(key)) || exportedAllConfigs) {
              Map<String,String> configs=status.getConfigs().get(key);
              publishApplicationInstanceData(key,key,configs.entrySet());
            }
          }
        }
        List<ExportGroup> appExportGroups=application.getExportGroups();
        boolean hasExportGroups=SliderUtils.isNotEmpty(appExportGroups);
        Set<String> appExports=new HashSet();
        String appExportsStr=getApplicationComponent(componentGroup).getAppExports();
        if (SliderUtils.isSet(appExportsStr)) {
          for (          String appExport : appExportsStr.split(""String_Node_Str"")) {
            if (!appExport.trim().isEmpty()) {
              appExports.add(appExport.trim());
            }
          }
        }
        if (hasExportGroups && !appExports.isEmpty()) {
          String configKeyFormat=""String_Node_Str"";
          String hostKeyFormat=""String_Node_Str"";
          Map<String,String> replaceTokens=new HashMap<String,String>();
          for (          Map.Entry<String,Map<String,ClusterNode>> entry : getRoleClusterNodeMapping().entrySet()) {
            String hostName=getHostsList(entry.getValue().values(),true).iterator().next();
            replaceTokens.put(String.format(hostKeyFormat,entry.getKey().toUpperCase(Locale.ENGLISH)),hostName);
          }
          for (          String key : status.getConfigs().keySet()) {
            Map<String,String> configs=status.getConfigs().get(key);
            for (            String configKey : configs.keySet()) {
              String lookupKey=String.format(configKeyFormat,key,configKey);
              replaceTokens.put(lookupKey,configs.get(configKey));
            }
          }
          Set<String> modifiedGroups=new HashSet<String>();
          for (          ExportGroup exportGroup : appExportGroups) {
            List<Export> exports=exportGroup.getExports();
            if (SliderUtils.isNotEmpty(exports)) {
              String exportGroupName=exportGroup.getName();
              ConcurrentHashMap<String,List<ExportEntry>> map=(ConcurrentHashMap<String,List<ExportEntry>>)getCurrentExports(exportGroupName);
              for (              Export export : exports) {
                if (canBeExported(exportGroupName,export.getName(),appExports)) {
                  String value=export.getValue();
                  for (                  String token : replaceTokens.keySet()) {
                    if (value.contains(token)) {
                      value=value.replace(token,replaceTokens.get(token));
                    }
                  }
                  ExportEntry entry=new ExportEntry();
                  entry.setLevel(APPLICATION_TAG);
                  entry.setValue(value);
                  entry.setUpdatedTime(new Date().toString());
                  map.put(export.getName(),new ArrayList(Arrays.asList(entry)));
                  log.info(""String_Node_Str"",export.getName(),value);
                }
              }
              modifiedGroups.add(exportGroupName);
            }
          }
          publishModifiedExportGroups(modifiedGroups);
        }
        log.info(""String_Node_Str"",heartBeat.getHostname());
        componentStatus.setConfigReported(true);
      }
    }
  }
}","/** 
 * Process return status for component instances
 * @param heartBeat
 * @param componentStatus
 */
protected void publishConfigAndExportGroups(HeartBeat heartBeat,ComponentInstanceState componentStatus,String componentGroup){
  List<ComponentStatus> statuses=heartBeat.getComponentStatus();
  if (statuses != null && !statuses.isEmpty()) {
    log.info(""String_Node_Str"",statuses.size());
    for (    ComponentStatus status : statuses) {
      log.info(""String_Node_Str"",status.toString());
      if (status.getConfigs() != null) {
        Application application=getMetaInfo(componentGroup).getApplication();
        if ((!canAnyMasterPublishConfig(componentGroup) || canPublishConfig(componentGroup)) && !getAmState().getAppConfSnapshot().getComponentOptBool(componentGroup,AgentKeys.AM_CONFIG_GENERATION,false)) {
          Set<String> exportedConfigs=new HashSet();
          String exportedConfigsStr=application.getExportedConfigs();
          boolean exportedAllConfigs=exportedConfigsStr == null || exportedConfigsStr.isEmpty();
          if (!exportedAllConfigs) {
            for (            String exportedConfig : exportedConfigsStr.split(""String_Node_Str"")) {
              if (exportedConfig.trim().length() > 0) {
                exportedConfigs.add(exportedConfig.trim());
              }
            }
          }
          for (          String key : status.getConfigs().keySet()) {
            if ((!exportedAllConfigs && exportedConfigs.contains(key)) || exportedAllConfigs) {
              Map<String,String> configs=status.getConfigs().get(key);
              publishApplicationInstanceData(key,key,configs.entrySet());
            }
          }
        }
        List<ExportGroup> appExportGroups=application.getExportGroups();
        boolean hasExportGroups=SliderUtils.isNotEmpty(appExportGroups);
        Set<String> appExports=new HashSet();
        String appExportsStr=getApplicationComponent(componentGroup).getAppExports();
        if (SliderUtils.isSet(appExportsStr)) {
          for (          String appExport : appExportsStr.split(""String_Node_Str"")) {
            if (!appExport.trim().isEmpty()) {
              appExports.add(appExport.trim());
            }
          }
        }
        if (hasExportGroups && !appExports.isEmpty()) {
          String configKeyFormat=""String_Node_Str"";
          String hostKeyFormat=""String_Node_Str"";
          Map<String,String> replaceTokens=new HashMap<String,String>();
          for (          Map.Entry<String,Map<String,ClusterNode>> entry : getRoleClusterNodeMapping().entrySet()) {
            String hostName=getHostsList(entry.getValue().values(),true).iterator().next();
            replaceTokens.put(String.format(hostKeyFormat,entry.getKey().toUpperCase(Locale.ENGLISH)),hostName);
          }
          for (          String key : status.getConfigs().keySet()) {
            Map<String,String> configs=status.getConfigs().get(key);
            for (            String configKey : configs.keySet()) {
              String lookupKey=String.format(configKeyFormat,key,configKey);
              replaceTokens.put(lookupKey,configs.get(configKey));
            }
          }
          Set<String> modifiedGroups=new HashSet<String>();
          for (          ExportGroup exportGroup : appExportGroups) {
            List<Export> exports=exportGroup.getExports();
            if (SliderUtils.isNotEmpty(exports)) {
              String exportGroupName=exportGroup.getName();
              ConcurrentHashMap<String,List<ExportEntry>> map=(ConcurrentHashMap<String,List<ExportEntry>>)getCurrentExports(exportGroupName);
              for (              Export export : exports) {
                if (canBeExported(exportGroupName,export.getName(),appExports)) {
                  String value=export.getValue();
                  for (                  String token : replaceTokens.keySet()) {
                    if (value.contains(token)) {
                      value=value.replaceAll(Pattern.quote(token),replaceTokens.get(token));
                    }
                  }
                  ExportEntry entry=new ExportEntry();
                  entry.setLevel(APPLICATION_TAG);
                  entry.setValue(value);
                  entry.setUpdatedTime(new Date().toString());
                  map.put(export.getName(),new ArrayList(Arrays.asList(entry)));
                  log.info(""String_Node_Str"",export.getName(),value);
                }
              }
              modifiedGroups.add(exportGroupName);
            }
          }
          publishModifiedExportGroups(modifiedGroups);
        }
        log.info(""String_Node_Str"",heartBeat.getHostname());
        componentStatus.setConfigReported(true);
      }
    }
  }
}",0.9980964467005076
80232,"private void createConfigFile(SliderFileSystem fileSystem,File file,ConfigFile configFile,Map<String,String> config) throws IOException {
  ConfigFormat configFormat=ConfigFormat.resolve(configFile.getType());
  log.info(""String_Node_Str"",configFormat,file);
  ConfigUtils.prepConfigForTemplateOutputter(configFormat,config,fileSystem,getClusterName(),file.getName());
  PublishedConfiguration publishedConfiguration=new PublishedConfiguration(configFile.getDictionaryName(),config.entrySet());
  PublishedConfigurationOutputter configurationOutputter=PublishedConfigurationOutputter.createOutputter(configFormat,publishedConfiguration);
  configurationOutputter.save(file);
}","private synchronized void createConfigFile(SliderFileSystem fileSystem,File file,ConfigFile configFile,Map<String,String> config) throws IOException {
  ConfigFormat configFormat=ConfigFormat.resolve(configFile.getType());
  if (file.exists()) {
    log.info(""String_Node_Str"",configFormat,file);
    return;
  }
  log.info(""String_Node_Str"",configFormat,file);
  ConfigUtils.prepConfigForTemplateOutputter(configFormat,config,fileSystem,getClusterName(),file.getName());
  PublishedConfiguration publishedConfiguration=new PublishedConfiguration(configFile.getDictionaryName(),config.entrySet());
  PublishedConfigurationOutputter configurationOutputter=PublishedConfigurationOutputter.createOutputter(configFormat,publishedConfiguration);
  configurationOutputter.save(file);
}",0.9292096219931272
80233,"@VisibleForTesting protected void localizeConfigFiles(ContainerLauncher launcher,String roleName,String roleGroup,Metainfo metainfo,Map<String,Map<String,String>> configs,MapOperations env,SliderFileSystem fileSystem,ConfTreeOperations appConf) throws IOException {
  for (  ConfigFile configFile : metainfo.getComponentConfigFiles(roleGroup)) {
    Map<String,String> config=ConfigUtils.replacePropsInConfig(configs.get(configFile.getDictionaryName()),env.options);
    String fileName=ConfigUtils.replaceProps(config,configFile.getFileName());
    File localFile=new File(SliderKeys.RESOURCE_DIR);
    if (!localFile.exists()) {
      localFile.mkdir();
    }
    localFile=new File(localFile,new File(fileName).getName());
    boolean perComponent=appConf.getComponentOptBool(roleGroup,""String_Node_Str"" + configFile.getDictionaryName() + PER_COMPONENT,false);
    boolean perGroup=appConf.getComponentOptBool(roleGroup,""String_Node_Str"" + configFile.getDictionaryName() + PER_GROUP,false);
    String folder=null;
    if (perComponent) {
      folder=roleName;
    }
 else     if (perGroup) {
      folder=roleGroup;
    }
    log.info(""String_Node_Str"" + ""String_Node_Str"",config.size(),localFile,fileName,configFile.getDictionaryName());
    createConfigFile(fileSystem,localFile,configFile,config);
    Path destPath=uploadResource(localFile,fileSystem,folder);
    LocalResource configResource=fileSystem.createAmResource(destPath,LocalResourceType.FILE);
    File destFile=new File(fileName);
    if (destFile.isAbsolute()) {
      launcher.addLocalResource(SliderKeys.RESOURCE_DIR + ""String_Node_Str"" + destFile.getName(),configResource,fileName);
    }
 else {
      launcher.addLocalResource(AgentKeys.APP_CONF_DIR + ""String_Node_Str"" + fileName,configResource);
    }
  }
}","@VisibleForTesting protected void localizeConfigFiles(ContainerLauncher launcher,String roleName,String roleGroup,Metainfo metainfo,Map<String,Map<String,String>> configs,MapOperations env,SliderFileSystem fileSystem,ConfTreeOperations appConf) throws IOException {
  for (  ConfigFile configFile : metainfo.getComponentConfigFiles(roleGroup)) {
    Map<String,String> config=ConfigUtils.replacePropsInConfig(configs.get(configFile.getDictionaryName()),env.options);
    String fileName=ConfigUtils.replaceProps(config,configFile.getFileName());
    File localFile=new File(SliderKeys.RESOURCE_DIR);
    if (!localFile.exists()) {
      if (!localFile.mkdir() && !localFile.exists()) {
        throw new IOException(RESOURCE_DIR + ""String_Node_Str"");
      }
    }
    boolean perComponent=appConf.getComponentOptBool(roleGroup,""String_Node_Str"" + configFile.getDictionaryName() + PER_COMPONENT,false);
    boolean perGroup=appConf.getComponentOptBool(roleGroup,""String_Node_Str"" + configFile.getDictionaryName() + PER_GROUP,false);
    String folder=null;
    if (perComponent) {
      folder=roleName;
    }
 else     if (perGroup) {
      folder=roleGroup;
    }
    if (folder != null) {
      localFile=new File(localFile,folder);
      if (!localFile.exists()) {
        if (!localFile.mkdir() && !localFile.exists()) {
          throw new IOException(localFile + ""String_Node_Str"");
        }
      }
    }
    localFile=new File(localFile,new File(fileName).getName());
    log.info(""String_Node_Str"" + ""String_Node_Str"",config.size(),localFile,fileName,configFile.getDictionaryName());
    if (!localFile.exists()) {
      createConfigFile(fileSystem,localFile,configFile,config);
    }
 else {
      log.info(""String_Node_Str"",configFile.getType(),localFile);
    }
    Path destPath=uploadResource(localFile,fileSystem,folder);
    LocalResource configResource=fileSystem.createAmResource(destPath,LocalResourceType.FILE);
    File destFile=new File(fileName);
    if (destFile.isAbsolute()) {
      launcher.addLocalResource(SliderKeys.RESOURCE_DIR + ""String_Node_Str"" + destFile.getName(),configResource,fileName);
    }
 else {
      launcher.addLocalResource(AgentKeys.APP_CONF_DIR + ""String_Node_Str"" + fileName,configResource);
    }
  }
}",0.8500742206828302
80234,"@Override public void execute(SliderAppMaster appMaster,QueueAccess queueService,AppState appState) throws Exception {
  if (fs != null) {
synchronized (fs) {
      try {
        long expires=remoteUser.doAs(new PrivilegedExceptionAction<Long>(){
          @Override public Long run() throws Exception {
            long expires=token.renew(fs.getConf());
            log.info(""String_Node_Str"",getPrintableExirationTime(expires));
            return expires;
          }
        }
);
        long calculatedInterval=tokenExpiryTime - Time.now();
        if (calculatedInterval < renewInterval) {
          log.info(""String_Node_Str"",calculatedInterval);
          getNewToken();
        }
 else {
          updateRenewalTime(renewInterval);
        }
      }
 catch (      IOException ie) {
        log.info(""String_Node_Str"",ie);
        getNewToken();
      }
    }
  }
}","@Override public void execute(SliderAppMaster appMaster,QueueAccess queueService,AppState appState) throws Exception {
  if (fs != null) {
synchronized (fs) {
      try {
        long expires=remoteUser.doAs(new PrivilegedExceptionAction<Long>(){
          @Override public Long run() throws Exception {
            long expires=token.renew(fs.getConf());
            log.info(""String_Node_Str"",getPrintableExpirationTime(expires));
            return expires;
          }
        }
);
        long calculatedInterval=tokenExpiryTime - Time.now();
        if (calculatedInterval < renewInterval) {
          log.info(""String_Node_Str"",calculatedInterval);
          getNewToken();
        }
 else {
          updateRenewalTime(renewInterval);
        }
      }
 catch (      IOException ie) {
        log.info(""String_Node_Str"",ie);
        getNewToken();
      }
    }
  }
}",0.9994282447112636
80235,"RenewAction(String name,Configuration configuration) throws IOException, InterruptedException {
  super(name);
  this.configuration=configuration;
  fs=getFileSystem();
synchronized (fs) {
    this.token=remoteUser.doAs(new PrivilegedExceptionAction<Token<?>>(){
      @Override public Token<?> run() throws Exception {
        log.info(""String_Node_Str"",remoteUser.getShortUserName());
        Token token=fs.getDelegationToken(remoteUser.getShortUserName());
        tokenExpiryTime=getTokenExpiryTime(token);
        log.info(""String_Node_Str"",getPrintableExirationTime(tokenExpiryTime));
        return token;
      }
    }
);
  }
  log.info(""String_Node_Str"",token);
}","RenewAction(String name,Configuration configuration) throws IOException, InterruptedException {
  super(name);
  this.configuration=configuration;
  fs=getFileSystem();
synchronized (fs) {
    this.token=remoteUser.doAs(new PrivilegedExceptionAction<Token<?>>(){
      @Override public Token<?> run() throws Exception {
        log.info(""String_Node_Str"",remoteUser.getShortUserName());
        Token token=fs.getDelegationToken(remoteUser.getShortUserName());
        tokenExpiryTime=getTokenExpiryTime(token);
        log.info(""String_Node_Str"",getPrintableExpirationTime(tokenExpiryTime));
        return token;
      }
    }
);
  }
  log.info(""String_Node_Str"",token);
}",0.9992576095025985
80236,"private void getNewToken() throws InterruptedException, IOException {
  try {
    Text service=token.getService();
    Token<?>[] tokens=remoteUser.doAs(new PrivilegedExceptionAction<Token<?>[]>(){
      @Override public Token<?>[] run() throws Exception {
        return fs.addDelegationTokens(remoteUser.getShortUserName(),null);
      }
    }
);
    if (tokens.length == 0) {
      throw new IOException(""String_Node_Str"");
    }
    token=findMatchingToken(service,tokens);
    currentUser.addToken(token.getService(),token);
    tokenExpiryTime=getTokenExpiryTime(token);
    log.info(""String_Node_Str"" + ""String_Node_Str"",getPrintableExirationTime(tokenExpiryTime));
    updateRenewalTime(renewInterval);
  }
 catch (  IOException ie2) {
    throw new IOException(""String_Node_Str"",ie2);
  }
}","private void getNewToken() throws InterruptedException, IOException {
  try {
    Text service=token.getService();
    Token<?>[] tokens=remoteUser.doAs(new PrivilegedExceptionAction<Token<?>[]>(){
      @Override public Token<?>[] run() throws Exception {
        return fs.addDelegationTokens(remoteUser.getShortUserName(),null);
      }
    }
);
    if (tokens.length == 0) {
      throw new IOException(""String_Node_Str"");
    }
    token=findMatchingToken(service,tokens);
    currentUser.addToken(token.getService(),token);
    tokenExpiryTime=getTokenExpiryTime(token);
    log.info(""String_Node_Str"" + ""String_Node_Str"",getPrintableExpirationTime(tokenExpiryTime));
    updateRenewalTime(renewInterval);
  }
 catch (  IOException ie2) {
    throw new IOException(""String_Node_Str"",ie2);
  }
}",0.9993746091307066
80237,"private void validateKeystore(File keystoreFile) throws KeyStoreException, IOException, NoSuchAlgorithmException, CertificateException {
  Assert.assertTrue(""String_Node_Str"",keystoreFile.exists());
  InputStream is=null;
  try {
    is=new FileInputStream(keystoreFile);
    KeyStore keystore=KeyStore.getInstance(""String_Node_Str"");
    String password=""String_Node_Str"";
    keystore.load(is,password.toCharArray());
    Certificate certificate=keystore.getCertificate(keystore.aliases().nextElement());
    Assert.assertNotNull(certificate);
    if (certificate instanceof X509Certificate) {
      X509Certificate x509cert=(X509Certificate)certificate;
      Principal principal=x509cert.getSubjectDN();
      String subjectDn=principal.getName();
      Assert.assertEquals(""String_Node_Str"",""String_Node_Str"",subjectDn);
      principal=x509cert.getIssuerDN();
      String issuerDn=principal.getName();
      Assert.assertEquals(""String_Node_Str"",""String_Node_Str"",issuerDn);
    }
  }
  finally {
    if (null != is) {
      is.close();
    }
  }
}","private void validateKeystore(File keystoreFile) throws KeyStoreException, IOException, NoSuchAlgorithmException, CertificateException {
  Assert.assertTrue(""String_Node_Str"",keystoreFile.exists());
  InputStream is=null;
  try {
    is=new FileInputStream(keystoreFile);
    KeyStore keystore=KeyStore.getInstance(""String_Node_Str"");
    String password=""String_Node_Str"";
    keystore.load(is,password.toCharArray());
    Certificate certificate=keystore.getCertificate(keystore.aliases().nextElement());
    Assert.assertNotNull(certificate);
    if (certificate instanceof X509Certificate) {
      X509Certificate x509cert=(X509Certificate)certificate;
      Principal principal=x509cert.getSubjectDN();
      String subjectDn=principal.getName();
      Assert.assertEquals(""String_Node_Str"",""String_Node_Str"",subjectDn);
      principal=x509cert.getIssuerDN();
      String issuerDn=principal.getName();
      Assert.assertEquals(""String_Node_Str"",""String_Node_Str"" + InetAddress.getLocalHost().getHostName(),issuerDn);
    }
  }
  finally {
    if (null != is) {
      is.close();
    }
  }
}",0.9800278680910358
80238,"@Test public void testAMKeystoreGenerated() throws Exception {
  File keystoreFile=new File(secDir,SliderKeys.KEYSTORE_FILE_NAME);
  Assert.assertTrue(""String_Node_Str"" + keystoreFile,keystoreFile.exists());
  InputStream is=null;
  try {
    is=new FileInputStream(keystoreFile);
    KeyStore keystore=KeyStore.getInstance(""String_Node_Str"");
    String password=SecurityUtils.getKeystorePass();
    keystore.load(is,password.toCharArray());
    Certificate certificate=keystore.getCertificate(keystore.aliases().nextElement());
    Assert.assertNotNull(certificate);
    if (certificate instanceof X509Certificate) {
      X509Certificate x509cert=(X509Certificate)certificate;
      Principal principal=x509cert.getSubjectDN();
      String subjectDn=principal.getName();
      Assert.assertEquals(""String_Node_Str"",""String_Node_Str"",subjectDn);
      principal=x509cert.getIssuerDN();
      String issuerDn=principal.getName();
      Assert.assertEquals(""String_Node_Str"",""String_Node_Str"",issuerDn);
    }
  }
  finally {
    if (null != is) {
      is.close();
    }
  }
}","@Test public void testAMKeystoreGenerated() throws Exception {
  File keystoreFile=new File(secDir,SliderKeys.KEYSTORE_FILE_NAME);
  Assert.assertTrue(""String_Node_Str"" + keystoreFile,keystoreFile.exists());
  InputStream is=null;
  try {
    is=new FileInputStream(keystoreFile);
    KeyStore keystore=KeyStore.getInstance(""String_Node_Str"");
    String password=SecurityUtils.getKeystorePass();
    keystore.load(is,password.toCharArray());
    Certificate certificate=keystore.getCertificate(keystore.aliases().nextElement());
    Assert.assertNotNull(certificate);
    if (certificate instanceof X509Certificate) {
      X509Certificate x509cert=(X509Certificate)certificate;
      Principal principal=x509cert.getSubjectDN();
      String subjectDn=principal.getName();
      Assert.assertEquals(""String_Node_Str"",""String_Node_Str"",subjectDn);
      principal=x509cert.getIssuerDN();
      String issuerDn=principal.getName();
      Assert.assertEquals(""String_Node_Str"",""String_Node_Str"" + InetAddress.getLocalHost().getHostName(),issuerDn);
    }
  }
  finally {
    if (null != is) {
      is.close();
    }
  }
}",0.9804456571168711
80239,"protected void resetResponse(){
  response=createResponse();
}","protected void resetResponse(){
  CookieStore cookieStore=null;
  if (storeCookies) {
    cookieStore=getResponse().getCookieStore();
    if (cookieStore == null) {
      cookieStore=new BasicCookieStore();
    }
  }
  response=createResponse();
  if (storeCookies) {
    response.setCookieStore(cookieStore);
  }
}",0.2652519893899204
80240,"/** 
 * @param headerName name of response header.
 * @return value of header in last response.
 */
public String responseHeader(String headerName){
  return responseHeaders().get(headerName);
}","/** 
 * @param headerName name of response header.
 * @return value of header in last response (may be a list if the saame header name was sent multiple times(e.g. Set-Cookie).
 */
public Object responseHeader(String headerName){
  return responseHeaders().get(headerName);
}",0.6098081023454158
80241,"/** 
 * @return headers received with response to last request.
 */
public Map<String,String> responseHeaders(){
  return response.getResponseHeaders();
}","/** 
 * @return headers received with response to last request.
 */
public Map<String,Object> responseHeaders(){
  return response.getResponseHeaders();
}",0.9675324675324676
80242,"protected void getResponse(String url,HttpResponse response,HttpRequestBase method,Map<String,Object> headers){
  long startTime=0;
  long endTime=-1;
  try {
    if (headers != null) {
      for (      String key : headers.keySet()) {
        Object value=headers.get(key);
        if (value != null) {
          method.setHeader(key,value.toString());
        }
      }
    }
    org.apache.http.HttpResponse resp;
    CookieStore store=response.getCookieStore();
    startTime=currentTimeMillis();
    if (store == null) {
      resp=getHttpResponse(url,method);
    }
 else {
      resp=getHttpResponse(store,url,method);
    }
    endTime=currentTimeMillis();
    int returnCode=resp.getStatusLine().getStatusCode();
    response.setStatusCode(returnCode);
    HttpEntity entity=resp.getEntity();
    Map<String,String> responseHeaders=response.getResponseHeaders();
    for (    Header h : resp.getAllHeaders()) {
      responseHeaders.put(h.getName(),h.getValue());
    }
    if (entity == null) {
      response.setResponse(null);
    }
 else {
      if (response instanceof BinaryHttpResponse) {
        BinaryHttpResponse binaryHttpResponse=(BinaryHttpResponse)response;
        byte[] content=EntityUtils.toByteArray(entity);
        binaryHttpResponse.setResponseContent(content);
        String fileName=getAttachmentFileName(resp);
        binaryHttpResponse.setFileName(fileName);
      }
 else {
        String result=EntityUtils.toString(entity);
        response.setResponse(result);
      }
    }
  }
 catch (  Exception e) {
    throw new RuntimeException(""String_Node_Str"" + url,e);
  }
 finally {
    if (startTime > 0) {
      if (endTime < 0) {
        endTime=currentTimeMillis();
      }
    }
    response.setResponseTime(endTime - startTime);
    method.reset();
  }
}","protected void getResponse(String url,HttpResponse response,HttpRequestBase method,Map<String,Object> headers){
  long startTime=0;
  long endTime=-1;
  try {
    if (headers != null) {
      for (      String key : headers.keySet()) {
        Object value=headers.get(key);
        if (value != null) {
          method.setHeader(key,value.toString());
        }
      }
    }
    org.apache.http.HttpResponse resp;
    CookieStore store=response.getCookieStore();
    startTime=currentTimeMillis();
    if (store == null) {
      resp=getHttpResponse(url,method);
    }
 else {
      resp=getHttpResponse(store,url,method);
    }
    endTime=currentTimeMillis();
    int returnCode=resp.getStatusLine().getStatusCode();
    response.setStatusCode(returnCode);
    HttpEntity entity=resp.getEntity();
    copyHeaders(response.getResponseHeaders(),resp.getAllHeaders());
    if (entity == null) {
      response.setResponse(null);
    }
 else {
      if (response instanceof BinaryHttpResponse) {
        BinaryHttpResponse binaryHttpResponse=(BinaryHttpResponse)response;
        byte[] content=EntityUtils.toByteArray(entity);
        binaryHttpResponse.setResponseContent(content);
        String fileName=getAttachmentFileName(resp);
        binaryHttpResponse.setFileName(fileName);
      }
 else {
        String result=EntityUtils.toString(entity);
        response.setResponse(result);
      }
    }
  }
 catch (  Exception e) {
    throw new RuntimeException(""String_Node_Str"" + url,e);
  }
 finally {
    if (startTime > 0) {
      if (endTime < 0) {
        endTime=currentTimeMillis();
      }
    }
    response.setResponseTime(endTime - startTime);
    method.reset();
  }
}",0.936854190585534
80243,"/** 
 * @return headers in response.
 */
public Map<String,String> getResponseHeaders(){
  return responseHeaders;
}","/** 
 * @return headers in response.
 */
public Map<String,Object> getResponseHeaders(){
  return responseHeaders;
}",0.956896551724138
80244,"/** 
 * Takes screenshot from current page
 * @param basename filename (below screenshot base directory).
 * @return location of screenshot.
 */
public String takeScreenshot(String basename){
  String screenshotFile=createScreenshot(basename);
  if (screenshotFile == null) {
    throw new SlimFixtureException(false,""String_Node_Str"");
  }
 else {
    screenshotFile=getScreenshotLink(screenshotFile);
  }
  return screenshotFile;
}","/** 
 * Takes screenshot from current page
 * @param basename filename (below screenshot base directory).
 * @return location of screenshot.
 */
public String takeScreenshot(String basename){
  try {
    String screenshotFile=createScreenshot(basename);
    if (screenshotFile == null) {
      throw new SlimFixtureException(false,""String_Node_Str"");
    }
 else {
      screenshotFile=getScreenshotLink(screenshotFile);
    }
    return screenshotFile;
  }
 catch (  UnhandledAlertException e) {
    return String.format(""String_Node_Str"" + ""String_Node_Str"",StringEscapeUtils.escapeHtml4(alertText()));
  }
}",0.8302972195589645
80245,"@Test public void testBadXPath(){
  String responseString=FileUtil.loadFile(""String_Node_Str"");
  assertEquals(""String_Node_Str"",XPathHelper.getXPath(null,responseString,""String_Node_Str""));
  try {
    XPathHelper.getXPath(null,responseString,""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  FitFailureException e) {
    assertEquals(""String_Node_Str"",e.getMessage());
  }
}","@Test public void testBadXPath(){
  String responseString=FileUtil.loadFile(""String_Node_Str"");
  assertEquals(""String_Node_Str"",XPathHelper.getXPath(null,responseString,""String_Node_Str""));
  try {
    XPathHelper.getXPath(null,responseString,""String_Node_Str"");
    fail(""String_Node_Str"");
  }
 catch (  FitFailureException e) {
    assertEquals(""String_Node_Str"" + ""String_Node_Str"",e.getMessage());
  }
}",0.974937343358396
80246,"private KeyInfo newKeyInfo(final List<Certificate> certs,final String keyInfoId,final boolean addKeyValue,final boolean addKeyName) throws KeyException {
  final List<Certificate> certificates=EscapeHelper.getEscapedCertificates(certs);
  final KeyInfoFactory keyInfoFactory=getXMLSignatureFactory().getKeyInfoFactory();
  final List<Certificate> x509DataList=new ArrayList<Certificate>();
  if (!XmlWrappedKeyInfo.PUBLIC_KEY.equals(getXmlWrappedKeyInfo())) {
    for (    final Certificate cert : certificates) {
      x509DataList.add(cert);
    }
  }
  final List<XMLStructure> newList=new ArrayList<XMLStructure>();
  newList.add(keyInfoFactory.newX509Data(x509DataList));
  if (addKeyValue) {
    newList.add(keyInfoFactory.newKeyValue(certificates.get(0).getPublicKey()));
  }
  if (addKeyName) {
    newList.add(keyInfoFactory.newKeyName(((X509Certificate)certificates.get(0)).getSubjectX500Principal().toString()));
  }
  return keyInfoFactory.newKeyInfo(newList,keyInfoId);
}","private KeyInfo newKeyInfo(final List<Certificate> certs,final String keyInfoId,final boolean addKeyValue,final boolean addKeyName) throws KeyException {
  final List<Certificate> certificates=EscapeHelper.getEscapedCertificates(certs);
  final KeyInfoFactory keyInfoFactory=getXMLSignatureFactory().getKeyInfoFactory();
  final List<Certificate> x509DataList=new ArrayList<Certificate>();
  if (!XmlWrappedKeyInfo.PUBLIC_KEY.equals(getXmlWrappedKeyInfo())) {
    for (    final Certificate cert : certificates) {
      x509DataList.add(cert);
    }
  }
  final List<XMLStructure> newList=new ArrayList<XMLStructure>();
  newList.add(keyInfoFactory.newX509Data(x509DataList));
  if (addKeyValue) {
    newList.add(keyInfoFactory.newKeyValue(certificates.get(0).getPublicKey()));
  }
  if (addKeyName) {
    newList.add(keyInfoFactory.newKeyName(EscapeHelper.escapeLdapName(((X509Certificate)certificates.get(0)).getSubjectX500Principal().toString())));
  }
  return keyInfoFactory.newKeyInfo(newList,keyInfoId);
}",0.985478217325989
80247,"/** 
 * Constructor de la clase. Se crea una cofirma a partir de los datos del firmante y del archivo que contiene las firmas.
 * @param signatureAlgorithm Algoritmo para la firma
 * @param signerCertificateChain Cadena de certificados para la construccion de los parametrosde firma.
 * @param data Archivo que contiene las firmas.
 * @param policy Pol&iacute;tica de firma
 * @param signingCertificateV2 <code>true</code> si se desea usar la versi&oacute;n 2 del atributo <i>Signing Certificate</i> <code>false</code> para usar la versi&oacute;n 1
 * @param keyEntry Clave privada usada para firmar.
 * @param md Huella digital espec&iacute;fica para una firma.
 * @return El archivo de firmas con la nueva firma.
 * @throws java.io.IOException Si ocurre alg&uacute;n problema leyendo o escribiendo los datos
 * @throws java.security.NoSuchAlgorithmException Si no se soporta alguno de los algoritmos de firma o huella digital
 * @throws java.security.cert.CertificateException Si se produce alguna excepci&oacute;n con los certificados de firma.
 * @throws javax.security.cert.CertificateException 
 */
byte[] coSigner(final String signatureAlgorithm,final X509Certificate[] signerCertificateChain,final InputStream data,final AdESPolicy policy,final boolean signingCertificateV2,final PrivateKeyEntry keyEntry,final byte[] md) throws IOException, NoSuchAlgorithmException, CertificateException {
  final ASN1InputStream is=new ASN1InputStream(data);
  final ASN1Sequence dsq=(ASN1Sequence)is.readObject();
  final Enumeration<?> e=dsq.getObjects();
  e.nextElement();
  final ASN1TaggedObject doj=(ASN1TaggedObject)e.nextElement();
  final ASN1Sequence contentSignedData=(ASN1Sequence)doj.getObject();
  final SignedData sd=new SignedData(contentSignedData);
  final ContentInfo encInfo=sd.getEncapContentInfo();
  final DEROctetString contenido=(DEROctetString)encInfo.getContent();
  byte[] contenidoDatos=null;
  if (contenido != null) {
    contenidoDatos=AOUtil.getDataFromInputStream(contenido.getOctetStream());
  }
  ASN1Set certificates=null;
  final ASN1Set certificatesSigned=sd.getCertificates();
  final ASN1EncodableVector vCertsSig=new ASN1EncodableVector();
  final Enumeration<?> certs=certificatesSigned.getObjects();
  while (certs.hasMoreElements()) {
    vCertsSig.add((DEREncodable)certs.nextElement());
  }
  if (signerCertificateChain.length != 0) {
    final List<DEREncodable> ce=new ArrayList<DEREncodable>();
    for (    final X509Certificate element : signerCertificateChain) {
      ce.add(X509CertificateStructure.getInstance(ASN1Object.fromByteArray(element.getEncoded())));
    }
    certificates=SigUtils.fillRestCerts(ce,vCertsSig);
  }
  final String digestAlgorithm=AOSignConstants.getDigestAlgorithmName(signatureAlgorithm);
  final AlgorithmIdentifier digAlgId=SigUtils.makeAlgId(AOAlgorithmID.getOID(digestAlgorithm));
  final TBSCertificateStructure tbs=TBSCertificateStructure.getInstance(ASN1Object.fromByteArray(signerCertificateChain[0].getTBSCertificate()));
  final IssuerAndSerialNumber encSid=new IssuerAndSerialNumber(X500Name.getInstance(tbs.getIssuer()),tbs.getSerialNumber().getValue());
  final SignerIdentifier identifier=new SignerIdentifier(encSid);
  final AlgorithmIdentifier encAlgId=SigUtils.makeAlgId(AOAlgorithmID.getOID(""String_Node_Str""));
  final ASN1Set signerInfosSd=sd.getSignerInfos();
  final ASN1EncodableVector signerInfos=new ASN1EncodableVector();
  byte[] messageDigest=md.clone();
  for (int i=0; i < signerInfosSd.size(); i++) {
    final SignerInfo si=new SignerInfo((ASN1Sequence)signerInfosSd.getObjectAt(i));
    final AlgorithmIdentifier algHash=si.getDigestAlgorithm();
    if (algHash.getAlgorithm().toString().equals(AOAlgorithmID.getOID(digestAlgorithm))) {
      final ASN1Set signedAttrib=si.getAuthenticatedAttributes();
      for (int s=0; s < signedAttrib.size(); s++) {
        final ASN1Sequence elemento=(ASN1Sequence)signedAttrib.getObjectAt(s);
        final DERObjectIdentifier oids=(DERObjectIdentifier)elemento.getObjectAt(0);
        if (CMSAttributes.messageDigest.getId().toString().equals(oids.toString())) {
          final DERSet derSetHash=(DERSet)elemento.getObjectAt(1);
          final DEROctetString derHash=(DEROctetString)derSetHash.getObjectAt(0);
          messageDigest=derHash.getOctets();
        }
      }
    }
    signerInfos.add(si);
  }
  ASN1Set signedAttr;
  if (contenidoDatos != null) {
    final ASN1EncodableVector contextExpecific=CAdESUtils.generateSignerInfo(signerCertificateChain[0],digestAlgorithm,contenidoDatos,policy,signingCertificateV2,null,new Date());
    this.signedAttr2=SigUtils.getAttributeSet(new AttributeTable(contextExpecific));
    signedAttr=SigUtils.getAttributeSet(new AttributeTable(contextExpecific));
  }
 else   if (messageDigest != null) {
    final ASN1EncodableVector contextExpecific=CAdESUtils.generateSignerInfo(signerCertificateChain[0],digestAlgorithm,null,policy,signingCertificateV2,messageDigest,new Date());
    this.signedAttr2=SigUtils.getAttributeSet(new AttributeTable(contextExpecific));
    signedAttr=SigUtils.getAttributeSet(new AttributeTable(contextExpecific));
  }
 else {
    throw new IllegalStateException(""String_Node_Str"");
  }
  final ASN1OctetString sign2;
  try {
    sign2=firma(signatureAlgorithm,keyEntry);
  }
 catch (  final AOException ex) {
    throw new IOException(""String_Node_Str"" + ex);
  }
  signerInfos.add(new SignerInfo(identifier,digAlgId,signedAttr,encAlgId,sign2,null));
  return new ContentInfo(PKCSObjectIdentifiers.signedData,new SignedData(sd.getDigestAlgorithms(),encInfo,certificates,null,new DERSet(signerInfos))).getDEREncoded();
}","/** 
 * Constructor de la clase. Se crea una cofirma a partir de los datos del firmante y del archivo que contiene las firmas.
 * @param signatureAlgorithm Algoritmo para la firma
 * @param signerCertificateChain Cadena de certificados para la construccion de los parametrosde firma.
 * @param data Archivo que contiene las firmas.
 * @param policy Pol&iacute;tica de firma
 * @param signingCertificateV2 <code>true</code> si se desea usar la versi&oacute;n 2 del atributo <i>Signing Certificate</i> <code>false</code> para usar la versi&oacute;n 1
 * @param keyEntry Clave privada usada para firmar.
 * @param md Huella digital espec&iacute;fica para una firma.
 * @return El archivo de firmas con la nueva firma.
 * @throws java.io.IOException Si ocurre alg&uacute;n problema leyendo o escribiendo los datos
 * @throws java.security.NoSuchAlgorithmException Si no se soporta alguno de los algoritmos de firma o huella digital
 * @throws java.security.cert.CertificateException Si se produce alguna excepci&oacute;n con los certificados de firma.
 * @throws javax.security.cert.CertificateException 
 */
byte[] coSigner(final String signatureAlgorithm,final X509Certificate[] signerCertificateChain,final InputStream data,final AdESPolicy policy,final boolean signingCertificateV2,final PrivateKeyEntry keyEntry,final byte[] md) throws IOException, NoSuchAlgorithmException, CertificateException {
  final ASN1InputStream is=new ASN1InputStream(data);
  final ASN1Sequence dsq=(ASN1Sequence)is.readObject();
  final Enumeration<?> e=dsq.getObjects();
  e.nextElement();
  final ASN1TaggedObject doj=(ASN1TaggedObject)e.nextElement();
  final ASN1Sequence contentSignedData=(ASN1Sequence)doj.getObject();
  final SignedData sd=new SignedData(contentSignedData);
  final ContentInfo encInfo=sd.getEncapContentInfo();
  final DEROctetString contenido=(DEROctetString)encInfo.getContent();
  byte[] contenidoDatos=null;
  if (contenido != null) {
    contenidoDatos=AOUtil.getDataFromInputStream(contenido.getOctetStream());
  }
  ASN1Set certificates=null;
  final ASN1Set certificatesSigned=sd.getCertificates();
  final ASN1EncodableVector vCertsSig=new ASN1EncodableVector();
  final Enumeration<?> certs=certificatesSigned.getObjects();
  while (certs.hasMoreElements()) {
    vCertsSig.add((DEREncodable)certs.nextElement());
  }
  if (signerCertificateChain.length != 0) {
    final List<DEREncodable> ce=new ArrayList<DEREncodable>();
    for (    final X509Certificate element : signerCertificateChain) {
      ce.add(X509CertificateStructure.getInstance(ASN1Object.fromByteArray(element.getEncoded())));
    }
    certificates=SigUtils.fillRestCerts(ce,vCertsSig);
  }
  final String digestAlgorithm=AOSignConstants.getDigestAlgorithmName(signatureAlgorithm);
  final AlgorithmIdentifier digAlgId=SigUtils.makeAlgId(AOAlgorithmID.getOID(digestAlgorithm));
  final TBSCertificateStructure tbs=TBSCertificateStructure.getInstance(ASN1Object.fromByteArray(signerCertificateChain[0].getTBSCertificate()));
  final IssuerAndSerialNumber encSid=new IssuerAndSerialNumber(X500Name.getInstance(tbs.getIssuer()),tbs.getSerialNumber().getValue());
  final SignerIdentifier identifier=new SignerIdentifier(encSid);
  final AlgorithmIdentifier encAlgId=SigUtils.makeAlgId(AOAlgorithmID.getOID(""String_Node_Str""));
  final ASN1Set signerInfosSd=sd.getSignerInfos();
  final ASN1EncodableVector signerInfos=new ASN1EncodableVector();
  byte[] messageDigest=md != null ? md.clone() : null;
  for (int i=0; i < signerInfosSd.size(); i++) {
    final SignerInfo si=new SignerInfo((ASN1Sequence)signerInfosSd.getObjectAt(i));
    final AlgorithmIdentifier algHash=si.getDigestAlgorithm();
    if (algHash.getAlgorithm().toString().equals(AOAlgorithmID.getOID(digestAlgorithm))) {
      final ASN1Set signedAttrib=si.getAuthenticatedAttributes();
      for (int s=0; s < signedAttrib.size(); s++) {
        final ASN1Sequence elemento=(ASN1Sequence)signedAttrib.getObjectAt(s);
        final DERObjectIdentifier oids=(DERObjectIdentifier)elemento.getObjectAt(0);
        if (CMSAttributes.messageDigest.getId().toString().equals(oids.toString())) {
          final DERSet derSetHash=(DERSet)elemento.getObjectAt(1);
          final DEROctetString derHash=(DEROctetString)derSetHash.getObjectAt(0);
          messageDigest=derHash.getOctets();
        }
      }
    }
    signerInfos.add(si);
  }
  ASN1Set signedAttr;
  if (contenidoDatos != null) {
    final ASN1EncodableVector contextExpecific=CAdESUtils.generateSignerInfo(signerCertificateChain[0],digestAlgorithm,contenidoDatos,policy,signingCertificateV2,null,new Date());
    this.signedAttr2=SigUtils.getAttributeSet(new AttributeTable(contextExpecific));
    signedAttr=SigUtils.getAttributeSet(new AttributeTable(contextExpecific));
  }
 else   if (messageDigest != null) {
    final ASN1EncodableVector contextExpecific=CAdESUtils.generateSignerInfo(signerCertificateChain[0],digestAlgorithm,null,policy,signingCertificateV2,messageDigest,new Date());
    this.signedAttr2=SigUtils.getAttributeSet(new AttributeTable(contextExpecific));
    signedAttr=SigUtils.getAttributeSet(new AttributeTable(contextExpecific));
  }
 else {
    throw new IllegalStateException(""String_Node_Str"");
  }
  final ASN1OctetString sign2;
  try {
    sign2=firma(signatureAlgorithm,keyEntry);
  }
 catch (  final AOException ex) {
    throw new IOException(""String_Node_Str"" + ex);
  }
  signerInfos.add(new SignerInfo(identifier,digAlgId,signedAttr,encAlgId,sign2,null));
  return new ContentInfo(PKCSObjectIdentifiers.signedData,new SignedData(sd.getDigestAlgorithms(),encInfo,certificates,null,new DERSet(signerInfos))).getDEREncoded();
}",0.9968203497615262
80248,"static byte[] postSign(final String digestAlgorithmName,final byte[] content,final X509Certificate[] signerCertificateChain,final String policyIdentifier,final String policyQualifier,final boolean signingCertificateV2,final byte[] messageDigest,final byte[] signature) throws AOException {
  if (signerCertificateChain == null || signerCertificateChain.length == 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  final TBSCertificateStructure tbsCertificateStructure;
  try {
    tbsCertificateStructure=TBSCertificateStructure.getInstance(ASN1Object.fromByteArray(signerCertificateChain[0].getTBSCertificate()));
  }
 catch (  final Exception e) {
    throw new AOException(""String_Node_Str"",e);
  }
  final SignerIdentifier signerIdentifier=new SignerIdentifier(new IssuerAndSerialNumber(X500Name.getInstance(tbsCertificateStructure.getIssuer()),tbsCertificateStructure.getSerialNumber().getValue()));
  final AlgorithmIdentifier digestAlgorithmOID;
  try {
    digestAlgorithmOID=SigUtils.makeAlgId(AOAlgorithmID.getOID(digestAlgorithmName));
  }
 catch (  final Exception e) {
    throw new AOException(""String_Node_Str"",e);
  }
  final AlgorithmIdentifier keyAlgorithmIdentifier;
  try {
    keyAlgorithmIdentifier=SigUtils.makeAlgId(AOAlgorithmID.getOID(""String_Node_Str""));
  }
 catch (  final Exception e) {
    throw new AOException(""String_Node_Str"",e);
  }
  final ASN1OctetString encodedPKCS1Signature=new DEROctetString(signature);
  final ASN1Set signedAttributes;
  try {
    signedAttributes=SigUtils.getAttributeSet(new AttributeTable(CAdESUtils.generateSignerInfo(signerCertificateChain[0],digestAlgorithmName,content,policyIdentifier,policyQualifier,signingCertificateV2,messageDigest)));
  }
 catch (  Exception e) {
    throw new AOException(""String_Node_Str"",e);
  }
  final ASN1EncodableVector signerInfo=new ASN1EncodableVector();
  signerInfo.add(new SignerInfo(signerIdentifier,digestAlgorithmOID,signedAttributes,keyAlgorithmIdentifier,encodedPKCS1Signature,null));
  final ContentInfo contentInfo;
  if (content != null) {
    final ByteArrayOutputStream baos=new ByteArrayOutputStream();
    final CMSProcessable msg=new CMSProcessableByteArray(content);
    try {
      msg.write(baos);
    }
 catch (    final Exception e) {
      throw new AOException(""String_Node_Str"",e);
    }
    contentInfo=new ContentInfo(new ASN1ObjectIdentifier(PKCSObjectIdentifiers.data.getId()),new BERConstructedOctetString(baos.toByteArray()));
  }
 else {
    contentInfo=new ContentInfo(new ASN1ObjectIdentifier(PKCSObjectIdentifiers.data.getId()),null);
  }
  final List<DEREncodable> ce=new ArrayList<DEREncodable>();
  for (  final X509Certificate cert : signerCertificateChain) {
    try {
      ce.add(X509CertificateStructure.getInstance(ASN1Object.fromByteArray(cert.getEncoded())));
    }
 catch (    final Exception e) {
      Logger.getLogger(""String_Node_Str"").severe(""String_Node_Str"" + AOUtil.getCN(cert) + ""String_Node_Str"");
    }
  }
  final ASN1Set certificates=SigUtils.createBerSetFromList(ce);
  final ASN1EncodableVector digestAlgorithms=new ASN1EncodableVector();
  digestAlgorithms.add(digestAlgorithmOID);
  return new ContentInfo(PKCSObjectIdentifiers.signedData,new SignedData(new DERSet(digestAlgorithms),contentInfo,certificates,null,new DERSet(signerInfo))).getDEREncoded();
}","static byte[] postSign(final String digestAlgorithmName,final byte[] content,final X509Certificate[] signerCertificateChain,final byte[] signature,final byte[] signedAttributes) throws AOException {
  if (signerCertificateChain == null || signerCertificateChain.length == 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  final TBSCertificateStructure tbsCertificateStructure;
  try {
    tbsCertificateStructure=TBSCertificateStructure.getInstance(ASN1Object.fromByteArray(signerCertificateChain[0].getTBSCertificate()));
  }
 catch (  final Exception e) {
    throw new AOException(""String_Node_Str"",e);
  }
  final SignerIdentifier signerIdentifier=new SignerIdentifier(new IssuerAndSerialNumber(X500Name.getInstance(tbsCertificateStructure.getIssuer()),tbsCertificateStructure.getSerialNumber().getValue()));
  final AlgorithmIdentifier digestAlgorithmOID;
  try {
    digestAlgorithmOID=SigUtils.makeAlgId(AOAlgorithmID.getOID(digestAlgorithmName));
  }
 catch (  final Exception e) {
    throw new AOException(""String_Node_Str"",e);
  }
  final AlgorithmIdentifier keyAlgorithmIdentifier;
  try {
    keyAlgorithmIdentifier=SigUtils.makeAlgId(AOAlgorithmID.getOID(""String_Node_Str""));
  }
 catch (  final Exception e) {
    throw new AOException(""String_Node_Str"",e);
  }
  final ASN1OctetString encodedPKCS1Signature=new DEROctetString(signature);
  final ASN1Set asn1SignedAttributes;
  try {
    asn1SignedAttributes=(ASN1Set)ASN1Object.fromByteArray(signedAttributes);
  }
 catch (  IOException e) {
    throw new AOException(""String_Node_Str"",e);
  }
  final ASN1EncodableVector signerInfo=new ASN1EncodableVector();
  signerInfo.add(new SignerInfo(signerIdentifier,digestAlgorithmOID,asn1SignedAttributes,keyAlgorithmIdentifier,encodedPKCS1Signature,null));
  final ContentInfo contentInfo;
  if (content != null) {
    final ByteArrayOutputStream baos=new ByteArrayOutputStream();
    final CMSProcessable msg=new CMSProcessableByteArray(content);
    try {
      msg.write(baos);
    }
 catch (    final Exception e) {
      throw new AOException(""String_Node_Str"",e);
    }
    contentInfo=new ContentInfo(new ASN1ObjectIdentifier(PKCSObjectIdentifiers.data.getId()),new BERConstructedOctetString(baos.toByteArray()));
  }
 else {
    contentInfo=new ContentInfo(new ASN1ObjectIdentifier(PKCSObjectIdentifiers.data.getId()),null);
  }
  final List<DEREncodable> ce=new ArrayList<DEREncodable>();
  for (  final X509Certificate cert : signerCertificateChain) {
    try {
      ce.add(X509CertificateStructure.getInstance(ASN1Object.fromByteArray(cert.getEncoded())));
    }
 catch (    final Exception e) {
      Logger.getLogger(""String_Node_Str"").severe(""String_Node_Str"" + AOUtil.getCN(cert) + ""String_Node_Str"");
    }
  }
  final ASN1Set certificates=SigUtils.createBerSetFromList(ce);
  final ASN1EncodableVector digestAlgorithms=new ASN1EncodableVector();
  digestAlgorithms.add(digestAlgorithmOID);
  return new ContentInfo(PKCSObjectIdentifiers.signedData,new SignedData(new DERSet(digestAlgorithms),contentInfo,certificates,null,new DERSet(signerInfo))).getDEREncoded();
}",0.9299659126123334
80249,"/** 
 * M&eacute;todo que genera la parte que contiene la informaci&oacute;n del Usuario. Se generan los atributos que se necesitan para generar la firma.
 * @param cert Certificado de firma.
 * @param digestAlgorithmName Algoritmo Firmado.
 * @param digestAlgorithmOID
 * @param datos Datos firmados.
 * @param policyIdentifier
 * @param policyQualifier
 * @param signingCertificateV2
 * @param dataType Identifica el tipo del contenido a firmar.
 * @param messageDigest
 * @return Los datos necesarios para generar la firma referente a los datosdel usuario.
 * @throws java.security.NoSuchAlgorithmException
 * @throws java.io.IOException
 * @throws CertificateEncodingException 
 */
static ASN1EncodableVector generateSignerInfo(final X509Certificate cert,final String digestAlgorithmName,final byte[] datos,final String policyIdentifier,final String policyQualifier,final boolean signingCertificateV2,final byte[] messageDigest) throws NoSuchAlgorithmException, IOException, CertificateEncodingException {
  final AlgorithmIdentifier digestAlgorithmOID;
  try {
    digestAlgorithmOID=SigUtils.makeAlgId(AOAlgorithmID.getOID(digestAlgorithmName));
  }
 catch (  final Exception e) {
    throw new IOException(""String_Node_Str"" + e);
  }
  final ASN1EncodableVector ContexExpecific=initContexExpecific(digestAlgorithmName,datos,PKCSObjectIdentifiers.data.getId(),messageDigest);
  ContexExpecific.add(new Attribute(RFC4519Style.serialNumber,new DERSet(new DERPrintableString(cert.getSerialNumber().toString()))));
  if (signingCertificateV2) {
    final TBSCertificateStructure tbs=TBSCertificateStructure.getInstance(ASN1Object.fromByteArray(cert.getTBSCertificate()));
    final GeneralName gn=new GeneralName(tbs.getIssuer());
    final GeneralNames gns=new GeneralNames(gn);
    final IssuerSerial isuerSerial=new IssuerSerial(gns,tbs.getSerialNumber());
    final MessageDigest md=MessageDigest.getInstance(digestAlgorithmName);
    final byte[] certHash=md.digest(cert.getEncoded());
    final ESSCertIDv2[] essCertIDv2={new ESSCertIDv2(digestAlgorithmOID,certHash,isuerSerial)};
    PolicyInformation[] pI;
    SigningCertificateV2 scv2=null;
    if (policyQualifier != null) {
      final DERObjectIdentifier oidQualifier=new DERObjectIdentifier(policyQualifier.toString());
      if (policyIdentifier.equals(""String_Node_Str"")) {
        pI=new PolicyInformation[]{new PolicyInformation(oidQualifier)};
      }
 else {
        final PolicyQualifierInfo pqInfo=new PolicyQualifierInfo(policyIdentifier);
        pI=new PolicyInformation[]{new PolicyInformation(oidQualifier,new DERSequence(pqInfo))};
      }
      scv2=new SigningCertificateV2(essCertIDv2,pI);
    }
 else {
      scv2=new SigningCertificateV2(essCertIDv2);
    }
    ContexExpecific.add(new Attribute(PKCSObjectIdentifiers.id_aa_signingCertificateV2,new DERSet(scv2)));
  }
 else {
    final TBSCertificateStructure tbs=TBSCertificateStructure.getInstance(ASN1Object.fromByteArray(cert.getTBSCertificate()));
    final GeneralName gn=new GeneralName(tbs.getIssuer());
    final GeneralNames gns=new GeneralNames(gn);
    final IssuerSerial isuerSerial=new IssuerSerial(gns,tbs.getSerialNumber());
    final MessageDigest md=MessageDigest.getInstance(digestAlgorithmName);
    final byte[] certHash=md.digest(cert.getEncoded());
    final ESSCertID essCertID=new ESSCertID(certHash,isuerSerial);
    PolicyInformation[] pI;
    SigningCertificate scv=null;
    if (policyQualifier != null) {
      final DERObjectIdentifier oidQualifier=new DERObjectIdentifier(policyQualifier.toString());
      if (policyIdentifier.equals(""String_Node_Str"")) {
        pI=new PolicyInformation[]{new PolicyInformation(oidQualifier)};
      }
 else {
        final PolicyQualifierInfo pqInfo=new PolicyQualifierInfo(policyIdentifier);
        pI=new PolicyInformation[]{new PolicyInformation(oidQualifier,new DERSequence(pqInfo))};
      }
      final ASN1EncodableVector v=new ASN1EncodableVector();
      v.add(new DERSequence(essCertID));
      v.add(new DERSequence(pI));
      scv=new SigningCertificate(new DERSequence(v));
    }
 else {
      scv=new SigningCertificate(essCertID);
    }
    ContexExpecific.add(new Attribute(PKCSObjectIdentifiers.id_aa_signingCertificate,new DERSet(scv)));
  }
  if (policyQualifier != null) {
    final DERObjectIdentifier DOISigPolicyId=new DERObjectIdentifier(policyQualifier.toString());
    final MessageDigest mdgest=MessageDigest.getInstance(digestAlgorithmName);
    final byte[] hashed=mdgest.digest(policyIdentifier.getBytes());
    final DigestInfo OtherHashAlgAndValue=new DigestInfo(digestAlgorithmOID,hashed);
    final SigPolicyQualifierInfo spqInfo=new SigPolicyQualifierInfo(policyIdentifier);
    final ASN1EncodableVector v=new ASN1EncodableVector();
    v.add(DOISigPolicyId);
    v.add(OtherHashAlgAndValue.toASN1Object());
    v.add(spqInfo.toASN1Object());
    final DERSequence ds=new DERSequence(v);
    ContexExpecific.add(new Attribute(PKCSObjectIdentifiers.id_aa_ets_sigPolicyId,new DERSet(ds.toASN1Object())));
  }
  return ContexExpecific;
}","/** 
 * M&eacute;todo que genera la parte que contiene la informaci&oacute;n del Usuario. Se generan los atributos que se necesitan para generar la firma.
 * @param cert Certificado de firma.
 * @param digestAlgorithmName Algoritmo Firmado.
 * @param digestAlgorithmOID
 * @param datos Datos firmados.
 * @param policyIdentifier
 * @param policyQualifier
 * @param signingCertificateV2
 * @param dataType Identifica el tipo del contenido a firmar.
 * @param messageDigest
 * @return Los datos necesarios para generar la firma referente a los datosdel usuario.
 * @throws java.security.NoSuchAlgorithmException
 * @throws java.io.IOException
 * @throws CertificateEncodingException 
 */
static ASN1EncodableVector generateSignerInfo(final X509Certificate cert,final String digestAlgorithmName,final byte[] datos,final String policyIdentifier,final String policyQualifier,final boolean signingCertificateV2,final byte[] messageDigest) throws NoSuchAlgorithmException, IOException, CertificateEncodingException {
  final AlgorithmIdentifier digestAlgorithmOID;
  try {
    digestAlgorithmOID=SigUtils.makeAlgId(AOAlgorithmID.getOID(digestAlgorithmName));
  }
 catch (  final Exception e) {
    throw new IOException(""String_Node_Str"" + e);
  }
  final ASN1EncodableVector contexExpecific=initContexExpecific(digestAlgorithmName,datos,PKCSObjectIdentifiers.data.getId(),messageDigest);
  contexExpecific.add(new Attribute(RFC4519Style.serialNumber,new DERSet(new DERPrintableString(cert.getSerialNumber().toString()))));
  if (signingCertificateV2) {
    final TBSCertificateStructure tbs=TBSCertificateStructure.getInstance(ASN1Object.fromByteArray(cert.getTBSCertificate()));
    final GeneralName gn=new GeneralName(tbs.getIssuer());
    final GeneralNames gns=new GeneralNames(gn);
    final IssuerSerial isuerSerial=new IssuerSerial(gns,tbs.getSerialNumber());
    final MessageDigest md=MessageDigest.getInstance(digestAlgorithmName);
    final byte[] certHash=md.digest(cert.getEncoded());
    final ESSCertIDv2[] essCertIDv2={new ESSCertIDv2(digestAlgorithmOID,certHash,isuerSerial)};
    PolicyInformation[] pI;
    SigningCertificateV2 scv2=null;
    if (policyQualifier != null) {
      final DERObjectIdentifier oidQualifier=new DERObjectIdentifier(policyQualifier.toString());
      if (policyIdentifier.equals(""String_Node_Str"")) {
        pI=new PolicyInformation[]{new PolicyInformation(oidQualifier)};
      }
 else {
        final PolicyQualifierInfo pqInfo=new PolicyQualifierInfo(policyIdentifier);
        pI=new PolicyInformation[]{new PolicyInformation(oidQualifier,new DERSequence(pqInfo))};
      }
      scv2=new SigningCertificateV2(essCertIDv2,pI);
    }
 else {
      scv2=new SigningCertificateV2(essCertIDv2);
    }
    contexExpecific.add(new Attribute(PKCSObjectIdentifiers.id_aa_signingCertificateV2,new DERSet(scv2)));
  }
 else {
    final TBSCertificateStructure tbs=TBSCertificateStructure.getInstance(ASN1Object.fromByteArray(cert.getTBSCertificate()));
    final GeneralName gn=new GeneralName(tbs.getIssuer());
    final GeneralNames gns=new GeneralNames(gn);
    final IssuerSerial isuerSerial=new IssuerSerial(gns,tbs.getSerialNumber());
    final MessageDigest md=MessageDigest.getInstance(digestAlgorithmName);
    final byte[] certHash=md.digest(cert.getEncoded());
    final ESSCertID essCertID=new ESSCertID(certHash,isuerSerial);
    PolicyInformation[] pI;
    SigningCertificate scv=null;
    if (policyQualifier != null) {
      final DERObjectIdentifier oidQualifier=new DERObjectIdentifier(policyQualifier.toString());
      if (policyIdentifier.equals(""String_Node_Str"")) {
        pI=new PolicyInformation[]{new PolicyInformation(oidQualifier)};
      }
 else {
        final PolicyQualifierInfo pqInfo=new PolicyQualifierInfo(policyIdentifier);
        pI=new PolicyInformation[]{new PolicyInformation(oidQualifier,new DERSequence(pqInfo))};
      }
      final ASN1EncodableVector v=new ASN1EncodableVector();
      v.add(new DERSequence(essCertID));
      v.add(new DERSequence(pI));
      scv=new SigningCertificate(new DERSequence(v));
    }
 else {
      scv=new SigningCertificate(essCertID);
    }
    contexExpecific.add(new Attribute(PKCSObjectIdentifiers.id_aa_signingCertificate,new DERSet(scv)));
  }
  if (policyQualifier != null) {
    final DERObjectIdentifier DOISigPolicyId=new DERObjectIdentifier(policyQualifier.toString());
    final MessageDigest mdgest=MessageDigest.getInstance(digestAlgorithmName);
    final byte[] hashed=mdgest.digest(policyIdentifier.getBytes());
    final DigestInfo OtherHashAlgAndValue=new DigestInfo(digestAlgorithmOID,hashed);
    final SigPolicyQualifierInfo spqInfo=new SigPolicyQualifierInfo(policyIdentifier);
    final ASN1EncodableVector v=new ASN1EncodableVector();
    v.add(DOISigPolicyId);
    v.add(OtherHashAlgAndValue.toASN1Object());
    v.add(spqInfo.toASN1Object());
    final DERSequence ds=new DERSequence(v);
    contexExpecific.add(new Attribute(PKCSObjectIdentifiers.id_aa_ets_sigPolicyId,new DERSet(ds.toASN1Object())));
  }
  return contexExpecific;
}",0.9988179669030732
80250,"/** 
 * M&eacute;odo que genera una firma digital usando el sitema conocido como SignedData y que podr&aacute; ser con el contenido del fichero codificado o s&oacute;lo como referencia del fichero.
 * @param parameters Par&aacute;metros necesarios para obtener los datos de SignedData.
 * @param omitContent Par&aacute;metro qeu indica si en la firma va el contenido del fichero o s&oacute;lo va de forma referenciada.
 * @param policyIdentifier Url de la Politica aplicada.
 * @param policyQualifier OID de la pol&iacute;tica.
 * @param signingCertificateV2 <code>true</code> si se desea usar la versi&oacute;n 2 del atributo <i>Signing Certificate</i> <code>false</code> para usar la versi&oacute;n 1
 * @param keyEntry Entrada a la clave privada para firma.
 * @param messageDigest Hash a aplicar en la firma.
 * @return La firma generada codificada.
 * @throws java.security.NoSuchAlgorithmException Si no se soporta alguno de los algoritmos de firma o huella digital
 * @throws java.security.cert.CertificateException Si se produce alguna excepci&oacute;n con los certificados de firma.
 * @throws java.io.IOException Si ocurre alg&uacute;n problema leyendo o escribiendo los datos
 * @throws AOException Cuando ocurre un error durante el proceso de descifrado (formato o clave incorrecto,...) 
 */
public byte[] generateSignedData(final P7ContentSignerParameters parameters,final boolean omitContent,final String policyIdentifier,final String policyQualifier,final boolean signingCertificateV2,final PrivateKeyEntry keyEntry,byte[] messageDigest) throws NoSuchAlgorithmException, CertificateException, IOException, AOException {
  if (parameters == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  final String signatureAlgorithm=parameters.getSignatureAlgorithm();
  final X509Certificate[] signerCertificateChain=parameters.getSignerCertificateChain();
  final byte[] content=(omitContent) ? null : parameters.getContent();
  if (omitContent && messageDigest == null && parameters.getContent() != null) {
    final MessageDigest md=MessageDigest.getInstance(AOSignConstants.getDigestAlgorithmName(signatureAlgorithm));
    md.update(parameters.getContent());
    messageDigest=md.digest();
  }
  final byte[] preSignature=CAdESTriPhaseSigner.preSign(AOSignConstants.getDigestAlgorithmName(signatureAlgorithm),content,signerCertificateChain,policyIdentifier,policyQualifier,signingCertificateV2,messageDigest);
  final byte[] signature=PKCS1ExternalizableSigner.sign(signatureAlgorithm,keyEntry,preSignature);
  return CAdESTriPhaseSigner.postSign(AOSignConstants.getDigestAlgorithmName(signatureAlgorithm),content,signerCertificateChain,policyIdentifier,policyQualifier,signingCertificateV2,messageDigest,signature);
}","/** 
 * M&eacute;odo que genera una firma digital usando el sitema conocido como SignedData y que podr&aacute; ser con el contenido del fichero codificado o s&oacute;lo como referencia del fichero.
 * @param parameters Par&aacute;metros necesarios para obtener los datos de SignedData.
 * @param omitContent Par&aacute;metro qeu indica si en la firma va el contenido del fichero o s&oacute;lo va de forma referenciada.
 * @param policyIdentifier Url de la Politica aplicada.
 * @param policyQualifier OID de la pol&iacute;tica.
 * @param signingCertificateV2 <code>true</code> si se desea usar la versi&oacute;n 2 del atributo <i>Signing Certificate</i> <code>false</code> para usar la versi&oacute;n 1
 * @param keyEntry Entrada a la clave privada para firma.
 * @param messageDigest Hash a aplicar en la firma.
 * @return La firma generada codificada.
 * @throws java.security.NoSuchAlgorithmException Si no se soporta alguno de los algoritmos de firma o huella digital
 * @throws java.security.cert.CertificateException Si se produce alguna excepci&oacute;n con los certificados de firma.
 * @throws java.io.IOException Si ocurre alg&uacute;n problema leyendo o escribiendo los datos
 * @throws AOException Cuando ocurre un error durante el proceso de descifrado (formato o clave incorrecto,...) 
 */
public byte[] generateSignedData(final P7ContentSignerParameters parameters,final boolean omitContent,final String policyIdentifier,final String policyQualifier,final boolean signingCertificateV2,final PrivateKeyEntry keyEntry,byte[] messageDigest) throws NoSuchAlgorithmException, CertificateException, IOException, AOException {
  if (parameters == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  final String signatureAlgorithm=parameters.getSignatureAlgorithm();
  final X509Certificate[] signerCertificateChain=parameters.getSignerCertificateChain();
  final byte[] content=(omitContent) ? null : parameters.getContent();
  if (messageDigest == null && parameters.getContent() != null) {
    final MessageDigest md=MessageDigest.getInstance(AOSignConstants.getDigestAlgorithmName(signatureAlgorithm));
    md.update(parameters.getContent());
    messageDigest=md.digest();
  }
  final byte[] preSignature=CAdESTriPhaseSigner.preSign(AOSignConstants.getDigestAlgorithmName(signatureAlgorithm),content,signerCertificateChain,policyIdentifier,policyQualifier,signingCertificateV2,messageDigest);
  final byte[] signature=PKCS1ExternalizableSigner.sign(signatureAlgorithm,keyEntry,preSignature);
  return CAdESTriPhaseSigner.postSign(AOSignConstants.getDigestAlgorithmName(signatureAlgorithm),content,signerCertificateChain,signature,preSignature);
}",0.9826887661141804
80251,"/** 
 * Anade un destinatario del origen seleccionado en el combo
 * @param listaModel Modelo de la lista de destinatarios
 */
private void anadirActionPerformed(JComboBox comboDestinatarios,DefaultListModel listaModel,JButton eliminar){
  AOKeyStoreManager keyStoreManager=null;
  KeyStoreConfiguration kc=(KeyStoreConfiguration)comboDestinatarios.getSelectedItem();
  try {
    AOKeyStore ao=kc.getType();
    keyStoreManager=AOKeyStoreManagerFactory.getAOKeyStoreManager(ao,null,null,getPreferredPCB(ao),this);
  }
 catch (  AOCancelledOperationException e) {
    logger.severe(""String_Node_Str"");
    return;
  }
catch (  Exception e) {
    e.printStackTrace();
    logger.severe(""String_Node_Str"" + e);
    JOptionPane.showMessageDialog(this,Messages.getString(""String_Node_Str""),Messages.getString(""String_Node_Str""),JOptionPane.ERROR_MESSAGE);
    return;
  }
  CertificateDestiny certDest=new CertificateDestiny(keyStoreManager,this);
  if (certDest.getAlias() != null && !certDest.equals(""String_Node_Str"")) {
    boolean copiar=true;
    for (int i=0; i < listaModel.getSize(); i++) {
      CertificateDestiny c=(CertificateDestiny)listaModel.getElementAt(i);
      if (certDest.getAlias().equals(c.getAlias())) {
        copiar=false;
      }
    }
    if (copiar) {
      listaModel.addElement(certDest.getAlias());
      listaCertificados.add(certDest);
      eliminar.setEnabled(true);
    }
 else     JOptionPane.showMessageDialog(this,Messages.getString(""String_Node_Str""),Messages.getString(""String_Node_Str""),JOptionPane.WARNING_MESSAGE);
  }
}","/** 
 * Anade un destinatario del origen seleccionado en el combo
 * @param listaModel Modelo de la lista de destinatarios
 */
private void anadirActionPerformed(JComboBox comboDestinatarios,DefaultListModel listaModel,JButton eliminar){
  AOKeyStoreManager keyStoreManager=null;
  KeyStoreConfiguration kc=(KeyStoreConfiguration)comboDestinatarios.getSelectedItem();
  try {
    AOKeyStore ao=kc.getType();
    keyStoreManager=AOKeyStoreManagerFactory.getAOKeyStoreManager(ao,null,null,getPreferredPCB(ao),this);
  }
 catch (  AOCancelledOperationException e) {
    logger.severe(""String_Node_Str"");
    return;
  }
catch (  Exception e) {
    e.printStackTrace();
    logger.severe(""String_Node_Str"" + e);
    JOptionPane.showMessageDialog(this,Messages.getString(""String_Node_Str""),Messages.getString(""String_Node_Str""),JOptionPane.ERROR_MESSAGE);
    return;
  }
  CertificateDestiny certDest=new CertificateDestiny(keyStoreManager,this);
  if (certDest.getAlias() != null && !certDest.equals(""String_Node_Str"")) {
    boolean copiar=true;
    for (int i=0; i < listaModel.getSize(); i++) {
      if (certDest.getAlias().equals((String)listaModel.getElementAt(i))) {
        copiar=false;
      }
    }
    if (copiar) {
      listaModel.addElement(certDest.getAlias());
      listaCertificados.add(certDest);
      eliminar.setEnabled(true);
    }
 else     JOptionPane.showMessageDialog(this,Messages.getString(""String_Node_Str""),Messages.getString(""String_Node_Str""),JOptionPane.WARNING_MESSAGE);
  }
}",0.9625529143601432
80252,"private void loadDefaultKeyStore(){
  this.container.setCursor(new Cursor(Cursor.WAIT_CURSOR));
  try {
    new SimpleKeyStoreManagerWorker(this,null,false).execute();
  }
 catch (  final Exception e) {
    Logger.getLogger(""String_Node_Str"").severe(""String_Node_Str"" + e);
    JOptionPane.showOptionDialog(this.container,Messages.getString(""String_Node_Str""),Messages.getString(""String_Node_Str""),JOptionPane.CLOSED_OPTION,JOptionPane.ERROR_MESSAGE,null,new Object[]{Messages.getString(""String_Node_Str"")},null);
    closeApplication(-2);
  }
 finally {
    this.container.setCursor(new Cursor(Cursor.DEFAULT_CURSOR));
  }
}","private void loadDefaultKeyStore(){
  this.container.setCursor(new Cursor(Cursor.WAIT_CURSOR));
  try {
    new SimpleKeyStoreManagerWorker(this,null,false).execute();
  }
 catch (  final Exception e) {
    Logger.getLogger(""String_Node_Str"").severe(""String_Node_Str"" + e);
    UIUtils.showErrorMessage(this.container,Messages.getString(""String_Node_Str""),Messages.getString(""String_Node_Str""),JOptionPane.ERROR_MESSAGE);
    closeApplication(-2);
  }
 finally {
    this.container.setCursor(new Cursor(Cursor.DEFAULT_CURSOR));
  }
}",0.8877374784110535
80253,"@Override public void propertyChange(final PropertyChangeEvent evt){
  if (DNIeManager.BLOWN_DNI_INSERTED.equals(evt.getPropertyName())) {
    if (DEBUG)     System.out.println(""String_Node_Str"");
    loadDefaultKeyStore();
    loadMainApp(true);
    JOptionPane.showOptionDialog(this.container,Messages.getString(""String_Node_Str""),Messages.getString(""String_Node_Str""),JOptionPane.OK_OPTION,JOptionPane.ERROR_MESSAGE,null,new Object[]{Messages.getString(""String_Node_Str"")},null);
    return;
  }
 else   if (DNIeManager.CARD_EXCEPTION.equals(evt.getPropertyName())) {
    if (DEBUG)     System.out.println(""String_Node_Str"");
    try {
      new SimpleKeyStoreManagerWorker(this,null,false).execute();
    }
 catch (    final Exception e) {
      Logger.getLogger(""String_Node_Str"").severe(""String_Node_Str"" + e);
      JOptionPane.showOptionDialog(this.container,Messages.getString(""String_Node_Str""),Messages.getString(""String_Node_Str""),JOptionPane.OK_OPTION,JOptionPane.ERROR_MESSAGE,null,new Object[]{Messages.getString(""String_Node_Str"")},null);
      closeApplication(-1);
    }
    return;
  }
 else   if (DNIeManager.NOT_DNI_INSERTED.equals(evt.getPropertyName())) {
    if (DEBUG)     System.out.println(""String_Node_Str"");
    JOptionPane.showOptionDialog(this.container,Messages.getString(""String_Node_Str""),Messages.getString(""String_Node_Str""),JOptionPane.OK_OPTION,JOptionPane.WARNING_MESSAGE,null,new Object[]{Messages.getString(""String_Node_Str"")},null);
    return;
  }
 else   if (DNIeManager.DNI_INSERTED.equals(evt.getPropertyName())) {
    if (DEBUG)     System.out.println(""String_Node_Str"");
    this.container.setCursor(new Cursor(Cursor.WAIT_CURSOR));
    try {
      new SimpleKeyStoreManagerWorker(this,null,true).execute();
    }
 catch (    final Exception e) {
      Logger.getLogger(""String_Node_Str"").severe(""String_Node_Str"" + e);
      loadDefaultKeyStore();
    }
 finally {
      this.container.setCursor(new Cursor(Cursor.DEFAULT_CURSOR));
    }
    loadMainApp(true);
  }
}","@Override public void propertyChange(final PropertyChangeEvent evt){
  if (DNIeManager.BLOWN_DNI_INSERTED.equals(evt.getPropertyName())) {
    if (DEBUG)     System.out.println(""String_Node_Str"");
    loadDefaultKeyStore();
    loadMainApp(true);
    UIUtils.showErrorMessage(this.container,Messages.getString(""String_Node_Str""),Messages.getString(""String_Node_Str""),JOptionPane.ERROR_MESSAGE);
    return;
  }
 else   if (DNIeManager.CARD_EXCEPTION.equals(evt.getPropertyName())) {
    if (DEBUG)     System.out.println(""String_Node_Str"");
    UIUtils.showErrorMessage(this.container,""String_Node_Str"",Messages.getString(""String_Node_Str""),JOptionPane.WARNING_MESSAGE);
    return;
  }
 else   if (DNIeManager.NOT_DNI_INSERTED.equals(evt.getPropertyName())) {
    if (DEBUG)     System.out.println(""String_Node_Str"");
    UIUtils.showErrorMessage(this.container,Messages.getString(""String_Node_Str""),Messages.getString(""String_Node_Str""),JOptionPane.WARNING_MESSAGE);
    return;
  }
 else   if (DNIeManager.DNI_INSERTED.equals(evt.getPropertyName())) {
    if (DEBUG)     System.out.println(""String_Node_Str"");
    this.container.setCursor(new Cursor(Cursor.WAIT_CURSOR));
    try {
      new SimpleKeyStoreManagerWorker(this,null,true).execute();
    }
 catch (    final Exception e) {
      Logger.getLogger(""String_Node_Str"").severe(""String_Node_Str"" + e);
      loadDefaultKeyStore();
    }
 finally {
      this.container.setCursor(new Cursor(Cursor.DEFAULT_CURSOR));
    }
    loadMainApp(true);
  }
}",0.6566401816118048
80254,"/** 
 * Carga el fichero a firmar. Este m&eacute;todo se situa aqu&iacute; para permitir su acceso desde la barra de men&uacute;
 * @param filePath Fichero a firmar, incluyendo su ruta completa 
 */
public void loadFileToSign(final String filePath){
  if (this.currentPanel instanceof SignPanel) {
    try {
      ((SignPanel)this.currentPanel).loadFile(filePath);
    }
 catch (    final Exception e) {
      JOptionPane.showOptionDialog(this.currentPanel,Messages.getString(""String_Node_Str""),Messages.getString(""String_Node_Str""),JOptionPane.OK_OPTION,JOptionPane.ERROR_MESSAGE,null,new Object[]{Messages.getString(""String_Node_Str"")},null);
    }
  }
}","/** 
 * Carga el fichero a firmar. Este m&eacute;todo se situa aqu&iacute; para permitir su acceso desde la barra de men&uacute;
 * @param filePath Fichero a firmar, incluyendo su ruta completa 
 */
public void loadFileToSign(final String filePath){
  if (this.currentPanel instanceof SignPanel) {
    try {
      ((SignPanel)this.currentPanel).loadFile(filePath);
    }
 catch (    final Exception e) {
      UIUtils.showErrorMessage(this.currentPanel,Messages.getString(""String_Node_Str""),Messages.getString(""String_Node_Str""),JOptionPane.ERROR_MESSAGE);
    }
  }
}",0.8839869281045751
80255,"void startMonitoring(){
  if (this.cardTerminal == null)   return;
  Card card;
  while (true) {
    try {
      this.cardTerminal.waitForCardPresent(0);
      if (SimpleAfirma.DEBUG) {
        System.out.println(""String_Node_Str"" + this.cardTerminal.getName() + ""String_Node_Str"");
      }
      card=this.cardTerminal.connect(""String_Node_Str"");
    }
 catch (    final CardException e) {
      if (SimpleAfirma.DEBUG) {
        e.printStackTrace();
      }
      firePropertyChange(CARD_EXCEPTION,""String_Node_Str"",this.cardTerminal.getName());
      return;
    }
    try {
      if (!itsDNIe(card.getATR().getBytes())) {
        if (SimpleAfirma.DEBUG) {
          System.out.println(""String_Node_Str"");
        }
        firePropertyChange(NOT_DNI_INSERTED,""String_Node_Str"",this.cardTerminal.getName());
        try {
          this.cardTerminal.waitForCardAbsent(0);
        }
 catch (        final CardException e) {
          firePropertyChange(CARD_EXCEPTION,""String_Node_Str"",this.cardTerminal.getName());
          return;
        }
      }
 else {
        if (SimpleAfirma.DEBUG) {
          System.out.println(""String_Node_Str"");
        }
        firePropertyChange(DNI_INSERTED,""String_Node_Str"",this.cardTerminal.getName());
        return;
      }
    }
 catch (    final BlownDNIeException e) {
      firePropertyChange(""String_Node_Str"",false,true);
      return;
    }
  }
}","void startMonitoring(){
  if (this.cardTerminal == null)   return;
  Card card=null;
  boolean validCard=true;
  while (true) {
    do {
      try {
        this.cardTerminal.waitForCardPresent(0);
        if (SimpleAfirma.DEBUG) {
          System.out.println(""String_Node_Str"" + this.cardTerminal.getName() + ""String_Node_Str"");
        }
        card=this.cardTerminal.connect(""String_Node_Str"");
        validCard=true;
      }
 catch (      final CardException e) {
        if (SimpleAfirma.DEBUG) {
          e.printStackTrace();
        }
        validCard=false;
        firePropertyChange(CARD_EXCEPTION,""String_Node_Str"",this.cardTerminal.getName());
        try {
          this.cardTerminal.waitForCardAbsent(0);
        }
 catch (        final CardException e2) {
        }
      }
    }
 while (!validCard);
    try {
      if (!itsDNIe(card.getATR().getBytes())) {
        if (SimpleAfirma.DEBUG) {
          System.out.println(""String_Node_Str"");
        }
        firePropertyChange(NOT_DNI_INSERTED,""String_Node_Str"",this.cardTerminal.getName());
        try {
          this.cardTerminal.waitForCardAbsent(0);
        }
 catch (        final CardException e) {
          firePropertyChange(CARD_EXCEPTION,""String_Node_Str"",this.cardTerminal.getName());
          return;
        }
      }
 else {
        if (SimpleAfirma.DEBUG) {
          System.out.println(""String_Node_Str"");
        }
        firePropertyChange(DNI_INSERTED,""String_Node_Str"",this.cardTerminal.getName());
        return;
      }
    }
 catch (    final BlownDNIeException e) {
      firePropertyChange(""String_Node_Str"",false,true);
      return;
    }
  }
}",0.9113591595535128
80256,"/** 
 * Before inflating views
 */
private boolean beforeInflate(){
  if (mIntent == null) {
    return false;
  }
  mAction=mIntent.getAction();
  if (mAction == null) {
    Log.w(TAG,""String_Node_Str"");
    return false;
  }
  if (mIntent.hasExtra(EXTRA_PREFERENCES)) {
    options=(LockPreferences)mIntent.getSerializableExtra(EXTRA_PREFERENCES);
  }
 else {
    options=new LockPreferences(this);
  }
  mPackageName=mIntent.getStringExtra(EXTRA_PACKAGENAME);
  if (ACTION_CREATE.equals(mAction) || mPackageName == getPackageName()) {
    options.showAds=false;
  }
  if (ACTION_CREATE.equals(mAction)) {
    options.patternStealth=false;
  }
  mLayoutParams=new WindowManager.LayoutParams(WindowManager.LayoutParams.MATCH_PARENT,WindowManager.LayoutParams.MATCH_PARENT,WindowManager.LayoutParams.TYPE_PHONE,WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM | WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL | WindowManager.LayoutParams.FLAG_FULLSCREEN| WindowManager.LayoutParams.FLAG_WATCH_OUTSIDE_TOUCH,PixelFormat.TRANSLUCENT);
  mLayoutParams.screenOrientation=getScreenOrientation();
  return true;
}","/** 
 * Before inflating views
 */
private boolean beforeInflate(){
  if (mIntent == null) {
    return false;
  }
  mAction=mIntent.getAction();
  if (mAction == null) {
    Log.w(TAG,""String_Node_Str"");
    return false;
  }
  if (mIntent.hasExtra(EXTRA_PREFERENCES)) {
    options=(LockPreferences)mIntent.getSerializableExtra(EXTRA_PREFERENCES);
  }
 else {
    options=new LockPreferences(this);
  }
  mPackageName=mIntent.getStringExtra(EXTRA_PACKAGENAME);
  if (!getPackageName().equals(mPackageName)) {
    Intent i=new Intent(this,AppLockService.class);
    if (mServiceState == ServiceState.NOT_BOUND) {
      if (DEBUG_BIND)       Log.v(TAG,""String_Node_Str"" + mServiceState + ""String_Node_Str"");
      mServiceState=ServiceState.BINDING;
      bindService(i,mConnection,0);
    }
 else {
      if (DEBUG_BIND)       Log.v(TAG,""String_Node_Str"" + mServiceState + ""String_Node_Str"");
    }
  }
  if (ACTION_CREATE.equals(mAction) || mPackageName == getPackageName()) {
    options.showAds=false;
  }
  if (ACTION_CREATE.equals(mAction)) {
    options.patternStealth=false;
  }
  mLayoutParams=new WindowManager.LayoutParams(WindowManager.LayoutParams.MATCH_PARENT,WindowManager.LayoutParams.MATCH_PARENT,WindowManager.LayoutParams.TYPE_PHONE,WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM | WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL | WindowManager.LayoutParams.FLAG_FULLSCREEN| WindowManager.LayoutParams.FLAG_WATCH_OUTSIDE_TOUCH,PixelFormat.TRANSLUCENT);
  mLayoutParams.screenOrientation=getScreenOrientation();
  return true;
}",0.834023334587881
80257,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_main);
  handleIntent();
  mReceiver=new ServiceStateReceiver();
  mFilter=new IntentFilter();
  mFilter.addCategory(AppLockService.CATEGORY_STATE_EVENTS);
  mFilter.addAction(AppLockService.BROADCAST_SERVICE_STARTED);
  mFilter.addAction(AppLockService.BROADCAST_SERVICE_STOPPED);
  mNavFragment=(NavigationFragment)getSupportFragmentManager().findFragmentById(R.id.navigation_drawer);
  mNavFragment.setUp(R.id.navigation_drawer,(DrawerLayout)findViewById(R.id.drawer_layout));
  mTitle=getTitle();
  mActionBar=getSupportActionBar();
  mCurrentFragment=new AppsFragment();
  getSupportFragmentManager().beginTransaction().add(R.id.container,mCurrentFragment).commit();
  mCurrentFragmentType=NavigationElement.TYPE_APPS;
  mSequencer=new DialogSequencer();
  showDialogs();
  showLockerIfNotUnlocked(false);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_main);
  handleIntent();
  mReceiver=new ServiceStateReceiver();
  mFilter=new IntentFilter();
  mFilter.addCategory(AppLockService.CATEGORY_STATE_EVENTS);
  mFilter.addAction(AppLockService.BROADCAST_SERVICE_STARTED);
  mFilter.addAction(AppLockService.BROADCAST_SERVICE_STOPPED);
  mNavFragment=(NavigationFragment)getSupportFragmentManager().findFragmentById(R.id.navigation_drawer);
  mNavFragment.setUp(R.id.navigation_drawer,(DrawerLayout)findViewById(R.id.drawer_layout));
  mTitle=getTitle();
  mActionBar=getSupportActionBar();
  mCurrentFragment=new AppsFragment();
  getSupportFragmentManager().beginTransaction().add(R.id.container,mCurrentFragment).commit();
  mCurrentFragmentType=NavigationElement.TYPE_APPS;
  mSequencer=new DialogSequencer();
  if (showDialogs()) {
  }
  showLockerIfNotUnlocked(false);
}",0.9936974789915968
80258,"private void cancelAnimations(){
  if (DEBUG_VIEW)   Log.v(TAG,""String_Node_Str"" + ""String_Node_Str"" + mViewState + ""String_Node_Str"");
  if (mViewState == ViewState.HIDING) {
    mAnimHide.setAnimationListener(null);
    mAnimHide.cancel();
    mAnimHide=null;
  }
 else   if (mViewState == ViewState.SHOWING) {
    mAnimShow.setAnimationListener(null);
    mAnimShow.cancel();
    mAnimShow=null;
  }
  mWindowManager.removeView(mRootView);
}","private void cancelAnimations(){
  if (DEBUG_VIEW)   Log.v(TAG,""String_Node_Str"" + ""String_Node_Str"" + mViewState + ""String_Node_Str"");
  if (mViewState == ViewState.HIDING) {
    mAnimHide.setAnimationListener(null);
    mAnimHide.cancel();
    mAnimHide=null;
  }
 else   if (mViewState == ViewState.SHOWING) {
    mAnimShow.setAnimationListener(null);
    mAnimShow.cancel();
    mAnimShow=null;
  }
 else   if (mViewState != ViewState.HIDDEN) {
    mWindowManager.removeView(mRootView);
  }
 else   if (mViewState == ViewState.HIDDEN) {
    Log.e(TAG,""String_Node_Str"");
  }
}",0.8671875
80259,"/** 
 * Called every time a pattern has been detected by the user and the action was   {@link #ACTION_COMPARE}
 */
private void doComparePattern(){
  final String currentPattern=mLockPatternView.getPatternString();
  if (currentPattern.equals(options.pattern)) {
    exitSuccessCompare();
    mAnalytics.increment(LockerAnalytics.PATTERN_SUCCESS);
  }
 else {
    mAnalytics.increment(LockerAnalytics.PATTERN_FAILED);
    if (options.patternErrorStealth) {
      Toast.makeText(this,R.string.locker_invalid_pattern,Toast.LENGTH_SHORT).show();
      mLockPatternView.clearPattern();
    }
 else {
      mLockPatternView.setDisplayMode(DisplayMode.Wrong);
      mLockPatternView.clearPattern(PATTERN_DELAY);
    }
  }
}","/** 
 * Called every time a pattern has been detected by the user and the action was   {@link #ACTION_COMPARE}
 */
private void doComparePattern(){
  final String currentPattern=mLockPatternView.getPatternString();
  if (currentPattern.equals(options.pattern)) {
    mFingerDistance=mLockPatternView.getFingerDistance();
    exitSuccessCompare();
  }
 else {
    mAnalytics.increment(LockerAnalytics.UNLOCK_ERROR);
    if (options.patternErrorStealth) {
      Toast.makeText(this,R.string.locker_invalid_pattern,Toast.LENGTH_SHORT).show();
      mLockPatternView.clearPattern();
    }
 else {
      mLockPatternView.setDisplayMode(DisplayMode.Wrong);
      mLockPatternView.clearPattern(PATTERN_DELAY);
    }
  }
}",0.8874912648497554
80260,"/** 
 * Exit when an app has been unlocked successfully
 */
private void exitSuccessCompare(){
  if (mPackageName == null || mPackageName.equals(getPackageName())) {
    finish(true);
    return;
  }
  if (mServiceState == ServiceState.BOUND) {
    mAppLockService.unlockApp(mPackageName);
  }
 else {
    if (DEBUG_BIND)     Log.w(TAG,""String_Node_Str"" + mServiceState + ""String_Node_Str"");
  }
  finish(true);
}","/** 
 * Exit when an app has been unlocked successfully
 */
private void exitSuccessCompare(){
  long current=System.nanoTime();
  long total=(current - mTimeViewShown) / 1000000;
  long interacting=(current - mTimeFirstFingerDown) / 1000000;
  Log.d(TAG,""String_Node_Str"" + total);
  mAnalytics.increment(LockerAnalytics.TIME_SPENT_IN_LOCKSCREEN,total);
  mAnalytics.increment(LockerAnalytics.TIME_SPENT_INTERACTING,interacting);
  mAnalytics.increment(LockerAnalytics.UNLOCK_SUCCESS);
  Log.d(TAG,""String_Node_Str"" + mFingerDistance);
  mAnalytics.incrementFloat(LockerAnalytics.FINGER_DISTANCE,mFingerDistance);
  if (mPackageName == null || mPackageName.equals(getPackageName())) {
    finish(true);
    return;
  }
  if (mServiceState == ServiceState.BOUND) {
    mAppLockService.unlockApp(mPackageName);
  }
 else {
    if (DEBUG_BIND)     Log.w(TAG,""String_Node_Str"" + mServiceState + ""String_Node_Str"");
  }
  finish(true);
}",0.6136701337295691
80261,"/** 
 * @param explicit true if the user has clicked the OK button to explicitly ask for a password check (this should never happen)
 */
private void doComparePassword(boolean explicit){
  final String currentPassword=mLockPasswordView.getPassword();
  if (currentPassword.equals(options.password)) {
    exitSuccessCompare();
    mAnalytics.increment(LockerAnalytics.PASSWORD_SUCCESS);
  }
 else   if (explicit) {
    mAnalytics.increment(LockerAnalytics.PASSWORD_FAILED);
    mLockPasswordView.clearPassword();
    updatePassword();
    Toast.makeText(this,R.string.locker_invalid_password,Toast.LENGTH_SHORT).show();
  }
}","/** 
 * @param explicit true if the user has clicked the OK button to explicitly ask for a password check (this should never happen)
 */
private void doComparePassword(boolean explicit){
  final String currentPassword=mLockPasswordView.getPassword();
  if (currentPassword.equals(options.password)) {
    mFingerDistance=mLockPasswordView.getFingerDistance();
    exitSuccessCompare();
  }
 else   if (explicit) {
    mAnalytics.increment(LockerAnalytics.UNLOCK_ERROR);
    mLockPasswordView.clearPassword();
    updatePassword();
    Toast.makeText(this,R.string.locker_invalid_password,Toast.LENGTH_SHORT).show();
  }
}",0.841091492776886
80262,"@Override public int onStartCommand(Intent intent,int flags,int startId){
  if (intent == null) {
    return START_NOT_STICKY;
  }
  Log.d(TAG,""String_Node_Str"" + intent.getAction());
  if (ACTION_HIDE.equals(intent.getAction())) {
    finish(true);
    return START_NOT_STICKY;
  }
  if (ACTION_NOTIFY_PACKAGE_CHANGED.equals(intent.getAction())) {
    String newPackageName=intent.getStringExtra(EXTRA_PACKAGENAME);
    if (newPackageName == null || !getPackageName().equals(newPackageName)) {
      finish(true);
      return START_NOT_STICKY;
    }
  }
 else {
    mIntent=intent;
    mAnalytics=new Analytics(this);
    showView();
  }
  return START_NOT_STICKY;
}","@Override public int onStartCommand(Intent intent,int flags,int startId){
  if (intent == null) {
    return START_NOT_STICKY;
  }
  Log.d(TAG,""String_Node_Str"" + intent.getAction());
  if (ACTION_HIDE.equals(intent.getAction())) {
    finish(true);
    return START_NOT_STICKY;
  }
  if (ACTION_NOTIFY_PACKAGE_CHANGED.equals(intent.getAction())) {
    String newPackageName=intent.getStringExtra(EXTRA_PACKAGENAME);
    if (newPackageName == null || !getPackageName().equals(newPackageName)) {
      finish(true);
      return START_NOT_STICKY;
    }
  }
 else {
    mIntent=intent;
    showView();
  }
  return START_NOT_STICKY;
}",0.9723076923076924
80263,"private void onViewShown(){
  if (DEBUG_VIEW)   Log.v(TAG,""String_Node_Str"" + ""String_Node_Str"" + mViewState + ""String_Node_Str"");
  mViewState=ViewState.SHOWN;
  mAnimShow=null;
}","private void onViewShown(){
  mTimeViewShown=System.nanoTime();
  if (DEBUG_VIEW)   Log.v(TAG,""String_Node_Str"" + ""String_Node_Str"" + mViewState + ""String_Node_Str"");
  mViewState=ViewState.SHOWN;
  mAnimShow=null;
}",0.9090909090909092
80264,"@Override public void onPatternStart(){
  mLockPatternView.cancelClearDelay();
  mLockPatternView.setDisplayMode(DisplayMode.Correct);
  if (ACTION_CREATE.equals(mAction)) {
    if (mRightButtonAction == RightButtonAction.CONTINUE) {
      mViewMessage.setText(R.string.pattern_change_head);
    }
 else {
      mViewMessage.setText(R.string.pattern_change_confirm);
    }
  }
}","@Override public void onPatternStart(){
  mTimeFirstFingerDown=System.nanoTime();
  mLockPatternView.cancelClearDelay();
  mLockPatternView.setDisplayMode(DisplayMode.Correct);
  if (ACTION_CREATE.equals(mAction)) {
    if (mRightButtonAction == RightButtonAction.CONTINUE) {
      mViewMessage.setText(R.string.pattern_change_head);
    }
 else {
      mViewMessage.setText(R.string.pattern_change_confirm);
    }
  }
}",0.9473684210526316
80265,"@Override public void onClick(View v){
  if (v.getId() == mOkButton.getId()) {
    onOkButtonImpl();
  }
 else   if (v.getId() == mBackButton.getId()) {
    onBackButtonImpl();
  }
 else {
    onNumberButtonImpl(v);
  }
  if (mEnableHapticFeedback) {
    performHapticFeedback(HapticFeedbackConstants.VIRTUAL_KEY,HapticFeedbackConstants.FLAG_IGNORE_VIEW_SETTING | HapticFeedbackConstants.FLAG_IGNORE_GLOBAL_SETTING);
  }
}","@Override public void onClick(View v){
  if (!mStarted) {
    mListener.onStart();
    mStarted=true;
  }
  if (v.getId() == mOkButton.getId()) {
    onOkButtonImpl();
  }
 else   if (v.getId() == mBackButton.getId()) {
    onBackButtonImpl();
  }
 else {
    onNumberButtonImpl(v);
  }
  if (mEnableHapticFeedback) {
    performHapticFeedback(HapticFeedbackConstants.VIRTUAL_KEY,HapticFeedbackConstants.FLAG_IGNORE_VIEW_SETTING | HapticFeedbackConstants.FLAG_IGNORE_GLOBAL_SETTING);
  }
}",0.9264544456641054
80266,"@Override public boolean onLongClick(View v){
  if (v.getId() == mOkButton.getId()) {
    onOkButtonLongImpl();
  }
 else   if (v.getId() == mBackButton.getId()) {
    onBackButtonLongImpl();
  }
  if (mEnableHapticFeedback) {
    performHapticFeedback(HapticFeedbackConstants.LONG_PRESS,HapticFeedbackConstants.FLAG_IGNORE_VIEW_SETTING | HapticFeedbackConstants.FLAG_IGNORE_GLOBAL_SETTING);
  }
  return true;
}","@Override public boolean onLongClick(View v){
  if (!mStarted) {
    mListener.onStart();
    mStarted=true;
  }
  if (v.getId() == mOkButton.getId()) {
    onOkButtonLongImpl();
  }
 else   if (v.getId() == mBackButton.getId()) {
    onBackButtonLongImpl();
  }
  if (mEnableHapticFeedback) {
    performHapticFeedback(HapticFeedbackConstants.LONG_PRESS,HapticFeedbackConstants.FLAG_IGNORE_VIEW_SETTING | HapticFeedbackConstants.FLAG_IGNORE_GLOBAL_SETTING);
  }
  return true;
}",0.924803591470258
80267,"/** 
 * Handle this Intent for searching...
 */
private void handleIntent(){
  if (getIntent().getAction().equals(Intent.ACTION_SEARCH)) {
    Log.d(""String_Node_Str"",""String_Node_Str"");
    if (mCurrentFragmentType == NavigationElement.TYPE_APPS) {
      final String query=getIntent().getStringExtra(SearchManager.QUERY);
      if (query != null) {
        ((AppsFragment)mCurrentFragment).onSearch(query);
      }
    }
  }
}","/** 
 * Handle this Intent for searching...
 */
private void handleIntent(){
  if (getIntent() != null && getIntent().getAction() != null) {
    if (getIntent().getAction().equals(Intent.ACTION_SEARCH)) {
      Log.d(""String_Node_Str"",""String_Node_Str"");
      if (mCurrentFragmentType == NavigationElement.TYPE_APPS) {
        final String query=getIntent().getStringExtra(SearchManager.QUERY);
        if (query != null) {
          ((AppsFragment)mCurrentFragment).onSearch(query);
        }
      }
    }
  }
}",0.9087048832271762
80268,"private void doTest(){
}","private void doTest(){
  Log.d(""String_Node_Str"",""String_Node_Str"");
  Analytics analytics=new Analytics(this);
  ProUtils proUtils=new ProUtils(this);
  Map<String,String> data=new HashMap<String,String>();
  data.put(LockerAnalytics.PRO_TYPE,proUtils.getProTypeString());
  data.put(LockerAnalytics.LOCKED_APPS_COUNT,String.valueOf(PrefUtils.getLockedApps(this).size()));
  analytics.setDefaultUrl(LockerAnalytics.URL).query(data);
}",0.1045751633986928
80269,"private void onAlarmReceived(final Context c){
  Log.d(""String_Node_Str"",""String_Node_Str"");
  Analytics analytics=new Analytics(c);
  ProUtils proUtils=new ProUtils(c);
  Map<String,String> data=new HashMap<String,String>();
  data.put(LockerAnalytics.PRO_TYPE,proUtils.getProTypeString());
  data.put(LockerAnalytics.LOCKED_APPS_COUNT,String.valueOf(PrefUtils.getLockedApps(c).size()));
  analytics.queryServer(data);
}","private void onAlarmReceived(final Context c){
  Log.d(""String_Node_Str"",""String_Node_Str"");
  Analytics analytics=new Analytics(c);
  ProUtils proUtils=new ProUtils(c);
  Map<String,String> data=new HashMap<String,String>();
  data.put(LockerAnalytics.PRO_TYPE,proUtils.getProTypeString());
  data.put(LockerAnalytics.LOCKED_APPS_COUNT,String.valueOf(PrefUtils.getLockedApps(c).size()));
  Log.d(""String_Node_Str"",""String_Node_Str"");
  analytics.setDefaultUrl(LockerAnalytics.URL).query(data);
}",0.8854961832061069
80270,"private void showRootView(boolean animate,boolean forceReload){
  if (mRootView == null || forceReload) {
    hideView();
    mRootView=inflateRootView();
    mWindowManager.addView(mRootView,mLayoutParams);
  }
 else {
    if (mViewDisplayed) {
      mWindowManager.updateViewLayout(mRootView,mLayoutParams);
    }
 else {
      mWindowManager.addView(mRootView,mLayoutParams);
    }
  }
  if (animate)   showAnimation();
  mViewDisplayed=true;
}","private void showRootView(boolean animate){
  hideView();
  mRootView=inflateRootView();
  mWindowManager.addView(mRootView,mLayoutParams);
  if (animate)   showAnimation();
  mViewDisplayed=true;
}",0.6139534883720931
80271,"@Override public void onConfigurationChanged(Configuration newConfig){
  Log.d(TAG,""String_Node_Str"");
  super.onConfigurationChanged(newConfig);
  if (mViewDisplayed) {
    showRootView(false,true);
    onAfterInflate();
  }
}","@Override public void onConfigurationChanged(Configuration newConfig){
  Log.d(TAG,""String_Node_Str"");
  super.onConfigurationChanged(newConfig);
  if (mViewDisplayed) {
    showRootView(false);
    onAfterInflate();
  }
}",0.9888641425389756
80272,"private void hideView(){
  if (mViewDisplayed) {
    mWindowManager.removeView(mRootView);
    mViewDisplayed=false;
  }
}","private void hideView(){
  if (mViewDisplayed && mRootView != null) {
    mWindowManager.removeView(mRootView);
    mViewDisplayed=false;
  }
}",0.920754716981132
80273,"@Override public int onStartCommand(Intent intent,int flags,int startId){
  if (intent == null) {
    return START_NOT_STICKY;
  }
  if (ACTION_NOTIFY_PACKAGE_CHANGED.equals(intent.getAction())) {
    String newPackageName=intent.getStringExtra(EXTRA_PACKAGENAME);
    if (newPackageName == null) {
      finish(true);
      return START_NOT_STICKY;
    }
 else     if (!newPackageName.equals(mPackageName) && (!getPackageName().equals(newPackageName))) {
      finish(true);
      return START_NOT_STICKY;
    }
    if (newPackageName.equals(mPackageName)) {
      if (!getPackageName().equals(newPackageName)) {
        finish(true);
      }
      return START_NOT_STICKY;
    }
  }
 else {
    mIntent=intent;
    mAnalytics=new Analytics(this);
    onBeforeInflate();
    showRootView(true,false);
    onAfterInflate();
  }
  return super.onStartCommand(intent,flags,startId);
}","@Override public int onStartCommand(Intent intent,int flags,int startId){
  if (intent == null) {
    return START_NOT_STICKY;
  }
  if (ACTION_NOTIFY_PACKAGE_CHANGED.equals(intent.getAction())) {
    String newPackageName=intent.getStringExtra(EXTRA_PACKAGENAME);
    if (newPackageName == null) {
      finish(true);
      return START_NOT_STICKY;
    }
 else     if (!newPackageName.equals(mPackageName) && (!getPackageName().equals(newPackageName))) {
      finish(true);
      return START_NOT_STICKY;
    }
    if (newPackageName.equals(mPackageName)) {
      if (!getPackageName().equals(newPackageName)) {
        finish(true);
      }
      return START_NOT_STICKY;
    }
  }
 else {
    mIntent=intent;
    mAnalytics=new Analytics(this);
    onBeforeInflate();
    showRootView(true);
    onAfterInflate();
  }
  return super.onStartCommand(intent,flags,startId);
}",0.9055745164960182
80274,"private void showRootView(boolean animate,boolean forceReload){
  if (mViewDisplayed) {
    mWindowManager.removeView(mRootView);
  }
  System.gc();
  if (mRootView == null || forceReload)   mRootView=inflateRootView();
  mWindowManager.addView(mRootView,mLayoutParams);
  if (animate)   showAnimation();
  mViewDisplayed=true;
}","private void showRootView(boolean animate,boolean forceReload){
  if (mRootView == null || forceReload) {
    if (mViewDisplayed) {
      mWindowManager.removeView(mRootView);
    }
    mRootView=inflateRootView();
    mWindowManager.addView(mRootView,mLayoutParams);
  }
 else {
    if (mViewDisplayed) {
      mWindowManager.updateViewLayout(mRootView,mLayoutParams);
    }
 else {
      mWindowManager.addView(mRootView,mLayoutParams);
    }
  }
  if (animate)   showAnimation();
  mViewDisplayed=true;
}",0.583732057416268
80275,"@Override public void onAnimationStart(Animation animation){
  Log.d(TAG,""String_Node_Str"");
}","@Override public void onAnimationStart(Animation animation){
}",0.7948717948717948
80276,"private void hideAnimation(){
  if (!mViewDisplayed) {
    return;
  }
  Log.d(TAG,""String_Node_Str"" + mContainer.hashCode());
  Animation anim=AnimationUtils.loadAnimation(this,R.anim.fade_out);
  anim.setDuration(mHideAnimationDuration);
  anim.setFillEnabled(true);
  anim.setDetachWallpaper(false);
  anim.setAnimationListener(new AnimationListener(){
    @Override public void onAnimationStart(    Animation animation){
      Log.d(TAG,""String_Node_Str"");
    }
    @Override public void onAnimationRepeat(    Animation animation){
    }
    @Override public void onAnimationEnd(    Animation animation){
      hideView();
    }
  }
);
  mContainer.startAnimation(anim);
}","private void hideAnimation(){
  if (!mViewDisplayed) {
    return;
  }
  Log.d(TAG,""String_Node_Str"" + mContainer.hashCode());
  Log.d(TAG,""String_Node_Str"" + mContainer.isFocused());
  Animation anim=AnimationUtils.loadAnimation(this,R.anim.fade_out);
  anim.setDuration(mHideAnimationDuration);
  anim.setFillEnabled(true);
  anim.setDetachWallpaper(false);
  anim.setAnimationListener(new AnimationListener(){
    @Override public void onAnimationStart(    Animation animation){
    }
    @Override public void onAnimationRepeat(    Animation animation){
    }
    @Override public void onAnimationEnd(    Animation animation){
      hideView();
    }
  }
);
  mContainer.startAnimation(anim);
}",0.5265454545454545
80277,"private void showAnimation(){
  Log.d(TAG,""String_Node_Str"");
  Animation anim=AnimationUtils.loadAnimation(this,R.anim.fade_in);
  anim.setDuration(mShowAnimationDuration);
  anim.setFillEnabled(true);
  mContainer.startAnimation(anim);
  Log.d(TAG,""String_Node_Str"");
}","private void showAnimation(){
  Animation anim=AnimationUtils.loadAnimation(this,R.anim.fade_in);
  anim.setDuration(mShowAnimationDuration);
  anim.setFillEnabled(true);
  mContainer.startAnimation(anim);
}",0.8661087866108786
80278,"/** 
 * Should be only called from   {@link #showRootView(boolean)}
 * @return
 */
private View inflateRootView(){
  mWindowManager=(WindowManager)getSystemService(WINDOW_SERVICE);
  LayoutInflater li=LayoutInflater.from(this);
  setTheme(R.style.LockActivityTheme);
  View root=(View)li.inflate(R.layout.layout_alias_locker,null);
  mContainer=(RelativeLayout)root.findViewById(R.id.rlContainer);
  mViewBackground=(ImageView)root.findViewById(R.id.ivBackground);
  root.setOnKeyListener(this);
  root.setFocusable(true);
  root.setFocusableInTouchMode(true);
  mViewTitle=(TextView)root.findViewById(R.id.tvHeader);
  mViewMessage=(TextView)root.findViewById(R.id.tvFooter);
  mAppIcon=(ImageView)root.findViewById(R.id.ivAppIcon);
  mLockView=(ViewGroup)root.findViewById(R.id.lockView);
  mFooterButtons=(LinearLayout)root.findViewById(R.id.llBottomButtons);
  mLeftButton=(Button)root.findViewById(R.id.bFooterLeft);
  mRightButton=(Button)root.findViewById(R.id.bFooterRight);
  mRightButton.setOnClickListener(this);
  mLeftButton.setOnClickListener(this);
  mPasswordListener=new MyOnNumberListener();
  mPatternListener=new MyOnPatternListener();
  return root;
}","/** 
 * Should be only called from   {@link #showRootView(boolean)}
 * @return
 */
private View inflateRootView(){
  mWindowManager=(WindowManager)getSystemService(WINDOW_SERVICE);
  LayoutInflater li=LayoutInflater.from(this);
  setTheme(R.style.LockActivityTheme);
  View root=(View)li.inflate(R.layout.layout_alias_locker,null);
  mContainer=(RelativeLayout)root.findViewById(R.id.rlContainer);
  Log.d(TAG,""String_Node_Str"" + mContainer.hashCode());
  mViewBackground=(ImageView)root.findViewById(R.id.ivBackground);
  root.setOnKeyListener(this);
  root.setFocusable(true);
  root.setFocusableInTouchMode(true);
  mViewTitle=(TextView)root.findViewById(R.id.tvHeader);
  mViewMessage=(TextView)root.findViewById(R.id.tvFooter);
  mAppIcon=(ImageView)root.findViewById(R.id.ivAppIcon);
  mLockView=(ViewGroup)root.findViewById(R.id.lockView);
  mFooterButtons=(LinearLayout)root.findViewById(R.id.llBottomButtons);
  mLeftButton=(Button)root.findViewById(R.id.bFooterLeft);
  mRightButton=(Button)root.findViewById(R.id.bFooterRight);
  mRightButton.setOnClickListener(this);
  mLeftButton.setOnClickListener(this);
  mPasswordListener=new MyOnNumberListener();
  mPatternListener=new MyOnPatternListener();
  return root;
}",0.9766666666666668
80279,"@Override public void onAnimationEnd(Animation animation){
}","@Override public void onAnimationEnd(Animation animation){
  hideView();
}",0.8955223880597015
80280,"private void hideAnimation(){
  if (!mViewDisplayed) {
    return;
  }
  Animation anim=AnimationUtils.loadAnimation(this,R.anim.fade_out);
  anim.setDuration(mHideAnimationDuration);
  anim.setFillEnabled(true);
  anim.setDetachWallpaper(false);
  anim.setAnimationListener(new AnimationListener(){
    @Override public void onAnimationStart(    Animation animation){
      Log.d(TAG,""String_Node_Str"");
    }
    @Override public void onAnimationRepeat(    Animation animation){
    }
    @Override public void onAnimationEnd(    Animation animation){
    }
  }
);
  hideView();
  mContainer.startAnimation(anim);
}","private void hideAnimation(){
  if (!mViewDisplayed) {
    return;
  }
  Log.d(TAG,""String_Node_Str"" + mContainer.hashCode());
  Animation anim=AnimationUtils.loadAnimation(this,R.anim.fade_out);
  anim.setDuration(mHideAnimationDuration);
  anim.setFillEnabled(true);
  anim.setDetachWallpaper(false);
  anim.setAnimationListener(new AnimationListener(){
    @Override public void onAnimationStart(    Animation animation){
      Log.d(TAG,""String_Node_Str"");
    }
    @Override public void onAnimationRepeat(    Animation animation){
    }
    @Override public void onAnimationEnd(    Animation animation){
      hideView();
    }
  }
);
  mContainer.startAnimation(anim);
}",0.4451313755795981
80281,"@SuppressLint(""String_Node_Str"") @Override public void onCreate(){
  super.onCreate();
  Log.v(TAG,""String_Node_Str"");
  mAM=(ActivityManager)getSystemService(ACTIVITY_SERVICE);
  loadPreferences();
  startScheduler();
  mScreenReceiver=new ScreenReceiver();
  IntentFilter filter=new IntentFilter();
  filter.addAction(Intent.ACTION_SCREEN_ON);
  filter.addAction(Intent.ACTION_SCREEN_OFF);
  registerReceiver(mScreenReceiver,filter);
  if (mShowNotification) {
    Intent i=new Intent(this,MainActivity.class);
    PendingIntent.getActivity(this,0,i,0);
    PendingIntent pi=PendingIntent.getActivity(this,0,i,0);
    String title=getString(R.string.notification_title);
    String content=getString(R.string.notification_state_locked);
    Notification n=getNotificationCompat(title,content,pi);
    startForeground(NOTIFICATION_ID,n);
  }
 else   if (Build.VERSION.SDK_INT <= Build.VERSION_CODES.JELLY_BEAN_MR1) {
    @SuppressWarnings(""String_Node_Str"") Notification n=new Notification(0,null,System.currentTimeMillis());
    n.flags|=Notification.FLAG_NO_CLEAR;
    startForeground(NOTIFICATION_ID,n);
  }
}","@SuppressLint(""String_Node_Str"") @Override public void onCreate(){
  super.onCreate();
  Log.v(TAG,""String_Node_Str"");
  mAM=(ActivityManager)getSystemService(ACTIVITY_SERVICE);
  loadPreferences();
  startScheduler();
  mScreenReceiver=new ScreenReceiver();
  IntentFilter filter=new IntentFilter();
  filter.addAction(Intent.ACTION_SCREEN_ON);
  filter.addAction(Intent.ACTION_SCREEN_OFF);
  registerReceiver(mScreenReceiver,filter);
  if (mShowNotification) {
    Intent i=new Intent(this,MainActivity.class);
    PendingIntent.getActivity(this,0,i,0);
    PendingIntent pi=PendingIntent.getActivity(this,0,i,0);
    String title=getString(R.string.notification_title);
    String content=getString(R.string.notification_state_locked);
    NotificationCompat.Builder nb=new NotificationCompat.Builder(this);
    nb.setSmallIcon(R.drawable.ic_launcher);
    nb.setContentTitle(title);
    nb.setContentText(content);
    nb.setWhen(System.currentTimeMillis());
    nb.setContentIntent(pi);
    nb.setOngoing(true);
    startForeground(NOTIFICATION_ID,nb.build());
  }
 else   if (Build.VERSION.SDK_INT <= Build.VERSION_CODES.JELLY_BEAN_MR1) {
    @SuppressWarnings(""String_Node_Str"") Notification n=new Notification(0,null,System.currentTimeMillis());
    n.flags|=Notification.FLAG_NO_CLEAR;
    startForeground(NOTIFICATION_ID,n);
  }
}",0.8797390949857318
80282,"/** 
 * @param context
 * @return A {@link Set} that is safe to edit and use.
 */
public static final Set<String> getTrackedApps(Context c){
  Set<String> apps=new HashSet<String>();
  SharedPreferences sp=c.getSharedPreferences(PREF_FILE_APPS,Context.MODE_PRIVATE);
  Set<String> prefApps=sp.getStringSet(PREF_KEY_APPS,new HashSet<String>());
  apps.addAll(prefApps);
  return apps;
}","/** 
 * @param context
 * @return A {@link Set} that is safe to edit and use.
 */
public static final Set<String> getTrackedApps(Context c){
  SharedPreferences sp=c.getSharedPreferences(PREF_FILE_APPS,Context.MODE_PRIVATE);
  Set<String> apps=new HashSet<String>(sp.getAll().keySet());
  return apps;
}",0.7906976744186046
80283,"/** 
 * Tracks or untracks an app
 * @param packageName
 * @param shouldTrack True if the new state will be tracking, false if not
 */
public final void setTracking(String packageName,boolean shouldTrack){
  Set<String> apps=getTrackedApps(this);
  SharedPreferences.Editor editor=getSharedPreferences(PREF_FILE_APPS,Context.MODE_PRIVATE).edit();
  boolean done;
  if (shouldTrack) {
    done=apps.add(packageName);
  }
 else {
    done=apps.remove(packageName);
  }
  Log.d(TAG,(shouldTrack ? ""String_Node_Str"" : ""String_Node_Str"") + packageName + ""String_Node_Str""+ done);
  editor.putStringSet(PREF_KEY_APPS,apps);
  boolean commited=editor.commit();
  if (!commited) {
    Log.w(TAG,""String_Node_Str"");
  }
  updateTrackedApps();
}","/** 
 * Tracks or untracks an app
 * @param packageName
 * @param shouldTrack True if the new state will be tracking, false if not
 */
public final void setTracking(String packageName,boolean shouldTrack){
  SharedPreferences.Editor editor=getSharedPreferences(PREF_FILE_APPS,Context.MODE_PRIVATE).edit();
  if (shouldTrack) {
    editor.putBoolean(packageName,true);
  }
 else {
    editor.remove(packageName);
  }
  boolean commited=editor.commit();
  if (!commited) {
    Log.w(TAG,""String_Node_Str"");
  }
  updateTrackedApps();
}",0.7176656151419558
80284,"@Override public void onClick(View v){
switch (v.getId()) {
case R.id.bOK:
{
      onOkButton();
      break;
    }
case R.id.bBack:
{
    StringBuilder sb=new StringBuilder(tvPassword.getText());
    if (sb.length() > 0) {
      tvPassword.setText(sb.delete(sb.length() - 1,sb.length()).toString());
    }
    onBackButton();
    break;
  }
default :
{
  onNumberButton(v);
  break;
}
}
}","@Override public void onClick(View v){
switch (v.getId()) {
case R.id.bOK:
{
      onOkButton();
      break;
    }
case R.id.bBack:
{
    onBackButton();
    break;
  }
default :
{
  onNumberButton(v);
  break;
}
}
}",0.5973597359735974
80285,"/** 
 * Called every time the back button is pressed. If you override this method call super.  {@link #onBackButton(boolean)} to remove last character from{@link #tvPassword}
 * @param longPress
 */
protected void onBackButton(){
  StringBuilder sb=new StringBuilder(tvPassword.getText());
  if (sb.length() != 0) {
    sb.delete(sb.length() - 1,sb.length());
    tvPassword.setText(sb.toString());
  }
}","/** 
 * Called every time the back button is pressed. If you override this method call super.  {@link #onBackButton(boolean)} to remove last character from{@link #tvPassword}
 * @param longPress
 */
protected void onBackButton(){
  StringBuilder sb=new StringBuilder(tvPassword.getText());
  if (sb.length() != 0) {
    sb.deleteCharAt(sb.length() - 1);
    tvPassword.setText(sb.toString());
  }
}",0.9775561097256856
80286,"/** 
 * Update master computable result to master znode. At the same time clean znodes for old iterations. Iteration 0 and last iteration will not be removed for fail over.
 */
@Override public void postIteration(final MasterContext<MASTER_RESULT,WORKER_RESULT> context){
  new BasicCoordinatorCommand(){
    @Override public void doExecute() throws KeeperException, InterruptedException {
      NettyMasterCoordinator.this.masterResult=context.getMasterResult();
      updateMasterHaltStatus(context);
      boolean isSplit=false;
      String appCurrentMasterNode=getCurrentMasterNode(context.getAppId(),context.getCurrentIteration()).toString();
      String appCurrentMasterSplitNode=getCurrentMasterSplitNode(context.getAppId(),context.getCurrentIteration()).toString();
      LOG.debug(""String_Node_Str"",context.getMasterResult());
      try {
        byte[] bytes=getMasterSerializer().objectToBytes(context.getMasterResult());
        isSplit=setBytesToZNode(appCurrentMasterNode,appCurrentMasterSplitNode,bytes,CreateMode.PERSISTENT);
synchronized (LOCK) {
          clear(context.getProps());
          NettyMasterCoordinator.this.currentInteration=context.getCurrentIteration() + 1;
          NettyMasterCoordinator.this.canUpdateWorkerResultMap=true;
        }
      }
 catch (      KeeperException.NodeExistsException e) {
        LOG.warn(""String_Node_Str"",e);
      }
      int resultCleanUpInterval=NumberFormatUtils.getInt(context.getProps().getProperty(GuaguaConstants.GUAGUA_CLEANUP_INTERVAL),GuaguaConstants.GUAGUA_DEFAULT_CLEANUP_INTERVAL);
      if (context.getCurrentIteration() >= (resultCleanUpInterval + 1)) {
        String znode=getMasterNode(context.getAppId(),context.getCurrentIteration() - resultCleanUpInterval).toString();
        try {
          getZooKeeper().deleteExt(znode,-1,false);
          if (isSplit) {
            znode=getCurrentMasterSplitNode(context.getAppId(),context.getCurrentIteration() - resultCleanUpInterval).toString();
            getZooKeeper().deleteExt(znode,-1,true);
          }
        }
 catch (        KeeperException.NoNodeException e) {
          if (System.nanoTime() % 20 == 0) {
            LOG.warn(""String_Node_Str"",znode);
          }
        }
      }
      LOG.info(""String_Node_Str"");
    }
  }
.execute();
}","/** 
 * Update master computable result to master znode. At the same time clean znodes for old iterations. Iteration 0 and last iteration will not be removed for fail over.
 */
@Override public void postIteration(final MasterContext<MASTER_RESULT,WORKER_RESULT> context){
  new BasicCoordinatorCommand(){
    @Override public void doExecute() throws KeeperException, InterruptedException {
      NettyMasterCoordinator.this.masterResult=context.getMasterResult();
      updateMasterHaltStatus(context);
      boolean isSplit=false;
      String appCurrentMasterNode=getCurrentMasterNode(context.getAppId(),context.getCurrentIteration()).toString();
      String appCurrentMasterSplitNode=getCurrentMasterSplitNode(context.getAppId(),context.getCurrentIteration()).toString();
      LOG.debug(""String_Node_Str"",context.getMasterResult());
      final long start=System.nanoTime();
      try {
        byte[] bytes=getMasterSerializer().objectToBytes(context.getMasterResult());
        isSplit=setBytesToZNode(appCurrentMasterNode,appCurrentMasterSplitNode,bytes,CreateMode.PERSISTENT);
synchronized (LOCK) {
          clear(context.getProps());
          NettyMasterCoordinator.this.currentInteration=context.getCurrentIteration() + 1;
          NettyMasterCoordinator.this.canUpdateWorkerResultMap=true;
        }
      }
 catch (      KeeperException.NodeExistsException e) {
        LOG.warn(""String_Node_Str"",e);
      }
      LOG.debug(""String_Node_Str"",TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - start));
      int resultCleanUpInterval=NumberFormatUtils.getInt(context.getProps().getProperty(GuaguaConstants.GUAGUA_CLEANUP_INTERVAL),GuaguaConstants.GUAGUA_DEFAULT_CLEANUP_INTERVAL);
      if (context.getCurrentIteration() >= (resultCleanUpInterval + 1)) {
        String znode=getMasterNode(context.getAppId(),context.getCurrentIteration() - resultCleanUpInterval).toString();
        try {
          getZooKeeper().deleteExt(znode,-1,false);
          if (isSplit) {
            znode=getCurrentMasterSplitNode(context.getAppId(),context.getCurrentIteration() - resultCleanUpInterval).toString();
            getZooKeeper().deleteExt(znode,-1,true);
          }
        }
 catch (        KeeperException.NoNodeException e) {
          if (System.nanoTime() % 20 == 0) {
            LOG.warn(""String_Node_Str"",znode);
          }
        }
      }
      LOG.info(""String_Node_Str"");
    }
  }
.execute();
}",0.97131931166348
80287,"@SuppressWarnings(""String_Node_Str"") protected void setUp(){
  try {
    this.fileSplits=generateWorkerSplits(this.props.getProperty(GuaguaConstants.GUAGUA_INPUT_DIR));
  }
 catch (  IOException e) {
    throw new GuaguaRuntimeException(e);
  }
  this.executor=Executors.newFixedThreadPool(this.fileSplits.size() + 1);
  this.props.setProperty(GuaguaConstants.GUAGUA_MASTER_SYSTEM_INTERCEPTERS,LocalMasterCoordinator.class.getName());
  this.props.setProperty(GuaguaConstants.GUAGUA_WORKER_SYSTEM_INTERCEPTERS,LocalWorkerCoordinator.class.getName());
  this.props.setProperty(GuaguaConstants.GUAGUA_WORKER_NUMBER,this.fileSplits.size() + ""String_Node_Str"");
  this.iteration=Integer.parseInt(this.props.getProperty(GuaguaConstants.GUAGUA_ITERATION_COUNT));
  this.workerServices=new ArrayList<GuaguaService>();
  this.masterService=new GuaguaMasterService<MASTER_RESULT,WORKER_RESULT>();
  InMemoryCoordinator<MASTER_RESULT,WORKER_RESULT> coordinator=new InMemoryCoordinator<MASTER_RESULT,WORKER_RESULT>(this.fileSplits.size(),this.iteration);
  this.masterService.setAppId(GUAGUA_UNIT_TEST);
  this.masterService.setContainerId(""String_Node_Str"");
  ((GuaguaMasterService<MASTER_RESULT,WORKER_RESULT>)this.masterService).setCoordinator(coordinator);
  this.masterService.init(this.props);
  for (int i=0; i < this.fileSplits.size(); i++) {
    GuaguaService workerService=new GuaguaWorkerService<MASTER_RESULT,WORKER_RESULT>();
    workerService.setAppId(GUAGUA_UNIT_TEST);
    workerService.setContainerId((i + 1) + ""String_Node_Str"");
    workerService.setSplits(Arrays.asList(this.fileSplits.get(i)));
    ((GuaguaWorkerService<MASTER_RESULT,WORKER_RESULT>)workerService).setCoordinator(coordinator);
    workerService.init(this.props);
    this.workerServices.add(workerService);
  }
}","@SuppressWarnings(""String_Node_Str"") protected void setUp(){
  try {
    this.fileSplits=generateWorkerSplits(this.props.getProperty(GuaguaConstants.GUAGUA_INPUT_DIR));
  }
 catch (  IOException e) {
    throw new GuaguaRuntimeException(e);
  }
  this.executor=Executors.newFixedThreadPool(this.fileSplits.size() + 1,new UtDefaultThreadFactory());
  this.props.setProperty(GuaguaConstants.GUAGUA_MASTER_SYSTEM_INTERCEPTERS,LocalMasterCoordinator.class.getName());
  this.props.setProperty(GuaguaConstants.GUAGUA_WORKER_SYSTEM_INTERCEPTERS,LocalWorkerCoordinator.class.getName());
  this.props.setProperty(GuaguaConstants.GUAGUA_WORKER_NUMBER,this.fileSplits.size() + ""String_Node_Str"");
  this.iteration=Integer.parseInt(this.props.getProperty(GuaguaConstants.GUAGUA_ITERATION_COUNT));
  this.workerServices=new ArrayList<GuaguaService>();
  this.masterService=new GuaguaMasterService<MASTER_RESULT,WORKER_RESULT>();
  InMemoryCoordinator<MASTER_RESULT,WORKER_RESULT> coordinator=new InMemoryCoordinator<MASTER_RESULT,WORKER_RESULT>(this.fileSplits.size(),this.iteration);
  this.masterService.setAppId(GUAGUA_UNIT_TEST);
  this.masterService.setContainerId(""String_Node_Str"");
  ((GuaguaMasterService<MASTER_RESULT,WORKER_RESULT>)this.masterService).setCoordinator(coordinator);
  this.masterService.init(this.props);
  for (int i=0; i < this.fileSplits.size(); i++) {
    GuaguaService workerService=new GuaguaWorkerService<MASTER_RESULT,WORKER_RESULT>();
    workerService.setAppId(GUAGUA_UNIT_TEST);
    workerService.setContainerId((i + 1) + ""String_Node_Str"");
    workerService.setSplits(Arrays.asList(this.fileSplits.get(i)));
    ((GuaguaWorkerService<MASTER_RESULT,WORKER_RESULT>)workerService).setCoordinator(coordinator);
    workerService.init(this.props);
    this.workerServices.add(workerService);
  }
}",0.9919645331116652
80288,"/** 
 * Run all jobs added to JobControl.
 */
public void run() throws IOException {
  List<ControlledJob> jobsWithoutIds=this.jc.getWaitingJobList();
  int totalNeededMRJobs=jobsWithoutIds.size();
  LOG.info(""String_Node_Str"",jobsWithoutIds.size());
  Thread jcThread=new Thread(this.jc,""String_Node_Str"");
  jcThread.start();
  JobClient jobClient=new JobClient(new JobConf(new Configuration()));
  double lastProg=-1;
  Set<String> sucessfulJobs=new HashSet<String>();
  while (!this.jc.allFinished()) {
    try {
      jcThread.join(1000);
    }
 catch (    InterruptedException ignore) {
      Thread.currentThread().interrupt();
    }
    List<ControlledJob> jobsAssignedIdInThisRun=new ArrayList<ControlledJob>(totalNeededMRJobs);
    for (    ControlledJob job : jobsWithoutIds) {
      if (job.getJob().getJobID() != null) {
        jobsAssignedIdInThisRun.add(job);
        LOG.info(""String_Node_Str"",job.getJob().getJobID().toString());
      }
 else {
      }
    }
    jobsWithoutIds.removeAll(jobsAssignedIdInThisRun);
    List<ControlledJob> successfulJobs=jc.getSuccessfulJobList();
    for (    ControlledJob controlledJob : successfulJobs) {
      String jobId=controlledJob.getJob().getJobID().toString();
      if (!sucessfulJobs.contains(jobId)) {
        LOG.info(""String_Node_Str"",jobId);
        sucessfulJobs.add(jobId);
      }
    }
    List<ControlledJob> failedJobs=jc.getFailedJobList();
    for (    ControlledJob controlledJob : failedJobs) {
      String failedJobId=controlledJob.getJob().getJobID().toString();
      Counters counters=controlledJob.getJob().getCounters();
      if (counters != null) {
        try {
          Thread.sleep(1 * 1000L);
        }
 catch (        InterruptedException e) {
          Thread.currentThread().interrupt();
        }
        Counter doneCounter=counters.findCounter(GuaguaMapReduceConstants.GUAGUA_STATUS,GuaguaMapReduceConstants.DONE_WORKERS);
        if (doneCounter != null && doneCounter.getValue() > 0) {
          LOG.info(""String_Node_Str"",failedJobId,doneCounter.getValue());
          continue;
        }
      }
      if (!this.failedCheckingJobs.contains(failedJobId)) {
        this.failedCheckingJobs.add(failedJobId);
        String jobName=controlledJob.getJob().getJobName();
        Integer jobIndex=this.jobIndexMap.get(jobName);
        Integer runTimes=this.jobRunningTimes.get(jobIndex);
        if (runTimes <= 1) {
          LOG.warn(""String_Node_Str"",jobName);
          Job newJob=createJob(this.jobIndexParams.get(jobIndex));
          this.jc.addJob(new ControlledJob(newJob,null));
          this.jobRunningTimes.put(jobIndex,runTimes + 1);
          this.jobIndexMap.put(newJob.getJobName(),jobIndex);
          jobsWithoutIds=this.jc.getWaitingJobList();
        }
 else {
          LOG.warn(""String_Node_Str"",jobName);
        }
      }
    }
    double prog=calculateProgress(jc,jobClient) / totalNeededMRJobs;
    notifyProgress(prog,lastProg);
    lastProg=prog;
    try {
      Thread.sleep(2 * 1000);
    }
 catch (    InterruptedException e) {
      Thread.currentThread().interrupt();
    }
  }
  List<ControlledJob> successfulJobs=jc.getSuccessfulJobList();
  List<ControlledJob> failedJobs=jc.getFailedJobList();
  LOG.debug(""String_Node_Str"",successfulJobs.size(),failedJobs.size(),totalNeededMRJobs);
  for (  ControlledJob controlledJob : successfulJobs) {
    LOG.info(""String_Node_Str"");
    LOG.info(""String_Node_Str"",controlledJob);
  }
  if (totalNeededMRJobs == successfulJobs.size()) {
    LOG.info(""String_Node_Str"");
    failedJobs=jc.getFailedJobList();
    if (failedJobs != null && failedJobs.size() > 0) {
      for (      ControlledJob controlledJob : failedJobs) {
        Counters counters=controlledJob.getJob().getCounters();
        if (counters != null) {
          Counter doneWorkers=counters.findCounter(GuaguaMapReduceConstants.GUAGUA_STATUS,GuaguaMapReduceConstants.DONE_WORKERS);
          if (doneWorkers != null && doneWorkers.getValue() > 0) {
            LOG.info(""String_Node_Str"");
            LOG.warn(""String_Node_Str"",toFakedStateString(controlledJob));
          }
 else {
            LOG.info(""String_Node_Str"");
            LOG.warn(""String_Node_Str"",controlledJob);
          }
        }
      }
    }
  }
 else {
    failedJobs=jc.getFailedJobList();
    if (failedJobs != null && failedJobs.size() > 0) {
      for (      ControlledJob controlledJob : failedJobs) {
        Counters counters=controlledJob.getJob().getCounters();
        if (counters != null) {
          Counter doneWorkers=counters.findCounter(GuaguaMapReduceConstants.GUAGUA_STATUS,GuaguaMapReduceConstants.DONE_WORKERS);
          if (doneWorkers != null && doneWorkers.getValue() > 0) {
            LOG.info(""String_Node_Str"");
            LOG.warn(""String_Node_Str"",toFakedStateString(controlledJob));
          }
 else {
            LOG.info(""String_Node_Str"");
            LOG.warn(""String_Node_Str"",controlledJob);
          }
        }
      }
    }
  }
  this.jc.stop();
}","/** 
 * Run all jobs added to JobControl.
 */
public void run() throws IOException {
  List<ControlledJob> jobsWithoutIds=this.jc.getWaitingJobList();
  int totalNeededMRJobs=jobsWithoutIds.size();
  LOG.info(""String_Node_Str"",jobsWithoutIds.size());
  Thread jcThread=new Thread(this.jc,""String_Node_Str"");
  jcThread.start();
  JobClient jobClient=new JobClient(new JobConf(new Configuration()));
  double lastProg=-1;
  Set<String> sucessfulJobs=new HashSet<String>();
  while (!this.jc.allFinished()) {
    try {
      jcThread.join(1000);
    }
 catch (    InterruptedException ignore) {
      Thread.currentThread().interrupt();
    }
    List<ControlledJob> jobsAssignedIdInThisRun=new ArrayList<ControlledJob>(totalNeededMRJobs);
    for (    ControlledJob job : jobsWithoutIds) {
      if (job.getJob().getJobID() != null) {
        jobsAssignedIdInThisRun.add(job);
        LOG.info(""String_Node_Str"",job.getJob().getJobID().toString());
      }
 else {
      }
    }
    jobsWithoutIds.removeAll(jobsAssignedIdInThisRun);
    List<ControlledJob> runningJobs=jc.getRunningJobList();
    for (    ControlledJob controlledJob : runningJobs) {
      String jobId=controlledJob.getJob().getJobID().toString();
      Counters counters=controlledJob.getJob().getCounters();
      Counter doneMaster=counters.findCounter(GuaguaMapReduceConstants.GUAGUA_STATUS,GuaguaMapReduceConstants.MASTER_SUCCESS);
      Counter doneWorkers=counters.findCounter(GuaguaMapReduceConstants.GUAGUA_STATUS,GuaguaMapReduceConstants.DONE_WORKERS);
      if ((doneMaster != null && doneMaster.getValue() > 0) || (doneWorkers != null && doneWorkers.getValue() > 0)) {
        Long initTime=firstMasterSuccessTimeMap.get(jobId);
        if (initTime == null) {
          firstMasterSuccessTimeMap.put(jobId,System.currentTimeMillis());
        }
 else {
          if (System.currentTimeMillis() - initTime >= 2 * 60 * 1000L) {
            killedSuccessJobSet.add(jobId);
            killJob(controlledJob.getJob().getConfiguration(),jobId,""String_Node_Str"");
            try {
              Thread.sleep(1 * 1000L);
            }
 catch (            InterruptedException e) {
              Thread.currentThread().interrupt();
            }
          }
        }
      }
    }
    List<ControlledJob> successfulJobs=jc.getSuccessfulJobList();
    for (    ControlledJob controlledJob : successfulJobs) {
      String jobId=controlledJob.getJob().getJobID().toString();
      if (!sucessfulJobs.contains(jobId)) {
        LOG.info(""String_Node_Str"",jobId);
        sucessfulJobs.add(jobId);
      }
    }
    List<ControlledJob> failedJobs=jc.getFailedJobList();
    for (    ControlledJob controlledJob : failedJobs) {
      String failedJobId=controlledJob.getJob().getJobID().toString();
      if (killedSuccessJobSet.contains(failedJobId)) {
        continue;
      }
      if (!this.failedCheckingJobs.contains(failedJobId)) {
        this.failedCheckingJobs.add(failedJobId);
        String jobName=controlledJob.getJob().getJobName();
        Integer jobIndex=this.jobIndexMap.get(jobName);
        Integer runTimes=this.jobRunningTimes.get(jobIndex);
        if (runTimes <= 1) {
          LOG.warn(""String_Node_Str"",jobName);
          Job newJob=createJob(this.jobIndexParams.get(jobIndex));
          this.jc.addJob(new ControlledJob(newJob,null));
          this.jobRunningTimes.put(jobIndex,runTimes + 1);
          this.jobIndexMap.put(newJob.getJobName(),jobIndex);
          jobsWithoutIds=this.jc.getWaitingJobList();
        }
 else {
          LOG.warn(""String_Node_Str"",jobName);
        }
      }
    }
    double prog=calculateProgress(jc,jobClient) / totalNeededMRJobs;
    notifyProgress(prog,lastProg);
    lastProg=prog;
    try {
      Thread.sleep(2 * 1000);
    }
 catch (    InterruptedException e) {
      Thread.currentThread().interrupt();
    }
  }
  List<ControlledJob> successfulJobs=jc.getSuccessfulJobList();
  List<ControlledJob> failedJobs=jc.getFailedJobList();
  LOG.debug(""String_Node_Str"",successfulJobs.size(),failedJobs.size(),totalNeededMRJobs);
  for (  ControlledJob controlledJob : successfulJobs) {
    LOG.info(""String_Node_Str"");
    LOG.info(""String_Node_Str"",controlledJob);
  }
  if (totalNeededMRJobs == successfulJobs.size()) {
    LOG.info(""String_Node_Str"");
    failedJobs=jc.getFailedJobList();
    if (failedJobs != null && failedJobs.size() > 0) {
      for (      ControlledJob controlledJob : failedJobs) {
        Counters counters=controlledJob.getJob().getCounters();
        if (counters != null) {
          Counter doneMaster=counters.findCounter(GuaguaMapReduceConstants.GUAGUA_STATUS,GuaguaMapReduceConstants.MASTER_SUCCESS);
          Counter doneWorkers=counters.findCounter(GuaguaMapReduceConstants.GUAGUA_STATUS,GuaguaMapReduceConstants.DONE_WORKERS);
          if ((doneMaster != null && doneMaster.getValue() > 0) || (doneWorkers != null && doneWorkers.getValue() > 0)) {
            LOG.info(""String_Node_Str"");
            LOG.warn(""String_Node_Str"",toFakedStateString(controlledJob));
          }
 else {
            LOG.info(""String_Node_Str"");
            LOG.warn(""String_Node_Str"",controlledJob);
          }
        }
      }
    }
  }
 else {
    failedJobs=jc.getFailedJobList();
    if (failedJobs != null && failedJobs.size() > 0) {
      for (      ControlledJob controlledJob : failedJobs) {
        Counters counters=controlledJob.getJob().getCounters();
        if (counters != null) {
          Counter doneWorkers=counters.findCounter(GuaguaMapReduceConstants.GUAGUA_STATUS,GuaguaMapReduceConstants.DONE_WORKERS);
          if (doneWorkers != null && doneWorkers.getValue() > 0) {
            LOG.info(""String_Node_Str"");
            LOG.warn(""String_Node_Str"",toFakedStateString(controlledJob));
          }
 else {
            LOG.info(""String_Node_Str"");
            LOG.warn(""String_Node_Str"",controlledJob);
          }
        }
      }
    }
  }
  this.jc.stop();
}",0.5808394160583942
80289,"private void killJob(Configuration conf){
  LOG.info(""String_Node_Str"");
  try {
    org.apache.hadoop.mapred.JobClient jobClient=new org.apache.hadoop.mapred.JobClient((org.apache.hadoop.mapred.JobConf)conf);
    JobID jobId=JobID.forName(conf.get(GuaguaMapReduceConstants.MAPRED_JOB_ID));
    RunningJob job=jobClient.getJob(jobId);
    job.killJob();
  }
 catch (  IOException ioe) {
    throw new GuaguaRuntimeException(ioe);
  }
}","@SuppressWarnings(""String_Node_Str"") private void killJob(Configuration conf){
  LOG.info(""String_Node_Str"");
  try {
    org.apache.hadoop.mapred.JobClient jobClient=new org.apache.hadoop.mapred.JobClient((org.apache.hadoop.mapred.JobConf)conf);
    JobID jobId=JobID.forName(conf.get(GuaguaMapReduceConstants.MAPRED_JOB_ID));
    RunningJob job=jobClient.getJob(jobId);
    job.killJob();
  }
 catch (  IOException ioe) {
    throw new GuaguaRuntimeException(ioe);
  }
}",0.9592061742006616
80290,"/** 
 * Run guagua service according   {@link #isMaster} setting. Iteration, coordination will be included in servicerunning. <p> {@link #cleanup(org.apache.hadoop.mapreduce.Mapper.Context)} is called in finally block to make sure resourcescan be cleaned. <p> Guagua try best to update progress for each iteration. And also task status will be updated in each iteration in hadoop job web ui.
 */
@Override public void run(final Context context) throws IOException, InterruptedException {
  Exception e=null;
  try {
    this.setup(context);
    final int iterations=context.getConfiguration().getInt(GuaguaConstants.GUAGUA_ITERATION_COUNT,-1);
    this.getGuaguaService().run(new Progressable(){
      @Override public void progress(      int iteration,      int totalIteration,      String status,      boolean isLastUpdate,      boolean isKill){
        if (isKill) {
          failTask(null,context.getConfiguration());
          return;
        }
        context.progress();
        GuaguaMRRecordReader.setCurrentIteration(iteration);
        try {
          context.nextKeyValue();
        }
 catch (        IOException e) {
          throw new GuaguaRuntimeException(e);
        }
catch (        InterruptedException e) {
          Thread.currentThread().interrupt();
        }
        if (isLastUpdate) {
          LOG.info(""String_Node_Str"",(iteration * 100 / iterations));
        }
        if (status != null && status.length() != 0) {
          context.setStatus(status);
        }
      }
    }
);
  }
 catch (  Throwable t) {
    LOG.error(""String_Node_Str"",t);
    failTask(t,context.getConfiguration());
    e=new GuaguaRuntimeException(t);
  }
 finally {
    try {
      this.cleanup(context);
    }
 catch (    Throwable t) {
      failTask(t,context.getConfiguration());
      e=new GuaguaRuntimeException(t);
    }
  }
  if (e == null && !this.isMaster) {
    context.getCounter(GuaguaMapReduceConstants.GUAGUA_STATUS,GuaguaMapReduceConstants.DONE_WORKERS).increment(1L);
  }
  if (e == null && this.isMaster) {
    context.getCounter(GuaguaMapReduceConstants.GUAGUA_STATUS,GuaguaMapReduceConstants.MASTER_SUCCESS).increment(1);
    LOG.info(""String_Node_Str"");
    if (!isJobFinised(context.getConfiguration(),context.getConfiguration().getInt(""String_Node_Str"",20))) {
      Thread.sleep(3 * 1000L);
      this.killJob(context.getConfiguration());
    }
 else {
      LOG.info(""String_Node_Str"");
    }
  }
}","/** 
 * Run guagua service according   {@link #isMaster} setting. Iteration, coordination will be included in servicerunning. <p> {@link #cleanup(org.apache.hadoop.mapreduce.Mapper.Context)} is called in finally block to make sure resourcescan be cleaned. <p> Guagua try best to update progress for each iteration. And also task status will be updated in each iteration in hadoop job web ui.
 */
@Override public void run(final Context context) throws IOException, InterruptedException {
  Exception e=null;
  try {
    this.setup(context);
    final int iterations=context.getConfiguration().getInt(GuaguaConstants.GUAGUA_ITERATION_COUNT,-1);
    this.getGuaguaService().run(new Progressable(){
      @Override public void progress(      int iteration,      int totalIteration,      String status,      boolean isLastUpdate,      boolean isKill){
        if (isKill) {
          failTask(null,context.getConfiguration());
          return;
        }
        context.progress();
        GuaguaMRRecordReader.setCurrentIteration(iteration);
        try {
          context.nextKeyValue();
        }
 catch (        IOException e) {
          throw new GuaguaRuntimeException(e);
        }
catch (        InterruptedException e) {
          Thread.currentThread().interrupt();
        }
        if (isLastUpdate) {
          LOG.info(""String_Node_Str"",(iteration * 100 / iterations));
        }
        if (status != null && status.length() != 0) {
          context.setStatus(status);
        }
      }
    }
);
  }
 catch (  Throwable t) {
    LOG.error(""String_Node_Str"",t);
    failTask(t,context.getConfiguration());
    e=new GuaguaRuntimeException(t);
  }
 finally {
    try {
      this.cleanup(context);
    }
 catch (    Throwable t) {
      failTask(t,context.getConfiguration());
      e=new GuaguaRuntimeException(t);
    }
  }
  if (e == null && !this.isMaster) {
    context.getCounter(GuaguaMapReduceConstants.GUAGUA_STATUS,GuaguaMapReduceConstants.DONE_WORKERS).increment(1L);
  }
  if (e == null && this.isMaster) {
    context.getCounter(GuaguaMapReduceConstants.GUAGUA_STATUS,GuaguaMapReduceConstants.MASTER_SUCCESS).increment(1);
  }
}",0.9397905759162304
80291,"/** 
 * Run all jobs added to JobControl.
 */
public void run() throws IOException {
  List<ControlledJob> jobsWithoutIds=this.jc.getWaitingJobList();
  int totalNeededMRJobs=jobsWithoutIds.size();
  LOG.info(""String_Node_Str"",jobsWithoutIds.size());
  Thread jcThread=new Thread(this.jc,""String_Node_Str"");
  jcThread.start();
  JobClient jobClient=new JobClient(new JobConf(new Configuration()));
  double lastProg=-1;
  Set<String> sucessfulJobs=new HashSet<String>();
  while (!this.jc.allFinished()) {
    try {
      jcThread.join(1000);
    }
 catch (    InterruptedException ignore) {
      Thread.currentThread().interrupt();
    }
    List<ControlledJob> jobsAssignedIdInThisRun=new ArrayList<ControlledJob>(totalNeededMRJobs);
    for (    ControlledJob job : jobsWithoutIds) {
      if (job.getJob().getJobID() != null) {
        jobsAssignedIdInThisRun.add(job);
        LOG.info(""String_Node_Str"",job.getJob().getJobID().toString());
      }
 else {
      }
    }
    jobsWithoutIds.removeAll(jobsAssignedIdInThisRun);
    List<ControlledJob> runningJobs=jc.getRunningJobList();
    for (    ControlledJob controlledJob : runningJobs) {
      String jobId=controlledJob.getJob().getJobID().toString();
      Counters counters=controlledJob.getJob().getCounters();
      Counter doneMaster=counters.findCounter(GuaguaMapReduceConstants.GUAGUA_STATUS,GuaguaMapReduceConstants.MASTER_SUCCESS);
      Counter doneWorkers=counters.findCounter(GuaguaMapReduceConstants.GUAGUA_STATUS,GuaguaMapReduceConstants.DONE_WORKERS);
      if ((doneMaster != null && doneMaster.getValue() > 0) || (doneWorkers != null && doneWorkers.getValue() > 0)) {
        Long initTime=firstMasterSuccessTimeMap.get(jobId);
        if (initTime == null) {
          firstMasterSuccessTimeMap.put(jobId,System.currentTimeMillis());
        }
 else {
          if (System.currentTimeMillis() - initTime >= 2 * 60 * 1000L) {
            killedSuccessJobSet.add(jobId);
            killJob(controlledJob.getJob().getConfiguration(),jobId,""String_Node_Str"");
            try {
              Thread.sleep(1 * 1000L);
            }
 catch (            InterruptedException e) {
              Thread.currentThread().interrupt();
            }
          }
        }
      }
    }
    List<ControlledJob> successfulJobs=jc.getSuccessfulJobList();
    for (    ControlledJob controlledJob : successfulJobs) {
      String jobId=controlledJob.getJob().getJobID().toString();
      if (!sucessfulJobs.contains(jobId)) {
        LOG.info(""String_Node_Str"",jobId);
        sucessfulJobs.add(jobId);
      }
    }
    List<ControlledJob> failedJobs=jc.getFailedJobList();
    for (    ControlledJob controlledJob : failedJobs) {
      String failedJobId=controlledJob.getJob().getJobID().toString();
      if (killedSuccessJobSet.contains(failedJobId)) {
        continue;
      }
      if (!this.failedCheckingJobs.contains(failedJobId)) {
        this.failedCheckingJobs.add(failedJobId);
        String jobName=controlledJob.getJob().getJobName();
        Integer jobIndex=this.jobIndexMap.get(jobName);
        Integer runTimes=this.jobRunningTimes.get(jobIndex);
        if (runTimes <= 1) {
          LOG.warn(""String_Node_Str"",jobName);
          Job newJob=createJob(this.jobIndexParams.get(jobIndex));
          this.jc.addJob(new ControlledJob(newJob,null));
          this.jobRunningTimes.put(jobIndex,runTimes + 1);
          this.jobIndexMap.put(newJob.getJobName(),jobIndex);
          jobsWithoutIds=this.jc.getWaitingJobList();
        }
 else {
          LOG.warn(""String_Node_Str"",jobName);
        }
      }
    }
    double prog=calculateProgress(jc,jobClient) / totalNeededMRJobs;
    notifyProgress(prog,lastProg);
    lastProg=prog;
    try {
      Thread.sleep(2 * 1000);
    }
 catch (    InterruptedException e) {
      Thread.currentThread().interrupt();
    }
  }
  List<ControlledJob> successfulJobs=jc.getSuccessfulJobList();
  List<ControlledJob> failedJobs=jc.getFailedJobList();
  LOG.debug(""String_Node_Str"",successfulJobs.size(),failedJobs.size(),totalNeededMRJobs);
  for (  ControlledJob controlledJob : successfulJobs) {
    LOG.info(""String_Node_Str"");
    LOG.info(""String_Node_Str"",controlledJob);
  }
  if (totalNeededMRJobs == successfulJobs.size()) {
    LOG.info(""String_Node_Str"");
    failedJobs=jc.getFailedJobList();
    if (failedJobs != null && failedJobs.size() > 0) {
      for (      ControlledJob controlledJob : failedJobs) {
        Counters counters=controlledJob.getJob().getCounters();
        if (counters != null) {
          Counter doneMaster=counters.findCounter(GuaguaMapReduceConstants.GUAGUA_STATUS,GuaguaMapReduceConstants.MASTER_SUCCESS);
          Counter doneWorkers=counters.findCounter(GuaguaMapReduceConstants.GUAGUA_STATUS,GuaguaMapReduceConstants.DONE_WORKERS);
          if ((doneMaster != null && doneMaster.getValue() > 0) || (doneWorkers != null && doneWorkers.getValue() > 0)) {
            LOG.info(""String_Node_Str"");
            LOG.warn(""String_Node_Str"",toFakedStateString(controlledJob));
          }
 else {
            LOG.info(""String_Node_Str"");
            LOG.warn(""String_Node_Str"",controlledJob);
          }
        }
      }
    }
  }
 else {
    failedJobs=jc.getFailedJobList();
    if (failedJobs != null && failedJobs.size() > 0) {
      for (      ControlledJob controlledJob : failedJobs) {
        Counters counters=controlledJob.getJob().getCounters();
        if (counters != null) {
          Counter doneMaster=counters.findCounter(GuaguaMapReduceConstants.GUAGUA_STATUS,GuaguaMapReduceConstants.MASTER_SUCCESS);
          Counter doneWorkers=counters.findCounter(GuaguaMapReduceConstants.GUAGUA_STATUS,GuaguaMapReduceConstants.DONE_WORKERS);
          if ((doneMaster != null && doneMaster.getValue() > 0) || (doneWorkers != null && doneWorkers.getValue() > 0)) {
            LOG.info(""String_Node_Str"");
            LOG.warn(""String_Node_Str"",toFakedStateString(controlledJob));
          }
 else {
            LOG.info(""String_Node_Str"");
            LOG.warn(""String_Node_Str"",controlledJob);
          }
        }
      }
    }
  }
  this.jc.stop();
}","/** 
 * Run all jobs added to JobControl.
 */
public void run() throws IOException {
  List<ControlledJob> jobsWithoutIds=this.jc.getWaitingJobList();
  int totalNeededMRJobs=jobsWithoutIds.size();
  LOG.info(""String_Node_Str"",jobsWithoutIds.size());
  Thread jcThread=new Thread(this.jc,""String_Node_Str"");
  jcThread.start();
  JobClient jobClient=new JobClient(new JobConf(new Configuration()));
  double lastProg=-1;
  Set<String> sucessfulJobs=new HashSet<String>();
  while (!this.jc.allFinished()) {
    try {
      jcThread.join(1000);
    }
 catch (    InterruptedException ignore) {
      Thread.currentThread().interrupt();
    }
    List<ControlledJob> jobsAssignedIdInThisRun=new ArrayList<ControlledJob>(totalNeededMRJobs);
    for (    ControlledJob job : jobsWithoutIds) {
      if (job.getJob().getJobID() != null) {
        jobsAssignedIdInThisRun.add(job);
        LOG.info(""String_Node_Str"",job.getJob().getJobID().toString());
      }
 else {
      }
    }
    jobsWithoutIds.removeAll(jobsAssignedIdInThisRun);
    List<ControlledJob> runningJobs=jc.getRunningJobList();
    for (    ControlledJob controlledJob : runningJobs) {
      String jobId=controlledJob.getJob().getJobID().toString();
      Counters counters=getCounters(controlledJob.getJob());
      Counter doneMaster=counters.findCounter(GuaguaMapReduceConstants.GUAGUA_STATUS,GuaguaMapReduceConstants.MASTER_SUCCESS);
      Counter doneWorkers=counters.findCounter(GuaguaMapReduceConstants.GUAGUA_STATUS,GuaguaMapReduceConstants.DONE_WORKERS);
      if ((doneMaster != null && doneMaster.getValue() > 0) || (doneWorkers != null && doneWorkers.getValue() > 0)) {
        Long initTime=firstMasterSuccessTimeMap.get(jobId);
        if (initTime == null) {
          firstMasterSuccessTimeMap.put(jobId,System.currentTimeMillis());
        }
 else {
          if (System.currentTimeMillis() - initTime >= 2 * 60 * 1000L) {
            killedSuccessJobSet.add(jobId);
            killJob(controlledJob.getJob().getConfiguration(),jobId,""String_Node_Str"" + jobId + ""String_Node_Str""+ jobId+ ""String_Node_Str"");
            try {
              Thread.sleep(1 * 1000L);
            }
 catch (            InterruptedException e) {
              Thread.currentThread().interrupt();
            }
          }
        }
      }
    }
    List<ControlledJob> successfulJobs=jc.getSuccessfulJobList();
    for (    ControlledJob controlledJob : successfulJobs) {
      String jobId=controlledJob.getJob().getJobID().toString();
      if (!sucessfulJobs.contains(jobId)) {
        LOG.info(""String_Node_Str"",jobId);
        sucessfulJobs.add(jobId);
      }
    }
    List<ControlledJob> failedJobs=jc.getFailedJobList();
    for (    ControlledJob controlledJob : failedJobs) {
      String failedJobId=controlledJob.getJob().getJobID().toString();
      if (killedSuccessJobSet.contains(failedJobId)) {
        if (!sucessfulJobs.contains(failedJobId)) {
          LOG.info(""String_Node_Str"",failedJobId);
          sucessfulJobs.add(failedJobId);
        }
        continue;
      }
      if (!this.failedCheckingJobs.contains(failedJobId)) {
        this.failedCheckingJobs.add(failedJobId);
        String jobName=controlledJob.getJob().getJobName();
        Integer jobIndex=this.jobIndexMap.get(jobName);
        Integer runTimes=this.jobRunningTimes.get(jobIndex);
        if (runTimes <= 1) {
          LOG.warn(""String_Node_Str"",jobName);
          Job newJob=createJob(this.jobIndexParams.get(jobIndex));
          this.jc.addJob(new ControlledJob(newJob,null));
          this.jobRunningTimes.put(jobIndex,runTimes + 1);
          this.jobIndexMap.put(newJob.getJobName(),jobIndex);
          jobsWithoutIds=this.jc.getWaitingJobList();
        }
 else {
          LOG.warn(""String_Node_Str"",jobName);
        }
      }
    }
    double prog=calculateProgress(jc,jobClient) / totalNeededMRJobs;
    notifyProgress(prog,lastProg);
    lastProg=prog;
    try {
      Thread.sleep(2 * 1000);
    }
 catch (    InterruptedException e) {
      Thread.currentThread().interrupt();
    }
  }
  List<ControlledJob> successfulJobs=jc.getSuccessfulJobList();
  List<ControlledJob> failedJobs=jc.getFailedJobList();
  LOG.debug(""String_Node_Str"",successfulJobs.size(),failedJobs.size(),totalNeededMRJobs);
  for (  ControlledJob controlledJob : successfulJobs) {
    LOG.info(""String_Node_Str"");
    LOG.info(""String_Node_Str"",controlledJob);
  }
  if (totalNeededMRJobs == successfulJobs.size()) {
    LOG.info(""String_Node_Str"");
    failedJobs=jc.getFailedJobList();
    if (failedJobs != null && failedJobs.size() > 0) {
      for (      ControlledJob controlledJob : failedJobs) {
        Counters counters=getCounters(controlledJob.getJob());
        if (counters != null) {
          Counter doneMaster=counters.findCounter(GuaguaMapReduceConstants.GUAGUA_STATUS,GuaguaMapReduceConstants.MASTER_SUCCESS);
          Counter doneWorkers=counters.findCounter(GuaguaMapReduceConstants.GUAGUA_STATUS,GuaguaMapReduceConstants.DONE_WORKERS);
          if ((doneMaster != null && doneMaster.getValue() > 0) || (doneWorkers != null && doneWorkers.getValue() > 0)) {
            LOG.info(""String_Node_Str"");
            LOG.warn(""String_Node_Str"",toFakedStateString(controlledJob));
          }
 else {
            LOG.info(""String_Node_Str"");
            LOG.warn(""String_Node_Str"",controlledJob);
          }
        }
      }
    }
  }
 else {
    failedJobs=jc.getFailedJobList();
    if (failedJobs != null && failedJobs.size() > 0) {
      for (      ControlledJob controlledJob : failedJobs) {
        Counters counters=getCounters(controlledJob.getJob());
        if (counters != null) {
          Counter doneMaster=counters.findCounter(GuaguaMapReduceConstants.GUAGUA_STATUS,GuaguaMapReduceConstants.MASTER_SUCCESS);
          Counter doneWorkers=counters.findCounter(GuaguaMapReduceConstants.GUAGUA_STATUS,GuaguaMapReduceConstants.DONE_WORKERS);
          if ((doneMaster != null && doneMaster.getValue() > 0) || (doneWorkers != null && doneWorkers.getValue() > 0)) {
            LOG.info(""String_Node_Str"");
            LOG.warn(""String_Node_Str"",toFakedStateString(controlledJob));
          }
 else {
            LOG.info(""String_Node_Str"");
            LOG.warn(""String_Node_Str"",controlledJob);
          }
        }
      }
    }
  }
  this.jc.stop();
}",0.9724226390893056
80292,"/** 
 * Start embed zookeeper server in a daemon thread.
 */
public static int startEmbedZooKeeper() throws IOException {
  final String zooKeeperWorkingDir=getZooKeeperWorkingDir();
  createFolder(zooKeeperWorkingDir);
  final String confName=zooKeeperWorkingDir + File.separator + ""String_Node_Str"";
  int validZkPort=getValidZooKeeperPort();
  prepZooKeeperConf(zooKeeperWorkingDir,confName,validZkPort + ""String_Node_Str"");
  Thread thread=new Thread(new Runnable(){
    @Override public void run(){
      QuorumPeerMain.main(new String[]{confName});
    }
  }
,""String_Node_Str"");
  thread.setDaemon(true);
  thread.start();
  Runtime.getRuntime().addShutdownHook(new Thread(new Runnable(){
    @Override public void run(){
      try {
        FileUtils.deleteDirectory(new File(zooKeeperWorkingDir));
      }
 catch (      IOException ignore) {
      }
    }
  }
));
  return validZkPort;
}","/** 
 * Start embed zookeeper server in a daemon thread.
 */
public static int startEmbedZooKeeper() throws IOException {
  String zooKeeperWorkingDir=getZooKeeperWorkingDir();
  boolean isSuccessful=createFolder(zooKeeperWorkingDir);
  if (!isSuccessful) {
    zooKeeperWorkingDir=getZooKeeperWorkingDir(""String_Node_Str"" + System.currentTimeMillis());
    createFolder(zooKeeperWorkingDir);
  }
  final String confName=zooKeeperWorkingDir + File.separator + ""String_Node_Str"";
  int validZkPort=getValidZooKeeperPort();
  prepZooKeeperConf(zooKeeperWorkingDir,confName,validZkPort + ""String_Node_Str"");
  Thread thread=new Thread(new Runnable(){
    @Override public void run(){
      QuorumPeerMain.main(new String[]{confName});
    }
  }
,""String_Node_Str"");
  thread.setDaemon(true);
  thread.start();
  final String cleanZkFolder=zooKeeperWorkingDir;
  Runtime.getRuntime().addShutdownHook(new Thread(new Runnable(){
    @Override public void run(){
      try {
        FileUtils.deleteDirectory(new File(cleanZkFolder));
      }
 catch (      IOException ignore) {
      }
    }
  }
));
  return validZkPort;
}",0.8574267262791853
80293,"/** 
 * Start embed zookeeper server in a child process.
 * @return null if start child process failed, non empty string if valid zookeeper server in child.
 */
public static String startChildZooKeeperProcess(String zkJavaOpts) throws IOException {
  final String zooKeeperWorkingDir=getZooKeeperWorkingDir();
  createFolder(zooKeeperWorkingDir);
  final String confName=zooKeeperWorkingDir + File.separator + ""String_Node_Str"";
  int validZkPort=getValidZooKeeperPort();
  prepZooKeeperConf(zooKeeperWorkingDir,confName,validZkPort + ""String_Node_Str"");
  ProcessBuilder processBuilder=new ProcessBuilder();
  List<String> commandList=new ArrayList<String>();
  String javaHome=System.getProperty(""String_Node_Str"");
  if (javaHome == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  commandList.add(javaHome + ""String_Node_Str"");
  String[] zkJavaOptsArray=zkJavaOpts.split(""String_Node_Str"");
  if (zkJavaOptsArray != null) {
    commandList.addAll(Arrays.asList(zkJavaOptsArray));
  }
  commandList.add(""String_Node_Str"");
  commandList.add(findContainingJar(Log4jLoggerAdapter.class) + ""String_Node_Str"" + findContainingJar(Logger.class)+ ""String_Node_Str""+ findContainingJar(org.apache.log4j.Logger.class)+ ""String_Node_Str""+ findContainingJar(ZooKeeperUtils.class)+ ""String_Node_Str""+ findContainingJar(QuorumPeerMain.class));
  commandList.add(ZooKeeperMain.class.getName());
  commandList.add(confName);
  processBuilder.command(commandList);
  File execDirectory=new File(zooKeeperWorkingDir);
  processBuilder.directory(execDirectory);
  processBuilder.redirectErrorStream(true);
  LOG.info(""String_Node_Str"",commandList,execDirectory.toString());
  Process zkProcess=null;
  StreamCollector zkProcessCollector;
synchronized (ZooKeeperUtils.class) {
    zkProcess=processBuilder.start();
    zkProcessCollector=new StreamCollector(zkProcess.getInputStream());
    zkProcessCollector.start();
  }
  Runtime.getRuntime().addShutdownHook(new Thread(new ZooKeeperShutdownHook(zkProcess,zkProcessCollector,zooKeeperWorkingDir)));
  LOG.info(""String_Node_Str"");
  String hostname=getLocalHostName();
  if (isServerAlive(hostname,validZkPort)) {
    return hostname + ""String_Node_Str"" + validZkPort;
  }
 else {
    return null;
  }
}","/** 
 * Start embed zookeeper server in a child process.
 * @return null if start child process failed, non empty string if valid zookeeper server in child.
 */
public static String startChildZooKeeperProcess(String zkJavaOpts) throws IOException {
  String zooKeeperWorkingDir=getZooKeeperWorkingDir();
  boolean isSuccessful=createFolder(zooKeeperWorkingDir);
  if (!isSuccessful) {
    zooKeeperWorkingDir=getZooKeeperWorkingDir(""String_Node_Str"" + System.currentTimeMillis());
    createFolder(zooKeeperWorkingDir);
  }
  final String confName=zooKeeperWorkingDir + File.separator + ""String_Node_Str"";
  int validZkPort=getValidZooKeeperPort();
  prepZooKeeperConf(zooKeeperWorkingDir,confName,validZkPort + ""String_Node_Str"");
  ProcessBuilder processBuilder=new ProcessBuilder();
  List<String> commandList=new ArrayList<String>();
  String javaHome=System.getProperty(""String_Node_Str"");
  if (javaHome == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  commandList.add(javaHome + ""String_Node_Str"");
  String[] zkJavaOptsArray=zkJavaOpts.split(""String_Node_Str"");
  if (zkJavaOptsArray != null) {
    commandList.addAll(Arrays.asList(zkJavaOptsArray));
  }
  commandList.add(""String_Node_Str"");
  commandList.add(findContainingJar(Log4jLoggerAdapter.class) + ""String_Node_Str"" + findContainingJar(Logger.class)+ ""String_Node_Str""+ findContainingJar(org.apache.log4j.Logger.class)+ ""String_Node_Str""+ findContainingJar(ZooKeeperUtils.class)+ ""String_Node_Str""+ findContainingJar(QuorumPeerMain.class));
  commandList.add(ZooKeeperMain.class.getName());
  commandList.add(confName);
  processBuilder.command(commandList);
  File execDirectory=new File(zooKeeperWorkingDir);
  processBuilder.directory(execDirectory);
  processBuilder.redirectErrorStream(true);
  LOG.info(""String_Node_Str"",commandList,execDirectory.toString());
  Process zkProcess=null;
  StreamCollector zkProcessCollector;
synchronized (ZooKeeperUtils.class) {
    zkProcess=processBuilder.start();
    zkProcessCollector=new StreamCollector(zkProcess.getInputStream());
    zkProcessCollector.start();
  }
  Runtime.getRuntime().addShutdownHook(new Thread(new ZooKeeperShutdownHook(zkProcess,zkProcessCollector,zooKeeperWorkingDir)));
  LOG.info(""String_Node_Str"");
  String hostname=getLocalHostName();
  if (isServerAlive(hostname,validZkPort)) {
    return hostname + ""String_Node_Str"" + validZkPort;
  }
 else {
    return null;
  }
}",0.9559855411439506
80294,"/** 
 * Retrieve zookeeper working folder.
 */
private static String getZooKeeperWorkingDir(){
  return getUserDir() + File.separator + ""String_Node_Str""+ System.currentTimeMillis();
}","/** 
 * Retrieve zookeeper working folder.
 */
private static String getZooKeeperWorkingDir(String subFolder){
  return getUserDir() + File.separator + subFolder;
}",0.8218390804597702
80295,"/** 
 * Create a folder with folder name, if exist, delete it firstly.
 */
private static void createFolder(String folder) throws IOException {
  File file=new File(folder);
  try {
    FileUtils.deleteDirectory(file);
  }
 catch (  IOException ignore) {
  }
  if (!file.mkdir()) {
    throw new IllegalStateException(""String_Node_Str"" + folder + ""String_Node_Str"");
  }
}","/** 
 * Create a folder with folder name, if exist, delete it firstly.
 */
private static boolean createFolder(String folder) throws IOException {
  File file=new File(folder);
  try {
    FileUtils.deleteDirectory(file);
  }
 catch (  IOException ignore) {
    return false;
  }
  return file.mkdir();
}",0.8047337278106509
80296,"@Override public WORKER_RESULT compute(WorkerContext<MASTER_RESULT,WORKER_RESULT> context) throws IOException {
  if (context.isFirstIteration()) {
    if (this.isLoaded.compareAndSet(false,true)) {
      init(context);
      long start=System.nanoTime();
      preLoad(context);
      long count=0;
      for (      GuaguaFileSplit fileSplit : context.getFileSplits()) {
        LOG.info(""String_Node_Str"",fileSplit);
        try {
          initRecordReader(fileSplit);
          while (getRecordReader().nextKeyValue()) {
            KEY currentKey=getRecordReader().getCurrentKey();
            VALUE currentValue=getRecordReader().getCurrentValue();
            doCompute(currentKey,currentValue,context);
            dataMap.put(currentKey,currentValue);
            ++count;
          }
        }
  finally {
          if (getRecordReader() != null) {
            getRecordReader().close();
          }
        }
      }
      postLoad(context);
      LOG.info(""String_Node_Str"",count);
      LOG.info(""String_Node_Str"",TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - start));
    }
  }
 else {
    long start=System.nanoTime();
    try {
      for (      Map.Entry<KEY,VALUE> entry : dataMap.entrySet()) {
        doCompute(entry.getKey(),entry.getValue(),context);
      }
    }
  finally {
      LOG.info(""String_Node_Str"",context.getAppId(),context.getContainerId(),context.getCurrentIteration(),TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - start));
    }
  }
  return context.getWorkerResult();
}","@Override public WORKER_RESULT compute(WorkerContext<MASTER_RESULT,WORKER_RESULT> context) throws IOException {
  if (context.isFirstIteration()) {
    if (this.isLoaded.compareAndSet(false,true)) {
      init(context);
      long start=System.nanoTime();
      preLoad(context);
      long count=0;
      for (      GuaguaFileSplit fileSplit : context.getFileSplits()) {
        LOG.info(""String_Node_Str"",fileSplit);
        try {
          initRecordReader(fileSplit);
          while (getRecordReader().nextKeyValue()) {
            KEY currentKey=getRecordReader().getCurrentKey();
            VALUE currentValue=getRecordReader().getCurrentValue();
            doCompute(currentKey,currentValue,context);
            dataMap.put(currentKey,currentValue);
            count+=1L;
          }
        }
  finally {
          if (getRecordReader() != null) {
            getRecordReader().close();
          }
        }
      }
      if (count == 0L) {
        throw new IllegalStateException(""String_Node_Str"");
      }
      postLoad(context);
      LOG.info(""String_Node_Str"",count);
      LOG.info(""String_Node_Str"",TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - start));
    }
  }
 else {
    long start=System.nanoTime();
    try {
      for (      Map.Entry<KEY,VALUE> entry : dataMap.entrySet()) {
        doCompute(entry.getKey(),entry.getValue(),context);
      }
    }
  finally {
      LOG.info(""String_Node_Str"",context.getAppId(),context.getContainerId(),context.getCurrentIteration(),TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - start));
    }
  }
  return context.getWorkerResult();
}",0.96576
80297,"@Override public WORKER_RESULT compute(WorkerContext<MASTER_RESULT,WORKER_RESULT> context) throws IOException {
  if (this.isLoaded.compareAndSet(false,true)) {
    init(context);
    long start=System.nanoTime();
    preLoad(context);
    long count=0;
    for (    GuaguaFileSplit fileSplit : context.getFileSplits()) {
      LOG.info(""String_Node_Str"",fileSplit);
      try {
        initRecordReader(fileSplit);
        LOG.info(""String_Node_Str"" + ""String_Node_Str"" + fileSplit.getExtension() + ""String_Node_Str""+ fileSplit);
        context.setAttachment(fileSplit.getExtension());
        while (getRecordReader().nextKeyValue()) {
          load(getRecordReader().getCurrentKey(),getRecordReader().getCurrentValue(),context);
          ++count;
        }
      }
  finally {
        if (getRecordReader() != null) {
          getRecordReader().close();
        }
      }
    }
    postLoad(context);
    LOG.info(""String_Node_Str"",count);
    LOG.info(""String_Node_Str"",TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - start));
  }
  long start=System.nanoTime();
  try {
    return doCompute(context);
  }
  finally {
    LOG.info(""String_Node_Str"",context.getAppId(),context.getContainerId(),context.getCurrentIteration(),TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - start));
  }
}","@Override public WORKER_RESULT compute(WorkerContext<MASTER_RESULT,WORKER_RESULT> context) throws IOException {
  if (this.isLoaded.compareAndSet(false,true)) {
    init(context);
    long start=System.nanoTime();
    preLoad(context);
    long count=0;
    for (    GuaguaFileSplit fileSplit : context.getFileSplits()) {
      LOG.info(""String_Node_Str"",fileSplit);
      try {
        initRecordReader(fileSplit);
        LOG.info(""String_Node_Str"",fileSplit.getExtension(),fileSplit);
        context.setAttachment(fileSplit.getExtension());
        while (getRecordReader().nextKeyValue()) {
          load(getRecordReader().getCurrentKey(),getRecordReader().getCurrentValue(),context);
          count+=1L;
        }
      }
  finally {
        if (getRecordReader() != null) {
          getRecordReader().close();
        }
      }
    }
    if (count == 0L) {
      throw new IllegalStateException(""String_Node_Str"");
    }
    postLoad(context);
    LOG.info(""String_Node_Str"",count);
    LOG.info(""String_Node_Str"",TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - start));
  }
  long start=System.nanoTime();
  try {
    return doCompute(context);
  }
  finally {
    LOG.info(""String_Node_Str"",context.getAppId(),context.getContainerId(),context.getCurrentIteration(),TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - start));
  }
}",0.943939393939394
80298,"/** 
 * Run all jobs added to JobControl.
 */
public void run() throws IOException {
  List<ControlledJob> jobsWithoutIds=this.jc.getWaitingJobList();
  int totalNeededMRJobs=jobsWithoutIds.size();
  LOG.info(""String_Node_Str"",jobsWithoutIds.size());
  Thread jcThread=new Thread(this.jc,""String_Node_Str"");
  jcThread.start();
  JobClient jobClient=new JobClient(new JobConf(new Configuration()));
  double lastProg=-1;
  Set<String> sucessfulJobs=new HashSet<String>();
  while (!this.jc.allFinished()) {
    try {
      jcThread.join(1000);
    }
 catch (    InterruptedException ignore) {
      Thread.currentThread().interrupt();
    }
    List<ControlledJob> jobsAssignedIdInThisRun=new ArrayList<ControlledJob>(totalNeededMRJobs);
    for (    ControlledJob job : jobsWithoutIds) {
      if (job.getJob().getJobID() != null) {
        jobsAssignedIdInThisRun.add(job);
        LOG.info(""String_Node_Str"",job.getJob().getJobID().toString());
      }
 else {
      }
    }
    jobsWithoutIds.removeAll(jobsAssignedIdInThisRun);
    List<ControlledJob> runningJobs=jc.getRunningJobList();
    for (    ControlledJob controlledJob : runningJobs) {
      String jobId=controlledJob.getJob().getJobID().toString();
      Counters counters=getCounters(controlledJob.getJob());
      Counter doneMaster=counters.findCounter(GuaguaMapReduceConstants.GUAGUA_STATUS,GuaguaMapReduceConstants.MASTER_SUCCESS);
      Counter doneWorkers=counters.findCounter(GuaguaMapReduceConstants.GUAGUA_STATUS,GuaguaMapReduceConstants.DONE_WORKERS);
      if ((doneMaster != null && doneMaster.getValue() > 0) || (doneWorkers != null && doneWorkers.getValue() > 0)) {
        Long initTime=firstMasterSuccessTimeMap.get(jobId);
        if (initTime == null) {
          firstMasterSuccessTimeMap.put(jobId,System.currentTimeMillis());
        }
 else {
          if (System.currentTimeMillis() - initTime >= 2 * 60 * 1000L) {
            killedSuccessJobSet.add(jobId);
            killJob(controlledJob.getJob().getConfiguration(),jobId,""String_Node_Str"" + jobId + ""String_Node_Str""+ jobId+ ""String_Node_Str"");
            try {
              Thread.sleep(1 * 1000L);
            }
 catch (            InterruptedException e) {
              Thread.currentThread().interrupt();
            }
          }
        }
      }
    }
    List<ControlledJob> successfulJobs=jc.getSuccessfulJobList();
    for (    ControlledJob controlledJob : successfulJobs) {
      String jobId=controlledJob.getJob().getJobID().toString();
      if (!sucessfulJobs.contains(jobId)) {
        LOG.info(""String_Node_Str"",jobId);
        sucessfulJobs.add(jobId);
      }
    }
    List<ControlledJob> failedJobs=jc.getFailedJobList();
    for (    ControlledJob controlledJob : failedJobs) {
      String failedJobId=controlledJob.getJob().getJobID().toString();
      if (killedSuccessJobSet.contains(failedJobId)) {
        if (!sucessfulJobs.contains(failedJobId)) {
          LOG.info(""String_Node_Str"",failedJobId);
          sucessfulJobs.add(failedJobId);
        }
        continue;
      }
      if (!this.failedCheckingJobs.contains(failedJobId)) {
        this.failedCheckingJobs.add(failedJobId);
        String jobName=controlledJob.getJob().getJobName();
        Integer jobIndex=this.jobIndexMap.get(jobName);
        Integer runTimes=this.jobRunningTimes.get(jobIndex);
        if (runTimes <= 1) {
          LOG.warn(""String_Node_Str"",jobName);
          Job newJob=createJob(this.jobIndexParams.get(jobIndex));
          this.jc.addJob(new ControlledJob(newJob,null));
          this.jobRunningTimes.put(jobIndex,runTimes + 1);
          this.jobIndexMap.put(newJob.getJobName(),jobIndex);
          jobsWithoutIds=this.jc.getWaitingJobList();
        }
 else {
          LOG.warn(""String_Node_Str"",jobName);
        }
      }
    }
    double prog=calculateProgress(jc,jobClient) / totalNeededMRJobs;
    notifyProgress(prog,lastProg);
    lastProg=prog;
    try {
      Thread.sleep(2 * 1000);
    }
 catch (    InterruptedException e) {
      Thread.currentThread().interrupt();
    }
  }
  List<ControlledJob> successfulJobs=jc.getSuccessfulJobList();
  List<ControlledJob> failedJobs=jc.getFailedJobList();
  LOG.debug(""String_Node_Str"",successfulJobs.size(),failedJobs.size(),totalNeededMRJobs);
  for (  ControlledJob controlledJob : successfulJobs) {
    LOG.info(""String_Node_Str"");
    LOG.info(""String_Node_Str"",controlledJob);
  }
  if (totalNeededMRJobs == successfulJobs.size()) {
    LOG.info(""String_Node_Str"");
    failedJobs=jc.getFailedJobList();
    if (failedJobs != null && failedJobs.size() > 0) {
      for (      ControlledJob controlledJob : failedJobs) {
        Counters counters=getCounters(controlledJob.getJob());
        if (counters != null) {
          Counter doneMaster=counters.findCounter(GuaguaMapReduceConstants.GUAGUA_STATUS,GuaguaMapReduceConstants.MASTER_SUCCESS);
          Counter doneWorkers=counters.findCounter(GuaguaMapReduceConstants.GUAGUA_STATUS,GuaguaMapReduceConstants.DONE_WORKERS);
          if ((doneMaster != null && doneMaster.getValue() > 0) || (doneWorkers != null && doneWorkers.getValue() > 0)) {
            LOG.info(""String_Node_Str"");
            LOG.warn(""String_Node_Str"",toFakedStateString(controlledJob));
          }
 else {
            LOG.info(""String_Node_Str"");
            LOG.warn(""String_Node_Str"",controlledJob);
          }
        }
      }
    }
  }
 else {
    failedJobs=jc.getFailedJobList();
    if (failedJobs != null && failedJobs.size() > 0) {
      for (      ControlledJob controlledJob : failedJobs) {
        Counters counters=getCounters(controlledJob.getJob());
        if (counters != null) {
          Counter doneMaster=counters.findCounter(GuaguaMapReduceConstants.GUAGUA_STATUS,GuaguaMapReduceConstants.MASTER_SUCCESS);
          Counter doneWorkers=counters.findCounter(GuaguaMapReduceConstants.GUAGUA_STATUS,GuaguaMapReduceConstants.DONE_WORKERS);
          if ((doneMaster != null && doneMaster.getValue() > 0) || (doneWorkers != null && doneWorkers.getValue() > 0)) {
            LOG.info(""String_Node_Str"");
            LOG.warn(""String_Node_Str"",toFakedStateString(controlledJob));
          }
 else {
            LOG.info(""String_Node_Str"");
            LOG.warn(""String_Node_Str"",controlledJob);
          }
        }
      }
    }
  }
  this.jc.stop();
}","/** 
 * Run all jobs added to JobControl.
 */
public void run() throws IOException {
  List<ControlledJob> jobsWithoutIds=this.jc.getWaitingJobList();
  int totalNeededMRJobs=jobsWithoutIds.size();
  LOG.info(""String_Node_Str"",jobsWithoutIds.size());
  Thread jcThread=new Thread(this.jc,""String_Node_Str"");
  jcThread.start();
  JobClient jobClient=new JobClient(new JobConf(new Configuration()));
  double lastProg=-1;
  Set<String> finalSucessfulJobIDs=new HashSet<String>();
  while (!this.jc.allFinished()) {
    try {
      jcThread.join(1000);
    }
 catch (    InterruptedException ignore) {
      Thread.currentThread().interrupt();
    }
    List<ControlledJob> jobsAssignedIdInThisRun=new ArrayList<ControlledJob>(totalNeededMRJobs);
    for (    ControlledJob job : jobsWithoutIds) {
      if (job.getJob().getJobID() != null) {
        jobsAssignedIdInThisRun.add(job);
        LOG.info(""String_Node_Str"",job.getJob().getJobID().toString());
      }
 else {
      }
    }
    jobsWithoutIds.removeAll(jobsAssignedIdInThisRun);
    List<ControlledJob> runningJobs=jc.getRunningJobList();
    for (    ControlledJob controlledJob : runningJobs) {
      String jobId=controlledJob.getJob().getJobID().toString();
      Counters counters=getCounters(controlledJob.getJob());
      Counter doneMaster=counters.findCounter(GuaguaMapReduceConstants.GUAGUA_STATUS,GuaguaMapReduceConstants.MASTER_SUCCESS);
      Counter doneWorkers=counters.findCounter(GuaguaMapReduceConstants.GUAGUA_STATUS,GuaguaMapReduceConstants.DONE_WORKERS);
      if ((doneMaster != null && doneMaster.getValue() > 0) || (doneWorkers != null && doneWorkers.getValue() > 0)) {
        Long initTime=firstMasterSuccessTimeMap.get(jobId);
        if (initTime == null) {
          firstMasterSuccessTimeMap.put(jobId,System.currentTimeMillis());
        }
 else {
          if (System.currentTimeMillis() - initTime >= 2 * 60 * 1000L) {
            killedSuccessJobSet.add(jobId);
            killJob(controlledJob.getJob().getConfiguration(),jobId,""String_Node_Str"" + jobId + ""String_Node_Str""+ jobId+ ""String_Node_Str"");
            try {
              Thread.sleep(1 * 1000L);
            }
 catch (            InterruptedException e) {
              Thread.currentThread().interrupt();
            }
          }
        }
      }
    }
    List<ControlledJob> successfulJobs=jc.getSuccessfulJobList();
    for (    ControlledJob controlledJob : successfulJobs) {
      String jobId=controlledJob.getJob().getJobID().toString();
      if (!finalSucessfulJobIDs.contains(jobId)) {
        LOG.info(""String_Node_Str"",jobId);
        finalSucessfulJobIDs.add(jobId);
      }
    }
    List<ControlledJob> failedJobs=jc.getFailedJobList();
    for (    ControlledJob controlledJob : failedJobs) {
      String failedJobId=controlledJob.getJob().getJobID().toString();
      if (killedSuccessJobSet.contains(failedJobId)) {
        if (!finalSucessfulJobIDs.contains(failedJobId)) {
          LOG.info(""String_Node_Str"",failedJobId);
          finalSucessfulJobIDs.add(failedJobId);
        }
        continue;
      }
      if (!this.failedCheckingJobs.contains(failedJobId)) {
        this.failedCheckingJobs.add(failedJobId);
        String jobName=controlledJob.getJob().getJobName();
        Integer jobIndex=this.jobIndexMap.get(jobName);
        Integer runTimes=this.jobRunningTimes.get(jobIndex);
        if (runTimes <= 1) {
          LOG.warn(""String_Node_Str"",jobName);
          Job newJob=createJob(this.jobIndexParams.get(jobIndex));
          this.jc.addJob(new ControlledJob(newJob,null));
          this.jobRunningTimes.put(jobIndex,runTimes + 1);
          this.jobIndexMap.put(newJob.getJobName(),jobIndex);
          jobsWithoutIds=this.jc.getWaitingJobList();
        }
 else {
          LOG.warn(""String_Node_Str"",jobName);
        }
      }
    }
    double prog=calculateProgress(finalSucessfulJobIDs,jc,jobClient) / totalNeededMRJobs;
    notifyProgress(prog,lastProg);
    lastProg=prog;
    try {
      Thread.sleep(2 * 1000);
    }
 catch (    InterruptedException e) {
      Thread.currentThread().interrupt();
    }
  }
  List<ControlledJob> successfulJobs=jc.getSuccessfulJobList();
  List<ControlledJob> failedJobs=jc.getFailedJobList();
  LOG.debug(""String_Node_Str"",successfulJobs.size(),failedJobs.size(),totalNeededMRJobs);
  for (  ControlledJob controlledJob : successfulJobs) {
    LOG.info(""String_Node_Str"");
    LOG.info(""String_Node_Str"",controlledJob);
  }
  if (totalNeededMRJobs == finalSucessfulJobIDs.size()) {
    LOG.info(""String_Node_Str"");
    if (failedJobs != null && failedJobs.size() > 0) {
      for (      ControlledJob controlledJob : failedJobs) {
        if (finalSucessfulJobIDs.contains(controlledJob.getJob().getJobID().toString())) {
          LOG.info(""String_Node_Str"");
          LOG.warn(""String_Node_Str"",toFakedStateString(controlledJob));
        }
      }
    }
  }
 else {
    if (failedJobs != null && failedJobs.size() > 0) {
      for (      ControlledJob controlledJob : failedJobs) {
        Counters counters=getCounters(controlledJob.getJob());
        if (counters != null) {
          Counter doneMaster=counters.findCounter(GuaguaMapReduceConstants.GUAGUA_STATUS,GuaguaMapReduceConstants.MASTER_SUCCESS);
          Counter doneWorkers=counters.findCounter(GuaguaMapReduceConstants.GUAGUA_STATUS,GuaguaMapReduceConstants.DONE_WORKERS);
          if ((doneMaster != null && doneMaster.getValue() > 0) || (doneWorkers != null && doneWorkers.getValue() > 0)) {
            LOG.info(""String_Node_Str"");
            LOG.warn(""String_Node_Str"",toFakedStateString(controlledJob));
          }
 else {
            LOG.info(""String_Node_Str"");
            LOG.warn(""String_Node_Str"",controlledJob);
          }
        }
      }
    }
  }
  this.jc.stop();
}",0.8746192475508356
80299,"/** 
 * Compute the progress of the current job submitted through the JobControl object jc to the JobClient jobClient
 * @param jc The JobControl object that has been submitted
 * @param jobClient The JobClient to which it has been submitted
 * @return The progress as a percentage in double format
 * @throws IOException In case any IOException connecting to JobTracker.
 */
protected double calculateProgress(JobControl jc,JobClient jobClient) throws IOException {
  double prog=0.0;
  prog+=jc.getSuccessfulJobList().size();
  List<ControlledJob> runnJobs=jc.getRunningJobList();
  for (  ControlledJob cjob : runnJobs) {
    prog+=progressOfRunningJob(cjob,jobClient);
  }
  return prog;
}","/** 
 * Compute the progress of the current job submitted through the JobControl object jc to the JobClient jobClient
 * @param jc The JobControl object that has been submitted
 * @param jobClient The JobClient to which it has been submitted
 * @return The progress as a percentage in double format
 * @throws IOException In case any IOException connecting to JobTracker.
 */
protected double calculateProgress(Set<String> successJobs,JobControl jc,JobClient jobClient) throws IOException {
  double prog=0.0;
  prog+=Math.max(jc.getSuccessfulJobList().size(),successJobs.size());
  List<ControlledJob> runnJobs=jc.getRunningJobList();
  for (  ControlledJob cjob : runnJobs) {
    prog+=progressOfRunningJob(cjob,jobClient);
  }
  return prog;
}",0.9631688672689368
80300,"@Override protected void setup(Context context) throws java.io.IOException, InterruptedException {
  GuaguaInputSplit inputSplit=(GuaguaInputSplit)context.getInputSplit();
  this.setMaster(inputSplit.isMaster());
  if (this.isMaster()) {
    context.setStatus(""String_Node_Str"");
    this.setGuaguaService(new GuaguaMasterService<MASTER_RESULT,WORKER_RESULT>());
  }
 else {
    context.setStatus(""String_Node_Str"");
    this.setGuaguaService(new GuaguaWorkerService<MASTER_RESULT,WORKER_RESULT>());
    List<GuaguaFileSplit> splits=new LinkedList<GuaguaFileSplit>();
    for (int i=0; i < inputSplit.getFileSplits().length; i++) {
      FileSplit fs=inputSplit.getFileSplits()[i];
      GuaguaFileSplit gfs=new GuaguaFileSplit(fs.getPath().toString(),fs.getStart(),fs.getLength());
      if (inputSplit.getExtensions() != null && i < inputSplit.getExtensions().length) {
        LOG.info(""String_Node_Str"" + inputSplit + ""String_Node_Str""+ i+ ""String_Node_Str""+ inputSplit.getExtensions()[i]);
        gfs.setExtension(inputSplit.getExtensions()[i]);
      }
      splits.add(gfs);
    }
    this.getGuaguaService().setSplits(splits);
  }
  Properties props=replaceConfToProps(context.getConfiguration());
  this.getGuaguaService().setAppId(context.getConfiguration().get(GuaguaMapReduceConstants.MAPRED_JOB_ID));
  this.getGuaguaService().setContainerId(context.getConfiguration().get(GuaguaMapReduceConstants.MAPRED_TASK_PARTITION));
  this.getGuaguaService().init(props);
  this.getGuaguaService().start();
}","@Override protected void setup(Context context) throws java.io.IOException, InterruptedException {
  GuaguaInputSplit inputSplit=(GuaguaInputSplit)context.getInputSplit();
  this.setMaster(inputSplit.isMaster());
  if (this.isMaster()) {
    context.setStatus(""String_Node_Str"");
    this.setGuaguaService(new GuaguaMasterService<MASTER_RESULT,WORKER_RESULT>());
  }
 else {
    context.setStatus(""String_Node_Str"");
    this.setGuaguaService(new GuaguaWorkerService<MASTER_RESULT,WORKER_RESULT>());
    List<GuaguaFileSplit> splits=new LinkedList<GuaguaFileSplit>();
    for (int i=0; i < inputSplit.getFileSplits().length; i++) {
      FileSplit fs=inputSplit.getFileSplits()[i];
      GuaguaFileSplit gfs=new GuaguaFileSplit(fs.getPath().toString(),fs.getStart(),fs.getLength());
      if (inputSplit.getExtensions() != null && i < inputSplit.getExtensions().length) {
        gfs.setExtension(inputSplit.getExtensions()[i]);
      }
      splits.add(gfs);
    }
    this.getGuaguaService().setSplits(splits);
  }
  Properties props=replaceConfToProps(context.getConfiguration());
  this.getGuaguaService().setAppId(context.getConfiguration().get(GuaguaMapReduceConstants.MAPRED_JOB_ID));
  this.getGuaguaService().setContainerId(context.getConfiguration().get(GuaguaMapReduceConstants.MAPRED_TASK_PARTITION));
  this.getGuaguaService().init(props);
  this.getGuaguaService().start();
}",0.9576008273009308
80301,"/** 
 * Update master computable result to master znode. At the same time clean znodes for old iterations. Iteration 0 and last iteration will not be removed for fail over.
 */
@Override public void postIteration(final MasterContext<MASTER_RESULT,WORKER_RESULT> context){
  context.setWorkerResults(null);
  new BasicCoordinatorCommand(){
    @Override public void doExecute() throws KeeperException, InterruptedException {
      NettyMasterCoordinator.this.masterResult=context.getMasterResult();
      updateMasterHaltStatus(context);
      boolean isSplit=false;
      String appCurrentMasterNode=getCurrentMasterNode(context.getAppId(),context.getCurrentIteration()).toString();
      String appCurrentMasterSplitNode=getCurrentMasterSplitNode(context.getAppId(),context.getCurrentIteration()).toString();
      LOG.debug(""String_Node_Str"",context.getMasterResult());
      final long start=System.nanoTime();
      try {
        byte[] bytes=getMasterSerializer().objectToBytes(context.getMasterResult());
        isSplit=setBytesToZNode(appCurrentMasterNode,appCurrentMasterSplitNode,bytes,CreateMode.PERSISTENT);
synchronized (LOCK) {
          clear(context.getProps());
          NettyMasterCoordinator.this.currentInteration=context.getCurrentIteration() + 1;
          NettyMasterCoordinator.this.canUpdateWorkerResultMap=true;
        }
      }
 catch (      KeeperException.NodeExistsException e) {
        LOG.warn(""String_Node_Str"",e);
      }
      LOG.info(""String_Node_Str"",TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - start));
      final int resultCleanUpInterval=NumberFormatUtils.getInt(context.getProps().getProperty(GuaguaConstants.GUAGUA_CLEANUP_INTERVAL),GuaguaConstants.GUAGUA_DEFAULT_CLEANUP_INTERVAL);
      if (context.getCurrentIteration() >= (resultCleanUpInterval + 1)) {
        final boolean isLocalSplit=isSplit;
        NettyMasterCoordinator.this.cleanOldZkDataThreadPool.submit(new Runnable(){
          @Override public void run(){
            String znode=getMasterNode(context.getAppId(),context.getCurrentIteration() - resultCleanUpInterval).toString();
            try {
              getZooKeeper().deleteExt(znode,-1,false);
              if (isLocalSplit) {
                znode=getCurrentMasterSplitNode(context.getAppId(),context.getCurrentIteration() - resultCleanUpInterval).toString();
                getZooKeeper().deleteExt(znode,-1,true);
              }
            }
 catch (            KeeperException.NoNodeException e) {
              if (System.nanoTime() % 20 == 0) {
                LOG.warn(""String_Node_Str"",znode);
              }
            }
catch (            KeeperException ignore) {
            }
catch (            InterruptedException ignore) {
            }
          }
        }
);
      }
      LOG.info(""String_Node_Str"");
    }
  }
.execute();
}","/** 
 * Update master computable result to master znode. At the same time clean znodes for old iterations. Iteration 0 and last iteration will not be removed for fail over.
 */
@Override public void postIteration(final MasterContext<MASTER_RESULT,WORKER_RESULT> context){
  context.setWorkerResults(null);
  new BasicCoordinatorCommand(){
    @Override public void doExecute() throws KeeperException, InterruptedException {
      NettyMasterCoordinator.this.masterResult=context.getMasterResult();
      updateMasterHaltStatus(context);
      boolean isSplit=false;
      String appCurrentMasterNode=getCurrentMasterNode(context.getAppId(),context.getCurrentIteration()).toString();
      String appCurrentMasterSplitNode=getCurrentMasterSplitNode(context.getAppId(),context.getCurrentIteration()).toString();
      LOG.debug(""String_Node_Str"",context.getMasterResult());
      final long start=System.nanoTime();
      try {
        byte[] bytes=getMasterSerializer().objectToBytes(context.getMasterResult());
        isSplit=setBytesToZNode(appCurrentMasterNode,appCurrentMasterSplitNode,bytes,CreateMode.PERSISTENT);
synchronized (LOCK) {
          clear(context.getProps());
          NettyMasterCoordinator.this.currentInteration=context.getCurrentIteration() + 1;
          NettyMasterCoordinator.this.canUpdateWorkerResultMap=true;
        }
      }
 catch (      KeeperException.NodeExistsException e) {
        LOG.warn(""String_Node_Str"",e);
      }
      LOG.info(""String_Node_Str"",TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - start));
      final int resultCleanUpInterval=NumberFormatUtils.getInt(context.getProps().getProperty(GuaguaConstants.GUAGUA_CLEANUP_INTERVAL),GuaguaConstants.GUAGUA_DEFAULT_CLEANUP_INTERVAL);
      if (context.getCurrentIteration() >= (resultCleanUpInterval + 1)) {
        final boolean isLocalSplit=isSplit;
        NettyMasterCoordinator.this.cleanOldZkDataThreadPool.submit(new Runnable(){
          @Override public void run(){
            String znode=getMasterNode(context.getAppId(),context.getCurrentIteration() - resultCleanUpInterval).toString();
            try {
              getZooKeeper().deleteExt(znode,-1,false);
              if (isLocalSplit) {
                znode=getCurrentMasterSplitNode(context.getAppId(),context.getCurrentIteration() - resultCleanUpInterval).toString();
                getZooKeeper().deleteExt(znode,-1,true);
              }
            }
 catch (            KeeperException.NoNodeException e) {
              if (System.nanoTime() % 20 == 0) {
                LOG.warn(""String_Node_Str"",znode);
              }
            }
catch (            KeeperException ignore) {
            }
catch (            InterruptedException ignore) {
            }
          }
        }
);
      }
      LOG.debug(""String_Node_Str"");
    }
  }
.execute();
}",0.9984112974404236
80302,"/** 
 * Wait for all workers done in current iteration.
 */
@Override public void preIteration(final MasterContext<MASTER_RESULT,WORKER_RESULT> context){
synchronized (LOCK) {
    this.currentInteration=context.getCurrentIteration();
    this.canUpdateWorkerResultMap=true;
  }
  long start=System.nanoTime();
  new RetryCoordinatorCommand(isFixedTime(),getSleepTime()){
    /** 
 * Next index to for logging
 */
    private int nextIndex=0;
    @Override public boolean retryExecution() throws KeeperException, InterruptedException {
      int doneWorkers;
synchronized (LOCK) {
        doneWorkers=(int)NettyMasterCoordinator.this.iterResults.size();
      }
      int[] dumpArray={context.getWorkers() / 5,context.getWorkers() * 2 / 5,context.getWorkers() * 3 / 5,context.getWorkers() * 4 / 5,context.getWorkers()};
      for (int i=nextIndex; i < dumpArray.length; i++) {
        if (doneWorkers >= dumpArray[i]) {
          nextIndex=i + 1;
          LOG.info(""String_Node_Str"",context.getCurrentIteration(),doneWorkers,(context.getWorkers() - doneWorkers));
        }
      }
      if (System.nanoTime() % 100 == 0) {
        LOG.info(""String_Node_Str"",context.getCurrentIteration(),doneWorkers,(context.getWorkers() - doneWorkers));
      }
      long timeOut=0L;
      if (context.isFirstIteration() || context.getCurrentIteration() == context.getTotalIteration()) {
        timeOut=GuaguaConstants.GUAGUA_DEFAULT_MIN_WORKERS_TIMEOUT;
      }
 else {
        timeOut=context.getMinWorkersTimeOut();
      }
      boolean isTerminated=isTerminated(doneWorkers,context.getWorkers(),context.getMinWorkersRatio(),timeOut);
      if (isTerminated) {
synchronized (LOCK) {
          NettyMasterCoordinator.this.canUpdateWorkerResultMap=false;
        }
        LOG.info(""String_Node_Str"" + ""String_Node_Str"",context.getCurrentIteration(),context.getWorkers(),doneWorkers,context.getMinWorkersRatio(),GuaguaConstants.GUAGUA_DEFAULT_MIN_WORKERS_TIMEOUT);
      }
      return isTerminated;
    }
  }
.execute();
synchronized (LOCK) {
    this.canUpdateWorkerResultMap=false;
    this.iterResults.switchState();
  }
  if (this.iterResults instanceof BytableMemoryDiskList) {
    LOG.info(""String_Node_Str"",this.currentInteration,((BytableMemoryDiskList<WorkerResultWrapper>)this.iterResults).getMemoryCount());
    LOG.info(""String_Node_Str"",this.currentInteration,((BytableMemoryDiskList<WorkerResultWrapper>)this.iterResults).getDiskCount());
  }
 else {
    LOG.info(""String_Node_Str"",this.currentInteration,((MergeWorkerResultList)this.iterResults).size(),((MergeWorkerResultList)this.iterResults).mergedSize());
  }
  final int currentIter=this.currentInteration;
  context.setWorkerResults(new Iterable<WORKER_RESULT>(){
    @Override public Iterator<WORKER_RESULT> iterator(){
      return new Iterator<WORKER_RESULT>(){
        private Iterator<WorkerResultWrapper> localItr;
        private volatile AtomicBoolean isStart=new AtomicBoolean();
        WorkerResultWrapper current=null;
        @Override public boolean hasNext(){
          boolean hasNext;
synchronized (LOCK) {
            if (this.isStart.compareAndSet(false,true)) {
              this.localItr=NettyMasterCoordinator.this.iterResults.iterator();
            }
            hasNext=this.localItr.hasNext();
            if (hasNext) {
              this.current=this.localItr.next();
              while (this.current.currIter != currentIter) {
                hasNext=this.localItr.hasNext();
                if (hasNext) {
                  this.current=this.localItr.next();
                  continue;
                }
 else {
                  break;
                }
              }
            }
            if (!hasNext) {
              this.localItr=NettyMasterCoordinator.this.iterResults.iterator();
              return false;
            }
          }
          return hasNext;
        }
        @SuppressWarnings(""String_Node_Str"") @Override public WORKER_RESULT next(){
synchronized (LOCK) {
            return (WORKER_RESULT)this.current.workerResult;
          }
        }
        @Override public void remove(){
          throw new UnsupportedOperationException();
        }
      }
;
    }
  }
);
  LOG.info(""String_Node_Str"",context.getAppId(),context.getContainerId(),context.getCurrentIteration(),TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - start));
}","/** 
 * Wait for all workers done in current iteration.
 */
@Override public void preIteration(final MasterContext<MASTER_RESULT,WORKER_RESULT> context){
synchronized (LOCK) {
    this.currentInteration=context.getCurrentIteration();
    this.canUpdateWorkerResultMap=true;
  }
  long start=System.nanoTime();
  new RetryCoordinatorCommand(isFixedTime(),getSleepTime()){
    /** 
 * Next index to for logging
 */
    private int nextIndex=0;
    @Override public boolean retryExecution() throws KeeperException, InterruptedException {
      int doneWorkers;
synchronized (LOCK) {
        doneWorkers=(int)NettyMasterCoordinator.this.iterResults.size();
      }
      int[] dumpArray={context.getWorkers() / 4,context.getWorkers() * 2 / 4,context.getWorkers() * 3 / 4,context.getWorkers()};
      for (int i=nextIndex; i < dumpArray.length; i++) {
        if (doneWorkers >= dumpArray[i]) {
          nextIndex=i + 1;
          LOG.info(""String_Node_Str"",context.getCurrentIteration(),doneWorkers,(context.getWorkers() - doneWorkers));
        }
      }
      long timeOut=0L;
      if (context.isFirstIteration() || context.getCurrentIteration() == context.getTotalIteration()) {
        timeOut=GuaguaConstants.GUAGUA_DEFAULT_MIN_WORKERS_TIMEOUT;
      }
 else {
        timeOut=context.getMinWorkersTimeOut();
      }
      boolean isTerminated=isTerminated(doneWorkers,context.getWorkers(),context.getMinWorkersRatio(),timeOut);
      if (isTerminated) {
synchronized (LOCK) {
          NettyMasterCoordinator.this.canUpdateWorkerResultMap=false;
        }
        LOG.info(""String_Node_Str"" + ""String_Node_Str"",context.getCurrentIteration(),context.getWorkers(),doneWorkers,context.getMinWorkersRatio(),GuaguaConstants.GUAGUA_DEFAULT_MIN_WORKERS_TIMEOUT);
      }
      return isTerminated;
    }
  }
.execute();
synchronized (LOCK) {
    this.canUpdateWorkerResultMap=false;
    this.iterResults.switchState();
  }
  if (this.iterResults instanceof BytableMemoryDiskList) {
    LOG.info(""String_Node_Str"",this.currentInteration,((BytableMemoryDiskList<WorkerResultWrapper>)this.iterResults).getMemoryCount());
    LOG.info(""String_Node_Str"",this.currentInteration,((BytableMemoryDiskList<WorkerResultWrapper>)this.iterResults).getDiskCount());
  }
 else {
    LOG.info(""String_Node_Str"",this.currentInteration,((MergeWorkerResultList)this.iterResults).size(),((MergeWorkerResultList)this.iterResults).mergedSize());
  }
  final int currentIter=this.currentInteration;
  context.setWorkerResults(new Iterable<WORKER_RESULT>(){
    @Override public Iterator<WORKER_RESULT> iterator(){
      return new Iterator<WORKER_RESULT>(){
        private Iterator<WorkerResultWrapper> localItr;
        private volatile AtomicBoolean isStart=new AtomicBoolean();
        WorkerResultWrapper current=null;
        @Override public boolean hasNext(){
          boolean hasNext;
synchronized (LOCK) {
            if (this.isStart.compareAndSet(false,true)) {
              this.localItr=NettyMasterCoordinator.this.iterResults.iterator();
            }
            hasNext=this.localItr.hasNext();
            if (hasNext) {
              this.current=this.localItr.next();
              while (this.current.currIter != currentIter) {
                hasNext=this.localItr.hasNext();
                if (hasNext) {
                  this.current=this.localItr.next();
                  continue;
                }
 else {
                  break;
                }
              }
            }
            if (!hasNext) {
              this.localItr=NettyMasterCoordinator.this.iterResults.iterator();
              return false;
            }
          }
          return hasNext;
        }
        @SuppressWarnings(""String_Node_Str"") @Override public WORKER_RESULT next(){
synchronized (LOCK) {
            return (WORKER_RESULT)this.current.workerResult;
          }
        }
        @Override public void remove(){
          throw new UnsupportedOperationException();
        }
      }
;
    }
  }
);
  LOG.info(""String_Node_Str"",context.getAppId(),context.getContainerId(),context.getCurrentIteration(),TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - start));
}",0.9766349653633908
80303,"/** 
 * Start embed zookeeper server in a child process.
 * @return null if start child process failed, non empty string if valid zookeeper server in child.
 */
public static String startChildZooKeeperProcess(String zkJavaOpts) throws IOException {
  final String zooKeeperWorkingDir=getZooKeeperWorkingDir();
  createFolder(zooKeeperWorkingDir);
  final String confName=zooKeeperWorkingDir + File.separator + ""String_Node_Str"";
  int validZkPort=getValidZooKeeperPort();
  prepZooKeeperConf(confName,validZkPort + ""String_Node_Str"");
  ProcessBuilder processBuilder=new ProcessBuilder();
  List<String> commandList=new ArrayList<String>();
  String javaHome=System.getProperty(""String_Node_Str"");
  if (javaHome == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  commandList.add(javaHome + ""String_Node_Str"");
  String[] zkJavaOptsArray=zkJavaOpts.split(""String_Node_Str"");
  if (zkJavaOptsArray != null) {
    commandList.addAll(Arrays.asList(zkJavaOptsArray));
  }
  commandList.add(""String_Node_Str"");
  commandList.add(findContainingJar(Log4jLoggerAdapter.class) + ""String_Node_Str"" + findContainingJar(Logger.class)+ ""String_Node_Str""+ findContainingJar(org.apache.log4j.Logger.class)+ ""String_Node_Str""+ findContainingJar(QuorumPeerMain.class));
  commandList.add(QuorumPeerMain.class.getName());
  commandList.add(confName);
  processBuilder.command(commandList);
  File execDirectory=new File(zooKeeperWorkingDir);
  processBuilder.directory(execDirectory);
  processBuilder.redirectErrorStream(true);
  LOG.info(""String_Node_Str"",commandList,execDirectory.toString());
  Process zkProcess=null;
  StreamCollector zkProcessCollector;
synchronized (ZooKeeperUtils.class) {
    zkProcess=processBuilder.start();
    zkProcessCollector=new StreamCollector(zkProcess.getInputStream());
    zkProcessCollector.start();
  }
  Runtime.getRuntime().addShutdownHook(new Thread(new ZooKeeperShutdownHook(zkProcess,zkProcessCollector,zooKeeperWorkingDir)));
  LOG.info(""String_Node_Str"");
  String hostname=getLocalHostName();
  if (isServerAlive(hostname,validZkPort)) {
    return hostname + ""String_Node_Str"" + validZkPort;
  }
 else {
    return null;
  }
}","/** 
 * Start embed zookeeper server in a child process.
 * @return null if start child process failed, non empty string if valid zookeeper server in child.
 */
public static String startChildZooKeeperProcess(String zkJavaOpts) throws IOException {
  final String zooKeeperWorkingDir=getZooKeeperWorkingDir();
  createFolder(zooKeeperWorkingDir);
  final String confName=zooKeeperWorkingDir + File.separator + ""String_Node_Str"";
  int validZkPort=getValidZooKeeperPort();
  prepZooKeeperConf(confName,validZkPort + ""String_Node_Str"");
  ProcessBuilder processBuilder=new ProcessBuilder();
  List<String> commandList=new ArrayList<String>();
  String javaHome=System.getProperty(""String_Node_Str"");
  if (javaHome == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  commandList.add(javaHome + ""String_Node_Str"");
  String[] zkJavaOptsArray=zkJavaOpts.split(""String_Node_Str"");
  if (zkJavaOptsArray != null) {
    commandList.addAll(Arrays.asList(zkJavaOptsArray));
  }
  commandList.add(""String_Node_Str"");
  commandList.add(findContainingJar(Log4jLoggerAdapter.class) + ""String_Node_Str"" + findContainingJar(Logger.class)+ ""String_Node_Str""+ findContainingJar(org.apache.log4j.Logger.class)+ ""String_Node_Str""+ findContainingJar(ZooKeeperUtils.class)+ ""String_Node_Str""+ findContainingJar(QuorumPeerMain.class));
  commandList.add(QuorumPeerMain.class.getName());
  commandList.add(confName);
  processBuilder.command(commandList);
  File execDirectory=new File(zooKeeperWorkingDir);
  processBuilder.directory(execDirectory);
  processBuilder.redirectErrorStream(true);
  LOG.info(""String_Node_Str"",commandList,execDirectory.toString());
  Process zkProcess=null;
  StreamCollector zkProcessCollector;
synchronized (ZooKeeperUtils.class) {
    zkProcess=processBuilder.start();
    zkProcessCollector=new StreamCollector(zkProcess.getInputStream());
    zkProcessCollector.start();
  }
  Runtime.getRuntime().addShutdownHook(new Thread(new ZooKeeperShutdownHook(zkProcess,zkProcessCollector,zooKeeperWorkingDir)));
  LOG.info(""String_Node_Str"");
  String hostname=getLocalHostName();
  if (isServerAlive(hostname,validZkPort)) {
    return hostname + ""String_Node_Str"" + validZkPort;
  }
 else {
    return null;
  }
}",0.986449864498645
80304,"/** 
 * Run all jobs added to JobControl.
 */
public void run() throws IOException {
  List<ControlledJob> jobsWithoutIds=this.jc.getWaitingJobList();
  int totalNeededMRJobs=jobsWithoutIds.size();
  LOG.info(""String_Node_Str"",jobsWithoutIds.size());
  Thread jcThread=new Thread(this.jc,""String_Node_Str"");
  jcThread.start();
  JobClient jobClient=new JobClient(new JobConf(new Configuration()));
  double lastProg=-1;
  Set<String> sucessfulJobs=new HashSet<String>();
  while (!this.jc.allFinished()) {
    try {
      jcThread.join(1000);
    }
 catch (    InterruptedException ignore) {
      Thread.currentThread().interrupt();
    }
    List<ControlledJob> jobsAssignedIdInThisRun=new ArrayList<ControlledJob>(totalNeededMRJobs);
    for (    ControlledJob job : jobsWithoutIds) {
      if (job.getJob().getJobID() != null) {
        jobsAssignedIdInThisRun.add(job);
        LOG.info(""String_Node_Str"",job.getJob().getJobID().toString());
      }
 else {
      }
    }
    jobsWithoutIds.removeAll(jobsAssignedIdInThisRun);
    List<ControlledJob> runningJobs=jc.getRunningJobList();
    for (    ControlledJob controlledJob : runningJobs) {
      String jobId=controlledJob.getJob().getJobID().toString();
      Counters counters=controlledJob.getJob().getCounters();
      Counter doneMaster=counters.findCounter(GuaguaMapReduceConstants.GUAGUA_STATUS,GuaguaMapReduceConstants.MASTER_SUCCESS);
      Counter doneWorkers=counters.findCounter(GuaguaMapReduceConstants.GUAGUA_STATUS,GuaguaMapReduceConstants.DONE_WORKERS);
      if ((doneMaster != null && doneMaster.getValue() > 0) || (doneWorkers != null && doneWorkers.getValue() > 0)) {
        Long initTime=firstMasterSuccessTimeMap.get(jobId);
        if (initTime == null) {
          firstMasterSuccessTimeMap.put(jobId,System.currentTimeMillis());
        }
 else {
          if (System.currentTimeMillis() - initTime >= 2 * 60 * 1000L) {
            killedSuccessJobSet.add(jobId);
            killJob(controlledJob.getJob().getConfiguration(),jobId,""String_Node_Str"");
            try {
              Thread.sleep(1 * 1000L);
            }
 catch (            InterruptedException e) {
              Thread.currentThread().interrupt();
            }
          }
        }
      }
    }
    List<ControlledJob> successfulJobs=jc.getSuccessfulJobList();
    for (    ControlledJob controlledJob : successfulJobs) {
      String jobId=controlledJob.getJob().getJobID().toString();
      if (!sucessfulJobs.contains(jobId)) {
        LOG.info(""String_Node_Str"",jobId);
        sucessfulJobs.add(jobId);
      }
    }
    List<ControlledJob> failedJobs=jc.getFailedJobList();
    for (    ControlledJob controlledJob : failedJobs) {
      String failedJobId=controlledJob.getJob().getJobID().toString();
      if (killedSuccessJobSet.contains(failedJobId)) {
        continue;
      }
      if (!this.failedCheckingJobs.contains(failedJobId)) {
        this.failedCheckingJobs.add(failedJobId);
        String jobName=controlledJob.getJob().getJobName();
        Integer jobIndex=this.jobIndexMap.get(jobName);
        Integer runTimes=this.jobRunningTimes.get(jobIndex);
        if (runTimes <= 1) {
          LOG.warn(""String_Node_Str"",jobName);
          Job newJob=createJob(this.jobIndexParams.get(jobIndex));
          this.jc.addJob(new ControlledJob(newJob,null));
          this.jobRunningTimes.put(jobIndex,runTimes + 1);
          this.jobIndexMap.put(newJob.getJobName(),jobIndex);
          jobsWithoutIds=this.jc.getWaitingJobList();
        }
 else {
          LOG.warn(""String_Node_Str"",jobName);
        }
      }
    }
    double prog=calculateProgress(jc,jobClient) / totalNeededMRJobs;
    notifyProgress(prog,lastProg);
    lastProg=prog;
    try {
      Thread.sleep(2 * 1000);
    }
 catch (    InterruptedException e) {
      Thread.currentThread().interrupt();
    }
  }
  List<ControlledJob> successfulJobs=jc.getSuccessfulJobList();
  List<ControlledJob> failedJobs=jc.getFailedJobList();
  LOG.debug(""String_Node_Str"",successfulJobs.size(),failedJobs.size(),totalNeededMRJobs);
  for (  ControlledJob controlledJob : successfulJobs) {
    LOG.info(""String_Node_Str"");
    LOG.info(""String_Node_Str"",controlledJob);
  }
  if (totalNeededMRJobs == successfulJobs.size()) {
    LOG.info(""String_Node_Str"");
    failedJobs=jc.getFailedJobList();
    if (failedJobs != null && failedJobs.size() > 0) {
      for (      ControlledJob controlledJob : failedJobs) {
        Counters counters=controlledJob.getJob().getCounters();
        if (counters != null) {
          Counter doneMaster=counters.findCounter(GuaguaMapReduceConstants.GUAGUA_STATUS,GuaguaMapReduceConstants.MASTER_SUCCESS);
          Counter doneWorkers=counters.findCounter(GuaguaMapReduceConstants.GUAGUA_STATUS,GuaguaMapReduceConstants.DONE_WORKERS);
          if ((doneMaster != null && doneMaster.getValue() > 0) || (doneWorkers != null && doneWorkers.getValue() > 0)) {
            LOG.info(""String_Node_Str"");
            LOG.warn(""String_Node_Str"",toFakedStateString(controlledJob));
          }
 else {
            LOG.info(""String_Node_Str"");
            LOG.warn(""String_Node_Str"",controlledJob);
          }
        }
      }
    }
  }
 else {
    failedJobs=jc.getFailedJobList();
    if (failedJobs != null && failedJobs.size() > 0) {
      for (      ControlledJob controlledJob : failedJobs) {
        Counters counters=controlledJob.getJob().getCounters();
        if (counters != null) {
          Counter doneWorkers=counters.findCounter(GuaguaMapReduceConstants.GUAGUA_STATUS,GuaguaMapReduceConstants.DONE_WORKERS);
          if (doneWorkers != null && doneWorkers.getValue() > 0) {
            LOG.info(""String_Node_Str"");
            LOG.warn(""String_Node_Str"",toFakedStateString(controlledJob));
          }
 else {
            LOG.info(""String_Node_Str"");
            LOG.warn(""String_Node_Str"",controlledJob);
          }
        }
      }
    }
  }
  this.jc.stop();
}","/** 
 * Run all jobs added to JobControl.
 */
public void run() throws IOException {
  List<ControlledJob> jobsWithoutIds=this.jc.getWaitingJobList();
  int totalNeededMRJobs=jobsWithoutIds.size();
  LOG.info(""String_Node_Str"",jobsWithoutIds.size());
  Thread jcThread=new Thread(this.jc,""String_Node_Str"");
  jcThread.start();
  JobClient jobClient=new JobClient(new JobConf(new Configuration()));
  double lastProg=-1;
  Set<String> sucessfulJobs=new HashSet<String>();
  while (!this.jc.allFinished()) {
    try {
      jcThread.join(1000);
    }
 catch (    InterruptedException ignore) {
      Thread.currentThread().interrupt();
    }
    List<ControlledJob> jobsAssignedIdInThisRun=new ArrayList<ControlledJob>(totalNeededMRJobs);
    for (    ControlledJob job : jobsWithoutIds) {
      if (job.getJob().getJobID() != null) {
        jobsAssignedIdInThisRun.add(job);
        LOG.info(""String_Node_Str"",job.getJob().getJobID().toString());
      }
 else {
      }
    }
    jobsWithoutIds.removeAll(jobsAssignedIdInThisRun);
    List<ControlledJob> runningJobs=jc.getRunningJobList();
    for (    ControlledJob controlledJob : runningJobs) {
      String jobId=controlledJob.getJob().getJobID().toString();
      Counters counters=controlledJob.getJob().getCounters();
      Counter doneMaster=counters.findCounter(GuaguaMapReduceConstants.GUAGUA_STATUS,GuaguaMapReduceConstants.MASTER_SUCCESS);
      Counter doneWorkers=counters.findCounter(GuaguaMapReduceConstants.GUAGUA_STATUS,GuaguaMapReduceConstants.DONE_WORKERS);
      if ((doneMaster != null && doneMaster.getValue() > 0) || (doneWorkers != null && doneWorkers.getValue() > 0)) {
        Long initTime=firstMasterSuccessTimeMap.get(jobId);
        if (initTime == null) {
          firstMasterSuccessTimeMap.put(jobId,System.currentTimeMillis());
        }
 else {
          if (System.currentTimeMillis() - initTime >= 2 * 60 * 1000L) {
            killedSuccessJobSet.add(jobId);
            killJob(controlledJob.getJob().getConfiguration(),jobId,""String_Node_Str"");
            try {
              Thread.sleep(1 * 1000L);
            }
 catch (            InterruptedException e) {
              Thread.currentThread().interrupt();
            }
          }
        }
      }
    }
    List<ControlledJob> successfulJobs=jc.getSuccessfulJobList();
    for (    ControlledJob controlledJob : successfulJobs) {
      String jobId=controlledJob.getJob().getJobID().toString();
      if (!sucessfulJobs.contains(jobId)) {
        LOG.info(""String_Node_Str"",jobId);
        sucessfulJobs.add(jobId);
      }
    }
    List<ControlledJob> failedJobs=jc.getFailedJobList();
    for (    ControlledJob controlledJob : failedJobs) {
      String failedJobId=controlledJob.getJob().getJobID().toString();
      if (killedSuccessJobSet.contains(failedJobId)) {
        continue;
      }
      if (!this.failedCheckingJobs.contains(failedJobId)) {
        this.failedCheckingJobs.add(failedJobId);
        String jobName=controlledJob.getJob().getJobName();
        Integer jobIndex=this.jobIndexMap.get(jobName);
        Integer runTimes=this.jobRunningTimes.get(jobIndex);
        if (runTimes <= 1) {
          LOG.warn(""String_Node_Str"",jobName);
          Job newJob=createJob(this.jobIndexParams.get(jobIndex));
          this.jc.addJob(new ControlledJob(newJob,null));
          this.jobRunningTimes.put(jobIndex,runTimes + 1);
          this.jobIndexMap.put(newJob.getJobName(),jobIndex);
          jobsWithoutIds=this.jc.getWaitingJobList();
        }
 else {
          LOG.warn(""String_Node_Str"",jobName);
        }
      }
    }
    double prog=calculateProgress(jc,jobClient) / totalNeededMRJobs;
    notifyProgress(prog,lastProg);
    lastProg=prog;
    try {
      Thread.sleep(2 * 1000);
    }
 catch (    InterruptedException e) {
      Thread.currentThread().interrupt();
    }
  }
  List<ControlledJob> successfulJobs=jc.getSuccessfulJobList();
  List<ControlledJob> failedJobs=jc.getFailedJobList();
  LOG.debug(""String_Node_Str"",successfulJobs.size(),failedJobs.size(),totalNeededMRJobs);
  for (  ControlledJob controlledJob : successfulJobs) {
    LOG.info(""String_Node_Str"");
    LOG.info(""String_Node_Str"",controlledJob);
  }
  if (totalNeededMRJobs == successfulJobs.size()) {
    LOG.info(""String_Node_Str"");
    failedJobs=jc.getFailedJobList();
    if (failedJobs != null && failedJobs.size() > 0) {
      for (      ControlledJob controlledJob : failedJobs) {
        Counters counters=controlledJob.getJob().getCounters();
        if (counters != null) {
          Counter doneMaster=counters.findCounter(GuaguaMapReduceConstants.GUAGUA_STATUS,GuaguaMapReduceConstants.MASTER_SUCCESS);
          Counter doneWorkers=counters.findCounter(GuaguaMapReduceConstants.GUAGUA_STATUS,GuaguaMapReduceConstants.DONE_WORKERS);
          if ((doneMaster != null && doneMaster.getValue() > 0) || (doneWorkers != null && doneWorkers.getValue() > 0)) {
            LOG.info(""String_Node_Str"");
            LOG.warn(""String_Node_Str"",toFakedStateString(controlledJob));
          }
 else {
            LOG.info(""String_Node_Str"");
            LOG.warn(""String_Node_Str"",controlledJob);
          }
        }
      }
    }
  }
 else {
    failedJobs=jc.getFailedJobList();
    if (failedJobs != null && failedJobs.size() > 0) {
      for (      ControlledJob controlledJob : failedJobs) {
        Counters counters=controlledJob.getJob().getCounters();
        if (counters != null) {
          Counter doneMaster=counters.findCounter(GuaguaMapReduceConstants.GUAGUA_STATUS,GuaguaMapReduceConstants.MASTER_SUCCESS);
          Counter doneWorkers=counters.findCounter(GuaguaMapReduceConstants.GUAGUA_STATUS,GuaguaMapReduceConstants.DONE_WORKERS);
          if ((doneMaster != null && doneMaster.getValue() > 0) || (doneWorkers != null && doneWorkers.getValue() > 0)) {
            LOG.info(""String_Node_Str"");
            LOG.warn(""String_Node_Str"",toFakedStateString(controlledJob));
          }
 else {
            LOG.info(""String_Node_Str"");
            LOG.warn(""String_Node_Str"",controlledJob);
          }
        }
      }
    }
  }
  this.jc.stop();
}",0.9827843072339016
80305,"private int getLatestMasterIteration(final WorkerContext<MASTER_RESULT,WORKER_RESULT> context){
  try {
    String masterBaseNode=getMasterBaseNode(context.getAppId()).toString();
    List<String> masterIterations=null;
    try {
      masterIterations=getZooKeeper().getChildrenExt(masterBaseNode,false,false,false,new Filter(){
        @Override public boolean filter(        String path){
          try {
            Integer.parseInt(path);
            return false;
          }
 catch (          Exception e) {
            return true;
          }
        }
      }
);
    }
 catch (    KeeperException.NoNodeException e) {
      LOG.warn(""String_Node_Str"",masterBaseNode);
    }
    if (masterIterations != null && masterIterations.size() > 0) {
      Collections.sort(masterIterations,new Comparator<String>(){
        @Override public int compare(        String o1,        String o2){
          return Integer.valueOf(o1).compareTo(Integer.valueOf(o2));
        }
      }
);
      LOG.info(""String_Node_Str"",masterIterations);
      try {
        return Integer.valueOf(masterIterations.get(masterIterations.size() - 1));
      }
 catch (      NumberFormatException e) {
        throw new GuaguaRuntimeException(e);
      }
    }
  }
 catch (  InterruptedException e) {
    Thread.currentThread().interrupt();
  }
catch (  Exception e) {
    throw new GuaguaRuntimeException(e);
  }
  throw new GuaguaRuntimeException(""String_Node_Str"");
}","private int getLatestMasterIteration(final WorkerContext<MASTER_RESULT,WORKER_RESULT> context){
  try {
    String masterBaseNode=getMasterBaseNode(context.getAppId()).toString();
    List<String> masterIterations=null;
    try {
      masterIterations=getZooKeeper().getChildrenExt(masterBaseNode,false,false,false,new Filter(){
        @Override public boolean filter(        String path){
          try {
            Integer.parseInt(path);
            return false;
          }
 catch (          Exception e) {
            return true;
          }
        }
      }
);
    }
 catch (    KeeperException.NoNodeException e) {
      LOG.warn(""String_Node_Str"",masterBaseNode);
    }
    if (masterIterations != null && masterIterations.size() > 0) {
      Collections.sort(masterIterations,new Comparator<String>(){
        @Override public int compare(        String o1,        String o2){
          return Integer.valueOf(o1).compareTo(Integer.valueOf(o2));
        }
      }
);
      LOG.debug(""String_Node_Str"",masterIterations);
      try {
        return Integer.valueOf(masterIterations.get(masterIterations.size() - 1));
      }
 catch (      NumberFormatException e) {
        throw new GuaguaRuntimeException(e);
      }
    }
  }
 catch (  InterruptedException e) {
    Thread.currentThread().interrupt();
  }
catch (  Exception e) {
    throw new GuaguaRuntimeException(e);
  }
  throw new GuaguaRuntimeException(""String_Node_Str"");
}",0.996889042516419
80306,"/** 
 * Create Hadoop job according to arguments from main.
 */
@SuppressWarnings(""String_Node_Str"") public synchronized Job createJob(String[] args) throws IOException {
  Configuration conf=new Configuration();
  conf.setInt(GuaguaMapReduceConstants.MAPRED_TASK_TIMEOUT,conf.getInt(GuaguaMapReduceConstants.MAPRED_TASK_TIMEOUT,1200000));
  GuaguaOptionsParser parser=new GuaguaOptionsParser(conf,args);
  String hdpVersion=HDPUtils.getHdpVersionForHDP224();
  if (hdpVersion != null && hdpVersion.length() != 0) {
    conf.set(""String_Node_Str"",hdpVersion);
    HDPUtils.addFileToClassPath(HDPUtils.findContainingFile(""String_Node_Str""),conf);
    HDPUtils.addFileToClassPath(HDPUtils.findContainingFile(""String_Node_Str""),conf);
    HDPUtils.addFileToClassPath(HDPUtils.findContainingFile(""String_Node_Str""),conf);
    HDPUtils.addFileToClassPath(HDPUtils.findContainingFile(""String_Node_Str""),conf);
  }
  CommandLine cmdLine=parser.getCommandLine();
  checkInputSetting(conf,cmdLine);
  checkZkServerSetting(conf,cmdLine);
  checkWorkerClassSetting(conf,cmdLine);
  checkMasterClassSetting(conf,cmdLine);
  checkIterationCountSetting(conf,cmdLine);
  checkResultClassSetting(conf,cmdLine);
  String name=checkMapReduceNameSetting(cmdLine);
  @SuppressWarnings(""String_Node_Str"") Class<? extends InputFormat> inputFormatClass=checkInputFormatSetting(cmdLine);
  conf.setBoolean(GuaguaMapReduceConstants.MAPRED_MAP_TASKS_SPECULATIVE_EXECUTION,false);
  conf.setBoolean(GuaguaMapReduceConstants.MAPRED_REDUCE_TASKS_SPECULATIVE_EXECUTION,false);
  conf.setInt(GuaguaMapReduceConstants.MAPREDUCE_JOB_MAX_SPLIT_LOCATIONS,conf.getInt(GuaguaMapReduceConstants.MAPREDUCE_JOB_MAX_SPLIT_LOCATIONS,100));
  conf.setInt(GuaguaMapReduceConstants.IO_SORT_MB,0);
  conf.setInt(GuaguaMapReduceConstants.MAPREDUCE_JOB_COUNTERS_LIMIT,conf.getInt(GuaguaMapReduceConstants.MAPREDUCE_JOB_COUNTERS_LIMIT,512));
  conf.setInt(GuaguaMapReduceConstants.MAPRED_JOB_REDUCE_MEMORY_MB,0);
  String childJavaOpts=conf.get(GuaguaMapReduceConstants.MAPRED_CHILD_JAVA_OPTS,""String_Node_Str"");
  if (childJavaOpts == null || childJavaOpts.length() == 0) {
    conf.set(GuaguaMapReduceConstants.MAPRED_CHILD_JAVA_OPTS,GuaguaMapReduceConstants.MAPRED_DEFAULT_CHILD_JAVA_OPTS);
  }
 else {
    String newChildJavaOpts=GuaguaMapReduceConstants.MAPRED_DEFAULT_CHILD_JAVA_OPTS + ""String_Node_Str"" + childJavaOpts;
    conf.set(GuaguaMapReduceConstants.MAPRED_CHILD_JAVA_OPTS,newChildJavaOpts.trim());
  }
  Job job=new Job(conf,name);
  job.setJarByClass(GuaguaMapReduceClient.class);
  job.setMapperClass(GuaguaMapper.class);
  job.setMapOutputKeyClass(Text.class);
  job.setMapOutputValueClass(Text.class);
  job.setInputFormatClass(inputFormatClass);
  job.setOutputFormatClass(GuaguaOutputFormat.class);
  job.setNumReduceTasks(0);
  return job;
}","/** 
 * Create Hadoop job according to arguments from main.
 */
@SuppressWarnings(""String_Node_Str"") public synchronized Job createJob(String[] args) throws IOException {
  Configuration conf=new Configuration();
  conf.setInt(GuaguaMapReduceConstants.MAPRED_TASK_TIMEOUT,conf.getInt(GuaguaMapReduceConstants.MAPRED_TASK_TIMEOUT,1200000));
  GuaguaOptionsParser parser=new GuaguaOptionsParser(conf,args);
  String hdpVersion=HDPUtils.getHdpVersionForHDP224();
  if (hdpVersion != null && hdpVersion.length() != 0) {
    conf.set(""String_Node_Str"",hdpVersion);
    HDPUtils.addFileToClassPath(HDPUtils.findContainingFile(""String_Node_Str""),conf);
    HDPUtils.addFileToClassPath(HDPUtils.findContainingFile(""String_Node_Str""),conf);
    HDPUtils.addFileToClassPath(HDPUtils.findContainingFile(""String_Node_Str""),conf);
    HDPUtils.addFileToClassPath(HDPUtils.findContainingFile(""String_Node_Str""),conf);
  }
  CommandLine cmdLine=parser.getCommandLine();
  checkInputSetting(conf,cmdLine);
  checkZkServerSetting(conf,cmdLine);
  checkWorkerClassSetting(conf,cmdLine);
  checkMasterClassSetting(conf,cmdLine);
  checkIterationCountSetting(conf,cmdLine);
  checkResultClassSetting(conf,cmdLine);
  String name=checkMapReduceNameSetting(cmdLine);
  @SuppressWarnings(""String_Node_Str"") Class<? extends InputFormat> inputFormatClass=checkInputFormatSetting(cmdLine);
  conf.setBoolean(GuaguaMapReduceConstants.MAPRED_MAP_TASKS_SPECULATIVE_EXECUTION,false);
  conf.setBoolean(GuaguaMapReduceConstants.MAPRED_REDUCE_TASKS_SPECULATIVE_EXECUTION,false);
  int maxSplits=conf.getInt(GuaguaMapReduceConstants.MAPREDUCE_JOB_MAX_SPLIT_LOCATIONS,100);
  if (maxSplits < 100) {
    maxSplits=100;
  }
  conf.setInt(GuaguaMapReduceConstants.MAPREDUCE_JOB_MAX_SPLIT_LOCATIONS,maxSplits);
  conf.setInt(GuaguaMapReduceConstants.IO_SORT_MB,0);
  conf.setInt(GuaguaMapReduceConstants.MAPREDUCE_JOB_COUNTERS_LIMIT,conf.getInt(GuaguaMapReduceConstants.MAPREDUCE_JOB_COUNTERS_LIMIT,512));
  conf.setInt(GuaguaMapReduceConstants.MAPRED_JOB_REDUCE_MEMORY_MB,0);
  String childJavaOpts=conf.get(GuaguaMapReduceConstants.MAPRED_CHILD_JAVA_OPTS,""String_Node_Str"");
  if (childJavaOpts == null || childJavaOpts.length() == 0) {
    conf.set(GuaguaMapReduceConstants.MAPRED_CHILD_JAVA_OPTS,GuaguaMapReduceConstants.MAPRED_DEFAULT_CHILD_JAVA_OPTS);
  }
 else {
    String newChildJavaOpts=GuaguaMapReduceConstants.MAPRED_DEFAULT_CHILD_JAVA_OPTS + ""String_Node_Str"" + childJavaOpts;
    conf.set(GuaguaMapReduceConstants.MAPRED_CHILD_JAVA_OPTS,newChildJavaOpts.trim());
  }
  Job job=new Job(conf,name);
  job.setJarByClass(GuaguaMapReduceClient.class);
  job.setMapperClass(GuaguaMapper.class);
  job.setMapOutputKeyClass(Text.class);
  job.setMapOutputValueClass(Text.class);
  job.setInputFormatClass(inputFormatClass);
  job.setOutputFormatClass(GuaguaOutputFormat.class);
  job.setNumReduceTasks(0);
  return job;
}",0.9619631901840492
80307,"/** 
 * A ugly method to retrieve hdp version like 2.2.4.6633 from hadoop-hdfs jar name. The jar name is like 'hadoop-hdfs-2.6.0.2.2.4.6633.jar'.
 */
public static String getHdpVersionForHDP224(){
  String hdfsJarWithVersion=findContainingJar(DistributedFileSystem.class);
  String hdpVersion=""String_Node_Str"";
  if (hdfsJarWithVersion != null) {
    if (hdfsJarWithVersion.contains(File.separator)) {
      hdfsJarWithVersion=hdfsJarWithVersion.substring(hdfsJarWithVersion.lastIndexOf(File.separator) + 1);
    }
    hdfsJarWithVersion=hdfsJarWithVersion.replace(""String_Node_Str"",""String_Node_Str"");
    hdfsJarWithVersion=hdfsJarWithVersion.replace(""String_Node_Str"",""String_Node_Str"");
    String[] splits=hdfsJarWithVersion.split(""String_Node_Str"");
    if (splits.length > 2) {
      for (int i=3; i < splits.length; i++) {
        if (i == splits.length - 1) {
          hdpVersion+=splits[i];
        }
 else {
          hdpVersion+=splits[i] + ""String_Node_Str"";
        }
      }
    }
  }
  return hdpVersion;
}","/** 
 * A ugly method to retrieve hdp version like 2.2.4.6633 from hadoop-hdfs jar name. The jar name is like 'hadoop-hdfs-2.6.0.2.2.4.6633.jar'.
 */
public static String getHdpVersionForHDP224(){
  String hdfsJarWithVersion=findContainingJar(DistributedFileSystem.class);
  StringBuilder hdpVersion=new StringBuilder(20);
  if (hdfsJarWithVersion != null) {
    if (hdfsJarWithVersion.contains(File.separator)) {
      hdfsJarWithVersion=hdfsJarWithVersion.substring(hdfsJarWithVersion.lastIndexOf(File.separator) + 1);
    }
    hdfsJarWithVersion=hdfsJarWithVersion.replace(""String_Node_Str"",""String_Node_Str"");
    hdfsJarWithVersion=hdfsJarWithVersion.replace(""String_Node_Str"",""String_Node_Str"");
    String[] splits=hdfsJarWithVersion.split(""String_Node_Str"");
    if (splits.length > 2) {
      for (int i=3; i < splits.length; i++) {
        if (i == splits.length - 1) {
          hdpVersion.append(splits[i]);
        }
 else {
          hdpVersion.append(splits[i]).append(""String_Node_Str"");
        }
      }
    }
  }
  return hdpVersion.toString();
}",0.9569377990430622
80308,"/** 
 * Wait for unregister message for all workers and then clean all znodes existing for this job.
 */
@Override public void postApplication(final MasterContext<MASTER_RESULT,WORKER_RESULT> context){
synchronized (LOCK) {
    this.currentInteration=context.getCurrentIteration();
  }
  new BasicCoordinatorCommand(){
    @Override public void doExecute() throws Exception, InterruptedException {
      try {
        String zkCleanUpEnabled=StringUtils.get(context.getProps().getProperty(GuaguaConstants.GUAGUA_ZK_CLEANUP_ENABLE),GuaguaConstants.GUAGUA_ZK_DEFAULT_CLEANUP_VALUE);
        final long start=System.nanoTime();
        if (Boolean.TRUE.toString().equalsIgnoreCase(zkCleanUpEnabled)) {
          new RetryCoordinatorCommand(isFixedTime(),getSleepTime()){
            @Override public boolean retryExecution() throws KeeperException, InterruptedException {
              int doneWorkers;
synchronized (LOCK) {
                doneWorkers=(int)NettyMasterCoordinator.this.iterResults.size();
              }
              if (TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - start) > 120 * 1000L) {
                LOG.info(""String_Node_Str"",doneWorkers,(context.getWorkers() - doneWorkers));
                return true;
              }
              if (System.nanoTime() % 30 == 0) {
                LOG.info(""String_Node_Str"",doneWorkers,(context.getWorkers() - doneWorkers));
              }
              return isTerminated(doneWorkers,context.getWorkers(),GuaguaConstants.GUAGUA_DEFAULT_MIN_WORKERS_RATIO,GuaguaConstants.GUAGUA_DEFAULT_MIN_WORKERS_TIMEOUT);
            }
          }
.execute();
          String appNode=getAppNode(context.getAppId()).toString();
          try {
            getZooKeeper().deleteExt(appNode,-1,true);
          }
 catch (          KeeperException.NoNodeException e) {
            if (System.nanoTime() % 20 == 0) {
              LOG.warn(""String_Node_Str"",appNode);
            }
          }
        }
      }
  finally {
        if (NettyMasterCoordinator.this.messageServer != null) {
          Method shutDownMethod=ReflectionUtils.getMethod(NettyMasterCoordinator.this.messageServer.getClass(),""String_Node_Str"");
          if (shutDownMethod != null) {
            shutDownMethod.invoke(NettyMasterCoordinator.this.messageServer,(Object[])null);
          }
          NettyMasterCoordinator.this.messageServer.releaseExternalResources();
        }
        NettyMasterCoordinator.super.closeZooKeeper();
        NettyMasterCoordinator.this.closeIterResults();
        NettyMasterCoordinator.this.iterResults.clear();
      }
    }
  }
.execute();
}","/** 
 * Wait for unregister message for all workers and then clean all znodes existing for this job.
 */
@Override public void postApplication(final MasterContext<MASTER_RESULT,WORKER_RESULT> context){
synchronized (LOCK) {
    this.currentInteration=context.getCurrentIteration();
  }
  new BasicCoordinatorCommand(){
    @Override public void doExecute() throws Exception, InterruptedException {
      try {
        String zkCleanUpEnabled=StringUtils.get(context.getProps().getProperty(GuaguaConstants.GUAGUA_ZK_CLEANUP_ENABLE),GuaguaConstants.GUAGUA_ZK_DEFAULT_CLEANUP_VALUE);
        final long start=System.nanoTime();
        if (Boolean.TRUE.toString().equalsIgnoreCase(zkCleanUpEnabled)) {
          new RetryCoordinatorCommand(isFixedTime(),getSleepTime()){
            @Override public boolean retryExecution() throws KeeperException, InterruptedException {
              int doneWorkers;
synchronized (LOCK) {
                doneWorkers=(int)NettyMasterCoordinator.this.iterResults.size();
              }
              if (TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - start) > 120 * 1000L) {
                LOG.info(""String_Node_Str"" + ""String_Node_Str"",doneWorkers,(context.getWorkers() - doneWorkers));
                return true;
              }
              if (System.nanoTime() % 30 == 0) {
                LOG.info(""String_Node_Str"" + ""String_Node_Str"",doneWorkers,(context.getWorkers() - doneWorkers));
              }
              return isTerminated(doneWorkers,context.getWorkers(),GuaguaConstants.GUAGUA_DEFAULT_MIN_WORKERS_RATIO,GuaguaConstants.GUAGUA_DEFAULT_MIN_WORKERS_TIMEOUT);
            }
          }
.execute();
          String appNode=getAppNode(context.getAppId()).toString();
          try {
            getZooKeeper().deleteExt(appNode,-1,true);
          }
 catch (          KeeperException.NoNodeException e) {
            if (System.nanoTime() % 20 == 0) {
              LOG.warn(""String_Node_Str"",appNode);
            }
          }
        }
      }
  finally {
        if (NettyMasterCoordinator.this.messageServer != null) {
          Method shutDownMethod=ReflectionUtils.getMethod(NettyMasterCoordinator.this.messageServer.getClass(),""String_Node_Str"");
          if (shutDownMethod != null) {
            shutDownMethod.invoke(NettyMasterCoordinator.this.messageServer,(Object[])null);
          }
          NettyMasterCoordinator.this.messageServer.releaseExternalResources();
        }
        NettyMasterCoordinator.super.closeZooKeeper();
        NettyMasterCoordinator.this.closeIterResults();
        NettyMasterCoordinator.this.iterResults.clear();
      }
    }
  }
.execute();
}",0.9923838537699924
80309,"@Override public void doExecute() throws Exception, InterruptedException {
  try {
    String zkCleanUpEnabled=StringUtils.get(context.getProps().getProperty(GuaguaConstants.GUAGUA_ZK_CLEANUP_ENABLE),GuaguaConstants.GUAGUA_ZK_DEFAULT_CLEANUP_VALUE);
    final long start=System.nanoTime();
    if (Boolean.TRUE.toString().equalsIgnoreCase(zkCleanUpEnabled)) {
      new RetryCoordinatorCommand(isFixedTime(),getSleepTime()){
        @Override public boolean retryExecution() throws KeeperException, InterruptedException {
          int doneWorkers;
synchronized (LOCK) {
            doneWorkers=(int)NettyMasterCoordinator.this.iterResults.size();
          }
          if (TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - start) > 120 * 1000L) {
            LOG.info(""String_Node_Str"",doneWorkers,(context.getWorkers() - doneWorkers));
            return true;
          }
          if (System.nanoTime() % 30 == 0) {
            LOG.info(""String_Node_Str"",doneWorkers,(context.getWorkers() - doneWorkers));
          }
          return isTerminated(doneWorkers,context.getWorkers(),GuaguaConstants.GUAGUA_DEFAULT_MIN_WORKERS_RATIO,GuaguaConstants.GUAGUA_DEFAULT_MIN_WORKERS_TIMEOUT);
        }
      }
.execute();
      String appNode=getAppNode(context.getAppId()).toString();
      try {
        getZooKeeper().deleteExt(appNode,-1,true);
      }
 catch (      KeeperException.NoNodeException e) {
        if (System.nanoTime() % 20 == 0) {
          LOG.warn(""String_Node_Str"",appNode);
        }
      }
    }
  }
  finally {
    if (NettyMasterCoordinator.this.messageServer != null) {
      Method shutDownMethod=ReflectionUtils.getMethod(NettyMasterCoordinator.this.messageServer.getClass(),""String_Node_Str"");
      if (shutDownMethod != null) {
        shutDownMethod.invoke(NettyMasterCoordinator.this.messageServer,(Object[])null);
      }
      NettyMasterCoordinator.this.messageServer.releaseExternalResources();
    }
    NettyMasterCoordinator.super.closeZooKeeper();
    NettyMasterCoordinator.this.closeIterResults();
    NettyMasterCoordinator.this.iterResults.clear();
  }
}","@Override public void doExecute() throws Exception, InterruptedException {
  try {
    String zkCleanUpEnabled=StringUtils.get(context.getProps().getProperty(GuaguaConstants.GUAGUA_ZK_CLEANUP_ENABLE),GuaguaConstants.GUAGUA_ZK_DEFAULT_CLEANUP_VALUE);
    final long start=System.nanoTime();
    if (Boolean.TRUE.toString().equalsIgnoreCase(zkCleanUpEnabled)) {
      new RetryCoordinatorCommand(isFixedTime(),getSleepTime()){
        @Override public boolean retryExecution() throws KeeperException, InterruptedException {
          int doneWorkers;
synchronized (LOCK) {
            doneWorkers=(int)NettyMasterCoordinator.this.iterResults.size();
          }
          if (TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - start) > 120 * 1000L) {
            LOG.info(""String_Node_Str"" + ""String_Node_Str"",doneWorkers,(context.getWorkers() - doneWorkers));
            return true;
          }
          if (System.nanoTime() % 30 == 0) {
            LOG.info(""String_Node_Str"" + ""String_Node_Str"",doneWorkers,(context.getWorkers() - doneWorkers));
          }
          return isTerminated(doneWorkers,context.getWorkers(),GuaguaConstants.GUAGUA_DEFAULT_MIN_WORKERS_RATIO,GuaguaConstants.GUAGUA_DEFAULT_MIN_WORKERS_TIMEOUT);
        }
      }
.execute();
      String appNode=getAppNode(context.getAppId()).toString();
      try {
        getZooKeeper().deleteExt(appNode,-1,true);
      }
 catch (      KeeperException.NoNodeException e) {
        if (System.nanoTime() % 20 == 0) {
          LOG.warn(""String_Node_Str"",appNode);
        }
      }
    }
  }
  finally {
    if (NettyMasterCoordinator.this.messageServer != null) {
      Method shutDownMethod=ReflectionUtils.getMethod(NettyMasterCoordinator.this.messageServer.getClass(),""String_Node_Str"");
      if (shutDownMethod != null) {
        shutDownMethod.invoke(NettyMasterCoordinator.this.messageServer,(Object[])null);
      }
      NettyMasterCoordinator.this.messageServer.releaseExternalResources();
    }
    NettyMasterCoordinator.super.closeZooKeeper();
    NettyMasterCoordinator.this.closeIterResults();
    NettyMasterCoordinator.this.iterResults.clear();
  }
}",0.990552668871044
80310,"@Override public synchronized boolean add(WorkerResultWrapper e){
  this.rawSize+=1;
  if (e.isWorkerCombinable()) {
    if (this.currIndex == this.threshold - 1) {
      while (this.currIndex > 0) {
        e.combine(this.removeLast());
        this.currIndex-=1;
      }
      return super.add(e);
    }
 else {
      this.currIndex+=1;
      return super.add(e);
    }
  }
 else {
    return super.add(e);
  }
}","@Override public synchronized boolean add(WorkerResultWrapper e){
  this.rawSize+=1;
  if (e.isWorkerCombinable()) {
    this.currIndex+=1;
    if (this.currIndex == this.threshold - 1) {
      while (this.currIndex > 1) {
        e.combine(this.removeLast());
        this.currIndex-=1;
      }
      if (currIndex != 1) {
        throw new IllegalStateException();
      }
      return super.add(e);
    }
 else {
      return super.add(e);
    }
  }
 else {
    return super.add(e);
  }
}",0.6143646408839779
80311,"private void initIterResults(Properties props){
synchronized (LOCK) {
    boolean nonSpill=""String_Node_Str"".equalsIgnoreCase(props.getProperty(GuaguaConstants.GUAGUA_MASTER_RESULT_NONSPILL,""String_Node_Str""));
    if (nonSpill) {
      int mergeThreshold=NumberFormatUtils.getInt(props.getProperty(GuaguaConstants.GUAGUA_MASTER_RESULT_MERGE_THRESHOLD,""String_Node_Str""),10);
      this.iterResults=new MergeWorkerResultList(mergeThreshold);
    }
 else {
      BytableDiskList<WorkerResultWrapper> bytableDiskList=new BytableDiskList<WorkerResultWrapper>(System.currentTimeMillis() + ""String_Node_Str"",WorkerResultWrapper.class.getName());
      double memoryFraction=Double.valueOf(props.getProperty(GuaguaConstants.GUAGUA_MASTER_WORKERESULTS_MEMORY_FRACTION,GuaguaConstants.GUAGUA_MASTER_WORKERESULTS_DEFAULT_MEMORY_FRACTION));
      long memoryStoreSize=(long)(Runtime.getRuntime().maxMemory() * memoryFraction);
      LOG.info(""String_Node_Str"",memoryStoreSize);
      this.iterResults=new BytableMemoryDiskList<WorkerResultWrapper>(memoryStoreSize,bytableDiskList);
    }
  }
}","private void initIterResults(Properties props){
synchronized (LOCK) {
    boolean nonSpill=""String_Node_Str"".equalsIgnoreCase(props.getProperty(GuaguaConstants.GUAGUA_MASTER_RESULT_NONSPILL,""String_Node_Str""));
    if (nonSpill && isWorkerCombinable(props.getProperty(GuaguaConstants.GUAGUA_WORKER_RESULT_CLASS))) {
      int mergeThreshold=NumberFormatUtils.getInt(props.getProperty(GuaguaConstants.GUAGUA_MASTER_RESULT_MERGE_THRESHOLD,""String_Node_Str""),10);
      this.iterResults=new MergeWorkerResultList(mergeThreshold);
    }
 else {
      BytableDiskList<WorkerResultWrapper> bytableDiskList=new BytableDiskList<WorkerResultWrapper>(System.currentTimeMillis() + ""String_Node_Str"",WorkerResultWrapper.class.getName());
      double memoryFraction=Double.valueOf(props.getProperty(GuaguaConstants.GUAGUA_MASTER_WORKERESULTS_MEMORY_FRACTION,GuaguaConstants.GUAGUA_MASTER_WORKERESULTS_DEFAULT_MEMORY_FRACTION));
      long memoryStoreSize=(long)(Runtime.getRuntime().maxMemory() * memoryFraction);
      LOG.info(""String_Node_Str"",memoryStoreSize);
      this.iterResults=new BytableMemoryDiskList<WorkerResultWrapper>(memoryStoreSize,bytableDiskList);
    }
  }
}",0.962239004886717
80312,"public MergeWorkerResultList(int threshold){
  this.threshold=threshold;
}","public MergeWorkerResultList(int threshold){
  if (threshold <= 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  this.threshold=threshold;
}",0.6297872340425532
80313,"/** 
 * Wait for all workers done in current iteration.
 */
@Override public void preIteration(final MasterContext<MASTER_RESULT,WORKER_RESULT> context){
synchronized (LOCK) {
    this.currentInteration=context.getCurrentIteration();
    this.canUpdateWorkerResultMap=true;
  }
  long start=System.nanoTime();
  new RetryCoordinatorCommand(isFixedTime(),getSleepTime()){
    @Override public boolean retryExecution() throws KeeperException, InterruptedException {
      int doneWorkers;
synchronized (LOCK) {
        doneWorkers=(int)NettyMasterCoordinator.this.iterResults.size();
      }
      if (System.nanoTime() % 30 == 0) {
        LOG.info(""String_Node_Str"",context.getCurrentIteration(),doneWorkers,(context.getWorkers() - doneWorkers));
      }
      boolean isTerminated=false;
      if (context.isFirstIteration() || context.getCurrentIteration() == context.getTotalIteration()) {
        isTerminated=isTerminated(doneWorkers,context.getWorkers(),context.getMinWorkersRatio(),GuaguaConstants.GUAGUA_DEFAULT_MIN_WORKERS_TIMEOUT);
        if (isTerminated) {
synchronized (LOCK) {
            NettyMasterCoordinator.this.canUpdateWorkerResultMap=false;
          }
          LOG.info(""String_Node_Str"",context.getCurrentIteration(),context.getWorkers(),doneWorkers,context.getMinWorkersRatio(),GuaguaConstants.GUAGUA_DEFAULT_MIN_WORKERS_TIMEOUT);
        }
      }
 else {
        isTerminated=isTerminated(doneWorkers,context.getWorkers(),context.getMinWorkersRatio(),context.getMinWorkersTimeOut());
        if (isTerminated) {
synchronized (LOCK) {
            NettyMasterCoordinator.this.canUpdateWorkerResultMap=false;
          }
          LOG.info(""String_Node_Str"",context.getCurrentIteration(),context.getWorkers(),doneWorkers,context.getMinWorkersRatio(),context.getMinWorkersTimeOut());
        }
      }
      return isTerminated;
    }
  }
.execute();
synchronized (LOCK) {
    this.canUpdateWorkerResultMap=false;
    this.iterResults.switchState();
  }
  if (this.iterResults instanceof BytableMemoryDiskList) {
    LOG.info(""String_Node_Str"",this.currentInteration,((BytableMemoryDiskList<WorkerResultWrapper>)this.iterResults).getMemoryCount());
    LOG.info(""String_Node_Str"",this.currentInteration,((BytableMemoryDiskList<WorkerResultWrapper>)this.iterResults).getDiskCount());
  }
 else {
    LOG.info(""String_Node_Str"",this.currentInteration,((MergeWorkerResultList)this.iterResults).size(),((MergeWorkerResultList)this.iterResults).mergedSize());
  }
  final int currentIter=this.currentInteration;
  context.setWorkerResults(new Iterable<WORKER_RESULT>(){
    @Override public Iterator<WORKER_RESULT> iterator(){
      return new Iterator<WORKER_RESULT>(){
        private Iterator<WorkerResultWrapper> localItr;
        private volatile AtomicBoolean isStart=new AtomicBoolean();
        WorkerResultWrapper current=null;
        @Override public boolean hasNext(){
          boolean hasNext;
synchronized (LOCK) {
            if (this.isStart.compareAndSet(false,true)) {
              this.localItr=NettyMasterCoordinator.this.iterResults.iterator();
            }
            hasNext=this.localItr.hasNext();
            if (hasNext) {
              this.current=this.localItr.next();
              while (this.current.currIter != currentIter) {
                hasNext=this.localItr.hasNext();
                if (hasNext) {
                  this.current=this.localItr.next();
                  continue;
                }
 else {
                  break;
                }
              }
            }
            if (!hasNext) {
              this.localItr=NettyMasterCoordinator.this.iterResults.iterator();
              return false;
            }
          }
          return hasNext;
        }
        @SuppressWarnings(""String_Node_Str"") @Override public WORKER_RESULT next(){
synchronized (LOCK) {
            return (WORKER_RESULT)this.current.workerResult;
          }
        }
        @Override public void remove(){
          throw new UnsupportedOperationException();
        }
      }
;
    }
  }
);
  LOG.info(""String_Node_Str"",context.getAppId(),context.getContainerId(),context.getCurrentIteration(),TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - start));
}","/** 
 * Wait for all workers done in current iteration.
 */
@Override public void preIteration(final MasterContext<MASTER_RESULT,WORKER_RESULT> context){
synchronized (LOCK) {
    this.currentInteration=context.getCurrentIteration();
    this.canUpdateWorkerResultMap=true;
  }
  long start=System.nanoTime();
  new RetryCoordinatorCommand(isFixedTime(),getSleepTime()){
    @Override public boolean retryExecution() throws KeeperException, InterruptedException {
      int doneWorkers;
synchronized (LOCK) {
        doneWorkers=(int)NettyMasterCoordinator.this.iterResults.size();
      }
      if (System.nanoTime() % 30 == 0) {
        LOG.info(""String_Node_Str"",context.getCurrentIteration(),doneWorkers,(context.getWorkers() - doneWorkers));
      }
      long timeOut=0L;
      if (context.isFirstIteration() || context.getCurrentIteration() == context.getTotalIteration()) {
        timeOut=GuaguaConstants.GUAGUA_DEFAULT_MIN_WORKERS_TIMEOUT;
      }
 else {
        timeOut=context.getMinWorkersTimeOut();
      }
      boolean isTerminated=isTerminated(doneWorkers,context.getWorkers(),context.getMinWorkersRatio(),timeOut);
      if (isTerminated) {
synchronized (LOCK) {
          NettyMasterCoordinator.this.canUpdateWorkerResultMap=false;
        }
        LOG.info(""String_Node_Str"" + ""String_Node_Str"",context.getCurrentIteration(),context.getWorkers(),doneWorkers,context.getMinWorkersRatio(),GuaguaConstants.GUAGUA_DEFAULT_MIN_WORKERS_TIMEOUT);
      }
      return isTerminated;
    }
  }
.execute();
synchronized (LOCK) {
    this.canUpdateWorkerResultMap=false;
    this.iterResults.switchState();
  }
  if (this.iterResults instanceof BytableMemoryDiskList) {
    LOG.info(""String_Node_Str"",this.currentInteration,((BytableMemoryDiskList<WorkerResultWrapper>)this.iterResults).getMemoryCount());
    LOG.info(""String_Node_Str"",this.currentInteration,((BytableMemoryDiskList<WorkerResultWrapper>)this.iterResults).getDiskCount());
  }
 else {
    LOG.info(""String_Node_Str"",this.currentInteration,((MergeWorkerResultList)this.iterResults).size(),((MergeWorkerResultList)this.iterResults).mergedSize());
  }
  final int currentIter=this.currentInteration;
  context.setWorkerResults(new Iterable<WORKER_RESULT>(){
    @Override public Iterator<WORKER_RESULT> iterator(){
      return new Iterator<WORKER_RESULT>(){
        private Iterator<WorkerResultWrapper> localItr;
        private volatile AtomicBoolean isStart=new AtomicBoolean();
        WorkerResultWrapper current=null;
        @Override public boolean hasNext(){
          boolean hasNext;
synchronized (LOCK) {
            if (this.isStart.compareAndSet(false,true)) {
              this.localItr=NettyMasterCoordinator.this.iterResults.iterator();
            }
            hasNext=this.localItr.hasNext();
            if (hasNext) {
              this.current=this.localItr.next();
              while (this.current.currIter != currentIter) {
                hasNext=this.localItr.hasNext();
                if (hasNext) {
                  this.current=this.localItr.next();
                  continue;
                }
 else {
                  break;
                }
              }
            }
            if (!hasNext) {
              this.localItr=NettyMasterCoordinator.this.iterResults.iterator();
              return false;
            }
          }
          return hasNext;
        }
        @SuppressWarnings(""String_Node_Str"") @Override public WORKER_RESULT next(){
synchronized (LOCK) {
            return (WORKER_RESULT)this.current.workerResult;
          }
        }
        @Override public void remove(){
          throw new UnsupportedOperationException();
        }
      }
;
    }
  }
);
  LOG.info(""String_Node_Str"",context.getAppId(),context.getContainerId(),context.getCurrentIteration(),TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - start));
}",0.9011505629098108
80314,"@Override public boolean retryExecution() throws KeeperException, InterruptedException {
  int doneWorkers;
synchronized (LOCK) {
    doneWorkers=(int)NettyMasterCoordinator.this.iterResults.size();
  }
  if (TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - start) > 120 * 1000L) {
    LOG.info(""String_Node_Str"",doneWorkers,(context.getWorkers() - doneWorkers));
    return true;
  }
  if (System.nanoTime() % 30 == 0) {
    LOG.info(""String_Node_Str"",doneWorkers,(context.getWorkers() - doneWorkers));
  }
  return isTerminated(doneWorkers,context.getWorkers(),GuaguaConstants.GUAGUA_DEFAULT_MIN_WORKERS_RATIO,GuaguaConstants.GUAGUA_DEFAULT_MIN_WORKERS_TIMEOUT);
}","@Override public boolean retryExecution() throws KeeperException, InterruptedException {
  int doneWorkers;
synchronized (LOCK) {
    doneWorkers=(int)NettyMasterCoordinator.this.iterResults.size();
  }
  if (TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - start) > 120 * 1000L) {
    LOG.info(""String_Node_Str"" + ""String_Node_Str"",doneWorkers,(context.getWorkers() - doneWorkers));
    return true;
  }
  if (System.nanoTime() % 30 == 0) {
    LOG.info(""String_Node_Str"" + ""String_Node_Str"",doneWorkers,(context.getWorkers() - doneWorkers));
  }
  return isTerminated(doneWorkers,context.getWorkers(),GuaguaConstants.GUAGUA_DEFAULT_MIN_WORKERS_RATIO,GuaguaConstants.GUAGUA_DEFAULT_MIN_WORKERS_TIMEOUT);
}",0.9708879184861716
80315,"/** 
 * Re-open stream for iterators.
 */
public void reOpen(){
  close();
  try {
    this.inputStream=new FileInputStream(file);
  }
 catch (  FileNotFoundException e) {
    throw new GuaguaRuntimeException(e);
  }
}","/** 
 * Re-open stream for iterators.
 */
public void reOpen(){
  close();
  try {
    this.inputStream=new DataInputStream(new BufferedInputStream(new FileInputStream(file)));
  }
 catch (  FileNotFoundException e) {
    throw new GuaguaRuntimeException(e);
  }
}",0.9045643153526972
80316,"@Override public T next(){
  try {
    int length=DiskList.this.inputStream.read();
    byte[] bytes=new byte[length];
    int size=DiskList.this.inputStream.read(bytes);
    if (size < 0) {
      throw new GuaguaRuntimeException(""String_Node_Str"");
    }
    return DiskList.this.getSerializer().deserialize(bytes,null);
  }
 catch (  IOException e) {
    throw new GuaguaRuntimeException(e);
  }
}","@Override public T next(){
  try {
    int length=DiskList.this.inputStream.readInt();
    byte[] bytes=new byte[length];
    for (int i=0; i < bytes.length; i++) {
      bytes[i]=DiskList.this.inputStream.readByte();
    }
    return DiskList.this.getSerializer().deserialize(bytes,null);
  }
 catch (  IOException e) {
    throw new GuaguaRuntimeException(e);
  }
}",0.7989556135770235
80317,"@Override public Iterator<T> iterator(){
  if (this.state != State.READ) {
    throw new IllegalStateException();
  }
  return new Iterator<T>(){
    @Override public boolean hasNext(){
      try {
        return DiskList.this.inputStream.available() > 0;
      }
 catch (      IOException e) {
        return false;
      }
    }
    @Override public T next(){
      try {
        int length=DiskList.this.inputStream.read();
        byte[] bytes=new byte[length];
        int size=DiskList.this.inputStream.read(bytes);
        if (size < 0) {
          throw new GuaguaRuntimeException(""String_Node_Str"");
        }
        return DiskList.this.getSerializer().deserialize(bytes,null);
      }
 catch (      IOException e) {
        throw new GuaguaRuntimeException(e);
      }
    }
    @Override public void remove(){
      throw new UnsupportedOperationException();
    }
  }
;
}","@Override public Iterator<T> iterator(){
  if (this.state != State.READ) {
    throw new IllegalStateException();
  }
  return new Iterator<T>(){
    @Override public boolean hasNext(){
      try {
        return DiskList.this.inputStream.available() > 0;
      }
 catch (      IOException e) {
        return false;
      }
    }
    @Override public T next(){
      try {
        int length=DiskList.this.inputStream.readInt();
        byte[] bytes=new byte[length];
        for (int i=0; i < bytes.length; i++) {
          bytes[i]=DiskList.this.inputStream.readByte();
        }
        return DiskList.this.getSerializer().deserialize(bytes,null);
      }
 catch (      IOException e) {
        throw new GuaguaRuntimeException(e);
      }
    }
    @Override public void remove(){
      throw new UnsupportedOperationException();
    }
  }
;
}",0.9077277970011534
80318,"/** 
 * Constructor with file name in current working dir.
 */
public DiskList(String fileName){
  try {
    this.file=new File(fileName);
    this.outputStream=new FileOutputStream(file);
    this.inputStream=new FileInputStream(file);
  }
 catch (  FileNotFoundException e) {
    throw new GuaguaRuntimeException(e);
  }
}","/** 
 * Constructor with file name in current working dir.
 */
public DiskList(String fileName){
  try {
    this.file=new File(fileName);
    this.outputStream=new DataOutputStream(new BufferedOutputStream(new FileOutputStream(file)));
    this.inputStream=new DataInputStream(new BufferedInputStream(new FileInputStream(file)));
  }
 catch (  FileNotFoundException e) {
    throw new GuaguaRuntimeException(e);
  }
}",0.8733153638814016
80319,"@Override public boolean append(T t){
  if (this.state != State.WRITE) {
    throw new IllegalStateException();
  }
  this.count+=1;
  byte[] bytes=getSerializer().serialize(t);
  try {
    this.outputStream.write(bytes.length);
    this.outputStream.write(bytes);
  }
 catch (  IOException e) {
    throw new GuaguaRuntimeException(e);
  }
  return true;
}","@Override public boolean append(T t){
  if (this.state != State.WRITE) {
    throw new IllegalStateException();
  }
  this.count+=1;
  byte[] bytes=getSerializer().serialize(t);
  try {
    this.outputStream.writeInt(bytes.length);
    for (    byte b : bytes) {
      this.outputStream.writeByte(b);
    }
  }
 catch (  IOException e) {
    throw new GuaguaRuntimeException(e);
  }
  return true;
}",0.9232804232804231
80320,"/** 
 * Wait for all workers done in current iteration.
 */
@Override public void preIteration(final MasterContext<MASTER_RESULT,WORKER_RESULT> context){
synchronized (LOCK) {
    this.currentInteration=context.getCurrentIteration();
    this.canUpdateWorkerResultMap=true;
  }
  long start=System.nanoTime();
  new RetryCoordinatorCommand(isFixedTime(),getSleepTime()){
    @Override public boolean retryExecution() throws KeeperException, InterruptedException {
      int doneWorkers;
synchronized (LOCK) {
        doneWorkers=(int)NettyMasterCoordinator.this.iterResults.size();
      }
      if (System.nanoTime() % 30 == 0) {
        LOG.info(""String_Node_Str"",context.getCurrentIteration(),doneWorkers,(context.getWorkers() - doneWorkers));
      }
      boolean isTerminated=false;
      if (context.isFirstIteration() || context.getCurrentIteration() == context.getTotalIteration()) {
        isTerminated=isTerminated(doneWorkers,context.getWorkers(),context.getMinWorkersRatio(),GuaguaConstants.GUAGUA_DEFAULT_MIN_WORKERS_TIMEOUT);
        if (isTerminated) {
synchronized (LOCK) {
            NettyMasterCoordinator.this.canUpdateWorkerResultMap=false;
          }
          LOG.info(""String_Node_Str"",context.getCurrentIteration(),context.getWorkers(),doneWorkers,GuaguaConstants.GUAGUA_DEFAULT_MIN_WORKERS_RATIO,GuaguaConstants.GUAGUA_DEFAULT_MIN_WORKERS_TIMEOUT);
        }
      }
 else {
        isTerminated=isTerminated(doneWorkers,context.getWorkers(),context.getMinWorkersRatio(),context.getMinWorkersTimeOut());
        if (isTerminated) {
synchronized (LOCK) {
            NettyMasterCoordinator.this.canUpdateWorkerResultMap=false;
          }
          LOG.info(""String_Node_Str"",context.getCurrentIteration(),context.getWorkers(),doneWorkers,context.getMinWorkersRatio(),context.getMinWorkersTimeOut());
        }
      }
      return isTerminated;
    }
  }
.execute();
synchronized (LOCK) {
    this.canUpdateWorkerResultMap=false;
    this.iterResults.switchState();
  }
  final int currentIter=this.currentInteration;
  context.setWorkerResults(new Iterable<WORKER_RESULT>(){
    @Override public Iterator<WORKER_RESULT> iterator(){
      return new Iterator<WORKER_RESULT>(){
        private Iterator<BytableWrapper> localItr;
        private volatile AtomicBoolean isStart=new AtomicBoolean();
        private boolean isPrint=false;
        BytableWrapper current=null;
        @Override public boolean hasNext(){
          boolean hasNext;
synchronized (LOCK) {
            if (!isPrint) {
              Iterator<BytableWrapper> ii=NettyMasterCoordinator.this.iterResults.iterator();
              int curr=0, notCurr=0;
              while (ii.hasNext()) {
                BytableWrapper next=ii.next();
                if (NettyMasterCoordinator.this.currentInteration == next.getCurrentIteration()) {
                  curr+=1;
                }
 else {
                  notCurr+=1;
                  LOG.info(""String_Node_Str"",next);
                }
              }
              LOG.info(""String_Node_Str"",curr,notCurr);
              isPrint=true;
            }
            if (this.isStart.compareAndSet(false,true)) {
              this.localItr=NettyMasterCoordinator.this.iterResults.iterator();
            }
            hasNext=this.localItr.hasNext();
            if (hasNext) {
              this.current=this.localItr.next();
              while (this.current.getCurrentIteration() != currentIter) {
                hasNext=this.localItr.hasNext();
                if (hasNext) {
                  this.current=this.localItr.next();
                  continue;
                }
 else {
                  break;
                }
              }
            }
            if (!hasNext) {
              this.localItr=NettyMasterCoordinator.this.iterResults.iterator();
              return false;
            }
          }
          return hasNext;
        }
        @Override public WORKER_RESULT next(){
synchronized (LOCK) {
            return NettyMasterCoordinator.this.getWorkerSerializer().bytesToObject(this.current.getBytes(),context.getWorkerResultClassName());
          }
        }
        @Override public void remove(){
          throw new UnsupportedOperationException();
        }
      }
;
    }
  }
);
  LOG.info(""String_Node_Str"",context.getAppId(),context.getContainerId(),context.getCurrentIteration(),TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - start));
}","/** 
 * Wait for all workers done in current iteration.
 */
@Override public void preIteration(final MasterContext<MASTER_RESULT,WORKER_RESULT> context){
synchronized (LOCK) {
    this.currentInteration=context.getCurrentIteration();
    this.canUpdateWorkerResultMap=true;
  }
  long start=System.nanoTime();
  new RetryCoordinatorCommand(isFixedTime(),getSleepTime()){
    @Override public boolean retryExecution() throws KeeperException, InterruptedException {
      int doneWorkers;
synchronized (LOCK) {
        doneWorkers=(int)NettyMasterCoordinator.this.iterResults.size();
      }
      if (System.nanoTime() % 30 == 0) {
        LOG.info(""String_Node_Str"",context.getCurrentIteration(),doneWorkers,(context.getWorkers() - doneWorkers));
      }
      boolean isTerminated=false;
      if (context.isFirstIteration() || context.getCurrentIteration() == context.getTotalIteration()) {
        isTerminated=isTerminated(doneWorkers,context.getWorkers(),context.getMinWorkersRatio(),GuaguaConstants.GUAGUA_DEFAULT_MIN_WORKERS_TIMEOUT);
        if (isTerminated) {
synchronized (LOCK) {
            NettyMasterCoordinator.this.canUpdateWorkerResultMap=false;
          }
          LOG.info(""String_Node_Str"",context.getCurrentIteration(),context.getWorkers(),doneWorkers,context.getMinWorkersRatio(),GuaguaConstants.GUAGUA_DEFAULT_MIN_WORKERS_TIMEOUT);
        }
      }
 else {
        isTerminated=isTerminated(doneWorkers,context.getWorkers(),context.getMinWorkersRatio(),context.getMinWorkersTimeOut());
        if (isTerminated) {
synchronized (LOCK) {
            NettyMasterCoordinator.this.canUpdateWorkerResultMap=false;
          }
          LOG.info(""String_Node_Str"",context.getCurrentIteration(),context.getWorkers(),doneWorkers,context.getMinWorkersRatio(),context.getMinWorkersTimeOut());
        }
      }
      return isTerminated;
    }
  }
.execute();
synchronized (LOCK) {
    this.canUpdateWorkerResultMap=false;
    this.iterResults.switchState();
  }
  final int currentIter=this.currentInteration;
  context.setWorkerResults(new Iterable<WORKER_RESULT>(){
    @Override public Iterator<WORKER_RESULT> iterator(){
      return new Iterator<WORKER_RESULT>(){
        private Iterator<BytableWrapper> localItr;
        private volatile AtomicBoolean isStart=new AtomicBoolean();
        private boolean isPrint=false;
        BytableWrapper current=null;
        @Override public boolean hasNext(){
          boolean hasNext;
synchronized (LOCK) {
            if (!isPrint) {
              Iterator<BytableWrapper> ii=NettyMasterCoordinator.this.iterResults.iterator();
              int curr=0, notCurr=0;
              while (ii.hasNext()) {
                BytableWrapper next=ii.next();
                if (NettyMasterCoordinator.this.currentInteration == next.getCurrentIteration()) {
                  curr+=1;
                }
 else {
                  notCurr+=1;
                  LOG.info(""String_Node_Str"",next);
                }
              }
              LOG.info(""String_Node_Str"",curr,notCurr);
              isPrint=true;
            }
            if (this.isStart.compareAndSet(false,true)) {
              this.localItr=NettyMasterCoordinator.this.iterResults.iterator();
            }
            hasNext=this.localItr.hasNext();
            if (hasNext) {
              this.current=this.localItr.next();
              while (this.current.getCurrentIteration() != currentIter) {
                hasNext=this.localItr.hasNext();
                if (hasNext) {
                  this.current=this.localItr.next();
                  continue;
                }
 else {
                  break;
                }
              }
            }
            if (!hasNext) {
              this.localItr=NettyMasterCoordinator.this.iterResults.iterator();
              return false;
            }
          }
          return hasNext;
        }
        @Override public WORKER_RESULT next(){
synchronized (LOCK) {
            return NettyMasterCoordinator.this.getWorkerSerializer().bytesToObject(this.current.getBytes(),context.getWorkerResultClassName());
          }
        }
        @Override public void remove(){
          throw new UnsupportedOperationException();
        }
      }
;
    }
  }
);
  LOG.info(""String_Node_Str"",context.getAppId(),context.getContainerId(),context.getCurrentIteration(),TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - start));
}",0.9923111714156492
80321,"/** 
 * Send worker results to master; wait for current master stop; get current master result.
 */
@Override public void postIteration(final WorkerContext<MASTER_RESULT,WORKER_RESULT> context){
  final long timeOutThreshold=NumberFormatUtils.getLong(context.getProps().getProperty(GUAGUA_WORKER_GETRESULT_TIMEOUT),GUAGUA_DEFAULT_WORKER_GETRESULT_TIMEOUT);
  while (true) {
    this.isTimeoutToGetCurrentMasterResult=false;
    int latestIteraton=getLatestMasterIteration(context);
    if (context.getCurrentIteration() == latestIteraton + 1 && context.getCurrentIteration() <= context.getTotalIteration()) {
      new BasicCoordinatorCommand(){
        @Override public void doExecute() throws KeeperException, InterruptedException {
          String appId=context.getAppId();
          int currentIteration=context.getCurrentIteration();
          final String appMasterNode=getCurrentMasterNode(appId,currentIteration).toString();
          BytableWrapper workerMessage=new BytableWrapper();
          workerMessage.setBytes(NettyWorkerCoordinator.this.getWorkerSerializer().objectToBytes(context.getWorkerResult()));
          workerMessage.setCurrentIteration(context.getCurrentIteration());
          workerMessage.setContainerId(context.getContainerId());
          workerMessage.setStopMessage(false);
          LOG.debug(""String_Node_Str"",workerMessage);
          NettyWorkerCoordinator.this.clientChannel.write(workerMessage);
          final long start=System.nanoTime();
          new RetryCoordinatorCommand(isFixedTime(),getSleepTime()){
            @Override public boolean retryExecution() throws KeeperException, InterruptedException {
              try {
                if (TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - start) >= timeOutThreshold) {
                  NettyWorkerCoordinator.this.isTimeoutToGetCurrentMasterResult=true;
                  return true;
                }
                return getZooKeeper().exists(appMasterNode,false) != null || NettyWorkerCoordinator.this.isServerShutdownOrClientDisconnect.get();
              }
 catch (              KeeperException.NoNodeException e) {
                if (System.nanoTime() % 10 == 0) {
                  LOG.warn(""String_Node_Str"",appMasterNode);
                }
                return false;
              }
            }
          }
.execute();
          if (!NettyWorkerCoordinator.this.isTimeoutToGetCurrentMasterResult) {
            LOG.info(""String_Node_Str"",context.getAppId(),context.getContainerId(),context.getCurrentIteration(),TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - start));
            if (!NettyWorkerCoordinator.this.isServerShutdownOrClientDisconnect.get()) {
              String appMasterSplitNode=getCurrentMasterSplitNode(appId,currentIteration).toString();
              setMasterResult(context,appMasterNode,appMasterSplitNode);
              LOG.info(""String_Node_Str"");
            }
          }
        }
      }
.execute();
      if (NettyWorkerCoordinator.this.isTimeoutToGetCurrentMasterResult) {
        continue;
      }
 else {
        break;
      }
    }
 else {
      LOG.info(""String_Node_Str"",context.getAppId(),context.getContainerId(),latestIteraton);
      context.setCurrentIteration(latestIteraton);
      if (!context.isInitIteration()) {
        new BasicCoordinatorCommand(){
          @Override public void doExecute() throws KeeperException, InterruptedException {
            String appId=context.getAppId();
            int lastIteration=context.getCurrentIteration();
            final String appMasterNode=getCurrentMasterNode(appId,lastIteration).toString();
            final String appMasterSplitNode=getCurrentMasterSplitNode(appId,lastIteration).toString();
            setMasterResult(context,appMasterNode,appMasterSplitNode);
          }
        }
.execute();
      }
      break;
    }
  }
}","/** 
 * Send worker results to master; wait for current master stop; get current master result.
 */
@Override public void postIteration(final WorkerContext<MASTER_RESULT,WORKER_RESULT> context){
  final long timeOutThreshold=NumberFormatUtils.getLong(context.getProps().getProperty(GUAGUA_WORKER_GETRESULT_TIMEOUT),GUAGUA_DEFAULT_WORKER_GETRESULT_TIMEOUT);
  while (true) {
    this.isTimeoutToGetCurrentMasterResult=false;
    this.isMasterZnodeCleaned=false;
    int latestIteraton=getLatestMasterIteration(context);
    if (context.getCurrentIteration() == latestIteraton + 1 && context.getCurrentIteration() <= context.getTotalIteration()) {
      new BasicCoordinatorCommand(){
        @Override public void doExecute() throws KeeperException, InterruptedException {
          String appId=context.getAppId();
          int currentIteration=context.getCurrentIteration();
          final String appMasterNode=getCurrentMasterNode(appId,currentIteration).toString();
          BytableWrapper workerMessage=new BytableWrapper();
          workerMessage.setBytes(NettyWorkerCoordinator.this.getWorkerSerializer().objectToBytes(context.getWorkerResult()));
          workerMessage.setCurrentIteration(context.getCurrentIteration());
          workerMessage.setContainerId(context.getContainerId());
          workerMessage.setStopMessage(false);
          LOG.debug(""String_Node_Str"",workerMessage);
          NettyWorkerCoordinator.this.clientChannel.write(workerMessage);
          final long start=System.nanoTime();
          new RetryCoordinatorCommand(isFixedTime(),getSleepTime()){
            @Override public boolean retryExecution() throws KeeperException, InterruptedException {
              try {
                if (TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - start) >= timeOutThreshold) {
                  NettyWorkerCoordinator.this.isTimeoutToGetCurrentMasterResult=true;
                  return true;
                }
                return getZooKeeper().exists(appMasterNode,false) != null || NettyWorkerCoordinator.this.isServerShutdownOrClientDisconnect.get();
              }
 catch (              KeeperException.NoNodeException e) {
                if (System.nanoTime() % 10 == 0) {
                  LOG.warn(""String_Node_Str"",appMasterNode);
                }
                return false;
              }
            }
          }
.execute();
          if (!NettyWorkerCoordinator.this.isTimeoutToGetCurrentMasterResult) {
            LOG.info(""String_Node_Str"",context.getAppId(),context.getContainerId(),context.getCurrentIteration(),TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - start));
            if (!NettyWorkerCoordinator.this.isServerShutdownOrClientDisconnect.get()) {
              String appMasterSplitNode=getCurrentMasterSplitNode(appId,currentIteration).toString();
              try {
                setMasterResult(context,appMasterNode,appMasterSplitNode);
              }
 catch (              KeeperException.NoNodeException e) {
                NettyWorkerCoordinator.this.isMasterZnodeCleaned=true;
                LOG.warn(""String_Node_Str"",appMasterNode);
              }
              LOG.info(""String_Node_Str"");
            }
          }
        }
      }
.execute();
      if (NettyWorkerCoordinator.this.isTimeoutToGetCurrentMasterResult || NettyWorkerCoordinator.this.isMasterZnodeCleaned) {
        continue;
      }
 else {
        break;
      }
    }
 else {
      LOG.info(""String_Node_Str"",context.getAppId(),context.getContainerId(),latestIteraton);
      context.setCurrentIteration(latestIteraton);
      if (!context.isInitIteration()) {
        new BasicCoordinatorCommand(){
          @Override public void doExecute() throws KeeperException, InterruptedException {
            String appId=context.getAppId();
            int lastIteration=context.getCurrentIteration();
            final String appMasterNode=getCurrentMasterNode(appId,lastIteration).toString();
            final String appMasterSplitNode=getCurrentMasterSplitNode(appId,lastIteration).toString();
            try {
              setMasterResult(context,appMasterNode,appMasterSplitNode);
            }
 catch (            KeeperException.NoNodeException e) {
              NettyWorkerCoordinator.this.isMasterZnodeCleaned=true;
              LOG.warn(""String_Node_Str"",appMasterNode);
            }
          }
        }
.execute();
      }
      if (NettyWorkerCoordinator.this.isMasterZnodeCleaned) {
        continue;
      }
 else {
        break;
      }
    }
  }
}",0.8763857432351889
80322,"@Override public void readFields(DataInput in) throws IOException {
  this.currentIteration=in.readInt();
  this.containerId=in.readUTF();
  this.isStopMessage=in.readBoolean();
  int bytesSize=in.readInt();
  if (bytesSize != 0) {
    this.bytes=new byte[bytesSize];
    in.readFully(bytes);
  }
}","@Override public void readFields(DataInput in) throws IOException {
  this.currentIteration=in.readInt();
  int containerIdlen=in.readInt();
  if (containerIdlen != 0) {
    byte[] containerIdbytes=new byte[containerIdlen];
    for (int i=0; i < containerIdbytes.length; i++) {
      containerIdbytes[i]=in.readByte();
    }
    this.containerId=new String(containerIdbytes,Charset.forName(""String_Node_Str""));
  }
 else {
    this.containerId=null;
  }
  this.isStopMessage=in.readBoolean();
  int bytesSize=in.readInt();
  if (bytesSize != 0) {
    this.bytes=new byte[bytesSize];
    for (int i=0; i < this.bytes.length; i++) {
      this.bytes[i]=in.readByte();
    }
  }
}",0.5066666666666667
80323,"@Override public void write(DataOutput out) throws IOException {
  out.writeInt(this.currentIteration);
  out.writeUTF(this.containerId);
  out.writeBoolean(this.isStopMessage);
  if (this.bytes != null) {
    out.writeInt(bytes.length);
    out.write(bytes);
  }
 else {
    out.writeInt(0);
  }
}","@Override public void write(DataOutput out) throws IOException {
  out.writeInt(this.currentIteration);
  if (this.containerId == null) {
    out.writeInt(0);
  }
 else {
    writeBytes(out,this.containerId.getBytes(Charset.forName(""String_Node_Str"")));
  }
  out.writeBoolean(this.isStopMessage);
  if (this.bytes != null) {
    out.writeInt(bytes.length);
    for (int i=0; i < bytes.length; i++) {
      out.writeByte(bytes[i]);
    }
  }
 else {
    out.writeInt(0);
  }
}",0.7028423772609819
80324,"/** 
 * Update master computable result to master znode. At the same time clean znodes for old iterations. Iteration 0 and last iteration will not be removed for fail over.
 */
@Override public void postIteration(final MasterContext<MASTER_RESULT,WORKER_RESULT> context){
  new BasicCoordinatorCommand(){
    @Override public void doExecute() throws KeeperException, InterruptedException {
      updateMasterHaltStatus(context);
      boolean isSplit=false;
      String appCurrentMasterNode=getCurrentMasterNode(context.getAppId(),context.getCurrentIteration()).toString();
      String appCurrentMasterSplitNode=getCurrentMasterSplitNode(context.getAppId(),context.getCurrentIteration()).toString();
      LOG.debug(""String_Node_Str"",context.getMasterResult());
      try {
        byte[] bytes=getMasterSerializer().objectToBytes(context.getMasterResult());
        isSplit=setBytesToZNode(appCurrentMasterNode,appCurrentMasterSplitNode,bytes,CreateMode.PERSISTENT);
      }
 catch (      KeeperException.NodeExistsException e) {
        LOG.warn(""String_Node_Str"",e);
      }
      if (context.getCurrentIteration() >= 3) {
        String znode=getMasterNode(context.getAppId(),context.getCurrentIteration() - 2).toString();
        try {
          getZooKeeper().deleteExt(znode,-1,false);
          if (isSplit) {
            znode=getCurrentMasterSplitNode(context.getAppId(),context.getCurrentIteration() - 2).toString();
            getZooKeeper().deleteExt(znode,-1,true);
          }
        }
 catch (        KeeperException.NoNodeException e) {
          if (System.nanoTime() % 20 == 0) {
            LOG.warn(""String_Node_Str"",znode);
          }
        }
      }
      LOG.info(""String_Node_Str"");
    }
  }
.execute();
  clear(context.getProps());
}","/** 
 * Update master computable result to master znode. At the same time clean znodes for old iterations. Iteration 0 and last iteration will not be removed for fail over.
 */
@Override public void postIteration(final MasterContext<MASTER_RESULT,WORKER_RESULT> context){
  new BasicCoordinatorCommand(){
    @Override public void doExecute() throws KeeperException, InterruptedException {
      updateMasterHaltStatus(context);
      clear(context.getProps());
      boolean isSplit=false;
      String appCurrentMasterNode=getCurrentMasterNode(context.getAppId(),context.getCurrentIteration()).toString();
      String appCurrentMasterSplitNode=getCurrentMasterSplitNode(context.getAppId(),context.getCurrentIteration()).toString();
      LOG.debug(""String_Node_Str"",context.getMasterResult());
      try {
        byte[] bytes=getMasterSerializer().objectToBytes(context.getMasterResult());
        isSplit=setBytesToZNode(appCurrentMasterNode,appCurrentMasterSplitNode,bytes,CreateMode.PERSISTENT);
      }
 catch (      KeeperException.NodeExistsException e) {
        LOG.warn(""String_Node_Str"",e);
      }
      if (context.getCurrentIteration() >= 3) {
        String znode=getMasterNode(context.getAppId(),context.getCurrentIteration() - 2).toString();
        try {
          getZooKeeper().deleteExt(znode,-1,false);
          if (isSplit) {
            znode=getCurrentMasterSplitNode(context.getAppId(),context.getCurrentIteration() - 2).toString();
            getZooKeeper().deleteExt(znode,-1,true);
          }
        }
 catch (        KeeperException.NoNodeException e) {
          if (System.nanoTime() % 20 == 0) {
            LOG.warn(""String_Node_Str"",znode);
          }
        }
      }
      LOG.info(""String_Node_Str"");
    }
  }
.execute();
}",0.9824759751271904
80325,"/** 
 * Start netty server which is used to communicate with workers.
 */
private void startNettyServer(Properties props){
  this.messageServerPort=NumberFormatUtils.getInt(props.getProperty(GuaguaConstants.GUAGUA_NETTY_SEVER_PORT),GuaguaConstants.GUAGUA_NETTY_SEVER_DEFAULT_PORT);
  this.messageServerPort=NetworkUtils.getValidServerPort(this.messageServerPort);
  this.messageServer=new ServerBootstrap(new NioServerSocketChannelFactory(Executors.newFixedThreadPool(GuaguaConstants.GUAGUA_NETTY_SERVER_DEFAULT_THREAD_COUNT),Executors.newCachedThreadPool()));
  this.messageServer.setPipelineFactory(new ChannelPipelineFactory(){
    public ChannelPipeline getPipeline() throws Exception {
      return Channels.pipeline(new NettyBytableEncoder(),new NettyBytableDecoder(),new ServerHandler());
    }
  }
);
  try {
    this.messageServer.bind(new InetSocketAddress(this.messageServerPort));
  }
 catch (  ChannelException e) {
    LOG.warn(e.getMessage() + ""String_Node_Str"");
    this.messageServerPort=NetworkUtils.getValidServerPort(this.messageServerPort);
    this.messageServer.bind(new InetSocketAddress(this.messageServerPort));
  }
}","/** 
 * Start netty server which is used to communicate with workers.
 */
private void startNettyServer(Properties props){
  this.messageServerPort=NumberFormatUtils.getInt(props.getProperty(GuaguaConstants.GUAGUA_NETTY_SEVER_PORT),GuaguaConstants.GUAGUA_NETTY_SEVER_DEFAULT_PORT);
  this.messageServerPort=NetworkUtils.getValidServerPort(this.messageServerPort);
  this.messageServer=new ServerBootstrap(new NioServerSocketChannelFactory(Executors.newFixedThreadPool(GuaguaConstants.GUAGUA_NETTY_SERVER_DEFAULT_THREAD_COUNT),Executors.newCachedThreadPool(new MasterThreadFactory())));
  this.messageServer.setPipelineFactory(new ChannelPipelineFactory(){
    public ChannelPipeline getPipeline() throws Exception {
      return Channels.pipeline(new NettyBytableEncoder(),new NettyBytableDecoder(),new ServerHandler());
    }
  }
);
  try {
    this.messageServer.bind(new InetSocketAddress(this.messageServerPort));
  }
 catch (  ChannelException e) {
    LOG.warn(e.getMessage() + ""String_Node_Str"");
    this.messageServerPort=NetworkUtils.getValidServerPort(this.messageServerPort);
    this.messageServer.bind(new InetSocketAddress(this.messageServerPort));
  }
}",0.9891915261565069
80326,"/** 
 * Re-open stream for iterators.
 */
public void reOpen(){
  close();
  try {
    this.inputStream=new FileInputStream(file);
  }
 catch (  FileNotFoundException e) {
    throw new GuaguaRuntimeException(e);
  }
}","/** 
 * Re-open stream for iterators.
 */
public void reOpen(){
  close();
  try {
    this.inputStream=new DataInputStream(new FileInputStream(file));
  }
 catch (  FileNotFoundException e) {
    throw new GuaguaRuntimeException(e);
  }
}",0.9540481400437636
80327,"@Override public T next(){
  try {
    int length=BytableDiskList.this.inputStream.read();
    byte[] bytes=new byte[length];
    int size=BytableDiskList.this.inputStream.read(bytes);
    if (size < 0) {
      throw new GuaguaRuntimeException(""String_Node_Str"");
    }
    return BytableDiskList.this.getSerializer().bytesToObject(bytes,className);
  }
 catch (  IOException e) {
    throw new GuaguaRuntimeException(e);
  }
}","@Override public T next(){
  try {
    int length=BytableDiskList.this.inputStream.readInt();
    byte[] bytes=new byte[length];
    int size=BytableDiskList.this.inputStream.read(bytes);
    if (size < 0) {
      throw new GuaguaRuntimeException(""String_Node_Str"");
    }
    return BytableDiskList.this.getSerializer().bytesToObject(bytes,className);
  }
 catch (  IOException e) {
    throw new GuaguaRuntimeException(e);
  }
}",0.9964994165694282
80328,"@Override public void clear(){
  FileUtils.deleteQuietly(file);
}","/** 
 * Delete file to store elements. After this method call, user cannot use such list. But clear here is used to clear resources used.
 */
@Override public void clear(){
  FileUtils.deleteQuietly(file);
}",0.4779411764705882
80329,"/** 
 * Constructor with file name in current working dir, class name and serializer instance.
 */
public BytableDiskList(String fileName,String className,BytableSerializer<T> serializer){
  try {
    this.file=new File(fileName);
    this.outputStream=new FileOutputStream(file);
    this.inputStream=new FileInputStream(file);
  }
 catch (  FileNotFoundException e) {
    throw new GuaguaRuntimeException(e);
  }
  this.className=className;
  this.serializer=serializer;
}","/** 
 * Constructor with file name in current working dir, class name and serializer instance.
 */
public BytableDiskList(String fileName,String className,BytableSerializer<T> serializer){
  try {
    this.file=new File(fileName);
    this.outputStream=new DataOutputStream(new FileOutputStream(file));
    this.inputStream=new DataInputStream(new FileInputStream(file));
  }
 catch (  FileNotFoundException e) {
    throw new GuaguaRuntimeException(e);
  }
  this.className=className;
  this.serializer=serializer;
}",0.9566094853683148
80330,"@Override public Iterator<T> iterator(){
  if (this.state != State.READ) {
    throw new IllegalStateException();
  }
  return new Iterator<T>(){
    @Override public boolean hasNext(){
      try {
        return BytableDiskList.this.inputStream.available() > 0;
      }
 catch (      IOException e) {
        return false;
      }
    }
    @Override public T next(){
      try {
        int length=BytableDiskList.this.inputStream.read();
        byte[] bytes=new byte[length];
        int size=BytableDiskList.this.inputStream.read(bytes);
        if (size < 0) {
          throw new GuaguaRuntimeException(""String_Node_Str"");
        }
        return BytableDiskList.this.getSerializer().bytesToObject(bytes,className);
      }
 catch (      IOException e) {
        throw new GuaguaRuntimeException(e);
      }
    }
    @Override public void remove(){
      throw new UnsupportedOperationException();
    }
  }
;
}","@Override public Iterator<T> iterator(){
  if (this.state != State.READ) {
    throw new IllegalStateException();
  }
  return new Iterator<T>(){
    @Override public boolean hasNext(){
      try {
        return BytableDiskList.this.inputStream.available() > 0;
      }
 catch (      IOException e) {
        return false;
      }
    }
    @Override public T next(){
      try {
        int length=BytableDiskList.this.inputStream.readInt();
        byte[] bytes=new byte[length];
        int size=BytableDiskList.this.inputStream.read(bytes);
        if (size < 0) {
          throw new GuaguaRuntimeException(""String_Node_Str"");
        }
        return BytableDiskList.this.getSerializer().bytesToObject(bytes,className);
      }
 catch (      IOException e) {
        throw new GuaguaRuntimeException(e);
      }
    }
    @Override public void remove(){
      throw new UnsupportedOperationException();
    }
  }
;
}",0.9983722192078134
80331,"@Override public boolean append(T t){
  if (this.state != State.WRITE) {
    throw new IllegalStateException();
  }
  this.count+=1;
  byte[] bytes=getSerializer().objectToBytes(t);
  try {
    this.outputStream.write(bytes.length);
    this.outputStream.write(bytes);
  }
 catch (  IOException e) {
    throw new GuaguaRuntimeException(e);
  }
  return true;
}","@Override public boolean append(T t){
  if (this.state != State.WRITE) {
    throw new IllegalStateException();
  }
  this.count+=1;
  byte[] bytes=getSerializer().objectToBytes(t);
  try {
    this.outputStream.writeInt(bytes.length);
    this.outputStream.write(bytes);
  }
 catch (  IOException e) {
    throw new GuaguaRuntimeException(e);
  }
  return true;
}",0.9958620689655172
80332,"/** 
 * Switch state from WRITE to READ
 */
@Override public void switchState(){
  this.state=State.READ;
}","/** 
 * Switch state from WRITE to READ
 */
@Override public void switchState(){
  this.state=State.READ;
  try {
    this.outputStream.flush();
  }
 catch (  IOException e) {
    throw new GuaguaRuntimeException(e);
  }
}",0.6504559270516718
80333,"/** 
 * Send stop message to master and then clean resources.
 */
@Override public void postApplication(final WorkerContext<MASTER_RESULT,WORKER_RESULT> context){
  new BasicCoordinatorCommand(){
    @Override public void doExecute() throws Exception, InterruptedException {
      try {
        BytableWrapper stopMessage=new BytableWrapper();
        stopMessage.setCurrentIteration(context.getCurrentIteration());
        stopMessage.setContainerId(context.getContainerId());
        stopMessage.setStopMessage(true);
        ChannelFuture future=NettyWorkerCoordinator.this.clientChannel.write(stopMessage);
        future.await(5,TimeUnit.SECONDS);
      }
  finally {
        NettyWorkerCoordinator.this.clientChannel.close();
        Method shutDownMethod=ReflectionUtils.getMethod(NettyWorkerCoordinator.this.messageClient.getClass(),""String_Node_Str"");
        if (shutDownMethod != null) {
          shutDownMethod.invoke(NettyWorkerCoordinator.this.messageClient,(Object[])null);
        }
        NettyWorkerCoordinator.this.messageClient.releaseExternalResources();
        closeZooKeeper();
      }
    }
  }
.execute();
}","/** 
 * Send stop message to master and then clean resources.
 */
@Override public void postApplication(final WorkerContext<MASTER_RESULT,WORKER_RESULT> context){
  new BasicCoordinatorCommand(){
    @Override public void doExecute() throws Exception, InterruptedException {
      try {
        BytableWrapper stopMessage=new BytableWrapper();
        stopMessage.setCurrentIteration(context.getCurrentIteration());
        stopMessage.setContainerId(context.getContainerId());
        stopMessage.setStopMessage(true);
        ChannelFuture future=NettyWorkerCoordinator.this.clientChannel.write(stopMessage);
        future.await(30,TimeUnit.SECONDS);
      }
  finally {
        NettyWorkerCoordinator.this.clientChannel.close();
        Method shutDownMethod=ReflectionUtils.getMethod(NettyWorkerCoordinator.this.messageClient.getClass(),""String_Node_Str"");
        if (shutDownMethod != null) {
          shutDownMethod.invoke(NettyWorkerCoordinator.this.messageClient,(Object[])null);
        }
        NettyWorkerCoordinator.this.messageClient.releaseExternalResources();
        closeZooKeeper();
      }
    }
  }
.execute();
}",0.998678996036988
80334,"@Override public void doExecute() throws Exception, InterruptedException {
  try {
    BytableWrapper stopMessage=new BytableWrapper();
    stopMessage.setCurrentIteration(context.getCurrentIteration());
    stopMessage.setContainerId(context.getContainerId());
    stopMessage.setStopMessage(true);
    ChannelFuture future=NettyWorkerCoordinator.this.clientChannel.write(stopMessage);
    future.await(5,TimeUnit.SECONDS);
  }
  finally {
    NettyWorkerCoordinator.this.clientChannel.close();
    Method shutDownMethod=ReflectionUtils.getMethod(NettyWorkerCoordinator.this.messageClient.getClass(),""String_Node_Str"");
    if (shutDownMethod != null) {
      shutDownMethod.invoke(NettyWorkerCoordinator.this.messageClient,(Object[])null);
    }
    NettyWorkerCoordinator.this.messageClient.releaseExternalResources();
    closeZooKeeper();
  }
}","@Override public void doExecute() throws Exception, InterruptedException {
  try {
    BytableWrapper stopMessage=new BytableWrapper();
    stopMessage.setCurrentIteration(context.getCurrentIteration());
    stopMessage.setContainerId(context.getContainerId());
    stopMessage.setStopMessage(true);
    ChannelFuture future=NettyWorkerCoordinator.this.clientChannel.write(stopMessage);
    future.await(30,TimeUnit.SECONDS);
  }
  finally {
    NettyWorkerCoordinator.this.clientChannel.close();
    Method shutDownMethod=ReflectionUtils.getMethod(NettyWorkerCoordinator.this.messageClient.getClass(),""String_Node_Str"");
    if (shutDownMethod != null) {
      shutDownMethod.invoke(NettyWorkerCoordinator.this.messageClient,(Object[])null);
    }
    NettyWorkerCoordinator.this.messageClient.releaseExternalResources();
    closeZooKeeper();
  }
}",0.998234255444379
80335,"/** 
 * Check whether a server is alive.
 * @param host the server host
 * @param port the server port
 * @return true if a server is alive, false if a server is not alive.
 */
public static boolean isServerAlive(String host,int port){
  Socket socket=null;
  int i=0;
  while (i++ < RETRY_COUNT) {
    try {
      socket=new Socket(host,port);
      break;
    }
 catch (    IOException e) {
      try {
        Thread.sleep(1000);
      }
 catch (      InterruptedException e1) {
        Thread.currentThread().interrupt();
      }
    }
 finally {
      try {
        if (socket != null) {
          socket.close();
        }
      }
 catch (      IOException ignore) {
      }
    }
  }
  return i == RETRY_COUNT;
}","/** 
 * Check whether a server is alive.
 * @param host the server host
 * @param port the server port
 * @return true if a server is alive, false if a server is not alive.
 */
public static boolean isServerAlive(String host,int port){
  Socket socket=null;
  int i=0;
  while (i++ < RETRY_COUNT) {
    try {
      socket=new Socket(host,port);
      break;
    }
 catch (    IOException e) {
      try {
        Thread.sleep(1000);
      }
 catch (      InterruptedException e1) {
        Thread.currentThread().interrupt();
      }
    }
 finally {
      try {
        if (socket != null) {
          socket.close();
        }
      }
 catch (      IOException ignore) {
      }
    }
  }
  return i < RETRY_COUNT;
}",0.9979123173277662
80336,"/** 
 * Check zookeeper servers, if one of them is alive, return true;
 */
public static boolean checkServers(String servers){
  String[] serverArray=servers.split(""String_Node_Str"");
  for (  String server : serverArray) {
    if (server != null) {
      server=server.trim();
      String port=null;
      String host=null;
      if (server.indexOf(':') > 0) {
        String[] hostAndPort=server.split(""String_Node_Str"");
        host=hostAndPort[0].trim();
        port=hostAndPort[1].trim();
      }
 else {
        host=server;
      }
      if (isServerAlive(host,Integer.parseInt(port))) {
        return true;
      }
    }
  }
  return false;
}","/** 
 * Check zookeeper servers, if one of them is alive, return true;
 */
public static boolean checkServers(String servers){
  String[] serverArray=servers.split(""String_Node_Str"");
  for (  String server : serverArray) {
    if (server != null) {
      server=server.trim();
      String port=null;
      String host=null;
      if (server.indexOf(':') > 0) {
        String[] hostAndPort=server.split(""String_Node_Str"");
        host=hostAndPort[0].trim();
        port=hostAndPort[1].trim();
      }
 else {
        host=server;
        port=DEFAULT_ZK_PORT + ""String_Node_Str"";
      }
      if (isServerAlive(host,Integer.parseInt(port))) {
        return true;
      }
    }
  }
  return false;
}",0.9631811487481592
80337,"/** 
 * Iterate   {@link WorkerComputable#compute(WorkerContext)}, and set hook point before and after each iteration.
 */
@Override public void run(Progressable progress){
  WorkerContext<MASTER_RESULT,WORKER_RESULT> context=buildContext();
  int iteration=context.getCurrentIteration();
  while (iteration < getTotalIteration()) {
    int currIter=iteration + 1;
    context.setCurrentIteration(currIter);
    iterate(context,currIter,progress);
    iteration=context.getCurrentIteration();
    MASTER_RESULT masterResult=context.getLastMasterResult();
    if ((masterResult instanceof HaltBytable) && ((HaltBytable)masterResult).isHalt()) {
      break;
    }
  }
}","/** 
 * Iterate   {@link WorkerComputable#compute(WorkerContext)}, and set hook point before and after each iteration.
 */
@Override public void run(Progressable progress){
  WorkerContext<MASTER_RESULT,WORKER_RESULT> context=buildContext();
  int firstIteration=context.getCurrentIteration() + 1;
  int iteration=context.getCurrentIteration();
  while (iteration < getTotalIteration()) {
    int currIter=iteration + 1;
    context.setCurrentIteration(currIter);
    iterate(context,firstIteration,progress);
    iteration=context.getCurrentIteration();
    MASTER_RESULT masterResult=context.getLastMasterResult();
    if ((masterResult instanceof HaltBytable) && ((HaltBytable)masterResult).isHalt()) {
      break;
    }
  }
}",0.9427753934191704
80338,"@Override public GuaguaWritableAdapter<LongWritable> doCompute(WorkerContext<GuaguaWritableAdapter<LongWritable>,GuaguaWritableAdapter<LongWritable>> context){
  long sum=context.getLastMasterResult() == null ? 0l : context.getLastMasterResult().getWritable().get();
  this.list.reOpen();
  for (  Long longValue : this.list) {
    sum+=longValue;
  }
  try {
    Thread.sleep(10 * 1000);
  }
 catch (  InterruptedException e) {
    e.printStackTrace();
  }
  LOG.info(""String_Node_Str"",context,sum);
  return new GuaguaWritableAdapter<LongWritable>(new LongWritable(sum));
}","@Override public GuaguaWritableAdapter<LongWritable> doCompute(WorkerContext<GuaguaWritableAdapter<LongWritable>,GuaguaWritableAdapter<LongWritable>> context){
  long sum=context.getLastMasterResult() == null ? 0l : context.getLastMasterResult().getWritable().get();
  this.list.reOpen();
  for (  Long longValue : this.list) {
    sum+=longValue;
  }
  LOG.info(""String_Node_Str"",context,sum);
  return new GuaguaWritableAdapter<LongWritable>(new LongWritable(sum));
}",0.8984674329501916
80339,"@Override protected void setUp() throws Exception {
  super.setUp();
  final String dexCache=getContext().getCacheDir().getPath();
  System.setProperty(""String_Node_Str"",dexCache);
  rootFile=new File(Environment.getExternalStorageDirectory(),""String_Node_Str"");
  FileGenerator.generate(rootFile);
  driven=new ExternalDrive(rootFile.getAbsolutePath());
  Credential credential=new Credential(getContext());
  ExternalDriveFile.setStorageProvider(driven);
  driven.authenticate(credential);
  remoteDir=driven.get(""String_Node_Str"");
  remoteFile=driven.get(remoteDir,""String_Node_Str"");
}","@Override protected void setUp() throws Exception {
  super.setUp();
  final String dexCache=getContext().getCacheDir().getPath();
  System.setProperty(""String_Node_Str"",dexCache);
  rootFile=new File(Environment.getExternalStorageDirectory(),""String_Node_Str"");
  FileGenerator.generate(rootFile);
  driven=new ExternalDrive();
  Credential credential=new Credential(getContext(),rootFile.getAbsolutePath());
  ExternalDriveFile.setStorageProvider(driven);
  driven.authenticate(credential);
  remoteDir=driven.get(""String_Node_Str"");
  remoteFile=driven.get(remoteDir,""String_Node_Str"");
}",0.6435224386113463
80340,"public void test_create_file() throws Exception {
  RemoteFile remoteFile=driven.get(""String_Node_Str"");
  LocalFile localFile=new LocalFile(new File(remoteFile.getId()));
  remoteFile=driven.create(""String_Node_Str"",localFile);
  assertNotNull(remoteFile);
  assertFalse(remoteFile.isDirectory());
  remoteFile=driven.id(""String_Node_Str"");
  assertNotNull(remoteFile);
  assertFalse(remoteFile.isDirectory());
}","public void test_create_file() throws Exception {
  driven.authenticate(credential);
  RemoteFile remoteFile=driven.get(""String_Node_Str"");
  LocalFile localFile=new LocalFile(new File(remoteFile.getId()));
  remoteFile=driven.create(""String_Node_Str"",localFile);
  assertNotNull(remoteFile);
  assertFalse(remoteFile.isDirectory());
  remoteFile=driven.id(""String_Node_Str"");
  assertNotNull(remoteFile);
  assertFalse(remoteFile.isDirectory());
}",0.959349593495935
80341,"@Override protected void setUp() throws Exception {
  super.setUp();
  final String dexCache=getContext().getCacheDir().getPath();
  System.setProperty(""String_Node_Str"",dexCache);
  rootFile=new File(Environment.getExternalStorageDirectory(),""String_Node_Str"");
  FileGenerator.generate(rootFile);
  driven=new ExternalDrive(rootFile.getAbsolutePath());
  credential=new Credential(getContext());
  FileGenerator.generate(rootFile);
}","@Override protected void setUp() throws Exception {
  super.setUp();
  final String dexCache=getContext().getCacheDir().getPath();
  System.setProperty(""String_Node_Str"",dexCache);
  rootFile=new File(Environment.getExternalStorageDirectory(),""String_Node_Str"");
  FileGenerator.generate(rootFile);
  driven=new ExternalDrive();
  credential=new Credential(getContext(),rootFile.getAbsolutePath());
}",0.8526946107784431
80342,"public void test_createAsync_file() throws Exception {
  RemoteFile remoteFile=driven.get(""String_Node_Str"");
  LocalFile localFile=new LocalFile(new File(remoteFile.getId()));
  final CountDownLatch signal=new CountDownLatch(1);
  driven.createAsync(""String_Node_Str"",localFile,new Task<RemoteFile>(){
    @Override public void onCompleted(    RemoteFile result){
      assertNotNull(result);
      assertFalse(result.isDirectory());
      result=driven.id(""String_Node_Str"");
      assertNotNull(result);
      assertFalse(result.isDirectory());
      signal.countDown();
    }
  }
);
  signal.await();
}","public void test_createAsync_file() throws Exception {
  driven.authenticate(credential);
  RemoteFile remoteFile=driven.get(""String_Node_Str"");
  LocalFile localFile=new LocalFile(new File(remoteFile.getId()));
  final CountDownLatch signal=new CountDownLatch(1);
  driven.createAsync(""String_Node_Str"",localFile,new Task<RemoteFile>(){
    @Override public void onCompleted(    RemoteFile result){
      assertNotNull(result);
      assertFalse(result.isDirectory());
      result=driven.id(""String_Node_Str"");
      assertNotNull(result);
      assertFalse(result.isDirectory());
      signal.countDown();
    }
  }
);
  signal.await();
}",0.9719326383319968
80343,"public void test_create_fileInParent() throws Exception {
  RemoteFile remoteFile=driven.get(""String_Node_Str"");
  LocalFile localFile=new LocalFile(new File(remoteFile.getId()));
  driven.authenticate(credential);
  RemoteFile parent=driven.create(""String_Node_Str"");
  assertNotNull(parent);
  remoteFile=driven.create(parent,""String_Node_Str"",localFile);
  assertNotNull(remoteFile);
  assertFalse(remoteFile.isDirectory());
}","public void test_create_fileInParent() throws Exception {
  driven.authenticate(credential);
  RemoteFile remoteFile=driven.get(""String_Node_Str"");
  LocalFile localFile=new LocalFile(new File(remoteFile.getId()));
  driven.authenticate(credential);
  RemoteFile parent=driven.create(""String_Node_Str"");
  assertNotNull(parent);
  remoteFile=driven.create(parent,""String_Node_Str"",localFile);
  assertNotNull(remoteFile);
  assertFalse(remoteFile.isDirectory());
}",0.9608062709966404
80344,"public void test_createAsync_fileInParent() throws Exception {
  RemoteFile remoteFile=driven.get(""String_Node_Str"");
  LocalFile localFile=new LocalFile(new File(remoteFile.getId()));
  driven.authenticate(credential);
  RemoteFile parent=driven.create(""String_Node_Str"");
  assertNotNull(parent);
  final CountDownLatch signal=new CountDownLatch(1);
  driven.createAsync(parent,""String_Node_Str"",localFile,new Task<RemoteFile>(){
    @Override public void onCompleted(    RemoteFile result){
      assertNotNull(result);
      assertFalse(result.isDirectory());
      signal.countDown();
    }
  }
);
  signal.await();
}","public void test_createAsync_fileInParent() throws Exception {
  driven.authenticate(credential);
  RemoteFile remoteFile=driven.get(""String_Node_Str"");
  LocalFile localFile=new LocalFile(new File(remoteFile.getId()));
  driven.authenticate(credential);
  RemoteFile parent=driven.create(""String_Node_Str"");
  assertNotNull(parent);
  final CountDownLatch signal=new CountDownLatch(1);
  driven.createAsync(parent,""String_Node_Str"",localFile,new Task<RemoteFile>(){
    @Override public void onCompleted(    RemoteFile result){
      assertNotNull(result);
      assertFalse(result.isDirectory());
      signal.countDown();
    }
  }
);
  signal.await();
}",0.9726348709929632
80345,"@Override public boolean hasSavedCredentials(Context context){
  return true;
}","@Override public boolean hasSavedCredentials(Context context){
  Credential credential=new Credential(context);
  return credential.hasSavedCredential(TAG);
}",0.6582278481012658
80346,"@Override public Result<DrivenException> authenticate(Credential credential,boolean saveCredential){
  return new Result<DrivenException>();
}","@Override public Result<DrivenException> authenticate(Credential credential,boolean saveCredential){
  Log.i(TAG,""String_Node_Str"");
  Result<DrivenException> result=new Result<DrivenException>(false);
  try {
    if (credential == null)     throw new DrivenException(new IllegalArgumentException(""String_Node_Str""));
    if (credential.hasSavedCredential(TAG)) {
      credential.read(TAG);
    }
    root=new File(credential.getAccountName());
    IOUtils.safeCreateDir(root);
    userInfo=new ExternalDriveUserInfo();
    result.setSuccess(true);
    Log.i(TAG,""String_Node_Str"" + userInfo);
    if (saveCredential)     credential.save(TAG);
  }
 catch (  Exception e) {
    Log.i(TAG,""String_Node_Str"");
    Log.e(TAG,""String_Node_Str"",e);
    result.setException(new DrivenException(e));
  }
  return result;
}",0.2675026123301985
80347,"@Override public boolean isAuthenticated(){
  return true;
}","@Override public boolean isAuthenticated(){
  return root != null && userInfo != null;
}",0.7972972972972973
80348,"@Override public UserInfo getDrivenUser(){
  return userInfo;
}","@Override public UserInfo getDrivenUser(){
  if (!isAuthenticated())   throw new DrivenException(""String_Node_Str"");
  return userInfo;
}",0.63
80349,"/** 
 * Creates an external drive with path root
 * @param path the root
 */
public ExternalDrive(String path){
  root=new File(path);
  IOUtils.safeCreateDir(root);
  ExternalDriveFile.setStorageProvider(this);
}","public ExternalDrive(){
  ExternalDriveFile.setStorageProvider(this);
}",0.5
80350,"@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  if (getIntent() != null) {
    String rootPath=getIntent().getStringExtra(BUNDLE_KEY_ROOT);
    if (rootPath != null) {
      storageProvider=new ExternalDrive(rootPath);
      successfullyAuthenticated();
      return;
    }
  }
  throw new DrivenException(""String_Node_Str"");
}","@Override public void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  if (getIntent() != null) {
    String rootPath=getIntent().getStringExtra(BUNDLE_KEY_ROOT);
    if (rootPath != null) {
      storageProvider=new ExternalDrive();
      Result<DrivenException> result=storageProvider.authenticate(new Credential(this,rootPath));
      if (result.isSuccess()) {
        successfullyAuthenticated();
        return;
      }
 else {
        throw new DrivenException(result.getException());
      }
    }
  }
  throw new DrivenException(""String_Node_Str"");
}",0.7489626556016598
80351,"private void authenticate(){
  driven.authenticateAsync(credential,new Task.WithErrorReporting<Result<DrivenException>>(){
    @Override public void onCompleted(    Result<DrivenException> result){
      if (!result.isSuccess()) {
        driven.getDropboxApi().getSession().startOAuth2Authentication(DropboxActivity.this);
      }
 else {
        successfullyAuthorized();
      }
    }
    @Override public void onError(    Throwable error){
      Log.e(driven.getName(),error.getMessage(),error);
      finish();
    }
  }
);
}","private void authenticate(){
  driven.authenticateAsync(credential,new Task.WithErrorReporting<Result<DrivenException>>(){
    @Override public void onCompleted(    Result<DrivenException> result){
      if (!result.isSuccess()) {
        driven.getDropboxApi().getSession().startOAuth2Authentication(DropboxActivity.this);
      }
 else {
        successfullyAuthenticated();
      }
    }
    @Override public void onError(    Throwable error){
      Log.e(driven.getName(),error.getMessage(),error);
      finish();
    }
  }
);
}",0.9896519285042332
80352,"@Override public void onCompleted(Result<DrivenException> result){
  if (!result.isSuccess()) {
    driven.getDropboxApi().getSession().startOAuth2Authentication(DropboxActivity.this);
  }
 else {
    successfullyAuthorized();
  }
}","@Override public void onCompleted(Result<DrivenException> result){
  if (!result.isSuccess()) {
    driven.getDropboxApi().getSession().startOAuth2Authentication(DropboxActivity.this);
  }
 else {
    successfullyAuthenticated();
  }
}",0.9764453961456104
80353,"@Override protected void onResume(){
  super.onResume();
  try {
    if (driven.getDropboxApi().getSession().authenticationSuccessful()) {
      driven.getDropboxApi().getSession().finishAuthentication();
      credential.getToken().setAccessToken(driven.getDropboxApi().getSession().getOAuth2AccessToken());
    }
 else {
      finish();
    }
  }
 catch (  DrivenException e) {
    authenticate();
  }
}","@Override protected void onResume(){
  super.onResume();
  try {
    if (driven.getDropboxApi().getSession().authenticationSuccessful()) {
      driven.getDropboxApi().getSession().finishAuthentication();
      credential.getToken().setAccessToken(driven.getDropboxApi().getSession().getOAuth2AccessToken());
      successfullyAuthenticated();
    }
 else {
      finish();
    }
  }
 catch (  DrivenException e) {
    authenticate();
  }
}",0.9585798816568049
80354,"@Override public RemoteFile create(RemoteFile parent,LocalFile local){
  return create(local);
}","@Override public RemoteFile create(RemoteFile parent,LocalFile local){
  try {
    if (local.getName() == null)     throw new NullPointerException(""String_Node_Str"");
    InputStream input=getApiFactory().createInputStream(local.getFile());
    getDropboxApi().putFile(Path.combine(parent,local.getName()),input,local.getFile().length(),null,null);
    safeClose(input);
    return get(local.getName());
  }
 catch (  Exception e) {
    return null;
  }
}",0.2686025408348457
80355,"/** 
 * The name of this file
 */
public String getName();","/** 
 * The name of this file
 */
String getName();",0.9357798165137616
80356,"/** 
 * Fetch this file's complete metadata
 */
public boolean fetchDetails();","/** 
 * Fetch this file's complete metadata
 */
boolean fetchDetails();",0.953020134228188
80357,"/** 
 * Upload/Save a file to this file. The remote content file will be overwritten by the   {@code content}
 */
public boolean upload(LocalFile local);","/** 
 * Upload/Save a file to this file. The remote content file will be overwritten by the   {@code content}
 */
boolean upload(LocalFile local);",0.9765886287625418
80358,"/** 
 * Async for   {@link #upload(com.bingzer.android.driven.LocalFile)}
 */
public void uploadAsync(LocalFile local,Task<Boolean> task);","/** 
 * Async for   {@link #upload(com.bingzer.android.driven.LocalFile)}
 */
void uploadAsync(LocalFile local,Task<Boolean> task);",0.9739776951672864
80359,"/** 
 * The unique identifier.
 */
public String getId();","/** 
 * The unique identifier.
 */
String getId();",0.9345794392523364
80360,"/** 
 * Async for   {@link #delete()}
 */
public void deleteAsync(Task<Boolean> task);","/** 
 * Async for   {@link #delete()}
 */
void deleteAsync(Task<Boolean> task);",0.9575757575757576
80361,"/** 
 * Async for   {@link #download(LocalFile)}
 */
public void downloadAsync(LocalFile local,Task<Boolean> task);","/** 
 * Async for   {@link #download(LocalFile)}
 */
void downloadAsync(LocalFile local,Task<Boolean> task);",0.968609865470852
80362,"/** 
 * Async call for   {@link #rename(String)}
 */
public void renameAsync(String name,Task<Boolean> task);","/** 
 * Async call for   {@link #rename(String)}
 */
void renameAsync(String name,Task<Boolean> task);",0.966824644549763
80363,"/** 
 * Async for   {@link #get(String)}
 */
public void getAsync(String name,Task<RemoteFile> task);","/** 
 * Async for   {@link #get(String)}
 */
void getAsync(String name,Task<RemoteFile> task);",0.964102564102564
80364,"/** 
 * If this file is   {@link #isDirectory()} then thismethod should return all children within.
 */
public List<RemoteFile> list();","/** 
 * If this file is   {@link #isDirectory()} then thismethod should return all children within.
 */
List<RemoteFile> list();",0.973384030418251
80365,"/** 
 * Delete or removes this file from remote provider.
 */
public boolean delete();","/** 
 * Delete or removes this file from remote provider.
 */
boolean delete();",0.9575757575757576
80366,"/** 
 * Download and keep this file to the local. There should be no local-to-remote mapping.
 */
public boolean download(LocalFile local);","/** 
 * Download and keep this file to the local. There should be no local-to-remote mapping.
 */
boolean download(LocalFile local);",0.974169741697417
80367,"/** 
 * The public downloadable URL. Driven API should be able to use this URL to download this file on demand. It may or may not use authenticate scheme by the provider.
 */
public String getDownloadUrl();","/** 
 * The public downloadable URL. Driven API should be able to use this URL to download this file on demand. It may or may not use authenticate scheme by the provider.
 */
String getDownloadUrl();",0.982716049382716
80368,"/** 
 * True if this file has ""all"" the details (metadata) provided by the provider.
 */
public boolean hasDetails();","/** 
 * True if this file has ""all"" the details (metadata) provided by the provider.
 */
boolean hasDetails();",0.9691629955947136
80369,"/** 
 * The MIME type of this file
 */
public String getType();","/** 
 * The MIME type of this file
 */
String getType();",0.9411764705882352
80370,"/** 
 * Rename the name of this file. True if successful, false otherwise
 */
public boolean rename(String name);","/** 
 * Rename the name of this file. True if successful, false otherwise
 */
boolean rename(String name);",0.9680365296803652
80371,"/** 
 * If this file is   {@link #isDirectory()} then thismethod should return a single children the specified  {@code name}
 */
public RemoteFile get(String name);","/** 
 * If this file is   {@link #isDirectory()} then thismethod should return a single children the specified  {@code name}
 */
RemoteFile get(String name);",0.9781931464174456
80372,"/** 
 * Share this file to other user. ""Sharing"" is generic and you should refer to the Provider's documentation
 */
public String share(String user,int kind);","/** 
 * Share this file to other user. ""Sharing"" is generic and you should refer to the Provider's documentation
 */
String share(String user,int kind);",0.977491961414791
80373,"/** 
 * Async for   {@link #share(String,int)}
 */
public void shareAsync(String user,int kind,Task<String> task);","/** 
 * Async for   {@link #share(String,int)}
 */
void shareAsync(String user,int kind,Task<String> task);",0.9683257918552036
80374,"/** 
 * Async for   {@link #list()}
 */
public void listAsync(Task<List<RemoteFile>> task);","/** 
 * Async for   {@link #list()}
 */
void listAsync(Task<List<RemoteFile>> task);",0.96
80375,"/** 
 * True if this file is a directory
 */
public boolean isDirectory();","/** 
 * True if this file is a directory
 */
boolean isDirectory();",0.950354609929078
80376,"/** 
 * Async for   {@link #fetchDetails()}
 */
public void fetchDetailsAsync(Task<Boolean> task);","/** 
 * Async for   {@link #fetchDetails()}
 */
void fetchDetailsAsync(Task<Boolean> task);",0.9629629629629628
80377,"@Override protected void onResume(){
  super.onResume();
  try {
    if (driven.getDropboxApi().getSession().authenticationSuccessful()) {
      driven.getDropboxApi().getSession().finishAuthentication();
      credential.getToken().setAccessToken(driven.getDropboxApi().getSession().getOAuth2AccessToken());
      successfullyAuthenticated();
    }
 else {
      finish();
    }
  }
 catch (  DrivenException e) {
    authenticate();
  }
}","@Override protected void onResume(){
  super.onResume();
  try {
    if (driven.getDropboxApi().getSession().authenticationSuccessful()) {
      driven.getDropboxApi().getSession().finishAuthentication();
      credential.getToken().setAccessToken(driven.getDropboxApi().getSession().getOAuth2AccessToken());
      credential.save(driven.getName());
      successfullyAuthenticated();
    }
 else {
      finish();
    }
  }
 catch (  DrivenException e) {
    authenticate();
  }
}",0.9554831704668838
80378,"private void authenticate(){
  driven.authenticateAsync(credential,new Task<Result<DrivenException>>(){
    @Override public void onCompleted(    Result<DrivenException> result){
      if (!result.isSuccess()) {
        driven.getDropboxApi().getSession().startOAuth2Authentication(DropboxActivity.this);
      }
 else {
        successfullyAuthorized();
      }
    }
  }
);
}","private void authenticate(){
  driven.authenticateAsync(credential,new Task.WithErrorReporting<Result<DrivenException>>(){
    @Override public void onCompleted(    Result<DrivenException> result){
      if (!result.isSuccess()) {
        driven.getDropboxApi().getSession().startOAuth2Authentication(DropboxActivity.this);
      }
 else {
        successfullyAuthorized();
      }
    }
    @Override public void onError(    Throwable error){
      Log.e(driven.getName(),error.getMessage(),error);
      finish();
    }
  }
);
}",0.8313120176405733
80379,"@Override protected void onResume(){
  super.onResume();
  try {
    if (driven.getDropboxApi().getSession().authenticationSuccessful()) {
      driven.getDropboxApi().getSession().finishAuthentication();
      credential.getToken().setAccessToken(driven.getDropboxApi().getSession().getOAuth2AccessToken());
    }
  }
 catch (  DrivenException e) {
    authenticate();
  }
}","@Override protected void onResume(){
  super.onResume();
  try {
    if (driven.getDropboxApi().getSession().authenticationSuccessful()) {
      driven.getDropboxApi().getSession().finishAuthentication();
      credential.getToken().setAccessToken(driven.getDropboxApi().getSession().getOAuth2AccessToken());
    }
 else {
      finish();
    }
  }
 catch (  DrivenException e) {
    authenticate();
  }
}",0.9615384615384616
80380,"private void authenticate(){
  storageProvider.authenticateAsync(new Credential(this,googleAccount.getSelectedAccountName()),new Task<Result<DrivenException>>(){
    @Override public void onCompleted(    Result<DrivenException> result){
      if (result.isSuccess())       successfullyAuthenticated();
 else {
        if (result.getException().getCause() instanceof UserRecoverableAuthIOException) {
          UserRecoverableAuthIOException exception=(UserRecoverableAuthIOException)result.getException().getCause();
          startActivityForResult(exception.getIntent(),REQUEST_AUTHORIZATION);
        }
 else {
          throw result.getException();
        }
      }
    }
  }
);
}","private void authenticate(){
  Credential credential=new Credential(this,googleAccount.getSelectedAccountName());
  storageProvider.authenticateAsync(credential,new Task.WithErrorReporting<Result<DrivenException>>(){
    @Override public void onCompleted(    Result<DrivenException> result){
      if (result.isSuccess())       successfullyAuthenticated();
 else {
        if (result.getException().getCause() instanceof UserRecoverableAuthIOException) {
          UserRecoverableAuthIOException exception=(UserRecoverableAuthIOException)result.getException().getCause();
          startActivityForResult(exception.getIntent(),REQUEST_AUTHORIZATION);
        }
 else {
          onError(result.getException());
        }
      }
    }
    @Override public void onError(    Throwable error){
      Log.e(storageProvider.getName(),error.getMessage(),error);
      finish();
    }
  }
);
}",0.7460216422660726
80381,"@Override public void onCompleted(Result<DrivenException> result){
  if (result.isSuccess())   successfullyAuthenticated();
 else {
    if (result.getException().getCause() instanceof UserRecoverableAuthIOException) {
      UserRecoverableAuthIOException exception=(UserRecoverableAuthIOException)result.getException().getCause();
      startActivityForResult(exception.getIntent(),REQUEST_AUTHORIZATION);
    }
 else {
      throw result.getException();
    }
  }
}","@Override public void onCompleted(Result<DrivenException> result){
  if (result.isSuccess())   successfullyAuthenticated();
 else {
    if (result.getException().getCause() instanceof UserRecoverableAuthIOException) {
      UserRecoverableAuthIOException exception=(UserRecoverableAuthIOException)result.getException().getCause();
      startActivityForResult(exception.getIntent(),REQUEST_AUTHORIZATION);
    }
 else {
      onError(result.getException());
    }
  }
}",0.9411764705882352
80382,"@Override public Result<DrivenException> authenticate(GoogleAccountCredential credential,boolean saveCredential){
  Log.i(TAG,""String_Node_Str"");
  ResultImpl<DrivenException> result=new ResultImpl<DrivenException>();
  try {
    if (credential == null)     throw new DrivenException(new IllegalArgumentException(""String_Node_Str""));
    String accountName=readSavedCredentials(credential.getContext());
    if (credential.getSelectedAccountName() == null && accountName != null) {
      credential.setSelectedAccountName(accountName);
    }
    driveService=DriveUtils.createGoogleDriveService(credential);
    driveUser=new DriveUser(driveService.about().get().setFields(""String_Node_Str"").execute());
    result.setSuccess(true);
    Log.i(TAG,""String_Node_Str"" + driveUser);
    if (saveCredential)     saveCredentials(credential);
  }
 catch (  IOException e) {
    Log.i(TAG,""String_Node_Str"" + credential.getSelectedAccountName());
    result.setException(new DrivenException(e));
  }
  return result;
}","@Override public Result<DrivenException> authenticate(GoogleAccountCredential credential,boolean saveCredential){
  Log.i(TAG,""String_Node_Str"");
  ResultImpl<DrivenException> result=new ResultImpl<DrivenException>();
  try {
    if (credential == null)     throw new DrivenException(new IllegalArgumentException(""String_Node_Str""));
    String accountName=readSavedCredentials(credential.getContext());
    if (credential.getSelectedAccountName() == null && accountName != null) {
      credential.setSelectedAccountName(accountName);
    }
    driveService=DriveUtils.createGoogleDriveService(credential);
    driveUser=new DriveUser(driveService.about().get().setFields(""String_Node_Str"").execute());
    result.setSuccess(true);
    Log.i(TAG,""String_Node_Str"" + driveUser);
    if (saveCredential && credential.getSelectedAccountName() != null)     saveCredentials(credential);
  }
 catch (  IOException e) {
    Log.i(TAG,""String_Node_Str"" + credential.getSelectedAccountName());
    result.setException(new DrivenException(e));
  }
  return result;
}",0.9772617319787132
80383,"/** 
 * @return a byte array with the vector tile
 */
public byte[] encode(){
  VectorTile.Tile.Builder tileBuilder=VectorTile.Tile.newBuilder();
  for (  Map.Entry<String,Layer> e : layers.entrySet()) {
    String layerName=e.getKey();
    Layer layer=e.getValue();
    VectorTile.Tile.Layer.Builder layerBuilder=VectorTile.Tile.Layer.newBuilder();
    layerBuilder.setVersion(1);
    layerBuilder.setName(layerName);
    layerBuilder.addAllKeys(layer.keys());
    VectorTile.Tile.Value.Builder valueBuilder=VectorTile.Tile.Value.newBuilder();
    for (    Object value : layer.values()) {
      if (value instanceof String) {
        valueBuilder.setStringValue((String)value);
      }
 else       if (value instanceof Integer) {
        valueBuilder.setIntValue(((Integer)value).intValue());
      }
 else       if (value instanceof Float) {
        valueBuilder.setFloatValue(((Float)value).floatValue());
      }
 else       if (value instanceof Double) {
        valueBuilder.setDoubleValue(((Double)value).doubleValue());
      }
 else {
        valueBuilder.setStringValue(value.toString());
      }
      layerBuilder.addValues(valueBuilder.build());
    }
    layerBuilder.setExtent(extent);
    for (    Feature feature : layer.features) {
      Geometry geometry=feature.geometry;
      VectorTile.Tile.Feature.Builder featureBuilder=VectorTile.Tile.Feature.newBuilder();
      featureBuilder.addAllTags(feature.tags);
      featureBuilder.setType(toGeomType(geometry));
      featureBuilder.addAllGeometry(commands(geometry));
      layerBuilder.addFeatures(featureBuilder.build());
    }
    tileBuilder.addLayers(layerBuilder.build());
  }
  return tileBuilder.build().toByteArray();
}","/** 
 * @return a byte array with the vector tile
 */
public byte[] encode(){
  VectorTile.Tile.Builder tileBuilder=VectorTile.Tile.newBuilder();
  for (  Map.Entry<String,Layer> e : layers.entrySet()) {
    String layerName=e.getKey();
    Layer layer=e.getValue();
    VectorTile.Tile.Layer.Builder layerBuilder=VectorTile.Tile.Layer.newBuilder();
    layerBuilder.setVersion(1);
    layerBuilder.setName(layerName);
    layerBuilder.addAllKeys(layer.keys());
    for (    Object value : layer.values()) {
      VectorTile.Tile.Value.Builder valueBuilder=VectorTile.Tile.Value.newBuilder();
      if (value instanceof String) {
        valueBuilder.setStringValue((String)value);
      }
 else       if (value instanceof Integer) {
        valueBuilder.setSintValue(((Integer)value).intValue());
      }
 else       if (value instanceof Long) {
        valueBuilder.setSintValue(((Long)value).longValue());
      }
 else       if (value instanceof Float) {
        valueBuilder.setFloatValue(((Float)value).floatValue());
      }
 else       if (value instanceof Double) {
        valueBuilder.setDoubleValue(((Double)value).doubleValue());
      }
 else {
        valueBuilder.setStringValue(value.toString());
      }
      layerBuilder.addValues(valueBuilder.build());
    }
    layerBuilder.setExtent(extent);
    for (    Feature feature : layer.features) {
      Geometry geometry=feature.geometry;
      VectorTile.Tile.Feature.Builder featureBuilder=VectorTile.Tile.Feature.newBuilder();
      featureBuilder.addAllTags(feature.tags);
      featureBuilder.setType(toGeomType(geometry));
      featureBuilder.addAllGeometry(commands(geometry));
      layerBuilder.addFeatures(featureBuilder.build());
    }
    tileBuilder.addLayers(layerBuilder.build());
  }
  return tileBuilder.build().toByteArray();
}",0.896414342629482
80384,"protected Rect growDown(final int w,final int h){
  final Node down=new Node(mRoot.x,mRoot.y + mRoot.height,mRoot.width,h);
  final Node right=mRoot;
  mRoot=new Node(mRoot.x,mRoot.y,mRoot.width,mRoot.height + h);
  mRoot.mRight=right;
  mRoot.mDown=down;
  return down.occupy(w,h);
}","protected Rect growDown(final int w,final int h){
  final Node down=new Node(mRoot.x,mRoot.y + mRoot.height,mRoot.width,h);
  final Node right=mRoot;
  mRoot=new Node(mRoot.x,mRoot.y,mRoot.width,mRoot.height + h);
  mRoot.split(down,right);
  return down.occupy(w,h);
}",0.9113924050632912
80385,"protected Rect growRight(final int w,final int h){
  final Node down=mRoot;
  final Node right=new Node(mRoot.x + mRoot.width,mRoot.y,w,mRoot.height);
  mRoot=new Node(mRoot.x,mRoot.y,mRoot.width + w,mRoot.height);
  mRoot.mRight=right;
  mRoot.mDown=down;
  return right.occupy(w,h);
}","protected Rect growRight(final int w,final int h){
  final Node down=mRoot;
  final Node right=new Node(mRoot.x + mRoot.width,mRoot.y,w,mRoot.height);
  mRoot=new Node(mRoot.x,mRoot.y,mRoot.width + w,mRoot.height);
  mRoot.split(down,right);
  return right.occupy(w,h);
}",0.9120287253141832
80386,"public Rect occupy(final int w,final int h){
  final Rect rect=new Rect(x,y,x + w,y + h);
  if (height > h) {
    mDown=new Node(x,y + h,width,height - h);
  }
  if (width > w) {
    mRight=new Node(x + w,y,width - w,h);
  }
  return rect;
}","public Rect occupy(final int w,final int h){
  if (mOccupied)   return null;
  final Rect rect=new Rect(x,y,x + w,y + h);
  mOccupied=true;
  if (height > h) {
    mDown=new Node(x,y + h,width,height - h);
  }
  if (width > w) {
    mRight=new Node(x + w,y,width - w,h);
  }
  return rect;
}",0.9060150375939848
80387,"public void reset(){
  mDown=mRight=null;
}","public void reset(){
  mDown=mRight=null;
  mOccupied=false;
}",0.819047619047619
80388,"public Node findNode(final int w,final int h){
  if (hasChildren()) {
    if (mRight != null) {
      final Node node=mRight.findNode(w,h);
      if (node != null) {
        return node;
      }
    }
    if (mDown != null) {
      final Node node=mDown.findNode(w,h);
      if (node != null) {
        return node;
      }
    }
  }
 else   if (w <= width && h <= height) {
    return this;
  }
  return null;
}","public Node findNode(final int w,final int h){
  if (mOccupied) {
    if (mRight != null) {
      final Node node=mRight.findNode(w,h);
      if (node != null) {
        return node;
      }
    }
    if (mDown != null) {
      final Node node=mDown.findNode(w,h);
      if (node != null) {
        return node;
      }
    }
  }
 else   if (w <= width && h <= height) {
    return this;
  }
  return null;
}",0.973170731707317
80389,"private void findStartIndex(){
  mStartX=mStartIndex=0;
  if (mContentSize.x <= 0) {
    return;
  }
  int offset=Math.round(mScrollPosition.x % mContentSize.x);
  offset+=(offset < 0) ? mContentSize.x : 0;
  if (offset == 0) {
    return;
  }
  float itemPos=0;
  for (int i=0; i < mNumChildren; i++) {
    if (offset <= itemPos) {
      mStartIndex=i;
      mStartX=itemPos - offset;
      return;
    }
    if (i == mNumChildren - 1) {
      mStartX=mContentSize.x - offset;
    }
 else {
      itemPos+=Math.max(mMinCellSize,mChildren.get(i).getSize().x) + mGap;
    }
  }
}","private void findStartIndex(){
  mStartX=mStartIndex=0;
  if (mContentSize.x <= 0) {
    return;
  }
  float offset=mScrollPosition.x % mContentSize.x;
  offset+=(offset < 0) ? mContentSize.x : 0;
  if (offset == 0) {
    return;
  }
  float itemPos=0;
  for (int i=0; i < mNumChildren; i++) {
    if (offset <= itemPos) {
      mStartIndex=i;
      mStartX=itemPos - offset;
      return;
    }
    if (i == mNumChildren - 1) {
      mStartX=mContentSize.x - offset;
    }
 else {
      itemPos+=Math.max(mMinCellSize,mChildren.get(i).getSize().x) + mGap;
    }
  }
}",0.9685863874345548
80390,"private void findStartIndex(){
  mStartY=mStartIndex=0;
  if (mContentSize.y <= 0) {
    return;
  }
  int offset=Math.round(mScrollPosition.y % mContentSize.y);
  offset+=(offset < 0) ? mContentSize.y : 0;
  if (offset == 0) {
    return;
  }
  float itemPos=0;
  for (int i=0; i < mNumChildren; i++) {
    if (offset <= itemPos) {
      mStartIndex=i;
      mStartY=itemPos - offset;
      return;
    }
    if (i == mNumChildren - 1) {
      mStartY=mContentSize.y - offset;
    }
 else {
      itemPos+=getChildHeight(mChildren.get(i)) + mGap;
    }
  }
}","private void findStartIndex(){
  mStartY=mStartIndex=0;
  if (mContentSize.y <= 0) {
    return;
  }
  float offset=mScrollPosition.y % mContentSize.y;
  offset+=(offset < 0) ? mContentSize.y : 0;
  if (offset == 0) {
    return;
  }
  float itemPos=0;
  for (int i=0; i < mNumChildren; i++) {
    if (offset <= itemPos) {
      mStartIndex=i;
      mStartY=itemPos - offset;
      return;
    }
    if (i == mNumChildren - 1) {
      mStartY=mContentSize.y - offset;
    }
 else {
      itemPos+=getChildHeight(mChildren.get(i)) + mGap;
    }
  }
}",0.967509025270758
80391,"@Override public void onPrepared(final MediaPlayer mp){
  if (mMediaEnabled) {
    mMediaPrepared=true;
    mp.start();
  }
}","@Override public void onPrepared(final MediaPlayer mp){
  mMediaPrepared=true;
  if (mMediaEnabled) {
    mp.start();
  }
}",0.8064516129032258
80392,"@Override public void setXMLAttributes(final XmlPullParser xmlParser,final UIManager manager){
  super.setXMLAttributes(xmlParser,manager);
  final String align=xmlParser.getAttributeValue(null,ATT_ALIGN);
  if (align != null) {
    setAlignment(UIConfig.getAlignment(align));
  }
  final String repeating=xmlParser.getAttributeValue(null,ATT_REPEATING);
  if (repeating != null) {
    setRepeating(Boolean.valueOf(repeating));
  }
  final String boundsCheck=xmlParser.getAttributeValue(null,ATT_BOUNDS_CHECK_ENABLED);
  if (boundsCheck != null) {
    setBoundsCheckEnabled(Boolean.valueOf(boundsCheck));
  }
  final String autoSleepChildren=xmlParser.getAttributeValue(null,ATT_AUTO_SLEEP_CHILDREN);
  if (autoSleepChildren != null) {
    setAutoSleepChildren(Boolean.valueOf(autoSleepChildren));
  }
  final String minCellSize=xmlParser.getAttributeValue(null,ATT_MIN_CELL_SIZE);
  if (ATT_MIN_CELL_SIZE != null) {
    setMinCellSize(Float.valueOf(minCellSize) * manager.getConfig().screen_scale);
  }
}","@Override public void setXMLAttributes(final XmlPullParser xmlParser,final UIManager manager){
  super.setXMLAttributes(xmlParser,manager);
  final String align=xmlParser.getAttributeValue(null,ATT_ALIGN);
  if (align != null) {
    setAlignment(UIConfig.getAlignment(align));
  }
  final String repeating=xmlParser.getAttributeValue(null,ATT_REPEATING);
  if (repeating != null) {
    setRepeating(Boolean.valueOf(repeating));
  }
  final String boundsCheck=xmlParser.getAttributeValue(null,ATT_BOUNDS_CHECK_ENABLED);
  if (boundsCheck != null) {
    setBoundsCheckEnabled(Boolean.valueOf(boundsCheck));
  }
  final String autoSleepChildren=xmlParser.getAttributeValue(null,ATT_AUTO_SLEEP_CHILDREN);
  if (autoSleepChildren != null) {
    setAutoSleepChildren(Boolean.valueOf(autoSleepChildren));
  }
  final String minCellSize=xmlParser.getAttributeValue(null,ATT_MIN_CELL_SIZE);
  if (minCellSize != null) {
    setMinCellSize(Float.valueOf(minCellSize) * manager.getConfig().screen_scale);
  }
}",0.9860279441117764
80393,"@Override protected void updateChildren(final int deltaTime){
  super.updateChildren(deltaTime);
  final boolean forceChildrenConstraints=((mInvalidateFlags & (SIZE | PARENT)) != 0);
  int numDrawingChildren=0;
  Uniable child;
  float temp, sx=mSize.x, sy=mSize.y;
  for (int i=0; i < mNumChildren; i++) {
    child=mChildren.get(i);
    if (forceChildrenConstraints) {
      child.invalidate(PARENT);
    }
    if (child.isAlive()) {
      child.update(deltaTime);
    }
    if (child.shouldDraw() && child.checkCameraClipping(mScene != null ? mScene.getCamera() : null)) {
      if (child instanceof UniContainer) {
        numDrawingChildren+=((UniContainer)child).getNumDrawingChildren();
      }
 else {
        numDrawingChildren++;
      }
    }
    if (mWrapContentWidth) {
      temp=child.getX() + child.getWidth();
      if (temp > sx) {
        sx=temp;
      }
    }
    if (mWrapContentHeight) {
      temp=child.getY() + child.getHeight();
      if (temp > sy) {
        sy=temp;
      }
    }
  }
  setNumDrawingChildren(numDrawingChildren);
  if (sx != mSize.x || sy != mSize.y) {
    setSize(sx,sy);
  }
}","@Override protected void updateChildren(final int deltaTime){
  super.updateChildren(deltaTime);
  final int flags;
  if (mAutoUpdateBounds && (mInvalidateFlags & BOUNDS) != 0) {
    updateBounds();
  }
  final boolean forceChildrenConstraints=((mInvalidateFlags & (SIZE | PARENT)) != 0);
  int numDrawingChildren=0;
  Uniable child;
  float temp, sx=mSize.x, sy=mSize.y;
  for (int i=0; i < mNumChildren; i++) {
    child=mChildren.get(i);
    if (forceChildrenConstraints) {
      child.invalidate(PARENT);
    }
    if (child.isAlive()) {
      child.update(deltaTime);
    }
    if (child.shouldDraw() && child.checkCameraClipping(mScene != null ? mScene.getCamera() : null)) {
      if (child instanceof UniContainer) {
        numDrawingChildren+=((UniContainer)child).getNumDrawingChildren();
      }
 else {
        numDrawingChildren++;
      }
    }
    if (mWrapContentWidth) {
      temp=child.getX() + child.getWidth();
      if (temp > sx) {
        sx=temp;
      }
    }
    if (mWrapContentHeight) {
      temp=child.getY() + child.getHeight();
      if (temp > sy) {
        sy=temp;
      }
    }
  }
  validate(BOUNDS);
  setNumDrawingChildren(numDrawingChildren);
  if (sx != mSize.x || sy != mSize.y) {
    setSize(sx,sy);
  }
}",0.9469250210614996
80394,"public boolean update(final int deltaTime){
  if (mNumManipulators > 0) {
    for (int i=0; i < mNumManipulators; i++) {
      mManipulators.get(i).update(deltaTime);
    }
  }
  if ((mInvalidateFlags & BOUNDS) != 0) {
    updateVertices();
    if (mAutoUpdateBounds) {
      updateBounds();
    }
  }
  mInvalidateFlags&=~(BOUNDS);
  return mNumManipulators > 0;
}","public boolean update(final int deltaTime){
  if (mNumManipulators > 0) {
    for (int i=0; i < mNumManipulators; i++) {
      mManipulators.get(i).update(deltaTime);
    }
  }
  if ((mInvalidateFlags & BOUNDS) != 0 || (mParent != null && (((AbstractUniGroup)mParent).mInvalidateFlags & BOUNDS) != 0)) {
    updateVertices();
    if (mAutoUpdateBounds) {
      updateBounds();
    }
  }
  mInvalidateFlags&=~(BOUNDS);
  return mNumManipulators > 0;
}",0.8957055214723927
80395,"public void setAtlasFrame(final AtlasFrame frame){
  if (frame != null) {
    setTextureCoords(frame.getTextureCoords());
    if (frame.mOffset != null) {
      setOrigin(mOrigin.x - (frame.mOffset.x - mOffsetX),mOrigin.y - (frame.mOffset.y - mOffsetY));
      mOffsetX=frame.mOffset.x;
      mOffsetY=frame.mOffset.y;
    }
 else     if (mOffsetX != 0 || mOffsetY != 0) {
      setOrigin(mOrigin.x + mOffsetX,mOrigin.y + mOffsetY);
      mOffsetX=mOffsetY=0;
    }
    final PointF newSize=frame.getSize();
    if (mSizeToFrame && (newSize.x != mSize.x || newSize.y != mSize.y)) {
      setSize(newSize.x,newSize.y);
    }
 else {
      invalidate(FRAME);
    }
  }
 else {
    TextureCoordBuffer.getDefault(mTextureCoords);
    if (mOffsetX != 0 || mOffsetY != 0) {
      setOrigin(mOrigin.x + mOffsetX,mOrigin.y + mOffsetY);
      mOffsetX=mOffsetY=0;
    }
    invalidate(FRAME);
  }
  mAtlasFrame=frame;
}","public void setAtlasFrame(final AtlasFrame frame){
  if (frame != null) {
    setTextureCoords(frame.getTextureCoords());
    if (frame.mOffset != null) {
      setOrigin(mOrigin.x - (frame.mOffset.x - mOffsetX),mOrigin.y - (frame.mOffset.y - mOffsetY));
      mOffsetX=frame.mOffset.x;
      mOffsetY=frame.mOffset.y;
    }
 else     if (mOffsetX != 0 || mOffsetY != 0) {
      setOrigin(mOrigin.x + mOffsetX,mOrigin.y + mOffsetY);
      mOffsetX=mOffsetY=0;
    }
    final PointF newSize=frame.getSize();
    if (mSizeToFrame && (newSize.x != mSize.x || newSize.y != mSize.y)) {
      setSize(newSize.x,newSize.y);
    }
    invalidate(FRAME);
  }
 else {
    TextureCoordBuffer.getDefault(mTextureCoords);
    if (mOffsetX != 0 || mOffsetY != 0) {
      setOrigin(mOrigin.x + mOffsetX,mOrigin.y + mOffsetY);
      mOffsetX=mOffsetY=0;
    }
    invalidate(FRAME);
  }
  mAtlasFrame=frame;
}",0.991130820399113
80396,"@Override public void onAdded(final Container container){
  super.onAdded(container);
  if (container instanceof DisplayObject) {
    mScene=((DisplayObject)container).getScene();
  }
 else   if (container instanceof AbstractUniGroup) {
    mScene=((AbstractUniGroup)container).getScene();
    setTexture(((AbstractUniGroup)container).getTexture());
  }
}","public void onAdded(final UniContainer container){
  if (container instanceof BaseDisplayObject) {
    mScene=((BaseDisplayObject)container).getScene();
  }
 else {
    mScene=container.getScene();
  }
  setTexture(container.getTexture());
}",0.7046979865771812
80397,"@Override public void onSurfaceCreated(final GL10 gl,final EGLConfig config){
  Log.v(TAG,""String_Node_Str"");
  if (Pure2D.GL_MAX_TEXTURE_SIZE == 0) {
    Pure2D.initGLProperties(gl);
  }
  gl.glClearColor(mColor.r,mColor.g,mColor.b,mColor.a);
  gl.glShadeModel(GL10.GL_SMOOTH);
  gl.glClearDepthf(1.0f);
  gl.glEnable(GL10.GL_DEPTH_TEST);
  gl.glDepthFunc(GL10.GL_LEQUAL);
  gl.glAlphaFunc(GL10.GL_GREATER,0f);
  gl.glHint(GL10.GL_PERSPECTIVE_CORRECTION_HINT,GL10.GL_NICEST);
  gl.glEnable(GL10.GL_BLEND);
  gl.glFrontFace(GL10.GL_CCW);
  gl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT);
  boolean firstTime;
  if (mGLState == null) {
    mGLState=new GLState(gl,mStage);
    mGLState.setDefaultBlendFunc(mDefaultBlendFunc);
    mGLState.setCamera(mCamera);
    mTextureManager=createDefaultTextureManager();
    mGLState.setTextureManager(mTextureManager);
    mStartTime=SystemClock.elapsedRealtime();
    mDownTime=0;
    mFrameCount=0;
    mCurrentFps=0;
    mFrameCountDuration=0;
    firstTime=true;
  }
 else {
    mGLState.reset(gl);
    mTextureManager.reload(mGLState,mStage.getResources());
    onSurfaceChanged(gl,(int)mSize.x,(int)mSize.y);
    firstTime=false;
  }
  if (mListener != null) {
    mListener.onSurfaceCreated(mGLState,firstTime);
  }
}","@Override public void onSurfaceCreated(final GL10 gl,final EGLConfig config){
  Log.v(TAG,""String_Node_Str"");
  if (Pure2D.GL_MAX_TEXTURE_SIZE == 0) {
    Pure2D.initGLProperties(gl);
  }
  gl.glClearColor(mColor.r,mColor.g,mColor.b,mColor.a);
  gl.glShadeModel(GL10.GL_SMOOTH);
  gl.glClearDepthf(1.0f);
  gl.glEnable(GL10.GL_DEPTH_TEST);
  gl.glDepthFunc(GL10.GL_LEQUAL);
  gl.glAlphaFunc(GL10.GL_GREATER,0f);
  gl.glHint(GL10.GL_PERSPECTIVE_CORRECTION_HINT,GL10.GL_NICEST);
  gl.glEnable(GL10.GL_BLEND);
  gl.glFrontFace(GL10.GL_CCW);
  gl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT);
  boolean firstTime;
  if (mGLState == null) {
    mGLState=new GLState(gl,mStage);
    mGLState.setDefaultBlendFunc(mDefaultBlendFunc);
    mGLState.setCamera(mCamera);
    mTextureManager=createDefaultTextureManager();
    mGLState.setTextureManager(mTextureManager);
    mStartTime=SystemClock.elapsedRealtime();
    mDownTime=0;
    mFrameCount=0;
    mCurrentFps=0;
    mFrameCountDuration=0;
    firstTime=true;
  }
 else {
    mGLState.reset(gl);
    final long idleTime=SystemClock.elapsedRealtime() - mStartTime;
    mTextureManager.update((int)idleTime);
    mTextureManager.reload(mGLState,mStage.getResources());
    onSurfaceChanged(gl,(int)mSize.x,(int)mSize.y);
    firstTime=false;
  }
  if (mListener != null) {
    mListener.onSurfaceCreated(mGLState,firstTime);
  }
}",0.958442530887308
80398,"/** 
 * @hide For internal use only. Do NOT call!
 * @param deltaTime
 */
public void update(final int deltaTime){
  if (mExpirationCheckInterval > 0) {
    mExpirationCheckElapsedTime+=deltaTime;
    if (mExpirationCheckElapsedTime >= mExpirationCheckInterval) {
      final int len=mTextures.size();
      for (int i=0; i < len; i++) {
        mTextures.get(i).update(mExpirationCheckElapsedTime);
      }
      mExpirationCheckElapsedTime-=mExpirationCheckInterval;
    }
  }
}","/** 
 * @hide For internal use only. Do NOT call!
 * @param deltaTime
 */
public void update(final int deltaTime){
  if (mExpirationCheckInterval > 0) {
    mExpirationCheckElapsedTime+=deltaTime;
    if (mExpirationCheckElapsedTime >= mExpirationCheckInterval) {
      final int len=mTextures.size();
      for (int i=0; i < len; i++) {
        mTextures.get(i).update(mExpirationCheckElapsedTime);
      }
      mExpirationCheckElapsedTime=0;
    }
  }
}",0.9722222222222222
80399,"@Override public boolean update(final int deltaTime){
  if (mUIConstraint != null) {
    if ((mInvalidateFlags & (SIZE | PARENT)) != 0) {
      mUIConstraint.apply(this,mParent);
    }
  }
  if (mNumManipulators > 0) {
    for (int i=0; i < mNumManipulators; i++) {
      mManipulators.get(i).update(deltaTime);
    }
  }
  if ((mInvalidateFlags & TRANSFORM_MATRIX) != 0) {
    if (mTransformMatrix == null) {
      mTransformMatrix=new Matrix();
    }
 else {
      mTransformMatrix.reset();
    }
    if (mSkew != null) {
      mTransformMatrix.setSkew(mSkew.x,mSkew.y);
    }
    mHasTransformValues=!mTransformMatrix.isIdentity();
    if (mHasTransformValues) {
      if (mTransformMatrixValues == null) {
        mTransformMatrixValues=new float[16];
      }
      Pure2DUtils.getMatrix3DValues(mTransformMatrix,mTransformMatrixValues);
    }
  }
  if (mAutoUpdateBounds && (mInvalidateFlags & BOUNDS) != 0) {
    updateBounds();
  }
  updateChildren(deltaTime);
  mInvalidateFlags&=~(BOUNDS | TRANSFORM_MATRIX);
  return mNumManipulators > 0;
}","@Override public boolean update(final int deltaTime){
  if (mUIConstraint != null) {
    if ((mInvalidateFlags & (SIZE | PARENT)) != 0) {
      mUIConstraint.apply(this,mParent);
    }
  }
  if (mNumManipulators > 0) {
    for (int i=0; i < mNumManipulators; i++) {
      mManipulators.get(i).update(deltaTime);
    }
  }
  if ((mInvalidateFlags & TRANSFORM_MATRIX) != 0) {
    if (mTransformMatrix == null) {
      mTransformMatrix=new Matrix();
    }
 else {
      mTransformMatrix.reset();
    }
    if (mSkew != null) {
      mTransformMatrix.setSkew(mSkew.x,mSkew.y);
    }
    mHasTransformValues=!mTransformMatrix.isIdentity();
    if (mHasTransformValues) {
      if (mTransformMatrixValues == null) {
        mTransformMatrixValues=new float[16];
      }
      Pure2DUtils.getMatrix3DValues(mTransformMatrix,mTransformMatrixValues);
    }
  }
  updateChildren(deltaTime);
  if (mAutoUpdateBounds && (mInvalidateFlags & BOUNDS) != 0) {
    updateBounds();
  }
  mInvalidateFlags&=~(BOUNDS | TRANSFORM_MATRIX);
  return mNumManipulators > 0;
}",0.9723809523809523
80400,"protected AtlasFrame parseFrame(final int index,final JSONObject frameJson,final float scale) throws JSONException {
  final JSONObject frame=frameJson.getJSONObject(""String_Node_Str"");
  final boolean trimmed=frameJson.getBoolean(""String_Node_Str"");
  final boolean rotated=frameJson.getBoolean(""String_Node_Str"");
  final int left=frame.getInt(""String_Node_Str"");
  final int top=frame.getInt(""String_Node_Str"");
  final int w=frame.getInt(""String_Node_Str"");
  final int h=frame.getInt(""String_Node_Str"");
  final int right=left + (rotated ? h : w) - 1;
  final int bottom=top + (rotated ? w : h) - 1;
  final AtlasFrame atlasFrame=new AtlasFrame(this,index,frameJson.getString(""String_Node_Str""),new RectF(left * scale,top * scale,right * scale,bottom * scale));
  if (trimmed) {
    final JSONObject spriteSourceSize=frameJson.getJSONObject(""String_Node_Str"");
    final int offsetX=spriteSourceSize.getInt(""String_Node_Str"");
    int offsetY=spriteSourceSize.getInt(""String_Node_Str"");
    if (mAxisSystem == Scene.AXIS_BOTTOM_LEFT) {
      final JSONObject sourceSize=frameJson.getJSONObject(""String_Node_Str"");
      offsetY=sourceSize.getInt(""String_Node_Str"") - (spriteSourceSize.getInt(""String_Node_Str"") + spriteSourceSize.getInt(""String_Node_Str""));
    }
    if (offsetX != 0 || offsetY != 0) {
      atlasFrame.mOffset=new PointF(offsetX * scale,offsetY * scale);
    }
  }
  if (rotated) {
    atlasFrame.rotateCCW();
  }
  return atlasFrame;
}","protected AtlasFrame parseFrame(final int index,final JSONObject frameJson,final float scale) throws JSONException {
  final JSONObject frame=frameJson.getJSONObject(""String_Node_Str"");
  final boolean trimmed=frameJson.getBoolean(""String_Node_Str"");
  final boolean rotated=frameJson.getBoolean(""String_Node_Str"");
  final int left=frame.getInt(""String_Node_Str"");
  final int top=frame.getInt(""String_Node_Str"");
  final int w=frame.getInt(""String_Node_Str"");
  final int h=frame.getInt(""String_Node_Str"");
  final int right=left + (rotated ? h : w);
  final int bottom=top + (rotated ? w : h);
  final AtlasFrame atlasFrame=new AtlasFrame(this,index,frameJson.getString(""String_Node_Str""),new RectF(left * scale,top * scale,right * scale,bottom * scale));
  if (trimmed) {
    final JSONObject spriteSourceSize=frameJson.getJSONObject(""String_Node_Str"");
    final int offsetX=spriteSourceSize.getInt(""String_Node_Str"");
    int offsetY=spriteSourceSize.getInt(""String_Node_Str"");
    if (mAxisSystem == Scene.AXIS_BOTTOM_LEFT) {
      final JSONObject sourceSize=frameJson.getJSONObject(""String_Node_Str"");
      offsetY=sourceSize.getInt(""String_Node_Str"") - (spriteSourceSize.getInt(""String_Node_Str"") + spriteSourceSize.getInt(""String_Node_Str""));
    }
    if (offsetX != 0 || offsetY != 0) {
      atlasFrame.mOffset=new PointF(offsetX * scale,offsetY * scale);
    }
  }
  if (rotated) {
    atlasFrame.rotateCCW();
  }
  return atlasFrame;
}",0.9972527472527472
80401,"protected AtlasFrame parseFrame(final int index,final JSONObject frameJson,final float scale) throws JSONException {
  final JSONObject frame=frameJson.getJSONObject(""String_Node_Str"");
  final boolean trimmed=frameJson.getBoolean(""String_Node_Str"");
  final boolean rotated=frameJson.getBoolean(""String_Node_Str"");
  final int left=frame.getInt(""String_Node_Str"");
  final int top=frame.getInt(""String_Node_Str"");
  final int w=frame.getInt(""String_Node_Str"");
  final int h=frame.getInt(""String_Node_Str"");
  final int right=left + (rotated ? h : w) - 1;
  final int bottom=top + (rotated ? w : h) - 1;
  final AtlasFrame atlasFrame=new AtlasFrame(this,index,frameJson.getString(""String_Node_Str""),new RectF(left * scale,top * scale,right * scale,bottom * scale));
  if (trimmed) {
    final JSONObject spriteSourceSize=frameJson.getJSONObject(""String_Node_Str"");
    final int offsetX=spriteSourceSize.getInt(""String_Node_Str"");
    int offsetY=spriteSourceSize.getInt(""String_Node_Str"");
    if (mAxisSystem == Scene.AXIS_BOTTOM_LEFT) {
      final JSONObject sourceSize=frameJson.getJSONObject(""String_Node_Str"");
      offsetY=sourceSize.getInt(""String_Node_Str"") - (spriteSourceSize.getInt(""String_Node_Str"") + spriteSourceSize.getInt(""String_Node_Str""));
    }
    if (offsetX != 0 || offsetY != 0) {
      atlasFrame.mOffset=new PointF(offsetX * scale,offsetY * scale);
    }
  }
  if (rotated) {
    atlasFrame.rotateCCW();
  }
  return atlasFrame;
}","protected AtlasFrame parseFrame(final int index,final JSONObject frameJson,final float scale) throws JSONException {
  final JSONObject frame=frameJson.getJSONObject(""String_Node_Str"");
  final boolean trimmed=frameJson.getBoolean(""String_Node_Str"");
  final boolean rotated=frameJson.getBoolean(""String_Node_Str"");
  final int left=frame.getInt(""String_Node_Str"");
  final int top=frame.getInt(""String_Node_Str"");
  final int w=frame.getInt(""String_Node_Str"");
  final int h=frame.getInt(""String_Node_Str"");
  final int right=left + (rotated ? h : w);
  final int bottom=top + (rotated ? w : h);
  final AtlasFrame atlasFrame=new AtlasFrame(this,index,frameJson.getString(""String_Node_Str""),new RectF(left * scale,top * scale,right * scale,bottom * scale));
  if (trimmed) {
    final JSONObject spriteSourceSize=frameJson.getJSONObject(""String_Node_Str"");
    final int offsetX=spriteSourceSize.getInt(""String_Node_Str"");
    int offsetY=spriteSourceSize.getInt(""String_Node_Str"");
    if (mAxisSystem == Scene.AXIS_BOTTOM_LEFT) {
      final JSONObject sourceSize=frameJson.getJSONObject(""String_Node_Str"");
      offsetY=sourceSize.getInt(""String_Node_Str"") - (spriteSourceSize.getInt(""String_Node_Str"") + spriteSourceSize.getInt(""String_Node_Str""));
    }
    if (offsetX != 0 || offsetY != 0) {
      atlasFrame.mOffset=new PointF(offsetX * scale,offsetY * scale);
    }
  }
  if (rotated) {
    atlasFrame.rotateCCW();
  }
  return atlasFrame;
}",0.9972527472527472
80402,"private void init(final LWFManager lwfManager,InputStream stream) throws Exception {
  mManager=lwfManager;
  byte[] header=new byte[HEADER_SIZE];
  stream.read(header);
  int length=ByteBuffer.wrap(header,header.length - 4,4).order(ByteOrder.LITTLE_ENDIAN).getInt();
  byte[] data=new byte[length];
  System.arraycopy(header,0,data,0,header.length);
  stream.read(data,header.length,length - header.length);
  mId=create(data);
}","private void init(final LWFManager lwfManager,final InputStream stream) throws Exception {
  mManager=lwfManager;
  byte[] header=new byte[HEADER_SIZE];
  stream.read(header);
  int length=ByteBuffer.wrap(header,header.length - 4,4).order(ByteOrder.LITTLE_ENDIAN).getInt();
  byte[] data=new byte[length];
  System.arraycopy(header,0,data,0,header.length);
  stream.read(data,header.length,length - header.length);
  mId=create(data);
}",0.9930715935334872
80403,"public void setLWFManager(LWFManager lwfManager){
  mManager=lwfManager;
}","public void setLWFManager(final LWFManager lwfManager){
  mManager=lwfManager;
}",0.961038961038961
80404,"public LWFData(final LWFManager lwfManager,InputStream stream) throws Exception {
  init(lwfManager,stream);
}","public LWFData(final LWFManager lwfManager,final InputStream stream) throws Exception {
  init(lwfManager,stream);
}",0.9734513274336284
80405,"public String getTextureName(int textureNo){
  return getTextureName(mId,textureNo);
}","public String getTextureName(final int textureNo){
  return getTextureName(mId,textureNo);
}",0.9662921348314608
80406,"public void setTextures(Texture[] textures){
  int textureNum=getTextureNum(mId);
  int[] glTextureIds=new int[textureNum];
  float[] glTextureUs=new float[textureNum];
  float[] glTextureVs=new float[textureNum];
  for (int i=0; i < textureNum; ++i) {
    Texture texture=textures[i];
    glTextureIds[i]=texture.getTextureID();
    glTextureUs[i]=texture.mCoordScaleX;
    glTextureVs[i]=texture.mCoordScaleY;
  }
  setGLTexture(mId,glTextureIds,glTextureUs,glTextureVs);
}","public void setTextures(final Texture[] textures){
  int textureNum=getTextureNum(mId);
  int[] glTextureIds=new int[textureNum];
  float[] glTextureUs=new float[textureNum];
  float[] glTextureVs=new float[textureNum];
  for (int i=0; i < textureNum; ++i) {
    Texture texture=textures[i];
    if (texture != null) {
      glTextureIds[i]=texture.getTextureID();
      glTextureUs[i]=texture.mCoordScaleX;
      glTextureVs[i]=texture.mCoordScaleY;
    }
 else {
      glTextureIds[i]=-1;
      glTextureUs[i]=0;
      glTextureVs[i]=0;
    }
  }
  setGLTexture(mId,glTextureIds,glTextureUs,glTextureVs);
}",0.8771929824561403
80407,"public void dispose(){
  if (mId != -1) {
    if (LOG_ENABLED) {
      Log.i(TAG,""String_Node_Str"");
    }
    destroy(mId);
    mId=-1;
    if (mManager != null)     mManager.removeLWFData(this);
    mManager=null;
  }
}","public void dispose(){
  if (mId != -1) {
    if (LOG_ENABLED) {
      Log.i(TAG,""String_Node_Str"");
    }
    destroy(mId);
    mId=-1;
    if (mManager != null) {
      mManager.removeLWFData(this);
    }
    mManager=null;
  }
}",0.9778761061946902
80408,"@Override public boolean update(final int deltaTime){
  super.update(deltaTime);
  if (mCurrentFrame != mPreviousFrame) {
    mPreviousFrame=mCurrentFrame;
    updateFrame(mCurrentFrame);
    invalidate(FRAME);
  }
  if (mNumFrames > 0 && mPlaying) {
    int frames=1;
    if (getFps() > 0) {
      mPendingTime+=deltaTime;
      frames=mPendingTime / (int)mFrameDuration;
      if (frames > 0) {
        mPendingTime%=(int)mFrameDuration;
      }
    }
    if (frames > 0) {
      mAccumulatedFrames+=frames;
      mCurrentFrame+=frames;
      if (mLoop == LOOP_REPEAT) {
        if (mCurrentFrame >= mNumFrames) {
          mCurrentFrame%=mNumFrames;
        }
      }
 else       if (mLoop == LOOP_REVERSE) {
        final int trips=(mAccumulatedFrames / mNumFrames);
        if (trips % 2 == 0) {
          if (mCurrentFrame >= mNumFrames) {
            mCurrentFrame%=mNumFrames;
          }
        }
 else {
          mCurrentFrame=mNumFrames - 1 - mAccumulatedFrames % mNumFrames;
        }
      }
 else {
        if (mCurrentFrame >= mNumFrames) {
          mCurrentFrame=mNumFrames - 1;
          stop();
        }
      }
    }
  }
  return mNumFrames > 0;
}","@Override public boolean update(final int deltaTime){
  super.update(deltaTime);
  if (mCurrentFrame != mPreviousFrame) {
    mPreviousFrame=mCurrentFrame;
    updateFrame(mCurrentFrame);
    invalidate(FRAME);
  }
  if (mNumFrames > 0 && mPlaying) {
    int frames=1;
    if (getFps() > 0) {
      mPendingTime+=deltaTime;
      frames=mPendingTime / (int)mFrameDuration;
      if (frames > 0) {
        mPendingTime%=(int)mFrameDuration;
      }
    }
    if (frames > 0) {
      mAccumulatedFrames+=frames;
      mCurrentFrame+=frames;
      if (mLoop == LOOP_REPEAT) {
        if (mCurrentFrame >= mNumFrames) {
          mCurrentFrame%=mNumFrames;
        }
      }
 else       if (mLoop == LOOP_REVERSE) {
        final int trips=(mAccumulatedFrames / mNumFrames);
        if (trips % 2 == 0) {
          if (mCurrentFrame >= mNumFrames) {
            mCurrentFrame%=mNumFrames;
          }
        }
 else {
          mCurrentFrame=mNumFrames - 1 - mAccumulatedFrames % mNumFrames;
        }
      }
 else {
        if (mCurrentFrame >= mNumFrames) {
          mCurrentFrame=mNumFrames - 1;
          stop();
        }
      }
    }
  }
  if (mCurrentFrame != mPreviousFrame) {
    updateFrame(mCurrentFrame);
    mPreviousFrame=mCurrentFrame;
    invalidate(FRAME);
  }
  return mNumFrames > 0;
}",0.9458367016976555
80409,"@Override public boolean update(final int deltaTime){
  super.update(deltaTime);
  if (mCurrentFrame != mPreviousFrame) {
    mPreviousFrame=mCurrentFrame;
    updateFrame(mCurrentFrame);
    invalidate(FRAME);
  }
  if (mNumFrames > 0 && mPlaying) {
    int frames=1;
    if (getFps() > 0) {
      mPendingTime+=deltaTime;
      frames=mPendingTime / (int)mFrameDuration;
      if (frames > 0) {
        mPendingTime%=(int)mFrameDuration;
      }
    }
    if (frames > 0) {
      mAccumulatedFrames+=frames;
      mCurrentFrame+=frames;
      if (mLoop == LOOP_REPEAT) {
        if (mCurrentFrame >= mNumFrames) {
          mCurrentFrame%=mNumFrames;
        }
      }
 else       if (mLoop == LOOP_REVERSE) {
        final int trips=(mAccumulatedFrames / mNumFrames);
        if (trips % 2 == 0) {
          if (mCurrentFrame >= mNumFrames) {
            mCurrentFrame%=mNumFrames;
          }
        }
 else {
          mCurrentFrame=mNumFrames - 1 - mAccumulatedFrames % mNumFrames;
        }
      }
 else {
        if (mCurrentFrame >= mNumFrames) {
          mCurrentFrame=mNumFrames - 1;
          stop();
        }
      }
    }
  }
  return mNumFrames > 0;
}","@Override public boolean update(final int deltaTime){
  super.update(deltaTime);
  if (mNumFrames > 0 && mPlaying) {
    int frames=1;
    if (getFps() > 0) {
      mPendingTime+=deltaTime;
      frames=mPendingTime / (int)mFrameDuration;
      if (frames > 0) {
        mPendingTime%=(int)mFrameDuration;
      }
    }
    if (frames > 0) {
      mAccumulatedFrames+=frames;
      mCurrentFrame+=frames;
      if (mLoop == LOOP_REPEAT) {
        if (mCurrentFrame >= mNumFrames) {
          mCurrentFrame%=mNumFrames;
        }
      }
 else       if (mLoop == LOOP_REVERSE) {
        final int trips=(mAccumulatedFrames / mNumFrames);
        if (trips % 2 == 0) {
          if (mCurrentFrame >= mNumFrames) {
            mCurrentFrame%=mNumFrames;
          }
        }
 else {
          mCurrentFrame=mNumFrames - 1 - mAccumulatedFrames % mNumFrames;
        }
      }
 else {
        if (mCurrentFrame >= mNumFrames) {
          mCurrentFrame=mNumFrames - 1;
          stop();
        }
      }
    }
  }
  if (mCurrentFrame != mPreviousFrame) {
    updateFrame(mCurrentFrame);
    mPreviousFrame=mCurrentFrame;
    invalidate(FRAME);
  }
  return mNumFrames > 0;
}",0.8854700854700854
80410,"@Override public boolean draw(final GLState glState){
  if (mNumChildren == 0) {
    return false;
  }
  drawStart(glState);
  if (mClippingEnabled) {
    mOriginalScissorEnabled=glState.isScissorTestEnabled();
    if (mOriginalScissorEnabled) {
      if (mOriginalScissor == null) {
        mOriginalScissor=new int[4];
      }
      glState.getScissor(mOriginalScissor);
    }
 else {
      glState.setScissorTestEnabled(true);
    }
    if (mClipStageRect == null) {
      mClipStageRect=new RectF();
    }
    final Scene scene=getScene();
    if (scene != null) {
      scene.globalToStage(mBounds,mClipStageRect);
    }
 else {
      mClipStageRect.set(mBounds);
    }
    glState.setScissor((int)mClipStageRect.left,(int)mClipStageRect.top,(int)mClipStageRect.width(),(int)mClipStageRect.height());
  }
  if (mCacheEnabled) {
    if ((mInvalidateFlags & CHILDREN) != 0) {
      if (mCacheFrameBuffer == null || !mCacheFrameBuffer.hasSize(mSize)) {
        if (mCacheFrameBuffer != null) {
          mCacheFrameBuffer.unload();
          mCacheFrameBuffer.getTexture().unload();
        }
        mCacheFrameBuffer=new FrameBuffer(glState,mSize.x,mSize.y,true);
        if (mCacheSprite == null) {
          mCacheSprite=new Sprite();
          mCacheSprite.flipTextureCoordBuffer(FLIP_Y);
        }
        mCacheSprite.setTexture(mCacheFrameBuffer.getTexture());
      }
      mCacheFrameBuffer.bind(mCacheProjection);
      mCacheFrameBuffer.clear();
      drawChildren(glState);
      mCacheFrameBuffer.unbind();
    }
    mCacheSprite.draw(glState);
  }
 else {
    drawChildren(glState);
  }
  if (mClippingEnabled) {
    if (mOriginalScissorEnabled) {
      glState.setScissor(mOriginalScissor);
    }
 else {
      glState.setScissorTestEnabled(false);
    }
  }
  drawEnd(glState);
  mInvalidateFlags&=~(VISUAL | CHILDREN);
  return true;
}","@Override public boolean draw(final GLState glState){
  if (mNumChildren == 0) {
    return false;
  }
  drawStart(glState);
  if (mClippingEnabled) {
    mOriginalScissorEnabled=glState.isScissorTestEnabled();
    if (mOriginalScissorEnabled) {
      if (mOriginalScissor == null) {
        mOriginalScissor=new int[4];
      }
      glState.getScissor(mOriginalScissor);
    }
 else {
      glState.setScissorTestEnabled(true);
    }
    if (mClipStageRect == null) {
      mClipStageRect=new RectF();
    }
    final Scene scene=getScene();
    if (scene != null) {
      scene.globalToStage(mBounds,mClipStageRect);
    }
 else {
      mClipStageRect.set(mBounds);
    }
    glState.setScissor((int)Math.ceil(mClipStageRect.left),(int)Math.ceil(mClipStageRect.top),(int)Math.ceil(mClipStageRect.width()),(int)Math.ceil(mClipStageRect.height()));
  }
  if (mCacheEnabled) {
    if ((mInvalidateFlags & CHILDREN) != 0) {
      if (mCacheFrameBuffer == null || !mCacheFrameBuffer.hasSize(mSize)) {
        if (mCacheFrameBuffer != null) {
          mCacheFrameBuffer.unload();
          mCacheFrameBuffer.getTexture().unload();
        }
        mCacheFrameBuffer=new FrameBuffer(glState,mSize.x,mSize.y,true);
        if (mCacheSprite == null) {
          mCacheSprite=new Sprite();
          mCacheSprite.flipTextureCoordBuffer(FLIP_Y);
        }
        mCacheSprite.setTexture(mCacheFrameBuffer.getTexture());
      }
      mCacheFrameBuffer.bind(mCacheProjection);
      mCacheFrameBuffer.clear();
      drawChildren(glState);
      mCacheFrameBuffer.unbind();
    }
    mCacheSprite.draw(glState);
  }
 else {
    drawChildren(glState);
  }
  if (mClippingEnabled) {
    if (mOriginalScissorEnabled) {
      glState.setScissor(mOriginalScissor);
    }
 else {
      glState.setScissorTestEnabled(false);
    }
  }
  drawEnd(glState);
  mInvalidateFlags&=~(VISUAL | CHILDREN);
  return true;
}",0.988279168886521
80411,"public void play(final Media media) throws IllegalStateException {
  if (mMediaPlayer == null) {
    mMediaPlayer=new MediaPlayer();
    mMediaPlayer.setOnErrorListener(this);
  }
  mMediaPlayer.reset();
  if (media.load(mMediaPlayer,mContext) == 0) {
    return;
  }
  mMediaPlayer.setAudioStreamType(AudioManager.STREAM_MUSIC);
  mMediaPlayer.setLooping(media.isLooping());
  mMediaPlayer.setOnPreparedListener(this);
  mMediaPlayer.setVolume(mMediaVolume,mMediaVolume);
  mMediaPlayer.prepareAsync();
}","public void play(final Media media) throws IllegalStateException {
  if (mMediaPlayer == null) {
    mMediaPlayer=new MediaPlayer();
    mMediaPlayer.setOnErrorListener(this);
  }
  mMediaPlayer.reset();
  mMediaPrepared=false;
  if (media.load(mMediaPlayer,mContext) == 0) {
    return;
  }
  mMediaPlayer.setAudioStreamType(AudioManager.STREAM_MUSIC);
  mMediaPlayer.setLooping(media.isLooping());
  mMediaPlayer.setOnPreparedListener(this);
  mMediaPlayer.setVolume(mMediaVolume,mMediaVolume);
  mMediaPlayer.prepareAsync();
}",0.97678916827853
80412,"public void setMediaEnabled(final boolean mediaEnabled){
  mMediaEnabled=mediaEnabled;
  if (!mediaEnabled) {
    if (mMediaPlayer != null && mMediaPlayer.isPlaying()) {
      mMediaPlayer.pause();
    }
  }
 else   if (mMediaPlayer != null) {
    mMediaPlayer.start();
  }
}","public void setMediaEnabled(final boolean mediaEnabled){
  mMediaEnabled=mediaEnabled;
  if (!mediaEnabled) {
    if (mMediaPlayer != null && mMediaPlayer.isPlaying()) {
      mMediaPlayer.pause();
    }
  }
 else   if (mMediaPlayer != null) {
    if (mMediaPrepared) {
      mMediaPlayer.start();
    }
  }
}",0.9315068493150684
80413,"public void releaseMedia(){
  if (mMediaPlayer != null) {
    mMediaPlayer.release();
    mMediaPlayer=null;
  }
}","public void releaseMedia(){
  if (mMediaPlayer != null) {
    mMediaPlayer.release();
    mMediaPlayer=null;
    mMediaPrepared=false;
  }
}",0.8976377952755905
80414,"@Override public boolean onError(final MediaPlayer mp,final int what,final int extra){
  if (mp != null) {
    mp.reset();
  }
  return true;
}","@Override public boolean onError(final MediaPlayer mp,final int what,final int extra){
  if (mp != null) {
    mp.reset();
    mMediaPrepared=false;
  }
  return true;
}",0.9166666666666666
80415,"public void stopMedia(){
  if (mMediaPlayer != null && mMediaPlayer.isPlaying()) {
    mMediaPlayer.stop();
  }
}","public void stopMedia(){
  if (mMediaPlayer != null && mMediaPlayer.isPlaying()) {
    mMediaPlayer.stop();
    mMediaPrepared=false;
  }
}",0.8968253968253969
80416,"@Override public void onPrepared(final MediaPlayer mp){
  if (mMediaEnabled) {
    mp.start();
  }
}","@Override public void onPrepared(final MediaPlayer mp){
  if (mMediaEnabled) {
    mMediaPrepared=true;
    mp.start();
  }
}",0.8888888888888888
80417,"public void play(final Media media) throws IllegalStateException {
  if (mMediaPlayer == null) {
    mMediaPlayer=new MediaPlayer();
    mMediaPlayer.setOnErrorListener(this);
  }
  mMediaPlayer.reset();
  if (media.load(mMediaPlayer,mContext) == 0) {
    return;
  }
  mMediaPlayer.setAudioStreamType(AudioManager.STREAM_MUSIC);
  mMediaPlayer.setLooping(media.isLooping());
  mMediaPlayer.setOnPreparedListener(this);
  mMediaPlayer.setVolume(mMediaVolume,mMediaVolume);
  mMediaPlayer.prepareAsync();
}","public void play(final Media media) throws IllegalStateException {
  if (mMediaPlayer == null) {
    mMediaPlayer=new MediaPlayer();
    mMediaPlayer.setOnErrorListener(this);
  }
  mMediaPlayer.reset();
  mMediaPrepared=false;
  if (media.load(mMediaPlayer,mContext) == 0) {
    return;
  }
  mMediaPlayer.setAudioStreamType(AudioManager.STREAM_MUSIC);
  mMediaPlayer.setLooping(media.isLooping());
  mMediaPlayer.setOnPreparedListener(this);
  mMediaPlayer.setVolume(mMediaVolume,mMediaVolume);
  mMediaPlayer.prepareAsync();
}",0.97678916827853
80418,"public void setMediaEnabled(final boolean mediaEnabled){
  mMediaEnabled=mediaEnabled;
  if (!mediaEnabled) {
    if (mMediaPlayer != null && mMediaPlayer.isPlaying()) {
      mMediaPlayer.pause();
    }
  }
 else   if (mMediaPlayer != null) {
    mMediaPlayer.start();
  }
}","public void setMediaEnabled(final boolean mediaEnabled){
  mMediaEnabled=mediaEnabled;
  if (!mediaEnabled) {
    if (mMediaPlayer != null && mMediaPlayer.isPlaying()) {
      mMediaPlayer.pause();
    }
  }
 else   if (mMediaPlayer != null) {
    if (mMediaPrepared) {
      mMediaPlayer.start();
    }
  }
}",0.9315068493150684
80419,"public void releaseMedia(){
  if (mMediaPlayer != null) {
    mMediaPlayer.release();
    mMediaPlayer=null;
  }
}","public void releaseMedia(){
  if (mMediaPlayer != null) {
    mMediaPlayer.release();
    mMediaPlayer=null;
    mMediaPrepared=false;
  }
}",0.8976377952755905
80420,"@Override public boolean onError(final MediaPlayer mp,final int what,final int extra){
  if (mp != null) {
    mp.reset();
  }
  return true;
}","@Override public boolean onError(final MediaPlayer mp,final int what,final int extra){
  if (mp != null) {
    mp.reset();
    mMediaPrepared=false;
  }
  return true;
}",0.9166666666666666
80421,"public void stopMedia(){
  if (mMediaPlayer != null && mMediaPlayer.isPlaying()) {
    mMediaPlayer.stop();
  }
}","public void stopMedia(){
  if (mMediaPlayer != null && mMediaPlayer.isPlaying()) {
    mMediaPlayer.stop();
    mMediaPrepared=false;
  }
}",0.8968253968253969
80422,"@Override public void onPrepared(final MediaPlayer mp){
  if (mMediaEnabled) {
    mp.start();
  }
}","@Override public void onPrepared(final MediaPlayer mp){
  if (mMediaEnabled) {
    mMediaPrepared=true;
    mp.start();
  }
}",0.8888888888888888
80423,"public void setAniFile(final AniFile file){
  mAniFile=file;
  if (file != null && mAniFile.mSkeletonData.length > 0) {
    mVertexBuffers=new VertexBuffer[file.mNumParts];
    mCoordBuffers=new TextureCoordBuffer[file.mNumParts];
    mBounds=new RectF[file.mNumParts];
    if (file.mVersion == 2) {
      file.getFrameCoordBuffers(0,mCoordBuffers);
    }
    mNumFrames=file.mNumFrames;
  }
 else {
    mNumFrames=0;
  }
  mPreviousFrame=-1;
  mCurrentFrame=0;
}","public void setAniFile(final AniFile file){
  mAniFile=file;
  if (file != null && mAniFile.mSkeletonData.length > 0) {
    mVertexBuffers=new VertexBuffer[file.mNumParts];
    mCoordBuffers=new TextureCoordBuffer[file.mNumParts];
    mBounds=new RectF[file.mNumFrames];
    if (file.mVersion == 2) {
      file.getFrameCoordBuffers(0,mCoordBuffers);
    }
    mNumFrames=file.mNumFrames;
  }
 else {
    mNumFrames=0;
  }
  mPreviousFrame=-1;
  mCurrentFrame=0;
}",0.9902912621359224
80424,"@Override public boolean draw(final GLState glState){
  if (mNumFrames > 0) {
    drawStart(glState);
    drawChildren(glState);
    drawEnd(glState);
    return true;
  }
  return false;
}","@Override public boolean draw(final GLState glState){
  if (mNumFrames > 0) {
    drawStart(glState);
    final boolean blendChanged=glState.setBlendFunc(mBlendFunc);
    glState.setColor(getSumColor());
    glState.setColorArrayEnabled(false);
    drawChildren(glState);
    if (blendChanged) {
      glState.setBlendFunc(null);
    }
    drawEnd(glState);
    return true;
  }
  return false;
}",0.6461538461538462
80425,"@Override public boolean draw(final GLState glState){
  if (mVertexBuffer == null) {
    return false;
  }
  drawStart(glState);
  boolean blendChanged=glState.setBlendFunc(mBlendFunc);
  glState.setColor(getSumColor());
  if (mColorBuffer == null) {
    glState.setColorArrayEnabled(false);
  }
 else {
    mColorBuffer.apply(glState);
  }
  if (mTexture != null) {
    mTexture.bind();
    if (mTextureCoordBufferScaled != null) {
      mTextureCoordBufferScaled.apply(glState);
    }
  }
 else {
    glState.unbindTexture();
  }
  mVertexBuffer.draw(glState);
  if (blendChanged) {
    glState.setBlendFunc(null);
  }
  drawEnd(glState);
  return true;
}","@Override public boolean draw(final GLState glState){
  if (mVertexBuffer == null) {
    return false;
  }
  drawStart(glState);
  final boolean blendChanged=glState.setBlendFunc(mBlendFunc);
  glState.setColor(getSumColor());
  if (mColorBuffer == null) {
    glState.setColorArrayEnabled(false);
  }
 else {
    mColorBuffer.apply(glState);
  }
  if (mTexture != null) {
    mTexture.bind();
    if (mTextureCoordBufferScaled != null) {
      mTextureCoordBufferScaled.apply(glState);
    }
  }
 else {
    glState.unbindTexture();
  }
  mVertexBuffer.draw(glState);
  if (blendChanged) {
    glState.setBlendFunc(null);
  }
  drawEnd(glState);
  return true;
}",0.9954545454545456
80426,"public int load(final MediaPlayer player,final Context context){
  try {
    player.setDataSource(mAssetFd.getFileDescriptor(),mAssetFd.getStartOffset(),mAssetFd.getLength());
  }
 catch (  Exception e) {
    Log.e(TAG,e.getMessage());
    return 0;
  }
  return 1;
}","public int load(final MediaPlayer player,final Context context){
  try {
    player.setDataSource(mAssetFd.getFileDescriptor(),mAssetFd.getStartOffset(),mAssetFd.getLength());
  }
 catch (  Exception e) {
    Log.e(TAG,""String_Node_Str"" + e.getMessage());
    return 0;
  }
  return 1;
}",0.9638989169675092
80427,"public ErrorLogRecorder(String detailMessage){
  super(detailMessage);
}","ErrorLogRecorder(String detailMessage){
  super(detailMessage);
}",0.948905109489051
80428,"@Override protected Result check() throws Exception {
  String keyspace=null;
  String clusterName=null;
  try (Session session=sessionFactory.create()){
    clusterName=session.getCluster().getClusterName();
    keyspace=session.getLoggedKeyspace();
    return Result.healthy();
  }
 catch (  Exception ex) {
    LOG.error(""String_Node_Str"",clusterName,keyspace,ex);
    throw ex;
  }
}","@Override protected Result check() throws Exception {
  try (Session session=sessionFactory.create()){
    return Result.healthy();
  }
 catch (  Exception ex) {
    LOG.error(""String_Node_Str"",sessionFactory.getClusterName(),sessionFactory.getKeyspace(),ex);
    throw ex;
  }
}",0.6336336336336337
80429,"private static void populateNumericResources(ActivityDictionary AD,Conditions conditions){
  List<NumericResource> numericResources=conditions.getNumericResources();
  List<NumericResourceDef> numericResourceDefs=AD.getDefinitions(NumericResourceDef.class);
  for (  NumericResourceDef numericDef : numericResourceDefs) {
    String name=numericDef.getName();
    NumericResource numericResource=MemberFactory.eINSTANCE.createNumericResource();
    numericResource.setName(name);
    numericResource.setFloat((float)numericDef.getDefault());
    numericResources.add(numericResource);
  }
}","private static void populateNumericResources(ActivityDictionary AD,Conditions conditions){
  List<NumericResource> numericResources=conditions.getNumericResources();
  List<ENumericResourceDef> numericResourceDefs=AD.getDefinitions(ENumericResourceDef.class);
  for (  ENumericResourceDef numericDef : numericResourceDefs) {
    if (!(numericDef instanceof EExtendedNumericResourceDef)) {
      String name=numericDef.getName();
      NumericResource numericResource=MemberFactory.eINSTANCE.createNumericResource();
      numericResource.setName(name);
      double defaultValue=getNumericResourceDefaultValue(numericDef);
      numericResource.setFloat((float)defaultValue);
      numericResources.add(numericResource);
    }
  }
}",0.8577912254160364
80430,"public static Jid from(String jidString) throws XmppStringprepException {
  String localpart=XmppStringUtils.parseBareAddress(jidString);
  String domainpart=XmppStringUtils.parseDomain(jidString);
  String resource=XmppStringUtils.parseResource(jidString);
  return from(localpart,domainpart,resource);
}","public static Jid from(String jidString) throws XmppStringprepException {
  String localpart=XmppStringUtils.parseLocalpart(jidString);
  String domainpart=XmppStringUtils.parseDomain(jidString);
  String resource=XmppStringUtils.parseResource(jidString);
  return from(localpart,domainpart,resource);
}",0.9671052631578948
80431,"public static Jid fromUnescaped(String escapedJidString) throws XmppStringprepException {
  String localpart=XmppStringUtils.parseBareAddress(escapedJidString);
  localpart=XmppStringUtils.escapeLocalpart(localpart);
  String domainpart=XmppStringUtils.parseDomain(escapedJidString);
  String resource=XmppStringUtils.parseResource(escapedJidString);
  return from(localpart,domainpart,resource);
}","public static Jid fromUnescaped(String escapedJidString) throws XmppStringprepException {
  String localpart=XmppStringUtils.parseLocalpart(escapedJidString);
  localpart=XmppStringUtils.escapeLocalpart(localpart);
  String domainpart=XmppStringUtils.parseDomain(escapedJidString);
  String resource=XmppStringUtils.parseResource(escapedJidString);
  return from(localpart,domainpart,resource);
}",0.9748110831234256
80432,"@Override public String asUnescapedString(){
  if (unescapedCache != null) {
    return unescapedCache;
  }
  unescapedCache=super.asUnescapedString() + '@' + super.toString();
  return unescapedCache;
}","@Override public String asUnescapedString(){
  if (unescapedCache != null) {
    return unescapedCache;
  }
  unescapedCache=super.asUnescapedString() + '/' + resource;
  return unescapedCache;
}",0.949748743718593
80433,"/** 
 * @功能 : 根据name获取properties文件中的value, 如果为空返回默认值
 * @作者 : yangc
 * @创建日期 : 2013-11-21 下午07:01:48
 * @param filePath properties文件路径(classpath中的相对路径)
 * @param name
 * @param defaultValue
 * @return
 */
public static String getProperty(String filePath,String name,String defaultValue){
  if (StringUtils.isBlank(filePath) || StringUtils.isBlank(name) || StringUtils.isBlank(defaultValue)) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  try {
    Properties prop=PROPS.get(filePath);
    if (prop == null) {
      prop=new Properties();
      prop.load(PropertiesUtils.class.getResourceAsStream(filePath));
      PROPS.put(filePath,prop);
    }
    String value=prop.getProperty(name);
    return StringUtils.isBlank(value) ? defaultValue : value;
  }
 catch (  FileNotFoundException e) {
    e.printStackTrace();
  }
catch (  IOException e) {
    e.printStackTrace();
  }
  return defaultValue;
}","/** 
 * @功能 : 根据name获取properties文件中的value, 如果为空返回默认值
 * @作者 : yangc
 * @创建日期 : 2013-11-21 下午07:01:48
 * @param filePath properties文件路径(classpath中的相对路径)
 * @param name
 * @param defaultValue
 * @return
 */
public static String getProperty(String filePath,String name,String defaultValue){
  if (StringUtils.isBlank(filePath) || StringUtils.isBlank(name)) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  Properties prop=new Properties();
  InputStream in=null;
  try {
    in=PropertiesUtils.class.getResourceAsStream(filePath);
    prop.load(in);
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
 finally {
    try {
      if (in != null)       in.close();
    }
 catch (    IOException e) {
      e.printStackTrace();
    }
  }
  return prop.getProperty(name,defaultValue);
}",0.5977945443993036
80434,"public static void main(String[] args){
  System.out.println(PropertiesUtils.getProperty(""String_Node_Str"",""String_Node_Str""));
  PropertiesUtils.setProperty(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
}","public static void main(String[] args){
  System.out.println(PropertiesUtils.getProperty(""String_Node_Str"",""String_Node_Str""));
}",0.75
80435,"protected void applySizeConstraintsForRead(ResourceEntity<?> entity,SizeConstraints constraints){
  int upperOffset=constraints.getFetchOffset();
  if (upperOffset > 0 && entity.getFetchOffset() > upperOffset) {
    LOGGER.info(""String_Node_Str"" + entity.getFetchOffset() + ""String_Node_Str""+ upperOffset);
    entity.setFetchOffset(upperOffset);
  }
  int upperLimit=constraints.getFetchLimit();
  if (upperLimit > 0 && entity.getFetchLimit() > upperLimit) {
    LOGGER.info(""String_Node_Str"" + entity.getFetchLimit() + ""String_Node_Str""+ upperLimit);
    entity.setFetchLimit(upperLimit);
  }
}","protected void applySizeConstraintsForRead(ResourceEntity<?> entity,SizeConstraints constraints){
  int upperOffset=constraints.getFetchOffset();
  if (upperOffset > 0 && entity.getFetchOffset() > upperOffset) {
    LOGGER.info(""String_Node_Str"" + entity.getFetchOffset() + ""String_Node_Str""+ upperOffset);
    entity.setFetchOffset(upperOffset);
  }
  int upperLimit=constraints.getFetchLimit();
  if (upperLimit > 0 && (entity.getFetchLimit() <= 0 || entity.getFetchLimit() > upperLimit)) {
    LOGGER.info(""String_Node_Str"" + entity.getFetchLimit() + ""String_Node_Str""+ upperLimit);
    entity.setFetchLimit(upperLimit);
  }
}",0.973061224489796
80436,"@Test public void testApply_FetchLimit(){
  SizeConstraints s1=new SizeConstraints().fetchLimit(5);
  SizeConstraints s2=new SizeConstraints().fetchLimit(0);
  ResourceEntity<E1> t1=new ResourceEntity<>(lre0);
  t1.setFetchLimit(0);
  constraintHandler.constrainResponse(t1,s1,null);
  assertEquals(0,t1.getFetchLimit());
  assertEquals(5,s1.getFetchLimit());
  ResourceEntity<E1> t2=new ResourceEntity<>(lre0);
  t2.setFetchLimit(3);
  constraintHandler.constrainResponse(t2,s1,null);
  assertEquals(3,t2.getFetchLimit());
  assertEquals(5,s1.getFetchLimit());
  ResourceEntity<E1> t3=new ResourceEntity<>(lre0);
  t3.setFetchLimit(6);
  constraintHandler.constrainResponse(t3,s1,null);
  assertEquals(5,t3.getFetchLimit());
  assertEquals(5,s1.getFetchLimit());
  ResourceEntity<E1> t4=new ResourceEntity<>(lre0);
  t4.setFetchLimit(6);
  constraintHandler.constrainResponse(t4,s2,null);
  assertEquals(6,t4.getFetchLimit());
  assertEquals(0,s2.getFetchLimit());
}","@Test public void testApply_FetchLimit(){
  SizeConstraints s1=new SizeConstraints().fetchLimit(5);
  SizeConstraints s2=new SizeConstraints().fetchLimit(0);
  ResourceEntity<E1> t1=new ResourceEntity<>(lre0);
  constraintHandler.constrainResponse(t1,s1,null);
  assertEquals(5,t1.getFetchLimit());
  assertEquals(5,s1.getFetchLimit());
  ResourceEntity<E1> t1_1=new ResourceEntity<>(lre0);
  t1_1.setFetchLimit(0);
  constraintHandler.constrainResponse(t1_1,s1,null);
  assertEquals(5,t1_1.getFetchLimit());
  assertEquals(5,s1.getFetchLimit());
  ResourceEntity<E1> t1_2=new ResourceEntity<>(lre0);
  t1_2.setFetchLimit(-1);
  constraintHandler.constrainResponse(t1_2,s1,null);
  assertEquals(5,t1_2.getFetchLimit());
  assertEquals(5,s1.getFetchLimit());
  ResourceEntity<E1> t2=new ResourceEntity<>(lre0);
  t2.setFetchLimit(3);
  constraintHandler.constrainResponse(t2,s1,null);
  assertEquals(3,t2.getFetchLimit());
  assertEquals(5,s1.getFetchLimit());
  ResourceEntity<E1> t3=new ResourceEntity<>(lre0);
  t3.setFetchLimit(6);
  constraintHandler.constrainResponse(t3,s1,null);
  assertEquals(5,t3.getFetchLimit());
  assertEquals(5,s1.getFetchLimit());
  ResourceEntity<E1> t4=new ResourceEntity<>(lre0);
  t4.setFetchLimit(6);
  constraintHandler.constrainResponse(t4,s2,null);
  assertEquals(6,t4.getFetchLimit());
  assertEquals(0,s2.getFetchLimit());
}",0.7710120068610634
80437,"@Before public void before(){
  this.context=runtime.newContext();
  QueryChain chain=new QueryChain();
  chain.addQuery(new EJBQLQuery(""String_Node_Str""));
  chain.addQuery(new EJBQLQuery(""String_Node_Str""));
  chain.addQuery(new EJBQLQuery(""String_Node_Str""));
  chain.addQuery(new EJBQLQuery(""String_Node_Str""));
  chain.addQuery(new EJBQLQuery(""String_Node_Str""));
  chain.addQuery(new EJBQLQuery(""String_Node_Str""));
  chain.addQuery(new EJBQLQuery(""String_Node_Str""));
  chain.addQuery(new EJBQLQuery(""String_Node_Str""));
  chain.addQuery(new EJBQLQuery(""String_Node_Str""));
  chain.addQuery(new EJBQLQuery(""String_Node_Str""));
  chain.addQuery(new EJBQLQuery(""String_Node_Str""));
  chain.addQuery(new EJBQLQuery(""String_Node_Str""));
  chain.addQuery(new EJBQLQuery(""String_Node_Str""));
  chain.addQuery(new EJBQLQuery(""String_Node_Str""));
  chain.addQuery(new EJBQLQuery(""String_Node_Str""));
  context.performGenericQuery(chain);
}","@Before public void before(){
  this.context=runtime.newContext();
  context.performQuery(new RefreshQuery());
  QueryChain chain=new QueryChain();
  chain.addQuery(new EJBQLQuery(""String_Node_Str""));
  chain.addQuery(new EJBQLQuery(""String_Node_Str""));
  chain.addQuery(new EJBQLQuery(""String_Node_Str""));
  chain.addQuery(new EJBQLQuery(""String_Node_Str""));
  chain.addQuery(new EJBQLQuery(""String_Node_Str""));
  chain.addQuery(new EJBQLQuery(""String_Node_Str""));
  chain.addQuery(new EJBQLQuery(""String_Node_Str""));
  chain.addQuery(new EJBQLQuery(""String_Node_Str""));
  chain.addQuery(new EJBQLQuery(""String_Node_Str""));
  chain.addQuery(new EJBQLQuery(""String_Node_Str""));
  chain.addQuery(new EJBQLQuery(""String_Node_Str""));
  chain.addQuery(new EJBQLQuery(""String_Node_Str""));
  chain.addQuery(new EJBQLQuery(""String_Node_Str""));
  chain.addQuery(new EJBQLQuery(""String_Node_Str""));
  chain.addQuery(new EJBQLQuery(""String_Node_Str""));
  context.performGenericQuery(chain);
}",0.9770833333333332
80438,"static boolean isMetadataGetter(Method getter){
  return getter.getParameterCount() == 0 && hasAnnotation(getter,Meta.class);
}","static boolean isMetadataGetter(Method method){
  return isAnyGetter(method) && hasAnnotation(method,Meta.class);
}",0.8099173553719008
80439,"static <D extends DynamicObject<D>>Set<Object> cachedKeys(Class<D> type){
  return Arrays.stream(type.getMethods()).filter(method -> method.getAnnotation(Cached.class) != null).map(method -> method.getAnnotation(Key.class)).filter(key -> key != null).map(Key::value).map(Reflection::stringToKey).collect(toSet());
}","static <D extends DynamicObject<D>>Set<Object> cachedKeys(Class<D> type){
  return Arrays.stream(type.getMethods()).flatMap(Reflection::getCachedKeysForMethod).collect(toSet());
}",0.6477732793522267
80440,"private static Method getCorrespondingGetter(Method builderMethod){
  try {
    Class<?> type=builderMethod.getDeclaringClass();
    Method correspondingGetter=type.getMethod(builderMethod.getName());
    return correspondingGetter;
  }
 catch (  NoSuchMethodException ex) {
    throw new IllegalStateException(""String_Node_Str"",ex);
  }
}","private static Method getCorrespondingGetter(Method builderMethod){
  try {
    Class<?> type=builderMethod.getDeclaringClass();
    Method correspondingGetter=type.getMethod(builderMethod.getName());
    return correspondingGetter;
  }
 catch (  NoSuchMethodException ex) {
    throw new IllegalStateException(""String_Node_Str"" + builderMethod + ""String_Node_Str"",ex);
  }
}",0.9495798319327732
80441,"static <D extends DynamicObject<D>>Collection<Method> fieldGetters(Class<D> type){
  Collection<Method> ret=new LinkedHashSet<>();
  for (  Method method : type.getDeclaredMethods())   if (method.getParameterCount() == 0 && !method.isDefault() && !method.isSynthetic() && !isMetadataGetter(method))   ret.add(method);
  return ret;
}","static <D extends DynamicObject<D>>Collection<Method> fieldGetters(Class<D> type){
  Collection<Method> ret=new LinkedHashSet<>();
  for (  Method method : type.getDeclaredMethods())   if (isGetter(method))   ret.add(method);
  return ret;
}",0.6759581881533101
80442,"private static <D extends DynamicObject<D>>D createIndyProxy(Map map,Class<D> type){
  try {
    Object proxy=proxyCache.computeIfAbsent(type,Instances::createProxy).constructor().invoke(map,type);
    return type.cast(proxy);
  }
 catch (  Throwable t) {
    throw new RuntimeException(t);
  }
}","private static <D extends DynamicObject<D>>D createIndyProxy(Map map,Class<D> type){
  ensureInitialized(type);
  try {
    Object proxy=proxyCache.computeIfAbsent(type,Instances::createProxy).constructor().invoke(map,type);
    return type.cast(proxy);
  }
 catch (  Throwable t) {
    throw new RuntimeException(t);
  }
}",0.9563812600969306
80443,"public void prettyPrint(){
  ClojureStuff.Pprint.invoke(map);
}","public void prettyPrint(){
  ClojureStuff.Pprint.invoke(this);
}",0.9448818897637796
80444,"public String toFormattedString(){
  Writer w=new StringWriter();
  ClojureStuff.Pprint.invoke(map,w);
  return w.toString();
}","public String toFormattedString(){
  Writer w=new StringWriter();
  ClojureStuff.Pprint.invoke(this,w);
  return w.toString();
}",0.9725490196078432
80445,"static synchronized <T extends DynamicObject<T>>void deregisterTag(Class<T> type){
  String tag=EdnSerialization.recordTagCache.get(type);
  fressianWriteHandlers.remove(type);
  fressianReadHandlers.remove(tag);
}","static synchronized <T extends DynamicObject<T>>void deregisterTag(Class<T> type){
  String tag=binaryTagCache.get(type);
  fressianWriteHandlers.remove(type);
  fressianReadHandlers.remove(tag);
}",0.9391727493917276
80446,"static synchronized <T extends DynamicObject<T>>void registerTag(Class<T> type,String tag){
  Handlers.installHandler(fressianWriteHandlers,type,tag,DynamicObject.getFressianWriteHandler(tag,type));
  fressianReadHandlers.putIfAbsent(tag,DynamicObject.getFressianReadHandler(tag,type));
}","static synchronized <T extends DynamicObject<T>>void registerTag(Class<T> type,String tag){
  binaryTagCache.put(type,tag);
  Handlers.installHandler(fressianWriteHandlers,type,tag,DynamicObject.getFressianWriteHandler(tag,type));
  fressianReadHandlers.putIfAbsent(tag,DynamicObject.getFressianReadHandler(tag,type));
}",0.9473684210526316
80447,"static synchronized <T extends DynamicObject<T>>void deregisterTag(Class<T> type){
  FressianSerialization.deregisterTag(type);
  EdnSerialization.deregisterTag(type);
}","static synchronized <T extends DynamicObject<T>>void deregisterTag(Class<T> type){
  EdnSerialization.deregisterTag(type);
  FressianSerialization.deregisterTag(type);
}",0.7633136094674556
80448,"private static Object convertCollectionToJavaTypes(Collection<?> coll,Object empty,Type genericReturnType){
  Object ret=Transient.invoke(empty);
  coll.forEach(o -> ConjBang.invoke(ret,convertCollectionElementToJavaTypes(o,genericReturnType)));
  return Persistent.invoke(ret);
}","private static Object convertCollectionToJavaTypes(Collection<?> coll,Object empty,Type genericReturnType){
  Object ret=Transient.invoke(empty);
  for (  Object o : coll)   ret=ConjBang.invoke(ret,convertCollectionElementToJavaTypes(o,genericReturnType));
  return Persistent.invoke(ret);
}",0.9246935201401052
80449,"private static Object convertMapToClojureTypes(Map<?,?> map){
  Object ret=Transient.invoke(EmptyMap);
  map.forEach((k,v) -> AssocBang.invoke(ret,javaToClojure(k),javaToClojure(v)));
  return Persistent.invoke(ret);
}","private static Object convertMapToClojureTypes(Map<?,?> map){
  Object ret=Transient.invoke(EmptyMap);
  for (  Map.Entry<?,?> entry : map.entrySet())   ret=AssocBang.invoke(ret,javaToClojure(entry.getKey()),javaToClojure(entry.getValue()));
  return Persistent.invoke(ret);
}",0.5101214574898786
80450,"private static Object convertCollectionToClojureTypes(Collection<?> val,Object empty){
  Object ret=Transient.invoke(empty);
  val.forEach(o -> ConjBang.invoke(ret,javaToClojure(o)));
  return Persistent.invoke(ret);
}","private static Object convertCollectionToClojureTypes(Collection<?> val,Object empty){
  Object ret=Transient.invoke(empty);
  for (  Object o : val)   ret=ConjBang.invoke(ret,javaToClojure(o));
  return Persistent.invoke(ret);
}",0.9082774049217002
80451,"Map<String,String> dictionary();","MapSchema dictionary(Map<String,String> dictionary);",0.7380952380952381
80452,"@Test public void listStream(){
  ListSchema listSchema=deserialize(""String_Node_Str"",ListSchema.class);
  List<String> stringList=listSchema.strings();
  List<Integer> collect=stringList.stream().map(x -> x.length()).collect(Collectors.toList());
  assertEquals(3,collect.get(0).intValue());
  assertEquals(3,collect.get(1).intValue());
  assertEquals(5,collect.get(2).intValue());
}","@Test public void listStream(){
  ListSchema listSchema=deserialize(""String_Node_Str"",ListSchema.class);
  List<String> stringList=listSchema.strings();
  List<Integer> collect=stringList.stream().map(x -> x.length()).collect(toList());
  assertEquals(3,collect.get(0).intValue());
  assertEquals(3,collect.get(1).intValue());
  assertEquals(5,collect.get(2).intValue());
}",0.9854689564068692
80453,"static Object unwrapCollectionElements(Object val,Class<?> type,Object empty){
  if (val != null && type.isAssignableFrom(val.getClass())) {
    Iterable<?> iterable=(Iterable<?>)val;
    Object ret=empty;
    ret=TRANSIENT.invoke(ret);
    for (    Object o : iterable)     CONJ_BANG.invoke(ret,unwrapAndAnnotate(o));
    return PERSISTENT.invoke(ret);
  }
  return val;
}","static Object unwrapCollectionElements(Object val,Class<?> type,Object empty){
  if (val != null && type.isAssignableFrom(val.getClass())) {
    Iterable<?> iterable=(Iterable<?>)val;
    Object ret=empty;
    ret=TRANSIENT.invoke(ret);
    for (    Object o : iterable) {
      o=Primitives.maybeUpconvert(o);
      o=unwrapAndAnnotate(o);
      CONJ_BANG.invoke(ret,o);
    }
    return PERSISTENT.invoke(ret);
  }
  return val;
}",0.8720496894409938
80454,"@Test public void listOfStrings(){
  ListSchema listSchema=DynamicObject.deserialize(""String_Node_Str"",ListSchema.class);
  List<String> stringList=listSchema.strings();
  assertEquals(""String_Node_Str"",stringList.get(0));
  assertEquals(""String_Node_Str"",stringList.get(1));
  assertEquals(""String_Node_Str"",stringList.get(2));
}","@Test public void listOfStrings(){
  ListSchema listSchema=deserialize(""String_Node_Str"",ListSchema.class);
  List<String> stringList=listSchema.strings();
  assertEquals(""String_Node_Str"",stringList.get(0));
  assertEquals(""String_Node_Str"",stringList.get(1));
  assertEquals(""String_Node_Str"",stringList.get(2));
}",0.978328173374613
80455,"@Test public void embeddedMap(){
  String edn=""String_Node_Str"";
  MapSchema mapSchema=DynamicObject.deserialize(edn,MapSchema.class);
  assertEquals(""String_Node_Str"",mapSchema.dictionary().get(""String_Node_Str""));
  assertEquals(1,mapSchema.dictionary().size());
}","@Test public void embeddedMap(){
  String edn=""String_Node_Str"";
  MapSchema mapSchema=deserialize(edn,MapSchema.class);
  assertEquals(""String_Node_Str"",mapSchema.dictionary().get(""String_Node_Str""));
  assertEquals(1,mapSchema.dictionary().size());
}",0.972972972972973
80456,"@Test public void setOfStrings(){
  SetSchema setSchema=DynamicObject.deserialize(""String_Node_Str"",SetSchema.class);
  Set<String> stringSet=setSchema.strings();
  assertEquals(3,stringSet.size());
  assertTrue(stringSet.contains(""String_Node_Str""));
  assertTrue(stringSet.contains(""String_Node_Str""));
  assertTrue(stringSet.contains(""String_Node_Str""));
}","@Test public void setOfStrings(){
  SetSchema setSchema=deserialize(""String_Node_Str"",SetSchema.class);
  Set<String> stringSet=setSchema.strings();
  assertEquals(3,stringSet.size());
  assertTrue(stringSet.contains(""String_Node_Str""));
  assertTrue(stringSet.contains(""String_Node_Str""));
  assertTrue(stringSet.contains(""String_Node_Str""));
}",0.9801136363636364
80457,"@Test public void listStream(){
  ListSchema listSchema=DynamicObject.deserialize(""String_Node_Str"",ListSchema.class);
  List<String> stringList=listSchema.strings();
  List<Integer> collect=stringList.stream().map(x -> x.length()).collect(Collectors.toList());
  assertEquals(3,collect.get(0).intValue());
  assertEquals(3,collect.get(1).intValue());
  assertEquals(5,collect.get(2).intValue());
}","@Test public void listStream(){
  ListSchema listSchema=deserialize(""String_Node_Str"",ListSchema.class);
  List<String> stringList=listSchema.strings();
  List<Integer> collect=stringList.stream().map(x -> x.length()).collect(Collectors.toList());
  assertEquals(3,collect.get(0).intValue());
  assertEquals(3,collect.get(1).intValue());
  assertEquals(5,collect.get(2).intValue());
}",0.9820971867007672
80458,"private T assoc(String key,Object value){
  Keyword keyword=Keyword.intern(key);
  IPersistentMap newMap=map.assoc(keyword,value);
  return DynamicObject.wrap(newMap,clazz);
}","private T assoc(String key,Object value){
  Keyword keyword=Keyword.intern(key);
  if (value instanceof DynamicObject)   value=((DynamicObject)value).getMap();
  IPersistentMap newMap=map.assoc(keyword,value);
  return DynamicObject.wrap(newMap,clazz);
}",0.8158508158508159
80459,"private T assocEx(String key,Object value){
  Keyword keyword=Keyword.intern(key);
  IPersistentMap newMap=map.assocEx(keyword,value);
  return DynamicObject.wrap(newMap,clazz);
}","private T assocEx(String key,Object value){
  Keyword keyword=Keyword.intern(key);
  if (value instanceof DynamicObject)   value=((DynamicObject)value).getMap();
  IPersistentMap newMap=map.assocEx(keyword,value);
  return DynamicObject.wrap(newMap,clazz);
}",0.8192219679633868
80460,"@Override public Object invoke(Object proxy,Method method,Object[] args) throws Throwable {
  String methodName=method.getName();
  if (method.getReturnType().equals(clazz))   return assoc(methodName,args[0]);
switch (methodName) {
case ""String_Node_Str"":
    return map;
case ""String_Node_Str"":
  return clazz;
case ""String_Node_Str"":
return assoc((String)args[0],args[1]);
case ""String_Node_Str"":
return assocEx((String)args[0],args[1]);
case ""String_Node_Str"":
return without((String)args[0]);
case ""String_Node_Str"":
return map.toString();
case ""String_Node_Str"":
return map.hashCode();
case ""String_Node_Str"":
Object other=args[0];
if (other instanceof DynamicObject) {
return map.equals(((DynamicObject)other).getMap());
}
 else return method.invoke(map,args);
default :
return getValueFor(method);
}
}","@Override public Object invoke(Object proxy,Method method,Object[] args) throws Throwable {
  String methodName=method.getName();
  if (method.getReturnType().equals(clazz))   return assoc(methodName,args[0]);
switch (methodName) {
case ""String_Node_Str"":
    return map;
case ""String_Node_Str"":
  return clazz;
case ""String_Node_Str"":
return assoc((String)args[0],args[1]);
case ""String_Node_Str"":
return assocEx((String)args[0],args[1]);
case ""String_Node_Str"":
return without((String)args[0]);
case ""String_Node_Str"":
return map.toString();
case ""String_Node_Str"":
return map.hashCode();
case ""String_Node_Str"":
Object other=args[0];
if (other instanceof DynamicObject) return map.equals(((DynamicObject)other).getMap());
 else return method.invoke(map,args);
default :
return getValueFor(method);
}
}",0.9975186104218362
80461,"private JsonValue getRestValue(JsonArray restArray,int colIdx){
  JsonValue obj=restArray.get(colIdx);
  if (obj.getValueType() == ValueType.ARRAY && ((JsonArray)obj).size() > 0)   obj=((JsonArray)obj).get(0);
  return obj;
}","private JsonValue getRestValue(JsonArray restArray,int colIdx){
  return restArray.get(colIdx);
}",0.5714285714285714
80462,"private List<GrRelation> getRelations(String colKey){
  List<GrRelation> rRelations=getRelationColumns().get(colKey);
  if (rRelations == null) {
    rRelations=new ArrayList<GrRelation>();
    int colIdx=getColumnIndex(colKey);
    if (colIdx == -1)     throw new RuntimeException(""String_Node_Str"" + colKey);
    Iterator<JsonValue> it=getDataIterator();
    int rowIdx=-1;
    while (it.hasNext()) {
      rowIdx++;
      JsonObject dataObject=(JsonObject)it.next();
      GrRelation rRelation=null;
      ElementInfo ei=getElementInfo(dataObject,colIdx);
      if (!ei.isNull) {
        RelationInfo ri=getRelationInfo(dataObject,colIdx);
        rRelation=getRelationsById().get(ei.id);
        if (rRelation == null) {
          rRelation=GrAccess.createRelation(this,new GrId(ei.id),new GrId(ri.startNodeId),new GrId(ri.endNodeId),rowIdx);
          GrAccess.setState(rRelation,SyncState.SYNC);
          GrAccess.addChangeListener(getNodeRelationListener(),rRelation);
          getRelationsById().put(ei.id,rRelation);
        }
      }
      if (!rRelations.contains(rRelation))       rRelations.add(rRelation);
    }
    getRelationColumns().put(colKey,rRelations);
    getUnresolvedColumns().remove(colKey);
  }
  return rRelations;
}","private List<GrRelation> getRelations(String colKey){
  List<GrRelation> rRelations=getRelationColumns().get(colKey);
  if (rRelations == null) {
    rRelations=new ArrayList<GrRelation>();
    int colIdx=getColumnIndex(colKey);
    if (colIdx == -1)     throw new RuntimeException(""String_Node_Str"" + colKey);
    Iterator<JsonValue> it=getDataIterator();
    int rowIdx=-1;
    while (it.hasNext()) {
      rowIdx++;
      JsonObject dataObject=(JsonObject)it.next();
      GrRelation rRelation=null;
      ElementInfo ei=getElementInfo(dataObject,colIdx);
      if (!ei.isNull) {
        RelationInfo ri=getRelationInfo(dataObject,colIdx);
        rRelation=getRelationsById().get(ei.id);
        if (rRelation == null) {
          rRelation=GrAccess.createRelation(this,new GrId(ei.id),new GrId(ri.startNodeId),new GrId(ri.endNodeId),rowIdx);
          GrAccess.setState(rRelation,SyncState.SYNC);
          GrAccess.addChangeListener(getNodeRelationListener(),rRelation);
          getRelationsById().put(ei.id,rRelation);
        }
      }
      rRelations.add(rRelation);
    }
    getRelationColumns().put(colKey,rRelations);
    getUnresolvedColumns().remove(colKey);
  }
  return rRelations;
}",0.9824418129848916
80463,"private void addType(List<Class<?>> typeList,boolean noAbstractTypes){
  if (!noAbstractTypes || (!this.type.isInterface() && !Modifier.isAbstract(this.type.getModifiers()) && !this.type.equals(Object.class)))   typeList.add(this.type);
  if (this.next != null)   next.addType(typeList,noAbstractTypes);
}","private void addType(List<Class<?>> typeList,boolean noAbstractTypes){
  if (!noAbstractTypes || isConcrete(this.type))   typeList.add(this.type);
  if (this.next != null)   next.addType(typeList,noAbstractTypes);
}",0.7846153846153846
80464,"private void buildStep(int tmpNodeIdx,boolean listOrArray,CloneInfo cloneInfo,boolean forward){
  FieldMapping fm=this.fieldMappings.get(this.fmIndex);
  Relation matchRel=matchNode.relation().type(fm.getPropertyOrRelationName());
  if (forward)   matchRel=matchRel.out();
 else   matchRel=matchRel.in();
  if (this.step.getMinDistance() != 1)   matchRel=matchRel.minHops(this.step.getMinDistance());
  if (this.step.getMaxDistance() != 1) {
    if (this.step.getMaxDistance() == -1)     matchRel=matchRel.maxHopsUnbound();
 else     matchRel=matchRel.maxHops(this.step.getMaxDistance());
  }
  Class<?> typ;
  CompoundObjectType cType=null;
  if (forward) {
    if (listOrArray) {
      cType=getMappingInfo().getInternalDomainAccess().getFieldComponentType(fm.getClassFieldName());
    }
 else {
      cType=getMappingInfo().getInternalDomainAccess().getConcreteFieldType(fm.getClassFieldName());
    }
    typ=cType.getType();
  }
 else {
    typ=fm.getField().getDeclaringClass();
  }
  boolean isList=typ.equals(Collection.class) || typ.equals(Array.class);
  Step nextStep=null;
  int nextStepIndex=this.stepIndex;
  List<Class<?>> types;
  if (isList) {
    if (forward) {
      nextStep=this.step.createStep(this.step.getDirection(),getMappingInfo().getObjectMappingFor(typ).fieldMappingsIterator().next().getPropertyOrRelationName());
    }
 else {
      nextStep=this.step.createStep(this.step.getDirection(),this.step.getAttributeName());
    }
    types=new ArrayList<Class<?>>();
    types.add(typ);
  }
 else {
    nextStepIndex++;
    if (nextStepIndex <= this.traversalExpression.getSteps().size() - 1)     nextStep=this.traversalExpression.getSteps().get(nextStepIndex);
    if (forward)     types=cType.getTypes(true);
 else     types=getMappingInfo().getCompoundTypesFor(typ);
  }
  if (nextStep == null) {
    if (isValidEndNodeType(types)) {
      this.endNode=new JcNode(this.originalEndNodeName.concat(tmpNodePostPrefix).concat(String.valueOf(tmpNodeIdx)));
      StepClause first=this.getFirst();
      if (first.jcPath != null) {
        String npm=ValueAccess.getName(first.jcPath).concat(tmpNodePostPrefix).concat(String.valueOf(tmpNodeIdx));
        ValueAccess.setName(npm,first.jcPath);
      }
      this.matchNode=matchRel.node(this.endNode).label(this.endNodeLabel);
    }
 else     this.matchNode=null;
  }
 else {
    this.matchNode=matchRel.node();
    if (cloneInfo != null)     this.buildNextClone(tmpNodeIdx,types,isList,cloneInfo);
 else     this.buildNext(tmpNodeIdx,types,isList,nextStep,nextStepIndex);
  }
}","private void buildStep(int tmpNodeIdx,boolean listOrArray,CloneInfo cloneInfo,boolean forward){
  FieldMapping fm=this.fieldMappings.get(this.fmIndex);
  Relation matchRel=matchNode.relation().type(fm.getPropertyOrRelationName());
  if (forward)   matchRel=matchRel.out();
 else   matchRel=matchRel.in();
  if (this.step.getMinDistance() != 1)   matchRel=matchRel.minHops(this.step.getMinDistance());
  if (this.step.getMaxDistance() != 1) {
    if (this.step.getMaxDistance() == -1)     matchRel=matchRel.maxHopsUnbound();
 else     matchRel=matchRel.maxHops(this.step.getMaxDistance());
  }
  Class<?> typ;
  CompoundObjectType cType=null;
  if (forward) {
    if (listOrArray) {
      cType=getMappingInfo().getInternalDomainAccess().getFieldComponentType(fm.getClassFieldName());
    }
 else {
      cType=getMappingInfo().getInternalDomainAccess().getConcreteFieldType(fm.getClassFieldName());
    }
    if (cType != null)     typ=cType.getType();
 else     typ=fm.getFieldType();
  }
 else {
    typ=fm.getField().getDeclaringClass();
  }
  boolean isList=typ.equals(Collection.class) || typ.equals(Array.class);
  Step nextStep=null;
  int nextStepIndex=this.stepIndex;
  List<Class<?>> types;
  if (isList) {
    if (forward) {
      nextStep=this.step.createStep(this.step.getDirection(),getMappingInfo().getObjectMappingFor(typ).fieldMappingsIterator().next().getPropertyOrRelationName());
    }
 else {
      nextStep=this.step.createStep(this.step.getDirection(),this.step.getAttributeName());
    }
    types=new ArrayList<Class<?>>();
    types.add(typ);
  }
 else {
    nextStepIndex++;
    if (nextStepIndex <= this.traversalExpression.getSteps().size() - 1)     nextStep=this.traversalExpression.getSteps().get(nextStepIndex);
    if (forward) {
      if (cType != null)       types=cType.getTypes(true);
 else       if (CompoundObjectType.isConcrete(typ)) {
        types=new ArrayList<Class<?>>();
        types.add(typ);
      }
 else       types=new ArrayList<Class<?>>();
    }
 else     types=getMappingInfo().getCompoundTypesFor(typ);
  }
  if (nextStep == null) {
    if (isValidEndNodeType(types)) {
      this.endNode=new JcNode(this.originalEndNodeName.concat(tmpNodePostPrefix).concat(String.valueOf(tmpNodeIdx)));
      StepClause first=this.getFirst();
      if (first.jcPath != null) {
        String npm=ValueAccess.getName(first.jcPath).concat(tmpNodePostPrefix).concat(String.valueOf(tmpNodeIdx));
        ValueAccess.setName(npm,first.jcPath);
      }
      this.matchNode=matchRel.node(this.endNode).label(this.endNodeLabel);
    }
 else     this.matchNode=null;
  }
 else {
    this.matchNode=matchRel.node();
    if (cloneInfo != null)     this.buildNextClone(tmpNodeIdx,types,isList,cloneInfo);
 else     this.buildNext(tmpNodeIdx,types,isList,nextStep,nextStepIndex);
  }
}",0.9427772600186394
80465,"@Test public void testGregSample(){
  List<JcError> errs;
  IDomainAccess da=DomainAccessFactory.createDomainAccess(dbAccess,domainName);
  initDomain(da);
  conditionallyCreateEnv_App(da);
  DomainQuery q=da.createQuery();
  DomainObjectMatch<Env> envMatch=q.createMatch(Env.class);
  DomainObjectMatch<App> appMatch=q.createMatch(App.class);
  q.WHERE(envMatch.atttribute(""String_Node_Str"")).EQUALS(""String_Node_Str"");
  q.WHERE(appMatch.atttribute(""String_Node_Str"")).EQUALS(""String_Node_Str"");
  DomainObjectMatch<BIStats> statsMatch=q.createMatch(BIStats.class);
  DomainObjectMatch<Env> statEnv=q.TRAVERSE_FROM(statsMatch).FORTH(""String_Node_Str"").TO(Env.class);
  DomainObjectMatch<App> statApp=q.TRAVERSE_FROM(statsMatch).FORTH(""String_Node_Str"").TO(App.class);
  DomainObjectMatch<BIStats> n2bChainedMatch=q.SELECT_FROM(statsMatch).ELEMENTS(q.WHERE(statEnv).CONTAINS(envMatch),q.WHERE(statApp).CONTAINS(appMatch));
  DomainQueryResult result=q.execute();
  List<BIStats> n2bChained=result.resultOf(n2bChainedMatch);
  Env env=result.resultOf(envMatch).get(0);
  App app=result.resultOf(appMatch).get(0);
  BIStats newStat=new BIStats();
  newStat.setMeasuredIn(env);
  newStat.setMeasuredFor(app);
  if (n2bChained.size() > 0) {
    BIStats n2bC=n2bChained.get(0);
    n2bC.setMeasuredFor(null);
    n2bC.setMeasuredIn(null);
    newStat.setFollows(n2bC);
  }
  errs=da.store(newStat);
  assertTrue(errs.isEmpty());
  return;
}","public void testGregSample(int count){
  List<JcError> errs;
  IDomainAccess da=DomainAccessFactory.createDomainAccess(dbAccess,domainName);
  conditionallyCreateEnv_App(da);
  DomainQuery q=da.createQuery();
  DomainObjectMatch<Env> envMatch=q.createMatch(Env.class);
  DomainObjectMatch<App> appMatch=q.createMatch(App.class);
  q.WHERE(envMatch.atttribute(""String_Node_Str"")).EQUALS(""String_Node_Str"");
  q.WHERE(appMatch.atttribute(""String_Node_Str"")).EQUALS(""String_Node_Str"");
  DomainObjectMatch<BIStats> statsMatch=q.createMatch(BIStats.class);
  DomainObjectMatch<Env> statEnv=q.TRAVERSE_FROM(statsMatch).FORTH(""String_Node_Str"").TO(Env.class);
  DomainObjectMatch<App> statApp=q.TRAVERSE_FROM(statsMatch).FORTH(""String_Node_Str"").TO(App.class);
  DomainObjectMatch<BIStats> n2bChainedMatch=q.SELECT_FROM(statsMatch).ELEMENTS(q.WHERE(statEnv).CONTAINS(envMatch),q.WHERE(statApp).CONTAINS(appMatch));
  DomainQueryResult result=q.execute();
  List<BIStats> n2bChained=result.resultOf(n2bChainedMatch);
  Env env=result.resultOf(envMatch).get(0);
  App app=result.resultOf(appMatch).get(0);
  BIStats newStat=new BIStats();
  newStat.setMeasuredIn(env);
  newStat.setMeasuredFor(app);
  if (n2bChained.size() > 0) {
    BIStats n2bC=n2bChained.get(0);
    n2bC.setMeasuredFor(null);
    n2bC.setMeasuredIn(null);
    newStat.setFollows(n2bC);
  }
  errs=da.store(newStat);
  assertTrue(errs.isEmpty());
  if (count > 0)   testGregSample(count - 1);
  return;
}",0.9727867723045126
80466,"@SuppressWarnings(""String_Node_Str"") private <T>SurrogateContent checkForSurrogates(FillModelContext<T> context,FieldMapping fm,FieldKind fieldKind,CompoundObjectType compoundType){
  SurrogateContent ret=new SurrogateContent();
  DomainState ds=domainAccessHandler.getDomainState();
  if (fieldKind == FieldKind.COLLECTION) {
    if (context.parentObject instanceof iot.jcypher.domain.mapping.surrogate.Collection) {
      ret.collection=((iot.jcypher.domain.mapping.surrogate.Collection)context.parentObject).getContent();
    }
    if (ret.collection == null) {
      String classFieldName=fm.getClassFieldName();
      ret.collection=(Collection<Object>)domainAccessHandler.createInstance(MappingUtil.internalDomainAccess.get().getConcreteFieldType(classFieldName).getType());
      ret.compoundType=MappingUtil.internalDomainAccess.get().getFieldComponentType(classFieldName);
      if (context.parentObject instanceof iot.jcypher.domain.mapping.surrogate.Collection) {
        ((iot.jcypher.domain.mapping.surrogate.Collection)context.parentObject).setContent(ret.collection);
        ds.getSurrogateState().addOriginal2Surrogate(ret.collection,(iot.jcypher.domain.mapping.surrogate.Collection)context.parentObject);
      }
    }
  }
 else   if (fieldKind == FieldKind.ARRAY) {
    if (context.parentObject instanceof iot.jcypher.domain.mapping.surrogate.Array) {
      ret.array=((iot.jcypher.domain.mapping.surrogate.Array)context.parentObject).getListContent();
    }
    if (ret.array == null) {
      String classFieldName=fm.getClassFieldName();
      ret.array=new ObservableList<Object>();
      ret.compoundType=MappingUtil.internalDomainAccess.get().getFieldComponentType(classFieldName);
      if (context.parentObject instanceof iot.jcypher.domain.mapping.surrogate.Array) {
        ((iot.jcypher.domain.mapping.surrogate.Array)context.parentObject).setListContent(ret.array);
      }
    }
  }
 else   if (fieldKind == FieldKind.MAP) {
    if (context.parentObject instanceof iot.jcypher.domain.mapping.surrogate.Map) {
      ret.map=((iot.jcypher.domain.mapping.surrogate.Map)context.parentObject).getContent();
    }
    if (ret.map == null) {
      String classFieldName=fm.getClassFieldName();
      ret.map=(Map<Object,Object>)domainAccessHandler.createInstance(MappingUtil.internalDomainAccess.get().getConcreteFieldType(classFieldName).getType());
      ret.compoundType=MappingUtil.internalDomainAccess.get().getFieldComponentType(classFieldName);
      if (context.parentObject instanceof iot.jcypher.domain.mapping.surrogate.Map) {
        ((iot.jcypher.domain.mapping.surrogate.Map)context.parentObject).setContent(ret.map);
        ds.getSurrogateState().addOriginal2Surrogate(ret.map,(iot.jcypher.domain.mapping.surrogate.Map)context.parentObject);
      }
    }
  }
  return ret;
}","@SuppressWarnings(""String_Node_Str"") private <T>SurrogateContent checkForSurrogates(FillModelContext<T> context,FieldMapping fm,FieldKind fieldKind,CompoundObjectType compoundType){
  SurrogateContent ret=new SurrogateContent();
  DomainState ds=domainAccessHandler.getDomainState();
  if (fieldKind == FieldKind.COLLECTION) {
    if (context.parentObject instanceof iot.jcypher.domain.mapping.surrogate.Collection) {
      ret.collection=((iot.jcypher.domain.mapping.surrogate.Collection)context.parentObject).getContent();
    }
    String classFieldName=fm.getClassFieldName();
    ret.compoundType=MappingUtil.internalDomainAccess.get().getFieldComponentType(classFieldName);
    if (ret.collection == null) {
      ret.collection=(Collection<Object>)domainAccessHandler.createInstance(MappingUtil.internalDomainAccess.get().getConcreteFieldType(classFieldName).getType());
      if (context.parentObject instanceof iot.jcypher.domain.mapping.surrogate.Collection) {
        ((iot.jcypher.domain.mapping.surrogate.Collection)context.parentObject).setContent(ret.collection);
        ds.getSurrogateState().addOriginal2Surrogate(ret.collection,(iot.jcypher.domain.mapping.surrogate.Collection)context.parentObject);
      }
    }
  }
 else   if (fieldKind == FieldKind.ARRAY) {
    if (context.parentObject instanceof iot.jcypher.domain.mapping.surrogate.Array) {
      ret.array=((iot.jcypher.domain.mapping.surrogate.Array)context.parentObject).getListContent();
    }
    String classFieldName=fm.getClassFieldName();
    ret.compoundType=MappingUtil.internalDomainAccess.get().getFieldComponentType(classFieldName);
    if (ret.array == null) {
      ret.array=new ObservableList<Object>();
      if (context.parentObject instanceof iot.jcypher.domain.mapping.surrogate.Array) {
        ((iot.jcypher.domain.mapping.surrogate.Array)context.parentObject).setListContent(ret.array);
      }
    }
  }
 else   if (fieldKind == FieldKind.MAP) {
    if (context.parentObject instanceof iot.jcypher.domain.mapping.surrogate.Map) {
      ret.map=((iot.jcypher.domain.mapping.surrogate.Map)context.parentObject).getContent();
    }
    String classFieldName=fm.getClassFieldName();
    ret.compoundType=MappingUtil.internalDomainAccess.get().getFieldComponentType(classFieldName);
    if (ret.map == null) {
      ret.map=(Map<Object,Object>)domainAccessHandler.createInstance(MappingUtil.internalDomainAccess.get().getConcreteFieldType(classFieldName).getType());
      if (context.parentObject instanceof iot.jcypher.domain.mapping.surrogate.Map) {
        ((iot.jcypher.domain.mapping.surrogate.Map)context.parentObject).setContent(ret.map);
        ds.getSurrogateState().addOriginal2Surrogate(ret.map,(iot.jcypher.domain.mapping.surrogate.Map)context.parentObject);
      }
    }
  }
  return ret;
}",0.8387326450694197
80467,"@BeforeClass public static void before(){
  domainName=""String_Node_Str"";
  Properties props=new Properties();
  props.setProperty(DBProperties.SERVER_ROOT_URI,""String_Node_Str"");
  props.setProperty(DBProperties.DATABASE_DIR,""String_Node_Str"");
  dbAccess=DBAccessFactory.createDBAccess(DBType.REMOTE,props);
  Population population=new Population();
  storedDomainObjects=population.createPopulation();
  QueriesPrintObserver.addOutputStream(System.out);
  QueriesPrintObserver.addToEnabledQueries(QueryToObserve.DOMAIN_INFO,ContentToObserve.CYPHER);
  QueriesPrintObserver.addToEnabledQueries(QueryToObserve.DOM_QUERY,ContentToObserve.CYPHER);
  QueriesPrintObserver.addToEnabledQueries(QueryToObserve.CLOSURE_QUERY,ContentToObserve.CYPHER);
  initDB(Locking.OPTIMISTIC);
}","@BeforeClass public static void before(){
  domainName=""String_Node_Str"";
  Properties props=new Properties();
  props.setProperty(DBProperties.SERVER_ROOT_URI,""String_Node_Str"");
  props.setProperty(DBProperties.DATABASE_DIR,""String_Node_Str"");
  dbAccess=DBAccessFactory.createDBAccess(DBType.IN_MEMORY,props);
  Population population=new Population();
  storedDomainObjects=population.createPopulation();
  QueriesPrintObserver.addOutputStream(System.out);
  QueriesPrintObserver.addToEnabledQueries(QueryToObserve.DOMAIN_INFO,ContentToObserve.CYPHER);
  QueriesPrintObserver.addToEnabledQueries(QueryToObserve.DOM_QUERY,ContentToObserve.CYPHER);
  QueriesPrintObserver.addToEnabledQueries(QueryToObserve.CLOSURE_QUERY,ContentToObserve.CYPHER);
  initDB(Locking.OPTIMISTIC);
}",0.9916398713826368
80468,"@Test public void replayQuery_01(){
  String qCypher;
  Locking lockingStrategy=Locking.OPTIMISTIC;
  IDomainAccess da1=DomainAccessFactory.createDomainAccess(dbAccess,domainName).setLockingStrategy(lockingStrategy);
  Person a_smith=ConcurrencyTest.findPerson(da1,""String_Node_Str"",""String_Node_Str"");
  Person j_smith1=ConcurrencyTest.findPerson(da1,""String_Node_Str"",""String_Node_Str"");
  IDomainAccess da2=DomainAccessFactory.createDomainAccess(dbAccess,domainName).setLockingStrategy(lockingStrategy);
  Person j_smith2=ConcurrencyTest.findPerson(da2,""String_Node_Str"",""String_Node_Str"");
  PoBox poBox=new PoBox();
  poBox.setNumber(12345);
  List<PointOfContact> pocs=j_smith2.getPointsOfContact();
  pocs.add(poBox);
  List<JcError> errors=da2.store(j_smith2);
  assertTrue(errors.isEmpty());
  if (errors.size() > 0) {
    printErrors(errors);
  }
  String domModel2=((IIntDomainAccess)da2).getInternalDomainAccess().domainModelAsString();
  String domModel1=((IIntDomainAccess)da1).getInternalDomainAccess().domainModelAsString();
  assertFalse(domModel2.equals(domModel1));
  Person j_smith=ConcurrencyTest.findPerson(da1,""String_Node_Str"",""String_Node_Str"");
  String domModel11=((IIntDomainAccess)da1).getInternalDomainAccess().domainModelAsString();
  assertEquals(domModel2,domModel11);
  return;
}","@Test public void replayQuery_01(){
  String qCypher;
  Locking lockingStrategy=Locking.OPTIMISTIC;
  IDomainAccess da1=DomainAccessFactory.createDomainAccess(dbAccess,domainName).setLockingStrategy(lockingStrategy);
  Person a_smith=ConcurrencyTest.findPerson(da1,""String_Node_Str"",""String_Node_Str"");
  Person j_smith1=ConcurrencyTest.findPerson(da1,""String_Node_Str"",""String_Node_Str"");
  IDomainAccess da2=DomainAccessFactory.createDomainAccess(dbAccess,domainName).setLockingStrategy(lockingStrategy);
  Person j_smith2=ConcurrencyTest.findPerson(da2,""String_Node_Str"",""String_Node_Str"");
  PoBox poBox=new PoBox();
  poBox.setNumber(12345);
  List<PointOfContact> pocs=j_smith2.getPointsOfContact();
  pocs.add(poBox);
  List<JcError> errors=da2.store(j_smith2);
  assertTrue(errors.isEmpty());
  if (errors.size() > 0) {
    printErrors(errors);
  }
  String domModel2=((IIntDomainAccess)da2).getInternalDomainAccess().domainModelAsString();
  String domModel1=((IIntDomainAccess)da1).getInternalDomainAccess().domainModelAsString();
  assertFalse(domModel2.equals(domModel1));
  IDomainAccess da3=DomainAccessFactory.createDomainAccess(dbAccess,domainName).setLockingStrategy(lockingStrategy);
  Person j_smithTemp=ConcurrencyTest.findPerson(da3,""String_Node_Str"",""String_Node_Str"");
  assertTrue(j_smith1.getPointsOfContact().size() == 4);
  assertTrue(j_smithTemp.getPointsOfContact().size() == 5);
  assertTrue(j_smithTemp.getPointsOfContact().get(4) instanceof PoBox);
  assertTrue(((PoBox)j_smithTemp.getPointsOfContact().get(4)).getNumber() == 12345);
  Person j_smith=ConcurrencyTest.findPerson(da1,""String_Node_Str"",""String_Node_Str"");
  String domModel11=((IIntDomainAccess)da1).getInternalDomainAccess().domainModelAsString();
  assertEquals(domModel2,domModel11);
  assertTrue(j_smith1 == j_smith);
  assertTrue(j_smith.getPointsOfContact().size() == 5);
  assertTrue(j_smith.getPointsOfContact().get(4) instanceof PoBox);
  assertTrue(((PoBox)j_smith.getPointsOfContact().get(4)).getNumber() == 12345);
  return;
}",0.7845832088437407
80469,"private List<IClause> createDomainInfoStartClause(JcNode info){
  List<IClause> ret=new ArrayList<IClause>();
  ret.add(MERGE.node(info).label(DomainInfoNodeLabel).property(DomainInfoNameProperty).value(DomainAccessHandler.this.domainName));
  ret.add(ON_CREATE.SET(info.property(DomainInfoVersionProperty)).to(0));
  ret.add(ON_CREATE.SET(info.property(DomainInfoModelVersionProperty)).to(0));
  return ret;
}","private List<IClause> createDomainInfoStartClause(JcNode info){
  String pLab=CurrentDomain.label.get();
  CurrentDomain.setDomainLabel(null);
  List<IClause> ret=new ArrayList<IClause>();
  try {
    ret.add(MERGE.node(info).label(DomainInfoNodeLabel).property(DomainInfoNameProperty).value(DomainAccessHandler.this.domainName));
    ret.add(ON_CREATE.SET(info.property(DomainInfoVersionProperty)).to(0));
    ret.add(ON_CREATE.SET(info.property(DomainInfoModelVersionProperty)).to(0));
  }
  finally {
    CurrentDomain.setDomainLabel(pLab);
  }
  return ret;
}",0.8180883864337102
80470,"List<JcError> store(List<Object> domainObjects){
  UpdateContext context;
  InternalDomainAccess internalAccess=null;
  try {
    internalAccess=MappingUtil.internalDomainAccess.get();
    MappingUtil.internalDomainAccess.set(getInternalDomainAccess());
    context=this.updateLocalGraph(domainObjects);
  }
  finally {
    if (internalAccess != null)     MappingUtil.internalDomainAccess.set(internalAccess);
 else     MappingUtil.internalDomainAccess.remove();
  }
  List<JcError> errors=context.graph.store();
  DomainState ds=getDomainState();
  if (errors.isEmpty()) {
    for (    IRelation relat : context.relationsToRemove) {
      ds.removeRelation(relat);
    }
    Iterator<Entry<Object,GrNode>> it=context.domObj2Node.entrySet().iterator();
    while (it.hasNext()) {
      Entry<Object,GrNode> entry=it.next();
      ds.add_Id2Object(entry.getKey(),entry.getValue().getId(),ResolutionDepth.DEEP);
    }
    for (    DomRelation2ResultRelation d2r : context.domRelation2Relations) {
      ds.add_Id2Relation(d2r.domRelation,d2r.resultRelation.getId());
    }
  }
  return errors;
}","List<JcError> store(List<?> domainObjects){
  UpdateContext context;
  InternalDomainAccess internalAccess=null;
  try {
    internalAccess=MappingUtil.internalDomainAccess.get();
    MappingUtil.internalDomainAccess.set(getInternalDomainAccess());
    context=this.updateLocalGraph(domainObjects);
  }
  finally {
    if (internalAccess != null)     MappingUtil.internalDomainAccess.set(internalAccess);
 else     MappingUtil.internalDomainAccess.remove();
  }
  List<JcError> errors=context.graph.store();
  DomainState ds=getDomainState();
  if (errors.isEmpty()) {
    for (    IRelation relat : context.relationsToRemove) {
      ds.removeRelation(relat);
    }
    Iterator<Entry<Object,GrNode>> it=context.domObj2Node.entrySet().iterator();
    while (it.hasNext()) {
      Entry<Object,GrNode> entry=it.next();
      ds.add_Id2Object(entry.getKey(),entry.getValue().getId(),ResolutionDepth.DEEP);
    }
    for (    DomRelation2ResultRelation d2r : context.domRelation2Relations) {
      ds.add_Id2Relation(d2r.domRelation,d2r.resultRelation.getId());
    }
  }
  return errors;
}",0.9967904630903256
80471,"private UpdateContext updateLocalGraph(List<Object> domainObjects){
  UpdateContext context=new UpdateContext();
  new ClosureCalculator().calculateClosure(domainObjects,context);
  context.surrogateChangeLog.applyChanges();
  Graph graph=null;
  Object domainObject;
  Map<Integer,QueryNode2ResultNode> nodeIndexMap=null;
  List<IClause> clauses=null;
  List<IClause> removeStartClauses=null;
  List<IClause> removeClauses=null;
  DomainState ds=this.getDomainState();
  for (int i=0; i < context.domainObjects.size(); i++) {
    domainObject=context.domainObjects.get(i);
    Long id=ds.getIdFrom_Object2IdMap(domainObject);
    if (id != null) {
      JcNode n=new JcNode(NodePrefix.concat(String.valueOf(i)));
      QueryNode2ResultNode n2n=new QueryNode2ResultNode();
      n2n.queryNode=n;
      if (nodeIndexMap == null)       nodeIndexMap=new HashMap<Integer,QueryNode2ResultNode>();
      nodeIndexMap.put(new Integer(i),n2n);
      if (clauses == null)       clauses=new ArrayList<IClause>();
      clauses.add(START.node(n).byId(id.longValue()));
    }
  }
  Map<Integer,QueryRelation2ResultRelation> relationIndexMap=null;
  for (int i=0; i < context.relations.size(); i++) {
    IRelation relat=context.relations.get(i);
    Long id=ds.getFrom_Relation2IdMap(relat);
    if (id != null) {
      JcRelation r=new JcRelation(RelationPrefix.concat(String.valueOf(i)));
      QueryRelation2ResultRelation r2r=new QueryRelation2ResultRelation();
      r2r.queryRelation=r;
      if (relationIndexMap == null)       relationIndexMap=new HashMap<Integer,QueryRelation2ResultRelation>();
      relationIndexMap.put(new Integer(i),r2r);
      clauses.add(START.relation(r).byId(id.longValue()));
    }
  }
  if (context.relationsToRemove.size() > 0) {
    removeStartClauses=new ArrayList<IClause>();
    removeClauses=new ArrayList<IClause>();
    for (int i=0; i < context.relationsToRemove.size(); i++) {
      IRelation relat=context.relationsToRemove.get(i);
      Long id=ds.getFrom_Relation2IdMap(relat);
      JcRelation r=new JcRelation(RelationPrefix.concat(String.valueOf(i)));
      removeStartClauses.add(START.relation(r).byId(id.longValue()));
      removeClauses.add(DO.DELETE(r));
    }
  }
  if (context.domainObjectsToRemove.size() > 0) {
    if (removeStartClauses == null) {
      removeStartClauses=new ArrayList<IClause>();
      removeClauses=new ArrayList<IClause>();
    }
    for (int i=0; i < context.domainObjectsToRemove.size(); i++) {
      Object dobj=context.domainObjectsToRemove.get(i);
      Long id=ds.getIdFrom_Object2IdMap(dobj);
      JcNode n=new JcNode(NodePrefix.concat(String.valueOf(i)));
      removeStartClauses.add(START.node(n).byId(id.longValue()));
      removeClauses.add(DO.DELETE(n));
    }
  }
  if (clauses != null || removeStartClauses != null) {
    JcQuery query;
    List<JcQuery> queries=new ArrayList<JcQuery>();
    if (clauses != null) {
      clauses.add(RETURN.ALL());
      IClause[] clausesArray=clauses.toArray(new IClause[clauses.size()]);
      query=new JcQuery();
      query.setClauses(clausesArray);
      queries.add(query);
    }
    if (removeStartClauses != null) {
      removeStartClauses.addAll(removeClauses);
      query=new JcQuery();
      query.setClauses(removeStartClauses.toArray(new IClause[removeStartClauses.size()]));
      queries.add(query);
    }
    List<JcQueryResult> results=this.dbAccess.execute(queries);
    List<JcError> errors=Util.collectErrors(results);
    if (errors.size() > 0) {
      throw new JcResultException(errors);
    }
    if (clauses != null) {
      JcQueryResult result=results.get(0);
      graph=result.getGraph();
      GrAccess.setDBAccess(this.dbAccess,graph);
      if (nodeIndexMap != null) {
        Iterator<Entry<Integer,QueryNode2ResultNode>> nit=nodeIndexMap.entrySet().iterator();
        while (nit.hasNext()) {
          Entry<Integer,QueryNode2ResultNode> entry=nit.next();
          entry.getValue().resultNode=result.resultOf(entry.getValue().queryNode).get(0);
        }
      }
      if (relationIndexMap != null) {
        Iterator<Entry<Integer,QueryRelation2ResultRelation>> rit=relationIndexMap.entrySet().iterator();
        while (rit.hasNext()) {
          Entry<Integer,QueryRelation2ResultRelation> entry=rit.next();
          entry.getValue().resultRelation=result.resultOf(entry.getValue().queryRelation).get(0);
        }
      }
    }
  }
  if (graph == null)   graph=Graph.create(this.dbAccess);
  context.domObj2Node=new HashMap<Object,GrNode>(context.domainObjects.size());
  context.domRelation2Relations=new ArrayList<DomRelation2ResultRelation>();
  for (int i=0; i < context.domainObjects.size(); i++) {
    GrNode rNode=null;
    if (nodeIndexMap != null && nodeIndexMap.get(i) != null) {
      rNode=nodeIndexMap.get(i).resultNode;
    }
    if (rNode == null)     rNode=graph.createNode();
    context.domObj2Node.put(context.domainObjects.get(i),rNode);
    updateGraphFromObject(context.domainObjects.get(i),rNode);
  }
  for (int i=0; i < context.relations.size(); i++) {
    GrRelation rRelation=null;
    if (relationIndexMap != null && relationIndexMap.get(i) != null) {
      rRelation=relationIndexMap.get(i).resultRelation;
    }
    if (rRelation == null) {
      IRelation relat=context.relations.get(i);
      rRelation=graph.createRelation(relat.getType(),context.domObj2Node.get(relat.getStart()),context.domObj2Node.get(relat.getEnd()));
      DomRelation2ResultRelation d2r=new DomRelation2ResultRelation();
      d2r.domRelation=relat;
      d2r.resultRelation=rRelation;
      context.domRelation2Relations.add(d2r);
    }
    updateGraphFromRelation(context.relations.get(i),rRelation);
  }
  context.graph=graph;
  return context;
}","private UpdateContext updateLocalGraph(List<?> domainObjects){
  UpdateContext context=new UpdateContext();
  new ClosureCalculator().calculateClosure(domainObjects,context);
  context.surrogateChangeLog.applyChanges();
  Graph graph=null;
  Object domainObject;
  Map<Integer,QueryNode2ResultNode> nodeIndexMap=null;
  List<IClause> clauses=null;
  List<IClause> removeStartClauses=null;
  List<IClause> removeClauses=null;
  DomainState ds=this.getDomainState();
  for (int i=0; i < context.domainObjects.size(); i++) {
    domainObject=context.domainObjects.get(i);
    Long id=ds.getIdFrom_Object2IdMap(domainObject);
    if (id != null) {
      JcNode n=new JcNode(NodePrefix.concat(String.valueOf(i)));
      QueryNode2ResultNode n2n=new QueryNode2ResultNode();
      n2n.queryNode=n;
      if (nodeIndexMap == null)       nodeIndexMap=new HashMap<Integer,QueryNode2ResultNode>();
      nodeIndexMap.put(new Integer(i),n2n);
      if (clauses == null)       clauses=new ArrayList<IClause>();
      clauses.add(START.node(n).byId(id.longValue()));
    }
  }
  Map<Integer,QueryRelation2ResultRelation> relationIndexMap=null;
  for (int i=0; i < context.relations.size(); i++) {
    IRelation relat=context.relations.get(i);
    Long id=ds.getFrom_Relation2IdMap(relat);
    if (id != null) {
      JcRelation r=new JcRelation(RelationPrefix.concat(String.valueOf(i)));
      QueryRelation2ResultRelation r2r=new QueryRelation2ResultRelation();
      r2r.queryRelation=r;
      if (relationIndexMap == null)       relationIndexMap=new HashMap<Integer,QueryRelation2ResultRelation>();
      relationIndexMap.put(new Integer(i),r2r);
      clauses.add(START.relation(r).byId(id.longValue()));
    }
  }
  if (context.relationsToRemove.size() > 0) {
    removeStartClauses=new ArrayList<IClause>();
    removeClauses=new ArrayList<IClause>();
    for (int i=0; i < context.relationsToRemove.size(); i++) {
      IRelation relat=context.relationsToRemove.get(i);
      Long id=ds.getFrom_Relation2IdMap(relat);
      JcRelation r=new JcRelation(RelationPrefix.concat(String.valueOf(i)));
      removeStartClauses.add(START.relation(r).byId(id.longValue()));
      removeClauses.add(DO.DELETE(r));
    }
  }
  if (context.domainObjectsToRemove.size() > 0) {
    if (removeStartClauses == null) {
      removeStartClauses=new ArrayList<IClause>();
      removeClauses=new ArrayList<IClause>();
    }
    for (int i=0; i < context.domainObjectsToRemove.size(); i++) {
      Object dobj=context.domainObjectsToRemove.get(i);
      Long id=ds.getIdFrom_Object2IdMap(dobj);
      JcNode n=new JcNode(NodePrefix.concat(String.valueOf(i)));
      removeStartClauses.add(START.node(n).byId(id.longValue()));
      removeClauses.add(DO.DELETE(n));
    }
  }
  if (clauses != null || removeStartClauses != null) {
    JcQuery query;
    List<JcQuery> queries=new ArrayList<JcQuery>();
    if (clauses != null) {
      clauses.add(RETURN.ALL());
      IClause[] clausesArray=clauses.toArray(new IClause[clauses.size()]);
      query=new JcQuery();
      query.setClauses(clausesArray);
      queries.add(query);
    }
    if (removeStartClauses != null) {
      removeStartClauses.addAll(removeClauses);
      query=new JcQuery();
      query.setClauses(removeStartClauses.toArray(new IClause[removeStartClauses.size()]));
      queries.add(query);
    }
    List<JcQueryResult> results=this.dbAccess.execute(queries);
    List<JcError> errors=Util.collectErrors(results);
    if (errors.size() > 0) {
      throw new JcResultException(errors);
    }
    if (clauses != null) {
      JcQueryResult result=results.get(0);
      graph=result.getGraph();
      GrAccess.setDBAccess(this.dbAccess,graph);
      if (nodeIndexMap != null) {
        Iterator<Entry<Integer,QueryNode2ResultNode>> nit=nodeIndexMap.entrySet().iterator();
        while (nit.hasNext()) {
          Entry<Integer,QueryNode2ResultNode> entry=nit.next();
          entry.getValue().resultNode=result.resultOf(entry.getValue().queryNode).get(0);
        }
      }
      if (relationIndexMap != null) {
        Iterator<Entry<Integer,QueryRelation2ResultRelation>> rit=relationIndexMap.entrySet().iterator();
        while (rit.hasNext()) {
          Entry<Integer,QueryRelation2ResultRelation> entry=rit.next();
          entry.getValue().resultRelation=result.resultOf(entry.getValue().queryRelation).get(0);
        }
      }
    }
  }
  if (graph == null)   graph=Graph.create(this.dbAccess);
  context.domObj2Node=new HashMap<Object,GrNode>(context.domainObjects.size());
  context.domRelation2Relations=new ArrayList<DomRelation2ResultRelation>();
  for (int i=0; i < context.domainObjects.size(); i++) {
    GrNode rNode=null;
    if (nodeIndexMap != null && nodeIndexMap.get(i) != null) {
      rNode=nodeIndexMap.get(i).resultNode;
    }
    if (rNode == null)     rNode=graph.createNode();
    context.domObj2Node.put(context.domainObjects.get(i),rNode);
    updateGraphFromObject(context.domainObjects.get(i),rNode);
  }
  for (int i=0; i < context.relations.size(); i++) {
    GrRelation rRelation=null;
    if (relationIndexMap != null && relationIndexMap.get(i) != null) {
      rRelation=relationIndexMap.get(i).resultRelation;
    }
    if (rRelation == null) {
      IRelation relat=context.relations.get(i);
      rRelation=graph.createRelation(relat.getType(),context.domObj2Node.get(relat.getStart()),context.domObj2Node.get(relat.getEnd()));
      DomRelation2ResultRelation d2r=new DomRelation2ResultRelation();
      d2r.domRelation=relat;
      d2r.resultRelation=rRelation;
      context.domRelation2Relations.add(d2r);
    }
    updateGraphFromRelation(context.relations.get(i),rRelation);
  }
  context.graph=graph;
  return context;
}",0.99938816537016
80472,"private void calculateClosure(List<Object> domainObjects,UpdateContext context){
  for (  Object domainObject : domainObjects) {
    recursiveCalculateClosure(domainObject,null,context,false);
  }
}","private void calculateClosure(List<?> domainObjects,UpdateContext context){
  for (  Object domainObject : domainObjects) {
    recursiveCalculateClosure(domainObject,null,context,false);
  }
}",0.9820971867007672
80473,"@BeforeClass public static void before(){
  Properties props=new Properties();
  props.setProperty(DBProperties.SERVER_ROOT_URI,""String_Node_Str"");
  props.setProperty(DBProperties.DATABASE_DIR,""String_Node_Str"");
  dbAccess=DBAccessFactory.createDBAccess(DBType.IN_MEMORY,props);
}","@BeforeClass public static void before(){
  Properties props=new Properties();
  props.setProperty(DBProperties.SERVER_ROOT_URI,""String_Node_Str"");
  props.setProperty(DBProperties.DATABASE_DIR,""String_Node_Str"");
  dbAccess=DBAccessFactory.createDBAccess(DBType.IN_MEMORY,props);
  List<JcError> errors=dbAccess.clearDatabase();
  if (errors.size() > 0) {
    printErrors(errors);
    throw new JcResultException(errors);
  }
}",0.7943661971830986
80474,"private void queryDB_01(){
  JcQueryResult result;
  String resultString;
  String testId;
  setDoPrint(true);
  setDoAssert(true);
  TestDataReader tdr=new TestDataReader(""String_Node_Str"");
  JcNode movie=new JcNode(""String_Node_Str"");
  JcNode n=new JcNode(""String_Node_Str"");
  JcRelation r=new JcRelation(""String_Node_Str"");
  JcQuery query=new JcQuery();
  query.setClauses(new IClause[]{MATCH.node(movie).label(""String_Node_Str"").property(""String_Node_Str"").value(""String_Node_Str""),RETURN.value(movie)});
  result=dbAccess.execute(query);
  resultString=Util.writePretty(result.getJsonResult());
  print(resultString);
  testId=""String_Node_Str"";
  assertQuery(testId,resultString,tdr.getTestData(testId));
  query=new JcQuery();
  query.setClauses(new IClause[]{MATCH.node(n).relation(r).out().node(),RETURN.ALL()});
  result=dbAccess.execute(query);
  resultString=Util.writePretty(result.getJsonResult());
  print(resultString);
  testId=""String_Node_Str"";
  return;
}","private void queryDB_01(){
  JcQueryResult result;
  String resultString;
  String testId;
  setDoPrint(true);
  setDoAssert(true);
  TestDataReader tdr=new TestDataReader(""String_Node_Str"");
  JcNode movie=new JcNode(""String_Node_Str"");
  JcNode n=new JcNode(""String_Node_Str"");
  JcRelation r=new JcRelation(""String_Node_Str"");
  JcQuery query=new JcQuery();
  query.setClauses(new IClause[]{MATCH.node(movie).label(""String_Node_Str"").property(""String_Node_Str"").value(""String_Node_Str""),RETURN.value(movie)});
  result=dbAccess.execute(query);
  resultString=Util.writePretty(result.getJsonResult());
  print(resultString);
  testId=""String_Node_Str"";
  assertQuery(testId,resultString,tdr.getTestData(testId));
  query=new JcQuery();
  query.setClauses(new IClause[]{MATCH.node(n).relation(r).out().node(),RETURN.ALL()});
  result=dbAccess.execute(query);
  resultString=Util.writePretty(result.getJsonResult());
  print(resultString);
  testId=""String_Node_Str"";
  assertQuery(testId,resultString,tdr.getTestData(testId));
  return;
}",0.9702675916749256
80475,"private void buildNextClone(int tmpNodeIdx,List<Class<?>> types,boolean isList,CloneInfo cloneInfo){
  cloneInfo.toClone=cloneInfo.toClone.next;
  StepClause stpc=new StepClause();
  this.next=stpc;
  stpc.previous=this;
  stpc.matchNode=this.matchNode;
  stpc.endNodeLabel=this.endNodeLabel;
  stpc.originalEndNodeName=this.originalEndNodeName;
  stpc.traversalExpression=this.traversalExpression;
  stpc.stepClauses=this.stepClauses;
  stpc.stepIndex=cloneInfo.toClone.stepIndex;
  stpc.step=cloneInfo.toClone.step;
  stpc.fieldMapping=cloneInfo.toClone.fieldMapping;
  stpc.fieldMappings=cloneInfo.toClone.fieldMappings;
  stpc.fmIndex=cloneInfo.toClone.fmIndex;
  stpc.buildClone(tmpNodeIdx,cloneInfo,isList);
}","private void buildNextClone(int tmpNodeIdx,List<Class<?>> types,boolean isList,CloneInfo cloneInfo){
  cloneInfo.toClone=cloneInfo.toClone.next;
  StepClause stpc=new StepClause();
  this.next=stpc;
  stpc.previous=this;
  stpc.matchNode=this.matchNode;
  stpc.endNodeLabel=this.endNodeLabel;
  stpc.originalEndNodeName=this.originalEndNodeName;
  stpc.traversalExpression=this.traversalExpression;
  stpc.stepClauses=this.stepClauses;
  stpc.stepIndex=cloneInfo.toClone.stepIndex;
  stpc.step=cloneInfo.toClone.step;
  stpc.fieldMappings=cloneInfo.toClone.fieldMappings;
  stpc.fmIndex=cloneInfo.toClone.fmIndex;
  stpc.buildClone(tmpNodeIdx,cloneInfo,isList);
}",0.9622641509433962
80476,"private void buildStep(int tmpNodeIdx,boolean listOrArray,CloneInfo cloneInfo,boolean forward){
  FieldMapping fm;
  if (this.fieldMappings != null && !forward)   fm=this.fieldMappings.get(this.fmIndex);
 else   fm=this.fieldMapping;
  Relation matchRel=matchNode.relation().type(fm.getPropertyOrRelationName());
  if (forward)   matchRel=matchRel.out();
 else   matchRel=matchRel.in();
  if (this.step.getMinDistance() != 1)   matchRel=matchRel.minHops(this.step.getMinDistance());
  if (this.step.getMaxDistance() != 1) {
    if (this.step.getMaxDistance() == -1)     matchRel=matchRel.maxHopsUnbound();
 else     matchRel=matchRel.maxHops(this.step.getMaxDistance());
  }
  Class<?> typ;
  CompoundObjectType cType=null;
  if (forward) {
    if (listOrArray) {
      cType=getMappingInfo().getInternalDomainAccess().getFieldComponentType(this.fieldMapping.getClassFieldName());
    }
 else {
      cType=getMappingInfo().getInternalDomainAccess().getConcreteFieldType(this.fieldMapping.getClassFieldName());
    }
    typ=cType.getType();
  }
 else {
    typ=fm.getField().getDeclaringClass();
  }
  boolean isList=typ.equals(Collection.class) || typ.equals(Array.class);
  Step nextStep=null;
  int nextStepIndex=this.stepIndex;
  List<Class<?>> types;
  if (isList) {
    if (forward) {
      nextStep=this.step.createStep(this.step.getDirection(),getMappingInfo().getObjectMappingFor(typ).fieldMappingsIterator().next().getPropertyOrRelationName());
    }
 else {
      nextStep=this.step.createStep(this.step.getDirection(),this.step.getAttributeName());
    }
    types=new ArrayList<Class<?>>();
    types.add(typ);
  }
 else {
    nextStepIndex++;
    if (nextStepIndex <= this.traversalExpression.getSteps().size() - 1)     nextStep=this.traversalExpression.getSteps().get(nextStepIndex);
    if (forward)     types=cType.getTypes(true);
 else     types=getMappingInfo().getCompoundTypesFor(typ);
  }
  if (nextStep == null) {
    if (isValidEndNodeType(types)) {
      this.endNode=new JcNode(this.originalEndNodeName.concat(tmpNodePostPrefix).concat(String.valueOf(tmpNodeIdx)));
      StepClause first=this.getFirst();
      if (first.jcPath != null) {
        String npm=ValueAccess.getName(first.jcPath).concat(tmpNodePostPrefix).concat(String.valueOf(tmpNodeIdx));
        ValueAccess.setName(npm,first.jcPath);
      }
      this.matchNode=matchRel.node(this.endNode).label(this.endNodeLabel);
    }
 else     this.matchNode=null;
  }
 else {
    this.matchNode=matchRel.node();
    if (cloneInfo != null)     this.buildNextClone(tmpNodeIdx,types,isList,cloneInfo);
 else     this.buildNext(tmpNodeIdx,types,isList,nextStep,nextStepIndex);
  }
}","private void buildStep(int tmpNodeIdx,boolean listOrArray,CloneInfo cloneInfo,boolean forward){
  FieldMapping fm=this.fieldMappings.get(this.fmIndex);
  Relation matchRel=matchNode.relation().type(fm.getPropertyOrRelationName());
  if (forward)   matchRel=matchRel.out();
 else   matchRel=matchRel.in();
  if (this.step.getMinDistance() != 1)   matchRel=matchRel.minHops(this.step.getMinDistance());
  if (this.step.getMaxDistance() != 1) {
    if (this.step.getMaxDistance() == -1)     matchRel=matchRel.maxHopsUnbound();
 else     matchRel=matchRel.maxHops(this.step.getMaxDistance());
  }
  Class<?> typ;
  CompoundObjectType cType=null;
  if (forward) {
    if (listOrArray) {
      cType=getMappingInfo().getInternalDomainAccess().getFieldComponentType(fm.getClassFieldName());
    }
 else {
      cType=getMappingInfo().getInternalDomainAccess().getConcreteFieldType(fm.getClassFieldName());
    }
    typ=cType.getType();
  }
 else {
    typ=fm.getField().getDeclaringClass();
  }
  boolean isList=typ.equals(Collection.class) || typ.equals(Array.class);
  Step nextStep=null;
  int nextStepIndex=this.stepIndex;
  List<Class<?>> types;
  if (isList) {
    if (forward) {
      nextStep=this.step.createStep(this.step.getDirection(),getMappingInfo().getObjectMappingFor(typ).fieldMappingsIterator().next().getPropertyOrRelationName());
    }
 else {
      nextStep=this.step.createStep(this.step.getDirection(),this.step.getAttributeName());
    }
    types=new ArrayList<Class<?>>();
    types.add(typ);
  }
 else {
    nextStepIndex++;
    if (nextStepIndex <= this.traversalExpression.getSteps().size() - 1)     nextStep=this.traversalExpression.getSteps().get(nextStepIndex);
    if (forward)     types=cType.getTypes(true);
 else     types=getMappingInfo().getCompoundTypesFor(typ);
  }
  if (nextStep == null) {
    if (isValidEndNodeType(types)) {
      this.endNode=new JcNode(this.originalEndNodeName.concat(tmpNodePostPrefix).concat(String.valueOf(tmpNodeIdx)));
      StepClause first=this.getFirst();
      if (first.jcPath != null) {
        String npm=ValueAccess.getName(first.jcPath).concat(tmpNodePostPrefix).concat(String.valueOf(tmpNodeIdx));
        ValueAccess.setName(npm,first.jcPath);
      }
      this.matchNode=matchRel.node(this.endNode).label(this.endNodeLabel);
    }
 else     this.matchNode=null;
  }
 else {
    this.matchNode=matchRel.node();
    if (cloneInfo != null)     this.buildNextClone(tmpNodeIdx,types,isList,cloneInfo);
 else     this.buildNext(tmpNodeIdx,types,isList,nextStep,nextStepIndex);
  }
}",0.9413118527042578
80477,"private void cloneFirst(CloneInfo cloneInfo,int tmpNodeIdx){
  this.stepClauses.add(this);
  this.startNode=cloneInfo.toClone.startNode;
  this.jcPath=cloneInfo.toClone.jcPath;
  this.originalEndNodeName=cloneInfo.toClone.originalEndNodeName;
  this.endNodeLabel=cloneInfo.toClone.endNodeLabel;
  this.traversalExpression=cloneInfo.toClone.traversalExpression;
  if (this.jcPath != null)   this.matchNode=OPTIONAL_MATCH.path(this.jcPath).node(this.startNode);
 else   this.matchNode=OPTIONAL_MATCH.node(this.startNode);
  Class<?> typ=APIAccess.getTypeForNodeName(this.traversalExpression.getStart(),ValueAccess.getName(this.startNode));
  boolean isList=typ.equals(Collection.class) || typ.equals(Array.class);
  this.stepIndex=cloneInfo.toClone.stepIndex;
  this.step=cloneInfo.toClone.step;
  this.fieldMapping=cloneInfo.toClone.fieldMapping;
  this.fieldMappings=cloneInfo.toClone.fieldMappings;
  this.fmIndex=cloneInfo.toClone.fmIndex;
  this.buildClone(tmpNodeIdx,cloneInfo,isList);
}","private void cloneFirst(CloneInfo cloneInfo,int tmpNodeIdx){
  this.stepClauses.add(this);
  this.startNode=cloneInfo.toClone.startNode;
  this.jcPath=cloneInfo.toClone.jcPath;
  this.originalEndNodeName=cloneInfo.toClone.originalEndNodeName;
  this.endNodeLabel=cloneInfo.toClone.endNodeLabel;
  this.traversalExpression=cloneInfo.toClone.traversalExpression;
  if (this.jcPath != null)   this.matchNode=OPTIONAL_MATCH.path(this.jcPath).node(this.startNode);
 else   this.matchNode=OPTIONAL_MATCH.node(this.startNode);
  Class<?> typ=APIAccess.getTypeForNodeName(this.traversalExpression.getStart(),ValueAccess.getName(this.startNode));
  boolean isList=typ.equals(Collection.class) || typ.equals(Array.class);
  this.stepIndex=cloneInfo.toClone.stepIndex;
  this.step=cloneInfo.toClone.step;
  this.fieldMappings=cloneInfo.toClone.fieldMappings;
  this.fmIndex=cloneInfo.toClone.fmIndex;
  this.buildClone(tmpNodeIdx,cloneInfo,isList);
}",0.9730569948186528
80478,"private void addCountWithClause(ClausesPerType iCpt,List<IClause> countWithClauses,List<IClause> selectClauses,ClausesPerType cpt){
  String alias=ValueAccess.getName(iCpt.node).concat(countXprPostPrefix);
  JcNumber num=new JcNumber(alias);
  selectClauses.add(WITH.count().value(iCpt.node).AS(num));
  selectClauses.addAll(countWithClauses);
  cpt.countWithClausesIdxs.add(0,selectClauses.size());
  countWithClauses.add(0,WITH.value(num));
}","private void addCountWithClause(ClausesPerType iCpt,List<IClause> countWithClauses,List<IClause> selectClauses,ClausesPerType cpt){
  String alias=ValueAccess.getName(iCpt.node).concat(countXprPostPrefix);
  JcNumber num=new JcNumber(alias);
  selectClauses.add(WITH.count().DISTINCT().value(iCpt.node).AS(num));
  selectClauses.addAll(countWithClauses);
  cpt.countWithClausesIdxs.add(0,selectClauses.size());
  countWithClauses.add(0,WITH.value(num));
}",0.9877641824249166
80479,"private void build(int tmpNodeIdx,List<Class<?>> types,boolean isList){
  FieldMapping fm=null;
  List<FieldMapping> fms=null;
  for (  Class<?> t : types) {
    if (this.step.getDirection() == 0) {
      fm=getMappingInfo().getFieldMapping(this.step.getAttributeName(),t);
      if (fm != null)       break;
    }
 else {
      if (fms == null)       fms=new ArrayList<FieldMapping>();
      List<FieldMapping> fms_t=getMappingInfo().getBackwardFieldMappings(this.step.getAttributeName(),t);
      for (      FieldMapping f : fms_t) {
        if (!fms.contains(f))         fms.add(f);
      }
    }
  }
  boolean doBuild=false;
  if (fms != null && !fms.isEmpty()) {
    if (fms.size() == 1)     this.fieldMapping=fms.get(0);
 else {
      this.fieldMappings=fms;
      this.fmIndex=0;
    }
    doBuild=true;
  }
 else {
    if (fm != null) {
      this.fieldMapping=fm;
      doBuild=true;
    }
 else     this.matchNode=null;
  }
  if (doBuild) {
    if (this.step.getDirection() == 0)     this.buildStep(tmpNodeIdx,isList,null,true);
 else     this.buildStep(tmpNodeIdx,isList,null,false);
  }
  if (this.fieldMappings != null && this.fmIndex < this.fieldMappings.size() - 1) {
    this.cloneTraversal(this,tmpNodeIdx + 1);
  }
}","private void build(int tmpNodeIdx,List<Class<?>> types,boolean isList){
  List<FieldMapping> fms=null;
  for (  Class<?> t : types) {
    if (this.step.getDirection() == 0) {
      FieldMapping fm=getMappingInfo().getFieldMapping(this.step.getAttributeName(),t);
      if (fm != null) {
        if (fms == null)         fms=new ArrayList<FieldMapping>();
        fms.add(fm);
      }
    }
 else {
      if (fms == null)       fms=new ArrayList<FieldMapping>();
      List<FieldMapping> fms_t=getMappingInfo().getBackwardFieldMappings(this.step.getAttributeName(),t);
      for (      FieldMapping f : fms_t) {
        if (!fms.contains(f))         fms.add(f);
      }
    }
  }
  boolean doBuild=false;
  if (fms != null && !fms.isEmpty()) {
    this.fieldMappings=fms;
    this.fmIndex=0;
    doBuild=true;
  }
 else {
    this.matchNode=null;
  }
  if (doBuild) {
    if (this.step.getDirection() == 0)     this.buildStep(tmpNodeIdx,isList,null,true);
 else     this.buildStep(tmpNodeIdx,isList,null,false);
  }
  if (this.fieldMappings != null && this.fmIndex < this.fieldMappings.size() - 1) {
    this.cloneTraversal(this,tmpNodeIdx + 1);
  }
}",0.8179530201342282
80480,"@Test public void testDomainQuery_Traversals_01(){
  IDomainAccess da1;
  DomainQuery q;
  DomainQueryResult result=null;
  boolean equals;
  String testId;
  String qCypher;
  TestDataReader tdr=new TestDataReader(""String_Node_Str"");
  Population population=new Population();
  population.createPopulation();
  da1=DomainAccessFactory.createDomainAccess(dbAccess,domainName);
  testId=""String_Node_Str"";
  queriesStream.reset();
  q=da1.createQuery();
  DomainObjectMatch<Person> j_smith=q.createMatch(Person.class);
  q.WHERE(j_smith.atttribute(""String_Node_Str"")).EQUALS(""String_Node_Str"");
  q.WHERE(j_smith.atttribute(""String_Node_Str"")).EQUALS(""String_Node_Str"");
  DomainObjectMatch<Address> j_smith_Addresses=q.TRAVERSE_FROM(j_smith).FORTH(""String_Node_Str"").TO(Address.class);
  result=q.execute();
  List<Address> j_smith_AddressesResult=result.resultOf(j_smith_Addresses);
  equals=CompareUtil.equalsUnorderedList(population.getJohn_smith_addresses(),j_smith_AddressesResult);
  assertTrue(equals);
  qCypher=TestDataReader.trimComments(queriesStream.toString().trim());
  assertQuery(testId,qCypher,tdr.getTestData(testId));
  testId=""String_Node_Str"";
  queriesStream.reset();
  q=da1.createQuery();
  DomainObjectMatch<Subject> subs=q.createMatch(Subject.class);
  q.WHERE(subs.atttribute(""String_Node_Str"")).EQUALS(""String_Node_Str"");
  q.OR();
  q.BR_OPEN();
  q.WHERE(subs.atttribute(""String_Node_Str"")).EQUALS(""String_Node_Str"");
  q.WHERE(subs.atttribute(""String_Node_Str"")).EQUALS(""String_Node_Str"");
  q.BR_CLOSE();
  DomainObjectMatch<PointOfContact> subs_Contacts=q.TRAVERSE_FROM(subs).FORTH(""String_Node_Str"").TO(PointOfContact.class);
  DomainObjectMatch<Area> areas=q.TRAVERSE_FROM(subs_Contacts).FORTH(""String_Node_Str"").TO(Area.class);
  result=q.execute();
  List<Subject> subsResult=result.resultOf(subs);
  List<PointOfContact> subs_ContactsResult=result.resultOf(subs_Contacts);
  List<Area> areasResult=result.resultOf(areas);
  equals=CompareUtil.equalsUnorderedList(population.getJohn_smith_globcom(),subsResult);
  assertTrue(equals);
  equals=CompareUtil.equalsUnorderedList(population.getJohn_smith_globcom_contacts(),subs_ContactsResult);
  assertTrue(equals);
  equals=CompareUtil.equalsUnorderedList(population.getAreas_sf_vienna_01_munich(),areasResult);
  assertTrue(equals);
  qCypher=TestDataReader.trimComments(queriesStream.toString().trim());
  assertQuery(testId,qCypher,tdr.getTestData(testId));
  testId=""String_Node_Str"";
  queriesStream.reset();
  q=da1.createQuery();
  DomainObjectMatch<Subject> subs_1=q.createMatch(Subject.class);
  q.WHERE(subs_1.atttribute(""String_Node_Str"")).EQUALS(""String_Node_Str"");
  q.OR();
  q.BR_OPEN();
  q.WHERE(subs_1.atttribute(""String_Node_Str"")).EQUALS(""String_Node_Str"");
  q.WHERE(subs_1.atttribute(""String_Node_Str"")).EQUALS(""String_Node_Str"");
  q.BR_CLOSE();
  subs_1.setPage(1,1);
  DomainObjectMatch<PointOfContact> subs_1_Contacts=q.TRAVERSE_FROM(subs_1).FORTH(""String_Node_Str"").TO(PointOfContact.class);
  subs_1_Contacts.setPage(2,2);
  q.ORDER(subs_1_Contacts).BY(""String_Node_Str"");
  DomainObjectMatch<Area> areas_1=q.TRAVERSE_FROM(subs_1_Contacts).FORTH(""String_Node_Str"").TO(Area.class);
  areas_1.setPage(0,1);
  q.ORDER(areas_1).BY(""String_Node_Str"").DESCENDING();
  result=q.execute();
  List<Subject> subs_1Result=result.resultOf(subs_1);
  List<PointOfContact> subs_1_ContactsResult=result.resultOf(subs_1_Contacts);
  List<Area> areas_1Result=result.resultOf(areas_1);
  List<Object> subs_1Comp=population.getJohn_smith_globcom().subList(1,2);
  equals=CompareUtil.equalsList(subs_1Comp,subs_1Result);
  assertTrue(equals);
  List<Object> contactsComp=population.getJohn_smith_globcom_contacts().subList(2,4);
  equals=CompareUtil.equalsList(contactsComp,subs_1_ContactsResult);
  assertTrue(equals);
  List<Object> areas_1Comp=population.getAreas_sf_vienna_01_munich().subList(0,1);
  equals=CompareUtil.equalsList(areas_1Comp,areas_1Result);
  assertTrue(equals);
  qCypher=TestDataReader.trimComments(queriesStream.toString().trim());
  assertQuery(testId,qCypher,tdr.getTestData(testId));
  testId=""String_Node_Str"";
  queriesStream.reset();
  q=da1.createQuery();
  DomainObjectMatch<Person> j_smith_1=q.createMatch(Person.class);
  q.WHERE(j_smith_1.atttribute(""String_Node_Str"")).EQUALS(""String_Node_Str"");
  q.WHERE(j_smith_1.atttribute(""String_Node_Str"")).EQUALS(""String_Node_Str"");
  DomainObjectMatch<Area> j_smith_1_Areas2=q.TRAVERSE_FROM(j_smith_1).FORTH(""String_Node_Str"").FORTH(""String_Node_Str"").FORTH(""String_Node_Str"").DISTANCE(1,-1).TO(Area.class);
  result=q.execute();
  List<Area> j_smith_1_Areas2Result=result.resultOf(j_smith_1_Areas2);
  equals=CompareUtil.equalsUnorderedList(population.getAreas_calif_vienna_munich_up(),j_smith_1_Areas2Result);
  assertTrue(equals);
  qCypher=TestDataReader.trimComments(queriesStream.toString().trim());
  assertQuery(testId,qCypher,tdr.getTestData(testId));
  testId=""String_Node_Str"";
  queriesStream.reset();
  q=da1.createQuery();
  DomainObjectMatch<Subject> j_smith_comp=q.createMatch(Subject.class);
  q.WHERE(j_smith_comp.atttribute(""String_Node_Str"")).EQUALS(""String_Node_Str"");
  q.WHERE(j_smith_comp.atttribute(""String_Node_Str"")).EQUALS(""String_Node_Str"");
  DomainObjectMatch<PointOfContact> pocs=q.TRAVERSE_FROM(j_smith_comp).FORTH(""String_Node_Str"").TO(PointOfContact.class);
  q.WHERE(pocs.atttribute(""String_Node_Str"")).LIKE(""String_Node_Str"");
  result=q.execute();
  List<PointOfContact> pocsResult=result.resultOf(pocs);
  equals=CompareUtil.equalsObjects(population.getMarketStreet_20(),pocsResult.get(0));
  assertTrue(equals);
  qCypher=TestDataReader.trimComments(queriesStream.toString().trim());
  assertQuery(testId,qCypher,tdr.getTestData(testId));
  testId=""String_Node_Str"";
  queriesStream.reset();
  q=da1.createQuery();
  DomainObjectMatch<Subject> jer_smith_comp=q.createMatch(Subject.class);
  areas=q.createMatch(Area.class);
  q.WHERE(jer_smith_comp.atttribute(""String_Node_Str"")).EQUALS(""String_Node_Str"");
  q.OR();
  q.BR_OPEN();
  q.WHERE(jer_smith_comp.atttribute(""String_Node_Str"")).EQUALS(""String_Node_Str"");
  q.WHERE(jer_smith_comp.atttribute(""String_Node_Str"")).EQUALS(""String_Node_Str"");
  q.BR_CLOSE();
  areas_1=q.TRAVERSE_FROM(jer_smith_comp).FORTH(""String_Node_Str"").FORTH(""String_Node_Str"").TO(Area.class);
  DomainObjectMatch<Area> areas_2=q.TRAVERSE_FROM(areas_1).FORTH(""String_Node_Str"").DISTANCE(1,-1).TO(Area.class);
  q.BR_OPEN();
  q.WHERE(areas).IN(areas_1);
  q.OR();
  q.WHERE(areas).IN(areas_2);
  q.BR_CLOSE();
  q.WHERE(areas.atttribute(""String_Node_Str"")).EQUALS(AreaType.CITY);
  result=q.execute();
  CountQueryResult cResult=q.executeCount();
  areasResult=result.resultOf(areas);
  equals=CompareUtil.equalsUnorderedList(population.getAreas_sf_vienna_munich(),areasResult);
  assertTrue(equals);
  long areasCount=cResult.countOf(areas);
  assertEquals(3,areasCount);
  qCypher=TestDataReader.trimComments(queriesStream.toString().trim());
  assertQuery(testId,qCypher,tdr.getTestData(testId));
  testId=""String_Node_Str"";
  queriesStream.reset();
  q=da1.createQuery();
  DomainObjectMatch<Subject> smith_globcomMatch=q.createMatch(Subject.class);
  q.WHERE(smith_globcomMatch.atttribute(""String_Node_Str"")).EQUALS(""String_Node_Str"");
  q.OR();
  q.BR_OPEN();
  q.WHERE(smith_globcomMatch.atttribute(""String_Node_Str"")).EQUALS(""String_Node_Str"");
  q.WHERE(smith_globcomMatch.atttribute(""String_Node_Str"")).EQUALS(""String_Node_Str"");
  q.BR_CLOSE();
  DomainObjectMatch<Area> immediateAreasMatch=q.TRAVERSE_FROM(smith_globcomMatch).FORTH(""String_Node_Str"").FORTH(""String_Node_Str"").TO(Area.class);
  q.WHERE(immediateAreasMatch.atttribute(""String_Node_Str"")).EQUALS(AreaType.CITY);
  result=q.execute();
  List<Area> immediateAreas=result.resultOf(immediateAreasMatch);
  List<Area> sf=new ArrayList<Area>();
  sf.add(population.getSanFrancisco());
  sf.add(population.getMunich());
  equals=CompareUtil.equalsUnorderedList(sf,immediateAreas);
  assertTrue(equals);
  qCypher=TestDataReader.trimComments(queriesStream.toString().trim());
  assertQuery(testId,qCypher,tdr.getTestData(testId));
  return;
}","@Test public void testDomainQuery_Traversals_01(){
  IDomainAccess da1;
  DomainQuery q;
  DomainQueryResult result=null;
  boolean equals;
  String testId;
  String qCypher;
  TestDataReader tdr=new TestDataReader(""String_Node_Str"");
  Population population=new Population();
  population.createPopulation();
  da1=DomainAccessFactory.createDomainAccess(dbAccess,domainName);
  testId=""String_Node_Str"";
  queriesStream.reset();
  q=da1.createQuery();
  DomainObjectMatch<Person> j_smith=q.createMatch(Person.class);
  q.WHERE(j_smith.atttribute(""String_Node_Str"")).EQUALS(""String_Node_Str"");
  q.WHERE(j_smith.atttribute(""String_Node_Str"")).EQUALS(""String_Node_Str"");
  DomainObjectMatch<Address> j_smith_Addresses=q.TRAVERSE_FROM(j_smith).FORTH(""String_Node_Str"").TO(Address.class);
  result=q.execute();
  List<Address> j_smith_AddressesResult=result.resultOf(j_smith_Addresses);
  equals=CompareUtil.equalsUnorderedList(population.getJohn_smith_addresses(),j_smith_AddressesResult);
  assertTrue(equals);
  qCypher=TestDataReader.trimComments(queriesStream.toString().trim());
  assertQuery(testId,qCypher,tdr.getTestData(testId));
  testId=""String_Node_Str"";
  queriesStream.reset();
  q=da1.createQuery();
  DomainObjectMatch<Subject> subs=q.createMatch(Subject.class);
  q.WHERE(subs.atttribute(""String_Node_Str"")).EQUALS(""String_Node_Str"");
  q.OR();
  q.BR_OPEN();
  q.WHERE(subs.atttribute(""String_Node_Str"")).EQUALS(""String_Node_Str"");
  q.WHERE(subs.atttribute(""String_Node_Str"")).EQUALS(""String_Node_Str"");
  q.BR_CLOSE();
  DomainObjectMatch<PointOfContact> subs_Contacts=q.TRAVERSE_FROM(subs).FORTH(""String_Node_Str"").TO(PointOfContact.class);
  DomainObjectMatch<Area> areas=q.TRAVERSE_FROM(subs_Contacts).FORTH(""String_Node_Str"").TO(Area.class);
  result=q.execute();
  List<Subject> subsResult=result.resultOf(subs);
  List<PointOfContact> subs_ContactsResult=result.resultOf(subs_Contacts);
  List<Area> areasResult=result.resultOf(areas);
  equals=CompareUtil.equalsUnorderedList(population.getJohn_smith_globcom(),subsResult);
  assertTrue(equals);
  equals=CompareUtil.equalsUnorderedList(population.getJohn_smith_globcom_contacts(),subs_ContactsResult);
  assertTrue(equals);
  equals=CompareUtil.equalsUnorderedList(population.getAreas_sf_vienna_01_munich(),areasResult);
  assertTrue(equals);
  qCypher=TestDataReader.trimComments(queriesStream.toString().trim());
  assertQuery(testId,qCypher,tdr.getTestData(testId));
  testId=""String_Node_Str"";
  queriesStream.reset();
  q=da1.createQuery();
  DomainObjectMatch<Subject> subs_1=q.createMatch(Subject.class);
  q.WHERE(subs_1.atttribute(""String_Node_Str"")).EQUALS(""String_Node_Str"");
  q.OR();
  q.BR_OPEN();
  q.WHERE(subs_1.atttribute(""String_Node_Str"")).EQUALS(""String_Node_Str"");
  q.WHERE(subs_1.atttribute(""String_Node_Str"")).EQUALS(""String_Node_Str"");
  q.BR_CLOSE();
  subs_1.setPage(1,1);
  DomainObjectMatch<PointOfContact> subs_1_Contacts=q.TRAVERSE_FROM(subs_1).FORTH(""String_Node_Str"").TO(PointOfContact.class);
  subs_1_Contacts.setPage(2,2);
  q.ORDER(subs_1_Contacts).BY(""String_Node_Str"");
  DomainObjectMatch<Area> areas_1=q.TRAVERSE_FROM(subs_1_Contacts).FORTH(""String_Node_Str"").TO(Area.class);
  areas_1.setPage(0,1);
  q.ORDER(areas_1).BY(""String_Node_Str"").DESCENDING();
  result=q.execute();
  List<Subject> subs_1Result=result.resultOf(subs_1);
  List<PointOfContact> subs_1_ContactsResult=result.resultOf(subs_1_Contacts);
  List<Area> areas_1Result=result.resultOf(areas_1);
  List<Object> subs_1Comp=population.getJohn_smith_globcom().subList(1,2);
  equals=CompareUtil.equalsList(subs_1Comp,subs_1Result);
  assertTrue(equals);
  List<Object> contactsComp=population.getJohn_smith_globcom_contacts().subList(2,4);
  equals=CompareUtil.equalsList(contactsComp,subs_1_ContactsResult);
  assertTrue(equals);
  List<Object> areas_1Comp=population.getAreas_sf_vienna_01_munich().subList(0,1);
  equals=CompareUtil.equalsList(areas_1Comp,areas_1Result);
  assertTrue(equals);
  qCypher=TestDataReader.trimComments(queriesStream.toString().trim());
  assertQuery(testId,qCypher,tdr.getTestData(testId));
  testId=""String_Node_Str"";
  queriesStream.reset();
  q=da1.createQuery();
  DomainObjectMatch<Person> j_smith_1=q.createMatch(Person.class);
  q.WHERE(j_smith_1.atttribute(""String_Node_Str"")).EQUALS(""String_Node_Str"");
  q.WHERE(j_smith_1.atttribute(""String_Node_Str"")).EQUALS(""String_Node_Str"");
  DomainObjectMatch<Area> j_smith_1_Areas2=q.TRAVERSE_FROM(j_smith_1).FORTH(""String_Node_Str"").FORTH(""String_Node_Str"").FORTH(""String_Node_Str"").DISTANCE(1,-1).TO(Area.class);
  result=q.execute();
  List<Area> j_smith_1_Areas2Result=result.resultOf(j_smith_1_Areas2);
  equals=CompareUtil.equalsUnorderedList(population.getAreas_calif_vienna_munich_up(),j_smith_1_Areas2Result);
  assertTrue(equals);
  qCypher=TestDataReader.trimComments(queriesStream.toString().trim());
  assertQuery(testId,qCypher,tdr.getTestData(testId));
  testId=""String_Node_Str"";
  queriesStream.reset();
  q=da1.createQuery();
  DomainObjectMatch<Subject> j_smith_comp=q.createMatch(Subject.class);
  q.WHERE(j_smith_comp.atttribute(""String_Node_Str"")).EQUALS(""String_Node_Str"");
  q.WHERE(j_smith_comp.atttribute(""String_Node_Str"")).EQUALS(""String_Node_Str"");
  DomainObjectMatch<PointOfContact> pocs=q.TRAVERSE_FROM(j_smith_comp).FORTH(""String_Node_Str"").TO(PointOfContact.class);
  q.WHERE(pocs.atttribute(""String_Node_Str"")).LIKE(""String_Node_Str"");
  result=q.execute();
  List<PointOfContact> pocsResult=result.resultOf(pocs);
  equals=CompareUtil.equalsObjects(population.getMarketStreet_20(),pocsResult.get(0));
  assertTrue(equals);
  qCypher=TestDataReader.trimComments(queriesStream.toString().trim());
  assertQuery(testId,qCypher,tdr.getTestData(testId));
  testId=""String_Node_Str"";
  queriesStream.reset();
  q=da1.createQuery();
  DomainObjectMatch<Subject> jer_smith_comp=q.createMatch(Subject.class);
  areas=q.createMatch(Area.class);
  q.WHERE(jer_smith_comp.atttribute(""String_Node_Str"")).EQUALS(""String_Node_Str"");
  q.OR();
  q.BR_OPEN();
  q.WHERE(jer_smith_comp.atttribute(""String_Node_Str"")).EQUALS(""String_Node_Str"");
  q.WHERE(jer_smith_comp.atttribute(""String_Node_Str"")).EQUALS(""String_Node_Str"");
  q.BR_CLOSE();
  areas_1=q.TRAVERSE_FROM(jer_smith_comp).FORTH(""String_Node_Str"").FORTH(""String_Node_Str"").TO(Area.class);
  DomainObjectMatch<Area> areas_2=q.TRAVERSE_FROM(areas_1).FORTH(""String_Node_Str"").DISTANCE(1,-1).TO(Area.class);
  q.BR_OPEN();
  q.WHERE(areas).IN(areas_1);
  q.OR();
  q.WHERE(areas).IN(areas_2);
  q.BR_CLOSE();
  q.WHERE(areas.atttribute(""String_Node_Str"")).EQUALS(AreaType.CITY);
  result=q.execute();
  CountQueryResult cResult=q.executeCount();
  areasResult=result.resultOf(areas);
  equals=CompareUtil.equalsUnorderedList(population.getAreas_sf_vienna_munich(),areasResult);
  assertTrue(equals);
  long areasCount=cResult.countOf(areas);
  assertEquals(3,areasCount);
  qCypher=TestDataReader.trimComments(queriesStream.toString().trim());
  assertQuery(testId,qCypher,tdr.getTestData(testId));
  testId=""String_Node_Str"";
  queriesStream.reset();
  q=da1.createQuery();
  DomainObjectMatch<Subject> smith_globcomMatch=q.createMatch(Subject.class);
  q.WHERE(smith_globcomMatch.atttribute(""String_Node_Str"")).EQUALS(""String_Node_Str"");
  q.OR();
  q.BR_OPEN();
  q.WHERE(smith_globcomMatch.atttribute(""String_Node_Str"")).EQUALS(""String_Node_Str"");
  q.WHERE(smith_globcomMatch.atttribute(""String_Node_Str"")).EQUALS(""String_Node_Str"");
  q.BR_CLOSE();
  DomainObjectMatch<Area> immediateAreasMatch=q.TRAVERSE_FROM(smith_globcomMatch).FORTH(""String_Node_Str"").FORTH(""String_Node_Str"").TO(Area.class);
  q.WHERE(immediateAreasMatch.atttribute(""String_Node_Str"")).EQUALS(AreaType.CITY);
  result=q.execute();
  List<Area> immediateAreas=result.resultOf(immediateAreasMatch);
  List<Area> sf=new ArrayList<Area>();
  sf.add(population.getSanFrancisco());
  sf.add(population.getMunich());
  equals=CompareUtil.equalsUnorderedList(sf,immediateAreas);
  assertTrue(equals);
  qCypher=TestDataReader.trimComments(queriesStream.toString().trim());
  assertQuery(testId,qCypher,tdr.getTestData(testId));
  testId=""String_Node_Str"";
  queriesStream.reset();
  q=da1.createQuery();
  j_smith=q.createMatch(Person.class);
  q.WHERE(j_smith.atttribute(""String_Node_Str"")).EQUALS(""String_Node_Str"");
  q.WHERE(j_smith.atttribute(""String_Node_Str"")).EQUALS(""String_Node_Str"");
  DomainObjectMatch<AbstractArea> jsAreas=q.TRAVERSE_FROM(j_smith).FORTH(""String_Node_Str"").FORTH(""String_Node_Str"").FORTH(""String_Node_Str"").DISTANCE(0,-1).TO(AbstractArea.class);
  result=q.execute();
  List<AbstractArea> jsAreasResult=result.resultOf(jsAreas);
  Person js=population.getJohn_smith();
  List<AbstractArea> compAreas=new ArrayList<AbstractArea>();
  for (  PointOfContact poc : js.getPointsOfContact()) {
    if (poc instanceof Address) {
      AbstractArea ar=((Address)poc).getArea();
      ar=ar.getPartOf();
      while (ar != null) {
        if (!compAreas.contains(ar))         compAreas.add(ar);
        ar=ar.getPartOf();
      }
    }
    if (poc instanceof EContact) {
      AbstractArea ar=((EContact)poc).getArea();
      ar=ar.getPartOf();
      while (ar != null) {
        if (!compAreas.contains(ar))         compAreas.add(ar);
        ar=ar.getPartOf();
      }
    }
  }
  equals=CompareUtil.equalsUnorderedList(compAreas,jsAreasResult);
  assertTrue(equals);
  qCypher=TestDataReader.trimComments(queriesStream.toString().trim());
  assertQuery(testId,qCypher,tdr.getTestData(testId));
  return;
}",0.920520067834935
80481,"/** 
 * CONTAINS 
 */
@Test public void testDomainQuery_Collections_09(){
  IDomainAccess da1;
  DomainQuery q;
  DomainQueryResult result=null;
  boolean equals;
  String testId;
  String qCypher;
  Population population=new Population();
  population.createPopulation();
  da1=DomainAccessFactory.createDomainAccess(dbAccess,domainName);
  testId=""String_Node_Str"";
  queriesStream.reset();
  q=da1.createQuery();
  DomainObjectMatch<Person> j_smith=q.createMatch(Person.class);
  q.WHERE(j_smith.atttribute(""String_Node_Str"")).EQUALS(""String_Node_Str"");
  q.WHERE(j_smith.atttribute(""String_Node_Str"")).EQUALS(""String_Node_Str"");
  DomainObjectMatch<PointOfContact> poc=q.TRAVERSE_FROM(j_smith).FORTH(""String_Node_Str"").TO(PointOfContact.class);
  DomainObjectMatch<AbstractArea> areas_1=q.TRAVERSE_FROM(j_smith).FORTH(""String_Node_Str"").FORTH(""String_Node_Str"").TO(AbstractArea.class);
  DomainObjectMatch<AbstractArea> areas_2=q.TRAVERSE_FROM(areas_1).FORTH(""String_Node_Str"").DISTANCE(0,-1).TO(AbstractArea.class);
  result=q.execute();
  List<AbstractArea> areas_1Result=result.resultOf(areas_1);
  List<AbstractArea> areas_2Result=result.resultOf(areas_2);
  List<PointOfContact> pocResult=result.resultOf(poc);
  return;
}","/** 
 * CONTAINS 
 */
@Test public void testDomainQuery_Collections_09(){
  IDomainAccess da1;
  DomainQuery q;
  DomainQueryResult result=null;
  boolean equals;
  String testId;
  String qCypher;
  Population population=new Population();
  population.createPopulation();
  da1=DomainAccessFactory.createDomainAccess(dbAccess,domainName);
  testId=""String_Node_Str"";
  queriesStream.reset();
  q=da1.createQuery();
  DomainObjectMatch<Person> subjects=q.createMatch(Person.class);
  DomainObjectMatch<Area> europe=q.createMatch(Area.class);
  DomainObjectMatch<Person> j_smith=q.createMatch(Person.class);
  q.WHERE(j_smith.atttribute(""String_Node_Str"")).EQUALS(""String_Node_Str"");
  q.WHERE(j_smith.atttribute(""String_Node_Str"")).EQUALS(""String_Node_Str"");
  q.WHERE(europe.atttribute(""String_Node_Str"")).EQUALS(""String_Node_Str"");
  DomainObjectMatch<Object> addresses=q.TRAVERSE_FROM(subjects).FORTH(""String_Node_Str"").TO(Object.class);
  DomainObjectMatch<AbstractArea> areas=q.TRAVERSE_FROM(subjects).FORTH(""String_Node_Str"").FORTH(""String_Node_Str"").FORTH(""String_Node_Str"").DISTANCE(0,-1).TO(AbstractArea.class);
  DomainObjectMatch<AbstractArea> areas_1=q.TRAVERSE_FROM(j_smith).FORTH(""String_Node_Str"").FORTH(""String_Node_Str"").FORTH(""String_Node_Str"").DISTANCE(0,-1).TO(AbstractArea.class);
  DomainObjectMatch<Person> num_addresses=q.SELECT_FROM(subjects).ELEMENTS(q.WHERE(addresses.COUNT()).EQUALS(4),q.WHERE(areas.COUNT()).EQUALS(9));
  result=q.execute();
  List<Person> num_addressesResult=result.resultOf(num_addresses);
  List<AbstractArea> areas_1Result=result.resultOf(areas_1);
  testId=""String_Node_Str"";
  queriesStream.reset();
  q=da1.createQuery();
  subjects=q.createMatch(Person.class);
  europe=q.createMatch(Area.class);
  j_smith=q.createMatch(Person.class);
  q.WHERE(j_smith.atttribute(""String_Node_Str"")).EQUALS(""String_Node_Str"");
  q.WHERE(j_smith.atttribute(""String_Node_Str"")).EQUALS(""String_Node_Str"");
  q.WHERE(europe.atttribute(""String_Node_Str"")).EQUALS(""String_Node_Str"");
  addresses=q.TRAVERSE_FROM(subjects).FORTH(""String_Node_Str"").TO(Object.class);
  areas=q.TRAVERSE_FROM(subjects).FORTH(""String_Node_Str"").FORTH(""String_Node_Str"").FORTH(""String_Node_Str"").DISTANCE(0,-1).TO(AbstractArea.class);
  areas_1=q.TRAVERSE_FROM(j_smith).FORTH(""String_Node_Str"").FORTH(""String_Node_Str"").FORTH(""String_Node_Str"").DISTANCE(0,-1).TO(AbstractArea.class);
  num_addresses=q.SELECT_FROM(subjects).ELEMENTS(q.WHERE(addresses.atttribute(""String_Node_Str"")).EQUALS(20),q.BR_OPEN(),q.WHERE(addresses.COUNT()).EQUALS(4),q.OR(),q.WHERE(areas.COUNT()).EQUALS(8),q.BR_CLOSE());
  result=q.execute();
  num_addressesResult=result.resultOf(num_addresses);
  areas_1Result=result.resultOf(areas_1);
  return;
}",0.3694556451612903
80482,"private List<JcQuery> buildQueriesInt(List<ClausesPerType> clausesPerTypeList,QueryContext context,ClauseBuilderContext cbContext){
  List<JcQuery> ret=new ArrayList<JcQuery>();
  int queryIndex=-1;
  int startIdx=0;
  while (startIdx < clausesPerTypeList.size()) {
    queryIndex++;
    List<IClause> clauses=new ArrayList<IClause>();
    List<ClausesPerType> toReturn=new ArrayList<ClausesPerType>();
    List<IClause> withClauses=null;
    boolean needAddDependencies=startIdx > 0;
    boolean needWith=false;
    int i;
    for (i=startIdx; i < clausesPerTypeList.size(); i++) {
      ClausesPerType cpt=clausesPerTypeList.get(i);
      if (cpt.valid) {
        boolean startNewQueryAfterThis=false;
        if (!context.execCount) {
          if (withClauses == null)           withClauses=new ArrayList<IClause>();
          if (this.clauseBuilder.buildAddWithClause(cpt,withClauses))           needWith=true;
          if (cpt.needSkipsLimits()) {
            if (i > startIdx) {
              startIdx=i;
              break;
            }
            needWith=true;
            withClauses.add(WHERE.NOT().valueOf(cpt.node).IS_NULL());
            startIdx=i + 1;
            startNewQueryAfterThis=true;
          }
        }
        if (cpt.startCountSelectXpr) {
          if (i > startIdx) {
            startIdx=i;
            break;
          }
        }
        if (needAddDependencies) {
          cpt.addDependencyClauses(clauses);
          needAddDependencies=false;
        }
        clauses.addAll(cpt.getClauses());
        if (APIAccess.isPartOfReturn(cpt.domainObjectMatch)) {
          toReturn.add(cpt);
          QueryContext.ResultsPerType resPerType=context.addFor(cpt,context.execCount);
          context.resultsPerType.add(resPerType);
          resPerType.queryIndex=queryIndex;
        }
        if (startNewQueryAfterThis)         break;
      }
 else       context.addEmptyFor(cpt);
    }
    if (i == clausesPerTypeList.size())     startIdx=i;
    List<IClause> returnClauses=buildReturnClauses(toReturn,context.execCount);
    if (needWith)     clauses.addAll(withClauses);
    clauses.addAll(returnClauses);
    IClause[] clausesArray=clauses.toArray(new IClause[clauses.size()]);
    JcQuery query=new JcQuery();
    query.setClauses(clausesArray);
    ret.add(query);
  }
  return ret;
}","private List<JcQuery> buildQueriesInt(List<ClausesPerType> clausesPerTypeList,QueryContext context,ClauseBuilderContext cbContext){
  List<JcQuery> ret=new ArrayList<JcQuery>();
  int queryIndex=-1;
  int startIdx=0;
  while (startIdx < clausesPerTypeList.size()) {
    queryIndex++;
    List<IClause> clauses=new ArrayList<IClause>();
    List<ClausesPerType> toReturn=new ArrayList<ClausesPerType>();
    List<ClausesPerType> added=new ArrayList<ClausesPerType>();
    List<IClause> withClauses=null;
    boolean needWith=false;
    int i;
    for (i=startIdx; i < clausesPerTypeList.size(); i++) {
      ClausesPerType cpt=clausesPerTypeList.get(i);
      if (cpt.valid) {
        boolean startNewQueryAfterThis=false;
        if (!context.execCount) {
          if (withClauses == null)           withClauses=new ArrayList<IClause>();
          if (this.clauseBuilder.buildAddWithClause(cpt,withClauses))           needWith=true;
          if (cpt.needSkipsLimits()) {
            if (i > startIdx) {
              startIdx=i;
              break;
            }
            needWith=true;
            withClauses.add(WHERE.NOT().valueOf(cpt.node).IS_NULL());
            startIdx=i + 1;
            startNewQueryAfterThis=true;
          }
        }
        if (cpt.startCountSelectXpr) {
          if (i > startIdx) {
            startIdx=i;
            break;
          }
        }
        cpt.addDependencyClauses(clauses,added);
        clauses.addAll(cpt.getClauses());
        if (APIAccess.isPartOfReturn(cpt.domainObjectMatch)) {
          toReturn.add(cpt);
          QueryContext.ResultsPerType resPerType=context.addFor(cpt,context.execCount);
          context.resultsPerType.add(resPerType);
          resPerType.queryIndex=queryIndex;
        }
        if (startNewQueryAfterThis)         break;
      }
 else       context.addEmptyFor(cpt);
      added.add(cpt);
    }
    if (i == clausesPerTypeList.size())     startIdx=i;
    List<IClause> returnClauses=buildReturnClauses(toReturn,context.execCount);
    if (needWith)     clauses.addAll(withClauses);
    clauses.addAll(returnClauses);
    IClause[] clausesArray=clauses.toArray(new IClause[clauses.size()]);
    JcQuery query=new JcQuery();
    query.setClauses(clausesArray);
    ret.add(query);
  }
  return ret;
}",0.941991341991342
80483,"private void addDependencyClauses(List<IClause> clauses){
  boolean hasCountWithXpr=this.countWithClausesIdxs != null;
  List<String> depBases=null;
  if (hasCountWithXpr)   depBases=new ArrayList<String>();
  if (this.expressionsPerDOM.flattenedDependencies != null) {
    for (    ExpressionsPerDOM xpd : this.expressionsPerDOM.flattenedDependencies) {
      List<DomainObjectMatch<?>> collOwner=APIAccess.getCollectExpressionOwner(xpd.domainObjectMatch);
      boolean addExpressions=collOwner == null || !collOwner.contains(this.domainObjectMatch);
      for (      ClausesPerType cpt : xpd.clausesPerTypes) {
        if (addExpressions) {
          cpt.addClausesTo(clauses);
          if (hasCountWithXpr) {
            String bnm=APIAccess.getBaseNodeName(cpt.domainObjectMatch);
            if (!depBases.contains(bnm))             depBases.add(bnm);
          }
        }
 else {
          if (this.countWithValidNodes != null)           this.countWithValidNodes.remove(ValueAccess.getName(cpt.node));
        }
      }
    }
  }
  if (hasCountWithXpr) {
    int sz=this.countWithValidNodes.size();
    for (int i=sz - 1; i >= 0; i--) {
      if (!isValidDependency(this.countWithValidNodes.get(i),depBases))       this.countWithValidNodes.remove(i);
    }
  }
}","private void addDependencyClauses(List<IClause> clauses,List<ClausesPerType> added){
  boolean hasCountWithXpr=this.countWithClausesIdxs != null;
  List<String> depBases=null;
  if (hasCountWithXpr)   depBases=new ArrayList<String>();
  if (this.expressionsPerDOM.flattenedDependencies != null) {
    for (    ExpressionsPerDOM xpd : this.expressionsPerDOM.flattenedDependencies) {
      List<DomainObjectMatch<?>> collOwner=APIAccess.getCollectExpressionOwner(xpd.domainObjectMatch);
      boolean addExpressions=collOwner == null || !collOwner.contains(this.domainObjectMatch);
      for (      ClausesPerType cpt : xpd.clausesPerTypes) {
        if (!added.contains(cpt)) {
          if (addExpressions) {
            cpt.addClausesTo(clauses);
            if (hasCountWithXpr) {
              String bnm=APIAccess.getBaseNodeName(cpt.domainObjectMatch);
              if (!depBases.contains(bnm))               depBases.add(bnm);
            }
          }
 else {
            if (this.countWithValidNodes != null)             this.countWithValidNodes.remove(ValueAccess.getName(cpt.node));
          }
          added.add(cpt);
        }
      }
    }
  }
  if (hasCountWithXpr) {
    int sz=this.countWithValidNodes.size();
    for (int i=sz - 1; i >= 0; i--) {
      if (!isValidDependency(this.countWithValidNodes.get(i),depBases))       this.countWithValidNodes.remove(i);
    }
  }
}",0.9545625234697708
80484,"@Test public void testDomainQuery_Collect_01(){
  IDomainAccess da1;
  DomainQuery q;
  DomainQueryResult result=null;
  boolean equals;
  String testId;
  String qCypher;
  Population population=new Population();
  population.createPopulation();
  da1=DomainAccessFactory.createDomainAccess(dbAccess,domainName);
  testId=""String_Node_Str"";
  queriesStream.reset();
  q=da1.createQuery();
  DomainObjectMatch<Subject> subjectsMatch=q.createMatch(Subject.class);
  DomainObjectMatch<Subject> subjectsMatch2=q.createMatch(Subject.class);
  q.ORDER(subjectsMatch).BY(""String_Node_Str"");
  subjectsMatch.setPage(0,5);
  q.ORDER(subjectsMatch2).BY(""String_Node_Str"");
  DomainObjectMatch<String> firstNamesMatch=q.COLLECT(subjectsMatch.atttribute(""String_Node_Str"")).AS(String.class);
  DomainObjectMatch<String> lastNamesMatch=q.COLLECT(subjectsMatch2.atttribute(""String_Node_Str"")).AS(String.class);
  CountQueryResult countResult=q.executeCount();
  result=q.execute();
  long numFirstNames=countResult.countOf(firstNamesMatch);
  long numLastNames=countResult.countOf(lastNamesMatch);
  long numSubjects=countResult.countOf(subjectsMatch);
  List<String> firstNames=result.resultOf(firstNamesMatch);
  List<String> lastNames=result.resultOf(lastNamesMatch);
  List<Subject> subjects=result.resultOf(subjectsMatch);
  testId=""String_Node_Str"";
  queriesStream.reset();
  q=da1.createQuery();
  DomainObjectMatch<Object> objectsMatch=q.createMatch(Object.class);
  q.WHERE(objectsMatch.atttribute(""String_Node_Str"")).LIKE(""String_Node_Str"");
  DomainObjectMatch<String> objNamesMatch=q.COLLECT(objectsMatch.atttribute(""String_Node_Str"")).AS(String.class);
  countResult=q.executeCount();
  result=q.execute();
  long numObjNames=countResult.countOf(objNamesMatch);
  List<String> objNames=result.resultOf(objNamesMatch);
  return;
}","@Test public void testDomainQuery_Collect_01(){
  IDomainAccess da1;
  DomainQuery q;
  DomainQueryResult result=null;
  boolean equals;
  String testId;
  String qCypher;
  Population population=new Population();
  population.createPopulation();
  da1=DomainAccessFactory.createDomainAccess(dbAccess,domainName);
  testId=""String_Node_Str"";
  queriesStream.reset();
  q=da1.createQuery();
  DomainObjectMatch<Subject> subjectsMatch=q.createMatch(Subject.class);
  DomainObjectMatch<Subject> subjectsMatch2=q.createMatch(Subject.class);
  q.ORDER(subjectsMatch).BY(""String_Node_Str"");
  q.ORDER(subjectsMatch2).BY(""String_Node_Str"");
  DomainObjectMatch<String> firstNamesMatch=q.COLLECT(subjectsMatch.atttribute(""String_Node_Str"")).AS(String.class);
  DomainObjectMatch<String> lastNamesMatch=q.COLLECT(subjectsMatch2.atttribute(""String_Node_Str"")).AS(String.class);
  CountQueryResult countResult=q.executeCount();
  result=q.execute();
  long numFirstNames=countResult.countOf(firstNamesMatch);
  long numLastNames=countResult.countOf(lastNamesMatch);
  long numSubjects=countResult.countOf(subjectsMatch);
  List<String> firstNames=result.resultOf(firstNamesMatch);
  List<String> lastNames=result.resultOf(lastNamesMatch);
  List<Subject> subjects=result.resultOf(subjectsMatch);
  testId=""String_Node_Str"";
  queriesStream.reset();
  q=da1.createQuery();
  DomainObjectMatch<Object> objectsMatch=q.createMatch(Object.class);
  q.WHERE(objectsMatch.atttribute(""String_Node_Str"")).LIKE(""String_Node_Str"");
  DomainObjectMatch<String> objNamesMatch=q.COLLECT(objectsMatch.atttribute(""String_Node_Str"")).AS(String.class);
  countResult=q.executeCount();
  result=q.execute();
  long numObjNames=countResult.countOf(objNamesMatch);
  List<String> objNames=result.resultOf(objNamesMatch);
  return;
}",0.9917355371900828
80485,"/** 
 * has one or more match clauses
 * @param domainObjectClass
 * @param context
 * @param ids
 * @return
 */
@SuppressWarnings(""String_Node_Str"") private <T>List<T> loadByIdsWithMatches(Class<T> domainObjectClass,ClosureQueryContext context,long... ids){
  List<T> resultList=new ArrayList<T>();
  JcQuery query;
  String nm=NodePrefix.concat(String.valueOf(0));
  List<JcQuery> queries=new ArrayList<JcQuery>();
  Map<Long,JcQueryResult> id2QueryResult=new HashMap<Long,JcQueryResult>();
  List<Long> queryIds=new ArrayList<Long>();
  Map<Long,T> id2Object=new HashMap<Long,T>();
  for (int i=0; i < ids.length; i++) {
    T obj=(T)this.domainState.getFrom_Id2ObjectMap(ids[i]);
    if (obj != null) {
      id2Object.put(ids[i],obj);
    }
 else {
      query=new JcQuery();
      JcNode n=new JcNode(nm);
      List<IClause> clauses=new ArrayList<IClause>();
      clauses.add(START.node(n).byId(ids[i]));
      clauses.addAll(context.matchClauses);
      clauses.add(RETURN.ALL());
      IClause[] clausesArray=clauses.toArray(new IClause[clauses.size()]);
      query.setClauses(clausesArray);
      queries.add(query);
      queryIds.add(ids[i]);
    }
  }
  if (queries.size() > 0) {
    Util.printQueries(queries,""String_Node_Str"",Format.PRETTY_1);
    List<JcQueryResult> results=this.dbAccess.execute(queries);
    List<JcError> errors=Util.collectErrors(results);
    if (errors.size() > 0) {
      throw new JcResultException(errors);
    }
    Util.printResults(results,""String_Node_Str"",Format.PRETTY_1);
    for (int i=0; i < queries.size(); i++) {
      id2QueryResult.put(queryIds.get(i),results.get(i));
    }
  }
  for (int i=0; i < ids.length; i++) {
    T obj=id2Object.get(ids[i]);
    if (obj == null) {
      FillModelContext<T> fContext=new FillModelContext<T>(domainObjectClass,id2QueryResult.get(ids[i]),context.queryEndNodes,context.recursionExitNodes);
      new ClosureCalculator().fillModel(fContext);
      obj=fContext.domainObject;
    }
    resultList.add(obj);
  }
  return resultList;
}","/** 
 * has one or more match clauses
 * @param domainObjectClass
 * @param context
 * @param ids
 * @return
 */
@SuppressWarnings(""String_Node_Str"") private <T>List<T> loadByIdsWithMatches(Class<T> domainObjectClass,ClosureQueryContext context,long... ids){
  List<T> resultList=new ArrayList<T>();
  JcQuery query;
  String nm=NodePrefix.concat(String.valueOf(0));
  List<JcQuery> queries=new ArrayList<JcQuery>();
  Map<Long,JcQueryResult> id2QueryResult=new HashMap<Long,JcQueryResult>();
  List<Long> queryIds=new ArrayList<Long>();
  Map<Long,T> id2Object=new HashMap<Long,T>();
  for (int i=0; i < ids.length; i++) {
    T obj=(T)this.domainState.getFrom_Id2ObjectMap(ids[i]);
    if (obj != null) {
      id2Object.put(ids[i],obj);
    }
 else {
      query=new JcQuery();
      JcNode n=new JcNode(nm);
      List<IClause> clauses=new ArrayList<IClause>();
      clauses.add(START.node(n).byId(ids[i]));
      clauses.addAll(context.matchClauses);
      clauses.add(RETURN.ALL());
      IClause[] clausesArray=clauses.toArray(new IClause[clauses.size()]);
      query.setClauses(clausesArray);
      queries.add(query);
      queryIds.add(ids[i]);
    }
  }
  if (queries.size() > 0) {
    Util.printQueries(queries,""String_Node_Str"",Format.PRETTY_1);
    List<JcQueryResult> results=this.dbAccess.execute(queries);
    List<JcError> errors=Util.collectErrors(results);
    if (errors.size() > 0) {
      throw new JcResultException(errors);
    }
    for (int i=0; i < queries.size(); i++) {
      id2QueryResult.put(queryIds.get(i),results.get(i));
    }
  }
  for (int i=0; i < ids.length; i++) {
    T obj=id2Object.get(ids[i]);
    if (obj == null) {
      FillModelContext<T> fContext=new FillModelContext<T>(domainObjectClass,id2QueryResult.get(ids[i]),context.queryEndNodes,context.recursionExitNodes);
      new ClosureCalculator().fillModel(fContext);
      obj=fContext.domainObject;
    }
    resultList.add(obj);
  }
  return resultList;
}",0.9834503510531596
80486,"private UpdateContext updateLocalGraph(List<Object> domainObjects){
  UpdateContext context=new UpdateContext();
  new ClosureCalculator().calculateClosure(domainObjects,context);
  Graph graph=null;
  Object domainObject;
  Map<Integer,QueryNode2ResultNode> nodeIndexMap=null;
  List<IClause> clauses=null;
  List<IClause> removeStartClauses=null;
  List<IClause> removeClauses=null;
  for (int i=0; i < context.domainObjects.size(); i++) {
    domainObject=context.domainObjects.get(i);
    Long id=this.domainState.getIdFrom_Object2IdMap(domainObject);
    if (id != null) {
      JcNode n=new JcNode(NodePrefix.concat(String.valueOf(i)));
      QueryNode2ResultNode n2n=new QueryNode2ResultNode();
      n2n.queryNode=n;
      if (nodeIndexMap == null)       nodeIndexMap=new HashMap<Integer,QueryNode2ResultNode>();
      nodeIndexMap.put(new Integer(i),n2n);
      if (clauses == null)       clauses=new ArrayList<IClause>();
      clauses.add(START.node(n).byId(id.longValue()));
    }
  }
  Map<Integer,QueryRelation2ResultRelation> relationIndexMap=null;
  for (int i=0; i < context.relations.size(); i++) {
    IRelation relat=context.relations.get(i);
    Long id=this.domainState.getFrom_Relation2IdMap(relat);
    if (id != null) {
      JcRelation r=new JcRelation(RelationPrefix.concat(String.valueOf(i)));
      QueryRelation2ResultRelation r2r=new QueryRelation2ResultRelation();
      r2r.queryRelation=r;
      if (relationIndexMap == null)       relationIndexMap=new HashMap<Integer,QueryRelation2ResultRelation>();
      relationIndexMap.put(new Integer(i),r2r);
      clauses.add(START.relation(r).byId(id.longValue()));
    }
  }
  if (context.relationsToRemove.size() > 0) {
    removeStartClauses=new ArrayList<IClause>();
    removeClauses=new ArrayList<IClause>();
    for (int i=0; i < context.relationsToRemove.size(); i++) {
      IRelation relat=context.relationsToRemove.get(i);
      Long id=this.domainState.getFrom_Relation2IdMap(relat);
      JcRelation r=new JcRelation(RelationPrefix.concat(String.valueOf(i)));
      removeStartClauses.add(START.relation(r).byId(id.longValue()));
      removeClauses.add(DO.DELETE(r));
    }
  }
  if (context.domainObjectsToRemove.size() > 0) {
    if (removeStartClauses == null) {
      removeStartClauses=new ArrayList<IClause>();
      removeClauses=new ArrayList<IClause>();
    }
    for (int i=0; i < context.domainObjectsToRemove.size(); i++) {
      Object dobj=context.domainObjectsToRemove.get(i);
      Long id=this.domainState.getIdFrom_Object2IdMap(dobj);
      JcNode n=new JcNode(NodePrefix.concat(String.valueOf(i)));
      removeStartClauses.add(START.node(n).byId(id.longValue()));
      removeClauses.add(DO.DELETE(n));
    }
  }
  if (clauses != null || removeStartClauses != null) {
    JcQuery query;
    List<JcQuery> queries=new ArrayList<JcQuery>();
    if (clauses != null) {
      clauses.add(RETURN.ALL());
      IClause[] clausesArray=clauses.toArray(new IClause[clauses.size()]);
      query=new JcQuery();
      query.setClauses(clausesArray);
      queries.add(query);
    }
    if (removeStartClauses != null) {
      removeStartClauses.addAll(removeClauses);
      query=new JcQuery();
      query.setClauses(removeStartClauses.toArray(new IClause[removeStartClauses.size()]));
      queries.add(query);
    }
    List<JcQueryResult> results=this.dbAccess.execute(queries);
    List<JcError> errors=Util.collectErrors(results);
    if (errors.size() > 0) {
      throw new JcResultException(errors);
    }
    if (clauses != null) {
      JcQueryResult result=results.get(0);
      graph=result.getGraph();
      if (nodeIndexMap != null) {
        Iterator<Entry<Integer,QueryNode2ResultNode>> nit=nodeIndexMap.entrySet().iterator();
        while (nit.hasNext()) {
          Entry<Integer,QueryNode2ResultNode> entry=nit.next();
          entry.getValue().resultNode=result.resultOf(entry.getValue().queryNode).get(0);
        }
      }
      if (relationIndexMap != null) {
        Iterator<Entry<Integer,QueryRelation2ResultRelation>> rit=relationIndexMap.entrySet().iterator();
        while (rit.hasNext()) {
          Entry<Integer,QueryRelation2ResultRelation> entry=rit.next();
          entry.getValue().resultRelation=result.resultOf(entry.getValue().queryRelation).get(0);
        }
      }
    }
  }
  if (graph == null)   graph=Graph.create(this.dbAccess);
  context.domObj2Node=new HashMap<Object,GrNode>(context.domainObjects.size());
  context.domRelation2Relations=new ArrayList<DomRelation2ResultRelation>();
  for (int i=0; i < context.domainObjects.size(); i++) {
    GrNode rNode=null;
    if (nodeIndexMap != null && nodeIndexMap.get(i) != null) {
      rNode=nodeIndexMap.get(i).resultNode;
    }
    if (rNode == null)     rNode=graph.createNode();
    context.domObj2Node.put(context.domainObjects.get(i),rNode);
    updateGraphFromObject(context.domainObjects.get(i),rNode);
  }
  for (int i=0; i < context.relations.size(); i++) {
    GrRelation rRelation=null;
    if (relationIndexMap != null && relationIndexMap.get(i) != null) {
      rRelation=relationIndexMap.get(i).resultRelation;
    }
    if (rRelation == null) {
      IRelation relat=context.relations.get(i);
      rRelation=graph.createRelation(relat.getType(),context.domObj2Node.get(relat.getStart()),context.domObj2Node.get(relat.getEnd()));
      DomRelation2ResultRelation d2r=new DomRelation2ResultRelation();
      d2r.domRelation=relat;
      d2r.resultRelation=rRelation;
      context.domRelation2Relations.add(d2r);
    }
    updateGraphFromRelation(context.relations.get(i),rRelation);
  }
  context.graph=graph;
  return context;
}","private UpdateContext updateLocalGraph(List<Object> domainObjects){
  UpdateContext context=new UpdateContext();
  new ClosureCalculator().calculateClosure(domainObjects,context);
  Graph graph=null;
  Object domainObject;
  Map<Integer,QueryNode2ResultNode> nodeIndexMap=null;
  List<IClause> clauses=null;
  List<IClause> removeStartClauses=null;
  List<IClause> removeClauses=null;
  for (int i=0; i < context.domainObjects.size(); i++) {
    domainObject=context.domainObjects.get(i);
    Long id=this.domainState.getIdFrom_Object2IdMap(domainObject);
    if (id != null) {
      JcNode n=new JcNode(NodePrefix.concat(String.valueOf(i)));
      QueryNode2ResultNode n2n=new QueryNode2ResultNode();
      n2n.queryNode=n;
      if (nodeIndexMap == null)       nodeIndexMap=new HashMap<Integer,QueryNode2ResultNode>();
      nodeIndexMap.put(new Integer(i),n2n);
      if (clauses == null)       clauses=new ArrayList<IClause>();
      clauses.add(START.node(n).byId(id.longValue()));
    }
  }
  Map<Integer,QueryRelation2ResultRelation> relationIndexMap=null;
  for (int i=0; i < context.relations.size(); i++) {
    IRelation relat=context.relations.get(i);
    Long id=this.domainState.getFrom_Relation2IdMap(relat);
    if (id != null) {
      JcRelation r=new JcRelation(RelationPrefix.concat(String.valueOf(i)));
      QueryRelation2ResultRelation r2r=new QueryRelation2ResultRelation();
      r2r.queryRelation=r;
      if (relationIndexMap == null)       relationIndexMap=new HashMap<Integer,QueryRelation2ResultRelation>();
      relationIndexMap.put(new Integer(i),r2r);
      clauses.add(START.relation(r).byId(id.longValue()));
    }
  }
  if (context.relationsToRemove.size() > 0) {
    removeStartClauses=new ArrayList<IClause>();
    removeClauses=new ArrayList<IClause>();
    for (int i=0; i < context.relationsToRemove.size(); i++) {
      IRelation relat=context.relationsToRemove.get(i);
      Long id=this.domainState.getFrom_Relation2IdMap(relat);
      JcRelation r=new JcRelation(RelationPrefix.concat(String.valueOf(i)));
      removeStartClauses.add(START.relation(r).byId(id.longValue()));
      removeClauses.add(DO.DELETE(r));
    }
  }
  if (context.domainObjectsToRemove.size() > 0) {
    if (removeStartClauses == null) {
      removeStartClauses=new ArrayList<IClause>();
      removeClauses=new ArrayList<IClause>();
    }
    for (int i=0; i < context.domainObjectsToRemove.size(); i++) {
      Object dobj=context.domainObjectsToRemove.get(i);
      Long id=this.domainState.getIdFrom_Object2IdMap(dobj);
      JcNode n=new JcNode(NodePrefix.concat(String.valueOf(i)));
      removeStartClauses.add(START.node(n).byId(id.longValue()));
      removeClauses.add(DO.DELETE(n));
    }
  }
  if (clauses != null || removeStartClauses != null) {
    JcQuery query;
    List<JcQuery> queries=new ArrayList<JcQuery>();
    if (clauses != null) {
      clauses.add(RETURN.ALL());
      IClause[] clausesArray=clauses.toArray(new IClause[clauses.size()]);
      query=new JcQuery();
      query.setClauses(clausesArray);
      queries.add(query);
    }
    if (removeStartClauses != null) {
      removeStartClauses.addAll(removeClauses);
      query=new JcQuery();
      query.setClauses(removeStartClauses.toArray(new IClause[removeStartClauses.size()]));
      queries.add(query);
    }
    List<JcQueryResult> results=this.dbAccess.execute(queries);
    List<JcError> errors=Util.collectErrors(results);
    if (errors.size() > 0) {
      throw new JcResultException(errors);
    }
    if (clauses != null) {
      JcQueryResult result=results.get(0);
      graph=result.getGraph();
      GrAccess.setDBAccess(this.dbAccess,graph);
      if (nodeIndexMap != null) {
        Iterator<Entry<Integer,QueryNode2ResultNode>> nit=nodeIndexMap.entrySet().iterator();
        while (nit.hasNext()) {
          Entry<Integer,QueryNode2ResultNode> entry=nit.next();
          entry.getValue().resultNode=result.resultOf(entry.getValue().queryNode).get(0);
        }
      }
      if (relationIndexMap != null) {
        Iterator<Entry<Integer,QueryRelation2ResultRelation>> rit=relationIndexMap.entrySet().iterator();
        while (rit.hasNext()) {
          Entry<Integer,QueryRelation2ResultRelation> entry=rit.next();
          entry.getValue().resultRelation=result.resultOf(entry.getValue().queryRelation).get(0);
        }
      }
    }
  }
  if (graph == null)   graph=Graph.create(this.dbAccess);
  context.domObj2Node=new HashMap<Object,GrNode>(context.domainObjects.size());
  context.domRelation2Relations=new ArrayList<DomRelation2ResultRelation>();
  for (int i=0; i < context.domainObjects.size(); i++) {
    GrNode rNode=null;
    if (nodeIndexMap != null && nodeIndexMap.get(i) != null) {
      rNode=nodeIndexMap.get(i).resultNode;
    }
    if (rNode == null)     rNode=graph.createNode();
    context.domObj2Node.put(context.domainObjects.get(i),rNode);
    updateGraphFromObject(context.domainObjects.get(i),rNode);
  }
  for (int i=0; i < context.relations.size(); i++) {
    GrRelation rRelation=null;
    if (relationIndexMap != null && relationIndexMap.get(i) != null) {
      rRelation=relationIndexMap.get(i).resultRelation;
    }
    if (rRelation == null) {
      IRelation relat=context.relations.get(i);
      rRelation=graph.createRelation(relat.getType(),context.domObj2Node.get(relat.getStart()),context.domObj2Node.get(relat.getEnd()));
      DomRelation2ResultRelation d2r=new DomRelation2ResultRelation();
      d2r.domRelation=relat;
      d2r.resultRelation=rRelation;
      context.domRelation2Relations.add(d2r);
    }
    updateGraphFromRelation(context.relations.get(i),rRelation);
  }
  context.graph=graph;
  return context;
}",0.995678631272599
80487,"/** 
 * @param typ
 * @return true if the type was added to the compound,false if the type was already contained in the compound
 */
public boolean addType(Class<?> typ){
  CompoundObjectType cur=null;
  Iterator<CompoundObjectType> it=typeIterator();
  while (it.hasNext()) {
    cur=it.next();
    if (cur.type.equals(typ))     return false;
  }
  CompoundObjectType nextOne=new CompoundObjectType(typ);
  cur.next=nextOne;
  return true;
}","/** 
 * @param typ
 * @return true if the type was added to the compound,false if the type was already contained in the compound
 */
public boolean addType(Class<?> typ){
  CompoundObjectType cur=null;
  Iterator<CompoundObjectType> it=typeIterator();
  while (it.hasNext()) {
    cur=it.next();
    if (cur.type.equals(typ))     return false;
  }
  CompoundObjectType nextOne=new CompoundObjectType(typ);
  cur.next=nextOne;
  CType t=nextOne.cType;
  it=typeIterator();
  while (it.hasNext()) {
    cur=it.next();
    if (cur.cType != t)     cur.cType=CType.MIXED;
  }
  return true;
}",0.8338192419825073
80488,"public CompoundObjectType(Class<?> type){
  super();
  this.type=type;
}","public CompoundObjectType(Class<?> type){
  super();
  this.type=type;
  this.cType=MappingUtil.mapsToProperty(type) ? CType.SIMPLE : CType.COMPLEX;
}",0.6486486486486487
80489,"/** 
 * @return true, if this field cannot be mapped to a property,but must be mapped to a seperate node connected via a relation, else return false.
 */
public boolean needsRelation(){
  boolean needRelation=!MappingUtil.mapsToProperty(this.field.getType());
  if (needRelation) {
    String classField=getClassFieldName();
    CompoundObjectType cType=MappingUtil.internalDomainAccess.get().getConcreteFieldType(classField);
    if (cType != null && MappingUtil.mapsToProperty(cType.getType()))     return false;
 else {
      if (Collection.class.isAssignableFrom(this.field.getType())) {
        cType=MappingUtil.internalDomainAccess.get().getFieldComponentType(classField);
        if (cType != null) {
          needRelation=!MappingUtil.mapsToProperty(cType.getType());
        }
 else         needRelation=true;
      }
    }
  }
  return needRelation;
}","/** 
 * @return true, if this field cannot be mapped to a property,but must be mapped to a seperate node connected via a relation, else return false.
 */
public boolean needsRelation(){
  boolean needRelation=!MappingUtil.mapsToProperty(this.field.getType());
  if (needRelation) {
    String classField=getClassFieldName();
    CompoundObjectType cType=MappingUtil.internalDomainAccess.get().getConcreteFieldType(classField);
    if (cType != null && cType.getCType() == CType.SIMPLE)     return false;
 else {
      if (Collection.class.isAssignableFrom(this.field.getType())) {
        cType=MappingUtil.internalDomainAccess.get().getFieldComponentType(classField);
        if (cType != null) {
          needRelation=cType.getCType() != CType.SIMPLE;
        }
 else         needRelation=true;
      }
    }
  }
  return needRelation;
}",0.5778038755137992
80490,"public void mapPropertyFromField(Object domainObject,GrNode rNode){
  try {
    prepare(domainObject);
    if (getObjectNeedingRelation(domainObject) == null) {
      Object value=this.field.get(domainObject);
      value=MappingUtil.convertToProperty(value);
      GrProperty prop=rNode.getProperty(this.propertyName);
      if (value != null) {
        if (prop != null) {
          Object propValue=MappingUtil.convertFromProperty(prop.getValue(),value.getClass(),getListComponentType());
          if (!propValue.equals(value)) {
            prop.setValue(value);
          }
        }
 else         rNode.addProperty(this.propertyName,value);
      }
 else {
        if (prop != null)         prop.setValue(null);
      }
    }
 else {
      if (Collection.class.isAssignableFrom(getFieldType())) {
        GrProperty prop=rNode.getProperty(this.propertyName);
        if (prop != null)         prop.setValue(null);
      }
    }
  }
 catch (  Throwable e) {
    throw new RuntimeException(e);
  }
}","public void mapPropertyFromField(Object domainObject,GrNode rNode){
  try {
    prepare(domainObject);
    if (getObjectNeedingRelation(domainObject) == null) {
      Object value=this.field.get(domainObject);
      value=MappingUtil.convertToProperty(value);
      GrProperty prop=rNode.getProperty(this.propertyName);
      if (value != null) {
        if (prop != null) {
          Object propValue=MappingUtil.convertFromProperty(prop.getValue(),value.getClass(),getListComponentType());
          if (!propValue.equals(value)) {
            addSimpleListComponentType2DomainInfo(value);
            prop.setValue(value);
          }
        }
 else         rNode.addProperty(this.propertyName,value);
      }
 else {
        if (prop != null)         prop.setValue(null);
      }
    }
 else {
      if (Collection.class.isAssignableFrom(getFieldType())) {
        GrProperty prop=rNode.getProperty(this.propertyName);
        if (prop != null)         prop.setValue(null);
      }
    }
  }
 catch (  Throwable e) {
    throw new RuntimeException(e);
  }
}",0.9719264278799612
80491,"public void testMapAny2Any(){
  List<JcError> errors;
  DomainAccess da=new DomainAccess(dbAccess,domainName);
  DomainAccess da1;
  MapContainer mapContainer=new MapContainer();
  MapContainer mapContainer_1;
  boolean equals;
  buildMapTestAny2Any(mapContainer);
  errors=dbAccess.clearDatabase();
  if (errors.size() > 0) {
    printErrors(errors);
    throw new JcResultException(errors);
  }
  errors=da.store(mapContainer);
  if (errors.size() > 0) {
    printErrors(errors);
    throw new JcResultException(errors);
  }
  SyncInfo syncInfo_1=da.getSyncInfo(mapContainer);
  da1=new DomainAccess(dbAccess,domainName);
  mapContainer_1=da1.loadById(MapContainer.class,syncInfo_1.getId());
  equals=CompareUtil_3.equalsMapContainer(mapContainer,mapContainer_1);
  assertTrue(equals);
  if (true)   return;
  mapContainer.getString2IntegerMap().put(""String_Node_Str"",2);
  mapContainer.getString2IntegerMap().put(""String_Node_Str"",3);
  mapContainer.getString2IntegerMap().remove(""String_Node_Str"");
  errors=da.store(mapContainer);
  if (errors.size() > 0) {
    printErrors(errors);
    throw new JcResultException(errors);
  }
  mapContainer.getString2IntegerMap().remove(""String_Node_Str"");
  mapContainer.getString2IntegerMap().remove(""String_Node_Str"");
  errors=da.store(mapContainer);
  if (errors.size() > 0) {
    printErrors(errors);
    throw new JcResultException(errors);
  }
  return;
}","@Test public void testMapAny2Any(){
  List<JcError> errors;
  DomainAccess da=new DomainAccess(dbAccess,domainName);
  DomainAccess da1;
  MapContainer mapContainer=new MapContainer();
  MapContainer mapContainer_1;
  boolean equals;
  buildMapTestAny2Any(mapContainer);
  errors=dbAccess.clearDatabase();
  if (errors.size() > 0) {
    printErrors(errors);
    throw new JcResultException(errors);
  }
  errors=da.store(mapContainer);
  if (errors.size() > 0) {
    printErrors(errors);
    throw new JcResultException(errors);
  }
  SyncInfo syncInfo_1=da.getSyncInfo(mapContainer);
  da1=new DomainAccess(dbAccess,domainName);
  mapContainer_1=da1.loadById(MapContainer.class,syncInfo_1.getId());
  equals=CompareUtil_3.equalsMapContainer(mapContainer,mapContainer_1);
  assertTrue(equals);
  if (true)   return;
  mapContainer.getString2IntegerMap().put(""String_Node_Str"",2);
  mapContainer.getString2IntegerMap().put(""String_Node_Str"",3);
  mapContainer.getString2IntegerMap().remove(""String_Node_Str"");
  errors=da.store(mapContainer);
  if (errors.size() > 0) {
    printErrors(errors);
    throw new JcResultException(errors);
  }
  mapContainer.getString2IntegerMap().remove(""String_Node_Str"");
  mapContainer.getString2IntegerMap().remove(""String_Node_Str"");
  errors=da.store(mapContainer);
  if (errors.size() > 0) {
    printErrors(errors);
    throw new JcResultException(errors);
  }
  return;
}",0.997867803837953
80492,"@SuppressWarnings(""String_Node_Str"") @Test public void testUpdateSimple_EmptyList2NotEmptyList(){
  List<JcError> errors;
  DomainAccess da=new DomainAccess(dbAccess,domainName);
  Person john=new Person();
  Address address=new Address();
  Contact phone=new Contact();
  Contact email=new Contact();
  Person james=new Person();
  Company skynet=new Company();
  Company globCom=new Company();
  buildInitialDomainObjects_1(john,james,address,phone,email,skynet,globCom);
  errors=dbAccess.clearDatabase();
  if (errors.size() > 0) {
    printErrors(errors);
    throw new JcResultException(errors);
  }
  errors=da.store(globCom);
  if (errors.size() > 0) {
    printErrors(errors);
    throw new JcResultException(errors);
  }
  SyncInfo syncInfo=da.getSyncInfo(globCom);
  globCom.getAreaCodes().add(2);
  globCom.getAreaCodes().add(3);
  errors=da.store(globCom);
  if (errors.size() > 0) {
    printErrors(errors);
    throw new JcResultException(errors);
  }
  da=new DomainAccess(dbAccess,domainName);
  Company globCom_1;
  globCom_1=da.loadById(Company.class,syncInfo.getId());
  boolean isEqual=CompareUtil.equalsCompany(globCom,globCom_1);
  assertTrue(""String_Node_Str"",isEqual);
  da=new DomainAccess(dbAccess,domainName);
  james.setLuckyNumbers(new ArrayList<Integer>());
  errors=da.store(james);
  if (errors.size() > 0) {
    printErrors(errors);
    throw new JcResultException(errors);
  }
  syncInfo=da.getSyncInfo(james);
  james.getLuckyNumbers().add(24);
  james.getLuckyNumbers().add(48);
  errors=da.store(james);
  if (errors.size() > 0) {
    printErrors(errors);
    throw new JcResultException(errors);
  }
  da=new DomainAccess(dbAccess,domainName);
  Person james_1;
  james_1=da.loadById(Person.class,syncInfo.getId());
  isEqual=CompareUtil.equalsPerson(james,james_1);
  assertTrue(""String_Node_Str"",isEqual);
  return;
}","@SuppressWarnings(""String_Node_Str"") public void testUpdateSimple_EmptyList2NotEmptyList(){
  List<JcError> errors;
  DomainAccess da=new DomainAccess(dbAccess,domainName);
  DomainAccess da1;
  Person john=new Person();
  Address address=new Address();
  Contact phone=new Contact();
  Contact email=new Contact();
  Person james=new Person();
  Company skynet=new Company();
  Company globCom=new Company();
  buildInitialDomainObjects_1(john,james,address,phone,email,skynet,globCom);
  errors=dbAccess.clearDatabase();
  if (errors.size() > 0) {
    printErrors(errors);
    throw new JcResultException(errors);
  }
  errors=da.store(globCom);
  if (errors.size() > 0) {
    printErrors(errors);
    throw new JcResultException(errors);
  }
  SyncInfo syncInfo=da.getSyncInfo(globCom);
  da1=new DomainAccess(dbAccess,domainName);
  Company globCom_1;
  globCom_1=da1.loadById(Company.class,syncInfo.getId());
  boolean isEqual=CompareUtil.equalsCompany(globCom,globCom_1);
  assertTrue(""String_Node_Str"",isEqual);
  globCom.getAreaCodes().add(2);
  globCom.getAreaCodes().add(3);
  errors=da.store(globCom);
  if (errors.size() > 0) {
    printErrors(errors);
    throw new JcResultException(errors);
  }
  da1=new DomainAccess(dbAccess,domainName);
  globCom_1=da1.loadById(Company.class,syncInfo.getId());
  isEqual=CompareUtil.equalsCompany(globCom,globCom_1);
  assertTrue(""String_Node_Str"",isEqual);
  james.setLuckyNumbers(new ArrayList<Integer>());
  errors=da.store(james);
  if (errors.size() > 0) {
    printErrors(errors);
    throw new JcResultException(errors);
  }
  syncInfo=da.getSyncInfo(james);
  da1=new DomainAccess(dbAccess,domainName);
  Person james_1;
  james_1=da1.loadById(Person.class,syncInfo.getId());
  isEqual=CompareUtil.equalsPerson(james,james_1);
  assertTrue(""String_Node_Str"",isEqual);
  james.getLuckyNumbers().add(24);
  james.getLuckyNumbers().add(48);
  errors=da.store(james);
  if (errors.size() > 0) {
    printErrors(errors);
    throw new JcResultException(errors);
  }
  da1=new DomainAccess(dbAccess,domainName);
  james_1=da1.loadById(Person.class,syncInfo.getId());
  isEqual=CompareUtil.equalsPerson(james,james_1);
  assertTrue(""String_Node_Str"",isEqual);
  return;
}",0.6246937775600196
80493,"/** 
 * has one or more match clauses
 * @param domainObjectClass
 * @param context
 * @param ids
 * @return
 */
@SuppressWarnings(""String_Node_Str"") private <T>List<T> loadByIdsWithMatches(Class<T> domainObjectClass,ClosureQueryContext context,long... ids){
  List<T> resultList=new ArrayList<T>();
  JcQuery query;
  String nm=NodePrefix.concat(String.valueOf(0));
  List<JcQuery> queries=new ArrayList<JcQuery>();
  Map<Long,JcQueryResult> id2QueryResult=new HashMap<Long,JcQueryResult>();
  List<Long> queryIds=new ArrayList<Long>();
  Map<Long,T> id2Object=new HashMap<Long,T>();
  for (int i=0; i < ids.length; i++) {
    T obj=(T)this.domainState.getFrom_Id2ObjectMap(ids[i]);
    if (obj != null) {
      id2Object.put(ids[i],obj);
    }
 else {
      query=new JcQuery();
      JcNode n=new JcNode(nm);
      List<IClause> clauses=new ArrayList<IClause>();
      clauses.add(START.node(n).byId(ids[i]));
      clauses.addAll(context.matchClauses);
      clauses.add(RETURN.ALL());
      IClause[] clausesArray=clauses.toArray(new IClause[clauses.size()]);
      query.setClauses(clausesArray);
      queries.add(query);
      queryIds.add(ids[i]);
    }
  }
  if (queries.size() > 0) {
    Util.printQueries(queries,""String_Node_Str"",Format.PRETTY_1);
    List<JcQueryResult> results=this.dbAccess.execute(queries);
    List<JcError> errors=Util.collectErrors(results);
    if (errors.size() > 0) {
      throw new JcResultException(errors);
    }
    Util.printResults(results,""String_Node_Str"",Format.PRETTY_1);
    for (int i=0; i < queries.size(); i++) {
      id2QueryResult.put(queryIds.get(i),results.get(i));
    }
  }
  for (int i=0; i < ids.length; i++) {
    T obj=id2Object.get(ids[i]);
    if (obj == null) {
      FillModelContext<T> fContext=new FillModelContext<T>(domainObjectClass,id2QueryResult.get(ids[i]),context.queryEndNodes);
      new ClosureCalculator().fillModel(fContext);
      obj=fContext.domainObject;
    }
    resultList.add(obj);
  }
  return resultList;
}","/** 
 * has one or more match clauses
 * @param domainObjectClass
 * @param context
 * @param ids
 * @return
 */
@SuppressWarnings(""String_Node_Str"") private <T>List<T> loadByIdsWithMatches(Class<T> domainObjectClass,ClosureQueryContext context,long... ids){
  List<T> resultList=new ArrayList<T>();
  JcQuery query;
  String nm=NodePrefix.concat(String.valueOf(0));
  List<JcQuery> queries=new ArrayList<JcQuery>();
  Map<Long,JcQueryResult> id2QueryResult=new HashMap<Long,JcQueryResult>();
  List<Long> queryIds=new ArrayList<Long>();
  Map<Long,T> id2Object=new HashMap<Long,T>();
  for (int i=0; i < ids.length; i++) {
    T obj=(T)this.domainState.getFrom_Id2ObjectMap(ids[i]);
    if (obj != null) {
      id2Object.put(ids[i],obj);
    }
 else {
      query=new JcQuery();
      JcNode n=new JcNode(nm);
      List<IClause> clauses=new ArrayList<IClause>();
      clauses.add(START.node(n).byId(ids[i]));
      clauses.addAll(context.matchClauses);
      clauses.add(RETURN.ALL());
      IClause[] clausesArray=clauses.toArray(new IClause[clauses.size()]);
      query.setClauses(clausesArray);
      queries.add(query);
      queryIds.add(ids[i]);
    }
  }
  if (queries.size() > 0) {
    Util.printQueries(queries,""String_Node_Str"",Format.PRETTY_1);
    List<JcQueryResult> results=this.dbAccess.execute(queries);
    List<JcError> errors=Util.collectErrors(results);
    if (errors.size() > 0) {
      throw new JcResultException(errors);
    }
    Util.printResults(results,""String_Node_Str"",Format.PRETTY_1);
    for (int i=0; i < queries.size(); i++) {
      id2QueryResult.put(queryIds.get(i),results.get(i));
    }
  }
  for (int i=0; i < ids.length; i++) {
    T obj=id2Object.get(ids[i]);
    if (obj == null) {
      FillModelContext<T> fContext=new FillModelContext<T>(domainObjectClass,id2QueryResult.get(ids[i]),context.queryEndNodes,context.recursionExitNodes);
      new ClosureCalculator().fillModel(fContext);
      obj=fContext.domainObject;
    }
    resultList.add(obj);
  }
  return resultList;
}",0.9932952570151478
80494,"/** 
 * @param context
 * @param fm
 * @param fieldIndex
 * @param level
 * @return true, if this leads to a null value
 */
@SuppressWarnings(""String_Node_Str"") private <T>boolean fillModel(FillModelContext<T> context,FieldMapping fm){
  int prevClauseRepetitionNumber=context.clauseRepetitionNumber;
  boolean isNullNode=false;
  String nnm=this.buildNodeOrRelationName(context.path,DomainAccessHandler.NodePrefix,context.clauseRepetitionNumber);
  context.setTerminatesClause(nnm);
  CompoundObjectType compoundType;
  if (fm == null)   compoundType=domainAccessHandler.getCompoundTypeFor(context.domainObjectClass);
 else {
    String classFieldName=fm.getClassFieldName();
    compoundType=MappingUtil.internalDomainAccess.get().getConcreteFieldType(classFieldName);
  }
  Class<? extends Object> pureType=fm != null ? fm.getFieldType() : context.domainObjectClass;
  if (compoundType != null) {
    context.path.add(new PathElement(pureType));
    boolean resolveDeep=true;
    if (context.queryEndNodes.contains(nnm)) {
      resolveDeep=false;
    }
    boolean isCollection=Collection.class.isAssignableFrom(pureType);
    Collection<Object> collection=null;
    if (isCollection) {
      String classFieldName=fm.getClassFieldName();
      collection=(Collection<Object>)domainAccessHandler.createInstance(MappingUtil.internalDomainAccess.get().getConcreteFieldType(classFieldName).getType());
      compoundType=MappingUtil.internalDomainAccess.get().getFieldComponentType(classFieldName);
    }
    JcNode n=new JcNode(nnm);
    List<GrNode> resList=context.qResult.resultOf(n);
    Object domainObject=null;
    if (resList.size() > 0) {
      for (      GrNode rNode : resList) {
        if (rNode != null) {
          boolean performMapping=false;
          boolean mapProperties=true;
          domainObject=domainAccessHandler.domainState.getFrom_Id2ObjectMap(rNode.getId());
          if (domainObject == null) {
            Class<?> clazz=domainAccessHandler.findClassToInstantiateFor(rNode);
            domainObject=domainAccessHandler.createInstance(clazz);
            domainAccessHandler.domainState.add_Id2Object(domainObject,rNode.getId(),resolveDeep ? ResolutionDepth.DEEP : ResolutionDepth.SHALLOW);
            performMapping=true;
          }
 else {
            if (resolveDeep && domainAccessHandler.domainState.getResolutionDepth(domainObject) != ResolutionDepth.DEEP) {
              performMapping=true;
              mapProperties=false;
            }
          }
          if (fm == null) {
            context.domainObject=(T)domainObject;
          }
          if (performMapping) {
            ObjectMapping objectMapping=domainAccessHandler.getCompoundObjectMappingFor(compoundType,domainObject.getClass());
            Iterator<FieldMapping> it=objectMapping.fieldMappingsIterator();
            int idx=0;
            while (it.hasNext()) {
              FieldMapping fMap=it.next();
              idx++;
              if (!objectMapping.shouldPerformFieldMapping(fMap)) {
                if (fMap.needsRelation() && resolveDeep) {
                  calculateMaxClauseRepetitionNumber(context,fMap,idx);
                }
                continue;
              }
              if (fMap.needsRelation() && resolveDeep) {
                context.currentObject=null;
                PathElement pe=context.getLastPathElement();
                pe.fieldIndex=idx;
                context.clauseRepetitionNumber=context.maxClauseRepetitionNumber;
                pe.fieldName=fMap.getFieldName();
                boolean nodeIsNull=this.fillModel(context,fMap);
                context.alreadyTested.clear();
                while (nodeIsNull && morePathsToTest(context,fMap,idx)) {
                  context.currentObject=null;
                  pe=context.getLastPathElement();
                  pe.fieldIndex=idx;
                  context.clauseRepetitionNumber=context.maxClauseRepetitionNumber;
                  pe.fieldName=fMap.getFieldName();
                  nodeIsNull=this.fillModel(context,fMap);
                }
                if (!nodeIsNull && context.currentObject != null) {
                  fMap.setField(domainObject,context.currentObject);
                  String rnm=this.buildNodeOrRelationName(context.path,DomainAccessHandler.RelationPrefix,context.clauseRepetitionNumber);
                  JcRelation r=new JcRelation(rnm);
                  List<GrRelation> relList=context.qResult.resultOf(r);
                  GrRelation rel=relList.get(0);
                  domainAccessHandler.domainState.add_Id2Relation(new Relation(fMap.getPropertyOrRelationName(),domainObject,context.currentObject),rel.getId());
                }
 else                 if (nodeIsNull && fMap.isCollection()) {
                  fMap.mapPropertyToField(domainObject,rNode);
                }
                context.updateMaxClauseRepetitionNumber();
              }
 else {
                if (mapProperties)                 fMap.mapPropertyToField(domainObject,rNode);
              }
            }
          }
          if (isCollection)           collection.add(domainObject);
        }
 else {
          isNullNode=true;
        }
      }
    }
    if (isCollection)     context.currentObject=collection;
 else     context.currentObject=domainObject;
    context.path.remove(context.path.size() - 1);
  }
  context.clauseRepetitionNumber=prevClauseRepetitionNumber;
  return isNullNode;
}","/** 
 * @param context
 * @param fm may be null
 * @param nodeName may be null
 * @return true, if this leads to a null value
 */
@SuppressWarnings(""String_Node_Str"") private <T>boolean fillModel(FillModelContext<T> context,FieldMapping fm,String nodeName){
  int prevClauseRepetitionNumber=context.clauseRepetitionNumber;
  boolean isNullNode=false;
  String nnm;
  if (nodeName != null)   nnm=nodeName;
 else   nnm=this.buildNodeOrRelationName(context.path,DomainAccessHandler.NodePrefix,context.clauseRepetitionNumber);
  context.setTerminatesClause(nnm);
  CompoundObjectType compoundType;
  if (fm == null)   compoundType=domainAccessHandler.getCompoundTypeFor(context.domainObjectClass);
 else {
    String classFieldName=fm.getClassFieldName();
    compoundType=MappingUtil.internalDomainAccess.get().getConcreteFieldType(classFieldName);
  }
  Class<? extends Object> pureType=fm != null ? fm.getFieldType() : context.domainObjectClass;
  if (compoundType != null) {
    context.path.add(new PathElement(pureType));
    boolean resolveDeep=true;
    if (context.recursionExitNodes.contains(nnm)) {
      resolveDeep=false;
    }
    boolean isCollection=Collection.class.isAssignableFrom(pureType);
    Collection<Object> collection=null;
    if (isCollection) {
      String classFieldName=fm.getClassFieldName();
      collection=(Collection<Object>)domainAccessHandler.createInstance(MappingUtil.internalDomainAccess.get().getConcreteFieldType(classFieldName).getType());
      compoundType=MappingUtil.internalDomainAccess.get().getFieldComponentType(classFieldName);
    }
    JcNode n=new JcNode(nnm);
    List<GrNode> resList=context.qResult.resultOf(n);
    Object domainObject=null;
    if (resList.size() > 0) {
      for (      GrNode rNode : resList) {
        if (rNode != null) {
          boolean performMapping=false;
          boolean mapProperties=true;
          domainObject=domainAccessHandler.domainState.getFrom_Id2ObjectMap(rNode.getId());
          if (domainObject == null) {
            Class<?> clazz=domainAccessHandler.findClassToInstantiateFor(rNode);
            domainObject=domainAccessHandler.createInstance(clazz);
            domainAccessHandler.domainState.add_Id2Object(domainObject,rNode.getId(),resolveDeep ? ResolutionDepth.DEEP : ResolutionDepth.SHALLOW);
            performMapping=true;
          }
 else {
            if (resolveDeep && domainAccessHandler.domainState.getResolutionDepth(domainObject) != ResolutionDepth.DEEP) {
              performMapping=true;
              mapProperties=false;
            }
          }
          if (fm == null) {
            context.domainObject=(T)domainObject;
          }
          if (performMapping) {
            ObjectMapping objectMapping=domainAccessHandler.getCompoundObjectMappingFor(compoundType,domainObject.getClass());
            Iterator<FieldMapping> it=objectMapping.fieldMappingsIterator();
            int idx=0;
            while (it.hasNext()) {
              FieldMapping fMap=it.next();
              idx++;
              if (!objectMapping.shouldPerformFieldMapping(fMap)) {
                if (fMap.needsRelation() && resolveDeep) {
                  calculateMaxClauseRepetitionNumber(context,fMap,idx);
                }
                continue;
              }
              if (fMap.needsRelation() && resolveDeep) {
                context.currentObject=null;
                PathElement pe=context.getLastPathElement();
                pe.fieldIndex=idx;
                context.clauseRepetitionNumber=context.maxClauseRepetitionNumber;
                pe.fieldName=fMap.getFieldName();
                String ndName=this.buildNodeOrRelationName(context.path,DomainAccessHandler.NodePrefix,context.clauseRepetitionNumber);
                boolean nodeIsNull=false;
                boolean needToRepeat=false;
                if (isValidNodeName(ndName,context))                 nodeIsNull=this.fillModel(context,fMap,ndName);
 else                 needToRepeat=true;
                context.alreadyTested.clear();
                while (needToRepeat && morePathsToTest(context,fMap,idx)) {
                  context.currentObject=null;
                  pe=context.getLastPathElement();
                  pe.fieldIndex=idx;
                  context.clauseRepetitionNumber=context.maxClauseRepetitionNumber;
                  pe.fieldName=fMap.getFieldName();
                  ndName=this.buildNodeOrRelationName(context.path,DomainAccessHandler.NodePrefix,context.clauseRepetitionNumber);
                  needToRepeat=false;
                  if (isValidNodeName(ndName,context))                   nodeIsNull=this.fillModel(context,fMap,ndName);
 else {
                    if (moreClausesAvailable(ndName,context))                     needToRepeat=true;
                  }
                }
                if (!nodeIsNull && context.currentObject != null) {
                  fMap.setField(domainObject,context.currentObject);
                  String rnm=this.buildNodeOrRelationName(context.path,DomainAccessHandler.RelationPrefix,context.clauseRepetitionNumber);
                  JcRelation r=new JcRelation(rnm);
                  List<GrRelation> relList=context.qResult.resultOf(r);
                  GrRelation rel=relList.get(0);
                  domainAccessHandler.domainState.add_Id2Relation(new Relation(fMap.getPropertyOrRelationName(),domainObject,context.currentObject),rel.getId());
                }
 else                 if (nodeIsNull && fMap.isCollection()) {
                  fMap.mapPropertyToField(domainObject,rNode);
                }
                context.updateMaxClauseRepetitionNumber();
              }
 else {
                if (mapProperties)                 fMap.mapPropertyToField(domainObject,rNode);
              }
            }
          }
          if (isCollection)           collection.add(domainObject);
        }
 else {
          isNullNode=true;
        }
      }
    }
    if (isCollection)     context.currentObject=collection;
 else     context.currentObject=domainObject;
    context.path.remove(context.path.size() - 1);
  }
  context.clauseRepetitionNumber=prevClauseRepetitionNumber;
  return isNullNode;
}",0.8124731552272142
80495,"ClosureQueryContext(Class<?> domainObjectClass){
  super();
  this.domainObjectClass=domainObjectClass;
  this.path=new ArrayList<PathElement>();
  this.queryEndNodes=new ArrayList<String>();
}","private ClosureQueryContext(Class<?> domainObjectClass){
  super();
  this.domainObjectClass=domainObjectClass;
  this.path=new ArrayList<PathElement>();
  this.queryEndNodes=new ArrayList<String>();
  this.recursionExitNodes=new ArrayList<String>();
}",0.8674157303370786
80496,"<T>List<T> loadByIds(Class<T> domainObjectClass,long... ids){
  List<T> resultList;
  InternalDomainAccess internalAccess=null;
  ClosureQueryContext context=new ClosureQueryContext(domainObjectClass);
  try {
    internalAccess=MappingUtil.internalDomainAccess.get();
    MappingUtil.internalDomainAccess.set(new InternalDomainAccess());
    updateMappingsIfNeeded();
    new ClosureCalculator().calculateClosureQuery(context);
    boolean repeat=context.matchClauses != null && context.matchClauses.size() > 0;
    if (repeat) {
      resultList=loadByIdsWithMatches(domainObjectClass,context,ids);
    }
 else {
      resultList=loadByIdsSimple(domainObjectClass,ids);
    }
  }
  finally {
    if (internalAccess != null)     MappingUtil.internalDomainAccess.set(internalAccess);
 else     MappingUtil.internalDomainAccess.remove();
  }
  return resultList;
}","<T>List<T> loadByIds(Class<T> domainObjectClass,long... ids){
  List<T> resultList;
  InternalDomainAccess internalAccess=null;
  ClosureQueryContext context=new ClosureQueryContext(domainObjectClass);
  try {
    internalAccess=MappingUtil.internalDomainAccess.get();
    MappingUtil.internalDomainAccess.set(new InternalDomainAccess());
    updateMappingsIfNeeded();
    new ClosureCalculator().calculateClosureQuery(context);
    boolean repeat=context.matchClauses != null && context.matchClauses.size() > 0;
    if (repeat) {
      resultList=loadByIdsWithMatches(domainObjectClass,context,ids);
    }
 else {
      resultList=loadByIdsSimple(domainObjectClass,ids);
    }
  }
 catch (  Throwable e) {
    if (!(e instanceof RuntimeException))     throw new RuntimeException(e);
 else     throw e;
  }
 finally {
    if (internalAccess != null)     MappingUtil.internalDomainAccess.set(internalAccess);
 else     MappingUtil.internalDomainAccess.remove();
  }
  return resultList;
}",0.932972972972973
80497,"/** 
 * @param fm, null for the root step
 * @param context
 * @return true, if calculating query for the current path is done
 */
private boolean calculateQuery(FieldMapping fm,ClosureQueryContext context){
  boolean ret=true;
  CompoundObjectType compoundType;
  if (fm == null)   compoundType=domainAccessHandler.getCompoundTypeFor(context.domainObjectClass);
 else {
    String classFieldName=fm.getClassFieldName();
    compoundType=MappingUtil.internalDomainAccess.get().getConcreteFieldType(classFieldName);
  }
  Class<? extends Object> pureType=fm != null ? fm.getFieldType() : context.domainObjectClass;
  if (fm != null)   this.addToQuery(fm,context);
  boolean resolveDeep=true;
  boolean walkedToIndex=this.subPathIndex == -1;
  if (walkedToIndex) {
    if (context.getRecursionCount() >= domainAccessHandler.maxRecursionCount)     resolveDeep=false;
  }
  context.path.add(new PathElement(pureType));
  boolean isCollection=Collection.class.isAssignableFrom(pureType);
  if (isCollection) {
    String classFieldName=fm.getClassFieldName();
    compoundType=MappingUtil.internalDomainAccess.get().getFieldComponentType(classFieldName);
  }
  boolean terminatesClause=true;
  if (compoundType != null) {
    ObjectMapping objectMapping=domainAccessHandler.getCompoundObjectMappingFor(compoundType,null);
    Iterator<FieldMapping> it=objectMapping.fieldMappingsIterator();
    boolean subPathWalked=false;
    int idx=0;
    while (it.hasNext()) {
      FieldMapping fMap=it.next();
      idx++;
      if (!walkedToIndex) {
        terminatesClause=false;
        if (idx != this.subPathIndex)         continue;
 else         walkedToIndex=true;
      }
      if (fMap.needsRelation() && resolveDeep) {
        terminatesClause=false;
        boolean needToComeBack=false;
        if (!subPathWalked) {
          if (this.next == null)           this.next=new Step();
          PathElement pe=context.getLastPathElement();
          pe.fieldIndex=idx;
          pe.fieldName=fMap.getFieldName();
          boolean isDone=this.next.calculateQuery(fMap,context);
          if (!isDone) {
            needToComeBack=true;
          }
 else {
            this.next=null;
            subPathWalked=true;
          }
        }
 else {
          needToComeBack=true;
        }
        if (needToComeBack) {
          this.subPathIndex=idx;
          ret=false;
          break;
        }
      }
    }
  }
  context.path.remove(context.path.size() - 1);
  if (!resolveDeep || terminatesClause) {
    String nm=this.buildNodeOrRelationName(context.path,DomainAccessHandler.NodePrefix,context.clauseRepetitionNumber);
    context.queryEndNodes.add(nm);
  }
  return ret;
}","/** 
 * @param fm, null for the root step
 * @param context
 * @return true, if calculating query for the current path is done
 */
private boolean calculateQuery(FieldMapping fm,ClosureQueryContext context){
  boolean ret=true;
  CompoundObjectType compoundType;
  if (fm == null)   compoundType=domainAccessHandler.getCompoundTypeFor(context.domainObjectClass);
 else {
    String classFieldName=fm.getClassFieldName();
    compoundType=MappingUtil.internalDomainAccess.get().getConcreteFieldType(classFieldName);
  }
  Class<? extends Object> pureType=fm != null ? fm.getFieldType() : context.domainObjectClass;
  if (fm != null)   this.addToQuery(fm,context);
  boolean resolveDeep=true;
  boolean walkedToIndex=this.subPathIndex == -1;
  boolean subPathWalked=false;
  if (walkedToIndex) {
    if (context.getRecursionCount() >= domainAccessHandler.maxRecursionCount)     resolveDeep=false;
    if (fm != null)     subPathWalked=true;
  }
  context.path.add(new PathElement(pureType));
  boolean isCollection=Collection.class.isAssignableFrom(pureType);
  if (isCollection) {
    String classFieldName=fm.getClassFieldName();
    compoundType=MappingUtil.internalDomainAccess.get().getFieldComponentType(classFieldName);
  }
  boolean terminatesClause=true;
  if (compoundType != null) {
    ObjectMapping objectMapping=domainAccessHandler.getCompoundObjectMappingFor(compoundType,null);
    Iterator<FieldMapping> it=objectMapping.fieldMappingsIterator();
    int idx=0;
    while (it.hasNext()) {
      FieldMapping fMap=it.next();
      idx++;
      if (!walkedToIndex) {
        if (idx != this.subPathIndex)         continue;
 else         walkedToIndex=true;
      }
      if (fMap.needsRelation() && resolveDeep) {
        boolean needToComeBack=false;
        if (!subPathWalked) {
          terminatesClause=false;
          if (this.next == null)           this.next=new Step();
          PathElement pe=context.getLastPathElement();
          pe.fieldIndex=idx;
          pe.fieldName=fMap.getFieldName();
          boolean isDone=this.next.calculateQuery(fMap,context);
          if (!isDone) {
            needToComeBack=true;
          }
 else {
            this.next=null;
            subPathWalked=true;
          }
        }
 else {
          needToComeBack=true;
        }
        if (needToComeBack) {
          this.subPathIndex=idx;
          ret=false;
          break;
        }
      }
    }
  }
  context.path.remove(context.path.size() - 1);
  if (!resolveDeep || terminatesClause) {
    String nm=this.buildNodeOrRelationName(context.path,DomainAccessHandler.NodePrefix,context.clauseRepetitionNumber);
    context.queryEndNodes.add(nm);
    if (!resolveDeep)     context.recursionExitNodes.add(nm);
  }
  return ret;
}",0.8591964614817545
80498,"FillModelContext(Class<T> domainObjectClass,JcQueryResult qResult,List<String> queryEndNds){
  super();
  this.domainObjectClass=domainObjectClass;
  this.qResult=qResult;
  this.path=new ArrayList<PathElement>();
  this.queryEndNodes=queryEndNds;
  this.clauseRepetitionNumber=0;
  this.maxClauseRepetitionNumber=0;
  this.terminatesClause=false;
  this.alreadyTested=new ArrayList<String>();
}","FillModelContext(Class<T> domainObjectClass,JcQueryResult qResult,List<String> queryEndNds,List<String> recursionExitNds){
  super();
  this.domainObjectClass=domainObjectClass;
  this.qResult=qResult;
  this.path=new ArrayList<PathElement>();
  this.queryEndNodes=queryEndNds;
  this.recursionExitNodes=recursionExitNds;
  this.clauseRepetitionNumber=0;
  this.maxClauseRepetitionNumber=0;
  this.terminatesClause=false;
  this.alreadyTested=new ArrayList<String>();
}",0.914351851851852
80499,"private void buildAmbiguousTestObjects(Broker broker1,Broker broker2,MultiBroker multiBroker){
  Address address=new Address();
  address.setCity(""String_Node_Str"");
  address.setStreet(""String_Node_Str"");
  address.setNumber(9);
  NPerson nPerson=new NPerson();
  nPerson.setNamePart1(""String_Node_Str"");
  nPerson.setNamePart2(""String_Node_Str"");
  nPerson.setSocialSecurityNumber(""String_Node_Str"");
  nPerson.setHomeAddress(address);
  address=new Address();
  address.setCity(""String_Node_Str"");
  address.setStreet(""String_Node_Str"");
  address.setNumber(2);
  nPerson.setWorkAddress(address);
  address=new Address();
  address.setCity(""String_Node_Str"");
  address.setStreet(""String_Node_Str"");
  address.setNumber(28);
  JPerson jPerson=new JPerson();
  jPerson.setNamePart1(""String_Node_Str"");
  jPerson.setNamePart2(""String_Node_Str"");
  jPerson.setCompanyNumber(42);
  jPerson.setCompanyAddress(address);
  address=new Address();
  address.setCity(""String_Node_Str"");
  address.setStreet(""String_Node_Str"");
  address.setNumber(29);
  jPerson.setContactAddress(address);
  DistrictAddress dAddress=new DistrictAddress();
  dAddress.setCity(""String_Node_Str"");
  dAddress.setStreet(""String_Node_Str"");
  dAddress.setNumber(1);
  District district=new District();
  district.setName(""String_Node_Str"");
  district=new District();
  district.setName(""String_Node_Str"");
  dAddress.setSubDistrict(district);
  jPerson.setPostalAddress(dAddress);
  broker1.setWorksWith(nPerson);
  address=new Address();
  address.setCity(""String_Node_Str"");
  address.setStreet(""String_Node_Str"");
  address.setNumber(35);
  broker1.setAddress(address);
  broker2.setWorksWith(jPerson);
  address=new Address();
  address.setCity(""String_Node_Str"");
  address.setStreet(""String_Node_Str"");
  address.setNumber(168);
  broker2.setAddress(address);
  List<IPerson> persons=new ArrayList<IPerson>();
  persons.add(jPerson);
  persons.add(nPerson);
  multiBroker.setCanBroker(persons);
}","private void buildAmbiguousTestObjects(Broker broker1,Broker broker2,MultiBroker multiBroker){
  Address address=new Address();
  address.setCity(""String_Node_Str"");
  address.setStreet(""String_Node_Str"");
  address.setNumber(9);
  NPerson nPerson=new NPerson();
  nPerson.setNamePart1(""String_Node_Str"");
  nPerson.setNamePart2(""String_Node_Str"");
  nPerson.setSocialSecurityNumber(""String_Node_Str"");
  nPerson.setHomeAddress(address);
  address=new Address();
  address.setCity(""String_Node_Str"");
  address.setStreet(""String_Node_Str"");
  address.setNumber(2);
  nPerson.setWorkAddress(address);
  address=new Address();
  address.setCity(""String_Node_Str"");
  address.setStreet(""String_Node_Str"");
  address.setNumber(28);
  JPerson jPerson=new JPerson();
  jPerson.setNamePart1(""String_Node_Str"");
  jPerson.setNamePart2(""String_Node_Str"");
  jPerson.setCompanyNumber(42);
  jPerson.setCompanyAddress(address);
  address=new Address();
  address.setCity(""String_Node_Str"");
  address.setStreet(""String_Node_Str"");
  address.setNumber(29);
  jPerson.setContactAddress(address);
  DistrictAddress dAddress=new DistrictAddress();
  dAddress.setCity(""String_Node_Str"");
  dAddress.setStreet(""String_Node_Str"");
  dAddress.setNumber(1);
  District district=new District();
  district.setName(""String_Node_Str"");
  dAddress.setDistrict(district);
  district=new District();
  district.setName(""String_Node_Str"");
  dAddress.setSubDistrict(district);
  jPerson.setPostalAddress(dAddress);
  broker1.setWorksWith(nPerson);
  address=new Address();
  address.setCity(""String_Node_Str"");
  address.setStreet(""String_Node_Str"");
  address.setNumber(35);
  broker1.setAddress(address);
  broker2.setWorksWith(jPerson);
  address=new Address();
  address.setCity(""String_Node_Str"");
  address.setStreet(""String_Node_Str"");
  address.setNumber(168);
  broker2.setAddress(address);
  List<IPerson> persons=new ArrayList<IPerson>();
  persons.add(jPerson);
  persons.add(nPerson);
  multiBroker.setCanBroker(persons);
}",0.9914658634538152
80500,"public void testAmbiguous(){
  List<JcError> errors;
  DomainAccess da=new DomainAccess(dbAccess,domainName);
  DomainAccess da1;
  Broker broker1=new Broker();
  Broker broker2=new Broker();
  MultiBroker multiBroker=new MultiBroker();
  Broker broker21;
  Broker broker22;
  boolean equals;
  buildAmbiguousTestObjects(broker1,broker2,multiBroker);
  errors=dbAccess.clearDatabase();
  if (errors.size() > 0) {
    printErrors(errors);
    throw new JcResultException(errors);
  }
  List<Object> domainObjects=new ArrayList<Object>();
  domainObjects.add(broker1);
  domainObjects.add(broker2);
  errors=da.store(domainObjects);
  if (errors.size() > 0) {
    printErrors(errors);
    throw new JcResultException(errors);
  }
  IPerson person1=broker1.getWorksWith();
  IPerson person2=broker2.getWorksWith();
  SyncInfo syncInfo_1=da.getSyncInfo(broker1);
  SyncInfo syncInfo_2=da.getSyncInfo(broker2);
  SyncInfo syncInfo_3=da.getSyncInfo(person1);
  SyncInfo syncInfo_4=da.getSyncInfo(person2);
  IPerson person21;
  IPerson person22;
  da1=new DomainAccess(dbAccess,domainName);
  broker21=da1.loadById(Broker.class,syncInfo_1.getId());
  equals=CompareUtil_2.equalsBroker(broker1,broker21);
  assertTrue(equals);
  broker22=da1.loadById(Broker.class,syncInfo_2.getId());
  equals=CompareUtil_2.equalsBroker(broker2,broker22);
  assertTrue(equals);
  return;
}","@Test public void testAmbiguous(){
  List<JcError> errors;
  DomainAccess da=new DomainAccess(dbAccess,domainName);
  DomainAccess da1;
  Broker broker1=new Broker();
  Broker broker2=new Broker();
  MultiBroker multiBroker=new MultiBroker();
  Broker broker21;
  Broker broker22;
  boolean equals;
  buildAmbiguousTestObjects(broker1,broker2,multiBroker);
  errors=dbAccess.clearDatabase();
  if (errors.size() > 0) {
    printErrors(errors);
    throw new JcResultException(errors);
  }
  List<Object> domainObjects=new ArrayList<Object>();
  domainObjects.add(broker1);
  domainObjects.add(broker2);
  errors=da.store(domainObjects);
  if (errors.size() > 0) {
    printErrors(errors);
    throw new JcResultException(errors);
  }
  IPerson person1=broker1.getWorksWith();
  IPerson person2=broker2.getWorksWith();
  SyncInfo syncInfo_1=da.getSyncInfo(broker1);
  SyncInfo syncInfo_2=da.getSyncInfo(broker2);
  SyncInfo syncInfo_3=da.getSyncInfo(person1);
  SyncInfo syncInfo_4=da.getSyncInfo(person2);
  IPerson person21;
  IPerson person22;
  da1=new DomainAccess(dbAccess,domainName);
  broker21=da1.loadById(Broker.class,syncInfo_1.getId());
  equals=CompareUtil_2.equalsBroker(broker1,broker21);
  assertTrue(equals);
  broker22=da1.loadById(Broker.class,syncInfo_2.getId());
  equals=CompareUtil_2.equalsBroker(broker2,broker22);
  assertTrue(equals);
  ((DistrictAddress)((JPerson)broker2.getWorksWith()).getPostalAddress()).setDistrict(null);
  errors=da.store(broker2);
  if (errors.size() > 0) {
    printErrors(errors);
    throw new JcResultException(errors);
  }
  da1=new DomainAccess(dbAccess,domainName);
  broker22=da1.loadById(Broker.class,syncInfo_2.getId());
  equals=CompareUtil_2.equalsBroker(broker2,broker22);
  assertTrue(equals);
  ((JPerson)broker2.getWorksWith()).setCompanyAddress(null);
  errors=da.store(broker2);
  if (errors.size() > 0) {
    printErrors(errors);
    throw new JcResultException(errors);
  }
  da1=new DomainAccess(dbAccess,domainName);
  broker22=da1.loadById(Broker.class,syncInfo_2.getId());
  equals=CompareUtil_2.equalsBroker(broker2,broker22);
  assertTrue(equals);
  ((JPerson)broker2.getWorksWith()).setPostalAddress(null);
  errors=da.store(broker2);
  if (errors.size() > 0) {
    printErrors(errors);
    throw new JcResultException(errors);
  }
  da1=new DomainAccess(dbAccess,domainName);
  broker22=da1.loadById(Broker.class,syncInfo_2.getId());
  equals=CompareUtil_2.equalsBroker(broker2,broker22);
  assertTrue(equals);
  ((JPerson)broker2.getWorksWith()).setContactAddress(null);
  errors=da.store(broker2);
  if (errors.size() > 0) {
    printErrors(errors);
    throw new JcResultException(errors);
  }
  da1=new DomainAccess(dbAccess,domainName);
  broker22=da1.loadById(Broker.class,syncInfo_2.getId());
  equals=CompareUtil_2.equalsBroker(broker2,broker22);
  assertTrue(equals);
  return;
}",0.6416253248287267
80501,"@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) @Test public void testUpdateComplex_EmptyList2NotEmptyList(){
  List<JcError> errors;
  DomainAccess da=new DomainAccess(dbAccess,domainName);
  Person john=new Person();
  buildInitialDomainObjects_2(john);
  List addresses=john.getAddresses();
  john.setAddresses(new ArrayList());
  errors=dbAccess.clearDatabase();
  if (errors.size() > 0) {
    printErrors(errors);
    throw new JcResultException(errors);
  }
  errors=da.store(john);
  if (errors.size() > 0) {
    printErrors(errors);
    throw new JcResultException(errors);
  }
  SyncInfo syncInfo=da.getSyncInfo(john);
  john.setAddresses(addresses);
  errors=da.store(john);
  if (errors.size() > 0) {
    printErrors(errors);
    throw new JcResultException(errors);
  }
  da=new DomainAccess(dbAccess,domainName);
  Person john_1;
  john_1=da.loadById(Person.class,syncInfo.getId());
  return;
}","@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) public void testUpdateComplex_EmptyList2NotEmptyList(){
  List<JcError> errors;
  DomainAccess da=new DomainAccess(dbAccess,domainName);
  Person john=new Person();
  buildInitialDomainObjects_2(john);
  List addresses=john.getAddresses();
  john.setAddresses(new ArrayList());
  errors=dbAccess.clearDatabase();
  if (errors.size() > 0) {
    printErrors(errors);
    throw new JcResultException(errors);
  }
  errors=da.store(john);
  if (errors.size() > 0) {
    printErrors(errors);
    throw new JcResultException(errors);
  }
  SyncInfo syncInfo=da.getSyncInfo(john);
  john.setAddresses(addresses);
  errors=da.store(john);
  if (errors.size() > 0) {
    printErrors(errors);
    throw new JcResultException(errors);
  }
  da=new DomainAccess(dbAccess,domainName);
  Person john_1;
  john_1=da.loadById(Person.class,syncInfo.getId());
  return;
}",0.9967141292442496
80502,"/** 
 * @param context
 * @param fm may be null
 * @param nodeName may be null
 * @return true, if this leads to a null value
 */
@SuppressWarnings(""String_Node_Str"") private <T>boolean fillModel(FillModelContext<T> context,FieldMapping fm,String nodeName){
  int prevClauseRepetitionNumber=context.clauseRepetitionNumber;
  boolean isNullNode=false;
  String nnm;
  if (nodeName != null)   nnm=nodeName;
 else   nnm=this.buildNodeOrRelationName(context.path,DomainAccessHandler.NodePrefix,context.clauseRepetitionNumber);
  context.setTerminatesClause(nnm);
  CompoundObjectType compoundType;
  if (fm == null)   compoundType=domainAccessHandler.getCompoundTypeFor(context.domainObjectClass);
 else {
    String classFieldName=fm.getClassFieldName();
    compoundType=MappingUtil.internalDomainAccess.get().getConcreteFieldType(classFieldName);
  }
  Class<? extends Object> pureType=fm != null ? fm.getFieldType() : context.domainObjectClass;
  if (compoundType != null) {
    context.path.add(new PathElement(pureType));
    boolean resolveDeep=true;
    if (context.recursionExitNodes.contains(nnm)) {
      resolveDeep=false;
    }
    boolean isCollection=Collection.class.isAssignableFrom(pureType);
    Collection<Object> collection=null;
    if (isCollection) {
      String classFieldName=fm.getClassFieldName();
      collection=(Collection<Object>)domainAccessHandler.createInstance(MappingUtil.internalDomainAccess.get().getConcreteFieldType(classFieldName).getType());
      compoundType=MappingUtil.internalDomainAccess.get().getFieldComponentType(classFieldName);
    }
    JcNode n=new JcNode(nnm);
    List<GrNode> resList=context.qResult.resultOf(n);
    Object domainObject=null;
    if (resList.size() > 0) {
      for (      GrNode rNode : resList) {
        if (rNode != null) {
          boolean performMapping=false;
          boolean mapProperties=true;
          domainObject=domainAccessHandler.domainState.getFrom_Id2ObjectMap(rNode.getId());
          if (domainObject == null) {
            Class<?> clazz=domainAccessHandler.findClassToInstantiateFor(rNode);
            domainObject=domainAccessHandler.createInstance(clazz);
            domainAccessHandler.domainState.add_Id2Object(domainObject,rNode.getId(),resolveDeep ? ResolutionDepth.DEEP : ResolutionDepth.SHALLOW);
            performMapping=true;
          }
 else {
            if (resolveDeep && domainAccessHandler.domainState.getResolutionDepth(domainObject) != ResolutionDepth.DEEP) {
              performMapping=true;
              mapProperties=false;
            }
          }
          if (fm == null) {
            context.domainObject=(T)domainObject;
          }
          if (performMapping) {
            ObjectMapping objectMapping=domainAccessHandler.getCompoundObjectMappingFor(compoundType,domainObject.getClass());
            Iterator<FieldMapping> it=objectMapping.fieldMappingsIterator();
            int idx=0;
            while (it.hasNext()) {
              FieldMapping fMap=it.next();
              idx++;
              if (!objectMapping.shouldPerformFieldMapping(fMap)) {
                if (fMap.needsRelation() && resolveDeep) {
                  calculateMaxClauseRepetitionNumber(context,fMap,idx);
                }
                continue;
              }
              if (fMap.needsRelation() && resolveDeep) {
                context.currentObject=null;
                PathElement pe=context.getLastPathElement();
                pe.fieldIndex=idx;
                context.clauseRepetitionNumber=context.maxClauseRepetitionNumber;
                pe.fieldName=fMap.getFieldName();
                String ndName=this.buildNodeOrRelationName(context.path,DomainAccessHandler.NodePrefix,context.clauseRepetitionNumber);
                boolean nodeIsNull=false;
                boolean needToRepeat=false;
                if (isValidNodeName(ndName,context))                 nodeIsNull=this.fillModel(context,fMap,ndName);
 else                 needToRepeat=true;
                context.alreadyTested.clear();
                while (needToRepeat && morePathsToTest(context,fMap,idx)) {
                  context.currentObject=null;
                  pe=context.getLastPathElement();
                  pe.fieldIndex=idx;
                  context.clauseRepetitionNumber=context.maxClauseRepetitionNumber;
                  pe.fieldName=fMap.getFieldName();
                  ndName=this.buildNodeOrRelationName(context.path,DomainAccessHandler.NodePrefix,context.clauseRepetitionNumber);
                  needToRepeat=false;
                  if (isValidNodeName(ndName,context))                   nodeIsNull=this.fillModel(context,fMap,ndName);
 else {
                    if (moreClausesAvailable(ndName,context))                     needToRepeat=true;
                  }
                }
                if (!nodeIsNull && context.currentObject != null) {
                  fMap.setField(domainObject,context.currentObject);
                  String rnm=this.buildNodeOrRelationName(context.path,DomainAccessHandler.RelationPrefix,context.clauseRepetitionNumber);
                  JcRelation r=new JcRelation(rnm);
                  List<GrRelation> relList=context.qResult.resultOf(r);
                  if (context.currentObject instanceof Collection) {
                    addRelations(domainObject,relList,(Collection<?>)context.currentObject,fMap.getPropertyOrRelationName());
                  }
 else {
                    GrRelation rel=relList.get(0);
                    domainAccessHandler.domainState.add_Id2Relation(new Relation(fMap.getPropertyOrRelationName(),domainObject,context.currentObject),rel.getId());
                  }
                }
 else                 if (nodeIsNull && fMap.isCollection()) {
                  fMap.mapPropertyToField(domainObject,rNode);
                }
                context.updateMaxClauseRepetitionNumber();
              }
 else {
                if (mapProperties)                 fMap.mapPropertyToField(domainObject,rNode);
              }
            }
          }
          if (isCollection)           collection.add(domainObject);
        }
 else {
          isNullNode=true;
        }
      }
    }
    if (isCollection)     context.currentObject=collection;
 else     context.currentObject=domainObject;
    context.path.remove(context.path.size() - 1);
  }
  context.clauseRepetitionNumber=prevClauseRepetitionNumber;
  return isNullNode;
}","/** 
 * @param context
 * @param fm may be null
 * @param nodeName may be null
 * @return true, if this leads to a null value
 */
@SuppressWarnings(""String_Node_Str"") private <T>boolean fillModel(FillModelContext<T> context,FieldMapping fm,String nodeName){
  int prevClauseRepetitionNumber=context.clauseRepetitionNumber;
  boolean isNullNode=false;
  String nnm;
  if (nodeName != null)   nnm=nodeName;
 else   nnm=this.buildNodeOrRelationName(context.path,DomainAccessHandler.NodePrefix,context.clauseRepetitionNumber);
  context.setTerminatesClause(nnm);
  CompoundObjectType compoundType;
  if (fm == null)   compoundType=domainAccessHandler.getCompoundTypeFor(context.domainObjectClass);
 else {
    String classFieldName=fm.getClassFieldName();
    compoundType=MappingUtil.internalDomainAccess.get().getConcreteFieldType(classFieldName);
  }
  Class<? extends Object> pureType=fm != null ? fm.getFieldType() : context.domainObjectClass;
  if (compoundType != null) {
    context.path.add(new PathElement(pureType));
    boolean resolveDeep=true;
    if (context.recursionExitNodes.contains(nnm)) {
      resolveDeep=false;
    }
    boolean isCollection=Collection.class.isAssignableFrom(pureType);
    Collection<Object> collection=null;
    if (isCollection) {
      String classFieldName=fm.getClassFieldName();
      collection=(Collection<Object>)domainAccessHandler.createInstance(MappingUtil.internalDomainAccess.get().getConcreteFieldType(classFieldName).getType());
      compoundType=MappingUtil.internalDomainAccess.get().getFieldComponentType(classFieldName);
    }
    JcNode n=new JcNode(nnm);
    List<GrNode> resList=context.qResult.resultOf(n);
    Object domainObject=null;
    if (resList.size() > 0) {
      int initialMaxClauseRepetitionNumber=context.maxClauseRepetitionNumber;
      for (      GrNode rNode : resList) {
        if (rNode != null) {
          boolean performMapping=false;
          boolean mapProperties=true;
          domainObject=domainAccessHandler.domainState.getFrom_Id2ObjectMap(rNode.getId());
          if (domainObject == null) {
            Class<?> clazz=domainAccessHandler.findClassToInstantiateFor(rNode);
            domainObject=domainAccessHandler.createInstance(clazz);
            domainAccessHandler.domainState.add_Id2Object(domainObject,rNode.getId(),resolveDeep ? ResolutionDepth.DEEP : ResolutionDepth.SHALLOW);
            performMapping=true;
          }
 else {
            if (resolveDeep && domainAccessHandler.domainState.getResolutionDepth(domainObject) != ResolutionDepth.DEEP) {
              performMapping=true;
              mapProperties=false;
            }
          }
          if (fm == null) {
            context.domainObject=(T)domainObject;
          }
          if (performMapping) {
            context.maxClauseRepetitionNumber=initialMaxClauseRepetitionNumber;
            ObjectMapping objectMapping=domainAccessHandler.getCompoundObjectMappingFor(compoundType,domainObject.getClass());
            Iterator<FieldMapping> it=objectMapping.fieldMappingsIterator();
            int idx=0;
            while (it.hasNext()) {
              FieldMapping fMap=it.next();
              idx++;
              if (!objectMapping.shouldPerformFieldMapping(fMap)) {
                if (fMap.needsRelation() && resolveDeep) {
                  calculateMaxClauseRepetitionNumber(context,fMap,idx);
                }
                continue;
              }
              if (fMap.needsRelation() && resolveDeep) {
                context.currentObject=null;
                PathElement pe=context.getLastPathElement();
                pe.fieldIndex=idx;
                context.clauseRepetitionNumber=context.maxClauseRepetitionNumber;
                pe.fieldName=fMap.getFieldName();
                String ndName=this.buildNodeOrRelationName(context.path,DomainAccessHandler.NodePrefix,context.clauseRepetitionNumber);
                boolean nodeIsNull=false;
                boolean needToRepeat=false;
                if (isValidNodeName(ndName,context))                 nodeIsNull=this.fillModel(context,fMap,ndName);
 else                 needToRepeat=true;
                context.alreadyTested.clear();
                while (needToRepeat && morePathsToTest(context,fMap,idx)) {
                  context.currentObject=null;
                  pe=context.getLastPathElement();
                  pe.fieldIndex=idx;
                  context.clauseRepetitionNumber=context.maxClauseRepetitionNumber;
                  pe.fieldName=fMap.getFieldName();
                  ndName=this.buildNodeOrRelationName(context.path,DomainAccessHandler.NodePrefix,context.clauseRepetitionNumber);
                  needToRepeat=false;
                  if (isValidNodeName(ndName,context))                   nodeIsNull=this.fillModel(context,fMap,ndName);
 else {
                    if (moreClausesAvailable(ndName,context))                     needToRepeat=true;
                  }
                }
                if (!nodeIsNull && context.currentObject != null) {
                  fMap.setField(domainObject,context.currentObject);
                  String rnm=this.buildNodeOrRelationName(context.path,DomainAccessHandler.RelationPrefix,context.clauseRepetitionNumber);
                  JcRelation r=new JcRelation(rnm);
                  List<GrRelation> relList=context.qResult.resultOf(r);
                  if (context.currentObject instanceof Collection) {
                    addRelations(domainObject,relList,(Collection<?>)context.currentObject,fMap.getPropertyOrRelationName());
                  }
 else {
                    GrRelation rel=relList.get(0);
                    domainAccessHandler.domainState.add_Id2Relation(new Relation(fMap.getPropertyOrRelationName(),domainObject,context.currentObject),rel.getId());
                  }
                }
 else                 if (nodeIsNull && fMap.isCollection()) {
                  fMap.mapPropertyToField(domainObject,rNode);
                }
                context.updateMaxClauseRepetitionNumber();
              }
 else {
                if (mapProperties)                 fMap.mapPropertyToField(domainObject,rNode);
              }
            }
          }
          if (isCollection)           collection.add(domainObject);
        }
 else {
          isNullNode=true;
        }
      }
    }
    if (isCollection)     context.currentObject=collection;
 else     context.currentObject=domainObject;
    context.path.remove(context.path.size() - 1);
  }
  context.clauseRepetitionNumber=prevClauseRepetitionNumber;
  return isNullNode;
}",0.9878927203065134
80503,"private void handleObjectInClosureCalc(Object relatedObject,Object domainObject,UpdateContext context,FieldMapping fm){
  IRelation relat=new Relation(fm.getPropertyOrRelationName(),domainObject,relatedObject);
  if (!domainAccessHandler.domainState.existsRelation(relat)) {
    context.relations.add(relat);
    relat=domainAccessHandler.domainState.findRelation(domainObject,fm.getPropertyOrRelationName());
    if (relat != null) {
      context.relationsToRemove.add(relat);
    }
  }
  recursiveCalculateClosure(relatedObject,context);
}","private void handleObjectInClosureCalc(Object relatedObject,Object domainObject,UpdateContext context,FieldMapping fm){
  IRelation relat=new Relation(fm.getPropertyOrRelationName(),domainObject,relatedObject);
  if (!domainAccessHandler.domainState.existsRelation(relat)) {
    context.relations.add(relat);
    relat=domainAccessHandler.domainState.findRelation(domainObject,fm.getPropertyOrRelationName());
    if (relat != null) {
      context.relationsToRemove.add(relat);
    }
  }
  String classField=fm.getClassFieldName();
  MappingUtil.internalDomainAccess.get().addConcreteFieldType(classField,relatedObject.getClass());
  recursiveCalculateClosure(relatedObject,context);
}",0.8827361563517915
80504,"private void handleListInClosureCalc(Collection<?> coll,Object domainObject,UpdateContext context,FieldMapping fm){
  String typ=fm.getPropertyOrRelationName();
  Map<SourceField2TargetKey,List<IndexedRelation>> indexedRelations=new HashMap<SourceField2TargetKey,List<IndexedRelation>>();
  int idx=0;
  for (  Object elem : coll) {
    SourceField2TargetKey key=new SourceField2TargetKey(domainObject,fm.getFieldName(),elem);
    List<IndexedRelation> relats=indexedRelations.get(key);
    if (relats == null) {
      relats=new ArrayList<IndexedRelation>();
      indexedRelations.put(key,relats);
    }
    relats.add(new IndexedRelation(typ,idx,domainObject,elem));
    idx++;
  }
  Iterator<Entry<SourceField2TargetKey,List<IndexedRelation>>> it=indexedRelations.entrySet().iterator();
  while (it.hasNext()) {
    Entry<SourceField2TargetKey,List<IndexedRelation>> entry=it.next();
    List<IndexedRelation> existingRels=domainAccessHandler.domainState.getIndexedRelations(entry.getKey());
    RelationsToModify toModify=calculateIndexedRelationsToModify(entry.getValue(),existingRels);
    context.relations.addAll(toModify.toChange);
    context.relations.addAll(toModify.toCreate);
    context.relationsToRemove.addAll(toModify.toRemove);
  }
  for (  Object elem : coll) {
    recursiveCalculateClosure(elem,context);
  }
}","private void handleListInClosureCalc(Collection<?> coll,Object domainObject,UpdateContext context,FieldMapping fm){
  String typ=fm.getPropertyOrRelationName();
  Map<SourceField2TargetKey,List<IndexedRelation>> indexedRelations=new HashMap<SourceField2TargetKey,List<IndexedRelation>>();
  String classField=fm.getClassFieldName();
  MappingUtil.internalDomainAccess.get().addConcreteFieldType(classField,coll.getClass());
  int idx=0;
  for (  Object elem : coll) {
    SourceField2TargetKey key=new SourceField2TargetKey(domainObject,fm.getFieldName(),elem);
    List<IndexedRelation> relats=indexedRelations.get(key);
    if (relats == null) {
      relats=new ArrayList<IndexedRelation>();
      indexedRelations.put(key,relats);
    }
    relats.add(new IndexedRelation(typ,idx,domainObject,elem));
    MappingUtil.internalDomainAccess.get().addFieldComponentType(classField,elem.getClass());
    idx++;
  }
  Iterator<Entry<SourceField2TargetKey,List<IndexedRelation>>> it=indexedRelations.entrySet().iterator();
  while (it.hasNext()) {
    Entry<SourceField2TargetKey,List<IndexedRelation>> entry=it.next();
    List<IndexedRelation> existingRels=domainAccessHandler.domainState.getIndexedRelations(entry.getKey());
    RelationsToModify toModify=calculateIndexedRelationsToModify(entry.getValue(),existingRels);
    context.relations.addAll(toModify.toChange);
    context.relations.addAll(toModify.toCreate);
    context.relationsToRemove.addAll(toModify.toRemove);
  }
  for (  Object elem : coll) {
    recursiveCalculateClosure(elem,context);
  }
}",0.9208981001727116
80505,"/** 
 * @return the value of the field, if this value cannot be mapped to a property,but must be mapped to a seperate node connected via a relation, else return null.
 */
@SuppressWarnings(""String_Node_Str"") public Object getObjectNeedingRelation(Object domainObject){
  Object value=null;
  try {
    prepare(domainObject);
    if (needsRelation()) {
      value=this.field.get(domainObject);
      if (value != null) {
        String classField=getClassFieldName();
        MappingUtil.internalDomainAccess.get().addConcreteFieldType(classField,value.getClass());
        if (Collection.class.isAssignableFrom(this.field.getType())) {
          Collection coll=(Collection)this.field.getType().cast(value);
          if (coll.size() > 0) {
            Object elem=coll.iterator().next();
            Class<?> type=elem.getClass();
            classField=getClassFieldName();
            MappingUtil.internalDomainAccess.get().addFieldComponentType(classField,type);
            if (MappingUtil.isSimpleType(type)) {
              value=null;
            }
          }
 else {
            value=null;
          }
        }
      }
    }
  }
 catch (  Throwable e) {
    throw new RuntimeException(e);
  }
  return value;
}","/** 
 * @return the value of the field, if this value cannot be mapped to a property,but must be mapped to a seperate node connected via a relation, else return null.
 */
@SuppressWarnings(""String_Node_Str"") public Object getObjectNeedingRelation(Object domainObject){
  Object value=null;
  try {
    prepare(domainObject);
    if (needsRelation()) {
      value=this.field.get(domainObject);
      if (value != null) {
        if (Collection.class.isAssignableFrom(this.field.getType())) {
          Collection coll=(Collection)this.field.getType().cast(value);
          if (coll.size() > 0) {
            Object elem=coll.iterator().next();
            Class<?> type=elem.getClass();
            if (MappingUtil.isSimpleType(type)) {
              value=null;
            }
          }
 else {
            value=null;
          }
        }
      }
    }
  }
 catch (  Throwable e) {
    throw new RuntimeException(e);
  }
  return value;
}",0.8605724838411819
80506,"public static boolean equalsAddresses(List addresses1,List addresses2){
  if (addresses1 == addresses2)   return true;
  ListIterator e1=addresses1.listIterator();
  ListIterator e2=addresses2.listIterator();
  while (e1.hasNext() && e2.hasNext()) {
    Object o1=e1.next();
    Object o2=e2.next();
    if (!(o1 == null ? o2 == null : equalsAddress((Address)o1,(Address)o2)))     return false;
  }
  return !(e1.hasNext() || e2.hasNext());
}","@SuppressWarnings(""String_Node_Str"") public static boolean equalsAddresses(List addresses1,List addresses2){
  if (addresses1 == addresses2)   return true;
  ListIterator e1=addresses1.listIterator();
  ListIterator e2=addresses2.listIterator();
  while (e1.hasNext() && e2.hasNext()) {
    Object o1=e1.next();
    Object o2=e2.next();
    if (!(o1 == null ? o2 == null : equalsAddress((Address)o1,(Address)o2)))     return false;
  }
  return !(e1.hasNext() || e2.hasNext());
}",0.9598262757871878
80507,"public void testAmbiguous(){
  List<JcError> errors;
  DomainAccess da=new DomainAccess(dbAccess,domainName);
  DomainAccess da1;
  Broker broker1=new Broker();
  Broker broker2=new Broker();
  MultiBroker multiBroker=new MultiBroker();
  Broker broker21;
  Broker broker22;
  boolean equals;
  buildAmbiguousTestObjects(broker1,broker2,multiBroker);
  errors=dbAccess.clearDatabase();
  if (errors.size() > 0) {
    printErrors(errors);
    throw new JcResultException(errors);
  }
  List<Object> domainObjects=new ArrayList<Object>();
  domainObjects.add(broker1);
  domainObjects.add(broker2);
  errors=da.store(domainObjects);
  if (errors.size() > 0) {
    printErrors(errors);
    throw new JcResultException(errors);
  }
  IPerson person1=broker1.getWorksWith();
  IPerson person2=broker2.getWorksWith();
  SyncInfo syncInfo_1=da.getSyncInfo(broker1);
  SyncInfo syncInfo_2=da.getSyncInfo(broker2);
  SyncInfo syncInfo_3=da.getSyncInfo(person1);
  SyncInfo syncInfo_4=da.getSyncInfo(person2);
  IPerson person21;
  IPerson person22;
  da1=new DomainAccess(dbAccess,domainName);
  broker21=da1.loadById(Broker.class,syncInfo_1.getId());
  equals=CompareUtil_2.equalsBroker(broker1,broker21);
  assertTrue(equals);
  broker22=da1.loadById(Broker.class,syncInfo_2.getId());
  equals=CompareUtil_2.equalsBroker(broker2,broker22);
  assertTrue(equals);
  ((DistrictAddress)((JPerson)broker2.getWorksWith()).getPostalAddress()).setDistrict(null);
  errors=da.store(broker2);
  if (errors.size() > 0) {
    printErrors(errors);
    throw new JcResultException(errors);
  }
  da1=new DomainAccess(dbAccess,domainName);
  broker22=da1.loadById(Broker.class,syncInfo_2.getId());
  equals=CompareUtil_2.equalsBroker(broker2,broker22);
  assertTrue(equals);
  ((JPerson)broker2.getWorksWith()).setCompanyAddress(null);
  errors=da.store(broker2);
  if (errors.size() > 0) {
    printErrors(errors);
    throw new JcResultException(errors);
  }
  da1=new DomainAccess(dbAccess,domainName);
  broker22=da1.loadById(Broker.class,syncInfo_2.getId());
  equals=CompareUtil_2.equalsBroker(broker2,broker22);
  assertTrue(equals);
  ((JPerson)broker2.getWorksWith()).setPostalAddress(null);
  errors=da.store(broker2);
  if (errors.size() > 0) {
    printErrors(errors);
    throw new JcResultException(errors);
  }
  da1=new DomainAccess(dbAccess,domainName);
  broker22=da1.loadById(Broker.class,syncInfo_2.getId());
  equals=CompareUtil_2.equalsBroker(broker2,broker22);
  assertTrue(equals);
  ((JPerson)broker2.getWorksWith()).setContactAddress(null);
  errors=da.store(broker2);
  if (errors.size() > 0) {
    printErrors(errors);
    throw new JcResultException(errors);
  }
  da1=new DomainAccess(dbAccess,domainName);
  broker22=da1.loadById(Broker.class,syncInfo_2.getId());
  equals=CompareUtil_2.equalsBroker(broker2,broker22);
  assertTrue(equals);
  return;
}","@Test public void testAmbiguous(){
  List<JcError> errors;
  DomainAccess da=new DomainAccess(dbAccess,domainName);
  DomainAccess da1;
  Broker broker1=new Broker();
  Broker broker2=new Broker();
  MultiBroker multiBroker=new MultiBroker();
  Broker broker21;
  Broker broker22;
  boolean equals;
  buildAmbiguousTestObjects(broker1,broker2,multiBroker);
  errors=dbAccess.clearDatabase();
  if (errors.size() > 0) {
    printErrors(errors);
    throw new JcResultException(errors);
  }
  List<Object> domainObjects=new ArrayList<Object>();
  domainObjects.add(broker1);
  domainObjects.add(broker2);
  errors=da.store(domainObjects);
  if (errors.size() > 0) {
    printErrors(errors);
    throw new JcResultException(errors);
  }
  IPerson person1=broker1.getWorksWith();
  IPerson person2=broker2.getWorksWith();
  SyncInfo syncInfo_1=da.getSyncInfo(broker1);
  SyncInfo syncInfo_2=da.getSyncInfo(broker2);
  SyncInfo syncInfo_3=da.getSyncInfo(person1);
  SyncInfo syncInfo_4=da.getSyncInfo(person2);
  IPerson person21;
  IPerson person22;
  da1=new DomainAccess(dbAccess,domainName);
  broker21=da1.loadById(Broker.class,syncInfo_1.getId());
  equals=CompareUtil_2.equalsBroker(broker1,broker21);
  assertTrue(equals);
  broker22=da1.loadById(Broker.class,syncInfo_2.getId());
  equals=CompareUtil_2.equalsBroker(broker2,broker22);
  assertTrue(equals);
  ((DistrictAddress)((JPerson)broker2.getWorksWith()).getPostalAddress()).setDistrict(null);
  errors=da.store(broker2);
  if (errors.size() > 0) {
    printErrors(errors);
    throw new JcResultException(errors);
  }
  da1=new DomainAccess(dbAccess,domainName);
  broker22=da1.loadById(Broker.class,syncInfo_2.getId());
  equals=CompareUtil_2.equalsBroker(broker2,broker22);
  assertTrue(equals);
  ((JPerson)broker2.getWorksWith()).setCompanyAddress(null);
  errors=da.store(broker2);
  if (errors.size() > 0) {
    printErrors(errors);
    throw new JcResultException(errors);
  }
  da1=new DomainAccess(dbAccess,domainName);
  broker22=da1.loadById(Broker.class,syncInfo_2.getId());
  equals=CompareUtil_2.equalsBroker(broker2,broker22);
  assertTrue(equals);
  ((JPerson)broker2.getWorksWith()).setPostalAddress(null);
  errors=da.store(broker2);
  if (errors.size() > 0) {
    printErrors(errors);
    throw new JcResultException(errors);
  }
  da1=new DomainAccess(dbAccess,domainName);
  broker22=da1.loadById(Broker.class,syncInfo_2.getId());
  equals=CompareUtil_2.equalsBroker(broker2,broker22);
  assertTrue(equals);
  ((JPerson)broker2.getWorksWith()).setContactAddress(null);
  errors=da.store(broker2);
  if (errors.size() > 0) {
    printErrors(errors);
    throw new JcResultException(errors);
  }
  da1=new DomainAccess(dbAccess,domainName);
  broker22=da1.loadById(Broker.class,syncInfo_2.getId());
  equals=CompareUtil_2.equalsBroker(broker2,broker22);
  assertTrue(equals);
  return;
}",0.9989525139664804
80508,"/** 
 * @param fm, null for the root step
 * @param context
 * @return true, if calculating query for the current path is done
 */
private boolean calculateQuery(FieldMapping fm,int fieldIndex,ClosureQueryContext context,int level){
  if (fm != null)   this.addToQuery(fm,fieldIndex,context,level);
  Class<?> doClass;
  if (fm == null)   doClass=context.domainObjectClass;
 else   doClass=fm.getFieldType();
  ObjectMapping objectMapping=domainAccessHandler.getObjectMappingFor(doClass);
  List<FieldMapping> fMappings=objectMapping.getFieldMappings();
  boolean walkedToIndex=this.subPathIndex == -1;
  boolean subPathWalked=false;
  int idx=-1;
  for (  FieldMapping fMap : fMappings) {
    idx++;
    if (!walkedToIndex) {
      if (idx != this.subPathIndex)       continue;
 else       walkedToIndex=true;
    }
    if (fMap.needsRelation()) {
      boolean needToComeBack=false;
      if (!subPathWalked) {
        if (this.next == null)         this.next=new Step();
        boolean isDone=this.next.calculateQuery(fMap,idx,context,level + 1);
        if (!isDone) {
          needToComeBack=true;
        }
 else {
          this.next=null;
          subPathWalked=true;
        }
      }
 else {
        needToComeBack=true;
      }
      if (needToComeBack) {
        this.subPathIndex=idx;
        return false;
      }
    }
  }
  return true;
}","/** 
 * @param fm, null for the root step
 * @param context
 * @return true, if calculating query for the current path is done
 */
private boolean calculateQuery(FieldMapping fm,int fieldIndex,ClosureQueryContext context,int level){
  Class<?> doClass;
  if (fm == null)   doClass=context.domainObjectClass;
 else   doClass=fm.getFieldType();
  if (fm != null)   this.addToQuery(fm,fieldIndex,context,level);
  boolean walkedToIndex=this.subPathIndex == -1;
  if (!context.visitedTypes.contains(doClass) || !walkedToIndex) {
    if (walkedToIndex)     context.visitedTypes.add(doClass);
    ObjectMapping objectMapping=domainAccessHandler.getObjectMappingFor(doClass);
    List<FieldMapping> fMappings=objectMapping.getFieldMappings();
    boolean subPathWalked=false;
    int idx=-1;
    for (    FieldMapping fMap : fMappings) {
      idx++;
      if (!walkedToIndex) {
        if (idx != this.subPathIndex)         continue;
 else         walkedToIndex=true;
      }
      if (fMap.needsRelation()) {
        boolean needToComeBack=false;
        if (!subPathWalked) {
          if (this.next == null)           this.next=new Step();
          boolean isDone=this.next.calculateQuery(fMap,idx,context,level + 1);
          if (!isDone) {
            needToComeBack=true;
          }
 else {
            this.next=null;
            subPathWalked=true;
          }
        }
 else {
          needToComeBack=true;
        }
        if (needToComeBack) {
          this.subPathIndex=idx;
          return false;
        }
      }
    }
  }
  return true;
}",0.4442155853072433
80509,"private void addToQuery(FieldMapping fm,int fieldIndex,ClosureQueryContext context,int level){
  if (context.currentMatchClause == null) {
    JcNode n=new JcNode(DomainAccessHandler.NodePrefix.concat(String.valueOf(0)));
    context.currentMatchClause=OPTIONAL_MATCH.node(n);
  }
  JcNode n=new JcNode(this.buildNodeOrRelationName(fieldIndex,level,DomainAccessHandler.NodePrefix));
  JcRelation r=new JcRelation(this.buildNodeOrRelationName(fieldIndex,level,DomainAccessHandler.RelationPrefix));
  context.currentMatchClause.relation(r).out().type(fm.getPropertyOrRelationName()).node(n);
}","private void addToQuery(FieldMapping fm,int fieldIndex,ClosureQueryContext context,int level){
  if (context.currentMatchClause == null) {
    JcNode n=new JcNode(DomainAccessHandler.NodePrefix.concat(String.valueOf(0)));
    context.currentMatchClause=OPTIONAL_MATCH.node(n);
    if (context.matchClauses != null && context.matchClauses.size() > 0) {
      context.matchClauses.add(SEPARATE.nextClause());
    }
  }
  JcNode n=new JcNode(this.buildNodeOrRelationName(fieldIndex,level,DomainAccessHandler.NodePrefix));
  JcRelation r=new JcRelation(this.buildNodeOrRelationName(fieldIndex,level,DomainAccessHandler.RelationPrefix));
  context.currentMatchClause.relation(r).out().type(fm.getPropertyOrRelationName()).node(n);
}",0.8968133535660091
80510,"/** 
 * has one or more match clauses
 * @param domainObjectClass
 * @param context
 * @param ids
 * @return
 */
@SuppressWarnings(""String_Node_Str"") private <T>List<T> loadByIdsWithMatches(Class<T> domainObjectClass,ClosureQueryContext context,long... ids){
  List<T> resultList=new ArrayList<T>();
  JcQuery query;
  String nm=NodePrefix.concat(String.valueOf(0));
  List<JcQuery> queries=new ArrayList<JcQuery>();
  Map<Long,JcQueryResult> id2QueryResult=new HashMap<Long,JcQueryResult>();
  List<Long> queryIds=new ArrayList<Long>();
  Map<Long,T> id2Object=new HashMap<Long,T>();
  for (int i=0; i < ids.length; i++) {
    T obj=(T)this.domainState.checkForMappedObject(domainObjectClass,ids[i]);
    if (obj != null) {
      id2Object.put(ids[i],obj);
    }
 else {
      query=new JcQuery();
      JcNode n=new JcNode(nm);
      List<IClause> clauses=new ArrayList<IClause>();
      clauses.add(START.node(n).byId(ids[i]));
      clauses.addAll(context.matchClauses);
      clauses.add(RETURN.ALL());
      IClause[] clausesArray=clauses.toArray(new IClause[clauses.size()]);
      query.setClauses(clausesArray);
      queries.add(query);
      queryIds.add(ids[i]);
    }
  }
  if (queries.size() > 0) {
    List<JcQueryResult> results=this.dbAccess.execute(queries);
    List<JcError> errors=Util.collectErrors(results);
    if (errors.size() > 0) {
      throw new JcResultException(errors);
    }
    for (int i=0; i < queries.size(); i++) {
      id2QueryResult.put(queryIds.get(i),results.get(i));
    }
  }
  for (int i=0; i < ids.length; i++) {
    T obj=id2Object.get(ids[i]);
    if (obj == null) {
      FillModelContext<T> fContext=new FillModelContext<T>(domainObjectClass,id2QueryResult.get(ids[i]));
      new ClosureCalculator().fillModel(fContext);
      obj=fContext.domainObject;
    }
    resultList.add(obj);
  }
  return resultList;
}","/** 
 * has one or more match clauses
 * @param domainObjectClass
 * @param context
 * @param ids
 * @return
 */
@SuppressWarnings(""String_Node_Str"") private <T>List<T> loadByIdsWithMatches(Class<T> domainObjectClass,ClosureQueryContext context,long... ids){
  List<T> resultList=new ArrayList<T>();
  JcQuery query;
  String nm=NodePrefix.concat(String.valueOf(0));
  List<JcQuery> queries=new ArrayList<JcQuery>();
  Map<Long,JcQueryResult> id2QueryResult=new HashMap<Long,JcQueryResult>();
  List<Long> queryIds=new ArrayList<Long>();
  Map<Long,T> id2Object=new HashMap<Long,T>();
  for (int i=0; i < ids.length; i++) {
    T obj=(T)this.domainState.checkForMappedObject(domainObjectClass,ids[i]);
    if (obj != null) {
      id2Object.put(ids[i],obj);
    }
 else {
      query=new JcQuery();
      JcNode n=new JcNode(nm);
      List<IClause> clauses=new ArrayList<IClause>();
      clauses.add(START.node(n).byId(ids[i]));
      clauses.addAll(context.matchClauses);
      clauses.add(RETURN.ALL());
      IClause[] clausesArray=clauses.toArray(new IClause[clauses.size()]);
      query.setClauses(clausesArray);
      queries.add(query);
      queryIds.add(ids[i]);
    }
  }
  if (queries.size() > 0) {
    Util.printQueries(queries,""String_Node_Str"",Format.PRETTY_1);
    List<JcQueryResult> results=this.dbAccess.execute(queries);
    List<JcError> errors=Util.collectErrors(results);
    if (errors.size() > 0) {
      throw new JcResultException(errors);
    }
    for (int i=0; i < queries.size(); i++) {
      id2QueryResult.put(queryIds.get(i),results.get(i));
    }
  }
  for (int i=0; i < ids.length; i++) {
    T obj=id2Object.get(ids[i]);
    if (obj == null) {
      FillModelContext<T> fContext=new FillModelContext<T>(domainObjectClass,id2QueryResult.get(ids[i]));
      new ClosureCalculator().fillModel(fContext);
      obj=fContext.domainObject;
    }
    resultList.add(obj);
  }
  return resultList;
}",0.9826041117554032
80511,"private UpdateContext updateLocalGraph(List<Object> domainObjects){
  UpdateContext context=new UpdateContext();
  new ClosureCalculator().calculateClosure(domainObjects,context);
  Graph graph=null;
  Object domainObject;
  Map<Integer,QueryNode2ResultNode> nodeIndexMap=null;
  List<IClause> clauses=null;
  List<IClause> removeStartClauses=null;
  List<IClause> removeClauses=null;
  for (int i=0; i < context.domainObjects.size(); i++) {
    domainObject=context.domainObjects.get(i);
    Long id=this.domainState.getFrom_Object2IdMap(domainObject);
    if (id != null) {
      JcNode n=new JcNode(NodePrefix.concat(String.valueOf(i)));
      QueryNode2ResultNode n2n=new QueryNode2ResultNode();
      n2n.queryNode=n;
      if (nodeIndexMap == null)       nodeIndexMap=new HashMap<Integer,QueryNode2ResultNode>();
      nodeIndexMap.put(new Integer(i),n2n);
      if (clauses == null)       clauses=new ArrayList<IClause>();
      clauses.add(START.node(n).byId(id.longValue()));
    }
  }
  Map<Integer,QueryRelation2ResultRelation> relationIndexMap=null;
  for (int i=0; i < context.relations.size(); i++) {
    Relation relat=context.relations.get(i);
    Long id=this.domainState.getFrom_Relation2IdMap(relat);
    if (id != null) {
      JcRelation r=new JcRelation(RelationPrefix.concat(String.valueOf(i)));
      QueryRelation2ResultRelation r2r=new QueryRelation2ResultRelation();
      r2r.queryRelation=r;
      if (relationIndexMap == null)       relationIndexMap=new HashMap<Integer,QueryRelation2ResultRelation>();
      relationIndexMap.put(new Integer(i),r2r);
      clauses.add(START.relation(r).byId(id.longValue()));
    }
  }
  if (context.relationsToRemove.size() > 0) {
    removeStartClauses=new ArrayList<IClause>();
    removeClauses=new ArrayList<IClause>();
    for (int i=0; i < context.relationsToRemove.size(); i++) {
      Relation relat=context.relationsToRemove.get(i);
      Long id=this.domainState.getFrom_Relation2IdMap(relat);
      JcRelation r=new JcRelation(RelationPrefix.concat(String.valueOf(i)));
      removeStartClauses.add(START.relation(r).byId(id.longValue()));
      removeClauses.add(DO.DELETE(r));
    }
  }
  if (clauses != null || removeStartClauses != null) {
    JcQuery query;
    List<JcQuery> queries=new ArrayList<JcQuery>();
    if (clauses != null) {
      clauses.add(RETURN.ALL());
      IClause[] clausesArray=clauses.toArray(new IClause[clauses.size()]);
      query=new JcQuery();
      query.setClauses(clausesArray);
      queries.add(query);
    }
    if (removeStartClauses != null) {
      removeStartClauses.addAll(removeClauses);
      query=new JcQuery();
      query.setClauses(removeStartClauses.toArray(new IClause[removeStartClauses.size()]));
      queries.add(query);
    }
    List<JcQueryResult> results=this.dbAccess.execute(queries);
    List<JcError> errors=Util.collectErrors(results);
    if (errors.size() > 0) {
      throw new JcResultException(errors);
    }
    if (clauses != null) {
      JcQueryResult result=results.get(0);
      graph=result.getGraph();
      if (nodeIndexMap != null) {
        Iterator<Entry<Integer,QueryNode2ResultNode>> nit=nodeIndexMap.entrySet().iterator();
        while (nit.hasNext()) {
          Entry<Integer,QueryNode2ResultNode> entry=nit.next();
          entry.getValue().resultNode=result.resultOf(entry.getValue().queryNode).get(0);
        }
      }
      if (relationIndexMap != null) {
        Iterator<Entry<Integer,QueryRelation2ResultRelation>> rit=relationIndexMap.entrySet().iterator();
        while (rit.hasNext()) {
          Entry<Integer,QueryRelation2ResultRelation> entry=rit.next();
          entry.getValue().resultRelation=result.resultOf(entry.getValue().queryRelation).get(0);
        }
      }
    }
  }
  if (graph == null)   graph=Graph.create(this.dbAccess);
  context.domObj2Node=new HashMap<Object,GrNode>(context.domainObjects.size());
  context.domRelation2Relations=new ArrayList<DomRelation2ResultRelation>();
  for (int i=0; i < context.domainObjects.size(); i++) {
    GrNode rNode=null;
    if (nodeIndexMap != null && nodeIndexMap.get(i) != null) {
      rNode=nodeIndexMap.get(i).resultNode;
    }
    if (rNode == null)     rNode=graph.createNode();
    context.domObj2Node.put(context.domainObjects.get(i),rNode);
    updateFromObject(context.domainObjects.get(i),rNode);
  }
  for (int i=0; i < context.relations.size(); i++) {
    GrRelation rRelation=null;
    if (relationIndexMap != null && relationIndexMap.get(i) != null) {
      rRelation=relationIndexMap.get(i).resultRelation;
    }
    if (rRelation == null) {
      Relation relat=context.relations.get(i);
      rRelation=graph.createRelation(relat.getType(),context.domObj2Node.get(relat.getStart()),context.domObj2Node.get(relat.getEnd()));
      DomRelation2ResultRelation d2r=new DomRelation2ResultRelation();
      d2r.domRelation=relat;
      d2r.resultRelation=rRelation;
      context.domRelation2Relations.add(d2r);
    }
  }
  context.graph=graph;
  return context;
}","private UpdateContext updateLocalGraph(List<Object> domainObjects){
  UpdateContext context=new UpdateContext();
  new ClosureCalculator().calculateClosure(domainObjects,context);
  Graph graph=null;
  Object domainObject;
  Map<Integer,QueryNode2ResultNode> nodeIndexMap=null;
  List<IClause> clauses=null;
  List<IClause> removeStartClauses=null;
  List<IClause> removeClauses=null;
  for (int i=0; i < context.domainObjects.size(); i++) {
    domainObject=context.domainObjects.get(i);
    Long id=this.domainState.getIdFrom_Object2IdMap(domainObject);
    if (id != null) {
      JcNode n=new JcNode(NodePrefix.concat(String.valueOf(i)));
      QueryNode2ResultNode n2n=new QueryNode2ResultNode();
      n2n.queryNode=n;
      if (nodeIndexMap == null)       nodeIndexMap=new HashMap<Integer,QueryNode2ResultNode>();
      nodeIndexMap.put(new Integer(i),n2n);
      if (clauses == null)       clauses=new ArrayList<IClause>();
      clauses.add(START.node(n).byId(id.longValue()));
    }
  }
  Map<Integer,QueryRelation2ResultRelation> relationIndexMap=null;
  for (int i=0; i < context.relations.size(); i++) {
    Relation relat=context.relations.get(i);
    Long id=this.domainState.getFrom_Relation2IdMap(relat);
    if (id != null) {
      JcRelation r=new JcRelation(RelationPrefix.concat(String.valueOf(i)));
      QueryRelation2ResultRelation r2r=new QueryRelation2ResultRelation();
      r2r.queryRelation=r;
      if (relationIndexMap == null)       relationIndexMap=new HashMap<Integer,QueryRelation2ResultRelation>();
      relationIndexMap.put(new Integer(i),r2r);
      clauses.add(START.relation(r).byId(id.longValue()));
    }
  }
  if (context.relationsToRemove.size() > 0) {
    removeStartClauses=new ArrayList<IClause>();
    removeClauses=new ArrayList<IClause>();
    for (int i=0; i < context.relationsToRemove.size(); i++) {
      Relation relat=context.relationsToRemove.get(i);
      Long id=this.domainState.getFrom_Relation2IdMap(relat);
      JcRelation r=new JcRelation(RelationPrefix.concat(String.valueOf(i)));
      removeStartClauses.add(START.relation(r).byId(id.longValue()));
      removeClauses.add(DO.DELETE(r));
    }
  }
  if (clauses != null || removeStartClauses != null) {
    JcQuery query;
    List<JcQuery> queries=new ArrayList<JcQuery>();
    if (clauses != null) {
      clauses.add(RETURN.ALL());
      IClause[] clausesArray=clauses.toArray(new IClause[clauses.size()]);
      query=new JcQuery();
      query.setClauses(clausesArray);
      queries.add(query);
    }
    if (removeStartClauses != null) {
      removeStartClauses.addAll(removeClauses);
      query=new JcQuery();
      query.setClauses(removeStartClauses.toArray(new IClause[removeStartClauses.size()]));
      queries.add(query);
    }
    List<JcQueryResult> results=this.dbAccess.execute(queries);
    List<JcError> errors=Util.collectErrors(results);
    if (errors.size() > 0) {
      throw new JcResultException(errors);
    }
    if (clauses != null) {
      JcQueryResult result=results.get(0);
      graph=result.getGraph();
      if (nodeIndexMap != null) {
        Iterator<Entry<Integer,QueryNode2ResultNode>> nit=nodeIndexMap.entrySet().iterator();
        while (nit.hasNext()) {
          Entry<Integer,QueryNode2ResultNode> entry=nit.next();
          entry.getValue().resultNode=result.resultOf(entry.getValue().queryNode).get(0);
        }
      }
      if (relationIndexMap != null) {
        Iterator<Entry<Integer,QueryRelation2ResultRelation>> rit=relationIndexMap.entrySet().iterator();
        while (rit.hasNext()) {
          Entry<Integer,QueryRelation2ResultRelation> entry=rit.next();
          entry.getValue().resultRelation=result.resultOf(entry.getValue().queryRelation).get(0);
        }
      }
    }
  }
  if (graph == null)   graph=Graph.create(this.dbAccess);
  context.domObj2Node=new HashMap<Object,GrNode>(context.domainObjects.size());
  context.domRelation2Relations=new ArrayList<DomRelation2ResultRelation>();
  for (int i=0; i < context.domainObjects.size(); i++) {
    GrNode rNode=null;
    if (nodeIndexMap != null && nodeIndexMap.get(i) != null) {
      rNode=nodeIndexMap.get(i).resultNode;
    }
    if (rNode == null)     rNode=graph.createNode();
    context.domObj2Node.put(context.domainObjects.get(i),rNode);
    updateFromObject(context.domainObjects.get(i),rNode);
  }
  for (int i=0; i < context.relations.size(); i++) {
    GrRelation rRelation=null;
    if (relationIndexMap != null && relationIndexMap.get(i) != null) {
      rRelation=relationIndexMap.get(i).resultRelation;
    }
    if (rRelation == null) {
      Relation relat=context.relations.get(i);
      rRelation=graph.createRelation(relat.getType(),context.domObj2Node.get(relat.getStart()),context.domObj2Node.get(relat.getEnd()));
      DomRelation2ResultRelation d2r=new DomRelation2ResultRelation();
      d2r.domRelation=relat;
      d2r.resultRelation=rRelation;
      context.domRelation2Relations.add(d2r);
    }
  }
  context.graph=graph;
  return context;
}",0.9998006379585328
80512,"ClosureQueryContext(Class<?> domainObjectClass){
  super();
  this.domainObjectClass=domainObjectClass;
}","ClosureQueryContext(Class<?> domainObjectClass){
  super();
  this.domainObjectClass=domainObjectClass;
  this.visitedTypes=new ArrayList<Class<?>>();
}",0.8171206225680934
80513,"private void addTo_Object2IdMap(Object key,Long value){
  this.object2IdMap.put(key,value);
}","private void addTo_Object2IdMap(Object key,Long value){
  LoadInfo loadInfo=new LoadInfo();
  loadInfo.id=value;
  this.object2IdMap.put(key,loadInfo);
}",0.7235772357723578
80514,"public DomainState(){
  super();
  this.object2IdMap=new HashMap<Object,Long>();
  this.relation2IdMap=new HashMap<Relation,Long>();
  this.id2ObjectsMap=new HashMap<Long,List<Object>>();
  this.object2RelationsMap=new HashMap<Object,List<Relation>>();
}","public DomainState(){
  super();
  this.object2IdMap=new HashMap<Object,LoadInfo>();
  this.relation2IdMap=new HashMap<Relation,Long>();
  this.id2ObjectsMap=new HashMap<Long,List<Object>>();
  this.object2RelationsMap=new HashMap<Object,List<Relation>>();
}",0.43359375
80515,"public void mapPropertyFromField(Object domainObject,GrNode rNode){
  try {
    prepare(domainObject);
    Object value=this.field.get(domainObject);
    Class<?> typ=this.field.getType();
    if (MappingUtil.mapsToProperty(typ)) {
      value=MappingUtil.convertToProperty(value);
      GrProperty prop=rNode.getProperty(this.propertyName);
      if (prop != null) {
        if (!prop.getValue().equals(value)) {
          prop.remove();
          prop=null;
        }
      }
      if (prop == null)       rNode.addProperty(this.propertyName,value);
    }
  }
 catch (  Throwable e) {
    throw new RuntimeException(e);
  }
}","public void mapPropertyFromField(Object domainObject,GrNode rNode){
  try {
    prepare(domainObject);
    Object value=this.field.get(domainObject);
    Class<?> typ=this.field.getType();
    if (MappingUtil.mapsToProperty(typ)) {
      value=MappingUtil.convertToProperty(value);
      GrProperty prop=rNode.getProperty(this.propertyName);
      if (value != null) {
        if (prop != null) {
          Object propValue=MappingUtil.convertFromProperty(prop.getValue(),value.getClass());
          if (!propValue.equals(value)) {
            prop.setValue(value);
          }
        }
 else         rNode.addProperty(this.propertyName,value);
      }
 else {
        if (prop != null)         prop.setValue(null);
      }
    }
  }
 catch (  Throwable e) {
    throw new RuntimeException(e);
  }
}",0.6988795518207283
80516,"public static Object convertFromProperty(Object value,Class<?> targetType){
  if (value != null) {
    if (Date.class.isAssignableFrom(targetType) && value instanceof Number) {
      return longToDate(((Number)value).longValue());
    }
 else     if (Enum.class.isAssignableFrom(targetType)) {
      Object[] enums=targetType.getEnumConstants();
      for (int i=0; i < enums.length; i++) {
        if (((Enum<?>)enums[i]).name().equals(value.toString()))         return enums[i];
      }
      return value;
    }
 else     if (targetType.equals(value.getClass())) {
      return value;
    }
 else     if (targetType.isPrimitive()) {
      return convertToPrimitive(value,targetType);
    }
 else     if (targetType.isAssignableFrom(value.getClass())) {
      return targetType.cast(value);
    }
  }
  return value;
}","public static Object convertFromProperty(Object value,Class<?> targetType){
  if (value != null) {
    if (Date.class.isAssignableFrom(targetType) && value instanceof Number) {
      return longToDate(((Number)value).longValue());
    }
 else     if (Enum.class.isAssignableFrom(targetType)) {
      Object[] enums=targetType.getEnumConstants();
      for (int i=0; i < enums.length; i++) {
        if (((Enum<?>)enums[i]).name().equals(value.toString()))         return enums[i];
      }
      return value;
    }
 else     if (targetType.equals(value.getClass())) {
      return value;
    }
 else     if (targetType.isPrimitive()) {
      return convertToPrimitive(value,targetType);
    }
 else     if (targetType.isAssignableFrom(value.getClass())) {
      return targetType.cast(value);
    }
 else     if (Number.class.isAssignableFrom(targetType)) {
      return convertToDistinctNumber(value,targetType);
    }
  }
  return value;
}",0.915388983532084
80517,"public void setValue(Object value){
  Object val=value;
  if (val.getClass().isArray()) {
    int length=Array.getLength(val);
    ArrayList<Object> list=new ArrayList<>();
    for (int i=0; i < length; i++) {
      Object arrayElement=Array.get(val,i);
      list.add(arrayElement);
    }
    val=list;
  }
  Object oldVal=this.value;
  this.value=val;
  if (oldVal != null && oldVal != this.value) {
    SyncState oldState=this.syncState;
    if (this.syncState == SyncState.SYNC)     this.syncState=SyncState.CHANGED;
    if (oldState != this.syncState)     fireChanged(oldState,this.syncState);
  }
}","public void setValue(Object value){
  Object val=value;
  if (val != null && val.getClass().isArray()) {
    int length=Array.getLength(val);
    ArrayList<Object> list=new ArrayList<>();
    for (int i=0; i < length; i++) {
      Object arrayElement=Array.get(val,i);
      list.add(arrayElement);
    }
    val=list;
  }
  Object oldVal=this.value;
  this.value=val;
  if (oldVal != null && oldVal != this.value) {
    SyncState oldState=this.syncState;
    if (this.syncState == SyncState.SYNC)     this.syncState=SyncState.CHANGED;
    if (oldState != this.syncState)     fireChanged(oldState,this.syncState);
  }
}",0.9877350776778414
80518,"/** 
 * Update the underlying database with changes made on the graph
 * @return a list of errors, which is empty if no errors occurred
 */
public List<JcError> store(){
  if (isModified())   return this.resultHandler.store();
  return null;
}","/** 
 * Update the underlying database with changes made on the graph
 * @return a list of errors, which is empty if no errors occurred
 */
public List<JcError> store(){
  if (isModified())   return this.resultHandler.store();
  return Collections.emptyList();
}",0.9465346534653464
80519,"@Override public void onViewBind(View view,Cursor cr,ODataRow row){
  int to_read=cr.getInt(cr.getColumnIndex(""String_Node_Str""));
  view.setBackgroundResource(background_resources[to_read]);
  ImageView imgStarred=(ImageView)view.findViewById(R.id.img_starred_mlist);
  int is_fav=cr.getInt(cr.getColumnIndex(""String_Node_Str""));
  imgStarred.setColorFilter((is_fav == 1) ? Color.parseColor(""String_Node_Str"") : Color.parseColor(""String_Node_Str""));
  OField totalChilds=(OField)view.findViewById(R.id.totalChilds);
  int replies=Integer.parseInt(cr.getString(cr.getColumnIndex(""String_Node_Str"")));
  String childs=""String_Node_Str"";
  if (replies > 0) {
    childs=replies + ""String_Node_Str"";
  }
  totalChilds.setText(childs);
}","@Override public void onViewBind(View view,Cursor cr,ODataRow row){
  int to_read=cr.getInt(cr.getColumnIndex(""String_Node_Str""));
  view.setBackgroundResource(background_resources[to_read]);
  ImageView imgStarred=(ImageView)view.findViewById(R.id.img_starred_mlist);
  int is_fav=0;
  is_fav=cr.getInt(cr.getColumnIndex(""String_Node_Str""));
  imgStarred.setColorFilter((is_fav == 1) ? Color.parseColor(""String_Node_Str"") : Color.parseColor(""String_Node_Str""));
  OField totalChilds=(OField)view.findViewById(R.id.totalChilds);
  int replies=0;
  String total_childs=cr.getString(cr.getColumnIndex(""String_Node_Str""));
  replies=Integer.parseInt(total_childs);
  String childs=""String_Node_Str"";
  if (replies > 0) {
    childs=replies + ""String_Node_Str"";
  }
  totalChilds.setText(childs);
}",0.7085789129011133
80520,"public Odoo createInstance(){
  Odoo odoo=null;
  OUser user=OUser.current(getApplicationContext());
  if (user != null) {
    try {
      if (user.isOAauthLogin()) {
        odoo=new Odoo(user.getInstanceUrl(),user.isAllowSelfSignedSSL());
        OdooInstance instance=new OdooInstance();
        instance.setInstanceUrl(user.getInstanceUrl());
        instance.setDatabaseName(user.getInstanceDatabase());
        instance.setClientId(user.getClientId());
        odoo.oauth_authenticate(instance,user.getUsername(),user.getPassword());
      }
 else {
        odoo=new Odoo(user.getHost(),user.isAllowSelfSignedSSL());
        odoo.authenticate(user.getUsername(),user.getPassword(),user.getDatabase());
      }
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
  }
  return odoo;
}","public Odoo createInstance(){
  Odoo odoo=null;
  OUser user=OUser.current(getApplicationContext());
  if (user != null) {
    try {
      if (user.isOAauthLogin()) {
        odoo=new Odoo(user.getInstanceUrl(),user.isAllowSelfSignedSSL());
        OdooInstance instance=new OdooInstance();
        instance.setInstanceUrl(user.getInstanceUrl());
        instance.setDatabaseName(user.getInstanceDatabase());
        instance.setClientId(user.getClientId());
        odoo.oauth_authenticate(instance,user.getUsername(),user.getPassword());
      }
 else {
        odoo=new Odoo(user.getHost(),user.isAllowSelfSignedSSL());
        odoo.authenticate(user.getUsername(),user.getPassword(),user.getDatabase());
      }
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
  }
  mOdooInstance=odoo;
  return odoo;
}",0.986469864698647
80521,"/** 
 * Removes the account.
 * @param context the context
 * @param username the username
 */
public static void removeAccount(Context context,String username){
  AccountManager accMgr=AccountManager.get(context);
  accMgr.removeAccount(OpenERPAccountManager.getAccount(context,username),null,null);
  App app=(App)context.getApplicationContext();
  app.setOEInstance(null);
  current_user=null;
}","/** 
 * Removes the account.
 * @param context the context
 * @param username the username 
 */
public static void removeAccount(Context context,String username){
  AccountManager accMgr=AccountManager.get(context);
  accMgr.removeAccount(OpenERPAccountManager.getAccount(context,username),null,null);
  App app=(App)context.getApplicationContext();
  app.setOEInstance(null);
  current_user=null;
}",0.998745294855709
80522,"private static boolean cancelAllSync(Account account){
  SyncWizardValues syncVals=new SyncWizardValues();
  boolean flag=false;
  for (  SyncValue sync : syncVals.syncValues()) {
    ContentResolver.cancelSync(account,sync.getAuthority());
    flag=true;
  }
  return flag;
}","private static boolean cancelAllSync(Account account){
  SyncWizardValues syncVals=new SyncWizardValues();
  for (  SyncValue sync : syncVals.syncValues()) {
    ContentResolver.cancelSync(account,sync.getAuthority());
  }
  return true;
}",0.8854368932038835
80523,"private void updateSyncSettings(){
  Log.d(TAG,""String_Node_Str"");
  PreferenceManager mPref=new PreferenceManager(mContext);
  int sync_interval=mPref.getInt(""String_Node_Str"",1440);
  List<String> default_authorities=new ArrayList<String>();
  default_authorities.add(""String_Node_Str"");
  default_authorities.add(""String_Node_Str"");
  SyncAdapterType[] list=ContentResolver.getSyncAdapterTypes();
  Account mAccount=OpenERPAccountManager.getAccount(mContext,OEUser.current(mContext).getAndroidName());
  for (  SyncAdapterType lst : list) {
    if (lst.authority.contains(""String_Node_Str"")) {
      default_authorities.add(lst.authority);
    }
  }
  for (  String authority : default_authorities) {
    boolean isSyncActive=ContentResolver.getSyncAutomatically(mAccount,authority);
    if (isSyncActive) {
      setSyncPeriodic(authority,sync_interval,1,1);
    }
  }
  Toast.makeText(this,R.string.toast_setting_saved,Toast.LENGTH_LONG).show();
}","private void updateSyncSettings(){
  Log.d(TAG,""String_Node_Str"");
  PreferenceManager mPref=new PreferenceManager(mContext);
  int sync_interval=mPref.getInt(""String_Node_Str"",1440);
  List<String> default_authorities=new ArrayList<String>();
  default_authorities.add(""String_Node_Str"");
  default_authorities.add(""String_Node_Str"");
  SyncAdapterType[] list=ContentResolver.getSyncAdapterTypes();
  Account mAccount=OpenERPAccountManager.getAccount(mContext,OEUser.current(mContext).getAndroidName());
  for (  SyncAdapterType lst : list) {
    if (lst.authority.contains(""String_Node_Str"") && lst.authority.contains(""String_Node_Str"")) {
      default_authorities.add(lst.authority);
    }
  }
  for (  String authority : default_authorities) {
    boolean isSyncActive=ContentResolver.getSyncAutomatically(mAccount,authority);
    if (isSyncActive) {
      setSyncPeriodic(authority,sync_interval,60,1);
    }
  }
  Toast.makeText(this,R.string.toast_setting_saved,Toast.LENGTH_LONG).show();
}",0.9753846153846154
80524,"private void initDrawer(List<DrawerItem> drawerItems){
  Res_PartnerDBHelper partner=new Res_PartnerDBHelper(context);
  Object obj=partner.search(partner,new String[]{""String_Node_Str""},new String[]{""String_Node_Str""},new String[]{OEUser.current(context).getPartner_id()}).get(""String_Node_Str"");
  String user_name=""String_Node_Str"";
  if (obj instanceof Boolean) {
    user_name=OEUser.current(context).getUsername();
  }
 else {
    user_name=((List<HashMap<String,Object>>)obj).get(0).get(""String_Node_Str"").toString();
  }
  mDrawerTitle=user_name;
  mDrawerSubtitle=OEUser.current(context).getHost();
  getActionBar().setHomeButtonEnabled(true);
  getActionBar().setDisplayHomeAsUpEnabled(true);
  setDrawerItems(drawerItems);
}","private void initDrawer(List<DrawerItem> drawerItems){
  Res_PartnerDBHelper partner=new Res_PartnerDBHelper(context);
  Object obj=partner.search(partner,new String[]{""String_Node_Str""},new String[]{""String_Node_Str""},new String[]{OEUser.current(context).getPartner_id()}).get(""String_Node_Str"");
  String user_name=""String_Node_Str"";
  if (obj instanceof Boolean) {
    user_name=OEUser.current(context).getUsername();
  }
 else {
    user_name=((List<HashMap<String,Object>>)obj).get(0).get(""String_Node_Str"").toString();
  }
  mDrawerTitle=user_name;
  mDrawerSubtitle=OEUser.current(context).getHost();
  getActionBar().setHomeButtonEnabled(true);
  getActionBar().setDisplayHomeAsUpEnabled(true);
  setDrawerItems(drawerItems);
  if (mDrawerItemSelectedPosition > 0) {
    mAppTitle=mDrawerListItems.get(mDrawerItemSelectedPosition).getTitle();
    setTitle(mAppTitle);
  }
}",0.9096534653465348
80525,"@Override public void onStart(){
  super.onStart();
  mDrawerListView.setOnItemClickListener(this);
  int position=-1;
  if (mDrawerListItems.size() > 0) {
    if (!mDrawerListItems.get(0).isGroupTitle()) {
      mDrawerListView.setItemChecked(0,true);
      position=0;
    }
 else {
      mDrawerListView.setItemChecked(1,true);
      position=1;
    }
  }
  if (mDrawerItemSelectedPosition >= 0) {
    position=mDrawerItemSelectedPosition;
  }
  if (getIntent().getAction() != null && !getIntent().getAction().toString().equalsIgnoreCase(""String_Node_Str"")) {
    if (getIntent().getAction().toString().equalsIgnoreCase(""String_Node_Str"")) {
      startActivity(new Intent(context,MessageComposeActivty.class));
    }
    if (getIntent().getAction().toString().equalsIgnoreCase(""String_Node_Str"")) {
      startActivity(new Intent(context,ComposeNoteActivity.class));
    }
  }
 else {
    if (position > 0) {
      loadFragment(mDrawerListItems.get(position));
    }
  }
}","@Override public void onStart(){
  super.onStart();
  mDrawerListView.setOnItemClickListener(this);
  int position=-1;
  if (mDrawerListItems.size() > 0) {
    if (!mDrawerListItems.get(0).isGroupTitle()) {
      mDrawerListView.setItemChecked(0,true);
      position=0;
    }
 else {
      mDrawerListView.setItemChecked(1,true);
      position=1;
    }
  }
  if (mDrawerItemSelectedPosition >= 0) {
    position=mDrawerItemSelectedPosition;
  }
  if (getIntent().getAction() != null && !getIntent().getAction().toString().equalsIgnoreCase(""String_Node_Str"")) {
    if (getIntent().getAction().toString().equalsIgnoreCase(""String_Node_Str"")) {
      startActivity(new Intent(context,MessageComposeActivty.class));
    }
    if (getIntent().getAction().toString().equalsIgnoreCase(""String_Node_Str"")) {
      startActivity(new Intent(context,ComposeNoteActivity.class));
    }
  }
 else {
    if (position > 0) {
      if (position != mDrawerItemSelectedPosition) {
        loadFragment(mDrawerListItems.get(position));
      }
    }
  }
}",0.9687344913151364
80526,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_main);
  context=this;
  if (isStateExist == null) {
    NoteDBHelper db=new NoteDBHelper(context);
    isStateExist=String.valueOf(db.isPadExist());
  }
  if (findViewById(R.id.fragment_container) != null) {
    initDrawerControls();
    fragmentHandler=new FragmentHandler(this);
    boot=new Boot(this);
    if (savedInstanceState != null) {
      mPullToRefreshAttacher=new PullToRefreshAttacher(this);
      initDrawer(boot.getDrawerItems());
      return;
    }
    if (OpenERPAccountManager.hasAccounts(this) == false) {
      getActionBar().setDisplayHomeAsUpEnabled(false);
      getActionBar().setHomeButtonEnabled(false);
      lockDrawer(true);
      Fragment fragment=new AccountFragment();
      fragmentHandler.setBackStack(true,null);
      fragmentHandler.startNewFragmnet(fragment);
      return;
    }
 else {
      lockDrawer(false);
      Intent intent=getIntent();
      boolean reqForNewAccount=intent.getBooleanExtra(""String_Node_Str"",false);
      if (OpenERPAccountManager.isAnyUser(this) && !reqForNewAccount) {
        initDrawer(boot.getDrawerItems());
        mPullToRefreshAttacher=new PullToRefreshAttacher(this);
        if (savedInstanceState != null) {
          return;
        }
      }
 else {
        if (reqForNewAccount) {
          getActionBar().setDisplayHomeAsUpEnabled(false);
          getActionBar().setHomeButtonEnabled(false);
          Fragment fragment=new AccountFragment();
          fragmentHandler.startNewFragmnet(fragment);
          return;
        }
 else {
          Dialog dialog=onCreateDialogSingleChoice();
          dialog.setCancelable(false);
          dialog.show();
        }
      }
    }
  }
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_main);
  context=this;
  if (isStateExist == null) {
    NoteDBHelper db=new NoteDBHelper(context);
    isStateExist=String.valueOf(db.isPadExist());
  }
  if (findViewById(R.id.fragment_container) != null) {
    initDrawerControls();
    fragmentHandler=new FragmentHandler(this);
    boot=new Boot(this);
    if (savedInstanceState != null) {
      mDrawerItemSelectedPosition=savedInstanceState.getInt(""String_Node_Str"");
      mPullToRefreshAttacher=new PullToRefreshAttacher(this);
      initDrawer(boot.getDrawerItems());
      return;
    }
    if (OpenERPAccountManager.hasAccounts(this) == false) {
      getActionBar().setDisplayHomeAsUpEnabled(false);
      getActionBar().setHomeButtonEnabled(false);
      lockDrawer(true);
      Fragment fragment=new AccountFragment();
      fragmentHandler.setBackStack(true,null);
      fragmentHandler.startNewFragmnet(fragment);
      return;
    }
 else {
      lockDrawer(false);
      Intent intent=getIntent();
      boolean reqForNewAccount=intent.getBooleanExtra(""String_Node_Str"",false);
      if (OpenERPAccountManager.isAnyUser(this) && !reqForNewAccount) {
        initDrawer(boot.getDrawerItems());
        mPullToRefreshAttacher=new PullToRefreshAttacher(this);
        if (savedInstanceState != null) {
          return;
        }
      }
 else {
        if (reqForNewAccount) {
          getActionBar().setDisplayHomeAsUpEnabled(false);
          getActionBar().setHomeButtonEnabled(false);
          Fragment fragment=new AccountFragment();
          fragmentHandler.startNewFragmnet(fragment);
          return;
        }
 else {
          Dialog dialog=onCreateDialogSingleChoice();
          dialog.setCancelable(false);
          dialog.show();
        }
      }
    }
  }
}",0.9782608695652174
80527,"private void initDrawer(List<DrawerItem> drawerItems){
  Res_PartnerDBHelper partner=new Res_PartnerDBHelper(context);
  Object obj=partner.search(partner,new String[]{""String_Node_Str""},new String[]{""String_Node_Str""},new String[]{OEUser.current(context).getPartner_id()}).get(""String_Node_Str"");
  String user_name=""String_Node_Str"";
  if (obj instanceof Boolean) {
    user_name=OEUser.current(context).getUsername();
  }
 else {
    user_name=((List<HashMap<String,Object>>)obj).get(0).get(""String_Node_Str"").toString();
  }
  mDrawerTitle=user_name;
  mDrawerSubtitle=OEUser.current(context).getHost();
  getActionBar().setHomeButtonEnabled(true);
  getActionBar().setDisplayHomeAsUpEnabled(true);
  setDrawerItems(drawerItems);
  if (mDrawerItemSelectedPosition > 0) {
    mAppTitle=mDrawerListItems.get(mDrawerItemSelectedPosition).getTitle();
    setTitle(mAppTitle);
  }
}","private void initDrawer(List<DrawerItem> drawerItems){
  if (OEUser.current(context) != null) {
    Res_PartnerDBHelper partner=new Res_PartnerDBHelper(context);
    Object obj=partner.search(partner,new String[]{""String_Node_Str""},new String[]{""String_Node_Str""},new String[]{OEUser.current(context).getPartner_id()}).get(""String_Node_Str"");
    String user_name=""String_Node_Str"";
    if (obj instanceof Boolean) {
      user_name=OEUser.current(context).getUsername();
    }
 else {
      user_name=((List<HashMap<String,Object>>)obj).get(0).get(""String_Node_Str"").toString();
    }
    mDrawerTitle=user_name;
    mDrawerSubtitle=OEUser.current(context).getHost();
    getActionBar().setHomeButtonEnabled(true);
    getActionBar().setDisplayHomeAsUpEnabled(true);
    setDrawerItems(drawerItems);
    if (mDrawerItemSelectedPosition > 0) {
      mAppTitle=mDrawerListItems.get(mDrawerItemSelectedPosition).getTitle();
      setTitle(mAppTitle);
    }
  }
}",0.9570885388375884
80528,"@Override public OEMenu menuHelper(Context context){
  OEMenu menu=new OEMenu();
  menu.setId(1);
  menu.setMenuTitle(""String_Node_Str"");
  setNoteStages(context);
  List<OEMenuItems> items=new ArrayList<OEMenuItems>();
  items.add(new OEMenuItems(""String_Node_Str"",getFragBundle(""String_Node_Str"",""String_Node_Str""),getCount(""String_Node_Str"",context)));
  items.add(new OEMenuItems(""String_Node_Str"",getFragBundle(""String_Node_Str"",""String_Node_Str""),0));
  if (stages != null) {
    int i=0;
    for (    String key : stages.keySet()) {
      if (i > tag_colors.length - 1) {
        i=0;
      }
      OEMenuItems stageMenu=new OEMenuItems(stages.get(key).toString(),getFragBundle(""String_Node_Str"",key),getCount(key,context));
      stageMenu.setAutoMenuTagColor(true);
      stageMenu.setMenuTagColor(Color.parseColor(tag_colors[i]));
      stage_colors.put(""String_Node_Str"" + key,stageMenu.getMenuTagColor());
      items.add(stageMenu);
      i++;
    }
  }
  menu.setMenuItems(items);
  return menu;
}","@Override public OEMenu menuHelper(Context context){
  db=(NoteDBHelper)databaseHelper(context);
  if (db.getOEInstance().isInstalled(""String_Node_Str"")) {
    OEMenu menu=new OEMenu();
    menu.setId(1);
    menu.setMenuTitle(""String_Node_Str"");
    setNoteStages(context);
    List<OEMenuItems> items=new ArrayList<OEMenuItems>();
    items.add(new OEMenuItems(""String_Node_Str"",getFragBundle(""String_Node_Str"",""String_Node_Str""),getCount(""String_Node_Str"",context)));
    items.add(new OEMenuItems(""String_Node_Str"",getFragBundle(""String_Node_Str"",""String_Node_Str""),0));
    if (stages != null) {
      int i=0;
      for (      String key : stages.keySet()) {
        if (i > tag_colors.length - 1) {
          i=0;
        }
        OEMenuItems stageMenu=new OEMenuItems(stages.get(key).toString(),getFragBundle(""String_Node_Str"",key),getCount(key,context));
        stageMenu.setAutoMenuTagColor(true);
        stageMenu.setMenuTagColor(Color.parseColor(tag_colors[i]));
        stage_colors.put(""String_Node_Str"" + key,stageMenu.getMenuTagColor());
        items.add(stageMenu);
        i++;
      }
    }
    menu.setMenuItems(items);
    return menu;
  }
 else {
    return null;
  }
}",0.8694469628286491
80529,"public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  setHasOptionsMenu(true);
  scope=new AppScope(MainActivity.userContext,(MainActivity)getActivity());
  db=(NoteDBHelper)getModel();
  rootView=inflater.inflate(R.layout.fragment_note,container,false);
  lstNotes=(ListView)rootView.findViewById(R.id.lstNotes);
  emptyNotesText=(TextView)rootView.findViewById(R.id.txvNoteAllArchive);
  handleArguments((Bundle)getArguments());
  return rootView;
}","public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  scope=new AppScope(MainActivity.userContext,(MainActivity)getActivity());
  db=(NoteDBHelper)getModel();
  setHasOptionsMenu(true);
  rootView=inflater.inflate(R.layout.fragment_note,container,false);
  lstNotes=(ListView)rootView.findViewById(R.id.lstNotes);
  emptyNotesText=(TextView)rootView.findViewById(R.id.txvNoteAllArchive);
  handleArguments((Bundle)getArguments());
  return rootView;
}",0.9455645161290324
80530,"/** 
 * Load base modules.
 */
private void loadBaseModules(){
  this.modules.add(new Module(""String_Node_Str"",""String_Node_Str"",new ResFragment(),0));
  this.modules.add(new Module(""String_Node_Str"",""String_Node_Str"",new AttachmentFragment(),0));
}","/** 
 * Load base modules.
 */
private void loadBaseModules(){
  this.modules.add(new Module(""String_Node_Str"",""String_Node_Str"",new ResFragment(),0));
  this.modules.add(new Module(""String_Node_Str"",""String_Node_Str"",new AttachmentFragment(),0));
  this.modules.add(new Module(""String_Node_Str"",""String_Node_Str"",new Ir_modelFragment(),0));
}",0.8412162162162162
80531,"public NutResource get_material(String media_id){
  String url=String.format(""String_Node_Str"",getAccessToken());
  Request req=Request.create(url,METHOD.POST);
  req.getParams().put(""String_Node_Str"",media_id);
  final Response resp=Sender.create(req).send();
  if (!resp.isOK())   throw new IllegalStateException(""String_Node_Str"" + resp.getStatus());
  String disposition=resp.getHeader().get(""String_Node_Str"");
  return new WxResource(disposition,resp.getStream());
}","public NutResource get_material(String media_id){
  String url=String.format(""String_Node_Str"",getAccessToken());
  Request req=Request.create(url,METHOD.POST);
  NutMap body=new NutMap();
  body.put(""String_Node_Str"",media_id);
  req.setData(Json.toJson(body));
  final Response resp=Sender.create(req).send();
  if (!resp.isOK())   throw new IllegalStateException(""String_Node_Str"" + resp.getStatus());
  String disposition=resp.getHeader().get(""String_Node_Str"");
  return new WxResource(disposition,resp.getStream());
}",0.9185929648241206
80532,"public WxResp add_news(WxArticle... news){
  return postJson(""String_Node_Str"",new NutMap().put(""String_Node_Str"",Arrays.asList(news)));
}","public WxResp add_news(WxMassArticle... news){
  return postJson(""String_Node_Str"",""String_Node_Str"",Arrays.asList(news));
}",0.916030534351145
80533,WxResp add_news(WxArticle... news);,WxResp add_news(WxMassArticle... news);,0.945945945945946
80534,"/** 
 * Test that Share Quota can be set, but only to allowable values.
 * @throws StorageException 
 * @throws URISyntaxException 
 */
@Test public void testCloudFileShareQuota() throws StorageException, URISyntaxException {
  this.share.createIfNotExists();
  this.share.downloadAttributes();
  assertNotNull(this.share.getProperties().getShareQuota());
  int shareQuota=FileConstants.MAX_SHARE_QUOTA;
  assertEquals(shareQuota,this.share.getProperties().getShareQuota().intValue());
  shareQuota=8;
  this.share.getProperties().setShareQuota(shareQuota);
  this.share.uploadProperties();
  this.share.downloadAttributes();
  assertNotNull(this.share.getProperties().getShareQuota());
  assertEquals(shareQuota,this.share.getProperties().getShareQuota().intValue());
  this.share.delete();
  shareQuota=16;
  this.share=FileTestHelper.getRandomShareReference();
  this.share.getProperties().setShareQuota(shareQuota);
  this.share.create();
  this.share.downloadAttributes();
  assertNotNull(this.share.getProperties().getShareQuota());
  assertEquals(shareQuota,this.share.getProperties().getShareQuota().intValue());
  try {
    shareQuota=FileConstants.MAX_SHARE_QUOTA + 1;
    this.share.getProperties().setShareQuota(shareQuota);
    fail();
  }
 catch (  IllegalArgumentException e) {
    assertEquals(String.format(SR.PARAMETER_NOT_IN_RANGE,""String_Node_Str"",1,FileConstants.MAX_SHARE_QUOTA),e.getMessage());
  }
}","/** 
 * Test that Share Quota can be set, but only to allowable values.
 * @throws StorageException 
 * @throws URISyntaxException 
 */
@Test public void testCloudFileShareQuota() throws StorageException, URISyntaxException {
  this.share.createIfNotExists();
  this.share.downloadAttributes();
  assertNotNull(this.share.getProperties().getShareQuota());
  int shareQuota=FileConstants.MAX_SHARE_QUOTA;
  assertEquals(shareQuota,this.share.getProperties().getShareQuota().intValue());
  shareQuota=8;
  this.share.getProperties().setShareQuota(shareQuota);
  this.share.uploadProperties();
  this.share.downloadAttributes();
  assertNotNull(this.share.getProperties().getShareQuota());
  assertEquals(shareQuota,this.share.getProperties().getShareQuota().intValue());
  this.share.delete();
  shareQuota=16;
  this.share=FileTestHelper.getRandomShareReference();
  this.share.getProperties().setShareQuota(shareQuota);
  this.share.create();
  assertNotNull(this.share.getProperties().getShareQuota());
  assertEquals(shareQuota,this.share.getProperties().getShareQuota().intValue());
  this.share.downloadAttributes();
  assertNotNull(this.share.getProperties().getShareQuota());
  assertEquals(shareQuota,this.share.getProperties().getShareQuota().intValue());
  try {
    shareQuota=FileConstants.MAX_SHARE_QUOTA + 1;
    this.share.getProperties().setShareQuota(shareQuota);
    fail();
  }
 catch (  IllegalArgumentException e) {
    assertEquals(String.format(SR.PARAMETER_NOT_IN_RANGE,""String_Node_Str"",1,FileConstants.MAX_SHARE_QUOTA),e.getMessage());
  }
}",0.952157912345266
80535,"/** 
 * Check uploading/downloading share metadata.
 * @throws StorageException
 * @throws URISyntaxException
 */
@Test public void testCloudFileShareUploadMetadata() throws StorageException, URISyntaxException {
  this.share.create();
  CloudFileShare share2=this.share.getServiceClient().getShareReference(this.share.getName());
  share2.downloadAttributes();
  assertEquals(0,share2.getMetadata().size());
  this.share.getMetadata().put(""String_Node_Str"",""String_Node_Str"");
  this.share.uploadMetadata();
  share2.downloadAttributes();
  assertEquals(1,share2.getMetadata().size());
  assertEquals(""String_Node_Str"",share2.getMetadata().get(""String_Node_Str""));
  Iterable<CloudFileShare> shares=this.share.getServiceClient().listShares(this.share.getName(),ShareListingDetails.METADATA,null,null);
  for (  CloudFileShare share3 : shares) {
    assertEquals(1,share3.getMetadata().size());
    assertEquals(""String_Node_Str"",share3.getMetadata().get(""String_Node_Str""));
  }
  this.share.getMetadata().clear();
  this.share.uploadMetadata();
  share2.downloadAttributes();
  assertEquals(0,share2.getMetadata().size());
}","/** 
 * Check uploading/downloading share metadata.
 * @throws StorageException
 * @throws URISyntaxException
 */
@Test public void testCloudFileShareUploadMetadata() throws StorageException, URISyntaxException {
  this.share.getMetadata().put(""String_Node_Str"",""String_Node_Str"");
  this.share.create();
  Assert.assertEquals(1,this.share.getMetadata().size());
  Assert.assertEquals(""String_Node_Str"",this.share.getMetadata().get(""String_Node_Str""));
  CloudFileShare share2=this.share.getServiceClient().getShareReference(this.share.getName());
  share2.downloadAttributes();
  Assert.assertEquals(1,share2.getMetadata().size());
  Assert.assertEquals(""String_Node_Str"",share2.getMetadata().get(""String_Node_Str""));
  this.share.getMetadata().put(""String_Node_Str"",""String_Node_Str"");
  Assert.assertEquals(2,this.share.getMetadata().size());
  Assert.assertEquals(""String_Node_Str"",this.share.getMetadata().get(""String_Node_Str""));
  Assert.assertEquals(""String_Node_Str"",this.share.getMetadata().get(""String_Node_Str""));
  this.share.uploadMetadata();
  Assert.assertEquals(2,this.share.getMetadata().size());
  Assert.assertEquals(""String_Node_Str"",this.share.getMetadata().get(""String_Node_Str""));
  Assert.assertEquals(""String_Node_Str"",this.share.getMetadata().get(""String_Node_Str""));
  share2.downloadAttributes();
  Assert.assertEquals(2,this.share.getMetadata().size());
  Assert.assertEquals(""String_Node_Str"",this.share.getMetadata().get(""String_Node_Str""));
  Assert.assertEquals(""String_Node_Str"",this.share.getMetadata().get(""String_Node_Str""));
  Iterable<CloudFileShare> shares=this.share.getServiceClient().listShares(this.share.getName(),ShareListingDetails.METADATA,null,null);
  for (  CloudFileShare share3 : shares) {
    Assert.assertEquals(2,share3.getMetadata().size());
    Assert.assertEquals(""String_Node_Str"",share3.getMetadata().get(""String_Node_Str""));
    Assert.assertEquals(""String_Node_Str"",this.share.getMetadata().get(""String_Node_Str""));
  }
  this.share.getMetadata().clear();
  this.share.uploadMetadata();
  share2.downloadAttributes();
  assertEquals(0,share2.getMetadata().size());
}",0.527027027027027
80536,"private StorageRequest<CloudFileClient,CloudFileShare,Void> createImpl(final FileRequestOptions options){
  final StorageRequest<CloudFileClient,CloudFileShare,Void> putRequest=new StorageRequest<CloudFileClient,CloudFileShare,Void>(options,this.getStorageUri()){
    @Override public HttpURLConnection buildRequest(    CloudFileClient client,    CloudFileShare share,    OperationContext context) throws Exception {
      final HttpURLConnection request=FileRequest.createShare(share.getTransformedAddress().getUri(this.getCurrentLocation()),options,context,share.getProperties());
      return request;
    }
    @Override public void setHeaders(    HttpURLConnection connection,    CloudFileShare share,    OperationContext context){
      FileRequest.addMetadata(connection,share.metadata,context);
    }
    @Override public void signRequest(    HttpURLConnection connection,    CloudFileClient client,    OperationContext context) throws Exception {
      StorageRequest.signBlobQueueAndFileRequest(connection,client,0L,context);
    }
    @Override public Void preProcessResponse(    CloudFileShare share,    CloudFileClient client,    OperationContext context) throws Exception {
      if (this.getResult().getStatusCode() != HttpURLConnection.HTTP_CREATED) {
        this.setNonExceptionedRetryableFailure(true);
        return null;
      }
      final FileShareAttributes attributes=FileResponse.getFileShareAttributes(this.getConnection(),client.isUsePathStyleUris());
      share.properties=attributes.getProperties();
      share.name=attributes.getName();
      return null;
    }
  }
;
  return putRequest;
}","private StorageRequest<CloudFileClient,CloudFileShare,Void> createImpl(final FileRequestOptions options){
  final StorageRequest<CloudFileClient,CloudFileShare,Void> putRequest=new StorageRequest<CloudFileClient,CloudFileShare,Void>(options,this.getStorageUri()){
    @Override public HttpURLConnection buildRequest(    CloudFileClient client,    CloudFileShare share,    OperationContext context) throws Exception {
      final HttpURLConnection request=FileRequest.createShare(share.getTransformedAddress().getUri(this.getCurrentLocation()),options,context,share.getProperties());
      return request;
    }
    @Override public void setHeaders(    HttpURLConnection connection,    CloudFileShare share,    OperationContext context){
      FileRequest.addMetadata(connection,share.metadata,context);
    }
    @Override public void signRequest(    HttpURLConnection connection,    CloudFileClient client,    OperationContext context) throws Exception {
      StorageRequest.signBlobQueueAndFileRequest(connection,client,0L,context);
    }
    @Override public Void preProcessResponse(    CloudFileShare share,    CloudFileClient client,    OperationContext context) throws Exception {
      if (this.getResult().getStatusCode() != HttpURLConnection.HTTP_CREATED) {
        this.setNonExceptionedRetryableFailure(true);
        return null;
      }
      final FileShareAttributes attributes=FileResponse.getFileShareAttributes(this.getConnection(),client.isUsePathStyleUris());
      Integer oldShareQuota=share.properties.getShareQuota();
      share.properties=attributes.getProperties();
      share.properties.setShareQuota(oldShareQuota);
      return null;
    }
  }
;
  return putRequest;
}",0.9530685920577616
80537,"private StorageRequest<CloudFileClient,CloudFileShare,Void> downloadAttributesImpl(final AccessCondition accessCondition,final FileRequestOptions options){
  final StorageRequest<CloudFileClient,CloudFileShare,Void> getRequest=new StorageRequest<CloudFileClient,CloudFileShare,Void>(options,this.getStorageUri()){
    @Override public void setRequestLocationMode(){
      this.setRequestLocationMode(RequestLocationMode.PRIMARY_OR_SECONDARY);
    }
    @Override public HttpURLConnection buildRequest(    CloudFileClient client,    CloudFileShare share,    OperationContext context) throws Exception {
      return FileRequest.getShareProperties(share.getTransformedAddress().getUri(this.getCurrentLocation()),options,context,accessCondition);
    }
    @Override public void signRequest(    HttpURLConnection connection,    CloudFileClient client,    OperationContext context) throws Exception {
      StorageRequest.signBlobQueueAndFileRequest(connection,client,-1L,context);
    }
    @Override public Void preProcessResponse(    CloudFileShare share,    CloudFileClient client,    OperationContext context) throws Exception {
      if (this.getResult().getStatusCode() != HttpURLConnection.HTTP_OK) {
        this.setNonExceptionedRetryableFailure(true);
        return null;
      }
      final FileShareAttributes attributes=FileResponse.getFileShareAttributes(this.getConnection(),client.isUsePathStyleUris());
      share.metadata=attributes.getMetadata();
      share.properties=attributes.getProperties();
      share.name=attributes.getName();
      return null;
    }
  }
;
  return getRequest;
}","private StorageRequest<CloudFileClient,CloudFileShare,Void> downloadAttributesImpl(final AccessCondition accessCondition,final FileRequestOptions options){
  final StorageRequest<CloudFileClient,CloudFileShare,Void> getRequest=new StorageRequest<CloudFileClient,CloudFileShare,Void>(options,this.getStorageUri()){
    @Override public void setRequestLocationMode(){
      this.setRequestLocationMode(RequestLocationMode.PRIMARY_OR_SECONDARY);
    }
    @Override public HttpURLConnection buildRequest(    CloudFileClient client,    CloudFileShare share,    OperationContext context) throws Exception {
      return FileRequest.getShareProperties(share.getTransformedAddress().getUri(this.getCurrentLocation()),options,context,accessCondition);
    }
    @Override public void signRequest(    HttpURLConnection connection,    CloudFileClient client,    OperationContext context) throws Exception {
      StorageRequest.signBlobQueueAndFileRequest(connection,client,-1L,context);
    }
    @Override public Void preProcessResponse(    CloudFileShare share,    CloudFileClient client,    OperationContext context) throws Exception {
      if (this.getResult().getStatusCode() != HttpURLConnection.HTTP_OK) {
        this.setNonExceptionedRetryableFailure(true);
        return null;
      }
      final FileShareAttributes attributes=FileResponse.getFileShareAttributes(this.getConnection(),client.isUsePathStyleUris());
      share.metadata=attributes.getMetadata();
      share.properties=attributes.getProperties();
      return null;
    }
  }
;
  return getRequest;
}",0.9650613786591123
80538,"/** 
 * Gets the FileShareAttributes from the given request.
 * @param request the request to get attributes from
 * @param usePathStyleUris a value indicating if the account is using pathSytleUris
 * @return the FileShareAttributes from the given request.
 * @throws StorageException
 */
public static FileShareAttributes getFileShareAttributes(final HttpURLConnection request,final boolean usePathStyleUris) throws StorageException {
  final FileShareAttributes shareAttributes=new FileShareAttributes();
  URI tempURI;
  try {
    tempURI=PathUtility.stripSingleURIQueryAndFragment(request.getURL().toURI());
  }
 catch (  final URISyntaxException e) {
    final StorageException wrappedUnexpectedException=Utility.generateNewUnexpectedStorageException(e);
    throw wrappedUnexpectedException;
  }
  shareAttributes.setName(PathUtility.getShareNameFromUri(tempURI,usePathStyleUris));
  final FileShareProperties shareProperties=shareAttributes.getProperties();
  shareProperties.setEtag(BaseResponse.getEtag(request));
  shareProperties.setShareQuota(parseShareQuota(request));
  shareProperties.setLastModified(new Date(request.getLastModified()));
  shareAttributes.setMetadata(getMetadata(request));
  return shareAttributes;
}","/** 
 * Gets the FileShareAttributes from the given request.
 * @param request the request to get attributes from
 * @param usePathStyleUris a value indicating if the account is using pathSytleUris
 * @return the FileShareAttributes from the given request.
 * @throws StorageException
 */
public static FileShareAttributes getFileShareAttributes(final HttpURLConnection request,final boolean usePathStyleUris) throws StorageException {
  final FileShareAttributes shareAttributes=new FileShareAttributes();
  final FileShareProperties shareProperties=shareAttributes.getProperties();
  shareProperties.setEtag(BaseResponse.getEtag(request));
  shareProperties.setShareQuota(parseShareQuota(request));
  shareProperties.setLastModified(new Date(request.getLastModified()));
  shareAttributes.setMetadata(getMetadata(request));
  return shareAttributes;
}",0.5184475323430762
80539,"@Override public CartItemInfo addItem(ProductInfo productInfo){
synchronized (LOCK) {
    CartItemInfo cartItemInfo=createCartItemInfo(productInfo);
    CartItem map=mapToCartItem(cartItemInfo);
    if (StringUtils.isEmpty(cartId)) {
      cartId=StringUtils.strip(cartRepository.create(map),""String_Node_Str"");
    }
 else {
      cartRepository.add(cartId,map);
    }
    return cartItemInfo;
  }
}","@Override public CartItemInfo addItem(ProductInfo productInfo){
synchronized (lock) {
    CartItemInfo cartItemInfo=createCartItemInfo(productInfo);
    CartItem map=mapToCartItem(cartItemInfo);
    if (StringUtils.isEmpty(cartId)) {
      cartId=StringUtils.strip(cartRepository.create(map),""String_Node_Str"");
    }
 else {
      cartRepository.add(cartId,map);
    }
    return cartItemInfo;
  }
}",0.99
80540,"@Override public void removeItem(CartItemInfo item){
synchronized (LOCK) {
    cartRepository.removeFromCart(cartId,item.getUuid());
  }
}","@Override public void removeItem(CartItemInfo item){
synchronized (lock) {
    cartRepository.removeFromCart(cartId,item.getUuid());
  }
}",0.9710144927536232
80541,"@Override public List<CartItemInfo> getAll(){
synchronized (LOCK) {
    return getItems();
  }
}","@Override public List<CartItemInfo> getAll(){
synchronized (lock) {
    return getItems();
  }
}",0.9583333333333334
80542,"@Override public boolean isEmpty(){
synchronized (LOCK) {
    return getItems().isEmpty();
  }
}","@Override public boolean isEmpty(){
synchronized (lock) {
    return getItems().isEmpty();
  }
}",0.9583333333333334
80543,"@Override public void clearAll(){
synchronized (LOCK) {
    cartRepository.clear(cartId);
    logger.info(""String_Node_Str"");
  }
}","@Override public void clearAll(){
synchronized (lock) {
    cartRepository.clear(cartId);
    logger.info(""String_Node_Str"");
  }
}",0.9694656488549618
80544,"@Override public void clear(){
synchronized (lock) {
    cartRepository.clear(cartId);
    logger.info(""String_Node_Str"");
  }
}","@Override public void clear(){
synchronized (lock) {
    if (StringUtils.isNotEmpty(cartId)) {
      cartRepository.clear(cartId);
      logger.info(""String_Node_Str"");
    }
  }
}",0.8311688311688312
80545,"@Override public void clearAll(){
synchronized (LOCK) {
    getItems().clear();
    logger.info(""String_Node_Str"");
  }
}","@Override public void clearAll(){
synchronized (LOCK) {
    cartRepository.clear(cartId);
    logger.info(""String_Node_Str"");
  }
}",0.8968253968253969
80546,"private Component cartView(){
  ListView<CartItemInfo> cartView=new ListView<CartItemInfo>(""String_Node_Str"",cartListModel()){
    @Override protected void populateItem(    ListItem<CartItemInfo> item){
      WebMarkupContainer cartItem=new WebMarkupContainer(""String_Node_Str"");
      cartItem.add(new Label(""String_Node_Str"",new PropertyModel<String>(item.getModel(),""String_Node_Str"")));
      cartItem.add(new IndicatingAjaxLink<Void>(""String_Node_Str""){
        @Override public void onClick(        AjaxRequestTarget target){
          send(CartPanel.this,Broadcast.BREADTH,new RemoveFromCartEvent(item.getModel().getObject(),target));
        }
      }
);
      cartItem.add(new Label(""String_Node_Str"",new PriceModel(new PropertyModel<>(item.getModel(),""String_Node_Str""))));
      item.add(cartItem);
    }
  }
;
  cartView.setOutputMarkupId(true);
  return cartView;
}","private Component cartView(){
  cartView=new ListView<CartItemInfo>(""String_Node_Str"",cartListModel()){
    @Override protected void populateItem(    ListItem<CartItemInfo> item){
      WebMarkupContainer cartItem=new WebMarkupContainer(""String_Node_Str"");
      cartItem.add(new Label(""String_Node_Str"",new PropertyModel<String>(item.getModel(),""String_Node_Str"")));
      cartItem.add(new IndicatingAjaxLink<Void>(""String_Node_Str""){
        @Override public void onClick(        AjaxRequestTarget target){
          IModel<CartItemInfo> model=item.getModel();
          send(CartPanel.this,Broadcast.BREADTH,new RemoveFromCartEvent(model.getObject(),target));
        }
      }
);
      cartItem.add(new Label(""String_Node_Str"",new PriceModel(new PropertyModel<>(item.getModel(),""String_Node_Str""))));
      item.add(cartItem);
    }
  }
;
  cartView.setReuseItems(false);
  cartView.setOutputMarkupId(true);
  return cartView;
}",0.9281767955801103
80547,"@Override public void onClick(AjaxRequestTarget target){
  send(CartPanel.this,Broadcast.BREADTH,new RemoveFromCartEvent(item.getModel().getObject(),target));
}","@Override public void onClick(AjaxRequestTarget target){
  IModel<CartItemInfo> model=item.getModel();
  send(CartPanel.this,Broadcast.BREADTH,new RemoveFromCartEvent(model.getObject(),target));
}",0.8426966292134831
80548,"@Override protected void populateItem(ListItem<CartItemInfo> item){
  WebMarkupContainer cartItem=new WebMarkupContainer(""String_Node_Str"");
  cartItem.add(new Label(""String_Node_Str"",new PropertyModel<String>(item.getModel(),""String_Node_Str"")));
  cartItem.add(new IndicatingAjaxLink<Void>(""String_Node_Str""){
    @Override public void onClick(    AjaxRequestTarget target){
      send(CartPanel.this,Broadcast.BREADTH,new RemoveFromCartEvent(item.getModel().getObject(),target));
    }
  }
);
  cartItem.add(new Label(""String_Node_Str"",new PriceModel(new PropertyModel<>(item.getModel(),""String_Node_Str""))));
  item.add(cartItem);
}","@Override protected void populateItem(ListItem<CartItemInfo> item){
  WebMarkupContainer cartItem=new WebMarkupContainer(""String_Node_Str"");
  cartItem.add(new Label(""String_Node_Str"",new PropertyModel<String>(item.getModel(),""String_Node_Str"")));
  cartItem.add(new IndicatingAjaxLink<Void>(""String_Node_Str""){
    @Override public void onClick(    AjaxRequestTarget target){
      IModel<CartItemInfo> model=item.getModel();
      send(CartPanel.this,Broadcast.BREADTH,new RemoveFromCartEvent(model.getObject(),target));
    }
  }
);
  cartItem.add(new Label(""String_Node_Str"",new PriceModel(new PropertyModel<>(item.getModel(),""String_Node_Str""))));
  item.add(cartItem);
}",0.9466463414634146
80549,"@Override public void onEvent(IEvent<?> event){
  if (event.getPayload() instanceof CartChangeEvent) {
    ((CartChangeEvent)event.getPayload()).getTarget().add(this);
  }
}","@Override public void onEvent(IEvent<?> event){
  if (event.getPayload() instanceof CartChangeEvent) {
    cartView.getModel().detach();
    ((CartChangeEvent)event.getPayload()).getTarget().add(this);
  }
}",0.9105263157894736
80550,"public void setType(ProductType type){
  this.type=type;
}","public void setType(String type){
  this.type=type;
}",0.8648648648648649
80551,"public ProductType getType(){
  return type;
}","public String getType(){
  return type;
}",0.8275862068965517
80552,"public static void agentmain(String agentArguments,Instrumentation instrumentation){
  scheduler.scheduleAtFixedRate(new MemoryLoggingTask(),0,1,TimeUnit.SECONDS);
}","public static void agentmain(String agentArguments,Instrumentation instrumentation){
  SCHEDULER.scheduleAtFixedRate(new MemoryLoggingTask(),0,1,TimeUnit.SECONDS);
}",0.9454545454545454
80553,"@Override public void onReceive(Context context,Intent intent){
  Tools.HangarLog(""String_Node_Str"" + this.getClass().getCanonicalName() + ""String_Node_Str"");
  if (mContext == null)   mContext=context;
  AppWidgetManager mgr=AppWidgetManager.getInstance(context);
  int[] ids=mgr.getAppWidgetIds(new ComponentName(context,AppsWidget.class));
  for (  int id : ids) {
    Tools.HangarLog(""String_Node_Str"" + id);
    try {
      Bundle options=mgr.getAppWidgetOptions(id);
      updateAppWidget(context,mgr,id,options);
    }
 catch (    NullPointerException e) {
      e.printStackTrace();
      Tools.HangarLog(""String_Node_Str"");
    }
  }
  super.onReceive(context,intent);
}","@Override public void onReceive(Context context,Intent intent){
  Tools.HangarLog(""String_Node_Str"" + this.getClass().getCanonicalName() + ""String_Node_Str"");
  AppWidgetManager mgr=AppWidgetManager.getInstance(context);
  int[] ids=mgr.getAppWidgetIds(new ComponentName(context,AppsWidget.class));
  for (  int id : ids) {
    Tools.HangarLog(""String_Node_Str"" + id);
    try {
      Bundle options=mgr.getAppWidgetOptions(id);
      updateAppWidget(context,mgr,id,options);
    }
 catch (    Exception e) {
      e.printStackTrace();
      Tools.HangarLog(""String_Node_Str"");
    }
  }
  super.onReceive(context,intent);
}",0.957789716039908
80554,"@Override public void onUpdate(Context context,AppWidgetManager appWidgetManager,int[] appWidgetIds){
  Tools.HangarLog(""String_Node_Str"" + this.getClass().getCanonicalName() + ""String_Node_Str"");
  mContext=context;
  Intent intent=new Intent(context,WatchfulService.class);
  context.startService(intent);
}","@Override public void onUpdate(Context context,AppWidgetManager appWidgetManager,int[] appWidgetIds){
  Tools.HangarLog(""String_Node_Str"" + this.getClass().getCanonicalName() + ""String_Node_Str"");
  Intent intent=new Intent(context,WatchfulService.class);
  context.startService(intent);
}",0.9665551839464884
80555,"static void updateAppWidget(Context context,AppWidgetManager appWidgetManager,int appWidgetId,Bundle options){
  Tools.HangarLog(""String_Node_Str"");
  prefs=new PrefsGet(context.getSharedPreferences(""String_Node_Str"",Context.MODE_PRIVATE));
  SharedPreferences mPrefs=prefs.prefsGet();
  int rowLayout=R.layout.apps_widget_row;
  int itemLayout=R.layout.apps_widget_item;
  int itemHeight=ICON_MEDIUM_HEIGHT;
  int itemWidth=ICON_MEDIUM_WIDTH;
  final int TOP_ROW=1;
  final int BOT_ROW=2;
  int iconSize=Integer.parseInt(mPrefs.getString(Settings.ICON_SIZE_PREFERENCE,Integer.toString(Settings.ICON_SIZE_DEFAULT)));
  int mGravity=Integer.parseInt(mPrefs.getString(Settings.ALIGNMENT_PREFERENCE,Integer.toString(Settings.ALIGNMENT_DEFAULT)));
switch (iconSize) {
case SMALL_ICONS:
    rowLayout=R.layout.apps_widget_row_small;
  itemHeight=ICON_SMALL_HEIGHT;
itemWidth=ICON_SMALL_WIDTH;
break;
case LARGE_ICONS:
rowLayout=R.layout.apps_widget_row_large;
itemHeight=ICON_LARGE_HEIGHT;
itemWidth=ICON_LARGE_WIDTH;
break;
}
boolean appsNoByWidgetSize=mPrefs.getBoolean(Settings.APPS_BY_WIDGET_SIZE_PREFERENCE,Settings.APPS_BY_WIDGET_SIZE_DEFAULT);
int appsNoH;
int appsNoW;
boolean autoHeight=true;
Tools.HangarLog(""String_Node_Str"" + options.getInt(AppWidgetManager.OPTION_APPWIDGET_MIN_HEIGHT));
Tools.HangarLog(""String_Node_Str"" + options.getInt(AppWidgetManager.OPTION_APPWIDGET_MAX_HEIGHT));
Tools.HangarLog(""String_Node_Str"" + options.getInt(AppWidgetManager.OPTION_APPWIDGET_MIN_WIDTH));
Tools.HangarLog(""String_Node_Str"" + options.getInt(AppWidgetManager.OPTION_APPWIDGET_MAX_WIDTH));
appsNoH=findDimensions(options.getInt(AppWidgetManager.OPTION_APPWIDGET_MAX_HEIGHT),itemHeight);
appsNoW=findDimensions(options.getInt(AppWidgetManager.OPTION_APPWIDGET_MIN_WIDTH),itemWidth);
Tools.HangarLog(""String_Node_Str"" + appsNoH + ""String_Node_Str""+ appsNoW);
if (appsNoH == 0) {
appsNoH=1;
autoHeight=false;
}
if (context.getResources().getConfiguration().orientation == Configuration.ORIENTATION_LANDSCAPE) {
float widgetHeight=options.getInt(AppWidgetManager.OPTION_APPWIDGET_MIN_HEIGHT);
appsNoH=findDimensions((int)widgetHeight,itemHeight);
int origWidgetHeight=appsNoH;
if (iconSize > SMALL_ICONS) {
if (iconSize == LARGE_ICONS) {
appsNoH=findDimensions(options.getInt(AppWidgetManager.OPTION_APPWIDGET_MIN_HEIGHT),itemHeight);
if (appsNoH == 0 && widgetHeight > 0) {
Tools.HangarLog(""String_Node_Str"");
rowLayout=R.layout.apps_widget_row;
itemWidth=ICON_MEDIUM_WIDTH;
}
}
if (itemWidth == ICON_MEDIUM_WIDTH) {
appsNoH=findDimensions(options.getInt(AppWidgetManager.OPTION_APPWIDGET_MIN_HEIGHT),ICON_MEDIUM_HEIGHT);
if (appsNoH == 0 && widgetHeight > 0) {
Tools.HangarLog(""String_Node_Str"");
rowLayout=R.layout.apps_widget_row_small;
itemWidth=ICON_SMALL_WIDTH;
mGravity=Settings.ALIGNMENT_DEFAULT;
}
}
}
if (origWidgetHeight == 0) {
appsNoH=1;
autoHeight=false;
}
appsNoW=findDimensions(options.getInt(AppWidgetManager.OPTION_APPWIDGET_MAX_WIDTH),itemWidth);
if (appsNoByWidgetSize && appsNoW > 0) {
Tools.HangarLog(""String_Node_Str"" + appsNoW);
}
 else {
appsNoW=Integer.parseInt(mPrefs.getString(Settings.STATS_WIDGET_APPSNO_LS_PREFERENCE,Integer.toString(Settings.APPS_WIDGET_APPSNO_LS_DEFAULT)));
}
Tools.HangarLog(""String_Node_Str"");
}
 else {
if (appsNoByWidgetSize && appsNoW > 0) {
Tools.HangarLog(""String_Node_Str"" + appsNoH);
}
 else {
appsNoW=Integer.parseInt(mPrefs.getString(Settings.STATS_WIDGET_APPSNO_PREFERENCE,Integer.toString(Settings.APPS_WIDGET_APPSNO_DEFAULT)));
}
}
int getBackgroundColor=mPrefs.getInt(Settings.BACKGROUND_COLOR_PREFERENCE,Settings.BACKGROUND_COLOR_DEFAULT);
RemoteViews views=new RemoteViews(context.getPackageName(),R.layout.apps_widget);
views.setInt(R.id.viewCont,""String_Node_Str"",mGravity);
TasksDataSource db=TasksDataSource.getInstance(context);
db.open();
int gridSize=(appsNoH * appsNoW);
int numOfIcons=(appsNoH * appsNoW > Settings.TASKLIST_QUEUE_SIZE) ? Settings.TASKLIST_QUEUE_SIZE : (appsNoH * appsNoW);
if (autoHeight && !appsNoByWidgetSize) {
numOfIcons=appsNoW;
}
int queueSize=(Math.ceil(numOfIcons * 1.2f)) < Settings.APPLIST_QUEUE_SIZE ? Settings.APPLIST_QUEUE_SIZE : (int)Math.ceil(numOfIcons * 1.2f);
String taskPackage=context.getPackageName();
boolean weightedRecents=mPrefs.getBoolean(Settings.WEIGHTED_RECENTS_PREFERENCE,Settings.WEIGHTED_RECENTS_DEFAULT);
ArrayList<Tools.TaskInfo> appList=Tools.buildTaskList(context,db,queueSize,weightedRecents,true);
boolean ignorePinned=mPrefs.getBoolean(Settings.IGNORE_PINNED_PREFERENCE,Settings.IGNORE_PINNED_DEFAULT);
if (!ignorePinned) {
ArrayList<Tools.TaskInfo> pinnedList=Tools.buildPinnedList(mContext,db);
appList=new Tools().getPinnedTasks(context,pinnedList,appList,numOfIcons,false);
}
db.close();
int imageButtonLayout=context.getResources().getIdentifier(""String_Node_Str"",""String_Node_Str"",taskPackage);
int imageContLayout=context.getResources().getIdentifier(""String_Node_Str"",""String_Node_Str"",taskPackage);
AppDrawer appDrawer=new AppDrawer(taskPackage);
appDrawer.createRow(rowLayout,R.id.viewRow);
appDrawer.setImageLayouts(imageButtonLayout,imageContLayout);
appDrawer.setPrefs(mPrefs);
appDrawer.setContext(mContext);
appDrawer.setRowBackgroundColor(getBackgroundColor,TOP_ROW);
appDrawer.setCount(numOfIcons,Settings.TASKLIST_QUEUE_SIZE,true);
if (autoHeight && !appsNoByWidgetSize) {
appsNoW=(int)Math.ceil((double)appsNoW / appsNoH);
Tools.HangarLog(""String_Node_Str"" + appsNoW);
}
int filledConts=0;
int filledRows=1;
Tools.HangarLog(""String_Node_Str"" + appsNoW + ""String_Node_Str""+ appList.size()+ ""String_Node_Str""+ numOfIcons);
views.removeAllViews(R.id.viewCont);
for (int i=0; i <= gridSize; i++) {
if (filledConts == appsNoW || i == gridSize) {
Tools.HangarLog(""String_Node_Str"" + i + ""String_Node_Str""+ filledConts);
views.addView(R.id.viewCont,appDrawer.getRow());
if (i >= numOfIcons && !appsNoByWidgetSize) break;
boolean lineBreak=(appsNoByWidgetSize && appList.size() > i) || (!appsNoByWidgetSize && numOfIcons > i);
if (filledRows < appsNoH && filledConts < numOfIcons && lineBreak) {
appDrawer.createRow(rowLayout,R.id.viewRow);
appDrawer.setRowBackgroundColor(getBackgroundColor);
filledConts=0;
filledRows++;
}
 else {
break;
}
}
Tools.TaskInfo newItemTask;
if (i >= appList.size()) {
newItemTask=new Tools.TaskInfo(null);
}
 else {
newItemTask=appList.get(i);
}
boolean newItem=appDrawer.newItem(newItemTask,itemLayout);
if (!newItem) {
numOfIcons++;
continue;
}
filledConts+=1;
if (i >= numOfIcons || i >= appList.size()) {
appDrawer.setItemVisibility(View.INVISIBLE);
appDrawer.addItem();
continue;
}
appDrawer.addItem();
}
appDrawer.setRowBackgroundColor(getBackgroundColor,BOT_ROW);
appWidgetManager.updateAppWidget(appWidgetId,views);
}","void updateAppWidget(Context context,AppWidgetManager appWidgetManager,int appWidgetId,Bundle options){
  Tools.HangarLog(""String_Node_Str"");
  PrefsGet prefs=new PrefsGet(context.getSharedPreferences(""String_Node_Str"",Context.MODE_PRIVATE));
  SharedPreferences mPrefs=prefs.prefsGet();
  int rowLayout=R.layout.apps_widget_row;
  int itemLayout=R.layout.apps_widget_item;
  int itemHeight=ICON_MEDIUM_HEIGHT;
  int itemWidth=ICON_MEDIUM_WIDTH;
  final int TOP_ROW=1;
  final int BOT_ROW=2;
  int iconSize=Integer.parseInt(mPrefs.getString(Settings.ICON_SIZE_PREFERENCE,Integer.toString(Settings.ICON_SIZE_DEFAULT)));
  int mGravity=Integer.parseInt(mPrefs.getString(Settings.ALIGNMENT_PREFERENCE,Integer.toString(Settings.ALIGNMENT_DEFAULT)));
switch (iconSize) {
case SMALL_ICONS:
    rowLayout=R.layout.apps_widget_row_small;
  itemHeight=ICON_SMALL_HEIGHT;
itemWidth=ICON_SMALL_WIDTH;
break;
case LARGE_ICONS:
rowLayout=R.layout.apps_widget_row_large;
itemHeight=ICON_LARGE_HEIGHT;
itemWidth=ICON_LARGE_WIDTH;
break;
}
boolean appsNoByWidgetSize=mPrefs.getBoolean(Settings.APPS_BY_WIDGET_SIZE_PREFERENCE,Settings.APPS_BY_WIDGET_SIZE_DEFAULT);
int appsNoH;
int appsNoW;
boolean autoHeight=true;
Tools.HangarLog(""String_Node_Str"" + options.getInt(AppWidgetManager.OPTION_APPWIDGET_MIN_HEIGHT));
Tools.HangarLog(""String_Node_Str"" + options.getInt(AppWidgetManager.OPTION_APPWIDGET_MAX_HEIGHT));
Tools.HangarLog(""String_Node_Str"" + options.getInt(AppWidgetManager.OPTION_APPWIDGET_MIN_WIDTH));
Tools.HangarLog(""String_Node_Str"" + options.getInt(AppWidgetManager.OPTION_APPWIDGET_MAX_WIDTH));
appsNoH=findDimensions(options.getInt(AppWidgetManager.OPTION_APPWIDGET_MAX_HEIGHT),itemHeight);
appsNoW=findDimensions(options.getInt(AppWidgetManager.OPTION_APPWIDGET_MIN_WIDTH),itemWidth);
Tools.HangarLog(""String_Node_Str"" + appsNoH + ""String_Node_Str""+ appsNoW);
if (appsNoH == 0) {
appsNoH=1;
autoHeight=false;
}
if (context.getResources().getConfiguration().orientation == Configuration.ORIENTATION_LANDSCAPE) {
float widgetHeight=options.getInt(AppWidgetManager.OPTION_APPWIDGET_MIN_HEIGHT);
appsNoH=findDimensions((int)widgetHeight,itemHeight);
int origWidgetHeight=appsNoH;
if (iconSize > SMALL_ICONS) {
if (iconSize == LARGE_ICONS) {
appsNoH=findDimensions(options.getInt(AppWidgetManager.OPTION_APPWIDGET_MIN_HEIGHT),itemHeight);
if (appsNoH == 0 && widgetHeight > 0) {
Tools.HangarLog(""String_Node_Str"");
rowLayout=R.layout.apps_widget_row;
itemWidth=ICON_MEDIUM_WIDTH;
}
}
if (itemWidth == ICON_MEDIUM_WIDTH) {
appsNoH=findDimensions(options.getInt(AppWidgetManager.OPTION_APPWIDGET_MIN_HEIGHT),ICON_MEDIUM_HEIGHT);
if (appsNoH == 0 && widgetHeight > 0) {
Tools.HangarLog(""String_Node_Str"");
rowLayout=R.layout.apps_widget_row_small;
itemWidth=ICON_SMALL_WIDTH;
mGravity=Settings.ALIGNMENT_DEFAULT;
}
}
}
if (origWidgetHeight == 0) {
appsNoH=1;
autoHeight=false;
}
appsNoW=findDimensions(options.getInt(AppWidgetManager.OPTION_APPWIDGET_MAX_WIDTH),itemWidth);
if (appsNoByWidgetSize && appsNoW > 0) {
Tools.HangarLog(""String_Node_Str"" + appsNoW);
}
 else {
appsNoW=Integer.parseInt(mPrefs.getString(Settings.STATS_WIDGET_APPSNO_LS_PREFERENCE,Integer.toString(Settings.APPS_WIDGET_APPSNO_LS_DEFAULT)));
}
Tools.HangarLog(""String_Node_Str"");
}
 else {
if (appsNoByWidgetSize && appsNoW > 0) {
Tools.HangarLog(""String_Node_Str"" + appsNoH);
}
 else {
appsNoW=Integer.parseInt(mPrefs.getString(Settings.STATS_WIDGET_APPSNO_PREFERENCE,Integer.toString(Settings.APPS_WIDGET_APPSNO_DEFAULT)));
}
}
int getBackgroundColor=mPrefs.getInt(Settings.BACKGROUND_COLOR_PREFERENCE,Settings.BACKGROUND_COLOR_DEFAULT);
RemoteViews views=new RemoteViews(context.getPackageName(),R.layout.apps_widget);
views.setInt(R.id.viewCont,""String_Node_Str"",mGravity);
TasksDataSource db=TasksDataSource.getInstance(context);
db.open();
int gridSize=(appsNoH * appsNoW);
int numOfIcons=(appsNoH * appsNoW > Settings.TASKLIST_QUEUE_SIZE) ? Settings.TASKLIST_QUEUE_SIZE : (appsNoH * appsNoW);
if (autoHeight && !appsNoByWidgetSize) {
numOfIcons=appsNoW;
}
int queueSize=(Math.ceil(numOfIcons * 1.2f)) < Settings.APPLIST_QUEUE_SIZE ? Settings.APPLIST_QUEUE_SIZE : (int)Math.ceil(numOfIcons * 1.2f);
String taskPackage=context.getPackageName();
boolean weightedRecents=mPrefs.getBoolean(Settings.WEIGHTED_RECENTS_PREFERENCE,Settings.WEIGHTED_RECENTS_DEFAULT);
ArrayList<Tools.TaskInfo> appList=Tools.buildTaskList(context,db,queueSize,weightedRecents,true);
boolean ignorePinned=mPrefs.getBoolean(Settings.IGNORE_PINNED_PREFERENCE,Settings.IGNORE_PINNED_DEFAULT);
if (!ignorePinned) {
ArrayList<Tools.TaskInfo> pinnedList=Tools.buildPinnedList(context,db);
appList=new Tools().getPinnedTasks(context,pinnedList,appList,numOfIcons,false);
}
db.close();
int imageButtonLayout=context.getResources().getIdentifier(""String_Node_Str"",""String_Node_Str"",taskPackage);
int imageContLayout=context.getResources().getIdentifier(""String_Node_Str"",""String_Node_Str"",taskPackage);
AppDrawer appDrawer=new AppDrawer(taskPackage);
appDrawer.createRow(rowLayout,R.id.viewRow);
appDrawer.setImageLayouts(imageButtonLayout,imageContLayout);
appDrawer.setPrefs(mPrefs);
appDrawer.setContext(context);
appDrawer.setRowBackgroundColor(getBackgroundColor,TOP_ROW);
appDrawer.setCount(numOfIcons,Settings.TASKLIST_QUEUE_SIZE,true);
if (autoHeight && !appsNoByWidgetSize) {
appsNoW=(int)Math.ceil((double)appsNoW / appsNoH);
Tools.HangarLog(""String_Node_Str"" + appsNoW);
}
int filledConts=0;
int filledRows=1;
Tools.HangarLog(""String_Node_Str"" + appsNoW + ""String_Node_Str""+ appList.size()+ ""String_Node_Str""+ numOfIcons);
views.removeAllViews(R.id.viewCont);
for (int i=0; i <= gridSize; i++) {
if (filledConts == appsNoW || i == gridSize) {
Tools.HangarLog(""String_Node_Str"" + i + ""String_Node_Str""+ filledConts);
views.addView(R.id.viewCont,appDrawer.getRow());
if (i >= numOfIcons && !appsNoByWidgetSize) break;
boolean lineBreak=(appsNoByWidgetSize && appList.size() > i) || (!appsNoByWidgetSize && numOfIcons > i);
if (filledRows < appsNoH && filledConts < numOfIcons && lineBreak) {
appDrawer.createRow(rowLayout,R.id.viewRow);
appDrawer.setRowBackgroundColor(getBackgroundColor);
filledConts=0;
filledRows++;
}
 else {
break;
}
}
Tools.TaskInfo newItemTask;
if (i >= appList.size()) {
newItemTask=new Tools.TaskInfo(null);
}
 else {
newItemTask=appList.get(i);
}
boolean newItem=appDrawer.newItem(newItemTask,itemLayout);
if (!newItem) {
numOfIcons++;
continue;
}
filledConts+=1;
if (i >= numOfIcons || i >= appList.size()) {
appDrawer.setItemVisibility(View.INVISIBLE);
appDrawer.addItem();
continue;
}
appDrawer.addItem();
}
appDrawer.setRowBackgroundColor(getBackgroundColor,BOT_ROW);
appWidgetManager.updateAppWidget(appWidgetId,views);
}",0.998357473495595
80556,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  mInstance=this;
  setContentView(R.layout.activity_settings);
  prefs=new PrefsGet(getSharedPreferences(getPackageName(),Context.MODE_MULTI_PROCESS));
  mContext=this;
  if (showChangelog(prefs)) {
    launchChangelog();
  }
  display=getWindowManager().getDefaultDisplay();
  updateDisplayWidth();
  myService=new ServiceCall(mContext);
  myService.setConnection(mConnection);
  final ActionBar actionBar=getActionBar();
  actionBar.setTitle(R.string.title_activity_settings);
  actionBar.setNavigationMode(ActionBar.NAVIGATION_MODE_TABS);
  actionBar.setCustomView(R.layout.action_spinner);
  setUpSpinner((Spinner)actionBar.getCustomView().findViewById(R.id.config_spinner));
  actionBar.setDisplayShowCustomEnabled(true);
  mSectionsPagerAdapter=new SectionsPagerAdapter(getFragmentManager());
  mViewPager=(ViewPager)findViewById(R.id.pager);
  mViewPager.setAdapter(mSectionsPagerAdapter);
  mViewPager.setOffscreenPageLimit(4);
  mGetFragments=new GetFragments();
  mGetFragments.setFm(getFragmentManager());
  mGetFragments.setVp(mViewPager);
  ViewPager.OnPageChangeListener pageChangeListener=new ViewPager.SimpleOnPageChangeListener(){
    @Override public void onPageSelected(    int position){
      actionBar.setSelectedNavigationItem(position);
    }
  }
;
  mViewPager.setOnPageChangeListener(pageChangeListener);
  for (int i=0; i < mSectionsPagerAdapter.getCount(); i++) {
    actionBar.addTab(actionBar.newTab().setText(mSectionsPagerAdapter.getPageTitle(i)).setTabListener(this));
  }
  db=TasksDataSource.getInstance(this);
  db.open();
  int allTasksSize=db.getAllTasks().size();
  db.close();
  if (allTasksSize == 0) {
    newStart=true;
  }
  pageChangeListener.onPageSelected(GENERAL_TAB);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  mInstance=this;
  setContentView(R.layout.activity_settings);
  prefs=new PrefsGet(getSharedPreferences(getPackageName(),Context.MODE_MULTI_PROCESS));
  mContext=this;
  if (showChangelog(prefs)) {
    launchChangelog();
  }
  display=getWindowManager().getDefaultDisplay();
  updateDisplayWidth();
  myService=new ServiceCall(mContext);
  myService.setConnection(mConnection);
  final ActionBar actionBar=getActionBar();
  actionBar.setTitle(R.string.title_activity_settings);
  actionBar.setNavigationMode(ActionBar.NAVIGATION_MODE_TABS);
  actionBar.setCustomView(R.layout.action_spinner);
  setUpSpinner((Spinner)actionBar.getCustomView().findViewById(R.id.config_spinner));
  actionBar.setDisplayShowCustomEnabled(true);
  mSectionsPagerAdapter=new SectionsPagerAdapter(getFragmentManager());
  mViewPager=(ViewPager)findViewById(R.id.pager);
  mViewPager.setAdapter(mSectionsPagerAdapter);
  mViewPager.setOffscreenPageLimit(4);
  mGetFragments=new GetFragments();
  mGetFragments.setFm(getFragmentManager());
  mGetFragments.setVp(mViewPager);
  ViewPager.OnPageChangeListener pageChangeListener=new ViewPager.SimpleOnPageChangeListener(){
    @Override public void onPageSelected(    int position){
      actionBar.setSelectedNavigationItem(position);
    }
  }
;
  mViewPager.setOnPageChangeListener(pageChangeListener);
  for (int i=0; i < mSectionsPagerAdapter.getCount(); i++) {
    actionBar.addTab(actionBar.newTab().setText(mSectionsPagerAdapter.getPageTitle(i)).setTabListener(this));
  }
  pageChangeListener.onPageSelected(GENERAL_TAB);
}",0.9536957146965775
80557,"@Override public void onActivityCreated(Bundle savedInstanceState){
  super.onActivityCreated(savedInstanceState);
  Tools.HangarLog(""String_Node_Str"");
  List<AppsRowItem> appTasks=createAppTasks();
  mAppRowAdapter=new AppsRowAdapter(mContext,appTasks);
  lv.setAdapter(mAppRowAdapter);
  lv.setOnItemClickListener(this);
  mAppRowAdapter.notifyDataSetChanged();
}","@Override public void onActivityCreated(Bundle savedInstanceState){
  super.onActivityCreated(savedInstanceState);
  Tools.HangarLog(""String_Node_Str"");
  List<AppsRowItem> appTasks=createAppTasksLoop();
  if (appTasks == null)   return;
  mAppRowAdapter=new AppsRowAdapter(mContext,appTasks);
  lv.setAdapter(mAppRowAdapter);
  lv.setOnItemClickListener(this);
  mAppRowAdapter.notifyDataSetChanged();
}",0.9454545454545454
80558,"public static Bitmap drawableToBitmap(Drawable drawable){
  if (drawable instanceof BitmapDrawable) {
    return ((BitmapDrawable)drawable).getBitmap();
  }
  Bitmap bitmap=Bitmap.createBitmap(Tools.dpToPx(mContext,100),Tools.dpToPx(mContext,5),Bitmap.Config.ARGB_8888);
  Canvas canvas=new Canvas(bitmap);
  drawable.setBounds(0,0,canvas.getWidth(),canvas.getHeight());
  drawable.draw(canvas);
  return bitmap;
}","public Bitmap drawableToBitmap(Context context,Drawable drawable){
  if (drawable instanceof BitmapDrawable) {
    return ((BitmapDrawable)drawable).getBitmap();
  }
  Bitmap bitmap=Bitmap.createBitmap(Tools.dpToPx(context,100),Tools.dpToPx(context,5),Bitmap.Config.ARGB_8888);
  Canvas canvas=new Canvas(bitmap);
  drawable.setBounds(0,0,canvas.getWidth(),canvas.getHeight());
  drawable.draw(canvas);
  return bitmap;
}",0.9652694610778444
80559,"@Override public void onReceive(Context context,Intent intent){
  Tools.HangarLog(""String_Node_Str"" + this.getClass().getCanonicalName() + ""String_Node_Str"");
  if (mContext == null)   mContext=context;
  AppWidgetManager mgr=AppWidgetManager.getInstance(context);
  int[] ids=mgr.getAppWidgetIds(new ComponentName(context,StatsWidget.class));
  for (  int id : ids) {
    Tools.HangarLog(""String_Node_Str"" + id);
    try {
      Bundle options=mgr.getAppWidgetOptions(id);
      updateAppWidget(context,mgr,id,options);
    }
 catch (    NullPointerException e) {
      e.printStackTrace();
      Tools.HangarLog(""String_Node_Str"");
    }
  }
  super.onReceive(context,intent);
}","@Override public void onReceive(Context context,Intent intent){
  Tools.HangarLog(""String_Node_Str"" + this.getClass().getCanonicalName() + ""String_Node_Str"");
  AppWidgetManager mgr=AppWidgetManager.getInstance(context);
  int[] ids=mgr.getAppWidgetIds(new ComponentName(context,StatsWidget.class));
  for (  int id : ids) {
    Tools.HangarLog(""String_Node_Str"" + id);
    try {
      Bundle options=mgr.getAppWidgetOptions(id);
      updateAppWidget(context,mgr,id,options);
    }
 catch (    Exception e) {
      e.printStackTrace();
      Tools.HangarLog(""String_Node_Str"");
    }
  }
  super.onReceive(context,intent);
}",0.9578544061302682
80560,"@Override public void onUpdate(Context context,AppWidgetManager appWidgetManager,int[] appWidgetIds){
  Tools.HangarLog(""String_Node_Str"" + this.getClass().getCanonicalName() + ""String_Node_Str"");
  mContext=context;
  Intent intent=new Intent(context,WatchfulService.class);
  context.startService(intent);
}","@Override public void onUpdate(Context context,AppWidgetManager appWidgetManager,int[] appWidgetIds){
  Tools.HangarLog(""String_Node_Str"" + this.getClass().getCanonicalName() + ""String_Node_Str"");
  Intent intent=new Intent(context,WatchfulService.class);
  context.startService(intent);
}",0.9665551839464884
80561,"static void updateAppWidget(Context context,AppWidgetManager appWidgetManager,int appWidgetId,Bundle options){
  Tools.HangarLog(""String_Node_Str"");
  prefs=new PrefsGet(context.getSharedPreferences(""String_Node_Str"",Context.MODE_PRIVATE));
  SharedPreferences mPrefs=prefs.prefsGet();
  int statsLayout;
  int itemHeight;
  if (mPrefs.getBoolean(Settings.DIVIDER_PREFERENCE,Settings.DIVIDER_DEFAULT)) {
    statsLayout=R.layout.stats_widget;
    itemHeight=36;
  }
 else {
    statsLayout=R.layout.stats_widget_no_dividers;
    itemHeight=35;
  }
  boolean appsNoByWidgetSize=mPrefs.getBoolean(Settings.APPS_BY_WIDGET_SIZE_PREFERENCE,Settings.APPS_BY_WIDGET_SIZE_DEFAULT);
  boolean roundedCorners=mPrefs.getBoolean(Settings.ROUNDED_CORNERS_PREFERENCE,Settings.ROUNDED_CORNERS_DEFAULT);
  int appsNo;
  int appsNoLs;
  Tools.HangarLog(""String_Node_Str"" + options.getInt(AppWidgetManager.OPTION_APPWIDGET_MIN_HEIGHT));
  Tools.HangarLog(""String_Node_Str"" + options.getInt(AppWidgetManager.OPTION_APPWIDGET_MAX_HEIGHT));
  appsNo=(int)Math.floor((options.getInt(AppWidgetManager.OPTION_APPWIDGET_MAX_HEIGHT) - 14) / itemHeight);
  appsNoLs=(int)Math.floor((options.getInt(AppWidgetManager.OPTION_APPWIDGET_MIN_HEIGHT) - 14) / itemHeight);
  if (appsNoByWidgetSize && appsNo > 0) {
    Tools.HangarLog(""String_Node_Str"" + appsNo);
  }
 else {
    appsNo=Integer.parseInt(mPrefs.getString(Settings.STATS_WIDGET_APPSNO_PREFERENCE,Integer.toString(Settings.STATS_WIDGET_APPSNO_DEFAULT)));
  }
  if (context.getResources().getConfiguration().orientation == Configuration.ORIENTATION_LANDSCAPE) {
    if (appsNoByWidgetSize && appsNoLs > 0) {
      appsNo=appsNoLs;
      Tools.HangarLog(""String_Node_Str"" + appsNo);
    }
 else {
      appsNo=Integer.parseInt(mPrefs.getString(Settings.STATS_WIDGET_APPSNO_LS_PREFERENCE,Integer.toString(Settings.STATS_WIDGET_APPSNO_LS_DEFAULT)));
    }
    Tools.HangarLog(""String_Node_Str"");
  }
  int getColor=mPrefs.getInt(Settings.BACKGROUND_COLOR_PREFERENCE,Settings.BACKGROUND_COLOR_DEFAULT);
  RemoteViews views=new RemoteViews(context.getPackageName(),statsLayout);
  int mGravity=Integer.parseInt(mPrefs.getString(Settings.ALIGNMENT_PREFERENCE,Integer.toString(Settings.ALIGNMENT_DEFAULT)));
  views.setInt(R.id.taskRoot,""String_Node_Str"",mGravity);
  views.removeAllViews(R.id.taskRoot);
  PackageManager pkgm=context.getPackageManager();
  String packageName=context.getPackageName();
  Intent intent;
  TasksDataSource db=TasksDataSource.getInstance(context);
  db.open();
  int highestSeconds=db.getHighestSeconds();
  List<TasksModel> tasks=db.getAllTasks();
  db.close();
  Collections.sort(tasks,new Tools.TasksModelComparator(""String_Node_Str""));
  IconHelper ih=new IconHelper(context);
  int count=0;
  for (  TasksModel task : tasks) {
    RemoteViews row=new RemoteViews(context.getPackageName(),R.layout.stats_widget_row);
    int topPadding=0;
    int bottomPadding=0;
    if (count == 0) {
      topPadding=Tools.dpToPx(context,6);
      Tools.setViewBackgroundColor(row,getColor,(roundedCorners) ? R.drawable.rounded_bg_top : R.drawable.empty_bg);
    }
    if (count == (appsNo - 1)) {
      bottomPadding=Tools.dpToPx(context,6);
      Tools.setViewBackgroundColor(row,getColor,(roundedCorners) ? R.drawable.rounded_bg_bottom : R.drawable.empty_bg);
    }
    if (count > 0 && count < (appsNo - 1)) {
      Tools.setViewBackgroundColor(row,getColor,R.drawable.empty_bg);
    }
    row.setViewPadding(R.id.clickCont,0,topPadding,0,bottomPadding);
    int clickID=context.getResources().getIdentifier(""String_Node_Str"",""String_Node_Str"",packageName);
    int iconID=context.getResources().getIdentifier(""String_Node_Str"",""String_Node_Str"",packageName);
    int labelID=context.getResources().getIdentifier(""String_Node_Str"",""String_Node_Str"",packageName);
    int imgID=context.getResources().getIdentifier(""String_Node_Str"",""String_Node_Str"",packageName);
    int statsID=context.getResources().getIdentifier(""String_Node_Str"",""String_Node_Str"",packageName);
    if (task.getBlacklisted()) {
      continue;
    }
    if (count >= appsNo) {
      Tools.HangarLog(""String_Node_Str"" + count + ""String_Node_Str""+ appsNo);
      break;
    }
    Bitmap cachedIcon;
    ComponentName componentTask=ComponentName.unflattenFromString(task.getPackageName() + ""String_Node_Str"" + task.getClassName());
    cachedIcon=ih.cachedIconHelper(componentTask);
    if (cachedIcon == null)     continue;
    count++;
    row.setImageViewBitmap(iconID,cachedIcon);
    row.setTextViewText(labelID,task.getName());
    float secondsRatio=(float)task.getSeconds() / highestSeconds;
    int barColor;
    int secondsColor=(Math.round(secondsRatio * 100));
    if (secondsColor >= 80) {
      barColor=0xFF34B5E2;
    }
 else     if (secondsColor >= 60) {
      barColor=0xFFAA66CC;
    }
 else     if (secondsColor >= 40) {
      barColor=0xFF74C353;
    }
 else     if (secondsColor >= 20) {
      barColor=0xFFFFBB33;
    }
 else {
      barColor=0xFFFF4444;
    }
    int[] colors=new int[]{barColor,Tools.dpToPx(context,secondsColor - 1),0x00000000,Tools.dpToPx(mContext,100 - secondsColor)};
    Drawable sd=new BarDrawable(colors);
    Bitmap bmpIcon2=drawableToBitmap(sd);
    row.setImageViewBitmap(imgID,bmpIcon2);
    int[] statsTime=new Settings().splitToComponentTimes(task.getSeconds());
    String statsString=((statsTime[0] > 0) ? statsTime[0] + ""String_Node_Str"" : ""String_Node_Str"") + ((statsTime[1] > 0) ? statsTime[1] + ""String_Node_Str"" : ""String_Node_Str"") + ((statsTime[2] > 0) ? statsTime[2] + ""String_Node_Str"" : ""String_Node_Str"");
    row.setTextViewText(statsID,statsString);
    try {
      intent=pkgm.getLaunchIntentForPackage(task.getPackageName());
      if (intent == null) {
        count--;
        throw new PackageManager.NameNotFoundException();
      }
      intent.addCategory(Intent.CATEGORY_LAUNCHER);
      intent.setAction(Intent.ACTION_MAIN);
      PendingIntent activity=PendingIntent.getActivity(context,0,intent,PendingIntent.FLAG_CANCEL_CURRENT);
      row.setOnClickPendingIntent(clickID,activity);
    }
 catch (    PackageManager.NameNotFoundException e) {
    }
    views.addView(R.id.taskRoot,row);
  }
  appWidgetManager.updateAppWidget(appWidgetId,views);
}","void updateAppWidget(Context context,AppWidgetManager appWidgetManager,int appWidgetId,Bundle options){
  Tools.HangarLog(""String_Node_Str"");
  PrefsGet prefs=new PrefsGet(context.getSharedPreferences(""String_Node_Str"",Context.MODE_PRIVATE));
  SharedPreferences mPrefs=prefs.prefsGet();
  int statsLayout;
  int itemHeight;
  if (mPrefs.getBoolean(Settings.DIVIDER_PREFERENCE,Settings.DIVIDER_DEFAULT)) {
    statsLayout=R.layout.stats_widget;
    itemHeight=36;
  }
 else {
    statsLayout=R.layout.stats_widget_no_dividers;
    itemHeight=35;
  }
  boolean appsNoByWidgetSize=mPrefs.getBoolean(Settings.APPS_BY_WIDGET_SIZE_PREFERENCE,Settings.APPS_BY_WIDGET_SIZE_DEFAULT);
  boolean roundedCorners=mPrefs.getBoolean(Settings.ROUNDED_CORNERS_PREFERENCE,Settings.ROUNDED_CORNERS_DEFAULT);
  int appsNo;
  int appsNoLs;
  Tools.HangarLog(""String_Node_Str"" + options.getInt(AppWidgetManager.OPTION_APPWIDGET_MIN_HEIGHT));
  Tools.HangarLog(""String_Node_Str"" + options.getInt(AppWidgetManager.OPTION_APPWIDGET_MAX_HEIGHT));
  appsNo=(int)Math.floor((options.getInt(AppWidgetManager.OPTION_APPWIDGET_MAX_HEIGHT) - 14) / itemHeight);
  appsNoLs=(int)Math.floor((options.getInt(AppWidgetManager.OPTION_APPWIDGET_MIN_HEIGHT) - 14) / itemHeight);
  if (appsNoByWidgetSize && appsNo > 0) {
    Tools.HangarLog(""String_Node_Str"" + appsNo);
  }
 else {
    appsNo=Integer.parseInt(mPrefs.getString(Settings.STATS_WIDGET_APPSNO_PREFERENCE,Integer.toString(Settings.STATS_WIDGET_APPSNO_DEFAULT)));
  }
  if (context.getResources().getConfiguration().orientation == Configuration.ORIENTATION_LANDSCAPE) {
    if (appsNoByWidgetSize && appsNoLs > 0) {
      appsNo=appsNoLs;
      Tools.HangarLog(""String_Node_Str"" + appsNo);
    }
 else {
      appsNo=Integer.parseInt(mPrefs.getString(Settings.STATS_WIDGET_APPSNO_LS_PREFERENCE,Integer.toString(Settings.STATS_WIDGET_APPSNO_LS_DEFAULT)));
    }
    Tools.HangarLog(""String_Node_Str"");
  }
  int getColor=mPrefs.getInt(Settings.BACKGROUND_COLOR_PREFERENCE,Settings.BACKGROUND_COLOR_DEFAULT);
  RemoteViews views=new RemoteViews(context.getPackageName(),statsLayout);
  int mGravity=Integer.parseInt(mPrefs.getString(Settings.ALIGNMENT_PREFERENCE,Integer.toString(Settings.ALIGNMENT_DEFAULT)));
  views.setInt(R.id.taskRoot,""String_Node_Str"",mGravity);
  views.removeAllViews(R.id.taskRoot);
  PackageManager pkgm=context.getPackageManager();
  String packageName=context.getPackageName();
  Intent intent;
  TasksDataSource db=TasksDataSource.getInstance(context);
  db.open();
  int highestSeconds=db.getHighestSeconds();
  List<TasksModel> tasks=db.getAllTasks();
  db.close();
  Collections.sort(tasks,new Tools.TasksModelComparator(""String_Node_Str""));
  IconHelper ih=new IconHelper(context);
  int count=0;
  for (  TasksModel task : tasks) {
    RemoteViews row=new RemoteViews(context.getPackageName(),R.layout.stats_widget_row);
    int topPadding=0;
    int bottomPadding=0;
    if (count == 0) {
      topPadding=Tools.dpToPx(context,6);
      Tools.setViewBackgroundColor(row,getColor,(roundedCorners) ? R.drawable.rounded_bg_top : R.drawable.empty_bg);
    }
    if (count == (appsNo - 1)) {
      bottomPadding=Tools.dpToPx(context,6);
      Tools.setViewBackgroundColor(row,getColor,(roundedCorners) ? R.drawable.rounded_bg_bottom : R.drawable.empty_bg);
    }
    if (count > 0 && count < (appsNo - 1)) {
      Tools.setViewBackgroundColor(row,getColor,R.drawable.empty_bg);
    }
    row.setViewPadding(R.id.clickCont,0,topPadding,0,bottomPadding);
    int clickID=context.getResources().getIdentifier(""String_Node_Str"",""String_Node_Str"",packageName);
    int iconID=context.getResources().getIdentifier(""String_Node_Str"",""String_Node_Str"",packageName);
    int labelID=context.getResources().getIdentifier(""String_Node_Str"",""String_Node_Str"",packageName);
    int imgID=context.getResources().getIdentifier(""String_Node_Str"",""String_Node_Str"",packageName);
    int statsID=context.getResources().getIdentifier(""String_Node_Str"",""String_Node_Str"",packageName);
    if (task.getBlacklisted()) {
      continue;
    }
    if (count >= appsNo) {
      Tools.HangarLog(""String_Node_Str"" + count + ""String_Node_Str""+ appsNo);
      break;
    }
    Bitmap cachedIcon;
    ComponentName componentTask=ComponentName.unflattenFromString(task.getPackageName() + ""String_Node_Str"" + task.getClassName());
    cachedIcon=ih.cachedIconHelper(componentTask);
    if (cachedIcon == null)     continue;
    count++;
    row.setImageViewBitmap(iconID,cachedIcon);
    row.setTextViewText(labelID,task.getName());
    float secondsRatio=(float)task.getSeconds() / highestSeconds;
    int barColor;
    int secondsColor=(Math.round(secondsRatio * 100));
    if (secondsColor >= 80) {
      barColor=0xFF34B5E2;
    }
 else     if (secondsColor >= 60) {
      barColor=0xFFAA66CC;
    }
 else     if (secondsColor >= 40) {
      barColor=0xFF74C353;
    }
 else     if (secondsColor >= 20) {
      barColor=0xFFFFBB33;
    }
 else {
      barColor=0xFFFF4444;
    }
    int[] colors=new int[]{barColor,Tools.dpToPx(context,secondsColor - 1),0x00000000,Tools.dpToPx(context,100 - secondsColor)};
    Drawable sd=new BarDrawable(colors);
    Bitmap bmpIcon2=drawableToBitmap(context,sd);
    row.setImageViewBitmap(imgID,bmpIcon2);
    int[] statsTime=new Settings().splitToComponentTimes(task.getSeconds());
    String statsString=((statsTime[0] > 0) ? statsTime[0] + ""String_Node_Str"" : ""String_Node_Str"") + ((statsTime[1] > 0) ? statsTime[1] + ""String_Node_Str"" : ""String_Node_Str"") + ((statsTime[2] > 0) ? statsTime[2] + ""String_Node_Str"" : ""String_Node_Str"");
    row.setTextViewText(statsID,statsString);
    try {
      intent=pkgm.getLaunchIntentForPackage(task.getPackageName());
      if (intent == null) {
        count--;
        throw new PackageManager.NameNotFoundException();
      }
      intent.addCategory(Intent.CATEGORY_LAUNCHER);
      intent.setAction(Intent.ACTION_MAIN);
      PendingIntent activity=PendingIntent.getActivity(context,0,intent,PendingIntent.FLAG_CANCEL_CURRENT);
      row.setOnClickPendingIntent(clickID,activity);
    }
 catch (    PackageManager.NameNotFoundException e) {
    }
    views.addView(R.id.taskRoot,row);
  }
  appWidgetManager.updateAppWidget(appWidgetId,views);
}",0.9978398271861748
80562,"public synchronized void createNotification(){
  int filledConts=0;
  int maxButtons;
  boolean filledSecondRow=false;
  Context mContext=getApplicationContext();
  if (moreAppsPage == 1)   updatePrefs();
  RemoteViews customNotifView=new RemoteViews(taskPackage,contLayout);
  RemoteViews customNotifBigView=customNotifView;
  AppDrawer appDrawer=new AppDrawer(taskPackage);
  appDrawer.createRow(rowLayout,R.id.notifRow);
  appDrawer.setImageLayouts(imageButtonLayout,imageContLayout);
  appDrawer.setPrefs(prefs);
  appDrawer.setContext(mContext);
  if (taskList.size() < numOfApps) {
    maxButtons=taskList.size();
  }
 else {
    maxButtons=numOfApps;
  }
  if (taskList.size() <= numOfApps) {
    Tools.HangarLog(""String_Node_Str"");
    secondRow=false;
  }
  int iconCacheCount=(maxButtons * (secondRow ? 2 : 1));
  appDrawer.setCount(iconCacheCount,Settings.CACHED_NOTIFICATION_ICON_LIMIT,secondRow);
  ArrayList<TaskInfo> pageList;
  if (moreAppsPage == 1) {
    if (pinnedList == null) {
      Tools.HangarLog(""String_Node_Str"");
      pinnedList=Tools.buildPinnedList(mContext,db);
      pinnedCount=pinnedList.size();
    }
    pageList=new ArrayList<TaskInfo>(taskList);
    pageList=new Tools().getPinnedTasks(mContext,pinnedList,pageList,iconCacheCount,moreApps);
  }
 else {
    if (pinnedCount > iconCacheCount)     pinnedCount=iconCacheCount - 1;
    pageList=getPageTasks(moreAppsPage,iconCacheCount);
    if (pageList == null) {
      moreAppsPage=1;
      createNotification();
      return;
    }
    pageList=new Tools().getPinnedTasks(mContext,null,pageList,iconCacheCount,moreApps);
  }
  Tools.HangarLog(""String_Node_Str"" + taskList.size() + ""String_Node_Str""+ pageList.size()+ ""String_Node_Str""+ numOfApps+ ""String_Node_Str""+ maxButtons+ ""String_Node_Str""+ moreAppsPage);
  customNotifBigView.removeAllViews(R.id.notifContainer);
  notificationTasks=new ArrayList<String>();
  for (int i=0; i <= pageList.size(); i++) {
    boolean wrapItUp=false;
    if (i == pageList.size())     wrapItUp=true;
    if (filledConts == maxButtons || wrapItUp) {
      if (filledSecondRow) {
        filledSecondRow=false;
        customNotifBigView=customNotifView;
        customNotifBigView.addView(R.id.notifContainer,appDrawer.getRow());
        break;
      }
 else {
        customNotifView.addView(R.id.notifContainer,appDrawer.getRow());
        filledSecondRow=true;
        filledConts=0;
        appDrawer.createRow(rowLayout,R.id.notifRow);
        appDrawer.setImageLayouts(imageButtonLayout,imageContLayout);
      }
    }
    if (!wrapItUp) {
      if (appDrawer.newItem(pageList.get(i),itemLayout)) {
        appDrawer.addItem();
        notificationTasks.add(pageList.get(i).packageName);
        filledConts++;
      }
    }
  }
  if (filledSecondRow && secondRow) {
    Tools.HangarLog(""String_Node_Str"");
    customNotifBigView=customNotifView;
    customNotifBigView.addView(R.id.notifContainer,appDrawer.getRow());
  }
  int smallIcon=iconMap.get(Settings.STATUSBAR_ICON_WHITE_WARM);
  try {
    smallIcon=iconMap.get(mIcon);
  }
 catch (  NullPointerException e) {
    e.printStackTrace();
  }
  Notification notification=new Notification.Builder(WatchfulService.this).setContentTitle(getResources().getString(R.string.app_name)).setContentText(getResources().getString(R.string.app_name)).setSmallIcon(smallIcon).setContent(customNotifView).setOngoing(true).setPriority(setPriority).build();
  if (secondRow) {
    notification.bigContentView=customNotifBigView;
  }
  Tools.HangarLog(""String_Node_Str"" + isNotificationRunning);
  if (isNotificationRunning) {
    NotificationManager mNotificationManager=(NotificationManager)getSystemService(Context.NOTIFICATION_SERVICE);
    mNotificationManager.notify(1337,notification);
  }
 else {
    startForeground(1337,notification);
  }
  if (moreAppsPage > 1) {
    notificationTasks=null;
    pinnedList=null;
  }
  isNotificationRunning=true;
}","public synchronized void createNotification(){
  int filledConts=0;
  int maxButtons;
  boolean filledSecondRow=false;
  Context mContext=getApplicationContext();
  if (moreAppsPage == 1)   updatePrefs();
  RemoteViews customNotifView=new RemoteViews(taskPackage,contLayout);
  RemoteViews customNotifBigView=customNotifView;
  AppDrawer appDrawer=new AppDrawer(taskPackage);
  appDrawer.createRow(rowLayout,R.id.notifRow);
  appDrawer.setImageLayouts(imageButtonLayout,imageContLayout);
  appDrawer.setPrefs(prefs);
  appDrawer.setContext(mContext);
  if (taskList.size() < numOfApps) {
    maxButtons=taskList.size();
  }
 else {
    maxButtons=numOfApps;
  }
  if (taskList.size() <= numOfApps) {
    Tools.HangarLog(""String_Node_Str"");
    secondRow=false;
  }
  int iconCacheCount=(maxButtons * (secondRow ? 2 : 1));
  appDrawer.setCount(iconCacheCount,Settings.CACHED_NOTIFICATION_ICON_LIMIT,secondRow);
  ArrayList<TaskInfo> pageList;
  if (moreAppsPage == 1) {
    if (pinnedList == null) {
      Tools.HangarLog(""String_Node_Str"");
      pinnedList=Tools.buildPinnedList(mContext,db);
      pinnedCount=pinnedList.size();
    }
    pageList=new ArrayList<TaskInfo>(taskList);
    pageList=new Tools().getPinnedTasks(mContext,pinnedList,pageList,iconCacheCount,moreApps);
  }
 else {
    if (pinnedCount > iconCacheCount)     pinnedCount=iconCacheCount - 1;
    pageList=getPageTasks(moreAppsPage,iconCacheCount);
    if (pageList == null) {
      moreAppsPage=1;
      createNotification();
      return;
    }
    pageList=new Tools().getPinnedTasks(mContext,null,pageList,iconCacheCount,moreApps);
    if (pageList.size() == 1) {
      moreAppsPage=1;
      return;
    }
  }
  Tools.HangarLog(""String_Node_Str"" + taskList.size() + ""String_Node_Str""+ pageList.size()+ ""String_Node_Str""+ numOfApps+ ""String_Node_Str""+ maxButtons+ ""String_Node_Str""+ moreAppsPage);
  customNotifBigView.removeAllViews(R.id.notifContainer);
  notificationTasks=new ArrayList<String>();
  for (int i=0; i <= pageList.size(); i++) {
    boolean wrapItUp=false;
    if (i == pageList.size())     wrapItUp=true;
    if (filledConts == maxButtons || wrapItUp) {
      if (filledSecondRow) {
        filledSecondRow=false;
        customNotifBigView=customNotifView;
        customNotifBigView.addView(R.id.notifContainer,appDrawer.getRow());
        break;
      }
 else {
        customNotifView.addView(R.id.notifContainer,appDrawer.getRow());
        filledSecondRow=true;
        filledConts=0;
        appDrawer.createRow(rowLayout,R.id.notifRow);
        appDrawer.setImageLayouts(imageButtonLayout,imageContLayout);
      }
    }
    if (!wrapItUp) {
      if (appDrawer.newItem(pageList.get(i),itemLayout)) {
        appDrawer.addItem();
        notificationTasks.add(pageList.get(i).packageName);
        filledConts++;
      }
    }
  }
  if (filledSecondRow && secondRow) {
    Tools.HangarLog(""String_Node_Str"");
    customNotifBigView=customNotifView;
    customNotifBigView.addView(R.id.notifContainer,appDrawer.getRow());
  }
  int smallIcon=iconMap.get(Settings.STATUSBAR_ICON_WHITE_WARM);
  try {
    smallIcon=iconMap.get(mIcon);
  }
 catch (  NullPointerException e) {
    e.printStackTrace();
  }
  Notification notification=new Notification.Builder(WatchfulService.this).setContentTitle(getResources().getString(R.string.app_name)).setContentText(getResources().getString(R.string.app_name)).setSmallIcon(smallIcon).setContent(customNotifView).setOngoing(true).setPriority(setPriority).build();
  if (secondRow) {
    notification.bigContentView=customNotifBigView;
  }
  Tools.HangarLog(""String_Node_Str"" + isNotificationRunning);
  if (isNotificationRunning) {
    NotificationManager mNotificationManager=(NotificationManager)getSystemService(Context.NOTIFICATION_SERVICE);
    mNotificationManager.notify(1337,notification);
  }
 else {
    startForeground(1337,notification);
  }
  if (moreAppsPage > 1) {
    notificationTasks=null;
    pinnedList=null;
  }
  isNotificationRunning=true;
}",0.9906683480453972
80563,"static void updateAppWidget(Context context,AppWidgetManager appWidgetManager,int appWidgetId,Bundle options){
  Tools.HangarLog(""String_Node_Str"");
  prefs=new PrefsGet(context.getSharedPreferences(""String_Node_Str"",Context.MODE_PRIVATE));
  SharedPreferences mPrefs=prefs.prefsGet();
  int rowLayout=R.layout.apps_widget_row;
  int itemLayout=R.layout.apps_widget_item;
  int itemHeight=ICON_MEDIUM_HEIGHT;
  int itemWidth=ICON_MEDIUM_WIDTH;
  int iconSize=Integer.parseInt(mPrefs.getString(Settings.ICON_SIZE_PREFERENCE,Integer.toString(Settings.ICON_SIZE_DEFAULT)));
  int mGravity=Integer.parseInt(mPrefs.getString(Settings.ALIGNMENT_PREFERENCE,Integer.toString(Settings.ALIGNMENT_DEFAULT)));
switch (iconSize) {
case SMALL_ICONS:
    rowLayout=R.layout.apps_widget_row_small;
  itemHeight=ICON_SMALL_HEIGHT;
itemWidth=ICON_SMALL_WIDTH;
break;
case LARGE_ICONS:
rowLayout=R.layout.apps_widget_row_large;
itemHeight=ICON_LARGE_HEIGHT;
itemWidth=ICON_LARGE_WIDTH;
break;
}
boolean appsNoByWidgetSize=mPrefs.getBoolean(Settings.APPS_BY_WIDGET_SIZE_PREFERENCE,Settings.APPS_BY_WIDGET_SIZE_DEFAULT);
int appsNoH;
int appsNoW;
boolean autoHeight=true;
Tools.HangarLog(""String_Node_Str"" + options.getInt(AppWidgetManager.OPTION_APPWIDGET_MIN_HEIGHT));
Tools.HangarLog(""String_Node_Str"" + options.getInt(AppWidgetManager.OPTION_APPWIDGET_MAX_HEIGHT));
Tools.HangarLog(""String_Node_Str"" + options.getInt(AppWidgetManager.OPTION_APPWIDGET_MIN_WIDTH));
Tools.HangarLog(""String_Node_Str"" + options.getInt(AppWidgetManager.OPTION_APPWIDGET_MAX_WIDTH));
appsNoH=findDimensions(options.getInt(AppWidgetManager.OPTION_APPWIDGET_MAX_HEIGHT),itemHeight);
appsNoW=findDimensions(options.getInt(AppWidgetManager.OPTION_APPWIDGET_MIN_WIDTH),itemWidth);
Tools.HangarLog(""String_Node_Str"" + appsNoH + ""String_Node_Str""+ appsNoW);
if (appsNoH == 0) {
appsNoH=1;
autoHeight=false;
}
if (context.getResources().getConfiguration().orientation == Configuration.ORIENTATION_LANDSCAPE) {
float widgetHeight=options.getInt(AppWidgetManager.OPTION_APPWIDGET_MIN_HEIGHT);
appsNoH=findDimensions((int)widgetHeight,itemHeight);
int origWidgetHeight=appsNoH;
if (iconSize > SMALL_ICONS) {
if (iconSize == LARGE_ICONS) {
appsNoH=findDimensions(options.getInt(AppWidgetManager.OPTION_APPWIDGET_MIN_HEIGHT),itemHeight);
if (appsNoH == 0 && widgetHeight > 0) {
Tools.HangarLog(""String_Node_Str"");
rowLayout=R.layout.apps_widget_row;
itemWidth=ICON_MEDIUM_WIDTH;
}
}
if (itemWidth == ICON_MEDIUM_WIDTH) {
appsNoH=findDimensions(options.getInt(AppWidgetManager.OPTION_APPWIDGET_MIN_HEIGHT),ICON_MEDIUM_HEIGHT);
if (appsNoH == 0 && widgetHeight > 0) {
Tools.HangarLog(""String_Node_Str"");
rowLayout=R.layout.apps_widget_row_small;
itemWidth=ICON_SMALL_WIDTH;
mGravity=Settings.ALIGNMENT_DEFAULT;
}
}
}
if (origWidgetHeight == 0) {
appsNoH=1;
autoHeight=false;
}
appsNoW=findDimensions(options.getInt(AppWidgetManager.OPTION_APPWIDGET_MAX_WIDTH),itemWidth);
if (appsNoByWidgetSize && appsNoW > 0) {
Tools.HangarLog(""String_Node_Str"" + appsNoW);
}
 else {
appsNoW=Integer.parseInt(mPrefs.getString(Settings.STATS_WIDGET_APPSNO_LS_PREFERENCE,Integer.toString(Settings.APPS_WIDGET_APPSNO_LS_DEFAULT)));
}
Tools.HangarLog(""String_Node_Str"");
}
 else {
if (appsNoByWidgetSize && appsNoW > 0) {
Tools.HangarLog(""String_Node_Str"" + appsNoH);
}
 else {
appsNoW=Integer.parseInt(mPrefs.getString(Settings.STATS_WIDGET_APPSNO_PREFERENCE,Integer.toString(Settings.APPS_WIDGET_APPSNO_DEFAULT)));
}
}
int getBackgroundColor=mPrefs.getInt(Settings.BACKGROUND_COLOR_PREFERENCE,Settings.BACKGROUND_COLOR_DEFAULT);
RemoteViews views=new RemoteViews(context.getPackageName(),R.layout.apps_widget);
views.setInt(R.id.viewCont,""String_Node_Str"",mGravity);
if (db == null) {
db=new TasksDataSource(context);
db.open();
}
int gridSize=(appsNoH * appsNoW);
int numOfIcons=(appsNoH * appsNoW > Settings.TASKLIST_QUEUE_SIZE) ? Settings.TASKLIST_QUEUE_SIZE : (appsNoH * appsNoW);
if (autoHeight && !appsNoByWidgetSize) {
numOfIcons=appsNoW;
}
int queueSize=(Math.ceil(numOfIcons * 1.2f)) < Settings.APPLIST_QUEUE_SIZE ? Settings.APPLIST_QUEUE_SIZE : (int)Math.ceil(numOfIcons * 1.2f);
String taskPackage=context.getPackageName();
boolean weightedRecents=mPrefs.getBoolean(Settings.WEIGHTED_RECENTS_PREFERENCE,Settings.WEIGHTED_RECENTS_DEFAULT);
ArrayList<Tools.TaskInfo> appList=Tools.buildTaskList(context,db,queueSize,weightedRecents,true);
boolean ignorePinned=mPrefs.getBoolean(Settings.IGNORE_PINNED_PREFERENCE,Settings.IGNORE_PINNED_DEFAULT);
if (!ignorePinned) {
ArrayList<Tools.TaskInfo> pinnedList=Tools.buildPinnedList(mContext,db);
appList=new Tools().getPinnedTasks(context,pinnedList,appList,numOfIcons);
}
int imageButtonLayout=context.getResources().getIdentifier(""String_Node_Str"",""String_Node_Str"",taskPackage);
int imageContLayout=context.getResources().getIdentifier(""String_Node_Str"",""String_Node_Str"",taskPackage);
AppDrawer appDrawer=new AppDrawer(taskPackage);
appDrawer.createRow(rowLayout,R.id.viewRow);
appDrawer.setImageLayouts(imageButtonLayout,imageContLayout);
appDrawer.setPrefs(mPrefs);
appDrawer.setContext(mContext);
appDrawer.setRowBackgroundColor(getBackgroundColor);
appDrawer.setCount(numOfIcons,Settings.TASKLIST_QUEUE_SIZE,true);
if (autoHeight && !appsNoByWidgetSize) {
appsNoW=(int)Math.ceil((double)appsNoW / appsNoH);
Tools.HangarLog(""String_Node_Str"" + appsNoW);
}
int filledConts=0;
int filledRows=1;
Tools.HangarLog(""String_Node_Str"" + appsNoW + ""String_Node_Str""+ appList.size()+ ""String_Node_Str""+ numOfIcons);
views.removeAllViews(R.id.viewCont);
for (int i=0; i <= gridSize; i++) {
if (filledConts == appsNoW || i == gridSize) {
Tools.HangarLog(""String_Node_Str"" + i + ""String_Node_Str""+ filledConts);
views.addView(R.id.viewCont,appDrawer.getRow());
if (i >= numOfIcons && !appsNoByWidgetSize) break;
boolean lineBreak=(appsNoByWidgetSize && appList.size() > i) || (!appsNoByWidgetSize && numOfIcons > i);
if (filledRows < appsNoH && filledConts < numOfIcons && lineBreak) {
appDrawer.createRow(rowLayout,R.id.viewRow);
appDrawer.setRowBackgroundColor(getBackgroundColor);
filledConts=0;
filledRows++;
}
 else {
break;
}
}
Tools.TaskInfo newItemTask;
if (i >= appList.size()) {
newItemTask=new Tools.TaskInfo(null);
}
 else {
newItemTask=appList.get(i);
}
boolean newItem=appDrawer.newItem(newItemTask,itemLayout);
if (!newItem) {
numOfIcons++;
continue;
}
filledConts+=1;
if (i >= numOfIcons || i >= appList.size()) {
appDrawer.setItemVisibility(View.INVISIBLE);
appDrawer.addItem();
continue;
}
appDrawer.addItem();
}
appWidgetManager.updateAppWidget(appWidgetId,views);
}","static void updateAppWidget(Context context,AppWidgetManager appWidgetManager,int appWidgetId,Bundle options){
  Tools.HangarLog(""String_Node_Str"");
  prefs=new PrefsGet(context.getSharedPreferences(""String_Node_Str"",Context.MODE_PRIVATE));
  SharedPreferences mPrefs=prefs.prefsGet();
  int rowLayout=R.layout.apps_widget_row;
  int itemLayout=R.layout.apps_widget_item;
  int itemHeight=ICON_MEDIUM_HEIGHT;
  int itemWidth=ICON_MEDIUM_WIDTH;
  int iconSize=Integer.parseInt(mPrefs.getString(Settings.ICON_SIZE_PREFERENCE,Integer.toString(Settings.ICON_SIZE_DEFAULT)));
  int mGravity=Integer.parseInt(mPrefs.getString(Settings.ALIGNMENT_PREFERENCE,Integer.toString(Settings.ALIGNMENT_DEFAULT)));
switch (iconSize) {
case SMALL_ICONS:
    rowLayout=R.layout.apps_widget_row_small;
  itemHeight=ICON_SMALL_HEIGHT;
itemWidth=ICON_SMALL_WIDTH;
break;
case LARGE_ICONS:
rowLayout=R.layout.apps_widget_row_large;
itemHeight=ICON_LARGE_HEIGHT;
itemWidth=ICON_LARGE_WIDTH;
break;
}
boolean appsNoByWidgetSize=mPrefs.getBoolean(Settings.APPS_BY_WIDGET_SIZE_PREFERENCE,Settings.APPS_BY_WIDGET_SIZE_DEFAULT);
int appsNoH;
int appsNoW;
boolean autoHeight=true;
Tools.HangarLog(""String_Node_Str"" + options.getInt(AppWidgetManager.OPTION_APPWIDGET_MIN_HEIGHT));
Tools.HangarLog(""String_Node_Str"" + options.getInt(AppWidgetManager.OPTION_APPWIDGET_MAX_HEIGHT));
Tools.HangarLog(""String_Node_Str"" + options.getInt(AppWidgetManager.OPTION_APPWIDGET_MIN_WIDTH));
Tools.HangarLog(""String_Node_Str"" + options.getInt(AppWidgetManager.OPTION_APPWIDGET_MAX_WIDTH));
appsNoH=findDimensions(options.getInt(AppWidgetManager.OPTION_APPWIDGET_MAX_HEIGHT),itemHeight);
appsNoW=findDimensions(options.getInt(AppWidgetManager.OPTION_APPWIDGET_MIN_WIDTH),itemWidth);
Tools.HangarLog(""String_Node_Str"" + appsNoH + ""String_Node_Str""+ appsNoW);
if (appsNoH == 0) {
appsNoH=1;
autoHeight=false;
}
if (context.getResources().getConfiguration().orientation == Configuration.ORIENTATION_LANDSCAPE) {
float widgetHeight=options.getInt(AppWidgetManager.OPTION_APPWIDGET_MIN_HEIGHT);
appsNoH=findDimensions((int)widgetHeight,itemHeight);
int origWidgetHeight=appsNoH;
if (iconSize > SMALL_ICONS) {
if (iconSize == LARGE_ICONS) {
appsNoH=findDimensions(options.getInt(AppWidgetManager.OPTION_APPWIDGET_MIN_HEIGHT),itemHeight);
if (appsNoH == 0 && widgetHeight > 0) {
Tools.HangarLog(""String_Node_Str"");
rowLayout=R.layout.apps_widget_row;
itemWidth=ICON_MEDIUM_WIDTH;
}
}
if (itemWidth == ICON_MEDIUM_WIDTH) {
appsNoH=findDimensions(options.getInt(AppWidgetManager.OPTION_APPWIDGET_MIN_HEIGHT),ICON_MEDIUM_HEIGHT);
if (appsNoH == 0 && widgetHeight > 0) {
Tools.HangarLog(""String_Node_Str"");
rowLayout=R.layout.apps_widget_row_small;
itemWidth=ICON_SMALL_WIDTH;
mGravity=Settings.ALIGNMENT_DEFAULT;
}
}
}
if (origWidgetHeight == 0) {
appsNoH=1;
autoHeight=false;
}
appsNoW=findDimensions(options.getInt(AppWidgetManager.OPTION_APPWIDGET_MAX_WIDTH),itemWidth);
if (appsNoByWidgetSize && appsNoW > 0) {
Tools.HangarLog(""String_Node_Str"" + appsNoW);
}
 else {
appsNoW=Integer.parseInt(mPrefs.getString(Settings.STATS_WIDGET_APPSNO_LS_PREFERENCE,Integer.toString(Settings.APPS_WIDGET_APPSNO_LS_DEFAULT)));
}
Tools.HangarLog(""String_Node_Str"");
}
 else {
if (appsNoByWidgetSize && appsNoW > 0) {
Tools.HangarLog(""String_Node_Str"" + appsNoH);
}
 else {
appsNoW=Integer.parseInt(mPrefs.getString(Settings.STATS_WIDGET_APPSNO_PREFERENCE,Integer.toString(Settings.APPS_WIDGET_APPSNO_DEFAULT)));
}
}
int getBackgroundColor=mPrefs.getInt(Settings.BACKGROUND_COLOR_PREFERENCE,Settings.BACKGROUND_COLOR_DEFAULT);
RemoteViews views=new RemoteViews(context.getPackageName(),R.layout.apps_widget);
views.setInt(R.id.viewCont,""String_Node_Str"",mGravity);
TasksDataSource db=new TasksDataSource(context);
db.open();
int gridSize=(appsNoH * appsNoW);
int numOfIcons=(appsNoH * appsNoW > Settings.TASKLIST_QUEUE_SIZE) ? Settings.TASKLIST_QUEUE_SIZE : (appsNoH * appsNoW);
if (autoHeight && !appsNoByWidgetSize) {
numOfIcons=appsNoW;
}
int queueSize=(Math.ceil(numOfIcons * 1.2f)) < Settings.APPLIST_QUEUE_SIZE ? Settings.APPLIST_QUEUE_SIZE : (int)Math.ceil(numOfIcons * 1.2f);
String taskPackage=context.getPackageName();
boolean weightedRecents=mPrefs.getBoolean(Settings.WEIGHTED_RECENTS_PREFERENCE,Settings.WEIGHTED_RECENTS_DEFAULT);
ArrayList<Tools.TaskInfo> appList=Tools.buildTaskList(context,db,queueSize,weightedRecents,true);
boolean ignorePinned=mPrefs.getBoolean(Settings.IGNORE_PINNED_PREFERENCE,Settings.IGNORE_PINNED_DEFAULT);
if (!ignorePinned) {
ArrayList<Tools.TaskInfo> pinnedList=Tools.buildPinnedList(mContext,db);
appList=new Tools().getPinnedTasks(context,pinnedList,appList,numOfIcons);
}
int imageButtonLayout=context.getResources().getIdentifier(""String_Node_Str"",""String_Node_Str"",taskPackage);
int imageContLayout=context.getResources().getIdentifier(""String_Node_Str"",""String_Node_Str"",taskPackage);
AppDrawer appDrawer=new AppDrawer(taskPackage);
appDrawer.createRow(rowLayout,R.id.viewRow);
appDrawer.setImageLayouts(imageButtonLayout,imageContLayout);
appDrawer.setPrefs(mPrefs);
appDrawer.setContext(mContext);
appDrawer.setRowBackgroundColor(getBackgroundColor);
appDrawer.setCount(numOfIcons,Settings.TASKLIST_QUEUE_SIZE,true);
if (autoHeight && !appsNoByWidgetSize) {
appsNoW=(int)Math.ceil((double)appsNoW / appsNoH);
Tools.HangarLog(""String_Node_Str"" + appsNoW);
}
int filledConts=0;
int filledRows=1;
Tools.HangarLog(""String_Node_Str"" + appsNoW + ""String_Node_Str""+ appList.size()+ ""String_Node_Str""+ numOfIcons);
views.removeAllViews(R.id.viewCont);
for (int i=0; i <= gridSize; i++) {
if (filledConts == appsNoW || i == gridSize) {
Tools.HangarLog(""String_Node_Str"" + i + ""String_Node_Str""+ filledConts);
views.addView(R.id.viewCont,appDrawer.getRow());
if (i >= numOfIcons && !appsNoByWidgetSize) break;
boolean lineBreak=(appsNoByWidgetSize && appList.size() > i) || (!appsNoByWidgetSize && numOfIcons > i);
if (filledRows < appsNoH && filledConts < numOfIcons && lineBreak) {
appDrawer.createRow(rowLayout,R.id.viewRow);
appDrawer.setRowBackgroundColor(getBackgroundColor);
filledConts=0;
filledRows++;
}
 else {
break;
}
}
Tools.TaskInfo newItemTask;
if (i >= appList.size()) {
newItemTask=new Tools.TaskInfo(null);
}
 else {
newItemTask=appList.get(i);
}
boolean newItem=appDrawer.newItem(newItemTask,itemLayout);
if (!newItem) {
numOfIcons++;
continue;
}
filledConts+=1;
if (i >= numOfIcons || i >= appList.size()) {
appDrawer.setItemVisibility(View.INVISIBLE);
appDrawer.addItem();
continue;
}
appDrawer.addItem();
}
appWidgetManager.updateAppWidget(appWidgetId,views);
db.close();
}",0.990554539914686
80564,"@Override public boolean onPreferenceChange(final Preference preference,Object newValue){
  Tools.HangarLog(""String_Node_Str"" + preference.getKey() + ""String_Node_Str""+ newValue+ ""String_Node_Str"");
  final SharedPreferences prefs2=prefs.prefsGet();
  final SharedPreferences.Editor editor=prefs.editorGet();
  if (preference.getKey().equals(DIVIDER_PREFERENCE)) {
    editor.putBoolean(DIVIDER_PREFERENCE,(Boolean)newValue);
    editor.commit();
    myService.execute(SERVICE_CLEAR_TASKS);
    myService.watchHelper(STOP_SERVICE);
    myService.watchHelper(START_SERVICE);
  }
 else   if (preference.getKey().equals(ROW_DIVIDER_PREFERENCE)) {
    editor.putBoolean(ROW_DIVIDER_PREFERENCE,(Boolean)newValue);
    editor.commit();
    myService.execute(SERVICE_CLEAR_TASKS);
    myService.watchHelper(STOP_SERVICE);
    myService.watchHelper(START_SERVICE);
  }
 else   if (preference.getKey().equals(COLORIZE_PREFERENCE)) {
    editor.putBoolean(COLORIZE_PREFERENCE,(Boolean)newValue);
    editor.commit();
    myService.execute(SERVICE_CLEAR_TASKS);
    myService.watchHelper(STOP_SERVICE);
    myService.watchHelper(START_SERVICE);
  }
 else   if (preference.getKey().equals(STATUSBAR_ICON_PREFERENCE)) {
    final String mStatusBarIcon=(String)newValue;
    if (mStatusBarIcon.equals(STATUSBAR_ICON_NONE)) {
      new AlertDialog.Builder(myService.mContext).setTitle(R.string.alert_title_statusbar_icon_preference).setMessage(R.string.alert_message_statusbar_icon_preference).setPositiveButton(""String_Node_Str"",new DialogInterface.OnClickListener(){
        public void onClick(        DialogInterface dialog,        int whichButton){
          editor.putString(STATUSBAR_ICON_PREFERENCE,mStatusBarIcon);
          editor.putString(PRIORITY_PREFERENCE,Integer.toString(PRIORITY_BOTTOM));
          editor.commit();
          PrefsFragment mBehaviorSettings=(PrefsFragment)mGetFragments.getFragmentByPosition(0);
          mBehaviorSettings.priority_preference.setValue(Integer.toString(PRIORITY_BOTTOM));
          launchPriorityWarning(prefs2);
          myService.execute(SERVICE_DESTROY_NOTIFICATIONS);
          myService.watchHelper(STOP_SERVICE);
          myService.watchHelper(START_SERVICE);
        }
      }
).setNegativeButton(""String_Node_Str"",new DialogInterface.OnClickListener(){
        public void onClick(        DialogInterface dialog,        int whichButton){
          statusbar_icon_preference.setValue(prefs2.getString(STATUSBAR_ICON_PREFERENCE,STATUSBAR_ICON_DEFAULT));
        }
      }
).show();
    }
 else {
      PrefsFragment mBehaviorSettings=(PrefsFragment)mGetFragments.getFragmentByPosition(0);
      if (mBehaviorSettings.priority_preference.getValue().equals(Integer.toString(PRIORITY_BOTTOM))) {
        editor.putString(PRIORITY_PREFERENCE,Integer.toString(PRIORITY_DEFAULT));
        mBehaviorSettings.priority_preference.setValue(Integer.toString(PRIORITY_DEFAULT));
      }
      editor.putString(STATUSBAR_ICON_PREFERENCE,(String)newValue);
      editor.commit();
      myService.execute(SERVICE_DESTROY_NOTIFICATIONS);
      myService.watchHelper(STOP_SERVICE);
      myService.watchHelper(START_SERVICE);
    }
  }
 else   if (preference.getKey().equals(ICON_COLOR_PREFERENCE)) {
    String hex=ColorPickerPreference.convertToARGB(Integer.valueOf(String.valueOf(newValue)));
    preference.setSummary(hex);
    int intHex=ColorPickerPreference.convertToColorInt(hex);
    editor.putInt(ICON_COLOR_PREFERENCE,intHex);
    editor.commit();
    myService.execute(SERVICE_CLEAR_TASKS);
    myService.watchHelper(STOP_SERVICE);
    myService.watchHelper(START_SERVICE);
  }
 else   if (preference.getKey().equals(ICON_SIZE_PREFERENCE)) {
    editor.putString(Settings.ICON_SIZE_PREFERENCE,(String)newValue);
    editor.commit();
    myService.execute(SERVICE_CREATE_NOTIFICATIONS);
  }
 else   if (preference.getKey().equals(TOGGLE_PREFERENCE)) {
    editor.putBoolean(TOGGLE_PREFERENCE,(Boolean)newValue);
    editor.commit();
    myService.execute(SERVICE_DESTROY_NOTIFICATIONS);
    myService.watchHelper(STOP_SERVICE);
    myService.watchHelper(START_SERVICE);
  }
 else   if (preference.getKey().equals(BOOT_PREFERENCE)) {
    editor.putBoolean(BOOT_PREFERENCE,(Boolean)newValue);
    editor.commit();
  }
 else   if (preference.getKey().equals(WEIGHT_PRIORITY_PREFERENCE)) {
    editor.putString(WEIGHT_PRIORITY_PREFERENCE,(String)newValue);
    editor.commit();
    myService.execute(SERVICE_BUILD_REORDER_LAUNCH);
  }
 else   if (preference.getKey().equals(WEIGHTED_RECENTS_PREFERENCE)) {
    editor.putBoolean(WEIGHTED_RECENTS_PREFERENCE,(Boolean)newValue);
    editor.commit();
    myService.execute(SERVICE_BUILD_REORDER_LAUNCH);
  }
 else   if (preference.getKey().equals(SMART_NOTIFICATION_PREFERENCE)) {
    editor.putBoolean(SMART_NOTIFICATION_PREFERENCE,(Boolean)newValue);
    editor.commit();
    myService.execute(SERVICE_DESTROY_NOTIFICATIONS);
    myService.watchHelper(STOP_SERVICE);
    myService.watchHelper(START_SERVICE);
  }
 else   if (preference.getKey().equals(APPSNO_PREFERENCE)) {
    editor.putString(APPSNO_PREFERENCE,(String)newValue);
    editor.commit();
    myService.execute(SERVICE_DESTROY_NOTIFICATIONS);
    myService.watchHelper(STOP_SERVICE);
    myService.watchHelper(START_SERVICE);
  }
 else   if (preference.getKey().equals(PRIORITY_PREFERENCE)) {
    String mPriorityPreference=(String)newValue;
    editor.putString(PRIORITY_PREFERENCE,mPriorityPreference);
    PrefsFragment mAppearanceSettings=(PrefsFragment)mGetFragments.getFragmentByPosition(1);
    if (!mPriorityPreference.equals(Integer.toString(PRIORITY_BOTTOM)) && mAppearanceSettings.statusbar_icon_preference.getValue().equals(STATUSBAR_ICON_NONE)) {
      editor.putString(STATUSBAR_ICON_PREFERENCE,STATUSBAR_ICON_DEFAULT);
      mAppearanceSettings.statusbar_icon_preference.setValue(STATUSBAR_ICON_DEFAULT);
    }
    editor.commit();
    launchPriorityWarning(prefs2);
    myService.execute(SERVICE_DESTROY_NOTIFICATIONS);
    myService.watchHelper(STOP_SERVICE);
    myService.watchHelper(START_SERVICE);
  }
 else   if (preference.getKey().equals(SECOND_ROW_PREFERENCE)) {
    setAppsnoSummary((Boolean)newValue,appnos_preference);
    editor.putBoolean(SECOND_ROW_PREFERENCE,(Boolean)newValue);
    editor.commit();
    launchPriorityWarning(prefs2);
    myService.execute(SERVICE_DESTROY_NOTIFICATIONS);
    myService.watchHelper(STOP_SERVICE);
    myService.watchHelper(START_SERVICE);
  }
 else   if (preference.getKey().equals(PINNED_SORT_PREFERENCE)) {
    editor.putString(PINNED_SORT_PREFERENCE,(String)newValue);
    editor.commit();
    String pinnedApps=prefs2.getString(PINNED_APPS,null);
    if (pinnedApps != null && !pinnedApps.isEmpty()) {
      myService.execute(SERVICE_BUILD_REORDER_LAUNCH);
    }
  }
 else   if (preference.getKey().equals(PINNED_PLACEMENT_PREFERENCE)) {
    editor.putString(PINNED_PLACEMENT_PREFERENCE,(String)newValue);
    editor.commit();
    String pinnedApps=prefs2.getString(PINNED_APPS,null);
    if (pinnedApps != null && !pinnedApps.isEmpty()) {
      myService.execute(SERVICE_BUILD_REORDER_LAUNCH);
    }
  }
  return true;
}","@Override public boolean onPreferenceChange(final Preference preference,Object newValue){
  Tools.HangarLog(""String_Node_Str"" + preference.getKey() + ""String_Node_Str""+ newValue+ ""String_Node_Str"");
  final SharedPreferences prefs2=prefs.prefsGet();
  final SharedPreferences.Editor editor=prefs.editorGet();
  if (preference.getKey().equals(DIVIDER_PREFERENCE)) {
    editor.putBoolean(DIVIDER_PREFERENCE,(Boolean)newValue);
    editor.commit();
    myService.execute(SERVICE_CLEAR_TASKS);
    myService.watchHelper(STOP_SERVICE);
    myService.watchHelper(START_SERVICE);
  }
 else   if (preference.getKey().equals(ROW_DIVIDER_PREFERENCE)) {
    editor.putBoolean(ROW_DIVIDER_PREFERENCE,(Boolean)newValue);
    editor.commit();
    myService.execute(SERVICE_CLEAR_TASKS);
    myService.watchHelper(STOP_SERVICE);
    myService.watchHelper(START_SERVICE);
  }
 else   if (preference.getKey().equals(COLORIZE_PREFERENCE)) {
    editor.putBoolean(COLORIZE_PREFERENCE,(Boolean)newValue);
    editor.commit();
    myService.execute(SERVICE_CLEAR_TASKS);
    myService.watchHelper(STOP_SERVICE);
    myService.watchHelper(START_SERVICE);
  }
 else   if (preference.getKey().equals(STATUSBAR_ICON_PREFERENCE)) {
    final String mStatusBarIcon=(String)newValue;
    if (mStatusBarIcon.equals(STATUSBAR_ICON_NONE)) {
      new AlertDialog.Builder(myService.mContext).setTitle(R.string.alert_title_statusbar_icon_preference).setMessage(R.string.alert_message_statusbar_icon_preference).setPositiveButton(""String_Node_Str"",new DialogInterface.OnClickListener(){
        public void onClick(        DialogInterface dialog,        int whichButton){
          editor.putString(STATUSBAR_ICON_PREFERENCE,mStatusBarIcon);
          editor.putString(PRIORITY_PREFERENCE,Integer.toString(PRIORITY_BOTTOM));
          editor.commit();
          PrefsFragment mBehaviorSettings=(PrefsFragment)mGetFragments.getFragmentByPosition(0);
          mBehaviorSettings.priority_preference.setValue(Integer.toString(PRIORITY_BOTTOM));
          launchPriorityWarning(prefs2);
          myService.execute(SERVICE_DESTROY_NOTIFICATIONS);
          myService.watchHelper(STOP_SERVICE);
          myService.watchHelper(START_SERVICE);
        }
      }
).setNegativeButton(""String_Node_Str"",new DialogInterface.OnClickListener(){
        public void onClick(        DialogInterface dialog,        int whichButton){
          statusbar_icon_preference.setValue(prefs2.getString(STATUSBAR_ICON_PREFERENCE,STATUSBAR_ICON_DEFAULT));
        }
      }
).show();
    }
 else {
      PrefsFragment mBehaviorSettings=(PrefsFragment)mGetFragments.getFragmentByPosition(0);
      if (mBehaviorSettings.priority_preference.getValue().equals(Integer.toString(PRIORITY_BOTTOM))) {
        editor.putString(PRIORITY_PREFERENCE,Integer.toString(PRIORITY_DEFAULT));
        mBehaviorSettings.priority_preference.setValue(Integer.toString(PRIORITY_DEFAULT));
      }
      editor.putString(STATUSBAR_ICON_PREFERENCE,(String)newValue);
      editor.commit();
      myService.execute(SERVICE_DESTROY_NOTIFICATIONS);
      myService.watchHelper(STOP_SERVICE);
      myService.watchHelper(START_SERVICE);
    }
  }
 else   if (preference.getKey().equals(ICON_COLOR_PREFERENCE)) {
    String hex=ColorPickerPreference.convertToARGB(Integer.valueOf(String.valueOf(newValue)));
    preference.setSummary(hex);
    int intHex=ColorPickerPreference.convertToColorInt(hex);
    editor.putInt(ICON_COLOR_PREFERENCE,intHex);
    editor.commit();
    myService.execute(SERVICE_CLEAR_TASKS);
    myService.watchHelper(STOP_SERVICE);
    myService.watchHelper(START_SERVICE);
  }
 else   if (preference.getKey().equals(ICON_SIZE_PREFERENCE)) {
    editor.putString(Settings.ICON_SIZE_PREFERENCE,(String)newValue);
    editor.commit();
    myService.execute(SERVICE_CREATE_NOTIFICATIONS);
  }
 else   if (preference.getKey().equals(TOGGLE_PREFERENCE)) {
    editor.putBoolean(TOGGLE_PREFERENCE,(Boolean)newValue);
    editor.commit();
    boolean toggleBool=(Boolean)newValue;
    toggleDependencies(toggleBool);
    myService.execute(SERVICE_DESTROY_NOTIFICATIONS);
    myService.watchHelper(STOP_SERVICE);
    myService.watchHelper(START_SERVICE);
  }
 else   if (preference.getKey().equals(BOOT_PREFERENCE)) {
    editor.putBoolean(BOOT_PREFERENCE,(Boolean)newValue);
    editor.commit();
  }
 else   if (preference.getKey().equals(WEIGHT_PRIORITY_PREFERENCE)) {
    editor.putString(WEIGHT_PRIORITY_PREFERENCE,(String)newValue);
    editor.commit();
    myService.execute(SERVICE_BUILD_REORDER_LAUNCH);
  }
 else   if (preference.getKey().equals(WEIGHTED_RECENTS_PREFERENCE)) {
    editor.putBoolean(WEIGHTED_RECENTS_PREFERENCE,(Boolean)newValue);
    editor.commit();
    myService.execute(SERVICE_BUILD_REORDER_LAUNCH);
  }
 else   if (preference.getKey().equals(SMART_NOTIFICATION_PREFERENCE)) {
    editor.putBoolean(SMART_NOTIFICATION_PREFERENCE,(Boolean)newValue);
    editor.commit();
    myService.execute(SERVICE_DESTROY_NOTIFICATIONS);
    myService.watchHelper(STOP_SERVICE);
    myService.watchHelper(START_SERVICE);
  }
 else   if (preference.getKey().equals(APPSNO_PREFERENCE)) {
    editor.putString(APPSNO_PREFERENCE,(String)newValue);
    editor.commit();
    myService.execute(SERVICE_DESTROY_NOTIFICATIONS);
    myService.watchHelper(STOP_SERVICE);
    myService.watchHelper(START_SERVICE);
  }
 else   if (preference.getKey().equals(PRIORITY_PREFERENCE)) {
    String mPriorityPreference=(String)newValue;
    editor.putString(PRIORITY_PREFERENCE,mPriorityPreference);
    PrefsFragment mAppearanceSettings=(PrefsFragment)mGetFragments.getFragmentByPosition(1);
    if (!mPriorityPreference.equals(Integer.toString(PRIORITY_BOTTOM)) && mAppearanceSettings.statusbar_icon_preference.getValue().equals(STATUSBAR_ICON_NONE)) {
      editor.putString(STATUSBAR_ICON_PREFERENCE,STATUSBAR_ICON_DEFAULT);
      mAppearanceSettings.statusbar_icon_preference.setValue(STATUSBAR_ICON_DEFAULT);
    }
    editor.commit();
    launchPriorityWarning(prefs2);
    myService.execute(SERVICE_DESTROY_NOTIFICATIONS);
    myService.watchHelper(STOP_SERVICE);
    myService.watchHelper(START_SERVICE);
  }
 else   if (preference.getKey().equals(SECOND_ROW_PREFERENCE)) {
    setAppsnoSummary((Boolean)newValue,appnos_preference);
    editor.putBoolean(SECOND_ROW_PREFERENCE,(Boolean)newValue);
    editor.commit();
    launchPriorityWarning(prefs2);
    myService.execute(SERVICE_DESTROY_NOTIFICATIONS);
    myService.watchHelper(STOP_SERVICE);
    myService.watchHelper(START_SERVICE);
  }
 else   if (preference.getKey().equals(PINNED_SORT_PREFERENCE)) {
    editor.putString(PINNED_SORT_PREFERENCE,(String)newValue);
    editor.commit();
    String pinnedApps=prefs2.getString(PINNED_APPS,null);
    if (pinnedApps != null && !pinnedApps.isEmpty()) {
      myService.execute(SERVICE_BUILD_REORDER_LAUNCH);
    }
  }
 else   if (preference.getKey().equals(PINNED_PLACEMENT_PREFERENCE)) {
    editor.putString(PINNED_PLACEMENT_PREFERENCE,(String)newValue);
    editor.commit();
    String pinnedApps=prefs2.getString(PINNED_APPS,null);
    if (pinnedApps != null && !pinnedApps.isEmpty()) {
      myService.execute(SERVICE_BUILD_REORDER_LAUNCH);
    }
  }
  return true;
}",0.9945652173913044
80565,"protected void reorderAndLaunch(ArrayList<Tools.TaskInfo> taskList){
  Tools.HangarLog(""String_Node_Str"" + taskList.size());
  boolean weightedRecents=prefs.getBoolean(Settings.WEIGHTED_RECENTS_PREFERENCE,Settings.WEIGHTED_RECENTS_DEFAULT);
  boolean isToggled=prefs.getBoolean(Settings.TOGGLE_PREFERENCE,Settings.TOGGLE_DEFAULT);
  int weightPriority=Integer.parseInt(prefs.getString(Settings.WEIGHT_PRIORITY_PREFERENCE,Integer.toString(Settings.WEIGHT_PRIORITY_DEFAULT)));
  if (weightedRecents) {
    taskList=new Tools().reorderTasks(taskList,db,weightPriority);
  }
  if (isToggled)   createNotification(taskList);
  try {
    int ids[]=AppWidgetManager.getInstance(this).getAppWidgetIds(new ComponentName(this,AppsWidget.class));
    if (ids.length > 0)     Tools.reorderWidgetTasks(db,getApplicationContext());
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}","protected void reorderAndLaunch(ArrayList<Tools.TaskInfo> taskList){
  reorderAndLaunch(taskList,false);
}",0.1912512716174974
80566,"protected void buildTasks(){
  Runnable runnable=new Runnable(){
    @Override public void run(){
      try {
        boolean isToggled=prefs.getBoolean(Settings.TOGGLE_PREFERENCE,Settings.TOGGLE_DEFAULT);
        boolean smartNotification=prefs.getBoolean(Settings.SMART_NOTIFICATION_PREFERENCE,Settings.SMART_NOTIFICATION_DEFAULT);
        final ActivityManager activityManager=(ActivityManager)getSystemService(Context.ACTIVITY_SERVICE);
        final List<ActivityManager.RunningTaskInfo> recentTasks=activityManager.getRunningTasks(MAX_RUNNING_TASKS);
        final Context mContext=getApplicationContext();
        pm=(PowerManager)getSystemService(Context.POWER_SERVICE);
        if (recentTasks != null && recentTasks.size() > 0) {
          ComponentName task=recentTasks.get(0).baseActivity;
          String taskClass=task.getClassName();
          String taskPackage=task.getPackageName();
          if (launcherPackage != null && taskPackage != null && taskPackage.equals(launcherPackage)) {
            if (runningTask == null || !runningTask.packageName.equals(taskPackage)) {
              Tools.HangarLog(""String_Node_Str"");
              Tools.updateWidget(mContext);
              runningTask=new TaskInfo(taskPackage);
              buildReorderAndLaunch(isToggled & !isNotificationRunning);
            }
            return;
          }
          if (taskClass.equals(""String_Node_Str"") || Tools.isBlacklistedOrBad(taskPackage,mContext,db)) {
            buildReorderAndLaunch(isToggled & !isNotificationRunning);
            return;
          }
          if (runningTask != null && runningTask.packageName.equals(taskPackage)) {
            if (pm.isScreenOn()) {
              runningTask.seconds+=LOOP_SECONDS;
              if (runningTask.seconds >= LOOP_SECONDS * 5) {
                db.addSeconds(taskPackage,runningTask.seconds);
                runningTask.totalseconds+=runningTask.seconds;
                runningTask.seconds=0;
              }
            }
            return;
          }
          buildTaskInfo(taskClass,taskPackage);
          if (taskClass.equals(getPackageName())) {
            buildReorderAndLaunch(isToggled & !isNotificationRunning);
            return;
          }
          if (smartNotification) {
            if (notificationTasks != null && new Tools().isInArray(notificationTasks,taskPackage)) {
              buildReorderAndLaunch(isToggled & !isNotificationRunning);
              return;
            }
          }
 else {
            if (new Tools().isPinned(mContext,taskPackage)) {
              buildReorderAndLaunch(isToggled & !isNotificationRunning);
              return;
            }
          }
        }
        buildReorderAndLaunch(isToggled);
      }
 catch (      Exception e) {
        e.printStackTrace();
      }
    }
  }
;
  new Thread(runnable).start();
}","protected void buildTasks(){
  Runnable runnable=new Runnable(){
    @Override public void run(){
      try {
        boolean isToggled=prefs.getBoolean(Settings.TOGGLE_PREFERENCE,Settings.TOGGLE_DEFAULT);
        boolean smartNotification=prefs.getBoolean(Settings.SMART_NOTIFICATION_PREFERENCE,Settings.SMART_NOTIFICATION_DEFAULT);
        final ActivityManager activityManager=(ActivityManager)getSystemService(Context.ACTIVITY_SERVICE);
        final List<ActivityManager.RunningTaskInfo> recentTasks=activityManager.getRunningTasks(MAX_RUNNING_TASKS);
        final Context mContext=getApplicationContext();
        pm=(PowerManager)getSystemService(Context.POWER_SERVICE);
        if (recentTasks != null && recentTasks.size() > 0) {
          ComponentName task=recentTasks.get(0).baseActivity;
          String taskClass=task.getClassName();
          String taskPackage=task.getPackageName();
          if (launcherPackage != null && taskPackage != null && taskPackage.equals(launcherPackage)) {
            if (runningTask == null || !runningTask.packageName.equals(taskPackage)) {
              if (!isToggled && isAppsWidget()) {
                taskList=Tools.buildTaskList(getApplicationContext(),db,Settings.TASKLIST_QUEUE_LIMIT);
                reorderAndLaunch(taskList,true);
              }
              Tools.HangarLog(""String_Node_Str"");
              Tools.updateWidget(mContext);
              runningTask=new TaskInfo(taskPackage);
              buildReorderAndLaunch(isToggled & !isNotificationRunning);
            }
            return;
          }
          if (taskClass.equals(""String_Node_Str"") || Tools.isBlacklistedOrBad(taskPackage,mContext,db)) {
            buildReorderAndLaunch(isToggled & !isNotificationRunning);
            return;
          }
          if (runningTask != null && runningTask.packageName.equals(taskPackage)) {
            if (pm.isScreenOn()) {
              runningTask.seconds+=LOOP_SECONDS;
              if (runningTask.seconds >= LOOP_SECONDS * 5) {
                db.addSeconds(taskPackage,runningTask.seconds);
                runningTask.totalseconds+=runningTask.seconds;
                runningTask.seconds=0;
              }
            }
            return;
          }
          buildTaskInfo(taskClass,taskPackage);
          if (taskClass.equals(getPackageName())) {
            buildReorderAndLaunch(isToggled & !isNotificationRunning);
            return;
          }
          if (smartNotification && isToggled) {
            if (notificationTasks != null && new Tools().isInArray(notificationTasks,taskPackage)) {
              buildReorderAndLaunch(!isNotificationRunning);
              return;
            }
          }
          if (new Tools().isPinned(mContext,taskPackage)) {
            buildReorderAndLaunch(isToggled & !isNotificationRunning);
            return;
          }
        }
        buildReorderAndLaunch(isToggled);
      }
 catch (      Exception e) {
        e.printStackTrace();
      }
    }
  }
;
  new Thread(runnable).start();
}",0.951393609789259
80567,"public void createNotification(ArrayList<Tools.TaskInfo> taskList){
  String taskPackage=this.getPackageName();
  Context mContext=getApplicationContext();
  int contLayout=prefs.getBoolean(Settings.ROW_DIVIDER_PREFERENCE,Settings.ROW_DIVIDER_DEFAULT) ? getResources().getIdentifier(""String_Node_Str"",""String_Node_Str"",taskPackage) : getResources().getIdentifier(""String_Node_Str"",""String_Node_Str"",taskPackage);
  int rowLayout=prefs.getBoolean(Settings.DIVIDER_PREFERENCE,Settings.DIVIDER_DEFAULT) ? getResources().getIdentifier(""String_Node_Str"",""String_Node_Str"",taskPackage) : getResources().getIdentifier(""String_Node_Str"",""String_Node_Str"",taskPackage);
  int imageButtonLayout=getResources().getIdentifier(""String_Node_Str"",""String_Node_Str"",taskPackage);
  int imageContLayout=getResources().getIdentifier(""String_Node_Str"",""String_Node_Str"",taskPackage);
  RemoteViews customNotifView=new RemoteViews(taskPackage,contLayout);
  RemoteViews customNotifBigView=customNotifView;
  AppDrawer appDrawer=new AppDrawer(taskPackage);
  appDrawer.createRow(rowLayout,R.id.notifRow);
  appDrawer.setImageLayouts(imageButtonLayout,imageContLayout);
  appDrawer.setPrefs(prefs);
  appDrawer.setContext(mContext);
  int maxButtons;
  int setPriority=Integer.parseInt(prefs.getString(Settings.PRIORITY_PREFERENCE,Integer.toString(Settings.PRIORITY_DEFAULT)));
  if (taskList.size() < numOfApps) {
    maxButtons=taskList.size();
  }
 else {
    maxButtons=numOfApps;
  }
  if (taskList.size() <= numOfApps) {
    Tools.HangarLog(""String_Node_Str"");
    secondRow=false;
  }
  Tools.HangarLog(""String_Node_Str"" + taskList.size() + ""String_Node_Str""+ numOfApps+ ""String_Node_Str""+ maxButtons);
  int filledConts=0;
  boolean filledSecondRow=false;
  int iconSize=Integer.parseInt(prefs.getString(Settings.ICON_SIZE_PREFERENCE,Integer.toString(Settings.ICON_SIZE_DEFAULT)));
  int itemLayout=R.layout.notification_item;
  if (iconSize == ICON_SIZE_SMALL) {
    itemLayout=R.layout.notification_item_small;
  }
 else   if (iconSize == ICON_SIZE_LARGE) {
    itemLayout=R.layout.notification_item_large;
  }
  customNotifBigView.removeAllViews(R.id.notifContainer);
  for (int i=0; i <= taskList.size(); i++) {
    if (filledConts == maxButtons) {
      if (filledSecondRow) {
        filledSecondRow=false;
        customNotifBigView=customNotifView;
        customNotifBigView.addView(R.id.notifContainer,appDrawer.getRow());
        break;
      }
 else {
        customNotifView.addView(R.id.notifContainer,appDrawer.getRow());
        filledSecondRow=true;
        filledConts=0;
        appDrawer.createRow(rowLayout,R.id.notifRow);
        appDrawer.setImageLayouts(imageButtonLayout,imageContLayout);
      }
    }
    if (appDrawer.newItem(taskList.get(i),itemLayout)) {
      appDrawer.addItem();
      filledConts++;
    }
  }
  if (filledSecondRow && secondRow) {
    Tools.HangarLog(""String_Node_Str"");
    customNotifBigView=customNotifView;
    customNotifBigView.addView(R.id.notifContainer,appDrawer.getRow());
  }
  String mIcon=prefs.getString(Settings.STATUSBAR_ICON_PREFERENCE,Settings.STATUSBAR_ICON_DEFAULT);
  int smallIcon=iconMap.get(Settings.STATUSBAR_ICON_WHITE_WARM);
  try {
    smallIcon=iconMap.get(mIcon);
  }
 catch (  NullPointerException e) {
  }
  Notification notification=new Notification.Builder(WatchfulService.this).setContentTitle(getResources().getString(R.string.app_name)).setContentText(getResources().getString(R.string.app_name)).setSmallIcon(smallIcon).setContent(customNotifView).setOngoing(true).setPriority(setPriority).build();
  if (secondRow) {
    notification.bigContentView=customNotifBigView;
  }
  startForeground(1337,notification);
  isNotificationRunning=true;
}","public void createNotification(ArrayList<Tools.TaskInfo> taskList){
  String taskPackage=this.getPackageName();
  Context mContext=getApplicationContext();
  int contLayout=prefs.getBoolean(Settings.ROW_DIVIDER_PREFERENCE,Settings.ROW_DIVIDER_DEFAULT) ? getResources().getIdentifier(""String_Node_Str"",""String_Node_Str"",taskPackage) : getResources().getIdentifier(""String_Node_Str"",""String_Node_Str"",taskPackage);
  int rowLayout=prefs.getBoolean(Settings.DIVIDER_PREFERENCE,Settings.DIVIDER_DEFAULT) ? getResources().getIdentifier(""String_Node_Str"",""String_Node_Str"",taskPackage) : getResources().getIdentifier(""String_Node_Str"",""String_Node_Str"",taskPackage);
  int imageButtonLayout=getResources().getIdentifier(""String_Node_Str"",""String_Node_Str"",taskPackage);
  int imageContLayout=getResources().getIdentifier(""String_Node_Str"",""String_Node_Str"",taskPackage);
  RemoteViews customNotifView=new RemoteViews(taskPackage,contLayout);
  RemoteViews customNotifBigView=customNotifView;
  AppDrawer appDrawer=new AppDrawer(taskPackage);
  appDrawer.createRow(rowLayout,R.id.notifRow);
  appDrawer.setImageLayouts(imageButtonLayout,imageContLayout);
  appDrawer.setPrefs(prefs);
  appDrawer.setContext(mContext);
  int maxButtons;
  int setPriority=Integer.parseInt(prefs.getString(Settings.PRIORITY_PREFERENCE,Integer.toString(Settings.PRIORITY_DEFAULT)));
  if (taskList.size() < numOfApps) {
    maxButtons=taskList.size();
  }
 else {
    maxButtons=numOfApps;
  }
  if (taskList.size() <= numOfApps) {
    Tools.HangarLog(""String_Node_Str"");
    secondRow=false;
  }
  Tools.HangarLog(""String_Node_Str"" + taskList.size() + ""String_Node_Str""+ numOfApps+ ""String_Node_Str""+ maxButtons);
  int filledConts=0;
  boolean filledSecondRow=false;
  int iconSize=Integer.parseInt(prefs.getString(Settings.ICON_SIZE_PREFERENCE,Integer.toString(Settings.ICON_SIZE_DEFAULT)));
  int itemLayout=R.layout.notification_item;
  if (iconSize == ICON_SIZE_SMALL) {
    itemLayout=R.layout.notification_item_small;
  }
 else   if (iconSize == ICON_SIZE_LARGE) {
    itemLayout=R.layout.notification_item_large;
  }
  customNotifBigView.removeAllViews(R.id.notifContainer);
  for (int i=0; i <= taskList.size(); i++) {
    boolean wrapItUp=false;
    if (i == taskList.size())     wrapItUp=true;
    if (filledConts == maxButtons || wrapItUp) {
      if (filledSecondRow) {
        filledSecondRow=false;
        customNotifBigView=customNotifView;
        customNotifBigView.addView(R.id.notifContainer,appDrawer.getRow());
        break;
      }
 else {
        customNotifView.addView(R.id.notifContainer,appDrawer.getRow());
        filledSecondRow=true;
        filledConts=0;
        appDrawer.createRow(rowLayout,R.id.notifRow);
        appDrawer.setImageLayouts(imageButtonLayout,imageContLayout);
      }
    }
    if (!wrapItUp && appDrawer.newItem(taskList.get(i),itemLayout)) {
      appDrawer.addItem();
      filledConts++;
    }
  }
  if (filledSecondRow && secondRow) {
    Tools.HangarLog(""String_Node_Str"");
    customNotifBigView=customNotifView;
    customNotifBigView.addView(R.id.notifContainer,appDrawer.getRow());
  }
  String mIcon=prefs.getString(Settings.STATUSBAR_ICON_PREFERENCE,Settings.STATUSBAR_ICON_DEFAULT);
  int smallIcon=iconMap.get(Settings.STATUSBAR_ICON_WHITE_WARM);
  try {
    smallIcon=iconMap.get(mIcon);
  }
 catch (  NullPointerException e) {
  }
  Notification notification=new Notification.Builder(WatchfulService.this).setContentTitle(getResources().getString(R.string.app_name)).setContentText(getResources().getString(R.string.app_name)).setSmallIcon(smallIcon).setContent(customNotifView).setOngoing(true).setPriority(setPriority).build();
  if (secondRow) {
    notification.bigContentView=customNotifBigView;
  }
  if (isNotificationRunning) {
    NotificationManager mNotificationManager=(NotificationManager)getSystemService(Context.NOTIFICATION_SERVICE);
    mNotificationManager.notify(1337,notification);
  }
 else {
    startForeground(1337,notification);
  }
  isNotificationRunning=true;
}",0.948264740033544
80568,"@Override public boolean onPreferenceChange(final Preference preference,Object newValue){
  Tools.HangarLog(""String_Node_Str"" + preference.getKey() + ""String_Node_Str""+ newValue+ ""String_Node_Str"");
  final SharedPreferences prefs2=prefs.prefsGet();
  final SharedPreferences.Editor editor=prefs.editorGet();
  if (preference.getKey().equals(DIVIDER_PREFERENCE)) {
    editor.putBoolean(DIVIDER_PREFERENCE,(Boolean)newValue);
    editor.apply();
    myService.execute(SERVICE_CLEAR_TASKS);
    myService.watchHelper(STOP_SERVICE);
    myService.watchHelper(START_SERVICE);
  }
 else   if (preference.getKey().equals(COLORIZE_PREFERENCE)) {
    editor.putBoolean(COLORIZE_PREFERENCE,(Boolean)newValue);
    editor.apply();
    myService.execute(SERVICE_CLEAR_TASKS);
    myService.watchHelper(STOP_SERVICE);
    myService.watchHelper(START_SERVICE);
  }
 else   if (preference.getKey().equals(STATUSBAR_ICON_PREFERENCE)) {
    final String mStatusBarIcon=(String)newValue;
    if (mStatusBarIcon.equals(STATUSBAR_ICON_NONE)) {
      new AlertDialog.Builder(myService.mContext).setTitle(R.string.alert_title_statusbar_icon_preference).setMessage(R.string.alert_message_statusbar_icon_preference).setPositiveButton(""String_Node_Str"",new DialogInterface.OnClickListener(){
        public void onClick(        DialogInterface dialog,        int whichButton){
          editor.putString(STATUSBAR_ICON_PREFERENCE,mStatusBarIcon);
          editor.putString(PRIORITY_PREFERENCE,Integer.toString(PRIORITY_BOTTOM));
          editor.apply();
          PrefsFragment mBehaviorSettings=(PrefsFragment)mGetFragments.getFragmentByPosition(0);
          mBehaviorSettings.priority_preference.setValue(Integer.toString(PRIORITY_BOTTOM));
          myService.execute(SERVICE_DESTROY_NOTIFICATIONS);
          myService.watchHelper(STOP_SERVICE);
          myService.watchHelper(START_SERVICE);
        }
      }
).setNegativeButton(""String_Node_Str"",new DialogInterface.OnClickListener(){
        public void onClick(        DialogInterface dialog,        int whichButton){
          statusbar_icon_preference.setValue(prefs2.getString(STATUSBAR_ICON_PREFERENCE,STATUSBAR_ICON_DEFAULT));
        }
      }
).show();
    }
 else {
      PrefsFragment mBehaviorSettings=(PrefsFragment)mGetFragments.getFragmentByPosition(0);
      if (mBehaviorSettings.priority_preference.getValue().equals(Integer.toString(PRIORITY_BOTTOM))) {
        editor.putString(PRIORITY_PREFERENCE,Integer.toString(PRIORITY_DEFAULT));
        mBehaviorSettings.priority_preference.setValue(Integer.toString(PRIORITY_DEFAULT));
      }
      editor.putString(STATUSBAR_ICON_PREFERENCE,(String)newValue);
      editor.apply();
      myService.execute(SERVICE_DESTROY_NOTIFICATIONS);
      myService.watchHelper(STOP_SERVICE);
      myService.watchHelper(START_SERVICE);
    }
  }
 else   if (preference.getKey().equals(ICON_COLOR_PREFERENCE)) {
    String hex=ColorPickerPreference.convertToARGB(Integer.valueOf(String.valueOf(newValue)));
    preference.setSummary(hex);
    int intHex=ColorPickerPreference.convertToColorInt(hex);
    editor.putInt(ICON_COLOR_PREFERENCE,intHex);
    editor.apply();
    myService.execute(SERVICE_CLEAR_TASKS);
    myService.watchHelper(STOP_SERVICE);
    myService.watchHelper(START_SERVICE);
  }
 else   if (preference.getKey().equals(ICON_SIZE_PREFERENCE)) {
    editor.putString(Settings.ICON_SIZE_PREFERENCE,(String)newValue);
    editor.apply();
    myService.execute(SERVICE_CLEAR_TASKS);
    myService.watchHelper(STOP_SERVICE);
    myService.watchHelper(START_SERVICE);
  }
 else   if (preference.getKey().equals(TOGGLE_PREFERENCE)) {
    editor.putBoolean(TOGGLE_PREFERENCE,(Boolean)newValue);
    editor.apply();
    myService.execute(SERVICE_DESTROY_NOTIFICATIONS);
    myService.watchHelper(STOP_SERVICE);
    myService.watchHelper(START_SERVICE);
  }
 else   if (preference.getKey().equals(BOOT_PREFERENCE)) {
    editor.putBoolean(BOOT_PREFERENCE,(Boolean)newValue);
    editor.apply();
  }
 else   if (preference.getKey().equals(WEIGHT_PRIORITY_PREFERENCE)) {
    editor.putString(WEIGHT_PRIORITY_PREFERENCE,(String)newValue);
    editor.apply();
    myService.execute(SERVICE_CLEAR_TASKS);
    myService.watchHelper(STOP_SERVICE);
    myService.watchHelper(START_SERVICE);
  }
 else   if (preference.getKey().equals(WEIGHTED_RECENTS_PREFERENCE)) {
    editor.putBoolean(WEIGHTED_RECENTS_PREFERENCE,(Boolean)newValue);
    editor.apply();
    myService.execute(SERVICE_CLEAR_TASKS);
    myService.watchHelper(STOP_SERVICE);
    myService.watchHelper(START_SERVICE);
  }
 else   if (preference.getKey().equals(APPSNO_PREFERENCE)) {
    editor.putString(APPSNO_PREFERENCE,(String)newValue);
    editor.apply();
    myService.execute(SERVICE_DESTROY_NOTIFICATIONS);
    myService.watchHelper(STOP_SERVICE);
    myService.watchHelper(START_SERVICE);
  }
 else   if (preference.getKey().equals(PRIORITY_PREFERENCE)) {
    String mPriorityPreference=(String)newValue;
    editor.putString(PRIORITY_PREFERENCE,mPriorityPreference);
    PrefsFragment mAppearanceSettings=(PrefsFragment)mGetFragments.getFragmentByPosition(1);
    if (!mPriorityPreference.equals(PRIORITY_BOTTOM) && mAppearanceSettings.statusbar_icon_preference.getValue().equals(STATUSBAR_ICON_NONE)) {
      editor.putString(STATUSBAR_ICON_PREFERENCE,STATUSBAR_ICON_DEFAULT);
      mAppearanceSettings.statusbar_icon_preference.setValue(STATUSBAR_ICON_DEFAULT);
    }
    editor.apply();
    myService.execute(SERVICE_DESTROY_NOTIFICATIONS);
    myService.watchHelper(STOP_SERVICE);
    myService.watchHelper(START_SERVICE);
  }
 else   if (preference.getKey().equals(SECOND_ROW_PREFERENCE)) {
    setAppsnoSummary((Boolean)newValue,appnos_preference);
    editor.putBoolean(SECOND_ROW_PREFERENCE,(Boolean)newValue);
    editor.apply();
    myService.execute(SERVICE_DESTROY_NOTIFICATIONS);
    myService.watchHelper(STOP_SERVICE);
    myService.watchHelper(START_SERVICE);
  }
  return true;
}","@Override public boolean onPreferenceChange(final Preference preference,Object newValue){
  Tools.HangarLog(""String_Node_Str"" + preference.getKey() + ""String_Node_Str""+ newValue+ ""String_Node_Str"");
  final SharedPreferences prefs2=prefs.prefsGet();
  final SharedPreferences.Editor editor=prefs.editorGet();
  if (preference.getKey().equals(DIVIDER_PREFERENCE)) {
    editor.putBoolean(DIVIDER_PREFERENCE,(Boolean)newValue);
    editor.apply();
    myService.execute(SERVICE_CLEAR_TASKS);
    myService.watchHelper(STOP_SERVICE);
    myService.watchHelper(START_SERVICE);
  }
 else   if (preference.getKey().equals(ROW_DIVIDER_PREFERENCE)) {
    editor.putBoolean(ROW_DIVIDER_PREFERENCE,(Boolean)newValue);
    editor.apply();
    myService.execute(SERVICE_CLEAR_TASKS);
    myService.watchHelper(STOP_SERVICE);
    myService.watchHelper(START_SERVICE);
  }
 else   if (preference.getKey().equals(COLORIZE_PREFERENCE)) {
    editor.putBoolean(COLORIZE_PREFERENCE,(Boolean)newValue);
    editor.apply();
    myService.execute(SERVICE_CLEAR_TASKS);
    myService.watchHelper(STOP_SERVICE);
    myService.watchHelper(START_SERVICE);
  }
 else   if (preference.getKey().equals(STATUSBAR_ICON_PREFERENCE)) {
    final String mStatusBarIcon=(String)newValue;
    if (mStatusBarIcon.equals(STATUSBAR_ICON_NONE)) {
      new AlertDialog.Builder(myService.mContext).setTitle(R.string.alert_title_statusbar_icon_preference).setMessage(R.string.alert_message_statusbar_icon_preference).setPositiveButton(""String_Node_Str"",new DialogInterface.OnClickListener(){
        public void onClick(        DialogInterface dialog,        int whichButton){
          editor.putString(STATUSBAR_ICON_PREFERENCE,mStatusBarIcon);
          editor.putString(PRIORITY_PREFERENCE,Integer.toString(PRIORITY_BOTTOM));
          editor.apply();
          PrefsFragment mBehaviorSettings=(PrefsFragment)mGetFragments.getFragmentByPosition(0);
          mBehaviorSettings.priority_preference.setValue(Integer.toString(PRIORITY_BOTTOM));
          myService.execute(SERVICE_DESTROY_NOTIFICATIONS);
          myService.watchHelper(STOP_SERVICE);
          myService.watchHelper(START_SERVICE);
        }
      }
).setNegativeButton(""String_Node_Str"",new DialogInterface.OnClickListener(){
        public void onClick(        DialogInterface dialog,        int whichButton){
          statusbar_icon_preference.setValue(prefs2.getString(STATUSBAR_ICON_PREFERENCE,STATUSBAR_ICON_DEFAULT));
        }
      }
).show();
    }
 else {
      PrefsFragment mBehaviorSettings=(PrefsFragment)mGetFragments.getFragmentByPosition(0);
      if (mBehaviorSettings.priority_preference.getValue().equals(Integer.toString(PRIORITY_BOTTOM))) {
        editor.putString(PRIORITY_PREFERENCE,Integer.toString(PRIORITY_DEFAULT));
        mBehaviorSettings.priority_preference.setValue(Integer.toString(PRIORITY_DEFAULT));
      }
      editor.putString(STATUSBAR_ICON_PREFERENCE,(String)newValue);
      editor.apply();
      myService.execute(SERVICE_DESTROY_NOTIFICATIONS);
      myService.watchHelper(STOP_SERVICE);
      myService.watchHelper(START_SERVICE);
    }
  }
 else   if (preference.getKey().equals(ICON_COLOR_PREFERENCE)) {
    String hex=ColorPickerPreference.convertToARGB(Integer.valueOf(String.valueOf(newValue)));
    preference.setSummary(hex);
    int intHex=ColorPickerPreference.convertToColorInt(hex);
    editor.putInt(ICON_COLOR_PREFERENCE,intHex);
    editor.apply();
    myService.execute(SERVICE_CLEAR_TASKS);
    myService.watchHelper(STOP_SERVICE);
    myService.watchHelper(START_SERVICE);
  }
 else   if (preference.getKey().equals(ICON_SIZE_PREFERENCE)) {
    editor.putString(Settings.ICON_SIZE_PREFERENCE,(String)newValue);
    editor.apply();
    myService.execute(SERVICE_CLEAR_TASKS);
    myService.watchHelper(STOP_SERVICE);
    myService.watchHelper(START_SERVICE);
  }
 else   if (preference.getKey().equals(TOGGLE_PREFERENCE)) {
    editor.putBoolean(TOGGLE_PREFERENCE,(Boolean)newValue);
    editor.apply();
    myService.execute(SERVICE_DESTROY_NOTIFICATIONS);
    myService.watchHelper(STOP_SERVICE);
    myService.watchHelper(START_SERVICE);
  }
 else   if (preference.getKey().equals(BOOT_PREFERENCE)) {
    editor.putBoolean(BOOT_PREFERENCE,(Boolean)newValue);
    editor.apply();
  }
 else   if (preference.getKey().equals(WEIGHT_PRIORITY_PREFERENCE)) {
    editor.putString(WEIGHT_PRIORITY_PREFERENCE,(String)newValue);
    editor.apply();
    myService.execute(SERVICE_CLEAR_TASKS);
    myService.watchHelper(STOP_SERVICE);
    myService.watchHelper(START_SERVICE);
  }
 else   if (preference.getKey().equals(WEIGHTED_RECENTS_PREFERENCE)) {
    editor.putBoolean(WEIGHTED_RECENTS_PREFERENCE,(Boolean)newValue);
    editor.apply();
    myService.execute(SERVICE_CLEAR_TASKS);
    myService.watchHelper(STOP_SERVICE);
    myService.watchHelper(START_SERVICE);
  }
 else   if (preference.getKey().equals(APPSNO_PREFERENCE)) {
    editor.putString(APPSNO_PREFERENCE,(String)newValue);
    editor.apply();
    myService.execute(SERVICE_DESTROY_NOTIFICATIONS);
    myService.watchHelper(STOP_SERVICE);
    myService.watchHelper(START_SERVICE);
  }
 else   if (preference.getKey().equals(PRIORITY_PREFERENCE)) {
    String mPriorityPreference=(String)newValue;
    editor.putString(PRIORITY_PREFERENCE,mPriorityPreference);
    PrefsFragment mAppearanceSettings=(PrefsFragment)mGetFragments.getFragmentByPosition(1);
    if (!mPriorityPreference.equals(PRIORITY_BOTTOM) && mAppearanceSettings.statusbar_icon_preference.getValue().equals(STATUSBAR_ICON_NONE)) {
      editor.putString(STATUSBAR_ICON_PREFERENCE,STATUSBAR_ICON_DEFAULT);
      mAppearanceSettings.statusbar_icon_preference.setValue(STATUSBAR_ICON_DEFAULT);
    }
    editor.apply();
    myService.execute(SERVICE_DESTROY_NOTIFICATIONS);
    myService.watchHelper(STOP_SERVICE);
    myService.watchHelper(START_SERVICE);
  }
 else   if (preference.getKey().equals(SECOND_ROW_PREFERENCE)) {
    setAppsnoSummary((Boolean)newValue,appnos_preference);
    editor.putBoolean(SECOND_ROW_PREFERENCE,(Boolean)newValue);
    editor.apply();
    myService.execute(SERVICE_DESTROY_NOTIFICATIONS);
    myService.watchHelper(STOP_SERVICE);
    myService.watchHelper(START_SERVICE);
  }
  return true;
}",0.9768928220255654
80569,"@Override public void onActivityCreated(Bundle savedInstanceState){
  super.onActivityCreated(savedInstanceState);
  final int prefLayout=getArguments().getInt(""String_Node_Str"");
  setHasOptionsMenu(true);
  addPreferencesFromResource(prefLayout);
  final SharedPreferences prefs2=prefs.prefsGet();
  SharedPreferences.Editor editor=prefs.editorGet();
  try {
    divider_preference=(CheckBoxPreference)findPreference(DIVIDER_PREFERENCE);
    divider_preference.setChecked(prefs2.getBoolean(DIVIDER_PREFERENCE,DIVIDER_DEFAULT));
    divider_preference.setOnPreferenceChangeListener(changeListener);
    colorize_preference=(CheckBoxPreference)findPreference(COLORIZE_PREFERENCE);
    colorize_preference.setChecked(prefs2.getBoolean(COLORIZE_PREFERENCE,COLORIZE_DEFAULT));
    colorize_preference.setOnPreferenceChangeListener(changeListener);
    icon_color_preference=(ColorPickerPreference)findPreference(ICON_COLOR_PREFERENCE);
    int intColor=prefs2.getInt(ICON_COLOR_PREFERENCE,ICON_COLOR_DEFAULT);
    String hexColor=String.format(""String_Node_Str"",(intColor));
    icon_color_preference.setSummary(hexColor);
    icon_color_preference.setOnPreferenceChangeListener(changeListener);
    appnos_preference=(UpdatingListPreference)findPreference(APPSNO_PREFERENCE);
    appnos_preference.setValue(prefs2.getString(APPSNO_PREFERENCE,Integer.toString(APPSNO_DEFAULT)));
    appnos_preference.setOnPreferenceChangeListener(changeListener);
    statusbar_icon_preference=(UpdatingListPreference)findPreference(STATUSBAR_ICON_PREFERENCE);
    statusbar_icon_preference.setValue(prefs2.getString(STATUSBAR_ICON_PREFERENCE,STATUSBAR_ICON_DEFAULT));
    statusbar_icon_preference.setOnPreferenceChangeListener(changeListener);
    icon_size_preference=(UpdatingListPreference)findPreference(Settings.ICON_SIZE_PREFERENCE);
    icon_size_preference.setValue(prefs2.getString(Settings.ICON_SIZE_PREFERENCE,Integer.toString(Settings.ICON_SIZE_DEFAULT)));
    icon_size_preference.setOnPreferenceChangeListener(changeListener);
    icon_pack_preference=findPreference(Settings.ICON_PACK_PREFERENCE);
    icon_pack_preference.setSummary(getApplicationName(prefs2.getString(ICON_PACK_PREFERENCE,null)));
    iconPackUpdate=new IconPackUpdate(prefs2,icon_pack_preference);
    icon_pack_preference.setOnPreferenceClickListener(new Preference.OnPreferenceClickListener(){
      @Override public boolean onPreferenceClick(      Preference preference){
        IconPackHelper.pickIconPack(mContext);
        return false;
      }
    }
);
    second_row_preference=(CheckBoxPreference)findPreference(Settings.SECOND_ROW_PREFERENCE);
    Boolean secondRow=prefs2.getBoolean(SECOND_ROW_PREFERENCE,SECOND_ROW_DEFAULT);
    second_row_preference.setChecked(secondRow);
    setAppsnoSummary(secondRow,appnos_preference);
    second_row_preference.setOnPreferenceChangeListener(changeListener);
  }
 catch (  NullPointerException e) {
  }
  try {
    toggle_preference=(SwitchPreference)findPreference(TOGGLE_PREFERENCE);
    toggle_preference.setChecked(prefs2.getBoolean(TOGGLE_PREFERENCE,TOGGLE_DEFAULT));
    toggle_preference.setOnPreferenceChangeListener(changeListener);
    boot_preference=(SwitchPreference)findPreference(BOOT_PREFERENCE);
    boot_preference.setChecked(prefs2.getBoolean(BOOT_PREFERENCE,BOOT_DEFAULT));
    boot_preference.setOnPreferenceChangeListener(changeListener);
    weighted_recents_preference=(CheckBoxPreference)findPreference(WEIGHTED_RECENTS_PREFERENCE);
    weighted_recents_preference.setChecked(prefs2.getBoolean(WEIGHTED_RECENTS_PREFERENCE,WEIGHTED_RECENTS_DEFAULT));
    weighted_recents_preference.setOnPreferenceChangeListener(changeListener);
    weight_priority_preference=(UpdatingListPreference)findPreference(WEIGHT_PRIORITY_PREFERENCE);
    weight_priority_preference.setValue(prefs2.getString(WEIGHT_PRIORITY_PREFERENCE,Integer.toString(WEIGHT_PRIORITY_DEFAULT)));
    weight_priority_preference.setOnPreferenceChangeListener(changeListener);
    priority_preference=(UpdatingListPreference)findPreference(PRIORITY_PREFERENCE);
    priority_preference.setValue(prefs2.getString(PRIORITY_PREFERENCE,Integer.toString(PRIORITY_DEFAULT)));
    priority_preference.setOnPreferenceChangeListener(changeListener);
  }
 catch (  NullPointerException e) {
  }
}","@Override public void onActivityCreated(Bundle savedInstanceState){
  super.onActivityCreated(savedInstanceState);
  final int prefLayout=getArguments().getInt(""String_Node_Str"");
  setHasOptionsMenu(true);
  addPreferencesFromResource(prefLayout);
  final SharedPreferences prefs2=prefs.prefsGet();
  SharedPreferences.Editor editor=prefs.editorGet();
  try {
    divider_preference=(CheckBoxPreference)findPreference(DIVIDER_PREFERENCE);
    divider_preference.setChecked(prefs2.getBoolean(DIVIDER_PREFERENCE,DIVIDER_DEFAULT));
    divider_preference.setOnPreferenceChangeListener(changeListener);
    row_divider_preference=(CheckBoxPreference)findPreference(ROW_DIVIDER_PREFERENCE);
    row_divider_preference.setChecked(prefs2.getBoolean(ROW_DIVIDER_PREFERENCE,ROW_DIVIDER_DEFAULT));
    row_divider_preference.setOnPreferenceChangeListener(changeListener);
    colorize_preference=(CheckBoxPreference)findPreference(COLORIZE_PREFERENCE);
    colorize_preference.setChecked(prefs2.getBoolean(COLORIZE_PREFERENCE,COLORIZE_DEFAULT));
    colorize_preference.setOnPreferenceChangeListener(changeListener);
    icon_color_preference=(ColorPickerPreference)findPreference(ICON_COLOR_PREFERENCE);
    int intColor=prefs2.getInt(ICON_COLOR_PREFERENCE,ICON_COLOR_DEFAULT);
    String hexColor=String.format(""String_Node_Str"",(intColor));
    icon_color_preference.setSummary(hexColor);
    icon_color_preference.setOnPreferenceChangeListener(changeListener);
    appnos_preference=(UpdatingListPreference)findPreference(APPSNO_PREFERENCE);
    appnos_preference.setValue(prefs2.getString(APPSNO_PREFERENCE,Integer.toString(APPSNO_DEFAULT)));
    appnos_preference.setOnPreferenceChangeListener(changeListener);
    statusbar_icon_preference=(UpdatingListPreference)findPreference(STATUSBAR_ICON_PREFERENCE);
    statusbar_icon_preference.setValue(prefs2.getString(STATUSBAR_ICON_PREFERENCE,STATUSBAR_ICON_DEFAULT));
    statusbar_icon_preference.setOnPreferenceChangeListener(changeListener);
    icon_size_preference=(UpdatingListPreference)findPreference(Settings.ICON_SIZE_PREFERENCE);
    icon_size_preference.setValue(prefs2.getString(Settings.ICON_SIZE_PREFERENCE,Integer.toString(Settings.ICON_SIZE_DEFAULT)));
    icon_size_preference.setOnPreferenceChangeListener(changeListener);
    icon_pack_preference=findPreference(Settings.ICON_PACK_PREFERENCE);
    icon_pack_preference.setSummary(getApplicationName(prefs2.getString(ICON_PACK_PREFERENCE,null)));
    iconPackUpdate=new IconPackUpdate(prefs2,icon_pack_preference);
    icon_pack_preference.setOnPreferenceClickListener(new Preference.OnPreferenceClickListener(){
      @Override public boolean onPreferenceClick(      Preference preference){
        IconPackHelper.pickIconPack(mContext);
        return false;
      }
    }
);
    second_row_preference=(CheckBoxPreference)findPreference(Settings.SECOND_ROW_PREFERENCE);
    Boolean secondRow=prefs2.getBoolean(SECOND_ROW_PREFERENCE,SECOND_ROW_DEFAULT);
    second_row_preference.setChecked(secondRow);
    setAppsnoSummary(secondRow,appnos_preference);
    second_row_preference.setOnPreferenceChangeListener(changeListener);
  }
 catch (  NullPointerException e) {
  }
  try {
    toggle_preference=(SwitchPreference)findPreference(TOGGLE_PREFERENCE);
    toggle_preference.setChecked(prefs2.getBoolean(TOGGLE_PREFERENCE,TOGGLE_DEFAULT));
    toggle_preference.setOnPreferenceChangeListener(changeListener);
    boot_preference=(SwitchPreference)findPreference(BOOT_PREFERENCE);
    boot_preference.setChecked(prefs2.getBoolean(BOOT_PREFERENCE,BOOT_DEFAULT));
    boot_preference.setOnPreferenceChangeListener(changeListener);
    weighted_recents_preference=(CheckBoxPreference)findPreference(WEIGHTED_RECENTS_PREFERENCE);
    weighted_recents_preference.setChecked(prefs2.getBoolean(WEIGHTED_RECENTS_PREFERENCE,WEIGHTED_RECENTS_DEFAULT));
    weighted_recents_preference.setOnPreferenceChangeListener(changeListener);
    weight_priority_preference=(UpdatingListPreference)findPreference(WEIGHT_PRIORITY_PREFERENCE);
    weight_priority_preference.setValue(prefs2.getString(WEIGHT_PRIORITY_PREFERENCE,Integer.toString(WEIGHT_PRIORITY_DEFAULT)));
    weight_priority_preference.setOnPreferenceChangeListener(changeListener);
    priority_preference=(UpdatingListPreference)findPreference(PRIORITY_PREFERENCE);
    priority_preference.setValue(prefs2.getString(PRIORITY_PREFERENCE,Integer.toString(PRIORITY_DEFAULT)));
    priority_preference.setOnPreferenceChangeListener(changeListener);
  }
 catch (  NullPointerException e) {
  }
}",0.9702522339101912
80570,"public void createNotification(ArrayList<Tools.TaskInfo> taskList){
  String taskPackage=this.getPackageName();
  Context mContext=getApplicationContext();
  int contLayout=prefs.getBoolean(Settings.DIVIDER_PREFERENCE,Settings.DIVIDER_DEFAULT) ? getResources().getIdentifier(""String_Node_Str"",""String_Node_Str"",taskPackage) : getResources().getIdentifier(""String_Node_Str"",""String_Node_Str"",taskPackage);
  int rowLayout=prefs.getBoolean(Settings.DIVIDER_PREFERENCE,Settings.DIVIDER_DEFAULT) ? getResources().getIdentifier(""String_Node_Str"",""String_Node_Str"",taskPackage) : getResources().getIdentifier(""String_Node_Str"",""String_Node_Str"",taskPackage);
  int imageButtonLayout=getResources().getIdentifier(""String_Node_Str"",""String_Node_Str"",taskPackage);
  int imageContLayout=getResources().getIdentifier(""String_Node_Str"",""String_Node_Str"",taskPackage);
  RemoteViews customNotifView=new RemoteViews(taskPackage,contLayout);
  RemoteViews customNotifBigView=customNotifView;
  AppDrawer appDrawer=new AppDrawer(taskPackage);
  appDrawer.createRow(rowLayout,R.id.notifRow);
  appDrawer.setImageLayouts(imageButtonLayout,imageContLayout);
  appDrawer.setPrefs(prefs);
  appDrawer.setContext(mContext);
  int maxButtons;
  int setPriority=Integer.parseInt(prefs.getString(Settings.PRIORITY_PREFERENCE,Integer.toString(Settings.PRIORITY_DEFAULT)));
  if (taskList.size() < numOfApps) {
    maxButtons=taskList.size();
  }
 else {
    maxButtons=numOfApps;
  }
  if (taskList.size() <= numOfApps) {
    Tools.HangarLog(""String_Node_Str"");
    secondRow=false;
  }
  Tools.HangarLog(""String_Node_Str"" + taskList.size() + ""String_Node_Str""+ numOfApps+ ""String_Node_Str""+ maxButtons);
  int filledConts=0;
  boolean filledSecondRow=false;
  int iconSize=Integer.parseInt(prefs.getString(Settings.ICON_SIZE_PREFERENCE,Integer.toString(Settings.ICON_SIZE_DEFAULT)));
  int itemLayout=R.layout.notification_item;
  if (iconSize == ICON_SIZE_SMALL) {
    itemLayout=R.layout.notification_item_small;
  }
 else   if (iconSize == ICON_SIZE_LARGE) {
    itemLayout=R.layout.notification_item_large;
  }
  for (int i=0; i <= taskList.size(); i++) {
    if (filledConts == maxButtons) {
      if (filledSecondRow) {
        filledSecondRow=false;
        customNotifBigView=customNotifView;
        customNotifBigView.addView(R.id.notifContainer,appDrawer.getRow());
        break;
      }
 else {
        customNotifView.addView(R.id.notifContainer,appDrawer.getRow());
        filledSecondRow=true;
        filledConts=0;
        appDrawer.createRow(rowLayout,R.id.notifRow);
        appDrawer.setImageLayouts(imageButtonLayout,imageContLayout);
      }
    }
    if (appDrawer.newItem(taskList.get(i),itemLayout)) {
      appDrawer.addItem();
      filledConts++;
    }
  }
  if (filledSecondRow && secondRow) {
    Tools.HangarLog(""String_Node_Str"");
    customNotifBigView=customNotifView;
    customNotifBigView.addView(R.id.notifContainer,appDrawer.getRow());
  }
  String mIcon=prefs.getString(Settings.STATUSBAR_ICON_PREFERENCE,Settings.STATUSBAR_ICON_DEFAULT);
  int smallIcon=iconMap.get(Settings.STATUSBAR_ICON_WHITE_WARM);
  try {
    smallIcon=iconMap.get(mIcon);
  }
 catch (  NullPointerException e) {
  }
  Notification notification=new Notification.Builder(WatchfulService.this).setContentTitle(getResources().getString(R.string.app_name)).setContentText(getResources().getString(R.string.app_name)).setSmallIcon(smallIcon).setContent(customNotifView).setOngoing(true).setPriority(setPriority).build();
  if (secondRow) {
    notification.bigContentView=customNotifBigView;
  }
  startForeground(1337,notification);
  isNotificationRunning=true;
}","public void createNotification(ArrayList<Tools.TaskInfo> taskList){
  String taskPackage=this.getPackageName();
  Context mContext=getApplicationContext();
  int contLayout=prefs.getBoolean(Settings.ROW_DIVIDER_PREFERENCE,Settings.ROW_DIVIDER_DEFAULT) ? getResources().getIdentifier(""String_Node_Str"",""String_Node_Str"",taskPackage) : getResources().getIdentifier(""String_Node_Str"",""String_Node_Str"",taskPackage);
  int rowLayout=prefs.getBoolean(Settings.DIVIDER_PREFERENCE,Settings.DIVIDER_DEFAULT) ? getResources().getIdentifier(""String_Node_Str"",""String_Node_Str"",taskPackage) : getResources().getIdentifier(""String_Node_Str"",""String_Node_Str"",taskPackage);
  int imageButtonLayout=getResources().getIdentifier(""String_Node_Str"",""String_Node_Str"",taskPackage);
  int imageContLayout=getResources().getIdentifier(""String_Node_Str"",""String_Node_Str"",taskPackage);
  RemoteViews customNotifView=new RemoteViews(taskPackage,contLayout);
  RemoteViews customNotifBigView=customNotifView;
  AppDrawer appDrawer=new AppDrawer(taskPackage);
  appDrawer.createRow(rowLayout,R.id.notifRow);
  appDrawer.setImageLayouts(imageButtonLayout,imageContLayout);
  appDrawer.setPrefs(prefs);
  appDrawer.setContext(mContext);
  int maxButtons;
  int setPriority=Integer.parseInt(prefs.getString(Settings.PRIORITY_PREFERENCE,Integer.toString(Settings.PRIORITY_DEFAULT)));
  if (taskList.size() < numOfApps) {
    maxButtons=taskList.size();
  }
 else {
    maxButtons=numOfApps;
  }
  if (taskList.size() <= numOfApps) {
    Tools.HangarLog(""String_Node_Str"");
    secondRow=false;
  }
  Tools.HangarLog(""String_Node_Str"" + taskList.size() + ""String_Node_Str""+ numOfApps+ ""String_Node_Str""+ maxButtons);
  int filledConts=0;
  boolean filledSecondRow=false;
  int iconSize=Integer.parseInt(prefs.getString(Settings.ICON_SIZE_PREFERENCE,Integer.toString(Settings.ICON_SIZE_DEFAULT)));
  int itemLayout=R.layout.notification_item;
  if (iconSize == ICON_SIZE_SMALL) {
    itemLayout=R.layout.notification_item_small;
  }
 else   if (iconSize == ICON_SIZE_LARGE) {
    itemLayout=R.layout.notification_item_large;
  }
  customNotifBigView.removeAllViews(R.id.notifContainer);
  for (int i=0; i <= taskList.size(); i++) {
    if (filledConts == maxButtons) {
      if (filledSecondRow) {
        filledSecondRow=false;
        customNotifBigView=customNotifView;
        customNotifBigView.addView(R.id.notifContainer,appDrawer.getRow());
        break;
      }
 else {
        customNotifView.addView(R.id.notifContainer,appDrawer.getRow());
        filledSecondRow=true;
        filledConts=0;
        appDrawer.createRow(rowLayout,R.id.notifRow);
        appDrawer.setImageLayouts(imageButtonLayout,imageContLayout);
      }
    }
    if (appDrawer.newItem(taskList.get(i),itemLayout)) {
      appDrawer.addItem();
      filledConts++;
    }
  }
  if (filledSecondRow && secondRow) {
    Tools.HangarLog(""String_Node_Str"");
    customNotifBigView=customNotifView;
    customNotifBigView.addView(R.id.notifContainer,appDrawer.getRow());
  }
  String mIcon=prefs.getString(Settings.STATUSBAR_ICON_PREFERENCE,Settings.STATUSBAR_ICON_DEFAULT);
  int smallIcon=iconMap.get(Settings.STATUSBAR_ICON_WHITE_WARM);
  try {
    smallIcon=iconMap.get(mIcon);
  }
 catch (  NullPointerException e) {
  }
  Notification notification=new Notification.Builder(WatchfulService.this).setContentTitle(getResources().getString(R.string.app_name)).setContentText(getResources().getString(R.string.app_name)).setSmallIcon(smallIcon).setContent(customNotifView).setOngoing(true).setPriority(setPriority).build();
  if (secondRow) {
    notification.bigContentView=customNotifBigView;
  }
  startForeground(1337,notification);
  isNotificationRunning=true;
}",0.991042345276873
80571,"@Override public void onReceive(Context context,Intent intent){
  Tools.HangarLog(""String_Node_Str"");
  if (mContext == null)   mContext=context;
  AppWidgetManager mgr=AppWidgetManager.getInstance(context);
  int[] ids=mgr.getAppWidgetIds(new ComponentName(context,AppsWidget.class));
  for (  int id : ids) {
    Tools.HangarLog(""String_Node_Str"" + id);
    try {
      Bundle options=mgr.getAppWidgetOptions(id);
      updateAppWidget(context,mgr,id,options);
    }
 catch (    NullPointerException e) {
      e.printStackTrace();
      Tools.HangarLog(""String_Node_Str"");
    }
  }
  super.onReceive(context,intent);
}","@Override public void onReceive(Context context,Intent intent){
  Tools.HangarLog(""String_Node_Str"" + this.getClass().getCanonicalName() + ""String_Node_Str"");
  if (mContext == null)   mContext=context;
  AppWidgetManager mgr=AppWidgetManager.getInstance(context);
  int[] ids=mgr.getAppWidgetIds(new ComponentName(context,AppsWidget.class));
  for (  int id : ids) {
    Tools.HangarLog(""String_Node_Str"" + id);
    try {
      Bundle options=mgr.getAppWidgetOptions(id);
      updateAppWidget(context,mgr,id,options);
    }
 catch (    NullPointerException e) {
      e.printStackTrace();
      Tools.HangarLog(""String_Node_Str"");
    }
  }
  super.onReceive(context,intent);
}",0.9561875480399692
80572,"@Override public void onUpdate(Context context,AppWidgetManager appWidgetManager,int[] appWidgetIds){
  Tools.HangarLog(""String_Node_Str"");
  mContext=context;
  Intent intent=new Intent(context,WatchfulService.class);
  context.startService(intent);
}","@Override public void onUpdate(Context context,AppWidgetManager appWidgetManager,int[] appWidgetIds){
  Tools.HangarLog(""String_Node_Str"" + this.getClass().getCanonicalName() + ""String_Node_Str"");
  mContext=context;
  Intent intent=new Intent(context,WatchfulService.class);
  context.startService(intent);
}",0.8983957219251337
80573,"static void updateAppWidget(Context context,AppWidgetManager appWidgetManager,int appWidgetId,Bundle options){
  Tools.HangarLog(""String_Node_Str"");
  prefs=new PrefsGet(context.getSharedPreferences(""String_Node_Str"",Context.MODE_PRIVATE));
  SharedPreferences mPrefs=prefs.prefsGet();
  int rowLayout=R.layout.apps_widget_row;
  int itemLayout=R.layout.apps_widget_item;
  int itemHeight=ICON_MEDIUM_HEIGHT;
  int itemWidth=ICON_MEDIUM_WIDTH;
  int iconSize=Integer.parseInt(mPrefs.getString(Settings.ICON_SIZE_PREFERENCE,Integer.toString(Settings.ICON_SIZE_DEFAULT)));
  int mGravity=Integer.parseInt(mPrefs.getString(Settings.ALIGNMENT_PREFERENCE,Integer.toString(Settings.ALIGNMENT_DEFAULT)));
switch (iconSize) {
case SMALL_ICONS:
    rowLayout=R.layout.apps_widget_row_small;
  itemHeight=ICON_SMALL_HEIGHT;
itemWidth=ICON_SMALL_WIDTH;
break;
case LARGE_ICONS:
rowLayout=R.layout.apps_widget_row_large;
itemHeight=ICON_LARGE_HEIGHT;
itemWidth=ICON_LARGE_WIDTH;
break;
}
boolean appsNoByWidgetSize=mPrefs.getBoolean(Settings.APPS_BY_WIDGET_SIZE_PREFERENCE,Settings.APPS_BY_WIDGET_SIZE_DEFAULT);
int appsNoH;
int appsNoW;
boolean autoHeight=true;
Tools.HangarLog(""String_Node_Str"" + options.getInt(AppWidgetManager.OPTION_APPWIDGET_MIN_HEIGHT));
Tools.HangarLog(""String_Node_Str"" + options.getInt(AppWidgetManager.OPTION_APPWIDGET_MAX_HEIGHT));
Tools.HangarLog(""String_Node_Str"" + options.getInt(AppWidgetManager.OPTION_APPWIDGET_MIN_WIDTH));
Tools.HangarLog(""String_Node_Str"" + options.getInt(AppWidgetManager.OPTION_APPWIDGET_MAX_WIDTH));
appsNoH=findDimensions(options.getInt(AppWidgetManager.OPTION_APPWIDGET_MAX_HEIGHT),itemHeight);
appsNoW=findDimensions(options.getInt(AppWidgetManager.OPTION_APPWIDGET_MIN_WIDTH),itemWidth);
Tools.HangarLog(""String_Node_Str"" + appsNoH + ""String_Node_Str""+ appsNoW);
if (appsNoH == 0) {
appsNoH=1;
autoHeight=false;
}
if (context.getResources().getConfiguration().orientation == Configuration.ORIENTATION_LANDSCAPE) {
float widgetHeight=options.getInt(AppWidgetManager.OPTION_APPWIDGET_MIN_HEIGHT);
appsNoH=findDimensions((int)widgetHeight,itemHeight);
int origWidgetHeight=appsNoH;
if (iconSize > SMALL_ICONS) {
if (iconSize == LARGE_ICONS) {
appsNoH=findDimensions(options.getInt(AppWidgetManager.OPTION_APPWIDGET_MIN_HEIGHT),itemHeight);
if (appsNoH == 0 && widgetHeight > 0) {
Tools.HangarLog(""String_Node_Str"");
rowLayout=R.layout.apps_widget_row;
itemWidth=ICON_MEDIUM_WIDTH;
}
}
if (itemWidth == ICON_MEDIUM_WIDTH) {
appsNoH=findDimensions(options.getInt(AppWidgetManager.OPTION_APPWIDGET_MIN_HEIGHT),ICON_MEDIUM_HEIGHT);
if (appsNoH == 0 && widgetHeight > 0) {
Tools.HangarLog(""String_Node_Str"");
rowLayout=R.layout.apps_widget_row_small;
itemWidth=ICON_SMALL_WIDTH;
mGravity=Settings.ALIGNMENT_DEFAULT;
}
}
}
if (origWidgetHeight == 0) {
appsNoH=1;
autoHeight=false;
}
appsNoW=findDimensions(options.getInt(AppWidgetManager.OPTION_APPWIDGET_MAX_WIDTH),itemWidth);
if (appsNoByWidgetSize && appsNoW > 0) {
Tools.HangarLog(""String_Node_Str"" + appsNoW);
}
 else {
appsNoW=Integer.parseInt(mPrefs.getString(Settings.STATS_WIDGET_APPSNO_LS_PREFERENCE,Integer.toString(Settings.APPS_WIDGET_APPSNO_LS_DEFAULT)));
}
Tools.HangarLog(""String_Node_Str"");
}
 else {
if (appsNoByWidgetSize && appsNoW > 0) {
Tools.HangarLog(""String_Node_Str"" + appsNoH);
}
 else {
appsNoW=Integer.parseInt(mPrefs.getString(Settings.STATS_WIDGET_APPSNO_PREFERENCE,Integer.toString(Settings.APPS_WIDGET_APPSNO_DEFAULT)));
}
}
int getBackgroundColor=mPrefs.getInt(Settings.BACKGROUND_COLOR_PREFERENCE,Settings.BACKGROUND_COLOR_DEFAULT);
RemoteViews views=new RemoteViews(context.getPackageName(),R.layout.apps_widget);
views.setInt(R.id.viewCont,""String_Node_Str"",mGravity);
if (db == null) {
db=new TasksDataSource(context);
db.open();
}
int gridSize=(appsNoH * appsNoW);
int numOfIcons=(appsNoH * appsNoW > 35) ? 35 : (appsNoH * appsNoW);
if (autoHeight && !appsNoByWidgetSize) {
numOfIcons=appsNoW;
}
int queueSize=(Math.ceil(numOfIcons * 1.2f)) < 14 ? 14 : (int)Math.ceil(numOfIcons * 1.2f);
String taskPackage=context.getPackageName();
boolean weightedRecents=mPrefs.getBoolean(Settings.WEIGHTED_RECENTS_PREFERENCE,Settings.WEIGHTED_RECENTS_DEFAULT);
ArrayList<Tools.TaskInfo> appList=Tools.buildTaskList(context,db,queueSize,weightedRecents,true);
int imageButtonLayout=context.getResources().getIdentifier(""String_Node_Str"",""String_Node_Str"",taskPackage);
int imageContLayout=context.getResources().getIdentifier(""String_Node_Str"",""String_Node_Str"",taskPackage);
AppDrawer appDrawer=new AppDrawer(taskPackage);
appDrawer.createRow(rowLayout,R.id.viewRow);
appDrawer.setImageLayouts(imageButtonLayout,imageContLayout);
appDrawer.setPrefs(mPrefs);
appDrawer.setContext(mContext);
appDrawer.setRowBackgroundColor(getBackgroundColor);
if (autoHeight && !appsNoByWidgetSize) {
appsNoW=(int)Math.ceil((double)appsNoW / appsNoH);
Tools.HangarLog(""String_Node_Str"" + appsNoW);
}
int filledConts=0;
int filledRows=1;
Tools.HangarLog(""String_Node_Str"" + appsNoW + ""String_Node_Str""+ appList.size()+ ""String_Node_Str""+ numOfIcons);
views.removeAllViews(R.id.viewCont);
for (int i=0; i <= gridSize; i++) {
if (filledConts == appsNoW || i == gridSize) {
Tools.HangarLog(""String_Node_Str"" + i + ""String_Node_Str""+ filledConts);
views.addView(R.id.viewCont,appDrawer.getRow());
if (i >= numOfIcons && !appsNoByWidgetSize) break;
boolean lineBreak=(appsNoByWidgetSize && appList.size() > i) || (!appsNoByWidgetSize && numOfIcons > i);
if (filledRows < appsNoH && filledConts < numOfIcons && lineBreak) {
appDrawer.createRow(rowLayout,R.id.viewRow);
appDrawer.setRowBackgroundColor(getBackgroundColor);
filledConts=0;
filledRows++;
}
 else {
break;
}
}
Tools.TaskInfo newItemTask;
if (i >= appList.size()) {
newItemTask=new Tools.TaskInfo(null);
}
 else {
newItemTask=appList.get(i);
}
boolean newItem=appDrawer.newItem(newItemTask,itemLayout,i);
if (!newItem) {
numOfIcons++;
continue;
}
filledConts+=1;
if (i >= numOfIcons || i >= appList.size()) {
appDrawer.setItemVisibility(View.INVISIBLE);
appDrawer.addItem();
continue;
}
appDrawer.addItem();
}
appWidgetManager.updateAppWidget(appWidgetId,views);
}","static void updateAppWidget(Context context,AppWidgetManager appWidgetManager,int appWidgetId,Bundle options){
  Tools.HangarLog(""String_Node_Str"");
  prefs=new PrefsGet(context.getSharedPreferences(""String_Node_Str"",Context.MODE_PRIVATE));
  SharedPreferences mPrefs=prefs.prefsGet();
  int rowLayout=R.layout.apps_widget_row;
  int itemLayout=R.layout.apps_widget_item;
  int itemHeight=ICON_MEDIUM_HEIGHT;
  int itemWidth=ICON_MEDIUM_WIDTH;
  int iconSize=Integer.parseInt(mPrefs.getString(Settings.ICON_SIZE_PREFERENCE,Integer.toString(Settings.ICON_SIZE_DEFAULT)));
  int mGravity=Integer.parseInt(mPrefs.getString(Settings.ALIGNMENT_PREFERENCE,Integer.toString(Settings.ALIGNMENT_DEFAULT)));
switch (iconSize) {
case SMALL_ICONS:
    rowLayout=R.layout.apps_widget_row_small;
  itemHeight=ICON_SMALL_HEIGHT;
itemWidth=ICON_SMALL_WIDTH;
break;
case LARGE_ICONS:
rowLayout=R.layout.apps_widget_row_large;
itemHeight=ICON_LARGE_HEIGHT;
itemWidth=ICON_LARGE_WIDTH;
break;
}
boolean appsNoByWidgetSize=mPrefs.getBoolean(Settings.APPS_BY_WIDGET_SIZE_PREFERENCE,Settings.APPS_BY_WIDGET_SIZE_DEFAULT);
int appsNoH;
int appsNoW;
boolean autoHeight=true;
Tools.HangarLog(""String_Node_Str"" + options.getInt(AppWidgetManager.OPTION_APPWIDGET_MIN_HEIGHT));
Tools.HangarLog(""String_Node_Str"" + options.getInt(AppWidgetManager.OPTION_APPWIDGET_MAX_HEIGHT));
Tools.HangarLog(""String_Node_Str"" + options.getInt(AppWidgetManager.OPTION_APPWIDGET_MIN_WIDTH));
Tools.HangarLog(""String_Node_Str"" + options.getInt(AppWidgetManager.OPTION_APPWIDGET_MAX_WIDTH));
appsNoH=findDimensions(options.getInt(AppWidgetManager.OPTION_APPWIDGET_MAX_HEIGHT),itemHeight);
appsNoW=findDimensions(options.getInt(AppWidgetManager.OPTION_APPWIDGET_MIN_WIDTH),itemWidth);
Tools.HangarLog(""String_Node_Str"" + appsNoH + ""String_Node_Str""+ appsNoW);
if (appsNoH == 0) {
appsNoH=1;
autoHeight=false;
}
if (context.getResources().getConfiguration().orientation == Configuration.ORIENTATION_LANDSCAPE) {
float widgetHeight=options.getInt(AppWidgetManager.OPTION_APPWIDGET_MIN_HEIGHT);
appsNoH=findDimensions((int)widgetHeight,itemHeight);
int origWidgetHeight=appsNoH;
if (iconSize > SMALL_ICONS) {
if (iconSize == LARGE_ICONS) {
appsNoH=findDimensions(options.getInt(AppWidgetManager.OPTION_APPWIDGET_MIN_HEIGHT),itemHeight);
if (appsNoH == 0 && widgetHeight > 0) {
Tools.HangarLog(""String_Node_Str"");
rowLayout=R.layout.apps_widget_row;
itemWidth=ICON_MEDIUM_WIDTH;
}
}
if (itemWidth == ICON_MEDIUM_WIDTH) {
appsNoH=findDimensions(options.getInt(AppWidgetManager.OPTION_APPWIDGET_MIN_HEIGHT),ICON_MEDIUM_HEIGHT);
if (appsNoH == 0 && widgetHeight > 0) {
Tools.HangarLog(""String_Node_Str"");
rowLayout=R.layout.apps_widget_row_small;
itemWidth=ICON_SMALL_WIDTH;
mGravity=Settings.ALIGNMENT_DEFAULT;
}
}
}
if (origWidgetHeight == 0) {
appsNoH=1;
autoHeight=false;
}
appsNoW=findDimensions(options.getInt(AppWidgetManager.OPTION_APPWIDGET_MAX_WIDTH),itemWidth);
if (appsNoByWidgetSize && appsNoW > 0) {
Tools.HangarLog(""String_Node_Str"" + appsNoW);
}
 else {
appsNoW=Integer.parseInt(mPrefs.getString(Settings.STATS_WIDGET_APPSNO_LS_PREFERENCE,Integer.toString(Settings.APPS_WIDGET_APPSNO_LS_DEFAULT)));
}
Tools.HangarLog(""String_Node_Str"");
}
 else {
if (appsNoByWidgetSize && appsNoW > 0) {
Tools.HangarLog(""String_Node_Str"" + appsNoH);
}
 else {
appsNoW=Integer.parseInt(mPrefs.getString(Settings.STATS_WIDGET_APPSNO_PREFERENCE,Integer.toString(Settings.APPS_WIDGET_APPSNO_DEFAULT)));
}
}
int getBackgroundColor=mPrefs.getInt(Settings.BACKGROUND_COLOR_PREFERENCE,Settings.BACKGROUND_COLOR_DEFAULT);
RemoteViews views=new RemoteViews(context.getPackageName(),R.layout.apps_widget);
views.setInt(R.id.viewCont,""String_Node_Str"",mGravity);
if (db == null) {
db=new TasksDataSource(context);
db.open();
}
int gridSize=(appsNoH * appsNoW);
int numOfIcons=(appsNoH * appsNoW > Settings.TASKLIST_QUEUE_SIZE) ? Settings.TASKLIST_QUEUE_SIZE : (appsNoH * appsNoW);
if (autoHeight && !appsNoByWidgetSize) {
numOfIcons=appsNoW;
}
int queueSize=(Math.ceil(numOfIcons * 1.2f)) < Settings.APPLIST_QUEUE_SIZE ? Settings.APPLIST_QUEUE_SIZE : (int)Math.ceil(numOfIcons * 1.2f);
String taskPackage=context.getPackageName();
boolean weightedRecents=mPrefs.getBoolean(Settings.WEIGHTED_RECENTS_PREFERENCE,Settings.WEIGHTED_RECENTS_DEFAULT);
ArrayList<Tools.TaskInfo> appList=Tools.buildTaskList(context,db,queueSize,weightedRecents,true);
int imageButtonLayout=context.getResources().getIdentifier(""String_Node_Str"",""String_Node_Str"",taskPackage);
int imageContLayout=context.getResources().getIdentifier(""String_Node_Str"",""String_Node_Str"",taskPackage);
AppDrawer appDrawer=new AppDrawer(taskPackage);
appDrawer.createRow(rowLayout,R.id.viewRow);
appDrawer.setImageLayouts(imageButtonLayout,imageContLayout);
appDrawer.setPrefs(mPrefs);
appDrawer.setContext(mContext);
appDrawer.setRowBackgroundColor(getBackgroundColor);
if (autoHeight && !appsNoByWidgetSize) {
appsNoW=(int)Math.ceil((double)appsNoW / appsNoH);
Tools.HangarLog(""String_Node_Str"" + appsNoW);
}
int filledConts=0;
int filledRows=1;
Tools.HangarLog(""String_Node_Str"" + appsNoW + ""String_Node_Str""+ appList.size()+ ""String_Node_Str""+ numOfIcons);
views.removeAllViews(R.id.viewCont);
for (int i=0; i <= gridSize; i++) {
if (filledConts == appsNoW || i == gridSize) {
Tools.HangarLog(""String_Node_Str"" + i + ""String_Node_Str""+ filledConts);
views.addView(R.id.viewCont,appDrawer.getRow());
if (i >= numOfIcons && !appsNoByWidgetSize) break;
boolean lineBreak=(appsNoByWidgetSize && appList.size() > i) || (!appsNoByWidgetSize && numOfIcons > i);
if (filledRows < appsNoH && filledConts < numOfIcons && lineBreak) {
appDrawer.createRow(rowLayout,R.id.viewRow);
appDrawer.setRowBackgroundColor(getBackgroundColor);
filledConts=0;
filledRows++;
}
 else {
break;
}
}
Tools.TaskInfo newItemTask;
if (i >= appList.size()) {
newItemTask=new Tools.TaskInfo(null);
}
 else {
newItemTask=appList.get(i);
}
boolean newItem=appDrawer.newItem(newItemTask,itemLayout,i);
if (!newItem) {
numOfIcons++;
continue;
}
filledConts+=1;
if (i >= numOfIcons || i >= appList.size()) {
appDrawer.setItemVisibility(View.INVISIBLE);
appDrawer.addItem();
continue;
}
appDrawer.addItem();
}
appWidgetManager.updateAppWidget(appWidgetId,views);
}",0.9904345006485084
80574,"@Override public void onClick(View v){
  int mAppWidgetId;
  savePrefs();
  if (extras != null) {
    mAppWidgetId=extras.getInt(AppWidgetManager.EXTRA_APPWIDGET_ID,AppWidgetManager.INVALID_APPWIDGET_ID);
    Intent resultValue=new Intent();
    resultValue.putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID,mAppWidgetId);
    getActivity().setResult(RESULT_OK,resultValue);
    Toast.makeText(mContext,R.string.reconfigure_reminder,Toast.LENGTH_LONG).show();
    getActivity().finish();
  }
 else {
    Tools.updateWidget(mContext);
    getActivity().finish();
  }
}","@Override public void onClick(View v){
  int mAppWidgetId;
  savePrefs();
  TasksDataSource db=new TasksDataSource(mContext);
  db.open();
  Tools.reorderWidgetTasks(db,mContext);
  db.close();
  if (extras != null) {
    mAppWidgetId=extras.getInt(AppWidgetManager.EXTRA_APPWIDGET_ID,AppWidgetManager.INVALID_APPWIDGET_ID);
    Intent resultValue=new Intent();
    resultValue.putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID,mAppWidgetId);
    getActivity().setResult(RESULT_OK,resultValue);
    Toast.makeText(mContext,R.string.reconfigure_reminder,Toast.LENGTH_LONG).show();
    getActivity().finish();
  }
 else {
    Tools.updateWidget(mContext);
    getActivity().finish();
  }
}",0.9035369774919614
80575,"@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  LinearLayout v=(LinearLayout)super.onCreateView(inflater,container,savedInstanceState);
  ViewGroup.LayoutParams params=new ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,ViewGroup.LayoutParams.WRAP_CONTENT);
  v.setLayoutParams(params);
  LinearLayout footer=(LinearLayout)inflater.inflate(R.layout.widget_footer,v,false);
  footer.setLayoutParams(new AbsListView.LayoutParams(AbsListView.LayoutParams.MATCH_PARENT,AbsListView.LayoutParams.WRAP_CONTENT));
  Button createButton=(Button)footer.findViewById(R.id.placementButton);
  if (extras == null) {
    createButton.setText(R.string.reconfigure_button_name);
  }
 else {
    createButton.setText(R.string.button_name);
  }
  createButton.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      int mAppWidgetId;
      savePrefs();
      if (extras != null) {
        mAppWidgetId=extras.getInt(AppWidgetManager.EXTRA_APPWIDGET_ID,AppWidgetManager.INVALID_APPWIDGET_ID);
        Intent resultValue=new Intent();
        resultValue.putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID,mAppWidgetId);
        getActivity().setResult(RESULT_OK,resultValue);
        Toast.makeText(mContext,R.string.reconfigure_reminder,Toast.LENGTH_LONG).show();
        getActivity().finish();
      }
 else {
        Tools.updateWidget(mContext);
        getActivity().finish();
      }
    }
  }
);
  v.addView(footer);
  return v;
}","@Override public View onCreateView(LayoutInflater inflater,ViewGroup container,Bundle savedInstanceState){
  LinearLayout v=(LinearLayout)super.onCreateView(inflater,container,savedInstanceState);
  ViewGroup.LayoutParams params=new ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT,ViewGroup.LayoutParams.WRAP_CONTENT);
  v.setLayoutParams(params);
  LinearLayout footer=(LinearLayout)inflater.inflate(R.layout.widget_footer,v,false);
  footer.setLayoutParams(new AbsListView.LayoutParams(AbsListView.LayoutParams.MATCH_PARENT,AbsListView.LayoutParams.WRAP_CONTENT));
  Button createButton=(Button)footer.findViewById(R.id.placementButton);
  if (extras == null) {
    createButton.setText(R.string.reconfigure_button_name);
  }
 else {
    createButton.setText(R.string.button_name);
  }
  createButton.setOnClickListener(new View.OnClickListener(){
    @Override public void onClick(    View v){
      int mAppWidgetId;
      savePrefs();
      TasksDataSource db=new TasksDataSource(mContext);
      db.open();
      Tools.reorderWidgetTasks(db,mContext);
      db.close();
      if (extras != null) {
        mAppWidgetId=extras.getInt(AppWidgetManager.EXTRA_APPWIDGET_ID,AppWidgetManager.INVALID_APPWIDGET_ID);
        Intent resultValue=new Intent();
        resultValue.putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID,mAppWidgetId);
        getActivity().setResult(RESULT_OK,resultValue);
        Toast.makeText(mContext,R.string.reconfigure_reminder,Toast.LENGTH_LONG).show();
        getActivity().finish();
      }
 else {
        Tools.updateWidget(mContext);
        getActivity().finish();
      }
    }
  }
);
  v.addView(footer);
  return v;
}",0.95742016280526
80576,"@Override public void onReceive(Context context,Intent intent){
  Tools.HangarLog(""String_Node_Str"");
  if (mContext == null)   mContext=context;
  AppWidgetManager mgr=AppWidgetManager.getInstance(context);
  int[] ids=mgr.getAppWidgetIds(new ComponentName(context,StatsWidget.class));
  for (  int id : ids) {
    Tools.HangarLog(""String_Node_Str"" + id);
    try {
      Bundle options=mgr.getAppWidgetOptions(id);
      updateAppWidget(context,mgr,id,options);
    }
 catch (    NullPointerException e) {
      e.printStackTrace();
      Tools.HangarLog(""String_Node_Str"");
    }
  }
  super.onReceive(context,intent);
}","@Override public void onReceive(Context context,Intent intent){
  Tools.HangarLog(""String_Node_Str"" + this.getClass().getCanonicalName() + ""String_Node_Str"");
  if (mContext == null)   mContext=context;
  AppWidgetManager mgr=AppWidgetManager.getInstance(context);
  int[] ids=mgr.getAppWidgetIds(new ComponentName(context,StatsWidget.class));
  for (  int id : ids) {
    Tools.HangarLog(""String_Node_Str"" + id);
    try {
      Bundle options=mgr.getAppWidgetOptions(id);
      updateAppWidget(context,mgr,id,options);
    }
 catch (    NullPointerException e) {
      e.printStackTrace();
      Tools.HangarLog(""String_Node_Str"");
    }
  }
  super.onReceive(context,intent);
}",0.9562547966231773
80577,"@Override public void onUpdate(Context context,AppWidgetManager appWidgetManager,int[] appWidgetIds){
  Tools.HangarLog(""String_Node_Str"");
  mContext=context;
  Intent intent=new Intent(context,WatchfulService.class);
  context.startService(intent);
}","@Override public void onUpdate(Context context,AppWidgetManager appWidgetManager,int[] appWidgetIds){
  Tools.HangarLog(""String_Node_Str"" + this.getClass().getCanonicalName() + ""String_Node_Str"");
  mContext=context;
  Intent intent=new Intent(context,WatchfulService.class);
  context.startService(intent);
}",0.8983957219251337
80578,"static void updateAppWidget(Context context,AppWidgetManager appWidgetManager,int appWidgetId,Bundle options){
  Tools.HangarLog(""String_Node_Str"");
  prefs=new PrefsGet(context.getSharedPreferences(""String_Node_Str"",Context.MODE_PRIVATE));
  SharedPreferences mPrefs=prefs.prefsGet();
  int statsLayout;
  int itemHeight;
  if (mPrefs.getBoolean(Settings.DIVIDER_PREFERENCE,Settings.DIVIDER_DEFAULT)) {
    statsLayout=R.layout.stats_widget;
    itemHeight=36;
  }
 else {
    statsLayout=R.layout.stats_widget_no_dividers;
    itemHeight=35;
  }
  boolean appsNoByWidgetSize=mPrefs.getBoolean(Settings.APPS_BY_WIDGET_SIZE_PREFERENCE,Settings.APPS_BY_WIDGET_SIZE_DEFAULT);
  int appsNo;
  int appsNoLs;
  Tools.HangarLog(""String_Node_Str"" + options.getInt(AppWidgetManager.OPTION_APPWIDGET_MIN_HEIGHT));
  Tools.HangarLog(""String_Node_Str"" + options.getInt(AppWidgetManager.OPTION_APPWIDGET_MAX_HEIGHT));
  appsNo=(int)Math.floor((options.getInt(AppWidgetManager.OPTION_APPWIDGET_MAX_HEIGHT) - 14) / itemHeight);
  appsNoLs=(int)Math.floor((options.getInt(AppWidgetManager.OPTION_APPWIDGET_MIN_HEIGHT) - 14) / itemHeight);
  if (appsNoByWidgetSize && appsNo > 0) {
    Tools.HangarLog(""String_Node_Str"" + appsNo);
  }
 else {
    appsNo=Integer.parseInt(mPrefs.getString(Settings.STATS_WIDGET_APPSNO_PREFERENCE,Integer.toString(Settings.STATS_WIDGET_APPSNO_DEFAULT)));
  }
  if (context.getResources().getConfiguration().orientation == Configuration.ORIENTATION_LANDSCAPE) {
    if (appsNoByWidgetSize && appsNoLs > 0) {
      appsNo=appsNoLs;
      Tools.HangarLog(""String_Node_Str"" + appsNo);
    }
 else {
      appsNo=Integer.parseInt(mPrefs.getString(Settings.STATS_WIDGET_APPSNO_LS_PREFERENCE,Integer.toString(Settings.STATS_WIDGET_APPSNO_LS_DEFAULT)));
    }
    Tools.HangarLog(""String_Node_Str"");
  }
  int getColor=mPrefs.getInt(Settings.BACKGROUND_COLOR_PREFERENCE,Settings.BACKGROUND_COLOR_DEFAULT);
  RemoteViews views=new RemoteViews(context.getPackageName(),statsLayout);
  int mGravity=Integer.parseInt(mPrefs.getString(Settings.ALIGNMENT_PREFERENCE,Integer.toString(Settings.ALIGNMENT_DEFAULT)));
  views.setInt(R.id.taskRoot,""String_Node_Str"",mGravity);
  views.removeAllViews(R.id.taskRoot);
  PackageManager pkgm=context.getPackageManager();
  String packageName=context.getPackageName();
  Intent intent;
  if (db == null) {
    db=new TasksDataSource(context);
    db.open();
  }
  int highestSeconds=db.getHighestSeconds();
  List<TasksModel> tasks=db.getAllTasks();
  Collections.sort(tasks,new Tools.TasksModelComparator(""String_Node_Str""));
  int count=0;
  for (  TasksModel task : tasks) {
    RemoteViews row=new RemoteViews(context.getPackageName(),R.layout.stats_widget_row);
    int topPadding=0;
    int bottomPadding=0;
    if (count == 0)     topPadding=Tools.dpToPx(context,6);
    if (count == (appsNo - 1))     bottomPadding=Tools.dpToPx(context,6);
    row.setViewPadding(R.id.appCont,0,topPadding,0,bottomPadding);
    int clickID=context.getResources().getIdentifier(""String_Node_Str"",""String_Node_Str"",packageName);
    int iconID=context.getResources().getIdentifier(""String_Node_Str"",""String_Node_Str"",packageName);
    int labelID=context.getResources().getIdentifier(""String_Node_Str"",""String_Node_Str"",packageName);
    int imgID=context.getResources().getIdentifier(""String_Node_Str"",""String_Node_Str"",packageName);
    int statsID=context.getResources().getIdentifier(""String_Node_Str"",""String_Node_Str"",packageName);
    if (task.getBlacklisted()) {
      continue;
    }
    if (count >= appsNo) {
      Tools.HangarLog(""String_Node_Str"" + count + ""String_Node_Str""+ appsNo);
      break;
    }
    Drawable taskIcon;
    try {
      ApplicationInfo appInfo=pkgm.getApplicationInfo(task.getPackageName(),0);
      taskIcon=appInfo.loadIcon(pkgm);
    }
 catch (    Exception e) {
      continue;
    }
    count++;
    Bitmap bmpIcon=((BitmapDrawable)taskIcon).getBitmap();
    row.setImageViewBitmap(iconID,bmpIcon);
    row.setTextViewText(labelID,task.getName());
    float secondsRatio=(float)task.getSeconds() / highestSeconds;
    int barColor;
    int secondsColor=(Math.round(secondsRatio * 100));
    if (secondsColor >= 80) {
      barColor=0xFF34B5E2;
    }
 else     if (secondsColor >= 60) {
      barColor=0xFFAA66CC;
    }
 else     if (secondsColor >= 40) {
      barColor=0xFF74C353;
    }
 else     if (secondsColor >= 20) {
      barColor=0xFFFFBB33;
    }
 else {
      barColor=0xFFFF4444;
    }
    int[] colors=new int[]{barColor,Tools.dpToPx(context,secondsColor - 1),0x00000000,Tools.dpToPx(mContext,100 - secondsColor)};
    Tools.HangarLog(""String_Node_Str"" + colors[0] + ""String_Node_Str""+ colors[1]+ ""String_Node_Str""+ colors[2]+ ""String_Node_Str""+ colors[3]);
    Drawable sd=new BarDrawable(colors);
    Bitmap bmpIcon2=drawableToBitmap(sd);
    row.setImageViewBitmap(imgID,bmpIcon2);
    int[] statsTime=new Settings().splitToComponentTimes(task.getSeconds());
    String statsString=((statsTime[0] > 0) ? statsTime[0] + ""String_Node_Str"" : ""String_Node_Str"") + ((statsTime[1] > 0) ? statsTime[1] + ""String_Node_Str"" : ""String_Node_Str"") + ((statsTime[2] > 0) ? statsTime[2] + ""String_Node_Str"" : ""String_Node_Str"");
    row.setTextViewText(statsID,statsString);
    try {
      intent=pkgm.getLaunchIntentForPackage(task.getPackageName());
      if (intent == null) {
        count--;
        throw new PackageManager.NameNotFoundException();
      }
      intent.addCategory(Intent.CATEGORY_LAUNCHER);
      intent.setAction(""String_Node_Str"" + (count));
      PendingIntent activity=PendingIntent.getActivity(context,0,intent,PendingIntent.FLAG_CANCEL_CURRENT);
      row.setOnClickPendingIntent(clickID,activity);
    }
 catch (    PackageManager.NameNotFoundException e) {
    }
    row.setInt(R.id.appCont,""String_Node_Str"",getColor);
    views.addView(R.id.taskRoot,row);
  }
  appWidgetManager.updateAppWidget(appWidgetId,views);
}","static void updateAppWidget(Context context,AppWidgetManager appWidgetManager,int appWidgetId,Bundle options){
  Tools.HangarLog(""String_Node_Str"");
  prefs=new PrefsGet(context.getSharedPreferences(""String_Node_Str"",Context.MODE_PRIVATE));
  SharedPreferences mPrefs=prefs.prefsGet();
  int statsLayout;
  int itemHeight;
  if (mPrefs.getBoolean(Settings.DIVIDER_PREFERENCE,Settings.DIVIDER_DEFAULT)) {
    statsLayout=R.layout.stats_widget;
    itemHeight=36;
  }
 else {
    statsLayout=R.layout.stats_widget_no_dividers;
    itemHeight=35;
  }
  boolean appsNoByWidgetSize=mPrefs.getBoolean(Settings.APPS_BY_WIDGET_SIZE_PREFERENCE,Settings.APPS_BY_WIDGET_SIZE_DEFAULT);
  int appsNo;
  int appsNoLs;
  Tools.HangarLog(""String_Node_Str"" + options.getInt(AppWidgetManager.OPTION_APPWIDGET_MIN_HEIGHT));
  Tools.HangarLog(""String_Node_Str"" + options.getInt(AppWidgetManager.OPTION_APPWIDGET_MAX_HEIGHT));
  appsNo=(int)Math.floor((options.getInt(AppWidgetManager.OPTION_APPWIDGET_MAX_HEIGHT) - 14) / itemHeight);
  appsNoLs=(int)Math.floor((options.getInt(AppWidgetManager.OPTION_APPWIDGET_MIN_HEIGHT) - 14) / itemHeight);
  if (appsNoByWidgetSize && appsNo > 0) {
    Tools.HangarLog(""String_Node_Str"" + appsNo);
  }
 else {
    appsNo=Integer.parseInt(mPrefs.getString(Settings.STATS_WIDGET_APPSNO_PREFERENCE,Integer.toString(Settings.STATS_WIDGET_APPSNO_DEFAULT)));
  }
  if (context.getResources().getConfiguration().orientation == Configuration.ORIENTATION_LANDSCAPE) {
    if (appsNoByWidgetSize && appsNoLs > 0) {
      appsNo=appsNoLs;
      Tools.HangarLog(""String_Node_Str"" + appsNo);
    }
 else {
      appsNo=Integer.parseInt(mPrefs.getString(Settings.STATS_WIDGET_APPSNO_LS_PREFERENCE,Integer.toString(Settings.STATS_WIDGET_APPSNO_LS_DEFAULT)));
    }
    Tools.HangarLog(""String_Node_Str"");
  }
  int getColor=mPrefs.getInt(Settings.BACKGROUND_COLOR_PREFERENCE,Settings.BACKGROUND_COLOR_DEFAULT);
  RemoteViews views=new RemoteViews(context.getPackageName(),statsLayout);
  int mGravity=Integer.parseInt(mPrefs.getString(Settings.ALIGNMENT_PREFERENCE,Integer.toString(Settings.ALIGNMENT_DEFAULT)));
  views.setInt(R.id.taskRoot,""String_Node_Str"",mGravity);
  views.removeAllViews(R.id.taskRoot);
  PackageManager pkgm=context.getPackageManager();
  String packageName=context.getPackageName();
  Intent intent;
  if (db == null) {
    db=new TasksDataSource(context);
    db.open();
  }
  int highestSeconds=db.getHighestSeconds();
  List<TasksModel> tasks=db.getAllTasks();
  Collections.sort(tasks,new Tools.TasksModelComparator(""String_Node_Str""));
  int count=0;
  for (  TasksModel task : tasks) {
    RemoteViews row=new RemoteViews(context.getPackageName(),R.layout.stats_widget_row);
    int topPadding=0;
    int bottomPadding=0;
    if (count == 0)     topPadding=Tools.dpToPx(context,6);
    if (count == (appsNo - 1))     bottomPadding=Tools.dpToPx(context,6);
    row.setViewPadding(R.id.appCont,0,topPadding,0,bottomPadding);
    int clickID=context.getResources().getIdentifier(""String_Node_Str"",""String_Node_Str"",packageName);
    int iconID=context.getResources().getIdentifier(""String_Node_Str"",""String_Node_Str"",packageName);
    int labelID=context.getResources().getIdentifier(""String_Node_Str"",""String_Node_Str"",packageName);
    int imgID=context.getResources().getIdentifier(""String_Node_Str"",""String_Node_Str"",packageName);
    int statsID=context.getResources().getIdentifier(""String_Node_Str"",""String_Node_Str"",packageName);
    if (task.getBlacklisted()) {
      continue;
    }
    if (count >= appsNo) {
      Tools.HangarLog(""String_Node_Str"" + count + ""String_Node_Str""+ appsNo);
      break;
    }
    Drawable taskIcon;
    try {
      ApplicationInfo appInfo=pkgm.getApplicationInfo(task.getPackageName(),0);
      taskIcon=appInfo.loadIcon(pkgm);
    }
 catch (    Exception e) {
      continue;
    }
    count++;
    Bitmap bmpIcon=((BitmapDrawable)taskIcon).getBitmap();
    row.setImageViewBitmap(iconID,bmpIcon);
    row.setTextViewText(labelID,task.getName());
    float secondsRatio=(float)task.getSeconds() / highestSeconds;
    int barColor;
    int secondsColor=(Math.round(secondsRatio * 100));
    if (secondsColor >= 80) {
      barColor=0xFF34B5E2;
    }
 else     if (secondsColor >= 60) {
      barColor=0xFFAA66CC;
    }
 else     if (secondsColor >= 40) {
      barColor=0xFF74C353;
    }
 else     if (secondsColor >= 20) {
      barColor=0xFFFFBB33;
    }
 else {
      barColor=0xFFFF4444;
    }
    int[] colors=new int[]{barColor,Tools.dpToPx(context,secondsColor - 1),0x00000000,Tools.dpToPx(mContext,100 - secondsColor)};
    Drawable sd=new BarDrawable(colors);
    Bitmap bmpIcon2=drawableToBitmap(sd);
    row.setImageViewBitmap(imgID,bmpIcon2);
    int[] statsTime=new Settings().splitToComponentTimes(task.getSeconds());
    String statsString=((statsTime[0] > 0) ? statsTime[0] + ""String_Node_Str"" : ""String_Node_Str"") + ((statsTime[1] > 0) ? statsTime[1] + ""String_Node_Str"" : ""String_Node_Str"") + ((statsTime[2] > 0) ? statsTime[2] + ""String_Node_Str"" : ""String_Node_Str"");
    row.setTextViewText(statsID,statsString);
    try {
      intent=pkgm.getLaunchIntentForPackage(task.getPackageName());
      if (intent == null) {
        count--;
        throw new PackageManager.NameNotFoundException();
      }
      intent.addCategory(Intent.CATEGORY_LAUNCHER);
      intent.setAction(""String_Node_Str"" + (count));
      PendingIntent activity=PendingIntent.getActivity(context,0,intent,PendingIntent.FLAG_CANCEL_CURRENT);
      row.setOnClickPendingIntent(clickID,activity);
    }
 catch (    PackageManager.NameNotFoundException e) {
    }
    row.setInt(R.id.appCont,""String_Node_Str"",getColor);
    views.addView(R.id.taskRoot,row);
  }
  appWidgetManager.updateAppWidget(appWidgetId,views);
}",0.9877829987184964
80579,"public TaskComparator(String type,int weight,int num){
  mType=type;
  weightPriority=weight;
  Float calNum=num / 8f;
  baseRecency=(calNum < 2.5) ? 2.5f : calNum;
  numToCompare=baseRecency + 1.5f;
}","public TaskComparator(String type,int weight,int num){
  mType=type;
  weightPriority=weight;
  Float calNum=num / 10f;
  baseRecency=(calNum < 2.5) ? 2.5f : calNum;
  numToCompare=baseRecency + 1.5f;
  HangarLog(""String_Node_Str"" + num + ""String_Node_Str""+ calNum+ ""String_Node_Str""+ baseRecency+ ""String_Node_Str""+ numToCompare);
}",0.7490636704119851
80580,"protected static ArrayList<TaskInfo> reorderTasks(ArrayList<TaskInfo> taskList,TasksDataSource db,int weightPriority){
  return reorderTasks(taskList,db,weightPriority,false);
}","protected ArrayList<TaskInfo> reorderTasks(ArrayList<TaskInfo> taskList,TasksDataSource db,int weightPriority){
  return reorderTasks(taskList,db,weightPriority,false);
}",0.9798270893371758
80581,"protected void buildReorderAndLaunch(boolean isToggled){
  if (isToggled) {
    ArrayList<Tools.TaskInfo> taskList;
    taskList=Tools.buildTaskList(getApplicationContext(),db,TASKLIST_QUEUE_SIZE);
    if (taskList.size() == 0) {
      buildBaseTasks();
      taskList=Tools.buildTaskList(getApplicationContext(),db,TASKLIST_QUEUE_SIZE);
    }
    reorderAndLaunch(taskList);
  }
}","protected void buildReorderAndLaunch(boolean isToggled){
  if (isToggled) {
    ArrayList<Tools.TaskInfo> taskList;
    taskList=Tools.buildTaskList(getApplicationContext(),db,Settings.TASKLIST_QUEUE_LIMIT);
    if (taskList.size() == 0) {
      buildBaseTasks();
      taskList=Tools.buildTaskList(getApplicationContext(),db,Settings.TASKLIST_QUEUE_LIMIT);
    }
    reorderAndLaunch(taskList);
  }
}",0.9539641943734016
80582,"protected void reorderAndLaunch(ArrayList<Tools.TaskInfo> taskList){
  boolean weightedRecents=prefs.getBoolean(Settings.WEIGHTED_RECENTS_PREFERENCE,Settings.WEIGHTED_RECENTS_DEFAULT);
  boolean isToggled=prefs.getBoolean(Settings.TOGGLE_PREFERENCE,Settings.TOGGLE_DEFAULT);
  int weightPriority=Integer.parseInt(prefs.getString(Settings.WEIGHT_PRIORITY_PREFERENCE,Integer.toString(Settings.WEIGHT_PRIORITY_DEFAULT)));
  if (weightedRecents) {
    taskList=Tools.reorderTasks(taskList,db,weightPriority);
  }
  if (isToggled)   createNotification(taskList);
  reorderWidgetTasks(weightedRecents,weightPriority);
}","protected void reorderAndLaunch(ArrayList<Tools.TaskInfo> taskList){
  boolean weightedRecents=prefs.getBoolean(Settings.WEIGHTED_RECENTS_PREFERENCE,Settings.WEIGHTED_RECENTS_DEFAULT);
  boolean isToggled=prefs.getBoolean(Settings.TOGGLE_PREFERENCE,Settings.TOGGLE_DEFAULT);
  int weightPriority=Integer.parseInt(prefs.getString(Settings.WEIGHT_PRIORITY_PREFERENCE,Integer.toString(Settings.WEIGHT_PRIORITY_DEFAULT)));
  if (weightedRecents) {
    taskList=new Tools().reorderTasks(taskList,db,weightPriority);
  }
  if (isToggled)   createNotification(taskList);
  try {
    int ids[]=AppWidgetManager.getInstance(this).getAppWidgetIds(new ComponentName(this,AppsWidget.class));
    if (ids.length > 0)     Tools.reorderWidgetTasks(db,getApplicationContext());
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}",0.797768479776848
80583,"@Override public void onReceive(Context context,Intent intent){
  if (intent.getAction() != null && intent.getAction().equals(BCAST_CONFIGCHANGED)) {
    Tools.HangarLog(""String_Node_Str"" + runningTask.packageName + ""String_Node_Str""+ launcherPackage);
    if (runningTask.packageName.equals(launcherPackage)) {
      Tools.updateWidget(context);
    }
  }
}","@Override public void onReceive(Context context,Intent intent){
  if (intent.getAction() != null && intent.getAction().equals(BCAST_CONFIGCHANGED) && runningTask != null && launcherPackage != null) {
    Tools.HangarLog(""String_Node_Str"" + runningTask.packageName + ""String_Node_Str""+ launcherPackage);
    if (runningTask.packageName.equals(launcherPackage)) {
      Tools.updateWidget(context);
    }
  }
}",0.9347258485639688
80584,"static void updateAppWidget(Context context,AppWidgetManager appWidgetManager,int appWidgetId,Bundle options){
  Tools.HangarLog(""String_Node_Str"");
  prefs=new PrefsGet(context.getSharedPreferences(""String_Node_Str"",Context.MODE_PRIVATE));
  SharedPreferences mPrefs=prefs.prefsGet();
  int statsLayout;
  int itemHeight;
  if (mPrefs.getBoolean(Settings.DIVIDER_PREFERENCE,Settings.DIVIDER_DEFAULT)) {
    statsLayout=R.layout.stats_widget;
    itemHeight=36;
  }
 else {
    statsLayout=R.layout.stats_widget_no_dividers;
    itemHeight=35;
  }
  boolean appsNoByWidgetSize=mPrefs.getBoolean(Settings.APPS_BY_WIDGET_SIZE_PREFERENCE,Settings.APPS_BY_WIDGET_SIZE_DEFAULT);
  int appsNo;
  int appsNoLs;
  Tools.HangarLog(""String_Node_Str"" + options.getInt(AppWidgetManager.OPTION_APPWIDGET_MIN_HEIGHT));
  Tools.HangarLog(""String_Node_Str"" + options.getInt(AppWidgetManager.OPTION_APPWIDGET_MAX_HEIGHT));
  appsNo=(int)Math.floor((options.getInt(AppWidgetManager.OPTION_APPWIDGET_MAX_HEIGHT) - 14) / itemHeight);
  appsNoLs=(int)Math.floor((options.getInt(AppWidgetManager.OPTION_APPWIDGET_MIN_HEIGHT) - 14) / itemHeight);
  if (appsNoByWidgetSize && appsNo > 0) {
    Tools.HangarLog(""String_Node_Str"" + appsNo);
  }
 else {
    appsNo=Integer.parseInt(mPrefs.getString(Settings.STATS_WIDGET_APPSNO_PREFERENCE,Integer.toString(Settings.STATS_WIDGET_APPSNO_DEFAULT)));
  }
  if (context.getResources().getConfiguration().orientation == Configuration.ORIENTATION_LANDSCAPE) {
    if (appsNoByWidgetSize && appsNoLs > 0) {
      appsNo=appsNoLs;
      Tools.HangarLog(""String_Node_Str"" + appsNo);
    }
 else {
      appsNo=Integer.parseInt(mPrefs.getString(Settings.STATS_WIDGET_APPSNO_LS_PREFERENCE,Integer.toString(Settings.STATS_WIDGET_APPSNO_LS_DEFAULT)));
    }
    Tools.HangarLog(""String_Node_Str"");
  }
  int getColor=mPrefs.getInt(Settings.BACKGROUND_COLOR_PREFERENCE,Settings.BACKGROUND_COLOR_DEFAULT);
  RemoteViews views=new RemoteViews(context.getPackageName(),statsLayout);
  int mGravity=Integer.parseInt(mPrefs.getString(Settings.ALIGNMENT_PREFERENCE,Integer.toString(Settings.ALIGNMENT_DEFAULT)));
  views.setInt(R.id.taskRoot,""String_Node_Str"",mGravity);
  views.removeAllViews(R.id.taskRoot);
  PackageManager pkgm=context.getPackageManager();
  String packageName=context.getPackageName();
  Intent intent;
  if (db == null) {
    db=new TasksDataSource(context);
    db.open();
  }
  int highestSeconds=db.getHighestSeconds();
  List<TasksModel> tasks=db.getAllTasks();
  Collections.sort(tasks,new Tools.TasksModelComparator(""String_Node_Str""));
  int count=0;
  for (  TasksModel task : tasks) {
    RemoteViews row=new RemoteViews(context.getPackageName(),R.layout.stats_widget_row);
    int topPadding=0;
    int bottomPadding=0;
    if (count == 0)     topPadding=Tools.dpToPx(context,6);
    if (count == (appsNo - 1))     bottomPadding=Tools.dpToPx(context,6);
    row.setViewPadding(R.id.appCont,0,topPadding,0,bottomPadding);
    int appID=context.getResources().getIdentifier(""String_Node_Str"",""String_Node_Str"",packageName);
    int iconID=context.getResources().getIdentifier(""String_Node_Str"",""String_Node_Str"",packageName);
    int labelID=context.getResources().getIdentifier(""String_Node_Str"",""String_Node_Str"",packageName);
    int imgID=context.getResources().getIdentifier(""String_Node_Str"",""String_Node_Str"",packageName);
    int statsID=context.getResources().getIdentifier(""String_Node_Str"",""String_Node_Str"",packageName);
    if (task.getBlacklisted()) {
      continue;
    }
    if (count >= appsNo) {
      Tools.HangarLog(""String_Node_Str"" + count + ""String_Node_Str""+ appsNo);
      break;
    }
    Drawable taskIcon;
    try {
      ApplicationInfo appInfo=pkgm.getApplicationInfo(task.getPackageName(),0);
      taskIcon=appInfo.loadIcon(pkgm);
    }
 catch (    Exception e) {
      continue;
    }
    count++;
    Bitmap bmpIcon=((BitmapDrawable)taskIcon).getBitmap();
    row.setImageViewBitmap(iconID,bmpIcon);
    row.setTextViewText(labelID,task.getName());
    float secondsRatio=(float)task.getSeconds() / highestSeconds;
    int barColor;
    int secondsColor=(Math.round(secondsRatio * 100));
    if (secondsColor >= 80) {
      barColor=0xFF34B5E2;
    }
 else     if (secondsColor >= 60) {
      barColor=0xFFAA66CC;
    }
 else     if (secondsColor >= 40) {
      barColor=0xFF74C353;
    }
 else     if (secondsColor >= 20) {
      barColor=0xFFFFBB33;
    }
 else {
      barColor=0xFFFF4444;
    }
    int[] colors=new int[]{barColor,Tools.dpToPx(context,secondsColor - 1),0x00000000,Tools.dpToPx(mContext,100 - secondsColor)};
    Tools.HangarLog(""String_Node_Str"" + colors[0] + ""String_Node_Str""+ colors[1]+ ""String_Node_Str""+ colors[2]+ ""String_Node_Str""+ colors[3]);
    Tools.HangarLog(""String_Node_Str"" + Tools.pxToDp(context,secondsColor * 2.55f));
    Drawable sd=new BarDrawable(colors);
    Bitmap bmpIcon2=drawableToBitmap(sd);
    row.setImageViewBitmap(imgID,bmpIcon2);
    int[] statsTime=new Settings().splitToComponentTimes(task.getSeconds());
    String statsString=((statsTime[0] > 0) ? statsTime[0] + ""String_Node_Str"" : ""String_Node_Str"") + ((statsTime[1] > 0) ? statsTime[1] + ""String_Node_Str"" : ""String_Node_Str"") + ((statsTime[2] > 0) ? statsTime[2] + ""String_Node_Str"" : ""String_Node_Str"");
    row.setTextViewText(statsID,statsString);
    try {
      intent=pkgm.getLaunchIntentForPackage(task.getPackageName());
      if (intent == null) {
        count--;
        throw new PackageManager.NameNotFoundException();
      }
      intent.addCategory(Intent.CATEGORY_LAUNCHER);
      intent.setAction(""String_Node_Str"" + (count));
      PendingIntent activity=PendingIntent.getActivity(context,0,intent,PendingIntent.FLAG_CANCEL_CURRENT);
      row.setOnClickPendingIntent(appID,activity);
      row.setViewVisibility(appID,View.VISIBLE);
    }
 catch (    PackageManager.NameNotFoundException e) {
    }
    row.setInt(R.id.appCont,""String_Node_Str"",getColor);
    views.addView(R.id.taskRoot,row);
  }
  appWidgetManager.updateAppWidget(appWidgetId,views);
}","static void updateAppWidget(Context context,AppWidgetManager appWidgetManager,int appWidgetId,Bundle options){
  Tools.HangarLog(""String_Node_Str"");
  prefs=new PrefsGet(context.getSharedPreferences(""String_Node_Str"",Context.MODE_PRIVATE));
  SharedPreferences mPrefs=prefs.prefsGet();
  int statsLayout;
  int itemHeight;
  if (mPrefs.getBoolean(Settings.DIVIDER_PREFERENCE,Settings.DIVIDER_DEFAULT)) {
    statsLayout=R.layout.stats_widget;
    itemHeight=36;
  }
 else {
    statsLayout=R.layout.stats_widget_no_dividers;
    itemHeight=35;
  }
  boolean appsNoByWidgetSize=mPrefs.getBoolean(Settings.APPS_BY_WIDGET_SIZE_PREFERENCE,Settings.APPS_BY_WIDGET_SIZE_DEFAULT);
  int appsNo;
  int appsNoLs;
  Tools.HangarLog(""String_Node_Str"" + options.getInt(AppWidgetManager.OPTION_APPWIDGET_MIN_HEIGHT));
  Tools.HangarLog(""String_Node_Str"" + options.getInt(AppWidgetManager.OPTION_APPWIDGET_MAX_HEIGHT));
  appsNo=(int)Math.floor((options.getInt(AppWidgetManager.OPTION_APPWIDGET_MAX_HEIGHT) - 14) / itemHeight);
  appsNoLs=(int)Math.floor((options.getInt(AppWidgetManager.OPTION_APPWIDGET_MIN_HEIGHT) - 14) / itemHeight);
  if (appsNoByWidgetSize && appsNo > 0) {
    Tools.HangarLog(""String_Node_Str"" + appsNo);
  }
 else {
    appsNo=Integer.parseInt(mPrefs.getString(Settings.STATS_WIDGET_APPSNO_PREFERENCE,Integer.toString(Settings.STATS_WIDGET_APPSNO_DEFAULT)));
  }
  if (context.getResources().getConfiguration().orientation == Configuration.ORIENTATION_LANDSCAPE) {
    if (appsNoByWidgetSize && appsNoLs > 0) {
      appsNo=appsNoLs;
      Tools.HangarLog(""String_Node_Str"" + appsNo);
    }
 else {
      appsNo=Integer.parseInt(mPrefs.getString(Settings.STATS_WIDGET_APPSNO_LS_PREFERENCE,Integer.toString(Settings.STATS_WIDGET_APPSNO_LS_DEFAULT)));
    }
    Tools.HangarLog(""String_Node_Str"");
  }
  int getColor=mPrefs.getInt(Settings.BACKGROUND_COLOR_PREFERENCE,Settings.BACKGROUND_COLOR_DEFAULT);
  RemoteViews views=new RemoteViews(context.getPackageName(),statsLayout);
  int mGravity=Integer.parseInt(mPrefs.getString(Settings.ALIGNMENT_PREFERENCE,Integer.toString(Settings.ALIGNMENT_DEFAULT)));
  views.setInt(R.id.taskRoot,""String_Node_Str"",mGravity);
  views.removeAllViews(R.id.taskRoot);
  PackageManager pkgm=context.getPackageManager();
  String packageName=context.getPackageName();
  Intent intent;
  if (db == null) {
    db=new TasksDataSource(context);
    db.open();
  }
  int highestSeconds=db.getHighestSeconds();
  List<TasksModel> tasks=db.getAllTasks();
  Collections.sort(tasks,new Tools.TasksModelComparator(""String_Node_Str""));
  int count=0;
  for (  TasksModel task : tasks) {
    RemoteViews row=new RemoteViews(context.getPackageName(),R.layout.stats_widget_row);
    int topPadding=0;
    int bottomPadding=0;
    if (count == 0)     topPadding=Tools.dpToPx(context,6);
    if (count == (appsNo - 1))     bottomPadding=Tools.dpToPx(context,6);
    row.setViewPadding(R.id.appCont,0,topPadding,0,bottomPadding);
    int clickID=context.getResources().getIdentifier(""String_Node_Str"",""String_Node_Str"",packageName);
    int iconID=context.getResources().getIdentifier(""String_Node_Str"",""String_Node_Str"",packageName);
    int labelID=context.getResources().getIdentifier(""String_Node_Str"",""String_Node_Str"",packageName);
    int imgID=context.getResources().getIdentifier(""String_Node_Str"",""String_Node_Str"",packageName);
    int statsID=context.getResources().getIdentifier(""String_Node_Str"",""String_Node_Str"",packageName);
    if (task.getBlacklisted()) {
      continue;
    }
    if (count >= appsNo) {
      Tools.HangarLog(""String_Node_Str"" + count + ""String_Node_Str""+ appsNo);
      break;
    }
    Drawable taskIcon;
    try {
      ApplicationInfo appInfo=pkgm.getApplicationInfo(task.getPackageName(),0);
      taskIcon=appInfo.loadIcon(pkgm);
    }
 catch (    Exception e) {
      continue;
    }
    count++;
    Bitmap bmpIcon=((BitmapDrawable)taskIcon).getBitmap();
    row.setImageViewBitmap(iconID,bmpIcon);
    row.setTextViewText(labelID,task.getName());
    float secondsRatio=(float)task.getSeconds() / highestSeconds;
    int barColor;
    int secondsColor=(Math.round(secondsRatio * 100));
    if (secondsColor >= 80) {
      barColor=0xFF34B5E2;
    }
 else     if (secondsColor >= 60) {
      barColor=0xFFAA66CC;
    }
 else     if (secondsColor >= 40) {
      barColor=0xFF74C353;
    }
 else     if (secondsColor >= 20) {
      barColor=0xFFFFBB33;
    }
 else {
      barColor=0xFFFF4444;
    }
    int[] colors=new int[]{barColor,Tools.dpToPx(context,secondsColor - 1),0x00000000,Tools.dpToPx(mContext,100 - secondsColor)};
    Tools.HangarLog(""String_Node_Str"" + colors[0] + ""String_Node_Str""+ colors[1]+ ""String_Node_Str""+ colors[2]+ ""String_Node_Str""+ colors[3]);
    Tools.HangarLog(""String_Node_Str"" + Tools.pxToDp(context,secondsColor * 2.55f));
    Drawable sd=new BarDrawable(colors);
    Bitmap bmpIcon2=drawableToBitmap(sd);
    row.setImageViewBitmap(imgID,bmpIcon2);
    int[] statsTime=new Settings().splitToComponentTimes(task.getSeconds());
    String statsString=((statsTime[0] > 0) ? statsTime[0] + ""String_Node_Str"" : ""String_Node_Str"") + ((statsTime[1] > 0) ? statsTime[1] + ""String_Node_Str"" : ""String_Node_Str"") + ((statsTime[2] > 0) ? statsTime[2] + ""String_Node_Str"" : ""String_Node_Str"");
    row.setTextViewText(statsID,statsString);
    try {
      intent=pkgm.getLaunchIntentForPackage(task.getPackageName());
      if (intent == null) {
        count--;
        throw new PackageManager.NameNotFoundException();
      }
      intent.addCategory(Intent.CATEGORY_LAUNCHER);
      intent.setAction(""String_Node_Str"" + (count));
      PendingIntent activity=PendingIntent.getActivity(context,0,intent,PendingIntent.FLAG_CANCEL_CURRENT);
      row.setOnClickPendingIntent(clickID,activity);
    }
 catch (    PackageManager.NameNotFoundException e) {
    }
    row.setInt(R.id.appCont,""String_Node_Str"",getColor);
    views.addView(R.id.taskRoot,row);
  }
  appWidgetManager.updateAppWidget(appWidgetId,views);
}",0.9946116223161734
80585,"static void updateAppWidget(Context context,AppWidgetManager appWidgetManager,int appWidgetId,Bundle options){
  Tools.HangarLog(""String_Node_Str"");
  prefs=new PrefsGet(context.getSharedPreferences(""String_Node_Str"",Context.MODE_PRIVATE));
  SharedPreferences mPrefs=prefs.prefsGet();
  int rowLayout=R.layout.apps_widget_row;
  int itemLayout=R.layout.apps_widget_item;
  int itemHeight=ICON_MEDIUM_HEIGHT;
  int itemWidth=ICON_MEDIUM_WIDTH;
  int iconSize=Integer.parseInt(mPrefs.getString(Settings.ICON_SIZE_PREFERENCE,Integer.toString(Settings.ICON_SIZE_DEFAULT)));
switch (iconSize) {
case SMALL_ICONS:
    rowLayout=R.layout.apps_widget_row_small;
  itemHeight=ICON_SMALL_HEIGHT;
itemWidth=ICON_SMALL_WIDTH;
break;
case LARGE_ICONS:
rowLayout=R.layout.apps_widget_row_large;
itemHeight=ICON_LARGE_HEIGHT;
itemWidth=ICON_LARGE_WIDTH;
break;
}
boolean appsNoByWidgetSize=mPrefs.getBoolean(Settings.APPS_BY_WIDGET_SIZE_PREFERENCE,Settings.APPS_BY_WIDGET_SIZE_DEFAULT);
int appsNoH;
int appsNoW;
boolean autoHeight=true;
Tools.HangarLog(""String_Node_Str"" + options.getInt(AppWidgetManager.OPTION_APPWIDGET_MIN_HEIGHT));
Tools.HangarLog(""String_Node_Str"" + options.getInt(AppWidgetManager.OPTION_APPWIDGET_MAX_HEIGHT));
Tools.HangarLog(""String_Node_Str"" + options.getInt(AppWidgetManager.OPTION_APPWIDGET_MIN_WIDTH));
Tools.HangarLog(""String_Node_Str"" + options.getInt(AppWidgetManager.OPTION_APPWIDGET_MAX_WIDTH));
appsNoH=(int)Math.floor((options.getInt(AppWidgetManager.OPTION_APPWIDGET_MAX_HEIGHT) - ICON_ROW_BUFFER) / itemHeight);
appsNoW=(int)Math.floor((options.getInt(AppWidgetManager.OPTION_APPWIDGET_MIN_WIDTH) - ICON_ROW_BUFFER) / itemWidth);
Tools.HangarLog(""String_Node_Str"" + appsNoH + ""String_Node_Str""+ appsNoW);
if (appsNoH == 0) {
appsNoH=1;
autoHeight=false;
}
if (context.getResources().getConfiguration().orientation == Configuration.ORIENTATION_LANDSCAPE) {
appsNoH=(int)Math.floor((options.getInt(AppWidgetManager.OPTION_APPWIDGET_MIN_HEIGHT) - ICON_ROW_BUFFER) / itemHeight);
float widgetHeight=(options.getInt(AppWidgetManager.OPTION_APPWIDGET_MIN_HEIGHT) - ICON_ROW_BUFFER);
if (appsNoH == 0) {
if (widgetHeight > 0) {
Tools.HangarLog(""String_Node_Str"");
rowLayout=R.layout.apps_widget_row_small;
itemWidth=ICON_SMALL_WIDTH;
}
appsNoH=1;
autoHeight=false;
}
appsNoW=(int)Math.floor((options.getInt(AppWidgetManager.OPTION_APPWIDGET_MAX_WIDTH) - ICON_ROW_BUFFER) / itemWidth);
if (appsNoByWidgetSize && appsNoW > 0) {
Tools.HangarLog(""String_Node_Str"" + appsNoW);
}
 else {
appsNoW=Integer.parseInt(mPrefs.getString(Settings.STATS_WIDGET_APPSNO_LS_PREFERENCE,Integer.toString(Settings.STATS_WIDGET_APPSNO_LS_DEFAULT)));
}
Tools.HangarLog(""String_Node_Str"");
}
 else {
if (appsNoByWidgetSize && appsNoW > 0) {
Tools.HangarLog(""String_Node_Str"" + appsNoH);
}
 else {
appsNoW=Integer.parseInt(mPrefs.getString(Settings.STATS_WIDGET_APPSNO_PREFERENCE,Integer.toString(Settings.STATS_WIDGET_APPSNO_DEFAULT)));
}
}
int getBackgroundColor=mPrefs.getInt(Settings.BACKGROUND_COLOR_PREFERENCE,Settings.BACKGROUND_COLOR_DEFAULT);
int getColor=mPrefs.getInt(Settings.ICON_COLOR_PREFERENCE,Settings.ICON_COLOR_DEFAULT);
RemoteViews views=new RemoteViews(context.getPackageName(),R.layout.apps_widget);
views.removeAllViews(R.id.viewCont);
PackageManager pkgm=context.getPackageManager();
if (db == null) {
db=new TasksDataSource(context);
db.open();
}
ArrayList<Tools.TaskInfo> appList=new ArrayList<Tools.TaskInfo>();
int gridSize=(appsNoH * appsNoW);
int numOfIcons=(appsNoH * appsNoW);
int lookUpNum=numOfIcons + 3;
if (autoHeight && !appsNoByWidgetSize) {
numOfIcons=appsNoW;
lookUpNum=appsNoW + 3;
}
List<TasksModel> tasks=db.getAllTasks((lookUpNum < MAX_DB_LOOKUPS) ? MAX_DB_LOOKUPS : lookUpNum);
for (TasksModel taskM : tasks) {
String taskPackage=taskM.getPackageName();
if (isBlacklisted(taskPackage)) continue;
Tools.TaskInfo dbTask=new Tools.TaskInfo();
dbTask.appName=taskM.getName();
dbTask.packageName=taskPackage;
dbTask.className=taskM.getClassName();
dbTask.launches=taskM.getLaunches();
dbTask.totalseconds=taskM.getSeconds();
try {
pkgm.getApplicationInfo(dbTask.packageName,0);
}
 catch (PackageManager.NameNotFoundException e) {
db.deleteTask(taskM);
continue;
}
try {
Intent intent=pkgm.getLaunchIntentForPackage(taskPackage);
if (intent == null) throw new PackageManager.NameNotFoundException();
}
 catch (PackageManager.NameNotFoundException e) {
db.deleteTask(taskM);
}
appList.add(dbTask);
}
String taskPackage=context.getPackageName();
boolean isColorized=mPrefs.getBoolean(Settings.COLORIZE_PREFERENCE,Settings.COLORIZE_DEFAULT);
boolean weightedRecents=mPrefs.getBoolean(Settings.WEIGHTED_RECENTS_PREFERENCE,Settings.WEIGHTED_RECENTS_DEFAULT);
int weightPriority=Integer.parseInt(mPrefs.getString(Settings.WEIGHT_PRIORITY_PREFERENCE,Integer.toString(Settings.WEIGHT_PRIORITY_DEFAULT)));
if (weightedRecents) {
Tools.HangarLog(""String_Node_Str"" + weightPriority);
appList=Tools.reorderTasks(appList,db,weightPriority);
}
RemoteViews row=new RemoteViews(context.getPackageName(),rowLayout);
row.setInt(R.id.viewRow,""String_Node_Str"",getBackgroundColor);
if (autoHeight && !appsNoByWidgetSize) {
appsNoW=(int)Math.ceil((double)appsNoW / appsNoH);
Tools.HangarLog(""String_Node_Str"" + appsNoW);
}
int filledConts=0;
int filledRows=1;
Tools.HangarLog(""String_Node_Str"" + appsNoW + ""String_Node_Str""+ appList.size()+ ""String_Node_Str""+ numOfIcons);
for (int i=0; i <= gridSize; i++) {
RemoteViews item=new RemoteViews(context.getPackageName(),itemLayout);
if (filledConts == appsNoW || i == (gridSize)) {
Tools.HangarLog(""String_Node_Str"" + i + ""String_Node_Str""+ filledConts);
views.addView(R.id.viewCont,row);
if (filledRows < appsNoH && (filledConts < numOfIcons && appList.size() > i)) {
row=new RemoteViews(context.getPackageName(),rowLayout);
row.setInt(R.id.viewRow,""String_Node_Str"",getBackgroundColor);
filledConts=0;
filledRows++;
}
 else {
break;
}
}
filledConts+=1;
int resID=context.getResources().getIdentifier(""String_Node_Str"",""String_Node_Str"",taskPackage);
int contID=context.getResources().getIdentifier(""String_Node_Str"",""String_Node_Str"",taskPackage);
if (i >= numOfIcons || i >= appList.size()) {
item.setViewVisibility(contID,View.INVISIBLE);
row.addView(R.id.viewRow,item);
continue;
}
Tools.HangarLog(""String_Node_Str"" + filledConts + ""String_Node_Str""+ appList.get(i).appName+ ""String_Node_Str"");
Drawable taskIcon, d;
try {
ApplicationInfo appInfo=pkgm.getApplicationInfo(appList.get(i).packageName,0);
taskIcon=appInfo.loadIcon(pkgm);
}
 catch (Exception e) {
Tools.HangarLog(""String_Node_Str"" + e);
continue;
}
if (isColorized) {
d=new BitmapDrawable(ColorHelper.getColoredBitmap(taskIcon,getColor));
}
 else {
d=taskIcon;
}
Bitmap bmpIcon=((BitmapDrawable)d).getBitmap();
item.setImageViewBitmap(resID,bmpIcon);
Intent intent;
PackageManager manager=context.getPackageManager();
try {
intent=manager.getLaunchIntentForPackage(appList.get(i).packageName);
if (intent == null) {
Tools.HangarLog(""String_Node_Str"" + appList.get(i).packageName + ""String_Node_Str""+ appList.get(i).className);
filledConts--;
item.setViewVisibility(contID,View.GONE);
row.addView(R.id.viewRow,item);
throw new PackageManager.NameNotFoundException();
}
intent.addCategory(Intent.CATEGORY_LAUNCHER);
intent.setAction(""String_Node_Str"" + (i));
PendingIntent activity=PendingIntent.getActivity(context,appWidgetId,intent,PendingIntent.FLAG_CANCEL_CURRENT);
item.setOnClickPendingIntent(contID,activity);
}
 catch (PackageManager.NameNotFoundException e) {
numOfIcons++;
}
row.addView(R.id.viewRow,item);
}
appWidgetManager.updateAppWidget(appWidgetId,views);
}","static void updateAppWidget(Context context,AppWidgetManager appWidgetManager,int appWidgetId,Bundle options){
  Tools.HangarLog(""String_Node_Str"");
  prefs=new PrefsGet(context.getSharedPreferences(""String_Node_Str"",Context.MODE_PRIVATE));
  SharedPreferences mPrefs=prefs.prefsGet();
  int rowLayout=R.layout.apps_widget_row;
  int itemLayout=R.layout.apps_widget_item;
  int itemHeight=ICON_MEDIUM_HEIGHT;
  int itemWidth=ICON_MEDIUM_WIDTH;
  int iconSize=Integer.parseInt(mPrefs.getString(Settings.ICON_SIZE_PREFERENCE,Integer.toString(Settings.ICON_SIZE_DEFAULT)));
switch (iconSize) {
case SMALL_ICONS:
    rowLayout=R.layout.apps_widget_row_small;
  itemHeight=ICON_SMALL_HEIGHT;
itemWidth=ICON_SMALL_WIDTH;
break;
case LARGE_ICONS:
rowLayout=R.layout.apps_widget_row_large;
itemHeight=ICON_LARGE_HEIGHT;
itemWidth=ICON_LARGE_WIDTH;
break;
}
boolean appsNoByWidgetSize=mPrefs.getBoolean(Settings.APPS_BY_WIDGET_SIZE_PREFERENCE,Settings.APPS_BY_WIDGET_SIZE_DEFAULT);
int appsNoH;
int appsNoW;
boolean autoHeight=true;
Tools.HangarLog(""String_Node_Str"" + options.getInt(AppWidgetManager.OPTION_APPWIDGET_MIN_HEIGHT));
Tools.HangarLog(""String_Node_Str"" + options.getInt(AppWidgetManager.OPTION_APPWIDGET_MAX_HEIGHT));
Tools.HangarLog(""String_Node_Str"" + options.getInt(AppWidgetManager.OPTION_APPWIDGET_MIN_WIDTH));
Tools.HangarLog(""String_Node_Str"" + options.getInt(AppWidgetManager.OPTION_APPWIDGET_MAX_WIDTH));
appsNoH=(int)Math.floor((options.getInt(AppWidgetManager.OPTION_APPWIDGET_MAX_HEIGHT) - ICON_ROW_BUFFER) / itemHeight);
appsNoW=(int)Math.floor((options.getInt(AppWidgetManager.OPTION_APPWIDGET_MIN_WIDTH) - ICON_ROW_BUFFER) / itemWidth);
Tools.HangarLog(""String_Node_Str"" + appsNoH + ""String_Node_Str""+ appsNoW);
if (appsNoH == 0) {
appsNoH=1;
autoHeight=false;
}
if (context.getResources().getConfiguration().orientation == Configuration.ORIENTATION_LANDSCAPE) {
appsNoH=(int)Math.floor((options.getInt(AppWidgetManager.OPTION_APPWIDGET_MIN_HEIGHT) - ICON_ROW_BUFFER) / itemHeight);
float widgetHeight=(options.getInt(AppWidgetManager.OPTION_APPWIDGET_MIN_HEIGHT) - ICON_ROW_BUFFER);
if (appsNoH == 0) {
if (widgetHeight > 0) {
Tools.HangarLog(""String_Node_Str"");
rowLayout=R.layout.apps_widget_row_small;
itemWidth=ICON_SMALL_WIDTH;
}
appsNoH=1;
autoHeight=false;
}
appsNoW=(int)Math.floor((options.getInt(AppWidgetManager.OPTION_APPWIDGET_MAX_WIDTH) - ICON_ROW_BUFFER) / itemWidth);
if (appsNoByWidgetSize && appsNoW > 0) {
Tools.HangarLog(""String_Node_Str"" + appsNoW);
}
 else {
appsNoW=Integer.parseInt(mPrefs.getString(Settings.STATS_WIDGET_APPSNO_LS_PREFERENCE,Integer.toString(Settings.STATS_WIDGET_APPSNO_LS_DEFAULT)));
}
Tools.HangarLog(""String_Node_Str"");
}
 else {
if (appsNoByWidgetSize && appsNoW > 0) {
Tools.HangarLog(""String_Node_Str"" + appsNoH);
}
 else {
appsNoW=Integer.parseInt(mPrefs.getString(Settings.STATS_WIDGET_APPSNO_PREFERENCE,Integer.toString(Settings.STATS_WIDGET_APPSNO_DEFAULT)));
}
}
int getBackgroundColor=mPrefs.getInt(Settings.BACKGROUND_COLOR_PREFERENCE,Settings.BACKGROUND_COLOR_DEFAULT);
int getColor=mPrefs.getInt(Settings.ICON_COLOR_PREFERENCE,Settings.ICON_COLOR_DEFAULT);
RemoteViews views=new RemoteViews(context.getPackageName(),R.layout.apps_widget);
views.removeAllViews(R.id.viewCont);
PackageManager pkgm=context.getPackageManager();
if (db == null) {
db=new TasksDataSource(context);
db.open();
}
ArrayList<Tools.TaskInfo> appList=new ArrayList<Tools.TaskInfo>();
int gridSize=(appsNoH * appsNoW);
int numOfIcons=(appsNoH * appsNoW);
int lookUpNum=numOfIcons + 3;
if (autoHeight && !appsNoByWidgetSize) {
numOfIcons=appsNoW;
lookUpNum=appsNoW + 3;
}
List<TasksModel> tasks=db.getAllTasks((lookUpNum < MAX_DB_LOOKUPS) ? MAX_DB_LOOKUPS : lookUpNum);
for (TasksModel taskM : tasks) {
String taskPackage=taskM.getPackageName();
if (isBlacklisted(taskPackage)) continue;
Tools.TaskInfo dbTask=new Tools.TaskInfo();
dbTask.appName=taskM.getName();
dbTask.packageName=taskPackage;
dbTask.className=taskM.getClassName();
dbTask.launches=taskM.getLaunches();
dbTask.totalseconds=taskM.getSeconds();
try {
pkgm.getApplicationInfo(dbTask.packageName,0);
}
 catch (PackageManager.NameNotFoundException e) {
db.deleteTask(taskM);
continue;
}
try {
Intent intent=pkgm.getLaunchIntentForPackage(taskPackage);
if (intent == null) throw new PackageManager.NameNotFoundException();
}
 catch (PackageManager.NameNotFoundException e) {
db.deleteTask(taskM);
}
appList.add(dbTask);
}
String taskPackage=context.getPackageName();
boolean isColorized=mPrefs.getBoolean(Settings.COLORIZE_PREFERENCE,Settings.COLORIZE_DEFAULT);
boolean weightedRecents=mPrefs.getBoolean(Settings.WEIGHTED_RECENTS_PREFERENCE,Settings.WEIGHTED_RECENTS_DEFAULT);
int weightPriority=Integer.parseInt(mPrefs.getString(Settings.WEIGHT_PRIORITY_PREFERENCE,Integer.toString(Settings.WEIGHT_PRIORITY_DEFAULT)));
if (weightedRecents) {
Tools.HangarLog(""String_Node_Str"" + weightPriority);
appList=Tools.reorderTasks(appList,db,weightPriority);
}
RemoteViews row=new RemoteViews(context.getPackageName(),rowLayout);
row.setInt(R.id.viewRow,""String_Node_Str"",getBackgroundColor);
if (autoHeight && !appsNoByWidgetSize) {
appsNoW=(int)Math.ceil((double)appsNoW / appsNoH);
Tools.HangarLog(""String_Node_Str"" + appsNoW);
}
int filledConts=0;
int filledRows=1;
Tools.HangarLog(""String_Node_Str"" + appsNoW + ""String_Node_Str""+ appList.size()+ ""String_Node_Str""+ numOfIcons);
for (int i=0; i <= gridSize; i++) {
RemoteViews item=new RemoteViews(context.getPackageName(),itemLayout);
if (filledConts == appsNoW || (i == gridSize)) {
Tools.HangarLog(""String_Node_Str"" + i + ""String_Node_Str""+ filledConts);
views.addView(R.id.viewCont,row);
if (i >= numOfIcons && !appsNoByWidgetSize) break;
if (filledRows < appsNoH && (filledConts < numOfIcons && appList.size() > i)) {
row=new RemoteViews(context.getPackageName(),rowLayout);
row.setInt(R.id.viewRow,""String_Node_Str"",getBackgroundColor);
filledConts=0;
filledRows++;
}
 else {
break;
}
}
filledConts+=1;
int resID=context.getResources().getIdentifier(""String_Node_Str"",""String_Node_Str"",taskPackage);
int contID=context.getResources().getIdentifier(""String_Node_Str"",""String_Node_Str"",taskPackage);
if (i >= numOfIcons || i >= appList.size()) {
item.setViewVisibility(contID,View.INVISIBLE);
row.addView(R.id.viewRow,item);
continue;
}
Tools.HangarLog(""String_Node_Str"" + filledConts + ""String_Node_Str""+ appList.get(i).appName+ ""String_Node_Str"");
Drawable taskIcon, d;
try {
ApplicationInfo appInfo=pkgm.getApplicationInfo(appList.get(i).packageName,0);
taskIcon=appInfo.loadIcon(pkgm);
}
 catch (Exception e) {
Tools.HangarLog(""String_Node_Str"" + e);
continue;
}
if (isColorized) {
d=new BitmapDrawable(ColorHelper.getColoredBitmap(taskIcon,getColor));
}
 else {
d=taskIcon;
}
Bitmap bmpIcon=((BitmapDrawable)d).getBitmap();
item.setImageViewBitmap(resID,bmpIcon);
Intent intent;
PackageManager manager=context.getPackageManager();
try {
intent=manager.getLaunchIntentForPackage(appList.get(i).packageName);
if (intent == null) {
Tools.HangarLog(""String_Node_Str"" + appList.get(i).packageName + ""String_Node_Str""+ appList.get(i).className);
filledConts--;
item.setViewVisibility(contID,View.GONE);
row.addView(R.id.viewRow,item);
throw new PackageManager.NameNotFoundException();
}
intent.addCategory(Intent.CATEGORY_LAUNCHER);
intent.setAction(""String_Node_Str"" + (i));
PendingIntent activity=PendingIntent.getActivity(context,appWidgetId,intent,PendingIntent.FLAG_CANCEL_CURRENT);
item.setOnClickPendingIntent(contID,activity);
}
 catch (PackageManager.NameNotFoundException e) {
numOfIcons++;
}
row.addView(R.id.viewRow,item);
}
appWidgetManager.updateAppWidget(appWidgetId,views);
}",0.995868581546331
80586,"@Override public void onCreate(final Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  addPreferencesFromResource(R.layout.apps_widget_settings);
  int defaultAppsNo=WIDGET_3X3_DEFAULT_APPSNO;
  int defaultAppsNoLs=WIDGET_3X3_DEFAULT_APPSNO_LS;
  SharedPreferences mPrefs=prefs.prefsGet();
  apps_by_widget_size_preference=(SwitchPreference)findPreference(Settings.APPS_BY_WIDGET_SIZE_PREFERENCE);
  apps_by_widget_size_preference.setChecked(mPrefs.getBoolean(Settings.APPS_BY_WIDGET_SIZE_PREFERENCE,Settings.APPS_BY_WIDGET_SIZE_DEFAULT));
  apps_by_widget_size_preference.setOnPreferenceChangeListener(changeListener);
  background_color_preference=(ColorPickerPreference)findPreference(Settings.BACKGROUND_COLOR_PREFERENCE);
  int intColor=mPrefs.getInt(Settings.BACKGROUND_COLOR_PREFERENCE,Settings.BACKGROUND_COLOR_DEFAULT);
  String hexColor=String.format(""String_Node_Str"",(intColor));
  background_color_preference.setSummary(hexColor);
  background_color_preference.setOnPreferenceChangeListener(changeListener);
  appnos_preference=(UpdatingListPreference)findPreference(Settings.STATS_WIDGET_APPSNO_PREFERENCE);
  appnos_preference.setValue(mPrefs.getString(extras == null ? Settings.STATS_WIDGET_APPSNO_PREFERENCE : Integer.toString(defaultAppsNo),Integer.toString(defaultAppsNo)));
  appnos_preference.setOnPreferenceChangeListener(changeListener);
  if (apps_by_widget_size_preference.isChecked()) {
    appnos_preference.setSummary(R.string.automatic_appsno);
  }
  appnos_ls_preference=(UpdatingListPreference)findPreference(Settings.STATS_WIDGET_APPSNO_LS_PREFERENCE);
  appnos_ls_preference.setValue(mPrefs.getString(extras == null ? Settings.STATS_WIDGET_APPSNO_LS_PREFERENCE : Integer.toString(defaultAppsNoLs),Integer.toString(defaultAppsNoLs)));
  appnos_ls_preference.setOnPreferenceChangeListener(changeListener);
  if (apps_by_widget_size_preference.isChecked()) {
    appnos_ls_preference.setSummary(R.string.automatic_appsno);
  }
  weighted_recents_preference=(CheckBoxPreference)findPreference(Settings.WEIGHTED_RECENTS_PREFERENCE);
  weighted_recents_preference.setChecked(mPrefs.getBoolean(Settings.WEIGHTED_RECENTS_PREFERENCE,Settings.WEIGHTED_RECENTS_DEFAULT));
  weighted_recents_preference.setOnPreferenceChangeListener(changeListener);
  weight_priority_preference=(UpdatingListPreference)findPreference(Settings.WEIGHT_PRIORITY_PREFERENCE);
  weight_priority_preference.setValue(mPrefs.getString(Settings.WEIGHT_PRIORITY_PREFERENCE,Integer.toString(Settings.WEIGHT_PRIORITY_DEFAULT)));
  weight_priority_preference.setOnPreferenceChangeListener(changeListener);
  colorize_preference=(CheckBoxPreference)findPreference(Settings.COLORIZE_PREFERENCE);
  colorize_preference.setChecked(mPrefs.getBoolean(Settings.COLORIZE_PREFERENCE,Settings.COLORIZE_DEFAULT));
  colorize_preference.setOnPreferenceChangeListener(changeListener);
  icon_color_preference=(ColorPickerPreference)findPreference(Settings.ICON_COLOR_PREFERENCE);
  int intColor2=mPrefs.getInt(Settings.ICON_COLOR_PREFERENCE,Settings.ICON_COLOR_DEFAULT);
  String hexColor2=String.format(""String_Node_Str"",(intColor2));
  icon_color_preference.setSummary(hexColor2);
  icon_color_preference.setOnPreferenceChangeListener(changeListener);
  icon_size_preference=(UpdatingListPreference)findPreference(Settings.ICON_SIZE_PREFERENCE);
  icon_size_preference.setValue(mPrefs.getString(Settings.ICON_SIZE_PREFERENCE,Integer.toString(Settings.ICON_SIZE_DEFAULT)));
  icon_size_preference.setOnPreferenceChangeListener(changeListener);
}","@Override public void onCreate(final Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  addPreferencesFromResource(R.layout.apps_widget_settings);
  int defaultAppsNo=APPS_WIDGET_DEFAULT_APPSNO;
  int defaultAppsNoLs=APPS_WIDGET_DEFAULT_APPSNO_LS;
  SharedPreferences mPrefs=prefs.prefsGet();
  apps_by_widget_size_preference=(SwitchPreference)findPreference(Settings.APPS_BY_WIDGET_SIZE_PREFERENCE);
  apps_by_widget_size_preference.setChecked(mPrefs.getBoolean(Settings.APPS_BY_WIDGET_SIZE_PREFERENCE,Settings.APPS_BY_WIDGET_SIZE_DEFAULT));
  apps_by_widget_size_preference.setOnPreferenceChangeListener(changeListener);
  background_color_preference=(ColorPickerPreference)findPreference(Settings.BACKGROUND_COLOR_PREFERENCE);
  int intColor=mPrefs.getInt(Settings.BACKGROUND_COLOR_PREFERENCE,Settings.BACKGROUND_COLOR_DEFAULT);
  String hexColor=String.format(""String_Node_Str"",(intColor));
  background_color_preference.setSummary(hexColor);
  background_color_preference.setOnPreferenceChangeListener(changeListener);
  appnos_preference=(UpdatingListPreference)findPreference(Settings.STATS_WIDGET_APPSNO_PREFERENCE);
  appnos_preference.setValue(mPrefs.getString(extras == null ? Settings.STATS_WIDGET_APPSNO_PREFERENCE : Integer.toString(defaultAppsNo),Integer.toString(defaultAppsNo)));
  appnos_preference.setOnPreferenceChangeListener(changeListener);
  if (apps_by_widget_size_preference.isChecked()) {
    appnos_preference.setSummary(R.string.automatic_appsno);
  }
  appnos_ls_preference=(UpdatingListPreference)findPreference(Settings.STATS_WIDGET_APPSNO_LS_PREFERENCE);
  appnos_ls_preference.setValue(mPrefs.getString(extras == null ? Settings.STATS_WIDGET_APPSNO_LS_PREFERENCE : Integer.toString(defaultAppsNoLs),Integer.toString(defaultAppsNoLs)));
  appnos_ls_preference.setOnPreferenceChangeListener(changeListener);
  if (apps_by_widget_size_preference.isChecked()) {
    appnos_ls_preference.setSummary(R.string.automatic_appsno);
  }
  weighted_recents_preference=(CheckBoxPreference)findPreference(Settings.WEIGHTED_RECENTS_PREFERENCE);
  weighted_recents_preference.setChecked(mPrefs.getBoolean(Settings.WEIGHTED_RECENTS_PREFERENCE,Settings.WEIGHTED_RECENTS_DEFAULT));
  weighted_recents_preference.setOnPreferenceChangeListener(changeListener);
  weight_priority_preference=(UpdatingListPreference)findPreference(Settings.WEIGHT_PRIORITY_PREFERENCE);
  weight_priority_preference.setValue(mPrefs.getString(Settings.WEIGHT_PRIORITY_PREFERENCE,Integer.toString(Settings.WEIGHT_PRIORITY_DEFAULT)));
  weight_priority_preference.setOnPreferenceChangeListener(changeListener);
  colorize_preference=(CheckBoxPreference)findPreference(Settings.COLORIZE_PREFERENCE);
  colorize_preference.setChecked(mPrefs.getBoolean(Settings.COLORIZE_PREFERENCE,Settings.COLORIZE_DEFAULT));
  colorize_preference.setOnPreferenceChangeListener(changeListener);
  icon_color_preference=(ColorPickerPreference)findPreference(Settings.ICON_COLOR_PREFERENCE);
  int intColor2=mPrefs.getInt(Settings.ICON_COLOR_PREFERENCE,Settings.ICON_COLOR_DEFAULT);
  String hexColor2=String.format(""String_Node_Str"",(intColor2));
  icon_color_preference.setSummary(hexColor2);
  icon_color_preference.setOnPreferenceChangeListener(changeListener);
  icon_size_preference=(UpdatingListPreference)findPreference(Settings.ICON_SIZE_PREFERENCE);
  icon_size_preference.setValue(mPrefs.getString(Settings.ICON_SIZE_PREFERENCE,Integer.toString(Settings.ICON_SIZE_DEFAULT)));
  icon_size_preference.setOnPreferenceChangeListener(changeListener);
}",0.9974604966139956
80587,"@Override public boolean onPreferenceChange(final Preference preference,Object newValue){
  if (preference.getKey().equals(Settings.BACKGROUND_COLOR_PREFERENCE)) {
    String hex=ColorPickerPreference.convertToARGB(Integer.valueOf(String.valueOf(newValue)));
    preference.setSummary(hex);
  }
 else   if (preference.getKey().equals(Settings.APPS_BY_WIDGET_SIZE_PREFERENCE)) {
    if (apps_by_widget_size_preference.isChecked()) {
      appnos_preference.setSummary(R.string.automatic_appsno);
      appnos_ls_preference.setSummary(R.string.automatic_appsno);
    }
 else {
      appnos_preference.goDefault(String.format(getResources().getString(R.string.summary_stats_widget_appsno_preference),appnos_preference.getValue()));
      appnos_ls_preference.goDefault(String.format(getResources().getString(R.string.summary_stats_widget_appsno_ls_preference),appnos_ls_preference.getValue()));
    }
  }
 else   if (preference.getKey().equals(Settings.STATS_WIDGET_APPSNO_PREFERENCE)) {
    appnos_preference.goDefault(String.format(getResources().getString(R.string.summary_stats_widget_appsno_preference),(String)newValue));
  }
 else   if (preference.getKey().equals(Settings.STATS_WIDGET_APPSNO_LS_PREFERENCE)) {
    appnos_ls_preference.goDefault(String.format(getResources().getString(R.string.summary_stats_widget_appsno_ls_preference),(String)newValue));
  }
 else   if (preference.getKey().equals(Settings.ICON_COLOR_PREFERENCE)) {
    String hex=ColorPickerPreference.convertToARGB(Integer.valueOf(String.valueOf(newValue)));
    preference.setSummary(hex);
  }
 else   if (preference.getKey().equals(Settings.ICON_SIZE_PREFERENCE)) {
    appnos_preference.goDefault(String.format(getResources().getString(R.string.summary_icon_size_preference),(String)newValue));
  }
  return true;
}","@Override public boolean onPreferenceChange(final Preference preference,Object newValue){
  if (preference.getKey().equals(Settings.BACKGROUND_COLOR_PREFERENCE)) {
    String hex=ColorPickerPreference.convertToARGB(Integer.valueOf(String.valueOf(newValue)));
    preference.setSummary(hex);
  }
 else   if (preference.getKey().equals(Settings.APPS_BY_WIDGET_SIZE_PREFERENCE)) {
    if (apps_by_widget_size_preference.isChecked()) {
      appnos_preference.setSummary(R.string.automatic_appsno);
      appnos_ls_preference.setSummary(R.string.automatic_appsno);
    }
 else {
      appnos_preference.goDefault(String.format(getResources().getString(R.string.summary_stats_widget_appsno_preference),appnos_preference.getValue()));
      appnos_ls_preference.goDefault(String.format(getResources().getString(R.string.summary_stats_widget_appsno_ls_preference),appnos_ls_preference.getValue()));
    }
  }
 else   if (preference.getKey().equals(Settings.STATS_WIDGET_APPSNO_PREFERENCE)) {
    appnos_preference.goDefault(String.format(getResources().getString(R.string.summary_stats_widget_appsno_preference),(String)newValue));
  }
 else   if (preference.getKey().equals(Settings.STATS_WIDGET_APPSNO_LS_PREFERENCE)) {
    appnos_ls_preference.goDefault(String.format(getResources().getString(R.string.summary_stats_widget_appsno_ls_preference),(String)newValue));
  }
 else   if (preference.getKey().equals(Settings.ICON_COLOR_PREFERENCE)) {
    String hex=ColorPickerPreference.convertToARGB(Integer.valueOf(String.valueOf(newValue)));
    preference.setSummary(hex);
  }
 else   if (preference.getKey().equals(Settings.ICON_SIZE_PREFERENCE)) {
    icon_size_preference.goDefault(String.format(getResources().getString(R.string.summary_icon_size_preference),(String)newValue));
  }
  return true;
}",0.995820562830872
80588,"/** 
 * Creates the i/o handler and nio acceptor; ports and addresses are bound.
 * @throws IOException
 */
@Override public void afterPropertiesSet() throws Exception {
  acceptor=new NioSocketAcceptor(ioThreads);
  SocketSessionConfig sessionConf=acceptor.getSessionConfig();
  sessionConf.setReuseAddress(true);
  sessionConf.setTcpNoDelay(true);
  sessionConf.setSendBufferSize(sendBufferSize);
  sessionConf.setReadBufferSize(receiveBufferSize);
  acceptor.setCloseOnDeactivation(true);
  acceptor.setHandler(ioHandler);
  acceptor.setBacklog(64);
  acceptor.setReuseAddress(true);
  if (ioHandler == null) {
    ioHandler=new WebSocketHandler();
  }
  log.trace(""String_Node_Str"",ioHandler);
  DefaultIoFilterChainBuilder chain=acceptor.getFilterChain();
  SslFilter sslFilter=null;
  if (secureConfig != null) {
    try {
      sslFilter=secureConfig.getSslFilter();
      chain.addFirst(""String_Node_Str"",sslFilter);
    }
 catch (    Exception e) {
      log.warn(""String_Node_Str"",e);
    }
  }
  if (log.isTraceEnabled()) {
    chain.addLast(""String_Node_Str"",new LoggingFilter());
  }
  chain.addLast(""String_Node_Str"",new ProtocolCodecFilter(new WebSocketCodecFactory()));
  if (addresses.isEmpty()) {
    if (sslFilter != null) {
      log.info(""String_Node_Str"",port);
    }
 else {
      log.info(""String_Node_Str"",port);
    }
    acceptor.bind(new InetSocketAddress(port));
  }
 else {
    if (sslFilter != null) {
      log.info(""String_Node_Str"",addresses);
    }
 else {
      log.info(""String_Node_Str"",addresses);
    }
    try {
      Set<InetSocketAddress> socketAddresses=new HashSet<InetSocketAddress>();
      for (      String addr : addresses) {
        if (addr.indexOf(':') != -1) {
          String[] parts=addr.split(""String_Node_Str"");
          socketAddresses.add(new InetSocketAddress(parts[0],Integer.valueOf(parts[1])));
        }
 else {
          socketAddresses.add(new InetSocketAddress(addr,port));
        }
      }
      log.debug(""String_Node_Str"",socketAddresses.toString());
      acceptor.bind(socketAddresses);
    }
 catch (    Exception e) {
      log.error(""String_Node_Str"",e);
    }
  }
  log.info(""String_Node_Str"",(isSecure() ? ""String_Node_Str"" : ""String_Node_Str""));
  if (log.isDebugEnabled()) {
    log.debug(""String_Node_Str"",acceptor.getSessionConfig().getSendBufferSize(),acceptor.getSessionConfig().getReadBufferSize());
  }
}","/** 
 * Creates the i/o handler and nio acceptor; ports and addresses are bound.
 * @throws IOException
 */
@Override public void afterPropertiesSet() throws Exception {
  acceptor=new NioSocketAcceptor(ioThreads);
  SocketSessionConfig sessionConf=acceptor.getSessionConfig();
  sessionConf.setReuseAddress(true);
  sessionConf.setTcpNoDelay(true);
  sessionConf.setSendBufferSize(sendBufferSize);
  sessionConf.setReadBufferSize(receiveBufferSize);
  acceptor.setCloseOnDeactivation(true);
  acceptor.setBacklog(64);
  acceptor.setReuseAddress(true);
  if (ioHandler == null) {
    ioHandler=new WebSocketHandler();
  }
  log.trace(""String_Node_Str"",ioHandler);
  acceptor.setHandler(ioHandler);
  DefaultIoFilterChainBuilder chain=acceptor.getFilterChain();
  SslFilter sslFilter=null;
  if (secureConfig != null) {
    try {
      sslFilter=secureConfig.getSslFilter();
      chain.addFirst(""String_Node_Str"",sslFilter);
    }
 catch (    Exception e) {
      log.warn(""String_Node_Str"",e);
    }
  }
  if (log.isTraceEnabled()) {
    chain.addLast(""String_Node_Str"",new LoggingFilter());
  }
  chain.addLast(""String_Node_Str"",new ProtocolCodecFilter(new WebSocketCodecFactory()));
  if (addresses.isEmpty()) {
    if (sslFilter != null) {
      log.info(""String_Node_Str"",port);
    }
 else {
      log.info(""String_Node_Str"",port);
    }
    acceptor.bind(new InetSocketAddress(port));
  }
 else {
    if (sslFilter != null) {
      log.info(""String_Node_Str"",addresses);
    }
 else {
      log.info(""String_Node_Str"",addresses);
    }
    try {
      Set<InetSocketAddress> socketAddresses=new HashSet<InetSocketAddress>();
      for (      String addr : addresses) {
        if (addr.indexOf(':') != -1) {
          String[] parts=addr.split(""String_Node_Str"");
          socketAddresses.add(new InetSocketAddress(parts[0],Integer.valueOf(parts[1])));
        }
 else {
          socketAddresses.add(new InetSocketAddress(addr,port));
        }
      }
      log.debug(""String_Node_Str"",socketAddresses.toString());
      acceptor.bind(socketAddresses);
    }
 catch (    Exception e) {
      log.error(""String_Node_Str"",e);
    }
  }
  log.info(""String_Node_Str"",(isSecure() ? ""String_Node_Str"" : ""String_Node_Str""));
  if (log.isDebugEnabled()) {
    log.debug(""String_Node_Str"",acceptor.getSessionConfig().getSendBufferSize(),acceptor.getSessionConfig().getReadBufferSize());
  }
}",0.9857918930213122
80589,"/** 
 * Decode the in buffer according to the Section 5.2. RFC 6455. If there are multiple websocket dataframes in the buffer, this will parse all and return one complete decoded buffer. <pre> 0                   1                   2                   3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-------+-+-------------+-------------------------------+ |F|R|R|R| opcode|M| Payload len |    Extended payload length    | |I|S|S|S|  (4)  |A|     (7)     |             (16/64)           | |N|V|V|V|       |S|             |   (if payload len==126/127)   | | |1|2|3|       |K|             |                               | +-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - + |     Extended payload length continued, if payload len == 127  | + - - - - - - - - - - - - - - - +-------------------------------+ |                               |Masking-key, if MASK set to 1  | +-------------------------------+-------------------------------+ | Masking-key (continued)       |          Payload Data         | +-------------------------------- - - - - - - - - - - - - - - - + :                     Payload Data continued ...                : + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - + |                     Payload Data continued ...                | +---------------------------------------------------------------+ </pre>
 * @param in
 * @param session
 */
public static void decodeIncommingData(IoBuffer in,IoSession session){
  log.trace(""String_Node_Str"",in);
  DecoderState decoderState=(DecoderState)session.getAttribute(DECODER_STATE_KEY);
  if (decoderState.fin == Byte.MIN_VALUE) {
    byte frameInfo=in.get();
    decoderState.fin=(byte)((frameInfo >>> 7) & 1);
    log.trace(""String_Node_Str"",decoderState.fin);
    decoderState.opCode=(byte)(frameInfo & 0x0f);
    log.trace(""String_Node_Str"",decoderState.opCode);
  }
  if (decoderState.mask == Byte.MIN_VALUE) {
    byte frameInfo2=in.get();
    decoderState.mask=(byte)((frameInfo2 >>> 7) & 1);
    log.trace(""String_Node_Str"",decoderState.mask);
    decoderState.frameLen=(frameInfo2 & (byte)0x7F);
    log.trace(""String_Node_Str"",decoderState.frameLen);
    if (decoderState.frameLen == 126) {
      decoderState.frameLen=in.getShort();
      log.trace(""String_Node_Str"",decoderState.frameLen);
    }
 else     if (decoderState.frameLen == 127) {
      long extendedLen=in.getLong();
      if (extendedLen >= Integer.MAX_VALUE) {
        log.error(""String_Node_Str"",extendedLen);
      }
 else {
        decoderState.frameLen=(int)extendedLen;
      }
      log.trace(""String_Node_Str"",decoderState.frameLen);
    }
  }
  if (decoderState.frameLen + (decoderState.mask == 1 ? 4 : 0) > in.remaining()) {
    log.info(""String_Node_Str"");
  }
 else {
    if (decoderState.mask == 1) {
      byte maskKey[]=new byte[4];
      for (int i=0; i < 4; i++) {
        maskKey[i]=in.get();
      }
      decoderState.payload=new byte[decoderState.frameLen];
      for (int i=0; i < decoderState.frameLen; i++) {
        byte maskedByte=in.get();
        decoderState.payload[i]=(byte)(maskedByte ^ maskKey[i % 4]);
      }
    }
 else {
      decoderState.payload=new byte[decoderState.frameLen];
      in.get(decoderState.payload);
    }
    if (decoderState.fin == 0) {
      IoBuffer fragments=(IoBuffer)session.getAttribute(DECODED_MESSAGE_FRAGMENTS_KEY);
      if (fragments == null) {
        fragments=IoBuffer.allocate(decoderState.frameLen);
        fragments.setAutoExpand(true);
        session.setAttribute(DECODED_MESSAGE_FRAGMENTS_KEY,fragments);
        MessageType messageType=MessageType.CLOSE;
switch (decoderState.opCode) {
case 0:
          messageType=MessageType.CONTINUATION;
        break;
case 1:
      messageType=MessageType.TEXT;
    break;
case 2:
  messageType=MessageType.BINARY;
break;
case 9:
messageType=MessageType.PING;
break;
case 0xa:
messageType=MessageType.PONG;
break;
}
session.setAttribute(DECODED_MESSAGE_TYPE_KEY,messageType);
}
fragments.put(decoderState.payload);
session.removeAttribute(DECODER_STATE_KEY);
}
 else {
WSMessage message=new WSMessage();
MessageType messageType=(MessageType)session.getAttribute(DECODED_MESSAGE_TYPE_KEY);
if (messageType == null) {
switch (decoderState.opCode) {
case 0:
messageType=MessageType.CONTINUATION;
break;
case 1:
messageType=MessageType.TEXT;
break;
case 2:
messageType=MessageType.BINARY;
break;
case 9:
messageType=MessageType.PING;
break;
case 0xa:
messageType=MessageType.PONG;
break;
case 8:
messageType=MessageType.CLOSE;
break;
default :
log.info(""String_Node_Str"",decoderState.opCode);
}
}
message.setMessageType(messageType);
IoBuffer fragments=(IoBuffer)session.removeAttribute(DECODED_MESSAGE_FRAGMENTS_KEY);
if (fragments != null) {
fragments.put(decoderState.payload);
fragments.flip();
message.setPayload(fragments);
}
 else {
message.addPayload(decoderState.payload);
}
session.setAttribute(DECODED_MESSAGE_KEY,message);
session.removeAttribute(DECODER_STATE_KEY);
session.removeAttribute(DECODED_MESSAGE_TYPE_KEY);
}
}
}","/** 
 * Decode the in buffer according to the Section 5.2. RFC 6455. If there are multiple websocket dataframes in the buffer, this will parse all and return one complete decoded buffer. <pre> 0                   1                   2                   3 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 +-+-+-+-+-------+-+-------------+-------------------------------+ |F|R|R|R| opcode|M| Payload len |    Extended payload length    | |I|S|S|S|  (4)  |A|     (7)     |             (16/64)           | |N|V|V|V|       |S|             |   (if payload len==126/127)   | | |1|2|3|       |K|             |                               | +-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - + |     Extended payload length continued, if payload len == 127  | + - - - - - - - - - - - - - - - +-------------------------------+ |                               |Masking-key, if MASK set to 1  | +-------------------------------+-------------------------------+ | Masking-key (continued)       |          Payload Data         | +-------------------------------- - - - - - - - - - - - - - - - + :                     Payload Data continued ...                : + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - + |                     Payload Data continued ...                | +---------------------------------------------------------------+ </pre>
 * @param in
 * @param session
 */
public static void decodeIncommingData(IoBuffer in,IoSession session){
  log.trace(""String_Node_Str"",in);
  DecoderState decoderState=(DecoderState)session.getAttribute(DECODER_STATE_KEY);
  if (decoderState.fin == Byte.MIN_VALUE) {
    byte frameInfo=in.get();
    decoderState.fin=(byte)((frameInfo >>> 7) & 1);
    log.trace(""String_Node_Str"",decoderState.fin);
    decoderState.opCode=(byte)(frameInfo & 0x0f);
    log.trace(""String_Node_Str"",decoderState.opCode);
  }
  if (decoderState.mask == Byte.MIN_VALUE) {
    byte frameInfo2=in.get();
    decoderState.mask=(byte)((frameInfo2 >>> 7) & 1);
    log.trace(""String_Node_Str"",decoderState.mask);
    decoderState.frameLen=(frameInfo2 & (byte)0x7F);
    log.trace(""String_Node_Str"",decoderState.frameLen);
    if (decoderState.frameLen == 126) {
      decoderState.frameLen=in.getUnsignedShort();
      log.trace(""String_Node_Str"",decoderState.frameLen);
    }
 else     if (decoderState.frameLen == 127) {
      long extendedLen=in.getLong();
      if (extendedLen >= Integer.MAX_VALUE) {
        log.error(""String_Node_Str"",extendedLen);
      }
 else {
        decoderState.frameLen=(int)extendedLen;
      }
      log.trace(""String_Node_Str"",decoderState.frameLen);
    }
  }
  if (decoderState.frameLen + (decoderState.mask == 1 ? 4 : 0) > in.remaining()) {
    log.info(""String_Node_Str"");
  }
 else {
    if (decoderState.mask == 1) {
      byte maskKey[]=new byte[4];
      for (int i=0; i < 4; i++) {
        maskKey[i]=in.get();
      }
      decoderState.payload=new byte[decoderState.frameLen];
      for (int i=0; i < decoderState.frameLen; i++) {
        byte maskedByte=in.get();
        decoderState.payload[i]=(byte)(maskedByte ^ maskKey[i % 4]);
      }
    }
 else {
      decoderState.payload=new byte[decoderState.frameLen];
      in.get(decoderState.payload);
    }
    if (decoderState.fin == 0) {
      IoBuffer fragments=(IoBuffer)session.getAttribute(DECODED_MESSAGE_FRAGMENTS_KEY);
      if (fragments == null) {
        fragments=IoBuffer.allocate(decoderState.frameLen);
        fragments.setAutoExpand(true);
        session.setAttribute(DECODED_MESSAGE_FRAGMENTS_KEY,fragments);
        MessageType messageType=MessageType.CLOSE;
switch (decoderState.opCode) {
case 0:
          messageType=MessageType.CONTINUATION;
        break;
case 1:
      messageType=MessageType.TEXT;
    break;
case 2:
  messageType=MessageType.BINARY;
break;
case 9:
messageType=MessageType.PING;
break;
case 0xa:
messageType=MessageType.PONG;
break;
}
session.setAttribute(DECODED_MESSAGE_TYPE_KEY,messageType);
}
fragments.put(decoderState.payload);
session.removeAttribute(DECODER_STATE_KEY);
}
 else {
WSMessage message=new WSMessage();
MessageType messageType=(MessageType)session.getAttribute(DECODED_MESSAGE_TYPE_KEY);
if (messageType == null) {
switch (decoderState.opCode) {
case 0:
messageType=MessageType.CONTINUATION;
break;
case 1:
messageType=MessageType.TEXT;
break;
case 2:
messageType=MessageType.BINARY;
break;
case 9:
messageType=MessageType.PING;
break;
case 0xa:
messageType=MessageType.PONG;
break;
case 8:
messageType=MessageType.CLOSE;
break;
default :
log.info(""String_Node_Str"",decoderState.opCode);
}
}
message.setMessageType(messageType);
IoBuffer fragments=(IoBuffer)session.removeAttribute(DECODED_MESSAGE_FRAGMENTS_KEY);
if (fragments != null) {
fragments.put(decoderState.payload);
fragments.flip();
message.setPayload(fragments);
}
 else {
message.addPayload(decoderState.payload);
}
session.setAttribute(DECODED_MESSAGE_KEY,message);
session.removeAttribute(DECODER_STATE_KEY);
session.removeAttribute(DECODED_MESSAGE_TYPE_KEY);
}
}
}",0.9992072929052715
80590,"@Override public NodeRef insertPDF(NodeRef targetNodeRef,Map<String,Serializable> params){
  PDDocument pdf=null;
  PDDocument insertContentPDF=null;
  InputStream is=null;
  InputStream cis=null;
  File tempDir=null;
  ContentWriter writer=null;
  NodeRef destinationNode=null;
  try {
    ContentReader targetReader=getReader(targetNodeRef);
    ContentReader insertReader=getReader((NodeRef)params.get(PARAM_TARGET_NODE));
    int insertAt=Integer.valueOf((String)params.get(PARAM_PAGE)).intValue();
    Boolean inplace=Boolean.valueOf(String.valueOf(params.get(PARAM_INPLACE)));
    is=targetReader.getContentInputStream();
    cis=insertReader.getContentInputStream();
    pdf=PDDocument.load(is);
    insertContentPDF=PDDocument.load(cis);
    Splitter splitter=new Splitter();
    List<PDDocument> pdfs=splitter.split(pdf);
    PDFMergerUtility merger=new PDFMergerUtility();
    PDDocument newDocument=new PDDocument();
    for (int i=0; i < pdfs.size(); i++) {
      if (i == insertAt - 1) {
        merger.appendDocument(newDocument,insertContentPDF);
      }
      merger.appendDocument(newDocument,(PDDocument)pdfs.get(i));
    }
    merger.setDestinationFileName(params.get(PARAM_DESTINATION_NAME).toString());
    merger.mergeDocuments();
    File alfTempDir=TempFileProvider.getTempDir();
    tempDir=new File(alfTempDir.getPath() + File.separatorChar + targetNodeRef.getId());
    tempDir.mkdir();
    String fileName=params.get(PARAM_DESTINATION_NAME).toString();
    PDDocument completePDF=newDocument;
    completePDF.save(tempDir + ""String_Node_Str"" + File.separatorChar+ fileName+ FILE_EXTENSION);
    try {
      completePDF.close();
      newDocument.close();
    }
 catch (    IOException e) {
      throw new AlfrescoRuntimeException(e.getMessage(),e);
    }
    for (    File file : tempDir.listFiles()) {
      try {
        if (file.isFile()) {
          destinationNode=createDestinationNode(file.getName(),(NodeRef)params.get(PARAM_DESTINATION_FOLDER),targetNodeRef,inplace);
          writer=cs.getWriter(destinationNode,ContentModel.PROP_CONTENT,true);
          writer.setEncoding(targetReader.getEncoding());
          writer.setMimetype(FILE_MIMETYPE);
          writer.putContent(file);
          file.delete();
        }
      }
 catch (      FileExistsException e) {
        throw new AlfrescoRuntimeException(""String_Node_Str"",e);
      }
    }
  }
 catch (  COSVisitorException e) {
    throw new AlfrescoRuntimeException(e.getMessage(),e);
  }
catch (  IOException e) {
    throw new AlfrescoRuntimeException(e.getMessage(),e);
  }
 finally {
    if (pdf != null) {
      try {
        pdf.close();
      }
 catch (      IOException e) {
        throw new AlfrescoRuntimeException(e.getMessage(),e);
      }
    }
    if (is != null) {
      try {
        is.close();
      }
 catch (      IOException e) {
        throw new AlfrescoRuntimeException(e.getMessage(),e);
      }
    }
    if (tempDir != null) {
      tempDir.delete();
    }
  }
  return destinationNode;
}","@Override public NodeRef insertPDF(NodeRef targetNodeRef,Map<String,Serializable> params){
  PDDocument pdf=null;
  PDDocument insertContentPDF=null;
  InputStream is=null;
  InputStream cis=null;
  File tempDir=null;
  ContentWriter writer=null;
  NodeRef destinationNode=null;
  try {
    ContentReader targetReader=getReader(targetNodeRef);
    ContentReader insertReader=getReader((NodeRef)params.get(PARAM_INSERT_CONTENT));
    int insertAt=Integer.valueOf((String)params.get(PARAM_PAGE)).intValue();
    Boolean inplace=Boolean.valueOf(String.valueOf(params.get(PARAM_INPLACE)));
    is=targetReader.getContentInputStream();
    cis=insertReader.getContentInputStream();
    pdf=PDDocument.load(is);
    insertContentPDF=PDDocument.load(cis);
    Splitter splitter=new Splitter();
    List<PDDocument> pdfs=splitter.split(pdf);
    PDFMergerUtility merger=new PDFMergerUtility();
    PDDocument newDocument=new PDDocument();
    for (int i=0; i < pdfs.size(); i++) {
      if (i == insertAt - 1) {
        merger.appendDocument(newDocument,insertContentPDF);
      }
      merger.appendDocument(newDocument,(PDDocument)pdfs.get(i));
    }
    merger.setDestinationFileName(params.get(PARAM_DESTINATION_NAME).toString());
    merger.mergeDocuments();
    File alfTempDir=TempFileProvider.getTempDir();
    tempDir=new File(alfTempDir.getPath() + File.separatorChar + targetNodeRef.getId());
    tempDir.mkdir();
    String fileName=params.get(PARAM_DESTINATION_NAME).toString();
    PDDocument completePDF=newDocument;
    completePDF.save(tempDir + ""String_Node_Str"" + File.separatorChar+ fileName+ FILE_EXTENSION);
    try {
      completePDF.close();
      newDocument.close();
    }
 catch (    IOException e) {
      throw new AlfrescoRuntimeException(e.getMessage(),e);
    }
    for (    File file : tempDir.listFiles()) {
      try {
        if (file.isFile()) {
          destinationNode=createDestinationNode(file.getName(),(NodeRef)params.get(PARAM_DESTINATION_FOLDER),targetNodeRef,inplace);
          writer=cs.getWriter(destinationNode,ContentModel.PROP_CONTENT,true);
          writer.setEncoding(targetReader.getEncoding());
          writer.setMimetype(FILE_MIMETYPE);
          writer.putContent(file);
          file.delete();
        }
      }
 catch (      FileExistsException e) {
        throw new AlfrescoRuntimeException(""String_Node_Str"",e);
      }
    }
  }
 catch (  COSVisitorException e) {
    throw new AlfrescoRuntimeException(e.getMessage(),e);
  }
catch (  IOException e) {
    throw new AlfrescoRuntimeException(e.getMessage(),e);
  }
 finally {
    if (pdf != null) {
      try {
        pdf.close();
      }
 catch (      IOException e) {
        throw new AlfrescoRuntimeException(e.getMessage(),e);
      }
    }
    if (is != null) {
      try {
        is.close();
      }
 catch (      IOException e) {
        throw new AlfrescoRuntimeException(e.getMessage(),e);
      }
    }
    if (tempDir != null) {
      tempDir.delete();
    }
  }
  return destinationNode;
}",0.9968475194956032
80591,"private NodeRef subsetPDFDocument(NodeRef targetNodeRef,Map<String,Serializable> params,String pages,boolean delete){
  InputStream is=null;
  File tempDir=null;
  ContentWriter writer=null;
  PdfReader pdfReader=null;
  NodeRef destinationNode=null;
  try {
    ContentReader targetReader=getReader(targetNodeRef);
    is=targetReader.getContentInputStream();
    File alfTempDir=TempFileProvider.getTempDir();
    tempDir=new File(alfTempDir.getPath() + File.separatorChar + targetNodeRef.getId());
    tempDir.mkdir();
    Boolean inplace=Boolean.valueOf(String.valueOf(params.get(PARAM_INPLACE)));
    String fileName=getFilename(params,targetNodeRef);
    File file=new File(tempDir,ffs.getFileInfo(targetNodeRef).getName());
    pdfReader=new PdfReader(is);
    Document doc=new Document(pdfReader.getPageSizeWithRotation(1));
    PdfCopy copy=new PdfCopy(doc,new FileOutputStream(file));
    doc.open();
    List<Integer> pagelist=parsePageList(pages);
    for (int pageNum=1; pageNum <= pdfReader.getNumberOfPages(); pageNum++) {
      if (pagelist.contains(pageNum) && !delete) {
        copy.addPage(copy.getImportedPage(pdfReader,pageNum));
      }
    }
    doc.close();
    destinationNode=createDestinationNode(fileName,(NodeRef)params.get(PARAM_DESTINATION_FOLDER),targetNodeRef,inplace);
    writer=cs.getWriter(destinationNode,ContentModel.PROP_CONTENT,true);
    writer.setEncoding(targetReader.getEncoding());
    writer.setMimetype(FILE_MIMETYPE);
    writer.putContent(file);
    file.delete();
  }
 catch (  IOException e) {
    throw new AlfrescoRuntimeException(e.getMessage(),e);
  }
catch (  DocumentException e) {
    throw new AlfrescoRuntimeException(e.getMessage(),e);
  }
catch (  Exception e) {
    throw new AlfrescoRuntimeException(e.getMessage(),e);
  }
 finally {
    if (pdfReader != null) {
      pdfReader.close();
    }
    if (is != null) {
      try {
        is.close();
      }
 catch (      IOException e) {
        throw new AlfrescoRuntimeException(e.getMessage(),e);
      }
    }
    if (tempDir != null) {
      tempDir.delete();
    }
  }
  return destinationNode;
}","private NodeRef subsetPDFDocument(NodeRef targetNodeRef,Map<String,Serializable> params,String pages,boolean delete){
  InputStream is=null;
  File tempDir=null;
  ContentWriter writer=null;
  PdfReader pdfReader=null;
  NodeRef destinationNode=null;
  try {
    ContentReader targetReader=getReader(targetNodeRef);
    is=targetReader.getContentInputStream();
    File alfTempDir=TempFileProvider.getTempDir();
    tempDir=new File(alfTempDir.getPath() + File.separatorChar + targetNodeRef.getId());
    tempDir.mkdir();
    Boolean inplace=Boolean.valueOf(String.valueOf(params.get(PARAM_INPLACE)));
    String fileName=getFilename(params,targetNodeRef);
    File file=new File(tempDir,ffs.getFileInfo(targetNodeRef).getName());
    pdfReader=new PdfReader(is);
    Document doc=new Document(pdfReader.getPageSizeWithRotation(1));
    PdfCopy copy=new PdfCopy(doc,new FileOutputStream(file));
    doc.open();
    List<Integer> pagelist=parsePageList(pages);
    for (int pageNum=1; pageNum <= pdfReader.getNumberOfPages(); pageNum++) {
      if (pagelist.contains(pageNum) && !delete) {
        copy.addPage(copy.getImportedPage(pdfReader,pageNum));
      }
 else       if (!pagelist.contains(pageNum) && delete) {
        copy.addPage(copy.getImportedPage(pdfReader,pageNum));
      }
    }
    doc.close();
    destinationNode=createDestinationNode(fileName,(NodeRef)params.get(PARAM_DESTINATION_FOLDER),targetNodeRef,inplace);
    writer=cs.getWriter(destinationNode,ContentModel.PROP_CONTENT,true);
    writer.setEncoding(targetReader.getEncoding());
    writer.setMimetype(FILE_MIMETYPE);
    writer.putContent(file);
    file.delete();
  }
 catch (  IOException e) {
    throw new AlfrescoRuntimeException(e.getMessage(),e);
  }
catch (  DocumentException e) {
    throw new AlfrescoRuntimeException(e.getMessage(),e);
  }
catch (  Exception e) {
    throw new AlfrescoRuntimeException(e.getMessage(),e);
  }
 finally {
    if (pdfReader != null) {
      pdfReader.close();
    }
    if (is != null) {
      try {
        is.close();
      }
 catch (      IOException e) {
        throw new AlfrescoRuntimeException(e.getMessage(),e);
      }
    }
    if (tempDir != null) {
      tempDir.delete();
    }
  }
  return destinationNode;
}",0.9706556625401191
80592,"@Override public void insertPDF(NodeRef targetNodeRef,Map<String,Serializable> params){
  PDDocument pdf=null;
  PDDocument insertContentPDF=null;
  InputStream is=null;
  InputStream cis=null;
  File tempDir=null;
  ContentWriter writer=null;
  try {
    ContentReader targetReader=getReader(targetNodeRef);
    ContentReader insertReader=getReader((NodeRef)params.get(PARAM_TARGET_NODE));
    int insertAt=Integer.valueOf((String)params.get(PARAM_INSERT_AT_PAGE)).intValue();
    is=targetReader.getContentInputStream();
    cis=insertReader.getContentInputStream();
    pdf=PDDocument.load(is);
    insertContentPDF=PDDocument.load(cis);
    Splitter splitter=new Splitter();
    splitter.setSplitAtPage(insertAt - 1);
    List<PDDocument> pdfs=splitter.split(pdf);
    PDFMergerUtility merger=new PDFMergerUtility();
    merger.appendDocument((PDDocument)pdfs.get(0),insertContentPDF);
    merger.appendDocument((PDDocument)pdfs.get(0),(PDDocument)pdfs.get(1));
    merger.setDestinationFileName(params.get(PARAM_DESTINATION_NAME).toString());
    merger.mergeDocuments();
    File alfTempDir=TempFileProvider.getTempDir();
    tempDir=new File(alfTempDir.getPath() + File.separatorChar + targetNodeRef.getId());
    tempDir.mkdir();
    String fileName=getFilename(params,targetNodeRef);
    Boolean inplace=Boolean.valueOf(String.valueOf(params.get(PARAM_INPLACE)));
    PDDocument completePDF=(PDDocument)pdfs.get(0);
    completePDF.save(tempDir + ""String_Node_Str"" + File.separatorChar+ fileName+ FILE_EXTENSION);
    try {
      completePDF.close();
    }
 catch (    IOException e) {
      throw new AlfrescoRuntimeException(e.getMessage(),e);
    }
    for (    File file : tempDir.listFiles()) {
      try {
        if (file.isFile()) {
          NodeRef destinationNode=createDestinationNode(file.getName(),(NodeRef)params.get(PARAM_DESTINATION_FOLDER),targetNodeRef,inplace);
          writer=cs.getWriter(destinationNode,ContentModel.PROP_CONTENT,true);
          writer.setEncoding(targetReader.getEncoding());
          writer.setMimetype(FILE_MIMETYPE);
          writer.putContent(file);
          file.delete();
        }
      }
 catch (      FileExistsException e) {
        throw new AlfrescoRuntimeException(""String_Node_Str"",e);
      }
    }
  }
 catch (  COSVisitorException e) {
    throw new AlfrescoRuntimeException(e.getMessage(),e);
  }
catch (  IOException e) {
    throw new AlfrescoRuntimeException(e.getMessage(),e);
  }
 finally {
    if (pdf != null) {
      try {
        pdf.close();
      }
 catch (      IOException e) {
        throw new AlfrescoRuntimeException(e.getMessage(),e);
      }
    }
    if (is != null) {
      try {
        is.close();
      }
 catch (      IOException e) {
        throw new AlfrescoRuntimeException(e.getMessage(),e);
      }
    }
    if (tempDir != null) {
      tempDir.delete();
    }
  }
}","@Override public void insertPDF(NodeRef targetNodeRef,Map<String,Serializable> params){
  PDDocument pdf=null;
  PDDocument insertContentPDF=null;
  InputStream is=null;
  InputStream cis=null;
  File tempDir=null;
  ContentWriter writer=null;
  try {
    ContentReader targetReader=getReader(targetNodeRef);
    ContentReader insertReader=getReader((NodeRef)params.get(PARAM_TARGET_NODE));
    int insertAt=Integer.valueOf((String)params.get(PARAM_INSERT_AT_PAGE)).intValue();
    is=targetReader.getContentInputStream();
    cis=insertReader.getContentInputStream();
    pdf=PDDocument.load(is);
    insertContentPDF=PDDocument.load(cis);
    Splitter splitter=new Splitter();
    List<PDDocument> pdfs=splitter.split(pdf);
    PDFMergerUtility merger=new PDFMergerUtility();
    PDDocument newDocument=new PDDocument();
    for (int i=0; i < pdfs.size(); i++) {
      if (i == insertAt - 1) {
        merger.appendDocument(newDocument,insertContentPDF);
      }
      merger.appendDocument(newDocument,(PDDocument)pdfs.get(i));
    }
    merger.setDestinationFileName(params.get(PARAM_DESTINATION_NAME).toString());
    merger.mergeDocuments();
    File alfTempDir=TempFileProvider.getTempDir();
    tempDir=new File(alfTempDir.getPath() + File.separatorChar + targetNodeRef.getId());
    tempDir.mkdir();
    String fileName=params.get(PARAM_DESTINATION_NAME).toString();
    Boolean inplace=Boolean.valueOf(String.valueOf(params.get(PARAM_INPLACE)));
    PDDocument completePDF=newDocument;
    completePDF.save(tempDir + ""String_Node_Str"" + File.separatorChar+ fileName+ FILE_EXTENSION);
    try {
      completePDF.close();
      newDocument.close();
    }
 catch (    IOException e) {
      throw new AlfrescoRuntimeException(e.getMessage(),e);
    }
    for (    File file : tempDir.listFiles()) {
      try {
        if (file.isFile()) {
          NodeRef destinationNode=createDestinationNode(file.getName(),(NodeRef)params.get(PARAM_DESTINATION_FOLDER),targetNodeRef,inplace);
          writer=cs.getWriter(destinationNode,ContentModel.PROP_CONTENT,true);
          writer.setEncoding(targetReader.getEncoding());
          writer.setMimetype(FILE_MIMETYPE);
          writer.putContent(file);
          file.delete();
        }
      }
 catch (      FileExistsException e) {
        throw new AlfrescoRuntimeException(""String_Node_Str"",e);
      }
    }
  }
 catch (  COSVisitorException e) {
    throw new AlfrescoRuntimeException(e.getMessage(),e);
  }
catch (  IOException e) {
    throw new AlfrescoRuntimeException(e.getMessage(),e);
  }
 finally {
    if (pdf != null) {
      try {
        pdf.close();
      }
 catch (      IOException e) {
        throw new AlfrescoRuntimeException(e.getMessage(),e);
      }
    }
    if (is != null) {
      try {
        is.close();
      }
 catch (      IOException e) {
        throw new AlfrescoRuntimeException(e.getMessage(),e);
      }
    }
    if (tempDir != null) {
      tempDir.delete();
    }
  }
}",0.9178082191780822
80593,"/** 
 * Add parameter definitions
 */
@Override protected void addParameterDefinitions(List<ParameterDefinition> paramList){
  paramList.add(new ParameterDefinitionImpl(PDFToolkitConstants.PARAM_DESTINATION_FOLDER,DataTypeDefinition.NODE_REF,false,getParamDisplayLabel(PDFToolkitConstants.PARAM_DESTINATION_FOLDER)));
  paramList.add(new ParameterDefinitionImpl(PDFToolkitConstants.PARAM_EXTRACT_PAGES,DataTypeDefinition.TEXT,true,getParamDisplayLabel(PDFToolkitConstants.PARAM_DELETE_PAGES)));
  paramList.add(new ParameterDefinitionImpl(PDFToolkitConstants.PARAM_DESTINATION_NAME,DataTypeDefinition.TEXT,false,getParamDisplayLabel(PDFToolkitConstants.PARAM_DESTINATION_NAME)));
  super.addParameterDefinitions(paramList);
}","/** 
 * Add parameter definitions
 */
@Override protected void addParameterDefinitions(List<ParameterDefinition> paramList){
  paramList.add(new ParameterDefinitionImpl(PDFToolkitConstants.PARAM_DESTINATION_FOLDER,DataTypeDefinition.NODE_REF,true,getParamDisplayLabel(PDFToolkitConstants.PARAM_DESTINATION_FOLDER)));
  paramList.add(new ParameterDefinitionImpl(PDFToolkitConstants.PARAM_EXTRACT_PAGES,DataTypeDefinition.TEXT,true,getParamDisplayLabel(PDFToolkitConstants.PARAM_DELETE_PAGES)));
  paramList.add(new ParameterDefinitionImpl(PDFToolkitConstants.PARAM_DESTINATION_NAME,DataTypeDefinition.TEXT,true,getParamDisplayLabel(PDFToolkitConstants.PARAM_DESTINATION_NAME)));
  super.addParameterDefinitions(paramList);
}",0.9903314917127072
80594,"@Override protected void executeImpl(Action action,NodeRef actionedUponNodeRef){
  NodeRef result=pdfToolkitService.deletePagesFromPDF(actionedUponNodeRef,action.getParameterValues());
  action.setParameterValue(PARAM_RESULT,result);
}","@Override protected void executeImpl(Action action,NodeRef actionedUponNodeRef){
  NodeRef result=pdfToolkitService.extractPagesFromPDF(actionedUponNodeRef,action.getParameterValues());
  action.setParameterValue(PARAM_RESULT,result);
}",0.9723991507430998
80595,"/** 
 * Create a rectangle for the visible signature using the selected position and signature size
 * @param position
 * @param width
 * @param height
 * @return
 */
private Rectangle positionSignature(String position,Rectangle pageRect,int width,int height){
  float pageHeight=pageRect.getHeight();
  float pageWidth=pageRect.getWidth();
  Rectangle r=null;
  if (position.equals(POSITION_BOTTOMLEFT)) {
    r=new Rectangle(0,height,width,0);
  }
 else   if (position.equals(POSITION_BOTTOMRIGHT)) {
    r=new Rectangle(pageWidth - width,pageHeight,pageWidth,pageHeight - height);
  }
 else   if (position.equals(POSITION_TOPLEFT)) {
    r=new Rectangle(0,pageHeight,width,pageHeight - height);
  }
 else   if (position.equals(POSITION_TOPRIGHT)) {
    r=new Rectangle(pageWidth - width,height,pageWidth,0);
  }
 else   if (position.equals(POSITION_CENTER)) {
    r=new Rectangle((pageWidth / 2) - (width / 2),(pageHeight / 2) - (height / 2),(pageWidth / 2) + (width / 2),(pageHeight / 2) + (height / 2));
  }
  return r;
}","/** 
 * Create a rectangle for the visible signature using the selected position and signature size
 * @param position
 * @param width
 * @param height
 * @return
 */
private Rectangle positionSignature(String position,Rectangle pageRect,int width,int height){
  float pageHeight=pageRect.getHeight();
  float pageWidth=pageRect.getWidth();
  Rectangle r=null;
  if (position.equals(POSITION_BOTTOMLEFT)) {
    r=new Rectangle(0,height,width,0);
  }
 else   if (position.equals(POSITION_BOTTOMRIGHT)) {
    r=new Rectangle(pageWidth - width,height,pageWidth,0);
  }
 else   if (position.equals(POSITION_TOPLEFT)) {
    r=new Rectangle(0,pageHeight,width,pageHeight - height);
  }
 else   if (position.equals(POSITION_TOPRIGHT)) {
    r=new Rectangle(pageWidth - width,pageHeight,pageWidth,pageHeight - height);
  }
 else   if (position.equals(POSITION_CENTER)) {
    r=new Rectangle((pageWidth / 2) - (width / 2),(pageHeight / 2) - (height / 2),(pageWidth / 2) + (width / 2),(pageHeight / 2) + (height / 2));
  }
  return r;
}",0.9746588693957114
80596,"/** 
 * Determines whether or not a watermark should be applied to a given page
 * @param pages
 * @param current
 * @param numpages
 * @return
 */
protected boolean checkPage(String pages,int current,int numpages){
  boolean markPage=false;
  if (pages.equals(PAGE_EVEN) || pages.equals(PAGE_ODD)) {
    if (current % 2 == 0) {
      markPage=true;
    }
  }
 else   if (pages.equals(PAGE_ODD)) {
    if (current % 2 != 0) {
      markPage=true;
    }
  }
 else   if (pages.equals(PAGE_FIRST)) {
    if (current == 1) {
      markPage=true;
    }
  }
 else   if (pages.equals(PAGE_LAST)) {
    if (current == numpages) {
      markPage=true;
    }
  }
 else {
    markPage=true;
  }
  return markPage;
}","/** 
 * Determines whether or not a watermark should be applied to a given page
 * @param pages
 * @param current
 * @param numpages
 * @return
 */
protected boolean checkPage(String pages,int current,int numpages){
  boolean markPage=false;
  if (pages.equals(PAGE_EVEN)) {
    if (current % 2 == 0) {
      markPage=true;
    }
  }
 else   if (pages.equals(PAGE_ODD)) {
    if (current % 2 != 0) {
      markPage=true;
    }
  }
 else   if (pages.equals(PAGE_FIRST)) {
    if (current == 1) {
      markPage=true;
    }
  }
 else   if (pages.equals(PAGE_LAST)) {
    if (current == numpages) {
      markPage=true;
    }
  }
 else {
    markPage=true;
  }
  return markPage;
}",0.9811866859623734
80597,"/** 
 * actual implementation for canonicalization
 * @param variant
 * @param end
 * @return
 */
private List<Variant> canonicalizeVariant(Variant variant,boolean end){
  List<Variant> variantList=new ArrayList<>();
  boolean noSplit=false;
  if (variant.getType() == VariantOverallType.SNP) {
    noSplit=true;
  }
  if (variant.getCompositions() == null && variant.getGoodPaternal() == 0 && variant.getGoodMaternal() == 0) {
    noSplit=true;
  }
  if (variant.getGoodPaternal() != 0 && !canonicalizableFlexSeqTypes.contains(variant.getAlt(variant.getGoodPaternal()).getSeqType())) {
    noSplit=true;
  }
  if (variant.getGoodMaternal() != 0 && !canonicalizableFlexSeqTypes.contains(variant.getAlt(variant.getGoodMaternal()).getSeqType())) {
    noSplit=true;
  }
  if (variant.getGoodPaternal() != 0 && variant.getAlt(variant.getGoodPaternal()).length() == 0 && variant.getReference().length == 0) {
    noSplit=true;
  }
  if (variant.getGoodMaternal() > 0 && variant.getAlt(variant.getGoodMaternal()).length() == 0 && variant.getReference().length == 0) {
    noSplit=true;
  }
  if (noSplit) {
    variantList.add(variant);
    return variantList;
  }
  if (variant.getCompositions() != null) {
    for (    Variant c : variant.getCompositions()) {
      variantList.addAll(canonicalizeVariant(new Variant(c),end));
    }
    return variantList;
  }
  Variant.Builder template=new Variant.Builder().chr(variant.getChr()).isPhased(true).varId(variant.getVariantId()).filter(VCFparser.DEFAULT_FILTER).refDeleted(""String_Node_Str"");
  if (variant.getType(variant.getGoodMaternal()) == VariantType.Translocation_Duplication || variant.getType(variant.getGoodMaternal()) == VariantType.Interspersed_Duplication || variant.getType(variant.getGoodPaternal()) == VariantType.Translocation_Duplication || variant.getType(variant.getGoodPaternal()) == VariantType.Interspersed_Duplication) {
    for (int parentIndex=0; parentIndex < 2; parentIndex++) {
      int allele=variant.getAllele(parentIndex);
      if (variant.getType(allele) == VariantType.Reference)       continue;
      byte[] phase=new byte[2];
      phase[parentIndex]=1;
      if (variant.getType(allele) == VariantType.Translocation_Duplication || variant.getType(allele) == VariantType.Interspersed_Duplication) {
        boolean isInversed=variant.isInversed();
        Alt alt1=new Alt();
        alt1.setBreakend(new Alt.Breakend(variant.getReference().clone(),variant.getChr2(allele),isInversed ? variant.getEnd2(allele) : variant.getPos2(allele),true,!isInversed));
        variantList.add(template.pos(variant.getPos() - 1).referenceAlleleLength(0).ref(new byte[]{'N'}).alts(new Alt[]{alt1}).phase(phase).build());
        Alt alt2=new Alt();
        alt2.setBreakend(new Alt.Breakend(ambiguousBase,variant.getChr2(parentIndex),isInversed ? variant.getPos2(parentIndex) : variant.getEnd2(parentIndex),false,isInversed));
        variantList.add(template.pos(variant.getPos()).referenceAlleleLength(0).ref(new byte[]{'N'}).alts(new Alt[]{alt2}).phase(phase).build());
      }
      variant.setAllele(parentIndex,(byte)0);
    }
  }
 else   if (variant.getType(variant.getGoodMaternal()) == VariantType.Translocation_Deletion || variant.getType(variant.getGoodPaternal()) == VariantType.Translocation_Deletion) {
    for (int parentIndex=0; parentIndex < 2; parentIndex++) {
      int allele=variant.getAllele(parentIndex);
      if (variant.getType(allele) == VariantType.Reference)       continue;
      byte[] phase=new byte[2];
      phase[parentIndex]=1;
      if (variant.getType(allele) == VariantType.Translocation_Deletion) {
        Alt alt1=new Alt();
        alt1.setBreakend(new Alt.Breakend(variant.getReference().clone(),variant.getChr(),variant.getPos() + variant.getReferenceAlleleLength(),true,true));
        variantList.add(template.pos(variant.getPos() - 1).referenceAlleleLength(0).ref(new byte[]{'N'}).alts(new Alt[]{alt1}).phase(phase).build());
      }
      variant.setAllele(parentIndex,(byte)0);
    }
  }
 else   if (variant.getType(variant.getGoodPaternal()) != VariantType.Reference && variant.getType(variant.getGoodMaternal()) != VariantType.Reference) {
    int[] alleleNumber={variant.getAllele(0),variant.getAllele(1)};
    byte[][] alternativeAlleleSequence={variant.getAlt(alleleNumber[0]).getSequence(),variant.getAlt(alleleNumber[1]).getSequence()};
    byte[] referenceAlleleSequence=variant.getReference();
    int currentPosition=variant.getPos();
    int minMatchLength=variant.getMinMatchLength();
    if (minMatchLength > 0) {
      referenceAlleleSequence=Arrays.copyOfRange(referenceAlleleSequence,minMatchLength,referenceAlleleSequence.length);
      for (int i=0; i < 2; i++) {
        alternativeAlleleSequence[i]=Arrays.copyOfRange(alternativeAlleleSequence[i],minMatchLength,alternativeAlleleSequence[i].length);
      }
      currentPosition+=minMatchLength;
    }
    int[] alleleLengthDifference={alternativeAlleleSequence[0].length - referenceAlleleSequence.length,alternativeAlleleSequence[1].length - referenceAlleleSequence.length};
    canonicalizeToIndels(variantList,alleleLengthDifference,referenceAlleleSequence,alternativeAlleleSequence,variant,currentPosition,end);
    for (int relativePosition=0; relativePosition < referenceAlleleSequence.length; relativePosition++, currentPosition++) {
      int[] alleleSpecificRelativePosition=new int[2];
      if (end) {
        for (int j=0; j < 2; j++) {
          if (relativePosition < referenceAlleleSequence.length + alleleLengthDifference[j]) {
            alleleSpecificRelativePosition[j]=relativePosition;
          }
 else {
            alleleSpecificRelativePosition[j]=-1;
          }
        }
      }
 else {
        for (int j=0; j < 2; j++) {
          alleleSpecificRelativePosition[j]=relativePosition + alleleLengthDifference[j];
        }
      }
      if (alleleSpecificRelativePosition[0] < 0 && alleleSpecificRelativePosition[1] < 0) {
      }
 else       if (alleleSpecificRelativePosition[0] >= 0 && alleleSpecificRelativePosition[1] < 0 && alternativeAlleleSequence[0][alleleSpecificRelativePosition[0]] != referenceAlleleSequence[relativePosition]) {
        byte[] phase={1,1};
        Alt alt=new Alt();
        alt.setSeq(new FlexSeq(alternativeAlleleSequence[0][alleleSpecificRelativePosition[0]]));
        variantList.add(template.pos(currentPosition).referenceAlleleLength(1).ref(new byte[]{referenceAlleleSequence[relativePosition]}).alts(new Alt[]{alt}).phase(phase).build());
      }
 else       if (alleleSpecificRelativePosition[0] < 0 && alleleSpecificRelativePosition[1] >= 0 && alternativeAlleleSequence[1][alleleSpecificRelativePosition[1]] != referenceAlleleSequence[relativePosition]) {
        byte[] phase={1,1};
        Alt alt=new Alt();
        alt.setSeq(new FlexSeq(alternativeAlleleSequence[1][alleleSpecificRelativePosition[1]]));
        variantList.add(template.pos(currentPosition).referenceAlleleLength(1).ref(new byte[]{referenceAlleleSequence[relativePosition]}).alts(new Alt[]{alt}).phase(phase).build());
      }
 else       if (alleleSpecificRelativePosition[0] >= 0 && alleleSpecificRelativePosition[1] < 0 && alternativeAlleleSequence[0][alleleSpecificRelativePosition[0]] == referenceAlleleSequence[relativePosition]) {
      }
 else       if (alleleSpecificRelativePosition[0] < 0 && alleleSpecificRelativePosition[1] >= 0 && alternativeAlleleSequence[1][alleleSpecificRelativePosition[1]] == referenceAlleleSequence[relativePosition]) {
      }
 else       if (alternativeAlleleSequence[0][alleleSpecificRelativePosition[0]] == referenceAlleleSequence[relativePosition] && alternativeAlleleSequence[1][alleleSpecificRelativePosition[1]] == referenceAlleleSequence[relativePosition]) {
      }
 else       if (alternativeAlleleSequence[0][alleleSpecificRelativePosition[0]] == alternativeAlleleSequence[1][alleleSpecificRelativePosition[1]]) {
        byte[] phase={1,1};
        Alt alt=new Alt();
        alt.setSeq(new FlexSeq(alternativeAlleleSequence[0][alleleSpecificRelativePosition[0]]));
        variantList.add(template.pos(currentPosition).referenceAlleleLength(1).ref(new byte[]{referenceAlleleSequence[relativePosition]}).alts(new Alt[]{alt}).phase(phase).build());
      }
 else       if (alternativeAlleleSequence[0][alleleSpecificRelativePosition[0]] != referenceAlleleSequence[relativePosition] && alternativeAlleleSequence[1][alleleSpecificRelativePosition[1]] != referenceAlleleSequence[relativePosition]) {
        byte[] phase={1,2};
        Alt[] alts=new Alt[2];
        alts[0]=new Alt();
        alts[1]=new Alt();
        alts[0].setSeq(new FlexSeq(alternativeAlleleSequence[0][alleleSpecificRelativePosition[0]]));
        alts[1].setSeq(new FlexSeq(alternativeAlleleSequence[1][alleleSpecificRelativePosition[1]]));
        variantList.add(template.pos(currentPosition).referenceAlleleLength(1).ref(new byte[]{referenceAlleleSequence[relativePosition]}).alts(alts).phase(phase).build());
      }
 else {
        for (int a=0; a < 2; a++) {
          if (alternativeAlleleSequence[a][alleleSpecificRelativePosition[a]] != referenceAlleleSequence[relativePosition]) {
            byte[] phase={0,0};
            phase[a]=1;
            Alt alt=new Alt();
            alt.setSeq(new FlexSeq(alternativeAlleleSequence[a][alleleSpecificRelativePosition[a]]));
            variantList.add(template.pos(currentPosition).referenceAlleleLength(1).ref(new byte[]{referenceAlleleSequence[relativePosition]}).alts(new Alt[]{alt}).phase(phase).build());
          }
        }
      }
    }
    variant.setAllele(0,(byte)0);
    variant.setAllele(1,(byte)0);
  }
 else {
    for (int alleleIndex=0; alleleIndex < 2; alleleIndex++) {
      int allele=variant.getAllele(alleleIndex);
      if (variant.getType(allele) == VariantType.Complex || variant.getType(allele) == VariantType.MNP || variant.getType(allele) == VariantType.SNP) {
        byte[] alternativeAlleleSequence=variant.getAlt(allele).getSequence();
        byte[] referenceSequence=variant.getReference();
        int currentPosition=variant.getPos();
        int alleleLengthDifference=alternativeAlleleSequence.length - referenceSequence.length;
        if (alleleLengthDifference > 0) {
          byte[] phase={0,0};
          phase[alleleIndex]=1;
          if (end) {
            Alt alt=new Alt();
            alt.setSeq(new FlexSeq(Arrays.copyOfRange(alternativeAlleleSequence,0,alleleLengthDifference)));
            variantList.add(template.pos(currentPosition + referenceSequence.length).referenceAlleleLength(0).ref(new byte[]{'N'}).alts(new Alt[]{alt}).phase(phase).build());
          }
 else {
            Alt alt=new Alt();
            alt.setSeq(new FlexSeq(Arrays.copyOfRange(alternativeAlleleSequence,0,alleleLengthDifference)));
            variantList.add(template.pos(currentPosition).referenceAlleleLength(0).ref(new byte[]{'N'}).alts(new Alt[]{alt}).phase(phase).build());
          }
        }
 else         if (alleleLengthDifference < 0) {
          byte[] phase={0,0};
          phase[alleleIndex]=1;
          if (end) {
            Alt alt=new Alt();
            alt.setSeq(new FlexSeq());
            variantList.add(template.pos(currentPosition + alternativeAlleleSequence.length).referenceAlleleLength(-alleleLengthDifference).ref(Arrays.copyOfRange(referenceSequence,alternativeAlleleSequence.length,alternativeAlleleSequence.length - alleleLengthDifference)).alts(new Alt[]{alt}).phase(phase).build());
          }
 else {
            Alt alt=new Alt();
            alt.setSeq(new FlexSeq());
            variantList.add(template.pos(currentPosition).referenceAlleleLength(-alleleLengthDifference).ref(Arrays.copyOfRange(referenceSequence,0,-alleleLengthDifference)).alts(new Alt[]{alt}).phase(phase).build());
          }
        }
        for (int i=0; i < referenceSequence.length; i++) {
          int idx;
          if (end) {
            if (i < referenceSequence.length + alleleLengthDifference) {
              idx=i;
            }
 else {
              idx=-1;
            }
          }
 else {
            idx=i + alleleLengthDifference;
          }
          if (idx >= 0 && alternativeAlleleSequence[idx] != referenceSequence[i]) {
            byte[] phase={0,0};
            phase[alleleIndex]=1;
            Alt alt=new Alt();
            alt.setSeq(new FlexSeq(alternativeAlleleSequence[idx]));
            variantList.add(template.pos(currentPosition).referenceAlleleLength(1).ref(new byte[]{referenceSequence[i]}).alts(new Alt[]{alt}).phase(phase).build());
          }
          currentPosition++;
        }
        variant.setAllele(alleleIndex,(byte)0);
      }
    }
  }
  if (!variant.isRef()) {
    variantList.add(variant);
  }
  return variantList;
}","/** 
 * actual implementation for canonicalization
 * @param variant
 * @param end
 * @return
 */
private List<Variant> canonicalizeVariant(Variant variant,boolean end){
  List<Variant> variantList=new ArrayList<>();
  boolean noSplit=false;
  if (variant.getType() == VariantOverallType.SNP) {
    noSplit=true;
  }
  if (variant.getCompositions() == null && variant.getGoodPaternal() == 0 && variant.getGoodMaternal() == 0) {
    noSplit=true;
  }
  if (variant.getGoodPaternal() > 0 && !canonicalizableFlexSeqTypes.contains(variant.getAlt(variant.getGoodPaternal()).getSeqType())) {
    noSplit=true;
  }
  if (variant.getGoodMaternal() > 0 && !canonicalizableFlexSeqTypes.contains(variant.getAlt(variant.getGoodMaternal()).getSeqType())) {
    noSplit=true;
  }
  if (variant.getGoodPaternal() > 0 && variant.getAlt(variant.getGoodPaternal()).length() == 0 && variant.getReference().length == 0) {
    noSplit=true;
  }
  if (variant.getGoodMaternal() > 0 && variant.getAlt(variant.getGoodMaternal()).length() == 0 && variant.getReference().length == 0) {
    noSplit=true;
  }
  if (noSplit) {
    variantList.add(variant);
    return variantList;
  }
  if (variant.getCompositions() != null) {
    for (    Variant c : variant.getCompositions()) {
      variantList.addAll(canonicalizeVariant(new Variant(c),end));
    }
    return variantList;
  }
  Variant.Builder template=new Variant.Builder().chr(variant.getChr()).isPhased(true).varId(variant.getVariantId()).filter(VCFparser.DEFAULT_FILTER).refDeleted(""String_Node_Str"");
  if (variant.getType(variant.getGoodMaternal()) == VariantType.Translocation_Duplication || variant.getType(variant.getGoodMaternal()) == VariantType.Interspersed_Duplication || variant.getType(variant.getGoodPaternal()) == VariantType.Translocation_Duplication || variant.getType(variant.getGoodPaternal()) == VariantType.Interspersed_Duplication) {
    for (int parentIndex=0; parentIndex < 2; parentIndex++) {
      int allele=variant.getAllele(parentIndex);
      if (variant.getType(allele) == VariantType.Reference)       continue;
      byte[] phase=new byte[2];
      phase[parentIndex]=1;
      if (variant.getType(allele) == VariantType.Translocation_Duplication || variant.getType(allele) == VariantType.Interspersed_Duplication) {
        boolean isInversed=variant.isInversed();
        Alt alt1=new Alt();
        alt1.setBreakend(new Alt.Breakend(variant.getReference().clone(),variant.getChr2(allele),isInversed ? variant.getEnd2(allele) : variant.getPos2(allele),true,!isInversed));
        variantList.add(template.pos(variant.getPos() - 1).referenceAlleleLength(0).ref(new byte[]{'N'}).alts(new Alt[]{alt1}).phase(phase).build());
        Alt alt2=new Alt();
        alt2.setBreakend(new Alt.Breakend(ambiguousBase,variant.getChr2(parentIndex),isInversed ? variant.getPos2(parentIndex) : variant.getEnd2(parentIndex),false,isInversed));
        variantList.add(template.pos(variant.getPos()).referenceAlleleLength(0).ref(new byte[]{'N'}).alts(new Alt[]{alt2}).phase(phase).build());
      }
      variant.setAllele(parentIndex,(byte)0);
    }
  }
 else   if (variant.getType(variant.getGoodMaternal()) == VariantType.Translocation_Deletion || variant.getType(variant.getGoodPaternal()) == VariantType.Translocation_Deletion) {
    for (int parentIndex=0; parentIndex < 2; parentIndex++) {
      int allele=variant.getAllele(parentIndex);
      if (variant.getType(allele) == VariantType.Reference)       continue;
      byte[] phase=new byte[2];
      phase[parentIndex]=1;
      if (variant.getType(allele) == VariantType.Translocation_Deletion) {
        Alt alt1=new Alt();
        alt1.setBreakend(new Alt.Breakend(variant.getReference().clone(),variant.getChr(),variant.getPos() + variant.getReferenceAlleleLength(),true,true));
        variantList.add(template.pos(variant.getPos() - 1).referenceAlleleLength(0).ref(new byte[]{'N'}).alts(new Alt[]{alt1}).phase(phase).build());
      }
      variant.setAllele(parentIndex,(byte)0);
    }
  }
 else   if (variant.getType(variant.getGoodPaternal()) != VariantType.Reference && variant.getType(variant.getGoodMaternal()) != VariantType.Reference) {
    int[] alleleNumber={variant.getAllele(0),variant.getAllele(1)};
    byte[][] alternativeAlleleSequence={variant.getAlt(alleleNumber[0]).getSequence(),variant.getAlt(alleleNumber[1]).getSequence()};
    byte[] referenceAlleleSequence=variant.getReference();
    int currentPosition=variant.getPos();
    int minMatchLength=variant.getMinMatchLength();
    if (minMatchLength > 0) {
      referenceAlleleSequence=Arrays.copyOfRange(referenceAlleleSequence,minMatchLength,referenceAlleleSequence.length);
      for (int i=0; i < 2; i++) {
        alternativeAlleleSequence[i]=Arrays.copyOfRange(alternativeAlleleSequence[i],minMatchLength,alternativeAlleleSequence[i].length);
      }
      currentPosition+=minMatchLength;
    }
    int[] alleleLengthDifference={alternativeAlleleSequence[0].length - referenceAlleleSequence.length,alternativeAlleleSequence[1].length - referenceAlleleSequence.length};
    canonicalizeToIndels(variantList,alleleLengthDifference,referenceAlleleSequence,alternativeAlleleSequence,variant,currentPosition,end);
    for (int relativePosition=0; relativePosition < referenceAlleleSequence.length; relativePosition++, currentPosition++) {
      int[] alleleSpecificRelativePosition=new int[2];
      if (end) {
        for (int j=0; j < 2; j++) {
          if (relativePosition < referenceAlleleSequence.length + alleleLengthDifference[j]) {
            alleleSpecificRelativePosition[j]=relativePosition;
          }
 else {
            alleleSpecificRelativePosition[j]=-1;
          }
        }
      }
 else {
        for (int j=0; j < 2; j++) {
          alleleSpecificRelativePosition[j]=relativePosition + alleleLengthDifference[j];
        }
      }
      if (alleleSpecificRelativePosition[0] < 0 && alleleSpecificRelativePosition[1] < 0) {
      }
 else       if (alleleSpecificRelativePosition[0] >= 0 && alleleSpecificRelativePosition[1] < 0 && alternativeAlleleSequence[0][alleleSpecificRelativePosition[0]] != referenceAlleleSequence[relativePosition]) {
        byte[] phase={1,1};
        Alt alt=new Alt();
        alt.setSeq(new FlexSeq(alternativeAlleleSequence[0][alleleSpecificRelativePosition[0]]));
        variantList.add(template.pos(currentPosition).referenceAlleleLength(1).ref(new byte[]{referenceAlleleSequence[relativePosition]}).alts(new Alt[]{alt}).phase(phase).build());
      }
 else       if (alleleSpecificRelativePosition[0] < 0 && alleleSpecificRelativePosition[1] >= 0 && alternativeAlleleSequence[1][alleleSpecificRelativePosition[1]] != referenceAlleleSequence[relativePosition]) {
        byte[] phase={1,1};
        Alt alt=new Alt();
        alt.setSeq(new FlexSeq(alternativeAlleleSequence[1][alleleSpecificRelativePosition[1]]));
        variantList.add(template.pos(currentPosition).referenceAlleleLength(1).ref(new byte[]{referenceAlleleSequence[relativePosition]}).alts(new Alt[]{alt}).phase(phase).build());
      }
 else       if (alleleSpecificRelativePosition[0] >= 0 && alleleSpecificRelativePosition[1] < 0 && alternativeAlleleSequence[0][alleleSpecificRelativePosition[0]] == referenceAlleleSequence[relativePosition]) {
      }
 else       if (alleleSpecificRelativePosition[0] < 0 && alleleSpecificRelativePosition[1] >= 0 && alternativeAlleleSequence[1][alleleSpecificRelativePosition[1]] == referenceAlleleSequence[relativePosition]) {
      }
 else       if (alternativeAlleleSequence[0][alleleSpecificRelativePosition[0]] == referenceAlleleSequence[relativePosition] && alternativeAlleleSequence[1][alleleSpecificRelativePosition[1]] == referenceAlleleSequence[relativePosition]) {
      }
 else       if (alternativeAlleleSequence[0][alleleSpecificRelativePosition[0]] == alternativeAlleleSequence[1][alleleSpecificRelativePosition[1]]) {
        byte[] phase={1,1};
        Alt alt=new Alt();
        alt.setSeq(new FlexSeq(alternativeAlleleSequence[0][alleleSpecificRelativePosition[0]]));
        variantList.add(template.pos(currentPosition).referenceAlleleLength(1).ref(new byte[]{referenceAlleleSequence[relativePosition]}).alts(new Alt[]{alt}).phase(phase).build());
      }
 else       if (alternativeAlleleSequence[0][alleleSpecificRelativePosition[0]] != referenceAlleleSequence[relativePosition] && alternativeAlleleSequence[1][alleleSpecificRelativePosition[1]] != referenceAlleleSequence[relativePosition]) {
        byte[] phase={1,2};
        Alt[] alts=new Alt[2];
        alts[0]=new Alt();
        alts[1]=new Alt();
        alts[0].setSeq(new FlexSeq(alternativeAlleleSequence[0][alleleSpecificRelativePosition[0]]));
        alts[1].setSeq(new FlexSeq(alternativeAlleleSequence[1][alleleSpecificRelativePosition[1]]));
        variantList.add(template.pos(currentPosition).referenceAlleleLength(1).ref(new byte[]{referenceAlleleSequence[relativePosition]}).alts(alts).phase(phase).build());
      }
 else {
        for (int a=0; a < 2; a++) {
          if (alternativeAlleleSequence[a][alleleSpecificRelativePosition[a]] != referenceAlleleSequence[relativePosition]) {
            byte[] phase={0,0};
            phase[a]=1;
            Alt alt=new Alt();
            alt.setSeq(new FlexSeq(alternativeAlleleSequence[a][alleleSpecificRelativePosition[a]]));
            variantList.add(template.pos(currentPosition).referenceAlleleLength(1).ref(new byte[]{referenceAlleleSequence[relativePosition]}).alts(new Alt[]{alt}).phase(phase).build());
          }
        }
      }
    }
    variant.setAllele(0,(byte)0);
    variant.setAllele(1,(byte)0);
  }
 else {
    for (int alleleIndex=0; alleleIndex < 2; alleleIndex++) {
      int allele=variant.getAllele(alleleIndex);
      if (variant.getType(allele) == VariantType.Complex || variant.getType(allele) == VariantType.MNP || variant.getType(allele) == VariantType.SNP) {
        byte[] alternativeAlleleSequence=variant.getAlt(allele).getSequence();
        byte[] referenceSequence=variant.getReference();
        int currentPosition=variant.getPos();
        int alleleLengthDifference=alternativeAlleleSequence.length - referenceSequence.length;
        if (alleleLengthDifference > 0) {
          byte[] phase={0,0};
          phase[alleleIndex]=1;
          if (end) {
            Alt alt=new Alt();
            alt.setSeq(new FlexSeq(Arrays.copyOfRange(alternativeAlleleSequence,0,alleleLengthDifference)));
            variantList.add(template.pos(currentPosition + referenceSequence.length).referenceAlleleLength(0).ref(new byte[]{'N'}).alts(new Alt[]{alt}).phase(phase).build());
          }
 else {
            Alt alt=new Alt();
            alt.setSeq(new FlexSeq(Arrays.copyOfRange(alternativeAlleleSequence,0,alleleLengthDifference)));
            variantList.add(template.pos(currentPosition).referenceAlleleLength(0).ref(new byte[]{'N'}).alts(new Alt[]{alt}).phase(phase).build());
          }
        }
 else         if (alleleLengthDifference < 0) {
          byte[] phase={0,0};
          phase[alleleIndex]=1;
          if (end) {
            Alt alt=new Alt();
            alt.setSeq(new FlexSeq());
            variantList.add(template.pos(currentPosition + alternativeAlleleSequence.length).referenceAlleleLength(-alleleLengthDifference).ref(Arrays.copyOfRange(referenceSequence,alternativeAlleleSequence.length,alternativeAlleleSequence.length - alleleLengthDifference)).alts(new Alt[]{alt}).phase(phase).build());
          }
 else {
            Alt alt=new Alt();
            alt.setSeq(new FlexSeq());
            variantList.add(template.pos(currentPosition).referenceAlleleLength(-alleleLengthDifference).ref(Arrays.copyOfRange(referenceSequence,0,-alleleLengthDifference)).alts(new Alt[]{alt}).phase(phase).build());
          }
        }
        for (int i=0; i < referenceSequence.length; i++) {
          int idx;
          if (end) {
            if (i < referenceSequence.length + alleleLengthDifference) {
              idx=i;
            }
 else {
              idx=-1;
            }
          }
 else {
            idx=i + alleleLengthDifference;
          }
          if (idx >= 0 && alternativeAlleleSequence[idx] != referenceSequence[i]) {
            byte[] phase={0,0};
            phase[alleleIndex]=1;
            Alt alt=new Alt();
            alt.setSeq(new FlexSeq(alternativeAlleleSequence[idx]));
            variantList.add(template.pos(currentPosition).referenceAlleleLength(1).ref(new byte[]{referenceSequence[i]}).alts(new Alt[]{alt}).phase(phase).build());
          }
          currentPosition++;
        }
        variant.setAllele(alleleIndex,(byte)0);
      }
    }
  }
  if (!variant.isRef()) {
    variantList.add(variant);
  }
  return variantList;
}",0.9996466292355412
80598,"/** 
 * Randomly swap the haploype
 */
public void randomizeHaplotype(){
  if (rand == null) {
    log.error(""String_Node_Str"");
    log.error(toString());
    System.exit(1);
  }
  if (rand.nextDouble() > 0.5) {
    return;
  }
  byte tmp=paternal;
  paternal=maternal;
  maternal=tmp;
}","/** 
 * Randomly swap the haploype
 */
public void randomizeHaplotype(){
  if (rand == null) {
    log.error(""String_Node_Str"");
    log.error(toString());
    System.exit(1);
  }
  isPhased=true;
  if (rand.nextDouble() > 0.5) {
    return;
  }
  byte tmp=paternal;
  paternal=maternal;
  maternal=tmp;
}",0.9713322091062394
80599,"/** 
 * this method returns a genotype number -1 for unavailable genotype 0 for reference allele 1 for first alternative allele 2,3,... when paternal genotype is unknown, i.e. -1, then we try to return something meaningful. however this is by no means a very good return value. proper fix involves explicitly handling of missing genotype/phasing information.
 * @return paternal genotype number
 */
public byte getGoodPaternal(){
  if (paternal >= 0)   return paternal;
  if (chr.isMT()) {
    return (byte)0;
  }
  return (byte)(Math.min(1,alts.length));
}","/** 
 * this method returns a genotype number -1 for unavailable genotype 0 for reference allele 1 for first alternative allele 2,3,... when paternal genotype is unknown, i.e. -1, then we try to return something meaningful. however this is by no means a very good return value. proper fix involves explicitly handling of missing genotype/phasing information.
 * @return paternal genotype number
 */
public byte getGoodPaternal(){
  if (paternal >= 0)   return paternal;
  if (chr.isMT() || chr.isX()) {
    return (byte)-1;
  }
  return (byte)(Math.min(1,alts.length));
}",0.9858156028368794
80600,"/** 
 * Randomize the genotype
 * @param gender
 */
public void randomizeGenotype(GenderType gender){
  if (rand == null) {
    log.error(""String_Node_Str"");
    log.error(toString());
    System.exit(1);
  }
  Genotypes g=new Genotypes(chr,gender,alts.length,rand);
  paternal=g.geno[0];
  maternal=g.geno[1];
}","/** 
 * Randomize the genotype
 * @param gender
 */
public void randomizeGenotype(GenderType gender){
  if (rand == null) {
    log.error(""String_Node_Str"");
    log.error(toString());
    System.exit(1);
  }
  Genotypes g=new Genotypes(chr,gender,alts.length,rand);
  paternal=g.geno[0];
  maternal=g.geno[1];
  isPhased=true;
}",0.9734789391575664
80601,"public SimpleInterval1D getGenotypeUnionVariantInterval(){
  return getVariantInterval(getGoodPaternal()).union(getVariantInterval(getGoodMaternal()));
}","public SimpleInterval1D getGenotypeUnionVariantInterval(){
  if (getGoodPaternal() == -1 && getGoodMaternal() == -1) {
    throw new RuntimeException(""String_Node_Str"" + this.toString());
  }
 else   if (getGoodPaternal() == -1) {
    return getVariantInterval(getGoodMaternal());
  }
 else   if (getGoodMaternal() == -1) {
    return getVariantInterval(getGoodPaternal());
  }
 else {
    return getVariantInterval(getGoodPaternal()).union(getVariantInterval(getGoodMaternal()));
  }
}",0.4788732394366197
80602,"/** 
 * this method returns a genotype number -1 for unavailable genotype 0 for reference allele 1 for first alternative allele 2,3,... when maternal genotype is unknown, i.e. -1, then we try to return something meaningful. however this is by no means a very good return value. proper fix involves explicitly handling of missing genotype/phasing information.
 * @return maternal genotype number
 */
public byte getGoodMaternal(){
  if (maternal >= 0)   return maternal;
  if (chr.isMT()) {
    return (byte)(Math.min(1,alts.length));
  }
  if (chr.isY()) {
    return (byte)0;
  }
  return (byte)(Math.min(2,alts.length));
}","/** 
 * this method returns a genotype number -1 for unavailable genotype 0 for reference allele 1 for first alternative allele 2,3,... when maternal genotype is unknown, i.e. -1, then we try to return something meaningful. however this is by no means a very good return value. proper fix involves explicitly handling of missing genotype/phasing information.
 * @return maternal genotype number
 */
public byte getGoodMaternal(){
  if (maternal >= 0)   return maternal;
  if (chr.isMT()) {
    return (byte)(Math.min(1,alts.length));
  }
  if (chr.isY()) {
    return (byte)-1;
  }
  return (byte)(Math.min(2,alts.length));
}",0.9975980784627704
80603,"/** 
 * @param paternal specified paternal allele
 * @param maternal specified maternal allele
 * @return the VCF record with prespecified genotype
 */
public String toString(final int paternal,final int maternal){
  StringBuilder sbStr=new StringBuilder();
  VariantOverallType t=getType();
  sbStr.append(chr == null ? ""String_Node_Str"" : chr.toString());
  sbStr.append(""String_Node_Str"");
  sbStr.append(pos - (refDeleted == null ? 0 : refDeleted.length()));
  sbStr.append('\t');
  sbStr.append(varId);
  sbStr.append(""String_Node_Str"");
  String ref=getReferenceString() + extraBase;
  ref=ref + clippedSequence;
  sbStr.append(ref.toUpperCase());
  sbStr.append(""String_Node_Str"");
  sbStr.append(alternativeAlleleString().toUpperCase() + clippedSequence.toUpperCase());
  sbStr.append(""String_Node_Str"");
  sbStr.append(""String_Node_Str"");
  sbStr.append(filter);
  sbStr.append(""String_Node_Str"");
  sbStr.append(""String_Node_Str"" + getType() + ""String_Node_Str"");
  if (t == VariantOverallType.TandemDup) {
    sbStr.append(""String_Node_Str"");
    sbStr.append(getLengthString());
    if (isInversed()) {
      sbStr.append(""String_Node_Str"");
    }
  }
 else   if (t == VariantOverallType.TransDup || t == VariantOverallType.InterDup) {
    sbStr.append(""String_Node_Str"");
    if (getTraid() != null) {
      sbStr.append(""String_Node_Str"" + getTraid() + ""String_Node_Str"");
    }
    sbStr.append(getLengthString());
    sbStr.append(""String_Node_Str"");
    sbStr.append(StringUtilities.concatenateArray(getAllChr2(),""String_Node_Str""));
    sbStr.append(""String_Node_Str"");
    sbStr.append(""String_Node_Str"");
    sbStr.append(StringUtilities.concatenateArray(getAllPos2(),""String_Node_Str""));
    sbStr.append(""String_Node_Str"");
    sbStr.append(""String_Node_Str"");
    sbStr.append(StringUtilities.concatenateArray(getAllEnd2(),""String_Node_Str""));
    if (isInversed()) {
      sbStr.append(""String_Node_Str"");
    }
  }
 else   if (t == VariantOverallType.Deletion) {
    sbStr.append(""String_Node_Str"");
    sbStr.append(getLengthString());
  }
 else   if (t == VariantOverallType.TransDel) {
    sbStr.append(""String_Node_Str"");
    if (getTraid() != null) {
      sbStr.append(""String_Node_Str"" + getTraid() + ""String_Node_Str"");
    }
    sbStr.append(getLengthString());
  }
 else   if (t == VariantOverallType.Inversion) {
    sbStr.append(""String_Node_Str"");
    sbStr.append(getLengthString());
  }
 else {
    sbStr.append(getLengthString());
  }
  if (threePrimeDistance != -1) {
    sbStr.append(""String_Node_Str"");
    sbStr.append(threePrimeDistance);
    sbStr.append(""String_Node_Str"");
  }
  if (fivePrimeDistance != -1) {
    sbStr.append(""String_Node_Str"");
    sbStr.append(fivePrimeDistance);
    sbStr.append(""String_Node_Str"");
  }
  if (lengthDifference != -1) {
    sbStr.append(""String_Node_Str"");
    sbStr.append(lengthDifference);
    sbStr.append(""String_Node_Str"");
  }
  sbStr.append(""String_Node_Str"");
  if (hasCN()) {
    sbStr.append(""String_Node_Str"");
  }
 else {
    sbStr.append(""String_Node_Str"");
  }
  if (paternal != -1 && maternal != -1) {
    sbStr.append(paternal);
    sbStr.append(""String_Node_Str"");
    sbStr.append(maternal);
  }
 else   if (paternal != -1) {
    sbStr.append(paternal);
  }
 else   if (maternal != -1) {
    sbStr.append(maternal);
  }
  if (hasCN()) {
    sbStr.append(""String_Node_Str"");
    if (paternal != -1 && maternal != -1) {
      sbStr.append(String.valueOf(getCN(paternal)));
      sbStr.append(""String_Node_Str"");
      sbStr.append(String.valueOf(getCN(maternal)));
    }
 else     if (paternal != -1) {
      sbStr.append(String.valueOf(getCN(paternal)));
    }
 else     if (maternal != -1) {
      sbStr.append(String.valueOf(getCN(maternal)));
    }
  }
  return sbStr.toString().replaceAll(""String_Node_Str"",""String_Node_Str"").replaceAll(""String_Node_Str"",""String_Node_Str"").replaceAll(""String_Node_Str"",""String_Node_Str"");
}","/** 
 * @param paternal specified paternal allele
 * @param maternal specified maternal allele
 * @return the VCF record with prespecified genotype
 */
public String toString(final int paternal,final int maternal){
  StringBuilder sbStr=new StringBuilder();
  VariantOverallType t=getType();
  sbStr.append(chr == null ? ""String_Node_Str"" : chr.toString());
  sbStr.append(""String_Node_Str"");
  sbStr.append(pos - (refDeleted == null ? 0 : refDeleted.length()));
  sbStr.append('\t');
  sbStr.append(varId);
  sbStr.append(""String_Node_Str"");
  String ref=getReferenceString() + extraBase;
  ref=ref + clippedSequence;
  sbStr.append(ref.toUpperCase());
  sbStr.append(""String_Node_Str"");
  sbStr.append(alternativeAlleleString().toUpperCase() + clippedSequence.toUpperCase());
  sbStr.append(""String_Node_Str"");
  sbStr.append(""String_Node_Str"");
  sbStr.append(filter);
  sbStr.append(""String_Node_Str"");
  sbStr.append(""String_Node_Str"" + getType() + ""String_Node_Str"");
  if (t == VariantOverallType.TandemDup) {
    sbStr.append(""String_Node_Str"");
    sbStr.append(getLengthString());
    if (isInversed()) {
      sbStr.append(""String_Node_Str"");
    }
  }
 else   if (t == VariantOverallType.TransDup || t == VariantOverallType.InterDup) {
    sbStr.append(""String_Node_Str"");
    if (getTraid() != null) {
      sbStr.append(""String_Node_Str"" + getTraid() + ""String_Node_Str"");
    }
    sbStr.append(getLengthString());
    sbStr.append(""String_Node_Str"");
    sbStr.append(StringUtilities.concatenateArray(getAllChr2(),""String_Node_Str""));
    sbStr.append(""String_Node_Str"");
    sbStr.append(""String_Node_Str"");
    sbStr.append(StringUtilities.concatenateArray(getAllPos2(),""String_Node_Str""));
    sbStr.append(""String_Node_Str"");
    sbStr.append(""String_Node_Str"");
    sbStr.append(StringUtilities.concatenateArray(getAllEnd2(),""String_Node_Str""));
    if (isInversed()) {
      sbStr.append(""String_Node_Str"");
    }
  }
 else   if (t == VariantOverallType.Deletion) {
    sbStr.append(""String_Node_Str"");
    sbStr.append(getLengthString());
  }
 else   if (t == VariantOverallType.TransDel) {
    sbStr.append(""String_Node_Str"");
    if (getTraid() != null) {
      sbStr.append(""String_Node_Str"" + getTraid() + ""String_Node_Str"");
    }
    sbStr.append(getLengthString());
  }
 else   if (t == VariantOverallType.Inversion) {
    sbStr.append(""String_Node_Str"");
    sbStr.append(getLengthString());
  }
 else {
    sbStr.append(getLengthString());
  }
  if (threePrimeDistance != -1) {
    sbStr.append(""String_Node_Str"");
    sbStr.append(threePrimeDistance);
    sbStr.append(""String_Node_Str"");
  }
  if (fivePrimeDistance != -1) {
    sbStr.append(""String_Node_Str"");
    sbStr.append(fivePrimeDistance);
    sbStr.append(""String_Node_Str"");
  }
  if (lengthDifference != -1) {
    sbStr.append(""String_Node_Str"");
    sbStr.append(lengthDifference);
    sbStr.append(""String_Node_Str"");
  }
  sbStr.append(""String_Node_Str"");
  if (hasCN()) {
    sbStr.append(""String_Node_Str"");
  }
 else {
    sbStr.append(""String_Node_Str"");
  }
  if (paternal != -1 && maternal != -1) {
    sbStr.append(paternal);
    sbStr.append(this.isPhased() || paternal == maternal ? ""String_Node_Str"" : ""String_Node_Str"");
    sbStr.append(maternal);
  }
 else   if (paternal != -1) {
    sbStr.append(paternal);
  }
 else   if (maternal != -1) {
    sbStr.append(maternal);
  }
  if (hasCN()) {
    sbStr.append(""String_Node_Str"");
    if (paternal != -1 && maternal != -1) {
      sbStr.append(String.valueOf(getCN(paternal)));
      sbStr.append(this.isPhased() || paternal == maternal ? ""String_Node_Str"" : ""String_Node_Str"");
      sbStr.append(String.valueOf(getCN(maternal)));
    }
 else     if (paternal != -1) {
      sbStr.append(String.valueOf(getCN(paternal)));
    }
 else     if (maternal != -1) {
      sbStr.append(String.valueOf(getCN(maternal)));
    }
  }
  return sbStr.toString().replaceAll(""String_Node_Str"",""String_Node_Str"").replaceAll(""String_Node_Str"",""String_Node_Str"").replaceAll(""String_Node_Str"",""String_Node_Str"");
}",0.9844767150726088
80604,"/** 
 * takes a line from a VCF file, parse it, return a Variant object right now the meta-info lines (beginning with ##) are not tied with data line parsing. This will be corrected in the future (perhaps with help of HTSJDK).
 * @param line
 * @return
 */
public Variant processLine(String line) throws UnexpectedException {
  List<String> toks=Lists.newArrayList(Splitter.on('\t').split(line));
  if (line.startsWith(""String_Node_Str"")) {
    if (sampleId != null && line.startsWith(""String_Node_Str"")) {
      chromLineSeen=true;
      int index=0;
      for (      String tok : toks) {
        index++;
        if (tok.equals(sampleId))         sampleIndex=index;
      }
    }
 else     if (sampleId == null) {
      sampleIndex=10;
      if (line.startsWith(""String_Node_Str"") && toks.size() >= sampleIndex) {
        sampleId=toks.get(sampleIndex - 1);
      }
    }
    return null;
  }
  if (sampleIndex < 0 && !chromLineSeen) {
    sampleIndex=10;
  }
 else   if (sampleIndex < 0) {
    sampleIndex=10;
    log.warn(""String_Node_Str"" + sampleId + ""String_Node_Str"");
  }
  int index=0, genotypeIndex=-1, copyNumberIndex=-1;
  int pos=-1;
  ChrString chr=null;
  String REF=""String_Node_Str"", FILTER=""String_Node_Str"", ALT=""String_Node_Str"", variantId=""String_Node_Str"";
  String phase=""String_Node_Str"", copyNumber=""String_Node_Str"", infoString=""String_Node_Str"", FORMAT;
  String[] sampleInfo;
  for (  String tok : toks) {
    index++;
    if (index == 1) {
      chr=new ChrString(tok);
    }
 else     if (index == 2)     pos=Integer.parseInt(tok);
 else     if (index == 3)     variantId=tok;
 else     if (index == 4)     REF=tok;
 else     if (index == 5)     ALT=tok;
 else     if (index == 7)     FILTER=tok;
 else     if (index == 8)     infoString=tok;
 else     if (index == 9) {
      FORMAT=tok;
      genotypeIndex=getFormatKeyIndex(FORMAT,""String_Node_Str"");
      copyNumberIndex=getFormatKeyIndex(FORMAT,""String_Node_Str"");
    }
 else     if (index == sampleIndex) {
      sampleInfo=tok.split(""String_Node_Str"");
      if (genotypeIndex >= 0) {
        phase=sampleInfo[genotypeIndex];
      }
      if (copyNumberIndex >= 0) {
        copyNumber=sampleInfo[copyNumberIndex];
      }
      break;
    }
  }
  if (chr == null) {
    log.warn(""String_Node_Str"" + line);
    return null;
  }
  if (isPassFilterRequired && !(FILTER.contains(""String_Node_Str"") || FILTER.equals(DEFAULT_FILTER))) {
    log.warn(""String_Node_Str"" + line);
    return null;
  }
  byte[] genotypeArray=new byte[2];
  boolean isGenotypePhased=isPhased(phase,genotypeArray,chr);
  if (genotypeIndex >= 0 && genotypeArray[0] == 0 && genotypeArray[1] == 0) {
    return null;
  }
  if (!REF.matches(""String_Node_Str"")) {
    log.warn(""String_Node_Str"");
    return null;
  }
  byte[] copyNumberArray=new byte[2];
  boolean isCopyNumberPhased;
  if (copyNumberIndex >= 0) {
    isCopyNumberPhased=isPhased(copyNumber,copyNumberArray,chr);
    if (isCopyNumberPhased != isGenotypePhased) {
      log.warn(""String_Node_Str"");
      log.warn(""String_Node_Str"" + line);
      return null;
    }
  }
  REF=REF.toUpperCase();
  ALT=ALT.toUpperCase();
  String deletedReference=""String_Node_Str"";
  VCFInfo info=new VCFInfo(infoString);
  if (ALT.indexOf('<') != -1) {
    String[] alternativeAlleles=ALT.split(""String_Node_Str"");
    int[] svlen=info.getValue(""String_Node_Str"",int[].class);
    if (alternativeAlleles.length != svlen.length) {
      throw new IllegalArgumentException(""String_Node_Str"" + line);
    }
    for (int i=0; i < alternativeAlleles.length; i++) {
      if (!alternativeAlleles[i].startsWith(""String_Node_Str"")) {
        throw new IllegalArgumentException(""String_Node_Str"" + line);
      }
    }
  }
  Alt[] alts=null;
  try {
    alts=string2Alt(ALT);
  }
 catch (  IllegalArgumentException e) {
    log.warn(""String_Node_Str"" + e.getMessage() + ""String_Node_Str""+ line);
    return null;
  }
  if (alts[0].getSymbolicAllele() != null) {
    int[] end=info.getValue(""String_Node_Str"",int[].class);
    int[] svlen=info.getValue(""String_Node_Str"",int[].class);
    int[] end2=info.getValue(""String_Node_Str"",int[].class);
    int[] pos2=info.getValue(""String_Node_Str"",int[].class);
    Boolean isinv=info.getValue(""String_Node_Str"",Boolean.class);
    Boolean isLengthImprecise=info.getValue(""String_Node_Str"",Boolean.class);
    isLengthImprecise=isLengthImprecise == null ? false : isLengthImprecise;
    String[] traid=info.getValue(""String_Node_Str"",String[].class);
    String[] chr2=info.getValue(""String_Node_Str"",String[].class);
    deletedReference=REF;
    byte[] refs=new byte[0];
    pos++;
    if (Alt.SVType.SVSubtype.TRA.equals(alts[0].getSymbolicAllele().getMinor())) {
      if (traid == null || traid.length == 0) {
        throw new IllegalArgumentException(""String_Node_Str"" + line);
      }
    }
    Variant.Builder template=new Variant.Builder().chr(chr).pos(pos).ref(refs).phase(genotypeArray).isPhased(isGenotypePhased).varId(variantId).filter(FILTER).refDeleted(deletedReference).isLengthImprecise(isLengthImprecise).randomNumberGenerator(random);
    if (alts[0].getSymbolicAllele().getMajor() == Alt.SVType.INV) {
      if (svlen.length > 0) {
        for (int i=0; i < svlen.length; i++) {
          if (i > 0 && svlen[i] != svlen[i - 1]) {
            log.warn(""String_Node_Str"" + line);
            return null;
          }
          int alternativeAlleleLength=Math.max(Math.abs(svlen[i]),1);
          alts[i].setSeq(new FlexSeq(FlexSeq.Type.INV,alternativeAlleleLength));
        }
        return template.referenceAlleleLength(Math.abs(svlen[0])).alts(alts).build();
      }
 else       if (end != null && end.length > 0 && end[0] > 0) {
        int alternativeAlleleLength=Math.max(Math.abs(end[0] - pos + 1),1);
        alts[0].setSeq(new FlexSeq(FlexSeq.Type.INV,alternativeAlleleLength));
        return template.referenceAlleleLength(alternativeAlleleLength).alts(alts).build();
      }
 else {
        log.error(""String_Node_Str"");
        log.error(line);
        log.error(""String_Node_Str"");
        return null;
      }
    }
 else     if (alts[0].getSymbolicAllele().getMajor() == Alt.SVType.DUP && ((alts[0].getSymbolicAllele().getMinor() != Alt.SVType.SVSubtype.TRA && alts[0].getSymbolicAllele().getMinor() != Alt.SVType.SVSubtype.ISP && info.getValue(""String_Node_Str"",getType(""String_Node_Str"")) == null) || alts[0].getSymbolicAllele().getMinor() == Alt.SVType.SVSubtype.TANDEM)) {
      if (svlen.length > 0) {
        for (int i=0; i < svlen.length; i++) {
          if (i > 0 && svlen[i] != svlen[i - 1]) {
            log.warn(""String_Node_Str"" + line);
            return null;
          }
          int currentCopyNumber=2;
          for (int j=0; j < 2; j++) {
            if ((i + 1) == genotypeArray[j]) {
              if (copyNumberArray[j] > 0) {
                currentCopyNumber=copyNumberArray[j];
              }
            }
          }
          int alternativeAlleleLength=Math.max(Math.abs(svlen[i]),1);
          alts[i].setSeq(new FlexSeq(FlexSeq.Type.TANDEM_DUP,alternativeAlleleLength,currentCopyNumber));
        }
        return template.referenceAlleleLength(Math.abs(svlen[0])).alts(alts).build();
      }
 else       if (end != null && end.length > 0 && end[0] > 0) {
        int alternativeAlleleLength=Math.max(Math.abs(end[0] - pos + 1),1);
        alts[0].setSeq(new FlexSeq(FlexSeq.Type.TANDEM_DUP,alternativeAlleleLength,Math.max(copyNumberArray[0],copyNumberArray[1])));
        return template.referenceAlleleLength(alternativeAlleleLength).alts(alts).build();
      }
 else {
        log.error(""String_Node_Str"");
        log.error(line);
        log.error(""String_Node_Str"");
        return null;
      }
    }
 else     if (alts[0].getSymbolicAllele().getMajor() == Alt.SVType.INS) {
      if (svlen.length > 0) {
        for (int i=0; i < svlen.length; i++) {
          int alternativeAlleleLength=svlen[i] == 0 ? Integer.MAX_VALUE : Math.max(Math.abs(svlen[i]),1);
          alts[i].setSeq(new FlexSeq(FlexSeq.Type.INS,alternativeAlleleLength));
        }
        return template.referenceAlleleLength(0).alts(alts).build();
      }
 else       if (end != null && end.length > 0 && end[0] > 0) {
        int alternativeAlleleLength=Math.max(Math.abs(end[0] - pos),1);
        alts[0].setSeq(new FlexSeq(FlexSeq.Type.INS,alternativeAlleleLength));
        return template.referenceAlleleLength(0).alts(alts).build();
      }
 else {
        log.error(""String_Node_Str"");
        log.error(line);
        log.error(""String_Node_Str"");
        return null;
      }
    }
 else     if (alts[0].getSymbolicAllele().getMajor() == Alt.SVType.DEL) {
      template=template.traid(traid == null ? null : traid[0]);
      if (svlen.length > 0) {
        for (int i=0; i < svlen.length; i++) {
          if (i > 0 && svlen[i] != svlen[i - 1]) {
            log.warn(""String_Node_Str"" + line);
            return null;
          }
          if (Alt.SVType.SVSubtype.TRA == alts[i].getSymbolicAllele().getMinor()) {
            alts[i].setSeq(new FlexSeq(FlexSeq.Type.TRA_DEL,svlen[i]));
          }
 else {
            alts[i].setSeq(new FlexSeq(FlexSeq.Type.DEL,0));
          }
        }
        return template.alts(alts).referenceAlleleLength(Math.abs(svlen[0])).build();
      }
 else       if (end != null && end.length > 0 && end[0] > 0) {
        int alternativeAlleleLength=end[0] - pos + 1;
        if (Alt.SVType.SVSubtype.TRA == alts[0].getSymbolicAllele().getMinor()) {
          alts[0].setSeq(new FlexSeq(FlexSeq.Type.TRA_DEL,-alternativeAlleleLength));
        }
 else {
          alts[0].setSeq(new FlexSeq(FlexSeq.Type.DEL,0));
        }
        return template.alts(alts).referenceAlleleLength(alternativeAlleleLength).build();
      }
 else {
        log.error(""String_Node_Str"");
        log.error(line);
        log.error(""String_Node_Str"");
        return null;
      }
    }
 else     if (alts[0].getSymbolicAllele().getMajor() == Alt.SVType.DUP && (alts[0].getSymbolicAllele().getMinor() == Alt.SVType.SVSubtype.TRA || alts[0].getSymbolicAllele().getMinor() == Alt.SVType.SVSubtype.ISP || info.getValue(""String_Node_Str"",getType(""String_Node_Str"")) != null)) {
      if (svlen.length > 0) {
        for (int altAlleleIndex=1; altAlleleIndex <= svlen.length; altAlleleIndex++) {
          int currentCopyNumber=2;
          if (altAlleleIndex == genotypeArray[0]) {
            currentCopyNumber=copyNumberArray[0];
          }
          if (altAlleleIndex == genotypeArray[1]) {
            currentCopyNumber=copyNumberArray[1];
          }
          currentCopyNumber=Math.max(1,currentCopyNumber);
          int altAllelelength=Math.max(Math.abs(svlen[altAlleleIndex - 1]),1);
          alts[altAlleleIndex - 1].setSeq(new FlexSeq(alts[altAlleleIndex - 1].getSymbolicAllele().getMinor() == Alt.SVType.SVSubtype.TRA ? FlexSeq.Type.TRA_DUP : FlexSeq.Type.ISP_DUP,altAllelelength,currentCopyNumber));
        }
        for (int i=1; i < svlen.length; i++) {
          if (svlen[i] != svlen[0]) {
            throw new IllegalArgumentException(""String_Node_Str"" + line);
          }
        }
        return template.referenceAlleleLength(0).alts(alts).chr2(ChrString.string2ChrString(chr2)).pos2(pos2).end2(end2).isinv(isinv).traid(traid == null ? null : traid[0]).build();
      }
 else {
        log.error(""String_Node_Str"");
        log.error(line);
        log.error(""String_Node_Str"");
        return null;
      }
    }
 else {
      log.warn(""String_Node_Str"" + line);
      return null;
    }
  }
 else   if (alts[0].getSeq() != null) {
    for (int i=0; i < alts.length; i++) {
      if (REF.length() == 1 && alts[i].length() == 1) {
      }
 else       if (REF.length() == 0 || alts[i].length() == 0) {
        log.warn(""String_Node_Str"" + line);
        return null;
      }
    }
    while (REF.length() > 0) {
      boolean same=true;
      for (int i=0; i < alts.length; i++) {
        if (alts[i].length() == 0 || REF.charAt(0) != alts[i].byteAt(0)) {
          same=false;
          break;
        }
      }
      if (same) {
        pos++;
        deletedReference=String.valueOf(REF.charAt(0));
        REF=REF.substring(1);
        for (int i=0; i < alts.length; i++) {
          alts[i].setSeq(new FlexSeq(alts[i].getSeq().substring(1)));
        }
      }
 else {
        break;
      }
    }
    String clippedSequence=""String_Node_Str"";
    if (REF.length() > 0) {
      int referenceAlleleLength=REF.length();
      int minClipLength=Integer.MAX_VALUE;
      for (int i=0; i < alts.length; i++) {
        int alternativeAlleleLength=alts[i].length();
        int clipLength=0;
        for (int j=0; j < Math.min(alternativeAlleleLength,referenceAlleleLength); j++) {
          if (REF.charAt(referenceAlleleLength - j - 1) != alts[i].byteAt(alternativeAlleleLength - j - 1)) {
            clipLength=j;
            break;
          }
          clipLength=j + 1;
        }
        minClipLength=Math.min(clipLength,minClipLength);
      }
      if (minClipLength > 0) {
        clippedSequence=REF.substring(referenceAlleleLength - minClipLength,referenceAlleleLength);
        REF=REF.substring(0,Math.max(0,referenceAlleleLength - minClipLength));
        for (int i=0; i < alts.length; i++) {
          if (!clippedSequence.equals(new String(alts[i].getSeq().substring(alts[i].getSeq().length() - minClipLength,alts[i].getSeq().length())))) {
            log.warn(""String_Node_Str"" + line);
            return null;
          }
          alts[i].setSeq(new FlexSeq(alts[i].getSeq().substring(0,Math.max(0,alts[i].length() - minClipLength))));
        }
      }
    }
    byte[] refs=new byte[REF.length()];
    for (int i=0; i < REF.length(); i++) {
      refs[i]=(byte)REF.charAt(i);
    }
    return new Variant.Builder().chr(chr).pos(pos).referenceAlleleLength(refs.length).ref(refs).alts(alts).phase(genotypeArray).isPhased(isGenotypePhased).varId(variantId).filter(FILTER).refDeleted(deletedReference).randomNumberGenerator(random).clippedSequence(clippedSequence).build();
  }
 else {
    log.warn(""String_Node_Str"" + line);
    return null;
  }
}","/** 
 * takes a line from a VCF file, parse it, return a Variant object right now the meta-info lines (beginning with ##) are not tied with data line parsing. This will be corrected in the future (perhaps with help of HTSJDK).
 * @param line
 * @return
 */
public Variant processLine(String line) throws UnexpectedException {
  List<String> toks=Lists.newArrayList(Splitter.on('\t').split(line));
  if (line.startsWith(""String_Node_Str"")) {
    if (sampleId != null && line.startsWith(""String_Node_Str"")) {
      chromLineSeen=true;
      int index=0;
      for (      String tok : toks) {
        index++;
        if (tok.equals(sampleId))         sampleIndex=index;
      }
    }
 else     if (sampleId == null) {
      sampleIndex=10;
      if (line.startsWith(""String_Node_Str"") && toks.size() >= sampleIndex) {
        sampleId=toks.get(sampleIndex - 1);
      }
    }
    return null;
  }
  if (sampleIndex < 0 && !chromLineSeen) {
    sampleIndex=10;
  }
 else   if (sampleIndex < 0) {
    sampleIndex=10;
    log.warn(""String_Node_Str"" + sampleId + ""String_Node_Str"");
  }
  int index=0, genotypeIndex=-1, copyNumberIndex=-1;
  int pos=-1;
  ChrString chr=null;
  String REF=""String_Node_Str"", FILTER=""String_Node_Str"", ALT=""String_Node_Str"", variantId=""String_Node_Str"";
  String phase=""String_Node_Str"", copyNumber=""String_Node_Str"", infoString=""String_Node_Str"", FORMAT;
  String[] sampleInfo;
  for (  String tok : toks) {
    index++;
    if (index == 1) {
      chr=new ChrString(tok);
    }
 else     if (index == 2)     pos=Integer.parseInt(tok);
 else     if (index == 3)     variantId=tok;
 else     if (index == 4)     REF=tok;
 else     if (index == 5)     ALT=tok;
 else     if (index == 7)     FILTER=tok;
 else     if (index == 8)     infoString=tok;
 else     if (index == 9) {
      FORMAT=tok;
      genotypeIndex=getFormatKeyIndex(FORMAT,""String_Node_Str"");
      copyNumberIndex=getFormatKeyIndex(FORMAT,""String_Node_Str"");
    }
 else     if (index == sampleIndex) {
      sampleInfo=tok.split(""String_Node_Str"");
      if (genotypeIndex >= 0) {
        phase=sampleInfo[genotypeIndex];
      }
      if (copyNumberIndex >= 0) {
        copyNumber=sampleInfo[copyNumberIndex];
      }
      break;
    }
  }
  if (chr == null) {
    log.warn(""String_Node_Str"" + line);
    return null;
  }
  if (isPassFilterRequired && !(FILTER.contains(""String_Node_Str"") || FILTER.equals(DEFAULT_FILTER))) {
    log.warn(""String_Node_Str"" + line);
    return null;
  }
  byte[] genotypeArray=new byte[2];
  boolean isGenotypePhased=isPhased(phase,genotypeArray,chr);
  if (genotypeIndex >= 0 && genotypeArray[0] == 0 && genotypeArray[1] == 0) {
    log.warn(""String_Node_Str"" + line);
    return null;
  }
  if (!REF.matches(""String_Node_Str"")) {
    log.warn(""String_Node_Str"" + line);
    return null;
  }
  byte[] copyNumberArray=new byte[2];
  boolean isCopyNumberPhased;
  if (copyNumberIndex >= 0) {
    isCopyNumberPhased=isPhased(copyNumber,copyNumberArray,chr);
    if (isCopyNumberPhased != isGenotypePhased) {
      log.warn(""String_Node_Str"");
      log.warn(""String_Node_Str"" + line);
      return null;
    }
  }
  REF=REF.toUpperCase();
  ALT=ALT.toUpperCase();
  String deletedReference=""String_Node_Str"";
  VCFInfo info=new VCFInfo(infoString);
  if (ALT.indexOf('<') != -1) {
    String[] alternativeAlleles=ALT.split(""String_Node_Str"");
    int[] svlen=info.getValue(""String_Node_Str"",int[].class);
    if (alternativeAlleles.length != svlen.length) {
      throw new IllegalArgumentException(""String_Node_Str"" + line);
    }
    for (int i=0; i < alternativeAlleles.length; i++) {
      if (!alternativeAlleles[i].startsWith(""String_Node_Str"")) {
        throw new IllegalArgumentException(""String_Node_Str"" + line);
      }
    }
  }
  Alt[] alts=null;
  try {
    alts=string2Alt(ALT);
  }
 catch (  IllegalArgumentException e) {
    log.warn(""String_Node_Str"" + e.getMessage() + ""String_Node_Str""+ line);
    return null;
  }
  if (alts[0].getSymbolicAllele() != null) {
    int[] end=info.getValue(""String_Node_Str"",int[].class);
    int[] svlen=info.getValue(""String_Node_Str"",int[].class);
    int[] end2=info.getValue(""String_Node_Str"",int[].class);
    int[] pos2=info.getValue(""String_Node_Str"",int[].class);
    Boolean isinv=info.getValue(""String_Node_Str"",Boolean.class);
    Boolean isLengthImprecise=info.getValue(""String_Node_Str"",Boolean.class);
    isLengthImprecise=isLengthImprecise == null ? false : isLengthImprecise;
    String[] traid=info.getValue(""String_Node_Str"",String[].class);
    String[] chr2=info.getValue(""String_Node_Str"",String[].class);
    deletedReference=REF;
    byte[] refs=new byte[0];
    pos++;
    if (Alt.SVType.SVSubtype.TRA.equals(alts[0].getSymbolicAllele().getMinor())) {
      if (traid == null || traid.length == 0) {
        throw new IllegalArgumentException(""String_Node_Str"" + line);
      }
    }
    Variant.Builder template=new Variant.Builder().chr(chr).pos(pos).ref(refs).phase(genotypeArray).isPhased(isGenotypePhased).varId(variantId).filter(FILTER).refDeleted(deletedReference).isLengthImprecise(isLengthImprecise).randomNumberGenerator(random);
    if (alts[0].getSymbolicAllele().getMajor() == Alt.SVType.INV) {
      if (svlen.length > 0) {
        for (int i=0; i < svlen.length; i++) {
          if (i > 0 && svlen[i] != svlen[i - 1]) {
            log.warn(""String_Node_Str"" + line);
            return null;
          }
          int alternativeAlleleLength=Math.max(Math.abs(svlen[i]),1);
          alts[i].setSeq(new FlexSeq(FlexSeq.Type.INV,alternativeAlleleLength));
        }
        return template.referenceAlleleLength(Math.abs(svlen[0])).alts(alts).build();
      }
 else       if (end != null && end.length > 0 && end[0] > 0) {
        int alternativeAlleleLength=Math.max(Math.abs(end[0] - pos + 1),1);
        alts[0].setSeq(new FlexSeq(FlexSeq.Type.INV,alternativeAlleleLength));
        return template.referenceAlleleLength(alternativeAlleleLength).alts(alts).build();
      }
 else {
        log.error(""String_Node_Str"");
        log.error(line);
        log.error(""String_Node_Str"");
        return null;
      }
    }
 else     if (alts[0].getSymbolicAllele().getMajor() == Alt.SVType.DUP && ((alts[0].getSymbolicAllele().getMinor() != Alt.SVType.SVSubtype.TRA && alts[0].getSymbolicAllele().getMinor() != Alt.SVType.SVSubtype.ISP && info.getValue(""String_Node_Str"",getType(""String_Node_Str"")) == null) || alts[0].getSymbolicAllele().getMinor() == Alt.SVType.SVSubtype.TANDEM)) {
      if (svlen.length > 0) {
        for (int i=0; i < svlen.length; i++) {
          if (i > 0 && svlen[i] != svlen[i - 1]) {
            log.warn(""String_Node_Str"" + line);
            return null;
          }
          int currentCopyNumber=2;
          for (int j=0; j < 2; j++) {
            if ((i + 1) == genotypeArray[j]) {
              if (copyNumberArray[j] > 0) {
                currentCopyNumber=copyNumberArray[j];
              }
            }
          }
          int alternativeAlleleLength=Math.max(Math.abs(svlen[i]),1);
          alts[i].setSeq(new FlexSeq(FlexSeq.Type.TANDEM_DUP,alternativeAlleleLength,currentCopyNumber));
        }
        return template.referenceAlleleLength(Math.abs(svlen[0])).alts(alts).build();
      }
 else       if (end != null && end.length > 0 && end[0] > 0) {
        int alternativeAlleleLength=Math.max(Math.abs(end[0] - pos + 1),1);
        alts[0].setSeq(new FlexSeq(FlexSeq.Type.TANDEM_DUP,alternativeAlleleLength,Math.max(copyNumberArray[0],copyNumberArray[1])));
        return template.referenceAlleleLength(alternativeAlleleLength).alts(alts).build();
      }
 else {
        log.error(""String_Node_Str"");
        log.error(line);
        log.error(""String_Node_Str"");
        return null;
      }
    }
 else     if (alts[0].getSymbolicAllele().getMajor() == Alt.SVType.INS) {
      if (svlen.length > 0) {
        for (int i=0; i < svlen.length; i++) {
          int alternativeAlleleLength=svlen[i] == 0 ? Integer.MAX_VALUE : Math.max(Math.abs(svlen[i]),1);
          alts[i].setSeq(new FlexSeq(FlexSeq.Type.INS,alternativeAlleleLength));
        }
        return template.referenceAlleleLength(0).alts(alts).build();
      }
 else       if (end != null && end.length > 0 && end[0] > 0) {
        int alternativeAlleleLength=Math.max(Math.abs(end[0] - pos),1);
        alts[0].setSeq(new FlexSeq(FlexSeq.Type.INS,alternativeAlleleLength));
        return template.referenceAlleleLength(0).alts(alts).build();
      }
 else {
        log.error(""String_Node_Str"");
        log.error(line);
        log.error(""String_Node_Str"");
        return null;
      }
    }
 else     if (alts[0].getSymbolicAllele().getMajor() == Alt.SVType.DEL) {
      template=template.traid(traid == null ? null : traid[0]);
      if (svlen.length > 0) {
        for (int i=0; i < svlen.length; i++) {
          if (i > 0 && svlen[i] != svlen[i - 1]) {
            log.warn(""String_Node_Str"" + line);
            return null;
          }
          if (Alt.SVType.SVSubtype.TRA == alts[i].getSymbolicAllele().getMinor()) {
            alts[i].setSeq(new FlexSeq(FlexSeq.Type.TRA_DEL,svlen[i]));
          }
 else {
            alts[i].setSeq(new FlexSeq(FlexSeq.Type.DEL,0));
          }
        }
        return template.alts(alts).referenceAlleleLength(Math.abs(svlen[0])).build();
      }
 else       if (end != null && end.length > 0 && end[0] > 0) {
        int alternativeAlleleLength=end[0] - pos + 1;
        if (Alt.SVType.SVSubtype.TRA == alts[0].getSymbolicAllele().getMinor()) {
          alts[0].setSeq(new FlexSeq(FlexSeq.Type.TRA_DEL,-alternativeAlleleLength));
        }
 else {
          alts[0].setSeq(new FlexSeq(FlexSeq.Type.DEL,0));
        }
        return template.alts(alts).referenceAlleleLength(alternativeAlleleLength).build();
      }
 else {
        log.error(""String_Node_Str"");
        log.error(line);
        log.error(""String_Node_Str"");
        return null;
      }
    }
 else     if (alts[0].getSymbolicAllele().getMajor() == Alt.SVType.DUP && (alts[0].getSymbolicAllele().getMinor() == Alt.SVType.SVSubtype.TRA || alts[0].getSymbolicAllele().getMinor() == Alt.SVType.SVSubtype.ISP || info.getValue(""String_Node_Str"",getType(""String_Node_Str"")) != null)) {
      if (svlen.length > 0) {
        for (int altAlleleIndex=1; altAlleleIndex <= svlen.length; altAlleleIndex++) {
          int currentCopyNumber=2;
          if (altAlleleIndex == genotypeArray[0]) {
            currentCopyNumber=copyNumberArray[0];
          }
          if (altAlleleIndex == genotypeArray[1]) {
            currentCopyNumber=copyNumberArray[1];
          }
          currentCopyNumber=Math.max(1,currentCopyNumber);
          int altAllelelength=Math.max(Math.abs(svlen[altAlleleIndex - 1]),1);
          alts[altAlleleIndex - 1].setSeq(new FlexSeq(alts[altAlleleIndex - 1].getSymbolicAllele().getMinor() == Alt.SVType.SVSubtype.TRA ? FlexSeq.Type.TRA_DUP : FlexSeq.Type.ISP_DUP,altAllelelength,currentCopyNumber));
        }
        for (int i=1; i < svlen.length; i++) {
          if (svlen[i] != svlen[0]) {
            throw new IllegalArgumentException(""String_Node_Str"" + line);
          }
        }
        return template.referenceAlleleLength(0).alts(alts).chr2(ChrString.string2ChrString(chr2)).pos2(pos2).end2(end2).isinv(isinv).traid(traid == null ? null : traid[0]).build();
      }
 else {
        log.error(""String_Node_Str"");
        log.error(line);
        log.error(""String_Node_Str"");
        return null;
      }
    }
 else {
      log.warn(""String_Node_Str"" + line);
      return null;
    }
  }
 else   if (alts[0].getSeq() != null) {
    for (int i=0; i < alts.length; i++) {
      if (REF.length() == 1 && alts[i].length() == 1) {
      }
 else       if (REF.length() == 0 || alts[i].length() == 0) {
        log.warn(""String_Node_Str"" + line);
        return null;
      }
    }
    while (REF.length() > 0) {
      boolean same=true;
      for (int i=0; i < alts.length; i++) {
        if (alts[i].length() == 0 || REF.charAt(0) != alts[i].byteAt(0)) {
          same=false;
          break;
        }
      }
      if (same) {
        pos++;
        deletedReference=String.valueOf(REF.charAt(0));
        REF=REF.substring(1);
        for (int i=0; i < alts.length; i++) {
          alts[i].setSeq(new FlexSeq(alts[i].getSeq().substring(1)));
        }
      }
 else {
        break;
      }
    }
    String clippedSequence=""String_Node_Str"";
    if (REF.length() > 0) {
      int referenceAlleleLength=REF.length();
      int minClipLength=Integer.MAX_VALUE;
      for (int i=0; i < alts.length; i++) {
        int alternativeAlleleLength=alts[i].length();
        int clipLength=0;
        for (int j=0; j < Math.min(alternativeAlleleLength,referenceAlleleLength); j++) {
          if (REF.charAt(referenceAlleleLength - j - 1) != alts[i].byteAt(alternativeAlleleLength - j - 1)) {
            clipLength=j;
            break;
          }
          clipLength=j + 1;
        }
        minClipLength=Math.min(clipLength,minClipLength);
      }
      if (minClipLength > 0) {
        clippedSequence=REF.substring(referenceAlleleLength - minClipLength,referenceAlleleLength);
        REF=REF.substring(0,Math.max(0,referenceAlleleLength - minClipLength));
        for (int i=0; i < alts.length; i++) {
          if (!clippedSequence.equals(new String(alts[i].getSeq().substring(alts[i].getSeq().length() - minClipLength,alts[i].getSeq().length())))) {
            log.warn(""String_Node_Str"" + line);
            return null;
          }
          alts[i].setSeq(new FlexSeq(alts[i].getSeq().substring(0,Math.max(0,alts[i].length() - minClipLength))));
        }
      }
    }
    byte[] refs=new byte[REF.length()];
    for (int i=0; i < REF.length(); i++) {
      refs[i]=(byte)REF.charAt(i);
    }
    return new Variant.Builder().chr(chr).pos(pos).referenceAlleleLength(refs.length).ref(refs).alts(alts).phase(genotypeArray).isPhased(isGenotypePhased).varId(variantId).filter(FILTER).refDeleted(deletedReference).randomNumberGenerator(random).clippedSequence(clippedSequence).build();
  }
 else {
    log.warn(""String_Node_Str"" + line);
    return null;
  }
}",0.9983372837584462
80605,"/** 
 * Fills in the insertions sequence with random sequence sampled from known insertions
 * @param var        Variant to be filled in
 * @param insertSeq Sequence on known insertions all concatented together
 * @param geno       allele to be filled in
 */
public void fillInSeq(Variant var,byte[] insertSeq,int geno){
  Alt alt=var.getAlt(geno);
  if (alt != null) {
    if (alt.getSeqType() == FlexSeq.Type.INS) {
      final double NSEGMENTS=10.0;
      int len=alt.length();
      byte newSeq[]=new byte[len];
      final int segLen=(len > insertSeq.length) ? (int)Math.ceil(insertSeq.length / NSEGMENTS) : len;
      for (int i=0; i < len; i+=segLen) {
        int randStart=rand.nextInt(insertSeq.length - segLen);
        System.arraycopy(insertSeq,randStart,newSeq,i,Math.min(segLen,len - i));
      }
      alt=new Alt(new FlexSeq(newSeq));
    }
    var.setAlt(geno,alt);
  }
}","/** 
 * Fills in the insertions sequence with random sequence sampled from known insertions
 * @param var        Variant to be filled in
 * @param insertSeq Sequence on known insertions all concatented together
 * @param geno       allele to be filled in
 */
public void fillInSeq(Variant var,byte[] insertSeq,int geno){
  Alt alt=var.getAlt(geno);
  if (alt != null) {
    if (alt.getSeqType() == FlexSeq.Type.INS) {
      final double NSEGMENTS=10.0;
      int len=alt.length();
      byte newSeq[]=new byte[len];
      final int segLen=(len >= insertSeq.length) ? (int)Math.ceil(insertSeq.length / NSEGMENTS) : len;
      for (int i=0; i < len; i+=segLen) {
        int randStart=rand.nextInt(insertSeq.length - segLen);
        System.arraycopy(insertSeq,randStart,newSeq,i,Math.min(segLen,len - i));
      }
      alt=new Alt(new FlexSeq(newSeq));
    }
    var.setAlt(geno,alt);
  }
}",0.9994378864530636
80606,"/** 
 * @param start 0-based start, consistent with BED
 * @param end non-inclusive end, consistent with BED
 * @return number of non-N based in the sequence in the region of interest
 */
public int getNumNonNBases(final int start,final int end){
  int count=0;
  for (int index=start; start < end; index++) {
    if (!isN(_seq[index]))     count++;
  }
  return count;
}","/** 
 * @param start 0-based start, consistent with BED
 * @param end non-inclusive end, consistent with BED
 * @return number of non-N based in the sequence in the region of interest
 */
public int getNumNonNBases(final int start,final int end){
  int count=0;
  for (int index=start; index < end; index++) {
    if (!isN(_seq[index]))     count++;
  }
  return count;
}",0.9865229110512128
80607,"private String getSummaryStats(List<Integer> list){
  double[] a=list.stream().mapToDouble(Integer::intValue).toArray();
  StringBuilder sb=new StringBuilder();
  sb.append(""String_Node_Str"" + StatUtils.max(a) + ""String_Node_Str"");
  sb.append(""String_Node_Str"" + StatUtils.min(a) + ""String_Node_Str"");
  sb.append(""String_Node_Str"" + StatUtils.mean(a) + ""String_Node_Str"");
  sb.append(""String_Node_Str"" + StatUtils.sum(a) + ""String_Node_Str"");
  sb.append(""String_Node_Str"" + StatUtils.variance(a) + ""String_Node_Str"");
  sb.append(""String_Node_Str"" + StatUtils.percentile(a,0.05) + ""String_Node_Str"");
  sb.append(""String_Node_Str"" + StatUtils.percentile(a,0.25) + ""String_Node_Str"");
  sb.append(""String_Node_Str"" + StatUtils.percentile(a,0.5) + ""String_Node_Str"");
  sb.append(""String_Node_Str"" + StatUtils.percentile(a,0.75) + ""String_Node_Str"");
  sb.append(""String_Node_Str"" + StatUtils.percentile(a,0.95) + ""String_Node_Str"");
  int binCount=Math.min(DISTANCE_METRIC_BIN_COUNT,a.length);
  double scalingFactor=Math.max((double)a.length / MAX_BIN_CAPACITY,1);
  EmpiricalDistribution distribution=new EmpiricalDistribution(binCount);
  distribution.load(a);
  sb.append(""String_Node_Str"");
  for (int i=0; i < binCount; i++) {
    sb.append(String.format(Locale.US,""String_Node_Str"",distribution.getUpperBounds()[i]) + ""String_Node_Str"");
    for (double j=0; j < distribution.getBinStats().get(i).getN() / scalingFactor; j++) {
      sb.append(""String_Node_Str"");
    }
    sb.append(""String_Node_Str"" + distribution.getBinStats().get(i).getN() + ""String_Node_Str"");
  }
  sb.append(""String_Node_Str"" + a.length + ""String_Node_Str"");
  int[] counts=new int[3];
  for (  Double i : a) {
    if (i.intValue() < counts.length) {
      counts[i.intValue()]++;
    }
  }
  sb.append(""String_Node_Str"" + counts[0] + ""String_Node_Str"");
  sb.append(""String_Node_Str"" + counts[1] + ""String_Node_Str"");
  sb.append(""String_Node_Str"" + counts[2] + ""String_Node_Str"");
  return sb.toString();
}","private String getSummaryStats(List<Integer> list){
  double[] a=list.stream().mapToDouble(Integer::intValue).toArray();
  StringBuilder sb=new StringBuilder();
  sb.append(""String_Node_Str"" + StatUtils.max(a) + ""String_Node_Str"");
  sb.append(""String_Node_Str"" + StatUtils.min(a) + ""String_Node_Str"");
  sb.append(""String_Node_Str"" + StatUtils.mean(a) + ""String_Node_Str"");
  sb.append(""String_Node_Str"" + StatUtils.sum(a) + ""String_Node_Str"");
  sb.append(""String_Node_Str"" + StatUtils.variance(a) + ""String_Node_Str"");
  sb.append(""String_Node_Str"" + StatUtils.percentile(a,5) + ""String_Node_Str"");
  sb.append(""String_Node_Str"" + StatUtils.percentile(a,25) + ""String_Node_Str"");
  sb.append(""String_Node_Str"" + StatUtils.percentile(a,50) + ""String_Node_Str"");
  sb.append(""String_Node_Str"" + StatUtils.percentile(a,75) + ""String_Node_Str"");
  sb.append(""String_Node_Str"" + StatUtils.percentile(a,95) + ""String_Node_Str"");
  int binCount=Math.min(DISTANCE_METRIC_BIN_COUNT,a.length);
  double scalingFactor=Math.max((double)a.length / MAX_BIN_CAPACITY,1);
  EmpiricalDistribution distribution=new EmpiricalDistribution(binCount);
  distribution.load(a);
  sb.append(""String_Node_Str"");
  for (int i=0; i < binCount; i++) {
    sb.append(String.format(Locale.US,""String_Node_Str"",distribution.getUpperBounds()[i]) + ""String_Node_Str"");
    for (double j=0; j < distribution.getBinStats().get(i).getN() / scalingFactor; j++) {
      sb.append(""String_Node_Str"");
    }
    sb.append(""String_Node_Str"" + distribution.getBinStats().get(i).getN() + ""String_Node_Str"");
  }
  sb.append(""String_Node_Str"" + a.length + ""String_Node_Str"");
  int[] counts=new int[3];
  for (  Double i : a) {
    if (i.intValue() < counts.length) {
      counts[i.intValue()]++;
    }
  }
  sb.append(""String_Node_Str"" + counts[0] + ""String_Node_Str"");
  sb.append(""String_Node_Str"" + counts[1] + ""String_Node_Str"");
  sb.append(""String_Node_Str"" + counts[2] + ""String_Node_Str"");
  return sb.toString();
}",0.9969818913480886
80608,"public ReadMap(final File file) throws IOException {
  log.info(""String_Node_Str"" + file);
  bufferedReader=new BufferedReader(new InputStreamReader(decompressStream(file)));
  while (hasMoreInput()) {
    readLine();
    log.trace(""String_Node_Str"" + line);
    if (line == null || line.trim().isEmpty()) {
      break;
    }
    final ReadMapRecord record=parseLine();
    readMap.put(record.getReadName(),record);
  }
  log.info(""String_Node_Str"");
}","public ReadMap(final File file) throws IOException {
  log.info(""String_Node_Str"" + file);
  bufferedReader=new BufferedReader(new InputStreamReader(decompressStream(file)));
  while (hasMoreInput()) {
    readLine();
    log.trace(""String_Node_Str"" + line);
    if (line == null)     break;
    if (line.trim().isEmpty())     continue;
    final ReadMapRecord record=parseLine();
    readMap.put(record.getReadName(),record);
  }
  log.info(""String_Node_Str"");
}",0.6768558951965066
80609,"public ReadMap(final File file) throws IOException {
  log.info(""String_Node_Str"" + file);
  bufferedReader=new BufferedReader(new InputStreamReader(decompressStream(file)));
  while (hasMoreInput()) {
    readLine();
    log.trace(""String_Node_Str"" + line);
    if (line == null || line.trim().isEmpty()) {
      break;
    }
    final ReadMapRecord record=parseLine();
    readMap.put(record.getReadName(),record);
  }
  log.info(""String_Node_Str"");
}","public ReadMap(final File file) throws IOException {
  log.info(""String_Node_Str"" + file);
  bufferedReader=new BufferedReader(new InputStreamReader(decompressStream(file)));
  while (hasMoreInput()) {
    readLine();
    log.trace(""String_Node_Str"" + line);
    if (line == null)     break;
    if (line.trim().isEmpty())     continue;
    final ReadMapRecord record=parseLine();
    readMap.put(record.getReadName(),record);
  }
  log.info(""String_Node_Str"");
}",0.6768558951965066
80610,"/** 
 * actual implementation for canonicalization
 * @param variant
 * @param end
 * @return
 */
private List<Variant> canonicalizeVariant(Variant variant,boolean end){
  List<Variant> variantList=new ArrayList<>();
  boolean noSplit=false;
  if (variant.getType() == VariantOverallType.SNP) {
    noSplit=true;
  }
  if (variant.getCompositions() == null && variant.getGoodPaternal() == 0 && variant.getGoodMaternal() == 0) {
    noSplit=true;
  }
  if (variant.getGoodPaternal() != 0 && !canonicalizableFlexSeqTypes.contains(variant.getAlt(variant.getGoodPaternal()).getSeqType())) {
    noSplit=true;
  }
  if (variant.getGoodMaternal() != 0 && !canonicalizableFlexSeqTypes.contains(variant.getAlt(variant.getGoodMaternal()).getSeqType())) {
    noSplit=true;
  }
  if (variant.getGoodPaternal() != 0 && variant.getAlt(variant.getGoodPaternal()).length() == 0 && variant.getReference().length == 0) {
    noSplit=true;
  }
  if (variant.getGoodMaternal() > 0 && variant.getAlt(variant.getGoodMaternal()).length() == 0 && variant.getReference().length == 0) {
    noSplit=true;
  }
  if (noSplit) {
    variantList.add(variant);
    return variantList;
  }
  if (variant.getCompositions() != null) {
    for (    Variant c : variant.getCompositions()) {
      variantList.addAll(canonicalizeVariant(new Variant(c),end));
    }
    return variantList;
  }
  Variant.Builder template=new Variant.Builder().chr(variant.getChr()).isPhased(true).varId(variant.getVariantId()).filter(VCFparser.DEFAULT_FILTER).refDeleted(""String_Node_Str"");
  if (variant.getType(variant.getGoodMaternal()) == VariantType.Translocation_Duplication || variant.getType(variant.getGoodMaternal()) == VariantType.Interspersed_Duplication || variant.getType(variant.getGoodPaternal()) == VariantType.Translocation_Duplication || variant.getType(variant.getGoodPaternal()) == VariantType.Interspersed_Duplication) {
    for (int parentIndex=0; parentIndex < 2; parentIndex++) {
      int allele=variant.getAllele(parentIndex);
      if (variant.getType(allele) == VariantType.Reference)       continue;
      byte[] phase=new byte[2];
      phase[parentIndex]=1;
      if (variant.getType(allele) == VariantType.Translocation_Duplication || variant.getType(allele) == VariantType.Interspersed_Duplication) {
        boolean isInversed=variant.isInversed();
        Alt alt1=new Alt();
        alt1.setBreakend(new Alt.Breakend(variant.getReference().clone(),variant.getChr2(allele),isInversed ? variant.getEnd2(allele) : variant.getPos2(allele),true,!isInversed));
        variantList.add(template.pos(variant.getPos() - 1).referenceAlleleLength(0).ref(new byte[0]).alts(new Alt[]{alt1}).phase(phase).build());
        Alt alt2=new Alt();
        alt2.setBreakend(new Alt.Breakend(ambiguousBase,variant.getChr2(parentIndex),isInversed ? variant.getPos2(parentIndex) : variant.getEnd2(parentIndex),false,isInversed));
        variantList.add(template.pos(variant.getPos()).referenceAlleleLength(0).ref(new byte[0]).alts(new Alt[]{alt2}).phase(phase).build());
      }
      variant.setAllele(parentIndex,(byte)0);
    }
  }
 else   if (variant.getType(variant.getGoodMaternal()) == VariantType.Translocation_Deletion || variant.getType(variant.getGoodPaternal()) == VariantType.Translocation_Deletion) {
    for (int parentIndex=0; parentIndex < 2; parentIndex++) {
      int allele=variant.getAllele(parentIndex);
      if (variant.getType(allele) == VariantType.Reference)       continue;
      byte[] phase=new byte[2];
      phase[parentIndex]=1;
      if (variant.getType(allele) == VariantType.Translocation_Deletion) {
        Alt alt1=new Alt();
        alt1.setBreakend(new Alt.Breakend(variant.getReference().clone(),variant.getChr(),variant.getPos() + variant.getReferenceAlleleLength(),true,true));
        variantList.add(template.pos(variant.getPos() - 1).referenceAlleleLength(0).ref(new byte[0]).alts(new Alt[]{alt1}).phase(phase).build());
      }
      variant.setAllele(parentIndex,(byte)0);
    }
  }
 else   if (variant.getType(variant.getGoodPaternal()) != VariantType.Reference && variant.getType(variant.getGoodMaternal()) != VariantType.Reference) {
    int[] alleleNumber={variant.getAllele(0),variant.getAllele(1)};
    byte[][] alternativeAlleleSequence={variant.getAlt(alleleNumber[0]).getSequence(),variant.getAlt(alleleNumber[1]).getSequence()};
    byte[] referenceAlleleSequence=variant.getReference();
    int currentPosition=variant.getPos();
    int minMatchLength=variant.getMinMatchLength();
    if (minMatchLength > 0) {
      referenceAlleleSequence=Arrays.copyOfRange(referenceAlleleSequence,minMatchLength,referenceAlleleSequence.length);
      for (int i=0; i < 2; i++) {
        alternativeAlleleSequence[i]=Arrays.copyOfRange(alternativeAlleleSequence[i],minMatchLength,alternativeAlleleSequence[i].length);
      }
      currentPosition+=minMatchLength;
    }
    int[] alleleLengthDifference={alternativeAlleleSequence[0].length - referenceAlleleSequence.length,alternativeAlleleSequence[1].length - referenceAlleleSequence.length};
    canonicalizeToIndels(variantList,alleleLengthDifference,referenceAlleleSequence,alternativeAlleleSequence,variant,currentPosition,end);
    for (int relativePosition=0; relativePosition < referenceAlleleSequence.length; relativePosition++, currentPosition++) {
      int[] alleleSpecificRelativePosition=new int[2];
      if (end) {
        for (int j=0; j < 2; j++) {
          if (relativePosition < referenceAlleleSequence.length + alleleLengthDifference[j]) {
            alleleSpecificRelativePosition[j]=relativePosition;
          }
 else {
            alleleSpecificRelativePosition[j]=-1;
          }
        }
      }
 else {
        for (int j=0; j < 2; j++) {
          alleleSpecificRelativePosition[j]=relativePosition + alleleLengthDifference[j];
        }
      }
      if (alleleSpecificRelativePosition[0] < 0 && alleleSpecificRelativePosition[1] < 0) {
      }
 else       if (alleleSpecificRelativePosition[0] >= 0 && alleleSpecificRelativePosition[1] < 0 && alternativeAlleleSequence[0][alleleSpecificRelativePosition[0]] != referenceAlleleSequence[relativePosition]) {
        byte[] phase={1,1};
        Alt alt=new Alt();
        alt.setSeq(new FlexSeq(alternativeAlleleSequence[0][alleleSpecificRelativePosition[0]]));
        variantList.add(template.pos(currentPosition).referenceAlleleLength(1).ref(new byte[]{referenceAlleleSequence[relativePosition]}).alts(new Alt[]{alt}).phase(phase).build());
      }
 else       if (alleleSpecificRelativePosition[0] < 0 && alleleSpecificRelativePosition[1] >= 0 && alternativeAlleleSequence[1][alleleSpecificRelativePosition[1]] != referenceAlleleSequence[relativePosition]) {
        byte[] phase={1,1};
        Alt alt=new Alt();
        alt.setSeq(new FlexSeq(alternativeAlleleSequence[1][alleleSpecificRelativePosition[1]]));
        variantList.add(template.pos(currentPosition).referenceAlleleLength(1).ref(new byte[]{referenceAlleleSequence[relativePosition]}).alts(new Alt[]{alt}).phase(phase).build());
      }
 else       if (alleleSpecificRelativePosition[0] >= 0 && alleleSpecificRelativePosition[1] < 0 && alternativeAlleleSequence[0][alleleSpecificRelativePosition[0]] == referenceAlleleSequence[relativePosition]) {
      }
 else       if (alleleSpecificRelativePosition[0] < 0 && alleleSpecificRelativePosition[1] >= 0 && alternativeAlleleSequence[1][alleleSpecificRelativePosition[1]] == referenceAlleleSequence[relativePosition]) {
      }
 else       if (alternativeAlleleSequence[0][alleleSpecificRelativePosition[0]] == referenceAlleleSequence[relativePosition] && alternativeAlleleSequence[1][alleleSpecificRelativePosition[1]] == referenceAlleleSequence[relativePosition]) {
      }
 else       if (alternativeAlleleSequence[0][alleleSpecificRelativePosition[0]] == alternativeAlleleSequence[1][alleleSpecificRelativePosition[1]]) {
        byte[] phase={1,1};
        Alt alt=new Alt();
        alt.setSeq(new FlexSeq(alternativeAlleleSequence[0][alleleSpecificRelativePosition[0]]));
        variantList.add(template.pos(currentPosition).referenceAlleleLength(1).ref(new byte[]{referenceAlleleSequence[relativePosition]}).alts(new Alt[]{alt}).phase(phase).build());
      }
 else       if (alternativeAlleleSequence[0][alleleSpecificRelativePosition[0]] != referenceAlleleSequence[relativePosition] && alternativeAlleleSequence[1][alleleSpecificRelativePosition[1]] != referenceAlleleSequence[relativePosition]) {
        byte[] phase={1,2};
        Alt[] alts=new Alt[2];
        alts[0]=new Alt();
        alts[1]=new Alt();
        alts[0].setSeq(new FlexSeq(alternativeAlleleSequence[0][alleleSpecificRelativePosition[0]]));
        alts[1].setSeq(new FlexSeq(alternativeAlleleSequence[1][alleleSpecificRelativePosition[1]]));
        variantList.add(template.pos(currentPosition).referenceAlleleLength(1).ref(new byte[]{referenceAlleleSequence[relativePosition]}).alts(alts).phase(phase).build());
      }
 else {
        for (int a=0; a < 2; a++) {
          if (alternativeAlleleSequence[a][alleleSpecificRelativePosition[a]] != referenceAlleleSequence[relativePosition]) {
            byte[] phase={0,0};
            phase[a]=1;
            Alt alt=new Alt();
            alt.setSeq(new FlexSeq(alternativeAlleleSequence[a][alleleSpecificRelativePosition[a]]));
            variantList.add(template.pos(currentPosition).referenceAlleleLength(1).ref(new byte[]{referenceAlleleSequence[relativePosition]}).alts(new Alt[]{alt}).phase(phase).build());
          }
        }
      }
    }
    variant.setAllele(0,(byte)0);
    variant.setAllele(1,(byte)0);
  }
 else {
    for (int alleleIndex=0; alleleIndex < 2; alleleIndex++) {
      int allele=variant.getAllele(alleleIndex);
      if (variant.getType(allele) == VariantType.Complex || variant.getType(allele) == VariantType.MNP || variant.getType(allele) == VariantType.SNP) {
        byte[] alternativeAlleleSequence=variant.getAlt(allele).getSequence();
        byte[] referenceSequence=variant.getReference();
        int currentPosition=variant.getPos();
        int alleleLengthDifference=alternativeAlleleSequence.length - referenceSequence.length;
        if (alleleLengthDifference > 0) {
          byte[] phase={0,0};
          phase[alleleIndex]=1;
          if (end) {
            Alt alt=new Alt();
            alt.setSeq(new FlexSeq(Arrays.copyOfRange(alternativeAlleleSequence,0,alleleLengthDifference)));
            variantList.add(template.pos(currentPosition + referenceSequence.length).referenceAlleleLength(0).ref(new byte[0]).alts(new Alt[]{alt}).phase(phase).build());
          }
 else {
            Alt alt=new Alt();
            alt.setSeq(new FlexSeq(Arrays.copyOfRange(alternativeAlleleSequence,0,alleleLengthDifference)));
            variantList.add(template.pos(currentPosition).referenceAlleleLength(0).ref(new byte[0]).alts(new Alt[]{alt}).phase(phase).build());
          }
        }
 else         if (alleleLengthDifference < 0) {
          byte[] phase={0,0};
          phase[alleleIndex]=1;
          if (end) {
            Alt alt=new Alt();
            alt.setSeq(new FlexSeq());
            variantList.add(template.pos(currentPosition + alternativeAlleleSequence.length).referenceAlleleLength(-alleleLengthDifference).ref(Arrays.copyOfRange(referenceSequence,alternativeAlleleSequence.length,alternativeAlleleSequence.length - alleleLengthDifference)).alts(new Alt[]{alt}).phase(phase).build());
          }
 else {
            Alt alt=new Alt();
            alt.setSeq(new FlexSeq());
            variantList.add(template.pos(currentPosition).referenceAlleleLength(-alleleLengthDifference).ref(Arrays.copyOfRange(referenceSequence,0,-alleleLengthDifference)).alts(new Alt[]{alt}).phase(phase).build());
          }
        }
        for (int i=0; i < referenceSequence.length; i++) {
          int idx;
          if (end) {
            if (i < referenceSequence.length + alleleLengthDifference) {
              idx=i;
            }
 else {
              idx=-1;
            }
          }
 else {
            idx=i + alleleLengthDifference;
          }
          if (idx >= 0 && alternativeAlleleSequence[idx] != referenceSequence[i]) {
            byte[] phase={0,0};
            phase[alleleIndex]=1;
            Alt alt=new Alt();
            alt.setSeq(new FlexSeq(alternativeAlleleSequence[idx]));
            variantList.add(template.pos(currentPosition).referenceAlleleLength(1).ref(new byte[]{referenceSequence[i]}).alts(new Alt[]{alt}).phase(phase).build());
          }
          currentPosition++;
        }
        variant.setAllele(alleleIndex,(byte)0);
      }
    }
  }
  if (!variant.isRef()) {
    variantList.add(variant);
  }
  return variantList;
}","/** 
 * actual implementation for canonicalization
 * @param variant
 * @param end
 * @return
 */
private List<Variant> canonicalizeVariant(Variant variant,boolean end){
  List<Variant> variantList=new ArrayList<>();
  boolean noSplit=false;
  if (variant.getType() == VariantOverallType.SNP) {
    noSplit=true;
  }
  if (variant.getCompositions() == null && variant.getGoodPaternal() == 0 && variant.getGoodMaternal() == 0) {
    noSplit=true;
  }
  if (variant.getGoodPaternal() != 0 && !canonicalizableFlexSeqTypes.contains(variant.getAlt(variant.getGoodPaternal()).getSeqType())) {
    noSplit=true;
  }
  if (variant.getGoodMaternal() != 0 && !canonicalizableFlexSeqTypes.contains(variant.getAlt(variant.getGoodMaternal()).getSeqType())) {
    noSplit=true;
  }
  if (variant.getGoodPaternal() != 0 && variant.getAlt(variant.getGoodPaternal()).length() == 0 && variant.getReference().length == 0) {
    noSplit=true;
  }
  if (variant.getGoodMaternal() > 0 && variant.getAlt(variant.getGoodMaternal()).length() == 0 && variant.getReference().length == 0) {
    noSplit=true;
  }
  if (noSplit) {
    variantList.add(variant);
    return variantList;
  }
  if (variant.getCompositions() != null) {
    for (    Variant c : variant.getCompositions()) {
      variantList.addAll(canonicalizeVariant(new Variant(c),end));
    }
    return variantList;
  }
  Variant.Builder template=new Variant.Builder().chr(variant.getChr()).isPhased(true).varId(variant.getVariantId()).filter(VCFparser.DEFAULT_FILTER).refDeleted(""String_Node_Str"");
  if (variant.getType(variant.getGoodMaternal()) == VariantType.Translocation_Duplication || variant.getType(variant.getGoodMaternal()) == VariantType.Interspersed_Duplication || variant.getType(variant.getGoodPaternal()) == VariantType.Translocation_Duplication || variant.getType(variant.getGoodPaternal()) == VariantType.Interspersed_Duplication) {
    for (int parentIndex=0; parentIndex < 2; parentIndex++) {
      int allele=variant.getAllele(parentIndex);
      if (variant.getType(allele) == VariantType.Reference)       continue;
      byte[] phase=new byte[2];
      phase[parentIndex]=1;
      if (variant.getType(allele) == VariantType.Translocation_Duplication || variant.getType(allele) == VariantType.Interspersed_Duplication) {
        boolean isInversed=variant.isInversed();
        Alt alt1=new Alt();
        alt1.setBreakend(new Alt.Breakend(variant.getReference().clone(),variant.getChr2(allele),isInversed ? variant.getEnd2(allele) : variant.getPos2(allele),true,!isInversed));
        variantList.add(template.pos(variant.getPos() - 1).referenceAlleleLength(0).ref(new byte[]{'N'}).alts(new Alt[]{alt1}).phase(phase).build());
        Alt alt2=new Alt();
        alt2.setBreakend(new Alt.Breakend(ambiguousBase,variant.getChr2(parentIndex),isInversed ? variant.getPos2(parentIndex) : variant.getEnd2(parentIndex),false,isInversed));
        variantList.add(template.pos(variant.getPos()).referenceAlleleLength(0).ref(new byte[]{'N'}).alts(new Alt[]{alt2}).phase(phase).build());
      }
      variant.setAllele(parentIndex,(byte)0);
    }
  }
 else   if (variant.getType(variant.getGoodMaternal()) == VariantType.Translocation_Deletion || variant.getType(variant.getGoodPaternal()) == VariantType.Translocation_Deletion) {
    for (int parentIndex=0; parentIndex < 2; parentIndex++) {
      int allele=variant.getAllele(parentIndex);
      if (variant.getType(allele) == VariantType.Reference)       continue;
      byte[] phase=new byte[2];
      phase[parentIndex]=1;
      if (variant.getType(allele) == VariantType.Translocation_Deletion) {
        Alt alt1=new Alt();
        alt1.setBreakend(new Alt.Breakend(variant.getReference().clone(),variant.getChr(),variant.getPos() + variant.getReferenceAlleleLength(),true,true));
        variantList.add(template.pos(variant.getPos() - 1).referenceAlleleLength(0).ref(new byte[]{'N'}).alts(new Alt[]{alt1}).phase(phase).build());
      }
      variant.setAllele(parentIndex,(byte)0);
    }
  }
 else   if (variant.getType(variant.getGoodPaternal()) != VariantType.Reference && variant.getType(variant.getGoodMaternal()) != VariantType.Reference) {
    int[] alleleNumber={variant.getAllele(0),variant.getAllele(1)};
    byte[][] alternativeAlleleSequence={variant.getAlt(alleleNumber[0]).getSequence(),variant.getAlt(alleleNumber[1]).getSequence()};
    byte[] referenceAlleleSequence=variant.getReference();
    int currentPosition=variant.getPos();
    int minMatchLength=variant.getMinMatchLength();
    if (minMatchLength > 0) {
      referenceAlleleSequence=Arrays.copyOfRange(referenceAlleleSequence,minMatchLength,referenceAlleleSequence.length);
      for (int i=0; i < 2; i++) {
        alternativeAlleleSequence[i]=Arrays.copyOfRange(alternativeAlleleSequence[i],minMatchLength,alternativeAlleleSequence[i].length);
      }
      currentPosition+=minMatchLength;
    }
    int[] alleleLengthDifference={alternativeAlleleSequence[0].length - referenceAlleleSequence.length,alternativeAlleleSequence[1].length - referenceAlleleSequence.length};
    canonicalizeToIndels(variantList,alleleLengthDifference,referenceAlleleSequence,alternativeAlleleSequence,variant,currentPosition,end);
    for (int relativePosition=0; relativePosition < referenceAlleleSequence.length; relativePosition++, currentPosition++) {
      int[] alleleSpecificRelativePosition=new int[2];
      if (end) {
        for (int j=0; j < 2; j++) {
          if (relativePosition < referenceAlleleSequence.length + alleleLengthDifference[j]) {
            alleleSpecificRelativePosition[j]=relativePosition;
          }
 else {
            alleleSpecificRelativePosition[j]=-1;
          }
        }
      }
 else {
        for (int j=0; j < 2; j++) {
          alleleSpecificRelativePosition[j]=relativePosition + alleleLengthDifference[j];
        }
      }
      if (alleleSpecificRelativePosition[0] < 0 && alleleSpecificRelativePosition[1] < 0) {
      }
 else       if (alleleSpecificRelativePosition[0] >= 0 && alleleSpecificRelativePosition[1] < 0 && alternativeAlleleSequence[0][alleleSpecificRelativePosition[0]] != referenceAlleleSequence[relativePosition]) {
        byte[] phase={1,1};
        Alt alt=new Alt();
        alt.setSeq(new FlexSeq(alternativeAlleleSequence[0][alleleSpecificRelativePosition[0]]));
        variantList.add(template.pos(currentPosition).referenceAlleleLength(1).ref(new byte[]{referenceAlleleSequence[relativePosition]}).alts(new Alt[]{alt}).phase(phase).build());
      }
 else       if (alleleSpecificRelativePosition[0] < 0 && alleleSpecificRelativePosition[1] >= 0 && alternativeAlleleSequence[1][alleleSpecificRelativePosition[1]] != referenceAlleleSequence[relativePosition]) {
        byte[] phase={1,1};
        Alt alt=new Alt();
        alt.setSeq(new FlexSeq(alternativeAlleleSequence[1][alleleSpecificRelativePosition[1]]));
        variantList.add(template.pos(currentPosition).referenceAlleleLength(1).ref(new byte[]{referenceAlleleSequence[relativePosition]}).alts(new Alt[]{alt}).phase(phase).build());
      }
 else       if (alleleSpecificRelativePosition[0] >= 0 && alleleSpecificRelativePosition[1] < 0 && alternativeAlleleSequence[0][alleleSpecificRelativePosition[0]] == referenceAlleleSequence[relativePosition]) {
      }
 else       if (alleleSpecificRelativePosition[0] < 0 && alleleSpecificRelativePosition[1] >= 0 && alternativeAlleleSequence[1][alleleSpecificRelativePosition[1]] == referenceAlleleSequence[relativePosition]) {
      }
 else       if (alternativeAlleleSequence[0][alleleSpecificRelativePosition[0]] == referenceAlleleSequence[relativePosition] && alternativeAlleleSequence[1][alleleSpecificRelativePosition[1]] == referenceAlleleSequence[relativePosition]) {
      }
 else       if (alternativeAlleleSequence[0][alleleSpecificRelativePosition[0]] == alternativeAlleleSequence[1][alleleSpecificRelativePosition[1]]) {
        byte[] phase={1,1};
        Alt alt=new Alt();
        alt.setSeq(new FlexSeq(alternativeAlleleSequence[0][alleleSpecificRelativePosition[0]]));
        variantList.add(template.pos(currentPosition).referenceAlleleLength(1).ref(new byte[]{referenceAlleleSequence[relativePosition]}).alts(new Alt[]{alt}).phase(phase).build());
      }
 else       if (alternativeAlleleSequence[0][alleleSpecificRelativePosition[0]] != referenceAlleleSequence[relativePosition] && alternativeAlleleSequence[1][alleleSpecificRelativePosition[1]] != referenceAlleleSequence[relativePosition]) {
        byte[] phase={1,2};
        Alt[] alts=new Alt[2];
        alts[0]=new Alt();
        alts[1]=new Alt();
        alts[0].setSeq(new FlexSeq(alternativeAlleleSequence[0][alleleSpecificRelativePosition[0]]));
        alts[1].setSeq(new FlexSeq(alternativeAlleleSequence[1][alleleSpecificRelativePosition[1]]));
        variantList.add(template.pos(currentPosition).referenceAlleleLength(1).ref(new byte[]{referenceAlleleSequence[relativePosition]}).alts(alts).phase(phase).build());
      }
 else {
        for (int a=0; a < 2; a++) {
          if (alternativeAlleleSequence[a][alleleSpecificRelativePosition[a]] != referenceAlleleSequence[relativePosition]) {
            byte[] phase={0,0};
            phase[a]=1;
            Alt alt=new Alt();
            alt.setSeq(new FlexSeq(alternativeAlleleSequence[a][alleleSpecificRelativePosition[a]]));
            variantList.add(template.pos(currentPosition).referenceAlleleLength(1).ref(new byte[]{referenceAlleleSequence[relativePosition]}).alts(new Alt[]{alt}).phase(phase).build());
          }
        }
      }
    }
    variant.setAllele(0,(byte)0);
    variant.setAllele(1,(byte)0);
  }
 else {
    for (int alleleIndex=0; alleleIndex < 2; alleleIndex++) {
      int allele=variant.getAllele(alleleIndex);
      if (variant.getType(allele) == VariantType.Complex || variant.getType(allele) == VariantType.MNP || variant.getType(allele) == VariantType.SNP) {
        byte[] alternativeAlleleSequence=variant.getAlt(allele).getSequence();
        byte[] referenceSequence=variant.getReference();
        int currentPosition=variant.getPos();
        int alleleLengthDifference=alternativeAlleleSequence.length - referenceSequence.length;
        if (alleleLengthDifference > 0) {
          byte[] phase={0,0};
          phase[alleleIndex]=1;
          if (end) {
            Alt alt=new Alt();
            alt.setSeq(new FlexSeq(Arrays.copyOfRange(alternativeAlleleSequence,0,alleleLengthDifference)));
            variantList.add(template.pos(currentPosition + referenceSequence.length).referenceAlleleLength(0).ref(new byte[]{'N'}).alts(new Alt[]{alt}).phase(phase).build());
          }
 else {
            Alt alt=new Alt();
            alt.setSeq(new FlexSeq(Arrays.copyOfRange(alternativeAlleleSequence,0,alleleLengthDifference)));
            variantList.add(template.pos(currentPosition).referenceAlleleLength(0).ref(new byte[]{'N'}).alts(new Alt[]{alt}).phase(phase).build());
          }
        }
 else         if (alleleLengthDifference < 0) {
          byte[] phase={0,0};
          phase[alleleIndex]=1;
          if (end) {
            Alt alt=new Alt();
            alt.setSeq(new FlexSeq());
            variantList.add(template.pos(currentPosition + alternativeAlleleSequence.length).referenceAlleleLength(-alleleLengthDifference).ref(Arrays.copyOfRange(referenceSequence,alternativeAlleleSequence.length,alternativeAlleleSequence.length - alleleLengthDifference)).alts(new Alt[]{alt}).phase(phase).build());
          }
 else {
            Alt alt=new Alt();
            alt.setSeq(new FlexSeq());
            variantList.add(template.pos(currentPosition).referenceAlleleLength(-alleleLengthDifference).ref(Arrays.copyOfRange(referenceSequence,0,-alleleLengthDifference)).alts(new Alt[]{alt}).phase(phase).build());
          }
        }
        for (int i=0; i < referenceSequence.length; i++) {
          int idx;
          if (end) {
            if (i < referenceSequence.length + alleleLengthDifference) {
              idx=i;
            }
 else {
              idx=-1;
            }
          }
 else {
            idx=i + alleleLengthDifference;
          }
          if (idx >= 0 && alternativeAlleleSequence[idx] != referenceSequence[i]) {
            byte[] phase={0,0};
            phase[alleleIndex]=1;
            Alt alt=new Alt();
            alt.setSeq(new FlexSeq(alternativeAlleleSequence[idx]));
            variantList.add(template.pos(currentPosition).referenceAlleleLength(1).ref(new byte[]{referenceSequence[i]}).alts(new Alt[]{alt}).phase(phase).build());
          }
          currentPosition++;
        }
        variant.setAllele(alleleIndex,(byte)0);
      }
    }
  }
  if (!variant.isRef()) {
    variantList.add(variant);
  }
  return variantList;
}",0.9984284142699984
80611,"/** 
 * canonicalize to indels
 * @param canonicalVariantList where results are saved
 * @param alleleLengthDifference
 * @param reference
 * @param alternativeAlleles
 * @param variant
 * @param currentPosition
 * @param end should we append indels to the end?
 */
private void canonicalizeToIndels(List<Variant> canonicalVariantList,int[] alleleLengthDifference,byte[] reference,byte[][] alternativeAlleles,Variant variant,int currentPosition,boolean end){
  Variant.Builder template=new Variant.Builder().chr(variant.getChr()).isPhased(true).varId(variant.getVariantId()).filter(VCFparser.DEFAULT_FILTER).refDeleted(""String_Node_Str"");
  if (alleleLengthDifference[0] == alleleLengthDifference[1] && alleleLengthDifference[0] != 0) {
    if (alleleLengthDifference[0] > 0) {
      if (Arrays.equals(alternativeAlleles[0],alternativeAlleles[1])) {
        byte[] phase={1,1};
        if (end) {
          Alt alt=new Alt();
          alt.setSeq(new FlexSeq(Arrays.copyOfRange(alternativeAlleles[0],0,alleleLengthDifference[0])));
          canonicalVariantList.add(template.pos(currentPosition + reference.length).referenceAlleleLength(0).ref(new byte[0]).alts(new Alt[]{alt}).phase(phase).build());
        }
 else {
          Alt alt=new Alt();
          alt.setSeq(new FlexSeq(Arrays.copyOfRange(alternativeAlleles[0],0,alleleLengthDifference[0])));
          canonicalVariantList.add(template.pos(currentPosition).referenceAlleleLength(0).ref(new byte[0]).alts(new Alt[]{alt}).phase(phase).build());
        }
      }
 else {
        byte[] phase={0,0};
        if (end) {
          phase[0]=1;
          phase[1]=0;
          Alt alt=new Alt();
          alt.setSeq(new FlexSeq(Arrays.copyOfRange(alternativeAlleles[0],0,alleleLengthDifference[0])));
          canonicalVariantList.add(template.pos(currentPosition + reference.length).referenceAlleleLength(0).ref(new byte[0]).alts(new Alt[]{alt}).phase(phase).build());
          phase[0]=0;
          phase[1]=1;
          Alt alt2=new Alt();
          alt2.setSeq(new FlexSeq(Arrays.copyOfRange(alternativeAlleles[1],0,alleleLengthDifference[1])));
          canonicalVariantList.add(template.pos(currentPosition + reference.length).referenceAlleleLength(0).ref(new byte[0]).alts(new Alt[]{alt2}).phase(phase).build());
        }
 else {
          phase[0]=1;
          phase[1]=0;
          Alt alt=new Alt();
          alt.setSeq(new FlexSeq(Arrays.copyOfRange(alternativeAlleles[0],0,alleleLengthDifference[0])));
          canonicalVariantList.add(template.pos(currentPosition).referenceAlleleLength(0).ref(new byte[0]).alts(new Alt[]{alt}).phase(phase).build());
          phase[0]=0;
          phase[1]=1;
          Alt alt2=new Alt();
          alt2.setSeq(new FlexSeq(Arrays.copyOfRange(alternativeAlleles[1],0,alleleLengthDifference[1])));
          canonicalVariantList.add(template.pos(currentPosition).referenceAlleleLength(0).ref(new byte[0]).alts(new Alt[]{alt2}).phase(phase).build());
        }
      }
    }
 else     if (alleleLengthDifference[0] < 0) {
      byte[] phase={1,1};
      if (end) {
        Alt alt=new Alt();
        alt.setSeq(new FlexSeq());
        canonicalVariantList.add(template.pos(currentPosition + alternativeAlleles[0].length).referenceAlleleLength(-alleleLengthDifference[0]).ref(Arrays.copyOfRange(reference,alternativeAlleles[0].length,alternativeAlleles[0].length - alleleLengthDifference[0])).alts(new Alt[]{alt}).phase(phase).build());
      }
 else {
        Alt alt=new Alt();
        alt.setSeq(new FlexSeq());
        canonicalVariantList.add(template.pos(currentPosition).referenceAlleleLength(-alleleLengthDifference[0]).ref(Arrays.copyOfRange(reference,0,-alleleLengthDifference[0])).alts(new Alt[]{alt}).phase(phase).build());
      }
    }
  }
 else {
    for (int a=0; a < alternativeAlleles.length; a++) {
      if (alleleLengthDifference[a] > 0) {
        byte[] phase={0,0};
        phase[a]=1;
        if (end) {
          Alt alt=new Alt();
          alt.setSeq(new FlexSeq(Arrays.copyOfRange(alternativeAlleles[a],0,alleleLengthDifference[a])));
          canonicalVariantList.add(template.pos(currentPosition + reference.length).referenceAlleleLength(0).ref(new byte[0]).alts(new Alt[]{alt}).phase(phase).build());
        }
 else {
          Alt alt=new Alt();
          alt.setSeq(new FlexSeq(Arrays.copyOfRange(alternativeAlleles[a],0,alleleLengthDifference[a])));
          canonicalVariantList.add(template.pos(currentPosition).referenceAlleleLength(0).ref(new byte[0]).alts(new Alt[]{alt}).phase(phase).build());
        }
      }
 else       if (alleleLengthDifference[a] < 0) {
        byte[] phase={0,0};
        phase[a]=1;
        if (end) {
          Alt alt=new Alt();
          alt.setSeq(new FlexSeq());
          canonicalVariantList.add(template.pos(currentPosition + alternativeAlleles[a].length).referenceAlleleLength(-alleleLengthDifference[a]).ref(Arrays.copyOfRange(reference,alternativeAlleles[a].length,alternativeAlleles[a].length - alleleLengthDifference[a])).alts(new Alt[]{alt}).phase(phase).build());
        }
 else {
          Alt alt=new Alt();
          alt.setSeq(new FlexSeq());
          canonicalVariantList.add(template.pos(currentPosition).referenceAlleleLength(-alleleLengthDifference[a]).ref(Arrays.copyOfRange(reference,0,-alleleLengthDifference[a])).alts(new Alt[]{alt}).phase(phase).build());
        }
      }
    }
  }
}","/** 
 * canonicalize to indels
 * @param canonicalVariantList where results are saved
 * @param alleleLengthDifference
 * @param reference
 * @param alternativeAlleles
 * @param variant
 * @param currentPosition
 * @param end should we append indels to the end?
 */
private void canonicalizeToIndels(List<Variant> canonicalVariantList,int[] alleleLengthDifference,byte[] reference,byte[][] alternativeAlleles,Variant variant,int currentPosition,boolean end){
  Variant.Builder template=new Variant.Builder().chr(variant.getChr()).isPhased(true).varId(variant.getVariantId()).filter(VCFparser.DEFAULT_FILTER).refDeleted(""String_Node_Str"");
  if (alleleLengthDifference[0] == alleleLengthDifference[1] && alleleLengthDifference[0] != 0) {
    if (alleleLengthDifference[0] > 0) {
      if (Arrays.equals(alternativeAlleles[0],alternativeAlleles[1])) {
        byte[] phase={1,1};
        if (end) {
          Alt alt=new Alt();
          alt.setSeq(new FlexSeq(Arrays.copyOfRange(alternativeAlleles[0],0,alleleLengthDifference[0])));
          canonicalVariantList.add(template.pos(currentPosition + reference.length).referenceAlleleLength(0).ref(new byte[]{'N'}).alts(new Alt[]{alt}).phase(phase).build());
        }
 else {
          Alt alt=new Alt();
          alt.setSeq(new FlexSeq(Arrays.copyOfRange(alternativeAlleles[0],0,alleleLengthDifference[0])));
          canonicalVariantList.add(template.pos(currentPosition).referenceAlleleLength(0).ref(new byte[]{'N'}).alts(new Alt[]{alt}).phase(phase).build());
        }
      }
 else {
        byte[] phase={0,0};
        if (end) {
          phase[0]=1;
          phase[1]=0;
          Alt alt=new Alt();
          alt.setSeq(new FlexSeq(Arrays.copyOfRange(alternativeAlleles[0],0,alleleLengthDifference[0])));
          canonicalVariantList.add(template.pos(currentPosition + reference.length).referenceAlleleLength(0).ref(new byte[]{'N'}).alts(new Alt[]{alt}).phase(phase).build());
          phase[0]=0;
          phase[1]=1;
          Alt alt2=new Alt();
          alt2.setSeq(new FlexSeq(Arrays.copyOfRange(alternativeAlleles[1],0,alleleLengthDifference[1])));
          canonicalVariantList.add(template.pos(currentPosition + reference.length).referenceAlleleLength(0).ref(new byte[]{'N'}).alts(new Alt[]{alt2}).phase(phase).build());
        }
 else {
          phase[0]=1;
          phase[1]=0;
          Alt alt=new Alt();
          alt.setSeq(new FlexSeq(Arrays.copyOfRange(alternativeAlleles[0],0,alleleLengthDifference[0])));
          canonicalVariantList.add(template.pos(currentPosition).referenceAlleleLength(0).ref(new byte[]{'N'}).alts(new Alt[]{alt}).phase(phase).build());
          phase[0]=0;
          phase[1]=1;
          Alt alt2=new Alt();
          alt2.setSeq(new FlexSeq(Arrays.copyOfRange(alternativeAlleles[1],0,alleleLengthDifference[1])));
          canonicalVariantList.add(template.pos(currentPosition).referenceAlleleLength(0).ref(new byte[]{'N'}).alts(new Alt[]{alt2}).phase(phase).build());
        }
      }
    }
 else     if (alleleLengthDifference[0] < 0) {
      byte[] phase={1,1};
      if (end) {
        Alt alt=new Alt();
        alt.setSeq(new FlexSeq());
        canonicalVariantList.add(template.pos(currentPosition + alternativeAlleles[0].length).referenceAlleleLength(-alleleLengthDifference[0]).ref(Arrays.copyOfRange(reference,alternativeAlleles[0].length,alternativeAlleles[0].length - alleleLengthDifference[0])).alts(new Alt[]{alt}).phase(phase).build());
      }
 else {
        Alt alt=new Alt();
        alt.setSeq(new FlexSeq());
        canonicalVariantList.add(template.pos(currentPosition).referenceAlleleLength(-alleleLengthDifference[0]).ref(Arrays.copyOfRange(reference,0,-alleleLengthDifference[0])).alts(new Alt[]{alt}).phase(phase).build());
      }
    }
  }
 else {
    for (int a=0; a < alternativeAlleles.length; a++) {
      if (alleleLengthDifference[a] > 0) {
        byte[] phase={0,0};
        phase[a]=1;
        if (end) {
          Alt alt=new Alt();
          alt.setSeq(new FlexSeq(Arrays.copyOfRange(alternativeAlleles[a],0,alleleLengthDifference[a])));
          canonicalVariantList.add(template.pos(currentPosition + reference.length).referenceAlleleLength(0).ref(new byte[]{'N'}).alts(new Alt[]{alt}).phase(phase).build());
        }
 else {
          Alt alt=new Alt();
          alt.setSeq(new FlexSeq(Arrays.copyOfRange(alternativeAlleles[a],0,alleleLengthDifference[a])));
          canonicalVariantList.add(template.pos(currentPosition).referenceAlleleLength(0).ref(new byte[]{'N'}).alts(new Alt[]{alt}).phase(phase).build());
        }
      }
 else       if (alleleLengthDifference[a] < 0) {
        byte[] phase={0,0};
        phase[a]=1;
        if (end) {
          Alt alt=new Alt();
          alt.setSeq(new FlexSeq());
          canonicalVariantList.add(template.pos(currentPosition + alternativeAlleles[a].length).referenceAlleleLength(-alleleLengthDifference[a]).ref(Arrays.copyOfRange(reference,alternativeAlleles[a].length,alternativeAlleles[a].length - alleleLengthDifference[a])).alts(new Alt[]{alt}).phase(phase).build());
        }
 else {
          Alt alt=new Alt();
          alt.setSeq(new FlexSeq());
          canonicalVariantList.add(template.pos(currentPosition).referenceAlleleLength(-alleleLengthDifference[a]).ref(Arrays.copyOfRange(reference,0,-alleleLengthDifference[a])).alts(new Alt[]{alt}).phase(phase).build());
        }
      }
    }
  }
}",0.9940839341837678
80612,"/** 
 * @return The midpoint of the interval floor((right+left)/2)
 */
public long getCenter(){
  return (((getRight() / 2) + (getLeft() / 2)));
}","/** 
 * @return The midpoint of the interval floor((right+left)/2)
 */
public long getCenter(){
  return Math.round(Math.floor(((getRight() / 2.0) + (getLeft() / 2.0))));
}",0.9182389937106918
80613,"CompareParams(String bamFilename,int wiggle,String bedFilename){
  this.bam_filename=bamFilename;
  this.wiggle=wiggle;
  this.bedFilename=bedFilename;
}","CompareParams(String bamFilename,int wiggle,String bedFilename,double identityThreshold){
  this.bamFilename=bamFilename;
  this.wiggle=wiggle;
  this.bedFilename=bedFilename;
  this.identityThreshold=identityThreshold;
}",0.8074866310160428
80614,"/** 
 * main execution code block expects alignments in SAM/BAM format read in alignment line by line, filter by alignment quality and mapping location determine if an alignment is false positive or not. outputs false positive alignments by type of sequence changes in the perturbed genome and a statistical report in json format
 * @param args command line arguments
 */
public void run(String[] args){
  if (!parseArguments(args)) {
    return;
  }
  OutputClass outputBlob=new OutputClass();
  outputBlob.setParams(new CompareParams(bamFilenames.get(0).substring(0,Math.min(64,bamFilenames.get(0).length())),wiggle,bedFilename));
  outputBlob.setStats(new MapRatioRecordSum());
  final SAMFileWriterFactory writerFactory=new SAMFileWriterFactory();
  final SamReaderFactory factory=SamReaderFactory.makeDefault().enable(SamReaderFactory.Option.INCLUDE_SOURCE_IN_RECORDS,SamReaderFactory.Option.VALIDATE_CRC_CHECKSUMS).validationStringency(ValidationStringency.LENIENT);
  final Map<BlockType,SAMFileWriter> fpWriters=new EnumMap<>(BlockType.class);
  try (final PrintWriter jsonWriter=new PrintWriter(outPrefix + ""String_Node_Str"",""String_Node_Str"");final SAMFileWriter tumFPWriter=writerFactory.makeBAMWriter(factory.getFileHeader(new File(bamFilenames.get(0))),false,new File(outPrefix + ""String_Node_Str""));final SAMFileWriter fpWriter=writerFactory.makeBAMWriter(factory.getFileHeader(new File(bamFilenames.get(0))),false,new File(outPrefix + ""String_Node_Str""))){
    for (    final BlockType blockType : BlockType.values()) {
      if (blockType != BlockType.UNKNOWN) {
        fpWriters.put(blockType,writerFactory.makeBAMWriter(factory.getFileHeader(new File(bamFilenames.get(0))),false,new File(outPrefix + ""String_Node_Str"" + blockType.getShortName()+ ""String_Node_Str"")));
      }
    }
    ReadMap readMap=readMapFile != null ? new ReadMap(readMapFile) : null;
    final BedFile intersector=(bedFilename != null && new File(bedFilename).isFile()) ? new BedFile(bedFilename) : null;
    int numReads=0;
    for (    String filename : bamFilenames) {
      log.info(""String_Node_Str"" + filename);
      final SamReader reader=factory.open(new File(filename));
      for (      SAMRecord rec : reader) {
        if (!useNonPrimary && (rec.getNotPrimaryAlignmentFlag() || rec.getSupplementaryAlignmentFlag())) {
          continue;
        }
        numReads++;
        if (numReads % 100000 == 0) {
          log.info(""String_Node_Str"" + numReads + ""String_Node_Str"");
        }
        String name=rec.getReadName();
        int pair_idx=rec.getReadPairedFlag() ? getPairIdx(rec.getFirstOfPairFlag()) : 0;
        log.trace(""String_Node_Str"" + name);
        final Collection<GenomeLocation> trueLoci=readMap != null ? readMap.getReadMapRecord(name).getUnclippedStarts(pair_idx) : new SimulatedRead(name).getLocs(pair_idx);
        if (!isContainedInBed(intersector,trueLoci,rec)) {
          continue;
        }
        boolean isTrueUnmapped;
        Set<EventTypesForStats> features=EnumSet.noneOf(EventTypesForStats.class);
        features.add(EventTypesForStats.All);
        isTrueUnmapped=true;
        if (!trueLoci.isEmpty()) {
          for (          GenomeLocation loc : trueLoci) {
            final BlockType feat=loc.feature;
            features.add(EventTypesForStats.valueOf(feat.getLongName()));
            isTrueUnmapped&=!feat.isMappable();
          }
        }
        if (isTrueUnmapped) {
          features.add(EventTypesForStats.True_Unmapped);
        }
 else {
          outputBlob.getStats().incStat(features,-1,StatsNamespace.T);
        }
        boolean unmapped=rec.getReadUnmappedFlag();
        int mappingQuality=unmapped ? MAPQ_UNMAPPED : rec.getMappingQuality();
        StatsNamespace validationStatus=StatsNamespace.TP;
        if (unmapped) {
          validationStatus=isTrueUnmapped ? StatsNamespace.TN : StatsNamespace.FN;
        }
 else {
          boolean closeAln=false;
          if (isTrueUnmapped) {
            if (getIdentity(rec) <= identityThreshold && mappingQuality > mapqCutoff) {
              tumFPWriter.addAlignment(rec);
            }
          }
 else {
            final GenomeLocation mappedLocation=new GenomeLocation(new ChrString(rec.getReferenceName()),rec.getUnclippedStart());
            for (            GenomeLocation loc : trueLoci) {
              closeAln|=loc.feature.isMappable() && loc.isClose(mappedLocation,wiggle);
            }
            if (!closeAln) {
              if (getIdentity(rec) <= identityThreshold && mappingQuality > mapqCutoff) {
                fpWriter.addAlignment(rec);
                validationStatus=StatsNamespace.FP;
                for (                final BlockType blockType : BlockType.values()) {
                  if (fpWriters.containsKey(blockType) && features.contains(EventTypesForStats.valueOf(blockType.getLongName()))) {
                    fpWriters.get(blockType).addAlignment(rec);
                  }
                }
              }
            }
          }
        }
        outputBlob.getStats().incStat(features,mappingQuality,validationStatus);
      }
      reader.close();
    }
    log.info(""String_Node_Str"" + numReads);
    log.info(""String_Node_Str"");
    log.info(outputBlob.getStats());
    ObjectMapper mapper=new ObjectMapper();
    mapper.configure(JsonGenerator.Feature.AUTO_CLOSE_TARGET,false);
    String jsonStr=""String_Node_Str"";
    try {
      jsonStr=mapper.writeValueAsString(outputBlob);
    }
 catch (    JsonProcessingException e) {
      e.printStackTrace();
      System.exit(1);
    }
    jsonWriter.print(jsonStr);
    if (htmlFile != null) {
      FileUtils.writeStringToFile(new File(outPrefix + ""String_Node_Str""),JSONInserter.insertJSON(FileUtils.readFileToString(htmlFile),jsonStr));
    }
    for (    final BlockType blockType : BlockType.values()) {
      if (blockType != BlockType.UNKNOWN) {
        fpWriters.get(blockType).close();
      }
    }
    fpWriters.values().stream().forEach(SAMFileWriter::close);
  }
 catch (  IOException e) {
    e.printStackTrace();
    System.exit(1);
  }
  log.info(""String_Node_Str"");
}","/** 
 * main execution code block expects alignments in SAM/BAM format read in alignment line by line, filter by alignment quality and mapping location determine if an alignment is false positive or not. outputs false positive alignments by type of sequence changes in the perturbed genome and a statistical report in json format
 * @param args command line arguments
 */
public void run(String[] args){
  if (!parseArguments(args)) {
    return;
  }
  OutputClass outputBlob=new OutputClass();
  outputBlob.setParams(new CompareParams(bamFilenames.get(0).substring(0,Math.min(64,bamFilenames.get(0).length())),wiggle,bedFilename,identityThreshold));
  outputBlob.setStats(new MapRatioRecordSum());
  final SAMFileWriterFactory writerFactory=new SAMFileWriterFactory();
  final SamReaderFactory factory=SamReaderFactory.makeDefault().enable(SamReaderFactory.Option.INCLUDE_SOURCE_IN_RECORDS,SamReaderFactory.Option.VALIDATE_CRC_CHECKSUMS).validationStringency(ValidationStringency.LENIENT);
  final Map<BlockType,SAMFileWriter> fpWriters=new EnumMap<>(BlockType.class);
  try (final PrintWriter jsonWriter=new PrintWriter(outPrefix + ""String_Node_Str"",""String_Node_Str"");final SAMFileWriter tumFPWriter=writerFactory.makeBAMWriter(factory.getFileHeader(new File(bamFilenames.get(0))),false,new File(outPrefix + ""String_Node_Str""));final SAMFileWriter fpWriter=writerFactory.makeBAMWriter(factory.getFileHeader(new File(bamFilenames.get(0))),false,new File(outPrefix + ""String_Node_Str""))){
    for (    final BlockType blockType : BlockType.values()) {
      if (blockType != BlockType.UNKNOWN) {
        fpWriters.put(blockType,writerFactory.makeBAMWriter(factory.getFileHeader(new File(bamFilenames.get(0))),false,new File(outPrefix + ""String_Node_Str"" + blockType.getShortName()+ ""String_Node_Str"")));
      }
    }
    ReadMap readMap=readMapFile != null ? new ReadMap(readMapFile) : null;
    final BedFile intersector=(bedFilename != null && new File(bedFilename).isFile()) ? new BedFile(bedFilename) : null;
    int numReads=0;
    for (    String filename : bamFilenames) {
      log.info(""String_Node_Str"" + filename);
      final SamReader reader=factory.open(new File(filename));
      for (      SAMRecord rec : reader) {
        if (!useNonPrimary && (rec.getNotPrimaryAlignmentFlag() || rec.getSupplementaryAlignmentFlag())) {
          continue;
        }
        numReads++;
        if (numReads % 100000 == 0) {
          log.info(""String_Node_Str"" + numReads + ""String_Node_Str"");
        }
        String name=rec.getReadName();
        int pair_idx=rec.getReadPairedFlag() ? getPairIdx(rec.getFirstOfPairFlag()) : 0;
        log.trace(""String_Node_Str"" + name);
        final Collection<GenomeLocation> trueLoci=readMap != null ? readMap.getReadMapRecord(name).getUnclippedStarts(pair_idx) : new SimulatedRead(name).getLocs(pair_idx);
        if (!isContainedInBed(intersector,trueLoci,rec)) {
          continue;
        }
        boolean isTrueUnmapped;
        Set<EventTypesForStats> features=EnumSet.noneOf(EventTypesForStats.class);
        features.add(EventTypesForStats.All);
        isTrueUnmapped=true;
        if (!trueLoci.isEmpty()) {
          for (          GenomeLocation loc : trueLoci) {
            final BlockType feat=loc.feature;
            features.add(EventTypesForStats.valueOf(feat.getLongName()));
            isTrueUnmapped&=!feat.isMappable();
          }
        }
        if (isTrueUnmapped) {
          features.add(EventTypesForStats.True_Unmapped);
        }
 else {
          outputBlob.getStats().incStat(features,-1,StatsNamespace.T);
        }
        boolean unmapped=rec.getReadUnmappedFlag();
        int mappingQuality=unmapped ? MAPQ_UNMAPPED : rec.getMappingQuality();
        StatsNamespace validationStatus=StatsNamespace.TP;
        if (unmapped) {
          validationStatus=isTrueUnmapped ? StatsNamespace.TN : StatsNamespace.FN;
        }
 else {
          boolean closeAln=false;
          if (isTrueUnmapped) {
            if (getIdentity(rec) <= identityThreshold && mappingQuality > mapqCutoff) {
              tumFPWriter.addAlignment(rec);
            }
          }
 else {
            final GenomeLocation mappedLocation=new GenomeLocation(new ChrString(rec.getReferenceName()),rec.getUnclippedStart());
            for (            GenomeLocation loc : trueLoci) {
              closeAln|=loc.feature.isMappable() && loc.isClose(mappedLocation,wiggle);
            }
            if (!closeAln) {
              if (getIdentity(rec) <= identityThreshold && mappingQuality > mapqCutoff) {
                fpWriter.addAlignment(rec);
                validationStatus=StatsNamespace.FP;
                for (                final BlockType blockType : BlockType.values()) {
                  if (fpWriters.containsKey(blockType) && features.contains(EventTypesForStats.valueOf(blockType.getLongName()))) {
                    fpWriters.get(blockType).addAlignment(rec);
                  }
                }
              }
            }
          }
        }
        outputBlob.getStats().incStat(features,mappingQuality,validationStatus);
      }
      reader.close();
    }
    log.info(""String_Node_Str"" + numReads);
    log.info(""String_Node_Str"");
    log.info(outputBlob.getStats());
    ObjectMapper mapper=new ObjectMapper();
    mapper.configure(JsonGenerator.Feature.AUTO_CLOSE_TARGET,false);
    String jsonStr=""String_Node_Str"";
    try {
      jsonStr=mapper.writeValueAsString(outputBlob);
    }
 catch (    JsonProcessingException e) {
      e.printStackTrace();
      System.exit(1);
    }
    jsonWriter.print(jsonStr);
    if (htmlFile != null) {
      FileUtils.writeStringToFile(new File(outPrefix + ""String_Node_Str""),JSONInserter.insertJSON(FileUtils.readFileToString(htmlFile),jsonStr));
    }
    for (    final BlockType blockType : BlockType.values()) {
      if (blockType != BlockType.UNKNOWN) {
        fpWriters.get(blockType).close();
      }
    }
    fpWriters.values().stream().forEach(SAMFileWriter::close);
  }
 catch (  IOException e) {
    e.printStackTrace();
    System.exit(1);
  }
  log.info(""String_Node_Str"");
}",0.998529892192094
80615,"/** 
 * actual implementation for canonicalization
 * @param variant
 * @param end
 * @return
 */
private List<Variant> canonicalizeVariant(Variant variant,boolean end){
  List<Variant> variantList=new ArrayList<>();
  boolean noSplit=false;
  if (variant.getType() == VariantOverallType.SNP) {
    noSplit=true;
  }
  if (variant.getCompositions() == null && variant.getGoodPaternal() == 0 && variant.getGoodMaternal() == 0) {
    noSplit=true;
  }
  if (variant.getGoodPaternal() > 0 && !canonicalizableFlexSeqTypes.contains(variant.getAlt(variant.getGoodPaternal()).getSeqType())) {
    noSplit=true;
  }
  if (variant.getGoodMaternal() > 0 && !canonicalizableFlexSeqTypes.contains(variant.getAlt(variant.getGoodMaternal()).getSeqType())) {
    noSplit=true;
  }
  if (variant.getGoodPaternal() > 0 && variant.getAlt(variant.getGoodPaternal()).length() == 0 && variant.getReference().length == 0) {
    noSplit=true;
  }
  if (variant.getGoodMaternal() > 0 && variant.getAlt(variant.getGoodMaternal()).length() == 0 && variant.getReference().length == 0) {
    noSplit=true;
  }
  if (noSplit) {
    variantList.add(variant);
    return variantList;
  }
  if (variant.getCompositions() != null) {
    for (    Variant c : variant.getCompositions()) {
      variantList.addAll(canonicalizeVariant(new Variant(c),end));
    }
    return variantList;
  }
  Variant.Builder template=new Variant.Builder().chr(variant.getChr()).isPhased(true).varId(variant.getVariantId()).filter(VCFparser.DEFAULT_FILTER).refDeleted(""String_Node_Str"");
  if (variant.getType(variant.getGoodMaternal()) == VariantType.Translocation_Duplication || variant.getType(variant.getGoodMaternal()) == VariantType.Interspersed_Duplication || variant.getType(variant.getGoodPaternal()) == VariantType.Translocation_Duplication || variant.getType(variant.getGoodPaternal()) == VariantType.Interspersed_Duplication) {
    for (int parentIndex=0; parentIndex < 2; parentIndex++) {
      int allele=variant.getAllele(parentIndex);
      if (variant.getType(allele) == VariantType.Reference)       continue;
      byte[] phase=new byte[2];
      phase[parentIndex]=1;
      if (variant.getType(allele) == VariantType.Translocation_Duplication || variant.getType(allele) == VariantType.Interspersed_Duplication) {
        boolean isInversed=variant.isInversed();
        Alt alt1=new Alt();
        alt1.setBreakend(new Alt.Breakend(variant.getReference().clone(),variant.getChr2(allele),isInversed ? variant.getEnd2(allele) : variant.getPos2(allele),true,!isInversed));
        variantList.add(template.pos(variant.getPos() - 1).referenceAlleleLength(0).ref(new byte[0]).alts(new Alt[]{alt1}).phase(phase).build());
        Alt alt2=new Alt();
        alt2.setBreakend(new Alt.Breakend(ambiguousBase,variant.getChr2(parentIndex),isInversed ? variant.getPos2(parentIndex) : variant.getEnd2(parentIndex),false,isInversed));
        variantList.add(template.pos(variant.getPos()).referenceAlleleLength(0).ref(new byte[0]).alts(new Alt[]{alt2}).phase(phase).build());
      }
      variant.setAllele(parentIndex,(byte)0);
    }
  }
 else   if (variant.getType(variant.getGoodMaternal()) == VariantType.Translocation_Deletion || variant.getType(variant.getGoodPaternal()) == VariantType.Translocation_Deletion) {
    for (int parentIndex=0; parentIndex < 2; parentIndex++) {
      int allele=variant.getAllele(parentIndex);
      if (variant.getType(allele) == VariantType.Reference)       continue;
      byte[] phase=new byte[2];
      phase[parentIndex]=1;
      if (variant.getType(allele) == VariantType.Translocation_Deletion) {
        Alt alt1=new Alt();
        alt1.setBreakend(new Alt.Breakend(variant.getReference().clone(),variant.getChr(),variant.getPos() + variant.getReferenceAlleleLength(),true,true));
        variantList.add(template.pos(variant.getPos() - 1).referenceAlleleLength(0).ref(new byte[0]).alts(new Alt[]{alt1}).phase(phase).build());
      }
      variant.setAllele(parentIndex,(byte)0);
    }
  }
 else   if (variant.getType(variant.getGoodPaternal()) != VariantType.Reference && variant.getType(variant.getGoodMaternal()) != VariantType.Reference) {
    int[] alleleNumber={variant.getAllele(0),variant.getAllele(1)};
    byte[][] alternativeAlleleSequence={variant.getAlt(alleleNumber[0]).getSequence(),variant.getAlt(alleleNumber[1]).getSequence()};
    byte[] referenceAlleleSequence=variant.getReference();
    int currentPosition=variant.getPos();
    int minMatchLength=variant.getMinMatchLength();
    if (minMatchLength > 0) {
      referenceAlleleSequence=Arrays.copyOfRange(referenceAlleleSequence,minMatchLength,referenceAlleleSequence.length);
      for (int i=0; i < 2; i++) {
        alternativeAlleleSequence[i]=Arrays.copyOfRange(alternativeAlleleSequence[i],minMatchLength,alternativeAlleleSequence[i].length);
      }
      currentPosition+=minMatchLength;
    }
    int[] alleleLengthDifference={alternativeAlleleSequence[0].length - referenceAlleleSequence.length,alternativeAlleleSequence[1].length - referenceAlleleSequence.length};
    canonicalizeToIndels(variantList,alleleLengthDifference,referenceAlleleSequence,alternativeAlleleSequence,variant,currentPosition,end);
    for (int relativePosition=0; relativePosition < referenceAlleleSequence.length; relativePosition++, currentPosition++) {
      int[] alleleSpecificRelativePosition=new int[2];
      if (end) {
        for (int j=0; j < 2; j++) {
          if (relativePosition < referenceAlleleSequence.length + alleleLengthDifference[j]) {
            alleleSpecificRelativePosition[j]=relativePosition;
          }
 else {
            alleleSpecificRelativePosition[j]=-1;
          }
        }
      }
 else {
        for (int j=0; j < 2; j++) {
          alleleSpecificRelativePosition[j]=relativePosition + alleleLengthDifference[j];
        }
      }
      if (alleleSpecificRelativePosition[0] < 0 && alleleSpecificRelativePosition[1] < 0) {
      }
 else       if (alleleSpecificRelativePosition[0] >= 0 && alleleSpecificRelativePosition[1] < 0 && alternativeAlleleSequence[0][alleleSpecificRelativePosition[0]] != referenceAlleleSequence[relativePosition]) {
        byte[] phase={1,1};
        Alt alt=new Alt();
        alt.setSeq(new FlexSeq(alternativeAlleleSequence[0][alleleSpecificRelativePosition[0]]));
        variantList.add(template.pos(currentPosition).referenceAlleleLength(1).ref(new byte[]{referenceAlleleSequence[relativePosition]}).alts(new Alt[]{alt}).phase(phase).build());
      }
 else       if (alleleSpecificRelativePosition[0] < 0 && alleleSpecificRelativePosition[1] >= 0 && alternativeAlleleSequence[1][alleleSpecificRelativePosition[1]] != referenceAlleleSequence[relativePosition]) {
        byte[] phase={1,1};
        Alt alt=new Alt();
        alt.setSeq(new FlexSeq(alternativeAlleleSequence[1][alleleSpecificRelativePosition[1]]));
        variantList.add(template.pos(currentPosition).referenceAlleleLength(1).ref(new byte[]{referenceAlleleSequence[relativePosition]}).alts(new Alt[]{alt}).phase(phase).build());
      }
 else       if (alleleSpecificRelativePosition[0] >= 0 && alleleSpecificRelativePosition[1] < 0 && alternativeAlleleSequence[0][alleleSpecificRelativePosition[0]] == referenceAlleleSequence[relativePosition]) {
      }
 else       if (alleleSpecificRelativePosition[0] < 0 && alleleSpecificRelativePosition[1] >= 0 && alternativeAlleleSequence[1][alleleSpecificRelativePosition[1]] == referenceAlleleSequence[relativePosition]) {
      }
 else       if (alternativeAlleleSequence[0][alleleSpecificRelativePosition[0]] == referenceAlleleSequence[relativePosition] && alternativeAlleleSequence[1][alleleSpecificRelativePosition[1]] == referenceAlleleSequence[relativePosition]) {
      }
 else       if (alternativeAlleleSequence[0][alleleSpecificRelativePosition[0]] == alternativeAlleleSequence[1][alleleSpecificRelativePosition[1]]) {
        byte[] phase={1,1};
        Alt alt=new Alt();
        alt.setSeq(new FlexSeq(alternativeAlleleSequence[0][alleleSpecificRelativePosition[0]]));
        variantList.add(template.pos(currentPosition).referenceAlleleLength(1).ref(new byte[]{referenceAlleleSequence[relativePosition]}).alts(new Alt[]{alt}).phase(phase).build());
      }
 else       if (alternativeAlleleSequence[0][alleleSpecificRelativePosition[0]] != referenceAlleleSequence[relativePosition] && alternativeAlleleSequence[1][alleleSpecificRelativePosition[1]] != referenceAlleleSequence[relativePosition]) {
        byte[] phase={1,2};
        Alt[] alts=new Alt[2];
        alts[0].setSeq(new FlexSeq(alternativeAlleleSequence[0][alleleSpecificRelativePosition[0]]));
        alts[1].setSeq(new FlexSeq(alternativeAlleleSequence[1][alleleSpecificRelativePosition[1]]));
        variantList.add(template.pos(currentPosition).referenceAlleleLength(1).ref(new byte[]{referenceAlleleSequence[relativePosition]}).alts(alts).phase(phase).build());
      }
 else {
        for (int a=0; a < 2; a++) {
          if (alternativeAlleleSequence[a][alleleSpecificRelativePosition[a]] != referenceAlleleSequence[relativePosition]) {
            byte[] phase={0,0};
            phase[a]=1;
            Alt alt=new Alt();
            alt.setSeq(new FlexSeq(alternativeAlleleSequence[a][alleleSpecificRelativePosition[a]]));
            variantList.add(template.pos(currentPosition).referenceAlleleLength(1).ref(new byte[]{referenceAlleleSequence[relativePosition]}).alts(new Alt[]{alt}).phase(phase).build());
          }
        }
      }
    }
    variant.setAllele(0,(byte)0);
    variant.setAllele(1,(byte)0);
  }
 else {
    for (int alleleIndex=0; alleleIndex < 2; alleleIndex++) {
      int allele=variant.getAllele(alleleIndex);
      if (variant.getType(allele) == VariantType.Complex || variant.getType(allele) == VariantType.MNP || variant.getType(allele) == VariantType.SNP) {
        byte[] alternativeAlleleSequence=variant.getAlt(allele).getSequence();
        byte[] referenceSequence=variant.getReference();
        int currentPosition=variant.getPos();
        int alleleLengthDifference=alternativeAlleleSequence.length - referenceSequence.length;
        if (alleleLengthDifference > 0) {
          byte[] phase={0,0};
          phase[alleleIndex]=1;
          if (end) {
            Alt alt=new Alt();
            alt.setSeq(new FlexSeq(Arrays.copyOfRange(alternativeAlleleSequence,0,alleleLengthDifference)));
            variantList.add(template.pos(currentPosition + referenceSequence.length).referenceAlleleLength(0).ref(new byte[0]).alts(new Alt[]{alt}).phase(phase).build());
          }
 else {
            Alt alt=new Alt();
            alt.setSeq(new FlexSeq(Arrays.copyOfRange(alternativeAlleleSequence,0,alleleLengthDifference)));
            variantList.add(template.pos(currentPosition).referenceAlleleLength(0).ref(new byte[0]).alts(new Alt[]{alt}).phase(phase).build());
          }
        }
 else         if (alleleLengthDifference < 0) {
          byte[] phase={0,0};
          phase[alleleIndex]=1;
          if (end) {
            Alt alt=new Alt();
            alt.setSeq(new FlexSeq());
            variantList.add(template.pos(currentPosition + alternativeAlleleSequence.length).referenceAlleleLength(-alleleLengthDifference).ref(Arrays.copyOfRange(referenceSequence,alternativeAlleleSequence.length,alternativeAlleleSequence.length - alleleLengthDifference)).alts(new Alt[]{alt}).phase(phase).build());
          }
 else {
            Alt alt=new Alt();
            alt.setSeq(new FlexSeq());
            variantList.add(template.pos(currentPosition).referenceAlleleLength(-alleleLengthDifference).ref(Arrays.copyOfRange(referenceSequence,0,-alleleLengthDifference)).alts(new Alt[]{alt}).phase(phase).build());
          }
        }
        for (int i=0; i < referenceSequence.length; i++) {
          int idx;
          if (end) {
            if (i < referenceSequence.length + alleleLengthDifference) {
              idx=i;
            }
 else {
              idx=-1;
            }
          }
 else {
            idx=i + alleleLengthDifference;
          }
          if (idx >= 0 && alternativeAlleleSequence[idx] != referenceSequence[i]) {
            byte[] phase={0,0};
            phase[alleleIndex]=1;
            Alt alt=new Alt();
            alt.setSeq(new FlexSeq(alternativeAlleleSequence[idx]));
            variantList.add(template.pos(currentPosition).referenceAlleleLength(1).ref(new byte[]{referenceSequence[i]}).alts(new Alt[]{alt}).phase(phase).build());
          }
          currentPosition++;
        }
        variant.setAllele(alleleIndex,(byte)0);
      }
    }
  }
  if (!variant.isRef()) {
    variantList.add(variant);
  }
  return variantList;
}","/** 
 * actual implementation for canonicalization
 * @param variant
 * @param end
 * @return
 */
private List<Variant> canonicalizeVariant(Variant variant,boolean end){
  List<Variant> variantList=new ArrayList<>();
  boolean noSplit=false;
  if (variant.getType() == VariantOverallType.SNP) {
    noSplit=true;
  }
  if (variant.getCompositions() == null && variant.getGoodPaternal() == 0 && variant.getGoodMaternal() == 0) {
    noSplit=true;
  }
  if (variant.getGoodPaternal() > 0 && !canonicalizableFlexSeqTypes.contains(variant.getAlt(variant.getGoodPaternal()).getSeqType())) {
    noSplit=true;
  }
  if (variant.getGoodMaternal() > 0 && !canonicalizableFlexSeqTypes.contains(variant.getAlt(variant.getGoodMaternal()).getSeqType())) {
    noSplit=true;
  }
  if (variant.getGoodPaternal() > 0 && variant.getAlt(variant.getGoodPaternal()).length() == 0 && variant.getReference().length == 0) {
    noSplit=true;
  }
  if (variant.getGoodMaternal() > 0 && variant.getAlt(variant.getGoodMaternal()).length() == 0 && variant.getReference().length == 0) {
    noSplit=true;
  }
  if (noSplit) {
    variantList.add(variant);
    return variantList;
  }
  if (variant.getCompositions() != null) {
    for (    Variant c : variant.getCompositions()) {
      variantList.addAll(canonicalizeVariant(new Variant(c),end));
    }
    return variantList;
  }
  Variant.Builder template=new Variant.Builder().chr(variant.getChr()).isPhased(true).varId(variant.getVariantId()).filter(VCFparser.DEFAULT_FILTER).refDeleted(""String_Node_Str"");
  if (variant.getType(variant.getGoodMaternal()) == VariantType.Translocation_Duplication || variant.getType(variant.getGoodMaternal()) == VariantType.Interspersed_Duplication || variant.getType(variant.getGoodPaternal()) == VariantType.Translocation_Duplication || variant.getType(variant.getGoodPaternal()) == VariantType.Interspersed_Duplication) {
    for (int parentIndex=0; parentIndex < 2; parentIndex++) {
      int allele=variant.getAllele(parentIndex);
      if (variant.getType(allele) == VariantType.Reference)       continue;
      byte[] phase=new byte[2];
      phase[parentIndex]=1;
      if (variant.getType(allele) == VariantType.Translocation_Duplication || variant.getType(allele) == VariantType.Interspersed_Duplication) {
        boolean isInversed=variant.isInversed();
        Alt alt1=new Alt();
        alt1.setBreakend(new Alt.Breakend(variant.getReference().clone(),variant.getChr2(allele),isInversed ? variant.getEnd2(allele) : variant.getPos2(allele),true,!isInversed));
        variantList.add(template.pos(variant.getPos() - 1).referenceAlleleLength(0).ref(new byte[0]).alts(new Alt[]{alt1}).phase(phase).build());
        Alt alt2=new Alt();
        alt2.setBreakend(new Alt.Breakend(ambiguousBase,variant.getChr2(parentIndex),isInversed ? variant.getPos2(parentIndex) : variant.getEnd2(parentIndex),false,isInversed));
        variantList.add(template.pos(variant.getPos()).referenceAlleleLength(0).ref(new byte[0]).alts(new Alt[]{alt2}).phase(phase).build());
      }
      variant.setAllele(parentIndex,(byte)0);
    }
  }
 else   if (variant.getType(variant.getGoodMaternal()) == VariantType.Translocation_Deletion || variant.getType(variant.getGoodPaternal()) == VariantType.Translocation_Deletion) {
    for (int parentIndex=0; parentIndex < 2; parentIndex++) {
      int allele=variant.getAllele(parentIndex);
      if (variant.getType(allele) == VariantType.Reference)       continue;
      byte[] phase=new byte[2];
      phase[parentIndex]=1;
      if (variant.getType(allele) == VariantType.Translocation_Deletion) {
        Alt alt1=new Alt();
        alt1.setBreakend(new Alt.Breakend(variant.getReference().clone(),variant.getChr(),variant.getPos() + variant.getReferenceAlleleLength(),true,true));
        variantList.add(template.pos(variant.getPos() - 1).referenceAlleleLength(0).ref(new byte[0]).alts(new Alt[]{alt1}).phase(phase).build());
      }
      variant.setAllele(parentIndex,(byte)0);
    }
  }
 else   if (variant.getType(variant.getGoodPaternal()) != VariantType.Reference && variant.getType(variant.getGoodMaternal()) != VariantType.Reference) {
    int[] alleleNumber={variant.getAllele(0),variant.getAllele(1)};
    byte[][] alternativeAlleleSequence={variant.getAlt(alleleNumber[0]).getSequence(),variant.getAlt(alleleNumber[1]).getSequence()};
    byte[] referenceAlleleSequence=variant.getReference();
    int currentPosition=variant.getPos();
    int minMatchLength=variant.getMinMatchLength();
    if (minMatchLength > 0) {
      referenceAlleleSequence=Arrays.copyOfRange(referenceAlleleSequence,minMatchLength,referenceAlleleSequence.length);
      for (int i=0; i < 2; i++) {
        alternativeAlleleSequence[i]=Arrays.copyOfRange(alternativeAlleleSequence[i],minMatchLength,alternativeAlleleSequence[i].length);
      }
      currentPosition+=minMatchLength;
    }
    int[] alleleLengthDifference={alternativeAlleleSequence[0].length - referenceAlleleSequence.length,alternativeAlleleSequence[1].length - referenceAlleleSequence.length};
    canonicalizeToIndels(variantList,alleleLengthDifference,referenceAlleleSequence,alternativeAlleleSequence,variant,currentPosition,end);
    for (int relativePosition=0; relativePosition < referenceAlleleSequence.length; relativePosition++, currentPosition++) {
      int[] alleleSpecificRelativePosition=new int[2];
      if (end) {
        for (int j=0; j < 2; j++) {
          if (relativePosition < referenceAlleleSequence.length + alleleLengthDifference[j]) {
            alleleSpecificRelativePosition[j]=relativePosition;
          }
 else {
            alleleSpecificRelativePosition[j]=-1;
          }
        }
      }
 else {
        for (int j=0; j < 2; j++) {
          alleleSpecificRelativePosition[j]=relativePosition + alleleLengthDifference[j];
        }
      }
      if (alleleSpecificRelativePosition[0] < 0 && alleleSpecificRelativePosition[1] < 0) {
      }
 else       if (alleleSpecificRelativePosition[0] >= 0 && alleleSpecificRelativePosition[1] < 0 && alternativeAlleleSequence[0][alleleSpecificRelativePosition[0]] != referenceAlleleSequence[relativePosition]) {
        byte[] phase={1,1};
        Alt alt=new Alt();
        alt.setSeq(new FlexSeq(alternativeAlleleSequence[0][alleleSpecificRelativePosition[0]]));
        variantList.add(template.pos(currentPosition).referenceAlleleLength(1).ref(new byte[]{referenceAlleleSequence[relativePosition]}).alts(new Alt[]{alt}).phase(phase).build());
      }
 else       if (alleleSpecificRelativePosition[0] < 0 && alleleSpecificRelativePosition[1] >= 0 && alternativeAlleleSequence[1][alleleSpecificRelativePosition[1]] != referenceAlleleSequence[relativePosition]) {
        byte[] phase={1,1};
        Alt alt=new Alt();
        alt.setSeq(new FlexSeq(alternativeAlleleSequence[1][alleleSpecificRelativePosition[1]]));
        variantList.add(template.pos(currentPosition).referenceAlleleLength(1).ref(new byte[]{referenceAlleleSequence[relativePosition]}).alts(new Alt[]{alt}).phase(phase).build());
      }
 else       if (alleleSpecificRelativePosition[0] >= 0 && alleleSpecificRelativePosition[1] < 0 && alternativeAlleleSequence[0][alleleSpecificRelativePosition[0]] == referenceAlleleSequence[relativePosition]) {
      }
 else       if (alleleSpecificRelativePosition[0] < 0 && alleleSpecificRelativePosition[1] >= 0 && alternativeAlleleSequence[1][alleleSpecificRelativePosition[1]] == referenceAlleleSequence[relativePosition]) {
      }
 else       if (alternativeAlleleSequence[0][alleleSpecificRelativePosition[0]] == referenceAlleleSequence[relativePosition] && alternativeAlleleSequence[1][alleleSpecificRelativePosition[1]] == referenceAlleleSequence[relativePosition]) {
      }
 else       if (alternativeAlleleSequence[0][alleleSpecificRelativePosition[0]] == alternativeAlleleSequence[1][alleleSpecificRelativePosition[1]]) {
        byte[] phase={1,1};
        Alt alt=new Alt();
        alt.setSeq(new FlexSeq(alternativeAlleleSequence[0][alleleSpecificRelativePosition[0]]));
        variantList.add(template.pos(currentPosition).referenceAlleleLength(1).ref(new byte[]{referenceAlleleSequence[relativePosition]}).alts(new Alt[]{alt}).phase(phase).build());
      }
 else       if (alternativeAlleleSequence[0][alleleSpecificRelativePosition[0]] != referenceAlleleSequence[relativePosition] && alternativeAlleleSequence[1][alleleSpecificRelativePosition[1]] != referenceAlleleSequence[relativePosition]) {
        byte[] phase={1,2};
        Alt[] alts=new Alt[2];
        alts[0]=new Alt();
        alts[1]=new Alt();
        alts[0].setSeq(new FlexSeq(alternativeAlleleSequence[0][alleleSpecificRelativePosition[0]]));
        alts[1].setSeq(new FlexSeq(alternativeAlleleSequence[1][alleleSpecificRelativePosition[1]]));
        variantList.add(template.pos(currentPosition).referenceAlleleLength(1).ref(new byte[]{referenceAlleleSequence[relativePosition]}).alts(alts).phase(phase).build());
      }
 else {
        for (int a=0; a < 2; a++) {
          if (alternativeAlleleSequence[a][alleleSpecificRelativePosition[a]] != referenceAlleleSequence[relativePosition]) {
            byte[] phase={0,0};
            phase[a]=1;
            Alt alt=new Alt();
            alt.setSeq(new FlexSeq(alternativeAlleleSequence[a][alleleSpecificRelativePosition[a]]));
            variantList.add(template.pos(currentPosition).referenceAlleleLength(1).ref(new byte[]{referenceAlleleSequence[relativePosition]}).alts(new Alt[]{alt}).phase(phase).build());
          }
        }
      }
    }
    variant.setAllele(0,(byte)0);
    variant.setAllele(1,(byte)0);
  }
 else {
    for (int alleleIndex=0; alleleIndex < 2; alleleIndex++) {
      int allele=variant.getAllele(alleleIndex);
      if (variant.getType(allele) == VariantType.Complex || variant.getType(allele) == VariantType.MNP || variant.getType(allele) == VariantType.SNP) {
        byte[] alternativeAlleleSequence=variant.getAlt(allele).getSequence();
        byte[] referenceSequence=variant.getReference();
        int currentPosition=variant.getPos();
        int alleleLengthDifference=alternativeAlleleSequence.length - referenceSequence.length;
        if (alleleLengthDifference > 0) {
          byte[] phase={0,0};
          phase[alleleIndex]=1;
          if (end) {
            Alt alt=new Alt();
            alt.setSeq(new FlexSeq(Arrays.copyOfRange(alternativeAlleleSequence,0,alleleLengthDifference)));
            variantList.add(template.pos(currentPosition + referenceSequence.length).referenceAlleleLength(0).ref(new byte[0]).alts(new Alt[]{alt}).phase(phase).build());
          }
 else {
            Alt alt=new Alt();
            alt.setSeq(new FlexSeq(Arrays.copyOfRange(alternativeAlleleSequence,0,alleleLengthDifference)));
            variantList.add(template.pos(currentPosition).referenceAlleleLength(0).ref(new byte[0]).alts(new Alt[]{alt}).phase(phase).build());
          }
        }
 else         if (alleleLengthDifference < 0) {
          byte[] phase={0,0};
          phase[alleleIndex]=1;
          if (end) {
            Alt alt=new Alt();
            alt.setSeq(new FlexSeq());
            variantList.add(template.pos(currentPosition + alternativeAlleleSequence.length).referenceAlleleLength(-alleleLengthDifference).ref(Arrays.copyOfRange(referenceSequence,alternativeAlleleSequence.length,alternativeAlleleSequence.length - alleleLengthDifference)).alts(new Alt[]{alt}).phase(phase).build());
          }
 else {
            Alt alt=new Alt();
            alt.setSeq(new FlexSeq());
            variantList.add(template.pos(currentPosition).referenceAlleleLength(-alleleLengthDifference).ref(Arrays.copyOfRange(referenceSequence,0,-alleleLengthDifference)).alts(new Alt[]{alt}).phase(phase).build());
          }
        }
        for (int i=0; i < referenceSequence.length; i++) {
          int idx;
          if (end) {
            if (i < referenceSequence.length + alleleLengthDifference) {
              idx=i;
            }
 else {
              idx=-1;
            }
          }
 else {
            idx=i + alleleLengthDifference;
          }
          if (idx >= 0 && alternativeAlleleSequence[idx] != referenceSequence[i]) {
            byte[] phase={0,0};
            phase[alleleIndex]=1;
            Alt alt=new Alt();
            alt.setSeq(new FlexSeq(alternativeAlleleSequence[idx]));
            variantList.add(template.pos(currentPosition).referenceAlleleLength(1).ref(new byte[]{referenceSequence[i]}).alts(new Alt[]{alt}).phase(phase).build());
          }
          currentPosition++;
        }
        variant.setAllele(alleleIndex,(byte)0);
      }
    }
  }
  if (!variant.isRef()) {
    variantList.add(variant);
  }
  return variantList;
}",0.997871669556992
80616,"/** 
 * Only compares one allele at a time - don't match variants in the bitset - if match set the bitset
 * @param variant       variant we want to compare
 * @param genotype      allele of the variant to compare
 * @param validated BitSet that records the true variants that have already been validated
 * @return The maximum length of all true variants
 */
public int compareVariant(Variant variant,int genotype,BitSet validated){
  VariantType type=variant.getType(genotype);
  ChrString chr=variant.getChr();
  SimpleInterval1D intervalForCompare=variant.getVariantInterval(genotype,ignoreInsertionLength);
  int maxTrueVarianLength=0;
  if (type == VariantType.SNP) {
    Iterable<ValueInterval1D<Variant>> overlaps=trueVariantIntervalTree.getOverlaps(chr,intervalForCompare);
    if (overlaps == null) {
      return maxTrueVarianLength;
    }
    byte alternativeAlleleFirstBase=variant.getAlt(genotype).getSequence()[0];
    int numberOfSnpMatches=0;
    for (    ValueInterval1D<Variant> trueVariantInterval : overlaps) {
      Variant trueVariant=trueVariantInterval.getContent();
      boolean hasSnp=false;
      int splitVariantIndex=trueVariant.splitVariantIndex;
      int wholeVariantIndex=trueVariant.wholeVariantIndex;
      overlapComplex=trueVariant.originalType == VariantOverallType.Complex;
      if (validated.get(splitVariantIndex)) {
        continue;
      }
      for (int parent=0; parent < 2; parent++) {
        int allele=trueVariant.getAllele(parent);
        if (trueVariant.isHom() || allele > 0) {
          if (trueVariant.getType(allele) == VariantType.SNP && variant.getPos() == trueVariant.getPos()) {
            if (alternativeAlleleFirstBase == trueVariant.getAlt(allele).getSequence()[0]) {
              if (trueVariant.isHom())               homozygousMatches.add(new DualIdx(splitVariantIndex,wholeVariantIndex));
 else               heterozygousMatches.get(parent).add(new DualIdx(splitVariantIndex,wholeVariantIndex));
            }
            hasSnp=true;
          }
        }
        if (trueVariant.isHom())         break;
      }
      if (hasSnp) {
        numberOfSnpMatches++;
        maxTrueVarianLength=1;
      }
    }
    if (numberOfSnpMatches > 1) {
      log.info(""String_Node_Str"" + numberOfSnpMatches);
    }
  }
 else {
    SimpleInterval1D intervalForCompareWithWiggle=new SimpleInterval1D(intervalForCompare.left - wiggle,intervalForCompare.right + wiggle);
    Iterable<ValueInterval1D<Variant>> overlaps=trueVariantIntervalTree.getOverlaps(chr,intervalForCompareWithWiggle);
    if (overlaps == null) {
      return maxTrueVarianLength;
    }
    for (    ValueInterval1D<Variant> trueVariantInterval : overlaps) {
      Variant trueVariant=trueVariantInterval.getContent();
      int splitVariantIndex=trueVariant.splitVariantIndex;
      int wholeVariantIndex=trueVariant.wholeVariantIndex;
      overlapComplex=trueVariant.originalType == VariantOverallType.Complex;
      if (validated.get(splitVariantIndex)) {
        continue;
      }
      for (int parent=0; parent < 2; parent++) {
        int allele=trueVariant.getAllele(parent);
        if (allele == 0 || type != trueVariant.getType(allele)) {
          continue;
        }
        Alt.Breakend currentBreakend=variant.getAlt(allele).getBreakend();
        Alt.Breakend trueBreakend=trueVariant.getAlt(allele).getBreakend();
        boolean overlap=trueVariant.getVariantInterval(allele,ignoreInsertionLength).intersects(intervalForCompare,overlapRatio,wiggle);
        boolean breakendMatch=trueVariant.getType(allele) == VariantType.Breakend && Alt.Breakend.looseEquals(currentBreakend,trueBreakend,overlapRatio,wiggle);
        boolean matched=trueVariant.getType(allele) == VariantType.Breakend ? breakendMatch : overlap;
        if (matched) {
          if (trueVariant.isHom()) {
            homozygousMatches.add(new DualIdx(splitVariantIndex,wholeVariantIndex));
          }
 else {
            heterozygousMatches.get(parent).add(new DualIdx(splitVariantIndex,wholeVariantIndex));
          }
          maxTrueVarianLength=Math.max(trueVariant.maxLen(allele),maxTrueVarianLength);
        }
        if (trueVariant.isHom())         break;
      }
    }
  }
  return maxTrueVarianLength;
}","/** 
 * Only compares one allele at a time - don't match variants in the bitset - if match set the bitset
 * @param variant       variant we want to compare
 * @param genotype      allele of the variant to compare
 * @param validated BitSet that records the true variants that have already been validated
 * @return The maximum length of all true variants
 */
public int compareVariant(Variant variant,int genotype,BitSet validated){
  VariantType type=variant.getType(genotype);
  ChrString chr=variant.getChr();
  SimpleInterval1D intervalForCompare=variant.getVariantInterval(genotype,ignoreInsertionLength);
  int maxTrueVarianLength=0;
  if (type == VariantType.SNP) {
    Iterable<ValueInterval1D<Variant>> overlaps=trueVariantIntervalTree.getOverlaps(chr,intervalForCompare);
    if (overlaps == null) {
      return maxTrueVarianLength;
    }
    byte alternativeAlleleFirstBase=variant.getAlt(genotype).getSequence()[0];
    int numberOfSnpMatches=0;
    for (    ValueInterval1D<Variant> trueVariantInterval : overlaps) {
      Variant trueVariant=trueVariantInterval.getContent();
      boolean hasSnp=false;
      int splitVariantIndex=trueVariant.splitVariantIndex;
      int wholeVariantIndex=trueVariant.wholeVariantIndex;
      overlapComplex=trueVariant.originalType == VariantOverallType.Complex;
      if (validated.get(splitVariantIndex)) {
        continue;
      }
      for (int parent=0; parent < 2; parent++) {
        int allele=trueVariant.getAllele(parent);
        if (trueVariant.isHom() || allele > 0) {
          if (trueVariant.getType(allele) == VariantType.SNP && variant.getPos() == trueVariant.getPos()) {
            if (alternativeAlleleFirstBase == trueVariant.getAlt(allele).getSequence()[0]) {
              if (trueVariant.isHom())               homozygousMatches.add(new DualIdx(splitVariantIndex,wholeVariantIndex));
 else               heterozygousMatches.get(parent).add(new DualIdx(splitVariantIndex,wholeVariantIndex));
            }
            hasSnp=true;
          }
        }
        if (trueVariant.isHom())         break;
      }
      if (hasSnp) {
        numberOfSnpMatches++;
        maxTrueVarianLength=1;
      }
    }
    if (numberOfSnpMatches > 1) {
      log.info(""String_Node_Str"" + numberOfSnpMatches);
    }
  }
 else {
    SimpleInterval1D intervalForCompareWithWiggle=new SimpleInterval1D(intervalForCompare.left - wiggle,intervalForCompare.right + wiggle);
    Iterable<ValueInterval1D<Variant>> overlaps=trueVariantIntervalTree.getOverlaps(chr,intervalForCompareWithWiggle);
    if (overlaps == null) {
      return maxTrueVarianLength;
    }
    for (    ValueInterval1D<Variant> trueVariantInterval : overlaps) {
      Variant trueVariant=trueVariantInterval.getContent();
      int splitVariantIndex=trueVariant.splitVariantIndex;
      int wholeVariantIndex=trueVariant.wholeVariantIndex;
      overlapComplex=trueVariant.originalType == VariantOverallType.Complex;
      if (validated.get(splitVariantIndex)) {
        continue;
      }
      for (int parent=0; parent < 2; parent++) {
        int allele=trueVariant.getAllele(parent);
        if (allele == 0 || type != trueVariant.getType(allele) || variant.getAlt(allele) == null || trueVariant.getAlt(allele) == null) {
          continue;
        }
        Alt.Breakend currentBreakend=variant.getAlt(allele).getBreakend();
        Alt.Breakend trueBreakend=trueVariant.getAlt(allele).getBreakend();
        boolean overlap=trueVariant.getVariantInterval(allele,ignoreInsertionLength).intersects(intervalForCompare,overlapRatio,wiggle);
        boolean breakendMatch=trueVariant.getType(allele) == VariantType.Breakend && Alt.Breakend.looseEquals(currentBreakend,trueBreakend,overlapRatio,wiggle);
        boolean matched=trueVariant.getType(allele) == VariantType.Breakend ? breakendMatch : overlap;
        if (matched) {
          if (trueVariant.isHom()) {
            homozygousMatches.add(new DualIdx(splitVariantIndex,wholeVariantIndex));
          }
 else {
            heterozygousMatches.get(parent).add(new DualIdx(splitVariantIndex,wholeVariantIndex));
          }
          maxTrueVarianLength=Math.max(trueVariant.maxLen(allele),maxTrueVarianLength);
        }
        if (trueVariant.isHom())         break;
      }
    }
  }
  return maxTrueVarianLength;
}",0.9915671117357696
80617,"/** 
 * loosely compare two breakends all fields must be equal except for the exact positions which are allowed to have some shifts
 * @param a
 * @param b
 * @param overlapRatio
 * @param wiggle
 * @return
 */
public static boolean looseEquals(Breakend a,Breakend b,double overlapRatio,int wiggle){
  return a.getChr().equals(b.getChr()) && a.isForward() == b.isForward() && a.isLeft() == b.isLeft() && a.getInterval().intersects(b.getInterval(),overlapRatio,wiggle);
}","/** 
 * loosely compare two breakends all fields must be equal except for the exact positions which are allowed to have some shifts
 * @param a
 * @param b
 * @param overlapRatio
 * @param wiggle
 * @return
 */
public static boolean looseEquals(Breakend a,Breakend b,double overlapRatio,int wiggle){
  if (a == null || b == null) {
    return false;
  }
  return a.getChr().equals(b.getChr()) && a.isForward() == b.isForward() && a.isLeft() == b.isLeft() && a.getInterval().intersects(b.getInterval(),overlapRatio,wiggle);
}",0.9456740442655936
80618,"public SimulatedRead getNextRead() throws IOException {
  SimulatedRead read;
  final String nameLine=fastqBr.readLine();
  if (nameLine == null)   return null;
  ArtAlnRecord alnRecord;
  if ((alnRecord=artAlnR.getNextAln()) == null)   return null;
  final String nameFields[]=nameLine.trim().substring(1).split(""String_Node_Str"");
  read=new SimulatedRead();
  read.fragment=Integer.parseInt(nameFields[nameFields.length - 1]);
  read.setReadId(nameFields[nameFields.length - 2]);
  read.sequence=fastqBr.readLine().trim();
  if (forceFiveBaseEncoding) {
    read.sequence=nonACGTPattern.matcher(read.sequence).replaceAll(""String_Node_Str"");
  }
  fastqBr.readLine();
  read.quality=fastqBr.readLine().trim();
  if (read.fragment == 1) {
    read.locs1.add(new GenomeLocation(alnRecord.chromosome,alnRecord.location,alnRecord.direction));
    read.origLocs1.add(new GenomeLocation(alnRecord.chromosome,alnRecord.location,alnRecord.direction));
    read.alignedBases1=alnRecord.alignedBases;
  }
 else {
    read.locs2.add(new GenomeLocation(alnRecord.chromosome,alnRecord.location,alnRecord.direction));
    read.origLocs2.add(new GenomeLocation(alnRecord.chromosome,alnRecord.location,alnRecord.direction));
    read.alignedBases2=alnRecord.alignedBases;
  }
  return read;
}","public SimulatedRead getNextRead() throws IOException {
  SimulatedRead read;
  final String nameLine=fastqBr.readLine();
  if (nameLine == null || nameLine.trim().length() < 1)   return null;
  ArtAlnRecord alnRecord;
  if ((alnRecord=artAlnR.getNextAln()) == null)   return null;
  final String nameFields[]=nameLine.trim().substring(1).split(""String_Node_Str"");
  if (nameFields.length < 2)   return null;
  read=new SimulatedRead();
  read.fragment=Integer.parseInt(nameFields[nameFields.length - 1]);
  read.setReadId(nameFields[nameFields.length - 2]);
  read.sequence=fastqBr.readLine().trim();
  if (forceFiveBaseEncoding) {
    read.sequence=nonACGTPattern.matcher(read.sequence).replaceAll(""String_Node_Str"");
  }
  fastqBr.readLine();
  read.quality=fastqBr.readLine().trim();
  if (read.fragment == 1) {
    read.locs1.add(new GenomeLocation(alnRecord.chromosome,alnRecord.location,alnRecord.direction));
    read.origLocs1.add(new GenomeLocation(alnRecord.chromosome,alnRecord.location,alnRecord.direction));
    read.alignedBases1=alnRecord.alignedBases;
  }
 else {
    read.locs2.add(new GenomeLocation(alnRecord.chromosome,alnRecord.location,alnRecord.direction));
    read.origLocs2.add(new GenomeLocation(alnRecord.chromosome,alnRecord.location,alnRecord.direction));
    read.alignedBases2=alnRecord.alignedBases;
  }
  return read;
}",0.9711246200607904
80619,"private void readHeader() throws IOException {
  while ((currentLine=br.readLine()) != null) {
    if (!currentLine.startsWith(""String_Node_Str"") && !currentLine.startsWith(""String_Node_Str"")) {
      break;
    }
    if (currentLine.startsWith(""String_Node_Str"")) {
      final String[] fields=currentLine.split(""String_Node_Str"");
      chromosomeLengths.put(fields[1],Integer.valueOf(fields[2]));
    }
  }
}","private void readHeader() throws IOException {
  while ((currentLine=br.readLine()) != null) {
    if (!currentLine.startsWith(""String_Node_Str"") && !currentLine.startsWith(""String_Node_Str"")) {
      break;
    }
    if (currentLine.startsWith(""String_Node_Str"")) {
      final String[] fields=currentLine.split(""String_Node_Str"");
      chromosomeLengths.put(new ChrString(fields[1]),Integer.valueOf(fields[2]));
    }
  }
}",0.982078853046595
80620,"public ArtAlnRecord getNextAln() throws IOException {
  if (currentLine == null) {
    return null;
  }
  final String refAln=br.readLine().trim();
  final String readAln=br.readLine().trim();
  final String[] alnFields=splitterPattern.split(currentLine.trim().substring(1));
  int direction=(alnFields[3].equals(""String_Node_Str"")) ? 1 : 0;
  final int refLength=refAln.replace(""String_Node_Str"",""String_Node_Str"").length();
  ArtAlnRecord record=new ArtAlnRecord(new ChrString(alnFields[0]),Integer.parseInt(alnFields[2]) + 1,direction,alnFields[1],refLength);
  if (record.direction == 1) {
    final int chromosomeLength=chromosomeLengths.get(record.chromosome);
    record.location=chromosomeLength - (record.location - 1) + 1 - refLength;
  }
  currentLine=br.readLine();
  return record;
}","public ArtAlnRecord getNextAln() throws IOException {
  if (currentLine == null) {
    return null;
  }
  final String refAln=br.readLine().trim();
  final String readAln=br.readLine().trim();
  final String[] alnFields=splitterPattern.split(currentLine.trim().substring(1));
  int direction=(alnFields[3].equals(""String_Node_Str"")) ? 1 : 0;
  final int refLength=refAln.replace(""String_Node_Str"",""String_Node_Str"").length();
  ArtAlnRecord record=new ArtAlnRecord(new ChrString(alnFields[0]),Integer.parseInt(alnFields[2]) + 1,direction,alnFields[1],refLength);
  if (!chromosomeLengths.containsKey(record.chromosome)) {
    return null;
  }
  if (record.direction == 1) {
    final int chromosomeLength=chromosomeLengths.get(record.chromosome);
    record.location=chromosomeLength - (record.location - 1) + 1 - refLength;
  }
  currentLine=br.readLine();
  return record;
}",0.9521531100478468
80621,"public ReadMap(final File file) throws IOException {
  log.info(""String_Node_Str"" + file.getName());
  bufferedReader=new BufferedReader(new InputStreamReader(decompressStream(file.getName())));
  while (hasMoreInput()) {
    readLine();
    log.trace(""String_Node_Str"" + line);
    if (line == null || line.trim().isEmpty()) {
      break;
    }
    final ReadMapRecord record=parseLine();
    readMap.put(record.getReadName(),record);
  }
  log.info(""String_Node_Str"");
}","public ReadMap(final File file) throws IOException {
  log.info(""String_Node_Str"" + file);
  bufferedReader=new BufferedReader(new InputStreamReader(decompressStream(file)));
  while (hasMoreInput()) {
    readLine();
    log.trace(""String_Node_Str"" + line);
    if (line == null || line.trim().isEmpty()) {
      break;
    }
    final ReadMapRecord record=parseLine();
    readMap.put(record.getReadName(),record);
  }
  log.info(""String_Node_Str"");
}",0.978401727861771
80622,"/** 
 * takes a line from a VCF file, parse it, return a Variant object right now the meta-info lines (beginning with ##) are not tied with data line parsing. This will be corrected in the future (perhaps with help of HTSJDK).
 * @param line
 * @return
 */
public Variant processLine(String line) throws UnexpectedException {
  StringTokenizer toks=new StringTokenizer(line);
  if (line.startsWith(""String_Node_Str"")) {
    if (sampleId != null && line.startsWith(""String_Node_Str"")) {
      chromLineSeen=true;
      int index=0;
      while (toks.hasMoreTokens()) {
        index++;
        String tok=toks.nextToken();
        if (tok.equals(sampleId))         sampleIndex=index;
      }
    }
 else     if (sampleId == null) {
      sampleIndex=10;
    }
    return null;
  }
  if (sampleIndex < 0 && !chromLineSeen) {
    sampleIndex=10;
  }
 else   if (sampleIndex < 0) {
    sampleIndex=10;
    log.warn(""String_Node_Str"" + sampleId + ""String_Node_Str"");
  }
  int index=0, genotypeIndex=-1, copyNumberIndex=-1;
  int pos=-1;
  ChrString chr=null;
  String REF=""String_Node_Str"", FILTER=""String_Node_Str"", ALT=""String_Node_Str"", variantId=""String_Node_Str"";
  String phase=""String_Node_Str"", copyNumber=""String_Node_Str"", infoString=""String_Node_Str"", FORMAT;
  String[] sampleInfo;
  while (toks.hasMoreTokens()) {
    index++;
    if (index == 1) {
      chr=new ChrString(toks.nextToken());
    }
 else     if (index == 2)     pos=Integer.parseInt(toks.nextToken());
 else     if (index == 3)     variantId=toks.nextToken();
 else     if (index == 4)     REF=toks.nextToken();
 else     if (index == 5)     ALT=toks.nextToken();
 else     if (index == 7)     FILTER=toks.nextToken();
 else     if (index == 8)     infoString=toks.nextToken();
 else     if (index == 9) {
      FORMAT=toks.nextToken();
      genotypeIndex=getFormatKeyIndex(FORMAT,""String_Node_Str"");
      copyNumberIndex=getFormatKeyIndex(FORMAT,""String_Node_Str"");
    }
 else     if (index == sampleIndex) {
      sampleInfo=(toks.nextToken()).split(""String_Node_Str"");
      if (genotypeIndex >= 0) {
        phase=sampleInfo[genotypeIndex];
      }
      if (copyNumberIndex >= 0) {
        copyNumber=sampleInfo[copyNumberIndex];
      }
      break;
    }
 else {
      toks.nextToken();
    }
  }
  if (chr == null) {
    log.warn(""String_Node_Str"" + line);
    return null;
  }
  if (isPassFilterRequired && !(FILTER.contains(""String_Node_Str"") || FILTER.equals(DEFAULT_FILTER))) {
    return null;
  }
  byte[] genotypeArray=new byte[2];
  boolean isGenotypePhased=isPhased(phase,genotypeArray,chr);
  if (genotypeIndex >= 0 && genotypeArray[0] == 0 && genotypeArray[1] == 0) {
  }
  byte[] copyNumberArray=new byte[2];
  boolean isCopyNumberPhased;
  if (copyNumberIndex >= 0) {
    isCopyNumberPhased=isPhased(copyNumber,copyNumberArray,chr);
    if (isCopyNumberPhased != isGenotypePhased) {
      log.error(""String_Node_Str"");
      log.error(line);
      return null;
    }
  }
  REF=REF.toUpperCase();
  ALT=ALT.toUpperCase();
  String deletedReference=""String_Node_Str"";
  VCFInfo info=new VCFInfo(infoString);
  if (ALT.indexOf('<') != -1) {
    String[] alternativeAlleles=ALT.split(""String_Node_Str"");
    int[] svlen=info.getValue(""String_Node_Str"",int[].class);
    if (alternativeAlleles.length != svlen.length) {
      throw new IllegalArgumentException(""String_Node_Str"" + line);
    }
    for (int i=0; i < alternativeAlleles.length; i++) {
      if (!alternativeAlleles[i].startsWith(""String_Node_Str"")) {
        throw new IllegalArgumentException(""String_Node_Str"" + line);
      }
    }
  }
  Alt[] alts=string2Alt(ALT);
  if (alts[0].getSymbolicAllele() != null) {
    int[] end=info.getValue(""String_Node_Str"",int[].class);
    int[] svlen=info.getValue(""String_Node_Str"",int[].class);
    int[] end2=info.getValue(""String_Node_Str"",int[].class);
    int[] pos2=info.getValue(""String_Node_Str"",int[].class);
    Boolean isinv=info.getValue(""String_Node_Str"",Boolean.class);
    String[] traid=info.getValue(""String_Node_Str"",String[].class);
    String[] chr2=info.getValue(""String_Node_Str"",String[].class);
    deletedReference=REF;
    byte[] refs=new byte[0];
    pos++;
    if (Alt.SVType.SVSubtype.TRA.equals(alts[0].getSymbolicAllele().getMinor())) {
      if (traid == null || traid.length == 0) {
        throw new IllegalArgumentException(""String_Node_Str"" + line);
      }
    }
    if (alts[0].getSymbolicAllele().getMajor() == Alt.SVType.INV) {
      if (svlen.length > 0) {
        for (int i=0; i < svlen.length; i++) {
          int alternativeAlleleLength=Math.max(Math.abs(svlen[i]),1);
          alts[i].setSeq(new FlexSeq(FlexSeq.Type.INV,alternativeAlleleLength));
        }
        return new Variant.Builder().chr(chr).pos(pos).referenceAlleleLength(Math.abs(svlen[0])).ref(refs).alts(alts).phase(genotypeArray).isPhased(isGenotypePhased).varId(variantId).filter(FILTER).refDeleted(deletedReference).randomNumberGenerator(random).build();
      }
 else       if (end != null && end.length > 0 && end[0] > 0) {
        int alternativeAlleleLength=Math.max(Math.abs(end[0] - pos + 1),1);
        alts[0].setSeq(new FlexSeq(FlexSeq.Type.INV,alternativeAlleleLength));
        return new Variant.Builder().chr(chr).pos(pos).referenceAlleleLength(alternativeAlleleLength).ref(refs).alts(alts).phase(genotypeArray).isPhased(isGenotypePhased).varId(variantId).filter(FILTER).refDeleted(deletedReference).randomNumberGenerator(random).build();
      }
 else {
        log.error(""String_Node_Str"");
        log.error(line);
        log.error(""String_Node_Str"");
        return null;
      }
    }
 else     if (alts[0].getSymbolicAllele().getMajor() == Alt.SVType.DUP && ((alts[0].getSymbolicAllele().getMinor() != Alt.SVType.SVSubtype.TRA && alts[0].getSymbolicAllele().getMinor() != Alt.SVType.SVSubtype.ISP && info.getValue(""String_Node_Str"",getType(""String_Node_Str"")) == null) || alts[0].getSymbolicAllele().getMinor() == Alt.SVType.SVSubtype.TANDEM)) {
      if (svlen.length > 0) {
        for (int i=0; i < svlen.length; i++) {
          int currentCopyNumber=1;
          for (int j=0; j < 2; j++) {
            if ((i + 1) == genotypeArray[j]) {
              if (copyNumberArray[j] > 0) {
                currentCopyNumber=copyNumberArray[j];
              }
            }
          }
          int alternativeAlleleLength=Math.max(Math.abs(svlen[i]),1);
          alts[i].setSeq(new FlexSeq(FlexSeq.Type.TANDEM_DUP,alternativeAlleleLength,currentCopyNumber));
        }
        return new Variant.Builder().chr(chr).pos(pos).referenceAlleleLength(Math.abs(svlen[0])).ref(refs).alts(alts).phase(genotypeArray).isPhased(isGenotypePhased).varId(variantId).filter(FILTER).refDeleted(deletedReference).randomNumberGenerator(random).build();
      }
 else       if (end != null && end.length > 0 && end[0] > 0) {
        int alternativeAlleleLength=Math.max(Math.abs(end[0] - pos + 1),1);
        alts[0].setSeq(new FlexSeq(FlexSeq.Type.TANDEM_DUP,alternativeAlleleLength,Math.max(copyNumberArray[0],copyNumberArray[1])));
        return new Variant.Builder().chr(chr).pos(pos).referenceAlleleLength(alternativeAlleleLength).ref(refs).alts(alts).phase(genotypeArray).isPhased(isGenotypePhased).varId(variantId).filter(FILTER).refDeleted(deletedReference).randomNumberGenerator(random).build();
      }
 else {
        log.error(""String_Node_Str"");
        log.error(line);
        log.error(""String_Node_Str"");
        return null;
      }
    }
 else     if (alts[0].getSymbolicAllele().getMajor() == Alt.SVType.INS) {
      if (svlen.length > 0) {
        for (int i=0; i < svlen.length; i++) {
          int alternativeAlleleLength=svlen[i] == 0 ? Integer.MAX_VALUE : Math.max(Math.abs(svlen[i]),1);
          alts[i].setSeq(new FlexSeq(FlexSeq.Type.INS,alternativeAlleleLength));
        }
        return new Variant.Builder().chr(chr).pos(pos).referenceAlleleLength(0).ref(refs).alts(alts).phase(genotypeArray).isPhased(isGenotypePhased).varId(variantId).filter(FILTER).refDeleted(deletedReference).randomNumberGenerator(random).build();
      }
 else       if (end != null && end.length > 0 && end[0] > 0) {
        int alternativeAlleleLength=Math.max(Math.abs(end[0] - pos),1);
        alts[0].setSeq(new FlexSeq(FlexSeq.Type.INS,alternativeAlleleLength));
        return new Variant.Builder().chr(chr).pos(pos).referenceAlleleLength(0).ref(refs).alts(alts).phase(genotypeArray).isPhased(isGenotypePhased).varId(variantId).filter(FILTER).refDeleted(deletedReference).randomNumberGenerator(random).build();
      }
 else {
        log.error(""String_Node_Str"");
        log.error(line);
        log.error(""String_Node_Str"");
        return null;
      }
    }
 else     if (alts[0].getSymbolicAllele().getMajor() == Alt.SVType.DEL) {
      Variant.Builder template=new Variant.Builder().chr(chr).pos(pos).ref(refs).phase(genotypeArray).isPhased(isGenotypePhased).varId(variantId).filter(FILTER).refDeleted(deletedReference).randomNumberGenerator(random).traid(traid == null ? null : traid[0]);
      if (svlen.length > 0) {
        for (int i=0; i < svlen.length; i++) {
          if (Alt.SVType.SVSubtype.TRA == alts[i].getSymbolicAllele().getMinor()) {
            alts[i].setSeq(new FlexSeq(FlexSeq.Type.TRA_DEL,svlen[i]));
          }
 else {
            alts[i].setSeq(new FlexSeq(FlexSeq.Type.DEL,0));
          }
        }
        return template.alts(alts).referenceAlleleLength(Math.abs(svlen[0])).build();
      }
 else       if (end != null && end.length > 0 && end[0] > 0) {
        int alternativeAlleleLength=end[0] - pos + 1;
        if (Alt.SVType.SVSubtype.TRA == alts[0].getSymbolicAllele().getMinor()) {
          alts[0].setSeq(new FlexSeq(FlexSeq.Type.TRA_DEL,-alternativeAlleleLength));
        }
 else {
          alts[0].setSeq(new FlexSeq(FlexSeq.Type.DEL,0));
        }
        return template.alts(alts).referenceAlleleLength(alternativeAlleleLength).build();
      }
 else {
        log.error(""String_Node_Str"");
        log.error(line);
        log.error(""String_Node_Str"");
        return null;
      }
    }
 else     if (alts[0].getSymbolicAllele().getMajor() == Alt.SVType.DUP && (alts[0].getSymbolicAllele().getMinor() == Alt.SVType.SVSubtype.TRA || alts[0].getSymbolicAllele().getMinor() == Alt.SVType.SVSubtype.ISP || info.getValue(""String_Node_Str"",getType(""String_Node_Str"")) != null)) {
      if (svlen.length > 0) {
        for (int altAlleleIndex=1; altAlleleIndex <= svlen.length; altAlleleIndex++) {
          int currentCopyNumber=1;
          if (altAlleleIndex == genotypeArray[0]) {
            currentCopyNumber=copyNumberArray[0];
          }
          if (altAlleleIndex == genotypeArray[1]) {
            currentCopyNumber=copyNumberArray[1];
          }
          currentCopyNumber=Math.max(1,currentCopyNumber);
          int altAllelelength=Math.max(Math.abs(svlen[altAlleleIndex - 1]),1);
          alts[altAlleleIndex - 1].setSeq(new FlexSeq(alts[altAlleleIndex - 1].getSymbolicAllele().getMinor() == Alt.SVType.SVSubtype.TRA ? FlexSeq.Type.TRA_DUP : FlexSeq.Type.ISP_DUP,altAllelelength,currentCopyNumber));
        }
        for (int i=1; i < svlen.length; i++) {
          if (svlen[i] != svlen[0]) {
            throw new IllegalArgumentException(""String_Node_Str"" + line);
          }
        }
        return new Variant.Builder().chr(chr).pos(pos).referenceAlleleLength(Math.abs(0)).ref(refs).alts(alts).phase(genotypeArray).isPhased(isGenotypePhased).varId(variantId).filter(FILTER).refDeleted(deletedReference).randomNumberGenerator(random).chr2(ChrString.string2ChrString(chr2)).pos2(pos2).end2(end2).isinv(isinv).traid(traid == null ? null : traid[0]).build();
      }
 else {
        log.error(""String_Node_Str"");
        log.error(line);
        log.error(""String_Node_Str"");
        return null;
      }
    }
 else {
      log.warn(""String_Node_Str"" + line);
      return null;
    }
  }
 else   if (alts[0].getSeq() != null) {
    for (int i=0; i < alts.length; i++) {
      if (REF.length() == 1 && alts[i].length() == 1) {
      }
 else       if (REF.length() == 0 || alts[i].length() == 0) {
        log.warn(""String_Node_Str"");
        log.warn(line);
        return null;
      }
    }
    while (REF.length() > 0) {
      boolean same=true;
      for (int i=0; i < alts.length; i++) {
        if (alts[i].length() == 0 || REF.charAt(0) != alts[i].byteAt(0)) {
          same=false;
          break;
        }
      }
      if (same) {
        pos++;
        deletedReference=String.valueOf(REF.charAt(0));
        REF=REF.substring(1);
        for (int i=0; i < alts.length; i++) {
          alts[i].setSeq(new FlexSeq(alts[i].getSeq().substring(1)));
        }
      }
 else {
        break;
      }
    }
    if (REF.length() > 0) {
      int referenceAlleleLength=REF.length();
      int minClipLength=Integer.MAX_VALUE;
      for (int i=0; i < alts.length; i++) {
        int alternativeAlleleLength=alts[i].length();
        int clipLength=0;
        for (int j=0; j < alternativeAlleleLength; j++) {
          if (referenceAlleleLength <= j) {
            clipLength=j;
            break;
          }
          if (REF.charAt(referenceAlleleLength - j - 1) != alts[i].byteAt(alternativeAlleleLength - j - 1)) {
            clipLength=j;
            break;
          }
          clipLength=j + 1;
        }
        if (minClipLength > clipLength) {
          minClipLength=clipLength;
        }
      }
      if (minClipLength > 0) {
        REF=REF.substring(0,Math.max(0,referenceAlleleLength - minClipLength));
        for (int i=0; i < alts.length; i++) {
          alts[i].setSeq(new FlexSeq(alts[i].getSeq().substring(0,Math.max(0,alts[i].length() - minClipLength))));
        }
      }
    }
    byte[] refs=new byte[REF.length()];
    for (int i=0; i < REF.length(); i++) {
      refs[i]=(byte)REF.charAt(i);
    }
    return new Variant.Builder().chr(chr).pos(pos).referenceAlleleLength(refs.length).ref(refs).alts(alts).phase(genotypeArray).isPhased(isGenotypePhased).varId(variantId).filter(FILTER).refDeleted(deletedReference).randomNumberGenerator(random).build();
  }
 else {
    log.warn(""String_Node_Str"" + line);
  }
  return null;
}","/** 
 * takes a line from a VCF file, parse it, return a Variant object right now the meta-info lines (beginning with ##) are not tied with data line parsing. This will be corrected in the future (perhaps with help of HTSJDK).
 * @param line
 * @return
 */
public Variant processLine(String line) throws UnexpectedException {
  Iterable<String> toks=Splitter.on('\t').split(line);
  if (line.startsWith(""String_Node_Str"")) {
    if (sampleId != null && line.startsWith(""String_Node_Str"")) {
      chromLineSeen=true;
      int index=0;
      for (      String tok : toks) {
        index++;
        if (tok.equals(sampleId))         sampleIndex=index;
      }
    }
 else     if (sampleId == null) {
      sampleIndex=10;
    }
    return null;
  }
  if (sampleIndex < 0 && !chromLineSeen) {
    sampleIndex=10;
  }
 else   if (sampleIndex < 0) {
    sampleIndex=10;
    log.warn(""String_Node_Str"" + sampleId + ""String_Node_Str"");
  }
  int index=0, genotypeIndex=-1, copyNumberIndex=-1;
  int pos=-1;
  ChrString chr=null;
  String REF=""String_Node_Str"", FILTER=""String_Node_Str"", ALT=""String_Node_Str"", variantId=""String_Node_Str"";
  String phase=""String_Node_Str"", copyNumber=""String_Node_Str"", infoString=""String_Node_Str"", FORMAT;
  String[] sampleInfo;
  for (  String tok : toks) {
    index++;
    if (index == 1) {
      chr=new ChrString(tok);
    }
 else     if (index == 2)     pos=Integer.parseInt(tok);
 else     if (index == 3)     variantId=tok;
 else     if (index == 4)     REF=tok;
 else     if (index == 5)     ALT=tok;
 else     if (index == 7)     FILTER=tok;
 else     if (index == 8)     infoString=tok;
 else     if (index == 9) {
      FORMAT=tok;
      genotypeIndex=getFormatKeyIndex(FORMAT,""String_Node_Str"");
      copyNumberIndex=getFormatKeyIndex(FORMAT,""String_Node_Str"");
    }
 else     if (index == sampleIndex) {
      sampleInfo=tok.split(""String_Node_Str"");
      if (genotypeIndex >= 0) {
        phase=sampleInfo[genotypeIndex];
      }
      if (copyNumberIndex >= 0) {
        copyNumber=sampleInfo[copyNumberIndex];
      }
      break;
    }
  }
  if (chr == null) {
    log.warn(""String_Node_Str"" + line);
    return null;
  }
  if (isPassFilterRequired && !(FILTER.contains(""String_Node_Str"") || FILTER.equals(DEFAULT_FILTER))) {
    return null;
  }
  byte[] genotypeArray=new byte[2];
  boolean isGenotypePhased=isPhased(phase,genotypeArray,chr);
  if (genotypeIndex >= 0 && genotypeArray[0] == 0 && genotypeArray[1] == 0) {
  }
  byte[] copyNumberArray=new byte[2];
  boolean isCopyNumberPhased;
  if (copyNumberIndex >= 0) {
    isCopyNumberPhased=isPhased(copyNumber,copyNumberArray,chr);
    if (isCopyNumberPhased != isGenotypePhased) {
      log.error(""String_Node_Str"");
      log.error(line);
      return null;
    }
  }
  REF=REF.toUpperCase();
  ALT=ALT.toUpperCase();
  String deletedReference=""String_Node_Str"";
  VCFInfo info=new VCFInfo(infoString);
  if (ALT.indexOf('<') != -1) {
    String[] alternativeAlleles=ALT.split(""String_Node_Str"");
    int[] svlen=info.getValue(""String_Node_Str"",int[].class);
    if (alternativeAlleles.length != svlen.length) {
      throw new IllegalArgumentException(""String_Node_Str"" + line);
    }
    for (int i=0; i < alternativeAlleles.length; i++) {
      if (!alternativeAlleles[i].startsWith(""String_Node_Str"")) {
        throw new IllegalArgumentException(""String_Node_Str"" + line);
      }
    }
  }
  Alt[] alts=string2Alt(ALT);
  if (alts[0].getSymbolicAllele() != null) {
    int[] end=info.getValue(""String_Node_Str"",int[].class);
    int[] svlen=info.getValue(""String_Node_Str"",int[].class);
    int[] end2=info.getValue(""String_Node_Str"",int[].class);
    int[] pos2=info.getValue(""String_Node_Str"",int[].class);
    Boolean isinv=info.getValue(""String_Node_Str"",Boolean.class);
    String[] traid=info.getValue(""String_Node_Str"",String[].class);
    String[] chr2=info.getValue(""String_Node_Str"",String[].class);
    deletedReference=REF;
    byte[] refs=new byte[0];
    pos++;
    if (Alt.SVType.SVSubtype.TRA.equals(alts[0].getSymbolicAllele().getMinor())) {
      if (traid == null || traid.length == 0) {
        throw new IllegalArgumentException(""String_Node_Str"" + line);
      }
    }
    if (alts[0].getSymbolicAllele().getMajor() == Alt.SVType.INV) {
      if (svlen.length > 0) {
        for (int i=0; i < svlen.length; i++) {
          int alternativeAlleleLength=Math.max(Math.abs(svlen[i]),1);
          alts[i].setSeq(new FlexSeq(FlexSeq.Type.INV,alternativeAlleleLength));
        }
        return new Variant.Builder().chr(chr).pos(pos).referenceAlleleLength(Math.abs(svlen[0])).ref(refs).alts(alts).phase(genotypeArray).isPhased(isGenotypePhased).varId(variantId).filter(FILTER).refDeleted(deletedReference).randomNumberGenerator(random).build();
      }
 else       if (end != null && end.length > 0 && end[0] > 0) {
        int alternativeAlleleLength=Math.max(Math.abs(end[0] - pos + 1),1);
        alts[0].setSeq(new FlexSeq(FlexSeq.Type.INV,alternativeAlleleLength));
        return new Variant.Builder().chr(chr).pos(pos).referenceAlleleLength(alternativeAlleleLength).ref(refs).alts(alts).phase(genotypeArray).isPhased(isGenotypePhased).varId(variantId).filter(FILTER).refDeleted(deletedReference).randomNumberGenerator(random).build();
      }
 else {
        log.error(""String_Node_Str"");
        log.error(line);
        log.error(""String_Node_Str"");
        return null;
      }
    }
 else     if (alts[0].getSymbolicAllele().getMajor() == Alt.SVType.DUP && ((alts[0].getSymbolicAllele().getMinor() != Alt.SVType.SVSubtype.TRA && alts[0].getSymbolicAllele().getMinor() != Alt.SVType.SVSubtype.ISP && info.getValue(""String_Node_Str"",getType(""String_Node_Str"")) == null) || alts[0].getSymbolicAllele().getMinor() == Alt.SVType.SVSubtype.TANDEM)) {
      if (svlen.length > 0) {
        for (int i=0; i < svlen.length; i++) {
          int currentCopyNumber=1;
          for (int j=0; j < 2; j++) {
            if ((i + 1) == genotypeArray[j]) {
              if (copyNumberArray[j] > 0) {
                currentCopyNumber=copyNumberArray[j];
              }
            }
          }
          int alternativeAlleleLength=Math.max(Math.abs(svlen[i]),1);
          alts[i].setSeq(new FlexSeq(FlexSeq.Type.TANDEM_DUP,alternativeAlleleLength,currentCopyNumber));
        }
        return new Variant.Builder().chr(chr).pos(pos).referenceAlleleLength(Math.abs(svlen[0])).ref(refs).alts(alts).phase(genotypeArray).isPhased(isGenotypePhased).varId(variantId).filter(FILTER).refDeleted(deletedReference).randomNumberGenerator(random).build();
      }
 else       if (end != null && end.length > 0 && end[0] > 0) {
        int alternativeAlleleLength=Math.max(Math.abs(end[0] - pos + 1),1);
        alts[0].setSeq(new FlexSeq(FlexSeq.Type.TANDEM_DUP,alternativeAlleleLength,Math.max(copyNumberArray[0],copyNumberArray[1])));
        return new Variant.Builder().chr(chr).pos(pos).referenceAlleleLength(alternativeAlleleLength).ref(refs).alts(alts).phase(genotypeArray).isPhased(isGenotypePhased).varId(variantId).filter(FILTER).refDeleted(deletedReference).randomNumberGenerator(random).build();
      }
 else {
        log.error(""String_Node_Str"");
        log.error(line);
        log.error(""String_Node_Str"");
        return null;
      }
    }
 else     if (alts[0].getSymbolicAllele().getMajor() == Alt.SVType.INS) {
      if (svlen.length > 0) {
        for (int i=0; i < svlen.length; i++) {
          int alternativeAlleleLength=svlen[i] == 0 ? Integer.MAX_VALUE : Math.max(Math.abs(svlen[i]),1);
          alts[i].setSeq(new FlexSeq(FlexSeq.Type.INS,alternativeAlleleLength));
        }
        return new Variant.Builder().chr(chr).pos(pos).referenceAlleleLength(0).ref(refs).alts(alts).phase(genotypeArray).isPhased(isGenotypePhased).varId(variantId).filter(FILTER).refDeleted(deletedReference).randomNumberGenerator(random).build();
      }
 else       if (end != null && end.length > 0 && end[0] > 0) {
        int alternativeAlleleLength=Math.max(Math.abs(end[0] - pos),1);
        alts[0].setSeq(new FlexSeq(FlexSeq.Type.INS,alternativeAlleleLength));
        return new Variant.Builder().chr(chr).pos(pos).referenceAlleleLength(0).ref(refs).alts(alts).phase(genotypeArray).isPhased(isGenotypePhased).varId(variantId).filter(FILTER).refDeleted(deletedReference).randomNumberGenerator(random).build();
      }
 else {
        log.error(""String_Node_Str"");
        log.error(line);
        log.error(""String_Node_Str"");
        return null;
      }
    }
 else     if (alts[0].getSymbolicAllele().getMajor() == Alt.SVType.DEL) {
      Variant.Builder template=new Variant.Builder().chr(chr).pos(pos).ref(refs).phase(genotypeArray).isPhased(isGenotypePhased).varId(variantId).filter(FILTER).refDeleted(deletedReference).randomNumberGenerator(random).traid(traid == null ? null : traid[0]);
      if (svlen.length > 0) {
        for (int i=0; i < svlen.length; i++) {
          if (Alt.SVType.SVSubtype.TRA == alts[i].getSymbolicAllele().getMinor()) {
            alts[i].setSeq(new FlexSeq(FlexSeq.Type.TRA_DEL,svlen[i]));
          }
 else {
            alts[i].setSeq(new FlexSeq(FlexSeq.Type.DEL,0));
          }
        }
        return template.alts(alts).referenceAlleleLength(Math.abs(svlen[0])).build();
      }
 else       if (end != null && end.length > 0 && end[0] > 0) {
        int alternativeAlleleLength=end[0] - pos + 1;
        if (Alt.SVType.SVSubtype.TRA == alts[0].getSymbolicAllele().getMinor()) {
          alts[0].setSeq(new FlexSeq(FlexSeq.Type.TRA_DEL,-alternativeAlleleLength));
        }
 else {
          alts[0].setSeq(new FlexSeq(FlexSeq.Type.DEL,0));
        }
        return template.alts(alts).referenceAlleleLength(alternativeAlleleLength).build();
      }
 else {
        log.error(""String_Node_Str"");
        log.error(line);
        log.error(""String_Node_Str"");
        return null;
      }
    }
 else     if (alts[0].getSymbolicAllele().getMajor() == Alt.SVType.DUP && (alts[0].getSymbolicAllele().getMinor() == Alt.SVType.SVSubtype.TRA || alts[0].getSymbolicAllele().getMinor() == Alt.SVType.SVSubtype.ISP || info.getValue(""String_Node_Str"",getType(""String_Node_Str"")) != null)) {
      if (svlen.length > 0) {
        for (int altAlleleIndex=1; altAlleleIndex <= svlen.length; altAlleleIndex++) {
          int currentCopyNumber=1;
          if (altAlleleIndex == genotypeArray[0]) {
            currentCopyNumber=copyNumberArray[0];
          }
          if (altAlleleIndex == genotypeArray[1]) {
            currentCopyNumber=copyNumberArray[1];
          }
          currentCopyNumber=Math.max(1,currentCopyNumber);
          int altAllelelength=Math.max(Math.abs(svlen[altAlleleIndex - 1]),1);
          alts[altAlleleIndex - 1].setSeq(new FlexSeq(alts[altAlleleIndex - 1].getSymbolicAllele().getMinor() == Alt.SVType.SVSubtype.TRA ? FlexSeq.Type.TRA_DUP : FlexSeq.Type.ISP_DUP,altAllelelength,currentCopyNumber));
        }
        for (int i=1; i < svlen.length; i++) {
          if (svlen[i] != svlen[0]) {
            throw new IllegalArgumentException(""String_Node_Str"" + line);
          }
        }
        return new Variant.Builder().chr(chr).pos(pos).referenceAlleleLength(Math.abs(0)).ref(refs).alts(alts).phase(genotypeArray).isPhased(isGenotypePhased).varId(variantId).filter(FILTER).refDeleted(deletedReference).randomNumberGenerator(random).chr2(ChrString.string2ChrString(chr2)).pos2(pos2).end2(end2).isinv(isinv).traid(traid == null ? null : traid[0]).build();
      }
 else {
        log.error(""String_Node_Str"");
        log.error(line);
        log.error(""String_Node_Str"");
        return null;
      }
    }
 else {
      log.warn(""String_Node_Str"" + line);
      return null;
    }
  }
 else   if (alts[0].getSeq() != null) {
    for (int i=0; i < alts.length; i++) {
      if (REF.length() == 1 && alts[i].length() == 1) {
      }
 else       if (REF.length() == 0 || alts[i].length() == 0) {
        log.warn(""String_Node_Str"");
        log.warn(line);
        return null;
      }
    }
    while (REF.length() > 0) {
      boolean same=true;
      for (int i=0; i < alts.length; i++) {
        if (alts[i].length() == 0 || REF.charAt(0) != alts[i].byteAt(0)) {
          same=false;
          break;
        }
      }
      if (same) {
        pos++;
        deletedReference=String.valueOf(REF.charAt(0));
        REF=REF.substring(1);
        for (int i=0; i < alts.length; i++) {
          alts[i].setSeq(new FlexSeq(alts[i].getSeq().substring(1)));
        }
      }
 else {
        break;
      }
    }
    if (REF.length() > 0) {
      int referenceAlleleLength=REF.length();
      int minClipLength=Integer.MAX_VALUE;
      for (int i=0; i < alts.length; i++) {
        int alternativeAlleleLength=alts[i].length();
        int clipLength=0;
        for (int j=0; j < alternativeAlleleLength; j++) {
          if (referenceAlleleLength <= j) {
            clipLength=j;
            break;
          }
          if (REF.charAt(referenceAlleleLength - j - 1) != alts[i].byteAt(alternativeAlleleLength - j - 1)) {
            clipLength=j;
            break;
          }
          clipLength=j + 1;
        }
        if (minClipLength > clipLength) {
          minClipLength=clipLength;
        }
      }
      if (minClipLength > 0) {
        REF=REF.substring(0,Math.max(0,referenceAlleleLength - minClipLength));
        for (int i=0; i < alts.length; i++) {
          alts[i].setSeq(new FlexSeq(alts[i].getSeq().substring(0,Math.max(0,alts[i].length() - minClipLength))));
        }
      }
    }
    byte[] refs=new byte[REF.length()];
    for (int i=0; i < REF.length(); i++) {
      refs[i]=(byte)REF.charAt(i);
    }
    return new Variant.Builder().chr(chr).pos(pos).referenceAlleleLength(refs.length).ref(refs).alts(alts).phase(genotypeArray).isPhased(isGenotypePhased).varId(variantId).filter(FILTER).refDeleted(deletedReference).randomNumberGenerator(random).build();
  }
 else {
    log.warn(""String_Node_Str"" + line);
  }
  return null;
}",0.978717356546456
80623,"/** 
 * @param dgvVariantType DGV Variant type
 * @param dgvVariantSubtype DGV Variant subtype
 * @return VariantType. Return value is null if cannot map to the right VariantType
 */
public VariantType getVariantType(final String dgvVariantType,final String dgvVariantSubtype){
switch (dgvVariantType) {
case ""String_Node_Str"":
switch (dgvVariantSubtype) {
case ""String_Node_Str"":
      return VariantType.Tandem_Duplication;
case ""String_Node_Str"":
    return VariantType.Deletion;
case ""String_Node_Str"":
  return VariantType.Tandem_Duplication;
case ""String_Node_Str"":
return VariantType.Tandem_Duplication;
case ""String_Node_Str"":
return VariantType.Insertion;
case ""String_Node_Str"":
return VariantType.Deletion;
default :
throw new IllegalArgumentException(""String_Node_Str"" + dgvVariantSubtype);
}
case ""String_Node_Str"":
switch (dgvVariantSubtype) {
case ""String_Node_Str"":
return VariantType.Tandem_Duplication;
case ""String_Node_Str"":
return VariantType.Inversion;
default :
throw new IllegalArgumentException(""String_Node_Str"" + dgvVariantSubtype);
}
default :
throw new IllegalArgumentException(""String_Node_Str"" + dgvVariantType);
}
}","/** 
 * @param dgvVariantType DGV Variant type
 * @param dgvVariantSubtype DGV Variant subtype
 * @return VariantType. Return value is null if cannot map to the right VariantType
 */
public VariantType getVariantType(final String dgvVariantSubtype){
switch (dgvVariantSubtype) {
case ""String_Node_Str"":
    return VariantType.Tandem_Duplication;
case ""String_Node_Str"":
  return VariantType.Deletion;
case ""String_Node_Str"":
return VariantType.Tandem_Duplication;
case ""String_Node_Str"":
return VariantType.Tandem_Duplication;
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
return VariantType.Insertion;
case ""String_Node_Str"":
return VariantType.Deletion;
case ""String_Node_Str"":
return VariantType.Tandem_Duplication;
case ""String_Node_Str"":
return VariantType.Inversion;
default :
throw new IllegalArgumentException(""String_Node_Str"" + dgvVariantSubtype);
}
}",0.7059980334316618
80624,"public Variant parseLine(){
  String line=this.line;
  readLine();
  if (line == null || line.length() == 0) {
    return null;
  }
  if (isHeaderLine(line)) {
    return null;
  }
  String[] ll=line.split(DGV_COLUMN_SEPARATOR);
  final String var_id=ll[0];
  final ChrString chr=new ChrString(ll[1]);
  final int start_loc=Integer.parseInt(ll[2]);
  final int end_loc=Integer.parseInt(ll[3]);
  VariantType type=null;
  try {
    type=getVariantType(ll[4],ll[5]);
  }
 catch (  Exception e) {
    log.error(e.getMessage());
    return null;
  }
  int observedgains=(ll[15].length() > 0) ? Integer.parseInt(ll[15]) : 0;
  String REF;
  Alt[] alts=new Alt[1];
switch (type) {
case Deletion:
    byte[] temp=reference.byteRange(chr,start_loc,end_loc);
  if (temp != null) {
    REF=new String(temp);
  }
 else {
    log.error(""String_Node_Str"");
    log.error(""String_Node_Str"" + line);
    return null;
  }
alts[0]=new Alt(new FlexSeq());
break;
case Insertion:
REF=""String_Node_Str"";
alts[0]=new Alt(new FlexSeq(FlexSeq.Type.INS,end_loc - start_loc + 1));
break;
case Tandem_Duplication:
REF=""String_Node_Str"";
alts[0]=new Alt(new FlexSeq(FlexSeq.Type.TANDEM_DUP,end_loc - start_loc + 1,observedgains));
observedgains=Math.max(2,observedgains);
break;
case Inversion:
REF=""String_Node_Str"";
alts[0]=new Alt(new FlexSeq(FlexSeq.Type.INV,end_loc - start_loc + 1));
break;
default :
return null;
}
REF=REF.toUpperCase();
byte[] refs=new byte[REF.length()];
for (int i=0; i < REF.length(); i++) {
refs[i]=(byte)REF.charAt(i);
}
if (REF.length() == 1 && alts[0].length() == 1) {
return null;
}
 else if (REF.length() == 0 && alts[0].length() == 0) {
log.error(""String_Node_Str"");
log.error(""String_Node_Str"" + line);
return null;
}
byte[] phase={1,1};
return new Variant.Builder().chr(chr).pos(start_loc).referenceAlleleLength(refs.length).ref(refs).alts(alts).phase(phase).isPhased(false).varId(var_id).filter(""String_Node_Str"").refDeleted(String.valueOf((char)reference.byteAt(chr,start_loc - 1))).randomNumberGenerator(rand).build();
}","public Variant parseLine(){
  try {
    String line=this.line;
    readLine();
    if (line == null || line.length() == 0) {
      return null;
    }
    if (isHeaderLine(line)) {
      return null;
    }
    String[] ll=line.split(DGV_COLUMN_SEPARATOR);
    final String var_id=ll[0];
    final ChrString chr=new ChrString(ll[1]);
    final int start_loc=Integer.parseInt(ll[2]);
    final int end_loc=Integer.parseInt(ll[3]);
    VariantType type=getVariantType(ll[5].toLowerCase());
    int observedgains=(ll[15].length() > 0) ? Integer.parseInt(ll[15]) : 0;
    String REF;
    Alt[] alts=new Alt[1];
switch (type) {
case Deletion:
      byte[] temp=reference.byteRange(chr,start_loc,end_loc);
    if (temp != null) {
      REF=new String(temp);
    }
 else {
      log.error(""String_Node_Str"");
      log.error(""String_Node_Str"" + line);
      return null;
    }
  alts[0]=new Alt(new FlexSeq());
break;
case Insertion:
REF=""String_Node_Str"";
alts[0]=new Alt(new FlexSeq(FlexSeq.Type.INS,end_loc - start_loc + 1));
break;
case Tandem_Duplication:
REF=""String_Node_Str"";
alts[0]=new Alt(new FlexSeq(FlexSeq.Type.TANDEM_DUP,end_loc - start_loc + 1,observedgains));
observedgains=Math.max(2,observedgains);
break;
case Inversion:
REF=""String_Node_Str"";
alts[0]=new Alt(new FlexSeq(FlexSeq.Type.INV,end_loc - start_loc + 1));
break;
default :
return null;
}
REF=REF.toUpperCase();
byte[] refs=new byte[REF.length()];
for (int i=0; i < REF.length(); i++) {
refs[i]=(byte)REF.charAt(i);
}
if (REF.length() == 1 && alts[0].length() == 1) {
return null;
}
 else if (REF.length() == 0 && alts[0].length() == 0) {
log.error(""String_Node_Str"");
log.error(""String_Node_Str"" + line);
return null;
}
byte[] phase={1,1};
return new Variant.Builder().chr(chr).pos(start_loc).referenceAlleleLength(refs.length).ref(refs).alts(alts).phase(phase).isPhased(false).varId(var_id).filter(""String_Node_Str"").refDeleted(String.valueOf((char)reference.byteAt(chr,start_loc - 1))).randomNumberGenerator(rand).build();
}
 catch (Exception e) {
log.error(e.getMessage());
log.error(""String_Node_Str"" + line);
return null;
}
}",0.8988872762457668
80625,"/** 
 * there are 3 possible ways to construct an ALT 1) breakend 2) symbolic allele 3) alt sequence
 */
public Alt(String alt){
  if (alt.startsWith(""String_Node_Str"")) {
    this.symbolicAllele=SymbolicAllele.symbolicAlleleFactory(alt);
  }
 else   if (alt.indexOf(""String_Node_Str"") >= 0) {
    this.breakend=Breakend.breakendFactory(alt);
  }
}","/** 
 * there are 3 possible ways to construct an ALT 1) breakend 2) symbolic allele 3) alt sequence
 */
public Alt(String alt){
  if (alt.startsWith(""String_Node_Str"")) {
    this.symbolicAllele=SymbolicAllele.symbolicAlleleFactory(alt);
  }
 else   if (alt.indexOf(""String_Node_Str"") >= 0) {
    this.breakend=Breakend.breakendFactory(alt);
  }
 else {
    this.seq=new FlexSeq(alt.getBytes());
  }
}",0.928
80626,"@Test public void homopolymerInsertionParsingTest() throws UnexpectedException {
  Variant v=parser.processLine(""String_Node_Str"");
  assertTrue(v.toString().equals(""String_Node_Str""));
  assertTrue(v.isPhased());
  assertTrue(v.getReference().length == 0);
  assertTrue(v.getAlt(1).length() == 3);
}","@Test public void homopolymerInsertionParsingTest() throws UnexpectedException {
  Variant v=parser.processLine(""String_Node_Str"");
  assertTrue(v.toString().equals(""String_Node_Str""));
  assertTrue(v.isPhased());
  assertTrue(v.getReference().length == 0);
  assertTrue(v.getAlt(1).getSeq().length() == 3);
}",0.9852216748768472
80627,"@Test public void insertionParsingTest() throws UnexpectedException {
  Variant v=parser.processLine(""String_Node_Str"");
  assertTrue(v.toString().equals(""String_Node_Str""));
  assertTrue(v.isPhased());
  assertTrue(v.getReference().length == 0);
  assertTrue(v.getAlt(1).length() == 2);
}","@Test public void insertionParsingTest() throws UnexpectedException {
  Variant v=parser.processLine(""String_Node_Str"");
  assertTrue(v.toString().equals(""String_Node_Str""));
  assertTrue(v.isPhased());
  assertTrue(v.getReference().length == 0);
  assertTrue(v.getAlt(1).getSeq().length() == 2);
}",0.9846678023850084
80628,"@Test public void deletionParsingTest() throws UnexpectedException {
  Variant v=parser.processLine(""String_Node_Str"");
  assertTrue(v.toString().equals(""String_Node_Str""));
  assertTrue(v.isPhased());
  assertTrue(v.getReference().length == 1);
  assertTrue(v.getAlt(1).length() == 0);
}","@Test public void deletionParsingTest() throws UnexpectedException {
  Variant v=parser.processLine(""String_Node_Str"");
  assertTrue(v.toString().equals(""String_Node_Str""));
  assertTrue(v.isPhased());
  assertTrue(v.getReference().length == 1);
  assertTrue(v.getAlt(1).getSeq().length() == 0);
}",0.9846153846153848
80629,"/** 
 * generate VCF file header a little explanation about translocation-related meta-info lines: each locus involved in translocations is modeled independently as a cut-paste event with slight variations for different types of translocations. Basically, a region at locus A (the sink) will be cut (deleted), and a region at locus B (the source) will be placed at the sink. The placement may be: complete transfer; complete transfer with inversion; no transfer (one-way or unbalanced translocation).
 * @param referenceFileName reference file name
 * @param sampleNames list of sample names
 * @return
 */
private String generateVCFHeader(final String referenceFileName,final List<String> sampleNames){
  String VCFHeader=""String_Node_Str"" + ""String_Node_Str"" + referenceFileName + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  StringJoiner joiner=new StringJoiner(""String_Node_Str"");
  for (  String id : sampleNames) {
    joiner.add(id);
  }
  return VCFHeader + ""String_Node_Str"" + (sampleNames.isEmpty() ? ""String_Node_Str"" : ""String_Node_Str"")+ joiner.toString()+ ""String_Node_Str"";
}","/** 
 * generate VCF file header a little explanation about translocation-related meta-info lines: each locus involved in translocations is modeled independently as a cut-paste event with slight variations for different types of translocations. Basically, a region at locus A (the sink) will be cut (deleted), and a region at locus B (the source) will be placed at the sink. The placement may be: complete transfer; complete transfer with inversion; no transfer (one-way or unbalanced translocation).
 * @param referenceFileName reference file name
 * @param sampleNames list of sample names
 * @return
 */
private String generateVCFHeader(final String referenceFileName,final List<String> sampleNames){
  String VCFHeader=""String_Node_Str"" + ""String_Node_Str"" + referenceFileName + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
  StringJoiner joiner=new StringJoiner(""String_Node_Str"");
  for (  String id : sampleNames) {
    joiner.add(id);
  }
  return VCFHeader + ""String_Node_Str"" + (sampleNames.isEmpty() ? ""String_Node_Str"" : ""String_Node_Str"")+ joiner.toString()+ ""String_Node_Str"";
}",0.9871967654986524
80630,"/** 
 * This is the main function that makes the diploid genome for each chromosome/sequence, all variants are traversed. Each variant is decomposed into a combination of deletion and insertion. Original sequence is flagged at variant loci. Perturbed sequences will be generated based on these flags. Map file format (MFF) records will generated by iterating over flag array of each sequence. VCFs (one for each sequence) containing all sampled variants will be generated as well with optional phasing information (if both maternal and paternal genomes are chosen for output).
 */
public void makeDiploid(){
}","/** 
 * This is the main function that makes the diploid genome for each chromosome/sequence, all variants are traversed. Each variant is decomposed into a combination of deletion and insertion. Original sequence is flagged at variant loci. Perturbed sequences will be generated based on these flags. Map file format (MFF) records will generated by iterating over flag array of each sequence. VCFs (one for each sequence) containing all sampled variants will be generated as well with optional phasing information (if both maternal and paternal genomes are chosen for output).
 */
public void makeDiploid(){
  StringBuilder map_string=new StringBuilder();
  SimpleReference allSequences=new SimpleReference(chrfiles);
  for (  ChrString chr : allSequences.keySet()) {
    Sequence referenceSequence=allSequences.getSequence(chr);
    System.out.println(""String_Node_Str"" + referenceSequence.getName() + ""String_Node_Str"");
    boolean output_paternal=true;
    boolean output_maternal=true;
    if (gender == GenderType.FEMALE) {
      if (chr.isY()) {
        output_paternal=false;
        output_maternal=false;
      }
    }
 else     if (gender == GenderType.MALE) {
      if (chr.isX()) {
        output_paternal=false;
      }
      if (chr.isY()) {
        output_maternal=false;
      }
    }
    if (chr.isMT()) {
      output_paternal=false;
    }
    if (!output_paternal && !output_maternal) {
      continue;
    }
    final List<Variant> varList=variants.containsKey(chr) ? variants.get(chr) : Collections.EMPTY_LIST;
    final List<Boolean> maternalIsVariantAdded=new ArrayList<>();
    final List<Boolean> paternalIsVariantAdded=new ArrayList<>();
    int len=referenceSequence.length();
    byte[] maternalSequence=new byte[len];
    byte[] paternalSequence=new byte[len];
    for (int c=1; c <= len; c++) {
      maternalSequence[c - 1]=paternalSequence[c - 1]=referenceSequence.byteAt(c);
    }
    Hashtable<Integer,FlexSeq> paternalInsertionSeq=new Hashtable<>(150);
    Hashtable<Integer,FlexSeq> maternalInsertionSeq=new Hashtable<>(150);
    int nPaternalVariant=0, nMaternalVariant=0;
    int nPaternalVariantBase=0, nMaternalVariantBase=0;
    for (    Variant var : varList) {
      if (!var.isPhased()) {
        var.randomizeHaplotype();
      }
      if (var.paternal() > 0) {
        if (addVariant(paternalSequence,referenceSequence,var,var.paternal(),paternalInsertionSeq)) {
          nPaternalVariant++;
          nPaternalVariantBase+=var.variantBases();
          paternalIsVariantAdded.add(true);
        }
 else {
          paternalIsVariantAdded.add(false);
        }
      }
 else {
        paternalIsVariantAdded.add(false);
      }
      if (var.maternal() > 0) {
        if (addVariant(maternalSequence,referenceSequence,var,var.maternal(),maternalInsertionSeq)) {
          nMaternalVariant++;
          nMaternalVariantBase+=var.variantBases();
          maternalIsVariantAdded.add(true);
        }
 else {
          maternalIsVariantAdded.add(false);
        }
      }
 else {
        maternalIsVariantAdded.add(false);
      }
    }
    log.info(""String_Node_Str"" + varList.size());
    writeVCF(referenceSequence,varList,paternalIsVariantAdded,maternalIsVariantAdded,output_paternal,output_maternal);
    if (output_paternal) {
      String paternalSequenceName=referenceSequence.getName() + ""String_Node_Str"" + DIPLOID_CHRS[1];
      String paternalSequenceFileName=referenceSequence.getName() + ""String_Node_Str"" + id+ ""String_Node_Str""+ DIPLOID_CHRS[1]+ ""String_Node_Str"";
      makePosMap(map_string,paternalSequenceName,referenceSequence,paternalSequence,paternalInsertionSeq);
      writeHaploid(paternalSequence,paternalInsertionSeq,paternalSequenceName,paternalSequenceFileName);
      System.out.println(""String_Node_Str"" + nPaternalVariant + ""String_Node_Str""+ nPaternalVariantBase+ ""String_Node_Str""+ ""String_Node_Str"");
    }
    if (output_maternal) {
      String maternalSequenceName=referenceSequence.getName() + ""String_Node_Str"" + DIPLOID_CHRS[0];
      String maternalSequenceFileName=referenceSequence.getName() + ""String_Node_Str"" + id+ ""String_Node_Str""+ DIPLOID_CHRS[0]+ ""String_Node_Str"";
      makePosMap(map_string,maternalSequenceName,referenceSequence,maternalSequence,maternalInsertionSeq);
      writeHaploid(maternalSequence,maternalInsertionSeq,maternalSequenceName,maternalSequenceFileName);
      System.out.println(""String_Node_Str"" + nMaternalVariant + ""String_Node_Str""+ nMaternalVariantBase+ ""String_Node_Str""+ ""String_Node_Str"");
    }
  }
  try {
    FileWriter fw=new FileWriter(new File(outDir,id + ""String_Node_Str""));
    BufferedWriter bw=new BufferedWriter(fw);
    bw.write(map_string.toString());
    bw.newLine();
    bw.close();
    fw.close();
    outputMap=new File(outDir,id + ""String_Node_Str"");
  }
 catch (  IOException ex) {
    log.error(ex.toString());
  }
}",0.2224251278305332
80631,"/** 
 * write perturbed maternal or paternal genomes into files flag array and sequences to be inserted for each haploid genome are required. here, insertion has broader meaning as all variants are considered combinations of insertion + deletion instead of calling writeDiploid and then writeMultiploid since we really only have two haplotypes, we can call writeHaploid twice. Got more haplotypes? Use a loop. This avoids creation of anonymous lists.
 * @param sequence
 * @param ins_seq
 * @param sequenceName
 * @param sequenceFileName
 * @param outputFlag
 */
private void writeHaploid(final byte[] sequence,Hashtable<Integer,FlexSeq> ins_seq,final String sequenceName,final String sequenceFileName,final Boolean outputFlag){
  try {
    FileWriter fw=new FileWriter(new File(outDir,sequenceFileName));
    BufferedWriter bw=new BufferedWriter(fw);
    writeGenome(bw,sequenceName,sequence,ins_seq);
    bw.close();
    fw.close();
  }
 catch (  IOException ex) {
    log.error(ex.toString());
  }
}","/** 
 * write perturbed maternal or paternal genomes into files flag array and sequences to be inserted for each haploid genome are required. here, insertion has broader meaning as all variants are considered combinations of insertion + deletion instead of calling writeDiploid and then writeMultiploid since we really only have two haplotypes, we can call writeHaploid twice. Got more haplotypes? Use a loop. This avoids creation of anonymous lists.
 * @param sequence
 * @param ins_seq
 * @param sequenceName
 * @param sequenceFileName
 */
private void writeHaploid(final byte[] sequence,Hashtable<Integer,FlexSeq> ins_seq,final String sequenceName,final String sequenceFileName){
  try {
    FileWriter fw=new FileWriter(new File(outDir,sequenceFileName));
    BufferedWriter bw=new BufferedWriter(fw);
    writeGenome(bw,sequenceName,sequence,ins_seq);
    bw.close();
    fw.close();
  }
 catch (  IOException ex) {
    log.error(ex.toString());
  }
}",0.9765066394279878
80632,"/** 
 * iterate over the original sequence, create map file records for each block of sequence (each block consists of identical events, e.g. insertion, or no-change), append records to sb
 * @param sb output string
 * @param chr_name name of haploid perturbed sequence
 * @param ref_seq name of original sequence
 * @param genome flags for each position of the original sequence
 * @param ins_seq recording positions of all insertions (here insertions are broader than typical definition)
 */
private void makePosMap(StringBuilder sb,String chr_name,Sequence ref_seq,byte[] genome,Hashtable<Integer,FlexSeq> ins_seq){
  boolean[] ins_flag=new boolean[genome.length];
  Enumeration<Integer> enm=ins_seq.keys();
  while (enm.hasMoreElements()) {
    Integer key=enm.nextElement();
    ins_flag[key - 1]=true;
  }
  host_ref_idx hf_idx=new host_ref_idx();
  hf_idx.host_idx=1;
  hf_idx.ref_idx=1;
  map_rec curr_rec=new_curr_rec(sb,0,chr_name,ref_seq.getName(),hf_idx,genome,ins_flag,ins_seq);
  for (int idx=1; idx < genome.length; idx++) {
    boolean same_block=true;
switch (curr_rec.feature) {
case ""String_Node_Str"":
      if (genome[idx] != DELETED_BASE) {
        same_block=false;
      }
 else       if (ins_flag[idx]) {
        same_block=false;
      }
    break;
case ""String_Node_Str"":
  if (genome[idx] == DELETED_BASE) {
    same_block=false;
  }
 else   if (ins_flag[idx]) {
    same_block=false;
  }
break;
default :
same_block=false;
break;
}
if (same_block) {
curr_rec.len++;
}
 else {
adjust_idx(curr_rec,hf_idx);
sb.append(curr_rec);
sb.append('\n');
curr_rec=new_curr_rec(sb,idx,chr_name,ref_seq.getName(),hf_idx,genome,ins_flag,ins_seq);
}
}
sb.append(curr_rec);
sb.append('\n');
}","/** 
 * iterate over the original sequence, create map file records for each block of sequence (each block consists of identical events, e.g. insertion, or no-change), append records to stringBuilder. For details about map file format, look into the comments below.
 * @param sb output string
 * @param chr_name name of haploid perturbed sequence
 * @param ref_seq name of original sequence
 * @param genome flags for each position of the original sequence
 * @param ins_seq recording positions of all insertions (here insertions are broader than typical definition)
 */
private void makePosMap(StringBuilder sb,String chr_name,Sequence ref_seq,byte[] genome,Hashtable<Integer,FlexSeq> ins_seq){
  boolean[] ins_flag=new boolean[genome.length];
  Enumeration<Integer> enm=ins_seq.keys();
  while (enm.hasMoreElements()) {
    Integer key=enm.nextElement();
    ins_flag[key - 1]=true;
  }
  host_ref_idx hf_idx=new host_ref_idx();
  hf_idx.host_idx=1;
  hf_idx.ref_idx=1;
  map_rec curr_rec=new_curr_rec(sb,0,chr_name,ref_seq.getName(),hf_idx,genome,ins_flag,ins_seq);
  for (int idx=1; idx < genome.length; idx++) {
    boolean same_block=true;
switch (curr_rec.feature) {
case ""String_Node_Str"":
      if (genome[idx] != DELETED_BASE) {
        same_block=false;
      }
 else       if (ins_flag[idx]) {
        same_block=false;
      }
    break;
case ""String_Node_Str"":
  if (genome[idx] == DELETED_BASE) {
    same_block=false;
  }
 else   if (ins_flag[idx]) {
    same_block=false;
  }
break;
default :
same_block=false;
break;
}
if (same_block) {
curr_rec.len++;
}
 else {
adjust_idx(curr_rec,hf_idx);
sb.append(curr_rec);
sb.append('\n');
curr_rec=new_curr_rec(sb,idx,chr_name,ref_seq.getName(),hf_idx,genome,ins_flag,ins_seq);
}
}
sb.append(curr_rec);
sb.append('\n');
}",0.9773184036749928
80633,"public void calculateExtraBase(final Sequence refSeq){
  for (  final FlexSeq alt : _alts) {
    if (alt.isSeq() && alt.length() == 0) {
      extraBase=String.valueOf((char)refSeq.byteAt(getPos() + _del));
    }
  }
}","public void calculateExtraBase(final Sequence refSeq){
  for (  final FlexSeq alt : _alts) {
    if (alt.isSeq() && alt.length() == 0 && getPos() + _del < refSeq.length()) {
      extraBase=String.valueOf((char)refSeq.byteAt(getPos() + _del));
    }
  }
}",0.9217758985200846
80634,"public String getLength(){
  StringBuilder len=new StringBuilder();
  for (int i=0; i < _alts.length; i++) {
    if (i > 0) {
      len.append(',');
    }
    VariantType t=getType(i + 1);
    if (t == VariantType.Deletion) {
      len.append(-_del);
    }
 else     if (t == VariantType.Complex) {
      int alt_len=_alts[i].length();
      if (_del > alt_len) {
        len.append(-_del);
      }
 else {
        len.append(alt_len);
      }
    }
 else {
      len.append(_alts[i].length());
    }
  }
  return len.toString();
}","public String getLength(){
  StringBuilder len=new StringBuilder();
  for (int i=0; i < _alts.length; i++) {
    if (i > 0) {
      len.append(',');
    }
    VariantType t=getType(i + 1);
    if (t == VariantType.Deletion) {
      len.append(-_del + _alts[i].length());
    }
 else     if (t == VariantType.Complex) {
      int alt_len=_alts[i].length();
      if (_del > alt_len) {
        len.append(-_del);
      }
 else {
        len.append(alt_len);
      }
    }
 else {
      len.append(_alts[i].length());
    }
  }
  return len.toString();
}",0.9815157116451017
80635,"public StringBuilder alt_string(){
  StringBuilder sbStr=new StringBuilder();
  for (int i=0; i < _alts.length; i++) {
    if (i > 0 && _alts[i].toString().equals(_alts[i - 1].toString())) {
      continue;
    }
    if (i > 0) {
      sbStr.append(""String_Node_Str"");
    }
    if (_alts[i].isSeq()) {
      sbStr.append(_ref_deleted).append(_alts[i].toString()).append(extraBase);
    }
 else {
      sbStr.append(_alts[i].toString());
    }
  }
  return sbStr;
}","public StringBuilder alt_string(){
  StringBuilder sbStr=new StringBuilder();
  for (int i=0; i < _alts.length; i++) {
    if (i > 0) {
      sbStr.append(""String_Node_Str"");
    }
    if (_alts[i].isSeq()) {
      sbStr.append(_ref_deleted).append(_alts[i].toString()).append(extraBase);
    }
 else {
      sbStr.append(_alts[i].toString());
    }
  }
  return sbStr;
}",0.8875598086124402
80636,"/** 
 * takes a line from a VCF file, parse it, return a Variant object
 * @param line
 * @return
 */
public Variant process_line(String line){
  StringTokenizer toks=new StringTokenizer(line);
  if (line.startsWith(""String_Node_Str"")) {
    if (_id != null && line.startsWith(""String_Node_Str"")) {
      chrom_exists=true;
      int index=0;
      while (toks.hasMoreTokens()) {
        index++;
        String tok=toks.nextToken();
        if (tok.equals(_id))         _id_ind=index;
      }
    }
 else     if (_id == null) {
      _id_ind=10;
    }
    return null;
  }
  if (_id_ind < 0 && !chrom_exists) {
    _id_ind=10;
  }
 else   if (_id_ind < 0) {
    _id_ind=10;
    log.warn(""String_Node_Str"" + _id + ""String_Node_Str"");
  }
  int index=0, genotype_ind=-1, copynum_ind=-1;
  int pos=-1;
  ChrString chr=null;
  String REF=""String_Node_Str"", FILTER=""String_Node_Str"", ALT=""String_Node_Str"", var_id=""String_Node_Str"";
  String phase=""String_Node_Str"", copy_num=""String_Node_Str"", INFO=""String_Node_Str"", FORMAT;
  String[] sampleInfo;
  while (toks.hasMoreTokens()) {
    index++;
    if (index == 1) {
      chr=new ChrString(toks.nextToken());
    }
 else     if (index == 2)     pos=Integer.parseInt(toks.nextToken());
 else     if (index == 3)     var_id=toks.nextToken();
 else     if (index == 4)     REF=toks.nextToken();
 else     if (index == 5)     ALT=toks.nextToken();
 else     if (index == 7)     FILTER=toks.nextToken();
 else     if (index == 8)     INFO=toks.nextToken();
 else     if (index == 9) {
      FORMAT=toks.nextToken();
      genotype_ind=getFormatKeyIndex(FORMAT,""String_Node_Str"");
      copynum_ind=getFormatKeyIndex(FORMAT,""String_Node_Str"");
    }
 else     if (index == _id_ind) {
      sampleInfo=(toks.nextToken()).split(""String_Node_Str"");
      if (genotype_ind >= 0) {
        phase=sampleInfo[genotype_ind];
      }
      if (copynum_ind >= 0) {
        copy_num=sampleInfo[copynum_ind];
      }
      break;
    }
 else {
      toks.nextToken();
    }
  }
  if (chr == null) {
    log.warn(""String_Node_Str"" + line);
    return null;
  }
  if (_pass && !(FILTER.contains(""String_Node_Str"") || FILTER.equals(""String_Node_Str""))) {
    return null;
  }
  byte[] phase_val=new byte[2];
  boolean is_phased=splitGeno(phase,phase_val,chr);
  if (genotype_ind >= 0 && phase_val[0] == 0 && phase_val[1] == 0) {
  }
  byte[] copy_num_val=new byte[2];
  boolean is_cn_phased;
  if (copynum_ind >= 0) {
    is_cn_phased=splitGeno(copy_num,copy_num_val,chr);
    if (is_cn_phased != is_phased) {
      log.error(""String_Node_Str"");
      log.error(line);
      return null;
    }
  }
  REF=REF.toUpperCase();
  ALT=ALT.toUpperCase();
  String ref_deleted=""String_Node_Str"";
  FlexSeq alts[];
  if (ALT.equals(""String_Node_Str"")) {
    int inv_lens[]=getSVLen(INFO);
    int end_loc=getEndInfo(INFO);
    ref_deleted=REF;
    byte[] refs=new byte[0];
    pos++;
    if (inv_lens.length > 0) {
      alts=new FlexSeq[inv_lens.length];
      for (int i=0; i < inv_lens.length; i++) {
        int len_val=Math.max(Math.abs(inv_lens[i]),1);
        alts[i]=new FlexSeq(FlexSeq.Type.INV,len_val);
      }
      return new Variant(chr,pos,Math.abs(inv_lens[0]),refs,alts,phase_val,is_phased,var_id,FILTER,ref_deleted,_rand);
    }
 else     if (end_loc > 0) {
      int inv_len=Math.max(Math.abs(end_loc - pos + 1),1);
      alts=new FlexSeq[1];
      alts[0]=new FlexSeq(FlexSeq.Type.INV,inv_len);
      return new Variant(chr,pos,inv_len,refs,alts,phase_val,is_phased,var_id,FILTER,ref_deleted,_rand);
    }
 else {
      log.error(""String_Node_Str"");
      log.error(line);
      log.error(""String_Node_Str"");
      return null;
    }
  }
 else   if (ALT.equals(""String_Node_Str"") || ALT.equals(""String_Node_Str"")) {
    int dup_lens[]=getSVLen(INFO);
    int end_loc=getEndInfo(INFO);
    ref_deleted=REF;
    byte[] refs=new byte[0];
    pos++;
    if (dup_lens.length > 0) {
      alts=new FlexSeq[dup_lens.length];
      for (int i=0; i < dup_lens.length; i++) {
        int copy_val=1;
        for (int j=0; j < 2; j++) {
          if ((i + 1) == phase_val[j]) {
            if (copy_num_val[j] > 0) {
              copy_val=copy_num_val[j];
            }
          }
        }
        int len_val=Math.max(Math.abs(dup_lens[i]),1);
        alts[i]=new FlexSeq(FlexSeq.Type.DUP,len_val,copy_val);
      }
      return new Variant(chr,pos,Math.abs(dup_lens[0]),refs,alts,phase_val,is_phased,var_id,FILTER,ref_deleted,_rand);
    }
 else     if (end_loc > 0) {
      int dup_len=Math.max(Math.abs(end_loc - pos + 1),1);
      alts=new FlexSeq[1];
      alts[0]=new FlexSeq(FlexSeq.Type.DUP,dup_len,Math.max(copy_num_val[0],copy_num_val[1]));
      return new Variant(chr,pos,dup_len,refs,alts,phase_val,is_phased,var_id,FILTER,ref_deleted,_rand);
    }
 else {
      log.error(""String_Node_Str"");
      log.error(line);
      log.error(""String_Node_Str"");
      return null;
    }
  }
 else   if (ALT.equals(""String_Node_Str"")) {
    int ins_lens[]=getSVLen(INFO);
    int end_loc=getEndInfo(INFO);
    ref_deleted=REF;
    byte[] refs=new byte[0];
    pos++;
    if (ins_lens.length > 0) {
      alts=new FlexSeq[ins_lens.length];
      for (int i=0; i < ins_lens.length; i++) {
        int len_val;
        if (ins_lens[i] == 0) {
          len_val=Integer.MAX_VALUE;
        }
 else {
          len_val=Math.max(Math.abs(ins_lens[i]),1);
        }
        alts[i]=new FlexSeq(FlexSeq.Type.INS,len_val);
      }
      return new Variant(chr,pos,0,refs,alts,phase_val,is_phased,var_id,FILTER,ref_deleted,_rand);
    }
 else     if (end_loc > 0) {
      int ins_len=Math.max(Math.abs(end_loc - pos),1);
      alts=new FlexSeq[1];
      alts[0]=new FlexSeq(FlexSeq.Type.INS,ins_len);
      return new Variant(chr,pos,0,refs,alts,phase_val,is_phased,var_id,FILTER,ref_deleted,_rand);
    }
 else {
      log.error(""String_Node_Str"");
      log.error(line);
      log.error(""String_Node_Str"");
      return null;
    }
  }
 else   if (ALT.equals(""String_Node_Str"")) {
    int del_lens[]=getSVLen(INFO);
    int end_loc=getEndInfo(INFO);
    ref_deleted=REF;
    byte[] refs=new byte[0];
    pos++;
    if (del_lens.length > 0) {
      alts=new FlexSeq[del_lens.length];
      for (int i=0; i < del_lens.length; i++) {
        alts[i]=new FlexSeq(FlexSeq.Type.DEL,0);
      }
      return new Variant(chr,pos,Math.abs(del_lens[0]),refs,alts,phase_val,is_phased,var_id,FILTER,ref_deleted,_rand);
    }
 else     if (end_loc > 0) {
      int del_len=end_loc - pos + 1;
      alts=new FlexSeq[1];
      alts[0]=new FlexSeq(FlexSeq.Type.DEL,0);
      return new Variant(chr,pos,del_len,refs,alts,phase_val,is_phased,var_id,FILTER,ref_deleted,_rand);
    }
 else {
      log.error(""String_Node_Str"");
      log.error(line);
      log.error(""String_Node_Str"");
      return null;
    }
  }
 else   if (ALT.indexOf('<') >= 0) {
    log.warn(""String_Node_Str"" + line);
    return null;
  }
 else {
    String[] alts_str=ALT.split(""String_Node_Str"");
    int n=alts_str.length;
    alts=new FlexSeq[n];
    for (int i=0; i < n; i++) {
      byte[] temp=new byte[alts_str[i].length()];
      for (int j=0; j < alts_str[i].length(); j++) {
        temp[j]=(byte)alts_str[i].charAt(j);
      }
      alts[i]=new FlexSeq(temp);
    }
    for (int i=0; i < n; i++) {
      if (REF.length() == 1 && alts[i].length() == 1) {
      }
 else       if (REF.length() == 0 || alts[i].length() == 0) {
        log.warn(""String_Node_Str"");
        log.warn(line);
        return null;
      }
    }
    if (REF.length() > 0) {
      boolean same=true;
      for (int i=0; i < n; i++) {
        if (alts[i].length() == 0 || REF.charAt(0) != alts[i].charAt(0)) {
          same=false;
          break;
        }
      }
      if (same) {
        pos++;
        ref_deleted=String.valueOf(REF.charAt(0));
        REF=REF.substring(1);
        for (int i=0; i < n; i++) {
          alts[i]=new FlexSeq(alts[i].substring(1));
        }
      }
    }
    if (REF.length() > 0) {
      int ref_len=REF.length();
      int min_clip_len=Integer.MAX_VALUE;
      for (int i=0; i < n; i++) {
        int alt_len=alts[i].length();
        int clip_len=0;
        for (int j=0; j < alt_len; j++) {
          if (ref_len - j <= 0 || alt_len - j <= 0) {
            clip_len=j;
            break;
          }
          if (REF.charAt(ref_len - j - 1) != alts[i].charAt(alt_len - j - 1)) {
            clip_len=j;
            break;
          }
          clip_len=j + 1;
        }
        if (min_clip_len > clip_len) {
          min_clip_len=clip_len;
        }
      }
      if (min_clip_len > 0) {
        REF=REF.substring(0,ref_len - min_clip_len);
        for (int i=0; i < n; i++) {
          alts[i]=new FlexSeq(alts[i].substring(0,alts[i].length() - min_clip_len));
        }
      }
    }
    byte[] refs=new byte[REF.length()];
    for (int i=0; i < REF.length(); i++) {
      refs[i]=(byte)REF.charAt(i);
    }
    return new Variant(chr,pos,refs.length,refs,alts,phase_val,is_phased,var_id,FILTER,ref_deleted,_rand);
  }
}","/** 
 * takes a line from a VCF file, parse it, return a Variant object
 * @param line
 * @return
 */
public Variant process_line(String line){
  StringTokenizer toks=new StringTokenizer(line);
  if (line.startsWith(""String_Node_Str"")) {
    if (_id != null && line.startsWith(""String_Node_Str"")) {
      chrom_exists=true;
      int index=0;
      while (toks.hasMoreTokens()) {
        index++;
        String tok=toks.nextToken();
        if (tok.equals(_id))         _id_ind=index;
      }
    }
 else     if (_id == null) {
      _id_ind=10;
    }
    return null;
  }
  if (_id_ind < 0 && !chrom_exists) {
    _id_ind=10;
  }
 else   if (_id_ind < 0) {
    _id_ind=10;
    log.warn(""String_Node_Str"" + _id + ""String_Node_Str"");
  }
  int index=0, genotype_ind=-1, copynum_ind=-1;
  int pos=-1;
  ChrString chr=null;
  String REF=""String_Node_Str"", FILTER=""String_Node_Str"", ALT=""String_Node_Str"", var_id=""String_Node_Str"";
  String phase=""String_Node_Str"", copy_num=""String_Node_Str"", INFO=""String_Node_Str"", FORMAT;
  String[] sampleInfo;
  while (toks.hasMoreTokens()) {
    index++;
    if (index == 1) {
      chr=new ChrString(toks.nextToken());
    }
 else     if (index == 2)     pos=Integer.parseInt(toks.nextToken());
 else     if (index == 3)     var_id=toks.nextToken();
 else     if (index == 4)     REF=toks.nextToken();
 else     if (index == 5)     ALT=toks.nextToken();
 else     if (index == 7)     FILTER=toks.nextToken();
 else     if (index == 8)     INFO=toks.nextToken();
 else     if (index == 9) {
      FORMAT=toks.nextToken();
      genotype_ind=getFormatKeyIndex(FORMAT,""String_Node_Str"");
      copynum_ind=getFormatKeyIndex(FORMAT,""String_Node_Str"");
    }
 else     if (index == _id_ind) {
      sampleInfo=(toks.nextToken()).split(""String_Node_Str"");
      if (genotype_ind >= 0) {
        phase=sampleInfo[genotype_ind];
      }
      if (copynum_ind >= 0) {
        copy_num=sampleInfo[copynum_ind];
      }
      break;
    }
 else {
      toks.nextToken();
    }
  }
  if (chr == null) {
    log.warn(""String_Node_Str"" + line);
    return null;
  }
  if (_pass && !(FILTER.contains(""String_Node_Str"") || FILTER.equals(""String_Node_Str""))) {
    return null;
  }
  byte[] phase_val=new byte[2];
  boolean is_phased=splitGeno(phase,phase_val,chr);
  if (genotype_ind >= 0 && phase_val[0] == 0 && phase_val[1] == 0) {
  }
  byte[] copy_num_val=new byte[2];
  boolean is_cn_phased;
  if (copynum_ind >= 0) {
    is_cn_phased=splitGeno(copy_num,copy_num_val,chr);
    if (is_cn_phased != is_phased) {
      log.error(""String_Node_Str"");
      log.error(line);
      return null;
    }
  }
  REF=REF.toUpperCase();
  ALT=ALT.toUpperCase();
  String ref_deleted=""String_Node_Str"";
  FlexSeq alts[];
  if (ALT.indexOf('<') != -1) {
    String[] alts_str=ALT.split(""String_Node_Str"");
    int[] inv_lens=getSVLen(INFO);
    if (alts_str.length != inv_lens.length) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
    for (int i=0; i < alts_str.length; i++) {
      if (!alts_str[i].startsWith(""String_Node_Str"")) {
        throw new IllegalArgumentException(""String_Node_Str"");
      }
    }
  }
  if (ALT.startsWith(""String_Node_Str"")) {
    int inv_lens[]=getSVLen(INFO);
    int end_loc=getEndInfo(INFO);
    ref_deleted=REF;
    byte[] refs=new byte[0];
    pos++;
    if (inv_lens.length > 0) {
      alts=new FlexSeq[inv_lens.length];
      for (int i=0; i < inv_lens.length; i++) {
        int len_val=Math.max(Math.abs(inv_lens[i]),1);
        alts[i]=new FlexSeq(FlexSeq.Type.INV,len_val);
      }
      return new Variant(chr,pos,Math.abs(inv_lens[0]),refs,alts,phase_val,is_phased,var_id,FILTER,ref_deleted,_rand);
    }
 else     if (end_loc > 0) {
      int inv_len=Math.max(Math.abs(end_loc - pos + 1),1);
      alts=new FlexSeq[1];
      alts[0]=new FlexSeq(FlexSeq.Type.INV,inv_len);
      return new Variant(chr,pos,inv_len,refs,alts,phase_val,is_phased,var_id,FILTER,ref_deleted,_rand);
    }
 else {
      log.error(""String_Node_Str"");
      log.error(line);
      log.error(""String_Node_Str"");
      return null;
    }
  }
 else   if (ALT.startsWith(""String_Node_Str"") || ALT.startsWith(""String_Node_Str"")) {
    int dup_lens[]=getSVLen(INFO);
    int end_loc=getEndInfo(INFO);
    ref_deleted=REF;
    byte[] refs=new byte[0];
    pos++;
    if (dup_lens.length > 0) {
      alts=new FlexSeq[dup_lens.length];
      for (int i=0; i < dup_lens.length; i++) {
        int copy_val=1;
        for (int j=0; j < 2; j++) {
          if ((i + 1) == phase_val[j]) {
            if (copy_num_val[j] > 0) {
              copy_val=copy_num_val[j];
            }
          }
        }
        int len_val=Math.max(Math.abs(dup_lens[i]),1);
        alts[i]=new FlexSeq(FlexSeq.Type.DUP,len_val,copy_val);
      }
      return new Variant(chr,pos,Math.abs(dup_lens[0]),refs,alts,phase_val,is_phased,var_id,FILTER,ref_deleted,_rand);
    }
 else     if (end_loc > 0) {
      int dup_len=Math.max(Math.abs(end_loc - pos + 1),1);
      alts=new FlexSeq[1];
      alts[0]=new FlexSeq(FlexSeq.Type.DUP,dup_len,Math.max(copy_num_val[0],copy_num_val[1]));
      return new Variant(chr,pos,dup_len,refs,alts,phase_val,is_phased,var_id,FILTER,ref_deleted,_rand);
    }
 else {
      log.error(""String_Node_Str"");
      log.error(line);
      log.error(""String_Node_Str"");
      return null;
    }
  }
 else   if (ALT.startsWith(""String_Node_Str"")) {
    int ins_lens[]=getSVLen(INFO);
    int end_loc=getEndInfo(INFO);
    ref_deleted=REF;
    byte[] refs=new byte[0];
    pos++;
    if (ins_lens.length > 0) {
      alts=new FlexSeq[ins_lens.length];
      for (int i=0; i < ins_lens.length; i++) {
        int len_val;
        if (ins_lens[i] == 0) {
          len_val=Integer.MAX_VALUE;
        }
 else {
          len_val=Math.max(Math.abs(ins_lens[i]),1);
        }
        alts[i]=new FlexSeq(FlexSeq.Type.INS,len_val);
      }
      return new Variant(chr,pos,0,refs,alts,phase_val,is_phased,var_id,FILTER,ref_deleted,_rand);
    }
 else     if (end_loc > 0) {
      int ins_len=Math.max(Math.abs(end_loc - pos),1);
      alts=new FlexSeq[1];
      alts[0]=new FlexSeq(FlexSeq.Type.INS,ins_len);
      return new Variant(chr,pos,0,refs,alts,phase_val,is_phased,var_id,FILTER,ref_deleted,_rand);
    }
 else {
      log.error(""String_Node_Str"");
      log.error(line);
      log.error(""String_Node_Str"");
      return null;
    }
  }
 else   if (ALT.startsWith(""String_Node_Str"")) {
    int del_lens[]=getSVLen(INFO);
    int end_loc=getEndInfo(INFO);
    ref_deleted=REF;
    byte[] refs=new byte[0];
    pos++;
    if (del_lens.length > 0) {
      alts=new FlexSeq[del_lens.length];
      for (int i=0; i < del_lens.length; i++) {
        alts[i]=new FlexSeq(FlexSeq.Type.DEL,0);
      }
      return new Variant(chr,pos,Math.abs(del_lens[0]),refs,alts,phase_val,is_phased,var_id,FILTER,ref_deleted,_rand);
    }
 else     if (end_loc > 0) {
      int del_len=end_loc - pos + 1;
      alts=new FlexSeq[1];
      alts[0]=new FlexSeq(FlexSeq.Type.DEL,0);
      return new Variant(chr,pos,del_len,refs,alts,phase_val,is_phased,var_id,FILTER,ref_deleted,_rand);
    }
 else {
      log.error(""String_Node_Str"");
      log.error(line);
      log.error(""String_Node_Str"");
      return null;
    }
  }
 else   if (ALT.indexOf('<') >= 0) {
    log.warn(""String_Node_Str"" + line);
    return null;
  }
 else {
    String[] alts_str=ALT.split(""String_Node_Str"");
    int n=alts_str.length;
    alts=new FlexSeq[n];
    for (int i=0; i < n; i++) {
      byte[] temp=new byte[alts_str[i].length()];
      for (int j=0; j < alts_str[i].length(); j++) {
        temp[j]=(byte)alts_str[i].charAt(j);
      }
      alts[i]=new FlexSeq(temp);
    }
    for (int i=0; i < n; i++) {
      if (REF.length() == 1 && alts[i].length() == 1) {
      }
 else       if (REF.length() == 0 || alts[i].length() == 0) {
        log.warn(""String_Node_Str"");
        log.warn(line);
        return null;
      }
    }
    if (REF.length() > 0) {
      boolean same=true;
      for (int i=0; i < n; i++) {
        if (alts[i].length() == 0 || REF.charAt(0) != alts[i].charAt(0)) {
          same=false;
          break;
        }
      }
      if (same) {
        pos++;
        ref_deleted=String.valueOf(REF.charAt(0));
        REF=REF.substring(1);
        for (int i=0; i < n; i++) {
          alts[i]=new FlexSeq(alts[i].substring(1));
        }
      }
    }
    if (REF.length() > 0) {
      int ref_len=REF.length();
      int min_clip_len=Integer.MAX_VALUE;
      for (int i=0; i < n; i++) {
        int alt_len=alts[i].length();
        int clip_len=0;
        for (int j=0; j < alt_len; j++) {
          if (ref_len - j <= 0 || alt_len - j <= 0) {
            clip_len=j;
            break;
          }
          if (REF.charAt(ref_len - j - 1) != alts[i].charAt(alt_len - j - 1)) {
            clip_len=j;
            break;
          }
          clip_len=j + 1;
        }
        if (min_clip_len > clip_len) {
          min_clip_len=clip_len;
        }
      }
      if (min_clip_len > 0) {
        REF=REF.substring(0,ref_len - min_clip_len);
        for (int i=0; i < n; i++) {
          alts[i]=new FlexSeq(alts[i].substring(0,alts[i].length() - min_clip_len));
        }
      }
    }
    byte[] refs=new byte[REF.length()];
    for (int i=0; i < REF.length(); i++) {
      refs[i]=(byte)REF.charAt(i);
    }
    return new Variant(chr,pos,refs.length,refs,alts,phase_val,is_phased,var_id,FILTER,ref_deleted,_rand);
  }
}",0.973347029247986
80637,"StatsRatioRecord(){
  bin_counts=new RatioRecord[bin_breaks.length + 1];
  if (bin_breaks.length > 0) {
    bin_counts[0]=new RatioRecord(1,bin_breaks[0]);
  }
 else {
    bin_counts[0]=new RatioRecord(1,-1);
  }
  for (int i=1; i < bin_counts.length; i++) {
    if (i < bin_breaks.length) {
      bin_counts[i]=new RatioRecord(bin_breaks[i - 1] + 1,bin_breaks[i]);
    }
 else {
      bin_counts[i]=new RatioRecord(bin_breaks[i - 1] + 1,-1);
    }
  }
  sum_count=new RatioRecord();
}","StatsRatioRecord(){
  bin_counts=new RatioRecord[bin_breaks.length + 1];
  if (bin_breaks.length > 0) {
    bin_counts[0]=new RatioRecord(1,bin_breaks[0]);
  }
 else {
    bin_counts[0]=new RatioRecord(1,-1);
  }
  for (int i=1; i < bin_counts.length; i++) {
    if (i < bin_breaks.length) {
      bin_counts[i]=new RatioRecord(bin_breaks[i - 1] + 1,bin_breaks[i]);
    }
 else {
      bin_counts[i]=new RatioRecord(bin_breaks[i - 1] + 1,-1);
    }
  }
  sum_count=new RatioRecord();
  svSumCount=new RatioRecord();
}",0.9680638722554892
80638,"public Variant parseLine(){
  String line=_line;
  readLine();
  if (line == null || line.length() == 0) {
    System.err.println(""String_Node_Str"");
    return null;
  }
  StringTokenizer toks=new StringTokenizer(line);
  if (line.startsWith(""String_Node_Str"")) {
    if (_id != null && line.startsWith(""String_Node_Str"")) {
      chrom_exists=true;
      int index=0;
      while (toks.hasMoreTokens()) {
        index++;
        String tok=toks.nextToken();
        if (tok.equals(_id))         _id_ind=index;
      }
    }
 else     if (_id == null) {
      _id_ind=10;
    }
    return null;
  }
  if (_id_ind < 0 && !chrom_exists) {
    _id_ind=10;
  }
 else   if (_id_ind < 0) {
    _id_ind=10;
    System.err.println(""String_Node_Str"" + _id + ""String_Node_Str"");
  }
  int index=0, genotype_ind=-1, copynum_ind=-1;
  int chr=-1, pos=-1;
  String chr_name=""String_Node_Str"", REF=""String_Node_Str"", FILTER=""String_Node_Str"", ALT=""String_Node_Str"", var_id=""String_Node_Str"";
  String phase=""String_Node_Str"", copy_num=""String_Node_Str"", INFO=""String_Node_Str"", FORMAT=""String_Node_Str"";
  String[] sampleInfo={};
  while (toks.hasMoreTokens()) {
    index++;
    if (index == 1) {
      chr_name=stripChr(toks.nextToken());
      chr=getChromIndex(chr_name);
    }
 else     if (index == 2)     pos=Integer.parseInt(toks.nextToken());
 else     if (index == 3)     var_id=toks.nextToken();
 else     if (index == 4)     REF=toks.nextToken();
 else     if (index == 5)     ALT=toks.nextToken();
 else     if (index == 7)     FILTER=toks.nextToken();
 else     if (index == 8)     INFO=toks.nextToken();
 else     if (index == 9) {
      FORMAT=toks.nextToken();
      genotype_ind=getFormatKeyIndex(FORMAT,""String_Node_Str"");
      copynum_ind=getFormatKeyIndex(FORMAT,""String_Node_Str"");
    }
 else     if (index == _id_ind) {
      sampleInfo=(toks.nextToken()).split(""String_Node_Str"");
      if (genotype_ind >= 0) {
        phase=sampleInfo[genotype_ind];
      }
      if (copynum_ind >= 0) {
        copy_num=sampleInfo[copynum_ind];
      }
      break;
    }
 else {
      toks.nextToken();
    }
  }
  if (chr < 0) {
    System.err.println(""String_Node_Str"" + line);
    return null;
  }
  if (_pass && FILTER.indexOf(""String_Node_Str"") < 0) {
    System.err.println(""String_Node_Str"" + line);
    return null;
  }
  byte[] phase_val=new byte[2];
  boolean is_phased=splitGeno(phase,phase_val,chr);
  if (genotype_ind >= 0 && phase_val[0] == 0 && phase_val[1] == 0) {
  }
  if (phase_val[0] < 0 || phase_val[1] < 0) {
    phase_val[0]=1;
    phase_val[1]=1;
  }
  byte[] copy_num_val=new byte[2];
  boolean is_cn_phased=false;
  if (copynum_ind >= 0) {
    is_cn_phased=splitGeno(copy_num,copy_num_val,chr);
    if (is_cn_phased != is_phased) {
      System.err.println(""String_Node_Str"");
      System.err.println(line);
      return null;
    }
  }
  REF=REF.toUpperCase();
  ALT=ALT.toUpperCase();
  String ref_deleted=""String_Node_Str"";
  FlexSeq alts[];
  if (ALT.equals(""String_Node_Str"")) {
    int inv_lens[]=getSVLen(INFO);
    int end_loc=getEndInfo(INFO);
    if (inv_lens.length > 0) {
      alts=new FlexSeq[inv_lens.length];
      for (int i=0; i < inv_lens.length; i++) {
        int len_val=Math.max(Math.abs(inv_lens[i]),1);
        alts[i]=new FlexSeq(FlexSeq.Type.INV,len_val);
      }
      ref_deleted=REF;
      byte[] refs=new byte[0];
      return new Variant(chr_name,chr,pos,Math.abs(inv_lens[0]),refs,alts,phase_val,is_phased,var_id,FILTER,ref_deleted);
    }
 else     if (end_loc > 0) {
      int inv_len=Math.max(Math.abs(end_loc - pos + 1),1);
      alts=new FlexSeq[1];
      alts[0]=new FlexSeq(FlexSeq.Type.INV,inv_len);
      ref_deleted=REF;
      byte[] refs=new byte[0];
      return new Variant(chr_name,chr,pos,inv_len,refs,alts,phase_val,is_phased,var_id,FILTER,ref_deleted);
    }
 else {
      System.err.println(""String_Node_Str"");
      System.err.println(line);
      System.err.println(""String_Node_Str"");
      return null;
    }
  }
 else   if (ALT.equals(""String_Node_Str"") || ALT.equals(""String_Node_Str"")) {
    int dup_lens[]=getSVLen(INFO);
    int end_loc=getEndInfo(INFO);
    if (dup_lens.length > 0) {
      alts=new FlexSeq[dup_lens.length];
      for (int i=0; i < dup_lens.length; i++) {
        int copy_val=1;
        for (int j=0; j < 2; j++) {
          if ((i + 1) == phase_val[j]) {
            if (copy_num_val[j] > 0) {
              copy_val=copy_num_val[j];
            }
          }
        }
        int len_val=Math.max(Math.abs(dup_lens[i]),1);
        alts[i]=new FlexSeq(FlexSeq.Type.DUP,len_val,copy_val);
      }
      ref_deleted=REF;
      byte[] refs=new byte[0];
      return new Variant(chr_name,chr,pos,Math.abs(dup_lens[0]),refs,alts,phase_val,is_phased,var_id,FILTER,ref_deleted);
    }
 else     if (end_loc > 0) {
      int dup_len=Math.max(Math.abs(end_loc - pos + 1),1);
      alts=new FlexSeq[1];
      alts[0]=new FlexSeq(FlexSeq.Type.DUP,dup_len,Math.max(copy_num_val[0],copy_num_val[1]));
      ref_deleted=REF;
      byte[] refs=new byte[0];
      return new Variant(chr_name,chr,pos,dup_len,refs,alts,phase_val,is_phased,var_id,FILTER,ref_deleted);
    }
 else {
      System.err.println(""String_Node_Str"");
      System.err.println(line);
      System.err.println(""String_Node_Str"");
      return null;
    }
  }
 else   if (ALT.equals(""String_Node_Str"")) {
    int ins_lens[]=getSVLen(INFO);
    int end_loc=getEndInfo(INFO);
    if (ins_lens.length > 0) {
      alts=new FlexSeq[ins_lens.length];
      for (int i=0; i < ins_lens.length; i++) {
        int len_val=Math.max(Math.abs(ins_lens[i]),1);
        alts[i]=new FlexSeq(FlexSeq.Type.INS,len_val);
      }
      ref_deleted=REF;
      byte[] refs=new byte[0];
      return new Variant(chr_name,chr,pos + 1,0,refs,alts,phase_val,is_phased,var_id,FILTER,ref_deleted);
    }
 else     if (end_loc > 0) {
      int ins_len=Math.max(Math.abs(end_loc - pos + 1),1);
      alts=new FlexSeq[1];
      alts[0]=new FlexSeq(FlexSeq.Type.INS,ins_len);
      ref_deleted=REF;
      byte[] refs=new byte[0];
      return new Variant(chr_name,chr,pos + 1,0,refs,alts,phase_val,is_phased,var_id,FILTER,ref_deleted);
    }
 else {
      System.err.println(""String_Node_Str"");
      System.err.println(line);
      System.err.println(""String_Node_Str"");
      return null;
    }
  }
 else   if (ALT.equals(""String_Node_Str"")) {
    int del_lens[]=getSVLen(INFO);
    int end_loc=getEndInfo(INFO);
    if (del_lens.length > 0) {
      alts=new FlexSeq[del_lens.length];
      for (int i=0; i < del_lens.length; i++) {
        alts[i]=new FlexSeq(FlexSeq.Type.DEL,0);
      }
      ref_deleted=REF;
      byte[] refs=new byte[0];
      return new Variant(chr_name,chr,pos,Math.abs(del_lens[0]),refs,alts,phase_val,is_phased,var_id,FILTER,ref_deleted);
    }
 else     if (end_loc > 0) {
      int del_len=end_loc - pos + 1;
      alts=new FlexSeq[1];
      alts[0]=new FlexSeq(FlexSeq.Type.DEL,0);
      ref_deleted=REF;
      byte[] refs=new byte[0];
      return new Variant(chr_name,chr,pos,del_len,refs,alts,phase_val,is_phased,var_id,FILTER,ref_deleted);
    }
 else {
      System.err.println(""String_Node_Str"");
      System.err.println(line);
      System.err.println(""String_Node_Str"");
      return null;
    }
  }
 else   if (ALT.indexOf('<') >= 0) {
    System.err.println(""String_Node_Str"" + line);
    return null;
  }
 else {
    String[] alts_str=ALT.split(""String_Node_Str"");
    int n=alts_str.length;
    alts=new FlexSeq[n];
    for (int i=0; i < n; i++) {
      byte[] temp=new byte[alts_str[i].length()];
      for (int j=0; j < alts_str[i].length(); j++) {
        temp[j]=(byte)alts_str[i].charAt(j);
      }
      alts[i]=new FlexSeq(temp);
    }
    for (int i=0; i < n; i++)     if (REF.length() == 1 && alts[i].length() == 1) {
    }
 else     if (REF.length() == 0 || alts[i].length() == 0) {
      System.err.println(""String_Node_Str"");
      System.err.println(line);
      return null;
    }
    if (REF.length() > 0) {
      boolean same=true;
      for (int i=0; i < n; i++)       if (alts[i].length() == 0 || REF.charAt(0) != alts[i].charAt(0)) {
        same=false;
        break;
      }
      if (same) {
        pos++;
        ref_deleted=String.valueOf(REF.charAt(0));
        REF=REF.substring(1);
        for (int i=0; i < n; i++) {
          alts[i]=new FlexSeq(alts[i].substring(1));
        }
      }
    }
    if (REF.length() > 0) {
      boolean same=true;
      int indREF=REF.length() - 1;
      for (int i=0; i < n; i++) {
        int len=alts[i].length();
        if (len == 0 || REF.charAt(indREF) != alts[i].charAt(len - 1)) {
          same=false;
          break;
        }
      }
      if (same) {
        REF=REF.substring(0,indREF);
        for (int i=0; i < n; i++) {
          alts[i]=new FlexSeq(alts[i].substring(0,alts[i].length() - 1));
        }
      }
    }
    byte[] refs=new byte[REF.length()];
    for (int i=0; i < REF.length(); i++) {
      refs[i]=(byte)REF.charAt(i);
    }
    return new Variant(chr_name,chr,pos,refs.length,refs,alts,phase_val,is_phased,var_id,FILTER,ref_deleted);
  }
}","public Variant parseLine(){
  String line=_line;
  readLine();
  if (line == null || line.length() == 0) {
    System.err.println(""String_Node_Str"");
    return null;
  }
  StringTokenizer toks=new StringTokenizer(line);
  if (line.startsWith(""String_Node_Str"")) {
    if (_id != null && line.startsWith(""String_Node_Str"")) {
      chrom_exists=true;
      int index=0;
      while (toks.hasMoreTokens()) {
        index++;
        String tok=toks.nextToken();
        if (tok.equals(_id))         _id_ind=index;
      }
    }
 else     if (_id == null) {
      _id_ind=10;
    }
    return null;
  }
  if (_id_ind < 0 && !chrom_exists) {
    _id_ind=10;
  }
 else   if (_id_ind < 0) {
    _id_ind=10;
    System.err.println(""String_Node_Str"" + _id + ""String_Node_Str"");
  }
  int index=0, genotype_ind=-1, copynum_ind=-1;
  int chr=-1, pos=-1;
  String chr_name=""String_Node_Str"", REF=""String_Node_Str"", FILTER=""String_Node_Str"", ALT=""String_Node_Str"", var_id=""String_Node_Str"";
  String phase=""String_Node_Str"", copy_num=""String_Node_Str"", INFO=""String_Node_Str"", FORMAT=""String_Node_Str"";
  String[] sampleInfo={};
  while (toks.hasMoreTokens()) {
    index++;
    if (index == 1) {
      chr_name=stripChr(toks.nextToken());
      chr=getChromIndex(chr_name);
    }
 else     if (index == 2)     pos=Integer.parseInt(toks.nextToken());
 else     if (index == 3)     var_id=toks.nextToken();
 else     if (index == 4)     REF=toks.nextToken();
 else     if (index == 5)     ALT=toks.nextToken();
 else     if (index == 7)     FILTER=toks.nextToken();
 else     if (index == 8)     INFO=toks.nextToken();
 else     if (index == 9) {
      FORMAT=toks.nextToken();
      genotype_ind=getFormatKeyIndex(FORMAT,""String_Node_Str"");
      copynum_ind=getFormatKeyIndex(FORMAT,""String_Node_Str"");
    }
 else     if (index == _id_ind) {
      sampleInfo=(toks.nextToken()).split(""String_Node_Str"");
      if (genotype_ind >= 0) {
        phase=sampleInfo[genotype_ind];
      }
      if (copynum_ind >= 0) {
        copy_num=sampleInfo[copynum_ind];
      }
      break;
    }
 else {
      toks.nextToken();
    }
  }
  if (chr < 0) {
    System.err.println(""String_Node_Str"" + line);
    return null;
  }
  if (_pass && FILTER.indexOf(""String_Node_Str"") < 0) {
    System.err.println(""String_Node_Str"" + line);
    return null;
  }
  byte[] phase_val=new byte[2];
  boolean is_phased=splitGeno(phase,phase_val,chr);
  if (genotype_ind >= 0 && phase_val[0] == 0 && phase_val[1] == 0) {
  }
  if (phase_val[0] < 0 || phase_val[1] < 0) {
    phase_val[0]=1;
    phase_val[1]=1;
  }
  byte[] copy_num_val=new byte[2];
  boolean is_cn_phased=false;
  if (copynum_ind >= 0) {
    is_cn_phased=splitGeno(copy_num,copy_num_val,chr);
    if (is_cn_phased != is_phased) {
      System.err.println(""String_Node_Str"");
      System.err.println(line);
      return null;
    }
  }
  REF=REF.toUpperCase();
  ALT=ALT.toUpperCase();
  String ref_deleted=""String_Node_Str"";
  FlexSeq alts[];
  if (ALT.equals(""String_Node_Str"")) {
    int inv_lens[]=getSVLen(INFO);
    int end_loc=getEndInfo(INFO);
    ref_deleted=REF;
    byte[] refs=new byte[0];
    pos++;
    if (inv_lens.length > 0) {
      alts=new FlexSeq[inv_lens.length];
      for (int i=0; i < inv_lens.length; i++) {
        int len_val=Math.max(Math.abs(inv_lens[i]),1);
        alts[i]=new FlexSeq(FlexSeq.Type.INV,len_val);
      }
      return new Variant(chr_name,chr,pos,Math.abs(inv_lens[0]),refs,alts,phase_val,is_phased,var_id,FILTER,ref_deleted);
    }
 else     if (end_loc > 0) {
      int inv_len=Math.max(Math.abs(end_loc - pos + 1),1);
      alts=new FlexSeq[1];
      alts[0]=new FlexSeq(FlexSeq.Type.INV,inv_len);
      return new Variant(chr_name,chr,pos,inv_len,refs,alts,phase_val,is_phased,var_id,FILTER,ref_deleted);
    }
 else {
      System.err.println(""String_Node_Str"");
      System.err.println(line);
      System.err.println(""String_Node_Str"");
      return null;
    }
  }
 else   if (ALT.equals(""String_Node_Str"") || ALT.equals(""String_Node_Str"")) {
    int dup_lens[]=getSVLen(INFO);
    int end_loc=getEndInfo(INFO);
    ref_deleted=REF;
    byte[] refs=new byte[0];
    pos++;
    if (dup_lens.length > 0) {
      alts=new FlexSeq[dup_lens.length];
      for (int i=0; i < dup_lens.length; i++) {
        int copy_val=1;
        for (int j=0; j < 2; j++) {
          if ((i + 1) == phase_val[j]) {
            if (copy_num_val[j] > 0) {
              copy_val=copy_num_val[j];
            }
          }
        }
        int len_val=Math.max(Math.abs(dup_lens[i]),1);
        alts[i]=new FlexSeq(FlexSeq.Type.DUP,len_val,copy_val);
      }
      return new Variant(chr_name,chr,pos,Math.abs(dup_lens[0]),refs,alts,phase_val,is_phased,var_id,FILTER,ref_deleted);
    }
 else     if (end_loc > 0) {
      int dup_len=Math.max(Math.abs(end_loc - pos + 1),1);
      alts=new FlexSeq[1];
      alts[0]=new FlexSeq(FlexSeq.Type.DUP,dup_len,Math.max(copy_num_val[0],copy_num_val[1]));
      return new Variant(chr_name,chr,pos,dup_len,refs,alts,phase_val,is_phased,var_id,FILTER,ref_deleted);
    }
 else {
      System.err.println(""String_Node_Str"");
      System.err.println(line);
      System.err.println(""String_Node_Str"");
      return null;
    }
  }
 else   if (ALT.equals(""String_Node_Str"")) {
    int ins_lens[]=getSVLen(INFO);
    int end_loc=getEndInfo(INFO);
    ref_deleted=REF;
    byte[] refs=new byte[0];
    pos++;
    if (ins_lens.length > 0) {
      alts=new FlexSeq[ins_lens.length];
      for (int i=0; i < ins_lens.length; i++) {
        int len_val=Math.max(Math.abs(ins_lens[i]),1);
        alts[i]=new FlexSeq(FlexSeq.Type.INS,len_val);
      }
      return new Variant(chr_name,chr,pos,0,refs,alts,phase_val,is_phased,var_id,FILTER,ref_deleted);
    }
 else     if (end_loc > 0) {
      int ins_len=Math.max(Math.abs(end_loc - pos),1);
      alts=new FlexSeq[1];
      alts[0]=new FlexSeq(FlexSeq.Type.INS,ins_len);
      return new Variant(chr_name,chr,pos,0,refs,alts,phase_val,is_phased,var_id,FILTER,ref_deleted);
    }
 else {
      System.err.println(""String_Node_Str"");
      System.err.println(line);
      System.err.println(""String_Node_Str"");
      return null;
    }
  }
 else   if (ALT.equals(""String_Node_Str"")) {
    int del_lens[]=getSVLen(INFO);
    int end_loc=getEndInfo(INFO);
    ref_deleted=REF;
    byte[] refs=new byte[0];
    pos++;
    if (del_lens.length > 0) {
      alts=new FlexSeq[del_lens.length];
      for (int i=0; i < del_lens.length; i++) {
        alts[i]=new FlexSeq(FlexSeq.Type.DEL,0);
      }
      return new Variant(chr_name,chr,pos,Math.abs(del_lens[0]),refs,alts,phase_val,is_phased,var_id,FILTER,ref_deleted);
    }
 else     if (end_loc > 0) {
      int del_len=end_loc - pos + 1;
      alts=new FlexSeq[1];
      alts[0]=new FlexSeq(FlexSeq.Type.DEL,0);
      return new Variant(chr_name,chr,pos,del_len,refs,alts,phase_val,is_phased,var_id,FILTER,ref_deleted);
    }
 else {
      System.err.println(""String_Node_Str"");
      System.err.println(line);
      System.err.println(""String_Node_Str"");
      return null;
    }
  }
 else   if (ALT.indexOf('<') >= 0) {
    System.err.println(""String_Node_Str"" + line);
    return null;
  }
 else {
    String[] alts_str=ALT.split(""String_Node_Str"");
    int n=alts_str.length;
    alts=new FlexSeq[n];
    for (int i=0; i < n; i++) {
      byte[] temp=new byte[alts_str[i].length()];
      for (int j=0; j < alts_str[i].length(); j++) {
        temp[j]=(byte)alts_str[i].charAt(j);
      }
      alts[i]=new FlexSeq(temp);
    }
    for (int i=0; i < n; i++) {
      if (REF.length() == 1 && alts[i].length() == 1) {
      }
 else       if (REF.length() == 0 || alts[i].length() == 0) {
        System.err.println(""String_Node_Str"");
        System.err.println(line);
        return null;
      }
    }
    if (REF.length() > 0) {
      boolean same=true;
      for (int i=0; i < n; i++)       if (alts[i].length() == 0 || REF.charAt(0) != alts[i].charAt(0)) {
        same=false;
        break;
      }
      if (same) {
        pos++;
        ref_deleted=String.valueOf(REF.charAt(0));
        REF=REF.substring(1);
        for (int i=0; i < n; i++) {
          alts[i]=new FlexSeq(alts[i].substring(1));
        }
      }
    }
    if (REF.length() > 0) {
      boolean same=true;
      int indREF=REF.length() - 1;
      for (int i=0; i < n; i++) {
        int len=alts[i].length();
        if (len == 0 || REF.charAt(indREF) != alts[i].charAt(len - 1)) {
          same=false;
          break;
        }
      }
      if (same) {
        REF=REF.substring(0,indREF);
        for (int i=0; i < n; i++) {
          alts[i]=new FlexSeq(alts[i].substring(0,alts[i].length() - 1));
        }
      }
    }
    byte[] refs=new byte[REF.length()];
    for (int i=0; i < REF.length(); i++) {
      refs[i]=(byte)REF.charAt(i);
    }
    return new Variant(chr_name,chr,pos,refs.length,refs,alts,phase_val,is_phased,var_id,FILTER,ref_deleted);
  }
}",0.939306678480452
80639,"@Override public boolean canEvaluate(Template template){
  if (!template.getContextTypeId().equals(JavaStatementPostfixContext.CONTEXT_TYPE_ID))   return false;
  if (fForceEvaluation)   return true;
  if (currentNode == null)   return false;
  if (template.getName().toLowerCase().startsWith(getPrefixKey().toLowerCase()) == false) {
    return false;
  }
  String regex=(""String_Node_Str"");
  Pattern pattern=Pattern.compile(regex);
  Matcher matcher=pattern.matcher(template.getPattern());
  boolean result=true;
  while (matcher.find()) {
    String[] types=matcher.group(2).split(""String_Node_Str"");
    for (    String s : types) {
      result=false;
      if (this.isNodeResolvingTo(currentNode,s.trim()) == true) {
        return true;
      }
    }
  }
  return result;
}","@Override public boolean canEvaluate(Template template){
  if (!template.getContextTypeId().equals(JavaStatementPostfixContext.CONTEXT_TYPE_ID))   return false;
  if (fForceEvaluation)   return true;
  if (selectedNode == null)   return false;
  if (template.getName().toLowerCase().startsWith(getPrefixKey().toLowerCase()) == false) {
    return false;
  }
  String regex=(""String_Node_Str"");
  Pattern pattern=Pattern.compile(regex);
  Matcher matcher=pattern.matcher(template.getPattern());
  boolean result=true;
  while (matcher.find()) {
    String[] types=matcher.group(2).split(""String_Node_Str"");
    for (    String s : types) {
      result=false;
      if (this.isNodeResolvingTo(selectedNode,s.trim()) == true) {
        return true;
      }
    }
  }
  return result;
}",0.9808184143222506
80640,"public JavaStatementPostfixContext(JavaStatementPostfixContextType type,IDocument document,int offset,int length,ICompilationUnit compilationUnit,ASTNode currentNode,ASTNode parentNode){
  super(type,document,offset,length,compilationUnit);
  this.currentNode=currentNode;
  this.parentNode=parentNode;
}","public JavaStatementPostfixContext(JavaStatementPostfixContextType type,IDocument document,int offset,int length,ICompilationUnit compilationUnit,ASTNode currentNode,ASTNode parentNode){
  super(type,document,offset,length,compilationUnit);
  this.nodeRegions=new HashMap<>();
  this.currentCompletionNode=currentNode;
  nodeRegions.put(currentNode,calculateNodeRegion(currentNode));
  this.currentCompletionNodeParent=parentNode;
  nodeRegions.put(parentNode,calculateNodeRegion(parentNode));
  this.selectedNode=currentNode;
}",0.6586538461538461
80641,"/** 
 * Returns the current prefix of the key which was typed in. <br/> Examples: <code> <br/> new Object().		=> getPrefixKey() returns """" new Object().a		=> getPrefixKey() returns ""a"" new object().asdf	=> getPrefixKey() returns ""asdf""
 * @return an empty string or a string which represents the prefix of the key which was typed in
 */
protected String getPrefixKey(){
  IDocument document=getDocument();
  int start=getCompletionOffset();
  int end=getEnd();
  try {
    String temp=document.get(start,1);
    while (!""String_Node_Str"".equals(temp)) {
      temp=document.get(--start,1);
    }
    return document.get(start + 1,end - start - 1);
  }
 catch (  BadLocationException e) {
  }
  return ""String_Node_Str"";
}","/** 
 * Returns the current prefix of the key which was typed in. <br/> Examples: <code> <br/> new Object().		=> getPrefixKey() returns """" new Object().a		=> getPrefixKey() returns ""a"" new object().asdf	=> getPrefixKey() returns ""asdf""
 * @return an empty string or a string which represents the prefix of the key which was typed in
 */
protected String getPrefixKey(){
  IDocument document=getDocument();
  int start=getCompletionOffset();
  int end=getCompletionOffset();
  try {
    String temp=document.get(start,1);
    while (!""String_Node_Str"".equals(temp)) {
      temp=document.get(--start,1);
    }
    return document.get(start + 1,end - start - 1);
  }
 catch (  BadLocationException e) {
  }
  return ""String_Node_Str"";
}",0.9869415807560138
80642,"/** 
 * Returns the   {@link Region} which represents the source region of the affected statement.
 * @return
 */
public Region getAffectedSourceRegion(){
  int start=getNodeBegin(currentNode);
  return new Region(start,(getCompletionOffset() - getPrefixKey().length()) - start - 1);
}","/** 
 * Returns the   {@link Region} which represents the source region of the affected statement.
 * @return
 */
public Region getAffectedSourceRegion(){
  return new Region(getCompletionOffset() - getPrefixKey().length() - nodeRegions.get(selectedNode).getLength()- 1,nodeRegions.get(selectedNode).getLength());
}",0.7733333333333333
80643,"/** 
 * Returns the fully qualified name the node of the current code completion invocation resolves to.
 * @return a fully qualified type signature or the name of the base type.
 */
public String getInnerExpressionTypeSignature(){
  return resolveNodeToTypeString(currentNode);
}","/** 
 * Returns the fully qualified name the node of the current code completion invocation resolves to.
 * @return a fully qualified type signature or the name of the base type.
 */
public String getInnerExpressionTypeSignature(){
  return resolveNodeToTypeString(selectedNode);
}",0.9732620320855616
80644,"/** 
 * Parse and verify CPIM ( https://tools.ietf.org/html/rfc3860 ). The decrypted content of a message is in CPIM format.
 */
private static MessageContent parseCPIMOrNull(String cpim,String myUID,Optional<String> senderKeyUID,EnumSet<Coder.Error> allErrors){
  CPIMMessage cpimMessage;
  try {
    cpimMessage=CPIMMessage.parse(cpim);
  }
 catch (  ParseException ex) {
    LOGGER.log(Level.WARNING,""String_Node_Str"",ex);
    allErrors.add(Coder.Error.INVALID_DATA);
    return null;
  }
  String mime=cpimMessage.getMime();
  if (!Arrays.stream(cpimMessage.getTo()).anyMatch(s -> s.contains(myUID))) {
    LOGGER.warning(""String_Node_Str"");
    allErrors.add(Coder.Error.INVALID_RECIPIENT);
  }
  if (senderKeyUID.isPresent() && !senderKeyUID.get().equals(cpimMessage.getFrom())) {
    LOGGER.warning(""String_Node_Str"");
    allErrors.add(Coder.Error.INVALID_SENDER);
  }
  String content=cpimMessage.getBody().toString();
  MessageContent decryptedContent;
  if (XMPPParserUtils.XML_XMPP_TYPE.equalsIgnoreCase(mime)) {
    Message parsedMessage;
    try {
      parsedMessage=XMPPParserUtils.parseMessageStanza(content);
    }
 catch (    Exception ex) {
      LOGGER.log(Level.WARNING,""String_Node_Str"",ex);
      allErrors.add(Coder.Error.INVALID_DATA);
      return null;
    }
    LOGGER.config(""String_Node_Str"" + parsedMessage.toXML());
    decryptedContent=ClientUtils.parseMessageContent(parsedMessage,true);
  }
 else {
    decryptedContent=MessageContent.plainText(content);
  }
  return decryptedContent;
}","/** 
 * Parse and verify CPIM ( https://tools.ietf.org/html/rfc3860 ). The decrypted content of a message is in CPIM format.
 */
private static MessageContent parseCPIMOrNull(String cpim,String myUID,Optional<String> senderKeyUID,EnumSet<Coder.Error> allErrors){
  CPIMMessage cpimMessage;
  try {
    cpimMessage=CPIMMessage.parse(cpim);
  }
 catch (  ParseException ex) {
    LOGGER.log(Level.WARNING,""String_Node_Str"",ex);
    allErrors.add(Coder.Error.INVALID_DATA);
    return null;
  }
  String mime=cpimMessage.getMime();
  if (Arrays.stream(cpimMessage.getTo()).noneMatch(s -> s.contains(myUID))) {
    LOGGER.warning(""String_Node_Str"");
    allErrors.add(Coder.Error.INVALID_RECIPIENT);
  }
  if (senderKeyUID.isPresent() && !senderKeyUID.get().equals(cpimMessage.getFrom())) {
    LOGGER.warning(""String_Node_Str"");
    allErrors.add(Coder.Error.INVALID_SENDER);
  }
  String content=cpimMessage.getBody().toString();
  MessageContent decryptedContent;
  if (XMPPParserUtils.XML_XMPP_TYPE.equalsIgnoreCase(mime)) {
    Message parsedMessage;
    try {
      parsedMessage=XMPPParserUtils.parseMessageStanza(content);
    }
 catch (    Exception ex) {
      LOGGER.log(Level.WARNING,""String_Node_Str"",ex);
      allErrors.add(Coder.Error.INVALID_DATA);
      return null;
    }
    LOGGER.config(""String_Node_Str"" + parsedMessage.toXML());
    decryptedContent=ClientUtils.parseMessageContent(parsedMessage,true);
  }
 else {
    decryptedContent=MessageContent.plainText(content);
  }
  return decryptedContent;
}",0.9973736047275116
80645,"public SubjectPGPPublicKeyInfo(byte[] publicKey){
  keyData=new DERBitString(publicKey);
}","SubjectPGPPublicKeyInfo(byte[] publicKey){
  keyData=new DERBitString(publicKey);
}",0.9595375722543352
80646,"@Override public int hashCode(){
  return Objects.hash(mTransmission);
}","@Override public int hashCode(){
  int hash=this.abstractHashCode();
  hash=67 * hash + Objects.hash(mTransmission);
  return hash;
}",0.6634146341463415
80647,"protected void changed(boolean repeat){
  this.setChanged();
  this.notifyObservers(repeat);
}","void changed(boolean repeat){
  this.setChanged();
  this.notifyObservers(repeat);
}",0.9438202247191012
80648,"@Override public int hashCode(){
  return Objects.hash(mTransmissions);
}","@Override public int hashCode(){
  int hash=this.abstractHashCode();
  hash=67 * hash + Objects.hash(mTransmissions);
  return hash;
}",0.6666666666666666
80649,"public DownloadTask(InMessage message){
  this.message=message;
}","DownloadTask(InMessage message){
  this.message=message;
}",0.943089430894309
80650,"public UploadTask(OutMessage message){
  this.message=message;
}","UploadTask(OutMessage message){
  this.message=message;
}",0.9421487603305784
80651,"@Override public void onInMessage(GroupCommand command,Contact sender){
  KonGroupData gid=mChat.getGroupData();
  MessageContent.GroupCommand.OP op=command.getOperation();
  if (op != GroupCommand.OP.LEAVE) {
    if (!gid.owner.equals(sender.getJID())) {
      LOGGER.warning(""String_Node_Str"");
      return;
    }
  }
  List<ProtoMember> added=new ArrayList<>();
  List<ProtoMember> removed=new ArrayList<>();
  String subject=""String_Node_Str"";
switch (command.getOperation()) {
case CREATE:
    added.addAll(JIDsToMembers(command.getAdded()));
  if (!added.stream().anyMatch(m -> m.getContact().isMe()))   LOGGER.warning(""String_Node_Str"");
subject=command.getSubject();
break;
case LEAVE:
removed.add(new ProtoMember(sender));
break;
case SET:
added.addAll(JIDsToMembers(command.getAdded()));
if (command.isAddingMe()) added.addAll(JIDsToMembers(command.getUnchanged()));
for (JID jid : command.getRemoved()) {
Contact contact=mModel.contacts().get(jid).orElse(null);
if (contact == null) {
LOGGER.warning(""String_Node_Str"" + jid);
continue;
}
removed.add(new ProtoMember(contact));
}
subject=command.getSubject();
break;
default :
LOGGER.warning(""String_Node_Str"" + command.getOperation());
}
mChat.applyGroupChanges(added,removed,subject);
}","@Override void onInMessage(GroupCommand command,Contact sender){
  KonGroupData gid=mChat.getGroupData();
  MessageContent.GroupCommand.OP op=command.getOperation();
  if (op != GroupCommand.OP.LEAVE) {
    if (!gid.owner.equals(sender.getJID())) {
      LOGGER.warning(""String_Node_Str"");
      return;
    }
  }
  List<ProtoMember> added=new ArrayList<>();
  List<ProtoMember> removed=new ArrayList<>();
  String subject=""String_Node_Str"";
switch (command.getOperation()) {
case CREATE:
    added.addAll(JIDsToMembers(command.getAdded()));
  if (added.stream().noneMatch(m -> m.getContact().isMe()))   LOGGER.warning(""String_Node_Str"");
subject=command.getSubject();
break;
case LEAVE:
removed.add(new ProtoMember(sender));
break;
case SET:
added.addAll(JIDsToMembers(command.getAdded()));
if (command.isAddingMe()) added.addAll(JIDsToMembers(command.getUnchanged()));
for (JID jid : command.getRemoved()) {
Contact contact=mModel.contacts().get(jid).orElse(null);
if (contact == null) {
LOGGER.warning(""String_Node_Str"" + jid);
continue;
}
removed.add(new ProtoMember(contact));
}
subject=command.getSubject();
break;
default :
LOGGER.warning(""String_Node_Str"" + command.getOperation());
}
mChat.applyGroupChanges(added,removed,subject);
}",0.9819349658771578
80652,"private static void addContent(MessageContent.Builder builder,List<ExtensionElement> elements,String body,boolean decrypted){
  String outOfBandURL=null;
  for (  ExtensionElement element : elements) {
    if (element instanceof BodyElement) {
      body=((BodyElement)element).getText();
    }
 else     if (element instanceof BitsOfBinary) {
      BitsOfBinary bob=(BitsOfBinary)element;
      String mime=StringUtils.defaultString(bob.getType());
      byte[] bits=bob.getContents();
      if (bits == null)       bits=new byte[0];
      if (mime.isEmpty() || bits.length <= 0)       LOGGER.warning(""String_Node_Str"" + bob.toXML());
 else       builder.preview(new Preview(bits,mime));
    }
 else     if (element instanceof OutOfBandData) {
      OutOfBandData oobData=(OutOfBandData)element;
      URI url;
      try {
        url=new URI(oobData.getUrl());
      }
 catch (      URISyntaxException ex) {
        LOGGER.log(Level.WARNING,""String_Node_Str"",ex);
        url=URI.create(""String_Node_Str"");
      }
      builder.attachment(new InAttachment(url));
      outOfBandURL=url.toString();
    }
 else     if (element instanceof GroupExtension) {
      GroupExtension group=(GroupExtension)element;
      KonGroupData gid=new KonGroupData(JID.bare(group.getOwner()),group.getID());
      GroupCommand groupCommand=ClientUtils.groupExtensionToGroupCommand(group.getType(),group.getMembers(),group.getSubject()).orElse(null);
      builder.groupData(gid);
      if (groupCommand != null)       builder.groupCommand(groupCommand);
    }
 else {
      if (decrypted || !IGNORED_NAMESPACES.contains(element.getNamespace()))       LOGGER.warning(""String_Node_Str"" + (element == null ? element : element.toXML().toString()));
    }
  }
  if (body.equals(outOfBandURL))   body=""String_Node_Str"";
  if (!body.isEmpty())   builder.body(body);
}","private static void addContent(MessageContent.Builder builder,List<ExtensionElement> elements,String body,boolean decrypted){
  String outOfBandURL=null;
  for (  ExtensionElement element : elements) {
    if (element instanceof BodyElement) {
      body=((BodyElement)element).getText();
    }
 else     if (element instanceof BitsOfBinary) {
      BitsOfBinary bob=(BitsOfBinary)element;
      String mime=StringUtils.defaultString(bob.getType());
      byte[] bits=bob.getContents();
      if (bits == null)       bits=new byte[0];
      if (mime.isEmpty() || bits.length <= 0)       LOGGER.warning(""String_Node_Str"" + bob.toXML());
 else       builder.preview(new Preview(bits,mime));
    }
 else     if (element instanceof OutOfBandData) {
      OutOfBandData oobData=(OutOfBandData)element;
      URI url;
      try {
        url=new URI(oobData.getUrl());
      }
 catch (      URISyntaxException ex) {
        LOGGER.log(Level.WARNING,""String_Node_Str"",ex);
        url=URI.create(""String_Node_Str"");
      }
      builder.attachment(new InAttachment(url));
      outOfBandURL=url.toString();
    }
 else     if (element instanceof GroupExtension) {
      GroupExtension group=(GroupExtension)element;
      KonGroupData gid=new KonGroupData(JID.bare(group.getOwner()),group.getID());
      GroupCommand groupCommand=ClientUtils.groupExtensionToGroupCommand(group.getType(),group.getMembers(),group.getSubject()).orElse(null);
      builder.groupData(gid);
      if (groupCommand != null)       builder.groupCommand(groupCommand);
    }
 else {
      if (decrypted || !IGNORED_NAMESPACES.contains(element.getNamespace()))       LOGGER.warning(""String_Node_Str"" + (element == null ? null : element.toXML().toString()));
    }
  }
  if (body.equals(outOfBandURL))   body=""String_Node_Str"";
  if (!body.isEmpty())   builder.body(body);
}",0.9970165446162192
80653,"public InternalException(String msg){
  super(msg);
}","InternalException(String msg){
  super(msg);
}",0.9292929292929292
80654,"public CellRenderer(){
  mNameLabel=new WebLabel();
  mRoleLabel=new WebLabel();
  mRoleLabel.setForeground(View.DARK_GREEN);
  this.setMargin(View.MARGIN_DEFAULT);
  this.setBorder(BorderFactory.createMatteBorder(0,0,1,0,Color.LIGHT_GRAY));
  this.add(new GroupPanel(GroupingType.fillMiddle,View.GAP_DEFAULT,mNameLabel,Box.createGlue(),mRoleLabel),BorderLayout.CENTER);
}","CellRenderer(){
  mNameLabel=new WebLabel();
  mRoleLabel=new WebLabel();
  mRoleLabel.setForeground(View.DARK_GREEN);
  this.setMargin(View.MARGIN_DEFAULT);
  this.setBorder(BorderFactory.createMatteBorder(0,0,1,0,Color.LIGHT_GRAY));
  this.add(new GroupPanel(GroupingType.fillMiddle,View.GAP_DEFAULT,mNameLabel,Box.createGlue(),mRoleLabel),BorderLayout.CENTER);
}",0.9905020352781548
80655,"Optional<char[]> getNewPassword(){
  if (!mSetPass.isSelected())   return Optional.of(new char[0]);
  char[] newPass=mNewPassField.getPassword();
  if (!Arrays.equals(newPass,mConfirmPassField.getPassword()))   Optional.empty();
  return Optional.of(newPass);
}","Optional<char[]> getNewPassword(){
  if (!mSetPass.isSelected())   return Optional.of(new char[0]);
  char[] newPass=mNewPassField.getPassword();
  if (!Arrays.equals(newPass,mConfirmPassField.getPassword()))   return Optional.empty();
  return Optional.of(newPass);
}",0.9867674858223062
80656,"public NetworkPanel(){
  GroupPanel groupPanel=new GroupPanel(View.GAP_DEFAULT,false);
  groupPanel.setMargin(View.MARGIN_BIG);
  groupPanel.add(new WebLabel(Tr.tr(""String_Node_Str"")).setBoldFont());
  groupPanel.add(new WebSeparator(true,true));
  mConnectStartupBox=createCheckBox(Tr.tr(""String_Node_Str""),""String_Node_Str"",mConf.getBoolean(Config.MAIN_CONNECT_STARTUP));
  groupPanel.add(mConnectStartupBox);
  mConnectRetryBox=createCheckBox(Tr.tr(""String_Node_Str""),Tr.tr(""String_Node_Str""),mConf.getBoolean(Config.NET_RETRY_CONNECT));
  groupPanel.add(new GroupPanel(mConnectRetryBox,new WebSeparator()));
  mRequestAvatars=createCheckBox(Tr.tr(""String_Node_Str""),Tr.tr(""String_Node_Str""),mConf.getBoolean(Config.NET_REQUEST_AVATARS));
  groupPanel.add(new GroupPanel(mRequestAvatars,new WebSeparator()));
  mImgResizeMap=new LinkedHashMap<>();
  mImgResizeMap.put(-1,Tr.tr(""String_Node_Str""));
  mImgResizeMap.put(300 * 1000,Tr.tr(""String_Node_Str""));
  mImgResizeMap.put(500 * 1000,Tr.tr(""String_Node_Str""));
  mImgResizeMap.put(800 * 1000,Tr.tr(""String_Node_Str""));
  mMaxImgSizeBox=new WebComboBox(new ArrayList<>(mImgResizeMap.values()).toArray());
  int maxImgIndex=new ArrayList<>(mImgResizeMap.keySet()).indexOf(mConf.getInt(Config.NET_MAX_IMG_SIZE));
  if (maxImgIndex >= 0)   mMaxImgSizeBox.setSelectedIndex(maxImgIndex);
  TooltipManager.addTooltip(mMaxImgSizeBox,Tr.tr(""String_Node_Str""));
  groupPanel.add(new GroupPanel(View.GAP_DEFAULT,new WebLabel(Tr.tr(""String_Node_Str"")),mMaxImgSizeBox,new WebSeparator()));
  this.add(groupPanel);
}","NetworkPanel(){
  GroupPanel groupPanel=new GroupPanel(View.GAP_DEFAULT,false);
  groupPanel.setMargin(View.MARGIN_BIG);
  groupPanel.add(new WebLabel(Tr.tr(""String_Node_Str"")).setBoldFont());
  groupPanel.add(new WebSeparator(true,true));
  mConnectStartupBox=createCheckBox(Tr.tr(""String_Node_Str""),""String_Node_Str"",mConf.getBoolean(Config.MAIN_CONNECT_STARTUP));
  groupPanel.add(mConnectStartupBox);
  mConnectRetryBox=createCheckBox(Tr.tr(""String_Node_Str""),Tr.tr(""String_Node_Str""),mConf.getBoolean(Config.NET_RETRY_CONNECT));
  groupPanel.add(new GroupPanel(mConnectRetryBox,new WebSeparator()));
  mRequestAvatars=createCheckBox(Tr.tr(""String_Node_Str""),Tr.tr(""String_Node_Str""),mConf.getBoolean(Config.NET_REQUEST_AVATARS));
  groupPanel.add(new GroupPanel(mRequestAvatars,new WebSeparator()));
  mImgResizeMap=new LinkedHashMap<>();
  mImgResizeMap.put(-1,Tr.tr(""String_Node_Str""));
  mImgResizeMap.put(300 * 1000,Tr.tr(""String_Node_Str""));
  mImgResizeMap.put(500 * 1000,Tr.tr(""String_Node_Str""));
  mImgResizeMap.put(800 * 1000,Tr.tr(""String_Node_Str""));
  mMaxImgSizeBox=new WebComboBox(new ArrayList<>(mImgResizeMap.values()).toArray());
  int maxImgIndex=new ArrayList<>(mImgResizeMap.keySet()).indexOf(mConf.getInt(Config.NET_MAX_IMG_SIZE));
  if (maxImgIndex >= 0)   mMaxImgSizeBox.setSelectedIndex(maxImgIndex);
  TooltipManager.addTooltip(mMaxImgSizeBox,Tr.tr(""String_Node_Str""));
  groupPanel.add(new GroupPanel(View.GAP_DEFAULT,new WebLabel(Tr.tr(""String_Node_Str"")),mMaxImgSizeBox,new WebSeparator()));
  this.add(groupPanel);
}",0.997748472177549
80657,"protected void configUpdate(){
}","void configUpdate(){
}",0.8148148148148148
80658,"public WrapLabelView(Element elem){
  super(elem);
}","WrapLabelView(Element elem){
  super(elem);
}",0.9278350515463918
80659,"private static WebPanel createListPanel(final WebTable list,String overlayText,WebToggleButton button){
  WebOverlay listOverlay=new WebOverlay(list);
  listOverlay.setOverlayMargin(20);
  final WebTextArea overlayArea=new WebTextArea();
  overlayArea.setText(overlayText);
  overlayArea.setLineWrap(true);
  overlayArea.setWrapStyleWord(true);
  overlayArea.setMargin(View.MARGIN_DEFAULT);
  overlayArea.setFontSize(View.FONT_SIZE_BIG);
  overlayArea.setEditable(false);
  BorderPainter<WebTextArea> borderPainter=new BorderPainter<>(Color.LIGHT_GRAY);
  borderPainter.setRound(15);
  overlayArea.setPainter(borderPainter);
  list.getModel().addTableModelListener(new TableModelListener(){
    @Override public void tableChanged(    TableModelEvent e){
      overlayArea.setVisible(list.getModel().getRowCount() == 0);
    }
  }
);
  overlayArea.setVisible(list.getModel().getRowCount() == 0);
  listOverlay.addOverlay(overlayArea,SwingConstants.CENTER,SwingConstants.CENTER);
  WebScrollPane scrollPane=new ComponentUtils.ScrollPane(listOverlay);
  scrollPane.setDrawBorder(false);
  button.setOpaque(false);
  button.setUndecorated(true);
  WebOverlay chatListOverlay=new WebOverlay(scrollPane,button,SwingConstants.TRAILING,SwingConstants.BOTTOM);
  chatListOverlay.setOverlayMargin(0,0,View.GAP_BIG,View.GAP_BIG + SCROLL_BAR_WIDTH);
  return chatListOverlay;
}","private static WebPanel createListPanel(final WebTable list,String overlayText,WebToggleButton button){
  WebOverlay listOverlay=new WebOverlay(list);
  listOverlay.setOverlayMargin(20);
  final WebTextArea overlayArea=new WebTextArea();
  overlayArea.setText(overlayText);
  overlayArea.setLineWrap(true);
  overlayArea.setWrapStyleWord(true);
  overlayArea.setMargin(View.MARGIN_DEFAULT);
  overlayArea.setFontSize(View.FONT_SIZE_BIG);
  overlayArea.setEditable(false);
  BorderPainter<WebTextArea> borderPainter=new BorderPainter<>(Color.LIGHT_GRAY);
  borderPainter.setRound(15);
  overlayArea.setPainter(borderPainter);
  list.getModel().addTableModelListener(new TableModelListener(){
    @Override public void tableChanged(    TableModelEvent e){
      overlayArea.setVisible(list.getModel().getRowCount() == 0);
    }
  }
);
  overlayArea.setVisible(list.getModel().getRowCount() == 0);
  listOverlay.addOverlay(overlayArea,SwingConstants.CENTER,SwingConstants.CENTER);
  WebScrollPane scrollPane=new ComponentUtils.ScrollPane(listOverlay);
  scrollPane.setDrawBorder(false);
  button.setOpaque(false);
  button.setUndecorated(true);
  WebOverlay chatListOverlay=new WebOverlay(scrollPane,button,SwingConstants.TRAILING,SwingConstants.BOTTOM);
  chatListOverlay.setOverlayMargin(0,0,View.GAP_BIG,View.GAP_BIG + SCROLL_BAR_WIDTH);
  SwingUtils.delayInvokeLater(0,new Runnable(){
    @Override public void run(){
      TooltipManager.showOneTimeTooltip(list,new Point(1,1),""String_Node_Str"");
    }
  }
);
  return chatListOverlay;
}",0.9400826446280992
80660,"@Override public JPopupMenu getComponentPopupMenu(){
  WebPopupMenu menu=new WebPopupMenu();
  if (mFile == null)   return null;
  WebMenuItem saveMenuItem=new WebMenuItem(Tr.tr(""String_Node_Str""));
  saveMenuItem.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent event){
      if (mFile == null)       return;
      mFileChooser.setSelectedFile(new File(mFileChooser.getCurrentDirectory(),mFile.getName()));
      int option=mFileChooser.showSaveDialog(AttachmentPanel.this);
      if (option == JFileChooser.APPROVE_OPTION) {
        try {
          Files.copy(mFile.toPath(),mFileChooser.getSelectedFile().toPath(),StandardCopyOption.REPLACE_EXISTING);
        }
 catch (        IOException ex) {
          LOGGER.log(Level.WARNING,""String_Node_Str"",ex);
        }
      }
    }
  }
);
  if (!mFile.exists()) {
    saveMenuItem.setEnabled(false);
    saveMenuItem.setToolTipText(Tr.tr(""String_Node_Str""));
  }
  menu.add(saveMenuItem);
  return menu;
}","@Override public JPopupMenu getComponentPopupMenu(){
  WebPopupMenu menu=new WebPopupMenu();
  if (mFile == null)   return null;
  WebMenuItem saveMenuItem=new WebMenuItem(Tr.tr(""String_Node_Str""));
  saveMenuItem.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent event){
      if (mFile == null)       return;
      File suggestedFile=new File(mFileChooser.getCurrentDirectory(),mFile.getName());
      mFileChooser.setSelectedFile(suggestedFile);
      mFileChooser.getFileChooserPanel().setSelectedFiles(new File[]{suggestedFile});
      int option=mFileChooser.showSaveDialog(AttachmentPanel.this);
      if (option == JFileChooser.APPROVE_OPTION) {
        try {
          Files.copy(mFile.toPath(),mFileChooser.getSelectedFile().toPath(),StandardCopyOption.REPLACE_EXISTING);
        }
 catch (        IOException ex) {
          LOGGER.log(Level.WARNING,""String_Node_Str"",ex);
        }
      }
    }
  }
);
  if (!mFile.exists()) {
    saveMenuItem.setEnabled(false);
    saveMenuItem.setToolTipText(Tr.tr(""String_Node_Str""));
  }
  menu.add(saveMenuItem);
  return menu;
}",0.8921200750469043
80661,"private void updateView(Object arg){
  if (arg == null || arg instanceof Contact || arg instanceof String || arg instanceof GroupCommand) {
    mTitleLabel.setText(Utils.chatTitle(mValue));
  }
  if (arg == null || arg instanceof Contact || arg instanceof String) {
    mAvatar.setImage(AvatarLoader.load(mValue));
  }
  if (arg == null || arg instanceof KonMessage) {
    this.updateBG();
    mStatusLabel.setText(lastActivity(mValue,true));
    ChatListView.this.updateSorting();
  }
 else   if (arg instanceof Boolean) {
    this.updateBG();
  }
 else   if (arg instanceof Timer) {
    mStatusLabel.setText(lastActivity(mValue,true));
  }
  String stateText=""String_Node_Str"";
  if (arg instanceof Member) {
    Member member=(Member)arg;
switch (member.getState()) {
case composing:
      stateText=Tr.tr(""String_Node_Str"");
    break;
}
if (!stateText.isEmpty() && mValue.isGroupChat()) stateText=member.getContact().getName() + ""String_Node_Str"" + stateText;
}
if (stateText.isEmpty()) {
mChatStateLabel.setText(""String_Node_Str"");
mStatusLabel.setVisible(true);
}
 else {
mChatStateLabel.setText(stateText);
mStatusLabel.setVisible(false);
}
}","private void updateView(Object arg){
  if (arg == null || arg instanceof Contact || arg instanceof String || arg instanceof GroupCommand) {
    mTitleLabel.setText(Utils.chatTitle(mValue));
  }
  if (arg == null || arg instanceof Contact || arg instanceof String) {
    Utils.fixedSetWebImageImage(mAvatar,AvatarLoader.load(mValue));
  }
  if (arg == null || arg instanceof KonMessage) {
    this.updateBG();
    mStatusLabel.setText(lastActivity(mValue,true));
    ChatListView.this.updateSorting();
  }
 else   if (arg instanceof Boolean) {
    this.updateBG();
  }
 else   if (arg instanceof Timer) {
    mStatusLabel.setText(lastActivity(mValue,true));
  }
  String stateText=""String_Node_Str"";
  if (arg instanceof Member) {
    Member member=(Member)arg;
switch (member.getState()) {
case composing:
      stateText=Tr.tr(""String_Node_Str"");
    break;
}
if (!stateText.isEmpty() && mValue.isGroupChat()) stateText=member.getContact().getName() + ""String_Node_Str"" + stateText;
}
if (stateText.isEmpty()) {
mChatStateLabel.setText(""String_Node_Str"");
mStatusLabel.setVisible(true);
}
 else {
mChatStateLabel.setText(stateText);
mStatusLabel.setVisible(false);
}
}",0.9831824062095732
80662,"@Override protected void updateOnEDT(Object arg){
  if (arg == null || arg instanceof String) {
    mAvatar.setImage(AvatarLoader.load(mValue));
    String name=Utils.displayName(mValue);
    if (!name.equals(mNameLabel.getText())) {
      mNameLabel.setText(name);
      ContactListView.this.updateSorting();
    }
  }
  if (arg == null || arg instanceof Contact.Subscription || arg instanceof Contact.Online) {
    mStatusLabel.setText(Utils.mainStatus(mValue,false));
  }
  if (arg == null || arg instanceof Contact.Subscription) {
    Contact.Subscription subStatus=mValue.getSubScription();
    mBackground=mValue.getOnline() == Contact.Online.YES ? View.LIGHT_BLUE : subStatus == Contact.Subscription.UNSUBSCRIBED || subStatus == Contact.Subscription.PENDING || mValue.isBlocked() ? View.LIGHT_GREY : Color.WHITE;
    this.setBackground(mBackground);
  }
  ContactListView.this.repaint();
}","@Override protected void updateOnEDT(Object arg){
  if (arg == null || arg instanceof String) {
    Utils.fixedSetWebImageImage(mAvatar,AvatarLoader.load(mValue));
    String name=Utils.displayName(mValue);
    if (!name.equals(mNameLabel.getText())) {
      mNameLabel.setText(name);
      ContactListView.this.updateSorting();
    }
  }
  if (arg == null || arg instanceof Contact.Subscription || arg instanceof Contact.Online) {
    mStatusLabel.setText(Utils.mainStatus(mValue,false));
  }
  if (arg == null || arg instanceof Contact.Subscription) {
    Contact.Subscription subStatus=mValue.getSubScription();
    mBackground=mValue.getOnline() == Contact.Online.YES ? View.LIGHT_BLUE : subStatus == Contact.Subscription.UNSUBSCRIBED || subStatus == Contact.Subscription.PENDING || mValue.isBlocked() ? View.LIGHT_GREY : Color.WHITE;
    this.setBackground(mBackground);
  }
  ContactListView.this.repaint();
}",0.9784649364991718
80663,"public boolean execDeleteWhereInsecure(String table,String where){
  try (Statement stat=mConn.createStatement()){
    int c=stat.executeUpdate(""String_Node_Str"" + table + ""String_Node_Str""+ where);
    LOGGER.info(""String_Node_Str"" + c + ""String_Node_Str""+ table+ ""String_Node_Str""+ where);
  }
 catch (  SQLException ex) {
    LOGGER.log(Level.WARNING,""String_Node_Str"",ex);
    return false;
  }
  return true;
}","public boolean execDeleteWhereInsecure(String table,String where){
  LOGGER.info(""String_Node_Str"" + table + ""String_Node_Str""+ where);
  try (Statement stat=mConn.createStatement()){
    int c=stat.executeUpdate(""String_Node_Str"" + table + ""String_Node_Str""+ where);
    LOGGER.config(""String_Node_Str"" + c + ""String_Node_Str"");
  }
 catch (  SQLException ex) {
    LOGGER.log(Level.WARNING,""String_Node_Str"",ex);
    return false;
  }
  return true;
}",0.7788018433179723
80664,"public ChatMessages(Chat chat){
  mChat=chat;
}","ChatMessages(Chat chat,boolean newChat){
  mChat=chat;
  mLoaded=newChat;
}",0.6557377049180327
80665,"private void loadMessages(){
  Database db=Database.getInstance();
  try (ResultSet messageRS=db.execSelectWhereInsecure(KonMessage.TABLE,KonMessage.COL_CHAT_ID + ""String_Node_Str"" + mChat.getID())){
    while (messageRS.next()) {
      KonMessage message=KonMessage.load(messageRS,mChat);
      if (message.getTransmissions().length == 0)       continue;
      this.addSilent(message);
    }
  }
 catch (  SQLException ex) {
    LOGGER.log(Level.WARNING,""String_Node_Str"",ex);
  }
}","private void loadMessages(){
  LOGGER.config(""String_Node_Str"" + mChat.getID());
  Database db=Database.getInstance();
  try (ResultSet messageRS=db.execSelectWhereInsecure(KonMessage.TABLE,KonMessage.COL_CHAT_ID + ""String_Node_Str"" + mChat.getID())){
    while (messageRS.next()) {
      KonMessage message=KonMessage.load(messageRS,mChat);
      if (message.getTransmissions().length == 0)       continue;
      this.addSilent(message);
    }
  }
 catch (  SQLException ex) {
    LOGGER.log(Level.WARNING,""String_Node_Str"",ex);
  }
}",0.948919449901768
80666,"/** 
 * Decrypt, verify and write input stream data to output stream. Input and output streams are closed.
 */
private static DecryptionResult decryptAndVerify(InputStream encryptedInput,OutputStream plainOutput,PersonalKey myKey,PGPPublicKey senderSigningKey){
  DecryptionResult result=new DecryptionResult();
  PGPObjectFactory pgpFactory=new PGPObjectFactory(encryptedInput,PGPUtils.FP_CALC);
  try {
    Object o=pgpFactory.nextObject();
    if (!(o instanceof PGPEncryptedDataList)) {
      o=pgpFactory.nextObject();
    }
    if (!(o instanceof PGPEncryptedDataList)) {
      LOGGER.warning(""String_Node_Str"");
      result.errors.add(Error.INVALID_DATA);
      return result;
    }
    PGPEncryptedDataList encDataList=(PGPEncryptedDataList)o;
    Iterator<?> it=encDataList.getEncryptedDataObjects();
    PGPPrivateKey sKey=null;
    PGPPublicKeyEncryptedData pbe=null;
    long myKeyID=myKey.getPrivateEncryptionKey().getKeyID();
    while (sKey == null && it.hasNext()) {
      Object i=it.next();
      if (!(i instanceof PGPPublicKeyEncryptedData))       continue;
      pbe=(PGPPublicKeyEncryptedData)i;
      if (pbe.getKeyID() == myKeyID)       sKey=myKey.getPrivateEncryptionKey();
    }
    if (sKey == null || pbe == null) {
      LOGGER.warning(""String_Node_Str"");
      result.errors.add(Error.INVALID_PRIVATE_KEY);
      return result;
    }
    InputStream clear=pbe.getDataStream(new BcPublicKeyDataDecryptorFactory(sKey));
    PGPObjectFactory plainFactory=new PGPObjectFactory(clear,PGPUtils.FP_CALC);
    Object object=plainFactory.nextObject();
    if (!(object instanceof PGPCompressedData)) {
      LOGGER.warning(""String_Node_Str"");
      result.errors.add(Error.INVALID_DATA);
      return result;
    }
    PGPCompressedData cData=(PGPCompressedData)object;
    PGPObjectFactory pgpFact=new PGPObjectFactory(cData.getDataStream(),PGPUtils.FP_CALC);
    object=pgpFact.nextObject();
    PGPOnePassSignature ops=null;
    if (object instanceof PGPOnePassSignatureList) {
      PGPOnePassSignatureList signatureList=(PGPOnePassSignatureList)object;
      result.signing=Signing.SIGNED;
      if (signatureList.isEmpty()) {
        LOGGER.warning(""String_Node_Str"");
        result.errors.add(Error.INVALID_SIGNATURE_DATA);
      }
 else {
        ops=signatureList.get(0);
        try {
          ops.init(new BcPGPContentVerifierBuilderProvider(),senderSigningKey);
        }
 catch (        ClassCastException e) {
          LOGGER.warning(""String_Node_Str"");
          result.errors.add(Error.INVALID_SIGNATURE_DATA);
          ops=null;
        }
      }
      object=pgpFact.nextObject();
    }
 else {
      LOGGER.warning(""String_Node_Str"");
      result.signing=Signing.NOT;
    }
    if (!(object instanceof PGPLiteralData)) {
      LOGGER.warning(""String_Node_Str"" + object.getClass().getName());
      result.errors.add(Error.INVALID_DATA);
      return result;
    }
    PGPLiteralData ld=(PGPLiteralData)object;
    InputStream unc=ld.getInputStream();
    int ch;
    while ((ch=unc.read()) >= 0) {
      plainOutput.write(ch);
      if (ops != null)       ops.update((byte)ch);
    }
    plainOutput.close();
    encryptedInput.close();
    result.decrypted=true;
    if (ops != null) {
      result=verifySignature(result,pgpFact,ops);
    }
    if (pbe.isIntegrityProtected()) {
      if (!pbe.verify()) {
        LOGGER.warning(""String_Node_Str"");
        result.errors.add(Error.INVALID_INTEGRITY);
      }
    }
 else {
      LOGGER.warning(""String_Node_Str"");
      result.errors.add(Error.NO_INTEGRITY);
    }
  }
 catch (  IOException|PGPException ex) {
    LOGGER.log(Level.WARNING,""String_Node_Str"",ex);
    result.errors.add(Error.UNKNOWN_ERROR);
  }
  return result;
}","/** 
 * Decrypt, verify and write input stream data to output stream. Input and output streams are closed.
 */
private static DecryptionResult decryptAndVerify(InputStream encryptedInput,OutputStream plainOutput,PersonalKey myKey,PGPPublicKey senderSigningKey){
  DecryptionResult result=new DecryptionResult();
  PGPObjectFactory pgpFactory=new PGPObjectFactory(encryptedInput,PGPUtils.FP_CALC);
  try {
    Object o=pgpFactory.nextObject();
    if (!(o instanceof PGPEncryptedDataList)) {
      o=pgpFactory.nextObject();
    }
    if (!(o instanceof PGPEncryptedDataList)) {
      LOGGER.warning(""String_Node_Str"");
      result.errors.add(Error.INVALID_DATA);
      return result;
    }
    PGPEncryptedDataList encDataList=(PGPEncryptedDataList)o;
    Iterator<?> it=encDataList.getEncryptedDataObjects();
    PGPPrivateKey sKey=null;
    PGPPublicKeyEncryptedData pbe=null;
    long myKeyID=myKey.getPrivateEncryptionKey().getKeyID();
    while (sKey == null && it.hasNext()) {
      Object i=it.next();
      if (!(i instanceof PGPPublicKeyEncryptedData))       continue;
      pbe=(PGPPublicKeyEncryptedData)i;
      if (pbe.getKeyID() == myKeyID)       sKey=myKey.getPrivateEncryptionKey();
    }
    if (sKey == null || pbe == null) {
      LOGGER.warning(""String_Node_Str"");
      result.errors.add(Error.INVALID_PRIVATE_KEY);
      return result;
    }
    InputStream clear=pbe.getDataStream(new BcPublicKeyDataDecryptorFactory(sKey));
    PGPObjectFactory plainFactory=new PGPObjectFactory(clear,PGPUtils.FP_CALC);
    Object object=plainFactory.nextObject();
    if (!(object instanceof PGPCompressedData)) {
      LOGGER.warning(""String_Node_Str"");
      result.errors.add(Error.INVALID_DATA);
      return result;
    }
    PGPCompressedData cData=(PGPCompressedData)object;
    PGPObjectFactory pgpFact=new PGPObjectFactory(cData.getDataStream(),PGPUtils.FP_CALC);
    object=pgpFact.nextObject();
    PGPOnePassSignature ops=null;
    if (object instanceof PGPOnePassSignatureList) {
      PGPOnePassSignatureList signatureList=(PGPOnePassSignatureList)object;
      result.signing=Signing.SIGNED;
      if (signatureList.isEmpty()) {
        LOGGER.warning(""String_Node_Str"");
        result.errors.add(Error.INVALID_SIGNATURE_DATA);
      }
 else {
        ops=signatureList.get(0);
        try {
          ops.init(new BcPGPContentVerifierBuilderProvider(),senderSigningKey);
        }
 catch (        ClassCastException e) {
          LOGGER.warning(""String_Node_Str"");
          result.errors.add(Error.INVALID_SIGNATURE_DATA);
          ops=null;
        }
      }
      object=pgpFact.nextObject();
    }
 else {
      LOGGER.warning(""String_Node_Str"");
      result.signing=Signing.NOT;
    }
    if (!(object instanceof PGPLiteralData)) {
      LOGGER.warning(""String_Node_Str"" + object.getClass().getName());
      result.errors.add(Error.INVALID_DATA);
      return result;
    }
    PGPLiteralData ld=(PGPLiteralData)object;
    InputStream unc=ld.getInputStream();
    int ch;
    while ((ch=unc.read()) >= 0) {
      plainOutput.write(ch);
      if (ops != null)       ops.update((byte)ch);
    }
    plainOutput.close();
    result.decrypted=true;
    if (ops != null) {
      result=verifySignature(result,pgpFact,ops);
    }
    encryptedInput.close();
    if (pbe.isIntegrityProtected()) {
      if (!pbe.verify()) {
        LOGGER.warning(""String_Node_Str"");
        result.errors.add(Error.INVALID_INTEGRITY);
      }
    }
 else {
      LOGGER.warning(""String_Node_Str"");
      result.errors.add(Error.NO_INTEGRITY);
    }
  }
 catch (  IOException|PGPException ex) {
    LOGGER.log(Level.WARNING,""String_Node_Str"",ex);
    result.errors.add(Error.UNKNOWN_ERROR);
  }
  return result;
}",0.971551261406334
80667,"private static TrayIcon createTrayIcon(final View view,final MainFrame mainFrame){
  final WebPopupMenu popup=new WebPopupMenu(""String_Node_Str"");
  WebMenuItem quitItem=new WebMenuItem(Tr.tr(""String_Node_Str""));
  quitItem.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent event){
      view.callShutDown();
    }
  }
);
  popup.add(quitItem);
  final WebDialog hiddenDialog=new WebDialog();
  hiddenDialog.setUndecorated(true);
  MouseListener listener=new MouseAdapter(){
    @Override public void mousePressed(    MouseEvent e){
    }
    @Override public void mouseReleased(    MouseEvent e){
      if (e.getButton() == MouseEvent.BUTTON1)       mainFrame.toggleState();
 else       check(e);
    }
    private void check(    MouseEvent e){
      hiddenDialog.setVisible(true);
      popup.setLocation(e.getX() - 20,e.getY() - 40);
      popup.setInvoker(hiddenDialog);
      popup.setCornerWidth(0);
      popup.setVisible(true);
    }
  }
;
  TrayIcon trayIcon=new TrayIcon(getTrayImage(),""String_Node_Str"");
  trayIcon.setImageAutoSize(true);
  trayIcon.addMouseListener(listener);
  return trayIcon;
}","private static TrayIcon createTrayIcon(final View view,final MainFrame mainFrame){
  final WebPopupMenu popup=new WebPopupMenu();
  WebMenuItem quitItem=new WebMenuItem(Tr.tr(""String_Node_Str""));
  quitItem.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent event){
      view.callShutDown();
    }
  }
);
  popup.add(quitItem);
  final WebDialog hiddenDialog=new WebDialog();
  hiddenDialog.setUndecorated(true);
  MouseListener listener=new MouseAdapter(){
    @Override public void mousePressed(    MouseEvent e){
    }
    @Override public void mouseReleased(    MouseEvent e){
      if (e.getButton() == MouseEvent.BUTTON1)       mainFrame.toggleState();
 else       check(e);
    }
    private void check(    MouseEvent e){
      hiddenDialog.setVisible(true);
      popup.setLocation(e.getX() - 20,e.getY() - 40);
      popup.setInvoker(hiddenDialog);
      popup.setCornerWidth(0);
      popup.setVisible(true);
    }
  }
;
  TrayIcon trayIcon=new TrayIcon(getTrayImage(),""String_Node_Str"");
  trayIcon.setImageAutoSize(true);
  trayIcon.addMouseListener(listener);
  return trayIcon;
}",0.9926054806437582
80668,"ThreadDetails(final ComponentUtils.ModalPopup popup,KonThread thread){
  mThread=thread;
  GroupPanel groupPanel=new GroupPanel(View.GAP_BIG,false);
  groupPanel.setMargin(View.MARGIN_BIG);
  groupPanel.add(new WebLabel(Tr.tr(""String_Node_Str"")).setBoldFont());
  groupPanel.add(new WebSeparator(true,true));
  groupPanel.add(new WebLabel(Tr.tr(""String_Node_Str"")));
  String subj=mThread.getSubject();
  mSubjectField=new WebTextField(subj,22);
  mSubjectField.setInputPrompt(subj);
  mSubjectField.setHideInputPromptOnFocus(false);
  groupPanel.add(mSubjectField);
  groupPanel.add(new WebSeparator(true,true));
  final WebSlider colorSlider=new WebSlider(WebSlider.HORIZONTAL);
  groupPanel.add(new WebLabel(Tr.tr(""String_Node_Str"")));
  mColorOpt=new WebRadioButton(Tr.tr(""String_Node_Str"") + ""String_Node_Str"");
  Optional<Color> optBGColor=mThread.getViewSettings().getBGColor();
  mColorOpt.setSelected(optBGColor.isPresent());
  mColorOpt.addItemListener(new ItemListener(){
    @Override public void itemStateChanged(    ItemEvent e){
      colorSlider.setEnabled(e.getStateChange() == ItemEvent.SELECTED);
    }
  }
);
  mColor=new WebButton();
  mColor.setMinimumHeight(25);
  Color oldColor=optBGColor.orElse(DEFAULT_BG);
  mColor.setBottomBgColor(oldColor);
  groupPanel.add(new GroupPanel(GroupingType.fillLast,mColorOpt,mColor));
  colorSlider.setMinimum(0);
  colorSlider.setMaximum(100);
  colorSlider.setPaintTicks(false);
  colorSlider.setPaintLabels(false);
  colorSlider.setEnabled(optBGColor.isPresent());
  final GradientData gradientData=GradientData.getDefaultValue();
  gradientData.getColor(0);
  colorSlider.addChangeListener(new ChangeListener(){
    @Override public void stateChanged(    ChangeEvent e){
      float v=colorSlider.getValue() / (float)100;
      Color c=gradientData.getColorForLocation(v);
      mColor.setBottomBgColor(c);
      mColor.repaint();
    }
  }
);
  groupPanel.add(colorSlider);
  mImgOpt=new WebRadioButton(Tr.tr(""String_Node_Str"") + ""String_Node_Str"");
  String imgPath=mThread.getViewSettings().getImagePath();
  mImgOpt.setSelected(!imgPath.isEmpty());
  mImgOpt.addItemListener(new ItemListener(){
    @Override public void itemStateChanged(    ItemEvent e){
      mImgChooser.setEnabled(e.getStateChange() == ItemEvent.SELECTED);
      mImgChooser.getChooseButton().setEnabled(e.getStateChange() == ItemEvent.SELECTED);
    }
  }
);
  mImgChooser=Utils.createImageChooser(!imgPath.isEmpty(),imgPath);
  groupPanel.add(new GroupPanel(GroupingType.fillLast,mImgOpt,mImgChooser));
  UnselectableButtonGroup.group(mColorOpt,mImgOpt);
  groupPanel.add(new WebSeparator());
  final WebButton saveButton=new WebButton(Tr.tr(""String_Node_Str""));
  this.add(groupPanel,BorderLayout.CENTER);
  saveButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      ThreadDetails.this.save();
      popup.close();
    }
  }
);
  GroupPanel buttonPanel=new GroupPanel(2,saveButton);
  buttonPanel.setLayout(new FlowLayout(FlowLayout.TRAILING));
  this.add(buttonPanel,BorderLayout.SOUTH);
}","ThreadDetails(final ComponentUtils.ModalPopup popup,KonThread thread){
  mThread=thread;
  GroupPanel groupPanel=new GroupPanel(View.GAP_BIG,false);
  groupPanel.setMargin(View.MARGIN_BIG);
  groupPanel.add(new WebLabel(Tr.tr(""String_Node_Str"")).setBoldFont());
  groupPanel.add(new WebSeparator(true,true));
  groupPanel.add(new WebLabel(Tr.tr(""String_Node_Str"")));
  String subj=mThread.getSubject();
  mSubjectField=new WebTextField(subj,22);
  mSubjectField.setInputPrompt(subj);
  mSubjectField.setHideInputPromptOnFocus(false);
  groupPanel.add(mSubjectField);
  groupPanel.add(new WebSeparator(true,true));
  final WebSlider colorSlider=new WebSlider(WebSlider.HORIZONTAL);
  groupPanel.add(new WebLabel(Tr.tr(""String_Node_Str"")));
  mColorOpt=new WebRadioButton(Tr.tr(""String_Node_Str"") + ""String_Node_Str"");
  Optional<Color> optBGColor=mThread.getViewSettings().getBGColor();
  mColorOpt.setSelected(optBGColor.isPresent());
  mColorOpt.addItemListener(new ItemListener(){
    @Override public void itemStateChanged(    ItemEvent e){
      colorSlider.setEnabled(e.getStateChange() == ItemEvent.SELECTED);
    }
  }
);
  mColor=new WebButton();
  mColor.setMinimumHeight(25);
  Color oldColor=optBGColor.orElse(DEFAULT_BG);
  mColor.setBottomBgColor(oldColor);
  groupPanel.add(new GroupPanel(GroupingType.fillLast,mColorOpt,mColor));
  colorSlider.setMinimum(0);
  colorSlider.setMaximum(100);
  colorSlider.setPaintTicks(false);
  colorSlider.setPaintLabels(false);
  colorSlider.setEnabled(optBGColor.isPresent());
  final GradientData gradientData=GradientData.getDefaultValue();
  gradientData.getColor(0);
  colorSlider.addChangeListener(new ChangeListener(){
    @Override public void stateChanged(    ChangeEvent e){
      float v=colorSlider.getValue() / (float)100;
      Color c=gradientData.getColorForLocation(v);
      mColor.setBottomBgColor(c);
      mColor.repaint();
    }
  }
);
  groupPanel.add(colorSlider);
  mImgOpt=new WebRadioButton(Tr.tr(""String_Node_Str"") + ""String_Node_Str"");
  String imgPath=mThread.getViewSettings().getImagePath();
  mImgOpt.setSelected(!imgPath.isEmpty());
  mImgOpt.addItemListener(new ItemListener(){
    @Override public void itemStateChanged(    ItemEvent e){
      mImgChooser.setEnabled(e.getStateChange() == ItemEvent.SELECTED);
      mImgChooser.getChooseButton().setEnabled(e.getStateChange() == ItemEvent.SELECTED);
    }
  }
);
  mImgChooser=Utils.createImageChooser(!imgPath.isEmpty(),imgPath);
  mImgChooser.setPreferredWidth(1);
  groupPanel.add(new GroupPanel(GroupingType.fillLast,mImgOpt,mImgChooser));
  UnselectableButtonGroup.group(mColorOpt,mImgOpt);
  groupPanel.add(new WebSeparator());
  final WebButton saveButton=new WebButton(Tr.tr(""String_Node_Str""));
  this.add(groupPanel,BorderLayout.CENTER);
  saveButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      ThreadDetails.this.save();
      popup.close();
    }
  }
);
  GroupPanel buttonPanel=new GroupPanel(2,saveButton);
  buttonPanel.setLayout(new FlowLayout(FlowLayout.TRAILING));
  this.add(buttonPanel,BorderLayout.SOUTH);
}",0.9942122186495176
80669,"private void showPopup(final WebToggleButton invoker){
  Optional<KonThread> optThread=ThreadView.this.getCurrentThread();
  if (!optThread.isPresent())   return;
  if (mPopup == null)   mPopup=new ComponentUtils.ModalPopup(invoker);
  mPopup.add(new ThreadDetails(mPopup,optThread.get()));
  mPopup.showPopup();
}","private void showPopup(final WebToggleButton invoker){
  Optional<KonThread> optThread=ThreadView.this.getCurrentThread();
  if (!optThread.isPresent())   return;
  if (mPopup == null)   mPopup=new ComponentUtils.ModalPopup(invoker);
  mPopup.removeAll();
  mPopup.add(new ThreadDetails(mPopup,optThread.get()));
  mPopup.showPopup();
}",0.966153846153846
80670,"public void setPassword(char[] newPassword) throws KonException {
  byte[] privateKeyData=readBytesFromFile(PRIVATE_KEY_FILENAME);
  char[] oldPassword=mConf.getString(Config.ACC_PASS).toCharArray();
  writePrivateKey(privateKeyData,oldPassword,newPassword);
  mConf.setProperty(Config.ACC_PASS,""String_Node_Str"");
}","public void setPassword(char[] newPassword) throws KonException {
  byte[] privateKeyData=readArmoredFile(PRIVATE_KEY_FILENAME);
  char[] oldPassword=mConf.getString(Config.ACC_PASS).toCharArray();
  writePrivateKey(privateKeyData,oldPassword,newPassword);
  mConf.setProperty(Config.ACC_PASS,""String_Node_Str"");
}",0.9777777777777776
80671,"private PersonalKey load() throws KonException {
  byte[] publicKeyData=readBytesFromFile(PUBLIC_KEY_FILENAME);
  byte[] privateKeyData=readBytesFromFile(PRIVATE_KEY_FILENAME);
  byte[] bridgeCertData=readBytesFromFile(BRIDGE_CERT_FILENAME);
  char[] password=mConf.getString(Config.ACC_PASS).toCharArray();
  try {
    return PersonalKey.load(disarm(privateKeyData),disarm(publicKeyData),password,bridgeCertData);
  }
 catch (  PGPException|IOException|CertificateException|NoSuchProviderException ex) {
    LOGGER.log(Level.WARNING,""String_Node_Str"",ex);
    throw new KonException(KonException.Error.RELOAD_KEY,ex);
  }
}","private PersonalKey load() throws KonException {
  byte[] publicKeyData=readArmoredFile(PUBLIC_KEY_FILENAME);
  byte[] privateKeyData=readArmoredFile(PRIVATE_KEY_FILENAME);
  byte[] bridgeCertData=readFile(BRIDGE_CERT_FILENAME);
  char[] password=mConf.getString(Config.ACC_PASS).toCharArray();
  try {
    mKey=PersonalKey.load(privateKeyData,publicKeyData,password,bridgeCertData);
  }
 catch (  PGPException|IOException|CertificateException|NoSuchProviderException ex) {
    LOGGER.log(Level.WARNING,""String_Node_Str"",ex);
    throw new KonException(KonException.Error.RELOAD_KEY,ex);
  }
  return mKey;
}",0.935064935064935
80672,"public void setNewPassword(char[] oldPassword,char[] newPassword) throws KonException {
  byte[] privateKeyData=readBytesFromFile(PRIVATE_KEY_FILENAME);
  writePrivateKey(privateKeyData,oldPassword,newPassword);
  mConf.setProperty(Config.ACC_PASS,""String_Node_Str"");
}","public void setNewPassword(char[] oldPassword,char[] newPassword) throws KonException {
  byte[] privateKeyData=readArmoredFile(PRIVATE_KEY_FILENAME);
  writePrivateKey(privateKeyData,oldPassword,newPassword);
  mConf.setProperty(Config.ACC_PASS,""String_Node_Str"");
}",0.9738805970149254
80673,"MessageItem(KonMessage message){
  super(message);
  this.setOpaque(false);
  this.setMargin(2);
  WebPanel messagePanel=new WebPanel(true);
  messagePanel.setWebColoredBackground(false);
  messagePanel.setMargin(5);
  if (mValue.getDir().equals(KonMessage.Direction.IN))   messagePanel.setBackground(Color.WHITE);
 else   messagePanel.setBackground(View.LIGHT_BLUE);
  if (mValue.getDir().equals(KonMessage.Direction.IN)) {
    String from=getFromString(mValue);
    WebLabel fromLabel=new WebLabel(""String_Node_Str"" + from);
    fromLabel.setFontSize(12);
    fromLabel.setForeground(Color.BLUE);
    fromLabel.setItalicFont();
    messagePanel.add(fromLabel,BorderLayout.NORTH);
  }
  mContentPanel=new WebPanel();
  mContentPanel.setOpaque(false);
  mTextArea=new WebTextArea();
  mTextArea.setOpaque(false);
  mTextArea.setFontSize(13);
  mContentPanel.add(mTextArea,BorderLayout.CENTER);
  messagePanel.add(mContentPanel,BorderLayout.CENTER);
  WebPanel statusPanel=new WebPanel();
  statusPanel.setOpaque(false);
  statusPanel.setLayout(new FlowLayout(FlowLayout.TRAILING));
  mStatusIconLabel=new WebLabel();
  this.update(null);
  mPreferredTextAreaWidth=mTextArea.getPreferredSize().width;
  mTextArea.setLineWrap(true);
  mTextArea.setWrapStyleWord(true);
  statusPanel.add(mStatusIconLabel);
  WebLabel encryptIconLabel=new WebLabel();
  if (message.getCoderStatus().isSecure()) {
    encryptIconLabel.setIcon(CRYPT_ICON);
  }
 else {
    encryptIconLabel.setIcon(UNENCRYPT_ICON);
  }
  statusPanel.add(encryptIconLabel);
  WebLabel dateLabel=new WebLabel(SHORT_DATE_FORMAT.format(mValue.getDate()));
  dateLabel.setForeground(Color.GRAY);
  dateLabel.setFontSize(11);
  statusPanel.add(dateLabel);
  messagePanel.add(statusPanel,BorderLayout.SOUTH);
  if (mValue.getDir().equals(KonMessage.Direction.IN)) {
    this.add(messagePanel,BorderLayout.WEST);
  }
 else {
    this.add(messagePanel,BorderLayout.EAST);
  }
}","MessageItem(KonMessage message){
  super(message);
  this.setOpaque(false);
  this.setMargin(2);
  WebPanel messagePanel=new WebPanel(true);
  messagePanel.setWebColoredBackground(false);
  messagePanel.setMargin(5);
  if (mValue.getDir().equals(KonMessage.Direction.IN))   messagePanel.setBackground(Color.WHITE);
 else   messagePanel.setBackground(View.LIGHT_BLUE);
  if (mValue.getDir().equals(KonMessage.Direction.IN)) {
    String from=getFromString(mValue);
    WebLabel fromLabel=new WebLabel(""String_Node_Str"" + from);
    fromLabel.setFontSize(12);
    fromLabel.setForeground(Color.BLUE);
    fromLabel.setItalicFont();
    messagePanel.add(fromLabel,BorderLayout.NORTH);
  }
  mContentPanel=new WebPanel();
  mContentPanel.setOpaque(false);
  mTextArea=new WebTextArea();
  mTextArea.setOpaque(false);
  mTextArea.setFontSize(13);
  mContentPanel.add(mTextArea,BorderLayout.CENTER);
  messagePanel.add(mContentPanel,BorderLayout.CENTER);
  WebPanel statusPanel=new WebPanel();
  statusPanel.setOpaque(false);
  statusPanel.setLayout(new FlowLayout(FlowLayout.TRAILING));
  mStatusIconLabel=new WebLabel();
  this.updateView(null);
  mPreferredTextAreaWidth=mTextArea.getPreferredSize().width;
  mTextArea.setLineWrap(true);
  mTextArea.setWrapStyleWord(true);
  statusPanel.add(mStatusIconLabel);
  WebLabel encryptIconLabel=new WebLabel();
  if (message.getCoderStatus().isSecure()) {
    encryptIconLabel.setIcon(CRYPT_ICON);
  }
 else {
    encryptIconLabel.setIcon(UNENCRYPT_ICON);
  }
  statusPanel.add(encryptIconLabel);
  WebLabel dateLabel=new WebLabel(SHORT_DATE_FORMAT.format(mValue.getDate()));
  dateLabel.setForeground(Color.GRAY);
  dateLabel.setFontSize(11);
  statusPanel.add(dateLabel);
  messagePanel.add(statusPanel,BorderLayout.SOUTH);
  if (mValue.getDir().equals(KonMessage.Direction.IN)) {
    this.add(messagePanel,BorderLayout.WEST);
  }
 else {
    this.add(messagePanel,BorderLayout.EAST);
  }
}",0.9989642672190576
80674,"@Override protected void updateOnEDT(Object arg){
  this.update(arg);
  MessageList table=MessageList.this;
  int row;
  for (row=table.getRowCount() - 1; row >= 0; row--)   if (this == table.getModel().getValueAt(row,0))   break;
  table.setHeight(row);
  if (row == table.getRowCount() - 1)   table.mScrollDownOnResize=true;
}","@Override protected void updateOnEDT(Object arg){
  this.updateView(arg);
  MessageList table=MessageList.this;
  int row;
  for (row=table.getRowCount() - 1; row >= 0; row--)   if (this == table.getModel().getValueAt(row,0))   break;
  table.setHeight(row);
  if (row == table.getRowCount() - 1)   table.mScrollDownOnResize=true;
}",0.993939393939394
80675,"Optional<BufferedImage> updateNowOrLater(){
  int width=mParent.getWidth();
  int height=mParent.getHeight();
  if (mCached == null || mCached.getWidth() != width || mCached.getHeight() != height) {
    Image scaledImage=scale(mOrigin,width,height,true);
    if (scaledImage.getWidth(this) != -1)     this.updateCachedBG(scaledImage);
  }
  return Optional.ofNullable(mCached);
}","/** 
 * Update the background image for this parent. Returns immediately, but repaints parent if updating is done asynchronously.
 * @return if synchronized update is possible the updated image, else anold image if present
 */
Optional<BufferedImage> updateNowOrLater(){
  if (mCached == null || mCached.getWidth() != mParent.getWidth() || mCached.getHeight() != mParent.getHeight()) {
    if (this.loadOrigin()) {
      this.scaleOrigin();
    }
  }
  return Optional.ofNullable(mCached);
}",0.3425287356321839
80676,"/** 
 * Scale image down to maximum or minimum of width or height, preserving ratio.
 * @param max specifies if image is scaled to maximum or minimum of width/height
 */
private static Image scale(Image image,int width,int height,boolean max){
  int iw=image.getWidth(null);
  int ih=image.getHeight(null);
  if (max && (iw <= width || ih <= height) || !max && (iw <= width && ih <= height))   return image;
  double sw=width / (iw * 1.0);
  double sh=height / (ih * 1.0);
  double scale=max ? Math.max(sw,sh) : Math.min(sw,sh);
  return image.getScaledInstance((int)(iw * scale),(int)(ih * scale),Image.SCALE_FAST);
}","/** 
 * Scale image down to maximum or minimum of width or height, preserving ratio.
 * @param max specifies if image is scaled to maximum or minimum of width/height
 * @return the scaled image, loaded async
 */
private static Image scale(Image image,int width,int height,boolean max){
  int iw=image.getWidth(null);
  int ih=image.getHeight(null);
  if (iw == -1)   LOGGER.warning(""String_Node_Str"");
  if (max && (iw <= width || ih <= height) || !max && (iw <= width && ih <= height))   return image;
  double sw=width / (iw * 1.0);
  double sh=height / (ih * 1.0);
  double scale=max ? Math.max(sw,sh) : Math.min(sw,sh);
  return image.getScaledInstance((int)(iw * scale),(int)(ih * scale),Image.SCALE_FAST);
}",0.92862509391435
80677,"@Override public boolean imageUpdate(Image img,int infoflags,int x,int y,int w,int h){
  if ((infoflags & ImageObserver.ALLBITS) == 0) {
    return true;
  }
  this.updateCachedBG(img);
  mParent.repaint();
  return false;
}","@Override public boolean imageUpdate(Image img,int infoflags,int x,int y,int w,int h){
  if ((infoflags & ImageObserver.ALLBITS) == 0) {
    return true;
  }
  if (img.equals(mOrigin)) {
    boolean sync=this.scaleOrigin();
    if (sync)     mParent.repaint();
    return false;
  }
 else {
    this.updateCachedBG(img);
    mParent.repaint();
    return false;
  }
}",0.7106598984771574
80678,"private void updateCachedBG(Image scaledImage){
  int width=mParent.getWidth();
  int height=mParent.getHeight();
  mCached=new BufferedImage(width,height,BufferedImage.TYPE_INT_ARGB);
  Graphics2D cachedG=mCached.createGraphics();
  if (mBottomColor != null) {
    GradientPaint p2=new GradientPaint(0,0,new Color(0,0,0,0),0,height,mBottomColor);
    cachedG.setPaint(p2);
    cachedG.fillRect(0,0,width,getHeight());
  }
  int iw=scaledImage.getWidth(this);
  int ih=scaledImage.getHeight(this);
  if (iw > 0 && ih > 0) {
    for (int x=0; x < width; x+=iw) {
      for (int y=0; y < height; y+=ih) {
        cachedG.drawImage(scaledImage,x,y,iw,ih,this);
      }
    }
  }
}","private void updateCachedBG(Image scaledImage){
  int width=mParent.getWidth();
  int height=mParent.getHeight();
  mCached=new BufferedImage(width,height,BufferedImage.TYPE_INT_ARGB);
  Graphics2D cachedG=mCached.createGraphics();
  if (mBottomColor != null) {
    GradientPaint p2=new GradientPaint(0,0,new Color(0,0,0,0),0,height,mBottomColor);
    cachedG.setPaint(p2);
    cachedG.fillRect(0,0,width,getHeight());
  }
  int iw=scaledImage.getWidth(null);
  int ih=scaledImage.getHeight(null);
  for (int x=0; x < width; x+=iw) {
    for (int y=0; y < height; y+=ih) {
      cachedG.drawImage(scaledImage,x,y,iw,ih,null);
    }
  }
}",0.923896499238965
80679,"@Override public void update(Observable o,Object arg){
  SwingUtilities.invokeLater(new Runnable(){
    @Override public void run(){
      MessageView.this.updateOnEDT();
    }
  }
);
}","@Override public void update(Observable o,Object arg){
  if (SwingUtilities.isEventDispatchThread()) {
    this.updateOnEDT();
    return;
  }
  SwingUtilities.invokeLater(new Runnable(){
    @Override public void run(){
      MessageView.this.updateOnEDT();
    }
  }
);
}",0.4235807860262008
80680,"@Override public void update(Observable o,Object arg){
  SwingUtilities.invokeLater(new Runnable(){
    @Override public void run(){
      UserListView.this.updateOnEDT();
    }
  }
);
}","@Override public void update(Observable o,Object arg){
  if (SwingUtilities.isEventDispatchThread()) {
    this.updateOnEDT();
    return;
  }
  SwingUtilities.invokeLater(new Runnable(){
    @Override public void run(){
      UserListView.this.updateOnEDT();
    }
  }
);
}",0.4217391304347826
80681,"@Override public void update(Observable o,final Object arg){
  SwingUtilities.invokeLater(new Runnable(){
    @Override public void run(){
      View.this.updateOnEDT(arg);
    }
  }
);
}","@Override public void update(Observable o,final Object arg){
  if (SwingUtilities.isEventDispatchThread()) {
    this.updateOnEDT(arg);
    return;
  }
  SwingUtilities.invokeLater(new Runnable(){
    @Override public void run(){
      View.this.updateOnEDT(arg);
    }
  }
);
}",0.4559139784946237
80682,"MessageView(KonMessage message){
  mMessage=message;
  this.setOpaque(false);
  this.setMargin(2);
  WebPanel messagePanel=new WebPanel(true);
  messagePanel.setWebColoredBackground(false);
  messagePanel.setMargin(5);
  if (mMessage.getDir().equals(KonMessage.Direction.IN))   messagePanel.setBackground(Color.WHITE);
 else   messagePanel.setBackground(View.LIGHT_BLUE);
  if (mMessage.getDir().equals(KonMessage.Direction.IN)) {
    String from=getFromString(mMessage);
    WebLabel fromLabel=new WebLabel(""String_Node_Str"" + from);
    fromLabel.setFontSize(12);
    fromLabel.setForeground(Color.BLUE);
    fromLabel.setItalicFont();
    messagePanel.add(fromLabel,BorderLayout.NORTH);
  }
  mContentPanel=new WebPanel();
  mContentPanel.setOpaque(false);
  mTextArea=new WebTextArea();
  mTextArea.setOpaque(false);
  mTextArea.setFontSize(13);
  mTextArea.setLineWrap(true);
  mTextArea.setWrapStyleWord(true);
  mContentPanel.add(mTextArea,BorderLayout.CENTER);
  messagePanel.add(mContentPanel,BorderLayout.CENTER);
  WebPanel statusPanel=new WebPanel();
  statusPanel.setOpaque(false);
  statusPanel.setLayout(new FlowLayout(FlowLayout.TRAILING));
  mStatusIconLabel=new WebLabel();
  this.update();
  statusPanel.add(mStatusIconLabel);
  WebLabel encryptIconLabel=new WebLabel();
  if (message.getCoderStatus().isSecure()) {
    encryptIconLabel.setIcon(CRYPT_ICON);
  }
 else {
    encryptIconLabel.setIcon(UNENCRYPT_ICON);
  }
  statusPanel.add(encryptIconLabel);
  WebLabel dateLabel=new WebLabel(SHORT_DATE_FORMAT.format(mMessage.getDate()));
  dateLabel.setForeground(Color.GRAY);
  dateLabel.setFontSize(11);
  statusPanel.add(dateLabel);
  messagePanel.add(statusPanel,BorderLayout.SOUTH);
  if (mMessage.getDir().equals(KonMessage.Direction.IN)) {
    this.add(messagePanel,BorderLayout.WEST);
  }
 else {
    this.add(messagePanel,BorderLayout.EAST);
  }
  mMessage.addObserver(this);
}","MessageView(KonMessage message){
  mMessage=message;
  this.setOpaque(false);
  this.setMargin(2);
  WebPanel messagePanel=new WebPanel(true);
  messagePanel.setWebColoredBackground(false);
  messagePanel.setMargin(5);
  if (mMessage.getDir().equals(KonMessage.Direction.IN))   messagePanel.setBackground(Color.WHITE);
 else   messagePanel.setBackground(View.LIGHT_BLUE);
  if (mMessage.getDir().equals(KonMessage.Direction.IN)) {
    String from=getFromString(mMessage);
    WebLabel fromLabel=new WebLabel(""String_Node_Str"" + from);
    fromLabel.setFontSize(12);
    fromLabel.setForeground(Color.BLUE);
    fromLabel.setItalicFont();
    messagePanel.add(fromLabel,BorderLayout.NORTH);
  }
  mContentPanel=new WebPanel();
  mContentPanel.setOpaque(false);
  mTextArea=new WebTextArea();
  mTextArea.setOpaque(false);
  mTextArea.setFontSize(13);
  mContentPanel.add(mTextArea,BorderLayout.CENTER);
  messagePanel.add(mContentPanel,BorderLayout.CENTER);
  WebPanel statusPanel=new WebPanel();
  statusPanel.setOpaque(false);
  statusPanel.setLayout(new FlowLayout(FlowLayout.TRAILING));
  mStatusIconLabel=new WebLabel();
  this.update();
  mPreferredTextAreaWidth=mTextArea.getPreferredSize().width;
  mTextArea.setLineWrap(true);
  mTextArea.setWrapStyleWord(true);
  statusPanel.add(mStatusIconLabel);
  WebLabel encryptIconLabel=new WebLabel();
  if (message.getCoderStatus().isSecure()) {
    encryptIconLabel.setIcon(CRYPT_ICON);
  }
 else {
    encryptIconLabel.setIcon(UNENCRYPT_ICON);
  }
  statusPanel.add(encryptIconLabel);
  WebLabel dateLabel=new WebLabel(SHORT_DATE_FORMAT.format(mMessage.getDate()));
  dateLabel.setForeground(Color.GRAY);
  dateLabel.setFontSize(11);
  statusPanel.add(dateLabel);
  messagePanel.add(statusPanel,BorderLayout.SOUTH);
  if (mMessage.getDir().equals(KonMessage.Direction.IN)) {
    this.add(messagePanel,BorderLayout.WEST);
  }
 else {
    this.add(messagePanel,BorderLayout.EAST);
  }
  mMessage.addObserver(this);
}",0.9493801652892562
80683,"MessageViewList(KonThread thread){
  super();
  mThread=thread;
  this.setOpaque(false);
  this.addComponentListener(new ComponentAdapter(){
    @Override public void componentResized(    ComponentEvent e){
      MessageViewList table=MessageViewList.this;
      for (int row=0; row < table.getRowCount(); row++) {
        MessageViewList.this.setHeight(row);
      }
    }
  }
);
  this.setSelectionModel(new UnselectableListModel());
  for (  KonMessage message : mThread.getMessages()) {
    this.addMessage(message);
  }
  this.addMouseListener(new MouseAdapter(){
    @Override public void mousePressed(    MouseEvent e){
      check(e);
    }
    @Override public void mouseReleased(    MouseEvent e){
      check(e);
    }
    private void check(    MouseEvent e){
      if (e.isPopupTrigger()) {
        MessageViewList.this.showPopupMenu(e);
      }
    }
  }
);
  mThread.addObserver(this);
}","MessageViewList(KonThread thread){
  super();
  mThread=thread;
  this.setOpaque(false);
  this.addComponentListener(new ComponentAdapter(){
    @Override public void componentResized(    ComponentEvent e){
      MessageViewList table=MessageViewList.this;
      for (int row=0; row < table.getRowCount(); row++) {
        MessageViewList.this.setHeight(row);
      }
      if (mScrollDownOnResize) {
        table.scrollToRow(table.getRowCount() - 1);
        mScrollDownOnResize=false;
      }
    }
  }
);
  this.setSelectionModel(new UnselectableListModel());
  for (  KonMessage message : mThread.getMessages()) {
    this.addMessage(message);
  }
  this.addMouseListener(new MouseAdapter(){
    @Override public void mousePressed(    MouseEvent e){
      check(e);
    }
    @Override public void mouseReleased(    MouseEvent e){
      check(e);
    }
    private void check(    MouseEvent e){
      if (e.isPopupTrigger()) {
        MessageViewList.this.showPopupMenu(e);
      }
    }
  }
);
  mThread.addObserver(this);
}",0.9337474120082816
80684,"@Override public void componentResized(ComponentEvent e){
  MessageViewList table=MessageViewList.this;
  for (int row=0; row < table.getRowCount(); row++) {
    MessageViewList.this.setHeight(row);
  }
}","@Override public void componentResized(ComponentEvent e){
  MessageViewList table=MessageViewList.this;
  for (int row=0; row < table.getRowCount(); row++) {
    MessageViewList.this.setHeight(row);
  }
  if (mScrollDownOnResize) {
    table.scrollToRow(table.getRowCount() - 1);
    mScrollDownOnResize=false;
  }
}",0.7846153846153846
80685,"void showThread(KonThread thread){
  boolean isNew=false;
  if (!mThreadCache.containsKey(thread.getID())) {
    mThreadCache.put(thread.getID(),new MessageViewList(thread));
    isNew=true;
  }
  MessageViewList table=mThreadCache.get(thread.getID());
  this.setViewportView(table);
  if (table.getRowCount() > 0 && isNew) {
    table.scrollToRow(table.getRowCount() - 1);
  }
  mCurrentThreadID=thread.getID();
}","void showThread(KonThread thread){
  boolean isNew=false;
  if (!mThreadCache.containsKey(thread.getID())) {
    mThreadCache.put(thread.getID(),new MessageViewList(thread));
    isNew=true;
  }
  MessageViewList table=mThreadCache.get(thread.getID());
  this.setViewportView(table);
  if (table.getRowCount() > 0 && isNew) {
    table.mScrollDownOnResize=true;
  }
  mCurrentThreadID=thread.getID();
}",0.943627450980392
80686,"private static XMPPTCPConnectionConfiguration buildConfiguration(String resource,EndpointServer server,PrivateKey privateKey,X509Certificate bridgeCert,boolean acceptAnyCertificate){
  XMPPTCPConnectionConfiguration.XMPPTCPConnectionConfigurationBuilder builder=XMPPTCPConnectionConfiguration.builder();
  builder.setHost(server.getHost()).setPort(server.getPort()).setServiceName(server.getNetwork()).setResource(resource).setUsernameAndPassword(null,""String_Node_Str"").setCallbackHandler(new CallbackHandler(){
    @Override public void handle(    Callback[] callbacks) throws IOException, UnsupportedCallbackException {
      for (      Callback cb : callbacks)       LOGGER.info(""String_Node_Str"" + cb);
    }
  }
).setRosterLoadedAtLogin(true).setCompressionEnabled(true).setSecurityMode(SecurityMode.required).setLegacySessionDisabled(true);
  try {
    SSLContext ctx=SSLContext.getInstance(""String_Node_Str"");
    KeyStore keystore=KeyStore.getInstance(KeyStore.getDefaultType());
    keystore.load(null,null);
    keystore.setKeyEntry(""String_Node_Str"",privateKey,new char[0],new Certificate[]{bridgeCert});
    KeyManagerFactory kmFactory=KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());
    kmFactory.init(keystore,new char[0]);
    KeyManager[] km=kmFactory.getKeyManagers();
    SASLAuthentication.blacklistSASLMechanism(""String_Node_Str"");
    TrustManager[] tm;
    if (acceptAnyCertificate) {
      tm=new TrustManager[]{new X509TrustManager(){
        @Override public X509Certificate[] getAcceptedIssuers(){
          return null;
        }
        @Override public void checkServerTrusted(        X509Certificate[] chain,        String authType) throws CertificateException {
        }
        @Override public void checkClientTrusted(        X509Certificate[] chain,        String authType) throws CertificateException {
        }
      }
};
    }
 else {
      TrustManagerFactory tmFactory=TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
      KeyStore ks=KeyStore.getInstance(KeyStore.getDefaultType());
      tmFactory.init(ks);
      tm=tmFactory.getTrustManagers();
    }
    ctx.init(km,tm,null);
    builder.setCustomSSLContext(ctx);
  }
 catch (  NoSuchAlgorithmException|KeyStoreException|IOException|CertificateException|UnrecoverableKeyException|KeyManagementException ex) {
    LOGGER.log(Level.WARNING,""String_Node_Str"",ex);
  }
  return builder.build();
}","private static XMPPTCPConnectionConfiguration buildConfiguration(String resource,EndpointServer server,PrivateKey privateKey,X509Certificate bridgeCert,boolean acceptAnyCertificate){
  XMPPTCPConnectionConfiguration.XMPPTCPConnectionConfigurationBuilder builder=XMPPTCPConnectionConfiguration.builder();
  builder.setHost(server.getHost()).setPort(server.getPort()).setServiceName(server.getNetwork()).setResource(resource).setUsernameAndPassword(null,""String_Node_Str"").setCallbackHandler(new CallbackHandler(){
    @Override public void handle(    Callback[] callbacks) throws IOException, UnsupportedCallbackException {
      for (      Callback cb : callbacks)       LOGGER.info(""String_Node_Str"" + cb);
    }
  }
).setRosterLoadedAtLogin(true).setCompressionEnabled(false).setSecurityMode(SecurityMode.required).setLegacySessionDisabled(true);
  try {
    SSLContext ctx=SSLContext.getInstance(""String_Node_Str"");
    KeyStore keystore=KeyStore.getInstance(KeyStore.getDefaultType());
    keystore.load(null,null);
    keystore.setKeyEntry(""String_Node_Str"",privateKey,new char[0],new Certificate[]{bridgeCert});
    KeyManagerFactory kmFactory=KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());
    kmFactory.init(keystore,new char[0]);
    KeyManager[] km=kmFactory.getKeyManagers();
    SASLAuthentication.blacklistSASLMechanism(""String_Node_Str"");
    TrustManager[] tm;
    if (acceptAnyCertificate) {
      tm=new TrustManager[]{new X509TrustManager(){
        @Override public X509Certificate[] getAcceptedIssuers(){
          return null;
        }
        @Override public void checkServerTrusted(        X509Certificate[] chain,        String authType) throws CertificateException {
        }
        @Override public void checkClientTrusted(        X509Certificate[] chain,        String authType) throws CertificateException {
        }
      }
};
    }
 else {
      TrustManagerFactory tmFactory=TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
      KeyStore ks=KeyStore.getInstance(KeyStore.getDefaultType());
      tmFactory.init(ks);
      tm=tmFactory.getTrustManagers();
    }
    ctx.init(km,tm,null);
    builder.setCustomSSLContext(ctx);
  }
 catch (  NoSuchAlgorithmException|KeyStoreException|IOException|CertificateException|UnrecoverableKeyException|KeyManagementException ex) {
    LOGGER.log(Level.WARNING,""String_Node_Str"",ex);
  }
  return builder.build();
}",0.998566455048126
80687,"private static XMPPTCPConnectionConfiguration buildConfiguration(String resource,EndpointServer server,PrivateKey privateKey,X509Certificate bridgeCert,boolean acceptAnyCertificate){
  XMPPTCPConnectionConfiguration.XMPPTCPConnectionConfigurationBuilder builder=XMPPTCPConnectionConfiguration.builder();
  builder.setHost(server.getHost()).setPort(server.getPort()).setServiceName(server.getNetwork()).setResource(resource).setUsernameAndPassword(null,""String_Node_Str"").setCallbackHandler(new CallbackHandler(){
    @Override public void handle(    Callback[] callbacks) throws IOException, UnsupportedCallbackException {
      for (      Callback cb : callbacks)       LOGGER.info(""String_Node_Str"" + cb);
    }
  }
).setRosterLoadedAtLogin(true).setCompressionEnabled(false).setSecurityMode(SecurityMode.required).setLegacySessionDisabled(true);
  try {
    SSLContext ctx=SSLContext.getInstance(""String_Node_Str"");
    KeyStore keystore=KeyStore.getInstance(KeyStore.getDefaultType());
    keystore.load(null,null);
    keystore.setKeyEntry(""String_Node_Str"",privateKey,new char[0],new Certificate[]{bridgeCert});
    KeyManagerFactory kmFactory=KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());
    kmFactory.init(keystore,new char[0]);
    KeyManager[] km=kmFactory.getKeyManagers();
    SASLAuthentication.blacklistSASLMechanism(""String_Node_Str"");
    TrustManager[] tm;
    if (acceptAnyCertificate) {
      tm=new TrustManager[]{new X509TrustManager(){
        @Override public X509Certificate[] getAcceptedIssuers(){
          return null;
        }
        @Override public void checkServerTrusted(        X509Certificate[] chain,        String authType) throws CertificateException {
        }
        @Override public void checkClientTrusted(        X509Certificate[] chain,        String authType) throws CertificateException {
        }
      }
};
    }
 else {
      TrustManagerFactory tmFactory=TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
      KeyStore ks=KeyStore.getInstance(KeyStore.getDefaultType());
      tmFactory.init(ks);
      tm=tmFactory.getTrustManagers();
    }
    ctx.init(km,tm,null);
    builder.setCustomSSLContext(ctx);
  }
 catch (  NoSuchAlgorithmException|KeyStoreException|IOException|CertificateException|UnrecoverableKeyException|KeyManagementException ex) {
    LOGGER.log(Level.WARNING,""String_Node_Str"",ex);
  }
  return builder.build();
}","private static XMPPTCPConnectionConfiguration buildConfiguration(String resource,EndpointServer server,PrivateKey privateKey,X509Certificate bridgeCert,boolean acceptAnyCertificate){
  XMPPTCPConnectionConfiguration.XMPPTCPConnectionConfigurationBuilder builder=XMPPTCPConnectionConfiguration.builder();
  builder.setHost(server.getHost()).setPort(server.getPort()).setServiceName(server.getNetwork()).setResource(resource).setUsernameAndPassword(null,""String_Node_Str"").setCallbackHandler(new CallbackHandler(){
    @Override public void handle(    Callback[] callbacks) throws IOException, UnsupportedCallbackException {
      for (      Callback cb : callbacks)       LOGGER.info(""String_Node_Str"" + cb);
    }
  }
).setRosterLoadedAtLogin(true).setCompressionEnabled(true).setSecurityMode(SecurityMode.required).setLegacySessionDisabled(true);
  try {
    SSLContext ctx=SSLContext.getInstance(""String_Node_Str"");
    KeyStore keystore=KeyStore.getInstance(KeyStore.getDefaultType());
    keystore.load(null,null);
    keystore.setKeyEntry(""String_Node_Str"",privateKey,new char[0],new Certificate[]{bridgeCert});
    KeyManagerFactory kmFactory=KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());
    kmFactory.init(keystore,new char[0]);
    KeyManager[] km=kmFactory.getKeyManagers();
    SASLAuthentication.blacklistSASLMechanism(""String_Node_Str"");
    TrustManager[] tm;
    if (acceptAnyCertificate) {
      tm=new TrustManager[]{new X509TrustManager(){
        @Override public X509Certificate[] getAcceptedIssuers(){
          return null;
        }
        @Override public void checkServerTrusted(        X509Certificate[] chain,        String authType) throws CertificateException {
        }
        @Override public void checkClientTrusted(        X509Certificate[] chain,        String authType) throws CertificateException {
        }
      }
};
    }
 else {
      TrustManagerFactory tmFactory=TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());
      KeyStore ks=KeyStore.getInstance(KeyStore.getDefaultType());
      tmFactory.init(ks);
      tm=tmFactory.getTrustManagers();
    }
    ctx.init(km,tm,null);
    builder.setCustomSSLContext(ctx);
  }
 catch (  NoSuchAlgorithmException|KeyStoreException|IOException|CertificateException|UnrecoverableKeyException|KeyManagementException ex) {
    LOGGER.log(Level.WARNING,""String_Node_Str"",ex);
  }
  return builder.build();
}",0.998566455048126
80688,"private int insert(){
  Database db=Database.getInstance();
  List<Object> values=new LinkedList<>();
  values.add(mThread.getID());
  values.add(mDir);
  values.add(mUser.getID());
  values.add(mJID);
  values.add(mXMPPID.isEmpty() ? null : mXMPPID);
  values.add(mDate);
  values.add(mReceiptStatus);
  values.add(mReceiptID.isEmpty() ? null : mReceiptID);
  values.add(mContent.toJSONString());
  values.add(mEncryption);
  values.add(mSigning);
  values.add(mCoderErrors);
synchronized (KonMessage.class) {
    if (!mReceiptID.isEmpty()) {
      if (db.execCount(TABLE,""String_Node_Str"",mReceiptID) > 0) {
        LOGGER.info(""String_Node_Str"" + mReceiptID);
        return -1;
      }
    }
    int id=db.execInsert(TABLE,values);
    if (id <= 0)     LOGGER.log(Level.WARNING,""String_Node_Str"");
    return -2;
  }
}","private int insert(){
  Database db=Database.getInstance();
  List<Object> values=new LinkedList<>();
  values.add(mThread.getID());
  values.add(mDir);
  values.add(mUser.getID());
  values.add(mJID);
  values.add(mXMPPID.isEmpty() ? null : mXMPPID);
  values.add(mDate);
  values.add(mReceiptStatus);
  values.add(mReceiptID.isEmpty() ? null : mReceiptID);
  values.add(mContent.toJSONString());
  values.add(mEncryption);
  values.add(mSigning);
  values.add(mCoderErrors);
synchronized (KonMessage.class) {
    if (!mReceiptID.isEmpty()) {
      if (db.execCount(TABLE,""String_Node_Str"",mReceiptID) > 0) {
        LOGGER.info(""String_Node_Str"" + mReceiptID);
        return -1;
      }
    }
    int id=db.execInsert(TABLE,values);
    if (id <= 0) {
      LOGGER.log(Level.WARNING,""String_Node_Str"");
      return -2;
    }
    return id;
  }
}",0.9838420107719928
80689,"/** 
 * Get the number of rows in one table that match a WHERE clause with one 'key' == 'value' condition.
 * @return number of rows for a SELECT/count query, -1 if something went wrong
 */
public int execCount(String table,String key,Object value){
  String select=""String_Node_Str"" + table + ""String_Node_Str""+ key+ ""String_Node_Str"";
  try {
    PreparedStatement stat=mConn.prepareStatement(select);
    setValue(stat,0,value);
    ResultSet resultSet=stat.executeQuery();
    resultSet.last();
    return resultSet.getRow();
  }
 catch (  SQLException ex) {
    LOGGER.log(Level.WARNING,""String_Node_Str"" + select,ex);
    return -1;
  }
}","/** 
 * Get the number of rows in one table that match a WHERE clause with one 'key' == 'value' condition.
 * @return number of rows for a SELECT/count query, -1 if something went wrong
 */
public int execCount(String table,String key,Object value){
  String select=""String_Node_Str"" + table + ""String_Node_Str""+ key+ ""String_Node_Str"";
  try {
    PreparedStatement stat=mConn.prepareStatement(select);
    setValue(stat,0,value);
    ResultSet resultSet=stat.executeQuery();
    return resultSet.getInt(1);
  }
 catch (  SQLException ex) {
    LOGGER.log(Level.WARNING,""String_Node_Str"" + select,ex);
    return -1;
  }
}",0.9629044988161012
80690,"private static String decryptAndVerify(KonMessage message,PersonalKey myKey,PGPPublicKey senderKey){
  String encryptedContent=message.getContent().getEncryptedContent();
  byte[] encryptedData=Base64.decode(encryptedContent);
  PGPObjectFactory pgpFactory=new PGPObjectFactory(encryptedData);
  ByteArrayOutputStream outputStream=new ByteArrayOutputStream();
  try {
    Object o=pgpFactory.nextObject();
    if (!(o instanceof PGPEncryptedDataList)) {
      o=pgpFactory.nextObject();
    }
    if (!(o instanceof PGPEncryptedDataList)) {
      LOGGER.warning(""String_Node_Str"");
      message.addSecurityError(Error.INVALID_DATA);
      return null;
    }
    PGPEncryptedDataList encDataList=(PGPEncryptedDataList)o;
    Iterator<?> it=encDataList.getEncryptedDataObjects();
    PGPPrivateKey sKey=null;
    PGPPublicKeyEncryptedData pbe=null;
    long ourKeyID=myKey.getEncryptKeyPair().getPrivateKey().getKeyID();
    while (sKey == null && it.hasNext()) {
      Object i=it.next();
      if (!(i instanceof PGPPublicKeyEncryptedData))       continue;
      pbe=(PGPPublicKeyEncryptedData)it.next();
      if (pbe.getKeyID() == ourKeyID)       sKey=myKey.getEncryptKeyPair().getPrivateKey();
    }
    if (sKey == null || pbe == null) {
      LOGGER.warning(""String_Node_Str"");
      message.addSecurityError(Error.INVALID_PRIVATE_KEY);
      return null;
    }
    InputStream clear=pbe.getDataStream(new BcPublicKeyDataDecryptorFactory(sKey));
    PGPObjectFactory plainFactory=new PGPObjectFactory(clear);
    Object object=plainFactory.nextObject();
    if (!(object instanceof PGPCompressedData)) {
      LOGGER.warning(""String_Node_Str"");
      message.addSecurityError(Error.INVALID_DATA);
      return null;
    }
    PGPCompressedData cData=(PGPCompressedData)object;
    PGPObjectFactory pgpFact=new PGPObjectFactory(cData.getDataStream());
    object=pgpFact.nextObject();
    PGPOnePassSignature ops=null;
    if (object instanceof PGPOnePassSignatureList) {
      message.setSigning(Signing.SIGNED);
      ops=((PGPOnePassSignatureList)object).get(0);
      ops.init(new BcPGPContentVerifierBuilderProvider(),senderKey);
      object=pgpFact.nextObject();
    }
 else {
      LOGGER.warning(""String_Node_Str"");
      message.setSigning(Signing.NOT);
    }
    if (!(object instanceof PGPLiteralData)) {
      LOGGER.warning(""String_Node_Str"" + object.getClass().getName());
      message.addSecurityError(Error.INVALID_DATA);
      return null;
    }
    PGPLiteralData ld=(PGPLiteralData)object;
    InputStream unc=ld.getInputStream();
    int ch;
    while ((ch=unc.read()) >= 0) {
      outputStream.write(ch);
      if (ops != null)       try {
        ops.update((byte)ch);
      }
 catch (      SignatureException ex) {
        LOGGER.log(Level.WARNING,""String_Node_Str"",ex);
      }
    }
    if (ops != null) {
      object=pgpFact.nextObject();
      if (!(object instanceof PGPSignatureList)) {
        LOGGER.warning(""String_Node_Str"");
        message.addSecurityError(Error.INVALID_SIGNATURE_DATA);
      }
 else {
        PGPSignature signature=((PGPSignatureList)object).get(0);
        boolean verified=false;
        try {
          verified=ops.verify(signature);
        }
 catch (        SignatureException ex) {
          LOGGER.log(Level.WARNING,""String_Node_Str"",ex);
        }
        if (verified) {
          message.setSigning(Signing.VERIFIED);
        }
 else {
          LOGGER.warning(""String_Node_Str"");
          message.addSecurityError(Error.INVALID_SIGNATURE);
        }
      }
    }
    if (pbe.isIntegrityProtected()) {
      if (!pbe.verify()) {
        LOGGER.warning(""String_Node_Str"");
        message.addSecurityError(Error.INVALID_INTEGRITY);
      }
    }
 else {
      LOGGER.warning(""String_Node_Str"");
    }
  }
 catch (  IOException|PGPException ex) {
    LOGGER.log(Level.WARNING,""String_Node_Str"",ex);
    message.addSecurityError(Error.UNKNOWN_ERROR);
  }
  return outputStream.toString();
}","private static String decryptAndVerify(KonMessage message,PersonalKey myKey,PGPPublicKey senderKey){
  String encryptedContent=message.getContent().getEncryptedContent();
  byte[] encryptedData=Base64.decode(encryptedContent);
  PGPObjectFactory pgpFactory=new PGPObjectFactory(encryptedData);
  ByteArrayOutputStream outputStream=new ByteArrayOutputStream();
  try {
    Object o=pgpFactory.nextObject();
    if (!(o instanceof PGPEncryptedDataList)) {
      o=pgpFactory.nextObject();
    }
    if (!(o instanceof PGPEncryptedDataList)) {
      LOGGER.warning(""String_Node_Str"");
      message.addSecurityError(Error.INVALID_DATA);
      return null;
    }
    PGPEncryptedDataList encDataList=(PGPEncryptedDataList)o;
    Iterator<?> it=encDataList.getEncryptedDataObjects();
    PGPPrivateKey sKey=null;
    PGPPublicKeyEncryptedData pbe=null;
    long ourKeyID=myKey.getEncryptKeyPair().getPrivateKey().getKeyID();
    while (sKey == null && it.hasNext()) {
      Object i=it.next();
      if (!(i instanceof PGPPublicKeyEncryptedData))       continue;
      pbe=(PGPPublicKeyEncryptedData)i;
      if (pbe.getKeyID() == ourKeyID)       sKey=myKey.getEncryptKeyPair().getPrivateKey();
    }
    if (sKey == null || pbe == null) {
      LOGGER.warning(""String_Node_Str"");
      message.addSecurityError(Error.INVALID_PRIVATE_KEY);
      return null;
    }
    InputStream clear=pbe.getDataStream(new BcPublicKeyDataDecryptorFactory(sKey));
    PGPObjectFactory plainFactory=new PGPObjectFactory(clear);
    Object object=plainFactory.nextObject();
    if (!(object instanceof PGPCompressedData)) {
      LOGGER.warning(""String_Node_Str"");
      message.addSecurityError(Error.INVALID_DATA);
      return null;
    }
    PGPCompressedData cData=(PGPCompressedData)object;
    PGPObjectFactory pgpFact=new PGPObjectFactory(cData.getDataStream());
    object=pgpFact.nextObject();
    PGPOnePassSignature ops=null;
    if (object instanceof PGPOnePassSignatureList) {
      message.setSigning(Signing.SIGNED);
      ops=((PGPOnePassSignatureList)object).get(0);
      ops.init(new BcPGPContentVerifierBuilderProvider(),senderKey);
      object=pgpFact.nextObject();
    }
 else {
      LOGGER.warning(""String_Node_Str"");
      message.setSigning(Signing.NOT);
    }
    if (!(object instanceof PGPLiteralData)) {
      LOGGER.warning(""String_Node_Str"" + object.getClass().getName());
      message.addSecurityError(Error.INVALID_DATA);
      return null;
    }
    PGPLiteralData ld=(PGPLiteralData)object;
    InputStream unc=ld.getInputStream();
    int ch;
    while ((ch=unc.read()) >= 0) {
      outputStream.write(ch);
      if (ops != null)       try {
        ops.update((byte)ch);
      }
 catch (      SignatureException ex) {
        LOGGER.log(Level.WARNING,""String_Node_Str"",ex);
      }
    }
    if (ops != null) {
      object=pgpFact.nextObject();
      if (!(object instanceof PGPSignatureList)) {
        LOGGER.warning(""String_Node_Str"");
        message.addSecurityError(Error.INVALID_SIGNATURE_DATA);
      }
 else {
        PGPSignature signature=((PGPSignatureList)object).get(0);
        boolean verified=false;
        try {
          verified=ops.verify(signature);
        }
 catch (        SignatureException ex) {
          LOGGER.log(Level.WARNING,""String_Node_Str"",ex);
        }
        if (verified) {
          message.setSigning(Signing.VERIFIED);
        }
 else {
          LOGGER.warning(""String_Node_Str"");
          message.addSecurityError(Error.INVALID_SIGNATURE);
        }
      }
    }
    if (pbe.isIntegrityProtected()) {
      if (!pbe.verify()) {
        LOGGER.warning(""String_Node_Str"");
        message.addSecurityError(Error.INVALID_INTEGRITY);
      }
    }
 else {
      LOGGER.warning(""String_Node_Str"");
    }
  }
 catch (  IOException|PGPException ex) {
    LOGGER.log(Level.WARNING,""String_Node_Str"",ex);
    message.addSecurityError(Error.UNKNOWN_ERROR);
  }
  return outputStream.toString();
}",0.998989898989899
80691,"public void changed(){
  this.setChanged();
  this.notifyObservers();
}","public synchronized void changed(){
  this.setChanged();
  this.notifyObservers();
}",0.9161290322580644
80692,"OutMessage(KonThread thread,User user,String text,boolean encrypted){
  super(thread,Direction.IN,new Date(),text,user,user.getJID(),Packet.nextID());
  mReceiptStatus=KonMessage.Status.PENDING;
  mReceiptID=null;
  if (encrypted) {
    mEncryption=Coder.Encryption.ENCRYPTED;
    mSigning=Coder.Signing.SIGNED;
  }
 else {
    mEncryption=Coder.Encryption.NOT;
    mSigning=Coder.Signing.NOT;
  }
}","OutMessage(KonThread thread,User user,String text,boolean encrypted){
  super(thread,Direction.OUT,new Date(),text,user,user.getJID(),Packet.nextID());
  mReceiptStatus=KonMessage.Status.PENDING;
  mReceiptID=null;
  if (encrypted) {
    mEncryption=Coder.Encryption.ENCRYPTED;
    mSigning=Coder.Signing.SIGNED;
  }
 else {
    mEncryption=Coder.Encryption.NOT;
    mSigning=Coder.Signing.NOT;
  }
}",0.9937421777221528
80693,"public void connect(){
  Account account=Account.getInstance();
  try {
    account.reload();
  }
 catch (  KonException ex) {
    this.handleException(ex);
    return;
  }
  List args=new ArrayList(1);
  args.add(account.getPersonalKey());
  Client.TASK_QUEUE.offer(new Client.Task(Client.Command.CONNECT,args));
}","public void connect(){
  Account account=Account.getInstance();
  try {
    account.reload();
  }
 catch (  KonException ex) {
    this.handleException(ex);
    return;
  }
  mClient.connect(account.getPersonalKey());
}",0.6816479400749064
80694,"public Task(Command c,List a){
  command=c;
  args=a;
}","Task(Command c,List a){
  command=c;
  args=a;
}",0.9320388349514565
80695,"@Override public void run(){
  while (true) {
    Task t;
    try {
      t=TASK_QUEUE.take();
    }
 catch (    InterruptedException ex) {
      LOGGER.log(Level.WARNING,""String_Node_Str"",ex);
      return;
    }
switch (t.command) {
case CONNECT:
      this.connect((PersonalKey)t.args.get(0));
    break;
case DISCONNECT:
  this.disconnect();
break;
}
}
}","@Override public void run(){
  while (true) {
    Task t;
    try {
      t=TASK_QUEUE.take();
    }
 catch (    InterruptedException ex) {
      LOGGER.log(Level.WARNING,""String_Node_Str"",ex);
      return;
    }
switch (t.command) {
case CONNECT:
      this.connectAsync();
    break;
case DISCONNECT:
  this.disconnect();
break;
}
}
}",0.9553956834532374
80696,"private void connect(PersonalKey key){
  this.disconnect();
  mModel.statusChanged(Kontalk.Status.CONNECTING);
  String network=mConfig.getString(""String_Node_Str"");
  String host=mConfig.getString(""String_Node_Str"");
  int port=mConfig.getInt(""String_Node_Str"");
  EndpointServer Server=new EndpointServer(network,host,port);
synchronized (this) {
    try {
      mConn=new KonConnection(Server,key.getBridgePrivateKey(),key.getBridgeCertificate());
    }
 catch (    XMPPException|PGPException ex) {
      LOGGER.log(Level.WARNING,""String_Node_Str"",ex);
      mModel.statusChanged(Kontalk.Status.FAILED);
      mModel.handleException(new KonException(KonException.Error.CLIENT_CONNECTION,ex));
      return;
    }
    LOGGER.info(""String_Node_Str"");
    try {
      mConn.connect();
    }
 catch (    XMPPException|SmackException|IOException ex) {
      LOGGER.log(Level.WARNING,""String_Node_Str"",ex);
      mModel.statusChanged(Kontalk.Status.FAILED);
      mModel.handleException(new KonException(KonException.Error.CLIENT_CONNECT,ex));
      return;
    }
    System.out.println(""String_Node_Str"");
    RosterListener rl=new KonRosterListener(mConn.getRoster(),this);
    mConn.getRoster().addRosterListener(rl);
    PacketFilter messageFilter=new PacketTypeFilter(Message.class);
    mConn.addPacketListener(new MessageListener(this),messageFilter);
    PacketFilter vCardFilter=new PacketTypeFilter(VCard4.class);
    mConn.addPacketListener(new VCardListener(),vCardFilter);
    PacketFilter blockingCommandFilter=new PacketTypeFilter(BlockingCommand.class);
    mConn.addPacketListener(new BlockingCommandListener(),blockingCommandFilter);
    mConn.addPacketListener(this,new AndFilter(new NotFilter(messageFilter),new NotFilter(vCardFilter),new NotFilter(blockingCommandFilter)));
    try {
      mConn.login(""String_Node_Str"",""String_Node_Str"");
    }
 catch (    XMPPException|SmackException|IOException ex) {
      LOGGER.log(Level.WARNING,""String_Node_Str"",ex);
      mModel.statusChanged(Kontalk.Status.FAILED);
      mModel.handleException(new KonException(KonException.Error.CLIENT_LOGIN,ex));
      return;
    }
  }
  LOGGER.info(""String_Node_Str"");
  this.sendPresence();
  this.sendBlocklistRequest();
  mModel.statusChanged(Kontalk.Status.CONNECTED);
}","public void connect(PersonalKey key){
  this.disconnect();
  mModel.statusChanged(Kontalk.Status.CONNECTING);
  String network=mConfig.getString(""String_Node_Str"");
  String host=mConfig.getString(""String_Node_Str"");
  int port=mConfig.getInt(""String_Node_Str"");
  EndpointServer Server=new EndpointServer(network,host,port);
  try {
    mConn=new KonConnection(Server,key.getBridgePrivateKey(),key.getBridgeCertificate());
  }
 catch (  XMPPException|PGPException ex) {
    LOGGER.log(Level.WARNING,""String_Node_Str"",ex);
    mModel.statusChanged(Kontalk.Status.FAILED);
    mModel.handleException(new KonException(KonException.Error.CLIENT_CONNECTION,ex));
    return;
  }
  RosterListener rl=new KonRosterListener(mConn.getRoster(),this);
  mConn.getRoster().addRosterListener(rl);
  PacketFilter messageFilter=new PacketTypeFilter(Message.class);
  mConn.addPacketListener(new MessageListener(this),messageFilter);
  PacketFilter vCardFilter=new PacketTypeFilter(VCard4.class);
  mConn.addPacketListener(new VCardListener(),vCardFilter);
  PacketFilter blockingCommandFilter=new PacketTypeFilter(BlockingCommand.class);
  mConn.addPacketListener(new BlockingCommandListener(),blockingCommandFilter);
  mConn.addPacketListener(this,new AndFilter(new NotFilter(messageFilter),new NotFilter(vCardFilter),new NotFilter(blockingCommandFilter)));
  List args=new ArrayList(0);
  Client.TASK_QUEUE.offer(new Client.Task(Client.Command.CONNECT,args));
}",0.6095596133190118
80697,"private void update(){
switch (mMessage.getStatus()) {
case PENDING:
    mStatusIconLabel.setIcon(PENDING_ICON);
  break;
case SENT:
mStatusIconLabel.setIcon(SENT_ICON);
break;
case RECEIVED:
mStatusIconLabel.setIcon(DELIVERED_ICON);
break;
}
doRepaint();
}","private void update(){
switch (mMessage.getStatus()) {
case PENDING:
    mStatusIconLabel.setIcon(PENDING_ICON);
  break;
case SENT:
mStatusIconLabel.setIcon(SENT_ICON);
break;
case RECEIVED:
mStatusIconLabel.setIcon(DELIVERED_ICON);
break;
}
}",0.9740518962075848
80698,"MessageViewList(KonThread thread){
  mThread=thread;
  mThread.addListener(this);
  this.setOpaque(false);
  this.setModel(mListModel);
  this.setCellRenderer(new MessageListRenderer());
  this.setSelectionModel(new DefaultListSelectionModel(){
    @Override public void setSelectionInterval(    int index0,    int index1){
    }
    @Override public void addSelectionInterval(    int index0,    int index1){
    }
  }
);
}","MessageViewList(KonThread thread){
  mThread=thread;
  mThread.addListener(this);
  this.setOpaque(false);
  this.setModel(mListModel);
  this.setCellRenderer(new MessageListRenderer());
  this.addComponentListener(new ComponentAdapter(){
    @Override public void componentResized(    ComponentEvent e){
      recache();
    }
  }
);
  this.setSelectionModel(new DefaultListSelectionModel(){
    @Override public void setSelectionInterval(    int index0,    int index1){
    }
    @Override public void addSelectionInterval(    int index0,    int index1){
    }
  }
);
  this.update();
  if (!mListModel.isEmpty())   this.ensureIndexIsVisible(mListModel.getSize() - 1);
}",0.7726027397260274
80699,"MessageView(KonMessage message){
  mMessage=message;
  mMessage.addListener(this);
  this.setOpaque(false);
  this.setMargin(2);
  WebPanel messagePanel=new WebPanel(true);
  messagePanel.setMargin(1);
  if (mMessage.getDir().equals(KonMessage.Direction.IN)) {
    WebLabel fromLabel=new WebLabel(mMessage.getJID().substring(0,8));
    fromLabel.setFontSize(12);
    fromLabel.setForeground(Color.BLUE);
    fromLabel.setItalicFont();
    messagePanel.add(fromLabel,BorderLayout.NORTH);
  }
  mTextArea=new WebTextArea(mMessage.getText());
  mTextArea.setOpaque(false);
  mTextArea.setFontSize(13);
  mPreferredTextAreaWidth=mTextArea.getPreferredSize().width;
  mTextArea.setLineWrap(true);
  mTextArea.setWrapStyleWord(true);
  messagePanel.add(mTextArea,BorderLayout.CENTER);
  WebPanel statusPanel=new WebPanel();
  statusPanel.setOpaque(false);
  statusPanel.setLayout(new FlowLayout(FlowLayout.TRAILING));
  mStatusIconLabel=new WebLabel();
  update();
  statusPanel.add(mStatusIconLabel);
  WebLabel encryptIconLabel=new WebLabel();
  if (message.isEncrypted()) {
    encryptIconLabel.setIcon(CRYPT_ICON);
  }
 else {
    encryptIconLabel.setIcon(UNENCRYPT_ICON);
  }
  statusPanel.add(encryptIconLabel);
  SimpleDateFormat dateFormat=new SimpleDateFormat(""String_Node_Str"");
  WebLabel dateLabel=new WebLabel(dateFormat.format(mMessage.getDate()));
  dateLabel.setForeground(Color.GRAY);
  dateLabel.setFontSize(11);
  statusPanel.add(dateLabel);
  messagePanel.add(statusPanel,BorderLayout.SOUTH);
  if (mMessage.getDir().equals(KonMessage.Direction.IN)) {
    this.add(messagePanel,BorderLayout.WEST);
  }
 else {
    this.add(messagePanel,BorderLayout.EAST);
  }
}","MessageView(KonMessage message){
  mMessage=message;
  mMessage.addListener(this);
  this.setOpaque(false);
  this.setMargin(2);
  WebPanel messagePanel=new WebPanel(true);
  messagePanel.setMargin(1);
  if (mMessage.getDir().equals(KonMessage.Direction.IN)) {
    String from;
    if (mMessage.getUser().getName() != null) {
      from=mMessage.getUser().getName();
    }
 else {
      from=mMessage.getJID();
      if (from.length() > 40)       from=from.substring(0,8);
    }
    WebLabel fromLabel=new WebLabel(""String_Node_Str"" + from);
    fromLabel.setFontSize(12);
    fromLabel.setForeground(Color.BLUE);
    fromLabel.setItalicFont();
    messagePanel.add(fromLabel,BorderLayout.NORTH);
  }
  mTextArea=new WebTextArea(mMessage.getText());
  mTextArea.setOpaque(false);
  mTextArea.setFontSize(13);
  mPreferredTextAreaWidth=mTextArea.getPreferredSize().width;
  mTextArea.setLineWrap(true);
  mTextArea.setWrapStyleWord(true);
  messagePanel.add(mTextArea,BorderLayout.CENTER);
  WebPanel statusPanel=new WebPanel();
  statusPanel.setOpaque(false);
  statusPanel.setLayout(new FlowLayout(FlowLayout.TRAILING));
  mStatusIconLabel=new WebLabel();
  update();
  statusPanel.add(mStatusIconLabel);
  WebLabel encryptIconLabel=new WebLabel();
  if (message.isEncrypted()) {
    encryptIconLabel.setIcon(CRYPT_ICON);
  }
 else {
    encryptIconLabel.setIcon(UNENCRYPT_ICON);
  }
  statusPanel.add(encryptIconLabel);
  SimpleDateFormat dateFormat=new SimpleDateFormat(""String_Node_Str"");
  WebLabel dateLabel=new WebLabel(dateFormat.format(mMessage.getDate()));
  dateLabel.setForeground(Color.GRAY);
  dateLabel.setFontSize(11);
  statusPanel.add(dateLabel);
  messagePanel.add(statusPanel,BorderLayout.SOUTH);
  if (mMessage.getDir().equals(KonMessage.Direction.IN)) {
    this.add(messagePanel,BorderLayout.WEST);
  }
 else {
    this.add(messagePanel,BorderLayout.EAST);
  }
}",0.9235955056179777
80700,"private void resize(int listWidth){
  int maxWidth=(int)(listWidth * 0.8);
  int width=Math.min(mPreferredTextAreaWidth,maxWidth);
  mTextArea.setSize(width,Short.MAX_VALUE);
}","private void resize(int listWidth){
  int maxWidth=(int)(listWidth * 0.8);
  int width=Math.min(mPreferredTextAreaWidth,maxWidth);
  mTextArea.setSize(width,mTextArea.getPreferredSize().height);
}",0.8817204301075269
80701,"@Override public void stateChanged(ChangeEvent e){
  update();
}","@Override public void stateChanged(ChangeEvent e){
  update();
  doRepaint();
}",0.8951048951048951
80702,"void showThread(KonThread thread){
  if (thread == null)   return;
  if (!mThreadCache.containsKey(thread.getID())) {
    mThreadCache.put(thread.getID(),new MessageViewList(thread));
  }
  MessageViewList list=mThreadCache.get(thread.getID());
  this.setViewportView(list);
  list.update();
  list.update();
  mCurrentThreadID=thread.getID();
}","void showThread(KonThread thread){
  if (!mThreadCache.containsKey(thread.getID())) {
    mThreadCache.put(thread.getID(),new MessageViewList(thread));
  }
  MessageViewList list=mThreadCache.get(thread.getID());
  this.setViewportView(list);
  mCurrentThreadID=thread.getID();
}",0.8878205128205128
80703,"void selectThreadByUser(User user){
  if (user == null) {
    mThreadView.showThread(null);
  }
 else {
    KonThread thread=ThreadList.getInstance().getThreadByUser(user);
    mThreadListView.selectThread(thread.getID());
    mMainFrame.selectTab(MainFrame.Tab.THREADS);
    mThreadView.showThread(thread);
  }
}","void selectThreadByUser(User user){
  if (user == null)   return;
  KonThread thread=ThreadList.getInstance().getThreadByUser(user);
  mThreadListView.selectThread(thread.getID());
  mMainFrame.selectTab(MainFrame.Tab.THREADS);
  mThreadView.showThread(thread);
}",0.8784722222222222
80704,"private static boolean containsAnyJavaType(TypeInfo type){
  if (type instanceof ParameterizedTypeInfo) {
    return ((ParameterizedTypeInfo)type).getArgs().stream().anyMatch(MethodInfo::containsAnyJavaType);
  }
 else {
    return type.getKind() == ClassKind.OTHER;
  }
}","private static boolean containsAnyJavaType(TypeInfo type){
  if (type instanceof ParameterizedTypeInfo) {
    return containsAnyJavaType(type.getRaw()) || ((ParameterizedTypeInfo)type).getArgs().stream().anyMatch(MethodInfo::containsAnyJavaType);
  }
 else {
    return type.getKind() == ClassKind.OTHER;
  }
}",0.9347079037800688
80705,"@Test public void testValidJavaTypeParams() throws Exception {
  ClassModel model=new GeneratorHelper().generateClass(MethodWithValidJavaTypeParams.class);
  assertEquals(4,model.getMethods().size());
  MethodInfo method=model.getMethods().get(0);
  checkMethod(method,""String_Node_Str"",4,""String_Node_Str"",MethodKind.OTHER);
  List<ParamInfo> params=method.getParams();
  checkParam(params.get(0),""String_Node_Str"",new TypeLiteral<Socket>(){
  }
);
  checkParam(params.get(1),""String_Node_Str"",new TypeLiteral<List<Socket>>(){
  }
);
  checkParam(params.get(2),""String_Node_Str"",new TypeLiteral<Set<Socket>>(){
  }
);
  checkParam(params.get(3),""String_Node_Str"",new TypeLiteral<Map<String,Socket>>(){
  }
);
  assertTrue(method.isContainingAnyJavaType());
  method=model.getMethods().get(1);
  checkMethod(method,""String_Node_Str"",4,""String_Node_Str"",MethodKind.HANDLER);
  params=method.getParams();
  checkParam(params.get(0),""String_Node_Str"",new TypeLiteral<Handler<Socket>>(){
  }
);
  checkParam(params.get(1),""String_Node_Str"",new TypeLiteral<Handler<List<Socket>>>(){
  }
);
  checkParam(params.get(2),""String_Node_Str"",new TypeLiteral<Handler<Set<Socket>>>(){
  }
);
  checkParam(params.get(3),""String_Node_Str"",new TypeLiteral<Handler<Map<String,Socket>>>(){
  }
);
  assertTrue(method.isContainingAnyJavaType());
  method=model.getMethods().get(2);
  checkMethod(method,""String_Node_Str"",4,""String_Node_Str"",MethodKind.FUTURE);
  params=method.getParams();
  checkParam(params.get(0),""String_Node_Str"",new TypeLiteral<Handler<AsyncResult<Socket>>>(){
  }
);
  checkParam(params.get(1),""String_Node_Str"",new TypeLiteral<Handler<AsyncResult<List<Socket>>>>(){
  }
);
  checkParam(params.get(2),""String_Node_Str"",new TypeLiteral<Handler<AsyncResult<Set<Socket>>>>(){
  }
);
  checkParam(params.get(3),""String_Node_Str"",new TypeLiteral<Handler<AsyncResult<Map<String,Socket>>>>(){
  }
);
  assertTrue(method.isContainingAnyJavaType());
  method=model.getMethods().get(3);
  checkMethod(method,""String_Node_Str"",4,""String_Node_Str"",MethodKind.OTHER);
  params=method.getParams();
  checkParam(params.get(0),""String_Node_Str"",new TypeLiteral<Function<Socket,Socket>>(){
  }
);
  checkParam(params.get(1),""String_Node_Str"",new TypeLiteral<Function<List<Socket>,List<Socket>>>(){
  }
);
  checkParam(params.get(2),""String_Node_Str"",new TypeLiteral<Function<Set<Socket>,Set<Socket>>>(){
  }
);
  checkParam(params.get(3),""String_Node_Str"",new TypeLiteral<Function<Map<String,Socket>,Map<String,Socket>>>(){
  }
);
  assertTrue(method.isContainingAnyJavaType());
}","@Test public void testValidJavaTypeParams() throws Exception {
  ClassModel model=new GeneratorHelper().generateClass(MethodWithValidJavaTypeParams.class);
  assertEquals(5,model.getMethods().size());
  MethodInfo method=model.getMethods().get(0);
  checkMethod(method,""String_Node_Str"",4,""String_Node_Str"",MethodKind.OTHER);
  List<ParamInfo> params=method.getParams();
  checkParam(params.get(0),""String_Node_Str"",new TypeLiteral<Socket>(){
  }
);
  checkParam(params.get(1),""String_Node_Str"",new TypeLiteral<List<Socket>>(){
  }
);
  checkParam(params.get(2),""String_Node_Str"",new TypeLiteral<Set<Socket>>(){
  }
);
  checkParam(params.get(3),""String_Node_Str"",new TypeLiteral<Map<String,Socket>>(){
  }
);
  assertTrue(method.isContainingAnyJavaType());
  method=model.getMethods().get(1);
  checkMethod(method,""String_Node_Str"",4,""String_Node_Str"",MethodKind.HANDLER);
  params=method.getParams();
  checkParam(params.get(0),""String_Node_Str"",new TypeLiteral<Handler<Socket>>(){
  }
);
  checkParam(params.get(1),""String_Node_Str"",new TypeLiteral<Handler<List<Socket>>>(){
  }
);
  checkParam(params.get(2),""String_Node_Str"",new TypeLiteral<Handler<Set<Socket>>>(){
  }
);
  checkParam(params.get(3),""String_Node_Str"",new TypeLiteral<Handler<Map<String,Socket>>>(){
  }
);
  assertTrue(method.isContainingAnyJavaType());
  method=model.getMethods().get(2);
  checkMethod(method,""String_Node_Str"",4,""String_Node_Str"",MethodKind.FUTURE);
  params=method.getParams();
  checkParam(params.get(0),""String_Node_Str"",new TypeLiteral<Handler<AsyncResult<Socket>>>(){
  }
);
  checkParam(params.get(1),""String_Node_Str"",new TypeLiteral<Handler<AsyncResult<List<Socket>>>>(){
  }
);
  checkParam(params.get(2),""String_Node_Str"",new TypeLiteral<Handler<AsyncResult<Set<Socket>>>>(){
  }
);
  checkParam(params.get(3),""String_Node_Str"",new TypeLiteral<Handler<AsyncResult<Map<String,Socket>>>>(){
  }
);
  assertTrue(method.isContainingAnyJavaType());
  method=model.getMethods().get(3);
  checkMethod(method,""String_Node_Str"",4,""String_Node_Str"",MethodKind.OTHER);
  params=method.getParams();
  checkParam(params.get(0),""String_Node_Str"",new TypeLiteral<Function<Socket,Socket>>(){
  }
);
  checkParam(params.get(1),""String_Node_Str"",new TypeLiteral<Function<List<Socket>,List<Socket>>>(){
  }
);
  checkParam(params.get(2),""String_Node_Str"",new TypeLiteral<Function<Set<Socket>,Set<Socket>>>(){
  }
);
  checkParam(params.get(3),""String_Node_Str"",new TypeLiteral<Function<Map<String,Socket>,Map<String,Socket>>>(){
  }
);
  assertTrue(method.isContainingAnyJavaType());
  method=model.getMethods().get(4);
  checkMethod(method,""String_Node_Str"",1,""String_Node_Str"",MethodKind.OTHER);
  params=method.getParams();
  checkParam(params.get(0),""String_Node_Str"",new TypeLiteral<Iterable<String>>(){
  }
);
  assertTrue(method.isContainingAnyJavaType());
}",0.9479128186183968
80706,"private static <T>List<T> fromArray(JsonObject obj,String name,Function<Object,T> converter){
  JsonArray array=obj.getJsonArray(name);
  if (array != null) {
    List<?> list=array.getList();
    return list.stream().map(converter).collect(Collectors.toList());
  }
 else {
    return null;
  }
}","private static <T>List<T> fromArray(JsonObject obj,String name,Function<Object,T> converter){
  JsonArray array=obj.getJsonArray(name);
  if (array != null) {
    return array.stream().map(converter).collect(Collectors.toList());
  }
 else {
    return null;
  }
}",0.6381461675579323
80707,"private static <T>Map<String,T> fromObject(JsonObject obj,String name,Function<Object,T> converter){
  JsonObject array=obj.getJsonObject(name);
  if (array != null) {
    Map<String,Object> map=array.getMap();
    map.entrySet().forEach(entry -> entry.setValue(converter.apply(entry.getValue())));
    return (Map<String,T>)map;
  }
 else {
    return null;
  }
}","private static <T>Map<String,T> fromObject(JsonObject obj,String name,Function<Object,T> converter){
  JsonObject array=obj.getJsonObject(name);
  if (array != null) {
    return array.stream().collect(Collectors.toMap(entry -> entry.getKey(),entry -> converter.apply(entry.getValue())));
  }
 else {
    return null;
  }
}",0.5443959243085881
80708,"public DataObjectWithLists(JsonObject json){
  booleanValues=fromArray(json,""String_Node_Str"");
  shortValues=fromArray(json,""String_Node_Str"",o -> Short.parseShort(o.toString()));
  integerValues=fromArray(json,""String_Node_Str"");
  longValues=fromArray(json,""String_Node_Str"",o -> Long.parseLong(o.toString()));
  floatValues=fromArray(json,""String_Node_Str"",o -> Float.parseFloat(o.toString()));
  doubleValues=fromArray(json,""String_Node_Str"");
  stringValues=fromArray(json,""String_Node_Str"");
  jsonObjectValues=fromArray(json,""String_Node_Str"",o -> new JsonObject((Map<String,Object>)o));
  jsonArrayValues=fromArray(json,""String_Node_Str"",o -> new JsonArray((List)o));
  dataObjectValues=fromArray(json,""String_Node_Str"",o -> new TestDataObject(new JsonObject((Map<String,Object>)o)));
  enumValues=fromArray(json,""String_Node_Str"",o -> TestEnum.valueOf(o.toString()));
  genEnumValues=fromArray(json,""String_Node_Str"",o -> TestGenEnum.valueOf(o.toString()));
}","public DataObjectWithLists(JsonObject json){
  booleanValues=fromArray(json,""String_Node_Str"");
  shortValues=fromArray(json,""String_Node_Str"",o -> Short.parseShort(o.toString()));
  integerValues=fromArray(json,""String_Node_Str"");
  longValues=fromArray(json,""String_Node_Str"",o -> Long.parseLong(o.toString()));
  floatValues=fromArray(json,""String_Node_Str"",o -> Float.parseFloat(o.toString()));
  doubleValues=fromArray(json,""String_Node_Str"");
  stringValues=fromArray(json,""String_Node_Str"");
  jsonObjectValues=fromArray(json,""String_Node_Str"",o -> (JsonObject)o);
  jsonArrayValues=fromArray(json,""String_Node_Str"",o -> (JsonArray)o);
  dataObjectValues=fromArray(json,""String_Node_Str"",o -> new TestDataObject((JsonObject)o));
  enumValues=fromArray(json,""String_Node_Str"",o -> TestEnum.valueOf(o.toString()));
  genEnumValues=fromArray(json,""String_Node_Str"",o -> TestGenEnum.valueOf(o.toString()));
}",0.8106382978723404
80709,"public DataObjectWithMaps(JsonObject json){
  booleanValues=fromObject(json,""String_Node_Str"");
  shortValues=fromObject(json,""String_Node_Str"",o -> Short.parseShort(o.toString()));
  integerValues=fromObject(json,""String_Node_Str"");
  longValues=fromObject(json,""String_Node_Str"",o -> Long.parseLong(o.toString()));
  floatValues=fromObject(json,""String_Node_Str"",o -> Float.parseFloat(o.toString()));
  doubleValues=fromObject(json,""String_Node_Str"");
  stringValues=fromObject(json,""String_Node_Str"");
  jsonObjectValues=fromObject(json,""String_Node_Str"",o -> new JsonObject((Map<String,Object>)o));
  jsonArrayValues=fromObject(json,""String_Node_Str"",o -> new JsonArray((List)o));
  dataObjectValues=fromObject(json,""String_Node_Str"",o -> new TestDataObject(new JsonObject((Map<String,Object>)o)));
  enumValues=fromObject(json,""String_Node_Str"",o -> TestEnum.valueOf(o.toString()));
  genEnumValues=fromObject(json,""String_Node_Str"",o -> TestGenEnum.valueOf(o.toString()));
}","public DataObjectWithMaps(JsonObject json){
  booleanValues=fromObject(json,""String_Node_Str"");
  shortValues=fromObject(json,""String_Node_Str"",o -> Short.parseShort(o.toString()));
  integerValues=fromObject(json,""String_Node_Str"");
  longValues=fromObject(json,""String_Node_Str"",o -> Long.parseLong(o.toString()));
  floatValues=fromObject(json,""String_Node_Str"",o -> Float.parseFloat(o.toString()));
  doubleValues=fromObject(json,""String_Node_Str"");
  stringValues=fromObject(json,""String_Node_Str"");
  jsonObjectValues=fromObject(json,""String_Node_Str"",o -> (JsonObject)o);
  jsonArrayValues=fromObject(json,""String_Node_Str"",o -> (JsonArray)o);
  dataObjectValues=fromObject(json,""String_Node_Str"",o -> new TestDataObject((JsonObject)o));
  enumValues=fromObject(json,""String_Node_Str"",o -> TestEnum.valueOf(o.toString()));
  genEnumValues=fromObject(json,""String_Node_Str"",o -> TestGenEnum.valueOf(o.toString()));
}",0.9600420609884333
80710,"public TypeArgExpression resolveTypeArg(TypeVariableInfo typeVar){
  for (  TypeParamInfo.Method typeParam : typeParams) {
    if (typeParam.getName().equals(typeVar.getName())) {
      for (      ParamInfo param : params) {
        if (param.getType().getKind() == ClassKind.CLASS_TYPE && param.getType().isParameterized()) {
          TypeInfo arg_=((ParameterizedTypeInfo)param.getType()).getArg(0);
          if (arg_.isVariable()) {
            TypeVariableInfo ttt=(TypeVariableInfo)arg_;
            if (ttt.getParam().equals(typeParam)) {
              return new TypeArgExpression(TypeArgExpression.CLASS_TYPE_ARG,ttt,param,0);
            }
          }
        }
 else         if (param.getType().getKind() == ClassKind.API && param.getType().isParameterized()) {
          ParameterizedTypeInfo type=(ParameterizedTypeInfo)param.getType();
          int index=0;
          for (          TypeInfo i : type.getArgs()) {
            if (i instanceof TypeVariableInfo) {
              TypeVariableInfo tt=(TypeVariableInfo)i;
              if (tt.isClassParam() && tt.getParam().equals(typeParam)) {
                return new TypeArgExpression(TypeArgExpression.CLASS_TYPE_ARG,tt,param,index);
              }
            }
            index++;
          }
        }
      }
      return null;
    }
  }
  return null;
}","public TypeArgExpression resolveTypeArg(TypeVariableInfo typeVar){
  for (  TypeParamInfo.Method typeParam : typeParams) {
    if (typeParam.getName().equals(typeVar.getName())) {
      for (      ParamInfo param : params) {
        if (param.getType().getKind() == ClassKind.CLASS_TYPE && param.getType().isParameterized()) {
          TypeInfo arg_=((ParameterizedTypeInfo)param.getType()).getArg(0);
          if (arg_.isVariable()) {
            TypeVariableInfo ttt=(TypeVariableInfo)arg_;
            if (ttt.getParam().equals(typeParam)) {
              return new TypeArgExpression(TypeArgExpression.CLASS_TYPE_ARG,ttt,param,0);
            }
          }
        }
 else         if (param.getType().getKind() == ClassKind.API && param.getType().isParameterized()) {
          ParameterizedTypeInfo type=(ParameterizedTypeInfo)param.getType();
          int index=0;
          for (          TypeInfo i : type.getArgs()) {
            if (i instanceof TypeVariableInfo) {
              TypeVariableInfo tt=(TypeVariableInfo)i;
              if (tt.getParam().equals(typeParam)) {
                return new TypeArgExpression(TypeArgExpression.API_ARG,tt,param,index);
              }
            }
            index++;
          }
        }
      }
      return null;
    }
  }
  return null;
}",0.9878326996197718
80711,"/** 
 * Load a template given its   {@code source}.
 * @param source the template source
 * @return the compiled template
 */
public static CompiledTemplate loadCompiled(InputStream source){
  String template;
  try (Scanner scanner=new Scanner(source,""String_Node_Str"").useDelimiter(""String_Node_Str"")){
    template=scanner.next();
  }
   template=template.replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str"");
  ClassLoader currentCL=Thread.currentThread().getContextClassLoader();
  Thread.currentThread().setContextClassLoader(TemplateRuntime.class.getClassLoader());
  try {
    return TemplateCompiler.compileTemplate(template);
  }
  finally {
    Thread.currentThread().setContextClassLoader(currentCL);
  }
}","/** 
 * Load a template given its   {@code source}.
 * @param source the template source
 * @return the compiled template
 */
public static CompiledTemplate loadCompiled(InputStream source){
  String template;
  try (Scanner scanner=new Scanner(source,""String_Node_Str"").useDelimiter(""String_Node_Str"")){
    template=scanner.next();
  }
   template=template.replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",System.getProperty(""String_Node_Str"")).replace(""String_Node_Str"",""String_Node_Str"");
  ClassLoader currentCL=Thread.currentThread().getContextClassLoader();
  Thread.currentThread().setContextClassLoader(TemplateRuntime.class.getClassLoader());
  try {
    return TemplateCompiler.compileTemplate(template);
  }
  finally {
    Thread.currentThread().setContextClassLoader(currentCL);
  }
}",0.960960960960961
80712,"@Override public String format(Iterable<String> atoms){
  StringBuilder sb=new StringBuilder();
  Iterator<String> it=atoms.iterator();
  while (it.hasNext()) {
    String atom=it.next();
    if (atom.length() > 0) {
      sb.append(atom.toLowerCase());
      break;
    }
  }
  while (it.hasNext()) {
    String atom=it.next();
    if (atom.length() > 0) {
      char c=atom.charAt(0);
      if (Character.isLowerCase(c)) {
        sb.append(Character.toUpperCase(c));
        sb.append(atom,1,atom.length());
      }
 else {
        sb.append(atom);
      }
      break;
    }
  }
  return sb.toString();
}","@Override public String format(Iterable<String> atoms){
  StringBuilder sb=new StringBuilder();
  Iterator<String> it=atoms.iterator();
  while (it.hasNext()) {
    String atom=it.next();
    if (atom.length() > 0) {
      sb.append(atom.toLowerCase());
      break;
    }
  }
  while (it.hasNext()) {
    String atom=it.next();
    if (atom.length() > 0) {
      char c=atom.charAt(0);
      if (Character.isLowerCase(c)) {
        sb.append(Character.toUpperCase(c));
        sb.append(atom,1,atom.length());
      }
 else {
        sb.append(atom);
      }
    }
  }
  return sb.toString();
}",0.9891936824605154
80713,"@Test public void testFormatLowerCamelCase(){
  formatLowerCamelCase(""String_Node_Str"",""String_Node_Str"");
  formatLowerCamelCase(""String_Node_Str"",""String_Node_Str"");
  formatLowerCamelCase(""String_Node_Str"",""String_Node_Str"");
  formatLowerCamelCase(""String_Node_Str"",""String_Node_Str"");
  formatLowerCamelCase(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  formatLowerCamelCase(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  formatLowerCamelCase(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  formatLowerCamelCase(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
}","@Test public void testFormatLowerCamelCase(){
  formatLowerCamelCase(""String_Node_Str"",""String_Node_Str"");
  formatLowerCamelCase(""String_Node_Str"",""String_Node_Str"");
  formatLowerCamelCase(""String_Node_Str"",""String_Node_Str"");
  formatLowerCamelCase(""String_Node_Str"",""String_Node_Str"");
  formatLowerCamelCase(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  formatLowerCamelCase(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  formatLowerCamelCase(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  formatLowerCamelCase(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  formatLowerCamelCase(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
}",0.9298626174981924
80714,"@Override public boolean process(Set<? extends TypeElement> annotations,RoundEnvironment roundEnv){
  if (!roundEnv.processingOver()) {
    Collection<CodeGenerator> codeGenerators=getCodeGenerators();
    if (!roundEnv.errorRaised()) {
      CodeGen codegen=new CodeGen(processingEnv,roundEnv);
      codegen.getModels().forEach(entry -> {
        try {
          Model model=entry.getValue();
          if (outputDirectory != null) {
            Map<String,Object> vars=new HashMap<>();
            vars.put(""String_Node_Str"",new Helper());
            vars.put(""String_Node_Str"",processingEnv.getOptions());
            vars.put(""String_Node_Str"",File.separator);
            vars.put(""String_Node_Str"",model.getFqn());
            vars.put(""String_Node_Str"",model.getModule());
            vars.put(""String_Node_Str"",model);
            vars.putAll(model.getVars());
            for (            CodeGenerator codeGenerator : codeGenerators) {
              if (codeGenerator.kind.equals(model.getKind())) {
                String relativeName=(String)MVEL.executeExpression(codeGenerator.filenameExpr,vars);
                if (relativeName != null) {
                  if (relativeName.endsWith(""String_Node_Str"") && !relativeName.contains(""String_Node_Str"")) {
                    String fqn=relativeName.substring(0,relativeName.length() - ""String_Node_Str"".length());
                    if (processingEnv.getElementUtils().getTypeElement(fqn) != null) {
                      return;
                    }
                    JavaFileObject target=processingEnv.getFiler().createSourceFile(fqn);
                    String output=codeGenerator.transformTemplate.render(model);
                    try (Writer writer=target.openWriter()){
                      writer.append(output);
                    }
                   }
 else {
                    File target=new File(outputDirectory,relativeName).getAbsoluteFile();
                    if (codeGenerator.incremental) {
                      List<ModelProcessing> processings=generatedFiles.computeIfAbsent(target,GeneratedFile::new);
                      processings.add(new ModelProcessing(model,codeGenerator));
                    }
 else {
                      codeGenerator.transformTemplate.apply(model,target);
                    }
                  }
                  log.info(""String_Node_Str"" + model.getFqn() + ""String_Node_Str""+ relativeName);
                }
              }
            }
          }
 else {
            log.info(""String_Node_Str"" + model.getFqn());
          }
        }
 catch (        GenException e) {
          reportGenException(e);
        }
catch (        Exception e) {
          reportException(e,entry.getKey());
        }
      }
);
    }
  }
 else {
    generatedFiles.values().forEach(generated -> {
      try (FileWriter fileWriter=new FileWriter(generated.file)){
        for (int i=0; i < generated.size(); i++) {
          ModelProcessing processing=generated.get(i);
          Map<String,Object> vars=new HashMap<>();
          vars.put(""String_Node_Str"",i);
          vars.put(""String_Node_Str"",generated.size());
          vars.put(""String_Node_Str"",generated.session);
          try {
            String part=processing.generator.transformTemplate.render(processing.model,vars);
            fileWriter.append(part);
          }
 catch (          GenException e) {
            reportGenException(e);
          }
catch (          Exception e) {
            reportException(e,processing.model.getElement());
          }
        }
      }
 catch (      Exception e) {
        reportException(e,generated.get(0).model.getElement());
      }
    }
);
  }
  return true;
}","@Override public boolean process(Set<? extends TypeElement> annotations,RoundEnvironment roundEnv){
  if (!roundEnv.processingOver()) {
    Collection<CodeGenerator> codeGenerators=getCodeGenerators();
    if (!roundEnv.errorRaised()) {
      CodeGen codegen=new CodeGen(processingEnv,roundEnv);
      codegen.getModels().forEach(entry -> {
        try {
          Model model=entry.getValue();
          if (outputDirectory != null) {
            Map<String,Object> vars=new HashMap<>();
            vars.put(""String_Node_Str"",new Helper());
            vars.put(""String_Node_Str"",processingEnv.getOptions());
            vars.put(""String_Node_Str"",File.separator);
            vars.put(""String_Node_Str"",model.getFqn());
            vars.put(""String_Node_Str"",model.getModule());
            vars.put(""String_Node_Str"",model);
            vars.putAll(model.getVars());
            for (            CodeGenerator codeGenerator : codeGenerators) {
              if (codeGenerator.kind.equals(model.getKind())) {
                String relativeName=(String)MVEL.executeExpression(codeGenerator.filenameExpr,vars);
                if (relativeName != null) {
                  if (relativeName.endsWith(""String_Node_Str"") && !relativeName.contains(""String_Node_Str"")) {
                    String fqn=relativeName.substring(0,relativeName.length() - ""String_Node_Str"".length());
                    if (processingEnv.getElementUtils().getTypeElement(fqn) != null) {
                      return;
                    }
                    JavaFileObject target=processingEnv.getFiler().createSourceFile(fqn);
                    String output=codeGenerator.transformTemplate.render(model);
                    try (Writer writer=target.openWriter()){
                      writer.append(output);
                    }
                   }
 else {
                    File target=new File(outputDirectory,relativeName).getAbsoluteFile();
                    if (codeGenerator.incremental) {
                      List<ModelProcessing> processings=generatedFiles.computeIfAbsent(target,GeneratedFile::new);
                      processings.add(new ModelProcessing(model,codeGenerator));
                    }
 else {
                      codeGenerator.transformTemplate.apply(model,target);
                    }
                  }
                  log.info(""String_Node_Str"" + model.getFqn() + ""String_Node_Str""+ relativeName);
                }
              }
            }
          }
 else {
            log.info(""String_Node_Str"" + model.getFqn());
          }
        }
 catch (        GenException e) {
          reportGenException(e);
        }
catch (        Exception e) {
          reportException(e,entry.getKey());
        }
      }
);
    }
  }
 else {
    generatedFiles.values().forEach(generated -> {
      File file=generated.file;
      Helper.ensureParentDir(file);
      try (FileWriter fileWriter=new FileWriter(file)){
        for (int i=0; i < generated.size(); i++) {
          ModelProcessing processing=generated.get(i);
          Map<String,Object> vars=new HashMap<>();
          vars.put(""String_Node_Str"",i);
          vars.put(""String_Node_Str"",generated.size());
          vars.put(""String_Node_Str"",generated.session);
          try {
            String part=processing.generator.transformTemplate.render(processing.model,vars);
            fileWriter.append(part);
          }
 catch (          GenException e) {
            reportGenException(e);
          }
catch (          Exception e) {
            reportException(e,processing.model.getElement());
          }
        }
      }
 catch (      Exception e) {
        reportException(e,generated.get(0).model.getElement());
      }
    }
);
  }
  return true;
}",0.989516129032258
80715,"public void apply(Model model,File outputFile) throws Exception {
  String output=render(model,new HashMap<>());
  if (!outputFile.getParentFile().exists()) {
    outputFile.getParentFile().mkdirs();
  }
  try (PrintStream outStream=new PrintStream(new FileOutputStream(outputFile))){
    outStream.print(output);
    outStream.flush();
  }
 }","public void apply(Model model,File outputFile) throws Exception {
  String output=render(model,new HashMap<>());
  Helper.ensureParentDir(outputFile);
  try (PrintStream outStream=new PrintStream(new FileOutputStream(outputFile))){
    outStream.print(output);
    outStream.flush();
  }
 }",0.8278041074249605
80716,"private void processMethod(ExecutableElement methodElt){
  String methodName=methodElt.getSimpleName().toString();
  if (methodName.length() > 3) {
    String prefix=methodName.substring(0,3);
    String name=Helper.normalizePropertyName(methodName.substring(3));
    List<? extends VariableElement> parameters=methodElt.getParameters();
switch (prefix) {
case ""String_Node_Str"":
case ""String_Node_Str"":
{
        if (parameters.size() != 1) {
          return;
        }
        VariableElement parameterElt=parameters.get(0);
        TypeInfo type=typeFactory.create(parameterElt.asType());
        boolean array;
        boolean adder;
        if (""String_Node_Str"".equals(prefix)) {
          if (name.endsWith(""String_Node_Str"")) {
            throw new GenException(methodElt,""String_Node_Str"");
          }
 else {
            name+=""String_Node_Str"";
          }
          array=true;
          adder=true;
        }
 else {
          adder=false;
          if (type.getKind() == ClassKind.LIST) {
            type=((TypeInfo.Parameterized)type).getArgs().get(0);
            array=true;
          }
 else {
            array=false;
          }
        }
switch (type.getKind()) {
case PRIMITIVE:
case BOXED_PRIMITIVE:
case STRING:
case DATA_OBJECT:
case API:
case JSON_OBJECT:
          break;
default :
        return;
    }
    Function<Boolean,Stream<ExecutableElement>> overridenMethods=(annotated) -> {
      LinkedList<TypeMirror> superTypes=new LinkedList<>(modelElt.getInterfaces());
      if (modelElt.getSuperclass() != null) {
        superTypes.addFirst(modelElt.getSuperclass());
      }
      return superTypes.stream().flatMap(Helper.instanceOf(DeclaredType.class)).map(DeclaredType::asElement).filter(superTypeElt -> !annotated || superTypeElt.getAnnotation(DataObject.class) != null).flatMap(Helper.cast(TypeElement.class)).flatMap(superTypeElt -> elementUtils.getAllMembers(superTypeElt).stream()).flatMap(Helper.instanceOf(ExecutableElement.class)).filter(executableElt -> executableElt.getKind() == ElementKind.METHOD && elementUtils.overrides(methodElt,executableElt,modelElt));
    }
;
    boolean declared;
    Element ownerElt=methodElt.getEnclosingElement();
    if (ownerElt.equals(modelElt)) {
      declared=overridenMethods.apply(true).count() == 0;
    }
 else {
      declared=ownerElt.getAnnotation(DataObject.class) == null;
    }
    Doc doc=docFactory.createDoc(methodElt);
    if (doc == null) {
      Optional<Doc> first=overridenMethods.apply(false).map(docFactory::createDoc).filter(d -> d != null).findFirst();
      doc=first.orElse(null);
    }
    PropertyInfo property=new PropertyInfo(declared,name,doc,type,methodName,array,adder);
    propertyMap.put(property.name,property);
  }
}
}
}","private void processMethod(ExecutableElement methodElt){
  String methodName=methodElt.getSimpleName().toString();
  if (methodName.length() > 3) {
    String prefix=methodName.substring(0,3);
    String name=Helper.normalizePropertyName(methodName.substring(3));
    List<? extends VariableElement> parameters=methodElt.getParameters();
switch (prefix) {
case ""String_Node_Str"":
case ""String_Node_Str"":
{
        if (parameters.size() != 1) {
          return;
        }
        VariableElement parameterElt=parameters.get(0);
        TypeInfo type=typeFactory.create(parameterElt.asType());
        boolean array;
        boolean adder;
        if (""String_Node_Str"".equals(prefix)) {
          if (name.endsWith(""String_Node_Str"")) {
            throw new GenException(methodElt,""String_Node_Str"");
          }
 else {
            name+=""String_Node_Str"";
          }
          array=true;
          adder=true;
        }
 else {
          adder=false;
          if (type.getKind() == ClassKind.LIST) {
            type=((TypeInfo.Parameterized)type).getArgs().get(0);
            array=true;
          }
 else {
            array=false;
          }
        }
switch (type.getKind()) {
case PRIMITIVE:
case BOXED_PRIMITIVE:
case STRING:
case DATA_OBJECT:
case API:
case JSON_OBJECT:
          break;
default :
        return;
    }
    Function<Boolean,Stream<ExecutableElement>> overridenMethods=(annotated) -> {
      Set<DeclaredType> ancestorTypes=Helper.resolveAncestorTypes(modelElt);
      return ancestorTypes.stream().map(DeclaredType::asElement).filter(superTypeElt -> !annotated || superTypeElt.getAnnotation(DataObject.class) != null).flatMap(Helper.cast(TypeElement.class)).flatMap(superTypeElt -> elementUtils.getAllMembers(superTypeElt).stream()).flatMap(Helper.instanceOf(ExecutableElement.class)).filter(executableElt -> executableElt.getKind() == ElementKind.METHOD && elementUtils.overrides(methodElt,executableElt,modelElt));
    }
;
    boolean declared;
    Element ownerElt=methodElt.getEnclosingElement();
    if (ownerElt.equals(modelElt)) {
      declared=overridenMethods.apply(true).count() == 0;
    }
 else {
      declared=ownerElt.getAnnotation(DataObject.class) == null;
    }
    Doc doc=docFactory.createDoc(methodElt);
    if (doc == null) {
      Optional<Doc> first=overridenMethods.apply(false).map(docFactory::createDoc).filter(d -> d != null).findFirst();
      doc=first.orElse(null);
    }
    PropertyInfo property=new PropertyInfo(declared,name,doc,type,methodName,array,adder);
    propertyMap.put(property.name,property);
  }
}
}
}",0.943630214205186
80717,"@Test public void testUncommentedPropertyOverridesCommentedProperty() throws Exception {
  DataObjectModel model=new Generator().generateDataObject(UncommentedPropertyOverridesCommentedProperty.class,AbstractCommentedProperty.class);
  PropertyInfo propertyInfo=model.getPropertyMap().get(""String_Node_Str"");
  Doc propertyDoc=propertyInfo.getDoc();
  assertEquals(""String_Node_Str"",propertyDoc.getFirstSentence().getValue());
}","@Test public void testUncommentedPropertyOverridesCommentedProperty() throws Exception {
  DataObjectModel model=new Generator().generateDataObject(UncommentedPropertyOverridesSuperCommentedProperty.class,AbstractCommentedProperty.class);
  PropertyInfo propertyInfo=model.getPropertyMap().get(""String_Node_Str"");
  Doc propertyDoc=propertyInfo.getDoc();
  assertEquals(""String_Node_Str"",propertyDoc.getFirstSentence().getValue());
}",0.994192799070848
80718,TestInterface method();,"static TestInterface method(){
  return new TestInterfaceImpl();
}",0.5168539325842697
80719,"Window findTargetWindow(Window window,LayoutElement layout);","@Nullable Window findTargetWindow(Window window,LayoutElement layout);",0.9230769230769232
80720,"private static Window currentWindowIn(LayoutElement windowLayout){
  return find(Directions.allWindowsIn(windowLayout),new Condition<Window>(){
    @Override public boolean value(    Window window){
      return window.isCurrent;
    }
  }
);
}","@Nullable private static Window currentWindowIn(LayoutElement windowLayout){
  return find(Directions.allWindowsIn(windowLayout),new Condition<Window>(){
    @Override public boolean value(    Window window){
      return window.isCurrent;
    }
  }
);
}",0.9799196787148594
80721,"public void moveFocus(Directions.Direction direction){
  LayoutElement layout=calculateAndSetPositions(ide.snapshotWindowLayout());
  if (layout == LayoutElement.none)   return;
  Window window=currentWindowIn(layout);
  Window targetWindow=direction.findTargetWindow(window,layout);
  ide.setFocusOn(targetWindow);
}","public void moveFocus(Directions.Direction direction){
  LayoutElement layout=calculateAndSetPositions(ide.snapshotWindowLayout());
  if (layout == LayoutElement.none)   return;
  Window window=currentWindowIn(layout);
  if (window == null)   return;
  Window targetWindow=direction.findTargetWindow(window,layout);
  if (targetWindow == null)   return;
  ide.setFocusOn(targetWindow);
}",0.9005681818181818
80722,"/** 
 * Moves tab in the specified direction. This is way more complicated than it should have been. The main reasons are: - closing/opening or opening/closing tab doesn't guarantee that focus will be in the moved tab => need to track target window to move focus into it - EditorWindow object changes its identity after split/unsplit (i.e. points to another visual window) => need to predict target window position and look up window by expected position
 */
public void moveTab(Directions.Direction direction){
  LayoutElement layout=calculateAndSetPositions(ide.snapshotWindowLayout());
  if (layout == LayoutElement.none)   return;
  Window window=currentWindowIn(layout);
  Window targetWindow=direction.findTargetWindow(window,layout);
  Position newPosition;
  boolean isAtEdge=(targetWindow == null);
  if (isAtEdge) {
    if (window.hasOneTab || !direction.canExpand())     return;
    LayoutElement newLayout=insertSplit(direction.splitOrientation(),window,layout);
    calculateAndSetPositions(newLayout);
    LayoutElement sibling=findSiblingOf(window,newLayout);
    if (sibling == null)     return;
    newPosition=sibling.position;
    ide.createSplitter(direction.splitOrientation());
    ide.closeCurrentFileIn(window);
  }
 else {
    boolean willBeUnsplit=window.hasOneTab;
    if (willBeUnsplit) {
      LayoutElement unsplitLayout=removeFrom(layout,window);
      calculateAndSetPositions(unsplitLayout);
    }
    newPosition=targetWindow.position;
    ide.openCurrentFileIn(targetWindow);
    ide.closeCurrentFileIn(window);
  }
  LayoutElement newWindowLayout=calculateAndSetPositions(ide.snapshotWindowLayout());
  targetWindow=findWindowBy(newPosition,newWindowLayout);
  if (targetWindow == null) {
    logger.warn(""String_Node_Str"" + newPosition);
  }
 else {
    ide.setFocusOn(targetWindow);
  }
}","/** 
 * Moves tab in the specified direction. This is way more complicated than it should have been. The main reasons are: - closing/opening or opening/closing tab doesn't guarantee that focus will be in the moved tab => need to track target window to move focus into it - EditorWindow object changes its identity after split/unsplit (i.e. points to another visual window) => need to predict target window position and look up window by expected position
 */
public void moveTab(Directions.Direction direction){
  LayoutElement layout=calculateAndSetPositions(ide.snapshotWindowLayout());
  if (layout == LayoutElement.none)   return;
  Window window=currentWindowIn(layout);
  if (window == null)   return;
  Window targetWindow=direction.findTargetWindow(window,layout);
  Position newPosition;
  boolean isAtEdge=(targetWindow == null);
  if (isAtEdge) {
    if (window.hasOneTab || !direction.canExpand())     return;
    LayoutElement newLayout=insertSplit(direction.splitOrientation(),window,layout);
    calculateAndSetPositions(newLayout);
    LayoutElement sibling=findSiblingOf(window,newLayout);
    if (sibling == null)     return;
    newPosition=sibling.position;
    ide.createSplitter(direction.splitOrientation());
    ide.closeCurrentFileIn(window);
  }
 else {
    boolean willBeUnsplit=window.hasOneTab;
    if (willBeUnsplit) {
      LayoutElement unsplitLayout=removeFrom(layout,window);
      calculateAndSetPositions(unsplitLayout);
    }
    newPosition=targetWindow.position;
    ide.openCurrentFileIn(targetWindow);
    ide.closeCurrentFileIn(window);
  }
  LayoutElement newWindowLayout=calculateAndSetPositions(ide.snapshotWindowLayout());
  targetWindow=findWindowBy(newPosition,newWindowLayout);
  if (targetWindow == null) {
    logger.warn(""String_Node_Str"" + newPosition);
  }
 else {
    ide.setFocusOn(targetWindow);
  }
}",0.991313789359392
80723,"private static Window findWindowBy(final Position position,LayoutElement layout){
  return find(Directions.allWindowsIn(layout),new Condition<Window>(){
    @Override public boolean value(    Window window){
      return position.equals(window.position);
    }
  }
);
}","@Nullable private static Window findWindowBy(final Position position,LayoutElement layout){
  return find(Directions.allWindowsIn(layout),new Condition<Window>(){
    @Override public boolean value(    Window window){
      return position.equals(window.position);
    }
  }
);
}",0.9817518248175182
80724,"@Override public String getUrl(){
  if (this.getParameters != null && !this.getParameters.isEmpty()) {
    Uri.Builder builder=Uri.parse(super.getUrl()).buildUpon();
    for (    Map.Entry<String,Object> entry : this.getParameters.entrySet()) {
      Object entryValue=entry.getValue();
      String entryKey=entry.getKey();
      if (entryValue == null) {
        builder.appendQueryParameter(entryKey,null);
        break;
      }
      if (entryValue instanceof Collection) {
        Collection items=(Collection)entryValue;
        for (        Object item : items) {
          if (item == null) {
            builder.appendQueryParameter(entryKey,null);
          }
 else {
            builder.appendQueryParameter(entryKey,entryValue.toString());
          }
        }
      }
 else {
        builder.appendQueryParameter(entryKey,entryValue.toString());
      }
    }
    String urlString=builder.build().toString();
    return urlString;
  }
 else {
    return super.getUrl();
  }
}","@Override public String getUrl(){
  if (this.getParameters != null && !this.getParameters.isEmpty()) {
    Uri.Builder builder=Uri.parse(super.getUrl()).buildUpon();
    for (    Map.Entry<String,Object> entry : this.getParameters.entrySet()) {
      Object entryValue=entry.getValue();
      String entryKey=entry.getKey();
      if (entryValue == null) {
        builder.appendQueryParameter(entryKey,null);
        break;
      }
      if (entryValue instanceof Collection) {
        Collection items=(Collection)entryValue;
        for (        Object item : items) {
          if (item == null) {
            builder.appendQueryParameter(entryKey,null);
          }
 else {
            builder.appendQueryParameter(entryKey,item.toString());
          }
        }
      }
 else {
        builder.appendQueryParameter(entryKey,entryValue.toString());
      }
    }
    String urlString=builder.build().toString();
    return urlString;
  }
 else {
    return super.getUrl();
  }
}",0.8024316109422492
80725,"@Override protected VolleyError parseNetworkError(VolleyError volleyError){
  VolleyError error=super.parseNetworkError(volleyError);
  this.result=new ResponseData();
  if (volleyError.networkResponse != null) {
    this.result.headers=new HashMap<String,String>(volleyError.networkResponse.headers);
    this.result.statusCode=volleyError.networkResponse.statusCode;
    if (this.errorResponseClasSpecifier != null) {
      Response<ResponseData> result=this.responseHandler.parseNetworkResponse(volleyError.networkResponse,responseClasSpecifier);
      this.result.parsedErrorResponse=result.result;
    }
  }
  this.result.error=error;
  return error;
}","@Override protected VolleyError parseNetworkError(VolleyError volleyError){
  VolleyError error=super.parseNetworkError(volleyError);
  this.result=new ResponseData();
  if (volleyError.networkResponse != null) {
    this.result.headers=new HashMap<String,String>(volleyError.networkResponse.headers);
    this.result.statusCode=volleyError.networkResponse.statusCode;
    if (this.errorResponseClasSpecifier != null) {
      Response<ResponseData> result=this.responseHandler.parseNetworkResponse(volleyError.networkResponse,errorResponseClasSpecifier);
      this.result.parsedErrorResponse=result.result;
    }
  }
  this.result.error=error;
  return error;
}",0.9946929492039424
80726,"public void outputEnergy(){
  for (  EnumFacing facing : EnumFacing.values()) {
    if (currentStorage > 0) {
      TileEntity entity=worldObj.getTileEntity(pos.offset(facing));
      if (entity != null) {
        if (entity.hasCapability(CapabilityEnergy.ENERGY,facing.getOpposite())) {
          IEnergyStorage energy=entity.getCapability(CapabilityEnergy.ENERGY,facing);
          if (energy.canReceive()) {
            int giveAmount=energy.receiveEnergy(currentStorage,false);
            if (giveAmount > 0) {
              changeCharge(giveAmount * -1);
            }
          }
        }
 else         if (entity instanceof IEnergyReceiver) {
          IEnergyReceiver energy=(IEnergyReceiver)entity;
          if (energy.canConnectEnergy(facing.getOpposite())) {
            int giveAmount=energy.receiveEnergy(facing.getOpposite(),currentStorage,false);
            if (giveAmount > 0) {
              changeCharge(giveAmount * -1);
            }
          }
        }
      }
    }
  }
}","public void outputEnergy(){
  for (  EnumFacing facing : EnumFacing.values()) {
    if (currentStorage > 0) {
      TileEntity entity=worldObj.getTileEntity(pos.offset(facing));
      if (entity != null) {
        if (entity.hasCapability(CapabilityEnergy.ENERGY,facing.getOpposite())) {
          IEnergyStorage energy=entity.getCapability(CapabilityEnergy.ENERGY,facing.getOpposite());
          if (energy.canReceive()) {
            int giveAmount=energy.receiveEnergy(currentStorage,false);
            if (giveAmount > 0) {
              changeCharge(giveAmount * -1);
            }
          }
        }
 else         if (entity instanceof IEnergyReceiver) {
          IEnergyReceiver energy=(IEnergyReceiver)entity;
          if (energy.canConnectEnergy(facing.getOpposite())) {
            int giveAmount=energy.receiveEnergy(facing.getOpposite(),currentStorage,false);
            if (giveAmount > 0) {
              changeCharge(giveAmount * -1);
            }
          }
        }
      }
    }
  }
}",0.993041749502982
80727,"public void outputEnergy(){
  for (  EnumFacing facing : EnumFacing.values()) {
    if (currentStorage > 0) {
      TileEntity entity=worldObj.getTileEntity(pos.offset(facing));
      if (entity != null) {
        if (entity.hasCapability(CapabilityEnergy.ENERGY,facing.getOpposite())) {
          IEnergyStorage energy=entity.getCapability(CapabilityEnergy.ENERGY,facing);
          if (energy.canReceive()) {
            int giveAmount=energy.receiveEnergy(currentStorage,false);
            if (giveAmount > 0) {
              changeCharge(giveAmount * -1);
            }
          }
        }
 else         if (entity instanceof IEnergyReceiver) {
          IEnergyReceiver energy=(IEnergyReceiver)entity;
          if (energy.canConnectEnergy(facing.getOpposite())) {
            int giveAmount=energy.receiveEnergy(facing.getOpposite(),currentStorage,false);
            if (giveAmount > 0) {
              changeCharge(giveAmount * -1);
            }
          }
        }
      }
    }
  }
}","public void outputEnergy(){
  for (  EnumFacing facing : EnumFacing.values()) {
    if (currentStorage > 0) {
      TileEntity entity=worldObj.getTileEntity(pos.offset(facing));
      if (entity != null) {
        if (entity.hasCapability(CapabilityEnergy.ENERGY,facing.getOpposite())) {
          IEnergyStorage energy=entity.getCapability(CapabilityEnergy.ENERGY,facing.getOpposite());
          if (energy.canReceive()) {
            int giveAmount=energy.receiveEnergy(currentStorage,false);
            if (giveAmount > 0) {
              changeCharge(giveAmount * -1);
            }
          }
        }
 else         if (entity instanceof IEnergyReceiver) {
          IEnergyReceiver energy=(IEnergyReceiver)entity;
          if (energy.canConnectEnergy(facing.getOpposite())) {
            int giveAmount=energy.receiveEnergy(facing.getOpposite(),currentStorage,false);
            if (giveAmount > 0) {
              changeCharge(giveAmount * -1);
            }
          }
        }
      }
    }
  }
}",0.993041749502982
80728,"public static int getLevel(ItemStack itemStack){
  if (itemStack.getItem() instanceof ItemTool) {
    return ((ItemTool)itemStack.getItem()).getToolMaterial().getHarvestLevel();
  }
 else   if ((itemStack.getItem() instanceof ItemSword) || (itemStack.getItem() instanceof ItemHoe)) {
    String material=""String_Node_Str"";
    if (itemStack.getItem() instanceof ItemSword)     material=((ItemSword)itemStack.getItem()).getToolMaterialName();
 else     if (itemStack.getItem() instanceof ItemHoe)     material=((ItemHoe)itemStack.getItem()).getMaterialName();
    if (material.equals(""String_Node_Str""))     return LEVEL_WOOD;
 else     if (material.equals(""String_Node_Str""))     return LEVEL_STONE;
 else     if (material.equals(""String_Node_Str""))     return LEVEL_IRON;
 else     if (material.equals(""String_Node_Str""))     return LEVEL_GOLD;
 else     if (material.equals(""String_Node_Str""))     return LEVEL_DIAMOND;
  }
 else {
    if (itemStack.hasTagCompound()) {
      return tinkersLevel(itemStack);
    }
  }
  return -1;
}","public static int getLevel(ItemStack itemStack){
  if (itemStack.getItem() instanceof ItemTool) {
    return ((ItemTool)itemStack.getItem()).getToolMaterial().getHarvestLevel();
  }
 else   if ((itemStack.getItem() instanceof ItemSword) || (itemStack.getItem() instanceof ItemHoe)) {
    String material=""String_Node_Str"";
    if (itemStack.getItem() instanceof ItemSword)     material=((ItemSword)itemStack.getItem()).getToolMaterialName();
 else     if (itemStack.getItem() instanceof ItemHoe)     material=((ItemHoe)itemStack.getItem()).getMaterialName();
    if (material.equals(""String_Node_Str""))     return LEVEL_WOOD;
 else     if (material.equals(""String_Node_Str""))     return LEVEL_STONE;
 else     if (material.equals(""String_Node_Str""))     return LEVEL_IRON;
 else     if (material.equals(""String_Node_Str""))     return LEVEL_GOLD;
 else     if (material.equals(""String_Node_Str""))     return LEVEL_DIAMOND;
 else     if (material.equals(""String_Node_Str""))     return LEVEL_DIAMOND;
  }
 else {
    if (itemStack.hasTagCompound()) {
      return tinkersLevel(itemStack);
    }
  }
  return -1;
}",0.9645522388059702
80729,"public static void syncConfig(){
  upgradeRange=config.getInt(""String_Node_Str"",""String_Node_Str"",1,1,1000,""String_Node_Str"");
  fuelCost=config.getInt(""String_Node_Str"",""String_Node_Str"",2,1,300,""String_Node_Str"");
  if (fuelCost <= 0)   fuelCost=1;
  rfSupport=config.getBoolean(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  rfCost=config.getInt(""String_Node_Str"",""String_Node_Str"",40,1,50000,""String_Node_Str"");
  if (rfCost <= 0)   rfCost=1000;
  rfStored=config.getInt(""String_Node_Str"",""String_Node_Str"",40000,rfCost,100000,""String_Node_Str"");
  if (rfStored < rfCost)   rfStored=rfCost;
  rfRate=config.getInt(""String_Node_Str"",""String_Node_Str"",1000,1,100000,""String_Node_Str"");
  if (rfRate <= 0)   rfRate=1000;
  allowCoalPellets=config.getBoolean(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  allowPotatos=config.getBoolean(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  enableWitherTools=config.getBoolean(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  allowWrench=config.getBoolean(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  destroyTools=config.getBoolean(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  shearTrees=config.getBoolean(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  minerEnabled=config.getBoolean(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  chopperEnabled=config.getBoolean(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  planterEnabled=config.getBoolean(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  generatorEnabled=config.getBoolean(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  crafterEnabled=config.getBoolean(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  farmerEnabled=config.getBoolean(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  killerEnabled=config.getBoolean(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  allowWoodenLevel=config.getBoolean(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  allowStoneLevel=config.getBoolean(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  allowIronLevel=config.getBoolean(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  allowDiamondLevel=config.getBoolean(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  allowCobbleUpgrade=config.getBoolean(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  allowFillerUpgrade=config.getBoolean(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  allowWitherUpgrade=config.getBoolean(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  allowShearingUpgrade=config.getBoolean(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  allowMilkerUpgrade=config.getBoolean(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  witherMultiplier=config.getInt(""String_Node_Str"",""String_Node_Str"",4,2,10,""String_Node_Str"");
  allowKillPlayer=config.getBoolean(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  maxRangeUpgrades=config.getInt(""String_Node_Str"",""String_Node_Str"",Integer.MAX_VALUE,0,Integer.MAX_VALUE,""String_Node_Str"");
  woodLevel=config.getInt(""String_Node_Str"",""String_Node_Str"",ToolHelper.LEVEL_WOOD,0,100,""String_Node_Str"");
  stoneLevel=config.getInt(""String_Node_Str"",""String_Node_Str"",ToolHelper.LEVEL_STONE,0,100,""String_Node_Str"");
  ironLevel=config.getInt(""String_Node_Str"",""String_Node_Str"",ToolHelper.LEVEL_IRON,0,100,""String_Node_Str"");
  diamondLevel=config.getInt(""String_Node_Str"",""String_Node_Str"",ToolHelper.LEVEL_MAX,0,100,""String_Node_Str"");
  if (config.hasChanged())   save();
}","public static void syncConfig(){
  upgradeRange=config.getInt(""String_Node_Str"",""String_Node_Str"",1,1,1000,""String_Node_Str"");
  fuelCost=config.getInt(""String_Node_Str"",""String_Node_Str"",2,1,300,""String_Node_Str"");
  if (fuelCost <= 0)   fuelCost=1;
  rfSupport=config.getBoolean(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  rfCost=config.getInt(""String_Node_Str"",""String_Node_Str"",40,1,50000,""String_Node_Str"");
  if (rfCost <= 0)   rfCost=1000;
  rfStored=config.getInt(""String_Node_Str"",""String_Node_Str"",40000,rfCost,100000,""String_Node_Str"");
  if (rfStored < rfCost)   rfStored=rfCost;
  rfRate=config.getInt(""String_Node_Str"",""String_Node_Str"",1000,1,100000,""String_Node_Str"");
  if (rfRate <= 0)   rfRate=1000;
  allowCoalPellets=config.getBoolean(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  allowPotatos=config.getBoolean(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  enableWitherTools=config.getBoolean(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  allowWrench=config.getBoolean(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  destroyTools=config.getBoolean(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  shearTrees=config.getBoolean(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  allowInventoryOverflow=config.getBoolean(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  pauseOnFullInventory=config.getBoolean(""String_Node_Str"",""String_Node_Str"",false,""String_Node_Str"");
  minerEnabled=config.getBoolean(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  chopperEnabled=config.getBoolean(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  planterEnabled=config.getBoolean(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  generatorEnabled=config.getBoolean(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  crafterEnabled=config.getBoolean(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  farmerEnabled=config.getBoolean(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  killerEnabled=config.getBoolean(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  allowWoodenLevel=config.getBoolean(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  allowStoneLevel=config.getBoolean(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  allowIronLevel=config.getBoolean(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  allowDiamondLevel=config.getBoolean(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  allowCobbleUpgrade=config.getBoolean(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  allowFillerUpgrade=config.getBoolean(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  allowWitherUpgrade=config.getBoolean(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  allowShearingUpgrade=config.getBoolean(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  allowMilkerUpgrade=config.getBoolean(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  witherMultiplier=config.getInt(""String_Node_Str"",""String_Node_Str"",4,2,10,""String_Node_Str"");
  allowKillPlayer=config.getBoolean(""String_Node_Str"",""String_Node_Str"",true,""String_Node_Str"");
  maxRangeUpgrades=config.getInt(""String_Node_Str"",""String_Node_Str"",Integer.MAX_VALUE,0,Integer.MAX_VALUE,""String_Node_Str"");
  woodLevel=config.getInt(""String_Node_Str"",""String_Node_Str"",ToolHelper.LEVEL_WOOD,0,100,""String_Node_Str"");
  stoneLevel=config.getInt(""String_Node_Str"",""String_Node_Str"",ToolHelper.LEVEL_STONE,0,100,""String_Node_Str"");
  ironLevel=config.getInt(""String_Node_Str"",""String_Node_Str"",ToolHelper.LEVEL_IRON,0,100,""String_Node_Str"");
  diamondLevel=config.getInt(""String_Node_Str"",""String_Node_Str"",ToolHelper.LEVEL_MAX,0,100,""String_Node_Str"");
  if (config.hasChanged())   save();
}",0.9725864123957092
80730,"public void checkInventory(){
  if ((SLOT_INVENTORY_START == -1) || (SLOT_INVENTORY_END == -1))   return;
  for (int i=SLOT_INVENTORY_START; i <= SLOT_INVENTORY_END; i++) {
    if (slots[i] != null) {
      int moveTo=extraSlotCheck(slots[i]);
      if (moveTo >= 0) {
        slots[i]=moveItemToSlot(slots[i],moveTo);
      }
    }
  }
  for (  EnumFacing facing : EnumFacing.values()) {
    if (sides[facing.ordinal()] == WrenchModes.Mode.Output) {
      if (worldObj.getTileEntity(pos.offset(facing)) instanceof ISidedInventory) {
        ISidedInventory externalInv=(ISidedInventory)worldObj.getTileEntity(pos.offset(facing));
        for (int i=SLOT_INVENTORY_START; i <= SLOT_INVENTORY_END; i++) {
          if (slots[i] != null) {
            addtoSidedExtInventory(externalInv,i);
          }
        }
      }
 else       if (worldObj.getTileEntity(pos.offset(facing)) instanceof IInventory) {
        IInventory externalInv=(IInventory)worldObj.getTileEntity(pos.offset(facing));
        for (int i=SLOT_INVENTORY_START; i <= SLOT_INVENTORY_END; i++) {
          if (slots[i] != null) {
            addtoExtInventory(externalInv,i);
          }
        }
      }
    }
  }
}","public void checkInventory(){
  if ((SLOT_INVENTORY_START == -1) || (SLOT_INVENTORY_END == -1))   return;
  boolean openSlots=false;
  for (int i=SLOT_INVENTORY_START; i <= SLOT_INVENTORY_END; i++) {
    if (slots[i] != null) {
      int moveTo=extraSlotCheck(slots[i]);
      if (moveTo >= 0) {
        slots[i]=moveItemToSlot(slots[i],moveTo);
      }
    }
    if (slots[i] == null && !openSlots) {
      openSlots=true;
    }
  }
  for (  EnumFacing facing : EnumFacing.values()) {
    if (sides[facing.ordinal()] == WrenchModes.Mode.Output) {
      if (worldObj.getTileEntity(pos.offset(facing)) instanceof ISidedInventory) {
        ISidedInventory externalInv=(ISidedInventory)worldObj.getTileEntity(pos.offset(facing));
        for (int i=SLOT_INVENTORY_START; i <= SLOT_INVENTORY_END; i++) {
          if (slots[i] != null && addtoSidedExtInventory(externalInv,i)) {
            openSlots=true;
          }
        }
      }
 else       if (worldObj.getTileEntity(pos.offset(facing)) instanceof IInventory) {
        IInventory externalInv=(IInventory)worldObj.getTileEntity(pos.offset(facing));
        for (int i=SLOT_INVENTORY_START; i <= SLOT_INVENTORY_END; i++) {
          if (slots[i] != null && addtoExtInventory(externalInv,i)) {
            openSlots=true;
          }
        }
      }
    }
  }
  setInventoryFull(!openSlots);
}",0.8551125148045795
80731,"public boolean addToInventory(ItemStack item){
  if (item == null)   return false;
  if ((SLOT_INVENTORY_START == -1) || (SLOT_INVENTORY_END == -1))   return false;
  int extraSlot=extraSlotCheck(item);
  if (extraSlot >= 0) {
    item=moveItemToSlot(item,extraSlot);
  }
  for (int i=SLOT_INVENTORY_START; i <= SLOT_INVENTORY_END; i++) {
    if (slots[i] != null) {
      if (item != null) {
        if ((slots[i].isItemEqual(item)) && (slots[i].stackSize < slots[i].getMaxStackSize()) && (ItemStack.areItemStackTagsEqual(item,slots[i]))) {
          int avail=slots[i].getMaxStackSize() - slots[i].stackSize;
          if (avail >= item.stackSize) {
            slots[i].stackSize+=item.stackSize;
            item=null;
            return true;
          }
 else {
            item.stackSize-=avail;
            slots[i].stackSize+=avail;
          }
        }
      }
    }
  }
  if ((item != null) && (item.stackSize > 0)) {
    for (int i=SLOT_INVENTORY_START; i <= SLOT_INVENTORY_END; i++) {
      if (slots[i] == null) {
        if (this.isItemValidForSlot(i,item,true)) {
          slots[i]=item;
          item=null;
          return true;
        }
      }
    }
  }
  if ((item != null) && (item.stackSize == 0)) {
    item=null;
  }
  if (item != null) {
    dropItem(item);
    item=null;
  }
  return false;
}","public boolean addToInventory(ItemStack item){
  if (item == null)   return false;
  if ((SLOT_INVENTORY_START == -1) || (SLOT_INVENTORY_END == -1))   return false;
  int extraSlot=extraSlotCheck(item);
  if (extraSlot >= 0) {
    item=moveItemToSlot(item,extraSlot);
    if (item == null)     return true;
  }
  int emptySlot=-1;
  for (int i=SLOT_INVENTORY_START; i <= SLOT_INVENTORY_END; i++) {
    if (slots[i] == null) {
      if (emptySlot == -1 && this.isItemValidForSlot(i,item,true)) {
        emptySlot=i;
        setInventoryFull(false);
      }
      continue;
    }
    if (item == null || item.stackSize == 0) {
      continue;
    }
    if (slots[i].isItemEqual(item) && slots[i].stackSize < slots[i].getMaxStackSize() && ItemStack.areItemStackTagsEqual(item,slots[i])) {
      int avail=slots[i].getMaxStackSize() - slots[i].stackSize;
      if (avail >= item.stackSize) {
        slots[i].stackSize+=item.stackSize;
        item.stackSize=0;
        item=null;
      }
 else {
        item.stackSize-=avail;
        slots[i].stackSize+=avail;
      }
    }
  }
  if (emptySlot == -1)   setInventoryFull(true);
  if (item == null || item.stackSize == 0) {
    item=null;
    return true;
  }
  if (emptySlot != -1) {
    slots[emptySlot]=item;
    item=null;
    return true;
  }
  if (item != null) {
    if (PAConfig.allowInventoryOverflow)     dropItem(item);
    item=null;
  }
  return false;
}",0.6330777656078861
80732,"public boolean roomInInventory(ItemStack item){
  if ((SLOT_INVENTORY_START == -1) || (SLOT_INVENTORY_END == -1))   return false;
  if (item == null)   return false;
  int stackSize=item.stackSize;
  for (int i=SLOT_INVENTORY_START; i <= SLOT_INVENTORY_END; i++) {
    if (slots[i] != null) {
      if ((slots[i].isItemEqual(item)) && (slots[i].stackSize < slots[i].getMaxStackSize()) && (ItemStack.areItemStackTagsEqual(item,slots[i]))) {
        int avail=slots[i].getMaxStackSize() - slots[i].stackSize;
        if (avail >= stackSize) {
          return true;
        }
 else {
          stackSize-=avail;
        }
      }
    }
  }
  if ((item != null) && (stackSize > 0)) {
    for (int i=SLOT_INVENTORY_START; i <= SLOT_INVENTORY_END; i++) {
      if (slots[i] == null) {
        return true;
      }
    }
  }
  if (stackSize == 0) {
    return true;
  }
  return false;
}","public boolean roomInInventory(ItemStack item){
  if ((SLOT_INVENTORY_START == -1) || (SLOT_INVENTORY_END == -1))   return false;
  if (item == null)   return false;
  int stackSize=item.stackSize;
  boolean hasRoom=false;
  for (int i=SLOT_INVENTORY_START; i <= SLOT_INVENTORY_END; i++) {
    if (slots[i] == null) {
      hasRoom=true;
      setInventoryFull(false);
    }
 else     if (stackSize > 0 && slots[i].isItemEqual(item) && (ItemStack.areItemStackTagsEqual(item,slots[i]))) {
      stackSize=Math.max(stackSize - (slots[i].getMaxStackSize() - slots[i].stackSize),0);
    }
    if (hasRoom || stackSize == 0)     return true;
  }
  setInventoryFull(true);
  return false;
}",0.4792332268370607
80733,"@Override public void update(){
  if (!worldObj.isRemote) {
    if (!isBurning()) {
      RedstonePowered=isIndirectlyPowered();
      if (!RedstonePowered) {
        if (readyToBurn()) {
          if (slots[SLOT_FUEL] != null) {
            if (isFuel()) {
              burnLevel=progress=getBurnTime();
              addPartialUpdate(""String_Node_Str"",progress);
              addPartialUpdate(""String_Node_Str"",burnLevel);
              if (slots[SLOT_FUEL].getItem().hasContainerItem(slots[SLOT_FUEL])) {
                slots[SLOT_FUEL]=slots[SLOT_FUEL].getItem().getContainerItem(slots[SLOT_FUEL]);
                if (!isFuel()) {
                  moveToInventoryOrDrop(SLOT_FUEL);
                }
              }
 else {
                slots[SLOT_FUEL].stackSize--;
                if (slots[SLOT_FUEL].stackSize == 0) {
                  slots[SLOT_FUEL]=null;
                }
              }
            }
 else             if (hasEngine()) {
              if (useEnergy(PAConfig.rfCost,false) > 0) {
                if (burnLevel != 1 || progress != 1) {
                  burnLevel=progress=1;
                  addPartialUpdate(""String_Node_Str"",progress);
                  addPartialUpdate(""String_Node_Str"",burnLevel);
                }
              }
            }
          }
        }
      }
    }
 else {
      progress--;
      if (progress <= 0) {
        burnLevel=progress=0;
        addPartialUpdate(""String_Node_Str"",burnLevel);
        if ((readyToBurn()) && (hasEngine())) {
          if (useEnergy(PAConfig.rfCost,false) > 0) {
            burnLevel=progress=1;
          }
        }
      }
      addPartialUpdate(""String_Node_Str"",progress);
    }
    checkForPowerChange();
  }
}","@Override public void update(){
  if (!worldObj.isRemote) {
    if (isFull())     return;
    if (!isBurning()) {
      RedstonePowered=isIndirectlyPowered();
      if (!RedstonePowered) {
        if (readyToBurn()) {
          if (slots[SLOT_FUEL] != null) {
            if (isFuel()) {
              burnLevel=progress=getBurnTime();
              addPartialUpdate(""String_Node_Str"",progress);
              addPartialUpdate(""String_Node_Str"",burnLevel);
              if (slots[SLOT_FUEL].getItem().hasContainerItem(slots[SLOT_FUEL])) {
                slots[SLOT_FUEL]=slots[SLOT_FUEL].getItem().getContainerItem(slots[SLOT_FUEL]);
                if (!isFuel()) {
                  moveToInventoryOrDrop(SLOT_FUEL);
                }
              }
 else {
                slots[SLOT_FUEL].stackSize--;
                if (slots[SLOT_FUEL].stackSize == 0) {
                  slots[SLOT_FUEL]=null;
                }
              }
            }
 else             if (hasEngine()) {
              if (useEnergy(PAConfig.rfCost,false) > 0) {
                if (burnLevel != 1 || progress != 1) {
                  burnLevel=progress=1;
                  addPartialUpdate(""String_Node_Str"",progress);
                  addPartialUpdate(""String_Node_Str"",burnLevel);
                }
              }
            }
          }
        }
      }
    }
 else {
      progress--;
      if (progress <= 0) {
        burnLevel=progress=0;
        addPartialUpdate(""String_Node_Str"",burnLevel);
        if ((readyToBurn()) && (hasEngine())) {
          if (useEnergy(PAConfig.rfCost,false) > 0) {
            burnLevel=progress=1;
          }
        }
      }
      addPartialUpdate(""String_Node_Str"",progress);
    }
    checkForPowerChange();
  }
}",0.9913544668587896
80734,"@Override public void clear(){
  for (int i=0; i < this.slots.length; ++i) {
    this.slots[i]=null;
  }
}","@Override public void clear(){
  for (int i=0; i < this.slots.length; ++i) {
    this.slots[i]=null;
  }
  setInventoryFull(false);
}",0.8870292887029289
80735,"/** 
 * This overridable method is intended for reading from NBT all data that is both saved to hdd and can be sent to the client TileEntity through S35PacketUpdateTileEntity and PartialTileNBTUpdateMessage. WARNING: Please check if the tag exists before reading it. Due to the nature of  PartialTileNBTUpdateMessage properties that didn't change since the last message will not be included. WARNING: Do not include slot contents here.  They are automagically synced when a GUI is opened using S30PacketWindowItems 
 * @param nbt
 */
public void readCommonNBT(NBTTagCompound nbt){
  if (nbt.hasKey(""String_Node_Str""))   progress=nbt.getInteger(""String_Node_Str"");
  if (nbt.hasKey(""String_Node_Str""))   burnLevel=nbt.getInteger(""String_Node_Str"");
  if (nbt.hasKey(""String_Node_Str""))   firstLook=nbt.getBoolean(""String_Node_Str"");
  if (nbt.hasKey(""String_Node_Str""))   facing=EnumFacing.getFront(nbt.getInteger(""String_Node_Str""));
  if (nbt.hasKey(""String_Node_Str"")) {
    int ary[]=nbt.getIntArray(""String_Node_Str"");
    for (int i=0; i < 6; i++) {
      sides[i]=WrenchModes.modes.get(ary[i]);
    }
  }
}","/** 
 * This overridable method is intended for reading from NBT all data that is both saved to hdd and can be sent to the client TileEntity through S35PacketUpdateTileEntity and PartialTileNBTUpdateMessage. WARNING: Please check if the tag exists before reading it. Due to the nature of  PartialTileNBTUpdateMessage properties that didn't change since the last message will not be included. WARNING: Do not include slot contents here.  They are automagically synced when a GUI is opened using S30PacketWindowItems 
 * @param nbt
 */
public void readCommonNBT(NBTTagCompound nbt){
  if (nbt.hasKey(""String_Node_Str""))   progress=nbt.getInteger(""String_Node_Str"");
  if (nbt.hasKey(""String_Node_Str""))   burnLevel=nbt.getInteger(""String_Node_Str"");
  if (nbt.hasKey(""String_Node_Str""))   inventoryFull=nbt.getBoolean(""String_Node_Str"");
  if (nbt.hasKey(""String_Node_Str""))   firstLook=nbt.getBoolean(""String_Node_Str"");
  if (nbt.hasKey(""String_Node_Str""))   facing=EnumFacing.getFront(nbt.getInteger(""String_Node_Str""));
  if (nbt.hasKey(""String_Node_Str"")) {
    int ary[]=nbt.getIntArray(""String_Node_Str"");
    for (int i=0; i < 6; i++) {
      sides[i]=WrenchModes.modes.get(ary[i]);
    }
  }
}",0.9619377162629758
80736,"/** 
 * This overridable method is intended for writing to NBT all data that is both saved to hdd and can be sent to the client TileEntity through S35PacketUpdateTileEntity. WARNING: Do not include slot contents here.  They are automagically synced when a GUI is opened using S30PacketWindowItems 
 * @param nbt
 */
public void writeCommonNBT(NBTTagCompound nbt){
  nbt.setInteger(""String_Node_Str"",progress);
  nbt.setInteger(""String_Node_Str"",burnLevel);
  nbt.setBoolean(""String_Node_Str"",firstLook);
  nbt.setInteger(""String_Node_Str"",facing.ordinal());
  int ary[]=new int[6];
  for (int i=0; i < 6; i++) {
    ary[i]=sides[i].ordinal();
  }
  nbt.setIntArray(""String_Node_Str"",ary);
  ary=null;
}","/** 
 * This overridable method is intended for writing to NBT all data that is both saved to hdd and can be sent to the client TileEntity through S35PacketUpdateTileEntity. WARNING: Do not include slot contents here.  They are automagically synced when a GUI is opened using S30PacketWindowItems 
 * @param nbt
 */
public void writeCommonNBT(NBTTagCompound nbt){
  nbt.setInteger(""String_Node_Str"",progress);
  nbt.setInteger(""String_Node_Str"",burnLevel);
  nbt.setBoolean(""String_Node_Str"",inventoryFull);
  nbt.setBoolean(""String_Node_Str"",firstLook);
  nbt.setInteger(""String_Node_Str"",facing.ordinal());
  int ary[]=new int[6];
  for (int i=0; i < 6; i++) {
    ary[i]=sides[i].ordinal();
  }
  nbt.setIntArray(""String_Node_Str"",ary);
  ary=null;
}",0.9649484536082474
80737,"@Override public void update(){
  super.update();
  if (!worldObj.isRemote) {
    checkForChanges();
    checkInventory();
    if (isBurning()) {
      if (chopping && blockList.size() == 0) {
        chopping=false;
        addPartialUpdate(""String_Node_Str"",false);
      }
      if (blockList.size() > 0) {
        cutTree();
      }
 else       if (plantSapling) {
        plantSaplings(searchBlock,true);
        plantSapling=false;
        addPartialUpdate(""String_Node_Str"",false);
      }
      scanBlocks();
    }
  }
}","@Override public void update(){
  super.update();
  if (!worldObj.isRemote) {
    checkForChanges();
    checkInventory();
    if (isFull())     return;
    if (isBurning()) {
      if (chopping && blockList.size() == 0) {
        chopping=false;
        addPartialUpdate(""String_Node_Str"",false);
      }
      if (blockList.size() > 0) {
        cutTree();
      }
 else       if (plantSapling) {
        plantSaplings(searchBlock,true);
        plantSapling=false;
        addPartialUpdate(""String_Node_Str"",false);
      }
      scanBlocks();
    }
  }
}",0.9723756906077348
80738,"@Override public void update(){
  super.update();
  if (!worldObj.isRemote) {
    doPickup();
    checkInventory();
    if (isBurning()) {
      if (currentTime > 0) {
        currentTime--;
      }
 else {
        if (searchBlock > -1) {
          initFaker();
          EntityAnimal animal=findAnimalToFeed(searchBlock);
          if (animal != null)           feedAnimal(animal);
 else {
            animal=findAnimalToShear(searchBlock);
            if (animal != null)             shearAnimal(animal);
 else {
              animal=findAnimalToMilk(searchBlock);
              if (animal != null)               milkAnimal(animal);
 else {
                searchBlock=-1;
                addPartialUpdate(""String_Node_Str"",searchBlock);
              }
            }
          }
        }
 else {
          doSearch();
        }
      }
    }
  }
}","@Override public void update(){
  super.update();
  if (!worldObj.isRemote) {
    doPickup();
    checkInventory();
    if (isFull())     return;
    if (isBurning()) {
      if (currentTime > 0) {
        currentTime--;
      }
 else {
        if (searchBlock > -1) {
          initFaker();
          EntityAnimal animal=findAnimalToFeed(searchBlock);
          if (animal != null)           feedAnimal(animal);
 else {
            animal=findAnimalToShear(searchBlock);
            if (animal != null)             shearAnimal(animal);
 else {
              animal=findAnimalToMilk(searchBlock);
              if (animal != null)               milkAnimal(animal);
 else {
                searchBlock=-1;
                addPartialUpdate(""String_Node_Str"",searchBlock);
              }
            }
          }
        }
 else {
          doSearch();
        }
      }
    }
  }
}",0.9826789838337182
80739,"@Override public void update(){
  super.update();
  if (!worldObj.isRemote) {
    doXpPickup();
    checkInventory();
    if (isBurning()) {
      if (currentTime > 0) {
        currentTime--;
      }
 else {
        if (searchBlock > -1) {
          EntityLivingBase mob=getMob(searchBlock);
          if (mob == null) {
            searchBlock=-1;
            addPartialUpdate(""String_Node_Str"",searchBlock);
          }
 else {
            if (slots[SLOT_SWORD] != null) {
              if (faker == null) {
                faker=new PlayerFake((WorldServer)worldObj,worldObj.getBlockState(pos).getBlock().getLocalizedName());
                faker.setPosition(0,0,0);
              }
              faker.setItemInHand(slots[SLOT_SWORD].copy());
              Multimap<String,AttributeModifier> attributeModifiers=slots[SLOT_SWORD].getAttributeModifiers(EntityEquipmentSlot.MAINHAND);
              attributeModifiers.get(SharedMonsterAttributes.ATTACK_SPEED.getAttributeUnlocalizedName());
              faker.setItemInUse(faker.getHeldItemMainhand(),72000);
              faker.onUpdate();
              faker.attackTargetEntityWithCurrentItem(mob);
              if (ToolHelper.damageTool(slots[SLOT_SWORD],worldObj,pos.getX(),pos.getY(),pos.getZ())) {
                destroyTool(SLOT_SWORD);
              }
              pickupDrops(searchBlock);
              currentTime=waitTime;
              addPartialUpdate(""String_Node_Str"",currentTime);
            }
 else {
              searchBlock=-1;
              addPartialUpdate(""String_Node_Str"",searchBlock);
            }
          }
        }
 else {
          doSearch();
        }
      }
    }
  }
}","@Override public void update(){
  super.update();
  if (!worldObj.isRemote) {
    doXpPickup();
    checkInventory();
    if (isFull())     return;
    if (isBurning()) {
      if (currentTime > 0) {
        currentTime--;
      }
 else {
        if (searchBlock > -1) {
          EntityLivingBase mob=getMob(searchBlock);
          if (mob == null) {
            searchBlock=-1;
            addPartialUpdate(""String_Node_Str"",searchBlock);
          }
 else {
            if (slots[SLOT_SWORD] != null) {
              if (faker == null) {
                faker=new PlayerFake((WorldServer)worldObj,worldObj.getBlockState(pos).getBlock().getLocalizedName());
                faker.setPosition(0,0,0);
              }
              faker.setItemInHand(slots[SLOT_SWORD].copy());
              Multimap<String,AttributeModifier> attributeModifiers=slots[SLOT_SWORD].getAttributeModifiers(EntityEquipmentSlot.MAINHAND);
              attributeModifiers.get(SharedMonsterAttributes.ATTACK_SPEED.getAttributeUnlocalizedName());
              faker.setItemInUse(faker.getHeldItemMainhand(),72000);
              faker.onUpdate();
              faker.attackTargetEntityWithCurrentItem(mob);
              if (ToolHelper.damageTool(slots[SLOT_SWORD],worldObj,pos.getX(),pos.getY(),pos.getZ())) {
                destroyTool(SLOT_SWORD);
              }
              pickupDrops(searchBlock);
              currentTime=waitTime;
              addPartialUpdate(""String_Node_Str"",currentTime);
            }
 else {
              searchBlock=-1;
              addPartialUpdate(""String_Node_Str"",searchBlock);
            }
          }
        }
 else {
          doSearch();
        }
      }
    }
  }
}",0.9910714285714286
80740,"public void update(){
  super.update();
  if (!worldObj.isRemote) {
    checkForChanges();
    checkInventory();
    if (isBurning()) {
      useCobbleGen();
      if (!isDone()) {
        mine();
      }
    }
  }
}","public void update(){
  super.update();
  if (!worldObj.isRemote) {
    checkForChanges();
    checkInventory();
    if (isFull())     return;
    if (isBurning()) {
      useCobbleGen();
      if (!isDone()) {
        mine();
      }
    }
  }
}",0.935064935064935
80741,"@Override public void update(){
  super.update();
  if (!worldObj.isRemote) {
    checkInventory();
    if (isBurning()) {
      if (searchBlock > -1) {
        if (currentTime > 0) {
          if (checkPlant(searchBlock)) {
            currentTime--;
            if (currentTime <= 0) {
              harvestPlant(searchBlock);
              searchBlock=-1;
              addPartialUpdate(""String_Node_Str"",searchBlock);
            }
          }
 else {
            currentTime=0;
            searchBlock=-1;
            addPartialUpdate(""String_Node_Str"",searchBlock);
          }
          addPartialUpdate(""String_Node_Str"",currentTime);
        }
 else         if (plantSeed(searchBlock,true)) {
          searchBlock=-1;
          addPartialUpdate(""String_Node_Str"",searchBlock);
        }
 else {
          if (checkPlant(searchBlock)) {
            currentTime=harvestTime;
            addPartialUpdate(""String_Node_Str"",currentTime);
          }
        }
      }
 else {
        doSearch();
      }
    }
  }
}","@Override public void update(){
  super.update();
  if (!worldObj.isRemote) {
    checkInventory();
    if (isFull())     return;
    if (isBurning()) {
      if (searchBlock > -1) {
        if (currentTime > 0) {
          if (checkPlant(searchBlock)) {
            currentTime--;
            if (currentTime <= 0) {
              harvestPlant(searchBlock);
              searchBlock=-1;
              addPartialUpdate(""String_Node_Str"",searchBlock);
            }
          }
 else {
            currentTime=0;
            searchBlock=-1;
            addPartialUpdate(""String_Node_Str"",searchBlock);
          }
          addPartialUpdate(""String_Node_Str"",currentTime);
        }
 else         if (plantSeed(searchBlock,true)) {
          searchBlock=-1;
          addPartialUpdate(""String_Node_Str"",searchBlock);
        }
 else {
          if (checkPlant(searchBlock)) {
            currentTime=harvestTime;
            addPartialUpdate(""String_Node_Str"",currentTime);
          }
        }
      }
 else {
        doSearch();
      }
    }
  }
}",0.9855212355212356
80742,"protected void drawText(){
  drawString(StringHelper.localize(""String_Node_Str""),5,GRAY);
  drawString(StringHelper.localize(""String_Node_Str"") + ""String_Node_Str"" + StringHelper.getScaledNumber(chopper.getRange()),infoScreenX,infoScreenW,infroScreenY3,(chopper.hasUpgrade(UpgradeType.WITHER)) ? GREEN : WHITE);
  if (chopper.isInvalidTool()) {
    drawString(getTextLine(1,""String_Node_Str""),infoScreenX,infoScreenW,infroScreenY1,ORANGE);
    drawString(getTextLine(2,""String_Node_Str""),infoScreenX,infoScreenW,infroScreenY2,ORANGE);
  }
 else   if (chopper.isLooked()) {
    boolean readyToChop=false;
    if ((!chopper.hasFuel()) && (!chopper.isBurning())) {
      String fuelString=""String_Node_Str"";
      if (chopper.hasEngine())       fuelString=""String_Node_Str"";
      drawString(StringHelper.localize(fuelString),infoScreenX,infoScreenW,infroScreenY2,RED);
    }
 else     if ((chopper.getStackInSlot(chopper.SLOT_SAPLINGS) == null) && (!chopper.isBurning())) {
      drawString(StringHelper.localize(""String_Node_Str""),infoScreenX,infoScreenW,infroScreenY2,RED);
    }
 else     if (chopper.getStackInSlot(chopper.SLOT_AXE) == null) {
      drawString(StringHelper.localize(""String_Node_Str""),infoScreenX,infoScreenW,infroScreenY2,RED);
    }
 else {
      readyToChop=true;
      String status=""String_Node_Str"";
      if (chopper.isChopping()) {
        status=""String_Node_Str"";
      }
 else       if (chopper.isPlanting()) {
        status=""String_Node_Str"";
      }
      drawString(StringHelper.localize(status),infoScreenX,infoScreenW,infroScreenY2,BLUE);
    }
    if (!readyToChop) {
      drawString(StringHelper.localize(""String_Node_Str""),infoScreenX,infoScreenW,infroScreenY1,RED);
    }
 else     if (chopper.isBurning()) {
      drawString(StringHelper.localize(""String_Node_Str""),infoScreenX,infoScreenW,infroScreenY1,BLUE);
    }
 else {
      drawString(StringHelper.localize(""String_Node_Str""),infoScreenX,infoScreenW,infroScreenY1,GREEN);
    }
  }
 else {
    drawString(getTextLine(1,""String_Node_Str""),infoScreenX,infoScreenW,infroScreenY1,GREEN);
    drawString(getTextLine(2,""String_Node_Str""),infoScreenX,infoScreenW,infroScreenY2,GREEN);
  }
}","protected void drawText(){
  drawString(StringHelper.localize(""String_Node_Str""),5,GRAY);
  drawString(StringHelper.localize(""String_Node_Str"") + ""String_Node_Str"" + StringHelper.getScaledNumber(chopper.getRange()),infoScreenX,infoScreenW,infroScreenY3,(chopper.hasUpgrade(UpgradeType.WITHER)) ? GREEN : WHITE);
  if (chopper.isInvalidTool()) {
    drawString(getTextLine(1,""String_Node_Str""),infoScreenX,infoScreenW,infroScreenY1,ORANGE);
    drawString(getTextLine(2,""String_Node_Str""),infoScreenX,infoScreenW,infroScreenY2,ORANGE);
  }
 else   if (chopper.isLooked()) {
    boolean readyToChop=false;
    if (chopper.isFull()) {
      drawString(StringHelper.localize(""String_Node_Str""),infoScreenX,infoScreenW,infroScreenY2,RED);
    }
 else     if ((!chopper.hasFuel()) && (!chopper.isBurning())) {
      String fuelString=""String_Node_Str"";
      if (chopper.hasEngine())       fuelString=""String_Node_Str"";
      drawString(StringHelper.localize(fuelString),infoScreenX,infoScreenW,infroScreenY2,RED);
    }
 else     if ((chopper.getStackInSlot(chopper.SLOT_SAPLINGS) == null) && (!chopper.isBurning())) {
      drawString(StringHelper.localize(""String_Node_Str""),infoScreenX,infoScreenW,infroScreenY2,RED);
    }
 else     if (chopper.getStackInSlot(chopper.SLOT_AXE) == null) {
      drawString(StringHelper.localize(""String_Node_Str""),infoScreenX,infoScreenW,infroScreenY2,RED);
    }
 else {
      readyToChop=true;
      String status=""String_Node_Str"";
      if (chopper.isChopping()) {
        status=""String_Node_Str"";
      }
 else       if (chopper.isPlanting()) {
        status=""String_Node_Str"";
      }
      drawString(StringHelper.localize(status),infoScreenX,infoScreenW,infroScreenY2,BLUE);
    }
    if (!readyToChop) {
      drawString(StringHelper.localize(""String_Node_Str""),infoScreenX,infoScreenW,infroScreenY1,RED);
    }
 else     if (chopper.isBurning()) {
      drawString(StringHelper.localize(""String_Node_Str""),infoScreenX,infoScreenW,infroScreenY1,BLUE);
    }
 else {
      drawString(StringHelper.localize(""String_Node_Str""),infoScreenX,infoScreenW,infroScreenY1,GREEN);
    }
  }
 else {
    drawString(getTextLine(1,""String_Node_Str""),infoScreenX,infoScreenW,infroScreenY1,GREEN);
    drawString(getTextLine(2,""String_Node_Str""),infoScreenX,infoScreenW,infroScreenY2,GREEN);
  }
}",0.9684864624944518
80743,"@Override protected void drawText(){
  drawString(StringHelper.localize(""String_Node_Str""),5,GRAY);
  drawString(StringHelper.localize(""String_Node_Str"") + ""String_Node_Str"" + StringHelper.getScaledNumber(farmer.getRange()),infoScreenX,infoScreenW,infroScreenY3,(farmer.hasUpgrade(UpgradeType.WITHER)) ? GREEN : WHITE);
  if (farmer.isInvalidTool()) {
    drawString(getTextLine(1,""String_Node_Str""),infoScreenX,infoScreenW,infroScreenY1,ORANGE);
    drawString(getTextLine(2,""String_Node_Str""),infoScreenX,infoScreenW,infroScreenY2,ORANGE);
  }
 else   if (farmer.isLooked()) {
    boolean allGood=false;
    if ((!farmer.hasFuel()) && (!farmer.isBurning())) {
      String fuelString=""String_Node_Str"";
      if (farmer.hasEngine())       fuelString=""String_Node_Str"";
      drawString(StringHelper.localize(fuelString),infoScreenX,infoScreenW,infroScreenY2,RED);
    }
 else     if ((farmer.getStackInSlot(farmer.SLOT_FOOD) == null) && (farmer.getStackInSlot(farmer.SLOT_BUCKETS) == null) && (farmer.getStackInSlot(farmer.SLOT_SHEARS) == null)) {
      drawString(StringHelper.localize(""String_Node_Str""),infoScreenX,infoScreenW,infroScreenY2,RED);
    }
 else {
      allGood=true;
      String status=""String_Node_Str"";
      if (farmer.getCurrentAction() == 1)       status=""String_Node_Str"";
 else       if (farmer.getCurrentAction() == 2)       status=""String_Node_Str"";
 else       if (farmer.getCurrentAction() == 3)       status=""String_Node_Str"";
      drawString(StringHelper.localize(status),infoScreenX,infoScreenW,infroScreenY2,BLUE);
    }
    if (!allGood) {
      drawString(StringHelper.localize(""String_Node_Str""),infoScreenX,infoScreenW,infroScreenY1,RED);
    }
 else     if (farmer.isBurning()) {
      drawString(StringHelper.localize(""String_Node_Str""),infoScreenX,infoScreenW,infroScreenY1,BLUE);
    }
 else {
      drawString(StringHelper.localize(""String_Node_Str""),infoScreenX,infoScreenW,infroScreenY1,GREEN);
    }
  }
 else {
    drawString(getTextLine(1,""String_Node_Str""),infoScreenX,infoScreenW,infroScreenY1,GREEN);
    drawString(getTextLine(2,""String_Node_Str""),infoScreenX,infoScreenW,infroScreenY2,GREEN);
  }
}","@Override protected void drawText(){
  drawString(StringHelper.localize(""String_Node_Str""),5,GRAY);
  drawString(StringHelper.localize(""String_Node_Str"") + ""String_Node_Str"" + StringHelper.getScaledNumber(farmer.getRange()),infoScreenX,infoScreenW,infroScreenY3,(farmer.hasUpgrade(UpgradeType.WITHER)) ? GREEN : WHITE);
  if (farmer.isInvalidTool()) {
    drawString(getTextLine(1,""String_Node_Str""),infoScreenX,infoScreenW,infroScreenY1,ORANGE);
    drawString(getTextLine(2,""String_Node_Str""),infoScreenX,infoScreenW,infroScreenY2,ORANGE);
  }
 else   if (farmer.isLooked()) {
    boolean allGood=false;
    if (farmer.isFull()) {
      drawString(StringHelper.localize(""String_Node_Str""),infoScreenX,infoScreenW,infroScreenY2,RED);
    }
 else     if ((!farmer.hasFuel()) && (!farmer.isBurning())) {
      String fuelString=""String_Node_Str"";
      if (farmer.hasEngine())       fuelString=""String_Node_Str"";
      drawString(StringHelper.localize(fuelString),infoScreenX,infoScreenW,infroScreenY2,RED);
    }
 else     if ((farmer.getStackInSlot(farmer.SLOT_FOOD) == null) && (farmer.getStackInSlot(farmer.SLOT_BUCKETS) == null) && (farmer.getStackInSlot(farmer.SLOT_SHEARS) == null)) {
      drawString(StringHelper.localize(""String_Node_Str""),infoScreenX,infoScreenW,infroScreenY2,RED);
    }
 else {
      allGood=true;
      String status=""String_Node_Str"";
      if (farmer.getCurrentAction() == 1)       status=""String_Node_Str"";
 else       if (farmer.getCurrentAction() == 2)       status=""String_Node_Str"";
 else       if (farmer.getCurrentAction() == 3)       status=""String_Node_Str"";
      drawString(StringHelper.localize(status),infoScreenX,infoScreenW,infroScreenY2,BLUE);
    }
    if (!allGood) {
      drawString(StringHelper.localize(""String_Node_Str""),infoScreenX,infoScreenW,infroScreenY1,RED);
    }
 else     if (farmer.isBurning()) {
      drawString(StringHelper.localize(""String_Node_Str""),infoScreenX,infoScreenW,infroScreenY1,BLUE);
    }
 else {
      drawString(StringHelper.localize(""String_Node_Str""),infoScreenX,infoScreenW,infroScreenY1,GREEN);
    }
  }
 else {
    drawString(getTextLine(1,""String_Node_Str""),infoScreenX,infoScreenW,infroScreenY1,GREEN);
    drawString(getTextLine(2,""String_Node_Str""),infoScreenX,infoScreenW,infroScreenY2,GREEN);
  }
}",0.9682932313919496
80744,"@Override protected void drawText(){
  drawString(StringHelper.localize(""String_Node_Str""),5,GRAY);
  drawString(StringHelper.localize(""String_Node_Str"") + ""String_Node_Str"" + StringHelper.getScaledNumber(killer.getRange()),infoScreenX,infoScreenW,infroScreenY3,(killer.hasUpgrade(UpgradeType.WITHER)) ? GREEN : WHITE);
  if (killer.isInvalidTool()) {
    drawString(getTextLine(1,""String_Node_Str""),infoScreenX,infoScreenW,infroScreenY1,ORANGE);
    drawString(getTextLine(2,""String_Node_Str""),infoScreenX,infoScreenW,infroScreenY2,ORANGE);
  }
 else   if (killer.isLooked()) {
    boolean readyToPlant=false;
    if ((!killer.hasFuel()) && (!killer.isBurning())) {
      String fuelString=""String_Node_Str"";
      if (killer.hasEngine())       fuelString=""String_Node_Str"";
      drawString(StringHelper.localize(fuelString),infoScreenX,infoScreenW,infroScreenY2,RED);
    }
 else     if (killer.getStackInSlot(killer.SLOT_SWORD) == null) {
      drawString(StringHelper.localize(""String_Node_Str""),infoScreenX,infoScreenW,infroScreenY2,RED);
    }
 else {
      readyToPlant=true;
      String status=""String_Node_Str"";
      if (killer.isKilling())       status=""String_Node_Str"";
      drawString(StringHelper.localize(status),infoScreenX,infoScreenW,infroScreenY2,BLUE);
    }
    if (!readyToPlant) {
      drawString(StringHelper.localize(""String_Node_Str""),infoScreenX,infoScreenW,infroScreenY1,RED);
    }
 else     if (killer.isBurning()) {
      drawString(StringHelper.localize(""String_Node_Str""),infoScreenX,infoScreenW,infroScreenY1,BLUE);
    }
 else {
      drawString(StringHelper.localize(""String_Node_Str""),infoScreenX,infoScreenW,infroScreenY1,GREEN);
    }
  }
 else {
    drawString(getTextLine(1,""String_Node_Str""),infoScreenX,infoScreenW,infroScreenY1,GREEN);
    drawString(getTextLine(2,""String_Node_Str""),infoScreenX,infoScreenW,infroScreenY2,GREEN);
  }
}","@Override protected void drawText(){
  drawString(StringHelper.localize(""String_Node_Str""),5,GRAY);
  drawString(StringHelper.localize(""String_Node_Str"") + ""String_Node_Str"" + StringHelper.getScaledNumber(killer.getRange()),infoScreenX,infoScreenW,infroScreenY3,(killer.hasUpgrade(UpgradeType.WITHER)) ? GREEN : WHITE);
  if (killer.isInvalidTool()) {
    drawString(getTextLine(1,""String_Node_Str""),infoScreenX,infoScreenW,infroScreenY1,ORANGE);
    drawString(getTextLine(2,""String_Node_Str""),infoScreenX,infoScreenW,infroScreenY2,ORANGE);
  }
 else   if (killer.isLooked()) {
    boolean readyToPlant=false;
    if (killer.isFull()) {
      drawString(StringHelper.localize(""String_Node_Str""),infoScreenX,infoScreenW,infroScreenY2,RED);
    }
 else     if ((!killer.hasFuel()) && (!killer.isBurning())) {
      String fuelString=""String_Node_Str"";
      if (killer.hasEngine())       fuelString=""String_Node_Str"";
      drawString(StringHelper.localize(fuelString),infoScreenX,infoScreenW,infroScreenY2,RED);
    }
 else     if (killer.getStackInSlot(killer.SLOT_SWORD) == null) {
      drawString(StringHelper.localize(""String_Node_Str""),infoScreenX,infoScreenW,infroScreenY2,RED);
    }
 else {
      readyToPlant=true;
      String status=""String_Node_Str"";
      if (killer.isKilling())       status=""String_Node_Str"";
      drawString(StringHelper.localize(status),infoScreenX,infoScreenW,infroScreenY2,BLUE);
    }
    if (!readyToPlant) {
      drawString(StringHelper.localize(""String_Node_Str""),infoScreenX,infoScreenW,infroScreenY1,RED);
    }
 else     if (killer.isBurning()) {
      drawString(StringHelper.localize(""String_Node_Str""),infoScreenX,infoScreenW,infroScreenY1,BLUE);
    }
 else {
      drawString(StringHelper.localize(""String_Node_Str""),infoScreenX,infoScreenW,infroScreenY1,GREEN);
    }
  }
 else {
    drawString(getTextLine(1,""String_Node_Str""),infoScreenX,infoScreenW,infroScreenY1,GREEN);
    drawString(getTextLine(2,""String_Node_Str""),infoScreenX,infoScreenW,infroScreenY2,GREEN);
  }
}",0.9639293937068304
80745,"protected void drawText(){
  drawString(StringHelper.localize(""String_Node_Str""),5,GRAY);
  drawString(StringHelper.localize(""String_Node_Str"") + ""String_Node_Str"" + StringHelper.getScaledNumber(miner.getRange()),infoScreenX,infoScreenW,infroScreenY3,(miner.hasUpgrade(UpgradeType.WITHER)) ? GREEN : WHITE);
  if (miner.isInvalidTool()) {
    drawString(getTextLine(1,""String_Node_Str""),infoScreenX,infoScreenW,infroScreenY1,ORANGE);
    drawString(getTextLine(2,""String_Node_Str""),infoScreenX,infoScreenW,infroScreenY2,ORANGE);
  }
 else   if (miner.isLooked()) {
    boolean readyToMine=true;
    if ((!miner.hasFuel()) && (!miner.isBurning())) {
      String fuelString=""String_Node_Str"";
      if (miner.hasEngine())       fuelString=""String_Node_Str"";
      drawString(StringHelper.localize(fuelString),infoScreenX,infoScreenW,infroScreenY2,RED);
      readyToMine=false;
    }
 else     if ((miner.getStackInSlot(1) == null) && (!miner.hasUpgrade(UpgradeType.COBBLE_GEN))) {
      drawString(StringHelper.localize(""String_Node_Str""),infoScreenX,infoScreenW,infroScreenY2,RED);
      readyToMine=false;
    }
 else     if (miner.getStackInSlot(miner.SLOT_PICKAXE) == null) {
      drawString(StringHelper.localize(""String_Node_Str""),infoScreenX,infoScreenW,infroScreenY2,RED);
      readyToMine=false;
    }
 else     if (miner.getStackInSlot(miner.SLOT_SHOVEL) == null) {
      drawString(StringHelper.localize(""String_Node_Str""),infoScreenX,infoScreenW,infroScreenY2,RED);
      readyToMine=false;
    }
 else {
      drawString(StringHelper.getScaledNumber(miner.getMinedBlocks()) + ""String_Node_Str"" + StringHelper.getScaledNumber(miner.getMineBlocks()),infoScreenX,infoScreenW,infroScreenY2,BLUE);
    }
    if (!readyToMine) {
      drawString(StringHelper.localize(""String_Node_Str""),infoScreenX,infoScreenW,infroScreenY1,RED);
    }
 else     if (miner.getMinedBlocks() == miner.getMineBlocks()) {
      drawString(StringHelper.localize(""String_Node_Str""),infoScreenX,infoScreenW,infroScreenY1,BLUE);
    }
 else {
      drawString(StringHelper.localize(""String_Node_Str""),infoScreenX,infoScreenW,infroScreenY1,GREEN);
    }
  }
 else {
    drawString(getTextLine(1,""String_Node_Str""),infoScreenX,infoScreenW,infroScreenY1,GREEN);
    drawString(getTextLine(2,""String_Node_Str""),infoScreenX,infoScreenW,infroScreenY2,GREEN);
  }
}","protected void drawText(){
  drawString(StringHelper.localize(""String_Node_Str""),5,GRAY);
  drawString(StringHelper.localize(""String_Node_Str"") + ""String_Node_Str"" + StringHelper.getScaledNumber(miner.getRange()),infoScreenX,infoScreenW,infroScreenY3,(miner.hasUpgrade(UpgradeType.WITHER)) ? GREEN : WHITE);
  if (miner.isInvalidTool()) {
    drawString(getTextLine(1,""String_Node_Str""),infoScreenX,infoScreenW,infroScreenY1,ORANGE);
    drawString(getTextLine(2,""String_Node_Str""),infoScreenX,infoScreenW,infroScreenY2,ORANGE);
  }
 else   if (miner.isLooked()) {
    boolean readyToMine=true;
    if (miner.isFull()) {
      drawString(StringHelper.localize(""String_Node_Str""),infoScreenX,infoScreenW,infroScreenY2,RED);
      readyToMine=false;
    }
 else     if ((!miner.hasFuel()) && (!miner.isBurning())) {
      String fuelString=""String_Node_Str"";
      if (miner.hasEngine())       fuelString=""String_Node_Str"";
      drawString(StringHelper.localize(fuelString),infoScreenX,infoScreenW,infroScreenY2,RED);
      readyToMine=false;
    }
 else     if ((miner.getStackInSlot(1) == null) && (!miner.hasUpgrade(UpgradeType.COBBLE_GEN))) {
      drawString(StringHelper.localize(""String_Node_Str""),infoScreenX,infoScreenW,infroScreenY2,RED);
      readyToMine=false;
    }
 else     if (miner.getStackInSlot(miner.SLOT_PICKAXE) == null) {
      drawString(StringHelper.localize(""String_Node_Str""),infoScreenX,infoScreenW,infroScreenY2,RED);
      readyToMine=false;
    }
 else     if (miner.getStackInSlot(miner.SLOT_SHOVEL) == null) {
      drawString(StringHelper.localize(""String_Node_Str""),infoScreenX,infoScreenW,infroScreenY2,RED);
      readyToMine=false;
    }
 else {
      drawString(StringHelper.getScaledNumber(miner.getMinedBlocks()) + ""String_Node_Str"" + StringHelper.getScaledNumber(miner.getMineBlocks()),infoScreenX,infoScreenW,infroScreenY2,BLUE);
    }
    if (!readyToMine) {
      drawString(StringHelper.localize(""String_Node_Str""),infoScreenX,infoScreenW,infroScreenY1,RED);
    }
 else     if (miner.getMinedBlocks() == miner.getMineBlocks()) {
      drawString(StringHelper.localize(""String_Node_Str""),infoScreenX,infoScreenW,infroScreenY1,BLUE);
    }
 else {
      drawString(StringHelper.localize(""String_Node_Str""),infoScreenX,infoScreenW,infroScreenY1,GREEN);
    }
  }
 else {
    drawString(getTextLine(1,""String_Node_Str""),infoScreenX,infoScreenW,infroScreenY1,GREEN);
    drawString(getTextLine(2,""String_Node_Str""),infoScreenX,infoScreenW,infroScreenY2,GREEN);
  }
}",0.9659863945578232
80746,"@Override protected void drawText(){
  drawString(StringHelper.localize(""String_Node_Str""),5,GRAY);
  drawString(StringHelper.localize(""String_Node_Str"") + ""String_Node_Str"" + StringHelper.getScaledNumber(planter.getRange()),infoScreenX,infoScreenW,infroScreenY3,(planter.hasUpgrade(UpgradeType.WITHER)) ? GREEN : WHITE);
  if (planter.isInvalidTool()) {
    drawString(getTextLine(1,""String_Node_Str""),infoScreenX,infoScreenW,infroScreenY1,ORANGE);
    drawString(getTextLine(2,""String_Node_Str""),infoScreenX,infoScreenW,infroScreenY2,ORANGE);
  }
 else   if (planter.isLooked()) {
    boolean readyToPlant=false;
    if ((!planter.hasFuel()) && (!planter.isBurning())) {
      String fuelString=""String_Node_Str"";
      if (planter.hasEngine())       fuelString=""String_Node_Str"";
      drawString(StringHelper.localize(fuelString),infoScreenX,infoScreenW,infroScreenY2,RED);
    }
 else     if ((planter.getStackInSlot(planter.SLOT_SEEDS) == null) && (!planter.isBurning())) {
      drawString(StringHelper.localize(""String_Node_Str""),infoScreenX,infoScreenW,infroScreenY2,RED);
    }
 else     if (planter.getStackInSlot(planter.SLOT_HOE) == null) {
      drawString(StringHelper.localize(""String_Node_Str""),infoScreenX,infoScreenW,infroScreenY2,RED);
    }
 else {
      readyToPlant=true;
      String status=""String_Node_Str"";
      if (planter.getStatus() == 1)       status=""String_Node_Str"";
 else       if (planter.getStatus() == 2)       status=""String_Node_Str"";
      drawString(StringHelper.localize(status),infoScreenX,infoScreenW,infroScreenY2,BLUE);
    }
    if (!readyToPlant) {
      drawString(StringHelper.localize(""String_Node_Str""),infoScreenX,infoScreenW,infroScreenY1,RED);
    }
 else     if (planter.isBurning()) {
      drawString(StringHelper.localize(""String_Node_Str""),infoScreenX,infoScreenW,infroScreenY1,BLUE);
    }
 else {
      drawString(StringHelper.localize(""String_Node_Str""),infoScreenX,infoScreenW,infroScreenY1,GREEN);
    }
  }
 else {
    drawString(getTextLine(1,""String_Node_Str""),infoScreenX,infoScreenW,infroScreenY1,GREEN);
    drawString(getTextLine(2,""String_Node_Str""),infoScreenX,infoScreenW,infroScreenY2,GREEN);
  }
}","@Override protected void drawText(){
  drawString(StringHelper.localize(""String_Node_Str""),5,GRAY);
  drawString(StringHelper.localize(""String_Node_Str"") + ""String_Node_Str"" + StringHelper.getScaledNumber(planter.getRange()),infoScreenX,infoScreenW,infroScreenY3,(planter.hasUpgrade(UpgradeType.WITHER)) ? GREEN : WHITE);
  if (planter.isInvalidTool()) {
    drawString(getTextLine(1,""String_Node_Str""),infoScreenX,infoScreenW,infroScreenY1,ORANGE);
    drawString(getTextLine(2,""String_Node_Str""),infoScreenX,infoScreenW,infroScreenY2,ORANGE);
  }
 else   if (planter.isLooked()) {
    boolean readyToPlant=false;
    if (planter.isFull()) {
      drawString(StringHelper.localize(""String_Node_Str""),infoScreenX,infoScreenW,infroScreenY2,RED);
    }
 else     if ((!planter.hasFuel()) && (!planter.isBurning())) {
      String fuelString=""String_Node_Str"";
      if (planter.hasEngine())       fuelString=""String_Node_Str"";
      drawString(StringHelper.localize(fuelString),infoScreenX,infoScreenW,infroScreenY2,RED);
    }
 else     if ((planter.getStackInSlot(planter.SLOT_SEEDS) == null) && (!planter.isBurning())) {
      drawString(StringHelper.localize(""String_Node_Str""),infoScreenX,infoScreenW,infroScreenY2,RED);
    }
 else     if (planter.getStackInSlot(planter.SLOT_HOE) == null) {
      drawString(StringHelper.localize(""String_Node_Str""),infoScreenX,infoScreenW,infroScreenY2,RED);
    }
 else {
      readyToPlant=true;
      String status=""String_Node_Str"";
      if (planter.getStatus() == 1)       status=""String_Node_Str"";
 else       if (planter.getStatus() == 2)       status=""String_Node_Str"";
      drawString(StringHelper.localize(status),infoScreenX,infoScreenW,infroScreenY2,BLUE);
    }
    if (!readyToPlant) {
      drawString(StringHelper.localize(""String_Node_Str""),infoScreenX,infoScreenW,infroScreenY1,RED);
    }
 else     if (planter.isBurning()) {
      drawString(StringHelper.localize(""String_Node_Str""),infoScreenX,infoScreenW,infroScreenY1,BLUE);
    }
 else {
      drawString(StringHelper.localize(""String_Node_Str""),infoScreenX,infoScreenW,infroScreenY1,GREEN);
    }
  }
 else {
    drawString(getTextLine(1,""String_Node_Str""),infoScreenX,infoScreenW,infroScreenY1,GREEN);
    drawString(getTextLine(2,""String_Node_Str""),infoScreenX,infoScreenW,infroScreenY2,GREEN);
  }
}",0.9684023141967067
80747,"public void addRecipe(Block previousTier){
  ShapedOreRecipe recipe=null;
  if (blockLevel == ToolHelper.LEVEL_STONE) {
    recipe=new ShapedOreRecipe(new ItemStack(this),new Object[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'s',Blocks.STONE,'c',previousTier,'p',Items.STONE_AXE});
  }
 else   if (blockLevel == ToolHelper.LEVEL_IRON) {
    recipe=new ShapedOreRecipe(new ItemStack(this),new Object[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'s',Items.IRON_INGOT,'c',previousTier,'p',Items.IRON_AXE,'b',Blocks.IRON_BLOCK});
  }
 else   if (blockLevel == ToolHelper.LEVEL_DIAMOND) {
    recipe=new ShapedOreRecipe(new ItemStack(this),new Object[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'s',Items.DIAMOND,'c',previousTier,'p',Items.DIAMOND_AXE});
  }
 else {
    recipe=new ShapedOreRecipe(new ItemStack(this),new Object[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'s',""String_Node_Str"",'r',previousTier,'c',Blocks.CHEST,'p',Items.WOODEN_AXE});
  }
  GameRegistry.addRecipe(recipe);
}","public void addRecipe(Block previousTier){
  ShapedOreRecipe recipe=null;
  if (blockLevel == ToolHelper.LEVEL_STONE) {
    recipe=new ShapedOreRecipe(new ItemStack(this),new Object[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'s',Blocks.STONE,'c',previousTier,'p',Items.STONE_AXE});
  }
 else   if (blockLevel == ToolHelper.LEVEL_IRON) {
    recipe=new ShapedOreRecipe(new ItemStack(this),new Object[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'s',Items.IRON_INGOT,'c',previousTier,'p',Items.IRON_AXE,'b',Blocks.IRON_BLOCK});
  }
 else   if (blockLevel == ToolHelper.LEVEL_DIAMOND) {
    recipe=new ShapedOreRecipe(new ItemStack(this),new Object[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'s',Items.DIAMOND,'c',previousTier,'p',Items.DIAMOND_AXE});
  }
 else {
    recipe=new ShapedOreRecipe(new ItemStack(this),new Object[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'s',""String_Node_Str"",'r',previousTier,'c',""String_Node_Str"",'p',Items.WOODEN_AXE});
  }
  GameRegistry.addRecipe(recipe);
}",0.986024096385542
80748,"public void addRecipe(Block previousTier){
  ShapedOreRecipe recipe=null;
  if (blockLevel == ToolHelper.LEVEL_STONE) {
    recipe=new ShapedOreRecipe(new ItemStack(this),new Object[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'s',Blocks.STONE,'c',previousTier,'p',Blocks.CRAFTING_TABLE});
  }
 else   if (blockLevel == ToolHelper.LEVEL_IRON) {
    recipe=new ShapedOreRecipe(new ItemStack(this),new Object[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'s',Items.IRON_INGOT,'c',previousTier,'p',Blocks.CRAFTING_TABLE,'b',Blocks.IRON_BLOCK});
  }
 else   if (blockLevel == ToolHelper.LEVEL_DIAMOND) {
    recipe=new ShapedOreRecipe(new ItemStack(this),new Object[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'s',Items.DIAMOND,'c',previousTier,'p',Blocks.CRAFTING_TABLE});
  }
 else {
    recipe=new ShapedOreRecipe(new ItemStack(this),new Object[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'s',""String_Node_Str"",'r',previousTier,'c',Blocks.CHEST,'p',Blocks.CRAFTING_TABLE});
  }
  GameRegistry.addRecipe(recipe);
}","public void addRecipe(Block previousTier){
  ShapedOreRecipe recipe=null;
  if (blockLevel == ToolHelper.LEVEL_STONE) {
    recipe=new ShapedOreRecipe(new ItemStack(this),new Object[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'s',Blocks.STONE,'c',previousTier,'p',Blocks.CRAFTING_TABLE});
  }
 else   if (blockLevel == ToolHelper.LEVEL_IRON) {
    recipe=new ShapedOreRecipe(new ItemStack(this),new Object[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'s',Items.IRON_INGOT,'c',previousTier,'p',Blocks.CRAFTING_TABLE,'b',Blocks.IRON_BLOCK});
  }
 else   if (blockLevel == ToolHelper.LEVEL_DIAMOND) {
    recipe=new ShapedOreRecipe(new ItemStack(this),new Object[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'s',Items.DIAMOND,'c',previousTier,'p',Blocks.CRAFTING_TABLE});
  }
 else {
    recipe=new ShapedOreRecipe(new ItemStack(this),new Object[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'s',""String_Node_Str"",'r',previousTier,'c',""String_Node_Str"",'p',Blocks.CRAFTING_TABLE});
  }
  GameRegistry.addRecipe(recipe);
}",0.9863142991977348
80749,"@Override public void addRecipe(Block previousTier){
  ShapedOreRecipe recipe=null;
  if (blockLevel == ToolHelper.LEVEL_STONE) {
    recipe=new ShapedOreRecipe(new ItemStack(this),new Object[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'s',Blocks.STONE,'c',previousTier,'p',Items.SHEARS});
  }
 else   if (blockLevel == ToolHelper.LEVEL_IRON) {
    recipe=new ShapedOreRecipe(new ItemStack(this),new Object[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'s',Items.IRON_INGOT,'c',previousTier,'p',Items.SHEARS,'b',Blocks.IRON_BLOCK});
  }
 else   if (blockLevel == ToolHelper.LEVEL_DIAMOND) {
    recipe=new ShapedOreRecipe(new ItemStack(this),new Object[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'s',Items.DIAMOND,'c',previousTier,'p',Items.SHEARS});
  }
 else {
    recipe=new ShapedOreRecipe(new ItemStack(this),new Object[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'s',""String_Node_Str"",'r',previousTier,'c',Blocks.CHEST,'p',Items.SHEARS});
  }
  GameRegistry.addRecipe(recipe);
}","@Override public void addRecipe(Block previousTier){
  ShapedOreRecipe recipe=null;
  if (blockLevel == ToolHelper.LEVEL_STONE) {
    recipe=new ShapedOreRecipe(new ItemStack(this),new Object[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'s',Blocks.STONE,'c',previousTier,'p',Items.SHEARS});
  }
 else   if (blockLevel == ToolHelper.LEVEL_IRON) {
    recipe=new ShapedOreRecipe(new ItemStack(this),new Object[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'s',Items.IRON_INGOT,'c',previousTier,'p',Items.SHEARS,'b',Blocks.IRON_BLOCK});
  }
 else   if (blockLevel == ToolHelper.LEVEL_DIAMOND) {
    recipe=new ShapedOreRecipe(new ItemStack(this),new Object[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'s',Items.DIAMOND,'c',previousTier,'p',Items.SHEARS});
  }
 else {
    recipe=new ShapedOreRecipe(new ItemStack(this),new Object[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'s',""String_Node_Str"",'r',previousTier,'c',""String_Node_Str"",'p',Items.SHEARS});
  }
  GameRegistry.addRecipe(recipe);
}",0.9317851959361392
80750,"@Override public void addRecipe(Block previousTier){
  ShapedOreRecipe recipe=null;
  if (blockLevel == ToolHelper.LEVEL_STONE) {
    recipe=new ShapedOreRecipe(new ItemStack(this),new Object[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'s',Blocks.STONE,'c',previousTier,'p',Items.STONE_SWORD});
  }
 else   if (blockLevel == ToolHelper.LEVEL_IRON) {
    recipe=new ShapedOreRecipe(new ItemStack(this),new Object[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'s',Items.IRON_INGOT,'c',previousTier,'p',Items.IRON_SWORD,'b',Blocks.IRON_BLOCK});
  }
 else   if (blockLevel == ToolHelper.LEVEL_DIAMOND) {
    recipe=new ShapedOreRecipe(new ItemStack(this),new Object[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'s',Items.DIAMOND,'c',previousTier,'p',Items.DIAMOND_SWORD});
  }
 else {
    recipe=new ShapedOreRecipe(new ItemStack(this),new Object[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'s',""String_Node_Str"",'r',previousTier,'c',Blocks.CHEST,'p',Items.WOODEN_SWORD});
  }
  GameRegistry.addRecipe(recipe);
}","@Override public void addRecipe(Block previousTier){
  ShapedOreRecipe recipe=null;
  if (blockLevel == ToolHelper.LEVEL_STONE) {
    recipe=new ShapedOreRecipe(new ItemStack(this),new Object[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'s',Blocks.STONE,'c',previousTier,'p',Items.STONE_SWORD});
  }
 else   if (blockLevel == ToolHelper.LEVEL_IRON) {
    recipe=new ShapedOreRecipe(new ItemStack(this),new Object[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'s',Items.IRON_INGOT,'c',previousTier,'p',Items.IRON_SWORD,'b',Blocks.IRON_BLOCK});
  }
 else   if (blockLevel == ToolHelper.LEVEL_DIAMOND) {
    recipe=new ShapedOreRecipe(new ItemStack(this),new Object[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'s',Items.DIAMOND,'c',previousTier,'p',Items.DIAMOND_SWORD});
  }
 else {
    recipe=new ShapedOreRecipe(new ItemStack(this),new Object[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'s',""String_Node_Str"",'r',previousTier,'c',""String_Node_Str"",'p',Items.WOODEN_SWORD});
  }
  GameRegistry.addRecipe(recipe);
}",0.9862624348649928
80751,"public void addRecipe(Block previousTier){
  ShapedOreRecipe recipe=null;
  if (blockLevel == ToolHelper.LEVEL_STONE) {
    recipe=new ShapedOreRecipe(new ItemStack(this),new Object[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'s',Blocks.STONE,'c',previousTier,'p',Items.STONE_PICKAXE});
  }
 else   if (blockLevel == ToolHelper.LEVEL_IRON) {
    recipe=new ShapedOreRecipe(new ItemStack(this),new Object[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'s',Items.IRON_INGOT,'c',previousTier,'p',Items.IRON_PICKAXE,'b',Blocks.IRON_BLOCK});
  }
 else   if (blockLevel == ToolHelper.LEVEL_DIAMOND) {
    recipe=new ShapedOreRecipe(new ItemStack(this),new Object[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'s',Items.DIAMOND,'c',previousTier,'p',Items.DIAMOND_PICKAXE});
  }
 else {
    recipe=new ShapedOreRecipe(new ItemStack(this),new Object[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'s',""String_Node_Str"",'r',previousTier,'c',Blocks.CHEST,'p',Items.WOODEN_PICKAXE});
  }
  GameRegistry.addRecipe(recipe);
}","public void addRecipe(Block previousTier){
  ShapedOreRecipe recipe=null;
  if (blockLevel == ToolHelper.LEVEL_STONE) {
    recipe=new ShapedOreRecipe(new ItemStack(this),new Object[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'s',Blocks.STONE,'c',previousTier,'p',Items.STONE_PICKAXE});
  }
 else   if (blockLevel == ToolHelper.LEVEL_IRON) {
    recipe=new ShapedOreRecipe(new ItemStack(this),new Object[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'s',Items.IRON_INGOT,'c',previousTier,'p',Items.IRON_PICKAXE,'b',Blocks.IRON_BLOCK});
  }
 else   if (blockLevel == ToolHelper.LEVEL_DIAMOND) {
    recipe=new ShapedOreRecipe(new ItemStack(this),new Object[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'s',Items.DIAMOND,'c',previousTier,'p',Items.DIAMOND_PICKAXE});
  }
 else {
    recipe=new ShapedOreRecipe(new ItemStack(this),new Object[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'s',""String_Node_Str"",'r',previousTier,'c',""String_Node_Str"",'p',Items.WOODEN_PICKAXE});
  }
  GameRegistry.addRecipe(recipe);
}",0.9862363550071191
80752,"public void addRecipe(Block previousTier){
  ShapedOreRecipe recipe=null;
  if (blockLevel == ToolHelper.LEVEL_STONE) {
    recipe=new ShapedOreRecipe(new ItemStack(this),new Object[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'s',Blocks.STONE,'c',previousTier,'p',Items.STONE_HOE});
  }
 else   if (blockLevel == ToolHelper.LEVEL_IRON) {
    recipe=new ShapedOreRecipe(new ItemStack(this),new Object[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'s',Items.IRON_INGOT,'c',previousTier,'p',Items.IRON_HOE,'b',Blocks.IRON_BLOCK});
  }
 else   if (blockLevel == ToolHelper.LEVEL_DIAMOND) {
    recipe=new ShapedOreRecipe(new ItemStack(this),new Object[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'s',Items.DIAMOND,'c',previousTier,'p',Items.DIAMOND_HOE});
  }
 else {
    recipe=new ShapedOreRecipe(new ItemStack(this),new Object[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'s',""String_Node_Str"",'r',previousTier,'c',Blocks.CHEST,'p',Items.WOODEN_HOE});
  }
  GameRegistry.addRecipe(recipe);
}","public void addRecipe(Block previousTier){
  ShapedOreRecipe recipe=null;
  if (blockLevel == ToolHelper.LEVEL_STONE) {
    recipe=new ShapedOreRecipe(new ItemStack(this),new Object[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'s',Blocks.STONE,'c',previousTier,'p',Items.STONE_HOE});
  }
 else   if (blockLevel == ToolHelper.LEVEL_IRON) {
    recipe=new ShapedOreRecipe(new ItemStack(this),new Object[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'s',Items.IRON_INGOT,'c',previousTier,'p',Items.IRON_HOE,'b',Blocks.IRON_BLOCK});
  }
 else   if (blockLevel == ToolHelper.LEVEL_DIAMOND) {
    recipe=new ShapedOreRecipe(new ItemStack(this),new Object[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'s',Items.DIAMOND,'c',previousTier,'p',Items.DIAMOND_HOE});
  }
 else {
    recipe=new ShapedOreRecipe(new ItemStack(this),new Object[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",'s',""String_Node_Str"",'r',previousTier,'c',""String_Node_Str"",'p',Items.WOODEN_HOE});
  }
  GameRegistry.addRecipe(recipe);
}",0.9272289156626506
80753,"public void mine(){
  if ((slots[1] == null) || (slots[2] == null) || (slots[3] == null))   return;
  if (currentBlock != null) {
    if (miningTime <= 0) {
      miningTime=0;
      Point2I currentPoint=spiral(currentColumn,pos.getX(),pos.getZ());
      BlockPos currentPosition=new BlockPos(currentPoint.getX(),currentYLevel,currentPoint.getY());
      if (miningWith != 4) {
        if (worldObj.getTileEntity(currentPosition) instanceof IInventory) {
          IInventory inv=(IInventory)worldObj.getTileEntity(currentPosition);
          for (int i=0; i < inv.getSizeInventory(); i++) {
            if (inv.getStackInSlot(i) != null) {
              addToInventory(inv.getStackInSlot(i));
              inv.setInventorySlotContents(i,null);
            }
          }
        }
        int silkTouch=0;
        if (miningWith != 1) {
          silkTouch=EnchantmentHelper.getEnchantmentLevel(Enchantments.SILK_TOUCH,slots[miningWith]);
        }
        if (silkTouch > 0) {
          int i=0;
          Item item=Item.getItemFromBlock(currentBlock);
          if (item != null && item.getHasSubtypes())           i=currentBlock.getMetaFromState(worldObj.getBlockState(currentPosition));
          ItemStack addItem=new ItemStack(currentBlock,1,i);
          addToInventory(addItem);
        }
 else {
          int fortuneLevel=0;
          if (miningWith != 1) {
            fortuneLevel=EnchantmentHelper.getEnchantmentLevel(Enchantments.FORTUNE,slots[miningWith]);
          }
          List<ItemStack> items=currentBlock.getDrops(worldObj,currentPosition,worldObj.getBlockState(currentPosition),fortuneLevel);
          for (          ItemStack item : items) {
            addToInventory(item);
          }
        }
        if (miningWith != 1) {
          if (ToolHelper.damageTool(slots[miningWith],worldObj,currentPoint.getX(),currentYLevel,currentPoint.getY())) {
            destroyTool(miningWith);
          }
        }
      }
      worldObj.removeTileEntity(currentPosition);
      worldObj.setBlockState(currentPosition,Blocks.COBBLESTONE.getDefaultState());
      slots[1].stackSize--;
      if (slots[1].stackSize == 0) {
        slots[1]=null;
      }
      currentMineBlocks++;
      addPartialUpdate(""String_Node_Str"",currentMineBlocks);
      currentBlock=null;
    }
 else {
      miningTime--;
    }
  }
 else {
    if (!isDone()) {
      currentBlock=getNextBlock();
      if (currentBlock != null) {
        Point2I currentPoint=spiral(currentColumn,pos.getX(),pos.getZ());
        BlockPos currentPosition=new BlockPos(currentPoint.getX(),currentYLevel,currentPoint.getY());
        IBlockState currentBlockState=worldObj.getBlockState(currentPosition);
        if (miningWith == 4) {
          miningTime=1;
        }
 else {
          miningTime=(int)Math.ceil(currentBlock.getBlockHardness(currentBlockState,worldObj,currentPosition) * 1.5 * 20);
          if (miningWith != 1) {
            float miningSpeed=ToolHelper.getDigSpeed(slots[miningWith],currentBlockState);
            if (miningSpeed > 1) {
              int eff=EnchantmentHelper.getEnchantmentLevel(Enchantments.EFFICIENCY,slots[miningWith]);
              if (eff > 0) {
                for (int i=0; i < eff; i++) {
                  miningSpeed=miningSpeed * 1.3f;
                }
              }
            }
            miningTime=(int)Math.ceil(miningTime / miningSpeed);
          }
        }
      }
    }
  }
  if (isDone()) {
    scanBlocks();
    currentColumn=getRange();
  }
}","public void mine(){
  if ((slots[1] == null) || (slots[2] == null) || (slots[3] == null))   return;
  if (currentBlock != null) {
    if (elapsedDuration >= blockMineDuration) {
      Point2I currentPoint=spiral(currentColumn,pos.getX(),pos.getZ());
      BlockPos currentPosition=new BlockPos(currentPoint.getX(),currentYLevel,currentPoint.getY());
      Block testBlock=worldObj.getBlockState(currentPosition).getBlock();
      if (testBlock != currentBlock) {
        currentBlock=testBlock;
        miningWith=canMineBlock(currentPosition.getX(),currentPosition.getY(),currentPosition.getZ());
        if (miningWith == -1) {
          miningWith=2;
        }
        blockMineDuration=miningDuration(currentPosition,miningWith);
        if (elapsedDuration < blockMineDuration) {
          elapsedDuration++;
          return;
        }
      }
      if (miningWith != 4) {
        if (worldObj.getTileEntity(currentPosition) instanceof IInventory) {
          IInventory inv=(IInventory)worldObj.getTileEntity(currentPosition);
          for (int i=0; i < inv.getSizeInventory(); i++) {
            if (inv.getStackInSlot(i) != null) {
              addToInventory(inv.getStackInSlot(i));
              inv.setInventorySlotContents(i,null);
            }
          }
        }
        int silkTouch=0;
        if (miningWith != 1) {
          silkTouch=EnchantmentHelper.getEnchantmentLevel(Enchantments.SILK_TOUCH,slots[miningWith]);
        }
        if (silkTouch > 0) {
          int i=0;
          Item item=Item.getItemFromBlock(currentBlock);
          if (item != null && item.getHasSubtypes())           i=currentBlock.getMetaFromState(worldObj.getBlockState(currentPosition));
          ItemStack addItem=new ItemStack(currentBlock,1,i);
          addToInventory(addItem);
        }
 else {
          int fortuneLevel=0;
          if (miningWith != 1) {
            fortuneLevel=EnchantmentHelper.getEnchantmentLevel(Enchantments.FORTUNE,slots[miningWith]);
          }
          List<ItemStack> items=currentBlock.getDrops(worldObj,currentPosition,worldObj.getBlockState(currentPosition),fortuneLevel);
          for (          ItemStack item : items) {
            addToInventory(item);
          }
        }
        if (miningWith != 1) {
          if (ToolHelper.damageTool(slots[miningWith],worldObj,currentPoint.getX(),currentYLevel,currentPoint.getY())) {
            destroyTool(miningWith);
          }
        }
      }
      worldObj.removeTileEntity(currentPosition);
      worldObj.setBlockState(currentPosition,Blocks.COBBLESTONE.getDefaultState());
      slots[1].stackSize--;
      if (slots[1].stackSize == 0) {
        slots[1]=null;
      }
      currentMineBlocks++;
      addPartialUpdate(""String_Node_Str"",currentMineBlocks);
      currentBlock=null;
      elapsedDuration=0;
    }
 else {
      elapsedDuration++;
    }
  }
 else {
    if (!isDone()) {
      currentBlock=getNextBlock();
      if (currentBlock != null) {
        Point2I currentPoint=spiral(currentColumn,pos.getX(),pos.getZ());
        BlockPos currentPosition=new BlockPos(currentPoint.getX(),currentYLevel,currentPoint.getY());
        blockMineDuration=miningDuration(currentPosition,miningWith);
      }
    }
  }
  if (isDone()) {
    scanBlocks();
    currentColumn=getRange();
  }
}",0.759169244365886
80754,"public void checkForChanges(){
  boolean update=false;
  if ((slots[2] == null) && (lastPick >= 0)) {
    lastPick=-1;
    update=true;
  }
 else   if (slots[2] != null) {
    if (ToolHelper.getLevel(slots[2]) != lastPick) {
      lastPick=ToolHelper.getLevel(slots[2]);
      update=true;
    }
  }
  if ((slots[3] == null) && (lastShovel >= 0)) {
    lastShovel=-1;
    update=true;
  }
 else   if (slots[3] != null) {
    if (ToolHelper.getLevel(slots[3]) != lastShovel) {
      lastShovel=ToolHelper.getLevel(slots[3]);
      update=true;
    }
  }
  if (previousUpgrades != getUpgrades()) {
    previousUpgrades=getUpgrades();
    update=true;
  }
  if (update) {
    scanBlocks();
    currentColumn=getRange();
    currentBlock=null;
    miningTime=0;
    currentYLevel=pos.getY() - 1;
  }
}","public void checkForChanges(){
  boolean update=false;
  if ((slots[2] == null) && (lastPick >= 0)) {
    lastPick=-1;
    update=true;
  }
 else   if (slots[2] != null) {
    if (ToolHelper.getLevel(slots[2]) != lastPick) {
      lastPick=ToolHelper.getLevel(slots[2]);
      update=true;
    }
  }
  if ((slots[3] == null) && (lastShovel >= 0)) {
    lastShovel=-1;
    update=true;
  }
 else   if (slots[3] != null) {
    if (ToolHelper.getLevel(slots[3]) != lastShovel) {
      lastShovel=ToolHelper.getLevel(slots[3]);
      update=true;
    }
  }
  if (previousUpgrades != getUpgrades()) {
    previousUpgrades=getUpgrades();
    update=true;
  }
  if (update) {
    scanBlocks();
    currentColumn=getRange();
    currentBlock=null;
    elapsedDuration=0;
    blockMineDuration=0;
    currentYLevel=pos.getY() - 1;
  }
}",0.9692118226600984
80755,"@Override public void update(){
  super.update();
  if (!worldObj.isRemote) {
    if (slots[SLOT_CHARGER] != null) {
      if (currentStorage > 0) {
        if (slots[SLOT_CHARGER].getItem() instanceof IEnergyContainerItem) {
          IEnergyContainerItem container=(IEnergyContainerItem)slots[SLOT_CHARGER].getItem();
          if (container.getEnergyStored(slots[SLOT_CHARGER]) < container.getMaxEnergyStored(slots[SLOT_CHARGER])) {
            int giveAmount=container.receiveEnergy(slots[SLOT_CHARGER],currentStorage,false);
            if (giveAmount > 0)             changeCharge(giveAmount * -1);
          }
        }
      }
    }
    outputEnergy();
  }
}","@Override public void update(){
  super.update();
  if (!worldObj.isRemote) {
    if (slots[SLOT_CHARGER] != null) {
      if (currentStorage > 0) {
        if (slots[SLOT_CHARGER].getItem() instanceof IEnergyContainerItem) {
          IEnergyContainerItem container=(IEnergyContainerItem)slots[SLOT_CHARGER].getItem();
          if (container.getEnergyStored(slots[SLOT_CHARGER]) < container.getMaxEnergyStored(slots[SLOT_CHARGER])) {
            int giveAmount=container.receiveEnergy(slots[SLOT_CHARGER],currentStorage,false);
            if (giveAmount > 0)             changeCharge(giveAmount * -1);
          }
        }
      }
    }
    if (worldObj.getRedstonePower(pos,EnumFacing.UP) == 0 || worldObj.getRedstonePower(pos,EnumFacing.DOWN) == 0 || worldObj.getRedstonePower(pos,EnumFacing.NORTH) == 0 || worldObj.getRedstonePower(pos,EnumFacing.SOUTH) == 0 || worldObj.getRedstonePower(pos,EnumFacing.WEST) == 0 || worldObj.getRedstonePower(pos,EnumFacing.EAST) == 0) {
      outputEnergy();
    }
  }
}",0.7902264600715138
80756,"@Override public int receiveEnergy(EnumFacing from,int maxReceive,boolean simulate){
  int energyReceived=0;
  if (from.getOpposite().getIndex() == getBlockMetadata()) {
    if (!simulate) {
      if (maxReceive > transferRate) {
        energyReceived=transferRate;
      }
 else {
        energyReceived=maxReceive;
      }
      changeCharge(energyReceived);
    }
  }
  return energyReceived;
}","@Override public int receiveEnergy(EnumFacing from,int maxReceive,boolean simulate){
  int energyReceived=0;
  if (from.getOpposite().getIndex() == getBlockMetadata()) {
    if (currentStorage + maxReceive <= maxStorage || currentStorage + transferRate <= maxStorage) {
      if (!simulate) {
        if (maxReceive > transferRate) {
          energyReceived=transferRate;
        }
 else {
          energyReceived=maxReceive;
        }
        changeCharge(energyReceived);
      }
    }
  }
  return energyReceived;
}",0.8671023965141612
80757,"@Override public boolean isLog(ItemStack item){
  if (item == null)   return false;
  return (item.getUnlocalizedName().contains(""String_Node_Str""));
}","@Override public boolean isLog(ItemStack item){
  if (item == null)   return false;
  if (item.getItem() == null)   return false;
  return (item.getItem().getUnlocalizedName().contains(""String_Node_Str""));
}",0.776536312849162
80758,"@Override public boolean isLeaf(ItemStack item){
  if (item == null)   return false;
  Boolean rv=false;
  try {
    rv=item.getUnlocalizedName().contains(""String_Node_Str"");
  }
 catch (  java.lang.NullPointerException e) {
    ProgressiveAutomation.logger.warn(""String_Node_Str"");
  }
  return rv;
}","@Override public boolean isLeaf(ItemStack item){
  if (item == null)   return false;
  if (item.getItem() == null)   return false;
  return (item.getItem().getUnlocalizedName().contains(""String_Node_Str""));
}",0.581532416502947
80759,"public int getMaxEnergyStored(EnumFacing from){
  if (slots[SLOT_FUEL].getItem() instanceof ItemRFEngine) {
    return getEngine().getMaxCharge();
  }
 else {
    return 0;
  }
}","public int getMaxEnergyStored(EnumFacing from){
  if (slots[SLOT_FUEL] != null && slots[SLOT_FUEL].getItem() instanceof ItemRFEngine) {
    return getEngine().getMaxCharge();
  }
 else {
    return 0;
  }
}",0.9270833333333334
80760,"public boolean isItemValidForSlot(int slot,ItemStack stack){
  if ((slot == SLOT_FUEL) && (getItemBurnTime(stack) > 0) && (ToolHelper.getType(stack) == -1)) {
    return true;
  }
  return false;
}","public boolean isItemValidForSlot(int slot,ItemStack stack){
  if ((slot == SLOT_FUEL) && (getItemBurnTime(stack) > 0) && (ToolHelper.getType(stack) == -1)) {
    return true;
  }
  if (((slot >= SLOT_INVENTORY_START) && (slot <= SLOT_INVENTORY_END)) && (SLOT_INVENTORY_START != SLOT_INVENTORY_END)) {
    return true;
  }
  return false;
}",0.6964618249534451
80761,"@EventHandler public void init(FMLInitializationEvent event){
  PAItems.init();
  PABlocks.init();
  NetworkRegistry.INSTANCE.registerGuiHandler(instance,guiHandler);
  FMLCommonHandler.instance().bus().register(instance);
  MinecraftForge.EVENT_BUS.register(new EventRenderWorld());
}","@EventHandler public void init(FMLInitializationEvent event){
  PAItems.init();
  PABlocks.init();
  NetworkRegistry.INSTANCE.registerGuiHandler(instance,guiHandler);
  FMLCommonHandler.instance().bus().register(instance);
  proxy.init();
}",0.8723809523809524
80762,"public UpgradeableTileEntity(int numSlots){
  super(numSlots);
  installedUpgrades=new EnumMap<UpgradeType,Integer>(UpgradeType.class);
  allowedUpgrades=Collections.emptySet();
  EventRenderWorld.addMachine(this);
}","public UpgradeableTileEntity(int numSlots){
  super(numSlots);
  installedUpgrades=new EnumMap<UpgradeType,Integer>(UpgradeType.class);
  allowedUpgrades=Collections.emptySet();
  if (ProgressiveAutomation.proxy.isClient()) {
    EventRenderWorld.addMachine(this);
  }
}",0.8888888888888888
80763,"@SubscribeEvent(priority=EventPriority.HIGHEST) public void renderWorldLast(RenderWorldLastEvent e){
  EntityPlayer player=Minecraft.getMinecraft().thePlayer;
  boolean holdingWrench=false;
  if (player.inventory.getCurrentItem() == null)   return;
  if (ProgressiveAutomation.proxy.isServer())   return;
  if (player.inventory.getCurrentItem().getItem().equals(PAItems.wrench))   holdingWrench=true;
  float playerOffsetX=-(float)(player.lastTickPosX + (player.posX - player.lastTickPosX) * e.partialTicks);
  float playerOffsetY=-(float)(player.lastTickPosY + (player.posY - player.lastTickPosY) * e.partialTicks);
  float playerOffsetZ=-(float)(player.lastTickPosZ + (player.posZ - player.lastTickPosZ) * e.partialTicks);
  GL11.glColorMask(true,true,true,true);
  GL11.glEnable(GL11.GL_ALPHA_TEST);
  GL11.glDisable(GL11.GL_FOG);
  GL11.glEnable(GL11.GL_CULL_FACE);
  GL11.glEnable(GL11.GL_BLEND);
  GL11.glBlendFunc(GL11.GL_SRC_ALPHA,GL11.GL_ONE_MINUS_SRC_ALPHA);
  GL11.glDisable(GL11.GL_TEXTURE_2D);
  GL11.glShadeModel(GL11.GL_FLAT);
  for (  UpgradeableTileEntity machine : machines) {
    if (((TileEntity)machine).isInvalid())     continue;
    if (!machine.getWorldObj().isRemote)     continue;
    if (!holdingWrench && !machine.displayRange())     continue;
    float r=randomColour(machine.xCoord);
    float g=randomColour(machine.yCoord);
    float b=randomColour(machine.zCoord);
    GL11.glPushMatrix();
    GL11.glColor4f(r,g,b,0.4F);
    GL11.glTranslatef(playerOffsetX,playerOffsetY,playerOffsetZ);
    Point3I block=machine.getRangeBlock();
    renderBlock(block.getX(),block.getY(),block.getZ());
    GL11.glPopMatrix();
  }
  GL11.glEnable(GL11.GL_TEXTURE_2D);
}","@SubscribeEvent(priority=EventPriority.HIGHEST) public void renderWorldLast(RenderWorldLastEvent e){
  if (ProgressiveAutomation.proxy.isServer())   return;
  EntityPlayer player=Minecraft.getMinecraft().thePlayer;
  boolean holdingWrench=false;
  if (player.inventory.getCurrentItem() == null)   return;
  if (player.inventory.getCurrentItem().getItem().equals(PAItems.wrench))   holdingWrench=true;
  float playerOffsetX=-(float)(player.lastTickPosX + (player.posX - player.lastTickPosX) * e.partialTicks);
  float playerOffsetY=-(float)(player.lastTickPosY + (player.posY - player.lastTickPosY) * e.partialTicks);
  float playerOffsetZ=-(float)(player.lastTickPosZ + (player.posZ - player.lastTickPosZ) * e.partialTicks);
  GL11.glColorMask(true,true,true,true);
  GL11.glEnable(GL11.GL_ALPHA_TEST);
  GL11.glDisable(GL11.GL_FOG);
  GL11.glEnable(GL11.GL_CULL_FACE);
  GL11.glEnable(GL11.GL_BLEND);
  GL11.glBlendFunc(GL11.GL_SRC_ALPHA,GL11.GL_ONE_MINUS_SRC_ALPHA);
  GL11.glDisable(GL11.GL_TEXTURE_2D);
  GL11.glShadeModel(GL11.GL_FLAT);
  for (  UpgradeableTileEntity machine : machines) {
    if (((TileEntity)machine).isInvalid())     continue;
    if (!machine.getWorldObj().isRemote)     continue;
    if (!holdingWrench && !machine.displayRange())     continue;
    float r=randomColour(machine.xCoord);
    float g=randomColour(machine.yCoord);
    float b=randomColour(machine.zCoord);
    GL11.glPushMatrix();
    GL11.glColor4f(r,g,b,0.4F);
    GL11.glTranslatef(playerOffsetX,playerOffsetY,playerOffsetZ);
    Point3I block=machine.getRangeBlock();
    renderBlock(block.getX(),block.getY(),block.getZ());
    GL11.glPopMatrix();
  }
  GL11.glEnable(GL11.GL_TEXTURE_2D);
}",0.966804979253112
80764,"public boolean addToInventory(ItemStack item){
  if ((SLOT_INVENTORY_START == -1) || (SLOT_INVENTORY_END == -1))   return false;
  int extraSlot=extraSlotCheck(item);
  if (extraSlot >= 0) {
    item=moveItemToSlot(item,extraSlot);
  }
  for (int i=SLOT_INVENTORY_START; i <= SLOT_INVENTORY_END; i++) {
    if (slots[i] != null) {
      if (item != null) {
        if ((slots[i].isItemEqual(item)) && (slots[i].stackSize < slots[i].getMaxStackSize()) && (ItemStack.areItemStackTagsEqual(item,slots[i]))) {
          int avail=slots[i].getMaxStackSize() - slots[i].stackSize;
          if (avail >= item.stackSize) {
            slots[i].stackSize+=item.stackSize;
            item=null;
            return true;
          }
 else {
            item.stackSize-=avail;
            slots[i].stackSize+=avail;
          }
        }
      }
    }
  }
  if ((item != null) && (item.stackSize > 0)) {
    for (int i=SLOT_INVENTORY_START; i <= SLOT_INVENTORY_END; i++) {
      if (slots[i] == null) {
        if (this.isItemValidForSlot(i,item)) {
          slots[i]=item;
          item=null;
          return true;
        }
      }
    }
  }
  if ((item != null) && (item.stackSize == 0)) {
    item=null;
  }
  if (item != null) {
    dropItem(item);
    item=null;
  }
  return false;
}","public boolean addToInventory(ItemStack item){
  if ((SLOT_INVENTORY_START == -1) || (SLOT_INVENTORY_END == -1))   return false;
  int extraSlot=extraSlotCheck(item);
  if (extraSlot >= 0) {
    item=moveItemToSlot(item,extraSlot);
  }
  for (int i=SLOT_INVENTORY_START; i <= SLOT_INVENTORY_END; i++) {
    if (slots[i] != null) {
      if (item != null) {
        if ((slots[i].isItemEqual(item)) && (slots[i].stackSize < slots[i].getMaxStackSize()) && (ItemStack.areItemStackTagsEqual(item,slots[i]))) {
          int avail=slots[i].getMaxStackSize() - slots[i].stackSize;
          if (avail >= item.stackSize) {
            slots[i].stackSize+=item.stackSize;
            item=null;
            return true;
          }
 else {
            item.stackSize-=avail;
            slots[i].stackSize+=avail;
          }
        }
      }
    }
  }
  if ((item != null) && (item.stackSize > 0)) {
    for (int i=SLOT_INVENTORY_START; i <= SLOT_INVENTORY_END; i++) {
      if (slots[i] == null) {
        if (this.isItemValidForSlot(i,item,true)) {
          slots[i]=item;
          item=null;
          return true;
        }
      }
    }
  }
  if ((item != null) && (item.stackSize == 0)) {
    item=null;
  }
  if (item != null) {
    dropItem(item);
    item=null;
  }
  return false;
}",0.99805523142746
80765,"public boolean isItemValidForSlot(int slot,ItemStack stack){
  if ((slot == SLOT_FUEL) && (getItemBurnTime(stack) > 0) && (ToolHelper.getType(stack) == -1)) {
    return true;
  }
  if (((slot >= SLOT_INVENTORY_START) && (slot <= SLOT_INVENTORY_END)) && (SLOT_INVENTORY_START != SLOT_INVENTORY_END)) {
    return true;
  }
  return false;
}","public boolean isItemValidForSlot(int slot,ItemStack stack,boolean internalStorage){
  if ((slot == SLOT_FUEL) && (getItemBurnTime(stack) > 0) && (ToolHelper.getType(stack) == -1)) {
    return true;
  }
  if (((slot >= SLOT_INVENTORY_START) && (slot <= SLOT_INVENTORY_END)) && (SLOT_INVENTORY_START != SLOT_INVENTORY_END) && (internalStorage)) {
    return true;
  }
  return false;
}",0.9379310344827586
80766,"@Override public boolean canExtractItem(int slot,ItemStack stack,int side){
  if (sides[side] == WrenchModes.Mode.Disabled)   return false;
  if ((sides[side] == WrenchModes.Mode.Normal) || (sides[side] == WrenchModes.Mode.Output)) {
    if (slot == OUTPUT_SLOT) {
      return true;
    }
 else     if ((slot >= SLOT_INVENTORY_START) && (slot <= SLOT_INVENTORY_END) && (side != 0)) {
      return true;
    }
  }
  return false;
}","@Override public boolean canExtractItem(int slot,ItemStack stack,int side){
  if (sides[side] == WrenchModes.Mode.Disabled)   return false;
  if ((sides[side] == WrenchModes.Mode.Output) || (sides[side] == WrenchModes.Mode.Normal)) {
    if (slot == OUTPUT_SLOT) {
      return true;
    }
  }
  if (sides[side] == WrenchModes.Mode.Input) {
    if ((slot >= SLOT_INVENTORY_START) && (slot <= SLOT_INVENTORY_END)) {
      return true;
    }
  }
  return false;
}",0.8946188340807175
80767,"@Override public boolean isItemValidForSlot(int slot,ItemStack stack){
  if (stack == null)   return false;
  if ((slot == this.SLOT_SHEARS) && (stack.getItem() == Items.shears) && (hasUpgrade(UpgradeType.SHEARING))) {
    return true;
  }
 else   if ((slot == this.SLOT_BUCKETS) && (stack.getItem() == Items.bucket) && (hasUpgrade(UpgradeType.MILKER))) {
    return true;
  }
  return super.isItemValidForSlot(slot,stack);
}","@Override public boolean isItemValidForSlot(int slot,ItemStack stack){
  if (stack == null)   return false;
  if ((slot == this.SLOT_FOOD) && (this.isFeed(stack))) {
    return true;
  }
  if ((slot == this.SLOT_SHEARS) && (stack.getItem() == Items.shears) && (hasUpgrade(UpgradeType.SHEARING))) {
    return true;
  }
 else   if ((slot == this.SLOT_BUCKETS) && (stack.getItem() == Items.bucket) && (hasUpgrade(UpgradeType.MILKER))) {
    return true;
  }
  return super.isItemValidForSlot(slot,stack);
}",0.914962325080732
80768,"public boolean isItemValid(ItemStack itemStack){
  if (itemStack.getItem() == Items.wheat)   return true;
  if (itemStack.getItem() == Items.wheat_seeds)   return true;
  if (itemStack.getItem() == Items.carrot)   return true;
  return false;
}","public boolean isItemValid(ItemStack itemStack){
  return TileFarmer.isFeed(itemStack);
}",0.3963963963963964
80769,"public static boolean damageTool(ItemStack tool,World world,int x,int y,int z){
  if ((tool.getItem() instanceof ItemShears) || (tool.getItem() instanceof ItemTool) || (tool.getItem() instanceof ItemHoe)|| (tool.getItem() instanceof ItemSword)) {
    if (tool.attemptDamageItem(1,RND)) {
      return true;
    }
  }
 else {
    Block mineBlock=world.getBlock(x,y,z);
    PlayerFake fakePlayer=new PlayerFake((WorldServer)world);
    tool.getItem().onBlockDestroyed(tool,world,mineBlock,x,y,z,fakePlayer);
  }
  return false;
}","public static boolean damageTool(ItemStack tool,World world,int x,int y,int z){
  if ((tool.getItem() instanceof ItemShears) || (tool.getItem() instanceof ItemTool) || (tool.getItem() instanceof ItemHoe)|| (tool.getItem() instanceof ItemSword)) {
    if (tool.attemptDamageItem(1,RND)) {
      return true;
    }
  }
 else {
    Block mineBlock=world.getBlock(x,y,z);
    PlayerFake fakePlayer=new PlayerFake((WorldServer)world);
    if (tinkersType(tool.getItem()) == TYPE_HOE) {
      tool.attemptDamageItem(1,RND);
    }
 else {
      tool.getItem().onBlockDestroyed(tool,world,mineBlock,x,y,z,fakePlayer);
    }
  }
  return false;
}",0.9054982817869416
80770,"public void updateEntity(){
  super.updateEntity();
  if (!worldObj.isRemote) {
    if (!isBurning()) {
      if (readyToBurn()) {
        if (slots[SLOT_FUEL] != null) {
          if (isFuel()) {
            burnLevel=progress=getBurnTime();
            addPartialUpdate(""String_Node_Str"",progress);
            addPartialUpdate(""String_Node_Str"",burnLevel);
            if (slots[SLOT_FUEL].getItem().hasContainerItem(slots[SLOT_FUEL])) {
              slots[SLOT_FUEL]=slots[SLOT_FUEL].getItem().getContainerItem(slots[SLOT_FUEL]);
            }
 else {
              slots[SLOT_FUEL].stackSize--;
              if (slots[SLOT_FUEL].stackSize == 0) {
                slots[SLOT_FUEL]=null;
              }
            }
          }
 else           if (hasEngine()) {
            if (useEnergy(PAConfig.rfCost,false) > 0) {
              if (burnLevel != 1 || progress != 1) {
                burnLevel=progress=1;
                addPartialUpdate(""String_Node_Str"",progress);
                addPartialUpdate(""String_Node_Str"",burnLevel);
              }
            }
          }
        }
      }
    }
 else {
      progress--;
      if (progress <= 0) {
        burnLevel=progress=0;
        addPartialUpdate(""String_Node_Str"",burnLevel);
        if ((readyToBurn()) && (hasEngine())) {
          if (useEnergy(PAConfig.rfCost,false) > 0) {
            burnLevel=progress=1;
          }
        }
      }
      addPartialUpdate(""String_Node_Str"",progress);
    }
    checkForPowerChange();
  }
}","public void updateEntity(){
  super.updateEntity();
  if (!worldObj.isRemote) {
    if (!isBurning()) {
      RedstonePowered=isIndirectlyPowered();
      if (!RedstonePowered) {
        if (readyToBurn()) {
          if (slots[SLOT_FUEL] != null) {
            if (isFuel()) {
              burnLevel=progress=getBurnTime();
              addPartialUpdate(""String_Node_Str"",progress);
              addPartialUpdate(""String_Node_Str"",burnLevel);
              if (slots[SLOT_FUEL].getItem().hasContainerItem(slots[SLOT_FUEL])) {
                slots[SLOT_FUEL]=slots[SLOT_FUEL].getItem().getContainerItem(slots[SLOT_FUEL]);
              }
 else {
                slots[SLOT_FUEL].stackSize--;
                if (slots[SLOT_FUEL].stackSize == 0) {
                  slots[SLOT_FUEL]=null;
                }
              }
            }
 else             if (hasEngine()) {
              if (useEnergy(PAConfig.rfCost,false) > 0) {
                if (burnLevel != 1 || progress != 1) {
                  burnLevel=progress=1;
                  addPartialUpdate(""String_Node_Str"",progress);
                  addPartialUpdate(""String_Node_Str"",burnLevel);
                }
              }
            }
          }
        }
      }
    }
 else {
      progress--;
      if (progress <= 0) {
        burnLevel=progress=0;
        addPartialUpdate(""String_Node_Str"",burnLevel);
        if ((readyToBurn()) && (hasEngine())) {
          if (useEnergy(PAConfig.rfCost,false) > 0) {
            burnLevel=progress=1;
          }
        }
      }
      addPartialUpdate(""String_Node_Str"",progress);
    }
    checkForPowerChange();
  }
}",0.9569926728257406
80771,"protected boolean checkIngredients(boolean consume){
  List<ItemStack> required=new ArrayList<ItemStack>();
  for (int i=CRAFT_GRID_START; i <= CRAFT_GRID_END; i++) {
    if (this.slots[i] != null) {
      required.add(slots[i].copy());
    }
  }
  if (required.size() == 0)   return false;
  for (int i=SLOT_INVENTORY_START; i <= SLOT_INVENTORY_END; i++) {
    if (slots[i] != null) {
      int amtItems=slots[i].stackSize;
      for (int j=0; j < required.size(); j++) {
        if (required.get(j) != null) {
          if (OreHelper.ItemOreMatch(required.get(j),slots[i])) {
            if (amtItems > 0) {
              amtItems--;
              required.set(j,null);
            }
          }
        }
      }
      if (consume) {
        if (amtItems <= 0) {
          slots[i]=null;
        }
 else {
          slots[i].stackSize=amtItems;
        }
      }
    }
  }
  for (int j=0; j < required.size(); j++) {
    if (required.get(j) != null) {
      required=null;
      return false;
    }
  }
  required=null;
  return true;
}","protected boolean checkIngredients(boolean consume){
  List<ItemStack> required=new ArrayList<ItemStack>();
  for (int i=CRAFT_GRID_START; i <= CRAFT_GRID_END; i++) {
    if (this.slots[i] != null) {
      required.add(slots[i].copy());
    }
  }
  if (required.size() == 0)   return false;
  for (int i=SLOT_INVENTORY_START; i <= SLOT_INVENTORY_END; i++) {
    if (slots[i] != null) {
      int amtItems=slots[i].stackSize;
      for (int j=0; j < required.size(); j++) {
        if (required.get(j) != null) {
          if (OreHelper.ItemOreMatch(required.get(j),slots[i])) {
            if (amtItems > 0) {
              amtItems--;
              required.set(j,null);
            }
          }
        }
      }
      if (consume) {
        if (amtItems <= 0) {
          if (slots[i].getItem().hasContainerItem(slots[i])) {
            this.addToInventory(new ItemStack(slots[i].getItem().getContainerItem(),slots[i].stackSize));
          }
          slots[i]=null;
        }
 else {
          if (slots[i].getItem().hasContainerItem(slots[i])) {
            this.addToInventory(new ItemStack(slots[i].getItem().getContainerItem(),slots[i].stackSize - amtItems));
          }
          slots[i].stackSize=amtItems;
        }
      }
    }
  }
  for (int j=0; j < required.size(); j++) {
    if (required.get(j) != null) {
      required=null;
      return false;
    }
  }
  required=null;
  return true;
}",0.8192574459404325
80772,"public ArrayList<ItemStack> harvestPlant(Point3I plantPoint,Block plantBlock,int metadata,World worldObj){
  ArrayList<ItemStack> items=plantBlock.getDrops(worldObj,plantPoint.getX(),plantPoint.getY(),plantPoint.getZ(),metadata,0);
  worldObj.removeTileEntity(plantPoint.getX(),plantPoint.getY(),plantPoint.getZ());
  worldObj.setBlockToAir(plantPoint.getX(),plantPoint.getY(),plantPoint.getZ());
  return items;
}","public List<ItemStack> harvestPlant(Point3I plantPoint,Block plantBlock,IBlockState state,World worldObj){
  List<ItemStack> items=plantBlock.getDrops(worldObj,plantPoint.toPosition(),state,0);
  worldObj.removeTileEntity(plantPoint.toPosition());
  worldObj.setBlockToAir(plantPoint.toPosition());
  return items;
}",0.7150684931506849
80773,"public boolean isPlant(Block plantBlock,int metadata){
  return false;
}","public boolean isPlant(Block plantBlock,IBlockState state){
  return false;
}",0.8590604026845637
80774,"public boolean isGrown(Point3I plantPoint,Block plantBlock,int metadata,World worldObj){
  return false;
}","public boolean isGrown(Point3I plantPoint,Block plantBlock,IBlockState state,World worldObj){
  return false;
}",0.9032258064516128
80775,"public static ArrayList<ItemStack> harvestPlant(Point3I plantPoint,Block plantBlock,int metadata,World worldObj){
  ArrayList<ItemStack> items=null;
  for (  BaseMod mod : modsLoaded) {
    if (mod.isPlant(plantBlock,metadata)) {
      if (mod.isGrown(plantPoint,plantBlock,metadata,worldObj)) {
        items=mod.harvestPlant(plantPoint,plantBlock,metadata,worldObj);
        if (items != null)         return items;
      }
    }
  }
  return null;
}","public static List<ItemStack> harvestPlant(Point3I plantPoint,Block plantBlock,IBlockState state,World worldObj){
  List<ItemStack> items=null;
  for (  BaseMod mod : modsLoaded) {
    if (mod.isPlant(plantBlock,state)) {
      if (mod.isGrown(plantPoint,plantBlock,state,worldObj)) {
        items=mod.harvestPlant(plantPoint,plantBlock,state,worldObj);
        if (items != null)         return items;
      }
    }
  }
  return null;
}",0.9123595505617976
80776,"public static boolean isPlant(Block plantBlock,int metadata){
  for (  BaseMod mod : modsLoaded) {
    if (mod.isPlant(plantBlock,metadata))     return true;
  }
  return false;
}","public static boolean isPlant(Block plantBlock,IBlockState state){
  for (  BaseMod mod : modsLoaded) {
    if (mod.isPlant(plantBlock,state))     return true;
  }
  return false;
}",0.9222222222222224
80777,"private static void registerMods(){
  registerMod(new Pams());
  registerMod(new Pneumaticcraft());
  registerMod(new MFR());
  registerMod(new AgriCraft());
  registerMod(new RightClick());
  registerMod(new Vanilla());
}","private static void registerMods(){
  registerMod(new MFR());
  registerMod(new RightClick());
  registerMod(new Vanilla());
}",0.7241379310344828
80778,"public static boolean isGrown(Point3I plantPoint,Block plantBlock,int metadata,World worldObj){
  for (  BaseMod mod : modsLoaded) {
    if (mod.isPlant(plantBlock,metadata)) {
      if (mod.isGrown(plantPoint,plantBlock,metadata,worldObj))       return true;
    }
  }
  return false;
}","public static boolean isGrown(Point3I plantPoint,Block plantBlock,IBlockState state,World worldObj){
  for (  BaseMod mod : modsLoaded) {
    if (mod.isPlant(plantBlock,state)) {
      if (mod.isGrown(plantPoint,plantBlock,state,worldObj))       return true;
    }
  }
  return false;
}",0.9040139616055848
80779,"@Override public ArrayList<ItemStack> harvestPlant(Point3I point,Block plantBlock,int metadata,World worldObj){
  PlayerFake faker=new PlayerFake((WorldServer)worldObj);
  plantBlock.onBlockActivated(worldObj,point.getX(),point.getY(),point.getZ(),faker,metadata,0,0,0);
  ArrayList<ItemStack> items=new ArrayList<ItemStack>();
  IInventory inv=faker.inventory;
  for (int i=0; i < inv.getSizeInventory(); i++) {
    if (inv.getStackInSlot(i) != null) {
      items.add(inv.getStackInSlot(i).copy());
    }
  }
  AxisAlignedBB block=AxisAlignedBB.getBoundingBox(point.getX(),point.getY(),point.getZ(),point.getX() + 1,point.getY() + 1,point.getZ() + 1);
  List<EntityItem> entities=worldObj.getEntitiesWithinAABB(EntityItem.class,block);
  if (entities.isEmpty()) {
    return null;
  }
  for (  EntityItem item : entities) {
    items.add(item.getEntityItem());
    worldObj.removeEntity(item);
  }
  return items;
}","@Override public List<ItemStack> harvestPlant(Point3I point,Block plantBlock,IBlockState state,World worldObj){
  PlayerFake faker=new PlayerFake((WorldServer)worldObj);
  plantBlock.onBlockActivated(worldObj,point.toPosition(),state,faker,EnumFacing.DOWN,0,0,0);
  ArrayList<ItemStack> items=new ArrayList<ItemStack>();
  IInventory inv=faker.inventory;
  for (int i=0; i < inv.getSizeInventory(); i++) {
    if (inv.getStackInSlot(i) != null) {
      items.add(inv.getStackInSlot(i).copy());
    }
  }
  AxisAlignedBB block=new AxisAlignedBB(point.getX(),point.getY(),point.getZ(),point.getX() + 1,point.getY() + 1,point.getZ() + 1);
  List<EntityItem> entities=worldObj.getEntitiesWithinAABB(EntityItem.class,block);
  if (entities.isEmpty()) {
    return null;
  }
  for (  EntityItem item : entities) {
    items.add(item.getEntityItem());
    worldObj.removeEntity(item);
  }
  return items;
}",0.9306167400881056
80780,"@Override public ArrayList<ItemStack> harvestPlant(Point3I plantPoint,Block plantBlock,int metadata,World worldObj){
  if ((plantBlock == Blocks.reeds) || (plantBlock == Blocks.cactus)) {
    plantPoint.setY(plantPoint.getY() + 1);
    plantBlock=worldObj.getBlock(plantPoint.getX(),plantPoint.getY(),plantPoint.getZ());
    metadata=worldObj.getBlockMetadata(plantPoint.getX(),plantPoint.getY(),plantPoint.getZ());
  }
  return super.harvestPlant(plantPoint,plantBlock,metadata,worldObj);
}","@Override public List<ItemStack> harvestPlant(Point3I plantPoint,Block plantBlock,IBlockState state,World worldObj){
  if ((plantBlock == Blocks.reeds) || (plantBlock == Blocks.cactus)) {
    plantPoint.setY(plantPoint.getY() + 1);
    state=worldObj.getBlockState(plantPoint.toPosition());
    plantBlock=state.getBlock();
  }
  return super.harvestPlant(plantPoint,plantBlock,state,worldObj);
}",0.5817361894024803
80781,"@Override public boolean isPlant(Block plantBlock,int metadata){
  if (plantBlock instanceof IGrowable)   return true;
  if (plantBlock instanceof BlockNetherWart)   return true;
  if (plantBlock == Blocks.reeds)   return true;
  if (plantBlock == Blocks.cactus)   return true;
  return false;
}","@Override public boolean isPlant(Block plantBlock,IBlockState state){
  if (plantBlock instanceof IGrowable)   return true;
  if (plantBlock instanceof BlockNetherWart)   return true;
  if (plantBlock == Blocks.reeds)   return true;
  if (plantBlock == Blocks.cactus)   return true;
  return false;
}",0.9512605042016806
80782,"@Override public boolean isGrown(Point3I plantPoint,Block plantBlock,int metadata,World worldObj){
  if (plantBlock instanceof IGrowable) {
    return !((IGrowable)plantBlock).func_149851_a(worldObj,plantPoint.getX(),plantPoint.getY(),plantPoint.getZ(),true);
  }
 else   if (plantBlock instanceof BlockNetherWart) {
    return (metadata >= 3);
  }
 else   if (plantBlock == Blocks.reeds) {
    return (worldObj.getBlock(plantPoint.getX(),plantPoint.getY() + 1,plantPoint.getZ()) == Blocks.reeds);
  }
 else   if (plantBlock == Blocks.cactus) {
    return (worldObj.getBlock(plantPoint.getX(),plantPoint.getY() + 1,plantPoint.getZ()) == Blocks.cactus);
  }
  return false;
}","@Override public boolean isGrown(Point3I plantPoint,Block plantBlock,IBlockState state,World worldObj){
  int metadata=plantBlock.getMetaFromState(state);
  if (plantBlock instanceof IGrowable) {
    return !((IGrowable)plantBlock).isStillGrowing(worldObj,plantPoint.toPosition(),state,true);
  }
 else   if (plantBlock instanceof BlockNetherWart) {
    return (metadata >= 3);
  }
 else   if (plantBlock == Blocks.reeds) {
    return (worldObj.getBlockState(plantPoint.toPosition().offsetUp()).getBlock() == Blocks.reeds);
  }
 else   if (plantBlock == Blocks.cactus) {
    return (worldObj.getBlockState(plantPoint.toPosition().offsetUp()).getBlock() == Blocks.cactus);
  }
  return false;
}",0.3028529626920263
80783,"@Override public boolean placeSeed(World worldObj,ItemStack itemStack,Point3I point,boolean doAction){
  Block plant=getPlantBlock(worldObj,itemStack,point);
  if (plant != null) {
    if (doAction) {
      worldObj.setBlock(point.getX(),point.getY(),point.getZ(),plant,itemStack.getItem().getDamage(itemStack),7);
    }
    return true;
  }
  return false;
}","@Override public boolean placeSeed(World worldObj,ItemStack itemStack,Point3I point,boolean doAction){
  IBlockState plant=getPlantBlock(worldObj,itemStack,point);
  if (plant != null) {
    if (doAction) {
      worldObj.setBlockState(point.toPosition(),plant.getBlock().getStateFromMeta(itemStack.getItem().getDamage(itemStack)),7);
    }
    return true;
  }
  return false;
}",0.8482384823848238
80784,"protected Block getPlantBlock(World worldObj,ItemStack itemStack,Point3I point){
  Block plant=null;
  if (itemStack.getItem() instanceof IPlantable) {
    plant=((IPlantable)itemStack.getItem()).getPlant(worldObj,point.getX(),point.getY(),point.getZ());
  }
 else   if (itemStack.getItem() == Items.reeds) {
    plant=Blocks.reeds;
  }
 else   if (Block.getBlockFromItem(itemStack.getItem()) == Blocks.cactus) {
    plant=Blocks.cactus;
  }
  return plant;
}","protected IBlockState getPlantBlock(World worldObj,ItemStack itemStack,Point3I point){
  IBlockState plant=null;
  if (itemStack.getItem() instanceof IPlantable) {
    plant=((IPlantable)itemStack.getItem()).getPlant(worldObj,point.toPosition());
  }
 else   if (itemStack.getItem() == Items.reeds) {
    plant=Blocks.reeds.getDefaultState();
  }
 else   if (Block.getBlockFromItem(itemStack.getItem()) == Blocks.cactus) {
    plant=Blocks.cactus.getDefaultState();
  }
  return plant;
}",0.8858350951374208
80785,"@Override public boolean validBlock(World worldObj,ItemStack itemStack,Point3I point){
  Block plant=getPlantBlock(worldObj,itemStack,point);
  if (plant != null) {
    return (plant.canPlaceBlockAt(worldObj,point.getX(),point.getY(),point.getZ())) && (worldObj.getBlock(point.getX(),point.getY(),point.getZ()) != plant);
  }
  return false;
}","@Override public boolean validBlock(World worldObj,ItemStack itemStack,Point3I point){
  IBlockState plant=getPlantBlock(worldObj,itemStack,point);
  if (plant != null) {
    return (plant.getBlock().canPlaceBlockAt(worldObj,point.toPosition())) && (worldObj.getBlockState(point.toPosition()) != plant);
  }
  return false;
}",0.811377245508982
80786,"public boolean isItemValidForSlot(int slot,ItemStack stack){
  return false;
}","public boolean isItemValidForSlot(int slot,ItemStack stack){
  if ((slot == SLOT_FUEL) && (TileEntityFurnace.getItemBurnTime(stack) > 0) && (ToolHelper.getType(stack.getItem()) == -1)) {
    return true;
  }
  return false;
}",0.4488448844884488
80787,"public boolean isItemValidForSlot(int slot,ItemStack stack){
  if ((slot == SLOT_PICKAXE) && (ToolHelper.getType(stack.getItem()) == ToolHelper.TYPE_PICKAXE)) {
    if (ToolHelper.getLevel(stack) <= getUpgradeLevel()) {
      return true;
    }
  }
 else   if ((slot == SLOT_SHOVEL) && (ToolHelper.getType(stack.getItem()) == ToolHelper.TYPE_SHOVEL)) {
    if (ToolHelper.getLevel(stack) <= getUpgradeLevel()) {
      return true;
    }
  }
 else   if ((slot == SLOT_AXE) && (ToolHelper.getType(stack.getItem()) == ToolHelper.TYPE_AXE)) {
    if (ToolHelper.getLevel(stack) <= getUpgradeLevel()) {
      return true;
    }
  }
 else   if ((slot == SLOT_SWORD) && (ToolHelper.getType(stack.getItem()) == ToolHelper.TYPE_SWORD)) {
    if (ToolHelper.getLevel(stack) <= getUpgradeLevel()) {
      return true;
    }
  }
 else   if ((slot == SLOT_HOE) && (ToolHelper.getType(stack.getItem()) == ToolHelper.TYPE_HOE)) {
    if (ToolHelper.getLevel(stack) <= getUpgradeLevel()) {
      return true;
    }
  }
 else   if ((slot == SLOT_FUEL) && (TileEntityFurnace.getItemBurnTime(stack) > 0) && (ToolHelper.getType(stack.getItem()) == -1)) {
    return true;
  }
 else   if ((slot == SLOT_UPGRADE) && (stack.isItemEqual(ToolHelper.getUpgradeType(getUpgradeLevel())))) {
    return true;
  }
  return false;
}","public boolean isItemValidForSlot(int slot,ItemStack stack){
  if ((slot == SLOT_PICKAXE) && (ToolHelper.getType(stack.getItem()) == ToolHelper.TYPE_PICKAXE)) {
    if (ToolHelper.getLevel(stack) <= getUpgradeLevel()) {
      return true;
    }
  }
 else   if ((slot == SLOT_SHOVEL) && (ToolHelper.getType(stack.getItem()) == ToolHelper.TYPE_SHOVEL)) {
    if (ToolHelper.getLevel(stack) <= getUpgradeLevel()) {
      return true;
    }
  }
 else   if ((slot == SLOT_AXE) && (ToolHelper.getType(stack.getItem()) == ToolHelper.TYPE_AXE)) {
    if (ToolHelper.getLevel(stack) <= getUpgradeLevel()) {
      return true;
    }
  }
 else   if ((slot == SLOT_SWORD) && (ToolHelper.getType(stack.getItem()) == ToolHelper.TYPE_SWORD)) {
    if (ToolHelper.getLevel(stack) <= getUpgradeLevel()) {
      return true;
    }
  }
 else   if ((slot == SLOT_HOE) && (ToolHelper.getType(stack.getItem()) == ToolHelper.TYPE_HOE)) {
    if (ToolHelper.getLevel(stack) <= getUpgradeLevel()) {
      return true;
    }
  }
 else   if ((slot == SLOT_UPGRADE) && (stack.isItemEqual(ToolHelper.getUpgradeType(getUpgradeLevel())))) {
    return true;
  }
  return super.isItemValidForSlot(slot,stack);
}",0.9217741935483872
80788,"public int canMineBlock(int x,int y,int z){
  Block tryBlock=worldObj.getBlock(x,y,z);
  if (tryBlock != null) {
    int meta=worldObj.getBlockMetadata(x,y,z);
    if ((tryBlock.getBlockHardness(worldObj,x,y,z) >= 0) && (!tryBlock.isAir(worldObj,x,y,z))) {
      boolean mine=false;
      if (tryBlock == Blocks.cobblestone) {
        return -1;
      }
      if ((tryBlock.getHarvestTool(meta) == ""String_Node_Str"") || (tryBlock.getHarvestTool(meta) == ""String_Node_Str"")) {
        if (ForgeHooks.canToolHarvestBlock(tryBlock,meta,getStackInSlot(2))) {
          return 2;
        }
      }
 else       if (tryBlock.getHarvestTool(meta) == ""String_Node_Str"") {
        if (ForgeHooks.canToolHarvestBlock(tryBlock,meta,getStackInSlot(3))) {
          return 3;
        }
      }
 else {
        if (!tryBlock.getMaterial().isLiquid()) {
          return 1;
        }
      }
    }
    if (hasUpgrade(UpgradeType.FILLER)) {
      if ((tryBlock.isAir(worldObj,x,y,z)) || (tryBlock.getMaterial().isLiquid())) {
        return 4;
      }
    }
  }
  return 0;
}","public int canMineBlock(int x,int y,int z){
  Block tryBlock=worldObj.getBlock(x,y,z);
  if (tryBlock != null) {
    int meta=worldObj.getBlockMetadata(x,y,z);
    if ((tryBlock.getBlockHardness(worldObj,x,y,z) >= 0) && (!tryBlock.isAir(worldObj,x,y,z))) {
      boolean mine=false;
      if (tryBlock == Blocks.cobblestone) {
        return -1;
      }
      if (tryBlock.getHarvestTool(meta) == ""String_Node_Str"") {
        return 2;
      }
 else       if (tryBlock.getHarvestTool(meta) == ""String_Node_Str"") {
        if (ForgeHooks.canToolHarvestBlock(tryBlock,meta,getStackInSlot(2))) {
          return 2;
        }
      }
 else       if (tryBlock.getHarvestTool(meta) == ""String_Node_Str"") {
        if (ForgeHooks.canToolHarvestBlock(tryBlock,meta,getStackInSlot(3))) {
          return 3;
        }
      }
 else {
        if (!tryBlock.getMaterial().isLiquid()) {
          return 1;
        }
      }
    }
    if (hasUpgrade(UpgradeType.FILLER)) {
      if ((tryBlock.isAir(worldObj,x,y,z)) || (tryBlock.getMaterial().isLiquid())) {
        return 4;
      }
    }
  }
  return 0;
}",0.978644382544104
80789,"public void updateEntity(){
  super.updateEntity();
  if (!worldObj.isRemote) {
    if (!isBurning()) {
      if (readyToBurn()) {
        if (slots[SLOT_FUEL] != null) {
          if (isFuel()) {
            burnLevel=progress=getBurnTime();
            if (slots[SLOT_FUEL].getItem().hasContainerItem(slots[SLOT_FUEL])) {
              slots[SLOT_FUEL]=slots[SLOT_FUEL].getItem().getContainerItem(slots[SLOT_FUEL]);
            }
 else {
              slots[SLOT_FUEL].stackSize--;
              if (slots[SLOT_FUEL].stackSize == 0) {
                slots[SLOT_FUEL]=null;
              }
            }
          }
 else           if (hasEngine()) {
            if (useEnergy(PAConfig.rfCost,false) > 0) {
              burnLevel=progress=1;
            }
          }
        }
      }
    }
 else {
      progress--;
      if (progress <= 0) {
        burnLevel=progress=0;
        if ((readyToBurn()) && (hasEngine())) {
          if (useEnergy(PAConfig.rfCost,false) > 0) {
            burnLevel=progress=1;
          }
        }
      }
    }
  }
}","public void updateEntity(){
  super.updateEntity();
  if (!worldObj.isRemote) {
    if (!isBurning()) {
      if (readyToBurn()) {
        if (slots[SLOT_FUEL] != null) {
          if (isFuel()) {
            burnLevel=progress=getBurnTime();
            if (slots[SLOT_FUEL].getItem().hasContainerItem(slots[SLOT_FUEL])) {
              slots[SLOT_FUEL]=slots[SLOT_FUEL].getItem().getContainerItem(slots[SLOT_FUEL]);
            }
 else {
              slots[SLOT_FUEL].stackSize--;
              if (slots[SLOT_FUEL].stackSize == 0) {
                slots[SLOT_FUEL]=null;
              }
            }
          }
 else           if (hasEngine()) {
            if (useEnergy(PAConfig.rfCost,false) > 0) {
              burnLevel=progress=1;
            }
          }
        }
      }
    }
 else {
      progress--;
      if (progress <= 0) {
        burnLevel=progress=0;
        if ((readyToBurn()) && (hasEngine())) {
          if (useEnergy(PAConfig.rfCost,false) > 0) {
            burnLevel=progress=1;
          }
        }
      }
    }
    checkForPowerChange();
  }
}",0.9845577912962096
80790,"public void scanBlocks(){
  totalMineBlocks=currentMineBlocks=0;
  for (int i=1; i <= getRange(); i++) {
    Point2I currentPoint=spiral(i,xCoord,zCoord);
    boolean bedrock=false;
    int newY=this.yCoord - 1;
    while (!bedrock) {
      int result=canMineBlock(currentPoint.getX(),newY,currentPoint.getY());
      if (result >= 1) {
        totalMineBlocks++;
      }
 else       if (result == -1) {
        totalMineBlocks++;
        currentMineBlocks++;
      }
      newY--;
      if (newY < 0)       bedrock=true;
    }
  }
}","public void scanBlocks(){
  totalMineBlocks=currentMineBlocks=0;
  for (int i=1; i <= getRange(); i++) {
    Point2I currentPoint=spiral(i,xCoord,zCoord);
    boolean bedrock=false;
    int newY=this.yCoord - 1;
    while (!bedrock) {
      int result=canMineBlock(currentPoint.getX(),newY,currentPoint.getY());
      if (result >= 1) {
        totalMineBlocks++;
      }
 else       if (result == -1) {
        totalMineBlocks++;
        currentMineBlocks++;
      }
      newY--;
      if (newY < 0)       bedrock=true;
    }
  }
  notifyUpdate();
}",0.9833948339483396
80791,"public Block getNextBlock(){
  Point2I currentPoint=spiral(currentColumn,xCoord,zCoord);
  miningWith=canMineBlock(currentPoint.getX(),currentYLevel,currentPoint.getY());
  while ((miningWith <= 0) && (currentYLevel >= 0)) {
    if (miningWith > 0) {
      return worldObj.getBlock(currentPoint.getX(),currentYLevel,currentPoint.getY());
    }
 else {
      currentYLevel--;
      miningWith=canMineBlock(currentPoint.getX(),currentYLevel,currentPoint.getY());
    }
  }
  if (miningWith > 0) {
    return worldObj.getBlock(currentPoint.getX(),currentYLevel,currentPoint.getY());
  }
  if (currentYLevel < 0) {
    currentYLevel=yCoord - 1;
    currentColumn--;
    if (currentColumn < 0) {
      scanBlocks();
      currentColumn=getRange();
    }
 else {
      return getNextBlock();
    }
  }
  return null;
}","public Block getNextBlock(){
  Point2I currentPoint=spiral(currentColumn,xCoord,zCoord);
  miningWith=canMineBlock(currentPoint.getX(),currentYLevel,currentPoint.getY());
  while ((miningWith <= 0) && (currentYLevel >= 0)) {
    if (miningWith > 0) {
      return worldObj.getBlock(currentPoint.getX(),currentYLevel,currentPoint.getY());
    }
 else {
      currentYLevel--;
      if (currentYLevel >= 0)       miningWith=canMineBlock(currentPoint.getX(),currentYLevel,currentPoint.getY());
    }
  }
  if (miningWith > 0) {
    return worldObj.getBlock(currentPoint.getX(),currentYLevel,currentPoint.getY());
  }
  if (currentYLevel < 0) {
    currentYLevel=yCoord - 1;
    currentColumn--;
    if (currentColumn < 0) {
      scanBlocks();
      currentColumn=getRange();
    }
 else {
      return getNextBlock();
    }
  }
  return null;
}",0.9818621523579202
80792,"public int canMineBlock(int x,int y,int z){
  Block tryBlock=worldObj.getBlock(x,y,z);
  if (tryBlock != null) {
    int meta=worldObj.getBlockMetadata(x,y,z);
    if ((tryBlock.getBlockHardness(worldObj,x,y,z) >= 0) && (!tryBlock.isAir(worldObj,x,y,z))) {
      boolean mine=false;
      if (tryBlock == Blocks.cobblestone) {
        return -1;
      }
      if ((tryBlock.getHarvestTool(meta) == ""String_Node_Str"") || (tryBlock.getHarvestTool(meta) == ""String_Node_Str"")) {
        if (ForgeHooks.canToolHarvestBlock(tryBlock,meta,getStackInSlot(2))) {
          return 2;
        }
      }
 else       if (tryBlock.getHarvestTool(meta) == ""String_Node_Str"") {
        if (ForgeHooks.canToolHarvestBlock(tryBlock,meta,getStackInSlot(3))) {
          return 3;
        }
      }
 else {
        if (!tryBlock.getMaterial().isLiquid()) {
          return 4;
        }
      }
    }
    if (this.hasFillerUpgrade) {
      if ((tryBlock.isAir(worldObj,x,y,z)) || (tryBlock.getMaterial().isLiquid())) {
        return 4;
      }
    }
  }
  return 0;
}","public int canMineBlock(int x,int y,int z){
  Block tryBlock=worldObj.getBlock(x,y,z);
  if (tryBlock != null) {
    int meta=worldObj.getBlockMetadata(x,y,z);
    if ((tryBlock.getBlockHardness(worldObj,x,y,z) >= 0) && (!tryBlock.isAir(worldObj,x,y,z))) {
      boolean mine=false;
      if (tryBlock == Blocks.cobblestone) {
        return -1;
      }
      if ((tryBlock.getHarvestTool(meta) == ""String_Node_Str"") || (tryBlock.getHarvestTool(meta) == ""String_Node_Str"")) {
        if (ForgeHooks.canToolHarvestBlock(tryBlock,meta,getStackInSlot(2))) {
          return 2;
        }
      }
 else       if (tryBlock.getHarvestTool(meta) == ""String_Node_Str"") {
        if (ForgeHooks.canToolHarvestBlock(tryBlock,meta,getStackInSlot(3))) {
          return 3;
        }
      }
 else {
        if (!tryBlock.getMaterial().isLiquid()) {
          return 1;
        }
      }
    }
    if (this.hasFillerUpgrade) {
      if ((tryBlock.isAir(worldObj,x,y,z)) || (tryBlock.getMaterial().isLiquid())) {
        return 4;
      }
    }
  }
  return 0;
}",0.9990467111534796
80793,"public static void preInit(){
  if (PAConfig.allowWoodenLevel)   woodUpgrade=new ItemWoodUpgrade();
  if (PAConfig.allowStoneLevel)   stoneUpgrade=new ItemStoneUpgrade();
  if (PAConfig.allowIronLevel)   ironUpgrade=new ItemIronUpgrade();
  if (PAConfig.allowDiamondLevel)   diamondUpgrade=new ItemDiamondUpgrade();
  if ((PAConfig.allowCobbleUpgrade) && (PAConfig.minerEnabled))   cobbleUpgrade=new ItemCobbleGenUpgrade();
  if ((PAConfig.allowFillerUpgrade) && (PAConfig.minerEnabled))   fillerUpgrade=new ItemFillerUpgrade();
  if (PAConfig.allowWitherUpgrade)   witherUpgrade=new ItemWitherUpgrade();
  if (PAConfig.allowCoalPellets)   coalPellet=new ItemCoalPellet();
  if (PAConfig.rfSupport) {
    rfEngine=new ItemRFEngine();
    CheatRFEngine=new ItemCreativeRFEngine();
  }
  Item previousTier=Items.redstone;
  if (woodUpgrade != null) {
    woodUpgrade.preInit(previousTier);
    previousTier=woodUpgrade;
  }
  if (stoneUpgrade != null) {
    stoneUpgrade.preInit(previousTier);
    previousTier=stoneUpgrade;
  }
  if (ironUpgrade != null) {
    ironUpgrade.preInit(previousTier);
    previousTier=ironUpgrade;
  }
  if (diamondUpgrade != null) {
    diamondUpgrade.preInit(previousTier);
  }
  if (witherUpgrade != null)   witherUpgrade.preInit();
  if (fillerUpgrade != null)   fillerUpgrade.preInit();
  if (PAConfig.rfSupport) {
    rfEngine.preInit();
    CheatRFEngine.preInit();
  }
  if (coalPellet != null)   coalPellet.preInit();
  if (PAConfig.enableWitherTools) {
    witherWood=new ItemWitherWood();
    witherStone=new ItemWitherStone();
    witherIron=new ItemWitherIron();
    witherDiamond=new ItemWitherDiamond();
    witherWood.preInit();
    witherStone.preInit();
    witherIron.preInit();
    witherDiamond.preInit();
  }
}","public static void preInit(){
  if (PAConfig.allowWoodenLevel)   woodUpgrade=new ItemWoodUpgrade();
  if (PAConfig.allowStoneLevel)   stoneUpgrade=new ItemStoneUpgrade();
  if (PAConfig.allowIronLevel)   ironUpgrade=new ItemIronUpgrade();
  if (PAConfig.allowDiamondLevel)   diamondUpgrade=new ItemDiamondUpgrade();
  if ((PAConfig.allowCobbleUpgrade) && (PAConfig.minerEnabled))   cobbleUpgrade=new ItemCobbleGenUpgrade();
  if ((PAConfig.allowFillerUpgrade) && (PAConfig.minerEnabled))   fillerUpgrade=new ItemFillerUpgrade();
  if (PAConfig.allowWitherUpgrade)   witherUpgrade=new ItemWitherUpgrade();
  if (PAConfig.allowCoalPellets)   coalPellet=new ItemCoalPellet();
  if (PAConfig.rfSupport) {
    rfEngine=new ItemRFEngine();
    CheatRFEngine=new ItemCreativeRFEngine();
  }
  Item previousTier=Items.redstone;
  if (woodUpgrade != null) {
    woodUpgrade.preInit(previousTier);
    previousTier=woodUpgrade;
  }
  if (stoneUpgrade != null) {
    stoneUpgrade.preInit(previousTier);
    previousTier=stoneUpgrade;
  }
  if (ironUpgrade != null) {
    ironUpgrade.preInit(previousTier);
    previousTier=ironUpgrade;
  }
  if (diamondUpgrade != null) {
    diamondUpgrade.preInit(previousTier);
  }
  if (witherUpgrade != null)   witherUpgrade.preInit();
  if (fillerUpgrade != null)   fillerUpgrade.preInit();
  if (PAConfig.rfSupport) {
    rfEngine.preInit();
    CheatRFEngine.preInit();
  }
  if (coalPellet != null)   coalPellet.preInit();
  if (PAConfig.enableWitherTools) {
    WitherTools.preInit();
  }
}",0.9241085035050288
80794,"public void updateEntity(){
  super.updateEntity();
  if (!worldObj.isRemote) {
    checkInventory();
    checkForChanges();
    if (isBurning()) {
      if (searchBlock > -1) {
        if (currentTime > 0) {
          if (checkPlant(searchBlock)) {
            currentTime--;
            if (currentTime <= 0) {
              harvestPlant(searchBlock);
              searchBlock=-1;
            }
          }
 else {
            currentTime=0;
          }
        }
 else         if (plantSeed(searchBlock,true)) {
          searchBlock=-1;
        }
 else {
          if (checkPlant(searchBlock)) {
            currentTime=harvestTime;
          }
        }
      }
    }
  }
}","public void updateEntity(){
  super.updateEntity();
  if (!worldObj.isRemote) {
    checkInventory();
    checkForChanges();
    if (isBurning()) {
      if (searchBlock > -1) {
        if (currentTime > 0) {
          if (checkPlant(searchBlock)) {
            currentTime--;
            if (currentTime <= 0) {
              harvestPlant(searchBlock);
              searchBlock=-1;
            }
          }
 else {
            currentTime=0;
          }
        }
 else         if (plantSeed(searchBlock,true)) {
          searchBlock=-1;
        }
 else {
          if (checkPlant(searchBlock)) {
            currentTime=harvestTime;
          }
        }
      }
 else {
        doSearch();
      }
    }
  }
}",0.9598278335724534
80795,"public static void init(){
  for (int i=0; i <= 3; i++) {
    if (PAConfig.allowLevel(i)) {
      miner[i].init();
      chopper[i].init();
      planter[i].init();
      generator[i].init();
    }
  }
}","public static void init(){
  for (int i=0; i <= 3; i++) {
    if (PAConfig.allowLevel(i)) {
      if (PAConfig.minerEnabled)       miner[i].init();
      if (PAConfig.chopperEnabled)       chopper[i].init();
      if (PAConfig.planterEnabled)       planter[i].init();
      if (PAConfig.generatorEnabled && PAConfig.rfSupport)       generator[i].init();
    }
  }
}",0.7147887323943662
80796,"public static void preInit(){
  for (int i=0; i <= 3; i++) {
    if (PAConfig.allowLevel(i)) {
      if (PAConfig.minerEnabled)       miner[i]=new BlockMiner(i);
      if (PAConfig.chopperEnabled)       chopper[i]=new BlockChopper(i);
      if (PAConfig.planterEnabled)       planter[i]=new BlockPlanter(i);
      if (PAConfig.generatorEnabled && PAConfig.rfSupport)       generator[i]=new BlockGenerator(i);
    }
  }
  for (int i=0; i <= 3; i++) {
    if (PAConfig.allowLevel(i)) {
      miner[i].preInit();
      chopper[i].preInit();
      planter[i].preInit();
      generator[i].preInit();
    }
  }
}","public static void preInit(){
  for (int i=0; i <= 3; i++) {
    if (PAConfig.allowLevel(i)) {
      if (PAConfig.minerEnabled)       miner[i]=new BlockMiner(i);
      if (PAConfig.chopperEnabled)       chopper[i]=new BlockChopper(i);
      if (PAConfig.planterEnabled)       planter[i]=new BlockPlanter(i);
      if (PAConfig.generatorEnabled && PAConfig.rfSupport)       generator[i]=new BlockGenerator(i);
    }
  }
  for (int i=0; i <= 3; i++) {
    if (PAConfig.allowLevel(i)) {
      if (PAConfig.minerEnabled)       miner[i].preInit();
      if (PAConfig.chopperEnabled)       chopper[i].preInit();
      if (PAConfig.planterEnabled)       planter[i].preInit();
      if (PAConfig.generatorEnabled && PAConfig.rfSupport)       generator[i].preInit();
    }
  }
}",0.8822674418604651
80797,"public static void postInit(){
  for (int i=0; i <= 3; i++) {
    if (PAConfig.allowLevel(i)) {
      miner[i].postInit();
      chopper[i].postInit();
      planter[i].postInit();
      generator[i].postInit();
    }
  }
}","public static void postInit(){
  for (int i=0; i <= 3; i++) {
    if (PAConfig.allowLevel(i)) {
      if (PAConfig.minerEnabled)       miner[i].postInit();
      if (PAConfig.chopperEnabled)       chopper[i].postInit();
      if (PAConfig.planterEnabled)       planter[i].postInit();
      if (PAConfig.generatorEnabled && PAConfig.rfSupport)       generator[i].postInit();
    }
  }
}",0.7335526315789473
80798,"public static void preInit(){
  if (PAConfig.allowWoodenLevel)   woodUpgrade=new ItemWoodUpgrade();
  if (PAConfig.allowStoneLevel)   stoneUpgrade=new ItemStoneUpgrade();
  if (PAConfig.allowIronLevel)   ironUpgrade=new ItemIronUpgrade();
  if (PAConfig.allowDiamondLevel)   diamondUpgrade=new ItemDiamondUpgrade();
  if (PAConfig.allowCobbleUpgrade)   cobbleUpgrade=new ItemCobbleGenUpgrade();
  if (PAConfig.allowWitherUpgrade)   witherUpgrade=new ItemWitherUpgrade();
  if (PAConfig.allowCoalPellets)   coalPellet=new ItemCoalPellet();
  if (PAConfig.rfSupport) {
    rfEngine=new ItemRFEngine();
    CheatRFEngine=new ItemCreativeRFEngine();
  }
  if (woodUpgrade != null)   woodUpgrade.preInit();
  if (stoneUpgrade != null)   stoneUpgrade.preInit();
  if (ironUpgrade != null)   ironUpgrade.preInit();
  if (diamondUpgrade != null)   diamondUpgrade.preInit();
  if (witherUpgrade != null)   witherUpgrade.preInit();
  if (PAConfig.rfSupport) {
    rfEngine.preInit();
    CheatRFEngine.preInit();
  }
  if (coalPellet != null)   coalPellet.preInit();
}","public static void preInit(){
  if (PAConfig.allowWoodenLevel)   woodUpgrade=new ItemWoodUpgrade();
  if (PAConfig.allowStoneLevel)   stoneUpgrade=new ItemStoneUpgrade();
  if (PAConfig.allowIronLevel)   ironUpgrade=new ItemIronUpgrade();
  if (PAConfig.allowDiamondLevel)   diamondUpgrade=new ItemDiamondUpgrade();
  if ((PAConfig.allowCobbleUpgrade) && (PAConfig.minerEnabled))   cobbleUpgrade=new ItemCobbleGenUpgrade();
  if (PAConfig.allowWitherUpgrade)   witherUpgrade=new ItemWitherUpgrade();
  if (PAConfig.allowCoalPellets)   coalPellet=new ItemCoalPellet();
  if (PAConfig.rfSupport) {
    rfEngine=new ItemRFEngine();
    CheatRFEngine=new ItemCreativeRFEngine();
  }
  if (woodUpgrade != null)   woodUpgrade.preInit();
  if (stoneUpgrade != null)   stoneUpgrade.preInit();
  if (ironUpgrade != null)   ironUpgrade.preInit();
  if (diamondUpgrade != null)   diamondUpgrade.preInit();
  if (witherUpgrade != null)   witherUpgrade.preInit();
  if (PAConfig.rfSupport) {
    rfEngine.preInit();
    CheatRFEngine.preInit();
  }
  if (coalPellet != null)   coalPellet.preInit();
}",0.9864801864801864
80799,"public boolean canInsertItem(int slot,ItemStack stack,int side){
  if (slots[slot] != null) {
    int availSpace=this.getInventoryStackLimit() - slots[slot].stackSize;
    if (availSpace > 0) {
      return true;
    }
  }
 else {
    return true;
  }
  return false;
}","public boolean canInsertItem(int slot,ItemStack stack,int side){
  if (slots[slot] != null) {
    int availSpace=this.getInventoryStackLimit() - slots[slot].stackSize;
    if (availSpace > 0) {
      return true;
    }
  }
 else   if (isItemValidForSlot(slot,stack)) {
    return true;
  }
  return false;
}",0.9340277777777778
80800,"public void checkForChanges(){
  boolean update=false;
  if ((slots[2] == null) && (lastPick >= 0)) {
    lastPick=-1;
    update=true;
  }
 else   if (slots[2] != null) {
    if (ToolInfo.getLevel(slots[2].getItem()) != lastPick) {
      lastPick=ToolInfo.getLevel(slots[2].getItem());
      update=true;
    }
  }
  if ((slots[3] == null) && (lastShovel >= 0)) {
    lastShovel=-1;
    update=true;
  }
 else   if (slots[3] != null) {
    if (ToolInfo.getLevel(slots[3].getItem()) != lastShovel) {
      lastShovel=ToolInfo.getLevel(slots[3].getItem());
      update=true;
    }
  }
  if (getCurrentUpgrades() != lastUpgrades) {
    addUpgrades(getCurrentUpgrades());
    slots[4]=null;
    lastUpgrades=getCurrentUpgrades();
    update=true;
  }
  if (update) {
    scanBlocks();
    currentColumn=getRange();
    currentBlock=null;
    miningTime=0;
    currentYLevel=yCoord - 1;
  }
}","public void checkForChanges(){
  boolean update=false;
  if ((slots[2] == null) && (lastPick >= 0)) {
    lastPick=-1;
    update=true;
  }
 else   if (slots[2] != null) {
    if (ToolInfo.getLevel(slots[2].getItem()) != lastPick) {
      lastPick=ToolInfo.getLevel(slots[2].getItem());
      update=true;
    }
  }
  if ((slots[3] == null) && (lastShovel >= 0)) {
    lastShovel=-1;
    update=true;
  }
 else   if (slots[3] != null) {
    if (ToolInfo.getLevel(slots[3].getItem()) != lastShovel) {
      lastShovel=ToolInfo.getLevel(slots[3].getItem());
      update=true;
    }
  }
  if (getCurrentUpgrades() != lastUpgrades) {
    if (slots[4].isItemEqual(ToolInfo.getUpgradeType(mineLevel))) {
      addUpgrades(getCurrentUpgrades());
      slots[4]=null;
      lastUpgrades=getCurrentUpgrades();
      update=true;
    }
  }
  if (update) {
    scanBlocks();
    currentColumn=getRange();
    currentBlock=null;
    miningTime=0;
    currentYLevel=yCoord - 1;
  }
}",0.8774193548387097
80801,"public int readLEInt(){
  ByteBuffer buffer=_read(4,true);
  return buffer.getInt();
}","public int readLEInt(){
  ByteBuffer buffer=_read(4,true);
  ThreadUtil.sleep(1);
  return buffer.getInt();
}",0.882051282051282
80802,"private ByteBuffer _read(int i,boolean strict){
  ByteBuffer buffer=ByteBuffer.allocate(i);
  buffer.order(ByteOrder.LITTLE_ENDIAN);
  try {
    int read=socketChannel.read(buffer);
    if (read != i && strict) {
      throw new RethinkDBException(""String_Node_Str"" + i + ""String_Node_Str""+ read);
    }
    buffer.flip();
    return buffer;
  }
 catch (  IOException e) {
    throw new RethinkDBException(e);
  }
}","private ByteBuffer _read(int i,boolean strict){
  ByteBuffer buffer=ByteBuffer.allocate(i);
  buffer.order(ByteOrder.LITTLE_ENDIAN);
  try {
    int totalRead=0;
    int read=socketChannel.read(buffer);
    totalRead+=read;
    while (strict && read != 0 && read != i) {
      read=socketChannel.read(buffer);
      totalRead+=read;
    }
    if (totalRead != i && strict) {
      throw new RethinkDBException(""String_Node_Str"" + i + ""String_Node_Str""+ totalRead);
    }
    buffer.flip();
    return buffer;
  }
 catch (  IOException e) {
    throw new RethinkDBException(e);
  }
}",0.8204613841524574
80803,"public SetInsert setInsert(List<Object> objects){
  return new SetInsert(null,new Arguments(objects),null);
}","public SetInsert setInsert(List<Object> objects){
  return new SetInsert(this,new Arguments(objects),null);
}",0.963302752293578
80804,"public SetIntersection setIntersection(List<Object> objects){
  return new SetIntersection(null,new Arguments(objects),null);
}","public SetIntersection setIntersection(List<Object> objects){
  return new SetIntersection(this,new Arguments(objects),null);
}",0.968503937007874
80805,"public SetDifference setDifference(List<Object> objects){
  return new SetDifference(null,new Arguments(objects),null);
}","public SetDifference setDifference(List<Object> objects){
  return new SetDifference(this,new Arguments(objects),null);
}",0.9669421487603306
80806,"public SetUnion setUnion(List<Object> objects){
  return new SetUnion(null,new Arguments(objects),null);
}","public SetUnion setUnion(List<Object> objects){
  return new SetUnion(this,new Arguments(objects),null);
}",0.9622641509433962
80807,"@Override public Query parse() throws SyntaxError {
  final String fieldName=localParams.get(QueryParsing.V);
  final BooleanQuery booleanQuery=new BooleanQuery(true);
  int booleanClausesTotal=0;
  fetchDataFromRedis(redisCommand,maxJedisRetries);
  if (results != null) {
    log.debug(""String_Node_Str"",results.size(),fieldName);
    for (    final Map.Entry<String,Float> entry : results.entrySet()) {
      try {
        final TokenStream tokenStream;
        final String termString=entry.getKey();
        if (termString == null) {
          continue;
        }
        final Float score=entry.getValue();
        if (useQueryTimeAnalyzer) {
          tokenStream=req.getSchema().getQueryAnalyzer().tokenStream(fieldName,termString);
          final CharTermAttribute charAttribute=tokenStream.addAttribute(CharTermAttribute.class);
          tokenStream.reset();
          int counter=0;
          while (tokenStream.incrementToken()) {
            log.trace(""String_Node_Str"",++counter,new String(charAttribute.buffer()),score,termString,fieldName);
            final TermQuery termQuery=new TermQuery(new Term(fieldName,new BytesRef(charAttribute)));
            if (!score.isNaN()) {
              termQuery.setBoost(score);
            }
            booleanQuery.add(termQuery,this.operator);
            ++booleanClausesTotal;
          }
          tokenStream.end();
          tokenStream.close();
        }
 else {
          final TermQuery termQuery=new TermQuery(new Term(fieldName,new BytesRef(termString)));
          booleanQuery.add(termQuery,this.operator);
          ++booleanClausesTotal;
        }
      }
 catch (      final IOException ex) {
        log.error(""String_Node_Str"",ex);
      }
    }
  }
  log.debug(""String_Node_Str"",fieldName,booleanClausesTotal);
  return booleanQuery;
}","@Override public Query parse() throws SyntaxError {
  final String fieldName=localParams.get(QueryParsing.V);
  final BooleanQuery booleanQuery=new BooleanQuery(true);
  int booleanClausesTotal=0;
  fetchDataFromRedis(redisCommand,maxJedisRetries);
  if (results != null) {
    log.debug(""String_Node_Str"",results.size(),fieldName);
    for (    final Map.Entry<String,Float> entry : results.entrySet()) {
      try {
        final TokenStream tokenStream;
        final String termString=entry.getKey();
        if (termString == null) {
          continue;
        }
        final Float score=entry.getValue();
        if (useQueryTimeAnalyzer) {
          log.trace(""String_Node_Str"",termString);
          tokenStream=req.getSchema().getQueryAnalyzer().tokenStream(fieldName,termString);
          final CharTermAttribute charAttribute=tokenStream.addAttribute(CharTermAttribute.class);
          tokenStream.reset();
          int counter=0;
          while (tokenStream.incrementToken()) {
            log.trace(""String_Node_Str"",++counter,charAttribute,score,termString,fieldName);
            addTermToQuery(booleanQuery,fieldName,new BytesRef(charAttribute),score);
            ++booleanClausesTotal;
          }
          tokenStream.end();
          tokenStream.close();
        }
 else {
          addTermToQuery(booleanQuery,fieldName,new BytesRef(termString),score);
          ++booleanClausesTotal;
        }
      }
 catch (      final IOException ex) {
        log.error(""String_Node_Str"",ex);
      }
    }
  }
  log.debug(""String_Node_Str"",fieldName,booleanClausesTotal);
  return booleanQuery;
}",0.8317293671624381
80808,"@Override public Query parse() throws SyntaxError {
  final String fieldName=localParams.get(QueryParsing.V);
  final BooleanQuery booleanQuery=new BooleanQuery(true);
  int booleanClausesTotal=0;
  fetchDataFromRedis(redisCommand,maxJedisRetries);
  if (results != null) {
    log.debug(""String_Node_Str"",results.size(),fieldName);
    for (    final Map.Entry<String,Float> entry : results.entrySet()) {
      try {
        final TokenStream tokenStream;
        final String termString=entry.getKey();
        if (termString == null) {
          continue;
        }
        final Float score=entry.getValue();
        if (useQueryTimeAnalyzer) {
          log.trace(""String_Node_Str"",termString);
          tokenStream=req.getSchema().getQueryAnalyzer().tokenStream(fieldName,termString);
          final CharTermAttribute charAttribute=tokenStream.addAttribute(CharTermAttribute.class);
          tokenStream.reset();
          int counter=0;
          while (tokenStream.incrementToken()) {
            log.trace(""String_Node_Str"",++counter,charAttribute,score,termString,fieldName);
            addTermToQuery(booleanQuery,fieldName,new BytesRef(charAttribute),score);
            ++booleanClausesTotal;
          }
          tokenStream.end();
          tokenStream.close();
        }
 else {
          addTermToQuery(booleanQuery,fieldName,new BytesRef(termString),score);
          ++booleanClausesTotal;
        }
      }
 catch (      final IOException ex) {
        log.error(""String_Node_Str"",ex);
      }
    }
  }
  log.debug(""String_Node_Str"",fieldName,booleanClausesTotal);
  return booleanQuery;
}","@Override public Query parse() throws SyntaxError {
  final String fieldName=localParams.get(QueryParsing.V);
  final BooleanQuery booleanQuery=new BooleanQuery(true);
  int booleanClausesTotal=0;
  fetchDataFromRedis(redisCommand,maxJedisRetries);
  if (results != null) {
    log.debug(""String_Node_Str"",results.size(),fieldName);
    for (    final Map.Entry<String,Float> entry : results.entrySet()) {
      try {
        final String termString=entry.getKey();
        if (termString == null) {
          continue;
        }
        final Float score=entry.getValue();
        if (useQueryTimeAnalyzer) {
          log.trace(""String_Node_Str"",termString);
          try (final TokenStream tokenStream=req.getSchema().getQueryAnalyzer().tokenStream(fieldName,termString)){
            final CharTermAttribute charAttribute=tokenStream.addAttribute(CharTermAttribute.class);
            tokenStream.reset();
            int counter=0;
            while (tokenStream.incrementToken()) {
              log.trace(""String_Node_Str"",++counter,charAttribute,score,termString,fieldName);
              addTermToQuery(booleanQuery,fieldName,new BytesRef(charAttribute),score);
              ++booleanClausesTotal;
            }
            tokenStream.end();
          }
         }
 else {
          addTermToQuery(booleanQuery,fieldName,new BytesRef(termString),score);
          ++booleanClausesTotal;
        }
      }
 catch (      final IOException ex) {
        log.error(""String_Node_Str"",ex);
      }
    }
  }
  log.debug(""String_Node_Str"",fieldName,booleanClausesTotal);
  return booleanQuery;
}",0.9660964230171072
80809,"@Override public Query parse() throws SyntaxError {
  final String fieldName=localParams.get(QueryParsing.V);
  final BooleanQuery booleanQuery=new BooleanQuery(true);
  int booleanClausesTotal=0;
  fetchDataFromRedis(redisCommand,maxJedisRetries);
  if (results != null) {
    log.debug(""String_Node_Str"",results.size(),fieldName);
    for (    final Map.Entry<String,Float> entry : results.entrySet()) {
      try {
        final TokenStream tokenStream;
        final String termString=entry.getKey();
        if (termString == null) {
          continue;
        }
        final Float score=entry.getValue();
        if (useQueryTimeAnalyzer) {
          tokenStream=req.getSchema().getQueryAnalyzer().tokenStream(fieldName,termString);
          final CharTermAttribute charAttribute=tokenStream.addAttribute(CharTermAttribute.class);
          tokenStream.reset();
          int counter=0;
          while (tokenStream.incrementToken()) {
            log.trace(""String_Node_Str"",++counter,new String(charAttribute.buffer()),score,termString,fieldName);
            final TermQuery termQuery=new TermQuery(new Term(fieldName,new BytesRef(charAttribute)));
            if (!score.isNaN()) {
              termQuery.setBoost(score);
            }
            booleanQuery.add(termQuery,this.operator);
            ++booleanClausesTotal;
          }
          tokenStream.end();
          tokenStream.close();
        }
 else {
          final TermQuery termQuery=new TermQuery(new Term(fieldName,new BytesRef(termString)));
          booleanQuery.add(termQuery,this.operator);
          ++booleanClausesTotal;
        }
      }
 catch (      final IOException ex) {
        log.error(""String_Node_Str"",ex);
      }
    }
  }
  log.debug(""String_Node_Str"",fieldName,booleanClausesTotal);
  return booleanQuery;
}","@Override public Query parse() throws SyntaxError {
  final String fieldName=localParams.get(QueryParsing.V);
  final BooleanQuery booleanQuery=new BooleanQuery(true);
  int booleanClausesTotal=0;
  fetchDataFromRedis(redisCommand,maxJedisRetries);
  if (results != null) {
    log.debug(""String_Node_Str"",results.size(),fieldName);
    for (    final Map.Entry<String,Float> entry : results.entrySet()) {
      try {
        final String termString=entry.getKey();
        if (termString == null) {
          continue;
        }
        final Float score=entry.getValue();
        if (useQueryTimeAnalyzer) {
          log.trace(""String_Node_Str"",termString);
          try (final TokenStream tokenStream=req.getSchema().getQueryAnalyzer().tokenStream(fieldName,termString)){
            final CharTermAttribute charAttribute=tokenStream.addAttribute(CharTermAttribute.class);
            tokenStream.reset();
            int counter=0;
            while (tokenStream.incrementToken()) {
              log.trace(""String_Node_Str"",++counter,charAttribute,score,termString,fieldName);
              addTermToQuery(booleanQuery,fieldName,new BytesRef(charAttribute),score);
              ++booleanClausesTotal;
            }
            tokenStream.end();
          }
         }
 else {
          addTermToQuery(booleanQuery,fieldName,new BytesRef(termString),score);
          ++booleanClausesTotal;
        }
      }
 catch (      final IOException ex) {
        log.error(""String_Node_Str"",ex);
      }
    }
  }
  log.debug(""String_Node_Str"",fieldName,booleanClausesTotal);
  return booleanQuery;
}",0.79203280609256
80810,"@Override public Map<String,Float> execute(Jedis jedis,String key,SolrParams params){
  final String min=ParamUtil.getStringByName(params,""String_Node_Str"",""String_Node_Str"");
  final String max=ParamUtil.getStringByName(params,""String_Node_Str"",""String_Node_Str"");
  log.debug(""String_Node_Str"",key,min,max);
  return Command.ResultUtil.tupleIteratorToMap(jedis.zrangeByScoreWithScores(key,max,min));
}","@Override public Map<String,Float> execute(Jedis jedis,String key,SolrParams params){
  final String min=ParamUtil.getStringByName(params,""String_Node_Str"",""String_Node_Str"");
  final String max=ParamUtil.getStringByName(params,""String_Node_Str"",""String_Node_Str"");
  log.debug(""String_Node_Str"",key,min,max);
  return Command.ResultUtil.tupleIteratorToMap(jedis.zrangeByScoreWithScores(key,min,max));
}",0.9900744416873448
80811,"@Override public Map<String,Float> execute(Jedis jedis,String key,SolrParams params){
  final String min=ParamUtil.getStringByName(params,""String_Node_Str"",""String_Node_Str"");
  final String max=ParamUtil.getStringByName(params,""String_Node_Str"",""String_Node_Str"");
  log.debug(""String_Node_Str"",key,min,max);
  return Command.ResultUtil.tupleIteratorToMap(jedis.zrangeByScoreWithScores(key,max,min));
}","@Override public Map<String,Float> execute(Jedis jedis,String key,SolrParams params){
  final String min=ParamUtil.getStringByName(params,""String_Node_Str"",""String_Node_Str"");
  final String max=ParamUtil.getStringByName(params,""String_Node_Str"",""String_Node_Str"");
  log.debug(""String_Node_Str"",key,min,max);
  return Command.ResultUtil.tupleIteratorToMap(jedis.zrangeByScoreWithScores(key,min,max));
}",0.9900744416873448
80812,"@Override public Query parse() throws SyntaxError {
  String fieldName=localParams.get(QueryParsing.V);
  BooleanQuery booleanQuery=new BooleanQuery(true);
  int booleanClausesTotal=0;
  log.debug(""String_Node_Str"" + redisObjectsCollection.size() + ""String_Node_Str""+ fieldName);
  for (  String termString : redisObjectsCollection) {
    try {
      TokenStream tokenStream=req.getSchema().getQueryAnalyzer().tokenStream(fieldName,termString);
      BytesRef term=new BytesRef();
      if (tokenStream != null) {
        CharTermAttribute charAttribute=tokenStream.addAttribute(CharTermAttribute.class);
        tokenStream.reset();
        int counter=0;
        while (tokenStream.incrementToken()) {
          log.trace(""String_Node_Str"",++counter,termString,fieldName);
          term=new BytesRef(charAttribute);
          TermQuery termQuery=new TermQuery(new Term(fieldName,term));
          booleanQuery.add(termQuery,this.operator);
          ++booleanClausesTotal;
        }
        tokenStream.end();
        tokenStream.close();
      }
 else {
        term.copyChars(termString);
        TermQuery termQuery=new TermQuery(new Term(fieldName,term));
        booleanQuery.add(termQuery,this.operator);
        ++booleanClausesTotal;
      }
    }
 catch (    IOException ex) {
      log.error(""String_Node_Str"",ex);
    }
  }
  log.debug(""String_Node_Str"",booleanClausesTotal);
  return booleanQuery;
}","@Override public Query parse() throws SyntaxError {
  String fieldName=localParams.get(QueryParsing.V);
  BooleanQuery booleanQuery=new BooleanQuery(true);
  int booleanClausesTotal=0;
  if (redisObjectsCollection != null) {
    log.debug(""String_Node_Str"" + redisObjectsCollection.size() + ""String_Node_Str""+ fieldName);
    for (    String termString : redisObjectsCollection) {
      try {
        TokenStream tokenStream=req.getSchema().getQueryAnalyzer().tokenStream(fieldName,termString);
        BytesRef term=new BytesRef();
        if (tokenStream != null) {
          CharTermAttribute charAttribute=tokenStream.addAttribute(CharTermAttribute.class);
          tokenStream.reset();
          int counter=0;
          while (tokenStream.incrementToken()) {
            log.trace(""String_Node_Str"",++counter,termString,fieldName);
            term=new BytesRef(charAttribute);
            TermQuery termQuery=new TermQuery(new Term(fieldName,term));
            booleanQuery.add(termQuery,this.operator);
            ++booleanClausesTotal;
          }
          tokenStream.end();
          tokenStream.close();
        }
 else {
          term.copyChars(termString);
          TermQuery termQuery=new TermQuery(new Term(fieldName,term));
          booleanQuery.add(termQuery,this.operator);
          ++booleanClausesTotal;
        }
      }
 catch (      IOException ex) {
        log.error(""String_Node_Str"",ex);
      }
    }
  }
  log.debug(""String_Node_Str"",booleanClausesTotal);
  return booleanQuery;
}",0.9645293315143249
80813,"protected boolean hasMore(){
  return reader.getFilePointer() < split.getEnd();
}","protected boolean hasMore(){
  return reader.getFilePointer() <= split.getEnd();
}",0.9938650306748468
80814,"/** 
 * Starts the session checker on a polling interval.
 * @param interval the checking interval
 */
protected abstract void startSessionChecker(final long interval);","/** 
 * Starts the session checker on a polling interval.
 * @param interval the checking interval
 */
public abstract void startSessionChecker(final long interval);",0.9669669669669668
80815,"/** 
 * Builds and adds a finalized payload by adding in extra information to the payload: - The event contexts - The Tracker Subject - The Tracker parameters
 * @param payload Payload the raw event payload to bedecorated.
 * @param context The raw context list
 */
private void addEventPayload(Payload payload,List<SelfDescribingJson> context){
  payload.add(Parameters.PLATFORM,this.devicePlatform.toString());
  payload.add(Parameters.APPID,this.appId);
  payload.add(Parameters.NAMESPACE,this.namespace);
  payload.add(Parameters.TRACKER_VERSION,this.trackerVersion);
  if (this.subject != null) {
    payload.addMap(new HashMap<String,Object>(this.subject.getSubject()));
  }
  SelfDescribingJson envelope=getFinalContext(context);
  payload.addMap(envelope.getMap(),this.base64Encoded,Parameters.CONTEXT_ENCODED,Parameters.CONTEXT);
  Logger.v(TAG,""String_Node_Str"",payload);
  this.emitter.add(payload);
}","/** 
 * Builds and adds a finalized payload by adding in extra information to the payload: - The event contexts - The Tracker Subject - The Tracker parameters
 * @param payload Payload the raw event payload to bedecorated.
 * @param context The raw context list
 */
private void addEventPayload(TrackerPayload payload,List<SelfDescribingJson> context){
  payload.add(Parameters.PLATFORM,this.devicePlatform.toString());
  payload.add(Parameters.APPID,this.appId);
  payload.add(Parameters.NAMESPACE,this.namespace);
  payload.add(Parameters.TRACKER_VERSION,this.trackerVersion);
  if (this.subject != null) {
    payload.addMap(new HashMap<String,Object>(this.subject.getSubject()));
  }
  SelfDescribingJson envelope=getFinalContext(context);
  payload.addMap(envelope.getMap(),this.base64Encoded,Parameters.CONTEXT_ENCODED,Parameters.CONTEXT);
  Logger.v(TAG,""String_Node_Str"",payload);
  this.emitter.add(payload);
}",0.9961769524849808
80816,"/** 
 * Shuts down all concurrent services in the Tracker: - Emitter polling sender - Session polling checker
 */
public void shutdown(){
  this.shutdownEmitter();
  this.shutdownSessionChecker();
}","/** 
 * Shuts down all concurrent services in the Tracker: - Emitter polling sender - Session polling checker
 */
public void shutdown(){
  shutdownEmitter();
  shutdownSessionChecker();
}",0.9740932642487048
80817,"protected Event(Builder<?> builder){
  this.context=Util.getMutableList(builder.context);
  this.timestamp=builder.timestamp;
  this.eventId=builder.eventId;
}","protected Event(Builder<?> builder){
  this.context=builder.context;
  this.timestamp=builder.timestamp;
  this.eventId=builder.eventId;
}",0.9292929292929292
80818,"/** 
 * @return the events custom context
 */
public List<SelfDescribingJson> getContext(){
  return this.context;
}","/** 
 * @return the events custom context
 */
public List<SelfDescribingJson> getContext(){
  return new ArrayList<>(this.context);
}",0.931726907630522
80819,"protected HttpResponse sendPostData(Payload payload){
  HttpResponse httpResponse=null;
  AsyncHttpPost asyncHttpPost=new AsyncHttpPost(payload);
  asyncHttpPost.execute();
  try {
    httpResponse=asyncHttpPost.get();
  }
 catch (  InterruptedException e) {
    e.printStackTrace();
  }
catch (  ExecutionException e) {
    e.printStackTrace();
  }
  return httpResponse;
}","protected HttpResponse sendPostData(Payload payload){
  HttpResponse httpResponse=null;
  AsyncHttpPost asyncHttpPost=new AsyncHttpPost(payload,indexArray);
  asyncHttpPost.execute();
  try {
    httpResponse=asyncHttpPost.get();
  }
 catch (  InterruptedException e) {
    e.printStackTrace();
  }
catch (  ExecutionException e) {
    e.printStackTrace();
  }
  return httpResponse;
}",0.9855072463768116
80820,"AsyncHttpGet(Payload payload){
  this.payload=payload;
}","AsyncHttpGet(Payload payload,LinkedList<Long> pendingEventIds){
  this.payload=payload;
  this.pendingEventIds=pendingEventIds;
}",0.6054054054054054
80821,"protected HttpResponse sendGetData(Payload payload){
  HttpResponse httpResponse=null;
  AsyncHttpGet asyncHttpGet=new AsyncHttpGet(payload);
  asyncHttpGet.execute();
  try {
    httpResponse=asyncHttpGet.get();
  }
 catch (  InterruptedException e) {
    e.printStackTrace();
  }
catch (  ExecutionException e) {
    e.printStackTrace();
  }
  return httpResponse;
}","protected HttpResponse sendGetData(Payload payload){
  HttpResponse httpResponse=null;
  AsyncHttpGet asyncHttpGet=new AsyncHttpGet(payload,indexArray);
  asyncHttpGet.execute();
  try {
    httpResponse=asyncHttpGet.get();
  }
 catch (  InterruptedException e) {
    e.printStackTrace();
  }
catch (  ExecutionException e) {
    e.printStackTrace();
  }
  return httpResponse;
}",0.9852744310575636
80822,"@SuppressWarnings(""String_Node_Str"") @Override public void flushBuffer(){
  indexArray=new LinkedList<Long>();
  if (httpMethod == HttpMethod.GET) {
    for (    Map<String,Object> eventMetadata : eventStore.getAllNonPendingEvents()) {
      TrackerPayload payload=new TrackerPayload();
      payload.addMap((Map<String,Object>)eventMetadata.get(EventStoreHelper.METADATA_EVENT_DATA));
      indexArray.add((Long)eventMetadata.get(EventStoreHelper.METADATA_ID));
      eventStore.setPending((Long)eventMetadata.get(EventStoreHelper.METADATA_ID));
      this.sendGetData(payload);
    }
  }
 else   if (httpMethod == HttpMethod.POST) {
    SchemaPayload postPayload=new SchemaPayload();
    postPayload.setSchema(Constants.SCHEMA_PAYLOAD_DATA);
    ArrayList<Map> eventMaps=new ArrayList<Map>();
    for (    Map<String,Object> eventMetadata : eventStore.getAllNonPendingEvents()) {
      TrackerPayload payload=new TrackerPayload();
      payload.addMap((Map<String,Object>)eventMetadata.get(EventStoreHelper.METADATA_EVENT_DATA));
      indexArray.add((Long)eventMetadata.get(EventStoreHelper.METADATA_ID));
      eventStore.setPending((Long)eventMetadata.get(EventStoreHelper.METADATA_ID));
      eventMaps.add(payload.getMap());
    }
    Log.d(TAG,""String_Node_Str"" + indexArray);
    postPayload.setData(eventMaps);
    this.sendPostData(postPayload);
  }
}","/** 
 * Empties the cached events manually. This shouldn't be used unless you're aware of it works. If you need events send instantly, use set the <code>Emitter</code> buffer to <code>BufferOption.Instant</code>
 */
@SuppressWarnings(""String_Node_Str"") @Override public void flushBuffer(){
  indexArray=new LinkedList<Long>();
  if (httpMethod == HttpMethod.GET) {
    for (    Map<String,Object> eventMetadata : eventStore.getAllNonPendingEvents()) {
      TrackerPayload payload=new TrackerPayload();
      payload.addMap((Map<String,Object>)eventMetadata.get(EventStoreHelper.METADATA_EVENT_DATA));
      indexArray.add((Long)eventMetadata.get(EventStoreHelper.METADATA_ID));
      eventStore.setPending((Long)eventMetadata.get(EventStoreHelper.METADATA_ID));
      this.sendGetData(payload);
    }
  }
 else   if (httpMethod == HttpMethod.POST) {
    SchemaPayload postPayload=new SchemaPayload();
    postPayload.setSchema(Constants.SCHEMA_PAYLOAD_DATA);
    ArrayList<Map> eventMaps=new ArrayList<Map>();
    for (    Map<String,Object> eventMetadata : eventStore.getAllNonPendingEvents()) {
      TrackerPayload payload=new TrackerPayload();
      payload.addMap((Map<String,Object>)eventMetadata.get(EventStoreHelper.METADATA_EVENT_DATA));
      indexArray.add((Long)eventMetadata.get(EventStoreHelper.METADATA_ID));
      eventStore.setPending((Long)eventMetadata.get(EventStoreHelper.METADATA_ID));
      eventMaps.add(payload.getMap());
    }
    Log.d(TAG,""String_Node_Str"" + indexArray);
    postPayload.setData(eventMaps);
    this.sendPostData(postPayload);
  }
}",0.8863945578231293
80823,"@Override protected void onPostExecute(HttpResponse response){
  unsentPayloads=new LinkedList<Payload>();
  int success_count=0;
  int status_code=response.getStatusLine().getStatusCode();
  Log.d(TAG,""String_Node_Str"" + status_code);
  if (status_code == 200) {
    success_count++;
    for (int i=0; i < indexArray.size(); i++) {
      eventStore.removeEvent(indexArray.get(i));
      Log.d(TAG,""String_Node_Str"" + indexArray.get(i));
    }
  }
 else {
    unsentPayloads.add(payload);
    for (int i=0; i < indexArray.size(); i++) {
      Log.d(TAG,""String_Node_Str"" + indexArray.get(i));
      eventStore.removePending(indexArray.get(i));
    }
  }
  if (unsentPayloads.size() == 0) {
    if (requestCallback != null)     requestCallback.onSuccess(success_count);
  }
 else   if (requestCallback != null)   requestCallback.onFailure(success_count,unsentPayloads);
}","@Override protected void onPostExecute(HttpResponse response){
  unsentPayloads=new LinkedList<Payload>();
  int success_count=0;
  int status_code=response.getStatusLine().getStatusCode();
  Log.d(TAG,""String_Node_Str"" + status_code);
  if (status_code == 200) {
    success_count++;
    for (int i=0; i < this.pendingEventIds.size(); i++) {
      eventStore.removeEvent(this.pendingEventIds.get(i));
      Log.d(TAG,""String_Node_Str"" + this.pendingEventIds.get(i));
    }
  }
 else {
    unsentPayloads.add(payload);
    for (int i=0; i < this.pendingEventIds.size(); i++) {
      Log.d(TAG,""String_Node_Str"" + this.pendingEventIds.get(i));
      eventStore.removePending(this.pendingEventIds.get(i));
    }
  }
  if (unsentPayloads.size() == 0) {
    if (requestCallback != null)     requestCallback.onSuccess(success_count);
  }
 else   if (requestCallback != null) {
    requestCallback.onFailure(success_count,unsentPayloads);
  }
}",0.5453539823008849
80824,"AsyncHttpPost(Payload payload){
  this.payload=payload;
}","AsyncHttpPost(Payload payload,LinkedList<Long> pendingEventIds){
  this.payload=payload;
  this.pendingEventIds=pendingEventIds;
}",0.6096256684491979
80825,"private void output(File intermediate) throws IOException {
  if (fArguments.size() >= 3) {
    File output=new File(fArguments.get(2));
    intermediate.renameTo(output);
  }
  try (FileInputStream iStream=new FileInputStream(intermediate)){
    IOUtils.copy(iStream,System.out);
  }
  finally {
    intermediate.delete();
  }
}","private void output(File intermediate) throws IOException {
  if (fArguments.size() >= 3) {
    File output=new File(fArguments.get(2));
    intermediate.renameTo(output);
  }
 else {
    try (FileInputStream iStream=new FileInputStream(intermediate)){
      IOUtils.copy(iStream,System.out);
    }
  finally {
      intermediate.delete();
    }
  }
}",0.9588235294117649
80826,"@Override public void handleGET(CoapExchange exchange){
  Collection<Resource> resources=rdResource.getChildren();
  TreeSet<String> availableDomains=new TreeSet<String>();
  String domainQuery=""String_Node_Str"";
  Iterator<Resource> resIt=resources.iterator();
  String result=""String_Node_Str"";
  List<String> queries=exchange.getRequestOptions().getUriQuery();
  for (  String query : queries) {
    LinkAttribute attr=LinkAttribute.parse(query);
    if (attr.getName().equals(LinkFormat.DOMAIN))     domainQuery=attr.getValue();
  }
  while (resIt.hasNext()) {
    Resource res=resIt.next();
    if (res.getClass() == RDNodeResource.class) {
      RDNodeResource node=(RDNodeResource)res;
      if ((domainQuery.isEmpty() || domainQuery.equals(node.getDomain()))) {
        availableDomains.add(node.getDomain());
      }
    }
  }
  if (availableDomains.isEmpty()) {
    exchange.respond(ResponseCode.NOT_FOUND);
  }
 else {
    Iterator<String> domIt=availableDomains.iterator();
    while (domIt.hasNext()) {
      String dom=domIt.next();
      result+=""String_Node_Str"" + LinkFormat.DOMAIN + ""String_Node_Str""+ dom+ ""String_Node_Str"";
    }
    exchange.respond(ResponseCode.CONTENT,result.substring(0,result.length() - 1),MediaTypeRegistry.APPLICATION_LINK_FORMAT);
  }
}","@Override public void handleGET(CoapExchange exchange){
  Collection<Resource> resources=rdResource.getChildren();
  TreeSet<String> availableDomains=new TreeSet<String>();
  String domainQuery=null;
  Iterator<Resource> resIt=resources.iterator();
  String result=""String_Node_Str"";
  List<String> query=exchange.getRequestOptions().getUriQuery();
  for (  String q : query) {
    KeyValuePair kvp=KeyValuePair.parse(q);
    if (LinkFormat.DOMAIN.equals(kvp.getName())) {
      domainQuery=kvp.getValue();
    }
  }
  while (resIt.hasNext()) {
    Resource res=resIt.next();
    if (res.getClass() == RDNodeResource.class) {
      RDNodeResource node=(RDNodeResource)res;
      if (domainQuery == null || domainQuery.equals(node.getDomain())) {
        availableDomains.add(node.getDomain());
      }
    }
  }
  if (availableDomains.isEmpty()) {
    exchange.respond(ResponseCode.NOT_FOUND);
  }
 else {
    Iterator<String> domIt=availableDomains.iterator();
    while (domIt.hasNext()) {
      String dom=domIt.next();
      result+=""String_Node_Str"" + LinkFormat.DOMAIN + ""String_Node_Str""+ dom+ ""String_Node_Str"";
    }
    exchange.respond(ResponseCode.CONTENT,result.substring(0,result.length() - 1),MediaTypeRegistry.APPLICATION_LINK_FORMAT);
  }
}",0.8534278959810875
80827,"@Override public void handleGET(CoapExchange exchange){
  Collection<Resource> resources=rdResource.getChildren();
  List<String> query=exchange.getRequestOptions().getUriQuery();
  String result=""String_Node_Str"";
  String domainQuery=""String_Node_Str"";
  String endpointQuery=""String_Node_Str"";
  TreeSet<String> endpointTypeQuery=new TreeSet<String>();
  for (  String q : query) {
    LinkAttribute attr=LinkAttribute.parse(q);
    if (attr.getName().equals(LinkFormat.DOMAIN)) {
      domainQuery=attr.getValue();
    }
    if (attr.getName().equals(LinkFormat.END_POINT)) {
      endpointQuery=attr.getValue();
    }
    if (attr.getName().equals(LinkFormat.END_POINT_TYPE)) {
      Collections.addAll(endpointTypeQuery,attr.getValue().split(""String_Node_Str""));
    }
  }
  Iterator<Resource> resIt=resources.iterator();
  while (resIt.hasNext()) {
    Resource res=resIt.next();
    if (res.getClass() == RDNodeResource.class) {
      RDNodeResource node=(RDNodeResource)res;
      if ((domainQuery.isEmpty() || domainQuery.equals(node.getDomain())) && (endpointQuery.isEmpty() || endpointQuery.equals(node.getEndpointIdentifier())) && (endpointTypeQuery.isEmpty() || endpointTypeQuery.contains(node.getEndpointType()))) {
        result+=""String_Node_Str"" + node.getContext() + ""String_Node_Str""+ LinkFormat.END_POINT+ ""String_Node_Str""+ node.getEndpointIdentifier()+ ""String_Node_Str"";
        result+=""String_Node_Str"" + LinkFormat.DOMAIN + ""String_Node_Str""+ node.getDomain()+ ""String_Node_Str"";
        if (!node.getEndpointType().isEmpty()) {
          result+=""String_Node_Str"" + LinkFormat.RESOURCE_TYPE + ""String_Node_Str""+ node.getEndpointType()+ ""String_Node_Str"";
        }
        result+=""String_Node_Str"";
      }
    }
  }
  if (result.isEmpty()) {
    exchange.respond(ResponseCode.NOT_FOUND);
  }
 else {
    exchange.respond(ResponseCode.CONTENT,result.substring(0,result.length() - 1),MediaTypeRegistry.APPLICATION_LINK_FORMAT);
  }
}","@Override public void handleGET(CoapExchange exchange){
  Collection<Resource> resources=rdResource.getChildren();
  String result=""String_Node_Str"";
  String domainQuery=""String_Node_Str"";
  String endpointQuery=""String_Node_Str"";
  TreeSet<String> endpointTypeQuery=new TreeSet<String>();
  List<String> query=exchange.getRequestOptions().getUriQuery();
  for (  String q : query) {
    KeyValuePair kvp=KeyValuePair.parse(q);
    if (LinkFormat.DOMAIN.equals(kvp.getName())) {
      domainQuery=kvp.getValue();
    }
    if (LinkFormat.END_POINT.equals(kvp.getName())) {
      endpointQuery=kvp.getValue();
    }
    if (LinkFormat.END_POINT_TYPE.equals(kvp.getName())) {
      Collections.addAll(endpointTypeQuery,kvp.getValue().split(""String_Node_Str""));
    }
  }
  Iterator<Resource> resIt=resources.iterator();
  while (resIt.hasNext()) {
    Resource res=resIt.next();
    if (res.getClass() == RDNodeResource.class) {
      RDNodeResource node=(RDNodeResource)res;
      if ((domainQuery.isEmpty() || domainQuery.equals(node.getDomain())) && (endpointQuery.isEmpty() || endpointQuery.equals(node.getEndpointName())) && (endpointTypeQuery.isEmpty() || endpointTypeQuery.contains(node.getEndpointType()))) {
        result+=""String_Node_Str"" + node.getContext() + ""String_Node_Str""+ LinkFormat.END_POINT+ ""String_Node_Str""+ node.getEndpointName()+ ""String_Node_Str"";
        result+=""String_Node_Str"" + LinkFormat.DOMAIN + ""String_Node_Str""+ node.getDomain()+ ""String_Node_Str"";
        if (!node.getEndpointType().isEmpty()) {
          result+=""String_Node_Str"" + LinkFormat.RESOURCE_TYPE + ""String_Node_Str""+ node.getEndpointType()+ ""String_Node_Str"";
        }
        result+=""String_Node_Str"";
      }
    }
  }
  if (result.isEmpty()) {
    exchange.respond(ResponseCode.NOT_FOUND);
  }
 else {
    exchange.respond(ResponseCode.CONTENT,result.substring(0,result.length() - 1),MediaTypeRegistry.APPLICATION_LINK_FORMAT);
  }
}",0.8265436843453754
80828,"@Override public void handleGET(CoapExchange exchange){
  Collection<Resource> resources=rdResource.getChildren();
  String result=""String_Node_Str"";
  String domainQuery=""String_Node_Str"";
  String endpointQuery=""String_Node_Str"";
  List<String> toRemove=new ArrayList<String>();
  List<String> query=exchange.getRequestOptions().getUriQuery();
  for (  String q : query) {
    LinkAttribute attr=LinkAttribute.parse(q);
    if (attr.getName().equals(LinkFormat.DOMAIN)) {
      domainQuery=attr.getValue();
      if (domainQuery == null) {
        exchange.respond(ResponseCode.BAD_REQUEST);
        return;
      }
      toRemove.add(q);
    }
    if (attr.getName().equals(LinkFormat.END_POINT)) {
      endpointQuery=attr.getValue();
      if (endpointQuery == null) {
        exchange.respond(ResponseCode.BAD_REQUEST);
        return;
      }
      toRemove.add(q);
    }
  }
  Iterator<Resource> resIt=resources.iterator();
  query.removeAll(toRemove);
  while (resIt.hasNext()) {
    Resource res=resIt.next();
    if (res instanceof RDNodeResource) {
      RDNodeResource node=(RDNodeResource)res;
      if ((domainQuery.isEmpty() || domainQuery.equals(node.getDomain())) && (endpointQuery.isEmpty() || endpointQuery.equals(node.getEndpointIdentifier()))) {
        String link=node.toLinkFormat(query);
        result+=(!link.isEmpty()) ? link + ""String_Node_Str"" : ""String_Node_Str"";
      }
    }
  }
  if (result.isEmpty()) {
    exchange.respond(ResponseCode.NOT_FOUND);
  }
 else {
    exchange.respond(ResponseCode.CONTENT,result.substring(0,result.length() - 1),MediaTypeRegistry.APPLICATION_LINK_FORMAT);
  }
}","@Override public void handleGET(CoapExchange exchange){
  Collection<Resource> resources=rdResource.getChildren();
  String result=""String_Node_Str"";
  String domainQuery=""String_Node_Str"";
  String endpointQuery=""String_Node_Str"";
  List<String> toRemove=new ArrayList<String>();
  List<String> query=exchange.getRequestOptions().getUriQuery();
  for (  String q : query) {
    KeyValuePair kvp=KeyValuePair.parse(q);
    if (LinkFormat.DOMAIN.equals(kvp.getName())) {
      if (kvp.isFlag()) {
        exchange.respond(ResponseCode.BAD_REQUEST,""String_Node_Str"");
        return;
      }
 else {
        domainQuery=kvp.getValue();
        toRemove.add(q);
      }
    }
    if (LinkFormat.END_POINT.equals(kvp.getName())) {
      if (kvp.isFlag()) {
        exchange.respond(ResponseCode.BAD_REQUEST,""String_Node_Str"");
        return;
      }
 else {
        endpointQuery=kvp.getValue();
        toRemove.add(q);
      }
    }
  }
  query.removeAll(toRemove);
  Iterator<Resource> resIt=resources.iterator();
  while (resIt.hasNext()) {
    Resource res=resIt.next();
    if (res instanceof RDNodeResource) {
      RDNodeResource node=(RDNodeResource)res;
      if ((domainQuery.isEmpty() || domainQuery.equals(node.getDomain())) && (endpointQuery.isEmpty() || endpointQuery.equals(node.getEndpointName()))) {
        String link=node.toLinkFormat(query);
        result+=(!link.isEmpty()) ? link + ""String_Node_Str"" : ""String_Node_Str"";
      }
    }
  }
  if (result.isEmpty()) {
    exchange.respond(ResponseCode.NOT_FOUND);
  }
 else {
    exchange.respond(ResponseCode.CONTENT,result.substring(0,result.length() - 1),MediaTypeRegistry.APPLICATION_LINK_FORMAT);
  }
}",0.8363086232980332
80829,"@Override public void delete(){
  LOGGER.info(""String_Node_Str"" + getContext());
  if (lifetimeTimer != null) {
    lifetimeTimer.cancel();
  }
  super.delete();
}","@Override public void delete(){
  LOGGER.info(""String_Node_Str"" + getContext());
  if (ltExpiryFuture != null) {
    ltExpiryFuture.cancel(false);
  }
  super.delete();
}",0.8588588588588588
80830,"public void setLifeTime(int newLifeTime){
  lifeTime=newLifeTime;
  if (lifetimeTimer != null) {
    lifetimeTimer.cancel();
  }
  lifetimeTimer=new Timer();
  lifetimeTimer.schedule(new ExpiryTask(this),lifeTime * 1000 + 2000);
}","public void setLifeTime(int newLifeTime){
  lifeTime=newLifeTime;
  if (ltExpiryFuture != null) {
    ltExpiryFuture.cancel(true);
  }
  ltExpiryFuture=scheduler.schedule(new Runnable(){
    @Override public void run(){
      delete();
    }
  }
,lifeTime + 2,TimeUnit.SECONDS);
}",0.5058823529411764
80831,"/** 
 * Updates the endpoint parameters from POST and PUT requests.
 * @param request A POST or PUT request with a {?et,lt,con} URI Template queryand a Link Format payload.
 */
public boolean setParameters(Request request){
  boolean contextUpdated=false;
  String newContext=""String_Node_Str"";
  List<String> query=request.getOptions().getUriQuery();
  for (  String q : query) {
    KeyValuePair kvp=KeyValuePair.parse(q);
    if (LinkFormat.END_POINT_TYPE.equals(kvp.getName()) && !kvp.isFlag()) {
      this.endpointType=kvp.getValue();
    }
    if (LinkFormat.LIFE_TIME.equals(kvp.getName()) && !kvp.isFlag()) {
      lifeTime=kvp.getIntValue();
      if (lifeTime < 60) {
        LOGGER.info(""String_Node_Str"" + lifeTime + ""String_Node_Str"");
        lifeTime=60;
      }
    }
    if (LinkFormat.CONTEXT.equals(kvp.getName()) && !kvp.isFlag()) {
      newContext=kvp.getValue();
      contextUpdated=true;
    }
  }
  if (context == null || contextUpdated) {
    try {
      URI check;
      if (newContext.isEmpty()) {
        check=new URI(""String_Node_Str"",""String_Node_Str"",request.getSource().getHostAddress(),request.getSourcePort(),""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
        this.context=check.toString().replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str"");
      }
 else {
        check=new URI(newContext);
        this.context=newContext;
      }
    }
 catch (    Exception e) {
      LOGGER.warning(""String_Node_Str"" + request.getSource().getHostAddress() + ""String_Node_Str""+ request.getSourcePort()+ ""String_Node_Str""+ newContext+ ""String_Node_Str"");
      return false;
    }
  }
  if (lifetimeTimer == null) {
    setLifeTime(lifeTime);
  }
  return updateEndpointResources(request.getPayloadString());
}","/** 
 * Updates the endpoint parameters from POST and PUT requests.
 * @param request A POST or PUT request with a {?et,lt,con} URI Template queryand a Link Format payload.
 */
public boolean setParameters(Request request){
  boolean contextUpdated=false;
  String newContext=""String_Node_Str"";
  List<String> query=request.getOptions().getUriQuery();
  for (  String q : query) {
    KeyValuePair kvp=KeyValuePair.parse(q);
    if (LinkFormat.END_POINT_TYPE.equals(kvp.getName()) && !kvp.isFlag()) {
      this.endpointType=kvp.getValue();
    }
    if (LinkFormat.LIFE_TIME.equals(kvp.getName()) && !kvp.isFlag()) {
      lifeTime=kvp.getIntValue();
      if (lifeTime < 60) {
        LOGGER.info(""String_Node_Str"" + lifeTime + ""String_Node_Str"");
        lifeTime=60;
      }
    }
    if (LinkFormat.CONTEXT.equals(kvp.getName()) && !kvp.isFlag()) {
      newContext=kvp.getValue();
      contextUpdated=true;
    }
  }
  if (context == null || contextUpdated) {
    try {
      setContextFromRequest(request,newContext);
    }
 catch (    Exception e) {
      LOGGER.log(Level.WARNING,""String_Node_Str"",new Object[]{newContext,request.getSource().getHostAddress(),request.getSourcePort(),e});
      return false;
    }
  }
  if (ltExpiryFuture == null) {
    setLifeTime(lifeTime);
  }
  return updateEndpointResources(request.getPayloadString());
}",0.7419962335216572
80832,"public RDNodeResource(String ep,String domain){
  super(ep);
  int epLength=ep.getBytes(CoAP.UTF8_CHARSET).length;
  if (epLength > 63)   LOGGER.warning(""String_Node_Str"" + ep + ""String_Node_Str""+ epLength+ ""String_Node_Str"");
  this.endpointName=ep;
  this.domain=domain;
}","public RDNodeResource(String ep,String domain){
  super(ep);
  int epLength=ep.getBytes(CoAP.UTF8_CHARSET).length;
  if (epLength > 63) {
    LOGGER.log(Level.WARNING,""String_Node_Str"",new Object[]{ep,epLength});
  }
  this.endpointName=ep;
  this.domain=domain;
}",0.7211895910780669
80833,"@Override public void handlePOST(CoapExchange exchange){
  if (lifetimeTimer != null) {
    lifetimeTimer.cancel();
  }
  LOGGER.info(""String_Node_Str"" + getContext());
  setParameters(exchange.advanced().getRequest());
  setLifeTime(this.lifeTime);
  exchange.respond(ResponseCode.CHANGED);
}","@Override public void handlePOST(CoapExchange exchange){
  if (ltExpiryFuture != null) {
    ltExpiryFuture.cancel(true);
  }
  LOGGER.info(""String_Node_Str"" + getContext());
  setParameters(exchange.advanced().getRequest());
  setLifeTime(this.lifeTime);
  exchange.respond(ResponseCode.CHANGED);
}",0.8817567567567568
80834,"public void stop(){
  float dt=(System.nanoTime() - timestamp) / 1000000f;
  if (verbose)   System.out.println(""String_Node_Str"");
  for (  VirtualClient vc : clients)   vc.stop();
  int sum=0;
  int sumTimeout=0;
  IntArray latencies=new IntArray();
  for (int i=0; i < clients.size(); i++) {
    VirtualClient client=clients.get(i);
    int count=client.getCount();
    int lost=client.getTimeouts();
    latencies.add(client.getLatencies());
    sum+=count;
    sumTimeout+=lost;
    if (verbose)     System.out.format(""String_Node_Str"",i,count,lost,(int)(count * 1000L / dt));
  }
  float throughput=(sum * 1000L) / dt;
  int[] lats=latencies.getArray();
  long latsum=0;
  for (  int l : lats)   latsum+=l;
  double mean=(double)latsum / lats.length;
  double temp=0;
  for (  int l : lats)   temp+=(mean - l) * (mean - l);
  double var=Math.sqrt(temp / lats.length);
  if (lats.length > 0) {
    Arrays.sort(lats);
    int q50=lats[(int)(lats.length / 2)];
    int q66=lats[(int)(lats.length * 2L / 3)];
    int q75=lats[(int)(lats.length * 3L / 4)];
    int q80=lats[(int)(lats.length * 4L / 5)];
    int q90=lats[(int)(lats.length * 9L / 10)];
    int q95=lats[(int)(lats.length * 19L / 20)];
    int q98=lats[(int)(lats.length * 98L / 100)];
    int q99=lats[(int)(lats.length * 99L / 100)];
    int q100=lats[lats.length - 1];
    log.format(""String_Node_Str"",sumTimeout,count,dt / 1000f,sum,throughput,q50,q66,q75,q80,q90,q95,q98,q99,q100,var);
  }
 else {
    log.format(""String_Node_Str"",count,dt / 1000f,sum,sumTimeout,throughput,uri.toString());
  }
}","public void stop(){
  float dt=(System.nanoTime() - timestamp) / 1000000f;
  if (verbose)   System.out.println(""String_Node_Str"");
  for (  VirtualClient vc : clients)   vc.stop();
  int sum=0;
  int sumTimeout=0;
  IntArray latencies=new IntArray();
  for (int i=0; i < clients.size(); i++) {
    VirtualClient client=clients.get(i);
    int count=client.getCount();
    int lost=client.getTimeouts();
    for (    int lat : client.getLatencies()) {
      latencies.add(lat);
    }
    sum+=count;
    sumTimeout+=lost;
    if (verbose)     System.out.format(""String_Node_Str"",i,count,lost,(int)(count * 1000L / dt));
  }
  float throughput=(sum * 1000L) / dt;
  int[] lats=latencies.getArray();
  long latsum=0;
  for (  int l : lats)   latsum+=l;
  double mean=(double)latsum / lats.length;
  double temp=0;
  for (  int l : lats)   temp+=(mean - l) * (mean - l);
  double var=Math.sqrt(temp / lats.length);
  if (lats.length > 0) {
    Arrays.sort(lats);
    int q50=lats[(int)(lats.length / 2)];
    int q66=lats[(int)(lats.length * 2L / 3)];
    int q75=lats[(int)(lats.length * 3L / 4)];
    int q80=lats[(int)(lats.length * 4L / 5)];
    int q90=lats[(int)(lats.length * 9L / 10)];
    int q95=lats[(int)(lats.length * 19L / 20)];
    int q98=lats[(int)(lats.length * 98L / 100)];
    int q99=lats[(int)(lats.length * 99L / 100)];
    int q100=lats[lats.length - 1];
    log.format(""String_Node_Str"",sumTimeout,count,dt / 1000f,sum,throughput,q50,q66,q75,q80,q90,q95,q98,q99,q100,var);
  }
 else {
    log.format(""String_Node_Str"",count,dt / 1000f,sum,sumTimeout,throughput,uri.toString());
  }
}",0.9735015772870662
80835,"public void run(){
  try {
    CordovaActivity ca=(CordovaActivity)cordova.getActivity();
    SystemWebView view=(SystemWebView)webView.getView();
    CertificatesCordovaWebViewClient cWebClient=new CertificatesCordovaWebViewClient((SystemWebViewEngine)webView.getEngine());
    cWebClient.setAllowUntrusted(allowUntrusted);
    webView.clearCache();
    view.setWebViewClient(cWebClient);
  }
 catch (  Exception e) {
    Log.e(LOG_TAG,""String_Node_Str"",e);
  }
}","public void run(){
  try {
    CordovaActivity ca=(CordovaActivity)cordova.getActivity();
    SystemWebView view=(SystemWebView)webView.getView();
    CertificatesCordovaWebViewClient cWebClient=new CertificatesCordovaWebViewClient((SystemWebViewEngine)webView.getEngine());
    cWebClient.setAllowUntrusted(allowUntrusted);
    webView.clearCache();
    webView.stopLoading();
    view.setWebViewClient(cWebClient);
  }
 catch (  Exception e) {
    Log.e(LOG_TAG,""String_Node_Str"",e);
  }
}",0.9717277486910996
80836,"/** 
 * Executes the request. This method is called from the WebView thread. To do a non-trivial amount of work, use: cordova.getThreadPool().execute(runnable); To run on the UI thread, use: cordova.getActivity().runOnUiThread(runnable);
 * @param action The action to execute. (Currently ""setUntrusted only"")
 * @param args The exec() arguments.
 * @param callbackContext The callback context used when calling back into JavaScript.
 * @return Whether the action was valid.
 */
@Override public boolean execute(String action,JSONArray args,CallbackContext callbackContext) throws JSONException {
  if (action.equals(""String_Node_Str"")) {
    try {
      allowUntrusted=args.getBoolean(0);
      Log.d(LOG_TAG,""String_Node_Str"" + allowUntrusted);
      cordova.getActivity().runOnUiThread(new Runnable(){
        public void run(){
          try {
            CordovaActivity ca=(CordovaActivity)cordova.getActivity();
            SystemWebView view=(SystemWebView)webView.getView();
            CertificatesCordovaWebViewClient cWebClient=new CertificatesCordovaWebViewClient((SystemWebViewEngine)webView.getEngine());
            cWebClient.setAllowUntrusted(allowUntrusted);
            webView.clearCache();
            view.setWebViewClient(cWebClient);
          }
 catch (          Exception e) {
            Log.e(LOG_TAG,""String_Node_Str"",e);
          }
        }
      }
);
      callbackContext.success();
      return true;
    }
 catch (    Exception e) {
      Log.e(LOG_TAG,""String_Node_Str"",e);
    }
  }
  callbackContext.error(""String_Node_Str"");
  return false;
}","/** 
 * Executes the request. This method is called from the WebView thread. To do a non-trivial amount of work, use: cordova.getThreadPool().execute(runnable); To run on the UI thread, use: cordova.getActivity().runOnUiThread(runnable);
 * @param action The action to execute. (Currently ""setUntrusted only"")
 * @param args The exec() arguments.
 * @param callbackContext The callback context used when calling back into JavaScript.
 * @return Whether the action was valid.
 */
@Override public boolean execute(String action,JSONArray args,CallbackContext callbackContext) throws JSONException {
  if (action.equals(""String_Node_Str"")) {
    try {
      allowUntrusted=args.getBoolean(0);
      Log.d(LOG_TAG,""String_Node_Str"" + allowUntrusted);
      cordova.getActivity().runOnUiThread(new Runnable(){
        public void run(){
          try {
            CordovaActivity ca=(CordovaActivity)cordova.getActivity();
            SystemWebView view=(SystemWebView)webView.getView();
            CertificatesCordovaWebViewClient cWebClient=new CertificatesCordovaWebViewClient((SystemWebViewEngine)webView.getEngine());
            cWebClient.setAllowUntrusted(allowUntrusted);
            webView.clearCache();
            webView.stopLoading();
            view.setWebViewClient(cWebClient);
          }
 catch (          Exception e) {
            Log.e(LOG_TAG,""String_Node_Str"",e);
          }
        }
      }
);
      callbackContext.success();
      return true;
    }
 catch (    Exception e) {
      Log.e(LOG_TAG,""String_Node_Str"",e);
    }
  }
  callbackContext.error(""String_Node_Str"");
  return false;
}",0.9890659169009683
80837,"/** 
 * Executes the request. This method is called from the WebView thread. To do a non-trivial amount of work, use: cordova.getThreadPool().execute(runnable); To run on the UI thread, use: cordova.getActivity().runOnUiThread(runnable);
 * @param action The action to execute. (Currently ""setUntrusted only"")
 * @param args The exec() arguments.
 * @param callbackContext The callback context used when calling back into JavaScript.
 * @return Whether the action was valid.
 */
@Override public boolean execute(String action,JSONArray args,CallbackContext callbackContext) throws JSONException {
  if (action.equals(""String_Node_Str"")) {
    boolean allowUntrusted=args.getBoolean(0);
    Log.d(LOG_TAG,""String_Node_Str"" + allowUntrusted);
    CordovaActivity ca=(CordovaActivity)this.cordova.getActivity();
    CertificatesCordovaWebViewClient cWebClient=new CertificatesCordovaWebViewClient(this.cordova);
    cWebClient.setAllowUntrusted(allowUntrusted);
    webView.setWebViewClient(cWebClient);
    ca.clearCache();
    callbackContext.success();
    return true;
  }
  callbackContext.error(""String_Node_Str"");
  return false;
}","/** 
 * Executes the request. This method is called from the WebView thread. To do a non-trivial amount of work, use: cordova.getThreadPool().execute(runnable); To run on the UI thread, use: cordova.getActivity().runOnUiThread(runnable);
 * @param action The action to execute. (Currently ""setUntrusted only"")
 * @param args The exec() arguments.
 * @param callbackContext The callback context used when calling back into JavaScript.
 * @return Whether the action was valid.
 */
@Override public boolean execute(String action,JSONArray args,CallbackContext callbackContext) throws JSONException {
  if (action.equals(""String_Node_Str"")) {
    allowUntrusted=args.getBoolean(0);
    Log.d(LOG_TAG,""String_Node_Str"" + allowUntrusted);
    cordova.getActivity().runOnUiThread(new Runnable(){
      public void run(){
        CertificatesCordovaWebViewClient cWebClient=new CertificatesCordovaWebViewClient(cordova);
        cWebClient.setAllowUntrusted(allowUntrusted);
        webView.setWebViewClient(cWebClient);
        CordovaActivity ca=(CordovaActivity)cordova.getActivity();
        ca.clearCache();
      }
    }
);
    callbackContext.success();
    return true;
  }
  callbackContext.error(""String_Node_Str"");
  return false;
}",0.7434599156118143
80838,"@Override public void onReceivedSslError(WebView view,SslErrorHandler handler,SslError error){
  Log.d(""String_Node_Str"" + isAllowUntrusted());
  if (isAllowUntrusted()) {
    handler.proceed();
  }
 else {
    handler.cancel();
  }
}","@Override public void onReceivedSslError(WebView view,SslErrorHandler handler,SslError error){
  Log.d(TAG,""String_Node_Str"" + isAllowUntrusted());
  if (isAllowUntrusted()) {
    handler.proceed();
  }
 else {
    handler.cancel();
  }
}",0.9915254237288136
80839,"public List<OutPair> getProperties(String filePath) throws EditorConfigException {
  final Map<String,String> options=new LinkedHashMap<String,String>();
  try {
    boolean root=false;
    String dir=new File(filePath).getParent();
    while (dir != null && !root) {
      String configPath=dir + ""String_Node_Str"" + configFilename;
      if (new File(configPath).exists()) {
        FileReader reader=new FileReader(configPath);
        BufferedReader bufferedReader=new BufferedReader(reader);
        try {
          root=parseFile(bufferedReader,dir + ""String_Node_Str"",filePath,options);
        }
  finally {
          bufferedReader.close();
          reader.close();
        }
      }
      dir=new File(dir).getParent();
    }
  }
 catch (  IOException e) {
    throw new EditorConfigException(null,e);
  }
  preprocessOptions(options);
  final List<OutPair> result=new ArrayList<OutPair>();
  for (  Map.Entry<String,String> keyValue : options.entrySet()) {
    result.add(new OutPair(keyValue.getKey(),keyValue.getValue()));
  }
  return result;
}","public List<OutPair> getProperties(String filePath) throws EditorConfigException {
  final Map<String,String> options=new LinkedHashMap<String,String>();
  try {
    boolean root=false;
    String dir=new File(filePath).getParent();
    while (dir != null && !root) {
      String configPath=dir + ""String_Node_Str"" + configFilename;
      if (new File(configPath).exists()) {
        FileInputStream stream=new FileInputStream(configPath);
        InputStreamReader reader=new InputStreamReader(stream,""String_Node_Str"");
        BufferedReader bufferedReader=new BufferedReader(reader);
        try {
          root=parseFile(bufferedReader,dir + ""String_Node_Str"",filePath,options);
        }
  finally {
          bufferedReader.close();
          reader.close();
          stream.close();
        }
      }
      dir=new File(dir).getParent();
    }
  }
 catch (  IOException e) {
    throw new EditorConfigException(null,e);
  }
  preprocessOptions(options);
  final List<OutPair> result=new ArrayList<OutPair>();
  for (  Map.Entry<String,String> keyValue : options.entrySet()) {
    result.add(new OutPair(keyValue.getKey(),keyValue.getValue()));
  }
  return result;
}",0.8202146690518783
80840,"private void update(ProxiedPlayer player,ConnectedPlayer connectedPlayer){
  PlayerTablistHandler tablistHandler=connectedPlayer.getPlayerTablistHandler();
  try {
    if (connectedPlayer.getCustomTablist() != null) {
      tablistHandler.setTablistProvider((TablistProvider)connectedPlayer.getCustomTablist());
    }
 else {
      TablistProvider tablistProvider=tablistHandler.getTablistProvider();
      Server server=player.getServer();
      if (server != null && !(BungeeTabListPlus.getInstance().excludedServers.contains(server.getInfo().getName()))) {
        Context context=new Context().put(Context.KEY_VIEWER,connectedPlayer);
        Config config=BungeeTabListPlus.getInstance().getTabListManager().getNewConfigForContext(context);
        if (config != null && (!(tablistProvider instanceof ConfigTablistProvider) || ((ConfigTablistProvider)tablistProvider).config != config)) {
          tablistHandler.setTablistProvider(createTablistProvider(context,config));
          tablistProvider=tablistHandler.getTablistProvider();
        }
 else         if (config == null && tablistProvider instanceof ConfigTablistProvider) {
          tablistHandler.setTablistProvider(tablistProvider=DefaultTablistProvider.INSTANCE);
        }
      }
 else {
        tablistHandler.setTablistProvider(tablistProvider=DefaultTablistProvider.INSTANCE);
      }
      if (tablistProvider instanceof ConfigTablistProvider) {
        ((ConfigTablistProvider)tablistProvider).update();
      }
    }
  }
 catch (  Throwable th) {
    BungeeTabListPlus.getInstance().getLogger().log(Level.SEVERE,""String_Node_Str"",th);
  }
}","private void update(ProxiedPlayer player,ConnectedPlayer connectedPlayer){
  PlayerTablistHandler tablistHandler=connectedPlayer.getPlayerTablistHandler();
  if (tablistHandler == null) {
    return;
  }
  try {
    if (connectedPlayer.getCustomTablist() != null) {
      tablistHandler.setTablistProvider((TablistProvider)connectedPlayer.getCustomTablist());
    }
 else {
      TablistProvider tablistProvider=tablistHandler.getTablistProvider();
      Server server=player.getServer();
      if (server != null && !(BungeeTabListPlus.getInstance().excludedServers.contains(server.getInfo().getName()))) {
        Context context=new Context().put(Context.KEY_VIEWER,connectedPlayer);
        Config config=BungeeTabListPlus.getInstance().getTabListManager().getNewConfigForContext(context);
        if (config != null && (!(tablistProvider instanceof ConfigTablistProvider) || ((ConfigTablistProvider)tablistProvider).config != config)) {
          tablistHandler.setTablistProvider(createTablistProvider(context,config));
          tablistProvider=tablistHandler.getTablistProvider();
        }
 else         if (config == null && tablistProvider instanceof ConfigTablistProvider) {
          tablistHandler.setTablistProvider(tablistProvider=DefaultTablistProvider.INSTANCE);
        }
      }
 else {
        tablistHandler.setTablistProvider(tablistProvider=DefaultTablistProvider.INSTANCE);
      }
      if (tablistProvider instanceof ConfigTablistProvider) {
        ((ConfigTablistProvider)tablistProvider).update();
      }
    }
  }
 catch (  Throwable th) {
    BungeeTabListPlus.getInstance().getLogger().log(Level.SEVERE,""String_Node_Str"",th);
  }
}",0.9853747714808044
80841,"@Synchronized public void onPlayerDisconnected(ConnectedPlayer player){
  if (!players.remove(player)) {
    return;
  }
  byName.remove(player.getName(),player);
  byUUID.remove(player.getUniqueID(),player);
  playerList=ImmutableList.copyOf((Iterable<? extends ConnectedPlayer>)players);
  BungeeTabListPlus.getInstance().runInMainThread(() -> {
    player.getPlayerTablistHandler().onDisconnect();
  }
);
  PacketHandler packetHandler=player.getPacketHandler();
  if (packetHandler instanceof TabListHandler) {
    ((TabListHandler)packetHandler).onDisconnected();
  }
}","@Synchronized public void onPlayerDisconnected(ConnectedPlayer player){
  if (!players.remove(player)) {
    return;
  }
  byName.remove(player.getName(),player);
  byUUID.remove(player.getUniqueID(),player);
  playerList=ImmutableList.copyOf((Iterable<? extends ConnectedPlayer>)players);
  BungeeTabListPlus.getInstance().runInMainThread(() -> {
    PlayerTablistHandler tablistHandler=player.getPlayerTablistHandler();
    if (tablistHandler != null) {
      tablistHandler.onDisconnect();
    }
  }
);
  PacketHandler packetHandler=player.getPacketHandler();
  if (packetHandler instanceof TabListHandler) {
    ((TabListHandler)packetHandler).onDisconnected();
  }
}",0.9212218649517684
80842,"@Synchronized public PlayerTablistHandler getPlayerTablistHandler(){
  if (playerTablistHandler == null) {
    createTabListHandler();
  }
  return playerTablistHandler;
}","@Nullable public PlayerTablistHandler getPlayerTablistHandler(){
  return playerTablistHandler;
}",0.6716417910447762
80843,"public void onMessage(@Nonnull Player player,@Nonnull DataInput input) throws IOException {
  PlayerConnectionInfo connectionInfo=playerPlayerConnectionInfoMap.get(player);
  if (connectionInfo == null) {
    return;
  }
  int messageId=input.readUnsignedByte();
  if (messageId == BridgeProtocolConstants.MESSAGE_ID_INTRODUCE) {
    int proxyIdentifier=input.readInt();
    int protocolVersion=input.readInt();
    int minimumCompatibleProtocolVersion=input.readInt();
    String proxyPluginVersion=input.readUTF();
    int connectionId=proxyIdentifier + serverIdentifier;
    if (connectionId == connectionInfo.connectionIdentifier) {
      return;
    }
    if (BridgeProtocolConstants.VERSION < minimumCompatibleProtocolVersion) {
      throw new IOException(""String_Node_Str"" + proxyPluginVersion);
    }
    connectionInfo.connectionIdentifier=connectionId;
    connectionInfo.isConnectionValid=true;
    connectionInfo.nextIntroducePacketDelay=1;
    connectionInfo.introducePacketDelay=1;
    connectionInfo.hasReceived=false;
    connectionInfo.protocolVersion=Integer.min(BridgeProtocolConstants.VERSION,protocolVersion);
    connectionInfo.proxyIdentifier=proxyIdentifier;
    connectionInfo.playerBridgeData=new BridgeData();
    connectionInfo.serverBridgeData=serverBridgeDataMap.computeIfAbsent(proxyIdentifier,key -> new BridgeData());
    ByteArrayOutputStream byteArrayOutput=new ByteArrayOutputStream();
    DataOutput output=new DataOutputStream(byteArrayOutput);
    output.writeByte(BridgeProtocolConstants.MESSAGE_ID_ACK);
    output.writeInt(connectionId);
    output.writeInt(0);
    byte[] message=byteArrayOutput.toByteArray();
    sendMessage(player,message);
  }
 else {
    if (!connectionInfo.isConnectionValid) {
      return;
    }
    int connectionId=input.readInt();
    if (connectionId != connectionInfo.connectionIdentifier) {
      return;
    }
    connectionInfo.hasReceived=true;
    int sequenceNumber=input.readInt();
    BridgeData bridgeData;
    boolean isServerMessage;
    if ((messageId & 0x80) == 0) {
      bridgeData=connectionInfo.playerBridgeData;
      isServerMessage=false;
    }
 else {
      bridgeData=connectionInfo.serverBridgeData;
      isServerMessage=true;
    }
    if (bridgeData == null) {
      return;
    }
    messageId=messageId & 0x7f;
    if (messageId == BridgeProtocolConstants.MESSAGE_ID_ACK) {
      int confirmed=sequenceNumber - bridgeData.lastConfirmed;
      if (confirmed > bridgeData.messagesPendingConfirmation.size()) {
        return;
      }
      while (confirmed-- > 0) {
        bridgeData.lastConfirmed++;
        bridgeData.messagesPendingConfirmation.remove();
      }
    }
 else     if (messageId == BridgeProtocolConstants.MESSAGE_ID_REQUEST_DATA) {
      if (sequenceNumber > bridgeData.nextIncomingMessageId) {
        return;
      }
      ByteArrayOutputStream byteArrayOutput=new ByteArrayOutputStream();
      DataOutput output=new DataOutputStream(byteArrayOutput);
      output.writeByte(BridgeProtocolConstants.MESSAGE_ID_ACK | (isServerMessage ? 0x80 : 0x00));
      output.writeInt(connectionId);
      output.writeInt(sequenceNumber);
      byte[] message=byteArrayOutput.toByteArray();
      sendMessage(player,message);
      if (sequenceNumber < bridgeData.nextIncomingMessageId) {
        return;
      }
      bridgeData.nextIncomingMessageId++;
      int size=input.readInt();
      for (int i=0; i < size; i++) {
        DataKey<?> key=DataStreamUtils.readDataKey(input,dataKeyRegistry);
        int keyNetId=input.readInt();
        if (key != null) {
          bridgeData.addRequest(key,keyNetId);
        }
      }
      updatePlayerData(player,connectionInfo);
    }
 else {
      throw new IllegalArgumentException(""String_Node_Str"" + messageId);
    }
  }
}","public void onMessage(@Nonnull Player player,@Nonnull DataInput input) throws IOException {
  PlayerConnectionInfo connectionInfo=playerPlayerConnectionInfoMap.get(player);
  if (connectionInfo == null) {
    return;
  }
  int messageId=input.readUnsignedByte();
  if (messageId == BridgeProtocolConstants.MESSAGE_ID_INTRODUCE) {
    int proxyIdentifier=input.readInt();
    int protocolVersion=input.readInt();
    int minimumCompatibleProtocolVersion=input.readInt();
    String proxyPluginVersion=input.readUTF();
    int connectionId=proxyIdentifier + serverIdentifier;
    if (connectionId == connectionInfo.connectionIdentifier) {
      return;
    }
    if (BridgeProtocolConstants.VERSION < minimumCompatibleProtocolVersion) {
      throw new IOException(""String_Node_Str"" + proxyPluginVersion);
    }
    connectionInfo.connectionIdentifier=connectionId;
    connectionInfo.isConnectionValid=true;
    connectionInfo.nextIntroducePacketDelay=1;
    connectionInfo.introducePacketDelay=1;
    connectionInfo.hasReceived=false;
    connectionInfo.protocolVersion=Integer.min(BridgeProtocolConstants.VERSION,protocolVersion);
    connectionInfo.proxyIdentifier=proxyIdentifier;
    connectionInfo.playerBridgeData=new BridgeData();
    connectionInfo.serverBridgeData=serverBridgeDataMap.computeIfAbsent(proxyIdentifier,key -> new BridgeData());
    ByteArrayOutputStream byteArrayOutput=new ByteArrayOutputStream();
    DataOutput output=new DataOutputStream(byteArrayOutput);
    output.writeByte(BridgeProtocolConstants.MESSAGE_ID_ACK);
    output.writeInt(connectionId);
    output.writeInt(0);
    byte[] message=byteArrayOutput.toByteArray();
    sendMessage(player,message);
  }
 else {
    if (!connectionInfo.isConnectionValid) {
      return;
    }
    int connectionId=input.readInt();
    if (connectionId != connectionInfo.connectionIdentifier) {
      return;
    }
    connectionInfo.hasReceived=true;
    int sequenceNumber=input.readInt();
    BridgeData bridgeData;
    boolean isServerMessage;
    if ((messageId & 0x80) == 0) {
      bridgeData=connectionInfo.playerBridgeData;
      isServerMessage=false;
    }
 else {
      bridgeData=connectionInfo.serverBridgeData;
      isServerMessage=true;
    }
    if (bridgeData == null) {
      return;
    }
    messageId=messageId & 0x7f;
    if (messageId == BridgeProtocolConstants.MESSAGE_ID_ACK) {
      int confirmed=sequenceNumber - bridgeData.lastConfirmed;
      if (confirmed > bridgeData.messagesPendingConfirmation.size()) {
        return;
      }
      while (confirmed-- > 0) {
        bridgeData.lastConfirmed++;
        bridgeData.messagesPendingConfirmation.remove();
      }
    }
 else     if (messageId == BridgeProtocolConstants.MESSAGE_ID_REQUEST_DATA) {
      if (sequenceNumber > bridgeData.nextIncomingMessageId) {
        return;
      }
      ByteArrayOutputStream byteArrayOutput=new ByteArrayOutputStream();
      DataOutput output=new DataOutputStream(byteArrayOutput);
      output.writeByte(BridgeProtocolConstants.MESSAGE_ID_ACK | (isServerMessage ? 0x80 : 0x00));
      output.writeInt(connectionId);
      output.writeInt(sequenceNumber);
      byte[] message=byteArrayOutput.toByteArray();
      sendMessage(player,message);
      if (sequenceNumber < bridgeData.nextIncomingMessageId) {
        return;
      }
      bridgeData.nextIncomingMessageId++;
      int size=input.readInt();
      for (int i=0; i < size; i++) {
        DataKey<?> key=DataStreamUtils.readDataKey(input,dataKeyRegistry);
        int keyNetId=input.readInt();
        if (key != null) {
          bridgeData.addRequest(key,keyNetId);
        }
      }
      runAsync(() -> {
        try {
          updatePlayerData(player,connectionInfo);
        }
 catch (        IOException e) {
          e.printStackTrace();
        }
      }
);
    }
 else {
      throw new IllegalArgumentException(""String_Node_Str"" + messageId);
    }
  }
}",0.9727343547130616
80844,"@Listener public void onServerStart(GameStartedServerEvent event){
  game.getScheduler().createTaskBuilder().name(""String_Node_Str"").async().delay(1,TimeUnit.SECONDS).interval(1,TimeUnit.SECONDS).execute(() -> {
    try {
      bridge.updateData();
    }
 catch (    Throwable e) {
      rlExecutor.execute(() -> {
        logger.error(""String_Node_Str"",e);
      }
);
    }
  }
).submit(this);
  game.getScheduler().createTaskBuilder().name(""String_Node_Str"").async().delay(100,TimeUnit.MILLISECONDS).interval(100,TimeUnit.MILLISECONDS).execute(() -> {
    try {
      bridge.sendIntroducePackets();
    }
 catch (    Throwable e) {
      rlExecutor.execute(() -> {
        logger.error(""String_Node_Str"",e);
      }
);
    }
  }
).submit(this);
  game.getScheduler().createTaskBuilder().name(""String_Node_Str"").async().delay(2500,TimeUnit.MILLISECONDS).interval(2500,TimeUnit.MILLISECONDS).execute(() -> {
    try {
      bridge.resendUnconfirmedMessages();
    }
 catch (    Throwable e) {
      rlExecutor.execute(() -> {
        logger.error(""String_Node_Str"",e);
      }
);
    }
  }
).submit(this);
  game.getScheduler().createTaskBuilder().name(""String_Node_Str"").delay(24,TimeUnit.HOURS).interval(24,TimeUnit.HOURS).execute(() -> {
    try {
      initBridge();
      for (      Player player : game.getServer().getOnlinePlayers()) {
        bridge.onPlayerConnect(player);
      }
    }
 catch (    Throwable e) {
      rlExecutor.execute(() -> {
        logger.error(""String_Node_Str"",e);
      }
);
    }
  }
).submit(this);
}","@Listener public void onServerStart(GameStartedServerEvent event){
  asyncExecutor=game.getScheduler().createAsyncExecutor(this);
  game.getScheduler().createTaskBuilder().name(""String_Node_Str"").async().delay(1,TimeUnit.SECONDS).interval(1,TimeUnit.SECONDS).execute(() -> {
    try {
      bridge.updateData();
    }
 catch (    Throwable e) {
      rlExecutor.execute(() -> {
        logger.error(""String_Node_Str"",e);
      }
);
    }
  }
).submit(this);
  game.getScheduler().createTaskBuilder().name(""String_Node_Str"").async().delay(100,TimeUnit.MILLISECONDS).interval(100,TimeUnit.MILLISECONDS).execute(() -> {
    try {
      bridge.sendIntroducePackets();
    }
 catch (    Throwable e) {
      rlExecutor.execute(() -> {
        logger.error(""String_Node_Str"",e);
      }
);
    }
  }
).submit(this);
  game.getScheduler().createTaskBuilder().name(""String_Node_Str"").async().delay(2500,TimeUnit.MILLISECONDS).interval(2500,TimeUnit.MILLISECONDS).execute(() -> {
    try {
      bridge.resendUnconfirmedMessages();
    }
 catch (    Throwable e) {
      rlExecutor.execute(() -> {
        logger.error(""String_Node_Str"",e);
      }
);
    }
  }
).submit(this);
  game.getScheduler().createTaskBuilder().name(""String_Node_Str"").delay(24,TimeUnit.HOURS).interval(24,TimeUnit.HOURS).execute(() -> {
    try {
      initBridge();
      for (      Player player : game.getServer().getOnlinePlayers()) {
        bridge.onPlayerConnect(player);
      }
    }
 catch (    Throwable e) {
      rlExecutor.execute(() -> {
        logger.error(""String_Node_Str"",e);
      }
);
    }
  }
).submit(this);
}",0.9799299139853456
80845,"private PacketListenerResult onPlayerListPacketInternal(PlayerListItem packet){
switch (packet.getAction()) {
case ADD_PLAYER:
    for (    PlayerListItem.Item item : packet.getItems()) {
      if (fakePlayerUUIDSet.contains(item.getUuid())) {
        throw new AssertionError(""String_Node_Str"" + item);
      }
      if (fakePlayerUsernameSet.contains(item.getUsername())) {
        throw new AssertionError(""String_Node_Str"" + item);
      }
      serverTabList.put(item.getUuid(),new TabListItem(item));
    }
  break;
case UPDATE_GAMEMODE:
for (PlayerListItem.Item item : packet.getItems()) {
  TabListItem tabListItem=serverTabList.get(item.getUuid());
  if (tabListItem != null) {
    tabListItem.setGamemode(item.getGamemode());
  }
}
break;
case UPDATE_LATENCY:
for (PlayerListItem.Item item : packet.getItems()) {
TabListItem tabListItem=serverTabList.get(item.getUuid());
if (tabListItem != null) {
tabListItem.setPing(item.getPing());
}
}
break;
case UPDATE_DISPLAY_NAME:
for (PlayerListItem.Item item : packet.getItems()) {
TabListItem tabListItem=serverTabList.get(item.getUuid());
if (tabListItem != null) {
tabListItem.setDisplayName(item.getDisplayName());
}
}
break;
case REMOVE_PLAYER:
for (PlayerListItem.Item item : packet.getItems()) {
serverTabList.remove(item.getUuid());
}
break;
}
if (serverTabList.size() > size) {
if (resizePolicy.isMod20()) {
setSizeInternal(min(((serverTabList.size() + 19) / 20) * 20,80));
}
 else {
setSizeInternal(min(serverTabList.size(),80));
}
}
if (passtrough || size == 80) {
sendPacket(packet);
return PacketListenerResult.CANCEL;
}
switch (packet.getAction()) {
case ADD_PLAYER:
for (PlayerListItem.Item item : packet.getItems()) {
if (item.getGamemode() == 3 && item.getUuid().equals(getUniqueId())) {
int slot=uuidToSlotMap.getInt(item.getUuid());
if (slot != -1) {
if (slot != size - 1) {
useFakePlayerForSlot(slot);
slot=size - 1;
if (clientUuid[slot] != fakePlayerUUIDs[slot]) {
int targetSlot=findSlotForPlayer(clientUuid[slot]);
useRealPlayerForSlot(targetSlot,clientUuid[slot]);
}
useRealPlayerForSlot(slot,item.getUuid());
}
 else {
useRealPlayerForSlot(slot,item.getUuid());
}
}
 else {
slot=size - 1;
if (clientUuid[slot] != fakePlayerUUIDs[slot]) {
int targetSlot=findSlotForPlayer(clientUuid[slot]);
useRealPlayerForSlot(targetSlot,clientUuid[slot]);
}
useRealPlayerForSlot(slot,item.getUuid());
}
}
 else {
item.setGamemode(0);
int slot;
if (-1 != (slot=uuidToSlotMap.getInt(item.getUuid())) && !skinUuidToSlotMap.contains(item.getUuid(),-1)) {
useFakePlayerForSlot(slot);
}
if (slot != -1) {
useRealPlayerForSlot(slot,item.getUuid());
}
 else {
slot=findSlotForPlayer(item.getUuid());
useRealPlayerForSlot(slot,item.getUuid());
}
}
}
break;
case UPDATE_GAMEMODE:
for (PlayerListItem.Item item : packet.getItems()) {
if (!serverTabList.containsKey(item.getUuid())) {
continue;
}
if (item.getUuid().equals(getUniqueId())) {
int slot=uuidToSlotMap.getInt(item.getUuid());
if (item.getGamemode() == 3 && slot != size - 1) {
useFakePlayerForSlot(slot);
slot=size - 1;
if (clientUuid[slot] != fakePlayerUUIDs[slot]) {
int targetSlot=findSlotForPlayer(clientUuid[slot]);
useRealPlayerForSlot(targetSlot,clientUuid[slot]);
}
useRealPlayerForSlot(slot,item.getUuid());
}
 else if (item.getGamemode() != 3 && slot == size - 1) {
useFakePlayerForSlot(size - 1);
useRealPlayerForSlot(findSlotForPlayer(getUniqueId()),getUniqueId());
}
}
}
break;
case REMOVE_PLAYER:
sendPacket(packet);
for (PlayerListItem.Item item : packet.getItems()) {
int slot=uuidToSlotMap.getInt(item.getUuid());
if (-1 != slot) {
useFakePlayerForSlot(slot);
}
}
break;
case UPDATE_LATENCY:
case UPDATE_DISPLAY_NAME:
break;
}
if (size != requestedSize && serverTabList.size() < requestedSize) {
setSizeInternal(requestedSize);
}
return PacketListenerResult.CANCEL;
}","private PacketListenerResult onPlayerListPacketInternal(PlayerListItem packet){
switch (packet.getAction()) {
case ADD_PLAYER:
    for (    PlayerListItem.Item item : packet.getItems()) {
      if (fakePlayerUUIDSet.contains(item.getUuid())) {
        throw new AssertionError(""String_Node_Str"" + item);
      }
      if (fakePlayerUsernameSet.contains(item.getUsername())) {
        throw new AssertionError(""String_Node_Str"" + item);
      }
      serverTabList.put(item.getUuid(),new TabListItem(item));
    }
  break;
case UPDATE_GAMEMODE:
for (PlayerListItem.Item item : packet.getItems()) {
  TabListItem tabListItem=serverTabList.get(item.getUuid());
  if (tabListItem != null) {
    tabListItem.setGamemode(item.getGamemode());
  }
}
break;
case UPDATE_LATENCY:
for (PlayerListItem.Item item : packet.getItems()) {
TabListItem tabListItem=serverTabList.get(item.getUuid());
if (tabListItem != null) {
tabListItem.setPing(item.getPing());
}
}
break;
case UPDATE_DISPLAY_NAME:
for (PlayerListItem.Item item : packet.getItems()) {
TabListItem tabListItem=serverTabList.get(item.getUuid());
if (tabListItem != null) {
tabListItem.setDisplayName(item.getDisplayName());
}
}
break;
case REMOVE_PLAYER:
for (PlayerListItem.Item item : packet.getItems()) {
serverTabList.remove(item.getUuid());
}
break;
}
if (serverTabList.size() > size) {
if (resizePolicy.isMod20()) {
setSizeInternal(min(((serverTabList.size() + 19) / 20) * 20,80));
}
 else {
setSizeInternal(min(serverTabList.size(),80));
}
}
if (passtrough || size == 80) {
sendPacket(packet);
return PacketListenerResult.CANCEL;
}
switch (packet.getAction()) {
case ADD_PLAYER:
for (PlayerListItem.Item item : packet.getItems()) {
if (item.getGamemode() == 3 && item.getUuid().equals(getUniqueId())) {
int slot=uuidToSlotMap.getInt(item.getUuid());
if (slot != -1) {
if (slot != size - 1) {
useFakePlayerForSlot(slot);
slot=size - 1;
if (clientUuid[slot] != fakePlayerUUIDs[slot]) {
int targetSlot=findSlotForPlayer(clientUuid[slot]);
useRealPlayerForSlot(targetSlot,clientUuid[slot]);
}
useRealPlayerForSlot(slot,item.getUuid());
}
 else {
useRealPlayerForSlot(slot,item.getUuid());
}
}
 else {
slot=size - 1;
if (clientUuid[slot] != fakePlayerUUIDs[slot]) {
int targetSlot=findSlotForPlayer(clientUuid[slot]);
useRealPlayerForSlot(targetSlot,clientUuid[slot]);
}
useRealPlayerForSlot(slot,item.getUuid());
}
}
 else {
item.setGamemode(0);
int slot;
if (-1 != (slot=uuidToSlotMap.getInt(item.getUuid())) && !skinUuidToSlotMap.contains(item.getUuid(),-1)) {
useFakePlayerForSlot(slot);
}
if (slot != -1) {
useRealPlayerForSlot(slot,item.getUuid());
}
 else {
slot=findSlotForPlayer(item.getUuid());
useRealPlayerForSlot(slot,item.getUuid());
}
}
}
break;
case UPDATE_GAMEMODE:
for (PlayerListItem.Item item : packet.getItems()) {
if (!serverTabList.containsKey(item.getUuid())) {
continue;
}
if (item.getUuid().equals(getUniqueId())) {
int slot=uuidToSlotMap.getInt(item.getUuid());
if (item.getGamemode() == 3 && slot != size - 1) {
useFakePlayerForSlot(slot);
slot=size - 1;
if (clientUuid[slot] != fakePlayerUUIDs[slot]) {
int targetSlot=findSlotForPlayer(clientUuid[slot]);
useRealPlayerForSlot(targetSlot,clientUuid[slot]);
}
useRealPlayerForSlot(slot,item.getUuid());
}
 else if (item.getGamemode() != 3 && slot == size - 1) {
useFakePlayerForSlot(size - 1);
useRealPlayerForSlot(findSlotForPlayer(getUniqueId()),getUniqueId());
}
 else {
PlayerListItem packetOut=new PlayerListItem();
packetOut.setAction(UPDATE_GAMEMODE);
packetOut.setItems(new PlayerListItem.Item[]{item});
sendPacket(packetOut);
}
}
}
break;
case REMOVE_PLAYER:
sendPacket(packet);
for (PlayerListItem.Item item : packet.getItems()) {
int slot=uuidToSlotMap.getInt(item.getUuid());
if (-1 != slot) {
useFakePlayerForSlot(slot);
}
}
break;
case UPDATE_LATENCY:
case UPDATE_DISPLAY_NAME:
break;
}
if (size != requestedSize && serverTabList.size() < requestedSize) {
setSizeInternal(requestedSize);
}
return PacketListenerResult.CANCEL;
}",0.977983777520278
80846,"@Test public void testSelfGamemode3Size0(){
  assertEquals(0,clientTabList.getSize());
  tabListHandler.setResizePolicy(PlayerTablistHandler.ResizePolicy.DYNAMIC);
  tabListHandler.setPassThrough(false);
  assertEquals(0,clientTabList.getSize());
  PlayerListItem packet=new PlayerListItem();
  packet.setAction(PlayerListItem.Action.ADD_PLAYER);
  PlayerListItem.Item item=new PlayerListItem.Item();
  item.setUsername(usernames[47]);
  item.setUuid(clientUUID);
  item.setPing(47);
  item.setProperties(new String[0][]);
  item.setGamemode(3);
  packet.setItems(new PlayerListItem.Item[]{item});
  tabListHandler.onPlayerListPacket(packet);
  packet.setAction(PlayerListItem.Action.UPDATE_GAMEMODE);
  assertEquals(1,clientTabList.getSize());
  assertEquals(clientUUID,clientTabList.getVisibleEntries().get(0).getUuid());
}","@Test public void testSelfGamemode3Size0(){
  assertEquals(0,clientTabList.getSize());
  tabListHandler.setResizePolicy(PlayerTablistHandler.ResizePolicy.DYNAMIC);
  tabListHandler.setPassThrough(false);
  assertEquals(0,clientTabList.getSize());
  PlayerListItem packet=new PlayerListItem();
  packet.setAction(PlayerListItem.Action.ADD_PLAYER);
  PlayerListItem.Item item=new PlayerListItem.Item();
  item.setUsername(usernames[47]);
  item.setUuid(clientUUID);
  item.setPing(47);
  item.setProperties(new String[0][]);
  item.setGamemode(3);
  packet.setItems(new PlayerListItem.Item[]{item});
  tabListHandler.onPlayerListPacket(packet);
  assertEquals(1,clientTabList.getSize());
  assertEquals(clientUUID,clientTabList.getVisibleEntries().get(0).getUuid());
}",0.96291640477687
80847,"public void setSize(int size){
  resize(size);
  clientSize=size;
}","public void setSize(int size){
  if (!passThrough) {
    resize(size);
  }
  clientSize=size;
}",0.8271604938271605
80848,"private void resize(int size){
  Preconditions.checkArgument(size >= 0 && size <= this.maxSize,""String_Node_Str"");
  if (!passThrough) {
    if (size > usedSlots) {
      for (int i=usedSlots; i < size; i++) {
        createSlot(i);
      }
    }
 else     if (size < usedSlots) {
      for (int i=size; i < usedSlots; i++) {
        removeSlot(i);
      }
    }
    usedSlots=size;
  }
}","private void resize(int size){
  Preconditions.checkArgument(size >= 0 && size <= this.maxSize,""String_Node_Str"");
  if (size > usedSlots) {
    for (int i=usedSlots; i < size; i++) {
      createSlot(i);
    }
  }
 else   if (size < usedSlots) {
    for (int i=size; i < usedSlots; i++) {
      removeSlot(i);
    }
  }
  usedSlots=size;
}",0.8351648351648352
80849,"@Override public void run(){
  if (activeComponent != -1) {
synchronized (context.get(Context.KEY_TAB_LIST)) {
      frames.get(activeComponent).deactivate();
      activeComponent++;
      if (activeComponent >= frames.size()) {
        activeComponent=0;
      }
      Component.Instance component=frames.get(activeComponent);
      component.activate();
      component.update1stStep();
      component.setPosition(leftMostColumn,row,column,size);
      component.update2ndStep();
    }
  }
}","@Override public void run(){
  if (activeComponent != -1) {
synchronized (context.get(Context.KEY_TAB_LIST)) {
      if (activeComponent != -1) {
        frames.get(activeComponent).deactivate();
        activeComponent++;
        if (activeComponent >= frames.size()) {
          activeComponent=0;
        }
        Component.Instance component=frames.get(activeComponent);
        component.activate();
        component.update1stStep();
        component.setPosition(leftMostColumn,row,column,size);
        component.update2ndStep();
      }
    }
  }
}",0.8983855650522318
80850,"@Override public void run(){
  if (activeComponent != -1) {
synchronized (context.get(Context.KEY_TAB_LIST)) {
      frames.get(activeComponent).deactivate();
      activeComponent++;
      if (activeComponent >= frames.size()) {
        activeComponent=0;
      }
      Component.Instance component=frames.get(activeComponent);
      component.activate();
      component.update1stStep();
      component.setPosition(row,column,size);
      component.update2ndStep();
    }
  }
}","@Override public void run(){
  if (activeComponent != -1) {
synchronized (context.get(Context.KEY_TAB_LIST)) {
      frames.get(activeComponent).deactivate();
      activeComponent++;
      if (activeComponent >= frames.size()) {
        activeComponent=0;
      }
      Component.Instance component=frames.get(activeComponent);
      component.activate();
      component.update1stStep();
      component.setPosition(leftMostColumn,row,column,size);
      component.update2ndStep();
    }
  }
}",0.9846153846153848
80851,"@Override public void update2ndStep(){
  super.update2ndStep();
synchronized (context.get(Context.KEY_TAB_LIST)) {
    if (activeComponent == -1) {
      activeComponent=0;
      Component.Instance component=frames.get(0);
      component.activate();
      component.update1stStep();
      component.setPosition(row,column,size);
      component.update2ndStep();
    }
 else {
      Component.Instance component=frames.get(activeComponent);
      component.update1stStep();
      component.setPosition(row,column,size);
      component.update2ndStep();
    }
  }
}","@Override public void update2ndStep(){
  super.update2ndStep();
synchronized (context.get(Context.KEY_TAB_LIST)) {
    if (activeComponent == -1) {
      activeComponent=0;
      Component.Instance component=frames.get(0);
      component.activate();
      component.update1stStep();
      component.setPosition(leftMostColumn,row,column,size);
      component.update2ndStep();
    }
 else {
      Component.Instance component=frames.get(activeComponent);
      component.update1stStep();
      component.setPosition(leftMostColumn,row,column,size);
      component.update2ndStep();
    }
  }
}",0.9740932642487048
80852,"public final void setPosition(int row,int column,int size){
  hasValidPosition=true;
  this.row=row;
  this.column=column;
  this.size=size;
}","public final void setPosition(int leftMostColumn,int row,int column,int size){
  hasValidPosition=true;
  this.leftMostColumn=leftMostColumn;
  this.row=row;
  this.column=column;
  this.size=size;
}",0.8328445747800587
80853,"protected void setSlot(int n,Icon icon,String text,int ping){
  if (active && hasValidPosition && n < size) {
    context.get(Context.KEY_TAB_LIST).setSlot(row + n / context.get(Context.KEY_COLUMNS),column + n % context.get(Context.KEY_COLUMNS),icon,text,ping);
  }
}","protected void setSlot(int row,int column,Icon icon,String text,int ping){
  if (active && hasValidPosition && row * context.get(Context.KEY_COLUMNS) + column < size) {
    context.get(Context.KEY_TAB_LIST).setSlot(this.row + row,this.column + column,icon,text,ping);
  }
}",0.7185185185185186
80854,"@Override public void update2ndStep(){
  super.update2ndStep();
  component.setPosition(row,column,size);
  component.update2ndStep();
}","@Override public void update2ndStep(){
  super.update2ndStep();
  component.setPosition(leftMostColumn,row,column,size);
  component.update2ndStep();
}",0.9477351916376306
80855,"void updateLayout() throws LayoutException {
  int[] sectionSize=new int[components.size()];
  for (int i=0; i < components.size(); i++) {
    sectionSize[i]=components.get(i).getMinSize();
  }
  int sizeNeeded=0;
  for (int i=0; i < components.size(); i++) {
    Component.Instance component=components.get(i);
    if (component.isBlockAligned()) {
      sizeNeeded=((sizeNeeded + context.get(Context.KEY_COLUMNS) - 1) / context.get(Context.KEY_COLUMNS)) * context.get(Context.KEY_COLUMNS);
    }
    sizeNeeded+=sectionSize[i];
  }
  if (sizeNeeded > size) {
    throw new LayoutException(String.format(""String_Node_Str"",sizeNeeded,size));
  }
  boolean repeat;
  boolean max=false;
  do {
    repeat=false;
    for (int i=0; i < components.size(); i++) {
      Component.Instance component=components.get(i);
      int oldSectionSize=sectionSize[i];
      if (oldSectionSize >= (max ? component.getMaxSize() : component.getPreferredSize())) {
        continue;
      }
      sectionSize[i]+=component.isBlockAligned() ? context.get(Context.KEY_COLUMNS) : 1;
      sizeNeeded=0;
      for (int j=0; j < components.size(); j++) {
        Component.Instance component1=components.get(j);
        if (component1.isBlockAligned()) {
          sizeNeeded=((sizeNeeded + context.get(Context.KEY_COLUMNS) - 1) / context.get(Context.KEY_COLUMNS)) * context.get(Context.KEY_COLUMNS);
        }
        sizeNeeded+=sectionSize[j];
      }
      if (sizeNeeded <= size) {
        repeat=true;
      }
 else {
        sectionSize[i]=oldSectionSize;
      }
    }
    if (!repeat && !max) {
      max=true;
      repeat=true;
    }
  }
 while (repeat);
  int pos=0;
  for (int i=0; i < components.size(); i++) {
    Component.Instance component=components.get(i);
    if (component.isBlockAligned()) {
      pos=((pos + context.get(Context.KEY_COLUMNS) - 1) / context.get(Context.KEY_COLUMNS)) * context.get(Context.KEY_COLUMNS);
    }
    component.setPosition(row + (pos / context.get(Context.KEY_COLUMNS)),column + (pos % context.get(Context.KEY_COLUMNS)),sectionSize[i]);
    pos+=sectionSize[i];
  }
}","void updateLayout() throws LayoutException {
  int[] sectionSize=new int[components.size()];
  for (int i=0; i < components.size(); i++) {
    sectionSize[i]=components.get(i).getMinSize();
  }
  int sizeNeeded=0;
  for (int i=0; i < components.size(); i++) {
    Component.Instance component=components.get(i);
    if (component.isBlockAligned()) {
      sizeNeeded=((sizeNeeded + context.get(Context.KEY_COLUMNS) - 1) / context.get(Context.KEY_COLUMNS)) * context.get(Context.KEY_COLUMNS);
    }
    sizeNeeded+=sectionSize[i];
  }
  if (sizeNeeded > size) {
    throw new LayoutException(String.format(""String_Node_Str"",sizeNeeded,size));
  }
  boolean repeat;
  boolean max=false;
  do {
    repeat=false;
    for (int i=0; i < components.size(); i++) {
      Component.Instance component=components.get(i);
      int oldSectionSize=sectionSize[i];
      if (oldSectionSize >= (max ? component.getMaxSize() : component.getPreferredSize())) {
        continue;
      }
      sectionSize[i]+=component.isBlockAligned() ? context.get(Context.KEY_COLUMNS) : 1;
      sizeNeeded=0;
      for (int j=0; j < components.size(); j++) {
        Component.Instance component1=components.get(j);
        if (component1.isBlockAligned()) {
          sizeNeeded=((sizeNeeded + context.get(Context.KEY_COLUMNS) - 1) / context.get(Context.KEY_COLUMNS)) * context.get(Context.KEY_COLUMNS);
        }
        sizeNeeded+=sectionSize[j];
      }
      if (sizeNeeded <= size) {
        repeat=true;
      }
 else {
        sectionSize[i]=oldSectionSize;
      }
    }
    if (!repeat && !max) {
      max=true;
      repeat=true;
    }
  }
 while (repeat);
  int pos=0;
  for (int i=0; i < components.size(); i++) {
    Component.Instance component=components.get(i);
    if (component.isBlockAligned()) {
      pos=((pos + context.get(Context.KEY_COLUMNS) - 1) / context.get(Context.KEY_COLUMNS)) * context.get(Context.KEY_COLUMNS);
    }
    component.setPosition(leftMostColumn,row + (pos / context.get(Context.KEY_COLUMNS)),column + (pos % context.get(Context.KEY_COLUMNS)),sectionSize[i]);
    pos+=sectionSize[i];
  }
}",0.9964328180737216
80856,"@Override public void update2ndStep(){
  activeComponents.forEach(Component.Instance::deactivate);
  activeComponents.clear();
  super.update2ndStep();
  int rows=size / context.get(Context.KEY_COLUMNS);
  int minRowsPerServer=(minSizePerServer + context.get(Context.KEY_COLUMNS) - 1) / context.get(Context.KEY_COLUMNS);
  int maxRowsPerServer=maxSizePerServer / context.get(Context.KEY_COLUMNS);
  List<String> servers=new ArrayList<>(playersByServer.keySet());
  Collections.sort(servers);
  int[] serverRows=new int[servers.size()];
  Arrays.fill(serverRows,minRowsPerServer);
  rows-=minRowsPerServer * servers.size();
  if (serverSeparator != null && playersByServer.size() > 1) {
    rows-=((serverSeparator.getSize() + context.get(Context.KEY_COLUMNS) - 1) / context.get(Context.KEY_COLUMNS)) * (playersByServer.size() - 1);
  }
  boolean change;
  do {
    change=false;
    for (int i=0; i < servers.size(); i++) {
      if (rows > 0 && serverRows[i] < maxRowsPerServer) {
        String server=servers.get(i);
        int serverSize=serverHeader.getSize() + playersByServer.get(server).size() * playerComponent.getSize() + (serverFooter != null ? serverFooter.getSize() : 0);
        if (min(serverSize,maxRowsPerServer) > serverRows[i] * context.get(Context.KEY_COLUMNS)) {
          serverRows[i]++;
          change=true;
          rows--;
        }
      }
    }
  }
 while (rows > 0 && change);
  int pos=0;
  for (int i=0; i < servers.size() && pos < size; i++) {
    if (serverSeparator != null && i > 0) {
      pos=((pos + context.get(Context.KEY_COLUMNS) - 1) / context.get(Context.KEY_COLUMNS)) * context.get(Context.KEY_COLUMNS);
      Component.Instance separator=serverSeparator.toInstance(context);
      separator.activate();
      separator.update1stStep();
      separator.setPosition(row + (pos / context.get(Context.KEY_COLUMNS)),column,serverSeparator.getSize());
      separator.update2ndStep();
      activeComponents.add(separator);
      pos+=serverSeparator.getSize();
    }
    String server=servers.get(i);
    pos=((pos + context.get(Context.KEY_COLUMNS) - 1) / context.get(Context.KEY_COLUMNS)) * context.get(Context.KEY_COLUMNS);
    List<Player> players=playersByServer.get(server);
    Context serverContext=context.derived().put(Context.KEY_SERVER,server).put(Context.KEY_SERVER_PLAYER_COUNT,players.size());
    Component.Instance header=serverHeader.toInstance(serverContext);
    header.activate();
    header.update1stStep();
    header.setPosition(row + (pos / context.get(Context.KEY_COLUMNS)),column,serverHeader.getSize());
    header.update2ndStep();
    activeComponents.add(header);
    pos+=serverHeader.getSize();
    int playersMaxSize=playersByServer.get(server).size() * playerComponent.getSize();
    int serverSize=min(serverRows[i] * context.get(Context.KEY_COLUMNS) - serverHeader.getSize() - (serverFooter != null ? serverFooter.getSize() : 0),playersMaxSize);
    boolean allFit=serverSize >= playersMaxSize;
    int j;
    int pos2=0;
    for (j=0; (allFit || pos2 + morePlayersComponent.getSize() < serverSize) && j < players.size(); j++) {
      Player player=players.get(j);
      Component.Instance component=playerComponent.toInstance(serverContext.derived().put(Context.KEY_PLAYER,player));
      component.activate();
      component.update1stStep();
      component.setPosition(row + ((pos + pos2) / context.get(Context.KEY_COLUMNS)),column + ((pos + pos2) % context.get(Context.KEY_COLUMNS)),playerComponent.getSize());
      component.update2ndStep();
      activeComponents.add(component);
      pos2+=playerComponent.getSize();
    }
    if (!allFit) {
      Component.Instance component=morePlayersComponent.toInstance(serverContext.derived().put(Context.KEY_OTHER_PLAYERS_COUNT,players.size() - j));
      component.activate();
      component.update1stStep();
      component.setPosition(row + ((pos + pos2) / context.get(Context.KEY_COLUMNS)),column + ((pos + pos2) % context.get(Context.KEY_COLUMNS)),morePlayersComponent.getSize());
      component.update2ndStep();
      activeComponents.add(component);
      pos2+=morePlayersComponent.getSize();
    }
    if (serverFooter != null) {
      pos+=serverSize;
      Component.Instance footer=serverFooter.toInstance(serverContext);
      footer.activate();
      footer.update1stStep();
      footer.setPosition(row + (pos / context.get(Context.KEY_COLUMNS)),column + (pos % context.get(Context.KEY_COLUMNS)),serverFooter.getSize());
      footer.update2ndStep();
      activeComponents.add(footer);
      pos+=serverFooter.getSize();
    }
 else {
      pos+=pos2;
    }
  }
}","@Override public void update2ndStep(){
  activeComponents.forEach(Component.Instance::deactivate);
  activeComponents.clear();
  super.update2ndStep();
  int rows=size / context.get(Context.KEY_COLUMNS);
  int minRowsPerServer=(minSizePerServer + context.get(Context.KEY_COLUMNS) - 1) / context.get(Context.KEY_COLUMNS);
  int maxRowsPerServer=maxSizePerServer / context.get(Context.KEY_COLUMNS);
  List<String> servers=new ArrayList<>(playersByServer.keySet());
  Collections.sort(servers);
  int[] serverRows=new int[servers.size()];
  Arrays.fill(serverRows,minRowsPerServer);
  rows-=minRowsPerServer * servers.size();
  if (serverSeparator != null && playersByServer.size() > 1) {
    rows-=((serverSeparator.getSize() + context.get(Context.KEY_COLUMNS) - 1) / context.get(Context.KEY_COLUMNS)) * (playersByServer.size() - 1);
  }
  boolean change;
  do {
    change=false;
    for (int i=0; i < servers.size(); i++) {
      if (rows > 0 && serverRows[i] < maxRowsPerServer) {
        String server=servers.get(i);
        int serverSize=serverHeader.getSize() + playersByServer.get(server).size() * playerComponent.getSize() + (serverFooter != null ? serverFooter.getSize() : 0);
        if (min(serverSize,maxRowsPerServer) > serverRows[i] * context.get(Context.KEY_COLUMNS)) {
          serverRows[i]++;
          change=true;
          rows--;
        }
      }
    }
  }
 while (rows > 0 && change);
  int pos=0;
  for (int i=0; i < servers.size() && pos < size; i++) {
    if (serverSeparator != null && i > 0) {
      pos=((pos + context.get(Context.KEY_COLUMNS) - 1) / context.get(Context.KEY_COLUMNS)) * context.get(Context.KEY_COLUMNS);
      Component.Instance separator=serverSeparator.toInstance(context);
      separator.activate();
      separator.update1stStep();
      separator.setPosition(leftMostColumn,row + (pos / context.get(Context.KEY_COLUMNS)),column,serverSeparator.getSize());
      separator.update2ndStep();
      activeComponents.add(separator);
      pos+=serverSeparator.getSize();
    }
    String server=servers.get(i);
    pos=((pos + context.get(Context.KEY_COLUMNS) - 1) / context.get(Context.KEY_COLUMNS)) * context.get(Context.KEY_COLUMNS);
    List<Player> players=playersByServer.get(server);
    Context serverContext=context.derived().put(Context.KEY_SERVER,server).put(Context.KEY_SERVER_PLAYER_COUNT,players.size());
    Component.Instance header=serverHeader.toInstance(serverContext);
    header.activate();
    header.update1stStep();
    header.setPosition(leftMostColumn,row + (pos / context.get(Context.KEY_COLUMNS)),column,serverHeader.getSize());
    header.update2ndStep();
    activeComponents.add(header);
    pos+=serverHeader.getSize();
    int playersMaxSize=playersByServer.get(server).size() * playerComponent.getSize();
    int serverSize=min(serverRows[i] * context.get(Context.KEY_COLUMNS) - serverHeader.getSize() - (serverFooter != null ? serverFooter.getSize() : 0),playersMaxSize);
    boolean allFit=serverSize >= playersMaxSize;
    int j;
    int pos2=0;
    for (j=0; (allFit || pos2 + morePlayersComponent.getSize() < serverSize) && j < players.size(); j++) {
      Player player=players.get(j);
      Component.Instance component=playerComponent.toInstance(serverContext.derived().put(Context.KEY_PLAYER,player));
      component.activate();
      component.update1stStep();
      component.setPosition(leftMostColumn,row + ((pos + pos2) / context.get(Context.KEY_COLUMNS)),leftMostColumn + ((pos + pos2) % context.get(Context.KEY_COLUMNS)),playerComponent.getSize());
      component.update2ndStep();
      activeComponents.add(component);
      pos2+=playerComponent.getSize();
    }
    if (!allFit) {
      Component.Instance component=morePlayersComponent.toInstance(serverContext.derived().put(Context.KEY_OTHER_PLAYERS_COUNT,players.size() - j));
      component.activate();
      component.update1stStep();
      component.setPosition(leftMostColumn,row + ((pos + pos2) / context.get(Context.KEY_COLUMNS)),leftMostColumn + ((pos + pos2) % context.get(Context.KEY_COLUMNS)),morePlayersComponent.getSize());
      component.update2ndStep();
      activeComponents.add(component);
      pos2+=morePlayersComponent.getSize();
    }
    if (serverFooter != null) {
      pos+=serverSize;
      Component.Instance footer=serverFooter.toInstance(serverContext);
      footer.activate();
      footer.update1stStep();
      footer.setPosition(leftMostColumn,row + (pos / context.get(Context.KEY_COLUMNS)),leftMostColumn + (pos % context.get(Context.KEY_COLUMNS)),serverFooter.getSize());
      footer.update2ndStep();
      activeComponents.add(footer);
      pos+=serverFooter.getSize();
    }
 else {
      pos+=pos2;
    }
  }
}",0.9887375308377132
80857,"@Override public void update2ndStep(){
  activeComponents.forEach(Component.Instance::deactivate);
  activeComponents.clear();
  super.update2ndStep();
  boolean allFit=super.size >= players.size() * playerComponent.getSize();
  int pos=0;
  int i;
  for (i=0; (allFit || pos + playerComponent.getSize() + morePlayersComponent.getSize() <= super.size) && i < players.size(); i++) {
    Player player=players.get(i);
    Component.Instance component=playerComponent.toInstance(context.derived().put(Context.KEY_PLAYER,player));
    component.activate();
    component.update1stStep();
    component.setPosition(row + (pos / context.get(Context.KEY_COLUMNS)),column + (pos % context.get(Context.KEY_COLUMNS)),playerComponent.getSize());
    component.update2ndStep();
    activeComponents.add(component);
    pos+=playerComponent.getSize();
  }
  if (!allFit) {
    Component.Instance component=morePlayersComponent.toInstance(context.derived().put(Context.KEY_OTHER_PLAYERS_COUNT,players.size() - i));
    component.activate();
    component.update1stStep();
    component.setPosition(row + (pos / context.get(Context.KEY_COLUMNS)),column + (pos % context.get(Context.KEY_COLUMNS)),morePlayersComponent.getSize());
    component.update2ndStep();
    activeComponents.add(component);
  }
}","@Override public void update2ndStep(){
  activeComponents.forEach(Component.Instance::deactivate);
  activeComponents.clear();
  super.update2ndStep();
  boolean allFit=super.size >= players.size() * playerComponent.getSize();
  int offset=column - leftMostColumn;
  int pos=offset;
  int i;
  for (i=0; (allFit || pos + playerComponent.getSize() + morePlayersComponent.getSize() - offset <= super.size) && i < players.size(); i++) {
    Player player=players.get(i);
    Component.Instance component=playerComponent.toInstance(context.derived().put(Context.KEY_PLAYER,player));
    component.activate();
    component.update1stStep();
    component.setPosition(leftMostColumn,row + (pos / context.get(Context.KEY_COLUMNS)),leftMostColumn + (pos % context.get(Context.KEY_COLUMNS)),playerComponent.getSize());
    component.update2ndStep();
    activeComponents.add(component);
    pos+=playerComponent.getSize();
  }
  if (!allFit) {
    Component.Instance component=morePlayersComponent.toInstance(context.derived().put(Context.KEY_OTHER_PLAYERS_COUNT,players.size() - i));
    component.activate();
    component.update1stStep();
    component.setPosition(leftMostColumn,row + (pos / context.get(Context.KEY_COLUMNS)),leftMostColumn + (pos % context.get(Context.KEY_COLUMNS)),morePlayersComponent.getSize());
    component.update2ndStep();
    activeComponents.add(component);
  }
}",0.9438622754491018
80858,"@Override public void update2ndStep(){
  super.update2ndStep();
  for (int i=0; i < columns.length; i++) {
    if (start[i] < context.get(Context.KEY_COLUMNS)) {
      Component.Instance component=columns[i];
      component.setPosition(row,column + start[i],size / context.get(Context.KEY_COLUMNS) * width[i]);
      component.update2ndStep();
    }
  }
}","@Override public void update2ndStep(){
  super.update2ndStep();
  for (int i=0; i < columns.length; i++) {
    if (start[i] < context.get(Context.KEY_COLUMNS)) {
      Component.Instance component=columns[i];
      component.setPosition(column + start[i],row,column + start[i],size / context.get(Context.KEY_COLUMNS) * width[i]);
      component.update2ndStep();
    }
  }
}",0.9753424657534246
80859,"@Override public synchronized void update(){
  super.update();
  List<Player> players=context.get(Context.KEY_PLAYER_SETS).get(config.getPlayerSet());
  config.getPlayerOrder().sort(context,players);
  activeComponents.forEach(Component.Instance::deactivate);
  activeComponents.clear();
  int size=min(80,players.size() * config.getPlayerComponent().getSize());
  setSize(1,size);
  int pos=0;
  int i;
  for (i=0; pos < size; i++) {
    Player player=players.get(i);
    Component.Instance component=config.getPlayerComponent().toInstance(context.derived().put(Context.KEY_PLAYER,player));
    component.activate();
    component.update1stStep();
    component.setPosition(pos,0,config.getPlayerComponent().getSize());
    component.update2ndStep();
    activeComponents.add(component);
    pos+=config.getPlayerComponent().getSize();
  }
}","@Override public synchronized void update(){
  super.update();
  List<Player> players=context.get(Context.KEY_PLAYER_SETS).get(config.getPlayerSet());
  config.getPlayerOrder().sort(context,players);
  activeComponents.forEach(Component.Instance::deactivate);
  activeComponents.clear();
  int size=min(80,players.size() * config.getPlayerComponent().getSize());
  setSize(1,size);
  int pos=0;
  int i;
  for (i=0; pos < size; i++) {
    Player player=players.get(i);
    Component.Instance component=config.getPlayerComponent().toInstance(context.derived().put(Context.KEY_PLAYER,player));
    component.activate();
    component.update1stStep();
    component.setPosition(0,pos,0,config.getPlayerComponent().getSize());
    component.update2ndStep();
    activeComponents.add(component);
    pos+=config.getPlayerComponent().getSize();
  }
}",0.9988137603795968
80860,"@Override public synchronized void update(){
  super.update();
  Arrays.fill(marks,false);
  content.setPosition(0,0,getSize());
  content.update1stStep();
  content.update2ndStep();
  for (int i=0; i < marks.length; i++) {
    boolean mark=marks[i];
    if (!mark) {
      setSlot(i / getColumns(),i % getColumns(),config.getDefaultIcon().evaluate(context),""String_Node_Str"",config.getDefaultPing());
    }
  }
}","@Override public synchronized void update(){
  super.update();
  Arrays.fill(marks,false);
  content.setPosition(0,0,0,getSize());
  content.update1stStep();
  content.update2ndStep();
  for (int i=0; i < marks.length; i++) {
    boolean mark=marks[i];
    if (!mark) {
      setSlot(i / getColumns(),i % getColumns(),config.getDefaultIcon().evaluate(context),""String_Node_Str"",config.getDefaultPing());
    }
  }
}",0.997584541062802
80861,"@Override public int getMaxSize(){
  return min(maxSize,players.size() * playerComponent.getSize());
}","@Override public int getMaxSize(){
  return max(minSize,min(maxSize,players.size() * playerComponent.getSize()));
}",0.9400921658986175
80862,"@Override public void update2ndStep(){
  activeComponents.forEach(Component.Instance::deactivate);
  activeComponents.clear();
  super.update2ndStep();
  boolean allFit=super.size >= getMaxSize();
  int pos=0;
  int i;
  for (i=0; (allFit || pos + morePlayersComponent.getSize() < super.size) && i < players.size(); i++) {
    Player player=players.get(i);
    Component.Instance component=playerComponent.toInstance(context.derived().setPlayer(player));
    component.activate();
    component.update1stStep();
    component.setPosition(row + (pos / context.getColumns()),column + (pos % context.getColumns()),playerComponent.getSize());
    component.update2ndStep();
    activeComponents.add(component);
    pos+=playerComponent.getSize();
  }
  if (!allFit) {
    Component.Instance component=morePlayersComponent.toInstance(context.derived().setOtherPlayersCount(players.size() - i));
    component.activate();
    component.update1stStep();
    component.setPosition(row + (pos / context.getColumns()),column + (pos % context.getColumns()),morePlayersComponent.getSize());
    component.update2ndStep();
    activeComponents.add(component);
  }
}","@Override public void update2ndStep(){
  activeComponents.forEach(Component.Instance::deactivate);
  activeComponents.clear();
  super.update2ndStep();
  boolean allFit=super.size >= players.size() * playerComponent.getSize();
  int pos=0;
  int i;
  for (i=0; (allFit || pos + playerComponent.getSize() + morePlayersComponent.getSize() <= super.size) && i < players.size(); i++) {
    Player player=players.get(i);
    Component.Instance component=playerComponent.toInstance(context.derived().setPlayer(player));
    component.activate();
    component.update1stStep();
    component.setPosition(row + (pos / context.getColumns()),column + (pos % context.getColumns()),playerComponent.getSize());
    component.update2ndStep();
    activeComponents.add(component);
    pos+=playerComponent.getSize();
  }
  if (!allFit) {
    Component.Instance component=morePlayersComponent.toInstance(context.derived().setOtherPlayersCount(players.size() - i));
    component.activate();
    component.update1stStep();
    component.setPosition(row + (pos / context.getColumns()),column + (pos % context.getColumns()),morePlayersComponent.getSize());
    component.update2ndStep();
    activeComponents.add(component);
  }
}",0.972492594159966
80863,"@Override public void update1stStep(){
  super.update1stStep();
  minSize=0;
  maxSize=Integer.MAX_VALUE;
  for (  Component.Instance component : columns) {
    component.update1stStep();
    minSize=max(minSize,component.getMinSize() / component.context.getColumns() * context.getColumns());
    maxSize=min(minSize,component.getMaxSize() / component.context.getColumns() * context.getColumns());
  }
}","@Override public void update1stStep(){
  super.update1stStep();
  minSize=0;
  maxSize=Integer.MAX_VALUE;
  for (  Component.Instance component : columns) {
    component.update1stStep();
    minSize=max(minSize,(component.getMinSize() + component.context.getColumns() - 1) / component.context.getColumns() * context.getColumns());
    maxSize=max(maxSize,(component.getMaxSize() + component.context.getColumns() - 1) / component.context.getColumns() * context.getColumns());
  }
}",0.8981900452488688
80864,"private void removePlayerFromTeam(int slot,UUID uuid,String player){
  if (uuid.version() == 2)   return;
  if (nameToSlotMap.remove(player,slot)) {
    sendPacket(removePlayer(slot,player));
  }
  if (playerToTeamMap.containsKey(player)) {
    Team team=new Team();
    team.setName(playerToTeamMap.get(player));
    team.setMode((byte)3);
    team.setPlayers(new String[]{player});
    sendPacket(team);
    team=new Team();
    team.setMode((byte)2);
    team.setName(fakePlayerUsernames[slot]);
    team.setDisplayName(fakePlayerUsernames[slot]);
    team.setPrefix(""String_Node_Str"");
    team.setSuffix(""String_Node_Str"");
    team.setFriendlyFire((byte)1);
    team.setNameTagVisibility(""String_Node_Str"");
    if (teamCollisionRuleSupported) {
      team.setCollisionRule(""String_Node_Str"");
    }
    team.setColor((byte)0);
    sendPacket(team);
  }
}","private void removePlayerFromTeam(int slot,UUID uuid,String player){
  if (uuid.version() == 2)   return;
  if (nameToSlotMap.getInt(player) == slot) {
    nameToSlotMap.remove(player);
    sendPacket(removePlayer(slot,player));
    if (playerToTeamMap.containsKey(player)) {
      Team team=new Team();
      team.setName(playerToTeamMap.get(player));
      team.setMode((byte)3);
      team.setPlayers(new String[]{player});
      sendPacket(team);
      team=new Team();
      team.setMode((byte)2);
      team.setName(fakePlayerUsernames[slot]);
      team.setDisplayName(fakePlayerUsernames[slot]);
      team.setPrefix(""String_Node_Str"");
      team.setSuffix(""String_Node_Str"");
      team.setFriendlyFire((byte)1);
      team.setNameTagVisibility(""String_Node_Str"");
      if (teamCollisionRuleSupported) {
        team.setCollisionRule(""String_Node_Str"");
      }
      team.setColor((byte)0);
      sendPacket(team);
    }
  }
}",0.9449694274596998
80865,"@Override public PacketListenerResult onTeamPacket(Team packet){
  if (fakePlayerUsernameSet.contains(packet.getName())) {
    throw new AssertionError(""String_Node_Str"" + packet);
  }
  if (packet.getMode() == 1) {
    net.md_5.bungee.api.score.Team team=serverTeams.remove(packet.getName());
    for (    String player : team.getPlayers()) {
      playerToTeamMap.remove(player,team.getName());
      if (!passtrough && size != 80 && nameToSlotMap.containsKey(player)) {
        Team packet1=new Team();
        packet1.setMode((byte)2);
        packet1.setName(fakePlayerUsernames[nameToSlotMap.get(player)]);
        packet1.setDisplayName(packet1.getName());
        packet1.setPrefix(""String_Node_Str"");
        packet1.setSuffix(""String_Node_Str"");
        packet1.setFriendlyFire((byte)1);
        packet1.setNameTagVisibility(""String_Node_Str"");
        if (teamCollisionRuleSupported) {
          packet1.setCollisionRule(""String_Node_Str"");
        }
        packet1.setColor((byte)0);
        sendPacket(packet1);
      }
    }
  }
 else {
    net.md_5.bungee.api.score.Team t;
    if (packet.getMode() == 0) {
      t=new net.md_5.bungee.api.score.Team(packet.getName());
      serverTeams.put(packet.getName(),t);
    }
 else {
      t=serverTeams.get(packet.getName());
    }
    if (t != null) {
      if (packet.getMode() == 0 || packet.getMode() == 2) {
        t.setDisplayName(packet.getDisplayName());
        t.setPrefix(packet.getPrefix());
        t.setSuffix(packet.getSuffix());
        t.setFriendlyFire(packet.getFriendlyFire());
        t.setNameTagVisibility(packet.getNameTagVisibility());
        if (teamCollisionRuleSupported) {
          t.setCollisionRule(packet.getCollisionRule());
        }
        t.setColor(packet.getColor());
      }
      if (packet.getPlayers() != null) {
        for (        String s : packet.getPlayers()) {
          if (packet.getMode() == 0 || packet.getMode() == 3) {
            if (playerToTeamMap.containsKey(s)) {
              serverTeams.get(playerToTeamMap.get(s)).getPlayers().remove(s);
            }
            t.addPlayer(s);
            playerToTeamMap.put(s,t.getName());
          }
 else {
            t.removePlayer(s);
            playerToTeamMap.remove(s,t.getName());
          }
        }
      }
    }
  }
  if (passtrough || size == 80) {
    return PacketListenerResult.PASS;
  }
  if (packet.getMode() == 2) {
    for (    String player : serverTeams.get(packet.getName()).getPlayers()) {
      if (nameToSlotMap.containsKey(player)) {
        Team team=new Team();
        team.setMode((byte)2);
        team.setName(fakePlayerUsernames[nameToSlotMap.get(player)]);
        team.setDisplayName(packet.getDisplayName());
        team.setPrefix(packet.getPrefix());
        team.setSuffix(packet.getSuffix());
        team.setFriendlyFire(packet.getFriendlyFire());
        team.setNameTagVisibility(packet.getNameTagVisibility());
        if (teamCollisionRuleSupported) {
          team.setCollisionRule(packet.getCollisionRule());
        }
        team.setColor(packet.getColor());
        sendPacket(team);
      }
    }
  }
  boolean modified=false;
  if (packet.getMode() == 0 || packet.getMode() == 3 || packet.getMode() == 4) {
    int length=0;
    for (    String player : packet.getPlayers()) {
      if (!nameToSlotMap.containsKey(player)) {
        length++;
      }
 else {
        if (packet.getMode() == 4 && nameToSlotMap.containsKey(player)) {
          Team team=new Team();
          team.setMode((byte)2);
          team.setName(fakePlayerUsernames[nameToSlotMap.get(player)]);
          team.setDisplayName(team.getName());
          team.setPrefix(""String_Node_Str"");
          team.setSuffix(""String_Node_Str"");
          team.setFriendlyFire((byte)1);
          team.setNameTagVisibility(""String_Node_Str"");
          if (teamCollisionRuleSupported) {
            team.setCollisionRule(""String_Node_Str"");
          }
          team.setColor((byte)0);
          sendPacket(team);
        }
 else         if (nameToSlotMap.containsKey(player)) {
          net.md_5.bungee.api.score.Team serverTeam=serverTeams.get(playerToTeamMap.get(player));
          Team team=new Team();
          team.setMode((byte)2);
          team.setName(fakePlayerUsernames[nameToSlotMap.get(player)]);
          team.setDisplayName(serverTeam.getDisplayName());
          team.setPrefix(serverTeam.getPrefix());
          team.setSuffix(serverTeam.getSuffix());
          team.setFriendlyFire(serverTeam.getFriendlyFire());
          team.setNameTagVisibility(serverTeam.getNameTagVisibility());
          if (teamCollisionRuleSupported) {
            team.setCollisionRule(serverTeam.getCollisionRule());
          }
          team.setColor(serverTeam.getColor());
          sendPacket(team);
        }
      }
    }
    if (length != packet.getPlayers().length) {
      String[] players=new String[length];
      length=0;
      for (      String player : packet.getPlayers()) {
        if (!nameToSlotMap.containsKey(player)) {
          players[length++]=player;
        }
      }
      packet.setPlayers(players);
      modified=true;
    }
  }
  return modified ? PacketListenerResult.MODIFIED : PacketListenerResult.PASS;
}","@Override public PacketListenerResult onTeamPacket(Team packet){
  if (fakePlayerUsernameSet.contains(packet.getName())) {
    throw new AssertionError(""String_Node_Str"" + packet);
  }
  if (packet.getMode() == 1) {
    net.md_5.bungee.api.score.Team team=serverTeams.remove(packet.getName());
    if (team != null) {
      for (      String player : team.getPlayers()) {
        playerToTeamMap.remove(player,team.getName());
        if (!passtrough && size != 80 && nameToSlotMap.containsKey(player)) {
          Team packet1=new Team();
          packet1.setMode((byte)2);
          packet1.setName(fakePlayerUsernames[nameToSlotMap.get(player)]);
          packet1.setDisplayName(packet1.getName());
          packet1.setPrefix(""String_Node_Str"");
          packet1.setSuffix(""String_Node_Str"");
          packet1.setFriendlyFire((byte)1);
          packet1.setNameTagVisibility(""String_Node_Str"");
          if (teamCollisionRuleSupported) {
            packet1.setCollisionRule(""String_Node_Str"");
          }
          packet1.setColor((byte)0);
          sendPacket(packet1);
        }
      }
    }
  }
 else {
    net.md_5.bungee.api.score.Team t;
    if (packet.getMode() == 0) {
      t=new net.md_5.bungee.api.score.Team(packet.getName());
      serverTeams.put(packet.getName(),t);
    }
 else {
      t=serverTeams.get(packet.getName());
    }
    if (t != null) {
      if (packet.getMode() == 0 || packet.getMode() == 2) {
        t.setDisplayName(packet.getDisplayName());
        t.setPrefix(packet.getPrefix());
        t.setSuffix(packet.getSuffix());
        t.setFriendlyFire(packet.getFriendlyFire());
        t.setNameTagVisibility(packet.getNameTagVisibility());
        if (teamCollisionRuleSupported) {
          t.setCollisionRule(packet.getCollisionRule());
        }
        t.setColor(packet.getColor());
      }
      if (packet.getPlayers() != null) {
        for (        String s : packet.getPlayers()) {
          if (packet.getMode() == 0 || packet.getMode() == 3) {
            if (playerToTeamMap.containsKey(s)) {
              serverTeams.get(playerToTeamMap.get(s)).removePlayer(s);
            }
            t.addPlayer(s);
            playerToTeamMap.put(s,t.getName());
          }
 else {
            t.removePlayer(s);
            playerToTeamMap.remove(s,t.getName());
          }
        }
      }
    }
  }
  if (passtrough || size == 80) {
    return PacketListenerResult.PASS;
  }
  if (packet.getMode() == 2) {
    for (    String player : serverTeams.get(packet.getName()).getPlayers()) {
      if (nameToSlotMap.containsKey(player)) {
        Team team=new Team();
        team.setMode((byte)2);
        team.setName(fakePlayerUsernames[nameToSlotMap.get(player)]);
        team.setDisplayName(packet.getDisplayName());
        team.setPrefix(packet.getPrefix());
        team.setSuffix(packet.getSuffix());
        team.setFriendlyFire(packet.getFriendlyFire());
        team.setNameTagVisibility(packet.getNameTagVisibility());
        if (teamCollisionRuleSupported) {
          team.setCollisionRule(packet.getCollisionRule());
        }
        team.setColor(packet.getColor());
        sendPacket(team);
      }
    }
  }
  boolean modified=false;
  if (packet.getMode() == 0 || packet.getMode() == 3 || packet.getMode() == 4) {
    int length=0;
    for (    String player : packet.getPlayers()) {
      if (!nameToSlotMap.containsKey(player)) {
        length++;
      }
 else {
        if (packet.getMode() == 4 && nameToSlotMap.containsKey(player)) {
          Team team=new Team();
          team.setMode((byte)2);
          team.setName(fakePlayerUsernames[nameToSlotMap.get(player)]);
          team.setDisplayName(team.getName());
          team.setPrefix(""String_Node_Str"");
          team.setSuffix(""String_Node_Str"");
          team.setFriendlyFire((byte)1);
          team.setNameTagVisibility(""String_Node_Str"");
          if (teamCollisionRuleSupported) {
            team.setCollisionRule(""String_Node_Str"");
          }
          team.setColor((byte)0);
          sendPacket(team);
        }
 else         if (nameToSlotMap.containsKey(player)) {
          net.md_5.bungee.api.score.Team serverTeam=serverTeams.get(playerToTeamMap.get(player));
          Team team=new Team();
          team.setMode((byte)2);
          team.setName(fakePlayerUsernames[nameToSlotMap.get(player)]);
          team.setDisplayName(serverTeam.getDisplayName());
          team.setPrefix(serverTeam.getPrefix());
          team.setSuffix(serverTeam.getSuffix());
          team.setFriendlyFire(serverTeam.getFriendlyFire());
          team.setNameTagVisibility(serverTeam.getNameTagVisibility());
          if (teamCollisionRuleSupported) {
            team.setCollisionRule(serverTeam.getCollisionRule());
          }
          team.setColor(serverTeam.getColor());
          sendPacket(team);
        }
      }
    }
    if (length != packet.getPlayers().length) {
      String[] players=new String[length];
      length=0;
      for (      String player : packet.getPlayers()) {
        if (!nameToSlotMap.containsKey(player)) {
          players[length++]=player;
        }
      }
      packet.setPlayers(players);
      modified=true;
    }
  }
  return modified ? PacketListenerResult.MODIFIED : PacketListenerResult.PASS;
}",0.9907750832144556
80866,"/** 
 * Called when the plugin is enabled
 */
public void onEnable(){
  try {
    Field field=BungeeTabListPlusAPI.class.getDeclaredField(""String_Node_Str"");
    field.setAccessible(true);
    field.set(null,this);
  }
 catch (  NoSuchFieldException|IllegalAccessException ex) {
    getLogger().log(Level.SEVERE,""String_Node_Str"",ex);
  }
  INSTANCE=this;
  try {
    config=new ConfigManager(plugin);
  }
 catch (  IOException ex) {
    plugin.getLogger().warning(""String_Node_Str"");
    plugin.getLogger().log(Level.WARNING,null,ex);
    plugin.getLogger().warning(""String_Node_Str"");
    return;
  }
  if (config.getMainConfig().automaticallySendBugReports) {
    BugReportingService bugReportingService=new BugReportingService(Level.SEVERE,getPlugin().getDescription().getName(),getPlugin().getDescription().getVersion(),command -> plugin.getProxy().getScheduler().runAsync(plugin,command));
    bugReportingService.registerLogger(getLogger());
  }
  try {
    Class.forName(""String_Node_Str"");
  }
 catch (  ClassNotFoundException ex) {
    is18=false;
  }
  try {
    Class.forName(""String_Node_Str"");
    isAbove995=true;
  }
 catch (  ClassNotFoundException ex) {
    isAbove995=false;
  }
  try {
    tabListHandlerField=UserConnection.class.getDeclaredField(isVersion18() ? ""String_Node_Str"" : ""String_Node_Str"");
  }
 catch (  NoSuchFieldException e) {
    plugin.getLogger().log(Level.SEVERE,""String_Node_Str"",e);
    plugin.getLogger().warning(""String_Node_Str"");
    plugin.getLogger().warning(""String_Node_Str"");
  }
  legacyPacketAccess=new LegacyPacketAccessImpl();
  if (!legacyPacketAccess.isTabModificationSupported()) {
    plugin.getLogger().warning(""String_Node_Str"");
    plugin.getLogger().warning(""String_Node_Str"");
    return;
  }
  if ((!legacyPacketAccess.isScoreboardSupported()) && config.getMainConfig().useScoreboardToBypass16CharLimit) {
    plugin.getLogger().warning(""String_Node_Str"");
    plugin.getLogger().warning(""String_Node_Str"");
    config.getMainConfig().useScoreboardToBypass16CharLimit=false;
  }
  resendThread=new ResendThread();
  if (isVersion18()) {
    packetAccess=new PacketAccessImpl(getLogger());
    if (!packetAccess.isTabHeaderFooterSupported()) {
      plugin.getLogger().warning(""String_Node_Str"");
    }
    File headsFolder=new File(plugin.getDataFolder(),""String_Node_Str"");
    if (!headsFolder.exists()) {
      headsFolder.mkdirs();
      try {
        ZipInputStream zipInputStream=new ZipInputStream(new FileInputStream(plugin.getFile()));
        ZipEntry entry;
        while ((entry=zipInputStream.getNextEntry()) != null) {
          if (!entry.isDirectory() && entry.getName().startsWith(""String_Node_Str"")) {
            try {
              File targetFile=new File(plugin.getDataFolder(),entry.getName());
              targetFile.getParentFile().mkdirs();
              if (!targetFile.exists()) {
                Files.copy(zipInputStream,targetFile.toPath());
                getLogger().info(""String_Node_Str"" + entry.getName());
              }
            }
 catch (            IOException ex) {
              getLogger().log(Level.SEVERE,""String_Node_Str"" + entry.getName(),ex);
            }
          }
        }
        zipInputStream.close();
      }
 catch (      IOException ex) {
        getLogger().log(Level.SEVERE,""String_Node_Str"",ex);
      }
    }
    skins=new SkinManagerImpl(plugin,headsFolder);
  }
 else {
    skins=new DummySkinManager();
  }
  fakePlayerManager=new FakePlayerManagerImpl(plugin);
  playerProviders=new ArrayList<>();
  if (plugin.getProxy().getPluginManager().getPlugin(""String_Node_Str"") != null) {
    redisPlayerManager=new RedisPlayerManager(connectedPlayerManager);
    playerProviders.add(redisPlayerManager);
    plugin.getLogger().info(""String_Node_Str"");
  }
  playerProviders.add(connectedPlayerManager);
  playerProviders.add(fakePlayerManager);
  plugin.getProxy().registerChannel(Constants.channel);
  bukkitBridge=new BukkitBridge(this);
  pm=new PermissionManager(this);
  dataManager=new DataManager(this,getPermissionManager());
  placeholderManager=new PlaceholderManagerImpl();
  placeholderManager.internalRegisterPlaceholderProvider(new BasicPlaceholders());
  placeholderManager.internalRegisterPlaceholderProvider(new BukkitPlaceholders());
  placeholderManager.internalRegisterPlaceholderProvider(new ColorPlaceholder());
  placeholderManager.internalRegisterPlaceholderProvider(new ConditionalPlaceholders());
  placeholderManager.internalRegisterPlaceholderProvider(new OnlineStatePlaceholder());
  placeholderManager.internalRegisterPlaceholderProvider(new PlayerCountPlaceholder());
  if (plugin.getProxy().getPluginManager().getPlugin(""String_Node_Str"") != null) {
    placeholderManager.internalRegisterPlaceholderProvider(new RedisBungeePlaceholders());
  }
  placeholderManager.internalRegisterPlaceholderProvider(new TimePlaceholders());
  tabLists=new TabListManager(this);
  if (!tabLists.loadTabLists()) {
    return;
  }
  if (plugin.getProxy().getPluginManager().getPlugin(""String_Node_Str"") != null) {
    protocolVersionProvider=new ProtocolSupportVersionProvider();
  }
 else {
    protocolVersionProvider=new BungeeProtocolVersionProvider();
  }
  ProxyServer.getInstance().getPluginManager().registerListener(plugin,listener);
  plugin.getProxy().getScheduler().runAsync(plugin,resendThread);
  restartRefreshThread();
  try {
    Thread.currentThread().getContextClassLoader().loadClass(""String_Node_Str"");
    ProxyServer.getInstance().getPluginManager().registerCommand(plugin,new SuperCommand(this));
    ProxyServer.getInstance().getScheduler().schedule(plugin,new UpdateNotifier(this),15,15,TimeUnit.MINUTES);
  }
 catch (  Exception ex) {
    ProxyServer.getInstance().getPluginManager().registerCommand(plugin,new OldSuperCommand(this));
  }
  try {
    Metrics metrics=new Metrics(plugin);
    metrics.start();
  }
 catch (  IOException e) {
    plugin.getLogger().log(Level.SEVERE,""String_Node_Str"",e);
  }
  if (config.getMainConfig().checkForUpdates) {
    updateChecker=new UpdateChecker(plugin);
  }
  ProtocolManager protocolManager=new ProtocolManager(plugin);
  protocolManager.enable();
  int[] serversHash={getProxy().getServers().hashCode()};
  getProxy().getScheduler().schedule(plugin,() -> {
    int hash=getProxy().getServers().hashCode();
    if (hash != serversHash[0]) {
      serversHash[0]=hash;
      getLogger().info(""String_Node_Str"");
      reload();
    }
  }
,1,1,TimeUnit.MINUTES);
  placeholderAPIHook=new PlaceholderAPIHook(this);
  placeholderAPIHook.onLoad();
}","/** 
 * Called when the plugin is enabled
 */
public void onEnable(){
  try {
    Field field=BungeeTabListPlusAPI.class.getDeclaredField(""String_Node_Str"");
    field.setAccessible(true);
    field.set(null,this);
  }
 catch (  NoSuchFieldException|IllegalAccessException ex) {
    getLogger().log(Level.SEVERE,""String_Node_Str"",ex);
  }
  INSTANCE=this;
  try {
    Team.class.getDeclaredMethod(""String_Node_Str"",String.class);
    is19=true;
  }
 catch (  NoSuchMethodException e) {
    is19=false;
  }
  try {
    config=new ConfigManager(plugin);
  }
 catch (  IOException ex) {
    plugin.getLogger().warning(""String_Node_Str"");
    plugin.getLogger().log(Level.WARNING,null,ex);
    plugin.getLogger().warning(""String_Node_Str"");
    return;
  }
  if (config.getMainConfig().automaticallySendBugReports) {
    BugReportingService bugReportingService=new BugReportingService(Level.SEVERE,getPlugin().getDescription().getName(),getPlugin().getDescription().getVersion(),command -> plugin.getProxy().getScheduler().runAsync(plugin,command));
    bugReportingService.registerLogger(getLogger());
  }
  try {
    Class.forName(""String_Node_Str"");
  }
 catch (  ClassNotFoundException ex) {
    is18=false;
  }
  try {
    Class.forName(""String_Node_Str"");
    isAbove995=true;
  }
 catch (  ClassNotFoundException ex) {
    isAbove995=false;
  }
  try {
    tabListHandlerField=UserConnection.class.getDeclaredField(isVersion18() ? ""String_Node_Str"" : ""String_Node_Str"");
  }
 catch (  NoSuchFieldException e) {
    plugin.getLogger().log(Level.SEVERE,""String_Node_Str"",e);
    plugin.getLogger().warning(""String_Node_Str"");
    plugin.getLogger().warning(""String_Node_Str"");
  }
  legacyPacketAccess=new LegacyPacketAccessImpl();
  if (!legacyPacketAccess.isTabModificationSupported()) {
    plugin.getLogger().warning(""String_Node_Str"");
    plugin.getLogger().warning(""String_Node_Str"");
    return;
  }
  if ((!legacyPacketAccess.isScoreboardSupported()) && config.getMainConfig().useScoreboardToBypass16CharLimit) {
    plugin.getLogger().warning(""String_Node_Str"");
    plugin.getLogger().warning(""String_Node_Str"");
    config.getMainConfig().useScoreboardToBypass16CharLimit=false;
  }
  resendThread=new ResendThread();
  if (isVersion18()) {
    packetAccess=new PacketAccessImpl(getLogger());
    if (!packetAccess.isTabHeaderFooterSupported()) {
      plugin.getLogger().warning(""String_Node_Str"");
    }
    File headsFolder=new File(plugin.getDataFolder(),""String_Node_Str"");
    if (!headsFolder.exists()) {
      headsFolder.mkdirs();
      try {
        ZipInputStream zipInputStream=new ZipInputStream(new FileInputStream(plugin.getFile()));
        ZipEntry entry;
        while ((entry=zipInputStream.getNextEntry()) != null) {
          if (!entry.isDirectory() && entry.getName().startsWith(""String_Node_Str"")) {
            try {
              File targetFile=new File(plugin.getDataFolder(),entry.getName());
              targetFile.getParentFile().mkdirs();
              if (!targetFile.exists()) {
                Files.copy(zipInputStream,targetFile.toPath());
                getLogger().info(""String_Node_Str"" + entry.getName());
              }
            }
 catch (            IOException ex) {
              getLogger().log(Level.SEVERE,""String_Node_Str"" + entry.getName(),ex);
            }
          }
        }
        zipInputStream.close();
      }
 catch (      IOException ex) {
        getLogger().log(Level.SEVERE,""String_Node_Str"",ex);
      }
    }
    skins=new SkinManagerImpl(plugin,headsFolder);
  }
 else {
    skins=new DummySkinManager();
  }
  fakePlayerManager=new FakePlayerManagerImpl(plugin);
  playerProviders=new ArrayList<>();
  if (plugin.getProxy().getPluginManager().getPlugin(""String_Node_Str"") != null) {
    redisPlayerManager=new RedisPlayerManager(connectedPlayerManager);
    playerProviders.add(redisPlayerManager);
    plugin.getLogger().info(""String_Node_Str"");
  }
  playerProviders.add(connectedPlayerManager);
  playerProviders.add(fakePlayerManager);
  plugin.getProxy().registerChannel(Constants.channel);
  bukkitBridge=new BukkitBridge(this);
  pm=new PermissionManager(this);
  dataManager=new DataManager(this,getPermissionManager());
  placeholderManager=new PlaceholderManagerImpl();
  placeholderManager.internalRegisterPlaceholderProvider(new BasicPlaceholders());
  placeholderManager.internalRegisterPlaceholderProvider(new BukkitPlaceholders());
  placeholderManager.internalRegisterPlaceholderProvider(new ColorPlaceholder());
  placeholderManager.internalRegisterPlaceholderProvider(new ConditionalPlaceholders());
  placeholderManager.internalRegisterPlaceholderProvider(new OnlineStatePlaceholder());
  placeholderManager.internalRegisterPlaceholderProvider(new PlayerCountPlaceholder());
  if (plugin.getProxy().getPluginManager().getPlugin(""String_Node_Str"") != null) {
    placeholderManager.internalRegisterPlaceholderProvider(new RedisBungeePlaceholders());
  }
  placeholderManager.internalRegisterPlaceholderProvider(new TimePlaceholders());
  tabLists=new TabListManager(this);
  if (!tabLists.loadTabLists()) {
    return;
  }
  if (plugin.getProxy().getPluginManager().getPlugin(""String_Node_Str"") != null) {
    protocolVersionProvider=new ProtocolSupportVersionProvider();
  }
 else {
    protocolVersionProvider=new BungeeProtocolVersionProvider();
  }
  ProxyServer.getInstance().getPluginManager().registerListener(plugin,listener);
  plugin.getProxy().getScheduler().runAsync(plugin,resendThread);
  restartRefreshThread();
  try {
    Thread.currentThread().getContextClassLoader().loadClass(""String_Node_Str"");
    ProxyServer.getInstance().getPluginManager().registerCommand(plugin,new SuperCommand(this));
    ProxyServer.getInstance().getScheduler().schedule(plugin,new UpdateNotifier(this),15,15,TimeUnit.MINUTES);
  }
 catch (  Exception ex) {
    ProxyServer.getInstance().getPluginManager().registerCommand(plugin,new OldSuperCommand(this));
  }
  try {
    Metrics metrics=new Metrics(plugin);
    metrics.start();
  }
 catch (  IOException e) {
    plugin.getLogger().log(Level.SEVERE,""String_Node_Str"",e);
  }
  if (config.getMainConfig().checkForUpdates) {
    updateChecker=new UpdateChecker(plugin);
  }
  ProtocolManager protocolManager=new ProtocolManager(plugin);
  protocolManager.enable();
  int[] serversHash={getProxy().getServers().hashCode()};
  getProxy().getScheduler().schedule(plugin,() -> {
    int hash=getProxy().getServers().hashCode();
    if (hash != serversHash[0]) {
      serversHash[0]=hash;
      getLogger().info(""String_Node_Str"");
      reload();
    }
  }
,1,1,TimeUnit.MINUTES);
  placeholderAPIHook=new PlaceholderAPIHook(this);
  placeholderAPIHook.onLoad();
}",0.9887082204155376
80867,"/** 
 * The property associated with the skin. See http://wiki.vg/Mojang_API#UUID_-.3E_Profile_.2B_Skin.2FCape This is only the ""textures"" property. <p> If this returns null   {@link Skin#getOwner()} must also return null. In that case this is arandom Alex/ Steve skin.
 * @return the properties associated with this skincan be null
 */
String[] toProperty();","/** 
 * The property associated with the skin. See http://wiki.vg/Mojang_API#UUID_-.3E_Profile_.2B_Skin.2FCape <p> If this returns null   {@link Skin#getOwner()} must also return null. In that case this is arandom Alex/ Steve skin.
 * @return the properties associated with this skin
 */
String[][] toProperty();",0.9239940387481372
80868,"@Override public void onEnable(){
  if (Float.parseFloat(System.getProperty(""String_Node_Str"")) < 52.0) {
    getLogger().severe(""String_Node_Str"");
    getLogger().severe(""String_Node_Str"");
    return;
  }
  if (!getProxy().getPlayers().isEmpty() && getProxy().getPluginManager().getPlugin(""String_Node_Str"") != null) {
    getLogger().severe(""String_Node_Str"");
    getLogger().severe(""String_Node_Str"");
    throw new RuntimeException(""String_Node_Str"");
  }
  BungeeTabListPlus.getInstance(this).onEnable();
}","@Override public void onEnable(){
  if (Float.parseFloat(System.getProperty(""String_Node_Str"")) < 52.0) {
    getLogger().severe(""String_Node_Str"");
    getLogger().severe(""String_Node_Str"");
    return;
  }
  if (!getProxy().getPlayers().isEmpty()) {
    for (    ProxiedPlayer proxiedPlayer : getProxy().getPlayers()) {
      proxiedPlayer.disconnect(""String_Node_Str"");
    }
  }
  BungeeTabListPlus.getInstance(this).onEnable();
  if (!getProxy().getPlayers().isEmpty()) {
    for (    ProxiedPlayer proxiedPlayer : getProxy().getPlayers()) {
      proxiedPlayer.disconnect(""String_Node_Str"");
    }
  }
}",0.5859305431878896
80869,"@Override public void onDisable(){
  if (BungeeCord.getInstance().isRunning && getProxy().getPluginManager().getPlugin(""String_Node_Str"") != null) {
    getLogger().severe(""String_Node_Str"");
    for (    ProxiedPlayer proxiedPlayer : getProxy().getPlayers()) {
      try {
        final TabList tablistHandler=ReflectionUtil.getTablistHandler(proxiedPlayer);
        if (tablistHandler instanceof PlayerTablistHandler) {
          ChannelWrapper channelWrapper=ReflectionUtil.getChannelWrapper(proxiedPlayer);
          channelWrapper.getHandle().eventLoop().submit(new Runnable(){
            @Override public void run(){
              ((PlayerTablistHandler)tablistHandler).exclude();
            }
          }
).await();
        }
      }
 catch (      Exception e) {
        e.printStackTrace();
      }
    }
    throw new RuntimeException(""String_Node_Str"");
  }
}","@Override public void onDisable(){
  if (BungeeCord.getInstance().isRunning) {
    getLogger().severe(""String_Node_Str"");
    if (!getProxy().getPlayers().isEmpty()) {
      for (      ProxiedPlayer proxiedPlayer : getProxy().getPlayers()) {
        proxiedPlayer.disconnect(""String_Node_Str"");
      }
    }
  }
}",0.2413502109704641
80870,"/** 
 * Called when the plugin is enabled
 */
public void onEnable(){
  try {
    Field field=BungeeTabListPlusAPI.class.getDeclaredField(""String_Node_Str"");
    field.setAccessible(true);
    field.set(null,this);
  }
 catch (  NoSuchFieldException|IllegalAccessException ex) {
    getLogger().log(Level.SEVERE,""String_Node_Str"",ex);
  }
  INSTANCE=this;
  try {
    Team.class.getDeclaredMethod(""String_Node_Str"",String.class);
    is19=true;
  }
 catch (  NoSuchMethodException e) {
    is19=false;
  }
  try {
    config=new ConfigManager(plugin);
  }
 catch (  IOException ex) {
    plugin.getLogger().warning(""String_Node_Str"");
    plugin.getLogger().log(Level.WARNING,null,ex);
    plugin.getLogger().warning(""String_Node_Str"");
    return;
  }
  if (config.getMainConfig().automaticallySendBugReports) {
    BugReportingService bugReportingService=new BugReportingService(Level.SEVERE,getPlugin().getDescription().getName(),getPlugin().getDescription().getVersion(),command -> plugin.getProxy().getScheduler().runAsync(plugin,command));
    bugReportingService.registerLogger(getLogger());
  }
  try {
    Class.forName(""String_Node_Str"");
  }
 catch (  ClassNotFoundException ex) {
    is18=false;
  }
  try {
    Class.forName(""String_Node_Str"");
    isAbove995=true;
  }
 catch (  ClassNotFoundException ex) {
    isAbove995=false;
  }
  try {
    tabListHandlerField=UserConnection.class.getDeclaredField(isVersion18() ? ""String_Node_Str"" : ""String_Node_Str"");
  }
 catch (  NoSuchFieldException e) {
    plugin.getLogger().log(Level.SEVERE,""String_Node_Str"",e);
    plugin.getLogger().warning(""String_Node_Str"");
    plugin.getLogger().warning(""String_Node_Str"");
  }
  legacyPacketAccess=new LegacyPacketAccessImpl();
  if (!legacyPacketAccess.isTabModificationSupported()) {
    plugin.getLogger().warning(""String_Node_Str"");
    plugin.getLogger().warning(""String_Node_Str"");
    return;
  }
  if ((!legacyPacketAccess.isScoreboardSupported()) && config.getMainConfig().useScoreboardToBypass16CharLimit) {
    plugin.getLogger().warning(""String_Node_Str"");
    plugin.getLogger().warning(""String_Node_Str"");
    config.getMainConfig().useScoreboardToBypass16CharLimit=false;
  }
  resendThread=new ResendThread();
  if (isVersion18()) {
    packetAccess=new PacketAccessImpl();
    if (!packetAccess.isTabHeaderFooterSupported()) {
      plugin.getLogger().warning(""String_Node_Str"");
    }
    File headsFolder=new File(plugin.getDataFolder(),""String_Node_Str"");
    if (!headsFolder.exists()) {
      headsFolder.mkdirs();
      try {
        ZipInputStream zipInputStream=new ZipInputStream(new FileInputStream(plugin.getFile()));
        ZipEntry entry;
        while ((entry=zipInputStream.getNextEntry()) != null) {
          if (!entry.isDirectory() && entry.getName().startsWith(""String_Node_Str"")) {
            try {
              File targetFile=new File(plugin.getDataFolder(),entry.getName());
              targetFile.getParentFile().mkdirs();
              if (!targetFile.exists()) {
                Files.copy(zipInputStream,targetFile.toPath());
                getLogger().info(""String_Node_Str"" + entry.getName());
              }
            }
 catch (            IOException ex) {
              getLogger().log(Level.SEVERE,""String_Node_Str"" + entry.getName(),ex);
            }
          }
        }
        zipInputStream.close();
      }
 catch (      IOException ex) {
        getLogger().log(Level.SEVERE,""String_Node_Str"",ex);
      }
    }
    skins=new SkinManagerImpl(plugin,headsFolder);
  }
 else {
    skins=new DummySkinManager();
  }
  fakePlayerManager=new FakePlayerManagerImpl(plugin);
  playerProviders=new ArrayList<>();
  if (plugin.getProxy().getPluginManager().getPlugin(""String_Node_Str"") != null) {
    redisPlayerManager=new RedisPlayerManager(connectedPlayerManager);
    playerProviders.add(redisPlayerManager);
    plugin.getLogger().info(""String_Node_Str"");
  }
  playerProviders.add(connectedPlayerManager);
  playerProviders.add(fakePlayerManager);
  plugin.getProxy().registerChannel(Constants.channel);
  bukkitBridge=new BukkitBridge(this);
  pm=new PermissionManager(this);
  dataManager=new DataManager(this,getPermissionManager());
  placeholderManager=new PlaceholderManagerImpl();
  placeholderManager.internalRegisterPlaceholderProvider(new BasicPlaceholders());
  placeholderManager.internalRegisterPlaceholderProvider(new BukkitPlaceholders());
  placeholderManager.internalRegisterPlaceholderProvider(new ColorPlaceholder());
  placeholderManager.internalRegisterPlaceholderProvider(new ConditionalPlaceholders());
  placeholderManager.internalRegisterPlaceholderProvider(new OnlineStatePlaceholder());
  placeholderManager.internalRegisterPlaceholderProvider(new PlayerCountPlaceholder());
  if (plugin.getProxy().getPluginManager().getPlugin(""String_Node_Str"") != null) {
    placeholderManager.internalRegisterPlaceholderProvider(new RedisBungeePlaceholders());
  }
  placeholderManager.internalRegisterPlaceholderProvider(new TimePlaceholders());
  tabLists=new TabListManager(this);
  if (!tabLists.loadTabLists()) {
    return;
  }
  if (plugin.getProxy().getPluginManager().getPlugin(""String_Node_Str"") != null) {
    protocolVersionProvider=new ProtocolSupportVersionProvider();
  }
 else {
    protocolVersionProvider=new BungeeProtocolVersionProvider();
  }
  ProxyServer.getInstance().getPluginManager().registerListener(plugin,listener);
  plugin.getProxy().getScheduler().runAsync(plugin,resendThread);
  restartRefreshThread();
  try {
    Thread.currentThread().getContextClassLoader().loadClass(""String_Node_Str"");
    ProxyServer.getInstance().getPluginManager().registerCommand(plugin,new SuperCommand(this));
    ProxyServer.getInstance().getScheduler().schedule(plugin,new UpdateNotifier(this),15,15,TimeUnit.MINUTES);
  }
 catch (  Exception ex) {
    ProxyServer.getInstance().getPluginManager().registerCommand(plugin,new OldSuperCommand(this));
  }
  try {
    Metrics metrics=new Metrics(plugin);
    metrics.start();
  }
 catch (  IOException e) {
    plugin.getLogger().log(Level.SEVERE,""String_Node_Str"",e);
  }
  if (config.getMainConfig().checkForUpdates) {
    updateChecker=new UpdateChecker(plugin);
  }
  ProtocolManager protocolManager=new ProtocolManager(plugin);
  protocolManager.enable();
  int[] serversHash={getProxy().getServers().hashCode()};
  getProxy().getScheduler().schedule(plugin,() -> {
    int hash=getProxy().getServers().hashCode();
    if (hash != serversHash[0]) {
      serversHash[0]=hash;
      getLogger().info(""String_Node_Str"");
      reload();
    }
  }
,1,1,TimeUnit.MINUTES);
  placeholderAPIHook=new PlaceholderAPIHook(this);
  placeholderAPIHook.onLoad();
}","/** 
 * Called when the plugin is enabled
 */
public void onEnable(){
  try {
    Class.forName(""String_Node_Str"");
  }
 catch (  ClassNotFoundException ex) {
    throw new RuntimeException(""String_Node_Str"");
  }
  try {
    Field field=BungeeTabListPlusAPI.class.getDeclaredField(""String_Node_Str"");
    field.setAccessible(true);
    field.set(null,this);
  }
 catch (  NoSuchFieldException|IllegalAccessException ex) {
    getLogger().log(Level.SEVERE,""String_Node_Str"",ex);
  }
  INSTANCE=this;
  try {
    config=new ConfigManager(plugin);
  }
 catch (  IOException ex) {
    plugin.getLogger().warning(""String_Node_Str"");
    plugin.getLogger().log(Level.WARNING,null,ex);
    plugin.getLogger().warning(""String_Node_Str"");
    return;
  }
  if (config.getMainConfig().automaticallySendBugReports) {
    BugReportingService bugReportingService=new BugReportingService(Level.SEVERE,getPlugin().getDescription().getName(),getPlugin().getDescription().getVersion(),command -> plugin.getProxy().getScheduler().runAsync(plugin,command));
    bugReportingService.registerLogger(getLogger());
  }
  resendThread=new ResendThread();
  File headsFolder=new File(plugin.getDataFolder(),""String_Node_Str"");
  if (!headsFolder.exists()) {
    headsFolder.mkdirs();
    try {
      ZipInputStream zipInputStream=new ZipInputStream(new FileInputStream(plugin.getFile()));
      ZipEntry entry;
      while ((entry=zipInputStream.getNextEntry()) != null) {
        if (!entry.isDirectory() && entry.getName().startsWith(""String_Node_Str"")) {
          try {
            File targetFile=new File(plugin.getDataFolder(),entry.getName());
            targetFile.getParentFile().mkdirs();
            if (!targetFile.exists()) {
              Files.copy(zipInputStream,targetFile.toPath());
              getLogger().info(""String_Node_Str"" + entry.getName());
            }
          }
 catch (          IOException ex) {
            getLogger().log(Level.SEVERE,""String_Node_Str"" + entry.getName(),ex);
          }
        }
      }
      zipInputStream.close();
    }
 catch (    IOException ex) {
      getLogger().log(Level.SEVERE,""String_Node_Str"",ex);
    }
  }
  skins=new SkinManagerImpl(plugin,headsFolder);
  fakePlayerManager=new FakePlayerManagerImpl(plugin);
  playerProviders=new ArrayList<>();
  if (plugin.getProxy().getPluginManager().getPlugin(""String_Node_Str"") != null) {
    redisPlayerManager=new RedisPlayerManager(connectedPlayerManager);
    playerProviders.add(redisPlayerManager);
    plugin.getLogger().info(""String_Node_Str"");
  }
  playerProviders.add(connectedPlayerManager);
  playerProviders.add(fakePlayerManager);
  plugin.getProxy().registerChannel(Constants.channel);
  bukkitBridge=new BukkitBridge(this);
  pm=new PermissionManager(this);
  dataManager=new DataManager(this,getPermissionManager());
  placeholderManager=new PlaceholderManagerImpl();
  placeholderManager.internalRegisterPlaceholderProvider(new BasicPlaceholders());
  placeholderManager.internalRegisterPlaceholderProvider(new BukkitPlaceholders());
  placeholderManager.internalRegisterPlaceholderProvider(new ColorPlaceholder());
  placeholderManager.internalRegisterPlaceholderProvider(new ConditionalPlaceholders());
  placeholderManager.internalRegisterPlaceholderProvider(new OnlineStatePlaceholder());
  placeholderManager.internalRegisterPlaceholderProvider(new PlayerCountPlaceholder());
  if (plugin.getProxy().getPluginManager().getPlugin(""String_Node_Str"") != null) {
    placeholderManager.internalRegisterPlaceholderProvider(new RedisBungeePlaceholders());
  }
  placeholderManager.internalRegisterPlaceholderProvider(new TimePlaceholders());
  tabLists=new TabListManager(this);
  if (!tabLists.loadTabLists()) {
    return;
  }
  if (plugin.getProxy().getPluginManager().getPlugin(""String_Node_Str"") != null) {
    protocolVersionProvider=new ProtocolSupportVersionProvider();
  }
 else {
    protocolVersionProvider=new BungeeProtocolVersionProvider();
  }
  ProxyServer.getInstance().getPluginManager().registerListener(plugin,listener);
  plugin.getProxy().getScheduler().runAsync(plugin,resendThread);
  restartRefreshThread();
  try {
    Thread.currentThread().getContextClassLoader().loadClass(""String_Node_Str"");
    ProxyServer.getInstance().getPluginManager().registerCommand(plugin,new SuperCommand(this));
    ProxyServer.getInstance().getScheduler().schedule(plugin,new UpdateNotifier(this),15,15,TimeUnit.MINUTES);
  }
 catch (  Exception ex) {
    ProxyServer.getInstance().getPluginManager().registerCommand(plugin,new OldSuperCommand(this));
  }
  try {
    Metrics metrics=new Metrics(plugin);
    metrics.start();
  }
 catch (  IOException e) {
    plugin.getLogger().log(Level.SEVERE,""String_Node_Str"",e);
  }
  if (config.getMainConfig().checkForUpdates) {
    updateChecker=new UpdateChecker(plugin);
  }
  ProtocolManager protocolManager=new ProtocolManager(plugin);
  protocolManager.enable();
  int[] serversHash={getProxy().getServers().hashCode()};
  getProxy().getScheduler().schedule(plugin,() -> {
    int hash=getProxy().getServers().hashCode();
    if (hash != serversHash[0]) {
      serversHash[0]=hash;
      getLogger().info(""String_Node_Str"");
      reload();
    }
  }
,1,1,TimeUnit.MINUTES);
  placeholderAPIHook=new PlaceholderAPIHook(this);
  placeholderAPIHook.onLoad();
}",0.7180382377389859
80871,"public IConfigTabListProvider parse(TabListConfig config){
  List<SlotTemplate> playerLines=config.playerLines.stream().filter(s -> s != null).map(this::parseSlot).collect(Collectors.toList());
  List<SlotTemplate> morePlayerLines=config.morePlayersLines.stream().filter(s -> s != null).map(this::parseSlot).collect(Collectors.toList());
  List<Function<TabListContext,List<Section>>> topSectionProviders=new ArrayList<>();
  List<Function<TabListContext,List<Section>>> botSectionProviders=new ArrayList<>();
  final boolean[] bottom={false};
  for (  String line : config.tabList) {
    if (line == null)     continue;
    final int[] startColumn={-1};
    final int[] column={-1};
    final int[] minslots={0};
    final int[] maxplayers={1000};
    final List<String> sortrules=new ArrayList<>();
    line=findTag(line,PATTERN_ALIGN_BOTTOM,matcher -> {
      if (config.verticalMode) {
        plugin.getLogger().warning(""String_Node_Str"");
      }
 else {
        bottom[0]=true;
      }
    }
);
    line=findTag(line,PATTERN_ALIGN_LEFT,matcher -> {
      if (config.verticalMode) {
        plugin.getLogger().warning(""String_Node_Str"");
      }
 else {
        startColumn[0]=0;
      }
    }
);
    line=findTag(line,PATTERN_ALIGN_RIGHT,matcher -> {
      if (config.verticalMode) {
        plugin.getLogger().warning(""String_Node_Str"");
      }
 else {
        startColumn[0]=columns - 1;
      }
    }
);
    line=findTag(line,PATTERN_COLUMN,matcher -> {
      if (config.verticalMode) {
        plugin.getLogger().warning(""String_Node_Str"");
      }
 else {
        column[0]=Integer.parseInt(matcher.group(1));
        if (column[0] >= columns) {
          plugin.getLogger().warning(String.format(""String_Node_Str"",column[0],columns,columns - 1));
          column[0]=columns - 1;
        }
      }
    }
);
    line=findTag(line,PATTERN_ROW,matcher -> {
      if (!config.verticalMode) {
        plugin.getLogger().warning(""String_Node_Str"");
      }
 else {
        column[0]=Integer.parseInt(matcher.group(1));
        if (column[0] >= rows) {
          plugin.getLogger().warning(String.format(""String_Node_Str"",column[0],rows,rows - 1));
          column[0]=rows - 1;
        }
      }
    }
);
    line=findTag(line,PATTERN_SORT,matcher -> {
      sortrules.addAll(Arrays.asList(matcher.group(1).split(""String_Node_Str"")));
    }
);
    line=findTag(line,PATTERN_MAXPLAYERS,matcher -> {
      maxplayers[0]=Integer.parseInt(matcher.group(1));
    }
);
    line=findTag(line,PATTERN_MINSLOTS,matcher -> {
      minslots[0]=Integer.parseInt(matcher.group(1));
    }
);
    if (startColumn[0] == -1 && column[0] != -1) {
      startColumn[0]=column[0];
    }
    PlayerSorter sorter=parseSortrules(sortrules);
    List<Function<TabListContext,List<Section>>> sections;
    if (!bottom[0]) {
      sections=topSectionProviders;
    }
 else {
      sections=botSectionProviders;
    }
    Matcher fillplayersMatcher=PATTERN_FILLPLAYERS.matcher(line);
    Matcher fillbukkitplayersMatcher=PATTERN_FILLBUKKITPLAYERS.matcher(line);
    if (fillplayersMatcher.matches()) {
      SlotTemplate prefix=parseSlot(fillplayersMatcher.group(""String_Node_Str""));
      SlotTemplate suffix=parseSlot(fillplayersMatcher.group(""String_Node_Str""));
      String args=fillplayersMatcher.group(""String_Node_Str"");
      List<String> filter;
      if (args == null || args.isEmpty()) {
        filter=new ArrayList<>();
      }
 else {
        filter=Arrays.asList(args.split(""String_Node_Str""));
      }
      if (column[0] == -1) {
        if (config.groupPlayers.equalsIgnoreCase(""String_Node_Str"") && filter.isEmpty()) {
          sections.add(parseServerSections(config,prefix,suffix,filter,sortrules,minslots[0],maxplayers[0],playerLines,morePlayerLines));
        }
 else {
          boolean allowsExtension=minslots[0] == 0 && maxplayers[0] == 1000 && startColumn[0] == -1;
          if (allowsExtension && !sections.isEmpty() && sections.get(sections.size() - 1) instanceof FillPlayersSection&& ((FillPlayersSection)sections.get(sections.size() - 1)).allowsExtension()) {
            ((FillPlayersSection)sections.get(sections.size() - 1)).addPlayers(parseFilter(filter),prefix,suffix,sorter);
          }
 else {
            sections.add(new FillPlayersSection(startColumn[0],parseFilter(filter),prefix,suffix,sorter,minslots[0],maxplayers[0],playerLines,morePlayerLines));
          }
        }
      }
 else {
        ColumnSplitSection cs;
        if (!sections.isEmpty() && sections.get(sections.size() - 1) instanceof ColumnSplitSection) {
          cs=(ColumnSplitSection)sections.get(sections.size() - 1);
        }
 else {
          cs=new ColumnSplitSection();
          sections.add(cs);
        }
        cs.addColumn(column[0],new PlayerColumn(parseFilter(filter),prefix,suffix,sorter,maxplayers[0],playerLines,morePlayerLines));
      }
    }
 else     if (fillbukkitplayersMatcher.matches()) {
      SlotTemplate prefix=parseSlot(fillbukkitplayersMatcher.group(""String_Node_Str""));
      SlotTemplate suffix=parseSlot(fillbukkitplayersMatcher.group(""String_Node_Str""));
      sections.add(new FillBukkitPlayersSection(startColumn[0],prefix,suffix,sorter,minslots[0],maxplayers[0],playerLines,morePlayerLines));
    }
 else {
      SlotTemplate template=parseSlot(line);
      StaticSection section;
      if (sections.size() > 0 && sections.get(sections.size() - 1) instanceof StaticSection && startColumn[0] == -1) {
        section=(StaticSection)sections.get(sections.size() - 1);
      }
 else {
        section=new StaticSection(startColumn[0]);
        sections.add(section);
      }
      section.add(template);
    }
  }
  if (config.headerCycleInterval <= 0) {
    config.headerCycleInterval=1;
  }
  if (config.footerCycleInterval <= 0) {
    config.footerCycleInterval=1;
  }
  if (config.header.size() > 1) {
    plugin.requireUpdateInterval(config.headerCycleInterval);
  }
  if (config.footer.size() > 1) {
    plugin.requireUpdateInterval(config.footerCycleInterval);
  }
  SlotTemplate header;
  if (!config.header.isEmpty()) {
    header=SlotTemplate.animate(config.header.stream().filter(s -> s != null).map(this::parseSlot).collect(Collectors.toList()),config.headerCycleInterval);
  }
 else {
    header=SlotTemplate.empty();
  }
  SlotTemplate footer;
  if (!config.footer.isEmpty()) {
    footer=SlotTemplate.animate(config.footer.stream().filter(s -> s != null).map(this::parseSlot).collect(Collectors.toList()),config.footerCycleInterval);
  }
 else {
    footer=SlotTemplate.empty();
  }
  return new ConfigTabListProvider(topSectionProviders,plugin,config,config.shownFooterHeader,botSectionProviders,header,footer,tab_size);
}","public IConfigTabListProvider parse(TabListConfig config){
  List<SlotTemplate> playerLines=config.playerLines.stream().filter(s -> s != null).map(this::parseSlot).collect(Collectors.toList());
  List<SlotTemplate> morePlayerLines=config.morePlayersLines.stream().filter(s -> s != null).map(this::parseSlot).collect(Collectors.toList());
  List<Function<TabListContext,List<Section>>> topSectionProviders=new ArrayList<>();
  List<Function<TabListContext,List<Section>>> botSectionProviders=new ArrayList<>();
  final boolean[] bottom={false};
  for (  String line : config.tabList) {
    if (line == null)     continue;
    final int[] startColumn={-1};
    final int[] column={-1};
    final int[] minslots={0};
    final int[] maxplayers={1000};
    final List<String> sortrules=new ArrayList<>();
    line=findTag(line,PATTERN_ALIGN_BOTTOM,matcher -> {
      if (config.verticalMode) {
        plugin.getLogger().warning(""String_Node_Str"");
      }
 else {
        bottom[0]=true;
      }
    }
);
    line=findTag(line,PATTERN_ALIGN_LEFT,matcher -> {
      if (config.verticalMode) {
        plugin.getLogger().warning(""String_Node_Str"");
      }
 else {
        startColumn[0]=0;
      }
    }
);
    line=findTag(line,PATTERN_ALIGN_RIGHT,matcher -> {
      if (config.verticalMode) {
        plugin.getLogger().warning(""String_Node_Str"");
      }
 else {
        startColumn[0]=columns - 1;
      }
    }
);
    line=findTag(line,PATTERN_COLUMN,matcher -> {
      if (config.verticalMode) {
        plugin.getLogger().warning(""String_Node_Str"");
      }
 else {
        column[0]=Integer.parseInt(matcher.group(1));
        if (column[0] >= columns) {
          plugin.getLogger().warning(String.format(""String_Node_Str"",column[0],columns,columns - 1));
          column[0]=columns - 1;
        }
      }
    }
);
    line=findTag(line,PATTERN_ROW,matcher -> {
      if (!config.verticalMode) {
        plugin.getLogger().warning(""String_Node_Str"");
      }
 else {
        column[0]=Integer.parseInt(matcher.group(1));
        if (column[0] >= rows) {
          plugin.getLogger().warning(String.format(""String_Node_Str"",column[0],rows,rows - 1));
          column[0]=rows - 1;
        }
      }
    }
);
    line=findTag(line,PATTERN_SORT,matcher -> {
      sortrules.addAll(Arrays.asList(matcher.group(1).split(""String_Node_Str"")));
    }
);
    line=findTag(line,PATTERN_MAXPLAYERS,matcher -> {
      maxplayers[0]=Integer.parseInt(matcher.group(1));
    }
);
    line=findTag(line,PATTERN_MINSLOTS,matcher -> {
      minslots[0]=Integer.parseInt(matcher.group(1));
    }
);
    if (startColumn[0] == -1 && column[0] != -1) {
      startColumn[0]=column[0];
    }
    PlayerSorter sorter=parseSortrules(sortrules);
    List<Function<TabListContext,List<Section>>> sections;
    if (!bottom[0]) {
      sections=topSectionProviders;
    }
 else {
      sections=botSectionProviders;
    }
    Matcher fillplayersMatcher=PATTERN_FILLPLAYERS.matcher(line);
    Matcher fillbukkitplayersMatcher=PATTERN_FILLBUKKITPLAYERS.matcher(line);
    if (fillplayersMatcher.matches()) {
      SlotTemplate prefix=parseSlot(fillplayersMatcher.group(""String_Node_Str""));
      SlotTemplate suffix=parseSlot(fillplayersMatcher.group(""String_Node_Str""));
      String args=fillplayersMatcher.group(""String_Node_Str"");
      List<String> filter;
      if (args == null || args.isEmpty()) {
        filter=new ArrayList<>();
      }
 else {
        filter=Arrays.asList(args.split(""String_Node_Str""));
      }
      if (column[0] == -1 || config.verticalMode) {
        if (config.groupPlayers.equalsIgnoreCase(""String_Node_Str"") && filter.isEmpty()) {
          sections.add(parseServerSections(config,prefix,suffix,filter,sortrules,minslots[0],maxplayers[0],playerLines,morePlayerLines));
        }
 else {
          boolean allowsExtension=minslots[0] == 0 && maxplayers[0] == 1000 && startColumn[0] == -1;
          if (allowsExtension && !sections.isEmpty() && sections.get(sections.size() - 1) instanceof FillPlayersSection&& ((FillPlayersSection)sections.get(sections.size() - 1)).allowsExtension()) {
            ((FillPlayersSection)sections.get(sections.size() - 1)).addPlayers(parseFilter(filter),prefix,suffix,sorter);
          }
 else {
            sections.add(new FillPlayersSection(startColumn[0],parseFilter(filter),prefix,suffix,sorter,minslots[0],maxplayers[0],playerLines,morePlayerLines));
          }
        }
      }
 else {
        ColumnSplitSection cs;
        if (!sections.isEmpty() && sections.get(sections.size() - 1) instanceof ColumnSplitSection) {
          cs=(ColumnSplitSection)sections.get(sections.size() - 1);
        }
 else {
          cs=new ColumnSplitSection();
          sections.add(cs);
        }
        cs.addColumn(column[0],new PlayerColumn(parseFilter(filter),prefix,suffix,sorter,maxplayers[0],playerLines,morePlayerLines));
      }
    }
 else     if (fillbukkitplayersMatcher.matches()) {
      SlotTemplate prefix=parseSlot(fillbukkitplayersMatcher.group(""String_Node_Str""));
      SlotTemplate suffix=parseSlot(fillbukkitplayersMatcher.group(""String_Node_Str""));
      sections.add(new FillBukkitPlayersSection(startColumn[0],prefix,suffix,sorter,minslots[0],maxplayers[0],playerLines,morePlayerLines));
    }
 else {
      SlotTemplate template=parseSlot(line);
      StaticSection section;
      if (sections.size() > 0 && sections.get(sections.size() - 1) instanceof StaticSection && startColumn[0] == -1) {
        section=(StaticSection)sections.get(sections.size() - 1);
      }
 else {
        section=new StaticSection(startColumn[0]);
        sections.add(section);
      }
      section.add(template);
    }
  }
  if (config.headerCycleInterval <= 0) {
    config.headerCycleInterval=1;
  }
  if (config.footerCycleInterval <= 0) {
    config.footerCycleInterval=1;
  }
  if (config.header.size() > 1) {
    plugin.requireUpdateInterval(config.headerCycleInterval);
  }
  if (config.footer.size() > 1) {
    plugin.requireUpdateInterval(config.footerCycleInterval);
  }
  SlotTemplate header;
  if (!config.header.isEmpty()) {
    header=SlotTemplate.animate(config.header.stream().filter(s -> s != null).map(this::parseSlot).collect(Collectors.toList()),config.headerCycleInterval);
  }
 else {
    header=SlotTemplate.empty();
  }
  SlotTemplate footer;
  if (!config.footer.isEmpty()) {
    footer=SlotTemplate.animate(config.footer.stream().filter(s -> s != null).map(this::parseSlot).collect(Collectors.toList()),config.footerCycleInterval);
  }
 else {
    footer=SlotTemplate.empty();
  }
  return new ConfigTabListProvider(topSectionProviders,plugin,config,config.shownFooterHeader,botSectionProviders,header,footer,tab_size);
}",0.9982793446547468
80872,"private boolean reloadTablists(){
  failIfNotMainThread();
  TabListManager tabListManager=new TabListManager(this);
  if (!tabListManager.loadTabLists()) {
    return true;
  }
  tabLists=tabListManager;
  return false;
}","private boolean reloadTablists(){
  failIfNotMainThread();
  TabListManager tabListManager=new TabListManager(this);
  if (!tabListManager.loadTabLists()) {
    return true;
  }
  tabListManager.customTabLists=tabLists.customTabLists;
  tabLists=tabListManager;
  return false;
}",0.8862275449101796
80873,"/** 
 * Reloads most settings of the plugin
 */
public boolean reload(){
  if (!resendThread.isInMainThread()) {
    AtomicReference<Boolean> ref=new AtomicReference<>(null);
    resendThread.execute(() -> {
      ref.set(reload());
    }
);
    while (ref.get() == null) {
      try {
        Thread.sleep(10);
      }
 catch (      InterruptedException ignored) {
        return false;
      }
    }
    return ref.get();
  }
  failIfNotMainThread();
  try {
    requestedUpdateInterval=null;
    config=new ConfigManager(plugin);
    placeholderManager.reload();
    if (reloadTablists())     return false;
    fakePlayerManager.reload();
    resendTabLists();
    restartRefreshThread();
    placeholderAPIHook.onLoad();
    skins.onReload();
  }
 catch (  IOException ex) {
    plugin.getLogger().log(Level.WARNING,""String_Node_Str"",ex);
  }
  return true;
}","/** 
 * Reloads most settings of the plugin
 */
public boolean reload(){
  if (!resendThread.isInMainThread()) {
    AtomicReference<Boolean> ref=new AtomicReference<>(null);
    resendThread.execute(() -> {
      ref.set(reload());
    }
);
    while (ref.get() == null) {
      try {
        Thread.sleep(10);
      }
 catch (      InterruptedException ignored) {
        return false;
      }
    }
    return ref.get();
  }
  failIfNotMainThread();
  try {
    config=new ConfigManager(plugin);
    placeholderManager.reload();
    if (reloadTablists())     return false;
    fakePlayerManager.reload();
    resendTabLists();
    restartRefreshThread();
    placeholderAPIHook.onLoad();
    skins.onReload();
  }
 catch (  IOException ex) {
    plugin.getLogger().log(Level.WARNING,""String_Node_Str"",ex);
  }
  return true;
}",0.979905437352246
80874,"@Override public void onDisconnect(){
  failIfNotInEventLoop();
  if (connectedPlayer != null) {
    BungeeTabListPlus.getInstance().getConnectedPlayerManager().onPlayerDisconnected(connectedPlayer);
    Server server=getPlayer().getServer();
    if (server != null) {
      server.disconnect(""String_Node_Str"");
    }
    ((UserConnection)getPlayer()).setServer(null);
  }
}","@Override public void onDisconnect(){
  failIfNotInEventLoop();
  if (connectedPlayer != null) {
    BungeeTabListPlus.getInstance().getConnectedPlayerManager().onPlayerDisconnected(connectedPlayer);
    if (getPlayer() != ProxyServer.getInstance().getPlayer(getPlayer().getName())) {
      Server server=getPlayer().getServer();
      if (server != null) {
        server.disconnect(""String_Node_Str"");
      }
      ((UserConnection)getPlayer()).setServer(null);
    }
  }
}",0.7567567567567568
80875,"@Override @SneakyThrows public void fillTabList(ProxiedPlayer player,TabList tabList,TabListContext context){
  if (config.verticalMode) {
    tabList=tabList.flip();
    context=new GenericTabListContext(tabList.getRows(),tabList.getColumns(),player,context.getPlayerManager());
    context=context.setPlayer(BungeeTabListPlus.getInstance().getConnectedPlayerManager().getPlayer(context.getViewer()));
  }
  if (config.autoShrinkTabList) {
    tabList.setShouldShrink(true);
  }
  final TabListContext finalContext=context;
  List<Section> topSections=topSectionsProvider.stream().flatMap(f -> f.apply(finalContext).stream()).collect(Collectors.toCollection(ArrayList::new));
  List<Section> botSections=botSectionsProvider.stream().flatMap(f -> f.apply(finalContext).stream()).collect(Collectors.toCollection(ArrayList::new));
  preCalculateSections(context,topSections);
  preCalculateSections(context,botSections);
  for (Iterator<Section> iterator=topSections.iterator(); iterator.hasNext(); ) {
    Section topSection=iterator.next();
    if (topSection.getMaxSize() == 0) {
      iterator.remove();
    }
  }
  for (Iterator<Section> iterator=botSections.iterator(); iterator.hasNext(); ) {
    Section botSection=iterator.next();
    if (botSection.getMaxSize() == 0) {
      iterator.remove();
    }
  }
  Layout<Section> layout=layoutManager.calculateLayout(topSections,botSections,context);
  for (int i=0; i < tabList.getSize(); i++) {
    Optional<Layout<Section>.SlotData> slotData=layout.getSlotData(i);
    if (slotData.isPresent()) {
      Layout<Section>.SlotData data=slotData.get();
      tabList.setSlot(i,data.getSection().getSlotAt(context,data.getSlotIndex(),data.getSectionSize()));
    }
  }
  if (showHeaderFooter) {
    tabList.setHeader(header.buildSlot(context).getText());
    tabList.setFooter(footer.buildSlot(context).getText());
  }
  if (BungeeTabListPlus.isVersion18()) {
    tabList.setDefaultSkin(plugin.getSkinManager().getSkin(config.defaultSkin));
  }
  tabList.setDefaultPing(config.defaultPing);
}","@Override @SneakyThrows public void fillTabList(ProxiedPlayer player,TabList tabList,TabListContext context){
  if (config.verticalMode) {
    tabList=tabList.flip();
    context=new GenericTabListContext(tabList.getRows(),tabList.getColumns(),player,context.getPlayerManager()).setPlayer(context.getPlayer());
  }
  if (config.autoShrinkTabList) {
    tabList.setShouldShrink(true);
  }
  final TabListContext finalContext=context;
  List<Section> topSections=topSectionsProvider.stream().flatMap(f -> f.apply(finalContext).stream()).collect(Collectors.toCollection(ArrayList::new));
  List<Section> botSections=botSectionsProvider.stream().flatMap(f -> f.apply(finalContext).stream()).collect(Collectors.toCollection(ArrayList::new));
  preCalculateSections(context,topSections);
  preCalculateSections(context,botSections);
  for (Iterator<Section> iterator=topSections.iterator(); iterator.hasNext(); ) {
    Section topSection=iterator.next();
    if (topSection.getMaxSize() == 0) {
      iterator.remove();
    }
  }
  for (Iterator<Section> iterator=botSections.iterator(); iterator.hasNext(); ) {
    Section botSection=iterator.next();
    if (botSection.getMaxSize() == 0) {
      iterator.remove();
    }
  }
  Layout<Section> layout=layoutManager.calculateLayout(topSections,botSections,context);
  for (int i=0; i < tabList.getSize(); i++) {
    Optional<Layout<Section>.SlotData> slotData=layout.getSlotData(i);
    if (slotData.isPresent()) {
      Layout<Section>.SlotData data=slotData.get();
      tabList.setSlot(i,data.getSection().getSlotAt(context,data.getSlotIndex(),data.getSectionSize()));
    }
  }
  if (showHeaderFooter) {
    tabList.setHeader(header.buildSlot(context).getText());
    tabList.setFooter(footer.buildSlot(context).getText());
  }
  if (BungeeTabListPlus.isVersion18()) {
    tabList.setDefaultSkin(plugin.getSkinManager().getSkin(config.defaultSkin));
  }
  tabList.setDefaultPing(config.defaultPing);
}",0.9714285714285714
80876,"private void checkForThirdPartyVariables(){
  for (  ServerInfo serverInfo : plugin.getProxy().getServers().values()) {
    get(serverInfo,BTLPDataKeys.REGISTERED_THIRD_PARTY_VARIABLES).ifPresent(variables -> {
      thirdPartyVariablesLock.lock();
      try {
        for (        String variable : variables) {
          if (!registeredThirdPartyVariables.contains(variable)) {
            plugin.registerPlaceholderProvider0(new PlaceholderProvider(){
              @Override public void setup(){
                bind(variable).to(context -> ((Player)context.getPlayer()).get(BTLPDataKeys.createThirdPartyVariableDataKey(variable)).orElse(""String_Node_Str""));
              }
            }
);
            registeredThirdPartyVariables.add(variable);
          }
        }
      }
  finally {
        thirdPartyVariablesLock.unlock();
      }
    }
);
  }
}","private void checkForThirdPartyVariables(){
  try {
    for (    ServerInfo serverInfo : plugin.getProxy().getServers().values()) {
      get(serverInfo,BTLPDataKeys.REGISTERED_THIRD_PARTY_VARIABLES).ifPresent(variables -> {
        thirdPartyVariablesLock.lock();
        try {
          for (          String variable : variables) {
            if (!registeredThirdPartyVariables.contains(variable)) {
              plugin.registerPlaceholderProvider0(new PlaceholderProvider(){
                @Override public void setup(){
                  bind(variable).to(context -> ((Player)context.getPlayer()).get(BTLPDataKeys.createThirdPartyVariableDataKey(variable)).orElse(""String_Node_Str""));
                }
              }
);
              registeredThirdPartyVariables.add(variable);
            }
          }
        }
 catch (        Throwable th) {
          plugin.getLogger().log(Level.SEVERE,""String_Node_Str"",th);
        }
 finally {
          thirdPartyVariablesLock.unlock();
        }
      }
);
    }
  }
 catch (  ConcurrentModificationException ignored) {
  }
}",0.850954100051573
80877,"private boolean reloadTablists(){
  TabListManager tabListManager=new TabListManager(this);
  if (!tabListManager.loadTabLists()) {
    return true;
  }
  tabLists=tabListManager;
  return false;
}","private boolean reloadTablists(){
  failIfNotMainThread();
  TabListManager tabListManager=new TabListManager(this);
  if (!tabListManager.loadTabLists()) {
    return true;
  }
  tabLists=tabListManager;
  return false;
}",0.9403341288782816
80878,"/** 
 * Reloads most settings of the plugin
 */
public boolean reload(){
  try {
    requestedUpdateInterval=null;
    config=new ConfigManager(plugin);
    placeholderManager.reload();
    if (reloadTablists())     return false;
    fakePlayerManager.reload();
    resendTabLists();
    restartRefreshThread();
    placeholderAPIHook.onLoad();
  }
 catch (  IOException ex) {
    plugin.getLogger().log(Level.WARNING,""String_Node_Str"",ex);
  }
  return true;
}","/** 
 * Reloads most settings of the plugin
 */
public boolean reload(){
  if (!resendThread.isInMainThread()) {
    AtomicReference<Boolean> ref=new AtomicReference<>(null);
    resendThread.execute(() -> {
      ref.set(reload());
    }
);
    while (ref.get() == null) {
      try {
        Thread.sleep(10);
      }
 catch (      InterruptedException ignored) {
        return false;
      }
    }
    return ref.get();
  }
  failIfNotMainThread();
  try {
    requestedUpdateInterval=null;
    config=new ConfigManager(plugin);
    placeholderManager.reload();
    if (reloadTablists())     return false;
    fakePlayerManager.reload();
    resendTabLists();
    restartRefreshThread();
    placeholderAPIHook.onLoad();
  }
 catch (  IOException ex) {
    plugin.getLogger().log(Level.WARNING,""String_Node_Str"",ex);
  }
  return true;
}",0.7081413210445469
80879,"/** 
 * Getter for an instance of the PlayerManager. For internal use only.
 * @return an instance of the PlayerManager or null
 */
public PlayerManager constructPlayerManager(ProxiedPlayer viewer){
  return new PlayerManagerImpl(this,playerProviders,viewer);
}","/** 
 * Getter for an instance of the PlayerManager. For internal use only.
 * @return an instance of the PlayerManager or null
 */
public PlayerManager constructPlayerManager(ProxiedPlayer viewer){
  failIfNotMainThread();
  return new PlayerManagerImpl(this,playerProviders,viewer);
}",0.9542961608775136
80880,"public void registerPlaceholderProvider0(PlaceholderProvider placeholderProvider){
  getPlaceholderManager0().internalRegisterPlaceholderProvider(placeholderProvider);
  reloadTablists();
}","public void registerPlaceholderProvider0(PlaceholderProvider placeholderProvider){
  getPlaceholderManager0().internalRegisterPlaceholderProvider(placeholderProvider);
  runInMainThread(this::reloadTablists);
}",0.9172932330827068
80881,"public void add(ProxiedPlayer player){
  if (!set.contains(player)) {
    set.add(player);
    queue.add(player);
  }
}","public void add(ProxiedPlayer player){
  lock.lock();
  try {
    if (!set.contains(player)) {
      set.add(player);
      queue.add(player);
      condition.signal();
    }
  }
  finally {
    lock.unlock();
  }
}",0.592814371257485
80882,"@Override public void run(){
  while (true) {
    try {
      if (queue.isEmpty()) {
        set.clear();
      }
      ProxiedPlayer player=queue.take();
      set.remove(player);
      Object tabList=BungeeTabListPlus.getTabList(player);
      if (tabList instanceof PlayerTablistHandler) {
        if (player.getServer() != null) {
          PlayerTablistHandler tablistHandler=(PlayerTablistHandler)tabList;
          update(tablistHandler);
        }
      }
    }
 catch (    InterruptedException ex) {
      break;
    }
catch (    Throwable th) {
      BungeeTabListPlus.getInstance().reportError(th);
    }
  }
}","@Override public void run(){
  lock.lock();
  try {
    while (true) {
      try {
        while (!tasks.isEmpty()) {
          tasks.poll().run();
        }
        while (!queue.isEmpty()) {
          ProxiedPlayer player=queue.poll();
          set.remove(player);
          Object tabList=BungeeTabListPlus.getTabList(player);
          if (tabList instanceof PlayerTablistHandler) {
            if (player.getServer() != null) {
              PlayerTablistHandler tablistHandler=(PlayerTablistHandler)tabList;
              update(tablistHandler);
            }
          }
        }
        set.clear();
        condition.await(1,TimeUnit.SECONDS);
      }
 catch (      InterruptedException ex) {
        break;
      }
catch (      Throwable th) {
        BungeeTabListPlus.getInstance().reportError(th);
      }
    }
  }
  finally {
    lock.unlock();
  }
}",0.7446236559139785
80883,"@SneakyThrows private BukkitData getPlayerDataCache(UUID uuid){
  return playerInformation.get(uuid,BukkitData::new);
}","@SneakyThrows private BukkitData getPlayerDataCache(UUID uuid){
  plugin.failIfNotMainThread();
  return playerInformation.get(uuid,BukkitData::new);
}",0.8814814814814815
80884,"public BukkitBridge(BungeeTabListPlus plugin){
  this.plugin=plugin;
  plugin.getProxy().getPluginManager().registerListener(plugin.getPlugin(),this);
  plugin.getProxy().getScheduler().schedule(plugin.getPlugin(),this::checkForThirdPartyVariables,2,2,TimeUnit.SECONDS);
  plugin.getProxy().getScheduler().schedule(plugin.getPlugin(),playerInformation::cleanUp,10,10,TimeUnit.SECONDS);
}","public BukkitBridge(BungeeTabListPlus plugin){
  this.plugin=plugin;
  plugin.getProxy().getPluginManager().registerListener(plugin.getPlugin(),this);
  plugin.getProxy().getScheduler().schedule(plugin.getPlugin(),() -> plugin.runInMainThread(this::checkForThirdPartyVariables),2,2,TimeUnit.SECONDS);
  plugin.getProxy().getScheduler().schedule(plugin.getPlugin(),playerInformation::cleanUp,10,10,TimeUnit.SECONDS);
}",0.9626865671641792
80885,"@EventHandler public void onPluginMessage(PluginMessageEvent event){
  if (event.getTag().equals(Constants.channel)) {
    event.setCancelled(true);
    if (event.getReceiver() instanceof ProxiedPlayer && event.getSender() instanceof Server) {
      try {
        ProxiedPlayer player=(ProxiedPlayer)event.getReceiver();
        Server server=(Server)event.getSender();
        ObjectInputStream in=new ObjectInputStream(new ByteArrayInputStream(event.getData()));
        String subchannel=in.readUTF();
switch (subchannel) {
case Constants.subchannelUpdateServer:
          updateData(in,getServerDataCache(server.getInfo().getName()));
        break;
case Constants.subchannelUpdatePlayer:
      updateData(in,getPlayerDataCache(player.getUniqueId()));
    break;
case Constants.subchannelPlayerHash:
  if (getPlayerDataCache(player.getUniqueId()).getMap().hashCode() != in.readInt()) {
    requestReset(player);
  }
break;
case Constants.subchannelServerHash:
if (getServerDataCache(server.getInfo().getName()).getMap().hashCode() != in.readInt()) {
requestReset(server);
}
break;
case Constants.subchannelPlaceholder:
plugin.getPlaceholderAPIHook().onPlaceholderConfirmed(in.readUTF());
break;
default :
plugin.getLogger().log(Level.SEVERE,""String_Node_Str"" + server.getInfo().getName() + ""String_Node_Str"");
break;
}
}
 catch (StreamCorruptedException ex) {
plugin.getLogger().log(Level.WARNING,""String_Node_Str"",((Server)event.getSender()).getInfo());
}
catch (IOException|ClassNotFoundException ex) {
plugin.getLogger().log(Level.SEVERE,""String_Node_Str"",ex);
}
}
}
}","@EventHandler public void onPluginMessage(PluginMessageEvent event){
  if (event.getTag().equals(Constants.channel)) {
    event.setCancelled(true);
    if (event.getReceiver() instanceof ProxiedPlayer && event.getSender() instanceof Server) {
      plugin.runInMainThread(() -> {
        try {
          ProxiedPlayer player=(ProxiedPlayer)event.getReceiver();
          Server server=(Server)event.getSender();
          ObjectInputStream in=new ObjectInputStream(new ByteArrayInputStream(event.getData()));
          String subchannel=in.readUTF();
switch (subchannel) {
case Constants.subchannelUpdateServer:
            updateData(in,getServerDataCache(server.getInfo().getName()));
          break;
case Constants.subchannelUpdatePlayer:
        updateData(in,getPlayerDataCache(player.getUniqueId()));
      break;
case Constants.subchannelPlayerHash:
    if (getPlayerDataCache(player.getUniqueId()).getMap().hashCode() != in.readInt()) {
      requestReset(player);
    }
  break;
case Constants.subchannelServerHash:
if (getServerDataCache(server.getInfo().getName()).getMap().hashCode() != in.readInt()) {
  requestReset(server);
}
break;
case Constants.subchannelPlaceholder:
plugin.getPlaceholderAPIHook().onPlaceholderConfirmed(in.readUTF());
break;
default :
plugin.getLogger().log(Level.SEVERE,""String_Node_Str"" + server.getInfo().getName() + ""String_Node_Str"");
break;
}
}
 catch (StreamCorruptedException ex) {
plugin.getLogger().log(Level.WARNING,""String_Node_Str"",((Server)event.getSender()).getInfo());
}
catch (IOException|ClassNotFoundException ex) {
plugin.getLogger().log(Level.SEVERE,""String_Node_Str"",ex);
}
}
);
}
}
}",0.9782608695652174
80886,"private BukkitData getServerDataCache(String serverName){
  if (!serverInformation.containsKey(serverName)) {
    serverInformation.putIfAbsent(serverName,new BukkitData());
  }
  return serverInformation.get(serverName);
}","private BukkitData getServerDataCache(String serverName){
  plugin.failIfNotMainThread();
  if (!serverInformation.containsKey(serverName)) {
    serverInformation.putIfAbsent(serverName,new BukkitData());
  }
  return serverInformation.get(serverName);
}",0.9330543933054394
80887,"public PlaceholderAPIHook(BungeeTabListPlus bungeeTabListPlus){
  this.bungeeTabListPlus=bungeeTabListPlus;
  bungeeTabListPlus.getPlugin().getProxy().getScheduler().schedule(bungeeTabListPlus.getPlugin(),this::askServersForPlaceholders,2,2,TimeUnit.SECONDS);
}","public PlaceholderAPIHook(BungeeTabListPlus bungeeTabListPlus){
  this.bungeeTabListPlus=bungeeTabListPlus;
  bungeeTabListPlus.getPlugin().getProxy().getScheduler().schedule(bungeeTabListPlus.getPlugin(),() -> bungeeTabListPlus.runInMainThread(this::askServersForPlaceholders),2,2,TimeUnit.SECONDS);
}",0.9271758436944938
80888,"private void update(PlayerTablistHandler tablistHandler){
  try {
    if (tablistHandler.getPlayer().getServer() != null) {
      if (BungeeTabListPlus.getInstance().getConfigManager().getMainConfig().excludeServers.contains(tablistHandler.getPlayer().getServer().getInfo().getName()) || tablistHandler.isExcluded()) {
        tablistHandler.unload();
        return;
      }
    }
    TabListProvider tlp=BungeeTabListPlus.getInstance().getTabListManager().getTabListForPlayer(tablistHandler.getPlayer());
    if (tlp == null) {
      tablistHandler.exclude();
      tablistHandler.unload();
      return;
    }
    TabList tabList;
    if (BungeeTabListPlus.getInstance().getProtocolVersionProvider().getProtocolVersion(tablistHandler.getPlayer()) >= 47) {
      int whishedTabListSize=tlp.getWhishedTabListSize();
      if (whishedTabListSize < 1) {
        whishedTabListSize=1;
      }
      if (whishedTabListSize > 80) {
        whishedTabListSize=80;
      }
      int columns=(whishedTabListSize + 19) / 20;
      tabList=new GenericTabList(whishedTabListSize / columns,columns);
    }
 else {
      tabList=new GenericTabList();
    }
    TabListContext context=new GenericTabListContext(tabList.getRows(),tabList.getColumns(),tablistHandler.getPlayer(),BungeeTabListPlus.getInstance().constructPlayerManager(tablistHandler.getPlayer()));
    context=context.setPlayer(BungeeTabListPlus.getInstance().getBungeePlayerProvider().wrapPlayer(context.getViewer()));
    tlp.fillTabList(tablistHandler.getPlayer(),tabList,context);
    tablistHandler.sendTablist(tabList);
  }
 catch (  Throwable th) {
    try {
      BungeeTabListPlus.getInstance().getLogger().log(th instanceof LayoutException ? Level.WARNING : Level.SEVERE,""String_Node_Str"",th);
      TabList tabList;
      if (BungeeTabListPlus.getInstance().getProtocolVersionProvider().getProtocolVersion(tablistHandler.getPlayer()) >= 47) {
        tabList=new GenericTabList(20,4);
      }
 else {
        tabList=new GenericTabList();
      }
      ErrorTabListProvider.constructErrorTabList(tablistHandler.getPlayer(),tabList,""String_Node_Str"",th);
      tablistHandler.sendTablist(tabList);
    }
 catch (    Throwable th2) {
      BungeeTabListPlus.getInstance().getLogger().log(Level.SEVERE,""String_Node_Str"",th2);
    }
  }
}","private void update(PlayerTablistHandler tablistHandler){
  try {
    if (tablistHandler.getPlayer().getServer() != null) {
      if (BungeeTabListPlus.getInstance().getConfigManager().getMainConfig().excludeServers.contains(tablistHandler.getPlayer().getServer().getInfo().getName()) || tablistHandler.isExcluded()) {
        tablistHandler.unload();
        return;
      }
    }
    TabListProvider tlp=BungeeTabListPlus.getInstance().getTabListManager().getTabListForPlayer(tablistHandler.getPlayer());
    if (tlp == null) {
      tablistHandler.exclude();
      tablistHandler.unload();
      return;
    }
    TabList tabList;
    if (BungeeTabListPlus.getInstance().getProtocolVersionProvider().getProtocolVersion(tablistHandler.getPlayer()) >= 47) {
      int wishedTabListSize=tlp.getWishedTabListSize();
      if (wishedTabListSize < 1) {
        wishedTabListSize=1;
      }
      if (wishedTabListSize > 80) {
        wishedTabListSize=80;
      }
      int columns=(wishedTabListSize + 19) / 20;
      tabList=new GenericTabList(wishedTabListSize / columns,columns);
    }
 else {
      tabList=new GenericTabList();
    }
    TabListContext context=new GenericTabListContext(tabList.getRows(),tabList.getColumns(),tablistHandler.getPlayer(),BungeeTabListPlus.getInstance().constructPlayerManager(tablistHandler.getPlayer()));
    context=context.setPlayer(BungeeTabListPlus.getInstance().getBungeePlayerProvider().wrapPlayer(context.getViewer()));
    tlp.fillTabList(tablistHandler.getPlayer(),tabList,context);
    tablistHandler.sendTablist(tabList);
  }
 catch (  Throwable th) {
    try {
      BungeeTabListPlus.getInstance().getLogger().log(th instanceof LayoutException ? Level.WARNING : Level.SEVERE,""String_Node_Str"",th);
      TabList tabList;
      if (BungeeTabListPlus.getInstance().getProtocolVersionProvider().getProtocolVersion(tablistHandler.getPlayer()) >= 47) {
        tabList=new GenericTabList(20,4);
      }
 else {
        tabList=new GenericTabList();
      }
      ErrorTabListProvider.constructErrorTabList(tablistHandler.getPlayer(),tabList,""String_Node_Str"",th);
      tablistHandler.sendTablist(tabList);
    }
 catch (    Throwable th2) {
      BungeeTabListPlus.getInstance().getLogger().log(Level.SEVERE,""String_Node_Str"",th2);
    }
  }
}",0.9733856893542756
80889,"@Override public void onUpdate(PlayerListItem pli){
  try {
    if (pli.getItems().length == 0) {
      return;
    }
    pli=CustomTabList18.rewrite(pli);
    for (    PlayerListItem.Item i : pli.getItems()) {
synchronized (bukkitplayers) {
        String name=i.getUsername();
        if (name == null && i.getUuid() != null) {
          name=uuids.get(i.getUuid());
        }
        if (name != null) {
switch (pli.getAction()) {
case ADD_PLAYER:
            FakePlayer player=new FakePlayer(name,getPlayer().getServer() != null ? getPlayer().getServer().getInfo() : null);
          player.setPing(i.getPing());
        player.setGamemode(i.getGamemode());
      if (i.getUuid() != null && i.getProperties() != null) {
        for (        String[] strings : i.getProperties()) {
          if (strings.length == 3 && strings[0].equals(""String_Node_Str"")) {
            player.setSkin(new PlayerSkin(i.getUuid(),strings));
          }
        }
      }
    bukkitplayers.put(name,player);
  break;
case UPDATE_GAMEMODE:
bukkitplayers.computeIfPresent(name,(s,fakePlayer) -> {
  fakePlayer.setGamemode(i.getGamemode());
  return fakePlayer;
}
);
break;
case UPDATE_LATENCY:
bukkitplayers.computeIfPresent(name,(s,fakePlayer) -> {
fakePlayer.setPing(i.getPing());
return fakePlayer;
}
);
break;
case UPDATE_DISPLAY_NAME:
break;
case REMOVE_PLAYER:
bukkitplayers.remove(name);
break;
}
}
}
}
if (BungeeTabListPlus.getInstance().getConfigManager().getMainConfig().excludeServers.contains(getPlayer().getServer().getInfo().getName()) || isExcluded || BungeeTabListPlus.getInstance().getProtocolVersionProvider().getProtocolVersion(getPlayer()) >= 47) {
if ((pli.getAction() == PlayerListItem.Action.ADD_PLAYER) || (pli.getAction() == PlayerListItem.Action.REMOVE_PLAYER) || pli.getItems()[0].getUuid().equals(getPlayer().getUniqueId())) {
player.unsafe().sendPacket(pli);
for (PlayerListItem.Item item : pli.getItems()) {
if (item.getUuid() != null) {
requiresUpdate.add(item.getUuid());
}
}
BungeeTabListPlus.getInstance().updateTabListForPlayer(player);
}
synchronized (usernames) {
for (PlayerListItem.Item item : pli.getItems()) {
if (pli.getAction() == PlayerListItem.Action.ADD_PLAYER) {
if (item.getUuid() != null) {
uuids.put(item.getUuid(),item.getUsername());
}
 else {
usernames.add(item.getUsername());
}
}
 else if (pli.getAction() == PlayerListItem.Action.REMOVE_PLAYER) {
if (item.getUuid() != null) {
uuids.remove(item.getUuid());
}
 else {
usernames.remove(item.getUsername());
}
}
}
}
}
}
 catch (Throwable th) {
BungeeTabListPlus.getInstance().reportError(th);
}
}","@Override public void onUpdate(PlayerListItem pli){
  try {
    if (pli.getItems().length == 0) {
      return;
    }
    pli=CustomTabList18.rewrite(pli);
    for (    PlayerListItem.Item i : pli.getItems()) {
synchronized (bukkitplayers) {
        String name=i.getUsername();
        if (name == null && i.getUuid() != null) {
          name=uuids.get(i.getUuid());
        }
        if (name != null) {
switch (pli.getAction()) {
case ADD_PLAYER:
            FakePlayer player=new FakePlayer(name,getPlayer().getServer() != null ? getPlayer().getServer().getInfo() : null);
          player.setPing(i.getPing());
        player.setGamemode(i.getGamemode());
      if (i.getUuid() != null && i.getProperties() != null) {
        for (        String[] strings : i.getProperties()) {
          if (strings.length == 3 && strings[0].equals(""String_Node_Str"")) {
            player.setSkin(new PlayerSkin(i.getUuid(),strings));
          }
        }
      }
    bukkitplayers.put(name,player);
  break;
case UPDATE_GAMEMODE:
bukkitplayers.computeIfPresent(name,(s,fakePlayer) -> {
  fakePlayer.setGamemode(i.getGamemode());
  return fakePlayer;
}
);
break;
case UPDATE_LATENCY:
bukkitplayers.computeIfPresent(name,(s,fakePlayer) -> {
fakePlayer.setPing(i.getPing());
return fakePlayer;
}
);
break;
case UPDATE_DISPLAY_NAME:
break;
case REMOVE_PLAYER:
bukkitplayers.remove(name);
break;
}
}
}
}
if (BungeeTabListPlus.getInstance().getConfigManager().getMainConfig().excludeServers.contains(getPlayer().getServer().getInfo().getName()) || isExcluded || BungeeTabListPlus.getInstance().getProtocolVersionProvider().getProtocolVersion(getPlayer()) >= 47) {
if ((pli.getAction() == PlayerListItem.Action.ADD_PLAYER) || (pli.getAction() == PlayerListItem.Action.REMOVE_PLAYER) || pli.getItems()[0].getUuid().equals(getPlayer().getUniqueId())) {
if ((pli.getAction() == PlayerListItem.Action.ADD_PLAYER) || (pli.getAction() == PlayerListItem.Action.UPDATE_GAMEMODE)) {
for (PlayerListItem.Item item : pli.getItems()) {
if (item.getGamemode() == 3 && !item.getUuid().equals(getPlayer().getUniqueId())) {
item.setGamemode(0);
}
}
}
player.unsafe().sendPacket(pli);
for (PlayerListItem.Item item : pli.getItems()) {
if (item.getUuid() != null) {
requiresUpdate.add(item.getUuid());
}
}
BungeeTabListPlus.getInstance().updateTabListForPlayer(player);
}
synchronized (usernames) {
for (PlayerListItem.Item item : pli.getItems()) {
if (pli.getAction() == PlayerListItem.Action.ADD_PLAYER) {
if (item.getUuid() != null) {
uuids.put(item.getUuid(),item.getUsername());
}
 else {
usernames.add(item.getUsername());
}
}
 else if (pli.getAction() == PlayerListItem.Action.REMOVE_PLAYER) {
if (item.getUuid() != null) {
uuids.remove(item.getUuid());
}
 else {
usernames.remove(item.getUsername());
}
}
}
}
}
}
 catch (Throwable th) {
BungeeTabListPlus.getInstance().reportError(th);
}
}",0.947870778267254
80890,"@Override public Slot getSlotAt(TabListContext context,int pos,int size){
  int column=pos % context.getColumns();
  int sizePerCol=size / ConfigManager.getCols();
  int columnPos=(pos + ConfigManager.getCols() - 1) / ConfigManager.getCols();
  PlayerColumn playerColumn=pc[column];
  if (playerColumn != null) {
    int span=1;
    while (column + span < pc.length && pc[column + span] != null && pc[column + span - 1].filter.equals(pc[column + span].filter)) {
      span++;
    }
    int pre=1;
    while (column - pre >= 0 && pc[column - pre] != null && playerColumn.filter.equals(pc[column - pre].filter)) {
      pre++;
    }
    pre--;
    span+=pre;
    columnPos=columnPos * span + pre;
    return playerColumn.getSlotAt(context,columnPos,sizePerCol * span);
  }
  return null;
}","@Override public Slot getSlotAt(TabListContext context,int pos,int size){
  int column=pos % context.getColumns();
  int sizePerCol=size / ConfigManager.getCols();
  int columnPos=pos / ConfigManager.getCols();
  PlayerColumn playerColumn=pc[column];
  if (playerColumn != null) {
    int span=1;
    while (column + span < pc.length && pc[column + span] != null && pc[column + span - 1].filter.equals(pc[column + span].filter)) {
      span++;
    }
    int pre=1;
    while (column - pre >= 0 && pc[column - pre] != null && playerColumn.filter.equals(pc[column - pre].filter)) {
      pre++;
    }
    pre--;
    span+=pre;
    columnPos=columnPos * span + pre;
    return playerColumn.getSlotAt(context,columnPos,sizePerCol * span);
  }
  return null;
}",0.9753886010362696
80891,"static boolean compareVersions(String newVersion,String runningVersion){
  boolean usesDevBuild=false;
  if (runningVersion.endsWith(""String_Node_Str"")) {
    usesDevBuild=true;
    runningVersion=runningVersion.replace(""String_Node_Str"",""String_Node_Str"");
  }
  String[] current=runningVersion.split(""String_Node_Str"");
  String[] latest=newVersion.split(""String_Node_Str"");
  int i=0;
  boolean higher=false;
  boolean equal=true;
  for (; i < current.length && i < latest.length; i++) {
    if (Integer.valueOf(current[i]) < Integer.valueOf(latest[i])) {
      higher=true;
      break;
    }
 else     if (Objects.equals(Integer.valueOf(current[i]),Integer.valueOf(latest[i]))) {
      equal=true;
    }
 else {
      equal=false;
      break;
    }
  }
  boolean updateAvailable=false;
  if (higher) {
    updateAvailable=true;
  }
  if (equal) {
    if (current.length < latest.length) {
      updateAvailable=true;
    }
 else     if (usesDevBuild) {
      updateAvailable=true;
    }
  }
  return updateAvailable;
}","static boolean compareVersions(String newVersion,String runningVersion){
  boolean usesDevBuild=false;
  if (runningVersion.endsWith(""String_Node_Str"")) {
    usesDevBuild=true;
    runningVersion=runningVersion.replace(""String_Node_Str"",""String_Node_Str"");
  }
  String[] current=runningVersion.split(""String_Node_Str"");
  String[] latest=newVersion.split(""String_Node_Str"");
  int i=0;
  boolean higher=false;
  boolean equal=true;
  for (; i < current.length && i < latest.length; i++) {
    if (Integer.valueOf(current[i]) < Integer.valueOf(latest[i])) {
      higher=true;
      break;
    }
 else     if (Objects.equals(Integer.valueOf(current[i]),Integer.valueOf(latest[i]))) {
      equal=true;
    }
 else {
      equal=false;
      break;
    }
  }
  boolean updateAvailable=false;
  if (higher) {
    updateAvailable=true;
  }
  if (equal) {
    if (current.length < latest.length) {
      updateAvailable=true;
    }
 else     if (current.length == latest.length && usesDevBuild) {
      updateAvailable=true;
    }
  }
  return updateAvailable;
}",0.9831973115698512
80892,"@Test public void testCompareVersions() throws Exception {
  Assert.assertTrue(UpdateChecker.compareVersions(""String_Node_Str"",""String_Node_Str""));
  Assert.assertTrue(UpdateChecker.compareVersions(""String_Node_Str"",""String_Node_Str""));
  Assert.assertTrue(UpdateChecker.compareVersions(""String_Node_Str"",""String_Node_Str""));
  Assert.assertTrue(UpdateChecker.compareVersions(""String_Node_Str"",""String_Node_Str""));
  Assert.assertTrue(UpdateChecker.compareVersions(""String_Node_Str"",""String_Node_Str""));
  Assert.assertFalse(UpdateChecker.compareVersions(""String_Node_Str"",""String_Node_Str""));
  Assert.assertFalse(UpdateChecker.compareVersions(""String_Node_Str"",""String_Node_Str""));
  Assert.assertFalse(UpdateChecker.compareVersions(""String_Node_Str"",""String_Node_Str""));
  Assert.assertFalse(UpdateChecker.compareVersions(""String_Node_Str"",""String_Node_Str""));
  Assert.assertFalse(UpdateChecker.compareVersions(""String_Node_Str"",""String_Node_Str""));
}","@Test public void testCompareVersions() throws Exception {
  Assert.assertTrue(UpdateChecker.compareVersions(""String_Node_Str"",""String_Node_Str""));
  Assert.assertTrue(UpdateChecker.compareVersions(""String_Node_Str"",""String_Node_Str""));
  Assert.assertTrue(UpdateChecker.compareVersions(""String_Node_Str"",""String_Node_Str""));
  Assert.assertTrue(UpdateChecker.compareVersions(""String_Node_Str"",""String_Node_Str""));
  Assert.assertTrue(UpdateChecker.compareVersions(""String_Node_Str"",""String_Node_Str""));
  Assert.assertFalse(UpdateChecker.compareVersions(""String_Node_Str"",""String_Node_Str""));
  Assert.assertFalse(UpdateChecker.compareVersions(""String_Node_Str"",""String_Node_Str""));
  Assert.assertFalse(UpdateChecker.compareVersions(""String_Node_Str"",""String_Node_Str""));
  Assert.assertFalse(UpdateChecker.compareVersions(""String_Node_Str"",""String_Node_Str""));
  Assert.assertFalse(UpdateChecker.compareVersions(""String_Node_Str"",""String_Node_Str""));
  Assert.assertFalse(UpdateChecker.compareVersions(""String_Node_Str"",""String_Node_Str""));
}",0.955
80893,"public AutoFillPlayers parseServerSections(TabListConfig config,SlotTemplate g_prefix,SlotTemplate g_suffix,List<String> g_filter,List<String> g_sort,int g_maxPlayers,List<SlotTemplate> playerLines,List<SlotTemplate> morePlayerLines){
  Map<String,ServerInfo> servers=ProxyServer.getInstance().getServers();
  Set<String> serverSet=new HashSet<>(servers.keySet());
  HashMultimap<String,String> aliasToServerMap=HashMultimap.create();
  for (  Map.Entry<String,String> entry : BungeeTabListPlus.getInstance().getConfigManager().getMainConfig().serverAlias.entrySet()) {
    if (ProxyServer.getInstance().getServerInfo(entry.getKey()) == null) {
      BungeeTabListPlus.getInstance().getLogger().warning(""String_Node_Str"" + entry.getKey() + ""String_Node_Str"");
      continue;
    }
    aliasToServerMap.put(entry.getValue(),entry.getKey());
  }
  List<ServerGroup> list=new ArrayList<>();
  while (!serverSet.isEmpty()) {
    String server=serverSet.iterator().next();
    String alias=BungeeTabListPlus.getInstance().getConfigManager().getMainConfig().serverAlias.get(server);
    if (alias != null) {
      Set<String> strings=aliasToServerMap.get(alias);
      serverSet.removeAll(strings);
      list.add(GenericServerGroup.of(serverSet,alias));
    }
 else {
      serverSet.remove(server);
      list.add(GenericServerGroup.of(server));
    }
  }
  List<Function<ServerGroup,Section>> sections=new ArrayList<>();
  for (  String line : config.groupLines) {
    final int[] startColumn={-1};
    final List<String> sortrules=new ArrayList<>();
    final int[] maxplayers={g_maxPlayers};
    line=findTag(line,PATTERN_ALIGN_LEFT,matcher -> {
      if (config.verticalMode) {
        plugin.getLogger().warning(""String_Node_Str"");
      }
 else {
        startColumn[0]=0;
      }
    }
);
    line=findTag(line,PATTERN_ALIGN_RIGHT,matcher -> {
      if (config.verticalMode) {
        plugin.getLogger().warning(""String_Node_Str"");
      }
 else {
        startColumn[0]=ConfigManager.getCols() - 1;
      }
    }
);
    line=findTag(line,PATTERN_SORT,matcher -> {
      sortrules.addAll(Arrays.asList(matcher.group(1).split(""String_Node_Str"")));
    }
);
    line=findTag(line,PATTERN_COLUMN,matcher -> {
      if (config.verticalMode) {
        plugin.getLogger().warning(""String_Node_Str"");
      }
 else {
        startColumn[0]=Integer.parseInt(matcher.group(1));
        if (startColumn[0] > ConfigManager.getCols()) {
          plugin.getLogger().warning(String.format(""String_Node_Str"",startColumn[0],ConfigManager.getCols(),ConfigManager.getCols() - 1));
          startColumn[0]=ConfigManager.getCols() - 1;
        }
      }
    }
);
    line=findTag(line,PATTERN_ROW,matcher -> {
      if (!config.verticalMode) {
        plugin.getLogger().warning(""String_Node_Str"");
      }
 else {
        startColumn[0]=Integer.parseInt(matcher.group(1));
        if (startColumn[0] > ConfigManager.getRows()) {
          plugin.getLogger().warning(String.format(""String_Node_Str"",startColumn[0],ConfigManager.getRows(),ConfigManager.getRows() - 1));
          startColumn[0]=ConfigManager.getRows() - 1;
        }
      }
    }
);
    line=findTag(line,PATTERN_MAXPLAYERS,matcher -> {
      maxplayers[0]=Integer.parseInt(matcher.group(1));
    }
);
    sortrules.addAll(g_sort);
    PlayerSorter sorter=parseSortrules(sortrules);
    Matcher fillplayersMatcher=PATTERN_FILLPLAYERS.matcher(line);
    if (fillplayersMatcher.matches()) {
      SlotTemplate prefix=SlotTemplate.of(g_prefix,parseSlot(fillplayersMatcher.group(""String_Node_Str"")));
      SlotTemplate suffix=SlotTemplate.of(parseSlot(fillplayersMatcher.group(""String_Node_Str"")),g_suffix);
      String args=fillplayersMatcher.group(""String_Node_Str"");
      List<String> filter;
      if (args == null || args.isEmpty()) {
        filter=new ArrayList<>();
      }
 else {
        filter=new ArrayList<>(Arrays.asList(args.split(""String_Node_Str"")));
      }
      checkServer(filter);
      filter.addAll(g_filter);
      sections.add(group -> {
        List<String> finalFilters=new ArrayList<>();
        finalFilters.addAll(filter);
        finalFilters.addAll(group.getServerNames());
        return new FillPlayersSection(startColumn[0],finalFilters,prefix,suffix,sorter,maxplayers[0],playerLines,morePlayerLines);
      }
);
    }
 else {
      SlotTemplate slotTemplate=SlotTemplate.of(g_prefix,parseSlot(line),g_suffix);
      sections.add(group -> {
        ServerSection serverSection=new ServerSection(startColumn[0],group);
        serverSection.add(slotTemplate);
        return serverSection;
      }
);
    }
  }
  return new AutoFillPlayers(list,sections,config.showEmptyGroups);
}","public AutoFillPlayers parseServerSections(TabListConfig config,SlotTemplate g_prefix,SlotTemplate g_suffix,List<String> g_filter,List<String> g_sort,int g_maxPlayers,List<SlotTemplate> playerLines,List<SlotTemplate> morePlayerLines){
  Map<String,ServerInfo> servers=ProxyServer.getInstance().getServers();
  Set<String> serverSet=new HashSet<>(servers.keySet());
  HashMultimap<String,String> aliasToServerMap=HashMultimap.create();
  for (  Map.Entry<String,String> entry : BungeeTabListPlus.getInstance().getConfigManager().getMainConfig().serverAlias.entrySet()) {
    if (ProxyServer.getInstance().getServerInfo(entry.getKey()) == null) {
      BungeeTabListPlus.getInstance().getLogger().warning(""String_Node_Str"" + entry.getKey() + ""String_Node_Str"");
      continue;
    }
    aliasToServerMap.put(entry.getValue(),entry.getKey());
  }
  List<ServerGroup> list=new ArrayList<>();
  while (!serverSet.isEmpty()) {
    String server=serverSet.iterator().next();
    String alias=BungeeTabListPlus.getInstance().getConfigManager().getMainConfig().serverAlias.get(server);
    if (alias != null) {
      Set<String> strings=aliasToServerMap.get(alias);
      serverSet.removeAll(strings);
      list.add(GenericServerGroup.of(strings,alias));
    }
 else {
      serverSet.remove(server);
      list.add(GenericServerGroup.of(server));
    }
  }
  List<Function<ServerGroup,Section>> sections=new ArrayList<>();
  for (  String line : config.groupLines) {
    final int[] startColumn={-1};
    final List<String> sortrules=new ArrayList<>();
    final int[] maxplayers={g_maxPlayers};
    line=findTag(line,PATTERN_ALIGN_LEFT,matcher -> {
      if (config.verticalMode) {
        plugin.getLogger().warning(""String_Node_Str"");
      }
 else {
        startColumn[0]=0;
      }
    }
);
    line=findTag(line,PATTERN_ALIGN_RIGHT,matcher -> {
      if (config.verticalMode) {
        plugin.getLogger().warning(""String_Node_Str"");
      }
 else {
        startColumn[0]=ConfigManager.getCols() - 1;
      }
    }
);
    line=findTag(line,PATTERN_SORT,matcher -> {
      sortrules.addAll(Arrays.asList(matcher.group(1).split(""String_Node_Str"")));
    }
);
    line=findTag(line,PATTERN_COLUMN,matcher -> {
      if (config.verticalMode) {
        plugin.getLogger().warning(""String_Node_Str"");
      }
 else {
        startColumn[0]=Integer.parseInt(matcher.group(1));
        if (startColumn[0] > ConfigManager.getCols()) {
          plugin.getLogger().warning(String.format(""String_Node_Str"",startColumn[0],ConfigManager.getCols(),ConfigManager.getCols() - 1));
          startColumn[0]=ConfigManager.getCols() - 1;
        }
      }
    }
);
    line=findTag(line,PATTERN_ROW,matcher -> {
      if (!config.verticalMode) {
        plugin.getLogger().warning(""String_Node_Str"");
      }
 else {
        startColumn[0]=Integer.parseInt(matcher.group(1));
        if (startColumn[0] > ConfigManager.getRows()) {
          plugin.getLogger().warning(String.format(""String_Node_Str"",startColumn[0],ConfigManager.getRows(),ConfigManager.getRows() - 1));
          startColumn[0]=ConfigManager.getRows() - 1;
        }
      }
    }
);
    line=findTag(line,PATTERN_MAXPLAYERS,matcher -> {
      maxplayers[0]=Integer.parseInt(matcher.group(1));
    }
);
    sortrules.addAll(g_sort);
    PlayerSorter sorter=parseSortrules(sortrules);
    Matcher fillplayersMatcher=PATTERN_FILLPLAYERS.matcher(line);
    if (fillplayersMatcher.matches()) {
      SlotTemplate prefix=SlotTemplate.of(g_prefix,parseSlot(fillplayersMatcher.group(""String_Node_Str"")));
      SlotTemplate suffix=SlotTemplate.of(parseSlot(fillplayersMatcher.group(""String_Node_Str"")),g_suffix);
      String args=fillplayersMatcher.group(""String_Node_Str"");
      List<String> filter;
      if (args == null || args.isEmpty()) {
        filter=new ArrayList<>();
      }
 else {
        filter=new ArrayList<>(Arrays.asList(args.split(""String_Node_Str"")));
      }
      checkServer(filter);
      filter.addAll(g_filter);
      sections.add(group -> {
        List<String> finalFilters=new ArrayList<>();
        finalFilters.addAll(filter);
        finalFilters.addAll(group.getServerNames());
        return new FillPlayersSection(startColumn[0],finalFilters,prefix,suffix,sorter,maxplayers[0],playerLines,morePlayerLines);
      }
);
    }
 else {
      SlotTemplate slotTemplate=SlotTemplate.of(g_prefix,parseSlot(line),g_suffix);
      sections.add(group -> {
        ServerSection serverSection=new ServerSection(startColumn[0],group);
        serverSection.add(slotTemplate);
        return serverSection;
      }
);
    }
  }
  return new AutoFillPlayers(list,sections,config.showEmptyGroups);
}",0.9984997856836691
80894,"public String getSuffix(IPlayer player){
  String suffix=null;
  Plugin p=plugin.getProxy().getPluginManager().getPlugin(""String_Node_Str"");
  if (p != null) {
    BungeePerms bp=BungeePerms.getInstance();
    try {
      PermissionsManager pm=bp.getPermissionsManager();
      if (pm != null) {
        User user=pm.getUser(player.getName());
        if (user != null) {
          suffix=pm.getMainGroup(user).getSuffix();
        }
      }
    }
 catch (    NullPointerException ex) {
      BungeeTabListPlus.getInstance().getLogger().log(Level.SEVERE,""String_Node_Str"",ex);
    }
catch (    Throwable th) {
      BungeeTabListPlus.getInstance().reportError(th);
    }
  }
  Optional<String> vsuffix=plugin.getBridge().getPlayerInformation(player,Values.Player.Vault.Suffix);
  String mode=plugin.getConfigManager().getMainConfig().permissionSource;
  if (mode.equalsIgnoreCase(""String_Node_Str"")) {
    return suffix;
  }
 else   if (mode.equalsIgnoreCase(""String_Node_Str"")) {
    return vsuffix.orElse(""String_Node_Str"");
  }
  if (suffix != null) {
    return suffix;
  }
  if (vsuffix.isPresent()) {
    return vsuffix.get();
  }
  return ""String_Node_Str"";
}","public String getSuffix(IPlayer player){
  String suffix=null;
  Plugin p=plugin.getProxy().getPluginManager().getPlugin(""String_Node_Str"");
  if (p != null) {
    BungeePerms bp=BungeePerms.getInstance();
    try {
      PermissionsManager pm=bp.getPermissionsManager();
      if (pm != null) {
        User user=pm.getUser(player.getName());
        if (user != null) {
          Group group=pm.getMainGroup(user);
          if (group != null) {
            suffix=group.getSuffix();
          }
        }
      }
    }
 catch (    NullPointerException ex) {
      BungeeTabListPlus.getInstance().getLogger().log(Level.SEVERE,""String_Node_Str"",ex);
    }
catch (    Throwable th) {
      BungeeTabListPlus.getInstance().reportError(th);
    }
  }
  Optional<String> vsuffix=plugin.getBridge().getPlayerInformation(player,Values.Player.Vault.Suffix);
  String mode=plugin.getConfigManager().getMainConfig().permissionSource;
  if (mode.equalsIgnoreCase(""String_Node_Str"")) {
    return suffix;
  }
 else   if (mode.equalsIgnoreCase(""String_Node_Str"")) {
    return vsuffix.orElse(""String_Node_Str"");
  }
  if (suffix != null) {
    return suffix;
  }
  if (vsuffix.isPresent()) {
    return vsuffix.get();
  }
  return ""String_Node_Str"";
}",0.9534497090606816
80895,"public String getPrefix(IPlayer player){
  String bpprefix=null;
  Plugin p=plugin.getProxy().getPluginManager().getPlugin(""String_Node_Str"");
  if (p != null) {
    BungeePerms bp=BungeePerms.getInstance();
    try {
      PermissionsManager pm=bp.getPermissionsManager();
      if (pm != null) {
        User user=pm.getUser(player.getName());
        if (user != null) {
          bpprefix=pm.getMainGroup(user).getPrefix();
        }
      }
    }
 catch (    NullPointerException ex) {
      BungeeTabListPlus.getInstance().getLogger().log(Level.SEVERE,""String_Node_Str"",ex);
    }
catch (    Throwable th) {
      BungeeTabListPlus.getInstance().reportError(th);
    }
  }
  String bprefix=plugin.getConfigManager().getMainConfig().prefixes.get(getMainGroup(player));
  Optional<String> vprefix=plugin.getBridge().getPlayerInformation(player,Values.Player.Vault.Prefix);
  String mode=plugin.getConfigManager().getMainConfig().permissionSource;
  if (mode.equalsIgnoreCase(""String_Node_Str"")) {
    return bpprefix != null ? bpprefix : ""String_Node_Str"";
  }
 else   if (mode.equalsIgnoreCase(""String_Node_Str"")) {
    return vprefix.isPresent() ? vprefix.get() : ""String_Node_Str"";
  }
 else   if (mode.equalsIgnoreCase(""String_Node_Str"")) {
    return bprefix != null ? bprefix : ""String_Node_Str"";
  }
  if (bprefix != null) {
    return bprefix;
  }
  if (bpprefix != null) {
    return bpprefix;
  }
  if (vprefix.isPresent()) {
    return vprefix.get();
  }
  return ""String_Node_Str"";
}","public String getPrefix(IPlayer player){
  String bpprefix=null;
  Plugin p=plugin.getProxy().getPluginManager().getPlugin(""String_Node_Str"");
  if (p != null) {
    BungeePerms bp=BungeePerms.getInstance();
    try {
      PermissionsManager pm=bp.getPermissionsManager();
      if (pm != null) {
        User user=pm.getUser(player.getName());
        if (user != null) {
          Group mainGroup=pm.getMainGroup(user);
          if (mainGroup != null) {
            bpprefix=mainGroup.getPrefix();
          }
        }
      }
    }
 catch (    NullPointerException ex) {
      BungeeTabListPlus.getInstance().getLogger().log(Level.SEVERE,""String_Node_Str"",ex);
    }
catch (    Throwable th) {
      BungeeTabListPlus.getInstance().reportError(th);
    }
  }
  String bprefix=plugin.getConfigManager().getMainConfig().prefixes.get(getMainGroup(player));
  Optional<String> vprefix=plugin.getBridge().getPlayerInformation(player,Values.Player.Vault.Prefix);
  String mode=plugin.getConfigManager().getMainConfig().permissionSource;
  if (mode.equalsIgnoreCase(""String_Node_Str"")) {
    return bpprefix != null ? bpprefix : ""String_Node_Str"";
  }
 else   if (mode.equalsIgnoreCase(""String_Node_Str"")) {
    return vprefix.isPresent() ? vprefix.get() : ""String_Node_Str"";
  }
 else   if (mode.equalsIgnoreCase(""String_Node_Str"")) {
    return bprefix != null ? bprefix : ""String_Node_Str"";
  }
  if (bprefix != null) {
    return bprefix;
  }
  if (bpprefix != null) {
    return bpprefix;
  }
  if (vprefix.isPresent()) {
    return vprefix.get();
  }
  return ""String_Node_Str"";
}",0.9584954604409858
80896,"public String getDisplayPrefix(IPlayer player){
  String display=null;
  Plugin p=plugin.getProxy().getPluginManager().getPlugin(""String_Node_Str"");
  if (p != null) {
    BungeePerms bp=BungeePerms.getInstance();
    try {
      PermissionsManager pm=bp.getPermissionsManager();
      if (pm != null) {
        User user=pm.getUser(player.getName());
        if (user != null) {
          display=pm.getMainGroup(user).getDisplay();
        }
      }
    }
 catch (    NullPointerException ex) {
      BungeeTabListPlus.getInstance().getLogger().log(Level.SEVERE,""String_Node_Str"",ex);
    }
catch (    Throwable th) {
      BungeeTabListPlus.getInstance().reportError(th);
    }
  }
  if (display == null) {
    display=""String_Node_Str"";
  }
  return display;
}","public String getDisplayPrefix(IPlayer player){
  String display=null;
  Plugin p=plugin.getProxy().getPluginManager().getPlugin(""String_Node_Str"");
  if (p != null) {
    BungeePerms bp=BungeePerms.getInstance();
    try {
      PermissionsManager pm=bp.getPermissionsManager();
      if (pm != null) {
        User user=pm.getUser(player.getName());
        if (user != null) {
          Group group=pm.getMainGroup(user);
          if (group != null) {
            display=group.getDisplay();
          }
        }
      }
    }
 catch (    NullPointerException ex) {
      BungeeTabListPlus.getInstance().getLogger().log(Level.SEVERE,""String_Node_Str"",ex);
    }
catch (    Throwable th) {
      BungeeTabListPlus.getInstance().reportError(th);
    }
  }
  if (display == null) {
    display=""String_Node_Str"";
  }
  return display;
}",0.9275905118601748
80897,"/** 
 * Called when the plugin is enabled
 */
public void onEnable(){
  INSTANCE=this;
  try {
    config=new ConfigManager(plugin);
  }
 catch (  InvalidConfigurationException ex) {
    plugin.getLogger().warning(""String_Node_Str"");
    plugin.getLogger().log(Level.WARNING,null,ex);
    plugin.getLogger().warning(""String_Node_Str"");
    return;
  }
  if (config.getMainConfig().automaticallySendBugReports) {
    BugReportingService bugReportingService=new BugReportingService(Level.SEVERE,getPlugin().getDescription().getName(),getPlugin().getDescription().getVersion(),command -> plugin.getProxy().getScheduler().runAsync(plugin,command));
    bugReportingService.registerLogger(getLogger());
  }
  try {
    Class.forName(""String_Node_Str"");
  }
 catch (  ClassNotFoundException ex) {
    is18=false;
  }
  try {
    Class.forName(""String_Node_Str"");
    isAbove995=true;
  }
 catch (  ClassNotFoundException ex) {
    isAbove995=false;
  }
  legacyPacketAccess=new LegacyPacketAccessImpl();
  if (!legacyPacketAccess.isTabModificationSupported()) {
    plugin.getLogger().warning(""String_Node_Str"");
    plugin.getLogger().warning(""String_Node_Str"");
    return;
  }
  if ((!legacyPacketAccess.isScoreboardSupported()) && config.getMainConfig().useScoreboardToBypass16CharLimit) {
    plugin.getLogger().warning(""String_Node_Str"");
    plugin.getLogger().warning(""String_Node_Str"");
    config.getMainConfig().useScoreboardToBypass16CharLimit=false;
  }
  if (isVersion18()) {
    packetAccess=new PacketAccessImpl(getLogger());
    if (!packetAccess.isTabHeaderFooterSupported()) {
      plugin.getLogger().warning(""String_Node_Str"");
    }
    skins=new SkinManager(plugin);
  }
  if (config.getMainConfig().pingDelay > 0) {
    for (    ServerInfo server : plugin.getProxy().getServers().values()) {
      PingTask task=new PingTask(server);
      serverState.put(server.getName(),task);
      plugin.getProxy().getScheduler().schedule(plugin,task,config.getMainConfig().pingDelay,config.getMainConfig().pingDelay,TimeUnit.SECONDS);
    }
  }
  fakePlayerManager=new FakePlayerManager(plugin);
  Collection<IPlayerProvider> playerProviders=new ArrayList<>();
  playerProviders.add(fakePlayerManager);
  if (plugin.getProxy().getPluginManager().getPlugin(""String_Node_Str"") != null) {
    playerProviders.add(new RedisPlayerProvider());
    plugin.getLogger().info(""String_Node_Str"");
  }
 else {
    playerProviders.add(bungeePlayerProvider);
  }
  players=new PlayerManager(this,playerProviders);
  tabLists=new TabListManager(this);
  if (!tabLists.loadTabLists()) {
    return;
  }
  plugin.getProxy().registerChannel(Constants.channel);
  bukkitBridge=new BukkitBridge(this);
  pm=new PermissionManager(this);
  variables=new VariablesManager();
  if (plugin.getProxy().getPluginManager().getPlugin(""String_Node_Str"") != null) {
    protocolVersionProvider=new ProtocolSupportVersionProvider();
  }
 else {
    protocolVersionProvider=new BungeeProtocolVersionProvider();
  }
  ProxyServer.getInstance().getPluginManager().registerListener(plugin,listener);
  ResendThread resendThread=new ResendThread(resendQueue,config.getMainConfig().tablistUpdateIntervall);
  plugin.getProxy().getScheduler().schedule(plugin,resendThread,1,TimeUnit.SECONDS);
  startRefreshThread();
  try {
    Thread.currentThread().getContextClassLoader().loadClass(""String_Node_Str"");
    ProxyServer.getInstance().getPluginManager().registerCommand(plugin,new SuperCommand(this));
    ProxyServer.getInstance().getScheduler().schedule(plugin,new UpdateNotifier(this),15,15,TimeUnit.MINUTES);
  }
 catch (  Exception ex) {
    ProxyServer.getInstance().getPluginManager().registerCommand(plugin,new OldSuperCommand(this));
  }
  try {
    Metrics metrics=new Metrics(plugin);
    metrics.start();
  }
 catch (  IOException e) {
    plugin.getLogger().log(Level.SEVERE,""String_Node_Str"",e);
  }
  if (config.getMainConfig().checkForUpdates) {
    updateChecker=new UpdateChecker(plugin);
  }
  if (isVersion18()) {
    try {
      List<Integer> supportedProtocolVersions=Arrays.stream(ProtocolConstants.class.getDeclaredFields()).filter(f -> (f.getModifiers() & 8) != 0).filter(f -> f.getType() == int.class).map(f -> {
        try {
          f.setAccessible(true);
          return f.getInt(null);
        }
 catch (        IllegalAccessException e) {
          reportError(e);
          return 0;
        }
      }
).collect(Collectors.toList());
      int maxProtocolVersion=supportedProtocolVersions.stream().mapToInt(Integer::intValue).max().getAsInt();
      if (maxProtocolVersion > 47) {
        Class clazz=Protocol.DirectionData.class;
        Method registerPacket=clazz.getDeclaredMethod(""String_Node_Str"",int.class,int.class,Class.class);
        Method getId=clazz.getDeclaredMethod(""String_Node_Str"",Class.class,int.class);
        getId.setAccessible(true);
        registerPacket.setAccessible(true);
        registerPacket.invoke(Protocol.GAME.TO_CLIENT,62,getId.invoke(Protocol.GAME.TO_CLIENT,Team.class,maxProtocolVersion),TeamPacket.class);
      }
 else {
        Class clazz=Protocol.DirectionData.class;
        Method registerPacket=clazz.getDeclaredMethod(""String_Node_Str"",int.class,Class.class);
        registerPacket.setAccessible(true);
        registerPacket.invoke(Protocol.GAME.TO_CLIENT,62,TeamPacket.class);
      }
    }
 catch (    IllegalArgumentException|NoSuchMethodException|SecurityException|InvocationTargetException|IllegalAccessException ex) {
      getLogger().log(Level.SEVERE,""String_Node_Str"",ex);
    }
  }
}","/** 
 * Called when the plugin is enabled
 */
public void onEnable(){
  INSTANCE=this;
  try {
    config=new ConfigManager(plugin);
  }
 catch (  InvalidConfigurationException ex) {
    plugin.getLogger().warning(""String_Node_Str"");
    plugin.getLogger().log(Level.WARNING,null,ex);
    plugin.getLogger().warning(""String_Node_Str"");
    return;
  }
  if (config.getMainConfig().automaticallySendBugReports) {
    BugReportingService bugReportingService=new BugReportingService(Level.SEVERE,getPlugin().getDescription().getName(),getPlugin().getDescription().getVersion(),command -> plugin.getProxy().getScheduler().runAsync(plugin,command));
    bugReportingService.registerLogger(getLogger());
  }
  try {
    Class.forName(""String_Node_Str"");
  }
 catch (  ClassNotFoundException ex) {
    is18=false;
  }
  try {
    Class.forName(""String_Node_Str"");
    isAbove995=true;
  }
 catch (  ClassNotFoundException ex) {
    isAbove995=false;
  }
  legacyPacketAccess=new LegacyPacketAccessImpl();
  if (!legacyPacketAccess.isTabModificationSupported()) {
    plugin.getLogger().warning(""String_Node_Str"");
    plugin.getLogger().warning(""String_Node_Str"");
    return;
  }
  if ((!legacyPacketAccess.isScoreboardSupported()) && config.getMainConfig().useScoreboardToBypass16CharLimit) {
    plugin.getLogger().warning(""String_Node_Str"");
    plugin.getLogger().warning(""String_Node_Str"");
    config.getMainConfig().useScoreboardToBypass16CharLimit=false;
  }
  if (isVersion18()) {
    packetAccess=new PacketAccessImpl(getLogger());
    if (!packetAccess.isTabHeaderFooterSupported()) {
      plugin.getLogger().warning(""String_Node_Str"");
    }
    skins=new SkinManager(plugin);
  }
  if (config.getMainConfig().pingDelay > 0) {
    for (    ServerInfo server : plugin.getProxy().getServers().values()) {
      PingTask task=new PingTask(server);
      serverState.put(server.getName(),task);
      plugin.getProxy().getScheduler().schedule(plugin,task,config.getMainConfig().pingDelay,config.getMainConfig().pingDelay,TimeUnit.SECONDS);
    }
  }
  fakePlayerManager=new FakePlayerManager(plugin);
  playerProviders=new ArrayList<>();
  playerProviders.add(fakePlayerManager);
  if (plugin.getProxy().getPluginManager().getPlugin(""String_Node_Str"") != null) {
    playerProviders.add(new RedisPlayerProvider());
    plugin.getLogger().info(""String_Node_Str"");
  }
 else {
    playerProviders.add(bungeePlayerProvider);
  }
  tabLists=new TabListManager(this);
  if (!tabLists.loadTabLists()) {
    return;
  }
  plugin.getProxy().registerChannel(Constants.channel);
  bukkitBridge=new BukkitBridge(this);
  pm=new PermissionManager(this);
  variables=new VariablesManager();
  if (plugin.getProxy().getPluginManager().getPlugin(""String_Node_Str"") != null) {
    protocolVersionProvider=new ProtocolSupportVersionProvider();
  }
 else {
    protocolVersionProvider=new BungeeProtocolVersionProvider();
  }
  ProxyServer.getInstance().getPluginManager().registerListener(plugin,listener);
  ResendThread resendThread=new ResendThread(resendQueue,config.getMainConfig().tablistUpdateIntervall);
  plugin.getProxy().getScheduler().schedule(plugin,resendThread,1,TimeUnit.SECONDS);
  startRefreshThread();
  try {
    Thread.currentThread().getContextClassLoader().loadClass(""String_Node_Str"");
    ProxyServer.getInstance().getPluginManager().registerCommand(plugin,new SuperCommand(this));
    ProxyServer.getInstance().getScheduler().schedule(plugin,new UpdateNotifier(this),15,15,TimeUnit.MINUTES);
  }
 catch (  Exception ex) {
    ProxyServer.getInstance().getPluginManager().registerCommand(plugin,new OldSuperCommand(this));
  }
  try {
    Metrics metrics=new Metrics(plugin);
    metrics.start();
  }
 catch (  IOException e) {
    plugin.getLogger().log(Level.SEVERE,""String_Node_Str"",e);
  }
  if (config.getMainConfig().checkForUpdates) {
    updateChecker=new UpdateChecker(plugin);
  }
  if (isVersion18()) {
    try {
      List<Integer> supportedProtocolVersions=Arrays.stream(ProtocolConstants.class.getDeclaredFields()).filter(f -> (f.getModifiers() & 8) != 0).filter(f -> f.getType() == int.class).map(f -> {
        try {
          f.setAccessible(true);
          return f.getInt(null);
        }
 catch (        IllegalAccessException e) {
          reportError(e);
          return 0;
        }
      }
).collect(Collectors.toList());
      int maxProtocolVersion=supportedProtocolVersions.stream().mapToInt(Integer::intValue).max().getAsInt();
      if (maxProtocolVersion > 47) {
        Class clazz=Protocol.DirectionData.class;
        Method registerPacket=clazz.getDeclaredMethod(""String_Node_Str"",int.class,int.class,Class.class);
        Method getId=clazz.getDeclaredMethod(""String_Node_Str"",Class.class,int.class);
        getId.setAccessible(true);
        registerPacket.setAccessible(true);
        registerPacket.invoke(Protocol.GAME.TO_CLIENT,62,getId.invoke(Protocol.GAME.TO_CLIENT,Team.class,maxProtocolVersion),TeamPacket.class);
      }
 else {
        Class clazz=Protocol.DirectionData.class;
        Method registerPacket=clazz.getDeclaredMethod(""String_Node_Str"",int.class,Class.class);
        registerPacket.setAccessible(true);
        registerPacket.invoke(Protocol.GAME.TO_CLIENT,62,TeamPacket.class);
      }
    }
 catch (    IllegalArgumentException|NoSuchMethodException|SecurityException|InvocationTargetException|IllegalAccessException ex) {
      getLogger().log(Level.SEVERE,""String_Node_Str"",ex);
    }
  }
}",0.9928305653870588
80898,"private void update(PlayerTablistHandler tablistHandler){
  if (tablistHandler.getPlayer().getServer() != null) {
    if (BungeeTabListPlus.getInstance().getConfigManager().getMainConfig().excludeServers.contains(tablistHandler.getPlayer().getServer().getInfo().getName()) || tablistHandler.isExcluded()) {
      tablistHandler.unload();
      return;
    }
  }
  ITabListProvider tlp=BungeeTabListPlus.getInstance().getTabListManager().getTabListForPlayer(tablistHandler.getPlayer());
  if (tlp == null) {
    tablistHandler.exclude();
    tablistHandler.unload();
    return;
  }
  ITabList tabList=new TabList();
  try {
    tlp.fillTabList(tablistHandler.getPlayer(),tabList);
  }
 catch (  LayoutException ex) {
    BungeeTabListPlus.getInstance().getLogger().log(Level.WARNING,""String_Node_Str"",ex);
  }
catch (  Throwable th) {
    BungeeTabListPlus.getInstance().getLogger().log(Level.SEVERE,""String_Node_Str"",th);
  }
  tablistHandler.sendTablist(tabList);
}","private void update(PlayerTablistHandler tablistHandler){
  if (tablistHandler.getPlayer().getServer() != null) {
    if (BungeeTabListPlus.getInstance().getConfigManager().getMainConfig().excludeServers.contains(tablistHandler.getPlayer().getServer().getInfo().getName()) || tablistHandler.isExcluded()) {
      tablistHandler.unload();
      return;
    }
  }
  ITabListProvider tlp=BungeeTabListPlus.getInstance().getTabListManager().getTabListForPlayer(tablistHandler.getPlayer());
  if (tlp == null) {
    tablistHandler.exclude();
    tablistHandler.unload();
    return;
  }
  ITabList tabList=new TabList();
  TabListContext context=new TabListContextImpl(tabList.getRows(),tabList.getColumns(),tablistHandler.getPlayer(),BungeeTabListPlus.getInstance().constructPlayerManager());
  try {
    tlp.fillTabList(tablistHandler.getPlayer(),tabList,context);
  }
 catch (  LayoutException ex) {
    BungeeTabListPlus.getInstance().getLogger().log(Level.WARNING,""String_Node_Str"",ex);
  }
catch (  Throwable th) {
    BungeeTabListPlus.getInstance().getLogger().log(Level.SEVERE,""String_Node_Str"",th);
  }
  tablistHandler.sendTablist(tabList,context);
}",0.9090909090909092
80899,"void fillTabList(ProxiedPlayer player,ITabList ITabList) throws LayoutException ;","void fillTabList(ProxiedPlayer player,ITabList ITabList,TabListContext context) throws LayoutException ;",0.8756756756756757
80900,"String getReplacement(ProxiedPlayer viewer,List<ServerInfo> servers,String args);","String getReplacement(ProxiedPlayer viewer,List<ServerInfo> servers,String args,TabListContext context);",0.8756756756756757
80901,"String getReplacement(ProxiedPlayer viewer,String args);","String getReplacement(ProxiedPlayer viewer,String args,TabListContext context);",0.8296296296296296
80902,"private void checkServer(List<String> filter){
  for (  String s : filter) {
    if (plugin.getPlayerManager().isServer(s)) {
      plugin.getLogger().warning(ChatColor.RED + ""String_Node_Str"");
    }
    if (s.equalsIgnoreCase(""String_Node_Str"")) {
      plugin.getLogger().warning(ChatColor.RED + ""String_Node_Str"");
    }
  }
}","private void checkServer(List<String> filter){
  for (  String s : filter) {
    if (plugin.isServer(s)) {
      plugin.getLogger().warning(ChatColor.RED + ""String_Node_Str"");
    }
    if (s.equalsIgnoreCase(""String_Node_Str"")) {
      plugin.getLogger().warning(ChatColor.RED + ""String_Node_Str"");
    }
  }
}",0.970358814352574
80903,"@Override public int compare(String s1,String s2){
  int p1=plugin.getPlayerManager().getServerPlayerCount(s1,player,plugin.getConfigManager().getMainConfig().showPlayersInGamemode3);
  int p2=plugin.getPlayerManager().getServerPlayerCount(s2,player,plugin.getConfigManager().getMainConfig().showPlayersInGamemode3);
  if (p1 < p2) {
    return 1;
  }
  if (p1 > p2) {
    return -1;
  }
  return s1.compareTo(s2);
}","@Override public int compare(String s1,String s2){
  int p1=context.getPlayerManager().getServerPlayerCount(s1,player,plugin.getConfigManager().getMainConfig().showPlayersInGamemode3);
  int p2=context.getPlayerManager().getServerPlayerCount(s2,player,plugin.getConfigManager().getMainConfig().showPlayersInGamemode3);
  if (p1 < p2) {
    return 1;
  }
  if (p1 > p2) {
    return -1;
  }
  return s1.compareTo(s2);
}",0.9688249400479616
80904,"@Override public void fillTabList(ProxiedPlayer player,ITabList tabList) throws LayoutException {
  if (config.verticalMode) {
    tabList=tabList.flip();
  }
  if (config.autoShrinkTabList) {
    tabList.setShouldShrink(true);
  }
  List<Section> topSections=new ArrayList<>(top);
  List<Section> botSections=new ArrayList<>(bot);
  parseAutoFillplayers(player,topSections);
  parseAutoFillplayers(player,botSections);
  TabListContext context=new TabListContextImpl(tabList.getRows(),tabList.getColumns(),player);
  precalculateSections(context,topSections);
  precalculateSections(context,botSections);
  for (Iterator<Section> iterator=topSections.iterator(); iterator.hasNext(); ) {
    Section topSection=iterator.next();
    if (topSection.getMaxSize() == 0) {
      iterator.remove();
    }
  }
  for (Iterator<Section> iterator=botSections.iterator(); iterator.hasNext(); ) {
    Section botSection=iterator.next();
    if (botSection.getMaxSize() == 0) {
      iterator.remove();
    }
  }
  Layout<Section> layout=layoutManager.calculateLayout(topSections,botSections,context);
  for (int i=0; i < tabList.getSize(); i++) {
    Optional<Layout<Section>.SlotData> slotData=layout.getSlotData(i);
    if (slotData.isPresent()) {
      Layout<Section>.SlotData data=slotData.get();
      if (data.getSlotIndex() == 0) {
        data.getSection().calculate(context,tabList,i,data.getSectionSize());
      }
    }
  }
  if (this.config.shownFooterHeader) {
    String header=config.header;
    header=plugin.getVariablesManager().replacePlayerVariables(player,header,plugin.getBungeePlayerProvider().wrapPlayer(player));
    header=plugin.getVariablesManager().replaceVariables(player,header);
    header=ChatColor.translateAlternateColorCodes('&',header);
    header=header.replaceAll(""String_Node_Str"",""String_Node_Str"");
    tabList.setHeader(header);
    String footer=config.footer;
    footer=plugin.getVariablesManager().replacePlayerVariables(player,footer,plugin.getBungeePlayerProvider().wrapPlayer(player));
    footer=plugin.getVariablesManager().replaceVariables(player,footer);
    footer=ChatColor.translateAlternateColorCodes('&',footer);
    footer=footer.replaceAll(""String_Node_Str"",""String_Node_Str"");
    tabList.setFooter(footer);
  }
  if (BungeeTabListPlus.isVersion18()) {
    tabList.setDefaultSkin(plugin.getSkinManager().getSkin(config.defaultSkin));
  }
  tabList.setDefaultPing(config.defaultPing);
}","@Override public void fillTabList(ProxiedPlayer player,ITabList tabList,TabListContext context) throws LayoutException {
  if (config.verticalMode) {
    tabList=tabList.flip();
  }
  if (config.autoShrinkTabList) {
    tabList.setShouldShrink(true);
  }
  List<Section> topSections=new ArrayList<>(top);
  List<Section> botSections=new ArrayList<>(bot);
  parseAutoFillplayers(player,topSections,context);
  parseAutoFillplayers(player,botSections,context);
  precalculateSections(context,topSections);
  precalculateSections(context,botSections);
  for (Iterator<Section> iterator=topSections.iterator(); iterator.hasNext(); ) {
    Section topSection=iterator.next();
    if (topSection.getMaxSize() == 0) {
      iterator.remove();
    }
  }
  for (Iterator<Section> iterator=botSections.iterator(); iterator.hasNext(); ) {
    Section botSection=iterator.next();
    if (botSection.getMaxSize() == 0) {
      iterator.remove();
    }
  }
  Layout<Section> layout=layoutManager.calculateLayout(topSections,botSections,context);
  for (int i=0; i < tabList.getSize(); i++) {
    Optional<Layout<Section>.SlotData> slotData=layout.getSlotData(i);
    if (slotData.isPresent()) {
      Layout<Section>.SlotData data=slotData.get();
      if (data.getSlotIndex() == 0) {
        data.getSection().calculate(context,tabList,i,data.getSectionSize());
      }
    }
  }
  if (this.config.shownFooterHeader) {
    String header=config.header;
    header=plugin.getVariablesManager().replacePlayerVariables(player,header,plugin.getBungeePlayerProvider().wrapPlayer(player),context);
    header=plugin.getVariablesManager().replaceVariables(player,header,context);
    header=ChatColor.translateAlternateColorCodes('&',header);
    header=header.replaceAll(""String_Node_Str"",""String_Node_Str"");
    tabList.setHeader(header);
    String footer=config.footer;
    footer=plugin.getVariablesManager().replacePlayerVariables(player,footer,plugin.getBungeePlayerProvider().wrapPlayer(player),context);
    footer=plugin.getVariablesManager().replaceVariables(player,footer,context);
    footer=ChatColor.translateAlternateColorCodes('&',footer);
    footer=footer.replaceAll(""String_Node_Str"",""String_Node_Str"");
    tabList.setFooter(footer);
  }
  if (BungeeTabListPlus.isVersion18()) {
    tabList.setDefaultSkin(plugin.getSkinManager().getSkin(config.defaultSkin));
  }
  tabList.setDefaultPing(config.defaultPing);
}",0.9680214565710747
80905,"private void parseAutoFillplayers(final ProxiedPlayer player,List<Section> sectionList){
  for (int i=0; i < sectionList.size(); i++) {
    Section section=sectionList.get(i);
    if (section instanceof AutoFillPlayers) {
      sectionList.remove(i);
      String prefix=((AutoFillPlayers)section).prefix;
      String suffix=((AutoFillPlayers)section).suffix;
      int maxPlayers=((AutoFillPlayers)section).maxPlayers;
      List<String> sortRules=((AutoFillPlayers)section).sortRules;
      Skin skin=((AutoFillPlayers)section).skin;
      Map<String,ServerInfo> servers=ProxyServer.getInstance().getServers();
      Set<String> serverSet=new HashSet<>(servers.keySet());
      HashMultimap<String,String> aliasToServerMap=HashMultimap.create();
      for (      Map.Entry<String,String> entry : BungeeTabListPlus.getInstance().getConfigManager().getMainConfig().serverAlias.entrySet()) {
        if (ProxyServer.getInstance().getServerInfo(entry.getKey()) == null) {
          BungeeTabListPlus.getInstance().getLogger().warning(""String_Node_Str"" + entry.getKey() + ""String_Node_Str"");
          continue;
        }
        aliasToServerMap.put(entry.getValue(),entry.getKey());
      }
      List<String> list=new ArrayList<>();
      while (!serverSet.isEmpty()) {
        String server=serverSet.iterator().next();
        String alias=BungeeTabListPlus.getInstance().getConfigManager().getMainConfig().serverAlias.get(server);
        if (alias != null) {
          Set<String> strings=aliasToServerMap.get(alias);
          serverSet.removeAll(strings);
          list.add(Joiner.on(',').join(strings));
        }
 else {
          serverSet.remove(server);
          list.add(server);
        }
      }
      Collections.sort(list,new Comparator<String>(){
        @Override public int compare(        String s1,        String s2){
          int p1=plugin.getPlayerManager().getServerPlayerCount(s1,player,plugin.getConfigManager().getMainConfig().showPlayersInGamemode3);
          int p2=plugin.getPlayerManager().getServerPlayerCount(s2,player,plugin.getConfigManager().getMainConfig().showPlayersInGamemode3);
          if (p1 < p2) {
            return 1;
          }
          if (p1 > p2) {
            return -1;
          }
          return s1.compareTo(s2);
        }
      }
);
      int j=i;
      for (      String server : list) {
        if (showEmptyGroups || plugin.getPlayerManager().getPlayerCount(server,player,plugin.getConfigManager().getMainConfig().showPlayersInGamemode3) > 0) {
          try {
            List<Section> sections=parser.parseServerSections(prefix,suffix,skin,new ArrayList<>(0),server,sortRules,maxPlayers);
            for (            Section s : sections) {
              sectionList.add(j++,s);
            }
          }
 catch (          ParseException ex) {
            BungeeTabListPlus.getInstance().reportError(ex);
          }
        }
      }
    }
  }
}","private void parseAutoFillplayers(final ProxiedPlayer player,List<Section> sectionList,TabListContext context){
  for (int i=0; i < sectionList.size(); i++) {
    Section section=sectionList.get(i);
    if (section instanceof AutoFillPlayers) {
      sectionList.remove(i);
      String prefix=((AutoFillPlayers)section).prefix;
      String suffix=((AutoFillPlayers)section).suffix;
      int maxPlayers=((AutoFillPlayers)section).maxPlayers;
      List<String> sortRules=((AutoFillPlayers)section).sortRules;
      Skin skin=((AutoFillPlayers)section).skin;
      Map<String,ServerInfo> servers=ProxyServer.getInstance().getServers();
      Set<String> serverSet=new HashSet<>(servers.keySet());
      HashMultimap<String,String> aliasToServerMap=HashMultimap.create();
      for (      Map.Entry<String,String> entry : BungeeTabListPlus.getInstance().getConfigManager().getMainConfig().serverAlias.entrySet()) {
        if (ProxyServer.getInstance().getServerInfo(entry.getKey()) == null) {
          BungeeTabListPlus.getInstance().getLogger().warning(""String_Node_Str"" + entry.getKey() + ""String_Node_Str"");
          continue;
        }
        aliasToServerMap.put(entry.getValue(),entry.getKey());
      }
      List<String> list=new ArrayList<>();
      while (!serverSet.isEmpty()) {
        String server=serverSet.iterator().next();
        String alias=BungeeTabListPlus.getInstance().getConfigManager().getMainConfig().serverAlias.get(server);
        if (alias != null) {
          Set<String> strings=aliasToServerMap.get(alias);
          serverSet.removeAll(strings);
          list.add(Joiner.on(',').join(strings));
        }
 else {
          serverSet.remove(server);
          list.add(server);
        }
      }
      Collections.sort(list,new Comparator<String>(){
        @Override public int compare(        String s1,        String s2){
          int p1=context.getPlayerManager().getServerPlayerCount(s1,player,plugin.getConfigManager().getMainConfig().showPlayersInGamemode3);
          int p2=context.getPlayerManager().getServerPlayerCount(s2,player,plugin.getConfigManager().getMainConfig().showPlayersInGamemode3);
          if (p1 < p2) {
            return 1;
          }
          if (p1 > p2) {
            return -1;
          }
          return s1.compareTo(s2);
        }
      }
);
      int j=i;
      for (      String server : list) {
        if (showEmptyGroups || context.getPlayerManager().getPlayerCount(server,player,plugin.getConfigManager().getMainConfig().showPlayersInGamemode3) > 0) {
          try {
            List<Section> sections=parser.parseServerSections(prefix,suffix,skin,new ArrayList<>(0),server,sortRules,maxPlayers);
            for (            Section s : sections) {
              sectionList.add(j++,s);
            }
          }
 catch (          ParseException ex) {
            BungeeTabListPlus.getInstance().reportError(ex);
          }
        }
      }
    }
  }
}",0.989423404981235
80906,"public TabListContextImpl(int rows,int columns,ProxiedPlayer player){
  this.rows=rows;
  this.columns=columns;
  this.size=rows * columns;
  this.player=player;
}","public TabListContextImpl(int rows,int columns,ProxiedPlayer player,PlayerManager playerManager){
  this.rows=rows;
  this.columns=columns;
  this.playerManager=playerManager;
  this.size=rows * columns;
  this.player=player;
}",0.8358974358974359
80907,"public PlayerManager(BungeeTabListPlus plugin,Collection<IPlayerProvider> playerProviders){
  this.plugin=plugin;
  this.playerProviders=playerProviders;
}","public PlayerManager(BungeeTabListPlus plugin,Collection<IPlayerProvider> playerProviders){
  this.plugin=plugin;
  this.players=ImmutableList.copyOf(Iterables.concat(Collections2.transform(playerProviders,IPlayerProvider::getPlayers)));
}",0.6700507614213198
80908,"public int getServerPlayerCount(String server,ProxiedPlayer viewer,boolean includeSuspectors){
  int num=0;
  Iterable<IPlayer> players=Iterables.concat(Collections2.transform(playerProviders,new Function<IPlayerProvider,Collection<? extends IPlayer>>(){
    @Override public Collection<? extends IPlayer> apply(    IPlayerProvider iPlayerProvider){
      return iPlayerProvider.getPlayers();
    }
  }
));
  for (  IPlayer p : players) {
    Optional<ServerInfo> s=p.getServer();
    if (s.isPresent()) {
      if (s.get().getName().equalsIgnoreCase(server) && !BungeeTabListPlus.isHidden(p,viewer) && (includeSuspectors || p.getGameMode() != 3)) {
        num++;
      }
    }
  }
  return num;
}","public int getServerPlayerCount(String server,ProxiedPlayer viewer,boolean includeSuspectors){
  int num=0;
  for (  IPlayer p : players) {
    Optional<ServerInfo> s=p.getServer();
    if (s.isPresent()) {
      if (s.get().getName().equalsIgnoreCase(server) && !BungeeTabListPlus.isHidden(p,viewer) && (includeSuspectors || p.getGameMode() != 3)) {
        num++;
      }
    }
  }
  return num;
}",0.7274384685505926
80909,"public List<IPlayer> getPlayers(Collection<String> filter,ProxiedPlayer who,boolean includeSuspectors){
  List<IPlayer> list=new ArrayList<>();
  Iterable<IPlayer> players=Iterables.concat(Collections2.transform(playerProviders,new Function<IPlayerProvider,Iterable<? extends IPlayer>>(){
    @Override public Iterable<? extends IPlayer> apply(    IPlayerProvider iPlayerProvider){
      return iPlayerProvider.getPlayers();
    }
  }
));
  for (  IPlayer p : players) {
    boolean areGroupRules=false;
    boolean areServerRules=false;
    boolean fitGroupRules=false;
    boolean fitServerRules=false;
    String group=plugin.getPermissionManager().getMainGroup(p);
    for (    String rule : filter) {
      if (rule.isEmpty()) {
      }
 else {
        Optional<ServerInfo> server=p.getServer();
        if (rule.equalsIgnoreCase(""String_Node_Str"")) {
          areServerRules=true;
          if (server.isPresent() && who.getServer() != null) {
            if (server.get().getName().equalsIgnoreCase(who.getServer().getInfo().getName())) {
              fitServerRules=true;
            }
          }
        }
 else         if (isServer(rule)) {
          areServerRules=true;
          if (server.isPresent()) {
            if (server.get().getName().equalsIgnoreCase(rule)) {
              fitServerRules=true;
            }
            String[] s=rule.split(""String_Node_Str"");
            if (s.length == 2) {
              if (server.get().getName().equalsIgnoreCase(s[0])) {
                Optional<String> world=plugin.getBridge().getPlayerInformation(p,Values.Player.Bukkit.World);
                if (world.isPresent()) {
                  if (world.get().equalsIgnoreCase(s[1])) {
                    fitServerRules=true;
                  }
                }
              }
            }
          }
        }
 else {
          areGroupRules=true;
          if (group != null) {
            if (group.equalsIgnoreCase(rule)) {
              fitGroupRules=true;
            }
          }
        }
      }
    }
    if (((!areServerRules) || fitServerRules) && ((!areGroupRules) || fitGroupRules) && !BungeeTabListPlus.isHidden(p,who)&& (includeSuspectors || p.getGameMode() != 3)) {
      list.add(p);
    }
  }
  return list;
}","public List<IPlayer> getPlayers(Collection<String> filter,ProxiedPlayer who,boolean includeSuspectors){
  List<IPlayer> list=new ArrayList<>();
  for (  IPlayer p : players) {
    boolean areGroupRules=false;
    boolean areServerRules=false;
    boolean fitGroupRules=false;
    boolean fitServerRules=false;
    String group=plugin.getPermissionManager().getMainGroup(p);
    for (    String rule : filter) {
      if (rule.isEmpty()) {
      }
 else {
        Optional<ServerInfo> server=p.getServer();
        if (rule.equalsIgnoreCase(""String_Node_Str"")) {
          areServerRules=true;
          if (server.isPresent() && who.getServer() != null) {
            if (server.get().getName().equalsIgnoreCase(who.getServer().getInfo().getName())) {
              fitServerRules=true;
            }
          }
        }
 else         if (plugin.isServer(rule)) {
          areServerRules=true;
          if (server.isPresent()) {
            if (server.get().getName().equalsIgnoreCase(rule)) {
              fitServerRules=true;
            }
            String[] s=rule.split(""String_Node_Str"");
            if (s.length == 2) {
              if (server.get().getName().equalsIgnoreCase(s[0])) {
                Optional<String> world=plugin.getBridge().getPlayerInformation(p,Values.Player.Bukkit.World);
                if (world.isPresent()) {
                  if (world.get().equalsIgnoreCase(s[1])) {
                    fitServerRules=true;
                  }
                }
              }
            }
          }
        }
 else {
          areGroupRules=true;
          if (group != null) {
            if (group.equalsIgnoreCase(rule)) {
              fitGroupRules=true;
            }
          }
        }
      }
    }
    if (((!areServerRules) || fitServerRules) && ((!areGroupRules) || fitGroupRules) && !BungeeTabListPlus.isHidden(p,who)&& (includeSuspectors || p.getGameMode() != 3)) {
      list.add(p);
    }
  }
  return list;
}",0.9249406175771973
80910,"public int getGlobalPlayerCount(ProxiedPlayer viewer,boolean includeSuspectors){
  int num=0;
  Iterable<IPlayer> players=Iterables.concat(Collections2.transform(playerProviders,new Function<IPlayerProvider,Collection<? extends IPlayer>>(){
    @Override public Collection<? extends IPlayer> apply(    IPlayerProvider iPlayerProvider){
      return iPlayerProvider.getPlayers();
    }
  }
));
  for (  IPlayer p : players) {
    if (!BungeeTabListPlus.isHidden(p,viewer) && (includeSuspectors || p.getGameMode() != 3)) {
      num++;
    }
  }
  return num;
}","public int getGlobalPlayerCount(ProxiedPlayer viewer,boolean includeSuspectors){
  int num=0;
  for (  IPlayer p : players) {
    if (!BungeeTabListPlus.isHidden(p,viewer) && (includeSuspectors || p.getGameMode() != 3)) {
      num++;
    }
  }
  return num;
}",0.6349206349206349
80911,"private void validateShowTo(TabListConfig config){
  String showTo=config.showTo;
  if (showTo.equalsIgnoreCase(""String_Node_Str"")) {
    return;
  }
  if (showTo.equalsIgnoreCase(""String_Node_Str"")) {
    return;
  }
  if (showTo.equalsIgnoreCase(""String_Node_Str"")) {
    return;
  }
  String s[]=showTo.split(""String_Node_Str"");
  if (s.length != 2) {
    invalidShowTo(config);
  }
  if (s[0].equalsIgnoreCase(""String_Node_Str"")) {
    if (s[1].contains(""String_Node_Str"")) {
      invalidShowTo(config);
    }
    return;
  }
  if (s[0].equalsIgnoreCase(""String_Node_Str"")) {
    return;
  }
  if (s[0].equalsIgnoreCase(""String_Node_Str"")) {
    if (s[1].contains(""String_Node_Str"")) {
      invalidShowTo(config);
    }
    if (plugin.getPlayerManager().isServer(s[1])) {
      return;
    }
 else {
      invalidShowTo(config);
    }
  }
  if (s[0].equalsIgnoreCase(""String_Node_Str"")) {
    for (    String sv : s[1].split(""String_Node_Str"")) {
      if (!plugin.getPlayerManager().isServer(sv)) {
        invalidShowTo(config);
      }
    }
    return;
  }
  if (s[0].equalsIgnoreCase(""String_Node_Str"")) {
    if (s[1].contains(""String_Node_Str"")) {
      invalidShowTo(config);
    }
    return;
  }
  if (s[0].equals(""String_Node_Str"")) {
    return;
  }
  invalidShowTo(config);
}","private void validateShowTo(TabListConfig config){
  String showTo=config.showTo;
  if (showTo.equalsIgnoreCase(""String_Node_Str"")) {
    return;
  }
  if (showTo.equalsIgnoreCase(""String_Node_Str"")) {
    return;
  }
  if (showTo.equalsIgnoreCase(""String_Node_Str"")) {
    return;
  }
  String s[]=showTo.split(""String_Node_Str"");
  if (s.length != 2) {
    invalidShowTo(config);
  }
  if (s[0].equalsIgnoreCase(""String_Node_Str"")) {
    if (s[1].contains(""String_Node_Str"")) {
      invalidShowTo(config);
    }
    return;
  }
  if (s[0].equalsIgnoreCase(""String_Node_Str"")) {
    return;
  }
  if (s[0].equalsIgnoreCase(""String_Node_Str"")) {
    if (s[1].contains(""String_Node_Str"")) {
      invalidShowTo(config);
    }
    if (plugin.isServer(s[1])) {
      return;
    }
 else {
      invalidShowTo(config);
    }
  }
  if (s[0].equalsIgnoreCase(""String_Node_Str"")) {
    for (    String sv : s[1].split(""String_Node_Str"")) {
      if (!plugin.isServer(sv)) {
        invalidShowTo(config);
      }
    }
    return;
  }
  if (s[0].equalsIgnoreCase(""String_Node_Str"")) {
    if (s[1].contains(""String_Node_Str"")) {
      invalidShowTo(config);
    }
    return;
  }
  if (s[0].equals(""String_Node_Str"")) {
    return;
  }
  invalidShowTo(config);
}",0.9850980392156864
80912,"@Override public void fillTabList(ProxiedPlayer player,ITabList tabList){
  if (config.verticalMode) {
    tabList=tabList.flip();
  }
  List<Section> topSections=new ArrayList<>(top);
  List<Section> botSections=new ArrayList<>(bot);
  parseAutoFillplayers(player,topSections);
  parseAutoFillplayers(player,botSections);
  TabListContext context=new TabListContextImpl(tabList.getRows(),tabList.getColumns(),player);
  precalculateSections(context,topSections);
  precalculateSections(context,botSections);
  for (Iterator<Section> iterator=topSections.iterator(); iterator.hasNext(); ) {
    Section topSection=iterator.next();
    if (topSection.getMinSize() == 0) {
      iterator.remove();
    }
  }
  for (Iterator<Section> iterator=botSections.iterator(); iterator.hasNext(); ) {
    Section botSection=iterator.next();
    if (botSection.getMaxSize() == 0) {
      iterator.remove();
    }
  }
  Layout<Section> layout=layoutManager.calculateLayout(topSections,botSections,context);
  for (int i=0; i < tabList.getSize(); i++) {
    Optional<Layout<Section>.SlotData> slotData=layout.getSlotData(i);
    if (slotData.isPresent()) {
      Layout<Section>.SlotData data=slotData.get();
      if (data.getSlotIndex() == 0) {
        data.getSection().calculate(context,tabList,i,data.getSectionSize());
      }
    }
  }
  if (this.config.shownFooterHeader) {
    String header=config.header;
    header=plugin.getVariablesManager().replacePlayerVariables(player,header,plugin.getBungeePlayerProvider().wrapPlayer(player));
    header=plugin.getVariablesManager().replaceVariables(player,header);
    header=ChatColor.translateAlternateColorCodes('&',header);
    header=header.replaceAll(""String_Node_Str"",""String_Node_Str"");
    tabList.setHeader(header);
    String footer=config.footer;
    footer=plugin.getVariablesManager().replacePlayerVariables(player,footer,plugin.getBungeePlayerProvider().wrapPlayer(player));
    footer=plugin.getVariablesManager().replaceVariables(player,footer);
    footer=ChatColor.translateAlternateColorCodes('&',footer);
    footer=footer.replaceAll(""String_Node_Str"",""String_Node_Str"");
    tabList.setFooter(footer);
  }
  if (BungeeTabListPlus.isVersion18()) {
    tabList.setDefaultSkin(plugin.getSkinManager().getSkin(config.defaultSkin));
  }
  tabList.setDefaultPing(config.defaultPing);
}","@Override public void fillTabList(ProxiedPlayer player,ITabList tabList){
  if (config.verticalMode) {
    tabList=tabList.flip();
  }
  List<Section> topSections=new ArrayList<>(top);
  List<Section> botSections=new ArrayList<>(bot);
  parseAutoFillplayers(player,topSections);
  parseAutoFillplayers(player,botSections);
  TabListContext context=new TabListContextImpl(tabList.getRows(),tabList.getColumns(),player);
  precalculateSections(context,topSections);
  precalculateSections(context,botSections);
  for (Iterator<Section> iterator=topSections.iterator(); iterator.hasNext(); ) {
    Section topSection=iterator.next();
    if (topSection.getMaxSize() == 0) {
      iterator.remove();
    }
  }
  for (Iterator<Section> iterator=botSections.iterator(); iterator.hasNext(); ) {
    Section botSection=iterator.next();
    if (botSection.getMaxSize() == 0) {
      iterator.remove();
    }
  }
  Layout<Section> layout=layoutManager.calculateLayout(topSections,botSections,context);
  for (int i=0; i < tabList.getSize(); i++) {
    Optional<Layout<Section>.SlotData> slotData=layout.getSlotData(i);
    if (slotData.isPresent()) {
      Layout<Section>.SlotData data=slotData.get();
      if (data.getSlotIndex() == 0) {
        data.getSection().calculate(context,tabList,i,data.getSectionSize());
      }
    }
  }
  if (this.config.shownFooterHeader) {
    String header=config.header;
    header=plugin.getVariablesManager().replacePlayerVariables(player,header,plugin.getBungeePlayerProvider().wrapPlayer(player));
    header=plugin.getVariablesManager().replaceVariables(player,header);
    header=ChatColor.translateAlternateColorCodes('&',header);
    header=header.replaceAll(""String_Node_Str"",""String_Node_Str"");
    tabList.setHeader(header);
    String footer=config.footer;
    footer=plugin.getVariablesManager().replacePlayerVariables(player,footer,plugin.getBungeePlayerProvider().wrapPlayer(player));
    footer=plugin.getVariablesManager().replaceVariables(player,footer);
    footer=ChatColor.translateAlternateColorCodes('&',footer);
    footer=footer.replaceAll(""String_Node_Str"",""String_Node_Str"");
    tabList.setFooter(footer);
  }
  if (BungeeTabListPlus.isVersion18()) {
    tabList.setDefaultSkin(plugin.getSkinManager().getSkin(config.defaultSkin));
  }
  tabList.setDefaultPing(config.defaultPing);
}",0.9991449337323642
80913,"public static int getTabSize(){
  return ProxyServer.getInstance().getConfigurationAdapter().getListeners().iterator().next().getTabListSize();
}","public static int getTabSize(){
  return ProxyServer.getInstance().getConfig().getListeners().iterator().next().getTabListSize();
}",0.9492753623188406
80914,"protected final void update(Player player,V dataAggregator,B boundType,String subchannel){
  Map<Value<?>,Object> newData=new ConcurrentHashMap<>();
  requestedData.parallelStream().forEach(value -> {
    dataAggregator.getValue(value,boundType).ifPresent(data -> newData.put(value,data));
  }
);
  Map<String,Object> delta=new HashMap<>();
  for (  Map.Entry<Value<?>,Object> entry : sentData.entrySet()) {
    if (!newData.containsKey(entry.getKey())) {
      delta.put(entry.getKey().getId(),null);
    }
 else     if (!newData.get(entry.getKey()).equals(entry.getValue())) {
      delta.put(entry.getKey().getId(),newData.get(entry.getKey()));
    }
  }
  for (  Map.Entry<Value<?>,Object> entry : newData.entrySet()) {
    if (!sentData.containsKey(entry.getKey())) {
      delta.put(entry.getKey().getId(),entry.getValue());
    }
  }
  for (  Map.Entry<String,Object> entry : delta.entrySet()) {
    if (entry.getValue() == null) {
      onErrorValueNotAvailable(entry.getKey());
    }
  }
  if (!delta.isEmpty()) {
    sendInformation(subchannel,delta,player);
  }
  sentData=newData;
}","protected final void update(Player player,V dataAggregator,B boundType,String subchannel){
  Map<Value<?>,Object> newData=new ConcurrentHashMap<>();
  requestedData.parallelStream().forEach(value -> {
    dataAggregator.getValue(value,boundType).ifPresent(data -> newData.put(value,data));
  }
);
  Map<String,Object> delta=new HashMap<>();
  for (  Map.Entry<Value<?>,Object> entry : sentData.entrySet()) {
    if (!newData.containsKey(entry.getKey())) {
      delta.put(entry.getKey().getId(),null);
    }
 else     if (!Objects.equals(newData.get(entry.getKey()),entry.getValue())) {
      delta.put(entry.getKey().getId(),newData.get(entry.getKey()));
    }
  }
  for (  Map.Entry<Value<?>,Object> entry : newData.entrySet()) {
    if (!sentData.containsKey(entry.getKey())) {
      delta.put(entry.getKey().getId(),entry.getValue());
    }
  }
  for (  Map.Entry<String,Object> entry : delta.entrySet()) {
    if (entry.getValue() == null) {
      onErrorValueNotAvailable(entry.getKey());
    }
  }
  if (!delta.isEmpty()) {
    sendInformation(subchannel,delta,player);
  }
  sentData=newData;
}",0.989071038251366
80915,"protected final void update(Player player,V dataAggregator,B boundType,String subchannel){
  Map<Value<?>,Object> newData=new HashMap<>();
  requestedData.parallelStream().forEach(value -> {
    dataAggregator.getValue(value,boundType).ifPresent(data -> newData.put(value,data));
  }
);
  Map<String,Object> delta=new HashMap<>();
  for (  Map.Entry<Value<?>,Object> entry : sentData.entrySet()) {
    if (!newData.containsKey(entry.getKey())) {
      delta.put(entry.getKey().getId(),null);
    }
 else     if (!newData.get(entry.getKey()).equals(entry.getValue())) {
      delta.put(entry.getKey().getId(),newData.get(entry.getKey()));
    }
  }
  for (  Map.Entry<Value<?>,Object> entry : newData.entrySet()) {
    if (!sentData.containsKey(entry.getKey())) {
      delta.put(entry.getKey().getId(),entry.getValue());
    }
  }
  for (  Map.Entry<String,Object> entry : delta.entrySet()) {
    if (entry.getValue() == null) {
      onErrorValueNotAvailable(entry.getKey());
    }
  }
  if (!delta.isEmpty()) {
    sendInformation(subchannel,delta,player);
  }
  sentData=newData;
}","protected final void update(Player player,V dataAggregator,B boundType,String subchannel){
  Map<Value<?>,Object> newData=new ConcurrentHashMap<>();
  requestedData.parallelStream().forEach(value -> {
    dataAggregator.getValue(value,boundType).ifPresent(data -> newData.put(value,data));
  }
);
  Map<String,Object> delta=new HashMap<>();
  for (  Map.Entry<Value<?>,Object> entry : sentData.entrySet()) {
    if (!newData.containsKey(entry.getKey())) {
      delta.put(entry.getKey().getId(),null);
    }
 else     if (!newData.get(entry.getKey()).equals(entry.getValue())) {
      delta.put(entry.getKey().getId(),newData.get(entry.getKey()));
    }
  }
  for (  Map.Entry<Value<?>,Object> entry : newData.entrySet()) {
    if (!sentData.containsKey(entry.getKey())) {
      delta.put(entry.getKey().getId(),entry.getValue());
    }
  }
  for (  Map.Entry<String,Object> entry : delta.entrySet()) {
    if (entry.getValue() == null) {
      onErrorValueNotAvailable(entry.getKey());
    }
  }
  if (!delta.isEmpty()) {
    sendInformation(subchannel,delta,player);
  }
  sentData=newData;
}",0.995408631772268
80916,"public String getSuffix(IPlayer player){
  String suffix=null;
  Plugin p=plugin.getProxy().getPluginManager().getPlugin(""String_Node_Str"");
  if (p != null) {
    BungeePerms bp=BungeePerms.getInstance();
    try {
      User user=bp.getPermissionsManager().getUser(player.getName());
      if (user != null) {
        suffix=bp.getPermissionsManager().getMainGroup(user).getSuffix();
      }
    }
 catch (    NullPointerException ex) {
      BungeeTabListPlus.getInstance().getLogger().log(Level.SEVERE,""String_Node_Str"",ex);
    }
catch (    Throwable th) {
      BungeeTabListPlus.getInstance().reportError(th);
    }
  }
  Optional<String> vsuffix=plugin.getBridge().getPlayerInformation(player,Values.Player.Vault.Suffix);
  String mode=plugin.getConfigManager().getMainConfig().permissionSource;
  if (mode.equalsIgnoreCase(""String_Node_Str"")) {
    return suffix;
  }
 else   if (mode.equalsIgnoreCase(""String_Node_Str"")) {
    return vsuffix.orElse(""String_Node_Str"");
  }
  if (suffix != null) {
    return suffix;
  }
  if (vsuffix.isPresent()) {
    return vsuffix.get();
  }
  return ""String_Node_Str"";
}","public String getSuffix(IPlayer player){
  String suffix=null;
  Plugin p=plugin.getProxy().getPluginManager().getPlugin(""String_Node_Str"");
  if (p != null) {
    BungeePerms bp=BungeePerms.getInstance();
    try {
      PermissionsManager pm=bp.getPermissionsManager();
      if (pm != null) {
        User user=pm.getUser(player.getName());
        if (user != null) {
          suffix=pm.getMainGroup(user).getSuffix();
        }
      }
    }
 catch (    NullPointerException ex) {
      BungeeTabListPlus.getInstance().getLogger().log(Level.SEVERE,""String_Node_Str"",ex);
    }
catch (    Throwable th) {
      BungeeTabListPlus.getInstance().reportError(th);
    }
  }
  Optional<String> vsuffix=plugin.getBridge().getPlayerInformation(player,Values.Player.Vault.Suffix);
  String mode=plugin.getConfigManager().getMainConfig().permissionSource;
  if (mode.equalsIgnoreCase(""String_Node_Str"")) {
    return suffix;
  }
 else   if (mode.equalsIgnoreCase(""String_Node_Str"")) {
    return vsuffix.orElse(""String_Node_Str"");
  }
  if (suffix != null) {
    return suffix;
  }
  if (vsuffix.isPresent()) {
    return vsuffix.get();
  }
  return ""String_Node_Str"";
}",0.902802101576182
80917,"public String getPrefix(IPlayer player){
  String bpprefix=null;
  Plugin p=plugin.getProxy().getPluginManager().getPlugin(""String_Node_Str"");
  if (p != null) {
    BungeePerms bp=BungeePerms.getInstance();
    try {
      User user=bp.getPermissionsManager().getUser(player.getName());
      if (user != null) {
        bpprefix=bp.getPermissionsManager().getMainGroup(user).getPrefix();
      }
    }
 catch (    NullPointerException ex) {
      BungeeTabListPlus.getInstance().getLogger().log(Level.SEVERE,""String_Node_Str"",ex);
    }
catch (    Throwable th) {
      BungeeTabListPlus.getInstance().reportError(th);
    }
  }
  String bprefix=plugin.getConfigManager().getMainConfig().prefixes.get(getMainGroup(player));
  Optional<String> vprefix=plugin.getBridge().getPlayerInformation(player,Values.Player.Vault.Prefix);
  String mode=plugin.getConfigManager().getMainConfig().permissionSource;
  if (mode.equalsIgnoreCase(""String_Node_Str"")) {
    return bpprefix != null ? bpprefix : ""String_Node_Str"";
  }
 else   if (mode.equalsIgnoreCase(""String_Node_Str"")) {
    return vprefix.isPresent() ? vprefix.get() : ""String_Node_Str"";
  }
 else   if (mode.equalsIgnoreCase(""String_Node_Str"")) {
    return bprefix != null ? bprefix : ""String_Node_Str"";
  }
  if (bprefix != null) {
    return bprefix;
  }
  if (bpprefix != null) {
    return bpprefix;
  }
  if (vprefix.isPresent()) {
    return vprefix.get();
  }
  return ""String_Node_Str"";
}","public String getPrefix(IPlayer player){
  String bpprefix=null;
  Plugin p=plugin.getProxy().getPluginManager().getPlugin(""String_Node_Str"");
  if (p != null) {
    BungeePerms bp=BungeePerms.getInstance();
    try {
      PermissionsManager pm=bp.getPermissionsManager();
      if (pm != null) {
        User user=pm.getUser(player.getName());
        if (user != null) {
          bpprefix=pm.getMainGroup(user).getPrefix();
        }
      }
    }
 catch (    NullPointerException ex) {
      BungeeTabListPlus.getInstance().getLogger().log(Level.SEVERE,""String_Node_Str"",ex);
    }
catch (    Throwable th) {
      BungeeTabListPlus.getInstance().reportError(th);
    }
  }
  String bprefix=plugin.getConfigManager().getMainConfig().prefixes.get(getMainGroup(player));
  Optional<String> vprefix=plugin.getBridge().getPlayerInformation(player,Values.Player.Vault.Prefix);
  String mode=plugin.getConfigManager().getMainConfig().permissionSource;
  if (mode.equalsIgnoreCase(""String_Node_Str"")) {
    return bpprefix != null ? bpprefix : ""String_Node_Str"";
  }
 else   if (mode.equalsIgnoreCase(""String_Node_Str"")) {
    return vprefix.isPresent() ? vprefix.get() : ""String_Node_Str"";
  }
 else   if (mode.equalsIgnoreCase(""String_Node_Str"")) {
    return bprefix != null ? bprefix : ""String_Node_Str"";
  }
  if (bprefix != null) {
    return bprefix;
  }
  if (bpprefix != null) {
    return bpprefix;
  }
  if (vprefix.isPresent()) {
    return vprefix.get();
  }
  return ""String_Node_Str"";
}",0.8983050847457628
80918,"public String getMainGroup(IPlayer player){
  String bpgroup=null;
  Plugin p=ProxyServer.getInstance().getPluginManager().getPlugin(""String_Node_Str"");
  if (p != null) {
    BungeePerms bp=BungeePerms.getInstance();
    try {
      User user=bp.getPermissionsManager().getUser(player.getName());
      Group mainGroup=null;
      if (user != null) {
        mainGroup=bp.getPermissionsManager().getMainGroup(user);
      }
      if (mainGroup == null) {
        if (!bp.getPermissionsManager().getDefaultGroups().isEmpty()) {
          mainGroup=bp.getPermissionsManager().getDefaultGroups().get(0);
          for (int i=1; i < bp.getPermissionsManager().getDefaultGroups().size(); ++i) {
            if (bp.getPermissionsManager().getDefaultGroups().get(i).getWeight() < mainGroup.getWeight()) {
              mainGroup=bp.getPermissionsManager().getDefaultGroups().get(i);
            }
          }
        }
      }
      if (mainGroup != null) {
        bpgroup=mainGroup.getName();
      }
    }
 catch (    NullPointerException ex) {
      BungeeTabListPlus.getInstance().getLogger().log(Level.SEVERE,""String_Node_Str"",ex);
    }
catch (    Throwable th) {
      BungeeTabListPlus.getInstance().reportError(th);
    }
  }
  Optional<String> vgroup=plugin.getBridge().getPlayerInformation(player,Values.Player.Vault.PermissionGroup);
  String bgroup=null;
  Collection<String> groups=plugin.getProxy().getConfigurationAdapter().getGroups(player.getName());
  if (groups.size() == 1) {
    bgroup=groups.iterator().next();
  }
  for (  String group : groups) {
    if (!group.equals(""String_Node_Str"")) {
      bgroup=group;
      break;
    }
  }
  if (bgroup == null) {
    bgroup=""String_Node_Str"";
  }
  String mode=plugin.getConfigManager().getMainConfig().permissionSource;
  if (mode.equalsIgnoreCase(""String_Node_Str"")) {
    return bpgroup != null ? bpgroup : ""String_Node_Str"";
  }
 else   if (mode.equalsIgnoreCase(""String_Node_Str"")) {
    return vgroup.isPresent() ? vgroup.get() : ""String_Node_Str"";
  }
 else   if (mode.equalsIgnoreCase(""String_Node_Str"")) {
    return bgroup;
  }
  if (bpgroup != null) {
    return bpgroup;
  }
  if (vgroup.isPresent()) {
    return vgroup.get();
  }
  return bgroup;
}","public String getMainGroup(IPlayer player){
  String bpgroup=null;
  Plugin p=ProxyServer.getInstance().getPluginManager().getPlugin(""String_Node_Str"");
  if (p != null) {
    BungeePerms bp=BungeePerms.getInstance();
    try {
      PermissionsManager pm=bp.getPermissionsManager();
      if (pm != null) {
        User user=pm.getUser(player.getName());
        Group mainGroup=null;
        if (user != null) {
          mainGroup=pm.getMainGroup(user);
        }
        if (mainGroup == null) {
          if (!pm.getDefaultGroups().isEmpty()) {
            mainGroup=pm.getDefaultGroups().get(0);
            for (int i=1; i < pm.getDefaultGroups().size(); ++i) {
              if (pm.getDefaultGroups().get(i).getWeight() < mainGroup.getWeight()) {
                mainGroup=pm.getDefaultGroups().get(i);
              }
            }
          }
        }
        if (mainGroup != null) {
          bpgroup=mainGroup.getName();
        }
      }
    }
 catch (    NullPointerException ex) {
      BungeeTabListPlus.getInstance().getLogger().log(Level.SEVERE,""String_Node_Str"",ex);
    }
catch (    Throwable th) {
      BungeeTabListPlus.getInstance().reportError(th);
    }
  }
  Optional<String> vgroup=plugin.getBridge().getPlayerInformation(player,Values.Player.Vault.PermissionGroup);
  String bgroup=null;
  Collection<String> groups=plugin.getProxy().getConfigurationAdapter().getGroups(player.getName());
  if (groups.size() == 1) {
    bgroup=groups.iterator().next();
  }
  for (  String group : groups) {
    if (!group.equals(""String_Node_Str"")) {
      bgroup=group;
      break;
    }
  }
  if (bgroup == null) {
    bgroup=""String_Node_Str"";
  }
  String mode=plugin.getConfigManager().getMainConfig().permissionSource;
  if (mode.equalsIgnoreCase(""String_Node_Str"")) {
    return bpgroup != null ? bpgroup : ""String_Node_Str"";
  }
 else   if (mode.equalsIgnoreCase(""String_Node_Str"")) {
    return vgroup.isPresent() ? vgroup.get() : ""String_Node_Str"";
  }
 else   if (mode.equalsIgnoreCase(""String_Node_Str"")) {
    return bgroup;
  }
  if (bpgroup != null) {
    return bpgroup;
  }
  if (vgroup.isPresent()) {
    return vgroup.get();
  }
  return bgroup;
}",0.7251700680272108
80919,"public int comparePlayers(IPlayer p1,IPlayer p2){
  Plugin p=plugin.getProxy().getPluginManager().getPlugin(""String_Node_Str"");
  if (p != null) {
    BungeePerms bp=BungeePerms.getInstance();
    try {
      User u1=bp.getPermissionsManager().getUser(p1.getName());
      User u2=bp.getPermissionsManager().getUser(p2.getName());
      if (u1 != null && u2 != null) {
        Group g1=bp.getPermissionsManager().getMainGroup(u1);
        Group g2=bp.getPermissionsManager().getMainGroup(u2);
        if (g1 != null && g2 != null) {
          int r1=g1.getRank();
          int r2=g2.getRank();
          if (r1 > r2) {
            return -1;
          }
          if (r2 > r1) {
            return 1;
          }
          return 0;
        }
      }
    }
 catch (    Throwable th) {
      BungeeTabListPlus.getInstance().reportError(th);
    }
  }
  if (p1 instanceof BungeePlayer && p2 instanceof BungeePlayer) {
    int i=0;
    for (    String group : ((BungeePlayer)p1).getPlayer().getGroups()) {
      if (!group.equals(""String_Node_Str"")) {
        i=1;
      }
    }
    int j=0;
    for (    String group : ((BungeePlayer)p2).getPlayer().getGroups()) {
      if (!group.equals(""String_Node_Str"")) {
        j=1;
      }
    }
    if (i > j) {
      return -1;
    }
    if (j > i) {
      return 1;
    }
  }
  return 0;
}","public int comparePlayers(IPlayer p1,IPlayer p2){
  Plugin p=plugin.getProxy().getPluginManager().getPlugin(""String_Node_Str"");
  if (p != null) {
    BungeePerms bp=BungeePerms.getInstance();
    try {
      PermissionsManager pm=bp.getPermissionsManager();
      if (pm != null) {
        User u1=pm.getUser(p1.getName());
        User u2=pm.getUser(p2.getName());
        if (u1 != null && u2 != null) {
          Group g1=pm.getMainGroup(u1);
          Group g2=pm.getMainGroup(u2);
          if (g1 != null && g2 != null) {
            int r1=g1.getRank();
            int r2=g2.getRank();
            if (r1 > r2) {
              return -1;
            }
            if (r2 > r1) {
              return 1;
            }
            return 0;
          }
        }
      }
    }
 catch (    Throwable th) {
      BungeeTabListPlus.getInstance().reportError(th);
    }
  }
  if (p1 instanceof BungeePlayer && p2 instanceof BungeePlayer) {
    int i=0;
    for (    String group : ((BungeePlayer)p1).getPlayer().getGroups()) {
      if (!group.equals(""String_Node_Str"")) {
        i=1;
      }
    }
    int j=0;
    for (    String group : ((BungeePlayer)p2).getPlayer().getGroups()) {
      if (!group.equals(""String_Node_Str"")) {
        j=1;
      }
    }
    if (i > j) {
      return -1;
    }
    if (j > i) {
      return 1;
    }
  }
  return 0;
}",0.8699851411589896
80920,"public String getDisplayPrefix(IPlayer player){
  String display=null;
  Plugin p=plugin.getProxy().getPluginManager().getPlugin(""String_Node_Str"");
  if (p != null) {
    BungeePerms bp=BungeePerms.getInstance();
    try {
      User user=bp.getPermissionsManager().getUser(player.getName());
      if (user != null) {
        display=bp.getPermissionsManager().getMainGroup(user).getDisplay();
      }
    }
 catch (    NullPointerException ex) {
      BungeeTabListPlus.getInstance().getLogger().log(Level.SEVERE,""String_Node_Str"",ex);
    }
catch (    Throwable th) {
      BungeeTabListPlus.getInstance().reportError(th);
    }
  }
  if (display == null) {
    display=""String_Node_Str"";
  }
  return display;
}","public String getDisplayPrefix(IPlayer player){
  String display=null;
  Plugin p=plugin.getProxy().getPluginManager().getPlugin(""String_Node_Str"");
  if (p != null) {
    BungeePerms bp=BungeePerms.getInstance();
    try {
      PermissionsManager pm=bp.getPermissionsManager();
      if (pm != null) {
        User user=pm.getUser(player.getName());
        if (user != null) {
          display=pm.getMainGroup(user).getDisplay();
        }
      }
    }
 catch (    NullPointerException ex) {
      BungeeTabListPlus.getInstance().getLogger().log(Level.SEVERE,""String_Node_Str"",ex);
    }
catch (    Throwable th) {
      BungeeTabListPlus.getInstance().reportError(th);
    }
  }
  if (display == null) {
    display=""String_Node_Str"";
  }
  return display;
}",0.7972972972972973
80921,"public int comparePlayers(IPlayer p1,IPlayer p2){
  Plugin p=plugin.getProxy().getPluginManager().getPlugin(""String_Node_Str"");
  if (p != null) {
    BungeePerms bp=BungeePerms.getInstance();
    try {
      Group g1=bp.getPermissionsManager().getMainGroup(bp.getPermissionsManager().getUser(p1.getName()));
      Group g2=bp.getPermissionsManager().getMainGroup(bp.getPermissionsManager().getUser(p2.getName()));
      int r1=g1.getRank();
      int r2=g2.getRank();
      if (r1 > r2) {
        return -1;
      }
      if (r2 > r1) {
        return 1;
      }
      return 0;
    }
 catch (    Throwable th) {
      BungeeTabListPlus.getInstance().reportError(th);
    }
  }
  if (p1 instanceof BungeePlayer && p2 instanceof BungeePlayer) {
    int i=0;
    for (    String group : ((BungeePlayer)p1).getPlayer().getGroups()) {
      if (!group.equals(""String_Node_Str"")) {
        i=1;
      }
    }
    int j=0;
    for (    String group : ((BungeePlayer)p2).getPlayer().getGroups()) {
      if (!group.equals(""String_Node_Str"")) {
        j=1;
      }
    }
    if (i > j) {
      return -1;
    }
    if (j > i) {
      return 1;
    }
  }
  return 0;
}","public int comparePlayers(IPlayer p1,IPlayer p2){
  Plugin p=plugin.getProxy().getPluginManager().getPlugin(""String_Node_Str"");
  if (p != null) {
    BungeePerms bp=BungeePerms.getInstance();
    try {
      User u1=bp.getPermissionsManager().getUser(p1.getName());
      User u2=bp.getPermissionsManager().getUser(p2.getName());
      if (u1 != null && u2 != null) {
        Group g1=bp.getPermissionsManager().getMainGroup(u1);
        Group g2=bp.getPermissionsManager().getMainGroup(u2);
        if (g1 != null && g2 != null) {
          int r1=g1.getRank();
          int r2=g2.getRank();
          if (r1 > r2) {
            return -1;
          }
          if (r2 > r1) {
            return 1;
          }
          return 0;
        }
      }
    }
 catch (    Throwable th) {
      BungeeTabListPlus.getInstance().reportError(th);
    }
  }
  if (p1 instanceof BungeePlayer && p2 instanceof BungeePlayer) {
    int i=0;
    for (    String group : ((BungeePlayer)p1).getPlayer().getGroups()) {
      if (!group.equals(""String_Node_Str"")) {
        i=1;
      }
    }
    int j=0;
    for (    String group : ((BungeePlayer)p2).getPlayer().getGroups()) {
      if (!group.equals(""String_Node_Str"")) {
        j=1;
      }
    }
    if (i > j) {
      return -1;
    }
    if (j > i) {
      return 1;
    }
  }
  return 0;
}",0.8187650360866079
80922,"public String getSuffix(IPlayer player){
  String suffix=null;
  Plugin p=plugin.getProxy().getPluginManager().getPlugin(""String_Node_Str"");
  if (p != null) {
    BungeePerms bp=BungeePerms.getInstance();
    try {
      User user=bp.getPermissionsManager().getUser(player.getName());
      if (user != null) {
        suffix=bp.getPermissionsManager().getMainGroup(user).getSuffix();
      }
    }
 catch (    Throwable th) {
      BungeeTabListPlus.getInstance().reportError(th);
    }
  }
  String vsuffix=plugin.getBridge().getPlayerInformation(player,""String_Node_Str"");
  String mode=plugin.getConfigManager().getMainConfig().permissionSource;
  if (mode.equalsIgnoreCase(""String_Node_Str"")) {
    return suffix;
  }
 else   if (mode.equalsIgnoreCase(""String_Node_Str"")) {
    return vsuffix != null ? vsuffix : ""String_Node_Str"";
  }
  if (suffix != null) {
    return suffix;
  }
  if (vsuffix != null) {
    return vsuffix;
  }
  return ""String_Node_Str"";
}","public String getSuffix(IPlayer player){
  String suffix=null;
  Plugin p=plugin.getProxy().getPluginManager().getPlugin(""String_Node_Str"");
  if (p != null) {
    BungeePerms bp=BungeePerms.getInstance();
    try {
      User user=bp.getPermissionsManager().getUser(player.getName());
      if (user != null) {
        suffix=bp.getPermissionsManager().getMainGroup(user).getSuffix();
      }
    }
 catch (    NullPointerException ex) {
      BungeeTabListPlus.getInstance().getLogger().log(Level.SEVERE,""String_Node_Str"",ex);
    }
catch (    Throwable th) {
      BungeeTabListPlus.getInstance().reportError(th);
    }
  }
  String vsuffix=plugin.getBridge().getPlayerInformation(player,""String_Node_Str"");
  String mode=plugin.getConfigManager().getMainConfig().permissionSource;
  if (mode.equalsIgnoreCase(""String_Node_Str"")) {
    return suffix;
  }
 else   if (mode.equalsIgnoreCase(""String_Node_Str"")) {
    return vsuffix != null ? vsuffix : ""String_Node_Str"";
  }
  if (suffix != null) {
    return suffix;
  }
  if (vsuffix != null) {
    return vsuffix;
  }
  return ""String_Node_Str"";
}",0.9352030947775628
80923,"public String getPrefix(IPlayer player){
  String bpprefix=null;
  Plugin p=plugin.getProxy().getPluginManager().getPlugin(""String_Node_Str"");
  if (p != null) {
    BungeePerms bp=BungeePerms.getInstance();
    try {
      User user=bp.getPermissionsManager().getUser(player.getName());
      if (user != null) {
        bpprefix=bp.getPermissionsManager().getMainGroup(user).getPrefix();
      }
    }
 catch (    Throwable th) {
      BungeeTabListPlus.getInstance().reportError(th);
    }
  }
  String bprefix=plugin.getConfigManager().getMainConfig().prefixes.get(getMainGroup(player));
  String vprefix=plugin.getBridge().getPlayerInformation(player,""String_Node_Str"");
  String mode=plugin.getConfigManager().getMainConfig().permissionSource;
  if (mode.equalsIgnoreCase(""String_Node_Str"")) {
    return bpprefix != null ? bpprefix : ""String_Node_Str"";
  }
 else   if (mode.equalsIgnoreCase(""String_Node_Str"")) {
    return vprefix != null ? vprefix : ""String_Node_Str"";
  }
 else   if (mode.equalsIgnoreCase(""String_Node_Str"")) {
    return bprefix != null ? bprefix : ""String_Node_Str"";
  }
  if (bprefix != null) {
    return bprefix;
  }
  if (bpprefix != null) {
    return bpprefix;
  }
  if (vprefix != null) {
    return vprefix;
  }
  return ""String_Node_Str"";
}","public String getPrefix(IPlayer player){
  String bpprefix=null;
  Plugin p=plugin.getProxy().getPluginManager().getPlugin(""String_Node_Str"");
  if (p != null) {
    BungeePerms bp=BungeePerms.getInstance();
    try {
      User user=bp.getPermissionsManager().getUser(player.getName());
      if (user != null) {
        bpprefix=bp.getPermissionsManager().getMainGroup(user).getPrefix();
      }
    }
 catch (    NullPointerException ex) {
      BungeeTabListPlus.getInstance().getLogger().log(Level.SEVERE,""String_Node_Str"",ex);
    }
catch (    Throwable th) {
      BungeeTabListPlus.getInstance().reportError(th);
    }
  }
  String bprefix=plugin.getConfigManager().getMainConfig().prefixes.get(getMainGroup(player));
  String vprefix=plugin.getBridge().getPlayerInformation(player,""String_Node_Str"");
  String mode=plugin.getConfigManager().getMainConfig().permissionSource;
  if (mode.equalsIgnoreCase(""String_Node_Str"")) {
    return bpprefix != null ? bpprefix : ""String_Node_Str"";
  }
 else   if (mode.equalsIgnoreCase(""String_Node_Str"")) {
    return vprefix != null ? vprefix : ""String_Node_Str"";
  }
 else   if (mode.equalsIgnoreCase(""String_Node_Str"")) {
    return bprefix != null ? bprefix : ""String_Node_Str"";
  }
  if (bprefix != null) {
    return bprefix;
  }
  if (bpprefix != null) {
    return bpprefix;
  }
  if (vprefix != null) {
    return vprefix;
  }
  return ""String_Node_Str"";
}",0.950185873605948
80924,"public String getMainGroup(IPlayer player){
  String bpgroup=null;
  Plugin p=plugin.getProxy().getPluginManager().getPlugin(""String_Node_Str"");
  if (p != null) {
    BungeePerms bp=BungeePerms.getInstance();
    try {
      User user=bp.getPermissionsManager().getUser(player.getName());
      Group mainGroup=null;
      if (user != null) {
        mainGroup=bp.getPermissionsManager().getMainGroup(user);
      }
      if (mainGroup == null) {
        if (!bp.getPermissionsManager().getDefaultGroups().isEmpty()) {
          mainGroup=bp.getPermissionsManager().getDefaultGroups().get(0);
          for (int i=1; i < bp.getPermissionsManager().getDefaultGroups().size(); ++i) {
            if (bp.getPermissionsManager().getDefaultGroups().get(i).getWeight() < mainGroup.getWeight()) {
              mainGroup=bp.getPermissionsManager().getDefaultGroups().get(i);
            }
          }
        }
      }
      if (mainGroup != null) {
        bpgroup=mainGroup.getName();
      }
    }
 catch (    Throwable th) {
      BungeeTabListPlus.getInstance().reportError(th);
    }
  }
  String vgroup=plugin.getBridge().getPlayerInformation(player,""String_Node_Str"");
  String bgroup=null;
  Collection<String> groups=plugin.getProxy().getConfigurationAdapter().getGroups(player.getName());
  if (groups.size() == 1) {
    bgroup=groups.iterator().next();
  }
  for (  String group : groups) {
    if (!group.equals(""String_Node_Str"")) {
      bgroup=group;
      break;
    }
  }
  if (bgroup == null) {
    bgroup=""String_Node_Str"";
  }
  String mode=plugin.getConfigManager().getMainConfig().permissionSource;
  if (mode.equalsIgnoreCase(""String_Node_Str"")) {
    return bpgroup != null ? bpgroup : ""String_Node_Str"";
  }
 else   if (mode.equalsIgnoreCase(""String_Node_Str"")) {
    return vgroup != null ? vgroup : ""String_Node_Str"";
  }
 else   if (mode.equalsIgnoreCase(""String_Node_Str"")) {
    return bgroup;
  }
  if (bpgroup != null) {
    return bpgroup;
  }
  if (vgroup != null) {
    return vgroup;
  }
  return bgroup;
}","public String getMainGroup(IPlayer player){
  String bpgroup=null;
  Plugin p=plugin.getProxy().getPluginManager().getPlugin(""String_Node_Str"");
  if (p != null) {
    BungeePerms bp=BungeePerms.getInstance();
    try {
      User user=bp.getPermissionsManager().getUser(player.getName());
      Group mainGroup=null;
      if (user != null) {
        mainGroup=bp.getPermissionsManager().getMainGroup(user);
      }
      if (mainGroup == null) {
        if (!bp.getPermissionsManager().getDefaultGroups().isEmpty()) {
          mainGroup=bp.getPermissionsManager().getDefaultGroups().get(0);
          for (int i=1; i < bp.getPermissionsManager().getDefaultGroups().size(); ++i) {
            if (bp.getPermissionsManager().getDefaultGroups().get(i).getWeight() < mainGroup.getWeight()) {
              mainGroup=bp.getPermissionsManager().getDefaultGroups().get(i);
            }
          }
        }
      }
      if (mainGroup != null) {
        bpgroup=mainGroup.getName();
      }
    }
 catch (    NullPointerException ex) {
      BungeeTabListPlus.getInstance().getLogger().log(Level.SEVERE,""String_Node_Str"",ex);
    }
catch (    Throwable th) {
      BungeeTabListPlus.getInstance().reportError(th);
    }
  }
  String vgroup=plugin.getBridge().getPlayerInformation(player,""String_Node_Str"");
  String bgroup=null;
  Collection<String> groups=plugin.getProxy().getConfigurationAdapter().getGroups(player.getName());
  if (groups.size() == 1) {
    bgroup=groups.iterator().next();
  }
  for (  String group : groups) {
    if (!group.equals(""String_Node_Str"")) {
      bgroup=group;
      break;
    }
  }
  if (bgroup == null) {
    bgroup=""String_Node_Str"";
  }
  String mode=plugin.getConfigManager().getMainConfig().permissionSource;
  if (mode.equalsIgnoreCase(""String_Node_Str"")) {
    return bpgroup != null ? bpgroup : ""String_Node_Str"";
  }
 else   if (mode.equalsIgnoreCase(""String_Node_Str"")) {
    return vgroup != null ? vgroup : ""String_Node_Str"";
  }
 else   if (mode.equalsIgnoreCase(""String_Node_Str"")) {
    return bgroup;
  }
  if (bpgroup != null) {
    return bpgroup;
  }
  if (vgroup != null) {
    return vgroup;
  }
  return bgroup;
}",0.9681558935361216
80925,"public String getDisplayPrefix(IPlayer player){
  String display=null;
  Plugin p=plugin.getProxy().getPluginManager().getPlugin(""String_Node_Str"");
  if (p != null) {
    BungeePerms bp=BungeePerms.getInstance();
    try {
      User user=bp.getPermissionsManager().getUser(player.getName());
      if (user != null) {
        display=bp.getPermissionsManager().getMainGroup(user).getDisplay();
      }
    }
 catch (    Throwable th) {
      BungeeTabListPlus.getInstance().reportError(th);
    }
  }
  if (display == null) {
    display=""String_Node_Str"";
  }
  return display;
}","public String getDisplayPrefix(IPlayer player){
  String display=null;
  Plugin p=plugin.getProxy().getPluginManager().getPlugin(""String_Node_Str"");
  if (p != null) {
    BungeePerms bp=BungeePerms.getInstance();
    try {
      User user=bp.getPermissionsManager().getUser(player.getName());
      if (user != null) {
        display=bp.getPermissionsManager().getMainGroup(user).getDisplay();
      }
    }
 catch (    NullPointerException ex) {
      BungeeTabListPlus.getInstance().getLogger().log(Level.SEVERE,""String_Node_Str"",ex);
    }
catch (    Throwable th) {
      BungeeTabListPlus.getInstance().reportError(th);
    }
  }
  if (display == null) {
    display=""String_Node_Str"";
  }
  return display;
}",0.8967642526964561
80926,"public String getMainGroup(IPlayer player){
  String bpgroup=null;
  BungeePerms bp=(BungeePerms)plugin.getProxy().getPluginManager().getPlugin(""String_Node_Str"");
  if (bp != null) {
    try {
      Group mainGroup=bp.getPermissionsManager().getMainGroup(bp.getPermissionsManager().getUser(player.getName()));
      if (mainGroup != null) {
        bpgroup=mainGroup.getName();
      }
    }
 catch (    Throwable th) {
      BungeeTabListPlus.getInstance().reportError(th);
    }
  }
  String vgroup=plugin.getBridge().getPlayerInformation(player,""String_Node_Str"");
  String bgroup=null;
  Collection<String> groups=plugin.getProxy().getConfigurationAdapter().getGroups(player.getName());
  if (groups.size() == 1) {
    bgroup=groups.iterator().next();
  }
  for (  String group : groups) {
    if (!group.equals(""String_Node_Str"")) {
      bgroup=group;
      break;
    }
  }
  if (bgroup == null) {
    bgroup=""String_Node_Str"";
  }
  String mode=plugin.getConfigManager().getMainConfig().permissionSource;
  if (mode.equalsIgnoreCase(""String_Node_Str"")) {
    return bpgroup != null ? bpgroup : ""String_Node_Str"";
  }
 else   if (mode.equalsIgnoreCase(""String_Node_Str"")) {
    return vgroup != null ? vgroup : ""String_Node_Str"";
  }
 else   if (mode.equalsIgnoreCase(""String_Node_Str"")) {
    return bgroup;
  }
  if (bpgroup != null) {
    return bpgroup;
  }
  if (vgroup != null) {
    return vgroup;
  }
  return bgroup;
}","public String getMainGroup(IPlayer player){
  String bpgroup=null;
  BungeePerms bp=(BungeePerms)plugin.getProxy().getPluginManager().getPlugin(""String_Node_Str"");
  if (bp != null) {
    try {
      User user=bp.getPermissionsManager().getUser(player.getName());
      Group mainGroup=null;
      if (user != null) {
        mainGroup=bp.getPermissionsManager().getMainGroup(user);
      }
      if (mainGroup == null) {
        if (!bp.getPermissionsManager().getDefaultGroups().isEmpty()) {
          mainGroup=bp.getPermissionsManager().getDefaultGroups().get(0);
          for (int i=1; i < bp.getPermissionsManager().getDefaultGroups().size(); ++i) {
            if (bp.getPermissionsManager().getDefaultGroups().get(i).getWeight() < mainGroup.getWeight()) {
              mainGroup=bp.getPermissionsManager().getDefaultGroups().get(i);
            }
          }
        }
      }
      if (mainGroup != null) {
        bpgroup=mainGroup.getName();
      }
    }
 catch (    Throwable th) {
      BungeeTabListPlus.getInstance().reportError(th);
    }
  }
  String vgroup=plugin.getBridge().getPlayerInformation(player,""String_Node_Str"");
  String bgroup=null;
  Collection<String> groups=plugin.getProxy().getConfigurationAdapter().getGroups(player.getName());
  if (groups.size() == 1) {
    bgroup=groups.iterator().next();
  }
  for (  String group : groups) {
    if (!group.equals(""String_Node_Str"")) {
      bgroup=group;
      break;
    }
  }
  if (bgroup == null) {
    bgroup=""String_Node_Str"";
  }
  String mode=plugin.getConfigManager().getMainConfig().permissionSource;
  if (mode.equalsIgnoreCase(""String_Node_Str"")) {
    return bpgroup != null ? bpgroup : ""String_Node_Str"";
  }
 else   if (mode.equalsIgnoreCase(""String_Node_Str"")) {
    return vgroup != null ? vgroup : ""String_Node_Str"";
  }
 else   if (mode.equalsIgnoreCase(""String_Node_Str"")) {
    return bgroup;
  }
  if (bpgroup != null) {
    return bpgroup;
  }
  if (vgroup != null) {
    return vgroup;
  }
  return bgroup;
}",0.8195008705745792
80927,"public void createOrUpdatePlayer(Connection.Unsafe connection,String player,int ping){
  playerListPacket.createOrUpdatePlayer(connection,player,ping);
}","public void createOrUpdatePlayer(Connection.Unsafe connection,String player,int ping){
  Preconditions.checkArgument(player.length() <= 16);
  playerListPacket.createOrUpdatePlayer(connection,player,ping);
}",0.85
80928,"public void createTeam(Connection.Unsafe connection,String player){
  teamPacket.createTeam(connection,player);
}","public void createTeam(Connection.Unsafe connection,String player){
  Preconditions.checkArgument(player.length() <= 13);
  teamPacket.createTeam(connection,player);
}",0.8071428571428572
80929,"public void updateTeam(Connection.Unsafe connection,String player,String prefix,String displayname,String suffix){
  teamPacket.updateTeam(connection,player,prefix,displayname,suffix);
}","public void updateTeam(Connection.Unsafe connection,String player,String prefix,String displayname,String suffix){
  Preconditions.checkArgument(player.length() <= 13);
  Preconditions.checkArgument(prefix.length() <= 16);
  Preconditions.checkArgument(displayname.length() <= 16);
  Preconditions.checkArgument(suffix.length() <= 16);
  teamPacket.updateTeam(connection,player,prefix,displayname,suffix);
}",0.6104553119730185
80930,"public void removeTeam(Connection.Unsafe connection,String player){
  teamPacket.removeTeam(connection,player);
}","public void removeTeam(Connection.Unsafe connection,String player){
  Preconditions.checkArgument(player.length() <= 13);
  teamPacket.removeTeam(connection,player);
}",0.8071428571428572
80931,"public void removePlayer(Connection.Unsafe connection,String player){
  playerListPacket.removePlayer(connection,player);
}","public void removePlayer(Connection.Unsafe connection,String player){
  Preconditions.checkArgument(player.length() <= 16);
  playerListPacket.removePlayer(connection,player);
}",0.82
80932,"@Override public Skin getSkin(){
  if (skin == null) {
    LoginResult loginResult=((UserConnection)player).getPendingConnection().getLoginProfile();
    if (loginResult != null) {
      for (      LoginResult.Property s : loginResult.getProperties()) {
        if (s.getName().equals(""String_Node_Str"")) {
          skin=new PlayerSkin(player.getUniqueId(),new String[]{s.getName(),s.getValue(),s.getSignature()});
        }
      }
    }
    if (skin == null) {
      skin=new PlayerSkin(player.getUniqueId(),null);
    }
  }
  return skin;
}","@Override public Skin getSkin(){
  if (!BungeeTabListPlus.isVersion18())   return SkinManager.defaultSkin;
  if (skin == null) {
    LoginResult loginResult=((UserConnection)player).getPendingConnection().getLoginProfile();
    if (loginResult != null) {
      for (      LoginResult.Property s : loginResult.getProperties()) {
        if (s.getName().equals(""String_Node_Str"")) {
          skin=new PlayerSkin(player.getUniqueId(),new String[]{s.getName(),s.getValue(),s.getSignature()});
        }
      }
    }
    if (skin == null) {
      skin=new PlayerSkin(player.getUniqueId(),null);
    }
  }
  return skin;
}",0.93631669535284
80933,"private static String getSlotID(int n){
  String hex=Integer.toHexString(n + 1);
  char[] alloc=new char[hex.length() * 2];
  for (int i=0; i < alloc.length; i++) {
    if (i % 2 == 0) {
      alloc[i]=ChatColor.COLOR_CHAR;
    }
 else {
      alloc[i]=hex.charAt(i / 2);
    }
  }
  return String.valueOf(ChatColor.MAGIC) + alloc + ChatColor.RESET;
}","private static String getSlotID(int n){
  String hex=Integer.toHexString(n + 1);
  char[] alloc=new char[hex.length() * 2];
  for (int i=0; i < alloc.length; i++) {
    if (i % 2 == 0) {
      alloc[i]=ChatColor.COLOR_CHAR;
    }
 else {
      alloc[i]=hex.charAt(i / 2);
    }
  }
  return String.valueOf(ChatColor.MAGIC) + String.valueOf(alloc) + ChatColor.RESET;
}",0.9637883008356546
80934,"private static String getSlotID(int n){
  String hex=Integer.toHexString(n + 1);
  char[] alloc=new char[hex.length() * 2];
  for (int i=0; i < alloc.length; i++) {
    if (i % 2 == 0) {
      alloc[i]=ChatColor.COLOR_CHAR;
    }
 else {
      alloc[i]=hex.charAt(i / 2);
    }
  }
  return String.valueOf(ChatColor.MAGIC) + alloc + ChatColor.RESET;
}","private static String getSlotID(int n){
  String hex=Integer.toHexString(n + 1);
  char[] alloc=new char[hex.length() * 2];
  for (int i=0; i < alloc.length; i++) {
    if (i % 2 == 0) {
      alloc[i]=ChatColor.COLOR_CHAR;
    }
 else {
      alloc[i]=hex.charAt(i / 2);
    }
  }
  return String.valueOf(ChatColor.MAGIC) + String.valueOf(alloc) + ChatColor.RESET;
}",0.9637883008356546
80935,"void createTeam(Connection.Unsafe connection,String player){
  Team t=new Team();
  t.setName(""String_Node_Str"" + player);
  t.setMode((byte)0);
  t.setPrefix(""String_Node_Str"");
  t.setDisplayName(""String_Node_Str"");
  t.setSuffix(""String_Node_Str"");
  t.setPlayers(new String[]{player});
  connection.sendPacket(t);
}","void createTeam(Connection.Unsafe connection,String player){
  Preconditions.checkArgument(player.length() <= 13);
  Team t=new Team();
  t.setName(""String_Node_Str"" + player);
  t.setMode((byte)0);
  t.setPrefix(""String_Node_Str"");
  t.setDisplayName(""String_Node_Str"");
  t.setSuffix(""String_Node_Str"");
  t.setPlayers(new String[]{player});
  connection.sendPacket(t);
}",0.9219653179190752
80936,"@Override public String getReplacement(ProxiedPlayer viewer,ServerInfo server,String args){
  if (Objects.equals(server,viewer.getServer()))   return args;
  return ""String_Node_Str"";
}","@Override public String getReplacement(ProxiedPlayer viewer,ServerInfo server,String args){
  if (viewer.getServer() != null && Objects.equals(server,viewer.getServer().getInfo()))   return args;
  return ""String_Node_Str"";
}",0.902439024390244
80937,"private void createSlot(int row){
  PlayerListItem pli=new PlayerListItem();
  pli.setAction(PlayerListItem.Action.ADD_PLAYER);
  Item item=new Item();
  UUID offlineId=java.util.UUID.nameUUIDFromBytes((""String_Node_Str"" + getSlotID(row)).getBytes(Charsets.UTF_8));
  item.setUuid(offlineId);
  item.setDisplayName(""String_Node_Str"");
  item.setGamemode(0);
  item.setPing(0);
  item.setUsername(getSlotID(row));
  item.setProperties(new String[0][0]);
  pli.setItems(new Item[]{item});
  getPlayer().unsafe().sendPacket(pli);
  send[row]=""String_Node_Str"";
  slots_ping[row]=0;
  sendTextures[row]=null;
}","private void createSlot(int row){
  PlayerListItem pli=new PlayerListItem();
  pli.setAction(PlayerListItem.Action.ADD_PLAYER);
  Item item=new Item();
  UUID offlineId=java.util.UUID.nameUUIDFromBytes((""String_Node_Str"" + getSlotID(row)).getBytes(Charsets.UTF_8));
  item.setUuid(offlineId);
  item.setDisplayName(""String_Node_Str"");
  item.setGamemode(0);
  item.setPing(0);
  item.setUsername(getSlotID(row));
  item.setProperties(new String[0][0]);
  pli.setItems(new Item[]{item});
  getPlayer().unsafe().sendPacket(pli);
  send[row]=null;
  slots_ping[row]=0;
  sendTextures[row]=null;
}",0.9824854045037532
80938,"private void removeSlot(int i){
  PlayerListItem pli=new PlayerListItem();
  pli.setAction(PlayerListItem.Action.REMOVE_PLAYER);
  Item item=new Item();
  UUID offlineId=java.util.UUID.nameUUIDFromBytes((""String_Node_Str"" + getSlotID(i)).getBytes(Charsets.UTF_8));
  item.setUuid(offlineId);
  item.setDisplayName(""String_Node_Str"");
  item.setGamemode(0);
  item.setPing(0);
  item.setUsername(getSlotID(i));
  item.setProperties(new String[0][0]);
  pli.setItems(new Item[]{item});
  getPlayer().unsafe().sendPacket(pli);
  uuidList[i]=null;
}","private void removeSlot(int i){
  PlayerListItem pli=new PlayerListItem();
  pli.setAction(PlayerListItem.Action.REMOVE_PLAYER);
  Item item=new Item();
  UUID offlineId=java.util.UUID.nameUUIDFromBytes((""String_Node_Str"" + getSlotID(i)).getBytes(Charsets.UTF_8));
  item.setUuid(offlineId);
  item.setDisplayName(""String_Node_Str"");
  item.setGamemode(0);
  item.setPing(0);
  item.setUsername(getSlotID(i));
  item.setProperties(new String[0][0]);
  pli.setItems(new Item[]{item});
  getPlayer().unsafe().sendPacket(pli);
  uuidList[i]=null;
  send.remove(offlineId);
}",0.9767025089605734
80939,"private void updateSlot(int row,String text,int ping){
  UUID offlineId=uuidList[row];
  if (ping != slots_ping[row]) {
    slots_ping[row]=ping;
    PlayerListItem pli=new PlayerListItem();
    pli.setAction(PlayerListItem.Action.UPDATE_LATENCY);
    Item item=new Item();
    item.setUuid(offlineId);
    item.setPing(ping);
    item.setUsername(getSlotID(row));
    item.setProperties(new String[0][0]);
    pli.setItems(new Item[]{item});
    getPlayer().unsafe().sendPacket(pli);
  }
  String old=send.get(offlineId);
  if (old == null || !old.equals(text)) {
    send.put(offlineId,text);
    PlayerListItem pli=new PlayerListItem();
    pli.setAction(PlayerListItem.Action.UPDATE_DISPLAY_NAME);
    Item item=new Item();
    item.setUuid(offlineId);
    item.setPing(ping);
    item.setDisplayName(ComponentSerializer.toString(TextComponent.fromLegacyText(text)));
    item.setUsername(getSlotID(row));
    item.setGamemode(0);
    item.setProperties(new String[0][0]);
    pli.setItems(new Item[]{item});
    getPlayer().unsafe().sendPacket(pli);
  }
}","private void updateSlot(int row,String text,int ping){
  UUID offlineId=uuidList[row];
  if (ping != slots_ping[row]) {
    slots_ping[row]=ping;
    PlayerListItem pli=new PlayerListItem();
    pli.setAction(PlayerListItem.Action.UPDATE_LATENCY);
    Item item=new Item();
    item.setUuid(offlineId);
    item.setPing(ping);
    item.setUsername(getSlotID(row));
    item.setProperties(new String[0][0]);
    pli.setItems(new Item[]{item});
    getPlayer().unsafe().sendPacket(pli);
  }
  String old=send.get(offlineId);
  if (old == null || !old.equals(text) || row >= sendSlots) {
    send.put(offlineId,text);
    PlayerListItem pli=new PlayerListItem();
    pli.setAction(PlayerListItem.Action.UPDATE_DISPLAY_NAME);
    Item item=new Item();
    item.setUuid(offlineId);
    item.setPing(ping);
    item.setDisplayName(ComponentSerializer.toString(TextComponent.fromLegacyText(text)));
    item.setUsername(getSlotID(row));
    item.setGamemode(0);
    item.setProperties(new String[0][0]);
    pli.setItems(new Item[]{item});
    getPlayer().unsafe().sendPacket(pli);
  }
}",0.9906542056074766
80940,"/** 
 * called when the plugin is disabled
 */
@Override public void onDisable(){
  ProxyServer.getInstance().getPluginManager().unregisterCommands(INSTANCE);
  ProxyServer.getInstance().getPluginManager().unregisterListeners(INSTANCE);
  ProxyServer.getInstance().getScheduler().cancel(INSTANCE);
  tabLists=null;
  variables=null;
  config=null;
  INSTANCE=null;
}","/** 
 * called when the plugin is disabled
 */
@Override public void onDisable(){
}",0.3697104677060133
80941,"public String getSuffix(ProxiedPlayer player){
  BungeePerms bp=(BungeePerms)plugin.getProxy().getPluginManager().getPlugin(""String_Node_Str"");
  String suffix=null;
  if (bp != null) {
    try {
      suffix=bp.getPermissionsManager().getMainGroup(bp.getPermissionsManager().getUser(player.getName())).getSuffix();
    }
 catch (    Throwable th) {
    }
  }
  if (suffix == null) {
    suffix=""String_Node_Str"";
  }
  String vsuffix=plugin.getBridge().getPlayerInformation(player,""String_Node_Str"");
  String mode=plugin.getConfigManager().getMainConfig().permissionSource;
  if (mode.equalsIgnoreCase(""String_Node_Str"")) {
    return suffix;
  }
 else   if (mode.equalsIgnoreCase(""String_Node_Str"")) {
    return vsuffix != null ? vsuffix : ""String_Node_Str"";
  }
  if (vsuffix != null) {
    return vsuffix;
  }
  return suffix;
}","public String getSuffix(ProxiedPlayer player){
  BungeePerms bp=(BungeePerms)plugin.getProxy().getPluginManager().getPlugin(""String_Node_Str"");
  String suffix=null;
  if (bp != null) {
    try {
      suffix=bp.getPermissionsManager().getMainGroup(bp.getPermissionsManager().getUser(player.getName())).getSuffix();
    }
 catch (    Throwable th) {
      BungeeTabListPlus.getInstance().reportError(th);
    }
  }
  String vsuffix=plugin.getBridge().getPlayerInformation(player,""String_Node_Str"");
  String mode=plugin.getConfigManager().getMainConfig().permissionSource;
  if (mode.equalsIgnoreCase(""String_Node_Str"")) {
    return suffix;
  }
 else   if (mode.equalsIgnoreCase(""String_Node_Str"")) {
    return vsuffix != null ? vsuffix : ""String_Node_Str"";
  }
  if (suffix != null) {
    return suffix;
  }
  if (vsuffix != null) {
    return vsuffix;
  }
  return ""String_Node_Str"";
}",0.8926291352292514
80942,"public String getPrefix(ProxiedPlayer player){
  BungeePerms bp=(BungeePerms)plugin.getProxy().getPluginManager().getPlugin(""String_Node_Str"");
  String bpprefix=null;
  if (bp != null) {
    try {
      bpprefix=bp.getPermissionsManager().getMainGroup(bp.getPermissionsManager().getUser(player.getName())).getPrefix();
    }
 catch (    Throwable th) {
    }
  }
  String bprefix=plugin.getConfigManager().getMainConfig().prefixes.get(getMainGroup(player));
  String vprefix=plugin.getBridge().getPlayerInformation(player,""String_Node_Str"");
  String mode=plugin.getConfigManager().getMainConfig().permissionSource;
  if (mode.equalsIgnoreCase(""String_Node_Str"")) {
    return bpprefix != null ? bpprefix : ""String_Node_Str"";
  }
 else   if (mode.equalsIgnoreCase(""String_Node_Str"")) {
    return vprefix != null ? vprefix : ""String_Node_Str"";
  }
 else   if (mode.equalsIgnoreCase(""String_Node_Str"")) {
    return bprefix;
  }
  if (vprefix != null) {
    return vprefix;
  }
  if (bpprefix != null) {
    return bpprefix;
  }
  return bprefix;
}","public String getPrefix(ProxiedPlayer player){
  BungeePerms bp=(BungeePerms)plugin.getProxy().getPluginManager().getPlugin(""String_Node_Str"");
  String bpprefix=null;
  if (bp != null) {
    try {
      bpprefix=bp.getPermissionsManager().getMainGroup(bp.getPermissionsManager().getUser(player.getName())).getPrefix();
    }
 catch (    Throwable th) {
      BungeeTabListPlus.getInstance().reportError(th);
    }
  }
  String bprefix=plugin.getConfigManager().getMainConfig().prefixes.get(getMainGroup(player));
  String vprefix=plugin.getBridge().getPlayerInformation(player,""String_Node_Str"");
  String mode=plugin.getConfigManager().getMainConfig().permissionSource;
  if (mode.equalsIgnoreCase(""String_Node_Str"")) {
    return bpprefix != null ? bpprefix : ""String_Node_Str"";
  }
 else   if (mode.equalsIgnoreCase(""String_Node_Str"")) {
    return vprefix != null ? vprefix : ""String_Node_Str"";
  }
 else   if (mode.equalsIgnoreCase(""String_Node_Str"")) {
    return bprefix;
  }
  if (bpprefix != null) {
    return bpprefix;
  }
  if (vprefix != null) {
    return vprefix;
  }
  return bprefix;
}",0.9530450953045096
80943,"public String getMainGroup(ProxiedPlayer player){
  String bpgroup=null;
  BungeePerms bp=(BungeePerms)plugin.getProxy().getPluginManager().getPlugin(""String_Node_Str"");
  if (bp != null) {
    try {
      bpgroup=bp.getPermissionsManager().getMainGroup(bp.getPermissionsManager().getUser(player.getName())).getName();
    }
 catch (    Throwable th) {
    }
  }
  String vgroup=plugin.getBridge().getPlayerInformation(player,""String_Node_Str"");
  String bgroup=null;
  if (player.getGroups().size() == 1) {
    bgroup=player.getGroups().iterator().next();
  }
  for (  String group : player.getGroups()) {
    if (!group.equals(""String_Node_Str"")) {
      bgroup=group;
      break;
    }
  }
  String mode=plugin.getConfigManager().getMainConfig().permissionSource;
  if (mode.equalsIgnoreCase(""String_Node_Str"")) {
    return bpgroup != null ? bpgroup : ""String_Node_Str"";
  }
 else   if (mode.equalsIgnoreCase(""String_Node_Str"")) {
    return vgroup != null ? vgroup : ""String_Node_Str"";
  }
 else   if (mode.equalsIgnoreCase(""String_Node_Str"")) {
    return bgroup;
  }
  if (vgroup != null) {
    return vgroup;
  }
  if (bpgroup != null) {
    return bpgroup;
  }
  return bgroup;
}","public String getMainGroup(ProxiedPlayer player){
  String bpgroup=null;
  BungeePerms bp=(BungeePerms)plugin.getProxy().getPluginManager().getPlugin(""String_Node_Str"");
  if (bp != null) {
    try {
      bpgroup=bp.getPermissionsManager().getMainGroup(bp.getPermissionsManager().getUser(player.getName())).getName();
    }
 catch (    Throwable th) {
      BungeeTabListPlus.getInstance().reportError(th);
    }
  }
  String vgroup=plugin.getBridge().getPlayerInformation(player,""String_Node_Str"");
  String bgroup=null;
  if (player.getGroups().size() == 1) {
    bgroup=player.getGroups().iterator().next();
  }
  for (  String group : player.getGroups()) {
    if (!group.equals(""String_Node_Str"")) {
      bgroup=group;
      break;
    }
  }
  String mode=plugin.getConfigManager().getMainConfig().permissionSource;
  if (mode.equalsIgnoreCase(""String_Node_Str"")) {
    return bpgroup != null ? bpgroup : ""String_Node_Str"";
  }
 else   if (mode.equalsIgnoreCase(""String_Node_Str"")) {
    return vgroup != null ? vgroup : ""String_Node_Str"";
  }
 else   if (mode.equalsIgnoreCase(""String_Node_Str"")) {
    return bgroup;
  }
  if (bpgroup != null) {
    return bpgroup;
  }
  if (vgroup != null) {
    return vgroup;
  }
  return bgroup;
}",0.9247842170160296
80944,"public boolean hasPermission(CommandSender sender,String permission){
  if (sender.hasPermission(permission)) {
    return true;
  }
  try {
    Boolean b=Boolean.valueOf(plugin.getBridge().getPlayerInformation((ProxiedPlayer)sender,permission));
    if (b != null) {
      return b;
    }
  }
 catch (  Throwable th) {
  }
  return false;
}","public boolean hasPermission(CommandSender sender,String permission){
  if (sender.hasPermission(permission)) {
    return true;
  }
  try {
    Boolean b=Boolean.valueOf(plugin.getBridge().getPlayerInformation((ProxiedPlayer)sender,permission));
    if (b != null) {
      return b;
    }
  }
 catch (  Throwable th) {
    BungeeTabListPlus.getInstance().reportError(th);
  }
  return false;
}",0.8761904761904762
80945,"public int comparePlayers(ProxiedPlayer p1,ProxiedPlayer p2){
  BungeePerms bp=(BungeePerms)plugin.getProxy().getPluginManager().getPlugin(""String_Node_Str"");
  if (bp != null) {
    try {
      Group g1=bp.getPermissionsManager().getMainGroup(bp.getPermissionsManager().getUser(p1.getName()));
      Group g2=bp.getPermissionsManager().getMainGroup(bp.getPermissionsManager().getUser(p2.getName()));
      int r1=g1.getRank();
      int r2=g2.getRank();
      if (r1 > r2) {
        return 1;
      }
      if (r2 > r1) {
        return -1;
      }
      return 0;
    }
 catch (    Throwable th) {
    }
  }
  int i=0;
  for (  String group : p1.getGroups()) {
    if (!group.equals(""String_Node_Str"")) {
      i=1;
    }
  }
  int j=0;
  for (  String group : p2.getGroups()) {
    if (!group.equals(""String_Node_Str"")) {
      j=1;
    }
  }
  if (i > j) {
    return 1;
  }
  if (j > i) {
    return -1;
  }
  return 0;
}","public int comparePlayers(ProxiedPlayer p1,ProxiedPlayer p2){
  BungeePerms bp=(BungeePerms)plugin.getProxy().getPluginManager().getPlugin(""String_Node_Str"");
  if (bp != null) {
    try {
      Group g1=bp.getPermissionsManager().getMainGroup(bp.getPermissionsManager().getUser(p1.getName()));
      Group g2=bp.getPermissionsManager().getMainGroup(bp.getPermissionsManager().getUser(p2.getName()));
      int r1=g1.getRank();
      int r2=g2.getRank();
      if (r1 > r2) {
        return 1;
      }
      if (r2 > r1) {
        return -1;
      }
      return 0;
    }
 catch (    Throwable th) {
      BungeeTabListPlus.getInstance().reportError(th);
    }
  }
  int i=0;
  for (  String group : p1.getGroups()) {
    if (!group.equals(""String_Node_Str"")) {
      i=1;
    }
  }
  int j=0;
  for (  String group : p2.getGroups()) {
    if (!group.equals(""String_Node_Str"")) {
      j=1;
    }
  }
  if (i > j) {
    return 1;
  }
  if (j > i) {
    return -1;
  }
  return 0;
}",0.9711588883062402
80946,"public String getDisplayPrefix(ProxiedPlayer player){
  BungeePerms bp=(BungeePerms)plugin.getProxy().getPluginManager().getPlugin(""String_Node_Str"");
  String display=null;
  if (bp != null) {
    try {
      display=bp.getPermissionsManager().getMainGroup(bp.getPermissionsManager().getUser(player.getName())).getDisplay();
    }
 catch (    Throwable th) {
    }
  }
  if (display == null) {
    display=""String_Node_Str"";
  }
  return display;
}","public String getDisplayPrefix(ProxiedPlayer player){
  BungeePerms bp=(BungeePerms)plugin.getProxy().getPluginManager().getPlugin(""String_Node_Str"");
  String display=null;
  if (bp != null) {
    try {
      display=bp.getPermissionsManager().getMainGroup(bp.getPermissionsManager().getUser(player.getName())).getDisplay();
    }
 catch (    Throwable th) {
      BungeeTabListPlus.getInstance().reportError(th);
    }
  }
  if (display == null) {
    display=""String_Node_Str"";
  }
  return display;
}",0.9422875131164744
80947,"private void invalidShowTo(TabListConfig config){
  plugin.getLogger().warning(ChatColor.RED + config.getFileName() + ""String_Node_Str"");
}","private void invalidShowTo(TabListConfig config){
  plugin.getLogger().log(Level.WARNING,""String_Node_Str"",new Object[]{ChatColor.RED,config.getFileName()});
}",0.7516778523489933
80948,"public String replaceVariables(String s){
  StringBuffer sb=new StringBuffer();
  Pattern pattern=Pattern.compile(""String_Node_Str"");
  Matcher matcher=pattern.matcher(s);
  while (matcher.find()) {
    String var=s.substring(matcher.start(),matcher.end());
    var=var.replaceAll(""String_Node_Str"",""String_Node_Str"");
    String arg=null;
    if (var.contains(""String_Node_Str"")) {
      arg=var.substring(var.indexOf(""String_Node_Str""),var.length());
      var=var.substring(0,var.indexOf(""String_Node_Str""));
    }
    Variable variable=this.variables.get(var);
    String replacement=""String_Node_Str"" + var + ""String_Node_Str"";
    if (variable != null) {
      replacement=variable.getReplacement(arg);
    }
    matcher.appendReplacement(sb,replacement);
  }
  matcher.appendTail(sb);
  return sb.toString();
}","public String replaceVariables(String s){
  StringBuffer sb=new StringBuffer();
  Pattern pattern=Pattern.compile(""String_Node_Str"");
  Matcher matcher=pattern.matcher(s);
  while (matcher.find()) {
    String var=s.substring(matcher.start(),matcher.end());
    var=var.replaceAll(""String_Node_Str"",""String_Node_Str"");
    String arg=null;
    String replacement=""String_Node_Str"" + var + ""String_Node_Str"";
    if (var.contains(""String_Node_Str"")) {
      arg=var.substring(var.indexOf(""String_Node_Str"") + 1);
      var=var.substring(0,var.indexOf(""String_Node_Str""));
    }
    Variable variable=this.variables.get(var);
    if (variable != null) {
      replacement=variable.getReplacement(arg);
    }
    matcher.appendReplacement(sb,replacement);
  }
  matcher.appendTail(sb);
  return sb.toString();
}",0.905846153846154
80949,"public String replacePlayerVariables(String s,ProxiedPlayer player){
  if (player.getServer() != null) {
    s=replaceServerVariables(s,player.getServer().getInfo());
  }
  StringBuffer sb=new StringBuffer();
  Pattern pattern=Pattern.compile(""String_Node_Str"");
  Matcher matcher=pattern.matcher(s);
  while (matcher.find()) {
    String var=s.substring(matcher.start(),matcher.end());
    var=var.replaceAll(""String_Node_Str"",""String_Node_Str"");
    String arg=null;
    if (var.contains(""String_Node_Str"")) {
      arg=var.substring(var.indexOf(""String_Node_Str""),var.length());
      var=var.substring(0,var.indexOf(""String_Node_Str""));
    }
    PlayerVariable variable=this.playerVariables.get(var);
    String replacement=""String_Node_Str"" + var + ""String_Node_Str"";
    if (variable != null) {
      replacement=variable.getReplacement(arg,player);
    }
    matcher.appendReplacement(sb,replacement);
  }
  matcher.appendTail(sb);
  return sb.toString();
}","public String replacePlayerVariables(String s,ProxiedPlayer player){
  if (player.getServer() != null) {
    s=replaceServerVariables(s,player.getServer().getInfo());
  }
  StringBuffer sb=new StringBuffer();
  Pattern pattern=Pattern.compile(""String_Node_Str"");
  Matcher matcher=pattern.matcher(s);
  while (matcher.find()) {
    String var=s.substring(matcher.start(),matcher.end());
    var=var.replaceAll(""String_Node_Str"",""String_Node_Str"");
    String arg=null;
    String replacement=""String_Node_Str"" + var + ""String_Node_Str"";
    if (var.contains(""String_Node_Str"")) {
      arg=var.substring(var.indexOf(""String_Node_Str"") + 1);
      var=var.substring(0,var.indexOf(""String_Node_Str""));
    }
    PlayerVariable variable=this.playerVariables.get(var);
    if (variable != null) {
      replacement=variable.getReplacement(arg,player);
    }
    matcher.appendReplacement(sb,replacement);
  }
  matcher.appendTail(sb);
  return sb.toString();
}",0.9203539823008848
80950,"public String replaceServerVariables(String s,ServerInfo server){
  StringBuffer sb=new StringBuffer();
  Pattern pattern=Pattern.compile(""String_Node_Str"");
  Matcher matcher=pattern.matcher(s);
  while (matcher.find()) {
    String var=s.substring(matcher.start(),matcher.end());
    var=var.replaceAll(""String_Node_Str"",""String_Node_Str"");
    String arg=null;
    if (var.contains(""String_Node_Str"")) {
      arg=var.substring(var.indexOf(""String_Node_Str""),var.length());
      var=var.substring(0,var.indexOf(""String_Node_Str""));
    }
    ServerVariable variable=this.serverVariables.get(var);
    String replacement=""String_Node_Str"" + var + ""String_Node_Str"";
    if (variable != null) {
      replacement=variable.getReplacement(arg,server);
    }
    matcher.appendReplacement(sb,replacement);
  }
  matcher.appendTail(sb);
  return sb.toString();
}","public String replaceServerVariables(String s,ServerInfo server){
  StringBuffer sb=new StringBuffer();
  Pattern pattern=Pattern.compile(""String_Node_Str"");
  Matcher matcher=pattern.matcher(s);
  while (matcher.find()) {
    String var=s.substring(matcher.start(),matcher.end());
    var=var.replaceAll(""String_Node_Str"",""String_Node_Str"");
    String arg=null;
    String replacement=""String_Node_Str"" + var + ""String_Node_Str"";
    if (var.contains(""String_Node_Str"")) {
      arg=var.substring(var.indexOf(""String_Node_Str"") + 1);
      var=var.substring(0,var.indexOf(""String_Node_Str""));
    }
    ServerVariable variable=this.serverVariables.get(var);
    if (variable != null) {
      replacement=variable.getReplacement(arg,server);
    }
    matcher.appendReplacement(sb,replacement);
  }
  matcher.appendTail(sb);
  return sb.toString();
}",0.9105786090005844
80951,"/** 
 * Gets the actual link from the given shortened URL.
 * @param toShorten The URL to unshorten
 * @return The actual URL that will be served
 */
public static String unshortenURL(String toShorten){
  URLConnection myConn=null;
  try {
    URL myURL=new URL(toShorten);
    myConn=myURL.openConnection();
    myConn.getInputStream();
  }
 catch (  Exception e) {
  }
  if (myConn != null) {
    return myConn.getURL().toString();
  }
 else {
    return toShorten;
  }
}","/** 
 * Gets the actual link from the given shortened URL. The URL should be an HTTP or HTTPS URL.
 * @param toShorten The URL to unshorten
 * @return The actual URL that will be served, or null if an error occurs
 */
public static String unshortenURL(String toShorten){
  try {
    HttpURLConnection connection=(HttpURLConnection)new URL(toShorten).openConnection();
    if (connection.getResponseCode() >= 300 && connection.getResponseCode() < 400) {
      if (connection.getHeaderField(""String_Node_Str"") != null) {
        return unshortenURL(connection.getHeaderField(""String_Node_Str""));
      }
 else {
        System.out.println(connection.getResponseCode() + ""String_Node_Str"");
        return null;
      }
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
    return null;
  }
  return toShorten;
}",0.4195046439628483
80952,"/** 
 * Checks whether or not the given URL is a PAX ticket page or a queue page.
 * @param URL The URL to check
 * @return True if it is, false if not
 */
public boolean isPaxPage(String URL){
  try {
    HttpURLConnection connect=Browser.setUpConnection(new URL(URL));
    if (connect.getResponseCode() >= 300 && connect.getResponseCode() < 400) {
      if (connect.getHeaderField(""String_Node_Str"") != null) {
        return isPaxPage(connect.getHeaderField(""String_Node_Str""));
      }
 else {
        System.out.println(connect.getResponseCode() + ""String_Node_Str"");
        return false;
      }
    }
    BufferedReader reader=new BufferedReader(new InputStreamReader(connect.getInputStream()));
    String text=""String_Node_Str"";
    String line;
    while ((line=reader.readLine()) != null) {
      DataTracker.addDataUsed(line.length());
      text+=line.toLowerCase();
    }
    if (text.contains(""String_Node_Str"")) {
      System.out.println(""String_Node_Str"");
      return true;
    }
 else     if (text.contains(""String_Node_Str"")) {
      if (strictFiltering) {
        System.out.println(""String_Node_Str"");
        return false;
      }
 else {
        System.out.println(""String_Node_Str"");
        return true;
      }
    }
 else {
      System.out.println(""String_Node_Str"");
      return false;
    }
  }
 catch (  IOException iOException) {
    System.out.println(""String_Node_Str"");
    return !strictFiltering;
  }
}","/** 
 * Checks whether or not the given URL is a PAX ticket page or a queue page. Note that this does NOT follow any redirects.
 * @param link The URL to check
 * @return True if it is, false if not
 */
public boolean isPaxPage(String link){
  try {
    URLConnection connect=new URL(link).openConnection();
    BufferedReader reader=new BufferedReader(new InputStreamReader(connect.getInputStream()));
    String line;
    while ((line=reader.readLine().toLowerCase()) != null) {
      DataTracker.addDataUsed(line.length());
      if (line.contains(""String_Node_Str"")) {
        System.out.println(""String_Node_Str"");
        return true;
      }
 else       if (line.contains(""String_Node_Str"")) {
        if (strictFiltering) {
          System.out.println(""String_Node_Str"");
        }
 else {
          System.out.println(""String_Node_Str"");
          return true;
        }
      }
    }
  }
 catch (  IOException iOException) {
    System.out.println(""String_Node_Str"");
    return !strictFiltering;
  }
  System.out.println(""String_Node_Str"");
  return false;
}",0.3794749403341289
80953,"private void updateLinkFromSet(Set<String> mySet){
  for (  String i : mySet) {
    if (!alreadyChecked.contains(i)) {
      System.out.println(""String_Node_Str"" + i);
      if (showReader.isPaxPage(i)) {
        originalLink=i;
        currentLink=Browser.unshortenURL(i);
        System.out.println(""String_Node_Str"" + originalLink + ""String_Node_Str""+ currentLink);
        break;
      }
 else {
        System.out.println(""String_Node_Str"");
        alreadyChecked.add(i);
      }
    }
  }
}","private void updateLinkFromSet(Set<String> allLinksFound){
  for (  String link : allLinksFound) {
    if (!alreadyChecked.contains(link)) {
      link=Browser.unshortenURL(link);
      if (!alreadyChecked.contains(link)) {
        System.out.println(""String_Node_Str"" + link);
        if (showReader.isPaxPage(link)) {
          currentLink=link;
          System.out.println(""String_Node_Str"" + currentLink);
          break;
        }
 else {
          System.out.println(""String_Node_Str"");
          alreadyChecked.add(link);
        }
      }
    }
  }
}",0.5960264900662252
80954,"@Override public synchronized boolean ticketsFound(){
  if (currentLink == null) {
    return false;
  }
  return !alreadyChecked.contains(currentLink);
}","@Override public synchronized boolean ticketsFound(){
  return currentLink != null;
}",0.6527196652719666
80955,"@Override public synchronized void reset(){
  if (currentLink == null) {
    Set<String> mySet=getLinks();
    for (    String i : mySet) {
      alreadyChecked.add(i);
      currentLink=i;
    }
  }
 else {
    System.out.println(""String_Node_Str"" + originalLink + ""String_Node_Str"");
    alreadyChecked.add(originalLink);
  }
}","@Override public synchronized void reset(){
  if (currentLink != null) {
    System.out.println(""String_Node_Str"" + currentLink + ""String_Node_Str"");
    alreadyChecked.add(currentLink);
    currentLink=null;
  }
}",0.5009208103130756
80956,"@Override public synchronized void updateLink(){
  updateLink(""String_Node_Str"");
  Set<String> mySet=getLinks();
  updateLinkFromSet(mySet);
  updateLink(getLink());
}","@Override public synchronized void updateLink(){
  updateLink(""String_Node_Str"");
  Set<String> allLinksFound=getLinks();
  if (alreadyChecked.isEmpty()) {
    alreadyChecked.addAll(allLinksFound);
  }
 else {
    updateLinkFromSet(allLinksFound);
  }
  updateLink(getLink());
}",0.5291479820627802
80957,"/** 
 * Creates a new CheckShowclix.
 * @param expo The expo to check
 * @param shouldFilterShowclix True to use strict Showclix filtering, false to not
 */
public CheckShowclix(Expo expo,boolean shouldFilterShowclix){
  super();
  expoToCheck=expo;
  showReader=new ShowclixReader(expoToCheck);
  if (shouldFilterShowclix) {
    showReader.strictFilter();
  }
}","/** 
 * Creates a new CheckShowclix.
 * @param expo The expo to check
 * @param shouldFilterShowclix True to use strict Showclix filtering, false to not
 */
public CheckShowclix(Expo expo,boolean shouldFilterShowclix){
  super();
  showReader=new ShowclixReader(expo);
  if (shouldFilterShowclix) {
    showReader.strictFilter();
  }
}",0.7317073170731707
80958,"@Override public void onStatus(Status status){
  System.out.println(""String_Node_Str"" + status.getUser().getScreenName() + ""String_Node_Str""+ status.getText());
  if (status.isRetweet()) {
    System.out.println(""String_Node_Str"");
  }
 else   if (filterKeywords && !hasKeyword(status.getText())) {
    System.out.println(""String_Node_Str"");
  }
 else {
    for (    twitter4j.URLEntity url : status.getURLEntities()) {
      System.out.println(""String_Node_Str"" + url.getDisplayURL());
      System.out.println(""String_Node_Str"" + url.getExpandedURL());
      System.out.println(""String_Node_Str"" + url.getText());
      System.out.println(""String_Node_Str"" + url.getURL());
      linkFound(url.getExpandedURL(),status.getText());
    }
  }
}","@Override public void onStatus(Status status){
  System.out.println(""String_Node_Str"" + status.getUser().getScreenName() + ""String_Node_Str""+ status.getText());
  if (status.isRetweet()) {
    System.out.println(""String_Node_Str"");
  }
 else   if (filterKeywords && !hasKeyword(status.getText())) {
    System.out.println(""String_Node_Str"");
  }
 else {
    for (    twitter4j.URLEntity url : status.getURLEntities()) {
      System.out.println(""String_Node_Str"" + url.getDisplayURL());
      System.out.println(""String_Node_Str"" + url.getExpandedURL());
      System.out.println(""String_Node_Str"" + url.getText());
      System.out.println(""String_Node_Str"" + url.getURL());
      if (url.getExpandedURL().contains(""String_Node_Str"")) {
        linkFound(url.getExpandedURL(),status.getText());
      }
 else {
        System.out.println(""String_Node_Str"");
        String finalURL=Browser.unshortenURL(url.getExpandedURL());
        if (finalURL.contains(""String_Node_Str"")) {
          linkFound(finalURL,status.getText());
        }
      }
    }
  }
}",0.8260144524735964
80959,"@Override public void linkFound(String link,String statusText){
  Browser.openLinkInBrowser(link);
  email.sendMessage(""String_Node_Str"",""String_Node_Str"" + statusText + ""String_Node_Str""+ link);
}","@Override public void linkFound(String link,String statusText){
  checker.addLinkFound(link);
  Browser.openLinkInBrowser(link);
  if (email != null) {
    email.sendMessage(""String_Node_Str"",""String_Node_Str"" + statusText + ""String_Node_Str""+ link);
  }
}",0.869757174392936
80960,"private static TwitterStreamer setupTwitter(final Status myStatus,final String[] keys,final EmailAccount email){
  return new TwitterStreamer(keys){
    @Override public void twitterConnected(){
      myStatus.setTwitterStatus(true);
    }
    @Override public void twitterDisconnected(){
      myStatus.setTwitterStatus(false);
    }
    @Override public void twitterKilled(){
      myStatus.twitterStreamKilled();
    }
    @Override public void linkFound(    String link,    String statusText){
      Browser.openLinkInBrowser(link);
      email.sendMessage(""String_Node_Str"",""String_Node_Str"" + statusText + ""String_Node_Str""+ link);
    }
  }
;
}","private static TwitterStreamer setupTwitter(final Status myStatus,final String[] keys,final EmailAccount email,final TicketChecker checker){
  return new TwitterStreamer(keys){
    @Override public void twitterConnected(){
      myStatus.setTwitterStatus(true);
    }
    @Override public void twitterDisconnected(){
      myStatus.setTwitterStatus(false);
    }
    @Override public void twitterKilled(){
      myStatus.twitterStreamKilled();
    }
    @Override public void linkFound(    String link,    String statusText){
      checker.addLinkFound(link);
      Browser.openLinkInBrowser(link);
      if (email != null) {
        email.sendMessage(""String_Node_Str"",""String_Node_Str"" + statusText + ""String_Node_Str""+ link);
      }
    }
  }
;
}",0.9293361884368307
80961,"private static TicketChecker initChecker(Setup mySetup,StatusGUI myStatus,String expo){
  TicketChecker myChecker=new TicketChecker(myStatus);
  if (mySetup.shouldCheckPAXWebsite()) {
    myChecker.addChecker(new CheckPaxsite(expo));
  }
  if (mySetup.shouldCheckShowclix()) {
    myChecker.addChecker(new CheckShowclix(expo));
  }
  if (mySetup.shouldCheckKnownEvents()) {
    myChecker.addChecker(new CheckShowclixEventPage());
  }
  myChecker.initCheckers();
  return myChecker;
}","private static TicketChecker initChecker(Setup mySetup,StatusGUI myStatus,Expo expo){
  TicketChecker myChecker=new TicketChecker(myStatus);
  if (mySetup.shouldCheckPAXWebsite()) {
    myChecker.addChecker(new CheckPaxsite(expo.toString()));
  }
  if (mySetup.shouldCheckShowclix()) {
    myChecker.addChecker(new CheckShowclix(expo.toString()));
  }
  if (mySetup.shouldCheckKnownEvents()) {
    myChecker.addChecker(new CheckShowclixEventPage());
  }
  myChecker.initCheckers();
  return myChecker;
}",0.9675456389452332
80962,"/** 
 * @param args the command line arguments
 */
public static void main(String[] args){
  removeOldPreferences();
  System.out.println(""String_Node_Str"");
  java.net.HttpURLConnection.setFollowRedirects(true);
  boolean isHeadless=GraphicsEnvironment.isHeadless();
  boolean isAutostart=false;
  boolean checkUpdates=true;
  boolean checkNotifications=true;
  boolean startMinimized=false;
  List<String> followList=new ArrayList<>();
  Map<String,String> properties=new HashMap<>();
  String[] twitterTokens=new String[4];
  for (int i=0; i < args.length; i++) {
switch (args[i].toLowerCase()) {
case ""String_Node_Str"":
      isHeadless=true;
    break;
case ""String_Node_Str"":
  isAutostart=true;
break;
case ""String_Node_Str"":
checkUpdates=false;
break;
case ""String_Node_Str"":
checkNotifications=false;
break;
case ""String_Node_Str"":
case ""String_Node_Str"":
followList.add(args[i + 1]);
break;
case ""String_Node_Str"":
startMinimized=true;
break;
case ""String_Node_Str"":
if (args.length > i + 2) {
String key=args[i + 1];
String value=args[i + 2];
if (!key.startsWith(""String_Node_Str"") && !value.startsWith(""String_Node_Str"")) {
properties.put(key,value);
}
 else {
System.out.println(""String_Node_Str"");
}
}
 else {
System.out.println(""String_Node_Str"");
}
break;
case ""String_Node_Str"":
if (args.length > i + 4) {
twitterTokens[0]=args[i + 1];
twitterTokens[1]=args[i + 2];
twitterTokens[2]=args[i + 3];
twitterTokens[3]=args[i + 4];
for (String s : twitterTokens) {
if (s.startsWith(""String_Node_Str"")) {
System.out.println(""String_Node_Str"" + s + ""String_Node_Str"");
for (int j=0; j < twitterTokens.length; j++) {
twitterTokens[j]=null;
}
break;
}
}
}
 else {
System.out.println(""String_Node_Str"");
}
break;
case ""String_Node_Str"":
try {
SavePrintStream printer;
if (args.length > i + 1 && !args[i + 1].startsWith(""String_Node_Str"")) {
printer=new SavePrintStream(System.out,args[i + 1]);
}
 else {
printer=new SavePrintStream(System.out);
}
System.setOut(printer);
System.setErr(printer);
}
 catch (FileNotFoundException fnfe) {
System.out.println(""String_Node_Str"");
fnfe.printStackTrace();
}
break;
case ""String_Node_Str"":
Audio.setAlarmFile(args[i + 1]);
break;
case ""String_Node_Str"":
break;
default :
if (args[i].startsWith(""String_Node_Str"")) {
System.out.println(""String_Node_Str"" + args[i]);
}
break;
}
}
final Startup loadingOutput;
if (isHeadless) {
ErrorBuilder.forceCommandLine();
loadingOutput=new LoadingCLI(System.out);
}
 else {
loadingOutput=new LoadingWindow();
}
String patchNotes=null;
loadingOutput.start();
loadResources(loadingOutput,hasArgument(args,""String_Node_Str""));
if (!isHeadless) {
if (checkUpdates) {
patchNotes=loadUpdates(loadingOutput);
}
if (checkNotifications) {
loadNotifications(loadingOutput);
}
}
 else {
System.out.println(""String_Node_Str"");
}
loadingOutput.stop();
Setup mySetup;
if (isAutostart) {
mySetup=new SetupAuto(args);
}
 else if (isHeadless) {
mySetup=new SetupCLI(twitterTokens);
}
 else {
SetupGUI myGUI=new SetupGUI(twitterTokens);
if (patchNotes != null) {
myGUI.setPatchNotesText(patchNotes);
}
 else {
myGUI.setPatchNotesText(""String_Node_Str"");
}
mySetup=myGUI;
}
mySetup.promptForSettings();
twitterTokens[0]=mySetup.getTwitterConsumerKey();
twitterTokens[1]=mySetup.getTwitterConsumerSecret();
twitterTokens[2]=mySetup.getTwitterApplicationKey();
twitterTokens[3]=mySetup.getTwitterApplicationSecret();
Browser myBrowser=new Browser();
myBrowser.setExpo(mySetup.getExpoToCheck());
if (mySetup.shouldFilterShowclix()) {
com.github.sunnybat.paxchecker.browser.ShowclixReader.strictFilter();
}
Status myStatus;
EmailAccount emailAccount;
try {
emailAccount=new EmailAccount(mySetup.getEmailUsername(),mySetup.getEmailPassword());
for (String s : mySetup.getEmailAddresses()) {
emailAccount.addEmailAddress(s);
}
for (String key : properties.keySet()) {
emailAccount.setProperty(key,properties.get(key));
}
}
 catch (IllegalArgumentException e) {
emailAccount=null;
}
if (!isHeadless) {
StatusGUI statGUI;
if (emailAccount != null) {
statGUI=new StatusGUI(myBrowser.getExpo(),emailAccount.getUsername(),emailAccount.getAddressList());
}
 else {
statGUI=new StatusGUI(myBrowser.getExpo());
}
myStatus=statGUI;
if (startMinimized) {
statGUI.minimizeToTray();
}
 else {
statGUI.showWindow();
}
}
 else {
myStatus=new StatusCLI();
}
if (emailAccount != null) {
myStatus.enableEmail();
}
if (mySetup.shouldPlayAlarm()) {
Audio.enableAlarm();
myStatus.enableAlarm();
}
final TicketChecker myChecker=initChecker(mySetup,isHeadless ? null : (StatusGUI)myStatus,myBrowser.getExpo());
if (mySetup.shouldCheckTwitter()) {
TwitterStreamer tcheck=setupTwitter(myStatus,twitterTokens,emailAccount);
for (String s : followList) {
tcheck.addUser(s);
}
tcheck.startStreamingTwitter();
myStreamer=tcheck;
myStatus.enableTwitter();
}
checkForTickets(myStatus,myChecker,emailAccount,mySetup.timeBetweenChecks());
}","/** 
 * @param args the command line arguments
 */
public static void main(String[] args){
  removeOldPreferences();
  System.out.println(""String_Node_Str"");
  java.net.HttpURLConnection.setFollowRedirects(true);
  boolean isHeadless=GraphicsEnvironment.isHeadless();
  boolean isAutostart=false;
  boolean checkUpdates=true;
  boolean checkNotifications=true;
  boolean startMinimized=false;
  List<String> followList=new ArrayList<>();
  Map<String,String> properties=new HashMap<>();
  String[] twitterTokens=new String[4];
  for (int i=0; i < args.length; i++) {
switch (args[i].toLowerCase()) {
case ""String_Node_Str"":
      isHeadless=true;
    break;
case ""String_Node_Str"":
  isAutostart=true;
break;
case ""String_Node_Str"":
checkUpdates=false;
break;
case ""String_Node_Str"":
checkNotifications=false;
break;
case ""String_Node_Str"":
case ""String_Node_Str"":
followList.add(args[i + 1]);
break;
case ""String_Node_Str"":
startMinimized=true;
break;
case ""String_Node_Str"":
if (args.length > i + 2) {
String key=args[i + 1];
String value=args[i + 2];
if (!key.startsWith(""String_Node_Str"") && !value.startsWith(""String_Node_Str"")) {
properties.put(key,value);
}
 else {
System.out.println(""String_Node_Str"");
}
}
 else {
System.out.println(""String_Node_Str"");
}
break;
case ""String_Node_Str"":
if (args.length > i + 4) {
twitterTokens[0]=args[i + 1];
twitterTokens[1]=args[i + 2];
twitterTokens[2]=args[i + 3];
twitterTokens[3]=args[i + 4];
for (String s : twitterTokens) {
if (s.startsWith(""String_Node_Str"")) {
System.out.println(""String_Node_Str"" + s + ""String_Node_Str"");
for (int j=0; j < twitterTokens.length; j++) {
twitterTokens[j]=null;
}
break;
}
}
}
 else {
System.out.println(""String_Node_Str"");
}
break;
case ""String_Node_Str"":
try {
SavePrintStream printer;
if (args.length > i + 1 && !args[i + 1].startsWith(""String_Node_Str"")) {
printer=new SavePrintStream(System.out,args[i + 1]);
}
 else {
printer=new SavePrintStream(System.out);
}
System.setOut(printer);
System.setErr(printer);
}
 catch (FileNotFoundException fnfe) {
System.out.println(""String_Node_Str"");
fnfe.printStackTrace();
}
break;
case ""String_Node_Str"":
Audio.setAlarmFile(args[i + 1]);
break;
case ""String_Node_Str"":
break;
default :
if (args[i].startsWith(""String_Node_Str"")) {
System.out.println(""String_Node_Str"" + args[i]);
}
break;
}
}
final Startup loadingOutput;
if (isHeadless) {
ErrorBuilder.forceCommandLine();
loadingOutput=new LoadingCLI(System.out);
}
 else {
loadingOutput=new LoadingWindow();
}
String patchNotes=null;
loadingOutput.start();
loadResources(loadingOutput,hasArgument(args,""String_Node_Str""));
if (!isHeadless) {
if (checkUpdates) {
patchNotes=loadUpdates(loadingOutput);
}
if (checkNotifications) {
loadNotifications(loadingOutput);
}
}
 else {
System.out.println(""String_Node_Str"");
}
loadingOutput.stop();
Setup mySetup;
if (isAutostart) {
mySetup=new SetupAuto(args);
}
 else if (isHeadless) {
mySetup=new SetupCLI(twitterTokens);
}
 else {
SetupGUI myGUI=new SetupGUI(twitterTokens);
if (patchNotes != null) {
myGUI.setPatchNotesText(patchNotes);
}
 else {
myGUI.setPatchNotesText(""String_Node_Str"");
}
mySetup=myGUI;
}
mySetup.promptForSettings();
twitterTokens[0]=mySetup.getTwitterConsumerKey();
twitterTokens[1]=mySetup.getTwitterConsumerSecret();
twitterTokens[2]=mySetup.getTwitterApplicationKey();
twitterTokens[3]=mySetup.getTwitterApplicationSecret();
Expo myExpo=Expo.parseExpo(mySetup.getExpoToCheck());
if (mySetup.shouldFilterShowclix()) {
com.github.sunnybat.paxchecker.browser.ShowclixReader.strictFilter();
}
Status myStatus;
EmailAccount emailAccount;
try {
emailAccount=new EmailAccount(mySetup.getEmailUsername(),mySetup.getEmailPassword());
for (String s : mySetup.getEmailAddresses()) {
emailAccount.addEmailAddress(s);
}
for (String key : properties.keySet()) {
emailAccount.setProperty(key,properties.get(key));
}
}
 catch (IllegalArgumentException e) {
emailAccount=null;
}
if (!isHeadless) {
StatusGUI statGUI;
if (emailAccount != null) {
statGUI=new StatusGUI(myExpo,emailAccount.getUsername(),emailAccount.getAddressList());
}
 else {
statGUI=new StatusGUI(myExpo);
}
myStatus=statGUI;
if (startMinimized) {
statGUI.minimizeToTray();
}
 else {
statGUI.showWindow();
}
}
 else {
myStatus=new StatusCLI();
}
if (emailAccount != null) {
myStatus.enableEmail();
}
if (mySetup.shouldPlayAlarm()) {
Audio.enableAlarm();
myStatus.enableAlarm();
}
final TicketChecker myChecker=initChecker(mySetup,isHeadless ? null : (StatusGUI)myStatus,myExpo);
if (mySetup.shouldCheckTwitter()) {
TwitterStreamer tcheck=setupTwitter(myStatus,twitterTokens,mySetup.shouldTextTweets() ? emailAccount : null,myChecker);
for (String s : followList) {
tcheck.addUser(s);
}
tcheck.startStreamingTwitter();
myStreamer=tcheck;
myStatus.enableTwitter();
}
checkForTickets(myStatus,myChecker,emailAccount,mySetup.timeBetweenChecks());
}",0.984457025218734
80963,"/** 
 * Checks for tickets. Blocks indefinitely. Note that if checker is not checking anything, this method does not block and only modifies the StatusGUI GUI status text.
 * @param status The StatusGUI window to update
 * @param checker The TicketChecker to use
 * @param email The EmailAccount to use, or null for none
 * @param checkTime The time between checks
 * @throws NullPointerException if any arguments besides email are null
 */
private static void checkForTickets(Status status,TicketChecker checker,EmailAccount email,int checkTime){
  if (checker.isCheckingAnything()) {
    while (true) {
      status.setLastCheckedText(""String_Node_Str"");
      long startTime=System.currentTimeMillis();
      if (checker.isUpdated()) {
        Browser.openLinkInBrowser(checker.getLinkFound());
        if (email != null) {
          try {
            email.sendMessage(""String_Node_Str"",""String_Node_Str"" + checker.getLinkFound());
          }
 catch (          IllegalStateException e) {
            System.out.println(""String_Node_Str"" + e.getMessage() + ""String_Node_Str"");
          }
        }
        Tickets ticketWindow=new Tickets(checker.getLinkFound());
        ticketWindow.showWindow();
      }
      status.setDataUsageText(DataTracker.getDataUsedMB());
      while (System.currentTimeMillis() - startTime < checkTime * 1000) {
synchronized (status) {
          int button=status.getButtonPressed();
          if (button > 0) {
            status.resetButtonPressed();
            if (button == 1) {
              break;
            }
 else             if (button == 2) {
              if (email != null) {
                status.setInformationText(""String_Node_Str"");
                try {
                  if (email.sendMessage(""String_Node_Str"",""String_Node_Str"")) {
                    status.setInformationText(""String_Node_Str"");
                  }
 else {
                    status.setInformationText(""String_Node_Str"");
                  }
                }
 catch (                IllegalStateException e) {
                  status.setInformationText(""String_Node_Str"");
                }
              }
            }
 else             if (button == 3) {
              if (Audio.playAlarm()) {
                status.setInformationText(""String_Node_Str"");
              }
 else {
                status.setInformationText(""String_Node_Str"");
              }
            }
 else             if (button == 4) {
              if (myStreamer != null) {
                myStreamer.startStreamingTwitter();
              }
            }
          }
        }
        status.setLastCheckedText(checkTime - (int)((System.currentTimeMillis() - startTime) / 1000));
        try {
          Thread.sleep(200);
        }
 catch (        InterruptedException iE) {
          iE.printStackTrace();
        }
      }
    }
  }
 else {
    status.setLastCheckedText(""String_Node_Str"");
  }
}","/** 
 * Checks for tickets. Blocks indefinitely. Note that if checker is not checking anything, this method does not block and only modifies the StatusGUI GUI status text.
 * @param status The StatusGUI window to update
 * @param checker The TicketChecker to use
 * @param email The EmailAccount to use, or null for none
 * @param checkTime The time between checks
 * @throws NullPointerException if any arguments besides email are null
 */
private static void checkForTickets(Status status,TicketChecker checker,EmailAccount email,int checkTime){
  if (checker.isCheckingAnything()) {
    while (true) {
      status.setLastCheckedText(""String_Node_Str"");
      long startTime=System.currentTimeMillis();
      if (checker.isUpdated()) {
        Browser.openLinkInBrowser(checker.getLinkFound());
        Audio.playAlarm();
        if (email != null) {
          try {
            email.sendMessage(""String_Node_Str"",""String_Node_Str"" + checker.getLinkFound());
          }
 catch (          IllegalStateException e) {
            System.out.println(""String_Node_Str"" + e.getMessage() + ""String_Node_Str"");
          }
        }
        if (status instanceof StatusGUI) {
          Tickets ticketWindow=new Tickets(checker.getLinkFound());
          ticketWindow.showWindow();
        }
      }
      status.setDataUsageText(DataTracker.getDataUsedMB());
      while (System.currentTimeMillis() - startTime < checkTime * 1000) {
synchronized (status) {
          int button=status.getButtonPressed();
          if (button > 0) {
            status.resetButtonPressed();
            if (button == 1) {
              break;
            }
 else             if (button == 2) {
              if (email != null) {
                status.setInformationText(""String_Node_Str"");
                try {
                  if (email.sendMessage(""String_Node_Str"",""String_Node_Str"")) {
                    status.setInformationText(""String_Node_Str"");
                  }
 else {
                    status.setInformationText(""String_Node_Str"");
                  }
                }
 catch (                IllegalStateException e) {
                  status.setInformationText(""String_Node_Str"");
                }
              }
            }
 else             if (button == 3) {
              if (Audio.playAlarm()) {
                status.setInformationText(""String_Node_Str"");
              }
 else {
                status.setInformationText(""String_Node_Str"");
              }
            }
 else             if (button == 4) {
              if (myStreamer != null) {
                myStreamer.startStreamingTwitter();
              }
            }
          }
        }
        status.setLastCheckedText(checkTime - (int)((System.currentTimeMillis() - startTime) / 1000));
        try {
          Thread.sleep(200);
        }
 catch (        InterruptedException iE) {
          iE.printStackTrace();
        }
      }
    }
  }
 else {
    status.setLastCheckedText(""String_Node_Str"");
  }
}",0.9857578840284842
80964,"/** 
 * Checks whether or not the given URL is a PAX ticket page or a queue page.
 * @param URL The URL to check
 * @return True if it is, false if not
 */
public static boolean isPaxPage(String URL){
  try {
    HttpURLConnection connect=Browser.setUpConnection(new URL(URL));
    BufferedReader reader=new BufferedReader(new InputStreamReader(connect.getInputStream()));
    String text=""String_Node_Str"";
    String line;
    while ((line=reader.readLine()) != null) {
      DataTracker.addDataUsed(line.length());
      text+=line.toLowerCase();
    }
    if (text.contains(""String_Node_Str"")) {
      System.out.println(""String_Node_Str"");
      return true;
    }
 else     if (!strictFiltering && text.contains(""String_Node_Str"")) {
      System.out.println(""String_Node_Str"");
      return true;
    }
 else {
      return false;
    }
  }
 catch (  IOException iOException) {
    System.out.println(""String_Node_Str"");
    return true;
  }
}","/** 
 * Checks whether or not the given URL is a PAX ticket page or a queue page.
 * @param URL The URL to check
 * @return True if it is, false if not
 */
public static boolean isPaxPage(String URL){
  try {
    HttpURLConnection connect=Browser.setUpConnection(new URL(URL));
    BufferedReader reader=new BufferedReader(new InputStreamReader(connect.getInputStream()));
    String text=""String_Node_Str"";
    String line;
    while ((line=reader.readLine()) != null) {
      DataTracker.addDataUsed(line.length());
      text+=line.toLowerCase();
    }
    if (text.contains(""String_Node_Str"")) {
      System.out.println(""String_Node_Str"");
      return true;
    }
 else     if (text.contains(""String_Node_Str"")) {
      if (strictFiltering) {
        System.out.println(""String_Node_Str"");
        return false;
      }
 else {
        System.out.println(""String_Node_Str"");
        return true;
      }
    }
 else {
      System.out.println(""String_Node_Str"");
      return false;
    }
  }
 catch (  IOException iOException) {
    System.out.println(""String_Node_Str"");
    return !strictFiltering;
  }
}",0.8860882210373243
80965,"@Override public void promptForSettings(){
  Scanner myScanner=new Scanner(System.in);
  String name=""String_Node_Str"";
  while (name.length() > 0) {
    System.out.print(""String_Node_Str"");
    try {
      name=myScanner.nextLine();
      if (name.length() == 0) {
      }
 else       if (name.length() < 5) {
        System.out.println(""String_Node_Str"");
      }
 else {
        emailAddress=name;
        System.out.print(""String_Node_Str"");
        emailPassword=new String(System.console().readPassword());
        while (true) {
          System.out.print(""String_Node_Str"");
          try {
            String cellNum=myScanner.nextLine();
            if (cellNum.length() == 0) {
              break;
            }
 else {
              emailSendToList.add(cellNum);
            }
          }
 catch (          Exception e) {
            e.printStackTrace();
            System.out.println(""String_Node_Str"");
            break;
          }
        }
        break;
      }
    }
 catch (    Exception e) {
      e.printStackTrace();
      System.out.println(""String_Node_Str"");
      break;
    }
  }
  System.out.print(""String_Node_Str"");
  try {
    String input=myScanner.nextLine();
switch (input.toLowerCase()) {
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
      expoToCheck=""String_Node_Str"";
    break;
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
  expoToCheck=""String_Node_Str"";
break;
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
expoToCheck=""String_Node_Str"";
break;
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
expoToCheck=""String_Node_Str"";
break;
default :
System.out.println(""String_Node_Str"" + input + ""String_Node_Str"");
expoToCheck=""String_Node_Str"";
break;
}
}
 catch (Exception e) {
}
System.out.print(""String_Node_Str"");
checkPaxWebsite=isResponseYes(myScanner);
System.out.print(""String_Node_Str"");
checkShowclixWebsite=isResponseYes(myScanner);
System.out.print(""String_Node_Str"");
filterShowclix=isResponseYes(myScanner);
System.out.print(""String_Node_Str"");
checkKnownEvents=isResponseYes(myScanner);
System.out.print(""String_Node_Str"");
checkTwitter=isResponseYes(myScanner);
if (checkTwitter) {
boolean inputKeys=true;
if (consumerKey != null) {
System.out.print(""String_Node_Str"");
inputKeys=isResponseYes(myScanner);
}
if (inputKeys) {
System.out.println(""String_Node_Str"" + ""String_Node_Str"");
System.out.print(""String_Node_Str"");
consumerKey=myScanner.nextLine();
System.out.print(""String_Node_Str"");
consumerSecret=myScanner.nextLine();
System.out.print(""String_Node_Str"");
applicationKey=myScanner.nextLine();
System.out.print(""String_Node_Str"");
applicationSecret=myScanner.nextLine();
}
System.out.print(""String_Node_Str"");
filterTwitter=isResponseYes(myScanner);
}
System.out.print(""String_Node_Str"");
try {
refreshTime=Integer.parseInt(myScanner.nextLine());
refreshTime=Math.max(refreshTime,10);
refreshTime=Math.min(refreshTime,120);
}
 catch (Exception e) {
System.out.println(""String_Node_Str"");
}
System.out.print(""String_Node_Str"");
playAlarm=isResponseYes(myScanner);
}","@Override public void promptForSettings(){
  Scanner myScanner=new Scanner(System.in);
  String name=""String_Node_Str"";
  while (name.length() > 0) {
    System.out.print(""String_Node_Str"");
    try {
      name=myScanner.nextLine();
      if (name.length() == 0) {
      }
 else       if (name.length() < 5) {
        System.out.println(""String_Node_Str"");
      }
 else {
        emailAddress=name;
        System.out.print(""String_Node_Str"");
        emailPassword=new String(System.console().readPassword());
        while (true) {
          System.out.print(""String_Node_Str"");
          try {
            String cellNum=myScanner.nextLine();
            if (cellNum.length() == 0) {
              break;
            }
 else {
              emailSendToList.add(cellNum);
            }
          }
 catch (          Exception e) {
            e.printStackTrace();
            System.out.println(""String_Node_Str"");
            break;
          }
        }
        break;
      }
    }
 catch (    Exception e) {
      e.printStackTrace();
      System.out.println(""String_Node_Str"");
      break;
    }
  }
  System.out.print(""String_Node_Str"");
  try {
    String input=myScanner.nextLine();
switch (input.toLowerCase()) {
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
      expoToCheck=""String_Node_Str"";
    break;
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
  expoToCheck=""String_Node_Str"";
break;
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
expoToCheck=""String_Node_Str"";
break;
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
expoToCheck=""String_Node_Str"";
break;
default :
System.out.println(""String_Node_Str"" + input + ""String_Node_Str"");
expoToCheck=""String_Node_Str"";
break;
}
}
 catch (Exception e) {
}
System.out.print(""String_Node_Str"");
checkPaxWebsite=isResponseYes(myScanner);
System.out.print(""String_Node_Str"");
checkShowclixWebsite=isResponseYes(myScanner);
System.out.print(""String_Node_Str"");
filterShowclix=isResponseYes(myScanner);
System.out.print(""String_Node_Str"");
checkKnownEvents=isResponseYes(myScanner);
System.out.print(""String_Node_Str"");
checkTwitter=isResponseYes(myScanner);
if (checkTwitter) {
boolean inputKeys=true;
if (consumerKey != null) {
System.out.print(""String_Node_Str"");
inputKeys=isResponseYes(myScanner);
}
if (inputKeys) {
System.out.println(""String_Node_Str"" + ""String_Node_Str"");
System.out.print(""String_Node_Str"");
consumerKey=myScanner.nextLine();
System.out.print(""String_Node_Str"");
consumerSecret=myScanner.nextLine();
System.out.print(""String_Node_Str"");
applicationKey=myScanner.nextLine();
System.out.print(""String_Node_Str"");
applicationSecret=myScanner.nextLine();
}
System.out.print(""String_Node_Str"");
filterTwitter=isResponseYes(myScanner);
if (emailAddress != null) {
System.out.println(""String_Node_Str"");
textTweets=isResponseYes(myScanner);
}
}
System.out.print(""String_Node_Str"");
try {
refreshTime=Integer.parseInt(myScanner.nextLine());
refreshTime=Math.max(refreshTime,10);
refreshTime=Math.min(refreshTime,120);
}
 catch (Exception e) {
System.out.println(""String_Node_Str"");
}
System.out.print(""String_Node_Str"");
playAlarm=isResponseYes(myScanner);
}",0.9837273564630028
80966,"/** 
 * @param args the command line arguments
 */
public static void main(String[] args){
  removeOldPreferences();
  System.out.println(""String_Node_Str"");
  java.net.HttpURLConnection.setFollowRedirects(true);
  boolean isHeadless=GraphicsEnvironment.isHeadless() || hasArgument(args,""String_Node_Str"");
  List<String> followList=new ArrayList<>();
  Map<String,String> properties=new HashMap<>();
  String[] twitterTokens=new String[4];
  for (int i=0; i < args.length; i++) {
switch (args[i].toLowerCase()) {
case ""String_Node_Str"":
case ""String_Node_Str"":
      followList.add(args[i + 1]);
    break;
case ""String_Node_Str"":
  if (args.length > i + 2) {
    String key=args[i + 1];
    String value=args[i + 2];
    if (!key.startsWith(""String_Node_Str"") && !value.startsWith(""String_Node_Str"")) {
      properties.put(key,value);
    }
 else {
      System.out.println(""String_Node_Str"");
    }
  }
 else {
    System.out.println(""String_Node_Str"");
  }
break;
case ""String_Node_Str"":
if (args.length > i + 4) {
twitterTokens[0]=args[i + 1];
twitterTokens[1]=args[i + 2];
twitterTokens[2]=args[i + 3];
twitterTokens[3]=args[i + 4];
for (String s : twitterTokens) {
  if (s.startsWith(""String_Node_Str"")) {
    System.out.println(""String_Node_Str"" + s + ""String_Node_Str"");
    for (int j=0; j < twitterTokens.length; j++) {
      twitterTokens[j]=null;
    }
    break;
  }
}
}
 else {
System.out.println(""String_Node_Str"");
}
break;
case ""String_Node_Str"":
try {
SavePrintStream printer;
if (args.length > i + 1 && !args[i + 1].startsWith(""String_Node_Str"")) {
printer=new SavePrintStream(System.out,args[i + 1]);
}
 else {
printer=new SavePrintStream(System.out);
}
System.setOut(printer);
System.setErr(printer);
}
 catch (FileNotFoundException fnfe) {
System.out.println(""String_Node_Str"");
fnfe.printStackTrace();
}
break;
case ""String_Node_Str"":
if (i < args.length - 1 && !args[i + 1].startsWith(""String_Node_Str"")) {
Audio.setAlarmFile(args[i + 1]);
}
 else {
System.out.println(""String_Node_Str"");
}
break;
}
}
PreferenceHandler prefs=new PreferenceHandler(""String_Node_Str"");
final Startup loadingOutput;
if (isHeadless) {
ErrorBuilder.forceCommandLine();
loadingOutput=new LoadingCLI(System.out);
}
 else {
loadingOutput=new LoadingWindow();
}
loadingOutput.start();
loadResources(loadingOutput,hasArgument(args,""String_Node_Str""));
Updater programUpdater=new Updater(VERSION);
String patchNotes=null;
if (!hasArgument(args,""String_Node_Str"") && prefs.getBooleanPreference(""String_Node_Str"",true)) {
if (hasArgument(args,""String_Node_Str"") || prefs.getBooleanPreference(""String_Node_Str"",false)) {
programUpdater.enableAnonymousMode();
}
if (isHeadless) {
programUpdater.enableHeadlessMode();
}
if (programUpdater.loadUpdates(loadingOutput)) {
patchNotes=programUpdater.getPatchNotes();
}
 else {
System.out.println(""String_Node_Str"");
}
}
if (!hasArgument(args,""String_Node_Str"") && prefs.getBooleanPreference(""String_Node_Str"",true)) {
loadNotifications(loadingOutput,hasArgument(args,""String_Node_Str"") || prefs.getBooleanPreference(""String_Node_Str"",false),isHeadless,prefs);
}
loadingOutput.stop();
Setup mySetup;
if (hasArgument(args,""String_Node_Str"")) {
mySetup=new SetupAuto(args);
}
 else if (isHeadless) {
mySetup=new SetupCLI(twitterTokens);
}
 else {
SetupGUI myGUI=new SetupGUI(twitterTokens);
if (patchNotes != null) {
myGUI.setPatchNotesText(patchNotes);
}
 else {
myGUI.setPatchNotesText(""String_Node_Str"");
}
mySetup=myGUI;
}
mySetup.promptForSettings();
twitterTokens[0]=mySetup.getTwitterConsumerKey();
twitterTokens[1]=mySetup.getTwitterConsumerSecret();
twitterTokens[2]=mySetup.getTwitterApplicationKey();
twitterTokens[3]=mySetup.getTwitterApplicationSecret();
if (mySetup.shouldCheckForUpdatesDaily()) {
new Thread(new PeriodicUpdateChecker(programUpdater)).start();
}
Expo myExpo=Expo.parseExpo(mySetup.getExpoToCheck());
Status myStatus;
EmailAccount emailAccount;
try {
emailAccount=new EmailAccount(mySetup.getEmailUsername(),mySetup.getEmailPassword());
for (String s : mySetup.getEmailAddresses()) {
emailAccount.addEmailAddress(s);
}
for (String key : properties.keySet()) {
emailAccount.setProperty(key,properties.get(key));
}
}
 catch (IllegalArgumentException e) {
emailAccount=null;
}
if (!isHeadless) {
StatusGUI statGUI;
if (emailAccount != null) {
statGUI=new StatusGUI(myExpo,emailAccount.getUsername(),emailAccount.getAddressList());
}
 else {
statGUI=new StatusGUI(myExpo);
}
myStatus=statGUI;
if (hasArgument(args,""String_Node_Str"")) {
statGUI.minimizeToTray();
}
 else {
statGUI.showWindow();
}
}
 else {
myStatus=new StatusCLI();
}
if (emailAccount != null) {
myStatus.enableEmail();
}
if (mySetup.shouldPlayAlarm()) {
Audio.enableAlarm();
myStatus.enableAlarm();
}
myLinkManager=new LinkManager(emailAccount);
TicketChecker myChecker=initChecker(mySetup,isHeadless ? null : (StatusGUI)myStatus,myExpo);
if (mySetup.shouldCheckTwitter()) {
TwitterStreamer tcheck=setupTwitter(myStatus,twitterTokens,mySetup.shouldTextTweets());
for (String s : followList) {
tcheck.addUser(s);
}
tcheck.startStreamingTwitter();
myStreamer=tcheck;
myStatus.enableTwitter();
}
checkForTickets(myStatus,myChecker,emailAccount,mySetup.timeBetweenChecks());
}","/** 
 * @param args the command line arguments
 */
public static void main(String[] args){
  removeOldPreferences();
  System.out.println(""String_Node_Str"");
  java.net.HttpURLConnection.setFollowRedirects(true);
  boolean isHeadless=GraphicsEnvironment.isHeadless() || hasArgument(args,""String_Node_Str"");
  List<String> followList=new ArrayList<>();
  Map<String,String> properties=new HashMap<>();
  String[] twitterTokens=new String[4];
  for (int i=0; i < args.length; i++) {
switch (args[i].toLowerCase()) {
case ""String_Node_Str"":
case ""String_Node_Str"":
      followList.add(args[i + 1]);
    break;
case ""String_Node_Str"":
  if (args.length > i + 2) {
    String key=args[i + 1];
    String value=args[i + 2];
    if (!key.startsWith(""String_Node_Str"") && !value.startsWith(""String_Node_Str"")) {
      properties.put(key,value);
    }
 else {
      System.out.println(""String_Node_Str"");
    }
  }
 else {
    System.out.println(""String_Node_Str"");
  }
break;
case ""String_Node_Str"":
if (args.length > i + 4) {
twitterTokens[0]=args[i + 1];
twitterTokens[1]=args[i + 2];
twitterTokens[2]=args[i + 3];
twitterTokens[3]=args[i + 4];
for (String s : twitterTokens) {
  if (s.startsWith(""String_Node_Str"")) {
    System.out.println(""String_Node_Str"" + s + ""String_Node_Str"");
    for (int j=0; j < twitterTokens.length; j++) {
      twitterTokens[j]=null;
    }
    break;
  }
}
}
 else {
System.out.println(""String_Node_Str"");
}
break;
case ""String_Node_Str"":
try {
SavePrintStream printer;
if (args.length > i + 1 && !args[i + 1].startsWith(""String_Node_Str"")) {
printer=new SavePrintStream(System.out,args[i + 1]);
}
 else {
printer=new SavePrintStream(System.out);
}
System.setOut(printer);
System.setErr(printer);
}
 catch (FileNotFoundException fnfe) {
System.out.println(""String_Node_Str"");
fnfe.printStackTrace();
}
break;
case ""String_Node_Str"":
if (i < args.length - 1 && !args[i + 1].startsWith(""String_Node_Str"")) {
Audio.setAlarmFile(args[i + 1]);
}
 else {
System.out.println(""String_Node_Str"");
}
break;
}
}
PreferenceHandler prefs=new PreferenceHandler(""String_Node_Str"");
final Startup loadingOutput;
if (isHeadless) {
ErrorBuilder.forceCommandLine();
loadingOutput=new LoadingCLI(System.out);
}
 else {
loadingOutput=new LoadingWindow();
}
loadingOutput.start();
loadResources(loadingOutput,hasArgument(args,""String_Node_Str""));
Updater programUpdater=new Updater(VERSION);
String patchNotes=null;
if (!hasArgument(args,""String_Node_Str"") && prefs.getBooleanPreference(""String_Node_Str"",true)) {
if (hasArgument(args,""String_Node_Str"") || prefs.getBooleanPreference(""String_Node_Str"",false)) {
programUpdater.enableAnonymousMode();
}
if (isHeadless) {
programUpdater.enableHeadlessMode();
}
if (hasArgument(args,""String_Node_Str"") || prefs.getBooleanPreference(""String_Node_Str"")) {
programUpdater.enableBetaUpdates();
}
if (programUpdater.loadUpdates(loadingOutput)) {
patchNotes=programUpdater.getPatchNotes();
}
 else {
System.out.println(""String_Node_Str"");
}
}
if (!hasArgument(args,""String_Node_Str"") && prefs.getBooleanPreference(""String_Node_Str"",true)) {
loadNotifications(loadingOutput,hasArgument(args,""String_Node_Str"") || prefs.getBooleanPreference(""String_Node_Str"",false),isHeadless,prefs);
}
loadingOutput.stop();
Setup mySetup;
if (hasArgument(args,""String_Node_Str"")) {
mySetup=new SetupAuto(args);
}
 else if (isHeadless) {
mySetup=new SetupCLI(twitterTokens);
}
 else {
SetupGUI myGUI=new SetupGUI(twitterTokens);
if (patchNotes != null) {
myGUI.setPatchNotesText(patchNotes);
}
 else {
myGUI.setPatchNotesText(""String_Node_Str"");
}
mySetup=myGUI;
}
mySetup.promptForSettings();
twitterTokens[0]=mySetup.getTwitterConsumerKey();
twitterTokens[1]=mySetup.getTwitterConsumerSecret();
twitterTokens[2]=mySetup.getTwitterApplicationKey();
twitterTokens[3]=mySetup.getTwitterApplicationSecret();
if (mySetup.shouldCheckForUpdatesDaily()) {
new Thread(new PeriodicUpdateChecker(programUpdater)).start();
}
Expo myExpo=Expo.parseExpo(mySetup.getExpoToCheck());
Status myStatus;
EmailAccount emailAccount;
try {
emailAccount=new EmailAccount(mySetup.getEmailUsername(),mySetup.getEmailPassword());
for (String s : mySetup.getEmailAddresses()) {
emailAccount.addEmailAddress(s);
}
for (String key : properties.keySet()) {
emailAccount.setProperty(key,properties.get(key));
}
}
 catch (IllegalArgumentException e) {
emailAccount=null;
}
if (!isHeadless) {
StatusGUI statGUI;
if (emailAccount != null) {
statGUI=new StatusGUI(myExpo,emailAccount.getUsername(),emailAccount.getAddressList());
}
 else {
statGUI=new StatusGUI(myExpo);
}
myStatus=statGUI;
if (hasArgument(args,""String_Node_Str"")) {
statGUI.minimizeToTray();
}
 else {
statGUI.showWindow();
}
}
 else {
myStatus=new StatusCLI();
}
if (emailAccount != null) {
myStatus.enableEmail();
}
if (mySetup.shouldPlayAlarm()) {
Audio.enableAlarm();
myStatus.enableAlarm();
}
myLinkManager=new LinkManager(emailAccount);
TicketChecker myChecker=initChecker(mySetup,isHeadless ? null : (StatusGUI)myStatus,myExpo);
if (mySetup.shouldCheckTwitter()) {
TwitterStreamer tcheck=setupTwitter(myStatus,twitterTokens,mySetup.shouldTextTweets());
for (String s : followList) {
tcheck.addUser(s);
}
tcheck.startStreamingTwitter();
myStreamer=tcheck;
myStatus.enableTwitter();
}
checkForTickets(myStatus,myChecker,emailAccount,mySetup.timeBetweenChecks());
}",0.9876566654006836
80967,"/** 
 * Checks for updates. This loads Patch Notes and prompts the user if they want to update. If the user does update, it kills the PAXChecker.
 * @param startupOutput The Startup object to update with information as updates are loaded
 * @return True if updates were checked for successfully, false if not
 */
public boolean loadUpdates(Startup startupOutput){
  String notes=null;
  try {
    if (startupOutput != null) {
      startupOutput.setStatus(""String_Node_Str"");
    }
    PatchNotesDownloader notesDownloader=new PatchNotesDownloader(getPatchNotesLink());
    notesDownloader.downloadVersionNotes(programVersion);
    notes=notesDownloader.getVersionNotes();
    if (notesDownloader.updateAvailable()) {
      UpdateDownloader myDownloader=new UpdateDownloader(getUpdateLink(),getBetaUpdateLink());
      UpdatePrompt myPrompt=null;
      boolean shouldUpdate;
      if (!headless) {
        myPrompt=new UpdatePrompt(""String_Node_Str"",myDownloader.getUpdateSize(),notesDownloader.getUpdateLevel(),programVersion,notesDownloader.getVersionNotes(programVersion));
        if (startupOutput != null) {
          startupOutput.stop();
        }
        myPrompt.showWindow();
        try {
          myPrompt.waitForClose();
        }
 catch (        InterruptedException e) {
        }
        shouldUpdate=myPrompt.shouldUpdateProgram();
      }
 else {
        System.out.println(""String_Node_Str"");
        System.out.println(""String_Node_Str"" + programVersion);
        System.out.println(""String_Node_Str"" + notesDownloader.getUpdateLevel());
        System.out.println(""String_Node_Str"" + myDownloader.getUpdateSize());
        System.out.print(""String_Node_Str"");
        Scanner in=new Scanner(System.in);
        shouldUpdate=in.nextLine().toUpperCase().startsWith(""String_Node_Str"");
      }
      if (shouldUpdate) {
        if (notesDownloader.getUpdateLevel() == 1) {
          myDownloader.setUseBeta();
        }
        myDownloader.updateProgram(myPrompt,new File(PAXChecker.class.getProtectionDomain().getCodeSource().getLocation().toURI().getPath()));
        System.exit(0);
      }
 else       if (startupOutput != null) {
        startupOutput.start();
      }
    }
  }
 catch (  IOException|URISyntaxException e) {
    e.printStackTrace();
    return false;
  }
  patchNotes=notes;
  return true;
}","/** 
 * Checks for updates. This loads Patch Notes and prompts the user if they want to update. If the user does update, it kills the PAXChecker.
 * @param startupOutput The Startup object to update with information as updates are loaded
 * @return True if updates were checked for successfully, false if not
 */
public boolean loadUpdates(Startup startupOutput){
  String notes=null;
  try {
    if (startupOutput != null) {
      startupOutput.setStatus(""String_Node_Str"");
    }
    PatchNotesDownloader notesDownloader=new PatchNotesDownloader(getPatchNotesLink());
    if (beta) {
      notesDownloader.enableBetaDownload();
    }
    notesDownloader.downloadVersionNotes(programVersion);
    notes=notesDownloader.getVersionNotes();
    if (notesDownloader.updateAvailable()) {
      UpdateDownloader myDownloader=new UpdateDownloader(getUpdateLink(),getBetaUpdateLink());
      UpdatePrompt myPrompt=null;
      boolean shouldUpdate;
      if (!headless) {
        myPrompt=new UpdatePrompt(""String_Node_Str"",myDownloader.getUpdateSize(),notesDownloader.getUpdateLevel(),programVersion,notesDownloader.getVersionNotes(programVersion));
        if (startupOutput != null) {
          startupOutput.stop();
        }
        myPrompt.showWindow();
        try {
          myPrompt.waitForClose();
        }
 catch (        InterruptedException e) {
        }
        shouldUpdate=myPrompt.shouldUpdateProgram();
      }
 else {
        System.out.println(""String_Node_Str"");
        System.out.println(""String_Node_Str"" + programVersion);
        System.out.println(""String_Node_Str"" + notesDownloader.getUpdateLevel());
        System.out.println(""String_Node_Str"" + myDownloader.getUpdateSize());
        System.out.print(""String_Node_Str"");
        Scanner in=new Scanner(System.in);
        shouldUpdate=in.nextLine().toUpperCase().startsWith(""String_Node_Str"");
      }
      if (shouldUpdate) {
        if (notesDownloader.getUpdateLevel() == 1) {
          myDownloader.setUseBeta();
        }
        myDownloader.updateProgram(myPrompt,new File(PAXChecker.class.getProtectionDomain().getCodeSource().getLocation().toURI().getPath()));
        System.exit(0);
      }
 else       if (startupOutput != null) {
        startupOutput.start();
      }
    }
  }
 catch (  IOException|URISyntaxException e) {
    e.printStackTrace();
    return false;
  }
  patchNotes=notes;
  return true;
}",0.9860583016476552
80968,"public String getCurrentButtonLink(){
  try {
    URL urlToConnectTo=new URL(getWebsiteLink(expoToCheck) + ""String_Node_Str"");
    String link=findShowclixLink(urlToConnectTo);
    if (link.equals(""String_Node_Str"") && expoToCheck == Expo.PRIME) {
      System.out.println(""String_Node_Str"");
      URL urlToConnectTo2=new URL(""String_Node_Str"");
      link=findShowclixLink(urlToConnectTo2);
    }
    return link;
  }
 catch (  MalformedURLException mue) {
  }
  return ""String_Node_Str"";
}","public String getCurrentButtonLink(){
  try {
    URL urlToConnectTo=new URL(getWebsiteLink(expoToCheck) + ""String_Node_Str"");
    String link=findShowclixLink(urlToConnectTo);
    return link;
  }
 catch (  MalformedURLException mue) {
  }
  return ""String_Node_Str"";
}",0.5485564304461942
80969,"@Override public void run(){
  setIconImage(image);
  setTrayIcon(""String_Node_Str"",image);
}","@Override public void run(){
  JLInformation.setText(""String_Node_Str"");
}",0.718562874251497
80970,"@Override protected Object doInBackground() throws Exception {
  long startTime=System.nanoTime();
  long delayTime=INFORMATION_CLEAR_DELAY_TIME * 1000000000L;
  do {
    int secondsLeft=(int)((delayTime - (System.nanoTime() - startTime)) / 1000000000L);
    setProgress((INFORMATION_CLEAR_DELAY_TIME - secondsLeft) / INFORMATION_CLEAR_DELAY_TIME * 100);
  }
 while (System.nanoTime() - startTime < delayTime && !super.isCancelled());
  setProgress(100);
  return null;
}","@Override protected Object doInBackground() throws Exception {
  long startTime=System.nanoTime();
  long delayTime=INFORMATION_CLEAR_DELAY_TIME * 1000000000L;
  do {
    int secondsLeft=(int)((delayTime - (System.nanoTime() - startTime)) / 1000000000L);
    setProgress((INFORMATION_CLEAR_DELAY_TIME - secondsLeft) / INFORMATION_CLEAR_DELAY_TIME * 100);
    Thread.sleep(250);
  }
 while (System.nanoTime() - startTime < delayTime && !super.isCancelled());
  setProgress(100);
  return null;
}",0.9761658031088084
80971,"@Override protected void process(java.util.List<String> chunks){
  if (!chunks.isEmpty()) {
    JBTestText.setText(chunks.get(chunks.size() - 1));
  }
}","@Override protected void process(final java.util.List<String> chunks){
  if (!chunks.isEmpty()) {
    invokeAndWaitOnEDT(new Runnable(){
      @Override public void run(){
        JBTestText.setText(chunks.get(chunks.size() - 1));
      }
    }
);
  }
}",0.7358024691358025
80972,"@Override protected void done(){
  if (!super.isCancelled()) {
    setInformationText(""String_Node_Str"");
  }
}","@Override protected void done(){
  if (!super.isCancelled()) {
    invokeAndWaitOnEDT(new Runnable(){
      @Override public void run(){
        JLInformation.setText(""String_Node_Str"");
      }
    }
);
  }
}",0.60625
80973,"private static void loadNotifications(Startup window,boolean anonymous,PreferenceHandler prefs){
  window.setStatus(""String_Node_Str"");
  String lastID=prefs.getStringPreference(""String_Node_Str"");
  if (lastID == null) {
    lastID=""String_Node_Str"";
  }
  NotificationHandler notifications=new NotificationHandler(anonymous,lastID);
  notifications.loadNotifications();
  String newID=notifications.showNewNotifications();
  prefs.getPreferenceObject(""String_Node_Str"").setValue(newID);
  prefs.savePreferences();
}","private static void loadNotifications(Startup window,boolean anonymous,boolean headless,PreferenceHandler prefs){
  window.setStatus(""String_Node_Str"");
  String lastID=prefs.getStringPreference(""String_Node_Str"");
  if (lastID == null) {
    lastID=""String_Node_Str"";
  }
  NotificationHandler notifications=new NotificationHandler(lastID);
  if (anonymous) {
    notifications.setAnonymous();
  }
  if (headless) {
    notifications.setHeadless();
  }
  notifications.loadNotifications();
  String newID=notifications.showNewNotifications();
  if (newID == null) {
    newID=lastID;
  }
  prefs.getPreferenceObject(""String_Node_Str"").setValue(newID);
  prefs.savePreferences();
}",0.6994991652754591
80974,"/** 
 * @param args the command line arguments
 */
public static void main(String[] args){
  removeOldPreferences();
  System.out.println(""String_Node_Str"");
  java.net.HttpURLConnection.setFollowRedirects(true);
  boolean isHeadless=GraphicsEnvironment.isHeadless() || hasArgument(args,""String_Node_Str"");
  List<String> followList=new ArrayList<>();
  Map<String,String> properties=new HashMap<>();
  String[] twitterTokens=new String[4];
  for (int i=0; i < args.length; i++) {
switch (args[i].toLowerCase()) {
case ""String_Node_Str"":
case ""String_Node_Str"":
      followList.add(args[i + 1]);
    break;
case ""String_Node_Str"":
  if (args.length > i + 2) {
    String key=args[i + 1];
    String value=args[i + 2];
    if (!key.startsWith(""String_Node_Str"") && !value.startsWith(""String_Node_Str"")) {
      properties.put(key,value);
    }
 else {
      System.out.println(""String_Node_Str"");
    }
  }
 else {
    System.out.println(""String_Node_Str"");
  }
break;
case ""String_Node_Str"":
if (args.length > i + 4) {
twitterTokens[0]=args[i + 1];
twitterTokens[1]=args[i + 2];
twitterTokens[2]=args[i + 3];
twitterTokens[3]=args[i + 4];
for (String s : twitterTokens) {
  if (s.startsWith(""String_Node_Str"")) {
    System.out.println(""String_Node_Str"" + s + ""String_Node_Str"");
    for (int j=0; j < twitterTokens.length; j++) {
      twitterTokens[j]=null;
    }
    break;
  }
}
}
 else {
System.out.println(""String_Node_Str"");
}
break;
case ""String_Node_Str"":
try {
SavePrintStream printer;
if (args.length > i + 1 && !args[i + 1].startsWith(""String_Node_Str"")) {
printer=new SavePrintStream(System.out,args[i + 1]);
}
 else {
printer=new SavePrintStream(System.out);
}
System.setOut(printer);
System.setErr(printer);
}
 catch (FileNotFoundException fnfe) {
System.out.println(""String_Node_Str"");
fnfe.printStackTrace();
}
break;
case ""String_Node_Str"":
Audio.setAlarmFile(args[i + 1]);
break;
case ""String_Node_Str"":
break;
}
}
PreferenceHandler prefs=new PreferenceHandler(""String_Node_Str"");
final Startup loadingOutput;
if (isHeadless) {
ErrorBuilder.forceCommandLine();
loadingOutput=new LoadingCLI(System.out);
}
 else {
loadingOutput=new LoadingWindow();
}
Updater programUpdater=new Updater(VERSION);
String patchNotes=null;
loadingOutput.start();
loadResources(loadingOutput,hasArgument(args,""String_Node_Str""));
if (!isHeadless) {
if (!hasArgument(args,""String_Node_Str"")) {
if (hasArgument(args,""String_Node_Str"") || prefs.getBooleanPreference(""String_Node_Str"",false)) {
programUpdater.enableAnonymousMode();
}
if (programUpdater.loadUpdates(loadingOutput)) {
patchNotes=programUpdater.getPatchNotes();
}
 else {
System.out.println(""String_Node_Str"");
}
}
if (!hasArgument(args,""String_Node_Str"")) {
loadNotifications(loadingOutput,hasArgument(args,""String_Node_Str"") || prefs.getBooleanPreference(""String_Node_Str"",false),prefs);
}
}
 else {
System.out.println(""String_Node_Str"");
}
loadingOutput.stop();
Setup mySetup;
if (hasArgument(args,""String_Node_Str"")) {
mySetup=new SetupAuto(args);
}
 else if (isHeadless) {
mySetup=new SetupCLI(twitterTokens);
}
 else {
SetupGUI myGUI=new SetupGUI(twitterTokens);
if (patchNotes != null) {
myGUI.setPatchNotesText(patchNotes);
}
 else {
myGUI.setPatchNotesText(""String_Node_Str"");
}
mySetup=myGUI;
}
mySetup.promptForSettings();
twitterTokens[0]=mySetup.getTwitterConsumerKey();
twitterTokens[1]=mySetup.getTwitterConsumerSecret();
twitterTokens[2]=mySetup.getTwitterApplicationKey();
twitterTokens[3]=mySetup.getTwitterApplicationSecret();
Expo myExpo=Expo.parseExpo(mySetup.getExpoToCheck());
Status myStatus;
EmailAccount emailAccount;
try {
emailAccount=new EmailAccount(mySetup.getEmailUsername(),mySetup.getEmailPassword());
for (String s : mySetup.getEmailAddresses()) {
emailAccount.addEmailAddress(s);
}
for (String key : properties.keySet()) {
emailAccount.setProperty(key,properties.get(key));
}
}
 catch (IllegalArgumentException e) {
emailAccount=null;
}
if (!isHeadless) {
StatusGUI statGUI;
if (emailAccount != null) {
statGUI=new StatusGUI(myExpo,emailAccount.getUsername(),emailAccount.getAddressList());
}
 else {
statGUI=new StatusGUI(myExpo);
}
myStatus=statGUI;
if (hasArgument(args,""String_Node_Str"")) {
statGUI.minimizeToTray();
}
 else {
statGUI.showWindow();
}
}
 else {
myStatus=new StatusCLI();
}
if (emailAccount != null) {
myStatus.enableEmail();
}
if (mySetup.shouldPlayAlarm()) {
Audio.enableAlarm();
myStatus.enableAlarm();
}
myLinkManager=new LinkManager(emailAccount);
TicketChecker myChecker=initChecker(mySetup,isHeadless ? null : (StatusGUI)myStatus,myExpo);
if (mySetup.shouldCheckTwitter()) {
TwitterStreamer tcheck=setupTwitter(myStatus,twitterTokens,mySetup.shouldTextTweets());
for (String s : followList) {
tcheck.addUser(s);
}
tcheck.startStreamingTwitter();
myStreamer=tcheck;
myStatus.enableTwitter();
}
checkForTickets(myStatus,myChecker,emailAccount,mySetup.timeBetweenChecks());
}","/** 
 * @param args the command line arguments
 */
public static void main(String[] args){
  removeOldPreferences();
  System.out.println(""String_Node_Str"");
  java.net.HttpURLConnection.setFollowRedirects(true);
  boolean isHeadless=GraphicsEnvironment.isHeadless() || hasArgument(args,""String_Node_Str"");
  List<String> followList=new ArrayList<>();
  Map<String,String> properties=new HashMap<>();
  String[] twitterTokens=new String[4];
  for (int i=0; i < args.length; i++) {
switch (args[i].toLowerCase()) {
case ""String_Node_Str"":
case ""String_Node_Str"":
      followList.add(args[i + 1]);
    break;
case ""String_Node_Str"":
  if (args.length > i + 2) {
    String key=args[i + 1];
    String value=args[i + 2];
    if (!key.startsWith(""String_Node_Str"") && !value.startsWith(""String_Node_Str"")) {
      properties.put(key,value);
    }
 else {
      System.out.println(""String_Node_Str"");
    }
  }
 else {
    System.out.println(""String_Node_Str"");
  }
break;
case ""String_Node_Str"":
if (args.length > i + 4) {
twitterTokens[0]=args[i + 1];
twitterTokens[1]=args[i + 2];
twitterTokens[2]=args[i + 3];
twitterTokens[3]=args[i + 4];
for (String s : twitterTokens) {
  if (s.startsWith(""String_Node_Str"")) {
    System.out.println(""String_Node_Str"" + s + ""String_Node_Str"");
    for (int j=0; j < twitterTokens.length; j++) {
      twitterTokens[j]=null;
    }
    break;
  }
}
}
 else {
System.out.println(""String_Node_Str"");
}
break;
case ""String_Node_Str"":
try {
SavePrintStream printer;
if (args.length > i + 1 && !args[i + 1].startsWith(""String_Node_Str"")) {
printer=new SavePrintStream(System.out,args[i + 1]);
}
 else {
printer=new SavePrintStream(System.out);
}
System.setOut(printer);
System.setErr(printer);
}
 catch (FileNotFoundException fnfe) {
System.out.println(""String_Node_Str"");
fnfe.printStackTrace();
}
break;
case ""String_Node_Str"":
Audio.setAlarmFile(args[i + 1]);
break;
case ""String_Node_Str"":
break;
}
}
PreferenceHandler prefs=new PreferenceHandler(""String_Node_Str"");
final Startup loadingOutput;
if (isHeadless) {
ErrorBuilder.forceCommandLine();
loadingOutput=new LoadingCLI(System.out);
}
 else {
loadingOutput=new LoadingWindow();
}
Updater programUpdater=new Updater(VERSION);
String patchNotes=null;
loadingOutput.start();
loadResources(loadingOutput,hasArgument(args,""String_Node_Str""));
if (!hasArgument(args,""String_Node_Str"") && prefs.getBooleanPreference(""String_Node_Str"",true)) {
if (hasArgument(args,""String_Node_Str"") || prefs.getBooleanPreference(""String_Node_Str"",false)) {
programUpdater.enableAnonymousMode();
}
if (isHeadless) {
programUpdater.enableHeadlessMode();
}
if (programUpdater.loadUpdates(loadingOutput)) {
patchNotes=programUpdater.getPatchNotes();
}
 else {
System.out.println(""String_Node_Str"");
}
}
if (!hasArgument(args,""String_Node_Str"") && prefs.getBooleanPreference(""String_Node_Str"",true)) {
loadNotifications(loadingOutput,hasArgument(args,""String_Node_Str"") || prefs.getBooleanPreference(""String_Node_Str"",false),isHeadless,prefs);
}
loadingOutput.stop();
Setup mySetup;
if (hasArgument(args,""String_Node_Str"")) {
mySetup=new SetupAuto(args);
}
 else if (isHeadless) {
mySetup=new SetupCLI(twitterTokens);
}
 else {
SetupGUI myGUI=new SetupGUI(twitterTokens);
if (patchNotes != null) {
myGUI.setPatchNotesText(patchNotes);
}
 else {
myGUI.setPatchNotesText(""String_Node_Str"");
}
mySetup=myGUI;
}
mySetup.promptForSettings();
twitterTokens[0]=mySetup.getTwitterConsumerKey();
twitterTokens[1]=mySetup.getTwitterConsumerSecret();
twitterTokens[2]=mySetup.getTwitterApplicationKey();
twitterTokens[3]=mySetup.getTwitterApplicationSecret();
Expo myExpo=Expo.parseExpo(mySetup.getExpoToCheck());
Status myStatus;
EmailAccount emailAccount;
try {
emailAccount=new EmailAccount(mySetup.getEmailUsername(),mySetup.getEmailPassword());
for (String s : mySetup.getEmailAddresses()) {
emailAccount.addEmailAddress(s);
}
for (String key : properties.keySet()) {
emailAccount.setProperty(key,properties.get(key));
}
}
 catch (IllegalArgumentException e) {
emailAccount=null;
}
if (!isHeadless) {
StatusGUI statGUI;
if (emailAccount != null) {
statGUI=new StatusGUI(myExpo,emailAccount.getUsername(),emailAccount.getAddressList());
}
 else {
statGUI=new StatusGUI(myExpo);
}
myStatus=statGUI;
if (hasArgument(args,""String_Node_Str"")) {
statGUI.minimizeToTray();
}
 else {
statGUI.showWindow();
}
}
 else {
myStatus=new StatusCLI();
}
if (emailAccount != null) {
myStatus.enableEmail();
}
if (mySetup.shouldPlayAlarm()) {
Audio.enableAlarm();
myStatus.enableAlarm();
}
myLinkManager=new LinkManager(emailAccount);
TicketChecker myChecker=initChecker(mySetup,isHeadless ? null : (StatusGUI)myStatus,myExpo);
if (mySetup.shouldCheckTwitter()) {
TwitterStreamer tcheck=setupTwitter(myStatus,twitterTokens,mySetup.shouldTextTweets());
for (String s : followList) {
tcheck.addUser(s);
}
tcheck.startStreamingTwitter();
myStreamer=tcheck;
myStatus.enableTwitter();
}
checkForTickets(myStatus,myChecker,emailAccount,mySetup.timeBetweenChecks());
}",0.9055802668823292
80975,"/** 
 * Checks for updates. This loads Patch Notes and prompts the user if they want to update. If the user does update, it kills the PAXChecker.
 * @param startupOutput The Startup object to update with information as updates are loaded
 * @return True if updates were checked for successfully, false if not
 */
public boolean loadUpdates(Startup startupOutput){
  String notes=null;
  try {
    startupOutput.setStatus(""String_Node_Str"");
    PatchNotesDownloader notesDownloader=new PatchNotesDownloader(getPatchNotesLink());
    notesDownloader.downloadVersionNotes(programVersion);
    notes=notesDownloader.getVersionNotes();
    if (notesDownloader.updateAvailable()) {
      UpdateDownloader myDownloader=new UpdateDownloader(getUpdateLink(),getBetaUpdateLink());
      UpdatePrompt myPrompt=new UpdatePrompt(""String_Node_Str"",myDownloader.getUpdateSize(),notesDownloader.getUpdateLevel(),programVersion,notesDownloader.getVersionNotes(programVersion));
      startupOutput.stop();
      myPrompt.showWindow();
      try {
        myPrompt.waitForClose();
      }
 catch (      InterruptedException e) {
      }
      if (myPrompt.shouldUpdateProgram()) {
        myDownloader.updateProgram(myPrompt,new File(PAXChecker.class.getProtectionDomain().getCodeSource().getLocation().toURI().getPath()));
        System.exit(0);
      }
 else {
        startupOutput.start();
      }
    }
  }
 catch (  IOException|URISyntaxException e) {
    e.printStackTrace();
    return false;
  }
  patchNotes=notes;
  return true;
}","/** 
 * Checks for updates. This loads Patch Notes and prompts the user if they want to update. If the user does update, it kills the PAXChecker.
 * @param startupOutput The Startup object to update with information as updates are loaded
 * @return True if updates were checked for successfully, false if not
 */
public boolean loadUpdates(Startup startupOutput){
  String notes=null;
  try {
    startupOutput.setStatus(""String_Node_Str"");
    PatchNotesDownloader notesDownloader=new PatchNotesDownloader(getPatchNotesLink());
    notesDownloader.downloadVersionNotes(programVersion);
    notes=notesDownloader.getVersionNotes();
    if (notesDownloader.updateAvailable()) {
      UpdateDownloader myDownloader=new UpdateDownloader(getUpdateLink(),getBetaUpdateLink());
      UpdatePrompt myPrompt=null;
      boolean shouldUpdate;
      if (!headless) {
        myPrompt=new UpdatePrompt(""String_Node_Str"",myDownloader.getUpdateSize(),notesDownloader.getUpdateLevel(),programVersion,notesDownloader.getVersionNotes(programVersion));
        startupOutput.stop();
        myPrompt.showWindow();
        try {
          myPrompt.waitForClose();
        }
 catch (        InterruptedException e) {
        }
        shouldUpdate=myPrompt.shouldUpdateProgram();
      }
 else {
        System.out.println(""String_Node_Str"");
        System.out.println(""String_Node_Str"" + programVersion);
        System.out.println(""String_Node_Str"" + notesDownloader.getUpdateLevel());
        System.out.println(""String_Node_Str"" + myDownloader.getUpdateSize());
        System.out.print(""String_Node_Str"");
        Scanner in=new Scanner(System.in);
        shouldUpdate=in.nextLine().toUpperCase().startsWith(""String_Node_Str"");
      }
      if (shouldUpdate) {
        myDownloader.updateProgram(myPrompt,new File(PAXChecker.class.getProtectionDomain().getCodeSource().getLocation().toURI().getPath()));
        System.exit(0);
      }
 else {
        startupOutput.start();
      }
    }
  }
 catch (  IOException|URISyntaxException e) {
    e.printStackTrace();
    return false;
  }
  patchNotes=notes;
  return true;
}",0.8366336633663366
80976,"/** 
 * Creates a new NotificationHandler.
 * @param anonymousStatistics True for anonymous statistics, false for usage tracking
 * @param lastNotificationID The ID of the last notification loaded, or null or ""DISABLE"" to disable notifications
 */
public NotificationHandler(boolean anonymousStatistics,String lastNotificationID){
  if (lastNotificationID == null) {
    this.lastNotificationID=""String_Node_Str"";
  }
 else {
    this.lastNotificationID=lastNotificationID;
  }
  this.anonymousStatistics=anonymousStatistics;
}","/** 
 * Creates a new NotificationHandler.
 * @param anonymousStatistics True for anonymous statistics, false for usage tracking
 * @param lastNotificationID The ID of the last notification loaded, or null or ""DISABLE"" to disable notifications
 */
public NotificationHandler(String lastNotificationID){
  if (lastNotificationID == null) {
    this.lastNotificationID=""String_Node_Str"";
  }
 else {
    this.lastNotificationID=lastNotificationID;
  }
}",0.9222903885480572
80977,"/** 
 * Checks for updates. This loads Patch Notes and prompts the user if they want to update. If the user does update, it kills the PAXChecker.
 * @param startupOutput The Startup object to update with information as updates are loaded
 * @return True if updates were checked for successfully, false if not
 */
public boolean loadUpdates(Startup startupOutput){
  String notes=null;
  try {
    if (startupOutput != null) {
      startupOutput.setStatus(""String_Node_Str"");
    }
    PatchNotesDownloader notesDownloader=new PatchNotesDownloader(getPatchNotesLink());
    notesDownloader.downloadVersionNotes(programVersion);
    notes=notesDownloader.getVersionNotes();
    if (notesDownloader.updateAvailable()) {
      UpdateDownloader myDownloader=new UpdateDownloader(getUpdateLink(),getBetaUpdateLink());
      UpdatePrompt myPrompt=null;
      boolean shouldUpdate;
      if (!headless) {
        myPrompt=new UpdatePrompt(""String_Node_Str"",myDownloader.getUpdateSize(),notesDownloader.getUpdateLevel(),programVersion,notesDownloader.getVersionNotes(programVersion));
        if (startupOutput != null) {
          startupOutput.stop();
        }
        myPrompt.showWindow();
        try {
          myPrompt.waitForClose();
        }
 catch (        InterruptedException e) {
        }
        shouldUpdate=myPrompt.shouldUpdateProgram();
      }
 else {
        System.out.println(""String_Node_Str"");
        System.out.println(""String_Node_Str"" + programVersion);
        System.out.println(""String_Node_Str"" + notesDownloader.getUpdateLevel());
        System.out.println(""String_Node_Str"" + myDownloader.getUpdateSize());
        System.out.print(""String_Node_Str"");
        Scanner in=new Scanner(System.in);
        shouldUpdate=in.nextLine().toUpperCase().startsWith(""String_Node_Str"");
      }
      if (shouldUpdate) {
        myDownloader.updateProgram(myPrompt,new File(PAXChecker.class.getProtectionDomain().getCodeSource().getLocation().toURI().getPath()));
        System.exit(0);
      }
 else       if (startupOutput != null) {
        startupOutput.start();
      }
    }
  }
 catch (  IOException|URISyntaxException e) {
    e.printStackTrace();
    return false;
  }
  patchNotes=notes;
  return true;
}","/** 
 * Checks for updates. This loads Patch Notes and prompts the user if they want to update. If the user does update, it kills the PAXChecker.
 * @param startupOutput The Startup object to update with information as updates are loaded
 * @return True if updates were checked for successfully, false if not
 */
public boolean loadUpdates(Startup startupOutput){
  String notes=null;
  try {
    if (startupOutput != null) {
      startupOutput.setStatus(""String_Node_Str"");
    }
    PatchNotesDownloader notesDownloader=new PatchNotesDownloader(getPatchNotesLink());
    notesDownloader.downloadVersionNotes(programVersion);
    notes=notesDownloader.getVersionNotes();
    if (notesDownloader.updateAvailable()) {
      UpdateDownloader myDownloader=new UpdateDownloader(getUpdateLink(),getBetaUpdateLink());
      UpdatePrompt myPrompt=null;
      boolean shouldUpdate;
      if (!headless) {
        myPrompt=new UpdatePrompt(""String_Node_Str"",myDownloader.getUpdateSize(),notesDownloader.getUpdateLevel(),programVersion,notesDownloader.getVersionNotes(programVersion));
        if (startupOutput != null) {
          startupOutput.stop();
        }
        myPrompt.showWindow();
        try {
          myPrompt.waitForClose();
        }
 catch (        InterruptedException e) {
        }
        shouldUpdate=myPrompt.shouldUpdateProgram();
      }
 else {
        System.out.println(""String_Node_Str"");
        System.out.println(""String_Node_Str"" + programVersion);
        System.out.println(""String_Node_Str"" + notesDownloader.getUpdateLevel());
        System.out.println(""String_Node_Str"" + myDownloader.getUpdateSize());
        System.out.print(""String_Node_Str"");
        Scanner in=new Scanner(System.in);
        shouldUpdate=in.nextLine().toUpperCase().startsWith(""String_Node_Str"");
      }
      if (shouldUpdate) {
        if (notesDownloader.getUpdateLevel() == 1) {
          myDownloader.setUseBeta();
        }
        myDownloader.updateProgram(myPrompt,new File(PAXChecker.class.getProtectionDomain().getCodeSource().getLocation().toURI().getPath()));
        System.exit(0);
      }
 else       if (startupOutput != null) {
        startupOutput.start();
      }
    }
  }
 catch (  IOException|URISyntaxException e) {
    e.printStackTrace();
    return false;
  }
  patchNotes=notes;
  return true;
}",0.978108581436077
80978,"/** 
 * Plays the alarm. Note that this checks   {@link #soundEnabled()} to make sure it's supposed to play. This method only allows one sound to play at atime, and resets the sound currently playing to the beginning.
 * @return True if the alarm was successfully started, false if not
 */
public static boolean playAlarm(){
  if (!playSound) {
    return false;
  }
  try {
    if (clip != null) {
      clip.stop();
      clip.setFramePosition(0);
    }
    clip=AudioSystem.getClip();
    clip.addLineListener(listener);
    InputStream audioSrc;
    if (alarmFile != null) {
      audioSrc=new FileInputStream(alarmFile);
    }
 else {
      audioSrc=ResourceLoader.loadResource(""String_Node_Str"");
    }
    InputStream bufferedIn=new BufferedInputStream(audioSrc);
    AudioInputStream inputStream=AudioSystem.getAudioInputStream(bufferedIn);
    clip.open(inputStream);
    clip.start();
    return true;
  }
 catch (  LineUnavailableException|UnsupportedAudioFileException|IOException e) {
    e.printStackTrace();
  }
  return false;
}","/** 
 * Plays the alarm. Note that this checks   {@link #soundEnabled()} to make sure it's supposed to play. This method only allows one sound to play at atime, and resets the sound currently playing to the beginning.
 * @return True if the alarm was successfully started, false if not
 */
public static boolean playAlarm(){
  if (!playSound) {
    return false;
  }
  try {
    if (clip != null) {
      clip.stop();
    }
    InputStream audioSrc;
    if (alarmFile != null) {
      audioSrc=new FileInputStream(alarmFile);
    }
 else {
      audioSrc=ResourceLoader.loadResource(""String_Node_Str"");
    }
    InputStream bufferedIn=new BufferedInputStream(audioSrc);
    AudioInputStream inputStream=AudioSystem.getAudioInputStream(bufferedIn);
    DataLine.Info lineInfo=new DataLine.Info(Clip.class,inputStream.getFormat());
    clip=(Clip)AudioSystem.getLine(lineInfo);
    clip.addLineListener(new LListener());
    clip.open(inputStream);
    clip.start();
    return true;
  }
 catch (  Exception e) {
    e.printStackTrace();
    new ErrorBuilder().setErrorTitle(e.toString()).setErrorMessage(e.getMessage() == null ? ""String_Node_Str"" : e.getMessage()).setError(e).buildWindow();
  }
  return false;
}",0.4297740363314133
80979,"/** 
 * Sets up a new HttpURLConnection with PAXChecker defaults. Connection has a 5-second connection timeout, 6-second read timeout.
 * @param url The URL to connect to
 * @return A new HttpURLConnection, or null if unable to set it up or if url is null
 */
public static HttpURLConnection setUpConnection(URL url){
  if (url == null) {
    return null;
  }
  try {
    HttpURLConnection httpCon=(HttpURLConnection)url.openConnection();
    httpCon.addRequestProperty(""String_Node_Str"",""String_Node_Str"");
    httpCon.setConnectTimeout(5000);
    httpCon.setReadTimeout(6000);
    return httpCon;
  }
 catch (  Exception e) {
    e.printStackTrace();
    return null;
  }
}","/** 
 * Sets up a new HttpURLConnection with PAXChecker defaults. Connection has a 5-second connection timeout, 6-second read timeout.
 * @param url The URL to connect to
 * @return A new HttpURLConnection, or null if unable to set it up or if url is null
 */
public static HttpURLConnection setUpConnection(URL url){
  if (url == null) {
    return null;
  }
  try {
    HttpURLConnection httpCon=(HttpURLConnection)url.openConnection();
    httpCon.addRequestProperty(""String_Node_Str"",""String_Node_Str"");
    httpCon.addRequestProperty(""String_Node_Str"",""String_Node_Str"");
    httpCon.setConnectTimeout(5000);
    httpCon.setReadTimeout(6000);
    return httpCon;
  }
 catch (  Exception e) {
    e.printStackTrace();
    return null;
  }
}",0.9513742071881608
80980,"final void updateLinkFromSet(Set<String> mySet){
  for (  String i : mySet) {
    if (!alreadyChecked.contains(i)) {
      System.out.println(""String_Node_Str"" + i);
      if (ShowclixReader.isPaxPage(i)) {
        originalLink=i;
        currentLink=Browser.unshortenURL(i);
        System.out.println(""String_Node_Str"" + originalLink + ""String_Node_Str""+ currentLink);
        break;
      }
 else {
        System.out.println(""String_Node_Str"");
      }
    }
  }
}","final void updateLinkFromSet(Set<String> mySet){
  for (  String i : mySet) {
    if (!alreadyChecked.contains(i)) {
      System.out.println(""String_Node_Str"" + i);
      if (ShowclixReader.isPaxPage(i)) {
        originalLink=i;
        currentLink=Browser.unshortenURL(i);
        System.out.println(""String_Node_Str"" + originalLink + ""String_Node_Str""+ currentLink);
        break;
      }
 else {
        System.out.println(""String_Node_Str"");
        alreadyChecked.add(i);
      }
    }
  }
}",0.96794208893485
80981,"@Override public synchronized void reset(){
  if (currentLink == null) {
    Set<String> mySet=getLinks();
    for (    String i : mySet) {
      alreadyChecked.add(i);
      currentLink=i;
    }
  }
 else {
    alreadyChecked.add(originalLink);
  }
}","@Override public synchronized void reset(){
  if (currentLink == null) {
    Set<String> mySet=getLinks();
    for (    String i : mySet) {
      alreadyChecked.add(i);
      currentLink=i;
    }
  }
 else {
    System.out.println(""String_Node_Str"" + originalLink + ""String_Node_Str"");
    alreadyChecked.add(originalLink);
  }
}",0.8655172413793103
80982,"/** 
 * Checks whether or not the registered Checkers have an update. This method may block for several seconds.
 * @return True if an update is found, false if not
 */
public static boolean isUpdated(){
  if (status != null) {
    status.setForceButtonState(false);
  }
  for (  Check c : checks) {
    threadPool.submit(c);
  }
  System.out.println(""String_Node_Str"");
  threadWait.arriveAndAwaitAdvance();
  System.out.println(""String_Node_Str"");
  for (  Check c : checks) {
    if (c.ticketsFound()) {
      if (!hasOpenedLink(c.getLink())) {
        System.out.println(""String_Node_Str"" + c.getLink());
        setLinkFound(c.getLink());
        c.reset();
        return true;
      }
 else {
        System.out.println(""String_Node_Str"" + c.getLink());
        c.reset();
      }
    }
 else {
      System.out.println(""String_Node_Str"" + c.getLink());
    }
  }
  if (status != null) {
    status.setForceButtonState(true);
  }
  return false;
}","/** 
 * Checks whether or not the registered Checkers have an update. This method may block for several seconds.
 * @return True if an update is found, false if not
 */
public static boolean isUpdated(){
  if (status != null) {
    status.setForceButtonState(false);
  }
  for (  Check c : checks) {
    threadPool.submit(c);
  }
  System.out.println(""String_Node_Str"");
  threadWait.arriveAndAwaitAdvance();
  System.out.println(""String_Node_Str"");
  for (  Check c : checks) {
    if (c.ticketsFound()) {
      if (!hasOpenedLink(c.getLink())) {
        System.out.println(""String_Node_Str"" + c.getLink());
        linkFound(c.getLink());
        c.reset();
        return true;
      }
 else {
        System.out.println(""String_Node_Str"" + c.getLink());
        c.reset();
      }
    }
 else {
      System.out.println(""String_Node_Str"" + c.getLink());
    }
  }
  if (status != null) {
    status.setForceButtonState(true);
  }
  return false;
}",0.9973753280839897
80983,"private static boolean openSystemSpecific(String what){
  EnumOS os=getOs();
  if (os.isLinux()) {
    if (runCommand(""String_Node_Str"",""String_Node_Str"",what)) {
      return true;
    }
 else     if (runCommand(""String_Node_Str"",""String_Node_Str"",what)) {
      return true;
    }
    if (runCommand(""String_Node_Str"",""String_Node_Str"",what)) {
      return true;
    }
  }
  if (os.isMac()) {
    if (runCommand(""String_Node_Str"",""String_Node_Str"",what)) {
      return true;
    }
  }
  if (os.isWindows()) {
    if (runCommand(""String_Node_Str"",""String_Node_Str"",what)) {
      return true;
    }
  }
  return false;
}","private static boolean openSystemSpecific(String what){
  EnumOS os=getOs();
  if (os.isLinux()) {
    if (runCommand(""String_Node_Str"",""String_Node_Str"",what)) {
      return true;
    }
 else     if (runCommand(""String_Node_Str"",""String_Node_Str"",what)) {
      return true;
    }
 else     if (runCommand(""String_Node_Str"",""String_Node_Str"",what)) {
      return true;
    }
  }
  if (os.isMac()) {
    if (runCommand(""String_Node_Str"",""String_Node_Str"",what)) {
      return true;
    }
  }
  if (os.isWindows()) {
    if (runCommand(""String_Node_Str"",""String_Node_Str"",what)) {
      return true;
    }
  }
  return false;
}",0.9952076677316294
80984,"final void updateLink(String link){
  if (linkLabel != null) {
    linkLabel.setText(""String_Node_Str"" + link);
  }
}","final void updateLink(String link){
  if (linkLabel != null) {
    if (this.getClass().getSimpleName().length() <= 5) {
      linkLabel.setText(""String_Node_Str"" + link);
    }
 else {
      linkLabel.setText(""String_Node_Str"" + this.getClass().getSimpleName().substring(5) + ""String_Node_Str""+ link);
    }
  }
}",0.5441860465116279
80985,"private static void loadNotifications(LoadingWindow window){
  window.setStatus(""String_Node_Str"");
  NotificationHandler notifications=new NotificationHandler(false,""String_Node_Str"");
  notifications.loadNotifications();
  notifications.showNewNotifications();
}","private static void loadNotifications(Startup window){
  window.setStatus(""String_Node_Str"");
  NotificationHandler notifications=new NotificationHandler(false,""String_Node_Str"");
  notifications.loadNotifications();
  notifications.showNewNotifications();
}",0.3295019157088122
80986,"private static TicketChecker initChecker(Setup mySetup,Status myStatus,String expo){
  TicketChecker myChecker=new TicketChecker(myStatus);
  if (mySetup.shouldCheckPAXWebsite()) {
    myChecker.addChecker(new CheckPaxsite(expo));
  }
  if (mySetup.shouldCheckShowclix()) {
    myChecker.addChecker(new CheckShowclix(expo));
  }
  if (mySetup.shouldCheckKnownEvents()) {
    myChecker.addChecker(new CheckShowclixEventPage());
  }
  myChecker.initCheckers();
  return myChecker;
}","private static TicketChecker initChecker(Setup mySetup,StatusGUI myStatus,String expo){
  TicketChecker myChecker=new TicketChecker(myStatus);
  if (mySetup.shouldCheckPAXWebsite()) {
    myChecker.addChecker(new CheckPaxsite(expo));
  }
  if (mySetup.shouldCheckShowclix()) {
    myChecker.addChecker(new CheckShowclix(expo));
  }
  if (mySetup.shouldCheckKnownEvents()) {
    myChecker.addChecker(new CheckShowclixEventPage());
  }
  myChecker.initCheckers();
  return myChecker;
}",0.9968847352024922
80987,"/** 
 * @param args the command line arguments
 */
public static void main(String[] args){
  removeOldPreferences();
  System.out.println(""String_Node_Str"");
  java.net.HttpURLConnection.setFollowRedirects(true);
  boolean isHeadless=GraphicsEnvironment.isHeadless();
  boolean isAutostart=false;
  boolean checkUpdates=true;
  boolean checkNotifications=true;
  boolean startMinimized=false;
  List<String> followList=new ArrayList<>();
  Map<String,String> properties=new HashMap<>();
  String[] twitterTokens=new String[4];
  for (int i=0; i < args.length; i++) {
switch (args[i].toLowerCase()) {
case ""String_Node_Str"":
      isHeadless=true;
    break;
case ""String_Node_Str"":
  isAutostart=true;
break;
case ""String_Node_Str"":
checkUpdates=false;
break;
case ""String_Node_Str"":
checkNotifications=false;
break;
case ""String_Node_Str"":
case ""String_Node_Str"":
followList.add(args[i + 1]);
break;
case ""String_Node_Str"":
startMinimized=true;
break;
case ""String_Node_Str"":
if (args.length > i + 2) {
String key=args[i + 1];
String value=args[i + 2];
if (!key.startsWith(""String_Node_Str"") && !value.startsWith(""String_Node_Str"")) {
properties.put(key,value);
}
 else {
System.out.println(""String_Node_Str"");
}
}
 else {
System.out.println(""String_Node_Str"");
}
break;
case ""String_Node_Str"":
twitterTokens[0]=args[i + 1];
twitterTokens[1]=args[i + 2];
twitterTokens[2]=args[i + 3];
twitterTokens[3]=args[i + 4];
break;
case ""String_Node_Str"":
try {
SavePrintStream printer;
if (args.length > i + 1 && !args[i + 1].startsWith(""String_Node_Str"")) {
printer=new SavePrintStream(System.out,args[i + 1]);
}
 else {
printer=new SavePrintStream(System.out);
}
System.setOut(printer);
System.setErr(printer);
}
 catch (FileNotFoundException fnfe) {
System.out.println(""String_Node_Str"");
fnfe.printStackTrace();
}
break;
case ""String_Node_Str"":
Audio.setAlarmFile(args[i + 1]);
break;
default :
if (args[i].startsWith(""String_Node_Str"")) {
System.out.println(""String_Node_Str"" + args[i]);
}
break;
}
}
if (isHeadless) {
ErrorBuilder.forceCommandLine();
}
String patchNotes=null;
final LoadingWindow loadingWindow=new LoadingWindow();
loadingWindow.showWindow();
loadResources(loadingWindow,hasArgument(args,""String_Node_Str""));
if (checkUpdates) {
patchNotes=loadUpdates(loadingWindow);
}
if (checkNotifications) {
loadNotifications(loadingWindow);
}
loadingWindow.dispose();
Setup mySetup;
if (isAutostart) {
mySetup=new SetupAuto(args);
}
 else if (isHeadless) {
mySetup=new SetupCLI();
}
 else {
SetupGUI myGUI=new SetupGUI(twitterTokens);
if (patchNotes != null) {
myGUI.setPatchNotesText(patchNotes);
}
 else {
myGUI.setPatchNotesText(""String_Node_Str"");
}
mySetup=myGUI;
}
mySetup.promptForSettings();
twitterTokens[0]=mySetup.getTwitterConsumerKey();
twitterTokens[1]=mySetup.getTwitterConsumerSecret();
twitterTokens[2]=mySetup.getTwitterApplicationKey();
twitterTokens[3]=mySetup.getTwitterApplicationSecret();
Browser myBrowser=new Browser();
myBrowser.setExpo(mySetup.getExpoToCheck());
Status myStatus;
EmailAccount emailAccount;
try {
emailAccount=new EmailAccount(mySetup.getEmailUsername(),mySetup.getEmailPassword());
for (String s : mySetup.getEmailAddresses()) {
emailAccount.addEmailAddress(s);
}
for (String key : properties.keySet()) {
emailAccount.setProperty(key,properties.get(key));
}
myStatus=new Status(myBrowser.getExpo(),emailAccount.getUsername(),emailAccount.getAddressList());
myStatus.enableEmail();
}
 catch (IllegalArgumentException e) {
emailAccount=null;
myStatus=new Status(myBrowser.getExpo());
}
if (mySetup.shouldPlayAlarm()) {
Audio.enableAlarm();
myStatus.enableAlarm();
}
final TicketChecker myChecker=initChecker(mySetup,myStatus,myBrowser.getExpo());
if (mySetup.shouldCheckTwitter()) {
TwitterStreamer tcheck=setupTwitter(myStatus,twitterTokens);
for (String s : followList) {
tcheck.addUser(s);
}
tcheck.startStreamingTwitter();
myStreamer=tcheck;
myStatus.enableTwitter();
}
if (startMinimized) {
myStatus.minimizeToTray();
}
 else {
myStatus.showWindow();
}
checkForTickets(myStatus,myChecker,emailAccount,mySetup.timeBetweenChecks());
}","/** 
 * @param args the command line arguments
 */
public static void main(String[] args){
  removeOldPreferences();
  System.out.println(""String_Node_Str"");
  java.net.HttpURLConnection.setFollowRedirects(true);
  boolean isHeadless=GraphicsEnvironment.isHeadless();
  boolean isAutostart=false;
  boolean checkUpdates=true;
  boolean checkNotifications=true;
  boolean startMinimized=false;
  List<String> followList=new ArrayList<>();
  Map<String,String> properties=new HashMap<>();
  String[] twitterTokens=new String[4];
  for (int i=0; i < args.length; i++) {
switch (args[i].toLowerCase()) {
case ""String_Node_Str"":
      isHeadless=true;
    break;
case ""String_Node_Str"":
  isAutostart=true;
break;
case ""String_Node_Str"":
checkUpdates=false;
break;
case ""String_Node_Str"":
checkNotifications=false;
break;
case ""String_Node_Str"":
case ""String_Node_Str"":
followList.add(args[i + 1]);
break;
case ""String_Node_Str"":
startMinimized=true;
break;
case ""String_Node_Str"":
if (args.length > i + 2) {
String key=args[i + 1];
String value=args[i + 2];
if (!key.startsWith(""String_Node_Str"") && !value.startsWith(""String_Node_Str"")) {
properties.put(key,value);
}
 else {
System.out.println(""String_Node_Str"");
}
}
 else {
System.out.println(""String_Node_Str"");
}
break;
case ""String_Node_Str"":
if (args.length > i + 4) {
twitterTokens[0]=args[i + 1];
twitterTokens[1]=args[i + 2];
twitterTokens[2]=args[i + 3];
twitterTokens[3]=args[i + 4];
for (String s : twitterTokens) {
if (s.startsWith(""String_Node_Str"")) {
System.out.println(""String_Node_Str"" + s + ""String_Node_Str"");
for (int j=0; j < twitterTokens.length; j++) {
twitterTokens[j]=null;
}
break;
}
}
}
 else {
System.out.println(""String_Node_Str"");
}
break;
case ""String_Node_Str"":
try {
SavePrintStream printer;
if (args.length > i + 1 && !args[i + 1].startsWith(""String_Node_Str"")) {
printer=new SavePrintStream(System.out,args[i + 1]);
}
 else {
printer=new SavePrintStream(System.out);
}
System.setOut(printer);
System.setErr(printer);
}
 catch (FileNotFoundException fnfe) {
System.out.println(""String_Node_Str"");
fnfe.printStackTrace();
}
break;
case ""String_Node_Str"":
Audio.setAlarmFile(args[i + 1]);
break;
default :
if (args[i].startsWith(""String_Node_Str"")) {
System.out.println(""String_Node_Str"" + args[i]);
}
break;
}
}
final Startup loadingOutput;
if (isHeadless) {
ErrorBuilder.forceCommandLine();
loadingOutput=new LoadingCLI(System.out);
}
 else {
loadingOutput=new LoadingWindow();
}
String patchNotes=null;
loadingOutput.start();
loadResources(loadingOutput,hasArgument(args,""String_Node_Str""));
if (checkUpdates) {
patchNotes=loadUpdates(loadingOutput);
}
if (checkNotifications) {
loadNotifications(loadingOutput);
}
loadingOutput.stop();
Setup mySetup;
if (isAutostart) {
mySetup=new SetupAuto(args);
}
 else if (isHeadless) {
mySetup=new SetupCLI(twitterTokens);
}
 else {
SetupGUI myGUI=new SetupGUI(twitterTokens);
if (patchNotes != null) {
myGUI.setPatchNotesText(patchNotes);
}
 else {
myGUI.setPatchNotesText(""String_Node_Str"");
}
mySetup=myGUI;
}
mySetup.promptForSettings();
twitterTokens[0]=mySetup.getTwitterConsumerKey();
twitterTokens[1]=mySetup.getTwitterConsumerSecret();
twitterTokens[2]=mySetup.getTwitterApplicationKey();
twitterTokens[3]=mySetup.getTwitterApplicationSecret();
Browser myBrowser=new Browser();
myBrowser.setExpo(mySetup.getExpoToCheck());
Status myStatus;
EmailAccount emailAccount;
try {
emailAccount=new EmailAccount(mySetup.getEmailUsername(),mySetup.getEmailPassword());
for (String s : mySetup.getEmailAddresses()) {
emailAccount.addEmailAddress(s);
}
for (String key : properties.keySet()) {
emailAccount.setProperty(key,properties.get(key));
}
}
 catch (IllegalArgumentException e) {
emailAccount=null;
}
if (!isHeadless) {
StatusGUI statGUI;
if (emailAccount != null) {
statGUI=new StatusGUI(myBrowser.getExpo(),emailAccount.getUsername(),emailAccount.getAddressList());
}
 else {
statGUI=new StatusGUI(myBrowser.getExpo());
}
myStatus=statGUI;
if (startMinimized) {
statGUI.minimizeToTray();
}
 else {
statGUI.showWindow();
}
}
 else {
myStatus=new StatusCLI();
}
if (emailAccount != null) {
myStatus.enableEmail();
}
if (mySetup.shouldPlayAlarm()) {
Audio.enableAlarm();
myStatus.enableAlarm();
}
final TicketChecker myChecker=initChecker(mySetup,isHeadless ? null : (StatusGUI)myStatus,myBrowser.getExpo());
if (mySetup.shouldCheckTwitter()) {
TwitterStreamer tcheck=setupTwitter(myStatus,twitterTokens);
for (String s : followList) {
tcheck.addUser(s);
}
tcheck.startStreamingTwitter();
myStreamer=tcheck;
myStatus.enableTwitter();
}
checkForTickets(myStatus,myChecker,emailAccount,mySetup.timeBetweenChecks());
}",0.78189111747851
80988,"private static String loadUpdates(LoadingWindow window){
  String notes=null;
  try {
    window.setStatus(""String_Node_Str"");
    PatchNotesDownloader notesDownloader=new PatchNotesDownloader(PATCH_NOTES_LINK);
    notesDownloader.downloadVersionNotes(VERSION);
    notes=notesDownloader.getVersionNotes();
    if (notesDownloader.updateAvailable()) {
      UpdateDownloader myDownloader=new UpdateDownloader(UPDATE_LINK,BETA_UPDATE_LINK);
      UpdatePrompt myPrompt=new UpdatePrompt(""String_Node_Str"",myDownloader.getUpdateSize(),notesDownloader.getUpdateLevel(),""String_Node_Str"",notesDownloader.getVersionNotes(VERSION));
      window.setVisible(false);
      myPrompt.showWindow();
      try {
        myPrompt.waitForClose();
      }
 catch (      InterruptedException e) {
      }
      if (myPrompt.shouldUpdateProgram()) {
        myDownloader.updateProgram(myPrompt,new File(PAXChecker.class.getProtectionDomain().getCodeSource().getLocation().toURI().getPath()));
        System.exit(0);
      }
 else {
        window.showWindow();
      }
    }
  }
 catch (  IOException|URISyntaxException e) {
    e.printStackTrace();
  }
  return notes;
}","private static String loadUpdates(Startup window){
  String notes=null;
  try {
    window.setStatus(""String_Node_Str"");
    PatchNotesDownloader notesDownloader=new PatchNotesDownloader(PATCH_NOTES_LINK);
    notesDownloader.downloadVersionNotes(VERSION);
    notes=notesDownloader.getVersionNotes();
    if (notesDownloader.updateAvailable()) {
      UpdateDownloader myDownloader=new UpdateDownloader(UPDATE_LINK,BETA_UPDATE_LINK);
      UpdatePrompt myPrompt=new UpdatePrompt(""String_Node_Str"",myDownloader.getUpdateSize(),notesDownloader.getUpdateLevel(),""String_Node_Str"",notesDownloader.getVersionNotes(VERSION));
      window.stop();
      myPrompt.showWindow();
      try {
        myPrompt.waitForClose();
      }
 catch (      InterruptedException e) {
      }
      if (myPrompt.shouldUpdateProgram()) {
        myDownloader.updateProgram(myPrompt,new File(PAXChecker.class.getProtectionDomain().getCodeSource().getLocation().toURI().getPath()));
        System.exit(0);
      }
 else {
        window.start();
      }
    }
  }
 catch (  IOException|URISyntaxException e) {
    e.printStackTrace();
  }
  return notes;
}",0.9772727272727272
80989,"/** 
 * Checks for tickets. Blocks indefinitely. Note that if checker is not checking anything, this method does not block and only modifies the Status GUI status text.
 * @param status The Status window to update
 * @param checker The TicketChecker to use
 * @param email The EmailAccount to use, or null for none
 * @param checkTime The time between checks
 * @throws NullPointerException if any arguments besides email are null
 */
private static void checkForTickets(Status status,TicketChecker checker,EmailAccount email,int checkTime){
  if (checker.isCheckingAnything()) {
    while (true) {
      status.setLastCheckedText(""String_Node_Str"");
      long startTime=System.currentTimeMillis();
      if (checker.isUpdated()) {
        Browser.openLinkInBrowser(checker.getLinkFound());
        if (email != null) {
          try {
            email.sendMessage(""String_Node_Str"",""String_Node_Str"" + checker.getLinkFound());
          }
 catch (          IllegalStateException e) {
            System.out.println(""String_Node_Str"" + e.getMessage() + ""String_Node_Str"");
          }
        }
        Tickets ticketWindow=new Tickets(checker.getLinkFound());
        ticketWindow.showWindow();
      }
      status.setDataUsageText(DataTracker.getDataUsedMB());
      while (System.currentTimeMillis() - startTime < checkTime * 1000) {
synchronized (status) {
          int button=status.getButtonPressed();
          if (button > 0) {
            status.resetButtonPressed();
            if (button == 1) {
              break;
            }
 else             if (button == 2) {
              if (email != null) {
                status.setInformationText(""String_Node_Str"");
                try {
                  if (email.sendMessage(""String_Node_Str"",""String_Node_Str"")) {
                    status.setInformationText(""String_Node_Str"");
                  }
 else {
                    status.setInformationText(""String_Node_Str"");
                  }
                }
 catch (                IllegalStateException e) {
                  status.setInformationText(""String_Node_Str"");
                }
              }
            }
 else             if (button == 3) {
              if (Audio.playAlarm()) {
                status.setInformationText(""String_Node_Str"");
              }
 else {
                status.setInformationText(""String_Node_Str"");
              }
            }
 else             if (button == 4) {
              if (myStreamer != null) {
                myStreamer.startStreamingTwitter();
              }
            }
          }
        }
        status.setLastCheckedText(checkTime - (int)((System.currentTimeMillis() - startTime) / 1000));
        try {
          Thread.sleep(200);
        }
 catch (        InterruptedException iE) {
          iE.printStackTrace();
        }
      }
    }
  }
 else {
    status.setLastCheckedText(""String_Node_Str"");
  }
}","/** 
 * Checks for tickets. Blocks indefinitely. Note that if checker is not checking anything, this method does not block and only modifies the StatusGUI GUI status text.
 * @param status The StatusGUI window to update
 * @param checker The TicketChecker to use
 * @param email The EmailAccount to use, or null for none
 * @param checkTime The time between checks
 * @throws NullPointerException if any arguments besides email are null
 */
private static void checkForTickets(Status status,TicketChecker checker,EmailAccount email,int checkTime){
  if (checker.isCheckingAnything()) {
    while (true) {
      status.setLastCheckedText(""String_Node_Str"");
      long startTime=System.currentTimeMillis();
      if (checker.isUpdated()) {
        Browser.openLinkInBrowser(checker.getLinkFound());
        if (email != null) {
          try {
            email.sendMessage(""String_Node_Str"",""String_Node_Str"" + checker.getLinkFound());
          }
 catch (          IllegalStateException e) {
            System.out.println(""String_Node_Str"" + e.getMessage() + ""String_Node_Str"");
          }
        }
        Tickets ticketWindow=new Tickets(checker.getLinkFound());
        ticketWindow.showWindow();
      }
      status.setDataUsageText(DataTracker.getDataUsedMB());
      while (System.currentTimeMillis() - startTime < checkTime * 1000) {
synchronized (status) {
          int button=status.getButtonPressed();
          if (button > 0) {
            status.resetButtonPressed();
            if (button == 1) {
              break;
            }
 else             if (button == 2) {
              if (email != null) {
                status.setInformationText(""String_Node_Str"");
                try {
                  if (email.sendMessage(""String_Node_Str"",""String_Node_Str"")) {
                    status.setInformationText(""String_Node_Str"");
                  }
 else {
                    status.setInformationText(""String_Node_Str"");
                  }
                }
 catch (                IllegalStateException e) {
                  status.setInformationText(""String_Node_Str"");
                }
              }
            }
 else             if (button == 3) {
              if (Audio.playAlarm()) {
                status.setInformationText(""String_Node_Str"");
              }
 else {
                status.setInformationText(""String_Node_Str"");
              }
            }
 else             if (button == 4) {
              if (myStreamer != null) {
                myStreamer.startStreamingTwitter();
              }
            }
          }
        }
        status.setLastCheckedText(checkTime - (int)((System.currentTimeMillis() - startTime) / 1000));
        try {
          Thread.sleep(200);
        }
 catch (        InterruptedException iE) {
          iE.printStackTrace();
        }
      }
    }
  }
 else {
    status.setLastCheckedText(""String_Node_Str"");
  }
}",0.9986225895316804
80990,"private static void loadResources(final LoadingWindow window,boolean redownload){
  ResourceDownloader download=new ResourceDownloader(){
    private String currentFile;
    @Override public void startingFile(    String fileName){
      currentFile=fileName;
      window.setStatus(""String_Node_Str"" + currentFile);
    }
    @Override public void filePercentage(    int percent){
      super.filePercentage(percent);
      window.setStatus(""String_Node_Str"" + currentFile + ""String_Node_Str""+ percent+ ""String_Node_Str"");
    }
    @Override public void finishedFile(    String fileName){
      window.setStatus(""String_Node_Str"" + fileName);
    }
  }
;
  if (redownload) {
    download.forceRedownload();
  }
  download.downloadResources();
}","private static void loadResources(final Startup window,boolean redownload){
  ResourceDownloader download=new ResourceDownloader(){
    private String currentFile;
    @Override public void startingFile(    String fileName){
      currentFile=fileName;
      window.setStatus(""String_Node_Str"" + currentFile);
    }
    @Override public void filePercentage(    int percent){
      super.filePercentage(percent);
      window.setStatus(""String_Node_Str"" + currentFile + ""String_Node_Str""+ percent+ ""String_Node_Str"");
    }
    @Override public void finishedFile(    String fileName){
      window.setStatus(""String_Node_Str"" + fileName);
    }
  }
;
  if (redownload) {
    download.forceRedownload();
  }
  download.downloadResources();
}",0.9865229110512128
80991,"public void init(com.github.sunnybat.paxchecker.gui.Status s,java.util.concurrent.Phaser cB){
  if (s != null) {
    linkLabel=s.addLinkJLabel();
  }
  updateLabel(s,""String_Node_Str"");
  cycBar=cB;
  cycBar.register();
  reset();
}","public void init(com.github.sunnybat.paxchecker.status.StatusGUI s,java.util.concurrent.Phaser cB){
  if (s != null) {
    linkLabel=s.addLinkJLabel();
  }
  updateLabel(s,""String_Node_Str"");
  cycBar=cB;
  cycBar.register();
  reset();
}",0.9744680851063828
80992,"public final void updateLabel(com.github.sunnybat.paxchecker.gui.Status s,String text){
  if (s != null) {
    s.updateJLabel(linkLabel,text);
  }
}","public final void updateLabel(com.github.sunnybat.paxchecker.status.StatusGUI s,String text){
  if (s != null) {
    s.updateJLabel(linkLabel,text);
  }
}",0.9668874172185432
80993,"@Override public synchronized void init(com.github.sunnybat.paxchecker.gui.Status s,java.util.concurrent.Phaser cB){
  super.init(s,cB);
  updateLabel(s,""String_Node_Str"");
}","@Override public synchronized void init(com.github.sunnybat.paxchecker.status.StatusGUI s,java.util.concurrent.Phaser cB){
  super.init(s,cB);
  updateLabel(s,""String_Node_Str"");
}",0.9717514124293786
80994,"@Override public synchronized void init(com.github.sunnybat.paxchecker.gui.Status s,java.util.concurrent.Phaser cB){
  super.init(s,cB);
  updateLabel(s,""String_Node_Str"");
}","@Override public synchronized void init(com.github.sunnybat.paxchecker.status.StatusGUI s,java.util.concurrent.Phaser cB){
  super.init(s,cB);
  updateLabel(s,""String_Node_Str"");
}",0.9717514124293786
80995,"@Override public synchronized void init(com.github.sunnybat.paxchecker.gui.Status s,java.util.concurrent.Phaser cB){
  super.init(s,cB);
  updateLabel(s,""String_Node_Str"");
}","@Override public synchronized void init(com.github.sunnybat.paxchecker.status.StatusGUI s,java.util.concurrent.Phaser cB){
  super.init(s,cB);
  updateLabel(s,""String_Node_Str"");
}",0.9717514124293786
80996,"/** 
 * Initializes the TicketChecker class.
 * @param s The Status to update, or null if none
 */
public TicketChecker(com.github.sunnybat.paxchecker.gui.Status s){
  status=s;
  threadPool=Executors.newCachedThreadPool();
  threadWait=new Phaser();
  threadWait.register();
}","/** 
 * Initializes the TicketChecker class.
 * @param s The StatusGUI to update, or null if none
 */
public TicketChecker(com.github.sunnybat.paxchecker.status.StatusGUI s){
  status=s;
  threadPool=Executors.newCachedThreadPool();
  threadWait=new Phaser();
  threadWait.register();
}",0.9733570159857904
80997,"@Override public void onException(Exception ex){
  ex.printStackTrace();
  if (++successiveErrorCount == 1) {
    if (ex.getMessage().contains(""String_Node_Str"")) {
      new ErrorBuilder().setError(ex).setErrorTitle(""String_Node_Str"").setErrorMessage(""String_Node_Str"" + ""String_Node_Str"").buildWindow();
    }
  }
 else   if (successiveErrorCount == 3) {
    if (ex.getMessage().contains(""String_Node_Str"")) {
      new ErrorBuilder().setError(ex).setErrorTitle(""String_Node_Str"").setErrorMessage(""String_Node_Str"" + ""String_Node_Str"").buildWindow();
    }
 else {
      new ErrorBuilder().setError(ex).setErrorTitle(""String_Node_Str"").setErrorMessage(""String_Node_Str"" + ""String_Node_Str"").buildWindow();
    }
    myStream.shutdown();
  }
}","@Override public void onException(Exception ex){
  ex.printStackTrace();
  if (++successiveErrorCount == 1) {
    if (ex.getMessage().contains(""String_Node_Str"")) {
      new ErrorBuilder().setError(ex).setErrorTitle(""String_Node_Str"").setErrorMessage(""String_Node_Str"" + ""String_Node_Str"").buildWindow();
    }
  }
 else   if (successiveErrorCount == 3) {
    if (ex.getMessage().contains(""String_Node_Str"")) {
      new ErrorBuilder().setError(ex).setErrorTitle(""String_Node_Str"").setErrorMessage(""String_Node_Str"" + ""String_Node_Str"").buildWindow();
    }
 else     if (ex.getMessage().contains(""String_Node_Str"")) {
      new ErrorBuilder().setError(ex).setErrorTitle(""String_Node_Str"").setErrorMessage(""String_Node_Str"" + ""String_Node_Str"").buildWindow();
    }
 else {
      new ErrorBuilder().setError(ex).setErrorTitle(""String_Node_Str"").setErrorMessage(""String_Node_Str"" + ""String_Node_Str"").buildWindow();
    }
    myStream.shutdown();
  }
}",0.8773584905660378
80998,"/** 
 * Starts looking for Twitter updates. If the stream is already started -- connected or disconnected -- this method does nothing.
 */
public void startStreamingTwitter(){
  if (isStreamingTwitter()) {
    System.out.println(""String_Node_Str"");
    return;
  }
  try {
    myStream=new TwitterStreamFactory().getInstance(myTwitter.getAuthorization());
    myStream.addListener(listener);
    myStream.addConnectionLifeCycleListener(cLCListener);
    long[] ids=new long[usersToCheck.size()];
    for (int i=0; i < usersToCheck.size(); i++) {
      User toAdd=myTwitter.showUser(usersToCheck.get(i));
      ids[i]=toAdd.getId();
    }
    FilterQuery filter=new FilterQuery(0,ids);
    myStream.filter(filter);
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}","/** 
 * Starts looking for Twitter updates. If the stream is already started -- connected or disconnected -- this method does nothing.
 */
public void startStreamingTwitter(){
  if (isStreamingTwitter()) {
    System.out.println(""String_Node_Str"");
    return;
  }
  try {
    myStream=new TwitterStreamFactory().getInstance(myTwitter.getAuthorization());
    myStream.addListener(listener);
    myStream.addConnectionLifeCycleListener(cLCListener);
    long[] ids=new long[usersToCheck.size()];
    for (int i=0; i < usersToCheck.size(); i++) {
      try {
        User toAdd=myTwitter.showUser(usersToCheck.get(i));
        ids[i]=toAdd.getId();
      }
 catch (      TwitterException tE) {
        System.out.println(""String_Node_Str"" + usersToCheck.get(i) + ""String_Node_Str"");
      }
    }
    FilterQuery filter=new FilterQuery(0,ids);
    myStream.filter(filter);
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}",0.9072769953051644
80999,"@Override public void promptForSettings(){
  Scanner myScanner=new Scanner(System.in);
  String name=""String_Node_Str"";
  while (name.length() > 0) {
    System.out.print(""String_Node_Str"");
    try {
      name=myScanner.nextLine();
      if (name.length() == 0) {
      }
 else       if (name.length() < 5) {
        System.out.println(""String_Node_Str"");
      }
 else {
        emailAddress=name;
        System.out.print(""String_Node_Str"");
        emailPassword=new String(System.console().readPassword());
        while (true) {
          System.out.print(""String_Node_Str"");
          try {
            String cellNum=myScanner.nextLine();
            if (cellNum.length() == 0) {
              break;
            }
 else {
              emailSendToList.add(cellNum);
            }
          }
 catch (          Exception e) {
            e.printStackTrace();
            System.out.println(""String_Node_Str"");
            break;
          }
        }
        break;
      }
    }
 catch (    Exception e) {
      e.printStackTrace();
      System.out.println(""String_Node_Str"");
      break;
    }
  }
  System.out.print(""String_Node_Str"");
  try {
    String input=myScanner.nextLine();
switch (input.toLowerCase()) {
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
      expoToCheck=""String_Node_Str"";
    break;
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
  expoToCheck=""String_Node_Str"";
break;
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
expoToCheck=""String_Node_Str"";
break;
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
expoToCheck=""String_Node_Str"";
break;
default :
System.out.println(""String_Node_Str"" + input + ""String_Node_Str"");
expoToCheck=""String_Node_Str"";
break;
}
}
 catch (Exception e) {
}
System.out.print(""String_Node_Str"");
checkPaxWebsite=isResponseYes(myScanner);
System.out.print(""String_Node_Str"");
checkShowclixWebsite=isResponseYes(myScanner);
System.out.print(""String_Node_Str"");
checkKnownEvents=isResponseYes(myScanner);
System.out.print(""String_Node_Str"");
checkTwitter=isResponseYes(myScanner);
if (checkTwitter) {
boolean inputKeys=true;
if (consumerKey != null) {
System.out.print(""String_Node_Str"");
inputKeys=isResponseYes(myScanner);
}
if (inputKeys) {
System.out.print(""String_Node_Str"");
consumerKey=myScanner.nextLine();
System.out.print(""String_Node_Str"");
consumerSecret=myScanner.nextLine();
System.out.print(""String_Node_Str"");
applicationKey=myScanner.nextLine();
System.out.print(""String_Node_Str"");
applicationSecret=myScanner.nextLine();
}
System.out.print(""String_Node_Str"");
filterTwitter=isResponseYes(myScanner);
System.out.println(""String_Node_Str"" + ""String_Node_Str"");
}
System.out.print(""String_Node_Str"");
try {
refreshTime=Integer.parseInt(myScanner.nextLine());
refreshTime=Math.max(refreshTime,10);
refreshTime=Math.min(refreshTime,120);
}
 catch (Exception e) {
System.out.println(""String_Node_Str"");
}
System.out.print(""String_Node_Str"");
playAlarm=isResponseYes(myScanner);
}","@Override public void promptForSettings(){
  Scanner myScanner=new Scanner(System.in);
  String name=""String_Node_Str"";
  while (name.length() > 0) {
    System.out.print(""String_Node_Str"");
    try {
      name=myScanner.nextLine();
      if (name.length() == 0) {
      }
 else       if (name.length() < 5) {
        System.out.println(""String_Node_Str"");
      }
 else {
        emailAddress=name;
        System.out.print(""String_Node_Str"");
        emailPassword=new String(System.console().readPassword());
        while (true) {
          System.out.print(""String_Node_Str"");
          try {
            String cellNum=myScanner.nextLine();
            if (cellNum.length() == 0) {
              break;
            }
 else {
              emailSendToList.add(cellNum);
            }
          }
 catch (          Exception e) {
            e.printStackTrace();
            System.out.println(""String_Node_Str"");
            break;
          }
        }
        break;
      }
    }
 catch (    Exception e) {
      e.printStackTrace();
      System.out.println(""String_Node_Str"");
      break;
    }
  }
  System.out.print(""String_Node_Str"");
  try {
    String input=myScanner.nextLine();
switch (input.toLowerCase()) {
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
      expoToCheck=""String_Node_Str"";
    break;
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
  expoToCheck=""String_Node_Str"";
break;
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
expoToCheck=""String_Node_Str"";
break;
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
case ""String_Node_Str"":
expoToCheck=""String_Node_Str"";
break;
default :
System.out.println(""String_Node_Str"" + input + ""String_Node_Str"");
expoToCheck=""String_Node_Str"";
break;
}
}
 catch (Exception e) {
}
System.out.print(""String_Node_Str"");
checkPaxWebsite=isResponseYes(myScanner);
System.out.print(""String_Node_Str"");
checkShowclixWebsite=isResponseYes(myScanner);
System.out.print(""String_Node_Str"");
checkKnownEvents=isResponseYes(myScanner);
System.out.print(""String_Node_Str"");
checkTwitter=isResponseYes(myScanner);
if (checkTwitter) {
boolean inputKeys=true;
if (consumerKey != null) {
System.out.print(""String_Node_Str"");
inputKeys=isResponseYes(myScanner);
}
if (inputKeys) {
System.out.println(""String_Node_Str"" + ""String_Node_Str"");
System.out.print(""String_Node_Str"");
consumerKey=myScanner.nextLine();
System.out.print(""String_Node_Str"");
consumerSecret=myScanner.nextLine();
System.out.print(""String_Node_Str"");
applicationKey=myScanner.nextLine();
System.out.print(""String_Node_Str"");
applicationSecret=myScanner.nextLine();
}
System.out.print(""String_Node_Str"");
filterTwitter=isResponseYes(myScanner);
}
System.out.print(""String_Node_Str"");
try {
refreshTime=Integer.parseInt(myScanner.nextLine());
refreshTime=Math.max(refreshTime,10);
refreshTime=Math.min(refreshTime,120);
}
 catch (Exception e) {
System.out.println(""String_Node_Str"");
}
System.out.print(""String_Node_Str"");
playAlarm=isResponseYes(myScanner);
}",0.9811260396673064
81000,"/** 
 * Sets the current email address (username) for the program to use. Note that if the username does not contain an ending (&#64;site.net) or is null, &#64;yahoo.com is automatically appended to the end of the username. If the site ending does not end in &#64;yahoo.com or &#64;gmail.com, the program parses the SMTP server addess after the address ending and two colons.<br> Example: User&#64;site.com::site.smtp.server<br> This also (optionall) parses the site's SMTP port after the SMTP server address and a colon.<br> Example: User&#64;site.com::site.smtp.server:123
 * @param username The username to set
 */
public static void setUsername(String username){
  if (username == null) {
    props.put(""String_Node_Str"",""String_Node_Str"");
    return;
  }
  if (username.length() < 3) {
    System.out.println(""String_Node_Str"");
    props.put(""String_Node_Str"",""String_Node_Str"");
    return;
  }
 else   if (!username.contains(""String_Node_Str"")) {
    username+=""String_Node_Str"";
    setHost(""String_Node_Str"");
  }
 else   if (username.toLowerCase().contains(""String_Node_Str"")) {
    setHost(""String_Node_Str"");
  }
 else   if (username.toLowerCase().contains(""String_Node_Str"")) {
    setHost(""String_Node_Str"");
  }
 else {
    if (!username.contains(""String_Node_Str"")) {
      System.out.println(""String_Node_Str"");
      ErrorDisplay.showErrorWindow(""String_Node_Str"",""String_Node_Str"" + username + ""String_Node_Str"",null);
      props.put(""String_Node_Str"",""String_Node_Str"");
      return;
    }
    String extraInfo=null;
    try {
      extraInfo=username.toLowerCase().substring(username.indexOf(""String_Node_Str"") + 2);
      System.out.println(""String_Node_Str"" + extraInfo);
    }
 catch (    Exception e) {
      System.out.println(""String_Node_Str"");
    }
    if (extraInfo == null) {
      ErrorDisplay.showErrorWindow(""String_Node_Str"",""String_Node_Str"",null);
      props.put(""String_Node_Str"",""String_Node_Str"");
      return;
    }
    String tempHost;
    try {
      if (extraInfo.contains(""String_Node_Str"")) {
        tempHost=extraInfo.substring(0,extraInfo.indexOf(""String_Node_Str""));
        setPort(extraInfo.substring(extraInfo.indexOf(""String_Node_Str"") + 1));
        System.out.println(""String_Node_Str"" + getPort());
      }
 else {
        tempHost=extraInfo;
      }
      setHost(tempHost);
    }
 catch (    Exception e) {
      System.out.println(""String_Node_Str"");
      ErrorDisplay.showErrorWindow(""String_Node_Str"",""String_Node_Str"" + extraInfo + ""String_Node_Str"",e);
      props.put(""String_Node_Str"",""String_Node_Str"");
      return;
    }
    username=username.substring(0,username.indexOf(""String_Node_Str""));
  }
  System.out.println(""String_Node_Str"" + username);
  props.put(""String_Node_Str"",username);
}","/** 
 * Sets the current email address (username) for the program to use. Note that if the username does not contain an ending (&#64;site.net) or is null, &#64;yahoo.com is automatically appended to the end of the username. If the site ending does not end in &#64;yahoo.com or &#64;gmail.com, the program parses the SMTP server addess after the address ending and two colons.<br> Example: User&#64;site.com::site.smtp.server<br> This also (optionall) parses the site's SMTP port after the SMTP server address and a colon.<br> Example: User&#64;site.com::site.smtp.server:123
 * @param username The username to set
 */
public static void setUsername(String username){
  if (username == null) {
    System.out.println(""String_Node_Str"");
    props.put(""String_Node_Str"",""String_Node_Str"");
    return;
  }
  if (username.length() < 3) {
    System.out.println(""String_Node_Str"");
    props.put(""String_Node_Str"",""String_Node_Str"");
    return;
  }
 else   if (!username.contains(""String_Node_Str"")) {
    username+=""String_Node_Str"";
    setHost(""String_Node_Str"");
  }
 else   if (username.toLowerCase().contains(""String_Node_Str"")) {
    setHost(""String_Node_Str"");
  }
 else   if (username.toLowerCase().contains(""String_Node_Str"")) {
    setHost(""String_Node_Str"");
  }
 else {
    if (!username.contains(""String_Node_Str"")) {
      System.out.println(""String_Node_Str"");
      ErrorDisplay.showErrorWindow(""String_Node_Str"",""String_Node_Str"" + username + ""String_Node_Str"",null);
      props.put(""String_Node_Str"",""String_Node_Str"");
      return;
    }
    String extraInfo=null;
    try {
      extraInfo=username.toLowerCase().substring(username.indexOf(""String_Node_Str"") + 2);
      System.out.println(""String_Node_Str"" + extraInfo);
    }
 catch (    Exception e) {
      System.out.println(""String_Node_Str"");
    }
    if (extraInfo == null) {
      ErrorDisplay.showErrorWindow(""String_Node_Str"",""String_Node_Str"",null);
      props.put(""String_Node_Str"",""String_Node_Str"");
      return;
    }
    String tempHost;
    try {
      if (extraInfo.contains(""String_Node_Str"")) {
        tempHost=extraInfo.substring(0,extraInfo.indexOf(""String_Node_Str""));
        setPort(extraInfo.substring(extraInfo.indexOf(""String_Node_Str"") + 1));
        System.out.println(""String_Node_Str"" + getPort());
      }
 else {
        tempHost=extraInfo;
      }
      setHost(tempHost);
    }
 catch (    Exception e) {
      System.out.println(""String_Node_Str"");
      ErrorDisplay.showErrorWindow(""String_Node_Str"",""String_Node_Str"" + extraInfo + ""String_Node_Str"",e);
      props.put(""String_Node_Str"",""String_Node_Str"");
      return;
    }
    username=username.substring(0,username.indexOf(""String_Node_Str""));
  }
  System.out.println(""String_Node_Str"" + username);
  props.put(""String_Node_Str"",username);
}",0.9922952875828704
