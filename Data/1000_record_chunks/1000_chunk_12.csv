record_number,buggy_code,fixed_code,code_similarity
11001,"public void setSvgElement(OMSVGSVGElement svgElement){
  this.svgElement=svgElement;
  Node firstChild=div.getFirstChild();
  Element svg=this.svgElement.getElement();
  if (firstChild == null) {
    div.appendChild(svg);
  }
 else   if (firstChild != svg) {
    div.replaceChild(svg,firstChild);
  }
}","public void setSvgElement(OMSVGSVGElement svgElement){
  this.svgElement=(OMSVGSVGElement)svgElement.cloneNode(true);
  Node firstChild=div.getFirstChild();
  Element svg=this.svgElement.getElement();
  if (firstChild == null) {
    div.appendChild(svg);
  }
 else   if (firstChild != svg) {
    div.replaceChild(svg,firstChild);
  }
}",0.9167974882260596
11002,"public void setSvgElement(OMSVGSVGElement svgElement){
  this.svgElement=(OMSVGSVGElement)svgElement.cloneNode(true);
  Node firstChild=div.getFirstChild();
  Element svg=this.svgElement.getElement();
  if (firstChild == null) {
    div.appendChild(svg);
  }
 else   if (firstChild != svg) {
    div.replaceChild(svg,firstChild);
  }
}","public void setSvgElement(OMSVGSVGElement svgElement){
  this.svgElement=svgElement;
  Node firstChild=div.getFirstChild();
  Element svg=this.svgElement.getElement();
  if (firstChild == null) {
    div.appendChild(svg);
  }
 else   if (firstChild != svg) {
    div.replaceChild(svg,firstChild);
  }
}",0.9167974882260596
11003,"/** 
 * Parse the supplied SVG text into a document
 * @param rawSvg raw xml to be parsed
 * @return the document resulting from the parse
 */
public static final OMSVGSVGElement parse(String rawSvg){
  SVGDocument doc=impl.parseFromString(rawSvg,""String_Node_Str"").cast();
  SVGSVGElement svg=DOMHelper.importNode(DOMHelper.getCurrentDocument(),doc.getDocumentElement(),true).cast();
  return new OMSVGSVGElement(svg);
}","/** 
 * Parse the supplied SVG text into a document
 * @param rawSvg raw xml to be parsed
 * @return the document resulting from the parse
 */
public static final OMSVGSVGElement parse(String rawSvg){
  SVGDocument doc=impl.parseFromString(rawSvg,""String_Node_Str"").cast();
  SVGSVGElement svg=DOMHelper.importNode(DOMHelper.getCurrentDocument(),doc.getDocumentElement(),true).cast();
  operaFix(svg);
  return new OMSVGSVGElement(svg);
}",0.980209545983702
11004,"private int popupExit(){
  int choix;
  choix=GUIUtilities.question_YES_NO(Utilities.getLangueMessage(Constantes.MESSAGE_FERMER_LOGICIEL));
  if (choix == JOptionPane.NO_OPTION)   choix=JOptionPane.CANCEL_OPTION;
  if (choix == JOptionPane.YES_OPTION) {
    if (this.fileName != null) {
      choix=GUIUtilities.question_YES_NO_CANCEL(Utilities.getLangueMessage(Constantes.MESSAGE_SAUVEGARDER_FICHIER_ENCOURS));
      if (choix == JOptionPane.YES_OPTION)       save();
    }
  }
  return choix;
}","private int popupExit(){
  int choix;
  choix=GUIUtilities.question_YES_NO(Utilities.getLangueMessage(Constantes.MESSAGE_FERMER_LOGICIEL));
  if (choix == JOptionPane.YES_OPTION) {
    if (this.fileName != null) {
      choix=GUIUtilities.question_YES_NO_CANCEL(Utilities.getLangueMessage(Constantes.MESSAGE_SAUVEGARDER_FICHIER_ENCOURS));
      if (choix == JOptionPane.YES_OPTION)       save();
    }
  }
 else {
    choix=JOptionPane.CANCEL_OPTION;
  }
  return choix;
}",0.4566115702479338
11005,"public static void show(Activity activity,JSONArray data){
  JSONObject dataObj=null;
  String text=""String_Node_Str"";
  try {
    dataObj=data.getJSONObject(0);
  }
 catch (  JSONException e) {
    dataObj=null;
  }
  if (dataObj != null) {
    if (dataObj.has(""String_Node_Str"")) {
      try {
        text=(String)dataObj.get(""String_Node_Str"");
      }
 catch (      JSONException e) {
      }
    }
  }
  final String labelText=text;
  final Activity _ctx=activity;
  if (!isVisible) {
    Log.i(""String_Node_Str"",""String_Node_Str"");
    activity.runOnUiThread(new Runnable(){
      public void run(){
        pd=ProgressDialog.show(_ctx,null,labelText,true,false);
      }
    }
);
    isVisible=true;
  }
}","public static void show(Activity activity,JSONArray data){
  JSONObject dataObj=null;
  String text=""String_Node_Str"";
  try {
    dataObj=data.getJSONObject(0);
  }
 catch (  JSONException e) {
    dataObj=null;
  }
  if (dataObj != null) {
    if (dataObj.has(""String_Node_Str"")) {
      Log.i(TAG,""String_Node_Str"");
      try {
        text=(String)dataObj.get(""String_Node_Str"");
      }
 catch (      JSONException e) {
      }
    }
 else     if (dataObj.has(""String_Node_Str"")) {
      try {
        text=(String)dataObj.get(""String_Node_Str"");
      }
 catch (      JSONException e) {
      }
    }
  }
  final String labelText=text;
  final Activity _ctx=activity;
  if (!isVisible) {
    Log.i(""String_Node_Str"",""String_Node_Str"");
    activity.runOnUiThread(new Runnable(){
      public void run(){
        pd=ProgressDialog.show(_ctx,null,labelText,true,false);
      }
    }
);
    isVisible=true;
  }
}",0.8748466257668711
11006,"public static void show(Activity activity,JSONArray data){
  JSONObject dataObj=null;
  String text=""String_Node_Str"";
  try {
    dataObj=data.getJSONObject(0);
  }
 catch (  JSONException e) {
    dataObj=null;
  }
  if (dataObj != null) {
    if (dataObj.has(""String_Node_Str"")) {
      try {
        text=(String)dataObj.get(""String_Node_Str"");
      }
 catch (      JSONException e) {
      }
    }
  }
  final String labelText=text;
  final Activity _ctx=activity;
  if (!isVisible) {
    Log.i(""String_Node_Str"",""String_Node_Str"");
    activity.runOnUiThread(new Runnable(){
      public void run(){
        pd=ProgressDialog.show(_ctx,null,labelText,true,false);
      }
    }
);
    isVisible=true;
  }
}","public static void show(Activity activity,JSONArray data){
  JSONObject dataObj=null;
  String text=""String_Node_Str"";
  try {
    dataObj=data.getJSONObject(0);
  }
 catch (  JSONException e) {
    dataObj=null;
  }
  if (dataObj != null) {
    if (dataObj.has(""String_Node_Str"")) {
      Log.i(TAG,""String_Node_Str"");
      try {
        text=(String)dataObj.get(""String_Node_Str"");
      }
 catch (      JSONException e) {
      }
    }
 else     if (dataObj.has(""String_Node_Str"")) {
      try {
        text=(String)dataObj.get(""String_Node_Str"");
      }
 catch (      JSONException e) {
      }
    }
  }
  final String labelText=text;
  final Activity _ctx=activity;
  if (!isVisible) {
    Log.i(""String_Node_Str"",""String_Node_Str"");
    activity.runOnUiThread(new Runnable(){
      public void run(){
        pd=ProgressDialog.show(_ctx,null,labelText,true,false);
      }
    }
);
    isVisible=true;
  }
}",0.8748466257668711
11007,"@Override public String getNodeName(){
  LOG.info(""String_Node_Str"");
  try {
    String jbossNodeName=System.getProperty(""String_Node_Str"");
    return jbossNodeName != null ? jbossNodeName : InetAddress.getLocalHost().getHostName();
  }
 catch (  UnknownHostException e) {
    throw new RuntimeException(e);
  }
}","public String getNodeName(){
  LOG.info(""String_Node_Str"");
  try {
    String jbossNodeName=System.getProperty(""String_Node_Str"");
    return jbossNodeName != null ? jbossNodeName : InetAddress.getLocalHost().getHostName();
  }
 catch (  UnknownHostException e) {
    throw new RuntimeException(e);
  }
}",0.9838709677419356
11008,"/** 
 * Swap the front and back buffers, giving access to the newly updated data for drawing
 */
private void swapBuffers(){
synchronized (pathBufferLock) {
    DoubleBuffer tmp=pathVertexFrontBuffer;
    pathVertexFrontBuffer=pathVertexBackBuffer;
    pathVertexBackBuffer=tmp;
    pathVertexFrontBuffer.rewind();
    tmp=pathColourFrontBuffer;
    pathColourFrontBuffer=pathColourBackBuffer;
    pathColourBackBuffer=tmp;
    pathColourFrontBuffer.rewind();
  }
}","/** 
 * Swap the front and back buffers, giving access to the newly updated data for drawing
 */
private void swapBuffers(){
synchronized (pathBufferLock) {
    DoubleBuffer tmp=pathVertexFrontBuffer;
    pathVertexFrontBuffer=pathVertexBackBuffer;
    pathVertexBackBuffer=tmp;
    pathVertexFrontBuffer.rewind();
    tmp=pathColourFrontBuffer;
    pathColourFrontBuffer=pathColourBackBuffer;
    pathColourBackBuffer=tmp;
    pathColourFrontBuffer.rewind();
    pathReferenceCenterFront=pathReferenceCenterBack;
  }
}",0.945121951219512
11009,"/** 
 * Populate the update vertex buffers with the coordinates of the eye location at each frame in the animation. <p/> Vertex buffer has size <code>3*animation.getlastFrame()</code>, with <code>[x,y,z]</code> stored at <code>[3*frame, 3*frame+1, 3*frame+2]</code> <p/> Colour buffer has size <code>3*animation.getLastFrame()</code> with colours ramping through the HSV colour space based on the rate of change of the camera eye position. Colours <code>[r,g,b]</code> are stored at <code>[3*frame, 3*frame+1, 3*frame+2]</code>.
 */
private void populatePathBuffers(){
  pathReferenceCenter=null;
  int firstFrame=animation.getFrameOfFirstKeyFrame();
  int lastFrame=animation.getFrameOfLastKeyFrame();
  double[] deltas=new double[lastFrame - firstFrame + 1];
  double minDelta=Double.MAX_VALUE;
  double maxDelta=0d;
  pathVertexBackBuffer.rewind();
  Position[] pathPositions=getPathPositions(firstFrame,lastFrame);
  Position previousPathPosition=null;
  for (int i=0; i < pathPositions.length; i++) {
    Position currentPathPosition=pathPositions[i];
    Vec4 eyeVector=animation.getView().getGlobe().computePointFromPosition(currentPathPosition);
    if (pathReferenceCenter == null) {
      pathReferenceCenter=eyeVector;
    }
    pathVertexBackBuffer.put(eyeVector.x - pathReferenceCenter.x);
    pathVertexBackBuffer.put(eyeVector.y - pathReferenceCenter.y);
    pathVertexBackBuffer.put(eyeVector.z - pathReferenceCenter.z);
    if (previousPathPosition != null) {
      double positionDelta=calculateDelta(currentPathPosition,previousPathPosition);
      deltas[i]=positionDelta;
      maxDelta=Math.max(maxDelta,positionDelta);
      minDelta=Math.min(minDelta,positionDelta);
    }
    previousPathPosition=currentPathPosition;
  }
  if (deltas.length > 1) {
    deltas[0]=deltas[1];
  }
  populatePathColourBufferFromDeltas(deltas,minDelta,maxDelta);
  pathVertexBackBuffer.rewind();
}","/** 
 * Populate the update vertex buffers with the coordinates of the eye location at each frame in the animation. <p/> Vertex buffer has size <code>3*animation.getlastFrame()</code>, with <code>[x,y,z]</code> stored at <code>[3*frame, 3*frame+1, 3*frame+2]</code> <p/> Colour buffer has size <code>3*animation.getLastFrame()</code> with colours ramping through the HSV colour space based on the rate of change of the camera eye position. Colours <code>[r,g,b]</code> are stored at <code>[3*frame, 3*frame+1, 3*frame+2]</code>.
 */
private void populatePathBuffers(){
  pathReferenceCenterBack=null;
  int firstFrame=animation.getFrameOfFirstKeyFrame();
  int lastFrame=animation.getFrameOfLastKeyFrame();
  double[] deltas=new double[lastFrame - firstFrame + 1];
  double minDelta=Double.MAX_VALUE;
  double maxDelta=0d;
  pathVertexBackBuffer.rewind();
  Position[] pathPositions=getPathPositions(firstFrame,lastFrame);
  Position previousPathPosition=null;
  for (int i=0; i < pathPositions.length; i++) {
    Position currentPathPosition=pathPositions[i];
    Vec4 eyeVector=animation.getView().getGlobe().computePointFromPosition(currentPathPosition);
    if (pathReferenceCenterBack == null) {
      pathReferenceCenterBack=eyeVector;
    }
    pathVertexBackBuffer.put(eyeVector.x - pathReferenceCenterBack.x);
    pathVertexBackBuffer.put(eyeVector.y - pathReferenceCenterBack.y);
    pathVertexBackBuffer.put(eyeVector.z - pathReferenceCenterBack.z);
    if (previousPathPosition != null) {
      double positionDelta=calculateDelta(currentPathPosition,previousPathPosition);
      deltas[i]=positionDelta;
      maxDelta=Math.max(maxDelta,positionDelta);
      minDelta=Math.min(minDelta,positionDelta);
    }
    previousPathPosition=currentPathPosition;
  }
  if (deltas.length > 1) {
    deltas[0]=deltas[1];
  }
  populatePathColourBufferFromDeltas(deltas,minDelta,maxDelta);
  pathVertexBackBuffer.rewind();
}",0.9937271301620492
11010,"/** 
 * Draw the camera path
 */
private void drawPath(DrawContext dc){
  if (frameCount <= 0 || dc.isPickingMode()) {
    return;
  }
  GL2 gl=dc.getGL().getGL2();
  OGLStackHandler stack=new OGLStackHandler();
  stack.pushAttrib(gl,GL2.GL_CURRENT_BIT | GL2.GL_POINT_BIT | GL2.GL_LINE_BIT| GL2.GL_HINT_BIT| GL2.GL_LIGHTING_BIT| GL2.GL_DEPTH_BUFFER_BIT);
  stack.pushClientAttrib(gl,GL2.GL_CLIENT_VERTEX_ARRAY_BIT);
  boolean popRefCenter=false;
  try {
synchronized (pathBufferLock) {
      if (pathReferenceCenter != null) {
        dc.getView().pushReferenceCenter(dc,pathReferenceCenter);
        popRefCenter=true;
      }
      gl.glEnableClientState(GL2.GL_VERTEX_ARRAY);
      gl.glEnableClientState(GL2.GL_COLOR_ARRAY);
      gl.glShadeModel(GL2.GL_SMOOTH);
      gl.glEnable(GL2.GL_LINE_SMOOTH);
      gl.glEnable(GL2.GL_POINT_SMOOTH);
      gl.glEnable(GL2.GL_BLEND);
      gl.glBlendFunc(GL2.GL_SRC_ALPHA,GL2.GL_ONE_MINUS_SRC_ALPHA);
      gl.glHint(GL2.GL_LINE_SMOOTH_HINT,GL2.GL_NICEST);
      gl.glHint(GL2.GL_POINT_SMOOTH_HINT,GL2.GL_NICEST);
      gl.glLineWidth(2.0f);
      gl.glPointSize(2.0f);
      int numberOfPointsInPath=animation.getFrameOfLastKeyFrame() - animation.getFrameOfFirstKeyFrame() + 1;
      if (numberOfPointsInPath <= 1) {
        return;
      }
      if (enableDepthTesting) {
        gl.glEnable(GL2.GL_DEPTH_TEST);
      }
 else {
        gl.glDisable(GL2.GL_DEPTH_TEST);
      }
      gl.glShadeModel(GL2.GL_FLAT);
      gl.glColorPointer(3,GL2.GL_DOUBLE,0,pathColourFrontBuffer);
      gl.glVertexPointer(3,GL2.GL_DOUBLE,0,pathVertexFrontBuffer);
      gl.glDepthMask(false);
      gl.glDrawArrays(GL2.GL_LINE_STRIP,0,numberOfPointsInPath);
      gl.glDrawArrays(GL2.GL_POINTS,0,numberOfPointsInPath);
      gl.glDepthMask(true);
      gl.glDrawArrays(GL2.GL_LINE_STRIP,0,numberOfPointsInPath);
    }
  }
  finally {
    if (popRefCenter) {
      dc.getView().popReferenceCenter(dc);
    }
    stack.pop(gl);
  }
}","/** 
 * Draw the camera path
 */
private void drawPath(DrawContext dc){
  if (frameCount <= 0 || dc.isPickingMode()) {
    return;
  }
  GL2 gl=dc.getGL().getGL2();
  OGLStackHandler stack=new OGLStackHandler();
  stack.pushAttrib(gl,GL2.GL_CURRENT_BIT | GL2.GL_POINT_BIT | GL2.GL_LINE_BIT| GL2.GL_HINT_BIT| GL2.GL_LIGHTING_BIT| GL2.GL_DEPTH_BUFFER_BIT);
  stack.pushClientAttrib(gl,GL2.GL_CLIENT_VERTEX_ARRAY_BIT);
  boolean popRefCenter=false;
  try {
synchronized (pathBufferLock) {
      if (pathReferenceCenterFront != null) {
        dc.getView().pushReferenceCenter(dc,pathReferenceCenterFront);
        popRefCenter=true;
      }
      gl.glEnableClientState(GL2.GL_VERTEX_ARRAY);
      gl.glEnableClientState(GL2.GL_COLOR_ARRAY);
      gl.glShadeModel(GL2.GL_SMOOTH);
      gl.glEnable(GL2.GL_LINE_SMOOTH);
      gl.glEnable(GL2.GL_POINT_SMOOTH);
      gl.glEnable(GL2.GL_BLEND);
      gl.glBlendFunc(GL2.GL_SRC_ALPHA,GL2.GL_ONE_MINUS_SRC_ALPHA);
      gl.glHint(GL2.GL_LINE_SMOOTH_HINT,GL2.GL_NICEST);
      gl.glHint(GL2.GL_POINT_SMOOTH_HINT,GL2.GL_NICEST);
      gl.glLineWidth(2.0f);
      gl.glPointSize(2.0f);
      int numberOfPointsInPath=animation.getFrameOfLastKeyFrame() - animation.getFrameOfFirstKeyFrame() + 1;
      if (numberOfPointsInPath <= 1) {
        return;
      }
      if (enableDepthTesting) {
        gl.glEnable(GL2.GL_DEPTH_TEST);
      }
 else {
        gl.glDisable(GL2.GL_DEPTH_TEST);
      }
      gl.glShadeModel(GL2.GL_FLAT);
      gl.glColorPointer(3,GL2.GL_DOUBLE,0,pathColourFrontBuffer);
      gl.glVertexPointer(3,GL2.GL_DOUBLE,0,pathVertexFrontBuffer);
      gl.glDepthMask(false);
      gl.glDrawArrays(GL2.GL_LINE_STRIP,0,numberOfPointsInPath);
      gl.glDrawArrays(GL2.GL_POINTS,0,numberOfPointsInPath);
      gl.glDepthMask(true);
      gl.glDrawArrays(GL2.GL_LINE_STRIP,0,numberOfPointsInPath);
    }
  }
  finally {
    if (popRefCenter) {
      dc.getView().popReferenceCenter(dc);
    }
    stack.pop(gl);
  }
}",0.9974554707379136
11011,"private void validateProperties(){
  Validate.isTrue(esize == 4,""String_Node_Str"" + esize);
  Validate.isTrue(""String_Node_Str"".equals(format),""String_Node_Str"" + format);
  Validate.isTrue(""String_Node_Str"".equals(etype) || ""String_Node_Str"".equals(etype),""String_Node_Str"" + etype);
}","private void validateProperties(){
  Validate.isTrue(""String_Node_Str"".equals(format),""String_Node_Str"" + format);
  Validate.isTrue(""String_Node_Str"".equals(etype) || ""String_Node_Str"".equals(etype),""String_Node_Str"" + etype);
}",0.8893203883495145
11012,"@Override public FastShape end(URL context){
  validateProperties();
  if (axisN == null) {
    if (axisD == null || axisMIN == null || axisMAX == null) {
      return null;
    }
    double nx=(axisMAX.x - axisMIN.x) / axisD.x + 1;
    double ny=(axisMAX.y - axisMIN.y) / axisD.y + 1;
    double nz=(axisMAX.z - axisMIN.z) / axisD.z + 1;
    axisN=new Vec4(nx,ny,nz);
  }
  Vec4 axisUStride=axisU.multiply3((axisMAX.x - axisMIN.x) / (axisN.x - 1));
  Vec4 axisVStride=axisV.multiply3((axisMAX.y - axisMIN.y) / (axisN.y - 1));
  Vec4 axisWStride=axisW.multiply3((axisMAX.z - axisMIN.z) / (axisN.z - 1));
  Vec4 origin=calculateAxisOrigin();
  int[] strides=calculateStrides();
  long[] axisN=calculateAxisN();
  int[] samples=calculateSamples(strides,axisN);
  List<Position> positions=new ArrayList<Position>();
  float[] values=createValuesArray(samples);
  double[] transformed=new double[3];
  float[] minmax=new float[]{Float.MAX_VALUE,-Float.MAX_VALUE};
  try {
    URL fileUrl=new URL(context,file);
    InputStream is=new BufferedInputStream(fileUrl.openStream());
    FloatReader reader=FloatReader.Builder.newFloatReaderForStream(is).withOffset(offset).withFormat(FloatFormat.valueOf(etype)).withByteOrder(parameters.getByteOrder()).build();
    float[] floatValue=new float[1];
    if (parameters.isBilinearMinification()) {
      int[] count=new int[values.length];
      for (int w=0; w < axisN[W]; w++) {
        int wRegion=(w / strides[W]) * samples[V] * samples[U];
        for (int v=0; v < axisN[V]; v++) {
          int vRegion=(v / strides[V]) * samples[U];
          for (int u=0; u < axisN[U]; u++) {
            reader.readNextValues(floatValue);
            if (!Float.isNaN(floatValue[0]) && floatValue[0] != noDataValue) {
              int uRegion=(u / strides[U]);
              int valueIndex=wRegion + vRegion + uRegion;
              if (count[valueIndex] == 0) {
                values[valueIndex]=floatValue[0];
              }
 else {
                values[valueIndex]+=floatValue[0];
              }
              count[valueIndex]++;
            }
          }
        }
      }
      normaliseValues(values,minmax,count);
      for (int w=0, wi=0; w < axisN[W]; w+=strides[W], wi++) {
        int wOffset=wi * samples[V] * samples[U];
        Vec4 wAdd=axisWStride.multiply3(w);
        for (int v=0, vi=0; v < axisN[V]; v+=strides[V], vi++) {
          int vOffset=vi * samples[U];
          Vec4 vAdd=axisVStride.multiply3(v);
          for (int u=0, ui=0; u < axisN[U]; u+=strides[U], ui++) {
            int uOffset=ui;
            int valueIndex=wOffset + vOffset + uOffset;
            float value=values[valueIndex];
            if (!Float.isNaN(value)) {
              Vec4 uAdd=axisUStride.multiply3(u);
              Vec4 point=new Vec4(origin.x + uAdd.x + vAdd.x+ wAdd.x,origin.y + uAdd.y + vAdd.y+ wAdd.y,origin.z + uAdd.z + vAdd.z+ wAdd.z);
              positions.add(createPositionFromPoint(transformed,point));
            }
          }
        }
      }
    }
 else {
      int valueIndex=0;
      for (int w=0; w < axisN[W]; w+=strides[W]) {
        Vec4 wAdd=axisWStride.multiply3(w);
        for (int v=0; v < axisN[V]; v+=strides[V]) {
          Vec4 vAdd=axisVStride.multiply3(v);
          for (int u=0; u < axisN[U]; u+=strides[U]) {
            reader.readNextValues(floatValue);
            if (!Float.isNaN(floatValue[0]) && floatValue[0] != noDataValue) {
              values[valueIndex]=floatValue[0];
              minmax[0]=Math.min(minmax[0],floatValue[0]);
              minmax[1]=Math.max(minmax[1],floatValue[0]);
              Vec4 uAdd=axisUStride.multiply3(u);
              Vec4 point=new Vec4(origin.x + uAdd.x + vAdd.x+ wAdd.x,origin.y + uAdd.y + vAdd.y+ wAdd.y,origin.z + uAdd.z + vAdd.z+ wAdd.z);
              positions.add(createPositionFromPoint(transformed,point));
            }
            valueIndex++;
            reader.skip(esize * Math.min(strides[U] - 1,axisN[U] - u - 1));
          }
          reader.skip(esize * axisN[U] * Math.min(strides[V] - 1,axisN[V] - v - 1));
        }
        reader.skip(esize * axisN[U] * axisN[V]* Math.min(strides[W] - 1,axisN[W] - w - 1));
      }
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
    return null;
  }
  FloatBuffer colorBuffer=createColorBuffer(values,minmax);
  if (name == null) {
    name=""String_Node_Str"";
  }
  FastShape shape=new FastShape(positions,GL2.GL_POINTS);
  shape.setName(name);
  shape.setColorBuffer(colorBuffer.array());
  shape.setColorBufferElementSize(4);
  shape.setForceSortedPrimitives(true);
  shape.setFollowTerrain(true);
  return shape;
}","@Override public FastShape end(URL context){
  validateProperties();
  if (axisN == null) {
    if (axisD == null || axisMIN == null || axisMAX == null) {
      return null;
    }
    double nx=(axisMAX.x - axisMIN.x) / axisD.x + 1;
    double ny=(axisMAX.y - axisMIN.y) / axisD.y + 1;
    double nz=(axisMAX.z - axisMIN.z) / axisD.z + 1;
    axisN=new Vec4(nx,ny,nz);
  }
  Vec4 axisUStride=axisU.multiply3((axisMAX.x - axisMIN.x) / (axisN.x > 1 ? axisN.x - 1 : 1));
  Vec4 axisVStride=axisV.multiply3((axisMAX.y - axisMIN.y) / (axisN.y > 1 ? axisN.y - 1 : 1));
  Vec4 axisWStride=axisW.multiply3((axisMAX.z - axisMIN.z) / (axisN.z > 1 ? axisN.z - 1 : 1));
  Vec4 origin=calculateAxisOrigin();
  int[] strides=calculateStrides();
  long[] axisN=calculateAxisN();
  int[] samples=calculateSamples(strides,axisN);
  List<Position> positions=new ArrayList<Position>();
  float[] values=createValuesArray(samples);
  double[] transformed=new double[3];
  float[] minmax=new float[]{Float.MAX_VALUE,-Float.MAX_VALUE};
  try {
    URL fileUrl=new URL(context,file);
    InputStream is=new BufferedInputStream(fileUrl.openStream());
    FloatReader reader=FloatReader.Builder.newFloatReaderForStream(is).withOffset(offset).withFormat(FloatFormat.valueOf(etype)).withByteOrder(parameters.getByteOrder()).build();
    float[] floatValue=new float[1];
    if (parameters.isBilinearMinification()) {
      int[] count=new int[values.length];
      for (int w=0; w < axisN[W]; w++) {
        int wRegion=(w / strides[W]) * samples[V] * samples[U];
        for (int v=0; v < axisN[V]; v++) {
          int vRegion=(v / strides[V]) * samples[U];
          for (int u=0; u < axisN[U]; u++) {
            reader.readNextValues(floatValue);
            if (!Float.isNaN(floatValue[0]) && floatValue[0] != noDataValue) {
              int uRegion=(u / strides[U]);
              int valueIndex=wRegion + vRegion + uRegion;
              if (count[valueIndex] == 0) {
                values[valueIndex]=floatValue[0];
              }
 else {
                values[valueIndex]+=floatValue[0];
              }
              count[valueIndex]++;
            }
          }
        }
      }
      normaliseValues(values,minmax,count);
      for (int w=0, wi=0; w < axisN[W]; w+=strides[W], wi++) {
        int wOffset=wi * samples[V] * samples[U];
        Vec4 wAdd=axisWStride.multiply3(w);
        for (int v=0, vi=0; v < axisN[V]; v+=strides[V], vi++) {
          int vOffset=vi * samples[U];
          Vec4 vAdd=axisVStride.multiply3(v);
          for (int u=0, ui=0; u < axisN[U]; u+=strides[U], ui++) {
            int uOffset=ui;
            int valueIndex=wOffset + vOffset + uOffset;
            float value=values[valueIndex];
            if (!Float.isNaN(value)) {
              Vec4 uAdd=axisUStride.multiply3(u);
              Vec4 point=new Vec4(origin.x + uAdd.x + vAdd.x+ wAdd.x,origin.y + uAdd.y + vAdd.y+ wAdd.y,origin.z + uAdd.z + vAdd.z+ wAdd.z);
              positions.add(createPositionFromPoint(transformed,point));
            }
          }
        }
      }
    }
 else {
      int valueIndex=0;
      for (int w=0; w < axisN[W]; w+=strides[W]) {
        Vec4 wAdd=axisWStride.multiply3(w);
        for (int v=0; v < axisN[V]; v+=strides[V]) {
          Vec4 vAdd=axisVStride.multiply3(v);
          for (int u=0; u < axisN[U]; u+=strides[U]) {
            reader.readNextValues(floatValue);
            if (!Float.isNaN(floatValue[0]) && floatValue[0] != noDataValue) {
              values[valueIndex]=floatValue[0];
              minmax[0]=Math.min(minmax[0],floatValue[0]);
              minmax[1]=Math.max(minmax[1],floatValue[0]);
              Vec4 uAdd=axisUStride.multiply3(u);
              Vec4 point=new Vec4(origin.x + uAdd.x + vAdd.x+ wAdd.x,origin.y + uAdd.y + vAdd.y+ wAdd.y,origin.z + uAdd.z + vAdd.z+ wAdd.z);
              positions.add(createPositionFromPoint(transformed,point));
            }
            valueIndex++;
            reader.skip(esize * Math.min(strides[U] - 1,axisN[U] - u - 1));
          }
          reader.skip(esize * axisN[U] * Math.min(strides[V] - 1,axisN[V] - v - 1));
        }
        reader.skip(esize * axisN[U] * axisN[V]* Math.min(strides[W] - 1,axisN[W] - w - 1));
      }
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
    return null;
  }
  FloatBuffer colorBuffer=createColorBuffer(values,minmax);
  if (name == null) {
    name=""String_Node_Str"";
  }
  FastShape shape=new FastShape(positions,GL2.GL_POINTS);
  shape.setName(name);
  shape.setColorBuffer(colorBuffer.array());
  shape.setColorBufferElementSize(4);
  shape.setForceSortedPrimitives(true);
  shape.setFollowTerrain(true);
  return shape;
}",0.9941947968178886
11013,"/** 
 * Add a hole to the current shape. The hole must be fully within both the current shape and this tile's sector.
 * @param points Points involved in the hole
 * @param attributes Shape attributes
 */
public void addHole(List<Coordinate> points,Attributes attributes){
  if (current == null)   throw new IllegalStateException(""String_Node_Str"" + this + ""String_Node_Str"");
  TileRecord hole=new TileRecord(-1,false,attributes,points);
  current.holes.add(hole);
}","/** 
 * Add a hole to the current shape. The hole must be fully within both the current shape and this tile's sector.
 * @param points Points involved in the hole
 * @param attributes Shape attributes
 */
public void addHole(List<Coordinate> points,Attributes attributes){
  if (current == null && !filled)   throw new IllegalStateException(""String_Node_Str"" + this + ""String_Node_Str"");
  TileRecord hole=new TileRecord(-1,false,attributes,points);
  if (current != null)   current.holes.add(hole);
 else   filledHoles.add(hole);
}",0.934934934934935
11014,"/** 
 * Join any exits to their neighbouring entries, moving clockwise around the sector. If an exit is on a different side to it's corresponding entry, add the sector corner points between the two points when joining.
 */
public void completePolygons(){
  Map<EntryExit,TileRecord> pointMap=new HashMap<EntryExit,TileRecord>();
  Map<TileRecord,EntryExit> reverseExitMap=new HashMap<TileRecord,EntryExit>();
  List<EntryExit> entryExits=new ArrayList<EntryExit>();
  List<EntryExit> entries=new ArrayList<EntryExit>();
  List<EntryExit> exits=new ArrayList<EntryExit>();
  for (  TileRecord r : records) {
    if (r.entered && r.exited) {
      Coordinate en=r.coordinates.get(0);
      Coordinate ex=r.coordinates.get(r.coordinates.size() - 1);
      EntryExit entry=new EntryExit(en,centroid,true);
      EntryExit exit=new EntryExit(ex,centroid,false);
      pointMap.put(entry,r);
      pointMap.put(exit,r);
      reverseExitMap.put(r,exit);
      entryExits.add(entry);
      entryExits.add(exit);
      entries.add(entry);
      exits.add(exit);
    }
  }
  if (entries.size() != exits.size())   throw new IllegalStateException(""String_Node_Str"");
  if (entries.isEmpty()) {
    if (filled) {
      fillSector();
    }
    return;
  }
  Collections.sort(entryExits);
  Collections.sort(entries);
  Collections.sort(exits);
  int offset=0;
  EntryExit previous=entryExits.get(entryExits.size() - 2);
  EntryExit current=entryExits.get(entryExits.size() - 1);
  for (int i=0; i < entryExits.size(); i++) {
    EntryExit next=entryExits.get(i);
    if (current.isExit() && next.isEntry() && !current.coordinate.equals(next.coordinate)&& !(previous.isEntry() && current.coordinate.equals(previous.coordinate))) {
      offset=entries.indexOf(next) - exits.indexOf(current);
      break;
    }
    previous=current;
    current=next;
  }
  for (int i=0; i < entries.size(); i++) {
    EntryExit exit=exits.get(i);
    EntryExit entry=entries.get((i + offset + entries.size()) % entries.size());
    TileRecord exitRecord=pointMap.remove(exit);
    TileRecord entryRecord=pointMap.remove(entry);
    addCornerPoints(exitRecord,entry.coordinate,exit.coordinate);
    if (exitRecord == entryRecord) {
    }
 else {
      exitRecord.coordinates.addAll(entryRecord.coordinates);
      records.remove(entryRecord);
      EntryExit entrysExit=reverseExitMap.get(entryRecord);
      pointMap.put(entrysExit,exitRecord);
      reverseExitMap.put(exitRecord,entrysExit);
    }
  }
}","/** 
 * Join any exits to their neighbouring entries, moving clockwise around the sector. If an exit is on a different side to it's corresponding entry, add the sector corner points between the two points when joining.
 */
public void completePolygons(){
  Map<EntryExit,TileRecord> pointMap=new HashMap<EntryExit,TileRecord>();
  Map<TileRecord,EntryExit> reverseExitMap=new HashMap<TileRecord,EntryExit>();
  List<EntryExit> entryExits=new ArrayList<EntryExit>();
  List<EntryExit> entries=new ArrayList<EntryExit>();
  List<EntryExit> exits=new ArrayList<EntryExit>();
  for (  TileRecord r : records) {
    if (r.entered && r.exited) {
      Coordinate en=r.coordinates.get(0);
      Coordinate ex=r.coordinates.get(r.coordinates.size() - 1);
      EntryExit entry=new EntryExit(en,centroid,true);
      EntryExit exit=new EntryExit(ex,centroid,false);
      pointMap.put(entry,r);
      pointMap.put(exit,r);
      reverseExitMap.put(r,exit);
      entryExits.add(entry);
      entryExits.add(exit);
      entries.add(entry);
      exits.add(exit);
    }
  }
  if (entries.size() != exits.size())   throw new IllegalStateException(""String_Node_Str"");
  if (entries.isEmpty()) {
    if (filled) {
      fillSector();
    }
    return;
  }
  Collections.sort(entryExits);
  Collections.sort(entries);
  Collections.sort(exits);
  int offset=0;
  EntryExit previous=entryExits.get(entryExits.size() - 2);
  EntryExit current=entryExits.get(entryExits.size() - 1);
  for (int i=0; i < entryExits.size(); i++) {
    EntryExit next=entryExits.get(i);
    if (current.isExit() && next.isEntry() && !current.coordinate.equals(next.coordinate)&& !(previous.isEntry() && current.coordinate.equals(previous.coordinate))) {
      offset=entries.indexOf(next) - exits.indexOf(current);
      break;
    }
    previous=current;
    current=next;
  }
  TileRecord exitRecord=null;
  for (int i=0; i < entries.size(); i++) {
    EntryExit exit=exits.get(i);
    EntryExit entry=entries.get((i + offset + entries.size()) % entries.size());
    exitRecord=pointMap.remove(exit);
    TileRecord entryRecord=pointMap.remove(entry);
    addCornerPoints(exitRecord,entry.coordinate,exit.coordinate);
    if (exitRecord == entryRecord) {
    }
 else {
      exitRecord.coordinates.addAll(entryRecord.coordinates);
      exitRecord.holes.addAll(entryRecord.holes);
      records.remove(entryRecord);
      EntryExit entrysExit=reverseExitMap.get(entryRecord);
      pointMap.put(entrysExit,exitRecord);
      reverseExitMap.put(exitRecord,entrysExit);
    }
  }
  exitRecord.holes.addAll(filledHoles);
}",0.8207155564340779
11015,"/** 
 * Fill the tile's sector with a square polygon.
 */
protected void fillSector(){
  TileRecord current=new TileRecord(-1,false,filledAttributes);
  records.add(current);
  current.exited=false;
  for (  Coordinate c : clockwise)   current.coordinates.add(c);
}","/** 
 * Fill the tile's sector with a square polygon.
 */
protected void fillSector(){
  TileRecord record=new TileRecord(-1,false,filledAttributes);
  records.add(record);
  record.exited=false;
  for (  Coordinate c : clockwise)   record.coordinates.add(c);
  record.holes.addAll(filledHoles);
}",0.7615658362989324
11016,"@Override public boolean buildVerts(DrawContext dc,RectTile tile,boolean makeSkirts){
  ((RowColRectTile)tile).rebuiltVertices=true;
  return super.buildVerts(dc,tile,false);
}","@Override public boolean buildVerts(DrawContext dc,RectTile tile,boolean makeSkirts){
  ((RowColRectTile)tile).rebuiltVertices=true;
  return super.buildVerts(dc,tile,makeSkirts);
}",0.969187675070028
11017,"@Override public void renderTiles(DrawContext dc,Iterable<? extends SurfaceTile> tiles){
  ExtendedDrawContext.applyWireframePolygonMode(dc);
  if (ignoreElevation && dc instanceof ExtendedDrawContext) {
    try {
      ((ExtendedDrawContext)dc).switchToFlatSurfaceGeometry();
      super.renderTiles(dc,tiles);
    }
  finally {
      ((ExtendedDrawContext)dc).switchToStandardSurfaceGeometry();
    }
  }
 else {
    super.renderTiles(dc,tiles);
  }
}","@Override public synchronized void renderTiles(DrawContext dc,Iterable<? extends SurfaceTile> tiles){
  ExtendedDrawContext.applyWireframePolygonMode(dc);
  if (ignoreElevation && dc instanceof ExtendedDrawContext) {
    try {
      ((ExtendedDrawContext)dc).switchToFlatSurfaceGeometry();
      super.renderTiles(dc,tiles);
    }
  finally {
      ((ExtendedDrawContext)dc).switchToStandardSurfaceGeometry();
    }
  }
 else {
    super.renderTiles(dc,tiles);
  }
}",0.985854189336235
11018,"@Override public SectorGeometryList tessellate(DrawContext dc){
  SectorGeometryList currentTiles=super.tessellate(dc);
  if (isMakeTileSkirts() && smartSkirts) {
    Map<RectTileKey,RowColRectTile> tileMap=new HashMap<RectTileKey,RowColRectTile>();
    for (    SectorGeometry t : currentTiles) {
      RowColRectTile tile=(RowColRectTile)t;
      RectTileKey tileKey=new RectTileKey(tile.getLevel(),tile.getRow(),tile.getColumn());
      tileMap.put(tileKey,tile);
    }
    for (    SectorGeometry tile : currentTiles) {
      fixSkirts(dc,(RowColRectTile)tile,tileMap);
    }
  }
  return currentTiles;
}","@Override public synchronized SectorGeometryList tessellate(DrawContext dc){
  SectorGeometryList currentTiles=super.tessellate(dc);
  if (isMakeTileSkirts() && smartSkirts) {
    Map<RectTileKey,RowColRectTile> tileMap=new HashMap<RectTileKey,RowColRectTile>();
    for (    SectorGeometry t : currentTiles) {
      RowColRectTile tile=(RowColRectTile)t;
      RectTileKey tileKey=new RectTileKey(tile.getLevel(),tile.getRow(),tile.getColumn());
      tileMap.put(tileKey,tile);
    }
    for (    SectorGeometry tile : currentTiles) {
      fixSkirts(dc,(RowColRectTile)tile,tileMap);
    }
  }
  return currentTiles;
}",0.9894222945484134
11019,"public ExtendedSceneController(){
  dc.dispose();
  VerticalExaggerationService.INSTANCE.addListener(this);
  setVerticalExaggeration(VerticalExaggerationService.INSTANCE.get());
}","public ExtendedSceneController(){
  dc=wrapDrawContext(dc);
  VerticalExaggerationService.INSTANCE.addListener(this);
  setVerticalExaggeration(VerticalExaggerationService.INSTANCE.get());
}",0.9297297297297298
11020,"public void doSetFullscreen(final boolean fullscreen){
  if (fullscreen != isFullscreen()) {
    this.fullscreen=fullscreen;
    if (!fullscreen) {
      splitPane.setRightComponent(wwdCanvas);
      frame.setBounds(Settings.get().getWindowBounds());
      if (Settings.get().isWindowMaximized()) {
        frame.setExtendedState(JFrame.MAXIMIZED_BOTH);
      }
      loadSplitLocation();
      fullscreenFrame.dispose();
      fullscreenFrame=null;
    }
 else {
      fullscreenFrame=new JFrame(frame.getTitle());
      fullscreenFrame.setIconImage(frame.getIconImage());
      fullscreenFrame.setUndecorated(true);
      fullscreenFrame.setAlwaysOnTop(true);
      JPanel fullscreenPanel=new JPanel(new BorderLayout());
      fullscreenFrame.setContentPane(fullscreenPanel);
      fullscreenPanel.add(wwdCanvas,BorderLayout.CENTER);
      fullscreenFrame.setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE);
      fullscreenFrame.addWindowListener(new WindowAdapter(){
        @Override public void windowClosing(        WindowEvent e){
          setFullscreen(false);
        }
      }
);
      Action action=new AbstractAction(){
        @Override public void actionPerformed(        ActionEvent e){
          setFullscreen(false);
        }
      }
;
      fullscreenPanel.getInputMap(JComponent.WHEN_IN_FOCUSED_WINDOW).put(KeyStroke.getKeyStroke(KeyEvent.VK_ESCAPE,0),action);
      fullscreenPanel.getActionMap().put(action,action);
      boolean span=Settings.get().isSpanDisplays();
      String id=Settings.get().getDisplayId();
      GraphicsEnvironment ge=GraphicsEnvironment.getLocalGraphicsEnvironment();
      Rectangle fullscreenBounds;
      Rectangle frameBounds=frame.getBounds();
      int splitLocation=Settings.get().getSplitLocation();
      frameBounds.width=splitLocation + 10;
      if (span) {
        Rectangle fullBounds=new Rectangle();
        GraphicsDevice[] gds=ge.getScreenDevices();
        for (        GraphicsDevice g : gds) {
          GraphicsConfiguration gc=g.getDefaultConfiguration();
          fullBounds=fullBounds.union(gc.getBounds());
        }
        fullscreenBounds=fullBounds;
      }
 else {
        GraphicsDevice fullscreenDevice=getGraphicsDeviceForId(id,ge);
        fullscreenBounds=fullscreenDevice.getDefaultConfiguration().getBounds();
        GraphicsDevice frameDevice=getGraphicsDeviceContainingBounds(frameBounds,ge);
        if (frameDevice == fullscreenDevice) {
          GraphicsDevice otherDevice=getOtherGraphicsDevice(fullscreenDevice,ge);
          if (otherDevice != null) {
            Rectangle otherDeviceBounds=otherDevice.getDefaultConfiguration().getBounds();
            frameBounds.setLocation(otherDeviceBounds.getLocation());
          }
        }
      }
      frame.setExtendedState(JFrame.NORMAL);
      frame.setBounds(frameBounds);
      fullscreenFrame.setBounds(fullscreenBounds);
      fullscreenFrame.setVisible(true);
    }
  }
}","public void doSetFullscreen(final boolean fullscreen){
  if (fullscreen != isFullscreen()) {
    this.fullscreen=fullscreen;
    wwdCanvas.getParent().remove(wwdCanvas);
    if (!fullscreen) {
      splitPane.setRightComponent(wwdCanvas);
      frame.setBounds(Settings.get().getWindowBounds());
      if (Settings.get().isWindowMaximized()) {
        frame.setExtendedState(JFrame.MAXIMIZED_BOTH);
      }
      loadSplitLocation();
      fullscreenFrame.dispose();
      fullscreenFrame=null;
    }
 else {
      fullscreenFrame=new JFrame(frame.getTitle());
      fullscreenFrame.setIconImage(frame.getIconImage());
      fullscreenFrame.setUndecorated(true);
      fullscreenFrame.setAlwaysOnTop(true);
      JPanel fullscreenPanel=new JPanel(new BorderLayout());
      fullscreenFrame.setContentPane(fullscreenPanel);
      fullscreenPanel.add(wwdCanvas,BorderLayout.CENTER);
      fullscreenFrame.setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE);
      fullscreenFrame.addWindowListener(new WindowAdapter(){
        @Override public void windowClosing(        WindowEvent e){
          setFullscreen(false);
        }
      }
);
      Action action=new AbstractAction(){
        @Override public void actionPerformed(        ActionEvent e){
          setFullscreen(false);
        }
      }
;
      fullscreenPanel.getInputMap(JComponent.WHEN_IN_FOCUSED_WINDOW).put(KeyStroke.getKeyStroke(KeyEvent.VK_ESCAPE,0),action);
      fullscreenPanel.getActionMap().put(action,action);
      boolean span=Settings.get().isSpanDisplays();
      String id=Settings.get().getDisplayId();
      GraphicsEnvironment ge=GraphicsEnvironment.getLocalGraphicsEnvironment();
      Rectangle fullscreenBounds;
      Rectangle frameBounds=frame.getBounds();
      int splitLocation=Settings.get().getSplitLocation();
      frameBounds.width=splitLocation + 10;
      if (span) {
        Rectangle fullBounds=new Rectangle();
        GraphicsDevice[] gds=ge.getScreenDevices();
        for (        GraphicsDevice g : gds) {
          GraphicsConfiguration gc=g.getDefaultConfiguration();
          fullBounds=fullBounds.union(gc.getBounds());
        }
        fullscreenBounds=fullBounds;
      }
 else {
        GraphicsDevice fullscreenDevice=getGraphicsDeviceForId(id,ge);
        fullscreenBounds=fullscreenDevice.getDefaultConfiguration().getBounds();
        GraphicsDevice frameDevice=getGraphicsDeviceContainingBounds(frameBounds,ge);
        if (frameDevice == fullscreenDevice) {
          GraphicsDevice otherDevice=getOtherGraphicsDevice(fullscreenDevice,ge);
          if (otherDevice != null) {
            Rectangle otherDeviceBounds=otherDevice.getDefaultConfiguration().getBounds();
            frameBounds.setLocation(otherDeviceBounds.getLocation());
          }
        }
      }
      frame.setExtendedState(JFrame.NORMAL);
      frame.setBounds(frameBounds);
      fullscreenFrame.setBounds(fullscreenBounds);
      fullscreenFrame.setVisible(true);
    }
  }
}",0.9923741738688358
11021,"private Application(Theme theme,boolean showSplashScreen,boolean useNewt){
  this.theme=theme;
  Settings.get().loadThemeProperties(theme);
  String title=getMessage(getApplicationTitleKey());
  if (theme.getName() != null && theme.getName().length() > 0) {
    title+=""String_Node_Str"" + theme.getName();
  }
  frame=new JFrame(title);
  frame.setIconImage(Icons.earth32.getIcon().getImage());
  final SplashScreen splashScreen=showSplashScreen ? new SplashScreen(null,SplashScreen.class.getResource(""String_Node_Str"")) : null;
  if (Settings.get().isHardwareStereoEnabled()) {
    System.setProperty(AVKey.STEREO_MODE,""String_Node_Str"");
  }
  if (useNewt) {
    Configuration.setValue(AVKey.WORLD_WINDOW_CLASS_NAME,WorldWindowNewtAutoDrawable.class.getName());
    Configuration.setValue(AVKey.INPUT_HANDLER_CLASS_NAME,NewtInputHandler.class.getName());
    wwd=new WorldWindowNewtCanvas();
  }
 else {
    wwd=new WorldWindowGLCanvas();
  }
  wwdCanvas=(Canvas)wwd;
  wwdCanvas.setMinimumSize(new Dimension(1,1));
  if (splashScreen != null) {
    splashScreen.addRenderingListener(wwd);
  }
  Model model=(Model)WorldWind.createConfigurationComponent(AVKey.MODEL_CLASS_NAME);
  model.setLayers(new SectionListLayerList());
  model.getGlobe().setElevationModel(new SectionListCompoundElevationModel());
  wwd.setModel(model);
  wwd.addSelectListener(new ClickAndGoSelectListener(wwd,WorldMapLayer.class));
  create3DMouse();
  createDoubleClickListener();
  wwd.addRenderingExceptionListener(new RenderingExceptionListener(){
    @Override public void exceptionThrown(    Throwable t){
      if (t instanceof WWAbsentRequirementException) {
        String title=getMessage(getVideocardFailureTitleKey());
        String message=getMessage(getVideocardFailureMessageKey(),t.getMessage());
        JOptionPane.showMessageDialog(frame,message,title,JOptionPane.ERROR_MESSAGE);
        System.exit(-1);
      }
    }
  }
);
  RetrievalService rs=WorldWind.getRetrievalService();
  if (rs instanceof ExtendedRetrievalService) {
    PolylineLayerRetrievalListener layer=new PolylineLayerRetrievalListener();
    model.getLayers().add(layer);
    ((ExtendedRetrievalService)rs).addRetrievalListener(layer);
  }
  ToolTipManager.sharedInstance().setLightWeightPopupEnabled(false);
  JPopupMenu.setDefaultLightWeightPopupEnabled(false);
  JPanel panel=new JPanel(new BorderLayout());
  frame.setContentPane(panel);
  frame.setBounds(Settings.get().getWindowBounds());
  if (!fullscreen && Settings.get().isWindowMaximized()) {
    frame.setExtendedState(JFrame.MAXIMIZED_BOTH);
  }
  splitPane=new JSplitPane(JSplitPane.HORIZONTAL_SPLIT,true);
  panel.add(splitPane,BorderLayout.CENTER);
  if (!fullscreen) {
    splitPane.setRightComponent(wwdCanvas);
  }
  splitPane.setOneTouchExpandable(true);
  loadSplitLocation();
  boolean anyPanels=!theme.getPanels().isEmpty() && theme.hasSideBar();
  if (anyPanels) {
    sideBar=new SideBar(theme,splitPane);
    splitPane.setLeftComponent(sideBar);
  }
  if (!anyPanels || fullscreen) {
    splitPane.setDividerSize(0);
  }
  if (theme.hasStatusBar()) {
    statusBar=new DownloaderStatusBar();
    panel.add(statusBar,BorderLayout.PAGE_END);
    statusBar.setEventSource(wwd);
    statusBar.setBorder(BorderFactory.createLoweredBevelBorder());
  }
  theme.setup(frame,wwd);
  if (!theme.getLayers().isEmpty() && !theme.hasThemeLayersPanel()) {
    List<ILayerNode> nodes=new ArrayList<ILayerNode>();
    for (    ThemeLayer layer : theme.getLayers()) {
      nodes.add(LayerNode.createFromLayerDefinition(layer));
    }
    LayerEnabler enabler=new LayerEnabler(theme.getLayersPanel().getTree(),wwd);
    enabler.enable(nodes);
  }
  afterSettingsChange();
  createActions();
  createThemeListeners();
  if (theme.hasMenuBar()) {
    menuBar=createMenuBar();
    frame.setJMenuBar(menuBar);
  }
  if (theme.hasToolBar()) {
    toolBar=createToolBar();
    panel.add(toolBar,BorderLayout.PAGE_START);
  }
  addWindowListeners();
  try {
    SwingUtil.invokeLaterTaskOnEDT(new Runnable(){
      @Override public void run(){
        frame.setVisible(true);
        wwdCanvas.createBufferStrategy(2);
      }
    }
);
  }
 catch (  Exception e) {
  }
}","private Application(Theme theme,boolean showSplashScreen,boolean useNewt){
  this.theme=theme;
  Settings.get().loadThemeProperties(theme);
  String title=getMessage(getApplicationTitleKey());
  if (theme.getName() != null && theme.getName().length() > 0) {
    title+=""String_Node_Str"" + theme.getName();
  }
  frame=new JFrame(title);
  frame.setIconImage(Icons.earth32.getIcon().getImage());
  final SplashScreen splashScreen=showSplashScreen ? new SplashScreen(null,SplashScreen.class.getResource(""String_Node_Str"")) : null;
  if (Settings.get().isHardwareStereoEnabled()) {
    System.setProperty(AVKey.STEREO_MODE,""String_Node_Str"");
  }
  if (useNewt) {
    Configuration.setValue(AVKey.WORLD_WINDOW_CLASS_NAME,WorldWindowNewtAutoDrawable.class.getName());
    Configuration.setValue(AVKey.INPUT_HANDLER_CLASS_NAME,NewtInputHandler.class.getName());
    wwd=new WorldWindowNewtCanvas();
  }
 else {
    wwd=new WorldWindowGLCanvas();
  }
  wwdCanvas=(Canvas)wwd;
  wwdCanvas.setMinimumSize(new Dimension(1,1));
  wwdCanvas.addComponentListener(new ComponentAdapter(){
    @Override public void componentResized(    ComponentEvent e){
      wwdCanvas.setMinimumSize(new Dimension(1,1));
    }
  }
);
  if (splashScreen != null) {
    splashScreen.addRenderingListener(wwd);
  }
  Model model=(Model)WorldWind.createConfigurationComponent(AVKey.MODEL_CLASS_NAME);
  model.setLayers(new SectionListLayerList());
  model.getGlobe().setElevationModel(new SectionListCompoundElevationModel());
  wwd.setModel(model);
  wwd.addSelectListener(new ClickAndGoSelectListener(wwd,WorldMapLayer.class));
  create3DMouse();
  createDoubleClickListener();
  wwd.addRenderingExceptionListener(new RenderingExceptionListener(){
    @Override public void exceptionThrown(    Throwable t){
      if (t instanceof WWAbsentRequirementException) {
        String title=getMessage(getVideocardFailureTitleKey());
        String message=getMessage(getVideocardFailureMessageKey(),t.getMessage());
        JOptionPane.showMessageDialog(frame,message,title,JOptionPane.ERROR_MESSAGE);
        System.exit(-1);
      }
    }
  }
);
  RetrievalService rs=WorldWind.getRetrievalService();
  if (rs instanceof ExtendedRetrievalService) {
    PolylineLayerRetrievalListener layer=new PolylineLayerRetrievalListener();
    model.getLayers().add(layer);
    ((ExtendedRetrievalService)rs).addRetrievalListener(layer);
  }
  ToolTipManager.sharedInstance().setLightWeightPopupEnabled(false);
  JPopupMenu.setDefaultLightWeightPopupEnabled(false);
  JPanel panel=new JPanel(new BorderLayout());
  frame.setContentPane(panel);
  frame.setBounds(Settings.get().getWindowBounds());
  if (!fullscreen && Settings.get().isWindowMaximized()) {
    frame.setExtendedState(JFrame.MAXIMIZED_BOTH);
  }
  splitPane=new JSplitPane(JSplitPane.HORIZONTAL_SPLIT,true);
  panel.add(splitPane,BorderLayout.CENTER);
  if (!fullscreen) {
    splitPane.setRightComponent(wwdCanvas);
  }
  splitPane.setOneTouchExpandable(true);
  loadSplitLocation();
  boolean anyPanels=!theme.getPanels().isEmpty() && theme.hasSideBar();
  if (anyPanels) {
    sideBar=new SideBar(theme,splitPane);
    splitPane.setLeftComponent(sideBar);
  }
  if (!anyPanels || fullscreen) {
    splitPane.setDividerSize(0);
  }
  if (theme.hasStatusBar()) {
    statusBar=new DownloaderStatusBar();
    panel.add(statusBar,BorderLayout.PAGE_END);
    statusBar.setEventSource(wwd);
    statusBar.setBorder(BorderFactory.createLoweredBevelBorder());
  }
  theme.setup(frame,wwd);
  if (!theme.getLayers().isEmpty() && !theme.hasThemeLayersPanel()) {
    List<ILayerNode> nodes=new ArrayList<ILayerNode>();
    for (    ThemeLayer layer : theme.getLayers()) {
      nodes.add(LayerNode.createFromLayerDefinition(layer));
    }
    LayerEnabler enabler=new LayerEnabler(theme.getLayersPanel().getTree(),wwd);
    enabler.enable(nodes);
  }
  afterSettingsChange();
  createActions();
  createThemeListeners();
  if (theme.hasMenuBar()) {
    menuBar=createMenuBar();
    frame.setJMenuBar(menuBar);
  }
  if (theme.hasToolBar()) {
    toolBar=createToolBar();
    panel.add(toolBar,BorderLayout.PAGE_START);
  }
  addWindowListeners();
  try {
    SwingUtil.invokeLaterTaskOnEDT(new Runnable(){
      @Override public void run(){
        frame.setVisible(true);
        wwdCanvas.createBufferStrategy(2);
      }
    }
);
  }
 catch (  Exception e) {
  }
}",0.9780578898225956
11022,"@Override public void valueChanged(TreeSelectionEvent event){
  IData selected=getSelectedData(event.getPath());
  if (selected == null)   return;
  addAction.setEnabled(false);
  removeAction.setEnabled(false);
  if (selected instanceof ILayerDefinition) {
    ILayerDefinition layer=(ILayerDefinition)selected;
    if (layerTreeModel.containsLayer(layer))     removeAction.setEnabled(true);
 else     addAction.setEnabled(true);
    addAllAction.setEnabled(false);
  }
 else {
    addAllAction.setEnabled(true);
  }
}","@Override public void valueChanged(TreeSelectionEvent event){
  IData selected=getSelectedData(event.getPath());
  enableActions(selected);
}",0.3909090909090909
11023,"protected void createActions(){
  addAction=new BasicAction(""String_Node_Str"",Icons.add.getIcon());
  addAction.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      TreePath path=tree.getSelectionPath();
      IData selected=getSelectedData(path);
      if (!(selected instanceof ILayerDefinition))       return;
      ILayerDefinition layer=(ILayerDefinition)selected;
      layerTreeModel.addLayer(layer,path.getPath());
      tree.repaint();
    }
  }
);
  removeAction=new BasicAction(""String_Node_Str"",Icons.remove.getIcon());
  removeAction.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      TreePath path=tree.getSelectionPath();
      IData selected=getSelectedData(path);
      if (!(selected instanceof ILayerDefinition))       return;
      ILayerDefinition layer=(ILayerDefinition)selected;
      layerTreeModel.removeLayer(layer);
      tree.repaint();
    }
  }
);
  addAllAction=new BasicAction(""String_Node_Str"",Icons.add.getIcon());
  addAllAction.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      final TreePath path=tree.getSelectionPath();
      final IData selected=getSelectedData(path);
      if (selected != null) {
        int choice=JOptionPane.showConfirmDialog(DatasetPanel.this,""String_Node_Str"",""String_Node_Str"",JOptionPane.YES_NO_OPTION,JOptionPane.WARNING_MESSAGE);
        if (choice == JOptionPane.YES_OPTION) {
          Thread thread=new Thread(new Runnable(){
            @Override public void run(){
              addAll(selected,path.getPath());
              SwingUtil.invokeLaterTaskOnEDT(new Runnable(){
                @Override public void run(){
                  tree.repaint();
                }
              }
);
            }
          }
);
          thread.setDaemon(true);
          thread.start();
        }
      }
    }
  }
);
  tree.addTreeSelectionListener(new TreeSelectionListener(){
    @Override public void valueChanged(    TreeSelectionEvent event){
      IData selected=getSelectedData(event.getPath());
      if (selected == null)       return;
      addAction.setEnabled(false);
      removeAction.setEnabled(false);
      if (selected instanceof ILayerDefinition) {
        ILayerDefinition layer=(ILayerDefinition)selected;
        if (layerTreeModel.containsLayer(layer))         removeAction.setEnabled(true);
 else         addAction.setEnabled(true);
        addAllAction.setEnabled(false);
      }
 else {
        addAllAction.setEnabled(true);
      }
    }
  }
);
}","protected void createActions(){
  addAction=new BasicAction(""String_Node_Str"",Icons.add.getIcon());
  addAction.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      TreePath path=tree.getSelectionPath();
      IData selected=getSelectedData(path);
      if (!(selected instanceof ILayerDefinition))       return;
      ILayerDefinition layer=(ILayerDefinition)selected;
      layerTreeModel.addLayer(layer,path.getPath());
      tree.repaint();
      enableActions();
    }
  }
);
  removeAction=new BasicAction(""String_Node_Str"",Icons.remove.getIcon());
  removeAction.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      TreePath path=tree.getSelectionPath();
      IData selected=getSelectedData(path);
      if (!(selected instanceof ILayerDefinition))       return;
      ILayerDefinition layer=(ILayerDefinition)selected;
      layerTreeModel.removeLayer(layer);
      tree.repaint();
      enableActions();
    }
  }
);
  addAllAction=new BasicAction(""String_Node_Str"",Icons.add.getIcon());
  addAllAction.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      final TreePath path=tree.getSelectionPath();
      final IData selected=getSelectedData(path);
      if (selected != null) {
        int choice=JOptionPane.showConfirmDialog(DatasetPanel.this,""String_Node_Str"",""String_Node_Str"",JOptionPane.YES_NO_OPTION,JOptionPane.WARNING_MESSAGE);
        if (choice == JOptionPane.YES_OPTION) {
          Thread thread=new Thread(new Runnable(){
            @Override public void run(){
              addAll(selected,path.getPath());
              SwingUtil.invokeLaterTaskOnEDT(new Runnable(){
                @Override public void run(){
                  tree.repaint();
                  enableActions();
                }
              }
);
            }
          }
);
          thread.setDaemon(true);
          thread.start();
        }
      }
    }
  }
);
  tree.addTreeSelectionListener(new TreeSelectionListener(){
    @Override public void valueChanged(    TreeSelectionEvent event){
      IData selected=getSelectedData(event.getPath());
      enableActions(selected);
    }
  }
);
}",0.8865641025641026
11024,"@Override public void run(){
  tree.repaint();
}","@Override public void run(){
  tree.repaint();
  enableActions();
}",0.8347826086956521
11025,"@Override public void actionPerformed(ActionEvent e){
  final TreePath path=tree.getSelectionPath();
  final IData selected=getSelectedData(path);
  if (selected != null) {
    int choice=JOptionPane.showConfirmDialog(DatasetPanel.this,""String_Node_Str"",""String_Node_Str"",JOptionPane.YES_NO_OPTION,JOptionPane.WARNING_MESSAGE);
    if (choice == JOptionPane.YES_OPTION) {
      Thread thread=new Thread(new Runnable(){
        @Override public void run(){
          addAll(selected,path.getPath());
          SwingUtil.invokeLaterTaskOnEDT(new Runnable(){
            @Override public void run(){
              tree.repaint();
            }
          }
);
        }
      }
);
      thread.setDaemon(true);
      thread.start();
    }
  }
}","@Override public void actionPerformed(ActionEvent e){
  final TreePath path=tree.getSelectionPath();
  final IData selected=getSelectedData(path);
  if (selected != null) {
    int choice=JOptionPane.showConfirmDialog(DatasetPanel.this,""String_Node_Str"",""String_Node_Str"",JOptionPane.YES_NO_OPTION,JOptionPane.WARNING_MESSAGE);
    if (choice == JOptionPane.YES_OPTION) {
      Thread thread=new Thread(new Runnable(){
        @Override public void run(){
          addAll(selected,path.getPath());
          SwingUtil.invokeLaterTaskOnEDT(new Runnable(){
            @Override public void run(){
              tree.repaint();
              enableActions();
            }
          }
);
        }
      }
);
      thread.setDaemon(true);
      thread.start();
    }
  }
}",0.9794837855724684
11026,"/** 
 * Show a new   {@link ProxyDialog}, and block until the user has completed.
 * @param parent Dialog's parent
 */
public static void show(Frame parent){
  ProxyDialog dialog=new ProxyDialog(parent);
  dialog.setVisible(true);
  if (dialog.response != JOptionPane.OK_OPTION) {
    return;
  }
  Proxy proxy=new Proxy();
  proxy.setEnabled(dialog.enabled.isSelected());
  proxy.setUseSystem(dialog.useSystem.isSelected());
  Integer port=dialog.port.getValue();
  if (port != null) {
    proxy.setPort(port);
  }
  proxy.setHost(dialog.host.getText());
  proxy.setNonProxyHosts(dialog.nonProxyHosts.getText());
  proxy.setType((ProxyType)dialog.type.getSelectedItem());
}","/** 
 * Show a new   {@link ProxyDialog}, and block until the user has completed.
 * @param parent Dialog's parent
 */
public static void show(Frame parent){
  ProxyDialog dialog=new ProxyDialog(parent);
  dialog.setVisible(true);
  if (dialog.response != JOptionPane.OK_OPTION) {
    return;
  }
  Proxy proxy=new Proxy();
  proxy.setEnabled(dialog.enabled.isSelected());
  proxy.setUseSystem(dialog.useSystem.isSelected());
  Integer port=dialog.port.getValue();
  if (port != null) {
    proxy.setPort(port);
  }
  proxy.setHost(dialog.host.getText());
  proxy.setNonProxyHosts(dialog.nonProxyHosts.getText());
  proxy.setType((ProxyType)dialog.type.getSelectedItem());
  Settings.get().setProxy(proxy);
}",0.975397973950796
11027,"/** 
 * Constructs a new <code>WorldWindowGLCanvas</code> on the default graphics device and shares graphics resources with another <code>WorldWindow</code>.
 * @param shareWith a <code>WorldWindow</code> with which to share graphics resources. May be null, in which case resources are not shared.
 * @see GLCanvas#GLCanvas(GLCapabilities,GLCapabilitiesChooser,GLContext,GraphicsDevice)
 */
public WorldWindowNewtCanvas(WorldWindow shareWith){
  super(GLWindow.create(getCaps()));
  this.window=(GLWindow)getNEWTChild();
  if (shareWith != null) {
    this.window.setSharedContext(shareWith.getContext());
  }
  try {
    this.wwd=((WorldWindowNewtDrawable)WorldWind.createConfigurationComponent(AVKey.WORLD_WINDOW_CLASS_NAME));
    this.wwd.initDrawable(window,this);
    if (shareWith != null)     this.wwd.initGpuResourceCache(shareWith.getGpuResourceCache());
 else     this.wwd.initGpuResourceCache(WorldWindowImpl.createGpuResourceCache());
    this.createView();
    this.createDefaultInputHandler();
    WorldWind.addPropertyChangeListener(WorldWind.SHUTDOWN_EVENT,this);
    this.wwd.endInitialization();
  }
 catch (  Exception e) {
    String message=Logging.getMessage(""String_Node_Str"");
    Logging.logger().severe(message);
    throw new WWRuntimeException(message,e);
  }
}","/** 
 * Constructs a new <code>WorldWindowGLCanvas</code> on the default graphics device and shares graphics resources with another <code>WorldWindow</code>.
 * @param shareWith a <code>WorldWindow</code> with which to share graphics resources. May be null, in which case resources are not shared.
 * @see GLCanvas#GLCanvas(GLCapabilities,GLCapabilitiesChooser,GLContext,GraphicsDevice)
 */
public WorldWindowNewtCanvas(WorldWindow shareWith){
  super(GLWindow.create(getCaps()));
  superContructorComplete=true;
  this.window=(GLWindow)getNEWTChild();
  if (shareWith != null) {
    this.window.setSharedContext(shareWith.getContext());
  }
  try {
    this.wwd=((WorldWindowNewtDrawable)WorldWind.createConfigurationComponent(AVKey.WORLD_WINDOW_CLASS_NAME));
    this.wwd.initDrawable(window,this);
    if (shareWith != null)     this.wwd.initGpuResourceCache(shareWith.getGpuResourceCache());
 else     this.wwd.initGpuResourceCache(WorldWindowImpl.createGpuResourceCache());
    this.createView();
    this.createDefaultInputHandler();
    WorldWind.addPropertyChangeListener(WorldWind.SHUTDOWN_EVENT,this);
    this.wwd.endInitialization();
  }
 catch (  Exception e) {
    String message=Logging.getMessage(""String_Node_Str"");
    Logging.logger().severe(message);
    throw new WWRuntimeException(message,e);
  }
}",0.9877394636015324
11028,"/** 
 * Create an AWT   {@link java.awt.event.KeyEvent} from the given NEWT{@link com.jogamp.newt.event.KeyEvent}. Return value implements  {@link AWTEventFromNewt}.
 * @param event NEWT event to convert
 * @param awtSource Component to set as the AWT event source
 * @return AWT event corresponding to the given NEWT event
 */
public static final java.awt.event.KeyEvent createKeyEvent(com.jogamp.newt.event.KeyEvent event,java.awt.Component awtSource){
  int id=eventTypeAWT2NEWT.get(event.getEventType());
  if (id != KEY_NOT_FOUND_VALUE) {
    int code=id == java.awt.event.KeyEvent.KEY_TYPED ? java.awt.event.KeyEvent.VK_UNDEFINED : event.getKeyCode();
    int location=id == java.awt.event.KeyEvent.KEY_TYPED ? java.awt.event.KeyEvent.KEY_LOCATION_UNKNOWN : java.awt.event.KeyEvent.KEY_LOCATION_STANDARD;
    return new KeyEventFromNewt(event,awtSource,id,event.getWhen(),newtModifiers2Awt(event.getModifiers()),code,event.getKeyChar(),location);
  }
  return null;
}","/** 
 * Create an AWT   {@link java.awt.event.KeyEvent} from the given NEWT{@link com.jogamp.newt.event.KeyEvent}. Return value implements  {@link AWTEventFromNewt}.
 * @param event NEWT event to convert
 * @param awtSource Component to set as the AWT event source
 * @return AWT event corresponding to the given NEWT event
 */
public static final java.awt.event.KeyEvent createKeyEvent(com.jogamp.newt.event.KeyEvent event,java.awt.Component awtSource){
  int id=eventTypeAWT2NEWT.get(event.getEventType());
  if (id != KEY_NOT_FOUND_VALUE) {
    int code=id == java.awt.event.KeyEvent.KEY_TYPED ? java.awt.event.KeyEvent.VK_UNDEFINED : event.getKeyCode();
    int location=id == java.awt.event.KeyEvent.KEY_TYPED ? java.awt.event.KeyEvent.KEY_LOCATION_UNKNOWN : java.awt.event.KeyEvent.KEY_LOCATION_STANDARD;
    try {
      return new KeyEventFromNewt(event,awtSource,id,event.getWhen(),newtModifiers2Awt(event.getModifiers()),code,event.getKeyChar(),location);
    }
 catch (    IllegalArgumentException e) {
    }
  }
  return null;
}",0.967196819085487
11029,"public CurtainLevel(AVList params){
  if (params == null) {
    String message=Logging.getMessage(""String_Node_Str"");
    Logging.logger().severe(message);
    throw new IllegalArgumentException(message);
  }
  this.params=params.copy();
  String message=this.validate(params);
  if (message != null) {
    Logging.logger().severe(message);
    throw new IllegalArgumentException(message);
  }
  String ln=this.params.getStringValue(AVKey.LEVEL_NAME);
  this.levelName=ln != null ? ln : ""String_Node_Str"";
  this.levelNumber=(Integer)this.params.getValue(AVKey.LEVEL_NUMBER);
  this.levelWidth=(Integer)this.params.getValue(AVKeyMore.LEVEL_WIDTH);
  this.levelHeight=(Integer)this.params.getValue(AVKeyMore.LEVEL_HEIGHT);
  int tileWidth=(Integer)this.params.getValue(AVKey.TILE_WIDTH);
  int tileHeight=(Integer)this.params.getValue(AVKey.TILE_HEIGHT);
  this.cacheName=this.params.getStringValue(AVKey.DATA_CACHE_NAME);
  this.service=this.params.getStringValue(AVKey.SERVICE);
  this.dataset=this.params.getStringValue(AVKey.DATASET_NAME);
  this.formatSuffix=this.params.getStringValue(AVKey.FORMAT_SUFFIX);
  this.urlBuilder=(CurtainTileUrlBuilder)this.params.getValue(AVKey.TILE_URL_BUILDER);
  this.expiryTime=AVListImpl.getLongValue(params,AVKey.EXPIRY_TIME,0L);
  Angle curtainLength=((Path)this.params.getValue(AVKeyMore.PATH)).getLength();
  this.texelSize=curtainLength.radians / this.levelWidth;
  int widthsPerTile=tileWidth / this.levelWidth;
  int heightsPerTile=tileHeight / this.levelHeight;
  if (widthsPerTile > 1) {
    tileWidth/=widthsPerTile;
    tileHeight*=widthsPerTile;
  }
  if (heightsPerTile > 1) {
    tileWidth*=heightsPerTile;
    tileHeight/=heightsPerTile;
  }
  this.tileWidth=tileWidth;
  this.tileHeight=tileHeight;
  this.columnCount=(levelWidth - 1) / tileWidth + 1;
  this.rowCount=(levelHeight - 1) / tileHeight + 1;
  this.path=this.cacheName + ""String_Node_Str"" + this.levelName;
  Integer maxAbsentTileAttempts=(Integer)this.params.getValue(AVKey.MAX_ABSENT_TILE_ATTEMPTS);
  if (maxAbsentTileAttempts == null)   maxAbsentTileAttempts=DEFAULT_MAX_ABSENT_TILE_ATTEMPTS;
  Integer minAbsentTileCheckInterval=(Integer)this.params.getValue(AVKey.MIN_ABSENT_TILE_CHECK_INTERVAL);
  if (minAbsentTileCheckInterval == null)   minAbsentTileCheckInterval=DEFAULT_MIN_ABSENT_TILE_CHECK_INTERVAL;
  this.absentTiles=new AbsentResourceList(maxAbsentTileAttempts,minAbsentTileCheckInterval);
}","public CurtainLevel(AVList params){
  if (params == null) {
    String message=Logging.getMessage(""String_Node_Str"");
    Logging.logger().severe(message);
    throw new IllegalArgumentException(message);
  }
  this.params=params.copy();
  String message=this.validate(params);
  if (message != null) {
    Logging.logger().severe(message);
    throw new IllegalArgumentException(message);
  }
  String ln=this.params.getStringValue(AVKey.LEVEL_NAME);
  this.levelName=ln != null ? ln : ""String_Node_Str"";
  this.levelNumber=(Integer)this.params.getValue(AVKey.LEVEL_NUMBER);
  this.levelWidth=(Integer)this.params.getValue(AVKeyMore.LEVEL_WIDTH);
  this.levelHeight=(Integer)this.params.getValue(AVKeyMore.LEVEL_HEIGHT);
  int tileWidth=(Integer)this.params.getValue(AVKey.TILE_WIDTH);
  int tileHeight=(Integer)this.params.getValue(AVKey.TILE_HEIGHT);
  this.cacheName=this.params.getStringValue(AVKey.DATA_CACHE_NAME);
  this.service=this.params.getStringValue(AVKey.SERVICE);
  this.dataset=this.params.getStringValue(AVKey.DATASET_NAME);
  this.formatSuffix=this.params.getStringValue(AVKey.FORMAT_SUFFIX);
  this.urlBuilder=(CurtainTileUrlBuilder)this.params.getValue(AVKey.TILE_URL_BUILDER);
  this.expiryTime=AVListImpl.getLongValue(params,AVKey.EXPIRY_TIME,0L);
  Angle curtainLength=((Path)this.params.getValue(AVKeyMore.PATH)).getLength();
  this.texelSize=curtainLength.radians / this.levelWidth;
  int widthsPerTile=Util.previousPowerOfTwo(tileWidth / this.levelWidth);
  int heightsPerTile=Util.previousPowerOfTwo(tileHeight / this.levelHeight);
  if (widthsPerTile > 1) {
    tileWidth/=widthsPerTile;
    tileHeight*=widthsPerTile;
  }
  if (heightsPerTile > 1) {
    tileWidth*=heightsPerTile;
    tileHeight/=heightsPerTile;
  }
  this.tileWidth=tileWidth;
  this.tileHeight=tileHeight;
  this.columnCount=(levelWidth - 1) / tileWidth + 1;
  this.rowCount=(levelHeight - 1) / tileHeight + 1;
  this.path=this.cacheName + ""String_Node_Str"" + this.levelName;
  Integer maxAbsentTileAttempts=(Integer)this.params.getValue(AVKey.MAX_ABSENT_TILE_ATTEMPTS);
  if (maxAbsentTileAttempts == null)   maxAbsentTileAttempts=DEFAULT_MAX_ABSENT_TILE_ATTEMPTS;
  Integer minAbsentTileCheckInterval=(Integer)this.params.getValue(AVKey.MIN_ABSENT_TILE_CHECK_INTERVAL);
  if (minAbsentTileCheckInterval == null)   minAbsentTileCheckInterval=DEFAULT_MIN_ABSENT_TILE_CHECK_INTERVAL;
  this.absentTiles=new AbsentResourceList(maxAbsentTileAttempts,minAbsentTileCheckInterval);
}",0.9898000815993472
11030,"protected void delete(GL2 gl){
  if (isCreated()) {
    if (texture) {
      gl.glDeleteRenderbuffers(1,new int[]{id},0);
    }
 else {
      gl.glDeleteTextures(1,new int[]{id},0);
    }
    id=0;
  }
}","protected void delete(GL2 gl){
  if (isCreated()) {
    if (texture) {
      gl.glDeleteTextures(1,new int[]{id},0);
    }
 else {
      gl.glDeleteRenderbuffers(1,new int[]{id},0);
    }
    id=0;
  }
}",0.7044334975369458
11031,"@Override protected void applyDrawProjection(DrawContext dc,OGLStackHandler ogsh){
  boolean loaded=false;
  if (dc.getView() instanceof StereoView && ((StereoView)dc.getView()).isStereo()) {
    StereoView stereo=(StereoView)dc.getView();
    double near=stereo.getEyePoint().getLength3();
    double far=this.radius + near;
    Matrix projection=stereo.calculateProjectionMatrix(near,far);
    if (projection != null) {
      double[] matrixArray=new double[16];
      GL2 gl=dc.getGL().getGL2();
      gl.glMatrixMode(GL2.GL_PROJECTION);
      gl.glPushMatrix();
      projection.toArray(matrixArray,0,false);
      gl.glLoadMatrixd(matrixArray,0);
      loaded=true;
    }
  }
  if (!loaded) {
    super.applyDrawProjection(dc,ogsh);
  }
}","@Override protected void applyDrawProjection(DrawContext dc,OGLStackHandler ogsh){
  boolean loaded=false;
  if (dc.getView() instanceof StereoView && ((StereoView)dc.getView()).isStereo()) {
    StereoView stereo=(StereoView)dc.getView();
    double near=stereo.getEyePoint().getLength3();
    double far=this.radius + near;
    Matrix projection=stereo.calculateProjectionMatrix(near,far);
    if (projection != null) {
      double[] matrixArray=new double[16];
      GL2 gl=dc.getGL().getGL2();
      ogsh.pushProjection(gl);
      projection.toArray(matrixArray,0,false);
      gl.glLoadMatrixd(matrixArray,0);
      loaded=true;
    }
  }
  if (!loaded) {
    super.applyDrawProjection(dc,ogsh);
  }
}",0.9462068965517242
11032,"protected void fixSkirts(DrawContext dc,RowColRectTile tile,Map<RectTileKey,RowColRectTile> tileMap){
  int row=tile.getRow();
  int column=tile.getColumn();
  int level=tile.getLevel();
  int sRow=row / 2;
  int sColumn=column / 2;
  int sLevel=level - 1;
  boolean topHalf=row % 2 == 0;
  boolean leftHalf=column % 2 == 0;
  RowColRectTile sLeft=leftHalf ? tileMap.get(new RectTileKey(sLevel,sRow,sColumn - 1)) : null;
  RowColRectTile sRight=!leftHalf ? tileMap.get(new RectTileKey(sLevel,sRow,sColumn + 1)) : null;
  RowColRectTile sTop=topHalf ? tileMap.get(new RectTileKey(sLevel,sRow - 1,sColumn)) : null;
  RowColRectTile sBottom=!topHalf ? tileMap.get(new RectTileKey(sLevel,sRow + 1,sColumn)) : null;
  RowColRectTile left=sLeft == null ? tileMap.get(new RectTileKey(level,row,column - 1)) : null;
  RowColRectTile top=sTop == null ? tileMap.get(new RectTileKey(level,row - 1,column)) : null;
  boolean anyRebuilt=tile.rebuiltVertices || (sLeft != null && sLeft.rebuiltVertices) || (sRight != null && sRight.rebuiltVertices)|| (sTop != null && sTop.rebuiltVertices)|| (sBottom != null && sBottom.rebuiltVertices)|| (left != null && left.rebuiltVertices)|| (top != null && top.rebuiltVertices);
  if (!anyRebuilt) {
    return;
  }
  FloatBuffer vertices=tile.getRi().getVertices();
  Vec4 refCenter=tile.getRi().getReferenceCenter();
  int density=tile.getDensity();
  int size=density + 3;
  if (sLeft != null) {
    FloatBuffer leftVertices=sLeft.getRi().getVertices();
    Vec4 leftRefCenter=sLeft.getRi().getReferenceCenter();
    int srcStart=topHalf ? 1 : density / 2 + 1;
    subdivideVerticesFromNeighboringSuperTile(leftVertices,vertices,leftRefCenter,refCenter,size,srcStart,size - 1,0,true);
  }
 else   if (left != null) {
    FloatBuffer leftVertices=left.getRi().getVertices();
    Vec4 leftRefCenter=left.getRi().getReferenceCenter();
    copyVerticesFromNeighboringTile(leftVertices,vertices,leftRefCenter,refCenter,size,size - 1,0,true);
  }
  if (sRight != null) {
    FloatBuffer rightVertices=sRight.getRi().getVertices();
    Vec4 rightRefCenter=sRight.getRi().getReferenceCenter();
    int srcStart=topHalf ? 1 : density / 2 + 1;
    subdivideVerticesFromNeighboringSuperTile(rightVertices,vertices,rightRefCenter,refCenter,size,srcStart,0,size - 1,true);
  }
  if (sTop != null) {
    FloatBuffer topVertices=sTop.getRi().getVertices();
    Vec4 topRefCenter=sTop.getRi().getReferenceCenter();
    int srcStart=leftHalf ? 1 : density / 2 + 1;
    subdivideVerticesFromNeighboringSuperTile(topVertices,vertices,topRefCenter,refCenter,size,srcStart,size - 1,0,false);
  }
 else   if (top != null) {
    FloatBuffer topVertices=top.getRi().getVertices();
    Vec4 topRefCenter=top.getRi().getReferenceCenter();
    copyVerticesFromNeighboringTile(topVertices,vertices,topRefCenter,refCenter,size,size - 1,0,false);
  }
  if (sBottom != null) {
    FloatBuffer bottomVertices=sBottom.getRi().getVertices();
    Vec4 bottomRefCenter=sBottom.getRi().getReferenceCenter();
    int srcStart=leftHalf ? 1 : density / 2 + 1;
    subdivideVerticesFromNeighboringSuperTile(bottomVertices,vertices,bottomRefCenter,refCenter,size,srcStart,0,size - 1,false);
  }
  if (dc.getGLRuntimeCapabilities().isUseVertexBufferObject()) {
    GL2 gl=dc.getGL();
    OGLStackHandler ogsh=new OGLStackHandler();
    try {
      ogsh.pushClientAttrib(gl,GL2.GL_CLIENT_VERTEX_ARRAY_BIT);
      int[] vboIds=(int[])dc.getGpuResourceCache().get(tile.getRi().getVboCacheKey());
      gl.glBindBuffer(GL2.GL_ARRAY_BUFFER,vboIds[0]);
      gl.glBufferData(GL2.GL_ARRAY_BUFFER,vertices.limit() * 4,vertices.rewind(),GL2.GL_DYNAMIC_DRAW);
    }
  finally {
      ogsh.pop(gl);
    }
  }
}","protected void fixSkirts(DrawContext dc,RowColRectTile tile,Map<RectTileKey,RowColRectTile> tileMap){
  int row=tile.getRow();
  int column=tile.getColumn();
  int level=tile.getLevel();
  int sRow=row / 2;
  int sColumn=column / 2;
  int sLevel=level - 1;
  boolean topHalf=row % 2 == 0;
  boolean leftHalf=column % 2 == 0;
  RowColRectTile sLeft=leftHalf ? tileMap.get(new RectTileKey(sLevel,sRow,sColumn - 1)) : null;
  RowColRectTile sRight=!leftHalf ? tileMap.get(new RectTileKey(sLevel,sRow,sColumn + 1)) : null;
  RowColRectTile sTop=topHalf ? tileMap.get(new RectTileKey(sLevel,sRow - 1,sColumn)) : null;
  RowColRectTile sBottom=!topHalf ? tileMap.get(new RectTileKey(sLevel,sRow + 1,sColumn)) : null;
  RowColRectTile left=sLeft == null ? tileMap.get(new RectTileKey(level,row,column - 1)) : null;
  RowColRectTile top=sTop == null ? tileMap.get(new RectTileKey(level,row - 1,column)) : null;
  boolean anyRebuilt=tile.rebuiltVertices || (sLeft != null && sLeft.rebuiltVertices) || (sRight != null && sRight.rebuiltVertices)|| (sTop != null && sTop.rebuiltVertices)|| (sBottom != null && sBottom.rebuiltVertices)|| (left != null && left.rebuiltVertices)|| (top != null && top.rebuiltVertices);
  if (!anyRebuilt) {
    return;
  }
  FloatBuffer vertices=tile.getRi().getVertices();
  Vec4 refCenter=tile.getRi().getReferenceCenter();
  int density=tile.getDensity();
  int size=density + 3;
  if (sLeft != null) {
    FloatBuffer leftVertices=sLeft.getRi().getVertices();
    Vec4 leftRefCenter=sLeft.getRi().getReferenceCenter();
    int srcStart=topHalf ? 1 : density / 2 + 1;
    subdivideVerticesFromNeighboringSuperTile(leftVertices,vertices,leftRefCenter,refCenter,size,srcStart,size - 1,0,true);
  }
 else   if (left != null) {
    FloatBuffer leftVertices=left.getRi().getVertices();
    Vec4 leftRefCenter=left.getRi().getReferenceCenter();
    copyVerticesFromNeighboringTile(leftVertices,vertices,leftRefCenter,refCenter,size,size - 1,0,true);
  }
  if (sRight != null) {
    FloatBuffer rightVertices=sRight.getRi().getVertices();
    Vec4 rightRefCenter=sRight.getRi().getReferenceCenter();
    int srcStart=topHalf ? 1 : density / 2 + 1;
    subdivideVerticesFromNeighboringSuperTile(rightVertices,vertices,rightRefCenter,refCenter,size,srcStart,0,size - 1,true);
  }
  if (sTop != null) {
    FloatBuffer topVertices=sTop.getRi().getVertices();
    Vec4 topRefCenter=sTop.getRi().getReferenceCenter();
    int srcStart=leftHalf ? 1 : density / 2 + 1;
    subdivideVerticesFromNeighboringSuperTile(topVertices,vertices,topRefCenter,refCenter,size,srcStart,size - 1,0,false);
  }
 else   if (top != null) {
    FloatBuffer topVertices=top.getRi().getVertices();
    Vec4 topRefCenter=top.getRi().getReferenceCenter();
    copyVerticesFromNeighboringTile(topVertices,vertices,topRefCenter,refCenter,size,size - 1,0,false);
  }
  if (sBottom != null) {
    FloatBuffer bottomVertices=sBottom.getRi().getVertices();
    Vec4 bottomRefCenter=sBottom.getRi().getReferenceCenter();
    int srcStart=leftHalf ? 1 : density / 2 + 1;
    subdivideVerticesFromNeighboringSuperTile(bottomVertices,vertices,bottomRefCenter,refCenter,size,srcStart,0,size - 1,false);
  }
  if (dc.getGLRuntimeCapabilities().isUseVertexBufferObject()) {
    GL2 gl=dc.getGL();
    OGLStackHandler ogsh=new OGLStackHandler();
    try {
      ogsh.pushClientAttrib(gl,GL2.GL_CLIENT_VERTEX_ARRAY_BIT);
      int[] vboIds=(int[])dc.getGpuResourceCache().get(tile.getRi().getVboCacheKey());
      if (vboIds != null) {
        gl.glBindBuffer(GL2.GL_ARRAY_BUFFER,vboIds[0]);
        gl.glBufferData(GL2.GL_ARRAY_BUFFER,vertices.limit() * 4,vertices.rewind(),GL2.GL_DYNAMIC_DRAW);
      }
    }
  finally {
      ogsh.pop(gl);
    }
  }
}",0.9946004319654428
11033,"/** 
 * Calculate the sector of the given dataset.
 * @param dataset
 * @param performCoordinateTransformation Should the dataset extent coordinates be transformed to geographic coordinates (lat/lon)?
 * @return Sector of the dataset
 * @throws TilerException
 */
public static Sector getSector(Dataset dataset,boolean performCoordinateTransformation) throws TilerException {
  double[] geoTransformArray=new double[6];
  dataset.GetGeoTransform(geoTransformArray);
  if (geoTransformArray[0] == 0 && geoTransformArray[1] == 0 && geoTransformArray[2] == 0 && geoTransformArray[3] == 0 && geoTransformArray[4] == 0 && geoTransformArray[5] == 0) {
    throw new TilerException(""String_Node_Str"");
  }
  int width=dataset.getRasterXSize();
  int height=dataset.getRasterYSize();
  double minlon=geoTransformArray[0];
  double maxlat=geoTransformArray[3];
  double maxlon=geoTransformArray[0] + geoTransformArray[1] * width + geoTransformArray[2] * height;
  double minlat=geoTransformArray[3] + geoTransformArray[4] * width + geoTransformArray[5] * height;
  if (performCoordinateTransformation) {
    String projection=dataset.GetProjectionRef();
    if (projection != null && projection.length() > 0) {
      SpatialReference proj=new SpatialReference(projection);
      if (proj != null) {
        SpatialReference geog=proj.CloneGeogCS();
        if (geog != null) {
          CoordinateTransformation transform=new CoordinateTransformation(proj,geog);
          if (transform != null) {
            double[] transPoint=new double[3];
            transform.TransformPoint(transPoint,minlon,minlat,0);
            minlon=transPoint[0];
            minlat=transPoint[1];
            transform.TransformPoint(transPoint,maxlon,maxlat,0);
            maxlon=transPoint[0];
            maxlat=transPoint[1];
            transform.delete();
          }
          geog.delete();
        }
        proj.delete();
      }
    }
  }
  if (minlat > maxlat) {
    double temp=minlat;
    minlat=maxlat;
    maxlat=temp;
  }
  if (minlon > maxlon) {
    double temp=minlon;
    minlon=maxlon;
    maxlon=temp;
  }
  return new Sector(minlat,minlon,maxlat,maxlon);
}","/** 
 * Calculate the sector of the given dataset.
 * @param dataset
 * @param performCoordinateTransformation Should the dataset extent coordinates be transformed to geographic coordinates (lat/lon)?
 * @return Sector of the dataset
 * @throws TilerException
 */
public static Sector getSector(Dataset dataset,boolean performCoordinateTransformation) throws TilerException {
  double[] geoTransformArray=new double[6];
  dataset.GetGeoTransform(geoTransformArray);
  if (geoTransformArray[0] == 0 && geoTransformArray[1] == 0 && geoTransformArray[2] == 0 && geoTransformArray[3] == 0 && geoTransformArray[4] == 0 && geoTransformArray[5] == 0) {
    throw new TilerException(""String_Node_Str"");
  }
  int width=dataset.getRasterXSize();
  int height=dataset.getRasterYSize();
  double minlon=geoTransformArray[0];
  double maxlat=geoTransformArray[3];
  double maxlon=geoTransformArray[0] + geoTransformArray[1] * width + geoTransformArray[2] * height;
  double minlat=geoTransformArray[3] + geoTransformArray[4] * width + geoTransformArray[5] * height;
  if (performCoordinateTransformation) {
    String projection=dataset.GetProjectionRef();
    if (projection != null && projection.length() > 0) {
      SpatialReference proj=new SpatialReference(projection);
      if (proj != null) {
        SpatialReference geog=proj.CloneGeogCS();
        if (geog != null) {
          gdal.PushErrorHandler(""String_Node_Str"");
          CoordinateTransformation transform=new CoordinateTransformation(proj,geog);
          gdal.PopErrorHandler();
          if (gdal.GetLastErrorMsg().indexOf(""String_Node_Str"") != -1)           transform=null;
          if (transform != null) {
            double[] transPoint=new double[3];
            transform.TransformPoint(transPoint,minlon,minlat,0);
            minlon=transPoint[0];
            minlat=transPoint[1];
            transform.TransformPoint(transPoint,maxlon,maxlat,0);
            maxlon=transPoint[0];
            maxlat=transPoint[1];
            transform.delete();
          }
          geog.delete();
        }
        proj.delete();
      }
    }
  }
  if (minlat > maxlat) {
    double temp=minlat;
    minlat=maxlat;
    maxlat=temp;
  }
  if (minlon > maxlon) {
    double temp=minlon;
    minlon=maxlon;
    maxlon=temp;
  }
  return new Sector(minlat,minlon,maxlat,maxlon);
}",0.9592336823345956
11034,"/** 
 * Build a   {@link FastShape} object from the list of binary triangle treeleaves.
 * @param triangles Triangle list.
 * @return FastShape containing triangles from the provided triangle list.
 */
protected FastShape buildFastShape(List<BTTTriangle> triangles){
  List<Position> positions=new ArrayList<Position>();
  List<Integer> originalIndices=new ArrayList<Integer>();
  Map<Position,Integer> positionIndexMap=new HashMap<Position,Integer>();
  int[] indices=new int[triangles.size() * 3];
  int i=0;
  for (  BTTTriangle triangle : triangles) {
    Position apexPosition=this.positions.get(triangle.apexIndex);
    Position leftPosition=this.positions.get(triangle.leftIndex);
    Position rightPosition=this.positions.get(triangle.rightIndex);
    Integer apexIndex=positionIndexMap.get(apexPosition);
    Integer leftIndex=positionIndexMap.get(leftPosition);
    Integer rightIndex=positionIndexMap.get(rightPosition);
    if (apexIndex == null) {
      apexIndex=positions.size();
      positionIndexMap.put(apexPosition,apexIndex);
      positions.add(apexPosition);
      originalIndices.add(triangle.apexIndex);
    }
    if (leftIndex == null) {
      leftIndex=positions.size();
      positionIndexMap.put(leftPosition,leftIndex);
      positions.add(leftPosition);
      originalIndices.add(triangle.leftIndex);
    }
    if (rightIndex == null) {
      rightIndex=positions.size();
      positionIndexMap.put(rightPosition,rightIndex);
      positions.add(rightPosition);
      originalIndices.add(triangle.rightIndex);
    }
    indices[i++]=leftIndex;
    indices[i++]=rightIndex;
  }
  FastShape shape=new FastShape(positions,indices,GL.GL_TRIANGLES);
  if (generateTextureCoordinates) {
    float[] textureCoordinateBuffer=new float[positions.size() * 2];
    i=0;
    for (    Integer index : originalIndices) {
      int x=index % width;
      int y=index / width;
      textureCoordinateBuffer[i++]=x / (float)(width - 1);
      textureCoordinateBuffer[i++]=y / (float)(height - 1);
    }
    shape.setTextureCoordinateBuffer(textureCoordinateBuffer);
  }
  return shape;
}","/** 
 * Build a   {@link FastShape} object from the list of binary triangle treeleaves.
 * @param triangles Triangle list.
 * @return FastShape containing triangles from the provided triangle list.
 */
protected FastShape buildFastShape(List<BTTTriangle> triangles){
  List<Position> positions=new ArrayList<Position>();
  List<Integer> originalIndices=new ArrayList<Integer>();
  Map<Position,Integer> positionIndexMap=new HashMap<Position,Integer>();
  int[] indices=new int[triangles.size() * 3];
  int i=0;
  for (  BTTTriangle triangle : triangles) {
    Position apexPosition=this.positions.get(triangle.apexIndex);
    Position leftPosition=this.positions.get(triangle.leftIndex);
    Position rightPosition=this.positions.get(triangle.rightIndex);
    Integer apexIndex=positionIndexMap.get(apexPosition);
    Integer leftIndex=positionIndexMap.get(leftPosition);
    Integer rightIndex=positionIndexMap.get(rightPosition);
    if (apexIndex == null) {
      apexIndex=positions.size();
      positionIndexMap.put(apexPosition,apexIndex);
      positions.add(apexPosition);
      originalIndices.add(triangle.apexIndex);
    }
    if (leftIndex == null) {
      leftIndex=positions.size();
      positionIndexMap.put(leftPosition,leftIndex);
      positions.add(leftPosition);
      originalIndices.add(triangle.leftIndex);
    }
    if (rightIndex == null) {
      rightIndex=positions.size();
      positionIndexMap.put(rightPosition,rightIndex);
      positions.add(rightPosition);
      originalIndices.add(triangle.rightIndex);
    }
    indices[i++]=leftIndex;
    indices[i++]=apexIndex;
    indices[i++]=rightIndex;
  }
  FastShape shape=new FastShape(positions,indices,GL.GL_TRIANGLES);
  if (generateTextureCoordinates) {
    float[] textureCoordinateBuffer=new float[positions.size() * 2];
    i=0;
    for (    Integer index : originalIndices) {
      int x=index % width;
      int y=index / width;
      textureCoordinateBuffer[i++]=x / (float)(width - 1);
      textureCoordinateBuffer[i++]=y / (float)(height - 1);
    }
    shape.setTextureCoordinateBuffer(textureCoordinateBuffer);
  }
  return shape;
}",0.9933806146572104
11035,"@Override public SectorGeometryList tessellate(DrawContext dc){
  double oldExaggeration=dc.getVerticalExaggeration();
  Integer oldMaxLevel=Configuration.getIntegerValue(AVKey.RECTANGULAR_TESSELLATOR_MAX_LEVEL);
  try {
    dc.setVerticalExaggeration(0);
    Configuration.setValue(AVKey.RECTANGULAR_TESSELLATOR_MAX_LEVEL,4);
    return super.tessellate(dc);
  }
  finally {
    dc.setVerticalExaggeration(oldExaggeration);
    Configuration.setValue(AVKey.RECTANGULAR_TESSELLATOR_MAX_LEVEL,oldMaxLevel);
  }
}","@Override public SectorGeometryList tessellate(DrawContext dc){
  Integer oldMaxLevel=Configuration.getIntegerValue(AVKey.RECTANGULAR_TESSELLATOR_MAX_LEVEL);
  try {
    Configuration.setValue(AVKey.RECTANGULAR_TESSELLATOR_MAX_LEVEL,4);
    DrawContextDelegateVerticalExaggerationOverride odc=new DrawContextDelegateVerticalExaggerationOverride(dc);
    odc.overrideVerticalExaggeration(0);
    return super.tessellate(odc);
  }
  finally {
    Configuration.setValue(AVKey.RECTANGULAR_TESSELLATOR_MAX_LEVEL,oldMaxLevel);
  }
}",0.7167630057803468
11036,"/** 
 * Bind this VBO's buffer. Also uploads the buffer to the video card if it is dirty.
 * @param gl OpenGL context
 */
public void bind(GL gl){
  if (vboId < 0) {
    int[] vboIds=new int[1];
    gl.glGenBuffers(vboIds.length,vboIds,0);
    vboId=vboIds[0];
  }
  gl.glBindBuffer(getTarget(),vboId);
  if (dirty) {
    Buffer b=wrapBuffer(buffer);
    gl.glBufferData(getTarget(),b.limit() * getDataSize(),b.rewind(),GL.GL_STATIC_DRAW);
    dirty=false;
  }
}","/** 
 * Bind this VBO's buffer. Also uploads the buffer to the video card if it is dirty.
 * @param gl OpenGL context
 */
public void bind(GL gl){
  if (vboId < 0) {
    int[] vboIds=new int[1];
    gl.glGenBuffers(vboIds.length,vboIds,0);
    vboId=vboIds[0];
  }
  gl.glBindBuffer(getTarget(),vboId);
  if (dirty) {
    boolean locked=false;
    if (uploadRequired) {
      lock.lock();
      uploadRequired=false;
      locked=true;
    }
 else {
      locked=lock.tryLock();
    }
    if (locked) {
      try {
        Buffer b=wrapBuffer(buffer);
        gl.glBufferData(getTarget(),b.limit() * getDataSize(),b.rewind(),GL.GL_STATIC_DRAW);
        dirty=false;
      }
  finally {
        lock.unlock();
      }
    }
  }
}",0.7764705882352941
11037,"/** 
 * Set this VBO's data array. The array will be passed to the video card upon the next call to   {@link #bind(GL)}.
 * @param buffer
 */
public void setBuffer(ARRAY buffer){
  this.buffer=buffer;
  markDirty();
}","/** 
 * Set this VBO's data array. The array will be passed to the video card upon the next call to   {@link #bind(GL)}.
 * @param buffer
 */
public void setBuffer(ARRAY buffer){
  if (!uploadRequired) {
    uploadRequired=this.buffer != buffer;
  }
  this.buffer=buffer;
  markDirty();
}",0.8594059405940594
11038,"protected void sortIndices(DrawContext dc,Vec4 eyePoint,float[] vertices,int[] indices,int[] sortedIndices){
  int size=vertices.length / 3;
  Vec4[] verts=new Vec4[size];
  for (int i=0, j=0; i < vertices.length; i+=3, j++) {
    verts[j]=new Vec4(vertices[i + 0],vertices[i + 1],vertices[i + 2]);
  }
  eyePoint=eyePoint.subtract3(boundingSphere.getCenter());
  if (mode == GL.GL_TRIANGLES) {
    boolean hasIndices=indices != null;
    int triangleCountBy3=hasIndices ? indices.length : size;
    IndexAndDistance[] distances=new IndexAndDistance[triangleCountBy3 / 3];
    for (int i=0, j=0; i < triangleCountBy3; i+=3, j++) {
      int index0=hasIndices ? indices[i + 0] : i + 0;
      int index1=hasIndices ? indices[i + 1] : i + 1;
      int index2=hasIndices ? indices[i + 2] : i + 2;
      Vec4 v0=verts[index0];
      Vec4 v1=verts[index1];
      Vec4 v2=verts[index2];
      double distance=v0.distanceToSquared3(eyePoint) + v1.distanceToSquared3(eyePoint) + v2.distanceToSquared3(eyePoint);
      distances[j]=new IndexAndDistance(distance,i);
    }
    Arrays.sort(distances);
    IndexAndDistance closest=distances[distances.length - 1];
    Vec4 closestPoint=verts[hasIndices ? indices[closest.index] : closest.index];
    distanceFromEye=closestPoint.distanceTo3(eyePoint);
    for (int i=0, j=0; i < triangleCountBy3; i+=3, j++) {
      IndexAndDistance distance=distances[j];
      sortedIndices[i + 0]=hasIndices ? indices[distance.index + 0] : distance.index + 0;
      sortedIndices[i + 1]=hasIndices ? indices[distance.index + 1] : distance.index + 1;
      sortedIndices[i + 2]=hasIndices ? indices[distance.index + 2] : distance.index + 2;
    }
  }
 else   if (mode == GL.GL_POINTS) {
    IndexAndDistance[] distances=new IndexAndDistance[size];
    for (int i=0; i < size; i++) {
      double distance=verts[i].distanceToSquared3(eyePoint);
      distances[i]=new IndexAndDistance(distance,i);
    }
    Arrays.sort(distances);
    IndexAndDistance closest=distances[distances.length - 1];
    Vec4 closestPoint=verts[closest.index];
    distanceFromEye=closestPoint.distanceTo3(eyePoint);
    for (int i=0; i < size; i++) {
      sortedIndices[i]=distances[i].index;
    }
  }
}","protected void sortIndices(DrawContext dc,Vec4 eyePoint,float[] vertices,int[] indices,int[] sortedIndices){
  int size=vertices.length / 3;
  Vec4[] verts=new Vec4[size];
  for (int i=0, j=0; i < vertices.length; i+=3, j++) {
    verts[j]=new Vec4(vertices[i + 0],vertices[i + 1],vertices[i + 2]);
  }
  if (boundingSphere != null)   eyePoint=eyePoint.subtract3(boundingSphere.getCenter());
  if (mode == GL.GL_TRIANGLES) {
    boolean hasIndices=indices != null;
    int triangleCountBy3=hasIndices ? indices.length : size;
    IndexAndDistance[] distances=new IndexAndDistance[triangleCountBy3 / 3];
    for (int i=0, j=0; i < triangleCountBy3; i+=3, j++) {
      int index0=hasIndices ? indices[i + 0] : i + 0;
      int index1=hasIndices ? indices[i + 1] : i + 1;
      int index2=hasIndices ? indices[i + 2] : i + 2;
      Vec4 v0=verts[index0];
      Vec4 v1=verts[index1];
      Vec4 v2=verts[index2];
      double distance=v0.distanceToSquared3(eyePoint) + v1.distanceToSquared3(eyePoint) + v2.distanceToSquared3(eyePoint);
      distances[j]=new IndexAndDistance(distance,i);
    }
    Arrays.sort(distances);
    IndexAndDistance closest=distances[distances.length - 1];
    Vec4 closestPoint=verts[hasIndices ? indices[closest.index] : closest.index];
    distanceFromEye=closestPoint.distanceTo3(eyePoint);
    for (int i=0, j=0; i < triangleCountBy3; i+=3, j++) {
      IndexAndDistance distance=distances[j];
      sortedIndices[i + 0]=hasIndices ? indices[distance.index + 0] : distance.index + 0;
      sortedIndices[i + 1]=hasIndices ? indices[distance.index + 1] : distance.index + 1;
      sortedIndices[i + 2]=hasIndices ? indices[distance.index + 2] : distance.index + 2;
    }
  }
 else   if (mode == GL.GL_POINTS) {
    IndexAndDistance[] distances=new IndexAndDistance[size];
    for (int i=0; i < size; i++) {
      double distance=verts[i].distanceToSquared3(eyePoint);
      distances[i]=new IndexAndDistance(distance,i);
    }
    Arrays.sort(distances);
    IndexAndDistance closest=distances[distances.length - 1];
    Vec4 closestPoint=verts[closest.index];
    distanceFromEye=closestPoint.distanceTo3(eyePoint);
    for (int i=0; i < size; i++) {
      sortedIndices[i]=distances[i].index;
    }
  }
}",0.9932432432432432
11039,"protected synchronized void resortIndices(final DrawContext dc,final Vec4 eyePoint){
  Runnable runnable=new Runnable(){
    @Override public void run(){
      float[] vertices=vertexVBO.getBuffer();
      if (vertices == null) {
        return;
      }
      int[] indices=indexVBO.getBuffer();
      int size=indices != null ? indices.length : vertices.length / 3;
      int[] sortedIndices=sortedIndexVBO.getBuffer();
      if (sortedIndices == null || sortedIndices.length != size) {
        sortedIndices=new int[size];
      }
      sortIndices(dc,eyePoint,vertices,indices,sortedIndices);
      sortedIndexVBO.setBuffer(sortedIndices);
    }
  }
;
  IndexUpdater.run(this,runnable);
}","protected synchronized void resortIndices(final DrawContext dc,final Vec4 eyePoint){
  Runnable runnable=new Runnable(){
    @Override public void run(){
      float[] vertices=vertexVBO.getBuffer();
      if (vertices == null) {
        return;
      }
      int[] indices=indexVBO.getBuffer();
      int size=indices != null ? indices.length : vertices.length / 3;
      sortedIndexVBO.lock();
      try {
        int[] sortedIndices=sortedIndexVBO.getBuffer();
        if (sortedIndices == null || sortedIndices.length != size) {
          sortedIndices=new int[size];
        }
        sortIndices(dc,eyePoint,vertices,indices,sortedIndices);
        sortedIndexVBO.setBuffer(sortedIndices);
      }
  finally {
        sortedIndexVBO.unlock();
      }
    }
  }
;
  IndexUpdater.run(this,runnable);
}",0.9237967914438504
11040,"@Override public void run(){
  float[] vertices=vertexVBO.getBuffer();
  if (vertices == null) {
    return;
  }
  int[] indices=indexVBO.getBuffer();
  int size=indices != null ? indices.length : vertices.length / 3;
  int[] sortedIndices=sortedIndexVBO.getBuffer();
  if (sortedIndices == null || sortedIndices.length != size) {
    sortedIndices=new int[size];
  }
  sortIndices(dc,eyePoint,vertices,indices,sortedIndices);
  sortedIndexVBO.setBuffer(sortedIndices);
}","@Override public void run(){
  float[] vertices=vertexVBO.getBuffer();
  if (vertices == null) {
    return;
  }
  int[] indices=indexVBO.getBuffer();
  int size=indices != null ? indices.length : vertices.length / 3;
  sortedIndexVBO.lock();
  try {
    int[] sortedIndices=sortedIndexVBO.getBuffer();
    if (sortedIndices == null || sortedIndices.length != size) {
      sortedIndices=new int[size];
    }
    sortIndices(dc,eyePoint,vertices,indices,sortedIndices);
    sortedIndexVBO.setBuffer(sortedIndices);
  }
  finally {
    sortedIndexVBO.unlock();
  }
}",0.9092664092664092
11041,"protected void recalculateVertices(final DrawContext dc,boolean runNow){
  Runnable runnable=new Runnable(){
    @Override public void run(){
      positionsLock.readLock().lock();
      try {
        int size=positions.size() * 3;
        float[] vertices=vertexVBO.getBuffer();
        if (vertices == null || vertices.length != size) {
          vertices=new float[size];
        }
        calculateVertices(dc,vertices);
        vertexVBO.setBuffer(vertices);
        if (willCalculateNormals()) {
          float[] normals=normalVBO.getBuffer();
          if (normals == null || normals.length != size) {
            normals=new float[size];
          }
          calculateNormals(vertices,normals);
          normalVBO.setBuffer(normals);
        }
        Sphere temp=boundingSphere;
        boundingSphere=modBoundingSphere;
        modBoundingSphere=temp;
      }
  finally {
        positionsLock.readLock().unlock();
      }
      if (lastLayer != null && !followTerrain) {
        lastLayer.firePropertyChange(AVKey.LAYER,null,lastLayer);
      }
    }
  }
;
  if (runNow) {
    runnable.run();
  }
 else {
    VertexUpdater.run(this,runnable);
  }
}","protected boolean recalculateVertices(final DrawContext dc,boolean runNow){
  Runnable runnable=new Runnable(){
    @Override public void run(){
      positionsLock.readLock().lock();
      try {
        int size=positions.size() * 3;
        float[] vertices;
        vertexVBO.lock();
        try {
          vertices=vertexVBO.getBuffer();
          if (vertices == null || vertices.length != size) {
            vertices=new float[size];
          }
          calculateVertices(dc,vertices);
          vertexVBO.setBuffer(vertices);
        }
  finally {
          vertexVBO.unlock();
        }
        if (willCalculateNormals()) {
          normalVBO.lock();
          try {
            float[] normals=normalVBO.getBuffer();
            if (normals == null || normals.length != size) {
              normals=new float[size];
            }
            calculateNormals(vertices,normals);
            normalVBO.setBuffer(normals);
          }
  finally {
            normalVBO.unlock();
          }
        }
        Sphere temp=boundingSphere;
        boundingSphere=modBoundingSphere;
        modBoundingSphere=temp;
      }
  finally {
        positionsLock.readLock().unlock();
      }
      if (lastLayer != null) {
        lastLayer.firePropertyChange(AVKey.LAYER,null,lastLayer);
      }
    }
  }
;
  if (runNow) {
    runnable.run();
    return true;
  }
 else {
    return VertexUpdater.run(this,runnable);
  }
}",0.5724217844727694
11042,"protected void recalculateIfRequired(DrawContext dc,double alpha){
  boolean recalculateVertices=isVertexRecalculationRequired(dc) || verticesDirty || lastGlobe != dc.getGlobe();
  if (recalculateVertices) {
    lastGlobe=dc.getGlobe();
    DrawContextDelegateVerticalExaggerationOverride dcve=new DrawContextDelegateVerticalExaggerationOverride(dc);
    dcve.overrideVerticalExaggeration(dc.getVerticalExaggeration());
    recalculateVertices(dcve,false);
    verticesDirty=false;
  }
  Vec4 eyePoint=dc.getView().getEyePoint();
  boolean recalculateIndices=(forceSortedPrimitives || (sortTransparentPrimitives && alpha < 1.0)) && (mode == GL.GL_TRIANGLES || mode == GL.GL_POINTS) && !eyePoint.equals(lastEyePoint);
  if (recalculateIndices) {
    lastEyePoint=eyePoint;
    resortIndices(dc,lastEyePoint);
  }
}","protected void recalculateIfRequired(DrawContext dc,double alpha){
  boolean followTerrainRecalculationRequired=false;
  if (followTerrain) {
    long currentTime=System.currentTimeMillis();
    if (currentTime - lastFollowTerrainUpdateTime > getFollowTerrainUpdateFrequency()) {
      lastFollowTerrainUpdateTime=currentTime;
      followTerrainRecalculationRequired=true;
    }
  }
  boolean recalculateVertices=followTerrainRecalculationRequired || elevationChanged || verticesDirty|| lastGlobe != dc.getGlobe() || VerticalExaggerationAccessor.isVerticalExaggerationChanged(this,dc);
  if (recalculateVertices) {
    boolean willRecalculate=recalculateVertices(dc,false);
    if (willRecalculate) {
      lastGlobe=dc.getGlobe();
      verticesDirty=false;
      elevationChanged=false;
      VerticalExaggerationAccessor.markVerticalExaggeration(this,dc);
    }
  }
  Vec4 eyePoint=dc.getView().getEyePoint();
  boolean recalculateIndices=(forceSortedPrimitives || (sortTransparentPrimitives && alpha < 1.0)) && (mode == GL.GL_TRIANGLES || mode == GL.GL_POINTS) && !eyePoint.equals(lastEyePoint);
  if (recalculateIndices) {
    lastEyePoint=eyePoint;
    resortIndices(dc,lastEyePoint);
  }
}",0.5691542288557214
11043,"protected synchronized void calculateVertices(DrawContext dc,float[] vertices){
  double ve=dc.getVerticalExaggeration();
  int index=0;
  for (  LatLon position : positions) {
    Vec4 v=calculateVertex(dc,position);
    vertices[index++]=(float)v.x;
    vertices[index++]=(float)v.y;
    vertices[index++]=(float)v.z;
    if (ve != dc.getVerticalExaggeration()) {
      System.out.println(ve + ""String_Node_Str"" + dc.getVerticalExaggeration());
    }
  }
  BufferWrapper wrapper=new BufferWrapper.FloatBufferWrapper(FloatBuffer.wrap(vertices));
  modBoundingSphere=createBoundingSphere(wrapper);
  if (modBoundingSphere == null) {
    modBoundingSphere=new Sphere(Vec4.ZERO,1);
  }
  for (int i=0; i < vertices.length; i+=3) {
    vertices[i + 0]-=(float)modBoundingSphere.getCenter().x;
    vertices[i + 1]-=(float)modBoundingSphere.getCenter().y;
    vertices[i + 2]-=(float)modBoundingSphere.getCenter().z;
  }
}","protected synchronized void calculateVertices(DrawContext dc,float[] vertices){
  int index=0;
  for (  LatLon position : positions) {
    Vec4 v=calculateVertex(dc,position);
    vertices[index++]=(float)v.x;
    vertices[index++]=(float)v.y;
    vertices[index++]=(float)v.z;
  }
  BufferWrapper wrapper=new BufferWrapper.FloatBufferWrapper(FloatBuffer.wrap(vertices));
  modBoundingSphere=createBoundingSphere(wrapper);
  if (modBoundingSphere == null) {
    modBoundingSphere=new Sphere(Vec4.ZERO,1);
  }
  for (int i=0; i < vertices.length; i+=3) {
    vertices[i + 0]-=(float)modBoundingSphere.getCenter().x;
    vertices[i + 1]-=(float)modBoundingSphere.getCenter().y;
    vertices[i + 2]-=(float)modBoundingSphere.getCenter().z;
  }
}",0.7293550331525015
11044,"public synchronized void run(Object owner,Runnable runnable){
  OwnerRunnable or=new OwnerRunnable(owner,runnable);
  if (!set.contains(or)) {
    set.add(or);
    queue.add(or);
  }
}","public synchronized boolean run(Object owner,Runnable runnable){
  OwnerRunnable or=new OwnerRunnable(owner,runnable);
  if (!set.contains(or)) {
    set.add(or);
    queue.add(or);
    return true;
  }
  return false;
}",0.8910891089108911
11045,"public synchronized SegmentGeometry getGeometry(DrawContext dc,CurtainTile tile,double top,double bottom,int subsegments,boolean followTerrain){
  MemoryCache cache=WorldWind.getMemoryCache(CACHE_ID);
  TileKey tileKey=tile.getTileKey();
  SegmentGeometry geometry=(SegmentGeometry)cache.getObject(tileKey);
  if (geometry != null && geometry.getTime() >= System.currentTimeMillis() - this.getUpdateFrequency()) {
    return geometry;
  }
  Segment segment=tile.getSegment();
  NavigableMap<Double,LatLon> betweenMap=segmentMap(segment,subsegments);
  int numVertices=betweenMap.size() * 2;
  Globe globe=dc.getGlobe();
  FloatBuffer verts, texCoords;
  if (geometry != null) {
    verts=geometry.getVertices();
    texCoords=geometry.getTexCoords();
  }
 else   if (dc.getGLRuntimeCapabilities().isUseVertexBufferObject()) {
    verts=FloatBuffer.allocate(numVertices * 3);
    texCoords=FloatBuffer.allocate(numVertices * 2);
  }
 else {
    verts=BufferUtil.newFloatBuffer(numVertices * 3);
    texCoords=BufferUtil.newFloatBuffer(numVertices * 2);
  }
  Vec4 refCenter=getSegmentCenterPoint(dc,segment,top,bottom,followTerrain);
  top=VerticalExaggerationAccessor.applyVerticalExaggeration(dc,top);
  bottom=VerticalExaggerationAccessor.applyVerticalExaggeration(dc,bottom);
  double height=top - bottom;
  double t=top - segment.getTop() * height;
  double b=top - segment.getBottom() * height;
  if (t <= b) {
    t=b + 1;
  }
  double percentDistance=segment.getHorizontalDelta();
  for (  Entry<Double,LatLon> entry : betweenMap.entrySet()) {
    LatLon ll=entry.getValue();
    double e=0;
    if (followTerrain) {
      e=globe.getElevation(ll.latitude,ll.longitude) * VerticalExaggerationAccessor.getGlobalVerticalExaggeration(dc);
    }
    Vec4 point1=globe.computePointFromPosition(ll,t + e);
    Vec4 point2=globe.computePointFromPosition(ll,b + e);
    double percent=(entry.getKey() - segment.getStart()) / percentDistance;
    verts.put((float)(point1.x - refCenter.x)).put((float)(point1.y - refCenter.y)).put((float)(point1.z - refCenter.z));
    verts.put((float)(point2.x - refCenter.x)).put((float)(point2.y - refCenter.y)).put((float)(point2.z - refCenter.z));
    texCoords.put((float)percent).put(1f);
    texCoords.put((float)percent).put(0f);
  }
  if (geometry == null) {
    geometry=new SegmentGeometry(dc,verts,texCoords,refCenter);
    cache.add(tileKey,geometry,geometry.getSizeInBytes());
  }
 else {
    geometry.update(dc);
  }
  return geometry;
}","public synchronized SegmentGeometry getGeometry(DrawContext dc,CurtainTile tile,double top,double bottom,int subsegments,boolean followTerrain){
  boolean exaggerationChanged=VerticalExaggerationAccessor.checkAndMarkVerticalExaggeration(this,dc);
  if (exaggerationChanged) {
    exaggerationChangeTime=System.currentTimeMillis();
  }
  MemoryCache cache=WorldWind.getMemoryCache(CACHE_ID);
  TileKey tileKey=tile.getTileKey();
  SegmentGeometry geometry=(SegmentGeometry)cache.getObject(tileKey);
  if (geometry != null && geometry.getTime() >= System.currentTimeMillis() - this.getUpdateFrequency() && geometry.getTime() >= exaggerationChangeTime) {
    return geometry;
  }
  Segment segment=tile.getSegment();
  NavigableMap<Double,LatLon> betweenMap=segmentMap(segment,subsegments);
  int numVertices=betweenMap.size() * 2;
  Globe globe=dc.getGlobe();
  FloatBuffer verts, texCoords;
  if (geometry != null) {
    verts=geometry.getVertices();
    texCoords=geometry.getTexCoords();
  }
 else   if (dc.getGLRuntimeCapabilities().isUseVertexBufferObject()) {
    verts=FloatBuffer.allocate(numVertices * 3);
    texCoords=FloatBuffer.allocate(numVertices * 2);
  }
 else {
    verts=BufferUtil.newFloatBuffer(numVertices * 3);
    texCoords=BufferUtil.newFloatBuffer(numVertices * 2);
  }
  Vec4 refCenter=getSegmentCenterPoint(dc,segment,top,bottom,followTerrain);
  top=VerticalExaggerationAccessor.applyVerticalExaggeration(dc,top);
  bottom=VerticalExaggerationAccessor.applyVerticalExaggeration(dc,bottom);
  double height=top - bottom;
  double t=top - segment.getTop() * height;
  double b=top - segment.getBottom() * height;
  if (t <= b) {
    t=b + 1;
  }
  double percentDistance=segment.getHorizontalDelta();
  for (  Entry<Double,LatLon> entry : betweenMap.entrySet()) {
    LatLon ll=entry.getValue();
    double e=0;
    if (followTerrain) {
      e=globe.getElevation(ll.latitude,ll.longitude) * VerticalExaggerationAccessor.getGlobalVerticalExaggeration(dc);
    }
    Vec4 point1=globe.computePointFromPosition(ll,t + e);
    Vec4 point2=globe.computePointFromPosition(ll,b + e);
    double percent=(entry.getKey() - segment.getStart()) / percentDistance;
    verts.put((float)(point1.x - refCenter.x)).put((float)(point1.y - refCenter.y)).put((float)(point1.z - refCenter.z));
    verts.put((float)(point2.x - refCenter.x)).put((float)(point2.y - refCenter.y)).put((float)(point2.z - refCenter.z));
    texCoords.put((float)percent).put(1f);
    texCoords.put((float)percent).put(0f);
  }
  if (geometry == null) {
    geometry=new SegmentGeometry(dc,verts,texCoords,refCenter);
    cache.add(tileKey,geometry,geometry.getSizeInBytes());
  }
 else {
    geometry.update(dc,refCenter);
  }
  return geometry;
}",0.9524722115753164
11046,"protected void update(DrawContext dc){
  this.time=System.currentTimeMillis();
  if (dc.getGLRuntimeCapabilities().isUseVertexBufferObject()) {
    this.fillVerticesVBO(dc);
  }
}","protected void update(DrawContext dc,Vec4 referenceCenter){
  this.time=System.currentTimeMillis();
  this.referenceCenter=referenceCenter;
  if (dc.getGLRuntimeCapabilities().isUseVertexBufferObject()) {
    this.fillVerticesVBO(dc);
  }
}",0.8544152744630071
11047,"protected IWorker<MutableTreeNode[]> getWorkerInterface(final LazyTreeNode node){
  return new IWorker<MutableTreeNode[]>(){
    @Override public MutableTreeNode[] work() throws Exception {
      return node.loadChildren(model);
    }
    @Override public void done(    MutableTreeNode[] nodes){
      node.setChildren(nodes);
      tree.getUI().relayout();
    }
    @Override public void error(    Exception e){
      node.setErrorLoading(true);
      node.setChildren(createErrorNode(e));
    }
  }
;
}","protected IWorker<MutableTreeNode[]> getWorkerInterface(final LazyTreeNode node){
  return new IWorker<MutableTreeNode[]>(){
    @Override public MutableTreeNode[] work() throws Exception {
      return node.loadChildren(model);
    }
    @Override public void done(    MutableTreeNode[] nodes){
      node.setChildren(nodes);
      tree.getUI().relayout();
      tree.repaint();
    }
    @Override public void error(    Exception e){
      node.setErrorLoading(true);
      node.setChildren(createErrorNode(e));
    }
  }
;
}",0.9786821705426356
11048,"private void fireTreeNodesRemoved(Object source,Object[] path,int[] childIndices,Object[] children){
  TreeModelEvent e=new TreeModelEvent(source,path,childIndices,children);
  for (int i=listeners.size() - 1; i >= 0; i--) {
    listeners.get(i).treeNodesRemoved(e);
  }
}","private void fireTreeNodesRemoved(final Object source,final Object[] path,final int[] childIndices,final Object[] children){
  SwingUtil.invokeLaterTaskOnEDT(new Runnable(){
    @Override public void run(){
      TreeModelEvent e=new TreeModelEvent(source,path,childIndices,children);
      for (int i=listeners.size() - 1; i >= 0; i--) {
        listeners.get(i).treeNodesRemoved(e);
      }
    }
  }
);
}",0.801178203240059
11049,"@Override public void run(){
  tree.getUI().relayout(expand);
  tree.scrollPathToVisible(expand);
}","@Override public void run(){
  TreeModelEvent e=new TreeModelEvent(source,path,childIndices,children);
  for (int i=listeners.size() - 1; i >= 0; i--) {
    listeners.get(i).treeNodesRemoved(e);
  }
}",0.2541806020066889
11050,"protected void fireTreeNodesChanged(Object source,Object[] path,int[] childIndices,Object[] children){
  TreeModelEvent e=new TreeModelEvent(source,path,childIndices,children);
  for (int i=listeners.size() - 1; i >= 0; i--) {
    listeners.get(i).treeNodesChanged(e);
  }
}","protected void fireTreeNodesChanged(final Object source,final Object[] path,final int[] childIndices,final Object[] children){
  SwingUtil.invokeLaterTaskOnEDT(new Runnable(){
    @Override public void run(){
      TreeModelEvent e=new TreeModelEvent(source,path,childIndices,children);
      for (int i=listeners.size() - 1; i >= 0; i--) {
        listeners.get(i).treeNodesChanged(e);
      }
    }
  }
);
}",0.8023426061493412
11051,"private void fireTreeNodesInserted(Object source,Object[] path,int[] childIndices,Object[] children){
  TreeModelEvent e=new TreeModelEvent(source,path,childIndices,children);
  for (int i=listeners.size() - 1; i >= 0; i--) {
    listeners.get(i).treeNodesInserted(e);
  }
}","private void fireTreeNodesInserted(final Object source,final Object[] path,final int[] childIndices,final Object[] children){
  SwingUtil.invokeLaterTaskOnEDT(new Runnable(){
    @Override public void run(){
      TreeModelEvent e=new TreeModelEvent(source,path,childIndices,children);
      for (int i=listeners.size() - 1; i >= 0; i--) {
        listeners.get(i).treeNodesInserted(e);
      }
    }
  }
);
}",0.8023426061493412
11052,"/** 
 * Attempt to open a   {@link Theme} from the given url, and notify the givendelegate when complete.
 * @param url Theme url
 * @param delegate Delegate to notify
 */
public static void openTheme(final URL url,final ThemeOpenDelegate delegate){
  if (url == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  final ProgressMonitor progress=new IndeterminateProgressMonitor(null,""String_Node_Str"",null);
  progress.setMillisToDecideToPopup(0);
  progress.setMillisToPopup(0);
  final ThemeOpenDelegate innerDelegate=new ThemeOpenDelegate(){
    @Override public void opened(    Theme theme,    Element themeElement,    URL themeUrl){
      delegate.opened(theme,themeElement,themeUrl);
    }
  }
;
  Runnable runnable=new Runnable(){
    @Override public void run(){
      try {
        RetrievalResult result=Downloader.downloadImmediatelyIfModified(url,true);
        if (progress.isCanceled()) {
          return;
        }
        InputStream is=result.getAsInputStream();
        Element element=XMLUtil.getElementFromSource(is);
        Theme theme=ThemeFactory.createFromXML(element,url);
        if (theme == null) {
          throw new Exception(""String_Node_Str"");
        }
        progress.close();
        innerDelegate.opened(theme,element,url);
      }
 catch (      Exception e) {
        progress.close();
        int response=(e instanceof HttpException) ? ((HttpException)e).getResponseCode() : -1;
        boolean forbidden=response == 403 || response == 407;
        String message=""String_Node_Str"" + url + ""String_Node_Str""+ e.getLocalizedMessage()+ ""String_Node_Str""+ (forbidden ? ""String_Node_Str"" : ""String_Node_Str"");
        JOptionPane.showMessageDialog(null,message,""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
        openDefault(innerDelegate);
      }
    }
  }
;
  Thread thread=new Thread(runnable);
  thread.start();
}","/** 
 * Attempt to open a   {@link Theme} from the given url, and notify the givendelegate when complete.
 * @param url Theme url
 * @param delegate Delegate to notify
 */
public static void openTheme(final URL url,final ThemeOpenDelegate delegate){
  if (url == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  boolean file=""String_Node_Str"".equalsIgnoreCase(url.getProtocol());
  final ProgressMonitor progress=new IndeterminateProgressMonitor(null,file ? ""String_Node_Str"" : ""String_Node_Str"",null);
  progress.setMillisToDecideToPopup(0);
  progress.setMillisToPopup(0);
  final ThemeOpenDelegate innerDelegate=new ThemeOpenDelegate(){
    @Override public void opened(    Theme theme,    Element themeElement,    URL themeUrl){
      delegate.opened(theme,themeElement,themeUrl);
    }
  }
;
  Runnable runnable=new Runnable(){
    @Override public void run(){
      try {
        RetrievalResult result=Downloader.downloadImmediatelyIfModified(url,true);
        if (progress.isCanceled()) {
          return;
        }
        InputStream is=result.getAsInputStream();
        Element element=XMLUtil.getElementFromSource(is);
        Theme theme=ThemeFactory.createFromXML(element,url);
        if (theme == null) {
          throw new Exception(""String_Node_Str"");
        }
        progress.close();
        innerDelegate.opened(theme,element,url);
      }
 catch (      Exception e) {
        progress.close();
        int response=(e instanceof HttpException) ? ((HttpException)e).getResponseCode() : -1;
        boolean forbidden=response == 403 || response == 407;
        String message=""String_Node_Str"" + url + ""String_Node_Str""+ e.getLocalizedMessage()+ ""String_Node_Str""+ (forbidden ? ""String_Node_Str"" : ""String_Node_Str"");
        JOptionPane.showMessageDialog(null,message,""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
        openDefault(innerDelegate);
      }
    }
  }
;
  Thread thread=new Thread(runnable);
  thread.start();
}",0.9727908784659238
11053,"public synchronized void setPositions(List<LatLon> positions){
  this.positions.clear();
  double[] distances=new double[positions.size()];
  double total=0d;
  for (int i=0; i < positions.size() - 1; i++) {
    Angle distance=LatLon.greatCircleDistance(positions.get(i),positions.get(i + 1));
    distances[i]=distance.radians;
    total+=distance.radians;
  }
  this.length=Angle.fromRadians(total);
  double sum=0d;
  for (int i=0; i < positions.size(); i++) {
    this.positions.put(sum / total,positions.get(i));
    sum+=distances[i];
  }
}","private synchronized void setPositions(List<LatLon> positions){
  this.positions.clear();
  double[] distances=new double[positions.size()];
  double total=0d;
  for (int i=0; i < positions.size() - 1; i++) {
    Angle distance=LatLon.greatCircleDistance(positions.get(i),positions.get(i + 1));
    distances[i]=distance.radians;
    total+=distance.radians;
  }
  this.length=Angle.fromRadians(total);
  double sum=0d;
  for (int i=0; i < positions.size(); i++) {
    this.positions.put(sum / total,positions.get(i));
    sum+=distances[i];
  }
}",0.989935956084172
11054,"public synchronized SegmentGeometry getGeometry(DrawContext dc,CurtainTile tile,double top,double bottom,int subsegments,boolean followTerrain){
  MemoryCache cache=WorldWind.getMemoryCache(CACHE_ID);
  TileKey tileKey=tile.getTileKey();
  SegmentGeometry geometry=(SegmentGeometry)cache.getObject(tileKey);
  if (geometry != null && geometry.getTime() >= System.currentTimeMillis() - this.getUpdateFrequency()) {
    return geometry;
  }
  Segment segment=tile.getSegment();
  NavigableMap<Double,LatLon> betweenMap=segmentMap(segment,subsegments);
  int numVertices=betweenMap.size() * 2;
  Globe globe=dc.getGlobe();
  FloatBuffer verts, texCoords;
  if (dc.getGLRuntimeCapabilities().isUseVertexBufferObject()) {
    verts=FloatBuffer.allocate(numVertices * 3);
    texCoords=FloatBuffer.allocate(numVertices * 2);
  }
 else {
    verts=BufferUtil.newFloatBuffer(numVertices * 3);
    texCoords=BufferUtil.newFloatBuffer(numVertices * 2);
  }
  Vec4 refCenter=getSegmentCenterPoint(dc,segment,top,bottom,followTerrain);
  top=VerticalExaggerationAccessor.applyVerticalExaggeration(dc,top);
  bottom=VerticalExaggerationAccessor.applyVerticalExaggeration(dc,bottom);
  double height=top - bottom;
  double t=top - segment.getTop() * height;
  double b=top - segment.getBottom() * height;
  if (t <= b) {
    t=b + 1;
  }
  double percentDistance=segment.getHorizontalDelta();
  for (  Entry<Double,LatLon> entry : betweenMap.entrySet()) {
    LatLon ll=entry.getValue();
    double e=0;
    if (followTerrain) {
      e=globe.getElevation(ll.latitude,ll.longitude) * VerticalExaggerationAccessor.getGlobalVerticalExaggeration(dc);
    }
    Vec4 point1=globe.computePointFromPosition(ll,t + e);
    Vec4 point2=globe.computePointFromPosition(ll,b + e);
    double percent=(entry.getKey() - segment.getStart()) / percentDistance;
    verts.put((float)(point1.x - refCenter.x)).put((float)(point1.y - refCenter.y)).put((float)(point1.z - refCenter.z));
    verts.put((float)(point2.x - refCenter.x)).put((float)(point2.y - refCenter.y)).put((float)(point2.z - refCenter.z));
    texCoords.put((float)percent).put(1f);
    texCoords.put((float)percent).put(0f);
  }
  geometry=new SegmentGeometry(dc,verts,texCoords,refCenter);
  cache.add(tileKey,geometry,geometry.getSizeInBytes());
  return geometry;
}","public synchronized SegmentGeometry getGeometry(DrawContext dc,CurtainTile tile,double top,double bottom,int subsegments,boolean followTerrain){
  MemoryCache cache=WorldWind.getMemoryCache(CACHE_ID);
  TileKey tileKey=tile.getTileKey();
  SegmentGeometry geometry=(SegmentGeometry)cache.getObject(tileKey);
  if (geometry != null && geometry.getTime() >= System.currentTimeMillis() - this.getUpdateFrequency()) {
    return geometry;
  }
  Segment segment=tile.getSegment();
  NavigableMap<Double,LatLon> betweenMap=segmentMap(segment,subsegments);
  int numVertices=betweenMap.size() * 2;
  Globe globe=dc.getGlobe();
  FloatBuffer verts, texCoords;
  if (geometry != null) {
    verts=geometry.getVertices();
    texCoords=geometry.getTexCoords();
  }
 else   if (dc.getGLRuntimeCapabilities().isUseVertexBufferObject()) {
    verts=FloatBuffer.allocate(numVertices * 3);
    texCoords=FloatBuffer.allocate(numVertices * 2);
  }
 else {
    verts=BufferUtil.newFloatBuffer(numVertices * 3);
    texCoords=BufferUtil.newFloatBuffer(numVertices * 2);
  }
  Vec4 refCenter=getSegmentCenterPoint(dc,segment,top,bottom,followTerrain);
  top=VerticalExaggerationAccessor.applyVerticalExaggeration(dc,top);
  bottom=VerticalExaggerationAccessor.applyVerticalExaggeration(dc,bottom);
  double height=top - bottom;
  double t=top - segment.getTop() * height;
  double b=top - segment.getBottom() * height;
  if (t <= b) {
    t=b + 1;
  }
  double percentDistance=segment.getHorizontalDelta();
  for (  Entry<Double,LatLon> entry : betweenMap.entrySet()) {
    LatLon ll=entry.getValue();
    double e=0;
    if (followTerrain) {
      e=globe.getElevation(ll.latitude,ll.longitude) * VerticalExaggerationAccessor.getGlobalVerticalExaggeration(dc);
    }
    Vec4 point1=globe.computePointFromPosition(ll,t + e);
    Vec4 point2=globe.computePointFromPosition(ll,b + e);
    double percent=(entry.getKey() - segment.getStart()) / percentDistance;
    verts.put((float)(point1.x - refCenter.x)).put((float)(point1.y - refCenter.y)).put((float)(point1.z - refCenter.z));
    verts.put((float)(point2.x - refCenter.x)).put((float)(point2.y - refCenter.y)).put((float)(point2.z - refCenter.z));
    texCoords.put((float)percent).put(1f);
    texCoords.put((float)percent).put(0f);
  }
  if (geometry == null) {
    geometry=new SegmentGeometry(dc,verts,texCoords,refCenter);
    cache.add(tileKey,geometry,geometry.getSizeInBytes());
  }
 else {
    geometry.update(dc);
  }
  return geometry;
}",0.9553235908141964
11055,"/** 
 * Recalculate any surfaces that require recalculation. This includes regenerating textures when the user has dragged a surface to a different slice.
 */
protected void recalculateSurfaces(){
  if (!dataAvailable) {
    return;
  }
  minLonOffset=Util.clamp(minLonOffset,0,dataProvider.getXSize() - 1);
  maxLonOffset=Util.clamp(maxLonOffset,0,dataProvider.getXSize() - 1 - minLonOffset);
  minLatOffset=Util.clamp(minLatOffset,0,dataProvider.getYSize() - 1);
  maxLatOffset=Util.clamp(maxLatOffset,0,dataProvider.getYSize() - 1 - minLatOffset);
  topOffset=Util.clamp(topOffset,0,dataProvider.getZSize() - 1);
  bottomOffset=Util.clamp(bottomOffset,0,dataProvider.getZSize() - 1 - topOffset);
  int maxLonSlice=dataProvider.getXSize() - 1 - maxLonOffset;
  int maxLatSlice=dataProvider.getYSize() - 1 - maxLatOffset;
  int bottomSlice=dataProvider.getZSize() - 1 - bottomOffset;
  boolean recalculateMinLon=lastMinLonOffset != minLonOffset;
  boolean recalculateMaxLon=lastMaxLonOffset != maxLonOffset;
  boolean recalculateMinLat=lastMinLatOffset != minLatOffset;
  boolean recalculateMaxLat=lastMaxLatOffset != maxLatOffset;
  boolean recalculateTop=lastTopOffset != topOffset;
  boolean recalculateBottom=lastBottomOffset != bottomOffset;
  Rectangle lonRectangle=new Rectangle(0,0,dataProvider.getYSize(),dataProvider.getZSize());
  Rectangle latRectangle=new Rectangle(0,0,dataProvider.getXSize(),dataProvider.getZSize());
  Rectangle elevationRectangle=new Rectangle(0,0,dataProvider.getXSize(),dataProvider.getYSize());
  double topPercent=topOffset / (double)Math.max(dataProvider.getZSize() - 1,1);
  double bottomPercent=bottomSlice / (double)Math.max(dataProvider.getZSize() - 1,1);
  if (recalculateMinLon) {
    minLonClipDirty=true;
    TopBottomFastShape newMinLonCurtain=dataProvider.createLongitudeCurtain(minLonOffset);
    minLonCurtain.setPositions(newMinLonCurtain.getPositions());
    updateTexture(generateTexture(0,minLonOffset,lonRectangle),minLonTexture,minLonCurtain);
    lastMinLonOffset=minLonOffset;
  }
  if (recalculateMaxLon) {
    maxLonClipDirty=true;
    TopBottomFastShape newMaxLonCurtain=dataProvider.createLongitudeCurtain(dataProvider.getXSize() - 1 - maxLonOffset);
    maxLonCurtain.setPositions(newMaxLonCurtain.getPositions());
    updateTexture(generateTexture(0,maxLonSlice,lonRectangle),maxLonTexture,maxLonCurtain);
    lastMaxLonOffset=maxLonOffset;
  }
  if (recalculateMinLat) {
    minLatClipDirty=true;
    TopBottomFastShape newMinLatCurtain=dataProvider.createLatitudeCurtain(minLatOffset);
    minLatCurtain.setPositions(newMinLatCurtain.getPositions());
    updateTexture(generateTexture(1,minLatOffset,latRectangle),minLatTexture,minLatCurtain);
    lastMinLatOffset=minLatOffset;
  }
  if (recalculateMaxLat) {
    maxLatClipDirty=true;
    TopBottomFastShape newMaxLatCurtain=dataProvider.createLatitudeCurtain(dataProvider.getYSize() - 1 - maxLatOffset);
    maxLatCurtain.setPositions(newMaxLatCurtain.getPositions());
    updateTexture(generateTexture(1,maxLatSlice,latRectangle),maxLatTexture,maxLatCurtain);
    lastMaxLatOffset=maxLatOffset;
  }
  if (recalculateTop) {
    topClipDirty=true;
    double elevation=-dataProvider.getDepth() * topPercent;
    updateTexture(generateTexture(2,topOffset,elevationRectangle),topTexture,topSurface);
    lastTopOffset=topOffset;
    topSurface.setElevation(elevation);
    minLonCurtain.setTopElevationOffset(elevation);
    maxLonCurtain.setTopElevationOffset(elevation);
    minLatCurtain.setTopElevationOffset(elevation);
    maxLatCurtain.setTopElevationOffset(elevation);
    recalculateTextureMatrix(topPercent,bottomPercent);
  }
  if (recalculateBottom) {
    bottomClipDirty=true;
    double elevation=-dataProvider.getDepth() * bottomPercent;
    updateTexture(generateTexture(2,bottomSlice,elevationRectangle),bottomTexture,bottomSurface);
    lastBottomOffset=bottomOffset;
    bottomSurface.setElevation(elevation);
    minLonCurtain.setBottomElevationOffset(elevation);
    maxLonCurtain.setBottomElevationOffset(elevation);
    minLatCurtain.setBottomElevationOffset(elevation);
    maxLatCurtain.setBottomElevationOffset(elevation);
    recalculateTextureMatrix(topPercent,bottomPercent);
  }
}","/** 
 * Recalculate any surfaces that require recalculation. This includes regenerating textures when the user has dragged a surface to a different slice.
 */
protected void recalculateSurfaces(){
  if (!dataAvailable) {
    return;
  }
  int xSize=dataProvider.getXSize();
  int ySize=dataProvider.getYSize();
  int zSize=dataProvider.getZSize();
  minLonOffset=Util.clamp(minLonOffset,0,xSize - 1);
  maxLonOffset=Util.clamp(maxLonOffset,0,xSize - 1 - minLonOffset);
  minLatOffset=Util.clamp(minLatOffset,0,ySize - 1);
  maxLatOffset=Util.clamp(maxLatOffset,0,ySize - 1 - minLatOffset);
  topOffset=Util.clamp(topOffset,0,zSize - 1);
  bottomOffset=Util.clamp(bottomOffset,0,zSize - 1 - topOffset);
  int maxLonSlice=xSize - 1 - maxLonOffset;
  int maxLatSlice=ySize - 1 - maxLatOffset;
  int bottomSlice=zSize - 1 - bottomOffset;
  boolean recalculateMinLon=lastMinLonOffset != minLonOffset;
  boolean recalculateMaxLon=lastMaxLonOffset != maxLonOffset;
  boolean recalculateMinLat=lastMinLatOffset != minLatOffset;
  boolean recalculateMaxLat=lastMaxLatOffset != maxLatOffset;
  boolean recalculateTop=lastTopOffset != topOffset;
  boolean recalculateBottom=lastBottomOffset != bottomOffset;
  Rectangle lonRectangle=new Rectangle(0,0,ySize,zSize);
  Rectangle latRectangle=new Rectangle(0,0,xSize,zSize);
  Rectangle elevationRectangle=new Rectangle(0,0,xSize,ySize);
  double topPercent=topOffset / (double)Math.max(zSize - 1,1);
  double bottomPercent=bottomSlice / (double)Math.max(zSize - 1,1);
  if (recalculateMinLon) {
    minLonClipDirty=true;
    TopBottomFastShape newMinLonCurtain=dataProvider.createLongitudeCurtain(minLonOffset);
    minLonCurtain.setPositions(newMinLonCurtain.getPositions());
    updateTexture(generateTexture(0,minLonOffset,lonRectangle),minLonTexture,minLonCurtain);
    lastMinLonOffset=minLonOffset;
  }
  if (recalculateMaxLon) {
    maxLonClipDirty=true;
    TopBottomFastShape newMaxLonCurtain=dataProvider.createLongitudeCurtain(xSize - 1 - maxLonOffset);
    maxLonCurtain.setPositions(newMaxLonCurtain.getPositions());
    updateTexture(generateTexture(0,maxLonSlice,lonRectangle),maxLonTexture,maxLonCurtain);
    lastMaxLonOffset=maxLonOffset;
  }
  if (recalculateMinLat) {
    minLatClipDirty=true;
    TopBottomFastShape newMinLatCurtain=dataProvider.createLatitudeCurtain(minLatOffset);
    minLatCurtain.setPositions(newMinLatCurtain.getPositions());
    updateTexture(generateTexture(1,minLatOffset,latRectangle),minLatTexture,minLatCurtain);
    lastMinLatOffset=minLatOffset;
  }
  if (recalculateMaxLat) {
    maxLatClipDirty=true;
    TopBottomFastShape newMaxLatCurtain=dataProvider.createLatitudeCurtain(ySize - 1 - maxLatOffset);
    maxLatCurtain.setPositions(newMaxLatCurtain.getPositions());
    updateTexture(generateTexture(1,maxLatSlice,latRectangle),maxLatTexture,maxLatCurtain);
    lastMaxLatOffset=maxLatOffset;
  }
  if (recalculateTop) {
    topClipDirty=true;
    double elevation=-dataProvider.getDepth() * topPercent;
    updateTexture(generateTexture(2,topOffset,elevationRectangle),topTexture,topSurface);
    lastTopOffset=topOffset;
    topSurface.setElevation(elevation);
    minLonCurtain.setTopElevationOffset(elevation);
    maxLonCurtain.setTopElevationOffset(elevation);
    minLatCurtain.setTopElevationOffset(elevation);
    maxLatCurtain.setTopElevationOffset(elevation);
    recalculateTextureMatrix(topPercent,bottomPercent);
  }
  if (recalculateBottom) {
    bottomClipDirty=true;
    double elevation=-dataProvider.getDepth() * bottomPercent;
    updateTexture(generateTexture(2,bottomSlice,elevationRectangle),bottomTexture,bottomSurface);
    lastBottomOffset=bottomOffset;
    bottomSurface.setElevation(elevation);
    minLonCurtain.setBottomElevationOffset(elevation);
    maxLonCurtain.setBottomElevationOffset(elevation);
    minLatCurtain.setBottomElevationOffset(elevation);
    maxLatCurtain.setBottomElevationOffset(elevation);
    recalculateTextureMatrix(topPercent,bottomPercent);
  }
}",0.111394868053022
11056,"/** 
 * Insert a clipping plane vector into the given array. The vector is calculated by finding a plane that intersects the three given points.
 * @param clippingPlaneArray Array to insert clipping plane vector into
 * @param arrayOffset Array start offset to begin inserting values at
 * @param v1 First point that the plane must intersect
 * @param v2 Second point that the plane must intersect
 * @param v3 Third point that the plane must intersect
 */
protected void insertClippingPlaneForPoints(double[] clippingPlaneArray,int arrayOffset,Vec4 v1,Vec4 v2,Vec4 v3){
  Line l1=Line.fromSegment(v1,v3);
  Line l2=Line.fromSegment(v1,v2);
  Plane plane=GeometryUtil.createPlaneContainingLines(l1,l2);
  Vec4 v=plane.getVector();
  clippingPlaneArray[arrayOffset + 0]=v.x;
  clippingPlaneArray[arrayOffset + 1]=v.y;
  clippingPlaneArray[arrayOffset + 2]=v.z;
  clippingPlaneArray[arrayOffset + 3]=v.w;
}","/** 
 * Insert a clipping plane vector into the given array. The vector is calculated by finding a plane that intersects the three given points.
 * @param clippingPlaneArray Array to insert clipping plane vector into
 * @param arrayOffset Array start offset to begin inserting values at
 * @param v1 First point that the plane must intersect
 * @param v2 Second point that the plane must intersect
 * @param v3 Third point that the plane must intersect
 */
protected void insertClippingPlaneForPoints(double[] clippingPlaneArray,int arrayOffset,Vec4 v1,Vec4 v2,Vec4 v3){
  if (v1 == null || v2 == null || v3 == null || v1.equals(v2) || v1.equals(v3)) {
    return;
  }
  Line l1=Line.fromSegment(v1,v3);
  Line l2=Line.fromSegment(v1,v2);
  Plane plane=GeometryUtil.createPlaneContainingLines(l1,l2);
  Vec4 v=plane.getVector();
  clippingPlaneArray[arrayOffset + 0]=v.x;
  clippingPlaneArray[arrayOffset + 1]=v.y;
  clippingPlaneArray[arrayOffset + 2]=v.z;
  clippingPlaneArray[arrayOffset + 3]=v.w;
}",0.9485834207764952
11057,"@Override protected boolean doLoadData(URL url,VolumeLayer layer){
  ZipFile zip=null;
  try {
    File file=URLUtil.urlToFile(url);
    InputStream sgInputStream=null;
    try {
      if (file.getName().toLowerCase().endsWith(""String_Node_Str"")) {
        zip=new ZipFile(file);
        Enumeration<? extends ZipEntry> entries=zip.entries();
        ZipEntry sgEntry=null;
        while (entries.hasMoreElements()) {
          ZipEntry entry=entries.nextElement();
          if (entry.getName().toLowerCase().endsWith(""String_Node_Str"")) {
            sgEntry=entry;
            break;
          }
        }
        if (sgEntry == null) {
          throw new IOException(""String_Node_Str"");
        }
        sgInputStream=zip.getInputStream(sgEntry);
      }
 else {
        sgInputStream=new FileInputStream(file);
      }
      BufferedReader reader=new BufferedReader(new InputStreamReader(sgInputStream));
      String line;
      while ((line=reader.readLine()) != null) {
        parseLine(line);
      }
    }
  finally {
      if (sgInputStream != null) {
        sgInputStream.close();
      }
    }
    if (asciiDataFile == null) {
      throw new IOException(""String_Node_Str"");
    }
    if (xSize == 0 || ySize == 0 || zSize == 0) {
      throw new IOException(""String_Node_Str"");
    }
    if (cellCentered) {
      xSize--;
      ySize--;
      zSize--;
    }
    InputStream dataInputStream=null;
    try {
      if (zip != null) {
        ZipEntry dataEntry=zip.getEntry(asciiDataFile);
        dataInputStream=zip.getInputStream(dataEntry);
      }
      if (dataInputStream == null) {
        File data=new File(file.getParent(),asciiDataFile);
        if (data.exists()) {
          dataInputStream=new FileInputStream(data);
        }
      }
      if (dataInputStream == null) {
        throw new IOException(""String_Node_Str"" + asciiDataFile + ""String_Node_Str"");
      }
      sector=null;
      double[] transformed=new double[3];
      CoordinateTransformation transformation=layer.getCoordinateTransformation();
      positions=new ArrayList<Position>(xSize * ySize);
      int positionIndex=0;
      double firstXValue=0, firstYValue=0, firstZValue=0;
      data=FloatBuffer.allocate(xSize * ySize * zSize);
      top=0;
      minValue=Float.MAX_VALUE;
      maxValue=-Float.MAX_VALUE;
      String doublePattern=""String_Node_Str"";
      String nonCapturingDoublePattern=""String_Node_Str"";
      String spacerPattern=""String_Node_Str"";
      String lineRegex=""String_Node_Str"" + doublePattern + spacerPattern+ doublePattern+ spacerPattern+ doublePattern;
      for (int property=1; property < paintedVariableId; property++) {
        lineRegex+=spacerPattern + nonCapturingDoublePattern;
      }
      lineRegex+=spacerPattern + doublePattern + ""String_Node_Str"";
      Pattern linePattern=Pattern.compile(lineRegex);
      BufferedReader reader=new BufferedReader(new InputStreamReader(dataInputStream));
      String line;
      while ((line=reader.readLine()) != null) {
        Matcher matcher=linePattern.matcher(line);
        if (matcher.matches()) {
          double x=Double.parseDouble(matcher.group(1));
          double y=Double.parseDouble(matcher.group(2));
          double z=Double.parseDouble(matcher.group(3));
          float value=Float.parseFloat(matcher.group(4));
          if (transformation != null) {
            transformation.TransformPoint(transformed,x,y,z);
            x=transformed[0];
            y=transformed[1];
            z=transformed[2];
          }
          if (positionIndex < xSize * ySize) {
            Position position=Position.fromDegrees(y,x,z);
            positions.add(position);
            top+=z / (double)(xSize * ySize);
            if (sector == null) {
              sector=new Sector(position.latitude,position.latitude,position.longitude,position.longitude);
            }
 else {
              sector=sector.union(position.latitude,position.longitude);
            }
          }
          if (positionIndex == 0) {
            firstXValue=x;
            firstYValue=y;
            firstZValue=z;
          }
 else           if (positionIndex == 1) {
            reverseX=x < firstXValue;
          }
 else           if (positionIndex == xSize) {
            reverseY=y < firstYValue;
          }
 else           if (positionIndex == xSize * ySize * (zSize - 1)) {
            reverseZ=z > firstZValue;
            depth=reverseZ ? z - firstZValue : firstZValue - z;
            top+=reverseZ ? depth : 0;
          }
          data.put(value);
          minValue=Math.min(minValue,value);
          maxValue=Math.max(maxValue,value);
          positionIndex++;
        }
      }
      if (positions.size() != xSize * ySize) {
        throw new IOException(""String_Node_Str"");
      }
      if (reverseX || reverseY || reverseZ) {
        if (reverseZ) {
          List<Position> oldPositions=positions;
          positions=new ArrayList<Position>(oldPositions.size());
          for (          Position position : oldPositions) {
            positions.add(new Position(position,position.elevation + depth));
          }
        }
        if (reverseX || reverseY) {
          List<Position> oldPositions=positions;
          positions=new ArrayList<Position>(oldPositions.size());
          for (int y=0; y < ySize; y++) {
            int ry=reverseY ? ySize - y - 1 : y;
            for (int x=0; x < xSize; x++) {
              int rx=reverseX ? xSize - x - 1 : x;
              positions.add(oldPositions.get(rx + ry * xSize));
            }
          }
        }
      }
    }
  finally {
      if (dataInputStream != null) {
        dataInputStream.close();
      }
    }
  }
 catch (  IOException e) {
    e.printStackTrace();
    return false;
  }
 finally {
    if (zip != null) {
      try {
        zip.close();
      }
 catch (      IOException e) {
      }
    }
  }
  layer.dataAvailable(this);
  return true;
}","@Override protected boolean doLoadData(URL url,VolumeLayer layer){
  ZipFile zip=null;
  try {
    File file=URLUtil.urlToFile(url);
    InputStream sgInputStream=null;
    try {
      if (file.getName().toLowerCase().endsWith(""String_Node_Str"")) {
        zip=new ZipFile(file);
        Enumeration<? extends ZipEntry> entries=zip.entries();
        ZipEntry sgEntry=null;
        while (entries.hasMoreElements()) {
          ZipEntry entry=entries.nextElement();
          if (entry.getName().toLowerCase().endsWith(""String_Node_Str"")) {
            sgEntry=entry;
            break;
          }
        }
        if (sgEntry == null) {
          throw new IOException(""String_Node_Str"");
        }
        sgInputStream=zip.getInputStream(sgEntry);
      }
 else {
        sgInputStream=new FileInputStream(file);
      }
      BufferedReader reader=new BufferedReader(new InputStreamReader(sgInputStream));
      String line;
      while ((line=reader.readLine()) != null) {
        parseLine(line);
      }
    }
  finally {
      if (sgInputStream != null) {
        sgInputStream.close();
      }
    }
    if (asciiDataFile == null) {
      throw new IOException(""String_Node_Str"");
    }
    if (cellCentered) {
      xSize--;
      ySize--;
      zSize--;
    }
    if (xSize == 0 || ySize == 0 || zSize == 0) {
      throw new IOException(""String_Node_Str"");
    }
    InputStream dataInputStream=null;
    try {
      if (zip != null) {
        ZipEntry dataEntry=zip.getEntry(asciiDataFile);
        dataInputStream=zip.getInputStream(dataEntry);
      }
      if (dataInputStream == null) {
        File data=new File(file.getParent(),asciiDataFile);
        if (data.exists()) {
          dataInputStream=new FileInputStream(data);
        }
      }
      if (dataInputStream == null) {
        throw new IOException(""String_Node_Str"" + asciiDataFile + ""String_Node_Str"");
      }
      sector=null;
      double[] transformed=new double[3];
      CoordinateTransformation transformation=layer.getCoordinateTransformation();
      positions=new ArrayList<Position>(xSize * ySize);
      int positionIndex=0;
      double firstXValue=0, firstYValue=0, firstZValue=0;
      data=FloatBuffer.allocate(xSize * ySize * zSize);
      top=0;
      minValue=Float.MAX_VALUE;
      maxValue=-Float.MAX_VALUE;
      String doublePattern=""String_Node_Str"";
      String nonCapturingDoublePattern=""String_Node_Str"";
      String spacerPattern=""String_Node_Str"";
      String lineRegex=""String_Node_Str"" + doublePattern + spacerPattern+ doublePattern+ spacerPattern+ doublePattern;
      for (int property=1; property < paintedVariableId; property++) {
        lineRegex+=spacerPattern + nonCapturingDoublePattern;
      }
      lineRegex+=spacerPattern + doublePattern + ""String_Node_Str"";
      Pattern linePattern=Pattern.compile(lineRegex);
      BufferedReader reader=new BufferedReader(new InputStreamReader(dataInputStream));
      String line;
      while ((line=reader.readLine()) != null) {
        Matcher matcher=linePattern.matcher(line);
        if (matcher.matches()) {
          double x=Double.parseDouble(matcher.group(1));
          double y=Double.parseDouble(matcher.group(2));
          double z=Double.parseDouble(matcher.group(3));
          float value=Float.parseFloat(matcher.group(4));
          if (transformation != null) {
            transformation.TransformPoint(transformed,x,y,z);
            x=transformed[0];
            y=transformed[1];
            z=transformed[2];
          }
          if (positionIndex < xSize * ySize) {
            Position position=Position.fromDegrees(y,x,z);
            positions.add(position);
            top+=z / (double)(xSize * ySize);
            if (sector == null) {
              sector=new Sector(position.latitude,position.latitude,position.longitude,position.longitude);
            }
 else {
              sector=sector.union(position.latitude,position.longitude);
            }
          }
          if (positionIndex == 0) {
            firstXValue=x;
            firstYValue=y;
            firstZValue=z;
          }
 else           if (positionIndex == 1) {
            reverseX=x < firstXValue;
          }
 else           if (positionIndex == xSize) {
            reverseY=y < firstYValue;
          }
 else           if (positionIndex == xSize * ySize * (zSize - 1)) {
            reverseZ=z > firstZValue;
            depth=reverseZ ? z - firstZValue : firstZValue - z;
            top+=reverseZ ? depth : 0;
          }
          data.put(value);
          minValue=Math.min(minValue,value);
          maxValue=Math.max(maxValue,value);
          positionIndex++;
        }
      }
      if (positions.size() != xSize * ySize) {
        throw new IOException(""String_Node_Str"");
      }
      if (reverseX || reverseY || reverseZ) {
        if (reverseZ) {
          List<Position> oldPositions=positions;
          positions=new ArrayList<Position>(oldPositions.size());
          for (          Position position : oldPositions) {
            positions.add(new Position(position,position.elevation + depth));
          }
        }
        if (reverseX || reverseY) {
          List<Position> oldPositions=positions;
          positions=new ArrayList<Position>(oldPositions.size());
          for (int y=0; y < ySize; y++) {
            int ry=reverseY ? ySize - y - 1 : y;
            for (int x=0; x < xSize; x++) {
              int rx=reverseX ? xSize - x - 1 : x;
              positions.add(oldPositions.get(rx + ry * xSize));
            }
          }
        }
      }
    }
  finally {
      if (dataInputStream != null) {
        dataInputStream.close();
      }
    }
  }
 catch (  IOException e) {
    e.printStackTrace();
    return false;
  }
 finally {
    if (zip != null) {
      try {
        zip.close();
      }
 catch (      IOException e) {
      }
    }
  }
  layer.dataAvailable(this);
  return true;
}",0.9873267995944576
11058,"protected void parseLine(String line){
  Matcher matcher=paintedVariablePattern.matcher(line);
  if (matcher.matches()) {
    paintedVariableName=matcher.group(1);
  }
  matcher=axisPattern.matcher(line);
  if (matcher.matches()) {
    if (matcher.group(1).equals(""String_Node_Str"")) {
      xSize=(int)Double.parseDouble(matcher.group(2));
      ySize=(int)Double.parseDouble(matcher.group(3));
      zSize=(int)Double.parseDouble(matcher.group(4));
    }
  }
  matcher=propAlignmentPattern.matcher(line);
  if (matcher.matches()) {
    String propAlignment=matcher.group(1);
    cellCentered=propAlignment.toLowerCase().equals(""String_Node_Str"");
  }
  matcher=asciiDataFilePattern.matcher(line);
  if (matcher.matches()) {
    asciiDataFile=matcher.group(1);
  }
  matcher=propertyNamePattern.matcher(line);
  if (matcher.matches()) {
    int propertyId=Integer.parseInt(matcher.group(1));
    String propertyName=matcher.group(2);
    if (propertyName.equals(paintedVariableName)) {
      paintedVariableId=propertyId;
    }
  }
  matcher=propertyNoDataPattern.matcher(line);
  if (matcher.matches()) {
    int propertyId=Integer.parseInt(matcher.group(1));
    float noDataValue=Float.parseFloat(matcher.group(2));
    if (propertyId == paintedVariableId) {
      this.noDataValue=noDataValue;
    }
  }
}","protected void parseLine(String line){
  Matcher matcher=paintedVariablePattern.matcher(line);
  if (matcher.matches()) {
    paintedVariableName=matcher.group(1);
    return;
  }
  matcher=axisPattern.matcher(line);
  if (matcher.matches()) {
    if (matcher.group(1).equals(""String_Node_Str"")) {
      xSize=(int)Double.parseDouble(matcher.group(2));
      ySize=(int)Double.parseDouble(matcher.group(3));
      zSize=(int)Double.parseDouble(matcher.group(4));
    }
    return;
  }
  matcher=propAlignmentPattern.matcher(line);
  if (matcher.matches()) {
    String propAlignment=matcher.group(1);
    cellCentered=propAlignment.toLowerCase().equals(""String_Node_Str"");
    return;
  }
  matcher=asciiDataFilePattern.matcher(line);
  if (matcher.matches()) {
    asciiDataFile=matcher.group(1);
    return;
  }
  matcher=propertyNamePattern.matcher(line);
  if (matcher.matches()) {
    int propertyId=Integer.parseInt(matcher.group(1));
    String propertyName=matcher.group(2);
    if (propertyName.equals(paintedVariableName)) {
      paintedVariableId=propertyId;
    }
    return;
  }
  matcher=propertyNoDataPattern.matcher(line);
  if (matcher.matches()) {
    int propertyId=Integer.parseInt(matcher.group(1));
    float noDataValue=Float.parseFloat(matcher.group(2));
    if (propertyId == paintedVariableId) {
      this.noDataValue=noDataValue;
    }
    return;
  }
}",0.9732540861812778
11059,"@Test public void testSave() throws Exception {
  INode root=createNodeTree();
  Document document=LayerTreePersistance.saveToDocument(root);
  String result=getFormattedXml(document);
  String expected=TestUtils.readStreamToString(getClass().getResourceAsStream(""String_Node_Str""));
  assertEquals(convertLineBreaks(expected.trim()),convertLineBreaks(result.trim()));
}","@Test public void testSave() throws Exception {
  INode root=createNodeTree();
  Document document=LayerTreePersistance.saveToDocument(root);
  String result=getFormattedXml(document);
  String expected=TestUtils.readStreamToString(getClass().getResourceAsStream(""String_Node_Str""));
  assertEquals(removeXmlDeclaration(convertLineBreaks(expected.trim())),removeXmlDeclaration(convertLineBreaks(result.trim())));
}",0.9438775510204082
11060,"@Override public void afterRetrieve(Retriever retriever){
  SectorPolyline s=retrievingLines.get(retriever);
  if (s != null) {
    removeRenderable(s);
    firePropertyChange(AVKey.LAYER,null,this);
  }
}","@Override public void afterRetrieve(Retriever retriever){
  SectorPolyline s=retrievingLines.remove(retriever);
  if (s != null) {
    removeRenderable(s);
    firePropertyChange(AVKey.LAYER,null,this);
  }
}",0.9782082324455206
11061,"@Override public void addLine(String line){
  Matcher matcher;
  matcher=vertexPattern.matcher(line);
  if (matcher.matches()) {
    int id=Integer.parseInt(matcher.group(1));
    if (vertexIdMap.containsKey(id)) {
      throw new IllegalArgumentException(""String_Node_Str"" + id);
    }
    double x=Double.parseDouble(matcher.group(2));
    double y=Double.parseDouble(matcher.group(3));
    double z=Double.parseDouble(matcher.group(4));
    z=zPositive ? z : -z;
    if (parameters.getCoordinateTransformation() != null) {
      double[] transformed=new double[3];
      parameters.getCoordinateTransformation().TransformPoint(transformed,x,y,z);
      x=transformed[0];
      y=transformed[1];
      z=transformed[2];
    }
    Position position=Position.fromDegrees(y,x,z);
    vertexIdMap.put(id,positions.size());
    positions.add(position);
    float value=Float.NaN;
    if (paintedVariableId <= 0) {
      value=(float)z;
    }
 else {
      double[] values=splitStringToDoubles(matcher.group(5));
      if (paintedVariableId <= values.length) {
        value=(float)values[paintedVariableId - 1];
      }
    }
    if (!Float.isNaN(value) && value != noDataValue) {
      min=Math.min(min,value);
      max=Math.max(max,value);
    }
    values.add(value);
    return;
  }
  matcher=atomPattern.matcher(line);
  if (matcher.matches()) {
    int id1=Integer.parseInt(matcher.group(1));
    int id2=Integer.parseInt(matcher.group(2));
    if (vertexIdMap.containsKey(id1)) {
      throw new IllegalArgumentException(""String_Node_Str"" + id1);
    }
    if (!vertexIdMap.containsKey(id2)) {
      throw new IllegalArgumentException(""String_Node_Str"" + id2);
    }
    Position position=positions.get(vertexIdMap.get(id2));
    vertexIdMap.put(id1,positions.size());
    positions.add(position);
    float value=Float.NaN;
    if (paintedVariableId <= 0) {
      value=(float)position.elevation;
    }
 else {
      double[] values=splitStringToDoubles(matcher.group(3));
      if (paintedVariableId <= values.length) {
        value=(float)values[paintedVariableId - 1];
      }
    }
    if (!Float.isNaN(value) && value != noDataValue) {
      min=Math.min(min,value);
      max=Math.max(max,value);
    }
    values.add(value);
    return;
  }
  matcher=trianglePattern.matcher(line);
  if (matcher.matches()) {
    int t1=Integer.parseInt(matcher.group(1));
    int t2=Integer.parseInt(matcher.group(2));
    int t3=Integer.parseInt(matcher.group(3));
    triangleIds.add(t1);
    triangleIds.add(t2);
    triangleIds.add(t3);
    return;
  }
  matcher=colorPattern.matcher(line);
  if (matcher.matches()) {
    color=GocadColor.gocadLineToColor(line);
    return;
  }
  matcher=namePattern.matcher(line);
  if (matcher.matches()) {
    name=matcher.group(1);
    return;
  }
  matcher=zpositivePattern.matcher(line);
  if (matcher.matches()) {
    zPositive=!matcher.group(1).equalsIgnoreCase(""String_Node_Str"");
    return;
  }
  matcher=paintedVariablePattern.matcher(line);
  if (matcher.matches()) {
    if (parameters.getPaintedVariable() == null) {
      paintedVariableName=matcher.group(1);
    }
    return;
  }
  matcher=propertiesPattern.matcher(line);
  if (matcher.matches()) {
    String properties=matcher.group(1).trim();
    String[] split=properties.split(""String_Node_Str"");
    for (int i=0; i < split.length; i++) {
      if (split[i].equalsIgnoreCase(paintedVariableName)) {
        paintedVariableId=i + 1;
        break;
      }
    }
    return;
  }
  matcher=nodataPattern.matcher(line);
  if (matcher.matches()) {
    double[] values=splitStringToDoubles(matcher.group(1));
    if (paintedVariableId <= values.length) {
      noDataValue=(float)values[paintedVariableId - 1];
    }
    return;
  }
}","@Override public void addLine(String line){
  Matcher matcher;
  matcher=vertexPattern.matcher(line);
  if (matcher.matches()) {
    int id=Integer.parseInt(matcher.group(1));
    if (vertexIdMap.containsKey(id)) {
      throw new IllegalArgumentException(""String_Node_Str"" + id);
    }
    double x=Double.parseDouble(matcher.group(2));
    double y=Double.parseDouble(matcher.group(3));
    double z=Double.parseDouble(matcher.group(4));
    z=zPositive ? z : -z;
    if (parameters.getCoordinateTransformation() != null) {
      double[] transformed=new double[3];
      parameters.getCoordinateTransformation().TransformPoint(transformed,x,y,z);
      x=transformed[0];
      y=transformed[1];
      z=transformed[2];
    }
    Position position=Position.fromDegrees(y,x,z);
    vertexIdMap.put(id,positions.size());
    positions.add(position);
    float value=Float.NaN;
    if (paintedVariableId <= 0) {
      value=(float)z;
    }
 else {
      double[] values=splitStringToDoubles(matcher.group(5));
      if (paintedVariableId <= values.length) {
        value=(float)values[paintedVariableId - 1];
      }
    }
    if (!Float.isNaN(value) && value != noDataValue) {
      min=Math.min(min,value);
      max=Math.max(max,value);
    }
    values.add(value);
    return;
  }
  matcher=atomPattern.matcher(line);
  if (matcher.matches()) {
    int id1=Integer.parseInt(matcher.group(1));
    int id2=Integer.parseInt(matcher.group(2));
    if (vertexIdMap.containsKey(id1)) {
      throw new IllegalArgumentException(""String_Node_Str"" + id1);
    }
    if (!vertexIdMap.containsKey(id2)) {
      throw new IllegalArgumentException(""String_Node_Str"" + id2);
    }
    Position position=positions.get(vertexIdMap.get(id2));
    vertexIdMap.put(id1,positions.size());
    positions.add(position);
    float value=Float.NaN;
    if (paintedVariableId <= 0) {
      value=(float)position.elevation;
    }
 else {
      double[] values=splitStringToDoubles(matcher.group(3));
      if (paintedVariableId <= values.length) {
        value=(float)values[paintedVariableId - 1];
      }
    }
    if (!Float.isNaN(value) && value != noDataValue) {
      min=Math.min(min,value);
      max=Math.max(max,value);
    }
    values.add(value);
    return;
  }
  matcher=trianglePattern.matcher(line);
  if (matcher.matches()) {
    int t1=Integer.parseInt(matcher.group(1));
    int t2=Integer.parseInt(matcher.group(2));
    int t3=Integer.parseInt(matcher.group(3));
    triangleIds.add(t1);
    triangleIds.add(t2);
    triangleIds.add(t3);
    return;
  }
  matcher=colorPattern.matcher(line);
  if (matcher.matches()) {
    color=GocadColor.gocadLineToColor(line);
    return;
  }
  matcher=namePattern.matcher(line);
  if (matcher.matches()) {
    name=matcher.group(1);
    return;
  }
  matcher=zpositivePattern.matcher(line);
  if (matcher.matches()) {
    zPositive=!matcher.group(1).equalsIgnoreCase(""String_Node_Str"");
    return;
  }
  matcher=paintedVariablePattern.matcher(line);
  if (matcher.matches()) {
    if (parameters.getPaintedVariable() == null) {
      paintedVariableName=matcher.group(1);
    }
    return;
  }
  matcher=propertiesPattern.matcher(line);
  if (matcher.matches()) {
    String properties=matcher.group(1).trim();
    String[] split=properties.split(""String_Node_Str"");
    for (int i=0; i < split.length; i++) {
      if (split[i].equalsIgnoreCase(paintedVariableName)) {
        paintedVariableId=i + 1;
        break;
      }
    }
    return;
  }
  matcher=nodataPattern.matcher(line);
  if (matcher.matches()) {
    double[] values=splitStringToDoubles(matcher.group(1));
    if (0 < paintedVariableId && paintedVariableId <= values.length) {
      noDataValue=(float)values[paintedVariableId - 1];
    }
    return;
  }
}",0.99666799946688
11062,"@Override public TopBottomFastShape createLatitudeCurtain(int y){
  List<Position> positions=new ArrayList<Position>();
  FloatBuffer textureCoordinateBuffer=BufferUtil.newFloatBuffer(ySize * 4);
  for (int x=0; x < xSize; x++) {
    Position position=this.positions.get(x + y * xSize);
    TopBottomPosition top=new TopBottomPosition(position.latitude,position.longitude,position.elevation,false);
    TopBottomPosition bottom=new TopBottomPosition(position.latitude,position.longitude,position.elevation,true);
    positions.add(top);
    positions.add(bottom);
    float u=x / (float)Math.max(1,xSize - 1);
    textureCoordinateBuffer.put(u).put(0);
    textureCoordinateBuffer.put(u).put(1);
  }
  TopBottomFastShape shape=new TopBottomFastShape(positions,GL.GL_TRIANGLE_STRIP);
  shape.setTextureCoordinateBuffer(textureCoordinateBuffer);
  return shape;
}","@Override public TopBottomFastShape createLatitudeCurtain(int y){
  List<Position> positions=new ArrayList<Position>();
  FloatBuffer textureCoordinateBuffer=BufferUtil.newFloatBuffer(xSize * 4);
  for (int x=0; x < xSize; x++) {
    Position position=this.positions.get(x + y * xSize);
    TopBottomPosition top=new TopBottomPosition(position.latitude,position.longitude,position.elevation,false);
    TopBottomPosition bottom=new TopBottomPosition(position.latitude,position.longitude,position.elevation,true);
    positions.add(top);
    positions.add(bottom);
    float u=x / (float)Math.max(1,xSize - 1);
    textureCoordinateBuffer.put(u).put(0);
    textureCoordinateBuffer.put(u).put(1);
  }
  TopBottomFastShape shape=new TopBottomFastShape(positions,GL.GL_TRIANGLE_STRIP);
  shape.setTextureCoordinateBuffer(textureCoordinateBuffer);
  return shape;
}",0.9988385598141696
11063,"@Override protected boolean doLoadData(URL url,VolumeLayer layer){
  ZipFile zip=null;
  try {
    File file=URLUtil.urlToFile(url);
    InputStream sgInputStream=null;
    try {
      if (file.getName().toLowerCase().endsWith(""String_Node_Str"")) {
        zip=new ZipFile(file);
        Enumeration<? extends ZipEntry> entries=zip.entries();
        ZipEntry sgEntry=null;
        while (entries.hasMoreElements()) {
          ZipEntry entry=entries.nextElement();
          if (entry.getName().toLowerCase().endsWith(""String_Node_Str"")) {
            sgEntry=entry;
            break;
          }
        }
        if (sgEntry == null) {
          throw new IOException(""String_Node_Str"");
        }
        sgInputStream=zip.getInputStream(sgEntry);
      }
 else {
        sgInputStream=new FileInputStream(file);
      }
      BufferedReader reader=new BufferedReader(new InputStreamReader(sgInputStream));
      String line;
      while ((line=reader.readLine()) != null) {
        parseLine(line);
      }
    }
  finally {
      if (sgInputStream != null) {
        sgInputStream.close();
      }
    }
    if (asciiDataFile == null) {
      throw new IOException(""String_Node_Str"");
    }
    if (xSize == 0 || ySize == 0 || zSize == 0) {
      throw new IOException(""String_Node_Str"");
    }
    if (cellCentered) {
      xSize--;
      ySize--;
      zSize--;
    }
    InputStream dataInputStream=null;
    try {
      if (zip != null) {
        ZipEntry dataEntry=zip.getEntry(asciiDataFile);
        dataInputStream=zip.getInputStream(dataEntry);
      }
      if (dataInputStream == null) {
        File data=new File(file.getParent(),asciiDataFile);
        if (data.exists()) {
          dataInputStream=new FileInputStream(data);
        }
      }
      if (dataInputStream == null) {
        throw new IOException(""String_Node_Str"" + asciiDataFile + ""String_Node_Str"");
      }
      sector=null;
      double[] transformed=new double[3];
      CoordinateTransformation transformation=layer.getCoordinateTransformation();
      positions=new ArrayList<Position>(xSize * ySize);
      int positionIndex=0;
      double firstZValue=0;
      data=BufferUtil.newFloatBuffer(xSize * ySize * zSize);
      top=0;
      String doublePattern=""String_Node_Str"";
      String nonCapturingDoublePattern=""String_Node_Str"";
      String spacerPattern=""String_Node_Str"";
      String lineRegex=doublePattern + spacerPattern + doublePattern+ spacerPattern+ doublePattern;
      for (int property=1; property < paintedVariableId; property++) {
        lineRegex+=spacerPattern + nonCapturingDoublePattern;
      }
      lineRegex+=spacerPattern + doublePattern + ""String_Node_Str"";
      Pattern linePattern=Pattern.compile(lineRegex);
      BufferedReader reader=new BufferedReader(new InputStreamReader(dataInputStream));
      String line;
      while ((line=reader.readLine()) != null) {
        Matcher matcher=linePattern.matcher(line);
        if (matcher.matches()) {
          double x=Double.parseDouble(matcher.group(1));
          double y=Double.parseDouble(matcher.group(2));
          double z=Double.parseDouble(matcher.group(3));
          float value=Float.parseFloat(matcher.group(4));
          if (transformation != null) {
            transformation.TransformPoint(transformed,x,y,z);
            x=transformed[0];
            y=transformed[1];
            z=transformed[2];
          }
          if (positionIndex < xSize * ySize) {
            Position position=Position.fromDegrees(y,x,z);
            positions.add(position);
            top+=z / (double)(xSize * ySize);
            if (sector == null) {
              sector=new Sector(position.latitude,position.latitude,position.longitude,position.longitude);
            }
 else {
              sector=sector.union(position.latitude,position.longitude);
            }
          }
          if (positionIndex == 0) {
            firstZValue=z;
          }
 else           if (positionIndex == xSize * ySize * (zSize - 1)) {
            depth=firstZValue - z;
          }
          data.put(value);
          positionIndex++;
        }
      }
    }
  finally {
      if (dataInputStream != null) {
        dataInputStream.close();
      }
    }
  }
 catch (  IOException e) {
    e.printStackTrace();
    return false;
  }
 finally {
    if (zip != null) {
      try {
        zip.close();
      }
 catch (      IOException e) {
      }
    }
  }
  layer.dataAvailable(this);
  return true;
}","@Override protected boolean doLoadData(URL url,VolumeLayer layer){
  ZipFile zip=null;
  try {
    File file=URLUtil.urlToFile(url);
    InputStream sgInputStream=null;
    try {
      if (file.getName().toLowerCase().endsWith(""String_Node_Str"")) {
        zip=new ZipFile(file);
        Enumeration<? extends ZipEntry> entries=zip.entries();
        ZipEntry sgEntry=null;
        while (entries.hasMoreElements()) {
          ZipEntry entry=entries.nextElement();
          if (entry.getName().toLowerCase().endsWith(""String_Node_Str"")) {
            sgEntry=entry;
            break;
          }
        }
        if (sgEntry == null) {
          throw new IOException(""String_Node_Str"");
        }
        sgInputStream=zip.getInputStream(sgEntry);
      }
 else {
        sgInputStream=new FileInputStream(file);
      }
      BufferedReader reader=new BufferedReader(new InputStreamReader(sgInputStream));
      String line;
      while ((line=reader.readLine()) != null) {
        parseLine(line);
      }
    }
  finally {
      if (sgInputStream != null) {
        sgInputStream.close();
      }
    }
    if (asciiDataFile == null) {
      throw new IOException(""String_Node_Str"");
    }
    if (xSize == 0 || ySize == 0 || zSize == 0) {
      throw new IOException(""String_Node_Str"");
    }
    if (cellCentered) {
      xSize--;
      ySize--;
      zSize--;
    }
    InputStream dataInputStream=null;
    try {
      if (zip != null) {
        ZipEntry dataEntry=zip.getEntry(asciiDataFile);
        dataInputStream=zip.getInputStream(dataEntry);
      }
      if (dataInputStream == null) {
        File data=new File(file.getParent(),asciiDataFile);
        if (data.exists()) {
          dataInputStream=new FileInputStream(data);
        }
      }
      if (dataInputStream == null) {
        throw new IOException(""String_Node_Str"" + asciiDataFile + ""String_Node_Str"");
      }
      sector=null;
      double[] transformed=new double[3];
      CoordinateTransformation transformation=layer.getCoordinateTransformation();
      positions=new ArrayList<Position>(xSize * ySize);
      int positionIndex=0;
      double firstZValue=0;
      data=BufferUtil.newFloatBuffer(xSize * ySize * zSize);
      top=0;
      String doublePattern=""String_Node_Str"";
      String nonCapturingDoublePattern=""String_Node_Str"";
      String spacerPattern=""String_Node_Str"";
      String lineRegex=""String_Node_Str"" + doublePattern + spacerPattern+ doublePattern+ spacerPattern+ doublePattern;
      for (int property=1; property < paintedVariableId; property++) {
        lineRegex+=spacerPattern + nonCapturingDoublePattern;
      }
      lineRegex+=spacerPattern + doublePattern + ""String_Node_Str"";
      Pattern linePattern=Pattern.compile(lineRegex);
      BufferedReader reader=new BufferedReader(new InputStreamReader(dataInputStream));
      String line;
      while ((line=reader.readLine()) != null) {
        Matcher matcher=linePattern.matcher(line);
        if (matcher.matches()) {
          double x=Double.parseDouble(matcher.group(1));
          double y=Double.parseDouble(matcher.group(2));
          double z=Double.parseDouble(matcher.group(3));
          float value=Float.parseFloat(matcher.group(4));
          if (transformation != null) {
            transformation.TransformPoint(transformed,x,y,z);
            x=transformed[0];
            y=transformed[1];
            z=transformed[2];
          }
          if (positionIndex < xSize * ySize) {
            Position position=Position.fromDegrees(y,x,z);
            positions.add(position);
            top+=z / (double)(xSize * ySize);
            if (sector == null) {
              sector=new Sector(position.latitude,position.latitude,position.longitude,position.longitude);
            }
 else {
              sector=sector.union(position.latitude,position.longitude);
            }
          }
          if (positionIndex == 0) {
            firstZValue=z;
          }
 else           if (positionIndex == xSize * ySize * (zSize - 1)) {
            depth=firstZValue - z;
          }
          data.put(value);
          positionIndex++;
        }
      }
    }
  finally {
      if (dataInputStream != null) {
        dataInputStream.close();
      }
    }
  }
 catch (  IOException e) {
    e.printStackTrace();
    return false;
  }
 finally {
    if (zip != null) {
      try {
        zip.close();
      }
 catch (      IOException e) {
      }
    }
  }
  layer.dataAvailable(this);
  return true;
}",0.9976586018508194
11064,"private synchronized static ByteBuffer takeByteBuffer(int size){
  Entry<Integer,ByteBuffer> entry=availableBuffers.higherEntry(size);
  if (entry != null) {
    ByteBuffer buffer=entry.getValue();
    availableBuffers.remove(entry.getKey());
    buffer.rewind();
    buffer.limit(size);
    return buffer;
  }
  return ByteBuffer.allocateDirect(size);
}","private synchronized static ByteBuffer takeByteBuffer(int size){
  Entry<Integer,ByteBuffer> entry=availableBuffers.ceilingEntry(size);
  if (entry != null) {
    ByteBuffer buffer=entry.getValue();
    availableBuffers.remove(entry.getKey());
    buffer.rewind();
    buffer.limit(size);
    return buffer;
  }
  return ByteBuffer.allocateDirect(size);
}",0.9844851904090268
11065,"@Override public void paint(Graphics g,JComponent c){
synchronized (invalidatedPaths) {
    if (relayout || !invalidatedPaths.isEmpty()) {
      if (relayout) {
        treeState.invalidateSizes();
      }
 else {
        for (        TreePath path : invalidatedPaths) {
          treeState.invalidatePathBounds(path);
        }
      }
      updateSize();
      relayout=false;
      invalidatedPaths.clear();
    }
  }
  super.paint(g,c);
}","@Override public void paint(Graphics g,JComponent c){
  if (relayout || !invalidatedPaths.isEmpty()) {
    if (relayout) {
      treeState.invalidateSizes();
    }
 else {
      for (      TreePath path : invalidatedPaths) {
        treeState.invalidatePathBounds(path);
      }
    }
    updateSize();
    relayout=false;
    invalidatedPaths.clear();
  }
  super.paint(g,c);
}",0.8170731707317073
11066,"public void addLayer(ILayerDefinition layer,List<IData> parents){
  INode layerNode=LayerNode.createFromLayerDefinition(layer);
  List<INode> expandPath=new ArrayList<INode>();
  INode currentParent=getRoot();
  IData directParent=null;
  if (parents != null) {
    if (!parents.isEmpty()) {
      directParent=parents.get(parents.size() - 1);
    }
    int startIndex=0;
    for (int i=parents.size() - 1; i >= 0; i--) {
      if (parents.get(i).isBase()) {
        startIndex=i;
        break;
      }
    }
    for (int i=startIndex; i < parents.size(); i++) {
      IData data=parents.get(i);
      INode node=null;
      for (int j=0; j < currentParent.getChildCount(); j++) {
        INode child=currentParent.getChild(j);
        if (sameFolder(data,child)) {
          node=child;
          break;
        }
      }
      if (node == null) {
        node=new FolderNode(data.getName(),data.getInfoURL(),data.getIconURL(),true);
        insertNodeInto(node,currentParent,currentParent.getChildCount(),false);
      }
      expandPath.add(currentParent);
      currentParent=node;
    }
  }
  expandPath.add(currentParent);
  expandPath.add(layerNode);
  int index=currentParent.getChildCount();
  if (directParent != null && directParent instanceof IDataset) {
    IDataset dataset=(IDataset)directParent;
    int insertionIndex=findInsertionIndex(layer,dataset,currentParent);
    if (insertionIndex >= 0) {
      index=insertionIndex;
    }
  }
  insertNodeInto(layerNode,currentParent,index,true);
  TreePath expand=new TreePath(expandPath.toArray());
  tree.getUI().relayout(expand);
  tree.scrollPathToVisible(expand);
}","public void addLayer(ILayerDefinition layer,List<IData> parents){
  INode layerNode=LayerNode.createFromLayerDefinition(layer);
  List<INode> expandPath=new ArrayList<INode>();
  INode currentParent=getRoot();
  IData directParent=null;
  if (parents != null) {
    if (!parents.isEmpty()) {
      directParent=parents.get(parents.size() - 1);
    }
    int startIndex=0;
    for (int i=parents.size() - 1; i >= 0; i--) {
      if (parents.get(i).isBase()) {
        startIndex=i;
        break;
      }
    }
    for (int i=startIndex; i < parents.size(); i++) {
      IData data=parents.get(i);
      INode node=null;
      for (int j=0; j < currentParent.getChildCount(); j++) {
        INode child=currentParent.getChild(j);
        if (sameFolder(data,child)) {
          node=child;
          break;
        }
      }
      if (node == null) {
        node=new FolderNode(data.getName(),data.getInfoURL(),data.getIconURL(),true);
        insertNodeInto(node,currentParent,currentParent.getChildCount(),false);
      }
      expandPath.add(currentParent);
      currentParent=node;
    }
  }
  expandPath.add(currentParent);
  expandPath.add(layerNode);
  int index=currentParent.getChildCount();
  if (directParent != null && directParent instanceof IDataset) {
    IDataset dataset=(IDataset)directParent;
    int insertionIndex=findInsertionIndex(layer,dataset,currentParent);
    if (insertionIndex >= 0) {
      index=insertionIndex;
    }
  }
  insertNodeInto(layerNode,currentParent,index,true);
  final TreePath expand=new TreePath(expandPath.toArray());
  SwingUtil.invokeLaterTaskOnEDT(new Runnable(){
    @Override public void run(){
      tree.getUI().relayout(expand);
      tree.scrollPathToVisible(expand);
    }
  }
);
}",0.9635339460420992
11067,"@Override public void setup(Theme theme){
  super.setup(theme);
  tree.addTreeSelectionListener(new TreeSelectionListener(){
    @Override public void valueChanged(    TreeSelectionEvent e){
      treeSelectionChanged();
      enableActions();
    }
  }
);
  treeSelectionChanged();
  enableActions();
  createPopupMenus();
  linkPanels(theme.getPanels());
  setupDrag();
  if (!layersFileExisted) {
    for (    IDataset dataset : theme.getDatasets()) {
      addDefaultLayersFromDataset(dataset);
    }
  }
  window=SwingUtilities.getWindowAncestor(this);
}","@Override public void setup(final Theme theme){
  super.setup(theme);
  tree.addTreeSelectionListener(new TreeSelectionListener(){
    @Override public void valueChanged(    TreeSelectionEvent e){
      treeSelectionChanged();
      enableActions();
    }
  }
);
  treeSelectionChanged();
  enableActions();
  createPopupMenus();
  linkPanels(theme.getPanels());
  setupDrag();
  if (!layersFileExisted) {
    Thread thread=new Thread(new Runnable(){
      @Override public void run(){
        for (        IDataset dataset : theme.getDatasets()) {
          addDefaultLayersFromDataset(dataset);
        }
      }
    }
);
    thread.setDaemon(true);
    thread.start();
  }
  window=SwingUtilities.getWindowAncestor(this);
}",0.8700389105058366
11068,"private void addLayersToList(INode parent,List<ILayerNode> layers){
  if (parent instanceof ILayerNode) {
    layers.add((ILayerNode)parent);
  }
  for (int i=0; i < parent.getChildCount(); i++) {
    addLayersToList(parent.getChild(i),layers);
  }
}","private void addLayersToList(INode parent,List<ILayerNode> layers){
  if (parent instanceof ILayerNode && !parent.isTransient()) {
    layers.add((ILayerNode)parent);
  }
  for (int i=0; i < parent.getChildCount(); i++) {
    addLayersToList(parent.getChild(i),layers);
  }
}",0.9523809523809524
11069,"private void createActions(){
  openLayerAction=new BasicAction(getMessage(getOpenLayerActionLabelKey()),Icons.folder.getIcon());
  openLayerAction.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      openLayer();
    }
  }
);
  createLayerFromDirectoryAction=new BasicAction(getMessage(getCreateLayerFromDirectoryLabelKey()),Icons.newfolder.getIcon());
  createLayerFromDirectoryAction.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      createLayerFromDirectory();
    }
  }
);
  offlineAction=new SelectableAction(getMessage(getWorkOfflineLabelKey()),Icons.offline.getIcon(),WorldWind.isOfflineMode());
  offlineAction.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      WorldWind.setOfflineMode(offlineAction.isSelected());
    }
  }
);
  screenshotAction=new BasicAction(getMessage(getScreenshotLabelKey()),Icons.screenshot.getIcon());
  screenshotAction.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      saveImage();
    }
  }
);
  exitAction=new BasicAction(getMessage(getExitLabelKey()),Icons.escape.getIcon());
  exitAction.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      quit();
    }
  }
);
  defaultViewAction=new BasicAction(getMessage(getDefaultViewLabelKey()),Icons.home.getIcon());
  defaultViewAction.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      resetView();
    }
  }
);
  gotoAction=new BasicAction(getMessage(getGotoCoordsLabelKey()),Icons.crosshair45.getIcon());
  gotoAction.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      GoToCoordinatePanel.showGotoDialog(frame,wwd,getMessage(getGotoCoordsTitleKey()),Icons.crosshair45.getIcon());
    }
  }
);
  for (  ThemePanel panel : theme.getPanels()) {
    panelActions.add(createThemePieceAction(panel));
  }
  for (  ThemeHUD hud : theme.getHUDs()) {
    hudActions.add(createThemePieceAction(hud));
  }
  final Tessellator tess=wwd.getModel().getGlobe().getTessellator();
  skirtAction=new SelectableAction(getMessage(getRenderSkirtsLabelKey()),Icons.skirts.getIcon(),tess.isMakeTileSkirts());
  skirtAction.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      tess.setMakeTileSkirts(skirtAction.isSelected());
      wwd.redraw();
    }
  }
);
  wireframeAction=new SelectableAction(getMessage(getWireframeLabelKey()),Icons.wireframe.getIcon(),wwd.getModel().isShowWireframeInterior());
  wireframeAction.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      LayerList layers=wwd.getModel().getLayers();
      for (      Layer layer : layers) {
        if (layer instanceof Wireframeable) {
          ((Wireframeable)layer).setWireframe(wireframeAction.isSelected());
        }
      }
      wwd.redraw();
    }
  }
);
  wireframeElevationAction=new SelectableAction(getMessage(getWireframeElevationLabelKey()),Icons.wireframe.getIcon(),wwd.getModel().isShowWireframeInterior());
  wireframeElevationAction.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      wireframeDepthAction.setEnabled(wireframeAction.isSelected());
      wwd.getModel().setShowWireframeInterior(wireframeAction.isSelected());
      wwd.redraw();
    }
  }
);
  final WireframeRectangularTessellator tessellator=tess instanceof WireframeRectangularTessellator ? (WireframeRectangularTessellator)tess : null;
  boolean depth=tessellator != null && tessellator.isWireframeDepthTesting();
  wireframeDepthAction=new SelectableAction(getMessage(getWireframeDepthLabelKey()),Icons.zwireframe.getIcon(),depth);
  wireframeDepthAction.setEnabled(wireframeAction.isSelected());
  wireframeDepthAction.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      tessellator.setWireframeDepthTesting(wireframeDepthAction.isSelected());
      wwd.redraw();
    }
  }
);
  fullscreenAction=new BasicAction(getMessage(getFullscreenLabelKey()),Icons.monitor.getIcon());
  fullscreenAction.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      setFullscreen(!isFullscreen());
    }
  }
);
  settingsAction=new BasicAction(getMessage(getPreferencesLabelKey()),Icons.settings.getIcon());
  settingsAction.addActionListener(new ActionListener(){
    private boolean visible=false;
    @Override public void actionPerformed(    ActionEvent e){
      if (!visible) {
        visible=true;
        SettingsDialog settingsDialog=new SettingsDialog(frame,getMessage(getPreferencesTitleKey()),Icons.settings.getIcon());
        settingsDialog.setVisible(true);
        visible=false;
        afterSettingsChange();
      }
    }
  }
);
  helpAction=new BasicAction(getMessage(getHelpLabelKey()),Icons.help.getIcon());
  helpAction.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      try {
        DefaultLauncher.openURL(URLTransformer.transform(new URL(HELP_URL)));
      }
 catch (      MalformedURLException e1) {
      }
    }
  }
);
  controlsAction=new BasicAction(getMessage(getControlsLabelKey()),Icons.keyboard.getIcon());
  controlsAction.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      showControls();
    }
  }
);
  aboutAction=new BasicAction(getMessage(getAboutLabelKey()),Icons.about.getIcon());
  aboutAction.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      new AboutDialog(frame,getMessage(getAboutTitleKey()));
    }
  }
);
  saveSectorAction=new BasicAction(getMessage(getSaveSectorLabelKey()),Icons.save.getIcon());
  saveSectorAction.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      saveSector();
    }
  }
);
  clipSectorAction=new BasicAction(getMessage(getClipSectorLabelKey()),Icons.cut.getIcon());
  clipSectorAction.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      clipSector();
    }
  }
);
  clearClipAction=new BasicAction(getMessage(getClearClipLabelKey()),Icons.cutdelete.getIcon());
  clearClipAction.setEnabled(false);
  clearClipAction.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      clearClipping();
    }
  }
);
  wmsBrowserAction=new BasicAction(getMessage(getLaunchWmsBrowserLabelKey()),Icons.wmsbrowser.getIcon());
  wmsBrowserAction.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      showWmsBrowser();
    }
  }
);
}","private void createActions(){
  openLayerAction=new BasicAction(getMessage(getOpenLayerActionLabelKey()),Icons.folder.getIcon());
  openLayerAction.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      openLayer();
    }
  }
);
  createLayerFromDirectoryAction=new BasicAction(getMessage(getCreateLayerFromDirectoryLabelKey()),Icons.newfolder.getIcon());
  createLayerFromDirectoryAction.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      createLayerFromDirectory();
    }
  }
);
  offlineAction=new SelectableAction(getMessage(getWorkOfflineLabelKey()),Icons.offline.getIcon(),WorldWind.isOfflineMode());
  offlineAction.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      WorldWind.setOfflineMode(offlineAction.isSelected());
    }
  }
);
  screenshotAction=new BasicAction(getMessage(getScreenshotLabelKey()),Icons.screenshot.getIcon());
  screenshotAction.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      saveImage();
    }
  }
);
  exitAction=new BasicAction(getMessage(getExitLabelKey()),Icons.escape.getIcon());
  exitAction.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      quit();
    }
  }
);
  defaultViewAction=new BasicAction(getMessage(getDefaultViewLabelKey()),Icons.home.getIcon());
  defaultViewAction.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      resetView();
    }
  }
);
  gotoAction=new BasicAction(getMessage(getGotoCoordsLabelKey()),Icons.crosshair45.getIcon());
  gotoAction.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      GoToCoordinatePanel.showGotoDialog(frame,wwd,getMessage(getGotoCoordsTitleKey()),Icons.crosshair45.getIcon());
    }
  }
);
  for (  ThemePanel panel : theme.getPanels()) {
    panelActions.add(createThemePieceAction(panel));
  }
  for (  ThemeHUD hud : theme.getHUDs()) {
    hudActions.add(createThemePieceAction(hud));
  }
  final Tessellator tess=wwd.getModel().getGlobe().getTessellator();
  skirtAction=new SelectableAction(getMessage(getRenderSkirtsLabelKey()),Icons.skirts.getIcon(),tess.isMakeTileSkirts());
  skirtAction.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      tess.setMakeTileSkirts(skirtAction.isSelected());
      wwd.redraw();
    }
  }
);
  wireframeAction=new SelectableAction(getMessage(getWireframeLabelKey()),Icons.wireframe.getIcon(),wwd.getModel().isShowWireframeInterior());
  wireframeAction.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      LayerList layers=wwd.getModel().getLayers();
      for (      Layer layer : layers) {
        if (layer instanceof Wireframeable) {
          ((Wireframeable)layer).setWireframe(wireframeAction.isSelected());
        }
      }
      wwd.redraw();
    }
  }
);
  wireframeElevationAction=new SelectableAction(getMessage(getWireframeElevationLabelKey()),Icons.wireframe.getIcon(),wwd.getModel().isShowWireframeInterior());
  wireframeElevationAction.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      wireframeDepthAction.setEnabled(wireframeElevationAction.isSelected());
      wwd.getModel().setShowWireframeInterior(wireframeElevationAction.isSelected());
      wwd.redraw();
    }
  }
);
  final WireframeRectangularTessellator tessellator=tess instanceof WireframeRectangularTessellator ? (WireframeRectangularTessellator)tess : null;
  boolean depth=tessellator != null && tessellator.isWireframeDepthTesting();
  wireframeDepthAction=new SelectableAction(getMessage(getWireframeDepthLabelKey()),Icons.zwireframe.getIcon(),depth);
  wireframeDepthAction.setEnabled(wireframeAction.isSelected());
  wireframeDepthAction.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      tessellator.setWireframeDepthTesting(wireframeDepthAction.isSelected());
      wwd.redraw();
    }
  }
);
  fullscreenAction=new BasicAction(getMessage(getFullscreenLabelKey()),Icons.monitor.getIcon());
  fullscreenAction.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      setFullscreen(!isFullscreen());
    }
  }
);
  settingsAction=new BasicAction(getMessage(getPreferencesLabelKey()),Icons.settings.getIcon());
  settingsAction.addActionListener(new ActionListener(){
    private boolean visible=false;
    @Override public void actionPerformed(    ActionEvent e){
      if (!visible) {
        visible=true;
        SettingsDialog settingsDialog=new SettingsDialog(frame,getMessage(getPreferencesTitleKey()),Icons.settings.getIcon());
        settingsDialog.setVisible(true);
        visible=false;
        afterSettingsChange();
      }
    }
  }
);
  helpAction=new BasicAction(getMessage(getHelpLabelKey()),Icons.help.getIcon());
  helpAction.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      try {
        DefaultLauncher.openURL(URLTransformer.transform(new URL(HELP_URL)));
      }
 catch (      MalformedURLException e1) {
      }
    }
  }
);
  controlsAction=new BasicAction(getMessage(getControlsLabelKey()),Icons.keyboard.getIcon());
  controlsAction.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      showControls();
    }
  }
);
  aboutAction=new BasicAction(getMessage(getAboutLabelKey()),Icons.about.getIcon());
  aboutAction.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      new AboutDialog(frame,getMessage(getAboutTitleKey()));
    }
  }
);
  saveSectorAction=new BasicAction(getMessage(getSaveSectorLabelKey()),Icons.save.getIcon());
  saveSectorAction.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      saveSector();
    }
  }
);
  clipSectorAction=new BasicAction(getMessage(getClipSectorLabelKey()),Icons.cut.getIcon());
  clipSectorAction.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      clipSector();
    }
  }
);
  clearClipAction=new BasicAction(getMessage(getClearClipLabelKey()),Icons.cutdelete.getIcon());
  clearClipAction.setEnabled(false);
  clearClipAction.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      clearClipping();
    }
  }
);
  wmsBrowserAction=new BasicAction(getMessage(getLaunchWmsBrowserLabelKey()),Icons.wmsbrowser.getIcon());
  wmsBrowserAction.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      showWmsBrowser();
    }
  }
);
}",0.9987081957801062
11070,"protected void buildMesh(float maxVariance,int x,int y,int width,int height,boolean reverseX,boolean reverseY,List<BTTTriangle> triangles){
  int yStart=y;
  int remainingHeight=height;
  while (remainingHeight > 1) {
    int xStart=x;
    int remainingWidth=width;
    int currentHeight=nextLowestPowerOf2Plus1(Math.min(remainingWidth,remainingHeight));
    while (remainingWidth > 1) {
      int currentWidth=nextLowestPowerOf2Plus1(Math.min(remainingWidth,remainingHeight));
      for (int yOffset=0; yOffset < currentHeight - 1; yOffset+=currentWidth - 1) {
        int tx=reverseX ? width - xStart - currentWidth + x * 2 : xStart;
        int ty=reverseY ? height - yStart - yOffset- currentWidth + y * 2 : yStart + yOffset;
        buildTree(maxVariance,tx,ty,currentWidth,triangles);
      }
      remainingWidth-=currentWidth - 1;
      xStart+=currentWidth - 1;
    }
    remainingHeight-=currentHeight - 1;
    yStart+=currentHeight - 1;
  }
}","protected void buildMesh(float maxVariance,int x,int y,int width,int height,boolean reverseX,boolean reverseY,List<BTTTriangle> triangles){
  if (width < 2 || height < 2)   return;
  int yStart=y;
  int remainingHeight=height;
  while (remainingHeight > 1) {
    int xStart=x;
    int remainingWidth=width;
    int currentHeight=nextLowestPowerOf2Plus1(Math.min(remainingWidth,remainingHeight));
    while (remainingWidth > 1) {
      int currentWidth=nextLowestPowerOf2Plus1(Math.min(remainingWidth,remainingHeight));
      for (int yOffset=0; yOffset < currentHeight - 1; yOffset+=currentWidth - 1) {
        int tx=reverseX ? width - xStart - currentWidth + x * 2 : xStart;
        int ty=reverseY ? height - yStart - yOffset- currentWidth + y * 2 : yStart + yOffset;
        buildTree(maxVariance,tx,ty,currentWidth,triangles);
      }
      remainingWidth-=currentWidth - 1;
      xStart+=currentWidth - 1;
    }
    remainingHeight-=currentHeight - 1;
    yStart+=currentHeight - 1;
  }
}",0.9789419619928096
11071,"public void enableClipping(DrawContext dc){
  if (dirty) {
    if (sector == null) {
      planes=null;
    }
 else {
      planes=computeSectorClippingPlanes(dc.getGlobe(),sector);
    }
  }
  if (planes != null) {
    GL gl=dc.getGL();
    gl.glClipPlane(GL.GL_CLIP_PLANE0,planes,0);
    gl.glClipPlane(GL.GL_CLIP_PLANE1,planes,4);
    gl.glClipPlane(GL.GL_CLIP_PLANE2,planes,8);
    gl.glClipPlane(GL.GL_CLIP_PLANE3,planes,12);
    gl.glEnable(GL.GL_CLIP_PLANE0);
    gl.glEnable(GL.GL_CLIP_PLANE1);
    gl.glEnable(GL.GL_CLIP_PLANE2);
    gl.glEnable(GL.GL_CLIP_PLANE3);
  }
}","public void enableClipping(DrawContext dc){
  if (dirty) {
    if (sector == null) {
      planes=null;
    }
 else {
      planes=computeSectorClippingPlanes(dc.getGlobe(),sector);
    }
    dirty=false;
  }
  if (planes != null) {
    GL gl=dc.getGL();
    gl.glClipPlane(GL.GL_CLIP_PLANE0,planes,0);
    gl.glClipPlane(GL.GL_CLIP_PLANE1,planes,4);
    gl.glClipPlane(GL.GL_CLIP_PLANE2,planes,8);
    gl.glClipPlane(GL.GL_CLIP_PLANE3,planes,12);
    gl.glEnable(GL.GL_CLIP_PLANE0);
    gl.glEnable(GL.GL_CLIP_PLANE1);
    gl.glEnable(GL.GL_CLIP_PLANE2);
    gl.glEnable(GL.GL_CLIP_PLANE3);
  }
}",0.9855564995751912
11072,"protected void buildMesh(float maxVariance,int x,int y,int width,int height,boolean reverseX,boolean reverseY,List<BTTTriangle> triangles){
  int yStart=y;
  int remainingHeight=height;
  while (remainingHeight > 1) {
    int xStart=x;
    int remainingWidth=width;
    int currentHeight=nextLowestPowerOf2Plus1(Math.min(remainingWidth,remainingHeight));
    while (remainingWidth > 1) {
      int currentWidth=nextLowestPowerOf2Plus1(Math.min(remainingWidth,remainingHeight));
      for (int yOffset=0; yOffset < currentHeight - 1; yOffset+=currentWidth - 1) {
        int tx=reverseX ? width - xStart - currentWidth : xStart;
        int ty=reverseY ? height - yStart - yOffset- currentWidth : yStart + yOffset;
        buildTree(maxVariance,tx,ty,currentWidth,triangles);
      }
      remainingWidth-=currentWidth - 1;
      xStart+=currentWidth - 1;
    }
    remainingHeight-=currentHeight - 1;
    yStart+=currentHeight - 1;
  }
}","protected void buildMesh(float maxVariance,int x,int y,int width,int height,boolean reverseX,boolean reverseY,List<BTTTriangle> triangles){
  int yStart=y;
  int remainingHeight=height;
  while (remainingHeight > 1) {
    int xStart=x;
    int remainingWidth=width;
    int currentHeight=nextLowestPowerOf2Plus1(Math.min(remainingWidth,remainingHeight));
    while (remainingWidth > 1) {
      int currentWidth=nextLowestPowerOf2Plus1(Math.min(remainingWidth,remainingHeight));
      for (int yOffset=0; yOffset < currentHeight - 1; yOffset+=currentWidth - 1) {
        int tx=reverseX ? width - xStart - currentWidth + x * 2 : xStart;
        int ty=reverseY ? height - yStart - yOffset- currentWidth + y * 2 : yStart + yOffset;
        buildTree(maxVariance,tx,ty,currentWidth,triangles);
      }
      remainingWidth-=currentWidth - 1;
      xStart+=currentWidth - 1;
    }
    remainingHeight-=currentHeight - 1;
    yStart+=currentHeight - 1;
  }
}",0.9915343915343916
11073,"public List<? extends LatLon> getPositions(){
  return positions;
}","public List<Position> getPositions(){
  return positions;
}",0.8571428571428571
11074,"protected static Sphere createBoundingSphere(BufferWrapper wrapper){
  Vec4[] extrema=Vec4.computeExtrema(wrapper);
  Vec4 center=new Vec4((extrema[0].x + extrema[1].x) / 2.0,(extrema[0].y + extrema[1].y) / 2.0,(extrema[0].z + extrema[1].z) / 2.0);
  double radius=Math.max(1,extrema[0].distanceTo3(extrema[1]) / 2.0);
  return new Sphere(center,radius);
}","protected static Sphere createBoundingSphere(BufferWrapper wrapper){
  Vec4[] extrema=Vec4.computeExtrema(wrapper);
  if (extrema == null)   return null;
  Vec4 center=new Vec4((extrema[0].x + extrema[1].x) / 2.0,(extrema[0].y + extrema[1].y) / 2.0,(extrema[0].z + extrema[1].z) / 2.0);
  double radius=Math.max(1,extrema[0].distanceTo3(extrema[1]) / 2.0);
  return new Sphere(center,radius);
}",0.9493333333333334
11075,"protected void calculateVertices(DrawContext dc){
  modVertexBuffer.rewind();
  for (  LatLon position : positions) {
    Vec4 v=calculateVertex(dc,position);
    modVertexBuffer.put(v.x).put(v.y).put(v.z);
  }
  modVertexBuffer.rewind();
  BufferWrapper wrapper=new BufferWrapper.DoubleBufferWrapper(modVertexBuffer);
  modBoundingSphere=createBoundingSphere(wrapper);
  modVertexBuffer.rewind();
  for (int i=0; modVertexBuffer.remaining() >= 3; i+=3) {
    modVertexBuffer.put(i + 0,modVertexBuffer.get() - modBoundingSphere.getCenter().x);
    modVertexBuffer.put(i + 1,modVertexBuffer.get() - modBoundingSphere.getCenter().y);
    modVertexBuffer.put(i + 2,modVertexBuffer.get() - modBoundingSphere.getCenter().z);
  }
}","protected void calculateVertices(DrawContext dc){
  modVertexBuffer.rewind();
  for (  LatLon position : positions) {
    Vec4 v=calculateVertex(dc,position);
    modVertexBuffer.put(v.x).put(v.y).put(v.z);
  }
  modVertexBuffer.rewind();
  BufferWrapper wrapper=new BufferWrapper.DoubleBufferWrapper(modVertexBuffer);
  modBoundingSphere=createBoundingSphere(wrapper);
  if (modBoundingSphere == null)   modBoundingSphere=new Sphere(Vec4.ZERO,1);
  modVertexBuffer.rewind();
  for (int i=0; modVertexBuffer.remaining() >= 3; i+=3) {
    modVertexBuffer.put(i + 0,modVertexBuffer.get() - modBoundingSphere.getCenter().x);
    modVertexBuffer.put(i + 1,modVertexBuffer.get() - modBoundingSphere.getCenter().y);
    modVertexBuffer.put(i + 2,modVertexBuffer.get() - modBoundingSphere.getCenter().z);
  }
}",0.9489528795811518
11076,"@Override public Sector getSector(){
  frontLock.readLock().unlock();
  try {
    return sector;
  }
  finally {
    frontLock.readLock().unlock();
  }
}","@Override public Sector getSector(){
  frontLock.readLock().lock();
  try {
    return sector;
  }
  finally {
    frontLock.readLock().unlock();
  }
}",0.993421052631579
11077,"/** 
 * @return The extent of this shape. This is calculated by{@link FastShape#render(DrawContext)}, so don't use this for frustum culling.
 */
public Extent getExtent(){
  frontLock.readLock().unlock();
  try {
    return boundingSphere;
  }
  finally {
    frontLock.readLock().unlock();
  }
}","/** 
 * @return The extent of this shape. This is calculated by{@link FastShape#render(DrawContext)}, so don't use this for frustum culling.
 */
public Extent getExtent(){
  frontLock.readLock().lock();
  try {
    return boundingSphere;
  }
  finally {
    frontLock.readLock().unlock();
  }
}",0.9966101694915256
11078,"/** 
 * Load the data from the file pointed to by the url. Delegates the loading to the subclass.
 * @param url
 * @param layer
 * @return True if the data was loaded successfully
 */
protected boolean loadData(URL url,L layer){
synchronized (getFileLock()) {
    loading=false;
    loadingListeners.notifyListeners(isLoading());
    if (!loaded)     loaded=doLoadData(url,layer);
    return loaded;
  }
}","/** 
 * Load the data from the file pointed to by the url. Delegates the loading to the subclass.
 * @param url
 * @param layer
 * @return True if the data was loaded successfully
 */
protected boolean loadData(URL url,L layer){
synchronized (readLock) {
    reading=true;
  }
synchronized (getFileLock()) {
    if (!loaded) {
      loaded=doLoadData(url,layer);
    }
  }
synchronized (readLock) {
    loading=false;
    loadingListeners.notifyListeners(isLoading());
    reading=false;
  }
  return loaded;
}",0.7540983606557377
11079,"@Override public void requestData(L layer){
  if (!loaded) {
    loading=true;
    loadingListeners.notifyListeners(isLoading());
    RequestTask task=new RequestTask(this,layer);
    WorldWind.getTaskService().addTask(task);
  }
}","@Override public void requestData(L layer){
synchronized (readLock) {
    if (!loaded && !reading) {
      RequestTask task=new RequestTask(this,layer);
      if (!WorldWind.getTaskService().isFull()) {
        loading=true;
        loadingListeners.notifyListeners(isLoading());
        WorldWind.getTaskService().addTask(task);
      }
    }
  }
}",0.4655172413793103
11080,"public XMLPointProvider(Element element){
  XPath xpath=XMLUtil.makeXPath();
  Element[] pointElements=XMLUtil.getElements(element,""String_Node_Str"",xpath);
  if (pointElements != null) {
    for (    Element pointElement : pointElements) {
      Position position=XMLUtil.getPosition(pointElement,null,xpath);
      if (position != null) {
        points.add(position);
        sector=sector != null ? sector.union(position.latitude,position.longitude) : new Sector(position.latitude,position.longitude,position.latitude,position.longitude);
        AVList attributes=new AVListImpl();
        this.attributes.add(attributes);
        NamedNodeMap elementAttributes=pointElement.getAttributes();
        for (int i=0; i < elementAttributes.getLength(); i++) {
          Node child=elementAttributes.item(i);
          attributes.setValue(child.getNodeName(),child.getTextContent());
        }
        NodeList children=pointElement.getChildNodes();
        for (int i=0; i < children.getLength(); i++) {
          Node child=children.item(i);
          attributes.setValue(child.getNodeName(),child.getTextContent());
        }
      }
    }
  }
}","public XMLPointProvider(Element element){
  XPath xpath=XMLUtil.makeXPath();
  Element[] pointElements=XMLUtil.getElements(element,""String_Node_Str"",xpath);
  if (pointElements != null) {
    for (    Element pointElement : pointElements) {
      Position position=XMLUtil.getPosition(pointElement,null,xpath);
      if (position != null) {
        points.add(position);
        sector=sector != null ? sector.union(position.latitude,position.longitude) : new Sector(position.latitude,position.latitude,position.longitude,position.longitude);
        AVList attributes=new AVListImpl();
        this.attributes.add(attributes);
        NamedNodeMap elementAttributes=pointElement.getAttributes();
        for (int i=0; i < elementAttributes.getLength(); i++) {
          Node child=elementAttributes.item(i);
          attributes.setValue(child.getNodeName(),child.getTextContent());
        }
        NodeList children=pointElement.getChildNodes();
        for (int i=0; i < children.getLength(); i++) {
          Node child=children.item(i);
          attributes.setValue(child.getNodeName(),child.getTextContent());
        }
      }
    }
  }
}",0.995644599303136
11081,"public void setPositions(List<Position> positions){
  frontLock.writeLock().lock();
  try {
    this.positions=positions;
    verticesDirty=true;
    sector=null;
    for (    Position position : positions) {
      sector=sector != null ? sector.union(position.latitude,position.longitude) : new Sector(position.latitude,position.longitude,position.latitude,position.longitude);
    }
  }
  finally {
    frontLock.writeLock().unlock();
  }
}","public void setPositions(List<Position> positions){
  frontLock.writeLock().lock();
  try {
    this.positions=positions;
    verticesDirty=true;
    sector=null;
    for (    Position position : positions) {
      sector=sector != null ? sector.union(position.latitude,position.longitude) : new Sector(position.latitude,position.latitude,position.longitude,position.longitude);
    }
  }
  finally {
    frontLock.writeLock().unlock();
  }
}",0.8054298642533937
11082,"@Override public void move(double deltaX,double deltaY,double deltaZ){
  View view=getView();
  if (view != null) {
    Vec4 forward=view.getForwardVector();
    Vec4 up=view.getUpVector();
    Vec4 side=up.cross3(forward);
    double scale=getScaleValueElevation();
    side=side.multiply3(deltaX * scale);
    up=up.multiply3(deltaY * scale);
    forward=forward.multiply3(deltaZ * scale);
    Vec4 eyePoint=view.getCurrentEyePoint();
    eyePoint=eyePoint.add3(forward.add3(up.add3(side)));
    Position newPosition=view.getGlobe().computePositionFromPoint(eyePoint);
    view.setEyePosition(newPosition);
    view.firePropertyChange(AVKey.VIEW,null,view);
  }
}","@Override public void move(double deltaX,double deltaY,double deltaZ){
  View view=getView();
  if (view != null) {
    Vec4 forward=view.getForwardVector();
    Vec4 up=view.getUpVector();
    Vec4 side=up.cross3(forward);
    Vec4 eyePoint=view.getCurrentEyePoint();
    Position eyePosition=view.getGlobe().computePositionFromPoint(eyePoint);
    double scale=getScaleValueElevation(eyePosition);
    side=side.multiply3(deltaX * scale);
    up=up.multiply3(deltaY * scale);
    forward=forward.multiply3(deltaZ * scale);
    eyePoint=eyePoint.add3(forward.add3(up.add3(side)));
    Position newPosition=view.getGlobe().computePositionFromPoint(eyePoint);
    view.setEyePosition(newPosition);
    view.firePropertyChange(AVKey.VIEW,null,view);
  }
}",0.8702397743300423
11083,"protected double getScaleValueElevation(){
  double[] range=new double[]{10,100000};
  View view=getView();
  Position eyePos=view.getEyePosition();
  Globe globe=getWorldWindow().getModel().getGlobe();
  double radius=globe.getRadius();
  double surfaceElevation=globe.getElevation(eyePos.getLatitude(),eyePos.getLongitude());
  double t=getScaleValue(range[0],range[1],eyePos.getElevation() - surfaceElevation,3.0 * radius,true);
  return t;
}","protected double getScaleValueElevation(Position eyePosition){
  double[] range=new double[]{10,100000};
  Globe globe=getView().getGlobe();
  double radius=globe.getRadius();
  double surfaceElevation=globe.getElevation(eyePosition.getLatitude(),eyePosition.getLongitude());
  double t=getScaleValue(range[0],range[1],eyePosition.getElevation() - surfaceElevation,3.0 * radius,true);
  return t;
}",0.5741399762752076
11084,"protected void afterDoApply(){
  this.lastEyePosition=null;
  this.lastEyePoint=null;
  this.lastUpVector=null;
  this.lastForwardVector=null;
  this.lastFrustumInModelCoords=null;
}","protected void afterDoApply(){
  this.lastEyePosition=this.computeEyePositionFromModelview();
  this.horizonDistance=this.computeHorizonDistance();
  this.lastEyePoint=null;
  this.lastUpVector=null;
  this.lastForwardVector=null;
  this.lastFrustumInModelCoords=null;
}",0.7300884955752213
11085,"protected void calculateVertices(DrawContext dc){
  modVertexBuffer.rewind();
  Globe globe=dc.getGlobe();
  for (  LatLon position : positions) {
    double elevation=this.elevation;
    if (followTerrain) {
      elevation+=globe.getElevation(position.getLatitude(),position.getLongitude());
    }
    if (position instanceof Position) {
      elevation+=((Position)position).getElevation();
    }
    elevation*=dc.getVerticalExaggeration();
    elevation=Math.max(elevation,-dc.getGlobe().getMaximumRadius());
    Vec4 v=dc.getGlobe().computePointFromPosition(position.getLatitude(),position.getLongitude(),elevation);
    modVertexBuffer.put(v.x).put(v.y).put(v.z);
  }
  modVertexBuffer.rewind();
  BufferWrapper wrapper=new BufferWrapper.DoubleBufferWrapper(modVertexBuffer);
  modBoundingSphere=Sphere.createBoundingSphere(wrapper);
  modVertexBuffer.rewind();
  for (int i=0; modVertexBuffer.remaining() >= 3; i+=3) {
    modVertexBuffer.put(i + 0,modVertexBuffer.get() - modBoundingSphere.getCenter().x);
    modVertexBuffer.put(i + 1,modVertexBuffer.get() - modBoundingSphere.getCenter().y);
    modVertexBuffer.put(i + 2,modVertexBuffer.get() - modBoundingSphere.getCenter().z);
  }
}","protected void calculateVertices(DrawContext dc){
  modVertexBuffer.rewind();
  Globe globe=dc.getGlobe();
  for (  LatLon position : positions) {
    double elevation=this.elevation;
    if (followTerrain) {
      elevation+=globe.getElevation(position.getLatitude(),position.getLongitude());
    }
    if (position instanceof Position) {
      elevation+=((Position)position).getElevation();
    }
    elevation*=dc.getVerticalExaggeration();
    elevation=Math.max(elevation,-dc.getGlobe().getMaximumRadius());
    Vec4 v=dc.getGlobe().computePointFromPosition(position.getLatitude(),position.getLongitude(),elevation);
    modVertexBuffer.put(v.x).put(v.y).put(v.z);
  }
  modVertexBuffer.rewind();
  BufferWrapper wrapper=new BufferWrapper.DoubleBufferWrapper(modVertexBuffer);
  modBoundingSphere=createBoundingSphere(wrapper);
  modVertexBuffer.rewind();
  for (int i=0; modVertexBuffer.remaining() >= 3; i+=3) {
    modVertexBuffer.put(i + 0,modVertexBuffer.get() - modBoundingSphere.getCenter().x);
    modVertexBuffer.put(i + 1,modVertexBuffer.get() - modBoundingSphere.getCenter().y);
    modVertexBuffer.put(i + 2,modVertexBuffer.get() - modBoundingSphere.getCenter().z);
  }
}",0.9970649895178196
11086,"protected String getPlaceholderString(StringWithPlaceholder string,AVList attributeValues){
  if (string == null || !attributeValues.hasKey(name))   return null;
  String stringValue=attributeValues.getValue(name).toString();
  return string.replacePlaceholder(stringValue);
}","protected String getPlaceholderString(StringWithPlaceholder string,AVList attributeValues){
  if (string == null || attributeValues.getValue(name) == null)   return null;
  String stringValue=attributeValues.getValue(name).toString();
  return string.replacePlaceholder(stringValue);
}",0.9590017825311944
11087,"/** 
 * Find a matching   {@link Style} string for the provided attributes.
 * @param attributeValues Attribute values to use when searching for matching cases
 * @return
 */
public String getMatchingStyle(AVList attributeValues){
  if (!attributeValues.hasKey(name))   return null;
  String stringValue=attributeValues.getValue(name).toString();
  if (switches.containsKey(stringValue))   return switches.get(stringValue);
  for (  Entry<String,String> regex : regexes.entrySet()) {
    if (Pattern.matches(regex.getKey(),stringValue))     return regex.getValue();
  }
  Double doubleValue=null;
  try {
    doubleValue=Double.valueOf(stringValue);
  }
 catch (  Exception e) {
  }
  if (doubleValue != null) {
    for (    Entry<Range,String> range : ranges.entrySet()) {
      if (range.getKey().contains(doubleValue))       return range.getValue();
    }
  }
  return null;
}","/** 
 * Find a matching   {@link Style} string for the provided attributes.
 * @param attributeValues Attribute values to use when searching for matching cases
 * @return
 */
public String getMatchingStyle(AVList attributeValues){
  if (attributeValues.getValue(name) == null)   return null;
  String stringValue=attributeValues.getValue(name).toString();
  if (switches.containsKey(stringValue))   return switches.get(stringValue);
  for (  Entry<String,String> regex : regexes.entrySet()) {
    if (Pattern.matches(regex.getKey(),stringValue))     return regex.getValue();
  }
  Double doubleValue=null;
  try {
    doubleValue=Double.valueOf(stringValue);
  }
 catch (  Exception e) {
  }
  if (doubleValue != null) {
    for (    Entry<Range,String> range : ranges.entrySet()) {
      if (range.getKey().contains(doubleValue))       return range.getValue();
    }
  }
  return null;
}",0.9688737973967176
11088,"protected void loadData(InputStream is){
  try {
    List<Earthquake> quakes=new ArrayList<Earthquake>();
    ObjectInputStream ois=new ObjectInputStream(is);
    while (ois.available() > 0) {
      double lat=ois.readDouble();
      double lon=ois.readDouble();
      double elevation=ois.readDouble();
      double magnitude=ois.readDouble();
      long timeInMillis=ois.readLong();
      Position position=Position.fromDegrees(lat,lon,elevation);
      Earthquake quake=new Earthquake(position,magnitude,timeInMillis);
      quakes.add(quake);
    }
    ois.close();
    loadEarthquakes(quakes);
  }
 catch (  IOException e) {
    if (loadAttempts < MAX_DOWNLOAD_ATTEMPTS) {
      loaded=false;
      Downloader.removeCache(url);
      Logging.logger().warning(""String_Node_Str"" + url);
    }
 else {
      e.printStackTrace();
    }
  }
}","protected void loadData(InputStream is){
  try {
    boolean isZipFile=url.toExternalForm().toLowerCase().endsWith(""String_Node_Str"");
    if (isZipFile) {
      ZipInputStream zis=new ZipInputStream(is);
      zis.getNextEntry();
      is=zis;
    }
    List<Earthquake> quakes=new ArrayList<Earthquake>();
    ObjectInputStream ois=new ObjectInputStream(is);
    try {
      while (is.available() > 0) {
        double lat=ois.readDouble();
        double lon=ois.readDouble();
        double elevation=ois.readDouble();
        double magnitude=ois.readDouble();
        long timeInMillis=ois.readLong();
        Position position=Position.fromDegrees(lat,lon,elevation);
        Earthquake quake=new Earthquake(position,magnitude,timeInMillis);
        quakes.add(quake);
      }
    }
 catch (    EOFException e) {
    }
    ois.close();
    loadEarthquakes(quakes);
  }
 catch (  IOException e) {
    e.printStackTrace();
    if (loadAttempts < MAX_DOWNLOAD_ATTEMPTS) {
      loaded=false;
      Downloader.removeCache(url);
      Logging.logger().warning(""String_Node_Str"" + url);
    }
 else {
      e.printStackTrace();
    }
  }
}",0.8486377396569122
11089,"@Override protected void applyDrawProjection(DrawContext dc,OGLStackHandler ogsh){
  boolean loaded=false;
  if (dc.getView() instanceof StereoView) {
    StereoView stereo=(StereoView)dc.getView();
    double near=stereo.getEyePoint().getLength3();
    double far=this.radius + near;
    Matrix projection=stereo.calculateProjectionMatrix(near,far);
    if (projection != null) {
      double[] matrixArray=new double[16];
      GL gl=dc.getGL();
      gl.glMatrixMode(GL.GL_PROJECTION);
      gl.glPushMatrix();
      projection.toArray(matrixArray,0,false);
      gl.glLoadMatrixd(matrixArray,0);
      loaded=true;
    }
  }
  if (!loaded) {
    super.applyDrawProjection(dc,ogsh);
  }
}","@Override protected void applyDrawProjection(DrawContext dc,OGLStackHandler ogsh){
  boolean loaded=false;
  if (dc.getView() instanceof StereoView && ((StereoView)dc.getView()).isStereo()) {
    StereoView stereo=(StereoView)dc.getView();
    double near=stereo.getEyePoint().getLength3();
    double far=this.radius + near;
    Matrix projection=stereo.calculateProjectionMatrix(near,far);
    if (projection != null) {
      double[] matrixArray=new double[16];
      GL gl=dc.getGL();
      gl.glMatrixMode(GL.GL_PROJECTION);
      gl.glPushMatrix();
      projection.toArray(matrixArray,0,false);
      gl.glLoadMatrixd(matrixArray,0);
      loaded=true;
    }
  }
  if (!loaded) {
    super.applyDrawProjection(dc,ogsh);
  }
}",0.9711876317638792
11090,"/** 
 * Fill the params with the values in the   {@link BoreholeLayer} specific XMLelements.
 */
public static AVList getParamsFromDocument(Element domElement,AVList params){
  if (params == null)   params=new AVListImpl();
  XPath xpath=WWXML.makeXPath();
  WWXML.checkAndSetStringParam(domElement,params,AVKey.URL,""String_Node_Str"",xpath);
  WWXML.checkAndSetLongParam(domElement,params,AVKey.EXPIRY_TIME,""String_Node_Str"",xpath);
  WWXML.checkAndSetDateTimeParam(domElement,params,AVKey.EXPIRY_TIME,""String_Node_Str"",DATE_TIME_PATTERN,xpath);
  WWXML.checkAndSetStringParam(domElement,params,AVKey.DATA_CACHE_NAME,""String_Node_Str"",xpath);
  WWXML.checkAndSetStringParam(domElement,params,AVKeyMore.POINT_TYPE,""String_Node_Str"",xpath);
  WWXML.checkAndSetStringParam(domElement,params,AVKeyMore.BOREHOLE_UNIQUE_IDENTIFIER_ATTRIBUTE,""String_Node_Str"",xpath);
  WWXML.checkAndSetStringParam(domElement,params,AVKeyMore.BOREHOLE_SAMPLE_DEPTH_FROM_ATTRIBUTE,""String_Node_Str"",xpath);
  WWXML.checkAndSetStringParam(domElement,params,AVKeyMore.BOREHOLE_SAMPLE_DEPTH_TO_ATTRIBUTE,""String_Node_Str"",xpath);
  setupBoreholeProvider(domElement,xpath,params);
  Element styles=WWXML.getElement(domElement,""String_Node_Str"",xpath);
  if (styles != null) {
    StyleAndAttributeFactory.addStyles(styles,xpath,AVKeyMore.BOREHOLE_STYLES,params);
  }
  Element attributes=WWXML.getElement(domElement,""String_Node_Str"",xpath);
  if (attributes != null) {
    StyleAndAttributeFactory.addAttributes(attributes,xpath,AVKeyMore.BOREHOLE_ATTRIBUTES,params);
  }
  Element sampleStyles=WWXML.getElement(domElement,""String_Node_Str"",xpath);
  if (sampleStyles != null) {
    StyleAndAttributeFactory.addStyles(sampleStyles,xpath,AVKeyMore.BOREHOLE_SAMPLE_STYLES,params);
  }
  Element sampleAttributes=WWXML.getElement(domElement,""String_Node_Str"",xpath);
  if (sampleAttributes != null) {
    StyleAndAttributeFactory.addAttributes(sampleAttributes,xpath,AVKeyMore.BOREHOLE_SAMPLE_ATTRIBUTES,params);
  }
  return params;
}","/** 
 * Fill the params with the values in the   {@link BoreholeLayer} specific XMLelements.
 */
public static AVList getParamsFromDocument(Element domElement,AVList params){
  if (params == null)   params=new AVListImpl();
  XPath xpath=WWXML.makeXPath();
  WWXML.checkAndSetStringParam(domElement,params,AVKey.URL,""String_Node_Str"",xpath);
  WWXML.checkAndSetLongParam(domElement,params,AVKey.EXPIRY_TIME,""String_Node_Str"",xpath);
  WWXML.checkAndSetDateTimeParam(domElement,params,AVKey.EXPIRY_TIME,""String_Node_Str"",DATE_TIME_PATTERN,xpath);
  WWXML.checkAndSetStringParam(domElement,params,AVKey.DATA_CACHE_NAME,""String_Node_Str"",xpath);
  WWXML.checkAndSetStringParam(domElement,params,AVKeyMore.POINT_TYPE,""String_Node_Str"",xpath);
  WWXML.checkAndSetStringParam(domElement,params,AVKeyMore.BOREHOLE_UNIQUE_IDENTIFIER_ATTRIBUTE,""String_Node_Str"",xpath);
  WWXML.checkAndSetStringParam(domElement,params,AVKeyMore.BOREHOLE_SAMPLE_DEPTH_FROM_ATTRIBUTE,""String_Node_Str"",xpath);
  WWXML.checkAndSetStringParam(domElement,params,AVKeyMore.BOREHOLE_SAMPLE_DEPTH_TO_ATTRIBUTE,""String_Node_Str"",xpath);
  setupBoreholeProvider(domElement,xpath,params);
  Element styles=WWXML.getElement(domElement,""String_Node_Str"",xpath);
  StyleAndAttributeFactory.addStyles(styles,xpath,AVKeyMore.BOREHOLE_STYLES,params);
  Element attributes=WWXML.getElement(domElement,""String_Node_Str"",xpath);
  StyleAndAttributeFactory.addAttributes(attributes,xpath,AVKeyMore.BOREHOLE_ATTRIBUTES,params);
  Element sampleStyles=WWXML.getElement(domElement,""String_Node_Str"",xpath);
  StyleAndAttributeFactory.addStyles(sampleStyles,xpath,AVKeyMore.BOREHOLE_SAMPLE_STYLES,params);
  Element sampleAttributes=WWXML.getElement(domElement,""String_Node_Str"",xpath);
  StyleAndAttributeFactory.addAttributes(sampleAttributes,xpath,AVKeyMore.BOREHOLE_SAMPLE_ATTRIBUTES,params);
  return params;
}",0.9560723514211886
11091,"/** 
 * Fill the params with the values in the   {@link GeometryLayer} specific XMLelements.
 */
public static AVList getParamsFromDocument(Element domElement,AVList params){
  if (params == null)   params=new AVListImpl();
  XPath xpath=WWXML.makeXPath();
  WWXML.checkAndSetStringParam(domElement,params,AVKey.URL,""String_Node_Str"",xpath);
  WWXML.checkAndSetLongParam(domElement,params,AVKey.EXPIRY_TIME,""String_Node_Str"",xpath);
  WWXML.checkAndSetDateTimeParam(domElement,params,AVKey.EXPIRY_TIME,""String_Node_Str"",DATE_TIME_PATTERN,xpath);
  WWXML.checkAndSetStringParam(domElement,params,AVKey.DATA_CACHE_NAME,""String_Node_Str"",xpath);
  WWXML.checkAndSetStringParam(domElement,params,AVKeyMore.RENDER_TYPE,""String_Node_Str"",xpath);
  WWXML.checkAndSetStringParam(domElement,params,AVKeyMore.SHAPE_TYPE,""String_Node_Str"",xpath);
  setupShapeProvider(domElement,xpath,params);
  Element styles=WWXML.getElement(domElement,""String_Node_Str"",xpath);
  if (styles != null) {
    StyleAndAttributeFactory.addStyles(styles,xpath,AVKeyMore.SHAPE_STYLES,params);
  }
  Element attributes=WWXML.getElement(domElement,""String_Node_Str"",xpath);
  if (attributes != null) {
    StyleAndAttributeFactory.addAttributes(attributes,xpath,AVKeyMore.SHAPE_ATTRIBUTES,params);
  }
  return params;
}","/** 
 * Fill the params with the values in the   {@link GeometryLayer} specific XMLelements.
 */
public static AVList getParamsFromDocument(Element domElement,AVList params){
  if (params == null)   params=new AVListImpl();
  XPath xpath=WWXML.makeXPath();
  WWXML.checkAndSetStringParam(domElement,params,AVKey.URL,""String_Node_Str"",xpath);
  WWXML.checkAndSetLongParam(domElement,params,AVKey.EXPIRY_TIME,""String_Node_Str"",xpath);
  WWXML.checkAndSetDateTimeParam(domElement,params,AVKey.EXPIRY_TIME,""String_Node_Str"",DATE_TIME_PATTERN,xpath);
  WWXML.checkAndSetStringParam(domElement,params,AVKey.DATA_CACHE_NAME,""String_Node_Str"",xpath);
  WWXML.checkAndSetStringParam(domElement,params,AVKeyMore.RENDER_TYPE,""String_Node_Str"",xpath);
  WWXML.checkAndSetStringParam(domElement,params,AVKeyMore.SHAPE_TYPE,""String_Node_Str"",xpath);
  setupShapeProvider(domElement,xpath,params);
  Element styles=WWXML.getElement(domElement,""String_Node_Str"",xpath);
  StyleAndAttributeFactory.addStyles(styles,xpath,AVKeyMore.SHAPE_STYLES,params);
  Element attributes=WWXML.getElement(domElement,""String_Node_Str"",xpath);
  StyleAndAttributeFactory.addAttributes(attributes,xpath,AVKeyMore.SHAPE_ATTRIBUTES,params);
  return params;
}",0.9625498007968128
11092,"/** 
 * Fill the params with the values in the   {@link PointLayer} specific XMLelements.
 */
public static AVList getParamsFromDocument(Element domElement,AVList params){
  if (params == null)   params=new AVListImpl();
  XPath xpath=WWXML.makeXPath();
  WWXML.checkAndSetStringParam(domElement,params,AVKey.URL,""String_Node_Str"",xpath);
  WWXML.checkAndSetLongParam(domElement,params,AVKey.EXPIRY_TIME,""String_Node_Str"",xpath);
  WWXML.checkAndSetDateTimeParam(domElement,params,AVKey.EXPIRY_TIME,""String_Node_Str"",DATE_TIME_PATTERN,xpath);
  WWXML.checkAndSetStringParam(domElement,params,AVKey.DATA_CACHE_NAME,""String_Node_Str"",xpath);
  WWXML.checkAndSetStringParam(domElement,params,AVKeyMore.POINT_TYPE,""String_Node_Str"",xpath);
  setupPointProvider(domElement,xpath,params);
  Element styles=WWXML.getElement(domElement,""String_Node_Str"",xpath);
  if (styles != null) {
    StyleAndAttributeFactory.addStyles(styles,xpath,AVKeyMore.POINT_STYLES,params);
  }
  Element attributes=WWXML.getElement(domElement,""String_Node_Str"",xpath);
  if (attributes != null) {
    StyleAndAttributeFactory.addAttributes(attributes,xpath,AVKeyMore.POINT_ATTRIBUTES,params);
  }
  return params;
}","/** 
 * Fill the params with the values in the   {@link PointLayer} specific XMLelements.
 */
public static AVList getParamsFromDocument(Element domElement,AVList params){
  if (params == null)   params=new AVListImpl();
  XPath xpath=WWXML.makeXPath();
  WWXML.checkAndSetStringParam(domElement,params,AVKey.URL,""String_Node_Str"",xpath);
  WWXML.checkAndSetLongParam(domElement,params,AVKey.EXPIRY_TIME,""String_Node_Str"",xpath);
  WWXML.checkAndSetDateTimeParam(domElement,params,AVKey.EXPIRY_TIME,""String_Node_Str"",DATE_TIME_PATTERN,xpath);
  WWXML.checkAndSetStringParam(domElement,params,AVKey.DATA_CACHE_NAME,""String_Node_Str"",xpath);
  WWXML.checkAndSetStringParam(domElement,params,AVKeyMore.POINT_TYPE,""String_Node_Str"",xpath);
  setupPointProvider(domElement,xpath,params);
  Element styles=WWXML.getElement(domElement,""String_Node_Str"",xpath);
  StyleAndAttributeFactory.addStyles(styles,xpath,AVKeyMore.POINT_STYLES,params);
  Element attributes=WWXML.getElement(domElement,""String_Node_Str"",xpath);
  StyleAndAttributeFactory.addAttributes(attributes,xpath,AVKeyMore.POINT_ATTRIBUTES,params);
  return params;
}",0.9593073593073592
11093,"/** 
 * Read a list of   {@link Style}s from the provided XML element and add them to the  {@link AVList} under the provided parameter key.
 * @param element XML element under which to read styles from
 * @param xpath XPath object
 * @param paramKey Key to use when setting the list in the params
 * @param params Params in which to add the list of styles
 */
public static void addStyles(Element element,XPath xpath,String paramKey,AVList params){
  List<Style> styles=new ArrayList<Style>();
  Element[] styleElements=WWXML.getElements(element,""String_Node_Str"",xpath);
  if (styleElements != null) {
    for (    Element s : styleElements) {
      String name=WWXML.getText(s,""String_Node_Str"",xpath);
      boolean defalt=XMLUtil.getBoolean(s,""String_Node_Str"",false);
      Style style=new Style(name,defalt);
      Element[] properties=WWXML.getElements(s,""String_Node_Str"",xpath);
      if (properties != null) {
        for (        Element p : properties) {
          String pname=WWXML.getText(p,""String_Node_Str"",xpath);
          String value=WWXML.getText(p,""String_Node_Str"",xpath);
          String type=WWXML.getText(p,""String_Node_Str"",xpath);
          style.addProperty(pname,value,type);
        }
      }
      styles.add(style);
    }
  }
  params.setValue(paramKey,styles);
}","/** 
 * Read a list of   {@link Style}s from the provided XML element and add them to the   {@link AVList} under the provided parameter key.
 * @param element XML element under which to read styles from
 * @param xpath XPath object
 * @param paramKey Key to use when setting the list in the params
 * @param params Params in which to add the list of styles
 */
public static void addStyles(Element element,XPath xpath,String paramKey,AVList params){
  List<Style> styles=new ArrayList<Style>();
  if (element != null) {
    Element[] styleElements=WWXML.getElements(element,""String_Node_Str"",xpath);
    if (styleElements != null) {
      for (      Element s : styleElements) {
        String name=WWXML.getText(s,""String_Node_Str"",xpath);
        boolean defalt=XMLUtil.getBoolean(s,""String_Node_Str"",false);
        Style style=new Style(name,defalt);
        Element[] properties=WWXML.getElements(s,""String_Node_Str"",xpath);
        if (properties != null) {
          for (          Element p : properties) {
            String pname=WWXML.getText(p,""String_Node_Str"",xpath);
            String value=WWXML.getText(p,""String_Node_Str"",xpath);
            String type=WWXML.getText(p,""String_Node_Str"",xpath);
            style.addProperty(pname,value,type);
          }
        }
        styles.add(style);
      }
    }
  }
  params.setValue(paramKey,styles);
}",0.9737434358589648
11094,"/** 
 * Read a list of   {@link Attribute}s from the provided XML element and add them to the  {@link AVList} under the provided parameter key.
 * @param element XML element under which to read attributes from
 * @param xpath XPath object
 * @param paramKey Key to use when setting the list in the params
 * @param params Params in which to add the list of attributes
 */
public static void addAttributes(Element element,XPath xpath,String paramKey,AVList params){
  List<Attribute> attributes=new ArrayList<Attribute>();
  Element[] attributesElements=WWXML.getElements(element,""String_Node_Str"",xpath);
  if (attributesElements != null) {
    for (    Element a : attributesElements) {
      String name=WWXML.getText(a,""String_Node_Str"",xpath);
      Attribute attribute=new Attribute(name);
      Element[] cases=WWXML.getElements(a,""String_Node_Str"",xpath);
      if (cases != null) {
        for (        Element c : cases) {
          String value=WWXML.getText(c,""String_Node_Str"",xpath);
          String style=WWXML.getText(c,""String_Node_Str"",xpath);
          attribute.addCase(value,style);
        }
      }
      Element[] regexes=WWXML.getElements(a,""String_Node_Str"",xpath);
      if (regexes != null) {
        for (        Element r : regexes) {
          String pattern=WWXML.getText(r,""String_Node_Str"",xpath);
          String style=WWXML.getText(r,""String_Node_Str"",xpath);
          attribute.addRegex(pattern,style);
        }
      }
      Element[] ranges=WWXML.getElements(a,""String_Node_Str"",xpath);
      if (ranges != null) {
        for (        Element r : ranges) {
          Double min=WWXML.getDouble(r,""String_Node_Str"",xpath);
          Double max=WWXML.getDouble(r,""String_Node_Str"",xpath);
          String style=WWXML.getText(r,""String_Node_Str"",xpath);
          attribute.addRange(min,max,style);
        }
      }
      Element text=WWXML.getElement(a,""String_Node_Str"",xpath);
      if (text != null) {
        String value=WWXML.getText(text,""String_Node_Str"",xpath);
        String placeholder=WWXML.getText(text,""String_Node_Str"",xpath);
        attribute.addText(value,placeholder);
      }
      Element link=WWXML.getElement(a,""String_Node_Str"",xpath);
      if (link != null) {
        String url=WWXML.getText(link,""String_Node_Str"",xpath);
        String placeholder=WWXML.getText(link,""String_Node_Str"",xpath);
        attribute.addLink(url,placeholder);
      }
      attributes.add(attribute);
    }
  }
  params.setValue(paramKey,attributes);
}","/** 
 * Read a list of   {@link Attribute}s from the provided XML element and add them to the   {@link AVList} under the provided parameter key.
 * @param element XML element under which to read attributes from
 * @param xpath XPath object
 * @param paramKey Key to use when setting the list in the params
 * @param params Params in which to add the list of attributes
 */
public static void addAttributes(Element element,XPath xpath,String paramKey,AVList params){
  List<Attribute> attributes=new ArrayList<Attribute>();
  if (element != null) {
    Element[] attributesElements=WWXML.getElements(element,""String_Node_Str"",xpath);
    if (attributesElements != null) {
      for (      Element a : attributesElements) {
        String name=WWXML.getText(a,""String_Node_Str"",xpath);
        Attribute attribute=new Attribute(name);
        Element[] cases=WWXML.getElements(a,""String_Node_Str"",xpath);
        if (cases != null) {
          for (          Element c : cases) {
            String value=WWXML.getText(c,""String_Node_Str"",xpath);
            String style=WWXML.getText(c,""String_Node_Str"",xpath);
            attribute.addCase(value,style);
          }
        }
        Element[] regexes=WWXML.getElements(a,""String_Node_Str"",xpath);
        if (regexes != null) {
          for (          Element r : regexes) {
            String pattern=WWXML.getText(r,""String_Node_Str"",xpath);
            String style=WWXML.getText(r,""String_Node_Str"",xpath);
            attribute.addRegex(pattern,style);
          }
        }
        Element[] ranges=WWXML.getElements(a,""String_Node_Str"",xpath);
        if (ranges != null) {
          for (          Element r : ranges) {
            Double min=WWXML.getDouble(r,""String_Node_Str"",xpath);
            Double max=WWXML.getDouble(r,""String_Node_Str"",xpath);
            String style=WWXML.getText(r,""String_Node_Str"",xpath);
            attribute.addRange(min,max,style);
          }
        }
        Element text=WWXML.getElement(a,""String_Node_Str"",xpath);
        if (text != null) {
          String value=WWXML.getText(text,""String_Node_Str"",xpath);
          String placeholder=WWXML.getText(text,""String_Node_Str"",xpath);
          attribute.addText(value,placeholder);
        }
        Element link=WWXML.getElement(a,""String_Node_Str"",xpath);
        if (link != null) {
          String url=WWXML.getText(link,""String_Node_Str"",xpath);
          String placeholder=WWXML.getText(link,""String_Node_Str"",xpath);
          attribute.addLink(url,placeholder);
        }
        attributes.add(attribute);
      }
    }
  }
  params.setValue(paramKey,attributes);
}",0.9750584567420107
11095,"public FolderNode(INode node){
  this(node.getName(),node.getInfoURL(),node.getIconURL(),node.isExpanded());
}","public FolderNode(String name,URL infoURL,URL iconURL,boolean expanded){
  super(name,infoURL,iconURL,expanded);
}",0.4642857142857143
11096,"private void refreshLists(){
  if (wwd == null) {
    return;
  }
  layerList.removeAllFromSection(this,layers);
  elevationModel.removeAllFromSection(this,elevationModels);
  layers.clear();
  elevationModels.clear();
  for (  Wrapper wrapper : wrappers) {
    if (wrapper.node.isEnabled()) {
      if (wrapper.hasLayer()) {
        Layer layer=wrapper.getLayer();
        layer.setEnabled(wrapper.node.isEnabled());
        layer.setOpacity(wrapper.node.getOpacity());
        layers.add(layer);
        layerMap.put(layer,wrapper.node);
      }
 else       if (wrapper.hasElevationModel()) {
        ElevationModel elevationModel=wrapper.getElevationModel();
        elevationModels.add(elevationModel);
        mapChildElevationModelsToNode(elevationModel,wrapper.node);
      }
    }
    if (wrapper.isLoaded()) {
      if (!layersSetup) {
        wrapper.getLoaded().setup(wwd);
      }
      wrapper.node.setLegendURL(wrapper.getLoaded().getLegendURL());
      wrapper.node.setQueryURL(wrapper.getLoaded().getQueryURL());
      wrapper.updateExpiryTime();
    }
  }
  layersSetup=true;
  layerList.addAllFromSection(this,layers);
  elevationModel.addAllFromSection(this,elevationModels);
  for (  RefreshListener listener : listeners) {
    listener.refreshed();
  }
  tree.getUI().relayout();
  tree.repaint();
}","private void refreshLists(){
  if (wwd == null) {
    return;
  }
  layerList.removeAllFromSection(this,layers);
  elevationModel.removeAllFromSection(this,elevationModels);
  layers.clear();
  elevationModels.clear();
  for (  Wrapper wrapper : wrappers) {
    if (wrapper.node.isEnabled()) {
      if (wrapper.hasLayer()) {
        Layer layer=wrapper.getLayer();
        layer.setEnabled(wrapper.node.isEnabled());
        layer.setOpacity(wrapper.node.getOpacity());
        layers.add(layer);
        layerMap.put(layer,wrapper.node);
      }
 else       if (wrapper.hasElevationModel()) {
        ElevationModel elevationModel=wrapper.getElevationModel();
        elevationModels.add(elevationModel);
        mapChildElevationModelsToNode(elevationModel,wrapper.node);
      }
    }
    if (wrapper.isLoaded()) {
      if (!layersSetup) {
        wrapper.getLoaded().setup(wwd);
      }
      wrapper.node.setLegendURL(wrapper.getLoaded().getLegendURL());
      wrapper.node.setQueryURL(wrapper.getLoaded().getQueryURL());
      wrapper.updateExpiryTime();
    }
  }
  layersSetup=true;
  layerList.addAllFromSection(this,layers);
  elevationModel.addAllFromSection(this,elevationModels);
  for (  RefreshListener listener : listeners) {
    listener.refreshed();
  }
  tree.relayoutOnEDT();
}",0.9881634211531118
11097,"private void setError(ILayerNode node,Exception error){
  node.setError(error);
  if (tree != null) {
    tree.getUI().relayout();
    tree.repaint();
  }
}","private void setError(ILayerNode node,Exception error){
  node.setError(error);
  if (tree != null) {
    tree.relayoutOnEDT();
  }
}",0.8927335640138409
11098,"private void setLayerLoading(ILayerNode node,boolean loading,boolean repaintTree){
  node.setLayerLoading(loading);
  if (repaintTree && tree != null) {
    tree.repaint();
  }
}","private void setLayerLoading(ILayerNode node,boolean loading,boolean repaintTree){
  node.setLayerLoading(loading);
  if (repaintTree && tree != null) {
    tree.relayoutOnEDT();
  }
}",0.9668508287292816
11099,"public LayerNode(ILayerNode node){
  this(node.getName(),node.getInfoURL(),node.getIconURL(),node.isExpanded(),node.getLayerURL(),node.isEnabled(),node.getOpacity(),node.getExpiryTime());
  setLegendURL(node.getLegendURL());
  setQueryURL(node.getQueryURL());
}","public LayerNode(String name,URL infoURL,URL iconURL,boolean expanded,URL layerURL,boolean enabled,double opacity,Long expiryTime){
  super(name,infoURL,iconURL,expanded);
  setLayerURL(layerURL);
  setEnabled(enabled);
  setOpacity(opacity);
  setExpiryTime(expiryTime);
}",0.1685393258426966
11100,"@Override protected void draw(DrawContext dc){
  Dimension dimensions=renderDimensions != null ? renderDimensions : new Dimension(dc.getDrawableWidth(),dc.getDrawableHeight());
  List<Effect> effects=animation.getEffects();
  if (effects == null || effects.isEmpty()) {
    super.draw(dc);
    return;
  }
  Effect firstEffect=effects.get(0);
  Effect lastEffect=effects.get(effects.size() - 1);
  firstEffect.preDraw(dc,dimensions);
  this.clearFrame(dc);
  super.draw(dc);
  for (int i=1; i < effects.size(); i++) {
    effects.get(i).preDraw(dc,dimensions);
    effects.get(i - 1).postDraw(dc,dimensions);
  }
  lastEffect.postDraw(dc,dimensions);
}","@Override protected void draw(DrawContext dc){
  Dimension dimensions=renderDimensions != null ? renderDimensions : new Dimension(dc.getDrawableWidth(),dc.getDrawableHeight());
  List<Effect> effects=new ArrayList<Effect>(animation.getEffects());
  for (int i=effects.size() - 1; i >= 0; i--) {
    Effect effect=effects.get(i);
    if (!effect.isEnabled()) {
      effect.releaseResources(dc);
      effects.remove(i);
    }
  }
  if (effects.isEmpty()) {
    super.draw(dc);
    return;
  }
  Effect firstEffect=effects.get(0);
  Effect lastEffect=effects.get(effects.size() - 1);
  try {
    firstEffect.bindFrameBuffer(dc,dimensions);
    this.clearFrame(dc);
    super.draw(dc);
  }
  finally {
    firstEffect.unbindFrameBuffer(dc,dimensions);
  }
  for (int i=1; i < effects.size(); i++) {
    try {
      effects.get(i).bindFrameBuffer(dc,dimensions);
      this.clearFrame(dc);
      effects.get(i - 1).drawFrameBufferWithEffect(dc,dimensions);
    }
  finally {
      effects.get(i).unbindFrameBuffer(dc,dimensions);
    }
  }
  lastEffect.drawFrameBufferWithEffect(dc,dimensions);
}",0.5936962750716333
11101,"public static Class<? extends Effect> collectEffect(Frame parent){
  EffectDialog dialog=new EffectDialog(parent);
  dialog.setVisible(true);
  if (dialog.getResponse() != JOptionPane.OK_OPTION) {
    return null;
  }
  return dialog.getEffect();
}","/** 
 * Show a new   {@link EffectDialog}, and block until the user has selected an effect.
 * @param parent Dialog's parent
 * @return The effect class selected, or null if the user cancelled.
 */
public static Class<? extends Effect> collectEffect(Frame parent){
  EffectDialog dialog=new EffectDialog(parent);
  dialog.setVisible(true);
  if (dialog.getResponse() != JOptionPane.OK_OPTION) {
    return null;
  }
  return dialog.getEffect();
}",0.7146974063400576
11102,"public SortedSet<Class<? extends Effect>> getEffects(){
  return Collections.unmodifiableSortedSet(effects);
}","/** 
 * @return The list of effects registered, sorted by name.
 */
public SortedSet<Class<? extends Effect>> getEffects(){
  return Collections.unmodifiableSortedSet(effects);
}",0.7638888888888888
11103,"public void registerEffect(Class<? extends Effect> effect){
  Effect effectInstance=AnimatableInstanciator.instantiate(effect);
  effects.add(effect);
  elementToEffectMap.put(effectInstance.getXmlElementName(AnimationFileVersion.VERSION020.getConstants()),effect);
}","/** 
 * Register an effect
 * @param effect Effect to register
 */
public void registerEffect(Class<? extends Effect> effect){
  Effect effectInstance=AnimatableInstanciator.instantiate(effect);
  effects.add(effect);
  elementToEffectMap.put(effectInstance.getXmlElementName(AnimationFileVersion.VERSION020.getConstants()),effect);
}",0.8885191347753744
11104,"public String getEffectName(Class<? extends Effect> effect){
  Effect effectInstance=AnimatableInstanciator.instantiate(effect);
  String name=effectInstance.getName();
  if (name == null) {
    name=effectInstance.getDefaultName();
  }
  if (name == null) {
    name=effect.getCanonicalName();
  }
  return name;
}","/** 
 * Helper method to get an effect's default name from it's class
 * @param effect Effect class to get the default name for
 * @return Default name of the given effect
 */
public String getEffectName(Class<? extends Effect> effect){
  Effect effectInstance=AnimatableInstanciator.instantiate(effect);
  String name=effectInstance.getName();
  if (name == null) {
    name=effectInstance.getDefaultName();
  }
  if (name == null) {
    name=effect.getCanonicalName();
  }
  return name;
}",0.7816377171215881
11105,"/** 
 * Draw a texture on a quad, covering the entire viewport
 */
public static void renderTexturedQuad(GL gl,int... textureIds){
  gl.glMatrixMode(GL.GL_MODELVIEW);
  gl.glPushMatrix();
  gl.glLoadIdentity();
  gl.glMatrixMode(GL.GL_PROJECTION);
  gl.glPushMatrix();
  gl.glLoadIdentity();
  gl.glPushAttrib(GL.GL_ENABLE_BIT);
  try {
    gl.glEnable(GL.GL_TEXTURE_2D);
    for (int i=0; i < textureIds.length; i++) {
      gl.glActiveTexture(GL.GL_TEXTURE0 + i);
      gl.glBindTexture(GL.GL_TEXTURE_2D,textureIds[i]);
      gl.glBegin(GL.GL_QUADS);
{
        gl.glTexCoord2f(0,0);
        gl.glVertex3i(-1,-1,-1);
        gl.glTexCoord2f(1,0);
        gl.glVertex3i(1,-1,-1);
        gl.glTexCoord2f(1,1);
        gl.glVertex3i(1,1,-1);
        gl.glTexCoord2f(0,1);
        gl.glVertex3i(-1,1,-1);
      }
      gl.glEnd();
    }
  }
  finally {
    gl.glPopMatrix();
    gl.glMatrixMode(GL.GL_MODELVIEW);
    gl.glPopMatrix();
    gl.glPopAttrib();
  }
}","/** 
 * Draw a texture on a quad, covering the entire viewport
 */
public static void renderTexturedQuad(GL gl,int... textureIds){
  gl.glMatrixMode(GL.GL_MODELVIEW);
  gl.glPushMatrix();
  gl.glLoadIdentity();
  gl.glMatrixMode(GL.GL_PROJECTION);
  gl.glPushMatrix();
  gl.glLoadIdentity();
  gl.glPushAttrib(GL.GL_ENABLE_BIT);
  try {
    gl.glEnable(GL.GL_TEXTURE_2D);
    for (int i=0; i < textureIds.length; i++) {
      gl.glActiveTexture(GL.GL_TEXTURE0 + i);
      gl.glBindTexture(GL.GL_TEXTURE_2D,textureIds[i]);
    }
    gl.glBegin(GL.GL_QUADS);
{
      gl.glTexCoord2f(0,0);
      gl.glVertex3i(-1,-1,-1);
      gl.glTexCoord2f(1,0);
      gl.glVertex3i(1,-1,-1);
      gl.glTexCoord2f(1,1);
      gl.glVertex3i(1,1,-1);
      gl.glTexCoord2f(0,1);
      gl.glVertex3i(-1,1,-1);
    }
    gl.glEnd();
  }
  finally {
    gl.glPopMatrix();
    gl.glMatrixMode(GL.GL_MODELVIEW);
    gl.glPopMatrix();
    gl.glPopAttrib();
  }
}",0.9726027397260274
11106,"/** 
 * @return The ID of the generated depth buffer
 */
private int generateDepthBuffer(GL gl,Dimension renderDimensions,boolean asTexture){
  int[] renderBuffers=new int[1];
  if (asTexture) {
    gl.glGenTextures(1,renderBuffers,0);
  }
 else {
    gl.glGenRenderbuffersEXT(1,renderBuffers,0);
  }
  if (renderBuffers[0] <= 0) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  if (asTexture) {
    gl.glBindTexture(GL.GL_TEXTURE_2D,renderBuffers[0]);
    gl.glTexParameteri(GL.GL_TEXTURE_2D,GL.GL_TEXTURE_MAG_FILTER,GL.GL_NEAREST);
    gl.glTexParameteri(GL.GL_TEXTURE_2D,GL.GL_TEXTURE_MIN_FILTER,GL.GL_NEAREST);
    gl.glTexParameteri(GL.GL_TEXTURE_2D,GL.GL_TEXTURE_WRAP_S,GL.GL_CLAMP);
    gl.glTexParameteri(GL.GL_TEXTURE_2D,GL.GL_TEXTURE_WRAP_T,GL.GL_CLAMP);
    gl.glTexParameteri(GL.GL_TEXTURE_2D,GL.GL_DEPTH_TEXTURE_MODE,GL.GL_INTENSITY);
    gl.glTexImage2D(GL.GL_TEXTURE_2D,0,GL.GL_DEPTH_COMPONENT24,renderDimensions.width,renderDimensions.height,0,GL.GL_DEPTH_COMPONENT,GL.GL_UNSIGNED_BYTE,null);
    gl.glBindTexture(GL.GL_TEXTURE_2D,0);
  }
 else {
    gl.glBindRenderbufferEXT(GL.GL_RENDERBUFFER_EXT,renderBuffers[0]);
    gl.glRenderbufferStorageEXT(GL.GL_RENDERBUFFER_EXT,GL.GL_DEPTH_COMPONENT24,renderDimensions.width,renderDimensions.height);
    gl.glBindRenderbufferEXT(GL.GL_RENDERBUFFER_EXT,0);
  }
  return renderBuffers[0];
}","/** 
 * @return The ID of the generated depth buffer
 */
private int generateDepthBuffer(GL gl,Dimension renderDimensions,boolean asTexture){
  int[] renderBuffers=new int[1];
  if (asTexture) {
    gl.glGenTextures(1,renderBuffers,0);
  }
 else {
    gl.glGenRenderbuffersEXT(1,renderBuffers,0);
  }
  if (renderBuffers[0] <= 0) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  if (asTexture) {
    gl.glBindTexture(GL.GL_TEXTURE_2D,renderBuffers[0]);
    gl.glTexParameteri(GL.GL_TEXTURE_2D,GL.GL_TEXTURE_MAG_FILTER,GL.GL_NEAREST);
    gl.glTexParameteri(GL.GL_TEXTURE_2D,GL.GL_TEXTURE_MIN_FILTER,GL.GL_NEAREST);
    gl.glTexParameteri(GL.GL_TEXTURE_2D,GL.GL_TEXTURE_WRAP_S,GL.GL_CLAMP);
    gl.glTexParameteri(GL.GL_TEXTURE_2D,GL.GL_TEXTURE_WRAP_T,GL.GL_CLAMP);
    gl.glTexParameteri(GL.GL_TEXTURE_2D,GL.GL_DEPTH_TEXTURE_MODE,GL.GL_INTENSITY);
    gl.glTexParameteri(GL.GL_TEXTURE_2D,GL.GL_TEXTURE_COMPARE_MODE,GL.GL_NONE);
    gl.glTexImage2D(GL.GL_TEXTURE_2D,0,GL.GL_DEPTH_COMPONENT24,renderDimensions.width,renderDimensions.height,0,GL.GL_DEPTH_COMPONENT,GL.GL_UNSIGNED_BYTE,null);
    gl.glBindTexture(GL.GL_TEXTURE_2D,0);
  }
 else {
    gl.glBindRenderbufferEXT(GL.GL_RENDERBUFFER_EXT,renderBuffers[0]);
    gl.glRenderbufferStorageEXT(GL.GL_RENDERBUFFER_EXT,GL.GL_DEPTH_COMPONENT24,renderDimensions.width,renderDimensions.height);
    gl.glBindRenderbufferEXT(GL.GL_RENDERBUFFER_EXT,0);
  }
  return renderBuffers[0];
}",0.9096085409252668
11107,"@Override protected void retrieveRemoteElevations(final Tile tile,gov.nasa.worldwind.terrain.BasicElevationModel.DownloadPostProcessor postProcessor){
  if (!this.isNetworkRetrievalEnabled()) {
    this.getLevels().markResourceAbsent(tile);
    return;
  }
  if (!WorldWind.getRetrievalService().isAvailable())   return;
  java.net.URL url=null;
  try {
    url=tile.getResourceURL();
    if (WorldWind.getNetworkStatus().isHostUnavailable(url)) {
      this.getLevels().markResourceAbsent(tile);
      return;
    }
  }
 catch (  java.net.MalformedURLException e) {
    Logging.logger().log(java.util.logging.Level.SEVERE,Logging.getMessage(""String_Node_Str"",url),e);
    return;
  }
  if (postProcessor == null)   postProcessor=new DownloadPostProcessor(tile,this);
  URLRetriever retriever=new HTTPRetriever(url,postProcessor);
  if (isExtractZipEntry()) {
    retriever.setValue(URLRetriever.EXTRACT_ZIP_ENTRY,""String_Node_Str"");
  }
  if (WorldWind.getRetrievalService().contains(retriever))   return;
  WorldWind.getRetrievalService().runRetriever(retriever,0d);
}","@Override protected void retrieveRemoteElevations(final Tile tile,gov.nasa.worldwind.terrain.BasicElevationModel.DownloadPostProcessor postProcessor){
  if (!this.isNetworkRetrievalEnabled()) {
    this.getLevels().markResourceAbsent(tile);
    return;
  }
  if (!WorldWind.getRetrievalService().isAvailable())   return;
  java.net.URL url=null;
  try {
    url=tile.getResourceURL();
    if (WorldWind.getNetworkStatus().isHostUnavailable(url)) {
      this.getLevels().markResourceAbsent(tile);
      return;
    }
  }
 catch (  java.net.MalformedURLException e) {
    Logging.logger().log(java.util.logging.Level.SEVERE,Logging.getMessage(""String_Node_Str"",url),e);
    return;
  }
  if (postProcessor == null)   postProcessor=new DownloadPostProcessor(tile,this);
  URLRetriever retriever=new HTTPRetriever(url,postProcessor);
  boolean formatContainsZip=getLevels().getFirstLevel().getFormatSuffix().toLowerCase().contains(""String_Node_Str"");
  if (isExtractZipEntry() || !formatContainsZip) {
    retriever.setValue(URLRetriever.EXTRACT_ZIP_ENTRY,""String_Node_Str"");
  }
  if (WorldWind.getRetrievalService().contains(retriever))   return;
  WorldWind.getRetrievalService().runRetriever(retriever,0d);
}",0.9390083369899078
11108,"@Override protected void retrieveRemoteElevations(final Tile tile,gov.nasa.worldwind.terrain.BasicElevationModel.DownloadPostProcessor postProcessor){
  if (!this.isNetworkRetrievalEnabled()) {
    this.getLevels().markResourceAbsent(tile);
    return;
  }
  if (!WorldWind.getRetrievalService().isAvailable())   return;
  java.net.URL url=null;
  try {
    url=tile.getResourceURL();
    if (WorldWind.getNetworkStatus().isHostUnavailable(url)) {
      this.getLevels().markResourceAbsent(tile);
      return;
    }
  }
 catch (  java.net.MalformedURLException e) {
    Logging.logger().log(java.util.logging.Level.SEVERE,Logging.getMessage(""String_Node_Str"",url),e);
    return;
  }
  if (postProcessor == null)   postProcessor=new DownloadPostProcessor(tile,this);
  URLRetriever retriever=new HTTPRetriever(url,postProcessor);
  if (isExtractZipEntry()) {
    retriever.setValue(URLRetriever.EXTRACT_ZIP_ENTRY,""String_Node_Str"");
  }
  if (WorldWind.getRetrievalService().contains(retriever))   return;
  WorldWind.getRetrievalService().runRetriever(retriever,0d);
}","@Override protected void retrieveRemoteElevations(final Tile tile,gov.nasa.worldwind.terrain.BasicElevationModel.DownloadPostProcessor postProcessor){
  if (!this.isNetworkRetrievalEnabled()) {
    this.getLevels().markResourceAbsent(tile);
    return;
  }
  if (!WorldWind.getRetrievalService().isAvailable())   return;
  java.net.URL url=null;
  try {
    url=tile.getResourceURL();
    if (WorldWind.getNetworkStatus().isHostUnavailable(url)) {
      this.getLevels().markResourceAbsent(tile);
      return;
    }
  }
 catch (  java.net.MalformedURLException e) {
    Logging.logger().log(java.util.logging.Level.SEVERE,Logging.getMessage(""String_Node_Str"",url),e);
    return;
  }
  if (postProcessor == null)   postProcessor=new DownloadPostProcessor(tile,this);
  URLRetriever retriever=new HTTPRetriever(url,postProcessor);
  boolean formatContainsZip=getLevels().getFirstLevel().getFormatSuffix().toLowerCase().contains(""String_Node_Str"");
  if (isExtractZipEntry() || !formatContainsZip) {
    retriever.setValue(URLRetriever.EXTRACT_ZIP_ENTRY,""String_Node_Str"");
  }
  if (WorldWind.getRetrievalService().contains(retriever))   return;
  WorldWind.getRetrievalService().runRetriever(retriever,0d);
}",0.9390083369899078
11109,"void promptToSetFrameCount(){
  int frames=slider.getLength() - 1;
  Object value=JOptionPane.showInputDialog(frame,getMessage(getSetFrameCountMessageKey()),getMessage(getSetFrameCountCaptionKey()),JOptionPane.QUESTION_MESSAGE,null,null,frames);
  try {
    frames=Integer.parseInt((String)value);
  }
 catch (  Exception ex) {
    ExceptionLogger.logException(ex);
  }
  getCurrentAnimation().setFrameCount(frames);
  updateSlider();
}","void promptToSetFrameCount(){
  int frames=slider.getLength() - 1;
  Object value=JOptionPane.showInputDialog(frame,getMessage(getSetFrameCountMessageKey()),getMessage(getSetFrameCountCaptionKey()),JOptionPane.QUESTION_MESSAGE,null,null,frames);
  if (value != null) {
    try {
      frames=Integer.parseInt((String)value);
    }
 catch (    Exception ex) {
      ExceptionLogger.logException(ex);
    }
    getCurrentAnimation().setFrameCount(frames);
    updateSlider();
  }
}",0.9530054644808744
11110,"@Override public void loaded(ILazyTreeObject object){
  addDefaultLayersFromDataset(lazy,new ArrayList<IData>());
  lazy.removeListener(this);
}","@Override public void loaded(ILazyTreeObject object){
  addDefaultLayersFromDataset(lazy,new ArrayList<IData>());
  lazy.removeListener(this);
  tree.relayoutOnEDT();
}",0.9230769230769232
11111,"@Override public ClearableBasicTreeUI getUI(){
  return (ClearableBasicTreeUI)super.getUI();
}","@Override public ClearableBasicTreeUI getUI(){
  if (super.getUI() != this.ui)   setUI(this.ui);
  return (ClearableBasicTreeUI)super.getUI();
}",0.7899159663865546
11112,"public LayerTree(WorldWindow wwd,INode root){
  super();
  setUI(new ClearableBasicTreeUI());
  enabler=new LayerEnabler(this,wwd);
  LayerTreeModel model=new LayerTreeModel(this,root,enabler);
  setModel(model);
  setCellRenderer(new LayerCellRenderer());
  setCellEditor(new LayerTreeCellEditor(this));
  setEditable(true);
  setShowsRootHandles(true);
  setRootVisible(false);
  setRowHeight(0);
  addTreeExpansionListener(model);
  model.expandNodes();
}","public LayerTree(WorldWindow wwd,INode root){
  super();
  ui=new ClearableBasicTreeUI();
  setUI(ui);
  enabler=new LayerEnabler(this,wwd);
  LayerTreeModel model=new LayerTreeModel(this,root,enabler);
  setModel(model);
  setCellRenderer(new LayerCellRenderer());
  setCellEditor(new LayerTreeCellEditor(this));
  setEditable(true);
  setShowsRootHandles(true);
  setRootVisible(false);
  setRowHeight(0);
  addTreeExpansionListener(model);
  model.expandNodes();
}",0.934054054054054
11113,"private void addFrameRangePane(){
  frameRangePane=new DialogPane(getMessage(getRenderDialogFrameRangeLabelKey()));
  GroupLayout layout=new GroupLayout(frameRangePane);
  frameRangePane.setLayout(layout);
  JLabel frameStartLabel=new JLabel(getMessage(getRenderDialogFrameStartLabelKey()));
  frameStartField=new JIntegerField(true,null);
  frameStartField.setToolTipText(getMessage(getRenderDialogFrameStartTooltipKey()));
  JLabel frameEndLabel=new JLabel(getMessage(getRenderDialogFrameEndLabelKey()));
  frameEndField=new JIntegerField(true,null);
  frameEndField.setToolTipText(getMessage(getRenderDialogFrameEndTooltipKey()));
  Component hGlue=Box.createHorizontalGlue();
  layout.setAutoCreateGaps(true);
  layout.setAutoCreateContainerGaps(true);
  layout.setHorizontalGroup(layout.createSequentialGroup().addComponent(frameStartLabel).addComponent(frameStartField).addComponent(frameEndLabel).addComponent(frameEndField).addComponent(hGlue));
  layout.setVerticalGroup(layout.createParallelGroup().addComponent(frameStartLabel).addComponent(frameStartField).addComponent(frameEndLabel).addComponent(frameEndField).addComponent(hGlue));
  contentPane.add(frameRangePane);
}","private void addFrameRangePane(){
  frameRangePane=new DialogPane(getMessage(getRenderDialogFrameRangeLabelKey()));
  GroupLayout layout=new GroupLayout(frameRangePane);
  frameRangePane.setLayout(layout);
  JLabel frameStartLabel=new JLabel(getMessage(getRenderDialogFrameStartLabelKey()));
  frameStartField=new JIntegerField(true,null);
  frameStartField.setToolTipText(getMessage(getRenderDialogFrameStartTooltipKey()));
  frameStartField.addFocusListener(new FocusAdapter(){
    @Override public void focusLost(    FocusEvent e){
      updateOutputExampleLabel();
    }
  }
);
  JLabel frameEndLabel=new JLabel(getMessage(getRenderDialogFrameEndLabelKey()));
  frameEndField=new JIntegerField(true,null);
  frameEndField.setToolTipText(getMessage(getRenderDialogFrameEndTooltipKey()));
  frameEndField.addFocusListener(new FocusAdapter(){
    @Override public void focusLost(    FocusEvent e){
      updateOutputExampleLabel();
    }
  }
);
  Component hGlue=Box.createHorizontalGlue();
  layout.setAutoCreateGaps(true);
  layout.setAutoCreateContainerGaps(true);
  layout.setHorizontalGroup(layout.createSequentialGroup().addComponent(frameStartLabel).addComponent(frameStartField).addComponent(frameEndLabel).addComponent(frameEndField).addComponent(hGlue));
  layout.setVerticalGroup(layout.createParallelGroup().addComponent(frameStartLabel).addComponent(frameStartField).addComponent(frameEndLabel).addComponent(frameEndField).addComponent(hGlue));
  contentPane.add(frameRangePane);
}",0.883495145631068
11114,"private void initialiseActions(){
  renderAction=new BasicAction(getMessage(getRenderDialogRenderLabelKey()),getMessage(getRenderDialogRenderTooltipKey()),Icons.render.getIcon());
  renderAction.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      bindToAnimation();
      hideDialog(JOptionPane.OK_OPTION);
    }
  }
);
  cancelAction=new BasicAction(getMessage(getTermCancelKey()),null);
  cancelAction.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      hideDialog(JOptionPane.CANCEL_OPTION);
    }
  }
);
}","private void initialiseActions(){
  renderAction=new BasicAction(getMessage(getRenderDialogRenderLabelKey()),getMessage(getRenderDialogRenderTooltipKey()),Icons.render.getIcon());
  renderAction.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      bindToAnimation();
      hideDialog(JOptionPane.OK_OPTION);
    }
  }
);
  cancelAction=new BasicAction(getMessage(getTermCancelKey()),null);
  cancelAction.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      hideDialog(JOptionPane.CANCEL_OPTION);
    }
  }
);
  resetAction=new BasicAction(getMessage(getRenderDialogResetLabelKey()),getMessage(getRenderDialogResetTooltipKey()),null);
  resetAction.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      updateFieldsFromAnimation();
    }
  }
);
}",0.8112344872632267
11115,"@Override public void run(){
  RenderParameters renderParameters=currentAnimation.getRenderParameters();
  widthField.setValue(renderParameters.getImageDimension().width);
  heightField.setValue(renderParameters.getImageDimension().height);
  lockedCheck.setSelected(renderParameters.isDimensionsLocked());
  scaleField.setValue(renderParameters.getImageScalePercent());
  aspectRatio=renderParameters.getImageAspectRatio();
  detailField.setValue(renderParameters.getDetailLevel());
  if (renderParameters.getRenderDestination() != null) {
    destinationField.setText(renderParameters.getRenderDestination().getAbsolutePath());
  }
  frameStartField.setValue(renderParameters.getStartFrame() == null ? 0 : renderParameters.getStartFrame());
  frameEndField.setValue(renderParameters.getEndFrame() == null ? currentAnimation.getFrameCount() : renderParameters.getStartFrame());
  updateRenderDimensions();
}","@Override public void run(){
  RenderParameters renderParameters=currentAnimation.getRenderParameters();
  widthField.setValue(renderParameters.getImageDimension().width);
  heightField.setValue(renderParameters.getImageDimension().height);
  lockedCheck.setSelected(renderParameters.isDimensionsLocked());
  scaleField.setValue(renderParameters.getImageScalePercent());
  aspectRatio=renderParameters.getImageAspectRatio();
  detailField.setValue(renderParameters.getDetailLevel());
  if (renderParameters.getRenderDestination() != null) {
    destinationField.setText(renderParameters.getRenderDestination().getAbsolutePath());
  }
  frameStartField.setValue(renderParameters.getStartFrame() == null ? 0 : renderParameters.getStartFrame());
  frameEndField.setValue(renderParameters.getEndFrame() == null ? currentAnimation.getFrameCount() : renderParameters.getEndFrame());
  updateRenderDimensions();
}",0.9955898566703418
11116,"@Override public void actionPerformed(ActionEvent e){
  if (!isBlank(destinationField.getText())) {
    fileChooser.setCurrentDirectory(new File(destinationField.getText()));
  }
 else {
    fileChooser.setCurrentDirectory(Settings.get().getLastUsedLocation());
  }
  fileChooser.showOpenDialog(RenderDialog.this);
  if (fileChooser.getSelectedFile() == null) {
    return;
  }
  destinationField.setText(fileChooser.getSelectedFile().getAbsolutePath());
}","@Override public void actionPerformed(ActionEvent e){
  if (!isBlank(destinationField.getText())) {
    File currentDir=new File(destinationField.getText());
    while (!currentDir.exists() && !currentDir.isDirectory()) {
      if (currentDir.getParentFile() == null) {
        break;
      }
      currentDir=currentDir.getParentFile();
    }
    fileChooser.setCurrentDirectory(currentDir);
  }
 else {
    fileChooser.setCurrentDirectory(Settings.get().getLastUsedLocation());
  }
  fileChooser.showOpenDialog(RenderDialog.this);
  if (fileChooser.getSelectedFile() == null) {
    return;
  }
  destinationField.setText(fileChooser.getSelectedFile().getAbsolutePath());
  updateOutputExampleLabel();
}",0.7241379310344828
11117,"private void addButtonPanel(){
  contentPane.add(Box.createVerticalGlue());
  JPanel buttonPanel=new JPanel(new FlowLayout(FlowLayout.CENTER));
  buttonPanel.add(new JButton(renderAction));
  buttonPanel.add(new JButton(cancelAction));
  buttonPanel.setAlignmentY(JPanel.BOTTOM_ALIGNMENT);
  buttonPanel.setMaximumSize(new Dimension(400,30));
  contentPane.add(buttonPanel);
}","private void addButtonPanel(){
  contentPane.add(Box.createVerticalGlue());
  JPanel buttonPanel=new JPanel(new FlowLayout(FlowLayout.CENTER));
  buttonPanel.add(new JButton(renderAction));
  buttonPanel.add(new JButton(cancelAction));
  buttonPanel.add(new JButton(resetAction));
  buttonPanel.setAlignmentY(JPanel.BOTTOM_ALIGNMENT);
  buttonPanel.setMaximumSize(new Dimension(400,30));
  contentPane.add(buttonPanel);
}",0.9435382685069008
11118,"private void initialiseDialog(){
  setModal(true);
  setTitle(getMessage(getRenderDialogTitleKey()));
  setIconImage(Icons.render.getIcon().getImage());
  contentPane=new JPanel();
  contentPane.setLayout(new BoxLayout(contentPane,BoxLayout.Y_AXIS));
  setContentPane(contentPane);
  setMinimumSize(new Dimension(300,370));
  setResizable(false);
}","private void initialiseDialog(){
  setModal(true);
  setTitle(getMessage(getRenderDialogTitleKey()));
  setIconImage(Icons.render.getIcon().getImage());
  contentPane=new JPanel();
  contentPane.setLayout(new BoxLayout(contentPane,BoxLayout.Y_AXIS));
  setContentPane(contentPane);
  setMinimumSize(new Dimension(DIALOG_WIDTH,DIALOG_HEIGHT));
  setResizable(false);
}",0.9566433566433566
11119,"@Override public void setVisible(boolean visible){
  if (visible) {
    updateFieldsFromAnimation();
  }
  super.setVisible(visible);
}","@Override public void setVisible(boolean visible){
  if (visible) {
    updateFieldsFromAnimation();
    updateOutputExampleLabel();
    response=JOptionPane.CANCEL_OPTION;
  }
  super.setVisible(visible);
}",0.7894736842105263
11120,"private void addDestinationPane(){
  destinationPane=new DialogPane(getMessage(getRenderDialogDestinationLabelKey()));
  GroupLayout layout=new GroupLayout(destinationPane);
  destinationPane.setLayout(layout);
  JLabel destinationLabel=new JLabel(getMessage(getRenderDialogOutputFieldLabelKey()));
  JButton browseButton=new JButton(Icons.folder.getIcon());
  browseButton.setMargin(new Insets(0,0,0,0));
  browseButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      if (!isBlank(destinationField.getText())) {
        fileChooser.setCurrentDirectory(new File(destinationField.getText()));
      }
 else {
        fileChooser.setCurrentDirectory(Settings.get().getLastUsedLocation());
      }
      fileChooser.showOpenDialog(RenderDialog.this);
      if (fileChooser.getSelectedFile() == null) {
        return;
      }
      destinationField.setText(fileChooser.getSelectedFile().getAbsolutePath());
    }
  }
);
  destinationField=new JTextField();
  destinationField.setToolTipText(getMessage(getRenderDialogOutputFieldTooltipKey()));
  destinationField.setMinimumSize(new Dimension(200,10));
  destinationField.addPropertyChangeListener(""String_Node_Str"",new PropertyChangeListener(){
    @Override public void propertyChange(    PropertyChangeEvent evt){
      updateOutputExampleLabel();
    }
  }
);
  destinationField.addFocusListener(new FocusAdapter(){
    @Override public void focusLost(    FocusEvent e){
      updateOutputExampleLabel();
    }
  }
);
  outputExampleLabel=new JLabel();
  Component hGlue=Box.createHorizontalGlue();
  layout.setAutoCreateGaps(true);
  layout.setAutoCreateContainerGaps(true);
  layout.setHorizontalGroup(layout.createParallelGroup().addGroup(layout.createSequentialGroup().addComponent(destinationLabel).addComponent(destinationField).addComponent(browseButton).addComponent(hGlue)).addComponent(outputExampleLabel));
  layout.setVerticalGroup(layout.createSequentialGroup().addGroup(layout.createParallelGroup().addComponent(destinationLabel).addComponent(destinationField).addComponent(browseButton).addComponent(hGlue)).addComponent(outputExampleLabel));
  contentPane.add(destinationPane);
}","private void addDestinationPane(){
  destinationPane=new DialogPane(getMessage(getRenderDialogDestinationLabelKey()));
  GroupLayout layout=new GroupLayout(destinationPane);
  destinationPane.setLayout(layout);
  JLabel destinationLabel=new JLabel(getMessage(getRenderDialogOutputFieldLabelKey()));
  JButton browseButton=new JButton(Icons.folder.getIcon());
  browseButton.setMargin(new Insets(0,0,0,0));
  browseButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      if (!isBlank(destinationField.getText())) {
        File currentDir=new File(destinationField.getText());
        while (!currentDir.exists() && !currentDir.isDirectory()) {
          if (currentDir.getParentFile() == null) {
            break;
          }
          currentDir=currentDir.getParentFile();
        }
        fileChooser.setCurrentDirectory(currentDir);
      }
 else {
        fileChooser.setCurrentDirectory(Settings.get().getLastUsedLocation());
      }
      fileChooser.showOpenDialog(RenderDialog.this);
      if (fileChooser.getSelectedFile() == null) {
        return;
      }
      destinationField.setText(fileChooser.getSelectedFile().getAbsolutePath());
      updateOutputExampleLabel();
    }
  }
);
  destinationField=new JTextField();
  destinationField.setToolTipText(getMessage(getRenderDialogOutputFieldTooltipKey()));
  destinationField.setMinimumSize(new Dimension(200,10));
  destinationField.addPropertyChangeListener(""String_Node_Str"",new PropertyChangeListener(){
    @Override public void propertyChange(    PropertyChangeEvent evt){
      updateOutputExampleLabel();
    }
  }
);
  destinationField.addFocusListener(new FocusAdapter(){
    @Override public void focusLost(    FocusEvent e){
      updateOutputExampleLabel();
    }
  }
);
  outputExampleLabel=new JLabel();
  Component hGlue=Box.createHorizontalGlue();
  layout.setAutoCreateGaps(true);
  layout.setAutoCreateContainerGaps(true);
  layout.setHorizontalGroup(layout.createParallelGroup().addGroup(layout.createSequentialGroup().addComponent(destinationLabel).addComponent(destinationField).addComponent(browseButton).addComponent(hGlue)).addComponent(outputExampleLabel));
  layout.setVerticalGroup(layout.createSequentialGroup().addGroup(layout.createParallelGroup().addComponent(destinationLabel).addComponent(destinationField).addComponent(browseButton).addComponent(hGlue)).addComponent(outputExampleLabel));
  contentPane.add(destinationPane);
}",0.9249466950959488
11121,"private void bindToAnimation(){
  if (currentAnimation == null) {
    return;
  }
  RenderParameters renderParameters=currentAnimation.getRenderParameters();
  renderParameters.setImageDimension(new Dimension(widthField.getValue(),heightField.getValue()));
  renderParameters.setDimensionsLocked(lockedCheck.isSelected());
  renderParameters.setImageScalePercent(scaleField.getValue());
  renderParameters.setDetailLevel(detailField.getValue());
  renderParameters.setRenderDestination(isBlank(destinationField.getText()) ? null : new File(destinationField.getText()));
  renderParameters.setStartFrame(Math.max(frameStartField.getValue(),0));
  renderParameters.setEndFrame(Math.min(frameStartField.getValue(),currentAnimation.getFrameCount()));
}","private void bindToAnimation(){
  if (currentAnimation == null) {
    return;
  }
  RenderParameters renderParameters=currentAnimation.getRenderParameters();
  renderParameters.setImageDimension(new Dimension(widthField.getValue(),heightField.getValue()));
  renderParameters.setDimensionsLocked(lockedCheck.isSelected());
  renderParameters.setImageScalePercent(scaleField.getValue());
  renderParameters.setDetailLevel(detailField.getValue());
  renderParameters.setRenderDestination(isBlank(destinationField.getText()) ? null : new File(destinationField.getText()));
  renderParameters.setStartFrame(Math.max(frameStartField.getValue(),0));
  renderParameters.setEndFrame(Math.min(frameEndField.getValue(),currentAnimation.getFrameCount()));
}",0.994645247657296
11122,"private void updateFieldsFromAnimation(){
  if (currentAnimation == null) {
    return;
  }
  SwingUtil.invokeTaskOnEDT(new Runnable(){
    @Override public void run(){
      RenderParameters renderParameters=currentAnimation.getRenderParameters();
      widthField.setValue(renderParameters.getImageDimension().width);
      heightField.setValue(renderParameters.getImageDimension().height);
      lockedCheck.setSelected(renderParameters.isDimensionsLocked());
      scaleField.setValue(renderParameters.getImageScalePercent());
      aspectRatio=renderParameters.getImageAspectRatio();
      detailField.setValue(renderParameters.getDetailLevel());
      if (renderParameters.getRenderDestination() != null) {
        destinationField.setText(renderParameters.getRenderDestination().getAbsolutePath());
      }
      frameStartField.setValue(renderParameters.getStartFrame() == null ? 0 : renderParameters.getStartFrame());
      frameEndField.setValue(renderParameters.getEndFrame() == null ? currentAnimation.getFrameCount() : renderParameters.getStartFrame());
      updateRenderDimensions();
    }
  }
);
}","private void updateFieldsFromAnimation(){
  if (currentAnimation == null) {
    return;
  }
  SwingUtil.invokeTaskOnEDT(new Runnable(){
    @Override public void run(){
      RenderParameters renderParameters=currentAnimation.getRenderParameters();
      widthField.setValue(renderParameters.getImageDimension().width);
      heightField.setValue(renderParameters.getImageDimension().height);
      lockedCheck.setSelected(renderParameters.isDimensionsLocked());
      scaleField.setValue(renderParameters.getImageScalePercent());
      aspectRatio=renderParameters.getImageAspectRatio();
      detailField.setValue(renderParameters.getDetailLevel());
      if (renderParameters.getRenderDestination() != null) {
        destinationField.setText(renderParameters.getRenderDestination().getAbsolutePath());
      }
      frameStartField.setValue(renderParameters.getStartFrame() == null ? 0 : renderParameters.getStartFrame());
      frameEndField.setValue(renderParameters.getEndFrame() == null ? currentAnimation.getFrameCount() : renderParameters.getEndFrame());
      updateRenderDimensions();
    }
  }
);
}",0.9964028776978416
11123,"private void updateOutputExampleLabel(){
  if (isBlank(destinationField.getText())) {
    outputExampleLabel.setText(getMessage(getRenderDialogOutputExampleLabelKey()));
  }
  File destinationFile=new File(destinationField.getText());
  String name=stripSequenceNumber(stripExtension(destinationFile.getName()));
  int firstFrame=getCurrentAnimation().getFrameOfFirstKeyFrame();
  int lastFrame=getCurrentAnimation().getFrameOfLastKeyFrame();
  int filenameLength=String.valueOf(lastFrame).length();
  final String example=createSequenceFileName(name,firstFrame,filenameLength,""String_Node_Str"") + ""String_Node_Str"" + createSequenceFileName(name,lastFrame,filenameLength,""String_Node_Str"");
  SwingUtil.invokeTaskOnEDT(new Runnable(){
    @Override public void run(){
      outputExampleLabel.setText(getMessage(getRenderDialogOutputExampleLabelKey(),example));
    }
  }
);
}","private void updateOutputExampleLabel(){
  if (isBlank(destinationField.getText())) {
    outputExampleLabel.setText(getMessage(getRenderDialogOutputExampleLabelKey(),""String_Node_Str""));
    return;
  }
  File destinationFile=new File(destinationField.getText());
  String name=stripSequenceNumber(stripExtension(destinationFile.getName()));
  int firstFrame=Math.max(0,frameStartField.getValue());
  int lastFrame=Math.min(frameEndField.getValue(),getCurrentAnimation().getFrameCount());
  int filenameLength=String.valueOf(lastFrame).length();
  final String example=createSequenceFileName(name,firstFrame,filenameLength,""String_Node_Str"") + ""String_Node_Str"" + createSequenceFileName(name,lastFrame,filenameLength,""String_Node_Str"");
  SwingUtil.invokeTaskOnEDT(new Runnable(){
    @Override public void run(){
      outputExampleLabel.setText(getMessage(getRenderDialogOutputExampleLabelKey(),example));
    }
  }
);
}",0.886047804335742
11124,"@Override protected void applyDrawProjection(DrawContext dc){
  boolean loaded=false;
  if (dc.getView() instanceof StereoView) {
    StereoView stereo=(StereoView)dc.getView();
    double near=100;
    double far=stereo.getFarClipDistance() + 10e3;
    Matrix projection=stereo.calculateProjectionMatrix(near,far);
    if (projection != null) {
      double[] matrixArray=new double[16];
      GL gl=dc.getGL();
      gl.glMatrixMode(GL.GL_PROJECTION);
      gl.glPushMatrix();
      projection.toArray(matrixArray,0,false);
      gl.glLoadMatrixd(matrixArray,0);
      loaded=true;
    }
  }
  if (!loaded) {
    super.applyDrawProjection(dc);
  }
}","@Override protected void applyDrawProjection(DrawContext dc){
  boolean loaded=false;
  if (dc.getView() instanceof StereoView) {
    StereoView stereo=(StereoView)dc.getView();
    double near=100;
    double far=stereo.computeHorizonDistance() + 10e3;
    Matrix projection=stereo.calculateProjectionMatrix(near,far);
    if (projection != null) {
      double[] matrixArray=new double[16];
      GL gl=dc.getGL();
      gl.glMatrixMode(GL.GL_PROJECTION);
      gl.glPushMatrix();
      projection.toArray(matrixArray,0,false);
      gl.glLoadMatrixd(matrixArray,0);
      loaded=true;
    }
  }
  if (!loaded) {
    super.applyDrawProjection(dc);
  }
}",0.981623277182236
11125,"@Override protected void updateSkyDone(DrawContext dc){
  GL gl=dc.getGL();
  View view=dc.getView();
  if (this.glListId != -1)   gl.glDeleteLists(this.glListId,1);
  double tangentalDistance=view.computeHorizonDistance();
  double distToCenterOfPlanet=view.getEyePoint().getLength3();
  Position camPos=dc.getGlobe().computePositionFromPoint(view.getEyePoint());
  double worldRadius=dc.getGlobe().getRadiusAt(camPos);
  double camAlt=camPos.getElevation();
  double horizonLat=(-Math.PI / 2 + Math.acos(tangentalDistance / distToCenterOfPlanet)) * 180 / Math.PI;
  double zenithLat=90;
  float zenithOpacity=1f;
  float gradientBias=2f;
  if (camAlt >= thickness) {
    double tangentalDistanceZenith=Math.sqrt(distToCenterOfPlanet * distToCenterOfPlanet - (worldRadius + thickness) * (worldRadius + thickness));
    zenithLat=(-Math.PI / 2 + Math.acos(tangentalDistanceZenith / distToCenterOfPlanet)) * 180 / Math.PI;
    zenithOpacity=0f;
    gradientBias=1f;
  }
  if (camAlt < thickness && camAlt > thickness * 0.7) {
    double factor=(thickness - camAlt) / (thickness - thickness * 0.7);
    zenithLat=factor * 90;
    zenithOpacity=(float)factor;
    gradientBias=1f + (float)factor;
  }
  this.makeSkyDome(dc,(float)(tangentalDistance),horizonLat,zenithLat,SLICES,STACKS,zenithOpacity,gradientBias);
  this.lastRebuildHorizon=tangentalDistance;
}","@Override protected void updateSkyDone(DrawContext dc){
  GL gl=dc.getGL();
  View view=dc.getView();
  if (this.glListId != -1) {
    gl.glDeleteLists(this.glListId,1);
  }
  double tangentalDistance=view.computeHorizonDistance();
  double distToCenterOfPlanet=view.getEyePoint().getLength3();
  Position camPos=dc.getGlobe().computePositionFromPoint(view.getEyePoint());
  double worldRadius=dc.getGlobe().getRadiusAt(camPos);
  double camAlt=camPos.getElevation();
  double horizonLat=(-PI_ON_2 + Math.acos(tangentalDistance / distToCenterOfPlanet)) * ONE80_ON_PI;
  double zenithLat=90;
  float zenithOpacity=1f;
  float gradientBias=2f;
  if (camAlt >= thickness) {
    double tangentalDistanceZenith=Math.sqrt(distToCenterOfPlanet * distToCenterOfPlanet - (worldRadius + thickness) * (worldRadius + thickness));
    zenithLat=(-PI_ON_2 + Math.acos(tangentalDistanceZenith / distToCenterOfPlanet)) * ONE80_ON_PI;
    zenithOpacity=0f;
    gradientBias=1f;
  }
  if (camAlt < thickness && camAlt > thickness * 0.7) {
    double factor=(thickness - camAlt) / (thickness - thickness * 0.7);
    zenithLat=factor * 90;
    zenithOpacity=(float)factor;
    gradientBias=1f + (float)factor;
  }
  this.makeSkyDome(dc,(float)(tangentalDistance),horizonLat,zenithLat,SLICES,STACKS,zenithOpacity,gradientBias);
  this.lastRebuildHorizon=tangentalDistance;
}",0.9306273062730628
11126,"@Override protected void doPreRender(final Animation animation,int firstFrame,int lastFrame,File outputDir,String frameName,double detailHint,boolean alpha){
  setupForRendering(detailHint);
  final Dimension renderDimensions=animation.getRenderParameters().getImageDimension();
  animatorSceneController.addPrePaintTask(new PaintTask(){
    @Override public void run(    DrawContext dc){
      frameBuffer.create(dc.getGL(),renderDimensions);
    }
  }
);
  preRenderTask=new PaintTask(){
    @Override public void run(    DrawContext dc){
      GL gl=dc.getGL();
      frameBuffer.bind(gl);
      gl.glViewport(0,0,renderDimensions.width,renderDimensions.height);
    }
  }
;
  postRenderTask=new PaintTask(){
    @Override public void run(    DrawContext dc){
      GL gl=dc.getGL();
      frameBuffer.unbind(gl);
      gl.glViewport(0,0,dc.getDrawableWidth(),dc.getDrawableHeight());
      FrameBuffer.renderTexturedQuad(gl,frameBuffer.getTextureId());
    }
  }
;
  wwd.redrawNow();
}","@Override protected void doPreRender(final Animation animation,int firstFrame,int lastFrame,File outputDir,String frameName,double detailHint,boolean alpha){
  setupForRendering(detailHint);
  final Dimension renderDimensions=animation.getRenderParameters().getImageDimension();
  animatorSceneController.addPrePaintTask(new PaintTask(){
    @Override public void run(    DrawContext dc){
      frameBuffer.create(dc.getGL(),renderDimensions);
    }
  }
);
  preRenderTask=new PaintTask(){
    @Override public void run(    DrawContext dc){
      GL gl=dc.getGL();
      frameBuffer.bind(gl);
      gl.glViewport(0,0,renderDimensions.width,renderDimensions.height);
    }
  }
;
  prePostRenderTask=new PaintTask(){
    @Override public void run(    DrawContext dc){
      GL gl=dc.getGL();
      gl.glViewport(0,0,renderDimensions.width,renderDimensions.height);
    }
  }
;
  postRenderTask=new PaintTask(){
    @Override public void run(    DrawContext dc){
      GL gl=dc.getGL();
      frameBuffer.unbind(gl);
      gl.glViewport(0,0,dc.getDrawableWidth(),dc.getDrawableHeight());
      FrameBuffer.renderTexturedQuad(gl,frameBuffer.getTextureId());
    }
  }
;
  wwd.redrawNow();
}",0.909425287356322
11127,"@Override protected void doRender(Animation animation,int frame,final File targetFile,double detailHint,boolean alpha){
  targetApplication.setSlider(frame);
  animation.applyFrame(frame);
  animatorSceneController.addPrePaintTask(preRenderTask);
  animatorSceneController.addPostPaintTask(preRenderTask);
  ScreenshotPaintTask screenshotTask=new ScreenshotPaintTask(targetFile,alpha);
  animatorSceneController.addPostPaintTask(screenshotTask);
  animatorSceneController.addPostPaintTask(postRenderTask);
  wwd.redraw();
  screenshotTask.waitForScreenshot();
}","@Override protected void doRender(Animation animation,int frame,final File targetFile,double detailHint,boolean alpha){
  targetApplication.setSlider(frame);
  animation.applyFrame(frame);
  animatorSceneController.addPrePaintTask(preRenderTask);
  animatorSceneController.addPostPaintTask(prePostRenderTask);
  ScreenshotPaintTask screenshotTask=new ScreenshotPaintTask(targetFile,alpha);
  animatorSceneController.addPostPaintTask(screenshotTask);
  animatorSceneController.addPostPaintTask(postRenderTask);
  wwd.redraw();
  screenshotTask.waitForScreenshot();
}",0.9964476021314388
11128,"/** 
 * Initialise the side bar, which contains a group of collapsible panels
 */
private void initialiseSideBar(){
  animationBrowserPanel=new AnimationBrowserPanel(getCurrentAnimation());
  objectPropertiesPanel=new ObjectPropertiesPanel(getCurrentAnimation());
  layerPalettePanel=new LayerPalettePanel(getCurrentAnimation());
  List<CollapsiblePanel> collapsiblePanels=new ArrayList<CollapsiblePanel>(3);
  collapsiblePanels.add(animationBrowserPanel);
  collapsiblePanels.add(objectPropertiesPanel);
  collapsiblePanels.add(layerPalettePanel);
  sideBar=new SideBar(splitPane,collapsiblePanels);
  splitPane.setLeftComponent(sideBar);
  slider.addChangeFrameListener(objectPropertiesPanel);
  slider.addChangeListener(objectPropertiesPanel);
  getView().addPropertyChangeListener(AVKey.VIEW,objectPropertiesPanel);
  animationChangeListeners.add(sideBar);
}","/** 
 * Initialise the side bar, which contains a group of collapsible panels
 */
private void initialiseSideBar(){
  animationBrowserPanel=new AnimationBrowserPanel(getCurrentAnimation());
  objectPropertiesPanel=new ObjectPropertiesPanel(getCurrentAnimation());
  layerPalettePanel=new LayerPalettePanel(getCurrentAnimation());
  List<CollapsiblePanel> collapsiblePanels=new ArrayList<CollapsiblePanel>(3);
  collapsiblePanels.add(animationBrowserPanel);
  collapsiblePanels.add(objectPropertiesPanel);
  collapsiblePanels.add(layerPalettePanel);
  sideBar=new SideBar(splitPane,collapsiblePanels);
  splitPane.setLeftComponent(sideBar);
  slider.addChangeFrameListener(objectPropertiesPanel);
  slider.addChangeListener(objectPropertiesPanel);
  getView().addPropertyChangeListener(AVKey.VIEW,objectPropertiesPanel);
  changeOfAnimationListeners.add(sideBar);
}",0.9907300115874856
11129,"private void initialiseKeyFrameClipboard(){
  keyFrameClipboard=new KeyFrameClipboard(getCurrentAnimation());
  slider.addChangeListener(keyFrameClipboard);
  slider.addChangeFrameListener(keyFrameClipboard);
  animation.addChangeListener(keyFrameClipboard);
  animationChangeListeners.add(keyFrameClipboard);
}","private void initialiseKeyFrameClipboard(){
  keyFrameClipboard=new KeyFrameClipboard(getCurrentAnimation());
  slider.addChangeListener(keyFrameClipboard);
  slider.addChangeFrameListener(keyFrameClipboard);
  animation.addChangeListener(keyFrameClipboard);
  changeOfAnimationListeners.add(keyFrameClipboard);
}",0.9647435897435898
11130,"private void notifyAnimationChanged(Animation newAnimation){
  for (int i=animationChangeListeners.size() - 1; i >= 0; i--) {
    animationChangeListeners.get(i).updateAnimation(newAnimation);
  }
}","private void notifyAnimationChanged(Animation newAnimation){
  for (int i=changeOfAnimationListeners.size() - 1; i >= 0; i--) {
    changeOfAnimationListeners.get(i).updateAnimation(newAnimation);
  }
}",0.89
11131,"private void initialiseParameterEditor(){
  this.parameterEditor=new ParameterEditor(this);
}","private void initialiseParameterEditor(){
  this.parameterEditor=new ParameterEditor(this);
  changeOfAnimationListeners.add(parameterEditor);
}",0.7848101265822784
11132,"/** 
 * Initialise the utility layers used inside the animator application
 */
private void initialiseUtilityLayers(){
  if (cameraPathLayer == null) {
    cameraPathLayer=new CameraPathLayer(wwd,getCurrentAnimation());
    wwd.addSelectListener(cameraPathLayer);
    cameraPathLayer.setEnabled(Settings.get().isCameraPathShown());
    animationChangeListeners.add(cameraPathLayer);
  }
  if (crosshair == null) {
    crosshair=new CrosshairLayer();
  }
  if (gridOverlay == null) {
    gridOverlay=new GridOverlayLayer();
    gridOverlay.setEnabled(Settings.get().isGridShown());
  }
  if (ruleOfThirdsOverlay == null) {
    ruleOfThirdsOverlay=new GridOverlayLayer(false,1 / 3d,1 / 3d);
    ruleOfThirdsOverlay.setGridColor(Color.GREEN);
    ruleOfThirdsOverlay.setEnabled(Settings.get().isRuleOfThirdsShown());
  }
}","/** 
 * Initialise the utility layers used inside the animator application
 */
private void initialiseUtilityLayers(){
  if (cameraPathLayer == null) {
    cameraPathLayer=new CameraPathLayer(wwd,getCurrentAnimation());
    wwd.addSelectListener(cameraPathLayer);
    cameraPathLayer.setEnabled(Settings.get().isCameraPathShown());
    changeOfAnimationListeners.add(cameraPathLayer);
  }
  if (crosshair == null) {
    crosshair=new CrosshairLayer();
  }
  if (gridOverlay == null) {
    gridOverlay=new GridOverlayLayer();
    gridOverlay.setEnabled(Settings.get().isGridShown());
  }
  if (ruleOfThirdsOverlay == null) {
    ruleOfThirdsOverlay=new GridOverlayLayer(false,1 / 3d,1 / 3d);
    ruleOfThirdsOverlay.setGridColor(Color.GREEN);
    ruleOfThirdsOverlay.setEnabled(Settings.get().isRuleOfThirdsShown());
  }
}",0.9804878048780488
11133,"public KeyFrameMarkers(WorldWindow wwd,Animation animation){
  this.worldWindow=wwd;
  setAnimation(animation);
}","public KeyFrameMarkers(WorldWindow wwd,Animation animation){
  this.worldWindow=wwd;
  setAnimation(animation);
  markerRenderer.setKeepSeparated(false);
}",0.8432835820895522
11134,"/** 
 * Draw the camera eye position key frame markers
 */
private void drawKeyFrameMarkers(DrawContext dc){
  try {
    frontLock.readLock().lock();
    markerRenderer.render(dc,eyeMarkersFrontBuffer);
    markerRenderer.render(dc,lookatMarkersFrontBuffer);
    drawJoiners(dc);
  }
  finally {
    frontLock.readLock().unlock();
  }
}","/** 
 * Draw the camera eye position key frame markers
 */
private void drawKeyFrameMarkers(DrawContext dc){
  try {
    frontLock.readLock().lock();
    ArrayList<Marker> combinedBuffer=new ArrayList<Marker>();
    combinedBuffer.addAll(eyeMarkersFrontBuffer);
    combinedBuffer.addAll(lookatMarkersFrontBuffer);
    markerRenderer.render(dc,combinedBuffer);
    drawJoiners(dc);
  }
  finally {
    frontLock.readLock().unlock();
  }
}",0.6847545219638242
11135,"private void setupSplitPane(){
  TreeModel model=new ParameterTreeModel(targetApplication.getCurrentAnimation());
  parameterTree=new NameableTree(model);
  parameterTree.setEditable(false);
  parameterTree.getSelectionModel().setSelectionMode(TreeSelectionModel.SINGLE_TREE_SELECTION);
  parameterTree.setToggleClickCount(-1);
  parameterTree.setActionMap(null);
  leftScrollPane=new JScrollPane(parameterTree);
  rightScrollPane=new JScrollPane(new JPanel());
  containerPane=new JSplitPane();
  containerPane.setDividerLocation(300);
  containerPane.setLeftComponent(leftScrollPane);
  containerPane.setRightComponent(rightScrollPane);
  add(containerPane);
}","private void setupSplitPane(){
  treeModel=new ParameterTreeModel(targetApplication.getCurrentAnimation());
  parameterTree=new NameableTree(treeModel);
  parameterTree.setEditable(false);
  parameterTree.getSelectionModel().setSelectionMode(TreeSelectionModel.SINGLE_TREE_SELECTION);
  parameterTree.setToggleClickCount(-1);
  parameterTree.setActionMap(null);
  leftScrollPane=new JScrollPane(parameterTree);
  rightScrollPane=new JScrollPane(new JPanel());
  containerPane=new JSplitPane();
  containerPane.setDividerLocation(300);
  containerPane.setLeftComponent(leftScrollPane);
  containerPane.setRightComponent(rightScrollPane);
  add(containerPane);
}",0.989409984871407
11136,"/** 
 * Draw the camera path
 */
private void drawPath(DrawContext dc){
  if (frameCount <= 0 || dc.isPickingMode()) {
    return;
  }
  GL gl=dc.getGL();
  gl.glPushClientAttrib(GL.GL_CLIENT_VERTEX_ARRAY_BIT);
  gl.glPushAttrib(GL.GL_ALL_ATTRIB_BITS);
  boolean popRefCenter=false;
  if (pathReferenceCenter != null) {
    dc.getView().pushReferenceCenter(dc,pathReferenceCenter);
    popRefCenter=true;
  }
  try {
    gl.glEnableClientState(GL.GL_VERTEX_ARRAY);
    gl.glEnableClientState(GL.GL_COLOR_ARRAY);
    gl.glShadeModel(GL.GL_SMOOTH);
    gl.glEnable(GL.GL_LINE_SMOOTH);
    gl.glEnable(GL.GL_POINT_SMOOTH);
    gl.glEnable(GL.GL_BLEND);
    gl.glBlendFunc(GL.GL_SRC_ALPHA,GL.GL_ONE_MINUS_SRC_ALPHA);
    gl.glHint(GL.GL_LINE_SMOOTH_HINT,GL.GL_NICEST);
    gl.glHint(GL.GL_POINT_SMOOTH_HINT,GL.GL_NICEST);
    gl.glLineWidth(2.0f);
    gl.glPointSize(2.0f);
    int numberOfPointsInPath=animation.getFrameOfLastKeyFrame() - animation.getFrameOfFirstKeyFrame() + 1;
    if (numberOfPointsInPath <= 1)     return;
synchronized (pathBufferLock) {
      if (enableDepthTesting) {
        gl.glEnable(GL.GL_DEPTH_TEST);
      }
 else {
        gl.glDisable(GL.GL_DEPTH_TEST);
      }
      gl.glShadeModel(GL.GL_FLAT);
      gl.glColorPointer(3,GL.GL_DOUBLE,0,pathColourFrontBuffer);
      gl.glVertexPointer(3,GL.GL_DOUBLE,0,pathVertexFrontBuffer);
      gl.glDepthMask(false);
      gl.glDrawArrays(GL.GL_LINE_STRIP,0,numberOfPointsInPath);
      gl.glDrawArrays(GL.GL_POINTS,0,numberOfPointsInPath);
      gl.glDepthMask(true);
      gl.glDrawArrays(GL.GL_LINE_STRIP,0,numberOfPointsInPath);
    }
  }
  finally {
    if (popRefCenter) {
      dc.getView().popReferenceCenter(dc);
    }
    gl.glPopAttrib();
    gl.glPopClientAttrib();
  }
}","/** 
 * Draw the camera path
 */
private void drawPath(DrawContext dc){
  if (frameCount <= 0 || dc.isPickingMode()) {
    return;
  }
  GL gl=dc.getGL();
  gl.glPushClientAttrib(GL.GL_CLIENT_VERTEX_ARRAY_BIT);
  gl.glPushAttrib(GL.GL_ALL_ATTRIB_BITS);
  boolean popRefCenter=false;
  try {
synchronized (pathBufferLock) {
      if (pathReferenceCenter != null) {
        dc.getView().pushReferenceCenter(dc,pathReferenceCenter);
        popRefCenter=true;
      }
      gl.glEnableClientState(GL.GL_VERTEX_ARRAY);
      gl.glEnableClientState(GL.GL_COLOR_ARRAY);
      gl.glShadeModel(GL.GL_SMOOTH);
      gl.glEnable(GL.GL_LINE_SMOOTH);
      gl.glEnable(GL.GL_POINT_SMOOTH);
      gl.glEnable(GL.GL_BLEND);
      gl.glBlendFunc(GL.GL_SRC_ALPHA,GL.GL_ONE_MINUS_SRC_ALPHA);
      gl.glHint(GL.GL_LINE_SMOOTH_HINT,GL.GL_NICEST);
      gl.glHint(GL.GL_POINT_SMOOTH_HINT,GL.GL_NICEST);
      gl.glLineWidth(2.0f);
      gl.glPointSize(2.0f);
      int numberOfPointsInPath=animation.getFrameOfLastKeyFrame() - animation.getFrameOfFirstKeyFrame() + 1;
      if (numberOfPointsInPath <= 1) {
        return;
      }
      if (enableDepthTesting) {
        gl.glEnable(GL.GL_DEPTH_TEST);
      }
 else {
        gl.glDisable(GL.GL_DEPTH_TEST);
      }
      gl.glShadeModel(GL.GL_FLAT);
      gl.glColorPointer(3,GL.GL_DOUBLE,0,pathColourFrontBuffer);
      gl.glVertexPointer(3,GL.GL_DOUBLE,0,pathVertexFrontBuffer);
      gl.glDepthMask(false);
      gl.glDrawArrays(GL.GL_LINE_STRIP,0,numberOfPointsInPath);
      gl.glDrawArrays(GL.GL_POINTS,0,numberOfPointsInPath);
      gl.glDepthMask(true);
      gl.glDrawArrays(GL.GL_LINE_STRIP,0,numberOfPointsInPath);
    }
  }
  finally {
    if (popRefCenter) {
      dc.getView().popReferenceCenter(dc);
    }
    gl.glPopAttrib();
    gl.glPopClientAttrib();
  }
}",0.9634831460674156
11137,"protected static void addPlace(Element context,List<Place> places,XPath xpath,Globe globe){
  Place place=new Place();
  places.add(place);
  place.setExcludeFromPlaylist(XMLUtil.getBoolean(context,""String_Node_Str"",place.isExcludeFromPlaylist(),xpath));
  place.setLabel(XMLUtil.getText(context,""String_Node_Str"",xpath));
  Double lat=XMLUtil.getDouble(context,""String_Node_Str"",xpath);
  Double lon=XMLUtil.getDouble(context,""String_Node_Str"",xpath);
  LatLon latlon=lat == null || lon == null ? null : LatLon.fromDegrees(lat,lon);
  if (latlon != null) {
    place.setLatLon(latlon);
  }
  place.setMinZoom(XMLUtil.getDouble(context,""String_Node_Str"",place.getMinZoom(),xpath));
  place.setMaxZoom(XMLUtil.getDouble(context,""String_Node_Str"",place.getMinZoom(),xpath));
  place.setSaveCamera(XMLUtil.getBoolean(context,""String_Node_Str"",place.isSaveCamera(),xpath));
  place.setVisible(XMLUtil.getBoolean(context,""String_Node_Str"",place.isVisible(),xpath));
  Double elevation=XMLUtil.getDouble(context,""String_Node_Str"",xpath);
  Double heading=XMLUtil.getDouble(context,""String_Node_Str"",xpath);
  Double pitch=XMLUtil.getDouble(context,""String_Node_Str"",xpath);
  Double zoom=XMLUtil.getDouble(context,""String_Node_Str"",xpath);
  if (zoom != null && latlon != null) {
    if (elevation == null)     elevation=0d;
    if (pitch == null)     pitch=0d;
    if (heading == null)     heading=0d;
    Position center=new Position(latlon,elevation);
    Matrix transform=OrbitViewInputSupport.computeTransformMatrix(globe,center,Angle.fromDegrees(heading),Angle.fromDegrees(pitch),zoom);
    Position eyePosition=null;
    Matrix modelviewInv=transform.getInverse();
    if (modelviewInv != null) {
      Vec4 eyePoint=Vec4.UNIT_W.transformBy4(modelviewInv);
      eyePosition=globe.computePositionFromPoint(eyePoint);
    }
    Vec4 upVector=Vec4.UNIT_Y.transformBy4(transform);
    place.setEyePosition(eyePosition);
    place.setUpVector(upVector);
  }
}","protected static void addPlace(Element context,List<Place> places,XPath xpath,Globe globe){
  Place place=new Place();
  places.add(place);
  place.setExcludeFromPlaylist(XMLUtil.getBoolean(context,""String_Node_Str"",place.isExcludeFromPlaylist(),xpath));
  place.setLabel(XMLUtil.getText(context,""String_Node_Str"",xpath));
  Double lat=XMLUtil.getDouble(context,""String_Node_Str"",xpath);
  Double lon=XMLUtil.getDouble(context,""String_Node_Str"",xpath);
  LatLon latlon=lat == null || lon == null ? null : LatLon.fromDegrees(lat,lon);
  if (latlon != null) {
    place.setLatLon(latlon);
  }
  place.setMinZoom(XMLUtil.getDouble(context,""String_Node_Str"",place.getMinZoom(),xpath));
  place.setMaxZoom(XMLUtil.getDouble(context,""String_Node_Str"",place.getMaxZoom(),xpath));
  place.setSaveCamera(XMLUtil.getBoolean(context,""String_Node_Str"",place.isSaveCamera(),xpath));
  place.setVisible(XMLUtil.getBoolean(context,""String_Node_Str"",place.isVisible(),xpath));
  Double elevation=XMLUtil.getDouble(context,""String_Node_Str"",xpath);
  Double heading=XMLUtil.getDouble(context,""String_Node_Str"",xpath);
  Double pitch=XMLUtil.getDouble(context,""String_Node_Str"",xpath);
  Double zoom=XMLUtil.getDouble(context,""String_Node_Str"",xpath);
  if (zoom != null && latlon != null) {
    if (elevation == null)     elevation=0d;
    if (pitch == null)     pitch=0d;
    if (heading == null)     heading=0d;
    Position center=new Position(latlon,elevation);
    Matrix transform=OrbitViewInputSupport.computeTransformMatrix(globe,center,Angle.fromDegrees(heading),Angle.fromDegrees(pitch),zoom);
    Matrix modelviewInv=transform.getInverse();
    if (modelviewInv != null) {
      Vec4 eyePoint=Vec4.UNIT_W.transformBy4(modelviewInv);
      Vec4 upVector=Vec4.UNIT_Y.transformBy4(modelviewInv);
      Position eyePosition=globe.computePositionFromPoint(eyePoint);
      place.setEyePosition(eyePosition);
      place.setUpVector(upVector);
    }
  }
}",0.9474224160041036
11138,"protected void loadPlaces(File file,boolean append){
  List<Place> places=PlacePersistance.readFromXML(file);
  if (places == null) {
    places=LegacyPlaceReader.readPlacesFromLegacyXML(file,wwd.getModel().getGlobe());
  }
  if (places == null)   places=new ArrayList<Place>();
  if (append)   this.places.addAll(places);
 else   this.places=places;
  populateList();
}","protected void loadPlaces(File file,boolean append){
  List<Place> places=PlacePersistance.readFromXML(file);
  if (places == null && wwd != null) {
    places=LegacyPlaceReader.readPlacesFromLegacyXML(file,wwd.getModel().getGlobe());
  }
  if (places == null)   places=new ArrayList<Place>();
  if (append)   this.places.addAll(places);
 else   this.places=places;
  populateList();
}",0.9801324503311258
11139,"private static String getNameFromDefinition(URL definitionLocation){
  Document definitionDocument=XMLUtil.openDocument(definitionLocation);
  if (definitionDocument == null) {
    return null;
  }
  Element nameElement=XMLUtil.getElement(definitionDocument.getDocumentElement(),""String_Node_Str"",null);
  if (nameElement == null) {
    return null;
  }
  if (nameElement.getFirstChild() == null) {
    return null;
  }
  return nameElement.getFirstChild().getNodeValue();
}","private static String getNameFromDefinition(URL definitionLocation){
  Document definitionDocument=XMLUtil.openDocument(definitionLocation);
  if (definitionDocument == null) {
    return null;
  }
  Element nameElement=XMLUtil.getElement(definitionDocument.getDocumentElement(),""String_Node_Str"",null);
  if (nameElement == null || nameElement.getFirstChild() == null) {
    return null;
  }
  return nameElement.getFirstChild().getNodeValue();
}",0.9619978284473398
11140,"private static String getNameFromDefinition(URL definitionLocation){
  Document definitionDocument=XMLUtil.openDocument(definitionLocation);
  if (definitionDocument == null) {
    return null;
  }
  Element nameElement=XMLUtil.getElement(definitionDocument.getDocumentElement(),""String_Node_Str"",null);
  if (nameElement == null) {
    return null;
  }
  return nameElement.getFirstChild().getNodeValue();
}","private static String getNameFromDefinition(URL definitionLocation){
  Document definitionDocument=XMLUtil.openDocument(definitionLocation);
  if (definitionDocument == null) {
    return null;
  }
  Element nameElement=XMLUtil.getElement(definitionDocument.getDocumentElement(),""String_Node_Str"",null);
  if (nameElement == null || nameElement.getFirstChild() == null) {
    return null;
  }
  return nameElement.getFirstChild().getNodeValue();
}",0.8771929824561403
11141,"private static String getNameFromDefinition(URL definitionLocation){
  Document definitionDocument=XMLUtil.openDocument(definitionLocation);
  if (definitionDocument == null) {
    return null;
  }
  Element nameElement=XMLUtil.getElement(definitionDocument.getDocumentElement(),""String_Node_Str"",null);
  if (nameElement == null) {
    return null;
  }
  return nameElement.getFirstChild().getNodeValue();
}","private static String getNameFromDefinition(URL definitionLocation){
  Document definitionDocument=XMLUtil.openDocument(definitionLocation);
  if (definitionDocument == null) {
    return null;
  }
  Element nameElement=XMLUtil.getElement(definitionDocument.getDocumentElement(),""String_Node_Str"",null);
  if (nameElement == null) {
    return null;
  }
  if (nameElement.getFirstChild() == null) {
    return null;
  }
  return nameElement.getFirstChild().getNodeValue();
}",0.909297052154195
11142,"public static void main(String[] args) throws Exception {
  File input=new File(""String_Node_Str"");
  File output=new File(""String_Node_Str"");
  Dataset dataset=GDALUtil.open(input);
  Insets insets=new Insets(0,0,0,0);
  int tilesize=512;
  String format=""String_Node_Str"";
  int width=dataset.GetRasterXSize() - insets.left - insets.right;
  int height=dataset.GetRasterYSize() - insets.top - insets.bottom;
  int levels=levelCount(width,height,tilesize);
  System.out.println(""String_Node_Str"" + levels);
  int printWidth=width, printHeight=height;
  for (int level=levels - 1; level >= 0; level--) {
    System.out.println(""String_Node_Str"" + level + ""String_Node_Str""+ printWidth+ ""String_Node_Str""+ printHeight);
    printWidth=(printWidth + 1) / 2;
    printHeight=(printHeight + 1) / 2;
  }
  File levelDir=new File(output,String.valueOf(levels - 1));
  int xStrips=Math.max(1,tilesize / width);
  int yStrips=Math.max(1,tilesize / height);
  int rows=(height - 1) / (tilesize * xStrips) + 1;
  int cols=(width - 1) / (tilesize * yStrips) + 1;
  for (int y=0, row=0; y < height; y+=tilesize * xStrips, row++) {
    String rowPadded=Util.paddedInt(row,4);
    File rowDir=new File(levelDir,rowPadded);
    rowDir.mkdirs();
    for (int x=0, col=0; x < width; x+=tilesize * yStrips, col++) {
      int w=Math.min(tilesize * yStrips / xStrips,width - x);
      int h=Math.min(tilesize * xStrips / yStrips,height - y);
      Rectangle src=new Rectangle(x + insets.left,y + insets.top,w,h);
      GDALTileParameters parameters=new GDALTileParameters(dataset,src.getSize(),src);
      GDALTile tile=new GDALTile(parameters);
      BufferedImage image=tile.getAsImage();
      File imageFile=tileFile(levelDir,row,col,format);
      ImageIO.write(image,format,imageFile);
    }
  }
  for (int level=levels - 2; level >= 0; level--) {
    int lastRows=rows;
    int lastCols=cols;
    if (cols == 1) {
      xStrips<<=1;
      rows=(rows + 1) / 2;
    }
    if (rows == 1) {
      yStrips<<=1;
      cols=(cols + 1) / 2;
    }
    rows=(rows + 1) / 2;
    cols=(cols + 1) / 2;
    System.out.println(""String_Node_Str"" + level);
    System.out.println(""String_Node_Str"" + lastRows + ""String_Node_Str""+ lastCols);
    System.out.println(""String_Node_Str"" + rows + ""String_Node_Str""+ cols);
    System.out.println(""String_Node_Str"" + xStrips + ""String_Node_Str""+ yStrips);
    File lastLevelDir=levelDir;
    levelDir=new File(output,String.valueOf(level));
    levelDir.mkdirs();
    int rowMultiplier=lastRows == 1 ? 0 : 1;
    int rowDivisor=lastCols == 1 ? 1 : 2;
    int colMultiplier=lastCols == 1 ? 0 : 1;
    int colDelta=lastRows == 1 ? 2 : 0;
    for (int row=0; row < rows; row++) {
      String rowPadded=Util.paddedInt(row,4);
      File rowDir=new File(levelDir,rowPadded);
      rowDir.mkdirs();
      int firstRow=row * 4;
      int r0=rowMultiplier * (firstRow + 0) / rowDivisor;
      int r1=rowMultiplier * (firstRow + 1) / rowDivisor;
      int r2=rowMultiplier * (firstRow + 2) / rowDivisor;
      int r3=rowMultiplier * (firstRow + 3) / rowDivisor;
      for (int col=0; col < cols; col++) {
        int firstCol=col * (lastRows == 1 ? 4 : 2);
        int c0=colMultiplier * (firstCol);
        int c1=colMultiplier * (firstCol + 1);
        int c2=colMultiplier * (firstCol + colDelta);
        int c3=colMultiplier * (firstCol + colDelta + 1);
        File src0=tileFile(lastLevelDir,r0,c0,format);
        File src1=tileFile(lastLevelDir,r1,c1,format);
        File src2=tileFile(lastLevelDir,r2,c2,format);
        File src3=tileFile(lastLevelDir,r3,c3,format);
        File imageFile=tileFile(levelDir,row,col,format);
        BufferedImage img0=src0.exists() ? ImageIO.read(src0) : null;
        BufferedImage img1=src1.exists() ? ImageIO.read(src1) : null;
        BufferedImage img2=src2.exists() ? ImageIO.read(src2) : null;
        BufferedImage img3=src3.exists() ? ImageIO.read(src3) : null;
        int w0=img0 == null ? 0 : (img0.getWidth() + 1) / 2;
        int w1=img1 == null ? 0 : (img1.getWidth() + 1) / 2;
        int w2=img2 == null ? 0 : (img2.getWidth() + 1) / 2;
        int w3=img3 == null ? 0 : (img3.getWidth() + 1) / 2;
        int h0=img0 == null ? 0 : (img0.getHeight() + 1) / 2;
        int h1=img1 == null ? 0 : (img1.getHeight() + 1) / 2;
        int h2=img2 == null ? 0 : (img2.getHeight() + 1) / 2;
        int h3=img3 == null ? 0 : (img3.getHeight() + 1) / 2;
        int w=w0 + (lastCols == 1 ? 0 : w1) + (lastRows == 1 ? w2 + w3 : 0);
        int h=h0 + (lastRows == 1 ? 0 : h2) + (lastCols == 1 ? h1 + h3 : 0);
        BufferedImage image=new BufferedImage(w,h,BufferedImage.TYPE_INT_RGB);
        Graphics2D g=image.createGraphics();
        g.setRenderingHint(RenderingHints.KEY_INTERPOLATION,RenderingHints.VALUE_INTERPOLATION_BILINEAR);
        int x=0, y=0;
        if (img0 != null) {
          g.drawImage(img0,x,y,w0,h0,null);
        }
        if (img1 != null) {
          x+=lastCols == 1 ? 0 : w0;
          y+=lastCols == 1 ? h0 : 0;
          g.drawImage(img1,x,y,w1,h1,null);
        }
        if (img2 != null) {
          x+=lastCols == 1 ? 0 : lastRows == 1 ? w1 : -w0;
          y+=lastCols == 1 ? h1 : lastRows == 1 ? 0 : h0;
          g.drawImage(img2,x,y,w2,h2,null);
        }
        if (img3 != null) {
          x+=lastCols == 1 ? 0 : w2;
          y+=lastCols == 1 ? h2 : 0;
          g.drawImage(img3,x,y,w3,h3,null);
        }
        g.dispose();
        ImageIO.write(image,format,imageFile);
      }
    }
  }
}","public static void main(String[] args) throws Exception {
  File input=new File(""String_Node_Str"");
  File output=new File(""String_Node_Str"");
  Dataset dataset=GDALUtil.open(input);
  Insets insets=new Insets(408,833,14385 - 14376,38159 - 37443);
  int tilesize=512;
  String format=""String_Node_Str"";
  int width=dataset.GetRasterXSize() - insets.left - insets.right;
  int height=dataset.GetRasterYSize() - insets.top - insets.bottom;
  int levels=levelCount(width,height,tilesize);
  System.out.println(""String_Node_Str"" + levels);
  int printWidth=width, printHeight=height;
  for (int level=levels - 1; level >= 0; level--) {
    System.out.println(""String_Node_Str"" + level + ""String_Node_Str""+ printWidth+ ""String_Node_Str""+ printHeight);
    printWidth=(printWidth + 1) / 2;
    printHeight=(printHeight + 1) / 2;
  }
  File levelDir=new File(output,String.valueOf(levels - 1));
  int xStrips=Math.max(1,tilesize / width);
  int yStrips=Math.max(1,tilesize / height);
  int rows=(height - 1) / (tilesize * xStrips) + 1;
  int cols=(width - 1) / (tilesize * yStrips) + 1;
  for (int y=0, row=0; y < height; y+=tilesize * xStrips, row++) {
    String rowPadded=Util.paddedInt(row,4);
    File rowDir=new File(levelDir,rowPadded);
    rowDir.mkdirs();
    for (int x=0, col=0; x < width; x+=tilesize * yStrips, col++) {
      File imageFile=tileFile(levelDir,row,col,format);
      if (imageFile.exists()) {
        continue;
      }
      int w=Math.min(tilesize * yStrips / xStrips,width - x);
      int h=Math.min(tilesize * xStrips / yStrips,height - y);
      Rectangle src=new Rectangle(x + insets.left,y + insets.top,w,h);
      GDALTileParameters parameters=new GDALTileParameters(dataset,src.getSize(),src);
      GDALTile tile=new GDALTile(parameters);
      BufferedImage image=tile.getAsImage();
      ImageIO.write(image,format,imageFile);
    }
  }
  for (int level=levels - 2; level >= 0; level--) {
    int lastRows=rows;
    int lastCols=cols;
    if (cols == 1) {
      xStrips<<=1;
      rows=(rows + 1) / 2;
    }
    if (rows == 1) {
      yStrips<<=1;
      cols=(cols + 1) / 2;
    }
    rows=(rows + 1) / 2;
    cols=(cols + 1) / 2;
    System.out.println(""String_Node_Str"" + level);
    System.out.println(""String_Node_Str"" + lastRows + ""String_Node_Str""+ lastCols);
    System.out.println(""String_Node_Str"" + rows + ""String_Node_Str""+ cols);
    System.out.println(""String_Node_Str"" + xStrips + ""String_Node_Str""+ yStrips);
    File lastLevelDir=levelDir;
    levelDir=new File(output,String.valueOf(level));
    levelDir.mkdirs();
    int rowMultiplier=lastRows == 1 ? 0 : 1;
    int rowDivisor=lastCols == 1 ? 1 : 2;
    int colMultiplier=lastCols == 1 ? 0 : 1;
    int colDelta=lastRows == 1 ? 2 : 0;
    for (int row=0; row < rows; row++) {
      String rowPadded=Util.paddedInt(row,4);
      File rowDir=new File(levelDir,rowPadded);
      rowDir.mkdirs();
      int firstRow=row * 4;
      int r0=rowMultiplier * (firstRow + 0) / rowDivisor;
      int r1=rowMultiplier * (firstRow + 1) / rowDivisor;
      int r2=rowMultiplier * (firstRow + 2) / rowDivisor;
      int r3=rowMultiplier * (firstRow + 3) / rowDivisor;
      for (int col=0; col < cols; col++) {
        File imageFile=tileFile(levelDir,row,col,format);
        if (imageFile.exists()) {
          continue;
        }
        int firstCol=col * (lastRows == 1 ? 4 : 2);
        int c0=colMultiplier * (firstCol);
        int c1=colMultiplier * (firstCol + 1);
        int c2=colMultiplier * (firstCol + colDelta);
        int c3=colMultiplier * (firstCol + colDelta + 1);
        File src0=tileFile(lastLevelDir,r0,c0,format);
        File src1=tileFile(lastLevelDir,r1,c1,format);
        File src2=tileFile(lastLevelDir,r2,c2,format);
        File src3=tileFile(lastLevelDir,r3,c3,format);
        BufferedImage img0=src0.exists() ? ImageIO.read(src0) : null;
        BufferedImage img1=src1.exists() ? ImageIO.read(src1) : null;
        BufferedImage img2=src2.exists() ? ImageIO.read(src2) : null;
        BufferedImage img3=src3.exists() ? ImageIO.read(src3) : null;
        int w0=img0 == null ? 0 : (img0.getWidth() + 1) / 2;
        int w1=img1 == null ? 0 : (img1.getWidth() + 1) / 2;
        int w2=img2 == null ? 0 : (img2.getWidth() + 1) / 2;
        int w3=img3 == null ? 0 : (img3.getWidth() + 1) / 2;
        int h0=img0 == null ? 0 : (img0.getHeight() + 1) / 2;
        int h1=img1 == null ? 0 : (img1.getHeight() + 1) / 2;
        int h2=img2 == null ? 0 : (img2.getHeight() + 1) / 2;
        int h3=img3 == null ? 0 : (img3.getHeight() + 1) / 2;
        int w=w0 + (lastCols == 1 ? 0 : w1) + (lastRows == 1 ? w2 + w3 : 0);
        int h=h0 + (lastRows == 1 ? 0 : h2) + (lastCols == 1 ? h1 + h3 : 0);
        BufferedImage image=new BufferedImage(w,h,BufferedImage.TYPE_INT_RGB);
        Graphics2D g=image.createGraphics();
        g.setRenderingHint(RenderingHints.KEY_INTERPOLATION,RenderingHints.VALUE_INTERPOLATION_BILINEAR);
        int x=0;
        int y=0;
        if (img0 != null) {
          g.drawImage(img0,x,y,w0,h0,null);
        }
        x+=lastCols == 1 ? 0 : w0;
        y+=lastCols == 1 ? h0 : 0;
        if (img1 != null) {
          g.drawImage(img1,x,y,w1,h1,null);
        }
        x+=lastCols == 1 ? 0 : lastRows == 1 ? w1 : -w0;
        y+=lastCols == 1 ? h1 : lastRows == 1 ? 0 : h0;
        if (img2 != null) {
          g.drawImage(img2,x,y,w2,h2,null);
        }
        x+=lastCols == 1 ? 0 : w2;
        y+=lastCols == 1 ? h2 : 0;
        if (img3 != null) {
          g.drawImage(img3,x,y,w3,h3,null);
        }
        g.dispose();
        ImageIO.write(image,format,imageFile);
      }
    }
  }
}",0.9137374461979914
11143,"@Override public void setTexture(TextureCache tc,Texture texture){
  if (tc == null) {
    String message=Logging.getMessage(""String_Node_Str"");
    Logging.logger().severe(message);
    throw new IllegalStateException(message);
  }
  tc.put(this.getTileKey(),texture);
  this.updateTime=System.currentTimeMillis();
  nullTextureData();
  this.updateMemoryCache();
}","@Override public void setTexture(TextureCache tc,Texture texture){
  if (tc == null) {
    String message=Logging.getMessage(""String_Node_Str"");
    Logging.logger().severe(message);
    throw new IllegalStateException(message);
  }
  tc.put(getTransformedTileKey(),texture);
  this.updateTime=System.currentTimeMillis();
  nullTextureData();
  this.updateMemoryCache();
}",0.9701897018970188
11144,"private void updateMemoryCache(){
  TileKey tileKey=this.getTileKey();
  tileKey=delegate.transformTileKey(tileKey);
  if (getMemoryCache().getObject(tileKey) != null)   getMemoryCache().add(tileKey,this);
}","private void updateMemoryCache(){
  if (getMemoryCache().getObject(getTransformedTileKey()) != null)   getMemoryCache().add(getTransformedTileKey(),this);
}",0.6831955922865014
11145,"@Override public void paint(Graphics g,JComponent c){
{
    super.paint(g,c);
  }
}","@Override public void paint(Graphics g,JComponent c){
  if (relayout || invalidatePath != null) {
    if (invalidatePath == null)     treeState.invalidateSizes();
 else     treeState.invalidatePathBounds(invalidatePath);
    updateSize();
    relayout=false;
    invalidatePath=null;
  }
  super.paint(g,c);
}",0.4030612244897959
11146,"public void relayout(){
synchronized (lock) {
    treeState.invalidateSizes();
    updateSize();
  }
}","public void relayout(){
  relayout=true;
}",0.4444444444444444
11147,"protected RenderInfo(DrawContext dc,int density,DoubleBuffer vertices,Integer verticesBuffer,Vec4 refCenter){
  processIndices(dc,density);
  processTextureCoordinates(dc,density);
  this.density=density;
  this.referenceCenter=refCenter;
  this.vertices=vertices;
  this.bufferIdVertices=verticesBuffer;
  this.indices=indexLists.get(this.density);
  this.bufferIdIndicies=indexBuffers.get(this.density);
  this.texCoords=parameterizations.get(this.density);
  this.bufferIdTexCoords=parameterizationsBuffers.get(this.density);
  this.time=System.currentTimeMillis();
}","public RenderInfo(DrawContext dc,int density,DoubleBuffer vertices,Integer verticesBuffer,Vec4 refCenter){
  processIndices(dc,density);
  processTextureCoordinates(dc,density);
  this.density=density;
  this.referenceCenter=refCenter;
  this.vertices=vertices;
  this.bufferIdVertices=verticesBuffer;
  this.indices=indexLists.get(this.density);
  this.bufferIdIndicies=indexBuffers.get(this.density);
  this.texCoords=parameterizations.get(this.density);
  this.bufferIdTexCoords=parameterizationsBuffers.get(this.density);
  this.time=System.currentTimeMillis();
}",0.988566402814424
11148,"public static void main(String[] args){
  Settings.get();
  if (Settings.isNewSettings()) {
    try {
      String hostname=InetAddress.getLocalHost().getCanonicalHostName();
      if (hostname.endsWith(""String_Node_Str"")) {
        Settings.get().setProxyHost(""String_Node_Str"");
        Settings.get().setProxyPort(8080);
        Settings.get().setProxyType(ProxyType.HTTP);
        Settings.get().setProxyEnabled(true);
      }
    }
 catch (    Throwable t) {
    }
  }
  int argsLength=args.length;
  String lastArg=argsLength > 0 ? args[argsLength - 1].toLowerCase().trim() : null;
  boolean sandpit=""String_Node_Str"".equals(lastArg) || ""String_Node_Str"".equals(lastArg);
  GASandpit.setSandpitMode(sandpit);
  if (sandpit)   argsLength--;
  URL themeUrl=null;
  if (argsLength > 0) {
    try {
      themeUrl=new URL(args[0]);
    }
 catch (    MalformedURLException e) {
    }
  }
  if (themeUrl == null) {
    File file=new File(""String_Node_Str"");
    if (file.exists()) {
      try {
        themeUrl=file.toURI().toURL();
      }
 catch (      MalformedURLException e) {
      }
    }
  }
  ThemeOpenDelegate delegate=new ThemeOpenDelegate(){
    @Override public void opened(    Theme theme){
      start(theme);
    }
  }
;
  if (themeUrl == null)   ThemeOpener.openDefault(delegate);
 else   ThemeOpener.openTheme(themeUrl,delegate);
}","public static void main(String[] args){
  int argsLength=args.length;
  String lastArg=argsLength > 0 ? args[argsLength - 1].toLowerCase().trim() : null;
  boolean sandpit=""String_Node_Str"".equals(lastArg) || ""String_Node_Str"".equals(lastArg);
  GASandpit.setSandpitMode(sandpit);
  if (sandpit)   argsLength--;
  Settings.init();
  if (Settings.isNewSettings()) {
    try {
      String hostname=InetAddress.getLocalHost().getCanonicalHostName();
      if (hostname.endsWith(""String_Node_Str"")) {
        Settings.get().setProxyHost(""String_Node_Str"");
        Settings.get().setProxyPort(8080);
        Settings.get().setProxyType(ProxyType.HTTP);
        Settings.get().setProxyEnabled(true);
      }
    }
 catch (    Throwable t) {
    }
  }
  URL themeUrl=null;
  if (argsLength > 0) {
    try {
      themeUrl=new URL(args[0]);
    }
 catch (    MalformedURLException e) {
    }
  }
  if (themeUrl == null) {
    File file=new File(""String_Node_Str"");
    if (file.exists()) {
      try {
        themeUrl=file.toURI().toURL();
      }
 catch (      MalformedURLException e) {
      }
    }
  }
  ThemeOpenDelegate delegate=new ThemeOpenDelegate(){
    @Override public void opened(    Theme theme){
      start(theme);
    }
  }
;
  if (themeUrl == null)   ThemeOpener.openDefault(delegate);
 else   ThemeOpener.openTheme(themeUrl,delegate);
}",0.7900777489818586
11149,"public Settings(){
  init();
}","public Settings(){
  updateProxyConfiguration();
  setVerticalExaggeration(getVerticalExaggeration());
}",0.417910447761194
11150,"private void init(){
  updateProxyConfiguration();
  setVerticalExaggeration(getVerticalExaggeration());
}","public static void init(){
  instance=SettingsPersistance.load(getSettingsFile());
  if (instance == null) {
    instance=new Settings();
    newSettings=true;
  }
}",0.3025830258302583
11151,"public static Settings get(){
  return instance;
}","public static Settings get(){
  if (instance == null) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  return instance;
}",0.5376344086021505
11152,"private Thread animate(final double detailHint,final int firstFrame,final int lastFrame,final File outputDir,final boolean alpha){
  if (animation != null && animation.size() > 0) {
    Thread thread=new Thread(new Runnable(){
      public void run(){
        stop=false;
        boolean immediate=ImmediateMode.isImmediate();
        ImmediateMode.setImmediate(true);
        AnimatorSceneController asc=(AnimatorSceneController)wwd.getSceneController();
        setAnimationSize(animation.getWidth(),animation.getHeight());
        crosshair.setEnabled(false);
        double detailHintBackup=ocem.getDetailHint();
        ocem.setDetailHint(detailHint);
        frame.setAlwaysOnTop(true);
        View view=wwd.getView();
        OrbitView orbitView=(OrbitView)view;
        boolean detectCollisions=orbitView.isDetectCollisions();
        orbitView.setDetectCollisions(false);
        int filenameLength=String.valueOf(lastFrame).length();
        for (int frame=firstFrame; frame <= lastFrame; frame+=1) {
          setSlider(frame);
          applyView(getView());
          asc.takeScreenshot(new File(outputDir,""String_Node_Str"" + FileUtil.paddedInt(frame,filenameLength) + ""String_Node_Str""),alpha);
          wwd.redraw();
          asc.waitForScreenshot();
          if (stop)           break;
        }
        ocem.setDetailHint(detailHintBackup);
        crosshair.setEnabled(true);
        orbitView.setDetectCollisions(detectCollisions);
        frame.setAlwaysOnTop(false);
        ImmediateMode.setImmediate(immediate);
      }
    }
);
    thread.start();
    return thread;
  }
  return null;
}","private Thread animate(final double detailHint,final int firstFrame,final int lastFrame,final File outputDir,final boolean alpha){
  if (animation != null && animation.size() > 0) {
    Thread thread=new Thread(new Runnable(){
      public void run(){
        stop=false;
        boolean immediate=ImmediateMode.isImmediate();
        ImmediateMode.setImmediate(true);
        AnimatorSceneController asc=(AnimatorSceneController)wwd.getSceneController();
        setAnimationSize(animation.getWidth(),animation.getHeight());
        crosshair.setEnabled(false);
        double detailHintBackup=dem.getDetailHint();
        dem.setDetailHint(detailHint);
        frame.setAlwaysOnTop(true);
        View view=wwd.getView();
        OrbitView orbitView=(OrbitView)view;
        boolean detectCollisions=orbitView.isDetectCollisions();
        orbitView.setDetectCollisions(false);
        int filenameLength=String.valueOf(lastFrame).length();
        for (int frame=firstFrame; frame <= lastFrame; frame+=1) {
          setSlider(frame);
          applyView(getView());
          asc.takeScreenshot(new File(outputDir,""String_Node_Str"" + FileUtil.paddedInt(frame,filenameLength) + ""String_Node_Str""),alpha);
          wwd.redraw();
          asc.waitForScreenshot();
          if (stop)           break;
        }
        dem.setDetailHint(detailHintBackup);
        crosshair.setEnabled(true);
        orbitView.setDetectCollisions(detectCollisions);
        frame.setAlwaysOnTop(false);
        ImmediateMode.setImmediate(immediate);
      }
    }
);
    thread.start();
    return thread;
  }
  return null;
}",0.9972110319181904
11153,"public Animator(){
  Configuration.setValue(AVKey.LAYERS_CLASS_NAMES,""String_Node_Str"");
  Configuration.setValue(AVKey.VIEW_CLASS_NAME,BasicRollOrbitView.class.getName());
  Configuration.setValue(AVKey.SCENE_CONTROLLER_CLASS_NAME,AnimatorSceneController.class.getName());
  Configuration.setValue(AVKey.TASK_SERVICE_CLASS_NAME,ImmediateTaskService.class.getName());
  Configuration.setValue(AVKey.RETRIEVAL_SERVICE_CLASS_NAME,ImmediateRetrievalService.class.getName());
  Configuration.setValue(AVKey.TESSELLATOR_CLASS_NAME,ElevationTesselator.class.getName());
  Configuration.setValue(AVKey.AIRSPACE_GEOMETRY_CACHE_SIZE,16777216L * 8);
  animationChangeListener=new ChangeListener(){
    public void stateChanged(    ChangeEvent e){
      changed=true;
      setTitleBar();
    }
  }
;
  animation=new Animation();
  resetChanged();
  updater=new Updater();
  frame=new JFrame();
  frame.setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE);
  frame.addWindowListener(new WindowAdapter(){
    @Override public void windowClosing(    WindowEvent e){
      quit();
    }
  }
);
  frame.setLayout(new BorderLayout());
  wwd=new WorldWindowGLCanvas(caps);
  Model model=new BasicModel();
  wwd.setModel(model);
  setAnimationSize(1024,576);
  frame.add(wwd,BorderLayout.CENTER);
  ((AWTInputHandler)wwd.getInputHandler()).setSmoothViewChanges(false);
  ((OrbitView)wwd.getView()).getOrbitViewLimits().setPitchLimits(Angle.ZERO,Angle.POS180);
  ocem=new DetailedCompoundElevationModel();
  model.getGlobe().setElevationModel(ocem);
  wwd.getSceneController().setVerticalExaggeration(10);
  LayerList layers=model.getLayers();
  StarsLayer stars=new StarsLayer();
  layers.add(stars);
  SkyGradientLayer sky=new SkyGradientLayer();
  layers.add(sky);
  Layer depth=new DepthLayer();
  layers.add(depth);
  bmng=new ImmediateBMNGWMSLayer();
  layers.add(bmng);
  landsat=new ImmediateLandsatI3WMSLayer();
  layers.add(landsat);
  ElevationModel earthem=(ElevationModel)new ExtendedBasicElevationModelFactory().createFromConfigSource(""String_Node_Str"",null);
  ExtendedElevationModel eem=getEBEM(earthem);
  Sector bemSector=Sector.fromDegrees(-59.99875,-7.99875,91.99875,171.99875);
  ExtendedBasicElevationModel bem=FileLayer.createElevationModel(""String_Node_Str"",""String_Node_Str"",new File(DATA_DRIVE + ""String_Node_Str""),7,150,LatLon.fromDegrees(20d,20d),bemSector,-8922,3958,AVKey.INT16);
  bem.setMissingDataSignal(-32768);
  Sector semSector=Sector.fromDegrees(-27.0015,-22.5005,106.5005,110.5025);
  ExtendedBasicElevationModel sem=FileLayer.createElevationModel(""String_Node_Str"",""String_Node_Str"",new File(DATA_DRIVE + ""String_Node_Str""),7,150,LatLon.fromDegrees(20d,20d),semSector,-6400,-2310,AVKey.INT16);
  sem.setMissingDataSignal(-9999);
  ocem.addElevationModel(eem);
  ocem.addElevationModel(bem);
  sunPosition=new Vec4(7649434.404798721,4779897.118999491,-9020047.848073645,0.0);
  elevationEarth=new ShadedElevationLayer(eem);
  elevationEarth.setSunPosition(sunPosition);
  elevationEarth.setExaggeration(50);
  elevationEarth.setMaxElevationClamp(0);
  elevationEarth.setMinElevationClamp(bem.getMinElevation());
  layers.add(elevationEarth);
  Sector belevSector=new Sector(bemSector.getMinLatitude().addDegrees(1),bemSector.getMaxLatitude().addDegrees(-1),bemSector.getMinLongitude().addDegrees(1),bemSector.getMaxLongitude().addDegrees(-1));
  elevationSW=new ShadedElevationLayer(bem,belevSector);
  elevationSW.setSunPosition(sunPosition);
  elevationSW.setExaggeration(50);
  elevationSW.setSplitScale(1.65);
  elevationSW.setMaxElevationClamp(0);
  elevationSW.setMinElevationClamp(bem.getMinElevation());
  layers.add(elevationSW);
  Sector selevSector=new Sector(semSector.getMinLatitude(),semSector.getMaxLatitude(),semSector.getMinLongitude().addDegrees(0.1),semSector.getMaxLongitude());
  elevationSONNE=new ShadedElevationLayer(sem,selevSector);
  elevationSONNE.setSunPosition(sunPosition);
  elevationSONNE.setExaggeration(50);
  elevationSONNE.setSplitScale(1.65);
  elevationSONNE.setMaxElevationClamp(0);
  elevationSONNE.setMinElevationClamp(bem.getMinElevation());
  elevationSONNE.setShaderMaxElevation(bem.getMaxElevation());
  elevationSONNE.setShaderMinElevation(bem.getMinElevation());
  layers.add(elevationSONNE);
  shadowsEarth=new ShadowsElevationLayer(eem);
  shadowsEarth.setSunPosition(sunPosition);
  shadowsEarth.setOpacity(0.5);
  layers.add(shadowsEarth);
  shadowsSW=new ShadowsElevationLayer(bem,belevSector);
  shadowsSW.setSunPosition(sunPosition);
  shadowsSW.setOpacity(0.5);
  shadowsSW.setSplitScale(1.3);
  layers.add(shadowsSW);
  Layer gravity=new GravityLayer();
  layers.add(gravity);
  Layer magnetics=new MagneticsLayer();
  layers.add(magnetics);
  MetacartaStateBoundariesLayer state=new MetacartaStateBoundariesLayer();
  state.setSplitScale(1.2);
  layers.add(state);
  MetacartaCoastlineLayer coast=new MetacartaCoastlineLayer();
  coast.setSplitScale(1.2);
  layers.add(coast);
  for (  Layer layer : layers) {
    layer.setEnabled(false);
  }
  stars.setEnabled(true);
  sky.setEnabled(true);
  depth.setEnabled(true);
  bmng.setEnabled(true);
  elevationEarth.setEnabled(true);
  elevationSW.setEnabled(true);
  elevationSONNE.setEnabled(true);
  crosshair=new CrosshairLayer();
  layers.add(crosshair);
  JPanel bottom=new JPanel(new BorderLayout());
  frame.add(bottom,BorderLayout.SOUTH);
  slider=new FrameSlider(0,0,animation.getFrameCount());
  slider.setMinimumSize(new Dimension(0,54));
  bottom.add(slider,BorderLayout.CENTER);
  slider.addChangeListener(new ChangeListener(){
    public void stateChanged(    ChangeEvent e){
      if (!settingSlider) {
        if (animation.size() > 0) {
          applyView(getView());
          wwd.redraw();
        }
        stop=true;
      }
    }
  }
);
  slider.addChangeFrameListener(new ChangeFrameListener(){
    public void frameChanged(    int index,    int oldFrame,    int newFrame){
      animation.setFrame(index,newFrame);
      updateSlider();
      applyView(getView());
      wwd.redraw();
    }
  }
);
  getView().addPropertyChangeListener(AVKey.VIEW,new PropertyChangeListener(){
    public void propertyChange(    PropertyChangeEvent evt){
      if (autokey && !applying) {
        addFrame();
      }
    }
  }
);
  StatusBar statusBar=new StatusBar();
  statusBar.setBorder(BorderFactory.createLoweredBevelBorder());
  bottom.add(statusBar,BorderLayout.SOUTH);
  statusBar.setEventSource(wwd);
  ToolTipManager.sharedInstance().setLightWeightPopupEnabled(false);
  JPopupMenu.setDefaultLightWeightPopupEnabled(false);
  createMenuBar();
  setTitleBar();
  updateSlider();
  frame.pack();
  frame.setVisible(true);
}","public Animator(){
  Configuration.setValue(AVKey.LAYERS_CLASS_NAMES,""String_Node_Str"");
  Configuration.setValue(AVKey.VIEW_CLASS_NAME,BasicRollOrbitView.class.getName());
  Configuration.setValue(AVKey.SCENE_CONTROLLER_CLASS_NAME,AnimatorSceneController.class.getName());
  Configuration.setValue(AVKey.TASK_SERVICE_CLASS_NAME,ImmediateTaskService.class.getName());
  Configuration.setValue(AVKey.RETRIEVAL_SERVICE_CLASS_NAME,ImmediateRetrievalService.class.getName());
  Configuration.setValue(AVKey.TESSELLATOR_CLASS_NAME,ElevationTesselator.class.getName());
  Configuration.setValue(AVKey.AIRSPACE_GEOMETRY_CACHE_SIZE,16777216L * 8);
  animationChangeListener=new ChangeListener(){
    public void stateChanged(    ChangeEvent e){
      changed=true;
      setTitleBar();
    }
  }
;
  animation=new Animation();
  resetChanged();
  updater=new Updater();
  frame=new JFrame();
  frame.setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE);
  frame.addWindowListener(new WindowAdapter(){
    @Override public void windowClosing(    WindowEvent e){
      quit();
    }
  }
);
  frame.setLayout(new BorderLayout());
  wwd=new WorldWindowGLCanvas(caps);
  Model model=new BasicModel();
  wwd.setModel(model);
  setAnimationSize(1024,576);
  frame.add(wwd,BorderLayout.CENTER);
  ((AWTInputHandler)wwd.getInputHandler()).setSmoothViewChanges(false);
  ((OrbitView)wwd.getView()).getOrbitViewLimits().setPitchLimits(Angle.ZERO,Angle.POS180);
  CompoundElevationModel cem=new CompoundElevationModel();
  dem=new DetailedElevationModel(cem);
  model.getGlobe().setElevationModel(dem);
  wwd.getSceneController().setVerticalExaggeration(10);
  LayerList layers=model.getLayers();
  StarsLayer stars=new StarsLayer();
  layers.add(stars);
  SkyGradientLayer sky=new SkyGradientLayer();
  layers.add(sky);
  Layer depth=new DepthLayer();
  layers.add(depth);
  bmng=new ImmediateBMNGWMSLayer();
  layers.add(bmng);
  landsat=new ImmediateLandsatI3WMSLayer();
  layers.add(landsat);
  ElevationModel earthem=(ElevationModel)new ExtendedBasicElevationModelFactory().createFromConfigSource(""String_Node_Str"",null);
  ExtendedElevationModel eem=getEBEM(earthem);
  Sector bemSector=Sector.fromDegrees(-59.99875,-7.99875,91.99875,171.99875);
  ExtendedBasicElevationModel bem=FileLayer.createElevationModel(""String_Node_Str"",""String_Node_Str"",new File(DATA_DRIVE + ""String_Node_Str""),7,150,LatLon.fromDegrees(20d,20d),bemSector,-8922,3958,AVKey.INT16);
  bem.setMissingDataSignal(-32768);
  Sector semSector=Sector.fromDegrees(-27.0015,-22.5005,106.5005,110.5025);
  ExtendedBasicElevationModel sem=FileLayer.createElevationModel(""String_Node_Str"",""String_Node_Str"",new File(DATA_DRIVE + ""String_Node_Str""),7,150,LatLon.fromDegrees(20d,20d),semSector,-6400,-2310,AVKey.INT16);
  sem.setMissingDataSignal(-9999);
  cem.addElevationModel(eem);
  cem.addElevationModel(bem);
  sunPosition=new Vec4(7649434.404798721,4779897.118999491,-9020047.848073645,0.0);
  elevationEarth=new ShadedElevationLayer(eem);
  elevationEarth.setSunPosition(sunPosition);
  elevationEarth.setExaggeration(50);
  elevationEarth.setMaxElevationClamp(0);
  elevationEarth.setMinElevationClamp(bem.getMinElevation());
  layers.add(elevationEarth);
  Sector belevSector=new Sector(bemSector.getMinLatitude().addDegrees(1),bemSector.getMaxLatitude().addDegrees(-1),bemSector.getMinLongitude().addDegrees(1),bemSector.getMaxLongitude().addDegrees(-1));
  elevationSW=new ShadedElevationLayer(bem,belevSector);
  elevationSW.setSunPosition(sunPosition);
  elevationSW.setExaggeration(50);
  elevationSW.setSplitScale(1.65);
  elevationSW.setMaxElevationClamp(0);
  elevationSW.setMinElevationClamp(bem.getMinElevation());
  layers.add(elevationSW);
  Sector selevSector=new Sector(semSector.getMinLatitude(),semSector.getMaxLatitude(),semSector.getMinLongitude().addDegrees(0.1),semSector.getMaxLongitude());
  elevationSONNE=new ShadedElevationLayer(sem,selevSector);
  elevationSONNE.setSunPosition(sunPosition);
  elevationSONNE.setExaggeration(50);
  elevationSONNE.setSplitScale(1.65);
  elevationSONNE.setMaxElevationClamp(0);
  elevationSONNE.setMinElevationClamp(bem.getMinElevation());
  elevationSONNE.setShaderMaxElevation(bem.getMaxElevation());
  elevationSONNE.setShaderMinElevation(bem.getMinElevation());
  layers.add(elevationSONNE);
  shadowsEarth=new ShadowsElevationLayer(eem);
  shadowsEarth.setSunPosition(sunPosition);
  shadowsEarth.setOpacity(0.5);
  layers.add(shadowsEarth);
  shadowsSW=new ShadowsElevationLayer(bem,belevSector);
  shadowsSW.setSunPosition(sunPosition);
  shadowsSW.setOpacity(0.5);
  shadowsSW.setSplitScale(1.3);
  layers.add(shadowsSW);
  Layer gravity=new GravityLayer();
  layers.add(gravity);
  Layer magnetics=new MagneticsLayer();
  layers.add(magnetics);
  MetacartaStateBoundariesLayer state=new MetacartaStateBoundariesLayer();
  state.setSplitScale(1.2);
  layers.add(state);
  MetacartaCoastlineLayer coast=new MetacartaCoastlineLayer();
  coast.setSplitScale(1.2);
  layers.add(coast);
  for (  Layer layer : layers) {
    layer.setEnabled(false);
  }
  stars.setEnabled(true);
  sky.setEnabled(true);
  depth.setEnabled(true);
  bmng.setEnabled(true);
  elevationEarth.setEnabled(true);
  elevationSW.setEnabled(true);
  elevationSONNE.setEnabled(true);
  crosshair=new CrosshairLayer();
  layers.add(crosshair);
  JPanel bottom=new JPanel(new BorderLayout());
  frame.add(bottom,BorderLayout.SOUTH);
  slider=new FrameSlider(0,0,animation.getFrameCount());
  slider.setMinimumSize(new Dimension(0,54));
  bottom.add(slider,BorderLayout.CENTER);
  slider.addChangeListener(new ChangeListener(){
    public void stateChanged(    ChangeEvent e){
      if (!settingSlider) {
        if (animation.size() > 0) {
          applyView(getView());
          wwd.redraw();
        }
        stop=true;
      }
    }
  }
);
  slider.addChangeFrameListener(new ChangeFrameListener(){
    public void frameChanged(    int index,    int oldFrame,    int newFrame){
      animation.setFrame(index,newFrame);
      updateSlider();
      applyView(getView());
      wwd.redraw();
    }
  }
);
  getView().addPropertyChangeListener(AVKey.VIEW,new PropertyChangeListener(){
    public void propertyChange(    PropertyChangeEvent evt){
      if (autokey && !applying) {
        addFrame();
      }
    }
  }
);
  StatusBar statusBar=new StatusBar();
  statusBar.setBorder(BorderFactory.createLoweredBevelBorder());
  bottom.add(statusBar,BorderLayout.SOUTH);
  statusBar.setEventSource(wwd);
  ToolTipManager.sharedInstance().setLightWeightPopupEnabled(false);
  JPopupMenu.setDefaultLightWeightPopupEnabled(false);
  createMenuBar();
  setTitleBar();
  updateSlider();
  frame.pack();
  frame.setVisible(true);
}",0.9943190312453282
11154,"public static AVList getExpirationParams(Element domElement,AVList params){
  if (params == null)   params=new AVListImpl();
  XPath xpath=WWXML.makeXPath();
  WWXML.checkAndSetLongParam(domElement,params,AVKeyMore.EXPIRY_START_TIME,""String_Node_Str"",xpath);
  WWXML.checkAndSetDateTimeParam(domElement,params,AVKeyMore.EXPIRY_START_TIME,""String_Node_Str"",DATE_TIME_PATTERN,xpath);
  WWXML.checkAndSetTimeParamAsInteger(domElement,params,AVKeyMore.EXPIRY_TIMESPAN,""String_Node_Str"",xpath);
  return params;
}","public static AVList getExpirationParams(Element domElement,AVList params){
  if (params == null)   params=new AVListImpl();
  XPath xpath=WWXML.makeXPath();
  WWXML.checkAndSetLongParam(domElement,params,AVKeyMore.EXPIRY_START_TIME,""String_Node_Str"",xpath);
  WWXML.checkAndSetDateTimeParam(domElement,params,AVKeyMore.EXPIRY_START_TIME,""String_Node_Str"",DATE_TIME_PATTERN,xpath);
  WWXML.checkAndSetTimeParam(domElement,params,AVKeyMore.EXPIRY_TIMESPAN,""String_Node_Str"",xpath);
  return params;
}",0.887785501489573
11155,"private void replaceValues(ByteBuffer buffer,Dimension bufferSize,Rectangle replaceRegion,int bufferBandCount,int bufferType,int bufferTypeSize,boolean floatingPoint,MinMaxArray[] minMaxs,NullableNumberArray replacement,NullableNumberArray otherwise) throws TilerException {
  if (minMaxs == null || minMaxs.length == 0)   return;
  if (replacement == null && otherwise == null)   return;
  for (int i=0; i < minMaxs.length; i++)   if (minMaxs[i].length() != bufferBandCount)   throw new IllegalArgumentException(""String_Node_Str"");
  if ((replacement != null && replacement.length() != bufferBandCount) || (otherwise != null && otherwise.length() != bufferBandCount))   throw new IllegalArgumentException(""String_Node_Str"");
  boolean allNull=true;
  for (int b=0; b < bufferBandCount; b++) {
    if ((replacement != null && replacement.getDouble(b) != null) || (otherwise != null && otherwise.getDouble(b) != null)) {
      allNull=false;
      break;
    }
  }
  if (allNull) {
    return;
  }
  double[] doubleValues=new double[bufferBandCount];
  long[] longValues=new long[bufferBandCount];
  int[] indices=new int[bufferBandCount];
  for (int y=replaceRegion.y; y < replaceRegion.height; y++) {
    for (int x=replaceRegion.x; x < replaceRegion.width; x++) {
      boolean between=false;
      for (int b=0; b < bufferBandCount; b++) {
        indices[b]=getBufferIndex(x,y,b,bufferSize.width,bufferSize.height) * bufferTypeSize;
        if (floatingPoint)         doubleValues[b]=getDoubleValue(indices[b],buffer,bufferType);
 else         longValues[b]=getLongValue(indices[b],buffer,bufferType);
      }
      for (int i=0; i < minMaxs.length; i++) {
        if (minMaxs[i] != null) {
          if (floatingPoint)           between=minMaxs[i].isBetweenDouble(doubleValues);
 else           between=minMaxs[i].isBetweenLong(longValues);
          if (between)           break;
        }
      }
      NullableNumberArray values=between ? replacement : otherwise;
      if (values != null) {
        for (int b=0; b < bufferBandCount; b++) {
          if (values.getDouble(b) != null) {
            if (floatingPoint)             putDoubleValue(indices[b],buffer,bufferType,values.getDouble(b));
 else             putLongValue(indices[b],buffer,bufferType,values.getLong(b));
          }
        }
      }
    }
  }
}","private void replaceValues(ByteBuffer buffer,Dimension bufferSize,Rectangle replaceRegion,int bufferBandCount,int bufferType,int bufferTypeSize,boolean floatingPoint,MinMaxArray[] minMaxs,NullableNumberArray replacement,NullableNumberArray otherwise) throws TilerException {
  if (minMaxs == null || minMaxs.length == 0)   return;
  if (replacement == null && otherwise == null)   return;
  for (int i=0; i < minMaxs.length; i++)   if (minMaxs[i].length() != bufferBandCount)   throw new IllegalArgumentException(""String_Node_Str"");
  if ((replacement != null && replacement.length() != bufferBandCount) || (otherwise != null && otherwise.length() != bufferBandCount))   throw new IllegalArgumentException(""String_Node_Str"");
  boolean allNull=true;
  for (int b=0; b < bufferBandCount; b++) {
    if ((replacement != null && replacement.getDouble(b) != null) || (otherwise != null && otherwise.getDouble(b) != null)) {
      allNull=false;
      break;
    }
  }
  if (allNull) {
    return;
  }
  double[] doubleValues=new double[bufferBandCount];
  long[] longValues=new long[bufferBandCount];
  int[] indices=new int[bufferBandCount];
  for (int y=replaceRegion.y; y < replaceRegion.y + replaceRegion.height; y++) {
    for (int x=replaceRegion.x; x < replaceRegion.x + replaceRegion.width; x++) {
      boolean between=false;
      for (int b=0; b < bufferBandCount; b++) {
        indices[b]=getBufferIndex(x,y,b,bufferSize.width,bufferSize.height) * bufferTypeSize;
        if (floatingPoint)         doubleValues[b]=getDoubleValue(indices[b],buffer,bufferType);
 else         longValues[b]=getLongValue(indices[b],buffer,bufferType);
      }
      for (int i=0; i < minMaxs.length; i++) {
        if (minMaxs[i] != null) {
          if (floatingPoint)           between=minMaxs[i].isBetweenDouble(doubleValues);
 else           between=minMaxs[i].isBetweenLong(longValues);
          if (between)           break;
        }
      }
      NullableNumberArray values=between ? replacement : otherwise;
      if (values != null) {
        for (int b=0; b < bufferBandCount; b++) {
          if (values.getDouble(b) != null) {
            if (floatingPoint)             putDoubleValue(indices[b],buffer,bufferType,values.getDouble(b));
 else             putLongValue(indices[b],buffer,bufferType,values.getLong(b));
          }
        }
      }
    }
  }
}",0.9923175416133164
11156,"private void saveDDS(BufferedImage image,File file) throws IOException {
  ByteBuffer buffer;
  if (image.getColorModel().hasAlpha())   buffer=DDSConverter.convertToDxt3(image);
 else   buffer=DDSConverter.convertToDxt1NoTransparency(image);
synchronized (this.getFileLock()) {
    WWIO.saveBuffer(buffer,file);
  }
}","private void saveDDS(BufferedImage image,File file) throws IOException {
  ByteBuffer buffer=DDSCompressor.compressImage(image);
synchronized (this.getFileLock()) {
    WWIO.saveBuffer(buffer,file);
  }
}",0.7140115163147792
11157,"private void openDataset(File file){
  fileOpen=file != null;
  if (!fileOpen) {
    infoText.setText(""String_Node_Str"");
    gdalFileField.setText(""String_Node_Str"");
    mapnikFileField.setText(""String_Node_Str"");
    previewCanvas.setIcon(null);
    bandCount=0;
    dataset=null;
    sector=null;
    mapFile=null;
  }
 else {
    try {
      gdalFileField.setText(file.getAbsolutePath());
      mapnikFileField.setText(file.getAbsolutePath());
      this.mapFile=file;
      if (gdalRadio.isSelected()) {
        final Dataset dataset=GDALUtil.open(file);
        final Sector sector=GDALUtil.getSector(dataset);
        this.sector=sector;
        this.dataset=dataset;
        final int width=dataset.getRasterXSize();
        final int height=dataset.getRasterYSize();
        if (sector.getMinLongitude() == 0 && sector.getMinLatitude() == 0 && sector.getMaxLongitude() == width && sector.getMaxLatitude() == height) {
          throw new TilerException(""String_Node_Str"" + file + ""String_Node_Str"");
        }
        if (sector.getMinLatitude() < -90 || sector.getMaxLatitude() > 90 || sector.getMinLongitude() < -180 || sector.getMaxLongitude() > 180) {
          throw new TilerException(""String_Node_Str"" + sector + ""String_Node_Str"");
        }
        bandCount=dataset.getRasterCount();
        if (bandCount == 0) {
          throw new TilerException(""String_Node_Str"");
        }
        String projection=dataset.GetProjection();
        SpatialReference spatialReference=(projection == null || projection.length() == 0 || !GDALUtil.isProjectionsSupported()) ? null : new SpatialReference(projection);
        String[] dataTypes=new String[bandCount];
        int[] dataTypeSizes=new int[bandCount];
        Double[] nodata=new Double[bandCount];
        double[] min=new double[bandCount];
        double[] max=new double[bandCount];
        for (int i=0; i < bandCount; i++) {
          Band band=dataset.GetRasterBand(i + 1);
          int dataType=band.getDataType();
          dataTypes[i]=gdal.GetDataTypeName(dataType);
          dataTypeSizes[i]=gdal.GetDataTypeSize(dataType);
          Double[] nodataValue=new Double[1];
          band.GetNoDataValue(nodataValue);
          nodata[i]=nodataValue[0];
          double[] minmax=new double[2];
          band.ComputeRasterMinMax(minmax,1);
          min[i]=minmax[0];
          max[i]=minmax[1];
        }
        StringLineBuilder info=new StringLineBuilder();
        info.appendLine(""String_Node_Str"");
        info.appendLine(""String_Node_Str"" + width + ""String_Node_Str""+ height);
        info.appendLine(""String_Node_Str"" + (sector.getDeltaLongitude() / width) + ""String_Node_Str""+ (sector.getDeltaLatitude() / height));
        info.appendLine(""String_Node_Str"" + sector.getMinLongitude() + ""String_Node_Str""+ sector.getMinLatitude()+ ""String_Node_Str"");
        info.appendLine(""String_Node_Str"" + sector.getMaxLongitude() + ""String_Node_Str""+ sector.getMaxLatitude()+ ""String_Node_Str"");
        info.appendLine(""String_Node_Str"" + bandCount);
        for (int i=0; i < bandCount; i++) {
          info.appendLine(""String_Node_Str"" + (i + 1) + ""String_Node_Str"");
          info.appendLine(""String_Node_Str"" + dataTypes[i] + ""String_Node_Str""+ dataTypeSizes[i]+ ""String_Node_Str"");
          info.appendLine(""String_Node_Str"" + nodata[i]);
          info.appendLine(""String_Node_Str"" + min[i]);
          info.appendLine(""String_Node_Str"" + max[i]);
        }
        if (spatialReference != null) {
          info.appendLine(""String_Node_Str"");
          info.appendLine(Util.fixNewlines(spatialReference.ExportToPrettyWkt()));
        }
        String text=info.toString(true);
        infoText.setText(text);
        infoText.select(0,0);
        Thread thread=new Thread(new Runnable(){
          public void run(){
            logger.fine(""String_Node_Str"");
            try {
              int w=400;
              int h=w;
              if (width > height) {
                h=w * height / width;
              }
 else {
                w=h * width / height;
              }
              GDALTile tile=new GDALTile(dataset,w,h,sector.getMinLatitude(),sector.getMinLongitude(),sector.getMaxLatitude(),sector.getMaxLongitude());
              tile=tile.convertToType(gdalconst.GDT_Byte);
              BufferedImage image=tile.getAsImage();
              ImageIcon icon=new ImageIcon(image);
              previewCanvas.setIcon(icon);
              logger.fine(""String_Node_Str"");
            }
 catch (            Exception e) {
              logger.warning(e.getMessage());
            }
          }
        }
);
        thread.setDaemon(true);
        thread.start();
      }
 else {
        infoText.setText(""String_Node_Str"");
        this.bandCount=0;
        Sector sect=MapnikUtil.getSector(mapFile);
        if (sect == null) {
          sect=Sector.FULL_SPHERE;
          logger.warning(""String_Node_Str"");
        }
        this.sector=sect;
        minLatitudeField.setValue(sect.getMinLatitude());
        minLongitudeField.setValue(sect.getMinLongitude());
        maxLatitudeField.setValue(sect.getMaxLatitude());
        maxLongitudeField.setValue(sect.getMaxLongitude());
        Thread thread=new Thread(new Runnable(){
          public void run(){
            logger.fine(""String_Node_Str"");
            try {
              File dst=File.createTempFile(""String_Node_Str"",""String_Node_Str"");
              dst.deleteOnExit();
              MapnikUtil.tile(sector,previewCanvas.getWidth(),previewCanvas.getHeight(),mapFile,dst,logger);
              BufferedImage image=ImageIO.read(dst);
              ImageIcon icon=new ImageIcon(image);
              previewCanvas.setIcon(icon);
              logger.fine(""String_Node_Str"");
            }
 catch (            Exception e) {
              logger.warning(e.toString());
            }
          }
        }
);
        thread.setDaemon(true);
        thread.start();
      }
      logger.info(""String_Node_Str"" + file + ""String_Node_Str"");
    }
 catch (    Exception e) {
      logger.severe(e.getMessage());
      openDataset(null);
      return;
    }
  }
  bandCountChanged();
  tileTypeChanged();
  imageFormatChanged();
  recalculateTiles();
  frame.doLayout();
}","private void openDataset(File file){
  fileOpen=file != null;
  if (!fileOpen) {
    infoText.setText(""String_Node_Str"");
    gdalFileField.setText(""String_Node_Str"");
    mapnikFileField.setText(""String_Node_Str"");
    previewCanvas.setIcon(null);
    bandCount=0;
    dataset=null;
    sector=null;
    mapFile=null;
  }
 else {
    try {
      gdalFileField.setText(file.getAbsolutePath());
      mapnikFileField.setText(file.getAbsolutePath());
      this.mapFile=file;
      if (gdalRadio.isSelected()) {
        final Dataset dataset=GDALUtil.open(file);
        final Sector sector=GDALUtil.getSector(dataset);
        this.sector=sector;
        this.dataset=dataset;
        final int width=dataset.getRasterXSize();
        final int height=dataset.getRasterYSize();
        if (sector.getMinLongitude() == 0 && sector.getMinLatitude() == 0 && sector.getMaxLongitude() == width && sector.getMaxLatitude() == height) {
          throw new TilerException(""String_Node_Str"" + file + ""String_Node_Str"");
        }
        if (sector.getMinLatitude() < -180 || sector.getMaxLatitude() > 180 || sector.getMinLongitude() < -360 || sector.getMaxLongitude() > 360 || Math.abs(sector.getDeltaLatitude()) > 180 || Math.abs(sector.getDeltaLongitude()) > 360) {
          throw new TilerException(""String_Node_Str"" + sector + ""String_Node_Str"");
        }
        bandCount=dataset.getRasterCount();
        if (bandCount == 0) {
          throw new TilerException(""String_Node_Str"");
        }
        String projection=dataset.GetProjection();
        SpatialReference spatialReference=(projection == null || projection.length() == 0 || !GDALUtil.isProjectionsSupported()) ? null : new SpatialReference(projection);
        String[] dataTypes=new String[bandCount];
        int[] dataTypeSizes=new int[bandCount];
        Double[] nodata=new Double[bandCount];
        double[] min=new double[bandCount];
        double[] max=new double[bandCount];
        for (int i=0; i < bandCount; i++) {
          Band band=dataset.GetRasterBand(i + 1);
          int dataType=band.getDataType();
          dataTypes[i]=gdal.GetDataTypeName(dataType);
          dataTypeSizes[i]=gdal.GetDataTypeSize(dataType);
          Double[] nodataValue=new Double[1];
          band.GetNoDataValue(nodataValue);
          nodata[i]=nodataValue[0];
          double[] minmax=new double[2];
          band.ComputeRasterMinMax(minmax,1);
          min[i]=minmax[0];
          max[i]=minmax[1];
        }
        StringLineBuilder info=new StringLineBuilder();
        info.appendLine(""String_Node_Str"");
        info.appendLine(""String_Node_Str"" + width + ""String_Node_Str""+ height);
        info.appendLine(""String_Node_Str"" + (sector.getDeltaLongitude() / width) + ""String_Node_Str""+ (sector.getDeltaLatitude() / height));
        info.appendLine(""String_Node_Str"" + sector.getMinLongitude() + ""String_Node_Str""+ sector.getMinLatitude()+ ""String_Node_Str"");
        info.appendLine(""String_Node_Str"" + sector.getMaxLongitude() + ""String_Node_Str""+ sector.getMaxLatitude()+ ""String_Node_Str"");
        info.appendLine(""String_Node_Str"" + bandCount);
        for (int i=0; i < bandCount; i++) {
          info.appendLine(""String_Node_Str"" + (i + 1) + ""String_Node_Str"");
          info.appendLine(""String_Node_Str"" + dataTypes[i] + ""String_Node_Str""+ dataTypeSizes[i]+ ""String_Node_Str"");
          info.appendLine(""String_Node_Str"" + nodata[i]);
          info.appendLine(""String_Node_Str"" + min[i]);
          info.appendLine(""String_Node_Str"" + max[i]);
        }
        if (spatialReference != null) {
          info.appendLine(""String_Node_Str"");
          info.appendLine(Util.fixNewlines(spatialReference.ExportToPrettyWkt()));
        }
        String text=info.toString(true);
        infoText.setText(text);
        infoText.select(0,0);
        Thread thread=new Thread(new Runnable(){
          public void run(){
            logger.fine(""String_Node_Str"");
            try {
              int w=400;
              int h=w;
              if (width > height) {
                h=w * height / width;
              }
 else {
                w=h * width / height;
              }
              GDALTile tile=new GDALTile(dataset,w,h,sector.getMinLatitude(),sector.getMinLongitude(),sector.getMaxLatitude(),sector.getMaxLongitude());
              tile=tile.convertToType(gdalconst.GDT_Byte);
              BufferedImage image=tile.getAsImage();
              ImageIcon icon=new ImageIcon(image);
              previewCanvas.setIcon(icon);
              logger.fine(""String_Node_Str"");
            }
 catch (            Exception e) {
              logger.warning(e.getMessage());
            }
          }
        }
);
        thread.setDaemon(true);
        thread.start();
      }
 else {
        infoText.setText(""String_Node_Str"");
        this.bandCount=0;
        Sector sect=MapnikUtil.getSector(mapFile);
        if (sect == null) {
          sect=Sector.FULL_SPHERE;
          logger.warning(""String_Node_Str"");
        }
        this.sector=sect;
        minLatitudeField.setValue(sect.getMinLatitude());
        minLongitudeField.setValue(sect.getMinLongitude());
        maxLatitudeField.setValue(sect.getMaxLatitude());
        maxLongitudeField.setValue(sect.getMaxLongitude());
        Thread thread=new Thread(new Runnable(){
          public void run(){
            logger.fine(""String_Node_Str"");
            try {
              File dst=File.createTempFile(""String_Node_Str"",""String_Node_Str"");
              dst.deleteOnExit();
              MapnikUtil.tile(sector,previewCanvas.getWidth(),previewCanvas.getHeight(),mapFile,dst,logger);
              BufferedImage image=ImageIO.read(dst);
              ImageIcon icon=new ImageIcon(image);
              previewCanvas.setIcon(icon);
              logger.fine(""String_Node_Str"");
            }
 catch (            Exception e) {
              logger.warning(e.toString());
            }
          }
        }
);
        thread.setDaemon(true);
        thread.start();
      }
      logger.info(""String_Node_Str"" + file + ""String_Node_Str"");
    }
 catch (    Exception e) {
      logger.severe(e.getMessage());
      openDataset(null);
      return;
    }
  }
  bandCountChanged();
  tileTypeChanged();
  imageFormatChanged();
  recalculateTiles();
  frame.doLayout();
}",0.981598024376643
11158,"public static int levelCount(Dataset dataset,double lztd,Sector sector,int tilesize){
  double width=dataset.getRasterXSize();
  double height=dataset.getRasterYSize();
  double lonPixels=sector.getDeltaLongitude() / width;
  double latPixels=sector.getDeltaLatitude() / height;
  double texelSize=Math.min(latPixels,lonPixels);
  return (int)Math.ceil(Math.log10(texelSize * tilesize / lztd) / Math.log10(0.5)) + 1;
}","public static int levelCount(Dataset dataset,double lztd,Sector sector,int tilesize){
  double width=dataset.getRasterXSize();
  double height=dataset.getRasterYSize();
  double lonPixels=sector.getDeltaLongitude() / width;
  double latPixels=sector.getDeltaLatitude() / height;
  double texelSize=Math.min(latPixels,lonPixels);
  int level=(int)Math.ceil(Math.log10(texelSize * tilesize / lztd) / Math.log10(0.5)) + 1;
  return Math.max(level,1);
}",0.9480968858131488
11159,"private void openDataset(File file){
  fileOpen=file != null;
  if (!fileOpen) {
    infoText.setText(""String_Node_Str"");
    gdalFileField.setText(""String_Node_Str"");
    mapnikFileField.setText(""String_Node_Str"");
    previewCanvas.setIcon(null);
    bandCount=0;
    dataset=null;
    sector=null;
    mapFile=null;
  }
 else {
    try {
      gdalFileField.setText(file.getAbsolutePath());
      mapnikFileField.setText(file.getAbsolutePath());
      this.mapFile=file;
      if (gdalRadio.isSelected()) {
        final Dataset dataset=GDALUtil.open(file);
        final Sector sector=GDALUtil.getSector(dataset);
        this.sector=sector;
        this.dataset=dataset;
        final int width=dataset.getRasterXSize();
        final int height=dataset.getRasterYSize();
        if (sector.getMinLongitude() == 0 && sector.getMinLatitude() == 0 && sector.getMaxLongitude() == width && sector.getMaxLatitude() == height) {
          throw new TilerException(""String_Node_Str"" + file + ""String_Node_Str"");
        }
        bandCount=dataset.getRasterCount();
        if (bandCount == 0) {
          throw new TilerException(""String_Node_Str"");
        }
        String projection=dataset.GetProjection();
        SpatialReference spatialReference=(projection == null || projection.length() == 0 || !GDALUtil.isProjectionsSupported()) ? null : new SpatialReference(projection);
        String[] dataTypes=new String[bandCount];
        int[] dataTypeSizes=new int[bandCount];
        Double[] nodata=new Double[bandCount];
        double[] min=new double[bandCount];
        double[] max=new double[bandCount];
        for (int i=0; i < bandCount; i++) {
          Band band=dataset.GetRasterBand(i + 1);
          int dataType=band.getDataType();
          dataTypes[i]=gdal.GetDataTypeName(dataType);
          dataTypeSizes[i]=gdal.GetDataTypeSize(dataType);
          Double[] nodataValue=new Double[1];
          band.GetNoDataValue(nodataValue);
          nodata[i]=nodataValue[0];
          double[] minmax=new double[2];
          band.ComputeRasterMinMax(minmax,1);
          min[i]=minmax[0];
          max[i]=minmax[1];
        }
        StringLineBuilder info=new StringLineBuilder();
        info.appendLine(""String_Node_Str"");
        info.appendLine(""String_Node_Str"" + width + ""String_Node_Str""+ height);
        info.appendLine(""String_Node_Str"" + (sector.getDeltaLongitude() / width) + ""String_Node_Str""+ (sector.getDeltaLatitude() / height));
        info.appendLine(""String_Node_Str"" + sector.getMinLongitude() + ""String_Node_Str""+ sector.getMinLatitude()+ ""String_Node_Str"");
        info.appendLine(""String_Node_Str"" + sector.getMaxLongitude() + ""String_Node_Str""+ sector.getMaxLatitude()+ ""String_Node_Str"");
        info.appendLine(""String_Node_Str"" + bandCount);
        for (int i=0; i < bandCount; i++) {
          info.appendLine(""String_Node_Str"" + (i + 1) + ""String_Node_Str"");
          info.appendLine(""String_Node_Str"" + dataTypes[i] + ""String_Node_Str""+ dataTypeSizes[i]+ ""String_Node_Str"");
          info.appendLine(""String_Node_Str"" + nodata[i]);
          info.appendLine(""String_Node_Str"" + min[i]);
          info.appendLine(""String_Node_Str"" + max[i]);
        }
        if (spatialReference != null) {
          info.appendLine(""String_Node_Str"");
          info.appendLine(Util.fixNewlines(spatialReference.ExportToPrettyWkt()));
        }
        String text=info.toString(true);
        infoText.setText(text);
        infoText.select(0,0);
        Thread thread=new Thread(new Runnable(){
          public void run(){
            logger.fine(""String_Node_Str"");
            try {
              int w=400;
              int h=w;
              if (width > height) {
                h=w * height / width;
              }
 else {
                w=h * width / height;
              }
              GDALTile tile=new GDALTile(dataset,w,h,sector.getMinLatitude(),sector.getMinLongitude(),sector.getMaxLatitude(),sector.getMaxLongitude());
              tile=tile.convertToType(gdalconst.GDT_Byte);
              BufferedImage image=tile.getAsImage();
              ImageIcon icon=new ImageIcon(image);
              previewCanvas.setIcon(icon);
              logger.fine(""String_Node_Str"");
            }
 catch (            Exception e) {
              logger.warning(e.getMessage());
            }
          }
        }
);
        thread.setDaemon(true);
        thread.start();
      }
 else {
        infoText.setText(""String_Node_Str"");
        this.bandCount=0;
        Sector sect=MapnikUtil.getSector(mapFile);
        if (sect == null) {
          sect=Sector.FULL_SPHERE;
          logger.warning(""String_Node_Str"");
        }
        this.sector=sect;
        minLatitudeField.setValue(sect.getMinLatitude());
        minLongitudeField.setValue(sect.getMinLongitude());
        maxLatitudeField.setValue(sect.getMaxLatitude());
        maxLongitudeField.setValue(sect.getMaxLongitude());
        Thread thread=new Thread(new Runnable(){
          public void run(){
            logger.fine(""String_Node_Str"");
            try {
              File dst=File.createTempFile(""String_Node_Str"",""String_Node_Str"");
              dst.deleteOnExit();
              MapnikUtil.tile(sector,previewCanvas.getWidth(),previewCanvas.getHeight(),mapFile,dst,logger);
              BufferedImage image=ImageIO.read(dst);
              ImageIcon icon=new ImageIcon(image);
              previewCanvas.setIcon(icon);
              logger.fine(""String_Node_Str"");
            }
 catch (            Exception e) {
              logger.warning(e.toString());
            }
          }
        }
);
        thread.setDaemon(true);
        thread.start();
      }
      logger.info(""String_Node_Str"" + file + ""String_Node_Str"");
    }
 catch (    Exception e) {
      logger.severe(e.getMessage());
      openDataset(null);
      return;
    }
  }
  bandCountChanged();
  tileTypeChanged();
  imageFormatChanged();
  recalculateTiles();
  frame.doLayout();
}","private void openDataset(File file){
  fileOpen=file != null;
  if (!fileOpen) {
    infoText.setText(""String_Node_Str"");
    gdalFileField.setText(""String_Node_Str"");
    mapnikFileField.setText(""String_Node_Str"");
    previewCanvas.setIcon(null);
    bandCount=0;
    dataset=null;
    sector=null;
    mapFile=null;
  }
 else {
    try {
      gdalFileField.setText(file.getAbsolutePath());
      mapnikFileField.setText(file.getAbsolutePath());
      this.mapFile=file;
      if (gdalRadio.isSelected()) {
        final Dataset dataset=GDALUtil.open(file);
        final Sector sector=GDALUtil.getSector(dataset);
        this.sector=sector;
        this.dataset=dataset;
        final int width=dataset.getRasterXSize();
        final int height=dataset.getRasterYSize();
        if (sector.getMinLongitude() == 0 && sector.getMinLatitude() == 0 && sector.getMaxLongitude() == width && sector.getMaxLatitude() == height) {
          throw new TilerException(""String_Node_Str"" + file + ""String_Node_Str"");
        }
        if (sector.getMinLatitude() < -90 || sector.getMaxLatitude() > 90 || sector.getMinLongitude() < -180 || sector.getMaxLongitude() > 180) {
          throw new TilerException(""String_Node_Str"" + sector + ""String_Node_Str"");
        }
        bandCount=dataset.getRasterCount();
        if (bandCount == 0) {
          throw new TilerException(""String_Node_Str"");
        }
        String projection=dataset.GetProjection();
        SpatialReference spatialReference=(projection == null || projection.length() == 0 || !GDALUtil.isProjectionsSupported()) ? null : new SpatialReference(projection);
        String[] dataTypes=new String[bandCount];
        int[] dataTypeSizes=new int[bandCount];
        Double[] nodata=new Double[bandCount];
        double[] min=new double[bandCount];
        double[] max=new double[bandCount];
        for (int i=0; i < bandCount; i++) {
          Band band=dataset.GetRasterBand(i + 1);
          int dataType=band.getDataType();
          dataTypes[i]=gdal.GetDataTypeName(dataType);
          dataTypeSizes[i]=gdal.GetDataTypeSize(dataType);
          Double[] nodataValue=new Double[1];
          band.GetNoDataValue(nodataValue);
          nodata[i]=nodataValue[0];
          double[] minmax=new double[2];
          band.ComputeRasterMinMax(minmax,1);
          min[i]=minmax[0];
          max[i]=minmax[1];
        }
        StringLineBuilder info=new StringLineBuilder();
        info.appendLine(""String_Node_Str"");
        info.appendLine(""String_Node_Str"" + width + ""String_Node_Str""+ height);
        info.appendLine(""String_Node_Str"" + (sector.getDeltaLongitude() / width) + ""String_Node_Str""+ (sector.getDeltaLatitude() / height));
        info.appendLine(""String_Node_Str"" + sector.getMinLongitude() + ""String_Node_Str""+ sector.getMinLatitude()+ ""String_Node_Str"");
        info.appendLine(""String_Node_Str"" + sector.getMaxLongitude() + ""String_Node_Str""+ sector.getMaxLatitude()+ ""String_Node_Str"");
        info.appendLine(""String_Node_Str"" + bandCount);
        for (int i=0; i < bandCount; i++) {
          info.appendLine(""String_Node_Str"" + (i + 1) + ""String_Node_Str"");
          info.appendLine(""String_Node_Str"" + dataTypes[i] + ""String_Node_Str""+ dataTypeSizes[i]+ ""String_Node_Str"");
          info.appendLine(""String_Node_Str"" + nodata[i]);
          info.appendLine(""String_Node_Str"" + min[i]);
          info.appendLine(""String_Node_Str"" + max[i]);
        }
        if (spatialReference != null) {
          info.appendLine(""String_Node_Str"");
          info.appendLine(Util.fixNewlines(spatialReference.ExportToPrettyWkt()));
        }
        String text=info.toString(true);
        infoText.setText(text);
        infoText.select(0,0);
        Thread thread=new Thread(new Runnable(){
          public void run(){
            logger.fine(""String_Node_Str"");
            try {
              int w=400;
              int h=w;
              if (width > height) {
                h=w * height / width;
              }
 else {
                w=h * width / height;
              }
              GDALTile tile=new GDALTile(dataset,w,h,sector.getMinLatitude(),sector.getMinLongitude(),sector.getMaxLatitude(),sector.getMaxLongitude());
              tile=tile.convertToType(gdalconst.GDT_Byte);
              BufferedImage image=tile.getAsImage();
              ImageIcon icon=new ImageIcon(image);
              previewCanvas.setIcon(icon);
              logger.fine(""String_Node_Str"");
            }
 catch (            Exception e) {
              logger.warning(e.getMessage());
            }
          }
        }
);
        thread.setDaemon(true);
        thread.start();
      }
 else {
        infoText.setText(""String_Node_Str"");
        this.bandCount=0;
        Sector sect=MapnikUtil.getSector(mapFile);
        if (sect == null) {
          sect=Sector.FULL_SPHERE;
          logger.warning(""String_Node_Str"");
        }
        this.sector=sect;
        minLatitudeField.setValue(sect.getMinLatitude());
        minLongitudeField.setValue(sect.getMinLongitude());
        maxLatitudeField.setValue(sect.getMaxLatitude());
        maxLongitudeField.setValue(sect.getMaxLongitude());
        Thread thread=new Thread(new Runnable(){
          public void run(){
            logger.fine(""String_Node_Str"");
            try {
              File dst=File.createTempFile(""String_Node_Str"",""String_Node_Str"");
              dst.deleteOnExit();
              MapnikUtil.tile(sector,previewCanvas.getWidth(),previewCanvas.getHeight(),mapFile,dst,logger);
              BufferedImage image=ImageIO.read(dst);
              ImageIcon icon=new ImageIcon(image);
              previewCanvas.setIcon(icon);
              logger.fine(""String_Node_Str"");
            }
 catch (            Exception e) {
              logger.warning(e.toString());
            }
          }
        }
);
        thread.setDaemon(true);
        thread.start();
      }
      logger.info(""String_Node_Str"" + file + ""String_Node_Str"");
    }
 catch (    Exception e) {
      logger.severe(e.getMessage());
      openDataset(null);
      return;
    }
  }
  bandCountChanged();
  tileTypeChanged();
  imageFormatChanged();
  recalculateTiles();
  frame.doLayout();
}",0.9803600654664484
11160,"public Application(){
  if (!GDALUtil.isProjectionsSupported()) {
    String message=""String_Node_Str"" + ""String_Node_Str"" + GDALUtil.GCS_FILE + ""String_Node_Str""+ ""String_Node_Str"";
    int value=JOptionPane.showConfirmDialog(null,message,""String_Node_Str"",JOptionPane.YES_NO_OPTION,JOptionPane.WARNING_MESSAGE);
    if (value != JOptionPane.YES_OPTION) {
      return;
    }
  }
  JLabel label;
  GridBagConstraints c;
  JScrollPane scrollPane;
  ButtonGroup bg;
  JPanel panel;
  Dimension size;
  ActionListener al;
  JSeparator sep;
  int SPACING=4;
  frame=new JFrame(""String_Node_Str"");
  frame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
  frame.setLayout(new BorderLayout());
  frame.addWindowListener(new WindowAdapter(){
    @Override public void windowClosed(    WindowEvent we){
      onExit();
    }
  }
);
  JPanel tlPanel=new JPanel(new GridBagLayout());
  tlPanel.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  JPanel trPanel=new JPanel(new GridBagLayout());
  trPanel.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  JPanel blPanel=new JPanel(new GridBagLayout());
  blPanel.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  JPanel brPanel=new JPanel(new GridBagLayout());
  brPanel.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  JPanel bPanel=new JPanel(new GridBagLayout());
  leftSplit=new JSplitPane(JSplitPane.VERTICAL_SPLIT,true,tlPanel,blPanel);
  rightSplit=new JSplitPane(JSplitPane.VERTICAL_SPLIT,true,trPanel,brPanel);
  topSplit=new JSplitPane(JSplitPane.HORIZONTAL_SPLIT,true,leftSplit,rightSplit);
  logSplit=new JSplitPane(JSplitPane.VERTICAL_SPLIT,true,topSplit,bPanel);
  panel=new JPanel(new GridBagLayout());
  scrollPane=new JScrollPane(panel,JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED,JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
  c=new GridBagConstraints();
  c.fill=GridBagConstraints.BOTH;
  c.weightx=1;
  c.weighty=1;
  trPanel.add(scrollPane,c);
  trPanel=panel;
  frame.add(logSplit,BorderLayout.CENTER);
  textLog=new JTextPane();
  textLog.setEditable(false);
  scrollPane=new JScrollPane(textLog,JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED,JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);
  c=new GridBagConstraints();
  c.gridx=0;
  c.gridy=0;
  c.fill=GridBagConstraints.BOTH;
  c.weightx=1;
  c.weighty=1;
  bPanel.add(scrollPane,c);
  textLog.getDocument().addDocumentListener(new DocumentAdapter(){
    @Override public void anyChange(    DocumentEvent e){
      int length=textLog.getDocument().getLength();
      textLog.select(length,length);
    }
  }
);
  progress=new JProgressBar(0,100);
  progress.setString(""String_Node_Str"");
  progress.setStringPainted(true);
  c=new GridBagConstraints();
  c.gridx=0;
  c.gridy=1;
  c.fill=GridBagConstraints.HORIZONTAL;
  bPanel.add(progress,c);
  logger=new DocumentLogger(LOGGER,textLog.getStyledDocument());
  LogManager.getLogManager().addLogger(logger);
  createLoggerPopupMenu();
  panel=new JPanel(new GridBagLayout());
  c=new GridBagConstraints();
  c.gridy=0;
  c.anchor=GridBagConstraints.WEST;
  tlPanel.add(panel,c);
  label=new JLabel(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=0;
  c.insets=new Insets(0,0,0,SPACING);
  panel.add(label,c);
  al=new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      datasetModeChanged();
    }
  }
;
  gdalRadio=new JRadioButton(""String_Node_Str"");
  gdalRadio.setSelected(true);
  datasetSelected=gdalRadio;
  c=new GridBagConstraints();
  c.gridx=1;
  panel.add(gdalRadio,c);
  gdalRadio.addActionListener(al);
  mapnikRadio=new JRadioButton(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=2;
  panel.add(mapnikRadio,c);
  mapnikRadio.addActionListener(al);
  bg=new ButtonGroup();
  bg.add(gdalRadio);
  bg.add(mapnikRadio);
  sep=new JSeparator(JSeparator.HORIZONTAL);
  c=new GridBagConstraints();
  c.gridy=1;
  c.fill=GridBagConstraints.HORIZONTAL;
  c.insets=new Insets(SPACING * 2,0,SPACING * 2,0);
  tlPanel.add(sep,c);
  dataModeCards=new JPanel(new CardLayout());
  c=new GridBagConstraints();
  c.gridy=2;
  c.fill=GridBagConstraints.BOTH;
  c.weighty=1;
  c.weightx=1;
  c.anchor=GridBagConstraints.NORTH;
  tlPanel.add(dataModeCards,c);
  JPanel gdalCard=new JPanel(new GridBagLayout());
  dataModeCards.add(gdalCard,gdalRadio.getText());
  JPanel mapnikCard=new JPanel(new GridBagLayout());
  dataModeCards.add(mapnikCard,mapnikRadio.getText());
  panel=new JPanel(new GridBagLayout());
  c=new GridBagConstraints();
  c.gridy=0;
  c.fill=GridBagConstraints.HORIZONTAL;
  gdalCard.add(panel,c);
  label=new JLabel(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=0;
  c.insets=new Insets(0,0,SPACING,SPACING);
  panel.add(label,c);
  gdalFileField=new JTextField();
  gdalFileField.setEnabled(false);
  c=new GridBagConstraints();
  c.gridx=1;
  c.fill=GridBagConstraints.HORIZONTAL;
  c.weightx=1;
  c.insets=new Insets(0,0,SPACING,0);
  panel.add(gdalFileField,c);
  browseGdalButton=new JButton(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=2;
  c.insets=new Insets(0,0,SPACING,0);
  panel.add(browseGdalButton,c);
  browseGdalButton.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      setupInputFile();
    }
  }
);
  infoText=new JTextArea();
  infoText.setBackground(label.getBackground());
  infoText.setEditable(false);
  Font font=Font.decode(null);
  infoText.setFont(font);
  scrollPane=new JScrollPane(infoText,JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED,JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);
  size=new Dimension(20,20);
  scrollPane.setMinimumSize(size);
  scrollPane.setPreferredSize(size);
  c=new GridBagConstraints();
  c.gridy=1;
  c.fill=GridBagConstraints.BOTH;
  c.weightx=1;
  c.weighty=1;
  gdalCard.add(scrollPane,c);
  panel=new JPanel(new GridBagLayout());
  c=new GridBagConstraints();
  c.gridy=0;
  c.fill=GridBagConstraints.HORIZONTAL;
  mapnikCard.add(panel,c);
  label=new JLabel(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=0;
  c.gridy=0;
  c.anchor=GridBagConstraints.EAST;
  c.insets=new Insets(0,0,SPACING,SPACING);
  panel.add(label,c);
  pythonBinaryField=new JTextField();
  pythonBinaryField.setEnabled(false);
  c=new GridBagConstraints();
  c.gridx=1;
  c.gridy=0;
  c.fill=GridBagConstraints.HORIZONTAL;
  c.weightx=1;
  c.insets=new Insets(0,0,SPACING,0);
  panel.add(pythonBinaryField,c);
  browsePythonBinaryButton=new JButton(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=2;
  c.gridy=0;
  c.insets=new Insets(0,0,SPACING,0);
  panel.add(browsePythonBinaryButton,c);
  browsePythonBinaryButton.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      setupPythonBinary();
    }
  }
);
  label=new JLabel(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=0;
  c.gridy=1;
  c.anchor=GridBagConstraints.EAST;
  c.insets=new Insets(0,0,SPACING,SPACING);
  panel.add(label,c);
  mapnikScriptField=new JTextField();
  mapnikScriptField.setEnabled(false);
  c=new GridBagConstraints();
  c.gridx=1;
  c.gridy=1;
  c.fill=GridBagConstraints.HORIZONTAL;
  c.weightx=1;
  c.insets=new Insets(0,0,SPACING,0);
  panel.add(mapnikScriptField,c);
  browseMapnikScriptButton=new JButton(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=2;
  c.gridy=1;
  c.insets=new Insets(0,0,SPACING,0);
  panel.add(browseMapnikScriptButton,c);
  browseMapnikScriptButton.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      setupMapnikScript();
    }
  }
);
  label=new JLabel(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=0;
  c.gridy=2;
  c.anchor=GridBagConstraints.EAST;
  c.insets=new Insets(0,0,0,SPACING);
  panel.add(label,c);
  mapnikFileField=new JTextField();
  mapnikFileField.setEnabled(false);
  c=new GridBagConstraints();
  c.gridx=1;
  c.gridy=2;
  c.fill=GridBagConstraints.HORIZONTAL;
  c.weightx=1;
  panel.add(mapnikFileField,c);
  browseMapnikButton=new JButton(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=2;
  c.gridy=2;
  panel.add(browseMapnikButton,c);
  browseMapnikButton.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      setupInputFile();
    }
  }
);
  sep=new JSeparator(JSeparator.HORIZONTAL);
  c=new GridBagConstraints();
  c.gridy=1;
  c.fill=GridBagConstraints.HORIZONTAL;
  c.insets=new Insets(SPACING * 2,0,SPACING * 2,0);
  mapnikCard.add(sep,c);
  panel=new JPanel(new GridBagLayout());
  c=new GridBagConstraints();
  c.gridy=2;
  c.anchor=GridBagConstraints.NORTH;
  c.fill=GridBagConstraints.HORIZONTAL;
  c.weightx=1;
  c.weighty=1;
  mapnikCard.add(panel,c);
  label=new JLabel(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=0;
  c.gridy=0;
  c.anchor=GridBagConstraints.EAST;
  c.insets=new Insets(0,0,SPACING,SPACING);
  panel.add(label,c);
  labels.add(label);
  minLatitudeField=new JDoubleField(-90d);
  c=new GridBagConstraints();
  c.gridx=1;
  c.gridy=0;
  c.weightx=0.5;
  c.fill=GridBagConstraints.HORIZONTAL;
  c.insets=new Insets(0,0,SPACING,SPACING);
  panel.add(minLatitudeField,c);
  label=new JLabel(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=2;
  c.gridy=0;
  c.anchor=GridBagConstraints.EAST;
  c.insets=new Insets(0,SPACING,SPACING,SPACING);
  panel.add(label,c);
  labels.add(label);
  minLongitudeField=new JDoubleField(-180d);
  c=new GridBagConstraints();
  c.gridx=3;
  c.gridy=0;
  c.weightx=0.5;
  c.fill=GridBagConstraints.HORIZONTAL;
  c.insets=new Insets(0,0,SPACING,0);
  panel.add(minLongitudeField,c);
  label=new JLabel(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=0;
  c.gridy=1;
  c.anchor=GridBagConstraints.EAST;
  c.insets=new Insets(0,0,SPACING,SPACING);
  panel.add(label,c);
  labels.add(label);
  maxLatitudeField=new JDoubleField(90d);
  c=new GridBagConstraints();
  c.gridx=1;
  c.gridy=1;
  c.fill=GridBagConstraints.HORIZONTAL;
  c.insets=new Insets(0,0,SPACING,SPACING);
  panel.add(maxLatitudeField,c);
  label=new JLabel(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=2;
  c.gridy=1;
  c.anchor=GridBagConstraints.EAST;
  c.insets=new Insets(0,SPACING,SPACING,SPACING);
  panel.add(label,c);
  labels.add(label);
  maxLongitudeField=new JDoubleField(180d);
  c=new GridBagConstraints();
  c.gridx=3;
  c.gridy=1;
  c.fill=GridBagConstraints.HORIZONTAL;
  c.insets=new Insets(0,0,SPACING,0);
  panel.add(maxLongitudeField,c);
  previewCanvas=new JLabel();
  previewCanvas.setHorizontalAlignment(SwingConstants.CENTER);
  scrollPane=new JScrollPane(previewCanvas,JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED,JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);
  previewCanvas.setBackground(Color.white);
  c=new GridBagConstraints();
  c.weightx=1;
  c.weighty=1;
  c.fill=GridBagConstraints.BOTH;
  c.anchor=GridBagConstraints.CENTER;
  blPanel.add(scrollPane,c);
  tileTypeLabel=new JLabel(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=0;
  c.gridy=0;
  c.anchor=GridBagConstraints.EAST;
  c.insets=new Insets(0,0,SPACING,SPACING);
  trPanel.add(tileTypeLabel,c);
  panel=new JPanel(new GridBagLayout());
  c=new GridBagConstraints();
  c.gridx=1;
  c.gridy=0;
  c.weightx=1;
  c.anchor=GridBagConstraints.WEST;
  c.insets=new Insets(0,0,SPACING,0);
  trPanel.add(panel,c);
  al=new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      tileTypeChanged();
    }
  }
;
  imageRadio=new JRadioButton(""String_Node_Str"");
  imageRadio.setSelected(true);
  c=new GridBagConstraints();
  c.gridx=0;
  panel.add(imageRadio,c);
  imageRadio.addActionListener(al);
  elevationRadio=new JRadioButton(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=1;
  panel.add(elevationRadio,c);
  elevationRadio.addActionListener(al);
  bg=new ButtonGroup();
  bg.add(imageRadio);
  bg.add(elevationRadio);
  label=new JLabel(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=0;
  c.gridy=1;
  c.anchor=GridBagConstraints.EAST;
  c.insets=new Insets(0,0,SPACING,SPACING);
  trPanel.add(label,c);
  labels.add(label);
  panel=new JPanel(new GridBagLayout());
  c=new GridBagConstraints();
  c.gridx=1;
  c.gridy=1;
  c.anchor=GridBagConstraints.WEST;
  c.insets=new Insets(0,0,SPACING,0);
  trPanel.add(panel,c);
  tilesizeField=new JIntegerField(512);
  tilesizeField.setPositive(true);
  c=new GridBagConstraints();
  c.gridx=0;
  size=tilesizeField.getPreferredSize();
  size.width=50;
  tilesizeField.setMinimumSize(size);
  tilesizeField.setMaximumSize(size);
  tilesizeField.setPreferredSize(size);
  panel.add(tilesizeField,c);
  tilesizeField.getDocument().addDocumentListener(new DocumentAdapter(){
    @Override public void anyChange(    DocumentEvent e){
      if (!tilesizeBeingSet) {
        tilesizeChanged=true;
      }
    }
  }
);
  tilesizeField.addFocusListener(new FocusAdapter(){
    @Override public void focusLost(    FocusEvent e){
      tilesizeChanged();
    }
  }
);
  label=new JLabel(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=1;
  c.insets=new Insets(0,SPACING / 2,0,0);
  panel.add(label,c);
  labels.add(label);
  label=new JLabel(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=0;
  c.gridy=2;
  c.anchor=GridBagConstraints.EAST;
  c.insets=new Insets(0,0,SPACING,SPACING);
  trPanel.add(label,c);
  labels.add(label);
  panel=new JPanel(new GridBagLayout());
  c=new GridBagConstraints();
  c.gridx=1;
  c.gridy=2;
  c.anchor=GridBagConstraints.WEST;
  c.insets=new Insets(0,0,SPACING,0);
  trPanel.add(panel,c);
  lztsField=new JDoubleField(36d);
  c=new GridBagConstraints();
  c.gridx=0;
  size=lztsField.getPreferredSize();
  size.width=50;
  lztsField.setMinimumSize(size);
  lztsField.setMaximumSize(size);
  lztsField.setPreferredSize(size);
  panel.add(lztsField,c);
  lztsField.getDocument().addDocumentListener(new DocumentAdapter(){
    @Override public void anyChange(    DocumentEvent e){
      if (!lztsBeingSet) {
        lztsChanged=true;
      }
    }
  }
);
  label=new JLabel(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=1;
  c.insets=new Insets(0,SPACING / 2,0,0);
  panel.add(label,c);
  labels.add(label);
  levelsLabel=new JLabel(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=0;
  c.gridy=3;
  c.anchor=GridBagConstraints.EAST;
  c.insets=new Insets(0,0,SPACING,SPACING);
  trPanel.add(levelsLabel,c);
  levelsSpinner=new JSpinner(new SpinnerNumberModel(5,1,100,1));
  c=new GridBagConstraints();
  c.gridx=1;
  c.gridy=3;
  c.anchor=GridBagConstraints.WEST;
  c.insets=new Insets(0,0,SPACING,0);
  trPanel.add(levelsSpinner,c);
  imageFormatLabel=new JLabel(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=0;
  c.gridy=4;
  c.anchor=GridBagConstraints.EAST;
  c.insets=new Insets(0,0,SPACING,SPACING);
  trPanel.add(imageFormatLabel,c);
  panel=new JPanel(new GridBagLayout());
  c=new GridBagConstraints();
  c.gridx=1;
  c.gridy=4;
  c.anchor=GridBagConstraints.WEST;
  c.insets=new Insets(0,0,SPACING,0);
  trPanel.add(panel,c);
  al=new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      imageFormatChanged();
    }
  }
;
  jpegRadio=new JRadioButton(""String_Node_Str"");
  jpegRadio.setSelected(true);
  c=new GridBagConstraints();
  c.gridx=0;
  panel.add(jpegRadio,c);
  jpegRadio.addActionListener(al);
  pngRadio=new JRadioButton(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=1;
  panel.add(pngRadio,c);
  pngRadio.addActionListener(al);
  bg=new ButtonGroup();
  bg.add(jpegRadio);
  bg.add(pngRadio);
  alphaCheck=new JCheckBox(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=0;
  c.gridy=5;
  c.anchor=GridBagConstraints.WEST;
  c.gridwidth=2;
  c.insets=new Insets(0,0,SPACING,0);
  trPanel.add(alphaCheck,c);
  alphaCheck.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      alphaSet=alphaCheck.isSelected();
      bandCountChanged();
    }
  }
);
  cellTypeLabel=new JLabel(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=0;
  c.gridy=6;
  c.anchor=GridBagConstraints.EAST;
  c.insets=new Insets(0,0,SPACING,SPACING);
  trPanel.add(cellTypeLabel,c);
  panel=new JPanel(new GridBagLayout());
  c=new GridBagConstraints();
  c.gridx=1;
  c.gridy=6;
  c.anchor=GridBagConstraints.WEST;
  c.insets=new Insets(0,0,SPACING,0);
  trPanel.add(panel,c);
  al=new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      elevationFormatChanged();
    }
  }
;
  byteRadio=new JRadioButton(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=0;
  panel.add(byteRadio,c);
  byteRadio.addActionListener(al);
  int16Radio=new JRadioButton(""String_Node_Str"");
  int16Radio.setSelected(true);
  c=new GridBagConstraints();
  c.gridx=1;
  panel.add(int16Radio,c);
  int16Radio.addActionListener(al);
  int32Radio=new JRadioButton(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=2;
  panel.add(int32Radio,c);
  int32Radio.addActionListener(al);
  float32Radio=new JRadioButton(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=3;
  panel.add(float32Radio,c);
  float32Radio.addActionListener(al);
  bg=new ButtonGroup();
  bg.add(byteRadio);
  bg.add(int16Radio);
  bg.add(int32Radio);
  bg.add(float32Radio);
  bandLabel=new JLabel(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=0;
  c.gridy=7;
  c.anchor=GridBagConstraints.EAST;
  c.insets=new Insets(0,0,SPACING,SPACING);
  trPanel.add(bandLabel,c);
  panel=new JPanel(new GridBagLayout());
  c=new GridBagConstraints();
  c.gridx=1;
  c.gridy=7;
  c.anchor=GridBagConstraints.WEST;
  c.insets=new Insets(0,0,SPACING,0);
  trPanel.add(panel,c);
  bandCombo=new JComboBox(new Integer[]{1});
  bandCombo.setSelectedIndex(0);
  c=new GridBagConstraints();
  c.gridx=0;
  panel.add(bandCombo,c);
  overviewsCheck=new JCheckBox(""String_Node_Str"");
  overviewsCheck.setSelected(true);
  c=new GridBagConstraints();
  c.gridx=0;
  c.gridy=8;
  c.gridwidth=2;
  c.anchor=GridBagConstraints.WEST;
  c.insets=new Insets(0,0,SPACING,0);
  trPanel.add(overviewsCheck,c);
  panel=new JPanel(new GridBagLayout());
  c=new GridBagConstraints();
  c.gridx=0;
  c.gridy=9;
  c.gridwidth=2;
  c.anchor=GridBagConstraints.WEST;
  trPanel.add(panel,c);
  overrideLevelsCheck=new JCheckBox(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=0;
  c.insets=new Insets(0,0,SPACING,SPACING);
  panel.add(overrideLevelsCheck,c);
  overrideLevelsCheck.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      if (mapnikRadio.isSelected() && !overrideLevelsCheck.isSelected()) {
        overrideLevelsCheck.setSelected(true);
      }
      enableFields();
    }
  }
);
  overrideLevelsSpinner=new JSpinner(new SpinnerNumberModel(1,1,100,1));
  c=new GridBagConstraints();
  c.gridx=1;
  c.insets=new Insets(0,0,SPACING,0);
  panel.add(overrideLevelsSpinner,c);
  outsideCheck=new JCheckBox(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=0;
  c.gridy=10;
  c.gridwidth=2;
  c.anchor=GridBagConstraints.WEST;
  trPanel.add(outsideCheck,c);
  outsideCheck.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      enableFields();
    }
  }
);
  outsidePanel=new JPanel(new GridBagLayout());
  c=new GridBagConstraints();
  c.gridx=1;
  c.gridy=11;
  c.anchor=GridBagConstraints.WEST;
  c.insets=new Insets(0,0,SPACING,0);
  trPanel.add(outsidePanel,c);
  replaceCheck=new JCheckBox(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=0;
  c.gridy=12;
  c.gridwidth=2;
  c.anchor=GridBagConstraints.WEST;
  trPanel.add(replaceCheck,c);
  replaceCheck.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      enableFields();
    }
  }
);
  replace1Label=new JLabel(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=0;
  c.gridy=13;
  c.anchor=GridBagConstraints.EAST;
  c.insets=new Insets(0,0,SPACING,SPACING);
  trPanel.add(replace1Label,c);
  minPanel=new JPanel(new GridBagLayout());
  c=new GridBagConstraints();
  c.gridx=1;
  c.gridy=13;
  c.anchor=GridBagConstraints.WEST;
  c.insets=new Insets(0,0,SPACING,0);
  trPanel.add(minPanel,c);
  replace2Label=new JLabel(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=0;
  c.gridy=14;
  c.anchor=GridBagConstraints.EAST;
  c.insets=new Insets(0,0,SPACING,SPACING);
  trPanel.add(replace2Label,c);
  maxPanel=new JPanel(new GridBagLayout());
  c=new GridBagConstraints();
  c.gridx=1;
  c.gridy=14;
  c.anchor=GridBagConstraints.WEST;
  c.insets=new Insets(0,0,SPACING,0);
  trPanel.add(maxPanel,c);
  replace3Label=new JLabel(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=0;
  c.gridy=15;
  c.anchor=GridBagConstraints.EAST;
  c.insets=new Insets(0,0,SPACING,SPACING);
  trPanel.add(replace3Label,c);
  min2Panel=new JPanel(new GridBagLayout());
  c=new GridBagConstraints();
  c.gridx=1;
  c.gridy=15;
  c.anchor=GridBagConstraints.WEST;
  c.insets=new Insets(0,0,SPACING,0);
  trPanel.add(min2Panel,c);
  replace4Label=new JLabel(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=0;
  c.gridy=16;
  c.anchor=GridBagConstraints.EAST;
  c.insets=new Insets(0,0,SPACING,SPACING);
  trPanel.add(replace4Label,c);
  max2Panel=new JPanel(new GridBagLayout());
  c=new GridBagConstraints();
  c.gridx=1;
  c.gridy=16;
  c.anchor=GridBagConstraints.WEST;
  c.insets=new Insets(0,0,SPACING,0);
  trPanel.add(max2Panel,c);
  replace5Label=new JLabel(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=0;
  c.gridy=17;
  c.anchor=GridBagConstraints.EAST;
  c.insets=new Insets(0,0,SPACING,SPACING);
  trPanel.add(replace5Label,c);
  withPanel=new JPanel(new GridBagLayout());
  c=new GridBagConstraints();
  c.gridx=1;
  c.gridy=17;
  c.anchor=GridBagConstraints.WEST;
  c.insets=new Insets(0,0,SPACING,0);
  trPanel.add(withPanel,c);
  replace6Label=new JLabel(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=0;
  c.gridy=18;
  c.anchor=GridBagConstraints.EAST;
  c.insets=new Insets(0,0,SPACING,SPACING);
  trPanel.add(replace6Label,c);
  otherwisePanel=new JPanel(new GridBagLayout());
  c=new GridBagConstraints();
  c.gridx=1;
  c.gridy=18;
  c.anchor=GridBagConstraints.WEST;
  c.insets=new Insets(0,0,SPACING,0);
  trPanel.add(otherwisePanel,c);
  panel=new JPanel(new GridBagLayout());
  c=new GridBagConstraints();
  c.gridx=0;
  c.gridy=19;
  c.weighty=1;
  trPanel.add(panel,c);
  panel=new JPanel(new GridBagLayout());
  c=new GridBagConstraints();
  c.gridx=0;
  c.gridy=0;
  c.fill=GridBagConstraints.HORIZONTAL;
  brPanel.add(panel,c);
  label=new JLabel(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=0;
  c.insets=new Insets(0,0,SPACING,SPACING);
  panel.add(label,c);
  outputDirectory=new JTextField();
  c=new GridBagConstraints();
  c.gridx=1;
  c.fill=GridBagConstraints.HORIZONTAL;
  c.weightx=1;
  c.insets=new Insets(0,0,SPACING,0);
  panel.add(outputDirectory,c);
  outputDirectory.getDocument().addDocumentListener(new DocumentAdapter(){
    @Override public void anyChange(    DocumentEvent e){
      String text=outputDirectory.getText();
      File dir=new File(text);
      if (dir.isDirectory()) {
        preferences.put(OUTPUT_DIR_KEY,text);
      }
    }
  }
);
  outputButton=new JButton(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=2;
  c.insets=new Insets(0,0,SPACING,0);
  panel.add(outputButton,c);
  outputButton.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      JFileChooser chooser=new JFileChooser(preferences.get(OUTPUT_DIR_KEY,null));
      chooser.setAcceptAllFileFilterUsed(false);
      chooser.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY);
      if (chooser.showOpenDialog(frame) == JFileChooser.APPROVE_OPTION) {
        File dir=chooser.getSelectedFile();
        outputDirectory.setText(dir.getAbsolutePath());
        preferences.put(OUTPUT_DIR_KEY,dir.getAbsolutePath());
      }
    }
  }
);
  tileText=new JTextArea();
  tileText.setBackground(label.getBackground());
  tileText.setEditable(false);
  tileText.setFont(font);
  scrollPane=new JScrollPane(tileText,JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED,JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);
  size=new Dimension(20,20);
  scrollPane.setMinimumSize(size);
  scrollPane.setPreferredSize(size);
  c=new GridBagConstraints();
  c.gridx=0;
  c.gridy=1;
  c.fill=GridBagConstraints.BOTH;
  c.weighty=1;
  c.weightx=1;
  c.anchor=GridBagConstraints.NORTH;
  c.insets=new Insets(0,0,SPACING,0);
  brPanel.add(scrollPane,c);
  panel=new JPanel(new GridBagLayout());
  c=new GridBagConstraints();
  c.gridx=0;
  c.gridy=2;
  brPanel.add(panel,c);
  tileButton=new JButton(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=0;
  c.insets=new Insets(0,0,0,SPACING);
  panel.add(tileButton,c);
  tileButton.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      generateTiles();
    }
  }
);
  cancelButton=new JButton(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=1;
  panel.add(cancelButton,c);
  cancelButton.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      cancel();
    }
  }
);
  JButton previewButton=new JButton(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=2;
  panel.add(previewButton,c);
  previewButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      preview();
    }
  }
);
  updatePythonFields();
  addRecalculateListeners();
  openDataset(null);
  datasetModeChanged();
  logger.info(""String_Node_Str"");
  if (!GDALUtil.isProjectionsSupported()) {
    logger.warning(""String_Node_Str"");
  }
  loadFrameBounds();
  loadSplitLocations();
  frame.setVisible(true);
}","public Application(){
  if (!GDALUtil.isProjectionsSupported()) {
    String message=""String_Node_Str"" + ""String_Node_Str"" + GDALUtil.GCS_FILE + ""String_Node_Str""+ ""String_Node_Str"";
    int value=JOptionPane.showConfirmDialog(null,message,""String_Node_Str"",JOptionPane.YES_NO_OPTION,JOptionPane.WARNING_MESSAGE);
    if (value != JOptionPane.YES_OPTION) {
      return;
    }
  }
  Thread.setDefaultUncaughtExceptionHandler(this);
  JLabel label;
  GridBagConstraints c;
  JScrollPane scrollPane;
  ButtonGroup bg;
  JPanel panel;
  Dimension size;
  ActionListener al;
  JSeparator sep;
  int SPACING=4;
  frame=new JFrame(""String_Node_Str"");
  frame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
  frame.setLayout(new BorderLayout());
  frame.addWindowListener(new WindowAdapter(){
    @Override public void windowClosed(    WindowEvent we){
      onExit();
    }
  }
);
  JPanel tlPanel=new JPanel(new GridBagLayout());
  tlPanel.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  JPanel trPanel=new JPanel(new GridBagLayout());
  trPanel.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  JPanel blPanel=new JPanel(new GridBagLayout());
  blPanel.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  JPanel brPanel=new JPanel(new GridBagLayout());
  brPanel.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  JPanel bPanel=new JPanel(new GridBagLayout());
  leftSplit=new JSplitPane(JSplitPane.VERTICAL_SPLIT,true,tlPanel,blPanel);
  rightSplit=new JSplitPane(JSplitPane.VERTICAL_SPLIT,true,trPanel,brPanel);
  topSplit=new JSplitPane(JSplitPane.HORIZONTAL_SPLIT,true,leftSplit,rightSplit);
  logSplit=new JSplitPane(JSplitPane.VERTICAL_SPLIT,true,topSplit,bPanel);
  panel=new JPanel(new GridBagLayout());
  scrollPane=new JScrollPane(panel,JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED,JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
  c=new GridBagConstraints();
  c.fill=GridBagConstraints.BOTH;
  c.weightx=1;
  c.weighty=1;
  trPanel.add(scrollPane,c);
  trPanel=panel;
  frame.add(logSplit,BorderLayout.CENTER);
  textLog=new JTextPane();
  textLog.setEditable(false);
  scrollPane=new JScrollPane(textLog,JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED,JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);
  c=new GridBagConstraints();
  c.gridx=0;
  c.gridy=0;
  c.fill=GridBagConstraints.BOTH;
  c.weightx=1;
  c.weighty=1;
  bPanel.add(scrollPane,c);
  textLog.getDocument().addDocumentListener(new DocumentAdapter(){
    @Override public void anyChange(    DocumentEvent e){
      int length=textLog.getDocument().getLength();
      textLog.select(length,length);
    }
  }
);
  progress=new JProgressBar(0,100);
  progress.setString(""String_Node_Str"");
  progress.setStringPainted(true);
  c=new GridBagConstraints();
  c.gridx=0;
  c.gridy=1;
  c.fill=GridBagConstraints.HORIZONTAL;
  bPanel.add(progress,c);
  logger=new DocumentLogger(LOGGER,textLog.getStyledDocument());
  LogManager.getLogManager().addLogger(logger);
  createLoggerPopupMenu();
  panel=new JPanel(new GridBagLayout());
  c=new GridBagConstraints();
  c.gridy=0;
  c.anchor=GridBagConstraints.WEST;
  tlPanel.add(panel,c);
  label=new JLabel(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=0;
  c.insets=new Insets(0,0,0,SPACING);
  panel.add(label,c);
  al=new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      datasetModeChanged();
    }
  }
;
  gdalRadio=new JRadioButton(""String_Node_Str"");
  gdalRadio.setSelected(true);
  datasetSelected=gdalRadio;
  c=new GridBagConstraints();
  c.gridx=1;
  panel.add(gdalRadio,c);
  gdalRadio.addActionListener(al);
  mapnikRadio=new JRadioButton(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=2;
  panel.add(mapnikRadio,c);
  mapnikRadio.addActionListener(al);
  bg=new ButtonGroup();
  bg.add(gdalRadio);
  bg.add(mapnikRadio);
  sep=new JSeparator(JSeparator.HORIZONTAL);
  c=new GridBagConstraints();
  c.gridy=1;
  c.fill=GridBagConstraints.HORIZONTAL;
  c.insets=new Insets(SPACING * 2,0,SPACING * 2,0);
  tlPanel.add(sep,c);
  dataModeCards=new JPanel(new CardLayout());
  c=new GridBagConstraints();
  c.gridy=2;
  c.fill=GridBagConstraints.BOTH;
  c.weighty=1;
  c.weightx=1;
  c.anchor=GridBagConstraints.NORTH;
  tlPanel.add(dataModeCards,c);
  JPanel gdalCard=new JPanel(new GridBagLayout());
  dataModeCards.add(gdalCard,gdalRadio.getText());
  JPanel mapnikCard=new JPanel(new GridBagLayout());
  dataModeCards.add(mapnikCard,mapnikRadio.getText());
  panel=new JPanel(new GridBagLayout());
  c=new GridBagConstraints();
  c.gridy=0;
  c.fill=GridBagConstraints.HORIZONTAL;
  gdalCard.add(panel,c);
  label=new JLabel(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=0;
  c.insets=new Insets(0,0,SPACING,SPACING);
  panel.add(label,c);
  gdalFileField=new JTextField();
  gdalFileField.setEnabled(false);
  c=new GridBagConstraints();
  c.gridx=1;
  c.fill=GridBagConstraints.HORIZONTAL;
  c.weightx=1;
  c.insets=new Insets(0,0,SPACING,0);
  panel.add(gdalFileField,c);
  browseGdalButton=new JButton(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=2;
  c.insets=new Insets(0,0,SPACING,0);
  panel.add(browseGdalButton,c);
  browseGdalButton.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      setupInputFile();
    }
  }
);
  infoText=new JTextArea();
  infoText.setBackground(label.getBackground());
  infoText.setEditable(false);
  Font font=Font.decode(null);
  infoText.setFont(font);
  scrollPane=new JScrollPane(infoText,JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED,JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);
  size=new Dimension(20,20);
  scrollPane.setMinimumSize(size);
  scrollPane.setPreferredSize(size);
  c=new GridBagConstraints();
  c.gridy=1;
  c.fill=GridBagConstraints.BOTH;
  c.weightx=1;
  c.weighty=1;
  gdalCard.add(scrollPane,c);
  panel=new JPanel(new GridBagLayout());
  c=new GridBagConstraints();
  c.gridy=0;
  c.fill=GridBagConstraints.HORIZONTAL;
  mapnikCard.add(panel,c);
  label=new JLabel(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=0;
  c.gridy=0;
  c.anchor=GridBagConstraints.EAST;
  c.insets=new Insets(0,0,SPACING,SPACING);
  panel.add(label,c);
  pythonBinaryField=new JTextField();
  pythonBinaryField.setEnabled(false);
  c=new GridBagConstraints();
  c.gridx=1;
  c.gridy=0;
  c.fill=GridBagConstraints.HORIZONTAL;
  c.weightx=1;
  c.insets=new Insets(0,0,SPACING,0);
  panel.add(pythonBinaryField,c);
  browsePythonBinaryButton=new JButton(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=2;
  c.gridy=0;
  c.insets=new Insets(0,0,SPACING,0);
  panel.add(browsePythonBinaryButton,c);
  browsePythonBinaryButton.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      setupPythonBinary();
    }
  }
);
  label=new JLabel(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=0;
  c.gridy=1;
  c.anchor=GridBagConstraints.EAST;
  c.insets=new Insets(0,0,SPACING,SPACING);
  panel.add(label,c);
  mapnikScriptField=new JTextField();
  mapnikScriptField.setEnabled(false);
  c=new GridBagConstraints();
  c.gridx=1;
  c.gridy=1;
  c.fill=GridBagConstraints.HORIZONTAL;
  c.weightx=1;
  c.insets=new Insets(0,0,SPACING,0);
  panel.add(mapnikScriptField,c);
  browseMapnikScriptButton=new JButton(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=2;
  c.gridy=1;
  c.insets=new Insets(0,0,SPACING,0);
  panel.add(browseMapnikScriptButton,c);
  browseMapnikScriptButton.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      setupMapnikScript();
    }
  }
);
  label=new JLabel(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=0;
  c.gridy=2;
  c.anchor=GridBagConstraints.EAST;
  c.insets=new Insets(0,0,0,SPACING);
  panel.add(label,c);
  mapnikFileField=new JTextField();
  mapnikFileField.setEnabled(false);
  c=new GridBagConstraints();
  c.gridx=1;
  c.gridy=2;
  c.fill=GridBagConstraints.HORIZONTAL;
  c.weightx=1;
  panel.add(mapnikFileField,c);
  browseMapnikButton=new JButton(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=2;
  c.gridy=2;
  panel.add(browseMapnikButton,c);
  browseMapnikButton.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      setupInputFile();
    }
  }
);
  sep=new JSeparator(JSeparator.HORIZONTAL);
  c=new GridBagConstraints();
  c.gridy=1;
  c.fill=GridBagConstraints.HORIZONTAL;
  c.insets=new Insets(SPACING * 2,0,SPACING * 2,0);
  mapnikCard.add(sep,c);
  panel=new JPanel(new GridBagLayout());
  c=new GridBagConstraints();
  c.gridy=2;
  c.anchor=GridBagConstraints.NORTH;
  c.fill=GridBagConstraints.HORIZONTAL;
  c.weightx=1;
  c.weighty=1;
  mapnikCard.add(panel,c);
  label=new JLabel(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=0;
  c.gridy=0;
  c.anchor=GridBagConstraints.EAST;
  c.insets=new Insets(0,0,SPACING,SPACING);
  panel.add(label,c);
  labels.add(label);
  minLatitudeField=new JDoubleField(-90d);
  c=new GridBagConstraints();
  c.gridx=1;
  c.gridy=0;
  c.weightx=0.5;
  c.fill=GridBagConstraints.HORIZONTAL;
  c.insets=new Insets(0,0,SPACING,SPACING);
  panel.add(minLatitudeField,c);
  label=new JLabel(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=2;
  c.gridy=0;
  c.anchor=GridBagConstraints.EAST;
  c.insets=new Insets(0,SPACING,SPACING,SPACING);
  panel.add(label,c);
  labels.add(label);
  minLongitudeField=new JDoubleField(-180d);
  c=new GridBagConstraints();
  c.gridx=3;
  c.gridy=0;
  c.weightx=0.5;
  c.fill=GridBagConstraints.HORIZONTAL;
  c.insets=new Insets(0,0,SPACING,0);
  panel.add(minLongitudeField,c);
  label=new JLabel(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=0;
  c.gridy=1;
  c.anchor=GridBagConstraints.EAST;
  c.insets=new Insets(0,0,SPACING,SPACING);
  panel.add(label,c);
  labels.add(label);
  maxLatitudeField=new JDoubleField(90d);
  c=new GridBagConstraints();
  c.gridx=1;
  c.gridy=1;
  c.fill=GridBagConstraints.HORIZONTAL;
  c.insets=new Insets(0,0,SPACING,SPACING);
  panel.add(maxLatitudeField,c);
  label=new JLabel(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=2;
  c.gridy=1;
  c.anchor=GridBagConstraints.EAST;
  c.insets=new Insets(0,SPACING,SPACING,SPACING);
  panel.add(label,c);
  labels.add(label);
  maxLongitudeField=new JDoubleField(180d);
  c=new GridBagConstraints();
  c.gridx=3;
  c.gridy=1;
  c.fill=GridBagConstraints.HORIZONTAL;
  c.insets=new Insets(0,0,SPACING,0);
  panel.add(maxLongitudeField,c);
  previewCanvas=new JLabel();
  previewCanvas.setHorizontalAlignment(SwingConstants.CENTER);
  scrollPane=new JScrollPane(previewCanvas,JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED,JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);
  previewCanvas.setBackground(Color.white);
  c=new GridBagConstraints();
  c.weightx=1;
  c.weighty=1;
  c.fill=GridBagConstraints.BOTH;
  c.anchor=GridBagConstraints.CENTER;
  blPanel.add(scrollPane,c);
  tileTypeLabel=new JLabel(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=0;
  c.gridy=0;
  c.anchor=GridBagConstraints.EAST;
  c.insets=new Insets(0,0,SPACING,SPACING);
  trPanel.add(tileTypeLabel,c);
  panel=new JPanel(new GridBagLayout());
  c=new GridBagConstraints();
  c.gridx=1;
  c.gridy=0;
  c.weightx=1;
  c.anchor=GridBagConstraints.WEST;
  c.insets=new Insets(0,0,SPACING,0);
  trPanel.add(panel,c);
  al=new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      tileTypeChanged();
    }
  }
;
  imageRadio=new JRadioButton(""String_Node_Str"");
  imageRadio.setSelected(true);
  c=new GridBagConstraints();
  c.gridx=0;
  panel.add(imageRadio,c);
  imageRadio.addActionListener(al);
  elevationRadio=new JRadioButton(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=1;
  panel.add(elevationRadio,c);
  elevationRadio.addActionListener(al);
  bg=new ButtonGroup();
  bg.add(imageRadio);
  bg.add(elevationRadio);
  label=new JLabel(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=0;
  c.gridy=1;
  c.anchor=GridBagConstraints.EAST;
  c.insets=new Insets(0,0,SPACING,SPACING);
  trPanel.add(label,c);
  labels.add(label);
  panel=new JPanel(new GridBagLayout());
  c=new GridBagConstraints();
  c.gridx=1;
  c.gridy=1;
  c.anchor=GridBagConstraints.WEST;
  c.insets=new Insets(0,0,SPACING,0);
  trPanel.add(panel,c);
  tilesizeField=new JIntegerField(512);
  tilesizeField.setPositive(true);
  c=new GridBagConstraints();
  c.gridx=0;
  size=tilesizeField.getPreferredSize();
  size.width=50;
  tilesizeField.setMinimumSize(size);
  tilesizeField.setMaximumSize(size);
  tilesizeField.setPreferredSize(size);
  panel.add(tilesizeField,c);
  tilesizeField.getDocument().addDocumentListener(new DocumentAdapter(){
    @Override public void anyChange(    DocumentEvent e){
      if (!tilesizeBeingSet) {
        tilesizeChanged=true;
      }
    }
  }
);
  tilesizeField.addFocusListener(new FocusAdapter(){
    @Override public void focusLost(    FocusEvent e){
      tilesizeChanged();
    }
  }
);
  label=new JLabel(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=1;
  c.insets=new Insets(0,SPACING / 2,0,0);
  panel.add(label,c);
  labels.add(label);
  label=new JLabel(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=0;
  c.gridy=2;
  c.anchor=GridBagConstraints.EAST;
  c.insets=new Insets(0,0,SPACING,SPACING);
  trPanel.add(label,c);
  labels.add(label);
  panel=new JPanel(new GridBagLayout());
  c=new GridBagConstraints();
  c.gridx=1;
  c.gridy=2;
  c.anchor=GridBagConstraints.WEST;
  c.insets=new Insets(0,0,SPACING,0);
  trPanel.add(panel,c);
  lztsField=new JDoubleField(36d);
  c=new GridBagConstraints();
  c.gridx=0;
  size=lztsField.getPreferredSize();
  size.width=50;
  lztsField.setMinimumSize(size);
  lztsField.setMaximumSize(size);
  lztsField.setPreferredSize(size);
  panel.add(lztsField,c);
  lztsField.getDocument().addDocumentListener(new DocumentAdapter(){
    @Override public void anyChange(    DocumentEvent e){
      if (!lztsBeingSet) {
        lztsChanged=true;
      }
    }
  }
);
  label=new JLabel(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=1;
  c.insets=new Insets(0,SPACING / 2,0,0);
  panel.add(label,c);
  labels.add(label);
  levelsLabel=new JLabel(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=0;
  c.gridy=3;
  c.anchor=GridBagConstraints.EAST;
  c.insets=new Insets(0,0,SPACING,SPACING);
  trPanel.add(levelsLabel,c);
  levelsSpinner=new JSpinner(new SpinnerNumberModel(5,1,100,1));
  c=new GridBagConstraints();
  c.gridx=1;
  c.gridy=3;
  c.anchor=GridBagConstraints.WEST;
  c.insets=new Insets(0,0,SPACING,0);
  trPanel.add(levelsSpinner,c);
  imageFormatLabel=new JLabel(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=0;
  c.gridy=4;
  c.anchor=GridBagConstraints.EAST;
  c.insets=new Insets(0,0,SPACING,SPACING);
  trPanel.add(imageFormatLabel,c);
  panel=new JPanel(new GridBagLayout());
  c=new GridBagConstraints();
  c.gridx=1;
  c.gridy=4;
  c.anchor=GridBagConstraints.WEST;
  c.insets=new Insets(0,0,SPACING,0);
  trPanel.add(panel,c);
  al=new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      imageFormatChanged();
    }
  }
;
  jpegRadio=new JRadioButton(""String_Node_Str"");
  jpegRadio.setSelected(true);
  c=new GridBagConstraints();
  c.gridx=0;
  panel.add(jpegRadio,c);
  jpegRadio.addActionListener(al);
  pngRadio=new JRadioButton(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=1;
  panel.add(pngRadio,c);
  pngRadio.addActionListener(al);
  bg=new ButtonGroup();
  bg.add(jpegRadio);
  bg.add(pngRadio);
  alphaCheck=new JCheckBox(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=0;
  c.gridy=5;
  c.anchor=GridBagConstraints.WEST;
  c.gridwidth=2;
  c.insets=new Insets(0,0,SPACING,0);
  trPanel.add(alphaCheck,c);
  alphaCheck.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      alphaSet=alphaCheck.isSelected();
      bandCountChanged();
    }
  }
);
  cellTypeLabel=new JLabel(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=0;
  c.gridy=6;
  c.anchor=GridBagConstraints.EAST;
  c.insets=new Insets(0,0,SPACING,SPACING);
  trPanel.add(cellTypeLabel,c);
  panel=new JPanel(new GridBagLayout());
  c=new GridBagConstraints();
  c.gridx=1;
  c.gridy=6;
  c.anchor=GridBagConstraints.WEST;
  c.insets=new Insets(0,0,SPACING,0);
  trPanel.add(panel,c);
  al=new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      elevationFormatChanged();
    }
  }
;
  byteRadio=new JRadioButton(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=0;
  panel.add(byteRadio,c);
  byteRadio.addActionListener(al);
  int16Radio=new JRadioButton(""String_Node_Str"");
  int16Radio.setSelected(true);
  c=new GridBagConstraints();
  c.gridx=1;
  panel.add(int16Radio,c);
  int16Radio.addActionListener(al);
  int32Radio=new JRadioButton(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=2;
  panel.add(int32Radio,c);
  int32Radio.addActionListener(al);
  float32Radio=new JRadioButton(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=3;
  panel.add(float32Radio,c);
  float32Radio.addActionListener(al);
  bg=new ButtonGroup();
  bg.add(byteRadio);
  bg.add(int16Radio);
  bg.add(int32Radio);
  bg.add(float32Radio);
  bandLabel=new JLabel(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=0;
  c.gridy=7;
  c.anchor=GridBagConstraints.EAST;
  c.insets=new Insets(0,0,SPACING,SPACING);
  trPanel.add(bandLabel,c);
  panel=new JPanel(new GridBagLayout());
  c=new GridBagConstraints();
  c.gridx=1;
  c.gridy=7;
  c.anchor=GridBagConstraints.WEST;
  c.insets=new Insets(0,0,SPACING,0);
  trPanel.add(panel,c);
  bandCombo=new JComboBox(new Integer[]{1});
  bandCombo.setSelectedIndex(0);
  c=new GridBagConstraints();
  c.gridx=0;
  panel.add(bandCombo,c);
  overviewsCheck=new JCheckBox(""String_Node_Str"");
  overviewsCheck.setSelected(true);
  c=new GridBagConstraints();
  c.gridx=0;
  c.gridy=8;
  c.gridwidth=2;
  c.anchor=GridBagConstraints.WEST;
  c.insets=new Insets(0,0,SPACING,0);
  trPanel.add(overviewsCheck,c);
  panel=new JPanel(new GridBagLayout());
  c=new GridBagConstraints();
  c.gridx=0;
  c.gridy=9;
  c.gridwidth=2;
  c.anchor=GridBagConstraints.WEST;
  trPanel.add(panel,c);
  overrideLevelsCheck=new JCheckBox(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=0;
  c.insets=new Insets(0,0,SPACING,SPACING);
  panel.add(overrideLevelsCheck,c);
  overrideLevelsCheck.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      if (mapnikRadio.isSelected() && !overrideLevelsCheck.isSelected()) {
        overrideLevelsCheck.setSelected(true);
      }
      enableFields();
    }
  }
);
  overrideLevelsSpinner=new JSpinner(new SpinnerNumberModel(1,1,100,1));
  c=new GridBagConstraints();
  c.gridx=1;
  c.insets=new Insets(0,0,SPACING,0);
  panel.add(overrideLevelsSpinner,c);
  outsideCheck=new JCheckBox(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=0;
  c.gridy=10;
  c.gridwidth=2;
  c.anchor=GridBagConstraints.WEST;
  trPanel.add(outsideCheck,c);
  outsideCheck.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      enableFields();
    }
  }
);
  outsidePanel=new JPanel(new GridBagLayout());
  c=new GridBagConstraints();
  c.gridx=1;
  c.gridy=11;
  c.anchor=GridBagConstraints.WEST;
  c.insets=new Insets(0,0,SPACING,0);
  trPanel.add(outsidePanel,c);
  replaceCheck=new JCheckBox(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=0;
  c.gridy=12;
  c.gridwidth=2;
  c.anchor=GridBagConstraints.WEST;
  trPanel.add(replaceCheck,c);
  replaceCheck.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      enableFields();
    }
  }
);
  replace1Label=new JLabel(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=0;
  c.gridy=13;
  c.anchor=GridBagConstraints.EAST;
  c.insets=new Insets(0,0,SPACING,SPACING);
  trPanel.add(replace1Label,c);
  minPanel=new JPanel(new GridBagLayout());
  c=new GridBagConstraints();
  c.gridx=1;
  c.gridy=13;
  c.anchor=GridBagConstraints.WEST;
  c.insets=new Insets(0,0,SPACING,0);
  trPanel.add(minPanel,c);
  replace2Label=new JLabel(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=0;
  c.gridy=14;
  c.anchor=GridBagConstraints.EAST;
  c.insets=new Insets(0,0,SPACING,SPACING);
  trPanel.add(replace2Label,c);
  maxPanel=new JPanel(new GridBagLayout());
  c=new GridBagConstraints();
  c.gridx=1;
  c.gridy=14;
  c.anchor=GridBagConstraints.WEST;
  c.insets=new Insets(0,0,SPACING,0);
  trPanel.add(maxPanel,c);
  replace3Label=new JLabel(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=0;
  c.gridy=15;
  c.anchor=GridBagConstraints.EAST;
  c.insets=new Insets(0,0,SPACING,SPACING);
  trPanel.add(replace3Label,c);
  min2Panel=new JPanel(new GridBagLayout());
  c=new GridBagConstraints();
  c.gridx=1;
  c.gridy=15;
  c.anchor=GridBagConstraints.WEST;
  c.insets=new Insets(0,0,SPACING,0);
  trPanel.add(min2Panel,c);
  replace4Label=new JLabel(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=0;
  c.gridy=16;
  c.anchor=GridBagConstraints.EAST;
  c.insets=new Insets(0,0,SPACING,SPACING);
  trPanel.add(replace4Label,c);
  max2Panel=new JPanel(new GridBagLayout());
  c=new GridBagConstraints();
  c.gridx=1;
  c.gridy=16;
  c.anchor=GridBagConstraints.WEST;
  c.insets=new Insets(0,0,SPACING,0);
  trPanel.add(max2Panel,c);
  replace5Label=new JLabel(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=0;
  c.gridy=17;
  c.anchor=GridBagConstraints.EAST;
  c.insets=new Insets(0,0,SPACING,SPACING);
  trPanel.add(replace5Label,c);
  withPanel=new JPanel(new GridBagLayout());
  c=new GridBagConstraints();
  c.gridx=1;
  c.gridy=17;
  c.anchor=GridBagConstraints.WEST;
  c.insets=new Insets(0,0,SPACING,0);
  trPanel.add(withPanel,c);
  replace6Label=new JLabel(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=0;
  c.gridy=18;
  c.anchor=GridBagConstraints.EAST;
  c.insets=new Insets(0,0,SPACING,SPACING);
  trPanel.add(replace6Label,c);
  otherwisePanel=new JPanel(new GridBagLayout());
  c=new GridBagConstraints();
  c.gridx=1;
  c.gridy=18;
  c.anchor=GridBagConstraints.WEST;
  c.insets=new Insets(0,0,SPACING,0);
  trPanel.add(otherwisePanel,c);
  panel=new JPanel(new GridBagLayout());
  c=new GridBagConstraints();
  c.gridx=0;
  c.gridy=19;
  c.weighty=1;
  trPanel.add(panel,c);
  panel=new JPanel(new GridBagLayout());
  c=new GridBagConstraints();
  c.gridx=0;
  c.gridy=0;
  c.fill=GridBagConstraints.HORIZONTAL;
  brPanel.add(panel,c);
  label=new JLabel(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=0;
  c.insets=new Insets(0,0,SPACING,SPACING);
  panel.add(label,c);
  outputDirectory=new JTextField();
  c=new GridBagConstraints();
  c.gridx=1;
  c.fill=GridBagConstraints.HORIZONTAL;
  c.weightx=1;
  c.insets=new Insets(0,0,SPACING,0);
  panel.add(outputDirectory,c);
  outputDirectory.getDocument().addDocumentListener(new DocumentAdapter(){
    @Override public void anyChange(    DocumentEvent e){
      String text=outputDirectory.getText();
      File dir=new File(text);
      if (dir.isDirectory()) {
        preferences.put(OUTPUT_DIR_KEY,text);
      }
    }
  }
);
  outputButton=new JButton(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=2;
  c.insets=new Insets(0,0,SPACING,0);
  panel.add(outputButton,c);
  outputButton.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      JFileChooser chooser=new JFileChooser(preferences.get(OUTPUT_DIR_KEY,null));
      chooser.setAcceptAllFileFilterUsed(false);
      chooser.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY);
      if (chooser.showOpenDialog(frame) == JFileChooser.APPROVE_OPTION) {
        File dir=chooser.getSelectedFile();
        outputDirectory.setText(dir.getAbsolutePath());
        preferences.put(OUTPUT_DIR_KEY,dir.getAbsolutePath());
      }
    }
  }
);
  tileText=new JTextArea();
  tileText.setBackground(label.getBackground());
  tileText.setEditable(false);
  tileText.setFont(font);
  scrollPane=new JScrollPane(tileText,JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED,JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);
  size=new Dimension(20,20);
  scrollPane.setMinimumSize(size);
  scrollPane.setPreferredSize(size);
  c=new GridBagConstraints();
  c.gridx=0;
  c.gridy=1;
  c.fill=GridBagConstraints.BOTH;
  c.weighty=1;
  c.weightx=1;
  c.anchor=GridBagConstraints.NORTH;
  c.insets=new Insets(0,0,SPACING,0);
  brPanel.add(scrollPane,c);
  panel=new JPanel(new GridBagLayout());
  c=new GridBagConstraints();
  c.gridx=0;
  c.gridy=2;
  brPanel.add(panel,c);
  tileButton=new JButton(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=0;
  c.insets=new Insets(0,0,0,SPACING);
  panel.add(tileButton,c);
  tileButton.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      generateTiles();
    }
  }
);
  cancelButton=new JButton(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=1;
  panel.add(cancelButton,c);
  cancelButton.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      cancel();
    }
  }
);
  JButton previewButton=new JButton(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=2;
  panel.add(previewButton,c);
  previewButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      preview();
    }
  }
);
  updatePythonFields();
  addRecalculateListeners();
  openDataset(null);
  datasetModeChanged();
  logger.info(""String_Node_Str"");
  if (!GDALUtil.isProjectionsSupported()) {
    logger.warning(""String_Node_Str"");
  }
  loadFrameBounds();
  loadSplitLocations();
  frame.setVisible(true);
}",0.999012603821804
11161,"private static void start() throws Exception {
  File dataDir=new File(""String_Node_Str"");
  File gdalDir=new File(""String_Node_Str"");
  if (!dataDir.exists()) {
    throw new FileNotFoundException(""String_Node_Str"" + dataDir.getAbsolutePath());
  }
  if (!gdalDir.exists()) {
    throw new FileNotFoundException(""String_Node_Str"" + gdalDir.getAbsolutePath());
  }
  Object libc=Native.loadLibrary(""String_Node_Str"",WinLibC.class);
  ((WinLibC)libc)._putenv(""String_Node_Str"" + dataDir.getAbsolutePath());
  String path=System.getenv(""String_Node_Str"");
  path=path + ""String_Node_Str"" + gdalDir.getAbsolutePath();
  ((WinLibC)libc)._putenv(""String_Node_Str"" + path);
  String newLibPath=gdalDir.getAbsolutePath() + File.pathSeparator + System.getProperty(""String_Node_Str"");
  System.setProperty(""String_Node_Str"",newLibPath);
  Field fieldSysPath=ClassLoader.class.getDeclaredField(""String_Node_Str"");
  if (fieldSysPath != null) {
    fieldSysPath.setAccessible(true);
    fieldSysPath.set(System.class.getClassLoader(),null);
  }
  Application.start();
}","private static void start() throws Exception {
  File dataDir=new File(""String_Node_Str"");
  File gdalDir=new File(""String_Node_Str"");
  if (!dataDir.exists()) {
    throw new FileNotFoundException(""String_Node_Str"" + dataDir.getAbsolutePath());
  }
  if (!gdalDir.exists()) {
    throw new FileNotFoundException(""String_Node_Str"" + gdalDir.getAbsolutePath());
  }
  Object libc=Native.loadLibrary(""String_Node_Str"",WinLibC.class);
  ((WinLibC)libc)._putenv(""String_Node_Str"" + dataDir.getAbsolutePath());
  String path=System.getenv(""String_Node_Str"");
  path=gdalDir.getAbsolutePath() + ""String_Node_Str"" + path;
  ((WinLibC)libc)._putenv(""String_Node_Str"" + path);
  String newLibPath=gdalDir.getAbsolutePath() + File.pathSeparator + System.getProperty(""String_Node_Str"");
  System.setProperty(""String_Node_Str"",newLibPath);
  Field fieldSysPath=ClassLoader.class.getDeclaredField(""String_Node_Str"");
  if (fieldSysPath != null) {
    fieldSysPath.setAccessible(true);
    fieldSysPath.set(System.class.getClassLoader(),null);
  }
  Application.start();
}",0.9725897920604916
11162,"protected void readDatasetReprojected(Dataset dataset,SpatialReference dstSR) throws GDALException, TilerException {
  Driver memDriver=gdal.GetDriverByName(""String_Node_Str"");
  Dataset dst=memDriver.Create(""String_Node_Str"",width,height);
  while (dst.getRasterCount() < dataset.getRasterCount())   dst.AddBand();
  double[] geoTransformArray=new double[6];
  geoTransformArray[0]=minLongitude;
  geoTransformArray[3]=maxLatitude;
  geoTransformArray[1]=(maxLongitude - minLongitude) / (double)width;
  geoTransformArray[5]=(minLatitude - maxLatitude) / (double)height;
  dst.SetGeoTransform(geoTransformArray);
  dst.SetProjection(dstSR.ExportToWkt());
  int returnVal=gdal.ReprojectImage(dataset,dst,null,null,gdalconst.GRA_NearestNeighbour);
  if (returnVal != gdalconstConstants.CE_None) {
    throw new GDALException();
  }
  readRectangle(dataset,null);
}","protected void readDatasetReprojected(Dataset dataset,SpatialReference dstSR) throws GDALException, TilerException {
  Driver memDriver=gdal.GetDriverByName(""String_Node_Str"");
  Dataset dst=memDriver.Create(""String_Node_Str"",width,height);
  while (dst.getRasterCount() < dataset.getRasterCount())   dst.AddBand();
  double[] geoTransformArray=new double[6];
  geoTransformArray[0]=minLongitude;
  geoTransformArray[3]=maxLatitude;
  geoTransformArray[1]=(maxLongitude - minLongitude) / (double)width;
  geoTransformArray[5]=(minLatitude - maxLatitude) / (double)height;
  dst.SetGeoTransform(geoTransformArray);
  dst.SetProjection(dstSR.ExportToWkt());
  int returnVal=gdal.ReprojectImage(dataset,dst,null,null,gdalconst.GRA_NearestNeighbour);
  if (returnVal != gdalconstConstants.CE_None) {
    throw new GDALException();
  }
  readRectangle(dst,null);
}",0.9965156794425089
11163,"private static ReplaceValues parseReplaceValues(Option option,String arg) throws IllegalOptionValueException {
  ReplaceValues replaceValues=new ReplaceValues();
  replaceValues.replaceMinMaxs=new MinMaxArray[2];
  String[] groups=arg.split(""String_Node_Str"");
  if (groups.length != 6)   throw new IllegalOptionValueException(option,arg);
  String[] min1=groups[0].split(""String_Node_Str"");
  String[] max1=groups[1].split(""String_Node_Str"");
  String[] min2=groups[2].split(""String_Node_Str"");
  String[] max2=groups[3].split(""String_Node_Str"");
  String[] replace=groups[4].split(""String_Node_Str"");
  String[] otherwise=groups[5].split(""String_Node_Str"");
  if (!(min1.length == max1.length && min1.length == min2.length && min1.length == max2.length && min1.length == replace.length && min1.length == otherwise.length))   throw new IllegalOptionValueException(option,arg);
  int length=min1.length;
  replaceValues.valueCount=length;
  replaceValues.replaceMinMaxs[0]=new MinMaxArray(length);
  replaceValues.replaceMinMaxs[1]=new MinMaxArray(length);
  replaceValues.replace=new NullableNumberArray(length);
  replaceValues.otherwise=new NullableNumberArray(length);
  try {
    Double[] min1D=stringsToDoubles(min1);
    Double[] max1D=stringsToDoubles(max1);
    Double[] min2D=stringsToDoubles(min2);
    Double[] max2D=stringsToDoubles(max2);
    Double[] replaceD=stringsToDoubles(replace);
    Double[] otherwiseD=stringsToDoubles(otherwise);
    replaceValues.replaceMinMaxs[0].setMinMaxDoubles(min1D,max1D);
    replaceValues.replaceMinMaxs[1].setMinMaxDoubles(min2D,max2D);
    replaceValues.replace.setDoubles(replaceD);
    replaceValues.otherwise.setDoubles(otherwiseD);
  }
 catch (  Exception e) {
    throw new IllegalOptionValueException(option,arg);
  }
  return replaceValues;
}","private static ReplaceValues parseReplaceValues(Option option,String arg) throws IllegalOptionValueException {
  ReplaceValues replaceValues=new ReplaceValues();
  replaceValues.replaceMinMaxs=new MinMaxArray[2];
  String[] groups=arg.split(""String_Node_Str"");
  if (groups.length != 6)   throw new IllegalOptionValueException(option,arg);
  for (int i=0; i < groups.length; i++)   groups[i]=groups[i] + ""String_Node_Str"";
  String[] min1=groups[0].split(""String_Node_Str"");
  String[] max1=groups[1].split(""String_Node_Str"");
  String[] min2=groups[2].split(""String_Node_Str"");
  String[] max2=groups[3].split(""String_Node_Str"");
  String[] replace=groups[4].split(""String_Node_Str"");
  String[] otherwise=groups[5].split(""String_Node_Str"");
  if (!(min1.length == max1.length && min1.length == min2.length && min1.length == max2.length && min1.length == replace.length && min1.length == otherwise.length))   throw new IllegalOptionValueException(option,arg);
  int length=min1.length;
  replaceValues.valueCount=length;
  replaceValues.replaceMinMaxs[0]=new MinMaxArray(length);
  replaceValues.replaceMinMaxs[1]=new MinMaxArray(length);
  replaceValues.replace=new NullableNumberArray(length);
  replaceValues.otherwise=new NullableNumberArray(length);
  try {
    Double[] min1D=stringsToDoubles(min1);
    Double[] max1D=stringsToDoubles(max1);
    Double[] min2D=stringsToDoubles(min2);
    Double[] max2D=stringsToDoubles(max2);
    Double[] replaceD=stringsToDoubles(replace);
    Double[] otherwiseD=stringsToDoubles(otherwise);
    replaceValues.replaceMinMaxs[0].setMinMaxDoubles(min1D,max1D);
    replaceValues.replaceMinMaxs[1].setMinMaxDoubles(min2D,max2D);
    replaceValues.replace.setDoubles(replaceD);
    replaceValues.otherwise.setDoubles(otherwiseD);
  }
 catch (  Exception e) {
    throw new IllegalOptionValueException(option,arg);
  }
  return replaceValues;
}",0.9254136154054788
11164,"private static Double[] stringsToDoubles(String[] s){
  Double[] d=new Double[s.length];
  for (int i=0; i < s.length; i++) {
    if (s.length == 0) {
      d[i]=null;
    }
 else {
      d[i]=Double.parseDouble(s[i]);
    }
  }
  return d;
}","private static Double[] stringsToDoubles(String[] s){
  Double[] d=new Double[s.length];
  for (int i=0; i < s.length; i++) {
    String t=s[i].trim();
    if (t.length() == 0) {
      d[i]=null;
    }
 else {
      d[i]=Double.parseDouble(t);
    }
  }
  return d;
}",0.8290766208251473
11165,"private static NullableNumberArray parseNumberArray(Option option,String arg) throws IllegalOptionValueException {
  try {
    String[] split=arg.split(""String_Node_Str"");
    Double[] d=stringsToDoubles(split);
    NullableNumberArray n=new NullableNumberArray(d.length);
    n.setDoubles(d);
    return n;
  }
 catch (  Exception e) {
    throw new IllegalOptionValueException(option,arg);
  }
}","private static NullableNumberArray parseNumberArray(Option option,String arg) throws IllegalOptionValueException {
  try {
    String[] split=(arg + ""String_Node_Str"").split(""String_Node_Str"");
    Double[] d=stringsToDoubles(split);
    NullableNumberArray n=new NullableNumberArray(d.length);
    n.setDoubles(d);
    return n;
  }
 catch (  Exception e) {
    throw new IllegalOptionValueException(option,arg);
  }
}",0.965686274509804
11166,"private BufferedImage loadImage(File file) throws IOException {
  if (!elevations)   return ImageIO.read(file);
 else {
    FileInputStream fis=null;
    ByteBuffer bb=ByteBuffer.allocate((int)file.length());
    bb.order(ByteOrder.LITTLE_ENDIAN);
    int length=bb.limit() / typeSize;
    try {
      fis=new FileInputStream(file);
      fis.getChannel().read(bb);
      bb.rewind();
    }
  finally {
      if (fis != null)       fis.close();
    }
    double min=Double.MAX_VALUE, max=-Double.MAX_VALUE;
    for (int i=0; i < width * height && i < length; i++) {
      double value=getBufferValue(bb);
      if (value == nodata)       continue;
      if (value < min)       min=value;
      if (value > max)       max=value;
    }
    if (max == min)     max=min + 1;
    int pixels=width * height;
    int[] offsets=new int[4];
    offsets[3]=pixels;
    bb.rewind();
    byte[] bytes=new byte[pixels * 2];
    for (int i=0; i < width * height && i < length; i++) {
      double value=getBufferValue(bb);
      bytes[i]=(byte)(255d * (value - min) / (max - min));
      bytes[i + pixels]=(byte)(value == nodata ? 0 : 255);
    }
    DataBuffer dataBuffer=new DataBufferByte(bytes,bytes.length);
    SampleModel sampleModel=new ComponentSampleModel(DataBuffer.TYPE_BYTE,width,height,1,width,offsets);
    WritableRaster raster=Raster.createWritableRaster(sampleModel,dataBuffer,null);
    BufferedImage image=new BufferedImage(width,height,BufferedImage.TYPE_INT_ARGB);
    image.setData(raster);
    return image;
  }
}","private BufferedImage loadImage(File file) throws IOException {
  if (!elevations)   return ImageIO.read(file);
 else {
    FileInputStream fis=null;
    ByteBuffer bb=ByteBuffer.allocate((int)file.length());
    bb.order(ByteOrder.LITTLE_ENDIAN);
    int length=bb.limit() / typeSize;
    try {
      fis=new FileInputStream(file);
      fis.getChannel().read(bb);
      bb.rewind();
    }
  finally {
      if (fis != null)       fis.close();
    }
    double min=Double.MAX_VALUE, max=-Double.MAX_VALUE;
    for (int i=0; i < width * height && i < length; i++) {
      double value=getBufferValue(bb);
      if (nodata != null && value == nodata)       continue;
      if (value < min)       min=value;
      if (value > max)       max=value;
    }
    if (max == min)     max=min + 1;
    int pixels=width * height;
    int[] offsets=new int[4];
    offsets[3]=pixels;
    bb.rewind();
    byte[] bytes=new byte[pixels * 2];
    for (int i=0; i < width * height && i < length; i++) {
      double value=getBufferValue(bb);
      bytes[i]=(byte)(255d * (value - min) / (max - min));
      bytes[i + pixels]=(byte)(nodata != null && value == nodata ? 0 : 255);
    }
    DataBuffer dataBuffer=new DataBufferByte(bytes,bytes.length);
    SampleModel sampleModel=new ComponentSampleModel(DataBuffer.TYPE_BYTE,width,height,1,width,offsets);
    WritableRaster raster=Raster.createWritableRaster(sampleModel,dataBuffer,null);
    BufferedImage image=new BufferedImage(width,height,BufferedImage.TYPE_INT_ARGB);
    image.setData(raster);
    return image;
  }
}",0.9883192731992212
11167,"@Override public void mousePressed(MouseEvent e){
  dragging=getListItemUnderMouse(e.getPoint());
}","@Override public void mousePressed(MouseEvent e){
  stopAnnotations();
  if (!playing) {
    wwd.getInputHandler().removeMouseListener(this);
  }
}",0.6097560975609756
11168,"private synchronized void playAnnotations(){
  if (!playing) {
    playing=true;
    final View view=wwd.getView();
    view.addPropertyChangeListener(AVKey.VIEW,new PropertyChangeListener(){
      public void propertyChange(      PropertyChangeEvent evt){
        if (!view.isAnimating()) {
          stopAnnotations();
        }
        if (!playing) {
          view.removePropertyChangeListener(AVKey.VIEW,this);
        }
      }
    }
);
    Thread thread=new Thread(new Runnable(){
      public void run(){
        ListItem item=(ListItem)list.getSelectedValue();
        List<Annotation> annotations=Settings.get().getAnnotations();
        int index=-1;
        if (item != null) {
          index=annotations.indexOf(item.annotation);
        }
 else         if (!annotations.isEmpty()) {
          index=0;
        }
        long jump=100;
        while (playing && index >= 0) {
          Annotation annotation=annotations.get(index);
          if (!annotation.isExcludeFromPlaylist()) {
            selectAnnotation(annotation);
            long length=flyToAnnotation(annotation);
            if (length < 0)             break;
            length+=Settings.get().getAnnotationsPause();
            for (; playing && length > jump; length-=jump) {
              sleep(jump);
            }
            if (playing)             sleep(length);
          }
          int nextIndex=index;
          while (true) {
            if (++nextIndex >= annotations.size())             nextIndex=0;
            if (nextIndex == index) {
              index=-1;
              break;
            }
            if (!annotations.get(nextIndex).isExcludeFromPlaylist()) {
              index=nextIndex;
              break;
            }
          }
        }
        stopAnnotations();
      }
      private void sleep(      long millis){
        try {
          Thread.sleep(millis);
        }
 catch (        InterruptedException e) {
          e.printStackTrace();
        }
      }
    }
);
    thread.setName(""String_Node_Str"");
    thread.setDaemon(true);
    thread.start();
  }
  playButton.setIcon(Icons.stop);
  playButton.setToolTipText(""String_Node_Str"");
  enableButtons();
}","private synchronized void playAnnotations(){
  if (!playing) {
    playing=true;
    wwd.getInputHandler().addMouseListener(new MouseAdapter(){
      @Override public void mousePressed(      MouseEvent e){
        stopAnnotations();
        if (!playing) {
          wwd.getInputHandler().removeMouseListener(this);
        }
      }
    }
);
    Thread thread=new Thread(new Runnable(){
      public void run(){
        ListItem item=(ListItem)list.getSelectedValue();
        List<Annotation> annotations=Settings.get().getAnnotations();
        int index=-1;
        if (item != null) {
          index=annotations.indexOf(item.annotation);
        }
 else         if (!annotations.isEmpty()) {
          index=0;
        }
        long jump=100;
        while (playing && index >= 0) {
          Annotation annotation=annotations.get(index);
          if (!annotation.isExcludeFromPlaylist()) {
            selectAnnotation(annotation);
            long length=flyToAnnotation(annotation);
            if (length < 0)             break;
            length+=Settings.get().getAnnotationsPause();
            for (; playing && length > jump; length-=jump) {
              sleep(jump);
            }
            if (playing)             sleep(length);
          }
          int nextIndex=index;
          while (true) {
            if (++nextIndex >= annotations.size())             nextIndex=0;
            if (nextIndex == index) {
              index=-1;
              break;
            }
            if (!annotations.get(nextIndex).isExcludeFromPlaylist()) {
              index=nextIndex;
              break;
            }
          }
        }
        stopAnnotations();
      }
      private void sleep(      long millis){
        try {
          Thread.sleep(millis);
        }
 catch (        InterruptedException e) {
          e.printStackTrace();
        }
      }
    }
);
    thread.setName(""String_Node_Str"");
    thread.setDaemon(true);
    thread.start();
  }
  playButton.setIcon(Icons.stop);
  playButton.setToolTipText(""String_Node_Str"");
  enableButtons();
}",0.8858147713950763
11169,"private long flyToAnnotation(Annotation annotation){
  View view=wwd.getView();
  if (view instanceof OrbitView) {
    OrbitView orbitView=(OrbitView)view;
    Position center=orbitView.getCenterPosition();
    Position newCenter=Position.fromDegrees(annotation.getLatitude(),annotation.getLongitude(),0);
    long lengthMillis=Util.getScaledLengthMillis(center,newCenter);
    Angle heading=orbitView.getHeading();
    Angle pitch=orbitView.getPitch();
    double zoom=orbitView.getZoom();
    if (annotation.isSaveCamera()) {
      zoom=annotation.getZoom();
      heading=Angle.fromDegrees(annotation.getHeading());
      pitch=Angle.fromDegrees(annotation.getPitch());
    }
 else {
      double minZoom=annotation.getMinZoom();
      double maxZoom=annotation.getMaxZoom();
      if (minZoom >= 0 && zoom > minZoom)       zoom=Math.max(minZoom,1000);
 else       if (maxZoom >= 0 && zoom < maxZoom)       zoom=maxZoom;
    }
    view.addAnimator(FlyToOrbitViewAnimator.createFlyToOrbitViewAnimator(orbitView,center,newCenter,orbitView.getHeading(),heading,orbitView.getPitch(),pitch,orbitView.getZoom(),zoom,lengthMillis,true));
    return lengthMillis;
  }
  return -1;
}","private long flyToAnnotation(Annotation annotation){
  View view=wwd.getView();
  if (view instanceof OrbitView) {
    OrbitView orbitView=(OrbitView)view;
    Position center=orbitView.getCenterPosition();
    Position newCenter=Position.fromDegrees(annotation.getLatitude(),annotation.getLongitude(),0);
    long lengthMillis=Util.getScaledLengthMillis(center,newCenter);
    Angle heading=orbitView.getHeading();
    Angle pitch=orbitView.getPitch();
    double zoom=orbitView.getZoom();
    if (annotation.isSaveCamera()) {
      zoom=annotation.getZoom();
      heading=Angle.fromDegrees(annotation.getHeading());
      pitch=Angle.fromDegrees(annotation.getPitch());
    }
 else {
      double minZoom=annotation.getMinZoom();
      double maxZoom=annotation.getMaxZoom();
      if (minZoom >= 0 && zoom > minZoom)       zoom=Math.max(minZoom,1000);
 else       if (maxZoom >= 0 && zoom < maxZoom)       zoom=maxZoom;
    }
    view.addAnimator(FlyToOrbitViewAnimator.createFlyToOrbitViewAnimator(orbitView,center,newCenter,orbitView.getHeading(),heading,orbitView.getPitch(),pitch,orbitView.getZoom(),zoom,lengthMillis,true));
    wwd.redraw();
    return lengthMillis;
  }
  return -1;
}",0.9924114671163576
11170,"private void updateBookmarksMenu(){
  while (bookmarksMenu.getMenuComponentCount() > 3) {
    bookmarksMenu.remove(3);
  }
  for (  final Bookmark bookmark : Bookmarks.iterable()) {
    JMenuItem mi=new JMenuItem(bookmark.getName());
    bookmarksMenu.add(mi);
    mi.addActionListener(new ActionListener(){
      public void actionPerformed(      ActionEvent e){
        View view=wwd.getView();
        if (view instanceof OrbitView) {
          OrbitView orbitView=(OrbitView)view;
          Position center=orbitView.getCenterPosition();
          Position newCenter=Position.fromDegrees(bookmark.getLat(),bookmark.getLon(),bookmark.getElevation());
          long lengthMillis=Util.getScaledLengthMillis(center,newCenter);
          orbitView.addAnimator(FlyToOrbitViewAnimator.createFlyToOrbitViewAnimator(orbitView,center,newCenter,orbitView.getHeading(),Angle.fromDegrees(bookmark.getHeading()),orbitView.getPitch(),Angle.fromDegrees(bookmark.getPitch()),orbitView.getZoom(),bookmark.getZoom(),lengthMillis,true));
        }
      }
    }
);
  }
}","private void updateBookmarksMenu(){
  while (bookmarksMenu.getMenuComponentCount() > 3) {
    bookmarksMenu.remove(3);
  }
  for (  final Bookmark bookmark : Bookmarks.iterable()) {
    JMenuItem mi=new JMenuItem(bookmark.getName());
    bookmarksMenu.add(mi);
    mi.addActionListener(new ActionListener(){
      public void actionPerformed(      ActionEvent e){
        View view=wwd.getView();
        if (view instanceof OrbitView) {
          OrbitView orbitView=(OrbitView)view;
          Position center=orbitView.getCenterPosition();
          Position newCenter=Position.fromDegrees(bookmark.getLat(),bookmark.getLon(),bookmark.getElevation());
          long lengthMillis=Util.getScaledLengthMillis(center,newCenter);
          orbitView.addAnimator(FlyToOrbitViewAnimator.createFlyToOrbitViewAnimator(orbitView,center,newCenter,orbitView.getHeading(),Angle.fromDegrees(bookmark.getHeading()),orbitView.getPitch(),Angle.fromDegrees(bookmark.getPitch()),orbitView.getZoom(),bookmark.getZoom(),lengthMillis,true));
          wwd.redraw();
        }
      }
    }
);
  }
}",0.9887535145267105
11171,"public void actionPerformed(ActionEvent e){
  View view=wwd.getView();
  if (view instanceof OrbitView) {
    OrbitView orbitView=(OrbitView)view;
    Position center=orbitView.getCenterPosition();
    Position newCenter=Position.fromDegrees(bookmark.getLat(),bookmark.getLon(),bookmark.getElevation());
    long lengthMillis=Util.getScaledLengthMillis(center,newCenter);
    orbitView.addAnimator(FlyToOrbitViewAnimator.createFlyToOrbitViewAnimator(orbitView,center,newCenter,orbitView.getHeading(),Angle.fromDegrees(bookmark.getHeading()),orbitView.getPitch(),Angle.fromDegrees(bookmark.getPitch()),orbitView.getZoom(),bookmark.getZoom(),lengthMillis,true));
  }
}","public void actionPerformed(ActionEvent e){
  View view=wwd.getView();
  if (view instanceof OrbitView) {
    OrbitView orbitView=(OrbitView)view;
    Position center=orbitView.getCenterPosition();
    Position newCenter=Position.fromDegrees(bookmark.getLat(),bookmark.getLon(),bookmark.getElevation());
    long lengthMillis=Util.getScaledLengthMillis(center,newCenter);
    orbitView.addAnimator(FlyToOrbitViewAnimator.createFlyToOrbitViewAnimator(orbitView,center,newCenter,orbitView.getHeading(),Angle.fromDegrees(bookmark.getHeading()),orbitView.getPitch(),Angle.fromDegrees(bookmark.getPitch()),orbitView.getZoom(),bookmark.getZoom(),lengthMillis,true));
    wwd.redraw();
  }
}",0.9866666666666668
11172,"private void createDoubleClickListener(){
  wwd.addMouseListener(new DoubleClickZoomListener(wwd,5000d));
}","private void createDoubleClickListener(){
  wwd.getInputHandler().addMouseListener(new DoubleClickZoomListener(wwd,5000d));
}",0.9224137931034484
11173,"private void resetView(){
  if (!(wwd.getView() instanceof OrbitView))   return;
  OrbitView view=(OrbitView)wwd.getView();
  Position beginCenter=view.getCenterPosition();
  Double initLat=Configuration.getDoubleValue(AVKey.INITIAL_LATITUDE);
  Double initLon=Configuration.getDoubleValue(AVKey.INITIAL_LONGITUDE);
  Double initAltitude=Configuration.getDoubleValue(AVKey.INITIAL_ALTITUDE);
  Double initHeading=Configuration.getDoubleValue(AVKey.INITIAL_HEADING);
  Double initPitch=Configuration.getDoubleValue(AVKey.INITIAL_PITCH);
  if (initLat == null)   initLat=0d;
  if (initLon == null)   initLon=0d;
  if (initAltitude == null)   initAltitude=3d * Earth.WGS84_EQUATORIAL_RADIUS;
  if (initHeading == null)   initHeading=0d;
  if (initPitch == null)   initPitch=0d;
  Position endCenter=Position.fromDegrees(initLat,initLon,beginCenter.getElevation());
  long lengthMillis=Util.getScaledLengthMillis(beginCenter,endCenter);
  view.addAnimator(FlyToOrbitViewAnimator.createFlyToOrbitViewAnimator(view,beginCenter,endCenter,view.getHeading(),Angle.fromDegrees(initHeading),view.getPitch(),Angle.fromDegrees(initPitch),view.getZoom(),initAltitude,lengthMillis,true));
}","private void resetView(){
  if (!(wwd.getView() instanceof OrbitView))   return;
  OrbitView view=(OrbitView)wwd.getView();
  Position beginCenter=view.getCenterPosition();
  Double initLat=Configuration.getDoubleValue(AVKey.INITIAL_LATITUDE);
  Double initLon=Configuration.getDoubleValue(AVKey.INITIAL_LONGITUDE);
  Double initAltitude=Configuration.getDoubleValue(AVKey.INITIAL_ALTITUDE);
  Double initHeading=Configuration.getDoubleValue(AVKey.INITIAL_HEADING);
  Double initPitch=Configuration.getDoubleValue(AVKey.INITIAL_PITCH);
  if (initLat == null)   initLat=0d;
  if (initLon == null)   initLon=0d;
  if (initAltitude == null)   initAltitude=3d * Earth.WGS84_EQUATORIAL_RADIUS;
  if (initHeading == null)   initHeading=0d;
  if (initPitch == null)   initPitch=0d;
  Position endCenter=Position.fromDegrees(initLat,initLon,beginCenter.getElevation());
  long lengthMillis=Util.getScaledLengthMillis(beginCenter,endCenter);
  view.addAnimator(FlyToOrbitViewAnimator.createFlyToOrbitViewAnimator(view,beginCenter,endCenter,view.getHeading(),Angle.fromDegrees(initHeading),view.getPitch(),Angle.fromDegrees(initPitch),view.getZoom(),initAltitude,lengthMillis,true));
  wwd.redraw();
}",0.99323753169907
11174,"private Application(){
  frame=new JFrame(""String_Node_Str"");
  final SplashScreen splashScreen=new SplashScreen(frame);
  try {
    frame.setIconImage(new ImageIcon(Application.class.getResource(""String_Node_Str"")).getImage());
  }
 catch (  Exception e) {
  }
  if (Settings.get().isHardwareStereoEnabled())   wwd=new WorldWindowStereoGLCanvas(WorldWindowStereoGLCanvas.stereoCaps);
 else   wwd=new WorldWindowStereoGLCanvas(WorldWindowStereoGLCanvas.defaultCaps);
  Model model=new BasicModel();
  wwd.setModel(model);
  wwd.addSelectListener(new ClickAndGoSelectListener(wwd,WorldMapLayer.class));
  create3DMouse();
  createDoubleClickListener();
  CameraSmoothHack.hackCameraSmoothing(wwd.getInputHandler());
  wwd.addRenderingListener(new RenderingListener(){
    public void stageChanged(    RenderingEvent event){
      if (event.getStage() == RenderingEvent.BEFORE_BUFFER_SWAP) {
        splashScreen.dispose();
        wwd.removeRenderingListener(this);
      }
    }
  }
);
  RetrievalService rs=WorldWind.getRetrievalService();
  if (rs instanceof ExtendedRetrievalService) {
    model.getLayers().add(((ExtendedRetrievalService)rs).getLayer());
  }
  map=new WorldMapLayer();
  scalebar=new ScalebarLayer();
  compass=new CompassLayer();
  logo=GALayer.getLogoLayer();
  model.getLayers().add(map);
  model.getLayers().add(scalebar);
  model.getLayers().add(compass);
  model.getLayers().add(logo);
  ToolTipManager.sharedInstance().setLightWeightPopupEnabled(false);
  JPopupMenu.setDefaultLightWeightPopupEnabled(false);
  frame.setLayout(new BorderLayout());
  frame.setBounds(Settings.get().getWindowBounds());
  if (Settings.get().isWindowMaximized()) {
    frame.setExtendedState(JFrame.MAXIMIZED_BOTH);
  }
  JPanel panel=new JPanel(new BorderLayout());
  frame.setContentPane(panel);
  splitPane=new JSplitPane(JSplitPane.HORIZONTAL_SPLIT,true);
  panel.add(splitPane,BorderLayout.CENTER);
  splitPane.setRightComponent(wwd);
  splitPane.setOneTouchExpandable(true);
  wwd.setMinimumSize(new Dimension(1,1));
  statusBar=new StatusBar();
  panel.add(statusBar,BorderLayout.PAGE_END);
  statusBar.setEventSource(wwd);
  statusBar.setBorder(BorderFactory.createLoweredBevelBorder());
  layersPanel=new LayersPanel(wwd,frame);
  splitPane.setLeftComponent(layersPanel);
  loadSplitLocations();
  afterSettingsChange();
  createDialogs();
  if (LOCAL_LAYERS_ENABLED) {
    LocalLayers.init(wwd);
    layersPanel.updateLocalLayers();
    LocalLayers.get().addChangeListener(new ChangeListener(){
      public void stateChanged(      ChangeEvent e){
        layersPanel.updateLocalLayers();
      }
    }
);
  }
  frame.setJMenuBar(createMenuBar());
  addWindowListeners();
  try {
    java.awt.EventQueue.invokeAndWait(new Runnable(){
      public void run(){
        frame.setVisible(true);
      }
    }
);
  }
 catch (  Exception e) {
  }
}","private Application(){
  frame=new JFrame(""String_Node_Str"");
  final SplashScreen splashScreen=new SplashScreen(frame);
  try {
    frame.setIconImage(new ImageIcon(Application.class.getResource(""String_Node_Str"")).getImage());
  }
 catch (  Exception e) {
  }
  if (Settings.get().isHardwareStereoEnabled())   wwd=new WorldWindowStereoGLCanvas(WorldWindowStereoGLCanvas.stereoCaps);
 else   wwd=new WorldWindowStereoGLCanvas(WorldWindowStereoGLCanvas.defaultCaps);
  Model model=new BasicModel();
  wwd.setModel(model);
  wwd.addSelectListener(new ClickAndGoSelectListener(wwd,WorldMapLayer.class));
  create3DMouse();
  createDoubleClickListener();
  wwd.addRenderingListener(new RenderingListener(){
    public void stageChanged(    RenderingEvent event){
      if (event.getStage() == RenderingEvent.BEFORE_BUFFER_SWAP) {
        splashScreen.dispose();
        wwd.removeRenderingListener(this);
      }
    }
  }
);
  RetrievalService rs=WorldWind.getRetrievalService();
  if (rs instanceof ExtendedRetrievalService) {
    model.getLayers().add(((ExtendedRetrievalService)rs).getLayer());
  }
  map=new WorldMapLayer();
  scalebar=new ScalebarLayer();
  compass=new CompassLayer();
  logo=GALayer.getLogoLayer();
  model.getLayers().add(map);
  model.getLayers().add(scalebar);
  model.getLayers().add(compass);
  model.getLayers().add(logo);
  ToolTipManager.sharedInstance().setLightWeightPopupEnabled(false);
  JPopupMenu.setDefaultLightWeightPopupEnabled(false);
  frame.setLayout(new BorderLayout());
  frame.setBounds(Settings.get().getWindowBounds());
  if (Settings.get().isWindowMaximized()) {
    frame.setExtendedState(JFrame.MAXIMIZED_BOTH);
  }
  JPanel panel=new JPanel(new BorderLayout());
  frame.setContentPane(panel);
  splitPane=new JSplitPane(JSplitPane.HORIZONTAL_SPLIT,true);
  panel.add(splitPane,BorderLayout.CENTER);
  splitPane.setRightComponent(wwd);
  splitPane.setOneTouchExpandable(true);
  wwd.setMinimumSize(new Dimension(1,1));
  statusBar=new StatusBar();
  panel.add(statusBar,BorderLayout.PAGE_END);
  statusBar.setEventSource(wwd);
  statusBar.setBorder(BorderFactory.createLoweredBevelBorder());
  layersPanel=new LayersPanel(wwd,frame);
  splitPane.setLeftComponent(layersPanel);
  loadSplitLocations();
  afterSettingsChange();
  createDialogs();
  if (LOCAL_LAYERS_ENABLED) {
    LocalLayers.init(wwd);
    layersPanel.updateLocalLayers();
    LocalLayers.get().addChangeListener(new ChangeListener(){
      public void stateChanged(      ChangeEvent e){
        layersPanel.updateLocalLayers();
      }
    }
);
  }
  frame.setJMenuBar(createMenuBar());
  addWindowListeners();
  try {
    java.awt.EventQueue.invokeAndWait(new Runnable(){
      public void run(){
        frame.setVisible(true);
      }
    }
);
  }
 catch (  Exception e) {
  }
}",0.9888633551352308
11175,"@Override protected String makeEyeAltitudeDescription(double metersAltitude){
  String s;
  if (UNIT_IMPERIAL.equals(getElevationUnit()))   return super.makeEyeAltitudeDescription(metersAltitude);
 else {
    if (metersAltitude < 1e4)     s=String.format(""String_Node_Str"",(int)Math.round(metersAltitude));
 else     s=String.format(""String_Node_Str"",(int)Math.round(metersAltitude / 1e3));
  }
  return s;
}","@Override protected String makeEyeAltitudeDescription(double metersAltitude){
  String s;
  String altitude=Logging.getMessage(""String_Node_Str"");
  if (UNIT_IMPERIAL.equals(getElevationUnit()))   return super.makeEyeAltitudeDescription(metersAltitude);
 else {
    if (metersAltitude < 1e4)     s=String.format(altitude + ""String_Node_Str"",(int)Math.round(metersAltitude));
 else     s=String.format(altitude + ""String_Node_Str"",(int)Math.round(metersAltitude / 1e3));
  }
  return s;
}",0.911731843575419
11176,"public long applyStateIterator(WorldWindow wwd){
  if (!(wwd.getView() instanceof OrbitView))   return 0;
  OrbitView view=(OrbitView)wwd.getView();
  Position beginCenter=view.getCenterPosition();
  long lengthMillis=Util.getScaledLengthMillis(beginCenter,center);
  view.addAnimator(FlyToOrbitViewAnimator.createFlyToOrbitViewAnimator(view,beginCenter,new Position(center,0),view.getHeading(),Angle.ZERO,view.getPitch(),Angle.ZERO,view.getZoom(),zoom,lengthMillis,true));
  return lengthMillis;
}","public long applyStateIterator(WorldWindow wwd){
  if (!(wwd.getView() instanceof OrbitView))   return 0;
  OrbitView view=(OrbitView)wwd.getView();
  Position beginCenter=view.getCenterPosition();
  long lengthMillis=Util.getScaledLengthMillis(beginCenter,center);
  view.addAnimator(FlyToOrbitViewAnimator.createFlyToOrbitViewAnimator(view,beginCenter,new Position(center,0),view.getHeading(),Angle.ZERO,view.getPitch(),Angle.ZERO,view.getZoom(),zoom,lengthMillis,true));
  wwd.redraw();
  return lengthMillis;
}",0.984189723320158
11177,"protected GDALTile(GDALTile tile,ByteBuffer buffer,int bufferType,int bufferTypeSize){
  this.buffer=buffer;
  this.bufferType=bufferType;
  this.bufferTypeSize=bufferTypeSize;
  this.width=tile.width;
  this.height=tile.height;
  this.minLatitude=tile.minLatitude;
  this.minLongitude=tile.minLongitude;
  this.maxLatitude=tile.maxLatitude;
  this.maxLongitude=tile.maxLongitude;
  this.addAlpha=tile.addAlpha;
  this.selectedBand=tile.selectedBand;
  this.dataRectangle=tile.dataRectangle;
  this.bufferBandCount=tile.bufferBandCount;
  this.indexed=tile.indexed;
  this.indexColorModel=tile.indexColorModel;
}","protected GDALTile(GDALTile tile,ByteBuffer buffer,int bufferType,int bufferTypeSize,boolean floatingPoint){
  this.buffer=buffer;
  this.bufferType=bufferType;
  this.bufferTypeSize=bufferTypeSize;
  this.floatingPoint=floatingPoint;
  this.width=tile.width;
  this.height=tile.height;
  this.minLatitude=tile.minLatitude;
  this.minLongitude=tile.minLongitude;
  this.maxLatitude=tile.maxLatitude;
  this.maxLongitude=tile.maxLongitude;
  this.addAlpha=tile.addAlpha;
  this.selectedBand=tile.selectedBand;
  this.dataRectangle=tile.dataRectangle;
  this.bufferBandCount=tile.bufferBandCount;
  this.indexed=tile.indexed;
  this.indexColorModel=tile.indexColorModel;
}",0.9547581903276132
11178,"public void fillOutside(int[] values) throws TilerException {
  if (values.length != bufferBandCount)   throw new IllegalArgumentException(""String_Node_Str"");
  if (dataRectangle.x == 0 && dataRectangle.y == 0 && dataRectangle.width == width && dataRectangle.height == height)   return;
  for (int x=0; x < width; x++) {
    for (int y=0; y < height; y++) {
      if (!dataRectangle.contains(x,y)) {
        for (int b=0; b < bufferBandCount; b++) {
          int index=getBufferIndex(x,y,b) * bufferTypeSize;
          if (bufferType == gdalconstConstants.GDT_Byte) {
            buffer.put(index,(byte)values[b]);
          }
 else           if (bufferType == gdalconstConstants.GDT_Int16 || bufferType == gdalconstConstants.GDT_UInt16) {
            buffer.putShort(index,(short)values[b]);
          }
 else           if (bufferType == gdalconstConstants.GDT_Int32 || bufferType == gdalconstConstants.GDT_UInt32) {
            buffer.putInt(index,values[b]);
          }
 else {
            throw new TilerException(""String_Node_Str"");
          }
        }
      }
    }
  }
}","public void fillOutside(NumberArray values) throws TilerException {
  if (values.length() != bufferBandCount)   throw new IllegalArgumentException(""String_Node_Str"");
  if (dataRectangle.x == 0 && dataRectangle.y == 0 && dataRectangle.width == width && dataRectangle.height == height)   return;
  for (int x=0; x < width; x++) {
    for (int y=0; y < height; y++) {
      if (!dataRectangle.contains(x,y)) {
        for (int b=0; b < bufferBandCount; b++) {
          int index=getBufferIndex(x,y,b) * bufferTypeSize;
          if (floatingPoint)           putDoubleValue(index,buffer,bufferType,values.getDouble(b));
 else           putLongValue(index,buffer,bufferType,values.getLong(b));
        }
      }
    }
  }
}",0.6329816768461966
11179,"public BufferedImage getAsImage() throws TilerException {
  int pixels=width * height;
  int[] offsets=new int[bufferBandCount];
  for (int b=0; b < bufferBandCount; b++) {
    offsets[b]=b * pixels;
  }
  DataBuffer imgBuffer=null;
  int imageType=0, dataType=0;
  if (bufferType == gdalconstConstants.GDT_Byte) {
    byte[] bytes=new byte[pixels * bufferBandCount];
    buffer.get(bytes);
    imgBuffer=new DataBufferByte(bytes,bytes.length);
    dataType=DataBuffer.TYPE_BYTE;
    imageType=indexed ? BufferedImage.TYPE_BYTE_INDEXED : BufferedImage.TYPE_BYTE_GRAY;
  }
 else   if (bufferType == gdalconstConstants.GDT_Int16 || bufferType == gdalconstConstants.GDT_UInt16) {
    short[] shorts=new short[pixels * bufferBandCount];
    buffer.asShortBuffer().get(shorts);
    imgBuffer=new DataBufferShort(shorts,shorts.length);
    dataType=DataBuffer.TYPE_USHORT;
    imageType=BufferedImage.TYPE_USHORT_GRAY;
  }
 else   if (bufferType == gdalconstConstants.GDT_Int32 || bufferType == gdalconstConstants.GDT_UInt32) {
    int[] ints=new int[pixels * bufferBandCount];
    buffer.asIntBuffer().get(ints);
    imgBuffer=new DataBufferInt(ints,ints.length);
    dataType=DataBuffer.TYPE_INT;
    imageType=BufferedImage.TYPE_CUSTOM;
  }
 else {
    throw new TilerException(""String_Node_Str"");
  }
  SampleModel sampleModel=new ComponentSampleModel(dataType,width,height,1,width,offsets);
  WritableRaster raster=Raster.createWritableRaster(sampleModel,imgBuffer,null);
  BufferedImage img=null;
  if (bufferBandCount == 4) {
    imageType=BufferedImage.TYPE_INT_ARGB_PRE;
  }
 else   if (bufferBandCount == 3) {
    imageType=BufferedImage.TYPE_INT_RGB;
  }
 else   if (indexed && bufferBandCount == 1) {
  }
 else {
  }
  img=(indexColorModel == null) ? new BufferedImage(width,height,imageType) : new BufferedImage(width,height,imageType,indexColorModel);
  img.setData(raster);
  return img;
}","public BufferedImage getAsImage() throws TilerException {
  int pixels=width * height;
  int[] offsets=new int[bufferBandCount];
  for (int b=0; b < bufferBandCount; b++) {
    offsets[b]=b * pixels;
  }
  DataBuffer imgBuffer=null;
  int imageType=0, dataType=0;
  if (bufferType == gdalconstConstants.GDT_Byte) {
    byte[] bytes=new byte[pixels * bufferBandCount];
    buffer.get(bytes);
    imgBuffer=new DataBufferByte(bytes,bytes.length);
    dataType=DataBuffer.TYPE_BYTE;
    imageType=indexed ? BufferedImage.TYPE_BYTE_INDEXED : BufferedImage.TYPE_BYTE_GRAY;
  }
 else   if (bufferType == gdalconstConstants.GDT_Int16 || bufferType == gdalconstConstants.GDT_UInt16) {
    short[] shorts=new short[pixels * bufferBandCount];
    buffer.asShortBuffer().get(shorts);
    imgBuffer=new DataBufferShort(shorts,shorts.length);
    dataType=bufferType == gdalconstConstants.GDT_UInt16 ? DataBuffer.TYPE_USHORT : DataBuffer.TYPE_SHORT;
    imageType=BufferedImage.TYPE_USHORT_GRAY;
  }
 else   if (bufferType == gdalconstConstants.GDT_Int32 || bufferType == gdalconstConstants.GDT_UInt32) {
    int[] ints=new int[pixels * bufferBandCount];
    buffer.asIntBuffer().get(ints);
    imgBuffer=new DataBufferInt(ints,ints.length);
    dataType=DataBuffer.TYPE_INT;
    imageType=BufferedImage.TYPE_CUSTOM;
  }
 else {
    throw new TilerException(""String_Node_Str"");
  }
  SampleModel sampleModel=new ComponentSampleModel(dataType,width,height,1,width,offsets);
  WritableRaster raster=Raster.createWritableRaster(sampleModel,imgBuffer,null);
  BufferedImage img=null;
  if (bufferBandCount == 4) {
    imageType=BufferedImage.TYPE_INT_ARGB_PRE;
  }
 else   if (bufferBandCount == 3) {
    imageType=BufferedImage.TYPE_INT_RGB;
  }
 else   if (indexed && bufferBandCount == 1) {
  }
 else {
  }
  img=(indexColorModel == null) ? new BufferedImage(width,height,imageType) : new BufferedImage(width,height,imageType,indexColorModel);
  img.setData(raster);
  return img;
}",0.9818934299017072
11180,"public void replaceValues(int[] min,int[] max,Integer[] replacement,Integer[] otherwise) throws TilerException {
  if (min.length != bufferBandCount || max.length != bufferBandCount || replacement.length != bufferBandCount || otherwise.length != bufferBandCount) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  boolean allNull=true;
  for (int b=0; b < bufferBandCount; b++) {
    if (replacement[b] != null || otherwise[b] != null) {
      allNull=false;
      break;
    }
  }
  if (allNull) {
    return;
  }
  for (int y=0; y < height; y++) {
    for (int x=0; x < width; x++) {
      boolean between=true;
      for (int b=0; b < bufferBandCount; b++) {
        int index=getBufferIndex(x,y,b) * bufferTypeSize;
        int value=0;
        if (bufferType == gdalconstConstants.GDT_Byte) {
          value=buffer.get(index) & 0xff;
        }
 else         if (bufferType == gdalconstConstants.GDT_Int16 || bufferType == gdalconstConstants.GDT_UInt16) {
          value=buffer.getShort(index);
        }
 else         if (bufferType == gdalconstConstants.GDT_Int32 || bufferType == gdalconstConstants.GDT_UInt32) {
          value=buffer.getInt(index);
        }
 else {
          throw new TilerException(""String_Node_Str"");
        }
        if (value < min[b] || value > max[b]) {
          between=false;
          break;
        }
      }
      Integer[] values=between ? replacement : otherwise;
      for (int b=0; b < bufferBandCount; b++) {
        if (values[b] != null) {
          int index=getBufferIndex(x,y,b) * bufferTypeSize;
          int value=values[b];
          if (bufferType == gdalconstConstants.GDT_Byte) {
            buffer.put(index,(byte)value);
          }
 else           if (bufferType == gdalconstConstants.GDT_Int16 || bufferType == gdalconstConstants.GDT_UInt16) {
            buffer.putShort(index,(short)value);
          }
 else           if (bufferType == gdalconstConstants.GDT_Int32 || bufferType == gdalconstConstants.GDT_UInt32) {
            buffer.putInt(index,value);
          }
 else {
            throw new TilerException(""String_Node_Str"");
          }
        }
      }
    }
  }
}","public void replaceValues(NumberArray min,NumberArray max,NullableNumberArray replacement,NullableNumberArray otherwise) throws TilerException {
  if (min.length() != bufferBandCount || max.length() != bufferBandCount || replacement.length() != bufferBandCount || otherwise.length() != bufferBandCount)   throw new IllegalArgumentException(""String_Node_Str"");
  boolean allNull=true;
  for (int b=0; b < bufferBandCount; b++) {
    if (replacement.getDouble(b) != null || otherwise.getDouble(b) != null) {
      allNull=false;
      break;
    }
  }
  if (allNull) {
    return;
  }
  for (int y=0; y < height; y++) {
    for (int x=0; x < width; x++) {
      boolean between=true;
      for (int b=0; b < bufferBandCount; b++) {
        int index=getBufferIndex(x,y,b) * bufferTypeSize;
        if (floatingPoint) {
          double value=getDoubleValue(index,buffer,bufferType);
          if (value < min.getDouble(b) || value > max.getDouble(b)) {
            between=false;
            break;
          }
        }
 else {
          long value=getLongValue(index,buffer,bufferType);
          if (value < min.getLong(b) || value > max.getLong(b)) {
            between=false;
            break;
          }
        }
      }
      NullableNumberArray values=between ? replacement : otherwise;
      for (int b=0; b < bufferBandCount; b++) {
        if (values.getDouble(b) != null) {
          int index=getBufferIndex(x,y,b) * bufferTypeSize;
          if (floatingPoint) {
            putDoubleValue(index,buffer,bufferType,values.getDouble(b));
          }
 else {
            putLongValue(index,buffer,bufferType,values.getLong(b));
          }
        }
      }
    }
  }
}",0.4356435643564356
11181,"public GDALTile convertToType(int newBufferType){
  if (newBufferType == bufferType)   return this;
  int newBufferTypeSize=gdal.GetDataTypeSize(newBufferType) / 8;
  if (!(bufferType == gdalconstConstants.GDT_Byte || bufferType == gdalconstConstants.GDT_Float32 || bufferType == gdalconstConstants.GDT_Float64 || bufferType == gdalconstConstants.GDT_Int16 || bufferType == gdalconstConstants.GDT_Int32 || bufferType == gdalconstConstants.GDT_UInt16 || bufferType == gdalconstConstants.GDT_UInt32))   throw new IllegalStateException(""String_Node_Str"");
  if (!(newBufferType == gdalconstConstants.GDT_Byte || newBufferType == gdalconstConstants.GDT_Float32 || newBufferType == gdalconstConstants.GDT_Float64 || newBufferType == gdalconstConstants.GDT_Int16 || newBufferType == gdalconstConstants.GDT_Int32 || newBufferType == gdalconstConstants.GDT_UInt16 || newBufferType == gdalconstConstants.GDT_UInt32))   throw new IllegalArgumentException(""String_Node_Str"");
  int size=buffer.limit() / bufferTypeSize;
  ByteBuffer newBuffer=ByteBuffer.allocateDirect(size * newBufferTypeSize);
  newBuffer.order(buffer.order());
  buffer.rewind();
  while (buffer.hasRemaining()) {
    copy(buffer,newBuffer,bufferType,newBufferType);
  }
  buffer.rewind();
  newBuffer.rewind();
  return new GDALTile(this,newBuffer,newBufferType,newBufferTypeSize);
}","public GDALTile convertToType(int newBufferType){
  if (newBufferType == bufferType)   return this;
  int newBufferTypeSize=gdal.GetDataTypeSize(newBufferType) / 8;
  boolean newFloatingPoint=isTypeFloatingPoint(newBufferType);
  int size=buffer.limit() / bufferTypeSize;
  ByteBuffer newBuffer=ByteBuffer.allocateDirect(size * newBufferTypeSize);
  newBuffer.order(buffer.order());
  long lvalue=0;
  double dvalue=0;
  buffer.rewind();
  while (buffer.hasRemaining()) {
    if (floatingPoint) {
      dvalue=getDoubleValue(buffer,bufferType);
      lvalue=(long)dvalue;
    }
 else {
      lvalue=getLongValue(buffer,bufferType);
      dvalue=lvalue;
    }
    if (newFloatingPoint)     putDoubleValue(newBuffer,newBufferType,dvalue);
 else     putLongValue(newBuffer,newBufferType,lvalue);
  }
  buffer.rewind();
  newBuffer.rewind();
  return new GDALTile(this,newBuffer,newBufferType,newBufferTypeSize,newFloatingPoint);
}",0.3418502202643171
11182,"protected void readRectangle(Dataset dataset,Rectangle srcRect) throws GDALException, TilerException {
  int dataBandCount=dataset.getRasterCount();
  if (dataBandCount <= 0) {
    throw new TilerException(""String_Node_Str"");
  }
  if (selectedBand >= 0 && selectedBand >= dataBandCount) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  bufferBandCount=selectedBand >= 0 ? 1 : (addAlpha && dataBandCount == 3) ? 4 : dataBandCount;
  bufferType=0;
  Band[] bands=null;
  if (selectedBand >= 0) {
    bands=new Band[1];
    bands[0]=dataset.GetRasterBand(selectedBand + 1);
    bufferType=bands[0].getDataType();
  }
 else {
    bands=new Band[dataBandCount];
    for (int i=0; i < dataBandCount; i++) {
      bands[i]=dataset.GetRasterBand(i + 1);
      if (i == 0) {
        bufferType=bands[i].getDataType();
      }
 else       if (bands[i].getDataType() != bufferType) {
        throw new TilerException(""String_Node_Str"");
      }
    }
  }
  int dataTypeSize=gdal.GetDataTypeSize(bufferType);
  bufferTypeSize=dataTypeSize / 8;
  int pixels=width * height;
  int bandSize=pixels * bufferTypeSize;
  buffer=ByteBuffer.allocateDirect(bandSize * bufferBandCount);
  buffer.order(ByteOrder.LITTLE_ENDIAN);
  dataRectangle=new Rectangle(0,0,width,height);
  if (srcRect == null) {
    srcRect=new Rectangle(0,0,dataset.getRasterXSize(),dataset.getRasterYSize());
  }
 else   if (srcRect.x < 0 || srcRect.y < 0 || srcRect.x + srcRect.width > dataset.getRasterXSize() || srcRect.y + srcRect.height > dataset.getRasterYSize()) {
    Rectangle newSrcRect=new Rectangle(0,0,dataset.getRasterXSize(),dataset.getRasterYSize());
    newSrcRect=srcRect.intersection(newSrcRect);
    if (!newSrcRect.isEmpty()) {
      int dstX=dataRectangle.width * (newSrcRect.x - srcRect.x) / srcRect.width;
      int dstY=dataRectangle.height * (newSrcRect.y - srcRect.y) / srcRect.height;
      int dstWidth=dataRectangle.width - dataRectangle.width * (srcRect.width - newSrcRect.width) / srcRect.width;
      int dstHeight=dataRectangle.height - dataRectangle.height * (srcRect.height - newSrcRect.height) / srcRect.height;
      dataRectangle=new Rectangle(dstX,dstY,dstWidth,dstHeight);
    }
 else {
      throw new TilerException(""String_Node_Str"");
    }
    srcRect=newSrcRect;
  }
  for (int b=0; b < bands.length; b++) {
    if (!srcRect.isEmpty()) {
      buffer.position(b * bandSize + dataRectangle.x + dataRectangle.y * width);
      ByteBuffer sliced=buffer.slice();
      int returnVal=bands[b].ReadRaster_Direct(srcRect.x,srcRect.y,srcRect.width,srcRect.height,dataRectangle.width,dataRectangle.height,bufferType,sliced,bufferTypeSize,bufferTypeSize * width);
      if (returnVal != gdalconstConstants.CE_None) {
        throw new GDALException();
      }
    }
  }
  if (bufferBandCount == 4 && dataBandCount != 4) {
    for (int y=0; y < height; y++) {
      for (int x=0; x < width; x++) {
        int index=getBufferIndex(x,y,3) * bufferTypeSize;
        for (int i=0; i < bufferTypeSize; i++) {
          if (dataRectangle.contains(x,y))           buffer.put(index + i,(byte)0xff);
 else           buffer.put(index + i,(byte)0x00);
        }
      }
    }
  }
  buffer.rewind();
  Band lastBand=bands[bands.length - 1];
  boolean indexed=lastBand.GetRasterColorInterpretation() == gdalconstConstants.GCI_PaletteIndex;
  indexColorModel=indexed ? lastBand.GetRasterColorTable().getIndexColorModel(dataTypeSize) : null;
}","protected void readRectangle(Dataset dataset,Rectangle srcRect) throws GDALException, TilerException {
  int dataBandCount=dataset.getRasterCount();
  if (dataBandCount <= 0) {
    throw new TilerException(""String_Node_Str"");
  }
  if (selectedBand >= 0 && selectedBand >= dataBandCount) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  bufferBandCount=selectedBand >= 0 ? 1 : (addAlpha && dataBandCount == 3) ? 4 : dataBandCount;
  bufferType=0;
  Band[] bands=null;
  if (selectedBand >= 0) {
    bands=new Band[1];
    bands[0]=dataset.GetRasterBand(selectedBand + 1);
    bufferType=bands[0].getDataType();
  }
 else {
    bands=new Band[dataBandCount];
    for (int i=0; i < dataBandCount; i++) {
      bands[i]=dataset.GetRasterBand(i + 1);
      if (i == 0) {
        bufferType=bands[i].getDataType();
      }
 else       if (bands[i].getDataType() != bufferType) {
        throw new TilerException(""String_Node_Str"");
      }
    }
  }
  int dataTypeSize=gdal.GetDataTypeSize(bufferType);
  bufferTypeSize=dataTypeSize / 8;
  floatingPoint=isTypeFloatingPoint(bufferType);
  int pixels=width * height;
  int bandSize=pixels * bufferTypeSize;
  buffer=ByteBuffer.allocateDirect(bandSize * bufferBandCount);
  buffer.order(ByteOrder.LITTLE_ENDIAN);
  dataRectangle=new Rectangle(0,0,width,height);
  if (srcRect == null) {
    srcRect=new Rectangle(0,0,dataset.getRasterXSize(),dataset.getRasterYSize());
  }
 else   if (srcRect.x < 0 || srcRect.y < 0 || srcRect.x + srcRect.width > dataset.getRasterXSize() || srcRect.y + srcRect.height > dataset.getRasterYSize()) {
    Rectangle newSrcRect=new Rectangle(0,0,dataset.getRasterXSize(),dataset.getRasterYSize());
    newSrcRect=srcRect.intersection(newSrcRect);
    if (!newSrcRect.isEmpty()) {
      int dstX=dataRectangle.width * (newSrcRect.x - srcRect.x) / srcRect.width;
      int dstY=dataRectangle.height * (newSrcRect.y - srcRect.y) / srcRect.height;
      int dstWidth=dataRectangle.width - dataRectangle.width * (srcRect.width - newSrcRect.width) / srcRect.width;
      int dstHeight=dataRectangle.height - dataRectangle.height * (srcRect.height - newSrcRect.height) / srcRect.height;
      dataRectangle=new Rectangle(dstX,dstY,dstWidth,dstHeight);
    }
 else {
      throw new TilerException(""String_Node_Str"");
    }
    srcRect=newSrcRect;
  }
  for (int b=0; b < bands.length; b++) {
    if (!srcRect.isEmpty()) {
      buffer.position(b * bandSize + dataRectangle.x + dataRectangle.y * width);
      ByteBuffer sliced=buffer.slice();
      int returnVal=bands[b].ReadRaster_Direct(srcRect.x,srcRect.y,srcRect.width,srcRect.height,dataRectangle.width,dataRectangle.height,bufferType,sliced,bufferTypeSize,bufferTypeSize * width);
      if (returnVal != gdalconstConstants.CE_None) {
        throw new GDALException();
      }
    }
  }
  if (bufferBandCount == 4 && dataBandCount != 4) {
    for (int y=0; y < height; y++) {
      for (int x=0; x < width; x++) {
        int index=getBufferIndex(x,y,3) * bufferTypeSize;
        for (int i=0; i < bufferTypeSize; i++) {
          if (dataRectangle.contains(x,y))           buffer.put(index + i,(byte)0xff);
 else           buffer.put(index + i,(byte)0x00);
        }
      }
    }
  }
  buffer.rewind();
  Band lastBand=bands[bands.length - 1];
  boolean indexed=lastBand.GetRasterColorInterpretation() == gdalconstConstants.GCI_PaletteIndex;
  indexColorModel=indexed ? lastBand.GetRasterColorTable().getIndexColorModel(dataTypeSize) : null;
}",0.9929200982516976
11183,"private void createLoggerPopupMenu(){
  final String preferenceKey=""String_Node_Str"";
  Level prefLevel=Level.FINE;
  try {
    String prefLevelStr=preferences.get(preferenceKey,prefLevel.getName());
    prefLevel=Level.parse(prefLevelStr);
  }
 catch (  Exception e) {
  }
  logger.setLevel(prefLevel);
  loggerPopup=new JPopupMenu();
  Level[] levels=new Level[]{Level.FINEST,Level.FINER,Level.FINE,Level.INFO,Level.WARNING,Level.SEVERE};
  ButtonGroup bg=new ButtonGroup();
  for (  final Level level : levels) {
    JRadioButtonMenuItem menuItem=new JRadioButtonMenuItem(new AbstractAction(level.getName()){
      public void actionPerformed(      ActionEvent e){
        logger.setLevel(level);
        preferences.put(preferenceKey,level.getName());
      }
    }
);
    loggerPopup.add(menuItem);
    bg.add(menuItem);
    menuItem.setSelected(logger.getLevel().equals(level));
  }
  MouseListener ml=new MouseAdapter(){
    public void mousePressed(    MouseEvent e){
      maybeShowPopup(e);
    }
    public void mouseReleased(    MouseEvent e){
      maybeShowPopup(e);
    }
    private void maybeShowPopup(    MouseEvent e){
      if (e.isPopupTrigger()) {
        loggerPopup.show(e.getComponent(),e.getX(),e.getY());
      }
    }
  }
;
  textLog.addMouseListener(ml);
}","private void createLoggerPopupMenu(){
  final String preferenceKey=""String_Node_Str"";
  Level prefLevel=Level.INFO;
  try {
    String prefLevelStr=preferences.get(preferenceKey,prefLevel.getName());
    prefLevel=Level.parse(prefLevelStr);
  }
 catch (  Exception e) {
  }
  logger.setLevel(prefLevel);
  loggerPopup=new JPopupMenu();
  Level[] levels=new Level[]{Level.FINEST,Level.FINER,Level.FINE,Level.INFO,Level.WARNING,Level.SEVERE};
  ButtonGroup bg=new ButtonGroup();
  for (  final Level level : levels) {
    JRadioButtonMenuItem menuItem=new JRadioButtonMenuItem(new AbstractAction(level.getName()){
      public void actionPerformed(      ActionEvent e){
        logger.setLevel(level);
        preferences.put(preferenceKey,level.getName());
      }
    }
);
    loggerPopup.add(menuItem);
    bg.add(menuItem);
    menuItem.setSelected(logger.getLevel().equals(level));
  }
  MouseListener ml=new MouseAdapter(){
    public void mousePressed(    MouseEvent e){
      maybeShowPopup(e);
    }
    public void mouseReleased(    MouseEvent e){
      maybeShowPopup(e);
    }
    private void maybeShowPopup(    MouseEvent e){
      if (e.isPopupTrigger()) {
        loggerPopup.show(e.getComponent(),e.getX(),e.getY());
      }
    }
  }
;
  textLog.addMouseListener(ml);
}",0.998443579766537
11184,"private void tileTypeChanged(){
  if (!tilesizeChanged) {
    tilesizeBeingSet=true;
    if (elevationRadio.isSelected()) {
      tilesizeField.setValue(150);
    }
 else {
      tilesizeField.setValue(512);
    }
    tilesizeBeingSet=false;
  }
  if (!lztsChanged) {
    lztsBeingSet=true;
    if (elevationRadio.isSelected()) {
      lztsField.setValue(20d);
    }
 else {
      lztsField.setValue(36d);
    }
    lztsBeingSet=false;
  }
  bandCountChanged();
}","private void tileTypeChanged(){
  if (!tilesizeChanged) {
    tilesizeBeingSet=true;
    if (elevationRadio.isSelected()) {
      tilesizeField.setValue(150);
    }
 else {
      tilesizeField.setValue(512);
    }
    tilesizeBeingSet=false;
  }
  if (!lztsChanged) {
    lztsBeingSet=true;
    if (elevationRadio.isSelected()) {
      lztsField.setValue(20d);
    }
 else {
      lztsField.setValue(36d);
    }
    lztsBeingSet=false;
  }
  bandCountChanged();
  tilesizeChanged();
}",0.97571277719113
11185,"private void openDataset(File file){
  fileOpen=file != null;
  if (!fileOpen) {
    infoText.setText(""String_Node_Str"");
    gdalFileField.setText(""String_Node_Str"");
    mapnikFileField.setText(""String_Node_Str"");
    previewCanvas.setIcon(null);
    bandCount=0;
    dataset=null;
    sector=null;
    mapFile=null;
  }
 else {
    try {
      gdalFileField.setText(file.getAbsolutePath());
      mapnikFileField.setText(file.getAbsolutePath());
      if (gdalRadio.isSelected()) {
        final Dataset dataset=GDALUtil.open(file);
        final Sector sector=GDALUtil.getSector(dataset);
        this.sector=sector;
        this.dataset=dataset;
        final int width=dataset.getRasterXSize();
        final int height=dataset.getRasterYSize();
        if (sector.getMinLongitude() == 0 && sector.getMinLatitude() == 0 && sector.getMaxLongitude() == width && sector.getMaxLatitude() == height) {
          throw new TilerException(""String_Node_Str"" + file + ""String_Node_Str"");
        }
        bandCount=dataset.getRasterCount();
        if (bandCount == 0) {
          throw new TilerException(""String_Node_Str"");
        }
        String projection=dataset.GetProjection();
        SpatialReference spatialReference=(projection == null || projection.length() == 0 || !GDALUtil.isProjectionsSupported()) ? null : new SpatialReference(projection);
        String[] dataTypes=new String[bandCount];
        int[] dataTypeSizes=new int[bandCount];
        for (int i=0; i < bandCount; i++) {
          Band band=dataset.GetRasterBand(i + 1);
          int dataType=band.getDataType();
          dataTypes[i]=gdal.GetDataTypeName(dataType);
          dataTypeSizes[i]=gdal.GetDataTypeSize(dataType);
        }
        StringBuilder info=new StringBuilder();
        info.append(""String_Node_Str"");
        info.append(""String_Node_Str"" + width + ""String_Node_Str""+ height+ ""String_Node_Str"");
        info.append(""String_Node_Str"" + (sector.getDeltaLongitude() / width) + ""String_Node_Str""+ (sector.getDeltaLatitude() / height)+ ""String_Node_Str"");
        info.append(""String_Node_Str"" + sector.getMinLongitude() + ""String_Node_Str""+ sector.getMinLatitude()+ ""String_Node_Str"");
        info.append(""String_Node_Str"" + sector.getMaxLongitude() + ""String_Node_Str""+ sector.getMaxLatitude()+ ""String_Node_Str"");
        info.append(""String_Node_Str"" + bandCount + ""String_Node_Str"");
        for (int i=0; i < bandCount; i++) {
          info.append(""String_Node_Str"" + (i + 1) + ""String_Node_Str""+ dataTypes[i]+ ""String_Node_Str""+ dataTypeSizes[i]+ ""String_Node_Str"");
        }
        if (spatialReference != null) {
          info.append(""String_Node_Str"");
          info.append(spatialReference.ExportToPrettyWkt() + ""String_Node_Str"");
        }
        String text=info.substring(0,info.length() - 1);
        infoText.setText(text);
        infoText.select(0,0);
        Thread thread=new Thread(new Runnable(){
          public void run(){
            logger.fine(""String_Node_Str"");
            try {
              int w=400;
              int h=w;
              if (width > height) {
                h=w * height / width;
              }
 else {
                w=h * width / height;
              }
              GDALTile tile=new GDALTile(dataset,w,h,sector.getMinLatitude(),sector.getMinLongitude(),sector.getMaxLatitude(),sector.getMaxLongitude());
              BufferedImage image=tile.getAsImage();
              ImageIcon icon=new ImageIcon(image);
              previewCanvas.setIcon(icon);
              logger.fine(""String_Node_Str"");
            }
 catch (            Exception e) {
              logger.warning(e.getMessage());
            }
          }
        }
);
        thread.setDaemon(true);
        thread.start();
      }
 else {
        infoText.setText(""String_Node_Str"");
        this.bandCount=0;
        this.mapFile=file;
        Sector sect=MapnikUtil.getSector(mapFile);
        if (sect == null) {
          sect=Sector.FULL_SPHERE;
          logger.warning(""String_Node_Str"");
        }
        this.sector=sect;
        minLatitudeField.setValue(sect.getMinLatitude());
        minLongitudeField.setValue(sect.getMinLongitude());
        maxLatitudeField.setValue(sect.getMaxLatitude());
        maxLongitudeField.setValue(sect.getMaxLongitude());
        Thread thread=new Thread(new Runnable(){
          public void run(){
            logger.fine(""String_Node_Str"");
            try {
              File dst=File.createTempFile(""String_Node_Str"",""String_Node_Str"");
              dst.deleteOnExit();
              MapnikUtil.tile(sector,previewCanvas.getWidth(),previewCanvas.getHeight(),mapFile,dst,logger);
              BufferedImage image=ImageIO.read(dst);
              ImageIcon icon=new ImageIcon(image);
              previewCanvas.setIcon(icon);
              logger.fine(""String_Node_Str"");
            }
 catch (            Exception e) {
              logger.warning(e.toString());
            }
          }
        }
);
        thread.setDaemon(true);
        thread.start();
      }
      logger.info(""String_Node_Str"" + file + ""String_Node_Str"");
    }
 catch (    Exception e) {
      logger.severe(e.getMessage());
      openDataset(null);
      return;
    }
  }
  bandCountChanged();
  tileTypeChanged();
  imageFormatChanged();
  recalculateTiles();
  frame.doLayout();
}","private void openDataset(File file){
  fileOpen=file != null;
  if (!fileOpen) {
    infoText.setText(""String_Node_Str"");
    gdalFileField.setText(""String_Node_Str"");
    mapnikFileField.setText(""String_Node_Str"");
    previewCanvas.setIcon(null);
    bandCount=0;
    dataset=null;
    sector=null;
    mapFile=null;
  }
 else {
    try {
      gdalFileField.setText(file.getAbsolutePath());
      mapnikFileField.setText(file.getAbsolutePath());
      if (gdalRadio.isSelected()) {
        final Dataset dataset=GDALUtil.open(file);
        final Sector sector=GDALUtil.getSector(dataset);
        this.sector=sector;
        this.dataset=dataset;
        final int width=dataset.getRasterXSize();
        final int height=dataset.getRasterYSize();
        if (sector.getMinLongitude() == 0 && sector.getMinLatitude() == 0 && sector.getMaxLongitude() == width && sector.getMaxLatitude() == height) {
          throw new TilerException(""String_Node_Str"" + file + ""String_Node_Str"");
        }
        bandCount=dataset.getRasterCount();
        if (bandCount == 0) {
          throw new TilerException(""String_Node_Str"");
        }
        String projection=dataset.GetProjection();
        SpatialReference spatialReference=(projection == null || projection.length() == 0 || !GDALUtil.isProjectionsSupported()) ? null : new SpatialReference(projection);
        String[] dataTypes=new String[bandCount];
        int[] dataTypeSizes=new int[bandCount];
        Double[] nodata=new Double[bandCount];
        for (int i=0; i < bandCount; i++) {
          Band band=dataset.GetRasterBand(i + 1);
          int dataType=band.getDataType();
          dataTypes[i]=gdal.GetDataTypeName(dataType);
          dataTypeSizes[i]=gdal.GetDataTypeSize(dataType);
          Double[] nodataValue=new Double[1];
          band.GetNoDataValue(nodataValue);
          nodata[i]=nodataValue[0];
        }
        StringBuilder info=new StringBuilder();
        info.append(""String_Node_Str"");
        info.append(""String_Node_Str"" + width + ""String_Node_Str""+ height+ ""String_Node_Str"");
        info.append(""String_Node_Str"" + (sector.getDeltaLongitude() / width) + ""String_Node_Str""+ (sector.getDeltaLatitude() / height)+ ""String_Node_Str"");
        info.append(""String_Node_Str"" + sector.getMinLongitude() + ""String_Node_Str""+ sector.getMinLatitude()+ ""String_Node_Str"");
        info.append(""String_Node_Str"" + sector.getMaxLongitude() + ""String_Node_Str""+ sector.getMaxLatitude()+ ""String_Node_Str"");
        info.append(""String_Node_Str"" + bandCount + ""String_Node_Str"");
        for (int i=0; i < bandCount; i++) {
          info.append(""String_Node_Str"" + (i + 1) + ""String_Node_Str""+ dataTypes[i]+ ""String_Node_Str""+ dataTypeSizes[i]+ ""String_Node_Str""+ nodata[i]+ ""String_Node_Str"");
        }
        if (spatialReference != null) {
          info.append(""String_Node_Str"");
          info.append(spatialReference.ExportToPrettyWkt() + ""String_Node_Str"");
        }
        String text=info.substring(0,info.length() - 1);
        infoText.setText(text);
        infoText.select(0,0);
        Thread thread=new Thread(new Runnable(){
          public void run(){
            logger.fine(""String_Node_Str"");
            try {
              int w=400;
              int h=w;
              if (width > height) {
                h=w * height / width;
              }
 else {
                w=h * width / height;
              }
              GDALTile tile=new GDALTile(dataset,w,h,sector.getMinLatitude(),sector.getMinLongitude(),sector.getMaxLatitude(),sector.getMaxLongitude());
              BufferedImage image=tile.getAsImage();
              ImageIcon icon=new ImageIcon(image);
              previewCanvas.setIcon(icon);
              logger.fine(""String_Node_Str"");
            }
 catch (            Exception e) {
              logger.warning(e.getMessage());
            }
          }
        }
);
        thread.setDaemon(true);
        thread.start();
      }
 else {
        infoText.setText(""String_Node_Str"");
        this.bandCount=0;
        this.mapFile=file;
        Sector sect=MapnikUtil.getSector(mapFile);
        if (sect == null) {
          sect=Sector.FULL_SPHERE;
          logger.warning(""String_Node_Str"");
        }
        this.sector=sect;
        minLatitudeField.setValue(sect.getMinLatitude());
        minLongitudeField.setValue(sect.getMinLongitude());
        maxLatitudeField.setValue(sect.getMaxLatitude());
        maxLongitudeField.setValue(sect.getMaxLongitude());
        Thread thread=new Thread(new Runnable(){
          public void run(){
            logger.fine(""String_Node_Str"");
            try {
              File dst=File.createTempFile(""String_Node_Str"",""String_Node_Str"");
              dst.deleteOnExit();
              MapnikUtil.tile(sector,previewCanvas.getWidth(),previewCanvas.getHeight(),mapFile,dst,logger);
              BufferedImage image=ImageIO.read(dst);
              ImageIcon icon=new ImageIcon(image);
              previewCanvas.setIcon(icon);
              logger.fine(""String_Node_Str"");
            }
 catch (            Exception e) {
              logger.warning(e.toString());
            }
          }
        }
);
        thread.setDaemon(true);
        thread.start();
      }
      logger.info(""String_Node_Str"" + file + ""String_Node_Str"");
    }
 catch (    Exception e) {
      logger.severe(e.getMessage());
      openDataset(null);
      return;
    }
  }
  bandCountChanged();
  tileTypeChanged();
  imageFormatChanged();
  recalculateTiles();
  frame.doLayout();
}",0.9813641788304416
11186,"private void generateTiles(){
  final TilerProgressReporter reporter=new TilerProgressReporter(this,logger);
  this.reporter=reporter;
  started();
  Thread thread=new Thread(new Runnable(){
    public void run(){
      int level=levels - 1;
      int tilesize=tilesizeField.getValue();
      double lzts=lztsField.getValue();
      File outDir=new File(outputDirectory.getText());
      int[] outsideValues=null;
      int[] minReplace=null;
      int[] maxReplace=null;
      Integer[] replace=null;
      Integer[] otherwise=null;
      boolean overviews=overviewsCheck.isSelected();
      if (outsideCheck.isSelected()) {
        outsideValues=new int[outputBandCount];
        for (int b=0; b < outputBandCount; b++) {
          Integer value=outsideFields[b].getValue();
          outsideValues[b]=value != null ? value : 0;
        }
      }
      if (replaceCheck.isSelected()) {
        minReplace=new int[outputBandCount];
        maxReplace=new int[outputBandCount];
        replace=new Integer[outputBandCount];
        otherwise=new Integer[outputBandCount];
        for (int b=0; b < outputBandCount; b++) {
          Integer value=minFields[b].getValue();
          minReplace[b]=value != null ? value : 0;
          value=maxFields[b].getValue();
          maxReplace[b]=value != null ? value : 0;
          replace[b]=replaceFields[b].getValue();
          otherwise[b]=otherwiseFields[b].getValue();
        }
      }
      String imageFormat=pngRadio.isSelected() ? ""String_Node_Str"" : ""String_Node_Str"";
      if (mapnikRadio.isSelected()) {
        Tiler.tileMapnik(mapFile,sector,level,tilesize,lzts,imageFormat,outDir,reporter);
        if (overviews && !reporter.isCancelled()) {
          Overviewer.createImageOverviews(outDir,imageFormat,tilesize,tilesize,outsideValues,sector,lzts,reporter);
        }
      }
 else       if (imageRadio.isSelected()) {
        boolean addAlpha=pngRadio.isSelected() && alphaCheck.isSelected();
        Tiler.tileImages(dataset,sector,level,tilesize,lzts,imageFormat,addAlpha,outsideValues,minReplace,maxReplace,replace,otherwise,outDir,reporter);
        if (overviews && !reporter.isCancelled()) {
          Overviewer.createImageOverviews(outDir,imageFormat,tilesize,tilesize,outsideValues,sector,lzts,reporter);
        }
      }
 else       if (elevationRadio.isSelected()) {
        int bufferType=byteRadio.isSelected() ? gdalconstConstants.GDT_Byte : int16Radio.isSelected() ? gdalconstConstants.GDT_Int16 : gdalconstConstants.GDT_Int32;
        int band=bandCombo.getSelectedIndex();
        Tiler.tileElevations(dataset,sector,level,tilesize,lzts,bufferType,band,outsideValues,minReplace,maxReplace,replace,otherwise,outDir,reporter);
        if (overviews && !reporter.isCancelled()) {
          Overviewer.createElevationOverviews(outDir,tilesize,tilesize,bufferType,ByteOrder.LITTLE_ENDIAN,outsideValues,sector,lzts,reporter);
        }
      }
      reporter.done();
    }
  }
);
  thread.setDaemon(true);
  thread.start();
}","private void generateTiles(){
  final TilerProgressReporter reporter=new TilerProgressReporter(this,logger);
  this.reporter=reporter;
  started();
  Thread thread=new Thread(new Runnable(){
    public void run(){
      int level=levels - 1;
      int tilesize=tilesizeField.getValue();
      double lzts=lztsField.getValue();
      File outDir=new File(outputDirectory.getText());
      NumberArray outsideValues=null;
      NumberArray minReplace=null;
      NumberArray maxReplace=null;
      NullableNumberArray replace=null;
      NullableNumberArray otherwise=null;
      boolean overviews=overviewsCheck.isSelected();
      boolean isFloat=isFloat();
      if (outsideCheck.isSelected()) {
        outsideValues=new NumberArray(outputBandCount);
        for (int b=0; b < outputBandCount; b++) {
          if (isFloat) {
            outsideValues.setDouble(b,((JDoubleField)outsideFields[b]).getValue());
          }
 else {
            outsideValues.setLong(b,((JLongField)outsideFields[b]).getValue());
          }
        }
      }
      if (replaceCheck.isSelected()) {
        minReplace=new NumberArray(outputBandCount);
        maxReplace=new NumberArray(outputBandCount);
        replace=new NullableNumberArray(outputBandCount);
        otherwise=new NullableNumberArray(outputBandCount);
        for (int b=0; b < outputBandCount; b++) {
          if (isFloat) {
            minReplace.setDouble(b,((JDoubleField)minFields[b]).getValue());
            maxReplace.setDouble(b,((JDoubleField)maxFields[b]).getValue());
            replace.setDouble(b,((JDoubleField)replaceFields[b]).getValue());
            otherwise.setDouble(b,((JDoubleField)otherwiseFields[b]).getValue());
          }
 else {
            minReplace.setLong(b,((JLongField)minFields[b]).getValue());
            maxReplace.setLong(b,((JLongField)maxFields[b]).getValue());
            replace.setLong(b,((JLongField)replaceFields[b]).getValue());
            otherwise.setLong(b,((JLongField)otherwiseFields[b]).getValue());
          }
        }
      }
      String imageFormat=pngRadio.isSelected() ? ""String_Node_Str"" : ""String_Node_Str"";
      if (mapnikRadio.isSelected()) {
        Tiler.tileMapnik(mapFile,sector,level,tilesize,lzts,imageFormat,outDir,reporter);
        if (overviews && !reporter.isCancelled()) {
          Overviewer.createImageOverviews(outDir,imageFormat,tilesize,tilesize,outsideValues,sector,lzts,reporter);
        }
      }
 else       if (imageRadio.isSelected()) {
        boolean addAlpha=pngRadio.isSelected() && alphaCheck.isSelected();
        Tiler.tileImages(dataset,sector,level,tilesize,lzts,imageFormat,addAlpha,outsideValues,minReplace,maxReplace,replace,otherwise,outDir,reporter);
        if (overviews && !reporter.isCancelled()) {
          Overviewer.createImageOverviews(outDir,imageFormat,tilesize,tilesize,outsideValues,sector,lzts,reporter);
        }
      }
 else       if (elevationRadio.isSelected()) {
        int bufferType=byteRadio.isSelected() ? gdalconstConstants.GDT_Byte : int16Radio.isSelected() ? gdalconstConstants.GDT_Int16 : int32Radio.isSelected() ? gdalconstConstants.GDT_Int32 : gdalconstConstants.GDT_Float32;
        int band=bandCombo.getSelectedIndex();
        NumberArray minmax=new NumberArray(2);
        if (isFloat) {
          minmax.setDouble(0,Double.MAX_VALUE);
          minmax.setDouble(1,-Double.MAX_VALUE);
        }
 else {
          minmax.setLong(0,Long.MAX_VALUE);
          minmax.setLong(1,Long.MIN_VALUE);
        }
        Tiler.tileElevations(dataset,sector,level,tilesize,lzts,bufferType,band,outsideValues,minReplace,maxReplace,replace,otherwise,minmax,outDir,reporter);
        if (overviews && !reporter.isCancelled()) {
          Overviewer.createElevationOverviews(outDir,tilesize,tilesize,bufferType,ByteOrder.LITTLE_ENDIAN,outsideValues,sector,lzts,reporter);
        }
        if (isFloat) {
          reporter.getLogger().info(""String_Node_Str"" + minmax.getDouble(0) + ""String_Node_Str""+ minmax.getDouble(1));
        }
 else {
          reporter.getLogger().info(""String_Node_Str"" + minmax.getLong(0) + ""String_Node_Str""+ minmax.getLong(1));
        }
      }
      reporter.done();
    }
  }
);
  thread.setDaemon(true);
  thread.start();
}",0.7383977900552486
11187,"public void run(){
  int level=levels - 1;
  int tilesize=tilesizeField.getValue();
  double lzts=lztsField.getValue();
  File outDir=new File(outputDirectory.getText());
  int[] outsideValues=null;
  int[] minReplace=null;
  int[] maxReplace=null;
  Integer[] replace=null;
  Integer[] otherwise=null;
  boolean overviews=overviewsCheck.isSelected();
  if (outsideCheck.isSelected()) {
    outsideValues=new int[outputBandCount];
    for (int b=0; b < outputBandCount; b++) {
      Integer value=outsideFields[b].getValue();
      outsideValues[b]=value != null ? value : 0;
    }
  }
  if (replaceCheck.isSelected()) {
    minReplace=new int[outputBandCount];
    maxReplace=new int[outputBandCount];
    replace=new Integer[outputBandCount];
    otherwise=new Integer[outputBandCount];
    for (int b=0; b < outputBandCount; b++) {
      Integer value=minFields[b].getValue();
      minReplace[b]=value != null ? value : 0;
      value=maxFields[b].getValue();
      maxReplace[b]=value != null ? value : 0;
      replace[b]=replaceFields[b].getValue();
      otherwise[b]=otherwiseFields[b].getValue();
    }
  }
  String imageFormat=pngRadio.isSelected() ? ""String_Node_Str"" : ""String_Node_Str"";
  if (mapnikRadio.isSelected()) {
    Tiler.tileMapnik(mapFile,sector,level,tilesize,lzts,imageFormat,outDir,reporter);
    if (overviews && !reporter.isCancelled()) {
      Overviewer.createImageOverviews(outDir,imageFormat,tilesize,tilesize,outsideValues,sector,lzts,reporter);
    }
  }
 else   if (imageRadio.isSelected()) {
    boolean addAlpha=pngRadio.isSelected() && alphaCheck.isSelected();
    Tiler.tileImages(dataset,sector,level,tilesize,lzts,imageFormat,addAlpha,outsideValues,minReplace,maxReplace,replace,otherwise,outDir,reporter);
    if (overviews && !reporter.isCancelled()) {
      Overviewer.createImageOverviews(outDir,imageFormat,tilesize,tilesize,outsideValues,sector,lzts,reporter);
    }
  }
 else   if (elevationRadio.isSelected()) {
    int bufferType=byteRadio.isSelected() ? gdalconstConstants.GDT_Byte : int16Radio.isSelected() ? gdalconstConstants.GDT_Int16 : gdalconstConstants.GDT_Int32;
    int band=bandCombo.getSelectedIndex();
    Tiler.tileElevations(dataset,sector,level,tilesize,lzts,bufferType,band,outsideValues,minReplace,maxReplace,replace,otherwise,outDir,reporter);
    if (overviews && !reporter.isCancelled()) {
      Overviewer.createElevationOverviews(outDir,tilesize,tilesize,bufferType,ByteOrder.LITTLE_ENDIAN,outsideValues,sector,lzts,reporter);
    }
  }
  reporter.done();
}","public void run(){
  int level=levels - 1;
  int tilesize=tilesizeField.getValue();
  double lzts=lztsField.getValue();
  File outDir=new File(outputDirectory.getText());
  NumberArray outsideValues=null;
  NumberArray minReplace=null;
  NumberArray maxReplace=null;
  NullableNumberArray replace=null;
  NullableNumberArray otherwise=null;
  boolean overviews=overviewsCheck.isSelected();
  boolean isFloat=isFloat();
  if (outsideCheck.isSelected()) {
    outsideValues=new NumberArray(outputBandCount);
    for (int b=0; b < outputBandCount; b++) {
      if (isFloat) {
        outsideValues.setDouble(b,((JDoubleField)outsideFields[b]).getValue());
      }
 else {
        outsideValues.setLong(b,((JLongField)outsideFields[b]).getValue());
      }
    }
  }
  if (replaceCheck.isSelected()) {
    minReplace=new NumberArray(outputBandCount);
    maxReplace=new NumberArray(outputBandCount);
    replace=new NullableNumberArray(outputBandCount);
    otherwise=new NullableNumberArray(outputBandCount);
    for (int b=0; b < outputBandCount; b++) {
      if (isFloat) {
        minReplace.setDouble(b,((JDoubleField)minFields[b]).getValue());
        maxReplace.setDouble(b,((JDoubleField)maxFields[b]).getValue());
        replace.setDouble(b,((JDoubleField)replaceFields[b]).getValue());
        otherwise.setDouble(b,((JDoubleField)otherwiseFields[b]).getValue());
      }
 else {
        minReplace.setLong(b,((JLongField)minFields[b]).getValue());
        maxReplace.setLong(b,((JLongField)maxFields[b]).getValue());
        replace.setLong(b,((JLongField)replaceFields[b]).getValue());
        otherwise.setLong(b,((JLongField)otherwiseFields[b]).getValue());
      }
    }
  }
  String imageFormat=pngRadio.isSelected() ? ""String_Node_Str"" : ""String_Node_Str"";
  if (mapnikRadio.isSelected()) {
    Tiler.tileMapnik(mapFile,sector,level,tilesize,lzts,imageFormat,outDir,reporter);
    if (overviews && !reporter.isCancelled()) {
      Overviewer.createImageOverviews(outDir,imageFormat,tilesize,tilesize,outsideValues,sector,lzts,reporter);
    }
  }
 else   if (imageRadio.isSelected()) {
    boolean addAlpha=pngRadio.isSelected() && alphaCheck.isSelected();
    Tiler.tileImages(dataset,sector,level,tilesize,lzts,imageFormat,addAlpha,outsideValues,minReplace,maxReplace,replace,otherwise,outDir,reporter);
    if (overviews && !reporter.isCancelled()) {
      Overviewer.createImageOverviews(outDir,imageFormat,tilesize,tilesize,outsideValues,sector,lzts,reporter);
    }
  }
 else   if (elevationRadio.isSelected()) {
    int bufferType=byteRadio.isSelected() ? gdalconstConstants.GDT_Byte : int16Radio.isSelected() ? gdalconstConstants.GDT_Int16 : int32Radio.isSelected() ? gdalconstConstants.GDT_Int32 : gdalconstConstants.GDT_Float32;
    int band=bandCombo.getSelectedIndex();
    NumberArray minmax=new NumberArray(2);
    if (isFloat) {
      minmax.setDouble(0,Double.MAX_VALUE);
      minmax.setDouble(1,-Double.MAX_VALUE);
    }
 else {
      minmax.setLong(0,Long.MAX_VALUE);
      minmax.setLong(1,Long.MIN_VALUE);
    }
    Tiler.tileElevations(dataset,sector,level,tilesize,lzts,bufferType,band,outsideValues,minReplace,maxReplace,replace,otherwise,minmax,outDir,reporter);
    if (overviews && !reporter.isCancelled()) {
      Overviewer.createElevationOverviews(outDir,tilesize,tilesize,bufferType,ByteOrder.LITTLE_ENDIAN,outsideValues,sector,lzts,reporter);
    }
    if (isFloat) {
      reporter.getLogger().info(""String_Node_Str"" + minmax.getDouble(0) + ""String_Node_Str""+ minmax.getDouble(1));
    }
 else {
      reporter.getLogger().info(""String_Node_Str"" + minmax.getLong(0) + ""String_Node_Str""+ minmax.getLong(1));
    }
  }
  reporter.done();
}",0.7158944658944659
11188,"@Override public void focusLost(FocusEvent e){
  JIntegerField jif=(JIntegerField)e.getSource();
  if (jif.getValue() == null)   jif.setValue(0);
}","@Override public void focusLost(FocusEvent e){
  if (e.getSource() instanceof JLongField) {
    JLongField jif=(JLongField)e.getSource();
    if (jif.getValue() == null)     jif.setValue(0l);
  }
 else   if (e.getSource() instanceof JDoubleField) {
    JDoubleField jdf=(JDoubleField)e.getSource();
    if (jdf.getValue() == null)     jdf.setValue(0d);
  }
}",0.4514851485148515
11189,"private void bandCountChanged(){
  GridBagConstraints c;
  Integer[] outsideBackup=readIntegerFields(outsideFields);
  Integer[] minBackup=readIntegerFields(minFields);
  Integer[] maxBackup=readIntegerFields(maxFields);
  Integer[] replaceBackup=readIntegerFields(replaceFields);
  Integer[] otherwiseBackup=readIntegerFields(otherwiseFields);
  FocusListener fl=new FocusAdapter(){
    @Override public void focusLost(    FocusEvent e){
      JIntegerField jif=(JIntegerField)e.getSource();
      if (jif.getValue() == null)       jif.setValue(0);
    }
  }
;
  outsidePanel.removeAll();
  minPanel.removeAll();
  maxPanel.removeAll();
  withPanel.removeAll();
  otherwisePanel.removeAll();
  while (bandCombo.getItemCount() > 0) {
    bandCombo.removeItemAt(0);
  }
  outputBandCount=bandCount <= 0 ? 1 : elevationRadio.isSelected() ? 1 : bandCount == 3 && alphaCheck.isSelected() ? 4 : bandCount;
  outsideFields=new JIntegerField[outputBandCount];
  minFields=new JIntegerField[outputBandCount];
  maxFields=new JIntegerField[outputBandCount];
  replaceFields=new JIntegerField[outputBandCount];
  otherwiseFields=new JIntegerField[outputBandCount];
  for (int i=0; i < outputBandCount; i++) {
    outsideFields[i]=new JIntegerField(0);
    Dimension size=outsideFields[i].getPreferredSize();
    size.width=50;
    outsideFields[i].setMinimumSize(size);
    outsideFields[i].setPreferredSize(size);
    outsideFields[i].addFocusListener(fl);
    c=new GridBagConstraints();
    c.gridx=i;
    outsidePanel.add(outsideFields[i],c);
    minFields[i]=new JIntegerField(0);
    minFields[i].setMinimumSize(size);
    minFields[i].setPreferredSize(size);
    minFields[i].addFocusListener(fl);
    c=new GridBagConstraints();
    c.gridx=i;
    minPanel.add(minFields[i],c);
    maxFields[i]=new JIntegerField(0);
    maxFields[i].setMinimumSize(size);
    maxFields[i].setPreferredSize(size);
    maxFields[i].addFocusListener(fl);
    c=new GridBagConstraints();
    c.gridx=i;
    maxPanel.add(maxFields[i],c);
    replaceFields[i]=new JIntegerField(null);
    replaceFields[i].setMinimumSize(size);
    replaceFields[i].setPreferredSize(size);
    c=new GridBagConstraints();
    c.gridx=i;
    withPanel.add(replaceFields[i],c);
    otherwiseFields[i]=new JIntegerField(null);
    otherwiseFields[i].setMinimumSize(size);
    otherwiseFields[i].setPreferredSize(size);
    c=new GridBagConstraints();
    c.gridx=i;
    otherwisePanel.add(otherwiseFields[i],c);
    bandCombo.addItem(new Integer(i + 1));
  }
  writeIntegerFields(outsideFields,outsideBackup);
  writeIntegerFields(minFields,minBackup);
  writeIntegerFields(maxFields,maxBackup);
  writeIntegerFields(replaceFields,replaceBackup);
  writeIntegerFields(otherwiseFields,otherwiseBackup);
  enableFields();
}","private void bandCountChanged(){
  GridBagConstraints c;
  Object[] outsideBackup=readNumberFields(outsideFields);
  Object[] minBackup=readNumberFields(minFields);
  Object[] maxBackup=readNumberFields(maxFields);
  Object[] replaceBackup=readNumberFields(replaceFields);
  Object[] otherwiseBackup=readNumberFields(otherwiseFields);
  FocusListener fl=new FocusAdapter(){
    @Override public void focusLost(    FocusEvent e){
      if (e.getSource() instanceof JLongField) {
        JLongField jif=(JLongField)e.getSource();
        if (jif.getValue() == null)         jif.setValue(0l);
      }
 else       if (e.getSource() instanceof JDoubleField) {
        JDoubleField jdf=(JDoubleField)e.getSource();
        if (jdf.getValue() == null)         jdf.setValue(0d);
      }
    }
  }
;
  outsidePanel.removeAll();
  minPanel.removeAll();
  maxPanel.removeAll();
  withPanel.removeAll();
  otherwisePanel.removeAll();
  while (bandCombo.getItemCount() > 0) {
    bandCombo.removeItemAt(0);
  }
  outputBandCount=bandCount <= 0 ? 1 : elevationRadio.isSelected() ? 1 : bandCount == 3 && alphaCheck.isSelected() ? 4 : bandCount;
  boolean isFloat=isFloat();
  outsideFields=new JTextField[outputBandCount];
  minFields=new JTextField[outputBandCount];
  maxFields=new JTextField[outputBandCount];
  replaceFields=new JTextField[outputBandCount];
  otherwiseFields=new JTextField[outputBandCount];
  for (int i=0; i < outputBandCount; i++) {
    if (isFloat)     outsideFields[i]=new JDoubleField(0d);
 else     outsideFields[i]=new JLongField(0l);
    Dimension size=outsideFields[i].getPreferredSize();
    size.width=50;
    outsideFields[i].setMinimumSize(size);
    outsideFields[i].setPreferredSize(size);
    outsideFields[i].addFocusListener(fl);
    c=new GridBagConstraints();
    c.gridx=i;
    outsidePanel.add(outsideFields[i],c);
    if (isFloat)     minFields[i]=new JDoubleField(0d);
 else     minFields[i]=new JLongField(0l);
    minFields[i].setMinimumSize(size);
    minFields[i].setPreferredSize(size);
    minFields[i].addFocusListener(fl);
    c=new GridBagConstraints();
    c.gridx=i;
    minPanel.add(minFields[i],c);
    if (isFloat)     maxFields[i]=new JDoubleField(0d);
 else     maxFields[i]=new JLongField(0l);
    maxFields[i].setMinimumSize(size);
    maxFields[i].setPreferredSize(size);
    maxFields[i].addFocusListener(fl);
    c=new GridBagConstraints();
    c.gridx=i;
    maxPanel.add(maxFields[i],c);
    if (isFloat)     replaceFields[i]=new JDoubleField(null);
 else     replaceFields[i]=new JLongField(null);
    replaceFields[i].setMinimumSize(size);
    replaceFields[i].setPreferredSize(size);
    c=new GridBagConstraints();
    c.gridx=i;
    withPanel.add(replaceFields[i],c);
    if (isFloat)     otherwiseFields[i]=new JDoubleField(null);
 else     otherwiseFields[i]=new JLongField(null);
    otherwiseFields[i].setMinimumSize(size);
    otherwiseFields[i].setPreferredSize(size);
    c=new GridBagConstraints();
    c.gridx=i;
    otherwisePanel.add(otherwiseFields[i],c);
    bandCombo.addItem(new Integer(i + 1));
  }
  writeNumberFields(outsideFields,outsideBackup);
  writeNumberFields(minFields,minBackup);
  writeNumberFields(maxFields,maxBackup);
  writeNumberFields(replaceFields,replaceBackup);
  writeNumberFields(otherwiseFields,otherwiseBackup);
  enableFields();
}",0.8392272429600524
11190,"private void visibledFields(){
  boolean mapnik=mapnikRadio.isSelected();
  tileTypeLabel.setVisible(!mapnik);
  imageRadio.setVisible(!mapnik);
  elevationRadio.setVisible(!mapnik);
  boolean images=mapnik || imageRadio.isSelected();
  imageFormatLabel.setVisible(images);
  jpegRadio.setVisible(images);
  pngRadio.setVisible(images);
  alphaCheck.setVisible(pngRadio.isSelected() && bandCount == 3 && !mapnik && !elevationRadio.isSelected());
  boolean elevations=elevationRadio.isSelected() && !mapnik;
  bandLabel.setVisible(elevations);
  bandCombo.setVisible(elevations);
  cellTypeLabel.setVisible(elevations);
  byteRadio.setVisible(elevations);
  int16Radio.setVisible(elevations);
  int32Radio.setVisible(elevations);
  levelsLabel.setVisible(mapnik);
  levelsSpinner.setVisible(mapnik);
  overrideLevelsCheck.setVisible(!mapnik);
  overrideLevelsSpinner.setVisible(!mapnik);
  outsideCheck.setVisible(!mapnik);
  outsidePanel.setVisible(!mapnik);
  replaceCheck.setVisible(!mapnik);
  replace1Label.setVisible(!mapnik);
  replace2Label.setVisible(!mapnik);
  replace3Label.setVisible(!mapnik);
  replace4Label.setVisible(!mapnik);
  minPanel.setVisible(!mapnik);
  maxPanel.setVisible(!mapnik);
  withPanel.setVisible(!mapnik);
  otherwisePanel.setVisible(!mapnik);
}","private void visibledFields(){
  boolean mapnik=mapnikRadio.isSelected();
  tileTypeLabel.setVisible(!mapnik);
  imageRadio.setVisible(!mapnik);
  elevationRadio.setVisible(!mapnik);
  boolean images=mapnik || imageRadio.isSelected();
  imageFormatLabel.setVisible(images);
  jpegRadio.setVisible(images);
  pngRadio.setVisible(images);
  alphaCheck.setVisible(pngRadio.isSelected() && bandCount == 3 && !mapnik && !elevationRadio.isSelected());
  boolean elevations=elevationRadio.isSelected() && !mapnik;
  bandLabel.setVisible(elevations);
  bandCombo.setVisible(elevations);
  cellTypeLabel.setVisible(elevations);
  byteRadio.setVisible(elevations);
  int16Radio.setVisible(elevations);
  int32Radio.setVisible(elevations);
  float32Radio.setVisible(elevations);
  levelsLabel.setVisible(mapnik);
  levelsSpinner.setVisible(mapnik);
  overrideLevelsCheck.setVisible(!mapnik);
  overrideLevelsSpinner.setVisible(!mapnik);
  outsideCheck.setVisible(!mapnik);
  outsidePanel.setVisible(!mapnik);
  replaceCheck.setVisible(!mapnik);
  replace1Label.setVisible(!mapnik);
  replace2Label.setVisible(!mapnik);
  replace3Label.setVisible(!mapnik);
  replace4Label.setVisible(!mapnik);
  minPanel.setVisible(!mapnik);
  maxPanel.setVisible(!mapnik);
  withPanel.setVisible(!mapnik);
  otherwisePanel.setVisible(!mapnik);
}",0.9849826723142088
11191,"private void enableFields(){
  boolean standard=fileOpen && !running;
  boolean mapnik=mapnikRadio.isSelected();
  byteRadio.setEnabled(standard);
  elevationRadio.setEnabled(standard && !mapnik);
  imageRadio.setEnabled(standard);
  int16Radio.setEnabled(standard);
  int32Radio.setEnabled(standard);
  jpegRadio.setEnabled(standard);
  lztsField.setEnabled(standard);
  outsideCheck.setEnabled(standard && !mapnik);
  overviewsCheck.setEnabled(standard);
  overrideLevelsCheck.setEnabled(standard && !mapnik);
  pngRadio.setEnabled(standard);
  tilesizeField.setEnabled(standard);
  for (  JComponent label : labels) {
    label.setEnabled(standard);
  }
  tileTypeLabel.setEnabled(standard);
  imageFormatLabel.setEnabled(standard);
  cellTypeLabel.setEnabled(standard);
  bandLabel.setEnabled(standard);
  levelsLabel.setEnabled(standard && mapnik);
  levelsSpinner.setEnabled(standard && mapnik);
  minLatitudeField.setEnabled(standard);
  maxLatitudeField.setEnabled(standard);
  minLongitudeField.setEnabled(standard);
  maxLongitudeField.setEnabled(standard);
  alphaCheck.setEnabled(pngRadio.isSelected() && standard && bandCount == 3 && !mapnik && !elevationRadio.isSelected());
  bandCombo.setEnabled(bandCount > 1 && standard);
  overrideLevelsSpinner.setEnabled(overrideLevelsCheck.isSelected() && standard);
  for (  JIntegerField field : outsideFields) {
    field.setEnabled(outsideCheck.isSelected() && standard);
  }
  replaceCheck.setEnabled(standard && !mapnik);
  replace1Label.setEnabled(replaceCheck.isSelected() && standard);
  replace2Label.setEnabled(replaceCheck.isSelected() && standard);
  replace3Label.setEnabled(replaceCheck.isSelected() && standard);
  replace4Label.setEnabled(replaceCheck.isSelected() && standard);
  for (  JIntegerField field : minFields) {
    field.setEnabled(replaceCheck.isSelected() && standard);
  }
  for (  JIntegerField field : maxFields) {
    field.setEnabled(replaceCheck.isSelected() && standard);
  }
  for (  JIntegerField field : replaceFields) {
    field.setEnabled(replaceCheck.isSelected() && standard);
  }
  for (  JIntegerField field : otherwiseFields) {
    field.setEnabled(replaceCheck.isSelected() && standard);
  }
  gdalRadio.setEnabled(!running);
  mapnikRadio.setEnabled(!running);
  browseGdalButton.setEnabled(!running);
  browseMapnikButton.setEnabled(!running);
  browseMapnikScriptButton.setEnabled(!running);
  browsePythonBinaryButton.setEnabled(!running);
  outputButton.setEnabled(!running);
  outputDirectory.setEnabled(!running);
  tileButton.setEnabled(validOptions && outputDirectory.getText().length() != 0 && !running);
  cancelButton.setEnabled(running);
  progress.setEnabled(running);
  visibledFields();
}","private void enableFields(){
  boolean standard=fileOpen && !running;
  boolean mapnik=mapnikRadio.isSelected();
  byteRadio.setEnabled(standard);
  elevationRadio.setEnabled(standard && !mapnik);
  imageRadio.setEnabled(standard);
  int16Radio.setEnabled(standard);
  int32Radio.setEnabled(standard);
  float32Radio.setEnabled(standard);
  jpegRadio.setEnabled(standard);
  lztsField.setEnabled(standard);
  outsideCheck.setEnabled(standard && !mapnik);
  overviewsCheck.setEnabled(standard);
  overrideLevelsCheck.setEnabled(standard && !mapnik);
  pngRadio.setEnabled(standard);
  tilesizeField.setEnabled(standard);
  for (  JComponent label : labels) {
    label.setEnabled(standard);
  }
  tileTypeLabel.setEnabled(standard);
  imageFormatLabel.setEnabled(standard);
  cellTypeLabel.setEnabled(standard);
  bandLabel.setEnabled(standard);
  levelsLabel.setEnabled(standard && mapnik);
  levelsSpinner.setEnabled(standard && mapnik);
  minLatitudeField.setEnabled(standard);
  maxLatitudeField.setEnabled(standard);
  minLongitudeField.setEnabled(standard);
  maxLongitudeField.setEnabled(standard);
  alphaCheck.setEnabled(pngRadio.isSelected() && standard && bandCount == 3 && !mapnik && !elevationRadio.isSelected());
  bandCombo.setEnabled(bandCount > 1 && standard);
  overrideLevelsSpinner.setEnabled(overrideLevelsCheck.isSelected() && standard);
  for (  JTextField field : outsideFields) {
    field.setEnabled(outsideCheck.isSelected() && standard);
  }
  if (!elevationRadio.isSelected()) {
    outsideCheck.setText(""String_Node_Str"");
  }
 else {
    outsideCheck.setText(""String_Node_Str"");
  }
  replaceCheck.setEnabled(standard && !mapnik);
  replace1Label.setEnabled(replaceCheck.isSelected() && standard);
  replace2Label.setEnabled(replaceCheck.isSelected() && standard);
  replace3Label.setEnabled(replaceCheck.isSelected() && standard);
  replace4Label.setEnabled(replaceCheck.isSelected() && standard);
  for (  JTextField field : minFields) {
    field.setEnabled(replaceCheck.isSelected() && standard);
  }
  for (  JTextField field : maxFields) {
    field.setEnabled(replaceCheck.isSelected() && standard);
  }
  for (  JTextField field : replaceFields) {
    field.setEnabled(replaceCheck.isSelected() && standard);
  }
  for (  JTextField field : otherwiseFields) {
    field.setEnabled(replaceCheck.isSelected() && standard);
  }
  gdalRadio.setEnabled(!running);
  mapnikRadio.setEnabled(!running);
  browseGdalButton.setEnabled(!running);
  browseMapnikButton.setEnabled(!running);
  browseMapnikScriptButton.setEnabled(!running);
  browsePythonBinaryButton.setEnabled(!running);
  outputButton.setEnabled(!running);
  outputDirectory.setEnabled(!running);
  tileButton.setEnabled(validOptions && outputDirectory.getText().length() != 0 && !running);
  cancelButton.setEnabled(running);
  progress.setEnabled(running);
  visibledFields();
}",0.9555873925501432
11192,"public Application(){
  if (!GDALUtil.isProjectionsSupported()) {
    String message=""String_Node_Str"" + ""String_Node_Str"" + GDALUtil.GCS_FILE + ""String_Node_Str""+ ""String_Node_Str"";
    int value=JOptionPane.showConfirmDialog(null,message,""String_Node_Str"",JOptionPane.YES_NO_OPTION,JOptionPane.WARNING_MESSAGE);
    if (value != JOptionPane.YES_OPTION) {
      return;
    }
  }
  JLabel label;
  GridBagConstraints c;
  JScrollPane scrollPane;
  ButtonGroup bg;
  JPanel panel;
  Dimension size;
  ActionListener al;
  JSeparator sep;
  int SPACING=4;
  frame=new JFrame(""String_Node_Str"");
  frame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
  frame.setLayout(new BorderLayout());
  frame.addWindowListener(new WindowAdapter(){
    @Override public void windowClosed(    WindowEvent we){
      onExit();
    }
  }
);
  JPanel tlPanel=new JPanel(new GridBagLayout());
  tlPanel.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  JPanel trPanel=new JPanel(new GridBagLayout());
  trPanel.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  JPanel blPanel=new JPanel(new GridBagLayout());
  blPanel.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  JPanel brPanel=new JPanel(new GridBagLayout());
  brPanel.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  JPanel bPanel=new JPanel(new GridBagLayout());
  leftSplit=new JSplitPane(JSplitPane.VERTICAL_SPLIT,true,tlPanel,blPanel);
  rightSplit=new JSplitPane(JSplitPane.VERTICAL_SPLIT,true,trPanel,brPanel);
  topSplit=new JSplitPane(JSplitPane.HORIZONTAL_SPLIT,true,leftSplit,rightSplit);
  logSplit=new JSplitPane(JSplitPane.VERTICAL_SPLIT,true,topSplit,bPanel);
  panel=new JPanel(new GridBagLayout());
  scrollPane=new JScrollPane(panel,JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED,JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
  c=new GridBagConstraints();
  c.fill=GridBagConstraints.BOTH;
  c.weightx=1;
  c.weighty=1;
  trPanel.add(scrollPane,c);
  trPanel=panel;
  frame.add(logSplit,BorderLayout.CENTER);
  textLog=new JTextPane();
  textLog.setEditable(false);
  scrollPane=new JScrollPane(textLog,JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED,JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);
  c=new GridBagConstraints();
  c.gridx=0;
  c.gridy=0;
  c.fill=GridBagConstraints.BOTH;
  c.weightx=1;
  c.weighty=1;
  bPanel.add(scrollPane,c);
  textLog.getDocument().addDocumentListener(new DocumentAdapter(){
    @Override public void anyChange(    DocumentEvent e){
      int length=textLog.getDocument().getLength();
      textLog.select(length,length);
    }
  }
);
  progress=new JProgressBar(0,100);
  progress.setString(""String_Node_Str"");
  progress.setStringPainted(true);
  c=new GridBagConstraints();
  c.gridx=0;
  c.gridy=1;
  c.fill=GridBagConstraints.HORIZONTAL;
  bPanel.add(progress,c);
  logger=new DocumentLogger(LOGGER,textLog.getStyledDocument());
  LogManager.getLogManager().addLogger(logger);
  createLoggerPopupMenu();
  panel=new JPanel(new GridBagLayout());
  c=new GridBagConstraints();
  c.gridy=0;
  c.anchor=GridBagConstraints.WEST;
  tlPanel.add(panel,c);
  label=new JLabel(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=0;
  c.insets=new Insets(0,0,0,SPACING);
  panel.add(label,c);
  al=new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      datasetModeChanged();
    }
  }
;
  gdalRadio=new JRadioButton(""String_Node_Str"");
  gdalRadio.setSelected(true);
  datasetSelected=gdalRadio;
  c=new GridBagConstraints();
  c.gridx=1;
  panel.add(gdalRadio,c);
  gdalRadio.addActionListener(al);
  mapnikRadio=new JRadioButton(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=2;
  panel.add(mapnikRadio,c);
  mapnikRadio.addActionListener(al);
  bg=new ButtonGroup();
  bg.add(gdalRadio);
  bg.add(mapnikRadio);
  sep=new JSeparator(JSeparator.HORIZONTAL);
  c=new GridBagConstraints();
  c.gridy=1;
  c.fill=GridBagConstraints.HORIZONTAL;
  c.insets=new Insets(SPACING * 2,0,SPACING * 2,0);
  tlPanel.add(sep,c);
  dataModeCards=new JPanel(new CardLayout());
  c=new GridBagConstraints();
  c.gridy=2;
  c.fill=GridBagConstraints.BOTH;
  c.weighty=1;
  c.weightx=1;
  c.anchor=GridBagConstraints.NORTH;
  tlPanel.add(dataModeCards,c);
  JPanel gdalCard=new JPanel(new GridBagLayout());
  dataModeCards.add(gdalCard,gdalRadio.getText());
  JPanel mapnikCard=new JPanel(new GridBagLayout());
  dataModeCards.add(mapnikCard,mapnikRadio.getText());
  panel=new JPanel(new GridBagLayout());
  c=new GridBagConstraints();
  c.gridy=0;
  c.fill=GridBagConstraints.HORIZONTAL;
  gdalCard.add(panel,c);
  label=new JLabel(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=0;
  c.insets=new Insets(0,0,SPACING,SPACING);
  panel.add(label,c);
  gdalFileField=new JTextField();
  gdalFileField.setEnabled(false);
  c=new GridBagConstraints();
  c.gridx=1;
  c.fill=GridBagConstraints.HORIZONTAL;
  c.weightx=1;
  c.insets=new Insets(0,0,SPACING,0);
  panel.add(gdalFileField,c);
  browseGdalButton=new JButton(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=2;
  c.insets=new Insets(0,0,SPACING,0);
  panel.add(browseGdalButton,c);
  browseGdalButton.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      setupInputFile();
    }
  }
);
  infoText=new JTextArea();
  infoText.setBackground(label.getBackground());
  infoText.setEditable(false);
  Font font=Font.decode(null);
  infoText.setFont(font);
  scrollPane=new JScrollPane(infoText,JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED,JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);
  size=new Dimension(20,20);
  scrollPane.setMinimumSize(size);
  scrollPane.setPreferredSize(size);
  c=new GridBagConstraints();
  c.gridy=1;
  c.fill=GridBagConstraints.BOTH;
  c.weightx=1;
  c.weighty=1;
  gdalCard.add(scrollPane,c);
  panel=new JPanel(new GridBagLayout());
  c=new GridBagConstraints();
  c.gridy=0;
  c.fill=GridBagConstraints.HORIZONTAL;
  mapnikCard.add(panel,c);
  label=new JLabel(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=0;
  c.gridy=0;
  c.anchor=GridBagConstraints.EAST;
  c.insets=new Insets(0,0,SPACING,SPACING);
  panel.add(label,c);
  pythonBinaryField=new JTextField();
  pythonBinaryField.setEnabled(false);
  c=new GridBagConstraints();
  c.gridx=1;
  c.gridy=0;
  c.fill=GridBagConstraints.HORIZONTAL;
  c.weightx=1;
  c.insets=new Insets(0,0,SPACING,0);
  panel.add(pythonBinaryField,c);
  browsePythonBinaryButton=new JButton(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=2;
  c.gridy=0;
  c.insets=new Insets(0,0,SPACING,0);
  panel.add(browsePythonBinaryButton,c);
  browsePythonBinaryButton.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      setupPythonBinary();
    }
  }
);
  label=new JLabel(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=0;
  c.gridy=1;
  c.anchor=GridBagConstraints.EAST;
  c.insets=new Insets(0,0,SPACING,SPACING);
  panel.add(label,c);
  mapnikScriptField=new JTextField();
  mapnikScriptField.setEnabled(false);
  c=new GridBagConstraints();
  c.gridx=1;
  c.gridy=1;
  c.fill=GridBagConstraints.HORIZONTAL;
  c.weightx=1;
  c.insets=new Insets(0,0,SPACING,0);
  panel.add(mapnikScriptField,c);
  browseMapnikScriptButton=new JButton(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=2;
  c.gridy=1;
  c.insets=new Insets(0,0,SPACING,0);
  panel.add(browseMapnikScriptButton,c);
  browseMapnikScriptButton.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      setupMapnikScript();
    }
  }
);
  label=new JLabel(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=0;
  c.gridy=2;
  c.anchor=GridBagConstraints.EAST;
  c.insets=new Insets(0,0,0,SPACING);
  panel.add(label,c);
  mapnikFileField=new JTextField();
  mapnikFileField.setEnabled(false);
  c=new GridBagConstraints();
  c.gridx=1;
  c.gridy=2;
  c.fill=GridBagConstraints.HORIZONTAL;
  c.weightx=1;
  panel.add(mapnikFileField,c);
  browseMapnikButton=new JButton(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=2;
  c.gridy=2;
  panel.add(browseMapnikButton,c);
  browseMapnikButton.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      setupInputFile();
    }
  }
);
  sep=new JSeparator(JSeparator.HORIZONTAL);
  c=new GridBagConstraints();
  c.gridy=1;
  c.fill=GridBagConstraints.HORIZONTAL;
  c.insets=new Insets(SPACING * 2,0,SPACING * 2,0);
  mapnikCard.add(sep,c);
  panel=new JPanel(new GridBagLayout());
  c=new GridBagConstraints();
  c.gridy=2;
  c.anchor=GridBagConstraints.NORTH;
  c.fill=GridBagConstraints.HORIZONTAL;
  c.weightx=1;
  c.weighty=1;
  mapnikCard.add(panel,c);
  label=new JLabel(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=0;
  c.gridy=0;
  c.anchor=GridBagConstraints.EAST;
  c.insets=new Insets(0,0,SPACING,SPACING);
  panel.add(label,c);
  labels.add(label);
  minLatitudeField=new JDoubleField(-90d);
  c=new GridBagConstraints();
  c.gridx=1;
  c.gridy=0;
  c.weightx=0.5;
  c.fill=GridBagConstraints.HORIZONTAL;
  c.insets=new Insets(0,0,SPACING,SPACING);
  panel.add(minLatitudeField,c);
  label=new JLabel(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=2;
  c.gridy=0;
  c.anchor=GridBagConstraints.EAST;
  c.insets=new Insets(0,SPACING,SPACING,SPACING);
  panel.add(label,c);
  labels.add(label);
  minLongitudeField=new JDoubleField(-180d);
  c=new GridBagConstraints();
  c.gridx=3;
  c.gridy=0;
  c.weightx=0.5;
  c.fill=GridBagConstraints.HORIZONTAL;
  c.insets=new Insets(0,0,SPACING,0);
  panel.add(minLongitudeField,c);
  label=new JLabel(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=0;
  c.gridy=1;
  c.anchor=GridBagConstraints.EAST;
  c.insets=new Insets(0,0,SPACING,SPACING);
  panel.add(label,c);
  labels.add(label);
  maxLatitudeField=new JDoubleField(90d);
  c=new GridBagConstraints();
  c.gridx=1;
  c.gridy=1;
  c.fill=GridBagConstraints.HORIZONTAL;
  c.insets=new Insets(0,0,SPACING,SPACING);
  panel.add(maxLatitudeField,c);
  label=new JLabel(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=2;
  c.gridy=1;
  c.anchor=GridBagConstraints.EAST;
  c.insets=new Insets(0,SPACING,SPACING,SPACING);
  panel.add(label,c);
  labels.add(label);
  maxLongitudeField=new JDoubleField(180d);
  c=new GridBagConstraints();
  c.gridx=3;
  c.gridy=1;
  c.fill=GridBagConstraints.HORIZONTAL;
  c.insets=new Insets(0,0,SPACING,0);
  panel.add(maxLongitudeField,c);
  previewCanvas=new JLabel();
  previewCanvas.setHorizontalAlignment(SwingConstants.CENTER);
  scrollPane=new JScrollPane(previewCanvas,JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED,JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);
  previewCanvas.setBackground(Color.white);
  c=new GridBagConstraints();
  c.weightx=1;
  c.weighty=1;
  c.fill=GridBagConstraints.BOTH;
  c.anchor=GridBagConstraints.CENTER;
  blPanel.add(scrollPane,c);
  tileTypeLabel=new JLabel(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=0;
  c.gridy=0;
  c.anchor=GridBagConstraints.EAST;
  c.insets=new Insets(0,0,SPACING,SPACING);
  trPanel.add(tileTypeLabel,c);
  panel=new JPanel(new GridBagLayout());
  c=new GridBagConstraints();
  c.gridx=1;
  c.gridy=0;
  c.weightx=1;
  c.anchor=GridBagConstraints.WEST;
  c.insets=new Insets(0,0,SPACING,0);
  trPanel.add(panel,c);
  al=new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      tileTypeChanged();
    }
  }
;
  imageRadio=new JRadioButton(""String_Node_Str"");
  imageRadio.setSelected(true);
  c=new GridBagConstraints();
  c.gridx=0;
  panel.add(imageRadio,c);
  imageRadio.addActionListener(al);
  elevationRadio=new JRadioButton(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=1;
  panel.add(elevationRadio,c);
  elevationRadio.addActionListener(al);
  bg=new ButtonGroup();
  bg.add(imageRadio);
  bg.add(elevationRadio);
  label=new JLabel(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=0;
  c.gridy=1;
  c.anchor=GridBagConstraints.EAST;
  c.insets=new Insets(0,0,SPACING,SPACING);
  trPanel.add(label,c);
  labels.add(label);
  panel=new JPanel(new GridBagLayout());
  c=new GridBagConstraints();
  c.gridx=1;
  c.gridy=1;
  c.anchor=GridBagConstraints.WEST;
  c.insets=new Insets(0,0,SPACING,0);
  trPanel.add(panel,c);
  tilesizeField=new JIntegerField(512);
  tilesizeField.setPositive(true);
  c=new GridBagConstraints();
  c.gridx=0;
  size=tilesizeField.getPreferredSize();
  size.width=50;
  tilesizeField.setMinimumSize(size);
  tilesizeField.setMaximumSize(size);
  tilesizeField.setPreferredSize(size);
  panel.add(tilesizeField,c);
  tilesizeField.getDocument().addDocumentListener(new DocumentAdapter(){
    @Override public void anyChange(    DocumentEvent e){
      if (!tilesizeBeingSet) {
        tilesizeChanged=true;
      }
    }
  }
);
  label=new JLabel(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=1;
  c.insets=new Insets(0,SPACING / 2,0,0);
  panel.add(label,c);
  labels.add(label);
  label=new JLabel(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=0;
  c.gridy=2;
  c.anchor=GridBagConstraints.EAST;
  c.insets=new Insets(0,0,SPACING,SPACING);
  trPanel.add(label,c);
  labels.add(label);
  panel=new JPanel(new GridBagLayout());
  c=new GridBagConstraints();
  c.gridx=1;
  c.gridy=2;
  c.anchor=GridBagConstraints.WEST;
  c.insets=new Insets(0,0,SPACING,0);
  trPanel.add(panel,c);
  lztsField=new JDoubleField(36d);
  c=new GridBagConstraints();
  c.gridx=0;
  size=lztsField.getPreferredSize();
  size.width=50;
  lztsField.setMinimumSize(size);
  lztsField.setMaximumSize(size);
  lztsField.setPreferredSize(size);
  panel.add(lztsField,c);
  lztsField.getDocument().addDocumentListener(new DocumentAdapter(){
    @Override public void anyChange(    DocumentEvent e){
      if (!lztsBeingSet) {
        lztsChanged=true;
      }
    }
  }
);
  label=new JLabel(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=1;
  c.insets=new Insets(0,SPACING / 2,0,0);
  panel.add(label,c);
  labels.add(label);
  levelsLabel=new JLabel(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=0;
  c.gridy=3;
  c.anchor=GridBagConstraints.EAST;
  c.insets=new Insets(0,0,SPACING,SPACING);
  trPanel.add(levelsLabel,c);
  levelsSpinner=new JSpinner(new SpinnerNumberModel(5,1,100,1));
  c=new GridBagConstraints();
  c.gridx=1;
  c.gridy=3;
  c.anchor=GridBagConstraints.WEST;
  c.insets=new Insets(0,0,SPACING,0);
  trPanel.add(levelsSpinner,c);
  imageFormatLabel=new JLabel(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=0;
  c.gridy=4;
  c.anchor=GridBagConstraints.EAST;
  c.insets=new Insets(0,0,SPACING,SPACING);
  trPanel.add(imageFormatLabel,c);
  panel=new JPanel(new GridBagLayout());
  c=new GridBagConstraints();
  c.gridx=1;
  c.gridy=4;
  c.anchor=GridBagConstraints.WEST;
  c.insets=new Insets(0,0,SPACING,0);
  trPanel.add(panel,c);
  al=new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      imageFormatChanged();
    }
  }
;
  jpegRadio=new JRadioButton(""String_Node_Str"");
  jpegRadio.setSelected(true);
  c=new GridBagConstraints();
  c.gridx=0;
  panel.add(jpegRadio,c);
  jpegRadio.addActionListener(al);
  pngRadio=new JRadioButton(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=1;
  panel.add(pngRadio,c);
  pngRadio.addActionListener(al);
  bg=new ButtonGroup();
  bg.add(jpegRadio);
  bg.add(pngRadio);
  alphaCheck=new JCheckBox(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=0;
  c.gridy=5;
  c.anchor=GridBagConstraints.WEST;
  c.gridwidth=2;
  c.insets=new Insets(0,0,SPACING,0);
  trPanel.add(alphaCheck,c);
  alphaCheck.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      alphaSet=alphaCheck.isSelected();
      bandCountChanged();
    }
  }
);
  cellTypeLabel=new JLabel(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=0;
  c.gridy=6;
  c.anchor=GridBagConstraints.EAST;
  c.insets=new Insets(0,0,SPACING,SPACING);
  trPanel.add(cellTypeLabel,c);
  panel=new JPanel(new GridBagLayout());
  c=new GridBagConstraints();
  c.gridx=1;
  c.gridy=6;
  c.anchor=GridBagConstraints.WEST;
  c.insets=new Insets(0,0,SPACING,0);
  trPanel.add(panel,c);
  byteRadio=new JRadioButton(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=0;
  panel.add(byteRadio,c);
  int16Radio=new JRadioButton(""String_Node_Str"");
  int16Radio.setSelected(true);
  c=new GridBagConstraints();
  c.gridx=1;
  panel.add(int16Radio,c);
  int32Radio=new JRadioButton(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=2;
  panel.add(int32Radio,c);
  bg=new ButtonGroup();
  bg.add(byteRadio);
  bg.add(int16Radio);
  bg.add(int32Radio);
  bandLabel=new JLabel(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=0;
  c.gridy=7;
  c.anchor=GridBagConstraints.EAST;
  c.insets=new Insets(0,0,SPACING,SPACING);
  trPanel.add(bandLabel,c);
  panel=new JPanel(new GridBagLayout());
  c=new GridBagConstraints();
  c.gridx=1;
  c.gridy=7;
  c.anchor=GridBagConstraints.WEST;
  c.insets=new Insets(0,0,SPACING,0);
  trPanel.add(panel,c);
  bandCombo=new JComboBox(new Integer[]{1});
  bandCombo.setSelectedIndex(0);
  c=new GridBagConstraints();
  c.gridx=0;
  panel.add(bandCombo,c);
  overviewsCheck=new JCheckBox(""String_Node_Str"");
  overviewsCheck.setSelected(true);
  c=new GridBagConstraints();
  c.gridx=0;
  c.gridy=8;
  c.gridwidth=2;
  c.anchor=GridBagConstraints.WEST;
  c.insets=new Insets(0,0,SPACING,0);
  trPanel.add(overviewsCheck,c);
  panel=new JPanel(new GridBagLayout());
  c=new GridBagConstraints();
  c.gridx=0;
  c.gridy=9;
  c.gridwidth=2;
  c.anchor=GridBagConstraints.WEST;
  trPanel.add(panel,c);
  overrideLevelsCheck=new JCheckBox(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=0;
  c.insets=new Insets(0,0,SPACING,SPACING);
  panel.add(overrideLevelsCheck,c);
  overrideLevelsCheck.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      if (mapnikRadio.isSelected() && !overrideLevelsCheck.isSelected()) {
        overrideLevelsCheck.setSelected(true);
      }
      enableFields();
    }
  }
);
  overrideLevelsSpinner=new JSpinner(new SpinnerNumberModel(1,1,100,1));
  c=new GridBagConstraints();
  c.gridx=1;
  c.insets=new Insets(0,0,SPACING,0);
  panel.add(overrideLevelsSpinner,c);
  outsideCheck=new JCheckBox(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=0;
  c.gridy=10;
  c.gridwidth=2;
  c.anchor=GridBagConstraints.WEST;
  trPanel.add(outsideCheck,c);
  outsideCheck.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      enableFields();
    }
  }
);
  outsidePanel=new JPanel(new GridBagLayout());
  c=new GridBagConstraints();
  c.gridx=1;
  c.gridy=11;
  c.anchor=GridBagConstraints.WEST;
  c.insets=new Insets(0,0,SPACING,0);
  trPanel.add(outsidePanel,c);
  replaceCheck=new JCheckBox(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=0;
  c.gridy=12;
  c.gridwidth=2;
  c.anchor=GridBagConstraints.WEST;
  trPanel.add(replaceCheck,c);
  replaceCheck.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      enableFields();
    }
  }
);
  replace1Label=new JLabel(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=0;
  c.gridy=13;
  c.anchor=GridBagConstraints.EAST;
  c.insets=new Insets(0,0,SPACING,SPACING);
  trPanel.add(replace1Label,c);
  minPanel=new JPanel(new GridBagLayout());
  c=new GridBagConstraints();
  c.gridx=1;
  c.gridy=13;
  c.anchor=GridBagConstraints.WEST;
  c.insets=new Insets(0,0,SPACING,0);
  trPanel.add(minPanel,c);
  replace2Label=new JLabel(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=0;
  c.gridy=14;
  c.anchor=GridBagConstraints.EAST;
  c.insets=new Insets(0,0,SPACING,SPACING);
  trPanel.add(replace2Label,c);
  maxPanel=new JPanel(new GridBagLayout());
  c=new GridBagConstraints();
  c.gridx=1;
  c.gridy=14;
  c.anchor=GridBagConstraints.WEST;
  c.insets=new Insets(0,0,SPACING,0);
  trPanel.add(maxPanel,c);
  replace3Label=new JLabel(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=0;
  c.gridy=15;
  c.anchor=GridBagConstraints.EAST;
  c.insets=new Insets(0,0,SPACING,SPACING);
  trPanel.add(replace3Label,c);
  withPanel=new JPanel(new GridBagLayout());
  c=new GridBagConstraints();
  c.gridx=1;
  c.gridy=15;
  c.anchor=GridBagConstraints.WEST;
  c.insets=new Insets(0,0,SPACING,0);
  trPanel.add(withPanel,c);
  replace4Label=new JLabel(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=0;
  c.gridy=16;
  c.anchor=GridBagConstraints.EAST;
  c.insets=new Insets(0,0,SPACING,SPACING);
  trPanel.add(replace4Label,c);
  otherwisePanel=new JPanel(new GridBagLayout());
  c=new GridBagConstraints();
  c.gridx=1;
  c.gridy=16;
  c.anchor=GridBagConstraints.WEST;
  c.insets=new Insets(0,0,SPACING,0);
  trPanel.add(otherwisePanel,c);
  panel=new JPanel(new GridBagLayout());
  c=new GridBagConstraints();
  c.gridx=0;
  c.gridy=17;
  c.weighty=1;
  trPanel.add(panel,c);
  panel=new JPanel(new GridBagLayout());
  c=new GridBagConstraints();
  c.gridx=0;
  c.gridy=0;
  c.fill=GridBagConstraints.HORIZONTAL;
  brPanel.add(panel,c);
  label=new JLabel(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=0;
  c.insets=new Insets(0,0,SPACING,SPACING);
  panel.add(label,c);
  final String outputDirKey=""String_Node_Str"";
  outputDirectory=new JTextField();
  c=new GridBagConstraints();
  c.gridx=1;
  c.fill=GridBagConstraints.HORIZONTAL;
  c.weightx=1;
  c.insets=new Insets(0,0,SPACING,0);
  panel.add(outputDirectory,c);
  outputDirectory.getDocument().addDocumentListener(new DocumentAdapter(){
    @Override public void anyChange(    DocumentEvent e){
      String text=outputDirectory.getText();
      File dir=new File(text);
      if (dir.isDirectory()) {
        preferences.put(outputDirKey,text);
      }
    }
  }
);
  outputButton=new JButton(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=2;
  c.insets=new Insets(0,0,SPACING,0);
  panel.add(outputButton,c);
  outputButton.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      JFileChooser chooser=new JFileChooser(preferences.get(outputDirKey,null));
      chooser.setAcceptAllFileFilterUsed(false);
      chooser.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY);
      if (chooser.showOpenDialog(frame) == JFileChooser.APPROVE_OPTION) {
        File dir=chooser.getSelectedFile();
        outputDirectory.setText(dir.getAbsolutePath());
        preferences.put(outputDirKey,dir.getAbsolutePath());
      }
    }
  }
);
  tileText=new JTextArea();
  tileText.setBackground(label.getBackground());
  tileText.setEditable(false);
  tileText.setFont(font);
  scrollPane=new JScrollPane(tileText,JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED,JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);
  size=new Dimension(20,20);
  scrollPane.setMinimumSize(size);
  scrollPane.setPreferredSize(size);
  c=new GridBagConstraints();
  c.gridx=0;
  c.gridy=1;
  c.fill=GridBagConstraints.BOTH;
  c.weighty=1;
  c.weightx=1;
  c.anchor=GridBagConstraints.NORTH;
  c.insets=new Insets(0,0,SPACING,0);
  brPanel.add(scrollPane,c);
  panel=new JPanel(new GridBagLayout());
  c=new GridBagConstraints();
  c.gridx=0;
  c.gridy=2;
  brPanel.add(panel,c);
  tileButton=new JButton(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=0;
  c.insets=new Insets(0,0,0,SPACING);
  panel.add(tileButton,c);
  tileButton.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      generateTiles();
    }
  }
);
  cancelButton=new JButton(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=1;
  panel.add(cancelButton,c);
  cancelButton.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      cancel();
    }
  }
);
  updatePythonFields();
  addRecalculateListeners();
  openDataset(null);
  datasetModeChanged();
  logger.info(""String_Node_Str"");
  if (!GDALUtil.isProjectionsSupported()) {
    logger.warning(""String_Node_Str"");
  }
  loadFrameBounds();
  loadSplitLocations();
  frame.setVisible(true);
}","public Application(){
  if (!GDALUtil.isProjectionsSupported()) {
    String message=""String_Node_Str"" + ""String_Node_Str"" + GDALUtil.GCS_FILE + ""String_Node_Str""+ ""String_Node_Str"";
    int value=JOptionPane.showConfirmDialog(null,message,""String_Node_Str"",JOptionPane.YES_NO_OPTION,JOptionPane.WARNING_MESSAGE);
    if (value != JOptionPane.YES_OPTION) {
      return;
    }
  }
  JLabel label;
  GridBagConstraints c;
  JScrollPane scrollPane;
  ButtonGroup bg;
  JPanel panel;
  Dimension size;
  ActionListener al;
  JSeparator sep;
  int SPACING=4;
  frame=new JFrame(""String_Node_Str"");
  frame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);
  frame.setLayout(new BorderLayout());
  frame.addWindowListener(new WindowAdapter(){
    @Override public void windowClosed(    WindowEvent we){
      onExit();
    }
  }
);
  JPanel tlPanel=new JPanel(new GridBagLayout());
  tlPanel.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  JPanel trPanel=new JPanel(new GridBagLayout());
  trPanel.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  JPanel blPanel=new JPanel(new GridBagLayout());
  blPanel.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  JPanel brPanel=new JPanel(new GridBagLayout());
  brPanel.setBorder(BorderFactory.createTitledBorder(""String_Node_Str""));
  JPanel bPanel=new JPanel(new GridBagLayout());
  leftSplit=new JSplitPane(JSplitPane.VERTICAL_SPLIT,true,tlPanel,blPanel);
  rightSplit=new JSplitPane(JSplitPane.VERTICAL_SPLIT,true,trPanel,brPanel);
  topSplit=new JSplitPane(JSplitPane.HORIZONTAL_SPLIT,true,leftSplit,rightSplit);
  logSplit=new JSplitPane(JSplitPane.VERTICAL_SPLIT,true,topSplit,bPanel);
  panel=new JPanel(new GridBagLayout());
  scrollPane=new JScrollPane(panel,JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED,JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
  c=new GridBagConstraints();
  c.fill=GridBagConstraints.BOTH;
  c.weightx=1;
  c.weighty=1;
  trPanel.add(scrollPane,c);
  trPanel=panel;
  frame.add(logSplit,BorderLayout.CENTER);
  textLog=new JTextPane();
  textLog.setEditable(false);
  scrollPane=new JScrollPane(textLog,JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED,JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);
  c=new GridBagConstraints();
  c.gridx=0;
  c.gridy=0;
  c.fill=GridBagConstraints.BOTH;
  c.weightx=1;
  c.weighty=1;
  bPanel.add(scrollPane,c);
  textLog.getDocument().addDocumentListener(new DocumentAdapter(){
    @Override public void anyChange(    DocumentEvent e){
      int length=textLog.getDocument().getLength();
      textLog.select(length,length);
    }
  }
);
  progress=new JProgressBar(0,100);
  progress.setString(""String_Node_Str"");
  progress.setStringPainted(true);
  c=new GridBagConstraints();
  c.gridx=0;
  c.gridy=1;
  c.fill=GridBagConstraints.HORIZONTAL;
  bPanel.add(progress,c);
  logger=new DocumentLogger(LOGGER,textLog.getStyledDocument());
  LogManager.getLogManager().addLogger(logger);
  createLoggerPopupMenu();
  panel=new JPanel(new GridBagLayout());
  c=new GridBagConstraints();
  c.gridy=0;
  c.anchor=GridBagConstraints.WEST;
  tlPanel.add(panel,c);
  label=new JLabel(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=0;
  c.insets=new Insets(0,0,0,SPACING);
  panel.add(label,c);
  al=new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      datasetModeChanged();
    }
  }
;
  gdalRadio=new JRadioButton(""String_Node_Str"");
  gdalRadio.setSelected(true);
  datasetSelected=gdalRadio;
  c=new GridBagConstraints();
  c.gridx=1;
  panel.add(gdalRadio,c);
  gdalRadio.addActionListener(al);
  mapnikRadio=new JRadioButton(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=2;
  panel.add(mapnikRadio,c);
  mapnikRadio.addActionListener(al);
  bg=new ButtonGroup();
  bg.add(gdalRadio);
  bg.add(mapnikRadio);
  sep=new JSeparator(JSeparator.HORIZONTAL);
  c=new GridBagConstraints();
  c.gridy=1;
  c.fill=GridBagConstraints.HORIZONTAL;
  c.insets=new Insets(SPACING * 2,0,SPACING * 2,0);
  tlPanel.add(sep,c);
  dataModeCards=new JPanel(new CardLayout());
  c=new GridBagConstraints();
  c.gridy=2;
  c.fill=GridBagConstraints.BOTH;
  c.weighty=1;
  c.weightx=1;
  c.anchor=GridBagConstraints.NORTH;
  tlPanel.add(dataModeCards,c);
  JPanel gdalCard=new JPanel(new GridBagLayout());
  dataModeCards.add(gdalCard,gdalRadio.getText());
  JPanel mapnikCard=new JPanel(new GridBagLayout());
  dataModeCards.add(mapnikCard,mapnikRadio.getText());
  panel=new JPanel(new GridBagLayout());
  c=new GridBagConstraints();
  c.gridy=0;
  c.fill=GridBagConstraints.HORIZONTAL;
  gdalCard.add(panel,c);
  label=new JLabel(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=0;
  c.insets=new Insets(0,0,SPACING,SPACING);
  panel.add(label,c);
  gdalFileField=new JTextField();
  gdalFileField.setEnabled(false);
  c=new GridBagConstraints();
  c.gridx=1;
  c.fill=GridBagConstraints.HORIZONTAL;
  c.weightx=1;
  c.insets=new Insets(0,0,SPACING,0);
  panel.add(gdalFileField,c);
  browseGdalButton=new JButton(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=2;
  c.insets=new Insets(0,0,SPACING,0);
  panel.add(browseGdalButton,c);
  browseGdalButton.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      setupInputFile();
    }
  }
);
  infoText=new JTextArea();
  infoText.setBackground(label.getBackground());
  infoText.setEditable(false);
  Font font=Font.decode(null);
  infoText.setFont(font);
  scrollPane=new JScrollPane(infoText,JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED,JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);
  size=new Dimension(20,20);
  scrollPane.setMinimumSize(size);
  scrollPane.setPreferredSize(size);
  c=new GridBagConstraints();
  c.gridy=1;
  c.fill=GridBagConstraints.BOTH;
  c.weightx=1;
  c.weighty=1;
  gdalCard.add(scrollPane,c);
  panel=new JPanel(new GridBagLayout());
  c=new GridBagConstraints();
  c.gridy=0;
  c.fill=GridBagConstraints.HORIZONTAL;
  mapnikCard.add(panel,c);
  label=new JLabel(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=0;
  c.gridy=0;
  c.anchor=GridBagConstraints.EAST;
  c.insets=new Insets(0,0,SPACING,SPACING);
  panel.add(label,c);
  pythonBinaryField=new JTextField();
  pythonBinaryField.setEnabled(false);
  c=new GridBagConstraints();
  c.gridx=1;
  c.gridy=0;
  c.fill=GridBagConstraints.HORIZONTAL;
  c.weightx=1;
  c.insets=new Insets(0,0,SPACING,0);
  panel.add(pythonBinaryField,c);
  browsePythonBinaryButton=new JButton(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=2;
  c.gridy=0;
  c.insets=new Insets(0,0,SPACING,0);
  panel.add(browsePythonBinaryButton,c);
  browsePythonBinaryButton.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      setupPythonBinary();
    }
  }
);
  label=new JLabel(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=0;
  c.gridy=1;
  c.anchor=GridBagConstraints.EAST;
  c.insets=new Insets(0,0,SPACING,SPACING);
  panel.add(label,c);
  mapnikScriptField=new JTextField();
  mapnikScriptField.setEnabled(false);
  c=new GridBagConstraints();
  c.gridx=1;
  c.gridy=1;
  c.fill=GridBagConstraints.HORIZONTAL;
  c.weightx=1;
  c.insets=new Insets(0,0,SPACING,0);
  panel.add(mapnikScriptField,c);
  browseMapnikScriptButton=new JButton(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=2;
  c.gridy=1;
  c.insets=new Insets(0,0,SPACING,0);
  panel.add(browseMapnikScriptButton,c);
  browseMapnikScriptButton.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      setupMapnikScript();
    }
  }
);
  label=new JLabel(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=0;
  c.gridy=2;
  c.anchor=GridBagConstraints.EAST;
  c.insets=new Insets(0,0,0,SPACING);
  panel.add(label,c);
  mapnikFileField=new JTextField();
  mapnikFileField.setEnabled(false);
  c=new GridBagConstraints();
  c.gridx=1;
  c.gridy=2;
  c.fill=GridBagConstraints.HORIZONTAL;
  c.weightx=1;
  panel.add(mapnikFileField,c);
  browseMapnikButton=new JButton(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=2;
  c.gridy=2;
  panel.add(browseMapnikButton,c);
  browseMapnikButton.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      setupInputFile();
    }
  }
);
  sep=new JSeparator(JSeparator.HORIZONTAL);
  c=new GridBagConstraints();
  c.gridy=1;
  c.fill=GridBagConstraints.HORIZONTAL;
  c.insets=new Insets(SPACING * 2,0,SPACING * 2,0);
  mapnikCard.add(sep,c);
  panel=new JPanel(new GridBagLayout());
  c=new GridBagConstraints();
  c.gridy=2;
  c.anchor=GridBagConstraints.NORTH;
  c.fill=GridBagConstraints.HORIZONTAL;
  c.weightx=1;
  c.weighty=1;
  mapnikCard.add(panel,c);
  label=new JLabel(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=0;
  c.gridy=0;
  c.anchor=GridBagConstraints.EAST;
  c.insets=new Insets(0,0,SPACING,SPACING);
  panel.add(label,c);
  labels.add(label);
  minLatitudeField=new JDoubleField(-90d);
  c=new GridBagConstraints();
  c.gridx=1;
  c.gridy=0;
  c.weightx=0.5;
  c.fill=GridBagConstraints.HORIZONTAL;
  c.insets=new Insets(0,0,SPACING,SPACING);
  panel.add(minLatitudeField,c);
  label=new JLabel(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=2;
  c.gridy=0;
  c.anchor=GridBagConstraints.EAST;
  c.insets=new Insets(0,SPACING,SPACING,SPACING);
  panel.add(label,c);
  labels.add(label);
  minLongitudeField=new JDoubleField(-180d);
  c=new GridBagConstraints();
  c.gridx=3;
  c.gridy=0;
  c.weightx=0.5;
  c.fill=GridBagConstraints.HORIZONTAL;
  c.insets=new Insets(0,0,SPACING,0);
  panel.add(minLongitudeField,c);
  label=new JLabel(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=0;
  c.gridy=1;
  c.anchor=GridBagConstraints.EAST;
  c.insets=new Insets(0,0,SPACING,SPACING);
  panel.add(label,c);
  labels.add(label);
  maxLatitudeField=new JDoubleField(90d);
  c=new GridBagConstraints();
  c.gridx=1;
  c.gridy=1;
  c.fill=GridBagConstraints.HORIZONTAL;
  c.insets=new Insets(0,0,SPACING,SPACING);
  panel.add(maxLatitudeField,c);
  label=new JLabel(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=2;
  c.gridy=1;
  c.anchor=GridBagConstraints.EAST;
  c.insets=new Insets(0,SPACING,SPACING,SPACING);
  panel.add(label,c);
  labels.add(label);
  maxLongitudeField=new JDoubleField(180d);
  c=new GridBagConstraints();
  c.gridx=3;
  c.gridy=1;
  c.fill=GridBagConstraints.HORIZONTAL;
  c.insets=new Insets(0,0,SPACING,0);
  panel.add(maxLongitudeField,c);
  previewCanvas=new JLabel();
  previewCanvas.setHorizontalAlignment(SwingConstants.CENTER);
  scrollPane=new JScrollPane(previewCanvas,JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED,JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);
  previewCanvas.setBackground(Color.white);
  c=new GridBagConstraints();
  c.weightx=1;
  c.weighty=1;
  c.fill=GridBagConstraints.BOTH;
  c.anchor=GridBagConstraints.CENTER;
  blPanel.add(scrollPane,c);
  tileTypeLabel=new JLabel(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=0;
  c.gridy=0;
  c.anchor=GridBagConstraints.EAST;
  c.insets=new Insets(0,0,SPACING,SPACING);
  trPanel.add(tileTypeLabel,c);
  panel=new JPanel(new GridBagLayout());
  c=new GridBagConstraints();
  c.gridx=1;
  c.gridy=0;
  c.weightx=1;
  c.anchor=GridBagConstraints.WEST;
  c.insets=new Insets(0,0,SPACING,0);
  trPanel.add(panel,c);
  al=new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      tileTypeChanged();
    }
  }
;
  imageRadio=new JRadioButton(""String_Node_Str"");
  imageRadio.setSelected(true);
  c=new GridBagConstraints();
  c.gridx=0;
  panel.add(imageRadio,c);
  imageRadio.addActionListener(al);
  elevationRadio=new JRadioButton(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=1;
  panel.add(elevationRadio,c);
  elevationRadio.addActionListener(al);
  bg=new ButtonGroup();
  bg.add(imageRadio);
  bg.add(elevationRadio);
  label=new JLabel(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=0;
  c.gridy=1;
  c.anchor=GridBagConstraints.EAST;
  c.insets=new Insets(0,0,SPACING,SPACING);
  trPanel.add(label,c);
  labels.add(label);
  panel=new JPanel(new GridBagLayout());
  c=new GridBagConstraints();
  c.gridx=1;
  c.gridy=1;
  c.anchor=GridBagConstraints.WEST;
  c.insets=new Insets(0,0,SPACING,0);
  trPanel.add(panel,c);
  tilesizeField=new JIntegerField(512);
  tilesizeField.setPositive(true);
  c=new GridBagConstraints();
  c.gridx=0;
  size=tilesizeField.getPreferredSize();
  size.width=50;
  tilesizeField.setMinimumSize(size);
  tilesizeField.setMaximumSize(size);
  tilesizeField.setPreferredSize(size);
  panel.add(tilesizeField,c);
  tilesizeField.getDocument().addDocumentListener(new DocumentAdapter(){
    @Override public void anyChange(    DocumentEvent e){
      if (!tilesizeBeingSet) {
        tilesizeChanged=true;
      }
    }
  }
);
  tilesizeField.addFocusListener(new FocusAdapter(){
    @Override public void focusLost(    FocusEvent e){
      tilesizeChanged();
    }
  }
);
  label=new JLabel(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=1;
  c.insets=new Insets(0,SPACING / 2,0,0);
  panel.add(label,c);
  labels.add(label);
  label=new JLabel(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=0;
  c.gridy=2;
  c.anchor=GridBagConstraints.EAST;
  c.insets=new Insets(0,0,SPACING,SPACING);
  trPanel.add(label,c);
  labels.add(label);
  panel=new JPanel(new GridBagLayout());
  c=new GridBagConstraints();
  c.gridx=1;
  c.gridy=2;
  c.anchor=GridBagConstraints.WEST;
  c.insets=new Insets(0,0,SPACING,0);
  trPanel.add(panel,c);
  lztsField=new JDoubleField(36d);
  c=new GridBagConstraints();
  c.gridx=0;
  size=lztsField.getPreferredSize();
  size.width=50;
  lztsField.setMinimumSize(size);
  lztsField.setMaximumSize(size);
  lztsField.setPreferredSize(size);
  panel.add(lztsField,c);
  lztsField.getDocument().addDocumentListener(new DocumentAdapter(){
    @Override public void anyChange(    DocumentEvent e){
      if (!lztsBeingSet) {
        lztsChanged=true;
      }
    }
  }
);
  label=new JLabel(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=1;
  c.insets=new Insets(0,SPACING / 2,0,0);
  panel.add(label,c);
  labels.add(label);
  levelsLabel=new JLabel(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=0;
  c.gridy=3;
  c.anchor=GridBagConstraints.EAST;
  c.insets=new Insets(0,0,SPACING,SPACING);
  trPanel.add(levelsLabel,c);
  levelsSpinner=new JSpinner(new SpinnerNumberModel(5,1,100,1));
  c=new GridBagConstraints();
  c.gridx=1;
  c.gridy=3;
  c.anchor=GridBagConstraints.WEST;
  c.insets=new Insets(0,0,SPACING,0);
  trPanel.add(levelsSpinner,c);
  imageFormatLabel=new JLabel(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=0;
  c.gridy=4;
  c.anchor=GridBagConstraints.EAST;
  c.insets=new Insets(0,0,SPACING,SPACING);
  trPanel.add(imageFormatLabel,c);
  panel=new JPanel(new GridBagLayout());
  c=new GridBagConstraints();
  c.gridx=1;
  c.gridy=4;
  c.anchor=GridBagConstraints.WEST;
  c.insets=new Insets(0,0,SPACING,0);
  trPanel.add(panel,c);
  al=new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      imageFormatChanged();
    }
  }
;
  jpegRadio=new JRadioButton(""String_Node_Str"");
  jpegRadio.setSelected(true);
  c=new GridBagConstraints();
  c.gridx=0;
  panel.add(jpegRadio,c);
  jpegRadio.addActionListener(al);
  pngRadio=new JRadioButton(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=1;
  panel.add(pngRadio,c);
  pngRadio.addActionListener(al);
  bg=new ButtonGroup();
  bg.add(jpegRadio);
  bg.add(pngRadio);
  alphaCheck=new JCheckBox(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=0;
  c.gridy=5;
  c.anchor=GridBagConstraints.WEST;
  c.gridwidth=2;
  c.insets=new Insets(0,0,SPACING,0);
  trPanel.add(alphaCheck,c);
  alphaCheck.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      alphaSet=alphaCheck.isSelected();
      bandCountChanged();
    }
  }
);
  cellTypeLabel=new JLabel(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=0;
  c.gridy=6;
  c.anchor=GridBagConstraints.EAST;
  c.insets=new Insets(0,0,SPACING,SPACING);
  trPanel.add(cellTypeLabel,c);
  panel=new JPanel(new GridBagLayout());
  c=new GridBagConstraints();
  c.gridx=1;
  c.gridy=6;
  c.anchor=GridBagConstraints.WEST;
  c.insets=new Insets(0,0,SPACING,0);
  trPanel.add(panel,c);
  al=new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      elevationFormatChanged();
    }
  }
;
  byteRadio=new JRadioButton(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=0;
  panel.add(byteRadio,c);
  byteRadio.addActionListener(al);
  int16Radio=new JRadioButton(""String_Node_Str"");
  int16Radio.setSelected(true);
  c=new GridBagConstraints();
  c.gridx=1;
  panel.add(int16Radio,c);
  int16Radio.addActionListener(al);
  int32Radio=new JRadioButton(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=2;
  panel.add(int32Radio,c);
  int32Radio.addActionListener(al);
  float32Radio=new JRadioButton(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=3;
  panel.add(float32Radio,c);
  float32Radio.addActionListener(al);
  bg=new ButtonGroup();
  bg.add(byteRadio);
  bg.add(int16Radio);
  bg.add(int32Radio);
  bg.add(float32Radio);
  bandLabel=new JLabel(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=0;
  c.gridy=7;
  c.anchor=GridBagConstraints.EAST;
  c.insets=new Insets(0,0,SPACING,SPACING);
  trPanel.add(bandLabel,c);
  panel=new JPanel(new GridBagLayout());
  c=new GridBagConstraints();
  c.gridx=1;
  c.gridy=7;
  c.anchor=GridBagConstraints.WEST;
  c.insets=new Insets(0,0,SPACING,0);
  trPanel.add(panel,c);
  bandCombo=new JComboBox(new Integer[]{1});
  bandCombo.setSelectedIndex(0);
  c=new GridBagConstraints();
  c.gridx=0;
  panel.add(bandCombo,c);
  overviewsCheck=new JCheckBox(""String_Node_Str"");
  overviewsCheck.setSelected(true);
  c=new GridBagConstraints();
  c.gridx=0;
  c.gridy=8;
  c.gridwidth=2;
  c.anchor=GridBagConstraints.WEST;
  c.insets=new Insets(0,0,SPACING,0);
  trPanel.add(overviewsCheck,c);
  panel=new JPanel(new GridBagLayout());
  c=new GridBagConstraints();
  c.gridx=0;
  c.gridy=9;
  c.gridwidth=2;
  c.anchor=GridBagConstraints.WEST;
  trPanel.add(panel,c);
  overrideLevelsCheck=new JCheckBox(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=0;
  c.insets=new Insets(0,0,SPACING,SPACING);
  panel.add(overrideLevelsCheck,c);
  overrideLevelsCheck.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      if (mapnikRadio.isSelected() && !overrideLevelsCheck.isSelected()) {
        overrideLevelsCheck.setSelected(true);
      }
      enableFields();
    }
  }
);
  overrideLevelsSpinner=new JSpinner(new SpinnerNumberModel(1,1,100,1));
  c=new GridBagConstraints();
  c.gridx=1;
  c.insets=new Insets(0,0,SPACING,0);
  panel.add(overrideLevelsSpinner,c);
  outsideCheck=new JCheckBox(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=0;
  c.gridy=10;
  c.gridwidth=2;
  c.anchor=GridBagConstraints.WEST;
  trPanel.add(outsideCheck,c);
  outsideCheck.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      enableFields();
    }
  }
);
  outsidePanel=new JPanel(new GridBagLayout());
  c=new GridBagConstraints();
  c.gridx=1;
  c.gridy=11;
  c.anchor=GridBagConstraints.WEST;
  c.insets=new Insets(0,0,SPACING,0);
  trPanel.add(outsidePanel,c);
  replaceCheck=new JCheckBox(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=0;
  c.gridy=12;
  c.gridwidth=2;
  c.anchor=GridBagConstraints.WEST;
  trPanel.add(replaceCheck,c);
  replaceCheck.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      enableFields();
    }
  }
);
  replace1Label=new JLabel(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=0;
  c.gridy=13;
  c.anchor=GridBagConstraints.EAST;
  c.insets=new Insets(0,0,SPACING,SPACING);
  trPanel.add(replace1Label,c);
  minPanel=new JPanel(new GridBagLayout());
  c=new GridBagConstraints();
  c.gridx=1;
  c.gridy=13;
  c.anchor=GridBagConstraints.WEST;
  c.insets=new Insets(0,0,SPACING,0);
  trPanel.add(minPanel,c);
  replace2Label=new JLabel(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=0;
  c.gridy=14;
  c.anchor=GridBagConstraints.EAST;
  c.insets=new Insets(0,0,SPACING,SPACING);
  trPanel.add(replace2Label,c);
  maxPanel=new JPanel(new GridBagLayout());
  c=new GridBagConstraints();
  c.gridx=1;
  c.gridy=14;
  c.anchor=GridBagConstraints.WEST;
  c.insets=new Insets(0,0,SPACING,0);
  trPanel.add(maxPanel,c);
  replace3Label=new JLabel(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=0;
  c.gridy=15;
  c.anchor=GridBagConstraints.EAST;
  c.insets=new Insets(0,0,SPACING,SPACING);
  trPanel.add(replace3Label,c);
  withPanel=new JPanel(new GridBagLayout());
  c=new GridBagConstraints();
  c.gridx=1;
  c.gridy=15;
  c.anchor=GridBagConstraints.WEST;
  c.insets=new Insets(0,0,SPACING,0);
  trPanel.add(withPanel,c);
  replace4Label=new JLabel(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=0;
  c.gridy=16;
  c.anchor=GridBagConstraints.EAST;
  c.insets=new Insets(0,0,SPACING,SPACING);
  trPanel.add(replace4Label,c);
  otherwisePanel=new JPanel(new GridBagLayout());
  c=new GridBagConstraints();
  c.gridx=1;
  c.gridy=16;
  c.anchor=GridBagConstraints.WEST;
  c.insets=new Insets(0,0,SPACING,0);
  trPanel.add(otherwisePanel,c);
  panel=new JPanel(new GridBagLayout());
  c=new GridBagConstraints();
  c.gridx=0;
  c.gridy=17;
  c.weighty=1;
  trPanel.add(panel,c);
  panel=new JPanel(new GridBagLayout());
  c=new GridBagConstraints();
  c.gridx=0;
  c.gridy=0;
  c.fill=GridBagConstraints.HORIZONTAL;
  brPanel.add(panel,c);
  label=new JLabel(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=0;
  c.insets=new Insets(0,0,SPACING,SPACING);
  panel.add(label,c);
  final String outputDirKey=""String_Node_Str"";
  outputDirectory=new JTextField();
  c=new GridBagConstraints();
  c.gridx=1;
  c.fill=GridBagConstraints.HORIZONTAL;
  c.weightx=1;
  c.insets=new Insets(0,0,SPACING,0);
  panel.add(outputDirectory,c);
  outputDirectory.getDocument().addDocumentListener(new DocumentAdapter(){
    @Override public void anyChange(    DocumentEvent e){
      String text=outputDirectory.getText();
      File dir=new File(text);
      if (dir.isDirectory()) {
        preferences.put(outputDirKey,text);
      }
    }
  }
);
  outputButton=new JButton(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=2;
  c.insets=new Insets(0,0,SPACING,0);
  panel.add(outputButton,c);
  outputButton.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      JFileChooser chooser=new JFileChooser(preferences.get(outputDirKey,null));
      chooser.setAcceptAllFileFilterUsed(false);
      chooser.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY);
      if (chooser.showOpenDialog(frame) == JFileChooser.APPROVE_OPTION) {
        File dir=chooser.getSelectedFile();
        outputDirectory.setText(dir.getAbsolutePath());
        preferences.put(outputDirKey,dir.getAbsolutePath());
      }
    }
  }
);
  tileText=new JTextArea();
  tileText.setBackground(label.getBackground());
  tileText.setEditable(false);
  tileText.setFont(font);
  scrollPane=new JScrollPane(tileText,JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED,JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);
  size=new Dimension(20,20);
  scrollPane.setMinimumSize(size);
  scrollPane.setPreferredSize(size);
  c=new GridBagConstraints();
  c.gridx=0;
  c.gridy=1;
  c.fill=GridBagConstraints.BOTH;
  c.weighty=1;
  c.weightx=1;
  c.anchor=GridBagConstraints.NORTH;
  c.insets=new Insets(0,0,SPACING,0);
  brPanel.add(scrollPane,c);
  panel=new JPanel(new GridBagLayout());
  c=new GridBagConstraints();
  c.gridx=0;
  c.gridy=2;
  brPanel.add(panel,c);
  tileButton=new JButton(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=0;
  c.insets=new Insets(0,0,0,SPACING);
  panel.add(tileButton,c);
  tileButton.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      generateTiles();
    }
  }
);
  cancelButton=new JButton(""String_Node_Str"");
  c=new GridBagConstraints();
  c.gridx=1;
  panel.add(cancelButton,c);
  cancelButton.addActionListener(new ActionListener(){
    public void actionPerformed(    ActionEvent e){
      cancel();
    }
  }
);
  updatePythonFields();
  addRecalculateListeners();
  openDataset(null);
  datasetModeChanged();
  logger.info(""String_Node_Str"");
  if (!GDALUtil.isProjectionsSupported()) {
    logger.warning(""String_Node_Str"");
  }
  loadFrameBounds();
  loadSplitLocations();
  frame.setVisible(true);
}",0.9885038661375444
11193,"private static <E extends Buffer>E selectBuffer(E src0,E src1,E src2,E src3,int x,int y,int w,int h){
  return (x < w / 2) ? (y < h / 2 ? src1 : src0) : (y < h / 2 ? src3 : src2);
}","private <E extends Buffer>E selectBuffer(E src0,E src1,E src2,E src3,int x,int y,int w,int h){
  return (x < w / 2) ? (y < h / 2 ? src1 : src0) : (y < h / 2 ? src3 : src2);
}",0.9802816901408452
11194,"private static ByteBuffer getFileChannelAsByteBuffer(FileChannel fileChannel,int length,ByteOrder byteOrder) throws IOException {
  ByteBuffer bb=ByteBuffer.allocate(length);
  bb.order(byteOrder);
  fileChannel.read(bb);
  bb.rewind();
  return bb;
}","private ByteBuffer getFileChannelAsByteBuffer(FileChannel fileChannel,int length,ByteOrder byteOrder) throws IOException {
  ByteBuffer bb=ByteBuffer.allocate(length);
  bb.order(byteOrder);
  fileChannel.read(bb);
  bb.rewind();
  return bb;
}",0.985858585858586
11195,"public static void createElevationOverviews(File directory,int width,int height,int bufferType,ByteOrder byteOrder,int[] outsideValues,Sector sector,double lzts,ProgressReporter reporter){
  createOverviews(true,directory,""String_Node_Str"",width,height,bufferType,byteOrder,outsideValues,sector,lzts,reporter);
}","public static void createElevationOverviews(File directory,int width,int height,int bufferType,ByteOrder byteOrder,NumberArray outsideValues,Sector sector,double lzts,ProgressReporter reporter){
  int bands=1;
  OverviewCreator overviewCreator=new ElevationOverviewCreator(width,height,bands,bufferType,byteOrder,outsideValues);
  createOverviews(overviewCreator,directory,""String_Node_Str"",sector,lzts,reporter);
}",0.6602475928473177
11196,"public static void createImageOverviews(File directory,String extension,int width,int height,int[] outsideValues,Sector sector,double lzts,ProgressReporter reporter){
  createOverviews(false,directory,extension,width,height,1,null,outsideValues,sector,lzts,reporter);
}","public static void createImageOverviews(File directory,String extension,int width,int height,NumberArray outsideValues,Sector sector,double lzts,ProgressReporter reporter){
  OverviewCreator overviewCreator=new ImageOverviewCreator(width,height,outsideValues);
  createOverviews(overviewCreator,directory,extension,sector,lzts,reporter);
}",0.7171052631578947
11197,"private static void createOverviews(boolean elevations,File directory,String extension,int width,int height,int bufferType,ByteOrder byteOrder,int[] outsideValues,Sector sector,double lzts,ProgressReporter progress){
  progress.getLogger().info(""String_Node_Str"");
  if (directory.isDirectory()) {
    if (extension.startsWith(""String_Node_Str"")) {
      extension=extension.substring(1);
    }
    int bufferTypeSize=1;
    if (elevations) {
      bufferTypeSize=gdal.GetDataTypeSize(bufferType);
      bufferTypeSize/=4;
      if (bufferTypeSize != 1 && bufferTypeSize != 2 && bufferTypeSize != 4) {
        throw new IllegalArgumentException(""String_Node_Str"");
      }
    }
    ByteBuffer outsideBuffer=null;
    BufferedImage outsideImage=null;
    if (outsideValues != null) {
      int bandCount=outsideValues.length;
      int[] offsets=new int[bandCount];
      byte[] bytes=new byte[bandCount * width * height* bufferTypeSize];
      outsideBuffer=ByteBuffer.wrap(bytes);
      for (int b=0; b < bandCount; b++) {
        offsets[b]=b * width * height* bufferTypeSize;
        for (int i=0; i < width * height; i++) {
          int index=offsets[b] + i;
switch (bufferTypeSize) {
case 1:
            outsideBuffer.put(index,(byte)outsideValues[b]);
          break;
case 2:
        outsideBuffer.putShort(index,(short)outsideValues[b]);
      break;
case 4:
    outsideBuffer.putInt(index,outsideValues[b]);
  break;
}
}
}
if (!elevations) {
DataBuffer buffer=new DataBufferByte(bytes,bytes.length);
SampleModel sampleModel=new ComponentSampleModel(DataBuffer.TYPE_BYTE,width,height,1,width,offsets);
WritableRaster raster=Raster.createWritableRaster(sampleModel,buffer,null);
int imageType=bandCount == 1 ? BufferedImage.TYPE_BYTE_GRAY : bandCount == 3 ? BufferedImage.TYPE_INT_RGB : BufferedImage.TYPE_INT_ARGB_PRE;
outsideImage=new BufferedImage(width,height,imageType);
outsideImage.setData(raster);
}
}
File[] dirs=directory.listFiles(new DirectoryFileFilter());
int maxlevel=Integer.MIN_VALUE;
for (int i=0; i < dirs.length; i++) {
try {
int num=Integer.parseInt(dirs[i].getName());
if (num > maxlevel) {
maxlevel=num;
}
}
 catch (NumberFormatException e) {
}
}
int count=0;
int size=0;
for (int i=0; i < maxlevel; i++) {
size+=GDALUtil.tileCount(sector,maxlevel,lzts);
}
for (int level=maxlevel; level > 0; level--) {
if (progress.isCancelled()) break;
File dir=new File(directory.getAbsolutePath() + ""String_Node_Str"" + level);
ExtensionFileFilter fileFilter=new ExtensionFileFilter(extension);
Set<File> sourceFiles=new HashSet<File>();
FileUtil.recursivelyAddFiles(sourceFiles,dir,fileFilter);
while (!sourceFiles.isEmpty()) {
if (progress.isCancelled()) break;
count++;
progress.getLogger().fine(""String_Node_Str"" + count + ""String_Node_Str""+ size+ ""String_Node_Str""+ (count * 100 / size)+ ""String_Node_Str"");
progress.progress(count / (double)size);
File file=sourceFiles.iterator().next();
String path=file.getName();
Pattern pattern=Pattern.compile(""String_Node_Str"");
Matcher matcher=pattern.matcher(path);
matcher.find();
int row=Integer.parseInt(matcher.group());
matcher.find(matcher.end());
int col=Integer.parseInt(matcher.group());
int rowabove=row / 2;
int colabove=col / 2;
final File src0=tileFile(dir,extension,rowabove * 2,colabove * 2);
final File src1=tileFile(dir,extension,rowabove * 2 + 1,colabove * 2);
final File src2=tileFile(dir,extension,rowabove * 2,colabove * 2 + 1);
final File src3=tileFile(dir,extension,rowabove * 2 + 1,colabove * 2 + 1);
sourceFiles.remove(src0);
sourceFiles.remove(src1);
sourceFiles.remove(src2);
sourceFiles.remove(src3);
final File dst=tileFile(new File(dir.getParent() + ""String_Node_Str"" + (level - 1)),extension,rowabove,colabove);
dst.getParentFile().mkdirs();
if (dst.exists()) {
progress.getLogger().warning(dst.getAbsolutePath() + ""String_Node_Str"");
}
 else {
try {
if (elevations) {
  mixElevations(src0,src1,src2,src3,dst,width,height,bufferTypeSize,byteOrder,outsideValues);
}
 else {
  mixImages(src0,src1,src2,src3,dst,width,height,outsideImage);
}
}
 catch (IOException e) {
progress.getLogger().severe(e.getMessage());
}
}
}
}
}
progress.getLogger().info(""String_Node_Str"" + (progress.isCancelled() ? ""String_Node_Str"" : ""String_Node_Str""));
}","private static void createOverviews(OverviewCreator overviewCreator,File directory,String extension,Sector sector,double lzts,ProgressReporter progress){
  progress.getLogger().info(""String_Node_Str"");
  if (directory.isDirectory()) {
    if (extension.startsWith(""String_Node_Str"")) {
      extension=extension.substring(1);
    }
    File[] dirs=directory.listFiles(new DirectoryFileFilter());
    int maxlevel=Integer.MIN_VALUE;
    for (int i=0; i < dirs.length; i++) {
      try {
        int num=Integer.parseInt(dirs[i].getName());
        if (num > maxlevel) {
          maxlevel=num;
        }
      }
 catch (      NumberFormatException e) {
      }
    }
    int count=0;
    int size=0;
    for (int i=0; i < maxlevel; i++) {
      size+=GDALUtil.tileCount(sector,i,lzts);
    }
    for (int level=maxlevel; level > 0; level--) {
      if (progress.isCancelled())       break;
      File dir=new File(directory.getAbsolutePath() + ""String_Node_Str"" + level);
      ExtensionFileFilter fileFilter=new ExtensionFileFilter(extension);
      Set<File> sourceFiles=new HashSet<File>();
      FileUtil.recursivelyAddFiles(sourceFiles,dir,fileFilter);
      while (!sourceFiles.isEmpty()) {
        if (progress.isCancelled())         break;
        count++;
        progress.getLogger().fine(""String_Node_Str"" + count + ""String_Node_Str""+ size+ ""String_Node_Str""+ (count * 100 / size)+ ""String_Node_Str"");
        progress.progress(count / (double)size);
        File file=sourceFiles.iterator().next();
        String path=file.getName();
        Pattern pattern=Pattern.compile(""String_Node_Str"");
        Matcher matcher=pattern.matcher(path);
        matcher.find();
        int row=Integer.parseInt(matcher.group());
        matcher.find(matcher.end());
        int col=Integer.parseInt(matcher.group());
        int rowabove=row / 2;
        int colabove=col / 2;
        final File src0=tileFile(dir,extension,rowabove * 2,colabove * 2);
        final File src1=tileFile(dir,extension,rowabove * 2 + 1,colabove * 2);
        final File src2=tileFile(dir,extension,rowabove * 2,colabove * 2 + 1);
        final File src3=tileFile(dir,extension,rowabove * 2 + 1,colabove * 2 + 1);
        sourceFiles.remove(src0);
        sourceFiles.remove(src1);
        sourceFiles.remove(src2);
        sourceFiles.remove(src3);
        final File dst=tileFile(new File(dir.getParent() + ""String_Node_Str"" + (level - 1)),extension,rowabove,colabove);
        dst.getParentFile().mkdirs();
        if (dst.exists()) {
          progress.getLogger().warning(dst.getAbsolutePath() + ""String_Node_Str"");
        }
 else {
          try {
            overviewCreator.mix(src0,src1,src2,src3,dst);
          }
 catch (          IOException e) {
            progress.getLogger().severe(e.getMessage());
          }
        }
      }
    }
  }
  progress.getLogger().info(""String_Node_Str"" + (progress.isCancelled() ? ""String_Node_Str"" : ""String_Node_Str""));
}",0.6041202672605791
11198,"public static void tileElevations(Dataset dataset,Sector sector,int level,int tilesize,double lzts,int bufferType,int band,int[] outsideValues,int[] minReplace,int[] maxReplace,Integer[] replace,Integer[] otherwise,File outputDirectory,ProgressReporter progress){
  tile(Type.Elevations,dataset,null,sector,level,tilesize,lzts,null,false,bufferType,band,outsideValues,minReplace,maxReplace,replace,otherwise,outputDirectory,progress);
}","public static void tileElevations(Dataset dataset,Sector sector,int level,int tilesize,double lzts,int bufferType,int band,NumberArray outsideValues,NumberArray minReplace,NumberArray maxReplace,NullableNumberArray replace,NullableNumberArray otherwise,NumberArray minMax,File outputDirectory,ProgressReporter progress){
  tile(Type.Elevations,dataset,null,sector,level,tilesize,lzts,null,false,bufferType,band,outsideValues,minReplace,maxReplace,replace,otherwise,minMax,outputDirectory,progress);
}",0.8418803418803419
11199,"private static void tile(Type type,Dataset dataset,File mapFile,Sector sector,int level,int tilesize,double lzts,String imageFormat,boolean addAlpha,int bufferType,int band,int[] outsideValues,int[] minReplace,int[] maxReplace,Integer[] replace,Integer[] otherwise,File outputDirectory,ProgressReporter progress){
  progress.getLogger().info(""String_Node_Str"");
  String outputExt=type == Type.Elevations ? ""String_Node_Str"" : imageFormat;
  double tilesizedegrees=Math.pow(0.5,level) * lzts;
  int minX=GDALUtil.getTileX(sector.getMinLongitude() + 1e-10,level,lzts);
  int maxX=GDALUtil.getTileX(sector.getMaxLongitude() - 1e-10,level,lzts);
  int minY=GDALUtil.getTileY(sector.getMinLatitude() + 1e-10,level,lzts);
  int maxY=GDALUtil.getTileY(sector.getMaxLatitude() - 1e-10,level,lzts);
  int size=(maxX - minX + 1) * (maxY - minY + 1);
  int count=0;
  for (int Y=minY; Y <= maxY; Y++) {
    if (progress.isCancelled())     break;
    File rowDir=new File(outputDirectory,String.valueOf(level));
    rowDir=new File(rowDir,GDALUtil.paddedInt(Y,4));
    if (!rowDir.exists()) {
      rowDir.mkdirs();
    }
    for (int X=minX; X <= maxX; X++) {
      if (progress.isCancelled())       break;
      count++;
      progress.getLogger().fine(""String_Node_Str"" + X + ""String_Node_Str""+ Y+ ""String_Node_Str""+ count+ ""String_Node_Str""+ size+ ""String_Node_Str""+ (count * 100 / size)+ ""String_Node_Str""+ (X - minX + 1)+ ""String_Node_Str""+ (maxX - minX + 1)+ ""String_Node_Str""+ (Y - minY + 1)+ ""String_Node_Str""+ (maxY - minY + 1)+ ""String_Node_Str"");
      progress.progress(count / (double)size);
      final double lat1=(Y * tilesizedegrees) - 90;
      final double lon1=(X * tilesizedegrees) - 180;
      final double lat2=lat1 + tilesizedegrees;
      final double lon2=lon1 + tilesizedegrees;
      final File dst=new File(rowDir,GDALUtil.paddedInt(Y,4) + ""String_Node_Str"" + GDALUtil.paddedInt(X,4)+ ""String_Node_Str""+ outputExt);
      if (dst.exists()) {
        progress.getLogger().warning(dst.getAbsolutePath() + ""String_Node_Str"");
      }
 else {
        try {
          if (type == Type.Mapnik) {
            Sector s=new Sector(lat1,lon1,lat2,lon2);
            MapnikUtil.tile(s,tilesize,tilesize,mapFile,dst,progress.getLogger());
          }
 else {
            GDALTile tile=new GDALTile(dataset,tilesize,tilesize,lat1,lon1,lat2,lon2,addAlpha,band);
            if (type == Type.Elevations) {
              tile=tile.convertToType(bufferType);
            }
            if (outsideValues != null) {
              tile.fillOutside(outsideValues);
            }
            if (minReplace != null && maxReplace != null && replace != null) {
              tile.replaceValues(minReplace,maxReplace,replace,otherwise);
            }
            if (type == Type.Elevations) {
              ByteBuffer bb=tile.getBuffer();
              bb.rewind();
              FileChannel fc=new RandomAccessFile(dst,""String_Node_Str"").getChannel();
              MappedByteBuffer mbb=fc.map(MapMode.READ_WRITE,0,bb.limit());
              mbb.order(bb.order());
              mbb.put(bb);
              fc.close();
            }
 else {
              BufferedImage image=tile.getAsImage();
              ImageIO.write(image,outputExt,dst);
            }
          }
        }
 catch (        Exception e) {
          progress.getLogger().severe(e.getMessage());
          try {
            Thread.sleep(1);
          }
 catch (          InterruptedException e1) {
            e1.printStackTrace();
          }
        }
      }
    }
  }
  progress.getLogger().info(""String_Node_Str"" + (progress.isCancelled() ? ""String_Node_Str"" : ""String_Node_Str""));
}","private static void tile(Type type,Dataset dataset,File mapFile,Sector sector,int level,int tilesize,double lzts,String imageFormat,boolean addAlpha,int bufferType,int band,NumberArray outsideValues,NumberArray minReplace,NumberArray maxReplace,NullableNumberArray replace,NullableNumberArray otherwise,NumberArray minMax,File outputDirectory,ProgressReporter progress){
  progress.getLogger().info(""String_Node_Str"");
  String outputExt=type == Type.Elevations ? ""String_Node_Str"" : imageFormat;
  double tilesizedegrees=Math.pow(0.5,level) * lzts;
  int minX=GDALUtil.getTileX(sector.getMinLongitude() + 1e-10,level,lzts);
  int maxX=GDALUtil.getTileX(sector.getMaxLongitude() - 1e-10,level,lzts);
  int minY=GDALUtil.getTileY(sector.getMinLatitude() + 1e-10,level,lzts);
  int maxY=GDALUtil.getTileY(sector.getMaxLatitude() - 1e-10,level,lzts);
  int size=(maxX - minX + 1) * (maxY - minY + 1);
  int count=0;
  for (int Y=minY; Y <= maxY; Y++) {
    if (progress.isCancelled())     break;
    File rowDir=new File(outputDirectory,String.valueOf(level));
    rowDir=new File(rowDir,GDALUtil.paddedInt(Y,4));
    if (!rowDir.exists()) {
      rowDir.mkdirs();
    }
    for (int X=minX; X <= maxX; X++) {
      if (progress.isCancelled())       break;
      count++;
      progress.getLogger().fine(""String_Node_Str"" + X + ""String_Node_Str""+ Y+ ""String_Node_Str""+ count+ ""String_Node_Str""+ size+ ""String_Node_Str""+ (count * 100 / size)+ ""String_Node_Str""+ (X - minX + 1)+ ""String_Node_Str""+ (maxX - minX + 1)+ ""String_Node_Str""+ (Y - minY + 1)+ ""String_Node_Str""+ (maxY - minY + 1)+ ""String_Node_Str"");
      progress.progress(count / (double)size);
      final double lat1=(Y * tilesizedegrees) - 90;
      final double lon1=(X * tilesizedegrees) - 180;
      final double lat2=lat1 + tilesizedegrees;
      final double lon2=lon1 + tilesizedegrees;
      final File dst=new File(rowDir,GDALUtil.paddedInt(Y,4) + ""String_Node_Str"" + GDALUtil.paddedInt(X,4)+ ""String_Node_Str""+ outputExt);
      if (dst.exists()) {
        progress.getLogger().warning(dst.getAbsolutePath() + ""String_Node_Str"");
      }
 else {
        try {
          if (type == Type.Mapnik) {
            Sector s=new Sector(lat1,lon1,lat2,lon2);
            MapnikUtil.tile(s,tilesize,tilesize,mapFile,dst,progress.getLogger());
          }
 else {
            GDALTile tile=new GDALTile(dataset,tilesize,tilesize,lat1,lon1,lat2,lon2,addAlpha,band);
            if (type == Type.Elevations) {
              tile=tile.convertToType(bufferType);
            }
            if (outsideValues != null) {
              tile.fillOutside(outsideValues);
            }
            if (minReplace != null && maxReplace != null && replace != null && otherwise != null) {
              tile.replaceValues(minReplace,maxReplace,replace,otherwise);
            }
            if (type == Type.Elevations) {
              tile.updateMinMax(minMax,outsideValues);
              ByteBuffer bb=tile.getBuffer();
              bb.rewind();
              RandomAccessFile raf=null;
              try {
                raf=new RandomAccessFile(dst,""String_Node_Str"");
                MappedByteBuffer mbb=raf.getChannel().map(MapMode.READ_WRITE,0,bb.limit());
                mbb.order(bb.order());
                mbb.put(bb);
              }
  finally {
                if (raf != null)                 raf.close();
              }
            }
 else {
              BufferedImage image=tile.getAsImage();
              ImageIO.write(image,outputExt,dst);
            }
          }
        }
 catch (        Exception e) {
          progress.getLogger().severe(e.getMessage());
          try {
            Thread.sleep(1);
          }
 catch (          InterruptedException e1) {
            e1.printStackTrace();
          }
        }
      }
    }
  }
  progress.getLogger().info(""String_Node_Str"" + (progress.isCancelled() ? ""String_Node_Str"" : ""String_Node_Str""));
}",0.9242544206914752
11200,"public static void tileImages(Dataset dataset,Sector sector,int level,int tilesize,double lzts,String imageFormat,boolean addAlpha,int[] outsideValues,int[] minReplace,int[] maxReplace,Integer[] replace,Integer[] otherwise,File outputDirectory,ProgressReporter progress){
  tile(Type.Images,dataset,null,sector,level,tilesize,lzts,imageFormat,addAlpha,-1,-1,outsideValues,minReplace,maxReplace,replace,otherwise,outputDirectory,progress);
}","public static void tileImages(Dataset dataset,Sector sector,int level,int tilesize,double lzts,String imageFormat,boolean addAlpha,NumberArray outsideValues,NumberArray minReplace,NumberArray maxReplace,NullableNumberArray replace,NullableNumberArray otherwise,File outputDirectory,ProgressReporter progress){
  tile(Type.Images,dataset,null,sector,level,tilesize,lzts,imageFormat,addAlpha,-1,-1,outsideValues,minReplace,maxReplace,replace,otherwise,null,outputDirectory,progress);
}",0.8624052004333694
11201,"public static void tileMapnik(File mapFile,Sector sector,int level,int tilesize,double lzts,String imageFormat,File outputDirectory,ProgressReporter progress){
  tile(Type.Mapnik,null,mapFile,sector,level,tilesize,lzts,imageFormat,false,-1,-1,null,null,null,null,null,outputDirectory,progress);
}","public static void tileMapnik(File mapFile,Sector sector,int level,int tilesize,double lzts,String imageFormat,File outputDirectory,ProgressReporter progress){
  tile(Type.Mapnik,null,mapFile,sector,level,tilesize,lzts,imageFormat,false,-1,-1,null,null,null,null,null,null,outputDirectory,progress);
}",0.9916247906197656
11202,"public TilerConsole() throws Exception {
  File file=new File(""String_Node_Str"");
  File outputDir=new File(""String_Node_Str"");
  String outputExt=""String_Node_Str"";
  double lztd=20d;
  int tilesize=150;
  int outside=-9999;
  boolean overviews=true;
  boolean saveAlpha=false;
  int outputType=gdalconstConstants.GDT_Int16;
  Dataset dataset=GDALUtil.open(file);
  Sector sector=GDALUtil.getSector(dataset);
  int levels=GDALUtil.levelCount(dataset,lztd,sector,tilesize);
  double width=dataset.getRasterXSize();
  double height=dataset.getRasterYSize();
  int bufferType=1;
  int[] outsidea=null;
  int level=levels - 1;
  double tilesizedegrees=Math.pow(0.5,level) * lztd;
  System.out.println(""String_Node_Str"" + level + ""String_Node_Str""+ tilesizedegrees+ ""String_Node_Str""+ (tilesizedegrees * height / sector.getDeltaLongitude())+ ""String_Node_Str""+ (tilesizedegrees * width / sector.getDeltaLatitude())+ ""String_Node_Str"");
  int minX=GDALUtil.getTileX(sector.getMinLongitude(),level,lztd);
  int maxX=GDALUtil.getTileX(sector.getMaxLongitude(),level,lztd);
  int minY=GDALUtil.getTileY(sector.getMinLatitude(),level,lztd);
  int maxY=GDALUtil.getTileY(sector.getMaxLatitude(),level,lztd);
  ProgressReporter progress=new SimpleProgressReporter();
  int size=(maxX - minX + 1) * (maxY - minY + 1);
  int count=0;
  for (int Y=minY; Y <= maxY; Y++) {
    File rowDir=new File(outputDir,String.valueOf(level));
    rowDir=new File(rowDir,GDALUtil.paddedInt(Y,4));
    if (!rowDir.exists()) {
      rowDir.mkdirs();
    }
    for (int X=minX; X <= maxX; X++) {
      count++;
      System.out.println(""String_Node_Str"" + X + ""String_Node_Str""+ Y+ ""String_Node_Str""+ count+ ""String_Node_Str""+ size+ ""String_Node_Str""+ (count * 100 / size)+ ""String_Node_Str""+ (X - minX + 1)+ ""String_Node_Str""+ (maxX - minX + 1)+ ""String_Node_Str""+ (Y - minY + 1)+ ""String_Node_Str""+ (maxY - minY + 1)+ ""String_Node_Str"");
      final double lat1=(Y * tilesizedegrees) - 90;
      final double lon1=(X * tilesizedegrees) - 180;
      final double lat2=lat1 + tilesizedegrees;
      final double lon2=lon1 + tilesizedegrees;
      final File dst=new File(rowDir,GDALUtil.paddedInt(Y,4) + ""String_Node_Str"" + GDALUtil.paddedInt(X,4)+ ""String_Node_Str""+ outputExt);
      if (dst.exists()) {
        System.out.println(dst.getAbsolutePath() + ""String_Node_Str"");
      }
 else {
        GDALTile tile=new GDALTile(dataset,tilesize,tilesize,lat1,lon1,lat2,lon2,saveAlpha,-1);
        tile=tile.convertToType(outputType);
        outsidea=new int[tile.getBandCount()];
        for (int i=0; i < tile.getBandCount(); i++)         outsidea[i]=outside;
        tile.fillOutside(outsidea);
        bufferType=tile.getBufferType();
        if (outputExt.toLowerCase().equals(""String_Node_Str"")) {
          try {
            ByteBuffer bb=tile.getBuffer();
            bb.rewind();
            FileChannel fc=new RandomAccessFile(dst,""String_Node_Str"").getChannel();
            MappedByteBuffer mbb=fc.map(MapMode.READ_WRITE,0,bb.limit());
            mbb.order(bb.order());
            mbb.put(bb);
            fc.close();
          }
 catch (          IOException e) {
            e.printStackTrace();
          }
        }
 else {
          BufferedImage image=tile.getAsImage();
          try {
            ImageIO.write(image,outputExt,dst);
          }
 catch (          IOException e) {
            e.printStackTrace();
          }
        }
      }
    }
  }
  if (overviews) {
    System.out.println();
    System.out.println(""String_Node_Str"");
    if (outputExt.toLowerCase().equals(""String_Node_Str"")) {
      Overviewer.createElevationOverviews(outputDir,tilesize,tilesize,bufferType,ByteOrder.LITTLE_ENDIAN,outsidea,sector,lztd,progress);
    }
 else {
      Overviewer.createImageOverviews(outputDir,outputExt,tilesize,tilesize,outsidea,sector,lztd,progress);
    }
  }
  System.out.println(""String_Node_Str"");
}","public TilerConsole() throws Exception {
  File file=new File(""String_Node_Str"");
  File outputDir=new File(""String_Node_Str"");
  String outputExt=""String_Node_Str"";
  double lztd=20d;
  int tilesize=150;
  long outside=-9999;
  boolean overviews=true;
  boolean saveAlpha=false;
  int outputType=gdalconstConstants.GDT_Int16;
  Dataset dataset=GDALUtil.open(file);
  Sector sector=GDALUtil.getSector(dataset);
  int levels=GDALUtil.levelCount(dataset,lztd,sector,tilesize);
  double width=dataset.getRasterXSize();
  double height=dataset.getRasterYSize();
  int bufferType=1;
  NumberArray outsidea=null;
  int level=levels - 1;
  double tilesizedegrees=Math.pow(0.5,level) * lztd;
  System.out.println(""String_Node_Str"" + level + ""String_Node_Str""+ tilesizedegrees+ ""String_Node_Str""+ (tilesizedegrees * height / sector.getDeltaLongitude())+ ""String_Node_Str""+ (tilesizedegrees * width / sector.getDeltaLatitude())+ ""String_Node_Str"");
  int minX=GDALUtil.getTileX(sector.getMinLongitude(),level,lztd);
  int maxX=GDALUtil.getTileX(sector.getMaxLongitude(),level,lztd);
  int minY=GDALUtil.getTileY(sector.getMinLatitude(),level,lztd);
  int maxY=GDALUtil.getTileY(sector.getMaxLatitude(),level,lztd);
  ProgressReporter progress=new SimpleProgressReporter();
  int size=(maxX - minX + 1) * (maxY - minY + 1);
  int count=0;
  for (int Y=minY; Y <= maxY; Y++) {
    File rowDir=new File(outputDir,String.valueOf(level));
    rowDir=new File(rowDir,GDALUtil.paddedInt(Y,4));
    if (!rowDir.exists()) {
      rowDir.mkdirs();
    }
    for (int X=minX; X <= maxX; X++) {
      count++;
      System.out.println(""String_Node_Str"" + X + ""String_Node_Str""+ Y+ ""String_Node_Str""+ count+ ""String_Node_Str""+ size+ ""String_Node_Str""+ (count * 100 / size)+ ""String_Node_Str""+ (X - minX + 1)+ ""String_Node_Str""+ (maxX - minX + 1)+ ""String_Node_Str""+ (Y - minY + 1)+ ""String_Node_Str""+ (maxY - minY + 1)+ ""String_Node_Str"");
      final double lat1=(Y * tilesizedegrees) - 90;
      final double lon1=(X * tilesizedegrees) - 180;
      final double lat2=lat1 + tilesizedegrees;
      final double lon2=lon1 + tilesizedegrees;
      final File dst=new File(rowDir,GDALUtil.paddedInt(Y,4) + ""String_Node_Str"" + GDALUtil.paddedInt(X,4)+ ""String_Node_Str""+ outputExt);
      if (dst.exists()) {
        System.out.println(dst.getAbsolutePath() + ""String_Node_Str"");
      }
 else {
        GDALTile tile=new GDALTile(dataset,tilesize,tilesize,lat1,lon1,lat2,lon2,saveAlpha,-1);
        tile=tile.convertToType(outputType);
        outsidea=new NumberArray(tile.getBandCount());
        for (int i=0; i < tile.getBandCount(); i++)         outsidea.setLong(i,outside);
        tile.fillOutside(outsidea);
        bufferType=tile.getBufferType();
        if (outputExt.toLowerCase().equals(""String_Node_Str"")) {
          try {
            ByteBuffer bb=tile.getBuffer();
            bb.rewind();
            FileChannel fc=new RandomAccessFile(dst,""String_Node_Str"").getChannel();
            MappedByteBuffer mbb=fc.map(MapMode.READ_WRITE,0,bb.limit());
            mbb.order(bb.order());
            mbb.put(bb);
            fc.close();
          }
 catch (          IOException e) {
            e.printStackTrace();
          }
        }
 else {
          BufferedImage image=tile.getAsImage();
          try {
            ImageIO.write(image,outputExt,dst);
          }
 catch (          IOException e) {
            e.printStackTrace();
          }
        }
      }
    }
  }
  if (overviews) {
    System.out.println();
    System.out.println(""String_Node_Str"");
    if (outputExt.toLowerCase().equals(""String_Node_Str"")) {
      Overviewer.createElevationOverviews(outputDir,tilesize,tilesize,bufferType,ByteOrder.LITTLE_ENDIAN,outsidea,sector,lztd,progress);
    }
 else {
      Overviewer.createImageOverviews(outputDir,outputExt,tilesize,tilesize,outsidea,sector,lztd,progress);
    }
  }
  System.out.println(""String_Node_Str"");
}",0.990935784501468
11203,"private static void takeScreenshotThread(final WorldWindow wwd,int width,int height,File file){
  if (!(wwd instanceof Component))   throw new IllegalArgumentException();
  Component component=(Component)wwd;
  Container parent=component.getParent();
  JFrame frame=new JFrame();
  frame.setLayout(new BorderLayout());
  frame.setUndecorated(true);
  frame.setResizable(false);
  frame.setAlwaysOnTop(false);
  frame.add(component,BorderLayout.CENTER);
  Dimension size=new Dimension(width,height);
  component.setMinimumSize(size);
  component.setMaximumSize(size);
  component.setPreferredSize(size);
  frame.setSize(size);
  frame.setVisible(true);
  GraphicsDevice device=GraphicsEnvironment.getLocalGraphicsEnvironment().getDefaultScreenDevice();
  DisplayMode displayMode=device.getDisplayMode();
  int displayWidth=displayMode.getWidth();
  int displayHeight=displayMode.getHeight();
  final int rows=(width - 1) / displayWidth + 1;
  final int columns=(height - 1) / displayHeight + 1;
  BufferedImage bi=new BufferedImage(width,height,BufferedImage.TYPE_INT_RGB);
  final Graphics2D g2d=bi.createGraphics();
  for (int x=0; x < rows; x++) {
    for (int y=0; y < columns; y++) {
      final int xOffset=x * displayWidth;
      final int yOffset=y * displayHeight;
      final int screenshotWidth=Math.min(width - xOffset,displayWidth);
      final int screenshotHeight=Math.min(height - yOffset,displayHeight);
      frame.setLocation(-xOffset,-yOffset);
      BufferedImage shot=takeShot(wwd,0,0,width,height);
      g2d.drawImage(shot,xOffset,yOffset,xOffset + screenshotWidth,yOffset + screenshotHeight,xOffset,yOffset,xOffset + screenshotWidth,yOffset + screenshotHeight,null);
    }
  }
  g2d.dispose();
  String filename=file.getName();
  int dot=filename.lastIndexOf('.');
  String extension=filename.substring(dot + 1,filename.length());
  try {
    ImageIO.write(bi,extension,file);
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
  parent.add(component,BorderLayout.CENTER);
  frame.dispose();
}","private static void takeScreenshotThread(WorldWindow wwd,int width,int height,File file){
  if (!(wwd instanceof Component))   throw new IllegalArgumentException();
  Component component=(Component)wwd;
  Container parent=component.getParent();
  JFrame frame=new JFrame();
  frame.setLayout(new BorderLayout());
  frame.setUndecorated(true);
  frame.setResizable(false);
  frame.setAlwaysOnTop(true);
  frame.add(component,BorderLayout.CENTER);
  Dimension size=new Dimension(width,height);
  component.setMinimumSize(size);
  component.setMaximumSize(size);
  component.setPreferredSize(size);
  frame.setSize(size);
  frame.setVisible(true);
  GraphicsDevice device=GraphicsEnvironment.getLocalGraphicsEnvironment().getDefaultScreenDevice();
  DisplayMode displayMode=device.getDisplayMode();
  int displayWidth=displayMode.getWidth();
  int displayHeight=displayMode.getHeight();
  final int rows=(width - 1) / displayWidth + 1;
  final int columns=(height - 1) / displayHeight + 1;
  BufferedImage bi=new BufferedImage(width,height,BufferedImage.TYPE_INT_RGB);
  final Graphics2D g2d=bi.createGraphics();
  for (int x=0; x < rows; x++) {
    for (int y=0; y < columns; y++) {
      final int xOffset=x * displayWidth;
      final int yOffset=y * displayHeight;
      final int screenshotWidth=Math.min(width - xOffset,displayWidth);
      final int screenshotHeight=Math.min(height - yOffset,displayHeight);
      frame.setLocation(-xOffset,-yOffset);
      BufferedImage shot=takeShot(wwd,0,0,width,height);
      g2d.drawImage(shot,xOffset,yOffset,xOffset + screenshotWidth,yOffset + screenshotHeight,xOffset,yOffset,xOffset + screenshotWidth,yOffset + screenshotHeight,null);
    }
  }
  g2d.dispose();
  String filename=file.getName();
  int dot=filename.lastIndexOf('.');
  String extension=filename.substring(dot + 1,filename.length());
  try {
    ImageIO.write(bi,extension,file);
  }
 catch (  IOException e) {
    e.printStackTrace();
  }
  parent.add(component,BorderLayout.CENTER);
  frame.dispose();
}",0.9967861557478368
11204,"public MaskUrlBuilder(File localTextureDir,File localMaskDir,String textureExtension,String maskExtension){
  this.localTextureDir=localTextureDir;
  this.localMaskDir=localMaskDir;
  this.textureExtension=(textureExtension.startsWith(""String_Node_Str"") ? ""String_Node_Str"" : ""String_Node_Str"") + textureExtension;
  this.maskExtension=(maskExtension.startsWith(""String_Node_Str"") ? ""String_Node_Str"" : ""String_Node_Str"") + maskExtension;
}","public MaskUrlBuilder(File localTextureDir,File localMaskDir,String textureExtension,String maskExtension){
  this.localTextureDir=localTextureDir;
  this.localMaskDir=localMaskDir;
  this.textureExtension=textureExtension == null ? null : (textureExtension.startsWith(""String_Node_Str"") ? ""String_Node_Str"" : ""String_Node_Str"") + textureExtension;
  this.maskExtension=maskExtension == null ? null : (maskExtension.startsWith(""String_Node_Str"") ? ""String_Node_Str"" : ""String_Node_Str"") + maskExtension;
}",0.9312169312169312
11205,"public Animator(){
  Configuration.setValue(AVKey.LAYERS_CLASS_NAMES,""String_Node_Str"");
  Configuration.setValue(AVKey.VIEW_CLASS_NAME,BasicRollOrbitView.class.getName());
  Configuration.setValue(AVKey.SCENE_CONTROLLER_CLASS_NAME,AnimatorSceneController.class.getName());
  Configuration.setValue(AVKey.TASK_SERVICE_CLASS_NAME,ImmediateTaskService.class.getName());
  Configuration.setValue(AVKey.RETRIEVAL_SERVICE_CLASS_NAME,ImmediateRetrievalService.class.getName());
  Configuration.setValue(AVKey.TESSELLATOR_CLASS_NAME,ElevationTesselator.class.getName());
  animationChangeListener=new ChangeListener(){
    public void stateChanged(    ChangeEvent e){
      changed=true;
      setTitleBar();
    }
  }
;
  animation=new SimpleAnimation();
  resetChanged();
  updater=new Updater();
  frame=new JFrame();
  frame.setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE);
  frame.addWindowListener(new WindowAdapter(){
    @Override public void windowClosing(    WindowEvent e){
      quit();
    }
  }
);
  frame.setLayout(new BorderLayout());
  wwd=new WorldWindowGLCanvas(caps);
  Model model=new BasicModel();
  wwd.setModel(model);
  setAnimationSize(1024,576);
  frame.add(wwd,BorderLayout.CENTER);
  ((AWTInputHandler)wwd.getInputHandler()).setSmoothViewChanges(false);
  ((OrbitView)wwd.getView()).getOrbitViewLimits().setPitchLimits(Angle.ZERO,Angle.POS180);
  ocem=new OffsetCompoundElevationModel();
  model.getGlobe().setElevationModel(ocem);
  LayerList layers=model.getLayers();
  Skybox skybox=new Skybox();
  layers.add(skybox);
  Skysphere skysphere=new Skysphere();
  layers.add(skysphere);
  Layer depth=new DepthLayer();
  layers.add(depth);
  Vec4 direction=new Vec4(0.32,0.9,-0.3,1.0);
  lensFlare=LensFlareLayer.getPresetInstance(LensFlareLayer.PRESET_NOSUN);
  layers.add(lensFlare);
  lensFlare.setSunDistance(lensFlare.getSunDistance() * 100);
  AtmosphereLayer atmosphere=new AtmosphereLayer();
  layers.add(atmosphere);
  lensFlare.setSunDirection(direction);
  atmosphere.setLightDirection(direction);
  SkyGradientLayer sky=new SkyGradientLayer();
  layers.add(sky);
  Color fogColor=new Color(138,82,57);
  FogLayer fog=new FogLayer();
  layers.add(fog);
  fog.setNearFactor(0.8f);
  fog.setFarFactor(0.4f);
  fog.setColor(fogColor);
  bmng=new BMNGWMSLayer();
  layers.add(bmng);
  landsat=new LandsatI3WMSLayer();
  layers.add(landsat);
  String tileDrive=""String_Node_Str"";
  ElevationModel earthem=new ExtendedBasicElevationModelFactory().createFromConfigFile(""String_Node_Str"");
  ExtendedBasicElevationModel eem=getEBEM(earthem);
  ExtendedBasicElevationModel bem=FileLayer.createElevationModel(""String_Node_Str"",""String_Node_Str"",new File(tileDrive + ""String_Node_Str""),7,150,LatLon.fromDegrees(20d,20d),Sector.fromDegrees(-59.99875,-7.99875,91.99875,171.99875),-8922,3958);
  bem.setMissingDataSignal(-32768);
  ocem.addElevationModel(eem);
  ocem.addElevationModel(bem);
  map1=FileLayer.createLayer(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",new File(tileDrive + ""String_Node_Str""),""String_Node_Str"",13,LatLon.fromDegrees(36d,36d),Sector.fromDegrees(-24.0536281,-23.4102781,132.0746805,133.9779805));
  layers.add(map1);
  map2=FileLayer.createLayer(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",new File(tileDrive + ""String_Node_Str""),""String_Node_Str"",13,LatLon.fromDegrees(36d,36d),Sector.fromDegrees(-24.0544889,-23.4081639,132.0708833,133.9771083));
  layers.add(map2);
  alos=FileLayer.createLayer(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",new File(tileDrive + ""String_Node_Str""),""String_Node_Str"",new File(tileDrive + ""String_Node_Str""),""String_Node_Str"",13,LatLon.fromDegrees(36d,36d),Sector.fromDegrees(-24.0,-23.433333,132.25,133.95));
  layers.add(alos);
  roads=FileLayer.createLayer(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",new File(tileDrive + ""String_Node_Str""),""String_Node_Str"",12,LatLon.fromDegrees(36d,36d),Sector.fromDegrees(-24.0,-23.433333,132.25,133.95));
  layers.add(roads);
  Layer elevation=new ElevationShader();
  layers.add(elevation);
  Layer elevationImage=new ElevationLayer(bem);
  layers.add(elevationImage);
  Landmarks landmarks=new Landmarks(model.getGlobe());
  layers.add(landmarks);
  for (  Layer layer : layers) {
    layer.setEnabled(false);
  }
  depth.setEnabled(true);
  bmng.setEnabled(true);
  landsat.setEnabled(true);
  elevationImage.setEnabled(true);
  crosshair=new CrosshairLayer();
  layers.add(crosshair);
  JPanel bottom=new JPanel(new BorderLayout());
  frame.add(bottom,BorderLayout.SOUTH);
  slider=new FrameSlider(0,0,animation.getFrameCount());
  slider.setMinimumSize(new Dimension(0,54));
  bottom.add(slider,BorderLayout.CENTER);
  slider.addChangeListener(new ChangeListener(){
    public void stateChanged(    ChangeEvent e){
      if (!settingSlider) {
        if (animation.size() > 0) {
          applyView(getView());
          wwd.redraw();
        }
        stop=true;
      }
    }
  }
);
  slider.addChangeFrameListener(new ChangeFrameListener(){
    public void frameChanged(    int index,    int oldFrame,    int newFrame){
      animation.setFrame(index,newFrame);
      updateSlider();
      applyView(getView());
      wwd.redraw();
    }
  }
);
  getView().addPropertyChangeListener(AVKey.VIEW,new PropertyChangeListener(){
    public void propertyChange(    PropertyChangeEvent evt){
      if (autokey && !applying) {
        addFrame();
      }
    }
  }
);
  StatusBar statusBar=new StatusBar();
  statusBar.setBorder(BorderFactory.createLoweredBevelBorder());
  bottom.add(statusBar,BorderLayout.SOUTH);
  statusBar.setEventSource(wwd);
  ToolTipManager.sharedInstance().setLightWeightPopupEnabled(false);
  JPopupMenu.setDefaultLightWeightPopupEnabled(false);
  createMenuBar();
  setTitleBar();
  updateSlider();
  frame.pack();
  frame.setVisible(true);
}","public Animator(){
  Configuration.setValue(AVKey.LAYERS_CLASS_NAMES,""String_Node_Str"");
  Configuration.setValue(AVKey.VIEW_CLASS_NAME,BasicRollOrbitView.class.getName());
  Configuration.setValue(AVKey.SCENE_CONTROLLER_CLASS_NAME,AnimatorSceneController.class.getName());
  Configuration.setValue(AVKey.TASK_SERVICE_CLASS_NAME,ImmediateTaskService.class.getName());
  Configuration.setValue(AVKey.RETRIEVAL_SERVICE_CLASS_NAME,ImmediateRetrievalService.class.getName());
  Configuration.setValue(AVKey.TESSELLATOR_CLASS_NAME,ElevationTesselator.class.getName());
  animationChangeListener=new ChangeListener(){
    public void stateChanged(    ChangeEvent e){
      changed=true;
      setTitleBar();
    }
  }
;
  animation=new SimpleAnimation();
  resetChanged();
  updater=new Updater();
  frame=new JFrame();
  frame.setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE);
  frame.addWindowListener(new WindowAdapter(){
    @Override public void windowClosing(    WindowEvent e){
      quit();
    }
  }
);
  frame.setLayout(new BorderLayout());
  wwd=new WorldWindowGLCanvas(caps);
  Model model=new BasicModel();
  wwd.setModel(model);
  setAnimationSize(1024,576);
  frame.add(wwd,BorderLayout.CENTER);
  ((AWTInputHandler)wwd.getInputHandler()).setSmoothViewChanges(false);
  ((OrbitView)wwd.getView()).getOrbitViewLimits().setPitchLimits(Angle.ZERO,Angle.POS180);
  ocem=new OffsetCompoundElevationModel();
  model.getGlobe().setElevationModel(ocem);
  wwd.getSceneController().setVerticalExaggeration(10);
  LayerList layers=model.getLayers();
  Skybox skybox=new Skybox();
  layers.add(skybox);
  Skysphere skysphere=new Skysphere();
  layers.add(skysphere);
  Layer depth=new DepthLayer();
  layers.add(depth);
  Vec4 direction=new Vec4(0.32,0.9,-0.3,1.0);
  lensFlare=LensFlareLayer.getPresetInstance(LensFlareLayer.PRESET_NOSUN);
  layers.add(lensFlare);
  lensFlare.setSunDistance(lensFlare.getSunDistance() * 100);
  AtmosphereLayer atmosphere=new AtmosphereLayer();
  layers.add(atmosphere);
  lensFlare.setSunDirection(direction);
  atmosphere.setLightDirection(direction);
  SkyGradientLayer sky=new SkyGradientLayer();
  layers.add(sky);
  Color fogColor=new Color(138,82,57);
  FogLayer fog=new FogLayer();
  layers.add(fog);
  fog.setNearFactor(0.8f);
  fog.setFarFactor(0.4f);
  fog.setColor(fogColor);
  bmng=new BMNGWMSLayer();
  layers.add(bmng);
  landsat=new LandsatI3WMSLayer();
  layers.add(landsat);
  String tileDrive=""String_Node_Str"";
  ElevationModel earthem=new ExtendedBasicElevationModelFactory().createFromConfigFile(""String_Node_Str"");
  ExtendedBasicElevationModel eem=getEBEM(earthem);
  ExtendedBasicElevationModel bem=FileLayer.createElevationModel(""String_Node_Str"",""String_Node_Str"",new File(tileDrive + ""String_Node_Str""),7,150,LatLon.fromDegrees(20d,20d),Sector.fromDegrees(-59.99875,-7.99875,91.99875,171.99875),-8922,3958);
  bem.setMissingDataSignal(-32768);
  ocem.addElevationModel(eem);
  ocem.addElevationModel(bem);
  map1=FileLayer.createLayer(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",new File(tileDrive + ""String_Node_Str""),""String_Node_Str"",13,LatLon.fromDegrees(36d,36d),Sector.fromDegrees(-24.0536281,-23.4102781,132.0746805,133.9779805));
  layers.add(map1);
  map2=FileLayer.createLayer(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",new File(tileDrive + ""String_Node_Str""),""String_Node_Str"",13,LatLon.fromDegrees(36d,36d),Sector.fromDegrees(-24.0544889,-23.4081639,132.0708833,133.9771083));
  layers.add(map2);
  alos=FileLayer.createLayer(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",new File(tileDrive + ""String_Node_Str""),""String_Node_Str"",new File(tileDrive + ""String_Node_Str""),""String_Node_Str"",13,LatLon.fromDegrees(36d,36d),Sector.fromDegrees(-24.0,-23.433333,132.25,133.95));
  layers.add(alos);
  roads=FileLayer.createLayer(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",new File(tileDrive + ""String_Node_Str""),""String_Node_Str"",12,LatLon.fromDegrees(36d,36d),Sector.fromDegrees(-24.0,-23.433333,132.25,133.95));
  layers.add(roads);
  Layer elevation=new ElevationShader();
  layers.add(elevation);
  final ElevationLayer elevationImage=new ElevationLayer(bem);
  elevationImage.setSunPosition(new Vec4(0.61,0.42,-0.67));
  elevationImage.setExaggeration(50);
  elevationImage.setSplitScale(1.2);
  layers.add(elevationImage);
  Landmarks landmarks=new Landmarks(model.getGlobe());
  layers.add(landmarks);
  for (  Layer layer : layers) {
    layer.setEnabled(false);
  }
  depth.setEnabled(true);
  bmng.setEnabled(true);
  landsat.setEnabled(true);
  elevationImage.setEnabled(true);
  crosshair=new CrosshairLayer();
  layers.add(crosshair);
  JPanel bottom=new JPanel(new BorderLayout());
  frame.add(bottom,BorderLayout.SOUTH);
  slider=new FrameSlider(0,0,animation.getFrameCount());
  slider.setMinimumSize(new Dimension(0,54));
  bottom.add(slider,BorderLayout.CENTER);
  slider.addChangeListener(new ChangeListener(){
    public void stateChanged(    ChangeEvent e){
      if (!settingSlider) {
        if (animation.size() > 0) {
          applyView(getView());
          wwd.redraw();
        }
        stop=true;
      }
    }
  }
);
  slider.addChangeFrameListener(new ChangeFrameListener(){
    public void frameChanged(    int index,    int oldFrame,    int newFrame){
      animation.setFrame(index,newFrame);
      updateSlider();
      applyView(getView());
      wwd.redraw();
    }
  }
);
  getView().addPropertyChangeListener(AVKey.VIEW,new PropertyChangeListener(){
    public void propertyChange(    PropertyChangeEvent evt){
      if (autokey && !applying) {
        addFrame();
      }
    }
  }
);
  StatusBar statusBar=new StatusBar();
  statusBar.setBorder(BorderFactory.createLoweredBevelBorder());
  bottom.add(statusBar,BorderLayout.SOUTH);
  statusBar.setEventSource(wwd);
  ToolTipManager.sharedInstance().setLightWeightPopupEnabled(false);
  JPopupMenu.setDefaultLightWeightPopupEnabled(false);
  createMenuBar();
  setTitleBar();
  updateSlider();
  frame.pack();
  frame.setVisible(true);
  JFrame exaggeration=new JFrame(""String_Node_Str"");
  exaggeration.setLayout(new GridLayout(0,1));
  JSlider slider;
  slider=new JSlider(0,100,(int)wwd.getSceneController().getVerticalExaggeration());
  exaggeration.add(slider);
  slider.addChangeListener(new ChangeListener(){
    public void stateChanged(    ChangeEvent e){
      int value=((JSlider)e.getSource()).getValue();
      Configuration.setValue(AVKey.VERTICAL_EXAGGERATION,(double)value);
      wwd.getSceneController().setVerticalExaggeration(value);
      wwd.redraw();
    }
  }
);
  slider=new JSlider(0,100,(int)elevationImage.getExaggeration());
  exaggeration.add(slider);
  slider.addChangeListener(new ChangeListener(){
    public void stateChanged(    ChangeEvent e){
      int value=((JSlider)e.getSource()).getValue();
      elevationImage.setExaggeration(value);
      wwd.redraw();
    }
  }
);
  slider=new JSlider(-1000,1000,(int)(elevationImage.getSunPosition().x * 1000));
  exaggeration.add(slider);
  slider.addChangeListener(new ChangeListener(){
    public void stateChanged(    ChangeEvent e){
      int value=((JSlider)e.getSource()).getValue();
      Vec4 pos=elevationImage.getSunPosition();
      pos=new Vec4(value / 1000d,pos.y,pos.z);
      elevationImage.setSunPosition(pos);
      wwd.redraw();
    }
  }
);
  slider=new JSlider(-1000,1000,(int)(elevationImage.getSunPosition().y * 1000));
  exaggeration.add(slider);
  slider.addChangeListener(new ChangeListener(){
    public void stateChanged(    ChangeEvent e){
      int value=((JSlider)e.getSource()).getValue();
      Vec4 pos=elevationImage.getSunPosition();
      pos=new Vec4(pos.x,value / 1000d,pos.z);
      elevationImage.setSunPosition(pos);
      wwd.redraw();
    }
  }
);
  slider=new JSlider(-1000,1000,(int)(elevationImage.getSunPosition().z * 1000));
  exaggeration.add(slider);
  slider.addChangeListener(new ChangeListener(){
    public void stateChanged(    ChangeEvent e){
      int value=((JSlider)e.getSource()).getValue();
      Vec4 pos=elevationImage.getSunPosition();
      pos=new Vec4(pos.x,pos.y,value / 1000d);
      elevationImage.setSunPosition(pos);
      wwd.redraw();
    }
  }
);
  exaggeration.setSize(640,200);
  exaggeration.setVisible(true);
}",0.8260314759676733
11206,"public void stateChanged(ChangeEvent e){
  if (!settingSlider) {
    if (animation.size() > 0) {
      applyView(getView());
      wwd.redraw();
    }
    stop=true;
  }
}","public void stateChanged(ChangeEvent e){
  int value=((JSlider)e.getSource()).getValue();
  Vec4 pos=elevationImage.getSunPosition();
  pos=new Vec4(pos.x,pos.y,value / 1000d);
  elevationImage.setSunPosition(pos);
  wwd.redraw();
}",0.238213399503722
11207,"@Override public RenderInfo buildVerts(DrawContext dc,RectTile tile,boolean makeSkirts){
  int density=tile.density;
  int numVertices=(density + 3) * (density + 3);
  DoubleBuffer verts=BufferUtil.newDoubleBuffer(numVertices * 3);
  DoubleBuffer positions=BufferUtil.newDoubleBuffer(numVertices * 3);
  ArrayList<LatLon> latlons=this.computeLocations(tile);
  double[] elevations=new double[latlons.size()];
  dc.getGlobe().getElevations(tile.sector,latlons,tile.getResolution(),elevations);
  int iv=0, ip=0;
  double verticalExaggeration=dc.getVerticalExaggeration();
  double exaggeratedMinElevation=makeSkirts ? globe.getMinElevation() * verticalExaggeration : 0;
  LatLon centroid=tile.sector.getCentroid();
  Vec4 refCenter=globe.computePointFromPosition(centroid.getLatitude(),centroid.getLongitude(),0d);
  double minElevation=Double.MAX_VALUE;
  double maxElevation=-Double.MAX_VALUE;
  int ie=0;
  Iterator<LatLon> latLonIter=latlons.iterator();
  for (int j=0; j <= density + 2; j++) {
    for (int i=0; i <= density + 2; i++) {
      LatLon latlon=latLonIter.next();
      double elevation=verticalExaggeration * elevations[ie++];
      positions.put(ip++,latlon.getLatitude().degrees).put(ip++,latlon.getLongitude().degrees).put(ip++,elevation);
      minElevation=Math.min(minElevation,elevation);
      maxElevation=Math.max(maxElevation,elevation);
      if (j == 0 || j >= tile.density + 2 || i == 0 || i >= tile.density + 2) {
        elevation-=exaggeratedMinElevation >= 0 ? exaggeratedMinElevation : -exaggeratedMinElevation;
      }
      Vec4 p=globe.computePointFromPosition(latlon.getLatitude(),latlon.getLongitude(),elevation);
      verts.put(iv++,p.x - refCenter.x).put(iv++,p.y - refCenter.y).put(iv++,p.z - refCenter.z);
    }
  }
  return new RenderInfo(density,verts,positions,minElevation,maxElevation,getTextureCoordinates(density),refCenter);
}","@Override public RenderInfo buildVerts(DrawContext dc,RectTile tile,boolean makeSkirts){
  int density=tile.density;
  int numVertices=(density + 3) * (density + 3);
  DoubleBuffer verts=BufferUtil.newDoubleBuffer(numVertices * 3);
  ArrayList<LatLon> latlons=this.computeLocations(tile);
  double[] elevations=new double[latlons.size()];
  dc.getGlobe().getElevations(tile.sector,latlons,tile.getResolution(),elevations);
  double verticalExaggeration=dc.getVerticalExaggeration();
  double exaggeratedMinElevation=makeSkirts ? globe.getMinElevation() * verticalExaggeration : 0;
  LatLon centroid=tile.sector.getCentroid();
  Vec4 refCenter=globe.computePointFromPosition(centroid.getLatitude(),centroid.getLongitude(),0d);
  double minElevation=Double.MAX_VALUE;
  double maxElevation=-Double.MAX_VALUE;
  int ie=0, iv=0;
  Iterator<LatLon> latLonIter=latlons.iterator();
  for (int j=0; j <= density + 2; j++) {
    for (int i=0; i <= density + 2; i++) {
      LatLon latlon=latLonIter.next();
      double elevation=elevations[ie++];
      minElevation=Math.min(minElevation,elevation);
      maxElevation=Math.max(maxElevation,elevation);
      elevation*=verticalExaggeration;
      if (j == 0 || j >= tile.density + 2 || i == 0 || i >= tile.density + 2) {
        elevation-=exaggeratedMinElevation >= 0 ? exaggeratedMinElevation : -exaggeratedMinElevation;
      }
      Vec4 p=globe.computePointFromPosition(latlon.getLatitude(),latlon.getLongitude(),elevation);
      verts.put(iv++,p.x - refCenter.x).put(iv++,p.y - refCenter.y).put(iv++,p.z - refCenter.z);
    }
  }
  return new RenderInfo(density,verts,elevations,minElevation,maxElevation,getTextureCoordinates(density),refCenter);
}",0.8538697960324113
11208,"@Override public SectorGeometryList tessellate(DrawContext dc){
  SectorGeometryList sgl=super.tessellate(dc);
  int count=0;
  minElevation=Double.MAX_VALUE;
  maxElevation=-Double.MAX_VALUE;
  for (  SectorGeometry sg : sgl) {
    RectTile tile=(RectTile)sg;
    RenderInfo ri=(RenderInfo)tile.ri;
    if (isSectorInScreen(dc,sg.getSector())) {
      minElevation=Math.min(minElevation,ri.minElevation);
      maxElevation=Math.max(maxElevation,ri.maxElevation);
    }
 else {
      ri.vertices.rewind();
      for (int i=0; i < ri.vertices.limit(); i+=3) {
        Vec4 point=new Vec4(ri.vertices.get(),ri.vertices.get(),ri.vertices.get()).add3(ri.refCenter);
        if (isPointInScreen(dc,point)) {
          count++;
          minElevation=Math.min(minElevation,ri.positions.get(i + 2));
          maxElevation=Math.max(maxElevation,ri.positions.get(i + 2));
        }
      }
    }
  }
  if (minElevation == Double.MAX_VALUE)   minElevation=dc.getGlobe().getMinElevation();
  if (maxElevation == -Double.MAX_VALUE)   maxElevation=dc.getGlobe().getMaxElevation();
  return sgl;
}","@Override public SectorGeometryList tessellate(DrawContext dc){
  SectorGeometryList sgl=super.tessellate(dc);
  int count=0;
  minElevation=Double.MAX_VALUE;
  maxElevation=-Double.MAX_VALUE;
  for (  SectorGeometry sg : sgl) {
    RectTile tile=(RectTile)sg;
    RenderInfo ri=(RenderInfo)tile.ri;
    if (isSectorInScreen(dc,sg.getSector())) {
      minElevation=Math.min(minElevation,ri.minElevation);
      maxElevation=Math.max(maxElevation,ri.maxElevation);
    }
 else {
      ri.vertices.rewind();
      for (int i=0; i < ri.vertices.limit() / 3; i++) {
        Vec4 point=new Vec4(ri.vertices.get(),ri.vertices.get(),ri.vertices.get()).add3(ri.refCenter);
        if (isPointInScreen(dc,point)) {
          count++;
          minElevation=Math.min(minElevation,ri.elevations[i]);
          maxElevation=Math.max(maxElevation,ri.elevations[i]);
        }
      }
    }
  }
  if (minElevation == Double.MAX_VALUE)   minElevation=dc.getGlobe().getMinElevation();
  if (maxElevation == -Double.MAX_VALUE)   maxElevation=dc.getGlobe().getMaxElevation();
  return sgl;
}",0.9661880500231588
11209,"protected RenderInfo(int density,DoubleBuffer vertices,DoubleBuffer positions,double minElevation,double maxElevation,DoubleBuffer texCoords,Vec4 refCenter){
  super(density,vertices,texCoords,refCenter);
  this.positions=positions;
  this.vertices=vertices;
  this.minElevation=minElevation;
  this.maxElevation=maxElevation;
  this.refCenter=refCenter;
}","protected RenderInfo(int density,DoubleBuffer vertices,double[] elevations,double minElevation,double maxElevation,DoubleBuffer texCoords,Vec4 refCenter){
  super(density,vertices,texCoords,refCenter);
  this.elevations=elevations;
  this.vertices=vertices;
  this.minElevation=minElevation;
  this.maxElevation=maxElevation;
  this.refCenter=refCenter;
}",0.9142053445850914
11210,"private void animate(){
  LatLon l1=LatLon.fromDegrees(-27,133.5);
  LatLon l2=LatLon.fromDegrees(-21.0474,119.6494);
  Zoom zoom1=Zoom.fromCameraZoom(6378137);
  Zoom zoom2=Zoom.fromCameraZoom(559794);
  Heading heading1=Heading.fromDegrees(-170);
  Heading heading2=Heading.fromDegrees(180);
  Pitch pitch1=Pitch.fromDegrees(0);
  Pitch pitch2=Pitch.fromDegrees(70);
  Pitch pitch3=Pitch.fromDegrees(45);
  MotionParams motion1=new MotionParams(0.2,0.2,0,0);
  MotionParams motion2=new MotionParams(5,5,0,0);
  final CameraPath path=new CameraPath(l1,l1,zoom1,heading1,pitch1);
  path.addCenter(l2,l2,null,20,motion1);
  path.addZoom(zoom2,10,motion1);
  path.addHeading(heading2,20,motion2);
  path.addPitch(pitch2,10,motion2);
  path.addPitch(pitch3,20,motion2);
  Thread thread=new Thread(new Runnable(){
    public void run(){
      View v=wwd.getSceneController().getView();
      if (!(v instanceof OrbitView))       return;
      OrbitView view=(OrbitView)v;
      boolean detectCollisions=view.isDetectCollisions();
      view.setDetectCollisions(false);
      double totalTime=path.getTime();
      double startTime=System.currentTimeMillis() / 1000d;
      double currentTime=0;
      while (currentTime <= totalTime) {
        currentTime=System.currentTimeMillis() / 1000d - startTime;
        LatLon center=path.getCenter(currentTime);
        Zoom zoom=path.getZoom(currentTime);
        Heading heading=path.getHeading(currentTime);
        Pitch pitch=path.getPitch(currentTime);
        view.setCenterPosition(new Position(center.getLatLon(),0));
        view.setZoom(zoom.toCameraZoom());
        view.setHeading(heading.getAngle());
        view.setPitch(pitch.getAngle());
        wwd.redrawNow();
      }
      view.setDetectCollisions(detectCollisions);
    }
  }
);
  thread.start();
}","private void animate(){
  LatLon l1=LatLon.fromDegrees(-27,133.5);
  LatLon l2=LatLon.fromDegrees(-21.0474,119.6494);
  Zoom zoom1=Zoom.fromCameraZoom(6378137);
  Zoom zoom2=Zoom.fromCameraZoom(559794);
  Heading heading1=Heading.fromDegrees(-180);
  Heading heading2=Heading.fromDegrees(180);
  Pitch pitch1=Pitch.fromDegrees(0);
  Pitch pitch2=Pitch.fromDegrees(70);
  Pitch pitch3=Pitch.fromDegrees(45);
  MotionParams motion1=new MotionParams(0.2,0.2,0,0);
  MotionParams motion2=new MotionParams(5,5,0,0);
  final CameraPath path=new CameraPath(l1,l1,zoom1,heading1,pitch1);
  path.addCenter(l2,l2,null,20,motion1);
  path.addZoom(zoom2,10,motion1);
  path.addHeading(heading2,20,motion2);
  path.addPitch(pitch2,10,motion2);
  path.addPitch(pitch3,20,motion2);
  Thread thread=new Thread(new Runnable(){
    public void run(){
      View v=wwd.getSceneController().getView();
      if (!(v instanceof OrbitView))       return;
      OrbitView view=(OrbitView)v;
      boolean detectCollisions=view.isDetectCollisions();
      view.setDetectCollisions(false);
      double totalTime=path.getTime();
      double startTime=System.currentTimeMillis() / 1000d;
      double currentTime=0;
      while (currentTime <= totalTime) {
        currentTime=System.currentTimeMillis() / 1000d - startTime;
        LatLon center=path.getCenter(currentTime);
        Zoom zoom=path.getZoom(currentTime);
        Heading heading=path.getHeading(currentTime);
        Pitch pitch=path.getPitch(currentTime);
        view.setCenterPosition(new Position(center.getLatLon(),0));
        view.setZoom(zoom.toCameraZoom());
        view.setHeading(heading.getAngle());
        view.setPitch(pitch.getAngle());
        wwd.redrawNow();
      }
      view.setDetectCollisions(detectCollisions);
    }
  }
);
  thread.start();
}",0.9994475138121548
11211,"private void refresh(){
  a1=params.accelerationIn;
  a3=params.accelerationOut;
  v1=params.velocityIn;
  v3=params.velocityOut;
  calculate();
  if (!isValid()) {
    a1=-a1;
    calculate();
    if (!isValid()) {
      a3=-a3;
      calculate();
      if (!isValid()) {
        a1=-a1;
        calculate();
        if (!isValid()) {
          throw new IllegalArgumentException();
        }
      }
    }
  }
  System.out.println();
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + t1 + ""String_Node_Str""+ t2+ ""String_Node_Str""+ t3);
  System.out.println(""String_Node_Str"" + v1 + ""String_Node_Str""+ v2+ ""String_Node_Str""+ v3);
  System.out.println(""String_Node_Str"" + d1 + ""String_Node_Str""+ d2+ ""String_Node_Str""+ d3+ ""String_Node_Str""+ d3Calc+ ""String_Node_Str"");
  System.out.println(""String_Node_Str"" + a1 + ""String_Node_Str""+ a3);
}","private void refresh(){
  a1=params.accelerationIn;
  a3=params.accelerationOut;
  v1=params.velocityIn;
  v3=params.velocityOut;
  calculate();
  if (!isValid()) {
    a1=-a1;
    calculate();
    if (!isValid()) {
      a3=-a3;
      calculate();
      if (!isValid()) {
        a1=-a1;
        calculate();
        if (!isValid()) {
          throw new IllegalArgumentException();
        }
      }
    }
  }
}",0.6423017107309487
11212,"public double getPercent(double time){
  if (time <= 0)   return 0;
  if (time >= getTime())   return 1;
  double a;
  double d;
  double u;
  double t;
  if (time < t1) {
    t=time;
    a=a1;
    d=0;
    u=v1;
  }
 else   if (time < t1 + t2) {
    t=time - t1;
    a=a2;
    d=d1;
    u=v2;
  }
 else {
    t=time - t1 - t2;
    a=a3;
    d=d1 + d2;
    u=v2;
  }
  d+=u * t + 0.5 * a * t* t;
  return Math.max(0,Math.min(1,d / getDistance()));
}","public double getPercent(double time){
  if (time <= 0)   return 0;
  if (time >= getTime())   return 1;
  if (getDistance() <= 0)   return 1;
  double a;
  double d;
  double u;
  double t;
  if (time < t1) {
    t=time;
    a=a1;
    d=0;
    u=v1;
  }
 else   if (time < t1 + t2) {
    t=time - t1;
    a=a2;
    d=d1;
    u=v2;
  }
 else {
    t=time - t1 - t2;
    a=a3;
    d=d1 + d2;
    u=v2;
  }
  d+=u * t + 0.5 * a * t* t;
  return Math.max(0,Math.min(1,d / getDistance()));
}",0.9594017094017094
11213,"public static void main(String[] args){
  Settings.initialize(SETTINGS_KEY);
  Configuration.setValue(AVKey.SCENE_CONTROLLER_CLASS_NAME,StereoSceneController.class.getName());
  Configuration.setValue(AVKey.VIEW_CLASS_NAME,StereoOrbitView.class.getName());
  Configuration.setValue(AVKey.LAYERS_CLASS_NAMES,""String_Node_Str"");
  Configuration.setValue(AVKey.INITIAL_LATITUDE,Double.toString(Angle.fromDegreesLatitude(-27).degrees));
  Configuration.setValue(AVKey.INITIAL_LONGITUDE,Double.toString(Angle.fromDegreesLongitude(133.5).degrees));
  new Application();
}","public static void main(String[] args){
  Settings.initialize(SETTINGS_KEY);
  Configuration.setValue(AVKey.SCENE_CONTROLLER_CLASS_NAME,StereoSceneController.class.getName());
  Configuration.setValue(AVKey.VIEW_CLASS_NAME,StereoOrbitView.class.getName());
  Configuration.setValue(AVKey.LAYERS_CLASS_NAMES,""String_Node_Str"");
  Configuration.setValue(AVKey.DATA_FILE_CACHE_CLASS_NAME,FixedBasicDataFileCache.class.getName());
  Configuration.setValue(AVKey.INITIAL_LATITUDE,Double.toString(Angle.fromDegreesLatitude(-27).degrees));
  Configuration.setValue(AVKey.INITIAL_LONGITUDE,Double.toString(Angle.fromDegreesLongitude(133.5).degrees));
  new Application();
}",0.91869918699187
11214,"private void animate(){
  LatLon l1=LatLon.fromDegrees(-27,133.5);
  LatLon l2=LatLon.fromDegrees(-21.0474,119.6494);
  Zoom zoom1=Zoom.fromCameraZoom(6378137);
  Zoom zoom2=Zoom.fromCameraZoom(559794);
  Heading heading1=Heading.fromDegrees(0);
  Heading heading2=Heading.fromDegrees(180);
  Heading heading3=Heading.fromDegrees(360);
  Pitch pitch1=Pitch.fromDegrees(0);
  Pitch pitch2=Pitch.fromDegrees(70);
  Pitch pitch3=Pitch.fromDegrees(45);
  MotionParams motion1=new MotionParams(0.2,0.2,0,0);
  MotionParams motion2=new MotionParams(400,400,0,0,true,true);
  final CameraPath path=new CameraPath(l1,l1,zoom1,heading1,pitch1);
  path.addCenter(l2,l2,null,20,motion1);
  path.addZoom(zoom2,10,motion1);
  path.addHeading(heading2,5,motion2);
  path.addHeading(heading3,10,motion2);
  path.addHeading(heading2,15,motion2);
  path.addHeading(heading3,20,motion2);
  path.addPitch(pitch2,10,motion2);
  path.addPitch(pitch3,20,motion2);
  Thread thread=new Thread(new Runnable(){
    public void run(){
      View v=wwd.getSceneController().getView();
      if (!(v instanceof OrbitView))       return;
      OrbitView view=(OrbitView)v;
      boolean detectCollisions=view.isDetectCollisions();
      view.setDetectCollisions(false);
      double totalTime=path.getTime();
      double startTime=System.currentTimeMillis() / 1000d;
      double currentTime=0;
      while (currentTime <= totalTime) {
        currentTime=System.currentTimeMillis() / 1000d - startTime;
        LatLon center=path.getCenter(currentTime);
        Zoom zoom=path.getZoom(currentTime);
        Heading heading=path.getHeading(currentTime);
        Pitch pitch=path.getPitch(currentTime);
        view.setCenterPosition(new Position(center.getLatLon(),0));
        view.setZoom(zoom.toCameraZoom());
        view.setHeading(heading.getAngle());
        view.setPitch(pitch.getAngle());
        wwd.redrawNow();
      }
      view.setDetectCollisions(detectCollisions);
    }
  }
);
  thread.start();
}","private void animate(){
  final CameraPath path=createPath();
  System.out.println(""String_Node_Str"" + path.getTime());
  Thread thread=new Thread(new Runnable(){
    public void run(){
      View v=wwd.getSceneController().getView();
      if (!(v instanceof OrbitView))       return;
      OrbitView view=(OrbitView)v;
      boolean detectCollisions=view.isDetectCollisions();
      view.setDetectCollisions(false);
      double totalTime=path.getTime();
      double startTime=System.currentTimeMillis() / 1000d;
      double currentTime=0;
      while (currentTime <= totalTime) {
        currentTime=System.currentTimeMillis() / 1000d - startTime;
        LatLon center=path.getCenter(currentTime);
        Zoom zoom=path.getZoom(currentTime);
        Heading heading=path.getHeading(currentTime);
        Pitch pitch=path.getPitch(currentTime);
        view.setCenterPosition(new Position(center.getLatLon(),0));
        view.setZoom(zoom.toCameraZoom());
        view.setHeading(heading.getAngle());
        view.setPitch(pitch.getAngle());
        wwd.redrawNow();
      }
      view.setDetectCollisions(detectCollisions);
    }
  }
);
  thread.start();
}",0.6905972045743329
11215,"public void addPitch(Pitch pitch,double time,MotionParams motion){
  pitchs.put(time,new MotionAndObject<InterpolatablePitch>(new InterpolatablePitch(pitch),new Motion(motion)));
  pitchsDirty=true;
}","public void addPitch(Pitch pitch,double time,MotionParams motion){
  pitchs.put(time,new MotionAndObject<InterpolatablePitch>(new InterpolatablePitch(pitch),new Motion(motion)));
  dirty=true;
}",0.9796954314720812
11216,"public Zoom getZoom(double time){
  return new ValueGetter<Zoom,InterpolatableZoom>().getValue(time,zooms);
}","public Zoom getZoom(double time){
  refresh();
  return new ValueGetter<Zoom,InterpolatableZoom>().getValue(time,zooms);
}",0.9437229437229436
11217,"public LatLon getCenter(double time){
  return new ValueGetter<LatLon,InterpolatableLatLon>().getValue(time,centers);
}","public LatLon getCenter(double time){
  refresh();
  return new ValueGetter<LatLon,InterpolatableLatLon>().getValue(time,centers);
}",0.9482071713147412
11218,"public void addHeading(Heading heading,double time,MotionParams motion){
  headings.put(time,new MotionAndObject<InterpolatableHeading>(new InterpolatableHeading(heading),new Motion(motion)));
  headingsDirty=true;
}","public void addHeading(Heading heading,double time,MotionParams motion){
  headings.put(time,new MotionAndObject<InterpolatableHeading>(new InterpolatableHeading(heading),new Motion(motion)));
  dirty=true;
}",0.9764150943396226
11219,"public double getTime(){
  refreshIfDirty();
  return time;
}","public double getTime(){
  refresh();
  return time;
}",0.9391304347826088
11220,"public Pitch getPitch(double time){
  return new ValueGetter<Pitch,InterpolatablePitch>().getValue(time,pitchs);
}","public Pitch getPitch(double time){
  refresh();
  return new ValueGetter<Pitch,InterpolatablePitch>().getValue(time,pitchs);
}",0.946058091286307
11221,"public void addZoom(Zoom zoom,double time,MotionParams motion){
  zooms.put(time,new MotionAndObject<InterpolatableZoom>(new InterpolatableZoom(zoom),new Motion(motion)));
  zoomsDirty=true;
}","public void addZoom(Zoom zoom,double time,MotionParams motion){
  zooms.put(time,new MotionAndObject<InterpolatableZoom>(new InterpolatableZoom(zoom),new Motion(motion)));
  dirty=true;
}",0.9815303430079156
11222,"public Heading getHeading(double time){
  return new ValueGetter<Heading,InterpolatableHeading>().getValue(time,headings);
}","public Heading getHeading(double time){
  refresh();
  return new ValueGetter<Heading,InterpolatableHeading>().getValue(time,headings);
}",0.950191570881226
11223,"public void addCenter(LatLon center,LatLon in,LatLon out,double time,MotionParams motion){
  LatLonBezier llb=new LatLonBezier(center,in,out);
  centers.put(time,new MotionAndObject<InterpolatableLatLon>(new InterpolatableLatLon(llb),new Motion(motion)));
  centersDirty=true;
}","public void addCenter(LatLon center,LatLon in,LatLon out,double time,MotionParams motion){
  LatLonBezier llb=new LatLonBezier(center,in,out);
  centers.put(time,new MotionAndObject<InterpolatableLatLon>(new InterpolatableLatLon(llb),new Motion(motion)));
  dirty=true;
}",0.9836065573770492
11224,"private void refresh(){
  a1=params.accelerationIn;
  a3=params.accelerationOut;
  v1=v1forced ? forcev1 : params.velocityIn;
  v3=params.velocityOut;
  calculate();
  if (!isValid()) {
    a1=-a1;
    calculate();
    if (!isValid()) {
      a3=-a3;
      calculate();
      if (!isValid()) {
        a1=-a1;
        calculate();
        if (!isValid()) {
          throw new IllegalArgumentException();
        }
      }
    }
  }
  System.out.println();
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + t1 + ""String_Node_Str""+ t2+ ""String_Node_Str""+ t3);
  System.out.println(""String_Node_Str"" + v1 + ""String_Node_Str""+ v2+ ""String_Node_Str""+ v3);
  System.out.println(""String_Node_Str"" + d1 + ""String_Node_Str""+ d2+ ""String_Node_Str""+ d3+ ""String_Node_Str""+ d3Calc+ ""String_Node_Str"");
  System.out.println(""String_Node_Str"" + a1 + ""String_Node_Str""+ a3);
}","private void refresh(){
  a1=params.accelerationIn;
  a3=params.accelerationOut;
  v1=v1forced ? forcev1 : params.velocityIn;
  v3=params.velocityOut;
  calculate();
  if (!isValid()) {
    a1=-a1;
    calculate();
    if (!isValid()) {
      a3=-a3;
      calculate();
      if (!isValid()) {
        a1=-a1;
        calculate();
        if (!isValid()) {
          throw new IllegalArgumentException();
        }
      }
    }
  }
}",0.6536144578313253
11225,"private void animate(){
  final CameraPath path=createPath();
  System.out.println(""String_Node_Str"" + path.getTime());
  Thread thread=new Thread(new Runnable(){
    public void run(){
      View v=wwd.getSceneController().getView();
      if (!(v instanceof OrbitView))       return;
      OrbitView view=(OrbitView)v;
      boolean detectCollisions=view.isDetectCollisions();
      view.setDetectCollisions(false);
      double totalTime=path.getTime();
      double startTime=System.currentTimeMillis() / 1000d;
      double currentTime=0;
      while (currentTime <= totalTime) {
        currentTime=System.currentTimeMillis() / 1000d - startTime;
        LatLon center=path.getCenter(currentTime);
        Zoom zoom=path.getZoom(currentTime);
        Heading heading=path.getHeading(currentTime);
        Pitch pitch=path.getPitch(currentTime);
        view.setCenterPosition(new Position(center.getLatLon(),0));
        view.setZoom(zoom.toCameraZoom());
        view.setHeading(heading.getAngle());
        view.setPitch(pitch.getAngle());
        wwd.redrawNow();
      }
      view.setDetectCollisions(detectCollisions);
    }
  }
);
  thread.start();
}","private void animate(){
  final CameraPath path=createPath();
  Thread thread=new Thread(new Runnable(){
    public void run(){
      View v=wwd.getSceneController().getView();
      if (!(v instanceof OrbitView))       return;
      OrbitView view=(OrbitView)v;
      boolean detectCollisions=view.isDetectCollisions();
      view.setDetectCollisions(false);
      double totalTime=path.getTime();
      double startTime=System.currentTimeMillis() / 1000d;
      double currentTime=0;
      while (currentTime <= totalTime) {
        currentTime=System.currentTimeMillis() / 1000d - startTime;
        LatLon center=path.getCenter(currentTime);
        Zoom zoom=path.getZoom(currentTime);
        Heading heading=path.getHeading(currentTime);
        Pitch pitch=path.getPitch(currentTime);
        view.setCenterPosition(new Position(center.getLatLon(),0));
        view.setZoom(zoom.toCameraZoom());
        view.setHeading(heading.getAngle());
        view.setPitch(pitch.getAngle());
        wwd.redrawNow();
      }
      view.setDetectCollisions(detectCollisions);
    }
  }
);
  thread.start();
}",0.9744268077601412
11226,"private static CameraPath createPath(){
  LatLon l1=LatLon.fromDegrees(-27,133.5);
  LatLon l2=LatLon.fromDegrees(-21.0474,119.6494);
  Zoom zoom1=Zoom.fromCameraZoom(6378137);
  Zoom zoom2=Zoom.fromCameraZoom(559794);
  Heading heading1=Heading.fromDegrees(0);
  Heading heading2=Heading.fromDegrees(-30);
  Heading heading3=Heading.fromDegrees(180);
  Pitch pitch1=Pitch.fromDegrees(0);
  Pitch pitch2=Pitch.fromDegrees(80);
  Pitch pitch3=Pitch.fromDegrees(50);
  double time1=5;
  double time2=12;
  MotionParams centerMotion=new MotionParams(3,3,0,0);
  MotionParams zoomMotion=new MotionParams(0.5,0.5,0,0);
  MotionParams headingMotion1=new MotionParams(15,15,0,3,false,false);
  MotionParams headingMotion2=new MotionParams(15,15,0,0,true,false);
  MotionParams pitchMotion=new MotionParams(15,15,0,0);
  CameraPath path=new CameraPath(l1,l1,zoom1,heading1,pitch1);
  path.addCenter(l2,l2,null,time1,centerMotion);
  path.addZoom(zoom2,time1,zoomMotion);
  path.addHeading(heading2,time1,headingMotion1);
  path.addPitch(pitch2,time1,pitchMotion);
  path.addHeading(heading3,time2,headingMotion2);
  path.addPitch(pitch3,time2,pitchMotion);
  path.refresh();
  return path;
}","private static CameraPath createPath(){
  LatLon l1=LatLon.fromDegrees(-27,133.5);
  LatLon l2=LatLon.fromDegrees(-21.0474,119.6494);
  Zoom zoom1=Zoom.fromCameraZoom(6378137);
  Zoom zoom2=Zoom.fromCameraZoom(559794);
  Heading heading1=Heading.fromDegrees(0);
  Heading heading2=Heading.fromDegrees(-360);
  Pitch pitch1=Pitch.fromDegrees(0);
  Pitch pitch2=Pitch.fromDegrees(70);
  Pitch pitch3=Pitch.fromDegrees(50);
  double time1=4;
  double time3=12;
  MotionParams centerMotion=new MotionParams(4,4,0,0);
  MotionParams zoomMotion=new MotionParams(0.8,0.8,0,0);
  MotionParams headingMotion=new MotionParams(10,10,0,0);
  MotionParams pitchMotion=new MotionParams(20,20,0,0);
  CameraPath path=new CameraPath(l1,l1,zoom1,heading1,pitch1);
  path.addCenter(l2,l2,null,time1,centerMotion);
  path.addZoom(zoom2,time1,zoomMotion);
  path.addHeading(heading2,time3,headingMotion);
  path.addPitch(pitch2,time1,pitchMotion);
  path.addPitch(pitch3,time3,pitchMotion);
  path.refresh();
  return path;
}",0.746800731261426
11227,"public void refresh(){
  if (dirty) {
    this.time=0;
    dirty=false;
    double time=new MapRefresher<InterpolatableLatLon>().refreshMap(centers);
    this.time=Math.max(this.time,time);
    time=new MapRefresher<InterpolatableZoom>().refreshMap(zooms);
    this.time=Math.max(this.time,time);
    time=new MapRefresher<InterpolatableHeading>().refreshMap(headings);
    this.time=Math.max(this.time,time);
    time=new MapRefresher<InterpolatablePitch>().refreshMap(pitchs);
    this.time=Math.max(this.time,time);
  }
}","public void refresh(){
  if (dirty) {
    this.time=0;
    dirty=false;
    try {
      double time=new MapRefresher<InterpolatableLatLon>().refreshMap(centers);
      this.time=Math.max(this.time,time);
      time=new MapRefresher<InterpolatableZoom>().refreshMap(zooms);
      this.time=Math.max(this.time,time);
      time=new MapRefresher<InterpolatableHeading>().refreshMap(headings);
      this.time=Math.max(this.time,time);
      time=new MapRefresher<InterpolatablePitch>().refreshMap(pitchs);
      this.time=Math.max(this.time,time);
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
  }
}",0.9192982456140352
11228,"private void calculateOthers(){
  if (params.ignoreOut) {
    v3=v2;
    t3=0;
    a3=0;
    d3=0;
    t1=(v2 - v1) / a1;
    t2=time - t1;
    d2=v2 * t2;
    d1=distance - d2;
    d3Calc=v2 * t3 + 0.5 * a3 * t3* t3;
  }
 else   if (params.ignoreIn) {
    v1=v2;
    a1=0;
    t1=0;
    d1=0;
    t3=(v3 - v2) / a3;
    t2=time - t3;
    d2=v2 * t2;
    d3=distance - d2;
    d3Calc=v2 * t3 + 0.5 * a3 * t3* t3;
  }
 else {
    t1=(v2 - v1) / a1;
    t3=(v3 - v1 - a1 * t1) / a3;
    t2=time - t3 - t1;
    d1=v1 * t1 + 0.5 * a1 * t1* t1;
    d2=v2 * t2;
    d3=distance - d1 - d2;
    d3Calc=v2 * t3 + 0.5 * a3 * t3* t3;
  }
}","private void calculateOthers(){
  if (params.ignoreOut) {
    v3=v2;
    a3=0;
    t1=(v2 - v1) / a1;
    t3=0;
    t2=time - t1;
    d2=v2 * t2;
    d1=distance - d2;
    d3=0;
  }
 else   if (params.ignoreIn) {
    v1=v2;
    a1=0;
    t1=0;
    t3=(v3 - v2) / a3;
    t2=time - t3;
    d1=0;
    d2=v2 * t2;
    d3=distance - d2;
  }
 else {
    t1=(v2 - v1) / a1;
    t3=(v3 - v1 - a1 * t1) / a3;
    t2=time - t3 - t1;
    d1=v1 * t1 + 0.5 * a1 * t1* t1;
    d2=v2 * t2;
    d3=distance - d1 - d2;
  }
  d3Calc=v2 * t3 + 0.5 * a3 * t3* t3;
  System.out.println();
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"" + t1 + ""String_Node_Str""+ t2+ ""String_Node_Str""+ t3);
  System.out.println(""String_Node_Str"" + v1 + ""String_Node_Str""+ v2+ ""String_Node_Str""+ v3);
  System.out.println(""String_Node_Str"" + d1 + ""String_Node_Str""+ d2+ ""String_Node_Str""+ d3+ ""String_Node_Str""+ d3Calc+ ""String_Node_Str"");
  System.out.println(""String_Node_Str"" + a1 + ""String_Node_Str""+ a3);
}",0.2203182374541003
11229,"private void refresh(){
  a1=params.accelerationIn;
  a3=params.accelerationOut;
  v1=v1forced ? forcev1 : params.velocityIn;
  v3=params.velocityOut;
  calculate();
  if (!isValid()) {
    a1=-a1;
    calculate();
    if (!isValid()) {
      a3=-a3;
      calculate();
      if (!isValid()) {
        a1=-a1;
        calculate();
        if (!isValid()) {
          throw new IllegalArgumentException();
        }
      }
    }
  }
}","private void refresh(){
  a1=params.accelerationIn;
  a3=params.accelerationOut;
  v1=v1forced ? forcev1 : params.velocityIn;
  v3=params.velocityOut;
  calculate();
  if (!isValid()) {
    a1=-a1;
    calculate();
    if (!isValid()) {
      a3=-a3;
      calculate();
      if (!isValid()) {
        a1=-a1;
        calculate();
        if (!isValid()) {
          throw new IllegalArgumentException();
        }
      }
    }
  }
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
  System.out.println(""String_Node_Str"");
}",0.875882946518668
11230,"private void calculate(){
  double a, b, c;
  if (params.ignoreOut) {
    a=1;
    b=2 * (-v1 - time * a1);
    c=2 * a1 * distance + v1 * v1;
  }
 else   if (params.ignoreIn) {
    a=-1;
    b=2 * (v3 - time * a3);
    c=2 * a3 * distance - v3 * v3;
  }
 else {
    a=a1 - a3;
    b=2 * (a1 * a3 * time + a3 * v1 - a1 * v3);
    c=a1 * v3 * v3 - a3 * v1 * v1 - 2 * a1 * a3* distance;
  }
  calculateV2(a,b,c,false);
  calculateOthers();
  if (!isValid()) {
    calculateV2(a,b,c,true);
    calculateOthers();
  }
}","private void calculate(){
  double a, b, c;
  if (params.ignoreOut) {
    a=1;
    b=2 * (-v1 - time * a1);
    c=2 * a1 * distance + v1 * v1;
  }
 else   if (params.ignoreIn) {
    a=-1;
    b=2 * (v3 - time * a3);
    c=2 * a3 * distance - v3 * v3;
  }
 else {
    a=a1 - a3;
    b=2 * (a1 * a3 * time + a3 * v1 - a1 * v3);
    c=a1 * v3 * v3 - a3 * v1 * v1 - 2 * a1 * a3* distance;
  }
  if (a == 0) {
    v2=(2 * a1 * a1* distance + a1 * v1 * v1 - a1 * v3 * v3) / (2 * (a1 * a1 * time + a1 * v1 - a1 * v3));
    calculateOthers();
  }
 else {
    v2=quadratic(a,b,c,false);
    calculateOthers();
    if (!isValid()) {
      v2=quadratic(a,b,c,true);
      calculateOthers();
    }
  }
}",0.7081260364842454
11231,"private Heading(double degrees){
  while (degrees > 180d) {
    degrees-=360d;
  }
  while (degrees <= -180d) {
    degrees+=360d;
  }
  this.degrees=degrees;
}","private Heading(double degrees){
  this.degrees=degrees;
}",0.5321100917431193
11232,"public Angle getAngle(){
  return Angle.fromDegrees(degrees);
}","public Angle getAngle(){
  return Angle.fromDegrees(fixDegrees(degrees));
}",0.9130434782608696
11233,"/** 
 * Gets a   {@link ScriptInfo} for the given file, creating a new one if noneare registered with the service.
 */
private ScriptInfo getOrCreate(final File file){
  final ScriptInfo info=scripts().get(file);
  if (info != null)   return info;
  return new ScriptInfo(getContext(),file);
}","/** 
 * Gets a   {@link ScriptInfo} for the given file, creating a new one if noneare registered with the service.
 */
private ScriptInfo getOrCreate(final File file){
  final ScriptInfo info=scripts().get(file.getAbsolutePath());
  if (info != null)   return info;
  return new ScriptInfo(getContext(),file);
}",0.9701986754966888
11234,"/** 
 * @deprecated Use {@link Types#returnType} instead. 
 */
@Deprecated public static Type getMethodReturnType(final Method method,final Class<?> type){
  return Types.methodReturnType(method,type);
}","/** 
 * @deprecated Use {@link Types#methodReturnType} instead. 
 */
@Deprecated public static Type getMethodReturnType(final Method method,final Class<?> type){
  return Types.methodReturnType(method,type);
}",0.9805825242718448
11235,"/** 
 * @deprecated Use {@link Types#returnType} and {@link Types#raws} instead.
 */
@Deprecated public static List<Class<?>> getMethodReturnClasses(final Method method,final Class<?> type){
  return Types.raws(Types.methodReturnType(method,type));
}","/** 
 * @deprecated Use {@link Types#methodReturnType} and {@link Types#raws} instead.
 */
@Deprecated public static List<Class<?>> getMethodReturnClasses(final Method method,final Class<?> type){
  return Types.raws(Types.methodReturnType(method,type));
}",0.984189723320158
11236,"/** 
 * Returns the primitive   {@link Class} closest to the given type.<p> Specifically, the following type conversions are done: <ul> <li>Boolean.class becomes boolean.class</li> <li>Byte.class becomes byte.class</li> <li>Character.class becomes char.class</li> <li>Double.class becomes double.class</li> <li>Float.class becomes float.class</li> <li>Integer.class becomes int.class</li> <li>Long.class becomes long.class</li> <li>Short.class becomes short.class</li> <li>Void.class becomes void.class</li> </ul> All other types are unchanged. </p>
 */
public static <T>Class<T> unbox(final Class<T> type){
  final Class<?> destType;
  if (type == Boolean.class)   destType=boolean.class;
 else   if (type == Byte.class)   destType=byte.class;
 else   if (type == Character.class)   destType=char.class;
 else   if (type == Double.class)   destType=double.class;
 else   if (type == Float.class)   destType=float.class;
 else   if (type == Integer.class)   destType=int.class;
 else   if (type == Long.class)   destType=long.class;
 else   if (type == Short.class)   destType=short.class;
 else   if (type == Void.class)   destType=void.class;
 else   destType=type;
  @SuppressWarnings(""String_Node_Str"") final Class<T> result=(Class<T>)destType;
  return result;
}","/** 
 * Returns the primitive   {@link Class} closest to the given type.<p> Specifically, the following type conversions are done: </p> <ul> <li>Boolean.class becomes boolean.class</li> <li>Byte.class becomes byte.class</li> <li>Character.class becomes char.class</li> <li>Double.class becomes double.class</li> <li>Float.class becomes float.class</li> <li>Integer.class becomes int.class</li> <li>Long.class becomes long.class</li> <li>Short.class becomes short.class</li> <li>Void.class becomes void.class</li> </ul> <p> All other types are unchanged. </p>
 */
public static <T>Class<T> unbox(final Class<T> type){
  final Class<?> destType;
  if (type == Boolean.class)   destType=boolean.class;
 else   if (type == Byte.class)   destType=byte.class;
 else   if (type == Character.class)   destType=char.class;
 else   if (type == Double.class)   destType=double.class;
 else   if (type == Float.class)   destType=float.class;
 else   if (type == Integer.class)   destType=int.class;
 else   if (type == Long.class)   destType=long.class;
 else   if (type == Short.class)   destType=short.class;
 else   if (type == Void.class)   destType=void.class;
 else   destType=type;
  @SuppressWarnings(""String_Node_Str"") final Class<T> result=(Class<T>)destType;
  return result;
}",0.9964608729846638
11237,"/** 
 * Returns the non-primitive   {@link Class} closest to the given type.<p> Specifically, the following type conversions are done: <ul> <li>boolean.class becomes Boolean.class</li> <li>byte.class becomes Byte.class</li> <li>char.class becomes Character.class</li> <li>double.class becomes Double.class</li> <li>float.class becomes Float.class</li> <li>int.class becomes Integer.class</li> <li>long.class becomes Long.class</li> <li>short.class becomes Short.class</li> <li>void.class becomes Void.class</li> </ul> All other types are unchanged. </p>
 */
public static <T>Class<T> box(final Class<T> type){
  final Class<?> destType;
  if (type == boolean.class)   destType=Boolean.class;
 else   if (type == byte.class)   destType=Byte.class;
 else   if (type == char.class)   destType=Character.class;
 else   if (type == double.class)   destType=Double.class;
 else   if (type == float.class)   destType=Float.class;
 else   if (type == int.class)   destType=Integer.class;
 else   if (type == long.class)   destType=Long.class;
 else   if (type == short.class)   destType=Short.class;
 else   if (type == void.class)   destType=Void.class;
 else   destType=type;
  @SuppressWarnings(""String_Node_Str"") final Class<T> result=(Class<T>)destType;
  return result;
}","/** 
 * Returns the non-primitive   {@link Class} closest to the given type.<p> Specifically, the following type conversions are done: </p> <ul> <li>boolean.class becomes Boolean.class</li> <li>byte.class becomes Byte.class</li> <li>char.class becomes Character.class</li> <li>double.class becomes Double.class</li> <li>float.class becomes Float.class</li> <li>int.class becomes Integer.class</li> <li>long.class becomes Long.class</li> <li>short.class becomes Short.class</li> <li>void.class becomes Void.class</li> </ul> <p> All other types are unchanged. </p>
 */
public static <T>Class<T> box(final Class<T> type){
  final Class<?> destType;
  if (type == boolean.class)   destType=Boolean.class;
 else   if (type == byte.class)   destType=Byte.class;
 else   if (type == char.class)   destType=Character.class;
 else   if (type == double.class)   destType=Double.class;
 else   if (type == float.class)   destType=Float.class;
 else   if (type == int.class)   destType=Integer.class;
 else   if (type == long.class)   destType=Long.class;
 else   if (type == short.class)   destType=Short.class;
 else   if (type == void.class)   destType=Void.class;
 else   destType=type;
  @SuppressWarnings(""String_Node_Str"") final Class<T> result=(Class<T>)destType;
  return result;
}",0.9964664310954064
11238,"@Override public UserInterface getDefaultUI(){
  if (isHeadless())   return uiMap().get(HeadlessUI.NAME);
  if (defaultUI != null)   return defaultUI;
  return uiList().isEmpty() ? null : uiList().get(0);
}","@Override public UserInterface getDefaultUI(){
  if (!initialized)   discoverUIs();
  if (isHeadless())   return uiMap().get(HeadlessUI.NAME);
  if (defaultUI != null)   return defaultUI;
  return uiList().isEmpty() ? null : uiList().get(0);
}",0.9175946547884188
11239,"@Override public void run(){
  save();
  for (  final ModuleItem<?> input : getInfo().inputs()) {
    unresolveInput(input.getName());
  }
  eventService.publish(new OptionsEvent(this));
}","@Override public void run(){
  save();
  eventService.publish(new OptionsEvent(this));
  resetState();
}",0.6027397260273972
11240,"/** 
 * Format a   {@link WildcardType} as a {@link String}.
 * @param w {@code WildcardType} to format
 * @return String
 * @since 3.2
 */
private static String wildcardTypeToString(final WildcardType w){
  final StringBuilder buf=new StringBuilder().append('?');
  final Type[] lowerBounds=w.getLowerBounds();
  final Type[] upperBounds=w.getUpperBounds();
  if (lowerBounds.length > 1 || lowerBounds.length == 1 && lowerBounds[0] != null) {
    appendAllTo(buf.append(""String_Node_Str""),""String_Node_Str"",lowerBounds);
  }
 else   if (upperBounds.length > 1 || upperBounds.length == 1 && !Object.class.equals(upperBounds[0])) {
    appendAllTo(buf.append(""String_Node_Str""),""String_Node_Str"",upperBounds);
  }
  return buf.toString();
}","/** 
 * Format a   {@link WildcardType} as a {@link String}.
 * @param w {@code WildcardType} to format
 * @param done list of already-encountered types
 * @return String
 * @since 3.2
 */
private static String wildcardTypeToString(final WildcardType w,final Set<Type> done){
  final StringBuilder buf=new StringBuilder().append('?');
  if (done.contains(w))   return buf.toString();
  done.add(w);
  final Type[] lowerBounds=w.getLowerBounds();
  final Type[] upperBounds=w.getUpperBounds();
  if (lowerBounds.length > 1 || lowerBounds.length == 1 && lowerBounds[0] != null) {
    appendAllTo(buf.append(""String_Node_Str""),""String_Node_Str"",done,lowerBounds);
  }
 else   if (upperBounds.length > 1 || upperBounds.length == 1 && !Object.class.equals(upperBounds[0])) {
    appendAllTo(buf.append(""String_Node_Str""),""String_Node_Str"",done,upperBounds);
  }
  return buf.toString();
}",0.9112207151664612
11241,"/** 
 * Format a   {@link TypeVariable} including its {@link GenericDeclaration}.
 * @param var the type variable to create a String representation for, not{@code null}
 * @return String
 * @since 3.2
 */
public static String toLongString(final TypeVariable<?> var){
  validateNotNull(var,""String_Node_Str"");
  final StringBuilder buf=new StringBuilder();
  final GenericDeclaration d=((TypeVariable<?>)var).getGenericDeclaration();
  if (d instanceof Class<?>) {
    Class<?> c=(Class<?>)d;
    while (true) {
      if (c.getEnclosingClass() == null) {
        buf.insert(0,c.getName());
        break;
      }
      buf.insert(0,c.getSimpleName()).insert(0,'.');
      c=c.getEnclosingClass();
    }
  }
 else   if (d instanceof Type) {
    buf.append(toString((Type)d));
  }
 else {
    buf.append(d);
  }
  return buf.append(':').append(typeVariableToString(var)).toString();
}","/** 
 * Format a   {@link TypeVariable} including its {@link GenericDeclaration}.
 * @param var the type variable to create a String representation for, not{@code null}
 * @return String
 * @since 3.2
 */
public static String toLongString(final TypeVariable<?> var){
  validateNotNull(var,""String_Node_Str"");
  final StringBuilder buf=new StringBuilder();
  final GenericDeclaration d=((TypeVariable<?>)var).getGenericDeclaration();
  if (d instanceof Class<?>) {
    Class<?> c=(Class<?>)d;
    while (true) {
      if (c.getEnclosingClass() == null) {
        buf.insert(0,c.getName());
        break;
      }
      buf.insert(0,c.getSimpleName()).insert(0,'.');
      c=c.getEnclosingClass();
    }
  }
 else   if (d instanceof Type) {
    buf.append(toString((Type)d));
  }
 else {
    buf.append(d);
  }
  return buf.append(':').append(typeVariableToString(var,new HashSet<>())).toString();
}",0.9910011248593926
11242,"/** 
 * Format a   {@link TypeVariable} as a {@link String}.
 * @param v {@code TypeVariable} to format
 * @return String
 * @since 3.2
 */
private static String typeVariableToString(final TypeVariable<?> v){
  final StringBuilder buf=new StringBuilder(v.getName());
  final Type[] bounds=v.getBounds();
  if (bounds.length > 0 && !(bounds.length == 1 && Object.class.equals(bounds[0]))) {
    buf.append(""String_Node_Str"");
    appendAllTo(buf,""String_Node_Str"",v.getBounds());
  }
  return buf.toString();
}","/** 
 * Format a   {@link TypeVariable} as a {@link String}.
 * @param v {@code TypeVariable} to format
 * @param done list of already-encountered types
 * @return String
 * @since 3.2
 */
private static String typeVariableToString(final TypeVariable<?> v,final Set<Type> done){
  final StringBuilder buf=new StringBuilder(v.getName());
  if (done.contains(v))   return buf.toString();
  done.add(v);
  final Type[] bounds=v.getBounds();
  if (bounds.length > 0 && !(bounds.length == 1 && Object.class.equals(bounds[0]))) {
    buf.append(""String_Node_Str"");
    appendAllTo(buf,""String_Node_Str"",done,v.getBounds());
  }
  return buf.toString();
}",0.8798617113223854
11243,"/** 
 * Append   {@code types} to {@code buf} with separator {@code sep}.
 * @param buf destination
 * @param sep separator
 * @param types to append
 * @return {@code buf}
 * @since 3.2
 */
private static StringBuilder appendAllTo(final StringBuilder buf,final String sep,final Type... types){
  validateNotEmpty(validateNoNullElements(types));
  if (types.length > 0) {
    buf.append(toString(types[0]));
    for (int i=1; i < types.length; i++) {
      buf.append(sep).append(toString(types[i]));
    }
  }
  return buf;
}","/** 
 * Append   {@code types} to {@code buf} with separator {@code sep}.
 * @param buf destination
 * @param sep separator
 * @param done list of already-encountered types
 * @param types to append
 * @return {@code buf}
 * @since 3.2
 */
private static StringBuilder appendAllTo(final StringBuilder buf,final String sep,final Set<Type> done,final Type... types){
  validateNotEmpty(validateNoNullElements(types));
  if (types.length > 0) {
    buf.append(toString(types[0],done));
    for (int i=1; i < types.length; i++) {
      buf.append(sep).append(toString(types[i],done));
    }
  }
  return buf;
}",0.9293286219081272
11244,"/** 
 * Format a   {@link Class} as a {@link String}.
 * @param c {@code Class} to format
 * @return String
 * @since 3.2
 */
private static String classToString(final Class<?> c){
  final StringBuilder buf=new StringBuilder();
  if (c.getEnclosingClass() != null) {
    buf.append(classToString(c.getEnclosingClass())).append('.').append(c.getSimpleName());
  }
 else {
    buf.append(c.getName());
  }
  if (c.getTypeParameters().length > 0) {
    buf.append('<');
    appendAllTo(buf,""String_Node_Str"",c.getTypeParameters());
    buf.append('>');
  }
  return buf.toString();
}","/** 
 * Format a   {@link Class} as a {@link String}.
 * @param c {@code Class} to format
 * @param done list of already-encountered types
 * @return String
 * @since 3.2
 */
private static String classToString(final Class<?> c,final Set<Type> done){
  final StringBuilder buf=new StringBuilder();
  if (c.getEnclosingClass() != null) {
    buf.append(classToString(c.getEnclosingClass(),done)).append('.').append(c.getSimpleName());
  }
 else {
    buf.append(c.getName());
  }
  if (c.getTypeParameters().length > 0) {
    buf.append('<');
    appendAllTo(buf,""String_Node_Str"",done,c.getTypeParameters());
    buf.append('>');
  }
  return buf.toString();
}",0.935483870967742
11245,"/** 
 * Present a given type as a Java-esque String.
 * @param type the type to create a String representation for, not{@code null}
 * @return String
 * @since 3.2
 */
public static String toString(final Type type){
  validateNotNull(type);
  if (type instanceof Class<?>) {
    return classToString((Class<?>)type);
  }
  if (type instanceof ParameterizedType) {
    return parameterizedTypeToString((ParameterizedType)type);
  }
  if (type instanceof WildcardType) {
    return wildcardTypeToString((WildcardType)type);
  }
  if (type instanceof TypeVariable<?>) {
    return typeVariableToString((TypeVariable<?>)type);
  }
  if (type instanceof GenericArrayType) {
    return genericArrayTypeToString((GenericArrayType)type);
  }
  throw new IllegalArgumentException(""String_Node_Str"" + type.getClass().getName());
}","private static String toString(final Type type,final Set<Type> done){
  validateNotNull(type);
  if (type instanceof Class<?>) {
    return classToString((Class<?>)type,done);
  }
  if (type instanceof ParameterizedType) {
    return parameterizedTypeToString((ParameterizedType)type,done);
  }
  if (type instanceof WildcardType) {
    return wildcardTypeToString((WildcardType)type,done);
  }
  if (type instanceof TypeVariable<?>) {
    return typeVariableToString((TypeVariable<?>)type,done);
  }
  if (type instanceof GenericArrayType) {
    return genericArrayTypeToString((GenericArrayType)type);
  }
  throw new IllegalArgumentException(""String_Node_Str"" + type.getClass().getName());
}",0.8071334214002642
11246,"/** 
 * Format a   {@link ParameterizedType} as a {@link String}.
 * @param p {@code ParameterizedType} to format
 * @return String
 * @since 3.2
 */
private static String parameterizedTypeToString(final ParameterizedType p){
  final StringBuilder buf=new StringBuilder();
  final Type useOwner=p.getOwnerType();
  final Class<?> raw=(Class<?>)p.getRawType();
  final Type[] typeArguments=p.getActualTypeArguments();
  if (useOwner == null) {
    buf.append(raw.getName());
  }
 else {
    if (useOwner instanceof Class<?>) {
      buf.append(((Class<?>)useOwner).getName());
    }
 else {
      buf.append(useOwner.toString());
    }
    buf.append('.').append(raw.getSimpleName());
  }
  appendAllTo(buf.append('<'),""String_Node_Str"",typeArguments).append('>');
  return buf.toString();
}","/** 
 * Format a   {@link ParameterizedType} as a {@link String}.
 * @param p {@code ParameterizedType} to format
 * @param done list of already-encountered types
 * @return String
 * @since 3.2
 */
private static String parameterizedTypeToString(final ParameterizedType p,final Set<Type> done){
  final StringBuilder buf=new StringBuilder();
  final Type useOwner=p.getOwnerType();
  final Class<?> raw=(Class<?>)p.getRawType();
  final Type[] typeArguments=p.getActualTypeArguments();
  if (useOwner == null) {
    buf.append(raw.getName());
  }
 else {
    if (useOwner instanceof Class<?>) {
      buf.append(((Class<?>)useOwner).getName());
    }
 else {
      buf.append(useOwner.toString());
    }
    buf.append('.').append(raw.getSimpleName());
  }
  appendAllTo(buf.append('<'),""String_Node_Str"",done,typeArguments).append('>');
  return buf.toString();
}",0.9546827794561934
11247,"private String prefKey(final ModuleItem<?> item){
  final String persistKey=item.getPersistKey();
  return persistKey == null || persistKey.isEmpty() ? persistKey : item.getName();
}","private String prefKey(final ModuleItem<?> item){
  final String persistKey=item.getPersistKey();
  return persistKey == null || persistKey.isEmpty() ? item.getName() : persistKey;
}",0.9285714285714286
11248,"@Override public void setBytes(final long startpos,final byte[] bytes,final int offset,final int length){
  checkWritePos(startpos,startpos + length);
  final int neededCapacity=(int)(Math.max(maxBufferedPos,0) + length);
  buffer.ensureCapacity(neededCapacity);
  System.arraycopy(bytes,offset,buffer.getArray(),(int)startpos,length);
  buffer.setSize(neededCapacity);
  updateMaxPos(startpos + length);
}","@Override public void setBytes(final long startpos,final byte[] bytes,final int offset,final int length){
  checkWritePos(startpos,startpos + length);
  final int neededCapacity=(int)(Math.max(maxBufferedPos,0) + length);
  buffer.ensureCapacity(neededCapacity);
  System.arraycopy(bytes,offset,buffer.getArray(),(int)startpos,length);
  buffer.setSize(neededCapacity);
  updateMaxPos(startpos + length - 1);
}",0.9950980392156864
11249,"@Override public void setByte(final long pos,final byte b){
  checkWritePos(pos,pos);
  buffer.setValue((int)pos,b);
  updateMaxPos(pos);
}","@Override public void setByte(final long pos,final byte b){
  checkWritePos(pos,pos);
  buffer.ensureCapacity((int)pos);
  if (pos == buffer.size()) {
    buffer.setSize((int)(pos + 1));
  }
  buffer.setValue((int)pos,b);
  updateMaxPos(pos);
}",0.7258485639686684
11250,"@Override public int getBytes(final long startPos,final byte[] b,final int offset,final int length){
  checkReadPos(startPos,startPos + length);
  final int readLength=(int)Math.min(getMaxPos() - startPos,length);
  System.arraycopy(buffer.getArray(),(int)startPos,b,offset,readLength);
  return readLength;
}","@Override public int getBytes(final long startPos,final byte[] b,final int offset,final int length){
  checkReadPos(startPos,startPos + length);
  final int readLength=(int)Math.min(getMaxPos() - startPos + 1,length);
  System.arraycopy(buffer.getArray(),(int)startPos,b,offset,readLength);
  return readLength;
}",0.9935691318327974
11251,"@Override public void setBytes(final long startpos,final byte[] bytes,final int offset,final int length){
  checkWritePos(startpos,startpos + length);
  final int neededCapacity=Math.max(maxBufferedPos,0) + length;
  ensureCapacity(neededCapacity);
  buffer.position((int)startpos);
  buffer.put(bytes,offset,length);
  updateMaxPos(startpos + length);
}","@Override public void setBytes(final long startpos,final byte[] bytes,final int offset,final int length){
  checkWritePos(startpos,startpos + length);
  final int neededCapacity=Math.max(maxBufferedPos,0) + length;
  ensureCapacity(neededCapacity);
  buffer.position((int)startpos);
  buffer.put(bytes,offset,length);
  updateMaxPos(startpos + length - 1);
}",0.99438202247191
11252,"@Override public void setByte(final long pos,final byte b){
  checkWritePos(pos,pos);
  buffer.put((int)pos,b);
  updateMaxPos(pos);
}","@Override public void setByte(final long pos,final byte b){
  checkWritePos(pos,pos);
  if (pos == buffer.capacity()) {
    ensureCapacity((int)pos + 1);
  }
  buffer.put((int)pos,b);
  updateMaxPos(pos);
}",0.788235294117647
11253,"@Override public int getBytes(final long startPos,final byte[] b,final int offset,final int length){
  checkReadPos(startPos,startPos + length);
  buffer.position((int)startPos);
  buffer.get(b,offset,length);
  return length;
}","@Override public int getBytes(final long startPos,final byte[] b,final int offset,final int length){
  checkReadPos(startPos,startPos + length);
  final int readLength=(int)Math.min(getMaxPos() - startPos + 1,length);
  buffer.position((int)startPos);
  buffer.get(b,offset,readLength);
  return readLength;
}",0.8417132216014898
11254,"/** 
 * Tests   {@link BytesLocation#BytesLocation(byte[],int,int)}. 
 */
@Test public void testBytesOffsetLength(){
  final byte[] digits={3,1,4,1,5,9,2,6,5,3,5,8,9,7,9};
  final int offset=3, length=5;
  final BytesLocation loc=new BytesLocation(digits,offset,length);
  final byte[] testDigits=new byte[digits.length];
  loc.getByteBank().getBytes(0,testDigits);
  assertEquals(length,loc.getByteBank().getMaxPos());
  final byte[] expectedDigits=new byte[digits.length];
  System.arraycopy(digits,offset,expectedDigits,0,length);
  assertArrayEquals(expectedDigits,testDigits);
}","/** 
 * Tests   {@link BytesLocation#BytesLocation(byte[],int,int)}. 
 */
@Test public void testBytesOffsetLength(){
  final byte[] digits={3,1,4,1,5,9,2,6,5,3,5,8,9,7,9};
  final int offset=3, length=5;
  final BytesLocation loc=new BytesLocation(digits,offset,length);
  final byte[] testDigits=new byte[digits.length];
  loc.getByteBank().getBytes(0,testDigits);
  assertEquals(length - 1,loc.getByteBank().getMaxPos());
  final byte[] expectedDigits=new byte[digits.length];
  System.arraycopy(digits,offset,expectedDigits,0,length);
  assertArrayEquals(expectedDigits,testDigits);
}",0.9965811965811966
11255,"/** 
 * Loads the index of all classes annotated with the specified annotation. <p> </p>
 * @param annotation the annotation type
 * @param loader the class loader to use when loading {@link Class}-type annotation fields
 * @return the index
 */
public static <A extends Annotation>Index<A> load(final Class<A> annotation,final ClassLoader loader){
  EclipseHelper.updateAnnotationIndex(loader);
  return new Index<>(annotation,loader);
}","/** 
 * Loads the index of all classes annotated with the specified annotation.
 * @param annotation the annotation type
 * @param loader the class loader to use when loading {@link Class}-type annotation fields
 * @return the index
 */
public static <A extends Annotation>Index<A> load(final Class<A> annotation,final ClassLoader loader){
  EclipseHelper.updateAnnotationIndex(loader);
  return new Index<>(annotation,loader);
}",0.9896193771626296
11256,"/** 
 * @see #supports(ConversionRequest)
 * @deprecated Use {@link #supports(Object,Type)}
 */
@Deprecated boolean supports(Class<?> src,Type dest);","/** 
 * @see HandlerService#supports(Object)
 * @deprecated Use {@link #supports(Object,Type)}
 */
@Deprecated boolean supports(Class<?> src,Type dest);",0.8903654485049833
11257,"/** 
 * @see #getHandler(ConversionRequest)
 * @deprecated Use {@link #getHandler(Object,Type)}
 */
@Deprecated Converter<?,?> getHandler(Class<?> src,Type dest);","/** 
 * @see HandlerService#getHandler(Object)
 * @deprecated Use {@link #getHandler(Object,Type)}
 */
@Deprecated Converter<?,?> getHandler(Class<?> src,Type dest);",0.8990825688073395
11258,"/** 
 * Gets how deep into the menu structure this node is. For example, ""File"" would be at depth 1, whereas ""Exit"" (of ""File>Exit"") would be at depth 2.
 */
public int getMenuDepth(){
  return menuDepth;
}","/** 
 * Gets how deep into the menu structure this node is. For example, ""File"" would be at depth 1, whereas ""Exit"" (of ""File&gt;Exit"") would be at depth 2.
 */
public int getMenuDepth(){
  return menuDepth;
}",0.9879518072289156
11259,"/** 
 * Parses the script's input and output parameters from the script header. <p> This method is called automatically the first time any parameter accessor method is called (  {@link #getInput},   {@link #getOutput},   {@link #inputs()},  {@link #outputs()}, etc.). Subsequent calls will reparse the parameters. <p> SciJava's scripting framework supports specifying @  {@link Parameter}-style inputs and outputs in a preamble. The format is a simplified version of the Java @  {@link Parameter} annotation syntax. The following syntaxes aresupported: </p> <ul> <li> {@code // @<type> <varName>}</li> <li>  {@code // @<type>(<attr1>=<value1>, ..., <attrN>=<valueN>) <varName>}</li> <li>  {@code // @<IOType> <type> <varName>}</li> <li>  {@code // @<IOType>(<attr1>=<value1>, ..., <attrN>=<valueN>) <type> <varName>}</li> </ul> <p> Where: </p> <ul> <li>  {@code //} = the comment style of the scripting language, so that theparameter line is ignored by the script engine itself.</li> <li> {@code <IOType>} = one of {@code INPUT},   {@code OUTPUT}, or  {@code BOTH}.</li> <li>  {@code <varName>} = the name of the input or output variable.</li><li> {@code <type>} = the Java {@link Class} of the variable.</li><li> {@code <attr*>} = an attribute key.</li><li> {@code <value*>} = an attribute value.</li></ul> <p> See the @ {@link Parameter} annotation for a list of valid attributes.</p> <p> Here are a few examples: </p> <ul> <li> {@code // @Dataset dataset}</li> <li>  {@code // @double(type=OUTPUT) result}</li> <li>  {@code // @BOTH ImageDisplay display}</li> <li>  {@code // @INPUT(persist=false, visibility=INVISIBLE) boolean verbose}</li> parameters will be parsed and filled just like @  {@link Parameter}-annotated fields in   {@link Command}s. </ul>
 */
@Override public void parseParameters(){
  clearParameters();
  appendReturnValue=true;
  try (final BufferedReader in=script == null ? new BufferedReader(new FileReader(getPath())) : getReader()){
    while (true) {
      final String line=in.readLine();
      if (line == null)       break;
      if (line.matches(""String_Node_Str"")) {
        final int at=line.indexOf('@');
        parseParam(line.substring(at + 1));
      }
 else       if (line.matches(""String_Node_Str""))       break;
    }
    if (appendReturnValue)     addReturnValue();
  }
 catch (  final IOException exc) {
    log.error(""String_Node_Str"" + path,exc);
  }
catch (  final ScriptException exc) {
    log.error(""String_Node_Str"" + path,exc);
  }
}","/** 
 * Parses the script's input and output parameters from the script header. <p> This method is called automatically the first time any parameter accessor method is called (  {@link #getInput},   {@link #getOutput},   {@link #inputs()},  {@link #outputs()}, etc.). Subsequent calls will reparse the parameters. <p> SciJava's scripting framework supports specifying @  {@link Parameter}-style inputs and outputs in a preamble. The format is a simplified version of the Java @  {@link Parameter} annotation syntax. The following syntaxes aresupported: </p> <ul> <li> {@code // @<type> <varName>}</li> <li>  {@code // @<type>(<attr1>=<value1>, ..., <attrN>=<valueN>) <varName>}</li> <li>  {@code // @<IOType> <type> <varName>}</li> <li>  {@code // @<IOType>(<attr1>=<value1>, ..., <attrN>=<valueN>) <type> <varName>}</li> </ul> <p> Where: </p> <ul> <li>  {@code //} = the comment style of the scripting language, so that theparameter line is ignored by the script engine itself.</li> <li> {@code <IOType>} = one of {@code INPUT},   {@code OUTPUT}, or  {@code BOTH}.</li> <li>  {@code <varName>} = the name of the input or output variable.</li><li> {@code <type>} = the Java {@link Class} of the variable.</li><li> {@code <attr*>} = an attribute key.</li><li> {@code <value*>} = an attribute value.</li></ul> <p> See the @ {@link Parameter} annotation for a list of valid attributes.</p> <p> Here are a few examples: </p> <ul> <li> {@code // @Dataset dataset}</li> <li>  {@code // @double(type=OUTPUT) result}</li> <li>  {@code // @BOTH ImageDisplay display}</li> <li>  {@code // @INPUT(persist=false, visibility=INVISIBLE) boolean verbose}</li> </ul> <p> Parameters will be parsed and filled just like @  {@link Parameter}-annotated fields in   {@link Command}s. </p>
 */
@Override public void parseParameters(){
  clearParameters();
  appendReturnValue=true;
  try (final BufferedReader in=script == null ? new BufferedReader(new FileReader(getPath())) : getReader()){
    while (true) {
      final String line=in.readLine();
      if (line == null)       break;
      if (line.matches(""String_Node_Str"")) {
        final int at=line.indexOf('@');
        parseParam(line.substring(at + 1));
      }
 else       if (line.matches(""String_Node_Str""))       break;
    }
    if (appendReturnValue)     addReturnValue();
  }
 catch (  final IOException exc) {
    log.error(""String_Node_Str"" + path,exc);
  }
catch (  final ScriptException exc) {
    log.error(""String_Node_Str"" + path,exc);
  }
}",0.996988556514756
11260,"/** 
 * Returns the class and the method/line number of the caller (excluding the specified class). <p> Sometimes it is convenient to determine the caller's context, e.g. to determine whether running in a maven-surefire-plugin context (in which case the location of the caller's class would end in <i>target/test-classes/</i>). </p>
 * @param excluding the class to exclude (or null)
 * @return the class of the caller and the method and line number
 */
public static Map.Entry<Class<?>,String> getCallingCodeLocation(final Class<?> excluding){
  final String thisClassName=TestUtils.class.getName();
  final String thisClassName2=excluding == null ? null : excluding.getName();
  final Thread currentThread=Thread.currentThread();
  for (  final StackTraceElement element : currentThread.getStackTrace()) {
    final String thatClassName=element.getClassName();
    if (thatClassName == null || thatClassName.equals(thisClassName) || thatClassName.equals(thisClassName2) || thatClassName.endsWith(""String_Node_Str"") || thatClassName.startsWith(""String_Node_Str"")) {
      continue;
    }
    final ClassLoader loader=currentThread.getContextClassLoader();
    final Class<?> clazz;
    try {
      clazz=loader.loadClass(element.getClassName());
      final URL url=clazz.getResource(""String_Node_Str"" + clazz.getName().replace('.','/') + ""String_Node_Str"");
      if (url == null || !""String_Node_Str"".equals(url.getProtocol())) {
        continue;
      }
    }
 catch (    ClassNotFoundException e) {
      throw new UnsupportedOperationException(""String_Node_Str"" + element.getClassName() + ""String_Node_Str""+ loader+ ""String_Node_Str"");
    }
    final String suffix=element.getMethodName() + ""String_Node_Str"" + element.getLineNumber();
    return new AbstractMap.SimpleEntry<>(clazz,suffix);
  }
  throw new UnsupportedOperationException(""String_Node_Str"" + thisClassName + ""String_Node_Str"");
}","/** 
 * Returns the class and the method/line number of the caller (excluding the specified class). <p> Sometimes it is convenient to determine the caller's context, e.g. to determine whether running in a maven-surefire-plugin context (in which case the location of the caller's class would end in  {@code target/test-classes/}). </p>
 * @param excluding the class to exclude (or null)
 * @return the class of the caller and the method and line number
 */
public static Map.Entry<Class<?>,String> getCallingCodeLocation(final Class<?> excluding){
  final String thisClassName=TestUtils.class.getName();
  final String thisClassName2=excluding == null ? null : excluding.getName();
  final Thread currentThread=Thread.currentThread();
  for (  final StackTraceElement element : currentThread.getStackTrace()) {
    final String thatClassName=element.getClassName();
    if (thatClassName == null || thatClassName.equals(thisClassName) || thatClassName.equals(thisClassName2) || thatClassName.endsWith(""String_Node_Str"") || thatClassName.startsWith(""String_Node_Str"")) {
      continue;
    }
    final ClassLoader loader=currentThread.getContextClassLoader();
    final Class<?> clazz;
    try {
      clazz=loader.loadClass(element.getClassName());
      final URL url=clazz.getResource(""String_Node_Str"" + clazz.getName().replace('.','/') + ""String_Node_Str"");
      if (url == null || !""String_Node_Str"".equals(url.getProtocol())) {
        continue;
      }
    }
 catch (    ClassNotFoundException e) {
      throw new UnsupportedOperationException(""String_Node_Str"" + element.getClassName() + ""String_Node_Str""+ loader+ ""String_Node_Str"");
    }
    final String suffix=element.getMethodName() + ""String_Node_Str"" + element.getLineNumber();
    return new AbstractMap.SimpleEntry<>(clazz,suffix);
  }
  throw new UnsupportedOperationException(""String_Node_Str"" + thisClassName + ""String_Node_Str"");
}",0.9957983193277312
11261,"/** 
 * Returns the class of the caller (excluding the specified class). <p> Sometimes it is convenient to determine the caller's context, e.g. to determine whether running in a maven-surefire-plugin context (in which case the location of the caller's class would end in <i>target/test-classes/</i>). </p>
 * @param excluding the class to exclude (or null)
 * @return the class of the caller
 */
public static Class<?> getCallingClass(final Class<?> excluding){
  return getCallingCodeLocation(excluding).getKey();
}","/** 
 * Returns the class of the caller (excluding the specified class). <p> Sometimes it is convenient to determine the caller's context, e.g. to determine whether running in a maven-surefire-plugin context (in which case the location of the caller's class would end in  {@code target/test-classes/}). </p>
 * @param excluding the class to exclude (or null)
 * @return the class of the caller
 */
public static Class<?> getCallingClass(final Class<?> excluding){
  return getCallingCodeLocation(excluding).getKey();
}",0.9845261121856866
11262,"/** 
 * Makes a temporary directory for use with unit tests. <p> When the unit test runs in a Maven context, the temporary directory will be created in the corresponding <i>target/</i> directory instead of <i>/tmp/</i>. </p>
 * @param prefix the prefix for the directory's name
 * @param forClass the class for context (to determine whether there's a<i>target/<i> directory)
 * @param suffix the suffix for the directory's name
 * @return the reference to the newly-created temporary directory
 * @throws IOException
 */
public static File createTemporaryDirectory(final String prefix,final Class<?> forClass,final String suffix) throws IOException {
  final URL directory=ClassUtils.getLocation(forClass);
  if (directory == null) {
    throw new IllegalArgumentException(""String_Node_Str"" + forClass);
  }
  if (!""String_Node_Str"".equals(directory.getProtocol())) {
    throw new IllegalArgumentException(""String_Node_Str"" + directory);
  }
  final String path=directory.getPath();
  if (path == null)   throw new IllegalArgumentException(""String_Node_Str"");
  final File baseDirectory;
  if (path.endsWith(""String_Node_Str"")) {
    baseDirectory=new File(path).getParentFile();
  }
 else {
    baseDirectory=new File(path);
  }
  File file=new File(baseDirectory,prefix + suffix);
  if (file.isDirectory()) {
    if (!FileUtils.deleteRecursively(file)) {
      for (int i=-1; file.isDirectory(); i--) {
        file=new File(baseDirectory,prefix + i + suffix);
      }
    }
  }
 else   if (file.exists() && !file.delete()) {
    throw new IOException(""String_Node_Str"" + file);
  }
  if (!file.mkdir())   throw new IOException(""String_Node_Str"" + file);
  return file;
}","/** 
 * Makes a temporary directory for use with unit tests. <p> When the unit test runs in a Maven context, the temporary directory will be created in the corresponding   {@code target/} directory instead of{@code /tmp/}. </p>
 * @param prefix the prefix for the directory's name
 * @param forClass the class for context (to determine whether there's a{@code target/} directory)
 * @param suffix the suffix for the directory's name
 * @return the reference to the newly-created temporary directory
 * @throws IOException
 */
public static File createTemporaryDirectory(final String prefix,final Class<?> forClass,final String suffix) throws IOException {
  final URL directory=ClassUtils.getLocation(forClass);
  if (directory == null) {
    throw new IllegalArgumentException(""String_Node_Str"" + forClass);
  }
  if (!""String_Node_Str"".equals(directory.getProtocol())) {
    throw new IllegalArgumentException(""String_Node_Str"" + directory);
  }
  final String path=directory.getPath();
  if (path == null)   throw new IllegalArgumentException(""String_Node_Str"");
  final File baseDirectory;
  if (path.endsWith(""String_Node_Str"")) {
    baseDirectory=new File(path).getParentFile();
  }
 else {
    baseDirectory=new File(path);
  }
  File file=new File(baseDirectory,prefix + suffix);
  if (file.isDirectory()) {
    if (!FileUtils.deleteRecursively(file)) {
      for (int i=-1; file.isDirectory(); i--) {
        file=new File(baseDirectory,prefix + i + suffix);
      }
    }
  }
 else   if (file.exists() && !file.delete()) {
    throw new IOException(""String_Node_Str"" + file);
  }
  if (!file.mkdir())   throw new IOException(""String_Node_Str"" + file);
  return file;
}",0.8899492991351029
11263,"/** 
 * Checks a <i>.jar</i> file for stale annotations. <p> This method is broken at the moment since there is no good way to verify that SezPoz ran before the <i>.jar</i> file was packaged. </p>
 * @param file the <i>.jar</i> file
 * @see EclipseHelper
 */
@Deprecated public static void checkJar(final File file) throws IOException {
  check(file);
}","/** 
 * Checks a   {@code .jar} file for stale annotations.<p> This method is broken at the moment since there is no good way to verify that SezPoz ran before the  {@code .jar} file was packaged.</p>
 * @param file the {@code .jar} file
 * @see EclipseHelper
 */
@Deprecated public static void checkJar(final File file) throws IOException {
  check(file);
}",0.4422535211267606
11264,"/** 
 * Writes out a DOM as <i>.xml</i> file.
 * @param xml the DOM
 * @param file the file to write
 * @throws TransformerException
 */
@Deprecated public static void writeXMLFile(final Document xml,final File file) throws TransformerException {
  final Source source=new DOMSource(xml);
  final Result result=new StreamResult(file);
  final TransformerFactory factory=TransformerFactory.newInstance();
  final Transformer transformer=factory.newTransformer();
  transformer.setOutputProperty(OutputKeys.INDENT,""String_Node_Str"");
  transformer.setOutputProperty(""String_Node_Str"",""String_Node_Str"");
  transformer.transform(source,result);
}","/** 
 * Writes out a DOM as   {@code .xml} file.
 * @param xml the DOM
 * @param file the file to write
 * @throws TransformerException
 */
@Deprecated public static void writeXMLFile(final Document xml,final File file) throws TransformerException {
  final Source source=new DOMSource(xml);
  final Result result=new StreamResult(file);
  final TransformerFactory factory=TransformerFactory.newInstance();
  final Transformer transformer=factory.newTransformer();
  transformer.setOutputProperty(OutputKeys.INDENT,""String_Node_Str"");
  transformer.setOutputProperty(""String_Node_Str"",""String_Node_Str"");
  transformer.transform(source,result);
}",0.9868114817688132
11265,"/** 
 * Checks whether the annotations are possibly out-of-date. <p> This method looks whether there are any <i>.class</i> files older than their corresponding <i>.java</i> files, or whether there are <i>.class</i> files that were generated since last time we checked. </p>
 * @param classes the <i>classes/</i> directory where Maven puts the<i>.class</i> files
 * @param source the <i>src/main/java/<i> directory where Maven expects the<i>.java</i> files
 * @param youngerThan the date/time when we last checked
 * @see EclipseHelper
 */
@Deprecated public static boolean checkDirectory(final File classes,final File source,final long youngerThan) throws IOException {
  return check(classes);
}","/** 
 * Checks whether the annotations are possibly out-of-date. <p> This method looks whether there are any   {@code .class} files older thantheir corresponding  {@code .java} files, or whether there are{@code .class} files that were generated since last time we checked.</p>
 * @param classes the {@code classes/} directory where Maven puts the{@code .class} files
 * @param source the {@code src/main/java/} directory where Maven expects the{@code .java} files
 * @param youngerThan the date/time when we last checked
 * @see EclipseHelper
 */
@Deprecated public static boolean checkDirectory(final File classes,final File source,final long youngerThan) throws IOException {
  return check(classes);
}",0.5285714285714286
11266,"private <T>void addItem(final String name,final Class<T> type,final Map<String,Object> attrs){
  final DefaultMutableModuleItem<T> item=new DefaultMutableModuleItem<>(this,name,type);
  for (  final String key : attrs.keySet()) {
    final Object value=attrs.get(key);
    assignAttribute(item,key,value);
  }
  if (item.isInput())   registerInput(item);
  if (item.isOutput()) {
    registerOutput(item);
    appendReturnValue=false;
  }
}","private <T>void addItem(final String name,final Class<T> type,final Map<String,Object> attrs,final boolean explicit){
  final DefaultMutableModuleItem<T> item=new DefaultMutableModuleItem<>(this,name,type);
  for (  final String key : attrs.keySet()) {
    final Object value=attrs.get(key);
    assignAttribute(item,key,value);
  }
  if (item.isInput())   registerInput(item);
  if (item.isOutput()) {
    registerOutput(item);
    if (explicit)     appendReturnValue=false;
  }
}",0.9554831704668838
11267,"/** 
 * Adds an output for the value returned by the script itself. 
 */
private void addReturnValue(){
  final HashMap<String,Object> attrs=new HashMap<>();
  attrs.put(""String_Node_Str"",""String_Node_Str"");
  addItem(ScriptModule.RETURN_VALUE,Object.class,attrs);
}","/** 
 * Adds an output for the value returned by the script itself. 
 */
private void addReturnValue(){
  final HashMap<String,Object> attrs=new HashMap<>();
  attrs.put(""String_Node_Str"",""String_Node_Str"");
  addItem(ScriptModule.RETURN_VALUE,Object.class,attrs,false);
}",0.9888475836431226
11268,"private void parseParam(final String param,final Map<String,Object> attrs) throws ScriptException {
  final String[] tokens=param.trim().split(""String_Node_Str"");
  checkValid(tokens.length >= 1,param);
  final String typeName, varName;
  if (isIOType(tokens[0])) {
    checkValid(tokens.length >= 3,param);
    attrs.put(""String_Node_Str"",tokens[0]);
    typeName=tokens[1];
    varName=tokens[2];
  }
 else {
    checkValid(tokens.length >= 2,param);
    typeName=tokens[0];
    varName=tokens[1];
  }
  final Class<?> type=scriptService.lookupClass(typeName);
  addItem(varName,type,attrs);
  if (ScriptModule.RETURN_VALUE.equals(varName)) {
    appendReturnValue=false;
  }
}","private void parseParam(final String param,final Map<String,Object> attrs) throws ScriptException {
  final String[] tokens=param.trim().split(""String_Node_Str"");
  checkValid(tokens.length >= 1,param);
  final String typeName, varName;
  if (isIOType(tokens[0])) {
    checkValid(tokens.length >= 3,param);
    attrs.put(""String_Node_Str"",tokens[0]);
    typeName=tokens[1];
    varName=tokens[2];
  }
 else {
    checkValid(tokens.length >= 2,param);
    typeName=tokens[0];
    varName=tokens[1];
  }
  final Class<?> type=scriptService.lookupClass(typeName);
  addItem(varName,type,attrs,true);
  if (ScriptModule.RETURN_VALUE.equals(varName)) {
    appendReturnValue=false;
  }
}",0.9963316214233308
11269,"@Override public void handle(final LinkedList<String> args){
  if (!supports(args))   return;
  args.removeFirst();
  final String code=args.removeFirst();
  final String arg=getParam(args);
  try {
    if (arg == null)     runService.run(code);
 else {
      final Items items=parser.parse(arg);
      if (items.isMap())       runService.run(code,items.asMap());
 else       if (items.isList())       runService.run(code,items.toArray());
 else {
        throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
      }
    }
  }
 catch (  final InvocationTargetException exc) {
    throw new RuntimeException(exc);
  }
}","@Override public void handle(final LinkedList<String> args){
  if (!supports(args))   return;
  args.removeFirst();
  final String code=args.removeFirst();
  final String arg=getParam(args);
  if (arg != null)   args.removeFirst();
  try {
    if (arg == null)     runService.run(code);
 else {
      final Items items=parser.parse(arg);
      if (items.isMap())       runService.run(code,items.asMap());
 else       if (items.isList())       runService.run(code,items.toArray());
 else {
        throw new IllegalArgumentException(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
      }
    }
  }
 catch (  final InvocationTargetException exc) {
    throw new RuntimeException(exc);
  }
}",0.9698750918442322
11270,"@Override public String getShortName(){
  return getClass().getName().toLowerCase();
}","@Override public String getShortName(){
  return getClass().getSimpleName().toLowerCase();
}",0.9662921348314608
11271,"@Override public void cancel(final String reason){
  cancelReason=reason == null ? ""String_Node_Str"" : reason;
  if (command instanceof Cancelable) {
    ((Cancelable)command).cancel(reason);
  }
}","@Override public void cancel(final String reason){
  if (command instanceof Cancelable) {
    ((Cancelable)command).cancel(reason);
    return;
  }
  cancelReason=reason == null ? ""String_Node_Str"" : reason;
}",0.5517241379310345
11272,"@Override public String getCancelReason(){
  return cancelReason;
}","@Override public String getCancelReason(){
  if (command instanceof Cancelable) {
    return ((Cancelable)command).getCancelReason();
  }
  return cancelReason;
}",0.5851528384279476
11273,"@Override public boolean isCanceled(){
  return cancelReason != null;
}","@Override public boolean isCanceled(){
  if (command instanceof Cancelable) {
    return ((Cancelable)command).isCanceled();
  }
  return cancelReason != null;
}",0.6120689655172413
11274,"/** 
 * Initializes   {@link #scriptLanguageIndex}. 
 */
private synchronized void initScriptLanguageIndex(){
  if (scriptLanguageIndex != null)   return;
  final ScriptLanguageIndex index=new ScriptLanguageIndex(log);
  for (  final ScriptLanguage language : getInstances()) {
    index.add(language,false);
  }
  final ScriptEngineManager manager=new ScriptEngineManager();
  for (  final ScriptEngineFactory factory : manager.getEngineFactories()) {
    index.add(factory,true);
  }
  scriptLanguageIndex=index;
}","/** 
 * Initializes   {@link #scriptLanguageIndex}. 
 */
private synchronized void initScriptLanguageIndex(){
  if (scriptLanguageIndex != null)   return;
  final ScriptLanguageIndex index=new ScriptLanguageIndex(log);
  for (  final ScriptLanguage language : getInstances()) {
    index.add(language,false);
  }
  final ScriptEngineManager manager=new ScriptEngineManager();
  for (  final ScriptEngineFactory factory : manager.getEngineFactories()) {
    index.add(factory,true);
  }
  for (  final ScriptLanguage language : index) {
    if (language.getContext() == null)     language.setContext(getContext());
  }
  scriptLanguageIndex=index;
}",0.845360824742268
11275,"/** 
 * @see java.util.prefs.Preferences#keys() 
 */
public String[] keys(){
  try {
    return p.keys();
  }
 catch (  final java.util.prefs.BackingStoreException exc) {
    log.error(exc);
    return new String[0];
  }
}","/** 
 * @see java.util.prefs.Preferences#keys() 
 */
public String[] keys(){
  try {
    final String[] keys=p.keys();
    for (int i=0; i < keys.length; i++) {
      keys[i]=safeKey(keys[i]);
    }
    return keys;
  }
 catch (  final java.util.prefs.BackingStoreException exc) {
    log.error(exc);
    return new String[0];
  }
}",0.7472924187725631
11276,"/** 
 * @see java.util.prefs.Preferences#getDouble(String,double) 
 */
public double getDouble(final String key,final double def){
  return p.getDouble(key,def);
}","/** 
 * @see java.util.prefs.Preferences#getDouble(String,double) 
 */
public double getDouble(final String key,final double def){
  return p.getDouble(safeKey(key),def);
}",0.9731343283582088
11277,"/** 
 * @see java.util.prefs.Preferences#putDouble(String,double) 
 */
public void putDouble(final String key,final double value){
  p.putDouble(key,value);
}","/** 
 * @see java.util.prefs.Preferences#putDouble(String,double) 
 */
public void putDouble(final String key,final double value){
  p.putDouble(safeKey(key),value);
}",0.9723076923076924
11278,"/** 
 * @see java.util.prefs.Preferences#getFloat(String,float) 
 */
public float getFloat(final String key,final float def){
  return p.getFloat(key,def);
}","/** 
 * @see java.util.prefs.Preferences#getFloat(String,float) 
 */
public float getFloat(final String key,final float def){
  return p.getFloat(safeKey(key),def);
}",0.9721362229102168
11279,"/** 
 * @see java.util.prefs.Preferences#putLong(String,long) 
 */
public void putLong(final String key,final long value){
  p.putLong(key,value);
}","/** 
 * @see java.util.prefs.Preferences#putLong(String,long) 
 */
public void putLong(final String key,final long value){
  p.putLong(safeKey(key),value);
}",0.9704918032786886
11280,"/** 
 * @see java.util.prefs.Preferences#put 
 */
public void put(final String key,final Object value){
  p.put(key,value == null ? null : value.toString());
}","/** 
 * @see java.util.prefs.Preferences#put 
 */
public void put(final String key,final Object value){
  p.put(safeKey(key),value == null ? null : value.toString());
}",0.9724770642201837
11281,"/** 
 * @see java.util.prefs.Preferences#get(String,String) 
 */
public String get(final String key,final String def){
  return p.get(key,def);
}","/** 
 * @see java.util.prefs.Preferences#get(String,String) 
 */
public String get(final String key,final String def){
  return p.get(safeKey(key),def);
}",0.9698996655518396
11282,"/** 
 * @see java.util.prefs.Preferences#getFloat(String,float) 
 */
public boolean getBoolean(final String key,final boolean def){
  return p.getBoolean(key,def);
}","/** 
 * @see java.util.prefs.Preferences#getFloat(String,float) 
 */
public boolean getBoolean(final String key,final boolean def){
  return p.getBoolean(safeKey(key),def);
}",0.9734513274336284
11283,"/** 
 * @see java.util.prefs.Preferences#putBoolean(String,boolean) 
 */
public void putBoolean(final String key,final boolean value){
  p.putBoolean(key,value);
}","/** 
 * @see java.util.prefs.Preferences#putBoolean(String,boolean) 
 */
public void putBoolean(final String key,final boolean value){
  p.putBoolean(safeKey(key),value);
}",0.9731343283582088
11284,"/** 
 * @see java.util.prefs.Preferences#putInt(String,int) 
 */
public void putInt(final String key,final int value){
  p.putInt(key,value);
}","/** 
 * @see java.util.prefs.Preferences#putInt(String,int) 
 */
public void putInt(final String key,final int value){
  p.putInt(safeKey(key),value);
}",0.9694915254237289
11285,"/** 
 * @see java.util.prefs.Preferences#getLong(String,long) 
 */
public long getLong(final String key,final long def){
  return p.getLong(key,def);
}","/** 
 * @see java.util.prefs.Preferences#getLong(String,long) 
 */
public long getLong(final String key,final long def){
  return p.getLong(safeKey(key),def);
}",0.9710610932475884
11286,"/** 
 * @see java.util.prefs.Preferences#getInt(String,int) 
 */
public int getInt(final String key,final int def){
  return p.getInt(key,def);
}","/** 
 * @see java.util.prefs.Preferences#getInt(String,int) 
 */
public int getInt(final String key,final int def){
  return p.getInt(safeKey(key),def);
}",0.9698996655518396
11287,"/** 
 * @see java.util.prefs.Preferences#putFloat(String,float) 
 */
public void putFloat(final String key,final float value){
  p.putFloat(key,value);
}","/** 
 * @see java.util.prefs.Preferences#putFloat(String,float) 
 */
public void putFloat(final String key,final float value){
  p.putFloat(safeKey(key),value);
}",0.9714285714285714
11288,"private <T>void assignDefaultValue(final Module module,final ModuleItem<T> item){
  if (module.isResolved(item.getName()))   return;
  final T defaultValue=moduleService.getDefaultValue(item);
  if (defaultValue == null)   return;
  item.setValue(module,defaultValue);
}","private <T>void assignDefaultValue(final Module module,final ModuleItem<T> item){
  if (module.isResolved(item.getName()))   return;
  final T nullValue=ConversionUtils.getNullValue(item.getType());
  if (MiscUtils.equal(item.getValue(module),nullValue))   return;
  final T defaultValue=moduleService.getDefaultValue(item);
  if (defaultValue == null)   return;
  item.setValue(module,defaultValue);
}",0.8035714285714286
11289,"@Override public Number getStepSize(){
  return tValue(getParameter().stepSize(),Number.class);
}","@Override public Number getStepSize(){
  final String value=getParameter().stepSize();
  try {
    final double stepSize=Double.parseDouble(value);
    return stepSize;
  }
 catch (  final NumberFormatException exc) {
    return tValue(value,Number.class);
  }
}",0.4011142061281337
11290,"/** 
 * Gets the reader which delivers the script's content. <p> This might be null, in which case the content is stored in a file on disk given by   {@link #getPath()}. </p>
 */
public BufferedReader getReader(){
  return reader;
}","/** 
 * Gets a reader which delivers the script's content. <p> This might be null, in which case the content is stored in a file on disk given by   {@link #getPath()}. </p>
 */
public BufferedReader getReader(){
  if (script == null) {
    return null;
  }
  return new BufferedReader(new StringReader(script),PARAM_CHAR_MAX);
}",0.7714285714285715
11291,"/** 
 * Creates a script metadata object which describes a script provided by the given   {@link Reader}.
 * @param context The SciJava application context to use when populatingservice inputs.
 * @param path Pseudo-path to the script file. This file does not actuallyneed to exist, but rather provides a name for the script with file extension.
 * @param reader Reader which provides the script itself (i.e., its contents).
 */
public ScriptInfo(final Context context,final String path,final Reader reader){
  setContext(context);
  this.path=path;
  this.reader=reader == null ? null : new BufferedReader(reader,PARAM_CHAR_MAX);
}","/** 
 * Creates a script metadata object which describes a script provided by the given   {@link Reader}.
 * @param context The SciJava application context to use when populatingservice inputs.
 * @param path Pseudo-path to the script file. This file does not actuallyneed to exist, but rather provides a name for the script with file extension.
 * @param reader Reader which provides the script itself (i.e., its contents).
 */
public ScriptInfo(final Context context,final String path,final Reader reader){
  setContext(context);
  this.path=path;
  String script=null;
  if (reader != null) {
    try {
      script=getReaderContentsAsString(reader);
    }
 catch (    final IOException exc) {
      log.error(""String_Node_Str"" + path,exc);
    }
  }
  this.script=script;
}",0.8119233498935415
11292,"/** 
 * Parses the script's input and output parameters from the script header. <p> This method is called automatically the first time any parameter accessor method is called (  {@link #getInput},   {@link #getOutput},   {@link #inputs()},  {@link #outputs()}, etc.). Subsequent calls will reparse the parameters. <p> SciJava's scripting framework supports specifying @  {@link Parameter}-style inputs and outputs in a preamble. The format is a simplified version of the Java @  {@link Parameter} annotation syntax. The following syntaxes aresupported: </p> <ul> <li> {@code // @<type> <varName>}</li> <li>  {@code // @<type>(<attr1>=<value1>, ..., <attrN>=<valueN>) <varName>}</li> <li>  {@code // @<IOType> <type> <varName>}</li> <li>  {@code // @<IOType>(<attr1>=<value1>, ..., <attrN>=<valueN>) <type> <varName>}</li> </ul> <p> Where: </p> <ul> <li>  {@code //} = the comment style of the scripting language, so that theparameter line is ignored by the script engine itself.</li> <li> {@code <IOType>} = one of {@code INPUT},   {@code OUTPUT}, or  {@code BOTH}.</li> <li>  {@code <varName>} = the name of the input or output variable.</li><li> {@code <type>} = the Java {@link Class} of the variable.</li><li> {@code <attr*>} = an attribute key.</li><li> {@code <value*>} = an attribute value.</li></ul> <p> See the @ {@link Parameter} annotation for a list of valid attributes.</p> <p> Here are a few examples: </p> <ul> <li> {@code // @Dataset dataset}</li> <li>  {@code // @double(type=OUTPUT) result}</li> <li>  {@code // @BOTH ImageDisplay display}</li> <li>  {@code // @INPUT(persist=false, visibility=INVISIBLE) boolean verbose}</li> parameters will be parsed and filled just like @  {@link Parameter}-annotated fields in   {@link Command}s. </ul>
 */
@Override public void parseParameters(){
  clearParameters();
  returnValueDeclared=false;
  try {
    final BufferedReader in;
    if (reader == null) {
      in=new BufferedReader(new FileReader(getPath()));
    }
 else {
      in=reader;
      in.mark(PARAM_CHAR_MAX);
    }
    while (true) {
      final String line=in.readLine();
      if (line == null)       break;
      if (line.matches(""String_Node_Str"")) {
        final int at=line.indexOf('@');
        parseParam(line.substring(at + 1));
      }
 else       if (line.matches(""String_Node_Str""))       break;
    }
    if (reader == null)     in.close();
 else     in.reset();
    if (!returnValueDeclared)     addReturnValue();
  }
 catch (  final IOException exc) {
    log.error(""String_Node_Str"" + path,exc);
  }
catch (  final ScriptException exc) {
    log.error(""String_Node_Str"" + path,exc);
  }
}","/** 
 * Parses the script's input and output parameters from the script header. <p> This method is called automatically the first time any parameter accessor method is called (  {@link #getInput},   {@link #getOutput},   {@link #inputs()},  {@link #outputs()}, etc.). Subsequent calls will reparse the parameters. <p> SciJava's scripting framework supports specifying @  {@link Parameter}-style inputs and outputs in a preamble. The format is a simplified version of the Java @  {@link Parameter} annotation syntax. The following syntaxes aresupported: </p> <ul> <li> {@code // @<type> <varName>}</li> <li>  {@code // @<type>(<attr1>=<value1>, ..., <attrN>=<valueN>) <varName>}</li> <li>  {@code // @<IOType> <type> <varName>}</li> <li>  {@code // @<IOType>(<attr1>=<value1>, ..., <attrN>=<valueN>) <type> <varName>}</li> </ul> <p> Where: </p> <ul> <li>  {@code //} = the comment style of the scripting language, so that theparameter line is ignored by the script engine itself.</li> <li> {@code <IOType>} = one of {@code INPUT},   {@code OUTPUT}, or  {@code BOTH}.</li> <li>  {@code <varName>} = the name of the input or output variable.</li><li> {@code <type>} = the Java {@link Class} of the variable.</li><li> {@code <attr*>} = an attribute key.</li><li> {@code <value*>} = an attribute value.</li></ul> <p> See the @ {@link Parameter} annotation for a list of valid attributes.</p> <p> Here are a few examples: </p> <ul> <li> {@code // @Dataset dataset}</li> <li>  {@code // @double(type=OUTPUT) result}</li> <li>  {@code // @BOTH ImageDisplay display}</li> <li>  {@code // @INPUT(persist=false, visibility=INVISIBLE) boolean verbose}</li> parameters will be parsed and filled just like @  {@link Parameter}-annotated fields in   {@link Command}s. </ul>
 */
@Override public void parseParameters(){
  clearParameters();
  returnValueDeclared=false;
  try {
    final BufferedReader in;
    if (script == null) {
      in=new BufferedReader(new FileReader(getPath()));
    }
 else {
      in=getReader();
    }
    while (true) {
      final String line=in.readLine();
      if (line == null)       break;
      if (line.matches(""String_Node_Str"")) {
        final int at=line.indexOf('@');
        parseParam(line.substring(at + 1));
      }
 else       if (line.matches(""String_Node_Str""))       break;
    }
    in.close();
    if (!returnValueDeclared)     addReturnValue();
  }
 catch (  final IOException exc) {
    log.error(""String_Node_Str"" + path,exc);
  }
catch (  final ScriptException exc) {
    log.error(""String_Node_Str"" + path,exc);
  }
}",0.9776493256262042
11293,"/** 
 * Creates an XML object for an existing document. 
 */
public XML(final String path,final Document doc){
  this.path=path;
  this.doc=doc;
  if (debug) {
    System.err.println(ClassUtils.getLocation(XPathFactory.class));
  }
  XPath xpath=null;
  final Thread thread=Thread.currentThread();
  final ClassLoader contextClassLoader=thread.getContextClassLoader();
  try {
    ClassLoader loader=contextClassLoader;
    for (; ; )     try {
      xpath=XPathFactory.newInstance().newXPath();
      try {
        xpath.evaluate(""String_Node_Str"",doc);
      }
 catch (      Throwable t) {
        if (debug) {
          System.err.println(""String_Node_Str"" + xpath.getClass() + ""String_Node_Str""+ ClassUtils.getLocation(xpath.getClass())+ ""String_Node_Str"");
          t.printStackTrace();
        }
        throw new Error(t);
      }
      break;
    }
 catch (    Error e) {
      if (debug)       e.printStackTrace();
      loader=loader.getParent();
      if (loader == null)       throw e;
      thread.setContextClassLoader(loader);
    }
    this.xpath=xpath;
  }
  finally {
    thread.setContextClassLoader(contextClassLoader);
  }
}","/** 
 * Creates an XML object for an existing document. 
 */
public XML(final String path,final Document doc){
  this.path=path;
  this.doc=doc;
  if (debug) {
    System.err.println(ClassUtils.getLocation(XPathFactory.class));
  }
  XPath xp=null;
  final Thread thread=Thread.currentThread();
  final ClassLoader contextClassLoader=thread.getContextClassLoader();
  try {
    ClassLoader loader=contextClassLoader;
    while (true) {
      try {
        xp=XPathFactory.newInstance().newXPath();
        try {
          xp.evaluate(""String_Node_Str"",doc);
        }
 catch (        Throwable t) {
          if (debug) {
            System.err.println(""String_Node_Str"" + xp.getClass() + ""String_Node_Str""+ ClassUtils.getLocation(xp.getClass())+ ""String_Node_Str"");
            t.printStackTrace();
          }
          throw new Error(t);
        }
        break;
      }
 catch (      Error e) {
        if (debug)         e.printStackTrace();
        loader=loader.getParent();
        if (loader == null)         throw e;
        thread.setContextClassLoader(loader);
      }
    }
    xpath=xp;
  }
  finally {
    thread.setContextClassLoader(contextClassLoader);
  }
}",0.954799827808868
11294,"@Override public <D extends DT>PT create(final D data){
  final PT instance=findWrapper(data);
  if (instance == null) {
    throw new IllegalArgumentException(""String_Node_Str"" + getPluginType().getSimpleName() + ""String_Node_Str""+ data);
  }
  return instance;
}","@Override public <D extends DT>PT create(final D data){
  final PT instance=findWrapper(data);
  if (instance == null) {
    throw new IllegalArgumentException(""String_Node_Str"" + getPluginType().getSimpleName() + ""String_Node_Str""+ data);
  }
  instance.set(data);
  return instance;
}",0.96
11295,"/** 
 * Persist the history.
 * @see {@link Prefs}
 */
public void write(){
  prefs.putIterable(getClass(),entries,PREFIX + name);
}","/** 
 * Persist the history.
 * @see PrefService
 */
public void write(){
  prefs.putIterable(getClass(),entries,PREFIX + name);
}",0.9389312977099236
11296,"/** 
 * This method scans the provided class, its superclasses and interfaces for all supported   {@code} {@link Annotation} : {@link AnnotatedObject} pairs.These are then cached to remove the need for future queries. <p> By combining multiple  {@code Annotation : AnnotatedObject} pairs in onequery, we can limit the number of times a class's superclass and interface hierarchy are traversed. </p>
 * @param scannedClass Class to scan
 * @param query Pairs of {@link Annotation} and {@link AnnotatedObject}s to discover.
 */
public static void cacheAnnotatedObjects(final Class<?> scannedClass,final Query query){
synchronized (scannedClass) {
    if (scannedClass == null || scannedClass == Object.class)     return;
    final Set<Class<? extends Annotation>> keysToDrop=new HashSet<Class<? extends Annotation>>();
    for (    final Class<? extends Annotation> annotationClass : query.keySet()) {
      if (fieldCache.getList(scannedClass,annotationClass) != null) {
        keysToDrop.add(annotationClass);
      }
 else       if (methodCache.getList(scannedClass,annotationClass) != null) {
        keysToDrop.add(annotationClass);
      }
    }
    for (    final Class<? extends Annotation> key : keysToDrop) {
      query.remove(key);
    }
    if (query.isEmpty())     return;
    final List<Class<?>> inherited=new ArrayList<Class<?>>();
    final Class<?> superClass=scannedClass.getSuperclass();
    if (superClass != null) {
      cacheAnnotatedObjects(superClass,new Query(query));
      inherited.add(superClass);
    }
    for (    final Class<?> ifaceClass : scannedClass.getInterfaces()) {
      cacheAnnotatedObjects(ifaceClass,new Query(query));
      inherited.add(ifaceClass);
    }
    for (    final Class<? extends Annotation> annotationClass : query.keySet()) {
      final Class<? extends AnnotatedElement> objectClass=query.get(annotationClass);
      if (Method.class.isAssignableFrom(objectClass)) {
        populateCache(scannedClass,inherited,annotationClass,methodCache,scannedClass.getDeclaredMethods());
      }
 else       if (Field.class.isAssignableFrom(objectClass)) {
        populateCache(scannedClass,inherited,annotationClass,fieldCache,scannedClass.getDeclaredFields());
      }
    }
  }
}","/** 
 * This method scans the provided class, its superclasses and interfaces for all supported   {@link Annotation} : {@link AnnotatedObject} pairs.These are then cached to remove the need for future queries. <p> By combining multiple  {@code Annotation : AnnotatedObject} pairs in onequery, we can limit the number of times a class's superclass and interface hierarchy are traversed. </p>
 * @param scannedClass Class to scan
 * @param query Pairs of {@link Annotation} and {@link AnnotatedObject}s to discover.
 */
public static void cacheAnnotatedObjects(final Class<?> scannedClass,final Query query){
synchronized (scannedClass) {
    if (scannedClass == null || scannedClass == Object.class)     return;
    final Set<Class<? extends Annotation>> keysToDrop=new HashSet<Class<? extends Annotation>>();
    for (    final Class<? extends Annotation> annotationClass : query.keySet()) {
      if (fieldCache.getList(scannedClass,annotationClass) != null) {
        keysToDrop.add(annotationClass);
      }
 else       if (methodCache.getList(scannedClass,annotationClass) != null) {
        keysToDrop.add(annotationClass);
      }
    }
    for (    final Class<? extends Annotation> key : keysToDrop) {
      query.remove(key);
    }
    if (query.isEmpty())     return;
    final List<Class<?>> inherited=new ArrayList<Class<?>>();
    final Class<?> superClass=scannedClass.getSuperclass();
    if (superClass != null) {
      cacheAnnotatedObjects(superClass,new Query(query));
      inherited.add(superClass);
    }
    for (    final Class<?> ifaceClass : scannedClass.getInterfaces()) {
      cacheAnnotatedObjects(ifaceClass,new Query(query));
      inherited.add(ifaceClass);
    }
    for (    final Class<? extends Annotation> annotationClass : query.keySet()) {
      final Class<? extends AnnotatedElement> objectClass=query.get(annotationClass);
      if (Method.class.isAssignableFrom(objectClass)) {
        populateCache(scannedClass,inherited,annotationClass,methodCache,scannedClass.getDeclaredMethods());
      }
 else       if (Field.class.isAssignableFrom(objectClass)) {
        populateCache(scannedClass,inherited,annotationClass,fieldCache,scannedClass.getDeclaredFields());
      }
    }
  }
}",0.998206278026906
11297,"private synchronized void initInstances(){
  if (instances != null)   return;
  final List<PT> list=Collections.unmodifiableList(filterInstances(getPluginService().createInstancesOfType(getPluginType())));
  final HashMap<Class<? extends PT>,PT> map=new HashMap<Class<? extends PT>,PT>();
  for (  final PT plugin : instances) {
    @SuppressWarnings(""String_Node_Str"") final Class<? extends PT> ptClass=(Class<? extends PT>)plugin.getClass();
    map.put(ptClass,plugin);
  }
  log.info(""String_Node_Str"" + list.size() + ""String_Node_Str""+ getPluginType().getSimpleName()+ ""String_Node_Str"");
  instanceMap=map;
  instances=list;
}","private synchronized void initInstances(){
  if (instances != null)   return;
  final List<PT> list=Collections.unmodifiableList(filterInstances(getPluginService().createInstancesOfType(getPluginType())));
  final HashMap<Class<? extends PT>,PT> map=new HashMap<Class<? extends PT>,PT>();
  for (  final PT plugin : list) {
    @SuppressWarnings(""String_Node_Str"") final Class<? extends PT> ptClass=(Class<? extends PT>)plugin.getClass();
    map.put(ptClass,plugin);
  }
  log.info(""String_Node_Str"" + list.size() + ""String_Node_Str""+ getPluginType().getSimpleName()+ ""String_Node_Str"");
  instanceMap=map;
  instances=list;
}",0.9896743447180302
11298,"/** 
 * Creates a new SciJava application context with the specified services (and any required service dependencies). Service dependency candidates are selected from those discovered by the given   {@link PluginIndex}'s associated   {@link org.scijava.plugin.PluginFinder}. <p> NB: Context creation is an important step of a SciJava applictation's lifecycle. Particularly in environments where more than one implementation exists for various services, careful consideration should be exercised regaring what classes and plugins are provided to the Context, and what needs to occur during the initialization of these services (especially those of lower priority). See   {@link ServiceHelper#loadServices()} for moreinformation. </p>
 * @param serviceClasses A collection of types that implement the{@link Service} interface (e.g., {@code DisplayService.class}).
 * @param pluginIndex The plugin index to use when discovering and indexingplugins. If you wish to completely control how services are discovered (i.e., use your own {@link org.scijava.plugin.PluginFinder} implementation), then youcan pass a custom  {@link PluginIndex} here.
 */
public Context(final Collection<Class<? extends Service>> serviceClasses,final PluginIndex pluginIndex){
  serviceIndex=new ServiceIndex();
  this.pluginIndex=pluginIndex == null ? new PluginIndex() : pluginIndex;
  this.pluginIndex.discover();
  final ServiceHelper serviceHelper=new ServiceHelper(this,serviceClasses);
  serviceHelper.loadServices();
}","/** 
 * Creates a new SciJava application context with the specified services (and any required service dependencies). Service dependency candidates are selected from those discovered by the given   {@link PluginIndex}'s associated   {@link org.scijava.plugin.PluginFinder}. <p> NB: Context creation is an important step of a SciJava application's lifecycle. Particularly in environments where more than one implementation exists for various services, careful consideration should be exercised regarding what classes and plugins are provided to the Context, and what needs to occur during the initialization of these services (especially those of lower priority). See   {@link ServiceHelper#loadServices()} for moreinformation. </p>
 * @param serviceClasses A collection of types that implement the{@link Service} interface (e.g., {@code DisplayService.class}).
 * @param pluginIndex The plugin index to use when discovering and indexingplugins. If you wish to completely control how services are discovered (i.e., use your own {@link org.scijava.plugin.PluginFinder} implementation), then youcan pass a custom  {@link PluginIndex} here.
 */
public Context(final Collection<Class<? extends Service>> serviceClasses,final PluginIndex pluginIndex){
  serviceIndex=new ServiceIndex();
  this.pluginIndex=pluginIndex == null ? new PluginIndex() : pluginIndex;
  this.pluginIndex.discover();
  final ServiceHelper serviceHelper=new ServiceHelper(this,serviceClasses);
  serviceHelper.loadServices();
}",0.9993315508021392
11299,"/** 
 * Cancels the command execution, with the given reason for doing so. 
 */
@Override public void cancel(final String reason){
  cancelReason=reason;
}","/** 
 * Cancels the command execution, with the given reason for doing so. 
 */
@Override public void cancel(final String reason){
  cancelReason=reason == null ? ""String_Node_Str"" : reason;
}",0.8933717579250721
11300,"@Override public void cancel(final String reason){
  cancelReason=reason;
}","@Override public void cancel(final String reason){
  cancelReason=reason == null ? ""String_Node_Str"" : reason;
}",0.8021390374331551
11301,"@Override public void cancel(final String reason){
  cancelReason=reason;
}","@Override public void cancel(final String reason){
  cancelReason=reason == null ? ""String_Node_Str"" : reason;
}",0.8021390374331551
11302,"@Override public void cancel(final String reason){
  cancelReason=reason;
}","@Override public void cancel(final String reason){
  cancelReason=reason == null ? ""String_Node_Str"" : reason;
}",0.8021390374331551
11303,"@Override public void cancel(final String reason){
  cancelReason=reason;
}","@Override public void cancel(final String reason){
  cancelReason=reason == null ? ""String_Node_Str"" : reason;
}",0.8021390374331551
11304,"/** 
 * Gets the component type of the given array type, or null if not an array. Supports both regular array types (i.e.,   {@link Class#getComponentType()}if   {@code type} is a {@link Class}) and generic array types (i.e.,  {@link GenericArrayType#getGenericComponentType()} if {@code type} is a{@link GenericArrayType}).
 */
public static Class<?> getComponentClass(final Type type){
  if (type instanceof Class)   return ((Class<?>)type).getComponentType();
  if (type instanceof GenericArrayType) {
    return (Class<?>)((GenericArrayType)type).getGenericComponentType();
  }
  return null;
}","/** 
 * Gets the component type of the given array type, or null if not an array. Supports both regular array types (i.e.,   {@link Class#getComponentType()}if   {@code type} is a {@link Class}) and generic array types (i.e.,  {@link GenericArrayType#getGenericComponentType()} if {@code type} is a{@link GenericArrayType}).
 */
public static Class<?> getComponentClass(final Type type){
  if (type instanceof Class)   return ((Class<?>)type).getComponentType();
  if (type instanceof GenericArrayType) {
    return getClass(((GenericArrayType)type).getGenericComponentType());
  }
  return null;
}",0.9832775919732442
11305,"/** 
 * Tests   {@link CharArray#remove(Object)}. 
 */
@Test public void testRemove(){
  final char[] raw={3,5,8,13,21};
  final CharArray array=new CharArray(raw.clone());
  assertEquals(raw.length,array.size());
  array.remove(new Integer(raw[0]));
  assertEquals(raw.length - 1,array.size());
  array.remove(new Integer(raw[2]));
  assertEquals(raw.length - 2,array.size());
  array.remove(new Integer(raw[4]));
  assertEquals(raw.length - 3,array.size());
  assertEquals(raw[1],array.getValue(0));
  assertEquals(raw[3],array.getValue(1));
}","/** 
 * Tests   {@link CharArray#remove(Object)}. 
 */
@Test public void testRemove(){
  final char[] raw={3,5,8,13,21};
  final CharArray array=new CharArray(raw.clone());
  assertEquals(raw.length,array.size());
  array.remove(new Character(raw[0]));
  assertEquals(raw.length - 1,array.size());
  array.remove(new Character(raw[2]));
  assertEquals(raw.length - 2,array.size());
  array.remove(new Character(raw[4]));
  assertEquals(raw.length - 3,array.size());
  assertEquals(raw[1],array.getValue(0));
  assertEquals(raw[3],array.getValue(1));
}",0.9671532846715328
11306,"/** 
 * Tests   {@link CharArray#containsAll(Collection)}. 
 */
@Test public void testContainsAll(){
  final char[] raw={3,5,8,13,21};
  final CharArray array=new CharArray(raw.clone());
  final ArrayList<Integer> list=new ArrayList<Integer>();
  assertTrue(array.containsAll(list));
  list.add(13);
  assertTrue(array.containsAll(list));
  list.add(1);
  assertFalse(array.containsAll(list));
  final CharArray yes=new CharArray(new char[]{3,8,21});
  assertTrue(array.containsAll(yes));
  final CharArray no=new CharArray(new char[]{5,13,1});
  assertFalse(array.containsAll(no));
}","/** 
 * Tests   {@link CharArray#containsAll(Collection)}. 
 */
@Test public void testContainsAll(){
  final char[] raw={3,5,8,13,21};
  final CharArray array=new CharArray(raw.clone());
  final ArrayList<Character> list=new ArrayList<Character>();
  assertTrue(array.containsAll(list));
  list.add((char)13);
  assertTrue(array.containsAll(list));
  list.add((char)1);
  assertFalse(array.containsAll(list));
  final CharArray yes=new CharArray(new char[]{3,8,21});
  assertTrue(array.containsAll(yes));
  final CharArray no=new CharArray(new char[]{5,13,1});
  assertFalse(array.containsAll(no));
}",0.9695945945945946
11307,"@Override public void initialize(){
  log.info(""String_Node_Str"" + getPlugins() + ""String_Node_Str""+ getPluginType().getSimpleName()+ ""String_Node_Str"");
}","@Override public void initialize(){
  log.info(""String_Node_Str"" + getPlugins().size() + ""String_Node_Str""+ getPluginType().getSimpleName()+ ""String_Node_Str"");
}",0.9779179810725552
11308,"@Override public StackedTimePlot2D getLayout(){
  final CollapsibleTimePlot2D plot=new CollapsibleTimePlot2D();
  plot.setShowLabels(true);
  plot.setLabelSize(30);
  plot.setIndentSubplots(true);
  plot.setIndentSize(30);
  GroupInfo topGroup1=plot.createGroup();
  topGroup1.setLabelText(""String_Node_Str"");
  topGroup1.setShowDivider(false);
  GroupInfo topGroup2=plot.createGroup();
  topGroup2.setLabelText(""String_Node_Str"");
  topGroup2.setShowDivider(false);
  GroupInfo midGroup1=plot.createGroup();
  midGroup1.setLabelText(""String_Node_Str"");
  midGroup1.setShowDivider(false);
  topGroup1.addChildPlot(midGroup1);
  TimePlotInfo plot1=plot.createTimePlot();
  plot1.setLabelText(""String_Node_Str"");
  midGroup1.addChildPlot(plot1);
  TimePlotInfo plot2=plot.createTimePlot();
  plot2.setLabelText(""String_Node_Str"");
  midGroup1.addChildPlot(plot2);
  GroupInfo midGroup2=plot.createGroup();
  midGroup2.setLabelText(""String_Node_Str"");
  midGroup2.setShowDivider(false);
  topGroup1.addChildPlot(midGroup2);
  TimePlotInfo plot3=plot.createTimePlot();
  plot3.setLabelText(""String_Node_Str"");
  midGroup2.addChildPlot(plot3);
  GroupInfo midGroup3=plot.createGroup();
  midGroup3.setLabelText(""String_Node_Str"");
  midGroup3.setShowDivider(false);
  topGroup1.addChildPlot(midGroup3);
  TimePlotInfo plot4=plot.createTimePlot();
  plot4.setLabelText(""String_Node_Str"");
  midGroup3.addChildPlot(plot4);
  TimePlotInfo plot5=plot.createTimePlot();
  plot5.setLabelText(""String_Node_Str"");
  midGroup3.addChildPlot(plot5);
  GroupInfo midGroup4=plot.createGroup();
  midGroup4.setLabelText(""String_Node_Str"");
  midGroup4.setShowDivider(false);
  topGroup2.addChildPlot(midGroup4);
  TimePlotInfo plot6=plot.createTimePlot();
  plot6.setLabelText(""String_Node_Str"");
  midGroup4.addChildPlot(plot6);
  return plot;
}","@Override public StackedTimePlot2D getLayout(){
  final CollapsibleTimePlot2D plot=new CollapsibleTimePlot2D();
  plot.getDefaultTimeline().setAxisColor(GlimpseColor.getBlack());
  plot.setShowLabels(true);
  plot.setLabelSize(30);
  plot.setIndentSubplots(true);
  plot.setIndentSize(30);
  GroupInfo topGroup1=plot.createGroup();
  topGroup1.setLabelText(""String_Node_Str"");
  topGroup1.setShowDivider(false);
  GroupInfo topGroup2=plot.createGroup();
  topGroup2.setLabelText(""String_Node_Str"");
  topGroup2.setShowDivider(false);
  GroupInfo midGroup1=plot.createGroup();
  midGroup1.setLabelText(""String_Node_Str"");
  midGroup1.setShowDivider(false);
  topGroup1.addChildPlot(midGroup1);
  TimePlotInfo plot1=plot.createTimePlot();
  plot1.setLabelText(""String_Node_Str"");
  midGroup1.addChildPlot(plot1);
  TimePlotInfo plot2=plot.createTimePlot();
  plot2.setLabelText(""String_Node_Str"");
  midGroup1.addChildPlot(plot2);
  GroupInfo midGroup2=plot.createGroup();
  midGroup2.setLabelText(""String_Node_Str"");
  midGroup2.setShowDivider(false);
  topGroup1.addChildPlot(midGroup2);
  TimePlotInfo plot3=plot.createTimePlot();
  plot3.setLabelText(""String_Node_Str"");
  midGroup2.addChildPlot(plot3);
  GroupInfo midGroup3=plot.createGroup();
  midGroup3.setLabelText(""String_Node_Str"");
  midGroup3.setShowDivider(false);
  topGroup1.addChildPlot(midGroup3);
  TimePlotInfo plot4=plot.createTimePlot();
  plot4.setLabelText(""String_Node_Str"");
  midGroup3.addChildPlot(plot4);
  TimePlotInfo plot5=plot.createTimePlot();
  plot5.setLabelText(""String_Node_Str"");
  midGroup3.addChildPlot(plot5);
  GroupInfo midGroup4=plot.createGroup();
  midGroup4.setLabelText(""String_Node_Str"");
  midGroup4.setShowDivider(false);
  topGroup2.addChildPlot(midGroup4);
  TimePlotInfo plot6=plot.createTimePlot();
  plot6.setLabelText(""String_Node_Str"");
  midGroup4.addChildPlot(plot6);
  return plot;
}",0.9819940876108572
11309,"protected double printTickLabels(List<String> tickLabels,List<TimeStamp> tickTimes,Axis1D axis,int width,int height){
  Rectangle2D fixedBounds=textRenderer.getBounds(""String_Node_Str"");
  double textHeight=fixedBounds.getHeight();
  int jTimeText=Integer.MAX_VALUE;
  for (int index=0; index < tickLabels.size(); index++) {
    TimeStamp t=tickTimes.get(index);
    String string=tickLabels.get(index);
    Rectangle2D textBounds=textRenderer.getBounds(string);
    double textWidth=textBounds.getWidth();
    int i=(int)Math.round(axis.valueToScreenPixel(fromTimeStamp(t)) - 0.5 * textWidth);
    if (i < 0 || i + textWidth > width)     continue;
    int j=(int)Math.round(height - tickSize - textHeight) - tickBufferSize - textBufferSize;
    jTimeText=Math.min(jTimeText,j);
    textRenderer.draw(string,i,j);
  }
  return jTimeText;
}","protected double printTickLabels(List<String> tickLabels,List<TimeStamp> tickTimes,Axis1D axis,int width,int height){
  GlimpseColor.setColor(textRenderer,textColor);
  Rectangle2D fixedBounds=textRenderer.getBounds(""String_Node_Str"");
  double textHeight=fixedBounds.getHeight();
  int jTimeText=Integer.MAX_VALUE;
  for (int index=0; index < tickLabels.size(); index++) {
    TimeStamp t=tickTimes.get(index);
    String string=tickLabels.get(index);
    Rectangle2D textBounds=textRenderer.getBounds(string);
    double textWidth=textBounds.getWidth();
    int i=(int)Math.round(axis.valueToScreenPixel(fromTimeStamp(t)) - 0.5 * textWidth);
    if (i < 0 || i + textWidth > width)     continue;
    int j=(int)Math.round(height - tickSize - textHeight) - tickBufferSize - textBufferSize;
    jTimeText=Math.min(jTimeText,j);
    textRenderer.draw(string,i,j);
  }
  return jTimeText;
}",0.971627099015634
11310,"protected void printHoverLabels(List<TimeStamp> tickTimes,Axis1D axis,double jTimeText,int width,int height){
  Rectangle2D fixedBounds=textRenderer.getBounds(""String_Node_Str"");
  double textHeight=fixedBounds.getHeight();
  List<TimeStruct> timeStructs=handler.getTimeStructs(axis,tickTimes);
  for (  TimeStruct time : timeStructs) {
    Rectangle2D textBounds=textRenderer.getBounds(time.text);
    double textWidth=textBounds.getWidth();
    int iMin=axis.valueToScreenPixel(fromTimeStamp(time.start));
    int iMax=(int)Math.floor(axis.valueToScreenPixel(fromTimeStamp(time.end)) - textWidth);
    int iApprox=(int)Math.round(axis.valueToScreenPixel(fromTimeStamp(time.textCenter)) - 0.5 * textWidth);
    int i=Math.max(iMin,Math.min(iMax,iApprox));
    if (i < 0 || i + textWidth > width)     continue;
    int j=(int)Math.floor(jTimeText - textHeight - hoverLabelOffset);
    textRenderer.draw(time.text,i,j);
  }
}","protected void printHoverLabels(List<TimeStamp> tickTimes,Axis1D axis,double jTimeText,int width,int height){
  GlimpseColor.setColor(textRenderer,textColor);
  Rectangle2D fixedBounds=textRenderer.getBounds(""String_Node_Str"");
  double textHeight=fixedBounds.getHeight();
  List<TimeStruct> timeStructs=handler.getTimeStructs(axis,tickTimes);
  for (  TimeStruct time : timeStructs) {
    Rectangle2D textBounds=textRenderer.getBounds(time.text);
    double textWidth=textBounds.getWidth();
    int iMin=axis.valueToScreenPixel(fromTimeStamp(time.start));
    int iMax=(int)Math.floor(axis.valueToScreenPixel(fromTimeStamp(time.end)) - textWidth);
    int iApprox=(int)Math.round(axis.valueToScreenPixel(fromTimeStamp(time.textCenter)) - 0.5 * textWidth);
    int i=Math.max(iMin,Math.min(iMax,iApprox));
    if (i < 0 || i + textWidth > width)     continue;
    int j=(int)Math.floor(jTimeText - textHeight - hoverLabelOffset);
    textRenderer.draw(time.text,i,j);
  }
}",0.974169741697417
11311,"private float printTickLabels(List<String> tickLabels,List<TimeStamp> tickTimes,Axis1D axis,int width,int height){
  float iTimeText=Float.POSITIVE_INFINITY;
  textRenderer.beginRendering(width,height);
  try {
    for (int index=0; index < tickLabels.size(); index++) {
      TimeStamp t=tickTimes.get(index);
      String string=tickLabels.get(index);
      Rectangle2D textBounds=textRenderer.getBounds(string);
      double textHeight=textBounds.getHeight();
      float j=(float)(axis.valueToScreenPixel(fromTimeStamp(t)) - 0.5 * Math.max(1,textHeight - 2));
      if (j < 0 || j + textHeight > height)       continue;
      float i=(float)(width - tickSize - textBounds.getWidth()- 1- textBufferSize- tickBufferSize);
      iTimeText=Math.min(iTimeText,i);
      textRenderer.draw3D(string,i,j,0,1);
    }
  }
  finally {
    textRenderer.endRendering();
  }
  return iTimeText;
}","private float printTickLabels(List<String> tickLabels,List<TimeStamp> tickTimes,Axis1D axis,int width,int height){
  float iTimeText=Float.POSITIVE_INFINITY;
  textRenderer.beginRendering(width,height);
  try {
    GlimpseColor.setColor(textRenderer,textColor);
    for (int index=0; index < tickLabels.size(); index++) {
      TimeStamp t=tickTimes.get(index);
      String string=tickLabels.get(index);
      Rectangle2D textBounds=textRenderer.getBounds(string);
      double textHeight=textBounds.getHeight();
      float j=(float)(axis.valueToScreenPixel(fromTimeStamp(t)) - 0.5 * Math.max(1,textHeight - 2));
      if (j < 0 || j + textHeight > height)       continue;
      float i=(float)(width - tickSize - textBounds.getWidth()- 1- textBufferSize- tickBufferSize);
      iTimeText=Math.min(iTimeText,i);
      textRenderer.draw3D(string,i,j,0,1);
    }
  }
  finally {
    textRenderer.endRendering();
  }
  return iTimeText;
}",0.9720241360394952
11312,"public void useProgram(GL gl,boolean on){
  if (on) {
    gl.getGL3().glBindVertexArray(GLUtils.defaultVertexAttributeArray(gl));
  }
 else {
    gl.getGL3().glBindVertexArray(0);
  }
  if (!load(gl.getGL3(),this.codes))   return;
  this.state.useProgram(gl.getGL3(),on);
  if (on)   this.updateUniformData(gl);
  for (  GLArrayDataClient array : arrays) {
    if (array.sealed()) {
      array.enableBuffer(gl,on);
    }
  }
}","public void useProgram(GL gl,boolean on){
  if (on) {
    gl.getGL3().glBindVertexArray(GLUtils.defaultVertexAttributeArray(gl));
  }
  if (!load(gl.getGL3(),this.codes))   return;
  this.state.useProgram(gl.getGL3(),on);
  if (on)   this.updateUniformData(gl);
  for (  GLArrayDataClient array : arrays) {
    if (array.sealed()) {
      array.enableBuffer(gl,on);
    }
  }
  if (!on) {
    gl.getGL3().glBindVertexArray(0);
  }
}",0.4214202561117579
11313,"public void end(GL2ES2 gl){
  gl.getGL3().glBindVertexArray(0);
  gl.glDisableVertexAttribArray(this.handles.inXy);
  gl.glDisableVertexAttribArray(this.handles.inRgba);
  gl.glDisableVertexAttribArray(this.handles.inSize);
  gl.glUseProgram(0);
  gl.glDisable(GL3.GL_PROGRAM_POINT_SIZE);
  if (gl.isGL2())   gl.glDisable(GLES1.GL_POINT_SPRITE);
}","public void end(GL2ES2 gl){
  gl.glDisableVertexAttribArray(this.handles.inXy);
  gl.glDisableVertexAttribArray(this.handles.inRgba);
  gl.glDisableVertexAttribArray(this.handles.inSize);
  gl.glUseProgram(0);
  gl.glDisable(GL3.GL_PROGRAM_POINT_SIZE);
  if (gl.isGL2())   gl.glDisable(GLES1.GL_POINT_SPRITE);
  gl.getGL3().glBindVertexArray(0);
}",0.8962536023054755
11314,"public void end(GL2ES2 gl){
  gl.getGL3().glBindVertexArray(0);
  gl.glDisableVertexAttribArray(this.handles.inXy);
  gl.glUseProgram(0);
  gl.glDisable(GL3.GL_PROGRAM_POINT_SIZE);
  if (gl.isGL2())   gl.glDisable(GLES1.GL_POINT_SPRITE);
}","public void end(GL2ES2 gl){
  gl.glDisableVertexAttribArray(this.handles.inXy);
  gl.glUseProgram(0);
  gl.glDisable(GL3.GL_PROGRAM_POINT_SIZE);
  if (gl.isGL2())   gl.glDisable(GLES1.GL_POINT_SPRITE);
  gl.getGL3().glBindVertexArray(0);
}",0.8493723849372385
11315,"public void end(GL2ES2 gl){
  gl.getGL3().glBindVertexArray(0);
  gl.glDisableVertexAttribArray(this.handles.inXy);
  gl.glUseProgram(0);
}","public void end(GL2ES2 gl){
  gl.glDisableVertexAttribArray(this.handles.inXy);
  gl.glUseProgram(0);
  gl.getGL3().glBindVertexArray(0);
}",0.7410071942446043
11316,"@Override public ColorAxisPlot2D getLayout(){
  ColorAxisPlot2D plot=newPlot();
  plot.setTitle(""String_Node_Str"");
  plot.setAxisLabelX(""String_Node_Str"");
  plot.setAxisLabelY(""String_Node_Str"");
  plot.setBorderSize(30);
  plot.setAxisSizeX(40);
  plot.setAxisSizeY(60);
  plot.setMinX(0.0f);
  plot.setMaxX(1000.0f);
  plot.setMinY(0.0f);
  plot.setMaxY(1000.0f);
  plot.setMinZ(0.0f);
  plot.setMaxZ(1000.0f);
  plot.lockAspectRatioXY(1.0f);
  plot.setSelectionSize(100.0f);
  plot.setShowMinorTicks(true);
  plot.setMinorTickCount(9);
  heatmapPainter=newHeatMapPainter(plot.getAxisZ());
  plot.addPainter(heatmapPainter);
  plot.setColorScale(heatmapPainter.getColorScale());
  cursorPainter=new CursorTextZPainter();
  plot.addPainterForeground(cursorPainter);
  cursorPainter.setTexture(heatmapPainter.getData());
  return plot;
}","@Override public ColorAxisPlot2D getLayout(){
  ColorAxisPlot2D plot=newPlot();
  plot.setTitle(""String_Node_Str"");
  plot.setAxisLabelX(""String_Node_Str"");
  plot.setAxisLabelY(""String_Node_Str"");
  plot.setBorderSize(30);
  plot.setAxisSizeX(40);
  plot.setAxisSizeY(60);
  plot.lockAspectRatioXY(1.0f);
  plot.setMinX(0.0f);
  plot.setMaxX(1000.0f);
  plot.setMinY(0.0f);
  plot.setMaxY(1000.0f);
  plot.setMinZ(0.0f);
  plot.setMaxZ(1000.0f);
  plot.setSelectionSize(100.0f);
  plot.setShowMinorTicks(true);
  plot.setMinorTickCount(9);
  heatmapPainter=newHeatMapPainter(plot.getAxisZ());
  plot.addPainter(heatmapPainter);
  plot.setColorScale(heatmapPainter.getColorScale());
  cursorPainter=new CursorTextZPainter();
  plot.addPainterForeground(cursorPainter);
  cursorPainter.setTexture(heatmapPainter.getData());
  return plot;
}",0.831942789034565
11317,"public TextureProjected2D getProjectedTexture(){
  Colorbuffer b=drawable.getColorbuffer(GL.GL_FRONT);
  return new ExternalTextureProjected2D(getTextureUnit(),b.getWidth(),b.getHeight(),false);
}","public TextureProjected2D getProjectedTexture(){
  Colorbuffer b=drawable.getColorbuffer(GL.GL_FRONT);
  return new ExternalTextureProjected2D(b.getName(),b.getWidth(),b.getHeight(),false);
}",0.9612403100775194
11318,"public static int defaultVertexAttributeArray(GL gl){
  if (default_vao == 0) {
    default_vao=genVertexAttributeArray(gl);
  }
  return default_vao;
}","public static int defaultVertexAttributeArray(GL gl){
  return gl.getContext().getDefaultVAO();
}",0.5783132530120482
11319,"protected int getTextureHandle(){
  return offscreenCanvas.getTextureUnit();
}","protected int getTextureHandle(){
  return offscreenCanvas.getTextureName();
}",0.9487179487179488
11320,"@Override protected int getTextureHandle(){
  return reprojectCanvas.getTextureUnit();
}","@Override protected int getTextureHandle(){
  return reprojectCanvas.getTextureName();
}",0.9545454545454546
11321,"@Override protected void drawOffscreen(GLContext glContext){
  super.drawOffscreen(glContext);
  if (texture == null) {
    init(glContext);
    int width=offscreenCanvas.getTargetBounds().getWidth();
    int height=offscreenCanvas.getTargetBounds().getHeight();
    int texHandle=offscreenCanvas.getTextureUnit();
    texture=new ExternalTextureProjected2D(texHandle,width,height,false){
      @Override protected void putVertexCoords(      int texIndex,      double texFracX,      double texFracY,      float[] temp){
        super.putVertexCoords(texIndex,(float)texFracX * scaleX,(float)texFracY * scaleY,temp);
      }
      @Override protected void putVertexTexCoords(      int texIndex,      double texFracX,      double texFracY){
        super.putVertexTexCoords(texIndex,(float)texFracX * scaleX,(float)texFracY * scaleY);
      }
      @Override protected void prepare_glState(      GL gl){
        gl.glEnable(GL2.GL_TEXTURE_2D);
        gl.glDisable(GL2.GL_BLEND);
      }
    }
;
    texturePainter.removeAllDrawableTextures();
    texturePainter.addDrawableTexture(texture);
    if (reproject != null) {
      texture.setProjection(reproject);
    }
  }
  if (didAxesChange(axes)) {
    updateProjection(currentWidth,currentHeight);
  }
  OGLStackHandler stack=new OGLStackHandler();
  GL2 gl=glContext.getGL().getGL2();
  stack.pushAttrib(gl,GL2.GL_ALL_ATTRIB_BITS);
  stack.pushClientAttrib(gl,(int)GL2.GL_ALL_CLIENT_ATTRIB_BITS);
  stack.pushTexture(gl);
  gl.glLoadIdentity();
  stack.pushModelview(gl);
  stack.pushProjection(gl);
  GLContext c=offscreenCanvas.getGLContext();
  if (c != null) {
    c.makeCurrent();
    try {
      reprojectCanvas.paint();
    }
 catch (    Exception e) {
      logWarning(logger,""String_Node_Str"",e);
    }
 finally {
      glContext.makeCurrent();
      stack.pop(gl);
    }
  }
}","@Override protected void drawOffscreen(GLContext glContext){
  super.drawOffscreen(glContext);
  if (texture == null) {
    init(glContext);
    int width=offscreenCanvas.getTargetBounds().getWidth();
    int height=offscreenCanvas.getTargetBounds().getHeight();
    int texHandle=offscreenCanvas.getTextureName();
    texture=new ExternalTextureProjected2D(texHandle,width,height,false){
      @Override protected void putVertexCoords(      int texIndex,      double texFracX,      double texFracY,      float[] temp){
        super.putVertexCoords(texIndex,(float)texFracX * scaleX,(float)texFracY * scaleY,temp);
      }
      @Override protected void putVertexTexCoords(      int texIndex,      double texFracX,      double texFracY){
        super.putVertexTexCoords(texIndex,(float)texFracX * scaleX,(float)texFracY * scaleY);
      }
      @Override protected void prepare_glState(      GL gl){
        gl.glEnable(GL2.GL_TEXTURE_2D);
        gl.glDisable(GL2.GL_BLEND);
      }
    }
;
    texturePainter.removeAllDrawableTextures();
    texturePainter.addDrawableTexture(texture);
    if (reproject != null) {
      texture.setProjection(reproject);
    }
  }
  if (didAxesChange(axes)) {
    updateProjection(currentWidth,currentHeight);
  }
  OGLStackHandler stack=new OGLStackHandler();
  GL2 gl=glContext.getGL().getGL2();
  stack.pushAttrib(gl,GL2.GL_ALL_ATTRIB_BITS);
  stack.pushClientAttrib(gl,(int)GL2.GL_ALL_CLIENT_ATTRIB_BITS);
  stack.pushTexture(gl);
  gl.glLoadIdentity();
  stack.pushModelview(gl);
  stack.pushProjection(gl);
  GLContext c=offscreenCanvas.getGLContext();
  if (c != null) {
    c.makeCurrent();
    try {
      reprojectCanvas.paint();
    }
 catch (    Exception e) {
      logWarning(logger,""String_Node_Str"",e);
    }
 finally {
      glContext.makeCurrent();
      stack.pop(gl);
    }
  }
}",0.9978225367446923
11322,"/** 
 * Constructs a   {@link QuadPipelineGL30}.
 * @param gl Current OpenGL context
 * @param shaderProgram Shader program to render quads with
 * @throws NullPointerException if context is null
 * @throws IllegalArgumentException if shader program is less than one
 */
public QuadPipelineGL30(final GL3 gl,final int shaderProgram){
  super(VERTS_PER_PRIM,PRIMS_PER_QUAD);
  Check.notNull(gl,""String_Node_Str"");
  Check.argument(shaderProgram > 0,""String_Node_Str"");
  this.vbo=createVertexBufferObject(gl,BYTES_PER_BUFFER);
  this.vao=createVertexArrayObject(gl,shaderProgram,vbo);
}","/** 
 * Constructs a   {@link QuadPipelineGL30}.
 * @param gl Current OpenGL context
 * @param shaderProgram Shader program to render quads with
 * @throws NullPointerException if context is null
 * @throws IllegalArgumentException if shader program is less than one
 */
public QuadPipelineGL30(final GL3 gl,final int shaderProgram){
  super(VERTS_PER_PRIM,PRIMS_PER_QUAD);
  Check.notNull(gl,""String_Node_Str"");
  Check.argument(shaderProgram > 0,""String_Node_Str"");
  this.shaderProgram=shaderProgram;
  this.vbo=createVertexBufferObject(gl,BYTES_PER_BUFFER);
}",0.9181184668989548
11323,"@Override public void beginRendering(final GL gl){
  super.beginRendering(gl);
  final GL3 gl3=gl.getGL3();
  gl3.glBindBuffer(GL3.GL_ARRAY_BUFFER,vbo);
  gl3.glBindVertexArray(vao);
}","@Override public void beginRendering(final GL gl){
  super.beginRendering(gl);
  final GL3 gl3=gl.getGL3();
  gl3.glBindVertexArray(getVertexArrayObject(gl3,this.shaderProgram,this.vbo));
  gl3.glBindBuffer(GL3.GL_ARRAY_BUFFER,this.vbo);
}",0.7186761229314421
11324,"@Override public void dispose(final GL gl){
  super.dispose(gl);
  final GL3 gl3=gl.getGL3();
  final int[] handles=new int[1];
  handles[0]=vbo;
  gl3.glDeleteBuffers(1,handles,0);
  handles[0]=vao;
  gl3.glDeleteVertexArrays(1,handles,0);
}","@Override public void dispose(final GL gl){
  super.dispose(gl);
  final GL3 gl3=gl.getGL3();
  final int[] handles=new int[1];
  handles[0]=vbo;
  gl3.glDeleteBuffers(1,handles,0);
  if (!this.vaoMap.isEmpty()) {
    try {
      for (      GLContext context : this.vaoMap.keySet()) {
        context.makeCurrent();
        handles[0]=this.vaoMap.get(context);
        gl3.glDeleteVertexArrays(1,handles,0);
      }
    }
  finally {
      gl.getContext().makeCurrent();
    }
  }
}",0.6546961325966851
11325,"@Override public StackedTimePlot2D getLayout(){
  StackedTimePlot2D plot=super.getLayout();
  final RelativeTimeAxisLabelHandler handler=new RelativeTimeAxisLabelHandler(plot.getEpoch().getTimeStamp().add(-Time.fromHours(100)));
  handler.setFuturePositive(false);
  plot.setTimeAxisLabelHandler(handler);
  new Thread(){
    @Override public void run(){
      while (true) {
        handler.setReferenceTime(handler.getReferenceTime().add(Time.fromSeconds(10)));
        try {
          Thread.sleep(10);
        }
 catch (        InterruptedException e) {
          e.printStackTrace();
        }
      }
    }
  }
.start();
  plot.setPlotSpacing(20);
  plot.getDefaultTimeline().setSize(65);
  for (  TimePlotInfo info : plot.getAllTimePlots()) {
    info.getLabelPainter().setHorizontalLabels(true);
  }
  return plot;
}","@Override public StackedTimePlot2D getLayout(){
  StackedTimePlot2D plot=super.getLayout();
  final RelativeTimeAxisLabelHandler handler=new RelativeTimeAxisLabelHandler(plot.getEpoch().getTimeStamp().add(-Time.fromHours(100)));
  handler.setFuturePositive(false);
  plot.setTimeAxisLabelHandler(handler);
  new Thread(){
    @Override public void run(){
      while (true) {
        handler.setReferenceTime(handler.getReferenceTime().add(Time.fromSeconds(10)));
        try {
          Thread.sleep(10);
        }
 catch (        InterruptedException e) {
          e.printStackTrace();
        }
      }
    }
  }
.start();
  plot.setPlotSpacing(20);
  plot.getDefaultTimeline().setSize(75);
  for (  TimePlotInfo info : plot.getAllTimePlots()) {
    info.getLabelPainter().setHorizontalLabels(true);
  }
  return plot;
}",0.9987864077669902
11326,"public NumericAxisPainter(AxisLabelHandler ticks){
  resetFont();
  resetLabelColors();
  resetTickColor();
  initShaders();
}","public NumericAxisPainter(AxisLabelHandler ticks){
  this.ticks=ticks;
  resetFont();
  resetLabelColors();
  resetTickColor();
  initShaders();
}",0.9264705882352942
11327,"public void setAxisLabel(String label){
  this.ticks.setAxisLabel(label);
}","@Override public void setAxisLabel(String label){
  this.ticks.setAxisLabel(label);
}",0.9375
11328,"public AxisLabelHandler getTickCalculator(){
  return ticks;
}","@Override public AxisLabelHandler getTickCalculator(){
  return ticks;
}",0.9253731343283582
11329,"public void setTickCalculator(AxisLabelHandler ticks){
  this.ticks=ticks;
}","@Override public void setTickCalculator(AxisLabelHandler ticks){
  this.ticks=ticks;
}",0.9382716049382716
11330,"public NumericLabelHandlerAxisPainter(AxisLabelHandler ticks){
  this.ticks=ticks;
}","public NumericLabelHandlerAxisPainter(AxisLabelHandler ticks){
  super(ticks);
  this.ticks=ticks;
}",0.9130434782608696
11331,"public TimeAxisPainter(TimeAxisLabelHandler handler){
  this.handler=handler;
  this.newFont=FontUtils.getBitstreamVeraSansPlain(12.0f);
  this.tickColor=GlimpseColor.getBlack();
  this.textColor=GlimpseColor.getBlack();
  this.setCurrentTimeTextColor(GlimpseColor.getGreen(0.5f));
  this.setCurrentTimeTickColor(GlimpseColor.getGreen(1.0f));
  this.currentTimeLineThickness=3;
}","public TimeAxisPainter(TimeAxisLabelHandler handler){
  super(handler);
  this.handler=handler;
  this.newFont=FontUtils.getBitstreamVeraSansPlain(12.0f);
  this.tickColor=GlimpseColor.getBlack();
  this.textColor=GlimpseColor.getBlack();
  this.setCurrentTimeTextColor(GlimpseColor.getGreen(0.5f));
  this.setCurrentTimeTickColor(GlimpseColor.getGreen(1.0f));
  this.currentTimeLineThickness=3;
}",0.9768041237113402
11332,"protected double printTickLabels(List<String> tickLabels,List<TimeStamp> tickTimes,Axis1D axis,int width,int height){
  Rectangle2D fixedBounds=textRenderer.getBounds(""String_Node_Str"");
  double textHeight=fixedBounds.getHeight();
  int jTimeText=Integer.MAX_VALUE;
  for (int index=0; index < tickLabels.size(); index++) {
    TimeStamp t=tickTimes.get(index);
    String string=tickLabels.get(index);
    Rectangle2D textBounds=textRenderer.getBounds(string);
    double textWidth=textBounds.getWidth();
    int i=(int)Math.round(axis.valueToScreenPixel(fromTimeStamp(t)) - 0.5 * textWidth);
    if (i < 0 || i + textWidth > width)     continue;
    int j=(int)Math.round(height - tickSize - textHeight);
    jTimeText=Math.min(jTimeText,j);
    textRenderer.draw(string,i,j);
  }
  return jTimeText;
}","protected double printTickLabels(List<String> tickLabels,List<TimeStamp> tickTimes,Axis1D axis,int width,int height){
  Rectangle2D fixedBounds=textRenderer.getBounds(""String_Node_Str"");
  double textHeight=fixedBounds.getHeight();
  int jTimeText=Integer.MAX_VALUE;
  for (int index=0; index < tickLabels.size(); index++) {
    TimeStamp t=tickTimes.get(index);
    String string=tickLabels.get(index);
    Rectangle2D textBounds=textRenderer.getBounds(string);
    double textWidth=textBounds.getWidth();
    int i=(int)Math.round(axis.valueToScreenPixel(fromTimeStamp(t)) - 0.5 * textWidth);
    if (i < 0 || i + textWidth > width)     continue;
    int j=(int)Math.round(height - tickSize - textHeight) - tickBufferSize - textBufferSize;
    jTimeText=Math.min(jTimeText,j);
    textRenderer.draw(string,i,j);
  }
  return jTimeText;
}",0.9793187347931872
11333,"@Override public void doPaintTo(GlimpseContext context){
  super.doPaintTo(context);
  if (textRenderer == null)   return;
  GL3 gl3=context.getGL().getGL3();
  Axis1D axis=getAxis1D(context);
  GlimpseBounds bounds=getBounds(context);
  int width=bounds.getWidth();
  int height=bounds.getHeight();
  if (width == 0 || height == 0)   return;
  List<TimeStamp> tickTimes=handler.tickTimes(axis,width);
  double tickInterval=handler.tickInterval(tickTimes);
  progLine.begin(gl3);
  try {
    pathLine.clear();
    for (    TimeStamp t : tickTimes) {
      float x=(float)fromTimeStamp(t);
      pathLine.moveTo(x,height);
      pathLine.lineTo(x,height - tickSize);
    }
    style.thickness_PX=tickLineWidth;
    style.rgba=tickColor;
    progLine.setViewport(gl3,bounds);
    progLine.setOrtho(gl3,(float)axis.getMin(),(float)axis.getMax(),-0.5f,height - 0.5f);
    progLine.draw(gl3,style,pathLine);
    if (showCurrentTimeLabel)     drawCurrentTimeTick(gl3,axis,width,height);
  }
  finally {
    progLine.end(gl3);
  }
  textRenderer.beginRendering(width,height);
  try {
    GlimpseColor.setColor(textRenderer,textColor);
    if (tickInterval <= Time.fromMinutes(1)) {
      double jTimeText=printTickLabels(tickTimes,axis,handler.getSecondMinuteFormat(),width,height);
      if (isShowDateLabels())       printHoverLabels(tickTimes,axis,handler.getHourDayMonthFormat(),handler.getHourStructFactory(),jTimeText,width,height);
    }
 else     if (tickInterval <= Time.fromHours(12)) {
      double jTimeText=printTickLabels(tickTimes,axis,handler.getHourMinuteFormat(),width,height);
      if (isShowDateLabels())       printHoverLabels(tickTimes,axis,handler.getDayMonthYearFormat(),handler.getDayStructFactory(),jTimeText,width,height);
    }
 else     if (tickInterval <= Time.fromDays(10)) {
      double jTimeText=printTickLabels(tickTimes,axis,handler.getDayFormat(),width,height);
      if (isShowDateLabels())       printHoverLabels(tickTimes,axis,handler.getMonthYearFormat(),handler.getMonthStructFactory(),jTimeText,width,height);
    }
 else     if (tickInterval <= Time.fromDays(60)) {
      double jTimeText=printTickLabels(tickTimes,axis,handler.getMonthFormat(),width,height);
      if (isShowDateLabels())       printHoverLabels(tickTimes,axis,handler.getYearFormat(),handler.getYearStructFactory(),jTimeText,width,height);
    }
 else {
      printTickLabels(tickTimes,axis,handler.getYearFormat(),width,height);
    }
  }
  finally {
    textRenderer.endRendering();
  }
}","@Override public void doPaintTo(GlimpseContext context){
  super.doPaintTo(context);
  if (textRenderer == null)   return;
  GL3 gl3=context.getGL().getGL3();
  Axis1D axis=getAxis1D(context);
  GlimpseBounds bounds=getBounds(context);
  int width=bounds.getWidth();
  int height=bounds.getHeight();
  if (width == 0 || height == 0)   return;
  List<TimeStamp> tickTimes=handler.getTickPositions(axis,width);
  progLine.begin(gl3);
  try {
    pathLine.clear();
    for (    TimeStamp t : tickTimes) {
      float x=(float)fromTimeStamp(t);
      pathLine.moveTo(x,height);
      pathLine.lineTo(x,height - tickSize);
    }
    style.thickness_PX=tickLineWidth;
    style.rgba=tickColor;
    progLine.setViewport(gl3,bounds);
    progLine.setOrtho(gl3,(float)axis.getMin(),(float)axis.getMax(),-0.5f,height - 0.5f);
    progLine.draw(gl3,style,pathLine);
    if (showCurrentTimeLabel)     drawCurrentTimeTick(gl3,axis,width,height);
  }
  finally {
    progLine.end(gl3);
  }
  List<String> tickLabels=handler.getTickLabels(axis,tickTimes);
  textRenderer.beginRendering(width,height);
  try {
    double jTimeText=printTickLabels(tickLabels,tickTimes,axis,width,height);
    if (isShowDateLabels())     printHoverLabels(tickTimes,axis,jTimeText,width,height);
  }
  finally {
    textRenderer.endRendering();
  }
}",0.5977433744424036
11334,"private double printTickLabels(List<String> tickLabels,List<TimeStamp> tickTimes,Axis1D axis,int width,int height){
  int iTimeText=Integer.MAX_VALUE;
  textRenderer.beginRendering(width,height);
  try {
    GlimpseColor.setColor(textRenderer,textColor);
    for (    TimeStamp t : tickTimes) {
      TimeStamp t=tickTimes.get(index);
      String string=tickLabels.get(index);
      Rectangle2D textBounds=textRenderer.getBounds(string);
      double textHeight=textBounds.getHeight();
      int j=(int)Math.round(axis.valueToScreenPixel(fromTimeStamp(t)) - 0.5 * Math.max(1,textHeight - 2));
      if (j < 0 || j + textHeight > height)       continue;
      int i=(int)Math.round(width - tickSize - textBounds.getWidth()) - 1;
      iTimeText=Math.min(iTimeText,i);
      textRenderer.draw(string,i,j);
    }
  }
  finally {
    textRenderer.endRendering();
  }
  return iTimeText;
}","private float printTickLabels(List<String> tickLabels,List<TimeStamp> tickTimes,Axis1D axis,int width,int height){
  float iTimeText=Float.POSITIVE_INFINITY;
  textRenderer.beginRendering(width,height);
  try {
    for (int index=0; index < tickLabels.size(); index++) {
      TimeStamp t=tickTimes.get(index);
      String string=tickLabels.get(index);
      Rectangle2D textBounds=textRenderer.getBounds(string);
      double textHeight=textBounds.getHeight();
      float j=(float)(axis.valueToScreenPixel(fromTimeStamp(t)) - 0.5 * Math.max(1,textHeight - 2));
      if (j < 0 || j + textHeight > height)       continue;
      float i=(float)(width - tickSize - textBounds.getWidth()- 1- textBufferSize- tickBufferSize);
      iTimeText=Math.min(iTimeText,i);
      textRenderer.draw3D(string,i,j,0,1);
    }
  }
  finally {
    textRenderer.endRendering();
  }
  return iTimeText;
}",0.7701863354037267
11335,"@Override public void doPaintTo(GlimpseContext context){
  super.doPaintTo(context);
  if (textRenderer == null)   return;
  GL3 gl3=context.getGL().getGL3();
  Axis1D axis=getAxis1D(context);
  GlimpseBounds bounds=getBounds(context);
  int width=bounds.getWidth();
  int height=bounds.getHeight();
  if (width == 0 || height == 0)   return;
  List<TimeStamp> tickTimes=handler.tickTimes(axis,height);
  double tickInterval=handler.tickInterval(tickTimes);
  progLine.begin(gl3);
  try {
    pathLine.clear();
    for (    TimeStamp t : tickTimes) {
      float y=(float)fromTimeStamp(t);
      pathLine.moveTo(width,y);
      pathLine.lineTo(width - tickSize,y);
    }
    style.thickness_PX=tickLineWidth;
    style.rgba=tickColor;
    progLine.setViewport(gl3,bounds);
    progLine.setOrtho(gl3,-0.5f,width - 0.5f,(float)axis.getMin(),(float)axis.getMax());
    progLine.draw(gl3,style,pathLine);
  }
  finally {
    progLine.end(gl3);
  }
  if (tickInterval <= Time.fromMinutes(1)) {
    double jTimeText=printTickLabels(tickTimes,axis,handler.getSecondMinuteFormat(),width,height);
    printHoverLabels(gl3,tickTimes,axis,handler.getHourDayMonthFormat(),handler.getHourStructFactory(),jTimeText,width,height);
  }
 else   if (tickInterval <= Time.fromHours(12)) {
    double jTimeText=printTickLabels(tickTimes,axis,handler.getHourMinuteFormat(),width,height);
    printHoverLabels(gl3,tickTimes,axis,handler.getDayMonthYearFormat(),handler.getDayStructFactory(),jTimeText,width,height);
  }
 else   if (tickInterval <= Time.fromDays(10)) {
    double jTimeText=printTickLabels(tickTimes,axis,handler.getDayFormat(),width,height);
    printHoverLabels(gl3,tickTimes,axis,handler.getMonthYearFormat(),handler.getMonthStructFactory(),jTimeText,width,height);
  }
 else   if (tickInterval <= Time.fromDays(60)) {
    double jTimeText=printTickLabels(tickTimes,axis,handler.getMonthFormat(),width,height);
    printHoverLabels(gl3,tickTimes,axis,handler.getYearFormat(),handler.getYearStructFactory(),jTimeText,width,height);
  }
 else {
    printTickLabels(tickTimes,axis,handler.getYearFormat(),width,height);
  }
}","@Override public void doPaintTo(GlimpseContext context){
  super.doPaintTo(context);
  if (textRenderer == null)   return;
  GL3 gl3=context.getGL().getGL3();
  Axis1D axis=getAxis1D(context);
  GlimpseBounds bounds=getBounds(context);
  int width=bounds.getWidth();
  int height=bounds.getHeight();
  if (width == 0 || height == 0)   return;
  List<TimeStamp> tickTimes=handler.getTickPositions(axis,height);
  progLine.begin(gl3);
  try {
    pathLine.clear();
    for (    TimeStamp t : tickTimes) {
      float y=(float)fromTimeStamp(t);
      pathLine.moveTo(width,y);
      pathLine.lineTo(width - tickSize,y);
    }
    style.thickness_PX=tickLineWidth;
    style.rgba=tickColor;
    progLine.setViewport(gl3,bounds);
    progLine.setOrtho(gl3,-0.5f,width - 0.5f,(float)axis.getMin(),(float)axis.getMax());
    progLine.draw(gl3,style,pathLine);
  }
  finally {
    progLine.end(gl3);
  }
  List<String> tickLabels=handler.getTickLabels(axis,tickTimes);
  double iTimeText=printTickLabels(tickLabels,tickTimes,axis,width,height);
  if (isShowDateLabels())   printHoverLabels(gl3,tickTimes,axis,iTimeText,width,height);
}",0.5495995070856439
11336,"private void printHoverLabels(GL3 gl,List<TimeStamp> tickTimes,Axis1D axis,TimeStampFormat format,TimeStructFactory factory,double iTimeText,int width,int height){
  textRenderer.begin3DRendering();
  try {
    GlimpseColor.setColor(textRenderer,textColor);
    List<TimeStruct> days=handler.timeStructs(axis,tickTimes,factory);
    for (    TimeStruct day : days) {
      String text=day.textCenter.toString(format);
      Rectangle2D textBounds=textRenderer.getBounds(text);
      double halfTextHeight=0.5 * textBounds.getWidth();
      int jMin=(int)Math.ceil(axis.valueToScreenPixel(fromTimeStamp(day.start)) + halfTextHeight);
      int jMax=(int)Math.floor(axis.valueToScreenPixel(fromTimeStamp(day.end)) - halfTextHeight);
      int jApprox=axis.valueToScreenPixel(fromTimeStamp(day.textCenter));
      int j=Math.max(jMin,Math.min(jMax,jApprox));
      if (j - halfTextHeight < 0 || j + halfTextHeight > height)       continue;
      int i=(int)Math.floor(iTimeText - dateTextRightPadding - 1);
      transformMatrix.loadIdentity();
      transformMatrix.makeOrtho(0,width,0,height,-1,1);
      transformMatrix.translate(i,j,0);
      transformMatrix.rotate(PI_2,0,0,1.0f);
      textRenderer.setTransform(transformMatrix.getMatrix());
      textRenderer.draw3D(text,(int)Math.round(-halfTextHeight),0,0,1);
    }
  }
  finally {
    textRenderer.end3DRendering();
  }
}","private void printHoverLabels(GL3 gl,List<TimeStamp> tickTimes,Axis1D axis,double iTimeText,int width,int height){
  textRenderer.begin3DRendering();
  try {
    GlimpseColor.setColor(textRenderer,textColor);
    List<TimeStruct> timeStructs=handler.getTimeStructs(axis,tickTimes);
    for (    TimeStruct timeStruct : timeStructs) {
      String text=timeStruct.text;
      Rectangle2D textBounds=textRenderer.getBounds(text);
      double halfTextHeight=0.5 * textBounds.getWidth();
      float jMin=(float)(axis.valueToScreenPixel(fromTimeStamp(timeStruct.start)) + halfTextHeight);
      float jMax=(float)(axis.valueToScreenPixel(fromTimeStamp(timeStruct.end)) - halfTextHeight);
      float jApprox=axis.valueToScreenPixel(fromTimeStamp(timeStruct.textCenter));
      float j=Math.max(jMin,Math.min(jMax,jApprox));
      if (j - halfTextHeight < 0 || j + halfTextHeight > height)       continue;
      float i=(float)(iTimeText - dateTextRightPadding - 1);
      transformMatrix.loadIdentity();
      transformMatrix.makeOrtho(0,width,0,height,-1,1);
      transformMatrix.translate(i,j,0);
      transformMatrix.rotate(PI_2,0,0,1.0f);
      textRenderer.setTransform(transformMatrix.getMatrix());
      textRenderer.draw3D(text,(int)Math.round(-halfTextHeight),0,0,1);
    }
  }
  finally {
    textRenderer.end3DRendering();
  }
}",0.8789105631210894
11337,"@Override public void end(GlimpseContext context){
  GL2ES2 gl=context.getGL().getGL2ES2();
  gl.getGL3().glBindVertexArray(0);
  gl.glDisableVertexAttribArray(this.handles.inXy);
  gl.glDisableVertexAttribArray(this.handles.inS);
  gl.glUseProgram(0);
}","@Override public void end(GlimpseContext context){
  GL2ES2 gl=context.getGL().getGL2ES2();
  gl.glDisableVertexAttribArray(this.handles.inXy);
  gl.glDisableVertexAttribArray(this.handles.inS);
  gl.glUseProgram(0);
  gl.getGL3().glBindVertexArray(0);
}",0.5078740157480315
11338,"@Override public void end(GlimpseContext context){
  GL3 gl=context.getGL().getGL3();
  gl.getGL3().glBindVertexArray(0);
  if (this.handles != null) {
    gl.glDisableVertexAttribArray(this.handles.inXy);
    gl.glDisableVertexAttribArray(this.handles.inS);
  }
  gl.glUseProgram(0);
}","@Override public void end(GlimpseContext context){
  GL3 gl=context.getGL().getGL3();
  if (this.handles != null) {
    gl.glDisableVertexAttribArray(this.handles.inXy);
    gl.glDisableVertexAttribArray(this.handles.inS);
  }
  gl.glUseProgram(0);
  gl.getGL3().glBindVertexArray(0);
}",0.8741258741258742
11339,"public void end(GL2ES2 gl){
  gl.getGL3().glBindVertexArray(0);
  gl.glDisableVertexAttribArray(this.handles.inXy);
  gl.glUseProgram(0);
}","public void end(GL2ES2 gl){
  gl.glDisableVertexAttribArray(this.handles.inXy);
  gl.glUseProgram(0);
  gl.getGL3().glBindVertexArray(0);
}",0.7410071942446043
11340,"public void end(GL2ES2 gl){
  gl.getGL3().glBindVertexArray(0);
  gl.glDisableVertexAttribArray(this.handles.inXy);
  gl.glUseProgram(0);
}","public void end(GL2ES2 gl){
  gl.glDisableVertexAttribArray(this.handles.inXy);
  gl.glUseProgram(0);
  gl.getGL3().glBindVertexArray(0);
}",0.7410071942446043
11341,"public void coalesce(int tolerance){
  if (tolerance > 0) {
    for (int i=0; i < this.ranges.n - 2; i+=2) {
      int prevEnd=this.ranges.v(i + 1);
      int nextStart=this.ranges.v(i + 2);
      if (prevEnd + tolerance >= nextStart) {
        this.ranges.removeRange(i + 1,i + 3);
      }
    }
  }
}","public void coalesce(int tolerance){
  if (tolerance > 0 && this.ranges.n >= 4) {
    SortedIntsArray coalesced=this.scratch;
    int firstStart=this.ranges.v(0);
    int firstEnd=this.ranges.v(1);
    coalesced.append(firstStart);
    int pendingEnd=firstEnd;
    for (int i=2; i < this.ranges.n; i+=2) {
      int start=this.ranges.v(i + 0);
      int end=this.ranges.v(i + 1);
      if (pendingEnd + tolerance < start) {
        coalesced.append(pendingEnd);
        coalesced.append(start);
      }
      pendingEnd=end;
    }
    coalesced.append(pendingEnd);
    this.scratch=this.ranges;
    this.scratch.clear();
    this.ranges=coalesced;
  }
}",0.2429319371727748
11342,"public IntRangeSetModifiable(){
  this.ranges=new SortedIntsArray();
}","public IntRangeSetModifiable(){
  this.ranges=new SortedIntsArray();
  this.scratch=new SortedIntsArray();
}",0.7865168539325843
11343,"public static void updateMileageBuffer(FloatBuffer xyBuffer,ByteBuffer flagsBuffer,FloatBuffer mileageBuffer,boolean useInitialMileages,double ppvAspectRatio){
  int firstVertex=mileageBuffer.position();
  xyBuffer.position(2 * firstVertex);
  flagsBuffer.position(1 * firstVertex);
  float x;
  float y;
  float mileage;
  if (firstVertex > 0) {
    int i=firstVertex - 1;
    x=xyBuffer.get(2 * i + 0);
    y=xyBuffer.get(2 * i + 1);
    mileage=mileageBuffer.get(1 * i);
  }
 else {
    x=0;
    y=0;
    mileage=0;
  }
  while (flagsBuffer.hasRemaining()) {
    float xNew=xyBuffer.get();
    float yNew=xyBuffer.get();
    byte flagsNew=flagsBuffer.get();
    boolean connect=((flagsNew & FLAGS_CONNECT) != 0);
    if (!connect) {
      if (useInitialMileages) {
        mileage=mileageBuffer.get();
      }
 else {
        mileage=0;
      }
    }
 else {
      mileage+=distance(x,y,xNew,yNew,ppvAspectRatio);
      mileageBuffer.put(mileage);
    }
    x=xNew;
    y=yNew;
  }
}","public static void updateMileageBuffer(FloatBuffer xyBuffer,ByteBuffer flagsBuffer,FloatBuffer mileageBuffer,boolean useInitialMileages,double ppvAspectRatio){
  int firstVertex=mileageBuffer.position();
  xyBuffer.position(2 * firstVertex);
  flagsBuffer.position(1 * firstVertex);
  float x;
  float y;
  float mileage;
  if (firstVertex > 0) {
    int i=firstVertex - 1;
    x=xyBuffer.get(2 * i + 0);
    y=xyBuffer.get(2 * i + 1);
    mileage=mileageBuffer.get(1 * i);
  }
 else {
    x=0;
    y=0;
    mileage=0;
  }
  while (flagsBuffer.hasRemaining()) {
    float xNew=xyBuffer.get();
    float yNew=xyBuffer.get();
    byte flagsNew=flagsBuffer.get();
    boolean connect=((flagsNew & FLAGS_CONNECT) != 0);
    if (connect) {
      mileage+=distance(x,y,xNew,yNew,ppvAspectRatio);
      mileageBuffer.put(mileage);
    }
 else     if (useInitialMileages) {
      mileage=mileageBuffer.get();
    }
 else {
      mileage=0;
      mileageBuffer.put(mileage);
    }
    x=xNew;
    y=yNew;
  }
}",0.8646200301962758
11344,"public void begin(GlimpseContext context){
  GL3 gl=context.getGL().getGL3();
  this.useProgram(context.getGL(),true);
  if (this.handles == null) {
    this.handles=new ProgramHandles(gl,getShaderProgram().id());
  }
  gl.glEnableVertexAttribArray(this.handles.inXy);
  gl.glEnableVertexAttribArray(this.handles.inS);
}","public void begin(GlimpseContext context){
  GL3 gl=context.getGL().getGL3();
  this.useProgram(context.getGL(),true);
  if (this.handles == null) {
    this.handles=new ProgramHandles(gl,getShaderProgram().program());
  }
  gl.glEnableVertexAttribArray(this.handles.inXy);
  gl.glEnableVertexAttribArray(this.handles.inS);
}",0.986046511627907
11345,"public void add(int first,int count){
  int start=first;
  int iBeforeStart=this.ranges.indexAtOrBefore(start);
  boolean startsInExistingRange=(iBeforeStart % 2 == 0);
  if (!startsInExistingRange && iBeforeStart >= 0 && start == this.ranges.v(iBeforeStart)) {
    start--;
    iBeforeStart--;
    startsInExistingRange=true;
  }
  int end=first + count;
  int iAfterEnd=this.ranges.indexAtOrAfter(end);
  boolean endsInExistingRange=(iAfterEnd % 2 == 1);
  if (!endsInExistingRange && iAfterEnd < this.ranges.n && end == this.ranges.v(iAfterEnd)) {
    end++;
    iAfterEnd++;
    endsInExistingRange=true;
  }
  if (startsInExistingRange && endsInExistingRange) {
    this.ranges.removeRange(iBeforeStart + 1,iAfterEnd);
  }
 else   if (startsInExistingRange) {
    this.ranges.a[iBeforeStart + 1]=end;
    this.ranges.removeRange(iBeforeStart + 2,iAfterEnd);
  }
 else   if (endsInExistingRange) {
    this.ranges.a[iAfterEnd - 1]=start;
    this.ranges.removeRange(iBeforeStart + 1,iAfterEnd - 1);
  }
 else {
    this.ranges.removeRange(iBeforeStart + 1,iAfterEnd);
    this.ranges.prepForInsert(iBeforeStart,2);
    this.ranges.a[iBeforeStart + 0]=start;
    this.ranges.a[iBeforeStart + 1]=end;
  }
}","public void add(int first,int count){
  if (count > 0) {
    int start=first;
    int iBeforeStart=this.ranges.indexAtOrBefore(start);
    boolean startsInExistingRange=(iBeforeStart % 2 == 0);
    if (!startsInExistingRange && iBeforeStart >= 0 && start == this.ranges.v(iBeforeStart)) {
      start--;
      iBeforeStart--;
      startsInExistingRange=true;
    }
    int end=first + count;
    int iAfterEnd=this.ranges.indexAtOrAfter(end);
    boolean endsInExistingRange=(iAfterEnd % 2 == 1);
    if (!endsInExistingRange && iAfterEnd < this.ranges.n && end == this.ranges.v(iAfterEnd)) {
      end++;
      iAfterEnd++;
      endsInExistingRange=true;
    }
    if (startsInExistingRange && endsInExistingRange) {
      this.ranges.removeRange(iBeforeStart + 1,iAfterEnd);
    }
 else     if (startsInExistingRange) {
      this.ranges.a[iBeforeStart + 1]=end;
      this.ranges.removeRange(iBeforeStart + 2,iAfterEnd);
    }
 else     if (endsInExistingRange) {
      this.ranges.a[iAfterEnd - 1]=start;
      this.ranges.removeRange(iBeforeStart + 1,iAfterEnd - 1);
    }
 else {
      this.ranges.removeRange(iBeforeStart + 1,iAfterEnd);
      this.ranges.prepForInsert(iBeforeStart + 1,2);
      this.ranges.a[iBeforeStart + 1]=start;
      this.ranges.a[iBeforeStart + 2]=end;
    }
  }
}",0.9142401276426008
11346,"public void coalesce(int tolerance){
  for (int i=0; i < this.ranges.n - 2; i+=2) {
    int prevEnd=this.ranges.v(i + 1);
    int nextStart=this.ranges.v(i + 2);
    if (prevEnd + tolerance >= nextStart) {
      this.ranges.removeRange(i + 1,i + 3);
    }
  }
}","public void coalesce(int tolerance){
  if (tolerance > 0) {
    for (int i=0; i < this.ranges.n - 2; i+=2) {
      int prevEnd=this.ranges.v(i + 1);
      int nextStart=this.ranges.v(i + 2);
      if (prevEnd + tolerance >= nextStart) {
        this.ranges.removeRange(i + 1,i + 3);
      }
    }
  }
}",0.8916518650088809
11347,"public void begin(GlimpseContext context){
  GL3 gl=context.getGL().getGL3();
  this.useProgram(context.getGL(),true);
  if (this.handles == null) {
    this.handles=new ProgramHandles(gl,getShaderProgram().id());
  }
  gl.glEnableVertexAttribArray(this.handles.inXy);
  gl.glEnableVertexAttribArray(this.handles.inS);
}","public void begin(GlimpseContext context){
  GL3 gl=context.getGL().getGL3();
  this.useProgram(context.getGL(),true);
  if (this.handles == null) {
    this.handles=new ProgramHandles(gl,getShaderProgram().program());
  }
  gl.glEnableVertexAttribArray(this.handles.inXy);
  gl.glEnableVertexAttribArray(this.handles.inS);
}",0.986046511627907
11348,"public ProgramHandles(GL2ES2 gl,int program){
  this.inXy=gl.glGetAttribLocation(program,""String_Node_Str"");
  this.inS=gl.glGetAttribLocation(program,""String_Node_Str"");
}","public ProgramHandles(GL2ES2 gl,int program){
  this.inXy=gl.glGetAttribLocation(program,""String_Node_Str"");
  this.inS=gl.glGetAttribLocation(program,""String_Node_Str"");
  GLErrorUtils.logGLError(logger,gl,""String_Node_Str"");
}",0.86
11349,"public void put(int firstVertex,FloatBuffer xys){
  if (xys.remaining() >= 2) {
    int putFirst=firstVertex + 1;
    int putCount=xys.remaining() / 2;
    boolean putLeader=(firstVertex == 0);
    if (putLeader) {
      putFirst--;
      putCount++;
    }
    int oldCount=this.flagsBuffer.numBytes();
    boolean putTrailer=(putFirst + putCount >= oldCount - 1);
    if (putTrailer) {
      putCount++;
    }
    FloatBuffer xyEdit=this.xyBuffer.editFloats(2 * putFirst,2 * putCount);
{
      if (putLeader) {
        float xLeader=xys.get(0);
        float yLeader=xys.get(1);
        xyEdit.put(xLeader).put(yLeader);
      }
      xyEdit.put(xys);
      if (putTrailer) {
        int iLast=xys.limit() - 2;
        float xTrailer=xys.get(iLast + 0);
        float yTrailer=xys.get(iLast + 1);
        xyEdit.put(xTrailer).put(yTrailer);
      }
    }
    ByteBuffer flagsEdit=this.flagsBuffer.editBytes(1 * putFirst,1 * putCount);
    int newCount=this.flagsBuffer.numBytes();
    for (int i=putFirst; i < putFirst + putCount; i++) {
      if (i == 0) {
        flagsEdit.put((byte)0);
      }
 else       if (i == 1) {
        flagsEdit.put((byte)0);
      }
 else       if (i == newCount - 2) {
        flagsEdit.put((byte)FLAGS_CONNECT);
      }
 else       if (i == newCount - 1) {
        flagsEdit.put((byte)0);
      }
 else {
        flagsEdit.put((byte)(FLAGS_CONNECT | FLAGS_JOIN));
      }
    }
    FloatBuffer mileageEdit=this.mileageBuffer.editFloats(1 * putFirst,1 * newCount);
{
      updateMileageBuffer(this.xyBuffer.hostFloats(),this.flagsBuffer.hostBytes(),mileageEdit,false,1.0);
    }
  }
}","public void put(int firstVertex,FloatBuffer xys){
  if (xys.remaining() >= 2) {
    int putFirst=firstVertex + 1;
    int putCount=xys.remaining() / 2;
    boolean putLeader=(firstVertex == 0);
    if (putLeader) {
      putFirst--;
      putCount++;
    }
    int oldCount=this.flagsBuffer.numBytes();
    boolean putTrailer=(putFirst + putCount >= oldCount - 1);
    if (putTrailer) {
      putCount++;
    }
{
      int xyFirst=2 * putFirst;
      int xyCount=2 * putCount;
      FloatBuffer xyEdit=this.xyBuffer.editFloats(xyFirst,xyCount);
      if (putLeader) {
        float xLeader=xys.get(0);
        float yLeader=xys.get(1);
        xyEdit.put(xLeader).put(yLeader);
      }
      xyEdit.put(xys);
      if (putTrailer) {
        int iLast=xys.limit() - 2;
        float xTrailer=xys.get(iLast + 0);
        float yTrailer=xys.get(iLast + 1);
        xyEdit.put(xTrailer).put(yTrailer);
      }
    }
{
      int flagsFirst=(putTrailer ? max(0,min(putFirst,oldCount - 2)) : putFirst);
      int flagsCount=putFirst + putCount - flagsFirst;
      ByteBuffer flagsEdit=this.flagsBuffer.editBytes(flagsFirst,flagsCount);
      int newCount=this.flagsBuffer.numBytes();
      for (int i=flagsFirst; i < flagsFirst + flagsCount; i++) {
        if (i == 0) {
          flagsEdit.put((byte)0);
        }
 else         if (i == 1) {
          flagsEdit.put((byte)0);
        }
 else         if (i == newCount - 2) {
          flagsEdit.put((byte)FLAGS_CONNECT);
        }
 else         if (i == newCount - 1) {
          flagsEdit.put((byte)0);
        }
 else {
          flagsEdit.put((byte)(FLAGS_CONNECT | FLAGS_JOIN));
        }
      }
    }
{
      int mileageFirst=max(0,putFirst - 1);
      int mileageCount=this.flagsBuffer.numBytes() - mileageFirst;
      FloatBuffer mileageEdit=this.mileageBuffer.editFloats(mileageFirst,mileageCount);
      mileageEdit.position(putFirst - mileageFirst);
      FloatBuffer xySlice=sliced(this.xyBuffer.hostFloats(),2 * mileageFirst,2 * mileageCount);
      ByteBuffer flagsSlice=sliced(this.flagsBuffer.hostBytes(),1 * mileageFirst,1 * mileageCount);
      updateMileageBuffer(xySlice,flagsSlice,mileageEdit,false,1.0);
    }
  }
}",0.4934175882043181
11350,"@Override protected synchronized void doPaintTo(GlimpseContext context){
  GlimpseBounds bounds=getBounds(context);
  Axis2D axis=getAxis2D(context);
  GL3 gl=context.getGL().getGL3();
  int width=bounds.getWidth();
  int height=bounds.getHeight();
  if (axis == null && !drawInPixelCoords) {
    throw new AxisNotSetException(this,context);
  }
  double x=drawInPixelCoords ? this.x : axis.getAxisX().valueToScreenPixelUnits(this.x);
  double y=drawInPixelCoords ? bounds.getHeight() - this.y : axis.getAxisY().valueToScreenPixelUnits(this.y);
  if (icons == null) {
    loadIcons(context);
  }
  if (newFont != null) {
    updateTextRenderer();
  }
  if (text != null && textLayout == null && textRenderer != null) {
    updateTextLayout();
  }
  if (iconIds == null && lines == null)   return;
  GLUtils.enableStandardBlending(gl);
  try {
    double textHeight=0;
    if (lines != null) {
      textHeight=(textLayout.getLineHeight()) * lines.size() + lineSpacing * (lines.size() - 1);
    }
    float iconSize;
    if (iconIds == null || iconIds.isEmpty()) {
      iconSize=0;
    }
 else     if (iconSizeFixedToText && textHeight != 0) {
      iconSize=(float)textLayout.getLineHeight();
    }
 else {
      iconSize=this.iconSize;
    }
    double iconHeight=0;
    if (icons != null) {
      iconHeight=iconSize * icons.size() + iconSpacing * (icons.size() - 1);
    }
    int boundingHeight=(int)(borderSize * 2 + Math.max(iconHeight,textHeight));
    float textLength=0;
    if (lines != null) {
      for (int k=0; k < lines.size(); k++) {
        textLength=Math.max(textLength,lines.get(k).width);
      }
    }
    int boundingWidth=(int)(borderSize * 2 + iconSize + textLength);
    if (iconIds != null && !iconIds.isEmpty() && lines != null) {
      boundingWidth+=textIconSpacing;
    }
    int offsetX=this.offsetX + this.insets.left;
    int offsetY=this.offsetY - this.insets.top;
    double clampX=offsetX, clampY=offsetY;
    if (clampToScreenEdges) {
      if (x + boundingWidth + offsetX > bounds.getWidth())       clampX=bounds.getWidth() - boundingWidth - x;
      if (x + offsetX < 0)       clampX=-x;
      if (y + offsetY > bounds.getHeight())       clampY=bounds.getHeight() - y;
      if (boundingHeight > y + offsetY)       clampY=boundingHeight - y;
    }
    if (this.paintBackground || this.paintBorder) {
      float xMin=(float)(x + clampX);
      float yMin=(float)(y + clampY);
      float xMax=xMin + boundingWidth;
      float yMax=yMin - boundingHeight;
      if (paintBackground) {
        this.fillBuilder.clear();
        this.fillBuilder.addQuad2f(xMin,yMin,xMax,yMax);
        this.fillProg.begin(gl);
        try {
          this.fillProg.setPixelOrtho(gl,bounds);
          this.fillProg.draw(gl,this.fillBuilder,this.backgroundColor);
        }
  finally {
          this.fillProg.end(gl);
        }
      }
      if (paintBorder) {
        this.linePath.clear();
        this.linePath.addRectangle(xMin,yMin,xMax,yMax);
        this.lineProg.begin(gl);
        try {
          this.lineProg.setPixelOrtho(gl,bounds);
          this.lineProg.setViewport(gl,bounds);
          this.lineStyle.rgba=borderColor;
          this.lineProg.draw(gl,this.lineStyle,this.linePath);
        }
  finally {
          this.lineProg.end(gl);
        }
      }
    }
    gl.glDisable(GL2.GL_BLEND);
    if (lines != null && textRenderer != null) {
      GlimpseColor.setColor(textRenderer,textColor);
      textRenderer.beginRendering(width,height);
      try {
        double posX=x + iconSize + borderSize;
        if (iconIds != null && !iconIds.isEmpty()) {
          posX+=textIconSpacing;
        }
        double posY=y - borderSize - textLayout.getLineHeight();
        double iconPosY=Float.NEGATIVE_INFINITY;
        if (wrapTextAroundIcon && icons != null) {
          iconPosY=y - (iconSize * icons.size() + iconSpacing * (icons.size() - 1) + borderSize);
        }
        for (int i=0; i < lines.size(); i++) {
          if (posY + textLayout.getLineHeight() < iconPosY)           posX=x + borderSize;
          textRenderer.draw(lines.get(i).text,(int)(posX + clampX),(int)(posY + clampY));
          posY=posY - lineSpacing - (textLayout.getLineHeight());
        }
      }
  finally {
        textRenderer.endRendering();
      }
    }
    if (iconIds != null && !iconIds.isEmpty()) {
      atlas.beginRenderingPixelOrtho(context,bounds);
      try {
        double posY=y - borderSize - iconSize;
        for (int i=0; i < iconIds.size(); i++) {
          Object iconId=iconIds.get(i);
          ImageData iconData=icons.get(i);
          if (iconId != null && iconData != null) {
            double iconScale=iconSize / (double)iconData.getWidth();
            float[] color=defaultIconColor;
            if (iconColors != null && i < iconColors.size()) {
              float[] iconColor=iconColors.get(i);
              if (iconColor != null)               color=iconColor;
            }
            int scaleX=(int)(x + borderSize + clampX);
            int scaleY=(int)(posY + clampY);
            atlas.drawImage(context,iconId,scaleX,scaleY,iconScale,iconScale,0,iconData.getHeight(),color);
            posY=posY - iconSize - iconSpacing;
          }
        }
      }
  finally {
        atlas.endRendering(context);
      }
    }
  }
  finally {
    GLUtils.disableBlending(gl);
  }
}","@Override protected synchronized void doPaintTo(GlimpseContext context){
  GlimpseBounds bounds=getBounds(context);
  Axis2D axis=getAxis2D(context);
  GL3 gl=context.getGL().getGL3();
  int width=bounds.getWidth();
  int height=bounds.getHeight();
  if (axis == null && !drawInPixelCoords) {
    throw new AxisNotSetException(this,context);
  }
  double x=drawInPixelCoords ? this.x : axis.getAxisX().valueToScreenPixelUnits(this.x);
  double y=drawInPixelCoords ? bounds.getHeight() - this.y : axis.getAxisY().valueToScreenPixelUnits(this.y);
  if (icons == null) {
    loadIcons(context);
  }
  if (newFont != null) {
    updateTextRenderer();
  }
  if (text != null && textLayout == null && textRenderer != null) {
    updateTextLayout();
  }
  if (iconIds == null && lines == null)   return;
  GLUtils.enableStandardBlending(gl);
  try {
    double textHeight=0;
    if (lines != null) {
      textHeight=(textLayout.getLineHeight()) * lines.size() + lineSpacing * (lines.size() - 1);
    }
    float iconSize;
    if (iconIds == null || iconIds.isEmpty()) {
      iconSize=0;
    }
 else     if (iconSizeFixedToText && textHeight != 0) {
      iconSize=(float)textLayout.getLineHeight();
    }
 else {
      iconSize=this.iconSize;
    }
    double iconHeight=0;
    if (icons != null) {
      iconHeight=iconSize * icons.size() + iconSpacing * (icons.size() - 1);
    }
    int boundingHeight=(int)(borderSize * 2 + Math.max(iconHeight,textHeight));
    float textLength=0;
    if (lines != null) {
      for (int k=0; k < lines.size(); k++) {
        textLength=Math.max(textLength,lines.get(k).width);
      }
    }
    int boundingWidth=(int)(borderSize * 2 + iconSize + textLength);
    if (iconIds != null && !iconIds.isEmpty() && lines != null) {
      boundingWidth+=textIconSpacing;
    }
    int offsetX=this.offsetX + this.insets.left;
    int offsetY=this.offsetY - this.insets.top;
    double clampX=offsetX, clampY=offsetY;
    if (clampToScreenEdges) {
      if (x + boundingWidth + offsetX > bounds.getWidth())       clampX=bounds.getWidth() - boundingWidth - x;
      if (x + offsetX < 0)       clampX=-x;
      if (y + offsetY > bounds.getHeight())       clampY=bounds.getHeight() - y;
      if (boundingHeight > y + offsetY)       clampY=boundingHeight - y;
    }
    if (this.paintBackground || this.paintBorder) {
      float xMin=(float)(x + clampX);
      float yMin=(float)(y + clampY);
      float xMax=xMin + boundingWidth;
      float yMax=yMin - boundingHeight;
      if (paintBackground) {
        this.fillBuilder.clear();
        this.fillBuilder.addQuad2f(xMin,yMin,xMax,yMax);
        this.fillProg.begin(gl);
        try {
          this.fillProg.setPixelOrtho(gl,bounds);
          this.fillProg.draw(gl,this.fillBuilder,this.backgroundColor);
        }
  finally {
          this.fillProg.end(gl);
        }
      }
      if (paintBorder) {
        this.linePath.clear();
        this.linePath.addRectangle(xMin,yMin,xMax,yMax);
        this.lineProg.begin(gl);
        try {
          this.lineProg.setPixelOrtho(gl,bounds);
          this.lineProg.setViewport(gl,bounds);
          this.lineStyle.rgba=borderColor;
          this.lineProg.draw(gl,this.lineStyle,this.linePath);
        }
  finally {
          this.lineProg.end(gl);
        }
      }
    }
    gl.glDisable(GL2.GL_BLEND);
    if (lines != null && textRenderer != null) {
      GlimpseColor.setColor(textRenderer,textColor);
      textRenderer.beginRendering(width,height);
      try {
        double posX=x + iconSize + borderSize;
        if (iconIds != null && !iconIds.isEmpty()) {
          posX+=textIconSpacing;
        }
        double posY=y - borderSize - textLayout.getLineHeight();
        double iconPosY=Float.NEGATIVE_INFINITY;
        if (wrapTextAroundIcon && icons != null) {
          iconPosY=y - (iconSize * icons.size() + iconSpacing * (icons.size() - 1) + borderSize);
        }
        for (int i=0; i < lines.size(); i++) {
          if (posY + textLayout.getLineHeight() < iconPosY)           posX=x + borderSize;
          textRenderer.draw(lines.get(i).text,(int)(posX + clampX),(int)(posY + clampY));
          posY=posY - lineSpacing - (textLayout.getLineHeight());
        }
      }
  finally {
        textRenderer.endRendering();
      }
    }
    if (iconIds != null && !iconIds.isEmpty()) {
      GLUtils.enableStandardBlending(gl);
      atlas.beginRenderingPixelOrtho(context,bounds);
      try {
        double posY=y - borderSize - iconSize;
        for (int i=0; i < iconIds.size(); i++) {
          Object iconId=iconIds.get(i);
          ImageData iconData=icons.get(i);
          if (iconId != null && iconData != null) {
            double iconScale=iconSize / (double)iconData.getWidth();
            float[] color=defaultIconColor;
            if (iconColors != null && i < iconColors.size()) {
              float[] iconColor=iconColors.get(i);
              if (iconColor != null)               color=iconColor;
            }
            int scaleX=(int)(x + borderSize + clampX);
            int scaleY=(int)(posY + clampY);
            atlas.drawImage(context,iconId,scaleX,scaleY,iconScale,iconScale,0,iconData.getHeight(),color);
            posY=posY - iconSize - iconSpacing;
          }
        }
      }
  finally {
        atlas.endRendering(context);
        GLUtils.disableBlending(gl);
      }
    }
  }
  finally {
    GLUtils.disableBlending(gl);
  }
}",0.9878354536168632
11351,"@Override public void doPaintTo(GlimpseContext context){
  if (this.pickSupportEnabled) {
    if (this.pickFrameBuffer == null) {
      this.pickFrameBuffer=new GLSimpleFrameBufferObject(WIDTH_BUFFER * 2 + 1,HEIGHT_BUFFER * 2 + 1,context.getGLContext());
    }
    pickIcons(context);
  }
  paintIcons(context);
}","@Override public void doPaintTo(GlimpseContext context){
  GL3 gl=getGL3(context);
  if (this.pickSupportEnabled) {
    if (this.pickFrameBuffer == null) {
      this.pickFrameBuffer=new GLSimpleFrameBufferObject(WIDTH_BUFFER * 2 + 1,HEIGHT_BUFFER * 2 + 1,context.getGLContext());
    }
    pickIcons(context);
  }
  GLUtils.enableStandardBlending(gl);
  try {
    paintIcons(context);
  }
  finally {
    GLUtils.disableBlending(gl);
  }
}",0.8313413014608234
11352,"@Override public void end(GlimpseContext context){
  GL3 gl=context.getGL().getGL3();
  gl.glDisableVertexAttribArray(this.handles.inXy);
  gl.glDisableVertexAttribArray(this.handles.inS);
  gl.glUseProgram(0);
}","@Override public void end(GlimpseContext context){
  GL3 gl=context.getGL().getGL3();
  if (this.handles != null) {
    gl.glDisableVertexAttribArray(this.handles.inXy);
    gl.glDisableVertexAttribArray(this.handles.inS);
  }
  gl.glUseProgram(0);
}",0.9177489177489178
11353,"public static Supplier<BufferedImage> newImageLoader(final StreamOpener opener,final String location){
  return new Supplier<BufferedImage>(){
    public BufferedImage get(){
      try {
        InputStream stream=null;
        try {
          stream=opener.openForRead(location);
          return ImageIO.read(stream);
        }
  finally {
          if (stream != null)           stream.close();
        }
      }
 catch (      IOException e) {
        throw new RuntimeException(e);
      }
    }
  }
;
}","public static Supplier<BufferedImage> newImageLoader(final StreamOpener opener,final String location){
  return new Supplier<BufferedImage>(){
    @Override public BufferedImage get(){
      try {
        InputStream stream=null;
        try {
          stream=opener.openForRead(location);
          return ImageIO.read(stream);
        }
  finally {
          if (stream != null)           stream.close();
        }
      }
 catch (      IOException e) {
        throw new RuntimeException(e);
      }
    }
  }
;
}",0.990234375
11354,"@Override protected void doDispose(GlimpseContext context){
  prog.dispose(context.getGL().getGL3());
  inXy.dispose(context.getGL());
  inS.dispose(context.getGL());
}","@Override protected void doDispose(GlimpseContext context){
  prog.dispose(context);
  inXy.dispose(context.getGL());
  inS.dispose(context.getGL());
}",0.9467084639498432
11355,"public BufferedImage get(){
  try {
    InputStream stream=null;
    try {
      stream=opener.openForRead(location);
      return ImageIO.read(stream);
    }
  finally {
      if (stream != null)       stream.close();
    }
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
}","@Override public BufferedImage get(){
  try {
    InputStream stream=null;
    try {
      stream=opener.openForRead(location);
      return ImageIO.read(stream);
    }
  finally {
      if (stream != null)       stream.close();
    }
  }
 catch (  IOException e) {
    throw new RuntimeException(e);
  }
}",0.9833887043189368
11356,"protected void doPaintTo(GlimpseContext context){
  GL3 gl=context.getGL().getGL3();
  GlimpseBounds bounds=getBounds(context);
  initIfNecessary(gl);
  if (texture == null)   return;
  double[] quadGeometry=computeQuadGeometry(texture.getWidth(),texture.getHeight(),bounds.getWidth(),bounds.getHeight());
  double wQuad=quadGeometry[0];
  double hQuad=quadGeometry[1];
  double padding=quadGeometry[2];
  float xLeft;
  float xRight;
switch (config.horizontalPos) {
case LEFT:
{
      xLeft=(float)(padding);
      xRight=(float)(xLeft + wQuad);
    }
  break;
default :
{
  xRight=(float)(bounds.getWidth() - padding);
  xLeft=(float)(xRight - wQuad);
}
break;
}
float yTop;
float yBottom;
switch (config.verticalPos) {
case TOP:
{
yTop=(float)(bounds.getHeight() - padding);
yBottom=(float)(yTop - hQuad);
}
break;
default :
{
yBottom=(float)(padding);
yTop=(float)(yBottom + hQuad);
}
break;
}
inXy.clear();
inXy.addQuad2f(xLeft,yBottom,xRight,yTop);
inS.clear();
inS.addQuad2f(0,1,1,0);
texture.setTexParameteri(gl,GL3.GL_TEXTURE_MAG_FILTER,GL3.GL_LINEAR);
texture.setTexParameteri(gl,GL3.GL_TEXTURE_MIN_FILTER,GL3.GL_LINEAR);
texture.enable(gl);
texture.bind(gl);
gl.glEnable(GL3.GL_BLEND);
gl.glBlendFunc(GL3.GL_ONE,GL3.GL_ONE_MINUS_SRC_ALPHA);
prog.begin(gl);
try {
prog.setPixelOrtho(gl,bounds);
prog.setTexture(gl,0);
prog.draw(gl,texture,inXy,inS);
}
  finally {
prog.end(gl);
gl.glDisable(GL3.GL_BLEND);
}
}","@Override protected void doPaintTo(GlimpseContext context){
  GL3 gl=context.getGL().getGL3();
  GlimpseBounds bounds=getBounds(context);
  initIfNecessary(gl);
  if (texture == null)   return;
  double[] quadGeometry=computeQuadGeometry(texture.getWidth(),texture.getHeight(),bounds.getWidth(),bounds.getHeight());
  double wQuad=quadGeometry[0];
  double hQuad=quadGeometry[1];
  double padding=quadGeometry[2];
  float xLeft;
  float xRight;
switch (config.horizontalPos) {
case LEFT:
{
      xLeft=(float)(padding);
      xRight=(float)(xLeft + wQuad);
    }
  break;
default :
{
  xRight=(float)(bounds.getWidth() - padding);
  xLeft=(float)(xRight - wQuad);
}
break;
}
float yTop;
float yBottom;
switch (config.verticalPos) {
case TOP:
{
yTop=(float)(bounds.getHeight() - padding);
yBottom=(float)(yTop - hQuad);
}
break;
default :
{
yBottom=(float)(padding);
yTop=(float)(yBottom + hQuad);
}
break;
}
inXy.clear();
inXy.addQuad2f(xLeft,yBottom,xRight,yTop);
inS.clear();
inS.addQuad2f(0,1,1,0);
texture.setTexParameteri(gl,GL3.GL_TEXTURE_MAG_FILTER,GL3.GL_LINEAR);
texture.setTexParameteri(gl,GL3.GL_TEXTURE_MIN_FILTER,GL3.GL_LINEAR);
texture.enable(gl);
texture.bind(gl);
gl.glEnable(GL3.GL_BLEND);
gl.glBlendFunc(GL3.GL_ONE,GL3.GL_ONE_MINUS_SRC_ALPHA);
prog.begin(context);
try {
prog.setPixelOrtho(context,bounds);
prog.setTexture(context,0);
prog.draw(context,texture,inXy,inS);
}
  finally {
prog.end(context);
gl.glDisable(GL3.GL_BLEND);
}
}",0.9627567003132614
11357,"public GlimpseLayout getLayout(final FBOGlimpseCanvas offscreenCanvas) throws Exception {
  Axis2D axis=new Axis2D();
  axis.set(-10,10,-10,10);
  GlimpseAxisLayout2D layout2=new GlimpseAxisLayout2D(axis);
  AxisUtil.attachMouseListener(layout2);
  ShadedTexturePainter painter=new ShadedTexturePainter(){
    boolean initialized=false;
    @Override public void paintTo(    GlimpseContext context,    GlimpseBounds bounds,    Axis2D axis){
      super.paintTo(context,bounds,axis);
      if (!initialized && offscreenCanvas.getGLDrawable().isInitialized()) {
        TextureProjected2D texture=offscreenCanvas.getProjectedTexture();
        texture.setProjection(new PolarProjection(0,10,0,360));
        addDrawableTexture(texture);
        initialized=true;
      }
    }
  }
;
  layout2.addPainter(new BackgroundPainter(true));
  layout2.addPainter(painter);
  return layout2;
}","public GlimpseLayout getLayout(final FBOGlimpseCanvas offscreenCanvas) throws Exception {
  Axis2D axis=new Axis2D();
  axis.set(-10,10,-10,10);
  GlimpseAxisLayout2D layout2=new GlimpseAxisLayout2D(axis);
  AxisUtil.attachMouseListener(layout2);
  ShadedTexturePainter painter=new ShadedTexturePainter(){
    boolean initialized=false;
    @Override public void doPaintTo(    GlimpseContext context){
      if (!initialized && offscreenCanvas.getGLDrawable().isInitialized()) {
        TextureProjected2D texture=offscreenCanvas.getProjectedTexture();
        texture.setProjection(new PolarProjection(0,10,0,360));
        addDrawableTexture(texture);
        initialized=true;
      }
      super.doPaintTo(context);
    }
  }
;
  painter.setProgram(new ColorTexture2DProgram());
  layout2.addPainter(new BackgroundPainter(true));
  layout2.addPainter(painter);
  return layout2;
}",0.9037372593431484
11358,public void begin(GlimpseContext context);,"public void begin(GlimpseContext context,float xMin,float xMax,float yMin,float yMax);",0.65625
11359,"@Override public void draw(GlimpseContext context,DrawableTextureProgram program,int texUnit,Collection<TextureUnit<Texture>> multiTextureList){
  boolean ready=true;
  for (  TextureUnit<Texture> texture : multiTextureList) {
    if (!texture.prepare(context))     ready=false;
  }
  if (!prepare(context,texUnit))   ready=false;
  if (!ready) {
    logger.log(WARNING,""String_Node_Str"");
    return;
  }
  Axis2D axis=GlimpsePainterBase.getAxis2D(context);
  program.setOrtho(context,(float)axis.getMinX(),(float)axis.getMaxX(),(float)axis.getMinY(),(float)axis.getMaxY());
  program.begin(context);
  try {
    program.draw(context,getMode(),xyVbo(context),sVbo(context),0,this.xyBuilder.numFloats() / 2);
  }
  finally {
    program.end(context);
  }
}","@Override public void draw(GlimpseContext context,DrawableTextureProgram program,int texUnit,Collection<TextureUnit<Texture>> multiTextureList){
  boolean ready=true;
  for (  TextureUnit<Texture> texture : multiTextureList) {
    if (!texture.prepare(context))     ready=false;
  }
  if (!prepare(context,texUnit))   ready=false;
  if (!ready) {
    logger.log(WARNING,""String_Node_Str"");
    return;
  }
  Axis2D axis=GlimpsePainterBase.getAxis2D(context);
  program.begin(context,(float)axis.getMinX(),(float)axis.getMaxX(),(float)axis.getMinY(),(float)axis.getMaxY());
  try {
    program.draw(context,getMode(),xyVbo(context),sVbo(context),0,this.xyBuilder.numFloats() / 2);
  }
  finally {
    program.end(context);
  }
}",0.973701955495617
11360,"@Override public void setOrtho(GlimpseContext context,float xMin,float xMax,float yMin,float yMax){
  this.AXIS_RECT.setData(FloatBuffer.wrap(new float[]{xMin,xMax,yMin,yMax}));
}","public void setOrtho(GlimpseContext context,float xMin,float xMax,float yMin,float yMax){
  this.AXIS_RECT.setData(FloatBuffer.wrap(new float[]{xMin,xMax,yMin,yMax}));
}",0.971264367816092
11361,"protected void initialize(Axis1D colorAxis,int targetTexUnit,int colorTexUnit){
  this.addShaders();
  this.dataMin=this.addUniformData(new GLUniformData(""String_Node_Str"",getMin(colorAxis)));
  this.dataMax=this.addUniformData(new GLUniformData(""String_Node_Str"",getMax(colorAxis)));
  this.alpha=this.addUniformData(new GLUniformData(""String_Node_Str"",1f));
  this.discardNaN=this.addUniformData(new GLUniformData(""String_Node_Str"",0));
  this.dataTexUnit=this.addUniformData(new GLUniformData(""String_Node_Str"",targetTexUnit));
  this.colorTexUnit=this.addUniformData(new GLUniformData(""String_Node_Str"",colorTexUnit));
  this.AXIS_RECT=this.addUniformData(GLUniformData.creatEmptyVector(""String_Node_Str"",4));
  this.colorAxis=colorAxis;
  this.colorAxis.addAxisListener(this);
}","protected void initialize(Axis1D colorAxis,int targetTexUnit,int colorTexUnit){
  this.addShaders();
  this.dataMin=this.addUniformData(new GLUniformData(""String_Node_Str"",getMin(colorAxis)));
  this.dataMax=this.addUniformData(new GLUniformData(""String_Node_Str"",getMax(colorAxis)));
  this.alpha=this.addUniformData(new GLUniformData(""String_Node_Str"",1f));
  this.discardNaN=this.addUniformData(new GLUniformData(""String_Node_Str"",0));
  this.dataTexUnit=this.addUniformData(new GLUniformData(""String_Node_Str"",targetTexUnit));
  this.colorTexUnit=this.addUniformData(new GLUniformData(""String_Node_Str"",colorTexUnit));
  this.AXIS_RECT=this.addUniformData(GLUniformData.creatEmptyVector(""String_Node_Str"",4));
  this.AXIS_RECT.setData(FloatBuffer.wrap(new float[]{0,1,0,1}));
  this.colorAxis=colorAxis;
  this.colorAxis.addAxisListener(this);
}",0.9595588235294118
11362,"@Override public void begin(GlimpseContext context){
  GL3 gl=context.getGL().getGL3();
  this.useProgram(context.getGL(),true);
  if (this.handles == null) {
    this.handles=new ProgramHandles(gl,getShaderProgram().id());
  }
  gl.glEnableVertexAttribArray(this.handles.inXy);
  gl.glEnableVertexAttribArray(this.handles.inS);
}","@Override public void begin(GlimpseContext context,float xMin,float xMax,float yMin,float yMax){
  setOrtho(context,xMin,xMax,yMin,yMax);
  GL3 gl=context.getGL().getGL3();
  this.useProgram(context.getGL(),true);
  if (this.handles == null) {
    this.handles=new ProgramHandles(gl,getShaderProgram().id());
  }
  gl.glEnableVertexAttribArray(this.handles.inXy);
  gl.glEnableVertexAttribArray(this.handles.inS);
}",0.8859060402684564
11363,"@Override public void setOrtho(GlimpseContext context,float xMin,float xMax,float yMin,float yMax){
  this.AXIS_RECT.setData(FloatBuffer.wrap(new float[]{xMin,xMax,yMin,yMax}));
}","public void setOrtho(GlimpseContext context,float xMin,float xMax,float yMin,float yMax){
  this.AXIS_RECT.setData(FloatBuffer.wrap(new float[]{xMin,xMax,yMin,yMax}));
}",0.971264367816092
11364,"@Override public void begin(GlimpseContext context){
  GL3 gl=context.getGL().getGL3();
  this.useProgram(context.getGL(),true);
  if (this.handles == null) {
    this.handles=new ProgramHandles(gl,getShaderProgram().id());
  }
  gl.glEnableVertexAttribArray(this.handles.inXy);
  gl.glEnableVertexAttribArray(this.handles.inS);
}","public void begin(GlimpseContext context){
  GL3 gl=context.getGL().getGL3();
  this.useProgram(context.getGL(),true);
  if (this.handles == null) {
    this.handles=new ProgramHandles(gl,getShaderProgram().id());
  }
  gl.glEnableVertexAttribArray(this.handles.inXy);
  gl.glEnableVertexAttribArray(this.handles.inS);
}",0.9846153846153848
11365,"@Override public void setOrtho(GlimpseContext context,float xMin,float xMax,float yMin,float yMax){
  GL3 gl=context.getGL().getGL3();
  gl.glUniform4f(this.handles.AXIS_RECT,xMin,xMax,yMin,yMax);
}","public void setOrtho(GlimpseContext context,float xMin,float xMax,float yMin,float yMax){
  GL3 gl=context.getGL().getGL3();
  gl.glUniform4f(this.handles.AXIS_RECT,xMin,xMax,yMin,yMax);
}",0.9740932642487048
11366,"@Override public void begin(GlimpseContext context){
  GL3 gl=context.getGL().getGL3();
  if (this.handles == null) {
    this.handles=new ProgramHandles(gl);
  }
  gl.glUseProgram(this.handles.program);
  gl.glEnableVertexAttribArray(this.handles.inXy);
  gl.glEnableVertexAttribArray(this.handles.inS);
}","public void begin(GlimpseContext context){
  GL3 gl=context.getGL().getGL3();
  if (this.handles == null) {
    this.handles=new ProgramHandles(gl);
  }
  gl.glUseProgram(this.handles.program);
  gl.glEnableVertexAttribArray(this.handles.inXy);
  gl.glEnableVertexAttribArray(this.handles.inS);
}",0.9833887043189368
11367,"@Override public void setOrtho(GlimpseContext context,float xMin,float xMax,float yMin,float yMax){
  GL3 gl=context.getGL().getGL3();
  gl.glUniform4f(this.handles.AXIS_RECT,xMin,xMax,yMin,yMax);
}","public void setOrtho(GlimpseContext context,float xMin,float xMax,float yMin,float yMax){
  GL3 gl=context.getGL().getGL3();
  gl.glUniform4f(this.handles.AXIS_RECT,xMin,xMax,yMin,yMax);
}",0.9740932642487048
11368,"@Override public void begin(GlimpseContext context){
  GL3 gl=context.getGL().getGL3();
  if (this.handles == null) {
    this.handles=new ProgramHandles(gl);
    gl.glUniform4f(this.handles.RGBA,1,1,1,1);
  }
  gl.glUseProgram(this.handles.program);
  gl.glEnableVertexAttribArray(this.handles.inXy);
  gl.glEnableVertexAttribArray(this.handles.inS);
}","@Override public void begin(GlimpseContext context,float xMin,float xMax,float yMin,float yMax){
  this.begin(context);
  this.setOrtho(context,xMin,xMax,yMin,yMax);
}",0.35
11369,"@Override public void draw(GlimpseContext context,DrawableTextureProgram program,int texUnit,Collection<TextureUnit<Texture>> multiTextureList){
  boolean ready=prepare(context,texUnit);
  if (!ready) {
    logger.log(WARNING,""String_Node_Str"");
    return;
  }
  for (  TextureUnit<Texture> texture : multiTextureList) {
    ready=texture.prepare(context);
    if (!ready) {
      logger.log(WARNING,""String_Node_Str"");
      return;
    }
  }
  Axis2D axis=GlimpsePainterBase.getAxis2D(context);
  GL3 gl=GlimpsePainterBase.getGL3(context);
  program.setOrtho(context,(float)axis.getMinX(),(float)axis.getMaxX(),(float)axis.getMinY(),(float)axis.getMaxY());
  program.begin(context);
  try {
    for (int i=0; i < numTextures; i++) {
      for (      TextureUnit<Texture> multiTexture : multiTextureList) {
        Texture texture=multiTexture.getTexture();
        int[] handles=texture.getHandles();
        int multiTextureUnit=multiTexture.getTextureUnit();
        int type=getGLTextureDim(texture.getNumDimension());
        gl.glActiveTexture(getGLTextureUnit(multiTextureUnit));
        gl.glBindTexture(type,texture.getHandles()[i >= handles.length ? 0 : i]);
      }
      int type=getTextureType();
      gl.glActiveTexture(getGLTextureUnit(texUnit));
      gl.glBindTexture(type,textureHandles[i]);
      int vertexCount=VERTICES_PER_QUAD * texQuadCounts[i];
      program.draw(context,GL.GL_TRIANGLES,vertexCoordHandles[i],texCoordHandles[i],0,vertexCount);
    }
  }
  finally {
    program.end(context);
  }
}","@Override public void draw(GlimpseContext context,DrawableTextureProgram program,int texUnit,Collection<TextureUnit<Texture>> multiTextureList){
  boolean ready=prepare(context,texUnit);
  if (!ready) {
    logger.log(WARNING,""String_Node_Str"");
    return;
  }
  for (  TextureUnit<Texture> texture : multiTextureList) {
    ready=texture.prepare(context);
    if (!ready) {
      logger.log(WARNING,""String_Node_Str"");
      return;
    }
  }
  Axis2D axis=GlimpsePainterBase.getAxis2D(context);
  GL3 gl=GlimpsePainterBase.getGL3(context);
  program.begin(context,(float)axis.getMinX(),(float)axis.getMaxX(),(float)axis.getMinY(),(float)axis.getMaxY());
  try {
    for (int i=0; i < numTextures; i++) {
      for (      TextureUnit<Texture> multiTexture : multiTextureList) {
        Texture texture=multiTexture.getTexture();
        int[] handles=texture.getHandles();
        int multiTextureUnit=multiTexture.getTextureUnit();
        int type=getGLTextureDim(texture.getNumDimension());
        gl.glActiveTexture(getGLTextureUnit(multiTextureUnit));
        gl.glBindTexture(type,texture.getHandles()[i >= handles.length ? 0 : i]);
      }
      int type=getTextureType();
      gl.glActiveTexture(getGLTextureUnit(texUnit));
      gl.glBindTexture(type,textureHandles[i]);
      int vertexCount=VERTICES_PER_QUAD * texQuadCounts[i];
      program.draw(context,GL.GL_TRIANGLES,vertexCoordHandles[i],texCoordHandles[i],0,vertexCount);
    }
  }
  finally {
    program.end(context);
  }
}",0.9870989083691696
11370,"@Override protected synchronized void doPaintTo(GlimpseContext context){
  GlimpseBounds bounds=getBounds(context);
  Axis2D axis=getAxis2D(context);
  GL3 gl=context.getGL().getGL3();
  int width=bounds.getWidth();
  int height=bounds.getHeight();
  if (axis == null && !drawInPixelCoords) {
    throw new AxisNotSetException(this,context);
  }
  double x=drawInPixelCoords ? this.x : axis.getAxisX().valueToScreenPixelUnits(this.x);
  double y=drawInPixelCoords ? bounds.getHeight() - this.y : axis.getAxisY().valueToScreenPixelUnits(this.y);
  if (icons == null) {
    loadIcons(context);
  }
  if (newFont != null) {
    updateTextRenderer();
  }
  if (text != null && textLayout == null && textRenderer != null) {
    updateTextLayout();
  }
  if (iconIds == null && lines == null)   return;
  GLUtils.enableStandardBlending(gl);
  try {
    double textHeight=0;
    if (lines != null) {
      textHeight=(textLayout.getLineHeight()) * lines.size() + lineSpacing * (lines.size() - 1);
    }
    float iconSize;
    if (iconIds == null || iconIds.isEmpty()) {
      iconSize=0;
    }
 else     if (iconSizeFixedToText && textHeight != 0) {
      iconSize=(float)textLayout.getLineHeight();
    }
 else {
      iconSize=this.iconSize;
    }
    double iconHeight=0;
    if (icons != null) {
      iconHeight=iconSize * icons.size() + iconSpacing * (icons.size() - 1);
    }
    int boundingHeight=(int)(borderSize * 2 + Math.max(iconHeight,textHeight));
    float textLength=0;
    if (lines != null) {
      for (int k=0; k < lines.size(); k++) {
        textLength=Math.max(textLength,lines.get(k).width);
      }
    }
    int boundingWidth=(int)(borderSize * 2 + iconSize + textLength);
    if (iconIds != null && !iconIds.isEmpty() && lines != null) {
      boundingWidth+=textIconSpacing;
    }
    int offsetX=this.offsetX + this.insets.left;
    int offsetY=this.offsetY - this.insets.top;
    double clampX=offsetX, clampY=offsetY;
    if (clampToScreenEdges) {
      if (x + boundingWidth + offsetX > bounds.getWidth())       clampX=bounds.getWidth() - boundingWidth - x;
      if (x + offsetX < 0)       clampX=-x;
      if (y + offsetY > bounds.getHeight())       clampY=bounds.getHeight() - y;
      if (boundingHeight > y + offsetY)       clampY=boundingHeight - y;
    }
    if (this.paintBackground || this.paintBorder) {
      if (paintBackground) {
        this.fillBuilder.clear();
        this.fillBuilder.addQuad2f(boundingHeight,boundingWidth,(float)(x + clampX),(float)(y + clampY));
        this.fillProg.begin(gl);
        try {
          this.fillProg.setPixelOrtho(gl,bounds);
          this.fillProg.draw(gl,this.fillBuilder,this.backgroundColor);
        }
  finally {
          this.fillProg.end(gl);
        }
      }
      if (paintBorder) {
        this.linePath.clear();
        this.linePath.addRectangle(boundingHeight,boundingWidth,(float)(x + clampX),(float)(y + clampY));
        this.lineProg.begin(gl);
        try {
          this.lineProg.setPixelOrtho(gl,bounds);
          this.lineProg.setViewport(gl,bounds);
          this.lineStyle.rgba=borderColor;
          this.lineProg.draw(gl,this.lineStyle,this.linePath);
        }
  finally {
          this.lineProg.end(gl);
        }
      }
    }
    gl.glDisable(GL2.GL_BLEND);
    if (lines != null && textRenderer != null) {
      GlimpseColor.setColor(textRenderer,textColor);
      textRenderer.beginRendering(width,height);
      try {
        double posX=x + iconSize + borderSize;
        if (iconIds != null && !iconIds.isEmpty()) {
          posX+=textIconSpacing;
        }
        double posY=y - borderSize - textLayout.getLineHeight();
        double iconPosY=Float.NEGATIVE_INFINITY;
        if (wrapTextAroundIcon && icons != null) {
          iconPosY=y - (iconSize * icons.size() + iconSpacing * (icons.size() - 1) + borderSize);
        }
        for (int i=0; i < lines.size(); i++) {
          if (posY + textLayout.getLineHeight() < iconPosY)           posX=x + borderSize;
          textRenderer.draw(lines.get(i).text,(int)(posX + clampX),(int)(posY + clampY));
          posY=posY - lineSpacing - (textLayout.getLineHeight());
        }
      }
  finally {
        textRenderer.endRendering();
      }
    }
    if (iconIds != null && !iconIds.isEmpty()) {
      atlas.beginRendering(context);
      try {
        double posY=y - borderSize - iconSize;
        for (int i=0; i < iconIds.size(); i++) {
          Object iconId=iconIds.get(i);
          ImageData iconData=icons.get(i);
          if (iconId != null && iconData != null) {
            double iconScale=iconSize / (double)iconData.getWidth();
            float[] color=defaultIconColor;
            if (iconColors != null && i < iconColors.size()) {
              float[] iconColor=iconColors.get(i);
              if (iconColor != null)               color=iconColor;
            }
            int scaleX=(int)(x + borderSize + clampX);
            int scaleY=(int)(posY + clampY);
            atlas.drawImage(gl,iconId,scaleX,scaleY,iconScale,iconScale,0,iconData.getHeight(),color);
            posY=posY - iconSize - iconSpacing;
          }
        }
      }
  finally {
        atlas.endRendering(context);
      }
    }
  }
  finally {
    GLUtils.disableBlending(gl);
  }
}","@Override protected synchronized void doPaintTo(GlimpseContext context){
  GlimpseBounds bounds=getBounds(context);
  Axis2D axis=getAxis2D(context);
  GL3 gl=context.getGL().getGL3();
  int width=bounds.getWidth();
  int height=bounds.getHeight();
  if (axis == null && !drawInPixelCoords) {
    throw new AxisNotSetException(this,context);
  }
  double x=drawInPixelCoords ? this.x : axis.getAxisX().valueToScreenPixelUnits(this.x);
  double y=drawInPixelCoords ? bounds.getHeight() - this.y : axis.getAxisY().valueToScreenPixelUnits(this.y);
  if (icons == null) {
    loadIcons(context);
  }
  if (newFont != null) {
    updateTextRenderer();
  }
  if (text != null && textLayout == null && textRenderer != null) {
    updateTextLayout();
  }
  if (iconIds == null && lines == null)   return;
  GLUtils.enableStandardBlending(gl);
  try {
    double textHeight=0;
    if (lines != null) {
      textHeight=(textLayout.getLineHeight()) * lines.size() + lineSpacing * (lines.size() - 1);
    }
    float iconSize;
    if (iconIds == null || iconIds.isEmpty()) {
      iconSize=0;
    }
 else     if (iconSizeFixedToText && textHeight != 0) {
      iconSize=(float)textLayout.getLineHeight();
    }
 else {
      iconSize=this.iconSize;
    }
    double iconHeight=0;
    if (icons != null) {
      iconHeight=iconSize * icons.size() + iconSpacing * (icons.size() - 1);
    }
    int boundingHeight=(int)(borderSize * 2 + Math.max(iconHeight,textHeight));
    float textLength=0;
    if (lines != null) {
      for (int k=0; k < lines.size(); k++) {
        textLength=Math.max(textLength,lines.get(k).width);
      }
    }
    int boundingWidth=(int)(borderSize * 2 + iconSize + textLength);
    if (iconIds != null && !iconIds.isEmpty() && lines != null) {
      boundingWidth+=textIconSpacing;
    }
    int offsetX=this.offsetX + this.insets.left;
    int offsetY=this.offsetY - this.insets.top;
    double clampX=offsetX, clampY=offsetY;
    if (clampToScreenEdges) {
      if (x + boundingWidth + offsetX > bounds.getWidth())       clampX=bounds.getWidth() - boundingWidth - x;
      if (x + offsetX < 0)       clampX=-x;
      if (y + offsetY > bounds.getHeight())       clampY=bounds.getHeight() - y;
      if (boundingHeight > y + offsetY)       clampY=boundingHeight - y;
    }
    if (this.paintBackground || this.paintBorder) {
      if (paintBackground) {
        this.fillBuilder.clear();
        this.fillBuilder.addQuad2f(boundingHeight,boundingWidth,(float)(x + clampX),(float)(y + clampY));
        this.fillProg.begin(gl);
        try {
          this.fillProg.setPixelOrtho(gl,bounds);
          this.fillProg.draw(gl,this.fillBuilder,this.backgroundColor);
        }
  finally {
          this.fillProg.end(gl);
        }
      }
      if (paintBorder) {
        this.linePath.clear();
        this.linePath.addRectangle(boundingHeight,boundingWidth,(float)(x + clampX),(float)(y + clampY));
        this.lineProg.begin(gl);
        try {
          this.lineProg.setPixelOrtho(gl,bounds);
          this.lineProg.setViewport(gl,bounds);
          this.lineStyle.rgba=borderColor;
          this.lineProg.draw(gl,this.lineStyle,this.linePath);
        }
  finally {
          this.lineProg.end(gl);
        }
      }
    }
    gl.glDisable(GL2.GL_BLEND);
    if (lines != null && textRenderer != null) {
      GlimpseColor.setColor(textRenderer,textColor);
      textRenderer.beginRendering(width,height);
      try {
        double posX=x + iconSize + borderSize;
        if (iconIds != null && !iconIds.isEmpty()) {
          posX+=textIconSpacing;
        }
        double posY=y - borderSize - textLayout.getLineHeight();
        double iconPosY=Float.NEGATIVE_INFINITY;
        if (wrapTextAroundIcon && icons != null) {
          iconPosY=y - (iconSize * icons.size() + iconSpacing * (icons.size() - 1) + borderSize);
        }
        for (int i=0; i < lines.size(); i++) {
          if (posY + textLayout.getLineHeight() < iconPosY)           posX=x + borderSize;
          textRenderer.draw(lines.get(i).text,(int)(posX + clampX),(int)(posY + clampY));
          posY=posY - lineSpacing - (textLayout.getLineHeight());
        }
      }
  finally {
        textRenderer.endRendering();
      }
    }
    if (iconIds != null && !iconIds.isEmpty()) {
      atlas.beginRendering(context);
      try {
        double posY=y - borderSize - iconSize;
        for (int i=0; i < iconIds.size(); i++) {
          Object iconId=iconIds.get(i);
          ImageData iconData=icons.get(i);
          if (iconId != null && iconData != null) {
            double iconScale=iconSize / (double)iconData.getWidth();
            float[] color=defaultIconColor;
            if (iconColors != null && i < iconColors.size()) {
              float[] iconColor=iconColors.get(i);
              if (iconColor != null)               color=iconColor;
            }
            int scaleX=(int)(x + borderSize + clampX);
            int scaleY=(int)(posY + clampY);
            atlas.drawImage(context,iconId,scaleX,scaleY,iconScale,iconScale,0,iconData.getHeight(),color);
            posY=posY - iconSize - iconSpacing;
          }
        }
      }
  finally {
        atlas.endRendering(context);
      }
    }
  }
  finally {
    GLUtils.disableBlending(gl);
  }
}",0.9991458669450508
11371,"@Override public void doPaintTo(GlimpseContext context){
  Axis2D axis=getAxis2D(context);
  GL2 gl=context.getGL().getGL2();
  if (vertexCount == 0)   return;
  if (!constantSize && (sizeTexture == null))   return;
  if (!constantColor && (colorTexture == null))   return;
  if (!constantSize) {
    sizeTexture.prepare(gl,1);
  }
  if (!constantColor) {
    colorTexture.prepare(gl,0);
  }
  program.setProjectionMatrix(axis);
  GLUtils.enableStandardBlending(gl);
  program.useProgram(gl,true);
  try {
    drawArrays(gl);
  }
  finally {
    program.useProgram(gl,false);
    GLUtils.disableBlending(gl);
    gl.glActiveTexture(GL.GL_TEXTURE0);
  }
}","@Override public void doPaintTo(GlimpseContext context){
  Axis2D axis=getAxis2D(context);
  GL2 gl=context.getGL().getGL2();
  if (vertexCount == 0)   return;
  if (!constantSize && (sizeTexture == null))   return;
  if (!constantColor && (colorTexture == null))   return;
  if (!constantSize) {
    sizeTexture.prepare(context,1);
  }
  if (!constantColor) {
    colorTexture.prepare(context,0);
  }
  program.setProjectionMatrix(axis);
  GLUtils.enableStandardBlending(gl);
  program.useProgram(gl,true);
  try {
    drawArrays(gl);
  }
  finally {
    program.useProgram(gl,false);
    GLUtils.disableBlending(gl);
    gl.glActiveTexture(GL.GL_TEXTURE0);
  }
}",0.9863429438543247
11372,"public void useSizeAttribData(FloatBuffer attributeBuffer){
  lock.lock();
  try {
    this.program.setSizeData(attributeBuffer);
    this.setVariablePointColor0();
  }
  finally {
    lock.unlock();
  }
}","@Override public void useSizeAttribData(FloatBuffer attributeBuffer){
  painterLock.lock();
  try {
    this.program.setSizeData(attributeBuffer);
    this.setVariablePointColor0();
  }
  finally {
    painterLock.unlock();
  }
}",0.8986175115207373
11373,"/** 
 * Sets the selected range of times which will be displayed by this painter. Times should generally be provided via   {@code Epoch#fromTimeStamp(TimeStamp)}.
 */
public void displayTimeRange(double startTime,double endTime){
  lock.lock();
  try {
    this.startTime=(float)startTime;
    this.endTime=(float)endTime;
    updateSelectedTime();
  }
  finally {
    lock.unlock();
  }
}","/** 
 * Sets the selected range of times which will be displayed by this painter. Times should generally be provided via   {@code Epoch#fromTimeStamp(TimeStamp)}.
 */
public void displayTimeRange(double startTime,double endTime){
  painterLock.lock();
  try {
    this.startTime=(float)startTime;
    this.endTime=(float)endTime;
    updateSelectedTime();
  }
  finally {
    painterLock.unlock();
  }
}",0.9772727272727272
11374,"/** 
 * Assigns a time value to each point painted by the time painter. Points must be added in increasing time order for time selection to function.
 */
public void useTimeAttribData(FloatBuffer attributeBuffer){
  lock.lock();
  try {
    this.timeAttributeBuffer=attributeBuffer;
    this.updateSelectedTime();
  }
  finally {
    lock.unlock();
  }
}","/** 
 * Assigns a time value to each point painted by the time painter. Points must be added in increasing time order for time selection to function.
 */
public void useTimeAttribData(FloatBuffer attributeBuffer){
  painterLock.lock();
  try {
    this.timeAttributeBuffer=attributeBuffer;
    this.updateSelectedTime();
  }
  finally {
    painterLock.unlock();
  }
}",0.9750692520775625
11375,"public void useVertexPositionData(FloatBuffer positionBuffer){
  lock.lock();
  try {
    super.useVertexPositionData(positionBuffer);
    updateSelectedTime();
  }
  finally {
    lock.unlock();
  }
}","@Override public void useVertexPositionData(FloatBuffer positionBuffer){
  painterLock.lock();
  try {
    super.useVertexPositionData(positionBuffer);
    updateSelectedTime();
  }
  finally {
    painterLock.unlock();
  }
}",0.9342723004694836
11376,"public void useColorAttribData(FloatBuffer attributeBuffer){
  lock.lock();
  try {
    this.program.setColorData(attributeBuffer);
    this.setVariablePointColor0();
  }
  finally {
    lock.unlock();
  }
}","@Override public void useColorAttribData(FloatBuffer attributeBuffer){
  painterLock.lock();
  try {
    this.program.setColorData(attributeBuffer);
    this.setVariablePointColor0();
  }
  finally {
    painterLock.unlock();
  }
}",0.8995433789954338
11377,"public ColorXAxisPainter(AxisLabelHandler ticks){
  super(ticks);
  this.pathOutline=new LinePath();
  this.xyBuffer=new GLStreamingBufferBuilder();
  this.sBuffer=new GLStreamingBufferBuilder();
  this.style=new LineStyle();
  this.style.stippleEnable=false;
  this.style.thickness_PX=1.0f;
  this.style.feather_PX=0.0f;
  this.style.rgba=GlimpseColor.getBlack();
  setTickSize(this.colorBarSize + 0);
}","public ColorXAxisPainter(AxisLabelHandler ticks){
  super(ticks);
  this.pathOutline=new LinePath();
  this.xyBuffer=new GLStreamingBufferBuilder();
  this.sBuffer=new GLStreamingBufferBuilder();
  this.style=new LineStyle();
  this.style.joinType=LineJoinType.JOIN_MITER;
  this.style.stippleEnable=false;
  this.style.thickness_PX=1.0f;
  this.style.feather_PX=0.0f;
  this.style.rgba=GlimpseColor.getBlack();
  setTickSize(this.colorBarSize + 0);
}",0.945029239766082
11378,"protected void paintColorScale(GlimpseContext context){
  if (colorTexture != null) {
    GlimpseBounds bounds=getBounds(context);
    GL3 gl=context.getGL().getGL3();
    int height=bounds.getHeight();
    int width=bounds.getWidth();
    float y1=getColorBarMinY(height);
    float y2=getColorBarMaxY(height);
    pathOutline.clear();
    pathOutline.addRectangle(0.5f,y1,width,y2);
    xyBuffer.clear();
    xyBuffer.addQuad2f(0.5f,y1,width,y2);
    sBuffer.clear();
    sBuffer.addQuad1f(0,0,1,1);
    GLUtils.enableStandardBlending(gl);
    try {
      progTex.begin(gl);
      try {
        progTex.setPixelOrtho(gl,bounds);
        progTex.draw(gl,colorTexture,xyBuffer,sBuffer);
      }
  finally {
        progTex.end(gl);
      }
      progOutline.begin(gl);
      try {
        progOutline.setPixelOrtho(gl,bounds);
        progOutline.setViewport(gl,bounds);
        progOutline.draw(gl,style,pathOutline);
      }
  finally {
        progOutline.end(gl);
      }
    }
  finally {
      GLUtils.disableBlending(gl);
    }
  }
}","protected void paintColorScale(GlimpseContext context){
  if (colorTexture != null) {
    GlimpseBounds bounds=getBounds(context);
    GL3 gl=context.getGL().getGL3();
    int height=bounds.getHeight();
    int width=bounds.getWidth();
    float y1=getColorBarMinY(height);
    float y2=getColorBarMaxY(height);
    float inset_PX=0.5f * style.thickness_PX;
    pathOutline.clear();
    pathOutline.addRectangle(inset_PX,y1,width - inset_PX,y2);
    xyBuffer.clear();
    xyBuffer.addQuad2f(inset_PX,y1,width - inset_PX,y2);
    sBuffer.clear();
    sBuffer.addQuad1f(0,0,1,1);
    GLUtils.enableStandardBlending(gl);
    try {
      progTex.begin(gl);
      try {
        progTex.setPixelOrtho(gl,bounds);
        progTex.draw(gl,colorTexture,xyBuffer,sBuffer);
      }
  finally {
        progTex.end(gl);
      }
      progOutline.begin(gl);
      try {
        progOutline.setPixelOrtho(gl,bounds);
        progOutline.setViewport(gl,bounds);
        progOutline.draw(gl,style,pathOutline);
      }
  finally {
        progOutline.end(gl);
      }
    }
  finally {
      GLUtils.disableBlending(gl);
    }
  }
}",0.9573283858998144
11379,"public ColorYAxisPainter(AxisLabelHandler ticks){
  super(ticks);
  this.pathOutline=new LinePath();
  this.xyBuffer=new GLStreamingBufferBuilder();
  this.sBuffer=new GLStreamingBufferBuilder();
  this.style=new LineStyle();
  this.style.stippleEnable=false;
  this.style.thickness_PX=1.0f;
  this.style.feather_PX=0.0f;
  this.style.rgba=GlimpseColor.getBlack();
  setTickSize(this.colorBarSize + 0);
}","public ColorYAxisPainter(AxisLabelHandler ticks){
  super(ticks);
  this.pathOutline=new LinePath();
  this.xyBuffer=new GLStreamingBufferBuilder();
  this.sBuffer=new GLStreamingBufferBuilder();
  this.style=new LineStyle();
  this.style.joinType=LineJoinType.JOIN_MITER;
  this.style.stippleEnable=false;
  this.style.thickness_PX=1.0f;
  this.style.feather_PX=0.0f;
  this.style.rgba=GlimpseColor.getBlack();
  setTickSize(this.colorBarSize + 0);
}",0.945029239766082
11380,"protected void paintColorScale(GlimpseContext context){
  if (colorTexture != null) {
    GlimpseBounds bounds=getBounds(context);
    GL3 gl=context.getGL().getGL3();
    int height=bounds.getHeight();
    int width=bounds.getWidth();
    float x1=getColorBarMinX(width);
    float x2=getColorBarMaxX(width);
    pathOutline.clear();
    pathOutline.addRectangle(x1,0.5f,x2,height);
    xyBuffer.clear();
    xyBuffer.addQuad2f(x1,0.5f,x2,height);
    sBuffer.clear();
    sBuffer.addQuad1f(0,1,0,1);
    GLUtils.enableStandardBlending(gl);
    try {
      progTex.begin(gl);
      try {
        progTex.setPixelOrtho(gl,bounds);
        progTex.draw(gl,colorTexture,xyBuffer,sBuffer);
      }
  finally {
        progTex.end(gl);
      }
      progOutline.begin(gl);
      try {
        progOutline.setPixelOrtho(gl,bounds);
        progOutline.setViewport(gl,bounds);
        progOutline.draw(gl,style,pathOutline);
      }
  finally {
        progOutline.end(gl);
      }
    }
  finally {
      GLUtils.disableBlending(gl);
    }
  }
}","protected void paintColorScale(GlimpseContext context){
  if (colorTexture != null) {
    GlimpseBounds bounds=getBounds(context);
    GL3 gl=context.getGL().getGL3();
    int height=bounds.getHeight();
    int width=bounds.getWidth();
    float x1=getColorBarMinX(width);
    float x2=getColorBarMaxX(width);
    float inset_PX=0.5f * style.thickness_PX;
    pathOutline.clear();
    pathOutline.addRectangle(x1,inset_PX,x2,height - inset_PX);
    xyBuffer.clear();
    xyBuffer.addQuad2f(x1,inset_PX,x2,height - inset_PX);
    sBuffer.clear();
    sBuffer.addQuad1f(0,1,0,1);
    GLUtils.enableStandardBlending(gl);
    try {
      progTex.begin(gl);
      try {
        progTex.setPixelOrtho(gl,bounds);
        progTex.draw(gl,colorTexture,xyBuffer,sBuffer);
      }
  finally {
        progTex.end(gl);
      }
      progOutline.begin(gl);
      try {
        progOutline.setPixelOrtho(gl,bounds);
        progOutline.setViewport(gl,bounds);
        progOutline.draw(gl,style,pathOutline);
      }
  finally {
        progOutline.end(gl);
      }
    }
  finally {
      GLUtils.disableBlending(gl);
    }
  }
}",0.9573283858998144
11381,"@Override protected void paintColorScale(GlimpseContext context){
  Axis1D axis=getAxis1D(context);
  if (colorTexture != null && axis instanceof TaggedAxis1D) {
    TaggedAxis1D taggedAxis=(TaggedAxis1D)axis;
    GlimpseBounds bounds=getBounds(context);
    GL3 gl=context.getGL().getGL3();
    int height=bounds.getHeight();
    int width=bounds.getWidth();
    int count=updateCoordinateBuffers(gl,taggedAxis,width,height);
    float y1=getColorBarMinY(height);
    float y2=getColorBarMaxY(height);
    pathOutline.clear();
    pathOutline.addRectangle(0.5f,y1,width,y2);
    GLUtils.enableStandardBlending(gl);
    try {
      if (count > 0) {
        progTex.begin(gl);
        try {
          progTex.setPixelOrtho(gl,bounds);
          progTex.draw(gl,GL_TRIANGLES,colorTexture,vertexCoords,textureCoords,0,count);
        }
  finally {
          progTex.end(gl);
        }
      }
      progOutline.begin(gl);
      try {
        progOutline.setPixelOrtho(gl,bounds);
        progOutline.setViewport(gl,bounds);
        progOutline.draw(gl,style,pathOutline);
      }
  finally {
        progOutline.end(gl);
      }
    }
  finally {
      gl.glDisable(GL.GL_BLEND);
    }
  }
}","@Override protected void paintColorScale(GlimpseContext context){
  Axis1D axis=getAxis1D(context);
  if (colorTexture != null && axis instanceof TaggedAxis1D) {
    TaggedAxis1D taggedAxis=(TaggedAxis1D)axis;
    GlimpseBounds bounds=getBounds(context);
    GL3 gl=context.getGL().getGL3();
    int height=bounds.getHeight();
    int width=bounds.getWidth();
    int count=updateCoordinateBuffers(gl,taggedAxis,width,height);
    float y1=getColorBarMinY(height);
    float y2=getColorBarMaxY(height);
    float inset_PX=0.5f * style.thickness_PX;
    pathOutline.clear();
    pathOutline.addRectangle(inset_PX,y1,width - inset_PX,y2);
    GLUtils.enableStandardBlending(gl);
    try {
      if (count > 0) {
        progTex.begin(gl);
        try {
          progTex.setPixelOrtho(gl,bounds);
          progTex.draw(gl,GL_TRIANGLES,colorTexture,vertexCoords,textureCoords,0,count);
        }
  finally {
          progTex.end(gl);
        }
      }
      progOutline.begin(gl);
      try {
        progOutline.setPixelOrtho(gl,bounds);
        progOutline.setViewport(gl,bounds);
        progOutline.draw(gl,style,pathOutline);
      }
  finally {
        progOutline.end(gl);
      }
    }
  finally {
      gl.glDisable(GL.GL_BLEND);
    }
  }
}",0.933935166187936
11382,"@Override protected void paintColorScale(GlimpseContext context){
  Axis1D axis=getAxis1D(context);
  if (colorTexture != null && axis instanceof TaggedAxis1D) {
    TaggedAxis1D taggedAxis=(TaggedAxis1D)axis;
    GlimpseBounds bounds=getBounds(context);
    GL3 gl=context.getGL().getGL3();
    int height=bounds.getHeight();
    int width=bounds.getWidth();
    int count=updateCoordinateBuffers(gl,taggedAxis,width,height);
    float x1=getColorBarMinX(width);
    float x2=getColorBarMaxX(width);
    pathOutline.clear();
    pathOutline.addRectangle(x1,0.5f,x2,height);
    GLUtils.enableStandardBlending(gl);
    try {
      if (count > 0) {
        progTex.begin(gl);
        try {
          progTex.setPixelOrtho(gl,bounds);
          progTex.draw(gl,GL_TRIANGLES,colorTexture,vertexCoords,textureCoords,0,count);
        }
  finally {
          progTex.end(gl);
        }
      }
      progOutline.begin(gl);
      try {
        progOutline.setPixelOrtho(gl,bounds);
        progOutline.setViewport(gl,bounds);
        progOutline.draw(gl,style,pathOutline);
      }
  finally {
        progOutline.end(gl);
      }
    }
  finally {
      gl.glDisable(GL.GL_BLEND);
    }
  }
}","@Override protected void paintColorScale(GlimpseContext context){
  Axis1D axis=getAxis1D(context);
  if (colorTexture != null && axis instanceof TaggedAxis1D) {
    TaggedAxis1D taggedAxis=(TaggedAxis1D)axis;
    GlimpseBounds bounds=getBounds(context);
    GL3 gl=context.getGL().getGL3();
    int height=bounds.getHeight();
    int width=bounds.getWidth();
    int count=updateCoordinateBuffers(gl,taggedAxis,width,height);
    float x1=getColorBarMinX(width);
    float x2=getColorBarMaxX(width);
    float inset_PX=0.5f * style.thickness_PX;
    pathOutline.clear();
    pathOutline.addRectangle(x1,inset_PX,x2,height - inset_PX);
    GLUtils.enableStandardBlending(gl);
    try {
      if (count > 0) {
        progTex.begin(gl);
        try {
          progTex.setPixelOrtho(gl,bounds);
          progTex.draw(gl,GL_TRIANGLES,colorTexture,vertexCoords,textureCoords,0,count);
        }
  finally {
          progTex.end(gl);
        }
      }
      progOutline.begin(gl);
      try {
        progOutline.setPixelOrtho(gl,bounds);
        progOutline.setViewport(gl,bounds);
        progOutline.draw(gl,style,pathOutline);
      }
  finally {
        progOutline.end(gl);
      }
    }
  finally {
      gl.glDisable(GL.GL_BLEND);
    }
  }
}",0.9314168377823407
11383,"public BorderPainter(){
  this.prog=new LineProgram();
  this.style=new LineStyle();
  this.style.feather_PX=0;
  this.style.stippleEnable=false;
  this.style.thickness_PX=1.0f;
  this.style.stipplePattern=(short)0x00FF;
  this.style.stippleScale=1;
  this.style.rgba=new float[]{0.5f,0.5f,0.5f,1.0f};
  this.path=new LinePath();
}","public BorderPainter(){
  this.prog=new LineProgram();
  this.style=new LineStyle();
  this.style.joinType=LineJoinType.JOIN_MITER;
  this.style.feather_PX=0;
  this.style.stippleEnable=false;
  this.style.thickness_PX=1.0f;
  this.style.stipplePattern=(short)0x00FF;
  this.style.stippleScale=1;
  this.style.rgba=new float[]{0.5f,0.5f,0.5f,1.0f};
  this.path=new LinePath();
}",0.933709449929478
11384,"@Override protected void doPaintTo(GlimpseContext context){
  GL3 gl=context.getGL().getGL3();
  GlimpseBounds bounds=getBounds(context);
  int x=bounds.getX();
  int y=bounds.getY();
  int width=bounds.getWidth();
  int height=bounds.getHeight();
  GLUtils.enableStandardBlending(gl);
  prog.begin(gl);
  try {
    prog.setPixelOrtho(gl,bounds);
    prog.setViewport(gl,bounds);
    path.clear();
    if (drawBottom) {
      path.moveTo(x,y);
      path.lineTo(x + width,y);
    }
    if (drawRight) {
      path.moveTo(x + width,y);
      path.lineTo(x + width,y + height);
    }
    if (drawTop) {
      path.moveTo(x + width,y + height);
      path.lineTo(x,y + height);
    }
    if (drawLeft) {
      path.moveTo(x,y + height);
      path.lineTo(x,y);
    }
    prog.draw(gl,style,path);
  }
  finally {
    prog.end(gl);
    GLUtils.disableBlending(gl);
  }
}","@Override protected void doPaintTo(GlimpseContext context){
  GL3 gl=context.getGL().getGL3();
  GlimpseBounds bounds=getBounds(context);
  float inset_PX=0.5f * style.thickness_PX;
  float x=inset_PX;
  float y=inset_PX;
  float width=bounds.getWidth() - 2 * inset_PX;
  float height=bounds.getHeight() - 2 * inset_PX;
  GLUtils.enableStandardBlending(gl);
  prog.begin(gl);
  try {
    prog.setPixelOrtho(gl,bounds);
    prog.setViewport(gl,bounds);
    path.clear();
    if (drawBottom) {
      path.moveTo(x,y);
      path.lineTo(x + width,y);
    }
    if (drawRight) {
      path.moveTo(x + width,y);
      path.lineTo(x + width,y + height);
    }
    if (drawTop) {
      path.moveTo(x + width,y + height);
      path.lineTo(x,y + height);
    }
    if (drawLeft) {
      path.moveTo(x,y + height);
      path.lineTo(x,y);
    }
    prog.draw(gl,style,path);
  }
  finally {
    prog.end(gl);
    GLUtils.disableBlending(gl);
  }
}",0.876940133037694
11385,"@Override public GlimpseLayout getLayout(){
  EmptyPlot2D plot=new EmptyPlot2D();
  plot.addPainter(new FpsPainter());
  return plot;
}","@Override public GlimpseLayout getLayout(){
  EmptyPlot2D plot=new EmptyPlot2D();
  plot.getAxis().set(0,500,0,500);
  plot.addPainter(new FillPainter());
  return plot;
}",0.869281045751634
11386,"protected void paintColorScale(GlimpseContext context){
  if (colorTexture != null) {
    GlimpseBounds bounds=getBounds(context);
    GL3 gl=context.getGL().getGL3();
    int height=bounds.getHeight();
    int width=bounds.getWidth();
    float y1=getColorBarMinY(height);
    float y2=getColorBarMaxY(height);
    pathOutline.clear();
    pathOutline.lineTo(0.5f,y2);
    pathOutline.lineTo(0.5f,y1);
    pathOutline.lineTo(width,y1);
    pathOutline.lineTo(width,y2);
    pathOutline.lineTo(0.5f,y2);
    xyBuffer.clear();
    xyBuffer.addQuad2f(0.5f,y1,width,y2);
    sBuffer.clear();
    sBuffer.addQuad1f(0,0,1,1);
    GLUtils.enableStandardBlending(gl);
    try {
      progTex.begin(gl);
      try {
        progTex.setPixelOrtho(gl,bounds);
        progTex.draw(gl,colorTexture,xyBuffer,sBuffer);
      }
  finally {
        progTex.end(gl);
      }
      progOutline.begin(gl);
      try {
        progOutline.setPixelOrtho(gl,bounds);
        progOutline.setViewport(gl,bounds);
        progOutline.draw(gl,style,pathOutline);
      }
  finally {
        progOutline.end(gl);
      }
    }
  finally {
      gl.glDisable(GL.GL_BLEND);
    }
  }
}","protected void paintColorScale(GlimpseContext context){
  if (colorTexture != null) {
    GlimpseBounds bounds=getBounds(context);
    GL3 gl=context.getGL().getGL3();
    int height=bounds.getHeight();
    int width=bounds.getWidth();
    float y1=getColorBarMinY(height);
    float y2=getColorBarMaxY(height);
    pathOutline.clear();
    pathOutline.addRectangle(0.5f,y1,width,y2);
    xyBuffer.clear();
    xyBuffer.addQuad2f(0.5f,y1,width,y2);
    sBuffer.clear();
    sBuffer.addQuad1f(0,0,1,1);
    GLUtils.enableStandardBlending(gl);
    try {
      progTex.begin(gl);
      try {
        progTex.setPixelOrtho(gl,bounds);
        progTex.draw(gl,colorTexture,xyBuffer,sBuffer);
      }
  finally {
        progTex.end(gl);
      }
      progOutline.begin(gl);
      try {
        progOutline.setPixelOrtho(gl,bounds);
        progOutline.setViewport(gl,bounds);
        progOutline.draw(gl,style,pathOutline);
      }
  finally {
        progOutline.end(gl);
      }
    }
  finally {
      gl.glDisable(GL.GL_BLEND);
    }
  }
}",0.9339407744874716
11387,"protected void paintColorScale(GlimpseContext context){
  if (colorTexture != null) {
    GlimpseBounds bounds=getBounds(context);
    GL3 gl=context.getGL().getGL3();
    int height=bounds.getHeight();
    int width=bounds.getWidth();
    float x1=getColorBarMinX(width);
    float x2=getColorBarMaxX(width);
    pathOutline.clear();
    pathOutline.lineTo(x2,0.5f);
    pathOutline.lineTo(x1,0.5f);
    pathOutline.lineTo(x1,height);
    pathOutline.lineTo(x2,height);
    pathOutline.lineTo(x2,0.5f);
    xyBuffer.clear();
    xyBuffer.addQuad2f(x1,0.5f,x2,height);
    sBuffer.clear();
    sBuffer.addQuad1f(0,1,0,1);
    GLUtils.enableStandardBlending(gl);
    try {
      progTex.begin(gl);
      try {
        progTex.setPixelOrtho(gl,bounds);
        progTex.draw(gl,colorTexture,xyBuffer,sBuffer);
      }
  finally {
        progTex.end(gl);
      }
      progOutline.begin(gl);
      try {
        progOutline.setPixelOrtho(gl,bounds);
        progOutline.setViewport(gl,bounds);
        progOutline.draw(gl,style,pathOutline);
      }
  finally {
        progOutline.end(gl);
      }
    }
  finally {
      gl.glDisable(GL.GL_BLEND);
    }
  }
}","protected void paintColorScale(GlimpseContext context){
  if (colorTexture != null) {
    GlimpseBounds bounds=getBounds(context);
    GL3 gl=context.getGL().getGL3();
    int height=bounds.getHeight();
    int width=bounds.getWidth();
    float x1=getColorBarMinX(width);
    float x2=getColorBarMaxX(width);
    pathOutline.clear();
    pathOutline.addRectangle(x1,0.5f,x2,height);
    xyBuffer.clear();
    xyBuffer.addQuad2f(x1,0.5f,x2,height);
    sBuffer.clear();
    sBuffer.addQuad1f(0,1,0,1);
    GLUtils.enableStandardBlending(gl);
    try {
      progTex.begin(gl);
      try {
        progTex.setPixelOrtho(gl,bounds);
        progTex.draw(gl,colorTexture,xyBuffer,sBuffer);
      }
  finally {
        progTex.end(gl);
      }
      progOutline.begin(gl);
      try {
        progOutline.setPixelOrtho(gl,bounds);
        progOutline.setViewport(gl,bounds);
        progOutline.draw(gl,style,pathOutline);
      }
  finally {
        progOutline.end(gl);
      }
    }
  finally {
      gl.glDisable(GL.GL_BLEND);
    }
  }
}",0.9207650273224044
11388,"@Override protected void paintColorScale(GlimpseContext context){
  Axis1D axis=getAxis1D(context);
  if (colorTexture != null && axis instanceof TaggedAxis1D) {
    TaggedAxis1D taggedAxis=(TaggedAxis1D)axis;
    GlimpseBounds bounds=getBounds(context);
    GL3 gl=context.getGL().getGL3();
    int height=bounds.getHeight();
    int width=bounds.getWidth();
    int count=updateCoordinateBuffers(gl,taggedAxis,width,height);
    float y1=getColorBarMinY(height);
    float y2=getColorBarMaxY(height);
    pathOutline.clear();
    pathOutline.lineTo(0.5f,y2);
    pathOutline.lineTo(0.5f,y1);
    pathOutline.lineTo(width,y1);
    pathOutline.lineTo(width,y2);
    pathOutline.lineTo(0.5f,y2);
    GLUtils.enableStandardBlending(gl);
    try {
      if (count > 0) {
        progTex.begin(gl);
        try {
          progTex.setPixelOrtho(gl,bounds);
          progTex.draw(gl,GL_TRIANGLES,colorTexture,vertexCoords,textureCoords,0,count);
        }
  finally {
          progTex.end(gl);
        }
      }
      progOutline.begin(gl);
      try {
        progOutline.setPixelOrtho(gl,bounds);
        progOutline.setViewport(gl,bounds);
        progOutline.draw(gl,style,pathOutline);
      }
  finally {
        progOutline.end(gl);
      }
    }
  finally {
      gl.glDisable(GL.GL_BLEND);
    }
  }
}","@Override protected void paintColorScale(GlimpseContext context){
  Axis1D axis=getAxis1D(context);
  if (colorTexture != null && axis instanceof TaggedAxis1D) {
    TaggedAxis1D taggedAxis=(TaggedAxis1D)axis;
    GlimpseBounds bounds=getBounds(context);
    GL3 gl=context.getGL().getGL3();
    int height=bounds.getHeight();
    int width=bounds.getWidth();
    int count=updateCoordinateBuffers(gl,taggedAxis,width,height);
    float y1=getColorBarMinY(height);
    float y2=getColorBarMaxY(height);
    pathOutline.clear();
    pathOutline.addRectangle(0.5f,y1,width,y2);
    GLUtils.enableStandardBlending(gl);
    try {
      if (count > 0) {
        progTex.begin(gl);
        try {
          progTex.setPixelOrtho(gl,bounds);
          progTex.draw(gl,GL_TRIANGLES,colorTexture,vertexCoords,textureCoords,0,count);
        }
  finally {
          progTex.end(gl);
        }
      }
      progOutline.begin(gl);
      try {
        progOutline.setPixelOrtho(gl,bounds);
        progOutline.setViewport(gl,bounds);
        progOutline.draw(gl,style,pathOutline);
      }
  finally {
        progOutline.end(gl);
      }
    }
  finally {
      gl.glDisable(GL.GL_BLEND);
    }
  }
}",0.9418837675350702
11389,"@Override protected void paintColorScale(GlimpseContext context){
  Axis1D axis=getAxis1D(context);
  if (colorTexture != null && axis instanceof TaggedAxis1D) {
    TaggedAxis1D taggedAxis=(TaggedAxis1D)axis;
    GlimpseBounds bounds=getBounds(context);
    GL3 gl=context.getGL().getGL3();
    int height=bounds.getHeight();
    int width=bounds.getWidth();
    int count=updateCoordinateBuffers(gl,taggedAxis,width,height);
    float x1=getColorBarMinX(width);
    float x2=getColorBarMaxX(width);
    pathOutline.clear();
    pathOutline.lineTo(x2,0.5f);
    pathOutline.lineTo(x1,0.5f);
    pathOutline.lineTo(x1,height);
    pathOutline.lineTo(x2,height);
    pathOutline.lineTo(x2,0.5f);
    GLUtils.enableStandardBlending(gl);
    try {
      if (count > 0) {
        progTex.begin(gl);
        try {
          progTex.setPixelOrtho(gl,bounds);
          progTex.draw(gl,GL_TRIANGLES,colorTexture,vertexCoords,textureCoords,0,count);
        }
  finally {
          progTex.end(gl);
        }
      }
      progOutline.begin(gl);
      try {
        progOutline.setPixelOrtho(gl,bounds);
        progOutline.setViewport(gl,bounds);
        progOutline.draw(gl,style,pathOutline);
      }
  finally {
        progOutline.end(gl);
      }
    }
  finally {
      gl.glDisable(GL.GL_BLEND);
    }
  }
}","@Override protected void paintColorScale(GlimpseContext context){
  Axis1D axis=getAxis1D(context);
  if (colorTexture != null && axis instanceof TaggedAxis1D) {
    TaggedAxis1D taggedAxis=(TaggedAxis1D)axis;
    GlimpseBounds bounds=getBounds(context);
    GL3 gl=context.getGL().getGL3();
    int height=bounds.getHeight();
    int width=bounds.getWidth();
    int count=updateCoordinateBuffers(gl,taggedAxis,width,height);
    float x1=getColorBarMinX(width);
    float x2=getColorBarMaxX(width);
    pathOutline.clear();
    pathOutline.addRectangle(x1,0.5f,x2,height);
    GLUtils.enableStandardBlending(gl);
    try {
      if (count > 0) {
        progTex.begin(gl);
        try {
          progTex.setPixelOrtho(gl,bounds);
          progTex.draw(gl,GL_TRIANGLES,colorTexture,vertexCoords,textureCoords,0,count);
        }
  finally {
          progTex.end(gl);
        }
      }
      progOutline.begin(gl);
      try {
        progOutline.setPixelOrtho(gl,bounds);
        progOutline.setViewport(gl,bounds);
        progOutline.draw(gl,style,pathOutline);
      }
  finally {
        progOutline.end(gl);
      }
    }
  finally {
      gl.glDisable(GL.GL_BLEND);
    }
  }
}",0.9390537289494788
11390,"@Override public GlimpseLayout getLayout(){
}","@Override public GlimpseLayout getLayout(){
  EmptyPlot2D plot=new EmptyPlot2D();
  GlimpseAxisLayoutY layoutY=new GlimpseAxisLayoutY();
  TaggedPartialColorYAxisPainter painter=new TaggedPartialColorYAxisPainter(new GridAxisLabelHandler());
  TaggedAxis1D axis=new TaggedAxis1D();
  axis.addTag(""String_Node_Str"",0.0).setAttribute(Tag.TEX_COORD_ATTR,0.0f);
  axis.addTag(""String_Node_Str"",1.0).setAttribute(Tag.TEX_COORD_ATTR,0.9f);
  axis.addTag(""String_Node_Str"",2.0).setAttribute(Tag.TEX_COORD_ATTR,1.0f).setAttribute(Tag.TAG_COLOR_ATTR,GlimpseColor.getRed());
  layoutY.setAxis(axis);
  ColorTexture1D texture=new ColorTexture1D(1024);
  texture.setColorGradient(ColorGradients.prism);
  painter.setColorScale(texture);
  layoutY.addGlimpseMouseAllListener(new TaggedAxisMouseListener1D());
  layoutY.addPainter(painter);
  plot.addLayout(layoutY);
  plot.addPainter(new FillPainter());
  return plot;
}",0.0944386149003148
11391,"protected void paintColorScale(GlimpseContext context){
  if (colorTexture != null) {
    GlimpseBounds bounds=getBounds(context);
    GL3 gl=context.getGL().getGL3();
    int height=bounds.getHeight();
    int width=bounds.getWidth();
    float y1=getColorBarMinY(height);
    float y2=getColorBarMaxY(height);
    pathOutline.clear();
    pathOutline.addRectangle(0.5f,y1,width,y2);
    xyBuffer.clear();
    xyBuffer.addQuad2f(0.5f,y1,width,y2);
    sBuffer.clear();
    sBuffer.addQuad1f(0,0,1,1);
    GLUtils.enableStandardBlending(gl);
    try {
      progTex.begin(gl);
      try {
        progTex.setPixelOrtho(gl,bounds);
        progTex.draw(gl,colorTexture,xyBuffer,sBuffer);
      }
  finally {
        progTex.end(gl);
      }
      progOutline.begin(gl);
      try {
        progOutline.setPixelOrtho(gl,bounds);
        progOutline.setViewport(gl,bounds);
        progOutline.draw(gl,style,pathOutline);
      }
  finally {
        progOutline.end(gl);
      }
    }
  finally {
      gl.glDisable(GL.GL_BLEND);
    }
  }
}","protected void paintColorScale(GlimpseContext context){
  if (colorTexture != null) {
    GlimpseBounds bounds=getBounds(context);
    GL3 gl=context.getGL().getGL3();
    int height=bounds.getHeight();
    int width=bounds.getWidth();
    float y1=getColorBarMinY(height);
    float y2=getColorBarMaxY(height);
    pathOutline.clear();
    pathOutline.addRectangle(0.5f,y1,width,y2);
    xyBuffer.clear();
    xyBuffer.addQuad2f(0.5f,y1,width,y2);
    sBuffer.clear();
    sBuffer.addQuad1f(0,0,1,1);
    GLUtils.enableStandardBlending(gl);
    try {
      progTex.begin(gl);
      try {
        progTex.setPixelOrtho(gl,bounds);
        progTex.draw(gl,colorTexture,xyBuffer,sBuffer);
      }
  finally {
        progTex.end(gl);
      }
      progOutline.begin(gl);
      try {
        progOutline.setPixelOrtho(gl,bounds);
        progOutline.setViewport(gl,bounds);
        progOutline.draw(gl,style,pathOutline);
      }
  finally {
        progOutline.end(gl);
      }
    }
  finally {
      GLUtils.disableBlending(gl);
    }
  }
}",0.9778633301251204
11392,"protected void paintColorScale(GlimpseContext context){
  if (colorTexture != null) {
    GlimpseBounds bounds=getBounds(context);
    GL3 gl=context.getGL().getGL3();
    int height=bounds.getHeight();
    int width=bounds.getWidth();
    float x1=getColorBarMinX(width);
    float x2=getColorBarMaxX(width);
    pathOutline.clear();
    pathOutline.addRectangle(x1,0.5f,x2,height);
    xyBuffer.clear();
    xyBuffer.addQuad2f(x1,0.5f,x2,height);
    sBuffer.clear();
    sBuffer.addQuad1f(0,1,0,1);
    GLUtils.enableStandardBlending(gl);
    try {
      progTex.begin(gl);
      try {
        progTex.setPixelOrtho(gl,bounds);
        progTex.draw(gl,colorTexture,xyBuffer,sBuffer);
      }
  finally {
        progTex.end(gl);
      }
      progOutline.begin(gl);
      try {
        progOutline.setPixelOrtho(gl,bounds);
        progOutline.setViewport(gl,bounds);
        progOutline.draw(gl,style,pathOutline);
      }
  finally {
        progOutline.end(gl);
      }
    }
  finally {
      gl.glDisable(GL.GL_BLEND);
    }
  }
}","protected void paintColorScale(GlimpseContext context){
  if (colorTexture != null) {
    GlimpseBounds bounds=getBounds(context);
    GL3 gl=context.getGL().getGL3();
    int height=bounds.getHeight();
    int width=bounds.getWidth();
    float x1=getColorBarMinX(width);
    float x2=getColorBarMaxX(width);
    pathOutline.clear();
    pathOutline.addRectangle(x1,0.5f,x2,height);
    xyBuffer.clear();
    xyBuffer.addQuad2f(x1,0.5f,x2,height);
    sBuffer.clear();
    sBuffer.addQuad1f(0,1,0,1);
    GLUtils.enableStandardBlending(gl);
    try {
      progTex.begin(gl);
      try {
        progTex.setPixelOrtho(gl,bounds);
        progTex.draw(gl,colorTexture,xyBuffer,sBuffer);
      }
  finally {
        progTex.end(gl);
      }
      progOutline.begin(gl);
      try {
        progOutline.setPixelOrtho(gl,bounds);
        progOutline.setViewport(gl,bounds);
        progOutline.draw(gl,style,pathOutline);
      }
  finally {
        progOutline.end(gl);
      }
    }
  finally {
      GLUtils.disableBlending(gl);
    }
  }
}",0.9778633301251204
11393,"protected void paintTag(GL gl,Tag tag,TaggedAxis1D taggedAxis,GlimpseBounds bounds){
  int height=bounds.getHeight();
  int x=taggedAxis.valueToScreenPixel(tag.getValue());
  int yMin=getTagMinY(height);
  int yMid=getTagPointerMaxY(height);
  int yMax=getTagMaxY(height);
  float[] color=tagColor;
  Object colorValue=tag.getAttribute(Tag.TAG_COLOR_ATTR);
  if (colorValue != null && colorValue instanceof float[]) {
    color=(float[])colorValue;
  }
  GL3 gl3=gl.getGL3();
  FloatBuffer xy=tagXyVbo.mapFloats(gl,18);
  xy.put(x).put(yMin);
  xy.put(x - tagHalfWidth).put(yMid);
  xy.put(x + tagHalfWidth).put(yMid);
  xy.put(x - tagHalfWidth).put(yMax);
  xy.put(x - tagHalfWidth).put(yMid);
  xy.put(x + tagHalfWidth).put(yMid);
  xy.put(x + tagHalfWidth).put(yMid);
  xy.put(x + tagHalfWidth).put(yMax);
  xy.put(x - tagHalfWidth).put(yMax);
  tagXyVbo.seal(gl);
  GLUtils.enableStandardBlending(gl);
  flatColorProg.begin(gl3);
  try {
    flatColorProg.setPixelOrtho(gl3,bounds);
    flatColorProg.setColor(gl3,color[0],color[1],color[2],0.3f);
    flatColorProg.draw(gl3,GL.GL_TRIANGLES,tagXyVbo,0,9);
  }
  finally {
    flatColorProg.end(gl3);
    gl.glDisable(GL.GL_BLEND);
  }
  tagStyle.rgba=color;
  tagStyle.thickness_PX=tagPointerOutlineWidth;
  pathOutline.clear();
  pathOutline.moveTo(x,yMin);
  pathOutline.lineTo(x + tagHalfWidth,yMid);
  pathOutline.lineTo(x + tagHalfWidth,yMax);
  pathOutline.lineTo(x - tagHalfWidth,yMax);
  pathOutline.lineTo(x - tagHalfWidth,yMid);
  pathOutline.lineTo(x,yMin);
  progOutline.begin(gl3);
  try {
    progOutline.setPixelOrtho(gl3,bounds);
    progOutline.setViewport(gl3,bounds);
    progOutline.draw(gl3,tagStyle,pathOutline);
  }
  finally {
    progOutline.end(gl3);
  }
}","protected void paintTag(GL gl,Tag tag,TaggedAxis1D taggedAxis,GlimpseBounds bounds){
  int height=bounds.getHeight();
  int x=taggedAxis.valueToScreenPixel(tag.getValue());
  int yMin=getTagMinY(height);
  int yMid=getTagPointerMaxY(height);
  int yMax=getTagMaxY(height);
  float[] color=tagColor;
  Object colorValue=tag.getAttribute(Tag.TAG_COLOR_ATTR);
  if (colorValue != null && colorValue instanceof float[]) {
    color=(float[])colorValue;
  }
  GL3 gl3=gl.getGL3();
  FloatBuffer xy=tagXyVbo.mapFloats(gl,18);
  xy.put(x).put(yMin);
  xy.put(x - tagHalfWidth).put(yMid);
  xy.put(x + tagHalfWidth).put(yMid);
  xy.put(x - tagHalfWidth).put(yMax);
  xy.put(x - tagHalfWidth).put(yMid);
  xy.put(x + tagHalfWidth).put(yMid);
  xy.put(x + tagHalfWidth).put(yMid);
  xy.put(x + tagHalfWidth).put(yMax);
  xy.put(x - tagHalfWidth).put(yMax);
  tagXyVbo.seal(gl);
  GLUtils.enableStandardBlending(gl);
  flatColorProg.begin(gl3);
  try {
    flatColorProg.setPixelOrtho(gl3,bounds);
    flatColorProg.setColor(gl3,color[0],color[1],color[2],0.3f);
    flatColorProg.draw(gl3,GL.GL_TRIANGLES,tagXyVbo,0,9);
  }
  finally {
    flatColorProg.end(gl3);
    gl.glDisable(GL.GL_BLEND);
  }
  tagStyle.rgba=color;
  tagStyle.thickness_PX=tagPointerOutlineWidth;
  pathOutline.clear();
  pathOutline.moveTo(x,yMin);
  pathOutline.lineTo(x + tagHalfWidth,yMid);
  pathOutline.lineTo(x + tagHalfWidth,yMax);
  pathOutline.lineTo(x - tagHalfWidth,yMax);
  pathOutline.lineTo(x - tagHalfWidth,yMid);
  pathOutline.closeLoop();
  progOutline.begin(gl3);
  try {
    progOutline.setPixelOrtho(gl3,bounds);
    progOutline.setViewport(gl3,bounds);
    progOutline.draw(gl3,tagStyle,pathOutline);
  }
  finally {
    progOutline.end(gl3);
  }
}",0.9933698472182184
11394,"public TaggedColorYAxisPainter(AxisLabelHandler ticks){
  super(ticks);
  this.tickBufferSize=10;
  this.tagXyVbo=new GLStreamingBuffer(GL_ARRAY_BUFFER,GL_DYNAMIC_DRAW,2);
  this.setTagColor0(GlimpseColor.fromColorRgba(0.0f,0.0f,0.0f,0.2f));
  this.tagStyle=new LineStyle();
  this.tagStyle.stippleEnable=false;
  this.tagStyle.feather_PX=0.0f;
}","public TaggedColorYAxisPainter(AxisLabelHandler ticks){
  super(ticks);
  this.tickBufferSize=10;
  this.tagXyVbo=new GLStreamingBuffer(GL_ARRAY_BUFFER,GL_DYNAMIC_DRAW,2);
  this.setTagColor0(GlimpseColor.fromColorRgba(0.0f,0.0f,0.0f,0.2f));
  this.tagStyle=new LineStyle();
  this.tagStyle.stippleEnable=false;
  this.tagStyle.feather_PX=0.9f;
}",0.9971098265895952
11395,"protected void paintTag(GL gl,Tag tag,TaggedAxis1D taggedAxis,GlimpseBounds bounds){
  int width=bounds.getWidth();
  int y=taggedAxis.valueToScreenPixel(tag.getValue());
  int xMin=getTagMinX(width);
  int xMid=getTagPointerMaxX(width);
  int xMax=getTagMaxX(width);
  float[] color=tagColor;
  Object colorValue=tag.getAttribute(Tag.TAG_COLOR_ATTR);
  if (colorValue != null && colorValue instanceof float[]) {
    color=(float[])colorValue;
  }
  GL3 gl3=gl.getGL3();
  FloatBuffer xy=tagXyVbo.mapFloats(gl,18);
  xy.put(xMin).put(y);
  xy.put(xMid).put(y - tagHalfWidth);
  xy.put(xMid).put(y + tagHalfWidth);
  xy.put(xMax).put(y - tagHalfWidth);
  xy.put(xMid).put(y - tagHalfWidth);
  xy.put(xMid).put(y + tagHalfWidth);
  xy.put(xMid).put(y + tagHalfWidth);
  xy.put(xMax).put(y + tagHalfWidth);
  xy.put(xMax).put(y - tagHalfWidth);
  tagXyVbo.seal(gl);
  GLUtils.enableStandardBlending(gl);
  flatColorProg.begin(gl3);
  try {
    flatColorProg.setPixelOrtho(gl3,bounds);
    flatColorProg.setColor(gl3,color[0],color[1],color[2],0.3f);
    flatColorProg.draw(gl3,GL.GL_TRIANGLES,tagXyVbo,0,9);
  }
  finally {
    flatColorProg.end(gl3);
    gl.glDisable(GL.GL_BLEND);
  }
  tagStyle.rgba=color;
  tagStyle.thickness_PX=tagPointerOutlineWidth;
  pathOutline.clear();
  pathOutline.moveTo(xMin,y);
  pathOutline.lineTo(xMid,y + tagHalfWidth);
  pathOutline.lineTo(xMax,y + tagHalfWidth);
  pathOutline.lineTo(xMax,y - tagHalfWidth);
  pathOutline.lineTo(xMid,y - tagHalfWidth);
  pathOutline.lineTo(xMin,y);
  progOutline.begin(gl3);
  try {
    progOutline.draw(gl3,tagStyle,pathOutline);
  }
  finally {
    progOutline.end(gl3);
  }
}","protected void paintTag(GL gl,Tag tag,TaggedAxis1D taggedAxis,GlimpseBounds bounds){
  int width=bounds.getWidth();
  int y=taggedAxis.valueToScreenPixel(tag.getValue());
  int xMin=getTagMinX(width);
  int xMid=getTagPointerMaxX(width);
  int xMax=getTagMaxX(width);
  float[] color=tagColor;
  Object colorValue=tag.getAttribute(Tag.TAG_COLOR_ATTR);
  if (colorValue != null && colorValue instanceof float[]) {
    color=(float[])colorValue;
  }
  GL3 gl3=gl.getGL3();
  FloatBuffer xy=tagXyVbo.mapFloats(gl,18);
  xy.put(xMin).put(y);
  xy.put(xMid).put(y - tagHalfWidth);
  xy.put(xMid).put(y + tagHalfWidth);
  xy.put(xMax).put(y - tagHalfWidth);
  xy.put(xMid).put(y - tagHalfWidth);
  xy.put(xMid).put(y + tagHalfWidth);
  xy.put(xMid).put(y + tagHalfWidth);
  xy.put(xMax).put(y + tagHalfWidth);
  xy.put(xMax).put(y - tagHalfWidth);
  tagXyVbo.seal(gl);
  GLUtils.enableStandardBlending(gl);
  try {
    flatColorProg.begin(gl3);
    try {
      flatColorProg.setPixelOrtho(gl3,bounds);
      flatColorProg.setColor(gl3,color[0],color[1],color[2],0.3f);
      flatColorProg.draw(gl3,GL.GL_TRIANGLES,tagXyVbo,0,9);
    }
  finally {
      flatColorProg.end(gl3);
    }
    tagStyle.rgba=color;
    tagStyle.rgba[3]=1.0f;
    tagStyle.thickness_PX=tagPointerOutlineWidth;
    pathOutline.clear();
    pathOutline.moveTo(xMin,y);
    pathOutline.lineTo(xMid,y + tagHalfWidth);
    pathOutline.lineTo(xMax,y + tagHalfWidth);
    pathOutline.lineTo(xMax,y - tagHalfWidth);
    pathOutline.lineTo(xMid,y - tagHalfWidth);
    pathOutline.closeLoop();
    progOutline.begin(gl3);
    try {
      progOutline.setPixelOrtho(gl3,bounds);
      progOutline.setViewport(gl3,bounds);
      progOutline.draw(gl3,tagStyle,pathOutline);
    }
  finally {
      progOutline.end(gl3);
    }
  }
  finally {
    GLUtils.disableBlending(gl3);
  }
}",0.9181739879414298
11396,"@Override public StackedTimePlot2D getLayout(){
  StackedTimePlot2D plot=createPlot();
  plot.getDefaultTimeline().setTimeZone(TimeZone.getDefault());
  Epoch epoch=plot.getEpoch();
  TimeStamp selectionMaxTime=epoch.getTimeStamp();
  TimeStamp selectionMinTime=selectionMaxTime.subtract(Time.fromHours(3));
  TimeStamp axisMaxTime=selectionMaxTime.add(Time.fromHours(1));
  TimeStamp axisMinTime=selectionMaxTime.subtract(Time.fromHours(20));
  plot.setTimeSelection(selectionMinTime,selectionMaxTime);
  plot.setTimeAxisBounds(axisMinTime,axisMaxTime);
  plot.setPlotSpacing(2);
  plot.setBorderSize(4);
  TimePlotInfo plot1=plot.createTimePlot(""String_Node_Str"");
  TimePlotInfo plot2=plot.createTimePlot(""String_Node_Str"");
  plot1.setLabelText(""String_Node_Str"");
  plot2.setLabelText(""String_Node_Str"");
  plot.setLabelSize(30);
  plot.setShowLabels(true);
  plot1.getLabelPainter().setHorizontalLabels(false);
  plot2.getLabelPainter().setHorizontalLabels(false);
  setChartData(plot1,epoch,axisMinTime,axisMaxTime);
  setChartData(plot2,epoch,axisMinTime,axisMaxTime);
  addMouseListener(epoch,plot1);
  addMouseListener(epoch,plot2);
  return plot;
}","@Override public StackedTimePlot2D getLayout(){
  StackedTimePlot2D plot=createPlot();
  plot.getDefaultTimeline().setTimeZone(TimeZone.getDefault());
  Epoch epoch=plot.getEpoch();
  TimeStamp selectionMinTime=epoch.getTimeStamp();
  TimeStamp selectionMaxTime=selectionMinTime.add(Time.fromHours(3));
  TimeStamp axisMinTime=selectionMinTime;
  TimeStamp axisMaxTime=selectionMaxTime.add(Time.fromHours(20));
  plot.setTimeSelection(selectionMinTime,selectionMaxTime);
  plot.setTimeAxisBounds(axisMinTime,axisMaxTime);
  plot.setPlotSpacing(2);
  plot.setBorderSize(4);
  TimePlotInfo plot1=plot.createTimePlot(""String_Node_Str"");
  TimePlotInfo plot2=plot.createTimePlot(""String_Node_Str"");
  plot1.setLabelText(""String_Node_Str"");
  plot2.setLabelText(""String_Node_Str"");
  plot.setLabelSize(30);
  plot.setShowLabels(true);
  plot1.getLabelPainter().setHorizontalLabels(false);
  plot2.getLabelPainter().setHorizontalLabels(false);
  setChartData(plot1,epoch,axisMinTime,axisMaxTime);
  setChartData(plot2,epoch,axisMinTime,axisMaxTime);
  addMouseListener(epoch,plot1);
  addMouseListener(epoch,plot2);
  return plot;
}",0.9347921225382932
11397,"@Override public StackedTimePlot2D getLayout(){
  StackedTimePlot2D plot=super.getLayout();
  final RelativeTimeAxisLabelHandler handler=new RelativeTimeAxisLabelHandler(plot.getEpoch().getTimeStamp().subtract(Time.fromDays(20)));
  plot.setTimeAxisLabelHandler(handler);
  new Thread(){
    @Override public void run(){
      while (true) {
        handler.setReferenceTime(handler.getReferenceTime().add(Time.fromSeconds(10)));
        try {
          Thread.sleep(10);
        }
 catch (        InterruptedException e) {
          e.printStackTrace();
        }
      }
    }
  }
.start();
  plot.setPlotSpacing(20);
  for (  TimePlotInfo info : plot.getAllTimePlots()) {
    info.getLabelPainter().setHorizontalLabels(true);
  }
  return plot;
}","@Override public StackedTimePlot2D getLayout(){
  StackedTimePlot2D plot=super.getLayout();
  final RelativeTimeAxisLabelHandler handler=new RelativeTimeAxisLabelHandler(plot.getEpoch().getTimeStamp().add(-Time.fromHours(100)));
  plot.setTimeAxisLabelHandler(handler);
  plot.setPlotSpacing(20);
  for (  TimePlotInfo info : plot.getAllTimePlots()) {
    info.getLabelPainter().setHorizontalLabels(true);
  }
  return plot;
}",0.3659574468085106
11398,"protected TimeStampFormat getTickFormat(double tickInterval,final TimeStamp referenceTime){
  if (tickInterval <= Time.fromMinutes(1)) {
    return new TimeStampFormat(){
      @Override public BigDecimal parse(      String string) throws TimeStampParseException {
        throw new UnsupportedOperationException();
      }
      @Override public String format(      BigDecimal posixSeconds){
        double elapsedTime_SU=posixSeconds.doubleValue() - referenceTime.toPosixSeconds();
        double elapsedTime_DAYS=Time.toDays(elapsedTime_SU);
        int elapsedTime_DAYS_WHOLE=(int)Math.floor(elapsedTime_DAYS);
        double elapsedTime_HOURS=(elapsedTime_DAYS - elapsedTime_DAYS_WHOLE) * 24;
        int elapsedTime_HOURS_WHOLE=(int)Math.floor(elapsedTime_HOURS);
        double elapsedTime_MIN=(elapsedTime_HOURS - elapsedTime_HOURS_WHOLE) * 60;
        int elapsedTime_MIN_WHOLE=(int)Math.floor(elapsedTime_MIN);
        double elapsedTime_SEC=(elapsedTime_MIN - elapsedTime_MIN_WHOLE) * 60;
        int elapsedTime_SEC_WHOLE=(int)Math.round(elapsedTime_SEC);
        if (elapsedTime_SEC_WHOLE >= 60) {
          elapsedTime_SEC_WHOLE-=60;
          elapsedTime_MIN_WHOLE+=1;
        }
        String min=elapsedTime_MIN_WHOLE < 10 ? ""String_Node_Str"" + elapsedTime_MIN_WHOLE : ""String_Node_Str"" + elapsedTime_MIN_WHOLE;
        String sec=elapsedTime_SEC_WHOLE < 10 ? ""String_Node_Str"" + elapsedTime_SEC_WHOLE : ""String_Node_Str"" + elapsedTime_SEC_WHOLE;
        return min + ':' + sec;
      }
    }
;
  }
 else   if (tickInterval <= Time.fromHours(12)) {
    return new TimeStampFormat(){
      @Override public BigDecimal parse(      String string) throws TimeStampParseException {
        throw new UnsupportedOperationException();
      }
      @Override public String format(      BigDecimal posixSeconds){
        double elapsedTime_SU=posixSeconds.doubleValue() - referenceTime.toPosixSeconds();
        double elapsedTime_DAYS=Time.toDays(elapsedTime_SU);
        int elapsedTime_DAYS_WHOLE=(int)Math.floor(elapsedTime_DAYS);
        double elapsedTime_HOURS=(elapsedTime_DAYS - elapsedTime_DAYS_WHOLE) * 24;
        int elapsedTime_HOURS_WHOLE=(int)Math.floor(elapsedTime_HOURS);
        double elapsedTime_MIN=(elapsedTime_HOURS - elapsedTime_HOURS_WHOLE) * 60;
        int elapsedTime_MIN_WHOLE=(int)Math.round(elapsedTime_MIN);
        if (elapsedTime_MIN_WHOLE >= 60) {
          elapsedTime_MIN_WHOLE-=60;
          elapsedTime_HOURS_WHOLE+=1;
        }
        String hour=elapsedTime_HOURS_WHOLE < 10 ? ""String_Node_Str"" + elapsedTime_HOURS_WHOLE : ""String_Node_Str"" + elapsedTime_HOURS_WHOLE;
        String min=elapsedTime_MIN_WHOLE < 10 ? ""String_Node_Str"" + elapsedTime_MIN_WHOLE : ""String_Node_Str"" + elapsedTime_MIN_WHOLE;
        return hour + ':' + min;
      }
    }
;
  }
 else {
    return new TimeStampFormat(){
      @Override public BigDecimal parse(      String string) throws TimeStampParseException {
        throw new UnsupportedOperationException();
      }
      @Override public String format(      BigDecimal posixSeconds){
        double elapsedTime_SU=posixSeconds.doubleValue() - referenceTime.toPosixSeconds();
        int elapsedTime_DAYS=(int)Math.floor(Time.toDays(elapsedTime_SU));
        return ""String_Node_Str"" + elapsedTime_DAYS;
      }
    }
;
  }
}","protected TimeStampFormat getTickFormat(double tickInterval,final TimeStamp referenceTime){
  if (tickInterval <= Time.fromMinutes(1)) {
    return new TimeStampFormat(){
      @Override public BigDecimal parse(      String string) throws TimeStampParseException {
        throw new UnsupportedOperationException();
      }
      @Override public String format(      BigDecimal posixSeconds){
        double elapsedTime_SU=Math.abs(posixSeconds.doubleValue() - referenceTime.toPosixSeconds());
        double elapsedTime_DAYS=Time.toDays(elapsedTime_SU);
        int elapsedTime_DAYS_WHOLE=(int)Math.floor(elapsedTime_DAYS);
        double elapsedTime_HOURS=(elapsedTime_DAYS - elapsedTime_DAYS_WHOLE) * 24;
        int elapsedTime_HOURS_WHOLE=(int)Math.floor(elapsedTime_HOURS);
        double elapsedTime_MIN=(elapsedTime_HOURS - elapsedTime_HOURS_WHOLE) * 60;
        int elapsedTime_MIN_WHOLE=(int)Math.floor(elapsedTime_MIN);
        double elapsedTime_SEC=(elapsedTime_MIN - elapsedTime_MIN_WHOLE) * 60;
        int elapsedTime_SEC_WHOLE=(int)Math.round(elapsedTime_SEC);
        if (elapsedTime_SEC_WHOLE >= 60) {
          elapsedTime_SEC_WHOLE-=60;
          elapsedTime_MIN_WHOLE+=1;
        }
        if (elapsedTime_MIN_WHOLE >= 60) {
          elapsedTime_HOURS_WHOLE=0;
        }
        String min=elapsedTime_MIN_WHOLE < 10 ? ""String_Node_Str"" + elapsedTime_MIN_WHOLE : ""String_Node_Str"" + elapsedTime_MIN_WHOLE;
        String sec=elapsedTime_SEC_WHOLE < 10 ? ""String_Node_Str"" + elapsedTime_SEC_WHOLE : ""String_Node_Str"" + elapsedTime_SEC_WHOLE;
        return min + ':' + sec;
      }
    }
;
  }
 else   if (tickInterval <= Time.fromHours(12)) {
    return new TimeStampFormat(){
      @Override public BigDecimal parse(      String string) throws TimeStampParseException {
        throw new UnsupportedOperationException();
      }
      @Override public String format(      BigDecimal posixSeconds){
        double elapsedTime_SU=Math.abs(posixSeconds.doubleValue() - referenceTime.toPosixSeconds());
        double elapsedTime_DAYS=Time.toDays(elapsedTime_SU);
        int elapsedTime_DAYS_WHOLE=(int)Math.floor(elapsedTime_DAYS);
        double elapsedTime_HOURS=(elapsedTime_DAYS - elapsedTime_DAYS_WHOLE) * 24;
        int elapsedTime_HOURS_WHOLE=(int)Math.floor(elapsedTime_HOURS);
        double elapsedTime_MIN=(elapsedTime_HOURS - elapsedTime_HOURS_WHOLE) * 60;
        int elapsedTime_MIN_WHOLE=(int)Math.round(elapsedTime_MIN);
        if (elapsedTime_MIN_WHOLE >= 60) {
          elapsedTime_MIN_WHOLE-=60;
          elapsedTime_HOURS_WHOLE+=1;
        }
        if (elapsedTime_HOURS_WHOLE >= 24) {
          elapsedTime_HOURS_WHOLE=0;
        }
        String hour=elapsedTime_HOURS_WHOLE < 10 ? ""String_Node_Str"" + elapsedTime_HOURS_WHOLE : ""String_Node_Str"" + elapsedTime_HOURS_WHOLE;
        String min=elapsedTime_MIN_WHOLE < 10 ? ""String_Node_Str"" + elapsedTime_MIN_WHOLE : ""String_Node_Str"" + elapsedTime_MIN_WHOLE;
        return hour + ':' + min;
      }
    }
;
  }
 else {
    return new TimeStampFormat(){
      @Override public BigDecimal parse(      String string) throws TimeStampParseException {
        throw new UnsupportedOperationException();
      }
      @Override public String format(      BigDecimal posixSeconds){
        double elapsedTime_SU=posixSeconds.doubleValue() - referenceTime.toPosixSeconds();
        int elapsedTime_DAYS=(int)Math.floor(Time.toDays(elapsedTime_SU));
        return ""String_Node_Str"" + elapsedTime_DAYS;
      }
    }
;
  }
}",0.9610313507178436
11399,"protected List<TimeStruct> createTimeStructsRelativeHours(Axis1D axis,TimeStamp referenceTime,List<TimeStamp> tickTimes,double labelAlign){
  List<TimeStruct> list=new ArrayList<>(tickTimes.size());
  TimeStamp minTime=epoch.toTimeStamp(axis.getMin());
  TimeStamp maxTime=epoch.toTimeStamp(axis.getMax());
  double referenceTime_su=referenceTime.toPosixSeconds();
  double maxViewDuration_SU=Double.NEGATIVE_INFINITY;
  Integer previous_HOURS=null;
  for (int n=0; n < tickTimes.size(); n++) {
    double elapsedTime_SU=tickTimes.get(n).toPosixSeconds() - referenceTime_su;
    double elapsedTime_DAYS=Time.toDays(elapsedTime_SU);
    int elapsedTime_DAYS_WHOLE=(int)Math.floor(elapsedTime_DAYS);
    double elapsedTime_HOURS=(elapsedTime_DAYS - elapsedTime_DAYS_WHOLE) * 24;
    int elapsedTime_HOURS_WHOLE=(int)Math.floor(elapsedTime_HOURS);
    int elapsedTime_HOURS_TOTAL=elapsedTime_DAYS_WHOLE * 24 + elapsedTime_HOURS_WHOLE;
    if (previous_HOURS != null && elapsedTime_HOURS_TOTAL == previous_HOURS)     continue;
    previous_HOURS=elapsedTime_HOURS_TOTAL;
    TimeStruct timeStruct=new TimeStructRelative();
    timeStruct.start=TimeStamp.fromPosixSeconds(Time.fromHours(elapsedTime_HOURS_TOTAL) + referenceTime_su);
    timeStruct.end=timeStruct.start.add(Time.fromHours(1));
    timeStruct.viewStart=clamp(timeStruct.start,timeStruct.end,minTime);
    timeStruct.viewEnd=clamp(timeStruct.start,timeStruct.end,maxTime);
    timeStruct.text=""String_Node_Str"" + elapsedTime_DAYS_WHOLE + ""String_Node_Str""+ elapsedTime_HOURS_WHOLE;
    maxViewDuration_SU=Math.max(maxViewDuration_SU,timeStruct.viewEnd.durationAfter(timeStruct.viewStart));
    list.add(timeStruct);
  }
  setTimeStructTextCenter(list,labelAlign,maxViewDuration_SU);
  return list;
}","protected List<TimeStruct> createTimeStructsRelativeHours(Axis1D axis,TimeStamp referenceTime,List<TimeStamp> tickTimes,double labelAlign){
  List<TimeStruct> list=new ArrayList<>(tickTimes.size());
  TimeStamp minTime=epoch.toTimeStamp(axis.getMin());
  TimeStamp maxTime=epoch.toTimeStamp(axis.getMax());
  double referenceTime_su=referenceTime.toPosixSeconds();
  double maxViewDuration_SU=Double.NEGATIVE_INFINITY;
  Integer previous_HOURS=null;
  Boolean previous_SIGN=null;
  for (int n=0; n < tickTimes.size(); n++) {
    double elapsedTime_SU=tickTimes.get(n).toPosixSeconds() - referenceTime_su;
    boolean negative=(elapsedTime_SU < 0);
    String signString=negative ? ""String_Node_Str"" : ""String_Node_Str"";
    elapsedTime_SU=Math.abs(elapsedTime_SU);
    double elapsedTime_DAYS=Time.toDays(elapsedTime_SU);
    int elapsedTime_DAYS_WHOLE=(int)Math.floor(elapsedTime_DAYS);
    double elapsedTime_HOURS=(elapsedTime_DAYS - elapsedTime_DAYS_WHOLE) * 24;
    int elapsedTime_HOURS_WHOLE=(int)Math.floor(elapsedTime_HOURS);
    int elapsedTime_HOURS_TOTAL=elapsedTime_DAYS_WHOLE * 24 + elapsedTime_HOURS_WHOLE;
    if (previous_HOURS != null && elapsedTime_HOURS_TOTAL == previous_HOURS && negative == previous_SIGN)     continue;
    previous_HOURS=elapsedTime_HOURS_TOTAL;
    previous_SIGN=negative;
    TimeStruct timeStruct=new TimeStructRelative();
    if (negative) {
      timeStruct.end=TimeStamp.fromPosixSeconds(Time.fromHours(-elapsedTime_HOURS_TOTAL) + referenceTime_su);
      timeStruct.start=timeStruct.end.subtract(Time.fromHours(1));
    }
 else {
      timeStruct.start=TimeStamp.fromPosixSeconds(Time.fromHours(elapsedTime_HOURS_TOTAL) + referenceTime_su);
      timeStruct.end=timeStruct.start.add(Time.fromHours(1));
    }
    timeStruct.viewStart=clamp(timeStruct.start,timeStruct.end,minTime);
    timeStruct.viewEnd=clamp(timeStruct.start,timeStruct.end,maxTime);
    timeStruct.text=""String_Node_Str"" + signString + elapsedTime_DAYS_WHOLE+ ""String_Node_Str""+ signString+ elapsedTime_HOURS_WHOLE;
    maxViewDuration_SU=Math.max(maxViewDuration_SU,timeStruct.viewEnd.durationAfter(timeStruct.viewStart));
    list.add(timeStruct);
  }
  setTimeStructTextCenter(list,labelAlign,maxViewDuration_SU);
  return list;
}",0.8458083832335329
11400,"protected List<TimeStruct> createTimeStructsRelativeDays(Axis1D axis,TimeStamp referenceTime,List<TimeStamp> tickTimes,double labelAlign){
  List<TimeStruct> list=new ArrayList<>(tickTimes.size());
  TimeStamp minTime=epoch.toTimeStamp(axis.getMin());
  TimeStamp maxTime=epoch.toTimeStamp(axis.getMax());
  double referenceTime_su=referenceTime.toPosixSeconds();
  double maxViewDuration_SU=Double.NEGATIVE_INFINITY;
  Integer previous_DAYS=null;
  for (int n=0; n < tickTimes.size(); n++) {
    double elapsedTime_SU=tickTimes.get(n).toPosixSeconds() - referenceTime_su;
    double elapsedTime_DAYS=Time.toDays(elapsedTime_SU);
    int elapsedTime_DAYS_WHOLE=(int)Math.floor(elapsedTime_DAYS);
    if (previous_DAYS != null && elapsedTime_DAYS_WHOLE == previous_DAYS)     continue;
    previous_DAYS=elapsedTime_DAYS_WHOLE;
    TimeStruct timeStruct=new TimeStructRelative();
    timeStruct.start=TimeStamp.fromPosixSeconds(Time.fromDays(elapsedTime_DAYS_WHOLE) + referenceTime_su);
    timeStruct.end=timeStruct.start.add(Time.fromDays(1));
    timeStruct.viewStart=clamp(timeStruct.start,timeStruct.end,minTime);
    timeStruct.viewEnd=clamp(timeStruct.start,timeStruct.end,maxTime);
    timeStruct.text=""String_Node_Str"" + elapsedTime_DAYS_WHOLE;
    maxViewDuration_SU=Math.max(maxViewDuration_SU,timeStruct.viewEnd.durationAfter(timeStruct.viewStart));
    list.add(timeStruct);
  }
  setTimeStructTextCenter(list,labelAlign,maxViewDuration_SU);
  return list;
}","protected List<TimeStruct> createTimeStructsRelativeDays(Axis1D axis,TimeStamp referenceTime,List<TimeStamp> tickTimes,double labelAlign){
  List<TimeStruct> list=new ArrayList<>(tickTimes.size());
  TimeStamp minTime=epoch.toTimeStamp(axis.getMin());
  TimeStamp maxTime=epoch.toTimeStamp(axis.getMax());
  double referenceTime_su=referenceTime.toPosixSeconds();
  double maxViewDuration_SU=Double.NEGATIVE_INFINITY;
  Integer previous_DAYS=null;
  Boolean previous_SIGN=null;
  for (int n=0; n < tickTimes.size(); n++) {
    double elapsedTime_SU=tickTimes.get(n).toPosixSeconds() - referenceTime_su;
    boolean negative=(elapsedTime_SU < 0);
    String signString=negative ? ""String_Node_Str"" : ""String_Node_Str"";
    elapsedTime_SU=Math.abs(elapsedTime_SU);
    double elapsedTime_DAYS=Time.toDays(elapsedTime_SU);
    int elapsedTime_DAYS_WHOLE=(int)Math.floor(elapsedTime_DAYS);
    if (previous_DAYS != null && elapsedTime_DAYS_WHOLE == previous_DAYS && negative == previous_SIGN)     continue;
    previous_DAYS=elapsedTime_DAYS_WHOLE;
    previous_SIGN=negative;
    TimeStruct timeStruct=new TimeStructRelative();
    if (negative) {
      timeStruct.end=TimeStamp.fromPosixSeconds(Time.fromDays(-elapsedTime_DAYS_WHOLE) + referenceTime_su);
      timeStruct.start=timeStruct.end.subtract(Time.fromDays(1));
    }
 else {
      timeStruct.start=TimeStamp.fromPosixSeconds(Time.fromDays(elapsedTime_DAYS_WHOLE) + referenceTime_su);
      timeStruct.end=timeStruct.start.add(Time.fromDays(1));
    }
    timeStruct.viewStart=clamp(timeStruct.start,timeStruct.end,minTime);
    timeStruct.viewEnd=clamp(timeStruct.start,timeStruct.end,maxTime);
    timeStruct.text=""String_Node_Str"" + signString + elapsedTime_DAYS_WHOLE;
    maxViewDuration_SU=Math.max(maxViewDuration_SU,timeStruct.viewEnd.durationAfter(timeStruct.viewStart));
    list.add(timeStruct);
  }
  setTimeStructTextCenter(list,labelAlign,maxViewDuration_SU);
  return list;
}",0.7189695550351288
11401,"public RelativeTimeAxisLabelHandler(TimeStamp referenceTime){
  this.referenceTime=referenceTime;
  this.epoch=new Epoch(this.referenceTime);
}","public RelativeTimeAxisLabelHandler(TimeStamp referenceTime,boolean isFuturePositive){
  this.isFuturePositive=isFuturePositive;
  this.referenceTime=referenceTime;
  this.epoch=new Epoch(this.referenceTime);
}",0.8101983002832861
11402,"public void paintTo(GlimpseContext context,GlimpseBounds bounds,Axis2D axis){
  prog.setViewport(bounds);
  prog.setPixelOrtho(bounds);
  float xLeft_PX=(float)(0.5 * lineThickness_PX);
  float xRight_PX=(float)(bounds.getWidth() - 0.5 * lineThickness_PX);
  float yBottom_PX=(float)(0.5 * lineThickness_PX);
  float yTop_PX=(float)(bounds.getHeight() - 0.5 * lineThickness_PX);
  prog.vertices.seal(false);
  prog.vertices.clear();
  prog.vertices.addVertex(xLeft_PX,yBottom_PX);
  prog.vertices.addVertex(xRight_PX,yBottom_PX);
  prog.vertices.addVertex(xRight_PX,yTop_PX);
  prog.vertices.addVertex(xLeft_PX,yTop_PX);
  prog.vertices.addVertex(xLeft_PX,yBottom_PX);
  prog.vertices.seal(true);
  GL gl=context.getGL();
  prog.useProgram(gl,true);
  gl.glDrawArrays(GL_LINES,0,8);
  prog.useProgram(gl,false);
}","public void paintTo(GlimpseContext context,GlimpseBounds bounds,Axis2D axis){
  prog.setViewport(bounds);
  prog.setPixelOrtho(bounds);
  float xLeft_PX=(float)(0.5 * lineThickness_PX);
  float xRight_PX=(float)(bounds.getWidth() - 0.5 * lineThickness_PX);
  float yBottom_PX=(float)(0.5 * lineThickness_PX);
  float yTop_PX=(float)(bounds.getHeight() - 0.5 * lineThickness_PX);
  prog.vertices.seal(false);
  prog.vertices.clear();
  prog.vertices.addVertex(xLeft_PX,yBottom_PX);
  prog.vertices.addVertex(xRight_PX,yBottom_PX);
  prog.vertices.addVertex(xRight_PX,yTop_PX);
  prog.vertices.addVertex(xLeft_PX,yTop_PX);
  prog.vertices.addVertex(xLeft_PX,yBottom_PX);
  prog.vertices.seal(true);
  GL gl=context.getGL();
  gl.glBlendFuncSeparate(GL.GL_SRC_ALPHA,GL.GL_ONE_MINUS_SRC_ALPHA,GL.GL_ONE,GL.GL_ONE_MINUS_SRC_ALPHA);
  gl.glEnable(GL.GL_BLEND);
  prog.useProgram(gl,true);
  gl.glDrawArrays(GL_LINES,0,8);
  prog.useProgram(gl,false);
}",0.9243888573052872
11403,"public static void main(String[] args){
  final Plot2D plot=new Plot2D(""String_Node_Str"");
  plot.setAxisSizeZ(0);
  plot.setTitleHeight(0);
  plot.getLayoutCenter().addPainter(new BackgroundPainter());
  plot.getLayoutCenter().addPainter(new GlimpsePainter2D(){
    float lineThickness_PX=5;
    LineProgram prog;
{
      this.prog=new LineProgram();
      prog.setLineThickness(lineThickness_PX);
      prog.setFeatherThickness(1f);
      prog.setColor(GlimpseColor.getBlack());
    }
    public void paintTo(    GlimpseContext context,    GlimpseBounds bounds,    Axis2D axis){
      prog.setViewport(bounds);
      prog.setPixelOrtho(bounds);
      float xLeft_PX=(float)(0.5 * lineThickness_PX);
      float xRight_PX=(float)(bounds.getWidth() - 0.5 * lineThickness_PX);
      float yBottom_PX=(float)(0.5 * lineThickness_PX);
      float yTop_PX=(float)(bounds.getHeight() - 0.5 * lineThickness_PX);
      prog.vertices.seal(false);
      prog.vertices.clear();
      prog.vertices.addVertex(xLeft_PX,yBottom_PX);
      prog.vertices.addVertex(xRight_PX,yBottom_PX);
      prog.vertices.addVertex(xRight_PX,yTop_PX);
      prog.vertices.addVertex(xLeft_PX,yTop_PX);
      prog.vertices.addVertex(xLeft_PX,yBottom_PX);
      prog.vertices.seal(true);
      GL gl=context.getGL();
      prog.useProgram(gl,true);
      gl.glDrawArrays(GL_LINES,0,8);
      prog.useProgram(gl,false);
    }
  }
);
  SwingUtilities.invokeLater(new Runnable(){
    public void run(){
      NewtSwingEDTGlimpseCanvas canvas=new NewtSwingEDTGlimpseCanvas();
      canvas.addLayout(plot);
      canvas.setLookAndFeel(new SwingLookAndFeel());
      GLAnimatorControl animator=new SwingEDTAnimator(30);
      animator.add(canvas.getGLDrawable());
      animator.start();
      JFrame frame=newFrame(""String_Node_Str"",canvas,DISPOSE_ON_CLOSE);
      stopOnWindowClosing(frame,animator);
      disposeOnWindowClosing(frame,canvas);
      showFrameCentered(frame);
    }
  }
);
}","public static void main(String[] args){
  final Plot2D plot=new Plot2D(""String_Node_Str"");
  plot.setAxisSizeZ(0);
  plot.setTitleHeight(0);
  plot.getLayoutCenter().addPainter(new BackgroundPainter());
  plot.getLayoutCenter().addPainter(new GlimpsePainter2D(){
    float lineThickness_PX=5;
    LineProgram prog;
{
      this.prog=new LineProgram();
      prog.setLineThickness(lineThickness_PX);
      prog.setFeatherThickness(1f);
      prog.setColor(GlimpseColor.getBlack());
    }
    public void paintTo(    GlimpseContext context,    GlimpseBounds bounds,    Axis2D axis){
      prog.setViewport(bounds);
      prog.setPixelOrtho(bounds);
      float xLeft_PX=(float)(0.5 * lineThickness_PX);
      float xRight_PX=(float)(bounds.getWidth() - 0.5 * lineThickness_PX);
      float yBottom_PX=(float)(0.5 * lineThickness_PX);
      float yTop_PX=(float)(bounds.getHeight() - 0.5 * lineThickness_PX);
      prog.vertices.seal(false);
      prog.vertices.clear();
      prog.vertices.addVertex(xLeft_PX,yBottom_PX);
      prog.vertices.addVertex(xRight_PX,yBottom_PX);
      prog.vertices.addVertex(xRight_PX,yTop_PX);
      prog.vertices.addVertex(xLeft_PX,yTop_PX);
      prog.vertices.addVertex(xLeft_PX,yBottom_PX);
      prog.vertices.seal(true);
      GL gl=context.getGL();
      gl.glBlendFuncSeparate(GL.GL_SRC_ALPHA,GL.GL_ONE_MINUS_SRC_ALPHA,GL.GL_ONE,GL.GL_ONE_MINUS_SRC_ALPHA);
      gl.glEnable(GL.GL_BLEND);
      prog.useProgram(gl,true);
      gl.glDrawArrays(GL_LINES,0,8);
      prog.useProgram(gl,false);
    }
  }
);
  SwingUtilities.invokeLater(new Runnable(){
    public void run(){
      NewtSwingEDTGlimpseCanvas canvas=new NewtSwingEDTGlimpseCanvas();
      canvas.addLayout(plot);
      canvas.setLookAndFeel(new SwingLookAndFeel());
      GLAnimatorControl animator=new SwingEDTAnimator(30);
      animator.add(canvas.getGLDrawable());
      animator.start();
      JFrame frame=newFrame(""String_Node_Str"",canvas,DISPOSE_ON_CLOSE);
      stopOnWindowClosing(frame,animator);
      disposeOnWindowClosing(frame,canvas);
      showFrameCentered(frame);
    }
  }
);
}",0.9651937793137496
11404,"protected boolean load(GL2ES2 gl,Collection<ShaderCode> codes){
  if (this.loaded)   return true;
  this.state=new ShaderState();
  this.state.setVerbose(true);
  this.program=new ShaderProgram();
  for (  ShaderCode code : codes) {
    boolean success=this.program.add(gl,code,System.err);
    GLErrorUtils.logGLError(logger,gl,""String_Node_Str"" + code);
    GLErrorUtils.logGLShaderInfoLog(logger,gl,this.program.program(),""String_Node_Str"");
    if (!success) {
      return false;
    }
  }
  this.state.attachShaderProgram(gl,this.program,true);
  GLErrorUtils.logGLError(logger,gl,""String_Node_Str"");
  GLErrorUtils.logGLShaderInfoLog(logger,gl,this.program.program(),""String_Node_Str"");
  for (  GLArrayData array : arrays) {
    this.state.ownAttribute(array,true);
    GLErrorUtils.logGLError(logger,gl,""String_Node_Str"" + array.getName());
  }
  for (  GLUniformData uniform : uniforms) {
    this.state.ownUniform(uniform);
    GLErrorUtils.logGLError(logger,gl,""String_Node_Str"" + uniform.getName());
  }
  this.loaded=true;
  return true;
}","protected boolean load(GL2ES2 gl,Collection<ShaderCode> codes){
  if (this.loaded)   return true;
  this.state=new ShaderState();
  this.state.setVerbose(true);
  this.program=new ShaderProgram();
  for (  ShaderCode code : codes) {
    boolean success=this.program.add(gl,code,System.err);
    GLErrorUtils.logGLError(logger,gl,""String_Node_Str"" + code);
    GLErrorUtils.logGLShaderInfoLog(logger,gl,code.shader().get(0),""String_Node_Str"");
    if (!success) {
      return false;
    }
  }
  this.state.attachShaderProgram(gl,this.program,true);
  GLErrorUtils.logGLError(logger,gl,""String_Node_Str"");
  GLErrorUtils.logGLProgramInfoLog(logger,gl,this.program.program(),""String_Node_Str"");
  for (  GLArrayData array : arrays) {
    this.state.ownAttribute(array,true);
    GLErrorUtils.logGLError(logger,gl,""String_Node_Str"" + array.getName());
  }
  for (  GLUniformData uniform : uniforms) {
    this.state.ownUniform(uniform);
    GLErrorUtils.logGLError(logger,gl,""String_Node_Str"" + uniform.getName());
  }
  this.loaded=true;
  return true;
}",0.8209026128266034
11405,"public static String getGLShaderInfoLog(GL2ES2 gl,int programObject){
  IntBuffer intValue=IntBuffer.allocate(1);
  gl.glGetShaderiv(programObject,GL_INFO_LOG_LENGTH,intValue);
  int lengthWithNull=intValue.get();
  if (lengthWithNull <= 1) {
    lengthWithNull=1000;
  }
  ByteBuffer infoLog=ByteBuffer.allocate(lengthWithNull);
  intValue.flip();
  gl.glGetShaderInfoLog(programObject,lengthWithNull,intValue,infoLog);
  int actualLength=intValue.get();
  byte[] infoBytes=new byte[actualLength];
  infoLog.get(infoBytes);
  return new String(infoBytes);
}","public static String getGLShaderInfoLog(GL2ES2 gl,int shaderObject){
  IntBuffer intValue=IntBuffer.allocate(1);
  gl.glGetShaderiv(shaderObject,GL_INFO_LOG_LENGTH,intValue);
  int lengthWithNull=intValue.get();
  if (lengthWithNull <= 1) {
    lengthWithNull=1000;
  }
  ByteBuffer infoLog=ByteBuffer.allocate(lengthWithNull);
  intValue.flip();
  gl.glGetShaderInfoLog(shaderObject,lengthWithNull,intValue,infoLog);
  int actualLength=intValue.get();
  byte[] infoBytes=new byte[actualLength];
  infoLog.get(infoBytes);
  return new String(infoBytes);
}",0.9649595687331536
11406,"public static void logGLShaderInfoLog(Logger logger,GL2ES2 gl,int programObject,String prefix){
  String log=getGLShaderInfoLog(gl,programObject);
  if (log != null && !log.isEmpty()) {
    logWarning(logger,""String_Node_Str"",prefix,log);
  }
}","public static void logGLShaderInfoLog(Logger logger,GL2ES2 gl,int shaderObject,String prefix){
  String log=getGLShaderInfoLog(gl,shaderObject);
  if (log != null && !log.isEmpty()) {
    logWarning(logger,""String_Node_Str"",prefix,log);
  }
}",0.9465020576131687
11407,"public static void main(String[] args) throws IOException {
  JFrame worldwindFrame=new JFrame(""String_Node_Str"");
  JPanel panel=new JPanel();
  panel.setLayout(new BorderLayout());
  worldwindFrame.add(panel);
  final WorldWindowGLCanvas wwc=new WorldWindowGLCanvas();
  BasicModel model=new BasicModel();
  wwc.setModel(model);
  panel.add(wwc,BorderLayout.CENTER);
  Axis2D wwaxis=new Axis2D();
  GlimpseAxisLayout2D baseLayout=new GlimpseAxisLayout2D(wwaxis);
  GlimpseLayoutManagerMig manager=new GlimpseLayoutManagerMig();
  manager.setLayoutConstraints(String.format(""String_Node_Str""));
  baseLayout.setLayoutManager(manager);
  GeoProjection projectionTo=new PlateCarreeProjection();
  TangentPlane projection=new TangentPlane(LatLonGeo.fromDeg(-30.637005,65.476074));
  BathymetryExample example=new BathymetryExample();
  MapPlot2D plot=example.getLayout(projection);
  Axis2D axis=plot.getAxis();
  GlimpseAxisLayout2D layout=new GlimpseAxisLayout2D(wwaxis);
  AxisUtil.attachMouseListener(layout);
  layout.addPainter(example.getBathymetryPainter());
  layout.addPainter(example.getContourPainter());
  baseLayout.addPainter(new BackgroundPainter().setColor(0,0,0,0));
  baseLayout.addLayout(layout);
  LatLonGeo corner1=projection.unproject(axis.getAxisX().getMin(),axis.getAxisY().getMin());
  LatLonGeo corner2=projection.unproject(axis.getAxisX().getMin(),axis.getAxisY().getMax());
  LatLonGeo corner3=projection.unproject(axis.getAxisX().getMax(),axis.getAxisY().getMax());
  LatLonGeo corner4=projection.unproject(axis.getAxisX().getMax(),axis.getAxisY().getMin());
  List<LatLon> corners=new ArrayList<LatLon>();
  corners.add(LatLon.fromDegrees(corner1.getLatDeg(),corner1.getLonDeg()));
  corners.add(LatLon.fromDegrees(corner2.getLatDeg(),corner2.getLonDeg()));
  corners.add(LatLon.fromDegrees(corner3.getLatDeg(),corner3.getLonDeg()));
  corners.add(LatLon.fromDegrees(corner4.getLatDeg(),corner4.getLonDeg()));
  GlimpseDynamicSurfaceTile glimpseLayer=new GlimpseReprojectingSurfaceTile(baseLayout,wwaxis,projection,projectionTo,4500,4500,3000,3000,corners);
  ApplicationTemplate.insertBeforePlacenames(wwc,glimpseLayer);
  ViewControlsLayer viewControlsLayer=new ViewControlsLayer();
  ApplicationTemplate.insertBeforeCompass(wwc,viewControlsLayer);
  wwc.addSelectListener(new ViewControlsSelectListener(wwc,viewControlsLayer));
  worldwindFrame.setSize(800,800);
  worldwindFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
  worldwindFrame.setVisible(true);
  NewtSwingGlimpseCanvas glimpseCanvas=new NewtSwingGlimpseCanvas(wwc.getContext());
  glimpseCanvas.addLayout(plot);
  glimpseCanvas.setLookAndFeel(new SwingLookAndFeel());
  JFrame glimpseFrame=new JFrame(""String_Node_Str"");
  glimpseFrame.add(glimpseCanvas);
  new FPSAnimator(glimpseCanvas.getGLDrawable(),120).start();
  glimpseFrame.pack();
  glimpseFrame.setSize(800,800);
  glimpseFrame.setLocation(800,0);
  glimpseFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
  glimpseFrame.setVisible(true);
  (new Thread(){
    public void run(){
      while (true) {
        wwc.redraw();
        try {
          Thread.sleep((long)(1000.0 / 60.0));
        }
 catch (        InterruptedException e) {
        }
      }
    }
  }
).start();
}","public static void main(String[] args) throws IOException {
  JFrame worldwindFrame=new JFrame(""String_Node_Str"");
  JPanel panel=new JPanel();
  panel.setLayout(new BorderLayout());
  worldwindFrame.add(panel);
  final WorldWindowGLCanvas wwc=new WorldWindowGLCanvas();
  BasicModel model=new BasicModel();
  wwc.setModel(model);
  panel.add(wwc,BorderLayout.CENTER);
  Axis2D wwaxis=new Axis2D();
  GlimpseAxisLayout2D baseLayout=new GlimpseAxisLayout2D(wwaxis);
  GlimpseLayoutManagerMig manager=new GlimpseLayoutManagerMig();
  manager.setLayoutConstraints(String.format(""String_Node_Str""));
  baseLayout.setLayoutManager(manager);
  GeoProjection projectionTo=new PlateCarreeProjection();
  TangentPlane projection=new TangentPlane(LatLonGeo.fromDeg(-30.637005,65.476074));
  BathymetryExample example=new BathymetryExample();
  MapPlot2D plot=example.getLayout(projection);
  Axis2D axis=plot.getAxis();
  GlimpseAxisLayout2D layout=new GlimpseAxisLayout2D(wwaxis);
  AxisUtil.attachMouseListener(layout);
  layout.addPainter(example.getBathymetryPainter());
  layout.addPainter(example.getContourPainter());
  baseLayout.addPainter(new BackgroundPainter().setColor(0,0,0,0));
  baseLayout.addLayout(layout);
  LatLonGeo corner1=projection.unproject(axis.getAxisX().getMin(),axis.getAxisY().getMin());
  LatLonGeo corner2=projection.unproject(axis.getAxisX().getMin(),axis.getAxisY().getMax());
  LatLonGeo corner3=projection.unproject(axis.getAxisX().getMax(),axis.getAxisY().getMax());
  LatLonGeo corner4=projection.unproject(axis.getAxisX().getMax(),axis.getAxisY().getMin());
  List<LatLon> corners=new ArrayList<LatLon>();
  corners.add(LatLon.fromDegrees(corner1.getLatDeg(),corner1.getLonDeg()));
  corners.add(LatLon.fromDegrees(corner2.getLatDeg(),corner2.getLonDeg()));
  corners.add(LatLon.fromDegrees(corner3.getLatDeg(),corner3.getLonDeg()));
  corners.add(LatLon.fromDegrees(corner4.getLatDeg(),corner4.getLonDeg()));
  GlimpseDynamicSurfaceTile glimpseLayer=new GlimpseReprojectingSurfaceTile(baseLayout,wwaxis,projection,projectionTo,4500,4500,3000,3000,corners);
  ApplicationTemplate.insertBeforePlacenames(wwc,glimpseLayer);
  ViewControlsLayer viewControlsLayer=new ViewControlsLayer();
  ApplicationTemplate.insertBeforeCompass(wwc,viewControlsLayer);
  wwc.addSelectListener(new ViewControlsSelectListener(wwc,viewControlsLayer));
  worldwindFrame.setSize(800,800);
  worldwindFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
  worldwindFrame.setVisible(true);
  NewtSwingGlimpseCanvas glimpseCanvas=new NewtSwingGlimpseCanvas(wwc.getContext());
  glimpseCanvas.addLayout(plot);
  glimpseCanvas.setLookAndFeel(new SwingLookAndFeel());
  JFrame glimpseFrame=new JFrame(""String_Node_Str"");
  glimpseFrame.add(glimpseCanvas);
  new FPSAnimator(glimpseCanvas.getGLDrawable(),120).start();
  glimpseFrame.pack();
  glimpseFrame.setSize(800,800);
  glimpseFrame.setLocation(800,0);
  glimpseFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
  glimpseFrame.setVisible(true);
  linkMouseEvents(wwc,projection,glimpseLayer);
  linkAxisToWorldWind(wwc,projection,plot.getAxis());
  linkWorldWindToAxis(wwc,projection,plot.getAxis());
  (new Thread(){
    public void run(){
      while (true) {
        wwc.redraw();
        try {
          Thread.sleep((long)(1000.0 / 60.0));
        }
 catch (        InterruptedException e) {
        }
      }
    }
  }
).start();
}",0.9765060240963856
11408,"public void restoreArrangement(GroupArrangement groupArr,TileFactory tileFactory,Collection<View> views){
  if (!frames.isEmpty())   throw new RuntimeException(""String_Node_Str"");
  Map<String,View> remainingViews=new LinkedHashMap<>();
  for (  View v : views)   remainingViews.put(v.viewId,v);
  if (groupArr != null) {
    for (    FrameArrangement frameArr : reversed(groupArr.frameArrs)) {
      MultiSplitPane.Node dockerRoot=toDockingPaneNode(frameArr.dockerArr,remainingViews,tileFactory);
      if (dockerRoot != null) {
        DockingFrame frame=addNewFrame();
        frame.setLocation(frameArr.x,frameArr.y);
        frame.setSize(frameArr.width,frameArr.height);
        frame.setExtendedState(getFrameExtendedState(frameArr));
        frame.setVisible(true);
        frame.docker.restore(dockerRoot);
      }
    }
  }
  if (!remainingViews.isEmpty()) {
    DockingFrame frame;
    if (frames.isEmpty()) {
      Tile tile=tileFactory.newTile();
      appendViewsToTile(tile,remainingViews.values());
      frame=addNewFrame();
      frame.docker.addInitialLeaf(tile);
      frame.setLocationByPlatform(true);
      frame.setSize(1024,768);
      frame.setVisible(true);
    }
 else {
      frame=findLargestComponent(frames);
      Tile tile=findLargestTile(frame.docker);
      if (tile == null) {
        tile=tileFactory.newTile();
        appendViewsToTile(tile,remainingViews.values());
        frame.docker.addEdgeLeaf(tile,LEFT);
      }
 else {
        appendViewsToTile(tile,remainingViews.values());
      }
    }
  }
}","public void restoreArrangement(GroupArrangement groupArr,TileFactory tileFactory,Collection<View> views){
  if (!frames.isEmpty())   throw new RuntimeException(""String_Node_Str"");
  Map<String,View> remainingViews=new LinkedHashMap<>();
  for (  View v : views)   remainingViews.put(v.viewId,v);
  if (groupArr != null) {
    for (    FrameArrangement frameArr : reversed(groupArr.frameArrs)) {
      MultiSplitPane.Node dockerRoot=toDockingPaneNode(frameArr.dockerArr,remainingViews,tileFactory);
      if (dockerRoot != null) {
        DockingFrame frame=addNewFrame();
        frame.setBounds(frameArr.x,frameArr.y,frameArr.width,frameArr.height);
        frame.setNormalBounds(frameArr.x,frameArr.y,frameArr.width,frameArr.height);
        frame.setExtendedState(getFrameExtendedState(frameArr));
        frame.setVisible(true);
        frame.docker.restore(dockerRoot);
      }
    }
  }
  if (!remainingViews.isEmpty()) {
    DockingFrame frame;
    if (frames.isEmpty()) {
      Tile tile=tileFactory.newTile();
      appendViewsToTile(tile,remainingViews.values());
      frame=addNewFrame();
      frame.docker.addInitialLeaf(tile);
      frame.setLocationByPlatform(true);
      frame.setSize(1024,768);
      frame.setVisible(true);
    }
 else {
      frame=findLargestComponent(frames);
      Tile tile=findLargestTile(frame.docker);
      if (tile == null) {
        tile=tileFactory.newTile();
        appendViewsToTile(tile,remainingViews.values());
        frame.docker.addEdgeLeaf(tile,LEFT);
      }
 else {
        appendViewsToTile(tile,remainingViews.values());
      }
    }
  }
}",0.9602796313949792
11409,"@Override public void mouseMoved(GlimpseMouseEvent e){
  if (!enabled)   return;
  if (e.isButtonDown(MouseButton.Button1) && dragEvent != null) {
    TimeStamp time=info.getTime(e);
    if (dragType == Location.Center) {
      double diff=time.durationAfter(anchorTime);
      dragEvent.setTimes(eventStart.add(diff),eventEnd.add(diff));
    }
 else     if (dragType == Location.End && eventStart.isBefore(time)) {
      dragEvent.setTimes(eventStart,time);
    }
 else     if (dragType == Location.Start && eventEnd.isAfter(time)) {
      dragEvent.setTimes(time,eventEnd);
    }
    e.setHandled(true);
  }
}","@Override public void mouseMoved(GlimpseMouseEvent e){
  if (!enabled)   return;
  if (e.isButtonDown(MouseButton.Button1) && dragEvent != null) {
    TimeStamp time=info.getTime(e);
    if (dragType == Location.Center) {
      double diff=time.durationAfter(anchorTime);
      dragEvent.setTimes(eventStart.add(diff),eventEnd.add(diff),false);
    }
 else     if (dragType == Location.End && eventStart.isBefore(time)) {
      dragEvent.setTimes(eventStart,time,false);
    }
 else     if (dragType == Location.Start && eventEnd.isAfter(time)) {
      dragEvent.setTimes(time,eventEnd,false);
    }
    e.setHandled(true);
  }
}",0.985483870967742
11410,"@Override public boolean bind(DrawContext dc){
  GL gl=dc.getGL();
  gl.glBindTexture(GL2.GL_TEXTURE_2D,textureHandle);
  return true;
}","@Override public boolean bind(DrawContext dc){
  GL gl=dc.getGL();
  gl.glBindTexture(GL2.GL_TEXTURE_2D,textureHandle);
  gl.glTexParameterf(GL2.GL_TEXTURE_2D,GL2.GL_TEXTURE_MAG_FILTER,GL2.GL_LINEAR);
  gl.glTexParameterf(GL2.GL_TEXTURE_2D,GL2.GL_TEXTURE_MIN_FILTER,GL2.GL_LINEAR);
  gl.glTexParameterf(GL2.GL_TEXTURE_2D,GL2.GL_TEXTURE_WRAP_S,GL2.GL_CLAMP_TO_EDGE);
  gl.glTexParameterf(GL2.GL_TEXTURE_2D,GL2.GL_TEXTURE_WRAP_T,GL2.GL_CLAMP_TO_EDGE);
  gl.glBlendFuncSeparate(GL2.GL_SRC_ALPHA,GL2.GL_ONE_MINUS_SRC_ALPHA,GL2.GL_ONE,GL2.GL_ONE_MINUS_SRC_ALPHA);
  gl.glEnable(GL2.GL_BLEND);
  return true;
}",0.3459459459459459
11411,"public static void main(String[] args) throws Exception {
  try {
    UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
  }
 catch (  UnsupportedLookAndFeelException e) {
  }
  SlippyTileExample slippy=new SlippyTileExample();
  Example example=Example.showWithSwing(slippy);
  example.getFrame().setJMenuBar(slippy.mapToolBar);
}","public static void main(String[] args) throws Exception {
  try {
    UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
  }
 catch (  UnsupportedLookAndFeelException e) {
  }
  SlippyTileExample slippy=new SlippyTileExample();
  Example example=Example.showWithSwing(slippy);
  SwingUtilities.invokeLater(() -> {
    example.getFrame().setJMenuBar(slippy.mapToolBar);
    example.getFrame().validate();
  }
);
}",0.8960205391527599
11412,"@Override public void mouseWheelMoved(GlimpseMouseEvent event){
  GlimpseAxisLayout2D layout=getAxisLayout(event);
  if (layout == null)   return;
  Axis2D axis2D=layout.getAxis(event.getTargetStack());
  double xTileDim=axis2D.getAxisX().getSizePixels() / 256;
  double yTileDim=axis2D.getAxisY().getSizePixels() / 256;
  double minX=axis2D.getAxisX().getMin();
  double maxX=axis2D.getAxisX().getMax();
  double minY=axis2D.getAxisY().getMin();
  double maxY=axis2D.getAxisY().getMax();
  LatLonGeo center=geoProj.unproject((minX + maxX) / 2.,(minY + maxY) / 2.);
  LatLonGeo ne=geoProj.unproject(maxX,maxY);
  LatLonGeo sw=geoProj.unproject(minX,minY);
  double east=ne.getLonDeg();
  double west=sw.getLonDeg();
  double lonSizeDeg=(east - west) / xTileDim;
  double zoomApprox=Math.log(360 / lonSizeDeg) / LOG2;
  int currentZoom=(int)Math.round(zoomApprox);
  int zoom=currentZoom;
  if (event.getWheelIncrement() == 0) {
  }
 else   if (event.getWheelIncrement() > 0) {
    zoom--;
  }
 else {
    zoom++;
  }
  zoom=Math.max(0,Math.min(zoom,MAX_ZOOM));
  if (zoom == currentZoom) {
    return;
  }
  double zoomFactor=1 << zoom;
  double lonTileSizeDeg=360 / zoomFactor;
  double latTileSizeDeg=170.1022 / zoomFactor;
  double dLat=(yTileDim / 2.) * latTileSizeDeg;
  double dLon=(xTileDim / 2.) * lonTileSizeDeg;
  Vector2d maxVec=geoProj.project(LatLonGeo.fromDeg(center.getLatDeg() + dLat,center.getLonDeg() + dLon));
  Vector2d minVec=geoProj.project(LatLonGeo.fromDeg(center.getLatDeg() - dLat,center.getLonDeg() - dLon));
  this.xSpan=maxVec.getX() - minVec.getX();
  this.ySpan=maxVec.getY() - minVec.getY();
  this.mouseWheelMoved(event,axis2D.getAxisX(),true);
  this.mouseWheelMoved(event,axis2D.getAxisY(),false);
  this.applyAndUpdate(axis2D.getAxisX(),axis2D.getAxisY());
}","@Override public void mouseWheelMoved(GlimpseMouseEvent event){
  GlimpseAxisLayout2D layout=getAxisLayout(event);
  if (layout == null)   return;
  Axis2D axis2D=layout.getAxis(event.getTargetStack());
  double xTileDim=axis2D.getAxisX().getSizePixels() / 256.;
  double yTileDim=axis2D.getAxisY().getSizePixels() / 256.;
  double minX=axis2D.getAxisX().getMin();
  double maxX=axis2D.getAxisX().getMax();
  double minY=axis2D.getAxisY().getMin();
  double maxY=axis2D.getAxisY().getMax();
  LatLonGeo center=geoProj.unproject((minX + maxX) / 2.,(minY + maxY) / 2.);
  LatLonGeo ne=geoProj.unproject(maxX,maxY);
  LatLonGeo sw=geoProj.unproject(minX,minY);
  double east=ne.getLonDeg();
  double west=sw.getLonDeg();
  double lonSizeDeg=(east - west) / xTileDim;
  double zoomApprox=Math.log(360 / lonSizeDeg) / LOG2;
  int currentZoom=(int)Math.round(zoomApprox);
  int zoom=currentZoom;
  if (event.getWheelIncrement() == 0) {
  }
 else   if (event.getWheelIncrement() > 0) {
    zoom--;
  }
 else {
    zoom++;
  }
  zoom=Math.max(0,Math.min(zoom,MAX_ZOOM));
  if (zoom == currentZoom) {
    return;
  }
  double zoomFactor=1 << zoom;
  double lonTileSizeDeg=360 / zoomFactor;
  double latTileSizeDeg=170.1022 / zoomFactor;
  double dLat=(yTileDim / 2.) * latTileSizeDeg;
  double dLon=(xTileDim / 2.) * lonTileSizeDeg;
  Vector2d maxVec=geoProj.project(LatLonGeo.fromDeg(center.getLatDeg() + dLat,center.getLonDeg() + dLon));
  Vector2d minVec=geoProj.project(LatLonGeo.fromDeg(center.getLatDeg() - dLat,center.getLonDeg() - dLon));
  this.xSpan=maxVec.getX() - minVec.getX();
  this.ySpan=maxVec.getY() - minVec.getY();
  this.mouseWheelMoved(event,axis2D.getAxisX(),true);
  this.mouseWheelMoved(event,axis2D.getAxisY(),false);
  this.applyAndUpdate(axis2D.getAxisX(),axis2D.getAxisY());
}",0.9994428969359332
11413,"protected void updateTiles(Axis2D axis){
  int xPix=axis.getAxisX().getSizePixels();
  if (!isVisible() || xPix <= 0) {
    return;
  }
  double minx=axis.getMinX();
  double maxx=axis.getMaxX();
  double maxy=axis.getMaxY();
  double miny=axis.getMinY();
  double[] bounds=new double[]{minx,maxx,miny,maxy};
  if (Arrays.equals(bounds,lastBounds.get())) {
    return;
  }
  lastBounds.set(bounds);
  double xTileDim=xPix / 256.;
  LatLonGeo ne=geoProj.unproject(maxx,maxy);
  LatLonGeo sw=geoProj.unproject(minx,miny);
  double east=ne.getLonDeg();
  double west=sw.getLonDeg();
  double lonSizeDeg=(east - west) / xTileDim;
  double zoomApprox=Math.log(360 / lonSizeDeg) / LOG2;
  final int zoom=(int)Math.min(Math.floor(zoomApprox),maxZoom);
  lastZoom.set(zoom);
  Vector2d tileNE=slippyProj[zoom].project(ne);
  Vector2d tileSW=slippyProj[zoom].project(sw);
  final int tileYmin=(int)Math.floor(tileNE.getY());
  final int tileYmax=(int)Math.ceil(tileSW.getY());
  final int tileXmin=(int)Math.floor(tileSW.getX());
  final int tileXmax=(int)Math.ceil(tileNE.getX());
  lock.lock();
  try {
    for (int y=tileYmin; y < tileYmax; y++) {
      for (int x=tileXmin; x < tileXmax; x++) {
        RGBTextureProjected2D tex=cache.getTextureIfPresent(zoom,x,y);
        if (tex != null && drawableTextures.containsKey(new TextureUnit<DrawableTexture>(tex))) {
          continue;
        }
        exec.submit(new FetchTexture(zoom,x,y));
      }
    }
    Iterator<TextureUnit<DrawableTexture>> itr=drawableTextures.keySet().iterator();
    while (itr.hasNext()) {
      TextureUnit<DrawableTexture> texUnit=itr.next();
      TextureProjected2D tex=(TextureProjected2D)texUnit.getTexture();
      double[] texBounds=getBounds(tex.getProjection());
      int texZoom=texZoomMap.get(tex);
      if (texZoom != zoom || !intersect(bounds,texBounds)) {
        itr.remove();
        texZoomMap.remove(tex);
      }
    }
  }
  finally {
    lock.unlock();
  }
}","protected void updateTiles(Axis2D axis){
  int xPix=axis.getAxisX().getSizePixels();
  if (!isVisible() || xPix <= 0) {
    return;
  }
  double minx=axis.getMinX();
  double maxx=axis.getMaxX();
  double maxy=axis.getMaxY();
  double miny=axis.getMinY();
  double[] bounds=new double[]{minx,maxx,miny,maxy};
  if (Arrays.equals(bounds,lastBounds.get())) {
    return;
  }
  lastBounds.set(bounds);
  double xTileDim=xPix / 256.;
  LatLonGeo ne=geoProj.unproject(maxx,maxy);
  LatLonGeo sw=geoProj.unproject(minx,miny);
  double east=ne.getLonDeg();
  double west=sw.getLonDeg();
  double lonSizeDeg=(east - west) / xTileDim;
  double zoomApprox=Math.log(360 / lonSizeDeg) / LOG2;
  final int zoom=(int)Math.min(Math.round(zoomApprox),maxZoom);
  lastZoom.set(zoom);
  Vector2d tileNE=slippyProj[zoom].project(ne);
  Vector2d tileSW=slippyProj[zoom].project(sw);
  final int tileYmin=(int)Math.floor(tileNE.getY());
  final int tileYmax=(int)Math.ceil(tileSW.getY());
  final int tileXmin=(int)Math.floor(tileSW.getX());
  final int tileXmax=(int)Math.ceil(tileNE.getX());
  lock.lock();
  try {
    for (int y=tileYmin; y < tileYmax; y++) {
      for (int x=tileXmin; x < tileXmax; x++) {
        RGBTextureProjected2D tex=cache.getTextureIfPresent(zoom,x,y);
        if (tex != null && drawableTextures.containsKey(new TextureUnit<DrawableTexture>(tex))) {
          continue;
        }
        exec.submit(new FetchTexture(zoom,x,y));
      }
    }
    Iterator<TextureUnit<DrawableTexture>> itr=drawableTextures.keySet().iterator();
    while (itr.hasNext()) {
      TextureUnit<DrawableTexture> texUnit=itr.next();
      TextureProjected2D tex=(TextureProjected2D)texUnit.getTexture();
      double[] texBounds=getBounds(tex.getProjection());
      int texZoom=texZoomMap.get(tex);
      if (texZoom != zoom || !intersect(bounds,texBounds)) {
        itr.remove();
        texZoomMap.remove(tex);
      }
    }
  }
  finally {
    lock.unlock();
  }
}",0.997443762781186
11414,"@Override public GlimpseLayout getLayout() throws Exception {
  final GeoProjection geoProj=new TangentPlane(LatLonGeo.fromDeg(38.958374,-77.358548));
  final boolean inUS=true;
  final MultiAxisPlot2D mapPlot=new MultiAxisPlot2D(){
    @Override protected AxisMouseListener createAxisMouseListenerXY(){
      return new SlippyAxisMouseListener2D(geoProj);
    }
  }
;
  double rad=Length.fromKilometers(1);
  mapPlot.getCenterAxis().lockAspectRatioXY(1);
  mapPlot.getCenterAxis().set(-rad,rad,-rad,rad);
  final SlippyMapTilePainter mapPainter=SlippyPainterFactory.getMapQuestMaps(geoProj);
  mapPlot.addPainter(mapPainter);
  final SlippyMapTilePainter satPainter=SlippyPainterFactory.getMapQuestImagery(geoProj,inUS);
  mapPlot.addPainter(satPainter);
  satPainter.setVisible(false);
  final SlippyMapTilePainter cartoLightPainter=SlippyPainterFactory.getCartoMap(geoProj,true,true);
  mapPlot.addPainter(cartoLightPainter);
  cartoLightPainter.setVisible(false);
  final SlippyMapTilePainter cartoDarkPainter=SlippyPainterFactory.getCartoMap(geoProj,false,false);
  mapPlot.addPainter(cartoDarkPainter);
  cartoDarkPainter.setVisible(false);
  this.mapToolBar=new JMenuBar();
  ButtonGroup group=new ButtonGroup();
  final JRadioButton mapCheckBox=new JRadioButton(""String_Node_Str"",mapPainter.isVisible());
  final JRadioButton satcheckBox=new JRadioButton(""String_Node_Str"",satPainter.isVisible());
  final JRadioButton cartoLightCheckBox=new JRadioButton(""String_Node_Str"",cartoLightPainter.isVisible());
  final JRadioButton cartoDarkcheckBox=new JRadioButton(""String_Node_Str"",cartoDarkPainter.isVisible());
  group.add(mapCheckBox);
  group.add(satcheckBox);
  group.add(cartoLightCheckBox);
  group.add(cartoDarkcheckBox);
  ActionListener l=new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      mapPainter.setVisible(mapCheckBox.isSelected());
      satPainter.setVisible(satcheckBox.isSelected());
      cartoLightPainter.setVisible(cartoLightCheckBox.isSelected());
      cartoDarkPainter.setVisible(cartoDarkcheckBox.isSelected());
    }
  }
;
  mapToolBar.add(mapCheckBox);
  mapToolBar.add(satcheckBox);
  mapToolBar.add(cartoLightCheckBox);
  mapToolBar.add(cartoDarkcheckBox);
  mapCheckBox.addActionListener(l);
  satcheckBox.addActionListener(l);
  cartoLightCheckBox.addActionListener(l);
  cartoDarkcheckBox.addActionListener(l);
  return mapPlot;
}","@Override public GlimpseLayout getLayout() throws Exception {
  final GeoProjection geoProj=new TangentPlane(LatLonGeo.fromDeg(38.958374,-77.358548));
  final boolean inUS=true;
  final MultiAxisPlot2D mapPlot=new MultiAxisPlot2D(){
    @Override protected AxisMouseListener createAxisMouseListenerXY(){
      return new SlippyAxisMouseListener2D(geoProj);
    }
  }
;
  double rad=Length.fromKilometers(1);
  mapPlot.getCenterAxis().lockAspectRatioXY(1);
  mapPlot.getCenterAxis().set(-rad,rad,-rad,rad);
  final SlippyMapTilePainter mapPainter=SlippyPainterFactory.getMapQuestMaps(geoProj);
  mapPlot.addPainter(mapPainter);
  final SlippyMapTilePainter satPainter=SlippyPainterFactory.getMapQuestImagery(geoProj,inUS);
  mapPlot.addPainter(satPainter);
  satPainter.setVisible(false);
  final SlippyMapTilePainter cartoLightPainter=SlippyPainterFactory.getCartoMap(geoProj,true,true);
  mapPlot.addPainter(cartoLightPainter);
  cartoLightPainter.setVisible(false);
  final SlippyMapTilePainter cartoDarkPainter=SlippyPainterFactory.getCartoMap(geoProj,false,false);
  mapPlot.addPainter(cartoDarkPainter);
  cartoDarkPainter.setVisible(false);
  ScalePainter scalePainter=new ScalePainter();
  scalePainter.setUnitConverter(AxisUnitConverters.suShownAsMeters);
  scalePainter.setUnitLabel(""String_Node_Str"");
  mapPlot.addPainter(scalePainter);
  this.mapToolBar=new JMenuBar();
  ButtonGroup group=new ButtonGroup();
  final JRadioButton mapCheckBox=new JRadioButton(""String_Node_Str"",mapPainter.isVisible());
  final JRadioButton satcheckBox=new JRadioButton(""String_Node_Str"",satPainter.isVisible());
  final JRadioButton cartoLightCheckBox=new JRadioButton(""String_Node_Str"",cartoLightPainter.isVisible());
  final JRadioButton cartoDarkcheckBox=new JRadioButton(""String_Node_Str"",cartoDarkPainter.isVisible());
  group.add(mapCheckBox);
  group.add(satcheckBox);
  group.add(cartoLightCheckBox);
  group.add(cartoDarkcheckBox);
  ActionListener l=new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      mapPainter.setVisible(mapCheckBox.isSelected());
      satPainter.setVisible(satcheckBox.isSelected());
      cartoLightPainter.setVisible(cartoLightCheckBox.isSelected());
      cartoDarkPainter.setVisible(cartoDarkcheckBox.isSelected());
    }
  }
;
  mapToolBar.add(mapCheckBox);
  mapToolBar.add(satcheckBox);
  mapToolBar.add(cartoLightCheckBox);
  mapToolBar.add(cartoDarkcheckBox);
  mapCheckBox.addActionListener(l);
  satcheckBox.addActionListener(l);
  cartoLightCheckBox.addActionListener(l);
  cartoDarkcheckBox.addActionListener(l);
  return mapPlot;
}",0.959952181709504
11415,"private static boolean intersect(final double[] outerBounds,final double[] bounds){
  return contains(outerBounds,bounds[0],bounds[2]) || contains(outerBounds,bounds[0],bounds[3]) || contains(outerBounds,bounds[1],bounds[2])|| contains(outerBounds,bounds[1],bounds[3]);
}","private static boolean intersect(final double[] outerBounds,final double[] bounds){
  return contains(outerBounds,bounds[0],bounds[2]) || contains(outerBounds,bounds[0],bounds[3]) || contains(outerBounds,bounds[1],bounds[2])|| contains(outerBounds,bounds[1],bounds[3])|| contains(bounds,outerBounds[0],outerBounds[2])|| contains(bounds,outerBounds[0],outerBounds[3])|| contains(bounds,outerBounds[1],outerBounds[2])|| contains(bounds,outerBounds[1],outerBounds[3]);
}",0.7344173441734417
11416,"@Override public void selectView(View view){
  if (view == selectedView)   return;
  if (selectedView != null) {
    ViewEntry viewEntry=viewMap.get(selectedView.viewId);
    viewEntry.tab.setSelected(false);
    cardPanel.setVisible(false);
  }
  if (view != null) {
    ViewEntry viewEntry=viewMap.get(view.viewId);
    viewEntry.tab.setSelected(true);
    cardLayout.show(cardPanel,view.viewId);
    cardPanel.setVisible(true);
  }
  selectedView=view;
  topBar.doLayout();
  topBar.repaint();
  for (  TileListener listener : listeners) {
    listener.selectedView(view);
  }
}","@Override public void selectView(View view){
  if (view == selectedView)   return;
  if (selectedView != null && viewMap.containsKey(selectedView.viewId)) {
    ViewEntry viewEntry=viewMap.get(selectedView.viewId);
    viewEntry.tab.setSelected(false);
    cardPanel.setVisible(false);
  }
  if (view != null) {
    ViewEntry viewEntry=viewMap.get(view.viewId);
    viewEntry.tab.setSelected(true);
    cardLayout.show(cardPanel,view.viewId);
    cardPanel.setVisible(true);
  }
  selectedView=view;
  topBar.doLayout();
  topBar.repaint();
  for (  TileListener listener : listeners) {
    listener.selectedView(view);
  }
}",0.9635157545605308
11417,"@Override public GlimpseContext getGlimpseContext(){
  GlimpseContext glimpseContext=new GlimpseContextImpl(getGLContext());
  glimpseContext.getTargetStack().push(this,effectiveGlimpseBounds);
  return glimpseContext;
}","@Override public GlimpseContext getGlimpseContext(){
  GlimpseContext glimpseContext=new GlimpseContextImpl(getGLContext(),getSurfaceScale());
  glimpseContext.getTargetStack().push(this,effectiveGlimpseBounds);
  return glimpseContext;
}",0.960698689956332
11418,"@Override public StackedTimePlot2D getLayout(){
  final CollapsibleTimePlot2D plot=(CollapsibleTimePlot2D)super.getLayout();
  plot.setLabelSize(120);
  plot.setIndentSize(140);
  plot.setIndentSubplots(true);
  for (  TimePlotInfo row : plot.getAllTimePlots()) {
    GroupInfo group=plot.createGroup(String.format(""String_Node_Str"",row.getId()),row);
    row.getLabelPainter().setText(""String_Node_Str"");
    group.setLabelText(""String_Node_Str"");
    setPlotLookAndFeel(row);
  }
  final EventPlotInfo events1=plot.createEventPlot(""String_Node_Str"");
  EventPlotInfo events2=plot.createEventPlot(""String_Node_Str"");
  EventPlotInfo events3=plot.createEventPlot(""String_Node_Str"");
  events1.setLabelText(""String_Node_Str"");
  events2.setLabelText(""String_Node_Str"");
  events3.setLabelText(""String_Node_Str"");
  setPlotLookAndFeel(events1);
  setPlotLookAndFeel(events2);
  setPlotLookAndFeel(events3);
  events1.getLabelPainter().setVerticalPosition(VerticalPosition.Center);
  events2.getLabelPainter().setVerticalPosition(VerticalPosition.Center);
  events3.getLabelPainter().setVerticalPosition(VerticalPosition.Center);
  GroupInfo group=plot.createGroup(""String_Node_Str"",events1,events2,events3);
  group.setLabelText(""String_Node_Str"");
  group.setOrder(100);
  events1.setOrder(2);
  events2.setOrder(3);
  events3.setOrder(4);
  events1.setDefaultEventBackgroundColor(GlimpseColor.getGreen(0.6f));
  events1.setDefaultEventBorderColor(GlimpseColor.getGreen());
  events3.setDefaultEventBackgroundColor(GlimpseColor.getCyan(0.6f));
  events3.setDefaultEventBorderColor(GlimpseColor.getCyan());
  Epoch e=plot.getEpoch();
  TimeStamp t0=e.toTimeStamp(0);
  Event e0=events1.addEvent(""String_Node_Str"",t0,t0.add(Time.fromMinutes(20)));
  e0.setShowBackground(false);
  events1.addEvent(""String_Node_Str"",t0.add(Time.fromMinutes(30)),t0.add(Time.fromMinutes(200)));
  Event e1=events1.addEvent(""String_Node_Str"",t0.add(Time.fromMinutes(290)),t0.add(Time.fromMinutes(320)));
  e1.setBackgroundColor(GlimpseColor.getRed(0.6f));
  e1.setBorderColor(GlimpseColor.getRed());
  Event e2=events1.addEvent(""String_Node_Str"",t0.add(Time.fromMinutes(-200)),t0.add(Time.fromMinutes(100)));
  Event e3=events1.addEvent(""String_Node_Str"",t0.add(Time.fromMinutes(100)),t0.add(Time.fromMinutes(300)));
  Event e4=events1.addEvent(""String_Node_Str"",t0.subtract(Time.fromMinutes(40)));
  events2.addEvent(""String_Node_Str"",t0.add(Time.fromMinutes(-250)),t0.add(Time.fromMinutes(-240)));
  events2.addEvent(""String_Node_Str"",t0.add(Time.fromMinutes(-220)),t0.add(Time.fromMinutes(-200)));
  events2.addEvent(""String_Node_Str"",t0.add(Time.fromMinutes(-170)),t0.add(Time.fromMinutes(-100)));
  events1.setAggregateNearbyEvents(true);
  events2.setAggregateNearbyEvents(true);
  e0.setEndTimeMoveable(false);
  e1.setResizeable(false);
  e2.setMinTimeSpan(Time.fromMinutes(100));
  e3.setMaxTimeSpan(Time.fromMinutes(500));
  events1.getEventSelectionHandler().setClearSelectionOnClick(true);
  e2.setSelectable(false);
  e2.setFixedRow(2);
  events1.validate();
  TextureAtlas atlas=plot.getTextureAtlas();
  try {
    atlas.loadImage(""String_Node_Str"",ImageIO.read(StreamOpener.fileThenResource.openForRead(""String_Node_Str"")));
    atlas.loadImage(""String_Node_Str"",ImageIO.read(StreamOpener.fileThenResource.openForRead(""String_Node_Str"")));
    atlas.loadImage(""String_Node_Str"",ImageIO.read(StreamOpener.fileThenResource.openForRead(""String_Node_Str"")));
    atlas.loadImage(""String_Node_Str"",ImageIO.read(StreamOpener.fileThenResource.openForRead(""String_Node_Str"")));
  }
 catch (  IOException ex) {
    logWarning(logger,""String_Node_Str"",ex);
  }
  e1.setIconId(""String_Node_Str"");
  e2.setIconId(""String_Node_Str"");
  e3.setIconId(""String_Node_Str"");
  e4.setIconId(""String_Node_Str"");
  plot.getTooltipPainter().setFixedWidth(300);
  e0.setToolTipText(""String_Node_Str"");
  e1.setToolTipText(""String_Node_Str"");
  e2.setToolTipText(""String_Node_Str"");
  e3.setToolTipText(""String_Node_Str"");
  e4.setToolTipText(""String_Node_Str"");
  events1.addEventPlotListener(new EventPlotListener(){
    @Override public void eventsHovered(    GlimpseMouseEvent e,    Set<EventSelection> events,    TimeStamp time){
      if (!events.isEmpty())       logInfo(logger,""String_Node_Str"",events,time);
    }
    @Override public void eventsClicked(    GlimpseMouseEvent e,    Set<EventSelection> events,    TimeStamp time){
      if (!events.isEmpty())       logInfo(logger,""String_Node_Str"",events,time);
    }
    @Override public void eventsExited(    GlimpseMouseEvent e,    Set<EventSelection> events,    TimeStamp time){
      if (!events.isEmpty())       logInfo(logger,""String_Node_Str"",events,time);
    }
    @Override public void eventsEntered(    GlimpseMouseEvent e,    Set<EventSelection> events,    TimeStamp time){
      if (!events.isEmpty())       logInfo(logger,""String_Node_Str"",events,time);
    }
    @Override public void eventUpdated(    GlimpseMouseEvent e,    Event event){
      logInfo(logger,""String_Node_Str"",event);
    }
  }
);
  plot.getEventSelectionHander().addEventSelectionListener(new EventSelectionListener(){
    @Override public void eventsSelected(    Set<Event> selectedEvents,    Set<Event> deselectedEvents){
      logInfo(logger,""String_Node_Str"",selectedEvents,deselectedEvents);
    }
  }
);
  events1.getEventSelectionHandler().setSelectedEventBorderThickness(3.0f);
  plot.setTimeAxisMouseListener(new TaggedAxisMouseListener1D());
  plot.getSelectedTimePainter().setShowLockedStatus(false);
  plot.getTimeAxis().addAxisListener(new TaggedAxisListener1D(){
    @Override public void tagsUpdated(    TaggedAxis1D axis){
      Tag s=plot.getTimeSelectionTag();
      Tag m=plot.getTimeSelectionMaxTag();
      if (s != null && m != null && s.getValue() != m.getValue()) {
        s.setValue(m.getValue());
        plot.getTimeAxis().validateTags();
      }
    }
  }
);
  return plot;
}","@Override public StackedTimePlot2D getLayout(){
  final CollapsibleTimePlot2D plot=(CollapsibleTimePlot2D)super.getLayout();
  plot.setLabelSize(120);
  plot.setIndentSize(140);
  plot.setIndentSubplots(true);
  plot.setShowLabels(true);
  for (  TimePlotInfo row : plot.getAllTimePlots()) {
    GroupInfo group=plot.createGroup(String.format(""String_Node_Str"",row.getId()),row);
    row.getLabelPainter().setText(""String_Node_Str"");
    group.setLabelText(""String_Node_Str"");
    setPlotLookAndFeel(row);
  }
  final EventPlotInfo events1=plot.createEventPlot(""String_Node_Str"");
  EventPlotInfo events2=plot.createEventPlot(""String_Node_Str"");
  EventPlotInfo events3=plot.createEventPlot(""String_Node_Str"");
  events1.setLabelText(""String_Node_Str"");
  events2.setLabelText(""String_Node_Str"");
  events3.setLabelText(""String_Node_Str"");
  setPlotLookAndFeel(events1);
  setPlotLookAndFeel(events2);
  setPlotLookAndFeel(events3);
  events1.getLabelPainter().setVerticalPosition(VerticalPosition.Center);
  events2.getLabelPainter().setVerticalPosition(VerticalPosition.Center);
  events3.getLabelPainter().setVerticalPosition(VerticalPosition.Center);
  GroupInfo group=plot.createGroup(""String_Node_Str"",events1,events2,events3);
  group.setLabelText(""String_Node_Str"");
  group.setOrder(100);
  events1.setOrder(2);
  events2.setOrder(3);
  events3.setOrder(4);
  events1.setDefaultEventBackgroundColor(GlimpseColor.getGreen(0.6f));
  events1.setDefaultEventBorderColor(GlimpseColor.getGreen());
  events3.setDefaultEventBackgroundColor(GlimpseColor.getCyan(0.6f));
  events3.setDefaultEventBorderColor(GlimpseColor.getCyan());
  Epoch e=plot.getEpoch();
  TimeStamp t0=e.toTimeStamp(0);
  Event e0=events1.addEvent(""String_Node_Str"",t0,t0.add(Time.fromMinutes(20)));
  e0.setShowBackground(false);
  events1.addEvent(""String_Node_Str"",t0.add(Time.fromMinutes(30)),t0.add(Time.fromMinutes(200)));
  Event e1=events1.addEvent(""String_Node_Str"",t0.add(Time.fromMinutes(290)),t0.add(Time.fromMinutes(320)));
  e1.setBackgroundColor(GlimpseColor.getRed(0.6f));
  e1.setBorderColor(GlimpseColor.getRed());
  Event e2=events1.addEvent(""String_Node_Str"",t0.add(Time.fromMinutes(-200)),t0.add(Time.fromMinutes(100)));
  Event e3=events1.addEvent(""String_Node_Str"",t0.add(Time.fromMinutes(100)),t0.add(Time.fromMinutes(300)));
  Event e4=events1.addEvent(""String_Node_Str"",t0.subtract(Time.fromMinutes(40)));
  events2.addEvent(""String_Node_Str"",t0.add(Time.fromMinutes(-250)),t0.add(Time.fromMinutes(-240)));
  events2.addEvent(""String_Node_Str"",t0.add(Time.fromMinutes(-220)),t0.add(Time.fromMinutes(-200)));
  events2.addEvent(""String_Node_Str"",t0.add(Time.fromMinutes(-170)),t0.add(Time.fromMinutes(-100)));
  events1.setAggregateNearbyEvents(true);
  events2.setAggregateNearbyEvents(true);
  e0.setEndTimeMoveable(false);
  e1.setResizeable(false);
  e2.setMinTimeSpan(Time.fromMinutes(100));
  e3.setMaxTimeSpan(Time.fromMinutes(500));
  events1.getEventSelectionHandler().setClearSelectionOnClick(true);
  e2.setSelectable(false);
  e2.setFixedRow(2);
  events1.validate();
  TextureAtlas atlas=plot.getTextureAtlas();
  try {
    atlas.loadImage(""String_Node_Str"",ImageIO.read(StreamOpener.fileThenResource.openForRead(""String_Node_Str"")));
    atlas.loadImage(""String_Node_Str"",ImageIO.read(StreamOpener.fileThenResource.openForRead(""String_Node_Str"")));
    atlas.loadImage(""String_Node_Str"",ImageIO.read(StreamOpener.fileThenResource.openForRead(""String_Node_Str"")));
    atlas.loadImage(""String_Node_Str"",ImageIO.read(StreamOpener.fileThenResource.openForRead(""String_Node_Str"")));
  }
 catch (  IOException ex) {
    logWarning(logger,""String_Node_Str"",ex);
  }
  e1.setIconId(""String_Node_Str"");
  e2.setIconId(""String_Node_Str"");
  e3.setIconId(""String_Node_Str"");
  e4.setIconId(""String_Node_Str"");
  plot.getTooltipPainter().setFixedWidth(300);
  e0.setToolTipText(""String_Node_Str"");
  e1.setToolTipText(""String_Node_Str"");
  e2.setToolTipText(""String_Node_Str"");
  e3.setToolTipText(""String_Node_Str"");
  e4.setToolTipText(""String_Node_Str"");
  events1.addEventPlotListener(new EventPlotListener(){
    @Override public void eventsHovered(    GlimpseMouseEvent e,    Set<EventSelection> events,    TimeStamp time){
      if (!events.isEmpty())       logInfo(logger,""String_Node_Str"",events,time);
    }
    @Override public void eventsClicked(    GlimpseMouseEvent e,    Set<EventSelection> events,    TimeStamp time){
      if (!events.isEmpty())       logInfo(logger,""String_Node_Str"",events,time);
    }
    @Override public void eventsExited(    GlimpseMouseEvent e,    Set<EventSelection> events,    TimeStamp time){
      if (!events.isEmpty())       logInfo(logger,""String_Node_Str"",events,time);
    }
    @Override public void eventsEntered(    GlimpseMouseEvent e,    Set<EventSelection> events,    TimeStamp time){
      if (!events.isEmpty())       logInfo(logger,""String_Node_Str"",events,time);
    }
    @Override public void eventUpdated(    GlimpseMouseEvent e,    Event event){
      logInfo(logger,""String_Node_Str"",event);
    }
  }
);
  plot.getEventSelectionHander().addEventSelectionListener(new EventSelectionListener(){
    @Override public void eventsSelected(    Set<Event> selectedEvents,    Set<Event> deselectedEvents){
      logInfo(logger,""String_Node_Str"",selectedEvents,deselectedEvents);
    }
  }
);
  events1.getEventSelectionHandler().setSelectedEventBorderThickness(3.0f);
  plot.setTimeAxisMouseListener(new TaggedAxisMouseListener1D());
  plot.getSelectedTimePainter().setShowLockedStatus(false);
  plot.getTimeAxis().addAxisListener(new TaggedAxisListener1D(){
    @Override public void tagsUpdated(    TaggedAxis1D axis){
      Tag s=plot.getTimeSelectionTag();
      Tag m=plot.getTimeSelectionMaxTag();
      if (s != null && m != null && s.getValue() != m.getValue()) {
        s.setValue(m.getValue());
        plot.getTimeAxis().validateTags();
      }
    }
  }
);
  return plot;
}",0.9976395211600068
11419,"@Override public StackedTimePlot2D getLayout(){
  StackedTimePlot2D plot=createPlot();
  plot.getDefaultTimeline().setTimeZone(TimeZone.getDefault());
  Epoch epoch=plot.getEpoch();
  TimeStamp selectionMaxTime=epoch.getTimeStamp();
  TimeStamp selectionMinTime=selectionMaxTime.subtract(Time.fromHours(3));
  TimeStamp axisMaxTime=selectionMaxTime.add(Time.fromHours(1));
  TimeStamp axisMinTime=selectionMaxTime.subtract(Time.fromHours(20));
  plot.setTimeSelection(selectionMinTime,selectionMaxTime);
  plot.setTimeAxisBounds(axisMinTime,axisMaxTime);
  plot.setPlotSpacing(2);
  plot.setBorderSize(4);
  TimePlotInfo plot1=plot.createTimePlot(""String_Node_Str"");
  TimePlotInfo plot2=plot.createTimePlot(""String_Node_Str"");
  plot1.setLabelText(""String_Node_Str"");
  plot2.setLabelText(""String_Node_Str"");
  plot.setLabelSize(30);
  plot.showLabels(true);
  plot1.getLabelPainter().setHorizontalLabels(false);
  plot2.getLabelPainter().setHorizontalLabels(false);
  setChartData(plot1,epoch,axisMinTime,axisMaxTime);
  setChartData(plot2,epoch,axisMinTime,axisMaxTime);
  addMouseListener(epoch,plot1);
  addMouseListener(epoch,plot2);
  return plot;
}","@Override public StackedTimePlot2D getLayout(){
  StackedTimePlot2D plot=createPlot();
  plot.getDefaultTimeline().setTimeZone(TimeZone.getDefault());
  Epoch epoch=plot.getEpoch();
  TimeStamp selectionMaxTime=epoch.getTimeStamp();
  TimeStamp selectionMinTime=selectionMaxTime.subtract(Time.fromHours(3));
  TimeStamp axisMaxTime=selectionMaxTime.add(Time.fromHours(1));
  TimeStamp axisMinTime=selectionMaxTime.subtract(Time.fromHours(20));
  plot.setTimeSelection(selectionMinTime,selectionMaxTime);
  plot.setTimeAxisBounds(axisMinTime,axisMaxTime);
  plot.setPlotSpacing(2);
  plot.setBorderSize(4);
  TimePlotInfo plot1=plot.createTimePlot(""String_Node_Str"");
  TimePlotInfo plot2=plot.createTimePlot(""String_Node_Str"");
  plot1.setLabelText(""String_Node_Str"");
  plot2.setLabelText(""String_Node_Str"");
  plot.setLabelSize(30);
  plot.setShowLabels(true);
  plot1.getLabelPainter().setHorizontalLabels(false);
  plot2.getLabelPainter().setHorizontalLabels(false);
  setChartData(plot1,epoch,axisMinTime,axisMaxTime);
  setChartData(plot2,epoch,axisMinTime,axisMaxTime);
  addMouseListener(epoch,plot1);
  addMouseListener(epoch,plot2);
  return plot;
}",0.9987041036717064
11420,"@Override public StackedTimePlot2D getLayout(){
  final CollapsibleTimePlot2D plot=(CollapsibleTimePlot2D)super.getLayout();
  TimePlotInfo speedPlot=plot.getTimePlot(""String_Node_Str"");
  speedPlot.setLabelText(""String_Node_Str"");
  TimePlotInfo viscPlot=plot.getTimePlot(""String_Node_Str"");
  viscPlot.setLabelText(""String_Node_Str"");
  TimePlotInfo plot3=plot.createTimePlot();
  plot3.setLabelText(""String_Node_Str"");
  TimePlotInfo plot4=plot.createTimePlot();
  plot4.setLabelText(""String_Node_Str"");
  TimePlotInfo plot5=plot.createTimePlot();
  plot5.setLabelText(""String_Node_Str"");
  GroupInfo group5=plot.createGroup(plot4);
  group5.setLabelText(""String_Node_Str"");
  GroupInfo group1=plot.createGroup();
  group1.setLabelText(""String_Node_Str"");
  group1.addChildPlot(speedPlot);
  group1.addChildPlot(group5);
  GroupInfo group4=plot.createGroup(plot5);
  group4.setLabelText(""String_Node_Str"");
  GroupInfo group2=plot.createGroup();
  group2.setLabelText(""String_Node_Str"");
  group2.addChildPlot(group1);
  group2.addChildPlot(viscPlot);
  group2.addChildPlot(group4);
  GroupInfo group3=plot.createGroup(plot3);
  group3.setLabelText(""String_Node_Str"");
  plot.setIndentSubplots(true);
  GroupInfo g=plot.createGroup();
  g.setLabelText(""String_Node_Str"");
  group5.addChildPlot(g);
  return plot;
}","@Override public StackedTimePlot2D getLayout(){
  final CollapsibleTimePlot2D plot=new CollapsibleTimePlot2D();
  plot.setShowLabels(true);
  plot.setLabelSize(30);
  plot.setIndentSubplots(true);
  plot.setIndentSize(30);
  GroupInfo topGroup1=plot.createGroup();
  topGroup1.setLabelText(""String_Node_Str"");
  topGroup1.setShowDivider(false);
  GroupInfo topGroup2=plot.createGroup();
  topGroup2.setLabelText(""String_Node_Str"");
  topGroup2.setShowDivider(false);
  GroupInfo midGroup1=plot.createGroup();
  midGroup1.setLabelText(""String_Node_Str"");
  midGroup1.setShowDivider(false);
  topGroup1.addChildPlot(midGroup1);
  TimePlotInfo plot1=plot.createTimePlot();
  plot1.setLabelText(""String_Node_Str"");
  midGroup1.addChildPlot(plot1);
  TimePlotInfo plot2=plot.createTimePlot();
  plot2.setLabelText(""String_Node_Str"");
  midGroup1.addChildPlot(plot2);
  GroupInfo midGroup2=plot.createGroup();
  midGroup2.setLabelText(""String_Node_Str"");
  midGroup2.setShowDivider(false);
  topGroup1.addChildPlot(midGroup2);
  TimePlotInfo plot3=plot.createTimePlot();
  plot3.setLabelText(""String_Node_Str"");
  midGroup2.addChildPlot(plot3);
  GroupInfo midGroup3=plot.createGroup();
  midGroup3.setLabelText(""String_Node_Str"");
  midGroup3.setShowDivider(false);
  topGroup1.addChildPlot(midGroup3);
  TimePlotInfo plot4=plot.createTimePlot();
  plot4.setLabelText(""String_Node_Str"");
  midGroup3.addChildPlot(plot4);
  TimePlotInfo plot5=plot.createTimePlot();
  plot5.setLabelText(""String_Node_Str"");
  midGroup3.addChildPlot(plot5);
  GroupInfo midGroup4=plot.createGroup();
  midGroup4.setLabelText(""String_Node_Str"");
  midGroup4.setShowDivider(false);
  topGroup2.addChildPlot(midGroup4);
  TimePlotInfo plot6=plot.createTimePlot();
  plot6.setLabelText(""String_Node_Str"");
  midGroup4.addChildPlot(plot6);
  return plot;
}",0.3282442748091603
11421,"protected int getOverlayLayoutOffsetX2(){
  return 0;
}","public int getOverlayLayoutOffsetX2(){
  return 0;
}",0.897196261682243
11422,"protected int getOverlayLayoutOffsetY(){
  return 0;
}","public int getOverlayLayoutOffsetY(){
  return 0;
}",0.8952380952380953
11423,"protected int getOverlayLayoutOffsetX(){
  return 0;
}","public int getOverlayLayoutOffsetX(){
  return 0;
}",0.8952380952380953
11424,"protected int getOverlayLayoutOffsetY2(){
  return 0;
}","public int getOverlayLayoutOffsetY2(){
  return 0;
}",0.897196261682243
11425,"@Override protected void setRowColumnConstraints(){
  int tempIndentSize=getIndentSize();
  if (indentSubplots) {
    int maxLevel=setIndentLevel0();
    setRowColumnConstraints(maxLevel,tempIndentSize);
  }
 else {
    resetIndentLevel0(0);
    setRowColumnConstraints(0,tempIndentSize);
  }
}","@Override protected void setRowColumnConstraints(){
  int tempIndentSize=getIndentSize();
  if (this.indentSubplots) {
    this.maxLevel=setIndentLevel0() + 1;
    setRowColumnConstraints(maxLevel,tempIndentSize);
  }
 else {
    this.maxLevel=1;
    resetIndentLevel0(0);
    setRowColumnConstraints(0,tempIndentSize);
  }
}",0.936995153473344
11426,"@Override protected int getOverlayLayoutOffsetX(){
  return orient == VERTICAL ? getLabelSize() : 0;
}","@Override public int getOverlayLayoutOffsetX(){
  return orient == VERTICAL ? getLabelSize() : 0;
}",0.945273631840796
11427,"@Override protected int getOverlayLayoutOffsetY2(){
  return orient == VERTICAL ? 0 : getLabelSize();
}","@Override public int getOverlayLayoutOffsetY2(){
  return orient == VERTICAL ? 0 : getLabelSize();
}",0.9458128078817734
11428,"public void showLabels(boolean show){
  this.showLabelLayout=show;
  this.validateLayout();
}","/** 
 * Method name changed to be more consistent with other setters.
 * @deprecated {@link #setShowLabels(boolean)}
 */
public void showLabels(boolean show){
  this.setShowLabels(show);
}",0.4412811387900356
11429,"@Override protected void paintTo(GlimpseContext context,GlimpseBounds bounds){
  this.textDelegate.paintTo(context);
  int width=bounds.getWidth();
  int height=bounds.getHeight();
  GL2 gl=context.getGL().getGL2();
  gl.glMatrixMode(GL_PROJECTION);
  gl.glLoadIdentity();
  gl.glOrtho(0,bounds.getWidth(),0,bounds.getHeight(),-1,1);
  gl.glMatrixMode(GL_MODELVIEW);
  gl.glLoadIdentity();
  if (showDivider) {
    Rectangle2D textBounds=this.textDelegate.getTextBounds();
    float startY=(float)height / 2.0f;
    float startX=(float)(padding + this.textDelegate.getHorizontalPadding() + textBounds.getWidth()+ (textBounds.getMinX()) - 1);
    gl.glLineWidth(1.0f);
    GlimpseColor.glColor(gl,lineColor);
    gl.glBegin(GL2.GL_LINES);
    try {
      gl.glVertex2f(startX,startY);
      gl.glVertex2f(width,startY);
    }
  finally {
      gl.glEnd();
    }
  }
  if (showArrow) {
    float halfSize=buttonSize / 2.0f;
    float centerX=halfSize + padding;
    float centerY=height / 2.0f;
    gl.glBegin(GL2.GL_POLYGON);
    try {
      if (isExpanded) {
        gl.glVertex2f(centerX - halfSize,centerY + halfSize);
        gl.glVertex2f(centerX + halfSize,centerY + halfSize);
        gl.glVertex2f(centerX,centerY - halfSize);
      }
 else {
        gl.glVertex2f(centerX - halfSize,centerY - halfSize);
        gl.glVertex2f(centerX - halfSize,centerY + halfSize);
        gl.glVertex2f(centerX + halfSize,centerY);
      }
    }
  finally {
      gl.glEnd();
    }
  }
}","@Override protected void paintTo(GlimpseContext context,GlimpseBounds bounds){
  this.textDelegate.paintTo(context);
  int width=bounds.getWidth();
  int height=bounds.getHeight();
  GL2 gl=context.getGL().getGL2();
  gl.glMatrixMode(GL_PROJECTION);
  gl.glLoadIdentity();
  gl.glOrtho(0,bounds.getWidth(),0,bounds.getHeight(),-1,1);
  gl.glMatrixMode(GL_MODELVIEW);
  gl.glLoadIdentity();
  if (showDivider) {
    Rectangle2D textBounds=this.textDelegate.getTextBounds();
    float startY=(float)height / 2.0f;
    float startX=(float)(padding + this.textDelegate.getHorizontalPadding() + textBounds.getWidth()+ (textBounds.getMinX()) - 1);
    gl.glLineWidth(1.0f);
    GlimpseColor.glColor(gl,lineColor);
    gl.glBegin(GL2.GL_LINES);
    try {
      gl.glVertex2f(startX,startY);
      gl.glVertex2f(width,startY);
    }
  finally {
      gl.glEnd();
    }
  }
  if (showArrow) {
    gl.glLineWidth(1.0f);
    GlimpseColor.glColor(gl,lineColor);
    float halfSize=buttonSize / 2.0f;
    float centerX=halfSize + padding;
    float centerY=height / 2.0f;
    gl.glBegin(GL2.GL_POLYGON);
    try {
      if (isExpanded) {
        gl.glVertex2f(centerX - halfSize,centerY + halfSize);
        gl.glVertex2f(centerX + halfSize,centerY + halfSize);
        gl.glVertex2f(centerX,centerY - halfSize);
      }
 else {
        gl.glVertex2f(centerX - halfSize,centerY - halfSize);
        gl.glVertex2f(centerX - halfSize,centerY + halfSize);
        gl.glVertex2f(centerX + halfSize,centerY);
      }
    }
  finally {
      gl.glEnd();
    }
  }
}",0.9781890284203568
11430,"@Override public void updateLayout(int index){
  super.updateLayout(index);
  StackedTimePlot2D parent=getStackedTimePlot();
  int labelSize=parent.isShowLabels() ? parent.getLabelSize() : 0;
  if (parent.isTimeAxisHorizontal()) {
    plotLayout.setLayoutData(""String_Node_Str"");
    labelLayout.setLayoutData(String.format(""String_Node_Str"",labelSize));
    labelLayout.setVisible(parent.isShowLabels());
  }
 else {
    plotLayout.setLayoutData(""String_Node_Str"");
    labelLayout.setLayoutData(String.format(""String_Node_Str"",labelSize));
    labelLayout.setVisible(parent.isShowLabels());
  }
}","@Override public void updateLayout(int index){
  super.updateLayout(index);
  StackedTimePlot2D parent=getStackedTimePlot();
  int labelSize;
  if (parent instanceof CollapsibleTimePlot2D) {
    CollapsibleTimePlot2D collapsible=((CollapsibleTimePlot2D)parent);
    labelSize=(collapsible.getMaxLevel() - getIndentLevel()) * collapsible.getIndentSize();
  }
 else {
    labelSize=parent.isShowLabels() ? parent.getLabelSize() : 0;
  }
  if (parent.isTimeAxisHorizontal()) {
    plotLayout.setLayoutData(""String_Node_Str"");
    labelLayout.setLayoutData(String.format(""String_Node_Str"",labelSize));
    labelLayout.setVisible(parent.isShowLabels());
  }
 else {
    plotLayout.setLayoutData(""String_Node_Str"");
    labelLayout.setLayoutData(String.format(""String_Node_Str"",labelSize));
    labelLayout.setVisible(parent.isShowLabels());
  }
}",0.8311327310632384
11431,"@Override public void updateLayout(int index){
  super.updateLayout(index);
  if (timeLayout == null)   return;
  if (plot.isTimeAxisHorizontal()) {
    timeLayout.setLayoutData(String.format(""String_Node_Str"",plot.getLabelSize()));
  }
 else {
    timeLayout.setLayoutData(String.format(""String_Node_Str"",plot.getLabelSize()));
  }
}","@Override public void updateLayout(int index){
  super.updateLayout(index);
  if (timeLayout == null)   return;
  if (plot.isTimeAxisHorizontal()) {
    timeLayout.setLayoutData(String.format(""String_Node_Str"",plot.getOverlayLayoutOffsetX()));
  }
 else {
    timeLayout.setLayoutData(String.format(""String_Node_Str"",plot.getOverlayLayoutOffsetY2()));
  }
}",0.914616497829233
11432,"public Collection<Axis1D> getAxis(TargetStackMatcher matcher){
  return this.cache.getMatching(matcher);
}","public synchronized Collection<Axis1D> getAxis(TargetStackMatcher matcher){
  return this.cache.getMatching(matcher);
}",0.9422222222222222
11433,"public void clearCache(){
  this.cache.clear();
  for (  GlimpseTarget target : getTargetChildren()) {
    if (target instanceof GlimpseAxisLayout1D) {
      GlimpseAxisLayout1D layout=(GlimpseAxisLayout1D)target;
      if (!layout.isAxisSet()) {
        layout.clearCache();
      }
    }
  }
}","public synchronized void clearCache(){
  for (  Axis1D axis : this.cache.getValues()) {
    axis.setParent(null);
  }
  this.cache.clear();
  for (  GlimpseTarget target : getTargetChildren()) {
    if (target instanceof GlimpseAxisLayout1D) {
      GlimpseAxisLayout1D layout=(GlimpseAxisLayout1D)target;
      if (!layout.isAxisSet()) {
        layout.clearCache();
      }
    }
  }
}",0.4662756598240469
11434,"public void setAxis(GlimpseContext context,Axis1D axis){
  cache.setValue(context,axis);
}","public synchronized void setAxis(GlimpseContext context,Axis1D axis){
  this.cache.setValue(context,axis);
}",0.9090909090909092
11435,"public Collection<Axis2D> getAxis(TargetStackMatcher matcher){
  return this.cache.getMatching(matcher);
}","public synchronized Collection<Axis2D> getAxis(TargetStackMatcher matcher){
  return this.cache.getMatching(matcher);
}",0.9422222222222222
11436,"public void clearCache(){
  this.cache.clear();
  for (  GlimpseTarget target : getTargetChildren()) {
    if (target instanceof GlimpseAxisLayout1D) {
      GlimpseAxisLayout1D layout=(GlimpseAxisLayout1D)target;
      if (!layout.isAxisSet()) {
        layout.clearCache();
      }
    }
 else     if (target instanceof GlimpseAxisLayout2D) {
      GlimpseAxisLayout2D layout=(GlimpseAxisLayout2D)target;
      if (!layout.isAxisSet()) {
        layout.clearCache();
      }
    }
  }
}","public synchronized void clearCache(){
  for (  Axis2D axis : this.cache.getValues()) {
    axis.setParent(null);
  }
  this.cache.clear();
  for (  GlimpseTarget target : getTargetChildren()) {
    if (target instanceof GlimpseAxisLayout1D) {
      GlimpseAxisLayout1D layout=(GlimpseAxisLayout1D)target;
      if (!layout.isAxisSet()) {
        layout.clearCache();
      }
    }
 else     if (target instanceof GlimpseAxisLayout2D) {
      GlimpseAxisLayout2D layout=(GlimpseAxisLayout2D)target;
      if (!layout.isAxisSet()) {
        layout.clearCache();
      }
    }
  }
}",0.8820224719101124
11437,"public void setAxis(GlimpseContext context,Axis2D axis){
  cache.setValue(context,axis);
}","public synchronized void setAxis(GlimpseContext context,Axis2D axis){
  this.cache.setValue(context,axis);
}",0.9090909090909092
11438,"protected Collection<PlotInfo> getTopPlots(){
  List<PlotInfo> plots=Lists.newArrayList();
  for (  PlotInfo plot : plot.getAllPlots()) {
    if (plot.getParent() == null) {
      plots.add(plot);
    }
  }
  return plots;
}","protected Collection<PlotInfo> getTopPlots(){
  List<PlotInfo> plots=Lists.newArrayList();
  for (  PlotInfo plot : this.plot.getAllPlots()) {
    if (plot.getParent() == null) {
      plots.add(plot);
    }
  }
  return plots;
}",0.9889624724061812
11439,"@Override public void paint(final GL2 gl,final EventPlotInfo info,final GlimpseBounds bounds,final Axis1D timeAxis,final Collection<EventDrawInfo> events){
  final StackedTimePlot2D plot=info.getStackedTimePlot();
  final int height=bounds.getHeight();
  final int width=bounds.getWidth();
  final Orientation orient=plot.getOrientation();
  final int size=orient == Orientation.HORIZONTAL ? height : width;
  final int buffer=info.getEventPadding();
  List<IconDrawInfo> iconDrawList=Lists.newArrayList();
  List<TextDrawInfo> textDrawList=Lists.newArrayList();
  FloatBuffer fillBuffer=Buffers.newDirectFloatBuffer(events.size() * 6 * 2);
  FloatBuffer borderBuffer=Buffers.newDirectFloatBuffer(events.size() * 6 * 2);
  FloatBuffer fillColorBuffer=Buffers.newDirectFloatBuffer(events.size() * 6 * 4);
  FloatBuffer borderColorBuffer=Buffers.newDirectFloatBuffer(events.size() * 6 * 4);
  IntBuffer fillCounts=Buffers.newDirectIntBuffer(events.size());
  IntBuffer borderCounts=Buffers.newDirectIntBuffer(events.size());
  IntBuffer fillIndices=Buffers.newDirectIntBuffer(events.size());
  IntBuffer borderIndices=Buffers.newDirectIntBuffer(events.size());
  int fillIndex=0;
  int borderIndex=0;
  int fillCount=0;
  int borderCount=0;
  Object defaultIconId=info.getDefaultIconId();
  TextureAtlas atlas=info.getTextureAtlas();
  TextRenderer textRenderer=info.getTextRenderer();
  boolean horiz=plot.isTimeAxisHorizontal();
  for (  EventDrawInfo eventInfo : events) {
    int posMax=eventInfo.posMax;
    int posMin=eventInfo.posMin;
    Event event=eventInfo.event;
    Event nextEvent=eventInfo.nextEvent;
    int sizePerpPixels=posMax - posMin;
    double sizePerpCenter=posMin + sizePerpPixels / 2.0;
    int arrowSize=Math.min(sizePerpPixels,ARROW_SIZE);
    Epoch epoch=plot.getEpoch();
    double timeMin=epoch.fromTimeStamp(event.getStartTime());
    double timeMax=epoch.fromTimeStamp(event.getEndTime());
    double arrowBaseMin=timeMin;
    boolean offEdgeMin=false;
    if (timeAxis.getMin() > timeMin) {
      offEdgeMin=true;
      timeMin=timeAxis.getMin() + ARROW_TIP_BUFFER / timeAxis.getPixelsPerValue();
      arrowBaseMin=timeMin + arrowSize / timeAxis.getPixelsPerValue();
    }
    double arrowBaseMax=timeMax;
    boolean offEdgeMax=false;
    if (timeAxis.getMax() < timeMax) {
      offEdgeMax=true;
      timeMax=timeAxis.getMax() - ARROW_TIP_BUFFER / timeAxis.getPixelsPerValue();
      arrowBaseMax=timeMax - arrowSize / timeAxis.getPixelsPerValue();
    }
    arrowBaseMax=Math.max(timeMin,arrowBaseMax);
    arrowBaseMin=Math.min(timeMax,arrowBaseMin);
    double timeSpan=arrowBaseMax - arrowBaseMin;
    double remainingSpace=timeAxis.getPixelsPerValue() * timeSpan - buffer * 2;
    int pixel=buffer + (offEdgeMin ? arrowSize : 0) + Math.max(0,timeAxis.valueToScreenPixel(timeMin));
    double nextStartValue=nextEvent != null ? epoch.fromTimeStamp(nextEvent.getStartTime()) : timeAxis.getMax();
    int nextStartPixel=nextEvent != null ? timeAxis.valueToScreenPixel(nextStartValue) : size;
    EventSelectionHandler selectionHandler=info.getEventSelectionHandler();
    boolean highlightSelected=selectionHandler.isHighlightSelectedEvents();
    boolean isSelected=highlightSelected ? selectionHandler.isEventSelected(event) : false;
    EventBounds eventBounds=info.getEventBounds(event.getId());
    if (!offEdgeMin && !offEdgeMax) {
      if (event.isShowBackground()) {
        float[] color=getBackgroundColor(event,info,isSelected);
        fillIndex=addVerticesBox(fillCounts,fillIndices,fillIndex,fillBuffer,fillColorBuffer,horiz,color,(float)timeMin,(float)timeMax,(float)posMin,(float)posMax);
        fillCount++;
      }
      if (event.isShowBorder()) {
        float[] color=getBorderColor(event,info,isSelected);
        borderIndex=addVerticesBox(borderCounts,borderIndices,borderIndex,borderBuffer,borderColorBuffer,horiz,color,(float)timeMin,(float)timeMax,(float)posMin,(float)posMax);
        borderCount++;
      }
    }
 else {
      if (event.isShowBackground()) {
        float[] color=getBackgroundColor(event,info,isSelected);
        fillIndex=addVerticesArrow(fillCounts,fillIndices,fillIndex,fillBuffer,fillColorBuffer,horiz,color,(float)timeMin,(float)timeMax,(float)posMin,(float)posMax,(float)arrowBaseMin,(float)arrowBaseMax,(float)sizePerpCenter);
        fillCount++;
      }
      if (event.isShowBorder()) {
        float[] color=getBorderColor(event,info,isSelected);
        borderIndex=addVerticesArrow(borderCounts,borderIndices,borderIndex,borderBuffer,borderColorBuffer,horiz,color,(float)timeMin,(float)timeMax,(float)posMin,(float)posMax,(float)arrowBaseMin,(float)arrowBaseMax,(float)sizePerpCenter);
        borderCount++;
      }
    }
    int totalIconSizePerpPixels=getIconSizePerpPixels(event,info,sizePerpPixels);
    if (event.hasChildren()) {
      final int numChildren=event.getEventCount();
      final int numRows=maxIconRows;
      int iconSizePerpPixels=totalIconSizePerpPixels / numRows;
      int columnsByAvailableSpace=(int)Math.floor(remainingSpace / (double)iconSizePerpPixels);
      int columnsByNumberOfIcons=(int)Math.ceil(numChildren / (double)numRows);
      int numColumns=(int)Math.min(columnsByAvailableSpace,columnsByNumberOfIcons);
      double iconSizePerpValue=iconSizePerpPixels / timeAxis.getPixelsPerValue();
      int totalIconWidthPixels=iconSizePerpPixels * numColumns;
      eventBounds.setIconVisible(event.isShowIcon() && !isIconOverlapping(totalIconWidthPixels,0,remainingSpace,pixel,nextStartPixel,event.getOverlapRenderingMode()));
      if (eventBounds.isIconVisible()) {
        double value=timeAxis.screenPixelToValue(pixel);
        eventBounds.setIconStartTime(epoch.toTimeStamp(value));
        eventBounds.setIconEndTime(eventBounds.getIconStartTime().add(totalIconWidthPixels / timeAxis.getPixelsPerValue()));
        Iterator<Event> iter=event.iterator();
        outer:         for (int c=0; c < numColumns; c++) {
          for (int r=numRows - 1; r >= 0; r--) {
            if (iter.hasNext()) {
              Event child=iter.next();
              Object icon=child.getIconId();
              if (icon == null || !atlas.isImageLoaded(icon)) {
                GlimpseColor.glColor(gl,getBackgroundColor(child,info,isSelected),0.5f);
                icon=defaultIconId;
              }
 else {
                GlimpseColor.glColor(gl,GlimpseColor.getWhite());
              }
              if (atlas.isImageLoaded(icon)) {
                ImageData iconData=atlas.getImageData(icon);
                int iconSizePerp=horiz ? iconData.getHeight() : iconData.getWidth();
                double iconScale=iconSizePerpPixels / (double)iconSizePerp;
                double x=value + c * iconSizePerpValue;
                double startY=sizePerpCenter - totalIconSizePerpPixels / 2.0;
                double y=startY + r * iconSizePerpPixels;
                if (horiz) {
                  iconDrawList.add(new IconDrawInfo(icon,x,y,iconScale,iconScale,0,iconSizePerp,true));
                }
 else {
                  iconDrawList.add(new IconDrawInfo(icon,x,y,iconScale,iconScale,0,iconSizePerp,false));
                }
              }
            }
 else {
              break outer;
            }
          }
        }
        remainingSpace-=totalIconWidthPixels + buffer;
        pixel+=totalIconWidthPixels + buffer;
      }
    }
 else {
      boolean isOverlapping=isIconOverlapping(totalIconSizePerpPixels,buffer,remainingSpace,pixel,nextStartPixel,event.getOverlapRenderingMode());
      eventBounds.setIconVisible(event.isShowIcon() && event.getIconId() != null && !isOverlapping);
      if (eventBounds.isIconVisible()) {
        Object icon=event.getIconId();
        if (icon == null || !atlas.isImageLoaded(icon)) {
          icon=defaultIconId;
        }
        if (atlas.isImageLoaded(icon)) {
          ImageData iconData=atlas.getImageData(icon);
          int iconSizePerp=horiz ? iconData.getHeight() : iconData.getWidth();
          int iconSizeTime=horiz ? iconData.getWidth() : iconData.getHeight();
          int iconSizePerpPixels=getIconSizePerpPixels(event,info,sizePerpPixels);
          double iconScale=iconSizePerpPixels / (double)iconSizePerp;
          double posTime=timeAxis.screenPixelToValue(pixel);
          eventBounds.setIconStartTime(epoch.toTimeStamp(posTime));
          double iconSizeTimeAxis=iconSizeTime / timeAxis.getPixelsPerValue();
          eventBounds.setIconEndTime(eventBounds.getIconStartTime().add(iconSizeTimeAxis));
          int iconSizeTimeScaledPixels=(int)(iconSizeTime * iconScale);
          double posPerp=sizePerpCenter - iconSizePerpPixels / 2.0;
          if (horiz) {
            iconDrawList.add(new IconDrawInfo(icon,posTime,posPerp,iconScale,iconScale,0,iconSizePerp,true));
          }
 else {
            iconDrawList.add(new IconDrawInfo(icon,posPerp,posTime,iconScale,iconScale,0,iconSizePerp,false));
          }
          remainingSpace-=iconSizeTimeScaledPixels + buffer;
          pixel+=iconSizeTimeScaledPixels + buffer;
        }
      }
    }
    if (event.isShowLabel() && event.getLabel() != null) {
      Rectangle2D labelBounds=textRenderer.getBounds(event.getLabel());
      boolean isTextOverfull=isTextOverfull(sizePerpPixels,buffer,remainingSpace,pixel,nextStartPixel,labelBounds,event.getOverlapRenderingMode());
      boolean isTextIntersecting=isTextIntersecting(sizePerpPixels,buffer,remainingSpace,pixel,nextStartPixel,labelBounds,event.getOverlapRenderingMode());
      boolean isTextOverlappingAndHidden=((isTextOverfull || isTextIntersecting) && event.getTextRenderingMode() == TextRenderingMode.HideAll);
      double availableSpace=getTextAvailableSpace(sizePerpPixels,buffer,remainingSpace,pixel,nextStartPixel,event.getOverlapRenderingMode());
      eventBounds.setTextVisible(!isTextOverlappingAndHidden);
      if (eventBounds.isTextVisible()) {
        Rectangle2D displayBounds=labelBounds;
        String displayText=event.getLabel();
        if (labelBounds.getWidth() > availableSpace && event.getTextRenderingMode() != TextRenderingMode.ShowAll) {
          displayText=calculateDisplayText(textRenderer,displayText,availableSpace);
          displayBounds=textRenderer.getBounds(displayText);
        }
        double value=timeAxis.screenPixelToValue(pixel);
        eventBounds.setTextStartTime(epoch.toTimeStamp(value));
        eventBounds.setTextEndTime(eventBounds.getTextStartTime().add(displayBounds.getWidth() / timeAxis.getPixelsPerValue()));
        float[] color;
        if (event.getLabelColor() != null) {
          color=event.getLabelColor();
        }
 else         if (!info.isTextColorSet() && !event.isShowBackground()) {
          color=info.getTextColorNoBackground();
        }
 else {
          color=info.getTextColor();
        }
        if (horiz) {
          int pixelY=(int)(sizePerpPixels / 2.0 - labelBounds.getHeight() * 0.3 + posMin);
          textDrawList.add(new TextDrawInfo(displayText,color,pixel,pixelY,0,0));
          remainingSpace-=displayBounds.getWidth() + buffer;
          pixel+=displayBounds.getWidth() + buffer;
        }
 else {
          double shiftX=sizePerpPixels / 2.0 + posMin;
          int pixelX=(int)shiftX;
          double shiftY=pixel;
          int pixelY=(int)(pixel - labelBounds.getHeight() * 0.34);
          textDrawList.add(new TextDrawInfo(displayText,color,pixelX,pixelY,shiftX,shiftY));
          remainingSpace-=displayBounds.getWidth() + buffer;
          pixel+=displayBounds.getWidth() + buffer;
        }
      }
    }
  }
  if (fillCount > 0) {
    gl.glEnableClientState(GL2.GL_COLOR_ARRAY);
    gl.glEnableClientState(GL2.GL_VERTEX_ARRAY);
    fillBuffer.flip();
    fillColorBuffer.flip();
    fillIndices.flip();
    fillCounts.flip();
    gl.glVertexPointer(2,GL.GL_FLOAT,0,fillBuffer);
    gl.glColorPointer(4,GL.GL_FLOAT,0,fillColorBuffer);
    gl.glMultiDrawArrays(GL2.GL_LINE_LOOP,fillIndices,fillCounts,fillCount);
    gl.glDisableClientState(GL2.GL_COLOR_ARRAY);
    gl.glDisableClientState(GL2.GL_VERTEX_ARRAY);
  }
  if (borderCount > 0) {
    gl.glEnableClientState(GL2.GL_COLOR_ARRAY);
    gl.glEnableClientState(GL2.GL_VERTEX_ARRAY);
    borderBuffer.flip();
    borderColorBuffer.flip();
    borderIndices.flip();
    borderCounts.flip();
    gl.glVertexPointer(2,GL.GL_FLOAT,0,borderBuffer);
    gl.glColorPointer(4,GL.GL_FLOAT,0,borderColorBuffer);
    gl.glMultiDrawArrays(GL2.GL_POLYGON,borderIndices,borderCounts,borderCount);
    gl.glDisableClientState(GL2.GL_COLOR_ARRAY);
    gl.glDisableClientState(GL2.GL_VERTEX_ARRAY);
  }
  if (!iconDrawList.isEmpty()) {
    atlas.beginRendering();
    try {
      for (      IconDrawInfo iconInfo : iconDrawList) {
        if (iconInfo.isX()) {
          atlas.drawImageAxisX(gl,iconInfo.id,timeAxis,iconInfo.positionX,iconInfo.positionY,iconInfo.scaleX,iconInfo.scaleY,iconInfo.centerX,iconInfo.centerY);
        }
 else {
          atlas.drawImageAxisY(gl,iconInfo.id,timeAxis,iconInfo.positionX,iconInfo.positionY,iconInfo.scaleX,iconInfo.scaleY,iconInfo.centerX,iconInfo.centerY);
        }
      }
    }
  finally {
      atlas.endRendering();
    }
  }
  if (!textDrawList.isEmpty()) {
    textRenderer.beginRendering(width,height);
    try {
      for (      TextDrawInfo textInfo : textDrawList) {
        if (!horiz) {
          gl.glMatrixMode(GL2.GL_PROJECTION);
          gl.glTranslated(textInfo.getShiftX(),textInfo.getShiftY(),0);
          gl.glRotated(90,0,0,1.0f);
          gl.glTranslated(-textInfo.getShiftX(),-textInfo.getShiftY(),0);
        }
        GlimpseColor.setColor(textRenderer,textInfo.getColor());
        textRenderer.draw(textInfo.getText(),textInfo.getX(),textInfo.getY());
      }
    }
  finally {
      textRenderer.endRendering();
    }
  }
}","@Override public void paint(final GL2 gl,final EventPlotInfo info,final GlimpseBounds bounds,final Axis1D timeAxis,final Collection<EventDrawInfo> events){
  final StackedTimePlot2D plot=info.getStackedTimePlot();
  final int height=bounds.getHeight();
  final int width=bounds.getWidth();
  final Orientation orient=plot.getOrientation();
  final int size=orient == Orientation.HORIZONTAL ? height : width;
  final int buffer=info.getEventPadding();
  List<IconDrawInfo> iconDrawList=Lists.newArrayList();
  List<TextDrawInfo> textDrawList=Lists.newArrayList();
  FloatBuffer fillBuffer=Buffers.newDirectFloatBuffer(events.size() * 6 * 2);
  FloatBuffer borderBuffer=Buffers.newDirectFloatBuffer(events.size() * 6 * 2);
  FloatBuffer fillColorBuffer=Buffers.newDirectFloatBuffer(events.size() * 6 * 4);
  FloatBuffer borderColorBuffer=Buffers.newDirectFloatBuffer(events.size() * 6 * 4);
  IntBuffer fillCounts=Buffers.newDirectIntBuffer(events.size());
  IntBuffer borderCounts=Buffers.newDirectIntBuffer(events.size());
  IntBuffer fillIndices=Buffers.newDirectIntBuffer(events.size());
  IntBuffer borderIndices=Buffers.newDirectIntBuffer(events.size());
  int fillIndex=0;
  int borderIndex=0;
  int fillCount=0;
  int borderCount=0;
  Object defaultIconId=info.getDefaultIconId();
  TextureAtlas atlas=info.getTextureAtlas();
  TextRenderer textRenderer=info.getTextRenderer();
  boolean horiz=plot.isTimeAxisHorizontal();
  for (  EventDrawInfo eventInfo : events) {
    int posMax=eventInfo.posMax;
    int posMin=eventInfo.posMin;
    Event event=eventInfo.event;
    Event nextEvent=eventInfo.nextEvent;
    int sizePerpPixels=posMax - posMin;
    double sizePerpCenter=posMin + sizePerpPixels / 2.0;
    int arrowSize=Math.min(sizePerpPixels,ARROW_SIZE);
    Epoch epoch=plot.getEpoch();
    double timeMin=epoch.fromTimeStamp(event.getStartTime());
    double timeMax=epoch.fromTimeStamp(event.getEndTime());
    double arrowBaseMin=timeMin;
    boolean offEdgeMin=false;
    if (timeAxis.getMin() > timeMin) {
      offEdgeMin=true;
      timeMin=timeAxis.getMin() + ARROW_TIP_BUFFER / timeAxis.getPixelsPerValue();
      arrowBaseMin=timeMin + arrowSize / timeAxis.getPixelsPerValue();
    }
    double arrowBaseMax=timeMax;
    boolean offEdgeMax=false;
    if (timeAxis.getMax() < timeMax) {
      offEdgeMax=true;
      timeMax=timeAxis.getMax() - ARROW_TIP_BUFFER / timeAxis.getPixelsPerValue();
      arrowBaseMax=timeMax - arrowSize / timeAxis.getPixelsPerValue();
    }
    arrowBaseMax=Math.max(timeMin,arrowBaseMax);
    arrowBaseMin=Math.min(timeMax,arrowBaseMin);
    double timeSpan=arrowBaseMax - arrowBaseMin;
    double remainingSpace=timeAxis.getPixelsPerValue() * timeSpan - buffer * 2;
    int pixel=buffer + (offEdgeMin ? arrowSize : 0) + Math.max(0,timeAxis.valueToScreenPixel(timeMin));
    double nextStartValue=nextEvent != null ? epoch.fromTimeStamp(nextEvent.getStartTime()) : timeAxis.getMax();
    int nextStartPixel=nextEvent != null ? timeAxis.valueToScreenPixel(nextStartValue) : size;
    EventSelectionHandler selectionHandler=info.getEventSelectionHandler();
    boolean highlightSelected=selectionHandler.isHighlightSelectedEvents();
    boolean isSelected=highlightSelected ? selectionHandler.isEventSelected(event) : false;
    EventBounds eventBounds=info.getEventBounds(event.getId());
    if (!offEdgeMin && !offEdgeMax) {
      if (event.isShowBackground()) {
        float[] color=getBackgroundColor(event,info,isSelected);
        fillIndex=addVerticesBox(fillCounts,fillIndices,fillIndex,fillBuffer,fillColorBuffer,horiz,color,(float)timeMin,(float)timeMax,(float)posMin,(float)posMax);
        fillCount++;
      }
      if (event.isShowBorder()) {
        float[] color=getBorderColor(event,info,isSelected);
        borderIndex=addVerticesBox(borderCounts,borderIndices,borderIndex,borderBuffer,borderColorBuffer,horiz,color,(float)timeMin,(float)timeMax,(float)posMin,(float)posMax);
        borderCount++;
      }
    }
 else {
      if (event.isShowBackground()) {
        float[] color=getBackgroundColor(event,info,isSelected);
        fillIndex=addVerticesArrow(fillCounts,fillIndices,fillIndex,fillBuffer,fillColorBuffer,horiz,color,(float)timeMin,(float)timeMax,(float)posMin,(float)posMax,(float)arrowBaseMin,(float)arrowBaseMax,(float)sizePerpCenter);
        fillCount++;
      }
      if (event.isShowBorder()) {
        float[] color=getBorderColor(event,info,isSelected);
        borderIndex=addVerticesArrow(borderCounts,borderIndices,borderIndex,borderBuffer,borderColorBuffer,horiz,color,(float)timeMin,(float)timeMax,(float)posMin,(float)posMax,(float)arrowBaseMin,(float)arrowBaseMax,(float)sizePerpCenter);
        borderCount++;
      }
    }
    int totalIconSizePerpPixels=getIconSizePerpPixels(event,info,sizePerpPixels);
    if (event.hasChildren()) {
      final int numChildren=event.getEventCount();
      final int numRows=maxIconRows;
      int iconSizePerpPixels=totalIconSizePerpPixels / numRows;
      int columnsByAvailableSpace=(int)Math.floor(remainingSpace / (double)iconSizePerpPixels);
      int columnsByNumberOfIcons=(int)Math.ceil(numChildren / (double)numRows);
      int numColumns=(int)Math.min(columnsByAvailableSpace,columnsByNumberOfIcons);
      double iconSizePerpValue=iconSizePerpPixels / timeAxis.getPixelsPerValue();
      int totalIconWidthPixels=iconSizePerpPixels * numColumns;
      eventBounds.setIconVisible(event.isShowIcon() && !isIconOverlapping(totalIconWidthPixels,0,remainingSpace,pixel,nextStartPixel,event.getOverlapRenderingMode()));
      if (eventBounds.isIconVisible()) {
        double value=timeAxis.screenPixelToValue(pixel);
        eventBounds.setIconStartTime(epoch.toTimeStamp(value));
        eventBounds.setIconEndTime(eventBounds.getIconStartTime().add(totalIconWidthPixels / timeAxis.getPixelsPerValue()));
        Iterator<Event> iter=event.iterator();
        outer:         for (int c=0; c < numColumns; c++) {
          for (int r=numRows - 1; r >= 0; r--) {
            if (iter.hasNext()) {
              Event child=iter.next();
              Object icon=child.getIconId();
              if (icon == null || !atlas.isImageLoaded(icon)) {
                GlimpseColor.glColor(gl,getBackgroundColor(child,info,isSelected),0.5f);
                icon=defaultIconId;
              }
 else {
                GlimpseColor.glColor(gl,GlimpseColor.getWhite());
              }
              if (atlas.isImageLoaded(icon)) {
                ImageData iconData=atlas.getImageData(icon);
                int iconSizePerp=horiz ? iconData.getHeight() : iconData.getWidth();
                double iconScale=iconSizePerpPixels / (double)iconSizePerp;
                double x=value + c * iconSizePerpValue;
                double startY=sizePerpCenter - totalIconSizePerpPixels / 2.0;
                double y=startY + r * iconSizePerpPixels;
                if (horiz) {
                  iconDrawList.add(new IconDrawInfo(icon,x,y,iconScale,iconScale,0,iconSizePerp,true));
                }
 else {
                  iconDrawList.add(new IconDrawInfo(icon,x,y,iconScale,iconScale,0,iconSizePerp,false));
                }
              }
            }
 else {
              break outer;
            }
          }
        }
        remainingSpace-=totalIconWidthPixels + buffer;
        pixel+=totalIconWidthPixels + buffer;
      }
    }
 else {
      boolean isOverlapping=isIconOverlapping(totalIconSizePerpPixels,buffer,remainingSpace,pixel,nextStartPixel,event.getOverlapRenderingMode());
      eventBounds.setIconVisible(event.isShowIcon() && event.getIconId() != null && !isOverlapping);
      if (eventBounds.isIconVisible()) {
        Object icon=event.getIconId();
        if (icon == null || !atlas.isImageLoaded(icon)) {
          icon=defaultIconId;
        }
        if (atlas.isImageLoaded(icon)) {
          ImageData iconData=atlas.getImageData(icon);
          int iconSizePerp=horiz ? iconData.getHeight() : iconData.getWidth();
          int iconSizeTime=horiz ? iconData.getWidth() : iconData.getHeight();
          int iconSizePerpPixels=getIconSizePerpPixels(event,info,sizePerpPixels);
          double iconScale=iconSizePerpPixels / (double)iconSizePerp;
          double posTime=timeAxis.screenPixelToValue(pixel);
          eventBounds.setIconStartTime(epoch.toTimeStamp(posTime));
          double iconSizeTimeAxis=iconSizeTime / timeAxis.getPixelsPerValue();
          eventBounds.setIconEndTime(eventBounds.getIconStartTime().add(iconSizeTimeAxis));
          int iconSizeTimeScaledPixels=(int)(iconSizeTime * iconScale);
          double posPerp=sizePerpCenter - iconSizePerpPixels / 2.0;
          if (horiz) {
            iconDrawList.add(new IconDrawInfo(icon,posTime,posPerp,iconScale,iconScale,0,iconSizePerp,true));
          }
 else {
            iconDrawList.add(new IconDrawInfo(icon,posPerp,posTime,iconScale,iconScale,0,iconSizePerp,false));
          }
          remainingSpace-=iconSizeTimeScaledPixels + buffer;
          pixel+=iconSizeTimeScaledPixels + buffer;
        }
      }
    }
    if (event.isShowLabel() && event.getLabel() != null) {
      Rectangle2D labelBounds=textRenderer.getBounds(event.getLabel());
      boolean isTextOverfull=isTextOverfull(sizePerpPixels,buffer,remainingSpace,pixel,nextStartPixel,labelBounds,event.getOverlapRenderingMode());
      boolean isTextIntersecting=isTextIntersecting(sizePerpPixels,buffer,remainingSpace,pixel,nextStartPixel,labelBounds,event.getOverlapRenderingMode());
      boolean isTextOverlappingAndHidden=((isTextOverfull || isTextIntersecting) && event.getTextRenderingMode() == TextRenderingMode.HideAll);
      double availableSpace=getTextAvailableSpace(sizePerpPixels,buffer,remainingSpace,pixel,nextStartPixel,event.getOverlapRenderingMode());
      eventBounds.setTextVisible(!isTextOverlappingAndHidden);
      if (eventBounds.isTextVisible()) {
        Rectangle2D displayBounds=labelBounds;
        String displayText=event.getLabel();
        if (labelBounds.getWidth() > availableSpace && event.getTextRenderingMode() != TextRenderingMode.ShowAll) {
          displayText=calculateDisplayText(textRenderer,displayText,availableSpace);
          displayBounds=textRenderer.getBounds(displayText);
        }
        double value=timeAxis.screenPixelToValue(pixel);
        eventBounds.setTextStartTime(epoch.toTimeStamp(value));
        eventBounds.setTextEndTime(eventBounds.getTextStartTime().add(displayBounds.getWidth() / timeAxis.getPixelsPerValue()));
        float[] color;
        if (event.getLabelColor() != null) {
          color=event.getLabelColor();
        }
 else         if (!info.isTextColorSet() && !event.isShowBackground()) {
          color=info.getTextColorNoBackground();
        }
 else {
          color=info.getTextColor();
        }
        if (horiz) {
          int pixelY=(int)(sizePerpPixels / 2.0 - labelBounds.getHeight() * 0.3 + posMin);
          textDrawList.add(new TextDrawInfo(displayText,color,pixel,pixelY,0,0));
          remainingSpace-=displayBounds.getWidth() + buffer;
          pixel+=displayBounds.getWidth() + buffer;
        }
 else {
          double shiftX=sizePerpPixels / 2.0 + posMin;
          int pixelX=(int)shiftX;
          double shiftY=pixel;
          int pixelY=(int)(pixel - labelBounds.getHeight() * 0.34);
          textDrawList.add(new TextDrawInfo(displayText,color,pixelX,pixelY,shiftX,shiftY));
          remainingSpace-=displayBounds.getWidth() + buffer;
          pixel+=displayBounds.getWidth() + buffer;
        }
      }
    }
  }
  if (fillCount > 0) {
    gl.glEnableClientState(GL2.GL_COLOR_ARRAY);
    gl.glEnableClientState(GL2.GL_VERTEX_ARRAY);
    fillBuffer.flip();
    fillColorBuffer.flip();
    fillIndices.flip();
    fillCounts.flip();
    gl.glVertexPointer(2,GL.GL_FLOAT,0,fillBuffer);
    gl.glColorPointer(4,GL.GL_FLOAT,0,fillColorBuffer);
    gl.glMultiDrawArrays(GL2.GL_POLYGON,fillIndices,fillCounts,fillCount);
    gl.glDisableClientState(GL2.GL_COLOR_ARRAY);
    gl.glDisableClientState(GL2.GL_VERTEX_ARRAY);
  }
  if (borderCount > 0) {
    gl.glEnableClientState(GL2.GL_COLOR_ARRAY);
    gl.glEnableClientState(GL2.GL_VERTEX_ARRAY);
    borderBuffer.flip();
    borderColorBuffer.flip();
    borderIndices.flip();
    borderCounts.flip();
    gl.glVertexPointer(2,GL.GL_FLOAT,0,borderBuffer);
    gl.glColorPointer(4,GL.GL_FLOAT,0,borderColorBuffer);
    gl.glMultiDrawArrays(GL2.GL_LINE_LOOP,borderIndices,borderCounts,borderCount);
    gl.glDisableClientState(GL2.GL_COLOR_ARRAY);
    gl.glDisableClientState(GL2.GL_VERTEX_ARRAY);
  }
  if (!iconDrawList.isEmpty()) {
    atlas.beginRendering();
    try {
      for (      IconDrawInfo iconInfo : iconDrawList) {
        if (iconInfo.isX()) {
          atlas.drawImageAxisX(gl,iconInfo.id,timeAxis,iconInfo.positionX,iconInfo.positionY,iconInfo.scaleX,iconInfo.scaleY,iconInfo.centerX,iconInfo.centerY);
        }
 else {
          atlas.drawImageAxisY(gl,iconInfo.id,timeAxis,iconInfo.positionX,iconInfo.positionY,iconInfo.scaleX,iconInfo.scaleY,iconInfo.centerX,iconInfo.centerY);
        }
      }
    }
  finally {
      atlas.endRendering();
    }
  }
  if (!textDrawList.isEmpty()) {
    textRenderer.beginRendering(width,height);
    try {
      for (      TextDrawInfo textInfo : textDrawList) {
        if (!horiz) {
          gl.glMatrixMode(GL2.GL_PROJECTION);
          gl.glTranslated(textInfo.getShiftX(),textInfo.getShiftY(),0);
          gl.glRotated(90,0,0,1.0f);
          gl.glTranslated(-textInfo.getShiftX(),-textInfo.getShiftY(),0);
        }
        GlimpseColor.setColor(textRenderer,textInfo.getColor());
        textRenderer.draw(textInfo.getText(),textInfo.getX(),textInfo.getY());
      }
    }
  finally {
      textRenderer.endRendering();
    }
  }
}",0.999057151145924
11440,"@Override public GlimpseLayout getLayout(){
  final SimplePlot2D plot=new SimplePlot2D();
  plot.setAxisSizeZ(50);
  plot.setAxisSizeX(0);
  plot.setAxisSizeY(0);
  plot.setTitleHeight(0);
  plot.setAxisLabelZ(""String_Node_Str"",""String_Node_Str"",false);
  plot.setMinX(-20.0);
  plot.setMaxX(20.0);
  plot.setMinY(-20.0);
  plot.setMaxY(20.0);
  plot.setMinZ(0.0);
  plot.setMaxZ(1000.0);
  plot.setAxisSizeZ(65);
  plot.getAxisX().setSelectionCenter(10);
  plot.getAxisY().setSelectionCenter(10);
  plot.lockAspectRatioXY(1.0);
  plot.setSelectionSize(5.0);
  plot.setShowMinorTicksX(true);
  plot.setShowMinorTicksY(true);
  plot.setShowMinorTicksZ(true);
  final TrackPainter trackPainter=new TrackPainter(true);
  plot.addPainter(trackPainter);
  TrackManager trackManager=new TrackManager(trackPainter,NUMBER_OF_TRACKS);
  plot.getAxisZ().addAxisListener(new TimeAxisListener(trackPainter));
  plot.getAxisPainterZ().setShowMarker(true);
  trackManager.start();
  trackPainter.addSpatialSelectionListener(plot.getAxis(),new TrackSelectionListener(trackManager,trackPainter));
  final TrackPainter selectionDotPainter=new TrackPainter(false);
  plot.addPainter(selectionDotPainter);
  selectionDotPainter.setShowPoints(0,true);
  selectionDotPainter.setPointSize(0,10f);
  selectionDotPainter.setPointColor(0,GlimpseColor.getYellow());
  final CustomCursorTextPainter cursorText=new CustomCursorTextPainter();
  plot.addPainter(cursorText);
  final Pulsator pulsator=new Pulsator(selectionDotPainter);
  pulsator.addId(0);
  pulsator.start();
  plot.addGlimpseMouseMotionListener(new GlimpseMouseMotionListener(){
    @Override public void mouseMoved(    GlimpseMouseEvent e){
      Point point=trackPainter.getNearestPoint(e,20);
      cursorText.setPoint(point);
      selectionDotPainter.clearTrack(0);
      pulsator.resetSize();
      if (point != null) {
        selectionDotPainter.addPoint(0,0,point.getX(),point.getY(),point.getTime());
      }
    }
  }
);
  return plot;
}","@Override public GlimpseLayout getLayout(){
  final SimplePlot2D plot=new SimplePlot2D();
  plot.setAxisSizeZ(50);
  plot.setAxisSizeX(0);
  plot.setAxisSizeY(0);
  plot.setTitleHeight(0);
  plot.setAxisLabelZ(""String_Node_Str"",""String_Node_Str"",false);
  plot.setMinX(-20.0);
  plot.setMaxX(20.0);
  plot.setMinY(-20.0);
  plot.setMaxY(20.0);
  plot.setMinZ(0.0);
  plot.setMaxZ(1000.0);
  plot.setAxisSizeZ(65);
  plot.getAxisX().setSelectionCenter(10);
  plot.getAxisY().setSelectionCenter(10);
  plot.lockAspectRatioXY(1.0);
  plot.setSelectionSize(5.0);
  plot.setShowMinorTicksX(true);
  plot.setShowMinorTicksY(true);
  plot.setShowMinorTicksZ(true);
  final TrackPainter trackPainter=new TrackPainter(true);
  plot.addPainter(trackPainter);
  TrackManager trackManager=new TrackManager(trackPainter,NUMBER_OF_TRACKS);
  plot.getAxisZ().addAxisListener(new TimeAxisListener(trackPainter));
  plot.getAxisPainterZ().setShowMarker(true);
  trackManager.start();
  trackPainter.addSpatialSelectionListener(plot.getAxis(),new TrackSelectionListener(trackManager,trackPainter));
  final TrackPainter selectionDotPainter=new TrackPainter(false);
  plot.addPainter(selectionDotPainter);
  selectionDotPainter.setShowPoints(0,true);
  selectionDotPainter.setPointSize(0,10f);
  selectionDotPainter.setPointColor(0,GlimpseColor.getYellow());
  final CustomCursorTextPainter cursorText=new CustomCursorTextPainter();
  plot.addPainter(cursorText);
  final Pulsator pulsator=new Pulsator(selectionDotPainter);
  pulsator.addId(0);
  pulsator.start();
  plot.addGlimpseMouseMotionListener(new GlimpseMouseMotionListener(){
    @Override public void mouseMoved(    GlimpseMouseEvent e){
      Point point=trackPainter.getNearestPoint(e,20);
      cursorText.setPoint(point);
      selectionDotPainter.clearTrack(0);
      pulsator.resetSize();
      if (point != null) {
        selectionDotPainter.addPoint(0,0,point.getX(),point.getY(),point.getTime());
      }
    }
  }
);
  plot.addPainter(new NumericXYAxisPainter());
  return plot;
}",0.9883113653320068
11441,"static FloatTexture2D setupTexture(){
  int n=200;
  double[] min=new double[]{-1,-1};
  double[] max=new double[]{1,1};
  FloatTexture2D data=new FloatTexture2D(min,max,n,n,false);
  return data;
}","static FloatTextureProjected2D setupTexture(){
  int n=200;
  FloatTextureProjected2D data=new FloatTextureProjected2D(n,n,false);
  data.setProjection(new FlatProjection(-1,1,-1,1));
  return data;
}",0.321608040201005
11442,"@Override public void mutate(FloatBuffer data,double[] min,double[] max,int[] dim){
  data.clear();
  for (int i=0; i < dim[0]; i++)   for (int j=0; j < dim[1]; j++) {
    double x0=2 * PI * i / dim[0];
    double x1=2 * PI * j / dim[1];
    data.put((float)(1000 * (abs(sin(x0 + w * fr)) * (sin(x0 - w * fr) * sin(8 * x0 + w * fr) * cos(-8 * x1 - w * fr) + abs(sin(24 * x1)) / 3))));
  }
  fr++;
}","@Override public void mutate(FloatBuffer data,int dataSizeX,int dataSizeY){
  data.clear();
  for (int i=0; i < dataSizeX; i++)   for (int j=0; j < dataSizeY; j++) {
    double x0=2 * PI * i / dataSizeX;
    double x1=2 * PI * j / dataSizeY;
    data.put((float)(1000 * (abs(sin(x0 + w * fr)) * (sin(x0 - w * fr) * sin(8 * x0 + w * fr) * cos(-8 * x1 - w * fr) + abs(sin(24 * x1)) / 3))));
  }
  fr++;
}",0.86
11443,"@Override public ColorAxisPlot2D getLayout(){
  ColorAxisPlot2D plot=new ColorAxisPlot2D();
  plot.setPlotBackgroundColor(GlimpseColor.getBlack());
  plot.setBackgroundColor(GlimpseColor.getBlack());
  plot.setAxisColor(GlimpseColor.getWhite());
  plot.getGridPainter().setLineColor(GlimpseColor.getWhite(0.5f));
  plot.setAxisLabelX(""String_Node_Str"");
  plot.setAxisLabelY(""String_Node_Str"");
  plot.setAxisLabelZ(""String_Node_Str"");
  plot.setTitle(""String_Node_Str"");
  plot.setTitleColor(GlimpseColor.getWhite());
  plot.getCrosshairPainter().setCursorColor(GlimpseColor.getGreen(0.2f));
  plot.getCrosshairPainter().setShadeColor(GlimpseColor.getGreen(0.05f));
  plot.getCrosshairPainter().setShadeSelectionBox(true);
  plot.getCrosshairPainter().setLineWidth(1);
  plot.setMinX(-1.2);
  plot.setMaxX(1.2);
  plot.setMinY(-1.2);
  plot.setMaxY(1.2);
  plot.setMinZ(0);
  plot.setMaxZ(1000);
  plot.lockAspectRatioXY(1);
  final ShadedTexturePainter painter=new ShadedTexturePainter();
  plot.addPainter(painter);
  ColorTexture1D colors=new ColorTexture1D(1024);
  colors.setColorGradient(ColorGradients.jet);
  final int dataTextureUnit=0;
  final int colorScaleTextureUnit=1;
  painter.addNonDrawableTexture(colors,colorScaleTextureUnit);
  SampledColorScaleShader shader;
  try {
    shader=new SampledColorScaleShader(plot.getAxisZ(),dataTextureUnit,colorScaleTextureUnit);
  }
 catch (  IOException e) {
    e.printStackTrace();
    throw new RuntimeException(e);
  }
  painter.setPipeline(new Pipeline(""String_Node_Str"",null,null,shader));
  new Thread(new Runnable(){
    @Override public void run(){
      FloatTexture2D data=setupTexture();
      MutatorFloat2D mutator=setupMutator(data);
      painter.addDrawableTexture(data,dataTextureUnit);
      while (true) {
        data.mutate(mutator);
        try {
          Thread.sleep(40);
        }
 catch (        InterruptedException e) {
        }
      }
    }
  }
).start();
  plot.setColorScale(colors);
  plot.addPainter(new BorderPainter());
  plot.addPainter(new FpsPainter());
  return plot;
}","@Override public ColorAxisPlot2D getLayout(){
  ColorAxisPlot2D plot=new ColorAxisPlot2D();
  plot.setPlotBackgroundColor(GlimpseColor.getBlack());
  plot.setBackgroundColor(GlimpseColor.getBlack());
  plot.setAxisColor(GlimpseColor.getWhite());
  plot.getGridPainter().setLineColor(GlimpseColor.getWhite(0.5f));
  plot.setAxisLabelX(""String_Node_Str"");
  plot.setAxisLabelY(""String_Node_Str"");
  plot.setAxisLabelZ(""String_Node_Str"");
  plot.setTitle(""String_Node_Str"");
  plot.setTitleColor(GlimpseColor.getWhite());
  plot.getCrosshairPainter().setCursorColor(GlimpseColor.getGreen(0.2f));
  plot.getCrosshairPainter().setShadeColor(GlimpseColor.getGreen(0.05f));
  plot.getCrosshairPainter().setShadeSelectionBox(true);
  plot.getCrosshairPainter().setLineWidth(1);
  plot.setMinX(-1.2);
  plot.setMaxX(1.2);
  plot.setMinY(-1.2);
  plot.setMaxY(1.2);
  plot.setMinZ(0);
  plot.setMaxZ(1000);
  plot.lockAspectRatioXY(1);
  final ShadedTexturePainter painter=new ShadedTexturePainter();
  plot.addPainter(painter);
  ColorTexture1D colors=new ColorTexture1D(1024);
  colors.setColorGradient(ColorGradients.jet);
  final int dataTextureUnit=0;
  final int colorScaleTextureUnit=1;
  painter.addNonDrawableTexture(colors,colorScaleTextureUnit);
  SampledColorScaleShader shader;
  try {
    shader=new SampledColorScaleShader(plot.getAxisZ(),dataTextureUnit,colorScaleTextureUnit);
  }
 catch (  IOException e) {
    e.printStackTrace();
    throw new RuntimeException(e);
  }
  painter.setPipeline(new Pipeline(""String_Node_Str"",null,null,shader));
  new Thread(new Runnable(){
    @Override public void run(){
      FloatTextureProjected2D data=setupTexture();
      MutatorFloat2D mutator=setupMutator(data);
      painter.addDrawableTexture(data,dataTextureUnit);
      while (true) {
        data.mutate(mutator);
        try {
          Thread.sleep(40);
        }
 catch (        InterruptedException e) {
        }
      }
    }
  }
).start();
  plot.setColorScale(colors);
  plot.addPainter(new BorderPainter());
  plot.addPainter(new FpsPainter());
  return plot;
}",0.9978287092882993
11444,"static MutatorFloat2D setupMutator(FloatTexture2D data){
  MutatorFloat2D editor=new MutatorFloat2D(){
    double w=2 * PI / 60;
    int fr=0;
    @Override public void mutate(    FloatBuffer data,    double[] min,    double[] max,    int[] dim){
      data.clear();
      for (int i=0; i < dim[0]; i++)       for (int j=0; j < dim[1]; j++) {
        double x0=2 * PI * i / dim[0];
        double x1=2 * PI * j / dim[1];
        data.put((float)(1000 * (abs(sin(x0 + w * fr)) * (sin(x0 - w * fr) * sin(8 * x0 + w * fr) * cos(-8 * x1 - w * fr) + abs(sin(24 * x1)) / 3))));
      }
      fr++;
    }
  }
;
  return editor;
}","static MutatorFloat2D setupMutator(FloatTextureProjected2D data){
  MutatorFloat2D editor=new MutatorFloat2D(){
    double w=2 * PI / 60;
    int fr=0;
    @Override public void mutate(    FloatBuffer data,    int dataSizeX,    int dataSizeY){
      data.clear();
      for (int i=0; i < dataSizeX; i++)       for (int j=0; j < dataSizeY; j++) {
        double x0=2 * PI * i / dataSizeX;
        double x1=2 * PI * j / dataSizeY;
        data.put((float)(1000 * (abs(sin(x0 + w * fr)) * (sin(x0 - w * fr) * sin(8 * x0 + w * fr) * cos(-8 * x1 - w * fr) + abs(sin(24 * x1)) / 3))));
      }
      fr++;
    }
  }
;
  return editor;
}",0.9002394253790902
11445,"@Override public void run(){
  FloatTexture2D data=setupTexture();
  MutatorFloat2D mutator=setupMutator(data);
  painter.addDrawableTexture(data,dataTextureUnit);
  while (true) {
    data.mutate(mutator);
    try {
      Thread.sleep(40);
    }
 catch (    InterruptedException e) {
    }
  }
}","@Override public void run(){
  FloatTextureProjected2D data=setupTexture();
  MutatorFloat2D mutator=setupMutator(data);
  painter.addDrawableTexture(data,dataTextureUnit);
  while (true) {
    data.mutate(mutator);
    try {
      Thread.sleep(40);
    }
 catch (    InterruptedException e) {
    }
  }
}",0.9850249584026622
11446,"@Override public GlimpseLayout getLayout() throws Exception {
  HeatMapExample example=new HeatMapExample(){
    @Override protected ColorAxisPlot2D newPlot(){
      return new ColorAxisPlot2D(){
        @Override protected GridAxisLabelHandler createLabelHandlerX(){
          return new WrappedLabelHandler();
        }
        @Override protected GridAxisLabelHandler createLabelHandlerY(){
          return new WrappedLabelHandler();
        }
        @Override protected Axis1D createAxisX(){
          return new WrappedAxis1D(0,1000);
        }
        @Override protected Axis1D createAxisY(){
          return new WrappedAxis1D(0,1000);
        }
      }
;
    }
  }
;
  ColorAxisPlot2D plot=example.getLayout();
  plot.getAxis().getAxisX().setMaxSpan(4000);
  plot.getAxis().getAxisY().setMaxSpan(4000);
  HeatMapPainter heatMapPainter=example.getPainter();
  plot.removePainter(heatMapPainter);
  WrappedPainter wrappedPainter=new WrappedPainter();
  wrappedPainter.addPainter(heatMapPainter);
  wrappedPainter.addPainter(new GlimpseDataPainter2D(){
    public void paintTo(    GL2 gl,    GlimpseBounds bounds,    Axis2D axis){
      gl.glColor4fv(GlimpseColor.getWhite(),0);
      gl.glPointSize(20f);
      gl.glBegin(GL.GL_POINTS);
      for (int x=0; x < 5; x++) {
        for (int y=0; y < 5; y++) {
          gl.glVertex2f(200 * (x + 0.5f),200 * (y + 0.5f));
        }
      }
      gl.glEnd();
    }
  }
);
  plot.addPainter(wrappedPainter);
  return plot;
}","@Override public GlimpseLayout getLayout() throws Exception {
  HeatMapExample example=new HeatMapExample(){
    @Override protected ColorAxisPlot2D newPlot(){
      return new ColorAxisPlot2D(){
        @Override protected GridAxisLabelHandler createLabelHandlerX(){
          return new WrappedLabelHandler();
        }
        @Override protected GridAxisLabelHandler createLabelHandlerY(){
          return new WrappedLabelHandler();
        }
        @Override protected Axis1D createAxisX(){
          return new WrappedAxis1D(0,1000);
        }
        @Override protected Axis1D createAxisY(){
          return new WrappedAxis1D(0,1000);
        }
      }
;
    }
  }
;
  ColorAxisPlot2D plot=example.getLayout();
  plot.getAxis().getAxisX().setMaxSpan(3000);
  plot.getAxis().getAxisY().setMaxSpan(3000);
  HeatMapPainter heatMapPainter=example.getPainter();
  plot.removePainter(heatMapPainter);
  WrappedPainter wrappedPainter=new WrappedPainter();
  wrappedPainter.addPainter(heatMapPainter);
  wrappedPainter.addPainter(new GlimpseDataPainter2D(){
    public void paintTo(    GL2 gl,    GlimpseBounds bounds,    Axis2D axis){
      gl.glColor4fv(GlimpseColor.getWhite(),0);
      gl.glPointSize(20f);
      gl.glBegin(GL.GL_POINTS);
      for (int x=0; x < 5; x++) {
        for (int y=0; y < 5; y++) {
          gl.glVertex2f(200 * (x + 0.5f),200 * (y + 0.5f));
        }
      }
      gl.glEnd();
    }
  }
);
  plot.addPainter(wrappedPainter);
  return plot;
}",0.9986449864498644
11447,"@Override public GlimpseLayout getLayout() throws Exception {
  GlimpseLayout layout=new GlimpseAxisLayout2D(new Axis2D());
  layout.addGlimpseMouseAllListener(new AxisMouseListener2D());
  TextureAtlas atlas=new TextureAtlas(256,256);
  final IconPainter iconPainter=new IconPainter();
  iconPainter.addIconGroup(""String_Node_Str"",atlas);
  iconPainter.addIconGroup(""String_Node_Str"",atlas);
  iconPainter.setPickingEnabled(layout);
  iconPainter.addSpatialSelectionListener(new SpatialSelectionListener<PickResult>(){
    @Override public void selectionChanged(    Collection<PickResult> newSelectedPoints){
      logInfo(logger,""String_Node_Str"",newSelectedPoints);
    }
  }
);
  TextureAtlasExample.loadTextureAtlas(atlas);
  iconPainter.addIcons(""String_Node_Str"",""String_Node_Str"",new float[]{0,20,30,40},new float[]{0,20,30,40},new float[]{(float)Math.PI / 3,(float)-Math.PI / 3,0,0},new float[]{1,1,1,1});
  layout.addGlimpseMouseListener(new GlimpseMouseListener(){
    float rot=0;
    @Override public void mouseEntered(    GlimpseMouseEvent event){
    }
    @Override public void mouseExited(    GlimpseMouseEvent event){
    }
    @Override public void mousePressed(    GlimpseMouseEvent event){
      float x=(float)event.getAxisCoordinatesX();
      float y=(float)event.getAxisCoordinatesY();
      if (event.isButtonDown(MouseButton.Button1)) {
        iconPainter.addIcon(""String_Node_Str"",""String_Node_Str"",x,y,rot,0.5f);
      }
 else       if (event.isButtonDown(MouseButton.Button2)) {
        iconPainter.addIcon(""String_Node_Str"",""String_Node_Str"",x,y,rot,0.5f);
      }
 else       if (event.isButtonDown(MouseButton.Button3)) {
        iconPainter.addIcon(""String_Node_Str"",""String_Node_Str"",x,y,rot,1);
      }
      rot+=Math.PI / 12;
    }
    @Override public void mouseReleased(    GlimpseMouseEvent event){
    }
  }
);
  TooltipPainter tooltipPainter=new TooltipPainter(atlas);
  tooltipPainter.setText(""String_Node_Str"");
  tooltipPainter.setFixedWidth(100);
  tooltipPainter.setClampToScreenEdges(false);
  tooltipPainter.setOffset(0,0);
  tooltipPainter.setIcons(Arrays.<Object>asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
  tooltipPainter.setLocationAxisCoords(0,0);
  layout.addPainter(new BackgroundPainter().setColor(GlimpseColor.getGray()));
  layout.addPainter(new NumericXYAxisPainter());
  layout.addPainter(iconPainter);
  layout.addPainter(tooltipPainter);
  layout.addPainter(new FpsPainter());
  return layout;
}","@Override public GlimpseLayout getLayout() throws Exception {
  GlimpseLayout layout=new GlimpseAxisLayout2D(new Axis2D());
  layout.addGlimpseMouseAllListener(new AxisMouseListener2D());
  TextureAtlas atlas=new TextureAtlas(256,256);
  final IconPainter iconPainter=new IconPainter();
  iconPainter.addIconGroup(""String_Node_Str"",atlas);
  iconPainter.addIconGroup(""String_Node_Str"",atlas);
  iconPainter.setPickingEnabled(layout);
  iconPainter.addSpatialSelectionListener(new SpatialSelectionListener<PickResult>(){
    @Override public void selectionChanged(    Collection<PickResult> newSelectedPoints){
      logInfo(logger,""String_Node_Str"",newSelectedPoints);
    }
  }
);
  TextureAtlasExample.loadTextureAtlas(atlas);
  iconPainter.addIcons(""String_Node_Str"",""String_Node_Str"",new float[]{0,20,30,40},new float[]{0,20,30,40},new float[]{(float)Math.PI / 3,(float)-Math.PI / 3,0,0},new float[]{1,1,1,1});
  layout.addGlimpseMouseListener(new GlimpseMouseListener(){
    float rot=0;
    @Override public void mouseEntered(    GlimpseMouseEvent event){
    }
    @Override public void mouseExited(    GlimpseMouseEvent event){
    }
    @Override public void mousePressed(    GlimpseMouseEvent event){
      float x=(float)event.getAxisCoordinatesX();
      float y=(float)event.getAxisCoordinatesY();
      if (event.isButtonDown(MouseButton.Button1)) {
        iconPainter.addIcon(""String_Node_Str"",""String_Node_Str"",x,y,rot,0.5f);
      }
 else       if (event.isButtonDown(MouseButton.Button2)) {
        iconPainter.addIcon(""String_Node_Str"",""String_Node_Str"",x,y,rot,0.5f);
      }
 else       if (event.isButtonDown(MouseButton.Button3)) {
        iconPainter.addIcon(""String_Node_Str"",""String_Node_Str"",x,y,rot,1);
      }
      rot+=Math.PI / 12;
    }
    @Override public void mouseReleased(    GlimpseMouseEvent event){
    }
  }
);
  layout.addPainter(new BackgroundPainter().setColor(GlimpseColor.getGray()));
  layout.addPainter(new NumericXYAxisPainter());
  layout.addPainter(iconPainter);
  layout.addPainter(new FpsPainter());
  return layout;
}",0.8985507246376812
11448,"public static void setupScreenCapture(Example example){
  GlimpseCanvas canvas=example.getCanvas();
  ColorAxisPlot2D plot=(ColorAxisPlot2D)example.getLayout();
  plot.setTitleFont(FontUtils.getDefaultBold(18));
  plot.setTitle(""String_Node_Str"");
  final FBOGlimpseCanvas offscreenCanvas=new FBOGlimpseCanvas(canvas.getGLContext(),1000,1000);
  offscreenCanvas.addLayout(example.getLayout());
  GlimpseTargetStack stack=newTargetStack(offscreenCanvas);
  AxisFactory2D factory=new FixedAxisFactory2D(0,1000,0,1000);
  plot.setAxisFactory(new ConditionalAxisFactory2D(stack,factory));
  plot.addGlimpseMouseListener(new GlimpseMouseAdapter(){
    @Override public void mousePressed(    GlimpseMouseEvent event){
      if (event.isButtonDown(MouseButton.Button2)) {
        try {
          BufferedImage image=offscreenCanvas.toBufferedImage();
          ImageIO.write(image,""String_Node_Str"",new File(""String_Node_Str""));
        }
 catch (        Exception e) {
          e.printStackTrace();
        }
      }
    }
  }
);
}","public static void setupScreenCapture(Example example){
  GlimpseCanvas canvas=example.getCanvas();
  ColorAxisPlot2D plot=(ColorAxisPlot2D)example.getLayout();
  plot.setTitleFont(FontUtils.getDefaultBold(18));
  plot.setTitle(""String_Node_Str"");
  final FBOGlimpseCanvas offscreenCanvas=new FBOGlimpseCanvas(canvas.getGLContext(),1000,1000);
  offscreenCanvas.addLayout(example.getLayout());
  GlimpseTargetStack stack=newTargetStack(offscreenCanvas);
  AxisFactory2D factory=new FixedAxisFactory2D(0,1000,0,1000);
  plot.setAxisFactory(new ConditionalEndsWithAxisFactory2D(stack,factory));
  plot.addGlimpseMouseListener(new GlimpseMouseAdapter(){
    @Override public void mousePressed(    GlimpseMouseEvent event){
      if (event.isButtonDown(MouseButton.Button2)) {
        try {
          BufferedImage image=offscreenCanvas.toBufferedImage();
          ImageIO.write(image,""String_Node_Str"",new File(""String_Node_Str""));
        }
 catch (        Exception e) {
          e.printStackTrace();
        }
      }
    }
  }
);
}",0.996116504854369
11449,"protected void setBounds(TimePlotInfo chart){
  Axis1D axis=chart.getLayout().getAxis().getAxisY();
  axis.setMin(-20.0);
  axis.setMax(20.0);
}","protected void setBounds(TimePlotInfo chart){
  Axis1D axis=chart.getBaseLayout().getAxis().getAxisY();
  axis.setMin(-20.0);
  axis.setMax(20.0);
}",0.9863013698630136
11450,"protected void axisUpdated0(Axis1D axis){
  this.updateMode=axis.getUpdateMode();
  this.lockMin=axis.isLockMin();
  this.lockMax=axis.isLockMax();
  this.lockMinValue=axis.getLockMin();
  this.lockMaxValue=axis.getLockMax();
  this.absoluteMin=axis.getAbsoluteMin();
  this.absoluteMax=axis.getAbsoluteMax();
  this.selectionCenterValue=axis.getSelectionCenter();
  this.selectionSizeValue=axis.getSelectionSize();
  this.selectionLocked=axis.isSelectionLocked();
  if (!this.isInitialized()) {
    this.minValue=axis.getMin();
    this.maxValue=axis.getMax();
    this.pixelsPerValue=axis.getPixelsPerValue();
  }
 else   if (this.updateMode == UpdateMode.MinScale) {
    this.minValue=axis.getMin();
    this.pixelsPerValue=axis.getPixelsPerValue();
    this.recalculateMaxValue0();
    this.applyConstraints();
  }
 else   if (this.updateMode == UpdateMode.CenterScale) {
    this.pixelsPerValue=axis.getPixelsPerValue();
    double centerValue=(axis.getMax() - axis.getMin()) / 2.0 + axis.getMin();
    this.recalculateMinMaxValue0(centerValue);
    this.applyConstraints();
  }
 else   if (this.updateMode == UpdateMode.MinMax) {
    this.minValue=axis.getMin();
    this.maxValue=axis.getMax();
    this.recalculatePixelsPerValue0();
    this.applyConstraints();
  }
 else   if (this.updateMode == UpdateMode.FixedPixel) {
  }
}","protected void axisUpdated0(Axis1D axis){
  this.updateMode=axis.getUpdateMode();
  this.minDiff=axis.getMinSpan();
  this.maxDiff=axis.getMaxSpan();
  this.constrainMinDiff=axis.isMinSpanConstrained();
  this.constrainMaxDiff=axis.isMaxSpanConstrained();
  this.lockMin=axis.isLockMin();
  this.lockMax=axis.isLockMax();
  this.lockMinValue=axis.getLockMin();
  this.lockMaxValue=axis.getLockMax();
  this.absoluteMin=axis.getAbsoluteMin();
  this.absoluteMax=axis.getAbsoluteMax();
  this.selectionCenterValue=axis.getSelectionCenter();
  this.selectionSizeValue=axis.getSelectionSize();
  this.selectionLocked=axis.isSelectionLocked();
  if (!this.isInitialized()) {
    this.minValue=axis.getMin();
    this.maxValue=axis.getMax();
    this.pixelsPerValue=axis.getPixelsPerValue();
  }
 else   if (this.updateMode == UpdateMode.MinScale) {
    this.minValue=axis.getMin();
    this.pixelsPerValue=axis.getPixelsPerValue();
    this.recalculateMaxValue0();
    this.applyConstraints();
  }
 else   if (this.updateMode == UpdateMode.CenterScale) {
    this.pixelsPerValue=axis.getPixelsPerValue();
    double centerValue=(axis.getMax() - axis.getMin()) / 2.0 + axis.getMin();
    this.recalculateMinMaxValue0(centerValue);
    this.applyConstraints();
  }
 else   if (this.updateMode == UpdateMode.MinMax) {
    this.minValue=axis.getMin();
    this.maxValue=axis.getMax();
    this.recalculatePixelsPerValue0();
    this.applyConstraints();
  }
 else   if (this.updateMode == UpdateMode.FixedPixel) {
  }
}",0.938818565400844
11451,"protected void updateAspectRatio(Axis1D updated,double aspectRatio){
  if (!isInitialized())   return;
  double oldPixelsPerValue=getPixelsPerValue();
  double newPixelsPerValue=updated.getPixelsPerValue() * aspectRatio;
  this.minValue=recenterMinValue0(getSizePixels() / 2d,oldPixelsPerValue,newPixelsPerValue);
  this.pixelsPerValue=newPixelsPerValue;
  this.recalculateMaxValue0();
  this.applyConstraints();
}","protected void updateAspectRatio(Axis1D updated,double aspectRatio){
  double oldPixelsPerValue=getPixelsPerValue();
  double newPixelsPerValue=updated.getPixelsPerValue() * aspectRatio;
  this.minValue=recenterMinValue0(getSizePixels() / 2d,oldPixelsPerValue,newPixelsPerValue);
  this.pixelsPerValue=newPixelsPerValue;
  this.recalculateMaxValue0();
  this.applyConstraints();
}",0.9571788413098236
11452,"public void setParent(Axis1D newParent,boolean duplicateChild){
  if (this.parentAxis != null && newParent == null) {
    this.parentAxis.removeChildAxis(this);
  }
  this.parentAxis=newParent;
  if (this.parentAxis != null) {
    this.parentAxis.addChildAxis(this);
    if (!duplicateChild) {
      this.parentAxis.updateLinkedAxes();
    }
  }
  if (duplicateChild) {
    updateLinkedAxes();
  }
}","public void setParent(Axis1D newParent,boolean duplicateChild){
  if (this.parentAxis != null) {
    this.parentAxis.removeChildAxis(this);
  }
  this.parentAxis=newParent;
  if (this.parentAxis != null) {
    this.parentAxis.addChildAxis(this);
    if (!duplicateChild) {
      this.parentAxis.updateLinkedAxes();
    }
  }
  if (duplicateChild) {
    updateLinkedAxes();
  }
}",0.972972972972973
11453,"/** 
 * Should be called once axisSizePixels has been properly set (usually once the underlying canvas associated with this Axis1D has been drawn).
 */
public void setInitialized(){
  if (!this.initialized && this.axisSizePixels > 0) {
    this.initialized=true;
    this.requestAxisUpdateUp();
  }
}","/** 
 * Should be called once axisSizePixels has been properly set (usually once the underlying canvas associated with this Axis1D has been drawn).
 */
public void setInitialized(){
  if (!this.initialized && this.axisSizePixels > 0) {
    this.initialized=true;
    this.broadcastAxisUpdateUp();
  }
}",0.9800664451827242
11454,"protected void initialize(Axis1D parent){
  this.children=new CopyOnWriteArrayList<Axis1D>();
  this.listeners=new CopyOnWriteArrayList<AxisListener1D>();
  this.setDefaults();
  this.setParent(parent);
}","protected void initialize(Axis1D parent){
  this.children=new CopyOnWriteArraySet<Axis1D>();
  this.listeners=new CopyOnWriteArraySet<AxisListener1D>();
  this.setDefaults();
  this.setParent(parent);
}",0.6798029556650246
11455,"@Override public String[] getTickLabels(Axis1D axis,double[] tickPositions){
  String[] tickLabels=new String[tickPositions.length];
  for (int i=0; i < tickPositions.length; i++) {
    double value=tickPositions[i];
    if (zoomedIn) {
      value-=baseValue;
      value/=pow(10,orderDelta);
    }
 else {
      value/=pow(10,orderAxis);
    }
    String s=format(""String_Node_Str"",value);
    if (tickPositions[i] < 0) {
      s=s.substring(0,6);
    }
 else {
      s=s.substring(0,5);
    }
    tickLabels[i]=s;
  }
  return tickLabels;
}","@Override public String[] getTickLabels(Axis1D axis,double[] tickPositions){
  String[] tickLabels=new String[tickPositions.length];
  for (int i=0; i < tickPositions.length; i++) {
    double value=tickPositions[i];
    if (zoomedIn) {
      value-=baseValue;
      value/=pow(10,orderDelta);
    }
 else {
      value/=pow(10,orderAxis);
    }
    String s=format(""String_Node_Str"",value);
    if (value < 0) {
      s=s.substring(0,6);
    }
 else {
      s=s.substring(0,5);
    }
    tickLabels[i]=s;
  }
  return tickLabels;
}",0.9804651162790696
11456,"@Override public Axis1D getCommonAxis(){
  return parent.getCommonAxis(layout.getAxis());
}","@Override public Axis1D getCommonAxis(){
  return parent.getCommonAxis(this.layout.getAxis());
}",0.9732620320855616
11457,"@Override public Axis1D getOrthogonalAxis(){
  return parent.getOrthogonalAxis(layout.getAxis());
}","@Override public Axis1D getOrthogonalAxis(){
  return parent.getOrthogonalAxis(this.layout.getAxis());
}",0.9753694581280788
11458,"protected Axis1D getCommonAxis(Axis2D axis){
  return orient == HORIZONTAL ? axis.getAxisY() : axis.getAxisX();
}","public Axis1D getCommonAxis(Axis2D axis){
  return orient == HORIZONTAL ? axis.getAxisY() : axis.getAxisX();
}",0.9506726457399104
11459,"protected Axis1D getOrthogonalAxis(Axis2D axis){
  return orient == HORIZONTAL ? axis.getAxisX() : axis.getAxisY();
}","public Axis1D getOrthogonalAxis(Axis2D axis){
  return orient == HORIZONTAL ? axis.getAxisX() : axis.getAxisY();
}",0.9523809523809524
11460,"@Override protected void paintTo(GlimpseContext context,GlimpseBounds bounds,Axis2D axis){
  if (axis == null && !drawInPixelCoords) {
    throw new AxisNotSetException(this,context);
  }
  double x=drawInPixelCoords ? this.x : axis.getAxisX().valueToScreenPixelUnits(this.x);
  double y=drawInPixelCoords ? this.y : axis.getAxisY().valueToScreenPixelUnits(this.y);
  if (icons == null) {
    loadIcons();
  }
  if (newFont != null) {
    updateTextRenderer();
  }
  if (text != null && textLayout == null && textRenderer != null) {
    updateTextLayout();
  }
  if (iconIds == null || iconIds.isEmpty())   iconSize=0;
  GL2 gl=context.getGL().getGL2();
  int width=bounds.getWidth();
  int height=bounds.getHeight();
  gl.glMatrixMode(GL2.GL_PROJECTION);
  gl.glLoadIdentity();
  gl.glOrtho(-0.5,width - 1 + 0.5,-0.5,height - 1 + 0.5,-1,1);
  gl.glMatrixMode(GL2.GL_MODELVIEW);
  gl.glLoadIdentity();
  gl.glBlendFunc(GL2.GL_SRC_ALPHA,GL2.GL_ONE_MINUS_SRC_ALPHA);
  gl.glEnable(GL2.GL_BLEND);
  double iconHeight=0;
  if (icons != null)   iconHeight=iconSize * icons.size() + iconSpacing * (icons.size() - 1);
  double textHeight=0;
  if (lines != null)   textHeight=(textLayout.getLineHeight()) * lines.size() + lineSpacing * (lines.size() - 1);
  int boundingHeight=(int)(borderSize * 2 + Math.max(iconHeight,textHeight));
  float textLength=0;
  if (lines != null)   for (int k=0; k < lines.size(); k++)   textLength=Math.max(textLength,lines.get(0).width);
  int boundingWidth=(int)(borderSize * 2 + iconSize + textLength);
  if (iconIds != null && !iconIds.isEmpty() && lines != null)   boundingWidth+=textIconSpacing;
  double clampX=offsetX, clampY=offsetY;
  if (clampToScreenEdges) {
    if (x + boundingWidth + offsetX > bounds.getWidth())     clampX=bounds.getWidth() - boundingWidth - x;
    if (x + offsetX < 0)     clampX=-x;
    if (y + offsetY > bounds.getHeight())     clampY=bounds.getHeight() - y;
    if (boundingHeight > y + offsetY)     clampY=boundingHeight - y;
  }
  if (this.paintBackground || this.paintBorder) {
    if (this.paintBackground) {
      gl.glColor4fv(backgroundColor,0);
      gl.glBegin(GL2.GL_QUADS);
      try {
        borderVertices(gl,boundingHeight,boundingWidth,x + clampX,y + clampY);
      }
  finally {
        gl.glEnd();
      }
    }
    if (this.paintBorder) {
      gl.glColor4fv(borderColor,0);
      gl.glEnable(GL2.GL_LINE_SMOOTH);
      gl.glBegin(GL2.GL_LINE_LOOP);
      try {
        borderVertices(gl,boundingHeight,boundingWidth,x + clampX,y + clampY);
      }
  finally {
        gl.glEnd();
      }
    }
  }
  gl.glDisable(GL2.GL_BLEND);
  if (lines != null && textRenderer != null) {
    GlimpseColor.setColor(textRenderer,textColor);
    textRenderer.beginRendering(width,height);
    try {
      double posX=x + iconSize + borderSize;
      if (iconIds != null && !iconIds.isEmpty())       posX+=textIconSpacing;
      double posY=y - borderSize - textLayout.getLineHeight();
      double iconPosY=Float.NEGATIVE_INFINITY;
      if (wrapTextAroundIcon && icons != null)       iconPosY=y - (iconSize * icons.size() + iconSpacing * (icons.size() - 1) + borderSize);
      for (int i=0; i < lines.size(); i++) {
        if (posY + textLayout.getLineHeight() < iconPosY)         posX=x + borderSize;
        textRenderer.draw(lines.get(i).text,(int)(posX + clampX),(int)(posY + clampY));
        posY=posY - lineSpacing - (textLayout.getLineHeight());
      }
    }
  finally {
      textRenderer.endRendering();
    }
  }
  if (iconIds != null && !iconIds.isEmpty()) {
    atlas.beginRendering();
    try {
      double posY=y - borderSize - iconSize;
      for (int i=0; i < iconIds.size(); i++) {
        Object iconId=iconIds.get(i);
        ImageData iconData=icons.get(i);
        if (iconId != null && iconData != null) {
          double iconScale=iconSize / (double)iconData.getWidth();
          float[] color=defaultIconColor;
          if (iconColors != null && i < iconColors.size()) {
            float[] iconColor=iconColors.get(i);
            if (iconColor != null)             color=iconColor;
          }
          GlimpseColor.glColor(gl,color);
          atlas.drawImage(gl,iconId,(int)(x + borderSize + clampX),(int)(posY + clampY),iconScale,iconScale,0,iconData.getHeight());
          posY=posY - iconSize - iconSpacing;
        }
      }
    }
  finally {
      atlas.endRendering();
    }
  }
}","@Override protected void paintTo(GlimpseContext context,GlimpseBounds bounds,Axis2D axis){
  if (axis == null && !drawInPixelCoords) {
    throw new AxisNotSetException(this,context);
  }
  double x=drawInPixelCoords ? this.x : axis.getAxisX().valueToScreenPixelUnits(this.x);
  double y=drawInPixelCoords ? bounds.getHeight() - this.y : axis.getAxisY().valueToScreenPixelUnits(this.y);
  if (icons == null) {
    loadIcons();
  }
  if (newFont != null) {
    updateTextRenderer();
  }
  if (text != null && textLayout == null && textRenderer != null) {
    updateTextLayout();
  }
  if (iconIds == null || iconIds.isEmpty())   iconSize=0;
  if (iconIds == null && lines == null)   return;
  GL2 gl=context.getGL().getGL2();
  int width=bounds.getWidth();
  int height=bounds.getHeight();
  gl.glMatrixMode(GL2.GL_PROJECTION);
  gl.glLoadIdentity();
  gl.glOrtho(-0.5,width - 1 + 0.5,-0.5,height - 1 + 0.5,-1,1);
  gl.glMatrixMode(GL2.GL_MODELVIEW);
  gl.glLoadIdentity();
  gl.glBlendFunc(GL2.GL_SRC_ALPHA,GL2.GL_ONE_MINUS_SRC_ALPHA);
  gl.glEnable(GL2.GL_BLEND);
  double iconHeight=0;
  if (icons != null)   iconHeight=iconSize * icons.size() + iconSpacing * (icons.size() - 1);
  double textHeight=0;
  if (lines != null)   textHeight=(textLayout.getLineHeight()) * lines.size() + lineSpacing * (lines.size() - 1);
  int boundingHeight=(int)(borderSize * 2 + Math.max(iconHeight,textHeight));
  float textLength=0;
  if (lines != null)   for (int k=0; k < lines.size(); k++)   textLength=Math.max(textLength,lines.get(k).width);
  int boundingWidth=(int)(borderSize * 2 + iconSize + textLength);
  if (iconIds != null && !iconIds.isEmpty() && lines != null)   boundingWidth+=textIconSpacing;
  double clampX=offsetX, clampY=offsetY;
  if (clampToScreenEdges) {
    if (x + boundingWidth + offsetX > bounds.getWidth())     clampX=bounds.getWidth() - boundingWidth - x;
    if (x + offsetX < 0)     clampX=-x;
    if (y + offsetY > bounds.getHeight())     clampY=bounds.getHeight() - y;
    if (boundingHeight > y + offsetY)     clampY=boundingHeight - y;
  }
  if (this.paintBackground || this.paintBorder) {
    if (this.paintBackground) {
      gl.glColor4fv(backgroundColor,0);
      gl.glBegin(GL2.GL_QUADS);
      try {
        borderVertices(gl,boundingHeight,boundingWidth,x + clampX,y + clampY);
      }
  finally {
        gl.glEnd();
      }
    }
    if (this.paintBorder) {
      gl.glColor4fv(borderColor,0);
      gl.glEnable(GL2.GL_LINE_SMOOTH);
      gl.glBegin(GL2.GL_LINE_LOOP);
      try {
        borderVertices(gl,boundingHeight,boundingWidth,x + clampX,y + clampY);
      }
  finally {
        gl.glEnd();
      }
    }
  }
  gl.glDisable(GL2.GL_BLEND);
  if (lines != null && textRenderer != null) {
    GlimpseColor.setColor(textRenderer,textColor);
    textRenderer.beginRendering(width,height);
    try {
      double posX=x + iconSize + borderSize;
      if (iconIds != null && !iconIds.isEmpty())       posX+=textIconSpacing;
      double posY=y - borderSize - textLayout.getLineHeight();
      double iconPosY=Float.NEGATIVE_INFINITY;
      if (wrapTextAroundIcon && icons != null)       iconPosY=y - (iconSize * icons.size() + iconSpacing * (icons.size() - 1) + borderSize);
      for (int i=0; i < lines.size(); i++) {
        if (posY + textLayout.getLineHeight() < iconPosY)         posX=x + borderSize;
        textRenderer.draw(lines.get(i).text,(int)(posX + clampX),(int)(posY + clampY));
        posY=posY - lineSpacing - (textLayout.getLineHeight());
      }
    }
  finally {
      textRenderer.endRendering();
    }
  }
  if (iconIds != null && !iconIds.isEmpty()) {
    atlas.beginRendering();
    try {
      double posY=y - borderSize - iconSize;
      for (int i=0; i < iconIds.size(); i++) {
        Object iconId=iconIds.get(i);
        ImageData iconData=icons.get(i);
        if (iconId != null && iconData != null) {
          double iconScale=iconSize / (double)iconData.getWidth();
          float[] color=defaultIconColor;
          if (iconColors != null && i < iconColors.size()) {
            float[] iconColor=iconColors.get(i);
            if (iconColor != null)             color=iconColor;
          }
          GlimpseColor.glColor(gl,color);
          atlas.drawImage(gl,iconId,(int)(x + borderSize + clampX),(int)(posY + clampY),iconScale,iconScale,0,iconData.getHeight());
          posY=posY - iconSize - iconSpacing;
        }
      }
    }
  finally {
      atlas.endRendering();
    }
  }
}",0.9917504802802576
11461,"public synchronized TooltipPainter setFixedWidth(int fixedWidth){
  this.fixedWidth=fixedWidth;
  this.isFixedWidth=true;
  this.textLayout=null;
  return this;
}","public synchronized TooltipPainter setFixedWidth(int fixedWidth){
  this.fixedWidth=fixedWidth;
  this.isFixedWidth=true;
  this.resetTextLayout();
  return this;
}",0.9631901840490796
11462,"public synchronized TooltipPainter setBreakOnEol(boolean breakOnEol){
  this.breakOnEol=breakOnEol;
  this.textLayout=null;
  return this;
}","public synchronized TooltipPainter setBreakOnEol(boolean breakOnEol){
  this.breakOnEol=breakOnEol;
  this.resetTextLayout();
  return this;
}",0.9574468085106383
11463,"public synchronized TooltipPainter setBorderSize(int size){
  this.borderSize=size;
  this.textLayout=null;
  return this;
}","public synchronized TooltipPainter setBorderSize(int size){
  this.borderSize=size;
  this.resetTextLayout();
  return this;
}",0.952
11464,"public synchronized TooltipPainter setUnlimitedWidth(){
  this.isFixedWidth=false;
  this.textLayout=null;
  return this;
}","public synchronized TooltipPainter setUnlimitedWidth(){
  this.isFixedWidth=false;
  this.resetTextLayout();
  return this;
}",0.9516129032258064
11465,"public synchronized TooltipPainter setWrapTextAroundIcon(boolean wrap){
  this.wrapTextAroundIcon=wrap;
  this.textLayout=null;
  return this;
}","public synchronized TooltipPainter setWrapTextAroundIcon(boolean wrap){
  this.wrapTextAroundIcon=wrap;
  this.resetTextLayout();
  return this;
}",0.9586206896551724
11466,"/** 
 * Sets the icon to be displayed on the first line of the tool tip.
 * @param id the id of the icon in TooltipPainter's TextureAtlas
 */
public synchronized TooltipPainter setIcon(Object iconId){
  this.iconIds=Collections.singletonList(iconId);
  this.iconColors=null;
  this.icons=null;
  return this;
}","/** 
 * Sets the icon to be displayed on the first line of the tool tip.
 * @param id the id of the icon in TooltipPainter's TextureAtlas
 */
public synchronized TooltipPainter setIcon(Object iconId){
  this.iconIds=iconId != null ? Collections.singletonList(iconId) : null;
  this.iconColors=null;
  this.icons=null;
  return this;
}",0.9627329192546584
11467,"public synchronized TooltipPainter setBreakIterator(BreakIterator breakIterator){
  this.breakIterator=breakIterator;
  this.textLayout=null;
  return this;
}","public synchronized TooltipPainter setBreakIterator(BreakIterator breakIterator){
  this.breakIterator=breakIterator;
  this.resetTextLayout();
  return this;
}",0.9622641509433962
11468,"public synchronized TooltipPainter setLineSpacing(int lineSpacing){
  this.lineSpacing=lineSpacing;
  this.textLayout=null;
  return this;
}","public synchronized TooltipPainter setLineSpacing(int lineSpacing){
  this.lineSpacing=lineSpacing;
  this.resetTextLayout();
  return this;
}",0.9574468085106383
11469,"@Override public synchronized TooltipPainter setText(String text){
  this.text=text;
  this.textLayout=null;
  return this;
}","@Override public synchronized TooltipPainter setText(String text){
  this.text=text;
  this.resetTextLayout();
  return this;
}",0.9523809523809524
11470,"@Override protected void paintTo(GlimpseContext context,GlimpseBounds bounds,Axis2D axis){
  if (axis == null && !drawInPixelCoords) {
    throw new AxisNotSetException(this,context);
  }
  double x=drawInPixelCoords ? this.x : axis.getAxisX().valueToScreenPixelUnits(this.x);
  double y=drawInPixelCoords ? this.y : axis.getAxisY().valueToScreenPixelUnits(this.y);
  if (icons == null) {
    loadIcons();
  }
  if (newFont != null) {
    updateTextRenderer();
  }
  if (text != null && textLayout == null && textRenderer != null) {
    updateTextLayout();
  }
  GL2 gl=context.getGL().getGL2();
  int width=bounds.getWidth();
  int height=bounds.getHeight();
  gl.glMatrixMode(GL2.GL_PROJECTION);
  gl.glLoadIdentity();
  gl.glOrtho(-0.5,width - 1 + 0.5,-0.5,height - 1 + 0.5,-1,1);
  gl.glMatrixMode(GL2.GL_MODELVIEW);
  gl.glLoadIdentity();
  gl.glBlendFunc(GL2.GL_SRC_ALPHA,GL2.GL_ONE_MINUS_SRC_ALPHA);
  gl.glEnable(GL2.GL_BLEND);
  double iconHeight=0;
  if (icons != null)   iconHeight=iconSize * icons.size() + iconSpacing * (icons.size() - 1);
  double textHeight=0;
  if (lines != null)   textHeight=(textLayout.getAscent()) * lines.size() + lineSpacing * (lines.size() - 1);
  int boundingHeight=(int)(borderSize * 2 + Math.max(iconHeight,textHeight));
  float textLength=0;
  if (lines != null)   for (int k=0; k < lines.size(); k++)   textLength=Math.max(textLength,lines.get(0).width);
  int boundingWidth=(int)(borderSize * 2 + iconSize + textLength);
  if (iconIds != null && !iconIds.isEmpty() && lines != null)   boundingWidth+=textIconSpacing;
  double clampX=offsetX, clampY=offsetY;
  if (clampToScreenEdges) {
    if (x + boundingWidth + offsetX > bounds.getWidth())     clampX=bounds.getWidth() - boundingWidth - x;
    if (x + offsetX < 0)     clampX=-x;
    if (y + offsetY > bounds.getHeight())     clampY=bounds.getHeight() - y;
    if (boundingHeight > y + offsetY)     clampY=boundingHeight - y;
  }
  if (this.paintBackground || this.paintBorder) {
    if (this.paintBackground) {
      gl.glColor4fv(backgroundColor,0);
      gl.glBegin(GL2.GL_QUADS);
      try {
        borderVertices(gl,boundingHeight,boundingWidth,x + clampX,y + clampY);
      }
  finally {
        gl.glEnd();
      }
    }
    if (this.paintBorder) {
      gl.glColor4fv(borderColor,0);
      gl.glEnable(GL2.GL_LINE_SMOOTH);
      gl.glBegin(GL2.GL_LINE_LOOP);
      try {
        borderVertices(gl,boundingHeight,boundingWidth,x + clampX,y + clampY);
      }
  finally {
        gl.glEnd();
      }
    }
  }
  gl.glDisable(GL2.GL_BLEND);
  if (lines != null && textRenderer != null) {
    GlimpseColor.setColor(textRenderer,textColor);
    textRenderer.beginRendering(width,height);
    try {
      double posX=x + iconSize + borderSize;
      if (iconIds != null && !iconIds.isEmpty())       posX+=textIconSpacing;
      double posY=y - borderSize - textLayout.getAscent();
      double iconPosY=Float.NEGATIVE_INFINITY;
      if (wrapTextAroundIcon && icons != null)       iconPosY=y - (iconSize * icons.size() + iconSpacing * (icons.size() - 1) + borderSize);
      for (int i=0; i < lines.size(); i++) {
        if (posY + textLayout.getAscent() < iconPosY)         posX=x + borderSize;
        textRenderer.draw(lines.get(i).text,(int)(posX + clampX),(int)(posY + clampY));
        posY=posY - lineSpacing - (textLayout.getAscent());
      }
    }
  finally {
      textRenderer.endRendering();
    }
  }
  if (iconIds != null && !iconIds.isEmpty()) {
    atlas.beginRendering();
    try {
      double posY=y - borderSize - iconSize;
      for (int i=0; i < iconIds.size(); i++) {
        Object iconId=iconIds.get(i);
        ImageData iconData=icons.get(i);
        if (iconId != null && iconData != null) {
          double iconScale=iconSize / (double)iconData.getWidth();
          float[] color=defaultIconColor;
          if (iconColors != null && i < iconColors.size()) {
            float[] iconColor=iconColors.get(i);
            if (iconColor != null)             color=iconColor;
          }
          GlimpseColor.glColor(gl,color);
          atlas.drawImage(gl,iconId,(int)(x + borderSize + clampX),(int)(posY + clampY),iconScale,iconScale,0,iconData.getHeight());
          posY=posY - iconSize - iconSpacing;
        }
      }
    }
  finally {
      atlas.endRendering();
    }
  }
}","@Override protected void paintTo(GlimpseContext context,GlimpseBounds bounds,Axis2D axis){
  if (axis == null && !drawInPixelCoords) {
    throw new AxisNotSetException(this,context);
  }
  double x=drawInPixelCoords ? this.x : axis.getAxisX().valueToScreenPixelUnits(this.x);
  double y=drawInPixelCoords ? this.y : axis.getAxisY().valueToScreenPixelUnits(this.y);
  if (icons == null) {
    loadIcons();
  }
  if (newFont != null) {
    updateTextRenderer();
  }
  if (text != null && textLayout == null && textRenderer != null) {
    updateTextLayout();
  }
  if (iconIds == null || iconIds.isEmpty())   iconSize=0;
  GL2 gl=context.getGL().getGL2();
  int width=bounds.getWidth();
  int height=bounds.getHeight();
  gl.glMatrixMode(GL2.GL_PROJECTION);
  gl.glLoadIdentity();
  gl.glOrtho(-0.5,width - 1 + 0.5,-0.5,height - 1 + 0.5,-1,1);
  gl.glMatrixMode(GL2.GL_MODELVIEW);
  gl.glLoadIdentity();
  gl.glBlendFunc(GL2.GL_SRC_ALPHA,GL2.GL_ONE_MINUS_SRC_ALPHA);
  gl.glEnable(GL2.GL_BLEND);
  double iconHeight=0;
  if (icons != null)   iconHeight=iconSize * icons.size() + iconSpacing * (icons.size() - 1);
  double textHeight=0;
  if (lines != null)   textHeight=(textLayout.getLineHeight()) * lines.size() + lineSpacing * (lines.size() - 1);
  int boundingHeight=(int)(borderSize * 2 + Math.max(iconHeight,textHeight));
  float textLength=0;
  if (lines != null)   for (int k=0; k < lines.size(); k++)   textLength=Math.max(textLength,lines.get(0).width);
  int boundingWidth=(int)(borderSize * 2 + iconSize + textLength);
  if (iconIds != null && !iconIds.isEmpty() && lines != null)   boundingWidth+=textIconSpacing;
  double clampX=offsetX, clampY=offsetY;
  if (clampToScreenEdges) {
    if (x + boundingWidth + offsetX > bounds.getWidth())     clampX=bounds.getWidth() - boundingWidth - x;
    if (x + offsetX < 0)     clampX=-x;
    if (y + offsetY > bounds.getHeight())     clampY=bounds.getHeight() - y;
    if (boundingHeight > y + offsetY)     clampY=boundingHeight - y;
  }
  if (this.paintBackground || this.paintBorder) {
    if (this.paintBackground) {
      gl.glColor4fv(backgroundColor,0);
      gl.glBegin(GL2.GL_QUADS);
      try {
        borderVertices(gl,boundingHeight,boundingWidth,x + clampX,y + clampY);
      }
  finally {
        gl.glEnd();
      }
    }
    if (this.paintBorder) {
      gl.glColor4fv(borderColor,0);
      gl.glEnable(GL2.GL_LINE_SMOOTH);
      gl.glBegin(GL2.GL_LINE_LOOP);
      try {
        borderVertices(gl,boundingHeight,boundingWidth,x + clampX,y + clampY);
      }
  finally {
        gl.glEnd();
      }
    }
  }
  gl.glDisable(GL2.GL_BLEND);
  if (lines != null && textRenderer != null) {
    GlimpseColor.setColor(textRenderer,textColor);
    textRenderer.beginRendering(width,height);
    try {
      double posX=x + iconSize + borderSize;
      if (iconIds != null && !iconIds.isEmpty())       posX+=textIconSpacing;
      double posY=y - borderSize - textLayout.getLineHeight();
      double iconPosY=Float.NEGATIVE_INFINITY;
      if (wrapTextAroundIcon && icons != null)       iconPosY=y - (iconSize * icons.size() + iconSpacing * (icons.size() - 1) + borderSize);
      for (int i=0; i < lines.size(); i++) {
        if (posY + textLayout.getLineHeight() < iconPosY)         posX=x + borderSize;
        textRenderer.draw(lines.get(i).text,(int)(posX + clampX),(int)(posY + clampY));
        posY=posY - lineSpacing - (textLayout.getLineHeight());
      }
    }
  finally {
      textRenderer.endRendering();
    }
  }
  if (iconIds != null && !iconIds.isEmpty()) {
    atlas.beginRendering();
    try {
      double posY=y - borderSize - iconSize;
      for (int i=0; i < iconIds.size(); i++) {
        Object iconId=iconIds.get(i);
        ImageData iconData=icons.get(i);
        if (iconId != null && iconData != null) {
          double iconScale=iconSize / (double)iconData.getWidth();
          float[] color=defaultIconColor;
          if (iconColors != null && i < iconColors.size()) {
            float[] iconColor=iconColors.get(i);
            if (iconColor != null)             color=iconColor;
          }
          GlimpseColor.glColor(gl,color);
          atlas.drawImage(gl,iconId,(int)(x + borderSize + clampX),(int)(posY + clampY),iconScale,iconScale,0,iconData.getHeight());
          posY=posY - iconSize - iconSpacing;
        }
      }
    }
  finally {
      atlas.endRendering();
    }
  }
}",0.9869025735294118
11471,"protected void updateTextLayout(){
  Font font=textRenderer.getFont();
  FontRenderContext frc=textRenderer.getFontRenderContext();
  textLayout=new SimpleTextLayoutCenter(font,frc,breakIterator);
  textLayout.setBreakOnEol(breakOnEol);
  textLayout.setLineSpacing(lineSpacing);
  if (iconSize == 0)   iconSize=(float)textLayout.getAscent();
  textLayout.doLayout(text,0,0,isFixedWidth ? fixedWidth : Float.MAX_VALUE);
  lines=textLayout.getLines();
}","protected void updateTextLayout(){
  Font font=textRenderer.getFont();
  FontRenderContext frc=textRenderer.getFontRenderContext();
  textLayout=new SimpleTextLayoutCenter(font,frc,breakIterator);
  textLayout.setBreakOnEol(breakOnEol);
  textLayout.setLineSpacing(lineSpacing);
  if (iconSize == 0)   iconSize=(float)textLayout.getLineHeight();
  textLayout.doLayout(text,0,0,isFixedWidth ? fixedWidth : Float.MAX_VALUE);
  lines=textLayout.getLines();
}",0.9845474613686536
11472,"public synchronized TooltipPainter setFixedWidth(int fixedWidth){
  this.fixedWidth=fixedWidth;
  this.isFixedWidth=true;
  this.lines=null;
  return this;
}","public synchronized TooltipPainter setFixedWidth(int fixedWidth){
  this.fixedWidth=fixedWidth;
  this.isFixedWidth=true;
  this.textLayout=null;
  return this;
}",0.9592476489028212
11473,"public synchronized TooltipPainter setBorderSize(int size){
  this.borderSize=size;
  this.lines=null;
  return this;
}","public synchronized TooltipPainter setBorderSize(int size){
  this.borderSize=size;
  this.textLayout=null;
  return this;
}",0.9465020576131687
11474,"public synchronized TooltipPainter setUnlimitedWidth(){
  this.isFixedWidth=false;
  this.lines=null;
  return this;
}","public synchronized TooltipPainter setUnlimitedWidth(){
  this.isFixedWidth=false;
  this.textLayout=null;
  return this;
}",0.946058091286307
11475,"public synchronized TooltipPainter setWrapTextAroundIcon(boolean wrap){
  this.wrapTextAroundIcon=wrap;
  this.lines=null;
  return this;
}","public synchronized TooltipPainter setWrapTextAroundIcon(boolean wrap){
  this.wrapTextAroundIcon=wrap;
  this.textLayout=null;
  return this;
}",0.9540636042402828
11476,"@Override public synchronized TooltipPainter setText(String text){
  this.text=text;
  this.lines=null;
  return this;
}","@Override public synchronized TooltipPainter setText(String text){
  this.text=text;
  this.textLayout=null;
  return this;
}",0.946938775510204
11477,"/** 
 * @param font The font to use for the layout
 * @param frc The FontRenderContext used to rasterize the font. This will help define the character bounds
 * @param breaker The BreakIterator that is used to break the text (also see {@link #forceBreakAfter(int)})
 */
public SimpleTextLayout(Font font,FontRenderContext frc,BreakIterator breaker){
  this.font=font;
  this.frc=frc;
  this.breaker=breaker;
  Rectangle2D rect=font.getMaxCharBounds(frc);
  ascent=(float)(rect.getMaxY() - rect.getY());
  descent=(float)-rect.getY();
  setLineSpacing(0);
  setBreakOnEol(true);
}","/** 
 * @param font The font to use for the layout
 * @param frc The FontRenderContext used to rasterize the font. This will help define the character bounds
 * @param breaker The BreakIterator that is used to break the text (also see {@link #forceBreakAfter(int)})
 */
public SimpleTextLayout(Font font,FontRenderContext frc,BreakIterator breaker){
  this.font=font;
  this.frc=frc;
  this.breaker=breaker;
  Rectangle2D rect=font.getMaxCharBounds(frc);
  ascent=(float)(rect.getMaxY() - rect.getY());
  descent=(float)-rect.getY();
  lineHeight=font.getSize();
  setLineSpacing(0);
  setBreakOnEol(true);
}",0.9755686604886268
11478,"protected void loadIcons(){
  int size=iconIds == null ? 0 : iconIds.size();
  this.icons=Lists.newArrayListWithCapacity(size);
  this.noIcons=true;
  for (int i=0; i < size; i++) {
    Object iconId=this.iconIds.get(i);
    ImageData icon=iconId != null ? atlas.getImageData(iconId) : null;
    if (icon != null)     noIcons=false;
    this.icons.add(icon);
  }
}","protected void loadIcons(){
  atlas.beginRendering();
  atlas.endRendering();
  int size=iconIds == null ? 0 : iconIds.size();
  this.icons=Lists.newArrayListWithCapacity(size);
  this.noIcons=true;
  for (int i=0; i < size; i++) {
    Object iconId=this.iconIds.get(i);
    ImageData icon=iconId != null ? atlas.getImageData(iconId) : null;
    if (icon != null)     noIcons=false;
    this.icons.add(icon);
  }
}",0.93573264781491
11479,"@Override public StackedTimePlot2D getLayout(){
  final CollapsibleTimePlot2D plot=(CollapsibleTimePlot2D)super.getLayout();
  plot.setLabelSize(120);
  for (  TimePlotInfo row : plot.getAllTimePlots()) {
    GroupInfo group=plot.createGroup(String.format(""String_Node_Str"",row.getId()),row);
    row.getLabelPainter().setText(""String_Node_Str"");
    group.setLabelText(""String_Node_Str"");
    setPlotLookAndFeel(row);
  }
  final EventPlotInfo events1=plot.createEventPlot(""String_Node_Str"");
  EventPlotInfo events2=plot.createEventPlot(""String_Node_Str"");
  EventPlotInfo events3=plot.createEventPlot(""String_Node_Str"");
  events1.setLabelText(""String_Node_Str"");
  events2.setLabelText(""String_Node_Str"");
  events3.setLabelText(""String_Node_Str"");
  setPlotLookAndFeel(events1);
  setPlotLookAndFeel(events2);
  setPlotLookAndFeel(events3);
  events1.getLabelPainter().setVerticalPosition(VerticalPosition.Center);
  events2.getLabelPainter().setVerticalPosition(VerticalPosition.Center);
  events3.getLabelPainter().setVerticalPosition(VerticalPosition.Center);
  GroupInfo group=plot.createGroup(""String_Node_Str"",events1,events2,events3);
  group.setLabelText(""String_Node_Str"");
  group.setOrder(100);
  events1.setOrder(2);
  events2.setOrder(3);
  events3.setOrder(4);
  events1.setDefaultEventBackgroundColor(GlimpseColor.getGreen(0.6f));
  events1.setDefaultEventBorderColor(GlimpseColor.getGreen());
  events3.setDefaultEventBackgroundColor(GlimpseColor.getCyan(0.6f));
  events3.setDefaultEventBorderColor(GlimpseColor.getCyan());
  Epoch e=plot.getEpoch();
  TimeStamp t0=e.toTimeStamp(0);
  Event e0=events1.addEvent(""String_Node_Str"",t0,t0.add(Time.fromMinutes(20)));
  e0.setShowBackground(false);
  events1.addEvent(""String_Node_Str"",t0.add(Time.fromMinutes(30)),t0.add(Time.fromMinutes(200)));
  Event e1=events1.addEvent(""String_Node_Str"",t0.add(Time.fromMinutes(290)),t0.add(Time.fromMinutes(320)));
  e1.setBackgroundColor(GlimpseColor.getRed(0.6f));
  e1.setBorderColor(GlimpseColor.getRed());
  Event e2=events1.addEvent(""String_Node_Str"",t0.add(Time.fromMinutes(-200)),t0.add(Time.fromMinutes(100)));
  Event e3=events1.addEvent(""String_Node_Str"",t0.add(Time.fromMinutes(100)),t0.add(Time.fromMinutes(300)));
  Event e4=events1.addEvent(""String_Node_Str"",t0.subtract(Time.fromMinutes(40)));
  events2.addEvent(""String_Node_Str"",t0.add(Time.fromMinutes(-250)),t0.add(Time.fromMinutes(-240)));
  events2.addEvent(""String_Node_Str"",t0.add(Time.fromMinutes(-220)),t0.add(Time.fromMinutes(-200)));
  events2.addEvent(""String_Node_Str"",t0.add(Time.fromMinutes(-170)),t0.add(Time.fromMinutes(-100)));
  events1.setAggregateNearbyEvents(true);
  events2.setAggregateNearbyEvents(true);
  e0.setEndTimeMoveable(false);
  e1.setResizeable(false);
  e2.setMinTimeSpan(Time.fromMinutes(100));
  e3.setMaxTimeSpan(Time.fromMinutes(500));
  events1.getEventSelectionHandler().setClearSelectionOnClick(true);
  e2.setSelectable(false);
  e2.setFixedRow(2);
  events1.validate();
  TextureAtlas atlas=plot.getTextureAtlas();
  try {
    atlas.loadImage(""String_Node_Str"",ImageIO.read(StreamOpener.fileThenResource.openForRead(""String_Node_Str"")));
    atlas.loadImage(""String_Node_Str"",ImageIO.read(StreamOpener.fileThenResource.openForRead(""String_Node_Str"")));
    atlas.loadImage(""String_Node_Str"",ImageIO.read(StreamOpener.fileThenResource.openForRead(""String_Node_Str"")));
    atlas.loadImage(""String_Node_Str"",ImageIO.read(StreamOpener.fileThenResource.openForRead(""String_Node_Str"")));
  }
 catch (  IOException ex) {
    logWarning(logger,""String_Node_Str"",ex);
  }
  e1.setIconId(""String_Node_Str"");
  e2.setIconId(""String_Node_Str"");
  e3.setIconId(""String_Node_Str"");
  e4.setIconId(""String_Node_Str"");
  plot.getTooltipPainter().setFixedWidth(300);
  e0.setToolTipText(""String_Node_Str"");
  e1.setToolTipText(""String_Node_Str"");
  e2.setToolTipText(""String_Node_Str"");
  e3.setToolTipText(""String_Node_Str"");
  e4.setToolTipText(""String_Node_Str"");
  events1.addEventPlotListener(new EventPlotListener(){
    @Override public void eventsHovered(    GlimpseMouseEvent e,    Set<EventSelection> events,    TimeStamp time){
      if (!events.isEmpty())       logInfo(logger,""String_Node_Str"",events,time);
    }
    @Override public void eventsClicked(    GlimpseMouseEvent e,    Set<EventSelection> events,    TimeStamp time){
      if (!events.isEmpty())       logInfo(logger,""String_Node_Str"",events,time);
    }
    @Override public void eventsExited(    GlimpseMouseEvent e,    Set<EventSelection> events,    TimeStamp time){
      if (!events.isEmpty())       logInfo(logger,""String_Node_Str"",events,time);
    }
    @Override public void eventsEntered(    GlimpseMouseEvent e,    Set<EventSelection> events,    TimeStamp time){
      if (!events.isEmpty())       logInfo(logger,""String_Node_Str"",events,time);
    }
    @Override public void eventUpdated(    GlimpseMouseEvent e,    Event event){
      logInfo(logger,""String_Node_Str"",event);
    }
  }
);
  plot.getEventSelectionHander().addEventSelectionListener(new EventSelectionListener(){
    @Override public void eventsSelected(    Set<Event> selectedEvents,    Set<Event> deselectedEvents){
      logInfo(logger,""String_Node_Str"",selectedEvents,deselectedEvents);
    }
  }
);
  events1.getEventSelectionHandler().setSelectedEventBorderThickness(3.0f);
  plot.setTimeAxisMouseListener(new TaggedAxisMouseListener1D());
  plot.getSelectedTimePainter().setShowLockedStatus(false);
  plot.getTimeAxis().addAxisListener(new TaggedAxisListener1D(){
    @Override public void tagsUpdated(    TaggedAxis1D axis){
      Tag s=plot.getTimeSelectionTag();
      Tag m=plot.getTimeSelectionMaxTag();
      if (s != null && m != null && s.getValue() != m.getValue()) {
        s.setValue(m.getValue());
        axis.validateTags();
      }
    }
  }
);
  return plot;
}","@Override public StackedTimePlot2D getLayout(){
  final CollapsibleTimePlot2D plot=(CollapsibleTimePlot2D)super.getLayout();
  plot.setLabelSize(120);
  for (  TimePlotInfo row : plot.getAllTimePlots()) {
    GroupInfo group=plot.createGroup(String.format(""String_Node_Str"",row.getId()),row);
    row.getLabelPainter().setText(""String_Node_Str"");
    group.setLabelText(""String_Node_Str"");
    setPlotLookAndFeel(row);
  }
  final EventPlotInfo events1=plot.createEventPlot(""String_Node_Str"");
  EventPlotInfo events2=plot.createEventPlot(""String_Node_Str"");
  EventPlotInfo events3=plot.createEventPlot(""String_Node_Str"");
  events1.setLabelText(""String_Node_Str"");
  events2.setLabelText(""String_Node_Str"");
  events3.setLabelText(""String_Node_Str"");
  setPlotLookAndFeel(events1);
  setPlotLookAndFeel(events2);
  setPlotLookAndFeel(events3);
  events1.getLabelPainter().setVerticalPosition(VerticalPosition.Center);
  events2.getLabelPainter().setVerticalPosition(VerticalPosition.Center);
  events3.getLabelPainter().setVerticalPosition(VerticalPosition.Center);
  GroupInfo group=plot.createGroup(""String_Node_Str"",events1,events2,events3);
  group.setLabelText(""String_Node_Str"");
  group.setOrder(100);
  events1.setOrder(2);
  events2.setOrder(3);
  events3.setOrder(4);
  events1.setDefaultEventBackgroundColor(GlimpseColor.getGreen(0.6f));
  events1.setDefaultEventBorderColor(GlimpseColor.getGreen());
  events3.setDefaultEventBackgroundColor(GlimpseColor.getCyan(0.6f));
  events3.setDefaultEventBorderColor(GlimpseColor.getCyan());
  Epoch e=plot.getEpoch();
  TimeStamp t0=e.toTimeStamp(0);
  Event e0=events1.addEvent(""String_Node_Str"",t0,t0.add(Time.fromMinutes(20)));
  e0.setShowBackground(false);
  events1.addEvent(""String_Node_Str"",t0.add(Time.fromMinutes(30)),t0.add(Time.fromMinutes(200)));
  Event e1=events1.addEvent(""String_Node_Str"",t0.add(Time.fromMinutes(290)),t0.add(Time.fromMinutes(320)));
  e1.setBackgroundColor(GlimpseColor.getRed(0.6f));
  e1.setBorderColor(GlimpseColor.getRed());
  Event e2=events1.addEvent(""String_Node_Str"",t0.add(Time.fromMinutes(-200)),t0.add(Time.fromMinutes(100)));
  Event e3=events1.addEvent(""String_Node_Str"",t0.add(Time.fromMinutes(100)),t0.add(Time.fromMinutes(300)));
  Event e4=events1.addEvent(""String_Node_Str"",t0.subtract(Time.fromMinutes(40)));
  events2.addEvent(""String_Node_Str"",t0.add(Time.fromMinutes(-250)),t0.add(Time.fromMinutes(-240)));
  events2.addEvent(""String_Node_Str"",t0.add(Time.fromMinutes(-220)),t0.add(Time.fromMinutes(-200)));
  events2.addEvent(""String_Node_Str"",t0.add(Time.fromMinutes(-170)),t0.add(Time.fromMinutes(-100)));
  events1.setAggregateNearbyEvents(true);
  events2.setAggregateNearbyEvents(true);
  e0.setEndTimeMoveable(false);
  e1.setResizeable(false);
  e2.setMinTimeSpan(Time.fromMinutes(100));
  e3.setMaxTimeSpan(Time.fromMinutes(500));
  events1.getEventSelectionHandler().setClearSelectionOnClick(true);
  e2.setSelectable(false);
  e2.setFixedRow(2);
  events1.validate();
  TextureAtlas atlas=plot.getTextureAtlas();
  try {
    atlas.loadImage(""String_Node_Str"",ImageIO.read(StreamOpener.fileThenResource.openForRead(""String_Node_Str"")));
    atlas.loadImage(""String_Node_Str"",ImageIO.read(StreamOpener.fileThenResource.openForRead(""String_Node_Str"")));
    atlas.loadImage(""String_Node_Str"",ImageIO.read(StreamOpener.fileThenResource.openForRead(""String_Node_Str"")));
    atlas.loadImage(""String_Node_Str"",ImageIO.read(StreamOpener.fileThenResource.openForRead(""String_Node_Str"")));
  }
 catch (  IOException ex) {
    logWarning(logger,""String_Node_Str"",ex);
  }
  e1.setIconId(""String_Node_Str"");
  e2.setIconId(""String_Node_Str"");
  e3.setIconId(""String_Node_Str"");
  e4.setIconId(""String_Node_Str"");
  plot.getTooltipPainter().setFixedWidth(300);
  e0.setToolTipText(""String_Node_Str"");
  e1.setToolTipText(""String_Node_Str"");
  e2.setToolTipText(""String_Node_Str"");
  e3.setToolTipText(""String_Node_Str"");
  e4.setToolTipText(""String_Node_Str"");
  events1.addEventPlotListener(new EventPlotListener(){
    @Override public void eventsHovered(    GlimpseMouseEvent e,    Set<EventSelection> events,    TimeStamp time){
      if (!events.isEmpty())       logInfo(logger,""String_Node_Str"",events,time);
    }
    @Override public void eventsClicked(    GlimpseMouseEvent e,    Set<EventSelection> events,    TimeStamp time){
      if (!events.isEmpty())       logInfo(logger,""String_Node_Str"",events,time);
    }
    @Override public void eventsExited(    GlimpseMouseEvent e,    Set<EventSelection> events,    TimeStamp time){
      if (!events.isEmpty())       logInfo(logger,""String_Node_Str"",events,time);
    }
    @Override public void eventsEntered(    GlimpseMouseEvent e,    Set<EventSelection> events,    TimeStamp time){
      if (!events.isEmpty())       logInfo(logger,""String_Node_Str"",events,time);
    }
    @Override public void eventUpdated(    GlimpseMouseEvent e,    Event event){
      logInfo(logger,""String_Node_Str"",event);
    }
  }
);
  plot.getEventSelectionHander().addEventSelectionListener(new EventSelectionListener(){
    @Override public void eventsSelected(    Set<Event> selectedEvents,    Set<Event> deselectedEvents){
      logInfo(logger,""String_Node_Str"",selectedEvents,deselectedEvents);
    }
  }
);
  events1.getEventSelectionHandler().setSelectedEventBorderThickness(3.0f);
  plot.setTimeAxisMouseListener(new TaggedAxisMouseListener1D());
  plot.getSelectedTimePainter().setShowLockedStatus(false);
  plot.getTimeAxis().addAxisListener(new TaggedAxisListener1D(){
    @Override public void tagsUpdated(    TaggedAxis1D axis){
      Tag s=plot.getTimeSelectionTag();
      Tag m=plot.getTimeSelectionMaxTag();
      if (s != null && m != null && s.getValue() != m.getValue()) {
        s.setValue(m.getValue());
        plot.getTimeAxis().validateTags();
      }
    }
  }
);
  return plot;
}",0.998632712356862
11480,"@Override public void tagsUpdated(TaggedAxis1D axis){
  Tag s=plot.getTimeSelectionTag();
  Tag m=plot.getTimeSelectionMaxTag();
  if (s != null && m != null && s.getValue() != m.getValue()) {
    s.setValue(m.getValue());
    axis.validateTags();
  }
}","@Override public void tagsUpdated(TaggedAxis1D axis){
  Tag s=plot.getTimeSelectionTag();
  Tag m=plot.getTimeSelectionMaxTag();
  if (s != null && m != null && s.getValue() != m.getValue()) {
    s.setValue(m.getValue());
    plot.getTimeAxis().validateTags();
  }
}",0.9576923076923076
11481,"protected void axisUpdated0(Axis1D axis){
  this.updateMode=axis.getUpdateMode();
  this.minDiff=axis.getMinSpan();
  this.maxDiff=axis.getMaxSpan();
  this.constrainMinDiff=axis.isMinSpanConstrained();
  this.constrainMaxDiff=axis.isMaxSpanConstrained();
  this.lockMin=axis.isLockMin();
  this.lockMax=axis.isLockMax();
  this.lockMinValue=axis.getLockMin();
  this.lockMaxValue=axis.getLockMax();
  this.absoluteMin=axis.getAbsoluteMin();
  this.absoluteMax=axis.getAbsoluteMax();
  this.selectionCenterValue=axis.getSelectionCenter();
  this.selectionSizeValue=axis.getSelectionSize();
  this.selectionLocked=axis.isSelectionLocked();
  if (!this.isInitialized()) {
    this.minValue=axis.getMin();
    this.maxValue=axis.getMax();
    this.pixelsPerValue=axis.getPixelsPerValue();
  }
 else   if (this.updateMode == UpdateMode.MinScale) {
    this.minValue=axis.getMin();
    this.pixelsPerValue=axis.getPixelsPerValue();
    this.recalculateMaxValue0();
    this.applyConstraints();
  }
 else   if (this.updateMode == UpdateMode.CenterScale) {
    this.pixelsPerValue=axis.getPixelsPerValue();
    double centerValue=(axis.getMax() - axis.getMin()) / 2.0 + axis.getMin();
    this.recalculateMinMaxValue0(centerValue);
    this.applyConstraints();
  }
 else   if (this.updateMode == UpdateMode.MinMax) {
    this.minValue=axis.getMin();
    this.maxValue=axis.getMax();
    this.recalculatePixelsPerValue0();
    this.applyConstraints();
  }
 else   if (this.updateMode == UpdateMode.FixedPixel) {
  }
}","protected void axisUpdated0(Axis1D axis){
  this.updateMode=axis.getUpdateMode();
  this.mousePosValue=axis.getMouseValue();
  this.minDiff=axis.getMinSpan();
  this.maxDiff=axis.getMaxSpan();
  this.constrainMinDiff=axis.isMinSpanConstrained();
  this.constrainMaxDiff=axis.isMaxSpanConstrained();
  this.lockMin=axis.isLockMin();
  this.lockMax=axis.isLockMax();
  this.lockMinValue=axis.getLockMin();
  this.lockMaxValue=axis.getLockMax();
  this.absoluteMin=axis.getAbsoluteMin();
  this.absoluteMax=axis.getAbsoluteMax();
  this.selectionCenterValue=axis.getSelectionCenter();
  this.selectionSizeValue=axis.getSelectionSize();
  this.selectionLocked=axis.isSelectionLocked();
  if (!this.isInitialized()) {
    this.minValue=axis.getMin();
    this.maxValue=axis.getMax();
    this.pixelsPerValue=axis.getPixelsPerValue();
  }
 else   if (this.updateMode == UpdateMode.MinScale) {
    this.minValue=axis.getMin();
    this.pixelsPerValue=axis.getPixelsPerValue();
    this.recalculateMaxValue0();
    this.applyConstraints();
  }
 else   if (this.updateMode == UpdateMode.CenterScale) {
    this.pixelsPerValue=axis.getPixelsPerValue();
    double centerValue=(axis.getMax() - axis.getMin()) / 2.0 + axis.getMin();
    this.recalculateMinMaxValue0(centerValue);
    this.applyConstraints();
  }
 else   if (this.updateMode == UpdateMode.MinMax) {
    this.minValue=axis.getMin();
    this.maxValue=axis.getMax();
    this.recalculatePixelsPerValue0();
    this.applyConstraints();
  }
 else   if (this.updateMode == UpdateMode.FixedPixel) {
  }
}",0.985952303168899
11482,"public Axis1D getAxis(GlimpseTargetStack stack){
  AxisFactory1D factory=getAxisFactory0(stack);
  for (  GlimpseTarget target : stack.getTargetList()) {
    if (target instanceof GlimpseAxisLayout2D) {
      GlimpseAxisLayout2D layout=(GlimpseAxisLayout2D)target;
      if (layout.isAxisSet()) {
        return getCachedAxis0(getAxis(layout.getAxis()),factory,stack);
      }
    }
 else     if (target instanceof GlimpseAxisLayout1D) {
      GlimpseAxisLayout1D layout=(GlimpseAxisLayout1D)target;
      if (layout.isAxisSet()) {
        return getCachedAxis0(layout.getAxis(),factory,stack);
      }
    }
  }
  return null;
}","public Collection<Axis1D> getAxis(TargetStackMatcher matcher){
  return this.cache.getMatching(matcher);
}",0.1523809523809524
11483,"public Collection<Axis2D> getAxis(GlimpseLayoutPredicate predicate){
  return this.cache.getMatching(predicate);
}","public Collection<Axis2D> getAxis(TargetStackMatcher matcher){
  return this.cache.getMatching(matcher);
}",0.7818181818181819
11484,"/** 
 * @return all keys in the cache which match the provided predicate
 */
public Collection<D> getMatching(GlimpseLayoutPredicate predicate){
  ArrayList<D> acum=Lists.newArrayList();
  for (  List<GlimpseTarget> key : map.keySet()) {
    if (predicate.matches(key)) {
      acum.add(map.get(key).second());
    }
  }
  return acum;
}","/** 
 * @return all keys in the cache which match the provided predicate
 */
public Collection<D> getMatching(TargetStackMatcher matcher){
  ArrayList<D> acum=Lists.newArrayList();
  for (  List<GlimpseTarget> key : map.keySet()) {
    if (matcher.matches(key)) {
      acum.add(map.get(key).second());
    }
  }
  return acum;
}",0.8888888888888888
11485,"protected void addTimeTags(TaggedAxis1D axis){
  axis.addTag(MIN_TIME,0);
  axis.addTag(MAX_TIME,10);
  axis.addTag(CURRENT_TIME,10);
  axis.addConstraint(new Constraint(){
    @Override public void applyConstraint(    TaggedAxis1D axis){
      Tag minTag=axis.getTag(MIN_TIME);
      Tag maxTag=axis.getTag(MAX_TIME);
      Tag currentTag=axis.getTag(CURRENT_TIME);
      double minValue=minTag.getValue();
      double maxValue=maxTag.getValue();
      double currentValue=currentTag.getValue();
      if (minValue > maxValue) {
        minTag.setValue(maxValue);
      }
      if (currentValue < minValue) {
        currentTag.setValue(minValue);
      }
 else       if (currentValue > maxValue) {
        currentTag.setValue(maxValue);
      }
    }
    @Override public String getName(){
      return ""String_Node_Str"";
    }
  }
);
}","protected void addTimeTags(TaggedAxis1D axis){
  axis.addTag(MIN_TIME,0);
  axis.addTag(MAX_TIME,10);
  axis.addTag(CURRENT_TIME,10);
  axis.addConstraint(new OrderedConstraint(""String_Node_Str"",Arrays.asList(MIN_TIME,CURRENT_TIME,MAX_TIME)));
}",0.3284132841328413
11486,"@Override protected void paintTo(GlimpseContext context,GlimpseBounds bounds,Axis2D axis){
}","@Override protected void paintTo(GlimpseContext context,GlimpseBounds bounds,Axis2D axis){
  if (axis == null && !drawInPixelCoords) {
    throw new AxisNotSetException(this,context);
  }
  double x=drawInPixelCoords ? this.x : axis.getAxisX().valueToScreenPixelUnits(this.x);
  double y=drawInPixelCoords ? this.y : axis.getAxisY().getSizePixels() - axis.getAxisY().valueToScreenPixelUnits(this.y);
  if (icons == null) {
    loadIcons();
  }
  if (newFont != null) {
    updateTextRenderer();
  }
  if (textLayout == null && textRenderer != null) {
    if (text == null)     setText(""String_Node_Str"");
    updateTextLayout();
  }
  if (lines == null && textLayout != null && text != null) {
    updateLayout();
  }
  if (textRenderer == null || lines == null)   return;
  GL2 gl=context.getGL().getGL2();
  int width=bounds.getWidth();
  int height=bounds.getHeight();
  double clampX=0;
  double clampY=0;
  if (clampToScreenEdges) {
    double maxX=x + linesBounds.maxX + offsetX;
    if (maxX > width)     clampX=width - maxX;
    double minX=x + linesBounds.minX + offsetX;
    if (minX < 0)     clampX=-minX;
    double maxY=height - y + linesBounds.maxY + offsetY;
    if (maxY > height)     clampY=height - maxY;
    double minY=height - y + linesBounds.minY + offsetY;
    if (minY < 0)     clampY=-minY;
  }
  gl.glMatrixMode(GL2.GL_PROJECTION);
  gl.glLoadIdentity();
  gl.glOrtho(-0.5,width - 1 + 0.5,-0.5,height - 1 + 0.5,-1,1);
  gl.glMatrixMode(GL2.GL_MODELVIEW);
  gl.glLoadIdentity();
  gl.glBlendFunc(GL2.GL_SRC_ALPHA,GL2.GL_ONE_MINUS_SRC_ALPHA);
  gl.glEnable(GL2.GL_BLEND);
  if (this.paintBackground || this.paintBorder) {
    if (this.paintBackground) {
      gl.glColor4fv(backgroundColor,0);
      gl.glBegin(GL2.GL_QUADS);
      try {
        borderVertices(gl,height,clampX + offsetX,clampY + offsetY,x,y);
      }
  finally {
        gl.glEnd();
      }
    }
    if (this.paintBorder) {
      gl.glColor4fv(borderColor,0);
      gl.glEnable(GL2.GL_LINE_SMOOTH);
      gl.glBegin(GL2.GL_LINE_LOOP);
      try {
        borderVertices(gl,height,clampX + offsetX,clampY + offsetY,x,y);
      }
  finally {
        gl.glEnd();
      }
    }
  }
  gl.glDisable(GL2.GL_BLEND);
  GlimpseColor.setColor(textRenderer,textColor);
  textRenderer.beginRendering(width,height);
  try {
    for (int i=0; i < lines.size(); i++) {
      TextBoundingBox line=lines.get(i);
      float iconsize=getIconSpacing(i);
      int posX=(int)(x + line.leftX + iconsize+ clampX+ offsetX);
      int posY=(int)(height - y + line.getMinY() + clampY + offsetY);
      textRenderer.draw(line.text,posX,posY);
    }
  }
  finally {
    textRenderer.endRendering();
  }
  if (!lines.isEmpty() && iconIds != null && !iconIds.isEmpty()) {
    atlas.beginRendering();
    try {
      for (int i=0; i < iconIds.size(); i++) {
        Object iconId=iconIds.get(i);
        ImageData iconData=icons.get(i);
        TextBoundingBox line=lines.get(i);
        if (iconId != null && iconData != null && line != null) {
          double iconScale=iconSize / (double)iconData.getWidth();
          int posX=(int)(x + line.leftX + clampX+ offsetX);
          int posY=(int)(height - y + line.getMinY() + clampY + offsetY - textLayout.getDescent() * 0.25);
          float[] color=defaultIconColor;
          if (iconColors != null && i < iconColors.size()) {
            float[] iconColor=iconColors.get(i);
            if (iconColor != null) {
              color=iconColor;
            }
          }
          GlimpseColor.glColor(gl,color);
          atlas.drawImage(gl,iconId,posX,posY,iconScale,iconScale,0,iconData.getHeight());
        }
      }
    }
  finally {
      atlas.endRendering();
    }
  }
}",0.0485744456177402
11487,"@Override public ColorAxisPlot2D getLayout(){
  return getLayout(ColorGradients.purpleBone);
}","@Override public ColorAxisPlot2D getLayout(){
  return getLayout(ColorGradients.lighten(ColorGradients.winter,.25));
}",0.8301886792452831
11488,"public NamedConstraint(String name){
  this.name=name;
}","public NamedConstraint(String name){
  this.name=name;
  this.previousTags=Collections.emptyMap();
}",0.717948717948718
11489,"@Override public Axis1D clone(){
  TaggedAxis1D axis=new TaggedAxis1D(this);
  for (  Tag tag : this.getSortedTags()) {
    axis.addTag(new Tag(tag));
  }
  for (  Constraint constraint : this.getAllConstraints()) {
    axis.addConstraint(constraint);
  }
  return axis;
}","@Override public TaggedAxis1D clone(){
  TaggedAxis1D axis=new TaggedAxis1D(this);
  for (  Tag tag : this.getSortedTags()) {
    axis.addTag(new Tag(tag));
  }
  for (  Constraint constraint : this.getAllConstraints()) {
    axis.addConstraint(constraint);
  }
  return axis;
}",0.9890909090909092
11490,"public MapPlot2D getLayout(GeoProjection projection){
  MapPlot2D plot=new MapPlot2D(projection){
    @Override protected Axis1D createAxisZ(){
      return new TaggedAxis1D();
    }
    @Override protected AxisMouseListener createAxisMouseListenerZ(){
      return new TaggedAxisMouseListener1D();
    }
    @Override protected NumericAxisPainter createAxisPainterZ(    AxisLabelHandler tickHandler){
      return new TaggedPartialColorYAxisPainter(tickHandler);
    }
  }
;
  TaggedAxis1D axisZ=(TaggedAxis1D)plot.getAxisZ();
  final Tag maxTag=axisZ.addTag(""String_Node_Str"",10000.0).setAttribute(TEX_COORD_ATTR,1.0f);
  final Tag seaLevelTag=axisZ.addTag(""String_Node_Str"",0.0).setAttribute(TEX_COORD_ATTR,0.5f);
  final Tag minTag=axisZ.addTag(""String_Node_Str"",-8000.0).setAttribute(TEX_COORD_ATTR,0.0f);
  axisZ.addConstraint(new NamedConstraint(""String_Node_Str""){
    protected double buffer=200;
    @Override public void applyConstraint(    TaggedAxis1D axis){
      if (seaLevelTag.getValue() > maxTag.getValue() - buffer)       seaLevelTag.setValue(maxTag.getValue() - buffer);
      if (minTag.getValue() > seaLevelTag.getValue() - buffer)       minTag.setValue(seaLevelTag.getValue() - buffer);
    }
  }
);
  BathymetryData bathymetryData;
  try {
    bathymetryData=new BathymetryData(StreamOpener.fileThenResource.openForRead(""String_Node_Str""),projection);
  }
 catch (  IOException e) {
    e.printStackTrace();
    throw new RuntimeException(e);
  }
  FloatTextureProjected2D texture=bathymetryData.getTexture();
  ColorTexture1D elevationColors=new ColorTexture1D(1024);
  elevationColors.mutate(new ColorGradientConcatenator(ColorGradients.bathymetry,ColorGradients.topography));
  bathymetryPainter=new TaggedHeatMapPainter(axisZ);
  bathymetryPainter.setData(texture);
  bathymetryPainter.setColorScale(elevationColors);
  ((ColorYAxisPainter)plot.getAxisPainterZ()).setColorScale(elevationColors);
  double[] contourLevels=new double[]{-4000,-3000,-2000,-1000,-900,-800,-700,-600,-500,-400,-300,-200,-100,-50,-10};
  ContourData contourData=new ContourData(bathymetryData,projection,contourLevels);
  contourPainter=new ContourPainter(contourData);
  contourPainter.setLineColor(1.0f,1.0f,1.0f,0.5f);
  contourPainter.setLineWidth(1.6f);
  bathymetryData.setAxisBounds(plot.getAxis());
  plot.setAxisSizeZ(60);
  plot.setMinZ(-5000);
  plot.setMaxZ(2000);
  plot.setShowMinorTicksX(true);
  plot.setShowMinorTicksY(true);
  plot.setShowMinorTicksZ(true);
  plot.addPainter(bathymetryPainter);
  plot.addPainter(contourPainter);
  CursorTextZPainter cursorPainter=new CursorTextZPainter();
  plot.addPainter(cursorPainter);
  cursorPainter.setTexture(texture);
  annotationPainter=new AnnotationPainter();
  plot.addPainter(annotationPainter);
  LatLonTrackPainter dotPainter=new LatLonTrackPainter(projection);
  plot.addPainter(dotPainter);
  dotPainter.setShowLines(1,false);
  dotPainter.setPointSize(1,5.0f);
  dotPainter.setPointColor(1,GlimpseColor.getBlack());
  Vector2d pos=projection.project(LatLonGeo.fromDeg(19.14,-80.23));
  annotationPainter.addAnnotation(""String_Node_Str"",(float)pos.getX(),(float)pos.getY(),5,0,false,true,AnnotationFont.Helvetical_12,GlimpseColor.getGreen());
  dotPainter.addPointGeo(1,1,19.14,-80.23,0);
  pos=projection.project(LatLonGeo.fromDeg(18.88,-80.83));
  annotationPainter.addAnnotation(""String_Node_Str"",(float)pos.getX(),(float)pos.getY(),5,0,false,true,AnnotationFont.Helvetical_12,GlimpseColor.getGreen());
  dotPainter.addPointGeo(1,1,18.88,-80.83,0);
  pos=projection.project(LatLonGeo.fromDeg(19.64,-79.50));
  annotationPainter.addAnnotation(""String_Node_Str"",(float)pos.getX(),(float)pos.getY(),5,0,false,true,AnnotationFont.Helvetical_12,GlimpseColor.getRed());
  dotPainter.addPointGeo(1,1,19.64,-79.50,0);
  pos=projection.project(LatLonGeo.fromDeg(19.80,-79.08));
  annotationPainter.addAnnotation(""String_Node_Str"",(float)pos.getX(),(float)pos.getY(),5,0,false,true,AnnotationFont.Helvetical_12,GlimpseColor.getGreen());
  dotPainter.addPointGeo(1,1,19.80,-79.08,0);
  ScalePainter scale=new ScalePainter();
  scale.setPixelBufferX(8);
  scale.setPixelBufferY(8);
  plot.addPainter(scale);
  return plot;
}","public MapPlot2D getLayout(GeoProjection projection){
  MapPlot2D plot=new MapPlot2D(projection){
    @Override protected Axis1D createAxisZ(){
      return new TaggedAxis1D();
    }
    @Override protected AxisMouseListener createAxisMouseListenerZ(){
      return new TaggedAxisMouseListener1D();
    }
    @Override protected NumericAxisPainter createAxisPainterZ(    AxisLabelHandler tickHandler){
      return new TaggedPartialColorYAxisPainter(tickHandler);
    }
  }
;
  TaggedAxis1D axisZ=(TaggedAxis1D)plot.getAxisZ();
  axisZ.addTag(""String_Node_Str"",10000.0).setAttribute(TEX_COORD_ATTR,1.0f);
  axisZ.addTag(""String_Node_Str"",0.0).setAttribute(TEX_COORD_ATTR,0.5f);
  axisZ.addTag(""String_Node_Str"",-8000.0).setAttribute(TEX_COORD_ATTR,0.0f);
  List<String> constraints=new ArrayList<String>();
  for (  Tag tag : axisZ.getSortedTags())   constraints.add(tag.getName());
  axisZ.addConstraint(new OrderedConstraint(""String_Node_Str"",200,constraints));
  BathymetryData bathymetryData;
  try {
    bathymetryData=new BathymetryData(StreamOpener.fileThenResource.openForRead(""String_Node_Str""),projection);
  }
 catch (  IOException e) {
    e.printStackTrace();
    throw new RuntimeException(e);
  }
  FloatTextureProjected2D texture=bathymetryData.getTexture();
  ColorTexture1D elevationColors=new ColorTexture1D(1024);
  elevationColors.mutate(new ColorGradientConcatenator(ColorGradients.bathymetry,ColorGradients.topography));
  bathymetryPainter=new TaggedHeatMapPainter(axisZ);
  bathymetryPainter.setData(texture);
  bathymetryPainter.setColorScale(elevationColors);
  ((ColorYAxisPainter)plot.getAxisPainterZ()).setColorScale(elevationColors);
  double[] contourLevels=new double[]{-4000,-3000,-2000,-1000,-900,-800,-700,-600,-500,-400,-300,-200,-100,-50,-10};
  ContourData contourData=new ContourData(bathymetryData,projection,contourLevels);
  contourPainter=new ContourPainter(contourData);
  contourPainter.setLineColor(1.0f,1.0f,1.0f,0.5f);
  contourPainter.setLineWidth(1.6f);
  bathymetryData.setAxisBounds(plot.getAxis());
  plot.setAxisSizeZ(60);
  plot.setMinZ(-5000);
  plot.setMaxZ(2000);
  plot.setShowMinorTicksX(true);
  plot.setShowMinorTicksY(true);
  plot.setShowMinorTicksZ(true);
  plot.addPainter(bathymetryPainter);
  plot.addPainter(contourPainter);
  CursorTextZPainter cursorPainter=new CursorTextZPainter();
  plot.addPainter(cursorPainter);
  cursorPainter.setTexture(texture);
  annotationPainter=new AnnotationPainter();
  plot.addPainter(annotationPainter);
  LatLonTrackPainter dotPainter=new LatLonTrackPainter(projection);
  plot.addPainter(dotPainter);
  dotPainter.setShowLines(1,false);
  dotPainter.setPointSize(1,5.0f);
  dotPainter.setPointColor(1,GlimpseColor.getBlack());
  Vector2d pos=projection.project(LatLonGeo.fromDeg(19.14,-80.23));
  annotationPainter.addAnnotation(""String_Node_Str"",(float)pos.getX(),(float)pos.getY(),5,0,false,true,AnnotationFont.Helvetical_12,GlimpseColor.getGreen());
  dotPainter.addPointGeo(1,1,19.14,-80.23,0);
  pos=projection.project(LatLonGeo.fromDeg(18.88,-80.83));
  annotationPainter.addAnnotation(""String_Node_Str"",(float)pos.getX(),(float)pos.getY(),5,0,false,true,AnnotationFont.Helvetical_12,GlimpseColor.getGreen());
  dotPainter.addPointGeo(1,1,18.88,-80.83,0);
  pos=projection.project(LatLonGeo.fromDeg(19.64,-79.50));
  annotationPainter.addAnnotation(""String_Node_Str"",(float)pos.getX(),(float)pos.getY(),5,0,false,true,AnnotationFont.Helvetical_12,GlimpseColor.getRed());
  dotPainter.addPointGeo(1,1,19.64,-79.50,0);
  pos=projection.project(LatLonGeo.fromDeg(19.80,-79.08));
  annotationPainter.addAnnotation(""String_Node_Str"",(float)pos.getX(),(float)pos.getY(),5,0,false,true,AnnotationFont.Helvetical_12,GlimpseColor.getGreen());
  dotPainter.addPointGeo(1,1,19.80,-79.08,0);
  ScalePainter scale=new ScalePainter();
  scale.setPixelBufferX(8);
  scale.setPixelBufferY(8);
  plot.addPainter(scale);
  return plot;
}",0.9319384615384616
11491,"@Override public MultiAxisPlot2D getLayout(){
  MultiAxisPlot2D plot=new MultiAxisPlot2D();
  plot.getCenterAxis().lockAspectRatioXY(1.0);
  plot.getCenterAxis().getAxisX().setUpdateMode(CenterScale);
  plot.getCenterAxis().getAxisX().setUpdateMode(CenterScale);
  plot.setBorderSize(2);
  plot.setShowTitle(false);
  Axis2D xyAxis=plot.getCenterAxis();
  AxisUnitConverter unitConverter=new AxisUnitConverter(){
    public double fromAxisUnits(    double value){
      return Length.fromNauticalMiles(value);
    }
    public double toAxisUnits(    double value){
      return Length.toNauticalMiles(value);
    }
  }
;
  GridAxisLabelHandler xTicks=new GridAxisLabelHandler();
  GridAxisLabelHandler yTicks=new GridAxisLabelHandler();
  xTicks.setAxisUnitConverter(unitConverter);
  yTicks.setAxisUnitConverter(unitConverter);
  TaggedAxis1D colorAxis=new TaggedAxis1D();
  AxisMouseListener colorMouseListener=new TaggedAxisMouseListener1D();
  final AxisInfo colorAxisInfo=plot.createAxisRight(""String_Node_Str"",colorAxis,colorMouseListener);
  final GridAxisLabelHandler colorTickHandler=new GridAxisLabelHandler();
  final TaggedPartialColorYAxisPainter colorTagPainter=new TaggedPartialColorYAxisPainter(colorTickHandler);
  colorAxisInfo.setAxisPainter(colorTagPainter);
  ColorTexture1D colorMapTexture=new ColorTexture1D(1024);
  colorMapTexture.mutate(new ColorGradientConcatenator(ColorGradients.bathymetry,ColorGradients.topography));
  colorTagPainter.setColorScale(colorMapTexture);
  final Tag maxTag=colorAxis.addTag(""String_Node_Str"",10000.0).setAttribute(TEX_COORD_ATTR,1.0f);
  final Tag seaLevelTag=colorAxis.addTag(""String_Node_Str"",0.0).setAttribute(TEX_COORD_ATTR,0.5f);
  final Tag minTag=colorAxis.addTag(""String_Node_Str"",-8000.0).setAttribute(TEX_COORD_ATTR,0.0f);
  colorAxis.addConstraint(new NamedConstraint(""String_Node_Str""){
    protected double buffer=200;
    @Override public void applyConstraint(    TaggedAxis1D axis){
      if (seaLevelTag.getValue() > maxTag.getValue() - buffer)       seaLevelTag.setValue(maxTag.getValue() - buffer);
      if (minTag.getValue() > seaLevelTag.getValue() - buffer)       minTag.setValue(seaLevelTag.getValue() - buffer);
    }
  }
);
  colorAxis.setMin(-10000);
  colorAxis.setMax(12000);
  plot.addPainter(new BackgroundPainter().setColor(GlimpseColor.getBlack()));
  GridPainter grid=new GridPainter(xTicks,yTicks);
  grid.setLineColor(GlimpseColor.getGray(0.2f));
  grid.setMinorLineColor(GlimpseColor.getGray(0.1f));
  plot.addPainter(grid);
  final TaggedHeatMapPainter heatmap=new TaggedHeatMapPainter(colorAxis);
  heatmap.setColorScale(colorMapTexture);
  plot.addPainter(heatmap);
  final TangentPlane initPlane=new TangentPlane(LatLonGeo.fromDeg(20.14,-79.23));
  BathymetryData bathyData;
  try {
    bathyData=new BathymetryData(StreamOpener.fileThenResource.openForRead(""String_Node_Str""),initPlane);
  }
 catch (  IOException e) {
    e.printStackTrace();
    throw new RuntimeException(e);
  }
  bathyData.setAxisBounds(xyAxis);
  final FloatTextureProjected2D texture=bathyData.getTexture();
  final double startLat=bathyData.getStartLat();
  final double startLon=bathyData.getStartLon();
  final double endLat=startLat + bathyData.getHeightStep() * bathyData.getImageHeight();
  final double endLon=startLon + bathyData.getWidthStep() * bathyData.getImageWidth();
  final RunnableOn<TangentPlane> reprojectHeatmap=new RunnableOn<TangentPlane>(){
    public void run(    TangentPlane plane){
      Projection projection=new LatLonProjection(plane,startLat,endLat,startLon,endLon,false);
      texture.setProjection(projection);
      heatmap.setData(texture);
    }
  }
;
  reprojectHeatmap.run(initPlane);
  xyAxis.addAxisListener(new AxisListener2D(){
    TangentPlane currentPlane=initPlane;
    public void axisUpdated(    Axis2D axis){
      double xRef=axis.getAxisX().getSelectionCenter();
      double yRef=axis.getAxisY().getSelectionCenter();
      LatLonGeo ref=currentPlane.unproject(xRef,yRef);
      currentPlane=new TangentPlane(ref,xRef,yRef);
      reprojectHeatmap.run(currentPlane);
    }
  }
);
  CrosshairPainter crosshairs=new CrosshairPainter();
  crosshairs.showSelectionBox(false);
  crosshairs.setLineWidth(1.0f);
  crosshairs.setCursorColor(GlimpseColor.getGreen(0.3f));
  plot.addPainter(crosshairs);
  ScalePainter scale=new ScalePainter();
  scale.setUnitConverter(unitConverter);
  scale.setPixelBufferX(5);
  scale.setPixelBufferY(5);
  scale.setPrimaryColor(GlimpseColor.getGray(0.75f));
  scale.setSecondaryColor(GlimpseColor.getGray(0.5f));
  scale.setBorderColor(GlimpseColor.getWhite());
  scale.setTextColor(GlimpseColor.getWhite());
  plot.addPainter(scale);
  plot.addPainter(new BorderPainter());
  return plot;
}","@Override public MultiAxisPlot2D getLayout(){
  MultiAxisPlot2D plot=new MultiAxisPlot2D();
  plot.getCenterAxis().lockAspectRatioXY(1.0);
  plot.getCenterAxis().getAxisX().setUpdateMode(CenterScale);
  plot.getCenterAxis().getAxisX().setUpdateMode(CenterScale);
  plot.setBorderSize(2);
  plot.setShowTitle(false);
  Axis2D xyAxis=plot.getCenterAxis();
  AxisUnitConverter unitConverter=new AxisUnitConverter(){
    public double fromAxisUnits(    double value){
      return Length.fromNauticalMiles(value);
    }
    public double toAxisUnits(    double value){
      return Length.toNauticalMiles(value);
    }
  }
;
  GridAxisLabelHandler xTicks=new GridAxisLabelHandler();
  GridAxisLabelHandler yTicks=new GridAxisLabelHandler();
  xTicks.setAxisUnitConverter(unitConverter);
  yTicks.setAxisUnitConverter(unitConverter);
  TaggedAxis1D colorAxis=new TaggedAxis1D();
  AxisMouseListener colorMouseListener=new TaggedAxisMouseListener1D();
  final AxisInfo colorAxisInfo=plot.createAxisRight(""String_Node_Str"",colorAxis,colorMouseListener);
  final GridAxisLabelHandler colorTickHandler=new GridAxisLabelHandler();
  final TaggedPartialColorYAxisPainter colorTagPainter=new TaggedPartialColorYAxisPainter(colorTickHandler);
  colorAxisInfo.setAxisPainter(colorTagPainter);
  ColorTexture1D colorMapTexture=new ColorTexture1D(1024);
  colorMapTexture.mutate(new ColorGradientConcatenator(ColorGradients.bathymetry,ColorGradients.topography));
  colorTagPainter.setColorScale(colorMapTexture);
  colorAxis.addTag(""String_Node_Str"",10000.0).setAttribute(TEX_COORD_ATTR,1.0f);
  colorAxis.addTag(""String_Node_Str"",0.0).setAttribute(TEX_COORD_ATTR,0.5f);
  colorAxis.addTag(""String_Node_Str"",-8000.0).setAttribute(TEX_COORD_ATTR,0.0f);
  List<String> constraints=new ArrayList<String>();
  for (  Tag tag : colorAxis.getSortedTags())   constraints.add(tag.getName());
  colorAxis.addConstraint(new OrderedConstraint(""String_Node_Str"",200,constraints));
  colorAxis.setMin(-10000);
  colorAxis.setMax(12000);
  plot.addPainter(new BackgroundPainter().setColor(GlimpseColor.getBlack()));
  GridPainter grid=new GridPainter(xTicks,yTicks);
  grid.setLineColor(GlimpseColor.getGray(0.2f));
  grid.setMinorLineColor(GlimpseColor.getGray(0.1f));
  plot.addPainter(grid);
  final TaggedHeatMapPainter heatmap=new TaggedHeatMapPainter(colorAxis);
  heatmap.setColorScale(colorMapTexture);
  plot.addPainter(heatmap);
  final TangentPlane initPlane=new TangentPlane(LatLonGeo.fromDeg(20.14,-79.23));
  BathymetryData bathyData;
  try {
    bathyData=new BathymetryData(StreamOpener.fileThenResource.openForRead(""String_Node_Str""),initPlane);
  }
 catch (  IOException e) {
    e.printStackTrace();
    throw new RuntimeException(e);
  }
  bathyData.setAxisBounds(xyAxis);
  final FloatTextureProjected2D texture=bathyData.getTexture();
  final double startLat=bathyData.getStartLat();
  final double startLon=bathyData.getStartLon();
  final double endLat=startLat + bathyData.getHeightStep() * bathyData.getImageHeight();
  final double endLon=startLon + bathyData.getWidthStep() * bathyData.getImageWidth();
  final RunnableOn<TangentPlane> reprojectHeatmap=new RunnableOn<TangentPlane>(){
    public void run(    TangentPlane plane){
      Projection projection=new LatLonProjection(plane,startLat,endLat,startLon,endLon,false);
      texture.setProjection(projection);
      heatmap.setData(texture);
    }
  }
;
  reprojectHeatmap.run(initPlane);
  xyAxis.addAxisListener(new AxisListener2D(){
    TangentPlane currentPlane=initPlane;
    public void axisUpdated(    Axis2D axis){
      double xRef=axis.getAxisX().getSelectionCenter();
      double yRef=axis.getAxisY().getSelectionCenter();
      LatLonGeo ref=currentPlane.unproject(xRef,yRef);
      currentPlane=new TangentPlane(ref,xRef,yRef);
      reprojectHeatmap.run(currentPlane);
    }
  }
);
  CrosshairPainter crosshairs=new CrosshairPainter();
  crosshairs.showSelectionBox(false);
  crosshairs.setLineWidth(1.0f);
  crosshairs.setCursorColor(GlimpseColor.getGreen(0.3f));
  plot.addPainter(crosshairs);
  ScalePainter scale=new ScalePainter();
  scale.setUnitConverter(unitConverter);
  scale.setPixelBufferX(5);
  scale.setPixelBufferY(5);
  scale.setPrimaryColor(GlimpseColor.getGray(0.75f));
  scale.setSecondaryColor(GlimpseColor.getGray(0.5f));
  scale.setBorderColor(GlimpseColor.getWhite());
  scale.setTextColor(GlimpseColor.getWhite());
  plot.addPainter(scale);
  plot.addPainter(new BorderPainter());
  return plot;
}",0.9351521056620116
11492,"@Override public MultiAxisPlot2D getLayout(){
  MultiAxisPlot2D plot=new MultiAxisPlot2D();
  plot.getCenterAxis().lockAspectRatioXY(1.0);
  plot.getCenterAxis().getAxisX().setUpdateMode(CenterScale);
  plot.getCenterAxis().getAxisX().setUpdateMode(CenterScale);
  plot.setBorderSize(2);
  plot.setShowTitle(false);
  Axis2D xyAxis=plot.getCenterAxis();
  AxisUnitConverter unitConverter=new AxisUnitConverter(){
    public double fromAxisUnits(    double value){
      return Length.fromNauticalMiles(value);
    }
    public double toAxisUnits(    double value){
      return Length.toNauticalMiles(value);
    }
  }
;
  GridAxisLabelHandler xTicks=new GridAxisLabelHandler();
  GridAxisLabelHandler yTicks=new GridAxisLabelHandler();
  xTicks.setAxisUnitConverter(unitConverter);
  yTicks.setAxisUnitConverter(unitConverter);
  TaggedAxis1D colorAxis=new TaggedAxis1D();
  AxisMouseListener colorMouseListener=new TaggedAxisMouseListener1D();
  final AxisInfo colorAxisInfo=plot.createAxisRight(""String_Node_Str"",colorAxis,colorMouseListener);
  final GridAxisLabelHandler colorTickHandler=new GridAxisLabelHandler();
  final TaggedPartialColorYAxisPainter colorTagPainter=new TaggedPartialColorYAxisPainter(colorTickHandler);
  colorAxisInfo.setAxisPainter(colorTagPainter);
  ColorTexture1D colorMapTexture=new ColorTexture1D(1024);
  colorMapTexture.mutate(new ColorGradientConcatenator(ColorGradients.bathymetry,ColorGradients.topography));
  colorTagPainter.setColorScale(colorMapTexture);
  final Tag maxTag=colorAxis.addTag(""String_Node_Str"",10000.0).setAttribute(TEX_COORD_ATTR,1.0f);
  final Tag seaLevelTag=colorAxis.addTag(""String_Node_Str"",0.0).setAttribute(TEX_COORD_ATTR,0.5f);
  final Tag minTag=colorAxis.addTag(""String_Node_Str"",-8000.0).setAttribute(TEX_COORD_ATTR,0.0f);
  colorAxis.addConstraint(new NamedConstraint(""String_Node_Str""){
    protected double buffer=200;
    @Override public void applyConstraint(    TaggedAxis1D axis){
      if (seaLevelTag.getValue() > maxTag.getValue() - buffer)       seaLevelTag.setValue(maxTag.getValue() - buffer);
      if (minTag.getValue() > seaLevelTag.getValue() - buffer)       minTag.setValue(seaLevelTag.getValue() - buffer);
    }
  }
);
  colorAxis.setMin(-10000);
  colorAxis.setMax(12000);
  plot.addPainter(new BackgroundPainter().setColor(GlimpseColor.getBlack()));
  GridPainter grid=new GridPainter(xTicks,yTicks);
  grid.setLineColor(GlimpseColor.getGray(0.2f));
  grid.setMinorLineColor(GlimpseColor.getGray(0.1f));
  plot.addPainter(grid);
  final TaggedHeatMapPainter heatmap=new TaggedHeatMapPainter(colorAxis);
  heatmap.setColorScale(colorMapTexture);
  plot.addPainter(heatmap);
  final TangentPlane initPlane=new TangentPlane(LatLonGeo.fromDeg(0,0));
  BathymetryData bathyData;
  try {
    bathyData=new BathymetryData(openBathyFile(),initPlane);
  }
 catch (  IOException e) {
    e.printStackTrace();
    throw new RuntimeException(e);
  }
  bathyData.setAxisBounds(xyAxis);
  final FloatTextureProjected2D texture=new FloatTextureProjected2D(bathyData.getImageWidth(),bathyData.getImageHeight(),true);
  texture.setData(bathyData.getData());
  final double startLat=bathyData.getStartLat();
  final double startLon=bathyData.getStartLon();
  final double endLat=startLat + bathyData.getHeightStep() * bathyData.getImageHeight();
  final double endLon=startLon + bathyData.getWidthStep() * bathyData.getImageWidth();
  final RunnableOn<TangentPlane> reprojectHeatmap=new RunnableOn<TangentPlane>(){
    double earthCircumference=2 * PI * LatLonGeo.defaultDatum.getRadius();
    double oneOverDistanceThreshold=1.0 / (0.4 * earthCircumference);
    public void run(    TangentPlane plane){
      LatLonProjection newProjection=new LatLonProjection(plane,startLat,endLat,startLon,endLon,false){
        public void getVertexXYZ(        double textureFractionX,        double textureFractionY,        float[] resultXYZ){
          Vector2d xy=project(textureFractionX,textureFractionY);
          resultXYZ[0]=(float)xy.getX();
          resultXYZ[1]=(float)xy.getY();
          Vector2d xyTangent=((TangentPlane)projection).getTangentPointOnPlane();
          resultXYZ[2]=(float)(xy.minus(xyTangent).norm() * oneOverDistanceThreshold);
        }
      }
;
      texture.setProjection(newProjection);
      heatmap.setData(texture);
    }
  }
;
  reprojectHeatmap.run(initPlane);
  xyAxis.addAxisListener(new AxisListener2D(){
    TangentPlane currentPlane=initPlane;
    public void axisUpdated(    Axis2D axis){
      double xRef=axis.getAxisX().getSelectionCenter();
      double yRef=axis.getAxisY().getSelectionCenter();
      LatLonGeo ref=currentPlane.unproject(xRef,yRef);
      currentPlane=new TangentPlane(ref,xRef,yRef);
      reprojectHeatmap.run(currentPlane);
    }
  }
);
  CrosshairPainter crosshairs=new CrosshairPainter();
  crosshairs.showSelectionBox(false);
  crosshairs.setLineWidth(1.0f);
  crosshairs.setCursorColor(GlimpseColor.getGreen(0.3f));
  plot.addPainter(crosshairs);
  ScalePainter scale=new ScalePainter();
  scale.setUnitConverter(unitConverter);
  scale.setPixelBufferX(5);
  scale.setPixelBufferY(5);
  scale.setPrimaryColor(GlimpseColor.getGray(0.75f));
  scale.setSecondaryColor(GlimpseColor.getGray(0.5f));
  scale.setBorderColor(GlimpseColor.getWhite());
  scale.setTextColor(GlimpseColor.getWhite());
  plot.addPainter(scale);
  plot.addPainter(new BorderPainter());
  return plot;
}","@Override public MultiAxisPlot2D getLayout(){
  MultiAxisPlot2D plot=new MultiAxisPlot2D();
  plot.getCenterAxis().lockAspectRatioXY(1.0);
  plot.getCenterAxis().getAxisX().setUpdateMode(CenterScale);
  plot.getCenterAxis().getAxisX().setUpdateMode(CenterScale);
  plot.setBorderSize(2);
  plot.setShowTitle(false);
  Axis2D xyAxis=plot.getCenterAxis();
  AxisUnitConverter unitConverter=new AxisUnitConverter(){
    public double fromAxisUnits(    double value){
      return Length.fromNauticalMiles(value);
    }
    public double toAxisUnits(    double value){
      return Length.toNauticalMiles(value);
    }
  }
;
  GridAxisLabelHandler xTicks=new GridAxisLabelHandler();
  GridAxisLabelHandler yTicks=new GridAxisLabelHandler();
  xTicks.setAxisUnitConverter(unitConverter);
  yTicks.setAxisUnitConverter(unitConverter);
  TaggedAxis1D colorAxis=new TaggedAxis1D();
  AxisMouseListener colorMouseListener=new TaggedAxisMouseListener1D();
  final AxisInfo colorAxisInfo=plot.createAxisRight(""String_Node_Str"",colorAxis,colorMouseListener);
  final GridAxisLabelHandler colorTickHandler=new GridAxisLabelHandler();
  final TaggedPartialColorYAxisPainter colorTagPainter=new TaggedPartialColorYAxisPainter(colorTickHandler);
  colorAxisInfo.setAxisPainter(colorTagPainter);
  ColorTexture1D colorMapTexture=new ColorTexture1D(1024);
  colorMapTexture.mutate(new ColorGradientConcatenator(ColorGradients.bathymetry,ColorGradients.topography));
  colorTagPainter.setColorScale(colorMapTexture);
  colorAxis.addTag(""String_Node_Str"",10000.0).setAttribute(TEX_COORD_ATTR,1.0f);
  colorAxis.addTag(""String_Node_Str"",0.0).setAttribute(TEX_COORD_ATTR,0.5f);
  colorAxis.addTag(""String_Node_Str"",-8000.0).setAttribute(TEX_COORD_ATTR,0.0f);
  List<String> constraints=new ArrayList<String>();
  for (  Tag tag : colorAxis.getSortedTags())   constraints.add(tag.getName());
  colorAxis.addConstraint(new OrderedConstraint(""String_Node_Str"",200,constraints));
  colorAxis.setMin(-10000);
  colorAxis.setMax(12000);
  plot.addPainter(new BackgroundPainter().setColor(GlimpseColor.getBlack()));
  GridPainter grid=new GridPainter(xTicks,yTicks);
  grid.setLineColor(GlimpseColor.getGray(0.2f));
  grid.setMinorLineColor(GlimpseColor.getGray(0.1f));
  plot.addPainter(grid);
  final TaggedHeatMapPainter heatmap=new TaggedHeatMapPainter(colorAxis);
  heatmap.setColorScale(colorMapTexture);
  plot.addPainter(heatmap);
  final TangentPlane initPlane=new TangentPlane(LatLonGeo.fromDeg(0,0));
  BathymetryData bathyData;
  try {
    bathyData=new BathymetryData(openBathyFile(),initPlane);
  }
 catch (  IOException e) {
    e.printStackTrace();
    throw new RuntimeException(e);
  }
  bathyData.setAxisBounds(xyAxis);
  final FloatTextureProjected2D texture=new FloatTextureProjected2D(bathyData.getImageWidth(),bathyData.getImageHeight(),true);
  texture.setData(bathyData.getData());
  final double startLat=bathyData.getStartLat();
  final double startLon=bathyData.getStartLon();
  final double endLat=startLat + bathyData.getHeightStep() * bathyData.getImageHeight();
  final double endLon=startLon + bathyData.getWidthStep() * bathyData.getImageWidth();
  final RunnableOn<TangentPlane> reprojectHeatmap=new RunnableOn<TangentPlane>(){
    double earthCircumference=2 * PI * LatLonGeo.defaultDatum.getRadius();
    double oneOverDistanceThreshold=1.0 / (0.4 * earthCircumference);
    public void run(    TangentPlane plane){
      LatLonProjection newProjection=new LatLonProjection(plane,startLat,endLat,startLon,endLon,false){
        public void getVertexXYZ(        double textureFractionX,        double textureFractionY,        float[] resultXYZ){
          Vector2d xy=project(textureFractionX,textureFractionY);
          resultXYZ[0]=(float)xy.getX();
          resultXYZ[1]=(float)xy.getY();
          Vector2d xyTangent=((TangentPlane)projection).getTangentPointOnPlane();
          resultXYZ[2]=(float)(xy.minus(xyTangent).norm() * oneOverDistanceThreshold);
        }
      }
;
      texture.setProjection(newProjection);
      heatmap.setData(texture);
    }
  }
;
  reprojectHeatmap.run(initPlane);
  xyAxis.addAxisListener(new AxisListener2D(){
    TangentPlane currentPlane=initPlane;
    public void axisUpdated(    Axis2D axis){
      double xRef=axis.getAxisX().getSelectionCenter();
      double yRef=axis.getAxisY().getSelectionCenter();
      LatLonGeo ref=currentPlane.unproject(xRef,yRef);
      currentPlane=new TangentPlane(ref,xRef,yRef);
      reprojectHeatmap.run(currentPlane);
    }
  }
);
  CrosshairPainter crosshairs=new CrosshairPainter();
  crosshairs.showSelectionBox(false);
  crosshairs.setLineWidth(1.0f);
  crosshairs.setCursorColor(GlimpseColor.getGreen(0.3f));
  plot.addPainter(crosshairs);
  ScalePainter scale=new ScalePainter();
  scale.setUnitConverter(unitConverter);
  scale.setPixelBufferX(5);
  scale.setPixelBufferY(5);
  scale.setPrimaryColor(GlimpseColor.getGray(0.75f));
  scale.setSecondaryColor(GlimpseColor.getGray(0.5f));
  scale.setBorderColor(GlimpseColor.getWhite());
  scale.setTextColor(GlimpseColor.getWhite());
  plot.addPainter(scale);
  plot.addPainter(new BorderPainter());
  return plot;
}",0.943356973995272
11493,"protected boolean getContainingTargets(I e,GlimpseContext context,List<GlimpseTargetStack> accumulator){
  GlimpseTargetStack stack=context.getTargetStack();
  GlimpseTarget layout=stack.getTarget();
  GlimpseBounds bounds=stack.getBounds();
  List<GlimpseTarget> list=layout.getTargetChildren();
  int size=list.size();
  for (int i=size - 1; i >= 0; i--) {
    GlimpseTarget childLayout=list.get(i);
    GlimpseBounds childBounds=childLayout.getTargetBounds(context.getTargetStack());
    stack.push(childLayout,childBounds);
    boolean consumeEvent=getContainingTargets(e,context,accumulator);
    if (consumeEvent)     return true;
    stack.pop();
  }
  if (!layout.isEventConsumer() && !layout.isEventGenerator())   return false;
  if (handleInterior(e,context,bounds)) {
    if (layout.isEventGenerator()) {
      accumulator.add(newTargetStack(stack));
    }
    return layout.isEventConsumer();
  }
 else {
    return false;
  }
}","protected boolean getContainingTargets(I e,GlimpseContext context,List<GlimpseTargetStack> accumulator){
  GlimpseTargetStack stack=context.getTargetStack();
  GlimpseTarget layout=stack.getTarget();
  GlimpseBounds bounds=stack.getBounds();
  List<GlimpseTarget> list=layout.getTargetChildren();
  int size=list.size();
  for (int i=size - 1; i >= 0; i--) {
    GlimpseTarget childLayout=list.get(i);
    if (childLayout.isVisible()) {
      GlimpseBounds childBounds=childLayout.getTargetBounds(context.getTargetStack());
      stack.push(childLayout,childBounds);
      boolean consumeEvent=getContainingTargets(e,context,accumulator);
      if (consumeEvent)       return true;
      stack.pop();
    }
  }
  if (!layout.isEventConsumer() && !layout.isEventGenerator())   return false;
  if (handleInterior(e,context,bounds)) {
    if (layout.isEventGenerator()) {
      accumulator.add(newTargetStack(stack));
    }
    return layout.isEventConsumer();
  }
 else {
    return false;
  }
}",0.9425763062597
11494,"public void paintTo(GlimpseContext context){
  GL gl=context.getGL();
  GlimpseBounds bounds=context.getTargetStack().getBounds();
  GlimpseBounds clippedBounds=getClippedBounds(context);
  if (!clippedBounds.isValid())   return;
  for (  Member m : memberList) {
    try {
      if (!(m.painter instanceof GlimpseLayout) && !layout.isVisible)       continue;
      gl.glEnable(GL2.GL_SCISSOR_TEST);
      gl.glViewport(bounds.getX(),bounds.getY(),bounds.getWidth(),bounds.getHeight());
      gl.glScissor(clippedBounds.getX(),clippedBounds.getY(),clippedBounds.getWidth(),clippedBounds.getHeight());
      if (m.callback != null)       m.callback.prePaint(m.painter,context);
      m.painter.paintTo(context);
      if (m.callback != null)       m.callback.postPaint(m.painter,context);
    }
  finally {
      gl.glDisable(GL2.GL_SCISSOR_TEST);
    }
  }
}","public void paintTo(GlimpseContext context){
  GL gl=context.getGL();
  GlimpseBounds bounds=context.getTargetStack().getBounds();
  GlimpseBounds clippedBounds=getClippedBounds(context);
  if (!clippedBounds.isValid())   return;
  for (  Member m : memberList) {
    try {
      boolean isLayout=m.painter instanceof GlimpseLayout;
      boolean isVisible=layout.isVisible;
      if (isVisible) {
        gl.glEnable(GL2.GL_SCISSOR_TEST);
        gl.glViewport(bounds.getX(),bounds.getY(),bounds.getWidth(),bounds.getHeight());
        gl.glScissor(clippedBounds.getX(),clippedBounds.getY(),clippedBounds.getWidth(),clippedBounds.getHeight());
        if (m.callback != null)         m.callback.prePaint(m.painter,context);
        m.painter.paintTo(context);
        if (m.callback != null)         m.callback.postPaint(m.painter,context);
      }
 else       if (isLayout) {
        ((GlimpseLayout)m.painter).layoutTo(context);
      }
    }
  finally {
      gl.glDisable(GL2.GL_SCISSOR_TEST);
    }
  }
}",0.8490364025695931
11495,"@Override public void mouseMoved(GlimpseMouseEvent e){
  TimeStamp time=getTime(e);
  Set<EventSelection> newHoveredEvents=Collections.unmodifiableSet(Sets.newHashSet(eventManager.getNearestEvents(e)));
  SetView<EventSelection> eventsExited=Sets.difference(hoveredEvents,newHoveredEvents);
  for (  EventPlotListener listener : eventListeners) {
    listener.eventsExited(e,eventsExited,time);
  }
  SetView<EventSelection> eventsEntered=Sets.difference(newHoveredEvents,hoveredEvents);
  for (  EventPlotListener listener : eventListeners) {
    listener.eventsEntered(e,eventsEntered,time);
  }
  for (  EventPlotListener listener : eventListeners) {
    listener.eventsHovered(e,newHoveredEvents,time);
  }
  hoveredEvents=Sets.newHashSet(newHoveredEvents);
}","@Override public void mouseMoved(GlimpseMouseEvent e){
  TimeStamp time=getTime(e);
  Set<EventSelection> newHoveredEvents=Collections.unmodifiableSet(Sets.newHashSet(eventManager.getNearestEvents(e)));
  SetView<EventSelection> eventsExited=Sets.difference(hoveredEvents,newHoveredEvents);
  for (  EventPlotListener listener : eventListeners) {
    listener.eventsExited(e,eventsExited,time);
  }
  SetView<EventSelection> eventsEntered=Sets.difference(newHoveredEvents,hoveredEvents);
  for (  EventPlotListener listener : eventListeners) {
    listener.eventsEntered(e,eventsEntered,time);
  }
  for (  EventPlotListener listener : eventListeners) {
    listener.eventsHovered(e,newHoveredEvents,time);
  }
  hoveredEvents=newHoveredEvents;
}",0.972829688535454
11496,"public double getWrappedMod(double value){
  double span=getWrapSpan();
  double v=value - minWrapVal;
  double mod=v % span;
  return mod + (mod > 0 ? 0 : span);
}","public double getWrappedMod(double value){
  double span=getWrapSpan();
  double v=value - minWrapVal;
  double mod=v % span;
  return mod + (mod >= 0 ? 0 : span);
}",0.9969604863221884
11497,"@Override protected double f(double x){
  Math.asin(x);
  return 0;
}","@Override protected double f(double x){
  return Math.asin(x);
}",0.8571428571428571
11498,"protected void shiftMaps(int lastDelete,int nextDelete,int deleteCount){
  for (int i=lastDelete + 1; i < nextDelete; i++) {
    Object id=this.indexMap.remove(i);
    this.indexMap.put(i - deleteCount,id);
    this.idMap.put(id,i - deleteCount);
  }
}","protected static void shiftMaps(Map<Object,Integer> idMap,Map<Integer,Object> indexMap,int lastDelete,int nextDelete,int deleteCount){
  for (int i=lastDelete + 1; i < nextDelete; i++) {
    Object id=indexMap.remove(i);
    indexMap.put(i - deleteCount,id);
    idMap.put(id,i - deleteCount);
  }
}",0.2431941923774954
11499,"protected void shift(FloatBuffer data,int dataSize,int endIndex,int startIndex,int length){
  int shiftCount=dataSize - startIndex;
  int shiftSize=endIndex - startIndex;
  if (tempBuffer == null || tempBuffer.capacity() < shiftCount * length) {
    tempBuffer=FloatBuffer.allocate(shiftCount * length);
  }
  tempBuffer.position(0);
  tempBuffer.limit(shiftCount * length);
  data.position(startIndex * length);
  data.limit(dataSize * length);
  tempBuffer.put(data);
  tempBuffer.rewind();
  data.position(endIndex * length);
  data.limit((dataSize - shiftSize) * length);
  data.put(tempBuffer);
}","/** 
 * @param data buffer to shift
 * @param shiftCount number of logical indices to shift (each index represents 'length' buffer entries)
 * @param toIndex the logical index to start copying data to
 * @param fromIndex the logical index to start copying data from
 * @param length the number of buffer entries per logical index
 */
protected static void shift(FloatBuffer data,FloatBuffer tempBuffer,int shiftCount,int toIndex,int fromIndex,int length){
  if (shiftCount == 0 || toIndex == fromIndex)   return;
  if (tempBuffer == null || tempBuffer.capacity() < shiftCount * length) {
    tempBuffer=FloatBuffer.allocate(shiftCount * length);
  }
  tempBuffer.limit(shiftCount * length);
  tempBuffer.position(0);
  data.limit((fromIndex + shiftCount) * length);
  data.position(fromIndex * length);
  tempBuffer.put(data);
  tempBuffer.rewind();
  data.limit((toIndex + shiftCount) * length);
  data.position(toIndex * length);
  data.put(tempBuffer);
}",0.4428754813863928
11500,"protected boolean isIconOverlapping(int size,int buffer,double remainingSpaceX,int pixelX,int nextStartPixel){
  return (size + buffer > remainingSpaceX && overlapRenderingMode == Overfull) || (pixelX + size + buffer > nextStartPixel && overlapRenderingMode == Intersecting);
}","protected boolean isIconOverlapping(int size,int buffer,double remainingSpaceX,int pixelX,int nextStartPixel){
  return (size + buffer > remainingSpaceX && getOverlapRenderingMode() == Overfull) || (pixelX + size + buffer > nextStartPixel && getOverlapRenderingMode() == Intersecting);
}",0.975177304964539
11501,"protected boolean isTextIntersecting(int size,int buffer,double remainingSpaceX,int pixelX,int nextStartPixel,Rectangle2D bounds){
  return pixelX + bounds.getWidth() + buffer > nextStartPixel && overlapRenderingMode == Intersecting;
}","protected boolean isTextIntersecting(int size,int buffer,double remainingSpaceX,int pixelX,int nextStartPixel,Rectangle2D bounds){
  return pixelX + bounds.getWidth() + buffer > nextStartPixel && getOverlapRenderingMode() == Intersecting;
}",0.9852631578947368
11502,"protected double getTextAvailableSpace(int size,int buffer,double remainingSpaceX,int pixelX,int nextStartPixel){
  double insideBoxSpace=remainingSpaceX - buffer;
  double outsideBoxSpace=nextStartPixel - pixelX - buffer;
switch (overlapRenderingMode) {
case Overfull:
    return insideBoxSpace;
case Intersecting:
  return outsideBoxSpace;
case None:
default :
return Double.MAX_VALUE;
}
}","protected double getTextAvailableSpace(int size,int buffer,double remainingSpaceX,int pixelX,int nextStartPixel){
  double insideBoxSpace=remainingSpaceX - buffer;
  double outsideBoxSpace=nextStartPixel - pixelX - buffer;
switch (getOverlapRenderingMode()) {
case Overfull:
    return insideBoxSpace;
case Intersecting:
  return outsideBoxSpace;
case None:
default :
return Double.MAX_VALUE;
}
}",0.9911054637865312
11503,"protected boolean isTextOverfull(int size,int buffer,double remainingSpaceX,int pixelX,int nextStartPixel,Rectangle2D bounds){
  return bounds.getWidth() + buffer > remainingSpaceX && overlapRenderingMode == Overfull;
}","protected boolean isTextOverfull(int size,int buffer,double remainingSpaceX,int pixelX,int nextStartPixel,Rectangle2D bounds){
  return bounds.getWidth() + buffer > remainingSpaceX && getOverlapRenderingMode() == Overfull;
}",0.984198645598194
11504,"@Override public void paintTo(GL2 gl,GlimpseBounds bounds,Axis2D axis){
  if (dataSize == 0)   return;
  if (!bufferInitialized) {
    bufferHandle=new int[1];
    gl.glGenBuffers(1,bufferHandle,0);
    bufferInitialized=true;
  }
  gl.glBindBuffer(GL2.GL_ARRAY_BUFFER,bufferHandle[0]);
  if (newData) {
    dataBufferLock.lock();
    try {
      gl.glBufferData(GL2.GL_ARRAY_BUFFER,dataSize * FLOATS_PER_BAR * BYTES_PER_FLOAT,dataBuffer.rewind(),GL2.GL_DYNAMIC_DRAW);
      glHandleError(gl);
      newData=false;
    }
  finally {
      dataBufferLock.unlock();
    }
  }
  gl.glBindBuffer(GL2.GL_ARRAY_BUFFER,bufferHandle[0]);
  gl.glVertexPointer(2,GL2.GL_FLOAT,0,0);
  gl.glEnableClientState(GL2.GL_VERTEX_ARRAY);
  gl.glColor4fv(barColor,0);
  gl.glDrawArrays(GL2.GL_QUADS,0,dataSize * 4);
}","@Override public void paintTo(GL2 gl,GlimpseBounds bounds,Axis2D axis){
  if (dataSize == 0)   return;
  if (!bufferInitialized) {
    bufferHandle=new int[1];
    gl.glGenBuffers(1,bufferHandle,0);
    bufferInitialized=true;
  }
  gl.glBindBuffer(GL2.GL_ARRAY_BUFFER,bufferHandle[0]);
  int dataSizeTemp=dataSize;
  if (newData) {
    dataBufferLock.lock();
    try {
      dataSizeTemp=dataSize;
      gl.glBufferData(GL2.GL_ARRAY_BUFFER,dataSizeTemp * FLOATS_PER_BAR * BYTES_PER_FLOAT,dataBuffer.rewind(),GL2.GL_DYNAMIC_DRAW);
      glHandleError(gl);
      newData=false;
    }
  finally {
      dataBufferLock.unlock();
    }
  }
  gl.glBindBuffer(GL2.GL_ARRAY_BUFFER,bufferHandle[0]);
  gl.glVertexPointer(2,GL2.GL_FLOAT,0,0);
  gl.glEnableClientState(GL2.GL_VERTEX_ARRAY);
  gl.glColor4fv(barColor,0);
  gl.glDrawArrays(GL2.GL_QUADS,0,dataSizeTemp * 4);
}",0.9602409638554216
11505,"public void autoAdjustAxisBounds(Axis2D axis){
  axis.getAxisX().setMin(minX);
  axis.getAxisX().setMax(maxX);
  axis.getAxisY().setMin(minY);
  axis.getAxisY().setMax(maxY);
}","public void autoAdjustAxisBounds(Axis2D axis){
  axis.getAxisX().setMin(minX);
  axis.getAxisX().setMax(maxX + getBinSize());
  axis.getAxisY().setMin(minY);
  axis.getAxisY().setMax(maxY);
}",0.9591280653950952
11506,"/** 
 * @deprecated Use {@link #NewtSwtGlimpseCanvas(Composite,GLContext,int)} instead. The context implicitly provides a GLProfile.
 */
public NewtSwtGlimpseCanvas(Composite parent,String profile,GLContext context,int options){
  this(parent,GLProfile.get(profile),context,options);
}","/** 
 * @deprecated Use {@link #NewtSwtGlimpseCanvas(Composite,GLContext,int)} instead. The context implicitly provides a GLProfile.
 */
@Deprecated public NewtSwtGlimpseCanvas(Composite parent,String profile,GLContext context,int options){
  this(parent,GLProfile.get(profile),context,options);
}",0.979381443298969
11507,"@Override public void windowClosing(WindowEvent e){
  glDrawable.destroy();
  leftPanel.dispose();
  rightPanel.dispose();
}","@Override public void windowClosing(WindowEvent e){
  leftPanel.destroy();
  rightPanel.destroy();
  leftPanel.disposeAttached();
  rightPanel.disposeAttached();
}",0.8083623693379791
11508,"public static void showWithSwing(GlimpseLayoutProvider layoutProviderA,GlimpseLayoutProvider layoutProviderB) throws Exception {
  GLProfile glProfile=GLUtils.getDefaultGLProfile();
  GLDrawableFactory factory=GLDrawableFactory.getFactory(glProfile);
  GLCapabilities glCapabilities=new GLCapabilities(glProfile);
  final GLOffscreenAutoDrawable glDrawable=factory.createOffscreenAutoDrawable(null,glCapabilities,null,1,1);
  glDrawable.display();
  GLContext context=glDrawable.getContext();
  final NewtSwingGlimpseCanvas leftPanel=new NewtSwingGlimpseCanvas(context);
  leftPanel.addLayout(layoutProviderA.getLayout());
  final NewtSwingGlimpseCanvas rightPanel=new NewtSwingGlimpseCanvas(context);
  rightPanel.addLayout(layoutProviderB.getLayout());
  FPSAnimator animator=new FPSAnimator(120);
  animator.add(leftPanel.getGLDrawable());
  animator.add(rightPanel.getGLDrawable());
  animator.start();
  WindowAdapter disposeListener=new WindowAdapter(){
    @Override public void windowClosing(    WindowEvent e){
      glDrawable.destroy();
      leftPanel.dispose();
      rightPanel.dispose();
    }
  }
;
  final JFrame rightFrame=new JFrame(""String_Node_Str"");
  rightFrame.addWindowListener(disposeListener);
  final JFrame leftFrame=new JFrame(""String_Node_Str"");
  leftFrame.addWindowListener(disposeListener);
  rightFrame.setSize(800,800);
  rightFrame.setLocation(800,0);
  rightFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
  rightFrame.setVisible(true);
  leftFrame.setSize(800,800);
  leftFrame.setLocation(0,0);
  leftFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
  leftFrame.setVisible(true);
  SwingUtilities.invokeAndWait(new Runnable(){
    @Override public void run(){
      rightFrame.add(rightPanel);
      leftFrame.add(leftPanel);
      rightFrame.validate();
      leftFrame.validate();
    }
  }
);
  return;
}","public static void showWithSwing(GlimpseLayoutProvider layoutProviderA,GlimpseLayoutProvider layoutProviderB) throws Exception {
  GLProfile glProfile=GLUtils.getDefaultGLProfile();
  GLDrawableFactory factory=GLDrawableFactory.getFactory(glProfile);
  GLCapabilities glCapabilities=new GLCapabilities(glProfile);
  final GLOffscreenAutoDrawable glDrawable=factory.createOffscreenAutoDrawable(null,glCapabilities,null,1,1);
  glDrawable.display();
  GLContext context=glDrawable.getContext();
  final NewtSwingGlimpseCanvas leftPanel=new NewtSwingGlimpseCanvas(context);
  leftPanel.addLayout(layoutProviderA.getLayout());
  final NewtSwingGlimpseCanvas rightPanel=new NewtSwingGlimpseCanvas(context);
  rightPanel.addLayout(layoutProviderB.getLayout());
  FPSAnimator animator=new FPSAnimator(120);
  animator.add(leftPanel.getGLDrawable());
  animator.add(rightPanel.getGLDrawable());
  animator.start();
  WindowAdapter disposeListener=new WindowAdapter(){
    @Override public void windowClosing(    WindowEvent e){
      leftPanel.destroy();
      rightPanel.destroy();
      leftPanel.disposeAttached();
      rightPanel.disposeAttached();
    }
  }
;
  final JFrame rightFrame=new JFrame(""String_Node_Str"");
  rightFrame.addWindowListener(disposeListener);
  final JFrame leftFrame=new JFrame(""String_Node_Str"");
  leftFrame.addWindowListener(disposeListener);
  rightFrame.setSize(800,800);
  rightFrame.setLocation(800,0);
  rightFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
  rightFrame.setVisible(true);
  leftFrame.setSize(800,800);
  leftFrame.setLocation(0,0);
  leftFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
  leftFrame.setVisible(true);
  SwingUtilities.invokeAndWait(new Runnable(){
    @Override public void run(){
      rightFrame.add(rightPanel);
      leftFrame.add(leftPanel);
      rightFrame.validate();
      leftFrame.validate();
    }
  }
);
  return;
}",0.965682362330407
11509,"public static void main(String[] args) throws Exception {
  ScatterplotExample provider=new ScatterplotExample();
  Example example=Example.showWithSwing(provider);
  provider.addDisposeListener(example.getCanvas());
}","public static void main(String[] args) throws Exception {
  ScatterplotExample provider=new ScatterplotExample();
  Example.showWithSwing(provider);
}",0.8152173913043478
11510,"@Override public void windowClosing(WindowEvent e){
  canvas.dispose();
}","@Override public void windowClosing(WindowEvent e){
  canvas.disposeAttached();
}",0.948051948051948
11511,"public static void main(String[] args) throws Exception {
  final NewtSwingGlimpseCanvas canvas=new NewtSwingGlimpseCanvas();
  GlimpseLayout plot=buildPlot(canvas);
  canvas.addLayout(plot);
  canvas.setLookAndFeel(new SwingLookAndFeel());
  new FPSAnimator(canvas.getGLDrawable(),120).start();
  final JFrame frame=new JFrame(""String_Node_Str"");
  frame.addWindowListener(new WindowAdapter(){
    @Override public void windowClosing(    WindowEvent e){
      canvas.dispose();
    }
  }
);
  frame.add(canvas);
  frame.pack();
  frame.setSize(800,800);
  frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
  frame.setVisible(true);
  return;
}","public static void main(String[] args) throws Exception {
  final NewtSwingGlimpseCanvas canvas=new NewtSwingGlimpseCanvas();
  GlimpseLayout plot=buildPlot(canvas);
  canvas.addLayout(plot);
  canvas.setLookAndFeel(new SwingLookAndFeel());
  new FPSAnimator(canvas.getGLDrawable(),120).start();
  final JFrame frame=new JFrame(""String_Node_Str"");
  frame.addWindowListener(new WindowAdapter(){
    @Override public void windowClosing(    WindowEvent e){
      canvas.disposeAttached();
    }
  }
);
  frame.add(canvas);
  frame.pack();
  frame.setSize(800,800);
  frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
  frame.setVisible(true);
  return;
}",0.9938650306748468
11512,"public static JFrame createFrame(String name,final NewtSwingGlimpseCanvas canvas){
  final JFrame frame=new JFrame(name);
  frame.addWindowListener(new WindowAdapter(){
    @Override public void windowClosing(    WindowEvent e){
      canvas.dispose();
      frame.remove(canvas);
    }
  }
);
  frame.add(canvas);
  frame.pack();
  frame.setSize(800,800);
  frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
  frame.setVisible(true);
  return frame;
}","public static JFrame createFrame(String name,final NewtSwingGlimpseCanvas canvas){
  final JFrame frame=new JFrame(name);
  frame.addWindowListener(new WindowAdapter(){
    @Override public void windowClosing(    WindowEvent e){
      canvas.disposeAttached();
      frame.remove(canvas);
    }
  }
);
  frame.add(canvas);
  frame.pack();
  frame.setSize(800,800);
  frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
  frame.setVisible(true);
  return frame;
}",0.991304347826087
11513,"@Override public void windowClosing(WindowEvent e){
  canvas.dispose();
  frame.remove(canvas);
}","@Override public void windowClosing(WindowEvent e){
  canvas.disposeAttached();
  frame.remove(canvas);
}",0.9603960396039604
11514,"public static void main(String[] args) throws Exception {
  GLProfile glProfile=GLUtils.getDefaultGLProfile();
  ;
  GLOffscreenAutoDrawable glDrawable=GLUtils.newOffscreenDrawable(glProfile);
  GLContext glContext=glDrawable.getContext();
  final NewtSwingGlimpseCanvas canvas=new NewtSwingGlimpseCanvas(glContext);
  ColorAxisPlot2D layout=new HeatMapExample().getLayout();
  canvas.addLayout(layout);
  canvas.setLookAndFeel(new SwingLookAndFeel());
  final FBOGlimpseCanvas offscreenCanvas=new FBOGlimpseCanvas(glContext,800,800);
  offscreenCanvas.addLayout(layout);
  final NewtSwingGlimpseCanvas canvas2=new NewtSwingGlimpseCanvas(glContext);
  canvas2.addLayout(new ReprojectionExample().getLayout(offscreenCanvas));
  canvas2.setLookAndFeel(new SwingLookAndFeel());
  FPSAnimator animator=new FPSAnimator(120);
  animator.add(offscreenCanvas.getGLDrawable());
  animator.add(canvas2.getGLDrawable());
  animator.add(canvas.getGLDrawable());
  animator.start();
  createFrame(""String_Node_Str"",canvas);
  createFrame(""String_Node_Str"",canvas2);
  Runtime.getRuntime().addShutdownHook(new Thread(){
    @Override public void run(){
      offscreenCanvas.dispose();
    }
  }
);
}","public static void main(String[] args) throws Exception {
  GLProfile glProfile=GLUtils.getDefaultGLProfile();
  ;
  GLOffscreenAutoDrawable glDrawable=GLUtils.newOffscreenDrawable(glProfile);
  GLContext glContext=glDrawable.getContext();
  final NewtSwingGlimpseCanvas canvas=new NewtSwingGlimpseCanvas(glContext);
  ColorAxisPlot2D layout=new HeatMapExample().getLayout();
  canvas.addLayout(layout);
  canvas.setLookAndFeel(new SwingLookAndFeel());
  final FBOGlimpseCanvas offscreenCanvas=new FBOGlimpseCanvas(glContext,800,800);
  offscreenCanvas.addLayout(layout);
  final NewtSwingGlimpseCanvas canvas2=new NewtSwingGlimpseCanvas(glContext);
  canvas2.addLayout(new ReprojectionExample().getLayout(offscreenCanvas));
  canvas2.setLookAndFeel(new SwingLookAndFeel());
  FPSAnimator animator=new FPSAnimator(120);
  animator.add(offscreenCanvas.getGLDrawable());
  animator.add(canvas2.getGLDrawable());
  animator.add(canvas.getGLDrawable());
  animator.start();
  createFrame(""String_Node_Str"",canvas);
  createFrame(""String_Node_Str"",canvas2);
  Runtime.getRuntime().addShutdownHook(new Thread(){
    @Override public void run(){
      offscreenCanvas.disposeAttached();
    }
  }
);
}",0.9966386554621848
11515,"@Override public void run(){
  offscreenCanvas.dispose();
}","@Override public void run(){
  offscreenCanvas.disposeAttached();
}",0.9365079365079364
11516,"@Override public GlimpseAxisLayout2D getLayout(){
  final Random r=new Random();
  ColorAxisPlot2D plot=new ColorAxisPlot2D();
  plot.setPlotBackgroundColor(GlimpseColor.getBlack());
  plot.setBackgroundColor(GlimpseColor.getBlack());
  plot.setAxisColor(GlimpseColor.getWhite());
  plot.setTitleColor(GlimpseColor.getWhite());
  plot.getCrosshairPainter().setCursorColor(GlimpseColor.getGreen(0.2f));
  plot.getCrosshairPainter().setShadeColor(GlimpseColor.getGreen(0.05f));
  plot.getCrosshairPainter().setShadeSelectionBox(true);
  plot.getCrosshairPainter().setLineWidth(1);
  plot.setAxisLabelX(""String_Node_Str"");
  plot.setAxisLabelY(""String_Node_Str"");
  plot.setAxisLabelZ(""String_Node_Str"");
  plot.setTitle(""String_Node_Str"");
  plot.setMinX(-3);
  plot.setMaxX(3);
  plot.setMinY(-3);
  plot.setMaxY(3);
  plot.setMinZ(0);
  plot.setMaxZ(10);
  plot.lockAspectRatioXY(1);
  plot.addPainter(new GLSimpleListenerPainter(new GLCapabilityLogger()));
  ShadedPointPainter dp;
  try {
    dp=new ShadedPointPainter(plot.getAxisZ(),plot.getAxisZ());
  }
 catch (  IOException e) {
    e.printStackTrace();
    throw new RuntimeException(e);
  }
  plot.addPainter(dp);
  ColorTexture1D colors=new ColorTexture1D(256);
  ColorGradientBuilder builder=new ColorGradientBuilder(ColorGradients.jet){
    @Override public void getColor(    int index,    int size,    float[] rgba){
      super.getColor(index,size,rgba);
      rgba[3]=0.2f + 0.5f * ((float)index) / (size - 1);
    }
  }
;
  colors.mutate(builder);
  dp.useColorScale(colors);
  plot.setColorScale(colors);
  FloatTexture1D sizes=new FloatTexture1D(256);
  final MutatorFloat1D sizeMutator=new MutatorFloat1D(){
    @Override public void mutate(    FloatBuffer data,    int n0){
      float minSize=1f;
      float maxSize=12f;
      float dSize=maxSize - minSize;
      data.clear();
      for (int i=0; i < data.capacity(); i++) {
        if (i == data.capacity() - 1) {
          data.put(maxSize * 2);
        }
 else {
          data.put((float)(minSize + dSize * sqrt(i / (n0 - 1f))));
        }
      }
    }
  }
;
  sizes.mutate(sizeMutator);
  dp.useSizeScale(sizes);
  final GLFloatBuffer2D positions=new GLFloatBuffer2D(NPOINTS);
  positions.mutate(new Mutator(){
    @Override public void mutate(    FloatBuffer data,    int length){
      data.clear();
      for (int i=0; i < NPOINTS; i++) {
        data.put((float)r.nextGaussian());
        data.put((float)r.nextGaussian());
      }
    }
  }
);
  final Mutator positionMutator=new Mutator(){
    @Override public void mutate(    FloatBuffer data,    int length){
      data.clear();
      for (int i=0; i < NPOINTS; i++) {
        data.put((float)(data.get(2 * i) + .001 * r.nextGaussian()));
        data.put((float)(data.get(2 * i + 1) + .001 * r.nextGaussian()));
      }
    }
  }
;
  dp.useVertexPositionData(positions);
  final GLFloatBuffer colorValues=new GLFloatBuffer(NPOINTS,1);
  final Mutator colorValueMutator=new Mutator(){
    @Override public void mutate(    FloatBuffer data,    int length){
      data.clear();
      for (int i=0; i < NPOINTS; i++) {
        if (r.nextDouble() > 0.999) {
          data.put((float)(10 * r.nextFloat()));
        }
 else {
          data.put((float)0.99 * data.get(i));
        }
      }
    }
  }
;
  colorValues.mutate(colorValueMutator);
  dp.useColorAttribData(colorValues);
  final GLFloatBuffer sizeValues=new GLFloatBuffer(NPOINTS,1);
  final Mutator sizeValueMutator=new Mutator(){
    @Override public void mutate(    FloatBuffer data,    int length){
      data.clear();
      for (int i=0; i < NPOINTS; i++) {
        if (r.nextDouble() > 0.999) {
          data.put((float)10 * r.nextFloat());
        }
 else {
          data.put((float)0.99 * data.get(i));
        }
      }
    }
  }
;
  sizeValues.mutate(sizeValueMutator);
  dp.useSizeAttribData(sizeValues);
  new Thread(new Runnable(){
    @Override public void run(){
      while (true) {
        try {
          positions.mutate(positionMutator);
          colorValues.mutate(colorValueMutator);
          sizeValues.mutate(sizeValueMutator);
          Thread.sleep(10);
        }
 catch (        InterruptedException e) {
        }
      }
    }
  }
).start();
  plot.addPainter(new BorderPainter());
  plot.addPainter(new FpsPainter());
  return plot;
}","@Override public GlimpseAxisLayout2D getLayout(){
  final Random r=new Random();
  ColorAxisPlot2D plot=new ColorAxisPlot2D();
  plot.setPlotBackgroundColor(GlimpseColor.getBlack());
  plot.setBackgroundColor(GlimpseColor.getBlack());
  plot.setAxisColor(GlimpseColor.getWhite());
  plot.setTitleColor(GlimpseColor.getWhite());
  plot.getCrosshairPainter().setCursorColor(GlimpseColor.getGreen(0.2f));
  plot.getCrosshairPainter().setShadeColor(GlimpseColor.getGreen(0.05f));
  plot.getCrosshairPainter().setShadeSelectionBox(true);
  plot.getCrosshairPainter().setLineWidth(1);
  plot.setAxisLabelX(""String_Node_Str"");
  plot.setAxisLabelY(""String_Node_Str"");
  plot.setAxisLabelZ(""String_Node_Str"");
  plot.setTitle(""String_Node_Str"");
  plot.setMinX(-3);
  plot.setMaxX(3);
  plot.setMinY(-3);
  plot.setMaxY(3);
  plot.setMinZ(0);
  plot.setMaxZ(10);
  plot.lockAspectRatioXY(1);
  ShadedPointPainter dp;
  try {
    dp=new ShadedPointPainter(plot.getAxisZ(),plot.getAxisZ());
  }
 catch (  IOException e) {
    e.printStackTrace();
    throw new RuntimeException(e);
  }
  plot.addPainter(dp);
  ColorTexture1D colors=new ColorTexture1D(256);
  ColorGradientBuilder builder=new ColorGradientBuilder(ColorGradients.jet){
    @Override public void getColor(    int index,    int size,    float[] rgba){
      super.getColor(index,size,rgba);
      rgba[3]=0.2f + 0.5f * ((float)index) / (size - 1);
    }
  }
;
  colors.mutate(builder);
  dp.useColorScale(colors);
  plot.setColorScale(colors);
  FloatTexture1D sizes=new FloatTexture1D(256);
  final MutatorFloat1D sizeMutator=new MutatorFloat1D(){
    @Override public void mutate(    FloatBuffer data,    int n0){
      float minSize=1f;
      float maxSize=12f;
      float dSize=maxSize - minSize;
      data.clear();
      for (int i=0; i < data.capacity(); i++) {
        if (i == data.capacity() - 1) {
          data.put(maxSize * 2);
        }
 else {
          data.put((float)(minSize + dSize * sqrt(i / (n0 - 1f))));
        }
      }
    }
  }
;
  sizes.mutate(sizeMutator);
  dp.useSizeScale(sizes);
  final GLFloatBuffer2D positions=new GLFloatBuffer2D(NPOINTS);
  positions.mutate(new Mutator(){
    @Override public void mutate(    FloatBuffer data,    int length){
      data.clear();
      for (int i=0; i < NPOINTS; i++) {
        data.put((float)r.nextGaussian());
        data.put((float)r.nextGaussian());
      }
    }
  }
);
  final Mutator positionMutator=new Mutator(){
    @Override public void mutate(    FloatBuffer data,    int length){
      data.clear();
      for (int i=0; i < NPOINTS; i++) {
        data.put((float)(data.get(2 * i) + .001 * r.nextGaussian()));
        data.put((float)(data.get(2 * i + 1) + .001 * r.nextGaussian()));
      }
    }
  }
;
  dp.useVertexPositionData(positions);
  final GLFloatBuffer colorValues=new GLFloatBuffer(NPOINTS,1);
  final Mutator colorValueMutator=new Mutator(){
    @Override public void mutate(    FloatBuffer data,    int length){
      data.clear();
      for (int i=0; i < NPOINTS; i++) {
        if (r.nextDouble() > 0.999) {
          data.put((float)(10 * r.nextFloat()));
        }
 else {
          data.put((float)0.99 * data.get(i));
        }
      }
    }
  }
;
  colorValues.mutate(colorValueMutator);
  dp.useColorAttribData(colorValues);
  final GLFloatBuffer sizeValues=new GLFloatBuffer(NPOINTS,1);
  final Mutator sizeValueMutator=new Mutator(){
    @Override public void mutate(    FloatBuffer data,    int length){
      data.clear();
      for (int i=0; i < NPOINTS; i++) {
        if (r.nextDouble() > 0.999) {
          data.put((float)10 * r.nextFloat());
        }
 else {
          data.put((float)0.99 * data.get(i));
        }
      }
    }
  }
;
  sizeValues.mutate(sizeValueMutator);
  dp.useSizeAttribData(sizeValues);
  new Thread(new Runnable(){
    @Override public void run(){
      while (true) {
        try {
          positions.mutate(positionMutator);
          colorValues.mutate(colorValueMutator);
          sizeValues.mutate(sizeValueMutator);
          Thread.sleep(10);
        }
 catch (        InterruptedException e) {
        }
      }
    }
  }
).start();
  plot.addPainter(new BorderPainter());
  plot.addPainter(new FpsPainter());
  return plot;
}",0.9913430042115114
11517,"public static void main(String[] args) throws Exception {
  Example.showWithSwing(new PointShaderExample());
}","public static void main(String[] args) throws Exception {
  Example example=Example.showWithSwing(new PointShaderExample());
  example.getCanvas().getGLDrawable().addGLEventListener(new GLCapabilityEventListener());
}",0.672782874617737
11518,"private GLEventListener createGLEventListener(){
  return new GLEventListener(){
    @Override public void init(    GLAutoDrawable drawable){
      try {
        GL gl=drawable.getGL();
        gl.setSwapInterval(0);
      }
 catch (      Exception e) {
        logWarning(logger,""String_Node_Str"",e);
      }
    }
    @Override public void display(    GLAutoDrawable drawable){
      for (      GlimpseLayout layout : layoutManager.getLayoutList()) {
        layout.paintTo(getGlimpseContext());
      }
    }
    @Override public void reshape(    GLAutoDrawable drawable,    int x,    int y,    int width,    int height){
      for (      GlimpseLayout layout : layoutManager.getLayoutList()) {
        layout.layoutTo(getGlimpseContext());
      }
    }
    @Override public void dispose(    GLAutoDrawable drawable){
      for (      GlimpseLayout layout : layoutManager.getLayoutList()) {
        layout.dispose(getGlimpseContext());
      }
      for (      GLRunnable runnable : disposeListeners) {
        runnable.run(drawable.getContext());
      }
    }
  }
;
}","protected GLEventListener createGLEventListener(){
  return new GLEventListener(){
    @Override public void init(    GLAutoDrawable drawable){
      try {
        GL gl=drawable.getGL();
        gl.setSwapInterval(0);
      }
 catch (      Exception e) {
        logWarning(logger,""String_Node_Str"",e);
      }
    }
    @Override public void display(    GLAutoDrawable drawable){
      for (      GlimpseLayout layout : layoutManager.getLayoutList()) {
        layout.paintTo(getGlimpseContext());
      }
    }
    @Override public void reshape(    GLAutoDrawable drawable,    int x,    int y,    int width,    int height){
      for (      GlimpseLayout layout : layoutManager.getLayoutList()) {
        layout.layoutTo(getGlimpseContext());
      }
    }
    @Override public void dispose(    GLAutoDrawable drawable){
      for (      GLRunnable runnable : disposeListeners) {
        runnable.run(drawable);
      }
    }
  }
;
}",0.852165256346441
11519,"@Override public void dispose(){
  if (!isDisposed) {
    this.drawable.destroy();
    this.isDisposed=true;
  }
}","@Override public void dispose(GLAutoDrawable drawable){
  for (  GLRunnable runnable : disposeListeners) {
    runnable.run(drawable);
  }
}",0.5433070866141733
11520,"/** 
 * Called when the canvas is disposed. Can be used to clean up native resources used by this Canvas.
 */
public void addDisposeListener(GLRunnable runnable);","/** 
 * Called when   {@link GLEventListener#dispose(GLAutoDrawable)} event is fired by the {@link GLAutoDrawable} associated with theGlimpseCanvas. This can happen for reasons other than the window containing the GlimpseCanvas being closed (for example, moving the window between physical monitors or moving the container between docks in a docking framework). Thus, GlimpsePainters and GlimpseLayouts attached to this GlimpseCanvas should generally not be disposed when this callback occurs.
 */
public void addDisposeListener(GLRunnable runnable);",0.2528089887640449
11521,"protected void updateLayoutList(){
  Collections.sort(this.layoutList,this.comparator);
  ArrayList<GlimpseLayout> temp=Lists.newArrayListWithCapacity(this.layoutList.size());
  for (  LayoutOrder order : this.layoutList) {
    temp.add(order.getLayout());
  }
  this.unmodifiableLayoutList=Collections.unmodifiableList(temp);
}","protected void updateLayoutList(){
  Collections.sort(this.layoutList,this.comparator);
  ArrayList<GlimpseLayout> temp=Lists.newArrayListWithCapacity(this.layoutList.size());
  for (  LayoutOrder order : this.layoutList) {
    temp.add(order.getLayout());
  }
  this.unmodifiableLayoutList=Collections.unmodifiableList(Lists.newArrayList(temp));
}",0.9585798816568049
11522,"@Override public void mousePressed(GlimpseMouseEvent e){
  TimeStamp time=getTime(e);
  Set<EventSelection> tempEvents=Collections.unmodifiableSet(Sets.newHashSet(eventManager.getNearestEvents(e)));
  for (  EventPlotListener listener : eventListeners) {
    listener.eventsClicked(e,tempEvents,time);
  }
  EventSelection eventSelection=eventManager.getNearestEvent(tempEvents,e);
  if (eventSelection != null) {
    Event event=eventSelection.getEvent();
    if (event.isSelectable()) {
      if (e.isKeyDown(ModifierKey.Ctrl)) {
        if (selectionHandler.isEventSelected(event)) {
          selectionHandler.removeSelectedEvent(event);
        }
 else {
          selectionHandler.addSelectedEvent(event);
        }
      }
 else {
        selectionHandler.setSelectedEvents(Collections.singleton(event));
      }
    }
  }
 else   if (selectionHandler.isClearSelectionOnClick()) {
    selectionHandler.clearSelectedEvents();
  }
}","@Override public void mousePressed(GlimpseMouseEvent e){
  TimeStamp time=getTime(e);
  Set<EventSelection> tempEvents=Collections.unmodifiableSet(Sets.newHashSet(eventManager.getNearestEvents(e)));
  for (  EventPlotListener listener : eventListeners) {
    listener.eventsClicked(e,tempEvents,time);
  }
  EventSelection eventSelection=eventManager.getNearestEvent(tempEvents,e);
  if (eventSelection != null && selectionHandler.isAllowMouseEventSelection()) {
    Event event=eventSelection.getEvent();
    if (event.isSelectable()) {
      if (e.isKeyDown(ModifierKey.Ctrl) && selectionHandler.isAllowMultipleEventSelection()) {
        if (selectionHandler.isEventSelected(event)) {
          selectionHandler.removeSelectedEvent(event);
        }
 else {
          selectionHandler.addSelectedEvent(event);
        }
      }
 else {
        if (isDeselectSingleEvent(event)) {
          selectionHandler.setSelectedEvents(Collections.<Event>emptySet());
        }
 else {
          selectionHandler.setSelectedEvents(Collections.singleton(event));
        }
      }
    }
  }
 else   if (selectionHandler.isClearSelectionOnClick()) {
    selectionHandler.clearSelectedEvents();
  }
}",0.8814675446848542
11523,"public void setSelectedEvents(Set<Event> events){
  Set<Event> deselectedEvents=Sets.difference(selectedEvents,events).immutableCopy();
  Set<Event> newSelectedEvents=Sets.difference(events,selectedEvents).immutableCopy();
  selectedEvents.clear();
  selectedEvents.addAll(events);
  notifyEventsSelected(newSelectedEvents,deselectedEvents);
}","public void setSelectedEvents(Set<Event> events){
  if (events.equals(selectedEvents))   return;
  Set<Event> deselectedEvents=Sets.difference(selectedEvents,events).immutableCopy();
  Set<Event> newSelectedEvents=Sets.difference(events,selectedEvents).immutableCopy();
  selectedEvents.clear();
  selectedEvents.addAll(events);
  notifyEventsSelected(newSelectedEvents,deselectedEvents);
}",0.9358799454297408
11524,"@Override public void paintTo(GlimpseContext context){
  lock.lock();
  try {
    GlimpseBounds bounds=layoutTo(context);
    if (!isVisible)     return;
    context.getTargetStack().push(this,bounds);
    layoutDelegate.paintTo(context);
    context.getTargetStack().pop();
  }
  finally {
    lock.unlock();
  }
}","@Override public void paintTo(GlimpseContext context){
  lock.lock();
  try {
    GlimpseBounds bounds=layoutTo(context);
    context.getTargetStack().push(this,bounds);
    layoutDelegate.paintTo(context);
    context.getTargetStack().pop();
  }
  finally {
    lock.unlock();
  }
}",0.9464882943143812
11525,"public void paintTo(GlimpseContext context){
  GL gl=context.getGL();
  GlimpseBounds bounds=context.getTargetStack().getBounds();
  GlimpseBounds clippedBounds=getClippedBounds(context);
  if (!clippedBounds.isValid())   return;
  for (  Member m : memberList) {
    try {
      gl.glEnable(GL2.GL_SCISSOR_TEST);
      gl.glViewport(bounds.getX(),bounds.getY(),bounds.getWidth(),bounds.getHeight());
      gl.glScissor(clippedBounds.getX(),clippedBounds.getY(),clippedBounds.getWidth(),clippedBounds.getHeight());
      if (m.callback != null)       m.callback.prePaint(m.painter,context);
      m.painter.paintTo(context);
      if (m.callback != null)       m.callback.postPaint(m.painter,context);
    }
  finally {
      gl.glDisable(GL2.GL_SCISSOR_TEST);
    }
  }
}","public void paintTo(GlimpseContext context){
  GL gl=context.getGL();
  GlimpseBounds bounds=context.getTargetStack().getBounds();
  GlimpseBounds clippedBounds=getClippedBounds(context);
  if (!clippedBounds.isValid())   return;
  for (  Member m : memberList) {
    try {
      if (!(m.painter instanceof GlimpseLayout) && !layout.isVisible)       continue;
      gl.glEnable(GL2.GL_SCISSOR_TEST);
      gl.glViewport(bounds.getX(),bounds.getY(),bounds.getWidth(),bounds.getHeight());
      gl.glScissor(clippedBounds.getX(),clippedBounds.getY(),clippedBounds.getWidth(),clippedBounds.getHeight());
      if (m.callback != null)       m.callback.prePaint(m.painter,context);
      m.painter.paintTo(context);
      if (m.callback != null)       m.callback.postPaint(m.painter,context);
    }
  finally {
      gl.glDisable(GL2.GL_SCISSOR_TEST);
    }
  }
}",0.947239263803681
11526,"public void add(V value){
  V oldValue=this.set.get(value);
  if (oldValue != null) {
    this.tree.remove(oldValue);
  }
  this.tree.add(value);
}","public void add(V value){
  V oldValue=this.map.get(value);
  if (oldValue != null) {
    this.tree.remove(oldValue);
  }
  this.tree.add(value);
  this.map.put(value,value);
}",0.891640866873065
11527,"public Set<V> getAll(){
  return Collections.unmodifiableSet(this.set.keySet());
}","public Set<V> getAll(){
  return Collections.unmodifiableSet(this.map.keySet());
}",0.9634146341463414
11528,"public void clear(){
  this.tree=buildTree(maxBucketSize);
  this.set.clear();
}","public void clear(){
  this.tree=buildTree(maxBucketSize);
  this.map.clear();
}",0.9625
11529,"public void remove(V value){
  V oldValue=this.set.remove(value);
  if (oldValue != null) {
    this.tree.remove(oldValue);
  }
}","public void remove(V value){
  V oldValue=this.map.remove(value);
  if (oldValue != null) {
    this.tree.remove(oldValue);
  }
}",0.9767441860465116
11530,"public int size(){
  return this.set.size();
}","public int size(){
  return this.map.size();
}",0.9347826086956522
11531,"public IntervalQuadTree(int maxBucketSize){
  this.maxBucketSize=maxBucketSize;
  this.tree=buildTree(maxBucketSize);
  this.set=Maps.newHashMap();
}","public IntervalQuadTree(int maxBucketSize){
  this.maxBucketSize=maxBucketSize;
  this.tree=buildTree(maxBucketSize);
  this.map=Maps.newHashMap();
}",0.9798657718120806
11532,"/** 
 * The spacing between the bottom (descent) of one line of text to the top (ascent) of the next line.
 */
public float getLineSpacing(){
  return lineSpacing;
}","/** 
 * The spacing between the bottom (descent) of one line of text to the top (ascent) of the next line.
 */
public synchronized float getLineSpacing(){
  return lineSpacing;
}",0.9620991253644317
11533,"@Override protected void paintTo(GlimpseContext context,GlimpseBounds bounds){
  if (icons == null) {
    loadIcons();
  }
  if (newFont != null) {
    updateTextRenderer();
  }
  if (textLayout == null && textRenderer != null) {
    updateTextLayout();
  }
  if (lines == null && textLayout != null && text != null) {
    updateLayout();
  }
  final List<TextBoundingBox> tempLines=lines;
  if (textRenderer == null || tempLines == null)   return;
  GL2 gl=context.getGL().getGL2();
  int width=bounds.getWidth();
  int height=bounds.getHeight();
  double clampX=0;
  double clampY=0;
  if (clampToScreenEdges) {
    double maxX=x + linesBounds.maxX + offsetX;
    if (maxX > width)     clampX=width - maxX;
    double minX=x + linesBounds.minX + offsetX;
    if (minX < 0)     clampX=-minX;
    double maxY=height - y + linesBounds.maxY + offsetY;
    if (maxY > height)     clampY=height - maxY;
    double minY=height - y + linesBounds.minY + offsetY;
    if (minY < 0)     clampY=-minY;
  }
  gl.glMatrixMode(GL2.GL_PROJECTION);
  gl.glLoadIdentity();
  gl.glOrtho(-0.5,width - 1 + 0.5,-0.5,height - 1 + 0.5,-1,1);
  gl.glMatrixMode(GL2.GL_MODELVIEW);
  gl.glLoadIdentity();
  gl.glBlendFunc(GL2.GL_SRC_ALPHA,GL2.GL_ONE_MINUS_SRC_ALPHA);
  gl.glEnable(GL2.GL_BLEND);
  if (this.paintBackground || this.paintBorder) {
    if (this.paintBackground) {
      gl.glColor4fv(backgroundColor,0);
      gl.glBegin(GL2.GL_QUADS);
      try {
        borderVertices(gl,height,clampX + offsetX,clampY + offsetY);
      }
  finally {
        gl.glEnd();
      }
    }
    if (this.paintBorder) {
      gl.glColor4fv(borderColor,0);
      gl.glEnable(GL2.GL_LINE_SMOOTH);
      gl.glBegin(GL2.GL_LINE_LOOP);
      try {
        borderVertices(gl,height,clampX + offsetX,clampY + offsetY);
      }
  finally {
        gl.glEnd();
      }
    }
  }
  gl.glDisable(GL2.GL_BLEND);
  GlimpseColor.setColor(textRenderer,textColor);
  textRenderer.beginRendering(width,height);
  try {
    for (int i=0; i < tempLines.size(); i++) {
      TextBoundingBox line=tempLines.get(i);
      float iconSize=getIconSpacing(i);
      int posX=(int)(x + line.leftX + iconSize+ clampX+ offsetX);
      int posY=(int)(height - y + line.getMinY() + clampY + offsetY);
      textRenderer.draw(line.text,posX,posY);
    }
  }
  finally {
    textRenderer.endRendering();
  }
  if (!tempLines.isEmpty() && iconIds != null && !iconIds.isEmpty()) {
    atlas.beginRendering();
    try {
      for (int i=0; i < iconIds.size(); i++) {
        Object iconId=iconIds.get(i);
        ImageData iconData=icons.get(i);
        TextBoundingBox line=tempLines.get(i);
        if (iconId != null && iconData != null && line != null) {
          float iconSize=getIconSize();
          double iconScale=iconSize / (double)iconData.getWidth();
          int posX=(int)(x + line.leftX + clampX+ offsetX);
          int posY=(int)(height - y + line.getMinY() + clampY + offsetY - textLayout.getDescent() * 0.25);
          float[] color=defaultIconColor;
          if (iconColors != null && i < iconColors.size()) {
            float[] iconColor=iconColors.get(i);
            if (iconColor != null) {
              color=iconColor;
            }
          }
          GlimpseColor.glColor(gl,color);
          atlas.drawImage(gl,iconId,posX,posY,iconScale,iconScale,0,iconData.getHeight());
        }
      }
    }
  finally {
      atlas.endRendering();
    }
  }
}","@Override protected synchronized void paintTo(GlimpseContext context,GlimpseBounds bounds){
  if (icons == null) {
    loadIcons();
  }
  if (newFont != null) {
    updateTextRenderer();
  }
  if (textLayout == null && textRenderer != null) {
    updateTextLayout();
  }
  if (lines == null && textLayout != null && text != null) {
    updateLayout();
  }
  if (textRenderer == null || lines == null)   return;
  GL2 gl=context.getGL().getGL2();
  int width=bounds.getWidth();
  int height=bounds.getHeight();
  double clampX=0;
  double clampY=0;
  if (clampToScreenEdges) {
    double maxX=x + linesBounds.maxX + offsetX;
    if (maxX > width)     clampX=width - maxX;
    double minX=x + linesBounds.minX + offsetX;
    if (minX < 0)     clampX=-minX;
    double maxY=height - y + linesBounds.maxY + offsetY;
    if (maxY > height)     clampY=height - maxY;
    double minY=height - y + linesBounds.minY + offsetY;
    if (minY < 0)     clampY=-minY;
  }
  gl.glMatrixMode(GL2.GL_PROJECTION);
  gl.glLoadIdentity();
  gl.glOrtho(-0.5,width - 1 + 0.5,-0.5,height - 1 + 0.5,-1,1);
  gl.glMatrixMode(GL2.GL_MODELVIEW);
  gl.glLoadIdentity();
  gl.glBlendFunc(GL2.GL_SRC_ALPHA,GL2.GL_ONE_MINUS_SRC_ALPHA);
  gl.glEnable(GL2.GL_BLEND);
  if (this.paintBackground || this.paintBorder) {
    if (this.paintBackground) {
      gl.glColor4fv(backgroundColor,0);
      gl.glBegin(GL2.GL_QUADS);
      try {
        borderVertices(gl,height,clampX + offsetX,clampY + offsetY);
      }
  finally {
        gl.glEnd();
      }
    }
    if (this.paintBorder) {
      gl.glColor4fv(borderColor,0);
      gl.glEnable(GL2.GL_LINE_SMOOTH);
      gl.glBegin(GL2.GL_LINE_LOOP);
      try {
        borderVertices(gl,height,clampX + offsetX,clampY + offsetY);
      }
  finally {
        gl.glEnd();
      }
    }
  }
  gl.glDisable(GL2.GL_BLEND);
  GlimpseColor.setColor(textRenderer,textColor);
  textRenderer.beginRendering(width,height);
  try {
    for (int i=0; i < lines.size(); i++) {
      TextBoundingBox line=lines.get(i);
      float iconSize=getIconSpacing(i);
      int posX=(int)(x + line.leftX + iconSize+ clampX+ offsetX);
      int posY=(int)(height - y + line.getMinY() + clampY + offsetY);
      textRenderer.draw(line.text,posX,posY);
    }
  }
  finally {
    textRenderer.endRendering();
  }
  if (!lines.isEmpty() && iconIds != null && !iconIds.isEmpty()) {
    atlas.beginRendering();
    try {
      for (int i=0; i < iconIds.size(); i++) {
        Object iconId=iconIds.get(i);
        ImageData iconData=icons.get(i);
        TextBoundingBox line=lines.get(i);
        if (iconId != null && iconData != null && line != null) {
          float iconSize=getIconSize();
          double iconScale=iconSize / (double)iconData.getWidth();
          int posX=(int)(x + line.leftX + clampX+ offsetX);
          int posY=(int)(height - y + line.getMinY() + clampY + offsetY - textLayout.getDescent() * 0.25);
          float[] color=defaultIconColor;
          if (iconColors != null && i < iconColors.size()) {
            float[] iconColor=iconColors.get(i);
            if (iconColor != null) {
              color=iconColor;
            }
          }
          GlimpseColor.glColor(gl,color);
          atlas.drawImage(gl,iconId,posX,posY,iconScale,iconScale,0,iconData.getHeight());
        }
      }
    }
  finally {
      atlas.endRendering();
    }
  }
}",0.986737400530504
11534,"public int getBorderSize(){
  return this.borderSize;
}","public synchronized int getBorderSize(){
  return this.borderSize;
}",0.8943089430894309
11535,"public TooltipPainter setFixedWidth(int fixedWidth){
  this.fixedWidth=fixedWidth;
  this.isFixedWidth=true;
  this.lines=null;
  return this;
}","public synchronized TooltipPainter setFixedWidth(int fixedWidth){
  this.fixedWidth=fixedWidth;
  this.isFixedWidth=true;
  this.lines=null;
  return this;
}",0.956810631229236
11536,"public TooltipPainter setLocation(GlimpseMouseEvent e){
  return setLocation(e.getScreenPixelsX(),e.getScreenPixelsY());
}","public synchronized TooltipPainter setLocation(GlimpseMouseEvent e){
  return setLocation(e.getScreenPixelsX(),e.getScreenPixelsY());
}",0.9494163424124512
11537,"public TooltipPainter setOffset(int x,int y){
  this.offsetX=x;
  this.offsetY=y;
  return this;
}","public synchronized TooltipPainter setOffset(int x,int y){
  this.offsetX=x;
  this.offsetY=y;
  return this;
}",0.937799043062201
11538,"public TooltipPainter setBreakOnEol(boolean breakOnEol){
  this.breakOnEol=breakOnEol;
  this.textLayout=null;
  return this;
}","public synchronized TooltipPainter setBreakOnEol(boolean breakOnEol){
  this.breakOnEol=breakOnEol;
  this.textLayout=null;
  return this;
}",0.951310861423221
11539,"/** 
 * Whether to force a break on the end of line characters (\r \f \n).
 */
public boolean getBreakOnEol(){
  return breakOnEol;
}","/** 
 * Whether to force a break on the end of line characters (\r \f \n).
 */
public synchronized boolean getBreakOnEol(){
  return breakOnEol;
}",0.953405017921147
11540,"public TooltipPainter setBorderSize(int size){
  this.borderSize=size;
  this.lines=null;
  return this;
}","public synchronized TooltipPainter setBorderSize(int size){
  this.borderSize=size;
  this.lines=null;
  return this;
}",0.9422222222222222
11541,"public void setClampToScreenEdges(boolean clamp){
  this.clampToScreenEdges=clamp;
}","public synchronized void setClampToScreenEdges(boolean clamp){
  this.clampToScreenEdges=clamp;
}",0.9281767955801103
11542,"public TooltipPainter setUnlimitedWidth(){
  this.isFixedWidth=false;
  this.lines=null;
  return this;
}","public synchronized TooltipPainter setUnlimitedWidth(){
  this.isFixedWidth=false;
  this.lines=null;
  return this;
}",0.9417040358744396
11543,"public TooltipPainter setWrapTextAroundIcon(boolean wrap){
  this.wrapTextAroundIcon=wrap;
  this.lines=null;
  return this;
}","public synchronized TooltipPainter setWrapTextAroundIcon(boolean wrap){
  this.wrapTextAroundIcon=wrap;
  this.lines=null;
  return this;
}",0.9509433962264152
11544,"/** 
 * Sets the icon to be displayed on the first line of the tool tip.
 * @param id the id of the icon in TooltipPainter's TextureAtlas
 */
public TooltipPainter setIcon(Object iconId){
  this.iconIds=Collections.singletonList(iconId);
  this.iconColors=null;
  this.icons=null;
  this.lines=null;
  return this;
}","/** 
 * Sets the icon to be displayed on the first line of the tool tip.
 * @param id the id of the icon in TooltipPainter's TextureAtlas
 */
public synchronized TooltipPainter setIcon(Object iconId){
  this.iconIds=Collections.singletonList(iconId);
  this.iconColors=null;
  this.icons=null;
  this.lines=null;
  return this;
}",0.97984496124031
11545,"public TooltipPainter setBreakIterator(BreakIterator breakIterator){
  this.breakIterator=breakIterator;
  this.textLayout=null;
  return this;
}","public synchronized TooltipPainter setBreakIterator(BreakIterator breakIterator){
  this.breakIterator=breakIterator;
  this.textLayout=null;
  return this;
}",0.9570957095709572
11546,"public TooltipPainter setLineSpacing(float lineSpacing){
  this.lineSpacing=lineSpacing;
  this.textLayout=null;
  return this;
}","public synchronized TooltipPainter setLineSpacing(float lineSpacing){
  this.lineSpacing=lineSpacing;
  this.textLayout=null;
  return this;
}",0.9520295202952028
11547,"/** 
 * Sets icons and associated colors.
 * @see #setIcons(List)
 */
public TooltipPainter setIcons(List<Object> iconIds,List<float[]> colors){
  setIcons(iconIds);
  this.iconColors=Lists.newArrayList(colors);
  return this;
}","/** 
 * Sets icons and associated colors.
 * @see #setIcons(List)
 */
public synchronized TooltipPainter setIcons(List<Object> iconIds,List<float[]> colors){
  setIcons(iconIds);
  this.iconColors=Lists.newArrayList(colors);
  return this;
}",0.9722814498933902
11548,"public boolean isFixedWidth(){
  return this.isFixedWidth;
}","public synchronized boolean isFixedWidth(){
  return this.isFixedWidth;
}",0.9022556390977444
11549,"public int getFixedWidth(){
  return this.fixedWidth;
}","public synchronized int getFixedWidth(){
  return this.fixedWidth;
}",0.8943089430894309
11550,"@Override public TooltipPainter setText(String text){
  this.text=text;
  this.lines=null;
  return this;
}","@Override public synchronized TooltipPainter setText(String text){
  this.text=text;
  this.lines=null;
  return this;
}",0.9427312775330396
11551,"@Override public void paintTo(GL2 gl,GlimpseBounds bounds,Axis2D axis){
  if (dataSize == 0)   return;
  if (!bufferInitialized) {
    bufferHandle=new int[1];
    gl.glGenBuffers(1,bufferHandle,0);
    colorHandle=new int[1];
    gl.glGenBuffers(1,colorHandle,0);
    bufferInitialized=true;
  }
  if (newData) {
    this.dataBufferLock.lock();
    try {
      gl.glBindBuffer(GL2.GL_ARRAY_BUFFER,bufferHandle[0]);
      gl.glBufferData(GL2.GL_ARRAY_BUFFER,dataSize * 2 * BYTES_PER_FLOAT,dataBuffer.rewind(),GL2.GL_DYNAMIC_DRAW);
      glHandleError(gl);
      useColorDevice=useColorHost;
      if (useColorDevice) {
        gl.glBindBuffer(GL2.GL_ARRAY_BUFFER,colorHandle[0]);
        gl.glBufferData(GL2.GL_ARRAY_BUFFER,dataSize * 4 * BYTES_PER_FLOAT,colorBuffer.rewind(),GL2.GL_DYNAMIC_DRAW);
        glHandleError(gl);
      }
      newData=false;
    }
  finally {
      this.dataBufferLock.unlock();
    }
  }
  if (useColorDevice) {
    gl.glBindBuffer(GL2.GL_ARRAY_BUFFER,colorHandle[0]);
    gl.glColorPointer(4,GL2.GL_FLOAT,0,0);
    gl.glEnableClientState(GL2.GL_COLOR_ARRAY);
  }
  gl.glBindBuffer(GL2.GL_ARRAY_BUFFER,bufferHandle[0]);
  gl.glVertexPointer(2,GL2.GL_FLOAT,0,0);
  gl.glEnableClientState(GL2.GL_VERTEX_ARRAY);
  gl.glColor4fv(pointColor,0);
  gl.glPointSize(pointSize);
  gl.glDrawArrays(GL2.GL_POINTS,0,dataSize);
}","@Override public void paintTo(GL2 gl,GlimpseBounds bounds,Axis2D axis){
  if (dataSize == 0)   return;
  if (!bufferInitialized) {
    bufferHandle=new int[1];
    gl.glGenBuffers(1,bufferHandle,0);
    colorHandle=new int[1];
    gl.glGenBuffers(1,colorHandle,0);
    bufferInitialized=true;
  }
  this.dataBufferLock.lock();
  try {
    if (newData) {
      gl.glBindBuffer(GL2.GL_ARRAY_BUFFER,bufferHandle[0]);
      gl.glBufferData(GL2.GL_ARRAY_BUFFER,dataSize * 2 * BYTES_PER_FLOAT,dataBuffer.rewind(),GL2.GL_DYNAMIC_DRAW);
      glHandleError(gl);
      useColorDevice=useColorHost;
      if (useColorDevice) {
        gl.glBindBuffer(GL2.GL_ARRAY_BUFFER,colorHandle[0]);
        gl.glBufferData(GL2.GL_ARRAY_BUFFER,dataSize * 4 * BYTES_PER_FLOAT,colorBuffer.rewind(),GL2.GL_DYNAMIC_DRAW);
        glHandleError(gl);
      }
    }
    newData=false;
    if (useColorDevice) {
      gl.glBindBuffer(GL2.GL_ARRAY_BUFFER,colorHandle[0]);
      gl.glColorPointer(4,GL2.GL_FLOAT,0,0);
      gl.glEnableClientState(GL2.GL_COLOR_ARRAY);
    }
    gl.glBindBuffer(GL2.GL_ARRAY_BUFFER,bufferHandle[0]);
    gl.glVertexPointer(2,GL2.GL_FLOAT,0,0);
    gl.glEnableClientState(GL2.GL_VERTEX_ARRAY);
    gl.glColor4fv(pointColor,0);
    gl.glPointSize(pointSize);
    gl.glDrawArrays(GL2.GL_POINTS,0,dataSize);
  }
  finally {
    this.dataBufferLock.unlock();
  }
}",0.9053254437869822
11552,"@Override public boolean isDisposed(){
  return this.disposed;
}","@Override public boolean isDisposed(){
  this.disposeLock.lock();
  try {
    return this.disposed;
  }
  finally {
    this.disposeLock.unlock();
  }
}",0.5925925925925926
11553,"@Override public void paintTo(GL2 gl,GlimpseBounds bounds,Axis2D axis){
  if (lineCount == 0)   return;
  if (!bufferInitialized) {
    bufferHandle=new int[1];
    gl.glGenBuffers(1,bufferHandle,0);
    bufferInitialized=true;
  }
  gl.glBindBuffer(GL2.GL_ARRAY_BUFFER,bufferHandle[0]);
  if (newData) {
    this.dataBufferLock.lock();
    try {
      gl.glBufferData(GL2.GL_ARRAY_BUFFER,totalPointCount * 2 * BYTES_PER_FLOAT,dataBuffer.rewind(),GL2.GL_DYNAMIC_DRAW);
      glHandleError(gl);
      newData=false;
    }
  finally {
      this.dataBufferLock.unlock();
    }
  }
  gl.glBindBuffer(GL2.GL_ARRAY_BUFFER,bufferHandle[0]);
  gl.glVertexPointer(2,GL2.GL_FLOAT,0,0);
  gl.glEnableClientState(GL2.GL_VERTEX_ARRAY);
  gl.glColor4fv(lineColor,0);
  gl.glLineWidth(lineWidth);
  offsetBuffer.rewind();
  sizeBuffer.rewind();
  gl.glMultiDrawArrays(GL2.GL_LINE_STRIP,offsetBuffer,sizeBuffer,lineCount);
}","@Override public void paintTo(GL2 gl,GlimpseBounds bounds,Axis2D axis){
  if (lineCount == 0)   return;
  if (!bufferInitialized) {
    bufferHandle=new int[1];
    gl.glGenBuffers(1,bufferHandle,0);
    bufferInitialized=true;
  }
  gl.glBindBuffer(GL2.GL_ARRAY_BUFFER,bufferHandle[0]);
  dataBufferLock.lock();
  try {
    if (newData) {
      gl.glBufferData(GL2.GL_ARRAY_BUFFER,totalPointCount * 2 * BYTES_PER_FLOAT,dataBuffer.rewind(),GL2.GL_DYNAMIC_DRAW);
      glHandleError(gl);
      newData=false;
    }
    gl.glBindBuffer(GL2.GL_ARRAY_BUFFER,bufferHandle[0]);
    gl.glVertexPointer(2,GL2.GL_FLOAT,0,0);
    gl.glEnableClientState(GL2.GL_VERTEX_ARRAY);
    gl.glColor4fv(lineColor,0);
    gl.glLineWidth(lineWidth);
    offsetBuffer.rewind();
    sizeBuffer.rewind();
    gl.glMultiDrawArrays(GL2.GL_LINE_STRIP,offsetBuffer,sizeBuffer,lineCount);
  }
  finally {
    dataBufferLock.unlock();
  }
}",0.8921892189218922
11554,"/** 
 * Adds multiple tracks containing series of (x,y) positions to be painter. The positions of a single track are connected by lines. dataX[0] is an array containing the x coordinates of the positions in track id 0. dataX[0][0] is the x coordinate of point id 0 in track id 0. The ids are used when making spatial or temporal queries on this painter.
 * @param dataX x coordinate data for all points in all tracks
 * @param dataY y coordinate data for all points in all tracks
 */
public void setData(float[][] dataX,float[][] dataY){
  this.dataBufferLock.lock();
  try {
    lineCount=Math.min(dataX.length,dataY.length);
    totalPointCount=0;
    for (int trackId=0; trackId < lineCount; trackId++) {
      int pointCount=Math.min(dataX[trackId].length,dataY[trackId].length);
      totalPointCount+=pointCount;
    }
    if (dataBuffer == null || dataBuffer.rewind().capacity() < totalPointCount * 2) {
      this.dataBuffer=Buffers.newDirectFloatBuffer(totalPointCount * 2);
    }
    if (sizeBuffer == null || sizeBuffer.rewind().capacity() < lineCount) {
      this.sizeBuffer=Buffers.newDirectIntBuffer(lineCount);
    }
    if (offsetBuffer == null || offsetBuffer.rewind().capacity() < lineCount) {
      this.offsetBuffer=Buffers.newDirectIntBuffer(lineCount);
    }
    int pointCount=0;
    for (int trackId=0; trackId < lineCount; trackId++) {
      float[] trackX=dataX[trackId];
      float[] trackY=dataY[trackId];
      int trackLength=Math.min(dataX[trackId].length,dataY[trackId].length);
      this.offsetBuffer.put(pointCount);
      this.sizeBuffer.put(trackLength);
      pointCount+=trackLength;
      for (int i=0; i < trackLength; i++) {
        this.dataBuffer.put(trackX[i]).put(trackY[i]);
      }
    }
    pointCount=0;
    if (this.enableSpatialIndex) {
      this.spatialIndex=new QuadTreeXys<IdXy>(QUAD_TREE_BIN_MAX);
      for (int trackId=0; trackId < lineCount; trackId++) {
        float[] trackX=dataX[trackId];
        float[] trackY=dataY[trackId];
        int trackLength=Math.min(dataX[trackId].length,dataY[trackId].length);
        for (int i=0; i < trackLength; i++) {
          this.spatialIndex.add(new IdXy(pointCount++,trackX[i],trackY[i]));
        }
      }
    }
    this.newData=true;
  }
  finally {
    this.dataBufferLock.unlock();
  }
}","/** 
 * Adds multiple tracks containing series of (x,y) positions to be painter. The positions of a single track are connected by lines. dataX[0] is an array containing the x coordinates of the positions in track id 0. dataX[0][0] is the x coordinate of point id 0 in track id 0. The ids are used when making spatial or temporal queries on this painter.
 * @param dataX x coordinate data for all points in all tracks
 * @param dataY y coordinate data for all points in all tracks
 */
public void setData(float[][] dataX,float[][] dataY){
  this.dataBufferLock.lock();
  try {
    lineCount=Math.min(dataX.length,dataY.length);
    totalPointCount=0;
    for (int trackId=0; trackId < lineCount; trackId++) {
      int pointCount=Math.min(dataX[trackId].length,dataY[trackId].length);
      totalPointCount+=pointCount;
    }
    System.out.println(totalPointCount);
    if (dataBuffer == null || dataBuffer.rewind().capacity() < totalPointCount * 2) {
      this.dataBuffer=Buffers.newDirectFloatBuffer(totalPointCount * 2);
    }
    if (sizeBuffer == null || sizeBuffer.rewind().capacity() < lineCount) {
      this.sizeBuffer=Buffers.newDirectIntBuffer(lineCount);
    }
    if (offsetBuffer == null || offsetBuffer.rewind().capacity() < lineCount) {
      this.offsetBuffer=Buffers.newDirectIntBuffer(lineCount);
    }
    int pointCount=0;
    for (int trackId=0; trackId < lineCount; trackId++) {
      float[] trackX=dataX[trackId];
      float[] trackY=dataY[trackId];
      int trackLength=Math.min(dataX[trackId].length,dataY[trackId].length);
      this.offsetBuffer.put(pointCount);
      this.sizeBuffer.put(trackLength);
      pointCount+=trackLength;
      for (int i=0; i < trackLength; i++) {
        this.dataBuffer.put(trackX[i]).put(trackY[i]);
      }
    }
    pointCount=0;
    if (this.enableSpatialIndex) {
      this.spatialIndex=new QuadTreeXys<IdXy>(QUAD_TREE_BIN_MAX);
      for (int trackId=0; trackId < lineCount; trackId++) {
        float[] trackX=dataX[trackId];
        float[] trackY=dataY[trackId];
        int trackLength=Math.min(dataX[trackId].length,dataY[trackId].length);
        for (int i=0; i < trackLength; i++) {
          this.spatialIndex.add(new IdXy(pointCount++,trackX[i],trackY[i]));
        }
      }
    }
    this.newData=true;
  }
  finally {
    this.dataBufferLock.unlock();
  }
}",0.991161888338004
11555,"public void add(V event){
  startMultimap.put(event.getStartTime(),event);
  endMultimap.put(event.getEndTime(),event);
}","public void add(V event){
  V existingEvent=values.get(event);
  if (existingEvent != null) {
    remove0(existingEvent);
  }
  add0(event);
}",0.5399239543726235
11556,"public void clear(){
  startMultimap.clear();
  endMultimap.clear();
}","public void clear(){
  values.clear();
  startMultimap.clear();
  endMultimap.clear();
}",0.8860759493670886
11557,"public void remove(V event){
  startMultimap.remove(event.getStartTime(),event);
  endMultimap.remove(event.getEndTime(),event);
}","public void remove(V event){
  V existingEvent=values.get(event);
  if (existingEvent != null) {
    remove0(existingEvent);
  }
 else {
    remove0(event);
  }
}",0.5616438356164384
11558,"public IntervalSortedMultimap(){
  startMultimap=buildMap();
  endMultimap=buildMap();
  startMap=(SortedMap<K,Collection<V>>)startMultimap.asMap();
  endMap=(SortedMap<K,Collection<V>>)endMultimap.asMap();
}","public IntervalSortedMultimap(){
  values=Maps.newHashMap();
  startMultimap=buildMap();
  endMultimap=buildMap();
  startMap=(SortedMap<K,Collection<V>>)startMultimap.asMap();
  endMap=(SortedMap<K,Collection<V>>)endMultimap.asMap();
}",0.9369369369369368
11559,"@Override protected void paintTo(GlimpseContext context,GlimpseBounds bounds){
  if (icons == null) {
    loadIcons();
  }
  if (newFont != null) {
    updateTextRenderer();
  }
  if (textLayout == null && textRenderer != null) {
    updateTextLayout();
  }
  if (lines == null && textLayout != null && text != null) {
    updateLayout();
  }
  if (textRenderer == null || lines == null)   return;
  GL2 gl=context.getGL().getGL2();
  int width=bounds.getWidth();
  int height=bounds.getHeight();
  double clampX=0;
  double clampY=0;
  if (clampToScreenEdges) {
    double maxX=x + linesBounds.maxX + offsetX;
    if (maxX > width)     clampX=width - maxX;
    double minX=x + linesBounds.minX + offsetX;
    if (minX < 0)     clampX=-minX;
    double maxY=height - y + linesBounds.maxY + offsetY;
    if (maxY > height)     clampY=height - maxY;
    double minY=height - y + linesBounds.minY + offsetY;
    if (minY < 0)     clampY=-minY;
  }
  gl.glMatrixMode(GL2.GL_PROJECTION);
  gl.glLoadIdentity();
  gl.glOrtho(-0.5,width - 1 + 0.5,-0.5,height - 1 + 0.5,-1,1);
  gl.glMatrixMode(GL2.GL_MODELVIEW);
  gl.glLoadIdentity();
  gl.glBlendFunc(GL2.GL_SRC_ALPHA,GL2.GL_ONE_MINUS_SRC_ALPHA);
  gl.glEnable(GL2.GL_BLEND);
  if (this.paintBackground || this.paintBorder) {
    if (this.paintBackground) {
      gl.glColor4fv(backgroundColor,0);
      gl.glBegin(GL2.GL_QUADS);
      try {
        borderVertices(gl,height,clampX + offsetX,clampY + offsetY);
      }
  finally {
        gl.glEnd();
      }
    }
    if (this.paintBorder) {
      gl.glColor4fv(borderColor,0);
      gl.glEnable(GL2.GL_LINE_SMOOTH);
      gl.glBegin(GL2.GL_LINE_LOOP);
      try {
        borderVertices(gl,height,clampX + offsetX,clampY + offsetY);
      }
  finally {
        gl.glEnd();
      }
    }
  }
  gl.glDisable(GL2.GL_BLEND);
  GlimpseColor.setColor(textRenderer,textColor);
  textRenderer.beginRendering(width,height);
  try {
    for (int i=0; i < lines.size(); i++) {
      TextBoundingBox line=lines.get(i);
      float iconSize=getIconSpacing(i);
      int posX=(int)(x + line.leftX + iconSize+ clampX+ offsetX);
      int posY=(int)(height - y + line.getMinY() + clampY + offsetY);
      textRenderer.draw(line.text,posX,posY);
    }
  }
  finally {
    textRenderer.endRendering();
  }
  if (!lines.isEmpty() && iconIds != null && !iconIds.isEmpty()) {
    atlas.beginRendering();
    try {
      for (int i=0; i < iconIds.size(); i++) {
        Object iconId=iconIds.get(i);
        ImageData iconData=icons.get(i);
        TextBoundingBox line=lines.get(i);
        if (iconId != null && iconData != null && line != null) {
          float iconSize=getIconSize();
          double iconScale=iconSize / (double)iconData.getWidth();
          int posX=(int)(x + line.leftX + clampX+ offsetX);
          int posY=(int)(height - y + line.getMinY() + clampY + offsetY - textLayout.getDescent() * 0.25);
          float[] color=defaultIconColor;
          if (iconColors != null && i < iconColors.size()) {
            float[] iconColor=iconColors.get(i);
            if (iconColor != null) {
              color=iconColor;
            }
          }
          GlimpseColor.glColor(gl,color);
          atlas.drawImage(gl,iconId,posX,posY,iconScale,iconScale,0,iconData.getHeight());
        }
      }
    }
  finally {
      atlas.endRendering();
    }
  }
}","@Override protected void paintTo(GlimpseContext context,GlimpseBounds bounds){
  if (icons == null) {
    loadIcons();
  }
  if (newFont != null) {
    updateTextRenderer();
  }
  if (textLayout == null && textRenderer != null) {
    updateTextLayout();
  }
  if (lines == null && textLayout != null && text != null) {
    updateLayout();
  }
  final List<TextBoundingBox> tempLines=lines;
  if (textRenderer == null || tempLines == null)   return;
  GL2 gl=context.getGL().getGL2();
  int width=bounds.getWidth();
  int height=bounds.getHeight();
  double clampX=0;
  double clampY=0;
  if (clampToScreenEdges) {
    double maxX=x + linesBounds.maxX + offsetX;
    if (maxX > width)     clampX=width - maxX;
    double minX=x + linesBounds.minX + offsetX;
    if (minX < 0)     clampX=-minX;
    double maxY=height - y + linesBounds.maxY + offsetY;
    if (maxY > height)     clampY=height - maxY;
    double minY=height - y + linesBounds.minY + offsetY;
    if (minY < 0)     clampY=-minY;
  }
  gl.glMatrixMode(GL2.GL_PROJECTION);
  gl.glLoadIdentity();
  gl.glOrtho(-0.5,width - 1 + 0.5,-0.5,height - 1 + 0.5,-1,1);
  gl.glMatrixMode(GL2.GL_MODELVIEW);
  gl.glLoadIdentity();
  gl.glBlendFunc(GL2.GL_SRC_ALPHA,GL2.GL_ONE_MINUS_SRC_ALPHA);
  gl.glEnable(GL2.GL_BLEND);
  if (this.paintBackground || this.paintBorder) {
    if (this.paintBackground) {
      gl.glColor4fv(backgroundColor,0);
      gl.glBegin(GL2.GL_QUADS);
      try {
        borderVertices(gl,height,clampX + offsetX,clampY + offsetY);
      }
  finally {
        gl.glEnd();
      }
    }
    if (this.paintBorder) {
      gl.glColor4fv(borderColor,0);
      gl.glEnable(GL2.GL_LINE_SMOOTH);
      gl.glBegin(GL2.GL_LINE_LOOP);
      try {
        borderVertices(gl,height,clampX + offsetX,clampY + offsetY);
      }
  finally {
        gl.glEnd();
      }
    }
  }
  gl.glDisable(GL2.GL_BLEND);
  GlimpseColor.setColor(textRenderer,textColor);
  textRenderer.beginRendering(width,height);
  try {
    for (int i=0; i < tempLines.size(); i++) {
      TextBoundingBox line=tempLines.get(i);
      float iconSize=getIconSpacing(i);
      int posX=(int)(x + line.leftX + iconSize+ clampX+ offsetX);
      int posY=(int)(height - y + line.getMinY() + clampY + offsetY);
      textRenderer.draw(line.text,posX,posY);
    }
  }
  finally {
    textRenderer.endRendering();
  }
  if (!tempLines.isEmpty() && iconIds != null && !iconIds.isEmpty()) {
    atlas.beginRendering();
    try {
      for (int i=0; i < iconIds.size(); i++) {
        Object iconId=iconIds.get(i);
        ImageData iconData=icons.get(i);
        TextBoundingBox line=tempLines.get(i);
        if (iconId != null && iconData != null && line != null) {
          float iconSize=getIconSize();
          double iconScale=iconSize / (double)iconData.getWidth();
          int posX=(int)(x + line.leftX + clampX+ offsetX);
          int posY=(int)(height - y + line.getMinY() + clampY + offsetY - textLayout.getDescent() * 0.25);
          float[] color=defaultIconColor;
          if (iconColors != null && i < iconColors.size()) {
            float[] iconColor=iconColors.get(i);
            if (iconColor != null) {
              color=iconColor;
            }
          }
          GlimpseColor.glColor(gl,color);
          atlas.drawImage(gl,iconId,posX,posY,iconScale,iconScale,0,iconData.getHeight());
        }
      }
    }
  finally {
      atlas.endRendering();
    }
  }
}",0.988631330282002
11560,"protected void read(InputStream in,GeoProjection tp) throws IOException {
  BufferedReader reader=new BufferedReader(new InputStreamReader(in));
  NavigableSet<Row> rows=new TreeSet<Row>(new Comparator<Row>(){
    @Override public int compare(    Row o1,    Row o2){
      int latComparison=Double.compare(o1.centerLat,o2.centerLat);
      return (latComparison != 0 ? latComparison : Double.compare(o1.centerLon,o2.centerLon));
    }
  }
);
  String line=null;
  while ((line=reader.readLine()) != null) {
    if (line.trim().isEmpty())     continue;
    String[] tokens=line.trim().split(""String_Node_Str"");
    float lon=Float.parseFloat(tokens[0]);
    float lat=Float.parseFloat(tokens[1]);
    float depth=Float.parseFloat(tokens[2]);
    rows.add(new Row(lat,lon,depth));
  }
  NavigableSet<Row> uniqueLatitudes=new TreeSet<Row>(new Comparator<Row>(){
    @Override public int compare(    Row o1,    Row o2){
      return Double.compare(o1.centerLat,o2.centerLat);
    }
  }
);
  NavigableSet<Row> uniqueLongitudes=new TreeSet<Row>(new Comparator<Row>(){
    @Override public int compare(    Row o1,    Row o2){
      return Double.compare(o1.centerLon,o2.centerLon);
    }
  }
);
  uniqueLatitudes.addAll(rows);
  uniqueLongitudes.addAll(rows);
  imageHeight=uniqueLatitudes.size();
  imageWidth=uniqueLongitudes.size();
  widthStep=0;
  Row prevRow=null;
  for (  Row row : uniqueLongitudes) {
    if (prevRow != null) {
      widthStep+=row.centerLon - prevRow.centerLon;
    }
    prevRow=row;
  }
  widthStep=widthStep / (uniqueLongitudes.size() - 1);
  heightStep=0;
  prevRow=null;
  for (  Row row : uniqueLatitudes) {
    if (prevRow != null) {
      heightStep+=row.centerLat - prevRow.centerLat;
    }
    prevRow=row;
  }
  heightStep=heightStep / (uniqueLatitudes.size() - 1);
  startLon=uniqueLongitudes.first().centerLon - 0.5 * widthStep;
  startLat=uniqueLatitudes.first().centerLat - 0.5 * heightStep;
  data=new double[imageWidth][imageHeight];
  for (  Row row : rows) {
    int x=(int)Math.floor((row.centerLon - startLon) / widthStep);
    int y=(int)Math.floor((row.centerLat - startLat) / heightStep);
    if (x < 0)     x=0;
    if (x >= imageWidth)     x=imageWidth - 1;
    if (y < 0)     y=0;
    if (y >= imageHeight)     y=imageHeight - 1;
    data[x][y]=row.depth;
  }
}","protected void read(InputStream in,GeoProjection tp) throws IOException {
  BufferedReader reader=new BufferedReader(new InputStreamReader(in));
  NavigableSet<Row> rows=new TreeSet<Row>(new Comparator<Row>(){
    @Override public int compare(    Row o1,    Row o2){
      int latComparison=Double.compare(o1.centerLat,o2.centerLat);
      return (latComparison != 0 ? latComparison : Double.compare(o1.centerLon,o2.centerLon));
    }
  }
);
  String line=null;
  while ((line=reader.readLine()) != null) {
    if (line.trim().isEmpty())     continue;
    String[] tokens=line.trim().split(""String_Node_Str"");
    float lon=Float.parseFloat(tokens[0]);
    float lat=Float.parseFloat(tokens[1]);
    float depth=Float.parseFloat(tokens[2]);
    rows.add(new Row(lat,lon,depth));
  }
  NavigableSet<Row> uniqueLatitudes=new TreeSet<Row>(new Comparator<Row>(){
    @Override public int compare(    Row o1,    Row o2){
      return Double.compare(o1.centerLat,o2.centerLat);
    }
  }
);
  NavigableSet<Row> uniqueLongitudes=new TreeSet<Row>(new Comparator<Row>(){
    @Override public int compare(    Row o1,    Row o2){
      return Double.compare(o1.centerLon,o2.centerLon);
    }
  }
);
  uniqueLatitudes.addAll(rows);
  uniqueLongitudes.addAll(rows);
  imageHeight=uniqueLatitudes.size();
  imageWidth=uniqueLongitudes.size();
  widthStep=0;
  Row prevRow=null;
  for (  Row row : uniqueLongitudes) {
    if (prevRow != null) {
      widthStep+=row.centerLon - prevRow.centerLon;
    }
    prevRow=row;
  }
  widthStep=widthStep / (uniqueLongitudes.size() - 1);
  heightStep=0;
  prevRow=null;
  for (  Row row : uniqueLatitudes) {
    if (prevRow != null) {
      heightStep+=row.centerLat - prevRow.centerLat;
    }
    prevRow=row;
  }
  heightStep=heightStep / (uniqueLatitudes.size() - 1);
  startLon=uniqueLongitudes.first().centerLon - 0.5 * widthStep;
  startLat=uniqueLatitudes.first().centerLat - 0.5 * heightStep;
  data=new double[imageWidth][imageHeight];
  for (  Row row : rows) {
    int x=(int)Math.floor((row.centerLon - startLon) / widthStep);
    int y=(int)Math.floor((row.centerLat - startLat) / heightStep);
    if (x < 0)     x=0;
    if (x >= imageWidth)     x=imageWidth - 1;
    if (y < 0)     y=0;
    if (y >= imageHeight)     y=imageHeight - 1;
    data[x][y]=row.depth;
  }
  startLon=Angle.normalizeAngle180(startLon);
}",0.9901329901329902
11561,"public Example(SwingGlimpseCanvas canvas,RepaintManager manager,JFrame frame,GlimpseLayout layout){
  super();
  this.canvas=canvas;
  this.manager=manager;
  this.frame=frame;
  this.layout=layout;
}","public Example(NewtGlimpseCanvas canvas,RepaintManager manager,JFrame frame,GlimpseLayout layout){
  super();
  this.canvas=canvas;
  this.manager=manager;
  this.frame=frame;
  this.layout=layout;
}",0.9824561403508772
11562,"public static void showWithSwing(GlimpseLayoutProvider layoutProviderA,GlimpseLayoutProvider layoutProviderB) throws Exception {
  GLContext context=createPixelBuffer(1,1).getContext();
  SwingGlimpseCanvas leftPanel=new SwingGlimpseCanvas(context);
  leftPanel.addLayout(layoutProviderA.getLayout());
  SwingGlimpseCanvas rightPanel=new SwingGlimpseCanvas(context);
  rightPanel.addLayout(layoutProviderB.getLayout());
  RepaintManager repaintManager=new NEWTRepaintManager(leftPanel.getGLDrawable());
  repaintManager.addGlimpseCanvas(leftPanel);
  repaintManager.addGlimpseCanvas(rightPanel);
  repaintManager.start();
  JFrame rightFrame=new JFrame(""String_Node_Str"");
  rightFrame.add(rightPanel);
  rightFrame.pack();
  rightFrame.setSize(800,800);
  rightFrame.setLocation(800,0);
  rightFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
  rightFrame.setVisible(true);
  JFrame leftFrame=new JFrame(""String_Node_Str"");
  leftFrame.add(leftPanel);
  leftFrame.pack();
  leftFrame.setSize(800,800);
  leftFrame.setLocation(0,0);
  leftFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
  leftFrame.setVisible(true);
  return;
}","public static void showWithSwing(GlimpseLayoutProvider layoutProviderA,GlimpseLayoutProvider layoutProviderB) throws Exception {
  final GLOffscreenAutoDrawable pBuffer=createPixelBuffer(1,1);
  final GLContext context=pBuffer.getContext();
  NewtGlimpseCanvas leftPanel=new NewtGlimpseCanvas(context);
  leftPanel.addLayout(layoutProviderA.getLayout());
  NewtGlimpseCanvas rightPanel=new NewtGlimpseCanvas(context);
  rightPanel.addLayout(layoutProviderB.getLayout());
  RepaintManager repaintManager=new NEWTRepaintManager(leftPanel.getGLDrawable());
  repaintManager.addGlimpseCanvas(leftPanel);
  repaintManager.addGlimpseCanvas(rightPanel);
  repaintManager.start();
  JFrame rightFrame=new JFrame(""String_Node_Str"");
  rightPanel.addDisposeListener(rightFrame,pBuffer);
  rightFrame.add(rightPanel);
  rightFrame.pack();
  rightFrame.setSize(800,800);
  rightFrame.setLocation(800,0);
  rightFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
  rightFrame.setVisible(true);
  JFrame leftFrame=new JFrame(""String_Node_Str"");
  leftPanel.addDisposeListener(leftFrame,pBuffer);
  leftFrame.add(leftPanel);
  leftFrame.pack();
  leftFrame.setSize(800,800);
  leftFrame.setLocation(0,0);
  leftFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
  leftFrame.setVisible(true);
  return;
}",0.9001233045622689
11563,"public SwingGlimpseCanvas getCanvas(){
  return canvas;
}","public NewtGlimpseCanvas getCanvas(){
  return canvas;
}",0.9380530973451328
11564,"protected static GlimpseLayout buildPlot(final SwingGlimpseCanvas canvas) throws Exception {
  GlimpseLayout layout=new SimpleLayoutExample().getLayout();
  final JPopupMenu _popupMenu=createPopupMenu();
  canvas.getGLWindow().addMouseListener(new MouseAdapter(){
    @Override public void mouseClicked(    MouseEvent event){
      if (event.getButton() == MouseEvent.BUTTON3) {
        _popupMenu.show(canvas,event.getX(),event.getY());
      }
    }
  }
);
  return layout;
}","protected static GlimpseLayout buildPlot(final NewtGlimpseCanvas canvas) throws Exception {
  GlimpseLayout layout=new SimpleLayoutExample().getLayout();
  final JPopupMenu _popupMenu=createPopupMenu();
  canvas.getGLWindow().addMouseListener(new MouseAdapter(){
    @Override public void mouseClicked(    MouseEvent event){
      if (event.getButton() == MouseEvent.BUTTON3) {
        _popupMenu.show(canvas,event.getX(),event.getY());
      }
    }
  }
);
  return layout;
}",0.9905561385099684
11565,"public static void main(String[] args) throws Exception {
  final SwingGlimpseCanvas canvas=new SwingGlimpseCanvas();
  GlimpseLayout plot=buildPlot(canvas);
  canvas.addLayout(plot);
  canvas.setLookAndFeel(new SwingLookAndFeel());
  final JFrame frame=new JFrame(""String_Node_Str"");
  frame.addWindowListener(new WindowAdapter(){
    @Override public void windowClosing(    WindowEvent e){
      canvas.dispose();
      frame.remove(canvas);
    }
  }
);
  frame.add(canvas);
  frame.pack();
  frame.setSize(800,800);
  frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
  frame.setVisible(true);
  return;
}","public static void main(String[] args) throws Exception {
  final NewtGlimpseCanvas canvas=new NewtGlimpseCanvas();
  GlimpseLayout plot=buildPlot(canvas);
  canvas.addLayout(plot);
  canvas.setLookAndFeel(new SwingLookAndFeel());
  NEWTRepaintManager.newRepaintManager(canvas);
  final JFrame frame=new JFrame(""String_Node_Str"");
  frame.addWindowListener(new WindowAdapter(){
    @Override public void windowClosing(    WindowEvent e){
      canvas.dispose();
      frame.remove(canvas);
    }
  }
);
  frame.add(canvas);
  frame.pack();
  frame.setSize(800,800);
  frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
  frame.setVisible(true);
  return;
}",0.9481132075471698
11566,"public static void main(String[] args) throws Exception {
  final SwingGlimpseCanvas canvas=new SwingGlimpseCanvas();
  GlimpseLayout plot=new HeatMapExample().getLayout();
  canvas.addLayout(plot);
  canvas.setLookAndFeel(new SwingLookAndFeel());
  SwingRepaintManager.newRepaintManager(canvas);
  final JFrame frame=makeFrame(0,0,800,800);
  final JFrame frame2=makeFrame(800,0,800,800);
  frame.add(canvas);
  new Timer(1000,new ActionListener(){
    boolean toc=true;
    @Override public void actionPerformed(    ActionEvent e){
      if (toc) {
        frame.remove(canvas);
        frame2.add(canvas);
      }
 else {
        frame2.remove(canvas);
        frame.add(canvas);
      }
      frame2.validate();
      frame.validate();
      toc=!toc;
    }
  }
).start();
}","public static void main(String[] args) throws Exception {
  final NewtGlimpseCanvas canvas=new NewtGlimpseCanvas();
  GlimpseLayout plot=new HeatMapExample().getLayout();
  canvas.addLayout(plot);
  canvas.setLookAndFeel(new SwingLookAndFeel());
  NEWTRepaintManager.newRepaintManager(canvas);
  final JFrame frame=makeFrame(0,0,800,800);
  final JFrame frame2=makeFrame(800,0,800,800);
  frame.add(canvas);
  new Timer(1000,new ActionListener(){
    boolean toc=true;
    @Override public void actionPerformed(    ActionEvent e){
      if (toc) {
        frame.remove(canvas);
        frame2.add(canvas);
      }
 else {
        frame2.remove(canvas);
        frame.add(canvas);
      }
      frame2.validate();
      frame.validate();
      toc=!toc;
    }
  }
).start();
}",0.9826142949130716
11567,"public static JFrame createFrame(String name,final SwingGlimpseCanvas canvas){
  final JFrame frame=new JFrame(name);
  frame.addWindowListener(new WindowAdapter(){
    @Override public void windowClosing(    WindowEvent e){
      canvas.dispose();
      frame.remove(canvas);
    }
  }
);
  frame.add(canvas);
  frame.pack();
  frame.setSize(800,800);
  frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
  frame.setVisible(true);
  return frame;
}","public static JFrame createFrame(String name,final NewtGlimpseCanvas canvas){
  final JFrame frame=new JFrame(name);
  frame.addWindowListener(new WindowAdapter(){
    @Override public void windowClosing(    WindowEvent e){
      canvas.dispose();
      frame.remove(canvas);
    }
  }
);
  frame.add(canvas);
  frame.pack();
  frame.setSize(800,800);
  frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
  frame.setVisible(true);
  return frame;
}",0.9900332225913622
11568,"public static void main(String[] args) throws Exception {
  GLContext context=createPixelBuffer(1,1).getContext();
  final SwingGlimpseCanvas canvas=new SwingGlimpseCanvas(context);
  ColorAxisPlot2D layout=new HeatMapExample().getLayout();
  canvas.addLayout(layout);
  canvas.setLookAndFeel(new SwingLookAndFeel());
  final RepaintManager manager=SwingRepaintManager.newRepaintManager(canvas);
  final FrameBufferGlimpseCanvas offscreenCanvas=new FrameBufferGlimpseCanvas(800,800,context);
  offscreenCanvas.addLayout(layout);
  manager.addGlimpseCanvas(offscreenCanvas);
  final SwingGlimpseCanvas canvas2=new SwingGlimpseCanvas(context);
  canvas2.addLayout(new ReprojectionExample().getLayout(offscreenCanvas));
  canvas2.setLookAndFeel(new SwingLookAndFeel());
  manager.addGlimpseCanvas(canvas2);
  createFrame(""String_Node_Str"",canvas);
  createFrame(""String_Node_Str"",canvas2);
  Runtime.getRuntime().addShutdownHook(new Thread(){
    @Override public void run(){
      offscreenCanvas.dispose();
    }
  }
);
}","public static void main(String[] args) throws Exception {
  GLContext context=createPixelBuffer(1,1).getContext();
  final NewtGlimpseCanvas canvas=new NewtGlimpseCanvas(context);
  ColorAxisPlot2D layout=new HeatMapExample().getLayout();
  canvas.addLayout(layout);
  canvas.setLookAndFeel(new SwingLookAndFeel());
  final RepaintManager manager=NEWTRepaintManager.newRepaintManager(canvas);
  final FrameBufferGlimpseCanvas offscreenCanvas=new FrameBufferGlimpseCanvas(800,800,context);
  offscreenCanvas.addLayout(layout);
  manager.addGlimpseCanvas(offscreenCanvas);
  final NewtGlimpseCanvas canvas2=new NewtGlimpseCanvas(context);
  canvas2.addLayout(new ReprojectionExample().getLayout(offscreenCanvas));
  canvas2.setLookAndFeel(new SwingLookAndFeel());
  manager.addGlimpseCanvas(canvas2);
  createFrame(""String_Node_Str"",canvas);
  createFrame(""String_Node_Str"",canvas2);
  Runtime.getRuntime().addShutdownHook(new Thread(){
    @Override public void run(){
      offscreenCanvas.dispose();
    }
  }
);
}",0.977886977886978
11569,"public static void main(String[] args) throws Exception {
  GLContext context=createPixelBuffer(1,1).getContext();
  final SwingGlimpseCanvas canvas=new SwingGlimpseCanvas(context);
  canvas.addLayout(new ScreenCaptureExample().getLayout(context));
  canvas.setLookAndFeel(new SwingLookAndFeel());
  final JFrame frame=new JFrame(""String_Node_Str"");
  frame.addWindowListener(new WindowAdapter(){
    @Override public void windowClosing(    WindowEvent e){
      canvas.dispose();
      frame.remove(canvas);
    }
  }
);
  frame.add(canvas);
  frame.pack();
  frame.setSize(800,800);
  frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
  frame.setVisible(true);
}","public static void main(String[] args) throws Exception {
  GLContext context=createPixelBuffer(1,1).getContext();
  final NewtGlimpseCanvas canvas=new NewtGlimpseCanvas(context);
  canvas.addLayout(new ScreenCaptureExample().getLayout(context));
  canvas.setLookAndFeel(new SwingLookAndFeel());
  final JFrame frame=new JFrame(""String_Node_Str"");
  frame.addWindowListener(new WindowAdapter(){
    @Override public void windowClosing(    WindowEvent e){
      canvas.dispose();
      frame.remove(canvas);
    }
  }
);
  frame.add(canvas);
  frame.pack();
  frame.setSize(800,800);
  frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
  frame.setVisible(true);
}",0.9865067466266868
11570,"@Override public StackedTimePlot2D getLayout(){
  StackedTimePlot2D plot=createPlot();
  Epoch epoch=plot.getEpoch();
  TimeStamp selectionMaxTime=epoch.getTimeStamp();
  TimeStamp selectionMinTime=selectionMaxTime.subtract(Time.fromHours(3));
  TimeStamp axisMaxTime=selectionMaxTime.add(Time.fromHours(1));
  TimeStamp axisMinTime=selectionMaxTime.subtract(Time.fromHours(20));
  plot.setTimeSelection(selectionMinTime,selectionMaxTime);
  plot.setTimeAxisBounds(axisMinTime,axisMaxTime);
  plot.setPlotSpacing(2);
  plot.setBorderSize(4);
  TimePlotInfo plot1=plot.createTimePlot(""String_Node_Str"");
  TimePlotInfo plot2=plot.createTimePlot(""String_Node_Str"");
  plot1.setLabelText(""String_Node_Str"");
  plot2.setLabelText(""String_Node_Str"");
  plot.setLabelSize(30);
  plot.showLabels(true);
  plot1.getLabelPainter().setHorizontalLabels(false);
  plot2.getLabelPainter().setHorizontalLabels(false);
  setChartData(plot1,epoch,axisMinTime,axisMaxTime);
  setChartData(plot2,epoch,axisMinTime,axisMaxTime);
  addMouseListener(epoch,plot1);
  addMouseListener(epoch,plot2);
  return plot;
}","@Override public StackedTimePlot2D getLayout(){
  StackedTimePlot2D plot=createPlot();
  Epoch epoch=plot.getEpoch();
  TimeStamp selectionMaxTime=epoch.getTimeStamp();
  TimeStamp selectionMinTime=selectionMaxTime.subtract(Time.fromHours(3));
  TimeStamp axisMaxTime=selectionMaxTime.add(Time.fromHours(1));
  TimeStamp axisMinTime=selectionMaxTime.subtract(Time.fromHours(20));
  plot.setTimeSelection(selectionMinTime,selectionMaxTime);
  plot.setTimeAxisBounds(axisMinTime,axisMaxTime);
  plot.setPlotSpacing(2);
  plot.setBorderSize(4);
  TimePlotInfo plot1=plot.createTimePlot(""String_Node_Str"");
  TimePlotInfo plot2=plot.createTimePlot(""String_Node_Str"");
  plot1.getLabelPainter().setHorizontalLabels(false);
  plot2.getLabelPainter().setHorizontalLabels(false);
  setChartData(plot1,epoch,axisMinTime,axisMaxTime);
  setChartData(plot2,epoch,axisMinTime,axisMaxTime);
  addMouseListener(epoch,plot1);
  addMouseListener(epoch,plot2);
  return plot;
}",0.935672514619883
11571,"@Override protected void setRowColumnConstraints(){
  if (indentSubplots) {
    int maxLevel=setIndentLevel0();
    setRowColumnConstraints(maxLevel,labelLayoutSize);
  }
 else {
    resetIndentLevel0(0);
    setRowColumnConstraints(0,labelLayoutSize);
  }
}","@Override protected void setRowColumnConstraints(){
  if (indentSubplots) {
    int maxLevel=setIndentLevel0();
    setRowColumnConstraints(maxLevel,getLabelSize());
  }
 else {
    resetIndentLevel0(0);
    setRowColumnConstraints(0,getLabelSize());
  }
}",0.9494163424124512
11572,"protected void initializeTimePlot(){
  TaggedAxis1D timeAxis=getTimeAxis();
  this.addTimeTags(getTimeAxis());
  this.minTag=timeAxis.getTag(MIN_TIME);
  this.maxTag=timeAxis.getTag(MAX_TIME);
  this.currentTag=timeAxis.getTag(CURRENT_TIME);
  PlotInfo info=createPlot(TIMELINE);
  this.timelineInfo=new PlotInfoWrapper(info){
    protected boolean doAnyOtherPlotsGrow(){
      for (      PlotInfo plot : getAllPlots()) {
        if (this != plot && plot.isGrow())         return true;
      }
      return false;
    }
    @Override public void updateLayout(    int index){
      setGrow(!doAnyOtherPlotsGrow());
      super.updateLayout(index);
      if (timeLayout == null)       return;
      if (isTimeAxisHorizontal()) {
        timeLayout.setLayoutData(String.format(""String_Node_Str"",labelLayoutSize));
      }
 else {
        timeLayout.setLayoutData(String.format(""String_Node_Str"",labelLayoutSize));
      }
    }
  }
;
  this.stackedPlots.put(this.timelineInfo.getId(),this.timelineInfo);
  this.timelineInfo.setPlotSpacing(0);
  if (isTimeAxisHorizontal()) {
    this.timelineInfo.setSize(45);
    this.timelineInfo.setOrder(Integer.MAX_VALUE);
    this.timeLayout=new GlimpseAxisLayoutX(this.timelineInfo.getLayout());
    this.timeLayout.setEventConsumer(false);
    this.labelLayoutSize=30;
  }
 else {
    this.timelineInfo.setSize(60);
    this.timelineInfo.setOrder(Integer.MIN_VALUE);
    this.timeLayout=new GlimpseAxisLayoutY(this.timelineInfo.getLayout());
    this.timeLayout.setEventConsumer(false);
    this.labelLayoutSize=30;
  }
  this.timelineInfo.getLayout().setEventConsumer(false);
  this.timeAxisPainter=createTimeAxisPainter();
  this.timeAxisPainter.setFont(getDefaultPlain(12),false);
  this.timeAxisPainter.showCurrentTimeLabel(false);
  this.timeAxisPainter.setCurrentTimeTickColor(GlimpseColor.getGreen());
  this.setBorderSize(0);
  this.timeAxisDelegate=new DelegatePainter();
  this.timeAxisDelegate.addPainter(this.timeAxisPainter);
  this.timeLayout.addPainter(this.timeAxisDelegate);
  this.timeUnitsPainter=new SimpleTextPainter();
  this.timeUnitsPainter.setHorizontalPosition(HorizontalPosition.Right);
  this.timeUnitsPainter.setVerticalPosition(VerticalPosition.Bottom);
  this.timeUnitsPainter.setColor(GlimpseColor.getBlack());
  this.timeUnitsPainter.setFont(getDefaultBold(12));
  this.timeUnitsPainter.setText(""String_Node_Str"");
  this.timeUnitsPainter.setBackgroundColor(GlimpseColor.getYellow());
  this.timeUnitsPainter.setPaintBackground(true);
  this.timeAxisBorderPainter=new BorderPainter();
  this.timeAxisBorderPainter.setVisible(false);
  this.timeLayout.addPainter(this.timeUnitsPainter);
  this.timeLayout.addPainter(this.timeAxisBorderPainter);
  this.validate();
}","protected void initializeTimePlot(){
  TaggedAxis1D timeAxis=getTimeAxis();
  this.addTimeTags(getTimeAxis());
  this.minTag=timeAxis.getTag(MIN_TIME);
  this.maxTag=timeAxis.getTag(MAX_TIME);
  this.currentTag=timeAxis.getTag(CURRENT_TIME);
  PlotInfo info=createPlot(TIMELINE);
  this.timelineInfo=new PlotInfoWrapper(info){
    protected boolean doAnyOtherPlotsGrow(){
      for (      PlotInfo plot : getAllPlots()) {
        if (this != plot && plot.isGrow())         return true;
      }
      return false;
    }
    @Override public void updateLayout(    int index){
      setGrow(!doAnyOtherPlotsGrow());
      super.updateLayout(index);
      if (timeLayout == null)       return;
      if (isTimeAxisHorizontal()) {
        timeLayout.setLayoutData(String.format(""String_Node_Str"",getLabelSize()));
      }
 else {
        timeLayout.setLayoutData(String.format(""String_Node_Str"",getLabelSize()));
      }
    }
  }
;
  this.stackedPlots.put(this.timelineInfo.getId(),this.timelineInfo);
  this.timelineInfo.setPlotSpacing(0);
  if (isTimeAxisHorizontal()) {
    this.timelineInfo.setSize(45);
    this.timelineInfo.setOrder(Integer.MAX_VALUE);
    this.timeLayout=new GlimpseAxisLayoutX(this.timelineInfo.getLayout());
    this.timeLayout.setEventConsumer(false);
    this.labelLayoutSize=30;
  }
 else {
    this.timelineInfo.setSize(60);
    this.timelineInfo.setOrder(Integer.MIN_VALUE);
    this.timeLayout=new GlimpseAxisLayoutY(this.timelineInfo.getLayout());
    this.timeLayout.setEventConsumer(false);
    this.labelLayoutSize=30;
  }
  this.timelineInfo.getLayout().setEventConsumer(false);
  this.timeAxisPainter=createTimeAxisPainter();
  this.timeAxisPainter.setFont(getDefaultPlain(12),false);
  this.timeAxisPainter.showCurrentTimeLabel(false);
  this.timeAxisPainter.setCurrentTimeTickColor(GlimpseColor.getGreen());
  this.setBorderSize(0);
  this.timeAxisDelegate=new DelegatePainter();
  this.timeAxisDelegate.addPainter(this.timeAxisPainter);
  this.timeLayout.addPainter(this.timeAxisDelegate);
  this.timeUnitsPainter=new SimpleTextPainter();
  this.timeUnitsPainter.setHorizontalPosition(HorizontalPosition.Right);
  this.timeUnitsPainter.setVerticalPosition(VerticalPosition.Bottom);
  this.timeUnitsPainter.setColor(GlimpseColor.getBlack());
  this.timeUnitsPainter.setFont(getDefaultBold(12));
  this.timeUnitsPainter.setText(""String_Node_Str"");
  this.timeUnitsPainter.setBackgroundColor(GlimpseColor.getYellow());
  this.timeUnitsPainter.setPaintBackground(true);
  this.timeAxisBorderPainter=new BorderPainter();
  this.timeAxisBorderPainter.setVisible(false);
  this.timeLayout.addPainter(this.timeUnitsPainter);
  this.timeLayout.addPainter(this.timeAxisBorderPainter);
  this.validate();
}",0.995245062179956
11573,"@Override public void updateLayout(int index){
  setGrow(!doAnyOtherPlotsGrow());
  super.updateLayout(index);
  if (timeLayout == null)   return;
  if (isTimeAxisHorizontal()) {
    timeLayout.setLayoutData(String.format(""String_Node_Str"",labelLayoutSize));
  }
 else {
    timeLayout.setLayoutData(String.format(""String_Node_Str"",labelLayoutSize));
  }
}","@Override public void updateLayout(int index){
  setGrow(!doAnyOtherPlotsGrow());
  super.updateLayout(index);
  if (timeLayout == null)   return;
  if (isTimeAxisHorizontal()) {
    timeLayout.setLayoutData(String.format(""String_Node_Str"",getLabelSize()));
  }
 else {
    timeLayout.setLayoutData(String.format(""String_Node_Str"",getLabelSize()));
  }
}",0.9633802816901408
11574,"@Override protected int getOverlayLayoutOffsetX(){
  return orient == VERTICAL ? labelLayoutSize : 0;
}","@Override protected int getOverlayLayoutOffsetX(){
  return orient == VERTICAL ? getLabelSize() : 0;
}",0.9365853658536586
11575,"@Override protected int getOverlayLayoutOffsetY2(){
  return orient == VERTICAL ? 0 : labelLayoutSize;
}","@Override protected int getOverlayLayoutOffsetY2(){
  return orient == VERTICAL ? 0 : getLabelSize();
}",0.9371980676328504
11576,"public int getLabelSize(){
  return this.labelLayoutSize;
}","public int getLabelSize(){
  return showLabelLayout ? this.labelLayoutSize : 0;
}",0.8428571428571429
11577,"public static GlimpseMouseEvent fromMouseEvent(MouseEvent event,GlimpseTargetStack stack,int x,int y){
  int wheelIncrement=(int)-event.getRotation()[1];
  int clickCount=event.getClickCount();
  EnumSet<MouseButton> buttons=getMouseButtons(event);
  EnumSet<ModifierKey> modifiers=getModifierKeys(event);
  return new GlimpseMouseEvent(stack,modifiers,buttons,x,y,wheelIncrement,clickCount);
}","public static GlimpseMouseEvent fromMouseEvent(MouseEvent event,GlimpseTargetStack stack,int x,int y){
  System.out.println(Arrays.toString(event.getRotation()));
  int wheelIncrement=getWheelIncrement(event);
  int clickCount=event.getClickCount();
  EnumSet<MouseButton> buttons=getMouseButtons(event);
  EnumSet<ModifierKey> modifiers=getModifierKeys(event);
  return new GlimpseMouseEvent(stack,modifiers,buttons,x,y,wheelIncrement,clickCount);
}",0.8672985781990521
11578,"protected void updateSelectedTime(){
  if (timeAttributeBuffer != null) {
    startIndex=binarySearch0(timeAttributeBuffer,0,timeAttributeBuffer.limit(),startTime);
    if (startIndex < 0)     startIndex=-startIndex + 1;
    endIndex=binarySearch0(timeAttributeBuffer,0,timeAttributeBuffer.limit(),endTime);
    if (endIndex < 0)     endIndex=-endIndex + 1;
  }
 else   if (positionBuffer != null) {
    startIndex=0;
    endIndex=positionBuffer.getNumVertices();
  }
}","protected void updateSelectedTime(){
  if (timeAttributeBuffer != null) {
    startIndex=binarySearch0(timeAttributeBuffer,0,timeAttributeBuffer.limit(),startTime);
    if (startIndex < 0)     startIndex=-(startIndex + 1);
    endIndex=binarySearch0(timeAttributeBuffer,0,timeAttributeBuffer.limit(),endTime);
    if (endIndex < 0)     endIndex=-(endIndex + 1);
  }
 else   if (positionBuffer != null) {
    startIndex=0;
    endIndex=positionBuffer.getNumVertices();
  }
}",0.9957537154989384
11579,"protected Node fromConfigNode(ConfigNode cNode,Rectangle bounds,Map<String,ConfigLeaf> leavesById_OUT){
  if (cNode instanceof ConfigSplit) {
    ConfigSplit cSplit=(ConfigSplit)cNode;
    int divPixels=splitPane.getDividerSize();
    int totalDivs=max(0,cSplit.childNodes.size() - 1);
    int totalContentPixels=(cSplit.isRow ? bounds.width : bounds.height) - totalDivs * divPixels;
    double totalContent=0;
    for (    ConfigNode cChild : cSplit.childNodes) {
      totalContent+=cChild.extent;
    }
    int divsSoFar=0;
    int startPixel=0;
    double contentSoFar=0;
    List<Node> children=newArrayList();
    for (    ConfigNode cChild : cSplit.childNodes) {
      if (!children.isEmpty()) {
        int xDiv=(cSplit.isRow ? startPixel : 0);
        int yDiv=(cSplit.isRow ? 0 : startPixel);
        int wDiv=(cSplit.isRow ? divPixels : bounds.width);
        int hDiv=(cSplit.isRow ? bounds.height : divPixels);
        Divider divider=new Divider();
        divider.setBounds(new Rectangle(xDiv,yDiv,wDiv,hDiv));
        children.add(divider);
        startPixel+=divPixels;
        divsSoFar++;
      }
      int endPixel=iround(((contentSoFar + cChild.extent) / totalContent) * totalContentPixels) + divsSoFar * divPixels;
      int xChild=(cSplit.isRow ? startPixel : 0);
      int yChild=(cSplit.isRow ? 0 : startPixel);
      int wChild=(cSplit.isRow ? endPixel - startPixel : bounds.width);
      int hChild=(cSplit.isRow ? bounds.height : endPixel - startPixel);
      Node child=fromConfigNode(cChild,new Rectangle(xChild,yChild,wChild,hChild),leavesById_OUT);
      children.add(child);
      startPixel=endPixel;
      contentSoFar+=cChild.extent;
    }
    Split split=(cSplit.isRow ? new RowSplit() : new ColSplit());
    split.setChildren(children);
    split.setBounds(bounds);
    return split;
  }
 else   if (cNode instanceof ConfigLeaf) {
    ConfigLeaf cLeaf=(ConfigLeaf)cNode;
    String leafId=nextLeafId();
    leavesById_OUT.put(leafId,cLeaf);
    Leaf leaf=new Leaf(leafId);
    leaf.setBounds(bounds);
    return leaf;
  }
 else {
    throw new RuntimeException(""String_Node_Str"" + cNode.getClass().getName());
  }
}","protected Node fromConfigNode(ConfigNode cNode,Rectangle bounds,Map<String,ConfigLeaf> leavesById_OUT){
  if (cNode instanceof ConfigSplit) {
    ConfigSplit cSplit=(ConfigSplit)cNode;
    int divPixels=splitPane.getDividerSize();
    int totalDivs=max(0,cSplit.childNodes.size() - 1);
    int totalContentPixels=(cSplit.isRow ? bounds.width : bounds.height) - totalDivs * divPixels;
    double totalContent=0;
    for (    ConfigNode cChild : cSplit.childNodes) {
      totalContent+=cChild.extent;
    }
    int divsSoFar=0;
    int startPixel=0;
    double contentSoFar=0;
    List<Node> children=newArrayList();
    for (    ConfigNode cChild : cSplit.childNodes) {
      if (!children.isEmpty()) {
        int xDiv=(cSplit.isRow ? startPixel : 0) + bounds.x;
        int yDiv=(cSplit.isRow ? 0 : startPixel) + bounds.y;
        int wDiv=(cSplit.isRow ? divPixels : bounds.width);
        int hDiv=(cSplit.isRow ? bounds.height : divPixels);
        Divider divider=new Divider();
        divider.setBounds(new Rectangle(xDiv,yDiv,wDiv,hDiv));
        children.add(divider);
        startPixel+=divPixels;
        divsSoFar++;
      }
      int endPixel=iround(((contentSoFar + cChild.extent) / totalContent) * totalContentPixels) + divsSoFar * divPixels;
      int xChild=(cSplit.isRow ? startPixel : 0) + bounds.x;
      int yChild=(cSplit.isRow ? 0 : startPixel) + bounds.y;
      int wChild=(cSplit.isRow ? endPixel - startPixel : bounds.width);
      int hChild=(cSplit.isRow ? bounds.height : endPixel - startPixel);
      Node child=fromConfigNode(cChild,new Rectangle(xChild,yChild,wChild,hChild),leavesById_OUT);
      children.add(child);
      startPixel=endPixel;
      contentSoFar+=cChild.extent;
    }
    Split split=(cSplit.isRow ? new RowSplit() : new ColSplit());
    split.setChildren(children);
    split.setBounds(bounds);
    return split;
  }
 else   if (cNode instanceof ConfigLeaf) {
    ConfigLeaf cLeaf=(ConfigLeaf)cNode;
    String leafId=nextLeafId();
    leavesById_OUT.put(leafId,cLeaf);
    Leaf leaf=new Leaf(leafId);
    leaf.setBounds(bounds);
    return leaf;
  }
 else {
    throw new RuntimeException(""String_Node_Str"" + cNode.getClass().getName());
  }
}",0.9898897058823528
11580,"public void select(Axis1D axis,boolean horizontal,float posX,float posY){
  if (!allowSelect)   return;
  if (axis.isSelectionLocked())   return;
  double posPixels=getDim(horizontal,posX,posY);
  double posData=posPixels / axis.getPixelsPerValue();
  axis.setSelectionCenter(posData);
}","public void select(Axis1D axis,boolean horizontal,float posX,float posY){
  if (!allowSelect)   return;
  double posPixels=getDim(horizontal,posX,posY);
  double posData=axis.screenPixelToValue(posPixels);
  axis.setMouseValue(posData);
  if (!axis.isSelectionLocked()) {
    axis.setSelectionCenter(posData);
  }
}",0.7275747508305648
11581,"@Override public void panDetected(GlimpsePanGestureEvent event){
  GlimpseAxisLayout1D layout=getAxisLayout(event.getTargetStack());
  if (layout == null)   return;
  Axis1D targetAxis=layout.getAxis(event.getTargetStack());
  pan(targetAxis,layout.isHorizontal(),event.getDx(),event.getDy());
  this.validateAxes(targetAxis);
}","@Override public void panDetected(GlimpsePanGestureEvent event){
  GlimpseAxisLayout1D layout=getAxisLayout(event.getTargetStack());
  if (layout == null)   return;
  Axis1D targetAxis=layout.getAxis(event.getTargetStack());
  pan(targetAxis,layout.isHorizontal(),event.getDx(),event.getDy());
  validateAxes(targetAxis);
}",0.9923195084485408
11582,"@Override public void pinchDetected(GlimpsePinchGestureEvent event){
  GlimpseAxisLayout1D layout=getAxisLayout(event.getTargetStack());
  if (layout == null)   return;
  Axis1D targetAxis=layout.getAxis(event.getTargetStack());
  zoom(targetAxis,layout.isHorizontal(),event.getX(),event.getY(),event.getScale());
  this.validateAxes(targetAxis);
}","@Override public void pinchDetected(GlimpsePinchGestureEvent event){
  GlimpseAxisLayout1D layout=getAxisLayout(event.getTargetStack());
  if (layout == null)   return;
  Axis1D targetAxis=layout.getAxis(event.getTargetStack());
  zoom(targetAxis,layout.isHorizontal(),event.getX(),event.getY(),event.getScale());
  validateAxes(targetAxis);
}",0.9927641099855282
11583,"@Override public void tapDetected(GlimpseTapGestureEvent event){
  GlimpseAxisLayout1D layout=getAxisLayout(event.getTargetStack());
  if (layout == null)   return;
  Axis1D targetAxis=layout.getAxis(event.getTargetStack());
  select(targetAxis,layout.isHorizontal(),event.getX(),event.getY());
  this.validateAxes(targetAxis);
}","@Override public void tapDetected(GlimpseTapGestureEvent event){
  GlimpseAxisLayout1D layout=getAxisLayout(event.getTargetStack());
  if (layout == null)   return;
  Axis1D targetAxis=layout.getAxis(event.getTargetStack());
  select(targetAxis,layout.isHorizontal(),event.getX(),event.getY());
  validateAxes(targetAxis);
}",0.9923430321592648
11584,"protected Touchable getTouchTarget(GlimpseTargetStack stack){
  if (stack == null) {
    return null;
  }
  GlimpseTarget target=stack.getTarget();
  if (target == null || !(target instanceof Touchable)) {
    return null;
  }
  Touchable touchTarget=(Touchable)target;
  return touchTarget;
}","protected Touchable getTouchTarget(GlimpseTargetStack stack){
  if (stack == null) {
    return null;
  }
  GlimpseTarget target=stack.getTarget();
  if (target instanceof Touchable) {
    return (Touchable)target;
  }
  return null;
}",0.7840909090909091
11585,"public int getDirection(){
  return direction;
}","/** 
 * The angle of the swipe, in MATH RADIANS.
 */
public int getDirection(){
  return direction;
}",0.6442953020134228
11586,"/** 
 * Links two WorldWindows so that the eye position of the master window is copied to the eye position of the slave. Does not set up the reverse link. However, the caller may call again with the arguments reversed to have both windows reflect each others position.
 * @param master
 * @param slave
 */
public static void linkWorldWindToWorldWind(final WorldWindow master,final WorldWindow slave){
  master.addPositionListener(new PositionListener(){
    @Override public void moved(    PositionEvent event){
      Position pos=master.getView().getCurrentEyePosition();
      slave.getView().setEyePosition(pos);
    }
  }
);
}","/** 
 * Links two WorldWindows so that the eye position of the master window is copied to the eye position of the slave. Does not set up the reverse link. However, the caller may call again with the arguments reversed to have both windows reflect each others position.
 * @param master
 * @param slave
 */
public static void linkWorldWindToWorldWind(final WorldWindow master,final WorldWindow slave){
  master.addPositionListener(new PositionListener(){
    @Override public void moved(    PositionEvent event){
      Position pos=master.getView().getCurrentEyePosition();
      slave.getView().setEyePosition(pos);
      slave.redraw();
    }
  }
);
}",0.982839313572543
11587,"protected void pruneIndex(int updateIndex){
  lock.lock();
  try {
    if (!indexEnabled) {
      xyIndex=null;
      return;
    }
    if (xyIndex == null || updateIndex > getNumVertices()) {
      xyIndex=null;
    }
 else {
      for (int i=updateIndex; i < getNumVertices(); i++) {
        xyIndex.remove(i);
      }
    }
  }
  finally {
    lock.unlock();
  }
}","protected void pruneIndex(int updateIndex){
  lock.lock();
  try {
    if (!indexEnabled) {
      xyIndex=null;
      return;
    }
    if (xyIndex == null || updateIndex == 0) {
      xyIndex=null;
    }
 else {
      for (int i=updateIndex; i < getNumVertices(); i++) {
        xyIndex.remove(i);
      }
    }
  }
  finally {
    lock.unlock();
  }
}",0.7722222222222223
11588,"protected void updateIndex(int updateIndex){
  lock.lock();
  try {
    if (!indexEnabled) {
      xyIndex=null;
      return;
    }
    if (xyIndex == null) {
      xyIndex=new QuadTreeInts(MAX_BUCKET_SIZE){
        @Override protected final float x(        int i){
          return data.asFloatBuffer().get(i * 2);
        }
        @Override protected final float y(        int i){
          return data.asFloatBuffer().get(i * 2 + 1);
        }
      }
;
      for (int i=0; i < getNumVertices(); i++) {
        xyIndex.add(i);
      }
    }
 else {
      for (int i=updateIndex; i < getNumVertices(); i++) {
        xyIndex.add(i);
      }
    }
  }
  finally {
    lock.unlock();
  }
}","protected void updateIndex(int updateIndex){
  lock.lock();
  try {
    if (!indexEnabled) {
      xyIndex=null;
      return;
    }
    if (xyIndex == null) {
      xyIndex=new QuadTreeInts(MAX_BUCKET_SIZE){
        @Override public final float x(        int i){
          return data.asFloatBuffer().get(i * 2);
        }
        @Override public final float y(        int i){
          return data.asFloatBuffer().get(i * 2 + 1);
        }
      }
;
      for (int i=0; i < getNumVertices(); i++) {
        xyIndex.add(i);
      }
    }
 else {
      for (int i=updateIndex; i < getNumVertices(); i++) {
        xyIndex.add(i);
      }
    }
  }
  finally {
    lock.unlock();
  }
}",0.9811046511627908
11589,"@Override protected final float x(int i){
  return data.asFloatBuffer().get(i * 2);
}","@Override public final float x(int i){
  return data.asFloatBuffer().get(i * 2);
}",0.934131736526946
11590,"@Override protected final float y(int i){
  return data.asFloatBuffer().get(i * 2 + 1);
}","@Override public final float y(int i){
  return data.asFloatBuffer().get(i * 2 + 1);
}",0.9371428571428572
11591,"protected void createIndex(){
  lock.lock();
  try {
    if (!indexEnabled) {
      xyIndex=null;
      return;
    }
    xyIndex=new QuadTreeInts(MAX_BUCKET_SIZE){
      @Override protected final float x(      int i){
        return data.asFloatBuffer().get(i * 2);
      }
      @Override protected final float y(      int i){
        return data.asFloatBuffer().get(i * 2 + 1);
      }
    }
;
    for (int i=0; i < getNumVertices(); i++) {
      xyIndex.add(i);
    }
  }
  finally {
    lock.unlock();
  }
}","protected void createIndex(){
  lock.lock();
  try {
    if (!indexEnabled) {
      xyIndex=null;
      return;
    }
    xyIndex=new QuadTreeInts(MAX_BUCKET_SIZE){
      @Override public final float x(      int i){
        return data.asFloatBuffer().get(i * 2);
      }
      @Override public final float y(      int i){
        return data.asFloatBuffer().get(i * 2 + 1);
      }
    }
;
    for (int i=0; i < getNumVertices(); i++) {
      xyIndex.add(i);
    }
  }
  finally {
    lock.unlock();
  }
}",0.974459724950884
11592,"public static List<LatLon> getCorners(DrawContext dc){
  View view=dc.getView();
  Rectangle viewport=view.getViewport();
  List<LatLon> corners=new ArrayList<LatLon>(4);
  corners.add(view.computePositionFromScreenPoint(viewport.getMinX(),viewport.getMinY()));
  corners.add(view.computePositionFromScreenPoint(viewport.getMinX(),viewport.getMaxY()));
  corners.add(view.computePositionFromScreenPoint(viewport.getMaxX(),viewport.getMaxY()));
  corners.add(view.computePositionFromScreenPoint(viewport.getMaxX(),viewport.getMinY()));
  return corners;
}","public static List<LatLon> getCorners(LatLonBounds bounds){
  List<LatLon> corners=new ArrayList<LatLon>();
  corners.add(LatLon.fromDegrees(bounds.minLat,bounds.minLon));
  corners.add(LatLon.fromDegrees(bounds.minLat,bounds.maxLon));
  corners.add(LatLon.fromDegrees(bounds.maxLat,bounds.maxLon));
  corners.add(LatLon.fromDegrees(bounds.maxLat,bounds.minLon));
  return corners;
}",0.1387406616862326
11593,"protected void updateGeometry(DrawContext dc){
  corners=maxCorners;
  bounds=maxBounds;
  List<LatLon> screenCorners=getCorners0(dc);
  if (isValid(screenCorners)) {
    LatLonBounds screenBounds=bufferCorners(getCorners(screenCorners),0.5);
    bounds=getIntersectedCorners(maxBounds,screenBounds);
    corners=getCorners(bounds);
  }
  if (tile != null) {
    setAxes(axes,bounds,projection);
    tile.setCorners(corners);
  }
}","protected void updateGeometry(List<LatLon> screenCorners){
  LatLonBounds screenBounds=bufferCorners(getCorners(screenCorners),0.5);
  bounds=getIntersectedCorners(maxBounds,screenBounds);
  corners=getCorners(bounds);
  updateTile();
}",0.5967016491754122
11594,"public DatumSphereWgs84(){
  super(avgGeodesicRadius);
}","public DatumSphereWgs84(){
  super(Constants.avgGeodesicRadius);
}",0.918032786885246
11595,"public DatumWgs84(){
  super(equatorialRadius,flattening);
}","public DatumWgs84(){
  super(Constants.equatorialRadius,Constants.flattening);
}",0.8571428571428571
11596,"@Override public StackedTimePlot2D getLayout(){
  final CollapsibleTimePlot2D plot=(CollapsibleTimePlot2D)super.getLayout();
  plot.setLabelSize(120);
  for (  TimePlotInfo row : plot.getAllTimePlots()) {
    GroupInfo group=plot.createGroup(String.format(""String_Node_Str"",row.getId()),row);
    row.getLabelPainter().setText(""String_Node_Str"");
    group.setLabelText(""String_Node_Str"");
    setPlotLookAndFeel(row);
  }
  final EventPlotInfo events1=plot.createEventPlot(""String_Node_Str"");
  EventPlotInfo events2=plot.createEventPlot(""String_Node_Str"");
  EventPlotInfo events3=plot.createEventPlot(""String_Node_Str"");
  events1.setLabelText(""String_Node_Str"");
  events2.setLabelText(""String_Node_Str"");
  events3.setLabelText(""String_Node_Str"");
  setPlotLookAndFeel(events1);
  setPlotLookAndFeel(events2);
  setPlotLookAndFeel(events3);
  events1.getLabelPainter().setVerticalPosition(VerticalPosition.Center);
  events2.getLabelPainter().setVerticalPosition(VerticalPosition.Center);
  events3.getLabelPainter().setVerticalPosition(VerticalPosition.Center);
  GroupInfo group=plot.createGroup(""String_Node_Str"",events1,events2,events3);
  group.setLabelText(""String_Node_Str"");
  group.setOrder(100);
  events1.setOrder(2);
  events2.setOrder(3);
  events3.setOrder(4);
  events1.setBackgroundColor(GlimpseColor.getGreen(0.6f));
  events1.setBorderColor(GlimpseColor.getGreen());
  events3.setBackgroundColor(GlimpseColor.getCyan(0.6f));
  events3.setBorderColor(GlimpseColor.getCyan());
  Epoch e=plot.getEpoch();
  TimeStamp t0=e.toTimeStamp(0);
  Event e0=events1.addEvent(""String_Node_Str"",t0,t0.add(Time.fromMinutes(20)));
  e0.setShowBackground(false);
  events1.addEvent(""String_Node_Str"",t0.add(Time.fromMinutes(30)),t0.add(Time.fromMinutes(200)));
  Event e1=events1.addEvent(""String_Node_Str"",t0.add(Time.fromMinutes(290)),t0.add(Time.fromMinutes(320)));
  e1.setBackgroundColor(GlimpseColor.getRed(0.6f));
  e1.setBorderColor(GlimpseColor.getRed());
  Event e2=events1.addEvent(""String_Node_Str"",t0.add(Time.fromMinutes(-200)),t0.add(Time.fromMinutes(100)));
  Event e3=events1.addEvent(""String_Node_Str"",t0.add(Time.fromMinutes(100)),t0.add(Time.fromMinutes(300)));
  Event e4=events1.addEvent(""String_Node_Str"",t0.subtract(Time.fromMinutes(40)));
  events2.addEvent(""String_Node_Str"",t0.add(Time.fromMinutes(-250)),t0.add(Time.fromMinutes(-240)));
  events2.addEvent(""String_Node_Str"",t0.add(Time.fromMinutes(-220)),t0.add(Time.fromMinutes(-200)));
  events2.addEvent(""String_Node_Str"",t0.add(Time.fromMinutes(-170)),t0.add(Time.fromMinutes(-100)));
  events1.setAggregateNearbyEvents(true);
  events2.setAggregateNearbyEvents(true);
  e0.setEndTimeMoveable(false);
  e1.setResizeable(false);
  e2.setMinTimeSpan(Time.fromMinutes(100));
  e3.setMaxTimeSpan(Time.fromMinutes(500));
  events1.getEventSelectionHandler().setClearSelectionOnClick(true);
  e2.setSelectable(false);
  e2.setFixedRow(2);
  TextureAtlas atlas=plot.getTextureAtlas();
  try {
    atlas.loadImage(""String_Node_Str"",ImageIO.read(StreamOpener.fileThenResource.openForRead(""String_Node_Str"")));
    atlas.loadImage(""String_Node_Str"",ImageIO.read(StreamOpener.fileThenResource.openForRead(""String_Node_Str"")));
    atlas.loadImage(""String_Node_Str"",ImageIO.read(StreamOpener.fileThenResource.openForRead(""String_Node_Str"")));
    atlas.loadImage(""String_Node_Str"",ImageIO.read(StreamOpener.fileThenResource.openForRead(""String_Node_Str"")));
  }
 catch (  IOException ex) {
    logWarning(logger,""String_Node_Str"",ex);
  }
  e1.setIconId(""String_Node_Str"");
  e2.setIconId(""String_Node_Str"");
  e3.setIconId(""String_Node_Str"");
  e4.setIconId(""String_Node_Str"");
  plot.getTooltipPainter().setFixedWidth(300);
  e0.setToolTipText(""String_Node_Str"");
  e1.setToolTipText(""String_Node_Str"");
  e2.setToolTipText(""String_Node_Str"");
  e3.setToolTipText(""String_Node_Str"");
  e4.setToolTipText(""String_Node_Str"");
  events1.addEventPlotListener(new EventPlotListener(){
    @Override public void eventsHovered(    GlimpseMouseEvent e,    Set<EventSelection> events,    TimeStamp time){
      if (!events.isEmpty())       logInfo(logger,""String_Node_Str"",events,time);
    }
    @Override public void eventsClicked(    GlimpseMouseEvent e,    Set<EventSelection> events,    TimeStamp time){
      if (!events.isEmpty())       logInfo(logger,""String_Node_Str"",events,time);
    }
    @Override public void eventsExited(    GlimpseMouseEvent e,    Set<EventSelection> events,    TimeStamp time){
      if (!events.isEmpty())       logInfo(logger,""String_Node_Str"",events,time);
    }
    @Override public void eventsEntered(    GlimpseMouseEvent e,    Set<EventSelection> events,    TimeStamp time){
      if (!events.isEmpty())       logInfo(logger,""String_Node_Str"",events,time);
    }
    @Override public void eventUpdated(    Event event){
      logInfo(logger,""String_Node_Str"",event);
    }
  }
);
  plot.getEventSelectionHander().addEventSelectionListener(new EventSelectionListener(){
    @Override public void eventsSelected(    Set<Event> selectedEvents,    Set<Event> deselectedEvents){
      logInfo(logger,""String_Node_Str"",selectedEvents,deselectedEvents);
    }
  }
);
  events1.getEventSelectionHandler().setSelectedEventBorderThickness(3.0f);
  plot.setTimeAxisMouseListener(new TaggedAxisMouseListener1D());
  plot.getSelectedTimePainter().setShowLockedStatus(false);
  plot.getTimeAxis().addAxisListener(new TaggedAxisListener1D(){
    @Override public void tagsUpdated(    TaggedAxis1D axis){
      Tag s=plot.getTimeSelectionTag();
      Tag m=plot.getTimeSelectionMaxTag();
      if (s != null && m != null && s.getValue() != m.getValue()) {
        s.setValue(m.getValue());
        axis.validateTags();
      }
    }
  }
);
  return plot;
}","@Override public StackedTimePlot2D getLayout(){
  final CollapsibleTimePlot2D plot=(CollapsibleTimePlot2D)super.getLayout();
  plot.setLabelSize(120);
  for (  TimePlotInfo row : plot.getAllTimePlots()) {
    GroupInfo group=plot.createGroup(String.format(""String_Node_Str"",row.getId()),row);
    row.getLabelPainter().setText(""String_Node_Str"");
    group.setLabelText(""String_Node_Str"");
    setPlotLookAndFeel(row);
  }
  final EventPlotInfo events1=plot.createEventPlot(""String_Node_Str"");
  EventPlotInfo events2=plot.createEventPlot(""String_Node_Str"");
  EventPlotInfo events3=plot.createEventPlot(""String_Node_Str"");
  events1.setLabelText(""String_Node_Str"");
  events2.setLabelText(""String_Node_Str"");
  events3.setLabelText(""String_Node_Str"");
  setPlotLookAndFeel(events1);
  setPlotLookAndFeel(events2);
  setPlotLookAndFeel(events3);
  events1.getLabelPainter().setVerticalPosition(VerticalPosition.Center);
  events2.getLabelPainter().setVerticalPosition(VerticalPosition.Center);
  events3.getLabelPainter().setVerticalPosition(VerticalPosition.Center);
  GroupInfo group=plot.createGroup(""String_Node_Str"",events1,events2,events3);
  group.setLabelText(""String_Node_Str"");
  group.setOrder(100);
  events1.setOrder(2);
  events2.setOrder(3);
  events3.setOrder(4);
  events1.setBackgroundColor(GlimpseColor.getGreen(0.6f));
  events1.setBorderColor(GlimpseColor.getGreen());
  events3.setBackgroundColor(GlimpseColor.getCyan(0.6f));
  events3.setBorderColor(GlimpseColor.getCyan());
  Epoch e=plot.getEpoch();
  TimeStamp t0=e.toTimeStamp(0);
  Event e0=events1.addEvent(""String_Node_Str"",t0,t0.add(Time.fromMinutes(20)));
  e0.setShowBackground(false);
  events1.addEvent(""String_Node_Str"",t0.add(Time.fromMinutes(30)),t0.add(Time.fromMinutes(200)));
  Event e1=events1.addEvent(""String_Node_Str"",t0.add(Time.fromMinutes(290)),t0.add(Time.fromMinutes(320)));
  e1.setBackgroundColor(GlimpseColor.getRed(0.6f));
  e1.setBorderColor(GlimpseColor.getRed());
  Event e2=events1.addEvent(""String_Node_Str"",t0.add(Time.fromMinutes(-200)),t0.add(Time.fromMinutes(100)));
  Event e3=events1.addEvent(""String_Node_Str"",t0.add(Time.fromMinutes(100)),t0.add(Time.fromMinutes(300)));
  Event e4=events1.addEvent(""String_Node_Str"",t0.subtract(Time.fromMinutes(40)));
  events2.addEvent(""String_Node_Str"",t0.add(Time.fromMinutes(-250)),t0.add(Time.fromMinutes(-240)));
  events2.addEvent(""String_Node_Str"",t0.add(Time.fromMinutes(-220)),t0.add(Time.fromMinutes(-200)));
  events2.addEvent(""String_Node_Str"",t0.add(Time.fromMinutes(-170)),t0.add(Time.fromMinutes(-100)));
  events1.setAggregateNearbyEvents(true);
  events2.setAggregateNearbyEvents(true);
  e0.setEndTimeMoveable(false);
  e1.setResizeable(false);
  e2.setMinTimeSpan(Time.fromMinutes(100));
  e3.setMaxTimeSpan(Time.fromMinutes(500));
  events1.getEventSelectionHandler().setClearSelectionOnClick(true);
  e2.setSelectable(false);
  e2.setFixedRow(2);
  events1.validate();
  TextureAtlas atlas=plot.getTextureAtlas();
  try {
    atlas.loadImage(""String_Node_Str"",ImageIO.read(StreamOpener.fileThenResource.openForRead(""String_Node_Str"")));
    atlas.loadImage(""String_Node_Str"",ImageIO.read(StreamOpener.fileThenResource.openForRead(""String_Node_Str"")));
    atlas.loadImage(""String_Node_Str"",ImageIO.read(StreamOpener.fileThenResource.openForRead(""String_Node_Str"")));
    atlas.loadImage(""String_Node_Str"",ImageIO.read(StreamOpener.fileThenResource.openForRead(""String_Node_Str"")));
  }
 catch (  IOException ex) {
    logWarning(logger,""String_Node_Str"",ex);
  }
  e1.setIconId(""String_Node_Str"");
  e2.setIconId(""String_Node_Str"");
  e3.setIconId(""String_Node_Str"");
  e4.setIconId(""String_Node_Str"");
  plot.getTooltipPainter().setFixedWidth(300);
  e0.setToolTipText(""String_Node_Str"");
  e1.setToolTipText(""String_Node_Str"");
  e2.setToolTipText(""String_Node_Str"");
  e3.setToolTipText(""String_Node_Str"");
  e4.setToolTipText(""String_Node_Str"");
  events1.addEventPlotListener(new EventPlotListener(){
    @Override public void eventsHovered(    GlimpseMouseEvent e,    Set<EventSelection> events,    TimeStamp time){
      if (!events.isEmpty())       logInfo(logger,""String_Node_Str"",events,time);
    }
    @Override public void eventsClicked(    GlimpseMouseEvent e,    Set<EventSelection> events,    TimeStamp time){
      if (!events.isEmpty())       logInfo(logger,""String_Node_Str"",events,time);
    }
    @Override public void eventsExited(    GlimpseMouseEvent e,    Set<EventSelection> events,    TimeStamp time){
      if (!events.isEmpty())       logInfo(logger,""String_Node_Str"",events,time);
    }
    @Override public void eventsEntered(    GlimpseMouseEvent e,    Set<EventSelection> events,    TimeStamp time){
      if (!events.isEmpty())       logInfo(logger,""String_Node_Str"",events,time);
    }
    @Override public void eventUpdated(    Event event){
      logInfo(logger,""String_Node_Str"",event);
    }
  }
);
  plot.getEventSelectionHander().addEventSelectionListener(new EventSelectionListener(){
    @Override public void eventsSelected(    Set<Event> selectedEvents,    Set<Event> deselectedEvents){
      logInfo(logger,""String_Node_Str"",selectedEvents,deselectedEvents);
    }
  }
);
  events1.getEventSelectionHandler().setSelectedEventBorderThickness(3.0f);
  plot.setTimeAxisMouseListener(new TaggedAxisMouseListener1D());
  plot.getSelectedTimePainter().setShowLockedStatus(false);
  plot.getTimeAxis().addAxisListener(new TaggedAxisListener1D(){
    @Override public void tagsUpdated(    TaggedAxis1D axis){
      Tag s=plot.getTimeSelectionTag();
      Tag m=plot.getTimeSelectionMaxTag();
      if (s != null && m != null && s.getValue() != m.getValue()) {
        s.setValue(m.getValue());
        axis.validateTags();
      }
    }
  }
);
  return plot;
}",0.998090609269224
11597,"/** 
 * contour is a contouring subroutine for rectangularly spaced data It emits calls to a line drawing subroutine supplied by the user which draws a contour map corresponding to real*4data on a randomly spaced rectangular grid. The coordinates emitted are in the same units given in the x() and y() arrays. Any number of contour levels may be specified but they must be in order of increasing value.
 * @param d  - matrix of data to contour
 * @param ilb,iub,jlb,jub - index bounds of data matrixThe following two, one dimensional arrays (x and y) contain the horizontal and vertical coordinates of each sample points.
 * @param x  - data matrix column coordinates
 * @param y  - data matrix row coordinates
 * @param nc - number of contour levels
 * @param z  - contour levels in increasing order.
 */
public void contour(double[][] d,int ilb,int iub,int jlb,int jub,double[] x,double[] y,int nc,double[] z){
  int m1;
  int m2;
  int m3;
  int case_value;
  double dmin;
  double dmax;
  double x1=0.0;
  double x2=0.0;
  double y1=0.0;
  double y2=0.0;
  int i, j, k, m;
  int[] im={0,1,1,0};
  int[] jm={0,0,1,1};
  int[][][] castab={{{0,0,8},{0,2,5},{7,6,9}},{{0,3,4},{1,3,1},{4,3,0}},{{9,6,7},{5,2,0},{8,0,0}}};
  double z_0=z[0];
  double z_n=z[nc - 1];
  double z_k;
  double d_i0j0, d_i0j1, d_i1j0, d_i1j1;
  double temp1, temp2;
  for (i=ilb; i <= iub - 1; i++) {
    final float[] d_i0=d[i];
    final float[] d_i1=d[i + 1];
    for (j=jlb; j <= jub - 1; j++) {
      d_i0j0=d_i0[j];
      d_i0j1=d_i0[j + 1];
      d_i1j0=d_i1[j];
      d_i1j1=d_i1[j + 1];
      temp1=Math.min(d_i0j0,d_i0j1);
      temp2=Math.min(d_i1j0,d_i1j1);
      dmin=Math.min(temp1,temp2);
      temp1=Math.max(d_i0j0,d_i0j1);
      temp2=Math.max(d_i1j0,d_i1j1);
      dmax=Math.max(temp1,temp2);
      if (z_0 <= dmax && dmin <= z_n) {
        for (k=0; k < nc; k++) {
          z_k=z[k];
          if (dmin <= z_k && z_k <= dmax) {
            for (m=4; m >= 0; m--) {
              if (m > 0) {
                h[m]=d[i + im[m - 1]][j + jm[m - 1]] - z_k;
                xh[m]=x[i + im[m - 1]];
                yh[m]=y[j + jm[m - 1]];
              }
 else {
                h[0]=0.25 * (h[1] + h[2] + h[3]+ h[4]);
                xh[0]=0.5 * (x[i] + x[i + 1]);
                yh[0]=0.5 * (y[j] + y[j + 1]);
              }
              if (h[m] > 0.0) {
                sh[m]=1;
              }
 else               if (h[m] < 0.0) {
                sh[m]=-1;
              }
 else               sh[m]=0;
            }
            for (m=1; m <= 4; m++) {
              m1=m;
              m2=0;
              if (m != 4) {
                m3=m + 1;
              }
 else {
                m3=1;
              }
              case_value=castab[sh[m1] + 1][sh[m2] + 1][sh[m3] + 1];
              if (case_value != 0) {
switch (case_value) {
case 1:
                  x1=xh[m1];
                y1=yh[m1];
              x2=xh[m2];
            y2=yh[m2];
          break;
case 2:
        x1=xh[m2];
      y1=yh[m2];
    x2=xh[m3];
  y2=yh[m3];
break;
case 3:
x1=xh[m3];
y1=yh[m3];
x2=xh[m1];
y2=yh[m1];
break;
case 4:
x1=xh[m1];
y1=yh[m1];
x2=xsect(m2,m3);
y2=ysect(m2,m3);
break;
case 5:
x1=xh[m2];
y1=yh[m2];
x2=xsect(m3,m1);
y2=ysect(m3,m1);
break;
case 6:
x1=xh[m3];
y1=yh[m3];
x2=xsect(m1,m2);
y2=ysect(m1,m2);
break;
case 7:
x1=xsect(m1,m2);
y1=ysect(m1,m2);
x2=xsect(m2,m3);
y2=ysect(m2,m3);
break;
case 8:
x1=xsect(m2,m3);
y1=ysect(m2,m3);
x2=xsect(m3,m1);
y2=ysect(m3,m1);
break;
case 9:
x1=xsect(m3,m1);
y1=ysect(m3,m1);
x2=xsect(m1,m2);
y2=ysect(m1,m2);
break;
default :
break;
}
render.drawContour(x1,y1,x2,y2,z[k]);
}
}
}
}
}
}
}
}","/** 
 * contour is a contouring subroutine for rectangularly spaced data It emits calls to a line drawing subroutine supplied by the user which draws a contour map corresponding to real*4data on a randomly spaced rectangular grid. The coordinates emitted are in the same units given in the x() and y() arrays. Any number of contour levels may be specified but they must be in order of increasing value.
 * @param d  - matrix of data to contour
 * @param ilb,iub,jlb,jub - index bounds of data matrixThe following two, one dimensional arrays (x and y) contain the horizontal and vertical coordinates of each sample points.
 * @param x  - data matrix column coordinates
 * @param y  - data matrix row coordinates
 * @param nc - number of contour levels
 * @param z  - contour levels in increasing order.
 */
public void contour(double[][] d,int ilb,int iub,int jlb,int jub,double[] x,double[] y,int nc,double[] z){
  int m1;
  int m2;
  int m3;
  int case_value;
  double dmin;
  double dmax;
  double x1=0.0;
  double x2=0.0;
  double y1=0.0;
  double y2=0.0;
  int i, j, k, m;
  int[] im={0,1,1,0};
  int[] jm={0,0,1,1};
  int[][][] castab={{{0,0,8},{0,2,5},{7,6,9}},{{0,3,4},{1,3,1},{4,3,0}},{{9,6,7},{5,2,0},{8,0,0}}};
  double z_0=z[0];
  double z_n=z[nc - 1];
  double z_k;
  double d_i0j0, d_i0j1, d_i1j0, d_i1j1;
  double temp1, temp2;
  for (i=ilb; i <= iub - 1; i++) {
    final float[] d_i0=d[i];
    final float[] d_i1=d[i + 1];
    for (j=jlb; j <= jub - 1; j++) {
      d_i0j0=d_i0[j];
      d_i0j1=d_i0[j + 1];
      d_i1j0=d_i1[j];
      d_i1j1=d_i1[j + 1];
      temp1=Math.min(d_i0j0,d_i0j1);
      temp2=Math.min(d_i1j0,d_i1j1);
      dmin=Math.min(temp1,temp2);
      temp1=Math.max(d_i0j0,d_i0j1);
      temp2=Math.max(d_i1j0,d_i1j1);
      dmax=Math.max(temp1,temp2);
      if (z_0 <= dmax && dmin <= z_n) {
        for (k=0; k < nc; k++) {
          z_k=z[k];
          if (dmin == z_k && z_k == dmax)           continue;
          if (dmin <= z_k && z_k <= dmax) {
            for (m=4; m >= 0; m--) {
              if (m > 0) {
                h[m]=d[i + im[m - 1]][j + jm[m - 1]] - z_k;
                xh[m]=x[i + im[m - 1]];
                yh[m]=y[j + jm[m - 1]];
              }
 else {
                h[0]=0.25 * (h[1] + h[2] + h[3]+ h[4]);
                xh[0]=0.5 * (x[i] + x[i + 1]);
                yh[0]=0.5 * (y[j] + y[j + 1]);
              }
              if (h[m] > 0.0) {
                sh[m]=1;
              }
 else               if (h[m] < 0.0) {
                sh[m]=-1;
              }
 else               sh[m]=0;
            }
            for (m=1; m <= 4; m++) {
              m1=m;
              m2=0;
              if (m != 4) {
                m3=m + 1;
              }
 else {
                m3=1;
              }
              case_value=castab[sh[m1] + 1][sh[m2] + 1][sh[m3] + 1];
              if (case_value != 0) {
switch (case_value) {
case 1:
                  x1=xh[m1];
                y1=yh[m1];
              x2=xh[m2];
            y2=yh[m2];
          break;
case 2:
        x1=xh[m2];
      y1=yh[m2];
    x2=xh[m3];
  y2=yh[m3];
break;
case 3:
x1=xh[m3];
y1=yh[m3];
x2=xh[m1];
y2=yh[m1];
break;
case 4:
x1=xh[m1];
y1=yh[m1];
x2=xsect(m2,m3);
y2=ysect(m2,m3);
break;
case 5:
x1=xh[m2];
y1=yh[m2];
x2=xsect(m3,m1);
y2=ysect(m3,m1);
break;
case 6:
x1=xh[m3];
y1=yh[m3];
x2=xsect(m1,m2);
y2=ysect(m1,m2);
break;
case 7:
x1=xsect(m1,m2);
y1=ysect(m1,m2);
x2=xsect(m2,m3);
y2=ysect(m2,m3);
break;
case 8:
x1=xsect(m2,m3);
y1=ysect(m2,m3);
x2=xsect(m3,m1);
y2=ysect(m3,m1);
break;
case 9:
x1=xsect(m3,m1);
y1=ysect(m3,m1);
x2=xsect(m1,m2);
y2=ysect(m1,m2);
break;
default :
break;
}
render.drawContour(x1,y1,x2,y2,z[k]);
}
}
}
}
}
}
}
}",0.9566521264994547
11598,"@Override public double getTextureFractionY(double vertexX,double vertexY){
  double texFracUnnormY=(vertexY - minX) / diffY;
  return texFracUnnormY * diffTexY + minTexY;
}","@Override public double getTextureFractionY(double vertexX,double vertexY){
  double texFracUnnormY=(vertexY - minY) / diffY;
  return texFracUnnormY * diffTexY + minTexY;
}",0.9942196531791908
11599,"protected void allocate_genBuffers(GL gl){
  if (vertexCoordHandles != null)   gl.glDeleteBuffers(numTextures,vertexCoordHandles,0);
  if (texCoordHandles != null)   gl.glDeleteBuffers(numTextures,texCoordHandles,0);
  if (numTextures == 0 || projection == null)   return;
  vertexCoordHandles=new int[numTextures];
  gl.glGenBuffers(numTextures,vertexCoordHandles,0);
  texCoordHandles=new int[numTextures];
  gl.glGenBuffers(numTextures,texCoordHandles,0);
  texStartsX=new int[numTextures];
  texStartsY=new int[numTextures];
  texSizesX=new int[numTextures];
  texSizesY=new int[numTextures];
  texQuadCounts=new int[numTextures];
  int index=0;
  for (int x=0; x < textureCountX; x++) {
    for (int y=0; y < textureCountY; y++) {
      int startX=x * maxTextureSize;
      int startY=y * maxTextureSize;
      int endX=Math.min(startX + maxTextureSize,dataSizeX);
      int endY=Math.min(startY + maxTextureSize,dataSizeY);
      int sizeX=endX - startX;
      int sizeY=endY - startY;
      texStartsX[index]=startX;
      texStartsY[index]=startY;
      texSizesX[index]=sizeX;
      texSizesY[index]=sizeY;
      texQuadCounts[index]=getQuadCountForTexture(index,startX,startY,sizeX,sizeY);
      index++;
    }
  }
  glAllocated=true;
  makeDirty();
  makeProjectionDirty();
}","protected void allocate_genBuffers(GL gl){
  if (vertexCoordHandles != null && vertexCoordHandles.length != 0) {
    gl.glDeleteBuffers(vertexCoordHandles.length,vertexCoordHandles,0);
  }
  if (texCoordHandles != null && texCoordHandles.length != 0) {
    gl.glDeleteBuffers(texCoordHandles.length,texCoordHandles,0);
  }
  if (numTextures == 0 || projection == null)   return;
  vertexCoordHandles=new int[numTextures];
  gl.glGenBuffers(numTextures,vertexCoordHandles,0);
  texCoordHandles=new int[numTextures];
  gl.glGenBuffers(numTextures,texCoordHandles,0);
  texStartsX=new int[numTextures];
  texStartsY=new int[numTextures];
  texSizesX=new int[numTextures];
  texSizesY=new int[numTextures];
  texQuadCounts=new int[numTextures];
  int index=0;
  for (int x=0; x < textureCountX; x++) {
    for (int y=0; y < textureCountY; y++) {
      int startX=x * maxTextureSize;
      int startY=y * maxTextureSize;
      int endX=Math.min(startX + maxTextureSize,dataSizeX);
      int endY=Math.min(startY + maxTextureSize,dataSizeY);
      int sizeX=endX - startX;
      int sizeY=endY - startY;
      texStartsX[index]=startX;
      texStartsY[index]=startY;
      texSizesX[index]=sizeX;
      texSizesY[index]=sizeY;
      texQuadCounts[index]=getQuadCountForTexture(index,startX,startY,sizeX,sizeY);
      index++;
    }
  }
  glAllocated=true;
  makeDirty();
  makeProjectionDirty();
}",0.935026138909634
11600,"protected void allocate_genTextureHandles(GL gl){
  if (textureHandles != null)   gl.glDeleteTextures(numTextures,textureHandles,0);
  if (numTextures == 0 || projection == null)   return;
  textureHandles=new int[numTextures];
  gl.glGenTextures(numTextures,textureHandles,0);
}","protected void allocate_genTextureHandles(GL gl){
  if (textureHandles != null && textureHandles.length != 0) {
    gl.glDeleteTextures(textureHandles.length,textureHandles,0);
  }
  if (numTextures == 0 || projection == null)   return;
  textureHandles=new int[numTextures];
  gl.glGenTextures(numTextures,textureHandles,0);
}",0.8646864686468647
11601,"@Override public void dispose(GLContext context){
  GL gl=context.getGL();
  if (textureHandles != null)   gl.glDeleteTextures(numTextures,textureHandles,0);
  if (vertexCoordHandles != null)   gl.glDeleteBuffers(numTextures,vertexCoordHandles,0);
  if (texCoordHandles != null)   gl.glDeleteBuffers(numTextures,texCoordHandles,0);
}","@Override public void dispose(GLContext context){
  GL gl=context.getGL();
  if (textureHandles != null && textureHandles.length != 0) {
    gl.glDeleteTextures(textureHandles.length,textureHandles,0);
  }
  if (vertexCoordHandles != null && vertexCoordHandles.length != 0) {
    gl.glDeleteBuffers(vertexCoordHandles.length,vertexCoordHandles,0);
  }
  if (texCoordHandles != null && texCoordHandles.length != 0) {
    gl.glDeleteBuffers(texCoordHandles.length,texCoordHandles,0);
  }
}",0.5853658536585366
11602,"public void deletePlot(Object id){
  this.lock.lock();
  try {
    PlotInfo info=stackedPlots.get(id);
    if (info == null)     return;
    this.removeLayout(info.getLayout());
    stackedPlots.remove(id);
    if (isAutoValidate())     validate();
  }
  finally {
    this.lock.unlock();
  }
}","public void deletePlot(Object id){
  this.lock.lock();
  try {
    PlotInfo info=stackedPlots.remove(id);
    if (info == null)     return;
    info.deletePlot();
    if (isAutoValidate())     validate();
  }
  finally {
    this.lock.unlock();
  }
}",0.5588235294117647
11603,"@Override public void addChildPlot(PlotInfo childPlot){
  childPlot.setVisible(this.expanded);
  this.children.add(childPlot);
  this.plot.validateLayout();
}","@Override public void addChildPlot(PlotInfo childPlot){
  childPlot.setVisible(this.expanded);
  this.children.add(childPlot);
  if (this.plot.isAutoValidate())   this.plot.validateLayout();
}",0.9028571428571428
11604,"@Override public void removeChildPlot(PlotInfo childPlot){
  this.children.remove(childPlot);
  this.plot.validateLayout();
}","@Override public void removeChildPlot(PlotInfo childPlot){
  this.children.remove(childPlot);
  if (this.plot.isAutoValidate())   this.plot.validateLayout();
}",0.8802816901408451
11605,"/** 
 * This implementation of removeNotify is to get around an inconvenience where this canvas is removed from one component hierarchy and added to another.  Technically, this will destroy the context.  But since Glimpse makes significant use of buffers and textures, this data needs to come along.  Therefore, we force shared contexts to preserve the information as we transition to another canvas.  This helps for docking frameworks and moving the canvas seamlessly. <p> We could override the removeNotify method of the enclosed GLCanvas, but then we'd have to take care of removing it from drawing into the screen. We could create a new GLCanvas directly shared with the old, instead of a pbuffer, but you have to draw into a new context at least once to share all the information, and you can't draw into a GLCanvas until it's physically displayed. </p>
 */
@Override public void removeNotify(){
  if (tempDrawable == null) {
    tempDrawable=GLDrawableFactory.getFactory().createGLPbuffer(glCanvas.getChosenGLCapabilities(),null,10,10,glCanvas.getContext());
  }
  attachAllGLListeners(tempDrawable);
  tempDrawable.display();
  boolean autoSwap=glCanvas.getAutoSwapBufferMode();
  remove(this.glCanvas);
  super.removeNotify();
  this.glCanvas=new GLCanvas(tempDrawable.getChosenGLCapabilities(),null,tempDrawable.getContext(),null);
  this.glCanvas.setAutoSwapBufferMode(autoSwap);
  attachAllGLListeners(glCanvas);
  add(this.glCanvas,BorderLayout.CENTER);
}","/** 
 * This implementation of removeNotify is to get around an inconvenience where this canvas is removed from one component hierarchy and added to another.  Technically, this will destroy the context.  But since Glimpse makes significant use of buffers and textures, this data needs to come along.  Therefore, we force shared contexts to preserve the information as we transition to another canvas.  This helps for docking frameworks and moving the canvas seamlessly. <p> We could override the removeNotify method of the enclosed GLCanvas, but then we'd have to take care of removing it from drawing into the screen. We could create a new GLCanvas directly shared with the old, instead of a pbuffer, but you have to draw into a new context at least once to share all the information, and you can't draw into a GLCanvas until it's physically displayed. </p>
 */
@Override public void removeNotify(){
  if (offscreenCanvas == null) {
    offscreenCanvas=new FrameBufferGlimpseCanvas(getWidth(),getHeight(),glCanvas.getContext());
  }
  offscreenCanvas.removeAllLayouts();
  for (  GlimpseLayout layout : layoutManager.getLayoutList()) {
    offscreenCanvas.addLayout(layout);
  }
  offscreenCanvas.paint();
  boolean autoSwap=glCanvas.getAutoSwapBufferMode();
  remove(this.glCanvas);
  super.removeNotify();
  this.glCanvas=new GLCanvas(null,null,offscreenCanvas.getGLContext(),null);
  this.glCanvas.setAutoSwapBufferMode(autoSwap);
  attachAllGLListeners(glCanvas);
  add(this.glCanvas,BorderLayout.CENTER);
}",0.7197045988586774
11606,"@Override public void updateLayout(int index){
  Orientation orient=getStackedPlot().getOrientation();
  int plotCount=getStackedPlot().getAllPlots().size();
  int plotSpacing=getPlotSpacing();
  int size=isVisible() ? getSize() : 0;
  boolean grow=isGrow();
  if (index == plotCount - 1 && orient == HORIZONTAL)   plotSpacing=0;
 else   if (index == 0 && orient == VERTICAL)   plotSpacing=0;
  String layoutData=null;
  if (orient == VERTICAL) {
    if (grow) {
      String format=""String_Node_Str"";
      layoutData=String.format(format,0,index,plotSpacing);
    }
 else {
      String format=""String_Node_Str"";
      layoutData=String.format(format,0,index,size,plotSpacing);
    }
  }
 else   if (orient == HORIZONTAL) {
    if (grow) {
      String format=""String_Node_Str"";
      layoutData=String.format(format,index,0,plotSpacing);
    }
 else {
      String format=""String_Node_Str"";
      layoutData=String.format(format,index,0,size,plotSpacing);
    }
  }
  getLayout().setLayoutData(layoutData);
}","@Override public void updateLayout(int index){
  Orientation orient=getStackedPlot().getOrientation();
  int plotCount=getStackedPlot().getAllPlots().size();
  int plotSpacing=getPlotSpacing();
  int plotSize=getSize();
  if (!isVisible()) {
    plotSpacing=0;
    plotSize=0;
  }
  if (index == plotCount - 1 && orient == HORIZONTAL)   plotSpacing=0;
 else   if (index == 0 && orient == VERTICAL)   plotSpacing=0;
  String layoutData=null;
  if (orient == VERTICAL) {
    if (isGrow()) {
      String format=""String_Node_Str"";
      layoutData=String.format(format,0,index,plotSpacing);
    }
 else {
      String format=""String_Node_Str"";
      layoutData=String.format(format,0,index,plotSize,plotSpacing);
    }
  }
 else   if (orient == HORIZONTAL) {
    if (isGrow()) {
      String format=""String_Node_Str"";
      layoutData=String.format(format,index,0,plotSpacing);
    }
 else {
      String format=""String_Node_Str"";
      layoutData=String.format(format,index,0,plotSize,plotSpacing);
    }
  }
  getLayout().setLayoutData(layoutData);
}",0.945631067961165
11607,"public GroupInfo getGroupById(Object id){
  this.lock.lock();
  try {
    return getGroup(getPlot(id));
  }
  finally {
    this.lock.unlock();
  }
}","public GroupInfo getGroupById(Object groupId){
  this.lock.lock();
  try {
    return (GroupInfo)getPlot(groupId);
  }
  finally {
    this.lock.unlock();
  }
}",0.919093851132686
11608,"@Override public int getSizePixels(List<PlotInfo> list,int index){
  GroupInfo group=plot.getGroup(info);
  if (group != null && !group.isExpanded()) {
    return 0;
  }
 else {
    return info.getSize();
  }
}","@Override public int getSizePixels(List<PlotInfo> list,int index){
  GroupInfo group=plot.getGroupForChild(info);
  if (group != null && !group.isExpanded()) {
    return 0;
  }
 else {
    return info.getSize();
  }
}",0.9813084112149532
11609,"@Override public SimplePlot2D getLayout(){
  final SimplePlot2D polyplot=new SimplePlot2D();
  polyplot.setTitle(""String_Node_Str"");
  polyplot.setAxisLabelX(""String_Node_Str"",""String_Node_Str"",false);
  polyplot.setAxisLabelY(""String_Node_Str"",""String_Node_Str"",false);
  polyplot.setAxisLabelZ(""String_Node_Str"",""String_Node_Str"");
  polyplot.setAxisSizeZ(65);
  polyplot.setMinX(-20.0f);
  polyplot.setMaxX(20.0f);
  polyplot.setMinY(-20.0f);
  polyplot.setMaxY(20.0f);
  polyplot.setMinZ(0.0f);
  polyplot.setMaxZ(1000.0f);
  polyplot.lockAspectRatioXY(1.0f);
  polyplot.setSelectionSize(50000.0f);
  polyplot.addPainter(new CopyrightPainter());
  polyplot.addPainter(new FpsPainter());
  final PolygonPainter polygonPainter=new PolygonPainter();
  polyplot.addPainter(polygonPainter);
  for (int i=0; i < 100; i++) {
    polygonPainter.addPolygon(1,i,i,i,new float[]{0f,i,i,0f},new float[]{0f,0f,i,i},i);
  }
  for (int i=0; i < 100; i++) {
    polygonPainter.addPolygon(2,i,i,i,new float[]{0f,-i,-i,0f},new float[]{0f,0f,-i,-i},i + 100);
  }
  polygonPainter.addPolygon(4,1,new float[]{-10f,0,10,10,0f},new float[]{-10f,8,0f,10,10},200);
  polygonPainter.setLineWidth(1,3);
  polygonPainter.setLineColor(2,0.0f,0.0f,1.0f,1.0f);
  polygonPainter.setLineDotted(2,true);
  polygonPainter.setFill(3,true);
  polygonPainter.setLineWidth(3,3);
  polygonPainter.setFillColor(3,0.0f,1.0f,0.0f,1.0f);
  polygonPainter.setFill(4,true);
  polygonPainter.setLineColor(6,1.0f,0.0f,0.0f,1.0f);
  polygonPainter.setFill(6,false);
  (new Thread(){
    @Override public void run(){
      int i=0;
      while (true) {
        polygonPainter.addPolygon(6,i,i,i + 20,new float[]{0f,-i,-i,0f},new float[]{0f,0f,i,i},100);
        int deleteId=(int)(Math.random() * i);
        polygonPainter.deletePolygon(6,deleteId);
        i++;
        try {
          Thread.sleep(100);
        }
 catch (        InterruptedException e) {
          e.printStackTrace();
        }
      }
    }
  }
).start();
  (new Thread(){
    int i=5;
    ColorGradient c=ColorGradients.jet;
    float[] rgba=new float[4];
    Random r=new Random();
    @Override public void run(){
      while (true) {
        float x0=200 * r.nextFloat();
        float y0=200 * r.nextFloat();
        float t=(float)(r.nextFloat() * Math.PI * 2);
        float d=15;
        float dt=(float)(Math.PI / 36);
        float x1=(float)(x0 + d * Math.sin(t - dt));
        float y1=(float)(y0 + d * Math.cos(t - dt));
        float x2=(float)(x0 + d * Math.sin(t + dt));
        float y2=(float)(y0 + d * Math.cos(t + dt));
        if (i % 2 == 0) {
          polygonPainter.addPolygon(5,i,i,i + 1000,new float[]{x0,x1,x2},new float[]{y0,y1,y2},200 + i);
        }
 else {
          polygonPainter.addPolygon(5 + i,0,i,i + 1000,new float[]{x0,x1,x2},new float[]{y0,y1,y2},200 + i);
        }
        polygonPainter.setFill(5 + i,true);
        polygonPainter.setShowLines(5 + i,false);
        c.toColor((i % 50) / 50f,rgba);
        polygonPainter.setFillColor(5 + i,rgba[0],rgba[1],rgba[2],r.nextFloat());
        polygonPainter.setFillColor(5,rgba[0],rgba[1],rgba[2],0.2f);
        polygonPainter.setLineColor(5,rgba[0],rgba[1],rgba[2],1.0f);
        i=i + 1;
        try {
          if (i < 2000) {
            Thread.sleep(1);
          }
 else {
            Thread.sleep(100);
          }
        }
 catch (        InterruptedException e) {
          e.printStackTrace();
        }
      }
    }
  }
).start();
  polyplot.getAxisZ().addAxisListener(new RateLimitedAxisListener1D(){
    double prevMinTime=-1;
    double prevMaxTime=-1;
    @Override public void axisUpdatedRateLimited(    Axis1D handler){
      double minTime=handler.getMin();
      double maxTime=handler.getMax();
      if (prevMinTime != minTime || prevMaxTime != maxTime) {
        polygonPainter.displayTimeRange(minTime,maxTime);
        prevMinTime=minTime;
        prevMaxTime=maxTime;
      }
    }
  }
);
  return polyplot;
}","@Override public SimplePlot2D getLayout(){
  final SimplePlot2D polyplot=new SimplePlot2D();
  polyplot.setTitle(""String_Node_Str"");
  polyplot.setAxisLabelX(""String_Node_Str"",""String_Node_Str"",false);
  polyplot.setAxisLabelY(""String_Node_Str"",""String_Node_Str"",false);
  polyplot.setAxisLabelZ(""String_Node_Str"",""String_Node_Str"");
  polyplot.setAxisSizeZ(65);
  polyplot.setMinX(-20.0f);
  polyplot.setMaxX(20.0f);
  polyplot.setMinY(-20.0f);
  polyplot.setMaxY(20.0f);
  polyplot.setMinZ(0.0f);
  polyplot.setMaxZ(1000.0f);
  polyplot.lockAspectRatioXY(1.0f);
  polyplot.setSelectionSize(50000.0f);
  polyplot.addPainter(new CopyrightPainter());
  polyplot.addPainter(new FpsPainter());
  final PolygonPainter polygonPainter=new PolygonPainter();
  polyplot.addPainter(polygonPainter);
  for (int i=0; i < 100; i++) {
    polygonPainter.addPolygon(1,i,i,i,new float[]{0f,i,i,0f},new float[]{0f,0f,i,i},i);
  }
  for (int i=0; i < 100; i++) {
    polygonPainter.addPolygon(2,i,i,i,new float[]{0f,-i,-i,0f},new float[]{0f,0f,-i,-i},i + 100);
  }
  polygonPainter.addPolygon(4,1,new float[]{-10f,0,10,10,0f},new float[]{-10f,8,0f,10,10},200);
  polygonPainter.setLineWidth(1,3);
  polygonPainter.setLineColor(2,0.0f,0.0f,1.0f,1.0f);
  polygonPainter.setLineDotted(2,true);
  polygonPainter.setFill(3,true);
  polygonPainter.setLineWidth(3,3);
  polygonPainter.setFillColor(3,0.0f,1.0f,0.0f,1.0f);
  polygonPainter.setFill(4,true);
  polygonPainter.setLineColor(6,1.0f,0.0f,0.0f,1.0f);
  polygonPainter.setFill(6,false);
  polygonPainter.setPolyDotted(4,true);
  polygonPainter.setPolyDotted(3,true);
  (new Thread(){
    @Override public void run(){
      int i=0;
      while (true) {
        polygonPainter.addPolygon(6,i,i,i + 20,new float[]{0f,-i,-i,0f},new float[]{0f,0f,i,i},100);
        int deleteId=(int)(Math.random() * i);
        polygonPainter.deletePolygon(6,deleteId);
        i++;
        try {
          Thread.sleep(100);
        }
 catch (        InterruptedException e) {
          e.printStackTrace();
        }
      }
    }
  }
).start();
  (new Thread(){
    int i=5;
    ColorGradient c=ColorGradients.jet;
    float[] rgba=new float[4];
    Random r=new Random();
    @Override public void run(){
      while (true) {
        float x0=200 * r.nextFloat();
        float y0=200 * r.nextFloat();
        float t=(float)(r.nextFloat() * Math.PI * 2);
        float d=15;
        float dt=(float)(Math.PI / 36);
        float x1=(float)(x0 + d * Math.sin(t - dt));
        float y1=(float)(y0 + d * Math.cos(t - dt));
        float x2=(float)(x0 + d * Math.sin(t + dt));
        float y2=(float)(y0 + d * Math.cos(t + dt));
        if (i % 2 == 0) {
          polygonPainter.addPolygon(5,i,i,i + 1000,new float[]{x0,x1,x2},new float[]{y0,y1,y2},200 + i);
        }
 else {
          polygonPainter.addPolygon(5 + i,0,i,i + 1000,new float[]{x0,x1,x2},new float[]{y0,y1,y2},200 + i);
        }
        polygonPainter.setFill(5 + i,true);
        polygonPainter.setShowLines(5 + i,false);
        c.toColor((i % 50) / 50f,rgba);
        polygonPainter.setFillColor(5 + i,rgba[0],rgba[1],rgba[2],r.nextFloat());
        polygonPainter.setFillColor(5,rgba[0],rgba[1],rgba[2],0.2f);
        polygonPainter.setLineColor(5,rgba[0],rgba[1],rgba[2],1.0f);
        i=i + 1;
        try {
          if (i < 2000) {
            Thread.sleep(1);
          }
 else {
            Thread.sleep(100);
          }
        }
 catch (        InterruptedException e) {
          e.printStackTrace();
        }
      }
    }
  }
).start();
  polyplot.getAxisZ().addAxisListener(new RateLimitedAxisListener1D(){
    double prevMinTime=-1;
    double prevMaxTime=-1;
    @Override public void axisUpdatedRateLimited(    Axis1D handler){
      double minTime=handler.getMin();
      double maxTime=handler.getMax();
      if (prevMinTime != minTime || prevMaxTime != maxTime) {
        polygonPainter.displayTimeRange(minTime,maxTime);
        prevMinTime=minTime;
        prevMaxTime=maxTime;
      }
    }
  }
);
  return polyplot;
}",0.9899799599198396
11610,"public GroupInfoImpl(PlotInfo group,Collection<? extends PlotInfo> subplots){
  this.group=group;
  this.subplots=new HashSet<PlotInfo>();
  this.subplots.addAll(subplots);
  for (  PlotInfo plot : subplots) {
    childParentMap.put(plot,this);
  }
  this.label=new GroupLabelPainter(group.getId());
  this.group.getLayout().addPainter(this.label);
  this.group.setSize(22);
  this.expanded=true;
  GlimpseLayout layout=this.group.getLayout();
  layout.setEventConsumer(false);
  layout.setEventGenerator(true);
  layout.addGlimpseMouseListener(new GlimpseMouseAdapter(){
    @Override public void mousePressed(    GlimpseMouseEvent event){
      int x=event.getScreenPixelsX();
      if (x < labelLayoutSize) {
        setExpanded(!expanded);
        event.setHandled(true);
      }
    }
  }
);
}","public GroupInfoImpl(PlotInfo group,Collection<? extends PlotInfo> subplots){
  this.group=group;
  this.subplots=new LinkedHashSet<PlotInfo>();
  this.subplots.addAll(subplots);
  for (  PlotInfo plot : subplots) {
    childParentMap.put(plot,this);
  }
  this.label=new GroupLabelPainter(group.getId());
  this.group.getLayout().addPainter(this.label);
  this.group.setSize(22);
  this.expanded=true;
  GlimpseLayout layout=this.group.getLayout();
  layout.setEventConsumer(false);
  layout.setEventGenerator(true);
  layout.addGlimpseMouseListener(new GlimpseMouseAdapter(){
    @Override public void mousePressed(    GlimpseMouseEvent event){
      int x=event.getScreenPixelsX();
      if (x < labelLayoutSize) {
        setExpanded(!expanded);
        event.setHandled(true);
      }
    }
  }
);
}",0.99625468164794
11611,"public static void showWithSwing(GlimpseLayoutProvider layoutProviderA,GlimpseLayoutProvider layoutProviderB) throws Exception {
  Jogular.initJogl();
  SwingGlimpseCanvas leftPanel=new SwingGlimpseCanvas(true);
  leftPanel.addLayout(layoutProviderA.getLayout());
  SwingGlimpseCanvas rightPanel=new SwingGlimpseCanvas(true,leftPanel.getGLContext());
  rightPanel.addLayout(layoutProviderB.getLayout());
  RepaintManager repaintManager=new RepaintManager();
  repaintManager.addGlimpseCanvas(leftPanel);
  repaintManager.addGlimpseCanvas(rightPanel);
  repaintManager.start();
  JFrame rightFrame=new JFrame(""String_Node_Str"");
  rightFrame.add(rightPanel);
  rightFrame.pack();
  rightFrame.setSize(800,800);
  rightFrame.setLocation(800,0);
  rightFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
  rightFrame.setVisible(true);
  JFrame leftFrame=new JFrame(""String_Node_Str"");
  leftFrame.add(leftPanel);
  leftFrame.pack();
  leftFrame.setSize(800,800);
  leftFrame.setLocation(0,0);
  leftFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
  leftFrame.setVisible(true);
  return;
}","public static void showWithSwing(GlimpseLayoutProvider layoutProviderA,GlimpseLayoutProvider layoutProviderB) throws Exception {
  Jogular.initJogl();
  SwingGlimpseCanvas leftPanel=new SwingGlimpseCanvas(true);
  leftPanel.addLayout(layoutProviderA.getLayout());
  SwingGlimpseCanvas rightPanel=new SwingGlimpseCanvas(true,leftPanel.getGLContext());
  rightPanel.addLayout(layoutProviderB.getLayout());
  RepaintManager repaintManager=new SwingRepaintManager();
  repaintManager.addGlimpseCanvas(leftPanel);
  repaintManager.addGlimpseCanvas(rightPanel);
  repaintManager.start();
  JFrame rightFrame=new JFrame(""String_Node_Str"");
  rightFrame.add(rightPanel);
  rightFrame.pack();
  rightFrame.setSize(800,800);
  rightFrame.setLocation(800,0);
  rightFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
  rightFrame.setVisible(true);
  JFrame leftFrame=new JFrame(""String_Node_Str"");
  leftFrame.add(leftPanel);
  leftFrame.pack();
  leftFrame.setSize(800,800);
  leftFrame.setLocation(0,0);
  leftFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
  leftFrame.setVisible(true);
  return;
}",0.997720018239854
11612,"public static void main(String[] args) throws Exception {
  Jogular.initJogl();
  final SwingGlimpseCanvas canvas=new SwingGlimpseCanvas(true);
  GlimpseLayout plot=buildPlot(canvas);
  canvas.addLayout(plot);
  canvas.setLookAndFeel(new SwingLookAndFeel());
  final RepaintManager manager=RepaintManager.newRepaintManager(canvas);
  JFrame frame=new JFrame(""String_Node_Str"");
  frame.add(canvas);
  frame.pack();
  frame.setSize(800,800);
  frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
  frame.setVisible(true);
  Runtime.getRuntime().addShutdownHook(new Thread(){
    @Override public void run(){
      canvas.dispose(manager);
    }
  }
);
  return;
}","public static void main(String[] args) throws Exception {
  Jogular.initJogl();
  final SwingGlimpseCanvas canvas=new SwingGlimpseCanvas(true);
  GlimpseLayout plot=buildPlot(canvas);
  canvas.addLayout(plot);
  canvas.setLookAndFeel(new SwingLookAndFeel());
  final RepaintManager manager=SwingRepaintManager.newRepaintManager(canvas);
  JFrame frame=new JFrame(""String_Node_Str"");
  frame.add(canvas);
  frame.pack();
  frame.setSize(800,800);
  frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
  frame.setVisible(true);
  Runtime.getRuntime().addShutdownHook(new Thread(){
    @Override public void run(){
      canvas.dispose(manager);
    }
  }
);
  return;
}",0.9962490622655664
11613,"public BlackAndWhiteLookAndFeel(){
  map.put(CROSSHAIR_COLOR,getWhite());
  map.put(BORDER_COLOR,getWhite());
  map.put(PLOT_BACKGROUND_COLOR,getBlack());
  map.put(FRAME_BACKGROUND_COLOR,getBlack());
  map.put(AXIS_TEXT_COLOR,getWhite());
  map.put(AXIS_TICK_COLOR,getWhite());
  map.put(AXIS_TAG_COLOR,getWhite(0.2f));
  map.put(AXIS_FONT,getDefaultPlain(11));
  map.put(TITLE_FONT,getDefaultBold(14));
  map.put(TEXT_BACKGROUND_COLOR,getBlack(0.7f));
}","public BlackAndWhiteLookAndFeel(){
  map.put(CROSSHAIR_COLOR,getWhite());
  map.put(BORDER_COLOR,getWhite());
  map.put(PLOT_BACKGROUND_COLOR,getBlack());
  map.put(FRAME_BACKGROUND_COLOR,getBlack());
  map.put(AXIS_TEXT_COLOR,getWhite());
  map.put(AXIS_TICK_COLOR,getWhite());
  map.put(AXIS_TAG_COLOR,getWhite(0.2f));
  map.put(AXIS_FONT,getDefaultPlain(11));
  map.put(TITLE_FONT,getDefaultBold(14));
  map.put(TOOLTIP_BACKGROUND_COLOR,getBlack(0.7f));
  map.put(TOOLTIP_TEXT_COLOR,getWhite());
}",0.9465968586387434
11614,"public OceanLookAndFeel(){
  map.put(CROSSHAIR_COLOR,getBlack());
  map.put(BORDER_COLOR,getWhite());
  map.put(PLOT_BACKGROUND_COLOR,addRgb(GlimpseColor.fromColorRgb(25,42,62),-0.08f));
  map.put(FRAME_BACKGROUND_COLOR,GlimpseColor.fromColorRgb(25,42,62));
  map.put(AXIS_TEXT_COLOR,getWhite());
  map.put(AXIS_TICK_COLOR,getWhite());
  map.put(AXIS_TAG_COLOR,getWhite(0.2f));
  map.put(AXIS_FONT,getDefaultPlain(11));
  map.put(TITLE_FONT,getDefaultPlain(14));
  map.put(TEXT_BACKGROUND_COLOR,getBlack(0.7f));
}","public OceanLookAndFeel(){
  map.put(CROSSHAIR_COLOR,getBlack());
  map.put(BORDER_COLOR,getWhite());
  map.put(PLOT_BACKGROUND_COLOR,addRgb(GlimpseColor.fromColorRgb(25,42,62),-0.08f));
  map.put(FRAME_BACKGROUND_COLOR,GlimpseColor.fromColorRgb(25,42,62));
  map.put(AXIS_TEXT_COLOR,getWhite());
  map.put(AXIS_TICK_COLOR,getWhite());
  map.put(AXIS_TAG_COLOR,getWhite(0.2f));
  map.put(AXIS_FONT,getDefaultPlain(11));
  map.put(TITLE_FONT,getDefaultPlain(14));
  map.put(TOOLTIP_BACKGROUND_COLOR,getBlack(0.7f));
  map.put(TOOLTIP_TEXT_COLOR,getWhite());
}",0.9523809523809524
11615,"public SwingLookAndFeel(){
  map.put(CROSSHAIR_COLOR,getBlack());
  map.put(BORDER_COLOR,getBlack());
  map.put(PLOT_BACKGROUND_COLOR,addRgb(fromColorAwt(SystemColor.window),-0.1f));
  map.put(FRAME_BACKGROUND_COLOR,fromColorAwt(SystemColor.window));
  map.put(AXIS_TEXT_COLOR,getBlack());
  map.put(AXIS_TICK_COLOR,getBlack());
  map.put(AXIS_TAG_COLOR,getBlack(0.2f));
  map.put(AXIS_FONT,getDefaultPlain(11));
  map.put(TITLE_FONT,getDefaultPlain(14));
  map.put(TEXT_BACKGROUND_COLOR,getBlack(0.7f));
}","public SwingLookAndFeel(){
  map.put(CROSSHAIR_COLOR,getBlack());
  map.put(BORDER_COLOR,getBlack());
  map.put(PLOT_BACKGROUND_COLOR,addRgb(fromColorAwt(SystemColor.window),-0.1f));
  map.put(FRAME_BACKGROUND_COLOR,fromColorAwt(SystemColor.window));
  map.put(AXIS_TEXT_COLOR,getBlack());
  map.put(AXIS_TICK_COLOR,getBlack());
  map.put(AXIS_TAG_COLOR,getBlack(0.2f));
  map.put(AXIS_FONT,getDefaultPlain(11));
  map.put(TITLE_FONT,getDefaultPlain(14));
  map.put(TOOLTIP_BACKGROUND_COLOR,getBlack(0.7f));
  map.put(TOOLTIP_TEXT_COLOR,getWhite());
}",0.9517502365184484
11616,"public SwtLookAndFeel(){
  map.put(CROSSHAIR_COLOR,GlimpseColor.getBlack());
  map.put(BORDER_COLOR,getBlack());
  map.put(PLOT_BACKGROUND_COLOR,GlimpseColorSwt.fromColorSwtSystemColor(SWT.COLOR_WIDGET_NORMAL_SHADOW));
  map.put(FRAME_BACKGROUND_COLOR,GlimpseColorSwt.fromColorSwtSystemColor(SWT.COLOR_WIDGET_BACKGROUND));
  map.put(AXIS_TEXT_COLOR,getBlack());
  map.put(AXIS_TICK_COLOR,getBlack());
  map.put(AXIS_TAG_COLOR,getBlack(0.2f));
  map.put(AXIS_FONT,getDefaultPlain(11));
  map.put(TITLE_FONT,getDefaultPlain(14));
  map.put(TEXT_BACKGROUND_COLOR,getBlack(0.7f));
}","public SwtLookAndFeel(){
  map.put(CROSSHAIR_COLOR,GlimpseColor.getBlack());
  map.put(BORDER_COLOR,getBlack());
  map.put(PLOT_BACKGROUND_COLOR,GlimpseColorSwt.fromColorSwtSystemColor(SWT.COLOR_WIDGET_NORMAL_SHADOW));
  map.put(FRAME_BACKGROUND_COLOR,GlimpseColorSwt.fromColorSwtSystemColor(SWT.COLOR_WIDGET_BACKGROUND));
  map.put(AXIS_TEXT_COLOR,getBlack());
  map.put(AXIS_TICK_COLOR,getBlack());
  map.put(AXIS_TAG_COLOR,getBlack(0.2f));
  map.put(AXIS_FONT,getDefaultPlain(11));
  map.put(TITLE_FONT,getDefaultPlain(14));
  map.put(TOOLTIP_BACKGROUND_COLOR,getBlack(0.7f));
  map.put(TOOLTIP_TEXT_COLOR,getWhite());
}",0.9125728559533722
11617,"public MouseWrapper(GlimpseCanvas canvas){
  this.canvas=canvas;
  this.dragHoveredSet=new HashSet<GlimpseTargetStack>();
  this.hoveredSet=new HashSet<GlimpseTargetStack>();
}","public MouseWrapper(GlimpseCanvas canvas){
  this.canvas=canvas;
  this.dragHoveredSet=new LinkedList<GlimpseTargetStack>();
  this.hoveredSet=new LinkedList<GlimpseTargetStack>();
}",0.9273743016759776
11618,"public void notifyMouseExited(E event,Set<GlimpseTargetStack> stacks){
  for (  GlimpseTargetStack stack : stacks) {
    notifyMouseExited(event,stack);
  }
}","public void notifyMouseExited(E event,List<GlimpseTargetStack> stacks){
  for (  GlimpseTargetStack stack : stacks) {
    notifyMouseExited(event,stack);
  }
}",0.9842271293375394
11619,"protected void setHovered(Collection<GlimpseTargetStack> list){
  clearHovered();
  for (  GlimpseTargetStack stack : list)   addHovered(stack);
}","protected void setHovered(List<GlimpseTargetStack> list){
  clearHovered();
  for (  GlimpseTargetStack stack : list)   addHovered(stack);
}",0.958041958041958
11620,"protected Set<GlimpseTargetStack> clearAllHovered(){
  Set<GlimpseTargetStack> oldHovered=copyHovered();
  dragHoveredSet.clear();
  hoveredSet.clear();
  return oldHovered;
}","protected List<GlimpseTargetStack> clearAllHovered(){
  List<GlimpseTargetStack> oldHovered=copyHovered();
  dragHoveredSet.clear();
  hoveredSet.clear();
  return oldHovered;
}",0.9715909090909092
11621,"protected Set<GlimpseTargetStack> getHovered(){
  return hoveredSet;
}","protected List<GlimpseTargetStack> getHovered(){
  return hoveredSet;
}",0.9645390070921984
11622,"public void notifyMouseEnteredExited(E event,Set<GlimpseTargetStack> oldStacks,Set<GlimpseTargetStack> newStacks){
  for (  GlimpseTargetStack oldStack : oldStacks) {
    if (!newStacks.contains(oldStack)) {
      notifyMouseExited(event,oldStack);
    }
  }
  for (  GlimpseTargetStack newStack : newStacks) {
    if (!oldStacks.contains(newStack)) {
      notifyMouseEntered(event,newStack);
    }
  }
}","public void notifyMouseEnteredExited(E event,List<GlimpseTargetStack> oldStacks,List<GlimpseTargetStack> newStacks){
  for (  GlimpseTargetStack oldStack : oldStacks) {
    if (!newStacks.contains(oldStack)) {
      notifyMouseExited(event,oldStack);
    }
  }
  for (  GlimpseTargetStack newStack : newStacks) {
    if (!oldStacks.contains(newStack)) {
      notifyMouseEntered(event,newStack);
    }
  }
}",0.9876847290640394
11623,"protected Set<GlimpseTargetStack> getDragHovered(){
  return dragHoveredSet;
}","protected List<GlimpseTargetStack> getDragHovered(){
  return dragHoveredSet;
}",0.9681528662420382
11624,"protected void setAllHovered(Collection<GlimpseTargetStack> list){
  setDragHovered(list);
  setHovered(list);
}","protected void setAllHovered(List<GlimpseTargetStack> list){
  setDragHovered(list);
  setHovered(list);
}",0.944954128440367
11625,"protected void setDragHovered(Collection<GlimpseTargetStack> list){
  clearDragHovered();
  for (  GlimpseTargetStack stack : list)   addDragHovered(stack);
}","protected void setDragHovered(List<GlimpseTargetStack> list){
  clearDragHovered();
  for (  GlimpseTargetStack stack : list)   addDragHovered(stack);
}",0.9612903225806452
11626,"protected Set<GlimpseTargetStack> copyHovered(){
  return new HashSet<GlimpseTargetStack>(hoveredSet);
}","protected List<GlimpseTargetStack> copyHovered(){
  return new LinkedList<GlimpseTargetStack>(hoveredSet);
}",0.9150943396226416
11627,"protected Set<GlimpseTargetStack> copyDragHovered(){
  return new HashSet<GlimpseTargetStack>(dragHoveredSet);
}","protected List<GlimpseTargetStack> copyDragHovered(){
  return new LinkedList<GlimpseTargetStack>(dragHoveredSet);
}",0.9210526315789472
11628,"protected Set<GlimpseTargetStack> clearDragHovered(){
  Set<GlimpseTargetStack> oldHovered=copyDragHovered();
  dragHoveredSet.clear();
  return oldHovered;
}","protected List<GlimpseTargetStack> clearDragHovered(){
  List<GlimpseTargetStack> oldHovered=copyDragHovered();
  dragHoveredSet.clear();
  return oldHovered;
}",0.9685534591194968
11629,"public void notifyMouseEntered(E event,Set<GlimpseTargetStack> stacks){
  for (  GlimpseTargetStack stack : stacks) {
    notifyMouseEntered(event,stack);
  }
}","public void notifyMouseEntered(E event,List<GlimpseTargetStack> stacks){
  for (  GlimpseTargetStack stack : stacks) {
    notifyMouseEntered(event,stack);
  }
}",0.9844236760124612
11630,"protected Set<GlimpseTargetStack> clearHovered(){
  Set<GlimpseTargetStack> oldHovered=copyHovered();
  hoveredSet.clear();
  return oldHovered;
}","protected List<GlimpseTargetStack> clearHovered(){
  List<GlimpseTargetStack> oldHovered=copyHovered();
  hoveredSet.clear();
  return oldHovered;
}",0.9659863945578232
11631,"public boolean mouseReleased0(E event){
  if (event == null)   return false;
  boolean handled=false;
  if (isDragHovered()) {
    Set<GlimpseTargetStack> hoveredList=getDragHovered();
    for (    GlimpseTargetStack hoveredStack : hoveredList) {
      Mouseable mouseTarget=getMouseTarget(hoveredStack);
      GlimpseMouseEvent glimpseEvent=toLocalGlimpseEvent(event,hoveredStack);
      if (mouseTarget != null)       mouseTarget.mouseReleased(glimpseEvent);
      if (glimpseEvent.isHandled()) {
        handled=true;
        break;
      }
    }
  }
  getContainingTargets(event);
  return handled;
}","public boolean mouseReleased0(E event){
  if (event == null)   return false;
  boolean handled=false;
  if (isDragHovered()) {
    List<GlimpseTargetStack> hoveredList=getDragHovered();
    for (    GlimpseTargetStack hoveredStack : hoveredList) {
      Mouseable mouseTarget=getMouseTarget(hoveredStack);
      GlimpseMouseEvent glimpseEvent=toLocalGlimpseEvent(event,hoveredStack);
      if (mouseTarget != null)       mouseTarget.mouseReleased(glimpseEvent);
      if (glimpseEvent.isHandled()) {
        handled=true;
        break;
      }
    }
  }
  getContainingTargets(event);
  return handled;
}",0.9958643507030605
11632,"public boolean mouseMoved0(E event){
  if (event == null)   return false;
  Set<GlimpseTargetStack> oldHovered=clearAllHovered();
  getContainingTargets(event);
  Set<GlimpseTargetStack> newHovered=getHovered();
  notifyMouseEnteredExited(event,oldHovered,newHovered);
  if (isDragHovered()) {
    for (    GlimpseTargetStack hoveredStack : newHovered) {
      Mouseable mouseHoveredTarget=getMouseTarget(hoveredStack);
      GlimpseMouseEvent glimpseHoveredEvent=toLocalGlimpseEvent(event,hoveredStack);
      if (mouseHoveredTarget != null)       mouseHoveredTarget.mouseMoved(glimpseHoveredEvent);
      if (glimpseHoveredEvent.isHandled())       return true;
    }
  }
  return false;
}","public boolean mouseMoved0(E event){
  if (event == null)   return false;
  List<GlimpseTargetStack> oldHovered=clearAllHovered();
  getContainingTargets(event);
  List<GlimpseTargetStack> newHovered=getHovered();
  notifyMouseEnteredExited(event,oldHovered,newHovered);
  if (isDragHovered()) {
    for (    GlimpseTargetStack hoveredStack : newHovered) {
      Mouseable mouseHoveredTarget=getMouseTarget(hoveredStack);
      GlimpseMouseEvent glimpseHoveredEvent=toLocalGlimpseEvent(event,hoveredStack);
      if (mouseHoveredTarget != null)       mouseHoveredTarget.mouseMoved(glimpseHoveredEvent);
      if (glimpseHoveredEvent.isHandled())       return true;
    }
  }
  return false;
}",0.9927641099855282
11633,"public void mouseEntered0(E event){
  if (event == null)   return;
  Set<GlimpseTargetStack> oldHovered=clearHovered();
  getContainingTargets(event);
  Set<GlimpseTargetStack> newHovered=getHovered();
  notifyMouseEnteredExited(event,oldHovered,newHovered);
}","public void mouseEntered0(E event){
  if (event == null)   return;
  List<GlimpseTargetStack> oldHovered=clearHovered();
  getContainingTargets(event);
  List<GlimpseTargetStack> newHovered=getHovered();
  notifyMouseEnteredExited(event,oldHovered,newHovered);
}",0.9808429118773946
11634,"public boolean mouseDragged0(E event){
  if (event == null)   return false;
  Set<GlimpseTargetStack> oldHovered=clearHovered();
  getContainingTargets(event);
  Set<GlimpseTargetStack> newHovered=getHovered();
  notifyMouseEnteredExited(event,oldHovered,newHovered);
  if (isDragHovered()) {
    Set<GlimpseTargetStack> hoveredList=getDragHovered();
    for (    GlimpseTargetStack hoveredStack : hoveredList) {
      Mouseable mouseHoveredTarget=getMouseTarget(hoveredStack);
      GlimpseMouseEvent glimpseHoveredEvent=toLocalGlimpseEvent(event,hoveredStack);
      if (mouseHoveredTarget != null)       mouseHoveredTarget.mouseMoved(glimpseHoveredEvent);
      if (glimpseHoveredEvent.isHandled())       return true;
    }
  }
  return false;
}","public boolean mouseDragged0(E event){
  if (event == null)   return false;
  List<GlimpseTargetStack> oldHovered=clearHovered();
  getContainingTargets(event);
  List<GlimpseTargetStack> newHovered=getHovered();
  notifyMouseEnteredExited(event,oldHovered,newHovered);
  if (isDragHovered()) {
    List<GlimpseTargetStack> hoveredList=getDragHovered();
    for (    GlimpseTargetStack hoveredStack : hoveredList) {
      Mouseable mouseHoveredTarget=getMouseTarget(hoveredStack);
      GlimpseMouseEvent glimpseHoveredEvent=toLocalGlimpseEvent(event,hoveredStack);
      if (mouseHoveredTarget != null)       mouseHoveredTarget.mouseMoved(glimpseHoveredEvent);
      if (glimpseHoveredEvent.isHandled())       return true;
    }
  }
  return false;
}",0.989993328885924
11635,"public void mouseExited0(E event){
  if (event == null)   return;
  Set<GlimpseTargetStack> oldHovered=clearHovered();
  getContainingTargets(event);
  Set<GlimpseTargetStack> newHovered=getHovered();
  notifyMouseEnteredExited(event,oldHovered,newHovered);
}","public void mouseExited0(E event){
  if (event == null)   return;
  List<GlimpseTargetStack> oldHovered=clearHovered();
  getContainingTargets(event);
  List<GlimpseTargetStack> newHovered=getHovered();
  notifyMouseEnteredExited(event,oldHovered,newHovered);
}",0.9807692307692308
11636,"protected Axis2D getMainMapAxis0(GlimpseTargetStack stack){
  return getAxis0(newTargetStack(stack).pop().pop());
}","protected Axis2D getMainMapAxis0(GlimpseTargetStack stack){
  return getAxis0(getMainMapTargetStack(stack));
}",0.8977777777777778
11637,"@Override public void paintTo(GlimpseContext context,GlimpseBounds bounds,Axis2D axis){
  GL gl=context.getGL();
  if (this.newData) {
    this.updateLock.lock();
    try {
      for (      Group group : updatedGroups) {
        int id=group.groupId;
        if (group.groupDeleted || group.groupCleared) {
          LoadedGroup loaded=getOrCreateLoadedGroup(id,group);
          loaded.dispose(gl);
          loadedGroups.remove(id);
          if (group.groupDeleted && !group.polygonsInserted) {
            groups.remove(id);
            continue;
          }
        }
        LoadedGroup loaded=getOrCreateLoadedGroup(id,group);
        loaded.loadSettings(group);
        if (group.polygonsInserted) {
          updateVertices(gl,loaded,group,true);
          updateVertices(gl,loaded,group,false);
        }
        if (loaded.glLineBufferInitialized && loaded.glFillBufferInitialized) {
          if (group.polygonsSelected) {
            loaded.loadLineSelectionIntoBuffer(group.selectedPolygons,group.selectedLinePrimitiveCount,0);
            loaded.loadFillSelectionIntoBuffer(group.selectedPolygons,group.selectedFillPrimitiveCount,0);
          }
 else           if (!group.newSelectedPolygons.isEmpty()) {
            loaded.loadLineSelectionIntoBuffer(group.newSelectedPolygons,group.selectedLinePrimitiveCount);
            loaded.loadFillSelectionIntoBuffer(group.newSelectedPolygons,group.selectedFillPrimitiveCount);
          }
        }
        group.reset();
      }
      this.updatedGroups.clear();
      this.newData=false;
    }
  finally {
      this.updateLock.unlock();
    }
    glHandleError(gl,""String_Node_Str"");
  }
  if (loadedGroups.isEmpty())   return;
  gl.glMatrixMode(GL.GL_PROJECTION);
  gl.glLoadIdentity();
  gl.glOrtho(axis.getMinX(),axis.getMaxX(),axis.getMinY(),axis.getMaxY(),-1 << 23,1);
  gl.glBlendFunc(GL.GL_SRC_ALPHA,GL.GL_ONE_MINUS_SRC_ALPHA);
  gl.glEnable(GL.GL_BLEND);
  gl.glEnable(GL.GL_LINE_SMOOTH);
  gl.glEnableClientState(GL.GL_VERTEX_ARRAY);
  for (  LoadedGroup loaded : loadedGroups.values()) {
    drawGroup(gl,loaded);
  }
  glHandleError(gl,""String_Node_Str"");
  gl.glDisable(GL.GL_DEPTH_TEST);
  gl.glDisable(GL.GL_BLEND);
  gl.glDisable(GL.GL_LINE_SMOOTH);
}","@Override public void paintTo(GlimpseContext context,GlimpseBounds bounds,Axis2D axis){
  GL gl=context.getGL();
  if (this.newData) {
    this.updateLock.lock();
    try {
      for (      Group group : updatedGroups) {
        int id=group.groupId;
        if (group.groupDeleted || group.groupCleared) {
          LoadedGroup loaded=getOrCreateLoadedGroup(id,group);
          loaded.dispose(gl);
          loadedGroups.remove(id);
          if (group.groupDeleted && !group.polygonsInserted) {
            groups.remove(id);
            continue;
          }
        }
        LoadedGroup loaded=getOrCreateLoadedGroup(id,group);
        loaded.loadSettings(group);
        if (group.polygonsInserted) {
          updateVertices(gl,loaded,group,true);
          updateVertices(gl,loaded,group,false);
        }
        if (group.polygonsSelected) {
          loaded.loadLineSelectionIntoBuffer(group.selectedPolygons,group.selectedLinePrimitiveCount,0);
          loaded.loadFillSelectionIntoBuffer(group.selectedPolygons,group.selectedFillPrimitiveCount,0);
        }
        group.reset();
      }
      this.updatedGroups.clear();
      this.newData=false;
    }
  finally {
      this.updateLock.unlock();
    }
    glHandleError(gl,""String_Node_Str"");
  }
  if (loadedGroups.isEmpty())   return;
  gl.glMatrixMode(GL.GL_PROJECTION);
  gl.glLoadIdentity();
  gl.glOrtho(axis.getMinX(),axis.getMaxX(),axis.getMinY(),axis.getMaxY(),-1 << 23,1);
  gl.glBlendFunc(GL.GL_SRC_ALPHA,GL.GL_ONE_MINUS_SRC_ALPHA);
  gl.glEnable(GL.GL_BLEND);
  gl.glEnable(GL.GL_LINE_SMOOTH);
  gl.glEnableClientState(GL.GL_VERTEX_ARRAY);
  for (  LoadedGroup loaded : loadedGroups.values()) {
    drawGroup(gl,loaded);
  }
  glHandleError(gl,""String_Node_Str"");
  gl.glDisable(GL.GL_DEPTH_TEST);
  gl.glDisable(GL.GL_BLEND);
  gl.glDisable(GL.GL_LINE_SMOOTH);
}",0.81237721021611
11638,"public void loadLineSelectionIntoBuffer(Collection<IdPolygon> polygons,int size,int offset){
  ensureLineOffsetBufferSize(size);
  ensureLineCountBufferSize(size);
  if (size <= 0 || offset < 0)   return;
  glLineOffsetBuffer.position(offset);
  glLineCountBuffer.position(offset);
  for (  IdPolygon polygon : polygons) {
    polygon.loadLineIntoBuffer(glLineOffsetBuffer,glLineCountBuffer);
  }
}","public void loadLineSelectionIntoBuffer(Collection<IdPolygon> polygons,int size,int offset){
  if (size <= 0 || offset < 0)   return;
  ensureLineOffsetBufferSize(size);
  ensureLineCountBufferSize(size);
  glLineOffsetBuffer.position(offset);
  glLineCountBuffer.position(offset);
  for (  IdPolygon polygon : polygons) {
    polygon.loadLineIntoBuffer(glLineOffsetBuffer,glLineCountBuffer);
  }
}",0.8165829145728644
11639,"protected void updateVertices(GL gl,LoadedGroup loaded,Group group,boolean fill){
  boolean initialized=fill ? loaded.glFillBufferInitialized : loaded.glLineBufferInitialized;
  int maxSize=fill ? loaded.glFillBufferMaxSize : loaded.glLineBufferMaxSize;
  int currentSize=fill ? loaded.glFillBufferCurrentSize : loaded.glLineBufferCurrentSize;
  int insertSize=fill ? group.fillInsertVertexCount : group.lineInsertVertexCount;
  int totalSize=fill ? group.totalFillVertexCount : group.totalLineVertexCount;
  int handle=fill ? loaded.glFillBufferHandle : loaded.glLineBufferHandle;
  int sizeNeeded=currentSize + insertSize;
  if (!initialized || maxSize < sizeNeeded) {
    if (!initialized || maxSize < DELETE_EXPAND_FACTOR * totalSize) {
      if (initialized) {
        gl.glDeleteBuffers(1,new int[]{handle},0);
        maxSize=Math.max((int)(maxSize * 1.5),totalSize);
      }
 else {
        maxSize=totalSize;
      }
      int[] bufferHandle=new int[1];
      gl.glGenBuffers(1,bufferHandle,0);
      handle=bufferHandle[0];
    }
    ensureDataBufferSize(maxSize);
    if (fill) {
      loaded.loadFillVerticesIntoBuffer(group,dataBuffer,0,group.polygonMap.values());
    }
 else {
      loaded.loadLineVerticesIntoBuffer(group,dataBuffer,0,group.polygonMap.values());
    }
    gl.glBindBuffer(GL.GL_ARRAY_BUFFER,handle);
    glHandleError(gl,""String_Node_Str"");
    gl.glBufferData(GL.GL_ARRAY_BUFFER,maxSize * 3 * BYTES_PER_FLOAT,dataBuffer.rewind(),GL.GL_DYNAMIC_DRAW);
    glHandleError(gl,""String_Node_Str"");
    if (fill) {
      loaded.glFillBufferInitialized=true;
      loaded.glFillBufferCurrentSize=totalSize;
      loaded.glFillBufferHandle=handle;
      loaded.glFillBufferMaxSize=maxSize;
    }
 else {
      loaded.glLineBufferInitialized=true;
      loaded.glLineBufferCurrentSize=totalSize;
      loaded.glLineBufferHandle=handle;
      loaded.glLineBufferMaxSize=maxSize;
    }
  }
 else {
    int insertVertices=insertSize;
    ensureDataBufferSize(insertVertices);
    if (fill) {
      loaded.loadFillVerticesIntoBuffer(group,dataBuffer,currentSize,group.newPolygons);
    }
 else {
      loaded.loadLineVerticesIntoBuffer(group,dataBuffer,currentSize,group.newPolygons);
    }
    gl.glBindBuffer(GL.GL_ARRAY_BUFFER,handle);
    glHandleError(gl,""String_Node_Str"");
    gl.glBufferSubData(GL.GL_ARRAY_BUFFER,currentSize * 3 * BYTES_PER_FLOAT,insertVertices * 3 * BYTES_PER_FLOAT,dataBuffer.rewind());
    glHandleError(gl,""String_Node_Str"");
    if (fill) {
      loaded.glFillBufferCurrentSize=sizeNeeded;
    }
 else {
      loaded.glLineBufferCurrentSize=sizeNeeded;
    }
  }
}","protected void updateVertices(GL gl,LoadedGroup loaded,Group group,boolean fill){
  boolean initialized=fill ? loaded.glFillBufferInitialized : loaded.glLineBufferInitialized;
  int maxSize=fill ? loaded.glFillBufferMaxSize : loaded.glLineBufferMaxSize;
  int currentSize=fill ? loaded.glFillBufferCurrentSize : loaded.glLineBufferCurrentSize;
  int insertSize=fill ? group.fillInsertVertexCount : group.lineInsertVertexCount;
  int totalSize=fill ? group.totalFillVertexCount : group.totalLineVertexCount;
  int handle=fill ? loaded.glFillBufferHandle : loaded.glLineBufferHandle;
  int sizeNeeded=currentSize + insertSize;
  if (!initialized || maxSize < sizeNeeded) {
    if (!initialized || maxSize < DELETE_EXPAND_FACTOR * totalSize) {
      if (initialized) {
        gl.glDeleteBuffers(1,new int[]{handle},0);
        maxSize=Math.max((int)(maxSize * 1.5),totalSize);
      }
 else {
        maxSize=totalSize;
      }
      int[] bufferHandle=new int[1];
      gl.glGenBuffers(1,bufferHandle,0);
      handle=bufferHandle[0];
      if (fill)       System.out.println(""String_Node_Str"" + maxSize);
    }
    ensureDataBufferSize(maxSize);
    if (fill) {
      loaded.loadFillVerticesIntoBuffer(group,dataBuffer,0,group.polygonMap.values());
      loaded.loadFillSelectionIntoBuffer(group.selectedPolygons,group.selectedFillPrimitiveCount,0);
    }
 else {
      loaded.loadLineVerticesIntoBuffer(group,dataBuffer,0,group.polygonMap.values());
      loaded.loadLineSelectionIntoBuffer(group.selectedPolygons,group.selectedLinePrimitiveCount,0);
    }
    gl.glBindBuffer(GL.GL_ARRAY_BUFFER,handle);
    glHandleError(gl,""String_Node_Str"");
    gl.glBufferData(GL.GL_ARRAY_BUFFER,maxSize * 3 * BYTES_PER_FLOAT,dataBuffer.rewind(),GL.GL_DYNAMIC_DRAW);
    glHandleError(gl,""String_Node_Str"");
    if (fill) {
      loaded.glFillBufferInitialized=true;
      loaded.glFillBufferCurrentSize=totalSize;
      loaded.glFillBufferHandle=handle;
      loaded.glFillBufferMaxSize=maxSize;
    }
 else {
      loaded.glLineBufferInitialized=true;
      loaded.glLineBufferCurrentSize=totalSize;
      loaded.glLineBufferHandle=handle;
      loaded.glLineBufferMaxSize=maxSize;
    }
  }
 else {
    ensureDataBufferSize(insertSize);
    if (fill) {
      loaded.loadFillVerticesIntoBuffer(group,dataBuffer,currentSize,group.newPolygons);
      loaded.loadFillSelectionIntoBuffer(group.newSelectedPolygons,group.selectedFillPrimitiveCount);
    }
 else {
      loaded.loadLineVerticesIntoBuffer(group,dataBuffer,currentSize,group.newPolygons);
      loaded.loadLineSelectionIntoBuffer(group.newSelectedPolygons,group.selectedLinePrimitiveCount);
    }
    gl.glBindBuffer(GL.GL_ARRAY_BUFFER,handle);
    glHandleError(gl,""String_Node_Str"");
    gl.glBufferSubData(GL.GL_ARRAY_BUFFER,currentSize * 3 * BYTES_PER_FLOAT,insertSize * 3 * BYTES_PER_FLOAT,dataBuffer.rewind());
    glHandleError(gl,""String_Node_Str"");
    if (fill) {
      loaded.glFillBufferCurrentSize=sizeNeeded;
    }
 else {
      loaded.glLineBufferCurrentSize=sizeNeeded;
    }
  }
}",0.9053338043094312
11640,"public GlimpseLayoutDelegate(GlimpseLayout layout){
  this.layout=layout;
  this.layoutChildren=new ArrayList<GlimpseLayoutDelegate>();
  this.memberList=new ArrayList<Member>();
  this.memberMap=new LinkedHashMap<GlimpsePainter,Member>();
  this.backgroundPainter=new BackgroundPainter(true);
  this.backgroundPainterEnabled=true;
}","public GlimpseLayoutDelegate(GlimpseLayout layout){
  this.layout=layout;
  this.layoutChildren=new ArrayList<GlimpseLayoutDelegate>();
  this.memberList=new ArrayList<Member>();
  this.memberMap=new LinkedHashMap<GlimpsePainter,Member>();
}",0.8397212543554007
11641,"public void setLookAndFeel(LookAndFeel laf){
  backgroundPainter.setLookAndFeel(laf);
  for (  Member m : memberList) {
    m.painter.setLookAndFeel(laf);
  }
}","public void setLookAndFeel(LookAndFeel laf){
  for (  Member m : memberList) {
    m.painter.setLookAndFeel(laf);
  }
}",0.8530465949820788
11642,"public void paintTo(GlimpseContext context){
  GL gl=context.getGL();
  GlimpseBounds bounds=context.getTargetStack().getBounds();
  GlimpseBounds clippedBounds=getClippedBounds(context);
  if (!clippedBounds.isValid())   return;
  if (backgroundPainterEnabled) {
    try {
      gl.glEnable(GL.GL_SCISSOR_TEST);
      gl.glViewport(bounds.getX(),bounds.getY(),bounds.getWidth(),bounds.getHeight());
      gl.glScissor(clippedBounds.getX(),clippedBounds.getY(),clippedBounds.getWidth(),clippedBounds.getHeight());
      this.backgroundPainter.paintTo(context);
    }
  finally {
      gl.glDisable(GL.GL_SCISSOR_TEST);
    }
  }
  for (  Member m : memberList) {
    try {
      gl.glEnable(GL.GL_SCISSOR_TEST);
      gl.glViewport(bounds.getX(),bounds.getY(),bounds.getWidth(),bounds.getHeight());
      gl.glScissor(clippedBounds.getX(),clippedBounds.getY(),clippedBounds.getWidth(),clippedBounds.getHeight());
      if (m.callback != null)       m.callback.prePaint(m.painter,context);
      m.painter.paintTo(context);
      if (m.callback != null)       m.callback.postPaint(m.painter,context);
    }
  finally {
      gl.glDisable(GL.GL_SCISSOR_TEST);
    }
  }
}","public void paintTo(GlimpseContext context){
  GL gl=context.getGL();
  GlimpseBounds bounds=context.getTargetStack().getBounds();
  GlimpseBounds clippedBounds=getClippedBounds(context);
  if (!clippedBounds.isValid())   return;
  for (  Member m : memberList) {
    try {
      gl.glEnable(GL.GL_SCISSOR_TEST);
      gl.glViewport(bounds.getX(),bounds.getY(),bounds.getWidth(),bounds.getHeight());
      gl.glScissor(clippedBounds.getX(),clippedBounds.getY(),clippedBounds.getWidth(),clippedBounds.getHeight());
      if (m.callback != null)       m.callback.prePaint(m.painter,context);
      m.painter.paintTo(context);
      if (m.callback != null)       m.callback.postPaint(m.painter,context);
    }
  finally {
      gl.glDisable(GL.GL_SCISSOR_TEST);
    }
  }
}",0.6106240330067045
11643,"protected void initializePainters(){
  this.titleLayout=new GlimpseLayout(this,""String_Node_Str"");
  this.axisLayoutXY=new GlimpseAxisLayout2D(this,""String_Node_Str"",new Axis2D(centerAxisX,centerAxisY));
  this.titlePainter=createTitlePainter();
  if (titlePainter != null)   titleLayout.addPainter(titlePainter);
  this.setTitleFont(getDefaultTitleFont(),false);
  this.plotBackgroundPainter=new BackgroundPainter(false);
  this.axisLayoutXY.addPainter(this.plotBackgroundPainter);
  this.mouseListenerXY=createAxisMouseListenerXY();
  this.attachAxisMouseListener(axisLayoutXY,mouseListenerXY);
}","protected void initializePainters(){
  this.backgroundPainter=new BackgroundPainter(true);
  super.addPainter(this.backgroundPainter);
  this.titleLayout=new GlimpseLayout(this,""String_Node_Str"");
  this.axisLayoutXY=new GlimpseAxisLayout2D(this,""String_Node_Str"",new Axis2D(centerAxisX,centerAxisY));
  this.titlePainter=createTitlePainter();
  if (titlePainter != null)   titleLayout.addPainter(titlePainter);
  this.setTitleFont(getDefaultTitleFont(),false);
  this.plotBackgroundPainter=new BackgroundPainter(false);
  this.axisLayoutXY.addPainter(this.plotBackgroundPainter);
  this.mouseListenerXY=createAxisMouseListenerXY();
  this.attachAxisMouseListener(axisLayoutXY,mouseListenerXY);
}",0.9242658423493044
11644,"protected void initialize(){
  initializeAxes();
  initializePainters();
  attachAxisMouseListeners();
  initializeLookAndFeel();
  updatePainterLayout();
}","protected void initialize(){
  initializeAxes();
  initializeParentLayout();
  initializePainters();
  attachAxisMouseListeners();
  initializeLookAndFeel();
  updatePainterLayout();
}",0.9176470588235294
11645,"public void invalidateLayout(){
  lock.lock();
  try {
    layoutCache.clear();
    layoutDelegate.invalidateLayout();
  }
  finally {
    lock.unlock();
  }
}","public void invalidateLayout(){
  lock.lock();
  try {
    layoutClean.clear();
    layoutDelegate.invalidateLayout();
  }
  finally {
    lock.unlock();
  }
}",0.981132075471698
11646,"protected List<Tag> copyTags(List<Tag> list){
  List<Tag> newList=new ArrayList<Tag>(list.size());
  for (  Tag tag : newList) {
    newList.add(new Tag(tag));
  }
  return newList;
}","protected List<Tag> copyTags(List<Tag> list){
  List<Tag> newList=new ArrayList<Tag>(list.size());
  for (  Tag tag : list) {
    newList.add(new Tag(tag));
  }
  return newList;
}",0.9862258953168044
11647,"public GlimpseLayoutDelegate(GlimpseLayout layout){
  this.layout=layout;
  this.layoutChildren=new ArrayList<GlimpseLayoutDelegate>();
  this.memberList=new ArrayList<Member>();
  this.memberMap=new LinkedHashMap<GlimpsePainter,Member>();
}","public GlimpseLayoutDelegate(GlimpseLayout layout){
  this.layout=layout;
  this.layoutChildren=new ArrayList<GlimpseLayoutDelegate>();
  this.memberList=new ArrayList<Member>();
  this.memberMap=new LinkedHashMap<GlimpsePainter,Member>();
  this.backgroundPainter=new BackgroundPainter(true);
  this.backgroundPainterEnabled=true;
}",0.8397212543554007
11648,"public void setLookAndFeel(LookAndFeel laf){
  for (  Member m : memberList) {
    m.painter.setLookAndFeel(laf);
  }
}","public void setLookAndFeel(LookAndFeel laf){
  backgroundPainter.setLookAndFeel(laf);
  for (  Member m : memberList) {
    m.painter.setLookAndFeel(laf);
  }
}",0.8530465949820788
11649,"public void paintTo(GlimpseContext context){
  GL gl=context.getGL();
  GlimpseBounds bounds=context.getTargetStack().getBounds();
  GlimpseBounds clippedBounds=getClippedBounds(context);
  if (!clippedBounds.isValid())   return;
  for (  Member m : memberList) {
    try {
      gl.glEnable(GL.GL_SCISSOR_TEST);
      gl.glViewport(bounds.getX(),bounds.getY(),bounds.getWidth(),bounds.getHeight());
      gl.glScissor(clippedBounds.getX(),clippedBounds.getY(),clippedBounds.getWidth(),clippedBounds.getHeight());
      if (m.callback != null)       m.callback.prePaint(m.painter,context);
      m.painter.paintTo(context);
      if (m.callback != null)       m.callback.postPaint(m.painter,context);
    }
  finally {
      gl.glDisable(GL.GL_SCISSOR_TEST);
    }
  }
}","public void paintTo(GlimpseContext context){
  GL gl=context.getGL();
  GlimpseBounds bounds=context.getTargetStack().getBounds();
  GlimpseBounds clippedBounds=getClippedBounds(context);
  if (!clippedBounds.isValid())   return;
  if (backgroundPainterEnabled) {
    try {
      gl.glEnable(GL.GL_SCISSOR_TEST);
      gl.glViewport(bounds.getX(),bounds.getY(),bounds.getWidth(),bounds.getHeight());
      gl.glScissor(clippedBounds.getX(),clippedBounds.getY(),clippedBounds.getWidth(),clippedBounds.getHeight());
      this.backgroundPainter.paintTo(context);
    }
  finally {
      gl.glDisable(GL.GL_SCISSOR_TEST);
    }
  }
  for (  Member m : memberList) {
    try {
      gl.glEnable(GL.GL_SCISSOR_TEST);
      gl.glViewport(bounds.getX(),bounds.getY(),bounds.getWidth(),bounds.getHeight());
      gl.glScissor(clippedBounds.getX(),clippedBounds.getY(),clippedBounds.getWidth(),clippedBounds.getHeight());
      if (m.callback != null)       m.callback.prePaint(m.painter,context);
      m.painter.paintTo(context);
      if (m.callback != null)       m.callback.postPaint(m.painter,context);
    }
  finally {
      gl.glDisable(GL.GL_SCISSOR_TEST);
    }
  }
}",0.6106240330067045
11650,"protected void initializePainters(){
  this.backgroundPainter=new BackgroundPainter(true);
  super.addPainter(this.backgroundPainter);
  this.titleLayout=new GlimpseLayout(this,""String_Node_Str"");
  this.axisLayoutXY=new GlimpseAxisLayout2D(this,""String_Node_Str"",new Axis2D(centerAxisX,centerAxisY));
  this.titlePainter=createTitlePainter();
  if (titlePainter != null)   titleLayout.addPainter(titlePainter);
  this.setTitleFont(getDefaultTitleFont(),false);
  this.plotBackgroundPainter=new BackgroundPainter(false);
  this.axisLayoutXY.addPainter(this.plotBackgroundPainter);
  this.mouseListenerXY=createAxisMouseListenerXY();
  this.attachAxisMouseListener(axisLayoutXY,mouseListenerXY);
}","protected void initializePainters(){
  this.titleLayout=new GlimpseLayout(this,""String_Node_Str"");
  this.axisLayoutXY=new GlimpseAxisLayout2D(this,""String_Node_Str"",new Axis2D(centerAxisX,centerAxisY));
  this.titlePainter=createTitlePainter();
  if (titlePainter != null)   titleLayout.addPainter(titlePainter);
  this.setTitleFont(getDefaultTitleFont(),false);
  this.plotBackgroundPainter=new BackgroundPainter(false);
  this.axisLayoutXY.addPainter(this.plotBackgroundPainter);
  this.mouseListenerXY=createAxisMouseListenerXY();
  this.attachAxisMouseListener(axisLayoutXY,mouseListenerXY);
}",0.9242658423493044
11651,"protected void initialize(){
  initializeAxes();
  initializeParentLayout();
  initializePainters();
  attachAxisMouseListeners();
  initializeLookAndFeel();
  updatePainterLayout();
}","protected void initialize(){
  initializeAxes();
  initializePainters();
  attachAxisMouseListeners();
  initializeLookAndFeel();
  updatePainterLayout();
}",0.9176470588235294
11652,"public SwingLookAndFeel(){
  map.put(CROSSHAIR_COLOR,getBlack());
  map.put(PLOT_BACKGROUND_COLOR,fromColorAwt(SystemColor.control));
  map.put(FRAME_BACKGROUND_COLOR,fromColorAwt(SystemColor.controlHighlight));
  map.put(AXIS_FONT,getDefaultPlain(11));
  map.put(TITLE_FONT,getDefaultPlain(14));
}","public SwingLookAndFeel(){
  map.put(CROSSHAIR_COLOR,getBlack());
  map.put(PLOT_BACKGROUND_COLOR,fromColorAwt(SystemColor.windowBorder));
  map.put(FRAME_BACKGROUND_COLOR,fromColorAwt(SystemColor.window));
  map.put(AXIS_FONT,getDefaultPlain(11));
  map.put(TITLE_FONT,getDefaultPlain(14));
}",0.9306260575296108
11653,"public SwingLookAndFeel(){
  map.put(CROSSHAIR_COLOR,getBlack());
  map.put(PLOT_BACKGROUND_COLOR,fromColorAwt(SystemColor.windowBorder));
  map.put(FRAME_BACKGROUND_COLOR,fromColorAwt(SystemColor.window));
  map.put(AXIS_FONT,getDefaultPlain(11));
  map.put(TITLE_FONT,getDefaultPlain(14));
}","public SwingLookAndFeel(){
  map.put(CROSSHAIR_COLOR,getBlack());
  map.put(PLOT_BACKGROUND_COLOR,addRgb(fromColorAwt(SystemColor.window),-0.1f));
  map.put(FRAME_BACKGROUND_COLOR,fromColorAwt(SystemColor.window));
  map.put(AXIS_FONT,getDefaultPlain(11));
  map.put(TITLE_FONT,getDefaultPlain(14));
}",0.9663299663299664
11654,"protected void paintToVertical(GL gl,int width,int height,Rectangle2D textBounds){
  int xText=padding;
  int yText=padding;
  double textWidth=textBounds.getWidth();
  double textHeight=textBounds.getHeight();
  double halfTextWidth=textWidth / 2d;
  double halfTextHeight=textHeight / 2d;
switch (hPos) {
case Left:
    xText=(int)(padding - halfTextWidth + halfTextHeight);
  break;
case Center:
xText=(int)(width / 2d - halfTextWidth);
break;
case Right:
xText=(int)(width - halfTextWidth - halfTextHeight- padding);
break;
}
switch (vPos) {
case Bottom:
yText=(int)(padding - halfTextHeight + halfTextWidth);
break;
case Center:
yText=(int)(height / 2d - halfTextHeight);
break;
case Top:
yText=(int)(height - halfTextHeight - halfTextWidth- padding);
break;
}
if (this.paintBackground) {
gl.glMatrixMode(GL.GL_PROJECTION);
gl.glLoadIdentity();
gl.glOrtho(0,width,0,height,-1,1);
gl.glMatrixMode(GL.GL_MODELVIEW);
gl.glLoadIdentity();
gl.glBlendFunc(GL.GL_SRC_ALPHA,GL.GL_ONE_MINUS_SRC_ALPHA);
gl.glEnable(GL.GL_BLEND);
int buffer=2;
int xTextMin=(int)(xText + halfTextWidth - halfTextHeight - buffer);
int yTextMin=(int)(yText + halfTextWidth + halfTextHeight+ buffer);
int xTextMax=(int)(xText + halfTextWidth + halfTextHeight+ buffer+ 3);
int yTextMax=(int)(yText - halfTextWidth + halfTextHeight - buffer);
gl.glColor4fv(backgroundColor,0);
gl.glBegin(GL.GL_QUADS);
try {
gl.glVertex2f(xTextMin,yTextMin);
gl.glVertex2f(xTextMax,yTextMin);
gl.glVertex2f(xTextMax,yTextMax);
gl.glVertex2f(xTextMin,yTextMax);
}
  finally {
gl.glEnd();
}
}
gl.glDisable(GL.GL_BLEND);
textRenderer.beginRendering(width,height);
try {
double xShift=xText + halfTextWidth;
double yShift=yText + halfTextHeight;
gl.glMatrixMode(GL.GL_PROJECTION);
gl.glTranslated(xShift,yShift,0);
gl.glRotated(90,0,0,1.0f);
gl.glTranslated(-xShift,-yShift,0);
textRenderer.setColor(textColor[0],textColor[1],textColor[2],textColor[3]);
textRenderer.draw(text,xText,yText);
}
  finally {
textRenderer.endRendering();
}
}","protected void paintToVertical(GL gl,int width,int height,Rectangle2D textBounds){
  int xText=padding;
  int yText=padding;
  double textWidth=textBounds.getWidth();
  double textHeight=textBounds.getHeight();
  int halfTextWidth=(int)(textWidth / 2d);
  int halfTextHeight=(int)(textHeight / 2d);
switch (hPos) {
case Left:
    xText=(int)(padding - halfTextWidth + halfTextHeight);
  break;
case Center:
xText=(int)(width / 2d - halfTextWidth);
break;
case Right:
xText=(int)(width - halfTextWidth - halfTextHeight- padding);
break;
}
switch (vPos) {
case Bottom:
yText=(int)(padding - halfTextHeight + halfTextWidth);
break;
case Center:
yText=(int)(height / 2d - halfTextHeight);
break;
case Top:
yText=(int)(height - halfTextHeight - halfTextWidth- padding);
break;
}
if (this.paintBackground) {
gl.glMatrixMode(GL.GL_PROJECTION);
gl.glLoadIdentity();
gl.glOrtho(0,width,0,height,-1,1);
gl.glMatrixMode(GL.GL_MODELVIEW);
gl.glLoadIdentity();
gl.glBlendFunc(GL.GL_SRC_ALPHA,GL.GL_ONE_MINUS_SRC_ALPHA);
gl.glEnable(GL.GL_BLEND);
int buffer=2;
int xTextMin=(int)(xText + halfTextWidth - halfTextHeight - buffer);
int yTextMin=(int)(yText + halfTextWidth + halfTextHeight+ buffer);
int xTextMax=(int)(xText + halfTextWidth + halfTextHeight+ buffer+ 3);
int yTextMax=(int)(yText - halfTextWidth + halfTextHeight - buffer);
gl.glColor4fv(backgroundColor,0);
gl.glBegin(GL.GL_QUADS);
try {
gl.glVertex2f(xTextMin,yTextMin);
gl.glVertex2f(xTextMax,yTextMin);
gl.glVertex2f(xTextMax,yTextMax);
gl.glVertex2f(xTextMin,yTextMax);
}
  finally {
gl.glEnd();
}
}
gl.glDisable(GL.GL_BLEND);
textRenderer.beginRendering(width,height);
try {
double xShift=xText + halfTextWidth;
double yShift=yText + halfTextHeight;
gl.glMatrixMode(GL.GL_PROJECTION);
gl.glTranslated(xShift,yShift,0);
gl.glRotated(90,0,0,1.0f);
gl.glTranslated(-xShift,-yShift,0);
textRenderer.setColor(textColor[0],textColor[1],textColor[2],textColor[3]);
textRenderer.draw(text,xText,yText);
}
  finally {
textRenderer.endRendering();
}
}",0.989964877069744
11655,"@Override public void paintTo(GlimpseContext context,GlimpseBounds bounds,Axis2D axis){
  GL gl=context.getGL();
  int width=bounds.getWidth();
  int height=bounds.getHeight();
  gl.glMatrixMode(GL.GL_PROJECTION);
  gl.glLoadIdentity();
  gl.glOrtho(0,width,0,height,-1,1);
  gl.glMatrixMode(GL.GL_MODELVIEW);
  gl.glLoadIdentity();
  gl.glBlendFunc(GL.GL_SRC_ALPHA,GL.GL_ONE_MINUS_SRC_ALPHA);
  gl.glEnable(GL.GL_BLEND);
  gl.glEnable(GL.GL_LINE_SMOOTH);
  gl.glEnable(GL.GL_POINT_SMOOTH);
  if (isVisible() && !list.isEmpty()) {
    displayLegend(gl,width,height);
  }
}","@Override public void paintTo(GlimpseContext context,GlimpseBounds bounds,Axis2D axis){
  if (newFont != null) {
    if (textRenderer != null)     textRenderer.dispose();
    textRenderer=new TextRenderer(newFont,antialias,false);
    newFont=null;
  }
  GL gl=context.getGL();
  int width=bounds.getWidth();
  int height=bounds.getHeight();
  gl.glMatrixMode(GL.GL_PROJECTION);
  gl.glLoadIdentity();
  gl.glOrtho(0,width,0,height,-1,1);
  gl.glMatrixMode(GL.GL_MODELVIEW);
  gl.glLoadIdentity();
  gl.glBlendFunc(GL.GL_SRC_ALPHA,GL.GL_ONE_MINUS_SRC_ALPHA);
  gl.glEnable(GL.GL_BLEND);
  gl.glEnable(GL.GL_LINE_SMOOTH);
  gl.glEnable(GL.GL_POINT_SMOOTH);
  if (isVisible() && !list.isEmpty()) {
    displayLegend(gl,width,height);
  }
}",0.8739495798319328
11656,"@Override public void dispose(GLContext context){
  if (textRenderer != null)   textRenderer.dispose();
  textRenderer=null;
}","@Override public void dispose(GlimpseContext context){
  if (textRenderer != null)   textRenderer.dispose();
  textRenderer=null;
}",0.9727626459143968
11657,"public void setFont(float size,boolean bold){
  setFont(bold ? FontUtils.getDefaultBold(size) : FontUtils.getDefaultPlain(size));
}","public LegendPainter setFont(int size,boolean bold,boolean antialias){
  if (bold) {
    setFont(getDefaultBold(size),antialias);
  }
 else {
    setFont(getDefaultPlain(size),antialias);
  }
  return this;
}",0.3126843657817109
11658,"protected void initializeTimePlot(){
  TaggedAxis1D timeAxis=getTimeAxis();
  this.timelineMouseListener=new TimelineMouseListener1D(this);
  this.addTimeTags(getTimeAxis());
  this.minTag=timeAxis.getTag(MIN_TIME);
  this.maxTag=timeAxis.getTag(MAX_TIME);
  this.currentTag=timeAxis.getTag(CURRENT_TIME);
  this.timelineInfo=createPlot(TIMELINE);
  if (isTimeAxisHorizontal()) {
    this.timelineInfo.setSize(45);
    this.timelineInfo.setOrder(Integer.MAX_VALUE);
    this.timeLayout=new GlimpseAxisLayoutX(this.timelineInfo.getLayout());
    this.labelLayoutSize=30;
  }
 else {
    this.timelineInfo.setSize(60);
    this.timelineInfo.setOrder(Integer.MIN_VALUE);
    this.timeLayout=new GlimpseAxisLayoutY(this.timelineInfo.getLayout());
    this.labelLayoutSize=30;
  }
  this.timeLayout.addGlimpseMouseAllListener(this.timelineMouseListener);
  this.timeAxisPainter=createTimeAxisPainter();
  this.timeAxisPainter.setFont(getDefaultPlain(12),false);
  this.timeAxisPainter.showCurrentTimeLabel(false);
  this.timeAxisPainter.setCurrentTimeTickColor(GlimpseColor.getGreen());
  this.setBorderSize(0);
  this.timeAxisDelegate=new DelegatePainter();
  this.timeAxisDelegate.addPainter(this.timeAxisPainter);
  this.timeLayout.addPainter(this.timeAxisDelegate);
  this.timeUnitsPainter=new SimpleTextPainter();
  this.timeUnitsPainter.setHorizontalPosition(HorizontalPosition.Right);
  this.timeUnitsPainter.setVerticalPosition(VerticalPosition.Bottom);
  this.timeUnitsPainter.setColor(GlimpseColor.getBlack());
  this.timeUnitsPainter.setFont(getDefaultBold(12));
  this.timeUnitsPainter.setText(""String_Node_Str"");
  this.timeUnitsPainter.setBackgroundColor(GlimpseColor.getYellow());
  this.timeUnitsPainter.setPaintBackground(true);
  this.timeAxisBorderPainter=new BorderPainter().setColor(GlimpseColor.fromColorRgba(0.8f,0.8f,0.8f,1.0f));
  this.timeLayout.addPainter(this.timeUnitsPainter);
  this.timeLayout.addPainter(this.timeAxisBorderPainter);
  if (isTimeAxisHorizontal()) {
    this.overlayLayout=new GlimpseAxisLayoutX(this,""String_Node_Str"",timeAxis);
    this.underlayLayout=new GlimpseAxisLayoutX(this,""String_Node_Str"",timeAxis);
  }
 else {
    this.overlayLayout=new GlimpseAxisLayoutY(this,""String_Node_Str"",timeAxis);
    this.underlayLayout=new GlimpseAxisLayoutX(this,""String_Node_Str"",timeAxis);
  }
  this.selectedTimePainter=new SelectedTimeRegionPainter(this);
  this.overlayLayout.setEventGenerator(true);
  this.overlayLayout.setEventConsumer(false);
  this.overlayLayout.addPainter(this.selectedTimePainter);
  this.setZOrder(this.overlayLayout,Integer.MAX_VALUE);
  this.setZOrder(this.underlayLayout,Integer.MIN_VALUE);
  this.validate();
}","protected void initializeTimePlot(){
  TaggedAxis1D timeAxis=getTimeAxis();
  this.timelineMouseListener=new TimelineMouseListener1D(this);
  this.addTimeTags(getTimeAxis());
  this.minTag=timeAxis.getTag(MIN_TIME);
  this.maxTag=timeAxis.getTag(MAX_TIME);
  this.currentTag=timeAxis.getTag(CURRENT_TIME);
  this.timelineInfo=createPlot(TIMELINE);
  if (isTimeAxisHorizontal()) {
    this.timelineInfo.setSize(45);
    this.timelineInfo.setOrder(Integer.MAX_VALUE);
    this.timeLayout=new GlimpseAxisLayoutX(this.timelineInfo.getLayout());
    this.labelLayoutSize=30;
  }
 else {
    this.timelineInfo.setSize(60);
    this.timelineInfo.setOrder(Integer.MIN_VALUE);
    this.timeLayout=new GlimpseAxisLayoutY(this.timelineInfo.getLayout());
    this.labelLayoutSize=30;
  }
  this.timeLayout.addGlimpseMouseAllListener(this.timelineMouseListener);
  this.timeAxisPainter=createTimeAxisPainter();
  this.timeAxisPainter.setFont(getDefaultPlain(12),false);
  this.timeAxisPainter.showCurrentTimeLabel(false);
  this.timeAxisPainter.setCurrentTimeTickColor(GlimpseColor.getGreen());
  this.setBorderSize(0);
  this.timeAxisDelegate=new DelegatePainter();
  this.timeAxisDelegate.addPainter(this.timeAxisPainter);
  this.timeLayout.addPainter(this.timeAxisDelegate);
  this.timeUnitsPainter=new SimpleTextPainter();
  this.timeUnitsPainter.setHorizontalPosition(HorizontalPosition.Right);
  this.timeUnitsPainter.setVerticalPosition(VerticalPosition.Bottom);
  this.timeUnitsPainter.setColor(GlimpseColor.getBlack());
  this.timeUnitsPainter.setFont(getDefaultBold(12));
  this.timeUnitsPainter.setText(""String_Node_Str"");
  this.timeUnitsPainter.setBackgroundColor(GlimpseColor.getYellow());
  this.timeUnitsPainter.setPaintBackground(true);
  this.timeAxisBorderPainter=new BorderPainter().setColor(GlimpseColor.fromColorRgba(0.8f,0.8f,0.8f,1.0f));
  this.timeLayout.addPainter(this.timeUnitsPainter);
  this.timeLayout.addPainter(this.timeAxisBorderPainter);
  if (isTimeAxisHorizontal()) {
    this.overlayLayout=new GlimpseAxisLayoutX(this,""String_Node_Str"",timeAxis);
    this.underlayLayout=new GlimpseAxisLayoutX(this,""String_Node_Str"",timeAxis);
  }
 else {
    this.overlayLayout=new GlimpseAxisLayoutY(this,""String_Node_Str"",timeAxis);
    this.underlayLayout=new GlimpseAxisLayoutY(this,""String_Node_Str"",timeAxis);
  }
  this.selectedTimePainter=new SelectedTimeRegionPainter(this);
  this.overlayLayout.setEventGenerator(true);
  this.overlayLayout.setEventConsumer(false);
  this.overlayLayout.addPainter(this.selectedTimePainter);
  this.setZOrder(this.overlayLayout,Integer.MAX_VALUE);
  this.setZOrder(this.underlayLayout,Integer.MIN_VALUE);
  this.validate();
}",0.9996265870052278
11659,"@Override public void paintTo(GlimpseContext context){
  if (!displayOn)   return;
  GlimpseBounds bounds=context.getTargetStack().getBounds();
  if (bounds == null)   return;
  int width=bounds.getWidth();
  int height=bounds.getHeight();
  if (width <= 0 || height <= 0)   return;
  GL gl=context.getGL();
  gl.glPushClientAttrib((int)GL.GL_CLIENT_ALL_ATTRIB_BITS);
  gl.glPushAttrib(GL.GL_ALL_ATTRIB_BITS);
  gl.glMatrixMode(GL.GL_MODELVIEW);
  gl.glPushMatrix();
  gl.glMatrixMode(GL.GL_PROJECTION);
  gl.glPushMatrix();
  try {
    paintTo(context,bounds);
    if (doErrorHandling)     glHandleError(gl,""String_Node_Str"" + getClass().getName());
  }
  finally {
    gl.glMatrixMode(GL.GL_MODELVIEW);
    gl.glPopMatrix();
    gl.glMatrixMode(GL.GL_PROJECTION);
    gl.glPopMatrix();
    gl.glPopAttrib();
    gl.glPopClientAttrib();
  }
}","@Override public void paintTo(GlimpseContext context){
  if (!displayOn)   return;
  GlimpseBounds bounds=context.getTargetStack().getBounds();
  if (bounds == null)   return;
  int width=bounds.getWidth();
  int height=bounds.getHeight();
  if (width <= 0 || height <= 0)   return;
  GL gl=context.getGL();
  gl.glPushClientAttrib((int)GL.GL_CLIENT_ALL_ATTRIB_BITS);
  gl.glPushAttrib(GL.GL_ALL_ATTRIB_BITS);
  gl.glMatrixMode(GL.GL_MODELVIEW);
  gl.glPushMatrix();
  gl.glMatrixMode(GL.GL_PROJECTION);
  gl.glPushMatrix();
  try {
    paintTo(context,bounds);
    if (doErrorHandling)     glHandleError(gl,errorPrefix);
  }
  finally {
    gl.glMatrixMode(GL.GL_MODELVIEW);
    gl.glPopMatrix();
    gl.glMatrixMode(GL.GL_PROJECTION);
    gl.glPopMatrix();
    gl.glPopAttrib();
    gl.glPopClientAttrib();
  }
}",0.9692214846107424
11660,"@Override public void paintTo(GlimpseContext context,GlimpseBounds bounds,Axis2D axis){
  GL gl=context.getGL();
  int width=bounds.getWidth();
  int height=bounds.getHeight();
  Axis1D axisX=axis.getAxisX();
  Axis1D axisY=axis.getAxisY();
  double[] xPositions=ticksX.getTickPositions(axis.getAxisX());
  double[] yPositions=ticksY.getTickPositions(axis.getAxisY());
  AxisUnitConverter convX=ticksX.getAxisUnitConverter();
  convX=convX == null ? new AxisUnitConverter(){
    public double toAxisUnits(    double value){
      return value;
    }
    public double fromAxisUnits(    double value){
      return value;
    }
  }
 : convX;
  AxisUnitConverter convY=ticksY.getAxisUnitConverter();
  convY=convY == null ? new AxisUnitConverter(){
    public double toAxisUnits(    double value){
      return value;
    }
    public double fromAxisUnits(    double value){
      return value;
    }
  }
 : convY;
  double onePixelX=0.5 / axisX.getPixelsPerValue();
  double onePixelY=0.5 / axisY.getPixelsPerValue();
  int originY=axisY.valueToScreenPixel(0.0);
  if (originY < 0 || lockBottom)   originY=0;
  if (originY > height || lockTop)   originY=height;
  int originX=axisX.valueToScreenPixel(0.0);
  if (originX < 0 || lockLeft)   originX=0;
  if (originX > width || lockRight)   originX=width;
  boolean rightCornerX=false;
  boolean leftCornerX=false;
  boolean topCornerY=false;
  boolean bottomCornerY=false;
  double doriginX=0.0;
  if (doriginX <= axisX.getMin() || lockLeft) {
    doriginX=axisX.getMin() + onePixelX;
    leftCornerX=true;
  }
  if (doriginX > axisX.getMax() || lockRight) {
    doriginX=axisX.getMax();
    rightCornerX=true;
  }
  double doriginY=0.0;
  if (doriginY <= axisY.getMin() || lockBottom) {
    doriginY=axisY.getMin() + onePixelY;
    topCornerY=true;
  }
  if (doriginY > axisY.getMax() || lockTop) {
    doriginY=axisY.getMax();
    bottomCornerY=true;
  }
  boolean labelRight=width - originX > rightBuffer;
  boolean labelTop=height - originY > topBuffer;
  GlimpseColor.setColor(textRenderer,textColor);
  textRenderer.beginRendering(width,height);
  try {
    if (showHorizontal) {
      String[] xLabels=ticksX.getTickLabels(axis.getAxisX(),xPositions);
      int offsetY;
      if (labelTop) {
        offsetY=tickWidth + labelBuffer;
      }
 else {
        Rectangle2D textBounds=textRenderer.getBounds(xLabels[0]);
        offsetY=(int)-(textBounds.getHeight() + tickWidth + labelBuffer);
      }
      for (int i=0; i < xPositions.length; i++) {
        String label=xLabels[i];
        double valueX=xPositions[i];
        if (valueX == 0.0 && !showZero)         continue;
        int posX=axisX.valueToScreenPixel(valueX);
        if (shouldPaintLabel(rightCornerX,leftCornerX,posX,width,rightBuffer))         textRenderer.draw(label,posX + labelBuffer,originY + offsetY);
      }
    }
    if (showVertical) {
      String[] yLabels=ticksY.getTickLabels(axis.getAxisY(),yPositions);
      for (int i=0; i < yPositions.length; i++) {
        String label=yLabels[i];
        Rectangle2D textBounds=textRenderer.getBounds(label);
        double valueY=yPositions[i];
        if (valueY == 0.0 && !showZero)         continue;
        int offsetX;
        if (labelRight) {
          offsetX=tickWidth + labelBuffer;
        }
 else {
          offsetX=(int)-(textBounds.getWidth() + tickWidth + labelBuffer);
        }
        int posY=axisY.valueToScreenPixel(valueY);
        if (shouldPaintLabel(bottomCornerY,topCornerY,posY,height,topBuffer))         textRenderer.draw(label,originX + offsetX,posY + labelBuffer);
      }
    }
  }
  finally {
    textRenderer.endRendering();
  }
  gl.glMatrixMode(GL.GL_PROJECTION);
  gl.glLoadIdentity();
  gl.glOrtho(-0.5,width - 1 + 0.5f,-0.5,height - 1 + 0.5f,-1,1);
  GlimpseColor.glColor(gl,lineColor);
  gl.glBegin(GL.GL_LINES);
  try {
    if (showHorizontal) {
      double tickWidthX=tickWidth / axisY.getPixelsPerValue();
      for (int i=0; i < xPositions.length; i++) {
        double valueX=xPositions[i];
        int tick=axisX.valueToScreenPixel(convX.fromAxisUnits(valueX));
        gl.glVertex2d(tick,axisY.valueToScreenPixelUnits(doriginY - tickWidthX));
        gl.glVertex2d(tick,axisY.valueToScreenPixelUnits(doriginY + tickWidthX));
        if (labelTop) {
          gl.glVertex2d(tick,axisY.valueToScreenPixelUnits(doriginY + tickWidthX));
          gl.glVertex2d(tick + labelBuffer - 1,axisY.valueToScreenPixelUnits(doriginY + tickWidthX) + labelBuffer - 1);
        }
 else {
          gl.glVertex2d(tick,axisY.valueToScreenPixelUnits(doriginY - tickWidthX));
          gl.glVertex2d(tick + labelBuffer - 1,axisY.valueToScreenPixelUnits(doriginY - tickWidthX) - labelBuffer + 1);
        }
      }
    }
    if (showVertical) {
      double tickWidthY=tickWidth / axisX.getPixelsPerValue();
      for (int i=0; i < yPositions.length; i++) {
        double valueY=yPositions[i];
        int tick=axisY.valueToScreenPixel(convY.fromAxisUnits(valueY));
        gl.glVertex2d(axisX.valueToScreenPixelUnits(doriginX - tickWidthY),tick);
        gl.glVertex2d(axisX.valueToScreenPixelUnits(doriginX + tickWidthY),tick);
        if (labelRight) {
          gl.glVertex2d(axisX.valueToScreenPixelUnits(doriginX + tickWidthY),tick);
          gl.glVertex2d(axisX.valueToScreenPixelUnits(doriginX + tickWidthY) + labelBuffer - 1,tick + labelBuffer - 1);
        }
 else {
          gl.glVertex2d(axisX.valueToScreenPixelUnits(doriginX - tickWidthY),tick);
          gl.glVertex2d(axisX.valueToScreenPixelUnits(doriginX - tickWidthY) - labelBuffer + 1,tick + labelBuffer - 1);
        }
      }
    }
    if (showHorizontal && showOrigin) {
      gl.glVertex2d(axisX.valueToScreenPixel(convX.fromAxisUnits(axis.getMinX())),axisY.valueToScreenPixel(convY.fromAxisUnits(doriginY)));
      gl.glVertex2d(axisX.valueToScreenPixel(convX.fromAxisUnits(axis.getMaxX())),axisY.valueToScreenPixel(convY.fromAxisUnits(doriginY)));
    }
    if (showVertical && showOrigin) {
      gl.glVertex2d(axisX.valueToScreenPixel(convX.fromAxisUnits(doriginX)),axisY.valueToScreenPixel(convY.fromAxisUnits(axis.getMinY())));
      gl.glVertex2d(axisX.valueToScreenPixel(convX.fromAxisUnits(doriginX)),axisY.valueToScreenPixel(convY.fromAxisUnits(axis.getMaxY())));
    }
  }
  finally {
    gl.glEnd();
  }
}","@Override public void paintTo(GlimpseContext context,GlimpseBounds bounds,Axis2D axis){
  GL gl=context.getGL();
  int width=bounds.getWidth();
  int height=bounds.getHeight();
  Axis1D axisX=axis.getAxisX();
  Axis1D axisY=axis.getAxisY();
  double[] positionsX=ticksX.getTickPositions(axis.getAxisX());
  double[] positionsY=ticksY.getTickPositions(axis.getAxisY());
  AxisUnitConverter convX=ticksX.getAxisUnitConverter();
  convX=convX == null ? AxisUnitConverters.identity : convX;
  AxisUnitConverter convY=ticksY.getAxisUnitConverter();
  convY=convY == null ? AxisUnitConverters.identity : convY;
  double onePixelX=0.5 / axisX.getPixelsPerValue();
  double onePixelY=0.5 / axisY.getPixelsPerValue();
  int originY=axisY.valueToScreenPixel(0.0);
  if (originY < 0 || lockBottom)   originY=0;
  if (originY > height || lockTop)   originY=height;
  int originX=axisX.valueToScreenPixel(0.0);
  if (originX < 0 || lockLeft)   originX=0;
  if (originX > width || lockRight)   originX=width;
  boolean rightCornerX=false;
  boolean leftCornerX=false;
  boolean topCornerY=false;
  boolean bottomCornerY=false;
  double doriginX=0.0;
  if (doriginX <= axisX.getMin() || lockLeft) {
    doriginX=axisX.getMin() + onePixelX;
    leftCornerX=true;
  }
  if (doriginX > axisX.getMax() || lockRight) {
    doriginX=axisX.getMax();
    rightCornerX=true;
  }
  double doriginY=0.0;
  if (doriginY <= axisY.getMin() || lockBottom) {
    doriginY=axisY.getMin() + onePixelY;
    topCornerY=true;
  }
  if (doriginY > axisY.getMax() || lockTop) {
    doriginY=axisY.getMax();
    bottomCornerY=true;
  }
  boolean labelRight=width - originX > rightBuffer;
  boolean labelTop=height - originY > topBuffer;
  boolean[] paintLabelsX=new boolean[positionsX.length];
  boolean[] paintLabelsY=new boolean[positionsY.length];
  GlimpseColor.setColor(textRenderer,textColor);
  textRenderer.beginRendering(width,height);
  try {
    if (showHorizontal) {
      String[] labelsX=ticksX.getTickLabels(axis.getAxisX(),positionsX);
      int offsetY;
      if (labelTop) {
        offsetY=tickWidth + labelBuffer;
      }
 else {
        Rectangle2D textBounds=textRenderer.getBounds(labelsX[0]);
        offsetY=(int)-(textBounds.getHeight() + tickWidth + labelBuffer);
      }
      for (int i=0; i < positionsX.length; i++) {
        String label=labelsX[i];
        double valueX=positionsX[i];
        if (valueX == 0.0 && !showZero)         continue;
        int posX=axisX.valueToScreenPixel(valueX);
        paintLabelsX[i]=shouldPaintLabel(rightCornerX,leftCornerX,posX,width,rightBuffer);
        if (paintLabelsX[i])         textRenderer.draw(label,posX + labelBuffer,originY + offsetY);
      }
    }
    if (showVertical) {
      String[] labelsY=ticksY.getTickLabels(axis.getAxisY(),positionsY);
      for (int i=0; i < positionsY.length; i++) {
        String label=labelsY[i];
        Rectangle2D textBounds=textRenderer.getBounds(label);
        double valueY=positionsY[i];
        if (valueY == 0.0 && !showZero)         continue;
        int offsetX;
        if (labelRight) {
          offsetX=tickWidth + labelBuffer;
        }
 else {
          offsetX=(int)-(textBounds.getWidth() + tickWidth + labelBuffer);
        }
        int posY=axisY.valueToScreenPixel(valueY);
        paintLabelsY[i]=shouldPaintLabel(bottomCornerY,topCornerY,posY,height,topBuffer);
        if (paintLabelsY[i])         textRenderer.draw(label,originX + offsetX,posY + labelBuffer);
      }
    }
  }
  finally {
    textRenderer.endRendering();
  }
  gl.glMatrixMode(GL.GL_PROJECTION);
  gl.glLoadIdentity();
  gl.glOrtho(axis.getMinX(),axis.getMaxX(),axis.getMinY(),axis.getMaxY(),-1,1);
  GlimpseColor.glColor(gl,lineColor);
  double labelBufferX=labelBuffer / axisX.getPixelsPerValue();
  double labelBufferY=labelBuffer / axisY.getPixelsPerValue();
  gl.glBegin(GL.GL_LINES);
  try {
    if (showHorizontal) {
      double tickWidthY=tickWidth / axisY.getPixelsPerValue();
      for (int i=0; i < positionsX.length; i++) {
        if (paintLabelsX[i]) {
          double valueX=convX.fromAxisUnits(positionsX[i]);
          gl.glVertex2d(valueX,doriginY - tickWidthY);
          gl.glVertex2d(valueX,doriginY + tickWidthY);
          if (labelTop) {
            gl.glVertex2d(valueX,doriginY + tickWidthY);
            gl.glVertex2d(valueX + labelBufferX,doriginY + tickWidthY + labelBufferY);
          }
 else {
            gl.glVertex2d(valueX,doriginY - tickWidthY);
            gl.glVertex2d(valueX + labelBufferX,doriginY - tickWidthY - labelBufferY);
          }
        }
      }
    }
    if (showVertical) {
      double tickWidthX=tickWidth / axisX.getPixelsPerValue();
      for (int i=0; i < positionsY.length; i++) {
        if (paintLabelsY[i]) {
          double valueY=convY.fromAxisUnits(positionsY[i]);
          gl.glVertex2d(doriginX - tickWidthX,valueY);
          gl.glVertex2d(doriginX + tickWidthX,valueY);
          if (labelRight) {
            gl.glVertex2d(doriginX + tickWidthX,valueY);
            gl.glVertex2d(doriginX + tickWidthX + labelBufferX,valueY + labelBufferY);
          }
 else {
            gl.glVertex2d(doriginX - tickWidthX,valueY);
            gl.glVertex2d(doriginX - tickWidthX - labelBufferX,valueY + labelBufferY);
          }
        }
      }
    }
    if (showHorizontal && showOrigin) {
      gl.glVertex2d(convX.fromAxisUnits(axis.getMinX()),convY.fromAxisUnits(doriginY));
      gl.glVertex2d(convX.fromAxisUnits(axis.getMaxX()),convY.fromAxisUnits(doriginY));
    }
    if (showVertical && showOrigin) {
      gl.glVertex2d(convX.fromAxisUnits(doriginX),convY.fromAxisUnits(axis.getMinY()));
      gl.glVertex2d(convX.fromAxisUnits(doriginX),convY.fromAxisUnits(axis.getMaxY()));
    }
  }
  finally {
    gl.glEnd();
  }
}",0.8058984342639384
11661,"/** 
 * Sets whether or not zooming of the Y axis is allowed for all timeline and plot axes. This setting will also affect newly created plots.
 * @param lock whether to allow zooming of the Y axis
 * @see AxisMouseListener#setAllowZoomY(boolean)
 */
public void setAllowZoomY(boolean lock){
  this.allowZoomY=lock;
  if (this.getOrientation() == Orientation.HORIZONTAL) {
    this.timelineMouseListener.setAllowZoom(lock);
  }
  for (  TimePlotInfo info : getAllTimePlots()) {
    info.getTimelineMouseListener().setAllowZoomY(lock);
  }
}","/** 
 * Sets whether or not zooming of the Y axis is allowed for all timeline and plot axes. This setting will also affect newly created plots.
 * @param lock whether to allow zooming of the Y axis
 * @see AxisMouseListener#setAllowZoomY(boolean)
 */
public void setAllowZoomY(boolean lock){
  this.lock.lock();
  try {
    this.allowZoomY=lock;
    if (this.getOrientation() == Orientation.HORIZONTAL) {
      this.timelineMouseListener.setAllowZoom(lock);
    }
    for (    TimePlotInfo info : getAllTimePlots()) {
      info.getTimelineMouseListener().setAllowZoomY(lock);
    }
  }
  finally {
    this.lock.unlock();
  }
}",0.916095890410959
11662,"/** 
 * Sets whether or not zooming of the X axis is allowed for all timeline and plot axes. This setting will also affect newly created plots.
 * @param lock whether to allow zooming of the X axis
 * @see AxisMouseListener#setAllowZoomX(boolean)
 */
public void setAllowZoomX(boolean lock){
  this.allowZoomX=lock;
  if (this.getOrientation() == Orientation.VERTICAL) {
    this.timelineMouseListener.setAllowZoom(lock);
  }
  for (  TimePlotInfo info : getAllTimePlots()) {
    info.getTimelineMouseListener().setAllowZoomX(lock);
  }
}","/** 
 * Sets whether or not zooming of the X axis is allowed for all timeline and plot axes. This setting will also affect newly created plots.
 * @param lock whether to allow zooming of the X axis
 * @see AxisMouseListener#setAllowZoomX(boolean)
 */
public void setAllowZoomX(boolean lock){
  this.lock.lock();
  try {
    this.allowZoomX=lock;
    if (this.getOrientation() == Orientation.VERTICAL) {
      this.timelineMouseListener.setAllowZoom(lock);
    }
    for (    TimePlotInfo info : getAllTimePlots()) {
      info.getTimelineMouseListener().setAllowZoomX(lock);
    }
  }
  finally {
    this.lock.unlock();
  }
}",0.915807560137457
11663,"/** 
 * <p>Returns only the TimePlotInfo handles for plotting areas created with   {@link #createTimePlot(String)}.</p> Note, this may not be all the plotting areas for this StackedPlot2D if some vanilla plots were created using   {@link #createPlot(String)}.
 */
public Collection<TimePlotInfo> getAllTimePlots(){
  List<TimePlotInfo> list=new LinkedList<TimePlotInfo>();
  for (  PlotInfo plot : getAllPlots()) {
    if (plot instanceof TimePlotInfo)     list.add((TimePlotInfo)plot);
  }
  return list;
}","/** 
 * <p>Returns only the TimePlotInfo handles for plotting areas created with   {@link #createTimePlot(String)}.</p> Note, this may not be all the plotting areas for this StackedPlot2D if some vanilla plots were created using   {@link #createPlot(String)}.
 */
public Collection<TimePlotInfo> getAllTimePlots(){
  this.lock.lock();
  try {
    List<TimePlotInfo> list=new LinkedList<TimePlotInfo>();
    for (    PlotInfo plot : getAllPlots()) {
      if (plot instanceof TimePlotInfo)       list.add((TimePlotInfo)plot);
    }
    return list;
  }
  finally {
    this.lock.unlock();
  }
}",0.8527272727272728
11664,"/** 
 * Returns the time plot handle for the plot identified via its unique string identifier.
 * @param name a plot unique identifier
 * @return the PlotInfo handle
 */
public TimePlotInfo getTimePlot(String name){
  PlotInfo plot=getPlot(name);
  if (plot instanceof TimePlotInfo) {
    return (TimePlotInfo)plot;
  }
 else {
    return null;
  }
}","/** 
 * Returns the time plot handle for the plot identified via its unique string identifier.
 * @param name a plot unique identifier
 * @return the PlotInfo handle
 */
public TimePlotInfo getTimePlot(String name){
  this.lock.lock();
  try {
    PlotInfo plot=getPlot(name);
    if (plot instanceof TimePlotInfo) {
      return (TimePlotInfo)plot;
    }
 else {
      return null;
    }
  }
  finally {
    this.lock.unlock();
  }
}",0.8928571428571429
11665,"/** 
 * Sets whether or not locking of the selected region is allowed for all timeline and plot axes. This setting will also affect newly created plots.
 * @param lock whether to allow locking of the selected region
 * @see AxisMouseListener#setAllowSelectionLock(boolean)
 */
public void setAllowSelectionLock(boolean lock){
  this.allowSelectionLock=lock;
  this.timelineMouseListener.setAllowSelectionLock(lock);
  for (  TimePlotInfo info : getAllTimePlots()) {
    info.getTimelineMouseListener().setAllowSelectionLock(lock);
  }
}","/** 
 * Sets whether or not locking of the selected region is allowed for all timeline and plot axes. This setting will also affect newly created plots.
 * @param lock whether to allow locking of the selected region
 * @see AxisMouseListener#setAllowSelectionLock(boolean)
 */
public void setAllowSelectionLock(boolean lock){
  this.lock.lock();
  try {
    this.allowSelectionLock=lock;
    this.timelineMouseListener.setAllowSelectionLock(lock);
    for (    TimePlotInfo info : getAllTimePlots()) {
      info.getTimelineMouseListener().setAllowSelectionLock(lock);
    }
  }
  finally {
    this.lock.unlock();
  }
}",0.9186851211072664
11666,"public void setTimelineMouseListener1D(AxisMouseListener1D listener){
  if (this.timelineMouseListener != null) {
    this.timeLayout.removeGlimpseMouseAllListener(this.timelineMouseListener);
  }
  this.timelineMouseListener=listener;
  if (this.timelineMouseListener != null) {
    this.timeLayout.addGlimpseMouseAllListener(this.timelineMouseListener);
  }
}","public void setTimelineMouseListener1D(AxisMouseListener1D listener){
  this.lock.lock();
  try {
    if (this.timelineMouseListener != null) {
      this.timeLayout.removeGlimpseMouseAllListener(this.timelineMouseListener);
    }
    this.timelineMouseListener=listener;
    if (this.timelineMouseListener != null) {
      this.timeLayout.addGlimpseMouseAllListener(this.timelineMouseListener);
    }
  }
  finally {
    this.lock.unlock();
  }
}",0.8935643564356436
11667,"/** 
 * Sets whether or not panning of the Y axis is allowed for all timeline and plot axes. This setting will also affect newly created plots.
 * @param lock whether to allow panning of the Y axis
 * @see AxisMouseListener#setAllowPanY(boolean)
 */
public void setAllowPanY(boolean lock){
  this.allowPanY=lock;
  if (this.getOrientation() == Orientation.HORIZONTAL) {
    this.timelineMouseListener.setAllowPan(lock);
  }
  for (  TimePlotInfo info : getAllTimePlots()) {
    info.getTimelineMouseListener().setAllowPanY(lock);
  }
}","/** 
 * Sets whether or not panning of the Y axis is allowed for all timeline and plot axes. This setting will also affect newly created plots.
 * @param lock whether to allow panning of the Y axis
 * @see AxisMouseListener#setAllowPanY(boolean)
 */
public void setAllowPanY(boolean lock){
  this.lock.lock();
  try {
    this.allowPanY=lock;
    if (this.getOrientation() == Orientation.HORIZONTAL) {
      this.timelineMouseListener.setAllowPan(lock);
    }
    for (    TimePlotInfo info : getAllTimePlots()) {
      info.getTimelineMouseListener().setAllowPanY(lock);
    }
  }
  finally {
    this.lock.unlock();
  }
}",0.915371329879102
11668,"/** 
 * Sets whether or not panning of the X axis is allowed for all timeline and plot axes. This setting will also affect newly created plots.
 * @param lock whether to allow panning of the X axis
 * @see AxisMouseListener#setAllowPanX(boolean)
 */
public void setAllowPanX(boolean lock){
  this.allowPanX=lock;
  if (this.getOrientation() == Orientation.VERTICAL) {
    this.timelineMouseListener.setAllowPan(lock);
  }
  for (  TimePlotInfo info : getAllTimePlots()) {
    info.getTimelineMouseListener().setAllowPanX(lock);
  }
}","/** 
 * Sets whether or not panning of the X axis is allowed for all timeline and plot axes. This setting will also affect newly created plots.
 * @param lock whether to allow panning of the X axis
 * @see AxisMouseListener#setAllowPanX(boolean)
 */
public void setAllowPanX(boolean lock){
  this.lock.lock();
  try {
    this.allowPanX=lock;
    if (this.getOrientation() == Orientation.VERTICAL) {
      this.timelineMouseListener.setAllowPan(lock);
    }
    for (    TimePlotInfo info : getAllTimePlots()) {
      info.getTimelineMouseListener().setAllowPanX(lock);
    }
  }
  finally {
    this.lock.unlock();
  }
}",0.9150779896013864
11669,"public void setTimeAxisPainter(TimeAxisPainter painter){
  this.timeAxisDelegate.removePainter(this.timeAxisPainter);
  this.timeAxisPainter=painter;
  this.timeAxisDelegate.addPainter(this.timeAxisPainter);
}","public void setTimeAxisPainter(TimeAxisPainter painter){
  this.lock.lock();
  try {
    this.timeAxisDelegate.removePainter(this.timeAxisPainter);
    this.timeAxisPainter=painter;
    this.timeAxisDelegate.addPainter(this.timeAxisPainter);
  }
  finally {
    this.lock.unlock();
  }
}",0.842741935483871
11670,"public void removeAll(){
  lock.lock();
  try {
    layoutChildren.clear();
    layoutDelegate.removeAll();
    invalidateLayout();
  }
  finally {
    lock.unlock();
  }
}","public void removeAll(){
  lock.lock();
  try {
    manager.removeAllLayouts();
    layoutDelegate.removeAll();
    invalidateLayout();
  }
  finally {
    lock.unlock();
  }
}",0.9080459770114944
11671,"public void addLayout(GlimpseLayout layout,GlimpsePainterCallback callback,int zOrder){
  lock.lock();
  try {
    layoutChildren.add(layout);
    layoutDelegate.addLayout(layout,callback,zOrder);
    invalidateLayout();
  }
  finally {
    lock.unlock();
  }
}","public void addLayout(GlimpseLayout layout,GlimpsePainterCallback callback,int zOrder){
  lock.lock();
  try {
    manager.addLayout(layout,zOrder);
    layoutDelegate.addLayout(layout,callback,zOrder);
    invalidateLayout();
  }
  finally {
    lock.unlock();
  }
}",0.7196969696969697
11672,"@Override public List<GlimpseTarget> getTargetChildren(){
  return unmodifiableLayoutChildren;
}","@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) @Override public List<GlimpseTarget> getTargetChildren(){
  return (List)manager.getLayoutList();
}",0.6349206349206349
11673,"public void addPainter(GlimpsePainter painter,GlimpsePainterCallback callback,int zOrder){
  lock.lock();
  try {
    layoutDelegate.addPainter(painter,callback,zOrder);
    invalidateLayout();
  }
  finally {
    lock.unlock();
  }
}","public void addPainter(GlimpsePainter painter,GlimpsePainterCallback callback,int zOrder){
  if (painter instanceof GlimpseLayout) {
    addLayout((GlimpseLayout)painter,callback,zOrder);
  }
 else {
    lock.lock();
    try {
      layoutDelegate.addPainter(painter,callback,zOrder);
      invalidateLayout();
    }
  finally {
      lock.unlock();
    }
  }
}",0.6050420168067226
11674,"@Override public void removeLayout(GlimpseLayout layout){
  lock.lock();
  try {
    layoutChildren.remove(layout);
    layoutDelegate.removeLayout(layout);
    invalidateLayout();
  }
  finally {
    lock.unlock();
  }
}","@Override public void removeLayout(GlimpseLayout layout){
  lock.lock();
  try {
    manager.removeLayout(layout);
    layoutDelegate.removeLayout(layout);
    invalidateLayout();
  }
  finally {
    lock.unlock();
  }
}",0.6303854875283447
11675,"/** 
 * <p>Sets the relative ordering constant for this painter. Painters with low z order will be painter first (in the back) and those with high z order will be painted last (in the front).</p> <p>The value itself has no meaning; it is relative to the z orders of the other painters in the GlimpseLayout. For   {@link com.metsci.glimpse.layout.com.metsciGlimpseLayout} instances,the z order also affects the order in which mouse events are delivered to overlapping components.</p> <p>The z order is set to 0 by default. GlimpsePainters with the same z order are painted in the order they were added to the GlimpseLayout. This means the first painters added will be obscured by later painters.</p>
 */
public void setZOrder(GlimpsePainter painter,int zOrder){
  lock.lock();
  try {
    layoutDelegate.setZOrder(painter,zOrder);
  }
  finally {
    lock.unlock();
  }
}","/** 
 * <p>Sets the relative ordering constant for this painter. Painters with low z order will be painter first (in the back) and those with high z order will be painted last (in the front).</p> <p>The value itself has no meaning; it is relative to the z orders of the other painters in the GlimpseLayout. For   {@link com.metsci.glimpse.layout.com.metsciGlimpseLayout} instances,the z order also affects the order in which mouse events are delivered to overlapping components.</p> <p>The z order is set to 0 by default. GlimpsePainters with the same z order are painted in the order they were added to the GlimpseLayout. This means the first painters added will be obscured by later painters.</p>
 */
public void setZOrder(GlimpsePainter painter,int zOrder){
  if (painter instanceof GlimpseLayout) {
    setZOrder((GlimpseLayout)painter,zOrder);
  }
 else {
    lock.lock();
    try {
      layoutDelegate.setZOrder(painter,zOrder);
    }
  finally {
      lock.unlock();
    }
  }
}",0.9375
11676,"protected void initializeArrays(){
  this.stackedPlots=new HashMap<String,PlotInfo>();
}","protected void initializeArrays(){
  this.stackedPlots=new LinkedHashMap<String,PlotInfo>();
}",0.967032967032967
11677,"/** 
 * Creates a StackedTimePlot2D with specified orientation. The provided epoch determines what absolute timestamp corresponds to value 0.0 on the time Axis1D.
 */
public StackedTimePlot2D(Orientation orientation,Epoch epoch){
  super(StackedTimePlot2D.class.getSimpleName());
  this.epoch=epoch;
  this.stackedTimePlots=new HashMap<String,TimePlotInfo>();
  this.delegatePlot=new StackedPlot2D(orientation){
    @Override protected TaggedAxis1D createCommonAxis(){
      return new TaggedAxis1D();
    }
  }
;
  this.initialize();
}","/** 
 * Creates a StackedTimePlot2D with specified orientation. The provided epoch determines what absolute timestamp corresponds to value 0.0 on the time Axis1D.
 */
public StackedTimePlot2D(Orientation orientation,Epoch epoch){
  super(StackedTimePlot2D.class.getSimpleName());
  this.epoch=epoch;
  this.stackedTimePlots=new LinkedHashMap<String,TimePlotInfo>();
  this.delegatePlot=new StackedPlot2D(orientation){
    @Override protected TaggedAxis1D createCommonAxis(){
      return new TaggedAxis1D();
    }
  }
;
  this.initialize();
}",0.9944341372912802
11678,"static NestedTreeMap createLargeGeoTree() throws Exception {
  NestedTreeMap tree=new NestedTreeMap();
  tree.setRoot(0);
  tree.setTitle(0,""String_Node_Str"");
  int idGenerator=100;
  Map<String,Integer> stateIdMap=new TreeMap<String,Integer>();
  Map<String,Integer> countyIdMap=new TreeMap<String,Integer>();
  InputStream fileStream=StreamOpener.fileThenResource.openForRead(""String_Node_Str"");
  ZipInputStream zipStream=new ZipInputStream(fileStream);
  zipStream.getNextEntry();
  BufferedReader reader=new BufferedReader(new InputStreamReader(zipStream));
  reader.readLine();
  reader.readLine();
  String line=null;
  while ((line=reader.readLine()) != null) {
    String[] parts=line.split(""String_Node_Str"");
    String level=parts[0];
    String county=parts[1];
    String city=parts[2];
    String state=parts[3];
    int population=Integer.parseInt(parts[15]);
    String text=""String_Node_Str"" + population;
    if (""String_Node_Str"".equals(level)) {
      int id=idGenerator++;
      stateIdMap.put(state,id);
      tree.addChild(0,id,population,state);
      tree.setText(id,text);
    }
 else     if (""String_Node_Str"".equals(level)) {
      int stateId=stateIdMap.get(state);
      int id=idGenerator++;
      countyIdMap.put(county,id);
      tree.addChild(stateId,id,population,""String_Node_Str"".equals(county) ? city : county);
      tree.setText(id,text);
    }
 else     if (""String_Node_Str"".equals(level)) {
      int countyId=countyIdMap.get(county);
      int id=idGenerator++;
      tree.addChild(countyId,id,population,city);
      tree.setText(id,text);
    }
  }
  reader.close();
  return tree;
}","static NestedTreeMap createLargeGeoTree() throws Exception {
  NestedTreeMap tree=new NestedTreeMap();
  tree.setRoot(0);
  tree.setTitle(0,""String_Node_Str"");
  int idGenerator=100;
  Map<String,Integer> stateIdMap=new TreeMap<String,Integer>();
  Map<String,Integer> countyIdMap=new TreeMap<String,Integer>();
  InputStream fileStream=StreamOpener.resource.openForRead(""String_Node_Str"");
  ZipInputStream zipStream=new ZipInputStream(fileStream);
  zipStream.getNextEntry();
  BufferedReader reader=new BufferedReader(new InputStreamReader(zipStream));
  reader.readLine();
  reader.readLine();
  String line=null;
  while ((line=reader.readLine()) != null) {
    String[] parts=line.split(""String_Node_Str"");
    String level=parts[0];
    String county=parts[1];
    String city=parts[2];
    String state=parts[3];
    int population=Integer.parseInt(parts[15]);
    String text=""String_Node_Str"" + population;
    if (""String_Node_Str"".equals(level)) {
      int id=idGenerator++;
      stateIdMap.put(state,id);
      tree.addChild(0,id,population,state);
      tree.setText(id,text);
    }
 else     if (""String_Node_Str"".equals(level)) {
      int stateId=stateIdMap.get(state);
      int id=idGenerator++;
      countyIdMap.put(county,id);
      tree.addChild(stateId,id,population,""String_Node_Str"".equals(county) ? city : county);
      tree.setText(id,text);
    }
 else     if (""String_Node_Str"".equals(level)) {
      int countyId=countyIdMap.get(county);
      int id=idGenerator++;
      tree.addChild(countyId,id,population,city);
      tree.setText(id,text);
    }
  }
  reader.close();
  return tree;
}",0.9969268592501536
11679,"public ExampleRunner(){
  setOrientation(JSplitPane.HORIZONTAL_SPLIT);
  exampleList=new JList();
  codeArea=new JTextArea();
  codeArea.setFont(Font.decode(""String_Node_Str""));
  codeArea.setEditable(false);
  runExampleButton=new JButton(""String_Node_Str"");
  runExampleButton.setEnabled(false);
  exampleList.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
  exampleList.addListSelectionListener(new ListSelectionListener(){
    @Override public void valueChanged(    ListSelectionEvent e){
      selectClass((Class<?>)exampleList.getSelectedValue());
    }
  }
);
  exampleList.setCellRenderer(new DefaultListCellRenderer(){
    @Override public Component getListCellRendererComponent(    JList list,    Object value,    int index,    boolean isSelected,    boolean cellHasFocus){
      Class<?> clazz=(Class<?>)value;
      value=clazz.getSimpleName();
      return super.getListCellRendererComponent(list,value,index,isSelected,cellHasFocus);
    }
  }
);
  runExampleButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      runExample(exampleClass);
    }
  }
);
  JPanel rightPanel=new JPanel(new BorderLayout());
  rightPanel.add(new JScrollPane(codeArea),BorderLayout.CENTER);
  JPanel buttonPanel=new JPanel(new BorderLayout());
  buttonPanel.add(runExampleButton,BorderLayout.EAST);
  rightPanel.add(buttonPanel,BorderLayout.SOUTH);
  setLeftComponent(new JScrollPane(exampleList));
  setRightComponent(rightPanel);
}","public ExampleRunner(){
  setOrientation(JSplitPane.HORIZONTAL_SPLIT);
  exampleTree=new JTree(new DefaultTreeModel(new DefaultMutableTreeNode(""String_Node_Str"")));
  codeArea=new JTextArea();
  codeArea.setFont(Font.decode(""String_Node_Str""));
  codeArea.setEditable(false);
  runExampleButton=new JButton(""String_Node_Str"");
  runExampleButton.setEnabled(false);
  exampleTree.getSelectionModel().setSelectionMode(TreeSelectionModel.SINGLE_TREE_SELECTION);
  exampleTree.addTreeSelectionListener(new TreeSelectionListener(){
    @Override public void valueChanged(    TreeSelectionEvent e){
      if (exampleTree.getSelectionCount() > 0) {
        TreePath selectionPath=exampleTree.getSelectionPath();
        DefaultMutableTreeNode node=(DefaultMutableTreeNode)selectionPath.getLastPathComponent();
        if (node.getUserObject() instanceof Class<?>) {
          Class<?> clazz=(Class<?>)node.getUserObject();
          selectClass(clazz);
        }
 else {
          selectClass(null);
        }
      }
    }
  }
);
  runExampleButton.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      runExample(exampleClass);
    }
  }
);
  JPanel rightPanel=new JPanel(new BorderLayout());
  rightPanel.add(new JScrollPane(codeArea),BorderLayout.CENTER);
  JPanel buttonPanel=new JPanel(new BorderLayout());
  buttonPanel.add(runExampleButton,BorderLayout.EAST);
  rightPanel.add(buttonPanel,BorderLayout.SOUTH);
  setLeftComponent(new JScrollPane(exampleTree));
  setRightComponent(rightPanel);
  setDividerLocation(300);
}",0.5355048859934853
11680,"@Override public void valueChanged(ListSelectionEvent e){
  selectClass((Class<?>)exampleList.getSelectedValue());
}","@Override public void valueChanged(TreeSelectionEvent e){
  if (exampleTree.getSelectionCount() > 0) {
    TreePath selectionPath=exampleTree.getSelectionPath();
    DefaultMutableTreeNode node=(DefaultMutableTreeNode)selectionPath.getLastPathComponent();
    if (node.getUserObject() instanceof Class<?>) {
      Class<?> clazz=(Class<?>)node.getUserObject();
      selectClass(clazz);
    }
 else {
      selectClass(null);
    }
  }
}",0.2640144665461121
11681,"public void populateExamples(){
  new SwingWorker<Collection<Class<?>>,Void>(){
    @Override protected Collection<Class<?>> doInBackground() throws Exception {
      return getExamples();
    }
    @Override protected void done(){
      try {
        Collection<Class<?>> classes=get();
        DefaultListModel model=new DefaultListModel();
        for (        Class<?> exampleClass : classes) {
          model.addElement(exampleClass);
        }
        exampleList.setModel(model);
      }
 catch (      Exception e) {
        JOptionPane.showMessageDialog(SwingUtilities.getWindowAncestor(ExampleRunner.this),e.getMessage(),""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
      }
    }
  }
.execute();
}","public void populateExamples(){
  new SwingWorker<Collection<Class<?>>,Void>(){
    @Override protected Collection<Class<?>> doInBackground() throws Exception {
      return getExamples();
    }
    @Override protected void done(){
      try {
        Collection<Class<?>> classes=get();
        exampleTree.setModel(createTreeModel(classes));
      }
 catch (      Exception e) {
        JOptionPane.showMessageDialog(SwingUtilities.getWindowAncestor(ExampleRunner.this),e.getMessage(),""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
      }
    }
  }
.execute();
}",0.8349056603773585
11682,"private void selectClass(final Class<?> clazz){
  runExampleButton.setEnabled(false);
  new SwingWorker<String,Void>(){
    @Override protected String doInBackground() throws Exception {
      return getSource(clazz);
    }
    @Override protected void done(){
      try {
        codeArea.setText(get());
        exampleClass=clazz;
        runExampleButton.setEnabled(true);
      }
 catch (      Exception e) {
        JOptionPane.showMessageDialog(SwingUtilities.getWindowAncestor(ExampleRunner.this),e.getMessage(),""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
      }
    }
  }
.execute();
}","private void selectClass(final Class<?> clazz){
  runExampleButton.setEnabled(false);
  if (clazz == null) {
    codeArea.setText(null);
    return;
  }
  new SwingWorker<String,Void>(){
    @Override protected String doInBackground() throws Exception {
      return getSource(clazz);
    }
    @Override protected void done(){
      try {
        codeArea.setText(get());
        codeArea.setCaretPosition(0);
        exampleClass=clazz;
        runExampleButton.setEnabled(true);
      }
 catch (      Exception e) {
        JOptionPane.showMessageDialog(SwingUtilities.getWindowAncestor(ExampleRunner.this),e.getMessage(),""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
      }
    }
  }
.execute();
}",0.9191685912240184
11683,"private Collection<Class<?>> getExamples() throws ClassNotFoundException, IOException {
  List<Class<?>> exampleClasses=new ArrayList<Class<?>>();
  URL url=ExampleRunner.class.getResource(ExampleRunner.class.getSimpleName() + ""String_Node_Str"");
  URLConnection connection=url.openConnection();
  if (connection instanceof JarURLConnection) {
    JarFile jar=((JarURLConnection)connection).getJarFile();
    Enumeration<JarEntry> entries=jar.entries();
    while (entries.hasMoreElements()) {
      JarEntry entry=entries.nextElement();
      String name=entry.getName();
      if (name.endsWith(""String_Node_Str"")) {
        String className=name.replace('/','.').substring(0,name.length() - ""String_Node_Str"".length());
        Class<?> clazz=Class.forName(className);
        exampleClasses.add(clazz);
      }
    }
  }
 else {
    throw new UnsupportedOperationException(""String_Node_Str"");
  }
  return exampleClasses;
}","private Collection<Class<?>> getExamples() throws ClassNotFoundException, IOException {
  List<Class<?>> exampleClasses=new ArrayList<Class<?>>();
  URL url=ExampleRunner.class.getResource(ExampleRunner.class.getSimpleName() + ""String_Node_Str"");
  URLConnection connection=url.openConnection();
  if (connection instanceof JarURLConnection) {
    JarFile jar=((JarURLConnection)connection).getJarFile();
    Enumeration<JarEntry> entries=jar.entries();
    while (entries.hasMoreElements()) {
      JarEntry entry=entries.nextElement();
      String name=entry.getName();
      if (name.endsWith(""String_Node_Str"")) {
        String className=name.replace('/','.').substring(0,name.length() - ""String_Node_Str"".length());
        Class<?> clazz=Class.forName(className);
        if (clazz.getSimpleName().equals(""String_Node_Str"")) {
          continue;
        }
 else {
          exampleClasses.add(clazz);
        }
      }
    }
  }
 else {
    throw new UnsupportedOperationException(""String_Node_Str"");
  }
  return exampleClasses;
}",0.9425521098118964
11684,"@Override protected void done(){
  try {
    codeArea.setText(get());
    exampleClass=clazz;
    runExampleButton.setEnabled(true);
  }
 catch (  Exception e) {
    JOptionPane.showMessageDialog(SwingUtilities.getWindowAncestor(ExampleRunner.this),e.getMessage(),""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
  }
}","@Override protected void done(){
  try {
    codeArea.setText(get());
    codeArea.setCaretPosition(0);
    exampleClass=clazz;
    runExampleButton.setEnabled(true);
  }
 catch (  Exception e) {
    JOptionPane.showMessageDialog(SwingUtilities.getWindowAncestor(ExampleRunner.this),e.getMessage(),""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
  }
}",0.9487951807228916
11685,"public static void main(String[] args){
  try {
    UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
  }
 catch (  Exception e) {
  }
  JFrame frame=new JFrame(""String_Node_Str"");
  frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
  frame.setPreferredSize(new Dimension(1280,800));
  ExampleRunner runnerPanel=new ExampleRunner();
  frame.setContentPane(runnerPanel);
  frame.pack();
  frame.setLocationRelativeTo(null);
  frame.setVisible(true);
  runnerPanel.populateExamples();
}","public static void main(String[] args){
  try {
    UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
  }
 catch (  Exception e) {
  }
  final JFrame runnerFrame=new JFrame(""String_Node_Str"");
  runnerFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
  runnerFrame.setPreferredSize(new Dimension(1280,800));
  ExampleRunner runnerPanel=new ExampleRunner();
  runnerFrame.setContentPane(runnerPanel);
  runnerFrame.pack();
  runnerFrame.setLocationRelativeTo(null);
  runnerFrame.setVisible(true);
  runnerPanel.populateExamples();
  Toolkit.getDefaultToolkit().addAWTEventListener(new AWTEventListener(){
    @Override public void eventDispatched(    AWTEvent event){
      if (event instanceof WindowEvent) {
        Window window=((WindowEvent)event).getWindow();
        if (window != runnerFrame) {
          if (window instanceof JFrame) {
            JFrame frame=(JFrame)window;
            if (frame.getDefaultCloseOperation() == JFrame.EXIT_ON_CLOSE) {
              frame.setDefaultCloseOperation(WindowConstants.DISPOSE_ON_CLOSE);
            }
          }
 else           if (window instanceof JDialog) {
            JDialog dialog=(JDialog)window;
            if (dialog.getDefaultCloseOperation() == JFrame.EXIT_ON_CLOSE) {
              dialog.setDefaultCloseOperation(WindowConstants.DISPOSE_ON_CLOSE);
            }
          }
        }
      }
    }
  }
,AWTEvent.WINDOW_EVENT_MASK);
}",0.5170630816959669
11686,"/** 
 * Computes a pre-alignemnt of all non-fixed   {@link Tile}s by propagating the pairwise models. This does not give a correct registration but a very good starting point for the global optimization. This is necessary for models where the global optimization is not guaranteed to converge like the   {@link HomographyModel2D},   {@link RigidModel3D}, ...
 * @return - a list of {@link Tile}s that could not be pre-aligned
 * @throws NotEnoughDataPointsException
 * @throws {@link IllDefinedDataPointsException}
 */
public List<Tile<?>> preAlign() throws NotEnoughDataPointsException, IllDefinedDataPointsException {
  final ArrayList<Tile<?>> unAlignedTiles=new ArrayList<Tile<?>>();
  final ArrayList<Tile<?>> alignedTiles=new ArrayList<Tile<?>>();
  if (getFixedTiles().size() == 0) {
    final Iterator<Tile<?>> it=this.getTiles().iterator();
    alignedTiles.add(it.next());
    while (it.hasNext())     unAlignedTiles.add(it.next());
  }
 else {
    for (    final Tile<?> tile : this.getTiles()) {
      if (this.getFixedTiles().contains(tile))       alignedTiles.add(tile);
 else       unAlignedTiles.add(tile);
    }
  }
  for (final ListIterator<Tile<?>> referenceIterator=alignedTiles.listIterator(); referenceIterator.hasNext(); ) {
    if (unAlignedTiles.size() == 0)     break;
    final Tile<?> referenceTile=referenceIterator.next();
    referenceTile.apply();
    for (final ListIterator<Tile<?>> targetIterator=unAlignedTiles.listIterator(); targetIterator.hasNext(); ) {
      final Tile<?> targetTile=targetIterator.next();
      if (referenceTile.getConnectedTiles().contains(targetTile)) {
        final ArrayList<PointMatch> pm=getConnectingPointMatches(targetTile,referenceTile);
        if (pm.size() > targetTile.getModel().getMinNumMatches()) {
          targetTile.getModel().fit(pm);
          targetIterator.remove();
          int countFwd=0;
          while (referenceIterator.hasNext()) {
            referenceIterator.next();
            ++countFwd;
          }
          referenceIterator.add(targetTile);
          for (int j=0; j < countFwd + 1; ++j)           referenceIterator.previous();
        }
      }
    }
  }
  return unAlignedTiles;
}","/** 
 * Computes a pre-alignemnt of all non-fixed   {@link Tile}s by propagating the pairwise models. This does not give a correct registration but a very good starting point for the global optimization. This is necessary for models where the global optimization is not guaranteed to converge like the   {@link HomographyModel2D},   {@link RigidModel3D}, ...
 * @return - a list of {@link Tile}s that could not be pre-aligned
 * @throws NotEnoughDataPointsException
 * @throws {@link IllDefinedDataPointsException}
 */
public List<Tile<?>> preAlign() throws NotEnoughDataPointsException, IllDefinedDataPointsException {
  final ArrayList<Tile<?>> unAlignedTiles=new ArrayList<Tile<?>>();
  final ArrayList<Tile<?>> alignedTiles=new ArrayList<Tile<?>>();
  if (getFixedTiles().size() == 0) {
    final Iterator<Tile<?>> it=this.getTiles().iterator();
    alignedTiles.add(it.next());
    while (it.hasNext())     unAlignedTiles.add(it.next());
  }
 else {
    for (    final Tile<?> tile : this.getTiles()) {
      if (this.getFixedTiles().contains(tile))       alignedTiles.add(tile);
 else       unAlignedTiles.add(tile);
    }
  }
  for (final ListIterator<Tile<?>> referenceIterator=alignedTiles.listIterator(); referenceIterator.hasNext(); ) {
    if (unAlignedTiles.size() == 0)     break;
    final Tile<?> referenceTile=referenceIterator.next();
    referenceTile.apply();
    for (final ListIterator<Tile<?>> targetIterator=unAlignedTiles.listIterator(); targetIterator.hasNext(); ) {
      final Tile<?> targetTile=targetIterator.next();
      if (referenceTile.getConnectedTiles().contains(targetTile)) {
        final ArrayList<PointMatch> pm=getConnectingPointMatches(targetTile,referenceTile);
        if (pm.size() >= targetTile.getModel().getMinNumMatches()) {
          targetTile.getModel().fit(pm);
          targetIterator.remove();
          int countFwd=0;
          while (referenceIterator.hasNext()) {
            referenceIterator.next();
            ++countFwd;
          }
          referenceIterator.add(targetTile);
          for (int j=0; j < countFwd + 1; ++j)           referenceIterator.previous();
        }
      }
    }
  }
  return unAlignedTiles;
}",0.9997712194005948
11687,"private void detectCandidates(){
  FloatArray2D[] d=octave.getD();
  for (int i=d.length - 2; i >= 1; --i) {
    int ia=i - 1;
    int ib=i + 1;
    for (int y=d[i].height - 2; y >= 1; --y) {
      int r=y * d[i].width;
      int ra=r - d[i].width;
      int rb=r + d[i].width;
      X:       for (int x=d[i].width - 2; x >= 1; --x) {
        int ic=i;
        int iac=ia;
        int ibc=ib;
        int yc=y;
        int rc=r;
        int rac=ra;
        int rbc=rb;
        int xc=x;
        int xa=xc - 1;
        int xb=xc + 1;
        float e111=d[ic].data[r + xc];
        float e000=d[iac].data[rac + xa];
        boolean isMax=e000 < e111;
        boolean isMin=e000 > e111;
        if (!(isMax || isMin))         continue;
        float e100=d[iac].data[rac + xc];
        isMax&=e100 < e111;
        isMin&=e100 > e111;
        if (!(isMax || isMin))         continue;
        float e200=d[iac].data[rac + xb];
        isMax&=e200 < e111;
        isMin&=e200 > e111;
        if (!(isMax || isMin))         continue;
        float e010=d[iac].data[rc + xa];
        isMax&=e010 < e111;
        isMin&=e010 > e111;
        if (!(isMax || isMin))         continue;
        float e110=d[iac].data[rc + xc];
        isMax&=e110 < e111;
        isMin&=e110 > e111;
        if (!(isMax || isMin))         continue;
        float e210=d[iac].data[rc + xb];
        isMax&=e210 < e111;
        isMin&=e210 > e111;
        if (!(isMax || isMin))         continue;
        float e020=d[iac].data[rbc + xa];
        isMax&=e020 < e111;
        isMin&=e020 > e111;
        if (!(isMax || isMin))         continue;
        float e120=d[iac].data[rbc + xc];
        isMax&=e120 < e111;
        isMin&=e120 > e111;
        if (!(isMax || isMin))         continue;
        float e220=d[iac].data[rbc + xb];
        isMax&=e220 < e111;
        isMin&=e220 > e111;
        if (!(isMax || isMin))         continue;
        float e001=d[ic].data[rac + xa];
        isMax&=e001 < e111;
        isMin&=e001 > e111;
        if (!(isMax || isMin))         continue;
        float e101=d[ic].data[rac + xc];
        isMax&=e101 < e111;
        isMin&=e101 > e111;
        if (!(isMax || isMin))         continue;
        float e201=d[ic].data[rac + xb];
        isMax&=e201 < e111;
        isMin&=e201 > e111;
        if (!(isMax || isMin))         continue;
        float e011=d[ic].data[rc + xa];
        isMax&=e011 < e111;
        isMin&=e011 > e111;
        if (!(isMax || isMin))         continue;
        float e211=d[ic].data[rc + xb];
        isMax&=e211 < e111;
        isMin&=e211 > e111;
        if (!(isMax || isMin))         continue;
        float e021=d[ic].data[rbc + xa];
        isMax&=e021 < e111;
        isMin&=e021 > e111;
        if (!(isMax || isMin))         continue;
        float e121=d[ic].data[rbc + xc];
        isMax&=e121 < e111;
        isMin&=e121 > e111;
        if (!(isMax || isMin))         continue;
        float e221=d[ic].data[rbc + xb];
        isMax&=e221 < e111;
        isMin&=e221 > e111;
        if (!(isMax || isMin))         continue;
        float e002=d[ibc].data[rac + xa];
        isMax&=e002 < e111;
        isMin&=e002 > e111;
        if (!(isMax || isMin))         continue;
        float e102=d[ibc].data[rac + xc];
        isMax&=e102 < e111;
        isMin&=e102 > e111;
        if (!(isMax || isMin))         continue;
        float e202=d[ibc].data[rac + xb];
        isMax&=e202 < e111;
        isMin&=e202 > e111;
        if (!(isMax || isMin))         continue;
        float e012=d[ibc].data[rc + xa];
        isMax&=e012 < e111;
        isMin&=e012 > e111;
        if (!(isMax || isMin))         continue;
        float e112=d[ibc].data[rc + xc];
        isMax&=e112 < e111;
        isMin&=e112 > e111;
        if (!(isMax || isMin))         continue;
        float e212=d[ibc].data[rc + xb];
        isMax&=e212 < e111;
        isMin&=e212 > e111;
        if (!(isMax || isMin))         continue;
        float e022=d[ibc].data[rbc + xa];
        isMax&=e022 < e111;
        isMin&=e022 > e111;
        if (!(isMax || isMin))         continue;
        float e122=d[ibc].data[rbc + xc];
        isMax&=e122 < e111;
        isMin&=e122 > e111;
        if (!(isMax || isMin))         continue;
        float e222=d[ibc].data[rbc + xb];
        isMax&=e222 < e111;
        isMin&=e222 > e111;
        if (!(isMax || isMin))         continue;
        boolean isLocalized=false;
        boolean isLocalizable=true;
        float dx;
        float dy;
        float di;
        float dxx;
        float dyy;
        float dii;
        float dxy;
        float dxi;
        float dyi;
        float ox;
        float oy;
        float oi;
        float od=Float.MAX_VALUE;
        float fx=0;
        float fy=0;
        float fi=0;
        int t=5;
        do {
          --t;
          dx=(e211 - e011) / 2.0f;
          dy=(e121 - e101) / 2.0f;
          di=(e112 - e110) / 2.0f;
          float e111_2=2.0f * e111;
          dxx=e011 - e111_2 + e211;
          dyy=e101 - e111_2 + e121;
          dii=e110 - e111_2 + e112;
          dxy=(e221 - e021 - e201 + e001) / 4.0f;
          dxi=(e212 - e012 - e210 + e010) / 4.0f;
          dyi=(e122 - e102 - e120 + e100) / 4.0f;
          final float det=Matrix3x3.det(dxx,dxy,dxi,dxy,dyy,dyi,dxi,dyi,dii);
          if (det == 0)           continue X;
          final float hixx=(dyy * dii - dyi * dyi) / det;
          final float hixy=(dxi * dyi - dxy * dii) / det;
          final float hixi=(dxy * dyi - dxi * dyy) / det;
          final float hiyy=(dxx * dii - dxi * dxi) / det;
          final float hiyi=(dxi * dxy - dxx * dyi) / det;
          final float hiii=(dxx * dyy - dxy * dxy) / det;
          ox=-hixx * dx - hixy * dy - hixx * di;
          oy=-hixy * dx - hiyy * dy - hixy * di;
          oi=-hixi * dx - hiyi * dy - hiii * di;
          float odc=ox * ox + oy * oy + oi * oi;
          if (odc < 2.0f) {
            if ((Math.abs(ox) > 0.5 || Math.abs(oy) > 0.5 || Math.abs(oi) > 0.5) && odc < od) {
              od=odc;
              xc=(int)Math.round((float)xc + ox);
              yc=(int)Math.round((float)yc + oy);
              ic=(int)Math.round((float)ic + oi);
              if (xc < 1 || yc < 1 || ic < 1 || xc > d[0].width - 2 || yc > d[0].height - 2 || ic > d.length - 2)               isLocalizable=false;
 else {
                xa=xc - 1;
                xb=xc + 1;
                rc=yc * d[ic].width;
                rac=rc - d[ic].width;
                rbc=rc + d[ic].width;
                iac=ic - 1;
                ibc=ic + 1;
                e000=d[iac].data[rac + xa];
                e100=d[iac].data[rac + xc];
                e200=d[iac].data[rac + xb];
                e010=d[iac].data[rc + xa];
                e110=d[iac].data[rc + xc];
                e210=d[iac].data[rc + xb];
                e020=d[iac].data[rbc + xa];
                e120=d[iac].data[rbc + xc];
                e220=d[iac].data[rbc + xb];
                e001=d[ic].data[rac + xa];
                e101=d[ic].data[rac + xc];
                e201=d[ic].data[rac + xb];
                e011=d[ic].data[rc + xa];
                e111=d[ic].data[rc + xc];
                e211=d[ic].data[rc + xb];
                e021=d[ic].data[rbc + xa];
                e121=d[ic].data[rbc + xc];
                e221=d[ic].data[rbc + xb];
                e002=d[ibc].data[rac + xa];
                e102=d[ibc].data[rac + xc];
                e202=d[ibc].data[rac + xb];
                e012=d[ibc].data[rc + xa];
                e112=d[ibc].data[rc + xc];
                e212=d[ibc].data[rc + xb];
                e022=d[ibc].data[rbc + xa];
                e122=d[ibc].data[rbc + xc];
                e222=d[ibc].data[rbc + xb];
              }
            }
 else {
              fx=(float)xc + ox;
              fy=(float)yc + oy;
              fi=(float)ic + oi;
              if (fx < 0 || fy < 0 || fi < 0 || fx > d[0].width - 1 || fy > d[0].height - 1 || fi > d.length - 1)               isLocalizable=false;
 else               isLocalized=true;
            }
          }
 else           isLocalizable=false;
        }
 while (!isLocalized && isLocalizable && t >= 0);
        if (!isLocalized) {
          continue;
        }
        if (Math.abs(e111 + 0.5f * (dx * ox + dy * oy + di * oi)) < MIN_CONTRAST)         continue;
        float det=dxx * dyy - dxy * dxy;
        float trace=dxx + dyy;
        if (trace * trace / det > MAX_CURVATURE_RATIO)         continue;
        candidates.addElement(new float[]{fx,fy,fi});
      }
    }
  }
}","private void detectCandidates(){
  FloatArray2D[] d=octave.getD();
  for (int i=d.length - 2; i >= 1; --i) {
    int ia=i - 1;
    int ib=i + 1;
    for (int y=d[i].height - 2; y >= 1; --y) {
      int r=y * d[i].width;
      int ra=r - d[i].width;
      int rb=r + d[i].width;
      X:       for (int x=d[i].width - 2; x >= 1; --x) {
        int ic=i;
        int iac=ia;
        int ibc=ib;
        int yc=y;
        int rc=r;
        int rac=ra;
        int rbc=rb;
        int xc=x;
        int xa=xc - 1;
        int xb=xc + 1;
        float e111=d[ic].data[r + xc];
        float e000=d[iac].data[rac + xa];
        boolean isMax=e000 < e111;
        boolean isMin=e000 > e111;
        if (!(isMax || isMin))         continue;
        float e100=d[iac].data[rac + xc];
        isMax&=e100 < e111;
        isMin&=e100 > e111;
        if (!(isMax || isMin))         continue;
        float e200=d[iac].data[rac + xb];
        isMax&=e200 < e111;
        isMin&=e200 > e111;
        if (!(isMax || isMin))         continue;
        float e010=d[iac].data[rc + xa];
        isMax&=e010 < e111;
        isMin&=e010 > e111;
        if (!(isMax || isMin))         continue;
        float e110=d[iac].data[rc + xc];
        isMax&=e110 < e111;
        isMin&=e110 > e111;
        if (!(isMax || isMin))         continue;
        float e210=d[iac].data[rc + xb];
        isMax&=e210 < e111;
        isMin&=e210 > e111;
        if (!(isMax || isMin))         continue;
        float e020=d[iac].data[rbc + xa];
        isMax&=e020 < e111;
        isMin&=e020 > e111;
        if (!(isMax || isMin))         continue;
        float e120=d[iac].data[rbc + xc];
        isMax&=e120 < e111;
        isMin&=e120 > e111;
        if (!(isMax || isMin))         continue;
        float e220=d[iac].data[rbc + xb];
        isMax&=e220 < e111;
        isMin&=e220 > e111;
        if (!(isMax || isMin))         continue;
        float e001=d[ic].data[rac + xa];
        isMax&=e001 < e111;
        isMin&=e001 > e111;
        if (!(isMax || isMin))         continue;
        float e101=d[ic].data[rac + xc];
        isMax&=e101 < e111;
        isMin&=e101 > e111;
        if (!(isMax || isMin))         continue;
        float e201=d[ic].data[rac + xb];
        isMax&=e201 < e111;
        isMin&=e201 > e111;
        if (!(isMax || isMin))         continue;
        float e011=d[ic].data[rc + xa];
        isMax&=e011 < e111;
        isMin&=e011 > e111;
        if (!(isMax || isMin))         continue;
        float e211=d[ic].data[rc + xb];
        isMax&=e211 < e111;
        isMin&=e211 > e111;
        if (!(isMax || isMin))         continue;
        float e021=d[ic].data[rbc + xa];
        isMax&=e021 < e111;
        isMin&=e021 > e111;
        if (!(isMax || isMin))         continue;
        float e121=d[ic].data[rbc + xc];
        isMax&=e121 < e111;
        isMin&=e121 > e111;
        if (!(isMax || isMin))         continue;
        float e221=d[ic].data[rbc + xb];
        isMax&=e221 < e111;
        isMin&=e221 > e111;
        if (!(isMax || isMin))         continue;
        float e002=d[ibc].data[rac + xa];
        isMax&=e002 < e111;
        isMin&=e002 > e111;
        if (!(isMax || isMin))         continue;
        float e102=d[ibc].data[rac + xc];
        isMax&=e102 < e111;
        isMin&=e102 > e111;
        if (!(isMax || isMin))         continue;
        float e202=d[ibc].data[rac + xb];
        isMax&=e202 < e111;
        isMin&=e202 > e111;
        if (!(isMax || isMin))         continue;
        float e012=d[ibc].data[rc + xa];
        isMax&=e012 < e111;
        isMin&=e012 > e111;
        if (!(isMax || isMin))         continue;
        float e112=d[ibc].data[rc + xc];
        isMax&=e112 < e111;
        isMin&=e112 > e111;
        if (!(isMax || isMin))         continue;
        float e212=d[ibc].data[rc + xb];
        isMax&=e212 < e111;
        isMin&=e212 > e111;
        if (!(isMax || isMin))         continue;
        float e022=d[ibc].data[rbc + xa];
        isMax&=e022 < e111;
        isMin&=e022 > e111;
        if (!(isMax || isMin))         continue;
        float e122=d[ibc].data[rbc + xc];
        isMax&=e122 < e111;
        isMin&=e122 > e111;
        if (!(isMax || isMin))         continue;
        float e222=d[ibc].data[rbc + xb];
        isMax&=e222 < e111;
        isMin&=e222 > e111;
        if (!(isMax || isMin))         continue;
        boolean isLocalized=false;
        boolean isLocalizable=true;
        float dx;
        float dy;
        float di;
        float dxx;
        float dyy;
        float dii;
        float dxy;
        float dxi;
        float dyi;
        float ox;
        float oy;
        float oi;
        float od=Float.MAX_VALUE;
        float fx=0;
        float fy=0;
        float fi=0;
        int t=5;
        do {
          --t;
          dx=(e211 - e011) / 2.0f;
          dy=(e121 - e101) / 2.0f;
          di=(e112 - e110) / 2.0f;
          float e111_2=2.0f * e111;
          dxx=e011 - e111_2 + e211;
          dyy=e101 - e111_2 + e121;
          dii=e110 - e111_2 + e112;
          dxy=(e221 - e021 - e201 + e001) / 4.0f;
          dxi=(e212 - e012 - e210 + e010) / 4.0f;
          dyi=(e122 - e102 - e120 + e100) / 4.0f;
          final float det=Matrix3x3.det(dxx,dxy,dxi,dxy,dyy,dyi,dxi,dyi,dii);
          if (det == 0)           continue X;
          final float hixx=(dyy * dii - dyi * dyi) / det;
          final float hixy=(dxi * dyi - dxy * dii) / det;
          final float hixi=(dxy * dyi - dxi * dyy) / det;
          final float hiyy=(dxx * dii - dxi * dxi) / det;
          final float hiyi=(dxi * dxy - dxx * dyi) / det;
          final float hiii=(dxx * dyy - dxy * dxy) / det;
          ox=-hixx * dx - hixy * dy - hixi * di;
          oy=-hixy * dx - hiyy * dy - hiyi * di;
          oi=-hixi * dx - hiyi * dy - hiii * di;
          final float odc=ox * ox + oy * oy + oi * oi;
          if (odc < 2.0f) {
            if ((Math.abs(ox) > 0.5 || Math.abs(oy) > 0.5 || Math.abs(oi) > 0.5) && odc < od) {
              od=odc;
              xc=(int)Math.round((float)xc + ox);
              yc=(int)Math.round((float)yc + oy);
              ic=(int)Math.round((float)ic + oi);
              if (xc < 1 || yc < 1 || ic < 1 || xc > d[0].width - 2 || yc > d[0].height - 2 || ic > d.length - 2)               isLocalizable=false;
 else {
                xa=xc - 1;
                xb=xc + 1;
                rc=yc * d[ic].width;
                rac=rc - d[ic].width;
                rbc=rc + d[ic].width;
                iac=ic - 1;
                ibc=ic + 1;
                e000=d[iac].data[rac + xa];
                e100=d[iac].data[rac + xc];
                e200=d[iac].data[rac + xb];
                e010=d[iac].data[rc + xa];
                e110=d[iac].data[rc + xc];
                e210=d[iac].data[rc + xb];
                e020=d[iac].data[rbc + xa];
                e120=d[iac].data[rbc + xc];
                e220=d[iac].data[rbc + xb];
                e001=d[ic].data[rac + xa];
                e101=d[ic].data[rac + xc];
                e201=d[ic].data[rac + xb];
                e011=d[ic].data[rc + xa];
                e111=d[ic].data[rc + xc];
                e211=d[ic].data[rc + xb];
                e021=d[ic].data[rbc + xa];
                e121=d[ic].data[rbc + xc];
                e221=d[ic].data[rbc + xb];
                e002=d[ibc].data[rac + xa];
                e102=d[ibc].data[rac + xc];
                e202=d[ibc].data[rac + xb];
                e012=d[ibc].data[rc + xa];
                e112=d[ibc].data[rc + xc];
                e212=d[ibc].data[rc + xb];
                e022=d[ibc].data[rbc + xa];
                e122=d[ibc].data[rbc + xc];
                e222=d[ibc].data[rbc + xb];
              }
            }
 else {
              fx=(float)xc + ox;
              fy=(float)yc + oy;
              fi=(float)ic + oi;
              if (fx < 0 || fy < 0 || fi < 0 || fx > d[0].width - 1 || fy > d[0].height - 1 || fi > d.length - 1)               isLocalizable=false;
 else               isLocalized=true;
            }
          }
 else           isLocalizable=false;
        }
 while (!isLocalized && isLocalizable && t >= 0);
        if (!isLocalized) {
          continue;
        }
        if (Math.abs(e111 + 0.5f * (dx * ox + dy * oy + di * oi)) < MIN_CONTRAST)         continue;
        float det=dxx * dyy - dxy * dxy;
        float trace=dxx + dyy;
        if (trace * trace / det > MAX_CURVATURE_RATIO)         continue;
        candidates.addElement(new float[]{fx,fy,fi});
      }
    }
  }
}",0.9994160924909494
11688,"/** 
 * TODO Not yet tested
 */
public TranslationModel2D createInverse(){
  final TranslationModel2D ict=new TranslationModel2D();
  ict.tx=-tx;
  ict.ty=-ty;
  ict.cost=cost;
  return ict;
}","/** 
 * TODO Not yet tested
 */
@Override public TranslationModel2D createInverse(){
  final TranslationModel2D ict=new TranslationModel2D();
  ict.tx=-tx;
  ict.ty=-ty;
  ict.cost=cost;
  return ict;
}",0.9746192893401016
11689,"@Override public void toArray(final double[] data){
  data[0]=1;
  data[1]=0;
  data[2]=1;
  data[3]=0;
  data[4]=tx;
  data[5]=ty;
}","@Override public void toArray(final double[] data){
  data[0]=1;
  data[1]=0;
  data[2]=0;
  data[3]=1;
  data[4]=tx;
  data[5]=ty;
}",0.9849624060150376
11690,"public void estimateInverseBounds(float[] min,float[] max) throws NoninvertibleModelException {
  applyInverseInPlace(min);
  applyInverseInPlace(max);
}","@Override public void estimateInverseBounds(final float[] min,final float[] max) throws NoninvertibleModelException {
  applyInverseInPlace(min);
  applyInverseInPlace(max);
}",0.9329268292682928
11691,"/** 
 * TODO Not yet tested
 */
public TranslationModel3D createInverse(){
  final TranslationModel3D ict=new TranslationModel3D();
  ict.translation[0]=-translation[0];
  ict.translation[1]=-translation[1];
  ict.translation[2]=-translation[2];
  ict.cost=cost;
  return ict;
}","/** 
 * TODO Not yet tested
 */
@Override public TranslationModel3D createInverse(){
  final TranslationModel3D ict=new TranslationModel3D();
  ict.translation[0]=-translation[0];
  ict.translation[1]=-translation[1];
  ict.translation[2]=-translation[2];
  ict.cost=cost;
  return ict;
}",0.9823321554770318
11692,"public void estimateBounds(float[] min,float[] max){
  applyInPlace(min);
  applyInPlace(max);
}","@Override public void estimateBounds(final float[] min,final float[] max){
  applyInPlace(min);
  applyInPlace(max);
}",0.897196261682243
11693,"@Override public void toMatrix(final double[][] data){
  data[0][0]=0;
  data[0][1]=0;
  data[0][2]=0;
  data[0][3]=translation[0];
  data[1][0]=0;
  data[1][1]=0;
  data[1][2]=0;
  data[1][3]=translation[1];
  data[2][0]=0;
  data[2][1]=0;
  data[2][2]=0;
  data[2][3]=translation[2];
}","@Override public void toMatrix(final double[][] data){
  data[0][0]=1;
  data[0][1]=0;
  data[0][2]=0;
  data[0][3]=translation[0];
  data[1][0]=0;
  data[1][1]=1;
  data[1][2]=0;
  data[1][3]=translation[1];
  data[2][0]=0;
  data[2][1]=0;
  data[2][2]=1;
  data[2][3]=translation[2];
}",0.989547038327526
11694,"@Override public float[] getMatrix(final float[] m){
  final float[] a;
  if (m == null || m.length != 12)   a=new float[12];
 else   a=m;
  a[0]=0;
  a[1]=0;
  a[2]=0;
  a[3]=translation[0];
  a[4]=0;
  a[5]=0;
  a[6]=0;
  a[7]=translation[1];
  a[8]=0;
  a[9]=0;
  a[10]=0;
  a[11]=translation[2];
  return a;
}","@Override public float[] getMatrix(final float[] m){
  final float[] a;
  if (m == null || m.length != 12)   a=new float[12];
 else   a=m;
  a[0]=1;
  a[1]=0;
  a[2]=0;
  a[3]=translation[0];
  a[4]=0;
  a[5]=1;
  a[6]=0;
  a[7]=translation[1];
  a[8]=0;
  a[9]=0;
  a[10]=1;
  a[11]=translation[2];
  return a;
}",0.9904153354632588
11695,"@Override public void toArray(final double[] data){
  data[0]=0;
  data[1]=0;
  data[2]=0;
  data[3]=0;
  data[4]=0;
  data[5]=0;
  data[6]=0;
  data[7]=0;
  data[8]=0;
  data[9]=translation[0];
  data[10]=translation[1];
  data[11]=translation[2];
}","@Override public void toArray(final double[] data){
  data[0]=1;
  data[1]=0;
  data[2]=0;
  data[3]=0;
  data[4]=1;
  data[5]=0;
  data[6]=0;
  data[7]=0;
  data[8]=1;
  data[9]=translation[0];
  data[10]=translation[1];
  data[11]=translation[2];
}",0.988
11696,"public TranslationModel3D copy(){
  final TranslationModel3D m=new TranslationModel3D();
  m.translation[0]=translation[0];
  m.translation[1]=translation[1];
  m.translation[2]=translation[2];
  m.cost=cost;
  return m;
}","@Override public TranslationModel3D copy(){
  final TranslationModel3D m=new TranslationModel3D();
  m.translation[0]=translation[0];
  m.translation[1]=translation[1];
  m.translation[2]=translation[2];
  m.cost=cost;
  return m;
}",0.9779735682819384
11697,"/** 
 * Performs one optimization step.
 * @param observer collecting the error after update
 * @throws NotEnoughDataPointsException
 */
protected void optimizeStep(final ErrorStatistic observer) throws NotEnoughDataPointsException {
  float maxSpeed=Float.MIN_VALUE;
  minForce=Double.MAX_VALUE;
  maxForce=0.0;
  force=0;
synchronized (this) {
    for (    final Vertex vertex : vertices) {
      vertex.update(damp);
      force+=vertex.getForce();
      final float speed=vertex.getSpeed();
      if (speed > maxSpeed)       maxSpeed=speed;
      if (force < minForce)       minForce=force;
      if (force > maxForce)       maxForce=force;
    }
    for (    final Vertex vertex : vertices)     vertex.move(Math.min(1000.0f,2.0f / maxSpeed));
    updateAffines();
    updatePassiveVertices();
  }
  observer.add(force);
}","/** 
 * Performs one optimization step.
 * @param observer collecting the error after update
 * @throws NotEnoughDataPointsException
 */
protected void optimizeStep(final ErrorStatistic observer) throws NotEnoughDataPointsException {
  maxSpeed=Double.MIN_VALUE;
  minForce=Double.MAX_VALUE;
  maxForce=0.0;
  force=0;
synchronized (this) {
    for (    final Vertex vertex : vertices) {
      vertex.update(damp);
      final float vertexForce=vertex.getForce();
      force+=vertexForce;
      final float speed=vertex.getSpeed();
      if (speed > maxSpeed)       maxSpeed=speed;
      if (vertexForce < minForce)       minForce=vertexForce;
      if (vertexForce > maxForce)       maxForce=vertexForce;
    }
    force/=vertices.size();
    for (    final Vertex vertex : vertices)     vertex.move(Math.min(1000.0f,(float)(2.0 / maxSpeed)));
    updateAffines();
    updatePassiveVertices();
  }
  observer.add(force);
}",0.8582857142857143
11698,"/** 
 * Optimize a   {@link Collection} of connected {@link SpringMesh SpringMeshes}.
 * @param maxError do not accept convergence if error is > max_error
 * @param maxIterations stop after that many iterations even if there wasno minimum found
 * @param maxPlateauwidth convergence is reached if the average slope inan interval of this size is 0.0 (in double accuracy).  This prevents the algorithm from stopping at plateaus smaller than this value.
 */
public static void optimizeMeshes(final Collection<SpringMesh> meshes,final float maxError,final int maxIterations,final int maxPlateauwidth,final boolean visualize) throws NotEnoughDataPointsException {
  final ErrorStatistic observer=new ErrorStatistic(maxPlateauwidth + 1);
  final ErrorStatistic singleMeshObserver=new ErrorStatistic(maxPlateauwidth + 1);
  int i=0;
  double force=0;
  double maxForce=0;
  double minForce=0;
  boolean proceed=i < maxIterations;
  final ImageStack stackAnimation=new ImageStack(VIS_SIZE,VIS_SIZE);
  final ImagePlus impAnimation=new ImagePlus();
  println(""String_Node_Str"");
  while (proceed) {
    force=0;
    maxForce=-Double.MAX_VALUE;
    minForce=Double.MAX_VALUE;
    if (visualize) {
      stackAnimation.addSlice(""String_Node_Str"" + i,paintSprings(meshes,VIS_SIZE,VIS_SIZE,maxError));
      impAnimation.setStack(stackAnimation);
      impAnimation.updateAndDraw();
      if (i == 1) {
        impAnimation.show();
      }
    }
    for (    final SpringMesh mesh : meshes) {
      mesh.optimizeStep(singleMeshObserver);
      force+=mesh.getForce();
      final double meshMaxForce=mesh.maxForce;
      final double meshMinForce=mesh.minForce;
      if (meshMaxForce > maxForce)       maxForce=meshMaxForce;
      if (meshMinForce < minForce)       minForce=meshMinForce;
    }
    observer.add(force / meshes.size());
    println(new StringBuffer(i + ""String_Node_Str"").append(force / meshes.size()).append(""String_Node_Str"").append(minForce).append(""String_Node_Str"").append(maxForce).toString());
    if (i > maxPlateauwidth) {
      proceed=force > maxError;
      int d=maxPlateauwidth;
      while (!proceed && d >= 1) {
        try {
          proceed|=Math.abs(observer.getWideSlope(d)) > 0.0001;
        }
 catch (        Exception e) {
          e.printStackTrace();
        }
        d/=2;
      }
    }
    proceed&=++i < maxIterations;
  }
  for (  final SpringMesh mesh : meshes) {
    mesh.updateAffines();
    mesh.updatePassiveVertices();
  }
  System.out.println(""String_Node_Str"" + meshes.size() + ""String_Node_Str""+ i+ ""String_Node_Str"");
  System.out.println(""String_Node_Str"" + decimalFormat.format(force / meshes.size()) + ""String_Node_Str"");
  System.out.println(""String_Node_Str"" + decimalFormat.format(minForce) + ""String_Node_Str"");
  System.out.println(""String_Node_Str"" + decimalFormat.format(maxForce) + ""String_Node_Str"");
}","/** 
 * Optimize a   {@link Collection} of connected {@link SpringMesh SpringMeshes}.
 * @param maxError do not accept convergence if error is > max_error
 * @param maxIterations stop after that many iterations even if there wasno minimum found
 * @param maxPlateauwidth convergence is reached if the average slope inan interval of this size is 0.0 (in double accuracy).  This prevents the algorithm from stopping at plateaus smaller than this value.
 */
public static void optimizeMeshes(final Collection<SpringMesh> meshes,final float maxError,final int maxIterations,final int maxPlateauwidth,final boolean visualize) throws NotEnoughDataPointsException {
  final ErrorStatistic observer=new ErrorStatistic(maxPlateauwidth + 1);
  final ErrorStatistic singleMeshObserver=new ErrorStatistic(maxPlateauwidth + 1);
  int i=0;
  double force=0;
  double maxForce=0;
  double minForce=0;
  boolean proceed=i < maxIterations;
  final ImageStack stackAnimation=new ImageStack(VIS_SIZE,VIS_SIZE);
  final ImagePlus impAnimation=new ImagePlus();
  println(""String_Node_Str"");
  while (proceed) {
    force=0;
    maxForce=0;
    minForce=Double.MAX_VALUE;
    double maxSpeed=0;
    if (visualize) {
      stackAnimation.addSlice(""String_Node_Str"" + i,paintSprings(meshes,VIS_SIZE,VIS_SIZE,maxError));
      impAnimation.setStack(stackAnimation);
      impAnimation.updateAndDraw();
      if (i == 1) {
        impAnimation.show();
      }
    }
    for (    final SpringMesh mesh : meshes) {
      mesh.calculateForceAndSpeed(singleMeshObserver);
      force+=mesh.getForce();
      if (mesh.maxSpeed > maxSpeed)       maxSpeed=mesh.maxSpeed;
      final double meshMaxForce=mesh.maxForce;
      final double meshMinForce=mesh.minForce;
      if (meshMaxForce > maxForce)       maxForce=meshMaxForce;
      if (meshMinForce < minForce)       minForce=meshMinForce;
    }
    observer.add(force / meshes.size());
    final float dt=(float)Math.min(1000,1.0 / maxSpeed);
    for (    final SpringMesh mesh : meshes) {
      mesh.update(dt);
    }
    println(new StringBuffer(i + ""String_Node_Str"").append(force / meshes.size()).append(""String_Node_Str"").append(minForce).append(""String_Node_Str"").append(maxForce).toString());
    if (i > maxPlateauwidth) {
      proceed=force > maxError;
      int d=maxPlateauwidth;
      while (!proceed && d >= 1) {
        try {
          proceed|=Math.abs(observer.getWideSlope(d)) > 0.0001;
        }
 catch (        Exception e) {
          e.printStackTrace();
        }
        d/=2;
      }
    }
    proceed&=++i < maxIterations;
  }
  for (  final SpringMesh mesh : meshes) {
    mesh.updateAffines();
    mesh.updatePassiveVertices();
  }
  System.out.println(""String_Node_Str"" + meshes.size() + ""String_Node_Str""+ i+ ""String_Node_Str"");
  System.out.println(""String_Node_Str"" + decimalFormat.format(force / meshes.size()) + ""String_Node_Str"");
  System.out.println(""String_Node_Str"" + decimalFormat.format(minForce) + ""String_Node_Str"");
  System.out.println(""String_Node_Str"" + decimalFormat.format(maxForce) + ""String_Node_Str"");
}",0.9511455525606468
11699,"/** 
 * Smooth with a Gaussian kernel that represents downsampling at a given scale factor and sourceSigma.
 */
final static public void smoothForScale(final ImageProcessor source,final float scale,final float sourceSigma,final float targetSigma){
  if (scale >= 1.0f)   return;
  float s=targetSigma / scale;
  float sigma=(float)Math.sqrt(s * s - sourceSigma * sourceSigma);
  new GaussianBlur().blurGaussian(source,sigma,sigma,0.01);
}","/** 
 * Smooth with a Gaussian kernel that represents downsampling at a given scale factor and sourceSigma.
 */
final static public void smoothForScale(final ImageProcessor source,final float scale,final float sourceSigma,final float targetSigma){
  float s=targetSigma / scale;
  final float v=s * s - sourceSigma * sourceSigma;
  if (v <= 0)   return;
  final float sigma=(float)Math.sqrt(v);
  new GaussianBlur().blurGaussian(source,sigma,sigma,0.01);
}",0.8076062639821029
11700,"/** 
 * Create a downsampled ImageProcessor.
 * @param source the source image
 * @param scale scaling factor
 * @param sourceSigma the Gaussian at which the source was sampled (guess 0.5 if you do not know)
 * @param targetSigma the Gaussian at which the target will be sampled
 * @return a new {@link FloatProcessor}
 */
final static public ImageProcessor createDownsampled(final ImageProcessor source,final float scale,final float sourceSigma,final float targetSigma){
  final int ow=source.getWidth();
  final int oh=source.getHeight();
  final int w=Math.round(ow * scale);
  final int h=Math.round(oh * scale);
  final ImageProcessor temp=source.duplicate();
  temp.setMinAndMax(source.getMin(),source.getMax());
  if (scale >= 1.0f)   return temp;
  smoothForScale(temp,scale,sourceSigma,targetSigma);
  final ImageProcessor target=temp.resize(w,h);
  target.setMinAndMax(source.getMin(),source.getMax());
  return target;
}","/** 
 * Create a downsampled ImageProcessor.
 * @param source the source image
 * @param scale scaling factor
 * @param sourceSigma the Gaussian at which the source was sampled (guess 0.5 if you do not know)
 * @param targetSigma the Gaussian at which the target will be sampled
 * @return a new {@link FloatProcessor}
 */
final static public ImageProcessor createDownsampled(final ImageProcessor source,final float scale,final float sourceSigma,final float targetSigma){
  final int ow=source.getWidth();
  final int oh=source.getHeight();
  final int w=Math.round(ow * scale);
  final int h=Math.round(oh * scale);
  final ImageProcessor temp=source.duplicate();
  temp.setMinAndMax(source.getMin(),source.getMax());
  smoothForScale(temp,scale,sourceSigma,targetSigma);
  if (scale >= 1.0f)   return temp;
  final ImageProcessor target=temp.resize(w,h);
  target.setMinAndMax(source.getMin(),source.getMax());
  return target;
}",0.8517722878625135
11701,"@Override public void init(){
  ipOriginal=imp.getProcessor();
  if (imp.getType() == ImagePlus.GRAY32)   fp=(FloatProcessor)ipOriginal.duplicate();
 else   fp=(FloatProcessor)ipOriginal.convertToFloat();
  imp.setProcessor(fp);
  std=new BlockStatistics(fp);
}","@Override final protected void init(){
  ipOriginal=imp.getProcessor();
  if (imp.getType() == ImagePlus.GRAY32)   fp=(FloatProcessor)ipOriginal.duplicate();
 else   fp=(FloatProcessor)ipOriginal.convertToFloat();
  imp.setProcessor(fp);
  std=new BlockStatistics(fp);
}",0.96045197740113
11702,"final static private int colorVector(float xs,float ys){
  xs/=maxDistance;
  ys/=maxDistance;
  final double a=Math.sqrt(xs * xs + ys * ys);
  if (a == 0.0)   return 0;
  double o=(Math.atan2(xs / a,ys / a) + Math.PI) / Math.PI * 3;
  final double r, g, b;
  if (o < 3)   r=Math.min(1.0,Math.max(0.0,2.0 - o)) * a;
 else   r=Math.min(1.0,Math.max(0.0,o - 4.0)) * a;
  o+=2;
  if (o >= 6)   o-=6;
  if (o < 3)   g=Math.min(1.0,Math.max(0.0,2.0 - o)) * a;
 else   g=Math.min(1.0,Math.max(0.0,o - 4.0)) * a;
  o+=2;
  if (o >= 6)   o-=6;
  if (o < 3)   b=Math.min(1.0,Math.max(0.0,2.0 - o)) * a;
 else   b=Math.min(1.0,Math.max(0.0,o - 4.0)) * a;
  return (((int)(r * 255) << 8) + (int)(g * 255) << 8) + (int)(b * 255);
}","final static private int colorVector(float xs,float ys){
  xs/=maxDistance;
  ys/=maxDistance;
  final double a=Math.sqrt(xs * xs + ys * ys);
  if (a == 0.0)   return 0;
  double o=(Math.atan2(xs / a,ys / a) + Math.PI) / Math.PI * 3;
  final double r, g, b;
  if (o < 3)   r=Math.min(1.0,Math.max(0.0,2.0 - o)) * a;
 else   r=Math.min(1.0,Math.max(0.0,o - 4.0)) * a;
  o+=2;
  if (o >= 6)   o-=6;
  if (o < 3)   g=Math.min(1.0,Math.max(0.0,2.0 - o)) * a;
 else   g=Math.min(1.0,Math.max(0.0,o - 4.0)) * a;
  o+=2;
  if (o >= 6)   o-=6;
  if (o < 3)   b=Math.min(1.0,Math.max(0.0,2.0 - o)) * a;
 else   b=Math.min(1.0,Math.max(0.0,o - 4.0)) * a;
  return ((((int)(r * 255) << 8) | (int)(g * 255)) << 8) | (int)(b * 255);
}",0.9958333333333332
11703,"final static private void algebraicToPolarAndColor(final byte[] ipXPixels,final byte[] ipYPixels,final float[] ipRPixels,final float[] ipPhiPixels,final int[] ipColorPixels,final double max){
  final int n=ipXPixels.length;
  for (int i=0; i < n; ++i) {
    final double x=ipXPixels[i] / max;
    final double y=ipYPixels[i] / max;
    final double r=Math.sqrt(x * x + y * y);
    final double phi=Math.atan2(x / r,y / r);
    ipRPixels[i]=(float)r;
    ipPhiPixels[i]=(float)phi;
    if (r == 0.0)     ipColorPixels[i]=0;
 else {
      final double red, green, blue;
      double o=(phi + Math.PI) / Math.PI * 3;
      if (o < 3)       red=Math.min(1.0,Math.max(0.0,2.0 - o)) * r;
 else       red=Math.min(1.0,Math.max(0.0,o - 4.0)) * r;
      o+=2;
      if (o >= 6)       o-=6;
      if (o < 3)       green=Math.min(1.0,Math.max(0.0,2.0 - o)) * r;
 else       green=Math.min(1.0,Math.max(0.0,o - 4.0)) * r;
      o+=2;
      if (o >= 6)       o-=6;
      if (o < 3)       blue=Math.min(1.0,Math.max(0.0,2.0 - o)) * r;
 else       blue=Math.min(1.0,Math.max(0.0,o - 4.0)) * r;
      ipColorPixels[i]=(((int)(red * 255) << 8) | (int)(green * 255) << 8) | (int)(blue * 255);
    }
  }
}","final static private void algebraicToPolarAndColor(final byte[] ipXPixels,final byte[] ipYPixels,final float[] ipRPixels,final float[] ipPhiPixels,final int[] ipColorPixels,final double max){
  final int n=ipXPixels.length;
  for (int i=0; i < n; ++i) {
    final double x=ipXPixels[i] / max;
    final double y=ipYPixels[i] / max;
    final double r=Math.sqrt(x * x + y * y);
    final double phi=Math.atan2(x / r,y / r);
    ipRPixels[i]=(float)r;
    ipPhiPixels[i]=(float)phi;
    if (r == 0.0)     ipColorPixels[i]=0;
 else {
      final double red, green, blue;
      double o=(phi + Math.PI) / Math.PI * 3;
      if (o < 3)       red=Math.min(1.0,Math.max(0.0,2.0 - o)) * r;
 else       red=Math.min(1.0,Math.max(0.0,o - 4.0)) * r;
      o+=2;
      if (o >= 6)       o-=6;
      if (o < 3)       green=Math.min(1.0,Math.max(0.0,2.0 - o)) * r;
 else       green=Math.min(1.0,Math.max(0.0,o - 4.0)) * r;
      o+=2;
      if (o >= 6)       o-=6;
      if (o < 3)       blue=Math.min(1.0,Math.max(0.0,2.0 - o)) * r;
 else       blue=Math.min(1.0,Math.max(0.0,o - 4.0)) * r;
      ipColorPixels[i]=((((int)(red * 255) << 8) | (int)(green * 255)) << 8) | (int)(blue * 255);
    }
  }
}",0.9991575400168492
11704,"final public void run() throws Exception {
  final ImagePlus imp=WindowManager.getCurrentImage();
  if (imp == null) {
    System.err.println(""String_Node_Str"");
    return;
  }
  if (!p.setup())   return;
  final ImageStack stack=imp.getStack();
  final ExecutorService exec=Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());
  final ArrayList<Future<?>> tasks=new ArrayList<Future<?>>();
  final String base_path=System.getProperty(""String_Node_Str"") + ""String_Node_Str"";
  final AtomicInteger counter=new AtomicInteger(0);
  for (int i=1; i <= stack.getSize(); i++) {
    final int slice=i;
    tasks.add(exec.submit(new Callable<Object>(){
      public Object call(){
        IJ.showProgress(counter.getAndIncrement(),stack.getSize());
        final String path=base_path + stack.getSliceLabel(slice) + ""String_Node_Str"";
        ArrayList<Feature> fs=deserializeFeatures(p.sift,path);
        if (null == fs) {
          final FloatArray2DSIFT sift=new FloatArray2DSIFT(p.sift);
          final SIFT ijSIFT=new SIFT(sift);
          fs=new ArrayList<Feature>();
          ijSIFT.extractFeatures(stack.getProcessor(slice),fs);
          if (!serializeFeatures(p.sift,fs,path)) {
            IJ.log(""String_Node_Str"" + stack.getSliceLabel(slice));
          }
        }
        IJ.log(fs.size() + ""String_Node_Str"" + stack.getSliceLabel(slice));
        return null;
      }
    }
));
  }
  for (  Future<?> fu : tasks) {
    fu.get();
  }
  tasks.clear();
  final InvertibleCoordinateTransform[] transforms=new InvertibleCoordinateTransform[stack.getSize() - 1];
  final SpringMesh[] meshes=new SpringMesh[stack.getSize()];
  meshes[0]=new SpringMesh(p.springMeshResolution,stack.getWidth(),stack.getHeight(),p.stiffness,p.maxStretch,p.springMeshDamp);
  counter.set(0);
  for (int i=2; i <= stack.getSize(); i++) {
    final int slice=i;
    tasks.add(exec.submit(new Callable<Object>(){
      public Object call(){
        IJ.showProgress(counter.getAndIncrement(),stack.getSize() - 1);
        String path=base_path + stack.getSliceLabel(slice) + ""String_Node_Str"";
        ArrayList<PointMatch> candidates=deserializePointMatches(p,path);
        if (null == candidates) {
          ArrayList<Feature> fs1=deserializeFeatures(p.sift,base_path + stack.getSliceLabel(slice - 1) + ""String_Node_Str"");
          ArrayList<Feature> fs2=deserializeFeatures(p.sift,base_path + stack.getSliceLabel(slice) + ""String_Node_Str"");
          candidates=new ArrayList<PointMatch>(FloatArray2DSIFT.createMatches(fs2,fs1,p.rod));
          if (!serializePointMatches(p,candidates,path)) {
            IJ.log(""String_Node_Str"");
          }
        }
        AbstractAffineModel2D<?> model;
switch (p.modelIndex) {
case 0:
          model=new TranslationModel2D();
        break;
case 1:
      model=new RigidModel2D();
    break;
case 2:
  model=new SimilarityModel2D();
break;
case 3:
model=new AffineModel2D();
break;
default :
return null;
}
final ArrayList<PointMatch> inliers=new ArrayList<PointMatch>();
boolean modelFound;
try {
modelFound=model.filterRansac(candidates,inliers,1000,p.maxEpsilon,p.minInlierRatio);
}
 catch (Exception e) {
modelFound=false;
System.err.println(e.getMessage());
}
if (modelFound) {
transforms[slice - 1]=model;
}
meshes[slice - 1]=new SpringMesh(p.springMeshResolution,stack.getWidth(),stack.getHeight(),p.stiffness,p.maxStretch,p.springMeshDamp);
return null;
}
}
));
}
for (Future<?> fu : tasks) {
fu.get();
}
tasks.clear();
final int blockRadius=Math.max(32,stack.getWidth() / p.springMeshResolution / 2);
final int searchRadius=Math.round(p.maxEpsilon);
for (int i=1; i < stack.getSize(); ++i) {
final int slice=i;
tasks.add(exec.submit(new Callable<Object>(){
public Object call(){
final SpringMesh m1=meshes[slice - 1];
final SpringMesh m2=meshes[slice];
String path12=base_path + stack.getSliceLabel(slice) + ""String_Node_Str""+ stack.getSliceLabel(slice + 1)+ ""String_Node_Str"";
String path21=base_path + stack.getSliceLabel(slice + 1) + ""String_Node_Str""+ stack.getSliceLabel(slice)+ ""String_Node_Str"";
ArrayList<PointMatch> pm12=deserializeBlockMatches(p,path12);
ArrayList<PointMatch> pm21=deserializeBlockMatches(p,path21);
if (null == pm12 || null == pm21) {
pm12=new ArrayList<PointMatch>();
pm21=new ArrayList<PointMatch>();
final Collection<Vertex> v1=m1.getVertices();
final Collection<Vertex> v2=m2.getVertices();
final FloatProcessor ip1=(FloatProcessor)stack.getProcessor(slice).convertToFloat().duplicate();
final FloatProcessor ip2=(FloatProcessor)stack.getProcessor(slice + 1).convertToFloat().duplicate();
BlockMatching.matchByMaximalPMCC(ip1,ip2,Math.min(1.0f,(float)p.sift.maxOctaveSize / ip1.getWidth()),transforms[slice - 1].createInverse(),blockRadius,blockRadius,searchRadius,searchRadius,p.minR,p.rodR,p.maxCurvatureR,v1,pm12,new ErrorStatistic(1));
IJ.log(""String_Node_Str"" + pm12.size() + ""String_Node_Str"");
BlockMatching.matchByMaximalPMCC(ip2,ip1,Math.min(1.0f,(float)p.sift.maxOctaveSize / ip1.getWidth()),transforms[slice - 1],blockRadius,blockRadius,searchRadius,searchRadius,p.minR,p.rodR,p.maxCurvatureR,v2,pm21,new ErrorStatistic(1));
IJ.log(""String_Node_Str"" + pm21.size() + ""String_Node_Str"");
}
serializePointMatches(p,pm12,path12);
serializePointMatches(p,pm21,path21);
synchronized (m2) {
for (final PointMatch pm : pm12) {
final Vertex p1=(Vertex)pm.getP1();
final Vertex p2=new Vertex(pm.getP2());
p1.addSpring(p2,new Spring(0,1));
m2.addPassiveVertex(p2);
}
}
synchronized (m1) {
for (final PointMatch pm : pm21) {
final Vertex p1=(Vertex)pm.getP1();
final Vertex p2=new Vertex(pm.getP2());
p1.addSpring(p2,new Spring(0,1));
m1.addPassiveVertex(p2);
}
}
return null;
}
}
));
}
for (Future<?> fu : tasks) {
fu.get();
}
tasks.clear();
for (int i=1; i < stack.getSize(); ++i) {
final CoordinateTransformList<CoordinateTransform> ctl=new CoordinateTransformList<CoordinateTransform>();
for (int j=i - 1; j >= 0; --j) ctl.add(transforms[j]);
meshes[i].init(ctl);
}
try {
long t0=System.currentTimeMillis();
IJ.log(""String_Node_Str"");
SpringMesh.optimizeMeshes(Arrays.asList(meshes),p.maxEpsilon,p.maxIterations,p.maxPlateauwidth);
IJ.log(""String_Node_Str"" + (System.currentTimeMillis() - t0) + ""String_Node_Str"");
}
 catch (NotEnoughDataPointsException e) {
e.printStackTrace();
}
final float[] min=new float[2];
final float[] max=new float[2];
for (final SpringMesh mesh : meshes) {
final float[] meshMin=new float[2];
final float[] meshMax=new float[2];
mesh.bounds(meshMin,meshMax);
Util.min(min,meshMin);
Util.max(max,meshMax);
}
for (final SpringMesh mesh : meshes) {
for (final Vertex vertex : mesh.getVertices()) {
final float[] w=vertex.getW();
w[0]-=min[0];
w[1]-=min[1];
}
mesh.updateAffines();
mesh.updatePassiveVertices();
}
final int width=(int)Math.ceil(max[0] - min[0]);
final int height=(int)Math.ceil(max[1] - min[1]);
for (int i=1; i <= stack.getSize(); ++i) {
final TransformMeshMapping<SpringMesh> meshMapping=new TransformMeshMapping<SpringMesh>(meshes[i - 1]);
final ImageProcessor ip=stack.getProcessor(i).createProcessor(width,height);
if (p.interpolate) meshMapping.mapInterpolated(stack.getProcessor(i),ip);
 else meshMapping.map(stack.getProcessor(i),ip);
IJ.save(new ImagePlus(""String_Node_Str"" + i,ip),""String_Node_Str"" + String.format(""String_Node_Str"",i) + ""String_Node_Str"");
}
IJ.log(""String_Node_Str"");
}","final public void run() throws Exception {
  final ImagePlus imp=WindowManager.getCurrentImage();
  if (imp == null) {
    System.err.println(""String_Node_Str"");
    return;
  }
  if (!p.setup())   return;
  final ImageStack stack=imp.getStack();
  final ExecutorService exec=Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());
  final ArrayList<Future<?>> tasks=new ArrayList<Future<?>>();
  final String base_path=System.getProperty(""String_Node_Str"") + ""String_Node_Str"";
  final AtomicInteger counter=new AtomicInteger(0);
  for (int i=1; i <= stack.getSize(); i++) {
    final int slice=i;
    tasks.add(exec.submit(new Callable<Object>(){
      public Object call(){
        IJ.showProgress(counter.getAndIncrement(),stack.getSize());
        final String path=base_path + stack.getSliceLabel(slice) + ""String_Node_Str"";
        ArrayList<Feature> fs=deserializeFeatures(p.sift,path);
        if (null == fs) {
          final FloatArray2DSIFT sift=new FloatArray2DSIFT(p.sift);
          final SIFT ijSIFT=new SIFT(sift);
          fs=new ArrayList<Feature>();
          ijSIFT.extractFeatures(stack.getProcessor(slice),fs);
          if (!serializeFeatures(p.sift,fs,path)) {
            IJ.log(""String_Node_Str"" + stack.getSliceLabel(slice));
          }
        }
        IJ.log(fs.size() + ""String_Node_Str"" + stack.getSliceLabel(slice));
        return null;
      }
    }
));
  }
  for (  Future<?> fu : tasks) {
    fu.get();
  }
  tasks.clear();
  final InvertibleCoordinateTransform[] transforms=new InvertibleCoordinateTransform[stack.getSize() - 1];
  final SpringMesh[] meshes=new SpringMesh[stack.getSize()];
  meshes[0]=new SpringMesh(p.springMeshResolution,stack.getWidth(),stack.getHeight(),p.stiffness,p.maxStretch,p.springMeshDamp);
  counter.set(0);
  for (int i=2; i <= stack.getSize(); i++) {
    final int slice=i;
    tasks.add(exec.submit(new Callable<Object>(){
      public Object call(){
        IJ.showProgress(counter.getAndIncrement(),stack.getSize() - 1);
        String path=base_path + stack.getSliceLabel(slice) + ""String_Node_Str"";
        ArrayList<PointMatch> candidates=deserializePointMatches(p,path);
        if (null == candidates) {
          ArrayList<Feature> fs1=deserializeFeatures(p.sift,base_path + stack.getSliceLabel(slice - 1) + ""String_Node_Str"");
          ArrayList<Feature> fs2=deserializeFeatures(p.sift,base_path + stack.getSliceLabel(slice) + ""String_Node_Str"");
          candidates=new ArrayList<PointMatch>(FloatArray2DSIFT.createMatches(fs2,fs1,p.rod));
          if (!serializePointMatches(p,candidates,path)) {
            IJ.log(""String_Node_Str"");
          }
        }
        AbstractAffineModel2D<?> model;
switch (p.modelIndex) {
case 0:
          model=new TranslationModel2D();
        break;
case 1:
      model=new RigidModel2D();
    break;
case 2:
  model=new SimilarityModel2D();
break;
case 3:
model=new AffineModel2D();
break;
default :
return null;
}
final ArrayList<PointMatch> inliers=new ArrayList<PointMatch>();
boolean modelFound;
try {
modelFound=model.filterRansac(candidates,inliers,1000,p.maxEpsilon,p.minInlierRatio);
}
 catch (Exception e) {
modelFound=false;
System.err.println(e.getMessage());
}
if (modelFound) {
transforms[slice - 2]=model;
}
meshes[slice - 1]=new SpringMesh(p.springMeshResolution,stack.getWidth(),stack.getHeight(),p.stiffness,p.maxStretch,p.springMeshDamp);
return null;
}
}
));
}
for (Future<?> fu : tasks) {
fu.get();
}
tasks.clear();
final int blockRadius=Math.max(32,stack.getWidth() / p.springMeshResolution / 2);
final int searchRadius=Math.round(p.maxEpsilon);
for (int i=1; i < stack.getSize(); ++i) {
final int slice=i;
tasks.add(exec.submit(new Callable<Object>(){
public Object call(){
final SpringMesh m1=meshes[slice - 1];
final SpringMesh m2=meshes[slice];
String path12=base_path + stack.getSliceLabel(slice) + ""String_Node_Str""+ stack.getSliceLabel(slice + 1)+ ""String_Node_Str"";
String path21=base_path + stack.getSliceLabel(slice + 1) + ""String_Node_Str""+ stack.getSliceLabel(slice)+ ""String_Node_Str"";
ArrayList<PointMatch> pm12=deserializeBlockMatches(p,path12);
ArrayList<PointMatch> pm21=deserializeBlockMatches(p,path21);
if (null == pm12 || null == pm21) {
pm12=new ArrayList<PointMatch>();
pm21=new ArrayList<PointMatch>();
final Collection<Vertex> v1=m1.getVertices();
final Collection<Vertex> v2=m2.getVertices();
final FloatProcessor ip1=(FloatProcessor)stack.getProcessor(slice).convertToFloat().duplicate();
final FloatProcessor ip2=(FloatProcessor)stack.getProcessor(slice + 1).convertToFloat().duplicate();
BlockMatching.matchByMaximalPMCC(ip1,ip2,Math.min(1.0f,(float)p.sift.maxOctaveSize / ip1.getWidth()),transforms[slice - 1].createInverse(),blockRadius,blockRadius,searchRadius,searchRadius,p.minR,p.rodR,p.maxCurvatureR,v1,pm12,new ErrorStatistic(1));
IJ.log(""String_Node_Str"" + pm12.size() + ""String_Node_Str"");
BlockMatching.matchByMaximalPMCC(ip2,ip1,Math.min(1.0f,(float)p.sift.maxOctaveSize / ip1.getWidth()),transforms[slice - 1],blockRadius,blockRadius,searchRadius,searchRadius,p.minR,p.rodR,p.maxCurvatureR,v2,pm21,new ErrorStatistic(1));
IJ.log(""String_Node_Str"" + pm21.size() + ""String_Node_Str"");
}
serializePointMatches(p,pm12,path12);
serializePointMatches(p,pm21,path21);
synchronized (m2) {
for (final PointMatch pm : pm12) {
final Vertex p1=(Vertex)pm.getP1();
final Vertex p2=new Vertex(pm.getP2());
p1.addSpring(p2,new Spring(0,1));
m2.addPassiveVertex(p2);
}
}
synchronized (m1) {
for (final PointMatch pm : pm21) {
final Vertex p1=(Vertex)pm.getP1();
final Vertex p2=new Vertex(pm.getP2());
p1.addSpring(p2,new Spring(0,1));
m1.addPassiveVertex(p2);
}
}
return null;
}
}
));
}
for (Future<?> fu : tasks) {
fu.get();
}
tasks.clear();
for (int i=1; i < stack.getSize(); ++i) {
final CoordinateTransformList<CoordinateTransform> ctl=new CoordinateTransformList<CoordinateTransform>();
for (int j=i - 1; j >= 0; --j) ctl.add(transforms[j]);
meshes[i].init(ctl);
}
try {
long t0=System.currentTimeMillis();
IJ.log(""String_Node_Str"");
SpringMesh.optimizeMeshes(Arrays.asList(meshes),p.maxEpsilon,p.maxIterations,p.maxPlateauwidth);
IJ.log(""String_Node_Str"" + (System.currentTimeMillis() - t0) + ""String_Node_Str"");
}
 catch (NotEnoughDataPointsException e) {
e.printStackTrace();
}
final float[] min=new float[2];
final float[] max=new float[2];
for (final SpringMesh mesh : meshes) {
final float[] meshMin=new float[2];
final float[] meshMax=new float[2];
mesh.bounds(meshMin,meshMax);
Util.min(min,meshMin);
Util.max(max,meshMax);
}
for (final SpringMesh mesh : meshes) {
for (final Vertex vertex : mesh.getVertices()) {
final float[] w=vertex.getW();
w[0]-=min[0];
w[1]-=min[1];
}
mesh.updateAffines();
mesh.updatePassiveVertices();
}
final int width=(int)Math.ceil(max[0] - min[0]);
final int height=(int)Math.ceil(max[1] - min[1]);
for (int i=1; i <= stack.getSize(); ++i) {
final TransformMeshMapping<SpringMesh> meshMapping=new TransformMeshMapping<SpringMesh>(meshes[i - 1]);
final ImageProcessor ip=stack.getProcessor(i).createProcessor(width,height);
if (p.interpolate) meshMapping.mapInterpolated(stack.getProcessor(i),ip);
 else meshMapping.map(stack.getProcessor(i),ip);
IJ.save(new ImagePlus(""String_Node_Str"" + i,ip),""String_Node_Str"" + String.format(""String_Node_Str"",i) + ""String_Node_Str"");
}
IJ.log(""String_Node_Str"");
}",0.9998636859323882
11705,"@Override final public void set(final HomographyModel2D m){
  m00=m.m00;
  m01=m.m01;
  m02=m.m02;
  m10=m.m00;
  m11=m.m11;
  m12=m.m12;
  m20=m.m20;
  m21=m.m21;
  m22=m.m22;
  i00=m.i00;
  i01=m.i01;
  i02=m.i02;
  i10=m.i00;
  i11=m.i11;
  i12=m.i12;
  i20=m.i20;
  i21=m.i21;
  i22=m.i22;
  cost=m.getCost();
}","@Override final public void set(final HomographyModel2D m){
  m00=m.m00;
  m01=m.m01;
  m02=m.m02;
  m10=m.m10;
  m11=m.m11;
  m12=m.m12;
  m20=m.m20;
  m21=m.m21;
  m22=m.m22;
  i00=m.i00;
  i01=m.i01;
  i02=m.i02;
  i10=m.i10;
  i11=m.i11;
  i12=m.i12;
  i20=m.i20;
  i21=m.i21;
  i22=m.i22;
  cost=m.getCost();
}",0.6253968253968254
11706,"public void estimateInverseBounds(final float[] min,final float[] max) throws NoninvertibleModelException {
}","@Override public void estimateInverseBounds(final float[] min,final float[] max) throws NoninvertibleModelException {
}",0.956140350877193
11707,"final private float[] fitToUnitSquare(final float[] p1,final float[] p2,final float[] p3,final float[] p4){
  final float x1=p1[0];
  final float x2=p2[0];
  final float x3=p3[0];
  final float x4=p4[0];
  final float y1=p1[1];
  final float y2=p2[1];
  final float y3=p3[1];
  final float y4=p4[1];
  final float s=(x2 - x3) * (y4 - y3) - (x4 - x3) * (y2 - y3);
  final float b00, b01, b02, b10, b11, b12, b20, b21, b22;
  b20=((x1 - x2 + x3 - x4) * (y4 - y3) - (y1 - y2 + y3 - y4) * (x4 - x3)) / s;
  b21=((y1 - y2 + y3 - y4) * (x2 - x3) - (x1 - x2 + x3 - x4) * (y2 - y3)) / s;
  b00=x2 - x1 + b20 * x2;
  b01=x4 - x1 + b21 * x4;
  b02=x1;
  b10=y2 - y1 + b20 * y2;
  b11=y4 - y1 + b21 * y4;
  b12=y1;
  b22=1;
  return new float[]{b00,b01,b02,b10,b11,b12,b20,b21,b22};
}","final static private float[] fitToUnitSquare(final float[] p1,final float[] p2,final float[] p3,final float[] p4){
  final float x1=p1[0];
  final float x2=p2[0];
  final float x3=p3[0];
  final float x4=p4[0];
  final float y1=p1[1];
  final float y2=p2[1];
  final float y3=p3[1];
  final float y4=p4[1];
  final float s=(x2 - x3) * (y4 - y3) - (x4 - x3) * (y2 - y3);
  final float b00, b01, b02, b10, b11, b12, b20, b21, b22;
  b20=((x1 - x2 + x3 - x4) * (y4 - y3) - (y1 - y2 + y3 - y4) * (x4 - x3)) / s;
  b21=((y1 - y2 + y3 - y4) * (x2 - x3) - (x1 - x2 + x3 - x4) * (y2 - y3)) / s;
  b00=x2 - x1 + b20 * x2;
  b01=x4 - x1 + b21 * x4;
  b02=x1;
  b10=y2 - y1 + b20 * y2;
  b11=y4 - y1 + b21 * y4;
  b12=y1;
  b22=1;
  return new float[]{b00,b01,b02,b10,b11,b12,b20,b21,b22};
}",0.995492594977463
11708,"public void estimateBounds(final float[] min,final float[] max){
}","@Override public void estimateBounds(final float[] min,final float[] max){
}",0.9295774647887324
11709,"@Override final public HomographyModel2D copy(){
  final HomographyModel2D m=new HomographyModel2D();
  m.m00=m00;
  m.m01=m01;
  m.m02=m02;
  m.m10=m00;
  m.m11=m11;
  m.m12=m12;
  m.m20=m20;
  m.m21=m21;
  m.m22=m22;
  m.i00=i00;
  m.i01=i01;
  m.i02=i02;
  m.i10=i00;
  m.i11=i11;
  m.i12=i12;
  m.i20=i20;
  m.i21=i21;
  m.i22=i22;
  m.cost=getCost();
  return m;
}","@Override final public HomographyModel2D copy(){
  final HomographyModel2D m=new HomographyModel2D();
  m.m00=m00;
  m.m01=m01;
  m.m02=m02;
  m.m10=m10;
  m.m11=m11;
  m.m12=m12;
  m.m20=m20;
  m.m21=m21;
  m.m22=m22;
  m.i00=i00;
  m.i01=i01;
  m.i02=i02;
  m.i10=i10;
  m.i11=i11;
  m.i12=i12;
  m.i20=i20;
  m.i21=i21;
  m.i22=i22;
  m.cost=getCost();
  return m;
}",0.6802168021680217
11710,"final public void run(String args){
  final ArrayList<PointMatch> matches=new ArrayList<PointMatch>();
  if (!setup())   return;
  final ImagePlus target=template.createImagePlus();
  final ImageProcessor ipSource=source.getProcessor();
  final ImageProcessor ipTarget=template.getProcessor().createProcessor(template.getWidth(),template.getHeight());
  final List<Point> sourcePoints=Util.pointRoiToPoints((PointRoi)source.getRoi());
  final List<Point> templatePoints=Util.pointRoiToPoints((PointRoi)template.getRoi());
  final int numMatches=Math.min(sourcePoints.size(),templatePoints.size());
  for (int i=0; i < numMatches; ++i)   matches.add(new PointMatch(sourcePoints.get(i),templatePoints.get(i)));
  final Mapping<?> mapping;
  if (methodIndex == 0) {
    AbstractAffineModel2D<?> model;
switch (modelClassIndex) {
case 0:
      model=new TranslationModel2D();
    break;
case 1:
  model=new RigidModel2D();
break;
case 2:
model=new SimilarityModel2D();
break;
case 3:
model=new AffineModel2D();
break;
default :
return;
}
try {
model.fit(matches);
}
 catch (NotEnoughDataPointsException e) {
IJ.showMessage(""String_Node_Str"");
return;
}
catch (IllDefinedDataPointsException e) {
IJ.showMessage(""String_Node_Str"");
return;
}
mapping=new InverseTransformMapping<AbstractAffineModel2D<?>>(model);
}
 else {
final MovingLeastSquaresTransform t=new MovingLeastSquaresTransform();
try {
switch (modelClassIndex) {
case 0:
t.setModel(TranslationModel2D.class);
break;
case 1:
t.setModel(RigidModel2D.class);
break;
case 2:
t.setModel(SimilarityModel2D.class);
break;
case 3:
t.setModel(AffineModel2D.class);
break;
default :
return;
}
}
 catch (Exception e) {
return;
}
t.setAlpha(alpha);
try {
t.setMatches(matches);
mapping=new TransformMeshMapping(new CoordinateTransformMesh(t,meshResolution,source.getWidth(),source.getHeight()));
}
 catch (NotEnoughDataPointsException e) {
IJ.showMessage(""String_Node_Str"");
return;
}
catch (IllDefinedDataPointsException e) {
IJ.showMessage(""String_Node_Str"");
return;
}
}
if (interpolate) mapping.mapInterpolated(ipSource,ipTarget);
 else mapping.map(ipSource,ipTarget);
target.setProcessor(""String_Node_Str"" + source.getTitle(),ipTarget);
target.show();
}","final public void run(String args){
  final ArrayList<PointMatch> matches=new ArrayList<PointMatch>();
  if (!setup())   return;
  final ImagePlus target=template.createImagePlus();
  final ImageProcessor ipSource=source.getProcessor();
  final ImageProcessor ipTarget=source.getProcessor().createProcessor(template.getWidth(),template.getHeight());
  final List<Point> sourcePoints=Util.pointRoiToPoints((PointRoi)source.getRoi());
  final List<Point> templatePoints=Util.pointRoiToPoints((PointRoi)template.getRoi());
  final int numMatches=Math.min(sourcePoints.size(),templatePoints.size());
  for (int i=0; i < numMatches; ++i)   matches.add(new PointMatch(sourcePoints.get(i),templatePoints.get(i)));
  final Mapping<?> mapping;
  if (methodIndex == 0) {
    AbstractAffineModel2D<?> model;
switch (modelClassIndex) {
case 0:
      model=new TranslationModel2D();
    break;
case 1:
  model=new RigidModel2D();
break;
case 2:
model=new SimilarityModel2D();
break;
case 3:
model=new AffineModel2D();
break;
default :
return;
}
try {
model.fit(matches);
}
 catch (NotEnoughDataPointsException e) {
IJ.showMessage(""String_Node_Str"");
return;
}
catch (IllDefinedDataPointsException e) {
IJ.showMessage(""String_Node_Str"");
return;
}
mapping=new InverseTransformMapping<AbstractAffineModel2D<?>>(model);
}
 else {
final MovingLeastSquaresTransform t=new MovingLeastSquaresTransform();
try {
switch (modelClassIndex) {
case 0:
t.setModel(TranslationModel2D.class);
break;
case 1:
t.setModel(RigidModel2D.class);
break;
case 2:
t.setModel(SimilarityModel2D.class);
break;
case 3:
t.setModel(AffineModel2D.class);
break;
default :
return;
}
}
 catch (Exception e) {
return;
}
t.setAlpha(alpha);
try {
t.setMatches(matches);
mapping=new TransformMeshMapping(new CoordinateTransformMesh(t,meshResolution,source.getWidth(),source.getHeight()));
}
 catch (NotEnoughDataPointsException e) {
IJ.showMessage(""String_Node_Str"");
return;
}
catch (IllDefinedDataPointsException e) {
IJ.showMessage(""String_Node_Str"");
return;
}
}
if (interpolate) mapping.mapInterpolated(ipSource,ipTarget);
 else mapping.map(ipSource,ipTarget);
target.setProcessor(""String_Node_Str"" + source.getTitle(),ipTarget);
target.show();
}",0.997275204359673
11711,"final public void run(final String args){
  fs1.clear();
  fs2.clear();
  if (IJ.versionLessThan(""String_Node_Str""))   return;
  final ImagePlus imp=WindowManager.getCurrentImage();
  if (imp == null) {
    System.err.println(""String_Node_Str"");
    return;
  }
  GenericDialog gd=new GenericDialog(""String_Node_Str"");
  gd.addMessage(""String_Node_Str"");
  gd.addNumericField(""String_Node_Str"",p.sift.initialSigma,2,6,""String_Node_Str"");
  gd.addNumericField(""String_Node_Str"",p.sift.steps,0);
  gd.addNumericField(""String_Node_Str"",p.sift.minOctaveSize,0,6,""String_Node_Str"");
  gd.addNumericField(""String_Node_Str"",p.sift.maxOctaveSize,0,6,""String_Node_Str"");
  gd.addMessage(""String_Node_Str"");
  gd.addNumericField(""String_Node_Str"",p.sift.fdSize,0);
  gd.addNumericField(""String_Node_Str"",p.sift.fdBins,0);
  gd.addNumericField(""String_Node_Str"",p.rod,2);
  gd.addMessage(""String_Node_Str"");
  gd.addNumericField(""String_Node_Str"",p.maxEpsilon,2,6,""String_Node_Str"");
  gd.addNumericField(""String_Node_Str"",p.minInlierRatio,2);
  gd.addChoice(""String_Node_Str"",Param.modelStrings,Param.modelStrings[p.modelIndex]);
  gd.addMessage(""String_Node_Str"");
  gd.addCheckbox(""String_Node_Str"",p.interpolate);
  gd.addCheckbox(""String_Node_Str"",p.showInfo);
  gd.showDialog();
  if (gd.wasCanceled())   return;
  p.sift.initialSigma=(float)gd.getNextNumber();
  p.sift.steps=(int)gd.getNextNumber();
  p.sift.minOctaveSize=(int)gd.getNextNumber();
  p.sift.maxOctaveSize=(int)gd.getNextNumber();
  p.sift.fdSize=(int)gd.getNextNumber();
  p.sift.fdBins=(int)gd.getNextNumber();
  p.rod=(float)gd.getNextNumber();
  p.maxEpsilon=(float)gd.getNextNumber();
  p.minInlierRatio=(float)gd.getNextNumber();
  p.modelIndex=gd.getNextChoiceIndex();
  p.interpolate=gd.getNextBoolean();
  p.showInfo=gd.getNextBoolean();
  ImageStack stack=imp.getStack();
  ImageStack stackAligned=new ImageStack(stack.getWidth(),stack.getHeight());
  float vis_scale=256.0f / imp.getWidth();
  ImageStack stackInfo=null;
  ImagePlus impInfo=null;
  if (p.showInfo)   stackInfo=new ImageStack(Math.round(vis_scale * stack.getWidth()),Math.round(vis_scale * stack.getHeight()));
  stackAligned.addSlice(null,stack.getProcessor(1));
  ImagePlus impAligned=new ImagePlus(""String_Node_Str"" + stack.getSize(),stackAligned);
  impAligned.show();
  ImageProcessor ip1;
  ImageProcessor ip2=stack.getProcessor(1);
  ImageProcessor ip3=null;
  FloatArray2DSIFT sift=new FloatArray2DSIFT(p.sift);
  SIFT ijSIFT=new SIFT(sift);
  long start_time=System.currentTimeMillis();
  IJ.log(""String_Node_Str"");
  ijSIFT.extractFeatures(ip2,fs2);
  IJ.log(""String_Node_Str"" + (System.currentTimeMillis() - start_time) + ""String_Node_Str"");
  IJ.log(fs2.size() + ""String_Node_Str"");
  if (p.showInfo)   ip2=downScale(ip2,vis_scale);
  AbstractAffineModel2D model;
switch (p.modelIndex) {
case 0:
    model=new TranslationModel2D();
  break;
case 1:
model=new RigidModel2D();
break;
case 2:
model=new SimilarityModel2D();
break;
case 3:
model=new AffineModel2D();
break;
default :
return;
}
Mapping mapping=new InverseTransformMapping(model);
for (int i=1; i < stack.getSize(); ++i) {
ip1=ip2;
ip2=stack.getProcessor(i + 1);
fs1.clear();
fs1.addAll(fs2);
fs2.clear();
start_time=System.currentTimeMillis();
IJ.log(""String_Node_Str"");
ijSIFT.extractFeatures(ip2,fs2);
IJ.log(""String_Node_Str"" + (System.currentTimeMillis() - start_time) + ""String_Node_Str"");
IJ.log(fs2.size() + ""String_Node_Str"");
start_time=System.currentTimeMillis();
System.out.print(""String_Node_Str"");
Vector<PointMatch> candidates=FloatArray2DSIFT.createMatches(fs2,fs1,1.5f,null,Float.MAX_VALUE,p.rod);
System.out.println(""String_Node_Str"" + (System.currentTimeMillis() - start_time) + ""String_Node_Str"");
IJ.log(candidates.size() + ""String_Node_Str"");
if (p.showInfo) {
ip2=downScale(ip2,vis_scale);
ip1=ip1.convertToRGB();
ip3=ip2.convertToRGB();
ip1.setColor(Color.red);
ip3.setColor(Color.red);
ip1.setLineWidth(2);
ip3.setLineWidth(2);
for (PointMatch m : candidates) {
float[] m_p1=m.getP1().getL();
float[] m_p2=m.getP2().getL();
ip1.drawDot((int)Math.round(vis_scale * m_p2[0]),(int)Math.round(vis_scale * m_p2[1]));
ip3.drawDot((int)Math.round(vis_scale * m_p1[0]),(int)Math.round(vis_scale * m_p1[1]));
}
}
Vector<PointMatch> inliers=new Vector<PointMatch>();
AbstractAffineModel2D<?> currentModel;
switch (p.modelIndex) {
case 0:
currentModel=new TranslationModel2D();
break;
case 1:
currentModel=new RigidModel2D();
break;
case 2:
currentModel=new SimilarityModel2D();
break;
case 3:
currentModel=new AffineModel2D();
break;
default :
return;
}
boolean modelFound;
try {
modelFound=currentModel.filterRansac(candidates,inliers,1000,p.maxEpsilon,p.minInlierRatio);
}
 catch (Exception e) {
modelFound=false;
System.err.println(e.getMessage());
}
if (modelFound) {
if (p.showInfo) {
ip1.setColor(Color.green);
ip3.setColor(Color.green);
ip1.setLineWidth(2);
ip3.setLineWidth(2);
for (PointMatch m : inliers) {
float[] m_p1=m.getP1().getL();
float[] m_p2=m.getP2().getL();
ip1.drawDot((int)Math.round(vis_scale * m_p2[0]),(int)Math.round(vis_scale * m_p2[1]));
ip3.drawDot((int)Math.round(vis_scale * m_p1[0]),(int)Math.round(vis_scale * m_p1[1]));
}
}
model.concatenate(currentModel);
}
ImageProcessor alignedSlice=stack.getProcessor(i + 1).duplicate();
if (p.interpolate) mapping.mapInterpolated(stack.getProcessor(i + 1),alignedSlice);
 else mapping.map(stack.getProcessor(i + 1),alignedSlice);
stackAligned.addSlice(null,alignedSlice);
if (p.showInfo) {
ImageProcessor tmp;
tmp=ip1.createProcessor(stackInfo.getWidth(),stackInfo.getHeight());
tmp.insert(ip1,0,0);
stackInfo.addSlice(null,tmp);
tmp=ip3.createProcessor(stackInfo.getWidth(),stackInfo.getHeight());
tmp.insert(ip3,0,0);
stackInfo.addSlice(null,tmp);
if (i == 1) {
impInfo=new ImagePlus(""String_Node_Str"",stackInfo);
impInfo.show();
}
impInfo.setStack(""String_Node_Str"",stackInfo);
impInfo.updateAndDraw();
}
impAligned.setStack(""String_Node_Str"" + stackAligned.getSize() + ""String_Node_Str""+ stack.getSize(),stackAligned);
impAligned.updateAndDraw();
}
}","final public void run(final String args){
  fs1.clear();
  fs2.clear();
  if (IJ.versionLessThan(""String_Node_Str""))   return;
  final ImagePlus imp=WindowManager.getCurrentImage();
  if (imp == null) {
    System.err.println(""String_Node_Str"");
    return;
  }
  GenericDialog gd=new GenericDialog(""String_Node_Str"");
  gd.addMessage(""String_Node_Str"");
  gd.addNumericField(""String_Node_Str"",p.sift.initialSigma,2,6,""String_Node_Str"");
  gd.addNumericField(""String_Node_Str"",p.sift.steps,0);
  gd.addNumericField(""String_Node_Str"",p.sift.minOctaveSize,0,6,""String_Node_Str"");
  gd.addNumericField(""String_Node_Str"",p.sift.maxOctaveSize,0,6,""String_Node_Str"");
  gd.addMessage(""String_Node_Str"");
  gd.addNumericField(""String_Node_Str"",p.sift.fdSize,0);
  gd.addNumericField(""String_Node_Str"",p.sift.fdBins,0);
  gd.addNumericField(""String_Node_Str"",p.rod,2);
  gd.addMessage(""String_Node_Str"");
  gd.addNumericField(""String_Node_Str"",p.maxEpsilon,2,6,""String_Node_Str"");
  gd.addNumericField(""String_Node_Str"",p.minInlierRatio,2);
  gd.addChoice(""String_Node_Str"",Param.modelStrings,Param.modelStrings[p.modelIndex]);
  gd.addMessage(""String_Node_Str"");
  gd.addCheckbox(""String_Node_Str"",p.interpolate);
  gd.addCheckbox(""String_Node_Str"",p.showInfo);
  gd.showDialog();
  if (gd.wasCanceled())   return;
  p.sift.initialSigma=(float)gd.getNextNumber();
  p.sift.steps=(int)gd.getNextNumber();
  p.sift.minOctaveSize=(int)gd.getNextNumber();
  p.sift.maxOctaveSize=(int)gd.getNextNumber();
  p.sift.fdSize=(int)gd.getNextNumber();
  p.sift.fdBins=(int)gd.getNextNumber();
  p.rod=(float)gd.getNextNumber();
  p.maxEpsilon=(float)gd.getNextNumber();
  p.minInlierRatio=(float)gd.getNextNumber();
  p.modelIndex=gd.getNextChoiceIndex();
  p.interpolate=gd.getNextBoolean();
  p.showInfo=gd.getNextBoolean();
  ImageStack stack=imp.getStack();
  ImageStack stackAligned=new ImageStack(stack.getWidth(),stack.getHeight());
  float vis_scale=256.0f / imp.getWidth();
  ImageStack stackInfo=null;
  ImagePlus impInfo=null;
  if (p.showInfo)   stackInfo=new ImageStack(Math.round(vis_scale * stack.getWidth()),Math.round(vis_scale * stack.getHeight()));
  stackAligned.addSlice(null,stack.getProcessor(1));
  ImagePlus impAligned=new ImagePlus(""String_Node_Str"" + stack.getSize(),stackAligned);
  impAligned.show();
  ImageProcessor ip1;
  ImageProcessor ip2=stack.getProcessor(1);
  ImageProcessor ip3=null;
  ImageProcessor ip4=null;
  FloatArray2DSIFT sift=new FloatArray2DSIFT(p.sift);
  SIFT ijSIFT=new SIFT(sift);
  long start_time=System.currentTimeMillis();
  IJ.log(""String_Node_Str"");
  ijSIFT.extractFeatures(ip2,fs2);
  IJ.log(""String_Node_Str"" + (System.currentTimeMillis() - start_time) + ""String_Node_Str"");
  IJ.log(fs2.size() + ""String_Node_Str"");
  if (p.showInfo)   ip2=downScale(ip2,vis_scale);
  AbstractAffineModel2D model;
switch (p.modelIndex) {
case 0:
    model=new TranslationModel2D();
  break;
case 1:
model=new RigidModel2D();
break;
case 2:
model=new SimilarityModel2D();
break;
case 3:
model=new AffineModel2D();
break;
default :
return;
}
Mapping mapping=new InverseTransformMapping(model);
for (int i=1; i < stack.getSize(); ++i) {
ip1=ip2;
ip2=stack.getProcessor(i + 1);
fs1.clear();
fs1.addAll(fs2);
fs2.clear();
start_time=System.currentTimeMillis();
IJ.log(""String_Node_Str"");
ijSIFT.extractFeatures(ip2,fs2);
IJ.log(""String_Node_Str"" + (System.currentTimeMillis() - start_time) + ""String_Node_Str"");
IJ.log(fs2.size() + ""String_Node_Str"");
start_time=System.currentTimeMillis();
System.out.print(""String_Node_Str"");
Vector<PointMatch> candidates=FloatArray2DSIFT.createMatches(fs2,fs1,1.5f,null,Float.MAX_VALUE,p.rod);
System.out.println(""String_Node_Str"" + (System.currentTimeMillis() - start_time) + ""String_Node_Str"");
IJ.log(candidates.size() + ""String_Node_Str"");
if (p.showInfo) {
ip2=downScale(ip2,vis_scale);
ip3=ip1.convertToRGB().duplicate();
ip4=ip2.convertToRGB().duplicate();
ip3.setColor(Color.red);
ip4.setColor(Color.red);
ip3.setLineWidth(2);
ip4.setLineWidth(2);
for (PointMatch m : candidates) {
float[] m_p1=m.getP1().getL();
float[] m_p2=m.getP2().getL();
ip3.drawDot((int)Math.round(vis_scale * m_p2[0]),(int)Math.round(vis_scale * m_p2[1]));
ip4.drawDot((int)Math.round(vis_scale * m_p1[0]),(int)Math.round(vis_scale * m_p1[1]));
}
}
Vector<PointMatch> inliers=new Vector<PointMatch>();
AbstractAffineModel2D<?> currentModel;
switch (p.modelIndex) {
case 0:
currentModel=new TranslationModel2D();
break;
case 1:
currentModel=new RigidModel2D();
break;
case 2:
currentModel=new SimilarityModel2D();
break;
case 3:
currentModel=new AffineModel2D();
break;
default :
return;
}
boolean modelFound;
try {
modelFound=currentModel.filterRansac(candidates,inliers,1000,p.maxEpsilon,p.minInlierRatio);
}
 catch (Exception e) {
modelFound=false;
System.err.println(e.getMessage());
}
if (modelFound) {
if (p.showInfo) {
ip3.setColor(Color.green);
ip4.setColor(Color.green);
ip3.setLineWidth(2);
ip4.setLineWidth(2);
for (PointMatch m : inliers) {
float[] m_p1=m.getP1().getL();
float[] m_p2=m.getP2().getL();
ip3.drawDot((int)Math.round(vis_scale * m_p2[0]),(int)Math.round(vis_scale * m_p2[1]));
ip4.drawDot((int)Math.round(vis_scale * m_p1[0]),(int)Math.round(vis_scale * m_p1[1]));
}
}
model.concatenate(currentModel);
}
ImageProcessor alignedSlice=stack.getProcessor(i + 1).duplicate();
if (p.interpolate) mapping.mapInterpolated(stack.getProcessor(i + 1),alignedSlice);
 else mapping.map(stack.getProcessor(i + 1),alignedSlice);
stackAligned.addSlice(null,alignedSlice);
if (p.showInfo) {
ImageProcessor tmp;
tmp=ip3.createProcessor(stackInfo.getWidth(),stackInfo.getHeight());
tmp.insert(ip3,0,0);
stackInfo.addSlice(null,tmp);
tmp=ip4.createProcessor(stackInfo.getWidth(),stackInfo.getHeight());
tmp.insert(ip4,0,0);
stackInfo.addSlice(null,tmp);
if (i == 1) {
impInfo=new ImagePlus(""String_Node_Str"",stackInfo);
impInfo.show();
}
impInfo.setStack(""String_Node_Str"",stackInfo);
impInfo.updateAndDraw();
}
impAligned.setStack(""String_Node_Str"" + stackAligned.getSize() + ""String_Node_Str""+ stack.getSize(),stackAligned);
impAligned.updateAndDraw();
}
}",0.9836362141271277
11712,"final static protected void subtractShifted(final FloatProcessor a,final FloatProcessor b,final FloatProcessor c,final int xo,final int yo){
  final float[] af=(float[])a.getPixels();
  final float[] bf=(float[])b.getPixels();
  final float[] cf=(float[])c.getPixels();
  final int w=a.getWidth();
  final int h=a.getHeight();
  for (int y=0; y < h; ++y) {
    int yb=y + yo;
    if (yb < 0 || yb >= h)     yb=pingPong(yb,h);
    final int yAdd=y * w;
    final int ybAdd=yb * w;
    for (int x=0; x < a.getWidth(); ++x) {
      int xb=x + xo;
      if (xb < 0 || xb >= w)       xb=pingPong(xb,h);
      final int i=yAdd + x;
      final float d=bf[ybAdd + xb] - af[i];
      cf[i]=d * d;
    }
  }
}","final static protected void subtractShifted(final FloatProcessor a,final FloatProcessor b,final FloatProcessor c,final int xo,final int yo){
  final float[] af=(float[])a.getPixels();
  final float[] bf=(float[])b.getPixels();
  final float[] cf=(float[])c.getPixels();
  final int w=a.getWidth();
  final int h=a.getHeight();
  for (int y=0; y < h; ++y) {
    int yb=y + yo;
    if (yb < 0 || yb >= h)     yb=pingPong(yb,h);
    final int yAdd=y * w;
    final int ybAdd=yb * w;
    for (int x=0; x < a.getWidth(); ++x) {
      int xb=x + xo;
      if (xb < 0 || xb >= w)       xb=pingPong(xb,w);
      final int i=yAdd + x;
      final float d=bf[ybAdd + xb] - af[i];
      cf[i]=d * d;
    }
  }
}",0.9985714285714286
11713,"final public void add(double new_value){
  if (values.size() > 1)   slope.add(new_value - values.get(values.size() - 1));
 else   slope.add(0.0);
  mean=(mean * values.size() + new_value);
  values.add(new_value);
  mean/=values.size();
  var0+=new_value * new_value / (double)(values.size());
  std0=Math.sqrt(var0);
  double tmp=new_value - mean;
  var+=tmp * tmp / (double)(values.size());
  std=Math.sqrt(var);
  Collections.sort(values);
  if (values.size() % 2 == 0) {
    int m=values.size() / 2;
    median=(values.get(m - 1) + values.get(m)) / 2.0;
  }
 else   median=values.get(values.size() / 2);
  if (new_value < min)   min=new_value;
  if (new_value > max)   max=new_value;
}","final public void add(double new_value){
  if (values.size() > 1)   slope.add(new_value - values.get(values.size() - 1));
 else   slope.add(0.0);
  mean=(mean * values.size() + new_value);
  values.add(new_value);
  mean/=values.size();
  var0+=new_value * new_value / (double)(values.size());
  std0=Math.sqrt(var0);
  double tmp=new_value - mean;
  var+=tmp * tmp / (double)(values.size());
  std=Math.sqrt(var);
  sortedValues.add(new_value);
  Collections.sort(sortedValues);
  if (sortedValues.size() % 2 == 0) {
    int m=sortedValues.size() / 2;
    median=(sortedValues.get(m - 1) + sortedValues.get(m)) / 2.0;
  }
 else   median=sortedValues.get(sortedValues.size() / 2);
  if (new_value < min)   min=new_value;
  if (new_value > max)   max=new_value;
}",0.9400413507925568
11714,"final public void add(double new_value){
  if (values.size() > 1)   slope.add(new_value - values.get(values.size() - 1));
 else   slope.add(0.0);
  mean=(mean * values.size() + new_value);
  values.add(new_value);
  mean/=values.size();
  var0+=new_value * new_value / (double)(values.size());
  std0=Math.sqrt(var0);
  double tmp=new_value - mean;
  var+=tmp * tmp / (double)(values.size());
  std=Math.sqrt(var);
  sortedValues.add(new_value);
  Collections.sort(sortedValues);
  if (sortedValues.size() % 2 == 0) {
    int m=sortedValues.size() / 2;
    median=(sortedValues.get(m - 1) + sortedValues.get(m)) / 2.0;
  }
 else   median=sortedValues.get(sortedValues.size() / 2);
  if (new_value < min)   min=new_value;
  if (new_value > max)   max=new_value;
}","final public void add(double new_value){
  if (values.size() > 1)   slope.add(new_value - values.get(values.size() - 1));
 else   slope.add(0.0);
  mean=(mean * values.size() + new_value);
  values.add(new_value);
  mean/=values.size();
  var0+=new_value * new_value / (double)(values.size() - 1);
  std0=Math.sqrt(var0);
  double tmp=new_value - mean;
  var+=tmp * tmp / (double)(values.size() - 1);
  std=Math.sqrt(var);
  sortedValues.add(new_value);
  Collections.sort(sortedValues);
  if (sortedValues.size() % 2 == 0) {
    int m=sortedValues.size() / 2;
    median=(sortedValues.get(m - 1) + sortedValues.get(m)) / 2.0;
  }
 else   median=sortedValues.get(sortedValues.size() / 2);
  if (new_value < min)   min=new_value;
  if (new_value > max)   max=new_value;
}",0.9947780678851176
11715,"final public double getWideSlope(int width) throws IndexOutOfBoundsException {
  if (width > slope.size())   throw new IndexOutOfBoundsException(""String_Node_Str"");
  ListIterator<Double> li=slope.listIterator(slope.size() - 1);
  int i=0;
  double s=0.0;
  while (i < width && li.hasPrevious()) {
    s+=li.previous();
  }
  s/=(double)width;
  return s;
}","final public double getWideSlope(int width) throws IndexOutOfBoundsException {
  if (width > slope.size())   throw new IndexOutOfBoundsException(""String_Node_Str"");
  ListIterator<Double> li=slope.listIterator(slope.size() - 1);
  int i=0;
  double s=0.0;
  while (i < width && li.hasPrevious()) {
    s+=li.previous();
    ++i;
  }
  s/=(double)width;
  return s;
}",0.9875518672199172
11716,"public void run(String args){
  if (IJ.versionLessThan(""String_Node_Str""))   return;
  int[] ids=WindowManager.getIDList();
  if (ids == null || ids.length < 2) {
    IJ.showMessage(""String_Node_Str"");
    return;
  }
  String[] titles=new String[ids.length];
  for (int i=0; i < ids.length; ++i) {
    titles[i]=(WindowManager.getImage(ids[i])).getTitle();
  }
  String[] methods=new String[]{""String_Node_Str"",""String_Node_Str""};
  GenericDialog gd=new GenericDialog(""String_Node_Str"");
  String current=WindowManager.getCurrentImage().getTitle();
  gd.addChoice(""String_Node_Str"",titles,current);
  gd.addChoice(""String_Node_Str"",titles,current.equals(titles[0]) ? titles[1] : titles[0]);
  gd.addMessage(""String_Node_Str"");
  gd.addNumericField(""String_Node_Str"",steps,0);
  gd.addNumericField(""String_Node_Str"",initial_sigma,2);
  gd.addNumericField(""String_Node_Str"",fdsize,0);
  gd.addNumericField(""String_Node_Str"",fdbins,0);
  gd.addNumericField(""String_Node_Str"",min_size,0);
  gd.addNumericField(""String_Node_Str"",max_size,0);
  gd.addNumericField(""String_Node_Str"",max_epsilon,2);
  gd.addNumericField(""String_Node_Str"",min_inlier_ratio,2);
  gd.addCheckbox(""String_Node_Str"",upscale);
  gd.addChoice(""String_Node_Str"",methods,methods[1]);
  gd.showDialog();
  if (gd.wasCanceled())   return;
  ImagePlus imp1=WindowManager.getImage(ids[gd.getNextChoiceIndex()]);
  ImagePlus imp2=WindowManager.getImage(ids[gd.getNextChoiceIndex()]);
  steps=(int)gd.getNextNumber();
  initial_sigma=(float)gd.getNextNumber();
  fdsize=(int)gd.getNextNumber();
  fdbins=(int)gd.getNextNumber();
  min_size=(int)gd.getNextNumber();
  max_size=(int)gd.getNextNumber();
  max_epsilon=(float)gd.getNextNumber();
  min_inlier_ratio=(float)gd.getNextNumber();
  upscale=gd.getNextBoolean();
  if (upscale)   scale=2.0f;
 else   scale=1.0f;
  method=gd.getNextChoiceIndex();
  ImageProcessor ip1=imp1.getProcessor().convertToFloat();
  ImageProcessor ip2=imp2.getProcessor().convertToFloat();
  Vector<Feature> fs1;
  Vector<Feature> fs2;
  FloatArray2DSIFT sift=new FloatArray2DSIFT(fdsize,fdbins);
  FloatArray2D fa1=ImageArrayConverter.ImageToFloatArray2D(ip1);
  Filter.enhance(fa1,1.0f);
  FloatArray2D fa2=ImageArrayConverter.ImageToFloatArray2D(ip2);
  Filter.enhance(fa1,1.0f);
  if (upscale) {
    FloatArray2D fat=new FloatArray2D(fa1.width * 2 - 1,fa1.height * 2 - 1);
    FloatArray2DScaleOctave.upsample(fa1,fat);
    fa1=fat;
    fa1=Filter.computeGaussianFastMirror(fa1,(float)Math.sqrt(initial_sigma * initial_sigma - 1.0));
    fat=new FloatArray2D(fa2.width * 2 - 1,fa2.height * 2 - 1);
    FloatArray2DScaleOctave.upsample(fa2,fat);
    fa2=fat;
    fa2=Filter.computeGaussianFastMirror(fa2,(float)Math.sqrt(initial_sigma * initial_sigma - 1.0));
  }
 else {
    fa1=Filter.computeGaussianFastMirror(fa1,(float)Math.sqrt(initial_sigma * initial_sigma - 0.25));
    fa2=Filter.computeGaussianFastMirror(fa2,(float)Math.sqrt(initial_sigma * initial_sigma - 0.25));
  }
  long start_time=System.currentTimeMillis();
  IJ.log(""String_Node_Str"");
  sift.init(fa1,steps,initial_sigma,min_size,max_size);
  fs1=sift.run(max_size);
  Collections.sort(fs1);
  IJ.log(""String_Node_Str"" + (System.currentTimeMillis() - start_time) + ""String_Node_Str"");
  IJ.log(fs1.size() + ""String_Node_Str"");
  start_time=System.currentTimeMillis();
  IJ.log(""String_Node_Str"");
  sift.init(fa2,steps,initial_sigma,min_size,max_size);
  fs2=sift.run(max_size);
  Collections.sort(fs2);
  IJ.log(""String_Node_Str"" + (System.currentTimeMillis() - start_time) + ""String_Node_Str"");
  IJ.log(fs2.size() + ""String_Node_Str"");
  start_time=System.currentTimeMillis();
  IJ.log(""String_Node_Str"");
  Vector<PointMatch> candidates=FloatArray2DSIFT.createMatches(fs1,fs2);
  IJ.log(""String_Node_Str"" + (System.currentTimeMillis() - start_time) + ""String_Node_Str"");
  IJ.log(candidates.size() + ""String_Node_Str"");
  start_time=System.currentTimeMillis();
  IJ.log(""String_Node_Str"");
  Vector<PointMatch> inliers=new Vector<PointMatch>();
  Model model=null;
  Class<? extends Model> modelClass=null;
switch (method) {
case 0:
    modelClass=TranslationModel2D.class;
  break;
case 1:
modelClass=RigidModel2D.class;
break;
}
IJ.showMessage(modelClass.getCanonicalName());
try {
model=Model.filterRansac(modelClass,candidates,inliers,1000,max_epsilon,min_inlier_ratio);
}
 catch (Exception e) {
System.err.println(e.getMessage());
}
IJ.log(""String_Node_Str"" + (System.currentTimeMillis() - start_time) + ""String_Node_Str"");
if (model != null) {
int x1[]=new int[inliers.size()];
int y1[]=new int[inliers.size()];
int x2[]=new int[inliers.size()];
int y2[]=new int[inliers.size()];
int i=0;
for (PointMatch m : inliers) {
float[] m_p1=m.getP1().getL();
float[] m_p2=m.getP2().getL();
x1[i]=(int)(m_p1[0] / scale);
y1[i]=(int)(m_p1[1] / scale);
x2[i]=(int)(m_p2[0] / scale);
y2[i]=(int)(m_p2[1] / scale);
++i;
}
PointRoi pr1=new PointRoi(x1,y1,inliers.size());
PointRoi pr2=new PointRoi(x2,y2,inliers.size());
imp1.setRoi(pr1);
imp2.setRoi(pr2);
IJ.log(inliers.size() + ""String_Node_Str"" + model.getError()+ ""String_Node_Str"");
}
 else {
IJ.log(""String_Node_Str"");
}
}","public void run(String args){
  if (IJ.versionLessThan(""String_Node_Str""))   return;
  int[] ids=WindowManager.getIDList();
  if (ids == null || ids.length < 2) {
    IJ.showMessage(""String_Node_Str"");
    return;
  }
  String[] titles=new String[ids.length];
  for (int i=0; i < ids.length; ++i) {
    titles[i]=(WindowManager.getImage(ids[i])).getTitle();
  }
  String[] methods=new String[]{""String_Node_Str"",""String_Node_Str""};
  GenericDialog gd=new GenericDialog(""String_Node_Str"");
  String current=WindowManager.getCurrentImage().getTitle();
  gd.addChoice(""String_Node_Str"",titles,current);
  gd.addChoice(""String_Node_Str"",titles,current.equals(titles[0]) ? titles[1] : titles[0]);
  gd.addMessage(""String_Node_Str"");
  gd.addNumericField(""String_Node_Str"",steps,0);
  gd.addNumericField(""String_Node_Str"",initial_sigma,2);
  gd.addNumericField(""String_Node_Str"",fdsize,0);
  gd.addNumericField(""String_Node_Str"",fdbins,0);
  gd.addNumericField(""String_Node_Str"",min_size,0);
  gd.addNumericField(""String_Node_Str"",max_size,0);
  gd.addNumericField(""String_Node_Str"",max_epsilon,2);
  gd.addNumericField(""String_Node_Str"",min_inlier_ratio,2);
  gd.addCheckbox(""String_Node_Str"",upscale);
  gd.addChoice(""String_Node_Str"",methods,methods[1]);
  gd.showDialog();
  if (gd.wasCanceled())   return;
  ImagePlus imp1=WindowManager.getImage(ids[gd.getNextChoiceIndex()]);
  ImagePlus imp2=WindowManager.getImage(ids[gd.getNextChoiceIndex()]);
  steps=(int)gd.getNextNumber();
  initial_sigma=(float)gd.getNextNumber();
  fdsize=(int)gd.getNextNumber();
  fdbins=(int)gd.getNextNumber();
  min_size=(int)gd.getNextNumber();
  max_size=(int)gd.getNextNumber();
  max_epsilon=(float)gd.getNextNumber();
  min_inlier_ratio=(float)gd.getNextNumber();
  upscale=gd.getNextBoolean();
  if (upscale)   scale=2.0f;
 else   scale=1.0f;
  method=gd.getNextChoiceIndex();
  ImageProcessor ip1=imp1.getProcessor().convertToFloat();
  ImageProcessor ip2=imp2.getProcessor().convertToFloat();
  Vector<Feature> fs1;
  Vector<Feature> fs2;
  FloatArray2DSIFT sift=new FloatArray2DSIFT(fdsize,fdbins);
  FloatArray2D fa1=ImageArrayConverter.ImageToFloatArray2D(ip1);
  Filter.enhance(fa1,1.0f);
  FloatArray2D fa2=ImageArrayConverter.ImageToFloatArray2D(ip2);
  Filter.enhance(fa2,1.0f);
  float[] initial_kernel;
  if (upscale) {
    FloatArray2D fat=new FloatArray2D(fa1.width * 2 - 1,fa1.height * 2 - 1);
    FloatArray2DScaleOctave.upsample(fa1,fat);
    fa1=fat;
    fat=new FloatArray2D(fa2.width * 2 - 1,fa2.height * 2 - 1);
    FloatArray2DScaleOctave.upsample(fa2,fat);
    fa2=fat;
    initial_kernel=Filter.createGaussianKernel((float)Math.sqrt(initial_sigma * initial_sigma - 1.0),true);
  }
 else   initial_kernel=Filter.createGaussianKernel((float)Math.sqrt(initial_sigma * initial_sigma - 0.25),true);
  fa1=Filter.convolveSeparable(fa1,initial_kernel,initial_kernel);
  fa2=Filter.convolveSeparable(fa2,initial_kernel,initial_kernel);
  long start_time=System.currentTimeMillis();
  IJ.log(""String_Node_Str"");
  sift.init(fa1,steps,initial_sigma,min_size,max_size);
  fs1=sift.run(max_size);
  Collections.sort(fs1);
  IJ.log(""String_Node_Str"" + (System.currentTimeMillis() - start_time) + ""String_Node_Str"");
  IJ.log(fs1.size() + ""String_Node_Str"");
  start_time=System.currentTimeMillis();
  IJ.log(""String_Node_Str"");
  sift.init(fa2,steps,initial_sigma,min_size,max_size);
  fs2=sift.run(max_size);
  Collections.sort(fs2);
  IJ.log(""String_Node_Str"" + (System.currentTimeMillis() - start_time) + ""String_Node_Str"");
  IJ.log(fs2.size() + ""String_Node_Str"");
  start_time=System.currentTimeMillis();
  IJ.log(""String_Node_Str"");
  Vector<PointMatch> candidates=FloatArray2DSIFT.createMatches(fs1,fs2);
  IJ.log(""String_Node_Str"" + (System.currentTimeMillis() - start_time) + ""String_Node_Str"");
  IJ.log(candidates.size() + ""String_Node_Str"");
  start_time=System.currentTimeMillis();
  IJ.log(""String_Node_Str"");
  Vector<PointMatch> inliers=new Vector<PointMatch>();
  Model model=null;
  Class<? extends Model> modelClass=null;
switch (method) {
case 0:
    modelClass=TranslationModel2D.class;
  break;
case 1:
modelClass=RigidModel2D.class;
break;
}
IJ.showMessage(modelClass.getCanonicalName());
try {
model=Model.filterRansac(modelClass,candidates,inliers,1000,max_epsilon,min_inlier_ratio);
}
 catch (Exception e) {
System.err.println(e.getMessage());
}
IJ.log(""String_Node_Str"" + (System.currentTimeMillis() - start_time) + ""String_Node_Str"");
if (model != null) {
int x1[]=new int[inliers.size()];
int y1[]=new int[inliers.size()];
int x2[]=new int[inliers.size()];
int y2[]=new int[inliers.size()];
int i=0;
for (PointMatch m : inliers) {
float[] m_p1=m.getP1().getL();
float[] m_p2=m.getP2().getL();
x1[i]=(int)(m_p1[0] / scale);
y1[i]=(int)(m_p1[1] / scale);
x2[i]=(int)(m_p2[0] / scale);
y2[i]=(int)(m_p2[1] / scale);
++i;
}
PointRoi pr1=new PointRoi(x1,y1,inliers.size());
PointRoi pr2=new PointRoi(x2,y2,inliers.size());
imp1.setRoi(pr1);
imp2.setRoi(pr2);
IJ.log(inliers.size() + ""String_Node_Str"" + model.getError()+ ""String_Node_Str"");
}
 else {
IJ.log(""String_Node_Str"");
}
}",0.8669335155716099
11717,"/** 
 * Sets the object at the index of the last call to   {@link #next() next} or {@link #previous previous}. This implementation delegates to   {@link AbstractEList#set set}.
 * @param object the object to set.
 * @exception IllegalStateException if <code>next</code> or <code>previous</code> have not yet been called, or  {@link #remove(Object) remove} or {@link #add add} have already been calledafter the last call to <code>next</code> or <code>previous</code>.
 */
protected void doSet(E object){
  if (lastCursor == -1) {
    throw new IllegalStateException();
  }
  checkModCount();
  try {
    AbstractEList.this.set(lastCursor,object);
  }
 catch (  IndexOutOfBoundsException exception) {
    throw new ConcurrentModificationException();
  }
}","/** 
 * Sets the object at the index of the last call to   {@link #next() next} or {@link #previous previous}. This implementation delegates to   {@link AbstractEList#set set}.
 * @param object the object to set.
 * @exception IllegalStateException if <code>next</code> or <code>previous</code> have not yet been called, or  {@link #remove(Object) remove} or {@link #add add} have already been calledafter the last call to <code>next</code> or <code>previous</code>.
 */
protected void doSet(E object){
  if (lastCursor == -1) {
    throw new IllegalStateException();
  }
  checkModCount();
  try {
    AbstractEList.this.set(lastCursor,object);
    expectedModCount=modCount;
  }
 catch (  IndexOutOfBoundsException exception) {
    throw new ConcurrentModificationException();
  }
}",0.9798308392973324
11718,"/** 
 * Removes the object at the index from the list and returns it. This implementation delegates to   {@link #didRemove didRemove} and {@link #didChange didChange}.
 * @param index the position of the object to remove.
 * @return the removed object.
 * @exception IndexOutOfBoundsException if the index isn't within the size range.
 */
@SuppressWarnings(""String_Node_Str"") @Override public E remove(int index){
  Object[] data=data();
  int size=data == null ? 0 : data.length;
  if (index >= size)   throw new BasicIndexOutOfBoundsException(index,size);
  @SuppressWarnings(""String_Node_Str"") E oldObject=(E)data[index];
  Object[] newData;
  if (size == 1) {
    newData=null;
  }
 else {
    newData=newData(size - 1);
    System.arraycopy(data,0,newData,0,index);
    int shifted=size - index - 1;
    if (shifted > 0) {
      System.arraycopy(data,index + 1,newData,index,shifted);
    }
  }
  setData(newData);
  didRemove(index,oldObject);
  didChange();
  return oldObject;
}","@Override public void remove(){
  super.remove();
  expectedData=data();
}",0.0886792452830188
11719,"public XImportSection get(){
  XImportSection importSection=XtypeFactory.eINSTANCE.createXImportSection();
  XPackage xPackage=(XPackage)resource.getContents().get(0);
  EList<XImportDirective> importDirectives=xPackage.getImportDirectives();
  for (  XImportDirective importDirective : importDirectives) {
    XImportDeclaration importDeclaration=XtypeFactory.eINSTANCE.createXImportDeclaration();
    JvmDeclaredType importedType=null;
    EObject importedObject=importDirective.getImportedObject();
    if (importedObject instanceof JvmDeclaredType) {
      importedType=(JvmDeclaredType)importedObject;
    }
 else {
      importedType=(JvmDeclaredType)associations.getPrimaryJvmElement(importedObject);
    }
    importDeclaration.setImportedType(importedType);
    importDeclaration.setImportedNamespace(importDirective.getImportedNamespace());
    importDeclaration.setExtension(false);
    importDeclaration.setStatic(false);
    importSection.getImportDeclarations().add(importDeclaration);
  }
  return importSection;
}","public XImportSection get(){
  XImportSection importSection=XtypeFactory.eINSTANCE.createXImportSection();
  EList<XImportDeclaration> importDeclarations=importSection.getImportDeclarations();
  XPackage xPackage=(XPackage)resource.getContents().get(0);
  EList<XImportDirective> importDirectives=xPackage.getImportDirectives();
  for (  XImportDirective importDirective : importDirectives) {
    JvmDeclaredType importedType=null;
    EObject importedObject=importDirective.getImportedObject();
    if (importedObject instanceof JvmDeclaredType) {
      importedType=(JvmDeclaredType)importedObject;
    }
 else {
      EObject primaryJvmElement=associations.getPrimaryJvmElement(importedObject);
      if (primaryJvmElement instanceof JvmDeclaredType) {
        importedType=(JvmDeclaredType)primaryJvmElement;
      }
    }
    if (importedType != null) {
      XImportDeclaration importDeclaration=XtypeFactory.eINSTANCE.createXImportDeclaration();
      importDeclaration.setImportedType(importedType);
      importDeclaration.setImportedNamespace(importDirective.getImportedNamespace());
      importDeclaration.setExtension(false);
      importDeclaration.setStatic(false);
      importDeclarations.add(importDeclaration);
    }
  }
  return importSection;
}",0.4873583260680035
11720,"@Override public XImportSection getImportSection(final XtextResource resource){
  return cache.get(""String_Node_Str"",resource,new Provider<XImportSection>(){
    public XImportSection get(){
      XImportSection importSection=XtypeFactory.eINSTANCE.createXImportSection();
      XPackage xPackage=(XPackage)resource.getContents().get(0);
      EList<XImportDirective> importDirectives=xPackage.getImportDirectives();
      for (      XImportDirective importDirective : importDirectives) {
        XImportDeclaration importDeclaration=XtypeFactory.eINSTANCE.createXImportDeclaration();
        JvmDeclaredType importedType=null;
        EObject importedObject=importDirective.getImportedObject();
        if (importedObject instanceof JvmDeclaredType) {
          importedType=(JvmDeclaredType)importedObject;
        }
 else {
          importedType=(JvmDeclaredType)associations.getPrimaryJvmElement(importedObject);
        }
        importDeclaration.setImportedType(importedType);
        importDeclaration.setImportedNamespace(importDirective.getImportedNamespace());
        importDeclaration.setExtension(false);
        importDeclaration.setStatic(false);
        importSection.getImportDeclarations().add(importDeclaration);
      }
      return importSection;
    }
  }
);
}","@Override public XImportSection getImportSection(final XtextResource resource){
  return cache.get(""String_Node_Str"",resource,new Provider<XImportSection>(){
    public XImportSection get(){
      XImportSection importSection=XtypeFactory.eINSTANCE.createXImportSection();
      EList<XImportDeclaration> importDeclarations=importSection.getImportDeclarations();
      XPackage xPackage=(XPackage)resource.getContents().get(0);
      EList<XImportDirective> importDirectives=xPackage.getImportDirectives();
      for (      XImportDirective importDirective : importDirectives) {
        JvmDeclaredType importedType=null;
        EObject importedObject=importDirective.getImportedObject();
        if (importedObject instanceof JvmDeclaredType) {
          importedType=(JvmDeclaredType)importedObject;
        }
 else {
          EObject primaryJvmElement=associations.getPrimaryJvmElement(importedObject);
          if (primaryJvmElement instanceof JvmDeclaredType) {
            importedType=(JvmDeclaredType)primaryJvmElement;
          }
        }
        if (importedType != null) {
          XImportDeclaration importDeclaration=XtypeFactory.eINSTANCE.createXImportDeclaration();
          importDeclaration.setImportedType(importedType);
          importDeclaration.setImportedNamespace(importDirective.getImportedNamespace());
          importDeclaration.setExtension(false);
          importDeclaration.setStatic(false);
          importDeclarations.add(importDeclaration);
        }
      }
      return importSection;
    }
  }
);
}",0.5452616690240453
11721,"@Override protected Diagnostic doExport(Monitor monitor,ModelExporter.ExportData exportData) throws Exception {
  for (  Map.Entry<GenPackage,URI> entry : exportData.genPackageToArtifactURI.entrySet()) {
    GenPackage genPackage=entry.getKey();
    URI xcoreLocationURI=entry.getValue();
    IFile xcoreFile=ResourcesPlugin.getWorkspace().getRoot().getFile(new Path(xcoreLocationURI.toPlatformString(true)));
    final IProject xcoreProject=xcoreFile.getProject();
    if (xcoreProject.isAccessible()) {
      if (!xcoreProject.hasNature(XtextProjectHelper.NATURE_ID)) {
        IProjectDescription description=xcoreProject.getDescription();
        String[] natures=description.getNatureIds();
        String[] newNatures=new String[natures.length + 1];
        System.arraycopy(natures,0,newNatures,0,natures.length);
        newNatures[natures.length]=XtextProjectHelper.NATURE_ID;
        description.setNatureIds(newNatures);
        xcoreProject.setDescription(description,null);
      }
      XcoreClasspathUpdater xcoreClasspathUpdater=new XcoreClasspathUpdater();
      IJavaProject xcoreJavaProject=JavaCore.create(xcoreProject);
      xcoreClasspathUpdater.addBundle(xcoreJavaProject,""String_Node_Str"",null);
      xcoreClasspathUpdater.addBundle(xcoreJavaProject,""String_Node_Str"",null);
    }
    final ResourceSet resourceSet=resourceSetProvider.get();
    resourceSet.getURIConverter().getURIMap().putAll(EcorePlugin.computePlatformURIMap(true));
    GenModel inputGenModel=(GenModel)resourceSet.getEObject(EcoreUtil.getURI(getGenModel()),true);
    inputGenModel.reconcile();
    Resource inputResource=inputGenModel.eResource();
    final XtextResource outputResource=(XtextResource)resourceSet.createResource(xcoreLocationURI);
    GenModel genModel=GenModelFactory.eINSTANCE.createGenModel();
    List<EPackage> ePackageClones=new ArrayList<EPackage>();
    for (    GenPackage inputGenPackage : inputGenModel.getGenPackages()) {
      ePackageClones.add(inputGenPackage.getEcorePackage());
    }
    genModel.initialize(ePackageClones);
    inputResource.getContents().add(genModel);
    genModelInitializer.initialize(genModel,true);
    final GenPackage inputGenPackage=(GenPackage)resourceSet.getEObject(EcoreUtil.getURI(genPackage),true);
    new Object(){
      void visit(      GenBase genBase1,      GenBase genBase2){
        if (genBase1.eClass() == genBase2.eClass()) {
          for (          EAttribute eAttribute : genBase1.eClass().getEAllAttributes()) {
            if (!eAttribute.isMany() && genBase1.eIsSet(eAttribute)) {
              Object value1=genBase1.eGet(eAttribute);
              Object value2=genBase2.eGet(eAttribute);
              if (value1 == null ? value2 != null : !value1.equals(value2)) {
                EModelElement eModelElement=genBase2.getEcoreModelElement();
                if (eModelElement == null && genBase2 instanceof GenModel) {
                  eModelElement=inputGenPackage.getEcorePackage();
                }
                EcoreUtil.setAnnotation(eModelElement,GenModelPackage.eNS_URI,eAttribute.getName(),EcoreUtil.convertToString(eAttribute.getEAttributeType(),value1));
              }
              for (Iterator<EObject> i=genBase1.eContents().iterator(), j=genBase2.eContents().iterator(); i.hasNext() && j.hasNext(); ) {
                EObject content1=i.next();
                EObject content2=j.next();
                if (content1 instanceof GenBase && content2 instanceof GenBase) {
                  visit((GenBase)content1,(GenBase)content2);
                }
              }
            }
          }
        }
      }
    }
.visit(inputGenModel,genModel);
    EcoreXcoreBuilder ecoreXcoreBuilder=ecoreXcoreBuilderProvider.get();
    ecoreXcoreBuilder.initialize(inputGenModel);
    XPackage xPackage=ecoreXcoreBuilder.getXPackage(inputGenPackage.getEcorePackage());
    outputResource.getContents().add(xPackage);
    outputResource.getContents().add(inputGenModel);
    outputResource.getContents().add(inputGenPackage.getEcorePackage());
    ResourceSet additionalResources=resourceSetProvider.get();
    GenPackage ecoreGenPackage=inputGenModel.getEcoreGenPackage();
    if (ecoreGenPackage != null) {
      Resource ecoreResource=additionalResources.createResource(URI.createPlatformResourceURI(""String_Node_Str"",false));
      ecoreResource.getContents().add(ecoreGenPackage.getGenModel());
    }
    GenPackage xmlTypeGenPackage=inputGenModel.getXMLTypeGenPackage();
    if (xmlTypeGenPackage != null) {
      Resource xmlTypeResource=additionalResources.createResource(URI.createPlatformResourceURI(""String_Node_Str"",false));
      xmlTypeResource.getContents().add(xmlTypeGenPackage.getGenModel());
    }
    GenPackage xmlNamespaceGenPackage=inputGenModel.getXMLNamespaceGenPackage();
    if (xmlNamespaceGenPackage != null) {
      Resource xmlNamespaceResource=additionalResources.createResource(URI.createPlatformResourceURI(""String_Node_Str"",false));
      xmlNamespaceResource.getContents().add(xmlNamespaceGenPackage.getGenModel());
    }
    resourceSet.getURIConverter().getURIMap().remove(URI.createPlatformResourceURI(""String_Node_Str"",false));
    ecoreXcoreBuilder.link();
    genModelBuilder.buildMap(inputGenModel);
    ImportManager importManager=new ImportManager(inputGenPackage.getInterfacePackageName()){
      @Override protected boolean shouldImport(      String packageName,      String shortName,      String importName){
        return true;
      }
    }
;
    Map<EGenericType,XGenericType> genericTypeMap=ecoreXcoreBuilder.getGenericTypeMap();
    for (TreeIterator<EObject> i=inputGenPackage.getEcorePackage().eAllContents(); i.hasNext(); ) {
      EObject eObject=i.next();
      if (eObject instanceof EGenericType) {
        EGenericType eGenericType=(EGenericType)eObject;
        EClassifier eClassifier=eGenericType.getEClassifier();
        if (eClassifier != null) {
          GenClassifier genClassifier=inputGenModel.findGenClassifier(eClassifier);
          QualifiedName qualifiedName=qualifiedNameProvider.getFullyQualifiedName(genClassifier);
          String qualifiedNameValue=qualifiedNameConverter.toString(qualifiedName);
          if (!IMPLICIT_ALIASES.contains(qualifiedNameValue)) {
            importManager.addImport(qualifiedNameValue);
          }
          XGenericType xGenericType=genericTypeMap.get(eGenericType);
          IScope scope=scopeProvider.getScope(xGenericType,XcorePackage.Literals.XGENERIC_TYPE__TYPE);
          IEObjectDescription genClassifierDescription=scope.getSingleElement(qualifiedName);
          if (genClassifierDescription != null) {
            EObject resolvedGenClassifier=resourceSet.getEObject(genClassifierDescription.getEObjectURI(),true);
            if (resolvedGenClassifier != null && resolvedGenClassifier != genClassifier) {
              xGenericType.setType((GenClassifier)resolvedGenClassifier);
            }
          }
        }
      }
 else       if (eObject instanceof EReference) {
        EReference eReference=(EReference)eObject;
        XReference xReference=(XReference)mapper.getToXcoreMapping(eReference).getXcoreElement();
        EList<GenFeature> keys=xReference.getKeys();
        GenFeature opposite=xReference.getOpposite();
        if (opposite != null) {
          IScope scope=scopeProvider.getScope(xReference,XcorePackage.Literals.XREFERENCE__OPPOSITE);
          IEObjectDescription genFeatureDescription=scope.getSingleElement(QualifiedName.create(opposite.getName()));
          if (genFeatureDescription != null) {
            EObject resolvedGenFeature=resourceSet.getEObject(genFeatureDescription.getEObjectURI(),true);
            if (resolvedGenFeature != null) {
              xReference.setOpposite((GenFeature)resolvedGenFeature);
            }
          }
        }
        if (!keys.isEmpty()) {
          IScope scope=scopeProvider.getScope(xReference,XcorePackage.Literals.XREFERENCE__KEYS);
          for (ListIterator<GenFeature> k=keys.listIterator(); k.hasNext(); ) {
            GenFeature key=k.next();
            IEObjectDescription genFeatureDescription=scope.getSingleElement(QualifiedName.create(key.getName()));
            if (genFeatureDescription != null) {
              EObject resolvedGenFeature=resourceSet.getEObject(genFeatureDescription.getEObjectURI(),true);
              if (resolvedGenFeature != null) {
                k.set((GenFeature)resolvedGenFeature);
              }
            }
          }
        }
      }
 else       if (eObject instanceof EPackage) {
        i.prune();
      }
    }
    for (    String qualifiedName : importManager.getImports()) {
      XImportDirective xImportDirective=XcoreFactory.eINSTANCE.createXImportDirective();
      xImportDirective.setImportedNamespace(qualifiedName);
      xPackage.getImportDirectives().add(xImportDirective);
    }
    final Map<Object,Object> options=new HashMap<Object,Object>();
    SaveOptions.newBuilder().format().noValidation().getOptions().addTo(options);
    Job job=new Job(""String_Node_Str""){
      @Override protected IStatus run(      IProgressMonitor monitor){
        try {
          Map<URI,URI> uriMap=resourceSet.getURIConverter().getURIMap();
          Map<URI,URI> copyiedURIMap=new HashMap<URI,URI>(uriMap);
          uriMap.clear();
          outputResource.save(options);
          uriMap.putAll(copyiedURIMap);
          outputResource.unload();
          outputResource.load(null);
          IParseResult parseResult=outputResource.getParseResult();
          if (parseResult != null) {
            IPreferenceValues configuration=preferencesProvider.getPreferenceValues(outputResource);
            try {
              List<TextReplacement> edits=formatter.format(outputResource,0,parseResult.getRootNode().getLength(),new FormattingPreferenceValues(configuration));
              BufferedInputStream bufferedInputStream=new BufferedInputStream(resourceSet.getURIConverter().createInputStream(outputResource.getURI()));
              byte[] input=new byte[bufferedInputStream.available()];
              bufferedInputStream.read(input);
              bufferedInputStream.close();
              String text=new String(input,outputResource.getEncoding());
              StringBuilder builder=new StringBuilder(text);
              for (int i=edits.size(); --i >= 0; ) {
                TextReplacement replacement=edits.get(i);
                builder.replace(replacement.getOffset(),replacement.getOffset() + replacement.getLength(),replacement.getText());
              }
              OutputStream outputStream=resourceSet.getURIConverter().createOutputStream(outputResource.getURI());
              outputStream.write(builder.toString().getBytes(outputResource.getEncoding()));
              outputStream.close();
            }
 catch (            Throwable throwable) {
              XcoreExporterPlugin.INSTANCE.log(throwable);
            }
          }
        }
 catch (        IOException exception) {
          return Status.CANCEL_STATUS;
        }
        return Status.OK_STATUS;
      }
    }
;
    job.schedule();
  }
  return Diagnostic.OK_INSTANCE;
}","@Override protected Diagnostic doExport(Monitor monitor,ModelExporter.ExportData exportData) throws Exception {
  for (  Map.Entry<GenPackage,URI> entry : exportData.genPackageToArtifactURI.entrySet()) {
    GenPackage genPackage=entry.getKey();
    URI xcoreLocationURI=entry.getValue();
    IFile xcoreFile=ResourcesPlugin.getWorkspace().getRoot().getFile(new Path(xcoreLocationURI.toPlatformString(true)));
    final IProject xcoreProject=xcoreFile.getProject();
    if (xcoreProject.isAccessible()) {
      if (!xcoreProject.hasNature(XtextProjectHelper.NATURE_ID)) {
        IProjectDescription description=xcoreProject.getDescription();
        String[] natures=description.getNatureIds();
        String[] newNatures=new String[natures.length + 1];
        System.arraycopy(natures,0,newNatures,0,natures.length);
        newNatures[natures.length]=XtextProjectHelper.NATURE_ID;
        description.setNatureIds(newNatures);
        xcoreProject.setDescription(description,null);
      }
      XcoreClasspathUpdater xcoreClasspathUpdater=new XcoreClasspathUpdater();
      IJavaProject xcoreJavaProject=JavaCore.create(xcoreProject);
      xcoreClasspathUpdater.addBundle(xcoreJavaProject,""String_Node_Str"",null);
      xcoreClasspathUpdater.addBundle(xcoreJavaProject,""String_Node_Str"",null);
    }
    final ResourceSet resourceSet=resourceSetProvider.get();
    final Map<URI,URI> uriMap=resourceSet.getURIConverter().getURIMap();
    Registry packageRegistry=resourceSet.getPackageRegistry();
    uriMap.putAll(EcorePlugin.computePlatformURIMap(true));
    GenModel inputGenModel=(GenModel)resourceSet.getEObject(EcoreUtil.getURI(getGenModel()),true);
    inputGenModel.reconcile();
    Resource inputResource=inputGenModel.eResource();
    final XtextResource outputResource=(XtextResource)resourceSet.createResource(xcoreLocationURI);
    GenModel genModel=GenModelFactory.eINSTANCE.createGenModel();
    List<EPackage> ePackageClones=new ArrayList<EPackage>();
    for (    GenPackage inputGenPackage : inputGenModel.getGenPackages()) {
      ePackageClones.add(inputGenPackage.getEcorePackage());
    }
    genModel.initialize(ePackageClones);
    inputResource.getContents().add(genModel);
    genModelInitializer.initialize(genModel,true);
    final GenPackage inputGenPackage=(GenPackage)resourceSet.getEObject(EcoreUtil.getURI(genPackage),true);
    new Object(){
      void visit(      GenBase genBase1,      GenBase genBase2){
        if (genBase1.eClass() == genBase2.eClass()) {
          for (          EAttribute eAttribute : genBase1.eClass().getEAllAttributes()) {
            if (!eAttribute.isMany() && genBase1.eIsSet(eAttribute)) {
              Object value1=genBase1.eGet(eAttribute);
              Object value2=genBase2.eGet(eAttribute);
              if (value1 == null ? value2 != null : !value1.equals(value2)) {
                EModelElement eModelElement=genBase2.getEcoreModelElement();
                if (eModelElement == null && genBase2 instanceof GenModel) {
                  eModelElement=inputGenPackage.getEcorePackage();
                }
                EcoreUtil.setAnnotation(eModelElement,GenModelPackage.eNS_URI,eAttribute.getName(),EcoreUtil.convertToString(eAttribute.getEAttributeType(),value1));
              }
              for (Iterator<EObject> i=genBase1.eContents().iterator(), j=genBase2.eContents().iterator(); i.hasNext() && j.hasNext(); ) {
                EObject content1=i.next();
                EObject content2=j.next();
                if (content1 instanceof GenBase && content2 instanceof GenBase) {
                  visit((GenBase)content1,(GenBase)content2);
                }
              }
            }
          }
        }
      }
    }
.visit(inputGenModel,genModel);
    EcoreXcoreBuilder ecoreXcoreBuilder=ecoreXcoreBuilderProvider.get();
    ecoreXcoreBuilder.initialize(inputGenModel);
    XPackage xPackage=ecoreXcoreBuilder.getXPackage(inputGenPackage.getEcorePackage());
    outputResource.getContents().add(xPackage);
    outputResource.getContents().add(inputGenModel);
    outputResource.getContents().add(inputGenPackage.getEcorePackage());
    ResourceSet additionalResources=resourceSetProvider.get();
    GenPackage ecoreGenPackage=inputGenModel.getEcoreGenPackage();
    if (ecoreGenPackage != null) {
      URI ecoreResourceURI=URI.createPlatformResourceURI(""String_Node_Str"",false);
      packageRegistry.put(ecoreResourceURI.toString(),ecoreGenPackage.getEcorePackage());
      Resource ecoreResource=additionalResources.createResource(ecoreResourceURI);
      ecoreResource.getContents().add(ecoreGenPackage.getGenModel());
    }
    GenPackage xmlTypeGenPackage=inputGenModel.getXMLTypeGenPackage();
    if (xmlTypeGenPackage != null) {
      URI xmlTypeResourceURI=URI.createPlatformResourceURI(""String_Node_Str"",false);
      packageRegistry.put(xmlTypeResourceURI.toString(),xmlTypeGenPackage.getEcorePackage());
      Resource xmlTypeResource=additionalResources.createResource(xmlTypeResourceURI);
      xmlTypeResource.getContents().add(xmlTypeGenPackage.getGenModel());
    }
    GenPackage xmlNamespaceGenPackage=inputGenModel.getXMLNamespaceGenPackage();
    if (xmlNamespaceGenPackage != null) {
      URI xmlNamespaceResourceURI=URI.createPlatformResourceURI(""String_Node_Str"",false);
      packageRegistry.put(xmlNamespaceResourceURI.toString(),xmlNamespaceGenPackage.getEcorePackage());
      Resource xmlNamespaceResource=additionalResources.createResource(xmlNamespaceResourceURI);
      xmlNamespaceResource.getContents().add(xmlNamespaceGenPackage.getGenModel());
    }
    ecoreXcoreBuilder.link();
    genModelBuilder.buildMap(inputGenModel);
    ImportManager importManager=new ImportManager(inputGenPackage.getInterfacePackageName()){
      @Override protected boolean shouldImport(      String packageName,      String shortName,      String importName){
        return true;
      }
    }
;
    Map<EGenericType,XGenericType> genericTypeMap=ecoreXcoreBuilder.getGenericTypeMap();
    for (TreeIterator<EObject> i=inputGenPackage.getEcorePackage().eAllContents(); i.hasNext(); ) {
      EObject eObject=i.next();
      if (eObject instanceof EGenericType) {
        EGenericType eGenericType=(EGenericType)eObject;
        EClassifier eClassifier=eGenericType.getEClassifier();
        if (eClassifier != null) {
          GenClassifier genClassifier=inputGenModel.findGenClassifier(eClassifier);
          QualifiedName qualifiedName=qualifiedNameProvider.getFullyQualifiedName(genClassifier);
          String qualifiedNameValue=qualifiedNameConverter.toString(qualifiedName);
          if (!IMPLICIT_ALIASES.contains(qualifiedNameValue)) {
            importManager.addImport(qualifiedNameValue);
          }
          XGenericType xGenericType=genericTypeMap.get(eGenericType);
          IScope scope=scopeProvider.getScope(xGenericType,XcorePackage.Literals.XGENERIC_TYPE__TYPE);
          IEObjectDescription genClassifierDescription=scope.getSingleElement(qualifiedName);
          if (genClassifierDescription != null) {
            EObject resolvedGenClassifier=resourceSet.getEObject(genClassifierDescription.getEObjectURI(),true);
            if (resolvedGenClassifier != null && resolvedGenClassifier != genClassifier) {
              xGenericType.setType((GenClassifier)resolvedGenClassifier);
            }
          }
        }
      }
 else       if (eObject instanceof EReference) {
        EReference eReference=(EReference)eObject;
        XReference xReference=(XReference)mapper.getToXcoreMapping(eReference).getXcoreElement();
        EList<GenFeature> keys=xReference.getKeys();
        GenFeature opposite=xReference.getOpposite();
        if (opposite != null) {
          IScope scope=scopeProvider.getScope(xReference,XcorePackage.Literals.XREFERENCE__OPPOSITE);
          IEObjectDescription genFeatureDescription=scope.getSingleElement(QualifiedName.create(opposite.getName()));
          if (genFeatureDescription != null) {
            EObject resolvedGenFeature=resourceSet.getEObject(genFeatureDescription.getEObjectURI(),true);
            if (resolvedGenFeature != null) {
              xReference.setOpposite((GenFeature)resolvedGenFeature);
            }
          }
        }
        if (!keys.isEmpty()) {
          IScope scope=scopeProvider.getScope(xReference,XcorePackage.Literals.XREFERENCE__KEYS);
          for (ListIterator<GenFeature> k=keys.listIterator(); k.hasNext(); ) {
            GenFeature key=k.next();
            IEObjectDescription genFeatureDescription=scope.getSingleElement(QualifiedName.create(key.getName()));
            if (genFeatureDescription != null) {
              EObject resolvedGenFeature=resourceSet.getEObject(genFeatureDescription.getEObjectURI(),true);
              if (resolvedGenFeature != null) {
                k.set((GenFeature)resolvedGenFeature);
              }
            }
          }
        }
      }
 else       if (eObject instanceof EPackage) {
        i.prune();
      }
    }
    for (    String qualifiedName : importManager.getImports()) {
      XImportDirective xImportDirective=XcoreFactory.eINSTANCE.createXImportDirective();
      xImportDirective.setImportedNamespace(qualifiedName);
      xPackage.getImportDirectives().add(xImportDirective);
    }
    final Map<Object,Object> options=new HashMap<Object,Object>();
    SaveOptions.newBuilder().format().noValidation().getOptions().addTo(options);
    Job job=new Job(""String_Node_Str""){
      @Override protected IStatus run(      IProgressMonitor monitor){
        try {
          Map<URI,URI> copyiedURIMap=new HashMap<URI,URI>(uriMap);
          uriMap.clear();
          outputResource.save(options);
          uriMap.putAll(copyiedURIMap);
          outputResource.unload();
          outputResource.load(null);
          IParseResult parseResult=outputResource.getParseResult();
          if (parseResult != null) {
            IPreferenceValues configuration=preferencesProvider.getPreferenceValues(outputResource);
            try {
              List<TextReplacement> edits=formatter.format(outputResource,0,parseResult.getRootNode().getLength(),new FormattingPreferenceValues(configuration));
              BufferedInputStream bufferedInputStream=new BufferedInputStream(resourceSet.getURIConverter().createInputStream(outputResource.getURI()));
              byte[] input=new byte[bufferedInputStream.available()];
              bufferedInputStream.read(input);
              bufferedInputStream.close();
              String text=new String(input,outputResource.getEncoding());
              StringBuilder builder=new StringBuilder(text);
              for (int i=edits.size(); --i >= 0; ) {
                TextReplacement replacement=edits.get(i);
                builder.replace(replacement.getOffset(),replacement.getOffset() + replacement.getLength(),replacement.getText());
              }
              OutputStream outputStream=resourceSet.getURIConverter().createOutputStream(outputResource.getURI());
              outputStream.write(builder.toString().getBytes(outputResource.getEncoding()));
              outputStream.close();
            }
 catch (            Throwable throwable) {
              XcoreExporterPlugin.INSTANCE.log(throwable);
            }
          }
        }
 catch (        IOException exception) {
          return Status.CANCEL_STATUS;
        }
        return Status.OK_STATUS;
      }
    }
;
    job.schedule();
  }
  return Diagnostic.OK_INSTANCE;
}",0.95283560977766
11722,"@Override protected IStatus run(IProgressMonitor monitor){
  try {
    Map<URI,URI> uriMap=resourceSet.getURIConverter().getURIMap();
    Map<URI,URI> copyiedURIMap=new HashMap<URI,URI>(uriMap);
    uriMap.clear();
    outputResource.save(options);
    uriMap.putAll(copyiedURIMap);
    outputResource.unload();
    outputResource.load(null);
    IParseResult parseResult=outputResource.getParseResult();
    if (parseResult != null) {
      IPreferenceValues configuration=preferencesProvider.getPreferenceValues(outputResource);
      try {
        List<TextReplacement> edits=formatter.format(outputResource,0,parseResult.getRootNode().getLength(),new FormattingPreferenceValues(configuration));
        BufferedInputStream bufferedInputStream=new BufferedInputStream(resourceSet.getURIConverter().createInputStream(outputResource.getURI()));
        byte[] input=new byte[bufferedInputStream.available()];
        bufferedInputStream.read(input);
        bufferedInputStream.close();
        String text=new String(input,outputResource.getEncoding());
        StringBuilder builder=new StringBuilder(text);
        for (int i=edits.size(); --i >= 0; ) {
          TextReplacement replacement=edits.get(i);
          builder.replace(replacement.getOffset(),replacement.getOffset() + replacement.getLength(),replacement.getText());
        }
        OutputStream outputStream=resourceSet.getURIConverter().createOutputStream(outputResource.getURI());
        outputStream.write(builder.toString().getBytes(outputResource.getEncoding()));
        outputStream.close();
      }
 catch (      Throwable throwable) {
        XcoreExporterPlugin.INSTANCE.log(throwable);
      }
    }
  }
 catch (  IOException exception) {
    return Status.CANCEL_STATUS;
  }
  return Status.OK_STATUS;
}","@Override protected IStatus run(IProgressMonitor monitor){
  try {
    Map<URI,URI> copyiedURIMap=new HashMap<URI,URI>(uriMap);
    uriMap.clear();
    outputResource.save(options);
    uriMap.putAll(copyiedURIMap);
    outputResource.unload();
    outputResource.load(null);
    IParseResult parseResult=outputResource.getParseResult();
    if (parseResult != null) {
      IPreferenceValues configuration=preferencesProvider.getPreferenceValues(outputResource);
      try {
        List<TextReplacement> edits=formatter.format(outputResource,0,parseResult.getRootNode().getLength(),new FormattingPreferenceValues(configuration));
        BufferedInputStream bufferedInputStream=new BufferedInputStream(resourceSet.getURIConverter().createInputStream(outputResource.getURI()));
        byte[] input=new byte[bufferedInputStream.available()];
        bufferedInputStream.read(input);
        bufferedInputStream.close();
        String text=new String(input,outputResource.getEncoding());
        StringBuilder builder=new StringBuilder(text);
        for (int i=edits.size(); --i >= 0; ) {
          TextReplacement replacement=edits.get(i);
          builder.replace(replacement.getOffset(),replacement.getOffset() + replacement.getLength(),replacement.getText());
        }
        OutputStream outputStream=resourceSet.getURIConverter().createOutputStream(outputResource.getURI());
        outputStream.write(builder.toString().getBytes(outputResource.getEncoding()));
        outputStream.close();
      }
 catch (      Throwable throwable) {
        XcoreExporterPlugin.INSTANCE.log(throwable);
      }
    }
  }
 catch (  IOException exception) {
    return Status.CANCEL_STATUS;
  }
  return Status.OK_STATUS;
}",0.9808844507845934
11723,"protected void getMissingPackagesHelper(List<EPackage> ePackages,List<GenPackage> genPackages){
  for (  GenPackage genPackage : genPackages) {
    EPackage ePackage=genPackage.getEcorePackage();
    if (ePackage != null) {
      for (Iterator<EObject> j=ePackage.eAllContents(); j.hasNext(); ) {
        EObject eObject=j.next();
        for (Iterator<EObject> k=eObject.eCrossReferences().iterator(); k.hasNext(); ) {
          EObject o=k.next();
          if (o instanceof EClassifier) {
            EClassifier eClassifier=(EClassifier)o;
            if (findGenClassifier(eClassifier) == null) {
              ePackages.add(eClassifier.getEPackage());
            }
          }
        }
      }
    }
  }
}","protected void getMissingPackagesHelper(List<EPackage> ePackages,List<GenPackage> genPackages){
  for (int i=0; i < genPackages.size(); ++i) {
    EPackage ePackage=genPackages.get(i).getEcorePackage();
    if (ePackage != null) {
      for (Iterator<EObject> j=ePackage.eAllContents(); j.hasNext(); ) {
        EObject eObject=j.next();
        for (Iterator<EObject> k=eObject.eCrossReferences().iterator(); k.hasNext(); ) {
          EObject o=k.next();
          if (o instanceof EClassifier) {
            EClassifier eClassifier=(EClassifier)o;
            if (findGenClassifier(eClassifier) == null) {
              ePackages.add(eClassifier.getEPackage());
            }
          }
        }
      }
    }
  }
}",0.9434752267969296
11724,"@Override public boolean select(Viewer viewer,Object parentElement,Object element){
  if (element instanceof IFile) {
    IFile file=(IFile)element;
    URI uri=URI.createPlatformResourceURI(file.getFullPath().toString(),true);
    return ""String_Node_Str"".equals(file.getFileExtension()) && !file.getFullPath().equals(genModelPath) && !genModelURIs.contains(uri);
  }
  return true;
}","@Override public boolean select(Viewer viewer,Object parentElement,Object element){
  if (element instanceof IFile) {
    IFile file=(IFile)element;
    URI uri=URI.createPlatformResourceURI(file.getFullPath().toString(),true);
    String fileExtension=file.getFileExtension();
    return (""String_Node_Str"".equals(fileExtension) || ""String_Node_Str"".equals(fileExtension)) && !file.getFullPath().equals(genModelPath) && !genModelURIs.contains(uri);
  }
  return true;
}",0.8631578947368421
11725,"protected void referencedGenModelsAddSelected(CheckboxTreeViewer treeViewer){
  IPath path=null;
  Resource resource=getModelConverter().getGenModel().eResource();
  if (resource != null) {
    if (resource.getURI().isPlatformResource()) {
      path=new Path(resource.getURI().toPlatformString(true)).makeAbsolute();
    }
  }
  final IPath genModelPath=path;
  ResourceSet resourceSet=null;
  List<GenModel> genModels=new UniqueEList.FastCompare<GenModel>();
  final Set<URI> genModelURIs=new HashSet<URI>();
  Object input=treeViewer.getInput();
  if (input instanceof ItemProvider) {
    Collection<?> elements=((ItemProvider)input).getChildren();
    for (    Object element : elements) {
      if (element instanceof GenModel) {
        GenModel genModel=(GenModel)element;
        URI genModelURI=genModel.eResource().getURI();
        genModels.add(genModel);
        genModelURIs.add(genModelURI);
        if (resourceSet == null && genModelURI.isPlatformResource()) {
          resourceSet=genModel.eResource().getResourceSet();
        }
      }
    }
  }
  ViewerFilter genModelFilter=new ViewerFilter(){
    @Override public boolean select(    Viewer viewer,    Object parentElement,    Object element){
      if (element instanceof IFile) {
        IFile file=(IFile)element;
        URI uri=URI.createPlatformResourceURI(file.getFullPath().toString(),true);
        return ""String_Node_Str"".equals(file.getFileExtension()) && !file.getFullPath().equals(genModelPath) && !genModelURIs.contains(uri);
      }
      return true;
    }
  }
;
  IFile[] files=WorkspaceResourceDialog.openFileSelection(getShell(),null,ConverterPlugin.INSTANCE.getString(""String_Node_Str""),true,null,Collections.singletonList(genModelFilter));
  if (files.length > 0) {
    ResourceSet referencedGenModels=resourceSet != null ? resourceSet : getModelConverter().createResourceSet();
    for (int i=0; i < files.length; ++i) {
      URI genModelURI=URI.createPlatformResourceURI(files[i].getFullPath().toString(),true);
      Resource genModelResource=referencedGenModels.getResource(genModelURI,true);
      GenModel genModel=(GenModel)genModelResource.getContents().get(0);
      genModels.add(genModel);
    }
    addExternalGenModels(genModels);
    addReferencedGenModels(genModels);
    List<GenPackage> genPackagesToCheck=new ArrayList<GenPackage>();
    Object[] checkedElements=treeViewer.getCheckedElements();
    LOOP:     for (int i=0; i < checkedElements.length; i++) {
      if (checkedElements[i] instanceof GenPackage) {
        GenPackage checkedGenPackage=(GenPackage)checkedElements[i];
        String nsURI=checkedGenPackage.getNSURI();
        for (        GenModel genModel : genModels) {
          for (          GenPackage genPackage : genModel.getGenPackages()) {
            if (nsURI.equals(genPackage.getNSURI())) {
              genPackagesToCheck.add(genPackage);
              continue LOOP;
            }
          }
        }
      }
    }
    treeViewer.getTree().deselectAll();
    treeViewer.cancelEditing();
    treeViewer.setInput(new ItemProvider(genModels));
    for (Iterator<?> i=genModels.iterator(); i.hasNext(); ) {
      treeViewer.expandToLevel(i.next(),AbstractTreeViewer.ALL_LEVELS);
    }
    treeViewer.setCheckedElements(genPackagesToCheck.toArray());
    referencedGenModelsCheckboxTreeViewerCheckStateChanged(null);
  }
}","protected void referencedGenModelsAddSelected(CheckboxTreeViewer treeViewer){
  IPath path=null;
  Resource resource=getModelConverter().getGenModel().eResource();
  if (resource != null) {
    if (resource.getURI().isPlatformResource()) {
      path=new Path(resource.getURI().toPlatformString(true)).makeAbsolute();
    }
  }
  final IPath genModelPath=path;
  ResourceSet resourceSet=null;
  List<GenModel> genModels=new UniqueEList.FastCompare<GenModel>();
  final Set<URI> genModelURIs=new HashSet<URI>();
  Object input=treeViewer.getInput();
  if (input instanceof ItemProvider) {
    Collection<?> elements=((ItemProvider)input).getChildren();
    for (    Object element : elements) {
      if (element instanceof GenModel) {
        GenModel genModel=(GenModel)element;
        URI genModelURI=genModel.eResource().getURI();
        genModels.add(genModel);
        genModelURIs.add(genModelURI);
        if (resourceSet == null && genModelURI.isPlatformResource()) {
          resourceSet=genModel.eResource().getResourceSet();
        }
      }
    }
  }
  ViewerFilter genModelFilter=new ViewerFilter(){
    @Override public boolean select(    Viewer viewer,    Object parentElement,    Object element){
      if (element instanceof IFile) {
        IFile file=(IFile)element;
        URI uri=URI.createPlatformResourceURI(file.getFullPath().toString(),true);
        String fileExtension=file.getFileExtension();
        return (""String_Node_Str"".equals(fileExtension) || ""String_Node_Str"".equals(fileExtension)) && !file.getFullPath().equals(genModelPath) && !genModelURIs.contains(uri);
      }
      return true;
    }
  }
;
  IFile[] files=WorkspaceResourceDialog.openFileSelection(getShell(),null,ConverterPlugin.INSTANCE.getString(""String_Node_Str""),true,null,Collections.singletonList(genModelFilter));
  if (files.length > 0) {
    ResourceSet referencedGenModels=resourceSet != null ? resourceSet : getModelConverter().createResourceSet();
    for (int i=0; i < files.length; ++i) {
      URI genModelURI=URI.createPlatformResourceURI(files[i].getFullPath().toString(),true);
      Resource genModelResource=referencedGenModels.getResource(genModelURI,true);
      GenModel genModel=(GenModel)EcoreUtil.getObjectByType(genModelResource.getContents(),GenModelPackage.Literals.GEN_MODEL);
      genModels.add(genModel);
    }
    addExternalGenModels(genModels);
    addReferencedGenModels(genModels);
    List<GenPackage> genPackagesToCheck=new ArrayList<GenPackage>();
    Object[] checkedElements=treeViewer.getCheckedElements();
    LOOP:     for (int i=0; i < checkedElements.length; i++) {
      if (checkedElements[i] instanceof GenPackage) {
        GenPackage checkedGenPackage=(GenPackage)checkedElements[i];
        String nsURI=checkedGenPackage.getNSURI();
        for (        GenModel genModel : genModels) {
          for (          GenPackage genPackage : genModel.getGenPackages()) {
            if (nsURI.equals(genPackage.getNSURI())) {
              genPackagesToCheck.add(genPackage);
              continue LOOP;
            }
          }
        }
      }
    }
    treeViewer.getTree().deselectAll();
    treeViewer.cancelEditing();
    treeViewer.setInput(new ItemProvider(genModels));
    for (Iterator<?> i=genModels.iterator(); i.hasNext(); ) {
      treeViewer.expandToLevel(i.next(),AbstractTreeViewer.ALL_LEVELS);
    }
    treeViewer.setCheckedElements(genPackagesToCheck.toArray());
    referencedGenModelsCheckboxTreeViewerCheckStateChanged(null);
  }
}",0.9726505673552516
11726,"@Override protected Diagnostic doComputeEPackages(Monitor monitor) throws Exception {
  Diagnostic diagnostic=Diagnostic.OK_INSTANCE;
  List<URI> locationURIs=getModelLocationURIs();
  if (locationURIs.isEmpty()) {
    diagnostic=new BasicDiagnostic(Diagnostic.ERROR,EcoreImporterPlugin.getPlugin().getBundle().getSymbolicName(),0,EcoreImporterPlugin.INSTANCE.getString(""String_Node_Str""),null);
  }
 else {
    monitor.beginTask(""String_Node_Str"",2);
    monitor.subTask(EcoreImporterPlugin.INSTANCE.getString(""String_Node_Str"",new Object[]{locationURIs}));
    ResourceSet ecoreResourceSet=createResourceSet();
    for (    URI ecoreModelLocation : locationURIs) {
      ecoreResourceSet.getResource(ecoreModelLocation,true);
    }
    EcoreUtil.resolveAll(ecoreResourceSet);
    for (    Resource resource : ecoreResourceSet.getResources()) {
      getEPackages().addAll(EcoreUtil.<EPackage>getObjectsByType(resource.getContents(),EcorePackage.Literals.EPACKAGE));
    }
    BasicDiagnostic diagnosticChain=new BasicDiagnostic(ConverterPlugin.ID,ConverterUtil.ACTION_MESSAGE_NONE,EcoreImporterPlugin.INSTANCE.getString(""String_Node_Str""),null);
    for (    EPackage ePackage : getEPackages()) {
      Diagnostician.INSTANCE.validate(ePackage,diagnosticChain);
    }
    if (diagnosticChain.getSeverity() != Diagnostic.OK) {
      diagnostic=diagnosticChain;
    }
  }
  return diagnostic;
}","@Override protected Diagnostic doComputeEPackages(Monitor monitor) throws Exception {
  Diagnostic diagnostic=Diagnostic.OK_INSTANCE;
  List<URI> locationURIs=getModelLocationURIs();
  if (locationURIs.isEmpty()) {
    diagnostic=new BasicDiagnostic(Diagnostic.ERROR,EcoreImporterPlugin.getPlugin().getBundle().getSymbolicName(),0,EcoreImporterPlugin.INSTANCE.getString(""String_Node_Str""),null);
  }
 else {
    monitor.beginTask(""String_Node_Str"",2);
    monitor.subTask(EcoreImporterPlugin.INSTANCE.getString(""String_Node_Str"",new Object[]{locationURIs}));
    ResourceSet ecoreResourceSet=createResourceSet();
    for (    URI ecoreModelLocation : locationURIs) {
      ecoreResourceSet.getResource(ecoreModelLocation,true);
    }
    EcoreUtil.resolveAll(ecoreResourceSet);
    List<EPackage> ePackages=getEPackages();
    for (    Resource resource : ecoreResourceSet.getResources()) {
      ePackages.addAll(EcoreUtil.<EPackage>getObjectsByType(resource.getContents(),EcorePackage.Literals.EPACKAGE));
    }
    for (Iterator<EPackage> i=ePackages.iterator(); i.hasNext(); ) {
      if (""String_Node_Str"".equals(i.next().getNsURI())) {
        i.remove();
      }
    }
    BasicDiagnostic diagnosticChain=new BasicDiagnostic(ConverterPlugin.ID,ConverterUtil.ACTION_MESSAGE_NONE,EcoreImporterPlugin.INSTANCE.getString(""String_Node_Str""),null);
    for (    EPackage ePackage : ePackages) {
      Diagnostician.INSTANCE.validate(ePackage,diagnosticChain);
    }
    if (diagnosticChain.getSeverity() != Diagnostic.OK) {
      diagnostic=diagnosticChain;
    }
  }
  return diagnostic;
}",0.925963149078727
11727,"@Override public GenPackage findGenPackage(EPackage ePackage){
  GenPackage result;
  if (ePackageToGenPackageMap == null) {
    ePackageToGenPackageMap=new HashMap<EPackage,GenPackage>();
    result=null;
  }
 else {
    result=ePackageToGenPackageMap.get(ePackage);
    if (result != null) {
      return result;
    }
  }
  if (!isMainGenModel() && (ePackage == EcorePackage.eINSTANCE || ePackage == XMLTypePackage.eINSTANCE || ePackage == XMLNamespacePackage.eINSTANCE)) {
    result=getMainGenModel().findGenPackage(ePackage);
  }
 else   if (ePackage == EcorePackage.eINSTANCE) {
    if (ecoreGenPackage == null) {
      GenModel ecoreGenModel=getGenModel().createGenModel();
      ecoreGenModel.initialize(Collections.singleton(EcorePackage.eINSTANCE));
      ecoreGenModel.setMainGenModel(this);
      ecoreGenModel.setImportManager(getImportManager());
      ecoreGenModel.setLanguage(""String_Node_Str"");
      ecoreGenPackage=ecoreGenModel.getGenPackages().get(0);
      ecoreGenPackage.setPrefix(""String_Node_Str"");
      ecoreGenPackage.setBasePackage(""String_Node_Str"");
    }
    result=ecoreGenPackage;
  }
 else   if (ePackage == XMLTypePackage.eINSTANCE) {
    if (xmlTypeGenPackage == null) {
      GenModel xmlTypeGenModel=getGenModel().createGenModel();
      xmlTypeGenModel.initialize(Collections.singleton(XMLTypePackage.eINSTANCE));
      xmlTypeGenModel.setMainGenModel(this);
      xmlTypeGenModel.setImportManager(getImportManager());
      xmlTypeGenModel.setLanguage(""String_Node_Str"");
      xmlTypeGenPackage=xmlTypeGenModel.getGenPackages().get(0);
      xmlTypeGenPackage.setPrefix(""String_Node_Str"");
      xmlTypeGenPackage.setBasePackage(""String_Node_Str"");
      xmlTypeGenPackage.setDataTypeConverters(true);
    }
    result=xmlTypeGenPackage;
  }
 else   if (ePackage == XMLNamespacePackage.eINSTANCE) {
    if (xmlNamespaceGenPackage == null) {
      GenModel xmlNamespaceGenModel=getGenModel().createGenModel();
      xmlNamespaceGenModel.initialize(Collections.singleton(XMLNamespacePackage.eINSTANCE));
      xmlNamespaceGenModel.setMainGenModel(this);
      xmlNamespaceGenModel.setImportManager(getImportManager());
      xmlNamespaceGenModel.setLanguage(""String_Node_Str"");
      xmlNamespaceGenPackage=xmlNamespaceGenModel.getGenPackages().get(0);
      xmlNamespaceGenPackage.setPrefix(""String_Node_Str"");
      xmlNamespaceGenPackage.setBasePackage(""String_Node_Str"");
    }
    result=xmlNamespaceGenPackage;
  }
 else   if (ePackage != null) {
    for (Iterator<GenPackage> pIter=getAllGenPackages().iterator(); pIter.hasNext() && result == null; ) {
      GenPackage genPackage=pIter.next();
      result=findGenPackageHelper(genPackage,ePackage);
    }
  }
  ePackageToGenPackageMap.put(ePackage,result);
  return result;
}","@Override public GenPackage findGenPackage(EPackage ePackage){
  GenPackage result;
  if (ePackageToGenPackageMap == null) {
    ePackageToGenPackageMap=new HashMap<EPackage,GenPackage>();
    result=null;
  }
 else {
    result=ePackageToGenPackageMap.get(ePackage);
    if (result != null) {
      return result;
    }
  }
  boolean isMainGenModel=isMainGenModel();
  if (!isMainGenModel && (ePackage == EcorePackage.eINSTANCE || ePackage == XMLTypePackage.eINSTANCE || ePackage == XMLNamespacePackage.eINSTANCE)) {
    result=getMainGenModel().findGenPackage(ePackage);
  }
 else   if (ePackage == EcorePackage.eINSTANCE) {
    if (ecoreGenPackage == null) {
      GenModel ecoreGenModel=getGenModel().createGenModel();
      ecoreGenModel.initialize(Collections.singleton(EcorePackage.eINSTANCE));
      ecoreGenModel.setMainGenModel(this);
      ecoreGenModel.setImportManager(getImportManager());
      ecoreGenModel.setLanguage(""String_Node_Str"");
      ecoreGenPackage=ecoreGenModel.getGenPackages().get(0);
      ecoreGenPackage.setPrefix(""String_Node_Str"");
      ecoreGenPackage.setBasePackage(""String_Node_Str"");
    }
    result=ecoreGenPackage;
  }
 else   if (ePackage == XMLTypePackage.eINSTANCE) {
    if (xmlTypeGenPackage == null) {
      GenModel xmlTypeGenModel=getGenModel().createGenModel();
      xmlTypeGenModel.initialize(Collections.singleton(XMLTypePackage.eINSTANCE));
      xmlTypeGenModel.setMainGenModel(this);
      xmlTypeGenModel.setImportManager(getImportManager());
      xmlTypeGenModel.setLanguage(""String_Node_Str"");
      xmlTypeGenPackage=xmlTypeGenModel.getGenPackages().get(0);
      xmlTypeGenPackage.setPrefix(""String_Node_Str"");
      xmlTypeGenPackage.setBasePackage(""String_Node_Str"");
      xmlTypeGenPackage.setDataTypeConverters(true);
    }
    result=xmlTypeGenPackage;
  }
 else   if (ePackage == XMLNamespacePackage.eINSTANCE) {
    if (xmlNamespaceGenPackage == null) {
      GenModel xmlNamespaceGenModel=getGenModel().createGenModel();
      xmlNamespaceGenModel.initialize(Collections.singleton(XMLNamespacePackage.eINSTANCE));
      xmlNamespaceGenModel.setMainGenModel(this);
      xmlNamespaceGenModel.setImportManager(getImportManager());
      xmlNamespaceGenModel.setLanguage(""String_Node_Str"");
      xmlNamespaceGenPackage=xmlNamespaceGenModel.getGenPackages().get(0);
      xmlNamespaceGenPackage.setPrefix(""String_Node_Str"");
      xmlNamespaceGenPackage.setBasePackage(""String_Node_Str"");
    }
    result=xmlNamespaceGenPackage;
  }
 else   if (ePackage != null) {
    for (Iterator<GenPackage> pIter=getAllGenPackages().iterator(); pIter.hasNext() && result == null; ) {
      GenPackage genPackage=pIter.next();
      result=findGenPackageHelper(genPackage,ePackage);
    }
    if (result == null && !isMainGenModel) {
      result=getMainGenModel().findGenPackage(ePackage);
    }
  }
  ePackageToGenPackageMap.put(ePackage,result);
  return result;
}",0.97317201472909
11728,"public ClassLoader getClassLoader(ResourceSet resourceSet){
  IJavaProject project=getJavaProject(resourceSet);
  if (project != null) {
    IWorkspaceRoot workspaceRoot=project.getProject().getWorkspace().getRoot();
    List<URL> libraryURLs=new UniqueEList<URL>();
    try {
      getAllReferencedProjects(libraryURLs,new IProject[]{project.getProject()});
      IClasspathEntry[] classpath=project.getResolvedClasspath(true);
      if (classpath != null) {
        for (int i=0; i < classpath.length; ++i) {
          IClasspathEntry classpathEntry=classpath[i];
switch (classpathEntry.getEntryKind()) {
case IClasspathEntry.CPE_LIBRARY:
case IClasspathEntry.CPE_CONTAINER:
{
              libraryURLs.add(new URL(URI.createFileURI(classpathEntry.getPath().toString()).toString()));
              break;
            }
case IClasspathEntry.CPE_PROJECT:
{
            IProject referencedProject=workspaceRoot.getProject(classpathEntry.getPath().segment(0));
            IJavaProject referencedJavaProject=JavaCore.create(referencedProject);
            IContainer container=workspaceRoot.getFolder(referencedJavaProject.getOutputLocation());
            libraryURLs.add(new URL(URI.createFileURI(container.getLocation().toString() + ""String_Node_Str"").toString()));
            IProjectDescription description=referencedProject.getDescription();
            getAllReferencedProjects(libraryURLs,description.getReferencedProjects());
            getAllReferencedProjects(libraryURLs,description.getDynamicReferences());
            break;
          }
case IClasspathEntry.CPE_SOURCE:
case IClasspathEntry.CPE_VARIABLE:
default :
{
          break;
        }
    }
  }
}
return new URLClassLoader(libraryURLs.toArray(new URL[libraryURLs.size()]),getClass().getClassLoader());
}
 catch (MalformedURLException exception) {
exception.printStackTrace();
}
catch (JavaModelException exception) {
exception.printStackTrace();
}
catch (CoreException exception) {
exception.printStackTrace();
}
}
for (Resource resource : resourceSet.getResources()) {
URI uri=resource.getURI();
if (uri.isPlatformPlugin()) {
final Bundle bundle=Platform.getBundle(uri.segments()[1]);
return new ClassLoader(){
  @Override public Enumeration<URL> findResources(  String name) throws IOException {
    return bundle.getResources(name);
  }
  @Override public URL findResource(  String name){
    return bundle.getResource(name);
  }
  @Override public URL getResource(  String name){
    return findResource(name);
  }
  @Override public Class<?> findClass(  String name) throws ClassNotFoundException {
    return bundle.loadClass(name);
  }
  @Override protected Class<?> loadClass(  String name,  boolean resolve) throws ClassNotFoundException {
    Class<?> clazz=findClass(name);
    if (resolve) {
      resolveClass(clazz);
    }
    return clazz;
  }
}
;
}
}
return null;
}","public ClassLoader getClassLoader(ResourceSet resourceSet){
  IJavaProject project=getJavaProject(resourceSet);
  if (project != null) {
    IProject iProject=project.getProject();
    IWorkspaceRoot workspaceRoot=iProject.getWorkspace().getRoot();
    List<URL> libraryURLs=new UniqueEList<URL>();
    try {
      getAllReferencedProjects(libraryURLs,new IProject[]{iProject});
      IClasspathEntry[] classpath=project.getResolvedClasspath(true);
      if (classpath != null) {
        String projectName=iProject.getName();
        for (int i=0; i < classpath.length; ++i) {
          IClasspathEntry classpathEntry=classpath[i];
switch (classpathEntry.getEntryKind()) {
case IClasspathEntry.CPE_LIBRARY:
case IClasspathEntry.CPE_CONTAINER:
{
              IPath path=classpathEntry.getPath();
              if (path.segment(0).equals(projectName)) {
                path=iProject.getLocation().append(path.removeFirstSegments(1));
              }
              libraryURLs.add(new URL(URI.createFileURI(path.toString()).toString()));
              break;
            }
case IClasspathEntry.CPE_PROJECT:
{
            IPath path=classpathEntry.getPath();
            IProject referencedProject=workspaceRoot.getProject(path.segment(0));
            IJavaProject referencedJavaProject=JavaCore.create(referencedProject);
            IContainer container=workspaceRoot.getFolder(referencedJavaProject.getOutputLocation());
            libraryURLs.add(new URL(URI.createFileURI(container.getLocation().toString() + ""String_Node_Str"").toString()));
            IProjectDescription description=referencedProject.getDescription();
            getAllReferencedProjects(libraryURLs,description.getReferencedProjects());
            getAllReferencedProjects(libraryURLs,description.getDynamicReferences());
            break;
          }
case IClasspathEntry.CPE_SOURCE:
case IClasspathEntry.CPE_VARIABLE:
default :
{
          break;
        }
    }
  }
}
return new URLClassLoader(libraryURLs.toArray(new URL[libraryURLs.size()]),getClass().getClassLoader());
}
 catch (MalformedURLException exception) {
exception.printStackTrace();
}
catch (JavaModelException exception) {
exception.printStackTrace();
}
catch (CoreException exception) {
exception.printStackTrace();
}
}
for (Resource resource : resourceSet.getResources()) {
URI uri=resource.getURI();
if (uri.isPlatformPlugin()) {
final Bundle bundle=Platform.getBundle(uri.segments()[1]);
return new ClassLoader(){
  @Override public Enumeration<URL> findResources(  String name) throws IOException {
    return bundle.getResources(name);
  }
  @Override public URL findResource(  String name){
    return bundle.getResource(name);
  }
  @Override public URL getResource(  String name){
    return findResource(name);
  }
  @Override public Class<?> findClass(  String name) throws ClassNotFoundException {
    return bundle.loadClass(name);
  }
  @Override protected Class<?> loadClass(  String name,  boolean resolve) throws ClassNotFoundException {
    Class<?> clazz=findClass(name);
    if (resolve) {
      resolveClass(clazz);
    }
    return clazz;
  }
}
;
}
}
return null;
}",0.9277007847720822
11729,"public void link(){
  List<Runnable> currentRunnables=new ArrayList<Runnable>(runnables);
  runnables.clear();
  for (  Runnable runnable : currentRunnables) {
    runnable.run();
  }
  for (  Runnable runnable : runnables) {
    runnable.run();
  }
}","public void link(){
  List<Runnable> currentRunnables=new ArrayList<Runnable>(runnables);
  runnables.clear();
  for (  Runnable runnable : currentRunnables) {
    try {
      runnable.run();
    }
 catch (    Throwable throwable) {
      XcorePlugin.INSTANCE.log(throwable);
    }
  }
  for (  Runnable runnable : runnables) {
    try {
      runnable.run();
    }
 catch (    Throwable throwable) {
      XcorePlugin.INSTANCE.log(throwable);
    }
  }
}",0.6090651558073654
11730,"protected EClassifier getEClassifier(final XClassifier xClassifier){
  final EClassifier eClassifier=xClassifier instanceof XClass ? getEClass((XClass)xClassifier) : xClassifier instanceof XEnum ? getEEnum((XEnum)xClassifier) : getEDataType((XDataType)xClassifier);
  handleAnnotations(xClassifier,eClassifier);
  eClassifier.setName(nonNullName(xClassifier.getName()));
  if (xClassifier.eIsSet(XcorePackage.Literals.XCLASSIFIER__INSTANCE_TYPE)) {
    if (eClassifier instanceof EClass) {
      eClassifier.setInstanceTypeName(""String_Node_Str"");
    }
    instanceTypeRunnables.add(new Runnable(){
      public void run(){
        JvmTypeReference instanceType=xClassifier.getInstanceType();
        if (instanceType != null) {
          String instanceTypeName=instanceType.getIdentifier();
          String normalizedInstanceTypeName=EcoreUtil.toJavaInstanceTypeName((EGenericType)EcoreValidator.EGenericTypeBuilder.INSTANCE.parseInstanceTypeName(instanceTypeName).getData().get(0));
          eClassifier.setInstanceTypeName(normalizedInstanceTypeName);
          if (classLoader != null && eClassifier instanceof EClassifierImpl) {
            try {
              Class<?> instanceClass=classLoader.loadClass(eClassifier.getInstanceClassName());
              ((EClassifierImpl)eClassifier).setInstanceClassGen(instanceClass);
            }
 catch (            Throwable throwable) {
            }
          }
        }
      }
    }
);
  }
  return eClassifier;
}","protected EClassifier getEClassifier(final XClassifier xClassifier){
  final EClassifier eClassifier=xClassifier instanceof XClass ? getEClass((XClass)xClassifier) : xClassifier instanceof XEnum ? getEEnum((XEnum)xClassifier) : getEDataType((XDataType)xClassifier);
  handleAnnotations(xClassifier,eClassifier);
  eClassifier.setName(nonNullName(xClassifier.getName()));
  if (xClassifier.eIsSet(XcorePackage.Literals.XCLASSIFIER__INSTANCE_TYPE)) {
    if (eClassifier instanceof EClass) {
      eClassifier.setInstanceTypeName(""String_Node_Str"");
    }
    List<INode> nodes=NodeModelUtils.findNodesForFeature(xClassifier,XcorePackage.Literals.XCLASSIFIER__INSTANCE_TYPE);
    if (!nodes.isEmpty()) {
      StringBuilder instanceTypeLiteral=new StringBuilder();
      for (      INode node : nodes) {
        instanceTypeLiteral.append(NodeModelUtils.getTokenText(node));
      }
      eClassifier.setInstanceTypeName(instanceTypeLiteral.toString());
    }
    instanceTypeRunnables.add(new Runnable(){
      public void run(){
        JvmTypeReference instanceType=xClassifier.getInstanceType();
        if (instanceType != null) {
          String instanceTypeName=instanceType.getIdentifier();
          String normalizedInstanceTypeName=EcoreUtil.toJavaInstanceTypeName((EGenericType)EcoreValidator.EGenericTypeBuilder.INSTANCE.parseInstanceTypeName(instanceTypeName).getData().get(0));
          eClassifier.setInstanceTypeName(normalizedInstanceTypeName);
          if (classLoader != null && eClassifier instanceof EClassifierImpl) {
            try {
              Class<?> instanceClass=classLoader.loadClass(eClassifier.getInstanceClassName());
              ((EClassifierImpl)eClassifier).setInstanceClassGen(instanceClass);
            }
 catch (            Throwable throwable) {
            }
          }
        }
      }
    }
);
  }
  return eClassifier;
}",0.8791866028708134
11731,"public void linkInstanceTypes(){
  for (  Runnable runnable : instanceTypeRunnables) {
    runnable.run();
  }
}","public void linkInstanceTypes(){
  for (  Runnable runnable : instanceTypeRunnables) {
    try {
      runnable.run();
    }
 catch (    Throwable throwable) {
      XcorePlugin.INSTANCE.log(throwable);
    }
  }
}",0.6687116564417178
11732,"/** 
 * @since 2.8
 */
protected String indentAndImport(String body,String indentation){
  if (body != null) {
    StringBuffer stringBuffer=new StringBuffer(indent(body,indentation));
    for (int i=0; i < stringBuffer.length(); ) {
      int start=stringBuffer.indexOf(""String_Node_Str"",i);
      if (start == -1) {
        break;
      }
 else {
        int end=stringBuffer.indexOf(""String_Node_Str"",start + 2);
        if (end == -1) {
          break;
        }
 else {
          String qualifiedName=stringBuffer.substring(start + 2,end);
          String importedName=getGenModel().getImportedName(qualifiedName);
          stringBuffer.replace(start,end + 2,importedName);
          i+=importedName.length();
        }
      }
    }
    return stringBuffer.toString();
  }
 else {
    return null;
  }
}","/** 
 * @since 2.8
 */
protected String indentAndImport(String body,String indentation){
  if (body != null) {
    StringBuffer stringBuffer=new StringBuffer(indent(body,indentation));
    for (int i=0; i < stringBuffer.length(); ) {
      int start=stringBuffer.indexOf(""String_Node_Str"",i);
      if (start == -1) {
        break;
      }
 else {
        int end=stringBuffer.indexOf(""String_Node_Str"",start + 2);
        if (end == -1) {
          break;
        }
 else {
          String qualifiedName=stringBuffer.substring(start + 2,end);
          String importedName=getGenModel().getImportedName(qualifiedName);
          stringBuffer.replace(start,end + 2,importedName);
          i=start + importedName.length();
        }
      }
    }
    return stringBuffer.toString();
  }
 else {
    return null;
  }
}",0.9944819129368484
11733,"@Override public ITreeAppendable append(CharSequence value){
  String string=value.toString();
  if (string.startsWith(""String_Node_Str"") || string.startsWith(""String_Node_Str"") || string.startsWith(""String_Node_Str"")|| string.startsWith(""String_Node_Str"")) {
    return super.append(""String_Node_Str"").append(string.substring(1));
  }
 else   if (string.endsWith(""String_Node_Str"")) {
    return super.append(string.substring(0,string.length() - 2)).append(""String_Node_Str"");
  }
 else   if (string.endsWith(""String_Node_Str"")) {
    return super.append(string.substring(0,string.length() - 3)).append(""String_Node_Str"");
  }
 else   if (string.startsWith(""String_Node_Str"")) {
    return super.append(""String_Node_Str"").append(string.substring(2));
  }
 else   if (string.endsWith(""String_Node_Str"")) {
    return super.append(string.substring(0,string.length() - 1)).append(""String_Node_Str"");
  }
 else {
    return super.append(value);
  }
}","@Override public ITreeAppendable append(CharSequence value){
  String string=value.toString();
  if (string.equals(""String_Node_Str"")) {
    if (!inDoubleQuotedString) {
      inSingleQuotedString=!inSingleQuotedString;
    }
    return super.append(value);
  }
 else   if (string.equals(""String_Node_Str"")) {
    if (!inSingleQuotedString) {
      inDoubleQuotedString=!inDoubleQuotedString;
    }
    return super.append(value);
  }
 else   if (inSingleQuotedString || inDoubleQuotedString) {
    return super.append(string.replace(""String_Node_Str"",""String_Node_Str""));
  }
 else   if (string.startsWith(""String_Node_Str"") || string.startsWith(""String_Node_Str"") || string.startsWith(""String_Node_Str"")|| string.startsWith(""String_Node_Str"")) {
    return super.append(""String_Node_Str"").append(string.substring(1));
  }
 else   if (string.endsWith(""String_Node_Str"")) {
    return super.append(string.substring(0,string.length() - 2)).append(""String_Node_Str"");
  }
 else   if (string.endsWith(""String_Node_Str"")) {
    return super.append(string.substring(0,string.length() - 3)).append(""String_Node_Str"");
  }
 else   if (string.startsWith(""String_Node_Str"")) {
    return super.append(""String_Node_Str"").append(string.substring(2));
  }
 else   if (string.endsWith(""String_Node_Str"")) {
    return super.append(string.substring(0,string.length() - 1)).append(""String_Node_Str"");
  }
 else {
    return super.append(value);
  }
}",0.7707808564231738
11734,"public List<String> getQualifiedInterfaceExtendsList(){
  List<String> result=new UniqueEList<String>();
  String rootExtendsInterface=getGenModel().getRootExtendsInterface();
  if (rootExtendsInterface == null) {
    rootExtendsInterface=""String_Node_Str"";
  }
  if (getBaseGenClasses().isEmpty()) {
    if (!isEObject() && !isBlank(rootExtendsInterface)) {
      result.add(rootExtendsInterface);
    }
    return result;
  }
  boolean needsRootExtendsInterface=true;
  for (  GenClass genClass : getAllBaseGenClasses()) {
    if (genClass.getEcoreClass().getInstanceClassName() == null && rootExtendsInterface.equals(genClass.getGenModel().getRootExtendsInterface())) {
      needsRootExtendsInterface=false;
      break;
    }
  }
  if (needsRootExtendsInterface && !isBlank(rootExtendsInterface)) {
    result.add(rootExtendsInterface);
  }
  boolean includeTypeArguments=getEffectiveComplianceLevel().getValue() >= GenJDKLevel.JDK50;
  for (int i=0, size=getBaseGenClasses().size(); i < size; i++) {
    GenClassImpl genClass=(GenClassImpl)getBaseGenClasses().get(i);
    EGenericType eGenericType=getEcoreClass().getEGenericSuperTypes().get(i);
    if (genClass.isExternalInterface() || genClass.isInterface() || !genClass.getGenModel().isSuppressInterfaces()) {
      if (includeTypeArguments && !eGenericType.getETypeArguments().isEmpty()) {
        result.add(genClass.getInternalQualifiedInterfaceName() + getTypeArguments(this,eGenericType.getETypeArguments(),false));
      }
 else {
        result.add(genClass.getInternalQualifiedInterfaceName());
      }
    }
  }
  return result;
}","public List<String> getQualifiedInterfaceExtendsList(){
  List<String> result=new UniqueEList<String>();
  if (!isExternalInterface()) {
    String rootExtendsInterface=getGenModel().getRootExtendsInterface();
    if (rootExtendsInterface == null) {
      rootExtendsInterface=""String_Node_Str"";
    }
    if (getBaseGenClasses().isEmpty()) {
      if (!isEObject() && !isBlank(rootExtendsInterface)) {
        result.add(rootExtendsInterface);
      }
      return result;
    }
    boolean needsRootExtendsInterface=true;
    for (    GenClass genClass : getAllBaseGenClasses()) {
      if (genClass.getEcoreClass().getInstanceClassName() == null && rootExtendsInterface.equals(genClass.getGenModel().getRootExtendsInterface())) {
        needsRootExtendsInterface=false;
        break;
      }
    }
    if (needsRootExtendsInterface && !isBlank(rootExtendsInterface)) {
      result.add(rootExtendsInterface);
    }
  }
  boolean includeTypeArguments=getEffectiveComplianceLevel().getValue() >= GenJDKLevel.JDK50;
  for (int i=0, size=getBaseGenClasses().size(); i < size; i++) {
    GenClassImpl genClass=(GenClassImpl)getBaseGenClasses().get(i);
    EGenericType eGenericType=getEcoreClass().getEGenericSuperTypes().get(i);
    if (genClass.isExternalInterface() || genClass.isInterface() || !genClass.getGenModel().isSuppressInterfaces()) {
      if (includeTypeArguments && !eGenericType.getETypeArguments().isEmpty()) {
        result.add(genClass.getInternalQualifiedInterfaceName() + getTypeArguments(this,eGenericType.getETypeArguments(),false));
      }
 else {
        result.add(genClass.getInternalQualifiedInterfaceName());
      }
    }
  }
  return result;
}",0.9731379731379732
11735,"public void scheduleValidation(){
  if (validationJob == null && (dialogSettings == null || dialogSettings.getBoolean(LiveValidationAction.LIVE_VALIDATOR_DIALOG_SETTINGS_KEY))) {
    validationJob=new Job(""String_Node_Str""){
      @Override protected IStatus run(      final IProgressMonitor monitor){
        Diagnostician diagnostician=new Diagnostician(){
          @Override public String getObjectLabel(          EObject eObject){
            String text=labelProvider != null && eObject.eIsProxy() ? ((InternalEObject)eObject).eProxyURI().toString() : labelProvider.getText(eObject);
            if (text == null || text.length() == 0) {
              text=""String_Node_Str"";
            }
 else {
              text=escapeContent(text);
            }
            Image image=labelProvider != null ? labelProvider.getImage(eObject) : null;
            if (image != null) {
              URI imageURI=ImageURIRegistry.INSTANCE.getImageURI(image);
              return enquote(""String_Node_Str"" + imageURI + ""String_Node_Str""+ text);
            }
 else {
              return escapeContent(text);
            }
          }
          @Override public boolean validate(          EClass eClass,          EObject eObject,          DiagnosticChain diagnostics,          Map<Object,Object> context){
            monitor.worked(1);
            return super.validate(eClass,eObject,diagnostics,context);
          }
        }
;
        final ResourceSet resourceSet=editingDomain.getResourceSet();
        List<Resource> resources=new ArrayList<Resource>(Arrays.asList(scheduledResources.toArray(new Resource[0])));
        scheduledResources.removeAll(resources);
        int count=0;
        for (        Resource resource : resources) {
synchronized (resource) {
synchronized (resourceSet) {
              for (Iterator<EObject> i=resource.getAllContents(); i.hasNext(); ) {
                ++count;
                EObject eObject=i.next();
                for (                @SuppressWarnings(""String_Node_Str"") EObject eCrossReference : eObject.eCrossReferences()) {
                }
              }
            }
          }
        }
        for (List<Resource> moreResources=Arrays.asList(scheduledResources.toArray(new Resource[0])); !moreResources.isEmpty(); moreResources=Arrays.asList(scheduledResources.toArray(new Resource[0]))) {
          resources.addAll(moreResources);
          scheduledResources.removeAll(moreResources);
          for (          Resource resource : moreResources) {
synchronized (resource) {
synchronized (resourceSet) {
                for (Iterator<EObject> i=resource.getAllContents(); i.hasNext(); ) {
                  ++count;
                  EObject eObject=i.next();
                  for (                  @SuppressWarnings(""String_Node_Str"") EObject eCrossReference : eObject.eCrossReferences()) {
                  }
                }
              }
            }
          }
        }
        monitor.beginTask(""String_Node_Str"",count);
        final BasicDiagnostic diagnostic=new BasicDiagnostic(EObjectValidator.DIAGNOSTIC_SOURCE,0,EMFEditUIPlugin.INSTANCE.getString(""String_Node_Str"",new String[]{""String_Node_Str"" + resources.size()}),new Object[]{resourceSet});
        Map<Object,Object> context=diagnostician.createDefaultContext();
        for (int i=0; i < resources.size(); ++i) {
          Resource resource=resources.get(i);
          monitor.setTaskName(EMFEditUIPlugin.INSTANCE.getString(""String_Node_Str"",new Object[]{resource.getURI()}));
          final BasicDiagnostic resourceDiagnostic=new BasicDiagnostic(EObjectValidator.DIAGNOSTIC_SOURCE,0,EMFEditUIPlugin.INSTANCE.getString(""String_Node_Str"",new String[]{""String_Node_Str""}),new Object[]{resource});
synchronized (resource) {
synchronized (resourceSet) {
              for (              EObject eObject : resource.getContents()) {
                diagnostician.validate(eObject,resourceDiagnostic,context);
              }
            }
          }
          for (          Resource.Diagnostic warning : resource.getWarnings()) {
            resourceDiagnostic.add(new BasicDiagnostic(Diagnostic.WARNING,null,0,warning.getMessage(),new Object[]{resource}));
          }
          for (          Resource.Diagnostic error : resource.getErrors()) {
            resourceDiagnostic.add(new BasicDiagnostic(Diagnostic.ERROR,null,0,error.getMessage(),new Object[]{resource}));
          }
          diagnostic.add(resourceDiagnostic);
          if (monitor.isCanceled()) {
            validationJob=null;
            return Status.CANCEL_STATUS;
          }
          monitor.worked(1);
        }
        DiagnosticAdapter.update(resourceSet,diagnostic);
        Display.getDefault().asyncExec(new Runnable(){
          public void run(){
            validationJob=null;
            if (!scheduledResources.isEmpty()) {
              LiveValidator.this.scheduleValidation();
            }
          }
        }
);
        return Status.OK_STATUS;
      }
    }
;
    validationJob.setPriority(Job.DECORATE);
    validationJob.schedule(500);
  }
}","public void scheduleValidation(){
  if (validationJob == null && (dialogSettings == null || dialogSettings.getBoolean(LiveValidationAction.LIVE_VALIDATOR_DIALOG_SETTINGS_KEY))) {
    validationJob=new Job(""String_Node_Str""){
      @Override protected IStatus run(      final IProgressMonitor monitor){
        Diagnostician diagnostician=new Diagnostician(){
          @Override public String getObjectLabel(          EObject eObject){
            String text=labelProvider != null && eObject.eIsProxy() ? ((InternalEObject)eObject).eProxyURI().toString() : labelProvider.getText(eObject);
            if (text == null || text.length() == 0) {
              text=""String_Node_Str"";
            }
 else {
              text=escapeContent(text);
            }
            Image image=labelProvider != null ? labelProvider.getImage(eObject) : null;
            if (image != null) {
              URI imageURI=ImageURIRegistry.INSTANCE.getImageURI(image);
              return enquote(""String_Node_Str"" + imageURI + ""String_Node_Str""+ text);
            }
 else {
              return escapeContent(text);
            }
          }
          @Override public boolean validate(          EClass eClass,          EObject eObject,          DiagnosticChain diagnostics,          Map<Object,Object> context){
            monitor.worked(1);
            return super.validate(eClass,eObject,diagnostics,context);
          }
        }
;
        final ResourceSet resourceSet=editingDomain.getResourceSet();
        List<Resource> resources=new UniqueEList<Resource>(Arrays.asList(scheduledResources.toArray(new Resource[0])));
        scheduledResources.removeAll(resources);
        int count=0;
        for (        Resource resource : resources) {
synchronized (resource) {
synchronized (resourceSet) {
              for (Iterator<EObject> i=resource.getAllContents(); i.hasNext(); ) {
                ++count;
                EObject eObject=i.next();
                for (                @SuppressWarnings(""String_Node_Str"") EObject eCrossReference : eObject.eCrossReferences()) {
                }
              }
            }
          }
        }
        for (List<Resource> moreResources=Arrays.asList(scheduledResources.toArray(new Resource[0])); !moreResources.isEmpty(); moreResources=Arrays.asList(scheduledResources.toArray(new Resource[0]))) {
          resources.addAll(moreResources);
          scheduledResources.removeAll(moreResources);
          for (          Resource resource : moreResources) {
synchronized (resource) {
synchronized (resourceSet) {
                for (Iterator<EObject> i=resource.getAllContents(); i.hasNext(); ) {
                  ++count;
                  EObject eObject=i.next();
                  for (                  @SuppressWarnings(""String_Node_Str"") EObject eCrossReference : eObject.eCrossReferences()) {
                  }
                }
              }
            }
          }
        }
        monitor.beginTask(""String_Node_Str"",count);
        final BasicDiagnostic diagnostic=new BasicDiagnostic(EObjectValidator.DIAGNOSTIC_SOURCE,0,EMFEditUIPlugin.INSTANCE.getString(""String_Node_Str"",new String[]{""String_Node_Str"" + resources.size()}),new Object[]{resourceSet});
        Map<Object,Object> context=diagnostician.createDefaultContext();
        for (int i=0; i < resources.size(); ++i) {
          Resource resource=resources.get(i);
          monitor.setTaskName(EMFEditUIPlugin.INSTANCE.getString(""String_Node_Str"",new Object[]{resource.getURI()}));
          final BasicDiagnostic resourceDiagnostic=new BasicDiagnostic(EObjectValidator.DIAGNOSTIC_SOURCE,0,EMFEditUIPlugin.INSTANCE.getString(""String_Node_Str"",new String[]{""String_Node_Str""}),new Object[]{resource});
synchronized (resource) {
synchronized (resourceSet) {
              for (              EObject eObject : resource.getContents()) {
                diagnostician.validate(eObject,resourceDiagnostic,context);
              }
            }
          }
          for (          Resource.Diagnostic warning : resource.getWarnings()) {
            resourceDiagnostic.add(new BasicDiagnostic(Diagnostic.WARNING,null,0,warning.getMessage(),new Object[]{resource}));
          }
          for (          Resource.Diagnostic error : resource.getErrors()) {
            resourceDiagnostic.add(new BasicDiagnostic(Diagnostic.ERROR,null,0,error.getMessage(),new Object[]{resource}));
          }
          diagnostic.add(resourceDiagnostic);
          if (monitor.isCanceled()) {
            validationJob=null;
            return Status.CANCEL_STATUS;
          }
          monitor.worked(1);
        }
        DiagnosticAdapter.update(resourceSet,diagnostic);
        Display.getDefault().asyncExec(new Runnable(){
          public void run(){
            validationJob=null;
            if (!scheduledResources.isEmpty()) {
              LiveValidator.this.scheduleValidation();
            }
          }
        }
);
        return Status.OK_STATUS;
      }
    }
;
    validationJob.setPriority(Job.DECORATE);
    validationJob.schedule(500);
  }
}",0.9988172678888232
11736,"/** 
 * Decorate the given   {@code styledString} by underlying the whole given {@code styledString} with a  {@link SWT#UNDERLINE_ERROR} underline style colored in {@link JFacePreferences#ERROR_COLOR}.
 */
public StyledString decorateStyledText(StyledString styledString,Object object){
  if (styledString == null || object == null) {
    throw new NullPointerException();
  }
  Diagnostic diagnostic=getDecorations().get(object);
  if (diagnostic != null && diagnostic.getSeverity() >= Diagnostic.WARNING) {
    StyledString result=new StyledString();
    StyleRange[] styleRanges=styledString.getStyleRanges();
    String string=styledString.getString();
    if (styleRanges.length == 0) {
      result.append(string,ErrorStyler.INSTANCE);
    }
 else {
      int start=0;
      for (      StyleRange range : styleRanges) {
        if (start < range.start) {
          result.append(string.substring(start,(range.start - start)),ErrorStyler.INSTANCE);
        }
        start=range.start + range.length;
        result.append(string.substring(range.start,start),new ComposedStyler(range,ErrorStyler.INSTANCE));
      }
      if (start < styledString.length()) {
        result.append(string.substring(start,string.length()),ErrorStyler.INSTANCE);
      }
    }
    return result;
  }
  return styledString;
}","/** 
 * Decorate the given   {@code styledString} by underlying the whole given {@code styledString} with a  {@link SWT#UNDERLINE_ERROR} underline style colored in {@link JFacePreferences#ERROR_COLOR}.
 */
@Override public StyledString decorateStyledText(StyledString styledString,Object object){
  if (styledString == null || object == null) {
    throw new NullPointerException();
  }
  Diagnostic diagnostic=getDecorations().get(object);
  if (diagnostic != null && diagnostic.getSeverity() >= Diagnostic.WARNING) {
    StyledString result=new StyledString();
    StyleRange[] styleRanges=styledString.getStyleRanges();
    String string=styledString.getString();
    if (styleRanges.length == 0) {
      result.append(string,ErrorStyler.INSTANCE);
    }
 else {
      int start=0;
      for (      StyleRange range : styleRanges) {
        if (start < range.start) {
          result.append(string.substring(start,(range.start - start)),ErrorStyler.INSTANCE);
        }
        start=range.start + range.length;
        result.append(string.substring(range.start,start),new ComposedStyler(range,ErrorStyler.INSTANCE));
      }
      if (start < styledString.length()) {
        result.append(string.substring(start,string.length()),ErrorStyler.INSTANCE);
      }
    }
    return result;
  }
  return styledString;
}",0.9961977186311788
11737,"/** 
 * @since 2.9
 */
@Override public Diagnostic getMarkerDiagnostics(Object object,IFile file){
  if (file == null) {
    file=getFile(object);
  }
  if (object instanceof Resource) {
    Resource resource=(Resource)object;
    EditingDomain editingDomain=AdapterFactoryEditingDomain.getEditingDomainFor(resource.getResourceSet());
    BasicDiagnostic diagnostic=new BasicDiagnostic(getDiagnosticSource(),0,null,new Object[]{resource});
    if (file != null) {
      try {
        for (        IMarker marker : file.findMarkers(null,true,IResource.DEPTH_ZERO)) {
          String message=marker.getAttribute(IMarker.MESSAGE,""String_Node_Str"");
          int severity=marker.getAttribute(IMarker.SEVERITY,IMarker.SEVERITY_INFO);
          String sourceID=marker.getAttribute(IMarker.SOURCE_ID,""String_Node_Str"");
          List<?> data=getTargetObjects(editingDomain,marker);
          diagnostic.add(new BasicDiagnostic(severity == IMarker.SEVERITY_ERROR ? Diagnostic.ERROR : severity == IMarker.SEVERITY_WARNING ? Diagnostic.WARNING : Diagnostic.INFO,sourceID,0,message,data.toArray(new Object[data.size()])));
        }
      }
 catch (      CoreException exception) {
        CommonUIPlugin.INSTANCE.log(exception);
      }
    }
    for (    Resource.Diagnostic resourceDiagnostic : resource.getWarnings()) {
      diagnostic.add(new BasicDiagnostic(Diagnostic.WARNING,null,0,resourceDiagnostic.getMessage(),new Object[]{resource}));
    }
    for (    Resource.Diagnostic resourceDiagnostic : resource.getErrors()) {
      diagnostic.add(new BasicDiagnostic(Diagnostic.ERROR,null,0,resourceDiagnostic.getMessage(),new Object[]{resource}));
    }
    return diagnostic;
  }
 else {
    return super.getMarkerDiagnostics(object,file);
  }
}","/** 
 * @since 2.9
 */
@Override public Diagnostic getMarkerDiagnostics(Object object,IFile file){
  if (file == null) {
    file=getFile(object);
  }
  if (object instanceof Resource) {
    Resource resource=(Resource)object;
    EditingDomain editingDomain=AdapterFactoryEditingDomain.getEditingDomainFor(resource.getResourceSet());
    BasicDiagnostic diagnostic=new BasicDiagnostic(getDiagnosticSource(),0,null,new Object[]{resource});
    if (file != null && file.isAccessible()) {
      try {
        for (        IMarker marker : file.findMarkers(null,true,IResource.DEPTH_ZERO)) {
          String message=marker.getAttribute(IMarker.MESSAGE,""String_Node_Str"");
          int severity=marker.getAttribute(IMarker.SEVERITY,IMarker.SEVERITY_INFO);
          String sourceID=marker.getAttribute(IMarker.SOURCE_ID,""String_Node_Str"");
          List<?> data=getTargetObjects(editingDomain,marker);
          diagnostic.add(new BasicDiagnostic(severity == IMarker.SEVERITY_ERROR ? Diagnostic.ERROR : severity == IMarker.SEVERITY_WARNING ? Diagnostic.WARNING : Diagnostic.INFO,sourceID,0,message,data.toArray(new Object[data.size()])));
        }
      }
 catch (      CoreException exception) {
        CommonUIPlugin.INSTANCE.log(exception);
      }
    }
    for (    Resource.Diagnostic resourceDiagnostic : resource.getWarnings()) {
      diagnostic.add(new BasicDiagnostic(Diagnostic.WARNING,null,0,resourceDiagnostic.getMessage(),new Object[]{resource}));
    }
    for (    Resource.Diagnostic resourceDiagnostic : resource.getErrors()) {
      diagnostic.add(new BasicDiagnostic(Diagnostic.ERROR,null,0,resourceDiagnostic.getMessage(),new Object[]{resource}));
    }
    return diagnostic;
  }
 else {
    return super.getMarkerDiagnostics(object,file);
  }
}",0.993456614509246
11738,"public FragmentCache(XcoreResource xcoreResource){
  XcoreResource.this.eAdapters.add(this);
}","public FragmentCache(XcoreResource xcoreResource){
  XcoreResource.this.eAdapters().add(this);
}",0.9894736842105264
11739,"/** 
 * Merge the contents of to manifests.
 * @since 2.9
 */
protected String mergeManifest(String oldContents,String newContents){
  List<AttributeData> oldAttributes=getAttributeData(oldContents);
  List<AttributeData> newAttributes=getAttributeData(newContents);
  AttributeData oldBundleLocalization=getAttribute(oldAttributes,""String_Node_Str"");
  AttributeData newBundleLocalization=getAttribute(newAttributes,""String_Node_Str"");
  boolean mergeTranslatedAttributes=oldBundleLocalization == null || (newBundleLocalization != null && !newBundleLocalization.value.equals(oldBundleLocalization.value));
  for (int i=0, size=oldAttributes.size(); i < size; ++i) {
    AttributeData oldAttribute=oldAttributes.get(i);
    int index=newAttributes.indexOf(oldAttribute);
    if (index != -1) {
      AttributeData newAttribute=newAttributes.get(index);
      newAttribute.value=null;
      if (""String_Node_Str"".equals(oldAttribute.name) || ""String_Node_Str"".equals(oldAttribute.name)) {
        if (mergeTranslatedAttributes) {
          if (oldAttribute.elements == null) {
            oldAttribute.value=newAttribute.value;
          }
 else {
            oldAttribute.elements=newAttribute.elements;
          }
        }
      }
 else       if (""String_Node_Str"".equals(oldAttribute.name) || ""String_Node_Str"".equals(oldAttribute.name)) {
        if (oldAttribute.elements == null) {
          oldAttribute.value=newAttribute.value;
        }
 else {
          oldAttribute.elements=newAttribute.elements;
        }
      }
 else       if (""String_Node_Str"".equals(oldAttribute.name) || ""String_Node_Str"".equals(oldAttribute.name) || ""String_Node_Str"".equals(oldAttribute.name)) {
        if (newAttribute.elements != null) {
          if (oldAttribute.elements == null) {
            oldAttribute.value=newAttribute.value;
          }
 else {
            LOOP:             for (int j=0, elementSize=newAttribute.elements.size(); j < elementSize; ++j) {
              AttributeData.Element element=newAttribute.elements.get(j);
              int elementIndex=oldAttribute.elements.indexOf(element);
              if (elementIndex == -1) {
                for (int k=j - 1; k >= 0; --k) {
                  int targetIndex=oldAttribute.elements.indexOf(newAttribute.elements.get(k));
                  if (targetIndex != -1) {
                    oldAttribute.elements.add(targetIndex + 1,element);
                    continue LOOP;
                  }
                }
                for (int k=j + 1; k < elementSize; ++k) {
                  int targetIndex=oldAttribute.elements.indexOf(newAttribute.elements.get(k));
                  if (targetIndex != -1) {
                    oldAttribute.elements.add(targetIndex,element);
                    continue LOOP;
                  }
                }
                oldAttribute.elements.add(element);
              }
            }
          }
        }
 else {
          oldAttribute.value=newAttribute.value;
        }
      }
    }
  }
  LOOP:   for (int i=0, size=newAttributes.size(); i < size; ++i) {
    AttributeData newAttribute=newAttributes.get(i);
    if (newAttribute.value != null) {
      for (int j=i - 1; j >= 0; --j) {
        int index=oldAttributes.indexOf(newAttributes.get(j));
        if (index != -1) {
          AttributeData oldAttribute=oldAttributes.get(index);
          oldAttributes.add(index + 1,newAttribute);
          newAttribute.start=newAttribute.end=oldAttribute.end;
          continue LOOP;
        }
      }
      for (int j=i + 1; j < size; ++j) {
        int index=oldAttributes.indexOf(newAttributes.get(j));
        if (index != -1) {
          AttributeData oldAttribute=oldAttributes.get(index);
          oldAttributes.add(index,newAttribute);
          newAttribute.start=newAttribute.end=oldAttribute.start;
          continue LOOP;
        }
      }
      oldAttributes.add(newAttribute);
      newAttribute.start=newAttribute.end=oldAttributes.get(oldAttributes.size() - 1).end;
    }
  }
  StringBuilder result=new StringBuilder();
  int index=0;
  for (int i=0, size=oldAttributes.size(); i < size; ++i) {
    AttributeData oldAttribute=oldAttributes.get(i);
    result.append(oldContents.substring(index,oldAttribute.start));
    result.append(oldAttribute);
    result.append(oldAttribute.lineDelimiter);
    index=oldAttribute.end;
  }
  result.append(oldContents.substring(index));
  return result.toString();
}","/** 
 * Merge the contents of to manifests.
 * @since 2.9
 */
protected String mergeManifest(String oldContents,String newContents){
  List<AttributeData> oldAttributes=getAttributeData(oldContents);
  List<AttributeData> newAttributes=getAttributeData(newContents);
  AttributeData oldBundleLocalization=getAttribute(oldAttributes,""String_Node_Str"");
  AttributeData newBundleLocalization=getAttribute(newAttributes,""String_Node_Str"");
  boolean mergeTranslatedAttributes=oldBundleLocalization == null || (newBundleLocalization != null && !newBundleLocalization.value.equals(oldBundleLocalization.value));
  for (int i=0, size=oldAttributes.size(); i < size; ++i) {
    AttributeData oldAttribute=oldAttributes.get(i);
    int index=newAttributes.indexOf(oldAttribute);
    if (index != -1) {
      AttributeData newAttribute=newAttributes.get(index);
      if (""String_Node_Str"".equals(oldAttribute.name) || ""String_Node_Str"".equals(oldAttribute.name)) {
        if (mergeTranslatedAttributes) {
          if (oldAttribute.elements == null) {
            oldAttribute.value=newAttribute.value;
          }
 else {
            oldAttribute.elements=newAttribute.elements;
          }
        }
      }
 else       if (""String_Node_Str"".equals(oldAttribute.name) || ""String_Node_Str"".equals(oldAttribute.name)) {
        if (oldAttribute.elements == null) {
          oldAttribute.value=newAttribute.value;
        }
 else {
          oldAttribute.elements=newAttribute.elements;
        }
      }
 else       if (""String_Node_Str"".equals(oldAttribute.name) || ""String_Node_Str"".equals(oldAttribute.name) || ""String_Node_Str"".equals(oldAttribute.name)) {
        if (newAttribute.elements != null) {
          if (oldAttribute.elements == null) {
            oldAttribute.value=newAttribute.value;
          }
 else {
            LOOP:             for (int j=0, elementSize=newAttribute.elements.size(); j < elementSize; ++j) {
              AttributeData.Element element=newAttribute.elements.get(j);
              int elementIndex=oldAttribute.elements.indexOf(element);
              if (elementIndex == -1) {
                for (int k=j - 1; k >= 0; --k) {
                  int targetIndex=oldAttribute.elements.indexOf(newAttribute.elements.get(k));
                  if (targetIndex != -1) {
                    oldAttribute.elements.add(targetIndex + 1,element);
                    continue LOOP;
                  }
                }
                for (int k=j + 1; k < elementSize; ++k) {
                  int targetIndex=oldAttribute.elements.indexOf(newAttribute.elements.get(k));
                  if (targetIndex != -1) {
                    oldAttribute.elements.add(targetIndex,element);
                    continue LOOP;
                  }
                }
                oldAttribute.elements.add(element);
              }
            }
          }
        }
 else {
        }
      }
      newAttribute.value=null;
    }
  }
  LOOP:   for (int i=0, size=newAttributes.size(); i < size; ++i) {
    AttributeData newAttribute=newAttributes.get(i);
    if (newAttribute.value != null) {
      for (int j=i - 1; j >= 0; --j) {
        int index=oldAttributes.indexOf(newAttributes.get(j));
        if (index != -1) {
          AttributeData oldAttribute=oldAttributes.get(index);
          oldAttributes.add(index + 1,newAttribute);
          newAttribute.start=newAttribute.end=oldAttribute.end;
          continue LOOP;
        }
      }
      for (int j=i + 1; j < size; ++j) {
        int index=oldAttributes.indexOf(newAttributes.get(j));
        if (index != -1) {
          AttributeData oldAttribute=oldAttributes.get(index);
          oldAttributes.add(index,newAttribute);
          newAttribute.start=newAttribute.end=oldAttribute.start;
          continue LOOP;
        }
      }
      oldAttributes.add(newAttribute);
      newAttribute.start=newAttribute.end=oldAttributes.get(oldAttributes.size() - 1).end;
    }
  }
  StringBuilder result=new StringBuilder();
  int index=0;
  for (int i=0, size=oldAttributes.size(); i < size; ++i) {
    AttributeData oldAttribute=oldAttributes.get(i);
    result.append(oldContents.substring(index,oldAttribute.start));
    result.append(oldAttribute);
    result.append(oldAttribute.lineDelimiter);
    index=oldAttribute.end;
  }
  result.append(oldContents.substring(index));
  return result.toString();
}",0.9892253600998072
11740,"public Map<GenPackage,Map<GenClass,List<GenClass.ChildCreationData>>> getExtendedChildCreationData(){
  GenModel genModel=getGenModel();
  Map<GenPackage,Map<GenClass,List<GenClass.ChildCreationData>>> result=new LinkedHashMap<GenPackage,Map<GenClass,List<GenClass.ChildCreationData>>>();
  List<GenPackage> allUsedGenPackagesWithClassifiers=getGenModel().getAllUsedGenPackagesWithClassifiers();
  for (  GenPackage genPackage : allUsedGenPackagesWithClassifiers) {
    for (    GenClass genClass : genPackage.getGenClasses()) {
      List<GenClass.ChildCreationData> allChildCreationData=genClass.getChildCreationData(genModel);
      for (      GenClass.ChildCreationData childCreationData : allChildCreationData) {
        if (childCreationData.delegatedFeature != null && childCreationData.delegatedFeature.getGenPackage() == this || childCreationData.createClassifier.getGenPackage() == this && (childCreationData.delegatedFeature == null || allUsedGenPackagesWithClassifiers.contains(childCreationData.delegatedFeature.getGenPackage()))) {
          GenClass featureClass=childCreationData.createFeature.getGenClass();
          GenPackage featureGenPackage=featureClass.getGenPackage();
          Map<GenClass,List<GenClass.ChildCreationData>> map=result.get(featureGenPackage);
          if (map == null) {
            result.put(featureGenPackage,map=new LinkedHashMap<GenClass,List<GenClass.ChildCreationData>>());
          }
          List<GenClass.ChildCreationData> data=map.get(featureClass);
          if (data == null) {
            map.put(featureClass,data=new UniqueEList<GenClass.ChildCreationData>());
          }
          data.add(childCreationData);
        }
      }
    }
  }
  return result;
}","public Map<GenPackage,Map<GenClass,List<GenClass.ChildCreationData>>> getExtendedChildCreationData(){
  GenModel genModel=getGenModel();
  Map<GenPackage,Map<GenClass,List<GenClass.ChildCreationData>>> result=new LinkedHashMap<GenPackage,Map<GenClass,List<GenClass.ChildCreationData>>>();
  List<GenPackage> allUsedGenPackagesWithClassifiers=getGenModel().getAllUsedGenPackagesWithClassifiers();
  for (  GenPackage genPackage : allUsedGenPackagesWithClassifiers) {
    for (    GenClass genClass : genPackage.getGenClasses()) {
      List<GenClass.ChildCreationData> allChildCreationData=genClass.getChildCreationData(genModel);
      for (      GenClass.ChildCreationData childCreationData : allChildCreationData) {
        if (childCreationData.delegatedFeature != null && childCreationData.delegatedFeature.getGenPackage() == this || childCreationData.createClassifier.getGenPackage() == this && (childCreationData.delegatedFeature == null || allUsedGenPackagesWithClassifiers.contains(childCreationData.delegatedFeature.getGenPackage()))) {
          GenClass featureClass=childCreationData.createFeature.getGenClass();
          GenPackage featureGenPackage=featureClass.getGenPackage();
          if (genPackage != featureGenPackage) {
            GenClass baseGenClass=genClass.getBaseGenClass();
            if (baseGenClass != null && !baseGenClass.getAllGenFeatures().contains(childCreationData.createFeature)) {
              Map<GenClass,List<GenClass.ChildCreationData>> map=result.get(genPackage);
              if (map == null) {
                result.put(genPackage,map=new LinkedHashMap<GenClass,List<GenClass.ChildCreationData>>());
              }
              List<GenClass.ChildCreationData> data=map.get(featureClass);
              if (data == null) {
                map.put(featureClass,data=new UniqueEList<GenClass.ChildCreationData>());
              }
              data.add(childCreationData);
            }
          }
          Map<GenClass,List<GenClass.ChildCreationData>> map=result.get(featureGenPackage);
          if (map == null) {
            result.put(featureGenPackage,map=new LinkedHashMap<GenClass,List<GenClass.ChildCreationData>>());
          }
          List<GenClass.ChildCreationData> data=map.get(featureClass);
          if (data == null) {
            map.put(featureClass,data=new UniqueEList<GenClass.ChildCreationData>());
          }
          data.add(childCreationData);
        }
      }
    }
  }
  return result;
}",0.7945727207807665
11741,"public final boolean validateEOperationSignatures(EClass eClass,EList<EOperation> eOperations,Collection<EOperation> otherEOperations,DiagnosticChain diagnostics,Map<Object,Object> context){
  boolean result=true;
  for (  EOperation eOperation : eOperations) {
    if (!ignoreOperationsWithSuppressedVisibility || !EcoreUtil.isSuppressedVisibility(eOperation)) {
      String name=eOperation.getName();
      if (name != null) {
        EList<EParameter> eParameters=eOperation.getEParameters();
        int eParameterSize=eParameters.size();
        LOOP:         for (        EOperation otherEOperation : otherEOperations) {
          if (otherEOperation == eOperation) {
            break;
          }
 else {
            String otherName=otherEOperation.getName();
            if (name.equals(otherName)) {
              EList<EParameter> otherEParmeters=otherEOperation.getEParameters();
              if (otherEParmeters.size() == eParameterSize) {
                for (int i=0; i < eParameterSize; ++i) {
                  EParameter eParameter=eParameters.get(i);
                  EParameter otherEParameter=otherEParmeters.get(i);
                  EClassifier eType=eParameter.getEType();
                  EClassifier otherEType=otherEParameter.getEType();
                  if (eType != otherEType) {
                    if (eType != null && otherEType != null) {
                      String instanceClassName=eType.getInstanceClassName();
                      String otherInstanceClassName=otherEType.getInstanceClassName();
                      if (instanceClassName != otherInstanceClassName || instanceClassName == null || eParameter.isMany() != otherEParameter.isMany()) {
                        continue LOOP;
                      }
                    }
 else {
                      continue LOOP;
                    }
                  }
 else                   if (eParameter.isMany() != otherEParameter.isMany()) {
                    continue LOOP;
                  }
                }
                if (diagnostics == null) {
                  return false;
                }
 else {
                  result=false;
                  diagnostics.add(createDiagnostic(Diagnostic.ERROR,DIAGNOSTIC_SOURCE,messageCode,messageKey,new Object[]{getObjectLabel(getTarget(otherEOperation),context),getObjectLabel(eOperation,context)},new Object[]{eClass,getTarget(otherEOperation),eOperation,EcorePackage.Literals.ECLASS__EALL_OPERATIONS},context));
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}","public final boolean validateEOperationSignatures(EClass eClass,EList<EOperation> eOperations,Collection<EOperation> otherEOperations,DiagnosticChain diagnostics,Map<Object,Object> context){
  boolean result=true;
  for (  EOperation eOperation : eOperations) {
    if (!ignoreOperationsWithSuppressedVisibility || !EcoreUtil.isSuppressedVisibility(eOperation)) {
      String name=eOperation.getName();
      if (name != null) {
        EList<EParameter> eParameters=eOperation.getEParameters();
        int eParameterSize=eParameters.size();
        LOOP:         for (        EOperation otherEOperation : otherEOperations) {
          if (otherEOperation == eOperation) {
            break;
          }
 else {
            String otherName=otherEOperation.getName();
            if (name.equals(otherName)) {
              EList<EParameter> otherEParmeters=otherEOperation.getEParameters();
              if (otherEParmeters.size() == eParameterSize) {
                for (int i=0; i < eParameterSize; ++i) {
                  EParameter eParameter=eParameters.get(i);
                  EParameter otherEParameter=otherEParmeters.get(i);
                  EClassifier eType=eParameter.getEType();
                  EClassifier otherEType=otherEParameter.getEType();
                  if (eType != otherEType) {
                    if (eType != null && otherEType != null) {
                      String instanceClassName=eType.getInstanceClassName();
                      String otherInstanceClassName=otherEType.getInstanceClassName();
                      if (instanceClassName != otherInstanceClassName || instanceClassName == null || eParameter.isMany() != otherEParameter.isMany()) {
                        continue LOOP;
                      }
                    }
 else {
                      continue LOOP;
                    }
                  }
 else                   if (eParameter.isMany() != otherEParameter.isMany()) {
                    continue LOOP;
                  }
                }
                if (diagnostics == null) {
                  return false;
                }
 else {
                  result=false;
                  EModelElement target=getTarget(otherEOperation);
                  diagnostics.add(createDiagnostic(Diagnostic.ERROR,DIAGNOSTIC_SOURCE,messageCode,messageKey,messageCode == DISJOINT_FEATURE_AND_OPERATION_SIGNATURES ? new Object[]{getObjectLabel(eOperation,context),getObjectLabel(target,context)} : new Object[]{getObjectLabel(target,context),getObjectLabel(eOperation,context)},messageCode == DISJOINT_FEATURE_AND_OPERATION_SIGNATURES ? new Object[]{eClass,eOperation,target,EcorePackage.Literals.ECLASS__EALL_OPERATIONS} : new Object[]{eClass,target,eOperation,EcorePackage.Literals.ECLASS__EALL_OPERATIONS},context));
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}",0.916058394160584
11742,"private static void computeModels(Map<URI,URI> pluginMap,Map<String,URI> nsURIMap){
  IWorkspaceRoot root=getWorkspaceRoot();
  Object[] activeModels=(Object[])invoke(null,PLUGIN_REGISTRY_GET_ACTIVE_MODELS_METHOD,Boolean.FALSE);
  LOOP:   for (  Object activeModel : activeModels) {
    Object bundleDescription=invoke(activeModel,PLUGIN_MODEL_BASE_GET_BUNDLE_DESCRIPTION_METHOD);
    String symbolicName=(String)invoke(bundleDescription,BUNDLE_DESCRIPTION_GET_SYMBOLIC_NAME_METHOD);
    IResource underlyingResource=(IResource)invoke(activeModel,PLUGIN_MODEL_BASE_GET_UNDERLYING_RESOURCE_METHOD);
    String installLocation=(String)invoke(activeModel,PLUGIN_MODEL_BASE_GET_INSTALL_LOCATION_METHOD);
    URI location=null;
    if (underlyingResource != null) {
      location=URI.createPlatformResourceURI(underlyingResource.getFullPath().toString(),true);
    }
 else     if (installLocation != null) {
      File file=new File(installLocation);
      if (file.isDirectory()) {
        location=URI.createFileURI(installLocation);
      }
 else {
        location=URI.createURI(""String_Node_Str"" + URI.createFileURI(installLocation) + ""String_Node_Str"");
      }
    }
    if (location != null) {
      URI logicalLocation=null;
      Object extensions=invoke(activeModel,PLUGIN_MODEL_BASE_GET_EXTENSIONS_METHOD);
      Object[] pluginExtensions=(Object[])invoke(extensions,EXTENSIONS_GET_EXTENSIONS_METHOD);
      for (      Object pluginExtension : pluginExtensions) {
        String point=(String)invoke(pluginExtension,PLUGIN_EXTENSION_GET_POINT_METHOD);
        if (""String_Node_Str"".equals(point)) {
          Object[] children=(Object[])invoke(pluginExtension,PLUGIN_EXTENSION_GET_CHILDREN_METHOD);
          for (          Object child : children) {
            if (PLUGIN_ELEMENT_CLASS.isInstance(child)) {
              Object uri=invoke(child,PLUGIN_ELEMENT_GET_ATTRIBUTE_METHOD,""String_Node_Str"");
              Object genModel=invoke(child,PLUGIN_ELEMENT_GET_ATTRIBUTE_METHOD,""String_Node_Str"");
              if (uri != null && genModel != null) {
                if (logicalLocation == null) {
                  URI platformPluginURI=URI.createPlatformPluginURI(symbolicName,true).appendSegment(""String_Node_Str"");
                  if (location.isPlatformResource()) {
                    if (pluginMap != null) {
                      pluginMap.put(platformPluginURI,location.appendSegment(""String_Node_Str""));
                    }
                    logicalLocation=location;
                  }
 else {
                    logicalLocation=URI.createPlatformResourceURI(symbolicName,true);
                    URI resourceURI=logicalLocation.appendSegment(""String_Node_Str"");
                    boolean exists=root.getProject(symbolicName).isAccessible();
                    if (pluginMap != null) {
                      if (location.isFile()) {
                        pluginMap.put(platformPluginURI,location.appendSegment(""String_Node_Str""));
                        if (!exists) {
                          pluginMap.put(resourceURI,location.appendSegment(""String_Node_Str""));
                        }
                      }
 else {
                        pluginMap.put(platformPluginURI,location);
                        if (!exists) {
                          pluginMap.put(resourceURI,location);
                        }
                      }
                    }
                  }
                }
                if (nsURIMap == null) {
                  continue LOOP;
                }
                nsURIMap.put((String)invoke(uri,PLUGIN_ATTRIBUTE_GET_VALUE_METHOD),logicalLocation.appendSegments(new Path((String)invoke(genModel,PLUGIN_ATTRIBUTE_GET_VALUE_METHOD)).segments()));
              }
            }
          }
        }
      }
    }
  }
}","private static void computeModels(Map<URI,URI> pluginMap,Map<String,URI> nsURIMap){
  IWorkspaceRoot root=getWorkspaceRoot();
  Object[] activeModels=(Object[])invoke(null,PLUGIN_REGISTRY_GET_ACTIVE_MODELS_METHOD,Boolean.FALSE);
  LOOP:   for (  Object activeModel : activeModels) {
    Object bundleDescription=invoke(activeModel,PLUGIN_MODEL_BASE_GET_BUNDLE_DESCRIPTION_METHOD);
    String symbolicName=(String)invoke(bundleDescription,BUNDLE_DESCRIPTION_GET_SYMBOLIC_NAME_METHOD);
    IResource underlyingResource=(IResource)invoke(activeModel,PLUGIN_MODEL_BASE_GET_UNDERLYING_RESOURCE_METHOD);
    String installLocation=(String)invoke(activeModel,PLUGIN_MODEL_BASE_GET_INSTALL_LOCATION_METHOD);
    URI location=null;
    if (underlyingResource != null) {
      location=URI.createPlatformResourceURI(underlyingResource.getProject().getFullPath().toString(),true);
    }
 else     if (installLocation != null) {
      File file=new File(installLocation);
      if (file.isDirectory()) {
        location=URI.createFileURI(installLocation);
      }
 else {
        location=URI.createURI(""String_Node_Str"" + URI.createFileURI(installLocation) + ""String_Node_Str"");
      }
    }
    if (location != null) {
      URI logicalLocation=null;
      Object extensions=invoke(activeModel,PLUGIN_MODEL_BASE_GET_EXTENSIONS_METHOD);
      Object[] pluginExtensions=(Object[])invoke(extensions,EXTENSIONS_GET_EXTENSIONS_METHOD);
      for (      Object pluginExtension : pluginExtensions) {
        String point=(String)invoke(pluginExtension,PLUGIN_EXTENSION_GET_POINT_METHOD);
        if (""String_Node_Str"".equals(point)) {
          Object[] children=(Object[])invoke(pluginExtension,PLUGIN_EXTENSION_GET_CHILDREN_METHOD);
          for (          Object child : children) {
            if (PLUGIN_ELEMENT_CLASS.isInstance(child)) {
              Object uri=invoke(child,PLUGIN_ELEMENT_GET_ATTRIBUTE_METHOD,""String_Node_Str"");
              Object genModel=invoke(child,PLUGIN_ELEMENT_GET_ATTRIBUTE_METHOD,""String_Node_Str"");
              if (uri != null && genModel != null) {
                if (logicalLocation == null) {
                  URI platformPluginURI=URI.createPlatformPluginURI(symbolicName,true).appendSegment(""String_Node_Str"");
                  if (location.isPlatformResource()) {
                    if (pluginMap != null) {
                      pluginMap.put(platformPluginURI,location.appendSegment(""String_Node_Str""));
                    }
                    logicalLocation=location;
                  }
 else {
                    logicalLocation=URI.createPlatformResourceURI(symbolicName,true);
                    URI resourceURI=logicalLocation.appendSegment(""String_Node_Str"");
                    boolean exists=root.getProject(symbolicName).isAccessible();
                    if (pluginMap != null) {
                      if (location.isFile()) {
                        pluginMap.put(platformPluginURI,location.appendSegment(""String_Node_Str""));
                        if (!exists) {
                          pluginMap.put(resourceURI,location.appendSegment(""String_Node_Str""));
                        }
                      }
 else {
                        pluginMap.put(platformPluginURI,location);
                        if (!exists) {
                          pluginMap.put(resourceURI,location);
                        }
                      }
                    }
                  }
                }
                if (nsURIMap == null) {
                  continue LOOP;
                }
                nsURIMap.put((String)invoke(uri,PLUGIN_ATTRIBUTE_GET_VALUE_METHOD),logicalLocation.appendSegments(new Path((String)invoke(genModel,PLUGIN_ATTRIBUTE_GET_VALUE_METHOD)).segments()));
              }
            }
          }
        }
      }
    }
  }
}",0.9982928430728824
11743,"@Override protected Multimap<Class<?>,Class<?>> simpleComputeExtensionClasses(){
  Multimap<Class<?>,Class<?>> result=super.simpleComputeExtensionClasses();
  result.put(Iterable.class,ECollections.class);
  result.put(Iterable.class,XcoreIterableExtensions.class);
  result.put(Iterator.class,ECollections.class);
  result.put(List.class,ECollections.class);
  result.put(EMap.class,ECollections.class);
  result.put(EList.class,ECollections.class);
  result.put(EList.class,XcoreEListExtensions.class);
  result.put(EObject.class,EcoreUtil.class);
  result.put(EClass.class,EcoreUtil.class);
  result.put(EDataType.class,EcoreUtil.class);
  result.put(EModelElement.class,EcoreUtil.class);
  result.put(EGenericType.class,EcoreUtil.class);
  result.put(Notifier.class,EcoreUtil.class);
  result.put(Resource.class,EcoreUtil.class);
  result.put(ResourceSet.class,EcoreUtil.class);
  return result;
}","@Override protected Multimap<Class<?>,Class<?>> simpleComputeExtensionClasses(){
  Multimap<Class<?>,Class<?>> result=super.simpleComputeExtensionClasses();
  result.put(Object.class,XcoreObjectsExtensions.class);
  result.put(Iterable.class,ECollections.class);
  result.put(Iterable.class,XcoreIterableExtensions.class);
  result.put(Iterator.class,ECollections.class);
  result.put(List.class,ECollections.class);
  result.put(EMap.class,ECollections.class);
  result.put(EList.class,ECollections.class);
  result.put(EList.class,XcoreEListExtensions.class);
  result.put(EObject.class,EcoreUtil.class);
  result.put(EClass.class,EcoreUtil.class);
  result.put(EDataType.class,EcoreUtil.class);
  result.put(EModelElement.class,EcoreUtil.class);
  result.put(EGenericType.class,EcoreUtil.class);
  result.put(Notifier.class,EcoreUtil.class);
  result.put(Resource.class,EcoreUtil.class);
  result.put(ResourceSet.class,EcoreUtil.class);
  return result;
}",0.5938676707907478
11744,"@Override protected Diagnostic doExport(Monitor monitor,ModelExporter.ExportData exportData) throws Exception {
  for (  Map.Entry<GenPackage,URI> entry : exportData.genPackageToArtifactURI.entrySet()) {
    GenPackage genPackage=entry.getKey();
    URI xcoreLocationURI=entry.getValue();
    IFile xcoreFile=ResourcesPlugin.getWorkspace().getRoot().getFile(new Path(xcoreLocationURI.toPlatformString(true)));
    final IProject xcoreProject=xcoreFile.getProject();
    if (xcoreProject.isAccessible()) {
      if (!xcoreProject.hasNature(XtextProjectHelper.NATURE_ID)) {
        IProjectDescription description=xcoreProject.getDescription();
        String[] natures=description.getNatureIds();
        String[] newNatures=new String[natures.length + 1];
        System.arraycopy(natures,0,newNatures,0,natures.length);
        newNatures[natures.length]=XtextProjectHelper.NATURE_ID;
        description.setNatureIds(newNatures);
        xcoreProject.setDescription(description,null);
      }
    }
    ResourceSet resourceSet=new ResourceSetImpl();
    resourceSet.getURIConverter().getURIMap().putAll(EcorePlugin.computePlatformURIMap());
    GenModel inputGenModel=(GenModel)resourceSet.getEObject(EcoreUtil.getURI(getGenModel()),true);
    inputGenModel.reconcile();
    Resource inputResource=inputGenModel.eResource();
    Resource outputResource=resourceSet.createResource(xcoreLocationURI);
    GenModel genModel=GenModelFactory.eINSTANCE.createGenModel();
    List<EPackage> ePackageClones=new ArrayList<EPackage>();
    for (    GenPackage inputGenPackage : inputGenModel.getGenPackages()) {
      ePackageClones.add(inputGenPackage.getEcorePackage());
    }
    genModel.initialize(ePackageClones);
    inputResource.getContents().add(genModel);
    genModelInitializer.initialize(genModel,true);
    final GenPackage inputGenPackage=(GenPackage)resourceSet.getEObject(EcoreUtil.getURI(genPackage),true);
    new Object(){
      void visit(      GenBase genBase1,      GenBase genBase2){
        if (genBase1.eClass() == genBase2.eClass()) {
          for (          EAttribute eAttribute : genBase1.eClass().getEAllAttributes()) {
            if (!eAttribute.isMany() && genBase1.eIsSet(eAttribute)) {
              Object value1=genBase1.eGet(eAttribute);
              Object value2=genBase2.eGet(eAttribute);
              if (value1 == null ? value2 != null : !value1.equals(value2)) {
                EModelElement eModelElement=genBase2.getEcoreModelElement();
                if (eModelElement == null && genBase2 instanceof GenModel) {
                  eModelElement=inputGenPackage.getEcorePackage();
                }
                EcoreUtil.setAnnotation(eModelElement,GenModelPackage.eNS_URI,eAttribute.getName(),EcoreUtil.convertToString(eAttribute.getEAttributeType(),value1));
              }
              for (Iterator<EObject> i=genBase1.eContents().iterator(), j=genBase2.eContents().iterator(); i.hasNext() && j.hasNext(); ) {
                EObject content1=i.next();
                EObject content2=j.next();
                if (content1 instanceof GenBase && content2 instanceof GenBase) {
                  visit((GenBase)content1,(GenBase)content2);
                }
              }
            }
          }
        }
      }
    }
.visit(inputGenModel,genModel);
    EcoreXcoreBuilder ecoreXcoreBuilder=ecoreXcoreBuilderProvider.get();
    ecoreXcoreBuilder.initialize(inputGenModel);
    XPackage xPackage=ecoreXcoreBuilder.getXPackage(inputGenPackage.getEcorePackage());
    outputResource.getContents().add(xPackage);
    outputResource.getContents().add(inputGenModel);
    outputResource.getContents().add(inputGenPackage.getEcorePackage());
    GenPackage ecoreGenPackage=inputGenModel.getEcoreGenPackage();
    if (ecoreGenPackage != null) {
      Resource ecoreResource=resourceSet.createResource(URI.createURI(""String_Node_Str""));
      ecoreResource.getContents().add(ecoreGenPackage.getGenModel());
    }
    GenPackage xmlTypeGenPackage=inputGenModel.getXMLTypeGenPackage();
    if (xmlTypeGenPackage != null) {
      Resource xmlTypeResource=resourceSet.createResource(URI.createURI(""String_Node_Str""));
      xmlTypeResource.getContents().add(xmlTypeGenPackage.getGenModel());
    }
    GenPackage xmlNamespaceGenPackage=inputGenModel.getXMLNamespaceGenPackage();
    if (xmlNamespaceGenPackage != null) {
      Resource xmlNamespaceResource=resourceSet.createResource(URI.createURI(""String_Node_Str""));
      xmlNamespaceResource.getContents().add(xmlNamespaceGenPackage.getGenModel());
    }
    ecoreXcoreBuilder.link();
    genModelBuilder.buildMap(inputGenModel);
    ImportManager importManager=new ImportManager(inputGenPackage.getInterfacePackageName()){
      @Override protected boolean shouldImport(      String packageName,      String shortName,      String importName){
        return true;
      }
    }
;
    Map<EGenericType,XGenericType> genericTypeMap=ecoreXcoreBuilder.getGenericTypeMap();
    for (TreeIterator<EObject> i=inputGenPackage.getEcorePackage().eAllContents(); i.hasNext(); ) {
      EObject eObject=i.next();
      if (eObject instanceof EGenericType) {
        EGenericType eGenericType=(EGenericType)eObject;
        EClassifier eClassifier=eGenericType.getEClassifier();
        if (eClassifier != null) {
          GenClassifier genClassifier=inputGenModel.findGenClassifier(eClassifier);
          QualifiedName qualifiedName=qualifiedNameProvider.getFullyQualifiedName(genClassifier);
          String qualifiedNameValue=qualifiedNameConverter.toString(qualifiedName);
          if (!IMPLICIT_ALIASES.contains(qualifiedNameValue)) {
            importManager.addImport(qualifiedNameValue);
          }
          XGenericType xGenericType=genericTypeMap.get(eGenericType);
          IScope scope=scopeProvider.getScope(xGenericType,XcorePackage.Literals.XGENERIC_TYPE__TYPE);
          IEObjectDescription genClassifierDescription=scope.getSingleElement(qualifiedName);
          if (genClassifierDescription != null) {
            EObject resolvedGenClassifier=resourceSet.getEObject(genClassifierDescription.getEObjectURI(),true);
            if (resolvedGenClassifier != null && resolvedGenClassifier != genClassifier) {
              xGenericType.setType((GenClassifier)resolvedGenClassifier);
            }
          }
        }
      }
 else       if (eObject instanceof EReference) {
        EReference eReference=(EReference)eObject;
        XReference xReference=(XReference)mapper.getToXcoreMapping(eReference).getXcoreElement();
        EList<GenFeature> keys=xReference.getKeys();
        GenFeature opposite=xReference.getOpposite();
        if (opposite != null) {
          IScope scope=scopeProvider.getScope(xReference,XcorePackage.Literals.XREFERENCE__OPPOSITE);
          IEObjectDescription genFeatureDescription=scope.getSingleElement(QualifiedName.create(opposite.getName()));
          if (genFeatureDescription != null) {
            EObject resolvedGenFeature=resourceSet.getEObject(genFeatureDescription.getEObjectURI(),true);
            if (resolvedGenFeature != null) {
              xReference.setOpposite((GenFeature)resolvedGenFeature);
            }
          }
        }
        if (!keys.isEmpty()) {
          IScope scope=scopeProvider.getScope(xReference,XcorePackage.Literals.XREFERENCE__KEYS);
          for (ListIterator<GenFeature> k=keys.listIterator(); k.hasNext(); ) {
            GenFeature key=k.next();
            IEObjectDescription genFeatureDescription=scope.getSingleElement(QualifiedName.create(key.getName()));
            if (genFeatureDescription != null) {
              EObject resolvedGenFeature=resourceSet.getEObject(genFeatureDescription.getEObjectURI(),true);
              if (resolvedGenFeature != null) {
                k.set((GenFeature)resolvedGenFeature);
              }
            }
          }
        }
      }
 else       if (eObject instanceof EPackage) {
        i.prune();
      }
    }
    for (    String qualifiedName : importManager.getImports()) {
      XImportDirective xImportDirective=XcoreFactory.eINSTANCE.createXImportDirective();
      xImportDirective.setImportedNamespace(qualifiedName);
      xPackage.getImportDirectives().add(xImportDirective);
    }
    Map<Object,Object> options=new HashMap<Object,Object>();
    SaveOptions.newBuilder().format().noValidation().getOptions().addTo(options);
    outputResource.save(options);
  }
  return Diagnostic.OK_INSTANCE;
}","@Override protected Diagnostic doExport(Monitor monitor,ModelExporter.ExportData exportData) throws Exception {
  for (  Map.Entry<GenPackage,URI> entry : exportData.genPackageToArtifactURI.entrySet()) {
    GenPackage genPackage=entry.getKey();
    URI xcoreLocationURI=entry.getValue();
    IFile xcoreFile=ResourcesPlugin.getWorkspace().getRoot().getFile(new Path(xcoreLocationURI.toPlatformString(true)));
    final IProject xcoreProject=xcoreFile.getProject();
    if (xcoreProject.isAccessible()) {
      if (!xcoreProject.hasNature(XtextProjectHelper.NATURE_ID)) {
        IProjectDescription description=xcoreProject.getDescription();
        String[] natures=description.getNatureIds();
        String[] newNatures=new String[natures.length + 1];
        System.arraycopy(natures,0,newNatures,0,natures.length);
        newNatures[natures.length]=XtextProjectHelper.NATURE_ID;
        description.setNatureIds(newNatures);
        xcoreProject.setDescription(description,null);
      }
    }
    ResourceSet resourceSet=new ResourceSetImpl();
    resourceSet.getURIConverter().getURIMap().putAll(EcorePlugin.computePlatformURIMap());
    GenModel inputGenModel=(GenModel)resourceSet.getEObject(EcoreUtil.getURI(getGenModel()),true);
    inputGenModel.reconcile();
    Resource inputResource=inputGenModel.eResource();
    final Resource outputResource=resourceSet.createResource(xcoreLocationURI);
    GenModel genModel=GenModelFactory.eINSTANCE.createGenModel();
    List<EPackage> ePackageClones=new ArrayList<EPackage>();
    for (    GenPackage inputGenPackage : inputGenModel.getGenPackages()) {
      ePackageClones.add(inputGenPackage.getEcorePackage());
    }
    genModel.initialize(ePackageClones);
    inputResource.getContents().add(genModel);
    genModelInitializer.initialize(genModel,true);
    final GenPackage inputGenPackage=(GenPackage)resourceSet.getEObject(EcoreUtil.getURI(genPackage),true);
    new Object(){
      void visit(      GenBase genBase1,      GenBase genBase2){
        if (genBase1.eClass() == genBase2.eClass()) {
          for (          EAttribute eAttribute : genBase1.eClass().getEAllAttributes()) {
            if (!eAttribute.isMany() && genBase1.eIsSet(eAttribute)) {
              Object value1=genBase1.eGet(eAttribute);
              Object value2=genBase2.eGet(eAttribute);
              if (value1 == null ? value2 != null : !value1.equals(value2)) {
                EModelElement eModelElement=genBase2.getEcoreModelElement();
                if (eModelElement == null && genBase2 instanceof GenModel) {
                  eModelElement=inputGenPackage.getEcorePackage();
                }
                EcoreUtil.setAnnotation(eModelElement,GenModelPackage.eNS_URI,eAttribute.getName(),EcoreUtil.convertToString(eAttribute.getEAttributeType(),value1));
              }
              for (Iterator<EObject> i=genBase1.eContents().iterator(), j=genBase2.eContents().iterator(); i.hasNext() && j.hasNext(); ) {
                EObject content1=i.next();
                EObject content2=j.next();
                if (content1 instanceof GenBase && content2 instanceof GenBase) {
                  visit((GenBase)content1,(GenBase)content2);
                }
              }
            }
          }
        }
      }
    }
.visit(inputGenModel,genModel);
    EcoreXcoreBuilder ecoreXcoreBuilder=ecoreXcoreBuilderProvider.get();
    ecoreXcoreBuilder.initialize(inputGenModel);
    XPackage xPackage=ecoreXcoreBuilder.getXPackage(inputGenPackage.getEcorePackage());
    outputResource.getContents().add(xPackage);
    outputResource.getContents().add(inputGenModel);
    outputResource.getContents().add(inputGenPackage.getEcorePackage());
    GenPackage ecoreGenPackage=inputGenModel.getEcoreGenPackage();
    if (ecoreGenPackage != null) {
      Resource ecoreResource=resourceSet.createResource(URI.createPlatformResourceURI(""String_Node_Str"",false));
      ecoreResource.getContents().add(ecoreGenPackage.getGenModel());
    }
    GenPackage xmlTypeGenPackage=inputGenModel.getXMLTypeGenPackage();
    if (xmlTypeGenPackage != null) {
      Resource xmlTypeResource=resourceSet.createResource(URI.createPlatformResourceURI(""String_Node_Str"",false));
      xmlTypeResource.getContents().add(xmlTypeGenPackage.getGenModel());
    }
    GenPackage xmlNamespaceGenPackage=inputGenModel.getXMLNamespaceGenPackage();
    if (xmlNamespaceGenPackage != null) {
      Resource xmlNamespaceResource=resourceSet.createResource(URI.createPlatformResourceURI(""String_Node_Str"",false));
      xmlNamespaceResource.getContents().add(xmlNamespaceGenPackage.getGenModel());
    }
    resourceSet.getURIConverter().getURIMap().remove(URI.createPlatformResourceURI(""String_Node_Str"",false));
    ecoreXcoreBuilder.link();
    genModelBuilder.buildMap(inputGenModel);
    ImportManager importManager=new ImportManager(inputGenPackage.getInterfacePackageName()){
      @Override protected boolean shouldImport(      String packageName,      String shortName,      String importName){
        return true;
      }
    }
;
    Map<EGenericType,XGenericType> genericTypeMap=ecoreXcoreBuilder.getGenericTypeMap();
    for (TreeIterator<EObject> i=inputGenPackage.getEcorePackage().eAllContents(); i.hasNext(); ) {
      EObject eObject=i.next();
      if (eObject instanceof EGenericType) {
        EGenericType eGenericType=(EGenericType)eObject;
        EClassifier eClassifier=eGenericType.getEClassifier();
        if (eClassifier != null) {
          GenClassifier genClassifier=inputGenModel.findGenClassifier(eClassifier);
          QualifiedName qualifiedName=qualifiedNameProvider.getFullyQualifiedName(genClassifier);
          String qualifiedNameValue=qualifiedNameConverter.toString(qualifiedName);
          if (!IMPLICIT_ALIASES.contains(qualifiedNameValue)) {
            importManager.addImport(qualifiedNameValue);
          }
          XGenericType xGenericType=genericTypeMap.get(eGenericType);
          IScope scope=scopeProvider.getScope(xGenericType,XcorePackage.Literals.XGENERIC_TYPE__TYPE);
          IEObjectDescription genClassifierDescription=scope.getSingleElement(qualifiedName);
          if (genClassifierDescription != null) {
            EObject resolvedGenClassifier=resourceSet.getEObject(genClassifierDescription.getEObjectURI(),true);
            if (resolvedGenClassifier != null && resolvedGenClassifier != genClassifier) {
              xGenericType.setType((GenClassifier)resolvedGenClassifier);
            }
          }
        }
      }
 else       if (eObject instanceof EReference) {
        EReference eReference=(EReference)eObject;
        XReference xReference=(XReference)mapper.getToXcoreMapping(eReference).getXcoreElement();
        EList<GenFeature> keys=xReference.getKeys();
        GenFeature opposite=xReference.getOpposite();
        if (opposite != null) {
          IScope scope=scopeProvider.getScope(xReference,XcorePackage.Literals.XREFERENCE__OPPOSITE);
          IEObjectDescription genFeatureDescription=scope.getSingleElement(QualifiedName.create(opposite.getName()));
          if (genFeatureDescription != null) {
            EObject resolvedGenFeature=resourceSet.getEObject(genFeatureDescription.getEObjectURI(),true);
            if (resolvedGenFeature != null) {
              xReference.setOpposite((GenFeature)resolvedGenFeature);
            }
          }
        }
        if (!keys.isEmpty()) {
          IScope scope=scopeProvider.getScope(xReference,XcorePackage.Literals.XREFERENCE__KEYS);
          for (ListIterator<GenFeature> k=keys.listIterator(); k.hasNext(); ) {
            GenFeature key=k.next();
            IEObjectDescription genFeatureDescription=scope.getSingleElement(QualifiedName.create(key.getName()));
            if (genFeatureDescription != null) {
              EObject resolvedGenFeature=resourceSet.getEObject(genFeatureDescription.getEObjectURI(),true);
              if (resolvedGenFeature != null) {
                k.set((GenFeature)resolvedGenFeature);
              }
            }
          }
        }
      }
 else       if (eObject instanceof EPackage) {
        i.prune();
      }
    }
    for (    String qualifiedName : importManager.getImports()) {
      XImportDirective xImportDirective=XcoreFactory.eINSTANCE.createXImportDirective();
      xImportDirective.setImportedNamespace(qualifiedName);
      xPackage.getImportDirectives().add(xImportDirective);
    }
    final Map<Object,Object> options=new HashMap<Object,Object>();
    SaveOptions.newBuilder().format().noValidation().getOptions().addTo(options);
    Job job=new Job(""String_Node_Str""){
      @Override protected IStatus run(      IProgressMonitor monitor){
        try {
          outputResource.save(options);
        }
 catch (        IOException exception) {
          return Status.CANCEL_STATUS;
        }
        return Status.OK_STATUS;
      }
    }
;
    job.schedule();
  }
  return Diagnostic.OK_INSTANCE;
}",0.9719733517114634
11745,"@Override protected Multimap<Class<?>,Class<?>> simpleComputeExtensionClasses(){
  Multimap<Class<?>,Class<?>> result=super.simpleComputeExtensionClasses();
  result.put(Object.class,XcoreObjectsExtensions.class);
  result.put(Iterable.class,ECollections.class);
  result.put(Iterable.class,XcoreIterableExtensions.class);
  result.put(Iterator.class,ECollections.class);
  result.put(List.class,ECollections.class);
  result.put(EMap.class,ECollections.class);
  result.put(EList.class,ECollections.class);
  result.put(EList.class,XcoreEListExtensions.class);
  result.put(EObject.class,EcoreUtil.class);
  result.put(EClass.class,EcoreUtil.class);
  result.put(EDataType.class,EcoreUtil.class);
  result.put(EModelElement.class,EcoreUtil.class);
  result.put(EGenericType.class,EcoreUtil.class);
  result.put(Notifier.class,EcoreUtil.class);
  result.put(Resource.class,EcoreUtil.class);
  result.put(ResourceSet.class,EcoreUtil.class);
  return result;
}","@Override protected Multimap<Class<?>,Class<?>> simpleComputeExtensionClasses(){
  Multimap<Class<?>,Class<?>> result=super.simpleComputeExtensionClasses();
  result.put(Iterable.class,ECollections.class);
  result.put(Iterable.class,XcoreIterableExtensions.class);
  result.put(Iterator.class,ECollections.class);
  result.put(List.class,ECollections.class);
  result.put(EMap.class,ECollections.class);
  result.put(EList.class,ECollections.class);
  result.put(EList.class,XcoreEListExtensions.class);
  result.put(EObject.class,EcoreUtil.class);
  result.put(EClass.class,EcoreUtil.class);
  result.put(EDataType.class,EcoreUtil.class);
  result.put(EModelElement.class,EcoreUtil.class);
  result.put(EGenericType.class,EcoreUtil.class);
  result.put(Notifier.class,EcoreUtil.class);
  result.put(Resource.class,EcoreUtil.class);
  result.put(ResourceSet.class,EcoreUtil.class);
  return result;
}",0.5938676707907478
11746,"@Override protected Object doGetValue(Object source){
  List<?> list=delegate.getList(source);
  @SuppressWarnings(""String_Node_Str"") int idx=elementAccess.getReadValueIndex(list);
  if (idx != WriteData.NO_INDEX) {
    return list.get(idx);
  }
  return null;
}","@Override protected Object doGetValue(Object source){
  List<?> list=listFromDelegate(source);
  @SuppressWarnings(""String_Node_Str"") int idx=elementAccess.getReadValueIndex(list);
  if (idx != WriteData.NO_INDEX) {
    return list.get(idx);
  }
  return null;
}",0.9389312977099236
11747,"public String getRawImportedType(){
  if (isFeatureMapType())   return getGenModel().getImportedName(getEffectiveFeatureMapWrapperInterface());
  if (isMapType())   return getGenModel().getImportedName(getEffectiveMapType());
  if (isMapEntryType())   return getGenModel().getImportedName(getEffectiveMapEntryType());
  if (isListType())   return getGenModel().getImportedName(getEffectiveListType());
  if (isEObjectType())   return getGenModel().getImportedName(getEffectiveEObjectType());
  return getImportedType(null,getEcoreTypedElement().getEType(),false);
}","public String getRawImportedType(){
  if (isFeatureMapType())   return getGenModel().getImportedName(getEffectiveFeatureMapWrapperInterface());
  if (isMapType())   return getGenModel().getImportedName(getEffectiveMapType());
  if (isListType())   return getGenModel().getImportedName(getEffectiveListType());
  if (isMapEntryType())   return getGenModel().getImportedName(getEffectiveMapEntryType());
  if (isEObjectType())   return getGenModel().getImportedName(getEffectiveEObjectType());
  return getImportedType(null,getEcoreTypedElement().getEType(),false);
}",0.9575221238938052
11748,"public String getListItemType(GenClass context){
  return getImportedType(context,getEcoreTypedElement().getEGenericType(),true);
}","public String getListItemType(GenClass context){
  if (isMapEntryType())   return getGenModel().getImportedName(getEffectiveMapEntryType(context,getEcoreTypedElement().getEGenericType(),getMapEntryTypeGenClass()));
  return getImportedType(context,getEcoreTypedElement().getEGenericType(),true);
}",0.6121495327102804
11749,"public String getRawBoundType(){
  if (isFeatureMapType())   return getEffectiveFeatureMapWrapperInterface();
  if (isMapType())   return getEffectiveMapType();
  if (isMapEntryType())   return getEffectiveMapEntryType();
  if (isListType())   return getEffectiveListType();
  if (isEObjectType())   return getEffectiveEObjectType();
  return getType(getContext(),getBoundType(getEcoreTypedElement().getEGenericType()),false,true);
}","public String getRawBoundType(){
  if (isFeatureMapType())   return getEffectiveFeatureMapWrapperInterface();
  if (isMapType())   return getEffectiveMapType();
  if (isListType())   return getEffectiveListType();
  if (isMapEntryType())   return getEffectiveMapEntryType();
  if (isEObjectType())   return getEffectiveEObjectType();
  return getType(getContext(),getBoundType(getEcoreTypedElement().getEGenericType()),false,true);
}",0.9168591224018476
11750,"public String getType(GenClass context){
  if (isFeatureMapType())   return getEffectiveFeatureMapWrapperInterface();
  if (isMapType())   return getEffectiveMapType(context,getEcoreTypedElement().getEGenericType(),getMapEntryTypeGenClass());
  if (isMapEntryType())   return getEffectiveMapEntryType(context,getEcoreTypedElement().getEGenericType(),getMapEntryTypeGenClass());
  if (isListType())   return getEffectiveListType(context,getEcoreTypedElement().getEGenericType());
  if (isEObjectType())   return getEffectiveEObjectType();
  if (isListDataType() && getEffectiveComplianceLevel().getValue() >= GenJDKLevel.JDK50) {
    return ""String_Node_Str"" + getType(context,getListDataType().getEcoreDataType(),true) + ""String_Node_Str"";
  }
  return getType(context,getEcoreTypedElement().getEGenericType(),false);
}","public String getType(GenClass context){
  if (isFeatureMapType())   return getEffectiveFeatureMapWrapperInterface();
  if (isMapType())   return getEffectiveMapType(context,getEcoreTypedElement().getEGenericType(),getMapEntryTypeGenClass());
  if (isMapEntryType())   if (isListType())   if (getEffectiveComplianceLevel().getValue() < GenJDKLevel.JDK50)   return getEffectiveListType();
 else   return getEffectiveListType() + ""String_Node_Str"" + getEffectiveMapEntryType(context,getEcoreTypedElement().getEGenericType(),getMapEntryTypeGenClass())+ ""String_Node_Str"";
 else   return getEffectiveMapEntryType(context,getEcoreTypedElement().getEGenericType(),getMapEntryTypeGenClass());
  if (isListType())   return getEffectiveListType(context,getEcoreTypedElement().getEGenericType());
  if (isEObjectType())   return getEffectiveEObjectType();
  if (isListDataType() && getEffectiveComplianceLevel().getValue() >= GenJDKLevel.JDK50) {
    return ""String_Node_Str"" + getType(context,getListDataType().getEcoreDataType(),true) + ""String_Node_Str"";
  }
  return getType(context,getEcoreTypedElement().getEGenericType(),false);
}",0.4727646454265159
11751,"public String getRawType(){
  if (isFeatureMapType())   return getEffectiveFeatureMapWrapperInterface();
  if (isMapType())   return getEffectiveMapType();
  if (isMapEntryType())   return getEffectiveMapType();
  if (isListType())   return getEffectiveListType();
  if (isEObjectType())   return getEffectiveEObjectType();
  return getType(getContext(),getEcoreTypedElement().getEType(),false,true);
}","public String getRawType(){
  if (isFeatureMapType())   return getEffectiveFeatureMapWrapperInterface();
  if (isMapType())   return getEffectiveMapType();
  if (isListType())   return getEffectiveListType();
  if (isMapEntryType())   return getEffectiveMapType();
  if (isEObjectType())   return getEffectiveEObjectType();
  return getType(getContext(),getEcoreTypedElement().getEType(),false,true);
}",0.9228855721393034
11752,"public String getImportedType(GenClass context){
  if (isFeatureMapType())   return getGenModel().getImportedName(getEffectiveFeatureMapWrapperInterface());
  if (isMapType())   return getGenModel().getImportedName(getEffectiveMapType(context,getEcoreTypedElement().getEGenericType(),getMapEntryTypeGenClass()));
  if (isMapEntryType())   return getGenModel().getImportedName(getEffectiveMapEntryType(context,getEcoreTypedElement().getEGenericType(),getMapEntryTypeGenClass()));
  if (isListType())   return getGenModel().getImportedName(getEffectiveListType(context,getEcoreTypedElement().getEGenericType()));
  if (isEObjectType())   return getGenModel().getImportedName(getEffectiveEObjectType());
  if (isListDataType() && getEffectiveComplianceLevel().getValue() >= GenJDKLevel.JDK50) {
    return getGenModel().getImportedName(""String_Node_Str"") + ""String_Node_Str"" + getImportedType(context,getListDataType().getEcoreDataType(),true)+ ""String_Node_Str"";
  }
  return getImportedType(context,getEcoreTypedElement().getEGenericType(),false);
}","public String getImportedType(GenClass context){
  if (isFeatureMapType())   return getGenModel().getImportedName(getEffectiveFeatureMapWrapperInterface());
  if (isMapType())   return getGenModel().getImportedName(getEffectiveMapType(context,getEcoreTypedElement().getEGenericType(),getMapEntryTypeGenClass()));
  if (isMapEntryType())   if (isListType())   if (getEffectiveComplianceLevel().getValue() < GenJDKLevel.JDK50)   return getGenModel().getImportedName(getEffectiveListType());
 else   return getGenModel().getImportedName(getEffectiveListType() + ""String_Node_Str"" + getEffectiveMapEntryType(context,getEcoreTypedElement().getEGenericType(),getMapEntryTypeGenClass())+ ""String_Node_Str"");
 else   return getGenModel().getImportedName(getEffectiveMapEntryType(context,getEcoreTypedElement().getEGenericType(),getMapEntryTypeGenClass()));
  if (isListType())   return getGenModel().getImportedName(getEffectiveListType(context,getEcoreTypedElement().getEGenericType()));
  if (isEObjectType())   return getGenModel().getImportedName(getEffectiveEObjectType());
  if (isListDataType() && getEffectiveComplianceLevel().getValue() >= GenJDKLevel.JDK50) {
    return getGenModel().getImportedName(""String_Node_Str"") + ""String_Node_Str"" + getImportedType(context,getListDataType().getEcoreDataType(),true)+ ""String_Node_Str"";
  }
  return getImportedType(context,getEcoreTypedElement().getEGenericType(),false);
}",0.5012165450121655
11753,"public String getObjectType(GenClass context){
  if (isFeatureMapType())   return getGenModel().getImportedName(getEffectiveFeatureMapWrapperInterface());
  if (isMapType())   return getGenModel().getImportedName(getEffectiveMapType(context,getEcoreTypedElement().getEGenericType(),getMapEntryTypeGenClass()));
  if (isMapEntryType())   return getGenModel().getImportedName(getEffectiveMapEntryType(context,getEcoreTypedElement().getEGenericType(),getMapEntryTypeGenClass()));
  if (isListType())   return getGenModel().getImportedName(getEffectiveListType(context,getEcoreTypedElement().getEGenericType()));
  if (isEObjectType())   return getGenModel().getImportedName(getEffectiveEObjectType());
  if (isListDataType() && getEffectiveComplianceLevel().getValue() >= GenJDKLevel.JDK50) {
    return getGenModel().getImportedName(""String_Node_Str"") + ""String_Node_Str"" + getImportedType(context,getListDataType().getEcoreDataType(),true)+ ""String_Node_Str"";
  }
  return getImportedType(context,getEcoreTypedElement().getEGenericType(),true);
}","public String getObjectType(GenClass context){
  if (isFeatureMapType())   return getGenModel().getImportedName(getEffectiveFeatureMapWrapperInterface());
  if (isMapType())   return getGenModel().getImportedName(getEffectiveMapType(context,getEcoreTypedElement().getEGenericType(),getMapEntryTypeGenClass()));
  if (isMapEntryType())   if (isListType())   if (getEffectiveComplianceLevel().getValue() < GenJDKLevel.JDK50)   return getGenModel().getImportedName(getEffectiveListType());
 else   return getGenModel().getImportedName(getEffectiveListType() + ""String_Node_Str"" + getEffectiveMapEntryType(context,getEcoreTypedElement().getEGenericType(),getMapEntryTypeGenClass())+ ""String_Node_Str"");
 else   return getGenModel().getImportedName(getEffectiveMapEntryType(context,getEcoreTypedElement().getEGenericType(),getMapEntryTypeGenClass()));
  if (isListType())   return getGenModel().getImportedName(getEffectiveListType(context,getEcoreTypedElement().getEGenericType()));
  if (isEObjectType())   return getGenModel().getImportedName(getEffectiveEObjectType());
  if (isListDataType() && getEffectiveComplianceLevel().getValue() >= GenJDKLevel.JDK50) {
    return getGenModel().getImportedName(""String_Node_Str"") + ""String_Node_Str"" + getImportedType(context,getListDataType().getEcoreDataType(),true)+ ""String_Node_Str"";
  }
  return getImportedType(context,getEcoreTypedElement().getEGenericType(),true);
}",0.5252032520325203
11754,"public String getRawImportedBoundType(){
  if (isFeatureMapType())   return getGenModel().getImportedName(getEffectiveFeatureMapWrapperInterface());
  if (isMapType())   return getGenModel().getImportedName(getEffectiveMapType());
  if (isMapEntryType())   return getGenModel().getImportedName(getEffectiveMapEntryType());
  if (isListType())   return getGenModel().getImportedName(getEffectiveListType());
  if (isEObjectType())   return getGenModel().getImportedName(getEffectiveEObjectType());
  return getImportedType(null,getBoundType(getEcoreTypedElement().getEGenericType()),false,true);
}","public String getRawImportedBoundType(){
  if (isFeatureMapType())   return getGenModel().getImportedName(getEffectiveFeatureMapWrapperInterface());
  if (isMapType())   return getGenModel().getImportedName(getEffectiveMapType());
  if (isListType())   return getGenModel().getImportedName(getEffectiveListType());
  if (isMapEntryType())   return getGenModel().getImportedName(getEffectiveMapEntryType());
  if (isEObjectType())   return getGenModel().getImportedName(getEffectiveEObjectType());
  return getImportedType(null,getBoundType(getEcoreTypedElement().getEGenericType()),false,true);
}",0.959731543624161
11755,"public String getImportedInternalType(GenClass context){
  if (isFeatureMapType())   return isBlank(getGenModel().getFeatureMapWrapperInternalInterface()) ? getImportedEffectiveFeatureMapWrapperClass() : getImportedEffectiveFeatureMapWrapperInternalInterface();
  if (isMapType())   return getGenModel().getImportedName(""String_Node_Str"") + getImportedMapTemplateArguments(context);
  if (isMapEntryType())   return getGenModel().getImportedName(""String_Node_Str"") + getImportedMapTemplateArguments(context);
  if (isListType())   return getGenModel().getImportedName(""String_Node_Str"") + getListTemplateArguments(context);
  if (isListDataType() && getEffectiveComplianceLevel().getValue() >= GenJDKLevel.JDK50) {
    return getGenModel().getImportedName(""String_Node_Str"") + ""String_Node_Str"" + getImportedType(context,getListDataType().getEcoreDataType(),true)+ ""String_Node_Str"";
  }
  return getImportedType(context,getEcoreTypedElement().getEGenericType(),false);
}","public String getImportedInternalType(GenClass context){
  if (isFeatureMapType())   return isBlank(getGenModel().getFeatureMapWrapperInternalInterface()) ? getImportedEffectiveFeatureMapWrapperClass() : getImportedEffectiveFeatureMapWrapperInternalInterface();
  if (isMapType())   return getGenModel().getImportedName(""String_Node_Str"") + getImportedMapTemplateArguments(context);
  if (isMapEntryType())   if (isListType())   if (getEffectiveComplianceLevel().getValue() < GenJDKLevel.JDK50)   return getGenModel().getImportedName(""String_Node_Str"");
 else   return getGenModel().getImportedName(""String_Node_Str"") + ""String_Node_Str"" + getGenModel().getImportedName(""String_Node_Str"")+ getImportedMapTemplateArguments(context)+ ""String_Node_Str"";
 else   return getGenModel().getImportedName(""String_Node_Str"") + getImportedMapTemplateArguments(context);
  if (isListType())   return getGenModel().getImportedName(""String_Node_Str"") + getListTemplateArguments(context);
  if (isListDataType() && getEffectiveComplianceLevel().getValue() >= GenJDKLevel.JDK50) {
    return getGenModel().getImportedName(""String_Node_Str"") + ""String_Node_Str"" + getImportedType(context,getListDataType().getEcoreDataType(),true)+ ""String_Node_Str"";
  }
  return getImportedType(context,getEcoreTypedElement().getEGenericType(),false);
}",0.6134380453752182
11756,"public String getQualifiedListItemType(GenClass context){
  return getType(context,getEcoreTypedElement().getEGenericType(),true).replace('$','.');
}","public String getQualifiedListItemType(GenClass context){
  if (isMapEntryType())   return getEffectiveMapEntryType(context,getEcoreTypedElement().getEGenericType(),getMapEntryTypeGenClass()).replace('$','.');
  return getType(context,getEcoreTypedElement().getEGenericType(),true).replace('$','.');
}",0.6622222222222223
11757,"public void discardDerivedState(DerivedStateAwareResource resource){
  EList<EObject> contents=resource.getContents();
  int size=contents.size();
  if (size > 1) {
    for (Iterator<EObject> i=contents.iterator(); i.hasNext(); ) {
      EObject eObject=i.next();
      if (eObject instanceof EPackage || eObject instanceof GenModel || eObject instanceof JvmGenericType) {
        unloader.unloadRoot(eObject);
      }
 else       if (eObject instanceof XPackage) {
        mapper.unsetMapping((XPackage)eObject);
      }
    }
  }
}","public void discardDerivedState(DerivedStateAwareResource resource){
  EList<EObject> contents=resource.getContents();
  int size=contents.size();
  if (size > 1) {
    List<EObject> toBeRemoved=newArrayList();
    for (Iterator<EObject> i=contents.iterator(); i.hasNext(); ) {
      EObject eObject=i.next();
      if (eObject instanceof EPackage || eObject instanceof GenModel || eObject instanceof JvmGenericType) {
        unloader.unloadRoot(eObject);
        toBeRemoved.add(eObject);
      }
 else       if (eObject instanceof XPackage) {
        mapper.unsetMapping((XPackage)eObject);
      }
    }
    contents.removeAll(toBeRemoved);
  }
}",0.9010989010989012
11758,"@Override protected boolean prepare(){
  boolean result=false;
  if (owner != null) {
    if (domain.isReadOnly(owner.eResource())) {
      return false;
    }
    EClass eMetaObject=owner.eClass();
    EList<EStructuralFeature> eAllStructuralFeatures=eMetaObject.getEAllStructuralFeatures();
    if (eAllStructuralFeatures.contains(feature) || eAllStructuralFeatures.contains(ExtendedMetaData.INSTANCE.getAffiliation(eMetaObject,feature))) {
      EClassifier eType=feature.getEType();
      if (ownerList != null) {
        if (index >= 0 && index < ownerList.size() && eType.isInstance(value) && (!feature.isUnique() || !ownerList.contains(value))) {
          oldValue=ownerList.get(index);
          result=true;
        }
      }
 else       if (feature.isMany()) {
        if (owner.eIsSet(feature)) {
          oldValue=new BasicEList<Object>((EList<?>)owner.eGet(feature));
        }
 else {
          oldValue=UNSET_VALUE;
        }
        if (value == UNSET_VALUE) {
          result=true;
        }
 else         if (value instanceof Collection<?>) {
          Collection<?> collection=(Collection<?>)value;
          result=true;
          for (          Object object : collection) {
            if (!eType.isInstance(object)) {
              result=false;
              break;
            }
          }
        }
      }
 else {
        if (owner.eIsSet(feature)) {
          oldValue=owner.eGet(feature);
        }
 else {
          oldValue=UNSET_VALUE;
        }
        result=value == null || value == UNSET_VALUE || eType.isInstance(value);
      }
      if (result && feature instanceof EReference && ((EReference)feature).isContainment()) {
        for (EObject container=owner; container != null; container=container.eContainer()) {
          if (value == container) {
            result=false;
            break;
          }
        }
      }
    }
  }
  return result;
}","@Override protected boolean prepare(){
  boolean result=false;
  if (owner != null) {
    if (domain.isReadOnly(owner.eResource())) {
      return false;
    }
    EClass eMetaObject=owner.eClass();
    EList<EStructuralFeature> eAllStructuralFeatures=eMetaObject.getEAllStructuralFeatures();
    if (eAllStructuralFeatures.contains(feature) || feature != null && eAllStructuralFeatures.contains(ExtendedMetaData.INSTANCE.getAffiliation(eMetaObject,feature))) {
      EClassifier eType=feature.getEType();
      if (ownerList != null) {
        if (index >= 0 && index < ownerList.size() && eType.isInstance(value) && (!feature.isUnique() || !ownerList.contains(value))) {
          oldValue=ownerList.get(index);
          result=true;
        }
      }
 else       if (feature.isMany()) {
        if (owner.eIsSet(feature)) {
          oldValue=new BasicEList<Object>((EList<?>)owner.eGet(feature));
        }
 else {
          oldValue=UNSET_VALUE;
        }
        if (value == UNSET_VALUE) {
          result=true;
        }
 else         if (value instanceof Collection<?>) {
          Collection<?> collection=(Collection<?>)value;
          result=true;
          for (          Object object : collection) {
            if (!eType.isInstance(object)) {
              result=false;
              break;
            }
          }
        }
      }
 else {
        if (owner.eIsSet(feature)) {
          oldValue=owner.eGet(feature);
        }
 else {
          oldValue=UNSET_VALUE;
        }
        result=value == null || value == UNSET_VALUE || eType.isInstance(value);
      }
      if (result && feature instanceof EReference && ((EReference)feature).isContainment()) {
        for (EObject container=owner; container != null; container=container.eContainer()) {
          if (value == container) {
            result=false;
            break;
          }
        }
      }
    }
  }
  return result;
}",0.995017046944663
11759,"@Override protected boolean prepare(){
  boolean result=false;
  if (owner != null) {
    if (domain.isReadOnly(owner.eResource())) {
      return false;
    }
    EClass eMetaObject=owner.eClass();
    EList<EStructuralFeature> eAllStructuralFeatures=eMetaObject.getEAllStructuralFeatures();
    if (eAllStructuralFeatures.contains(feature) || eAllStructuralFeatures.contains(ExtendedMetaData.INSTANCE.getAffiliation(eMetaObject,feature))) {
      EClassifier eType=feature.getEType();
      if (ownerList != null) {
        if (index >= 0 && index < ownerList.size() && eType.isInstance(value) && (!feature.isUnique() || !ownerList.contains(value))) {
          oldValue=ownerList.get(index);
          result=true;
        }
      }
 else       if (feature.isMany()) {
        if (owner.eIsSet(feature)) {
          oldValue=new BasicEList<Object>((EList<?>)owner.eGet(feature));
        }
 else {
          oldValue=UNSET_VALUE;
        }
        if (value == UNSET_VALUE) {
          result=true;
        }
 else         if (value instanceof Collection<?>) {
          Collection<?> collection=(Collection<?>)value;
          result=true;
          for (          Object object : collection) {
            if (!eType.isInstance(object)) {
              result=false;
              break;
            }
          }
        }
      }
 else {
        if (owner.eIsSet(feature)) {
          oldValue=owner.eGet(feature);
        }
 else {
          oldValue=UNSET_VALUE;
        }
        result=value == null || value == UNSET_VALUE || eType.isInstance(value);
      }
      if (result && feature instanceof EReference && ((EReference)feature).isContainment()) {
        for (EObject container=owner; container != null; container=container.eContainer()) {
          if (value == container) {
            result=false;
            break;
          }
        }
      }
    }
  }
  return result;
}","@Override protected boolean prepare(){
  boolean result=false;
  if (owner != null) {
    if (domain.isReadOnly(owner.eResource())) {
      return false;
    }
    EClass eMetaObject=owner.eClass();
    EList<EStructuralFeature> eAllStructuralFeatures=eMetaObject.getEAllStructuralFeatures();
    if (eAllStructuralFeatures.contains(feature) || feature != null && eAllStructuralFeatures.contains(ExtendedMetaData.INSTANCE.getAffiliation(eMetaObject,feature))) {
      EClassifier eType=feature.getEType();
      if (ownerList != null) {
        if (index >= 0 && index < ownerList.size() && eType.isInstance(value) && (!feature.isUnique() || !ownerList.contains(value))) {
          oldValue=ownerList.get(index);
          result=true;
        }
      }
 else       if (feature.isMany()) {
        if (owner.eIsSet(feature)) {
          oldValue=new BasicEList<Object>((EList<?>)owner.eGet(feature));
        }
 else {
          oldValue=UNSET_VALUE;
        }
        if (value == UNSET_VALUE) {
          result=true;
        }
 else         if (value instanceof Collection<?>) {
          Collection<?> collection=(Collection<?>)value;
          result=true;
          for (          Object object : collection) {
            if (!eType.isInstance(object)) {
              result=false;
              break;
            }
          }
        }
      }
 else {
        if (owner.eIsSet(feature)) {
          oldValue=owner.eGet(feature);
        }
 else {
          oldValue=UNSET_VALUE;
        }
        result=value == null || value == UNSET_VALUE || eType.isInstance(value);
      }
      if (result && feature instanceof EReference && ((EReference)feature).isContainment()) {
        for (EObject container=owner; container != null; container=container.eContainer()) {
          if (value == container) {
            result=false;
            break;
          }
        }
      }
    }
  }
  return result;
}",0.995017046944663
11760,"@Override protected List<IEObjectDescription> computeExportedObjects(){
  Resource resource=getResource();
  if (resource instanceof XtextResource) {
    if (resource.isLoaded()) {
      try {
        resource.load(null);
      }
 catch (      IOException e) {
        log.error(e.getMessage(),e);
        return Collections.<IEObjectDescription>emptyList();
      }
    }
    IParseResult parseResult=((XtextResource)resource).getParseResult();
    if (parseResult != null && parseResult.getRootASTElement() != null) {
      final List<IEObjectDescription> result=newArrayList();
      IAcceptor<IEObjectDescription> acceptor=new IAcceptor<IEObjectDescription>(){
        public void accept(        IEObjectDescription description){
          result.add(description);
        }
      }
;
      TreeIterator<EObject> allProperContents=EcoreUtil2.eAll(parseResult.getRootASTElement());
      while (allProperContents.hasNext()) {
        EObject content=allProperContents.next();
        if (!strategy.createEObjectDescriptions(content,acceptor)) {
          allProperContents.prune();
        }
      }
      return result;
    }
  }
  return super.computeExportedObjects();
}","@Override protected List<IEObjectDescription> computeExportedObjects(){
  Resource resource=getResource();
  if (resource instanceof XtextResource) {
    if (!resource.isLoaded()) {
      try {
        resource.load(null);
      }
 catch (      IOException e) {
        log.error(e.getMessage(),e);
        return Collections.<IEObjectDescription>emptyList();
      }
    }
    IParseResult parseResult=((XtextResource)resource).getParseResult();
    if (parseResult != null && parseResult.getRootASTElement() != null) {
      final List<IEObjectDescription> result=newArrayList();
      IAcceptor<IEObjectDescription> acceptor=new IAcceptor<IEObjectDescription>(){
        public void accept(        IEObjectDescription description){
          result.add(description);
        }
      }
;
      TreeIterator<EObject> allProperContents=EcoreUtil2.eAll(parseResult.getRootASTElement());
      while (allProperContents.hasNext()) {
        EObject content=allProperContents.next();
        if (!strategy.createEObjectDescriptions(content,acceptor)) {
          allProperContents.prune();
        }
      }
      return result;
    }
  }
  return super.computeExportedObjects();
}",0.9995750106247344
11761,"@Override public boolean createEObjectDescriptions(EObject eObject,IAcceptor<IEObjectDescription> acceptor){
  if (eObject instanceof XClass) {
    QualifiedName qn=nameProvider.getFullyQualifiedName(eObject);
    if (qn != null) {
      createGenModelDescription(eObject.eResource().getURI(),acceptor,qn);
      createEcoreDescription(eObject.eResource().getURI(),acceptor,qn);
      createJvmTypesDescription(eObject.eResource().getURI(),acceptor,qn);
    }
    return false;
  }
  if (eObject instanceof XDataType) {
    QualifiedName qn=nameProvider.getFullyQualifiedName(eObject);
    if (qn != null) {
      GenDataType genDatatype=genFactory.createGenDataType();
      proxyTool.installProxyURI(eObject.eResource().getURI(),genDatatype,qn);
      acceptor.accept(EObjectDescription.create(qn,genDatatype));
    }
    return false;
  }
  return true;
}","@Override public boolean createEObjectDescriptions(EObject eObject,IAcceptor<IEObjectDescription> acceptor){
  if (eObject instanceof XClass) {
    QualifiedName qn=nameProvider.getFullyQualifiedName(eObject);
    if (qn != null) {
      URI uri=eObject.eResource().getURI();
      createGenModelDescription(uri,acceptor,qn);
      createEcoreDescription(uri,acceptor,qn);
      createJvmTypesDescription(uri,acceptor,qn);
    }
    return false;
  }
  if (eObject instanceof XDataType) {
    QualifiedName qn=nameProvider.getFullyQualifiedName(eObject);
    if (qn != null) {
      GenDataType genDatatype=genFactory.createGenDataType();
      proxyTool.installProxyURI(eObject.eResource().getURI(),genDatatype,qn);
      acceptor.accept(EObjectDescription.create(qn,genDatatype));
    }
    return false;
  }
  if (eObject instanceof XAnnotationDirective) {
    QualifiedName qn=nameProvider.getFullyQualifiedName(eObject);
    if (qn != null) {
      acceptor.accept(EObjectDescription.create(qn,eObject));
    }
  }
  return true;
}",0.4730728616684266
11762,"public void discardDerivedState(DerivedStateAwareResource resource){
  EList<EObject> contents=resource.getContents();
  int size=contents.size();
  if (size > 1) {
    List<EObject> toBeRemoved=newArrayList();
    for (Iterator<EObject> i=contents.iterator(); i.hasNext(); ) {
      EObject eObject=i.next();
      if (eObject instanceof EPackage || eObject instanceof GenModel || eObject instanceof JvmGenericType) {
        unloader.unloadRoot(eObject);
        toBeRemoved.add(eObject);
      }
 else       if (eObject instanceof XPackage) {
        mapper.unsetMapping((XPackage)eObject);
      }
    }
    contents.removeAll(toBeRemoved);
  }
}","public void discardDerivedState(DerivedStateAwareResource resource){
  EList<EObject> contents=resource.getContents();
  int size=contents.size();
  if (size > 1) {
    List<EObject> toBeRemoved=newArrayList();
    for (Iterator<EObject> i=contents.iterator(); i.hasNext(); ) {
      EObject eObject=i.next();
      if (eObject instanceof XPackage) {
        mapper.unsetMapping((XPackage)eObject);
      }
 else {
        unloader.unloadRoot(eObject);
        toBeRemoved.add(eObject);
      }
    }
    contents.removeAll(toBeRemoved);
  }
}",0.7627829002514669
11763,"EOperation getEOperation(XOperation xOperation){
  EOperation eOperation=EcoreFactory.eINSTANCE.createEOperation();
  map(eOperation,xOperation);
  eOperation.setUnique(false);
  handleETypedElement(eOperation,xOperation);
  for (  XTypeParameter xTypeParameter : xOperation.getTypeParameters()) {
    ETypeParameter eTypeParameter=getETypeParameter(xTypeParameter);
    eOperation.getETypeParameters().add(eTypeParameter);
  }
  for (  XParameter xParameter : xOperation.getParameters()) {
    EParameter eParameter=getEParameter(xParameter);
    eOperation.getEParameters().add(eParameter);
  }
  for (  XGenericType exception : xOperation.getExceptions()) {
    EGenericType eException=getEGenericType(exception);
    eOperation.getEGenericExceptions().add(eException);
  }
  XBlockExpression body=xOperation.getBody();
  if (body != null) {
    EAnnotation eAnnotation=EcoreFactory.eINSTANCE.createEAnnotation();
    eAnnotation.setSource(EcorePackage.eNS_URI);
    eAnnotation.getContents().add(EcoreUtil2.cloneWithProxies(body));
    eOperation.getEAnnotations().add(eAnnotation);
  }
  return eOperation;
}","EOperation getEOperation(XOperation xOperation){
  EOperation eOperation=EcoreFactory.eINSTANCE.createEOperation();
  map(eOperation,xOperation);
  eOperation.setUnique(false);
  handleETypedElement(eOperation,xOperation);
  for (  XTypeParameter xTypeParameter : xOperation.getTypeParameters()) {
    ETypeParameter eTypeParameter=getETypeParameter(xTypeParameter);
    eOperation.getETypeParameters().add(eTypeParameter);
  }
  for (  XParameter xParameter : xOperation.getParameters()) {
    EParameter eParameter=getEParameter(xParameter);
    eOperation.getEParameters().add(eParameter);
  }
  for (  XGenericType exception : xOperation.getExceptions()) {
    EGenericType eException=getEGenericType(exception);
    eOperation.getEGenericExceptions().add(eException);
  }
  XBlockExpression body=xOperation.getBody();
  if (body != null) {
    EAnnotation eAnnotation=EcoreFactory.eINSTANCE.createEAnnotation();
    eAnnotation.setSource(EcorePackage.eNS_URI);
    eAnnotation.getReferences().add(body);
    eOperation.getEAnnotations().add(eAnnotation);
  }
  return eOperation;
}",0.9731696225557072
11764,"@Override protected void updateInternalState(IParseResult parseResult){
  for (Iterator<EObject> i=getContents().iterator(); i.hasNext(); ) {
    EObject eObject=i.next();
    if (eObject instanceof EPackage || eObject instanceof GenModel || eObject instanceof JvmGenericType) {
      unloader.unloadRoot(eObject);
      i.remove();
    }
  }
  fullyInitialized=false;
  super.updateInternalState(parseResult);
}","@Override protected void updateInternalState(IParseResult parseResult){
  EObject ePackage=null;
  EList<EObject> contents=getContents();
  int size=contents.size();
  if (size > 1) {
    for (Iterator<EObject> i=contents.iterator(); i.hasNext(); ) {
      EObject eObject=i.next();
      if (eObject instanceof EPackage) {
        ePackage=eObject;
      }
 else       if (eObject instanceof GenModel || eObject instanceof JvmGenericType) {
        unloader.unloadRoot(eObject);
        if (ePackage != null) {
          unloader.unloadRoot(ePackage);
          ePackage=null;
        }
      }
    }
    contents.clear();
  }
  super.updateInternalState(parseResult);
  fullyInitialized=false;
}",0.6131650135256989
11765,"Mapping(EObject eObject){
  this.eObject=eObject;
}","Mapping(EObject eObject,Mapping other){
  this.eObject=eObject;
  this.other=other;
}",0.75
11766,"public void saveEObject(InternalEObject internalEObject,Check check) throws IOException {
  if (internalEObject == null) {
    writeCompressedInt(-1);
  }
 else {
    Integer id=eObjectIDMap.get(internalEObject);
    if (id == null) {
      int idValue=eObjectIDMap.size();
      writeCompressedInt(idValue);
      eObjectIDMap.put(internalEObject,idValue);
      EClass eClass=internalEObject.eClass();
      EClassData eClassData=writeEClass(eClass);
      boolean checkIsTransientProxy=false;
switch (check) {
case DIRECT_RESOURCE:
{
          Internal resource=internalEObject.eDirectResource();
          if (resource != null) {
            writeCompressedInt(-1);
            writeURI(resource.getURI(),resource.getURIFragment(internalEObject));
            if (version == Version.VERSION_1_0) {
              return;
            }
            checkIsTransientProxy=true;
          }
 else           if (internalEObject.eIsProxy()) {
            writeCompressedInt(-1);
            writeURI(internalEObject.eProxyURI());
            if (version == Version.VERSION_1_0) {
              return;
            }
          }
          break;
        }
case RESOURCE:
{
        Resource resource=internalEObject.eResource();
        if (resource != this.resource && resource != null) {
          writeCompressedInt(-1);
          writeURI(resource.getURI(),resource.getURIFragment(internalEObject));
          if (version == Version.VERSION_1_0) {
            return;
          }
          checkIsTransientProxy=true;
        }
 else         if (internalEObject.eIsProxy()) {
          writeCompressedInt(-1);
          writeURI(internalEObject.eProxyURI());
          if (version == Version.VERSION_1_0) {
            return;
          }
        }
        break;
      }
case NOTHING:
case CONTAINER:
{
      break;
    }
}
EStructuralFeatureData[] eStructuralFeatureData=eClassData.eStructuralFeatureData;
for (int i=0, length=eStructuralFeatureData.length; i < length; ++i) {
  EStructuralFeatureData structuralFeatureData=eStructuralFeatureData[i];
  if (!structuralFeatureData.isTransient && (structuralFeatureData.kind != FeatureKind.EOBJECT_CONTAINER_PROXY_RESOLVING || check == Check.CONTAINER) && (!checkIsTransientProxy || !structuralFeatureData.isProxyTransient)) {
    saveFeatureValue(internalEObject,i,structuralFeatureData);
  }
}
writeCompressedInt(0);
}
 else {
writeCompressedInt(id);
}
}
}","public void saveEObject(InternalEObject internalEObject,Check check) throws IOException {
  if (internalEObject == null) {
    writeCompressedInt(-1);
  }
 else {
    Integer id=eObjectIDMap.get(internalEObject);
    if (id == null) {
      int idValue=eObjectIDMap.size();
      writeCompressedInt(idValue);
      eObjectIDMap.put(internalEObject,idValue);
      EClass eClass=internalEObject.eClass();
      EClassData eClassData=writeEClass(eClass);
      boolean checkIsTransientProxy=false;
switch (check) {
case DIRECT_RESOURCE:
{
          Internal resource=internalEObject.eDirectResource();
          if (resource != null) {
            writeCompressedInt(-1);
            writeURI(resource.getURI(),resource.getURIFragment(internalEObject));
            if ((style & STYLE_PROXY_ATTRIBUTES) == 0) {
              return;
            }
            checkIsTransientProxy=true;
          }
 else           if (internalEObject.eIsProxy()) {
            writeCompressedInt(-1);
            writeURI(internalEObject.eProxyURI());
            if ((style & STYLE_PROXY_ATTRIBUTES) == 0) {
              return;
            }
            checkIsTransientProxy=true;
          }
          break;
        }
case RESOURCE:
{
        Resource resource=internalEObject.eResource();
        if (resource != this.resource && resource != null) {
          writeCompressedInt(-1);
          writeURI(resource.getURI(),resource.getURIFragment(internalEObject));
          if ((style & STYLE_PROXY_ATTRIBUTES) == 0) {
            return;
          }
          checkIsTransientProxy=true;
        }
 else         if (internalEObject.eIsProxy()) {
          writeCompressedInt(-1);
          writeURI(internalEObject.eProxyURI());
          if ((style & STYLE_PROXY_ATTRIBUTES) == 0) {
            return;
          }
          checkIsTransientProxy=true;
        }
        break;
      }
case NOTHING:
case CONTAINER:
{
      break;
    }
}
EStructuralFeatureData[] eStructuralFeatureData=eClassData.eStructuralFeatureData;
for (int i=0, length=eStructuralFeatureData.length; i < length; ++i) {
  EStructuralFeatureData structuralFeatureData=eStructuralFeatureData[i];
  if (!structuralFeatureData.isTransient && (structuralFeatureData.kind != FeatureKind.EOBJECT_CONTAINER_PROXY_RESOLVING || check == Check.CONTAINER) && (!checkIsTransientProxy || !structuralFeatureData.isProxyTransient)) {
    saveFeatureValue(internalEObject,i,structuralFeatureData);
  }
}
writeCompressedInt(0);
}
 else {
writeCompressedInt(id);
}
}
}",0.936178861788618
11767,"@Override protected boolean readElement(IConfigurationElement element,boolean add){
  if (element.getName().equals(TAG_HANDLER)) {
    int priority=0;
    if (element.getAttribute(ATT_PRIORITY) != null) {
      priority=Integer.parseInt(element.getAttribute(ATT_PRIORITY));
    }
    String contributorClassName=element.getAttribute(ATT_CLASS);
    if (contributorClassName == null) {
      logMissingAttribute(element,ATT_CLASS);
    }
 else {
      String contributorName=element.getContributor().getName();
      if (add) {
        try {
          @SuppressWarnings(""String_Node_Str"") Class<ContentHandler> contributorHandlerClass=Platform.getBundle(element.getNamespaceIdentifier()).loadClass(contributorClassName);
          Map<String,String> parameters=new HashMap<String,String>();
          for (          IConfigurationElement parameter : element.getChildren(""String_Node_Str"")) {
            parameters.put(parameter.getAttribute(""String_Node_Str""),parameter.getAttribute(""String_Node_Str""));
          }
          ContentHandler contentHandler=parameters.isEmpty() ? contributorHandlerClass.newInstance() : contributorHandlerClass.getConstructor(Map.class).newInstance(parameters);
          ContentHandler.Registry.INSTANCE.put(priority,contentHandler);
          List<ContentHandler> contributions=CONTRIBUTION_MAP.get(contributorName);
          if (contributions == null) {
            CONTRIBUTION_MAP.put(contributorName,contributions=new ArrayList<ContentHandler>());
          }
          contributions.add(contentHandler);
        }
 catch (        Exception exception) {
          EcorePlugin.INSTANCE.log(exception);
        }
        return true;
      }
 else {
        List<ContentHandler> contributions=CONTRIBUTION_MAP.get(contributorName);
        if (contributions != null) {
          for (          List<ContentHandler> values : ContentHandler.Registry.INSTANCE.values()) {
            values.removeAll(contributions);
          }
        }
        CONTRIBUTION_MAP.remove(contributorName);
        return true;
      }
    }
  }
 else   if (element.getName().equals(""String_Node_Str"")) {
    return true;
  }
  return false;
}","@Override protected boolean readElement(IConfigurationElement element,boolean add){
  if (element.getName().equals(TAG_HANDLER)) {
    int priority=0;
    if (element.getAttribute(ATT_PRIORITY) != null) {
      priority=Integer.parseInt(element.getAttribute(ATT_PRIORITY));
    }
    String contributorClassName=element.getAttribute(ATT_CLASS);
    if (contributorClassName == null) {
      logMissingAttribute(element,ATT_CLASS);
    }
 else {
      String contributorName=element.getContributor().getName();
      if (add) {
        try {
          @SuppressWarnings(""String_Node_Str"") Class<ContentHandler> contributorHandlerClass=(Class<ContentHandler>)Platform.getBundle(element.getNamespaceIdentifier()).loadClass(contributorClassName);
          Map<String,String> parameters=new HashMap<String,String>();
          for (          IConfigurationElement parameter : element.getChildren(""String_Node_Str"")) {
            parameters.put(parameter.getAttribute(""String_Node_Str""),parameter.getAttribute(""String_Node_Str""));
          }
          ContentHandler contentHandler=parameters.isEmpty() ? contributorHandlerClass.newInstance() : contributorHandlerClass.getConstructor(Map.class).newInstance(parameters);
          ContentHandler.Registry.INSTANCE.put(priority,contentHandler);
          List<ContentHandler> contributions=CONTRIBUTION_MAP.get(contributorName);
          if (contributions == null) {
            CONTRIBUTION_MAP.put(contributorName,contributions=new ArrayList<ContentHandler>());
          }
          contributions.add(contentHandler);
        }
 catch (        Exception exception) {
          EcorePlugin.INSTANCE.log(exception);
        }
        return true;
      }
 else {
        List<ContentHandler> contributions=CONTRIBUTION_MAP.get(contributorName);
        if (contributions != null) {
          for (          List<ContentHandler> values : ContentHandler.Registry.INSTANCE.values()) {
            values.removeAll(contributions);
          }
        }
        CONTRIBUTION_MAP.remove(contributorName);
        return true;
      }
    }
  }
 else   if (element.getName().equals(""String_Node_Str"")) {
    return true;
  }
  return false;
}",0.994701681640175
11768,"/** 
 * @return an observable manager where {@link ObservablesManager#runAndCollect(Runnable)} is working
 */
public static ObservablesManager getObservableManager(){
  return new CustomObservablesManager();
}","/** 
 * @return an observable manager where {@link ObservablesManager#runAndCollect(Runnable)} is working
 */
public static ObservablesManager getObservableManager(){
  return new EMFObservablesManager();
}",0.9783132530120482
11769,"private void addStatusSupport(final DataBindingContext ctx){
  final AggregateValidationStatus aggregateStatus=new AggregateValidationStatus(ctx.getValidationStatusProviders(),AggregateValidationStatus.MAX_SEVERITY);
  aggregateStatus.addValueChangeListener(new IValueChangeListener(){
    public void handleValueChange(    ValueChangeEvent event){
      handleStateChange((IStatus)event.diff.getNewValue(),ctx);
    }
  }
);
}","private void addStatusSupport(final DataBindingContext ctx){
  aggregateStatus=new AggregateValidationStatus(ctx.getValidationStatusProviders(),AggregateValidationStatus.MAX_SEVERITY);
  aggregateStatus.addValueChangeListener(new IValueChangeListener(){
    public void handleValueChange(    ValueChangeEvent event){
      handleStateChange((IStatus)event.diff.getNewValue(),ctx);
    }
  }
);
}",0.9610705596107056
11770,"/** 
 * release all sources allocated
 */
public void dispose(){
  if (projectImage != null) {
    projectImage.dispose();
  }
  committerPart.dispose();
  if (ctx != null) {
    ctx.dispose();
  }
}","/** 
 * release all sources allocated
 */
public void dispose(){
  if (aggregateStatus != null) {
    aggregateStatus.dispose();
  }
  if (projectImage != null) {
    projectImage.dispose();
  }
  committerPart.dispose();
  if (ctx != null) {
    ctx.dispose();
  }
}",0.5064377682403434
11771,"public Object execute(ExecutionEvent event) throws ExecutionException {
  IEvaluationContext ctx=(IEvaluationContext)event.getApplicationContext();
  Shell shell=(Shell)ctx.getVariable(ISources.ACTIVE_WORKBENCH_WINDOW_SHELL_NAME);
  FileDialog dialog=new FileDialog(shell,SWT.SAVE);
  String name=dialog.open();
  if (name != null) {
    File f=new File(name);
    if (!f.exists()) {
      ResourceSet resourceSet=new ResourceSetImpl();
      resourceSet.getResourceFactoryRegistry().getExtensionToFactoryMap().put(Resource.Factory.Registry.DEFAULT_EXTENSION,new XMIResourceFactoryImpl());
      resourceSet.getPackageRegistry().put(ProjectPackage.eNS_URI,ProjectPackage.eINSTANCE);
      Resource resource=resourceSet.createResource(URI.createURI(""String_Node_Str""));
      Foundation root=ProjectFactory.eINSTANCE.createFoundation();
      resource.getContents().add(root);
      try {
        FileOutputStream out=new FileOutputStream(f);
        resource.save(out,null);
        out.close();
      }
 catch (      FileNotFoundException e) {
        e.printStackTrace();
      }
catch (      IOException e) {
        e.printStackTrace();
      }
    }
    try {
      IWorkbenchWindow w=(IWorkbenchWindow)ctx.getVariable(ISources.ACTIVE_WORKBENCH_WINDOW_NAME);
      String path=f.toURL().toString();
      path=path.replaceFirst(""String_Node_Str"",""String_Node_Str"");
      w.getActivePage().showView(ProjectAdminViewPart.ID,path,IWorkbenchPage.VIEW_ACTIVATE);
    }
 catch (    PartInitException e) {
      e.printStackTrace();
    }
catch (    MalformedURLException e) {
      e.printStackTrace();
    }
  }
  return null;
}","public Object execute(ExecutionEvent event) throws ExecutionException {
  IEvaluationContext ctx=(IEvaluationContext)event.getApplicationContext();
  Shell shell=(Shell)ctx.getVariable(ISources.ACTIVE_WORKBENCH_WINDOW_SHELL_NAME);
  FileDialog dialog=new FileDialog(shell,SWT.SAVE);
  String name=dialog.open();
  if (name != null) {
    File f=new File(name);
    if (!f.exists()) {
      ResourceSet resourceSet=new ResourceSetImpl();
      resourceSet.getResourceFactoryRegistry().getExtensionToFactoryMap().put(Resource.Factory.Registry.DEFAULT_EXTENSION,new XMIResourceFactoryImpl());
      resourceSet.getPackageRegistry().put(ProjectPackage.eNS_URI,ProjectPackage.eINSTANCE);
      Resource resource=resourceSet.createResource(URI.createURI(""String_Node_Str""));
      Foundation root=ProjectFactory.eINSTANCE.createFoundation();
      resource.getContents().add(root);
      try {
        FileOutputStream out=new FileOutputStream(f);
        resource.save(out,null);
        out.close();
      }
 catch (      FileNotFoundException e) {
        e.printStackTrace();
      }
catch (      IOException e) {
        e.printStackTrace();
      }
    }
    try {
      IWorkbenchWindow w=(IWorkbenchWindow)ctx.getVariable(ISources.ACTIVE_WORKBENCH_WINDOW_NAME);
      String path=f.toURL().toString();
      path=path.replaceAll(""String_Node_Str"",""String_Node_Str"");
      w.getActivePage().showView(ProjectAdminViewPart.ID,path,IWorkbenchPage.VIEW_ACTIVATE);
    }
 catch (    PartInitException e) {
      e.printStackTrace();
    }
catch (    MalformedURLException e) {
      e.printStackTrace();
    }
  }
  return null;
}",0.9975429975429976
11772,"public void handleMapChange(MapChangeEvent event){
  Set<?> affectedElements=event.diff.getChangedKeys();
  LabelProviderChangedEvent newEvent=new LabelProviderChangedEvent(TreeLabelProviderImpl.this,affectedElements.toArray());
  fireLabelProviderChanged(newEvent);
}","public void handleMapChange(MapChangeEvent event){
  Set<?> affectedElements=event.diff.getChangedKeys();
  if (!affectedElements.isEmpty()) {
    LabelProviderChangedEvent newEvent=new LabelProviderChangedEvent(TreeLabelProviderImpl.this,affectedElements.toArray());
    fireLabelProviderChanged(newEvent);
  }
}",0.9225473321858864
11773,"private TreeViewer init(Composite parent,Foundation foundation){
  ObservableListTreeContentProvider cp=new ObservableListTreeContentProvider(new TreeFactoryImpl(),new TreeStructureAdvisorImpl());
  IObservableSet set=cp.getKnownElements();
  IObservableMap[] map=new IObservableMap[4];
  map[0]=EMFProperties.value(ProjectPackage.Literals.PROJECT__SHORTNAME).observeDetail(set);
  map[1]=EMFProperties.value(ProjectPackage.Literals.PROJECT__COMMITTERS).observeDetail(set);
  map[2]=EMFProperties.value(FeaturePath.fromList(ProjectPackage.Literals.COMMITTER_SHIP__PERSON,ProjectPackage.Literals.PERSON__FIRSTNAME)).observeDetail(set);
  map[3]=EMFProperties.value(FeaturePath.fromList(ProjectPackage.Literals.COMMITTER_SHIP__PERSON,ProjectPackage.Literals.PERSON__LASTNAME)).observeDetail(set);
  IEMFListProperty projects=EMFProperties.list(ProjectPackage.Literals.FOUNDATION__PROJECTS);
  TreeViewer viewer=new TreeViewer(parent);
  viewer.setContentProvider(cp);
  viewer.setLabelProvider(new TreeLabelProviderImpl(map));
  viewer.setInput(projects.observe(foundation));
  MenuManager mgr=new MenuManager();
  mgr.add(new GroupMarker(""String_Node_Str""));
  viewer.getControl().setMenu(mgr.createContextMenu(viewer.getControl()));
  site.registerContextMenu(Activator.PLUGIN_ID + ""String_Node_Str"",mgr,viewer);
  site.setSelectionProvider(viewer);
  ColumnViewerToolTipSupportImpl.enableFor(viewer,toolkit);
  IObservableValue treeObs=ViewerProperties.singleSelection().observe(viewer);
  treeObs.addValueChangeListener(new IValueChangeListener(){
    public void handleValueChange(    ValueChangeEvent event){
      ISourceProviderService s=(ISourceProviderService)site.getService(ISourceProviderService.class);
      ResourceProvider p=(ResourceProvider)s.getSourceProvider(ResourceProvider.MODEL_RESOURCE_NAME);
      if (event.diff.getNewValue() instanceof Project) {
        Project pr=(Project)event.diff.getNewValue();
        master.setValue(pr);
        p.setCommitter(null);
        p.setProject(pr);
      }
 else       if (event.diff.getNewValue() != null) {
        CommitterShip cm=(CommitterShip)event.diff.getNewValue();
        master.setValue(cm.getProject());
        p.setCommitter(cm);
        p.setProject(cm.getProject());
      }
 else {
        p.setCommitter(null);
        p.setProject(null);
      }
    }
  }
);
  return viewer;
}","private TreeViewer init(Composite parent,Foundation foundation){
  TreeViewer viewer=new TreeViewer(parent);
  ObservableListTreeContentProvider cp=new ObservableListTreeContentProvider(new TreeFactoryImpl(),new TreeStructureAdvisorImpl());
  viewer.setContentProvider(cp);
  IObservableSet set=cp.getKnownElements();
  IObservableMap[] map=new IObservableMap[4];
  map[0]=EMFProperties.value(ProjectPackage.Literals.PROJECT__SHORTNAME).observeDetail(set);
  map[1]=EMFProperties.value(ProjectPackage.Literals.PROJECT__COMMITTERS).observeDetail(set);
  map[2]=EMFProperties.value(FeaturePath.fromList(ProjectPackage.Literals.COMMITTER_SHIP__PERSON,ProjectPackage.Literals.PERSON__FIRSTNAME)).observeDetail(set);
  map[3]=EMFProperties.value(FeaturePath.fromList(ProjectPackage.Literals.COMMITTER_SHIP__PERSON,ProjectPackage.Literals.PERSON__LASTNAME)).observeDetail(set);
  viewer.setLabelProvider(new TreeLabelProviderImpl(map));
  IEMFListProperty projects=EMFProperties.list(ProjectPackage.Literals.FOUNDATION__PROJECTS);
  viewer.setInput(projects.observe(foundation));
  MenuManager mgr=new MenuManager();
  mgr.add(new GroupMarker(""String_Node_Str""));
  viewer.getControl().setMenu(mgr.createContextMenu(viewer.getControl()));
  site.registerContextMenu(Activator.PLUGIN_ID + ""String_Node_Str"",mgr,viewer);
  site.setSelectionProvider(viewer);
  ColumnViewerToolTipSupportImpl.enableFor(viewer,toolkit);
  IObservableValue treeObs=ViewerProperties.singleSelection().observe(viewer);
  treeObs.addValueChangeListener(new IValueChangeListener(){
    public void handleValueChange(    ValueChangeEvent event){
      ISourceProviderService s=(ISourceProviderService)site.getService(ISourceProviderService.class);
      ResourceProvider p=(ResourceProvider)s.getSourceProvider(ResourceProvider.MODEL_RESOURCE_NAME);
      if (event.diff.getNewValue() instanceof Project) {
        Project pr=(Project)event.diff.getNewValue();
        master.setValue(pr);
        p.setCommitter(null);
        p.setProject(pr);
      }
 else       if (event.diff.getNewValue() != null) {
        CommitterShip cm=(CommitterShip)event.diff.getNewValue();
        master.setValue(cm.getProject());
        p.setCommitter(cm);
        p.setProject(cm.getProject());
      }
 else {
        p.setCommitter(null);
        p.setProject(null);
      }
    }
  }
);
  return viewer;
}",0.9423972892842016
11774,"public Object execute(ExecutionEvent event) throws ExecutionException {
  IEvaluationContext ctx=(IEvaluationContext)event.getApplicationContext();
  Shell shell=(Shell)ctx.getVariable(ISources.ACTIVE_WORKBENCH_WINDOW_SHELL_NAME);
  FileDialog dialog=new FileDialog(shell,SWT.OPEN);
  String name=dialog.open();
  if (name != null) {
    File f=new File(name);
    try {
      IWorkbenchWindow w=(IWorkbenchWindow)ctx.getVariable(ISources.ACTIVE_WORKBENCH_WINDOW_NAME);
      String path=f.toURL().toString();
      path=path.replaceFirst(""String_Node_Str"",""String_Node_Str"");
      w.getActivePage().showView(ProjectAdminViewPart.ID,path,IWorkbenchPage.VIEW_ACTIVATE);
    }
 catch (    PartInitException e) {
      e.printStackTrace();
    }
catch (    MalformedURLException e) {
      e.printStackTrace();
    }
  }
  return null;
}","public Object execute(ExecutionEvent event) throws ExecutionException {
  IEvaluationContext ctx=(IEvaluationContext)event.getApplicationContext();
  Shell shell=(Shell)ctx.getVariable(ISources.ACTIVE_WORKBENCH_WINDOW_SHELL_NAME);
  FileDialog dialog=new FileDialog(shell,SWT.OPEN);
  String name=dialog.open();
  if (name != null) {
    File f=new File(name);
    try {
      IWorkbenchWindow w=(IWorkbenchWindow)ctx.getVariable(ISources.ACTIVE_WORKBENCH_WINDOW_NAME);
      String path=f.toURL().toString();
      path=path.replaceAll(""String_Node_Str"",""String_Node_Str"");
      w.getActivePage().showView(ProjectAdminViewPart.ID,path,IWorkbenchPage.VIEW_ACTIVATE);
    }
 catch (    PartInitException e) {
      e.printStackTrace();
    }
catch (    MalformedURLException e) {
      e.printStackTrace();
    }
  }
  return null;
}",0.9952038369304556
11775,"@Override public void createPartControl(Composite parent){
  String path=getViewSite().getSecondaryId().replaceFirst(""String_Node_Str"",""String_Node_Str"");
  resource=Activator.getDefault().loadResource(path);
  modelListener=new IModelResource.Listener(){
    public void dirtyStateChanged(){
      firePropertyChange(PROP_DIRTY);
    }
    public void commandStackChanged(){
    }
  }
;
  resource.addListener(modelListener);
  if (resource == null) {
    throw new RuntimeException(""String_Node_Str"");
  }
  toolkit=new FormToolkit(parent.getDisplay());
  sashForm=new SashForm(parent,SWT.HORIZONTAL);
  mgr=new ObservablesManager();
  mgr.runAndCollect(new Runnable(){
    public void run(){
      projectExplorer=new ProjectExplorerPart(getViewSite(),sashForm,toolkit,resource.getFoundation());
      projectDataForm=new ProjectFormAreaPart(getViewSite(),sashForm,toolkit,resource,projectExplorer.getProjectObservable());
    }
  }
);
  int left=(int)(100 * divider);
  sashForm.setWeights(new int[]{left,100 - left});
  makeActions();
}","@Override public void createPartControl(Composite parent){
  String path=getViewSite().getSecondaryId().replaceAll(""String_Node_Str"",""String_Node_Str"");
  resource=Activator.getDefault().loadResource(path);
  modelListener=new IModelResource.Listener(){
    public void dirtyStateChanged(){
      firePropertyChange(PROP_DIRTY);
    }
    public void commandStackChanged(){
    }
  }
;
  resource.addListener(modelListener);
  if (resource == null) {
    throw new RuntimeException(""String_Node_Str"");
  }
  toolkit=new FormToolkit(parent.getDisplay());
  sashForm=new SashForm(parent,SWT.HORIZONTAL);
  mgr=new ObservablesManager();
  mgr.runAndCollect(new Runnable(){
    public void run(){
      projectExplorer=new ProjectExplorerPart(getViewSite(),sashForm,toolkit,resource.getFoundation());
      projectDataForm=new ProjectFormAreaPart(getViewSite(),sashForm,toolkit,resource,projectExplorer.getProjectObservable());
    }
  }
);
  int left=(int)(100 * divider);
  sashForm.setWeights(new int[]{left,100 - left});
  makeActions();
}",0.9961538461538462
11776,"private void handleStateChange(IStatus currentStatus,DataBindingContext ctx){
  if (form.isDisposed()) {
    return;
  }
  if (currentStatus != null && currentStatus.getSeverity() != IStatus.OK) {
    int type=convertType(currentStatus.getSeverity());
    List<IMessage> list=new ArrayList<IMessage>();
    for (Iterator<?> it=ctx.getValidationStatusProviders().iterator(); it.hasNext(); ) {
      ValidationStatusProvider validationStatusProvider=(ValidationStatusProvider)it.next();
      final IStatus status=(IStatus)validationStatusProvider.getValidationStatus().getValue();
      if (!status.isOK()) {
        list.add(new IMessage(){
          public Control getControl(){
            return null;
          }
          public Object getData(){
            return null;
          }
          public Object getKey(){
            return null;
          }
          public String getPrefix(){
            return null;
          }
          public String getMessage(){
            return status.getMessage();
          }
          public int getMessageType(){
            return convertType(status.getSeverity());
          }
        }
);
      }
    }
    form.setMessage(""String_Node_Str"",type,list.toArray(new IMessage[0]));
  }
 else {
    form.setMessage(null);
  }
}","private void handleStateChange(IStatus currentStatus,DataBindingContext ctx){
  if (form.isDisposed() || form.getHead().isDisposed()) {
    return;
  }
  if (currentStatus != null && currentStatus.getSeverity() != IStatus.OK) {
    int type=convertType(currentStatus.getSeverity());
    List<IMessage> list=new ArrayList<IMessage>();
    for (Iterator<?> it=ctx.getValidationStatusProviders().iterator(); it.hasNext(); ) {
      ValidationStatusProvider validationStatusProvider=(ValidationStatusProvider)it.next();
      final IStatus status=(IStatus)validationStatusProvider.getValidationStatus().getValue();
      if (!status.isOK()) {
        list.add(new IMessage(){
          public Control getControl(){
            return null;
          }
          public Object getData(){
            return null;
          }
          public Object getKey(){
            return null;
          }
          public String getPrefix(){
            return null;
          }
          public String getMessage(){
            return status.getMessage();
          }
          public int getMessageType(){
            return convertType(status.getSeverity());
          }
        }
);
      }
    }
    form.setMessage(""String_Node_Str"",type,list.toArray(new IMessage[0]));
  }
 else {
    form.setMessage(null);
  }
}",0.98798915149167
11777,"private void createFormArea(Composite parent){
  final IObservableValue master=ViewerProperties.singleSelection().observe(viewer);
  ctx=new EMFDataBindingContext();
  addStatusSupport(ctx);
  form=toolkit.createForm(parent);
  toolkit.decorateFormHeading(form);
  form.setText(""String_Node_Str"");
  Composite body=form.getBody();
  body.setLayout(new GridLayout(2,false));
  IWidgetValueProperty prop=WidgetProperties.text(SWT.Modify);
{
    final IEMFValueProperty shortProp=EMFEditProperties.value(editingDomain,ProjectPackage.Literals.PROJECT__SHORTNAME);
    ;
    toolkit.createLabel(body,""String_Node_Str"");
    Text t=toolkit.createText(body,""String_Node_Str"");
    t.setLayoutData(new GridData(GridData.FILL_HORIZONTAL));
    ctx.bindValue(prop.observeDelayed(400,t),shortProp.observeDetail(master));
    final IEMFValueProperty longProp=EMFEditProperties.value(editingDomain,ProjectPackage.Literals.PROJECT__LONGNAME);
    toolkit.createLabel(body,""String_Node_Str"");
    t=toolkit.createText(body,""String_Node_Str"");
    t.setLayoutData(new GridData(GridData.FILL_HORIZONTAL));
    ctx.bindValue(prop.observeDelayed(400,t),longProp.observeDetail(master));
    ctx.bindValue(FormTextProperty.create().observe(form),new ComputedValue(){
      private IObservableValue shortname=shortProp.observeDetail(master);
      private IObservableValue longname=longProp.observeDetail(master);
      @Override protected Object calculate(){
        return shortname.getValue() + ""String_Node_Str"" + longname.getValue();
      }
    }
);
  }
{
    IEMFValueProperty mProp=EMFEditProperties.value(editingDomain,ProjectPackage.Literals.PROJECT__START);
    toolkit.createLabel(body,""String_Node_Str"");
    Text t=toolkit.createText(body,""String_Node_Str"");
    t.setLayoutData(new GridData(GridData.FILL_HORIZONTAL));
    ctx.bindValue(prop.observeDelayed(400,t),mProp.observeDetail(master),new EMFUpdateValueStrategy().setConverter(new StringToDateConverter(NLSMessages.ProjectAdminViewPart_StartDateNotParseable)),new EMFUpdateValueStrategy().setConverter(new DateToStringConverter()));
  }
{
    IEMFValueProperty mProp=EMFEditProperties.value(editingDomain,ProjectPackage.Literals.PROJECT__END);
    toolkit.createLabel(body,""String_Node_Str"");
    Text t=toolkit.createText(body,""String_Node_Str"");
    t.setLayoutData(new GridData(GridData.FILL_HORIZONTAL));
    ctx.bindValue(prop.observeDelayed(400,t),mProp.observeDetail(master),new EMFUpdateValueStrategy().setConverter(new StringToDateConverter(NLSMessages.ProjectAdminViewPart_EndDateNotParseable)),new EMFUpdateValueStrategy().setConverter(new DateToStringConverter()));
  }
  addTabArea(ctx,master,body);
  body.setBackgroundMode(SWT.INHERIT_DEFAULT);
}","private void createFormArea(Composite parent){
  final IObservableValue master=new WritableValue();
  IObservableValue treeObs=ViewerProperties.singleSelection().observe(viewer);
  treeObs.addValueChangeListener(new IValueChangeListener(){
    public void handleValueChange(    ValueChangeEvent event){
      if (event.diff.getNewValue() instanceof Project) {
        master.setValue(event.diff.getNewValue());
      }
    }
  }
);
  ctx=new EMFDataBindingContext();
  addStatusSupport(ctx);
  form=toolkit.createForm(parent);
  toolkit.decorateFormHeading(form);
  form.setText(""String_Node_Str"");
  Composite body=form.getBody();
  body.setLayout(new GridLayout(2,false));
  IWidgetValueProperty prop=WidgetProperties.text(SWT.Modify);
{
    final IEMFValueProperty shortProp=EMFEditProperties.value(editingDomain,ProjectPackage.Literals.PROJECT__SHORTNAME);
    ;
    toolkit.createLabel(body,""String_Node_Str"");
    Text t=toolkit.createText(body,""String_Node_Str"");
    t.setLayoutData(new GridData(GridData.FILL_HORIZONTAL));
    ctx.bindValue(prop.observeDelayed(400,t),shortProp.observeDetail(master));
    final IEMFValueProperty longProp=EMFEditProperties.value(editingDomain,ProjectPackage.Literals.PROJECT__LONGNAME);
    toolkit.createLabel(body,""String_Node_Str"");
    t=toolkit.createText(body,""String_Node_Str"");
    t.setLayoutData(new GridData(GridData.FILL_HORIZONTAL));
    ctx.bindValue(prop.observeDelayed(400,t),longProp.observeDetail(master));
    ctx.bindValue(FormTextProperty.create().observe(form),new ComputedValue(){
      private IObservableValue shortname=shortProp.observeDetail(master);
      private IObservableValue longname=longProp.observeDetail(master);
      @Override protected Object calculate(){
        return shortname.getValue() + ""String_Node_Str"" + longname.getValue();
      }
    }
);
  }
{
    IEMFValueProperty mProp=EMFEditProperties.value(editingDomain,ProjectPackage.Literals.PROJECT__START);
    toolkit.createLabel(body,""String_Node_Str"");
    Text t=toolkit.createText(body,""String_Node_Str"");
    t.setLayoutData(new GridData(GridData.FILL_HORIZONTAL));
    ctx.bindValue(prop.observeDelayed(400,t),mProp.observeDetail(master),new EMFUpdateValueStrategy().setConverter(new StringToDateConverter(NLSMessages.ProjectAdminViewPart_StartDateNotParseable)),new EMFUpdateValueStrategy().setConverter(new DateToStringConverter()));
  }
{
    IEMFValueProperty mProp=EMFEditProperties.value(editingDomain,ProjectPackage.Literals.PROJECT__END);
    toolkit.createLabel(body,""String_Node_Str"");
    Text t=toolkit.createText(body,""String_Node_Str"");
    t.setLayoutData(new GridData(GridData.FILL_HORIZONTAL));
    ctx.bindValue(prop.observeDelayed(400,t),mProp.observeDetail(master),new EMFUpdateValueStrategy().setConverter(new StringToDateConverter(NLSMessages.ProjectAdminViewPart_EndDateNotParseable)),new EMFUpdateValueStrategy().setConverter(new DateToStringConverter()));
  }
  addTabArea(ctx,master,body);
  body.setBackgroundMode(SWT.INHERIT_DEFAULT);
}",0.9327275904246024
11778,"protected void generatePackageSerialization(GenPackage genPackage,Monitor monitor){
  if (genPackage.hasClassifiers() && genPackage.isLoadingInitialization()) {
    monitor=createMonitor(monitor,1);
    try {
      monitor.beginTask(""String_Node_Str"",2);
      GenModel genModel=genPackage.getGenModel();
      String targetPathName=genModel.getModelDirectory() + ""String_Node_Str"" + genPackage.getClassPackageName().replace('.','/')+ ""String_Node_Str""+ genPackage.getSerializedPackageFilename();
      message=CodeGenEcorePlugin.INSTANCE.getString(""String_Node_Str"",new Object[]{targetPathName});
      monitor.subTask(message);
      URI targetFile=toURI(targetPathName);
      ensureContainerExists(targetFile.trimSegments(1),createMonitor(monitor,1));
      EPackage originalPackage=genPackage.getEcorePackage();
      Resource originalResource=originalPackage.eResource();
      ResourceSet set=new ResourceSetImpl();
      set.getResourceFactoryRegistry().getExtensionToFactoryMap().put(Resource.Factory.Registry.DEFAULT_EXTENSION,new EcoreResourceFactoryImpl());
      URI targetURI=toPlatformResourceURI(targetFile);
      Resource outputResource=set.createResource(targetFile);
      EPackage outputPackage=(EPackage)EcoreUtil.copy(originalPackage);
      outputResource.getContents().add(outputPackage);
      for (Iterator<EObject> i=outputResource.getAllContents(); i.hasNext(); ) {
        EObject eObject=i.next();
        if (eObject instanceof EModelElement) {
          EModelElement eModelElement=(EModelElement)eObject;
          for (Iterator<EAnnotation> j=eModelElement.getEAnnotations().iterator(); j.hasNext(); ) {
            EAnnotation eAnnotation=j.next();
            if (genModel.isSuppressedAnnotation(eAnnotation.getSource())) {
              j.remove();
            }
          }
        }
      }
      collapseEmptyPackages(outputPackage);
      final Map<URI,URI> uriMap=new HashMap<URI,URI>();
      for (      Resource resource : originalResource.getResourceSet().getResources()) {
        List<EObject> contents=resource.getContents();
        if (!contents.isEmpty() && contents.get(0) instanceof EPackage) {
          EPackage ePackage=(EPackage)contents.get(0);
          uriMap.put(resource.getURI(),resource == originalResource ? targetURI : URI.createURI(ePackage.getNsURI()));
        }
      }
      XMLResource.URIHandler uriHandler=new URIHandlerImpl.PlatformSchemeAware(){
        protected URI redirect(        URI uri){
          URI mappedURI=uriMap.get(uri.trimFragment());
          return mappedURI == null ? uri : mappedURI.appendFragment(uri.fragment());
        }
        @Override public URI deresolve(        URI uri){
          return super.deresolve(redirect(uri));
        }
        @Override public URI resolve(        URI uri){
          return super.resolve(redirect(uri));
        }
        @Override public void setBaseURI(        URI uri){
          super.setBaseURI(redirect(uri));
        }
      }
;
      Map<Object,Object> options=new HashMap<Object,Object>();
      options.put(XMLResource.OPTION_URI_HANDLER,uriHandler);
      try {
        outputResource.save(options);
      }
 catch (      IOException exception) {
        CodeGenEcorePlugin.INSTANCE.log(exception);
      }
    }
  finally {
      monitor.done();
    }
  }
 else {
    monitor.worked(1);
  }
}","protected void generatePackageSerialization(GenPackage genPackage,Monitor monitor){
  if (genPackage.hasClassifiers() && genPackage.isLoadingInitialization()) {
    monitor=createMonitor(monitor,1);
    try {
      monitor.beginTask(""String_Node_Str"",2);
      final GenModel genModel=genPackage.getGenModel();
      String targetPathName=genModel.getModelDirectory() + ""String_Node_Str"" + genPackage.getClassPackageName().replace('.','/')+ ""String_Node_Str""+ genPackage.getSerializedPackageFilename();
      message=CodeGenEcorePlugin.INSTANCE.getString(""String_Node_Str"",new Object[]{targetPathName});
      monitor.subTask(message);
      URI targetFile=toURI(targetPathName);
      ensureContainerExists(targetFile.trimSegments(1),createMonitor(monitor,1));
      EPackage originalPackage=genPackage.getEcorePackage();
      Resource originalResource=originalPackage.eResource();
      ResourceSet set=new ResourceSetImpl();
      set.getResourceFactoryRegistry().getExtensionToFactoryMap().put(Resource.Factory.Registry.DEFAULT_EXTENSION,new EcoreResourceFactoryImpl());
      URI targetURI=toPlatformResourceURI(targetFile);
      Resource outputResource=set.createResource(targetURI);
      EcoreUtil.Copier copier=new EcoreUtil.Copier(){
        private static final long serialVersionUID=1L;
        @Override protected void copyContainment(        EReference reference,        EObject object,        EObject copyEObject){
          if (reference == EcorePackage.Literals.EMODEL_ELEMENT__EANNOTATIONS) {
            List<EAnnotation> result=((EModelElement)copyEObject).getEAnnotations();
            result.clear();
            for (            EAnnotation eAnnotation : ((EModelElement)object).getEAnnotations()) {
              if (!genModel.isSuppressedAnnotation(eAnnotation.getSource())) {
                result.add((EAnnotation)copy(eAnnotation));
              }
            }
            return;
          }
          super.copyContainment(reference,object,copyEObject);
        }
      }
;
      EPackage outputPackage=(EPackage)copier.copy(originalPackage);
      copier.copyReferences();
      outputResource.getContents().add(outputPackage);
      collapseEmptyPackages(outputPackage);
      final Map<URI,URI> uriMap=new HashMap<URI,URI>();
      for (      Resource resource : originalResource.getResourceSet().getResources()) {
        List<EObject> contents=resource.getContents();
        if (!contents.isEmpty() && contents.get(0) instanceof EPackage) {
          if (resource != originalResource) {
            uriMap.put(resource.getURI(),URI.createURI(((EPackage)contents.get(0)).getNsURI()));
          }
        }
      }
      XMLResource.URIHandler uriHandler=new URIHandlerImpl.PlatformSchemeAware(){
        protected URI redirect(        URI uri){
          URI mappedURI=uriMap.get(uri.trimFragment());
          return mappedURI == null ? uri : mappedURI.appendFragment(uri.fragment());
        }
        @Override public URI deresolve(        URI uri){
          return super.deresolve(redirect(uri));
        }
        @Override public URI resolve(        URI uri){
          return super.resolve(redirect(uri));
        }
        @Override public void setBaseURI(        URI uri){
          super.setBaseURI(redirect(uri));
        }
      }
;
      Map<Object,Object> options=new HashMap<Object,Object>();
      options.put(XMLResource.OPTION_URI_HANDLER,uriHandler);
      options.put(Resource.OPTION_SAVE_ONLY_IF_CHANGED,Resource.OPTION_SAVE_ONLY_IF_CHANGED_MEMORY_BUFFER);
      try {
        outputResource.save(options);
      }
 catch (      IOException exception) {
        CodeGenEcorePlugin.INSTANCE.log(exception);
      }
    }
  finally {
      monitor.done();
    }
  }
 else {
    monitor.worked(1);
  }
}",0.747923997185081
11779,"/** 
 * Does the work of fetching the image associated with the key, when the image resource is not available locally.
 * @param key the key of the image to fetch.
 * @exception MissingResourceException if the image resource doesn't exist anywhere.
 * @see #delegateResourceLocators
 */
protected Object delegatedGetImage(String key) throws MissingResourceException {
  ResourceLocator[] delegateResourceLocators=getDelegateResourceLocators();
  for (int i=0; i < delegateResourceLocators.length; ++i) {
    try {
      return delegateResourceLocators[i].getImage(key);
    }
 catch (    MissingResourceException exception) {
    }
  }
  throw new MissingResourceException(CommonPlugin.INSTANCE.getString(""String_Node_Str"",new Object[]{key}),getClass().getName(),key);
}","/** 
 * Does the work of fetching the image associated with the key, when the image resource is not available locally.
 * @param key the key of the image to fetch.
 * @exception MissingResourceException if the image resource doesn't exist anywhere.
 * @see #getDelegateResourceLocators()
 */
protected Object delegatedGetImage(String key) throws MissingResourceException {
  ResourceLocator[] delegateResourceLocators=getDelegateResourceLocators();
  for (int i=0; i < delegateResourceLocators.length; ++i) {
    try {
      return delegateResourceLocators[i].getImage(key);
    }
 catch (    MissingResourceException exception) {
    }
  }
  throw new MissingResourceException(CommonPlugin.INSTANCE.getString(""String_Node_Str"",new Object[]{key}),getClass().getName(),key);
}",0.9954692556634304
11780,"/** 
 * Does the work of fetching the string associated with the key, when the string resource is not available locally.
 * @param key the key of the string to fetch.
 * @exception MissingResourceException if the string resource doesn't exist anywhere.
 * @see #delegateResourceLocators
 */
protected String delegatedGetString(String key,boolean translate){
  ResourceLocator[] delegateResourceLocators=getDelegateResourceLocators();
  for (int i=0; i < delegateResourceLocators.length; ++i) {
    try {
      return delegateResourceLocators[i].getString(key,translate);
    }
 catch (    MissingResourceException exception) {
    }
  }
  throw new MissingResourceException(MessageFormat.format(""String_Node_Str"",new Object[]{key}),getClass().getName(),key);
}","/** 
 * Does the work of fetching the string associated with the key, when the string resource is not available locally.
 * @param key the key of the string to fetch.
 * @exception MissingResourceException if the string resource doesn't exist anywhere.
 * @see #getDelegateResourceLocators()
 */
protected String delegatedGetString(String key,boolean translate){
  ResourceLocator[] delegateResourceLocators=getDelegateResourceLocators();
  for (int i=0; i < delegateResourceLocators.length; ++i) {
    try {
      return delegateResourceLocators[i].getString(key,translate);
    }
 catch (    MissingResourceException exception) {
    }
  }
  throw new MissingResourceException(MessageFormat.format(""String_Node_Str"",new Object[]{key}),getClass().getName(),key);
}",0.9954098360655738
11781,"/** 
 * @param descriptor
 */
public TypesafeEnumPlugin(){
  sPlugin=this;
}","/** 
 */
public TypesafeEnumPlugin(){
  sPlugin=this;
}",0.8396946564885496
11782,"/** 
 * Logs the exception and shows an error dialog.
 * @param e the exception to handle
 */
private void handleException(Throwable t){
  if (t instanceof InvocationTargetException) {
    t=((InvocationTargetException)t).getTargetException();
  }
  TypesafeEnumPlugin.log(t);
  Shell shell=TypesafeEnumPlugin.getActiveWorkbenchShell();
  String title=""String_Node_Str"";
  DiagnosticDialog.open(shell,title,null,BasicDiagnostic.toDiagnostic(t));
}","/** 
 * Logs the exception and shows an error dialog.
 * @param t the exception to handle
 */
private void handleException(Throwable t){
  if (t instanceof InvocationTargetException) {
    t=((InvocationTargetException)t).getTargetException();
  }
  TypesafeEnumPlugin.log(t);
  Shell shell=TypesafeEnumPlugin.getActiveWorkbenchShell();
  String title=""String_Node_Str"";
  DiagnosticDialog.open(shell,title,null,BasicDiagnostic.toDiagnostic(t));
}",0.9977628635346756
11783,"/** 
 * Returns whether existing read-only files should be overwritten. This method returns <code>true</code> by default.
 * @return whether existing read-only files should be overwritten
 */
public void setForceOverwrite(boolean force){
  mForceOverwrite=force;
}","/** 
 * Sets whether existing read-only files should be overwritten. 
 */
public void setForceOverwrite(boolean force){
  mForceOverwrite=force;
}",0.7073170731707317
11784,"/** 
 * Sets the model object to pass to the JET template.
 * @param the model object to pass to the JET template
 */
public void setModel(Object object){
  mModel=object;
}","/** 
 * Sets the model object to pass to the JET template.
 * @param object the model object to pass to the JET template
 */
public void setModel(Object object){
  mModel=object;
}",0.980169971671388
11785,"/** 
 * Sets whether this instance is the default instance of the parent <code>TypesafeEnum</code>.
 * @param isDefault whether this instance is the default instance of the parent <code>TypesafeEnum</code>
 * @throws IllegalStateException if this instance has not been added to a type
 */
public void setDefault(){
  assertTypeNotNull();
  getType().setDefaultInstance(this);
}","/** 
 * Sets whether this instance is the default instance of the parent <code>TypesafeEnum</code>.
 * @throws IllegalStateException if this instance has not been added to a type
 */
public void setDefault(){
  assertTypeNotNull();
  getType().setDefaultInstance(this);
}",0.8364197530864198
11786,"/** 
 * @param isClass
 * @param pageName
 */
public NewTypesafeEnumCreationWizardPage(){
  super(true,PAGE_NAME);
  setTitle(WizardMessages.getString(""String_Node_Str""));
  setDescription(WizardMessages.getString(""String_Node_Str""));
}","/** 
 */
public NewTypesafeEnumCreationWizardPage(){
  super(true,PAGE_NAME);
  setTitle(WizardMessages.getString(""String_Node_Str""));
  setDescription(WizardMessages.getString(""String_Node_Str""));
}",0.9149425287356322
11787,"/** 
 * @param composite
 * @param nColumns
 */
private void createAuthorVersionControls(Composite parent,int nColumns){
  Label author=new Label(parent,SWT.NONE);
  author.setText(WizardMessages.getString(""String_Node_Str""));
  mTextAuthor=new Text(parent,SWT.SINGLE | SWT.BORDER);
  mTextAuthor.setLayoutData(new GridData(GridData.FILL_HORIZONTAL));
  mTextAuthor.addModifyListener(new ModifyListener(){
    public void modifyText(    ModifyEvent e){
      getTypesafeEnumModel().setAuthor(mTextAuthor.getText());
    }
  }
);
  mTextAuthor.setText(System.getProperty(""String_Node_Str""));
  new Label(parent,SWT.NONE);
  new Label(parent,SWT.NONE);
  Label version=new Label(parent,SWT.NONE);
  version.setText(WizardMessages.getString(""String_Node_Str""));
  mTextVersion=new Text(parent,SWT.SINGLE | SWT.BORDER);
  mTextVersion.setLayoutData(new GridData(GridData.FILL_HORIZONTAL));
  mTextVersion.addModifyListener(new ModifyListener(){
    public void modifyText(    ModifyEvent e){
      getTypesafeEnumModel().setVersion(mTextVersion.getText());
    }
  }
);
  mTextVersion.setText(""String_Node_Str"");
  new Label(parent,SWT.NONE);
  new Label(parent,SWT.NONE);
}","/** 
 * @param parent
 * @param nColumns
 */
private void createAuthorVersionControls(Composite parent,int nColumns){
  Label author=new Label(parent,SWT.NONE);
  author.setText(WizardMessages.getString(""String_Node_Str""));
  mTextAuthor=new Text(parent,SWT.SINGLE | SWT.BORDER);
  mTextAuthor.setLayoutData(new GridData(GridData.FILL_HORIZONTAL));
  mTextAuthor.addModifyListener(new ModifyListener(){
    public void modifyText(    ModifyEvent e){
      getTypesafeEnumModel().setAuthor(mTextAuthor.getText());
    }
  }
);
  mTextAuthor.setText(System.getProperty(""String_Node_Str""));
  new Label(parent,SWT.NONE);
  new Label(parent,SWT.NONE);
  Label version=new Label(parent,SWT.NONE);
  version.setText(WizardMessages.getString(""String_Node_Str""));
  mTextVersion=new Text(parent,SWT.SINGLE | SWT.BORDER);
  mTextVersion.setLayoutData(new GridData(GridData.FILL_HORIZONTAL));
  mTextVersion.addModifyListener(new ModifyListener(){
    public void modifyText(    ModifyEvent e){
      getTypesafeEnumModel().setVersion(mTextVersion.getText());
    }
  }
);
  mTextVersion.setText(""String_Node_Str"");
  new Label(parent,SWT.NONE);
  new Label(parent,SWT.NONE);
}",0.993581514762516
11788,"/** 
 * @param container
 */
private void createButtonsPanel(Composite parent){
  Composite panel=new Composite(parent,SWT.NONE);
  GridLayout layout=new GridLayout();
  layout.numColumns=3;
  panel.setLayout(layout);
  mButtonAdd=new Button(panel,SWT.PUSH);
  mButtonEdit=new Button(panel,SWT.PUSH);
  mButtonRemove=new Button(panel,SWT.PUSH);
  mButtonAdd.setText(WizardMessages.getString(""String_Node_Str""));
  mButtonEdit.setText(WizardMessages.getString(""String_Node_Str""));
  mButtonRemove.setText(WizardMessages.getString(""String_Node_Str""));
}","/** 
 * @param parent
 */
private void createButtonsPanel(Composite parent){
  Composite panel=new Composite(parent,SWT.NONE);
  GridLayout layout=new GridLayout();
  layout.numColumns=3;
  panel.setLayout(layout);
  mButtonAdd=new Button(panel,SWT.PUSH);
  mButtonEdit=new Button(panel,SWT.PUSH);
  mButtonRemove=new Button(panel,SWT.PUSH);
  mButtonAdd.setText(WizardMessages.getString(""String_Node_Str""));
  mButtonEdit.setText(WizardMessages.getString(""String_Node_Str""));
  mButtonRemove.setText(WizardMessages.getString(""String_Node_Str""));
}",0.986351228389445
11789,"/** 
 * Creates an instance that will search the given packages for candidate features.
 * @param considerSubtypes whether to consider {@link ExtendedMetaData#getBaseType(EDataType)base types} or {@link EClass#getESuperTypes() super types}when finding a substitution group.
 * @param ePackages the packages to search for candidates.
 */
public ElementHandlerImpl(boolean considerSubtypes,Collection<? extends EPackage> ePackages){
  this.considerSubtypes=considerSubtypes;
  this.ePackages=ePackages;
}","/** 
 * Creates an instance that will search the given packages for candidate features.
 * @param considerSubtypes whether to consider {@link ExtendedMetaData#getBaseType(EDataType) base types} or {@link EClass#getESuperTypes() super types}when finding a substitution group.
 * @param ePackages the packages to search for candidates.
 */
public ElementHandlerImpl(boolean considerSubtypes,Collection<? extends EPackage> ePackages){
  this.considerSubtypes=considerSubtypes;
  this.ePackages=ePackages;
}",0.999004975124378
11790,"/** 
 * Returns the   {@link ExtendedMetaData#getBaseType(EDataType)base type} or first {@link EClass#getESuperTypes() super type} of the classifier,depending on there it is a  {@link EDataType data type} or a {@link EClass class}.
 * @param extendedMetaData the extended meta data in which to look up type information.
 * @param eClassifier the classifier in question.
 * @return the {@link ExtendedMetaData#getBaseType(EDataType)base type}, the first   {@link EClass#getESuperTypes() super type} of the classifier, or <code>null</code>.
 */
protected EClassifier getSuperType(ExtendedMetaData extendedMetaData,EClassifier eClassifier){
  if (eClassifier instanceof EDataType) {
    return extendedMetaData.getBaseType((EDataType)eClassifier);
  }
 else {
    List<EClass> eSuperTypes=((EClass)eClassifier).getESuperTypes();
    if (eSuperTypes.isEmpty()) {
      return null;
    }
 else {
      return eSuperTypes.get(0);
    }
  }
}","/** 
 * Returns the   {@link ExtendedMetaData#getBaseType(EDataType) base type} or first {@link EClass#getESuperTypes() super type} of the classifier,depending on there it is a  {@link EDataType data type} or a {@link EClass class}.
 * @param extendedMetaData the extended meta data in which to look up type information.
 * @param eClassifier the classifier in question.
 * @return the {@link ExtendedMetaData#getBaseType(EDataType) base type}, the first   {@link EClass#getESuperTypes() super type} of the classifier, or <code>null</code>.
 */
protected EClassifier getSuperType(ExtendedMetaData extendedMetaData,EClassifier eClassifier){
  if (eClassifier instanceof EDataType) {
    return extendedMetaData.getBaseType((EDataType)eClassifier);
  }
 else {
    List<EClass> eSuperTypes=((EClass)eClassifier).getESuperTypes();
    if (eSuperTypes.isEmpty()) {
      return null;
    }
 else {
      return eSuperTypes.get(0);
    }
  }
}",0.9989327641408752
11791,"/** 
 * Returns an observable list that tracks the current value of the feature of the current value of the master observable value.
 * @param realm the realm in which to observe.
 * @param domain the editing domain used for applying changes.
 * @param value the master observable value.
 * @param eStructuralFeature the feature for which to track the value.
 * @return an observable value that tracks the current value of the named property for the current value of the master observable value
 * @see MasterDetailObservables#detailList(IObservableValue,IObservableFactory,Object)
 */
public static IObservableList observeDetailList(Realm realm,EditingDomain domain,IObservableValue master,EStructuralFeature eStructuralFeature){
  return MasterDetailObservables.detailList(master,listFactory(realm,domain,eStructuralFeature),eStructuralFeature);
}","/** 
 * Returns an observable list that tracks the current value of the feature of the current value of the master observable value.
 * @param realm the realm in which to observe.
 * @param domain the editing domain used for applying changes.
 * @param value the master observable value.
 * @param eStructuralFeature the feature for which to track the value.
 * @return an observable value that tracks the current value of the named property for the current value of the master observable value
 * @see MasterDetailObservables#detailList(IObservableValue,IObservableFactory,Object)
 */
public static IObservableList observeDetailList(Realm realm,EditingDomain domain,IObservableValue value,EStructuralFeature eStructuralFeature){
  return MasterDetailObservables.detailList(value,listFactory(realm,domain,eStructuralFeature),eStructuralFeature);
}",0.9870283018867924
11792,"/** 
 * Returns an observable value that tracks the current value of the feature of the current value of the master observable value.
 * @param realm the realm in which to observe.
 * @param domain the editing domain used for applying changes.
 * @param value the master observable value.
 * @param eStructuralFeature the feature for which to track the value.
 * @return an observable value that tracks the current value of the named property for the current value of the master observable value
 * @see MasterDetailObservables#detailValue(IObservableValue,IObservableFactory,Object)
 */
public static IObservableValue observeDetailValue(Realm realm,EditingDomain domain,IObservableValue master,EStructuralFeature eStructuralFeature){
  return MasterDetailObservables.detailValue(master,valueFactory(realm,domain,eStructuralFeature),eStructuralFeature);
}","/** 
 * Returns an observable value that tracks the current value of the feature of the current value of the master observable value.
 * @param realm the realm in which to observe.
 * @param domain the editing domain used for applying changes.
 * @param value the master observable value.
 * @param eStructuralFeature the feature for which to track the value.
 * @return an observable value that tracks the current value of the named property for the current value of the master observable value
 * @see MasterDetailObservables#detailValue(IObservableValue,IObservableFactory,Object)
 */
public static IObservableValue observeDetailValue(Realm realm,EditingDomain domain,IObservableValue value,EStructuralFeature eStructuralFeature){
  return MasterDetailObservables.detailValue(value,valueFactory(realm,domain,eStructuralFeature),eStructuralFeature);
}",0.98711943793911
11793,"/** 
 * Returns the editors for a given URI. This method actually attempts to open an input stream for the URI and uses its contents, along with the filename (the URI's last segment), to obtain appropriate content types. <p> If a URI converter is specified, it is used to open the stream. Otherwise, the global default  {@link URIConverter#INSTANCE instance} is used.
 * @param uri a URI
 * @param a URI converter from which to obtain an input stream, or <code>null</code>
 * @param defaultsOnly if <code>true</code>, only the default editor for each content type will be included in the result 
 * @return the descriptors of the editors
 * @since 2.4
 */
public static IEditorDescriptor[] getEditors(URI uri,URIConverter uriConverter,boolean defaultsOnly){
  String fileName=URI.decode(uri.lastSegment());
  if (uriConverter == null) {
    uriConverter=URIConverter.INSTANCE;
  }
  InputStream stream=null;
  try {
    stream=uriConverter.createInputStream(uri);
    return getEditors(stream,fileName,defaultsOnly);
  }
 catch (  IOException e) {
    EMFEditUIPlugin.INSTANCE.log(e);
    return getEditors(fileName,defaultsOnly);
  }
 finally {
    close(stream);
  }
}","/** 
 * Returns the editors for a given URI. This method actually attempts to open an input stream for the URI and uses its contents, along with the filename (the URI's last segment), to obtain appropriate content types. <p> If a URI converter is specified, it is used to open the stream. Otherwise, the global default  {@link URIConverter#INSTANCE instance} is used.
 * @param uri a URI
 * @param uriConverter a URI converter from which to obtain an input stream, or <code>null</code>
 * @param defaultsOnly if <code>true</code>, only the default editor for each content type will be included in the result 
 * @return the descriptors of the editors
 * @since 2.4
 */
public static IEditorDescriptor[] getEditors(URI uri,URIConverter uriConverter,boolean defaultsOnly){
  String fileName=URI.decode(uri.lastSegment());
  if (uriConverter == null) {
    uriConverter=URIConverter.INSTANCE;
  }
  InputStream stream=null;
  try {
    stream=uriConverter.createInputStream(uri);
    return getEditors(stream,fileName,defaultsOnly);
  }
 catch (  IOException e) {
    EMFEditUIPlugin.INSTANCE.log(e);
    return getEditors(fileName,defaultsOnly);
  }
 finally {
    close(stream);
  }
}",0.994475138121547
11794,"/** 
 * Returns the default editor for a given URI. This method actually attempts to open an input stream for the URI and uses its contents, along with the filename (the URI's last segment), to obtain appropriate content types. <p> If a URI converter is specified, it is used to open the stream. Otherwise, the global default  {@link URIConverter#INSTANCE instance} is used.
 * @param uri a URI
 * @param a URI converter from which to obtain an input stream, or <code>null</code>
 * @return the descriptor of the default editor, or <code>null</code> if not found
 * @since 2.4
 */
public static IEditorDescriptor getDefaultEditor(URI uri,URIConverter uriConverter){
  String fileName=URI.decode(uri.lastSegment());
  if (uriConverter == null) {
    uriConverter=URIConverter.INSTANCE;
  }
  InputStream stream=null;
  try {
    stream=uriConverter.createInputStream(uri);
    return getDefaultEditor(stream,fileName);
  }
 catch (  IOException e) {
    EMFEditUIPlugin.INSTANCE.log(e);
    return getDefaultEditor(fileName);
  }
 finally {
    close(stream);
  }
}","/** 
 * Returns the default editor for a given URI. This method actually attempts to open an input stream for the URI and uses its contents, along with the filename (the URI's last segment), to obtain appropriate content types. <p> If a URI converter is specified, it is used to open the stream. Otherwise, the global default  {@link URIConverter#INSTANCE instance} is used.
 * @param uri a URI
 * @param uriConverter URI converter from which to obtain an input stream, or <code>null</code>
 * @return the descriptor of the default editor, or <code>null</code> if not found
 * @since 2.4
 */
public static IEditorDescriptor getDefaultEditor(URI uri,URIConverter uriConverter){
  String fileName=URI.decode(uri.lastSegment());
  if (uriConverter == null) {
    uriConverter=URIConverter.INSTANCE;
  }
  InputStream stream=null;
  try {
    stream=uriConverter.createInputStream(uri);
    return getDefaultEditor(stream,fileName);
  }
 catch (  IOException e) {
    EMFEditUIPlugin.INSTANCE.log(e);
    return getDefaultEditor(fileName);
  }
 finally {
    close(stream);
  }
}",0.9939223936418888
11795,"/** 
 * Returns an observable list that tracks the current value of the feature of the current value of the master observable value.
 * @param realm the realm in which to observe.
 * @param value the master observable value.
 * @param eStructuralFeature the feature for which to track the value.
 * @return an observable value that tracks the current value of the named property for the current value of the master observable value
 * @see MasterDetailObservables#detailList(IObservableValue,IObservableFactory,Object)
 */
public static IObservableList observeDetailList(Realm realm,IObservableValue master,EStructuralFeature eStructuralFeature){
  return MasterDetailObservables.detailList(master,listFactory(realm,eStructuralFeature),eStructuralFeature);
}","/** 
 * Returns an observable list that tracks the current value of the feature of the current value of the master observable value.
 * @param realm the realm in which to observe.
 * @param value the master observable value.
 * @param eStructuralFeature the feature for which to track the value.
 * @return an observable value that tracks the current value of the named property for the current value of the master observable value
 * @see MasterDetailObservables#detailList(IObservableValue,IObservableFactory,Object)
 */
public static IObservableList observeDetailList(Realm realm,IObservableValue value,EStructuralFeature eStructuralFeature){
  return MasterDetailObservables.detailList(value,listFactory(realm,eStructuralFeature),eStructuralFeature);
}",0.9854689564068692
11796,"/** 
 * This test case was based on the excellent article written by Adrian Powell  Model with the Eclipse Modeling Framework, Part 3 
 * @see http://www-106.ibm.com/developerworks/library/os-ecemf3/.
 */
public void merge1() throws Exception {
  verifyMerge(mergeFiles());
}","/** 
 * This test case was based on the excellent article written by Adrian Powell  Model with the Eclipse Modeling Framework, Part 3 
 * @see <a href=""http://www.ibm.com/developerworks/library/os-ecemf3/"">JMerge</a>
 */
public void merge1() throws Exception {
  verifyMerge(mergeFiles());
}",0.9540636042402828
11797,"/** 
 * Method to be used in tests created based on data directories.
 * @throws Exception
 * @see addItself(TestSuite)
 * @see JMergerTestSuite
 */
public void mergeAST() throws Exception {
  merge();
}","/** 
 * Method to be used in tests created based on data directories.
 * @throws Exception
 * @see #addItself(TestSuite)
 * @see JMergerTestSuite
 */
public void mergeAST() throws Exception {
  merge();
}",0.9975429975429976
11798,"/** 
 * Adds itself only if java version is 1.4 based on directory (  {@link #determineJavaVersion()}and if possible by   {@link JMergerTest#addItself(TestSuite)}.
 * @see org.eclipse.emf.test.tools.merger.JMergerTest#addItself(junit.framework.TestSuite)
 */
@Override public void addItself(TestSuite ts){
  String javaVersion=computeJavaVersion();
  if (JavaCore.VERSION_1_4.equals(javaVersion)) {
    super.addItself(ts);
  }
}","/** 
 * Adds itself only if java version is 1.4 based on directory (  {@link #computeExpectedOutputFile()}and if possible by   {@link JMergerTest#addItself(TestSuite)}.
 * @see org.eclipse.emf.test.tools.merger.JMergerTest#addItself(junit.framework.TestSuite)
 */
@Override public void addItself(TestSuite ts){
  String javaVersion=computeJavaVersion();
  if (JavaCore.VERSION_1_4.equals(javaVersion)) {
    super.addItself(ts);
  }
}",0.9501738122827348
11799,"/** 
 * Method to be used in tests created based on data directories.
 * @throws Exception
 * @see {@link #addItself(TestSuite)}
 * @see JMergerTestSuite
 */
public void mergeJDOM() throws Exception {
  merge();
}","/** 
 * Method to be used in tests created based on data directories.
 * @throws Exception
 * @see #addItself(TestSuite)
 * @see JMergerTestSuite
 */
public void mergeJDOM() throws Exception {
  merge();
}",0.9808612440191388
11800,"/** 
 * Perform and verify merge. To be used in merge tests by subclasses.  <b> Before performing merge, java compiler source version is set based on data directory.
 * @throws Exception 
 * @see {@link #adjustSourceCompatibility()}
 */
protected void merge() throws Exception {
  adjustSourceCompatibility();
  verifyMerge(expectedOutput,mergeFiles());
}","/** 
 * Perform and verify merge. To be used in merge tests by subclasses.  <b> Before performing merge, java compiler source version is set based on data directory.
 * @throws Exception 
 * @see #adjustSourceCompatibility()
 */
protected void merge() throws Exception {
  adjustSourceCompatibility();
  verifyMerge(expectedOutput,mergeFiles());
}",0.9886039886039886
11801,"/** 
 * Creates and returns test suite for a single input directory.
 * @param subDirectoryName
 * @param dataDirsDirectory directory containing directory with subDirectoryName
 * @return
 */
protected TestSuite createSingleInputTestSuite(File dataDirectory){
  TestSuite ts=new TestSuite(dataDirectory.getName());
  addTestCases(ts,dataDirectory);
  return ts;
}","/** 
 * Creates and returns test suite for a single input directory.
 * @param dataDirectory directory containing directory with subDirectoryName
 * @return
 */
protected TestSuite createSingleInputTestSuite(File dataDirectory){
  TestSuite ts=new TestSuite(dataDirectory.getName());
  addTestCases(ts,dataDirectory);
  return ts;
}",0.943884892086331
11802,"/** 
 * Returns the   {@link GenBase} object's {@link GenAnnotation} Details mapassociated with this Model Exporter or  {@link ECollections.EMPTY_EMAP}
 */
protected EMap<String,String> getExporterGenAnnotationDetails(GenBase genBase){
  EMap<String,String> eMap=getGenBaseToGenAnnotationDetailsMap().get(genBase);
  if (eMap == null) {
    GenAnnotation genAnnotation=genBase.getGenAnnotation(getConverterGenAnnotationSource());
    if (genAnnotation != null) {
      eMap=genAnnotation.getDetails();
      getGenBaseToGenAnnotationDetailsMap().put(genBase,eMap);
    }
 else {
      eMap=ECollections.emptyEMap();
    }
  }
  return eMap;
}","/** 
 * Returns the   {@link GenBase} object's {@link GenAnnotation} Details mapassociated with this Model Exporter or  {@link ECollections#EMPTY_EMAP}
 */
protected EMap<String,String> getExporterGenAnnotationDetails(GenBase genBase){
  EMap<String,String> eMap=getGenBaseToGenAnnotationDetailsMap().get(genBase);
  if (eMap == null) {
    GenAnnotation genAnnotation=genBase.getGenAnnotation(getConverterGenAnnotationSource());
    if (genAnnotation != null) {
      eMap=genAnnotation.getDetails();
      getGenBaseToGenAnnotationDetailsMap().put(genBase,eMap);
    }
 else {
      eMap=ECollections.emptyEMap();
    }
  }
  return eMap;
}",0.9984423676012462
11803,"/** 
 * Separates the type argument from the type.  The first position of the returned array is always the raw type and the second is either the type argument without the outmost '&lt;' and '&gt;' or <code>null</null>.
 * @param typeName
 * @return a String array with length == 2
 */
public static String[] separateTypeArgument(String typeName){
  String typeArgument=null;
  int ltIndex=typeName.indexOf('<');
  if (ltIndex > 0) {
    int gtIndex=typeName.lastIndexOf('>');
    if (gtIndex > ltIndex + 1) {
      typeArgument=typeName.substring(ltIndex + 1,gtIndex).trim();
      typeName=typeName.substring(0,ltIndex).trim();
    }
  }
  return new String[]{typeName,typeArgument};
}","/** 
 * Separates the type argument from the type.  The first position of the returned array is always the raw type and the second is either the type argument without the outermost '&lt;' and '&gt;' or <code>null</null>.
 * @param typeName
 * @return a String array with length == 2
 */
public static String[] separateTypeArgument(String typeName){
  String typeArgument=null;
  int ltIndex=typeName.indexOf('<');
  if (ltIndex > 0) {
    int gtIndex=typeName.lastIndexOf('>');
    if (gtIndex > ltIndex + 1) {
      typeArgument=typeName.substring(ltIndex + 1,gtIndex).trim();
      typeName=typeName.substring(0,ltIndex).trim();
    }
  }
  return new String[]{typeName,typeArgument};
}",0.9985443959243084
11804,"/** 
 * Executes a stand-alone test.
 * @param arguments an array of Strings from the command line.
 * @see #run
 */
public static void main(String arguments[]){
  ResourceSet resourceSet=new ResourceSetImpl();
  resourceSet.getResourceFactoryRegistry().getExtensionToFactoryMap().put(""String_Node_Str"",new JavaPackageResourceFactoryImpl());
  JavaPackageResourceImpl javaPackageResource=(JavaPackageResourceImpl)resourceSet.getResource(JAVA_PACKAGE_RESOURCE_URI,true);
  javaPackageResource.setClassLoader(StandAloneTest.class.getClassLoader());
  JClass thisClass=(JClass)resourceSet.getEObject(JAVA_PACKAGE_RESOURCE_URI.appendFragment(""String_Node_Str""),true);
  System.out.println(""String_Node_Str"" + thisClass.getQualifiedName());
  for (  JMethod jMethod : thisClass.getAllMethods()) {
    System.out.println(""String_Node_Str"" + jMethod.getQualifiedName());
  }
  System.exit(1);
}","/** 
 * Executes a stand-alone test.
 * @param arguments an array of Strings from the command line.
 */
public static void main(String arguments[]){
  ResourceSet resourceSet=new ResourceSetImpl();
  resourceSet.getResourceFactoryRegistry().getExtensionToFactoryMap().put(""String_Node_Str"",new JavaPackageResourceFactoryImpl());
  JavaPackageResourceImpl javaPackageResource=(JavaPackageResourceImpl)resourceSet.getResource(JAVA_PACKAGE_RESOURCE_URI,true);
  javaPackageResource.setClassLoader(StandAloneTest.class.getClassLoader());
  JClass thisClass=(JClass)resourceSet.getEObject(JAVA_PACKAGE_RESOURCE_URI.appendFragment(""String_Node_Str""),true);
  System.out.println(""String_Node_Str"" + thisClass.getQualifiedName());
  for (  JMethod jMethod : thisClass.getAllMethods()) {
    System.out.println(""String_Node_Str"" + jMethod.getQualifiedName());
  }
  System.exit(1);
}",0.9926178307779672
11805,"/** 
 * Record the DOM node and its corresponding EMF values.
 * @param node the DOM node
 * @param container the {@link org.eclipse.emf.ecore.EObject} which is the node's container
 * @param feature the feature for DOM node value
 * @param object the EMF value which is obtained by querying the value of the specified feature on the container {@link EObject#eGet(EStructuralFeature)};  this value is used to create the <emf>node</emf>
 */
void recordValues(Node node,EObject container,EStructuralFeature feature,Object value);","/** 
 * Record the DOM node and its corresponding EMF values.
 * @param node the DOM node
 * @param container the {@link org.eclipse.emf.ecore.EObject} which is the node's container
 * @param feature the feature for DOM node value
 * @param value the EMF value which is obtained by querying the value of the specified feature on the container {@link EObject#eGet(EStructuralFeature)};  this value is used to create the <emf>node</emf>
 */
void recordValues(Node node,EObject container,EStructuralFeature feature,Object value);",0.9895536562203228
11806,"/** 
 * This options allows the user to load and deserialize arbitrary XML (i.e. XML for which schema is not specified). The default is <code>false</code>, unless set to <code>true</code> explicitly.  To process schemaLocation/noNamespaceSchemaLocation attributes, user have to set   {@link #setProcessSchemaLocations(boolean)} to <code>true</code>.
 * @see XMLResource#getEObjectToExtensionMap()
 * @param anyXML
 */
void setProcessAnyXML(boolean processAnyXML);","/** 
 * This options allows the user to load and deserialize arbitrary XML (i.e. XML for which schema is not specified). The default is <code>false</code>, unless set to <code>true</code> explicitly.  To process schemaLocation/noNamespaceSchemaLocation attributes, user have to set   {@link #setProcessSchemaLocations(boolean)} to <code>true</code>.
 * @see XMLResource#getEObjectToExtensionMap()
 * @param processAnyXML whether to process arbitrary XML.
 */
void setProcessAnyXML(boolean processAnyXML);",0.9555325749741468
11807,"/** 
 * Called before saving begins.
 * @param resource the resource being saved.
 * @param inputStream the stream being written.
 * @param options the save options.
 */
void postSave(XMLResource resource,OutputStream outputStream,Map<?,?> options);","/** 
 * Called before saving begins.
 * @param resource the resource being saved.
 * @param outputStream the stream being written.
 * @param options the save options.
 */
void postSave(XMLResource resource,OutputStream outputStream,Map<?,?> options);",0.9899799599198396
11808,"/** 
 * Called before saving begins.
 * @param resource the resource being saved.
 * @param inputStream the stream being written.
 * @param options the save options.
 */
void preSave(XMLResource resource,OutputStream outputStream,Map<?,?> options);","/** 
 * Called before saving begins.
 * @param resource the resource being saved.
 * @param outputStream the stream being written.
 * @param options the save options.
 */
void preSave(XMLResource resource,OutputStream outputStream,Map<?,?> options);",0.9899396378269618
11809,"/** 
 * Updates any cached children based on the given notification. If a   {@link ChildrenStore} exists for its notifier,then the children of the specified feature are updated. <p>Existing children in the store that correspond to any set, removed or unset values are  {@link #disposeWrapper disposed} before being removed from the store. When children are added to, removed from, or movedwithin a feature, the indices of any others affected are  {@link #adjustWrapperIndex adjusted}. Since this method is typically called from   {@link #notifyChanged notifyChanged}, which, in subclasses, is often invoked repeatedly up the inheritance chain, it can be safely called repeatedly for a single notification, and only the first such call will have an effect. Such repeated calls may not, however, safely be interleaved with calls for another notification.
 */
protected void updateChildren(Notification notification){
  EObject object=(EObject)notification.getNotifier();
  ChildrenStore childrenStore=getChildrenStore(object);
  if (childrenStore != null) {
    EStructuralFeature feature=(EStructuralFeature)notification.getFeature();
    EList<Object> children=childrenStore.getList(feature);
    if (children != null) {
      int index=notification.getPosition();
switch (notification.getEventType()) {
case Notification.UNSET:
{
          if (feature.isMany()) {
            break;
          }
        }
case Notification.SET:
{
        Object oldChild=childrenStore.get(feature,index);
        Object newValue=notification.getNewValue();
        if (unwrap(oldChild) != newValue) {
          if (feature.isMany() && index == Notification.NO_INDEX) {
            disposeWrappers((List<?>)oldChild);
          }
 else {
            disposeWrapper(oldChild);
          }
          Object newChild=newValue == null && index == Notification.NO_INDEX ? null : wrap(object,feature,newValue,index);
          childrenStore.set(feature,index,newChild);
        }
        break;
      }
case Notification.ADD:
{
      EList<?> values=(EList<?>)object.eGet(feature);
      if (children.size() != values.size()) {
        Object newValue=notification.getNewValue();
        adjustWrapperIndices(children,index,1);
        children.add(index,wrap(object,feature,newValue,index));
      }
      break;
    }
case Notification.REMOVE:
{
    EList<?> values=(EList<?>)object.eGet(feature);
    if (children.size() != values.size()) {
      disposeWrapper(children.remove(index));
      adjustWrapperIndices(children,index,-1);
    }
    break;
  }
case Notification.ADD_MANY:
{
  EList<?> values=(EList<?>)object.eGet(feature);
  if (children.size() != values.size()) {
    if (notification.getOldValue() != null) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
    List<?> newValues=(List<?>)notification.getNewValue();
    List<Object> newChildren=new ArrayList<Object>(newValues.size());
    int offset=0;
    for (    Object newValue : newValues) {
      newChildren.add(wrap(object,feature,newValue,index + offset++));
    }
    adjustWrapperIndices(children,index,offset);
    children.addAll(index,newChildren);
  }
  break;
}
case Notification.REMOVE_MANY:
{
if (index == Notification.NO_INDEX) index=0;
EList<?> values=(EList<?>)object.eGet(feature);
if (children.size() != values.size()) {
  if (notification.getNewValue() instanceof int[]) {
    int[] indices=(int[])notification.getNewValue();
    for (int i=indices.length - 1; i >= 0; i--) {
      disposeWrapper(children.remove(indices[i]));
      adjustWrapperIndices(children,indices[i],-1);
    }
  }
 else {
    int len=((List<?>)notification.getOldValue()).size();
    List<?> sl=children.subList(index,index + len);
    disposeWrappers(sl);
    sl.clear();
    adjustWrapperIndices(children,index,-len);
  }
}
break;
}
case Notification.MOVE:
{
int oldIndex=((Integer)notification.getOldValue()).intValue();
EList<?> values=(EList<?>)object.eGet(feature);
boolean didMove=true;
for (int i=Math.min(oldIndex,index), end=Math.max(oldIndex,index); didMove && i <= end; i++) {
didMove=unwrap(children.get(i)) == values.get(i);
}
if (!didMove) {
int delta=index - oldIndex;
if (delta < 0) {
  adjustWrapperIndices(children,index,oldIndex,1);
}
children.move(index,oldIndex);
adjustWrapperIndex(children.get(index),delta);
if (delta > 0) {
  adjustWrapperIndices(children,oldIndex,index,-1);
}
}
break;
}
}
}
}
}","/** 
 * Updates any cached children based on the given notification. If a   {@link ChildrenStore} exists for its notifier,then the children of the specified feature are updated. <p>Existing children in the store that correspond to any set, removed or unset values are  {@link #disposeWrapper disposed} before being removed from the store. When children are added to, removed from, or movedwithin a feature, the indices of any others affected are  {@link #adjustWrapperIndex adjusted}. Since this method is typically called from   {@link #notifyChanged(Notification) notifyChanged}, which, in subclasses, is often invoked repeatedly up the inheritance chain, it can be safely called repeatedly for a single notification, and only the first such call will have an effect. Such repeated calls may not, however, safely be interleaved with calls for another notification.
 */
protected void updateChildren(Notification notification){
  EObject object=(EObject)notification.getNotifier();
  ChildrenStore childrenStore=getChildrenStore(object);
  if (childrenStore != null) {
    EStructuralFeature feature=(EStructuralFeature)notification.getFeature();
    EList<Object> children=childrenStore.getList(feature);
    if (children != null) {
      int index=notification.getPosition();
switch (notification.getEventType()) {
case Notification.UNSET:
{
          if (feature.isMany()) {
            break;
          }
        }
case Notification.SET:
{
        Object oldChild=childrenStore.get(feature,index);
        Object newValue=notification.getNewValue();
        if (unwrap(oldChild) != newValue) {
          if (feature.isMany() && index == Notification.NO_INDEX) {
            disposeWrappers((List<?>)oldChild);
          }
 else {
            disposeWrapper(oldChild);
          }
          Object newChild=newValue == null && index == Notification.NO_INDEX ? null : wrap(object,feature,newValue,index);
          childrenStore.set(feature,index,newChild);
        }
        break;
      }
case Notification.ADD:
{
      EList<?> values=(EList<?>)object.eGet(feature);
      if (children.size() != values.size()) {
        Object newValue=notification.getNewValue();
        adjustWrapperIndices(children,index,1);
        children.add(index,wrap(object,feature,newValue,index));
      }
      break;
    }
case Notification.REMOVE:
{
    EList<?> values=(EList<?>)object.eGet(feature);
    if (children.size() != values.size()) {
      disposeWrapper(children.remove(index));
      adjustWrapperIndices(children,index,-1);
    }
    break;
  }
case Notification.ADD_MANY:
{
  EList<?> values=(EList<?>)object.eGet(feature);
  if (children.size() != values.size()) {
    if (notification.getOldValue() != null) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
    List<?> newValues=(List<?>)notification.getNewValue();
    List<Object> newChildren=new ArrayList<Object>(newValues.size());
    int offset=0;
    for (    Object newValue : newValues) {
      newChildren.add(wrap(object,feature,newValue,index + offset++));
    }
    adjustWrapperIndices(children,index,offset);
    children.addAll(index,newChildren);
  }
  break;
}
case Notification.REMOVE_MANY:
{
if (index == Notification.NO_INDEX) index=0;
EList<?> values=(EList<?>)object.eGet(feature);
if (children.size() != values.size()) {
  if (notification.getNewValue() instanceof int[]) {
    int[] indices=(int[])notification.getNewValue();
    for (int i=indices.length - 1; i >= 0; i--) {
      disposeWrapper(children.remove(indices[i]));
      adjustWrapperIndices(children,indices[i],-1);
    }
  }
 else {
    int len=((List<?>)notification.getOldValue()).size();
    List<?> sl=children.subList(index,index + len);
    disposeWrappers(sl);
    sl.clear();
    adjustWrapperIndices(children,index,-len);
  }
}
break;
}
case Notification.MOVE:
{
int oldIndex=((Integer)notification.getOldValue()).intValue();
EList<?> values=(EList<?>)object.eGet(feature);
boolean didMove=true;
for (int i=Math.min(oldIndex,index), end=Math.max(oldIndex,index); didMove && i <= end; i++) {
didMove=unwrap(children.get(i)) == values.get(i);
}
if (!didMove) {
int delta=index - oldIndex;
if (delta < 0) {
  adjustWrapperIndices(children,index,oldIndex,1);
}
children.move(index,oldIndex);
adjustWrapperIndex(children.get(index),delta);
if (delta > 0) {
  adjustWrapperIndices(children,oldIndex,index,-1);
}
}
break;
}
}
}
}
}",0.9984061930783242
11810,"/** 
 * If the given object implements   {@link IWrapperItemProvider}, it is disposed by calling   {@link IWrapperItemProvider#dispose dispose}. It is also removed from   {@link #wrappers}, as it will longer need to be disposed along with this item provider.
 */
protected void disposeWrapper(Object object){
  if (object instanceof IWrapperItemProvider) {
    ((IWrapperItemProvider)object).dispose();
    if (wrappers != null) {
      wrappers.remove(object);
    }
  }
}","/** 
 * If the given object implements   {@link IWrapperItemProvider}, it is disposed by calling   {@link IDisposable#dispose dispose}. It is also removed from   {@link #wrappers}, as it will longer need to be disposed along with this item provider.
 */
protected void disposeWrapper(Object object){
  if (object instanceof IWrapperItemProvider) {
    ((IWrapperItemProvider)object).dispose();
    if (wrappers != null) {
      wrappers.remove(object);
    }
  }
}",0.9690501600853788
11811,"/** 
 * Returns the property image for the specified type. Implementations of   {@link #getPropertyImage getPropertyImage}typically call this method.
 */
protected Object getPropertyImage(Class<?> typeClass){
  if (typeClass == Boolean.TYPE || typeClass == Boolean.class) {
    return ItemPropertyDescriptor.BOOLEAN_VALUE_IMAGE;
  }
 else   if (typeClass == Byte.TYPE || typeClass == Byte.class || typeClass == Integer.TYPE || typeClass == Integer.class || typeClass == Long.TYPE || typeClass == Long.class || typeClass == Short.TYPE || typeClass == Short.class) {
    return ItemPropertyDescriptor.INTEGRAL_VALUE_IMAGE;
  }
 else   if (typeClass == Character.TYPE || typeClass == Character.class || typeClass == String.class) {
    return ItemPropertyDescriptor.TEXT_VALUE_IMAGE;
  }
 else   if (typeClass == Double.TYPE || typeClass == Double.class || typeClass == Float.TYPE || typeClass == Float.class) {
    return ItemPropertyDescriptor.REAL_VALUE_IMAGE;
  }
  return ItemPropertyDescriptor.GENERIC_VALUE_IMAGE;
}","/** 
 * Returns the property image for the specified type. Implementations of   {@link #getPropertyImage() getPropertyImage}typically call this method.
 */
protected Object getPropertyImage(Class<?> typeClass){
  if (typeClass == Boolean.TYPE || typeClass == Boolean.class) {
    return ItemPropertyDescriptor.BOOLEAN_VALUE_IMAGE;
  }
 else   if (typeClass == Byte.TYPE || typeClass == Byte.class || typeClass == Integer.TYPE || typeClass == Integer.class || typeClass == Long.TYPE || typeClass == Long.class || typeClass == Short.TYPE || typeClass == Short.class) {
    return ItemPropertyDescriptor.INTEGRAL_VALUE_IMAGE;
  }
 else   if (typeClass == Character.TYPE || typeClass == Character.class || typeClass == String.class) {
    return ItemPropertyDescriptor.TEXT_VALUE_IMAGE;
  }
 else   if (typeClass == Double.TYPE || typeClass == Double.class || typeClass == Float.TYPE || typeClass == Float.class) {
    return ItemPropertyDescriptor.REAL_VALUE_IMAGE;
  }
  return ItemPropertyDescriptor.GENERIC_VALUE_IMAGE;
}",0.9990196078431371
11812,"/** 
 * This method is invoked after the decrypted input stream is used allowing the Cipher implementation to do any maintenance work required, such as flushing internal cache.
 * @param The inputStream returned by {@link #decrypt(InputStream)}.
 */
void finish(InputStream inputStream) throws Exception ;","/** 
 * This method is invoked after the decrypted input stream is used allowing the Cipher implementation to do any maintenance work required, such as flushing internal cache.
 * @param inputStream the stream returned by {@link #decrypt(InputStream)}.
 */
void finish(InputStream inputStream) throws Exception ;",0.9756888168557536
11813,"/** 
 * Handles the exception thrown during demand load  by recording it as an error diagnostic  and throwing a wrapping runtime exception.
 * @param resource the resource that threw an exception while loading.
 * @param resource the exception thrown from the resource while loading.
 * @see #demandLoadHelper(Resource)
 */
protected void handleDemandLoadException(Resource resource,IOException exception) throws RuntimeException {
  final String location=resource.getURI() == null ? null : resource.getURI().toString();
class DiagnosticWrappedException extends WrappedException implements Resource.Diagnostic {
    private static final long serialVersionUID=1L;
    public DiagnosticWrappedException(    Exception exception){
      super(exception);
    }
    public String getLocation(){
      return location;
    }
    public int getColumn(){
      return 0;
    }
    public int getLine(){
      return 0;
    }
  }
  Exception cause=exception instanceof Resource.IOWrappedException ? (Exception)exception.getCause() : exception;
  DiagnosticWrappedException wrappedException=new DiagnosticWrappedException(cause);
  if (resource.getErrors().isEmpty()) {
    resource.getErrors().add(exception instanceof Resource.Diagnostic ? (Resource.Diagnostic)exception : wrappedException);
  }
  throw wrappedException;
}","/** 
 * Handles the exception thrown during demand load  by recording it as an error diagnostic  and throwing a wrapping runtime exception.
 * @param resource the resource that threw an exception while loading.
 * @param exception the exception thrown from the resource while loading.
 * @see #demandLoadHelper(Resource)
 */
protected void handleDemandLoadException(Resource resource,IOException exception) throws RuntimeException {
  final String location=resource.getURI() == null ? null : resource.getURI().toString();
class DiagnosticWrappedException extends WrappedException implements Resource.Diagnostic {
    private static final long serialVersionUID=1L;
    public DiagnosticWrappedException(    Exception exception){
      super(exception);
    }
    public String getLocation(){
      return location;
    }
    public int getColumn(){
      return 0;
    }
    public int getLine(){
      return 0;
    }
  }
  Exception cause=exception instanceof Resource.IOWrappedException ? (Exception)exception.getCause() : exception;
  DiagnosticWrappedException wrappedException=new DiagnosticWrappedException(cause);
  if (resource.getErrors().isEmpty()) {
    resource.getErrors().add(exception instanceof Resource.Diagnostic ? (Resource.Diagnostic)exception : wrappedException);
  }
  throw wrappedException;
}",0.9935385784872672
11814,"/** 
 * Creates an input stream for the archive paths and returns it. It uses   {@link ArchiveReader} to implement read access.</p>
 * @return an open input stream.
 * @exception IOException if there is a problem obtaining an open input stream.
 */
protected InputStream createArchiveInputStream(URI archiveURI) throws IOException {
  return createArchive(archiveURI).getInputStream();
}","/** 
 * Creates an input stream for the archive paths and returns it. It uses   {@link Archive} to implement read access.</p>
 * @return an open input stream.
 * @exception IOException if there is a problem obtaining an open input stream.
 */
protected InputStream createArchiveInputStream(URI archiveURI) throws IOException {
  return createArchive(archiveURI).getInputStream();
}",0.9921875
11815,"/** 
 * @since 2.3
 * @param eObject
 * @param eReference
 * @param diagnostics
 * @param context
 * @return
 */
protected boolean validate_KeyUnique(EObject eObject,EReference eReference,DiagnosticChain diagnostics,Map<Object,Object> context){
  boolean result=true;
  Map<List<Object>,EObject> keys=new HashMap<List<Object>,EObject>();
  EAttribute[] eAttributes=(EAttribute[])((BasicEList<?>)eReference.getEKeys()).data();
  @SuppressWarnings(""String_Node_Str"") List<EObject> values=(List<EObject>)eObject.eGet(eReference);
  for (  EObject value : values) {
    ArrayList<Object> key=new ArrayList<Object>();
    for (int i=0, size=eAttributes.length; i < size; ++i) {
      EAttribute eAttribute=eAttributes[i];
      if (eAttribute == null) {
        break;
      }
 else {
        key.add(value.eGet(eAttribute));
      }
    }
    EObject otherValue=keys.put(key,value);
    if (otherValue != null) {
      result=false;
      if (diagnostics == null) {
        break;
      }
 else {
        String uriFragmentSegment=((InternalEObject)eObject).eURIFragmentSegment(eReference,value);
        int index=uriFragmentSegment.indexOf('[',0);
        if (index != -1) {
          uriFragmentSegment=uriFragmentSegment.substring(index);
        }
        diagnostics.add(new BasicDiagnostic(Diagnostic.ERROR,DIAGNOSTIC_SOURCE,EOBJECT__EVERY_KEY_UNIQUE,getEcoreResourceLocator().getString(""String_Node_Str"",new Object[]{getFeatureLabel(eReference,context),uriFragmentSegment,getObjectLabel(value,context),getObjectLabel(otherValue,context)}),new Object[]{eObject,eReference,value,otherValue}));
      }
    }
  }
  return result;
}","/** 
 * @since 2.3
 * @param eObject
 * @param eReference
 * @param diagnostics
 * @param context
 * @return whether every key is unique.
 */
protected boolean validate_KeyUnique(EObject eObject,EReference eReference,DiagnosticChain diagnostics,Map<Object,Object> context){
  boolean result=true;
  Map<List<Object>,EObject> keys=new HashMap<List<Object>,EObject>();
  EAttribute[] eAttributes=(EAttribute[])((BasicEList<?>)eReference.getEKeys()).data();
  @SuppressWarnings(""String_Node_Str"") List<EObject> values=(List<EObject>)eObject.eGet(eReference);
  for (  EObject value : values) {
    ArrayList<Object> key=new ArrayList<Object>();
    for (int i=0, size=eAttributes.length; i < size; ++i) {
      EAttribute eAttribute=eAttributes[i];
      if (eAttribute == null) {
        break;
      }
 else {
        key.add(value.eGet(eAttribute));
      }
    }
    EObject otherValue=keys.put(key,value);
    if (otherValue != null) {
      result=false;
      if (diagnostics == null) {
        break;
      }
 else {
        String uriFragmentSegment=((InternalEObject)eObject).eURIFragmentSegment(eReference,value);
        int index=uriFragmentSegment.indexOf('[',0);
        if (index != -1) {
          uriFragmentSegment=uriFragmentSegment.substring(index);
        }
        diagnostics.add(new BasicDiagnostic(Diagnostic.ERROR,DIAGNOSTIC_SOURCE,EOBJECT__EVERY_KEY_UNIQUE,getEcoreResourceLocator().getString(""String_Node_Str"",new Object[]{getFeatureLabel(eReference,context),uriFragmentSegment,getObjectLabel(value,context),getObjectLabel(otherValue,context)}),new Object[]{eObject,eReference,value,otherValue}));
      }
    }
  }
  return result;
}",0.9911934406316428
11816,"/** 
 * @since 2.3
 * @param eObject
 * @param eReference
 * @param diagnostics
 * @param context
 * @return
 */
protected boolean validate_MapEntryUnique(EObject eObject,EReference eReference,DiagnosticChain diagnostics,Map<Object,Object> context){
  boolean result=true;
  Object value=eObject.eGet(eReference);
  if (value instanceof EMap) {
    EMap<?,?> eMap=(EMap<?,?>)value;
    for (int i=0, size=eMap.size(); i < size; ++i) {
      Map.Entry<?,?> entry=eMap.get(i);
      Object key=entry.getKey();
      int index=eMap.indexOfKey(key);
      if (index != i) {
        result=false;
        if (diagnostics == null) {
          break;
        }
 else {
          diagnostics.add(new BasicDiagnostic(Diagnostic.ERROR,DIAGNOSTIC_SOURCE,EOBJECT__EVERY_MAP_ENTRY_UNIQUE,getEcoreResourceLocator().getString(""String_Node_Str"",new Object[]{getFeatureLabel(eReference,context),i,index}),new Object[]{eObject,eReference,entry,eMap.get(index)}));
        }
      }
    }
  }
  return result;
}","/** 
 * @since 2.3
 * @param eObject
 * @param eReference
 * @param diagnostics
 * @param context
 * @return whether every map entry is unique.
 */
protected boolean validate_MapEntryUnique(EObject eObject,EReference eReference,DiagnosticChain diagnostics,Map<Object,Object> context){
  boolean result=true;
  Object value=eObject.eGet(eReference);
  if (value instanceof EMap) {
    EMap<?,?> eMap=(EMap<?,?>)value;
    for (int i=0, size=eMap.size(); i < size; ++i) {
      Map.Entry<?,?> entry=eMap.get(i);
      Object key=entry.getKey();
      int index=eMap.indexOfKey(key);
      if (index != i) {
        result=false;
        if (diagnostics == null) {
          break;
        }
 else {
          diagnostics.add(new BasicDiagnostic(Diagnostic.ERROR,DIAGNOSTIC_SOURCE,EOBJECT__EVERY_MAP_ENTRY_UNIQUE,getEcoreResourceLocator().getString(""String_Node_Str"",new Object[]{getFeatureLabel(eReference,context),i,index}),new Object[]{eObject,eReference,entry,eMap.get(index)}));
        }
      }
    }
  }
  return result;
}",0.9826646854878652
11817,"/** 
 * Creates an instance for the given collection of objects.
 * @param emfObjects the collection of objects to iterate over.
 */
protected ContentTreeIterator(Object object,boolean isResolveProxies){
  super(object,false);
  this.isResolveProxies=isResolveProxies;
}","/** 
 * Creates an instance for the given collection of objects.
 * @param object the collection of objects to iterate over.
 * @param isResolveProxies whether proxies should be resolved during the traversal.
 */
protected ContentTreeIterator(Object object,boolean isResolveProxies){
  super(object,false);
  this.isResolveProxies=isResolveProxies;
}",0.7064516129032258
11818,"/** 
 * Parses a character-class-expression, not a character-class-escape. c-c-expression   ::= '[' c-group ']' c-group          ::= positive-c-group | negative-c-group | c-c-subtraction positive-c-group ::= (c-range | c-c-escape)+ negative-c-group ::= '^' positive-c-group c-c-subtraction  ::= (positive-c-group | negative-c-group) subtraction subtraction      ::= '-' c-c-expression c-range          ::= single-range | from-to-range single-range     ::= multi-c-escape | category-c-escape | block-c-escape | <any XML char> cc-normal-c      ::= <any character except [, ], \> from-to-range    ::= cc-normal-c '-' cc-normal-c
 * @param useNrage Ignored.
 * @return This returns no NrageToken.
 */
@Override protected RangeToken parseCharacterClass(boolean useNrange) throws ParseException {
  this.setContext(S_INBRACKETS);
  this.next();
  RangeToken base=null;
  RangeToken tok;
  if (this.read() == T_CHAR && this.chardata == '^') {
    this.next();
    base=Token.createRange();
    base.addRange(0,Token.UTF16_MAX);
    tok=Token.createRange();
  }
 else {
    tok=Token.createRange();
  }
  int type;
  boolean firstloop=true;
  while ((type=this.read()) != T_EOF) {
    if (type == T_CHAR && this.chardata == ']' && !firstloop) {
      if (base != null) {
        base.subtractRanges(tok);
        tok=base;
      }
      break;
    }
    int c=this.chardata;
    boolean end=false;
    if (type == T_BACKSOLIDUS) {
switch (c) {
case 'd':
case 'D':
case 'w':
case 'W':
case 's':
case 'S':
        tok.mergeRanges(this.getTokenForShorthand(c));
      end=true;
    break;
case 'i':
case 'I':
case 'c':
case 'C':
  c=this.processCIinCharacterClass(tok,c);
if (c < 0) end=true;
break;
case 'p':
case 'P':
int pstart=this.offset;
RangeToken tok2=this.processBacksolidus_pP(c);
if (tok2 == null) throw this.ex(""String_Node_Str"",pstart);
tok.mergeRanges(tok2);
end=true;
break;
default :
c=this.decodeEscaped();
}
}
 else if (type == T_XMLSCHEMA_CC_SUBTRACTION && !firstloop) {
if (base != null) {
base.subtractRanges(tok);
tok=base;
}
RangeToken range2=this.parseCharacterClass(false);
tok.subtractRanges(range2);
if (this.read() != T_CHAR || this.chardata != ']') throw this.ex(""String_Node_Str"",this.offset);
break;
}
this.next();
if (!end) {
if (type == T_CHAR) {
if (c == '[') throw this.ex(""String_Node_Str"",this.offset - 2);
if (c == ']') throw this.ex(""String_Node_Str"",this.offset - 2);
if (c == '-') throw this.ex(""String_Node_Str"",this.offset - 2);
}
if (this.read() != T_CHAR || this.chardata != '-') {
tok.addRange(c,c);
}
 else {
this.next();
if ((type=this.read()) == T_EOF) throw this.ex(""String_Node_Str"",this.offset);
if ((type == T_CHAR && this.chardata == ']') || type == T_XMLSCHEMA_CC_SUBTRACTION) {
throw this.ex(""String_Node_Str"",this.offset - 1);
}
 else {
int rangeend=this.chardata;
if (type == T_CHAR) {
if (rangeend == '[') throw this.ex(""String_Node_Str"",this.offset - 1);
if (rangeend == ']') throw this.ex(""String_Node_Str"",this.offset - 1);
if (rangeend == '-') throw this.ex(""String_Node_Str"",this.offset - 2);
}
 else if (type == T_BACKSOLIDUS) rangeend=this.decodeEscaped();
this.next();
if (c > rangeend) throw this.ex(""String_Node_Str"",this.offset - 1);
tok.addRange(c,rangeend);
}
}
}
firstloop=false;
}
if (this.read() == T_EOF) throw this.ex(""String_Node_Str"",this.offset);
tok.sortRanges();
tok.compactRanges();
this.setContext(S_NORMAL);
this.next();
return tok;
}","/** 
 * Parses a character-class-expression, not a character-class-escape. c-c-expression   ::= '[' c-group ']' c-group          ::= positive-c-group | negative-c-group | c-c-subtraction positive-c-group ::= (c-range | c-c-escape)+ negative-c-group ::= '^' positive-c-group c-c-subtraction  ::= (positive-c-group | negative-c-group) subtraction subtraction      ::= '-' c-c-expression c-range          ::= single-range | from-to-range single-range     ::= multi-c-escape | category-c-escape | block-c-escape | <any XML char> cc-normal-c      ::= <any character except [, ], \> from-to-range    ::= cc-normal-c '-' cc-normal-c
 * @param useNrange Ignored.
 * @return This returns no NrageToken.
 */
@Override protected RangeToken parseCharacterClass(boolean useNrange) throws ParseException {
  this.setContext(S_INBRACKETS);
  this.next();
  RangeToken base=null;
  RangeToken tok;
  if (this.read() == T_CHAR && this.chardata == '^') {
    this.next();
    base=Token.createRange();
    base.addRange(0,Token.UTF16_MAX);
    tok=Token.createRange();
  }
 else {
    tok=Token.createRange();
  }
  int type;
  boolean firstloop=true;
  while ((type=this.read()) != T_EOF) {
    if (type == T_CHAR && this.chardata == ']' && !firstloop) {
      if (base != null) {
        base.subtractRanges(tok);
        tok=base;
      }
      break;
    }
    int c=this.chardata;
    boolean end=false;
    if (type == T_BACKSOLIDUS) {
switch (c) {
case 'd':
case 'D':
case 'w':
case 'W':
case 's':
case 'S':
        tok.mergeRanges(this.getTokenForShorthand(c));
      end=true;
    break;
case 'i':
case 'I':
case 'c':
case 'C':
  c=this.processCIinCharacterClass(tok,c);
if (c < 0) end=true;
break;
case 'p':
case 'P':
int pstart=this.offset;
RangeToken tok2=this.processBacksolidus_pP(c);
if (tok2 == null) throw this.ex(""String_Node_Str"",pstart);
tok.mergeRanges(tok2);
end=true;
break;
default :
c=this.decodeEscaped();
}
}
 else if (type == T_XMLSCHEMA_CC_SUBTRACTION && !firstloop) {
if (base != null) {
base.subtractRanges(tok);
tok=base;
}
RangeToken range2=this.parseCharacterClass(false);
tok.subtractRanges(range2);
if (this.read() != T_CHAR || this.chardata != ']') throw this.ex(""String_Node_Str"",this.offset);
break;
}
this.next();
if (!end) {
if (type == T_CHAR) {
if (c == '[') throw this.ex(""String_Node_Str"",this.offset - 2);
if (c == ']') throw this.ex(""String_Node_Str"",this.offset - 2);
if (c == '-') throw this.ex(""String_Node_Str"",this.offset - 2);
}
if (this.read() != T_CHAR || this.chardata != '-') {
tok.addRange(c,c);
}
 else {
this.next();
if ((type=this.read()) == T_EOF) throw this.ex(""String_Node_Str"",this.offset);
if ((type == T_CHAR && this.chardata == ']') || type == T_XMLSCHEMA_CC_SUBTRACTION) {
throw this.ex(""String_Node_Str"",this.offset - 1);
}
 else {
int rangeend=this.chardata;
if (type == T_CHAR) {
if (rangeend == '[') throw this.ex(""String_Node_Str"",this.offset - 1);
if (rangeend == ']') throw this.ex(""String_Node_Str"",this.offset - 1);
if (rangeend == '-') throw this.ex(""String_Node_Str"",this.offset - 2);
}
 else if (type == T_BACKSOLIDUS) rangeend=this.decodeEscaped();
this.next();
if (c > rangeend) throw this.ex(""String_Node_Str"",this.offset - 1);
tok.addRange(c,rangeend);
}
}
}
firstloop=false;
}
if (this.read() == T_EOF) throw this.ex(""String_Node_Str"",this.offset);
tok.sortRanges();
tok.compactRanges();
this.setContext(S_NORMAL);
this.next();
return tok;
}",0.9998533079067038
11819,"/** 
 * Returns the text associated to be displayed in the detail text when a a dignostic is selected in the tree.
 * @param diagnostic
 * @return a not null String
 */
public String getDetail(Diagnostic diagnostic){
  Throwable throwable=diagnostic.getException();
  if (throwable != null) {
    StringWriter in=new StringWriter();
    PrintWriter ps=new PrintWriter(in);
    throwable.printStackTrace(ps);
    return in.getBuffer().toString();
  }
  for (  Object datum : diagnostic.getData()) {
    if (datum instanceof StringBuilder) {
      return datum.toString();
    }
  }
  return ""String_Node_Str"";
}","/** 
 * Returns the text associated to be displayed in the detail text when a a diagnostic is selected in the tree.
 * @param diagnostic
 * @return a not null String
 */
public String getDetail(Diagnostic diagnostic){
  Throwable throwable=diagnostic.getException();
  if (throwable != null) {
    StringWriter in=new StringWriter();
    PrintWriter ps=new PrintWriter(in);
    throwable.printStackTrace(ps);
    return in.getBuffer().toString();
  }
  for (  Object datum : diagnostic.getData()) {
    if (datum instanceof StringBuilder) {
      return datum.toString();
    }
  }
  return ""String_Node_Str"";
}",0.9991809991809992
11820,"/** 
 * Create a pulldown menu on the action bar.
 */
private void createPulldownMenu(){
  if (systemBar != null) {
    ToolItem ti=new ToolItem(systemBar,SWT.PUSH,0);
    try {
      pullDownImage=ImageDescriptor.createFromURL(new URL(CommonUIPlugin.INSTANCE.getImage(""String_Node_Str"").toString())).createImage();
      ti.setImage(pullDownImage);
      ti.addSelectionListener(new SelectionAdapter(){
        @Override public void widgetSelected(        SelectionEvent e){
          showViewMenu();
        }
      }
);
    }
 catch (    MalformedURLException exception) {
    }
  }
}","/** 
 * Create a pull-down menu on the action bar.
 */
private void createPulldownMenu(){
  if (systemBar != null) {
    ToolItem ti=new ToolItem(systemBar,SWT.PUSH,0);
    try {
      pullDownImage=ImageDescriptor.createFromURL(new URL(CommonUIPlugin.INSTANCE.getImage(""String_Node_Str"").toString())).createImage();
      ti.setImage(pullDownImage);
      ti.addSelectionListener(new SelectionAdapter(){
        @Override public void widgetSelected(        SelectionEvent e){
          showViewMenu();
        }
      }
);
    }
 catch (    MalformedURLException exception) {
    }
  }
}",0.9991489361702128
11821,"/** 
 * Indicates that a property has changed.
 * @param source the object whose property has changed
 * @param propId the id of the property which has changed; property idsare generally defined as constants on the source class
 */
public void propertyChanged(Object source,int propId){
  if (propId == IWorkbenchPart.PROP_TITLE) {
    updateTitles();
  }
}","/** 
 * Indicates that a property has changed.
 * @param source the object whose property has changed
 * @param propID the ID of the property which has changed; property IDsare generally defined as constants on the source class
 */
public void propertyChanged(Object source,int propID){
  if (propID == IWorkbenchPart.PROP_TITLE) {
    updateTitles();
  }
}",0.9663865546218487
11822,"/** 
 * Handles the pressing of the Ok or Details button in this dialog. If the Ok button was pressed then close this dialog. If the Details button was pressed then toggle the displaying of the diagnostic details area. Note that the Details button will only be visible if the diagnostic being displayed specifies child details.
 */
@Override protected void buttonPressed(int id){
  if (id == IDialogConstants.DETAILS_ID) {
    toggleDetailsArea();
  }
 else {
    super.buttonPressed(id);
  }
}","/** 
 * Handles the pressing of the OK or Details button in this dialog. If the OK button was pressed then close this dialog. If the Details button was pressed then toggle the displaying of the diagnostic details area. Note that the Details button will only be visible if the diagnostic being displayed specifies child details.
 */
@Override protected void buttonPressed(int id){
  if (id == IDialogConstants.DETAILS_ID) {
    toggleDetailsArea();
  }
 else {
    super.buttonPressed(id);
  }
}",0.9959514170040484
11823,"/** 
 * Returns the value of the '<em><b>EAttribute Type</b></em>' reference. <!-- begin-user-doc --> <p> The   {@link #getEType type} of an attribute must always be a data type; this method provides access to it.</p> <!-- end-user-doc -->
 * @return the value of the '<em>EAttribute Type</em>' reference.
 * @see org.eclipse.emf.ecore.EcorePackage#getEAttribute_EAttributeType()
 * @model required=""true"" transient=""true"" changeable=""false"" volatile=""true"" derived=""true""
 * @generated
 */
EDataType getEAttributeType();","/** 
 * Returns the value of the '<em><b>EAttribute Type</b></em>' reference. <!-- begin-user-doc --> <p> The   {@link #getEType() type} of an attribute must always be a data type; this method provides access to it.</p> <!-- end-user-doc -->
 * @return the value of the '<em>EAttribute Type</em>' reference.
 * @see org.eclipse.emf.ecore.EcorePackage#getEAttribute_EAttributeType()
 * @model required=""true"" transient=""true"" changeable=""false"" volatile=""true"" derived=""true""
 * @generated
 */
EDataType getEAttributeType();",0.9980842911877394
11824,"/** 
 * Returns the value of the '<em><b>EID Attribute</b></em>' reference. <!-- begin-user-doc --> <p> It represents the attribute that will be used as the ID of an instace.
 * @see org.eclipse.emf.ecore.EAttribute#isID()
 * @ignore </p> <!-- end-user-doc -->
 * @return the value of the '<em>EID Attribute</em>' reference.
 * @see org.eclipse.emf.ecore.EcorePackage#getEClass_EIDAttribute()
 * @model resolveProxies=""false"" transient=""true"" changeable=""false"" volatile=""true"" derived=""true""
 * @generated
 */
EAttribute getEIDAttribute();","/** 
 * Returns the value of the '<em><b>EID Attribute</b></em>' reference. <!-- begin-user-doc --> <p> It represents the attribute that will be used as the ID of an instance.
 * @see org.eclipse.emf.ecore.EAttribute#isID()
 * @ignore </p> <!-- end-user-doc -->
 * @return the value of the '<em>EID Attribute</em>' reference.
 * @see org.eclipse.emf.ecore.EcorePackage#getEClass_EIDAttribute()
 * @model resolveProxies=""false"" transient=""true"" changeable=""false"" volatile=""true"" derived=""true""
 * @generated
 */
EAttribute getEIDAttribute();",0.9990749306197964
11825,"/** 
 * Returns the value of the '<em><b>Serializable</b></em>' attribute. The default value is <code>""true""</code>. <!-- begin-user-doc --> <p> It represents whether values of this type will be   {@link org.eclipse.emf.ecore.resource.Resource#save(java.util.Map) serialized}. For a serializable datatype, there will be factory methods of the form: <pre> String convertXyzToString(EDataType metaObject, Object instanceValue) Object createXyzFromString(EDataType metaObject, String initialValue) </pre> in the generated factory implementation. Clients will typically need to hand write the bodies of these generated methods. </p> <!-- end-user-doc -->
 * @return the value of the '<em>Serializable</em>' attribute.
 * @see #setSerializable(boolean)
 * @see org.eclipse.emf.ecore.EcorePackage#getEDataType_Serializable()
 * @model default=""true""
 * @generated
 */
boolean isSerializable();","/** 
 * Returns the value of the '<em><b>Serializable</b></em>' attribute. The default value is <code>""true""</code>. <!-- begin-user-doc --> <p> It represents whether values of this type will be   {@link org.eclipse.emf.ecore.resource.Resource#save(java.util.Map) serialized}. For a serializable data type, there will be factory methods of the form: <pre> String convertXyzToString(EDataType metaObject, Object instanceValue) Object createXyzFromString(EDataType metaObject, String initialValue) </pre> in the generated factory implementation. Clients will typically need to hand write the bodies of these generated methods. </p> <!-- end-user-doc -->
 * @return the value of the '<em>Serializable</em>' attribute.
 * @see #setSerializable(boolean)
 * @see org.eclipse.emf.ecore.EcorePackage#getEDataType_Serializable()
 * @model default=""true""
 * @generated
 */
boolean isSerializable();",0.99943661971831
11826,"/** 
 * <!-- begin-user-doc --> Returns whether the feature of the object is considered to be set. <p> If the feature is   {@link EStructuralFeature#isMany many-valued}, the value must be an   {@link EList}and the feature is considered set if the list is not empty. If the feature is   {@link EAttribute#isUnsettable unsettable}, the modeled state is directly available and is used. Otherwise,  the   {@link #eGet(EStructuralFeature,boolean) unresolved value} of the feature of the object is compared against the feature's  {@link EStructuralFeature#getDefaultValue() default value}or the   {@link #eClass meta class}'s   {@link EStructuralFeature#getDefaultValue() default value}, as appropriate; the feature is considered set if it's not the same as the default. </p> <p> This property can affect serialization, since defaults are typically omitted in a compact serialization. </p>
 * @param feature the feature in question.
 * @exception IllegalArgumentException if the feature is not one the  {@link #eClass meta class}'s   {@link EClass#getEAllStructuralFeatures features}.
 * @return whether the feature of the object is set.
 * @see #eSet(EStructuralFeature,Object)
 * @see #eUnset(EStructuralFeature)
 * @see #eGet(EStructuralFeature,boolean)
 * @ignore <!-- end-user-doc -->
 * @model
 * @generated
 */
boolean eIsSet(EStructuralFeature feature);","/** 
 * <!-- begin-user-doc --> Returns whether the feature of the object is considered to be set. <p> If the feature is   {@link ETypedElement#isMany() many-valued}, the value must be an   {@link EList}and the feature is considered set if the list is not empty. If the feature is   {@link EStructuralFeature#isUnsettable unsettable}, the modeled state is directly available and is used. Otherwise,  the   {@link #eGet(EStructuralFeature,boolean) unresolved value} of the feature of the object is compared against the feature's  {@link EStructuralFeature#getDefaultValue() default value}or the   {@link #eClass meta class}'s   {@link EStructuralFeature#getDefaultValue() default value}, as appropriate; the feature is considered set if it's not the same as the default. </p> <p> This property can affect serialization, since defaults are typically omitted in a compact serialization. </p>
 * @param feature the feature in question.
 * @exception IllegalArgumentException if the feature is not one the  {@link #eClass meta class}'s   {@link EClass#getEAllStructuralFeatures features}.
 * @return whether the feature of the object is set.
 * @see #eSet(EStructuralFeature,Object)
 * @see #eUnset(EStructuralFeature)
 * @see #eGet(EStructuralFeature,boolean)
 * @ignore <!-- end-user-doc -->
 * @model
 * @generated
 */
boolean eIsSet(EStructuralFeature feature);",0.9797421731123388
11827,"/** 
 * <!-- begin-user-doc --> Indicates whether this object is a proxy. <p>  A proxy is an object that is defined in a <code>Resource</code> that has not been loaded. An object may be a proxy either because proxy resolution was disabled  when the object was accessed (see   {@link #eGet(EStructuralFeature,boolean)}) or because proxy   {@link org.eclipse.emf.ecore.util.EcoreUtil#resolve resolution} failed.</p>
 * @return <code>true</code> if this object is a proxy or <code>false</code>, otherwise.
 * @see Resource#unload
 * @see org.eclipse.emf.ecore.util.EcoreUtil#resolve(EObject,org.eclipse.emf.ecore.resource.ResourceSet)
 * @ignore <!-- end-user-doc -->
 * @model
 * @generated
 */
boolean eIsProxy();","/** 
 * <!-- begin-user-doc --> Indicates whether this object is a proxy. <p>  A proxy is an object that is defined in a <code>Resource</code> that has not been loaded. An object may be a proxy either because proxy resolution was disabled  when the object was accessed (see   {@link #eGet(EStructuralFeature,boolean)}) or because proxy   {@link org.eclipse.emf.ecore.util.EcoreUtil#resolve(EObject,EObject) resolution} failed.</p>
 * @return <code>true</code> if this object is a proxy or <code>false</code>, otherwise.
 * @see Resource#unload
 * @see org.eclipse.emf.ecore.util.EcoreUtil#resolve(EObject,org.eclipse.emf.ecore.resource.ResourceSet)
 * @ignore <!-- end-user-doc -->
 * @model
 * @generated
 */
boolean eIsProxy();",0.9882026370575988
11828,"/** 
 * <!-- begin-user-doc --> Returns the containing object, or <code>null</code>. <p> An object is contained by another object  if it appears in the   {@link #eContents contents} of that object.The object will be contained by a  {@link #eContainmentFeature containment feature} of the containing object.</p>
 * @return the containing object.
 * @see #eResource
 * @see org.eclipse.emf.ecore.util.EcoreUtil#remove(EObject)
 * @see #eContainmentFeature
 * @see #eContainingFeature
 * @see org.eclipse.emf.ecore.util.EcoreUtil#getRootContainer
 * @see #eContents
 * @ignore <!-- end-user-doc -->
 * @model
 * @generated
 */
EObject eContainer();","/** 
 * <!-- begin-user-doc --> Returns the containing object, or <code>null</code>. <p> An object is contained by another object  if it appears in the   {@link #eContents contents} of that object.The object will be contained by a  {@link #eContainmentFeature containment feature} of the containing object.</p>
 * @return the containing object.
 * @see #eResource
 * @see org.eclipse.emf.ecore.util.EcoreUtil#remove(EObject)
 * @see #eContainmentFeature
 * @see #eContainingFeature
 * @see org.eclipse.emf.ecore.util.EcoreUtil#getRootContainer(EObject)
 * @see #eContents
 * @ignore <!-- end-user-doc -->
 * @model
 * @generated
 */
EObject eContainer();",0.9930715935334872
11829,"/** 
 * <!-- begin-user-doc --> Sets the value of the given feature of the object to the new value. <p> If the feature is   {@link EStructuralFeature#isMany many-valued}, the new value must be an   {@link EList}and each object in that list must be   {@link EClassifier#isInstance an instance of} the feature's  {@link EStructuralFeature#getEType type}; the existing contents are cleared and the contents of the new value are added. However, if the new value is the content list itself, or is modified as a side effect of modifying the content list  (i.e., if it is a view on the content list), the behavior is undefined and will likely result in simply clearing the list. If the feature is single-valued, the new value directly must be an instance of the feature's type and it becomes the new value of the feature of the object. If the feature is   {@link EAttribute#isUnsettable unsettable}, the modeled state becomes set; otherwise, the feature may still not considered   {@link #eIsSet set} if the new value is the same as the default.
 * @param feature the feature of the value to set.
 * @exception IllegalArgumentException if the feature is not one the  {@link #eClass meta class}'s   {@link EClass#getEAllStructuralFeatures features}, or it isn't   {@link EStructuralFeature#isChangeable changeable}.
 * @exception ClassCastException if there is a type conflict.
 * @exception ArrayStoreException  if there is a type conflict.
 * @see #eUnset(EStructuralFeature)
 * @see #eIsSet(EStructuralFeature)
 * @see #eGet(EStructuralFeature,boolean)
 * @ignore <!-- end-user-doc -->
 * @model
 * @generated
 */
void eSet(EStructuralFeature feature,Object newValue);","/** 
 * <!-- begin-user-doc --> Sets the value of the given feature of the object to the new value. <p> If the feature is   {@link ETypedElement#isMany() many-valued}, the new value must be an   {@link EList}and each object in that list must be   {@link EClassifier#isInstance an instance of} the feature's  {@link ETypedElement#getEType() type}; the existing contents are cleared and the contents of the new value are added. However, if the new value is the content list itself, or is modified as a side effect of modifying the content list  (i.e., if it is a view on the content list), the behavior is undefined and will likely result in simply clearing the list. If the feature is single-valued, the new value directly must be an instance of the feature's type and it becomes the new value of the feature of the object. If the feature is   {@link EStructuralFeature#isUnsettable() unsettable}, the modeled state becomes set; otherwise, the feature may still not considered   {@link #eIsSet set} if the new value is the same as the default.
 * @param feature the feature of the value to set.
 * @exception IllegalArgumentException if the feature is not one the  {@link #eClass meta class}'s   {@link EClass#getEAllStructuralFeatures features}, or it isn't   {@link EStructuralFeature#isChangeable changeable}.
 * @exception ClassCastException if there is a type conflict.
 * @exception ArrayStoreException  if there is a type conflict.
 * @see #eUnset(EStructuralFeature)
 * @see #eIsSet(EStructuralFeature)
 * @see #eGet(EStructuralFeature,boolean)
 * @ignore <!-- end-user-doc -->
 * @model
 * @generated
 */
void eSet(EStructuralFeature feature,Object newValue);",0.9615615615615616
11830,"/** 
 * <!-- begin-user-doc --> Returns a tree iterator that iterates over all the   {@link #eContents direct contents} and indirect contents of this object.
 * @return a tree iterator that iterates over all contents.
 * @see Resource#getAllContents
 * @see org.eclipse.emf.ecore.util.EcoreUtil#getAllContents
 * @ignore <!-- end-user-doc -->
 * @model
 * @generated
 */
TreeIterator<EObject> eAllContents();","/** 
 * <!-- begin-user-doc --> Returns a tree iterator that iterates over all the   {@link #eContents direct contents} and indirect contents of this object.
 * @return a tree iterator that iterates over all contents.
 * @see Resource#getAllContents
 * @see org.eclipse.emf.ecore.util.EcoreUtil#getAllContents(EObject,boolean)
 * @ignore <!-- end-user-doc -->
 * @model
 * @generated
 */
TreeIterator<EObject> eAllContents();",0.979591836734694
11831,"/** 
 * <!-- begin-user-doc --> Returns the value of the given feature of the object;  the value is optionally   {@link org.eclipse.emf.ecore.util.EcoreUtil#resolve resolved} before it is returned.<p> If the feature is  {@link EStructuralFeature#isMany many-valued}, the result will be an   {@link EList}and each object in the list will be   {@link EClassifier#isInstance an instance of} the feature's  {@link EStructuralFeature#getEType type}; the list's contents are <b>not</b> affected by <code>resolve</code> argument. Otherwise the result directly will be an instance of the feature's type; if it is a   {@link #eIsProxy proxy}, it is resolved.
 * @param feature the feature of the value to fetch.
 * @param resolve whether to resolve.
 * @return the value of the given feature of the object.
 * @exception IllegalArgumentException if the feature is not one the  {@link #eClass meta class}'s   {@link EClass#getEAllStructuralFeatures features}.
 * @see org.eclipse.emf.ecore.util.InternalEList#basicIterator
 * @see org.eclipse.emf.ecore.util.InternalEList#basicList
 * @see org.eclipse.emf.ecore.util.EcoreUtil#resolve(EObject,org.eclipse.emf.ecore.resource.ResourceSet) EcoreUtil.resolve(EObject, org.eclipse.emf.ecore.resource.ResourceSet)
 * @see #eSet(EStructuralFeature,Object)
 * @see #eUnset(EStructuralFeature)
 * @see #eIsSet(EStructuralFeature)
 * @see #eGet(EStructuralFeature)
 * @ignore <!-- end-user-doc -->
 * @model
 * @generated
 */
Object eGet(EStructuralFeature feature,boolean resolve);","/** 
 * <!-- begin-user-doc --> Returns the value of the given feature of the object;  the value is optionally   {@link org.eclipse.emf.ecore.util.EcoreUtil#resolve(EObject,EObject) resolved} before it is returned.<p> If the feature is  {@link ETypedElement#isMany() many-valued}, the result will be an   {@link EList}and each object in the list will be   {@link EClassifier#isInstance an instance of} the feature's  {@link ETypedElement#getEType() type}; the list's contents are <b>not</b> affected by <code>resolve</code> argument. Otherwise the result directly will be an instance of the feature's type; if it is a   {@link #eIsProxy proxy}, it is resolved.
 * @param feature the feature of the value to fetch.
 * @param resolve whether to resolve.
 * @return the value of the given feature of the object.
 * @exception IllegalArgumentException if the feature is not one the  {@link #eClass meta class}'s   {@link EClass#getEAllStructuralFeatures features}.
 * @see org.eclipse.emf.ecore.util.InternalEList#basicIterator
 * @see org.eclipse.emf.ecore.util.InternalEList#basicList
 * @see org.eclipse.emf.ecore.util.EcoreUtil#resolve(EObject,org.eclipse.emf.ecore.resource.ResourceSet) EcoreUtil.resolve(EObject, org.eclipse.emf.ecore.resource.ResourceSet)
 * @see #eSet(EStructuralFeature,Object)
 * @see #eUnset(EStructuralFeature)
 * @see #eIsSet(EStructuralFeature)
 * @see #eGet(EStructuralFeature)
 * @ignore <!-- end-user-doc -->
 * @model
 * @generated
 */
Object eGet(EStructuralFeature feature,boolean resolve);",0.9739703459637562
11832,"/** 
 * <!-- begin-user-doc --> Unsets the feature of the object. <p> If the feature is   {@link EStructuralFeature#isMany many-valued}, the value must be an   {@link EList}and that list is cleared. Otherwise,  the value of the feature of the object  is set to the feature's   {@link EStructuralFeature#getDefaultValue() default value}or the   {@link #eClass meta class}'s   {@link EStructuralFeature#getDefaultValue() default value}, as appropriate. If the feature is   {@link EAttribute#isUnsettable unsettable}, the modeled state becomes unset. In any case, the feature will no longer be considered   {@link #eIsSet set}. </p>
 * @param feature the feature in question.
 * @exception IllegalArgumentException if the feature is not one the  {@link #eClass meta class}'s   {@link EClass#getEAllStructuralFeatures features}, or it isn't   {@link EStructuralFeature#isChangeable changeable}.
 * @see #eIsSet(EStructuralFeature)
 * @see #eSet(EStructuralFeature,Object)
 * @see #eGet(EStructuralFeature,boolean)
 * @ignore <!-- end-user-doc -->
 * @model
 * @generated
 */
void eUnset(EStructuralFeature feature);","/** 
 * <!-- begin-user-doc --> Unsets the feature of the object. <p> If the feature is   {@link ETypedElement#isMany() many-valued}, the value must be an   {@link EList}and that list is cleared. Otherwise,  the value of the feature of the object  is set to the feature's   {@link EStructuralFeature#getDefaultValue() default value}or the   {@link #eClass meta class}'s   {@link EStructuralFeature#getDefaultValue() default value}, as appropriate. If the feature is   {@link EStructuralFeature#isUnsettable() unsettable}, the modeled state becomes unset. In any case, the feature will no longer be considered   {@link #eIsSet set}. </p>
 * @param feature the feature in question.
 * @exception IllegalArgumentException if the feature is not one the  {@link #eClass meta class}'s   {@link EClass#getEAllStructuralFeatures features}, or it isn't   {@link EStructuralFeature#isChangeable changeable}.
 * @see #eIsSet(EStructuralFeature)
 * @see #eSet(EStructuralFeature,Object)
 * @see #eGet(EStructuralFeature,boolean)
 * @ignore <!-- end-user-doc -->
 * @model
 * @generated
 */
void eUnset(EStructuralFeature feature);",0.9627635711081204
11833,"/** 
 * Returns the value of the '<em><b>Ns Prefix</b></em>' attribute. <!-- begin-user-doc --> <p> It represents the prefered XMLNS prefix to be used for this package's the   {@link #getNsURI namespace URI}. It will be used in an XMI serialization. </p> <!-- end-user-doc -->
 * @return the value of the '<em>Ns Prefix</em>' attribute.
 * @see #setNsPrefix(String)
 * @see org.eclipse.emf.ecore.EcorePackage#getEPackage_NsPrefix()
 * @model
 * @generated
 */
String getNsPrefix();","/** 
 * Returns the value of the '<em><b>Ns Prefix</b></em>' attribute. <!-- begin-user-doc --> <p> It represents the preferred XMLNS prefix to be used for this package's the   {@link #getNsURI namespace URI}. It will be used in an XMI serialization. </p> <!-- end-user-doc -->
 * @return the value of the '<em>Ns Prefix</em>' attribute.
 * @see #setNsPrefix(String)
 * @see org.eclipse.emf.ecore.EcorePackage#getEPackage_NsPrefix()
 * @model
 * @generated
 */
String getNsPrefix();",0.9989615784008308
11834,"/** 
 * Returns the value of the '<em><b>EClassifiers</b></em>' containment reference list. The list contents are of type   {@link org.eclipse.emf.ecore.EClassifier}. It is bidirectional and its opposite is '  {@link org.eclipse.emf.ecore.EClassifier#getEPackage <em>EPackage</em>}'. <!-- begin-user-doc --> <p> It represents the meta objects, i.e., classes and datatypes, defined in this package. </p> <!-- end-user-doc -->
 * @return the value of the '<em>EClassifiers</em>' containment reference list.
 * @see org.eclipse.emf.ecore.EcorePackage#getEPackage_EClassifiers()
 * @see org.eclipse.emf.ecore.EClassifier#getEPackage
 * @model opposite=""ePackage"" containment=""true"" resolveProxies=""true""
 * @generated
 */
EList<EClassifier> getEClassifiers();","/** 
 * Returns the value of the '<em><b>EClassifiers</b></em>' containment reference list. The list contents are of type   {@link org.eclipse.emf.ecore.EClassifier}. It is bidirectional and its opposite is '  {@link org.eclipse.emf.ecore.EClassifier#getEPackage <em>EPackage</em>}'. <!-- begin-user-doc --> <p> It represents the meta objects, i.e., classes and data types, defined in this package. </p> <!-- end-user-doc -->
 * @return the value of the '<em>EClassifiers</em>' containment reference list.
 * @see org.eclipse.emf.ecore.EcorePackage#getEPackage_EClassifiers()
 * @see org.eclipse.emf.ecore.EClassifier#getEPackage
 * @model opposite=""ePackage"" containment=""true"" resolveProxies=""true""
 * @generated
 */
EList<EClassifier> getEClassifiers();",0.99933818663137
11835,"/** 
 * Returns the value of the '<em><b>EReference Type</b></em>' reference. <!-- begin-user-doc --> <p> The   {@link #getEType type} of a reference must always be a class; this method provides access to it.</p> <!-- end-user-doc -->
 * @return the value of the '<em>EReference Type</em>' reference.
 * @see org.eclipse.emf.ecore.EcorePackage#getEReference_EReferenceType()
 * @model required=""true"" transient=""true"" changeable=""false"" volatile=""true"" derived=""true""
 * @generated
 */
EClass getEReferenceType();","/** 
 * Returns the value of the '<em><b>EReference Type</b></em>' reference. <!-- begin-user-doc --> <p> The   {@link #getEType() type} of a reference must always be a class; this method provides access to it.</p> <!-- end-user-doc -->
 * @return the value of the '<em>EReference Type</em>' reference.
 * @see org.eclipse.emf.ecore.EcorePackage#getEReference_EReferenceType()
 * @model required=""true"" transient=""true"" changeable=""false"" volatile=""true"" derived=""true""
 * @generated
 */
EClass getEReferenceType();",0.9980544747081712
11836,"/** 
 * Returns the value held by the feature of the object; it optionally   {@link org.eclipse.emf.ecore.util.EcoreUtil#resolve resolves} the value.
 * @param resolve whether to resolve.
 * @return the value held by the feature of the object.
 * @see EObject#eGet(EStructuralFeature,boolean)
 */
Object get(boolean resolve);","/** 
 * Returns the value held by the feature of the object; it optionally   {@link org.eclipse.emf.ecore.util.EcoreUtil#resolve(EObject,EObject) resolves} the value.
 * @param resolve whether to resolve.
 * @return the value held by the feature of the object.
 * @see EObject#eGet(EStructuralFeature,boolean)
 */
Object get(boolean resolve);",0.974512743628186
11837,"/** 
 * This supports a non-headless invocation. The variable VABASE or ECLIPSE.
 * @deprecated It is not possible to generate code withtout using Eclipse.  Ifyou are invoking this method, you should instantiate a Generator and call {@link #run(Object)}.  This method will be removed in a future release.
 */
@Deprecated public static void main(String args[]){
  new Generator().run(args);
}","/** 
 * This supports a non-headless invocation. The variable VABASE or ECLIPSE.
 * @deprecated It is not possible to generate code without using Eclipse.  Ifyou are invoking this method, you should instantiate a Generator and call {@link #run(Object)}.  This method will be removed in a future release.
 */
@Deprecated public static void main(String args[]){
  new Generator().run(args);
}",0.998719590268886
11838,"/** 
 * If code can be generated for the object, as determined by   {@link #canGenerate(Object,Object)}, delegates code generation to   {@link #doGenerate(Object,Object,Monitor)}. Otherwise, simply returns  {@link Diagnostic#OK_INSTANCE OK}. The object is cached as   {@link #generatingObject} and the {@link #message} iscleared before calling  {@link #doGenerate(Object,Object,Monitor)}; both are cleared again afterwards.
 * @link #canGenerate(Object, Object)
 * @link #doGenerate(Object, Object, Monitor)
 */
public final Diagnostic generate(Object object,Object projectType,Monitor monitor){
  try {
    if (canGenerate(object,projectType)) {
      generatingObject=object;
      message=null;
      return doGenerate(object,projectType,monitor);
    }
    return Diagnostic.OK_INSTANCE;
  }
 catch (  Exception exception) {
    return toDiagnostic(exception,message);
  }
 finally {
    generatingObject=null;
    message=null;
    monitor.done();
  }
}","/** 
 * If code can be generated for the object, as determined by   {@link #canGenerate(Object,Object)}, delegates code generation to   {@link #doGenerate(Object,Object,Monitor)}. Otherwise, simply returns  {@link Diagnostic#OK_INSTANCE OK}. The object is cached as   {@link #generatingObject} and the {@link #message} iscleared before calling  {@link #doGenerate(Object,Object,Monitor)}; both are cleared again afterwards.
 * @see #canGenerate(Object,Object)
 * @see #doGenerate(Object,Object,Monitor)
 */
public final Diagnostic generate(Object object,Object projectType,Monitor monitor){
  try {
    if (canGenerate(object,projectType)) {
      generatingObject=object;
      message=null;
      return doGenerate(object,projectType,monitor);
    }
    return Diagnostic.OK_INSTANCE;
  }
 catch (  Exception exception) {
    return toDiagnostic(exception,message);
  }
 finally {
    generatingObject=null;
    message=null;
    monitor.done();
  }
}",0.9837781266352696
11839,"/** 
 * If   {@link Generator.Options#dynamicTemplates dynamic templates} are not being used, attempts to set the emitter touse an existing, pre-compiled template class.
 */
protected void setStaticTemplateClass(JETEmitter jetEmitter,String className){
  if (!getGenerator().getOptions().dynamicTemplates) {
    try {
      Class<?> templateClass=getClass().getClassLoader().loadClass(className);
      Method emitterMethod=templateClass.getDeclaredMethod(""String_Node_Str"",OBJECT_ARGUMENT);
      jetEmitter.setMethod(emitterMethod);
    }
 catch (    Exception exception) {
    }
  }
}","/** 
 * If   {@link Generator.Options#dynamicTemplates dynamic templates} are not being used, attempts to set the emitter touse an existing, precompiled template class.
 */
protected void setStaticTemplateClass(JETEmitter jetEmitter,String className){
  if (!getGenerator().getOptions().dynamicTemplates) {
    try {
      Class<?> templateClass=getClass().getClassLoader().loadClass(className);
      Method emitterMethod=templateClass.getDeclaredMethod(""String_Node_Str"",OBJECT_ARGUMENT);
      jetEmitter.setMethod(emitterMethod);
    }
 catch (    Exception exception) {
    }
  }
}",0.9991474850809888
11840,"/** 
 * Creates and returns a sub-monitor for the given progress monitor. When running standalone, the same monitor is actually returned.
 * @param monitor the parent monitor
 * @param ticks the number of work ticks allocated from the parent monitor
 */
protected Monitor createMonitor(Monitor monitor,int ticks){
  return CodeGenUtil.createMonitor(monitor,ticks);
}","/** 
 * Creates and returns a sub-monitor for the given progress monitor. When running stand-alone, the same monitor is actually returned.
 * @param monitor the parent monitor
 * @param ticks the number of work ticks allocated from the parent monitor
 */
protected Monitor createMonitor(Monitor monitor,int ticks){
  return CodeGenUtil.createMonitor(monitor,ticks);
}",0.9986357435197816
11841,"/** 
 * Generates an arbitrary text artifact using JET.
 * @param targetPathName the path name of the target file. This should be a workspace path; when running standalone,it will be converted to a platform resource URI that should be mapped to a physical file URI by the {@link #getURIConverter() URIConverter}.
 * @param jetEmitter the <code>JETEmitter</code> to use for generating the text.
 * @param arguments the argument array to pass to the <code>JETEmitter</code>'s{@link JETEmitter#generate(Monitor,Object[]) generate(Monitor, Object[])} method. If null, an array willbe constructed containing only the  {@link #generatingObject object} for which code is being generated. 
 * @param overwrite whether an existing file should be overritten.
 * @param encoding an override of the default encoding. If ""ISO-8859-1"" is specified,{@link org.eclipse.emf.codegen.util.CodeGenUtil#unicodeEscapeEncode(String) Unicode escape encoding}  is performed to represent non-Latin characters. The default encoding, when running under Eclipse, is determined from the workspace. Failing that, or in standalone, the platform default is used.
 * @param monitor the <code>Monitor</code> through which to report progress.<p>This method also consults the following  {@link Generator#getOptions() generator options}: <ul> <li>  {@link Generator.Options#redirectionPattern redirectionPattern}<li>  {@link Generator.Options#forceOverwrite forceOverwrite}<li>  {@link Generator.Options#dynamicTemplates dynamicTemplates}<li>  {@link Generator.Options#resourceSet resourceSet}</ul>
 */
protected void generateText(String targetPathName,JETEmitter jetEmitter,Object[] arguments,boolean overwrite,String encoding,Monitor monitor){
  try {
    monitor.beginTask(""String_Node_Str"",3);
    URI targetFile=toURI(targetPathName);
    monitor.subTask(CodeGenEcorePlugin.INSTANCE.getString(""String_Node_Str"",new Object[]{targetFile}));
    URI targetDirectory=targetFile.trimSegments(1);
    ensureContainerExists(targetDirectory,createMonitor(monitor,1));
    boolean exists=exists(targetFile);
    if (!exists || overwrite) {
      if (arguments == null) {
        arguments=new Object[]{generatingObject};
      }
      setLineDelimiter(getLineDelimiter(targetFile,encoding));
      String emitterResult=jetEmitter.generate(createMonitor(monitor,1),arguments,getLineDelimiter());
      if (PROPERTIES_ENCODING.equals(encoding)) {
        emitterResult=CodeGenUtil.unicodeEscapeEncode(emitterResult);
      }
      if (encoding == null) {
        encoding=getEncoding(targetFile);
      }
      boolean changed=true;
      if (exists) {
        monitor.subTask(CodeGenEcorePlugin.INSTANCE.getString(""String_Node_Str"",new Object[]{targetFile}));
        String oldContents=getContents(targetFile,encoding);
        changed=!emitterResult.equals(oldContents);
      }
      if (changed) {
        byte[] bytes=encoding == null ? emitterResult.toString().getBytes() : emitterResult.toString().getBytes(encoding);
        String redirection=getGenerator().getOptions().redirectionPattern;
        boolean redirect=redirection != null && redirection.indexOf(""String_Node_Str"") != -1;
        if (redirect) {
          String baseName=MessageFormat.format(redirection,new Object[]{targetFile.lastSegment()});
          targetFile=targetDirectory.appendSegment(baseName);
          monitor.subTask(CodeGenEcorePlugin.INSTANCE.getString(""String_Node_Str"",new Object[]{targetFile}));
        }
        if (isReadOnly(targetFile)) {
          if (getGenerator().getOptions().forceOverwrite) {
            validateEdit(targetFile,createMonitor(monitor,1));
            setWriteable(targetFile);
          }
 else {
            targetFile=targetDirectory.appendSegment(""String_Node_Str"" + targetFile.lastSegment() + ""String_Node_Str"");
            monitor.subTask(CodeGenEcorePlugin.INSTANCE.getString(""String_Node_Str"",new Object[]{targetFile}));
          }
        }
        OutputStream outputStream=createOutputStream(targetFile);
        outputStream.write(bytes);
        outputStream.close();
      }
    }
  }
 catch (  Exception exception) {
    CodeGenEcorePlugin.INSTANCE.log(exception);
  }
 finally {
    setLineDelimiter(null);
    monitor.done();
  }
}","/** 
 * Generates an arbitrary text artifact using JET.
 * @param targetPathName the path name of the target file. This should be a workspace path; when running stand-alone,it will be converted to a platform resource URI that should be mapped to a physical file URI by the {@link #getURIConverter() URIConverter}.
 * @param jetEmitter the <code>JETEmitter</code> to use for generating the text.
 * @param arguments the argument array to pass to the <code>JETEmitter</code>'s{@link JETEmitter#generate(Monitor,Object[]) generate(Monitor, Object[])} method. If null, an array willbe constructed containing only the  {@link #generatingObject object} for which code is being generated. 
 * @param overwrite whether an existing file should be overwritten.
 * @param encoding an override of the default encoding. If ""ISO-8859-1"" is specified,{@link org.eclipse.emf.codegen.util.CodeGenUtil#unicodeEscapeEncode(String) Unicode escape encoding}  is performed to represent non-Latin characters. The default encoding, when running under Eclipse, is determined from the workspace. Failing that, or in stand-alone, the platform default is used.
 * @param monitor the <code>Monitor</code> through which to report progress.<p>This method also consults the following  {@link Generator#getOptions() generator options}: <ul> <li>  {@link Generator.Options#redirectionPattern redirectionPattern}<li>  {@link Generator.Options#forceOverwrite forceOverwrite}<li>  {@link Generator.Options#dynamicTemplates dynamicTemplates}<li>  {@link Generator.Options#resourceSet resourceSet}</ul>
 */
protected void generateText(String targetPathName,JETEmitter jetEmitter,Object[] arguments,boolean overwrite,String encoding,Monitor monitor){
  try {
    monitor.beginTask(""String_Node_Str"",3);
    URI targetFile=toURI(targetPathName);
    monitor.subTask(CodeGenEcorePlugin.INSTANCE.getString(""String_Node_Str"",new Object[]{targetFile}));
    URI targetDirectory=targetFile.trimSegments(1);
    ensureContainerExists(targetDirectory,createMonitor(monitor,1));
    boolean exists=exists(targetFile);
    if (!exists || overwrite) {
      if (arguments == null) {
        arguments=new Object[]{generatingObject};
      }
      setLineDelimiter(getLineDelimiter(targetFile,encoding));
      String emitterResult=jetEmitter.generate(createMonitor(monitor,1),arguments,getLineDelimiter());
      if (PROPERTIES_ENCODING.equals(encoding)) {
        emitterResult=CodeGenUtil.unicodeEscapeEncode(emitterResult);
      }
      if (encoding == null) {
        encoding=getEncoding(targetFile);
      }
      boolean changed=true;
      if (exists) {
        monitor.subTask(CodeGenEcorePlugin.INSTANCE.getString(""String_Node_Str"",new Object[]{targetFile}));
        String oldContents=getContents(targetFile,encoding);
        changed=!emitterResult.equals(oldContents);
      }
      if (changed) {
        byte[] bytes=encoding == null ? emitterResult.toString().getBytes() : emitterResult.toString().getBytes(encoding);
        String redirection=getGenerator().getOptions().redirectionPattern;
        boolean redirect=redirection != null && redirection.indexOf(""String_Node_Str"") != -1;
        if (redirect) {
          String baseName=MessageFormat.format(redirection,new Object[]{targetFile.lastSegment()});
          targetFile=targetDirectory.appendSegment(baseName);
          monitor.subTask(CodeGenEcorePlugin.INSTANCE.getString(""String_Node_Str"",new Object[]{targetFile}));
        }
        if (isReadOnly(targetFile)) {
          if (getGenerator().getOptions().forceOverwrite) {
            validateEdit(targetFile,createMonitor(monitor,1));
            setWriteable(targetFile);
          }
 else {
            targetFile=targetDirectory.appendSegment(""String_Node_Str"" + targetFile.lastSegment() + ""String_Node_Str"");
            monitor.subTask(CodeGenEcorePlugin.INSTANCE.getString(""String_Node_Str"",new Object[]{targetFile}));
          }
        }
        OutputStream outputStream=createOutputStream(targetFile);
        outputStream.write(bytes);
        outputStream.close();
      }
    }
  }
 catch (  Exception exception) {
    CodeGenEcorePlugin.INSTANCE.log(exception);
  }
 finally {
    setLineDelimiter(null);
    monitor.done();
  }
}",0.9996453481498996
11842,"/** 
 * Generates a properties file using JET, with   {@link org.eclipse.emf.codegen.merge.properties.PropertyMerger merging}capability. <p>The encoding used for the generated file is ""ISO-8859-1"".  {@link org.eclipse.emf.codegen.util.CodeGenUtil#unicodeEscapeEncode(String) Unicode escape encoding} isperformed to represent non-Latin characters.
 * @param targetPathName the path name of the target file. This should be a workspace path; when running standalone,it will be converted to a platform resource URI that should be mapped to a physical file URI by the {@link #getURIConverter() URIConverter}.
 * @param jetEmitter the <code>JETEmitter</code> to use for generating the text.
 * @param arguments the argument array to pass to the <code>JETEmitter</code>'s{@link JETEmitter#generate(Monitor,Object[]) generate(Monitor, Object[])} method. If null, an array willbe constructed containing only the  {@link #generatingObject object} for which code is being generated. 
 * @param monitor the <code>Monitor</code> through which to report progress.<p>This method also consults the following  {@link Generator#getOptions() generator options}: <ul> <li>  {@link Generator.Options#redirectionPattern redirectionPattern}<li>  {@link Generator.Options#forceOverwrite forceOverwrite}<li>  {@link Generator.Options#dynamicTemplates dynamicTemplates}<li>  {@link Generator.Options#resourceSet resourceSet}</ul>
 */
protected void generateProperties(String targetPathName,JETEmitter jetEmitter,Object[] arguments,Monitor monitor){
  try {
    monitor.beginTask(""String_Node_Str"",3);
    URI targetFile=toURI(targetPathName);
    monitor.subTask(CodeGenEcorePlugin.INSTANCE.getString(""String_Node_Str"",new Object[]{targetFile}));
    URI targetDirectory=targetFile.trimSegments(1);
    ensureContainerExists(targetDirectory,createMonitor(monitor,1));
    boolean changed=false;
    if (arguments == null) {
      arguments=new Object[]{generatingObject};
    }
    setLineDelimiter(getLineDelimiter(targetFile,PROPERTIES_ENCODING));
    String emitterResult=CodeGenUtil.unicodeEscapeEncode(jetEmitter.generate(createMonitor(monitor,1),arguments,getLineDelimiter()));
    byte[] bytes=emitterResult.toString().getBytes(PROPERTIES_ENCODING);
    if (exists(targetFile)) {
      PropertyMerger propertyMerger=new PropertyMerger();
      propertyMerger.setSourceProperties(emitterResult);
      monitor.subTask(CodeGenEcorePlugin.INSTANCE.getString(""String_Node_Str"",new Object[]{targetFile}));
      String oldProperties=propertyMerger.createPropertiesForInputStream(createInputStream(targetFile));
      propertyMerger.setTargetProperties(oldProperties);
      monitor.subTask(CodeGenEcorePlugin.INSTANCE.getString(""String_Node_Str"",new Object[]{targetFile}));
      propertyMerger.merge();
      String mergedResult=propertyMerger.getTargetProperties();
      changed=!mergedResult.equals(oldProperties);
      if (changed) {
        if (isReadOnly(targetFile) && validateEdit(targetFile,createMonitor(monitor,1))) {
          propertyMerger.setTargetProperties(propertyMerger.createPropertiesForInputStream(createInputStream(targetFile)));
          propertyMerger.merge();
          mergedResult=propertyMerger.getTargetProperties();
        }
        bytes=mergedResult.getBytes(PROPERTIES_ENCODING);
      }
    }
 else {
      changed=true;
      monitor.worked(1);
    }
    if (changed) {
      String redirection=getGenerator().getOptions().redirectionPattern;
      boolean redirect=redirection != null && redirection.indexOf(""String_Node_Str"") != -1;
      if (redirect) {
        String baseName=MessageFormat.format(redirection,new Object[]{targetFile.lastSegment()});
        targetFile=targetDirectory.appendSegment(baseName);
        monitor.subTask(CodeGenEcorePlugin.INSTANCE.getString(""String_Node_Str"",new Object[]{targetFile}));
      }
      if (isReadOnly(targetFile)) {
        if (getGenerator().getOptions().forceOverwrite) {
          setWriteable(targetFile);
        }
 else {
          targetFile=targetDirectory.appendSegment(""String_Node_Str"" + targetFile.lastSegment() + ""String_Node_Str"");
          monitor.subTask(CodeGenEcorePlugin.INSTANCE.getString(""String_Node_Str"",new Object[]{targetFile}));
        }
      }
      OutputStream outputStream=createOutputStream(targetFile);
      outputStream.write(bytes);
      outputStream.close();
    }
  }
 catch (  Exception exception) {
    CodeGenEcorePlugin.INSTANCE.log(exception);
  }
 finally {
    setLineDelimiter(null);
    monitor.done();
  }
}","/** 
 * Generates a properties file using JET, with   {@link org.eclipse.emf.codegen.merge.properties.PropertyMerger merging}capability. <p>The encoding used for the generated file is ""ISO-8859-1"".  {@link org.eclipse.emf.codegen.util.CodeGenUtil#unicodeEscapeEncode(String) Unicode escape encoding} isperformed to represent non-Latin characters.
 * @param targetPathName the path name of the target file. This should be a workspace path; when running stand-alone,it will be converted to a platform resource URI that should be mapped to a physical file URI by the {@link #getURIConverter() URIConverter}.
 * @param jetEmitter the <code>JETEmitter</code> to use for generating the text.
 * @param arguments the argument array to pass to the <code>JETEmitter</code>'s{@link JETEmitter#generate(Monitor,Object[]) generate(Monitor, Object[])} method. If null, an array willbe constructed containing only the  {@link #generatingObject object} for which code is being generated. 
 * @param monitor the <code>Monitor</code> through which to report progress.<p>This method also consults the following  {@link Generator#getOptions() generator options}: <ul> <li>  {@link Generator.Options#redirectionPattern redirectionPattern}<li>  {@link Generator.Options#forceOverwrite forceOverwrite}<li>  {@link Generator.Options#dynamicTemplates dynamicTemplates}<li>  {@link Generator.Options#resourceSet resourceSet}</ul>
 */
protected void generateProperties(String targetPathName,JETEmitter jetEmitter,Object[] arguments,Monitor monitor){
  try {
    monitor.beginTask(""String_Node_Str"",3);
    URI targetFile=toURI(targetPathName);
    monitor.subTask(CodeGenEcorePlugin.INSTANCE.getString(""String_Node_Str"",new Object[]{targetFile}));
    URI targetDirectory=targetFile.trimSegments(1);
    ensureContainerExists(targetDirectory,createMonitor(monitor,1));
    boolean changed=false;
    if (arguments == null) {
      arguments=new Object[]{generatingObject};
    }
    setLineDelimiter(getLineDelimiter(targetFile,PROPERTIES_ENCODING));
    String emitterResult=CodeGenUtil.unicodeEscapeEncode(jetEmitter.generate(createMonitor(monitor,1),arguments,getLineDelimiter()));
    byte[] bytes=emitterResult.toString().getBytes(PROPERTIES_ENCODING);
    if (exists(targetFile)) {
      PropertyMerger propertyMerger=new PropertyMerger();
      propertyMerger.setSourceProperties(emitterResult);
      monitor.subTask(CodeGenEcorePlugin.INSTANCE.getString(""String_Node_Str"",new Object[]{targetFile}));
      String oldProperties=propertyMerger.createPropertiesForInputStream(createInputStream(targetFile));
      propertyMerger.setTargetProperties(oldProperties);
      monitor.subTask(CodeGenEcorePlugin.INSTANCE.getString(""String_Node_Str"",new Object[]{targetFile}));
      propertyMerger.merge();
      String mergedResult=propertyMerger.getTargetProperties();
      changed=!mergedResult.equals(oldProperties);
      if (changed) {
        if (isReadOnly(targetFile) && validateEdit(targetFile,createMonitor(monitor,1))) {
          propertyMerger.setTargetProperties(propertyMerger.createPropertiesForInputStream(createInputStream(targetFile)));
          propertyMerger.merge();
          mergedResult=propertyMerger.getTargetProperties();
        }
        bytes=mergedResult.getBytes(PROPERTIES_ENCODING);
      }
    }
 else {
      changed=true;
      monitor.worked(1);
    }
    if (changed) {
      String redirection=getGenerator().getOptions().redirectionPattern;
      boolean redirect=redirection != null && redirection.indexOf(""String_Node_Str"") != -1;
      if (redirect) {
        String baseName=MessageFormat.format(redirection,new Object[]{targetFile.lastSegment()});
        targetFile=targetDirectory.appendSegment(baseName);
        monitor.subTask(CodeGenEcorePlugin.INSTANCE.getString(""String_Node_Str"",new Object[]{targetFile}));
      }
      if (isReadOnly(targetFile)) {
        if (getGenerator().getOptions().forceOverwrite) {
          setWriteable(targetFile);
        }
 else {
          targetFile=targetDirectory.appendSegment(""String_Node_Str"" + targetFile.lastSegment() + ""String_Node_Str"");
          monitor.subTask(CodeGenEcorePlugin.INSTANCE.getString(""String_Node_Str"",new Object[]{targetFile}));
        }
      }
      OutputStream outputStream=createOutputStream(targetFile);
      outputStream.write(bytes);
      outputStream.close();
    }
  }
 catch (  Exception exception) {
    CodeGenEcorePlugin.INSTANCE.log(exception);
  }
 finally {
    setLineDelimiter(null);
    monitor.done();
  }
}",0.9998895149707214
11843,"/** 
 * Generates an icon using a   {@link org.eclipse.emf.codegen.util.GIFEmitter GIFEmitter} to colourize a grey-scale GIFimage. The colours to use are calculated from one or, optionally, two text keys. 
 * @param targetPathName the path name of the target file. This should be a workspace path; when running standalone,it will be converted to a platform resource URI that should be mapped to a physical file URI by the {@link #getURIConverter() URIConverter}.
 * @param gifEmitter the <code>GIFEmitter</code> to use for generating the icon.
 * @param parentKey the key used to determine the first colour set.
 * @param childKey the key used to determine the second colour set. If null, this key is ignored.
 * @param overwrite whether an existing file should be overritten.
 * @param monitor the <code>Monitor</code> through which to report progress.<p>This method also consults the following  {@link Generator#getOptions() generator options}: <ul> <li>  {@link Generator.Options#redirectionPattern redirectionPattern}<li>  {@link Generator.Options#forceOverwrite forceOverwrite}<li>  {@link Generator.Options#resourceSet resourceSet}</ul>
 */
protected void generateGIF(String targetPathName,GIFEmitter gifEmitter,String parentKey,String childKey,boolean overwrite,Monitor monitor){
  try {
    monitor.beginTask(""String_Node_Str"",3);
    URI targetFile=toURI(targetPathName);
    monitor.subTask(CodeGenEcorePlugin.INSTANCE.getString(""String_Node_Str"",new Object[]{targetFile}));
    URI targetDirectory=targetFile.trimSegments(1);
    ensureContainerExists(targetDirectory,createMonitor(monitor,1));
    boolean exists=exists(targetFile);
    if (!exists || overwrite) {
      byte[] emitterResult=gifEmitter.generateGIF(parentKey,childKey);
      monitor.worked(1);
      String redirection=getGenerator().getOptions().redirectionPattern;
      boolean redirect=redirection != null && redirection.indexOf(""String_Node_Str"") != -1;
      if (redirect) {
        String baseName=MessageFormat.format(redirection,new Object[]{targetFile.lastSegment()});
        targetFile=targetDirectory.appendSegment(baseName);
        monitor.subTask(CodeGenEcorePlugin.INSTANCE.getString(""String_Node_Str"",new Object[]{targetFile}));
      }
      if (isReadOnly(targetFile)) {
        if (getGenerator().getOptions().forceOverwrite) {
          validateEdit(targetFile,createMonitor(monitor,1));
          setWriteable(targetFile);
        }
 else {
          targetFile=targetDirectory.appendSegment(""String_Node_Str"" + targetFile.lastSegment() + ""String_Node_Str"");
          monitor.subTask(CodeGenEcorePlugin.INSTANCE.getString(""String_Node_Str"",new Object[]{targetFile}));
        }
      }
      OutputStream outputStream=createOutputStream(targetFile);
      outputStream.write(emitterResult);
      outputStream.close();
    }
  }
 catch (  Exception exception) {
    CodeGenEcorePlugin.INSTANCE.log(exception);
  }
 finally {
    monitor.done();
  }
}","/** 
 * Generates an icon using a   {@link org.eclipse.emf.codegen.util.GIFEmitter GIFEmitter} to colourize a grey-scale GIFimage. The colours to use are calculated from one or, optionally, two text keys. 
 * @param targetPathName the path name of the target file. This should be a workspace path; when running stand-alone,it will be converted to a platform resource URI that should be mapped to a physical file URI by the {@link #getURIConverter() URIConverter}.
 * @param gifEmitter the <code>GIFEmitter</code> to use for generating the icon.
 * @param parentKey the key used to determine the first colour set.
 * @param childKey the key used to determine the second colour set. If null, this key is ignored.
 * @param overwrite whether an existing file should be overwritten.
 * @param monitor the <code>Monitor</code> through which to report progress.<p>This method also consults the following  {@link Generator#getOptions() generator options}: <ul> <li>  {@link Generator.Options#redirectionPattern redirectionPattern}<li>  {@link Generator.Options#forceOverwrite forceOverwrite}<li>  {@link Generator.Options#resourceSet resourceSet}</ul>
 */
protected void generateGIF(String targetPathName,GIFEmitter gifEmitter,String parentKey,String childKey,boolean overwrite,Monitor monitor){
  try {
    monitor.beginTask(""String_Node_Str"",3);
    URI targetFile=toURI(targetPathName);
    monitor.subTask(CodeGenEcorePlugin.INSTANCE.getString(""String_Node_Str"",new Object[]{targetFile}));
    URI targetDirectory=targetFile.trimSegments(1);
    ensureContainerExists(targetDirectory,createMonitor(monitor,1));
    boolean exists=exists(targetFile);
    if (!exists || overwrite) {
      byte[] emitterResult=gifEmitter.generateGIF(parentKey,childKey);
      monitor.worked(1);
      String redirection=getGenerator().getOptions().redirectionPattern;
      boolean redirect=redirection != null && redirection.indexOf(""String_Node_Str"") != -1;
      if (redirect) {
        String baseName=MessageFormat.format(redirection,new Object[]{targetFile.lastSegment()});
        targetFile=targetDirectory.appendSegment(baseName);
        monitor.subTask(CodeGenEcorePlugin.INSTANCE.getString(""String_Node_Str"",new Object[]{targetFile}));
      }
      if (isReadOnly(targetFile)) {
        if (getGenerator().getOptions().forceOverwrite) {
          validateEdit(targetFile,createMonitor(monitor,1));
          setWriteable(targetFile);
        }
 else {
          targetFile=targetDirectory.appendSegment(""String_Node_Str"" + targetFile.lastSegment() + ""String_Node_Str"");
          monitor.subTask(CodeGenEcorePlugin.INSTANCE.getString(""String_Node_Str"",new Object[]{targetFile}));
        }
      }
      OutputStream outputStream=createOutputStream(targetFile);
      outputStream.write(emitterResult);
      outputStream.close();
    }
  }
 catch (  Exception exception) {
    CodeGenEcorePlugin.INSTANCE.log(exception);
  }
 finally {
    monitor.done();
  }
}",0.9996614759647936
11844,"/** 
 * Generates a Java source file using JET, with   {@link org.eclipse.emf.codegen.util.ImportManager import management}and, when running under Eclipse,   {@link org.eclipse.emf.codegen.merge.java.JMerger merging} and{@link org.eclipse.jdt.core.formatter.CodeFormatter code formatting} capabilities.<p>When running under Eclipse, the encoding for the file is determined from the workspace. Failing that, or in standalone, the platform default is used.
 * @param targetPath the workspace path of the directory in or under which the file will be created, depending on thespecified package name. When running standalone, this path will be converted to a platform resource URI that should be mapped to a physical file URI by the  {@link #getURIConverter() URIConverter}.
 * @param packageName the package name for the generated compilation unit.
 * @param className the name of the public class in the generated compilation unit.
 * @param jetEmitter the <code>JETEmitter</code> to use for generating the code.
 * @param arguments the argument array to pass to the <code>JETEmitter</code>'s{@link JETEmitter#generate(Monitor,Object[]) generate(Monitor, Object[])} method. If null, an array willbe constructed containing only the  {@link #generatingObject object} for which code is being generated. 
 * @param monitor the <code>Monitor</code> through which to report progress.<p>This method also consults the following  {@link Generator#getOptions() generator options}: <ul> <li>  {@link Generator.Options#redirectionPattern redirectionPattern}<li>  {@link Generator.Options#forceOverwrite forceOverwrite}<li>  {@link Generator.Options#dynamicTemplates dynamicTemplates}<li>  {@link Generator.Options#mergerFacadeHelperClass mergerFacadeHelperClass}<li>  {@link Generator.Options#mergeRulesURI mergeRulesURI}<li>  {@link Generator.Options#codeFormatting codeFormatting} <li> {@link Generator.Options#codeFormatterOptions codeFormatterOptions} <li> {@link Generator.Options#resourceSet resourceSet}</ul>
 */
protected void generateJava(String targetPath,String packageName,String className,JETEmitter jetEmitter,Object[] arguments,Monitor monitor){
  try {
    monitor.beginTask(""String_Node_Str"",4);
    URI targetDirectory=toURI(targetPath).appendSegments(packageName.split(""String_Node_Str""));
    URI targetFile=targetDirectory.appendSegment(className + ""String_Node_Str"");
    monitor.subTask(CodeGenEcorePlugin.INSTANCE.getString(""String_Node_Str"",new Object[]{targetFile}));
    ensureContainerExists(targetDirectory,createMonitor(monitor,1));
    if (arguments == null) {
      arguments=new Object[]{generatingObject};
    }
    createImportManager(packageName,className);
    setLineDelimiter(getLineDelimiter(targetFile,getEncoding(targetFile)));
    String emitterResult=jetEmitter.generate(createMonitor(monitor,1),arguments,getLineDelimiter());
    boolean changed=true;
    String newContents=emitterResult;
    boolean targetExists=exists(targetFile);
    JControlModel jControlModel=getGenerator().getJControlModel();
    boolean mergeSuccessful=jControlModel.canMerge();
    if (mergeSuccessful) {
      JMerger jMerger=new JMerger(jControlModel);
      jMerger.setFixInterfaceBrace(jControlModel.getFacadeHelper().fixInterfaceBrace());
      try {
        jMerger.setSourceCompilationUnit(jMerger.createCompilationUnitForContents(emitterResult));
      }
 catch (      RuntimeException runtimeException) {
        if (targetExists) {
          throw runtimeException;
        }
 else {
          mergeSuccessful=false;
        }
      }
      if (mergeSuccessful) {
        Object codeFormatter=getGenerator().getOptions().codeFormatting ? createCodeFormatter(getGenerator().getOptions().codeFormatterOptions,targetFile) : null;
        if (targetExists) {
          monitor.subTask(CodeGenEcorePlugin.INSTANCE.getString(""String_Node_Str"",new Object[]{targetFile}));
          jMerger.setTargetCompilationUnit(jMerger.createCompilationUnitForInputStream(createInputStream(targetFile),getEncoding(targetFile)));
          String oldContents=jMerger.getTargetCompilationUnitContents();
          monitor.subTask(CodeGenEcorePlugin.INSTANCE.getString(""String_Node_Str"",new Object[]{targetFile}));
          jMerger.merge();
          newContents=formatCode(jMerger.getTargetCompilationUnitContents(),codeFormatter);
          changed=!oldContents.equals(newContents);
          if (changed && isReadOnly(targetFile) && validateEdit(targetFile,createMonitor(monitor,1))) {
            jMerger.setTargetCompilationUnit(jMerger.createCompilationUnitForInputStream(createInputStream(targetFile),getEncoding(targetFile)));
            jMerger.remerge();
            newContents=formatCode(jMerger.getTargetCompilationUnitContents(),codeFormatter);
          }
        }
 else {
          changed=true;
          monitor.subTask(CodeGenEcorePlugin.INSTANCE.getString(""String_Node_Str"",new Object[]{targetFile}));
          jMerger.merge();
          newContents=formatCode(jMerger.getTargetCompilationUnitContents(),codeFormatter);
        }
        if (jControlModel.getFacadeHelper() != null) {
          jControlModel.getFacadeHelper().reset();
        }
      }
    }
    if (!mergeSuccessful) {
      newContents=CodeGenUtil.convertFormat(jControlModel.getLeadingTabReplacement(),jControlModel.convertToStandardBraceStyle(),emitterResult);
      if (targetExists) {
        monitor.subTask(CodeGenEcorePlugin.INSTANCE.getString(""String_Node_Str"",new Object[]{targetFile}));
        String oldContents=getContents(targetFile,null);
        changed=!oldContents.equals(newContents);
      }
 else {
        changed=true;
      }
    }
    monitor.worked(1);
    if (changed) {
      String encoding=getEncoding(targetFile);
      byte[] bytes=encoding == null ? newContents.getBytes() : newContents.getBytes(encoding);
      String redirection=getGenerator().getOptions().redirectionPattern;
      boolean redirect=redirection != null && redirection.indexOf(""String_Node_Str"") != -1;
      if (redirect) {
        String baseName=MessageFormat.format(redirection,new Object[]{className + ""String_Node_Str""});
        targetFile=targetDirectory.appendSegment(baseName);
        monitor.subTask(CodeGenEcorePlugin.INSTANCE.getString(""String_Node_Str"",new Object[]{targetFile}));
      }
      if (isReadOnly(targetFile)) {
        if (getGenerator().getOptions().forceOverwrite) {
          setWriteable(targetFile);
        }
 else {
          targetFile=targetDirectory.appendSegment(""String_Node_Str"" + className + ""String_Node_Str"");
          monitor.subTask(CodeGenEcorePlugin.INSTANCE.getString(""String_Node_Str"",new Object[]{targetFile}));
        }
      }
      OutputStream outputStream=createOutputStream(targetFile);
      outputStream.write(bytes);
      outputStream.close();
    }
  }
 catch (  Exception e) {
    throw e instanceof RuntimeException ? (RuntimeException)e : new WrappedException(e);
  }
 finally {
    clearImportManager();
    setLineDelimiter(null);
    monitor.done();
  }
}","/** 
 * Generates a Java source file using JET, with   {@link org.eclipse.emf.codegen.util.ImportManager import management}and, when running under Eclipse,   {@link org.eclipse.emf.codegen.merge.java.JMerger merging} and{@link org.eclipse.jdt.core.formatter.CodeFormatter code formatting} capabilities.<p>When running under Eclipse, the encoding for the file is determined from the workspace. Failing that, or in stand-alone, the platform default is used.
 * @param targetPath the workspace path of the directory in or under which the file will be created, depending on thespecified package name. When running stand-alone, this path will be converted to a platform resource URI that should be mapped to a physical file URI by the  {@link #getURIConverter() URIConverter}.
 * @param packageName the package name for the generated compilation unit.
 * @param className the name of the public class in the generated compilation unit.
 * @param jetEmitter the <code>JETEmitter</code> to use for generating the code.
 * @param arguments the argument array to pass to the <code>JETEmitter</code>'s{@link JETEmitter#generate(Monitor,Object[]) generate(Monitor, Object[])} method. If null, an array willbe constructed containing only the  {@link #generatingObject object} for which code is being generated. 
 * @param monitor the <code>Monitor</code> through which to report progress.<p>This method also consults the following  {@link Generator#getOptions() generator options}: <ul> <li>  {@link Generator.Options#redirectionPattern redirectionPattern}<li>  {@link Generator.Options#forceOverwrite forceOverwrite}<li>  {@link Generator.Options#dynamicTemplates dynamicTemplates}<li>  {@link Generator.Options#mergerFacadeHelperClass mergerFacadeHelperClass}<li>  {@link Generator.Options#mergeRulesURI mergeRulesURI}<li>  {@link Generator.Options#codeFormatting codeFormatting} <li> {@link Generator.Options#codeFormatterOptions codeFormatterOptions} <li> {@link Generator.Options#resourceSet resourceSet}</ul>
 */
protected void generateJava(String targetPath,String packageName,String className,JETEmitter jetEmitter,Object[] arguments,Monitor monitor){
  try {
    monitor.beginTask(""String_Node_Str"",4);
    URI targetDirectory=toURI(targetPath).appendSegments(packageName.split(""String_Node_Str""));
    URI targetFile=targetDirectory.appendSegment(className + ""String_Node_Str"");
    monitor.subTask(CodeGenEcorePlugin.INSTANCE.getString(""String_Node_Str"",new Object[]{targetFile}));
    ensureContainerExists(targetDirectory,createMonitor(monitor,1));
    if (arguments == null) {
      arguments=new Object[]{generatingObject};
    }
    createImportManager(packageName,className);
    setLineDelimiter(getLineDelimiter(targetFile,getEncoding(targetFile)));
    String emitterResult=jetEmitter.generate(createMonitor(monitor,1),arguments,getLineDelimiter());
    boolean changed=true;
    String newContents=emitterResult;
    boolean targetExists=exists(targetFile);
    JControlModel jControlModel=getGenerator().getJControlModel();
    boolean mergeSuccessful=jControlModel.canMerge();
    if (mergeSuccessful) {
      JMerger jMerger=new JMerger(jControlModel);
      jMerger.setFixInterfaceBrace(jControlModel.getFacadeHelper().fixInterfaceBrace());
      try {
        jMerger.setSourceCompilationUnit(jMerger.createCompilationUnitForContents(emitterResult));
      }
 catch (      RuntimeException runtimeException) {
        if (targetExists) {
          throw runtimeException;
        }
 else {
          mergeSuccessful=false;
        }
      }
      if (mergeSuccessful) {
        Object codeFormatter=getGenerator().getOptions().codeFormatting ? createCodeFormatter(getGenerator().getOptions().codeFormatterOptions,targetFile) : null;
        if (targetExists) {
          monitor.subTask(CodeGenEcorePlugin.INSTANCE.getString(""String_Node_Str"",new Object[]{targetFile}));
          jMerger.setTargetCompilationUnit(jMerger.createCompilationUnitForInputStream(createInputStream(targetFile),getEncoding(targetFile)));
          String oldContents=jMerger.getTargetCompilationUnitContents();
          monitor.subTask(CodeGenEcorePlugin.INSTANCE.getString(""String_Node_Str"",new Object[]{targetFile}));
          jMerger.merge();
          newContents=formatCode(jMerger.getTargetCompilationUnitContents(),codeFormatter);
          changed=!oldContents.equals(newContents);
          if (changed && isReadOnly(targetFile) && validateEdit(targetFile,createMonitor(monitor,1))) {
            jMerger.setTargetCompilationUnit(jMerger.createCompilationUnitForInputStream(createInputStream(targetFile),getEncoding(targetFile)));
            jMerger.remerge();
            newContents=formatCode(jMerger.getTargetCompilationUnitContents(),codeFormatter);
          }
        }
 else {
          changed=true;
          monitor.subTask(CodeGenEcorePlugin.INSTANCE.getString(""String_Node_Str"",new Object[]{targetFile}));
          jMerger.merge();
          newContents=formatCode(jMerger.getTargetCompilationUnitContents(),codeFormatter);
        }
        if (jControlModel.getFacadeHelper() != null) {
          jControlModel.getFacadeHelper().reset();
        }
      }
    }
    if (!mergeSuccessful) {
      newContents=CodeGenUtil.convertFormat(jControlModel.getLeadingTabReplacement(),jControlModel.convertToStandardBraceStyle(),emitterResult);
      if (targetExists) {
        monitor.subTask(CodeGenEcorePlugin.INSTANCE.getString(""String_Node_Str"",new Object[]{targetFile}));
        String oldContents=getContents(targetFile,null);
        changed=!oldContents.equals(newContents);
      }
 else {
        changed=true;
      }
    }
    monitor.worked(1);
    if (changed) {
      String encoding=getEncoding(targetFile);
      byte[] bytes=encoding == null ? newContents.getBytes() : newContents.getBytes(encoding);
      String redirection=getGenerator().getOptions().redirectionPattern;
      boolean redirect=redirection != null && redirection.indexOf(""String_Node_Str"") != -1;
      if (redirect) {
        String baseName=MessageFormat.format(redirection,new Object[]{className + ""String_Node_Str""});
        targetFile=targetDirectory.appendSegment(baseName);
        monitor.subTask(CodeGenEcorePlugin.INSTANCE.getString(""String_Node_Str"",new Object[]{targetFile}));
      }
      if (isReadOnly(targetFile)) {
        if (getGenerator().getOptions().forceOverwrite) {
          setWriteable(targetFile);
        }
 else {
          targetFile=targetDirectory.appendSegment(""String_Node_Str"" + className + ""String_Node_Str"");
          monitor.subTask(CodeGenEcorePlugin.INSTANCE.getString(""String_Node_Str"",new Object[]{targetFile}));
        }
      }
      OutputStream outputStream=createOutputStream(targetFile);
      outputStream.write(bytes);
      outputStream.close();
    }
  }
 catch (  Exception e) {
    throw e instanceof RuntimeException ? (RuntimeException)e : new WrappedException(e);
  }
 finally {
    clearImportManager();
    setLineDelimiter(null);
    monitor.done();
  }
}",0.999857509261898
11845,"/** 
 * Override this to   {@link org.eclipse.emf.codegen.jet.JETEmitter#addVariable(String,String) add classpath variables}to the JETEmitter. These will be used to build and execute dynamic templates.
 * @link org.eclipse.emf.codegen.jet.JETEmitter#addVariable(String, String)
 */
protected void addClasspathEntries(JETEmitter jetEmitter) throws JETException {
  if (getGenerator().getOptions().templateClasspath != null) {
    for (    String additionalClasspathEntry : getGenerator().getOptions().templateClasspath) {
      int index=additionalClasspathEntry.indexOf('=');
      if (index == -1) {
        jetEmitter.addVariable(additionalClasspathEntry,additionalClasspathEntry);
      }
 else {
        jetEmitter.addVariable(additionalClasspathEntry.substring(0,index),additionalClasspathEntry.substring(index + 1));
      }
    }
  }
}","/** 
 * Override this to   {@link org.eclipse.emf.codegen.jet.JETEmitter#addVariable(String,String) add classpath variables}to the JETEmitter. These will be used to build and execute dynamic templates.
 * @see org.eclipse.emf.codegen.jet.JETEmitter#addVariable(String,String)
 */
protected void addClasspathEntries(JETEmitter jetEmitter) throws JETException {
  if (getGenerator().getOptions().templateClasspath != null) {
    for (    String additionalClasspathEntry : getGenerator().getOptions().templateClasspath) {
      int index=additionalClasspathEntry.indexOf('=');
      if (index == -1) {
        jetEmitter.addVariable(additionalClasspathEntry,additionalClasspathEntry);
      }
 else {
        jetEmitter.addVariable(additionalClasspathEntry.substring(0,index),additionalClasspathEntry.substring(index + 1));
      }
    }
  }
}",0.995243757431629
11846,"/** 
 * Converts the given workspace path to a <code>URI</code>. No encoding is performed, so the URI may contain invalid characters. Such a URI is only used to easily acess and manipulate parts of the workspace path. It can then be converted back to a string and an   {@link org.eclipse.core.runtime.IPath IPath} for use in the workspace, or to an encoded  {@link #toPlatformResourceURI(URI) platform resource URI} for direct use with the EMF persistenceframework.
 */
protected URI toURI(String pathName){
  return URI.createURI(pathName);
}","/** 
 * Converts the given workspace path to a <code>URI</code>. No encoding is performed, so the URI may contain invalid characters. Such a URI is only used to easily access and manipulate parts of the workspace path. It can then be converted back to a string and an   {@link org.eclipse.core.runtime.IPath IPath} for use in the workspace, or to an encoded  {@link #toPlatformResourceURI(URI) platform resource URI} for direct use with the EMF persistenceframework.
 */
protected URI toURI(String pathName){
  return URI.createURI(pathName);
}",0.999080036798528
11847,"/** 
 * Performs initialization for the given model-level input object. This implementaiton does nothing; it should be overridden when   {@link Generator#getOptions() options} should be set on the generator, or other initializationis required.
 */
public void initialize(Object input){
}","/** 
 * Performs initialization for the given model-level input object. This implementation does nothing; it should be overridden when   {@link Generator#getOptions() options} should be set on the generator, or other initializationis required.
 */
public void initialize(Object input){
}",0.9930313588850174
11848,"/** 
 * Returns whether code can be generated for the given object and project type. A project type is repesented by an arbitrary object that is meaningful to the generator adapters for the relevant objects. <p>This result is obtained as follows: <ol> <li>The   {@link GeneratorAdapter adapters} for the object are obtained.<li>A complete collection of objects to be considered is formed by iteratively invoking the {@link GeneratorAdapter#getCanGenerateParent(Object,Object) getCanGenerateParent(Object, Object)} and{@link GeneratorAdapter#getCanGenerateChildren(Object,Object) getCanGenerateChildren(Object, Object)} methodson the adapters for the object, the adapters for the object's parent and children, and so on. It is the adapters' responsibility to determine the relevant objects through their implementations of these methods. <li>The  {@link GeneratorAdapter#canGenerate(Object,Object) canGenerate(Object, Object)} method is invoked on allthe adapters for every object in the set formed in step 2. If any adapter returns <code>true</code> for any object, this method returns <code>true</code>. <li>Otherwise, <code>false</code> is returned. </ol>
 * @see GeneratorAdapter#getCanGenerateParent(Object,Object)
 * @see GeneratorAdapter#getCanGenerateChildren(Object,Object)
 * @see GeneratorAdapter#canGenerate(Object,Object)
 */
public boolean canGenerate(Object object,Object projectType){
  GeneratorData[] data=getGeneratorData(object,projectType,false);
  for (int i=0; i < data.length; i++) {
    if (data[i].adapter.canGenerate(data[i].object,projectType)) {
      return true;
    }
  }
  return false;
}","/** 
 * Returns whether code can be generated for the given object and project type. A project type is represented by an arbitrary object that is meaningful to the generator adapters for the relevant objects. <p>This result is obtained as follows: <ol> <li>The   {@link GeneratorAdapter adapters} for the object are obtained.<li>A complete collection of objects to be considered is formed by iteratively invoking the {@link GeneratorAdapter#getCanGenerateParent(Object,Object) getCanGenerateParent(Object, Object)} and{@link GeneratorAdapter#getCanGenerateChildren(Object,Object) getCanGenerateChildren(Object, Object)} methodson the adapters for the object, the adapters for the object's parent and children, and so on. It is the adapters' responsibility to determine the relevant objects through their implementations of these methods. <li>The  {@link GeneratorAdapter#canGenerate(Object,Object) canGenerate(Object, Object)} method is invoked on allthe adapters for every object in the set formed in step 2. If any adapter returns <code>true</code> for any object, this method returns <code>true</code>. <li>Otherwise, <code>false</code> is returned. </ol>
 * @see GeneratorAdapter#getCanGenerateParent(Object,Object)
 * @see GeneratorAdapter#getCanGenerateChildren(Object,Object)
 * @see GeneratorAdapter#canGenerate(Object,Object)
 */
public boolean canGenerate(Object object,Object projectType){
  GeneratorData[] data=getGeneratorData(object,projectType,false);
  for (int i=0; i < data.length; i++) {
    if (data[i].adapter.canGenerate(data[i].object,projectType)) {
      return true;
    }
  }
  return false;
}",0.9996914532551682
11849,"/** 
 * Performs code generation for the given object and project type. A project type is repesented by an arbitrary object that is meaningful to the generator adapters for the relevant objects. Since this is a long-running operation, it reports progress using the given <code>Monitor</code>. Its final status is returned as a <code>Diagnostic</code>. The <code>projectTypeName</code>, if non-null, is used only to provide to the <code>Monitor</code> a more specific message for the task. <p>It is not necessary to call   {@link #canGenerate(Object,Object)} before this method. If that method would return <code>false</code>, this method should generate nothing when invoked with the same arguments. <p>Code generation is performed as follows: <ol> <li>The  {@link GeneratorAdapter adapters} for the object are obtained.<li>A complete collection of objects to be considered is formed by iteratively invoking the {@link GeneratorAdapter#getGenerateParent(Object,Object) getGenerateParent(Object, Object)} and{@link GeneratorAdapter#getGenerateChildren(Object,Object) getGenerateChildren(Object, Object)} methods on theadapters for the object, the adapters for the object's parent and children, and so on. It is the adapters' responsibility to determine the relevant objects through their implementations of these methods. <li>If this is the first invocation of  {@link #generate(Object,Object,String,Monitor)} or initialization hasbeen  {@link #requestInitialize() requested},   {@link GeneratorAdapterFactory#initialize(Object) initialize(Object)}is invoked on each adapter factory for the   {@link #getInput() input} object.<li>The  {@link GeneratorAdapter#preGenerate(Object,Object) preGenerate(Object, Object)} method is invoked on allthe adapters for every object in the set formed in step 2, giving the adapters a chance to perform setup before any code is generated. <li>The  {@link GeneratorAdapter#generate(Object,Object,Monitor) generate(Object, Object, Monitor)} method isinvoked on all the adapters for every object in the set formed in step 2. This is where code generation actually occurs. <li>The  {@link GeneratorAdapter#postGenerate(Object,Object) postGenerate(Object, Object)} method is invoked on allthe adapters for every object in the set formed in step 2, giving adapters a chance to clean up from code generation. </ol> <p>The operation may be cancelled during step 4 or 5, either based on the <code>Monitor</code> or the <code>Diagnostic</code> returned by any generator adapter invocation. By default, only a <code>CANCEL</code> {@link org.eclipse.emf.common.util.Diagnostic#getSeverity severity} will cause code generation to stop; however,this can be customized by overriding  {@link #canContinue(Diagnostic) canContinue(Diagnostic)}. Even if code generation is cancelled,   {@link GeneratorAdapter#postGenerate(Object,Object) postGenerate(Object, Object)} willstill be called on all the adapters on which  {@link GeneratorAdapter#preGenerate(Object,Object) preGenerate(Object, Object)}has been called.
 * @see #canGenerate(Object,Object)
 * @see #requestInitialize()
 * @see GeneratorAdapter#getGenerateParent(Object,Object)
 * @see GeneratorAdapter#getGenerateChildren(Object,Object)
 * @see GeneratorAdapter#preGenerate(Object,Object)
 * @see GeneratorAdapter#generate(Object,Object,Monitor)
 * @see GeneratorAdapter#postGenerate(Object,Object)
 * @see GeneratorAdapterFactory#initialize(Object)
 */
public Diagnostic generate(Object object,Object projectType,String projectTypeName,Monitor monitor){
  if (SYSOUT_BEGIN_END)   System.out.println(""String_Node_Str"" + new java.util.Date());
  try {
    String message=projectTypeName != null ? CodeGenEcorePlugin.INSTANCE.getString(""String_Node_Str"",new Object[]{projectTypeName}) : CodeGenEcorePlugin.INSTANCE.getString(""String_Node_Str"");
    BasicDiagnostic result=new BasicDiagnostic(CodeGenEcorePlugin.ID,0,message,null);
    GeneratorData[] data=getGeneratorData(object,projectType,true);
    monitor.beginTask(""String_Node_Str"",data.length + 2);
    monitor.subTask(message);
    if (initializeNeeded) {
      initializeNeeded=false;
      initialize();
    }
    int preIndex=0;
    for (; preIndex < data.length && canContinue(result); preIndex++) {
      result.add(data[preIndex].adapter.preGenerate(data[preIndex].object,projectType));
    }
    monitor.worked(1);
    for (int i=0; i < data.length && canContinue(result); i++) {
      result.add(data[i].adapter.generate(data[i].object,projectType,CodeGenUtil.createMonitor(monitor,1)));
      if (monitor.isCanceled()) {
        result.add(Diagnostic.CANCEL_INSTANCE);
      }
    }
    for (int i=0; i < preIndex; i++) {
      result.add(data[i].adapter.postGenerate(data[i].object,projectType));
    }
    return result;
  }
  finally {
    monitor.done();
    if (SYSOUT_BEGIN_END)     System.out.println(""String_Node_Str"" + new java.util.Date());
  }
}","/** 
 * Performs code generation for the given object and project type. A project type is represented by an arbitrary object that is meaningful to the generator adapters for the relevant objects. Since this is a long-running operation, it reports progress using the given <code>Monitor</code>. Its final status is returned as a <code>Diagnostic</code>. The <code>projectTypeName</code>, if non-null, is used only to provide to the <code>Monitor</code> a more specific message for the task. <p>It is not necessary to call   {@link #canGenerate(Object,Object)} before this method. If that method would return <code>false</code>, this method should generate nothing when invoked with the same arguments. <p>Code generation is performed as follows: <ol> <li>The  {@link GeneratorAdapter adapters} for the object are obtained.<li>A complete collection of objects to be considered is formed by iteratively invoking the {@link GeneratorAdapter#getGenerateParent(Object,Object) getGenerateParent(Object, Object)} and{@link GeneratorAdapter#getGenerateChildren(Object,Object) getGenerateChildren(Object, Object)} methods on theadapters for the object, the adapters for the object's parent and children, and so on. It is the adapters' responsibility to determine the relevant objects through their implementations of these methods. <li>If this is the first invocation of  {@link #generate(Object,Object,String,Monitor)} or initialization hasbeen  {@link #requestInitialize() requested},   {@link GeneratorAdapterFactory#initialize(Object) initialize(Object)}is invoked on each adapter factory for the   {@link #getInput() input} object.<li>The  {@link GeneratorAdapter#preGenerate(Object,Object) preGenerate(Object, Object)} method is invoked on allthe adapters for every object in the set formed in step 2, giving the adapters a chance to perform setup before any code is generated. <li>The  {@link GeneratorAdapter#generate(Object,Object,Monitor) generate(Object, Object, Monitor)} method isinvoked on all the adapters for every object in the set formed in step 2. This is where code generation actually occurs. <li>The  {@link GeneratorAdapter#postGenerate(Object,Object) postGenerate(Object, Object)} method is invoked on allthe adapters for every object in the set formed in step 2, giving adapters a chance to clean up from code generation. </ol> <p>The operation may be canceled during step 4 or 5, either based on the <code>Monitor</code> or the <code>Diagnostic</code> returned by any generator adapter invocation. By default, only a <code>CANCEL</code> {@link org.eclipse.emf.common.util.Diagnostic#getSeverity severity} will cause code generation to stop; however,this can be customized by overriding  {@link #canContinue(Diagnostic) canContinue(Diagnostic)}. Even if code generation is canceled,   {@link GeneratorAdapter#postGenerate(Object,Object) postGenerate(Object, Object)} willstill be called on all the adapters on which  {@link GeneratorAdapter#preGenerate(Object,Object) preGenerate(Object, Object)}has been called.
 * @see #canGenerate(Object,Object)
 * @see #requestInitialize()
 * @see GeneratorAdapter#getGenerateParent(Object,Object)
 * @see GeneratorAdapter#getGenerateChildren(Object,Object)
 * @see GeneratorAdapter#preGenerate(Object,Object)
 * @see GeneratorAdapter#generate(Object,Object,Monitor)
 * @see GeneratorAdapter#postGenerate(Object,Object)
 * @see GeneratorAdapterFactory#initialize(Object)
 */
public Diagnostic generate(Object object,Object projectType,String projectTypeName,Monitor monitor){
  if (SYSOUT_BEGIN_END)   System.out.println(""String_Node_Str"" + new java.util.Date());
  try {
    String message=projectTypeName != null ? CodeGenEcorePlugin.INSTANCE.getString(""String_Node_Str"",new Object[]{projectTypeName}) : CodeGenEcorePlugin.INSTANCE.getString(""String_Node_Str"");
    BasicDiagnostic result=new BasicDiagnostic(CodeGenEcorePlugin.ID,0,message,null);
    GeneratorData[] data=getGeneratorData(object,projectType,true);
    monitor.beginTask(""String_Node_Str"",data.length + 2);
    monitor.subTask(message);
    if (initializeNeeded) {
      initializeNeeded=false;
      initialize();
    }
    int preIndex=0;
    for (; preIndex < data.length && canContinue(result); preIndex++) {
      result.add(data[preIndex].adapter.preGenerate(data[preIndex].object,projectType));
    }
    monitor.worked(1);
    for (int i=0; i < data.length && canContinue(result); i++) {
      result.add(data[i].adapter.generate(data[i].object,projectType,CodeGenUtil.createMonitor(monitor,1)));
      if (monitor.isCanceled()) {
        result.add(Diagnostic.CANCEL_INSTANCE);
      }
    }
    for (int i=0; i < preIndex; i++) {
      result.add(data[i].adapter.postGenerate(data[i].object,projectType));
    }
    return result;
  }
  finally {
    monitor.done();
    if (SYSOUT_BEGIN_END)     System.out.println(""String_Node_Str"" + new java.util.Date());
  }
}",0.9996936587358316
11850,"/** 
 * Returns whether code of the given poject type can be generated for the specified object.
 */
boolean canGenerate(Object object,Object projectType);","/** 
 * Returns whether code of the given object type can be generated for the specified object.
 */
boolean canGenerate(Object object,Object projectType);",0.9935483870967742
11851,"/** 
 * Record the DOM node and its corresponding EMF values.
 * @param node the DOM node
 * @param container the {@link org.eclipse.emf.ecore.EObject} which is the node's container
 * @param feature the feature for DOM node value
 * @param object the EMF value which is obtained by querying the value of the specified feature on the container {@link  org.eclipse.emf.ecore.EObject#eGet(EStructuralFeature};  this value is used to create the <emf>node</emf>
 */
void recordValues(Node node,EObject container,EStructuralFeature feature,Object value);","/** 
 * Record the DOM node and its corresponding EMF values.
 * @param node the DOM node
 * @param container the {@link org.eclipse.emf.ecore.EObject} which is the node's container
 * @param feature the feature for DOM node value
 * @param object the EMF value which is obtained by querying the value of the specified feature on the container {@link EObject#eGet(EStructuralFeature)};  this value is used to create the <emf>node</emf>
 */
void recordValues(Node node,EObject container,EStructuralFeature feature,Object value);",0.9776951672862454
11852,"/** 
 * Converts the given valuevalue to string while saving an XML document. 
 */
public String convertToString(EFactory factory,EDataType dataType,Object data);","/** 
 * Converts the given data value to a string while saving an XML document. 
 */
public String convertToString(EFactory factory,EDataType dataType,Object data);",0.9693251533742332
11853,"/** 
 * Create an object given an EFactory and a type 
 * @since 2.2
 * @param eFactory
 * @param type
 * @return
 * @see #createObject(EFactory,String)
 */
EObject createObject(EFactory eFactory,EClassifier type);","/** 
 * Create an object given an EFactory and a type 
 * @since 2.2
 * @param eFactory
 * @param type
 * @return the created object.
 * @see #createObject(EFactory,String)
 */
EObject createObject(EFactory eFactory,EClassifier type);",0.9553571428571428
11854,"/** 
 * Retrives XMLDefaultHandler from the pool and initializes / prepares it.
 * @param resource - the resource
 * @param xmlLoad - the XMLLoad
 * @param helper - XMLHelper
 * @param options
 */
public XMLDefaultHandler getDefaultHandler(XMLResource resource,XMLLoad xmlLoad,XMLHelper helper,Map<?,?> options);","/** 
 * Retrieves XMLDefaultHandler from the pool and initializes / prepares it.
 * @param resource - the resource
 * @param xmlLoad - the XMLLoad
 * @param helper - XMLHelper
 * @param options
 */
public XMLDefaultHandler getDefaultHandler(XMLResource resource,XMLLoad xmlLoad,XMLHelper helper,Map<?,?> options);",0.9984
11855,"/** 
 * Returns the name associated with the entity value;  a new name will be generated if there is not yet a name assocaited with the entity value.
 * @param entityValue the entity value for which a named entity is needed.
 * @return the name associated with the entity value.
 */
String getEntityName(String entityValue);","/** 
 * Returns the name associated with the entity value;  a new name will be generated if there is not yet a name associated with the entity value.
 * @param entityValue the entity value for which a named entity is needed.
 * @return the name associated with the entity value.
 */
String getEntityName(String entityValue);",0.9938271604938272
11856,"/** 
 * Get the XML version for this resource. The default is 1.0.
 * @return
 */
String getXMLVersion();","/** 
 * Returns the XML version for this resource. The default is 1.0.
 * @return the XML version.
 */
String getXMLVersion();",0.9004329004329005
11857,"/** 
 * Creates an instance that will generate entity names based on the given entity name  followed by the   {@link #count} starting from 1 to ensure uniquenss.
 * @param entityName
 */
public ResourceEntityHandlerImpl(String entityName){
  this.entityName=entityName;
}","/** 
 * Creates an instance that will generate entity names based on the given entity name  followed by the   {@link #count} starting from 1 to ensure uniqueness.
 * @param entityName
 */
public ResourceEntityHandlerImpl(String entityName){
  this.entityName=entityName;
}",0.998158379373849
11858,"/** 
 * Check if the values of the forward references have been set (they may have been set due to a bi-directional reference being set).  If not, set them. If this is called during end document processing, errors should be diagnosed. If it is called in the middle of a document,  we need to clean up the forward reference lists to avoid reprocessing resolved references again later.
 */
protected void handleForwardReferences(boolean isEndDocument){
  for (Iterator<InternalEObject> i=sameDocumentProxies.iterator(); i.hasNext(); ) {
    InternalEObject proxy=i.next();
    LOOP:     for (    EReference eReference : proxy.eClass().getEAllReferences()) {
      EReference oppositeEReference=eReference.getEOpposite();
      if (oppositeEReference != null && proxy.eIsSet(eReference)) {
        EObject resolvedEObject=xmlResource.getEObject(proxy.eProxyURI().fragment());
        if (resolvedEObject != null) {
          if (!isEndDocument) {
            i.remove();
          }
          EObject proxyHolder=(EObject)(eReference.isMany() ? ((List<?>)proxy.eGet(eReference)).get(0) : proxy.eGet(eReference));
          if (oppositeEReference.isMany()) {
            InternalEList<?> holderContents=(InternalEList<?>)proxyHolder.eGet(oppositeEReference);
            List<?> basicHolderContents=holderContents.basicList();
            int resolvedEObjectIndex=basicHolderContents.indexOf(resolvedEObject);
            if (resolvedEObjectIndex != -1) {
              int proxyIndex=basicHolderContents.indexOf(proxy);
              holderContents.move(proxyIndex,resolvedEObjectIndex);
              holderContents.remove(proxyIndex > resolvedEObjectIndex ? proxyIndex - 1 : proxyIndex + 1);
              break LOOP;
            }
          }
          if (eReference.isMany() ? !((InternalEList<?>)resolvedEObject.eGet(eReference)).basicList().contains(proxyHolder) : resolvedEObject.eGet(eReference) != proxyHolder) {
            if (oppositeEReference.isMany()) {
              @SuppressWarnings(""String_Node_Str"") InternalEList<EObject> proxyHolderList=(InternalEList<EObject>)proxyHolder.eGet(oppositeEReference);
              proxyHolderList.setUnique(proxyHolderList.indexOf(proxy),resolvedEObject);
            }
 else {
              proxyHolder.eSet(oppositeEReference,resolvedEObject);
            }
          }
        }
        break;
      }
    }
  }
  for (Iterator<SingleReference> i=forwardSingleReferences.iterator(); i.hasNext(); ) {
    SingleReference ref=i.next();
    EObject obj=xmlResource.getEObject((String)ref.getValue());
    if (obj != null) {
      if (!isEndDocument) {
        i.remove();
      }
      EStructuralFeature feature=ref.getFeature();
      setFeatureValue(ref.getObject(),feature,obj,ref.getPosition());
    }
 else     if (isEndDocument) {
      error(new UnresolvedReferenceException((String)ref.getValue(),getLocation(),ref.getLineNumber(),ref.getColumnNumber()));
    }
  }
  for (Iterator<ManyReference> i=forwardManyReferences.iterator(); i.hasNext(); ) {
    ManyReference ref=i.next();
    Object[] values=ref.getValues();
    boolean failure=false;
    for (int j=0, l=values.length; j < l; j++) {
      String id=(String)values[j];
      EObject obj=xmlResource.getEObject(id);
      values[j]=obj;
      if (obj == null) {
        failure=true;
        if (isEndDocument) {
          error(new UnresolvedReferenceException(id,getLocation(),ref.getLineNumber(),ref.getColumnNumber()));
        }
      }
    }
    if (!failure) {
      if (!isEndDocument) {
        i.remove();
      }
      setFeatureValues(ref);
    }
 else     if (isEndDocument) {
      setFeatureValues(ref);
    }
  }
}","/** 
 * Check if the values of the forward references have been set (they may have been set due to a bidirectional reference being set).  If not, set them. If this is called during end document processing, errors should be diagnosed. If it is called in the middle of a document,  we need to clean up the forward reference lists to avoid processing resolved references again later.
 */
protected void handleForwardReferences(boolean isEndDocument){
  for (Iterator<InternalEObject> i=sameDocumentProxies.iterator(); i.hasNext(); ) {
    InternalEObject proxy=i.next();
    LOOP:     for (    EReference eReference : proxy.eClass().getEAllReferences()) {
      EReference oppositeEReference=eReference.getEOpposite();
      if (oppositeEReference != null && proxy.eIsSet(eReference)) {
        EObject resolvedEObject=xmlResource.getEObject(proxy.eProxyURI().fragment());
        if (resolvedEObject != null) {
          if (!isEndDocument) {
            i.remove();
          }
          EObject proxyHolder=(EObject)(eReference.isMany() ? ((List<?>)proxy.eGet(eReference)).get(0) : proxy.eGet(eReference));
          if (oppositeEReference.isMany()) {
            InternalEList<?> holderContents=(InternalEList<?>)proxyHolder.eGet(oppositeEReference);
            List<?> basicHolderContents=holderContents.basicList();
            int resolvedEObjectIndex=basicHolderContents.indexOf(resolvedEObject);
            if (resolvedEObjectIndex != -1) {
              int proxyIndex=basicHolderContents.indexOf(proxy);
              holderContents.move(proxyIndex,resolvedEObjectIndex);
              holderContents.remove(proxyIndex > resolvedEObjectIndex ? proxyIndex - 1 : proxyIndex + 1);
              break LOOP;
            }
          }
          if (eReference.isMany() ? !((InternalEList<?>)resolvedEObject.eGet(eReference)).basicList().contains(proxyHolder) : resolvedEObject.eGet(eReference) != proxyHolder) {
            if (oppositeEReference.isMany()) {
              @SuppressWarnings(""String_Node_Str"") InternalEList<EObject> proxyHolderList=(InternalEList<EObject>)proxyHolder.eGet(oppositeEReference);
              proxyHolderList.setUnique(proxyHolderList.indexOf(proxy),resolvedEObject);
            }
 else {
              proxyHolder.eSet(oppositeEReference,resolvedEObject);
            }
          }
        }
        break;
      }
    }
  }
  for (Iterator<SingleReference> i=forwardSingleReferences.iterator(); i.hasNext(); ) {
    SingleReference ref=i.next();
    EObject obj=xmlResource.getEObject((String)ref.getValue());
    if (obj != null) {
      if (!isEndDocument) {
        i.remove();
      }
      EStructuralFeature feature=ref.getFeature();
      setFeatureValue(ref.getObject(),feature,obj,ref.getPosition());
    }
 else     if (isEndDocument) {
      error(new UnresolvedReferenceException((String)ref.getValue(),getLocation(),ref.getLineNumber(),ref.getColumnNumber()));
    }
  }
  for (Iterator<ManyReference> i=forwardManyReferences.iterator(); i.hasNext(); ) {
    ManyReference ref=i.next();
    Object[] values=ref.getValues();
    boolean failure=false;
    for (int j=0, l=values.length; j < l; j++) {
      String id=(String)values[j];
      EObject obj=xmlResource.getEObject(id);
      values[j]=obj;
      if (obj == null) {
        failure=true;
        if (isEndDocument) {
          error(new UnresolvedReferenceException(id,getLocation(),ref.getLineNumber(),ref.getColumnNumber()));
        }
      }
    }
    if (!failure) {
      if (!isEndDocument) {
        i.remove();
      }
      setFeatureValues(ref);
    }
 else     if (isEndDocument) {
      setFeatureValues(ref);
    }
  }
}",0.9995889847924372
11859,"/** 
 * Create an XML processor that is aware of XML Schemas specified.
 * @param schemaURIs - a list of URI {@link org.eclipse.common.util.URI} which point to XML Schemas
 * @throws SAXException
 */
public XMLProcessor(Collection<URI> schemaURIs) throws SAXException {
  this(new EPackageRegistryImpl());
  loadOptions.put(XMLResource.OPTION_USE_ENCODED_ATTRIBUTE_STYLE,Boolean.TRUE);
  loadOptions.put(XMLResource.OPTION_USE_LEXICAL_HANDLER,Boolean.TRUE);
  saveOptions.put(XMLResource.OPTION_USE_ENCODED_ATTRIBUTE_STYLE,Boolean.TRUE);
  saveOptions.put(XMLResource.OPTION_SCHEMA_LOCATION,Boolean.TRUE);
  try {
    for (    Resource resource : ecoreBuilder.generate(schemaURIs)) {
      for (      EPackage ePackage : EcoreUtil.<EPackage>getObjectsByType(resource.getContents(),EcorePackage.eINSTANCE.getEPackage())) {
        EcoreUtil.freeze(ePackage);
      }
    }
  }
 catch (  InvocationTargetException ie) {
    throw new SAXException((Exception)ie.getTargetException());
  }
catch (  Exception e) {
    throw new SAXException(e);
  }
}","/** 
 * Create an XML processor that is aware of XML Schemas specified.
 * @param schemaURIs - a list of URI {@link URI} which point to XML Schemas
 * @throws SAXException
 */
public XMLProcessor(Collection<URI> schemaURIs) throws SAXException {
  this(new EPackageRegistryImpl());
  loadOptions.put(XMLResource.OPTION_USE_ENCODED_ATTRIBUTE_STYLE,Boolean.TRUE);
  loadOptions.put(XMLResource.OPTION_USE_LEXICAL_HANDLER,Boolean.TRUE);
  saveOptions.put(XMLResource.OPTION_USE_ENCODED_ATTRIBUTE_STYLE,Boolean.TRUE);
  saveOptions.put(XMLResource.OPTION_SCHEMA_LOCATION,Boolean.TRUE);
  try {
    for (    Resource resource : ecoreBuilder.generate(schemaURIs)) {
      for (      EPackage ePackage : EcoreUtil.<EPackage>getObjectsByType(resource.getContents(),EcorePackage.eINSTANCE.getEPackage())) {
        EcoreUtil.freeze(ePackage);
      }
    }
  }
 catch (  InvocationTargetException ie) {
    throw new SAXException((Exception)ie.getTargetException());
  }
catch (  Exception e) {
    throw new SAXException(e);
  }
}",0.988394584139265
11860,"/** 
 * <p>Creates the   {@link ExportData} instance and delegates the export work tothe  {@link #doExport(Monitor,ModelExporter.ExportData)} method.</p><p>The  {@link Diagnostic} returned by this method should be used to providethe user some information regarding a <b>successfull</b> export.  If the export fails, an exception should be thrown.<p>
 * @param monitor
 * @return {@link Diagnostic}
 * @throws Exception
 */
public Diagnostic export(Monitor monitor) throws Exception {
  Map<String,GenPackage> nsURIToReferencedGenPackage=null;
  Map<GenPackage,URI> referencedGenPackageToArtifactURI=null;
  if (referencedGenPackageToInfoMap != null) {
    referencedGenPackageToArtifactURI=new HashMap<GenPackage,URI>(referencedGenPackageToInfoMap.size());
    nsURIToReferencedGenPackage=new HashMap<String,GenPackage>(referencedGenPackageToInfoMap.size());
    List<GenPackage> referencedGenPackages=computeValidReferencedGenPackages();
    for (    GenPackage genPackage : referencedGenPackages) {
      URI artifactURI=getReferencedGenPackageExportInfo(genPackage).getArtifactURI();
      referencedGenPackageToArtifactURI.put(genPackage,artifactURI);
      nsURIToReferencedGenPackage.put(genPackage.getNSURI(),genPackage);
    }
  }
  Map<GenPackage,URI> genPackageToArtifactURI=null;
  Map<GenPackage,List<GenPackage>> genPackageToReferencedGenPackages=null;
  if (ePackageToInfoMap != null && ePackageToGenPackageMap != null) {
    genPackageToArtifactURI=new HashMap<GenPackage,URI>(ePackageToInfoMap.size());
    genPackageToReferencedGenPackages=new HashMap<GenPackage,List<GenPackage>>(ePackageToInfoMap.size());
    List<EPackage> ePackages=computeEPackagesToConvert();
    for (    EPackage ePackage : ePackages) {
      GenPackage genPackage=ePackageToGenPackageMap.get(ePackage);
      if (genPackage != null) {
        if (nsURIToReferencedGenPackage != null) {
          List<EPackage> requiredEPackages=ConverterUtil.computeRequiredPackages(ePackage);
          List<GenPackage> requiredGenPackages=new ConverterUtil.GenPackageList(requiredEPackages.size());
          for (          EPackage requiredEPackage : requiredEPackages) {
            GenPackage referencedGenPackage=nsURIToReferencedGenPackage.get(requiredEPackage.getNsURI());
            if (referencedGenPackage != null) {
              requiredGenPackages.add(referencedGenPackage);
            }
          }
          if (!requiredGenPackages.isEmpty()) {
            genPackageToReferencedGenPackages.put(genPackage,requiredGenPackages);
          }
        }
        EPackageExportInfo exportInfo=getEPackageExportInfo(ePackage);
        String artifactLocation=exportInfo.getArtifactLocation();
        if (artifactLocation != null) {
          genPackageToArtifactURI.put(genPackage,computeArtifactURI(artifactLocation));
        }
      }
    }
  }
  if (genPackageToArtifactURI == null || genPackageToArtifactURI.isEmpty()) {
    throw new DiagnosticException(new BasicDiagnostic(Diagnostic.ERROR,ExporterPlugin.ID,0,ExporterPlugin.INSTANCE.getString(""String_Node_Str""),null));
  }
 else {
    ExportData exportData=new ExportData();
    exportData.genPackageToArtifactURI=genPackageToArtifactURI;
    exportData.referencedGenPackagesToArtifactURI=referencedGenPackageToArtifactURI != null && !referencedGenPackageToArtifactURI.isEmpty() ? referencedGenPackageToArtifactURI : Collections.<GenPackage,URI>emptyMap();
    exportData.genPackageToReferencedGenPackages=genPackageToReferencedGenPackages != null && !genPackageToReferencedGenPackages.isEmpty() ? genPackageToReferencedGenPackages : Collections.<GenPackage,List<GenPackage>>emptyMap();
    return doExport(monitor,exportData);
  }
}","/** 
 * <p>Creates the   {@link ExportData} instance and delegates the export work tothe  {@link #doExport(Monitor,ModelExporter.ExportData)} method.</p><p>The  {@link Diagnostic} returned by this method should be used to providethe user some information regarding a <b>successful</b> export.  If the export fails, an exception should be thrown.<p>
 * @param monitor
 * @return {@link Diagnostic}
 * @throws Exception
 */
public Diagnostic export(Monitor monitor) throws Exception {
  Map<String,GenPackage> nsURIToReferencedGenPackage=null;
  Map<GenPackage,URI> referencedGenPackageToArtifactURI=null;
  if (referencedGenPackageToInfoMap != null) {
    referencedGenPackageToArtifactURI=new HashMap<GenPackage,URI>(referencedGenPackageToInfoMap.size());
    nsURIToReferencedGenPackage=new HashMap<String,GenPackage>(referencedGenPackageToInfoMap.size());
    List<GenPackage> referencedGenPackages=computeValidReferencedGenPackages();
    for (    GenPackage genPackage : referencedGenPackages) {
      URI artifactURI=getReferencedGenPackageExportInfo(genPackage).getArtifactURI();
      referencedGenPackageToArtifactURI.put(genPackage,artifactURI);
      nsURIToReferencedGenPackage.put(genPackage.getNSURI(),genPackage);
    }
  }
  Map<GenPackage,URI> genPackageToArtifactURI=null;
  Map<GenPackage,List<GenPackage>> genPackageToReferencedGenPackages=null;
  if (ePackageToInfoMap != null && ePackageToGenPackageMap != null) {
    genPackageToArtifactURI=new HashMap<GenPackage,URI>(ePackageToInfoMap.size());
    genPackageToReferencedGenPackages=new HashMap<GenPackage,List<GenPackage>>(ePackageToInfoMap.size());
    List<EPackage> ePackages=computeEPackagesToConvert();
    for (    EPackage ePackage : ePackages) {
      GenPackage genPackage=ePackageToGenPackageMap.get(ePackage);
      if (genPackage != null) {
        if (nsURIToReferencedGenPackage != null) {
          List<EPackage> requiredEPackages=ConverterUtil.computeRequiredPackages(ePackage);
          List<GenPackage> requiredGenPackages=new ConverterUtil.GenPackageList(requiredEPackages.size());
          for (          EPackage requiredEPackage : requiredEPackages) {
            GenPackage referencedGenPackage=nsURIToReferencedGenPackage.get(requiredEPackage.getNsURI());
            if (referencedGenPackage != null) {
              requiredGenPackages.add(referencedGenPackage);
            }
          }
          if (!requiredGenPackages.isEmpty()) {
            genPackageToReferencedGenPackages.put(genPackage,requiredGenPackages);
          }
        }
        EPackageExportInfo exportInfo=getEPackageExportInfo(ePackage);
        String artifactLocation=exportInfo.getArtifactLocation();
        if (artifactLocation != null) {
          genPackageToArtifactURI.put(genPackage,computeArtifactURI(artifactLocation));
        }
      }
    }
  }
  if (genPackageToArtifactURI == null || genPackageToArtifactURI.isEmpty()) {
    throw new DiagnosticException(new BasicDiagnostic(Diagnostic.ERROR,ExporterPlugin.ID,0,ExporterPlugin.INSTANCE.getString(""String_Node_Str""),null));
  }
 else {
    ExportData exportData=new ExportData();
    exportData.genPackageToArtifactURI=genPackageToArtifactURI;
    exportData.referencedGenPackagesToArtifactURI=referencedGenPackageToArtifactURI != null && !referencedGenPackageToArtifactURI.isEmpty() ? referencedGenPackageToArtifactURI : Collections.<GenPackage,URI>emptyMap();
    exportData.genPackageToReferencedGenPackages=genPackageToReferencedGenPackages != null && !genPackageToReferencedGenPackages.isEmpty() ? genPackageToReferencedGenPackages : Collections.<GenPackage,List<GenPackage>>emptyMap();
    return doExport(monitor,exportData);
  }
}",0.9998642226748132
11861,"/** 
 * This can be overriden to determine the parent of an object; this implementation uses   {@link EditingDomain#getParent}.
 */
protected Object getParent(Object object){
  return domain.getParent(object);
}","/** 
 * This can be overridden to determine the parent of an object; this implementation uses   {@link EditingDomain#getParent}.
 */
protected Object getParent(Object object){
  return domain.getParent(object);
}",0.9976359338061466
11862,"/** 
 * This can be overriden to determine the children of an object; this implementation uses   {@link EditingDomain#getChildren}.
 */
protected Collection<?> getChildren(Object object){
  return domain.getChildren(object);
}","/** 
 * This can be overridden to determine the children of an object; this implementation uses   {@link EditingDomain#getChildren}.
 */
protected Collection<?> getChildren(Object object){
  return domain.getChildren(object);
}",0.9977924944812362
11863,"/** 
 * This returns the orginal position to which the object will be moved upon undo.
 */
public int getOldIndex(){
  return oldIndex;
}","/** 
 * This returns the original position to which the object will be moved upon undo.
 */
public int getOldIndex(){
  return oldIndex;
}",0.9963636363636365
11864,"/** 
 * Removes the first occurence of the given target object, itself, from the collection.
 */
protected boolean removeExact(Collection<?> collection,Object target){
  for (Iterator<?> i=collection.iterator(); i.hasNext(); ) {
    if (i.next() == target) {
      i.remove();
      return true;
    }
  }
  return false;
}","/** 
 * Removes the first occurrence of the given target object, itself, from the collection.
 */
protected boolean removeExact(Collection<?> collection,Object target){
  for (Iterator<?> i=collection.iterator(); i.hasNext(); ) {
    if (i.next() == target) {
      i.remove();
      return true;
    }
  }
  return false;
}",0.9984544049459042
11865,"/** 
 * Create an instance from the adapter factory, the specialized command stack, and the specialized resource set. If the resource set's context is null, one will be created here; otherwize, the existing context should implement   {@link org.eclipse.emf.edit.domain.IEditingDomainProvider}.
 */
public AdapterFactoryEditingDomain(AdapterFactory adapterFactory,CommandStack commandStack,ResourceSet resourceSet){
  this.adapterFactory=adapterFactory;
  this.commandStack=commandStack;
  this.resourceSet=resourceSet;
}","/** 
 * Create an instance from the adapter factory, the specialized command stack, and the specialized resource set. If the resource set's context is null, one will be created here; otherwise, the existing context should implement   {@link org.eclipse.emf.edit.domain.IEditingDomainProvider}.
 */
public AdapterFactoryEditingDomain(AdapterFactory adapterFactory,CommandStack commandStack,ResourceSet resourceSet){
  this.adapterFactory=adapterFactory;
  this.commandStack=commandStack;
  this.resourceSet=resourceSet;
}",0.9980769230769232
11866,"/** 
 * This returns the editing domain for the given aribtrary object, or null, if it can't be determined. It is recommended that you always work directly with an EditingDomain instance whenever possible. This is implemented to checks if the object itself implements   {@link org.eclipse.emf.edit.domain.IEditingDomainProvider}and returns that result. Otherwise it checks if it is valid to call   {@link #getEditingDomainFor(org.eclipse.emf.ecore.EObject) getEditingDomainFor(EObject)} and returns that result or null. <p> It is recommended that you always keep an editing domain instance available through some other means; this should only be used to implement things such as a global popup action for some object; in such a cases such as that the editing domain returned here may well be one that belongs to some editor you know nothing about, which is what you want.
 */
static public EditingDomain getEditingDomainFor(Object object){
  if (object instanceof IEditingDomainProvider) {
    EditingDomain editingDomain=((IEditingDomainProvider)object).getEditingDomain();
    return editingDomain;
  }
 else   if (object instanceof EObject) {
    EditingDomain editingDomain=AdapterFactoryEditingDomain.getEditingDomainFor((EObject)object);
    return editingDomain;
  }
 else   if (object instanceof FeatureMap.Entry) {
    return getEditingDomainFor(((FeatureMap.Entry)object).getValue());
  }
 else   if (object instanceof IWrapperItemProvider) {
    return getEditingDomainFor(((IWrapperItemProvider)object).getValue());
  }
 else {
    return null;
  }
}","/** 
 * This returns the editing domain for the given arbitrary object, or null, if it can't be determined. It is recommended that you always work directly with an EditingDomain instance whenever possible. This is implemented to checks if the object itself implements   {@link org.eclipse.emf.edit.domain.IEditingDomainProvider}and returns that result. Otherwise it checks if it is valid to call   {@link #getEditingDomainFor(org.eclipse.emf.ecore.EObject) getEditingDomainFor(EObject)} and returns that result or null. <p> It is recommended that you always keep an editing domain instance available through some other means; this should only be used to implement things such as a global popup action for some object; in such a cases such as that the editing domain returned here may well be one that belongs to some editor you know nothing about, which is what you want.
 */
static public EditingDomain getEditingDomainFor(Object object){
  if (object instanceof IEditingDomainProvider) {
    EditingDomain editingDomain=((IEditingDomainProvider)object).getEditingDomain();
    return editingDomain;
  }
 else   if (object instanceof EObject) {
    EditingDomain editingDomain=AdapterFactoryEditingDomain.getEditingDomainFor((EObject)object);
    return editingDomain;
  }
 else   if (object instanceof FeatureMap.Entry) {
    return getEditingDomainFor(((FeatureMap.Entry)object).getValue());
  }
 else   if (object instanceof IWrapperItemProvider) {
    return getEditingDomainFor(((IWrapperItemProvider)object).getValue());
  }
 else {
    return null;
  }
}",0.998719590268886
11867,"/** 
 * Creates a new project
 * @param projectName Name of the project
 * @return Project
 * @throws CoreException 
 * @throws Exception
 */
protected IProject createProject(String projectName,IProgressMonitor monitor) throws CoreException {
  monitor.beginTask(CheatSheetsPlugin.INSTANCE.getString(""String_Node_Str"",new String[]{projectName}),2);
  IWorkspaceRoot workspaceRoot=ResourcesPlugin.getWorkspace().getRoot();
  IProject project=workspaceRoot.getProject(projectName);
  if (!project.exists()) {
    project.create(new SubProgressMonitor(monitor,1));
  }
  project.open(new SubProgressMonitor(monitor,1));
  monitor.done();
  return project;
}","/** 
 * Creates a new project
 * @param projectName Name of the project
 * @return Project
 * @throws CoreException 
 * @throws CoreException
 */
protected IProject createProject(String projectName,IProgressMonitor monitor) throws CoreException {
  monitor.beginTask(CheatSheetsPlugin.INSTANCE.getString(""String_Node_Str"",new String[]{projectName}),2);
  IWorkspaceRoot workspaceRoot=ResourcesPlugin.getWorkspace().getRoot();
  IProject project=workspaceRoot.getProject(projectName);
  if (!project.exists()) {
    project.create(new SubProgressMonitor(monitor,1));
  }
  project.open(new SubProgressMonitor(monitor,1));
  monitor.done();
  return project;
}",0.9969512195121952
11868,"/** 
 * This constructs an instance of an action that creates a child descripted by newChildDescriptor.
 */
public CreateChildAction(IEditorPart editorPart,ISelection selection,CommandParameter newChildDescriptor){
  super(editorPart);
  this.newChildDescriptor=newChildDescriptor;
  configureAction(selection);
}","/** 
 * This constructs an instance of an action that creates a child described by newChildDescriptor.
 */
public CreateChildAction(IEditorPart editorPart,ISelection selection,CommandParameter newChildDescriptor){
  super(editorPart);
  this.newChildDescriptor=newChildDescriptor;
  configureAction(selection);
}",0.9952
11869,"/** 
 * Returns a not null list with the GenPackages that should be selected  in the Rereferenced Tree Viewer.  The list passed in the genPackage is not null and contains all GenPackages that can be marked.  This list can be both changed and returned. 
 */
protected List<GenPackage> getReferencedGenPackagesToCheck(List<GenPackage> genPackages,boolean reloadReferencedGenPackagesTable){
  return genPackages;
}","/** 
 * Returns a not null list with the GenPackages that should be selected  in the referenced Tree Viewer.  The list passed in the genPackage is not null and contains all GenPackages that can be marked.  This list can be both changed and returned. 
 */
protected List<GenPackage> getReferencedGenPackagesToCheck(List<GenPackage> genPackages,boolean reloadReferencedGenPackagesTable){
  return genPackages;
}",0.997560975609756
11870,"/** 
 * <p>Subclasses should overwrite this method, adding the code that performs the actions required when this wizard is &quot;finished&quot;.</p> <p>The   {@link Diagnostic} returned by this method should be used to providethe user some information regarding a <b>successfull</b> convertion.  If the coversion fails, an exception should be thrown.<p>
 * @param monitor
 * @return {@link Diagnostic}
 * @throws Exception
 */
protected Diagnostic doPerformFinish(Monitor monitor) throws Exception {
  return Diagnostic.OK_INSTANCE;
}","/** 
 * <p>Subclasses should overwrite this method, adding the code that performs the actions required when this wizard is &quot;finished&quot;.</p> <p>The   {@link Diagnostic} returned by this method should be used to providethe user some information regarding a <b>successful</b> conversion.  If the conversion fails, an exception should be thrown.<p>
 * @param monitor
 * @return {@link Diagnostic}
 * @throws Exception
 */
protected Diagnostic doPerformFinish(Monitor monitor) throws Exception {
  return Diagnostic.OK_INSTANCE;
}",0.99625468164794
11871,"/** 
 * This contructs and instance in this editing domain.
 */
public CommandActionHandler(EditingDomain domain,String label){
  super(label);
  this.domain=domain;
}","/** 
 * This constructs and instance in this editing domain.
 */
public CommandActionHandler(EditingDomain domain,String label){
  super(label);
  this.domain=domain;
}",0.9970149253731344
11872,"/** 
 * This returns the transfer ids that this agent supports.
 */
@Override protected int[] getTypeIds(){
  return new int[]{TYPE_ID};
}","/** 
 * This returns the transfer IDs that this agent supports.
 */
@Override protected int[] getTypeIds(){
  return new int[]{TYPE_ID};
}",0.9855072463768116
11873,"/** 
 * Sets the containers where the template sources are located.
 * @param templateContainers the new locations.
 * @param templateSourceContainers the new sourcelocations.
 * @since 2.1.0
 */
public void setTemplateContainers(List<Object> templateContainers,List<Object> templateSourceContainers);","/** 
 * Sets the containers where the template sources are located.
 * @param templateContainers the new locations.
 * @param templateSourceContainers the new source locations.
 * @since 2.1.0
 */
public void setTemplateContainers(List<Object> templateContainers,List<Object> templateSourceContainers);",0.9983416252072967
11874,"/** 
 * Considers all the files of a container and all it's subcontainer.
 */
protected void consider(IContainer container) throws CoreException {
  IResource[] children=container.members();
  if (children != null) {
    for (int i=0; i < children.length; ++i) {
      IResource resource=children[i];
      if (resource instanceof IFile) {
        consider((IFile)resource);
      }
 else       if (resource instanceof IContainer) {
        consider((IContainer)resource);
      }
    }
  }
}","/** 
 * Considers all the files of a container and all its subcontainer.
 */
protected void consider(IContainer container) throws CoreException {
  IResource[] children=container.members();
  if (children != null) {
    for (int i=0; i < children.length; ++i) {
      IResource resource=children[i];
      if (resource instanceof IFile) {
        consider((IFile)resource);
      }
 else       if (resource instanceof IContainer) {
        consider((IContainer)resource);
      }
    }
  }
}",0.9989827060020344
11875,"public void handleDirective(String directive,JETMark start,JETMark stop,Map<String,String> attributes) throws JETException {
  if (directive.equals(""String_Node_Str"")) {
    String fileURI=attributes.get(""String_Node_Str"");
    if (fileURI != null) {
      String currentURI=start.getFile();
      String[] resolvedFileURI=resolveLocation(templateURIPath,currentURI,fileURI);
      if (resolvedFileURI[0].equals(currentURI)) {
        boolean loop=true;
        if (templateURIPath != null) {
          String baseURI=start.getBaseURI();
          if (baseURI != null) {
            for (int i=0; i < templateURIPath.length; ++i) {
              if (baseURI.equals(templateURIPath[i])) {
                resolvedFileURI=resolveLocation(templateURIPath,i + 1,currentURI,fileURI);
                loop=false;
              }
            }
          }
        }
        if (loop) {
          return;
        }
      }
      try {
        BufferedInputStream bufferedInputStream=new BufferedInputStream(openStream(resolvedFileURI[1]));
        reader.stackStream(resolvedFileURI[2],resolvedFileURI[0],bufferedInputStream,null);
        if (""String_Node_Str"".equals(attributes.get(""String_Node_Str""))) {
          skipSections.push(new SkipSection(sectionDepth + 1,!skipping));
        }
        if (fSavedLine != null) {
          return;
        }
      }
 catch (      JETException exception) {
        String failType=attributes.get(""String_Node_Str"");
        if (""String_Node_Str"".equals(failType)) {
          skipSections.push(new SkipSection(sectionDepth + 1,false));
        }
 else         if (!""String_Node_Str"".equals(failType)) {
          throw new JETException(CodeGenPlugin.getPlugin().getString(""String_Node_Str"",new Object[]{resolvedFileURI[1],start.format(""String_Node_Str"")}),exception);
        }
      }
    }
 else {
      throw new JETException(CodeGenPlugin.getPlugin().getString(""String_Node_Str"",new Object[]{""String_Node_Str"",start.format(""String_Node_Str"")}));
    }
  }
 else   if (directive.equals(""String_Node_Str"")) {
    sectionDepth++;
    SkipSection skipSection=skipSections.isEmpty() ? null : (SkipSection)skipSections.peek();
    if (skipSection == null || skipSection.depth != sectionDepth) {
      throw new JETException(CodeGenPlugin.getPlugin().getString(""String_Node_Str"",new Object[]{start.format(""String_Node_Str"")}));
    }
 else     if (skipSection.skip) {
      skipping=true;
    }
  }
 else   if (directive.equals(""String_Node_Str"")) {
    if (sectionDepth == 0) {
      throw new JETException(CodeGenPlugin.getPlugin().getString(""String_Node_Str"",new Object[]{""String_Node_Str"",""String_Node_Str"",start.format(""String_Node_Str"")}));
    }
    sectionDepth--;
    if (skipSections.pop().skip) {
      skipping=false;
    }
  }
 else   if (directive.equals(""String_Node_Str"")) {
    if (skeleton != null) {
    }
 else {
      skeleton=new JETSkeleton();
      String skeletonURI=attributes.get(""String_Node_Str"");
      if (skeletonURI != null) {
        try {
          BufferedInputStream bufferedInputStream=new BufferedInputStream(openStream(resolveLocation(templateURIPath,templateURI,skeletonURI)[1]));
          byte[] input=new byte[bufferedInputStream.available()];
          bufferedInputStream.read(input);
          bufferedInputStream.close();
          skeleton.setCompilationUnitContents(new String(input));
        }
 catch (        IOException exception) {
          throw new JETException(exception);
        }
      }
      for (      Map.Entry<String,String> entry : attributes.entrySet()) {
        if (entry.getKey().equals(""String_Node_Str"")) {
        }
 else         if (entry.getKey().equals(""String_Node_Str"")) {
          skeleton.setPackageName(entry.getValue());
        }
 else         if (entry.getKey().equals(""String_Node_Str"")) {
          skeleton.addImports(entry.getValue());
        }
 else         if (entry.getKey().equals(""String_Node_Str"")) {
          skeleton.setClassName(entry.getValue());
        }
 else         if (entry.getKey().equals(""String_Node_Str"")) {
          skeleton.setNLString(entry.getValue());
        }
 else         if (entry.getKey().equals(""String_Node_Str"")) {
          parser.setStartTag(entry.getValue());
        }
 else         if (entry.getKey().equals(""String_Node_Str"")) {
          parser.setEndTag(entry.getValue());
        }
 else         if (entry.getKey().equals(""String_Node_Str"")) {
        }
 else         throw new JETException(CodeGenPlugin.getPlugin().getString(""String_Node_Str"",new Object[]{entry.getKey(),start.format(""String_Node_Str"")}));
      }
      handleNewSkeleton();
    }
  }
  fSavedLine=null;
}","public void handleDirective(String directive,JETMark start,JETMark stop,Map<String,String> attributes) throws JETException {
  if (directive.equals(""String_Node_Str"")) {
    String fileURI=attributes.get(""String_Node_Str"");
    if (fileURI != null) {
      String currentURI=start.getFile();
      String[] resolvedFileURI=resolveLocation(templateURIPath,currentURI,fileURI);
      if (resolvedFileURI[0].equals(currentURI)) {
        boolean loop=true;
        if (templateURIPath != null) {
          String baseURI=start.getBaseURI();
          if (baseURI != null) {
            for (int i=0; i < templateURIPath.length; ++i) {
              if (baseURI.equals(templateURIPath[i])) {
                resolvedFileURI=resolveLocation(templateURIPath,i + 1,currentURI,fileURI);
                loop=false;
              }
            }
          }
        }
        if (loop) {
          return;
        }
      }
      try {
        BufferedInputStream bufferedInputStream=new BufferedInputStream(openStream(resolvedFileURI[1]));
        reader.stackStream(resolvedFileURI[2],resolvedFileURI[0],bufferedInputStream,null);
        if (""String_Node_Str"".equals(attributes.get(""String_Node_Str""))) {
          skipSections.push(new SkipSection(sectionDepth + 1,!skipping));
        }
        if (fSavedLine != null) {
          return;
        }
      }
 catch (      JETException exception) {
        String failType=attributes.get(""String_Node_Str"");
        if (""String_Node_Str"".equals(failType)) {
          skipSections.push(new SkipSection(sectionDepth + 1,false));
        }
 else         if (!""String_Node_Str"".equals(failType)) {
          throw new JETException(CodeGenPlugin.getPlugin().getString(""String_Node_Str"",new Object[]{resolvedFileURI[1],start.format(""String_Node_Str"")}),exception);
        }
      }
    }
 else {
      throw new JETException(CodeGenPlugin.getPlugin().getString(""String_Node_Str"",new Object[]{""String_Node_Str"",start.format(""String_Node_Str"")}));
    }
  }
 else   if (directive.equals(""String_Node_Str"")) {
    sectionDepth++;
    SkipSection skipSection=skipSections.isEmpty() ? null : (SkipSection)skipSections.peek();
    if (skipSection == null || skipSection.depth != sectionDepth) {
      throw new JETException(CodeGenPlugin.getPlugin().getString(""String_Node_Str"",new Object[]{start.format(""String_Node_Str"")}));
    }
 else     if (skipSection.skip) {
      skipping=true;
    }
  }
 else   if (directive.equals(""String_Node_Str"")) {
    if (sectionDepth == 0) {
      throw new JETException(CodeGenPlugin.getPlugin().getString(""String_Node_Str"",new Object[]{""String_Node_Str"",""String_Node_Str"",start.format(""String_Node_Str"")}));
    }
    sectionDepth--;
    if (skipSections.pop().skip) {
      skipping=false;
    }
  }
 else   if (directive.equals(""String_Node_Str"")) {
    if (skeleton != null) {
    }
 else {
      skeleton=new JETSkeleton();
      String skeletonURI=attributes.get(""String_Node_Str"");
      if (skeletonURI != null) {
        try {
          BufferedInputStream bufferedInputStream=new BufferedInputStream(openStream(resolveLocation(templateURIPath,templateURI,skeletonURI)[1]));
          byte[] input=new byte[bufferedInputStream.available()];
          bufferedInputStream.read(input);
          bufferedInputStream.close();
          skeleton.setCompilationUnitContents(new String(input));
        }
 catch (        IOException exception) {
          throw new JETException(exception);
        }
      }
      for (      Map.Entry<String,String> entry : attributes.entrySet()) {
        if (entry.getKey().equals(""String_Node_Str"")) {
        }
 else         if (entry.getKey().equals(""String_Node_Str"")) {
          skeleton.setPackageName(entry.getValue());
        }
 else         if (entry.getKey().equals(""String_Node_Str"")) {
          skeleton.addImports(entry.getValue());
        }
 else         if (entry.getKey().equals(""String_Node_Str"")) {
          skeleton.setClassName(entry.getValue());
        }
 else         if (entry.getKey().equals(""String_Node_Str"")) {
          skeleton.setNLString(entry.getValue());
        }
 else         if (entry.getKey().equals(""String_Node_Str"")) {
          parser.setStartTag(entry.getValue());
        }
 else         if (entry.getKey().equals(""String_Node_Str"")) {
          parser.setEndTag(entry.getValue());
        }
 else         if (entry.getKey().equals(""String_Node_Str"")) {
        }
 else {
          throw new JETException(CodeGenPlugin.getPlugin().getString(""String_Node_Str"",new Object[]{entry.getKey(),start.format(""String_Node_Str"")}));
        }
      }
      handleNewSkeleton();
    }
  }
  fSavedLine=null;
}",0.9984952708512468
11876,"/** 
 * Returns the method that will be invoked when   {@link #generate generate} called.
 * @return the generator method.
 */
public Method getMethod(){
  return method;
}","/** 
 * Returns the method that will be invoked when   {@link #generate(Monitor,Object[]) generate} called.
 * @return the generator method.
 */
public Method getMethod(){
  return method;
}",0.9502762430939228
11877,"/** 
 * Set the method that will be invoked when   {@link #generate generate} called.
 * @param method the generator method.
 */
public void setMethod(Method method){
  this.method=method;
  if ((method.getModifiers() & Modifier.STATIC) == 0 && object == null) {
    try {
      object=method.getDeclaringClass().newInstance();
    }
 catch (    IllegalAccessException exception) {
      CodeGenPlugin.INSTANCE.log(exception);
    }
catch (    InstantiationException exception) {
      CodeGenPlugin.INSTANCE.log(exception);
    }
  }
}","/** 
 * Set the method that will be invoked when   {@link #generate(Monitor,Object[]) generate} called.
 * @param method the generator method.
 */
public void setMethod(Method method){
  this.method=method;
  if ((method.getModifiers() & Modifier.STATIC) == 0 && object == null) {
    try {
      object=method.getDeclaringClass().newInstance();
    }
 catch (    IllegalAccessException exception) {
      CodeGenPlugin.INSTANCE.log(exception);
    }
catch (    InstantiationException exception) {
      CodeGenPlugin.INSTANCE.log(exception);
    }
  }
}",0.98348623853211
11878,"/** 
 * Returns a list of classpath entries that will be added to the classpath of the internal   {@link #getProjectName project}where emitted JET templates are compiled. <p> This method must be called <b>before</b>  {@link #initialize initialize} or {@link #generate generate}are called.
 * @return a list of classpath entries.
 */
public List<IClasspathEntry> getClasspathEntries(){
  return classpathEntries;
}","/** 
 * Returns a list of classpath entries that will be added to the classpath of the internal   {@link #getProjectName project}where emitted JET templates are compiled. <p> This method must be called <b>before</b>  {@link #initialize(Monitor) initialize} or {@link #generate(Monitor,Object[]) generate}are called.
 * @return a list of classpath entries.
 */
public List<IClasspathEntry> getClasspathEntries(){
  return classpathEntries;
}",0.9683470105509964
11879,"/** 
 * Adds a builder to the build spec for the given project.
 */
protected void addToFrontOfBuildSpec(String builderID) throws CoreException {
  IProjectDescription description=getProject().getDescription();
  ICommand[] commands=description.getBuildSpec();
  boolean found=false;
  for (int i=0; i < commands.length; ++i) {
    if (commands[i].getBuilderName().equals(builderID)) {
      found=true;
      break;
    }
  }
  if (!found) {
    ICommand command=description.newCommand();
    command.setBuilderName(builderID);
    ICommand[] newCommands=new ICommand[commands.length + 1];
    System.arraycopy(commands,0,newCommands,1,commands.length);
    newCommands[0]=command;
    description.setBuildSpec(newCommands);
    getProject().setDescription(description,null);
  }
}","/** 
 * Adds a builder to the build specification for the given project.
 */
protected void addToFrontOfBuildSpec(String builderID) throws CoreException {
  IProjectDescription description=getProject().getDescription();
  ICommand[] commands=description.getBuildSpec();
  boolean found=false;
  for (int i=0; i < commands.length; ++i) {
    if (commands[i].getBuilderName().equals(builderID)) {
      found=true;
      break;
    }
  }
  if (!found) {
    ICommand command=description.newCommand();
    command.setBuilderName(builderID);
    ICommand[] newCommands=new ICommand[commands.length + 1];
    System.arraycopy(commands,0,newCommands,1,commands.length);
    newCommands[0]=command;
    description.setBuildSpec(newCommands);
    getProject().setDescription(description,null);
  }
}",0.9942784488239034
11880,"/** 
 * Register a new baseURI. This method is used to implement file inclusion. Each included file gets a uniq identifier (which is the index in the array of base URIs).
 * @return The index of the now registered file.
 */
protected void registerBaseURI(String baseURI){
  baseURIs.add(baseURI);
}","/** 
 * Register a new baseURI. This method is used to implement file inclusion. Each included file gets a unique identifier (which is the index in the array of base URIs).
 */
protected void registerBaseURI(String baseURI){
  baseURIs.add(baseURI);
}",0.907103825136612
11881,"/** 
 * Parse some tag attributes. The stream is assumed to be positioned right after the tag name. The syntax recognized is: <pre> tag-attrs := empty | attr-list (""&gt;"" | ""--&gt;"" | %&gt;) attr-list := empty | av spaces attr-list empty     := spaces </pre> Where <em>av</em> is defined by <code>parseAttributeValue</code>.
 * @return A HashMap mapping String instances (variable names) intoString instances (variable values).
 */
public HashMap<String,String> parseTagAttributes() throws JETException {
  HashMap<String,String> values=new HashMap<String,String>(11);
  while (true) {
    skipSpaces();
    int ch=peekChar();
    if (ch == endTagFinalChar) {
      return values;
    }
    if (ch == '-') {
      JETMark mark=mark();
      nextChar();
      try {
        if (nextChar() == '-' && nextChar() == endTagFinalChar) {
          return values;
        }
      }
  finally {
        reset(mark);
      }
    }
 else     if (ch == endTagInitialChar) {
      JETMark mark=mark();
      nextChar();
      try {
        if (nextChar() == endTagFinalChar) {
          return values;
        }
      }
  finally {
        reset(mark);
      }
    }
 else     if (ch == '/') {
      JETMark mark=mark();
      nextChar();
      try {
        if (nextChar() == endTagFinalChar) {
          return values;
        }
      }
  finally {
        reset(mark);
      }
    }
    if (ch == -1) {
      break;
    }
    parseAttributeValue(values);
  }
  throw new JETException(CodeGenPlugin.getPlugin().getString(""String_Node_Str"",new Object[]{mark().toString()}));
}","/** 
 * Parse some tag attributes. The stream is assumed to be positioned right after the tag name. The syntax recognized is: <pre> tag-attributes := empty | attribute-list (""&gt;"" | ""--&gt;"" | %&gt;) attribute-list := empty | attribute-value spaces attribute-list empty     := spaces </pre> Where <em>attribute-value</em> is defined by <code>parseAttributeValue</code>.
 * @return A HashMap mapping String instances (variable names) intoString instances (variable values).
 */
public HashMap<String,String> parseTagAttributes() throws JETException {
  HashMap<String,String> values=new HashMap<String,String>(11);
  while (true) {
    skipSpaces();
    int ch=peekChar();
    if (ch == endTagFinalChar) {
      return values;
    }
    if (ch == '-') {
      JETMark mark=mark();
      nextChar();
      try {
        if (nextChar() == '-' && nextChar() == endTagFinalChar) {
          return values;
        }
      }
  finally {
        reset(mark);
      }
    }
 else     if (ch == endTagInitialChar) {
      JETMark mark=mark();
      nextChar();
      try {
        if (nextChar() == endTagFinalChar) {
          return values;
        }
      }
  finally {
        reset(mark);
      }
    }
 else     if (ch == '/') {
      JETMark mark=mark();
      nextChar();
      try {
        if (nextChar() == endTagFinalChar) {
          return values;
        }
      }
  finally {
        reset(mark);
      }
    }
    if (ch == -1) {
      break;
    }
    parseAttributeValue(values);
  }
  throw new JETException(CodeGenPlugin.getPlugin().getString(""String_Node_Str"",new Object[]{mark().toString()}));
}",0.9779458097038436
11882,"/** 
 * Register a new source file. This method is used to implement file inclusion. Each included file gets a uniq identifier (which is the index in the array of source files).
 * @return The index of the now registered file.
 */
protected int registerSourceFile(String file){
  sourceFiles.add(file);
  ++this.size;
  return sourceFiles.size() - 1;
}","/** 
 * Register a new source file. This method is used to implement file inclusion. Each included file gets a unique identifier (which is the index in the array of source files).
 * @return The index of the now registered file.
 */
protected int registerSourceFile(String file){
  sourceFiles.add(file);
  ++this.size;
  return sourceFiles.size() - 1;
}",0.9971671388101984
11883,"/** 
 * Parse utils - Is current character a token delimiter ? Delimiters are currently defined to be =, &gt;, &lt;, "", and ' or any any space character as defined by <code>isSpace</code>.
 * @return A boolean.
 */
protected boolean isDelimiter(){
  if (!isSpace()) {
    int ch=peekChar();
    if (ch == '=' || ch == endTagFinalChar || ch == '""' || ch == '\'' || ch == '/') {
      return true;
    }
    if (ch == '-') {
      JETMark mark=mark();
      if (((ch=nextChar()) == endTagFinalChar) || ((ch == '-') && (nextChar() == endTagFinalChar))) {
        reset(mark);
        return true;
      }
 else {
        reset(mark);
        return false;
      }
    }
    return false;
  }
 else {
    return true;
  }
}","/** 
 * Parse utilities - Is current character a token delimiter ? Delimiters are currently defined to be =, &gt;, &lt;, "", and ' or any any space character as defined by <code>isSpace</code>.
 * @return A boolean.
 */
protected boolean isDelimiter(){
  if (!isSpace()) {
    int ch=peekChar();
    if (ch == '=' || ch == endTagFinalChar || ch == '""' || ch == '\'' || ch == '/') {
      return true;
    }
    if (ch == '-') {
      JETMark mark=mark();
      if (((ch=nextChar()) == endTagFinalChar) || ((ch == '-') && (nextChar() == endTagFinalChar))) {
        reset(mark);
        return true;
      }
 else {
        reset(mark);
        return false;
      }
    }
    return false;
  }
 else {
    return true;
  }
}",0.9972260748959778
11884,"/** 
 * Utilitiy for headless operations.
 * @param mergeXML
 * @param sourceURI
 * @param targetURI
 * @return the merged content
 * @since 2.1.0
 */
public String execute(IProgressMonitor progressMonitor,String[] arguments){
  String mergeXML=arguments[0];
  String sourceURI=arguments[1];
  String targetURI=arguments[2];
  jControlModel=new JControlModel(mergeXML);
  sourceCompilationUnit=createCompilationUnitForURI(sourceURI);
  targetCompilationUnit=createCompilationUnitForURI(targetURI);
  sourcePatternDictionary=new JPatternDictionary(sourceCompilationUnit,jControlModel);
  targetPatternDictionary=new JPatternDictionary(targetCompilationUnit,jControlModel);
  merge();
  return targetCompilationUnit.getContents();
}","/** 
 * Utility for headless operations.
 * @return the merged content
 * @since 2.1.0
 */
public String execute(IProgressMonitor progressMonitor,String[] arguments){
  String mergeXML=arguments[0];
  String sourceURI=arguments[1];
  String targetURI=arguments[2];
  jControlModel=new JControlModel(mergeXML);
  sourceCompilationUnit=createCompilationUnitForURI(sourceURI);
  targetCompilationUnit=createCompilationUnitForURI(targetURI);
  sourcePatternDictionary=new JPatternDictionary(sourceCompilationUnit,jControlModel);
  targetPatternDictionary=new JPatternDictionary(targetCompilationUnit,jControlModel);
  merge();
  return targetCompilationUnit.getContents();
}",0.9571428571428572
11885,"/** 
 * Creates an input stream for the nested URL by calling   {@link URL#openStream()opening} a stream on it.
 * @param nestedURL the nested URL for which a stream is required.
 * @return the open stream of the nested URL.
 */
protected OutputStream createOutputStream(String nestedURL) throws IOException {
  URL url=new URL(nestedURL.toString());
  URLConnection urlConnection=url.openConnection();
  urlConnection.setDoOutput(true);
  return urlConnection.getOutputStream();
}","/** 
 * Creates an output stream for the nested URL by calling   {@link URL#openConnection() opening} a stream on it.
 * @param nestedURL the nested URL for which a stream is required.
 * @return the open stream of the nested URL.
 */
protected OutputStream createOutputStream(String nestedURL) throws IOException {
  URL url=new URL(nestedURL.toString());
  URLConnection urlConnection=url.openConnection();
  urlConnection.setDoOutput(true);
  return urlConnection.getOutputStream();
}",0.9731404958677686
11886,"/** 
 * Creates an input stream for the nested URL by calling   {@link URL#openStream()opening} a stream on it.
 * @param nestedURL the nested URL for which a stream is required.
 * @return the open stream of the nested URL.
 */
protected InputStream createInputStream(String nestedURL) throws IOException {
  return new URL(nestedURL).openStream();
}","/** 
 * Creates an input stream for the nested URL by calling   {@link URL#openStream() opening} a stream on it.
 * @param nestedURL the nested URL for which a stream is required.
 * @return the open stream of the nested URL.
 */
protected InputStream createInputStream(String nestedURL) throws IOException {
  return new URL(nestedURL).openStream();
}",0.9985775248933144
11887,"/** 
 * Returns whether the comamad is valid to <code>execute</code>. The   {@link UnexecutableCommand#INSTANCE}.<code>canExecute()</code> always returns <code>false</code>. This <b>must</b> be called before calling <code>execute</code>.
 * @return whether the comamad is valid to <code>execute</code>.
 */
boolean canExecute();","/** 
 * Returns whether the command is valid to <code>execute</code>. The   {@link UnexecutableCommand#INSTANCE}.<code>canExecute()</code> always returns <code>false</code>. This <b>must</b> be called before calling <code>execute</code>.
 * @return whether the command is valid to <code>execute</code>.
 */
boolean canExecute();",0.9817073170731708
11888,"/** 
 * Returns a command that represents the composition of this command with the given command. The resulting command may just be this, if this command is capabable of composition. Otherwise, it will be a new command created to compose the two. <p> Instead of the following pattern of usage <pre> Command result = x; if (condition) result = result.chain(y); </pre> you should consider using a   {@link org.eclipse.emf.common.command.CompoundCommand} and using  {@link org.eclipse.emf.common.command.CompoundCommand#unwrap()} to optimize the result:<pre> CompoundCommand subcommands = new CompoundCommand(); subcommands.append(x); if (condition) subcommands.append(y); Command result = subcommands.unwrap(); </pre> This gives you more control over how the compound command composes it's result and affected objects.
 * @param command the command to chain.
 * @return a command that represents the composition of this command with the given command.
 */
Command chain(Command command);","/** 
 * Returns a command that represents the composition of this command with the given command. The resulting command may just be this, if this command is capable of composition. Otherwise, it will be a new command created to compose the two. <p> Instead of the following pattern of usage <pre> Command result = x; if (condition) result = result.chain(y); </pre> you should consider using a   {@link org.eclipse.emf.common.command.CompoundCommand} and using  {@link org.eclipse.emf.common.command.CompoundCommand#unwrap()} to optimize the result:<pre> CompoundCommand subcommands = new CompoundCommand(); subcommands.append(x); if (condition) subcommands.append(y); Command result = subcommands.unwrap(); </pre> This gives you more control over how the compound command composes it's result and affected objects.
 * @param command the command to chain.
 * @return a command that represents the composition of this command with the given command.
 */
Command chain(Command command);",0.9989837398373984
11889,"/** 
 * Returns one of three things:   {@link org.eclipse.emf.common.command.UnexecutableCommand#INSTANCE}, if there are no commands, the one command, if there is exactly one command, or <code>this</code>, if there are multiple commands; this command is   {@link #dispose}d in the first two cases. You should only unwrap a compound command if you created it for that purpose, e.g., <pre> CompoundCommand subcommands = new CompoundCommand(); subcommands.append(x); if (condition) subcommands.append(y); Command result = subcommands.unwrap(); </pre> is a good way to create an efficient accumulated result.
 * @return the unwapped command.
 */
public Command unwrap(){
switch (commandList.size()) {
case 0:
{
      dispose();
      return UnexecutableCommand.INSTANCE;
    }
case 1:
{
    Command result=commandList.remove(0);
    dispose();
    return result;
  }
default :
{
  return this;
}
}
}","/** 
 * Returns one of three things:   {@link org.eclipse.emf.common.command.UnexecutableCommand#INSTANCE}, if there are no commands, the one command, if there is exactly one command, or <code>this</code>, if there are multiple commands; this command is   {@link #dispose}d in the first two cases. You should only unwrap a compound command if you created it for that purpose, e.g., <pre> CompoundCommand subcommands = new CompoundCommand(); subcommands.append(x); if (condition) subcommands.append(y); Command result = subcommands.unwrap(); </pre> is a good way to create an efficient accumulated result.
 * @return the unwrapped command.
 */
public Command unwrap(){
switch (commandList.size()) {
case 0:
{
      dispose();
      return UnexecutableCommand.INSTANCE;
    }
case 1:
{
    Command result=commandList.remove(0);
    dispose();
    return result;
  }
default :
{
  return this;
}
}
}",0.9994416527079844
11890,"/** 
 * Unsets the target from which the adapter will receive notification. This method is only to be called by a notifier when this adapter is removed from its adapter list. In general, an adapter may be shared by more than one notifier, so this mechanism allows the adapter to know specifically which notifier will no longer be notifying.
 * @param oldTarget the old notifier.
 * @see #getTarget
 * @see #setTarget
 */
void unsetTarget(Notifier oldTarget);","/** 
 * Unsets the target from which the adapter will receive notification. This method is only to be called by a notifier when this adapter is removed from its adapter list. In general, an adapter may be shared by more than one notifier, so this mechanism allows the adapter to know specifically which notifier will no longer be notifying.
 * @param oldTarget the old notifier.
 * @see #getTarget()
 * @see #setTarget(Notifier)
 */
void unsetTarget(Notifier oldTarget);",0.9418103448275862
11891,"/** 
 * Returns true if this notification represents an event that did not change the state of the notifying object. For the events   {@link #ADD},   {@link #ADD_MANY},   {@link #REMOVE},   {@link #REMOVE_MANY},   {@link #MOVE},  it always returns false. For the events   {@link #RESOLVE} and {@link #REMOVING_ADAPTER} it always returns true.For the events  {@link #SET} and {@link #UNSET} it returns true if the old and the new value are equal;In addition, for certain types of features there may be a distiction between  being set to a default value and not being set at all, which implies that it has the default value. In this situation, even in the case that the old and new values are equal,  isTouch may never the less return false in order to indicate that, although the value has not changed, the feature has gone from simply having a default value to being set to that same default value, or has gone from being set to the default value back to being unset.
 * @return whether or not this is a state changing modification.
 */
boolean isTouch();","/** 
 * Returns true if this notification represents an event that did not change the state of the notifying object. For the events   {@link #ADD},   {@link #ADD_MANY},   {@link #REMOVE},   {@link #REMOVE_MANY},   {@link #MOVE},  it always returns false. For the events   {@link #RESOLVE} and {@link #REMOVING_ADAPTER} it always returns true.For the events  {@link #SET} and {@link #UNSET} it returns true if the old and the new value are equal;In addition, for certain types of features there may be a distinction between  being set to a default value and not being set at all, which implies that it has the default value. In this situation, even in the case that the old and new values are equal,  isTouch may never the less return false in order to indicate that, although the value has not changed, the feature has gone from simply having a default value to being set to that same default value, or has gone from being set to the default value back to being unset.
 * @return whether or not this is a state changing modification.
 */
boolean isTouch();",0.9995262908574136
11892,"/** 
 * Returns the position within a list-based feature at which the change occurred. It returns   {@link #NO_INDEX} when not applicable.
 * @return the positition at which the change occurred.
 */
int getPosition();","/** 
 * Returns the position within a list-based feature at which the change occurred. It returns   {@link #NO_INDEX} when not applicable.
 * @return the position at which the change occurred.
 */
int getPosition();",0.9953703703703703
11893,"protected void applyPullRules(IDOMNode sourceNode,IDOMNode targetNode){
  try {
    for (Iterator pullRules=jControlModel.getPullRules().iterator(); pullRules.hasNext(); ) {
      JControlModel.PullRule pullRule=(JControlModel.PullRule)pullRules.next();
      if (sourcePatternDictionary.isMarkedUp(pullRule.getSourceMarkup(),sourceNode) && targetPatternDictionary.isMarkedUp(pullRule.getTargetMarkup(),targetNode) && pullRule.getSourceGetFeature().getFeatureClass() != null && pullRule.getSourceGetFeature().getFeatureClass().isInstance(sourceNode) && pullRule.getTargetPutFeature().getFeatureClass() != null && pullRule.getTargetPutFeature().getFeatureClass().isInstance(targetNode)) {
        Method sourceGetMethod=pullRule.getSourceGetFeature().getFeatureMethod();
        Object value=sourceGetMethod.invoke(sourceNode,noArguments);
        Method targetPutMethod=pullRule.getTargetPutFeature().getFeatureMethod();
        if (!sourceGetMethod.getReturnType().isArray() || targetPutMethod.getParameterTypes()[0].isAssignableFrom(sourceGetMethod.getReturnType())) {
          if (value instanceof String) {
            String stringValue=(String)value;
            stringValue=applyFormatRules(stringValue);
            Pattern sourceTransfer=pullRule.getSourceTransfer();
            if (sourceTransfer != null) {
              String oldStringValue=(String)sourceGetMethod.invoke(targetNode,noArguments);
              Matcher sourceMatcher=sourceTransfer.matcher(stringValue);
              Matcher targetMatcher=sourceTransfer.matcher(oldStringValue);
              if (sourceMatcher.groupCount() >= 1 && targetMatcher.groupCount() >= 1) {
                StringBuffer result=new StringBuffer();
                int index=0;
                while (sourceMatcher.find() && targetMatcher.find()) {
                  result.append(stringValue.substring(index,sourceMatcher.start(1)));
                  result.append(targetMatcher.group(1));
                  index=sourceMatcher.end(1);
                }
                if (result.length() == 0) {
                  stringValue=null;
                }
 else {
                  result.append(stringValue.substring(index));
                  stringValue=result.toString();
                }
              }
 else {
                stringValue=null;
              }
            }
            value=stringValue;
          }
          if (value != null || targetPutMethod.getName().equals(""String_Node_Str"") || targetPutMethod.getName().equals(""String_Node_Str"") || targetPutMethod.getName().equals(""String_Node_Str"")) {
            Object oldValue=sourceGetMethod.invoke(targetNode,noArguments);
            if (value == null ? oldValue == null : value.equals(oldValue)) {
              continue;
            }
 else             if (targetPutMethod.getName().equals(""String_Node_Str"")) {
              if (oldValue != null && value != null && ((String)oldValue).trim().equals(((String)value).trim())) {
                continue;
              }
            }
            if (sourceGetMethod.getName().equals(""String_Node_Str"") && jControlModel.getBlockPattern() != null && ((IDOMMethod)targetNode).getComment() != null && jControlModel.getBlockPattern().matcher(((IDOMMethod)targetNode).getComment()).find()) {
              continue;
            }
            targetPutMethod.invoke(targetNode,new Object[]{value});
            if (targetPutMethod.getName().equals(""String_Node_Str"") && sourceNode instanceof IDOMMethod) {
              IDOMMethod sourceMethod=(IDOMMethod)sourceNode;
              IDOMMethod targetMethod=(IDOMMethod)targetNode;
              String[] sourceParameterNames=sourceMethod.getParameterNames();
              String[] targetParameterTypes=targetMethod.getParameterTypes();
              targetMethod.setParameters(targetParameterTypes,sourceParameterNames);
            }
          }
        }
 else {
          ArrayList additionalStrings=new ArrayList();
          String[] sourceStrings=(String[])value;
          if (sourceStrings != null) {
            additionalStrings.addAll(Arrays.asList(sourceStrings));
          }
          if (targetPutMethod.getName().equals(""String_Node_Str"")) {
            Pattern sourceTransfer=pullRule.getSourceTransfer();
            if (sourceTransfer != null) {
              String comment=((IDOMMember)targetNode).getComment();
              Matcher matcher=sourceTransfer.matcher(comment);
              while (matcher.find() && matcher.groupCount() >= 1) {
                String clientStrings=comment.substring(matcher.start(matcher.groupCount()),matcher.end(matcher.groupCount()));
                for (StringTokenizer stringTokenizer=new StringTokenizer(clientStrings,""String_Node_Str""); stringTokenizer.hasMoreTokens(); ) {
                  String token=stringTokenizer.nextToken();
                  if (!additionalStrings.contains(token)) {
                    additionalStrings.add(token);
                  }
                }
              }
            }
            IDOMType type=(IDOMType)targetNode;
            String[] superInterfaces=(String[])additionalStrings.toArray(new String[additionalStrings.size()]);
            if (type.getSuperInterfaces() == null ? superInterfaces.length != 0 : !Arrays.equals(type.getSuperInterfaces(),superInterfaces)) {
              type.setSuperInterfaces((String[])additionalStrings.toArray(new String[additionalStrings.size()]));
            }
          }
 else {
            String[] oldStringValues=(String[])sourceGetMethod.invoke(targetNode,noArguments);
            List old=oldStringValues == null ? Collections.EMPTY_LIST : Arrays.asList(oldStringValues);
            for (Iterator i=additionalStrings.iterator(); i.hasNext(); ) {
              String string=(String)i.next();
              if (!old.contains(string)) {
                targetPutMethod.invoke(targetNode,new Object[]{string});
              }
            }
          }
        }
      }
    }
  }
 catch (  InvocationTargetException exception) {
  }
catch (  IllegalAccessException exception) {
  }
}","protected void applyPullRules(IDOMNode sourceNode,IDOMNode targetNode){
  try {
    for (Iterator pullRules=jControlModel.getPullRules().iterator(); pullRules.hasNext(); ) {
      JControlModel.PullRule pullRule=(JControlModel.PullRule)pullRules.next();
      if (sourcePatternDictionary.isMarkedUp(pullRule.getSourceMarkup(),sourceNode) && targetPatternDictionary.isMarkedUp(pullRule.getTargetMarkup(),targetNode) && pullRule.getSourceGetFeature().getFeatureMethod() != null && pullRule.getSourceGetFeature().getFeatureClass().isInstance(sourceNode) && pullRule.getTargetPutFeature().getFeatureMethod() != null && pullRule.getTargetPutFeature().getFeatureClass().isInstance(targetNode)) {
        Method sourceGetMethod=pullRule.getSourceGetFeature().getFeatureMethod();
        Object value=sourceGetMethod.invoke(sourceNode,noArguments);
        Method targetPutMethod=pullRule.getTargetPutFeature().getFeatureMethod();
        if (!sourceGetMethod.getReturnType().isArray() || targetPutMethod.getParameterTypes()[0].isAssignableFrom(sourceGetMethod.getReturnType())) {
          if (value instanceof String) {
            String stringValue=(String)value;
            stringValue=applyFormatRules(stringValue);
            Pattern sourceTransfer=pullRule.getSourceTransfer();
            if (sourceTransfer != null) {
              String oldStringValue=(String)sourceGetMethod.invoke(targetNode,noArguments);
              Matcher sourceMatcher=sourceTransfer.matcher(stringValue);
              Matcher targetMatcher=sourceTransfer.matcher(oldStringValue);
              if (sourceMatcher.groupCount() >= 1 && targetMatcher.groupCount() >= 1) {
                StringBuffer result=new StringBuffer();
                int index=0;
                while (sourceMatcher.find() && targetMatcher.find()) {
                  result.append(stringValue.substring(index,sourceMatcher.start(1)));
                  result.append(targetMatcher.group(1));
                  index=sourceMatcher.end(1);
                }
                if (result.length() == 0) {
                  stringValue=null;
                }
 else {
                  result.append(stringValue.substring(index));
                  stringValue=result.toString();
                }
              }
 else {
                stringValue=null;
              }
            }
            value=stringValue;
          }
          if (value != null || targetPutMethod.getName().equals(""String_Node_Str"") || targetPutMethod.getName().equals(""String_Node_Str"") || targetPutMethod.getName().equals(""String_Node_Str"")) {
            Object oldValue=sourceGetMethod.invoke(targetNode,noArguments);
            if (value == null ? oldValue == null : value.equals(oldValue)) {
              continue;
            }
 else             if (targetPutMethod.getName().equals(""String_Node_Str"")) {
              if (oldValue != null && value != null && ((String)oldValue).trim().equals(((String)value).trim())) {
                continue;
              }
            }
            if (sourceGetMethod.getName().equals(""String_Node_Str"") && jControlModel.getBlockPattern() != null && ((IDOMMethod)targetNode).getComment() != null && jControlModel.getBlockPattern().matcher(((IDOMMethod)targetNode).getComment()).find()) {
              continue;
            }
            targetPutMethod.invoke(targetNode,new Object[]{value});
            if (targetPutMethod.getName().equals(""String_Node_Str"") && sourceNode instanceof IDOMMethod) {
              IDOMMethod sourceMethod=(IDOMMethod)sourceNode;
              IDOMMethod targetMethod=(IDOMMethod)targetNode;
              String[] sourceParameterNames=sourceMethod.getParameterNames();
              String[] targetParameterTypes=targetMethod.getParameterTypes();
              targetMethod.setParameters(targetParameterTypes,sourceParameterNames);
            }
          }
        }
 else {
          ArrayList additionalStrings=new ArrayList();
          String[] sourceStrings=(String[])value;
          if (sourceStrings != null) {
            additionalStrings.addAll(Arrays.asList(sourceStrings));
          }
          if (targetPutMethod.getName().equals(""String_Node_Str"")) {
            Pattern sourceTransfer=pullRule.getSourceTransfer();
            if (sourceTransfer != null) {
              String comment=((IDOMMember)targetNode).getComment();
              Matcher matcher=sourceTransfer.matcher(comment);
              while (matcher.find() && matcher.groupCount() >= 1) {
                String clientStrings=comment.substring(matcher.start(matcher.groupCount()),matcher.end(matcher.groupCount()));
                for (StringTokenizer stringTokenizer=new StringTokenizer(clientStrings,""String_Node_Str""); stringTokenizer.hasMoreTokens(); ) {
                  String token=stringTokenizer.nextToken();
                  if (!additionalStrings.contains(token)) {
                    additionalStrings.add(token);
                  }
                }
              }
            }
            IDOMType type=(IDOMType)targetNode;
            String[] superInterfaces=(String[])additionalStrings.toArray(new String[additionalStrings.size()]);
            if (type.getSuperInterfaces() == null ? superInterfaces.length != 0 : !Arrays.equals(type.getSuperInterfaces(),superInterfaces)) {
              type.setSuperInterfaces((String[])additionalStrings.toArray(new String[additionalStrings.size()]));
            }
          }
 else {
            String[] oldStringValues=(String[])sourceGetMethod.invoke(targetNode,noArguments);
            List old=oldStringValues == null ? Collections.EMPTY_LIST : Arrays.asList(oldStringValues);
            for (Iterator i=additionalStrings.iterator(); i.hasNext(); ) {
              String string=(String)i.next();
              if (!old.contains(string)) {
                targetPutMethod.invoke(targetNode,new Object[]{string});
              }
            }
          }
        }
      }
    }
  }
 catch (  InvocationTargetException exception) {
  }
catch (  IllegalAccessException exception) {
  }
}",0.998183919432062
11894,"protected void applyPullRules(JNode sourceNode,JNode targetNode){
  try {
    for (    JControlModel.PullRule pullRule : getControlModel().getPullRules()) {
      if (pullRule.getSourceGetFeature().getFeatureClass() != null && pullRule.getSourceGetFeature().getFeatureClass().isInstance(sourceNode) && pullRule.getTargetPutFeature().getFeatureClass() != null && pullRule.getTargetPutFeature().getFeatureClass().isInstance(targetNode) && sourcePatternDictionary.isMarkedUp(pullRule.getSourceMarkup(),pullRule.getSourceParentMarkup(),sourceNode) && targetPatternDictionary.isMarkedUp(pullRule.getTargetMarkup(),pullRule.getTargetParentMarkup(),targetNode)) {
        if (pullRule.getEqualityFeature() != null) {
          Method equalityFeatureMethod=pullRule.getEqualityFeature().getFeatureMethod();
          Object value1=equalityFeatureMethod.invoke(sourceNode,NO_ARGUMENTS);
          Object value2=equalityFeatureMethod.invoke(targetNode,NO_ARGUMENTS);
          if (value1 == null ? value2 != null : !value1.equals(value2)) {
            continue;
          }
        }
        Method sourceGetMethod=pullRule.getSourceGetFeature().getFeatureMethod();
        Object value=sourceGetMethod.invoke(sourceNode,NO_ARGUMENTS);
        Method targetPutMethod=pullRule.getTargetPutFeature().getFeatureMethod();
        if (!sourceGetMethod.getReturnType().isArray() || targetPutMethod.getParameterTypes()[0].isAssignableFrom(sourceGetMethod.getReturnType())) {
          if (value instanceof String) {
            String stringValue=(String)value;
            stringValue=getControlModel().getFacadeHelper().applyFormatRules(stringValue);
            Pattern sourceTransfer=pullRule.getSourceTransfer();
            if (sourceTransfer != null) {
              String oldStringValue=(String)sourceGetMethod.invoke(targetNode,NO_ARGUMENTS);
              if (oldStringValue != null) {
                Matcher sourceMatcher=sourceTransfer.matcher(stringValue);
                Matcher targetMatcher=sourceTransfer.matcher(oldStringValue);
                if (sourceMatcher.groupCount() >= 1 && targetMatcher.groupCount() >= 1) {
                  StringBuilder result=new StringBuilder();
                  int index=0;
                  int sourceStart=0;
                  int targetStart=0;
                  if (sourceTransfer.pattern().startsWith(""String_Node_Str"")) {
                    sourceStart=getStartIndex(stringValue);
                    targetStart=getStartIndex(oldStringValue);
                  }
                  for (boolean match=sourceMatcher.find(sourceStart) && targetMatcher.find(targetStart); match; match=sourceMatcher.find() && targetMatcher.find()) {
                    result.append(stringValue.substring(index,sourceMatcher.start(1)));
                    result.append(targetMatcher.group(1));
                    index=sourceMatcher.end(1);
                  }
                  if (result.length() == 0) {
                    stringValue=null;
                  }
 else {
                    result.append(stringValue.substring(index));
                    stringValue=result.toString();
                  }
                }
 else {
                  stringValue=null;
                }
              }
            }
            value=stringValue;
          }
          if (value != null || targetPutMethod.getName().equals(""String_Node_Str"") || targetPutMethod.getName().equals(""String_Node_Str"") || targetPutMethod.getName().equals(""String_Node_Str"")) {
            Object oldValue=sourceGetMethod.invoke(targetNode,NO_ARGUMENTS);
            if (value == null ? oldValue == null : value.equals(oldValue)) {
              continue;
            }
 else             if (value instanceof Object[] && oldValue instanceof Object[] && Arrays.equals((Object[])value,(Object[])oldValue)) {
              continue;
            }
 else             if (targetPutMethod.getName().equals(""String_Node_Str"")) {
              if (oldValue != null && value != null && ((String)oldValue).trim().equals(((String)value).trim())) {
                continue;
              }
            }
            if (sourceGetMethod.getName().equals(""String_Node_Str"") && getControlModel().getBlockPattern() != null && ((JMethod)targetNode).getComment() != null && getControlModel().getBlockPattern().matcher(((JMethod)targetNode).getComment()).find()) {
              continue;
            }
            targetPutMethod.invoke(targetNode,new Object[]{value});
            targetCompilationChanged=true;
            if (targetPutMethod.getName().equals(""String_Node_Str"") && sourceNode instanceof JMethod) {
              JMethod sourceMethod=(JMethod)sourceNode;
              JMethod targetMethod=(JMethod)targetNode;
              String[] sourceParameterNames=sourceMethod.getParameterNames();
              targetMethod.setParameterNames(sourceParameterNames);
            }
          }
        }
 else {
          ArrayList<String> additionalStrings=new ArrayList<String>();
          String[] sourceStrings=(String[])value;
          if (sourceStrings != null) {
            additionalStrings.addAll(Arrays.asList(sourceStrings));
          }
          if (targetPutMethod.getName().equals(""String_Node_Str"")) {
            Pattern sourceTransfer=pullRule.getSourceTransfer();
            String comment=((JMember)targetNode).getComment();
            if (sourceTransfer != null && comment != null) {
              Matcher matcher=sourceTransfer.matcher(comment);
              while (matcher.find() && matcher.groupCount() >= 1) {
                String clientStrings=comment.substring(matcher.start(matcher.groupCount()),matcher.end(matcher.groupCount()));
                for (StringTokenizer stringTokenizer=new StringTokenizer(clientStrings,""String_Node_Str""); stringTokenizer.hasMoreTokens(); ) {
                  String token=stringTokenizer.nextToken();
                  if (!additionalStrings.contains(token)) {
                    additionalStrings.add(token);
                  }
                }
              }
            }
            String[] oldSuperInterfaces=(String[])sourceGetMethod.invoke(targetNode);
            String[] superInterfaces=additionalStrings.toArray(new String[additionalStrings.size()]);
            if (oldSuperInterfaces == null ? superInterfaces.length != 0 : !Arrays.equals(oldSuperInterfaces,superInterfaces)) {
              Method putMethod=targetNode.getClass().getMethod(""String_Node_Str"",String[].class);
              putMethod.invoke(targetNode,new Object[]{superInterfaces});
              targetCompilationChanged=true;
            }
          }
 else {
            String[] oldStringValues=(String[])sourceGetMethod.invoke(targetNode,NO_ARGUMENTS);
            List<String> old=oldStringValues == null ? Collections.<String>emptyList() : Arrays.<String>asList(oldStringValues);
            for (            String string : additionalStrings) {
              if (!old.contains(string)) {
                targetPutMethod.invoke(targetNode,new Object[]{string});
                targetCompilationChanged=true;
              }
            }
          }
        }
      }
    }
  }
 catch (  InvocationTargetException exception) {
    if (DEBUG) {
      exception.printStackTrace();
    }
  }
catch (  IllegalAccessException exception) {
    if (DEBUG) {
      exception.printStackTrace();
    }
  }
catch (  SecurityException e) {
    if (DEBUG) {
      e.printStackTrace();
    }
  }
catch (  NoSuchMethodException e) {
    if (DEBUG) {
      e.printStackTrace();
    }
  }
}","protected void applyPullRules(JNode sourceNode,JNode targetNode){
  try {
    for (    JControlModel.PullRule pullRule : getControlModel().getPullRules()) {
      if (pullRule.getSourceGetFeature().getFeatureMethod() != null && pullRule.getSourceGetFeature().getFeatureClass().isInstance(sourceNode) && pullRule.getTargetPutFeature().getFeatureMethod() != null && pullRule.getTargetPutFeature().getFeatureClass().isInstance(targetNode) && sourcePatternDictionary.isMarkedUp(pullRule.getSourceMarkup(),pullRule.getSourceParentMarkup(),sourceNode) && targetPatternDictionary.isMarkedUp(pullRule.getTargetMarkup(),pullRule.getTargetParentMarkup(),targetNode)) {
        if (pullRule.getEqualityFeature() != null) {
          Method equalityFeatureMethod=pullRule.getEqualityFeature().getFeatureMethod();
          Object value1=equalityFeatureMethod.invoke(sourceNode,NO_ARGUMENTS);
          Object value2=equalityFeatureMethod.invoke(targetNode,NO_ARGUMENTS);
          if (value1 == null ? value2 != null : !value1.equals(value2)) {
            continue;
          }
        }
        Method sourceGetMethod=pullRule.getSourceGetFeature().getFeatureMethod();
        Object value=sourceGetMethod.invoke(sourceNode,NO_ARGUMENTS);
        Method targetPutMethod=pullRule.getTargetPutFeature().getFeatureMethod();
        if (!sourceGetMethod.getReturnType().isArray() || targetPutMethod.getParameterTypes()[0].isAssignableFrom(sourceGetMethod.getReturnType())) {
          if (value instanceof String) {
            String stringValue=(String)value;
            stringValue=getControlModel().getFacadeHelper().applyFormatRules(stringValue);
            Pattern sourceTransfer=pullRule.getSourceTransfer();
            if (sourceTransfer != null) {
              String oldStringValue=(String)sourceGetMethod.invoke(targetNode,NO_ARGUMENTS);
              if (oldStringValue != null) {
                Matcher sourceMatcher=sourceTransfer.matcher(stringValue);
                Matcher targetMatcher=sourceTransfer.matcher(oldStringValue);
                if (sourceMatcher.groupCount() >= 1 && targetMatcher.groupCount() >= 1) {
                  StringBuilder result=new StringBuilder();
                  int index=0;
                  int sourceStart=0;
                  int targetStart=0;
                  if (sourceTransfer.pattern().startsWith(""String_Node_Str"")) {
                    sourceStart=getStartIndex(stringValue);
                    targetStart=getStartIndex(oldStringValue);
                  }
                  for (boolean match=sourceMatcher.find(sourceStart) && targetMatcher.find(targetStart); match; match=sourceMatcher.find() && targetMatcher.find()) {
                    result.append(stringValue.substring(index,sourceMatcher.start(1)));
                    result.append(targetMatcher.group(1));
                    index=sourceMatcher.end(1);
                  }
                  if (result.length() == 0) {
                    stringValue=null;
                  }
 else {
                    result.append(stringValue.substring(index));
                    stringValue=result.toString();
                  }
                }
 else {
                  stringValue=null;
                }
              }
            }
            value=stringValue;
          }
          if (value != null || targetPutMethod.getName().equals(""String_Node_Str"") || targetPutMethod.getName().equals(""String_Node_Str"") || targetPutMethod.getName().equals(""String_Node_Str"")) {
            Object oldValue=sourceGetMethod.invoke(targetNode,NO_ARGUMENTS);
            if (value == null ? oldValue == null : value.equals(oldValue)) {
              continue;
            }
 else             if (value instanceof Object[] && oldValue instanceof Object[] && Arrays.equals((Object[])value,(Object[])oldValue)) {
              continue;
            }
 else             if (targetPutMethod.getName().equals(""String_Node_Str"")) {
              if (oldValue != null && value != null && ((String)oldValue).trim().equals(((String)value).trim())) {
                continue;
              }
            }
            if (sourceGetMethod.getName().equals(""String_Node_Str"") && getControlModel().getBlockPattern() != null && ((JMethod)targetNode).getComment() != null && getControlModel().getBlockPattern().matcher(((JMethod)targetNode).getComment()).find()) {
              continue;
            }
            targetPutMethod.invoke(targetNode,new Object[]{value});
            targetCompilationChanged=true;
            if (targetPutMethod.getName().equals(""String_Node_Str"") && sourceNode instanceof JMethod) {
              JMethod sourceMethod=(JMethod)sourceNode;
              JMethod targetMethod=(JMethod)targetNode;
              String[] sourceParameterNames=sourceMethod.getParameterNames();
              targetMethod.setParameterNames(sourceParameterNames);
            }
          }
        }
 else {
          ArrayList<String> additionalStrings=new ArrayList<String>();
          String[] sourceStrings=(String[])value;
          if (sourceStrings != null) {
            additionalStrings.addAll(Arrays.asList(sourceStrings));
          }
          if (targetPutMethod.getName().equals(""String_Node_Str"")) {
            Pattern sourceTransfer=pullRule.getSourceTransfer();
            String comment=((JMember)targetNode).getComment();
            if (sourceTransfer != null && comment != null) {
              Matcher matcher=sourceTransfer.matcher(comment);
              while (matcher.find() && matcher.groupCount() >= 1) {
                String clientStrings=comment.substring(matcher.start(matcher.groupCount()),matcher.end(matcher.groupCount()));
                for (StringTokenizer stringTokenizer=new StringTokenizer(clientStrings,""String_Node_Str""); stringTokenizer.hasMoreTokens(); ) {
                  String token=stringTokenizer.nextToken();
                  if (!additionalStrings.contains(token)) {
                    additionalStrings.add(token);
                  }
                }
              }
            }
            String[] oldSuperInterfaces=(String[])sourceGetMethod.invoke(targetNode);
            String[] superInterfaces=additionalStrings.toArray(new String[additionalStrings.size()]);
            if (oldSuperInterfaces == null ? superInterfaces.length != 0 : !Arrays.equals(oldSuperInterfaces,superInterfaces)) {
              Method putMethod=targetNode.getClass().getMethod(""String_Node_Str"",String[].class);
              putMethod.invoke(targetNode,new Object[]{superInterfaces});
              targetCompilationChanged=true;
            }
          }
 else {
            String[] oldStringValues=(String[])sourceGetMethod.invoke(targetNode,NO_ARGUMENTS);
            List<String> old=oldStringValues == null ? Collections.<String>emptyList() : Arrays.<String>asList(oldStringValues);
            for (            String string : additionalStrings) {
              if (!old.contains(string)) {
                targetPutMethod.invoke(targetNode,new Object[]{string});
                targetCompilationChanged=true;
              }
            }
          }
        }
      }
    }
  }
 catch (  InvocationTargetException exception) {
    if (DEBUG) {
      exception.printStackTrace();
    }
  }
catch (  IllegalAccessException exception) {
    if (DEBUG) {
      exception.printStackTrace();
    }
  }
catch (  SecurityException e) {
    if (DEBUG) {
      e.printStackTrace();
    }
  }
catch (  NoSuchMethodException e) {
    if (DEBUG) {
      e.printStackTrace();
    }
  }
}",0.9985409205464916
11895,"/** 
 * Walks the type either as an EClass or an ENum to analyze either the methods or the fields.
 */
protected void analyzeType(JType type){
  String modelAnnotation=getModelAnnotation(type.getComment());
  boolean isEClassifier=false;
  String kind=null;
  if (modelAnnotation != null) {
    kind=getModelAnnotationAttribute(modelAnnotation,""String_Node_Str"");
    isEClassifier=!""String_Node_Str"".equals(kind);
  }
  if (isEClassifier) {
    EPackage ePackage=getEPackage(type);
    if ((type.getFlags() & Flags.AccInterface) != 0 || ""String_Node_Str"".equals(kind)) {
      EClass eClass=EcoreFactory.eINSTANCE.createEClass();
      eModelElementToJNodeMap.put(eClass,type);
      eClass.setName(type.getName());
      ePackage.getEClassifiers().add(eClass);
      eClass.getEAnnotations().addAll(extractEAnnotations(modelAnnotation));
      EcoreUtil.setDocumentation(eClass,getModelDocumentation(type.getComment()));
      String[] superInterfaces=type.getSuperInterfaces();
      String extend=getExtendsAnnotation(type.getComment());
      if (extend != null && superInterfaces != null) {
        List<String> superInterfaceList=new ArrayList<String>(Arrays.asList(superInterfaces));
        for (StringTokenizer stringTokenizer=new StringTokenizer(extend,""String_Node_Str""); stringTokenizer.hasMoreTokens(); ) {
          superInterfaceList.remove(stringTokenizer.nextToken());
        }
        superInterfaces=new String[superInterfaceList.size()];
        superInterfaceList.toArray(superInterfaces);
      }
      eClassToSuperTypeNamesMap.put(eClass,superInterfaces);
      String isAbstract=getModelAnnotationAttribute(modelAnnotation,""String_Node_Str"");
      eClass.setAbstract(""String_Node_Str"".equals(isAbstract));
      String isInterface=getModelAnnotationAttribute(modelAnnotation,""String_Node_Str"");
      eClass.setInterface(""String_Node_Str"".equals(isInterface));
      for (      JMethod method : facadeHelper.getChildren(type,JMethod.class)) {
        analyzeMethod(eClass,method);
      }
      String features=getModelAnnotationAttribute(modelAnnotation,""String_Node_Str"");
      if (features != null) {
        for (StringTokenizer stringTokenizer=new StringTokenizer(features,""String_Node_Str""); stringTokenizer.hasMoreTokens(); ) {
          String feature=stringTokenizer.nextToken();
          if (eClass.getEStructuralFeature(feature) == null) {
            analyzeMethod(eClass,getFilteredModelAnnotations(modelAnnotation,feature),""String_Node_Str"" + Character.toUpperCase(feature.charAt(0)) + feature.substring(1),""String_Node_Str"",null,null,null);
          }
 else {
            warning(CodeGenEcorePlugin.INSTANCE.getString(""String_Node_Str"",new Object[]{feature,eClass.getName()}));
          }
        }
      }
    }
 else {
      EEnum eEnum=EcoreFactory.eINSTANCE.createEEnum();
      eModelElementToJNodeMap.put(eEnum,type);
      eEnum.setName(type.getName());
      ePackage.getEClassifiers().add(eEnum);
      eEnum.getEAnnotations().addAll(extractEAnnotations(modelAnnotation));
      EcoreUtil.setDocumentation(eEnum,getModelDocumentation(type.getComment()));
      for (      JField field : facadeHelper.getChildren(type,JField.class)) {
        analyzeEnumLiteral(eEnum,field);
      }
    }
  }
 else {
    JPackage jPackage=facadeHelper.getPackage(type);
    String qualifiedPackageName=jPackage != null ? jPackage.getQualifiedName() : null;
    String typeName=type.getName();
    boolean isEPackage=false;
    if (typeName.endsWith(""String_Node_Str"") && typeName.length() > 7) {
      String packagePrefix=typeName.substring(0,typeName.length() - 7);
      if (""String_Node_Str"".equals(kind)) {
        isEPackage=true;
      }
      int index=qualifiedPackageName == null ? -1 : qualifiedPackageName.lastIndexOf(""String_Node_Str"");
      @SuppressWarnings(""String_Node_Str"") String name=index == -1 ? qualifiedPackageName : qualifiedPackageName.substring(index + 1);
      String nsURI=""String_Node_Str"" + (qualifiedPackageName == null ? ""String_Node_Str"" : qualifiedPackageName.replace('.','/')) + ""String_Node_Str"";
      String nsPrefix=qualifiedPackageName == null ? ""String_Node_Str"" : qualifiedPackageName;
      List<EClass> eClasses=new ArrayList<EClass>();
      List<EDataType> eDataTypes=new ArrayList<EDataType>();
      Map<Object,Integer> ordering=new HashMap<Object,Integer>();
      for (      JNode node : type.getChildren()) {
        if (node instanceof JField) {
          JField field=(JField)node;
          String fieldName=field.getName();
          String fieldType=field.getType();
          if (""String_Node_Str"".equals(fieldName)) {
            isEPackage=true;
            name=field.getInitializer();
            name=name.substring(1,name.length() - 1);
          }
 else           if (""String_Node_Str"".equals(fieldName)) {
            isEPackage=true;
            nsURI=field.getInitializer();
            nsURI=nsURI.substring(1,nsURI.length() - 1);
          }
 else           if (""String_Node_Str"".equals(fieldName)) {
            isEPackage=true;
            nsPrefix=field.getInitializer();
            nsPrefix=nsPrefix.substring(1,nsPrefix.length() - 1);
          }
 else           if (""String_Node_Str"".equals(fieldType) && !fieldName.endsWith(""String_Node_Str"")) {
            try {
              String initializer=field.getInitializer();
              int plusIndex=initializer.lastIndexOf(""String_Node_Str"");
              if (plusIndex != -1) {
                initializer=initializer.substring(plusIndex + 1);
              }
              initializer=initializer.trim();
              int value=Integer.parseInt(initializer);
              ordering.put(fieldName,value);
            }
 catch (            NumberFormatException exception) {
            }
          }
        }
 else         if (node instanceof JMethod) {
          JMethod method=(JMethod)node;
          String methodAnnotation=getModelAnnotation(method.getComment());
          if (methodAnnotation != null) {
            String returnType=method.getReturnType();
            if (returnType != null) {
              if (returnType.endsWith(""String_Node_Str"")) {
                EDataType eDataType=EcoreFactory.eINSTANCE.createEDataType();
                eDataType.setInstanceClassName(getModelAnnotationAttribute(methodAnnotation,""String_Node_Str""));
                eDataType.setName(method.getName().substring(3));
                String isSerializable=getModelAnnotationAttribute(methodAnnotation,""String_Node_Str"");
                if (""String_Node_Str"".equals(isSerializable)) {
                  eDataType.setSerializable(false);
                }
                eDataTypes.add(eDataType);
                eDataType.getEAnnotations().addAll(extractEAnnotations(methodAnnotation));
                EcoreUtil.setDocumentation(eDataType,getModelDocumentation(method.getComment()));
              }
 else               if (returnType.endsWith(""String_Node_Str"")) {
                EClass eClass=EcoreFactory.eINSTANCE.createEClass();
                String instanceClass=getModelAnnotationAttribute(methodAnnotation,""String_Node_Str"");
                if (instanceClass != null) {
                  eClass.setInterface(true);
                  eClass.setAbstract(true);
                  eClass.setInstanceClassName(instanceClass);
                  eClass.setName(method.getName().substring(3));
                  eClasses.add(eClass);
                }
 else {
                  eClass.setInstanceClassName(""String_Node_Str"");
                  eClass.setName(method.getName().substring(3));
                  eClasses.add(eClass);
                  String features=getModelAnnotationAttribute(methodAnnotation,""String_Node_Str"");
                  if (features != null) {
                    for (StringTokenizer stringTokenizer=new StringTokenizer(features,""String_Node_Str""); stringTokenizer.hasMoreTokens(); ) {
                      String feature=stringTokenizer.nextToken();
                      analyzeMethod(eClass,getFilteredModelAnnotations(methodAnnotation,feature),""String_Node_Str"" + Character.toUpperCase(feature.charAt(0)) + feature.substring(1),""String_Node_Str"",null,null,null);
                    }
                  }
 else {
                    analyzeMethod(eClass,getFilteredModelAnnotations(methodAnnotation,""String_Node_Str""),""String_Node_Str"",""String_Node_Str"",null,null,null);
                    analyzeMethod(eClass,getFilteredModelAnnotations(methodAnnotation,""String_Node_Str""),""String_Node_Str"",""String_Node_Str"",null,null,null);
                  }
                }
                eClass.getEAnnotations().addAll(extractEAnnotations(methodAnnotation));
                EcoreUtil.setDocumentation(eClass,getModelDocumentation(method.getComment()));
              }
            }
          }
        }
      }
      if (isEPackage || !eClasses.isEmpty() || !eDataTypes.isEmpty()) {
        EPackage ePackage=EcoreFactory.eINSTANCE.createEPackage();
        ePackageToOrderingMap.put(ePackage,ordering);
        eModelElementToJNodeMap.put(ePackage,type);
        ePackage.setNsURI(nsURI);
        ePackage.setNsPrefix(nsPrefix);
        ePackage.setName(name);
        ePackage.getEClassifiers().addAll(eClasses);
        ePackage.getEClassifiers().addAll(eDataTypes);
        if (modelAnnotation != null) {
          ePackage.getEAnnotations().addAll(extractEAnnotations(modelAnnotation));
        }
        EcoreUtil.setDocumentation(ePackage,getModelDocumentation(type.getComment()));
        ePackageToPrefixMap.put(ePackage,packagePrefix);
        EPackage existingEPackage=packageNameToEPackageMap.get(qualifiedPackageName);
        if (existingEPackage != null) {
          ePackage.getEClassifiers().addAll(existingEPackage.getEClassifiers());
        }
        packageNameToEPackageMap.put(qualifiedPackageName,ePackage);
      }
    }
  }
}","/** 
 * Walks the type either as an EClass or an ENum to analyze either the methods or the fields.
 */
protected void analyzeType(JType type){
  String modelAnnotation=getModelAnnotation(type.getComment());
  boolean isEClassifier=false;
  String kind=null;
  if (modelAnnotation != null) {
    kind=getModelAnnotationAttribute(modelAnnotation,""String_Node_Str"");
    isEClassifier=!""String_Node_Str"".equals(kind);
  }
  if (isEClassifier) {
    EPackage ePackage=getEPackage(type);
    if ((type.getFlags() & Flags.AccInterface) != 0 || ""String_Node_Str"".equals(kind)) {
      EClass eClass=EcoreFactory.eINSTANCE.createEClass();
      eModelElementToJNodeMap.put(eClass,type);
      eClass.setName(type.getName());
      ePackage.getEClassifiers().add(eClass);
      eClass.getEAnnotations().addAll(extractEAnnotations(modelAnnotation));
      EcoreUtil.setDocumentation(eClass,getModelDocumentation(type.getComment()));
      String[] superInterfaces=type.getSuperInterfaces();
      String extend=getExtendsAnnotation(type.getComment());
      if (extend != null && superInterfaces != null) {
        List<String> superInterfaceList=new ArrayList<String>(Arrays.asList(superInterfaces));
        for (StringTokenizer stringTokenizer=new StringTokenizer(extend,""String_Node_Str""); stringTokenizer.hasMoreTokens(); ) {
          superInterfaceList.remove(stringTokenizer.nextToken());
        }
        superInterfaces=new String[superInterfaceList.size()];
        superInterfaceList.toArray(superInterfaces);
      }
      eClassToSuperTypeNamesMap.put(eClass,superInterfaces);
      String isInterface=getModelAnnotationAttribute(modelAnnotation,""String_Node_Str"");
      eClass.setInterface(""String_Node_Str"".equals(isInterface));
      String isAbstract=getModelAnnotationAttribute(modelAnnotation,""String_Node_Str"");
      eClass.setAbstract(""String_Node_Str"".equals(isAbstract) || isAbstract == null && eClass.isInterface());
      for (      JMethod method : facadeHelper.getChildren(type,JMethod.class)) {
        analyzeMethod(eClass,method);
      }
      String features=getModelAnnotationAttribute(modelAnnotation,""String_Node_Str"");
      if (features != null) {
        for (StringTokenizer stringTokenizer=new StringTokenizer(features,""String_Node_Str""); stringTokenizer.hasMoreTokens(); ) {
          String feature=stringTokenizer.nextToken();
          if (eClass.getEStructuralFeature(feature) == null) {
            analyzeMethod(eClass,getFilteredModelAnnotations(modelAnnotation,feature),""String_Node_Str"" + Character.toUpperCase(feature.charAt(0)) + feature.substring(1),""String_Node_Str"",EMPTY_STRING_ARRAY,EMPTY_STRING_ARRAY,EMPTY_STRING_ARRAY);
          }
 else {
            warning(CodeGenEcorePlugin.INSTANCE.getString(""String_Node_Str"",new Object[]{feature,eClass.getName()}));
          }
        }
      }
    }
 else {
      EEnum eEnum=EcoreFactory.eINSTANCE.createEEnum();
      eModelElementToJNodeMap.put(eEnum,type);
      eEnum.setName(type.getName());
      ePackage.getEClassifiers().add(eEnum);
      eEnum.getEAnnotations().addAll(extractEAnnotations(modelAnnotation));
      EcoreUtil.setDocumentation(eEnum,getModelDocumentation(type.getComment()));
      for (      JField field : facadeHelper.getChildren(type,JField.class)) {
        analyzeEnumLiteral(eEnum,field);
      }
    }
  }
 else {
    JPackage jPackage=facadeHelper.getPackage(type);
    String qualifiedPackageName=jPackage != null ? jPackage.getQualifiedName() : null;
    String typeName=type.getName();
    boolean isEPackage=false;
    if (typeName.endsWith(""String_Node_Str"") && typeName.length() > 7) {
      String packagePrefix=typeName.substring(0,typeName.length() - 7);
      if (""String_Node_Str"".equals(kind)) {
        isEPackage=true;
      }
      int index=qualifiedPackageName == null ? -1 : qualifiedPackageName.lastIndexOf(""String_Node_Str"");
      @SuppressWarnings(""String_Node_Str"") String name=index == -1 ? qualifiedPackageName : qualifiedPackageName.substring(index + 1);
      String nsURI=""String_Node_Str"" + (qualifiedPackageName == null ? ""String_Node_Str"" : qualifiedPackageName.replace('.','/')) + ""String_Node_Str"";
      String nsPrefix=qualifiedPackageName == null ? ""String_Node_Str"" : qualifiedPackageName;
      List<EClass> eClasses=new ArrayList<EClass>();
      List<EDataType> eDataTypes=new ArrayList<EDataType>();
      Map<Object,Integer> ordering=new HashMap<Object,Integer>();
      for (      JNode node : type.getChildren()) {
        if (node instanceof JField) {
          JField field=(JField)node;
          String fieldName=field.getName();
          String fieldType=field.getType();
          if (""String_Node_Str"".equals(fieldName)) {
            isEPackage=true;
            name=field.getInitializer();
            name=name.substring(1,name.length() - 1);
          }
 else           if (""String_Node_Str"".equals(fieldName)) {
            isEPackage=true;
            nsURI=field.getInitializer();
            nsURI=nsURI.substring(1,nsURI.length() - 1);
          }
 else           if (""String_Node_Str"".equals(fieldName)) {
            isEPackage=true;
            nsPrefix=field.getInitializer();
            nsPrefix=nsPrefix.substring(1,nsPrefix.length() - 1);
          }
 else           if (""String_Node_Str"".equals(fieldType) && !fieldName.endsWith(""String_Node_Str"")) {
            try {
              String initializer=field.getInitializer();
              int plusIndex=initializer.lastIndexOf(""String_Node_Str"");
              if (plusIndex != -1) {
                initializer=initializer.substring(plusIndex + 1);
              }
              initializer=initializer.trim();
              int value=Integer.parseInt(initializer);
              ordering.put(fieldName,value);
            }
 catch (            NumberFormatException exception) {
            }
          }
        }
 else         if (node instanceof JMethod) {
          JMethod method=(JMethod)node;
          String methodAnnotation=getModelAnnotation(method.getComment());
          if (methodAnnotation != null) {
            String returnType=method.getReturnType();
            if (returnType != null) {
              if (returnType.endsWith(""String_Node_Str"")) {
                EDataType eDataType=EcoreFactory.eINSTANCE.createEDataType();
                eDataType.setInstanceClassName(getModelAnnotationAttribute(methodAnnotation,""String_Node_Str""));
                eDataType.setName(method.getName().substring(3));
                String isSerializable=getModelAnnotationAttribute(methodAnnotation,""String_Node_Str"");
                if (""String_Node_Str"".equals(isSerializable)) {
                  eDataType.setSerializable(false);
                }
                eDataTypes.add(eDataType);
                eDataType.getEAnnotations().addAll(extractEAnnotations(methodAnnotation));
                EcoreUtil.setDocumentation(eDataType,getModelDocumentation(method.getComment()));
              }
 else               if (returnType.endsWith(""String_Node_Str"")) {
                EClass eClass=EcoreFactory.eINSTANCE.createEClass();
                String instanceClass=getModelAnnotationAttribute(methodAnnotation,""String_Node_Str"");
                if (instanceClass != null) {
                  eClass.setInterface(true);
                  eClass.setAbstract(true);
                  eClass.setInstanceClassName(instanceClass);
                  eClass.setName(method.getName().substring(3));
                  eClasses.add(eClass);
                }
 else {
                  eClass.setInstanceClassName(""String_Node_Str"");
                  eClass.setName(method.getName().substring(3));
                  eClasses.add(eClass);
                  String features=getModelAnnotationAttribute(methodAnnotation,""String_Node_Str"");
                  if (features != null) {
                    for (StringTokenizer stringTokenizer=new StringTokenizer(features,""String_Node_Str""); stringTokenizer.hasMoreTokens(); ) {
                      String feature=stringTokenizer.nextToken();
                      analyzeMethod(eClass,getFilteredModelAnnotations(methodAnnotation,feature),""String_Node_Str"" + Character.toUpperCase(feature.charAt(0)) + feature.substring(1),""String_Node_Str"",EMPTY_STRING_ARRAY,EMPTY_STRING_ARRAY,EMPTY_STRING_ARRAY);
                    }
                  }
 else {
                    analyzeMethod(eClass,getFilteredModelAnnotations(methodAnnotation,""String_Node_Str""),""String_Node_Str"",""String_Node_Str"",EMPTY_STRING_ARRAY,EMPTY_STRING_ARRAY,EMPTY_STRING_ARRAY);
                    analyzeMethod(eClass,getFilteredModelAnnotations(methodAnnotation,""String_Node_Str""),""String_Node_Str"",""String_Node_Str"",EMPTY_STRING_ARRAY,EMPTY_STRING_ARRAY,EMPTY_STRING_ARRAY);
                  }
                }
                eClass.getEAnnotations().addAll(extractEAnnotations(methodAnnotation));
                EcoreUtil.setDocumentation(eClass,getModelDocumentation(method.getComment()));
              }
            }
          }
        }
      }
      if (isEPackage || !eClasses.isEmpty() || !eDataTypes.isEmpty()) {
        EPackage ePackage=EcoreFactory.eINSTANCE.createEPackage();
        ePackageToOrderingMap.put(ePackage,ordering);
        eModelElementToJNodeMap.put(ePackage,type);
        ePackage.setNsURI(nsURI);
        ePackage.setNsPrefix(nsPrefix);
        ePackage.setName(name);
        ePackage.getEClassifiers().addAll(eClasses);
        ePackage.getEClassifiers().addAll(eDataTypes);
        if (modelAnnotation != null) {
          ePackage.getEAnnotations().addAll(extractEAnnotations(modelAnnotation));
        }
        EcoreUtil.setDocumentation(ePackage,getModelDocumentation(type.getComment()));
        ePackageToPrefixMap.put(ePackage,packagePrefix);
        EPackage existingEPackage=packageNameToEPackageMap.get(qualifiedPackageName);
        if (existingEPackage != null) {
          ePackage.getEClassifiers().addAll(existingEPackage.getEClassifiers());
        }
        packageNameToEPackageMap.put(qualifiedPackageName,ePackage);
      }
    }
  }
}",0.9736314417485462
11896,"public void validate(){
  Resource mainResource=editingDomain.getResourceSet().getResources().get(0);
  GenModel genModel=(GenModel)mainResource.getContents().get(0);
  genModel.setValidateModel(true);
  Diagnostic diagnostic=genModel.diagnose();
  if (diagnostic.getSeverity() != Diagnostic.OK) {
    Diagnostic mapDiagnostic=resourceToDiagnosticMap.get(mainResource);
    if (mapDiagnostic != null) {
      ((DiagnosticChain)diagnostic).add(mapDiagnostic);
    }
    resourceToDiagnosticMap.put(mainResource,diagnostic);
  }
}","public void validate(){
  Resource mainResource=editingDomain.getResourceSet().getResources().get(0);
  GenModel genModel=(GenModel)mainResource.getContents().get(0);
  genModel.setValidateModel(true);
  Diagnostic diagnostic=genModel.diagnose();
  if (diagnostic.getSeverity() != Diagnostic.OK) {
    markerHelper=new ValidateAction.EclipseResourcesUtil();
    Diagnostic mapDiagnostic=resourceToDiagnosticMap.get(mainResource);
    if (mapDiagnostic != null) {
      ((DiagnosticChain)diagnostic).add(mapDiagnostic);
    }
    resourceToDiagnosticMap.put(mainResource,diagnostic);
  }
}",0.946236559139785
11897,"/** 
 * <!-- begin-user-doc --> <!-- end-user-doc -->
 * @generated
 */
public void gotoMarker(IMarker marker){
  try {
    if (marker.getType().equals(EValidator.MARKER)) {
      String uriAttribute=marker.getAttribute(EValidator.URI_ATTRIBUTE,null);
      if (uriAttribute != null) {
        URI uri=URI.createURI(uriAttribute);
        EObject eObject=editingDomain.getResourceSet().getEObject(uri,true);
        if (eObject != null) {
          setSelectionToViewer(Collections.singleton(editingDomain.getWrapper(eObject)));
        }
      }
    }
  }
 catch (  CoreException exception) {
    GenModelEditPlugin.INSTANCE.log(exception);
  }
}","/** 
 * <!-- begin-user-doc --> <!-- end-user-doc -->
 * @generated NOT
 */
public void gotoMarker(IMarker marker){
  try {
    if (marker.exists() && marker.getType().equals(EValidator.MARKER)) {
      String uriAttribute=marker.getAttribute(EValidator.URI_ATTRIBUTE,null);
      if (uriAttribute != null) {
        URI uri=URI.createURI(uriAttribute);
        EObject eObject=editingDomain.getResourceSet().getEObject(uri,true);
        if (eObject != null) {
          setSelectionToViewer(Collections.singleton(editingDomain.getWrapper(eObject)));
        }
      }
    }
  }
 catch (  CoreException exception) {
    GenModelEditPlugin.INSTANCE.log(exception);
  }
}",0.982536066818527
11898,"/** 
 * <!-- begin-user-doc --> <!-- end-user-doc -->
 * @generated NOT
 */
protected EStructuralFeature getChildFeature(Object object,Object child){
  EOperation eOperation=(EOperation)object;
  if (child instanceof EObject) {
    EObject eObject=(EObject)child;
    if (eObject.eContainer() == eOperation) {
      return eObject.eContainingFeature();
    }
  }
  if (eOperation.getEGenericType() == null) {
    return EcorePackage.Literals.ETYPED_ELEMENT__EGENERIC_TYPE;
  }
 else {
    return EcorePackage.Literals.EOPERATION__EGENERIC_EXCEPTIONS;
  }
}","/** 
 * <!-- begin-user-doc --> <!-- end-user-doc -->
 * @generated NOT
 */
protected EStructuralFeature getChildFeature(Object object,Object child){
  EOperation eOperation=(EOperation)object;
  if (child instanceof EObject) {
    EObject eObject=(EObject)child;
    if (eObject.eContainer() == eOperation) {
      return eObject.eContainingFeature();
    }
  }
  if (child instanceof EGenericType) {
    if (eOperation.getEGenericType() == null) {
      return EcorePackage.Literals.ETYPED_ELEMENT__EGENERIC_TYPE;
    }
 else {
      return EcorePackage.Literals.EOPERATION__EGENERIC_EXCEPTIONS;
    }
  }
 else {
    return super.getChildFeature(object,child);
  }
}",0.9077551020408164
11899,"/** 
 * Adds each object from start to end of the array at each successive index in the list  and returns whether any objects were added; it does no ranging checking or uniqueness checking. This implementation delegates to   {@link #assign assign},   {@link #didAdd didAdd}, and   {@link #didChange didChange}. In addition to the normal effects,  this override implementation generates notifications as   {@link #isNotificationRequired required} and delegates to  {@link #inverseAdd inverseAdd} as {@link #hasInverse required}.
 * @param index the index at which to add.
 * @param objects the objects to be added.
 * @param start the index of first object to be added.
 * @param end the index past the last object to be added.
 * @return whether any objects were added.
 * @see #addAllUnique(int,Collection)
 * @see #isNotificationRequired
 * @see #hasInverse
 * @see #inverseAdd
 */
public boolean addAllUnique(int index,Object[] objects,int start,int end){
  int collectionSize=end - start;
  if (collectionSize == 0) {
    return false;
  }
 else {
    if (isNotificationRequired()) {
      boolean oldIsSet=isSet();
      doAddAllUnique(index,objects,start,end);
      NotificationImpl notification;
      if (collectionSize == 0) {
        notification=createNotification(Notification.ADD,null,objects[0],index,oldIsSet);
      }
 else {
        if (start != 0 || end != objects.length) {
          Object[] actualObjects=new Object[collectionSize];
          for (int i=0, j=start; j < end; ++i, ++j) {
            actualObjects[i]=objects[j];
          }
          notification=createNotification(Notification.ADD_MANY,null,actualObjects,index,oldIsSet);
        }
 else {
          notification=createNotification(Notification.ADD_MANY,null,objects,index,oldIsSet);
        }
      }
      if (hasInverse()) {
        NotificationChain notifications=createNotificationChain(collectionSize);
        int lastIndex=index + collectionSize;
        for (int i=index; i < lastIndex; ++i) {
          Object value=delegateGet(i);
          notifications=inverseAdd(value,notifications);
          notifications=shadowAdd(value,notifications);
        }
        if (notifications == null) {
          dispatchNotification(notification);
        }
 else {
          notifications.add(notification);
          notifications.dispatch();
        }
      }
 else {
        dispatchNotification(notification);
      }
    }
 else {
      doAddAllUnique(index,objects,start,end);
      if (hasInverse()) {
        NotificationChain notifications=createNotificationChain(collectionSize);
        int lastIndex=index + collectionSize;
        for (int i=index; i < lastIndex; ++i) {
          notifications=inverseAdd(delegateGet(i),notifications);
        }
        if (notifications != null)         notifications.dispatch();
      }
    }
    return true;
  }
}","/** 
 * Adds each object from start to end of the array at each successive index in the list  and returns whether any objects were added; it does no ranging checking or uniqueness checking. This implementation delegates to   {@link #assign assign},   {@link #didAdd didAdd}, and   {@link #didChange didChange}. In addition to the normal effects,  this override implementation generates notifications as   {@link #isNotificationRequired required} and delegates to  {@link #inverseAdd inverseAdd} as {@link #hasInverse required}.
 * @param index the index at which to add.
 * @param objects the objects to be added.
 * @param start the index of first object to be added.
 * @param end the index past the last object to be added.
 * @return whether any objects were added.
 * @see #addAllUnique(int,Collection)
 * @see #isNotificationRequired
 * @see #hasInverse
 * @see #inverseAdd
 */
public boolean addAllUnique(int index,Object[] objects,int start,int end){
  int collectionSize=end - start;
  if (collectionSize == 0) {
    return false;
  }
 else {
    if (isNotificationRequired()) {
      boolean oldIsSet=isSet();
      doAddAllUnique(index,objects,start,end);
      NotificationImpl notification;
      if (collectionSize == 1) {
        notification=createNotification(Notification.ADD,null,objects[0],index,oldIsSet);
      }
 else {
        if (start != 0 || end != objects.length) {
          Object[] actualObjects=new Object[collectionSize];
          for (int i=0, j=start; j < end; ++i, ++j) {
            actualObjects[i]=objects[j];
          }
          notification=createNotification(Notification.ADD_MANY,null,Arrays.asList(actualObjects),index,oldIsSet);
        }
 else {
          notification=createNotification(Notification.ADD_MANY,null,Arrays.asList(objects),index,oldIsSet);
        }
      }
      if (hasInverse()) {
        NotificationChain notifications=createNotificationChain(collectionSize);
        int lastIndex=index + collectionSize;
        for (int i=index; i < lastIndex; ++i) {
          Object value=delegateGet(i);
          notifications=inverseAdd(value,notifications);
          notifications=shadowAdd(value,notifications);
        }
        if (notifications == null) {
          dispatchNotification(notification);
        }
 else {
          notifications.add(notification);
          notifications.dispatch();
        }
      }
 else {
        dispatchNotification(notification);
      }
    }
 else {
      doAddAllUnique(index,objects,start,end);
      if (hasInverse()) {
        NotificationChain notifications=createNotificationChain(collectionSize);
        int lastIndex=index + collectionSize;
        for (int i=index; i < lastIndex; ++i) {
          notifications=inverseAdd(delegateGet(i),notifications);
        }
        if (notifications != null)         notifications.dispatch();
      }
    }
    return true;
  }
}",0.9944270289097876
11900,"/** 
 * Adds each object from start to end of the array at each successive index in the list  and returns whether any objects were added; it does no ranging checking or uniqueness checking. This implementation delegates to   {@link #assign assign},   {@link #didAdd didAdd}, and   {@link #didChange didChange}. In addition to the normal effects,  this override implementation generates notifications as   {@link #isNotificationRequired required} and delegates to  {@link #inverseAdd inverseAdd} as {@link #hasInverse required}.
 * @param index the index at which to add.
 * @param objects the objects to be added.
 * @param start the index of first object to be added.
 * @param end the index past the last object to be added.
 * @return whether any objects were added.
 * @see #addAllUnique(int,Collection)
 * @see #isNotificationRequired
 * @see #hasInverse
 * @see #inverseAdd
 */
public boolean addAllUnique(int index,Object[] objects,int start,int end){
  int collectionSize=end - start;
  if (collectionSize == 0) {
    return false;
  }
 else {
    if (isNotificationRequired()) {
      boolean oldIsSet=isSet();
      doAddAllUnique(index,objects,start,end);
      NotificationImpl notification;
      if (collectionSize == 0) {
        notification=createNotification(Notification.ADD,null,objects[0],index,oldIsSet);
      }
 else {
        if (start != 0 || end != objects.length) {
          Object[] actualObjects=new Object[collectionSize];
          for (int i=0, j=start; j < end; ++i, ++j) {
            actualObjects[i]=objects[j];
          }
          notification=createNotification(Notification.ADD_MANY,null,actualObjects,index,oldIsSet);
        }
 else {
          notification=createNotification(Notification.ADD_MANY,null,objects,index,oldIsSet);
        }
      }
      if (hasInverse()) {
        NotificationChain notifications=createNotificationChain(collectionSize);
        int lastIndex=index + collectionSize;
        for (int i=index; i < lastIndex; ++i) {
          Object value=data[i];
          notifications=inverseAdd(value,notifications);
          notifications=shadowAdd(value,notifications);
        }
        if (notifications == null) {
          dispatchNotification(notification);
        }
 else {
          notifications.add(notification);
          notifications.dispatch();
        }
      }
 else {
        dispatchNotification(notification);
      }
    }
 else {
      doAddAllUnique(index,objects,start,end);
      if (hasInverse()) {
        NotificationChain notifications=createNotificationChain(collectionSize);
        int lastIndex=index + collectionSize;
        for (int i=index; i < lastIndex; ++i) {
          notifications=inverseAdd(data[i],notifications);
        }
        if (notifications != null)         notifications.dispatch();
      }
    }
    return true;
  }
}","/** 
 * Adds each object from start to end of the array at each successive index in the list  and returns whether any objects were added; it does no ranging checking or uniqueness checking. This implementation delegates to   {@link #assign assign},   {@link #didAdd didAdd}, and   {@link #didChange didChange}. In addition to the normal effects,  this override implementation generates notifications as   {@link #isNotificationRequired required} and delegates to  {@link #inverseAdd inverseAdd} as {@link #hasInverse required}.
 * @param index the index at which to add.
 * @param objects the objects to be added.
 * @param start the index of first object to be added.
 * @param end the index past the last object to be added.
 * @return whether any objects were added.
 * @see #addAllUnique(int,Collection)
 * @see #isNotificationRequired
 * @see #hasInverse
 * @see #inverseAdd
 */
public boolean addAllUnique(int index,Object[] objects,int start,int end){
  int collectionSize=end - start;
  if (collectionSize == 0) {
    return false;
  }
 else {
    if (isNotificationRequired()) {
      boolean oldIsSet=isSet();
      doAddAllUnique(index,objects,start,end);
      NotificationImpl notification;
      if (collectionSize == 1) {
        notification=createNotification(Notification.ADD,null,objects[0],index,oldIsSet);
      }
 else {
        if (start != 0 || end != objects.length) {
          Object[] actualObjects=new Object[collectionSize];
          for (int i=0, j=start; j < end; ++i, ++j) {
            actualObjects[i]=objects[j];
          }
          notification=createNotification(Notification.ADD_MANY,null,Arrays.asList(actualObjects),index,oldIsSet);
        }
 else {
          notification=createNotification(Notification.ADD_MANY,null,Arrays.asList(objects),index,oldIsSet);
        }
      }
      if (hasInverse()) {
        NotificationChain notifications=createNotificationChain(collectionSize);
        int lastIndex=index + collectionSize;
        for (int i=index; i < lastIndex; ++i) {
          Object value=data[i];
          notifications=inverseAdd(value,notifications);
          notifications=shadowAdd(value,notifications);
        }
        if (notifications == null) {
          dispatchNotification(notification);
        }
 else {
          notifications.add(notification);
          notifications.dispatch();
        }
      }
 else {
        dispatchNotification(notification);
      }
    }
 else {
      doAddAllUnique(index,objects,start,end);
      if (hasInverse()) {
        NotificationChain notifications=createNotificationChain(collectionSize);
        int lastIndex=index + collectionSize;
        for (int i=index; i < lastIndex; ++i) {
          notifications=inverseAdd(data[i],notifications);
        }
        if (notifications != null)         notifications.dispatch();
      }
    }
    return true;
  }
}",0.9943997199859992
11901,"protected void applyPullRules(IDOMNode sourceNode,IDOMNode targetNode){
  try {
    for (Iterator pullRules=jControlModel.getPullRules().iterator(); pullRules.hasNext(); ) {
      JControlModel.PullRule pullRule=(JControlModel.PullRule)pullRules.next();
      if (sourcePatternDictionary.isMarkedUp(pullRule.getSourceMarkup(),sourceNode) && targetPatternDictionary.isMarkedUp(pullRule.getTargetMarkup(),targetNode) && pullRule.getSourceGetFeature().getFeatureClass().isInstance(sourceNode)&& pullRule.getTargetPutFeature().getFeatureClass().isInstance(targetNode)) {
        Method sourceGetMethod=pullRule.getSourceGetFeature().getFeatureMethod();
        Object value=sourceGetMethod.invoke(sourceNode,noArguments);
        Method targetPutMethod=pullRule.getTargetPutFeature().getFeatureMethod();
        if (!sourceGetMethod.getReturnType().isArray() || targetPutMethod.getParameterTypes()[0].isAssignableFrom(sourceGetMethod.getReturnType())) {
          if (value instanceof String) {
            String stringValue=(String)value;
            stringValue=applyFormatRules(stringValue);
            Pattern sourceTransfer=pullRule.getSourceTransfer();
            if (sourceTransfer != null) {
              String oldStringValue=(String)sourceGetMethod.invoke(targetNode,noArguments);
              Matcher sourceMatcher=sourceTransfer.matcher(stringValue);
              Matcher targetMatcher=sourceTransfer.matcher(oldStringValue);
              if (sourceMatcher.groupCount() >= 1 && targetMatcher.groupCount() >= 1) {
                StringBuffer result=new StringBuffer();
                int index=0;
                while (sourceMatcher.find() && targetMatcher.find()) {
                  result.append(stringValue.substring(index,sourceMatcher.start(1)));
                  result.append(targetMatcher.group(1));
                  index=sourceMatcher.end(1);
                }
                if (result.length() == 0) {
                  stringValue=null;
                }
 else {
                  result.append(stringValue.substring(index));
                  stringValue=result.toString();
                }
              }
 else {
                stringValue=null;
              }
            }
            value=stringValue;
          }
          if (value != null || targetPutMethod.getName().equals(""String_Node_Str"") || targetPutMethod.getName().equals(""String_Node_Str"") || targetPutMethod.getName().equals(""String_Node_Str"")) {
            Object oldValue=sourceGetMethod.invoke(targetNode,noArguments);
            if (value == null ? oldValue == null : value.equals(oldValue)) {
              continue;
            }
 else             if (targetPutMethod.getName().equals(""String_Node_Str"")) {
              if (oldValue != null && value != null && ((String)oldValue).trim().equals(((String)value).trim())) {
                continue;
              }
            }
            if (sourceGetMethod.getName().equals(""String_Node_Str"") && jControlModel.getBlockPattern() != null && ((IDOMMethod)targetNode).getComment() != null && jControlModel.getBlockPattern().matcher(((IDOMMethod)targetNode).getComment()).find()) {
              continue;
            }
            targetPutMethod.invoke(targetNode,new Object[]{value});
            if (targetPutMethod.getName().equals(""String_Node_Str"") && sourceNode instanceof IDOMMethod) {
              IDOMMethod sourceMethod=(IDOMMethod)sourceNode;
              IDOMMethod targetMethod=(IDOMMethod)targetNode;
              String[] sourceParameterNames=sourceMethod.getParameterNames();
              String[] targetParameterTypes=targetMethod.getParameterTypes();
              targetMethod.setParameters(targetParameterTypes,sourceParameterNames);
            }
          }
        }
 else {
          ArrayList additionalStrings=new ArrayList();
          String[] sourceStrings=(String[])value;
          if (sourceStrings != null) {
            additionalStrings.addAll(Arrays.asList(sourceStrings));
          }
          if (targetPutMethod.getName().equals(""String_Node_Str"")) {
            Pattern sourceTransfer=pullRule.getSourceTransfer();
            if (sourceTransfer != null) {
              String comment=((IDOMMember)targetNode).getComment();
              Matcher matcher=sourceTransfer.matcher(comment);
              while (matcher.find() && matcher.groupCount() >= 1) {
                String clientStrings=comment.substring(matcher.start(matcher.groupCount()),matcher.end(matcher.groupCount()));
                for (StringTokenizer stringTokenizer=new StringTokenizer(clientStrings,""String_Node_Str""); stringTokenizer.hasMoreTokens(); ) {
                  String token=stringTokenizer.nextToken();
                  if (!additionalStrings.contains(token)) {
                    additionalStrings.add(token);
                  }
                }
              }
            }
            IDOMType type=(IDOMType)targetNode;
            String[] superInterfaces=(String[])additionalStrings.toArray(new String[additionalStrings.size()]);
            if (type.getSuperInterfaces() == null ? superInterfaces.length != 0 : !Arrays.equals(type.getSuperInterfaces(),superInterfaces)) {
              type.setSuperInterfaces((String[])additionalStrings.toArray(new String[additionalStrings.size()]));
            }
          }
 else {
            String[] oldStringValues=(String[])sourceGetMethod.invoke(targetNode,noArguments);
            List old=oldStringValues == null ? Collections.EMPTY_LIST : Arrays.asList(oldStringValues);
            for (Iterator i=additionalStrings.iterator(); i.hasNext(); ) {
              String string=(String)i.next();
              if (!old.contains(string)) {
                targetPutMethod.invoke(targetNode,new Object[]{string});
              }
            }
          }
        }
      }
    }
  }
 catch (  InvocationTargetException exception) {
  }
catch (  IllegalAccessException exception) {
  }
}","protected void applyPullRules(IDOMNode sourceNode,IDOMNode targetNode){
  try {
    for (Iterator pullRules=jControlModel.getPullRules().iterator(); pullRules.hasNext(); ) {
      JControlModel.PullRule pullRule=(JControlModel.PullRule)pullRules.next();
      if (sourcePatternDictionary.isMarkedUp(pullRule.getSourceMarkup(),sourceNode) && targetPatternDictionary.isMarkedUp(pullRule.getTargetMarkup(),targetNode) && pullRule.getSourceGetFeature().getFeatureClass().isInstance(sourceNode)&& pullRule.getTargetPutFeature().getFeatureClass().isInstance(targetNode)) {
        Method sourceGetMethod=pullRule.getSourceGetFeature().getFeatureMethod();
        Object value=sourceGetMethod.invoke(sourceNode,noArguments);
        if (""String_Node_Str"".equals(sourceGetMethod.getName())) {
          System.out.println(""String_Node_Str"");
          System.out.println(value);
        }
        Method targetPutMethod=pullRule.getTargetPutFeature().getFeatureMethod();
        if (!sourceGetMethod.getReturnType().isArray() || targetPutMethod.getParameterTypes()[0].isAssignableFrom(sourceGetMethod.getReturnType())) {
          if (value instanceof String) {
            String stringValue=(String)value;
            stringValue=applyFormatRules(stringValue);
            Pattern sourceTransfer=pullRule.getSourceTransfer();
            if (sourceTransfer != null) {
              String oldStringValue=(String)sourceGetMethod.invoke(targetNode,noArguments);
              Matcher sourceMatcher=sourceTransfer.matcher(stringValue);
              Matcher targetMatcher=sourceTransfer.matcher(oldStringValue);
              if (sourceMatcher.groupCount() >= 1 && targetMatcher.groupCount() >= 1) {
                StringBuffer result=new StringBuffer();
                int index=0;
                while (sourceMatcher.find() && targetMatcher.find()) {
                  result.append(stringValue.substring(index,sourceMatcher.start(1)));
                  result.append(targetMatcher.group(1));
                  index=sourceMatcher.end(1);
                }
                if (result.length() == 0) {
                  stringValue=null;
                }
 else {
                  result.append(stringValue.substring(index));
                  stringValue=result.toString();
                }
              }
 else {
                stringValue=null;
              }
            }
            value=stringValue;
          }
          if (value != null || targetPutMethod.getName().equals(""String_Node_Str"") || targetPutMethod.getName().equals(""String_Node_Str"") || targetPutMethod.getName().equals(""String_Node_Str"")) {
            Object oldValue=sourceGetMethod.invoke(targetNode,noArguments);
            if (value == null ? oldValue == null : value.equals(oldValue)) {
              continue;
            }
 else             if (targetPutMethod.getName().equals(""String_Node_Str"")) {
              if (oldValue != null && value != null && ((String)oldValue).trim().equals(((String)value).trim())) {
                continue;
              }
            }
            if (sourceGetMethod.getName().equals(""String_Node_Str"") && jControlModel.getBlockPattern() != null && ((IDOMMethod)targetNode).getComment() != null && jControlModel.getBlockPattern().matcher(((IDOMMethod)targetNode).getComment()).find()) {
              continue;
            }
            targetPutMethod.invoke(targetNode,new Object[]{value});
            if (targetPutMethod.getName().equals(""String_Node_Str"") && sourceNode instanceof IDOMMethod) {
              IDOMMethod sourceMethod=(IDOMMethod)sourceNode;
              IDOMMethod targetMethod=(IDOMMethod)targetNode;
              String[] sourceParameterNames=sourceMethod.getParameterNames();
              String[] targetParameterTypes=targetMethod.getParameterTypes();
              targetMethod.setParameters(targetParameterTypes,sourceParameterNames);
            }
          }
        }
 else {
          ArrayList additionalStrings=new ArrayList();
          String[] sourceStrings=(String[])value;
          if (sourceStrings != null) {
            additionalStrings.addAll(Arrays.asList(sourceStrings));
          }
          if (targetPutMethod.getName().equals(""String_Node_Str"")) {
            Pattern sourceTransfer=pullRule.getSourceTransfer();
            if (sourceTransfer != null) {
              String comment=((IDOMMember)targetNode).getComment();
              Matcher matcher=sourceTransfer.matcher(comment);
              while (matcher.find() && matcher.groupCount() >= 1) {
                String clientStrings=comment.substring(matcher.start(matcher.groupCount()),matcher.end(matcher.groupCount()));
                for (StringTokenizer stringTokenizer=new StringTokenizer(clientStrings,""String_Node_Str""); stringTokenizer.hasMoreTokens(); ) {
                  String token=stringTokenizer.nextToken();
                  if (!additionalStrings.contains(token)) {
                    additionalStrings.add(token);
                  }
                }
              }
            }
            IDOMType type=(IDOMType)targetNode;
            String[] superInterfaces=(String[])additionalStrings.toArray(new String[additionalStrings.size()]);
            if (type.getSuperInterfaces() == null ? superInterfaces.length != 0 : !Arrays.equals(type.getSuperInterfaces(),superInterfaces)) {
              type.setSuperInterfaces((String[])additionalStrings.toArray(new String[additionalStrings.size()]));
            }
          }
 else {
            String[] oldStringValues=(String[])sourceGetMethod.invoke(targetNode,noArguments);
            List old=oldStringValues == null ? Collections.EMPTY_LIST : Arrays.asList(oldStringValues);
            for (Iterator i=additionalStrings.iterator(); i.hasNext(); ) {
              String string=(String)i.next();
              if (!old.contains(string)) {
                targetPutMethod.invoke(targetNode,new Object[]{string});
              }
            }
          }
        }
      }
    }
  }
 catch (  InvocationTargetException exception) {
  }
catch (  IllegalAccessException exception) {
  }
}",0.9864539183910912
11902,"protected void verifyMerge(String targetContents){
  StringBuffer mergeResult=new StringBuffer(targetContents);
  for (int i=mergeResult.length() - 1; i >= 0; i--) {
    if ('\r' == mergeResult.charAt(i)) {
      mergeResult.deleteCharAt(i);
    }
  }
  String expectedMerge=TestUtil.readFile(expected,false);
  String actualMerge=mergeResult.toString();
  if (expectedMerge == null ? actualMerge == null : expectedMerge.equals(actualMerge)) {
    System.out.println(""String_Node_Str"");
  }
 else {
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"" + expectedMerge);
    System.out.println(""String_Node_Str"" + actualMerge);
  }
  assertEquals(""String_Node_Str"",expectedMerge,actualMerge);
}","protected void verifyMerge(String targetContents){
  StringBuffer mergeResult=new StringBuffer(targetContents);
  for (int i=mergeResult.length() - 1; i >= 0; i--) {
    if ('\r' == mergeResult.charAt(i)) {
      mergeResult.deleteCharAt(i);
    }
  }
  String expectedMerge=TestUtil.readFile(expected,false);
  String actualMerge=mergeResult.toString();
  if (expectedMerge == null ? actualMerge == null : expectedMerge.equals(actualMerge)) {
    System.out.println(""String_Node_Str"" + getName());
  }
 else {
    System.out.println(""String_Node_Str"" + getName());
    System.out.println(""String_Node_Str"" + expectedMerge);
    System.out.println(""String_Node_Str"" + actualMerge);
  }
  assertEquals(""String_Node_Str"",expectedMerge,actualMerge);
}",0.9836956521739132
11903,"protected void addNamespaceDeclarations(){
  EPackage noNamespacePackage=helper.getNoNamespacePackage();
  EPackage[] packages=helper.packages();
  buffer.setLength(0);
  StringBuffer xsiSchemaLocation=buffer;
  String xsiNoNamespaceSchemaLocation=null;
  if (declareSchemaLocation) {
    Map handledBySchemaLocationMap=Collections.EMPTY_MAP;
    if (extendedMetaData != null) {
      Resource resource=helper.getResource();
      if (resource != null && resource.getContents().size() >= 1) {
        EObject root=getSchemaLocationRoot((EObject)resource.getContents().get(0));
        EClass eClass=root.eClass();
        EReference xsiSchemaLocationMapFeature=extendedMetaData.getXSISchemaLocationMapFeature(eClass);
        if (xsiSchemaLocationMapFeature != null) {
          EMap xsiSchemaLocationMap=(EMap)root.eGet(xsiSchemaLocationMapFeature);
          if (!xsiSchemaLocationMap.isEmpty()) {
            handledBySchemaLocationMap=xsiSchemaLocationMap.map();
            declareXSI=true;
            for (Iterator i=xsiSchemaLocationMap.entrySet().iterator(); i.hasNext(); ) {
              Map.Entry entry=(Map.Entry)i.next();
              String namespace=(String)entry.getKey();
              URI location=URI.createURI(entry.getValue().toString());
              if (namespace == null) {
                xsiNoNamespaceSchemaLocation=helper.deresolve(location).toString();
              }
 else {
                if (xsiSchemaLocation.length() > 0) {
                  xsiSchemaLocation.append(' ');
                }
                xsiSchemaLocation.append(namespace);
                xsiSchemaLocation.append(' ');
                xsiSchemaLocation.append(helper.deresolve(location).toString());
              }
            }
          }
        }
      }
    }
    for (int i=0; i < packages.length; i++) {
      EPackage ePackage=packages[i];
      String javaImplementationLocation=null;
      if (declareSchemaLocationImplementation) {
        try {
          Field field=ePackage.getClass().getField(""String_Node_Str"");
          javaImplementationLocation=""String_Node_Str"" + field.getDeclaringClass().getName();
        }
 catch (        Exception exception) {
        }
      }
      if (noNamespacePackage == ePackage) {
        if (ePackage.eResource() != null && !handledBySchemaLocationMap.containsKey(null)) {
          declareXSI=true;
          if (javaImplementationLocation != null) {
            xsiNoNamespaceSchemaLocation=javaImplementationLocation;
          }
 else {
            xsiNoNamespaceSchemaLocation=helper.getHREF(ePackage);
            if (xsiNoNamespaceSchemaLocation.endsWith(""String_Node_Str"")) {
              xsiNoNamespaceSchemaLocation=xsiNoNamespaceSchemaLocation.substring(0,xsiNoNamespaceSchemaLocation.length() - 2);
            }
          }
        }
      }
 else {
        Resource resource=ePackage.eResource();
        if (resource != null) {
          String nsURI=ePackage.getNsURI();
          if (!handledBySchemaLocationMap.containsKey(nsURI)) {
            URI uri=resource.getURI();
            if (javaImplementationLocation != null || (uri == null ? nsURI != null : !uri.toString().equals(nsURI))) {
              declareXSI=true;
              if (xsiSchemaLocation.length() > 0) {
                xsiSchemaLocation.append(' ');
              }
              xsiSchemaLocation.append(nsURI);
              xsiSchemaLocation.append(' ');
              String location=javaImplementationLocation == null ? helper.getHREF(ePackage) : javaImplementationLocation;
              if (location.endsWith(""String_Node_Str"")) {
                location=location.substring(0,location.length() - 2);
              }
              xsiSchemaLocation.append(location);
            }
          }
        }
      }
    }
  }
  if (declareXSI) {
    if (!toDOM) {
      doc.addAttribute(XSI_XMLNS,XMLResource.XSI_URI);
    }
 else {
      ((Element)currentNode).setAttributeNS(ExtendedMetaData.XMLNS_URI,XSI_XMLNS,XMLResource.XSI_URI);
    }
  }
  for (int i=0; i < packages.length; i++) {
    EPackage ePackage=packages[i];
    if (ePackage != noNamespacePackage && ePackage != XMLNamespacePackage.eINSTANCE && !ExtendedMetaData.XMLNS_URI.equals(ePackage.getNsURI())) {
      String nsURI=extendedMetaData == null ? ePackage.getNsURI() : extendedMetaData.getNamespace(ePackage);
      if (ePackage == xmlSchemaTypePackage) {
        nsURI=XMLResource.XML_SCHEMA_URI;
      }
      if (nsURI != null && !isDuplicateURI(nsURI)) {
        List nsPrefixes=helper.getPrefixes(ePackage);
        for (Iterator j=nsPrefixes.iterator(); j.hasNext(); ) {
          String nsPrefix=(String)j.next();
          if (!toDOM) {
            if (nsPrefix != null && nsPrefix.length() > 0) {
              doc.addAttributeNS(XMLResource.XML_NS,nsPrefix,nsURI);
            }
 else {
              doc.addAttribute(XMLResource.XML_NS,nsURI);
            }
          }
 else {
            if (nsPrefix != null && nsPrefix.length() > 0) {
              ((Element)currentNode).setAttributeNS(ExtendedMetaData.XMLNS_URI,XMLResource.XML_NS + ""String_Node_Str"" + nsPrefix,nsURI);
            }
 else {
              ((Element)currentNode).setAttributeNS(ExtendedMetaData.XMLNS_URI,XMLResource.XML_NS,nsURI);
            }
          }
        }
      }
    }
  }
  if (xsiSchemaLocation.length() > 0) {
    if (!toDOM) {
      doc.addAttribute(XSI_SCHEMA_LOCATION,xsiSchemaLocation.toString());
    }
 else {
      ((Element)currentNode).setAttributeNS(XMLResource.XSI_URI,XSI_SCHEMA_LOCATION,xsiSchemaLocation.toString());
    }
  }
  if (xsiNoNamespaceSchemaLocation != null) {
    if (!toDOM) {
      doc.addAttribute(XSI_NO_NAMESPACE_SCHEMA_LOCATION,xsiNoNamespaceSchemaLocation);
    }
 else {
      ((Element)currentNode).setAttributeNS(XMLResource.XSI_URI,XSI_NO_NAMESPACE_SCHEMA_LOCATION,xsiNoNamespaceSchemaLocation);
    }
  }
}","protected void addNamespaceDeclarations(){
  EPackage noNamespacePackage=helper.getNoNamespacePackage();
  EPackage[] packages=helper.packages();
  buffer.setLength(0);
  StringBuffer xsiSchemaLocation=buffer;
  String xsiNoNamespaceSchemaLocation=null;
  if (declareSchemaLocation) {
    Map handledBySchemaLocationMap=Collections.EMPTY_MAP;
    if (extendedMetaData != null) {
      Resource resource=helper.getResource();
      if (resource != null && resource.getContents().size() >= 1) {
        EObject root=getSchemaLocationRoot((EObject)resource.getContents().get(0));
        EClass eClass=root.eClass();
        EReference xsiSchemaLocationMapFeature=extendedMetaData.getXSISchemaLocationMapFeature(eClass);
        if (xsiSchemaLocationMapFeature != null) {
          EMap xsiSchemaLocationMap=(EMap)root.eGet(xsiSchemaLocationMapFeature);
          if (!xsiSchemaLocationMap.isEmpty()) {
            handledBySchemaLocationMap=xsiSchemaLocationMap.map();
            declareXSI=true;
            for (Iterator i=xsiSchemaLocationMap.entrySet().iterator(); i.hasNext(); ) {
              Map.Entry entry=(Map.Entry)i.next();
              String namespace=(String)entry.getKey();
              URI location=URI.createURI(entry.getValue().toString());
              if (namespace == null) {
                xsiNoNamespaceSchemaLocation=helper.deresolve(location).toString();
              }
 else {
                if (xsiSchemaLocation.length() > 0) {
                  xsiSchemaLocation.append(' ');
                }
                xsiSchemaLocation.append(namespace);
                xsiSchemaLocation.append(' ');
                xsiSchemaLocation.append(helper.deresolve(location).toString());
              }
            }
          }
        }
      }
    }
    for (int i=0; i < packages.length; i++) {
      EPackage ePackage=packages[i];
      String javaImplementationLocation=null;
      if (declareSchemaLocationImplementation) {
        try {
          Field field=ePackage.getClass().getField(""String_Node_Str"");
          javaImplementationLocation=""String_Node_Str"" + field.getDeclaringClass().getName();
        }
 catch (        Exception exception) {
        }
      }
      if (noNamespacePackage == ePackage) {
        if (ePackage.eResource() != null && !handledBySchemaLocationMap.containsKey(null)) {
          declareXSI=true;
          if (javaImplementationLocation != null) {
            xsiNoNamespaceSchemaLocation=javaImplementationLocation;
          }
 else {
            xsiNoNamespaceSchemaLocation=helper.getHREF(ePackage);
            if (xsiNoNamespaceSchemaLocation.endsWith(""String_Node_Str"")) {
              xsiNoNamespaceSchemaLocation=xsiNoNamespaceSchemaLocation.substring(0,xsiNoNamespaceSchemaLocation.length() - 2);
            }
          }
        }
      }
 else {
        Resource resource=ePackage.eResource();
        if (resource != null) {
          String nsURI=ePackage.getNsURI();
          if (!handledBySchemaLocationMap.containsKey(nsURI)) {
            URI uri=resource.getURI();
            if (javaImplementationLocation != null || (uri == null ? nsURI != null : !uri.toString().equals(nsURI))) {
              declareXSI=true;
              if (xsiSchemaLocation.length() > 0) {
                xsiSchemaLocation.append(' ');
              }
              xsiSchemaLocation.append(nsURI);
              xsiSchemaLocation.append(' ');
              String location=javaImplementationLocation == null ? helper.getHREF(ePackage) : javaImplementationLocation;
              if (location.endsWith(""String_Node_Str"")) {
                location=location.substring(0,location.length() - 2);
                if (uri.hasFragment()) {
                  location+=""String_Node_Str"" + uri.fragment();
                }
              }
              xsiSchemaLocation.append(location);
            }
          }
        }
      }
    }
  }
  if (declareXSI) {
    if (!toDOM) {
      doc.addAttribute(XSI_XMLNS,XMLResource.XSI_URI);
    }
 else {
      ((Element)currentNode).setAttributeNS(ExtendedMetaData.XMLNS_URI,XSI_XMLNS,XMLResource.XSI_URI);
    }
  }
  for (int i=0; i < packages.length; i++) {
    EPackage ePackage=packages[i];
    if (ePackage != noNamespacePackage && ePackage != XMLNamespacePackage.eINSTANCE && !ExtendedMetaData.XMLNS_URI.equals(ePackage.getNsURI())) {
      String nsURI=extendedMetaData == null ? ePackage.getNsURI() : extendedMetaData.getNamespace(ePackage);
      if (ePackage == xmlSchemaTypePackage) {
        nsURI=XMLResource.XML_SCHEMA_URI;
      }
      if (nsURI != null && !isDuplicateURI(nsURI)) {
        List nsPrefixes=helper.getPrefixes(ePackage);
        for (Iterator j=nsPrefixes.iterator(); j.hasNext(); ) {
          String nsPrefix=(String)j.next();
          if (!toDOM) {
            if (nsPrefix != null && nsPrefix.length() > 0) {
              doc.addAttributeNS(XMLResource.XML_NS,nsPrefix,nsURI);
            }
 else {
              doc.addAttribute(XMLResource.XML_NS,nsURI);
            }
          }
 else {
            if (nsPrefix != null && nsPrefix.length() > 0) {
              ((Element)currentNode).setAttributeNS(ExtendedMetaData.XMLNS_URI,XMLResource.XML_NS + ""String_Node_Str"" + nsPrefix,nsURI);
            }
 else {
              ((Element)currentNode).setAttributeNS(ExtendedMetaData.XMLNS_URI,XMLResource.XML_NS,nsURI);
            }
          }
        }
      }
    }
  }
  if (xsiSchemaLocation.length() > 0) {
    if (!toDOM) {
      doc.addAttribute(XSI_SCHEMA_LOCATION,xsiSchemaLocation.toString());
    }
 else {
      ((Element)currentNode).setAttributeNS(XMLResource.XSI_URI,XSI_SCHEMA_LOCATION,xsiSchemaLocation.toString());
    }
  }
  if (xsiNoNamespaceSchemaLocation != null) {
    if (!toDOM) {
      doc.addAttribute(XSI_NO_NAMESPACE_SCHEMA_LOCATION,xsiNoNamespaceSchemaLocation);
    }
 else {
      ((Element)currentNode).setAttributeNS(XMLResource.XSI_URI,XSI_NO_NAMESPACE_SCHEMA_LOCATION,xsiNoNamespaceSchemaLocation);
    }
  }
}",0.9896333754740836
11904,"protected void init(XMLResource resource,Map options){
  useCache=Boolean.TRUE.equals(options.get(XMLResource.OPTION_CONFIGURATION_CACHE));
  nameInfo=new NameInfoImpl();
  declareXSI=false;
  keepDefaults=Boolean.TRUE.equals(options.get(XMLResource.OPTION_KEEP_DEFAULT_CONTENT));
  useEncodedAttributeStyle=Boolean.TRUE.equals(options.get(XMLResource.OPTION_USE_ENCODED_ATTRIBUTE_STYLE));
  declareSchemaLocationImplementation=Boolean.TRUE.equals(options.get(XMLResource.OPTION_SCHEMA_LOCATION_IMPLEMENTATION));
  declareSchemaLocation=declareSchemaLocationImplementation || Boolean.TRUE.equals(options.get(XMLResource.OPTION_SCHEMA_LOCATION));
  Object saveTypeInfoOption=options.get(XMLResource.OPTION_SAVE_TYPE_INFORMATION);
  if (saveTypeInfoOption instanceof Boolean) {
    saveTypeInfo=saveTypeInfoOption.equals(Boolean.TRUE);
    if (saveTypeInfo) {
      xmlTypeInfo=new XMLTypeInfo(){
        public boolean shouldSaveType(        EClass objectType,        EClass featureType,        EStructuralFeature feature){
          return objectType != anyType;
        }
        public boolean shouldSaveType(        EClass objectType,        EClassifier featureType,        EStructuralFeature feature){
          return true;
        }
      }
;
    }
  }
 else {
    saveTypeInfo=saveTypeInfoOption != null;
    if (saveTypeInfo) {
      xmlTypeInfo=(XMLTypeInfo)saveTypeInfoOption;
    }
  }
  anyType=(EClass)options.get(XMLResource.OPTION_ANY_TYPE);
  anySimpleType=(EClass)options.get(XMLResource.OPTION_ANY_SIMPLE_TYPE);
  if (anyType == null) {
    anyType=XMLTypePackage.eINSTANCE.getAnyType();
    anySimpleType=XMLTypePackage.eINSTANCE.getSimpleAnyType();
  }
  Object extendedMetaDataOption=options.get(XMLResource.OPTION_EXTENDED_META_DATA);
  if (extendedMetaDataOption instanceof Boolean) {
    if (extendedMetaDataOption.equals(Boolean.TRUE)) {
      extendedMetaData=resource == null || resource.getResourceSet() == null ? ExtendedMetaData.INSTANCE : new BasicExtendedMetaData(resource.getResourceSet().getPackageRegistry());
    }
  }
 else {
    extendedMetaData=(ExtendedMetaData)options.get(XMLResource.OPTION_EXTENDED_META_DATA);
  }
  if (!toDOM) {
    declareXML=!Boolean.FALSE.equals(options.get(XMLResource.OPTION_DECLARE_XML));
    if (options.get(XMLResource.OPTION_FLUSH_THRESHOLD) instanceof Integer) {
      flushThreshold=((Integer)options.get(XMLResource.OPTION_FLUSH_THRESHOLD)).intValue();
    }
    String temporaryFileName=null;
    if (Boolean.TRUE.equals(options.get(XMLResource.OPTION_USE_FILE_BUFFER))) {
      try {
        temporaryFileName=File.createTempFile(""String_Node_Str"",null).getPath();
      }
 catch (      IOException exception) {
      }
    }
    Integer lineWidth=(Integer)options.get(XMLResource.OPTION_LINE_WIDTH);
    int effectiveLineWidth=lineWidth == null ? Integer.MAX_VALUE : lineWidth.intValue();
    String publicId=null, systemId=null;
    if (resource != null && Boolean.TRUE.equals(options.get(XMLResource.OPTION_SAVE_DOCTYPE))) {
      publicId=resource.getPublicId();
      systemId=resource.getSystemId();
    }
    if (useCache) {
      doc=ConfigurationCache.INSTANCE.getPrinter();
      doc.reset(publicId,systemId,effectiveLineWidth,temporaryFileName);
      escape=Boolean.TRUE.equals(options.get(XMLResource.OPTION_SKIP_ESCAPE)) ? null : ConfigurationCache.INSTANCE.getEscape();
    }
 else {
      doc=new XMLString(effectiveLineWidth,publicId,systemId,temporaryFileName);
      escape=Boolean.TRUE.equals(options.get(XMLResource.OPTION_SKIP_ESCAPE)) ? null : new Escape();
    }
    if (Boolean.FALSE.equals(options.get(XMLResource.OPTION_FORMATTED))) {
      doc.setUnformatted(true);
    }
    escapeURI=Boolean.FALSE.equals(options.get(XMLResource.OPTION_SKIP_ESCAPE_URI)) ? escape : null;
    if (options.containsKey(XMLResource.OPTION_ENCODING)) {
      encoding=(String)options.get(XMLResource.OPTION_ENCODING);
    }
 else     if (resource != null) {
      encoding=resource.getEncoding();
    }
    if (options.containsKey(XMLResource.OPTION_XML_VERSION)) {
      xmlVersion=(String)options.get(XMLResource.OPTION_XML_VERSION);
    }
 else     if (resource != null) {
      xmlVersion=resource.getXMLVersion();
    }
    if (escape != null) {
      int maxSafeChar=MAX_UTF_MAPPABLE_CODEPOINT;
      if (encoding != null) {
        if (encoding.equalsIgnoreCase(""String_Node_Str"") || encoding.equalsIgnoreCase(""String_Node_Str"")) {
          maxSafeChar=MAX_ASCII_MAPPABLE_CODEPOINT;
        }
 else         if (encoding.equalsIgnoreCase(""String_Node_Str"")) {
          maxSafeChar=MAX_LATIN1_MAPPABLE_CODEPOINT;
        }
      }
      escape.setMappingLimit(maxSafeChar);
      if (!""String_Node_Str"".equals(xmlVersion)) {
        escape.setAllowControlCharacters(true);
      }
    }
  }
 else {
    if (handler instanceof DefaultDOMHandlerImpl) {
      ((DefaultDOMHandlerImpl)handler).setExtendedMetaData(extendedMetaData);
    }
  }
  processDanglingHREF=(String)options.get(XMLResource.OPTION_PROCESS_DANGLING_HREF);
  helper.setProcessDanglingHREF(processDanglingHREF);
  map=(XMLResource.XMLMap)options.get(XMLResource.OPTION_XML_MAP);
  if (map != null) {
    helper.setXMLMap(map);
    if (map.getIDAttributeName() != null) {
      idAttributeName=map.getIDAttributeName();
    }
  }
  if (resource != null) {
    eObjectToExtensionMap=resource.getEObjectToExtensionMap();
    if (eObjectToExtensionMap.isEmpty()) {
      eObjectToExtensionMap=null;
    }
 else     if (extendedMetaData == null) {
      extendedMetaData=resource.getResourceSet() == null ? ExtendedMetaData.INSTANCE : new BasicExtendedMetaData(resource.getResourceSet().getPackageRegistry());
    }
  }
  if (extendedMetaData != null) {
    helper.setExtendedMetaData(extendedMetaData);
    if (resource != null && resource.getContents().size() >= 1) {
      EObject root=(EObject)resource.getContents().get(0);
      EClass eClass=root.eClass();
      EReference xmlnsPrefixMapFeature=extendedMetaData.getXMLNSPrefixMapFeature(eClass);
      if (xmlnsPrefixMapFeature != null) {
        EMap xmlnsPrefixMap=(EMap)root.eGet(xmlnsPrefixMapFeature);
        helper.setPrefixToNamespaceMap(xmlnsPrefixMap);
      }
    }
  }
  List lookup=(List)options.get(XMLResource.OPTION_USE_CACHED_LOOKUP_TABLE);
  if (lookup != null) {
    if (lookup.isEmpty()) {
      featureTable=new Lookup(map,extendedMetaData);
      lookup.add(featureTable);
    }
 else {
      featureTable=(Lookup)lookup.get(INDEX_LOOKUP);
    }
  }
 else {
    featureTable=new Lookup(map,extendedMetaData);
  }
}","protected void init(XMLResource resource,Map options){
  useCache=Boolean.TRUE.equals(options.get(XMLResource.OPTION_CONFIGURATION_CACHE));
  nameInfo=new NameInfoImpl();
  declareXSI=false;
  keepDefaults=Boolean.TRUE.equals(options.get(XMLResource.OPTION_KEEP_DEFAULT_CONTENT));
  useEncodedAttributeStyle=Boolean.TRUE.equals(options.get(XMLResource.OPTION_USE_ENCODED_ATTRIBUTE_STYLE));
  declareSchemaLocationImplementation=Boolean.TRUE.equals(options.get(XMLResource.OPTION_SCHEMA_LOCATION_IMPLEMENTATION));
  declareSchemaLocation=declareSchemaLocationImplementation || Boolean.TRUE.equals(options.get(XMLResource.OPTION_SCHEMA_LOCATION));
  Object saveTypeInfoOption=options.get(XMLResource.OPTION_SAVE_TYPE_INFORMATION);
  if (saveTypeInfoOption instanceof Boolean) {
    saveTypeInfo=saveTypeInfoOption.equals(Boolean.TRUE);
    if (saveTypeInfo) {
      xmlTypeInfo=new XMLTypeInfo(){
        public boolean shouldSaveType(        EClass objectType,        EClassifier featureType,        EStructuralFeature feature){
          return objectType != anyType;
        }
        public boolean shouldSaveType(        EClass objectType,        EClass featureType,        EStructuralFeature feature){
          return true;
        }
      }
;
    }
  }
 else {
    saveTypeInfo=saveTypeInfoOption != null;
    if (saveTypeInfo) {
      xmlTypeInfo=(XMLTypeInfo)saveTypeInfoOption;
    }
  }
  anyType=(EClass)options.get(XMLResource.OPTION_ANY_TYPE);
  anySimpleType=(EClass)options.get(XMLResource.OPTION_ANY_SIMPLE_TYPE);
  if (anyType == null) {
    anyType=XMLTypePackage.eINSTANCE.getAnyType();
    anySimpleType=XMLTypePackage.eINSTANCE.getSimpleAnyType();
  }
  Object extendedMetaDataOption=options.get(XMLResource.OPTION_EXTENDED_META_DATA);
  if (extendedMetaDataOption instanceof Boolean) {
    if (extendedMetaDataOption.equals(Boolean.TRUE)) {
      extendedMetaData=resource == null || resource.getResourceSet() == null ? ExtendedMetaData.INSTANCE : new BasicExtendedMetaData(resource.getResourceSet().getPackageRegistry());
    }
  }
 else {
    extendedMetaData=(ExtendedMetaData)options.get(XMLResource.OPTION_EXTENDED_META_DATA);
  }
  if (!toDOM) {
    declareXML=!Boolean.FALSE.equals(options.get(XMLResource.OPTION_DECLARE_XML));
    if (options.get(XMLResource.OPTION_FLUSH_THRESHOLD) instanceof Integer) {
      flushThreshold=((Integer)options.get(XMLResource.OPTION_FLUSH_THRESHOLD)).intValue();
    }
    String temporaryFileName=null;
    if (Boolean.TRUE.equals(options.get(XMLResource.OPTION_USE_FILE_BUFFER))) {
      try {
        temporaryFileName=File.createTempFile(""String_Node_Str"",null).getPath();
      }
 catch (      IOException exception) {
      }
    }
    Integer lineWidth=(Integer)options.get(XMLResource.OPTION_LINE_WIDTH);
    int effectiveLineWidth=lineWidth == null ? Integer.MAX_VALUE : lineWidth.intValue();
    String publicId=null, systemId=null;
    if (resource != null && Boolean.TRUE.equals(options.get(XMLResource.OPTION_SAVE_DOCTYPE))) {
      publicId=resource.getPublicId();
      systemId=resource.getSystemId();
    }
    if (useCache) {
      doc=ConfigurationCache.INSTANCE.getPrinter();
      doc.reset(publicId,systemId,effectiveLineWidth,temporaryFileName);
      escape=Boolean.TRUE.equals(options.get(XMLResource.OPTION_SKIP_ESCAPE)) ? null : ConfigurationCache.INSTANCE.getEscape();
    }
 else {
      doc=new XMLString(effectiveLineWidth,publicId,systemId,temporaryFileName);
      escape=Boolean.TRUE.equals(options.get(XMLResource.OPTION_SKIP_ESCAPE)) ? null : new Escape();
    }
    if (Boolean.FALSE.equals(options.get(XMLResource.OPTION_FORMATTED))) {
      doc.setUnformatted(true);
    }
    escapeURI=Boolean.FALSE.equals(options.get(XMLResource.OPTION_SKIP_ESCAPE_URI)) ? escape : null;
    if (options.containsKey(XMLResource.OPTION_ENCODING)) {
      encoding=(String)options.get(XMLResource.OPTION_ENCODING);
    }
 else     if (resource != null) {
      encoding=resource.getEncoding();
    }
    if (options.containsKey(XMLResource.OPTION_XML_VERSION)) {
      xmlVersion=(String)options.get(XMLResource.OPTION_XML_VERSION);
    }
 else     if (resource != null) {
      xmlVersion=resource.getXMLVersion();
    }
    if (escape != null) {
      int maxSafeChar=MAX_UTF_MAPPABLE_CODEPOINT;
      if (encoding != null) {
        if (encoding.equalsIgnoreCase(""String_Node_Str"") || encoding.equalsIgnoreCase(""String_Node_Str"")) {
          maxSafeChar=MAX_ASCII_MAPPABLE_CODEPOINT;
        }
 else         if (encoding.equalsIgnoreCase(""String_Node_Str"")) {
          maxSafeChar=MAX_LATIN1_MAPPABLE_CODEPOINT;
        }
      }
      escape.setMappingLimit(maxSafeChar);
      if (!""String_Node_Str"".equals(xmlVersion)) {
        escape.setAllowControlCharacters(true);
      }
    }
  }
 else {
    if (handler instanceof DefaultDOMHandlerImpl) {
      ((DefaultDOMHandlerImpl)handler).setExtendedMetaData(extendedMetaData);
    }
  }
  processDanglingHREF=(String)options.get(XMLResource.OPTION_PROCESS_DANGLING_HREF);
  helper.setProcessDanglingHREF(processDanglingHREF);
  map=(XMLResource.XMLMap)options.get(XMLResource.OPTION_XML_MAP);
  if (map != null) {
    helper.setXMLMap(map);
    if (map.getIDAttributeName() != null) {
      idAttributeName=map.getIDAttributeName();
    }
  }
  if (resource != null) {
    eObjectToExtensionMap=resource.getEObjectToExtensionMap();
    if (eObjectToExtensionMap.isEmpty()) {
      eObjectToExtensionMap=null;
    }
 else     if (extendedMetaData == null) {
      extendedMetaData=resource.getResourceSet() == null ? ExtendedMetaData.INSTANCE : new BasicExtendedMetaData(resource.getResourceSet().getPackageRegistry());
    }
  }
  if (extendedMetaData != null) {
    helper.setExtendedMetaData(extendedMetaData);
    if (resource != null && resource.getContents().size() >= 1) {
      EObject root=(EObject)resource.getContents().get(0);
      EClass eClass=root.eClass();
      EReference xmlnsPrefixMapFeature=extendedMetaData.getXMLNSPrefixMapFeature(eClass);
      if (xmlnsPrefixMapFeature != null) {
        EMap xmlnsPrefixMap=(EMap)root.eGet(xmlnsPrefixMapFeature);
        helper.setPrefixToNamespaceMap(xmlnsPrefixMap);
      }
    }
  }
  List lookup=(List)options.get(XMLResource.OPTION_USE_CACHED_LOOKUP_TABLE);
  if (lookup != null) {
    if (lookup.isEmpty()) {
      featureTable=new Lookup(map,extendedMetaData);
      lookup.add(featureTable);
    }
 else {
      featureTable=(Lookup)lookup.get(INDEX_LOOKUP);
    }
  }
 else {
    featureTable=new Lookup(map,extendedMetaData);
  }
}",0.999236174763214
11905,"protected int sameDocSingle(EObject o,EStructuralFeature f){
  InternalEObject value=(InternalEObject)helper.getValue(o,f);
  if (value == null) {
    return SKIP;
  }
 else   if (value.eIsProxy()) {
    return CROSS_DOC;
  }
 else {
    Resource res=value.eResource();
    return res == helper.getResource() ? SAME_DOC : CROSS_DOC;
  }
}","protected int sameDocSingle(EObject o,EStructuralFeature f){
  InternalEObject value=(InternalEObject)helper.getValue(o,f);
  if (value == null) {
    return SKIP;
  }
 else   if (value.eIsProxy()) {
    return CROSS_DOC;
  }
 else {
    Resource res=value.eResource();
    return res == helper.getResource() || res == null ? SAME_DOC : CROSS_DOC;
  }
}",0.9782923299565848
11906,"protected void saveHref(EObject remote,EStructuralFeature f){
  String href=helper.getHREF(remote);
  if (href != null) {
    if (escapeURI != null) {
      href=escapeURI.convert(href);
    }
    if (!toDOM) {
      String name=helper.getQName(f);
      doc.startElement(name);
    }
 else {
      helper.populateNameInfo(nameInfo,f);
      Element elem=document.createElementNS(nameInfo.getNamespaceURI(),nameInfo.getQualifiedName());
      currentNode=currentNode.appendChild(elem);
      handler.recordValues(elem,remote.eContainer(),f,remote);
    }
    EClass eClass=remote.eClass();
    EClass expectedType=(EClass)f.getEType();
    if (saveTypeInfo ? xmlTypeInfo.shouldSaveType(eClass,expectedType,f) : eClass != expectedType && expectedType.isAbstract()) {
      saveTypeAttribute(eClass);
    }
    if (!toDOM) {
      doc.addAttribute(XMLResource.HREF,href);
      doc.endEmptyElement();
    }
 else {
      ((Element)currentNode).setAttributeNS(null,XMLResource.HREF,href);
      currentNode=currentNode.getParentNode();
    }
  }
}","protected void saveHref(EObject remote,EStructuralFeature f){
  String href=helper.getHREF(remote);
  if (href != null) {
    if (escapeURI != null) {
      href=escapeURI.convert(href);
    }
    if (!toDOM) {
      String name=helper.getQName(f);
      doc.startElement(name);
    }
 else {
      helper.populateNameInfo(nameInfo,f);
      Element elem=document.createElementNS(nameInfo.getNamespaceURI(),nameInfo.getQualifiedName());
      currentNode=currentNode.appendChild(elem);
      handler.recordValues(elem,remote.eContainer(),f,remote);
    }
    EClass eClass=remote.eClass();
    EClass expectedType=(EClass)f.getEType();
    if (saveTypeInfo ? xmlTypeInfo.shouldSaveType(eClass,expectedType,f) : eClass != expectedType && expectedType.isAbstract()) {
      saveTypeAttribute(eClass);
    }
    if (!toDOM) {
      doc.addAttribute(XMLResource.HREF,href);
      if (eObjectToExtensionMap != null) {
        processAttributeExtensions(remote);
        if (processElementExtensions(remote)) {
          doc.endElement();
        }
 else {
          doc.endEmptyElement();
        }
      }
 else {
        doc.endEmptyElement();
      }
    }
 else {
      ((Element)currentNode).setAttributeNS(null,XMLResource.HREF,href);
      if (eObjectToExtensionMap != null) {
        processAttributeExtensions(remote);
        processElementExtensions(remote);
      }
      currentNode=currentNode.getParentNode();
    }
  }
}",0.8436363636363636
11907,"protected int sameDocMany(EObject o,EStructuralFeature f){
  InternalEList values=(InternalEList)helper.getValue(o,f);
  if (values.isEmpty()) {
    return SKIP;
  }
  for (Iterator i=values.basicIterator(); i.hasNext(); ) {
    InternalEObject value=(InternalEObject)i.next();
    if (value.eIsProxy() || value.eResource() != helper.getResource()) {
      return CROSS_DOC;
    }
  }
  return SAME_DOC;
}","protected int sameDocMany(EObject o,EStructuralFeature f){
  InternalEList values=(InternalEList)helper.getValue(o,f);
  if (values.isEmpty()) {
    return SKIP;
  }
  for (Iterator i=values.basicIterator(); i.hasNext(); ) {
    InternalEObject value=(InternalEObject)i.next();
    if (value.eIsProxy()) {
      return CROSS_DOC;
    }
 else {
      Resource resource=value.eResource();
      if (resource != helper.getResource() && resource != null) {
        return CROSS_DOC;
      }
    }
  }
  return SAME_DOC;
}",0.8698481561822126
11908,"public boolean shouldSaveType(EClass objectType,EClass featureType,EStructuralFeature feature){
  return objectType != featureType;
}","public boolean shouldSaveType(EClass objectType,EClass featureType,EStructuralFeature feature){
  return objectType != featureType && featureType.isAbstract();
}",0.9047619047619048
11909,"/** 
 * Add object to extent and call processObject.
 */
protected void processTopObject(EObject object){
  if (object != null) {
    if (deferredExtent != null) {
      deferredExtent.add(object);
    }
 else {
      extent.addUnique(object);
    }
    if (extendedMetaData != null) {
      FeatureMap featureMap=(FeatureMap)mixedTargets.pop();
      EStructuralFeature target=extendedMetaData.getMixedFeature(object.eClass());
      if (target != null) {
        FeatureMap otherFeatureMap=(FeatureMap)object.eGet(target);
        for (Iterator i=featureMap.iterator(); i.hasNext(); ) {
          FeatureMap.Entry entry=(FeatureMap.Entry)i.next();
          if (entry.getEStructuralFeature() != XMLTypePackage.Literals.XML_TYPE_DOCUMENT_ROOT__TEXT || !""String_Node_Str"".equals(XMLTypeUtil.normalize(entry.getValue().toString(),true))) {
            otherFeatureMap.add(entry.getEStructuralFeature(),entry.getValue());
          }
        }
      }
      text=null;
    }
  }
  processObject(object);
}","/** 
 * Add object to extent and call processObject.
 */
protected void processTopObject(EObject object){
  if (object != null) {
    if (deferredExtent != null) {
      deferredExtent.add(object);
    }
 else {
      extent.addUnique(object);
    }
    if (extendedMetaData != null && !mixedTargets.isEmpty()) {
      FeatureMap featureMap=(FeatureMap)mixedTargets.pop();
      EStructuralFeature target=extendedMetaData.getMixedFeature(object.eClass());
      if (target != null) {
        FeatureMap otherFeatureMap=(FeatureMap)object.eGet(target);
        for (Iterator i=featureMap.iterator(); i.hasNext(); ) {
          FeatureMap.Entry entry=(FeatureMap.Entry)i.next();
          if (entry.getEStructuralFeature() != XMLTypePackage.Literals.XML_TYPE_DOCUMENT_ROOT__TEXT || !""String_Node_Str"".equals(XMLTypeUtil.normalize(entry.getValue().toString(),true))) {
            otherFeatureMap.add(entry.getEStructuralFeature(),entry.getValue());
          }
        }
      }
      text=null;
    }
  }
  processObject(object);
}",0.9867191342843088
11910,"protected void recordUnknownFeature(String prefix,String name,boolean isElement,EObject peekObject,String value){
  if (isElement) {
    AnyType anyType=getExtension(peekObject);
    objects.push(anyType);
    mixedTargets.push(anyType.getAny());
    types.push(UNKNOWN_FEATURE_TYPE);
    int unknownFeatureIndex=types.size() - 1;
    ;
    handleFeature(prefix,name);
    objects.remove(unknownFeatureIndex);
    mixedTargets.remove(unknownFeatureIndex);
    types.remove(unknownFeatureIndex);
  }
 else {
    AnyType anyType=getExtension(peekObject);
    setAttribValue(anyType,prefix == null ? name : prefix + ""String_Node_Str"" + name,value);
  }
}","protected void recordUnknownFeature(String prefix,String name,boolean isElement,EObject peekObject,String value){
  if (isElement) {
    AnyType anyType=getExtension(peekObject);
    int objectsIndex=objects.size();
    objects.push(anyType);
    int mixedTargetsIndex=mixedTargets.size();
    mixedTargets.push(anyType.getAny());
    int typesIndex=types.size();
    types.push(UNKNOWN_FEATURE_TYPE);
    handleFeature(prefix,name);
    objects.remove(objectsIndex);
    mixedTargets.remove(mixedTargetsIndex);
    types.remove(typesIndex);
  }
 else {
    AnyType anyType=getExtension(peekObject);
    setAttribValue(anyType,prefix == null ? name : prefix + ""String_Node_Str"" + name,value);
  }
}",0.7353595255744997
11911,"protected JNode insertClone(JNode sourceNode){
  Object context=targetCompilationUnit != null ? getControlModel().getFacadeHelper().getContext(targetCompilationUnit) : null;
  JNode targetNode=getControlModel().getFacadeHelper().cloneNode(context,sourceNode);
  if (targetNode != null) {
    map(sourceNode,targetNode);
    mapChildren(sourceNode,targetNode);
  }
 else {
  }
  for (JNode previousNode=getControlModel().getFacadeHelper().getPrevious(sourceNode); previousNode != null; previousNode=getControlModel().getFacadeHelper().getPrevious(previousNode)) {
    JNode targetSibling=(JNode)sourceToTargetMap.get(previousNode);
    if (targetSibling != null) {
      JNode targetNextSibling=getControlModel().getFacadeHelper().getNext(targetSibling);
      if (targetNextSibling == null) {
        getControlModel().getFacadeHelper().addChild(targetSibling.getParent(),targetNode);
      }
 else {
        getControlModel().getFacadeHelper().insertSibling(targetNextSibling,targetNode,true);
      }
      return targetNode;
    }
  }
  JNode sourceParent=sourceNode.getParent();
  if (sourceParent != null) {
    JNode targetParent=(JNode)sourceToTargetMap.get(sourceParent);
    JNode targetSibling=getControlModel().getFacadeHelper().getFirstChild(targetParent);
    if (targetSibling == null) {
      getControlModel().getFacadeHelper().addChild(targetParent.getParent(),targetNode);
    }
 else {
      getControlModel().getFacadeHelper().insertSibling(targetSibling,targetNode,true);
    }
  }
  return targetNode;
}","protected JNode insertClone(JNode sourceNode){
  Object context=targetCompilationUnit != null ? getControlModel().getFacadeHelper().getContext(targetCompilationUnit) : null;
  JNode targetNode=getControlModel().getFacadeHelper().cloneNode(context,sourceNode);
  if (targetNode != null) {
    map(sourceNode,targetNode);
    mapChildren(sourceNode,targetNode);
  }
 else {
  }
  for (JNode previousNode=getControlModel().getFacadeHelper().getPrevious(sourceNode); previousNode != null; previousNode=getControlModel().getFacadeHelper().getPrevious(previousNode)) {
    JNode targetSibling=(JNode)sourceToTargetMap.get(previousNode);
    if (targetSibling != null) {
      JNode targetNextSibling=getControlModel().getFacadeHelper().getNext(targetSibling);
      if (targetNextSibling == null) {
        getControlModel().getFacadeHelper().addChild(targetSibling.getParent(),targetNode);
      }
 else {
        getControlModel().getFacadeHelper().insertSibling(targetNextSibling,targetNode,true);
      }
      return targetNode;
    }
  }
  JNode sourceParent=sourceNode.getParent();
  if (sourceParent != null) {
    JNode targetParent=(JNode)sourceToTargetMap.get(sourceParent);
    JNode targetSibling=getControlModel().getFacadeHelper().getFirstChild(targetParent);
    if (targetSibling == null) {
      getControlModel().getFacadeHelper().addChild(targetParent,targetNode);
    }
 else {
      getControlModel().getFacadeHelper().insertSibling(targetSibling,targetNode,true);
    }
  }
  return targetNode;
}",0.9960500329163924
11912,"public void reset(){
  this.xmlResource=null;
  this.extendedMetaData=null;
  eClassFeatureNamePairToEStructuralFeatureMap=null;
  if (isOptionUseXMLNameToFeatureSet && helper instanceof XMLHelperImpl) {
    featuresToKinds=((XMLHelperImpl)helper).featuresToKinds;
  }
 else {
    featuresToKinds=null;
  }
  if (ecoreBuilder != null) {
    this.ecoreBuilder.setExtendedMetaData(null);
  }
  this.helper=null;
  elements.clear();
  objects.clear();
  mixedTargets.clear();
  contextFeature=null;
  eObjectToExtensionMap=null;
  externalURIToLocations=null;
  types.clear();
  prefixesToFactories.clear();
  forwardSingleReferences.clear();
  forwardManyReferences.clear();
  sameDocumentProxies.clear();
  for (int i=0; i < identifiers.length; i++) {
    identifiers[i]=null;
  }
  for (int i=0; i < positions.length; i++) {
    positions[i]=0;
  }
  capacity=ARRAY_SIZE;
  resourceSet=null;
  packageRegistry=null;
  resourceURI=null;
  extent=null;
  attribs=null;
  locator=null;
  urisToLocations=null;
}","public void reset(){
  this.xmlResource=null;
  this.extendedMetaData=null;
  eClassFeatureNamePair.eClass=null;
  eClassFeatureNamePairToEStructuralFeatureMap=null;
  if (isOptionUseXMLNameToFeatureSet && helper instanceof XMLHelperImpl) {
    featuresToKinds=((XMLHelperImpl)helper).featuresToKinds;
  }
 else {
    featuresToKinds=null;
  }
  if (ecoreBuilder != null) {
    this.ecoreBuilder.setExtendedMetaData(null);
  }
  this.helper=null;
  elements.clear();
  objects.clear();
  mixedTargets.clear();
  contextFeature=null;
  eObjectToExtensionMap=null;
  externalURIToLocations=null;
  types.clear();
  prefixesToFactories.clear();
  forwardSingleReferences.clear();
  forwardManyReferences.clear();
  sameDocumentProxies.clear();
  for (int i=0; i < identifiers.length; i++) {
    identifiers[i]=null;
  }
  for (int i=0; i < positions.length; i++) {
    positions[i]=0;
  }
  capacity=ARRAY_SIZE;
  resourceSet=null;
  packageRegistry=null;
  resourceURI=null;
  extent=null;
  attribs=null;
  locator=null;
  urisToLocations=null;
}",0.9819775937652216
11913,"public NotificationChain eBasicSetContainer(InternalEObject newContainer,int newContainerFeatureID,NotificationChain msgs){
  InternalEObject oldContainer=eInternalContainer();
  Resource.Internal oldResource=this.eDirectResource();
  Resource.Internal newResource=null;
  if (oldResource != null) {
    if (!eContainmentFeature(this,newContainer,newContainerFeatureID).isResolveProxies()) {
      msgs=((InternalEList)oldResource.getContents()).basicRemove(this,msgs);
      eSetDirectResource(null);
      if (newContainer != null) {
        newResource=newContainer.eInternalResource();
      }
    }
    oldResource=null;
  }
 else   if (oldContainer != null) {
    oldResource=oldContainer.eInternalResource();
    if (newContainer != null) {
      newResource=newContainer.eInternalResource();
    }
  }
  if (oldResource != newResource && oldResource != null) {
    oldResource.detached(this);
  }
  int oldContainerFeatureID=eContainerFeatureID();
  eBasicSetContainer(newContainer,newContainerFeatureID);
  if (oldResource != newResource && newResource != null) {
    newResource.attached(this);
  }
  if (eNotificationRequired()) {
    if (msgs == null)     msgs=new NotificationChainImpl(4);
    if (oldContainer != null && oldContainerFeatureID >= 0 && oldContainerFeatureID != newContainerFeatureID) {
      msgs.add(new ENotificationImpl(this,Notification.SET,oldContainerFeatureID,oldContainer,null));
    }
    if (newContainerFeatureID >= 0) {
      msgs.add(new ENotificationImpl(this,Notification.SET,newContainerFeatureID,oldContainerFeatureID == newContainerFeatureID ? oldContainer : null,newContainer));
    }
  }
  return msgs;
}","public NotificationChain eBasicSetContainer(InternalEObject newContainer,int newContainerFeatureID,NotificationChain msgs){
  InternalEObject oldContainer=eInternalContainer();
  Resource.Internal oldResource=this.eDirectResource();
  Resource.Internal newResource=null;
  if (oldResource != null) {
    if (!eContainmentFeature(this,newContainer,newContainerFeatureID).isResolveProxies()) {
      msgs=((InternalEList)oldResource.getContents()).basicRemove(this,msgs);
      eSetDirectResource(null);
      if (newContainer != null) {
        newResource=newContainer.eInternalResource();
      }
    }
    oldResource=null;
  }
 else {
    if (oldContainer != null) {
      oldResource=oldContainer.eInternalResource();
    }
    if (newContainer != null) {
      newResource=newContainer.eInternalResource();
    }
  }
  if (oldResource != newResource && oldResource != null) {
    oldResource.detached(this);
  }
  int oldContainerFeatureID=eContainerFeatureID();
  eBasicSetContainer(newContainer,newContainerFeatureID);
  if (oldResource != newResource && newResource != null) {
    newResource.attached(this);
  }
  if (eNotificationRequired()) {
    if (msgs == null)     msgs=new NotificationChainImpl(4);
    if (oldContainer != null && oldContainerFeatureID >= 0 && oldContainerFeatureID != newContainerFeatureID) {
      msgs.add(new ENotificationImpl(this,Notification.SET,oldContainerFeatureID,oldContainer,null));
    }
    if (newContainerFeatureID >= 0) {
      msgs.add(new ENotificationImpl(this,Notification.SET,newContainerFeatureID,oldContainerFeatureID == newContainerFeatureID ? oldContainer : null,newContainer));
    }
  }
  return msgs;
}",0.9963833634719712
11914,"/** 
 * <!-- begin-user-doc --> <!-- end-user-doc -->
 * @generated NOT
 */
public void setReferenceValue(EObject newReferenceValue){
  EObject oldReferenceValue=basicGetReferenceValue();
  value=newReferenceValue;
  if (value instanceof EEnumLiteral) {
    eFlags&=~REFVALUE_FEATURECHANGE;
  }
 else {
    eFlags|=REFVALUE_FEATURECHANGE;
  }
  valueString=null;
  if (eNotificationRequired())   eNotify(new ENotificationImpl(this,Notification.SET,ChangePackage.FEATURE_CHANGE__REFERENCE_VALUE,oldReferenceValue,newReferenceValue));
}","/** 
 * <!-- begin-user-doc --> <!-- end-user-doc -->
 * @generated NOT
 */
public void setReferenceValue(EObject newReferenceValue){
  EObject oldReferenceValue=basicGetReferenceValue();
  value=newReferenceValue;
  valueString=null;
  if (eNotificationRequired())   eNotify(new ENotificationImpl(this,Notification.SET,ChangePackage.FEATURE_CHANGE__REFERENCE_VALUE,oldReferenceValue,newReferenceValue));
}",0.8638297872340426
11915,"/** 
 * <!-- begin-user-doc --> <!-- end-user-doc -->
 * @generated NOT
 */
public EObject basicGetReferenceValue(){
  return (eFlags & REFVALUE_FEATURECHANGE) != 0 ? (EObject)value : null;
}","/** 
 * <!-- begin-user-doc --> <!-- end-user-doc -->
 * @generated NOT
 */
public EObject basicGetReferenceValue(){
  return (feature instanceof EReference && !feature.isMany()) ? (EObject)value : null;
}",0.797979797979798
11916,"protected void setValue(Object value){
  EStructuralFeature feature=getFeature();
  if (!eNotificationRequired() || feature.isMany()) {
    valueString=null;
    this.value=value;
    if (value instanceof EObject && !(value instanceof EEnumLiteral)) {
      eFlags|=REFVALUE_FEATURECHANGE;
    }
 else {
      eFlags&=~REFVALUE_FEATURECHANGE;
    }
  }
 else {
    if (feature instanceof EAttribute) {
      EDataType type=(EDataType)feature.getEType();
      setDataValue(EcoreUtil.convertToString(type,value));
      this.value=value;
      eFlags&=~REFVALUE_FEATURECHANGE;
    }
 else {
      setReferenceValue((EObject)value);
    }
  }
}","protected void setValue(Object value){
  EStructuralFeature feature=getFeature();
  if (!eNotificationRequired() || feature.isMany()) {
    valueString=null;
    this.value=value;
  }
 else {
    if (feature instanceof EAttribute) {
      EDataType type=(EDataType)feature.getEType();
      setDataValue(EcoreUtil.convertToString(type,value));
      this.value=value;
    }
 else {
      setReferenceValue((EObject)value);
    }
  }
}",0.3754646840148699
11917,"/** 
 * <!-- begin-user-doc --> <!-- end-user-doc -->
 * @generated NOT
 */
public void setReferenceValue(EObject newReferenceValue){
  EObject oldReferenceValue=basicGetReferenceValue();
  value=newReferenceValue;
  valueString=null;
  if (eNotificationRequired())   eNotify(new ENotificationImpl(this,Notification.SET,ChangePackage.FEATURE_CHANGE__REFERENCE_VALUE,oldReferenceValue,newReferenceValue));
}","/** 
 * <!-- begin-user-doc --> <!-- end-user-doc -->
 * @generated NOT
 */
public void setReferenceValue(EObject newReferenceValue){
  EObject oldReferenceValue=basicGetReferenceValue();
  value=newReferenceValue;
  if (value instanceof EEnumLiteral) {
    eFlags&=~REFVALUE_FEATURECHANGE;
  }
 else {
    eFlags|=REFVALUE_FEATURECHANGE;
  }
  valueString=null;
  if (eNotificationRequired())   eNotify(new ENotificationImpl(this,Notification.SET,ChangePackage.FEATURE_CHANGE__REFERENCE_VALUE,oldReferenceValue,newReferenceValue));
}",0.8638297872340426
11918,"/** 
 * <!-- begin-user-doc --> <!-- end-user-doc -->
 * @generated NOT
 */
public EObject basicGetReferenceValue(){
  return value instanceof EObject ? (EObject)value : null;
}","/** 
 * <!-- begin-user-doc --> <!-- end-user-doc -->
 * @generated NOT
 */
public EObject basicGetReferenceValue(){
  return (eFlags & REFVALUE_FEATURECHANGE) != 0 ? (EObject)value : null;
}",0.8532608695652174
11919,"protected void setValue(Object value){
  EStructuralFeature feature=getFeature();
  if (!eNotificationRequired() || feature.isMany()) {
    valueString=null;
    this.value=value;
  }
 else {
    if (feature instanceof EAttribute) {
      EDataType type=(EDataType)feature.getEType();
      setDataValue(EcoreUtil.convertToString(type,value));
      this.value=value;
    }
 else {
      setReferenceValue((EObject)value);
    }
  }
}","protected void setValue(Object value){
  EStructuralFeature feature=getFeature();
  if (!eNotificationRequired() || feature.isMany()) {
    valueString=null;
    this.value=value;
    if (value instanceof EObject && !(value instanceof EEnumLiteral)) {
      eFlags|=REFVALUE_FEATURECHANGE;
    }
 else {
      eFlags&=~REFVALUE_FEATURECHANGE;
    }
  }
 else {
    if (feature instanceof EAttribute) {
      EDataType type=(EDataType)feature.getEType();
      setDataValue(EcoreUtil.convertToString(type,value));
      this.value=value;
      eFlags&=~REFVALUE_FEATURECHANGE;
    }
 else {
      setReferenceValue((EObject)value);
    }
  }
}",0.8066914498141264
11920,"/** 
 * Updates the UUID with the current time, compensating for the fact that the clock resolution may be less than 100 ns. The byte array will have its first eight bytes populated with the time in the correct sequence of bytes, as per the specification.
 */
private static void updateCurrentTime(){
  long currentTime=System.currentTimeMillis() + EPOCH_ADJUSTMENT;
  if (lastTime > currentTime) {
    ++clockSequence;
    if (16384 == clockSequence) {
      clockSequence=0;
    }
    updateClockSequence();
  }
 else   if (lastTime == currentTime) {
    ++timeAdjustment;
    if (timeAdjustment > 9999) {
      try {
        Thread.sleep(1);
      }
 catch (      InterruptedException exception) {
      }
      timeAdjustment=0;
      currentTime=System.currentTimeMillis() + EPOCH_ADJUSTMENT;
      if (lastTime == currentTime) {
        throw new Error(""String_Node_Str"");
      }
    }
  }
 else {
    timeAdjustment=0;
  }
  lastTime=currentTime;
  currentTime*=10000;
  currentTime+=timeAdjustment;
  currentTime|=0x1000000000000000L;
  for (int i=0; i < 4; ++i) {
    uuid[i]=(byte)((currentTime >> 8 * (3 - i)) & 0xFFL);
  }
  for (int i=0; i < 2; ++i) {
    uuid[i + 4]=(byte)((currentTime >> 8 * (1 - i) + 32) & 0xFFL);
  }
  for (int i=0; i < 2; ++i) {
    uuid[i + 6]=(byte)((currentTime >> 8 * (1 - i) + 48) & 0xFFL);
  }
}","/** 
 * Updates the UUID with the current time, compensating for the fact that the clock resolution may be less than 100 ns. The byte array will have its first eight bytes populated with the time in the correct sequence of bytes, as per the specification.
 */
private static void updateCurrentTime(){
  long currentTime=System.currentTimeMillis() + EPOCH_ADJUSTMENT;
  if (lastTime > currentTime) {
    ++clockSequence;
    if (16384 == clockSequence) {
      clockSequence=0;
    }
    updateClockSequence();
  }
 else   if (lastTime == currentTime) {
    ++timeAdjustment;
    if (timeAdjustment > 9999) {
      try {
        Thread.sleep(sleepTime);
      }
 catch (      InterruptedException exception) {
      }
      timeAdjustment=0;
      currentTime=System.currentTimeMillis() + EPOCH_ADJUSTMENT;
      while (lastTime == currentTime) {
        try {
          ++sleepTime;
          Thread.sleep(1);
        }
 catch (        InterruptedException exception) {
        }
        currentTime=System.currentTimeMillis() + EPOCH_ADJUSTMENT;
      }
    }
  }
 else {
    timeAdjustment=0;
  }
  lastTime=currentTime;
  currentTime*=10000;
  currentTime+=timeAdjustment;
  currentTime|=0x1000000000000000L;
  for (int i=0; i < 4; ++i) {
    uuid[i]=(byte)((currentTime >> 8 * (3 - i)) & 0xFFL);
  }
  for (int i=0; i < 2; ++i) {
    uuid[i + 4]=(byte)((currentTime >> 8 * (1 - i) + 32) & 0xFFL);
  }
  for (int i=0; i < 2; ++i) {
    uuid[i + 6]=(byte)((currentTime >> 8 * (1 - i) + 48) & 0xFFL);
  }
}",0.9184820801124384
11921,"/** 
 * Registers the specified classpath variable in the workspace   and adds a classpath entry to the   {@link #getClasspathEntries() classpath entry list}. The variable is bound to the first runtime library JAR file in the list of runtime libraries of the specified plugin. When   {@link #generate generate} is called and it needs to generate the  {@link #getMethod method} to invoke,it will call  {@link #initialize initialize} which will add the classpath entries to the  {@link #getProjectName project} created to hold and compile the emitted template.<p> This method must be called <b>before</b> {@link #initialize initialize} or {@link #generate generate}are called. <p> The specified plugin ID must be the ID of an existing plugin. The referenced plugin must have at least one  runtime library JAR file in its plugin descriptor. If the plugin descriptor's list of runtime libraries contains more than one JAR file,  the classpath variable will be bound to the <b>first</b> library in the list.
 * @param variableName name of the classpath variable
 * @param pluginID the ID of an existing plugin 
 */
public void addVariable(String variableName,String pluginID) throws JETException {
  try {
    Bundle bundle=Platform.getBundle(pluginID);
    String requires=(String)bundle.getHeaders().get(Constants.BUNDLE_CLASSPATH);
    ManifestElement[] elements=ManifestElement.parseHeader(Constants.BUNDLE_CLASSPATH,requires);
    for (int i=0; i < elements.length; ++i) {
      ManifestElement element=elements[i];
      try {
        IPath path=null;
        URL url=Platform.inDevelopmentMode() ? null : bundle.getEntry(element.getValue());
        if (url == null) {
          URL classpathURL=bundle.getEntry(""String_Node_Str"");
          if (classpathURL == null) {
            url=bundle.getEntry(element.getValue());
          }
 else {
            DocumentBuilderFactory documentBuilderFactory=DocumentBuilderFactory.newInstance();
            documentBuilderFactory.setNamespaceAware(true);
            documentBuilderFactory.setValidating(false);
            try {
              DocumentBuilder documentBuilder=documentBuilderFactory.newDocumentBuilder();
              Document document=documentBuilder.parse(new InputSource(classpathURL.toString()));
              for (Node child=document.getDocumentElement().getFirstChild(); child != null; child=child.getNextSibling()) {
                if (child.getNodeType() == Node.ELEMENT_NODE) {
                  Element classpathEntryElement=(Element)child;
                  if (""String_Node_Str"".equals(classpathEntryElement.getNodeName()) && ""String_Node_Str"".equals(classpathEntryElement.getAttribute(""String_Node_Str""))) {
                    URI uri=URI.createURI(classpathEntryElement.getAttribute(""String_Node_Str"")).resolve(URI.createURI(classpathURL.toString()));
                    IWorkspace workspace=ResourcesPlugin.getWorkspace();
                    IProject project=workspace.getRoot().getProject(getProjectName());
                    if (!project.exists()) {
                      project.create(new NullProgressMonitor());
                    }
                    if (!project.isOpen()) {
                      project.open(new NullProgressMonitor());
                    }
                    IFolder folder=project.getFolder(""String_Node_Str"" + pluginID);
                    if (!folder.exists()) {
                      folder.createLink(new Path(CommonPlugin.asLocalURI(uri).toFileString()).removeTrailingSeparator(),IResource.ALLOW_MISSING_LOCAL,new NullProgressMonitor());
                    }
                    folder.refreshLocal(IResource.DEPTH_INFINITE,new NullProgressMonitor());
                    path=folder.getFullPath();
                    break;
                  }
                }
              }
            }
 catch (            Exception exception) {
              CodeGenPlugin.INSTANCE.log(exception);
            }
          }
        }
 else {
          path=new Path(Platform.asLocalURL(url).getFile());
        }
        if (path != null && !path.equals(JavaCore.getClasspathVariable(variableName))) {
          JavaCore.setClasspathVariable(variableName,path,null);
        }
      }
 catch (      MalformedURLException exception) {
        throw new JETException(exception);
      }
catch (      JavaModelException exception) {
        throw new JETException(exception);
      }
catch (      IOException exception) {
        throw new JETException(exception);
      }
      break;
    }
  }
 catch (  BundleException exception) {
    throw new JETException(exception);
  }
  IClasspathEntry entry=JavaCore.newVariableEntry(new Path(variableName),null,null);
  getClasspathEntries().add(entry);
}","/** 
 * Registers the specified classpath variable in the workspace   and adds a classpath entry to the   {@link #getClasspathEntries() classpath entry list}. The variable is bound to the first runtime library JAR file in the list of runtime libraries of the specified plugin. When   {@link #generate generate} is called and it needs to generate the  {@link #getMethod method} to invoke,it will call  {@link #initialize initialize} which will add the classpath entries to the  {@link #getProjectName project} created to hold and compile the emitted template.<p> This method must be called <b>before</b> {@link #initialize initialize} or {@link #generate generate}are called. <p> The specified plugin ID must be the ID of an existing plugin. The referenced plugin must have at least one  runtime library JAR file in its plugin descriptor. If the plugin descriptor's list of runtime libraries contains more than one JAR file,  the classpath variable will be bound to the <b>first</b> library in the list.
 * @param variableName name of the classpath variable
 * @param pluginID the ID of an existing plugin 
 */
public void addVariable(String variableName,String pluginID) throws JETException {
  try {
    Bundle bundle=Platform.getBundle(pluginID);
    String requires=(String)bundle.getHeaders().get(Constants.BUNDLE_CLASSPATH);
    ManifestElement[] elements=ManifestElement.parseHeader(Constants.BUNDLE_CLASSPATH,requires);
    for (int i=0; i < elements.length; ++i) {
      ManifestElement element=elements[i];
      try {
        IPath path=null;
        URL url=Platform.inDevelopmentMode() ? null : bundle.getEntry(element.getValue());
        if (url == null) {
          URL classpathURL=bundle.getEntry(""String_Node_Str"");
          if (classpathURL == null) {
            url=bundle.getEntry(element.getValue());
            path=new Path(Platform.asLocalURL(url).getFile());
          }
 else {
            DocumentBuilderFactory documentBuilderFactory=DocumentBuilderFactory.newInstance();
            documentBuilderFactory.setNamespaceAware(true);
            documentBuilderFactory.setValidating(false);
            try {
              DocumentBuilder documentBuilder=documentBuilderFactory.newDocumentBuilder();
              Document document=documentBuilder.parse(new InputSource(classpathURL.toString()));
              for (Node child=document.getDocumentElement().getFirstChild(); child != null; child=child.getNextSibling()) {
                if (child.getNodeType() == Node.ELEMENT_NODE) {
                  Element classpathEntryElement=(Element)child;
                  if (""String_Node_Str"".equals(classpathEntryElement.getNodeName()) && ""String_Node_Str"".equals(classpathEntryElement.getAttribute(""String_Node_Str""))) {
                    URI uri=URI.createURI(classpathEntryElement.getAttribute(""String_Node_Str"")).resolve(URI.createURI(classpathURL.toString()));
                    IWorkspace workspace=ResourcesPlugin.getWorkspace();
                    IProject project=workspace.getRoot().getProject(getProjectName());
                    if (!project.exists()) {
                      project.create(new NullProgressMonitor());
                    }
                    if (!project.isOpen()) {
                      project.open(new NullProgressMonitor());
                    }
                    IFolder folder=project.getFolder(""String_Node_Str"" + pluginID);
                    if (!folder.exists()) {
                      folder.createLink(new Path(CommonPlugin.asLocalURI(uri).toFileString()).removeTrailingSeparator(),IResource.ALLOW_MISSING_LOCAL,new NullProgressMonitor());
                    }
                    folder.refreshLocal(IResource.DEPTH_INFINITE,new NullProgressMonitor());
                    path=folder.getFullPath();
                    break;
                  }
                }
              }
            }
 catch (            Exception exception) {
              CodeGenPlugin.INSTANCE.log(exception);
            }
          }
        }
 else {
          path=new Path(Platform.asLocalURL(url).getFile());
        }
        if (path != null && !path.equals(JavaCore.getClasspathVariable(variableName))) {
          JavaCore.setClasspathVariable(variableName,path,null);
        }
      }
 catch (      MalformedURLException exception) {
        throw new JETException(exception);
      }
catch (      JavaModelException exception) {
        throw new JETException(exception);
      }
catch (      IOException exception) {
        throw new JETException(exception);
      }
      break;
    }
  }
 catch (  BundleException exception) {
    throw new JETException(exception);
  }
  IClasspathEntry entry=JavaCore.newVariableEntry(new Path(variableName),null,null);
  getClasspathEntries().add(entry);
}",0.9933593338252346
11922,"public static String readFile(File file){
  StringBuffer stringBuffer=new StringBuffer();
  try {
    BufferedReader in=new BufferedReader(new FileReader(file));
    String str=null;
    try {
      while ((str=in.readLine()) != null) {
        stringBuffer.append(str).append(""String_Node_Str"");
      }
    }
  finally {
      if (in != null) {
        in.close();
      }
    }
  }
 catch (  IOException exception) {
    throw new RuntimeException(exception);
  }
  int length=stringBuffer.length();
  if (length > 0) {
    stringBuffer.deleteCharAt(length - 1);
  }
  return stringBuffer.toString();
}","public static String readFile(File file,boolean useSystemLineSeparator){
  StringBuffer stringBuffer=new StringBuffer();
  try {
    BufferedReader in=new BufferedReader(new FileReader(file));
    String str=null;
    try {
      while ((str=in.readLine()) != null) {
        stringBuffer.append(str).append(useSystemLineSeparator ? System.getProperties().getProperty(""String_Node_Str"") : ""String_Node_Str"");
      }
    }
  finally {
      if (in != null) {
        in.close();
      }
    }
  }
 catch (  IOException exception) {
    throw new RuntimeException(exception);
  }
  int length=stringBuffer.length();
  if (length > 0) {
    stringBuffer.deleteCharAt(length - 1);
  }
  return stringBuffer.toString();
}",0.9152798789712556
11923,"private void assertGeneratedFile(File dir,File expectedDir,String file,String[] testTokenReplacements){
  File expectedFile=new File(expectedDir,file);
  File generatedFile=new File(dir,file);
  assertTrue(""String_Node_Str"" + expectedFile,expectedFile.isFile());
  assertTrue(""String_Node_Str"" + generatedFile,generatedFile.isFile());
  String expectedContent=TestUtil.readFile(expectedFile);
  if (testTokenReplacements != null) {
    for (int i=testTokenReplacements.length - 1; i >= 0; i--) {
      String replacement=testTokenReplacements[i];
      expectedContent=expectedContent.replaceAll(TEST_TOKEN + i,replacement.replaceAll(""String_Node_Str"",""String_Node_Str""));
    }
  }
  String generatedContent=TestUtil.readFile(generatedFile);
  expectedContent=expectedContent.replaceAll(""String_Node_Str"",""String_Node_Str"");
  generatedContent=generatedContent.replaceAll(""String_Node_Str"",""String_Node_Str"");
  assertEquals(""String_Node_Str"" + file,expectedContent,generatedContent);
}","private void assertGeneratedFile(File dir,File expectedDir,String file,String[] testTokenReplacements){
  File expectedFile=new File(expectedDir,file);
  File generatedFile=new File(dir,file);
  assertTrue(""String_Node_Str"" + expectedFile,expectedFile.isFile());
  assertTrue(""String_Node_Str"" + generatedFile,generatedFile.isFile());
  String expectedContent=TestUtil.readFile(expectedFile,true);
  if (testTokenReplacements != null) {
    for (int i=testTokenReplacements.length - 1; i >= 0; i--) {
      String replacement=testTokenReplacements[i];
      expectedContent=expectedContent.replaceAll(TEST_TOKEN + i,replacement.replaceAll(""String_Node_Str"",""String_Node_Str""));
    }
  }
  String generatedContent=TestUtil.readFile(generatedFile,true);
  expectedContent=expectedContent.replaceAll(""String_Node_Str"",""String_Node_Str"");
  generatedContent=generatedContent.replaceAll(""String_Node_Str"",""String_Node_Str"");
  assertEquals(""String_Node_Str"" + file,expectedContent,generatedContent);
}",0.9949596774193548
11924,"public void testRead(){
  String content=TestUtil.readFile(CLASS_FILE);
  ASTParser astParser=ASTParser.newParser(AST.JLS3);
  astParser.setSource(content.toCharArray());
  CompilationUnit compilationUnit=(CompilationUnit)astParser.createAST(null);
  PackageDeclaration packageDeclaration=compilationUnit.getPackage();
  assertNotNull(packageDeclaration);
  assertTrue(packageDeclaration.getName().isQualifiedName());
  assertEquals(""String_Node_Str"",packageDeclaration.getName().getFullyQualifiedName());
  List importDeclarations=compilationUnit.imports();
  assertEquals(5,importDeclarations.size());
  assertEquals(""String_Node_Str"",((ImportDeclaration)importDeclarations.get(0)).getName().getFullyQualifiedName());
  assertEquals(""String_Node_Str"",((ImportDeclaration)importDeclarations.get(1)).getName().getFullyQualifiedName());
  assertEquals(""String_Node_Str"",((ImportDeclaration)importDeclarations.get(2)).getName().getFullyQualifiedName());
  assertEquals(""String_Node_Str"",((ImportDeclaration)importDeclarations.get(3)).getName().getFullyQualifiedName());
  assertEquals(""String_Node_Str"",((ImportDeclaration)importDeclarations.get(4)).getName().getFullyQualifiedName());
  List typeDeclarations=(List)compilationUnit.types();
  assertEquals(2,typeDeclarations.size());
  TypeDeclaration exampleClass=(TypeDeclaration)typeDeclarations.get(1);
  assertEquals(""String_Node_Str"",exampleClass.getName().getFullyQualifiedName());
  assertFalse(exampleClass.isInterface());
{
    Javadoc typeJavadoc=exampleClass.getJavadoc();
    assertEquals(4,typeJavadoc.tags().size());
    TagElement[] tagElements=(TagElement[])typeJavadoc.tags().toArray(new TagElement[typeJavadoc.tags().size()]);
    assertNull(tagElements[0].getTagName());
    assertEquals(2,tagElements[0].fragments().size());
    assertEquals(""String_Node_Str"",((TextElement)tagElements[0].fragments().get(0)).getText());
    assertEquals(""String_Node_Str"",((TextElement)tagElements[0].fragments().get(1)).getText());
    assertEquals(""String_Node_Str"",tagElements[1].getTagName());
    assertEquals(1,tagElements[1].fragments().size());
    assertEquals(""String_Node_Str"",((TextElement)tagElements[1].fragments().get(0)).getText());
    assertEquals(""String_Node_Str"",tagElements[2].getTagName());
    assertTrue(tagElements[2].fragments().isEmpty());
    assertEquals(""String_Node_Str"",tagElements[3].getTagName());
    assertEquals(1,tagElements[3].fragments().size());
    assertEquals(""String_Node_Str"",((TextElement)tagElements[3].fragments().get(0)).getText());
  }
  assertTrue(exampleClass.getSuperclassType().isSimpleType());
  assertEquals(""String_Node_Str"",((SimpleType)exampleClass.getSuperclassType()).getName().getFullyQualifiedName());
  assertTrue(exampleClass.superInterfaceTypes().isEmpty());
  assertEquals(Modifier.PUBLIC,exampleClass.getModifiers());
  assertEquals(12,exampleClass.bodyDeclarations().size());
  assertEquals(2,exampleClass.getTypes().length);
  assertEquals(5,exampleClass.getFields().length);
  assertEquals(5,exampleClass.getMethods().length);
  TypeDeclaration innerClass=exampleClass.getTypes()[0];
  assertFalse(innerClass.isInterface());
  assertTrue(innerClass.bodyDeclarations().isEmpty());
  assertEquals(Modifier.PUBLIC | Modifier.ABSTRACT,innerClass.getModifiers());
  assertNull(innerClass.getSuperclassType());
  assertEquals(2,innerClass.superInterfaceTypes().size());
  assertTrue(((Type)innerClass.superInterfaceTypes().get(0)).isSimpleType());
  assertEquals(""String_Node_Str"",((SimpleType)innerClass.superInterfaceTypes().get(0)).getName().getFullyQualifiedName());
  assertTrue(((Type)innerClass.superInterfaceTypes().get(1)).isSimpleType());
  assertEquals(""String_Node_Str"",((SimpleType)innerClass.superInterfaceTypes().get(1)).getName().getFullyQualifiedName());
  assertNull(innerClass.getJavadoc());
  TypeDeclaration innerInterface=exampleClass.getTypes()[1];
  assertTrue(innerInterface.isInterface());
  assertTrue(innerInterface.bodyDeclarations().isEmpty());
  assertEquals(Modifier.PRIVATE | Modifier.STATIC,innerInterface.getModifiers());
  assertNull(innerInterface.getSuperclassType());
  assertEquals(1,innerInterface.superInterfaceTypes().size());
  assertTrue(((Type)innerInterface.superInterfaceTypes().get(0)).isSimpleType());
  assertEquals(""String_Node_Str"",((SimpleType)innerInterface.superInterfaceTypes().get(0)).getName().getFullyQualifiedName());
  assertNull(innerClass.getJavadoc());
  FieldDeclaration[] fieldDeclarations=exampleClass.getFields();
{
    Javadoc javadoc=fieldDeclarations[0].getJavadoc();
    assertEquals(1,javadoc.tags().size());
    assertEquals(1,((TagElement)javadoc.tags().get(0)).fragments().size());
    assertEquals(""String_Node_Str"",((TextElement)((TagElement)javadoc.tags().get(0)).fragments().get(0)).getText());
    assertEquals(Modifier.PUBLIC | Modifier.STATIC | Modifier.FINAL,fieldDeclarations[0].getModifiers());
    assertTrue(fieldDeclarations[0].getType().isSimpleType());
    assertEquals(""String_Node_Str"",((SimpleType)fieldDeclarations[0].getType()).getName().getFullyQualifiedName());
    assertEquals(1,fieldDeclarations[0].fragments().size());
    VariableDeclarationFragment[] variableDeclarationFragments=(VariableDeclarationFragment[])fieldDeclarations[0].fragments().toArray(new VariableDeclarationFragment[fieldDeclarations[0].fragments().size()]);
    assertEquals(0,variableDeclarationFragments[0].getExtraDimensions());
    assertEquals(""String_Node_Str"",variableDeclarationFragments[0].getName().getFullyQualifiedName());
    assertNotNull(variableDeclarationFragments[0].getInitializer());
    assertTrue(variableDeclarationFragments[0].getInitializer() instanceof StringLiteral);
    assertEquals(""String_Node_Str"",((StringLiteral)variableDeclarationFragments[0].getInitializer()).getLiteralValue());
  }
{
    Javadoc javadoc=fieldDeclarations[1].getJavadoc();
    assertEquals(1,javadoc.tags().size());
    assertEquals(2,((TagElement)javadoc.tags().get(0)).fragments().size());
    assertEquals(""String_Node_Str"",((TextElement)((TagElement)javadoc.tags().get(0)).fragments().get(0)).getText());
    assertEquals(""String_Node_Str"",((TextElement)((TagElement)javadoc.tags().get(0)).fragments().get(1)).getText());
    assertEquals(Modifier.PROTECTED | Modifier.STATIC,fieldDeclarations[1].getModifiers());
    assertTrue(fieldDeclarations[1].getType().isPrimitiveType());
    assertEquals(PrimitiveType.LONG,((PrimitiveType)fieldDeclarations[1].getType()).getPrimitiveTypeCode());
    assertEquals(1,fieldDeclarations[1].fragments().size());
    VariableDeclarationFragment[] variableDeclarationFragments=(VariableDeclarationFragment[])fieldDeclarations[1].fragments().toArray(new VariableDeclarationFragment[fieldDeclarations[1].fragments().size()]);
    assertEquals(0,variableDeclarationFragments[0].getExtraDimensions());
    assertEquals(""String_Node_Str"",variableDeclarationFragments[0].getName().getFullyQualifiedName());
    assertNotNull(variableDeclarationFragments[0].getInitializer());
    assertTrue(variableDeclarationFragments[0].getInitializer() instanceof NumberLiteral);
    assertEquals(""String_Node_Str"",((NumberLiteral)variableDeclarationFragments[0].getInitializer()).getToken());
  }
{
    assertNull(fieldDeclarations[2].getJavadoc());
    assertEquals(0,fieldDeclarations[2].getModifiers());
    assertTrue(fieldDeclarations[2].getType().isSimpleType());
    assertEquals(""String_Node_Str"",((SimpleType)fieldDeclarations[2].getType()).getName().getFullyQualifiedName());
    assertEquals(1,fieldDeclarations[2].fragments().size());
    VariableDeclarationFragment[] variableDeclarationFragments=(VariableDeclarationFragment[])fieldDeclarations[2].fragments().toArray(new VariableDeclarationFragment[fieldDeclarations[2].fragments().size()]);
    assertEquals(0,variableDeclarationFragments[0].getExtraDimensions());
    assertEquals(""String_Node_Str"",variableDeclarationFragments[0].getName().getFullyQualifiedName());
    assertNull(variableDeclarationFragments[0].getInitializer());
  }
{
    assertNull(fieldDeclarations[3].getJavadoc());
    assertEquals(Modifier.PRIVATE,fieldDeclarations[3].getModifiers());
    assertTrue(fieldDeclarations[3].getType().isSimpleType());
    assertEquals(""String_Node_Str"",((SimpleType)fieldDeclarations[3].getType()).getName().getFullyQualifiedName());
    assertEquals(1,fieldDeclarations[3].fragments().size());
    VariableDeclarationFragment[] variableDeclarationFragments=(VariableDeclarationFragment[])fieldDeclarations[3].fragments().toArray(new VariableDeclarationFragment[fieldDeclarations[3].fragments().size()]);
    assertEquals(0,variableDeclarationFragments[0].getExtraDimensions());
    assertEquals(""String_Node_Str"",variableDeclarationFragments[0].getName().getFullyQualifiedName());
    assertNull(variableDeclarationFragments[0].getInitializer());
  }
{
    assertNull(fieldDeclarations[4].getJavadoc());
    assertEquals(Modifier.PRIVATE,fieldDeclarations[4].getModifiers());
    assertTrue(fieldDeclarations[4].getType().isArrayType());
    assertEquals(2,((ArrayType)fieldDeclarations[4].getType()).getDimensions());
    assertTrue(((ArrayType)fieldDeclarations[4].getType()).getElementType().isPrimitiveType());
    assertEquals(PrimitiveType.INT,((PrimitiveType)((ArrayType)fieldDeclarations[4].getType()).getElementType()).getPrimitiveTypeCode());
    assertEquals(1,fieldDeclarations[4].fragments().size());
    VariableDeclarationFragment[] variableDeclarationFragments=(VariableDeclarationFragment[])fieldDeclarations[4].fragments().toArray(new VariableDeclarationFragment[fieldDeclarations[4].fragments().size()]);
    assertEquals(0,variableDeclarationFragments[0].getExtraDimensions());
    assertEquals(""String_Node_Str"",variableDeclarationFragments[0].getName().getFullyQualifiedName());
    assertNotNull(variableDeclarationFragments[0].getInitializer());
    assertTrue(variableDeclarationFragments[0].getInitializer() instanceof ArrayCreation);
    ArrayCreation arrayCreation=(ArrayCreation)variableDeclarationFragments[0].getInitializer();
    assertEquals(2,arrayCreation.dimensions().size());
    assertEquals(""String_Node_Str"",((NumberLiteral)arrayCreation.dimensions().get(0)).getToken());
    assertEquals(""String_Node_Str"",((NumberLiteral)arrayCreation.dimensions().get(1)).getToken());
  }
  MethodDeclaration[] methodDeclarations=exampleClass.getMethods();
{
    Javadoc javadoc=methodDeclarations[0].getJavadoc();
    assertEquals(1,javadoc.tags().size());
    assertEquals(1,((TagElement)javadoc.tags().get(0)).fragments().size());
    assertEquals(""String_Node_Str"",((TextElement)((TagElement)javadoc.tags().get(0)).fragments().get(0)).getText());
    assertTrue(methodDeclarations[0].isConstructor());
    assertEquals(Modifier.PUBLIC,methodDeclarations[0].getModifiers());
    assertNull(methodDeclarations[0].getReturnType2());
    assertEquals(""String_Node_Str"",methodDeclarations[0].getName().getFullyQualifiedName());
    assertTrue(methodDeclarations[0].parameters().isEmpty());
    assertNotNull(methodDeclarations[0].getBody());
    assertEquals(1,methodDeclarations[0].getBody().statements().size());
    Statement statement=(Statement)methodDeclarations[0].getBody().statements().get(0);
    assertEquals(ASTNode.SUPER_CONSTRUCTOR_INVOCATION,statement.getNodeType());
    assertTrue(((SuperConstructorInvocation)statement).arguments().isEmpty());
  }
{
    Javadoc javadoc=methodDeclarations[1].getJavadoc();
    assertEquals(3,javadoc.tags().size());
    assertNull(((TagElement)javadoc.tags().get(0)).getTagName());
    assertEquals(1,((TagElement)javadoc.tags().get(0)).fragments().size());
    assertEquals(""String_Node_Str"",((TextElement)((TagElement)javadoc.tags().get(0)).fragments().get(0)).getText());
    assertEquals(""String_Node_Str"",((TagElement)javadoc.tags().get(1)).getTagName());
    assertEquals(1,((TagElement)javadoc.tags().get(0)).fragments().size());
    assertEquals(""String_Node_Str"",((SimpleName)((TagElement)javadoc.tags().get(1)).fragments().get(0)).getFullyQualifiedName());
    assertEquals(""String_Node_Str"",((TagElement)javadoc.tags().get(2)).getTagName());
    assertTrue(((TagElement)javadoc.tags().get(2)).fragments().isEmpty());
    assertFalse(methodDeclarations[1].isConstructor());
    assertEquals(Modifier.PUBLIC,methodDeclarations[1].getModifiers());
    assertNotNull(methodDeclarations[1].getReturnType2());
    assertTrue(methodDeclarations[1].getReturnType2().isPrimitiveType());
    assertEquals(PrimitiveType.VOID,((PrimitiveType)methodDeclarations[1].getReturnType2()).getPrimitiveTypeCode());
    assertEquals(""String_Node_Str"",methodDeclarations[1].getName().getFullyQualifiedName());
    assertEquals(1,methodDeclarations[1].parameters().size());
    assertTrue(((SingleVariableDeclaration)methodDeclarations[1].parameters().get(0)).getType().isSimpleType());
    assertEquals(""String_Node_Str"",((SimpleType)((SingleVariableDeclaration)methodDeclarations[1].parameters().get(0)).getType()).getName().getFullyQualifiedName());
    assertEquals(""String_Node_Str"",((SingleVariableDeclaration)methodDeclarations[1].parameters().get(0)).getName().getFullyQualifiedName());
    assertNotNull(methodDeclarations[1].getBody());
    assertEquals(1,methodDeclarations[1].getBody().statements().size());
  }
}","public void testRead(){
  String content=TestUtil.readFile(CLASS_FILE,false);
  ASTParser astParser=ASTParser.newParser(AST.JLS3);
  astParser.setSource(content.toCharArray());
  CompilationUnit compilationUnit=(CompilationUnit)astParser.createAST(null);
  PackageDeclaration packageDeclaration=compilationUnit.getPackage();
  assertNotNull(packageDeclaration);
  assertTrue(packageDeclaration.getName().isQualifiedName());
  assertEquals(""String_Node_Str"",packageDeclaration.getName().getFullyQualifiedName());
  List importDeclarations=compilationUnit.imports();
  assertEquals(5,importDeclarations.size());
  assertEquals(""String_Node_Str"",((ImportDeclaration)importDeclarations.get(0)).getName().getFullyQualifiedName());
  assertEquals(""String_Node_Str"",((ImportDeclaration)importDeclarations.get(1)).getName().getFullyQualifiedName());
  assertEquals(""String_Node_Str"",((ImportDeclaration)importDeclarations.get(2)).getName().getFullyQualifiedName());
  assertEquals(""String_Node_Str"",((ImportDeclaration)importDeclarations.get(3)).getName().getFullyQualifiedName());
  assertEquals(""String_Node_Str"",((ImportDeclaration)importDeclarations.get(4)).getName().getFullyQualifiedName());
  List typeDeclarations=(List)compilationUnit.types();
  assertEquals(2,typeDeclarations.size());
  TypeDeclaration exampleClass=(TypeDeclaration)typeDeclarations.get(1);
  assertEquals(""String_Node_Str"",exampleClass.getName().getFullyQualifiedName());
  assertFalse(exampleClass.isInterface());
{
    Javadoc typeJavadoc=exampleClass.getJavadoc();
    assertEquals(4,typeJavadoc.tags().size());
    TagElement[] tagElements=(TagElement[])typeJavadoc.tags().toArray(new TagElement[typeJavadoc.tags().size()]);
    assertNull(tagElements[0].getTagName());
    assertEquals(2,tagElements[0].fragments().size());
    assertEquals(""String_Node_Str"",((TextElement)tagElements[0].fragments().get(0)).getText());
    assertEquals(""String_Node_Str"",((TextElement)tagElements[0].fragments().get(1)).getText());
    assertEquals(""String_Node_Str"",tagElements[1].getTagName());
    assertEquals(1,tagElements[1].fragments().size());
    assertEquals(""String_Node_Str"",((TextElement)tagElements[1].fragments().get(0)).getText());
    assertEquals(""String_Node_Str"",tagElements[2].getTagName());
    assertTrue(tagElements[2].fragments().isEmpty());
    assertEquals(""String_Node_Str"",tagElements[3].getTagName());
    assertEquals(1,tagElements[3].fragments().size());
    assertEquals(""String_Node_Str"",((TextElement)tagElements[3].fragments().get(0)).getText());
  }
  assertTrue(exampleClass.getSuperclassType().isSimpleType());
  assertEquals(""String_Node_Str"",((SimpleType)exampleClass.getSuperclassType()).getName().getFullyQualifiedName());
  assertTrue(exampleClass.superInterfaceTypes().isEmpty());
  assertEquals(Modifier.PUBLIC,exampleClass.getModifiers());
  assertEquals(12,exampleClass.bodyDeclarations().size());
  assertEquals(2,exampleClass.getTypes().length);
  assertEquals(5,exampleClass.getFields().length);
  assertEquals(5,exampleClass.getMethods().length);
  TypeDeclaration innerClass=exampleClass.getTypes()[0];
  assertFalse(innerClass.isInterface());
  assertTrue(innerClass.bodyDeclarations().isEmpty());
  assertEquals(Modifier.PUBLIC | Modifier.ABSTRACT,innerClass.getModifiers());
  assertNull(innerClass.getSuperclassType());
  assertEquals(2,innerClass.superInterfaceTypes().size());
  assertTrue(((Type)innerClass.superInterfaceTypes().get(0)).isSimpleType());
  assertEquals(""String_Node_Str"",((SimpleType)innerClass.superInterfaceTypes().get(0)).getName().getFullyQualifiedName());
  assertTrue(((Type)innerClass.superInterfaceTypes().get(1)).isSimpleType());
  assertEquals(""String_Node_Str"",((SimpleType)innerClass.superInterfaceTypes().get(1)).getName().getFullyQualifiedName());
  assertNull(innerClass.getJavadoc());
  TypeDeclaration innerInterface=exampleClass.getTypes()[1];
  assertTrue(innerInterface.isInterface());
  assertTrue(innerInterface.bodyDeclarations().isEmpty());
  assertEquals(Modifier.PRIVATE | Modifier.STATIC,innerInterface.getModifiers());
  assertNull(innerInterface.getSuperclassType());
  assertEquals(1,innerInterface.superInterfaceTypes().size());
  assertTrue(((Type)innerInterface.superInterfaceTypes().get(0)).isSimpleType());
  assertEquals(""String_Node_Str"",((SimpleType)innerInterface.superInterfaceTypes().get(0)).getName().getFullyQualifiedName());
  assertNull(innerClass.getJavadoc());
  FieldDeclaration[] fieldDeclarations=exampleClass.getFields();
{
    Javadoc javadoc=fieldDeclarations[0].getJavadoc();
    assertEquals(1,javadoc.tags().size());
    assertEquals(1,((TagElement)javadoc.tags().get(0)).fragments().size());
    assertEquals(""String_Node_Str"",((TextElement)((TagElement)javadoc.tags().get(0)).fragments().get(0)).getText());
    assertEquals(Modifier.PUBLIC | Modifier.STATIC | Modifier.FINAL,fieldDeclarations[0].getModifiers());
    assertTrue(fieldDeclarations[0].getType().isSimpleType());
    assertEquals(""String_Node_Str"",((SimpleType)fieldDeclarations[0].getType()).getName().getFullyQualifiedName());
    assertEquals(1,fieldDeclarations[0].fragments().size());
    VariableDeclarationFragment[] variableDeclarationFragments=(VariableDeclarationFragment[])fieldDeclarations[0].fragments().toArray(new VariableDeclarationFragment[fieldDeclarations[0].fragments().size()]);
    assertEquals(0,variableDeclarationFragments[0].getExtraDimensions());
    assertEquals(""String_Node_Str"",variableDeclarationFragments[0].getName().getFullyQualifiedName());
    assertNotNull(variableDeclarationFragments[0].getInitializer());
    assertTrue(variableDeclarationFragments[0].getInitializer() instanceof StringLiteral);
    assertEquals(""String_Node_Str"",((StringLiteral)variableDeclarationFragments[0].getInitializer()).getLiteralValue());
  }
{
    Javadoc javadoc=fieldDeclarations[1].getJavadoc();
    assertEquals(1,javadoc.tags().size());
    assertEquals(2,((TagElement)javadoc.tags().get(0)).fragments().size());
    assertEquals(""String_Node_Str"",((TextElement)((TagElement)javadoc.tags().get(0)).fragments().get(0)).getText());
    assertEquals(""String_Node_Str"",((TextElement)((TagElement)javadoc.tags().get(0)).fragments().get(1)).getText());
    assertEquals(Modifier.PROTECTED | Modifier.STATIC,fieldDeclarations[1].getModifiers());
    assertTrue(fieldDeclarations[1].getType().isPrimitiveType());
    assertEquals(PrimitiveType.LONG,((PrimitiveType)fieldDeclarations[1].getType()).getPrimitiveTypeCode());
    assertEquals(1,fieldDeclarations[1].fragments().size());
    VariableDeclarationFragment[] variableDeclarationFragments=(VariableDeclarationFragment[])fieldDeclarations[1].fragments().toArray(new VariableDeclarationFragment[fieldDeclarations[1].fragments().size()]);
    assertEquals(0,variableDeclarationFragments[0].getExtraDimensions());
    assertEquals(""String_Node_Str"",variableDeclarationFragments[0].getName().getFullyQualifiedName());
    assertNotNull(variableDeclarationFragments[0].getInitializer());
    assertTrue(variableDeclarationFragments[0].getInitializer() instanceof NumberLiteral);
    assertEquals(""String_Node_Str"",((NumberLiteral)variableDeclarationFragments[0].getInitializer()).getToken());
  }
{
    assertNull(fieldDeclarations[2].getJavadoc());
    assertEquals(0,fieldDeclarations[2].getModifiers());
    assertTrue(fieldDeclarations[2].getType().isSimpleType());
    assertEquals(""String_Node_Str"",((SimpleType)fieldDeclarations[2].getType()).getName().getFullyQualifiedName());
    assertEquals(1,fieldDeclarations[2].fragments().size());
    VariableDeclarationFragment[] variableDeclarationFragments=(VariableDeclarationFragment[])fieldDeclarations[2].fragments().toArray(new VariableDeclarationFragment[fieldDeclarations[2].fragments().size()]);
    assertEquals(0,variableDeclarationFragments[0].getExtraDimensions());
    assertEquals(""String_Node_Str"",variableDeclarationFragments[0].getName().getFullyQualifiedName());
    assertNull(variableDeclarationFragments[0].getInitializer());
  }
{
    assertNull(fieldDeclarations[3].getJavadoc());
    assertEquals(Modifier.PRIVATE,fieldDeclarations[3].getModifiers());
    assertTrue(fieldDeclarations[3].getType().isSimpleType());
    assertEquals(""String_Node_Str"",((SimpleType)fieldDeclarations[3].getType()).getName().getFullyQualifiedName());
    assertEquals(1,fieldDeclarations[3].fragments().size());
    VariableDeclarationFragment[] variableDeclarationFragments=(VariableDeclarationFragment[])fieldDeclarations[3].fragments().toArray(new VariableDeclarationFragment[fieldDeclarations[3].fragments().size()]);
    assertEquals(0,variableDeclarationFragments[0].getExtraDimensions());
    assertEquals(""String_Node_Str"",variableDeclarationFragments[0].getName().getFullyQualifiedName());
    assertNull(variableDeclarationFragments[0].getInitializer());
  }
{
    assertNull(fieldDeclarations[4].getJavadoc());
    assertEquals(Modifier.PRIVATE,fieldDeclarations[4].getModifiers());
    assertTrue(fieldDeclarations[4].getType().isArrayType());
    assertEquals(2,((ArrayType)fieldDeclarations[4].getType()).getDimensions());
    assertTrue(((ArrayType)fieldDeclarations[4].getType()).getElementType().isPrimitiveType());
    assertEquals(PrimitiveType.INT,((PrimitiveType)((ArrayType)fieldDeclarations[4].getType()).getElementType()).getPrimitiveTypeCode());
    assertEquals(1,fieldDeclarations[4].fragments().size());
    VariableDeclarationFragment[] variableDeclarationFragments=(VariableDeclarationFragment[])fieldDeclarations[4].fragments().toArray(new VariableDeclarationFragment[fieldDeclarations[4].fragments().size()]);
    assertEquals(0,variableDeclarationFragments[0].getExtraDimensions());
    assertEquals(""String_Node_Str"",variableDeclarationFragments[0].getName().getFullyQualifiedName());
    assertNotNull(variableDeclarationFragments[0].getInitializer());
    assertTrue(variableDeclarationFragments[0].getInitializer() instanceof ArrayCreation);
    ArrayCreation arrayCreation=(ArrayCreation)variableDeclarationFragments[0].getInitializer();
    assertEquals(2,arrayCreation.dimensions().size());
    assertEquals(""String_Node_Str"",((NumberLiteral)arrayCreation.dimensions().get(0)).getToken());
    assertEquals(""String_Node_Str"",((NumberLiteral)arrayCreation.dimensions().get(1)).getToken());
  }
  MethodDeclaration[] methodDeclarations=exampleClass.getMethods();
{
    Javadoc javadoc=methodDeclarations[0].getJavadoc();
    assertEquals(1,javadoc.tags().size());
    assertEquals(1,((TagElement)javadoc.tags().get(0)).fragments().size());
    assertEquals(""String_Node_Str"",((TextElement)((TagElement)javadoc.tags().get(0)).fragments().get(0)).getText());
    assertTrue(methodDeclarations[0].isConstructor());
    assertEquals(Modifier.PUBLIC,methodDeclarations[0].getModifiers());
    assertNull(methodDeclarations[0].getReturnType2());
    assertEquals(""String_Node_Str"",methodDeclarations[0].getName().getFullyQualifiedName());
    assertTrue(methodDeclarations[0].parameters().isEmpty());
    assertNotNull(methodDeclarations[0].getBody());
    assertEquals(1,methodDeclarations[0].getBody().statements().size());
    Statement statement=(Statement)methodDeclarations[0].getBody().statements().get(0);
    assertEquals(ASTNode.SUPER_CONSTRUCTOR_INVOCATION,statement.getNodeType());
    assertTrue(((SuperConstructorInvocation)statement).arguments().isEmpty());
  }
{
    Javadoc javadoc=methodDeclarations[1].getJavadoc();
    assertEquals(3,javadoc.tags().size());
    assertNull(((TagElement)javadoc.tags().get(0)).getTagName());
    assertEquals(1,((TagElement)javadoc.tags().get(0)).fragments().size());
    assertEquals(""String_Node_Str"",((TextElement)((TagElement)javadoc.tags().get(0)).fragments().get(0)).getText());
    assertEquals(""String_Node_Str"",((TagElement)javadoc.tags().get(1)).getTagName());
    assertEquals(1,((TagElement)javadoc.tags().get(0)).fragments().size());
    assertEquals(""String_Node_Str"",((SimpleName)((TagElement)javadoc.tags().get(1)).fragments().get(0)).getFullyQualifiedName());
    assertEquals(""String_Node_Str"",((TagElement)javadoc.tags().get(2)).getTagName());
    assertTrue(((TagElement)javadoc.tags().get(2)).fragments().isEmpty());
    assertFalse(methodDeclarations[1].isConstructor());
    assertEquals(Modifier.PUBLIC,methodDeclarations[1].getModifiers());
    assertNotNull(methodDeclarations[1].getReturnType2());
    assertTrue(methodDeclarations[1].getReturnType2().isPrimitiveType());
    assertEquals(PrimitiveType.VOID,((PrimitiveType)methodDeclarations[1].getReturnType2()).getPrimitiveTypeCode());
    assertEquals(""String_Node_Str"",methodDeclarations[1].getName().getFullyQualifiedName());
    assertEquals(1,methodDeclarations[1].parameters().size());
    assertTrue(((SingleVariableDeclaration)methodDeclarations[1].parameters().get(0)).getType().isSimpleType());
    assertEquals(""String_Node_Str"",((SimpleType)((SingleVariableDeclaration)methodDeclarations[1].parameters().get(0)).getType()).getName().getFullyQualifiedName());
    assertEquals(""String_Node_Str"",((SingleVariableDeclaration)methodDeclarations[1].parameters().get(0)).getName().getFullyQualifiedName());
    assertNotNull(methodDeclarations[1].getBody());
    assertEquals(1,methodDeclarations[1].getBody().statements().size());
  }
}",0.99977421539851
11925,"public void testMerge() throws Exception {
  assertTrue(""String_Node_Str"" + MERGE_XML.getAbsolutePath(),MERGE_XML.isFile());
  assertTrue(""String_Node_Str"" + MERGE_SOURCE.getAbsolutePath(),MERGE_SOURCE.isFile());
  assertTrue(""String_Node_Str"" + MERGE_TARGET.getAbsolutePath(),MERGE_TARGET.isFile());
  assertTrue(""String_Node_Str"" + MERGE_EXPECTED.getAbsolutePath(),MERGE_TARGET.isFile());
  jMerger=new JMerger();
  JControlModel controlModel=new JControlModel(MERGE_XML.getAbsolutePath());
  jMerger.setControlModel(controlModel);
  jMerger.setSourceCompilationUnit(jMerger.createCompilationUnitForContents(TestUtil.readFile(MERGE_SOURCE)));
  jMerger.setTargetCompilationUnit(jMerger.createCompilationUnitForInputStream(new FileInputStream(MERGE_TARGET)));
  jMerger.merge();
  StringBuffer mergeResult=new StringBuffer(jMerger.getTargetCompilationUnitContents());
  for (int i=mergeResult.length() - 1; i >= 0; i--) {
    if ('\r' == mergeResult.charAt(i)) {
      mergeResult.deleteCharAt(i);
    }
  }
  String expectedMerge=TestUtil.readFile(MERGE_EXPECTED);
  assertEquals(""String_Node_Str"",expectedMerge,mergeResult.toString());
}","public void testMerge() throws Exception {
  assertTrue(""String_Node_Str"" + MERGE_XML.getAbsolutePath(),MERGE_XML.isFile());
  assertTrue(""String_Node_Str"" + MERGE_SOURCE.getAbsolutePath(),MERGE_SOURCE.isFile());
  assertTrue(""String_Node_Str"" + MERGE_TARGET.getAbsolutePath(),MERGE_TARGET.isFile());
  assertTrue(""String_Node_Str"" + MERGE_EXPECTED.getAbsolutePath(),MERGE_TARGET.isFile());
  jMerger=new JMerger();
  JControlModel controlModel=new JControlModel(MERGE_XML.getAbsolutePath());
  jMerger.setControlModel(controlModel);
  jMerger.setSourceCompilationUnit(jMerger.createCompilationUnitForContents(TestUtil.readFile(MERGE_SOURCE,false)));
  jMerger.setTargetCompilationUnit(jMerger.createCompilationUnitForInputStream(new FileInputStream(MERGE_TARGET)));
  jMerger.merge();
  StringBuffer mergeResult=new StringBuffer(jMerger.getTargetCompilationUnitContents());
  for (int i=mergeResult.length() - 1; i >= 0; i--) {
    if ('\r' == mergeResult.charAt(i)) {
      mergeResult.deleteCharAt(i);
    }
  }
  String expectedMerge=TestUtil.readFile(MERGE_EXPECTED,false);
  assertEquals(""String_Node_Str"",expectedMerge,mergeResult.toString());
}",0.9947643979057592
11926,"public static String readFile(File file,boolean useSystemLineSeparator){
  StringBuffer stringBuffer=new StringBuffer();
  try {
    BufferedReader in=new BufferedReader(new FileReader(file));
    String str=null;
    try {
      while ((str=in.readLine()) != null) {
        stringBuffer.append(str).append(useSystemLineSeparator ? System.getProperties().getProperty(""String_Node_Str"") : ""String_Node_Str"");
      }
    }
  finally {
      if (in != null) {
        in.close();
      }
    }
  }
 catch (  IOException exception) {
    throw new RuntimeException(exception);
  }
  int length=stringBuffer.length();
  if (length > 0) {
    stringBuffer.deleteCharAt(length - 1);
  }
  return stringBuffer.toString();
}","public static String readFile(File file,boolean useSystemLineSeparator){
  StringBuffer stringBuffer=new StringBuffer();
  try {
    BufferedReader in=new BufferedReader(new FileReader(file));
    String str=null;
    try {
      String nl=useSystemLineSeparator ? System.getProperties().getProperty(""String_Node_Str"") : ""String_Node_Str"";
      while ((str=in.readLine()) != null) {
        stringBuffer.append(str).append(nl);
      }
    }
  finally {
      if (in != null) {
        in.close();
      }
    }
  }
 catch (  IOException exception) {
    throw new RuntimeException(exception);
  }
  int length=stringBuffer.length();
  if (length > 0) {
    stringBuffer.deleteCharAt(length - 1);
  }
  return stringBuffer.toString();
}",0.8514442916093535
11927,"private void assertGeneratedFile(File dir,File expectedDir,String file,String[] testTokenReplacements){
  File expectedFile=new File(expectedDir,file);
  File generatedFile=new File(dir,file);
  assertTrue(""String_Node_Str"" + expectedFile,expectedFile.isFile());
  assertTrue(""String_Node_Str"" + generatedFile,generatedFile.isFile());
  String expectedContent=TestUtil.readFile(expectedFile,true);
  if (testTokenReplacements != null) {
    for (int i=testTokenReplacements.length - 1; i >= 0; i--) {
      String replacement=testTokenReplacements[i];
      expectedContent=expectedContent.replaceAll(TEST_TOKEN + i,replacement.replaceAll(""String_Node_Str"",""String_Node_Str""));
    }
  }
  String generatedContent=TestUtil.readFile(generatedFile,true);
  expectedContent=expectedContent.replaceAll(""String_Node_Str"",""String_Node_Str"");
  generatedContent=generatedContent.replaceAll(""String_Node_Str"",""String_Node_Str"");
  assertEquals(""String_Node_Str"" + file,expectedContent,generatedContent);
}","private void assertGeneratedFile(File dir,File expectedDir,String file,String[] testTokenReplacements){
  File expectedFile=new File(expectedDir,file);
  File generatedFile=new File(dir,file);
  assertTrue(""String_Node_Str"" + expectedFile,expectedFile.isFile());
  assertTrue(""String_Node_Str"" + generatedFile,generatedFile.isFile());
  String expectedContent=TestUtil.readFile(expectedFile,true);
  if (testTokenReplacements != null) {
    for (int i=testTokenReplacements.length - 1; i >= 0; i--) {
      String replacement=testTokenReplacements[i];
      expectedContent=expectedContent.replaceAll(TEST_TOKEN + i,replacement.replaceAll(""String_Node_Str"",""String_Node_Str""));
    }
  }
  String generatedContent=TestUtil.readFile(generatedFile,true);
  expectedContent=expectedContent.replaceAll(""String_Node_Str"",""String_Node_Str"");
  generatedContent=generatedContent.replaceAll(""String_Node_Str"",""String_Node_Str"");
  expectedContent=expectedContent.replaceAll(""String_Node_Str"",""String_Node_Str"").replaceAll(""String_Node_Str"",""String_Node_Str"");
  generatedContent=generatedContent.replaceAll(""String_Node_Str"",""String_Node_Str"").replaceAll(""String_Node_Str"",""String_Node_Str"");
  assertEquals(""String_Node_Str"" + file,expectedContent,generatedContent);
}",0.8830823737821081
11928,"public EObject getContainer(Node node){
  short type=node.getNodeType();
switch (type) {
case Node.ELEMENT_NODE:
    return (EObject)nodeToContainer.get(node);
case Node.TEXT_NODE:
case Node.CDATA_SECTION_NODE:
  return (EObject)nodeToContainer.get(node.getParentNode());
case Node.ATTRIBUTE_NODE:
return (EObject)nodeToEObject.get(((Attr)node).getOwnerElement());
default :
return null;
}
}","public EObject getContainer(Node node){
  short type=node.getNodeType();
switch (type) {
case Node.ELEMENT_NODE:
{
      Object o=nodeToObject.get(node);
      if (o != null && o instanceof EObject) {
        return ((EObject)o).eContainer();
      }
      return (EObject)nodeToObject.get(node.getParentNode());
    }
case Node.TEXT_NODE:
case Node.CDATA_SECTION_NODE:
{
    Object o=nodeToContainer.get(node);
    if (o != null) {
      return (EObject)o;
    }
    return (EObject)nodeToObject.get(node.getParentNode().getParentNode());
  }
case Node.ATTRIBUTE_NODE:
return (EObject)nodeToObject.get(((Attr)node).getOwnerElement());
default :
return null;
}
}",0.6324786324786325
11929,"public EStructuralFeature getEStructuralFeature(Node node){
  short type=node.getNodeType();
switch (type) {
case Node.ELEMENT_NODE:
    return (EStructuralFeature)nodeToFeature.get(node);
case Node.TEXT_NODE:
case Node.CDATA_SECTION_NODE:
  return (EStructuralFeature)nodeToFeature.get(node.getParentNode());
case Node.ATTRIBUTE_NODE:
{
  EObject obj=(EObject)nodeToEObject.get(((Attr)node).getOwnerElement());
  if (extendedMetaData == null) {
    return obj.eClass().getEStructuralFeature(node.getLocalName());
  }
 else {
    return extendedMetaData.getAttribute(obj.eClass(),node.getNamespaceURI(),node.getLocalName());
  }
}
default :
return null;
}
}","public EStructuralFeature getEStructuralFeature(Node node){
  short type=node.getNodeType();
switch (type) {
case Node.ELEMENT_NODE:
    return (EStructuralFeature)nodeToFeature.get(node);
case Node.ATTRIBUTE_NODE:
{
    EObject obj=(EObject)nodeToObject.get(((Attr)node).getOwnerElement());
    if (extendedMetaData == null) {
      return obj.eClass().getEStructuralFeature(node.getLocalName());
    }
 else     if (obj != null) {
      return extendedMetaData.getAttribute(obj.eClass(),node.getNamespaceURI(),node.getLocalName());
    }
  }
case Node.TEXT_NODE:
case Node.CDATA_SECTION_NODE:
{
  EStructuralFeature feature=(EStructuralFeature)nodeToFeature.get(node);
  if (feature == null) {
    feature=(EStructuralFeature)nodeToFeature.get(node.getParentNode());
  }
  return feature;
}
default :
return null;
}
}",0.7222222222222222
11930,"protected boolean saveFeatures(EObject o){
  EClass eClass=o.eClass();
  int contentKind=extendedMetaData == null ? ExtendedMetaData.UNSPECIFIED_CONTENT : extendedMetaData.getContentKind(eClass);
  if (!toDOM) {
switch (contentKind) {
case ExtendedMetaData.MIXED_CONTENT:
case ExtendedMetaData.SIMPLE_CONTENT:
{
        doc.setMixed(true);
        break;
      }
  }
}
EStructuralFeature[] features=featureTable.getFeatures(eClass);
int[] featureKinds=featureTable.getKinds(eClass,features);
int[] elementFeatures=null;
int elementCount=0;
String content=null;
LOOP: for (int i=0; i < features.length; i++) {
  int kind=featureKinds[i];
  EStructuralFeature f=features[i];
  boolean isSet=o.eIsSet(f);
  if (keepDefaults && !isSet) {
    if (f.getDefaultValueLiteral() != null) {
      isSet=true;
    }
  }
  if (kind != TRANSIENT && isSet) {
switch (kind) {
case DATATYPE_ELEMENT_SINGLE:
{
        if (contentKind == ExtendedMetaData.SIMPLE_CONTENT) {
          content=getDataTypeElementSingleSimple(o,f);
          continue LOOP;
        }
        break;
      }
case DATATYPE_SINGLE:
{
      saveDataTypeSingle(o,f);
      continue LOOP;
    }
case DATATYPE_SINGLE_NILLABLE:
{
    if (!isNil(o,f)) {
      saveDataTypeSingle(o,f);
      continue LOOP;
    }
    break;
  }
case OBJECT_ATTRIBUTE_SINGLE:
{
  saveEObjectSingle(o,f);
  continue LOOP;
}
case OBJECT_ATTRIBUTE_MANY:
{
saveEObjectMany(o,f);
continue LOOP;
}
case OBJECT_ATTRIBUTE_IDREF_SINGLE:
{
saveIDRefSingle(o,f);
continue LOOP;
}
case OBJECT_ATTRIBUTE_IDREF_MANY:
{
saveIDRefMany(o,f);
continue LOOP;
}
case OBJECT_HREF_SINGLE_UNSETTABLE:
{
if (isNil(o,f)) {
break;
}
}
case OBJECT_HREF_SINGLE:
{
if (useEncodedAttributeStyle) {
saveEObjectSingle(o,f);
continue LOOP;
}
 else {
switch (sameDocSingle(o,f)) {
case SAME_DOC:
{
saveIDRefSingle(o,f);
continue LOOP;
}
case CROSS_DOC:
{
break;
}
default :
{
continue LOOP;
}
}
}
break;
}
case OBJECT_HREF_MANY_UNSETTABLE:
{
if (isEmpty(o,f)) {
saveManyEmpty(o,f);
continue LOOP;
}
}
case OBJECT_HREF_MANY:
{
if (useEncodedAttributeStyle) {
saveEObjectMany(o,f);
continue LOOP;
}
 else {
switch (sameDocMany(o,f)) {
case SAME_DOC:
{
saveIDRefMany(o,f);
continue LOOP;
}
case CROSS_DOC:
{
break;
}
default :
{
continue LOOP;
}
}
}
break;
}
case OBJECT_ELEMENT_SINGLE_UNSETTABLE:
case OBJECT_ELEMENT_SINGLE:
{
if (contentKind == ExtendedMetaData.SIMPLE_CONTENT) {
content=getElementReferenceSingleSimple(o,f);
continue LOOP;
}
break;
}
case OBJECT_ELEMENT_MANY:
{
if (contentKind == ExtendedMetaData.SIMPLE_CONTENT) {
content=getElementReferenceManySimple(o,f);
continue LOOP;
}
break;
}
case OBJECT_ELEMENT_IDREF_SINGLE_UNSETTABLE:
case OBJECT_ELEMENT_IDREF_SINGLE:
{
if (contentKind == ExtendedMetaData.SIMPLE_CONTENT) {
content=getElementIDRefSingleSimple(o,f);
continue LOOP;
}
break;
}
case OBJECT_ELEMENT_IDREF_MANY:
{
if (contentKind == ExtendedMetaData.SIMPLE_CONTENT) {
content=getElementIDRefManySimple(o,f);
continue LOOP;
}
break;
}
case OBJECT_CONTAIN_MANY_UNSETTABLE:
case DATATYPE_MANY:
{
if (isEmpty(o,f)) {
saveManyEmpty(o,f);
continue LOOP;
}
break;
}
case OBJECT_CONTAIN_SINGLE_UNSETTABLE:
case OBJECT_CONTAIN_SINGLE:
case OBJECT_CONTAIN_MANY:
case ELEMENT_FEATURE_MAP:
{
break;
}
case ATTRIBUTE_FEATURE_MAP:
{
saveAttributeFeatureMap(o,f);
continue LOOP;
}
default :
{
continue LOOP;
}
}
if (elementFeatures == null) {
elementFeatures=new int[features.length];
}
elementFeatures[elementCount++]=i;
}
}
processAttributeExtensions(o);
if (elementFeatures == null) {
if (content == null) {
content=getContent(o,features);
}
if (content == null) {
endSaveFeatures(o,EMPTY_ELEMENT,null);
return false;
}
 else {
endSaveFeatures(o,CONTENT_ELEMENT,content);
return true;
}
}
for (int i=0; i < elementCount; i++) {
int kind=featureKinds[elementFeatures[i]];
EStructuralFeature f=features[elementFeatures[i]];
switch (kind) {
case DATATYPE_SINGLE_NILLABLE:
{
saveNil(o,f);
break;
}
case ELEMENT_FEATURE_MAP:
{
saveElementFeatureMap(o,f);
break;
}
case DATATYPE_MANY:
{
saveDataTypeMany(o,f);
break;
}
case DATATYPE_ELEMENT_SINGLE:
{
saveDataTypeElementSingle(o,f);
break;
}
case OBJECT_CONTAIN_SINGLE_UNSETTABLE:
{
if (isNil(o,f)) {
saveNil(o,f);
break;
}
}
case OBJECT_CONTAIN_SINGLE:
{
saveContainedSingle(o,f);
break;
}
case OBJECT_CONTAIN_MANY_UNSETTABLE:
case OBJECT_CONTAIN_MANY:
{
saveContainedMany(o,f);
break;
}
case OBJECT_HREF_SINGLE_UNSETTABLE:
{
if (isNil(o,f)) {
saveNil(o,f);
break;
}
}
case OBJECT_HREF_SINGLE:
{
saveHRefSingle(o,f);
break;
}
case OBJECT_HREF_MANY_UNSETTABLE:
case OBJECT_HREF_MANY:
{
saveHRefMany(o,f);
break;
}
case OBJECT_ELEMENT_SINGLE_UNSETTABLE:
{
if (isNil(o,f)) {
saveNil(o,f);
break;
}
}
case OBJECT_ELEMENT_SINGLE:
{
saveElementReferenceSingle(o,f);
break;
}
case OBJECT_ELEMENT_MANY:
{
saveElementReferenceMany(o,f);
break;
}
case OBJECT_ELEMENT_IDREF_SINGLE_UNSETTABLE:
{
if (isNil(o,f)) {
saveNil(o,f);
break;
}
}
case OBJECT_ELEMENT_IDREF_SINGLE:
{
saveElementIDRefSingle(o,f);
break;
}
case OBJECT_ELEMENT_IDREF_MANY:
{
saveElementIDRefMany(o,f);
break;
}
}
}
endSaveFeatures(o,0,null);
return true;
}","protected boolean saveFeatures(EObject o){
  EClass eClass=o.eClass();
  int contentKind=extendedMetaData == null ? ExtendedMetaData.UNSPECIFIED_CONTENT : extendedMetaData.getContentKind(eClass);
  if (!toDOM) {
switch (contentKind) {
case ExtendedMetaData.MIXED_CONTENT:
case ExtendedMetaData.SIMPLE_CONTENT:
{
        doc.setMixed(true);
        break;
      }
  }
}
EStructuralFeature[] features=featureTable.getFeatures(eClass);
int[] featureKinds=featureTable.getKinds(eClass,features);
int[] elementFeatures=null;
int elementCount=0;
String content=null;
LOOP: for (int i=0; i < features.length; i++) {
  int kind=featureKinds[i];
  EStructuralFeature f=features[i];
  if (kind != TRANSIENT && (o.eIsSet(f) || keepDefaults && f.getDefaultValueLiteral() != null)) {
switch (kind) {
case DATATYPE_ELEMENT_SINGLE:
{
        if (contentKind == ExtendedMetaData.SIMPLE_CONTENT) {
          content=getDataTypeElementSingleSimple(o,f);
          continue LOOP;
        }
        break;
      }
case DATATYPE_SINGLE:
{
      saveDataTypeSingle(o,f);
      continue LOOP;
    }
case DATATYPE_SINGLE_NILLABLE:
{
    if (!isNil(o,f)) {
      saveDataTypeSingle(o,f);
      continue LOOP;
    }
    break;
  }
case OBJECT_ATTRIBUTE_SINGLE:
{
  saveEObjectSingle(o,f);
  continue LOOP;
}
case OBJECT_ATTRIBUTE_MANY:
{
saveEObjectMany(o,f);
continue LOOP;
}
case OBJECT_ATTRIBUTE_IDREF_SINGLE:
{
saveIDRefSingle(o,f);
continue LOOP;
}
case OBJECT_ATTRIBUTE_IDREF_MANY:
{
saveIDRefMany(o,f);
continue LOOP;
}
case OBJECT_HREF_SINGLE_UNSETTABLE:
{
if (isNil(o,f)) {
break;
}
}
case OBJECT_HREF_SINGLE:
{
if (useEncodedAttributeStyle) {
saveEObjectSingle(o,f);
continue LOOP;
}
 else {
switch (sameDocSingle(o,f)) {
case SAME_DOC:
{
saveIDRefSingle(o,f);
continue LOOP;
}
case CROSS_DOC:
{
break;
}
default :
{
continue LOOP;
}
}
}
break;
}
case OBJECT_HREF_MANY_UNSETTABLE:
{
if (isEmpty(o,f)) {
saveManyEmpty(o,f);
continue LOOP;
}
}
case OBJECT_HREF_MANY:
{
if (useEncodedAttributeStyle) {
saveEObjectMany(o,f);
continue LOOP;
}
 else {
switch (sameDocMany(o,f)) {
case SAME_DOC:
{
saveIDRefMany(o,f);
continue LOOP;
}
case CROSS_DOC:
{
break;
}
default :
{
continue LOOP;
}
}
}
break;
}
case OBJECT_ELEMENT_SINGLE_UNSETTABLE:
case OBJECT_ELEMENT_SINGLE:
{
if (contentKind == ExtendedMetaData.SIMPLE_CONTENT) {
content=getElementReferenceSingleSimple(o,f);
continue LOOP;
}
break;
}
case OBJECT_ELEMENT_MANY:
{
if (contentKind == ExtendedMetaData.SIMPLE_CONTENT) {
content=getElementReferenceManySimple(o,f);
continue LOOP;
}
break;
}
case OBJECT_ELEMENT_IDREF_SINGLE_UNSETTABLE:
case OBJECT_ELEMENT_IDREF_SINGLE:
{
if (contentKind == ExtendedMetaData.SIMPLE_CONTENT) {
content=getElementIDRefSingleSimple(o,f);
continue LOOP;
}
break;
}
case OBJECT_ELEMENT_IDREF_MANY:
{
if (contentKind == ExtendedMetaData.SIMPLE_CONTENT) {
content=getElementIDRefManySimple(o,f);
continue LOOP;
}
break;
}
case OBJECT_CONTAIN_MANY_UNSETTABLE:
case DATATYPE_MANY:
{
if (isEmpty(o,f)) {
saveManyEmpty(o,f);
continue LOOP;
}
break;
}
case OBJECT_CONTAIN_SINGLE_UNSETTABLE:
case OBJECT_CONTAIN_SINGLE:
case OBJECT_CONTAIN_MANY:
case ELEMENT_FEATURE_MAP:
{
break;
}
case ATTRIBUTE_FEATURE_MAP:
{
saveAttributeFeatureMap(o,f);
continue LOOP;
}
default :
{
continue LOOP;
}
}
if (elementFeatures == null) {
elementFeatures=new int[features.length];
}
elementFeatures[elementCount++]=i;
}
}
processAttributeExtensions(o);
if (elementFeatures == null) {
if (content == null) {
content=getContent(o,features);
}
if (content == null) {
endSaveFeatures(o,EMPTY_ELEMENT,null);
return false;
}
 else {
endSaveFeatures(o,CONTENT_ELEMENT,content);
return true;
}
}
for (int i=0; i < elementCount; i++) {
int kind=featureKinds[elementFeatures[i]];
EStructuralFeature f=features[elementFeatures[i]];
switch (kind) {
case DATATYPE_SINGLE_NILLABLE:
{
saveNil(o,f);
break;
}
case ELEMENT_FEATURE_MAP:
{
saveElementFeatureMap(o,f);
break;
}
case DATATYPE_MANY:
{
saveDataTypeMany(o,f);
break;
}
case DATATYPE_ELEMENT_SINGLE:
{
saveDataTypeElementSingle(o,f);
break;
}
case OBJECT_CONTAIN_SINGLE_UNSETTABLE:
{
if (isNil(o,f)) {
saveNil(o,f);
break;
}
}
case OBJECT_CONTAIN_SINGLE:
{
saveContainedSingle(o,f);
break;
}
case OBJECT_CONTAIN_MANY_UNSETTABLE:
case OBJECT_CONTAIN_MANY:
{
saveContainedMany(o,f);
break;
}
case OBJECT_HREF_SINGLE_UNSETTABLE:
{
if (isNil(o,f)) {
saveNil(o,f);
break;
}
}
case OBJECT_HREF_SINGLE:
{
saveHRefSingle(o,f);
break;
}
case OBJECT_HREF_MANY_UNSETTABLE:
case OBJECT_HREF_MANY:
{
saveHRefMany(o,f);
break;
}
case OBJECT_ELEMENT_SINGLE_UNSETTABLE:
{
if (isNil(o,f)) {
saveNil(o,f);
break;
}
}
case OBJECT_ELEMENT_SINGLE:
{
saveElementReferenceSingle(o,f);
break;
}
case OBJECT_ELEMENT_MANY:
{
saveElementReferenceMany(o,f);
break;
}
case OBJECT_ELEMENT_IDREF_SINGLE_UNSETTABLE:
{
if (isNil(o,f)) {
saveNil(o,f);
break;
}
}
case OBJECT_ELEMENT_IDREF_SINGLE:
{
saveElementIDRefSingle(o,f);
break;
}
case OBJECT_ELEMENT_IDREF_MANY:
{
saveElementIDRefMany(o,f);
break;
}
}
}
endSaveFeatures(o,0,null);
return true;
}",0.9869949369601906
11931,"public void write(OutputStreamWriter os) throws IOException {
  int count=0;
  final int BUFFER_SIZE=8192;
  char[] buffer=new char[BUFFER_SIZE];
  int pos=0;
  for (Iterator i=doc.iterator(); i.hasNext(); ) {
    String s=(String)i.next();
    int slen=s.length();
    if (slen + pos >= buffer.length) {
      os.write(buffer,0,pos);
      pos=0;
      if (slen > buffer.length) {
        buffer=new char[slen];
      }
    }
    s.getChars(0,slen,buffer,pos);
    pos+=slen;
    count+=slen;
    if (count > flushThreshold) {
      os.flush();
      count=0;
    }
  }
  os.write(buffer,0,pos);
  String temporaryFileName=doc.getTemporaryFileName();
  if (temporaryFileName != null) {
    InputStreamReader reader=new InputStreamReader(new FileInputStream(temporaryFileName),""String_Node_Str"");
    for (int length=reader.read(buffer,0,BUFFER_SIZE); length > 0; length=reader.read(buffer,0,BUFFER_SIZE)) {
      os.write(buffer,0,length);
      count+=length;
      if (count > flushThreshold) {
        os.flush();
        count=0;
      }
    }
    reader.close();
    new File(temporaryFileName).delete();
  }
}","public void write(OutputStreamWriter os) throws IOException {
  int count=0;
  final int BUFFER_SIZE=8192;
  char[] buffer=new char[BUFFER_SIZE];
  int pos=0;
  for (Iterator i=doc.iterator(); i.hasNext(); ) {
    String s=(String)i.next();
    int slen=s.length();
    if (slen + pos >= buffer.length) {
      os.write(buffer,0,pos);
      pos=0;
      if (slen > buffer.length) {
        buffer=new char[slen];
      }
    }
    s.getChars(0,slen,buffer,pos);
    pos+=slen;
    count+=slen;
    if (count > flushThreshold) {
      os.flush();
      count=0;
    }
  }
  os.write(buffer,0,pos);
  String temporaryFileName=doc.getTemporaryFileName();
  if (temporaryFileName != null) {
    InputStreamReader reader=new InputStreamReader(new FileInputStream(temporaryFileName),""String_Node_Str"");
    for (int length=reader.read(buffer,0,BUFFER_SIZE); length > 0; length=reader.read(buffer,0,BUFFER_SIZE)) {
      os.write(buffer,0,length);
      count+=length;
      if (count > flushThreshold) {
        os.flush();
        count=0;
      }
    }
    reader.close();
    new File(temporaryFileName).delete();
  }
  os.flush();
}",0.993766696349065
11932,"public void save(XMLResource resource,OutputStream outputStream,Map options) throws IOException {
  init(resource,options);
  List contents=resource.getContents();
  traverse(contents);
  if (encoding.equals(""String_Node_Str"") || encoding.equals(""String_Node_Str"")) {
    writeAscii(outputStream);
  }
 else {
    OutputStreamWriter outputStreamWriter=new OutputStreamWriter(outputStream,helper.getJavaEncoding(encoding));
    write(outputStreamWriter);
  }
  if (extendedMetaData != null && contents.size() >= 1) {
    EObject root=(EObject)contents.get(0);
    EClass eClass=root.eClass();
    EReference xmlnsPrefixMapFeature=extendedMetaData.getXMLNSPrefixMapFeature(eClass);
    if (xmlnsPrefixMapFeature != null) {
      EMap xmlnsPrefixMap=(EMap)root.eGet(xmlnsPrefixMapFeature);
      for (Iterator i=helper.getPrefixToNamespaceMap().iterator(); i.hasNext(); ) {
        Map.Entry entry=(Map.Entry)i.next();
        Object key=entry.getKey();
        Object value=entry.getValue();
        Object currentValue=xmlnsPrefixMap.get(key);
        if (currentValue == null ? value != null : !currentValue.equals(value)) {
          xmlnsPrefixMap.put(key,value);
        }
      }
    }
  }
  featureTable=null;
  doc=null;
  if (processDanglingHREF == null || XMLResource.OPTION_PROCESS_DANGLING_HREF_THROW.equals(processDanglingHREF)) {
    DanglingHREFException exception=helper.getDanglingHREFException();
    if (exception != null) {
      helper=null;
      throw new Resource.IOWrappedException(exception);
    }
  }
  helper=null;
}","public void save(XMLResource resource,OutputStream outputStream,Map options) throws IOException {
  init(resource,options);
  List contents=resource.getContents();
  traverse(contents);
  if (encoding.equals(""String_Node_Str"") || encoding.equals(""String_Node_Str"")) {
    writeAscii(outputStream);
    outputStream.flush();
  }
 else {
    OutputStreamWriter outputStreamWriter=new OutputStreamWriter(outputStream,helper.getJavaEncoding(encoding));
    write(outputStreamWriter);
    outputStreamWriter.flush();
  }
  if (extendedMetaData != null && contents.size() >= 1) {
    EObject root=(EObject)contents.get(0);
    EClass eClass=root.eClass();
    EReference xmlnsPrefixMapFeature=extendedMetaData.getXMLNSPrefixMapFeature(eClass);
    if (xmlnsPrefixMapFeature != null) {
      EMap xmlnsPrefixMap=(EMap)root.eGet(xmlnsPrefixMapFeature);
      for (Iterator i=helper.getPrefixToNamespaceMap().iterator(); i.hasNext(); ) {
        Map.Entry entry=(Map.Entry)i.next();
        Object key=entry.getKey();
        Object value=entry.getValue();
        Object currentValue=xmlnsPrefixMap.get(key);
        if (currentValue == null ? value != null : !currentValue.equals(value)) {
          xmlnsPrefixMap.put(key,value);
        }
      }
    }
  }
  featureTable=null;
  doc=null;
  if (processDanglingHREF == null || XMLResource.OPTION_PROCESS_DANGLING_HREF_THROW.equals(processDanglingHREF)) {
    DanglingHREFException exception=helper.getDanglingHREFException();
    if (exception != null) {
      helper=null;
      throw new Resource.IOWrappedException(exception);
    }
  }
  helper=null;
}",0.9815521628498728
11933,"public void writeAscii(OutputStream os) throws IOException {
  int count=0;
  final int BUFFER_SIZE=8192;
  char[] buffer=new char[BUFFER_SIZE];
  byte[] bytes=new byte[BUFFER_SIZE];
  int pos=0;
  for (Iterator i=doc.iterator(); i.hasNext(); ) {
    String s=(String)i.next();
    int slen=s.length();
    if (slen + pos >= buffer.length) {
      for (int x=0; x < pos; x++) {
        bytes[x]=(byte)(buffer[x] & 0xFF);
      }
      os.write(bytes,0,pos);
      pos=0;
      if (slen > buffer.length) {
        buffer=new char[slen];
        bytes=new byte[slen];
      }
    }
    s.getChars(0,slen,buffer,pos);
    pos+=slen;
    count+=slen;
    if (count > flushThreshold) {
      os.flush();
      count=0;
    }
  }
  for (int x=0; x < pos; x++) {
    bytes[x]=(byte)(buffer[x] & 0xFF);
  }
  os.write(bytes,0,pos);
  String temporaryFileName=doc.getTemporaryFileName();
  if (temporaryFileName != null) {
    InputStream inputStream=new FileInputStream(temporaryFileName);
    for (int length=inputStream.read(bytes,0,BUFFER_SIZE); length > 0; length=inputStream.read(bytes,0,BUFFER_SIZE)) {
      os.write(bytes,0,length);
      count+=length;
      if (count > flushThreshold) {
        os.flush();
        count=0;
      }
    }
    inputStream.close();
    new File(temporaryFileName).delete();
  }
}","public void writeAscii(OutputStream os) throws IOException {
  int count=0;
  final int BUFFER_SIZE=8192;
  char[] buffer=new char[BUFFER_SIZE];
  byte[] bytes=new byte[BUFFER_SIZE];
  int pos=0;
  for (Iterator i=doc.iterator(); i.hasNext(); ) {
    String s=(String)i.next();
    int slen=s.length();
    if (slen + pos >= buffer.length) {
      for (int x=0; x < pos; x++) {
        bytes[x]=(byte)(buffer[x] & 0xFF);
      }
      os.write(bytes,0,pos);
      pos=0;
      if (slen > buffer.length) {
        buffer=new char[slen];
        bytes=new byte[slen];
      }
    }
    s.getChars(0,slen,buffer,pos);
    pos+=slen;
    count+=slen;
    if (count > flushThreshold) {
      os.flush();
      count=0;
    }
  }
  for (int x=0; x < pos; x++) {
    bytes[x]=(byte)(buffer[x] & 0xFF);
  }
  os.write(bytes,0,pos);
  String temporaryFileName=doc.getTemporaryFileName();
  if (temporaryFileName != null) {
    InputStream inputStream=new FileInputStream(temporaryFileName);
    for (int length=inputStream.read(bytes,0,BUFFER_SIZE); length > 0; length=inputStream.read(bytes,0,BUFFER_SIZE)) {
      os.write(bytes,0,length);
      count+=length;
      if (count > flushThreshold) {
        os.flush();
        count=0;
      }
    }
    inputStream.close();
    new File(temporaryFileName).delete();
  }
  os.flush();
}",0.9946969696969696
11934,"public EPackage[] packages(){
  Map map=new TreeMap();
  for (Iterator i=packages.entrySet().iterator(); i.hasNext(); ) {
    Map.Entry entry=(Map.Entry)i.next();
    EPackage conflict=(EPackage)map.put(entry.getValue(),entry.getKey());
    if (conflict != null && conflict.eResource() != null) {
      map.put(entry.getValue(),conflict);
    }
  }
  EPackage[] result=new EPackage[map.size()];
  map.values().toArray(result);
  return result;
}","public EPackage[] packages(){
  Map map=new TreeMap();
  for (Iterator i=packages.entrySet().iterator(); i.hasNext(); ) {
    Map.Entry entry=(Map.Entry)i.next();
    Object value=entry.getValue();
    if (value == null) {
      value=""String_Node_Str"";
    }
    EPackage conflict=(EPackage)map.put(value,entry.getKey());
    if (conflict != null && conflict.eResource() != null) {
      map.put(value,conflict);
    }
  }
  EPackage[] result=new EPackage[map.size()];
  map.values().toArray(result);
  return result;
}",0.8559585492227979
11935,"protected void addNamespaceDeclarations(){
  EPackage noNamespacePackage=helper.getNoNamespacePackage();
  EPackage[] packages=helper.packages();
  StringBuffer xsiSchemaLocation=null;
  String xsiNoNamespaceSchemaLocation=null;
  if (declareSchemaLocation) {
    if (extendedMetaData == null) {
      for (int i=0; i < packages.length; i++) {
        EPackage ePackage=packages[i];
        if (noNamespacePackage == ePackage) {
          declareXSI=true;
          if (ePackage.eResource() != null) {
            xsiNoNamespaceSchemaLocation=helper.getHREF(ePackage);
            if (xsiNoNamespaceSchemaLocation.endsWith(""String_Node_Str"")) {
              xsiNoNamespaceSchemaLocation=xsiNoNamespaceSchemaLocation.substring(0,xsiNoNamespaceSchemaLocation.length() - 2);
            }
          }
        }
 else {
          Resource resource=ePackage.eResource();
          if (resource != null) {
            URI uri=resource.getURI();
            String nsURI=ePackage.getNsURI();
            if (uri == null ? nsURI != null : !uri.toString().equals(nsURI)) {
              declareXSI=true;
              if (xsiSchemaLocation == null) {
                xsiSchemaLocation=new StringBuffer();
              }
 else {
                xsiSchemaLocation.append(' ');
              }
              xsiSchemaLocation.append(nsURI);
              xsiSchemaLocation.append(' ');
              String location=helper.getHREF(ePackage);
              if (location.endsWith(""String_Node_Str"")) {
                location=location.substring(0,location.length() - 2);
              }
              xsiSchemaLocation.append(location);
            }
          }
        }
      }
    }
 else {
      Resource resource=helper.getResource();
      if (resource != null && resource.getContents().size() >= 1) {
        EObject root=(EObject)resource.getContents().get(0);
        EClass eClass=root.eClass();
        EReference xsiSchemaLocationMapFeature=extendedMetaData.getXSISchemaLocationMapFeature(eClass);
        if (xsiSchemaLocationMapFeature != null) {
          EMap xsiSchemaLocationMap=(EMap)root.eGet(xsiSchemaLocationMapFeature);
          if (!xsiSchemaLocationMap.isEmpty()) {
            declareXSI=true;
            for (Iterator i=xsiSchemaLocationMap.entrySet().iterator(); i.hasNext(); ) {
              Map.Entry entry=(Map.Entry)i.next();
              String namespace=(String)entry.getKey();
              URI location=URI.createURI(entry.getValue().toString());
              if (namespace == null) {
                xsiNoNamespaceSchemaLocation=helper.deresolve(location).toString();
              }
 else {
                if (xsiSchemaLocation == null) {
                  xsiSchemaLocation=new StringBuffer();
                }
 else {
                  xsiSchemaLocation.append(' ');
                }
                xsiSchemaLocation.append(namespace);
                xsiSchemaLocation.append(' ');
                xsiSchemaLocation.append(helper.deresolve(location).toString());
              }
            }
          }
        }
      }
    }
  }
  if (declareXSI) {
    doc.addAttribute(XSI_XMLNS,XMLResource.XSI_URI);
  }
  for (int i=0; i < packages.length; i++) {
    EPackage ePackage=packages[i];
    if (ePackage != noNamespacePackage && ePackage != XMLNamespacePackage.eINSTANCE) {
      String nsURI=extendedMetaData == null ? ePackage.getNsURI() : extendedMetaData.getNamespace(ePackage);
      if (nsURI != null) {
        List nsPrefixes=helper.getPrefixes(ePackage);
        for (Iterator j=nsPrefixes.iterator(); j.hasNext(); ) {
          String nsPrefix=(String)j.next();
          if (nsPrefix != null && nsPrefix.length() > 0) {
            doc.addAttributeNS(XMLResource.XML_NS,nsPrefix,nsURI);
          }
 else {
            doc.addAttribute(XMLResource.XML_NS,nsURI);
          }
        }
      }
    }
  }
  if (xsiSchemaLocation != null) {
    doc.addAttribute(XSI_SCHEMA_LOCATION,xsiSchemaLocation.toString());
  }
  if (xsiNoNamespaceSchemaLocation != null) {
    doc.addAttribute(XSI_NO_NAMESPACE_SCHEMA_LOCATION,xsiNoNamespaceSchemaLocation);
  }
}","protected void addNamespaceDeclarations(){
  EPackage noNamespacePackage=helper.getNoNamespacePackage();
  EPackage[] packages=helper.packages();
  StringBuffer xsiSchemaLocation=null;
  String xsiNoNamespaceSchemaLocation=null;
  if (declareSchemaLocation) {
    if (extendedMetaData == null) {
      for (int i=0; i < packages.length; i++) {
        EPackage ePackage=packages[i];
        if (noNamespacePackage == ePackage) {
          declareXSI=true;
          if (ePackage.eResource() != null) {
            xsiNoNamespaceSchemaLocation=helper.getHREF(ePackage);
            if (xsiNoNamespaceSchemaLocation.endsWith(""String_Node_Str"")) {
              xsiNoNamespaceSchemaLocation=xsiNoNamespaceSchemaLocation.substring(0,xsiNoNamespaceSchemaLocation.length() - 2);
            }
          }
        }
 else {
          Resource resource=ePackage.eResource();
          if (resource != null) {
            URI uri=resource.getURI();
            String nsURI=ePackage.getNsURI();
            if (uri == null ? nsURI != null : !uri.toString().equals(nsURI)) {
              declareXSI=true;
              if (xsiSchemaLocation == null) {
                xsiSchemaLocation=new StringBuffer();
              }
 else {
                xsiSchemaLocation.append(' ');
              }
              xsiSchemaLocation.append(nsURI);
              xsiSchemaLocation.append(' ');
              String location=helper.getHREF(ePackage);
              if (location.endsWith(""String_Node_Str"")) {
                location=location.substring(0,location.length() - 2);
              }
              xsiSchemaLocation.append(location);
            }
          }
        }
      }
    }
 else {
      Resource resource=helper.getResource();
      if (resource != null && resource.getContents().size() >= 1) {
        EObject root=(EObject)resource.getContents().get(0);
        EClass eClass=root.eClass();
        EReference xsiSchemaLocationMapFeature=extendedMetaData.getXSISchemaLocationMapFeature(eClass);
        if (xsiSchemaLocationMapFeature != null) {
          EMap xsiSchemaLocationMap=(EMap)root.eGet(xsiSchemaLocationMapFeature);
          if (!xsiSchemaLocationMap.isEmpty()) {
            declareXSI=true;
            for (Iterator i=xsiSchemaLocationMap.entrySet().iterator(); i.hasNext(); ) {
              Map.Entry entry=(Map.Entry)i.next();
              String namespace=(String)entry.getKey();
              URI location=URI.createURI(entry.getValue().toString());
              if (namespace == null) {
                xsiNoNamespaceSchemaLocation=helper.deresolve(location).toString();
              }
 else {
                if (xsiSchemaLocation == null) {
                  xsiSchemaLocation=new StringBuffer();
                }
 else {
                  xsiSchemaLocation.append(' ');
                }
                xsiSchemaLocation.append(namespace);
                xsiSchemaLocation.append(' ');
                xsiSchemaLocation.append(helper.deresolve(location).toString());
              }
            }
          }
        }
      }
    }
  }
  if (declareXSI) {
    doc.addAttribute(XSI_XMLNS,XMLResource.XSI_URI);
  }
  for (int i=0; i < packages.length; i++) {
    EPackage ePackage=packages[i];
    if (ePackage != noNamespacePackage && ePackage != XMLNamespacePackage.eINSTANCE) {
      String nsURI=extendedMetaData == null ? ePackage.getNsURI() : extendedMetaData.getNamespace(ePackage);
      if (nsURI != null && !isDuplicateURI(nsURI)) {
        List nsPrefixes=helper.getPrefixes(ePackage);
        for (Iterator j=nsPrefixes.iterator(); j.hasNext(); ) {
          String nsPrefix=(String)j.next();
          if (nsPrefix != null && nsPrefix.length() > 0) {
            doc.addAttributeNS(XMLResource.XML_NS,nsPrefix,nsURI);
          }
 else {
            doc.addAttribute(XMLResource.XML_NS,nsURI);
          }
        }
      }
    }
  }
  if (xsiSchemaLocation != null) {
    doc.addAttribute(XSI_SCHEMA_LOCATION,xsiSchemaLocation.toString());
  }
  if (xsiNoNamespaceSchemaLocation != null) {
    doc.addAttribute(XSI_NO_NAMESPACE_SCHEMA_LOCATION,xsiNoNamespaceSchemaLocation);
  }
}",0.9968415937803692
11936,"/** 
 * Method getExcludeFiles.
 * @return String
 */
private String getExcludeFile(int type){
  String file=File.separator + ""String_Node_Str"";
switch (type) {
case HTML:
    file+=""String_Node_Str"";
  break;
case PROPERTIES:
file+=""String_Node_Str"";
break;
case XML:
file+=""String_Node_Str"";
break;
default :
file+=""String_Node_Str"";
}
String fullPath=""String_Node_Str"" + File.separator + ""String_Node_Str""+ File.separator+ ""String_Node_Str""+ File.separator+ ""String_Node_Str""+ file;
if (new File(fullPath).isFile()) {
return ""String_Node_Str"" + fullPath;
}
fullPath=EMFTestCorePlugin.getPlugin().getPluginDirectory() + file;
if (new File(fullPath).isFile()) {
return ""String_Node_Str"" + fullPath;
}
return ""String_Node_Str"";
}","/** 
 * Method getExcludeFiles.
 * @return String
 */
private String getExcludeFile(int type){
  String file=File.separator + ""String_Node_Str"";
switch (type) {
case HTML:
    file+=""String_Node_Str"";
  break;
case PROPERTIES:
file+=""String_Node_Str"";
break;
case XML:
file+=""String_Node_Str"";
break;
default :
file+=""String_Node_Str"";
}
file=EMFTestCorePlugin.getPlugin().getPluginDirectory() + file;
if (new File(file).isFile()) {
return ""String_Node_Str"" + file;
}
return ""String_Node_Str"";
}",0.7924836601307189
11937,"/** 
 * Method getFilesToTest.
 * @param HTML
 * @return String
 */
private String getFilesToTest(int type){
  String sniffFolder=Platform.getInstanceLocation().toOSString();
  String aString=new File(sniffFolder).getPath() + File.separator;
switch (type) {
case HTML:
    return aString + ""String_Node_Str"";
case PROPERTIES:
  return aString + ""String_Node_Str"";
case XML:
return aString + ""String_Node_Str"";
default :
return aString + ""String_Node_Str"";
}
}","/** 
 * Method getFilesToTest.
 * @param HTML
 * @return String
 */
private String getFilesToTest(int type){
  String sniffFolder=Platform.getInstanceLocation().getURL().getFile();
  String aString=new File(sniffFolder).getPath() + File.separator;
switch (type) {
case HTML:
    return aString + ""String_Node_Str"";
case PROPERTIES:
  return aString + ""String_Node_Str"";
case XML:
return aString + ""String_Node_Str"";
default :
return aString + ""String_Node_Str"";
}
}",0.971861471861472
11938,"public void execute(int method) throws Exception {
switch (method) {
case RestService.GET:
{
      String combinedParams=""String_Node_Str"";
      if (!params.isEmpty()) {
        combinedParams+=""String_Node_Str"";
        for (        NameValuePair p : params) {
          String paramString=p.getName() + ""String_Node_Str"" + URLEncoder.encode(p.getValue(),""String_Node_Str"");
          if (combinedParams.length() > 1) {
            combinedParams+=""String_Node_Str"" + paramString;
          }
 else {
            combinedParams+=paramString;
          }
        }
      }
      request=new HttpGet(url + combinedParams);
      for (      NameValuePair h : headers) {
        request.addHeader(h.getName(),h.getValue());
      }
      commit();
      break;
    }
case RestService.POST:
{
    HttpPost request=new HttpPost(url);
    for (    NameValuePair h : headers) {
      request.addHeader(h.getName(),h.getValue());
    }
    if (!params.isEmpty()) {
      request.setEntity(new UrlEncodedFormEntity(params,HTTP.UTF_8));
    }
    commit();
    break;
  }
}
}","public void execute(int method) throws Exception {
switch (method) {
case RestService.GET:
{
      String combinedParams=""String_Node_Str"";
      if (!params.isEmpty()) {
        combinedParams+=""String_Node_Str"";
        for (        NameValuePair p : params) {
          String paramString=p.getName() + ""String_Node_Str"" + URLEncoder.encode(p.getValue(),""String_Node_Str"");
          if (combinedParams.length() > 1) {
            combinedParams+=""String_Node_Str"" + paramString;
          }
 else {
            combinedParams+=paramString;
          }
        }
      }
      request=new HttpGet(url + combinedParams);
      for (      NameValuePair h : headers) {
        request.addHeader(h.getName(),h.getValue());
      }
      commit();
      break;
    }
case RestService.POST:
{
    request=new HttpPost(url);
    for (    NameValuePair h : headers) {
      request.addHeader(h.getName(),h.getValue());
    }
    if (!params.isEmpty()) {
      ((HttpPost)request).setEntity(new UrlEncodedFormEntity(params,HTTP.UTF_8));
    }
    commit();
    break;
  }
}
}",0.8655737704918033
11939,"public static void main(String[] args) throws Exception {
  if (args.length != 2) {
    usage();
  }
  File input=new File(args[0]);
  if (!input.exists())   error(""String_Node_Str"" + input.getAbsolutePath() + ""String_Node_Str"");
  if (!input.canRead())   error(""String_Node_Str"" + input.getAbsolutePath());
  if (!input.isFile())   error(""String_Node_Str"" + input.getAbsolutePath());
  File output=new File(args[1]);
  if (output.exists())   error(""String_Node_Str"" + output.getAbsolutePath() + ""String_Node_Str"");
  if (output.canWrite())   error(""String_Node_Str"" + output.getAbsolutePath());
  if (output.isDirectory())   error(""String_Node_Str"" + output.getAbsolutePath());
  if (!output.getName().endsWith(""String_Node_Str""))   error(""String_Node_Str"");
  BufferedReader in=new BufferedReader(new InputStreamReader(new BZip2CompressorInputStream(new FileInputStream(input))));
  BufferedOutputStream out=new BufferedOutputStream(new GZIPOutputStream(new FileOutputStream(output)));
  String line;
  int count=0;
  ProgressLogger progressLogger=new ProgressLogger(log,""String_Node_Str"",100000,1000000);
  progressLogger.start();
  while ((line=in.readLine()) != null) {
    count++;
    progressLogger.tick();
    String[] tokens=line.split(""String_Node_Str"");
    if (tokens.length > 0) {
      if ((tokens.length == 3) && (tokens[0].trim().length() > 0) && (tokens[1].trim().length() > 0)&& (tokens[2].trim().length() > 0)) {
        output_resource(out,tokens[0],tokens[1],tokens[2]);
      }
 else       if ((tokens.length == 4) && (tokens[0].trim().length() > 0) && (tokens[1].trim().length() > 0)&& (tokens[3].trim().length() > 0)) {
        if (tokens[2].trim().length() == 0) {
          output_literal(out,tokens[0],tokens[1],tokens[3]);
        }
 else {
          if (tokens[2].startsWith(LANG)) {
            output_literal_lang(out,tokens[0],tokens[1],tokens[3],tokens[2]);
          }
 else {
            if (tokens[1].equals(OBJECT_KEY)) {
              output_literal2(out,tokens[0],tokens[1],tokens[2],tokens[3]);
            }
 else             if ((tokens[1].equals(OBJECT_NAME)) && (tokens[2].startsWith(GUID))) {
              output_literal2(out,tokens[0],tokens[1],tokens[2],tokens[3]);
            }
 else {
              log.warn(""String_Node_Str"",count,line);
            }
          }
        }
      }
 else {
        if (tokens.length < 3) {
          log.warn(""String_Node_Str"",new Object[]{count,tokens.length,line});
        }
 else {
          log.warn(""String_Node_Str"",new Object[]{count,line});
        }
      }
    }
  }
  progressLogger.finish();
}","public static void main(String[] args) throws Exception {
  if (args.length != 2) {
    usage();
  }
  File input=new File(args[0]);
  if (!input.exists())   error(""String_Node_Str"" + input.getAbsolutePath() + ""String_Node_Str"");
  if (!input.canRead())   error(""String_Node_Str"" + input.getAbsolutePath());
  if (!input.isFile())   error(""String_Node_Str"" + input.getAbsolutePath());
  File output=new File(args[1]);
  if (output.exists())   error(""String_Node_Str"" + output.getAbsolutePath() + ""String_Node_Str"");
  if (output.canWrite())   error(""String_Node_Str"" + output.getAbsolutePath());
  if (output.isDirectory())   error(""String_Node_Str"" + output.getAbsolutePath());
  if (!output.getName().endsWith(""String_Node_Str""))   error(""String_Node_Str"");
  BufferedReader in=new BufferedReader(new InputStreamReader(new BZip2CompressorInputStream(new FileInputStream(input))));
  BufferedOutputStream out=new BufferedOutputStream(new GZIPOutputStream(new FileOutputStream(output)));
  String line;
  int count=0;
  ProgressLogger progressLogger=new ProgressLogger(log,""String_Node_Str"",100000,1000000);
  progressLogger.start();
  while ((line=in.readLine()) != null) {
    count++;
    progressLogger.tick();
    String[] tokens=line.split(""String_Node_Str"");
    if (tokens.length > 0) {
      if ((tokens.length == 3) && (tokens[0].trim().length() > 0) && (tokens[1].trim().length() > 0)&& (tokens[2].trim().length() > 0)) {
        output_resource(out,tokens[0],tokens[1],tokens[2]);
      }
 else       if ((tokens.length == 4) && (tokens[0].trim().length() > 0) && (tokens[1].trim().length() > 0)&& (tokens[3].trim().length() > 0)) {
        if (tokens[2].trim().length() == 0) {
          output_literal(out,tokens[0],tokens[1],tokens[3]);
        }
 else {
          if (tokens[2].startsWith(LANG)) {
            output_literal_lang(out,tokens[0],tokens[1],tokens[3],tokens[2].substring(tokens[2].lastIndexOf('/') + 1));
          }
 else {
            if (tokens[1].equals(OBJECT_KEY)) {
              output_literal2(out,tokens[0],tokens[1],tokens[2],tokens[3]);
            }
 else             if ((tokens[1].equals(OBJECT_NAME)) && (tokens[2].startsWith(GUID))) {
              output_literal2(out,tokens[0],tokens[1],tokens[2],tokens[3]);
            }
 else {
              log.warn(""String_Node_Str"",count,line);
            }
          }
        }
      }
 else {
        if (tokens.length < 3) {
          log.warn(""String_Node_Str"",new Object[]{count,tokens.length,line});
        }
 else {
          log.warn(""String_Node_Str"",new Object[]{count,line});
        }
      }
    }
  }
  progressLogger.finish();
  out.flush();
  out.close();
}",0.9863013698630136
11940,"private String getTopicDesc(Topic t){
  StringBuilder sb=new StringBuilder();
  sb.append(t.getUser().getLogin()).append(""String_Node_Str"");
  sb.append(howLongAgo(t.getCreatedAt()));
  sb.append(getContext().getString(R.string.fragment_at)).append(topic.getNodeName()).append(getContext().getString(R.string.fragment_created));
  return sb.toString();
}","private String getTopicDesc(Topic t){
  StringBuilder sb=new StringBuilder();
  sb.append(t.getUser().getLogin()).append(""String_Node_Str"");
  sb.append(getCreatedTime(t.getCreatedAt())).append(""String_Node_Str"");
  sb.append(getContext().getString(R.string.fragment_at)).append(topic.getNodeName()).append(getContext().getString(R.string.fragment_created));
  return sb.toString();
}",0.6585365853658537
11941,"@Override public View getView(int position,View convertView,ViewGroup parent){
  if (position == 0) {
    topic=((MockReply)items.get(position)).getTopic();
    initializeTopicBody(topic);
    return body;
  }
  final ViewHolder viewHolder;
  if (convertView == null || convertView.getTag() == null) {
    viewHolder=new ViewHolder();
    convertView=LayoutInflater.from(getContext()).inflate(replyResource,null);
    viewHolder.gravatar=(ImageView)convertView.findViewById(R.id.gravatar);
    viewHolder.userName=(TextView)convertView.findViewById(R.id.user_name);
    viewHolder.replyAt=(TextView)convertView.findViewById(R.id.reply_at);
    viewHolder.floor=(TextView)convertView.findViewById(R.id.floor);
    viewHolder.body=(TextView)convertView.findViewById(R.id.body);
    viewHolder.forward=(ImageView)convertView.findViewById(R.id.forward);
    convertView.setTag(viewHolder);
  }
 else {
    viewHolder=(ViewHolder)convertView.getTag();
  }
  final Reply r=items.get(position);
  fragment.requestUserAvatar(r.getUser(),viewHolder.gravatar,0);
  viewHolder.userName.setText(r.getUser().getLogin());
  viewHolder.replyAt.setText(""String_Node_Str"" + howLongAgo(r.getCreatedAt()) + getContext().getString(R.string.fragment_reply));
  viewHolder.floor.setText(position + ""String_Node_Str"" + fragment.getString(R.string.reply_list_unit));
  if (HtmlUtil.existsImg(r.getBodyHTML())) {
    fragment.executeRetrieveSpannedTask(viewHolder.body,r.getBodyHTML());
  }
 else {
    viewHolder.body.setText(Html.fromHtml(r.getBodyHTML()));
  }
  viewHolder.gravatar.setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View v){
      fragment.visitUserProfile(r.getUser());
    }
  }
);
  return convertView;
}","@Override public View getView(int position,View convertView,ViewGroup parent){
  if (position == 0) {
    topic=((MockReply)items.get(position)).getTopic();
    initializeTopicBody(topic);
    return body;
  }
  final ViewHolder viewHolder;
  if (convertView == null || convertView.getTag() == null) {
    viewHolder=new ViewHolder();
    convertView=LayoutInflater.from(getContext()).inflate(replyResource,null);
    viewHolder.gravatar=(ImageView)convertView.findViewById(R.id.gravatar);
    viewHolder.userName=(TextView)convertView.findViewById(R.id.user_name);
    viewHolder.replyAt=(TextView)convertView.findViewById(R.id.reply_at);
    viewHolder.floor=(TextView)convertView.findViewById(R.id.floor);
    viewHolder.body=(TextView)convertView.findViewById(R.id.body);
    viewHolder.forward=(ImageView)convertView.findViewById(R.id.forward);
    convertView.setTag(viewHolder);
  }
 else {
    viewHolder=(ViewHolder)convertView.getTag();
  }
  final Reply r=items.get(position);
  fragment.requestUserAvatar(r.getUser(),viewHolder.gravatar,0);
  viewHolder.userName.setText(r.getUser().getLogin());
  viewHolder.replyAt.setText(""String_Node_Str"" + getCreatedTime(r.getCreatedAt()) + ""String_Node_Str""+ getContext().getString(R.string.fragment_reply));
  viewHolder.floor.setText(position + ""String_Node_Str"" + fragment.getString(R.string.reply_list_unit));
  if (HtmlUtil.existsImg(r.getBodyHTML())) {
    fragment.executeRetrieveSpannedTask(viewHolder.body,r.getBodyHTML());
  }
 else {
    viewHolder.body.setText(Html.fromHtml(r.getBodyHTML()));
  }
  viewHolder.gravatar.setOnClickListener(new OnClickListener(){
    @Override public void onClick(    View v){
      fragment.visitUserProfile(r.getUser());
    }
  }
);
  return convertView;
}",0.9773444221393748
11942,"private void refreshPage(List<Topic> topics,Node node){
  initializeNode(node);
  TopicAdapter adapter=new TopicAdapter(this,getActivity(),R.layout.topic_item,R.id.title,topics);
  setListAdapter(adapter);
  getListView().setDivider(getResources().getDrawable(R.drawable.list_divider));
  getListView().setDividerHeight(1);
}","private void refreshPage(List<Topic> topics,Node node){
  initializeNode(node);
  TopicAdapter adapter=new TopicAdapter(this,getActivity(),R.layout.topic_item,R.id.title,topics);
  topicList.setAdapter(adapter);
  topicList.setOnItemClickListener(new OnItemClickListener(){
    @Override public void onItemClick(    AdapterView<?> parent,    View v,    int position,    long id){
      listener.onTopicSelected(((TopicAdapter)((HeaderViewListAdapter)parent.getAdapter()).getWrappedAdapter()).getItems(),position - 1);
    }
  }
);
}",0.5297549591598599
11943,"private void initializeNode(Node node){
  if (nodeSection == null) {
    nodeSection=(TextView)LayoutInflater.from(getActivity()).inflate(R.layout.node_section_header,null);
    getListView().addHeaderView(nodeSection,null,false);
  }
  nodeSection.setText(node.getName());
}","private void initializeNode(Node node){
  if (nodeSection == null) {
    nodeSection=(TextView)LayoutInflater.from(getActivity()).inflate(R.layout.node_section_header,null);
  }
  topicList.addHeaderView(nodeSection,null,false);
  nodeSection.setText(node.getName());
}",0.6727941176470589
11944,"@Override public View getView(int position,View convertView,ViewGroup parent){
  ViewHolder viewHolder;
  if (convertView == null) {
    viewHolder=new ViewHolder();
    convertView=LayoutInflater.from(context).inflate(resource,null);
    viewHolder.gravatar=(ImageView)convertView.findViewById(R.id.gravatar);
    viewHolder.userName=(TextView)convertView.findViewById(R.id.user_name);
    viewHolder.floor=(TextView)convertView.findViewById(R.id.floor);
    viewHolder.body=(TextView)convertView.findViewById(R.id.body);
    viewHolder.forward=(ImageView)convertView.findViewById(R.id.forward);
    viewHolder.forward.setOnClickListener(new OnClickListener(){
      @Override public void onClick(      View v){
        Toast.makeText(getApplicationContext(),""String_Node_Str"",Toast.LENGTH_SHORT).show();
      }
    }
);
    convertView.setTag(viewHolder);
  }
 else {
    viewHolder=(ViewHolder)convertView.getTag();
  }
  Reply r=items.get(position);
  String avatar=r.getUser().getAvatarUrl();
  if (TextUtils.isEmpty(avatar)) {
    viewHolder.gravatar.setImageResource(R.drawable.default_gravatar);
  }
 else {
    Bitmap ava=((RCApplication)getApplication()).getImgLoader().load(avatar,viewHolder.gravatar);
    if (ava != null) {
      viewHolder.gravatar.setImageBitmap(ava);
    }
 else {
      viewHolder.gravatar.setImageResource(R.drawable.default_gravatar);
    }
  }
  viewHolder.userName.setText(r.getUser().getLogin());
  viewHolder.floor.setText(position + 1 + ""String_Node_Str""+ ""String_Node_Str"");
  viewHolder.body.setText(r.getBody());
  return convertView;
}","@Override public View getView(int position,View convertView,ViewGroup parent){
  ViewHolder viewHolder;
  if (convertView == null) {
    viewHolder=new ViewHolder();
    convertView=LayoutInflater.from(context).inflate(resource,null);
    viewHolder.gravatar=(ImageView)convertView.findViewById(R.id.gravatar);
    viewHolder.userName=(TextView)convertView.findViewById(R.id.user_name);
    viewHolder.floor=(TextView)convertView.findViewById(R.id.floor);
    viewHolder.body=(TextView)convertView.findViewById(R.id.body);
    viewHolder.forward=(ImageView)convertView.findViewById(R.id.forward);
    viewHolder.forward.setOnClickListener(new OnClickListener(){
      @Override public void onClick(      View v){
        Toast.makeText(getApplicationContext(),""String_Node_Str"",Toast.LENGTH_SHORT).show();
      }
    }
);
    convertView.setTag(viewHolder);
  }
 else {
    viewHolder=(ViewHolder)convertView.getTag();
  }
  Reply r=items.get(position);
  String avatar=r.getUser().getAvatarUrl();
  String hash=r.getUser().getGravatarHash();
  if (TextUtils.isEmpty(avatar)) {
    Bitmap ava=((RCApplication)getApplication()).getImgLoader().load(GravatarUtil.getBaseURL(hash),viewHolder.gravatar);
    if (ava != null) {
      viewHolder.gravatar.setImageBitmap(ava);
    }
 else {
      viewHolder.gravatar.setImageResource(R.drawable.default_gravatar);
    }
  }
 else {
    Bitmap ava=((RCApplication)getApplication()).getImgLoader().load(avatar,viewHolder.gravatar);
    if (ava != null) {
      viewHolder.gravatar.setImageBitmap(ava);
    }
 else {
      viewHolder.gravatar.setImageResource(R.drawable.default_gravatar);
    }
  }
  viewHolder.userName.setText(r.getUser().getLogin());
  viewHolder.floor.setText(position + 1 + ""String_Node_Str""+ ""String_Node_Str"");
  viewHolder.body.setText(r.getBody());
  return convertView;
}",0.8725146198830409
11945,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  requestWindowFeature(Window.FEATURE_INDETERMINATE_PROGRESS);
  setActionBarContentView(R.layout.topic_detail_layout);
  addActionBarItem(Type.List,R.id.action_bar_replies);
  t=GlobalResource.INSTANCE.getCurTopics().get(getIntent().getIntExtra(POS,0));
  TextView title=(TextView)findViewById(R.id.title);
  title.setText(t.getTitle());
  ImageView avatar=(ImageView)findViewById(R.id.gravatar);
  Bitmap avatarBitmap=((RCApplication)getApplication()).getImgLoader().load(t.getUser().getAvatarUrl(),avatar);
  if (avatarBitmap != null) {
    avatar.setImageBitmap(avatarBitmap);
  }
  WebView webView=(WebView)findViewById(R.id.body_html);
  webView.getSettings().setJavaScriptEnabled(true);
  webView.getSettings().setBuiltInZoomControls(true);
  webView.getSettings().setDefaultTextEncodingName(""String_Node_Str"");
  webView.loadData(t.getBodyHTML(),""String_Node_Str"",""String_Node_Str"");
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  requestWindowFeature(Window.FEATURE_INDETERMINATE_PROGRESS);
  setActionBarContentView(R.layout.topic_detail_layout);
  addActionBarItem(Type.List,R.id.action_bar_replies);
  t=GlobalResource.INSTANCE.getCurTopics().get(getIntent().getIntExtra(POS,0));
  TextView title=(TextView)findViewById(R.id.title);
  title.setText(t.getTitle());
  ImageView gravatar=(ImageView)findViewById(R.id.gravatar);
  String avatar=t.getUser().getAvatarUrl();
  String hash=t.getUser().getGravatarHash();
  if (TextUtils.isEmpty(avatar)) {
    Bitmap ava=((RCApplication)getApplication()).getImgLoader().load(GravatarUtil.getBaseURL(hash),gravatar);
    if (ava != null) {
      gravatar.setImageBitmap(ava);
    }
 else {
      gravatar.setImageResource(R.drawable.default_gravatar);
    }
  }
 else {
    Bitmap ava=((RCApplication)getApplication()).getImgLoader().load(avatar,gravatar);
    if (ava != null) {
      gravatar.setImageBitmap(ava);
    }
 else {
      gravatar.setImageResource(R.drawable.default_gravatar);
    }
  }
  WebView webView=(WebView)findViewById(R.id.body_html);
  webView.getSettings().setJavaScriptEnabled(true);
  webView.getSettings().setBuiltInZoomControls(true);
  webView.getSettings().setDefaultTextEncodingName(""String_Node_Str"");
  webView.loadData(t.getBodyHTML(),""String_Node_Str"",""String_Node_Str"");
}",0.775206611570248
11946,"private void startTopicsRequest(int nodeId){
  if (request == null) {
    request=new HotTopicsRequest();
  }
  ((RCApplication)getApplication()).getAPIClient().request(request,new HotTopicsCallback());
  setProgressBarIndeterminateVisibility(true);
}","private void startTopicsRequest(int nodeId){
  if (request == null) {
    request=new HotTopicsRequest();
  }
  if (!(nodeId == HOT_TOPICS_NODE_ID)) {
    request.setNodeId(nodeId);
  }
  ((RCApplication)getApplication()).getAPIClient().request(request,new HotTopicsCallback());
  setProgressBarIndeterminateVisibility(true);
}",0.8685121107266436
11947,"@Override public View getView(int position,View convertView,ViewGroup parent){
  ViewHolder viewHolder;
  if (convertView == null) {
    viewHolder=new ViewHolder();
    convertView=LayoutInflater.from(context).inflate(resource,null);
    viewHolder.gravatar=(ImageView)convertView.findViewById(R.id.gravatar);
    viewHolder.title=(TextView)convertView.findViewById(R.id.title);
    viewHolder.replies=(TextView)convertView.findViewById(R.id.reply_count);
    convertView.setTag(viewHolder);
  }
 else {
    viewHolder=(ViewHolder)convertView.getTag();
  }
  Topic t=items.get(position);
  String avatar=t.getUser().getAvatarUrl();
  LogUtil.d(TAG,""String_Node_Str"" + avatar);
  LogUtil.d(TAG,""String_Node_Str"" + t.getUser().getGravatarHash());
  if (TextUtils.isEmpty(avatar)) {
    viewHolder.gravatar.setImageResource(R.drawable.default_gravatar);
  }
 else {
    Bitmap ava=((RCApplication)getApplication()).getImgLoader().load(avatar,viewHolder.gravatar);
    if (ava != null) {
      viewHolder.gravatar.setImageBitmap(ava);
    }
 else {
      viewHolder.gravatar.setImageResource(R.drawable.default_gravatar);
    }
  }
  viewHolder.title.setText(t.getTitle());
  viewHolder.replies.setText(t.getRepliesCount() + ""String_Node_Str"");
  return convertView;
}","@Override public View getView(int position,View convertView,ViewGroup parent){
  ViewHolder viewHolder;
  if (convertView == null) {
    viewHolder=new ViewHolder();
    convertView=LayoutInflater.from(context).inflate(resource,null);
    viewHolder.gravatar=(ImageView)convertView.findViewById(R.id.gravatar);
    viewHolder.title=(TextView)convertView.findViewById(R.id.title);
    viewHolder.replies=(TextView)convertView.findViewById(R.id.reply_count);
    convertView.setTag(viewHolder);
  }
 else {
    viewHolder=(ViewHolder)convertView.getTag();
  }
  Topic t=items.get(position);
  String avatar=t.getUser().getAvatarUrl();
  String hash=t.getUser().getGravatarHash();
  if (TextUtils.isEmpty(avatar)) {
    Bitmap ava=((RCApplication)getApplication()).getImgLoader().load(GravatarUtil.getBaseURL(hash),viewHolder.gravatar);
    if (ava != null) {
      viewHolder.gravatar.setImageBitmap(ava);
    }
 else {
      viewHolder.gravatar.setImageResource(R.drawable.default_gravatar);
    }
  }
 else {
    Bitmap ava=((RCApplication)getApplication()).getImgLoader().load(avatar,viewHolder.gravatar);
    if (ava != null) {
      viewHolder.gravatar.setImageBitmap(ava);
    }
 else {
      viewHolder.gravatar.setImageResource(R.drawable.default_gravatar);
    }
  }
  viewHolder.title.setText(t.getTitle());
  viewHolder.replies.setText(t.getRepliesCount() + ""String_Node_Str"");
  return convertView;
}",0.8089719626168225
11948,"@Override public void parse(String source){
  Log.d(TAG,source);
  try {
    JSONArray jsonReplies=new JSONObject(source).getJSONArray(""String_Node_Str"");
    List<Reply> replies=new ArrayList<Reply>();
    int length=jsonReplies.length();
    for (int i=0; i < length; i++) {
      replies.add(json2Reply(jsonReplies.getJSONObject(i)));
    }
    resp.setReplies(replies);
    resp.setSuccess(true);
  }
 catch (  JSONException e) {
    resp.setSuccess(false);
    e.printStackTrace();
  }
}","@Override public void parse(String source){
  try {
    JSONArray jsonReplies=new JSONObject(source).getJSONArray(""String_Node_Str"");
    List<Reply> replies=new ArrayList<Reply>();
    int length=jsonReplies.length();
    for (int i=0; i < length; i++) {
      replies.add(json2Reply(jsonReplies.getJSONObject(i)));
    }
    resp.setReplies(replies);
    resp.setSuccess(true);
  }
 catch (  JSONException e) {
    resp.setSuccess(false);
    e.printStackTrace();
  }
}",0.9781931464174456
11949,"@Override public String getCacheRelativePathOrURL(){
  return makeCachePath(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
}","@Override public String getCacheRelativePathOrURL(){
  return makeCachePath(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",size + ""String_Node_Str"");
}",0.9235474006116208
11950,"@Override public Map<String,String> getTextParams(RCAPIContext context){
  HashMap<String,String> params=new HashMap<String,String>();
  return params;
}","@Override public Map<String,String> getTextParams(RCAPIContext context){
  HashMap<String,String> params=new HashMap<String,String>();
  params.put(SIZE_KEY,size + ""String_Node_Str"");
  return params;
}",0.7943661971830986
11951,"@Override public long getCacheTime(){
  return 60 * 60;
}","@Override public long getCacheTime(){
  return Cache.EXPIRED;
}",0.8333333333333334
11952,"protected Configuration getConfiguration(IPreferenceStore store,ISelection selection){
  Configuration config=null;
  StructuredSelection structuredSelection=null;
  if (selection instanceof StructuredSelection) {
    structuredSelection=(StructuredSelection)selection;
  }
  if (!isNotSelected(structuredSelection) && !isSelectedSeveral(structuredSelection)) {
    String projectName=getProjectName(structuredSelection);
    String projectRootPath=getWorkspaceRootAbsolutePath(getIWorkspaceRoot()) + StringValue.DirectorySeparator.General + projectName+ StringValue.DirectorySeparator.General;
    String configFilepath=projectRootPath + ""String_Node_Str"";
    File configProperites=new File(configFilepath);
    if (configProperites.exists()) {
      try {
        config=new ConfigurationLoader().load(configFilepath);
      }
 catch (      Exception e) {
        e.printStackTrace();
      }
    }
 else {
      config=new PreferenceLoader(store).getConfig();
    }
    String extConfigFilepath=projectRootPath + ""String_Node_Str"";
    File extConfigXML=new File(extConfigFilepath);
    if (extConfigXML.exists()) {
      try {
        ExtConfiguration extConfig=new ExtConfigurationLoader().load(extConfigFilepath);
        config.isExtensionEnabled=true;
        config.extConfiguration=extConfig;
      }
 catch (      Exception e) {
        e.printStackTrace();
      }
    }
  }
  return config;
}","protected Configuration getConfiguration(IPreferenceStore store,ISelection selection){
  Configuration config=null;
  StructuredSelection structuredSelection=null;
  if (selection instanceof StructuredSelection) {
    structuredSelection=(StructuredSelection)selection;
  }
  if (!isNotSelected(structuredSelection) && !isSelectedSeveral(structuredSelection)) {
    String projectName=getProjectName(structuredSelection);
    String projectRootPath=getIWorkspaceRoot().findMember(projectName).getLocationURI().getPath() + StringValue.DirectorySeparator.General;
    String configFilepath=projectRootPath + ""String_Node_Str"";
    File configProperites=new File(configFilepath);
    if (configProperites.exists()) {
      try {
        config=new ConfigurationLoader().load(configFilepath);
      }
 catch (      Exception e) {
        e.printStackTrace();
      }
    }
 else {
      config=new PreferenceLoader(store).getConfig();
    }
    String extConfigFilepath=projectRootPath + ""String_Node_Str"";
    File extConfigXML=new File(extConfigFilepath);
    if (extConfigXML.exists()) {
      try {
        ExtConfiguration extConfig=new ExtConfigurationLoader().load(extConfigFilepath);
        config.isExtensionEnabled=true;
        config.extConfiguration=extConfig;
      }
 catch (      Exception e) {
        e.printStackTrace();
      }
    }
  }
  return config;
}",0.9521410579345088
11953,"public void run(IAction action){
  store=getIPreferenceStore();
  Configuration config=getConfiguration(store,selection);
  PropertiesLoader props=getPropertiesLoader(config.language);
  StructuredSelection structuredSelection=null;
  InputStream inputStream=null;
  FileOutputStream outputStream=null;
  OutputStreamWriter writer=null;
  String projectName=null;
  String testCaseFileName=null;
  String testCaseCreateFilePath=null;
  String resourcePathForTargetClassFile=null;
  String resourcePathForTestClassFile=null;
  try {
    if (selection instanceof StructuredSelection) {
      structuredSelection=(StructuredSelection)selection;
    }
    if (isNotSelected(structuredSelection)) {
      openWarningForRequired(props);
      return;
    }
 else     if (isSelectedSeveral(structuredSelection)) {
      openWarningForSelectOneOnly(props);
      return;
    }
    projectName=getProjectName(structuredSelection);
    resourcePathForTargetClassFile=getResourcePathForTargetClassFile(structuredSelection);
    String projectRootAbsolutePath=getWorkspaceRootAbsolutePath(getIWorkspaceRoot()) + StringValue.DirectorySeparator.General + projectName+ StringValue.DirectorySeparator.General;
    resourcePathForTestClassFile=resourcePathForTargetClassFile.replaceFirst(config.directoryPathOfProductSourceCode,config.directoryPathOfTestSourceCode).replace(StringValue.FileExtension.JavaFile,StringValue.JUnit.TestClassNameSuffix + StringValue.FileExtension.JavaFile);
    testCaseCreateFilePath=projectRootAbsolutePath + getResourcePathForTargetClassFile(structuredSelection).replace(config.directoryPathOfProductSourceCode,config.directoryPathOfTestSourceCode).replace(StringValue.FileExtension.JavaFile,StringValue.JUnit.TestClassNameSuffix + StringValue.FileExtension.JavaFile);
    testCaseFileName=(getClassNameFromResourcePathForTargetClassFile(resourcePathForTargetClassFile) + StringValue.FileExtension.JavaFile).replace(StringValue.FileExtension.JavaFile,StringValue.JUnit.TestClassNameSuffix + StringValue.FileExtension.JavaFile);
    String testCaseCreateDirPath=testCaseCreateFilePath.replaceFirst(""String_Node_Str"",""String_Node_Str"");
    File testDir=new File(testCaseCreateDirPath);
    String[] dirArr=testCaseCreateDirPath.split(StringValue.DirectorySeparator.General);
    String tmpDirPath=StringValue.Empty;
    String tmpResourceDirPath=StringValue.Empty;
    for (    String each : dirArr) {
      tmpDirPath+=StringValue.DirectorySeparator.General + each;
      File tmpDir=new File(tmpDirPath);
      if (tmpDir.getPath().length() <= projectRootAbsolutePath.length()) {
        continue;
      }
      tmpResourceDirPath+=StringValue.DirectorySeparator.General + each;
      if (!tmpDir.exists()) {
        if (!tmpDir.mkdir()) {
          System.err.println(""String_Node_Str"" + tmpDir.getPath());
        }
        String parentPathOfCreatedDir=projectName + StringValue.DirectorySeparator.General + tmpResourceDirPath+ ""String_Node_Str"";
        if (!ResourceRefreshUtil.refreshLocal(null,parentPathOfCreatedDir)) {
          System.err.println(""String_Node_Str"" + parentPathOfCreatedDir);
        }
      }
    }
    if (!testDir.mkdirs()) {
      System.err.println(""String_Node_Str"");
    }
    String pathOfTestCaseDir=projectName + StringValue.DirectorySeparator.General + resourcePathForTestClassFile+ ""String_Node_Str"";
    if (!ResourceRefreshUtil.refreshLocal(null,pathOfTestCaseDir)) {
      openWarningForResourceRefreshError(props);
      return;
    }
    try {
      File outputIOFile=new File(testCaseCreateDirPath + StringValue.DirectorySeparator.General + testCaseFileName);
      String msg=props.get(Dialog.Common.alreadyExist) + ""String_Node_Str"" + testCaseFileName+ ""String_Node_Str""+ StringValue.LineFeed+ props.get(Dialog.Common.confirmToProceed);
      if (outputIOFile.exists() && !openConfirm(props,msg)) {
        return;
      }
      IResource targetClassResource=getIWorkspaceRoot().findMember(""String_Node_Str"" + projectName + ""String_Node_Str""+ resourcePathForTargetClassFile);
      IFile targetClassFile=(IFile)targetClassResource;
      String absolutePath=projectRootAbsolutePath + StringValue.DirectorySeparator.General;
      config.directoryPathOfProductSourceCode=absolutePath + config.directoryPathOfProductSourceCode;
      config.directoryPathOfTestSourceCode=absolutePath + config.directoryPathOfTestSourceCode;
      String encoding=UniversalDetectorUtil.getDetectedEncoding(EclipseIFileUtil.getInputStreamFrom(targetClassFile));
      InputStream targetInputStream=EclipseIFileUtil.getInputStreamFrom(targetClassFile);
      String sourceCodeString=IOUtil.readAsString(targetInputStream,encoding);
      LineBreakProvider lineBreakProvider=new LineBreakProvider(config,null);
      TestCaseGenerator generator=TestCaseGeneratorFactory.create(config,lineBreakProvider);
      generator.initialize(new ClassMetaExtractor(config).extract(sourceCodeString));
      outputStream=new FileOutputStream(testCaseCreateDirPath + StringValue.DirectorySeparator.General + testCaseFileName);
      String charset=null;
      if (config.outputFileEncoding != null) {
        charset=config.outputFileEncoding;
      }
 else {
        charset=getDetectedCharsetFrom(targetClassFile,config.outputFileEncoding);
      }
      writer=new OutputStreamWriter(outputStream,charset);
      writer.write(generator.getNewTestCaseSourceCode());
    }
 catch (    InvalidPreferenceException ipe) {
      ipe.printStackTrace();
      openWarning(props,props.get(Dialog.Common.invalidPreference));
      return;
    }
catch (    FileNotFoundException fnfe) {
      fnfe.printStackTrace();
    }
 finally {
      IOUtils.closeQuietly(writer);
      IOUtils.closeQuietly(outputStream);
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
 finally {
    IOUtils.closeQuietly(inputStream);
    IOUtils.closeQuietly(outputStream);
    IOUtils.closeQuietly(writer);
  }
  if (!ResourceRefreshUtil.refreshLocal(null,projectName + StringValue.DirectorySeparator.General + resourcePathForTestClassFile+ ""String_Node_Str"")) {
    openWarningForResourceRefreshError(props);
    System.err.println(""String_Node_Str"");
    return;
  }
  int retryCount=0;
  IEditorPart editorPart=null;
  ThreadUtil.sleep(1500);
  while (true) {
    try {
      IProject project=getIProject(projectName);
      IFile testCaseFile=getIFile(project,resourcePathForTestClassFile);
      IWorkbenchPage page=getIWorkbenchPage();
      editorPart=getIEditorPart(page,testCaseFile);
      if (editorPart == null) {
        throw new NullPointerException();
      }
      break;
    }
 catch (    Exception e) {
      retryCount++;
      if (retryCount > 3) {
        break;
      }
      ThreadUtil.sleep(1500);
    }
  }
  editorPart.setFocus();
}","public void run(IAction action){
  store=getIPreferenceStore();
  Configuration config=getConfiguration(store,selection);
  PropertiesLoader props=getPropertiesLoader(config.language);
  StructuredSelection structuredSelection=null;
  InputStream inputStream=null;
  FileOutputStream outputStream=null;
  OutputStreamWriter writer=null;
  String projectName=null;
  String testCaseFileName=null;
  String testCaseCreateFilePath=null;
  String resourcePathForTargetClassFile=null;
  String resourcePathForTestClassFile=null;
  try {
    if (selection instanceof StructuredSelection) {
      structuredSelection=(StructuredSelection)selection;
    }
    if (isNotSelected(structuredSelection)) {
      openWarningForRequired(props);
      return;
    }
 else     if (isSelectedSeveral(structuredSelection)) {
      openWarningForSelectOneOnly(props);
      return;
    }
    projectName=getProjectName(structuredSelection);
    resourcePathForTargetClassFile=getResourcePathForTargetClassFile(structuredSelection);
    String projectRootAbsolutePath=getIWorkspaceRoot().findMember(projectName).getLocationURI().getPath() + StringValue.DirectorySeparator.General;
    resourcePathForTestClassFile=resourcePathForTargetClassFile.replaceFirst(config.directoryPathOfProductSourceCode,config.directoryPathOfTestSourceCode).replace(StringValue.FileExtension.JavaFile,StringValue.JUnit.TestClassNameSuffix + StringValue.FileExtension.JavaFile);
    testCaseCreateFilePath=projectRootAbsolutePath + getResourcePathForTargetClassFile(structuredSelection).replace(config.directoryPathOfProductSourceCode,config.directoryPathOfTestSourceCode).replace(StringValue.FileExtension.JavaFile,StringValue.JUnit.TestClassNameSuffix + StringValue.FileExtension.JavaFile);
    testCaseFileName=(getClassNameFromResourcePathForTargetClassFile(resourcePathForTargetClassFile) + StringValue.FileExtension.JavaFile).replace(StringValue.FileExtension.JavaFile,StringValue.JUnit.TestClassNameSuffix + StringValue.FileExtension.JavaFile);
    String testCaseCreateDirPath=testCaseCreateFilePath.replaceFirst(""String_Node_Str"",""String_Node_Str"");
    File testDir=new File(testCaseCreateDirPath);
    String[] dirArr=testCaseCreateDirPath.split(StringValue.DirectorySeparator.General);
    String tmpDirPath=StringValue.Empty;
    String tmpResourceDirPath=StringValue.Empty;
    for (    String each : dirArr) {
      tmpDirPath+=StringValue.DirectorySeparator.General + each;
      File tmpDir=new File(tmpDirPath);
      if (tmpDir.getPath().length() <= projectRootAbsolutePath.length()) {
        continue;
      }
      tmpResourceDirPath+=StringValue.DirectorySeparator.General + each;
      if (!tmpDir.exists()) {
        if (!tmpDir.mkdir()) {
          System.err.println(""String_Node_Str"" + tmpDir.getPath());
        }
        String parentPathOfCreatedDir=projectName + StringValue.DirectorySeparator.General + tmpResourceDirPath+ ""String_Node_Str"";
        if (!ResourceRefreshUtil.refreshLocal(null,parentPathOfCreatedDir)) {
          System.err.println(""String_Node_Str"" + parentPathOfCreatedDir);
        }
      }
    }
    if (!testDir.mkdirs()) {
      System.err.println(""String_Node_Str"");
    }
    String pathOfTestCaseDir=projectName + StringValue.DirectorySeparator.General + resourcePathForTestClassFile+ ""String_Node_Str"";
    if (!ResourceRefreshUtil.refreshLocal(null,pathOfTestCaseDir)) {
      openWarningForResourceRefreshError(props);
      return;
    }
    try {
      File outputIOFile=new File(testCaseCreateDirPath + StringValue.DirectorySeparator.General + testCaseFileName);
      String msg=props.get(Dialog.Common.alreadyExist) + ""String_Node_Str"" + testCaseFileName+ ""String_Node_Str""+ StringValue.LineFeed+ props.get(Dialog.Common.confirmToProceed);
      if (outputIOFile.exists() && !openConfirm(props,msg)) {
        return;
      }
      IResource targetClassResource=getIWorkspaceRoot().findMember(""String_Node_Str"" + projectName + ""String_Node_Str""+ resourcePathForTargetClassFile);
      IFile targetClassFile=(IFile)targetClassResource;
      String absolutePath=projectRootAbsolutePath + StringValue.DirectorySeparator.General;
      config.directoryPathOfProductSourceCode=absolutePath + config.directoryPathOfProductSourceCode;
      config.directoryPathOfTestSourceCode=absolutePath + config.directoryPathOfTestSourceCode;
      String encoding=UniversalDetectorUtil.getDetectedEncoding(EclipseIFileUtil.getInputStreamFrom(targetClassFile));
      InputStream targetInputStream=EclipseIFileUtil.getInputStreamFrom(targetClassFile);
      String sourceCodeString=IOUtil.readAsString(targetInputStream,encoding);
      LineBreakProvider lineBreakProvider=new LineBreakProvider(config,null);
      TestCaseGenerator generator=TestCaseGeneratorFactory.create(config,lineBreakProvider);
      generator.initialize(new ClassMetaExtractor(config).extract(sourceCodeString));
      outputStream=new FileOutputStream(testCaseCreateDirPath + StringValue.DirectorySeparator.General + testCaseFileName);
      String charset=null;
      if (config.outputFileEncoding != null) {
        charset=config.outputFileEncoding;
      }
 else {
        charset=getDetectedCharsetFrom(targetClassFile,config.outputFileEncoding);
      }
      writer=new OutputStreamWriter(outputStream,charset);
      writer.write(generator.getNewTestCaseSourceCode());
    }
 catch (    InvalidPreferenceException ipe) {
      ipe.printStackTrace();
      openWarning(props,props.get(Dialog.Common.invalidPreference));
      return;
    }
catch (    FileNotFoundException fnfe) {
      fnfe.printStackTrace();
    }
 finally {
      IOUtils.closeQuietly(writer);
      IOUtils.closeQuietly(outputStream);
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
 finally {
    IOUtils.closeQuietly(inputStream);
    IOUtils.closeQuietly(outputStream);
    IOUtils.closeQuietly(writer);
  }
  if (!ResourceRefreshUtil.refreshLocal(null,projectName + StringValue.DirectorySeparator.General + resourcePathForTestClassFile+ ""String_Node_Str"")) {
    openWarningForResourceRefreshError(props);
    System.err.println(""String_Node_Str"");
    return;
  }
  int retryCount=0;
  IEditorPart editorPart=null;
  ThreadUtil.sleep(1500);
  while (true) {
    try {
      IProject project=getIProject(projectName);
      IFile testCaseFile=getIFile(project,resourcePathForTestClassFile);
      IWorkbenchPage page=getIWorkbenchPage();
      editorPart=getIEditorPart(page,testCaseFile);
      if (editorPart == null) {
        throw new NullPointerException();
      }
      break;
    }
 catch (    Exception e) {
      retryCount++;
      if (retryCount > 3) {
        break;
      }
      ThreadUtil.sleep(1500);
    }
  }
  editorPart.setFocus();
}",0.9914846353202518
11954,"public void run(IAction action){
  store=getIPreferenceStore();
  Configuration config=getConfiguration(store,selection);
  PropertiesLoader props=getPropertiesLoader(store.getString(Preference.lang));
  StructuredSelection structuredSelection=null;
  try {
    if (selection instanceof StructuredSelection) {
      structuredSelection=(StructuredSelection)selection;
    }
    if (isNotSelected(structuredSelection)) {
      openWarningForRequired(props);
      return;
    }
 else     if (isSelectedSeveral(structuredSelection)) {
      openWarningForSelectOneOnly(props);
      return;
    }
    String resourcePathForTargetClassFile=getResourcePathForTargetClassFile(structuredSelection).replaceFirst(config.directoryPathOfTestSourceCode,config.directoryPathOfProductSourceCode);
    String resourcePathForTestCaseFile=resourcePathForTargetClassFile.replaceFirst(config.directoryPathOfProductSourceCode,config.directoryPathOfTestSourceCode).replaceFirst(""String_Node_Str"",StringValue.JUnit.TestClassNameSuffix + StringValue.FileExtension.JavaFile);
    String projectName=getProjectName(structuredSelection);
    String projectRootAbsolutePath=getWorkspaceRootAbsolutePath(getIWorkspaceRoot()) + StringValue.DirectorySeparator.General + projectName+ StringValue.DirectorySeparator.General;
    if (!resourcePathForTestCaseFile.matches(""String_Node_Str"" + RegExp.FileExtension.JavaFile)) {
      openWarningForSelectJavaFile(props);
      return;
    }
    String targetClassName=getClassNameFromResourcePathForTargetClassFile(resourcePathForTargetClassFile);
    String testCaseFilename=getTestClassNameFromClassName(targetClassName);
    String msg=props.get(Dialog.Common.confirmToChangeToJUnitVersion3) + ""String_Node_Str"" + testCaseFilename+ ""String_Node_Str"";
    if (testCaseFilename == null || !openConfirm(props,msg)) {
      return;
    }
    System.setProperty(""String_Node_Str"",""String_Node_Str"");
    ForceJUnitVersion3Command.main(new String[]{projectRootAbsolutePath + resourcePathForTargetClassFile});
    ThreadUtil.sleep(200);
    int retryCount=0;
    while (true) {
      try {
        if (!ResourceRefreshUtil.refreshLocal(null,projectName + StringValue.DirectorySeparator.General + resourcePathForTestCaseFile+ ""String_Node_Str"")) {
          openWarningForResourceRefreshError(props);
          System.err.println(""String_Node_Str"");
          return;
        }
        retryCount=0;
        ThreadUtil.sleep(1500);
      }
 catch (      Exception e) {
        retryCount++;
        if (retryCount > 10) {
          break;
        }
        e.printStackTrace();
        ThreadUtil.sleep(1500);
      }
      break;
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}","public void run(IAction action){
  store=getIPreferenceStore();
  Configuration config=getConfiguration(store,selection);
  PropertiesLoader props=getPropertiesLoader(store.getString(Preference.lang));
  StructuredSelection structuredSelection=null;
  try {
    if (selection instanceof StructuredSelection) {
      structuredSelection=(StructuredSelection)selection;
    }
    if (isNotSelected(structuredSelection)) {
      openWarningForRequired(props);
      return;
    }
 else     if (isSelectedSeveral(structuredSelection)) {
      openWarningForSelectOneOnly(props);
      return;
    }
    String resourcePathForTargetClassFile=getResourcePathForTargetClassFile(structuredSelection).replaceFirst(config.directoryPathOfTestSourceCode,config.directoryPathOfProductSourceCode);
    String resourcePathForTestCaseFile=resourcePathForTargetClassFile.replaceFirst(config.directoryPathOfProductSourceCode,config.directoryPathOfTestSourceCode).replaceFirst(""String_Node_Str"",StringValue.JUnit.TestClassNameSuffix + StringValue.FileExtension.JavaFile);
    String projectName=getProjectName(structuredSelection);
    String projectRootAbsolutePath=getIWorkspaceRoot().findMember(projectName).getLocationURI().getPath() + StringValue.DirectorySeparator.General;
    if (!resourcePathForTestCaseFile.matches(""String_Node_Str"" + RegExp.FileExtension.JavaFile)) {
      openWarningForSelectJavaFile(props);
      return;
    }
    String targetClassName=getClassNameFromResourcePathForTargetClassFile(resourcePathForTargetClassFile);
    String testCaseFilename=getTestClassNameFromClassName(targetClassName);
    String msg=props.get(Dialog.Common.confirmToChangeToJUnitVersion3) + ""String_Node_Str"" + testCaseFilename+ ""String_Node_Str"";
    if (testCaseFilename == null || !openConfirm(props,msg)) {
      return;
    }
    System.setProperty(""String_Node_Str"",""String_Node_Str"");
    ForceJUnitVersion3Command.main(new String[]{projectRootAbsolutePath + resourcePathForTargetClassFile});
    ThreadUtil.sleep(200);
    int retryCount=0;
    while (true) {
      try {
        if (!ResourceRefreshUtil.refreshLocal(null,projectName + StringValue.DirectorySeparator.General + resourcePathForTestCaseFile+ ""String_Node_Str"")) {
          openWarningForResourceRefreshError(props);
          System.err.println(""String_Node_Str"");
          return;
        }
        retryCount=0;
        ThreadUtil.sleep(1500);
      }
 catch (      Exception e) {
        retryCount++;
        if (retryCount > 10) {
          break;
        }
        e.printStackTrace();
        ThreadUtil.sleep(1500);
      }
      break;
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}",0.9786205614426472
11955,"public void run(IAction action){
  store=getIPreferenceStore();
  Configuration config=getConfiguration(store,selection);
  PropertiesLoader props=getPropertiesLoader(store.getString(Preference.lang));
  StructuredSelection structuredSelection=null;
  try {
    if (selection instanceof StructuredSelection) {
      structuredSelection=(StructuredSelection)selection;
    }
    if (isNotSelected(structuredSelection)) {
      openWarningForRequired(props);
      return;
    }
 else     if (isSelectedSeveral(structuredSelection)) {
      openWarningForSelectOneOnly(props);
      return;
    }
    String resourcePathForTargetClassFile=getResourcePathForTargetClassFile(structuredSelection).replaceFirst(config.directoryPathOfTestSourceCode,config.directoryPathOfProductSourceCode);
    String resourcePathForTestCaseFile=resourcePathForTargetClassFile.replaceFirst(config.directoryPathOfProductSourceCode,config.directoryPathOfTestSourceCode).replaceFirst(""String_Node_Str"",StringValue.JUnit.TestClassNameSuffix + StringValue.FileExtension.JavaFile);
    String projectName=getProjectName(structuredSelection);
    String projectRootAbsolutePath=getWorkspaceRootAbsolutePath(getIWorkspaceRoot()) + StringValue.DirectorySeparator.General + projectName+ StringValue.DirectorySeparator.General;
    if (!resourcePathForTestCaseFile.matches(""String_Node_Str"" + RegExp.FileExtension.JavaFile)) {
      openWarningForSelectJavaFile(props);
      return;
    }
    String targetClassName=getClassNameFromResourcePathForTargetClassFile(resourcePathForTargetClassFile);
    String testCaseFilename=getTestClassNameFromClassName(targetClassName);
    String msg=props.get(Dialog.Common.confirmToChangeToJUnitVersion4) + ""String_Node_Str"" + testCaseFilename+ ""String_Node_Str"";
    if (testCaseFilename == null || !openConfirm(props,msg)) {
      return;
    }
    System.setProperty(""String_Node_Str"",""String_Node_Str"");
    ForceJUnitVersion4Command.main(new String[]{projectRootAbsolutePath + resourcePathForTargetClassFile});
    ThreadUtil.sleep(200);
    int retryCount=0;
    while (true) {
      try {
        if (!ResourceRefreshUtil.refreshLocal(null,projectName + StringValue.DirectorySeparator.General + resourcePathForTestCaseFile+ ""String_Node_Str"")) {
          openWarningForResourceRefreshError(props);
          System.err.println(""String_Node_Str"");
          return;
        }
        retryCount=0;
        ThreadUtil.sleep(1500);
      }
 catch (      Exception e) {
        retryCount++;
        if (retryCount > 10) {
          break;
        }
        e.printStackTrace();
        ThreadUtil.sleep(1500);
      }
      break;
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}","public void run(IAction action){
  store=getIPreferenceStore();
  Configuration config=getConfiguration(store,selection);
  PropertiesLoader props=getPropertiesLoader(store.getString(Preference.lang));
  StructuredSelection structuredSelection=null;
  try {
    if (selection instanceof StructuredSelection) {
      structuredSelection=(StructuredSelection)selection;
    }
    if (isNotSelected(structuredSelection)) {
      openWarningForRequired(props);
      return;
    }
 else     if (isSelectedSeveral(structuredSelection)) {
      openWarningForSelectOneOnly(props);
      return;
    }
    String resourcePathForTargetClassFile=getResourcePathForTargetClassFile(structuredSelection).replaceFirst(config.directoryPathOfTestSourceCode,config.directoryPathOfProductSourceCode);
    String resourcePathForTestCaseFile=resourcePathForTargetClassFile.replaceFirst(config.directoryPathOfProductSourceCode,config.directoryPathOfTestSourceCode).replaceFirst(""String_Node_Str"",StringValue.JUnit.TestClassNameSuffix + StringValue.FileExtension.JavaFile);
    String projectName=getProjectName(structuredSelection);
    String projectRootAbsolutePath=getIWorkspaceRoot().findMember(projectName).getLocationURI().getPath() + StringValue.DirectorySeparator.General;
    if (!resourcePathForTestCaseFile.matches(""String_Node_Str"" + RegExp.FileExtension.JavaFile)) {
      openWarningForSelectJavaFile(props);
      return;
    }
    String targetClassName=getClassNameFromResourcePathForTargetClassFile(resourcePathForTargetClassFile);
    String testCaseFilename=getTestClassNameFromClassName(targetClassName);
    String msg=props.get(Dialog.Common.confirmToChangeToJUnitVersion4) + ""String_Node_Str"" + testCaseFilename+ ""String_Node_Str"";
    if (testCaseFilename == null || !openConfirm(props,msg)) {
      return;
    }
    System.setProperty(""String_Node_Str"",""String_Node_Str"");
    ForceJUnitVersion4Command.main(new String[]{projectRootAbsolutePath + resourcePathForTargetClassFile});
    ThreadUtil.sleep(200);
    int retryCount=0;
    while (true) {
      try {
        if (!ResourceRefreshUtil.refreshLocal(null,projectName + StringValue.DirectorySeparator.General + resourcePathForTestCaseFile+ ""String_Node_Str"")) {
          openWarningForResourceRefreshError(props);
          System.err.println(""String_Node_Str"");
          return;
        }
        retryCount=0;
        ThreadUtil.sleep(1500);
      }
 catch (      Exception e) {
        retryCount++;
        if (retryCount > 10) {
          break;
        }
        e.printStackTrace();
        ThreadUtil.sleep(1500);
      }
      break;
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}",0.9786205614426472
11956,"public void run(IAction action){
  store=getIPreferenceStore();
  Configuration config=getConfiguration(store,selection);
  PropertiesLoader props=getPropertiesLoader(config.language);
  String resourcePathForTestCaseFile=null;
  StructuredSelection structuredSelection=null;
  try {
    if (selection instanceof StructuredSelection) {
      structuredSelection=(StructuredSelection)selection;
    }
    if (isNotSelected(structuredSelection)) {
      openWarningForRequired(props);
      return;
    }
 else     if (isSelectedSeveral(structuredSelection)) {
      openWarningForSelectOneOnly(props);
      return;
    }
    String projectName=getProjectName(structuredSelection);
    String resourcePathForTargetClassFile=getResourcePathForTargetClassFile(structuredSelection);
    String targetClassName=getClassNameFromResourcePathForTargetClassFile(resourcePathForTargetClassFile);
    if (targetClassName == null) {
      openWarningForSelectJavaFile(props);
      return;
    }
    resourcePathForTestCaseFile=resourcePathForTargetClassFile.replace(config.directoryPathOfProductSourceCode,config.directoryPathOfTestSourceCode).replace(StringValue.FileExtension.JavaFile,StringValue.JUnit.TestClassNameSuffix + StringValue.FileExtension.JavaFile);
    String projectRootAbsolutePath=getWorkspaceRootAbsolutePath(getIWorkspaceRoot()) + StringValue.DirectorySeparator.General + projectName+ StringValue.DirectorySeparator.General;
    String testCaseFileAbsolutePath=projectRootAbsolutePath + resourcePathForTestCaseFile;
    File testCaseIOFile=new File(testCaseFileAbsolutePath);
    if (!testCaseIOFile.exists()) {
      String testCaseFilename=getTestClassNameFromClassName(targetClassName);
      String msg=props.get(Dialog.Common.notExist) + ""String_Node_Str"" + testCaseFilename+ ""String_Node_Str""+ StringValue.LineFeed+ props.get(Dialog.Common.confirmToCreateNewFile);
      if (testCaseFilename != null && openConfirm(props,msg)) {
        new CreateNewTestCaseAction().run(action,selection);
      }
      return;
    }
    int retryCount=0;
    IEditorPart editorPart=null;
    while (true) {
      try {
        IProject project=getIProject(projectName);
        IWorkbenchPage page=getIWorkbenchPage();
        String absolutePath=projectRootAbsolutePath + StringValue.DirectorySeparator.General;
        config.directoryPathOfProductSourceCode=absolutePath + config.directoryPathOfProductSourceCode;
        config.directoryPathOfTestSourceCode=absolutePath + config.directoryPathOfTestSourceCode;
        IFile targetFile=getIFile(project,resourcePathForTargetClassFile);
        String targetFileEncoding=UniversalDetectorUtil.getDetectedEncoding(EclipseIFileUtil.getInputStreamFrom(targetFile));
        String targetSourceCodeString=IOUtil.readAsString(EclipseIFileUtil.getInputStreamFrom(targetFile),targetFileEncoding);
        ClassMeta targetClassMeta=new ClassMetaExtractor(config).extract(targetSourceCodeString);
        IFile testCaseFile=getIFile(project,resourcePathForTestCaseFile);
        String charset=null;
        if (config.outputFileEncoding != null) {
          charset=config.outputFileEncoding;
        }
 else {
          charset=getDetectedCharsetFrom(testCaseFile,config.outputFileEncoding);
        }
        InputStream testCaseFileStream=null;
        String currentTestCodeString=null;
        try {
          testCaseFileStream=new FileInputStream(new File(testCaseFileAbsolutePath));
          currentTestCodeString=IOUtils.toString(testCaseFileStream,charset);
        }
  finally {
          IOUtils.closeQuietly(testCaseFileStream);
        }
        CurrentLineBreak currentLineBreak=CurrentLineBreakDetector.detect(currentTestCodeString);
        LineBreakProvider lineBreakProvider=new LineBreakProvider(config,currentLineBreak);
        TestCaseGenerator generator=TestCaseGeneratorFactory.create(config,lineBreakProvider);
        String newTestCodeString=generator.initialize(targetClassMeta).getTestCaseSourceCodeWithLackingTestMethod(currentTestCodeString);
        OutputStreamWriter writer=null;
        FileOutputStream outputStream=null;
        try {
          outputStream=new FileOutputStream(testCaseIOFile);
          writer=new OutputStreamWriter(outputStream,charset);
          writer.write(newTestCodeString);
        }
  finally {
          IOUtils.closeQuietly(writer);
          IOUtils.closeQuietly(outputStream);
        }
        if (!ResourceRefreshUtil.refreshLocal(null,projectName + StringValue.DirectorySeparator.General + resourcePathForTestCaseFile+ ""String_Node_Str"")) {
          openWarningForResourceRefreshError(props);
          System.err.println(""String_Node_Str"");
          return;
        }
        retryCount=0;
        ThreadUtil.sleep(1500);
        while (true) {
          try {
            editorPart=getIEditorPart(page,testCaseFile);
            if (editorPart == null) {
              throw new NullPointerException();
            }
            break;
          }
 catch (          Exception e) {
            retryCount++;
            if (retryCount > 3) {
              break;
            }
            ThreadUtil.sleep(1500);
          }
        }
        editorPart.setFocus();
      }
 catch (      Exception e) {
        retryCount++;
        if (retryCount > 10) {
          break;
        }
        e.printStackTrace();
        ThreadUtil.sleep(1500);
      }
      break;
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}","public void run(IAction action){
  store=getIPreferenceStore();
  Configuration config=getConfiguration(store,selection);
  PropertiesLoader props=getPropertiesLoader(config.language);
  String resourcePathForTestCaseFile=null;
  StructuredSelection structuredSelection=null;
  try {
    if (selection instanceof StructuredSelection) {
      structuredSelection=(StructuredSelection)selection;
    }
    if (isNotSelected(structuredSelection)) {
      openWarningForRequired(props);
      return;
    }
 else     if (isSelectedSeveral(structuredSelection)) {
      openWarningForSelectOneOnly(props);
      return;
    }
    String projectName=getProjectName(structuredSelection);
    String resourcePathForTargetClassFile=getResourcePathForTargetClassFile(structuredSelection);
    String targetClassName=getClassNameFromResourcePathForTargetClassFile(resourcePathForTargetClassFile);
    if (targetClassName == null) {
      openWarningForSelectJavaFile(props);
      return;
    }
    resourcePathForTestCaseFile=resourcePathForTargetClassFile.replace(config.directoryPathOfProductSourceCode,config.directoryPathOfTestSourceCode).replace(StringValue.FileExtension.JavaFile,StringValue.JUnit.TestClassNameSuffix + StringValue.FileExtension.JavaFile);
    String projectRootAbsolutePath=getIWorkspaceRoot().findMember(projectName).getLocationURI().getPath() + StringValue.DirectorySeparator.General;
    String testCaseFileAbsolutePath=projectRootAbsolutePath + resourcePathForTestCaseFile;
    File testCaseIOFile=new File(testCaseFileAbsolutePath);
    if (!testCaseIOFile.exists()) {
      String testCaseFilename=getTestClassNameFromClassName(targetClassName);
      String msg=props.get(Dialog.Common.notExist) + ""String_Node_Str"" + testCaseFilename+ ""String_Node_Str""+ StringValue.LineFeed+ props.get(Dialog.Common.confirmToCreateNewFile);
      if (testCaseFilename != null && openConfirm(props,msg)) {
        new CreateNewTestCaseAction().run(action,selection);
      }
      return;
    }
    int retryCount=0;
    IEditorPart editorPart=null;
    while (true) {
      try {
        IProject project=getIProject(projectName);
        IWorkbenchPage page=getIWorkbenchPage();
        String absolutePath=projectRootAbsolutePath + StringValue.DirectorySeparator.General;
        config.directoryPathOfProductSourceCode=absolutePath + config.directoryPathOfProductSourceCode;
        config.directoryPathOfTestSourceCode=absolutePath + config.directoryPathOfTestSourceCode;
        IFile targetFile=getIFile(project,resourcePathForTargetClassFile);
        String targetFileEncoding=UniversalDetectorUtil.getDetectedEncoding(EclipseIFileUtil.getInputStreamFrom(targetFile));
        String targetSourceCodeString=IOUtil.readAsString(EclipseIFileUtil.getInputStreamFrom(targetFile),targetFileEncoding);
        ClassMeta targetClassMeta=new ClassMetaExtractor(config).extract(targetSourceCodeString);
        IFile testCaseFile=getIFile(project,resourcePathForTestCaseFile);
        String charset=null;
        if (config.outputFileEncoding != null) {
          charset=config.outputFileEncoding;
        }
 else {
          charset=getDetectedCharsetFrom(testCaseFile,config.outputFileEncoding);
        }
        InputStream testCaseFileStream=null;
        String currentTestCodeString=null;
        try {
          testCaseFileStream=new FileInputStream(new File(testCaseFileAbsolutePath));
          currentTestCodeString=IOUtils.toString(testCaseFileStream,charset);
        }
  finally {
          IOUtils.closeQuietly(testCaseFileStream);
        }
        CurrentLineBreak currentLineBreak=CurrentLineBreakDetector.detect(currentTestCodeString);
        LineBreakProvider lineBreakProvider=new LineBreakProvider(config,currentLineBreak);
        TestCaseGenerator generator=TestCaseGeneratorFactory.create(config,lineBreakProvider);
        String newTestCodeString=generator.initialize(targetClassMeta).getTestCaseSourceCodeWithLackingTestMethod(currentTestCodeString);
        OutputStreamWriter writer=null;
        FileOutputStream outputStream=null;
        try {
          outputStream=new FileOutputStream(testCaseIOFile);
          writer=new OutputStreamWriter(outputStream,charset);
          writer.write(newTestCodeString);
        }
  finally {
          IOUtils.closeQuietly(writer);
          IOUtils.closeQuietly(outputStream);
        }
        if (!ResourceRefreshUtil.refreshLocal(null,projectName + StringValue.DirectorySeparator.General + resourcePathForTestCaseFile+ ""String_Node_Str"")) {
          openWarningForResourceRefreshError(props);
          System.err.println(""String_Node_Str"");
          return;
        }
        retryCount=0;
        ThreadUtil.sleep(1500);
        while (true) {
          try {
            editorPart=getIEditorPart(page,testCaseFile);
            if (editorPart == null) {
              throw new NullPointerException();
            }
            break;
          }
 catch (          Exception e) {
            retryCount++;
            if (retryCount > 3) {
              break;
            }
            ThreadUtil.sleep(1500);
          }
        }
        editorPart.setFocus();
      }
 catch (      Exception e) {
        retryCount++;
        if (retryCount > 10) {
          break;
        }
        e.printStackTrace();
        ThreadUtil.sleep(1500);
      }
      break;
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}",0.9894252873563218
11957,"public void run(IAction action){
  store=getIPreferenceStore();
  Configuration config=getConfiguration(store,selection);
  PropertiesLoader props=getPropertiesLoader(store.getString(Preference.lang));
  StructuredSelection structuredSelection=null;
  try {
    if (selection instanceof StructuredSelection) {
      structuredSelection=(StructuredSelection)selection;
    }
    if (isNotSelected(structuredSelection)) {
      openWarningForRequired(props);
      return;
    }
 else     if (isSelectedSeveral(structuredSelection)) {
      openWarningForSelectOneOnly(props);
      return;
    }
    String resourcePathForTestClassFile=getResourcePathForTargetClassFile(structuredSelection);
    String projectName=getProjectName(structuredSelection);
    String projectRootPath=getWorkspaceRootAbsolutePath(getIWorkspaceRoot()) + StringValue.DirectorySeparator.General + projectName+ StringValue.DirectorySeparator.General;
    if (!resourcePathForTestClassFile.matches(""String_Node_Str"" + RegExp.FileExtension.JavaFile)) {
      openWarningForSelectJavaFile(props);
      return;
    }
    String resourcePathForTargetClassFile=resourcePathForTestClassFile.replaceFirst(config.directoryPathOfTestSourceCode,config.directoryPathOfProductSourceCode);
    File openTargetIOFile=new File(projectRootPath + resourcePathForTargetClassFile);
    if (!openTargetIOFile.exists()) {
      return;
    }
    int retryCount=0;
    IEditorPart editorPart=null;
    while (true) {
      try {
        IProject project=getIProject(projectName);
        IWorkbenchPage page=getIWorkbenchPage();
        IFile targetClassFile=getIFile(project,resourcePathForTargetClassFile);
        editorPart=getIEditorPart(page,targetClassFile);
        editorPart.setFocus();
      }
 catch (      Exception e) {
        e.printStackTrace();
        retryCount++;
        if (retryCount > 10) {
          break;
        }
        ThreadUtil.sleep(1500);
      }
      break;
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}","public void run(IAction action){
  store=getIPreferenceStore();
  Configuration config=getConfiguration(store,selection);
  PropertiesLoader props=getPropertiesLoader(store.getString(Preference.lang));
  StructuredSelection structuredSelection=null;
  try {
    if (selection instanceof StructuredSelection) {
      structuredSelection=(StructuredSelection)selection;
    }
    if (isNotSelected(structuredSelection)) {
      openWarningForRequired(props);
      return;
    }
 else     if (isSelectedSeveral(structuredSelection)) {
      openWarningForSelectOneOnly(props);
      return;
    }
    String resourcePathForTestClassFile=getResourcePathForTargetClassFile(structuredSelection);
    String projectName=getProjectName(structuredSelection);
    String projectRootPath=getIWorkspaceRoot().findMember(projectName).getLocationURI().getPath() + StringValue.DirectorySeparator.General;
    if (!resourcePathForTestClassFile.matches(""String_Node_Str"" + RegExp.FileExtension.JavaFile)) {
      openWarningForSelectJavaFile(props);
      return;
    }
    String resourcePathForTargetClassFile=resourcePathForTestClassFile.replaceFirst(config.directoryPathOfTestSourceCode,config.directoryPathOfProductSourceCode);
    File openTargetIOFile=new File(projectRootPath + resourcePathForTargetClassFile);
    if (!openTargetIOFile.exists()) {
      return;
    }
    int retryCount=0;
    IEditorPart editorPart=null;
    while (true) {
      try {
        IProject project=getIProject(projectName);
        IWorkbenchPage page=getIWorkbenchPage();
        IFile targetClassFile=getIFile(project,resourcePathForTargetClassFile);
        editorPart=getIEditorPart(page,targetClassFile);
        editorPart.setFocus();
      }
 catch (      Exception e) {
        e.printStackTrace();
        retryCount++;
        if (retryCount > 10) {
          break;
        }
        ThreadUtil.sleep(1500);
      }
      break;
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}",0.9666750187922828
11958,"public ClassMeta extract(String sourceCodeString){
  Assertion.on(""String_Node_Str"").mustNotBeNull(sourceCodeString);
  ClassMeta meta=new ClassMeta();
  String modifiedSourceCodeString=TrimFilterUtil.doAllFilters(sourceCodeString);
  Matcher matcherGroupingPackageName=RegExp.PatternObject.Pacakge_Group.matcher(modifiedSourceCodeString);
  if (matcherGroupingPackageName.find()) {
    meta.packageName=matcherGroupingPackageName.group(1);
  }
  String outOfBrace=modifiedSourceCodeString.split(""String_Node_Str"")[0];
  int lenForOutOfBrace=outOfBrace.length();
  StringBuilder bufForOutOfBrace=new StringBuilder();
  boolean isInsideOfGenerics=false;
  int depth=0;
  for (int i=0; i < lenForOutOfBrace; i++) {
    char current=outOfBrace.charAt(i);
    if (current == '<') {
      isInsideOfGenerics=true;
      depth++;
    }
    if (current == '>') {
      depth--;
      if (depth <= 0) {
        isInsideOfGenerics=false;
        continue;
      }
    }
    if (!isInsideOfGenerics) {
      bufForOutOfBrace.append(current);
    }
  }
  String outOfBraceWithoutGenerics=bufForOutOfBrace.toString();
  String[] splittedBySpace=outOfBraceWithoutGenerics.split(""String_Node_Str"");
  if (!outOfBrace.matches(""String_Node_Str"") && !outOfBrace.matches(""String_Node_Str"")) {
    meta.isAbstract=true;
  }
 else {
    for (    String each : splittedBySpace) {
      if (each.equals(""String_Node_Str"") || each.equals(""String_Node_Str"") || each.equals(""String_Node_Str"")) {
        meta.isAbstract=true;
        break;
      }
    }
    if (outOfBrace.matches(""String_Node_Str"")) {
      meta.isEnum=true;
    }
  }
  meta.name=splittedBySpace[splittedBySpace.length - 1].replaceFirst(RegExp.Generics,StringValue.Empty);
  for (int i=0; i < splittedBySpace.length; i++) {
    if (splittedBySpace[i].equals(""String_Node_Str"") || splittedBySpace[i].equals(""String_Node_Str"")) {
      meta.name=splittedBySpace[i - 1].replaceFirst(RegExp.Generics,StringValue.Empty);
      break;
    }
  }
  meta.importedList=importedListExtractor.extract(modifiedSourceCodeString);
  constructorMetaExtractor.initialize(meta,modifiedSourceCodeString);
  meta.constructors=constructorMetaExtractor.extract(modifiedSourceCodeString);
  methodMetaExtractor.initialize(meta,modifiedSourceCodeString);
  meta.methods=methodMetaExtractor.extract(modifiedSourceCodeString);
  if (meta.constructors.size() > 0) {
    for (    ConstructorMeta cons : meta.constructors) {
      int len=cons.argNames.size();
      for (int i=0; i < len; i++) {
        if (isDuplicatedVariableName(cons.argNames.get(i))) {
          cons.argNames.set(i,cons.argNames.get(i) + ""String_Node_Str"");
        }
      }
    }
    ConstructorMeta constructor=meta.constructors.get(0);
    for (    MethodMeta method : meta.methods) {
      int len=method.argNames.size();
      for (int i=0; i < len; i++) {
        String targetArgName=method.argNames.get(i);
        List<String> methodArgNames=new ArrayList<String>();
        for (        String methodArgName : method.argNames) {
          if (!targetArgName.equals(methodArgName)) {
            methodArgNames.add(methodArgName);
          }
        }
        method.argNames.set(i,renameIfDuplicatedToConstructorArgNames(targetArgName,constructor.argNames,methodArgNames));
      }
    }
  }
  return meta;
}","public ClassMeta extract(String sourceCodeString){
  Assertion.on(""String_Node_Str"").mustNotBeNull(sourceCodeString);
  ClassMeta meta=new ClassMeta();
  String modifiedSourceCodeString=TrimFilterUtil.doAllFilters(sourceCodeString);
  Matcher matcherGroupingPackageName=RegExp.PatternObject.Pacakge_Group.matcher(modifiedSourceCodeString);
  if (matcherGroupingPackageName.find()) {
    meta.packageName=matcherGroupingPackageName.group(1);
  }
  String outOfBrace=modifiedSourceCodeString.split(""String_Node_Str"")[0];
  int lenForOutOfBrace=outOfBrace.length();
  StringBuilder bufForOutOfBrace=new StringBuilder();
  boolean isInsideOfGenerics=false;
  int depth=0;
  for (int i=0; i < lenForOutOfBrace; i++) {
    char current=outOfBrace.charAt(i);
    if (current == '<') {
      isInsideOfGenerics=true;
      depth++;
    }
    if (current == '>') {
      depth--;
      if (depth <= 0) {
        isInsideOfGenerics=false;
        continue;
      }
    }
    if (!isInsideOfGenerics) {
      bufForOutOfBrace.append(current);
    }
  }
  String outOfBraceWithoutGenerics=bufForOutOfBrace.toString();
  String[] splittedBySpace=outOfBraceWithoutGenerics.split(""String_Node_Str"");
  boolean isClass=outOfBrace.matches(""String_Node_Str"") || outOfBrace.matches(""String_Node_Str"");
  meta.isEnum=outOfBrace.matches(""String_Node_Str"");
  if (!isClass && !meta.isEnum) {
    meta.isAbstract=true;
  }
 else {
    for (    String each : splittedBySpace) {
      if (each.equals(""String_Node_Str"") || each.equals(""String_Node_Str"") || each.equals(""String_Node_Str"")) {
        meta.isAbstract=true;
        break;
      }
    }
  }
  meta.name=splittedBySpace[splittedBySpace.length - 1].replaceFirst(RegExp.Generics,StringValue.Empty);
  for (int i=0; i < splittedBySpace.length; i++) {
    if (splittedBySpace[i].equals(""String_Node_Str"") || splittedBySpace[i].equals(""String_Node_Str"")) {
      meta.name=splittedBySpace[i - 1].replaceFirst(RegExp.Generics,StringValue.Empty);
      break;
    }
  }
  meta.importedList=importedListExtractor.extract(modifiedSourceCodeString);
  constructorMetaExtractor.initialize(meta,modifiedSourceCodeString);
  meta.constructors=constructorMetaExtractor.extract(modifiedSourceCodeString);
  methodMetaExtractor.initialize(meta,modifiedSourceCodeString);
  meta.methods=methodMetaExtractor.extract(modifiedSourceCodeString);
  if (meta.constructors.size() > 0) {
    for (    ConstructorMeta cons : meta.constructors) {
      int len=cons.argNames.size();
      for (int i=0; i < len; i++) {
        if (isDuplicatedVariableName(cons.argNames.get(i))) {
          cons.argNames.set(i,cons.argNames.get(i) + ""String_Node_Str"");
        }
      }
    }
    ConstructorMeta constructor=meta.constructors.get(0);
    for (    MethodMeta method : meta.methods) {
      int len=method.argNames.size();
      for (int i=0; i < len; i++) {
        String targetArgName=method.argNames.get(i);
        List<String> methodArgNames=new ArrayList<String>();
        for (        String methodArgName : method.argNames) {
          if (!targetArgName.equals(methodArgName)) {
            methodArgNames.add(methodArgName);
          }
        }
        method.argNames.set(i,renameIfDuplicatedToConstructorArgNames(targetArgName,constructor.argNames,methodArgNames));
      }
    }
  }
  return meta;
}",0.9514767932489452
11959,"@Override public String trimAll(String src){
  if (src == null) {
    return null;
  }
  src=src.replaceAll(RegExp.CRLF,StringValue.Space);
  int len=src.length();
  boolean isInsideOfString=false;
  boolean isInsideOfChar=false;
  boolean isInsideOfTargetClass=false;
  boolean isInsideOfFirstBrace=false;
  boolean isInsideOfSecondBrace=false;
  Stack<Character> braceStack=new Stack<Character>();
  StringBuilder sb=new StringBuilder();
  for (int i=0; i < len; i++) {
    char current=src.charAt(i);
    if (i > 0) {
      if (current == '""') {
        int count=countPreviousContinuedBackslash(src,i,0);
        if (count % 2 == 0) {
          isInsideOfString=!isInsideOfString;
          sb.append(current);
          continue;
        }
      }
      if (!isInsideOfString && current == '\'') {
        int count=countPreviousContinuedBackslash(src,i,0);
        if (count % 2 == 0) {
          isInsideOfChar=!isInsideOfChar;
          sb.append(current);
          continue;
        }
      }
    }
    if (isInsideOfChar || isInsideOfString) {
      continue;
    }
    if (!isInsideOfTargetClass) {
      sb.append(current);
      if (i >= 6 && src.charAt(i - 6) == ' ' && src.charAt(i - 5) == 'c' && src.charAt(i - 4) == 'l' && src.charAt(i - 3) == 'a' && src.charAt(i - 2) == 's' && src.charAt(i - 1) == 's' && current == ' ') {
        isInsideOfTargetClass=true;
      }
 else       if (i >= 5 && src.charAt(i - 5) == ' ' && src.charAt(i - 4) == 'e' && src.charAt(i - 3) == 'n' && src.charAt(i - 2) == 'u' && src.charAt(i - 1) == 'm' && current == ' ') {
        isInsideOfTargetClass=true;
      }
      continue;
    }
    if (!isInsideOfFirstBrace) {
      sb.append(current);
      if (current == '{') {
        isInsideOfFirstBrace=true;
      }
      continue;
    }
    if (!isInsideOfSecondBrace) {
      sb.append(current);
    }
    if (current == '{') {
      isInsideOfSecondBrace=true;
      braceStack.push(current);
    }
    if (!braceStack.empty() && current == '}') {
      braceStack.pop();
      if (braceStack.empty()) {
        sb.append(current);
      }
    }
    if (braceStack.empty()) {
      isInsideOfSecondBrace=false;
    }
  }
  return sb.toString();
}","@Override public String trimAll(String src){
  if (src == null) {
    return null;
  }
  src=src.replaceAll(RegExp.CRLF,StringValue.Space).replaceAll(RegExp.LF,StringValue.Space);
  int len=src.length();
  boolean isInsideOfString=false;
  boolean isInsideOfChar=false;
  boolean isInsideOfTargetClass=false;
  boolean isInsideOfFirstBrace=false;
  boolean isInsideOfSecondBrace=false;
  Stack<Character> braceStack=new Stack<Character>();
  StringBuilder sb=new StringBuilder();
  for (int i=0; i < len; i++) {
    char current=src.charAt(i);
    if (i > 0) {
      if (current == '""') {
        int count=countPreviousContinuedBackslash(src,i,0);
        if (count % 2 == 0) {
          isInsideOfString=!isInsideOfString;
          sb.append(current);
          continue;
        }
      }
      if (!isInsideOfString && current == '\'') {
        int count=countPreviousContinuedBackslash(src,i,0);
        if (count % 2 == 0) {
          isInsideOfChar=!isInsideOfChar;
          sb.append(current);
          continue;
        }
      }
    }
    if (isInsideOfChar || isInsideOfString) {
      continue;
    }
    if (!isInsideOfTargetClass) {
      sb.append(current);
      if (i >= 6 && (src.charAt(i - 6) == ' ' || src.charAt(i - 6) == ';') && src.charAt(i - 5) == 'c' && src.charAt(i - 4) == 'l' && src.charAt(i - 3) == 'a' && src.charAt(i - 2) == 's' && src.charAt(i - 1) == 's' && current == ' ') {
        isInsideOfTargetClass=true;
      }
 else       if (i >= 5 && (src.charAt(i - 5) == ' ' || src.charAt(i - 5) == ';') && src.charAt(i - 4) == 'e' && src.charAt(i - 3) == 'n' && src.charAt(i - 2) == 'u' && src.charAt(i - 1) == 'm' && current == ' ') {
        isInsideOfTargetClass=true;
      }
      continue;
    }
    if (!isInsideOfFirstBrace) {
      sb.append(current);
      if (current == '{') {
        isInsideOfFirstBrace=true;
      }
      continue;
    }
    if (!isInsideOfSecondBrace) {
      sb.append(current);
    }
    if (current == '{') {
      isInsideOfSecondBrace=true;
      braceStack.push(current);
    }
    if (!braceStack.empty() && current == '}') {
      braceStack.pop();
      if (braceStack.empty()) {
        sb.append(current);
      }
    }
    if (braceStack.empty()) {
      isInsideOfSecondBrace=false;
    }
  }
  return sb.toString();
}",0.9768888888888888
11960,"void appendExtensionSourceCode(StringBuilder buf,String code){
  Assertion.on(""String_Node_Str"").mustNotBeNull(buf);
  Assertion.on(""String_Node_Str"").mustNotBeNull(code);
  String[] separatedListBySemicolon=code.split(StringValue.Semicolon);
  for (  String separatedBySemicolon : separatedListBySemicolon) {
    if (separatedBySemicolon != null && separatedBySemicolon.trim().length() > 0) {
      separatedBySemicolon=separatedBySemicolon.trim().replaceAll(StringValue.CarriageReturn,""String_Node_Str"");
      String[] lines=separatedBySemicolon.split(StringValue.LineFeed);
      for (int i=0; i < (lines.length - 1); i++) {
        String line=lines[i];
        if (line != null && line.trim().length() > 0) {
          appendTabs(buf,2);
          buf.append(line.trim());
          appendLineBreak(buf);
        }
      }
      String lastLine=lines[lines.length - 1];
      if (lastLine != null && lastLine.trim().length() > 0) {
        appendTabs(buf,2);
        buf.append(lastLine.trim());
        if (!lastLine.endsWith(""String_Node_Str"") && !lastLine.endsWith(""String_Node_Str"")) {
          buf.append(StringValue.Semicolon);
        }
        appendLineBreak(buf);
      }
    }
  }
}","void appendExtensionSourceCode(StringBuilder buf,String code){
  Assertion.on(""String_Node_Str"").mustNotBeNull(buf);
  Assertion.on(""String_Node_Str"").mustNotBeNull(code);
  String[] separatedListBySemicolon=code.split(StringValue.Semicolon);
  for (  String separatedBySemicolon : separatedListBySemicolon) {
    if (separatedBySemicolon != null && separatedBySemicolon.trim().length() > 0) {
      separatedBySemicolon=separatedBySemicolon.trim().replaceAll(StringValue.CarriageReturn,StringValue.Empty);
      String[] lines=separatedBySemicolon.split(StringValue.LineFeed);
      for (int i=0; i < (lines.length - 1); i++) {
        String line=lines[i];
        if (line != null && line.trim().length() > 0) {
          appendTabs(buf,2);
          buf.append(line.trim());
          appendLineBreak(buf);
        }
      }
      String lastLine=lines[lines.length - 1];
      if (lastLine != null && lastLine.trim().length() > 0) {
        appendTabs(buf,2);
        buf.append(lastLine.trim());
        if (!lastLine.endsWith(""String_Node_Str"") && !lastLine.endsWith(""String_Node_Str"")) {
          buf.append(StringValue.Semicolon);
        }
        appendLineBreak(buf);
      }
    }
  }
}",0.4766666666666667
11961,"public void run(IAction action){
  store=getIPreferenceStore();
  Configuration config=getConfiguration(store,selection);
  PropertiesLoader props=getPropertiesLoader(config.language);
  StructuredSelection structuredSelection=null;
  InputStream inputStream=null;
  FileOutputStream outputStream=null;
  OutputStreamWriter writer=null;
  String projectName=null;
  String testCaseFileName=null;
  String testCaseCreateFilePath=null;
  String resourcePathForTargetClassFile=null;
  String resourcePathForTestClassFile=null;
  try {
    if (selection instanceof StructuredSelection) {
      structuredSelection=(StructuredSelection)selection;
    }
    if (isNotSelected(structuredSelection)) {
      openWarningForRequired(props);
      return;
    }
 else     if (isSelectedSeveral(structuredSelection)) {
      openWarningForSelectOneOnly(props);
      return;
    }
    projectName=getProjectName(structuredSelection);
    resourcePathForTargetClassFile=getResourcePathForTargetClassFile(structuredSelection);
    String projectRootAbsolutePath=getWorkspaceRootAbsolutePath(getIWorkspaceRoot()) + StringValue.DirectorySeparator.General + projectName+ StringValue.DirectorySeparator.General;
    resourcePathForTestClassFile=resourcePathForTargetClassFile.replaceFirst(config.directoryPathOfProductSourceCode,config.directoryPathOfTestSourceCode).replace(StringValue.FileExtension.JavaFile,StringValue.JUnit.TestClassNameSuffix + StringValue.FileExtension.JavaFile);
    testCaseCreateFilePath=projectRootAbsolutePath + getResourcePathForTargetClassFile(structuredSelection).replace(config.directoryPathOfProductSourceCode,config.directoryPathOfTestSourceCode).replace(StringValue.FileExtension.JavaFile,StringValue.JUnit.TestClassNameSuffix + StringValue.FileExtension.JavaFile);
    testCaseFileName=(getClassNameFromResourcePathForTargetClassFile(resourcePathForTargetClassFile) + StringValue.FileExtension.JavaFile).replace(StringValue.FileExtension.JavaFile,StringValue.JUnit.TestClassNameSuffix + StringValue.FileExtension.JavaFile);
    String testCaseCreateDirPath=testCaseCreateFilePath.replaceFirst(""String_Node_Str"",""String_Node_Str"");
    File testDir=new File(testCaseCreateDirPath);
    String[] dirArr=testCaseCreateDirPath.split(StringValue.DirectorySeparator.General);
    String tmpDirPath=StringValue.Empty;
    String tmpResourceDirPath=StringValue.Empty;
    for (    String each : dirArr) {
      tmpDirPath+=StringValue.DirectorySeparator.General + each;
      File tmpDir=new File(tmpDirPath);
      if (tmpDir.getPath().length() <= projectRootAbsolutePath.length()) {
        continue;
      }
      tmpResourceDirPath+=StringValue.DirectorySeparator.General + each;
      if (!tmpDir.exists()) {
        if (!tmpDir.mkdir()) {
          System.err.println(""String_Node_Str"" + tmpDir.getPath());
        }
        String parentPathOfCreatedDir=projectName + StringValue.DirectorySeparator.General + tmpResourceDirPath+ ""String_Node_Str"";
        if (!ResourceRefreshUtil.refreshLocal(null,parentPathOfCreatedDir)) {
          System.err.println(""String_Node_Str"" + parentPathOfCreatedDir);
        }
      }
    }
    if (!testDir.mkdirs()) {
      System.err.println(""String_Node_Str"");
    }
    String pathOfTestCaseDir=projectName + StringValue.DirectorySeparator.General + resourcePathForTestClassFile+ ""String_Node_Str"";
    if (!ResourceRefreshUtil.refreshLocal(null,pathOfTestCaseDir)) {
      openWarningForResourceRefreshError(props);
      return;
    }
    try {
      File outputIOFile=new File(testCaseCreateDirPath + StringValue.DirectorySeparator.General + testCaseFileName);
      String msg=props.get(Dialog.Common.alreadyExist) + ""String_Node_Str"" + testCaseFileName+ ""String_Node_Str""+ StringValue.LineFeed+ props.get(Dialog.Common.confirmToProceed);
      if (outputIOFile.exists() && !openConfirm(props,msg)) {
        return;
      }
      IResource targetClassResource=getIWorkspaceRoot().findMember(""String_Node_Str"" + projectName + ""String_Node_Str""+ resourcePathForTargetClassFile);
      IFile targetClassFile=(IFile)targetClassResource;
      TestCaseGenerator generator=new DefaultTestCaseGenerator(config);
      String encoding=UniversalDetectorUtil.getDetectedEncoding(EclipseIFileUtil.getInputStreamFrom(targetClassFile));
      String sourceCodeString=IOUtil.readAsString(EclipseIFileUtil.getInputStreamFrom(targetClassFile),encoding);
      generator.initialize(new ClassMetaExtractor(config).extract(sourceCodeString));
      outputStream=new FileOutputStream(testCaseCreateDirPath + StringValue.DirectorySeparator.General + testCaseFileName);
      writer=new OutputStreamWriter(outputStream,getDetectedEncodingFrom(targetClassFile,config.outputFileEncoding));
      writer.write(generator.getNewTestCaseSourceCode());
    }
 catch (    InvalidPreferenceException ipe) {
      ipe.printStackTrace();
      openWarning(props,props.get(Dialog.Common.invalidPreference));
      return;
    }
catch (    FileNotFoundException fnfe) {
      fnfe.printStackTrace();
    }
 finally {
      IOUtil.close(writer);
      IOUtil.close(outputStream);
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
 finally {
    IOUtil.close(inputStream);
    IOUtil.close(outputStream);
    IOUtil.close(writer);
  }
  if (!ResourceRefreshUtil.refreshLocal(null,projectName + StringValue.DirectorySeparator.General + resourcePathForTestClassFile+ ""String_Node_Str"")) {
    openWarningForResourceRefreshError(props);
    System.err.println(""String_Node_Str"");
    return;
  }
  int retryCount=0;
  IEditorPart editorPart=null;
  ThreadUtil.sleep(1500);
  while (true) {
    try {
      IProject project=getIProject(projectName);
      IFile testCaseFile=getIFile(project,resourcePathForTestClassFile);
      IWorkbenchPage page=getIWorkbenchPage();
      editorPart=getIEditorPart(page,testCaseFile);
      if (editorPart == null) {
        throw new NullPointerException();
      }
      break;
    }
 catch (    Exception e) {
      retryCount++;
      if (retryCount > 3) {
        break;
      }
      ThreadUtil.sleep(1500);
    }
  }
  editorPart.setFocus();
}","public void run(IAction action){
  store=getIPreferenceStore();
  Configuration config=getConfiguration(store,selection);
  PropertiesLoader props=getPropertiesLoader(config.language);
  StructuredSelection structuredSelection=null;
  InputStream inputStream=null;
  FileOutputStream outputStream=null;
  OutputStreamWriter writer=null;
  String projectName=null;
  String testCaseFileName=null;
  String testCaseCreateFilePath=null;
  String resourcePathForTargetClassFile=null;
  String resourcePathForTestClassFile=null;
  try {
    if (selection instanceof StructuredSelection) {
      structuredSelection=(StructuredSelection)selection;
    }
    if (isNotSelected(structuredSelection)) {
      openWarningForRequired(props);
      return;
    }
 else     if (isSelectedSeveral(structuredSelection)) {
      openWarningForSelectOneOnly(props);
      return;
    }
    projectName=getProjectName(structuredSelection);
    resourcePathForTargetClassFile=getResourcePathForTargetClassFile(structuredSelection);
    String projectRootAbsolutePath=getWorkspaceRootAbsolutePath(getIWorkspaceRoot()) + StringValue.DirectorySeparator.General + projectName+ StringValue.DirectorySeparator.General;
    resourcePathForTestClassFile=resourcePathForTargetClassFile.replaceFirst(config.directoryPathOfProductSourceCode,config.directoryPathOfTestSourceCode).replace(StringValue.FileExtension.JavaFile,StringValue.JUnit.TestClassNameSuffix + StringValue.FileExtension.JavaFile);
    testCaseCreateFilePath=projectRootAbsolutePath + getResourcePathForTargetClassFile(structuredSelection).replace(config.directoryPathOfProductSourceCode,config.directoryPathOfTestSourceCode).replace(StringValue.FileExtension.JavaFile,StringValue.JUnit.TestClassNameSuffix + StringValue.FileExtension.JavaFile);
    testCaseFileName=(getClassNameFromResourcePathForTargetClassFile(resourcePathForTargetClassFile) + StringValue.FileExtension.JavaFile).replace(StringValue.FileExtension.JavaFile,StringValue.JUnit.TestClassNameSuffix + StringValue.FileExtension.JavaFile);
    String testCaseCreateDirPath=testCaseCreateFilePath.replaceFirst(""String_Node_Str"",""String_Node_Str"");
    File testDir=new File(testCaseCreateDirPath);
    String[] dirArr=testCaseCreateDirPath.split(StringValue.DirectorySeparator.General);
    String tmpDirPath=StringValue.Empty;
    String tmpResourceDirPath=StringValue.Empty;
    for (    String each : dirArr) {
      tmpDirPath+=StringValue.DirectorySeparator.General + each;
      File tmpDir=new File(tmpDirPath);
      if (tmpDir.getPath().length() <= projectRootAbsolutePath.length()) {
        continue;
      }
      tmpResourceDirPath+=StringValue.DirectorySeparator.General + each;
      if (!tmpDir.exists()) {
        if (!tmpDir.mkdir()) {
          System.err.println(""String_Node_Str"" + tmpDir.getPath());
        }
        String parentPathOfCreatedDir=projectName + StringValue.DirectorySeparator.General + tmpResourceDirPath+ ""String_Node_Str"";
        if (!ResourceRefreshUtil.refreshLocal(null,parentPathOfCreatedDir)) {
          System.err.println(""String_Node_Str"" + parentPathOfCreatedDir);
        }
      }
    }
    if (!testDir.mkdirs()) {
      System.err.println(""String_Node_Str"");
    }
    String pathOfTestCaseDir=projectName + StringValue.DirectorySeparator.General + resourcePathForTestClassFile+ ""String_Node_Str"";
    if (!ResourceRefreshUtil.refreshLocal(null,pathOfTestCaseDir)) {
      openWarningForResourceRefreshError(props);
      return;
    }
    try {
      File outputIOFile=new File(testCaseCreateDirPath + StringValue.DirectorySeparator.General + testCaseFileName);
      String msg=props.get(Dialog.Common.alreadyExist) + ""String_Node_Str"" + testCaseFileName+ ""String_Node_Str""+ StringValue.LineFeed+ props.get(Dialog.Common.confirmToProceed);
      if (outputIOFile.exists() && !openConfirm(props,msg)) {
        return;
      }
      IResource targetClassResource=getIWorkspaceRoot().findMember(""String_Node_Str"" + projectName + ""String_Node_Str""+ resourcePathForTargetClassFile);
      IFile targetClassFile=(IFile)targetClassResource;
      String absolutePath=projectRootAbsolutePath + StringValue.DirectorySeparator.General;
      config.directoryPathOfProductSourceCode=absolutePath + config.directoryPathOfProductSourceCode;
      config.directoryPathOfTestSourceCode=absolutePath + config.directoryPathOfTestSourceCode;
      TestCaseGenerator generator=new DefaultTestCaseGenerator(config);
      String encoding=UniversalDetectorUtil.getDetectedEncoding(EclipseIFileUtil.getInputStreamFrom(targetClassFile));
      String sourceCodeString=IOUtil.readAsString(EclipseIFileUtil.getInputStreamFrom(targetClassFile),encoding);
      generator.initialize(new ClassMetaExtractor(config).extract(sourceCodeString));
      outputStream=new FileOutputStream(testCaseCreateDirPath + StringValue.DirectorySeparator.General + testCaseFileName);
      writer=new OutputStreamWriter(outputStream,getDetectedEncodingFrom(targetClassFile,config.outputFileEncoding));
      writer.write(generator.getNewTestCaseSourceCode());
    }
 catch (    InvalidPreferenceException ipe) {
      ipe.printStackTrace();
      openWarning(props,props.get(Dialog.Common.invalidPreference));
      return;
    }
catch (    FileNotFoundException fnfe) {
      fnfe.printStackTrace();
    }
 finally {
      IOUtil.close(writer);
      IOUtil.close(outputStream);
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
 finally {
    IOUtil.close(inputStream);
    IOUtil.close(outputStream);
    IOUtil.close(writer);
  }
  if (!ResourceRefreshUtil.refreshLocal(null,projectName + StringValue.DirectorySeparator.General + resourcePathForTestClassFile+ ""String_Node_Str"")) {
    openWarningForResourceRefreshError(props);
    System.err.println(""String_Node_Str"");
    return;
  }
  int retryCount=0;
  IEditorPart editorPart=null;
  ThreadUtil.sleep(1500);
  while (true) {
    try {
      IProject project=getIProject(projectName);
      IFile testCaseFile=getIFile(project,resourcePathForTestClassFile);
      IWorkbenchPage page=getIWorkbenchPage();
      editorPart=getIEditorPart(page,testCaseFile);
      if (editorPart == null) {
        throw new NullPointerException();
      }
      break;
    }
 catch (    Exception e) {
      retryCount++;
      if (retryCount > 3) {
        break;
      }
      ThreadUtil.sleep(1500);
    }
  }
  editorPart.setFocus();
}",0.9768555466879488
11962,"public void run(IAction action){
  store=getIPreferenceStore();
  Configuration config=getConfiguration(store,selection);
  PropertiesLoader props=getPropertiesLoader(config.language);
  String resourcePathForTestCaseFile=null;
  StructuredSelection structuredSelection=null;
  try {
    if (selection instanceof StructuredSelection) {
      structuredSelection=(StructuredSelection)selection;
    }
    if (isNotSelected(structuredSelection)) {
      openWarningForRequired(props);
      return;
    }
 else     if (isSelectedSeveral(structuredSelection)) {
      openWarningForSelectOneOnly(props);
      return;
    }
    String projectName=getProjectName(structuredSelection);
    String resourcePathForTargetClassFile=getResourcePathForTargetClassFile(structuredSelection);
    String targetClassName=getClassNameFromResourcePathForTargetClassFile(resourcePathForTargetClassFile);
    if (targetClassName == null) {
      openWarningForSelectJavaFile(props);
      return;
    }
    resourcePathForTestCaseFile=resourcePathForTargetClassFile.replace(config.directoryPathOfProductSourceCode,config.directoryPathOfTestSourceCode).replace(StringValue.FileExtension.JavaFile,StringValue.JUnit.TestClassNameSuffix + StringValue.FileExtension.JavaFile);
    String projectRootAbsolutePath=getWorkspaceRootAbsolutePath(getIWorkspaceRoot()) + StringValue.DirectorySeparator.General + projectName+ StringValue.DirectorySeparator.General;
    String testCaseFileAbsolutePath=projectRootAbsolutePath + resourcePathForTestCaseFile;
    File testCaseIOFile=new File(testCaseFileAbsolutePath);
    if (!testCaseIOFile.exists()) {
      String testCaseFilename=getTestClassNameFromClassName(targetClassName);
      String msg=props.get(Dialog.Common.notExist) + ""String_Node_Str"" + testCaseFilename+ ""String_Node_Str""+ StringValue.LineFeed+ props.get(Dialog.Common.confirmToCreateNewFile);
      if (testCaseFilename != null && openConfirm(props,msg)) {
        new CreateNewTestCaseAction().run(action,selection);
      }
      return;
    }
    int retryCount=0;
    IEditorPart editorPart=null;
    while (true) {
      try {
        IProject project=getIProject(projectName);
        IWorkbenchPage page=getIWorkbenchPage();
        IFile targetFile=getIFile(project,resourcePathForTargetClassFile);
        String targetFileEncoding=UniversalDetectorUtil.getDetectedEncoding(EclipseIFileUtil.getInputStreamFrom(targetFile));
        String targetSourceCodeString=IOUtil.readAsString(EclipseIFileUtil.getInputStreamFrom(targetFile),targetFileEncoding);
        ClassMeta targetClassMeta=new ClassMetaExtractor(config).extract(targetSourceCodeString);
        IFile testCaseFile=getIFile(project,resourcePathForTestCaseFile);
        String testCaseFileEncoding=UniversalDetectorUtil.getDetectedEncoding(EclipseIFileUtil.getInputStreamFrom(testCaseFile));
        String currentTestCodeString=IOUtil.readAsString(EclipseIFileUtil.getInputStreamFrom(testCaseFile),testCaseFileEncoding);
        String newTestCodeString=new DefaultTestCaseGenerator(config).initialize(targetClassMeta).getTestCaseSourceCodeWithLackingTestMethod(currentTestCodeString);
        OutputStreamWriter writer=null;
        FileOutputStream outputStream=null;
        try {
          outputStream=new FileOutputStream(testCaseIOFile);
          writer=new OutputStreamWriter(outputStream,getDetectedEncodingFrom(testCaseFile,config.outputFileEncoding));
          writer.write(newTestCodeString);
        }
  finally {
          IOUtil.close(writer);
          IOUtil.close(outputStream);
        }
        if (!ResourceRefreshUtil.refreshLocal(null,projectName + StringValue.DirectorySeparator.General + resourcePathForTestCaseFile+ ""String_Node_Str"")) {
          openWarningForResourceRefreshError(props);
          System.err.println(""String_Node_Str"");
          return;
        }
        retryCount=0;
        ThreadUtil.sleep(1500);
        while (true) {
          try {
            editorPart=getIEditorPart(page,testCaseFile);
            if (editorPart == null) {
              throw new NullPointerException();
            }
            break;
          }
 catch (          Exception e) {
            retryCount++;
            if (retryCount > 3) {
              break;
            }
            ThreadUtil.sleep(1500);
          }
        }
        editorPart.setFocus();
      }
 catch (      Exception e) {
        retryCount++;
        if (retryCount > 10) {
          break;
        }
        e.printStackTrace();
        ThreadUtil.sleep(1500);
      }
      break;
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}","public void run(IAction action){
  store=getIPreferenceStore();
  Configuration config=getConfiguration(store,selection);
  PropertiesLoader props=getPropertiesLoader(config.language);
  String resourcePathForTestCaseFile=null;
  StructuredSelection structuredSelection=null;
  try {
    if (selection instanceof StructuredSelection) {
      structuredSelection=(StructuredSelection)selection;
    }
    if (isNotSelected(structuredSelection)) {
      openWarningForRequired(props);
      return;
    }
 else     if (isSelectedSeveral(structuredSelection)) {
      openWarningForSelectOneOnly(props);
      return;
    }
    String projectName=getProjectName(structuredSelection);
    String resourcePathForTargetClassFile=getResourcePathForTargetClassFile(structuredSelection);
    String targetClassName=getClassNameFromResourcePathForTargetClassFile(resourcePathForTargetClassFile);
    if (targetClassName == null) {
      openWarningForSelectJavaFile(props);
      return;
    }
    resourcePathForTestCaseFile=resourcePathForTargetClassFile.replace(config.directoryPathOfProductSourceCode,config.directoryPathOfTestSourceCode).replace(StringValue.FileExtension.JavaFile,StringValue.JUnit.TestClassNameSuffix + StringValue.FileExtension.JavaFile);
    String projectRootAbsolutePath=getWorkspaceRootAbsolutePath(getIWorkspaceRoot()) + StringValue.DirectorySeparator.General + projectName+ StringValue.DirectorySeparator.General;
    String testCaseFileAbsolutePath=projectRootAbsolutePath + resourcePathForTestCaseFile;
    File testCaseIOFile=new File(testCaseFileAbsolutePath);
    if (!testCaseIOFile.exists()) {
      String testCaseFilename=getTestClassNameFromClassName(targetClassName);
      String msg=props.get(Dialog.Common.notExist) + ""String_Node_Str"" + testCaseFilename+ ""String_Node_Str""+ StringValue.LineFeed+ props.get(Dialog.Common.confirmToCreateNewFile);
      if (testCaseFilename != null && openConfirm(props,msg)) {
        new CreateNewTestCaseAction().run(action,selection);
      }
      return;
    }
    int retryCount=0;
    IEditorPart editorPart=null;
    while (true) {
      try {
        IProject project=getIProject(projectName);
        IWorkbenchPage page=getIWorkbenchPage();
        String absolutePath=projectRootAbsolutePath + StringValue.DirectorySeparator.General;
        config.directoryPathOfProductSourceCode=absolutePath + config.directoryPathOfProductSourceCode;
        config.directoryPathOfTestSourceCode=absolutePath + config.directoryPathOfTestSourceCode;
        IFile targetFile=getIFile(project,resourcePathForTargetClassFile);
        String targetFileEncoding=UniversalDetectorUtil.getDetectedEncoding(EclipseIFileUtil.getInputStreamFrom(targetFile));
        String targetSourceCodeString=IOUtil.readAsString(EclipseIFileUtil.getInputStreamFrom(targetFile),targetFileEncoding);
        ClassMeta targetClassMeta=new ClassMetaExtractor(config).extract(targetSourceCodeString);
        IFile testCaseFile=getIFile(project,resourcePathForTestCaseFile);
        String testCaseFileEncoding=UniversalDetectorUtil.getDetectedEncoding(EclipseIFileUtil.getInputStreamFrom(testCaseFile));
        String currentTestCodeString=IOUtil.readAsString(EclipseIFileUtil.getInputStreamFrom(testCaseFile),testCaseFileEncoding);
        String newTestCodeString=new DefaultTestCaseGenerator(config).initialize(targetClassMeta).getTestCaseSourceCodeWithLackingTestMethod(currentTestCodeString);
        OutputStreamWriter writer=null;
        FileOutputStream outputStream=null;
        try {
          outputStream=new FileOutputStream(testCaseIOFile);
          writer=new OutputStreamWriter(outputStream,getDetectedEncodingFrom(testCaseFile,config.outputFileEncoding));
          writer.write(newTestCodeString);
        }
  finally {
          IOUtil.close(writer);
          IOUtil.close(outputStream);
        }
        if (!ResourceRefreshUtil.refreshLocal(null,projectName + StringValue.DirectorySeparator.General + resourcePathForTestCaseFile+ ""String_Node_Str"")) {
          openWarningForResourceRefreshError(props);
          System.err.println(""String_Node_Str"");
          return;
        }
        retryCount=0;
        ThreadUtil.sleep(1500);
        while (true) {
          try {
            editorPart=getIEditorPart(page,testCaseFile);
            if (editorPart == null) {
              throw new NullPointerException();
            }
            break;
          }
 catch (          Exception e) {
            retryCount++;
            if (retryCount > 3) {
              break;
            }
            ThreadUtil.sleep(1500);
          }
        }
        editorPart.setFocus();
      }
 catch (      Exception e) {
        retryCount++;
        if (retryCount > 10) {
          break;
        }
        e.printStackTrace();
        ThreadUtil.sleep(1500);
      }
      break;
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}",0.9689401888772298
11963,"@Override public String getInstantiationSourceCode(Configuration config,ClassMeta classMeta,ConstructorMeta constructorMeta){
  StringBuilder buf=new StringBuilder();
  if (constructorMeta == null) {
    buf.append(StringValue.Tab);
    buf.append(StringValue.Tab);
    buf.append(classMeta.name);
    buf.append(""String_Node_Str"");
    buf.append(StringValue.Semicolon);
    buf.append(StringValue.CarriageReturn);
    buf.append(StringValue.LineFeed);
  }
 else {
    int len=constructorMeta.argTypes.size();
    for (int i=0; i < len; i++) {
      String typeName=constructorMeta.argTypes.get(i).name;
      boolean isAssigned=false;
      if (config.isExtensionEnabled && config.extConfiguration.extInstantiations != null) {
        for (        ExtInstantiation ins : config.extConfiguration.extInstantiations) {
          if (isCanonicalClassNameUsed(ins.canonicalClassName,typeName,classMeta)) {
            for (            String newImport : ins.importList) {
              classMeta.importedList.add(newImport);
            }
            if (ins.preAssignCode != null && ins.preAssignCode.trim().length() > 0) {
              appendExtensionSourceCode(buf,ins.preAssignCode);
            }
            appendTabs(buf,2);
            buf.append(typeName);
            buf.append(""String_Node_Str"");
            buf.append(constructorMeta.argNames.get(i));
            buf.append(""String_Node_Str"");
            buf.append(ins.assignCode.trim());
            appendCRLF(buf);
            if (ins.postAssignCode != null && ins.postAssignCode.trim().length() > 0) {
              appendExtensionPostAssignSourceCode(buf,ins.postAssignCode,new String[]{""String_Node_Str""},constructorMeta.argNames.get(i));
            }
            isAssigned=true;
          }
        }
      }
      if (!isAssigned) {
        appendTabs(buf,2);
        buf.append(typeName);
        buf.append(""String_Node_Str"");
        buf.append(constructorMeta.argNames.get(i));
        buf.append(""String_Node_Str"");
        if (PrimitiveTypeUtil.isPrimitive(typeName)) {
          buf.append(PrimitiveTypeUtil.getTypeDefaultValue(typeName));
        }
 else {
          buf.append(""String_Node_Str"");
        }
        buf.append(StringValue.Semicolon);
        appendCRLF(buf);
      }
    }
    appendTabs(buf,2);
    buf.append(classMeta.name);
    buf.append(""String_Node_Str"");
    buf.append(classMeta.name);
    buf.append(""String_Node_Str"");
    if (len > 0) {
      buf.append(constructorMeta.argNames.get(0));
    }
    if (len > 1) {
      for (int i=1; i < len; i++) {
        buf.append(StringValue.Comma);
        buf.append(StringValue.Space);
        buf.append(constructorMeta.argNames.get(i));
      }
    }
    buf.append(""String_Node_Str"");
    buf.append(StringValue.Semicolon);
    appendCRLF(buf);
  }
  return buf.toString();
}","@Override public String getInstantiationSourceCode(Configuration config,ClassMeta classMeta,ConstructorMeta constructorMeta){
  StringBuilder buf=new StringBuilder();
  if (constructorMeta == null) {
    appendTabs(buf,2);
    buf.append(classMeta.name);
    buf.append(""String_Node_Str"");
    buf.append(StringValue.Semicolon);
    appendCRLF(buf);
  }
 else {
    int len=constructorMeta.argTypes.size();
    for (int i=0; i < len; i++) {
      String typeName=constructorMeta.argTypes.get(i).name;
      boolean isAssigned=false;
      if (config.isExtensionEnabled && config.extConfiguration.extInstantiations != null) {
        for (        ExtInstantiation ins : config.extConfiguration.extInstantiations) {
          if (isCanonicalClassNameUsed(ins.canonicalClassName,typeName,classMeta)) {
            for (            String newImport : ins.importList) {
              classMeta.importedList.add(newImport);
            }
            if (ins.preAssignCode != null && ins.preAssignCode.trim().length() > 0) {
              appendExtensionSourceCode(buf,ins.preAssignCode);
            }
            appendTabs(buf,2);
            buf.append(typeName);
            buf.append(""String_Node_Str"");
            buf.append(constructorMeta.argNames.get(i));
            buf.append(""String_Node_Str"");
            buf.append(ins.assignCode.trim());
            if (!ins.assignCode.endsWith(StringValue.Semicolon)) {
              buf.append(StringValue.Semicolon);
            }
            appendCRLF(buf);
            if (ins.postAssignCode != null && ins.postAssignCode.trim().length() > 0) {
              appendExtensionPostAssignSourceCode(buf,ins.postAssignCode,new String[]{""String_Node_Str""},constructorMeta.argNames.get(i));
            }
            isAssigned=true;
          }
        }
      }
      if (!isAssigned) {
        appendTabs(buf,2);
        buf.append(typeName);
        buf.append(""String_Node_Str"");
        buf.append(constructorMeta.argNames.get(i));
        buf.append(""String_Node_Str"");
        if (PrimitiveTypeUtil.isPrimitive(typeName)) {
          buf.append(PrimitiveTypeUtil.getTypeDefaultValue(typeName));
        }
 else {
          buf.append(""String_Node_Str"");
        }
        buf.append(StringValue.Semicolon);
        appendCRLF(buf);
      }
    }
    appendTabs(buf,2);
    buf.append(classMeta.name);
    buf.append(""String_Node_Str"");
    buf.append(classMeta.name);
    buf.append(""String_Node_Str"");
    if (len > 0) {
      buf.append(constructorMeta.argNames.get(0));
    }
    if (len > 1) {
      for (int i=1; i < len; i++) {
        buf.append(StringValue.Comma);
        buf.append(StringValue.Space);
        buf.append(constructorMeta.argNames.get(i));
      }
    }
    buf.append(""String_Node_Str"");
    buf.append(StringValue.Semicolon);
    appendCRLF(buf);
  }
  return buf.toString();
}",0.5922671353251318
11964,"static String getInstantiationSourceCode(Configuration config,TestMethodMeta testMethodMeta){
  Assertion.on(""String_Node_Str"").mustNotBeNull(config);
  Assertion.on(""String_Node_Str"").mustNotBeNull(testMethodMeta);
  if (config.isExtensionEnabled && config.extConfiguration.extInstantiations != null) {
    for (    ExtInstantiation ins : config.extConfiguration.extInstantiations) {
      if (isCanonicalClassNameUsed(ins.canonicalClassName,testMethodMeta.classMeta.name,testMethodMeta.classMeta)) {
        for (        String newImport : ins.importList) {
          testMethodMeta.classMeta.importedList.add(newImport);
        }
        StringBuilder buf=new StringBuilder();
        if (ins.preAssignCode != null && ins.preAssignCode.trim().length() > 0) {
          appendExtensionSourceCode(buf,ins.preAssignCode);
        }
        appendTabs(buf,2);
        buf.append(testMethodMeta.classMeta.name);
        buf.append(""String_Node_Str"");
        buf.append(ins.assignCode.trim());
        appendCRLF(buf);
        if (ins.postAssignCode != null && ins.postAssignCode.trim().length() > 0) {
          appendExtensionPostAssignSourceCode(buf,ins.postAssignCode,new String[]{""String_Node_Str""},""String_Node_Str"");
        }
        return buf.toString();
      }
    }
  }
  return new DefaultConstructorGenerator().getFirstInstantiationSourceCode(config,testMethodMeta.classMeta);
}","static String getInstantiationSourceCode(Configuration config,TestMethodMeta testMethodMeta){
  Assertion.on(""String_Node_Str"").mustNotBeNull(config);
  Assertion.on(""String_Node_Str"").mustNotBeNull(testMethodMeta);
  if (config.isExtensionEnabled && config.extConfiguration.extInstantiations != null) {
    for (    ExtInstantiation ins : config.extConfiguration.extInstantiations) {
      if (isCanonicalClassNameUsed(ins.canonicalClassName,testMethodMeta.classMeta.name,testMethodMeta.classMeta)) {
        for (        String newImport : ins.importList) {
          testMethodMeta.classMeta.importedList.add(newImport);
        }
        StringBuilder buf=new StringBuilder();
        if (ins.preAssignCode != null && ins.preAssignCode.trim().length() > 0) {
          appendExtensionSourceCode(buf,ins.preAssignCode);
        }
        appendTabs(buf,2);
        buf.append(testMethodMeta.classMeta.name);
        buf.append(""String_Node_Str"");
        buf.append(ins.assignCode.trim());
        if (!ins.assignCode.trim().endsWith(StringValue.Semicolon)) {
          buf.append(StringValue.Semicolon);
        }
        appendCRLF(buf);
        if (ins.postAssignCode != null && ins.postAssignCode.trim().length() > 0) {
          appendExtensionPostAssignSourceCode(buf,ins.postAssignCode,new String[]{""String_Node_Str""},""String_Node_Str"");
        }
        return buf.toString();
      }
    }
  }
  return new DefaultConstructorGenerator().getFirstInstantiationSourceCode(config,testMethodMeta.classMeta);
}",0.9570299071845996
11965,"public static void main(String[] args) throws Exception {
  initializeConfiguration(config);
  config.junitVersion=JUnitVersion.version3;
  boolean hasFirstArg=(args != null && args.length > 0 && args[0] != null);
  String dirOrFile=hasFirstArg ? args[0] : config.directoryPathOfProductSourceCode;
  List<File> javaFiles=findTargets(config,dirOrFile);
  for (  File javaFile : javaFiles) {
    Stdout.p(""String_Node_Str"" + javaFile.getAbsolutePath());
  }
  if (confirmToExecute() > 0) {
    return;
  }
  TestCaseGenerator testCaseGenerator=TestCaseGeneratorFactory.create(config);
  FileReader fileReader=FileReaderFactory.create();
  for (  File javaFile : javaFiles) {
    File testFile=null;
    String currentTestCaseSourceCode=null;
    try {
      String testFilePath=javaFile.getAbsolutePath().replaceAll(""String_Node_Str"",""String_Node_Str"").replaceFirst(getDirectoryPathOfProductSourceCode(config),getDirectoryPathOfTestSourceCode(config)).replaceFirst(""String_Node_Str"",""String_Node_Str"");
      testFile=new File(testFilePath);
      currentTestCaseSourceCode=fileReader.readAsString(testFile);
    }
 catch (    Exception e) {
    }
    String targetSourceCodeString=fileReader.readAsString(javaFile);
    testCaseGenerator.initialize(targetSourceCodeString);
    String testCodeString=null;
    if (currentTestCaseSourceCode != null) {
      testCodeString=testCaseGenerator.getUnifiedVersionTestCaseSourceCode(testCaseGenerator.getTestCaseSourceCodeWithLackingTestMethod(currentTestCaseSourceCode),JUnitVersion.version3);
    }
 else {
      testCodeString=testCaseGenerator.getNewTestCaseSourceCode();
    }
    FileWriterFactory.create(testFile).writeText(testCodeString);
    Stdout.p(""String_Node_Str"" + testFile.getAbsolutePath());
  }
}","public static void main(String[] args) throws Exception {
  config=getUpdatedConfig(config);
  config.junitVersion=JUnitVersion.version3;
  boolean hasFirstArg=(args != null && args.length > 0 && args[0] != null);
  String dirOrFile=hasFirstArg ? args[0] : config.directoryPathOfProductSourceCode;
  List<File> javaFiles=findTargets(config,dirOrFile);
  for (  File javaFile : javaFiles) {
    Stdout.p(""String_Node_Str"" + javaFile.getAbsolutePath());
  }
  if (confirmToExecute() > 0) {
    return;
  }
  FileReader fileReader=FileReaderFactory.create();
  for (  File javaFile : javaFiles) {
    File testFile=null;
    String currentTestCaseSourceCode=null;
    try {
      String testFilePath=javaFile.getAbsolutePath().replaceAll(""String_Node_Str"",""String_Node_Str"").replaceFirst(getDirectoryPathOfProductSourceCode(config),getDirectoryPathOfTestSourceCode(config)).replaceFirst(""String_Node_Str"",""String_Node_Str"");
      testFile=new File(testFilePath);
      currentTestCaseSourceCode=fileReader.readAsString(testFile);
    }
 catch (    Exception e) {
    }
    CurrentLineBreak currentLineBreak=CurrentLineBreakDetector.detect(currentTestCaseSourceCode);
    LineBreakProvider lineBreakProvider=new LineBreakProvider(config,currentLineBreak);
    TestCaseGenerator testCaseGenerator=TestCaseGeneratorFactory.create(config,lineBreakProvider);
    String targetSourceCodeString=fileReader.readAsString(javaFile);
    testCaseGenerator.initialize(targetSourceCodeString);
    String testCodeString=null;
    if (currentTestCaseSourceCode != null) {
      testCodeString=testCaseGenerator.getUnifiedVersionTestCaseSourceCode(testCaseGenerator.getTestCaseSourceCodeWithLackingTestMethod(currentTestCaseSourceCode),JUnitVersion.version3);
    }
 else {
      testCodeString=testCaseGenerator.getNewTestCaseSourceCode();
    }
    testCodeString=standardizeLineBreak(config,testCodeString);
    FileWriterFactory.create(testFile).writeText(testCodeString);
    Stdout.p(""String_Node_Str"" + testFile.getAbsolutePath());
  }
}",0.8747357293868921
11966,"public static void main(String[] args) throws Exception {
  initializeConfiguration(config);
  config.junitVersion=JUnitVersion.version4;
  boolean hasFirstArg=(args != null && args.length > 0 && args[0] != null);
  String dirOrFile=hasFirstArg ? args[0] : config.directoryPathOfProductSourceCode;
  List<File> javaFiles=findTargets(config,dirOrFile);
  for (  File javaFile : javaFiles) {
    Stdout.p(""String_Node_Str"" + javaFile.getAbsolutePath());
  }
  if (confirmToExecute() > 0) {
    return;
  }
  TestCaseGenerator testCaseGenerator=TestCaseGeneratorFactory.create(config);
  FileReader fileReader=FileReaderFactory.create();
  for (  File javaFile : javaFiles) {
    File testFile=null;
    String currentTestCaseSourceCode=null;
    try {
      String testFilePath=javaFile.getAbsolutePath().replaceAll(""String_Node_Str"",""String_Node_Str"").replaceFirst(getDirectoryPathOfProductSourceCode(config),getDirectoryPathOfTestSourceCode(config)).replaceFirst(""String_Node_Str"",""String_Node_Str"");
      testFile=new File(testFilePath);
      currentTestCaseSourceCode=fileReader.readAsString(testFile);
    }
 catch (    Exception e) {
    }
    String targetSourceCodeString=fileReader.readAsString(javaFile);
    testCaseGenerator.initialize(targetSourceCodeString);
    String testCodeString=null;
    if (currentTestCaseSourceCode != null) {
      testCodeString=testCaseGenerator.getUnifiedVersionTestCaseSourceCode(testCaseGenerator.getTestCaseSourceCodeWithLackingTestMethod(currentTestCaseSourceCode),JUnitVersion.version4);
    }
 else {
      testCodeString=testCaseGenerator.getNewTestCaseSourceCode();
    }
    FileWriterFactory.create(testFile).writeText(testCodeString);
    Stdout.p(""String_Node_Str"" + testFile.getAbsolutePath());
  }
}","public static void main(String[] args) throws Exception {
  config=getUpdatedConfig(config);
  config.junitVersion=JUnitVersion.version4;
  boolean hasFirstArg=(args != null && args.length > 0 && args[0] != null);
  String dirOrFile=hasFirstArg ? args[0] : config.directoryPathOfProductSourceCode;
  List<File> javaFiles=findTargets(config,dirOrFile);
  for (  File javaFile : javaFiles) {
    Stdout.p(""String_Node_Str"" + javaFile.getAbsolutePath());
  }
  if (confirmToExecute() > 0) {
    return;
  }
  FileReader fileReader=FileReaderFactory.create();
  for (  File javaFile : javaFiles) {
    File testFile=null;
    String currentTestCaseSourceCode=null;
    try {
      String testFilePath=javaFile.getAbsolutePath().replaceAll(""String_Node_Str"",""String_Node_Str"").replaceFirst(getDirectoryPathOfProductSourceCode(config),getDirectoryPathOfTestSourceCode(config)).replaceFirst(""String_Node_Str"",""String_Node_Str"");
      testFile=new File(testFilePath);
      currentTestCaseSourceCode=fileReader.readAsString(testFile);
    }
 catch (    Exception e) {
    }
    CurrentLineBreak currentLineBreak=CurrentLineBreakDetector.detect(currentTestCaseSourceCode);
    LineBreakProvider lineBreakProvider=new LineBreakProvider(config,currentLineBreak);
    TestCaseGenerator testCaseGenerator=TestCaseGeneratorFactory.create(config,lineBreakProvider);
    String targetSourceCodeString=fileReader.readAsString(javaFile);
    testCaseGenerator.initialize(targetSourceCodeString);
    String testCodeString=null;
    if (currentTestCaseSourceCode != null) {
      testCodeString=testCaseGenerator.getUnifiedVersionTestCaseSourceCode(testCaseGenerator.getTestCaseSourceCodeWithLackingTestMethod(currentTestCaseSourceCode),JUnitVersion.version4);
    }
 else {
      testCodeString=testCaseGenerator.getNewTestCaseSourceCode();
    }
    testCodeString=standardizeLineBreak(config,testCodeString);
    FileWriterFactory.create(testFile).writeText(testCodeString);
    Stdout.p(""String_Node_Str"" + testFile.getAbsolutePath());
  }
}",0.8747357293868921
11967,"public static void main(String[] args) throws Exception {
  initializeConfiguration(config);
  boolean hasFirstArg=(args != null && args.length > 0 && args[0] != null);
  String dirOrFile=hasFirstArg ? args[0] : config.directoryPathOfProductSourceCode;
  List<File> javaFiles=findTargets(config,dirOrFile);
  for (  File javaFile : javaFiles) {
    if (isNeedToExclude(javaFile)) {
      continue;
    }
    Stdout.p(""String_Node_Str"" + javaFile.getAbsolutePath());
  }
  if (confirmToExecute() > 0) {
    return;
  }
  FileReader fileReader=FileReaderFactory.create();
  TestCaseGenerator testCaseGenerator=TestCaseGeneratorFactory.create(config);
  for (  File javaFile : javaFiles) {
    if (isNeedToExclude(javaFile)) {
      continue;
    }
    File testFile=null;
    String currentTestCaseSourceCode=null;
    try {
      String testFilePath=javaFile.getAbsolutePath().replaceAll(""String_Node_Str"",""String_Node_Str"").replaceFirst(getDirectoryPathOfProductSourceCode(config),getDirectoryPathOfTestSourceCode(config)).replaceFirst(""String_Node_Str"",""String_Node_Str"");
      testFile=new File(testFilePath);
      currentTestCaseSourceCode=fileReader.readAsString(testFile);
    }
 catch (    Exception e) {
    }
    String targetSourceCodeString=fileReader.readAsString(javaFile);
    testCaseGenerator.initialize(targetSourceCodeString);
    String testCodeString=null;
    if (currentTestCaseSourceCode != null) {
      testCodeString=testCaseGenerator.getTestCaseSourceCodeWithLackingTestMethod(currentTestCaseSourceCode);
      if (!testCodeString.equals(currentTestCaseSourceCode)) {
        Stdout.p(""String_Node_Str"" + testFile.getAbsolutePath());
        FileWriterFactory.create(testFile).writeText(testCodeString);
      }
    }
 else {
      testCodeString=testCaseGenerator.getNewTestCaseSourceCode();
      Stdout.p(""String_Node_Str"" + testFile.getAbsolutePath());
      FileWriterFactory.create(testFile).writeText(testCodeString);
    }
  }
}","public static void main(String[] args) throws Exception {
  config=getUpdatedConfig(config);
  boolean hasFirstArg=(args != null && args.length > 0 && args[0] != null);
  String dirOrFile=hasFirstArg ? args[0] : config.directoryPathOfProductSourceCode;
  List<File> javaFiles=findTargets(config,dirOrFile);
  for (  File javaFile : javaFiles) {
    if (isNeedToExclude(javaFile)) {
      continue;
    }
    Stdout.p(""String_Node_Str"" + javaFile.getAbsolutePath());
  }
  if (confirmToExecute() > 0) {
    return;
  }
  FileReader fileReader=FileReaderFactory.create();
  for (  File javaFile : javaFiles) {
    if (isNeedToExclude(javaFile)) {
      continue;
    }
    File testFile=null;
    String currentTestCaseSourceCode=null;
    try {
      String testFilePath=javaFile.getAbsolutePath().replaceAll(""String_Node_Str"",""String_Node_Str"").replaceFirst(getDirectoryPathOfProductSourceCode(config),getDirectoryPathOfTestSourceCode(config)).replaceFirst(""String_Node_Str"",""String_Node_Str"");
      testFile=new File(testFilePath);
      currentTestCaseSourceCode=fileReader.readAsString(testFile);
    }
 catch (    Exception e) {
    }
    CurrentLineBreak currentLineBreak=CurrentLineBreakDetector.detect(currentTestCaseSourceCode);
    LineBreakProvider lineBreakProvider=new LineBreakProvider(config,currentLineBreak);
    TestCaseGenerator testCaseGenerator=TestCaseGeneratorFactory.create(config,lineBreakProvider);
    String targetSourceCodeString=fileReader.readAsString(javaFile);
    testCaseGenerator.initialize(targetSourceCodeString);
    String testCodeString=null;
    if (currentTestCaseSourceCode != null) {
      testCodeString=testCaseGenerator.getTestCaseSourceCodeWithLackingTestMethod(currentTestCaseSourceCode);
      if (!testCodeString.equals(currentTestCaseSourceCode)) {
        testCodeString=standardizeLineBreak(config,testCodeString);
        FileWriterFactory.create(testFile).writeText(testCodeString);
        Stdout.p(""String_Node_Str"" + testFile.getAbsolutePath());
      }
    }
 else {
      testCodeString=testCaseGenerator.getNewTestCaseSourceCode();
      FileWriterFactory.create(testFile).writeText(testCodeString);
      Stdout.p(""String_Node_Str"" + testFile.getAbsolutePath());
    }
  }
}",0.820561637315564
11968,"public static ConstructorGenerator create(){
  return new ConstructorGeneratorImpl();
}","public static ConstructorGenerator create(Configuration config,LineBreakProvider lineBreakProvider){
  return new ConstructorGeneratorImpl(config,lineBreakProvider);
}",0.6850393700787402
11969,"@Override public String getInstantiationSourceCode(Configuration config,ClassMeta classMeta,ConstructorMeta constructorMeta){
  StringBuilder buf=new StringBuilder();
  if (constructorMeta == null) {
    appendTabs(buf,2);
    buf.append(classMeta.name);
    buf.append(""String_Node_Str"");
    buf.append(StringValue.Semicolon);
    appendCRLF(buf);
  }
 else {
    int len=constructorMeta.argTypes.size();
    for (int i=0; i < len; i++) {
      String typeName=constructorMeta.argTypes.get(i).name;
      boolean isAssigned=false;
      if (config.isExtensionEnabled && config.extConfiguration.extInstantiations != null) {
        for (        ExtInstantiation ins : config.extConfiguration.extInstantiations) {
          if (isCanonicalClassNameUsed(ins.canonicalClassName,typeName,classMeta)) {
            for (            String newImport : ins.importList) {
              classMeta.importedList.add(newImport);
            }
            if (ins.preAssignCode != null && ins.preAssignCode.trim().length() > 0) {
              appendExtensionSourceCode(buf,ins.preAssignCode);
            }
            appendTabs(buf,2);
            buf.append(typeName);
            buf.append(""String_Node_Str"");
            buf.append(constructorMeta.argNames.get(i));
            buf.append(""String_Node_Str"");
            buf.append(ins.assignCode.trim());
            if (!ins.assignCode.endsWith(StringValue.Semicolon)) {
              buf.append(StringValue.Semicolon);
            }
            appendCRLF(buf);
            if (ins.postAssignCode != null && ins.postAssignCode.trim().length() > 0) {
              appendExtensionPostAssignSourceCode(buf,ins.postAssignCode,new String[]{""String_Node_Str""},constructorMeta.argNames.get(i));
            }
            isAssigned=true;
          }
        }
      }
      if (!isAssigned) {
        appendTabs(buf,2);
        buf.append(typeName);
        buf.append(""String_Node_Str"");
        buf.append(constructorMeta.argNames.get(i));
        buf.append(""String_Node_Str"");
        if (PrimitiveTypeUtil.isPrimitive(typeName)) {
          buf.append(PrimitiveTypeUtil.getTypeDefaultValue(typeName));
        }
 else {
          buf.append(""String_Node_Str"");
        }
        buf.append(StringValue.Semicolon);
        appendCRLF(buf);
      }
    }
    appendTabs(buf,2);
    buf.append(classMeta.name);
    buf.append(""String_Node_Str"");
    buf.append(classMeta.name);
    buf.append(""String_Node_Str"");
    if (len > 0) {
      buf.append(constructorMeta.argNames.get(0));
    }
    if (len > 1) {
      for (int i=1; i < len; i++) {
        buf.append(StringValue.Comma);
        buf.append(StringValue.Space);
        buf.append(constructorMeta.argNames.get(i));
      }
    }
    buf.append(""String_Node_Str"");
    buf.append(StringValue.Semicolon);
    appendCRLF(buf);
  }
  return buf.toString();
}","@Override public String getInstantiationSourceCode(Configuration config,ClassMeta classMeta,ConstructorMeta constructorMeta){
  StringBuilder buf=new StringBuilder();
  if (constructorMeta == null) {
    appender.appendTabs(buf,2);
    buf.append(classMeta.name);
    buf.append(""String_Node_Str"");
    buf.append(StringValue.Semicolon);
    appender.appendLineBreak(buf);
  }
 else {
    int len=constructorMeta.argTypes.size();
    for (int i=0; i < len; i++) {
      String typeName=constructorMeta.argTypes.get(i).name;
      boolean isAssigned=false;
      if (config.isExtensionEnabled && config.extConfiguration.extInstantiations != null) {
        for (        ExtInstantiation ins : config.extConfiguration.extInstantiations) {
          if (isCanonicalClassNameUsed(ins.canonicalClassName,typeName,classMeta)) {
            for (            String newImport : ins.importList) {
              classMeta.importedList.add(newImport);
            }
            if (ins.preAssignCode != null && ins.preAssignCode.trim().length() > 0) {
              appender.appendExtensionSourceCode(buf,ins.preAssignCode);
            }
            appender.appendTabs(buf,2);
            buf.append(typeName);
            buf.append(""String_Node_Str"");
            buf.append(constructorMeta.argNames.get(i));
            buf.append(""String_Node_Str"");
            buf.append(ins.assignCode.trim());
            if (!ins.assignCode.endsWith(StringValue.Semicolon)) {
              buf.append(StringValue.Semicolon);
            }
            appender.appendLineBreak(buf);
            if (ins.postAssignCode != null && ins.postAssignCode.trim().length() > 0) {
              appender.appendExtensionPostAssignSourceCode(buf,ins.postAssignCode,new String[]{""String_Node_Str""},constructorMeta.argNames.get(i));
            }
            isAssigned=true;
          }
        }
      }
      if (!isAssigned) {
        appender.appendTabs(buf,2);
        buf.append(typeName);
        buf.append(""String_Node_Str"");
        buf.append(constructorMeta.argNames.get(i));
        buf.append(""String_Node_Str"");
        if (PrimitiveTypeUtil.isPrimitive(typeName)) {
          buf.append(PrimitiveTypeUtil.getTypeDefaultValue(typeName));
        }
 else {
          buf.append(""String_Node_Str"");
        }
        buf.append(StringValue.Semicolon);
        appender.appendLineBreak(buf);
      }
    }
    appender.appendTabs(buf,2);
    buf.append(classMeta.name);
    buf.append(""String_Node_Str"");
    buf.append(classMeta.name);
    buf.append(""String_Node_Str"");
    if (len > 0) {
      buf.append(constructorMeta.argNames.get(0));
    }
    if (len > 1) {
      for (int i=1; i < len; i++) {
        buf.append(StringValue.Comma);
        buf.append(StringValue.Space);
        buf.append(constructorMeta.argNames.get(i));
      }
    }
    buf.append(""String_Node_Str"");
    buf.append(StringValue.Semicolon);
    appender.appendLineBreak(buf);
  }
  return buf.toString();
}",0.9769996567112942
11970,"static void appendExtensionPostAssignSourceCode(StringBuilder buf,String code,String[] fromList,String to){
  Assertion.on(""String_Node_Str"").mustNotBeNull(code);
  Assertion.on(""String_Node_Str"").mustNotBeNull(fromList);
  Assertion.on(""String_Node_Str"").mustNotBeNull(to);
  String[] separatedListBySemicolon=code.split(StringValue.Semicolon);
  for (  String separatedBySemicolon : separatedListBySemicolon) {
    if (separatedBySemicolon != null && separatedBySemicolon.trim().length() > 0) {
      separatedBySemicolon=separatedBySemicolon.trim().replaceAll(StringValue.CarriageReturn,""String_Node_Str"");
      String[] lines=separatedBySemicolon.split(StringValue.LineFeed);
      for (      String line : lines) {
        if (line != null && line.trim().length() > 0) {
          appendTabs(buf,2);
          line=line.trim();
          for (          String from : fromList) {
            line=line.replaceAll(from,to);
          }
          buf.append(line);
          if (!line.endsWith(""String_Node_Str"") && !line.endsWith(""String_Node_Str"") && !line.endsWith(""String_Node_Str"")&& !line.endsWith(""String_Node_Str"")) {
            buf.append(StringValue.Semicolon);
          }
          appendCRLF(buf);
        }
      }
    }
  }
}","static void appendExtensionPostAssignSourceCode(StringBuilder buf,String code,String[] fromList,String to){
  Assertion.on(""String_Node_Str"").mustNotBeNull(code);
  Assertion.on(""String_Node_Str"").mustNotBeNull(fromList);
  Assertion.on(""String_Node_Str"").mustNotBeNull(to);
  String[] separatedListBySemicolon=code.split(StringValue.Semicolon);
  for (  String separatedBySemicolon : separatedListBySemicolon) {
    if (separatedBySemicolon != null && separatedBySemicolon.trim().length() > 0) {
      separatedBySemicolon=separatedBySemicolon.trim().replaceAll(StringValue.CarriageReturn,""String_Node_Str"");
      String[] lines=separatedBySemicolon.split(StringValue.LineFeed);
      for (int i=0; i < (lines.length - 1); i++) {
        String line=lines[i];
        if (line != null && line.trim().length() > 0) {
          appendTabs(buf,2);
          buf.append(line.trim());
          appendCRLF(buf);
        }
      }
      String lastLine=lines[lines.length - 1];
      if (lastLine != null && lastLine.trim().length() > 0) {
        appendTabs(buf,2);
        buf.append(lastLine.trim());
        if (!lastLine.endsWith(""String_Node_Str"") && !lastLine.endsWith(""String_Node_Str"")) {
          buf.append(StringValue.Semicolon);
        }
        appendCRLF(buf);
      }
    }
  }
}",0.6803310997240836
11971,"static void appendExtensionSourceCode(StringBuilder buf,String code){
  Assertion.on(""String_Node_Str"").mustNotBeNull(buf);
  Assertion.on(""String_Node_Str"").mustNotBeNull(code);
  String[] separatedListBySemicolon=code.split(StringValue.Semicolon);
  for (  String separatedBySemicolon : separatedListBySemicolon) {
    if (separatedBySemicolon != null && separatedBySemicolon.trim().length() > 0) {
      separatedBySemicolon=separatedBySemicolon.trim().replaceAll(StringValue.CarriageReturn,""String_Node_Str"");
      String[] lines=separatedBySemicolon.split(StringValue.LineFeed);
      for (      String line : lines) {
        if (line != null && line.trim().length() > 0) {
          appendTabs(buf,2);
          buf.append(line.trim());
          if (!line.endsWith(""String_Node_Str"") && !line.endsWith(""String_Node_Str"") && !line.endsWith(""String_Node_Str"")&& !line.endsWith(""String_Node_Str"")) {
            buf.append(StringValue.Semicolon);
          }
          appendCRLF(buf);
        }
      }
    }
  }
}","static void appendExtensionSourceCode(StringBuilder buf,String code){
  Assertion.on(""String_Node_Str"").mustNotBeNull(buf);
  Assertion.on(""String_Node_Str"").mustNotBeNull(code);
  String[] separatedListBySemicolon=code.split(StringValue.Semicolon);
  for (  String separatedBySemicolon : separatedListBySemicolon) {
    if (separatedBySemicolon != null && separatedBySemicolon.trim().length() > 0) {
      separatedBySemicolon=separatedBySemicolon.trim().replaceAll(StringValue.CarriageReturn,""String_Node_Str"");
      String[] lines=separatedBySemicolon.split(StringValue.LineFeed);
      for (int i=0; i < (lines.length - 1); i++) {
        String line=lines[i];
        if (line != null && line.trim().length() > 0) {
          appendTabs(buf,2);
          buf.append(line.trim());
          appendCRLF(buf);
        }
      }
      String lastLine=lines[lines.length - 1];
      if (lastLine != null && lastLine.trim().length() > 0) {
        appendTabs(buf,2);
        buf.append(lastLine.trim());
        if (!lastLine.endsWith(""String_Node_Str"") && !lastLine.endsWith(""String_Node_Str"")) {
          buf.append(StringValue.Semicolon);
        }
        appendCRLF(buf);
      }
    }
  }
}",0.6997294860234445
11972,"protected Configuration loadConfig(){
  Configuration config=new Configuration();
  config.language=language;
  config.outputFileEncoding=outputFileEncoding;
  config.directoryPathOfProductSourceCode=directoryPathOfProductSourceCode;
  config.directoryPathOfTestSourceCode=directoryPathOfTestSourceCode;
  try {
    config.junitVersion=JUnitVersion.valueOf(junitVersion);
  }
 catch (  Exception e) {
    config.junitVersion=JUnitVersion.version4;
  }
  config.testCaseClassNameToExtend=testCaseClassNameToExtend;
  config.isTemplateImplementationRequired=isTemplateImplementationRequired;
  config.target.isAccessorExcluded=target_isAccessorExcluded;
  config.target.isExceptionPatternRequired=target_isExceptionPatternRequired;
  config.target.isPackageLocalMethodRequired=target_isPackageLocalMethodRequired;
  config.target.isProtectedMethodRequired=target_isProtectedMethodRequired;
  config.target.isPublicMethodRequired=target_isPublicMethodRequired;
  config.target.regexpCsvForExclusion=target_regexpCsvForExclusion;
  config.testMethodName.isArgsRequired=testMethodName_isArgsRequired;
  config.testMethodName.isReturnRequired=testMethodName_isReturnRequired;
  config.testMethodName.basicDelimiter=testMethodName_basicDelimiter;
  config.testMethodName.argsAreaPrefix=testMethodName_argsAreaPrefix;
  config.testMethodName.argsAreaDelimiter=testMethodName_argsAreaDelimiter;
  config.testMethodName.returnAreaPrefix=testMethodName_returnAreaPrefix;
  config.testMethodName.returnAreaDelimiter=testMethodName_returnAreaDelimiter;
  config.testMethodName.exceptionAreaPrefix=testMethodName_exceptionAreaPrefix;
  config.testMethodName.exceptionAreaDelimiter=testMethodName_exceptionAreaDelimiter;
  try {
    config.mockObjectFramework=MockObjectFramework.valueOf(mockObjectFramework);
  }
 catch (  Exception e) {
    config.mockObjectFramework=null;
  }
  try {
    config.testingPatternExplicitComment=TestingPatternExplicitComment.valueOf(testingPatternExplicitComment);
  }
 catch (  Exception e) {
    config.testingPatternExplicitComment=null;
  }
  config.isExtensionEnabled=isExtensionEnabled;
  config.extensionConfigXML=extensionConfigXML;
  return config;
}","protected Configuration loadConfig(){
  Configuration config=new Configuration();
  config.language=language;
  config.outputFileEncoding=outputFileEncoding;
  config.directoryPathOfProductSourceCode=directoryPathOfProductSourceCode;
  config.directoryPathOfTestSourceCode=directoryPathOfTestSourceCode;
  try {
    config.junitVersion=JUnitVersion.valueOf(junitVersion);
  }
 catch (  Exception e) {
    config.junitVersion=JUnitVersion.version4;
  }
  config.testCaseClassNameToExtend=testCaseClassNameToExtend;
  config.isTemplateImplementationRequired=isTemplateImplementationRequired;
  config.target.isAccessorExcluded=target_isAccessorExcluded;
  config.target.isExceptionPatternRequired=target_isExceptionPatternRequired;
  config.target.isPackageLocalMethodRequired=target_isPackageLocalMethodRequired;
  config.target.isProtectedMethodRequired=target_isProtectedMethodRequired;
  config.target.isPublicMethodRequired=target_isPublicMethodRequired;
  config.target.regexpCsvForExclusion=target_regexpCsvForExclusion;
  config.testMethodName.isArgsRequired=testMethodName_isArgsRequired;
  config.testMethodName.isReturnRequired=testMethodName_isReturnRequired;
  config.testMethodName.basicDelimiter=testMethodName_basicDelimiter;
  config.testMethodName.argsAreaPrefix=testMethodName_argsAreaPrefix;
  config.testMethodName.argsAreaDelimiter=testMethodName_argsAreaDelimiter;
  config.testMethodName.returnAreaPrefix=testMethodName_returnAreaPrefix;
  config.testMethodName.returnAreaDelimiter=testMethodName_returnAreaDelimiter;
  config.testMethodName.exceptionAreaPrefix=testMethodName_exceptionAreaPrefix;
  config.testMethodName.exceptionAreaDelimiter=testMethodName_exceptionAreaDelimiter;
  try {
    config.mockObjectFramework=MockObjectFramework.valueOf(mockObjectFramework);
  }
 catch (  Exception e) {
    config.mockObjectFramework=null;
  }
  try {
    config.testingPatternExplicitComment=TestingPatternExplicitComment.valueOf(testingPatternExplicitComment);
  }
 catch (  Exception e) {
    config.testingPatternExplicitComment=TestingPatternExplicitComment.None;
  }
  config.isExtensionEnabled=isExtensionEnabled;
  config.extensionConfigXML=extensionConfigXML;
  return config;
}",0.9913360693114456
11973,"static String appendRequiredImportListToSourceCode(String sourceCode,ClassMeta targetClassMeta,Configuration config){
  Assertion.on(""String_Node_Str"").mustNotBeNull(targetClassMeta);
  String dest=sourceCode;
  String oneline=TrimFilterUtil.doAllFilters(sourceCode);
  StringBuilder importedListBuf=new StringBuilder();
  List<String> uniqImportedList=new ArrayList<String>();
  for (  String imported : targetClassMeta.importedList) {
    if (!uniqImportedList.contains(imported.trim())) {
      uniqImportedList.add(imported.trim());
    }
  }
  for (  String imported : uniqImportedList) {
    String newOne=""String_Node_Str"" + imported + ""String_Node_Str"";
    if (!oneline.matches(RegExp.Anything_ZeroOrMore_Min + newOne + RegExp.Anything_ZeroOrMore_Min)) {
      importedListBuf.append(newOne);
      importedListBuf.append(StringValue.CarriageReturn);
      importedListBuf.append(StringValue.LineFeed);
    }
  }
  appendIfNotExists(importedListBuf,oneline,""String_Node_Str"" + targetClassMeta.packageName + ""String_Node_Str""+ targetClassMeta.name+ ""String_Node_Str"");
  if (config.junitVersion == JUnitVersion.version3) {
    appendIfNotExists(importedListBuf,oneline,""String_Node_Str"" + config.testCaseClassNameToExtend + ""String_Node_Str"");
  }
 else   if (config.junitVersion == JUnitVersion.version4) {
    if (!sourceCode.contains(""String_Node_Str"") && !uniqImportedList.contains(""String_Node_Str"")) {
      appendIfNotExists(importedListBuf,oneline,""String_Node_Str"");
    }
    appendIfNotExists(importedListBuf,oneline,""String_Node_Str"");
    appendIfNotExists(importedListBuf,oneline,""String_Node_Str"");
  }
  if (config.mockObjectFramework == MockObjectFramework.EasyMock) {
    appendIfNotExists(importedListBuf,oneline,""String_Node_Str"");
    appendIfNotExists(importedListBuf,oneline,""String_Node_Str"");
  }
 else   if (config.mockObjectFramework == MockObjectFramework.JMock2) {
    appendIfNotExists(importedListBuf,oneline,""String_Node_Str"");
    appendIfNotExists(importedListBuf,oneline,""String_Node_Str"");
    appendIfNotExists(importedListBuf,oneline,""String_Node_Str"");
  }
 else   if (config.mockObjectFramework == MockObjectFramework.JMockit) {
    appendIfNotExists(importedListBuf,oneline,""String_Node_Str"");
    appendIfNotExists(importedListBuf,oneline,""String_Node_Str"");
  }
 else   if (config.mockObjectFramework == MockObjectFramework.Mockito) {
    appendIfNotExists(importedListBuf,oneline,""String_Node_Str"");
  }
  if (importedListBuf.length() > 0) {
    Matcher matcher=RegExp.PatternObject.PackageDefArea_Group.matcher(sourceCode.replaceAll(RegExp.CRLF,StringValue.Space));
    if (matcher.find()) {
      String packageDef=matcher.group(1);
      String CRLF=StringValue.CarriageReturn + StringValue.LineFeed;
      String replacement=packageDef + CRLF + CRLF+ importedListBuf.toString().replaceAll(""String_Node_Str"",StringValue.Empty);
      dest=dest.replaceFirst(packageDef,replacement);
    }
 else {
      dest=importedListBuf.toString() + dest;
    }
  }
  return dest;
}","static String appendRequiredImportListToSourceCode(String sourceCode,ClassMeta targetClassMeta,Configuration config){
  Assertion.on(""String_Node_Str"").mustNotBeNull(targetClassMeta);
  String dest=sourceCode;
  String oneline=TrimFilterUtil.doAllFilters(sourceCode);
  StringBuilder importedListBuf=new StringBuilder();
  List<String> uniqImportedList=new ArrayList<String>();
  for (  String imported : targetClassMeta.importedList) {
    if (!uniqImportedList.contains(imported.trim())) {
      uniqImportedList.add(imported.trim());
    }
  }
  for (  String imported : uniqImportedList) {
    String newOne=""String_Node_Str"" + imported + ""String_Node_Str"";
    if (!oneline.matches(RegExp.Anything_ZeroOrMore_Min + newOne + RegExp.Anything_ZeroOrMore_Min)) {
      importedListBuf.append(newOne);
      importedListBuf.append(StringValue.CarriageReturn);
      importedListBuf.append(StringValue.LineFeed);
    }
  }
  String prefix=targetClassMeta.packageName == null ? ""String_Node_Str"" : targetClassMeta.packageName + ""String_Node_Str"";
  appendIfNotExists(importedListBuf,oneline,""String_Node_Str"" + prefix + targetClassMeta.name+ ""String_Node_Str"");
  if (config.junitVersion == JUnitVersion.version3) {
    appendIfNotExists(importedListBuf,oneline,""String_Node_Str"" + config.testCaseClassNameToExtend + ""String_Node_Str"");
  }
 else   if (config.junitVersion == JUnitVersion.version4) {
    if (!sourceCode.contains(""String_Node_Str"") && !uniqImportedList.contains(""String_Node_Str"")) {
      appendIfNotExists(importedListBuf,oneline,""String_Node_Str"");
    }
    appendIfNotExists(importedListBuf,oneline,""String_Node_Str"");
    appendIfNotExists(importedListBuf,oneline,""String_Node_Str"");
  }
  if (config.mockObjectFramework == MockObjectFramework.EasyMock) {
    appendIfNotExists(importedListBuf,oneline,""String_Node_Str"");
    appendIfNotExists(importedListBuf,oneline,""String_Node_Str"");
  }
 else   if (config.mockObjectFramework == MockObjectFramework.JMock2) {
    appendIfNotExists(importedListBuf,oneline,""String_Node_Str"");
    appendIfNotExists(importedListBuf,oneline,""String_Node_Str"");
    appendIfNotExists(importedListBuf,oneline,""String_Node_Str"");
  }
 else   if (config.mockObjectFramework == MockObjectFramework.JMockit) {
    appendIfNotExists(importedListBuf,oneline,""String_Node_Str"");
    appendIfNotExists(importedListBuf,oneline,""String_Node_Str"");
  }
 else   if (config.mockObjectFramework == MockObjectFramework.Mockito) {
    appendIfNotExists(importedListBuf,oneline,""String_Node_Str"");
  }
  if (importedListBuf.length() > 0) {
    Matcher matcher=RegExp.PatternObject.PackageDefArea_Group.matcher(sourceCode.replaceAll(RegExp.CRLF,StringValue.Space));
    if (matcher.find()) {
      String packageDef=matcher.group(1);
      String CRLF=StringValue.CarriageReturn + StringValue.LineFeed;
      String replacement=packageDef + CRLF + CRLF+ importedListBuf.toString().replaceAll(""String_Node_Str"",StringValue.Empty);
      dest=dest.replaceFirst(packageDef,replacement);
    }
 else {
      dest=importedListBuf.toString() + dest;
    }
  }
  return dest;
}",0.9711209006363192
11974,"@Override public String getNewTestCaseSourceCode(){
  StringBuilder buf=new StringBuilder();
  if (targetClassMeta.packageName != null) {
    buf.append(""String_Node_Str"");
    buf.append(targetClassMeta.packageName);
    buf.append(""String_Node_Str"");
    appendCRLF(buf);
    appendCRLF(buf);
  }
  for (  String imported : targetClassMeta.importedList) {
    buf.append(""String_Node_Str"");
    buf.append(imported);
    buf.append(""String_Node_Str"");
    appendCRLF(buf);
  }
  if (config.testCaseClassNameToExtend != null && config.testCaseClassNameToExtend.trim().length() > 0) {
    if (config.junitVersion == JUnitVersion.version3 || !config.testCaseClassNameToExtend.equals(""String_Node_Str"")) {
      buf.append(""String_Node_Str"");
      buf.append(config.testCaseClassNameToExtend);
      buf.append(""String_Node_Str"");
      appendCRLF(buf);
      appendCRLF(buf);
    }
  }
  buf.append(""String_Node_Str"");
  buf.append(targetClassMeta.name);
  buf.append(""String_Node_Str"");
  if (config.testCaseClassNameToExtend != null && config.testCaseClassNameToExtend.trim().length() > 0) {
    if (config.junitVersion == JUnitVersion.version3 || !config.testCaseClassNameToExtend.equals(""String_Node_Str"")) {
      buf.append(""String_Node_Str"");
      String[] splittedArray=config.testCaseClassNameToExtend.split(""String_Node_Str"");
      buf.append(splittedArray[splittedArray.length - 1]);
      buf.append(""String_Node_Str"");
    }
  }
  buf.append(""String_Node_Str"");
  appendCRLF(buf);
  appendCRLF(buf);
  buf.append(""String_Node_Str"");
  appendCRLF(buf);
  return getTestCaseSourceCodeWithLackingTestMethod(buf.toString());
}","@Override public String getNewTestCaseSourceCode(){
  StringBuilder buf=new StringBuilder();
  if (targetClassMeta.packageName != null && targetClassMeta.packageName.trim().length() > 0) {
    buf.append(""String_Node_Str"");
    buf.append(targetClassMeta.packageName);
    buf.append(""String_Node_Str"");
    appendCRLF(buf);
    appendCRLF(buf);
  }
  for (  String imported : targetClassMeta.importedList) {
    if (imported != null && imported.trim().length() > 0) {
      buf.append(""String_Node_Str"");
      buf.append(imported);
      buf.append(""String_Node_Str"");
      appendCRLF(buf);
    }
  }
  if (config.testCaseClassNameToExtend != null && config.testCaseClassNameToExtend.trim().length() > 0) {
    if (config.junitVersion == JUnitVersion.version3 || !config.testCaseClassNameToExtend.equals(""String_Node_Str"")) {
      buf.append(""String_Node_Str"");
      buf.append(config.testCaseClassNameToExtend);
      buf.append(""String_Node_Str"");
      appendCRLF(buf);
      appendCRLF(buf);
    }
  }
 else {
    appendCRLF(buf);
  }
  buf.append(""String_Node_Str"");
  buf.append(targetClassMeta.name);
  buf.append(""String_Node_Str"");
  if (config.testCaseClassNameToExtend != null && config.testCaseClassNameToExtend.trim().length() > 0) {
    if (config.junitVersion == JUnitVersion.version3 || !config.testCaseClassNameToExtend.equals(""String_Node_Str"")) {
      buf.append(""String_Node_Str"");
      String[] splittedArray=config.testCaseClassNameToExtend.split(""String_Node_Str"");
      buf.append(splittedArray[splittedArray.length - 1]);
      buf.append(""String_Node_Str"");
    }
  }
  buf.append(""String_Node_Str"");
  appendCRLF(buf);
  appendCRLF(buf);
  buf.append(""String_Node_Str"");
  appendCRLF(buf);
  return getTestCaseSourceCodeWithLackingTestMethod(buf.toString());
}",0.9003496503496503
11975,"private static boolean isNeedToExclude(File javaFile){
  String canonicalClassName=javaFile.getAbsolutePath().replaceAll(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str"").trim();
  String[] regexpListForExclusion=config.target.getRegexpArrayForExclusion();
  for (  String regexp : regexpListForExclusion) {
    if (regexp != null && regexp.trim().length() > 0 && canonicalClassName.matches(""String_Node_Str"" + regexp + ""String_Node_Str"")) {
      return true;
    }
  }
  return false;
}","private static boolean isNeedToExclude(File javaFile){
  String canonicalClassName=javaFile.getAbsolutePath().replaceAll(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str"").trim();
  String[] regexpListForExclusion=config.target.getRegexpArrayForExclusion();
  for (  String regexp : regexpListForExclusion) {
    if (regexp != null && regexp.trim().length() > 0 && canonicalClassName.matches(""String_Node_Str"" + regexp.trim() + ""String_Node_Str"")) {
      return true;
    }
  }
  return false;
}",0.9933142311365808
11976,"public String[] getRegexpArrayForExclusion(){
  return regexpCsvForExclusion.split(""String_Node_Str"");
}","public String[] getRegexpArrayForExclusion(){
  return regexpCsvForExclusion.replaceAll(""String_Node_Str"",""String_Node_Str"").replaceAll(""String_Node_Str"",""String_Node_Str"").trim().split(""String_Node_Str"");
}",0.6688102893890675
11977,String getFirstInstantiationSourceCode(ClassMeta classMeta);,"String getFirstInstantiationSourceCode(Configuration config,ClassMeta classMeta);",0.851063829787234
11978,"String getInstantiationSourceCode(ClassMeta classMeta,ConstructorMeta constructorMeta);","String getInstantiationSourceCode(Configuration config,ClassMeta classMeta,ConstructorMeta constructorMeta);",0.8923076923076924
11979,List<String> getAllInstantiationSourceCodeList(ClassMeta classMeta);,"List<String> getAllInstantiationSourceCodeList(Configuration config,ClassMeta classMeta);",0.8662420382165605
11980,"@Override public String getFirstInstantiationSourceCode(ClassMeta classMeta){
  return getInstantiationSourceCode(classMeta,getFirstConstructor(classMeta));
}","@Override public String getFirstInstantiationSourceCode(Configuration config,ClassMeta classMeta){
  return getInstantiationSourceCode(config,classMeta,getFirstConstructor(classMeta));
}",0.9186046511627908
11981,"@Override public String getInstantiationSourceCode(ClassMeta classMeta,ConstructorMeta constructorMeta){
  StringBuilder buf=new StringBuilder();
  if (constructorMeta == null) {
    buf.append(StringValue.Tab);
    buf.append(StringValue.Tab);
    buf.append(classMeta.name);
    buf.append(""String_Node_Str"");
    buf.append(StringValue.Semicolon);
    buf.append(StringValue.CarriageReturn);
    buf.append(StringValue.LineFeed);
  }
 else {
    int len=constructorMeta.argTypes.size();
    for (int i=0; i < len; i++) {
      buf.append(StringValue.Tab);
      buf.append(StringValue.Tab);
      String typeName=constructorMeta.argTypes.get(i).name;
      buf.append(typeName);
      buf.append(""String_Node_Str"");
      buf.append(constructorMeta.argNames.get(i));
      buf.append(""String_Node_Str"");
      if (PrimitiveTypeUtil.isPrimitive(typeName)) {
        buf.append(PrimitiveTypeUtil.getTypeDefaultValue(typeName));
      }
 else {
        buf.append(""String_Node_Str"");
      }
      buf.append(StringValue.Semicolon);
      buf.append(StringValue.CarriageReturn);
      buf.append(StringValue.LineFeed);
    }
    buf.append(StringValue.Tab);
    buf.append(StringValue.Tab);
    buf.append(classMeta.name);
    buf.append(""String_Node_Str"");
    buf.append(classMeta.name);
    buf.append(""String_Node_Str"");
    if (len > 0) {
      buf.append(constructorMeta.argNames.get(0));
    }
    if (len > 1) {
      for (int i=1; i < len; i++) {
        buf.append(StringValue.Comma);
        buf.append(StringValue.Space);
        buf.append(constructorMeta.argNames.get(i));
      }
    }
    buf.append(""String_Node_Str"");
    buf.append(StringValue.Semicolon);
    buf.append(StringValue.CarriageReturn);
    buf.append(StringValue.LineFeed);
  }
  return buf.toString();
}","@Override public String getInstantiationSourceCode(Configuration config,ClassMeta classMeta,ConstructorMeta constructorMeta){
  StringBuilder buf=new StringBuilder();
  if (constructorMeta == null) {
    buf.append(StringValue.Tab);
    buf.append(StringValue.Tab);
    buf.append(classMeta.name);
    buf.append(""String_Node_Str"");
    buf.append(StringValue.Semicolon);
    buf.append(StringValue.CarriageReturn);
    buf.append(StringValue.LineFeed);
  }
 else {
    int len=constructorMeta.argTypes.size();
    for (int i=0; i < len; i++) {
      String typeName=constructorMeta.argTypes.get(i).name;
      boolean isAssigned=false;
      if (config.isExtensionEnabled && config.extConfiguration.extInstantiations != null) {
        for (        ExtInstantiation ins : config.extConfiguration.extInstantiations) {
          if (isCanonicalClassNameUsed(ins.canonicalClassName,typeName,classMeta)) {
            for (            String newImport : ins.importList) {
              classMeta.importedList.add(newImport);
            }
            if (ins.preAssignCode != null && ins.preAssignCode.trim().length() > 0) {
              appendExtensionSourceCode(buf,ins.preAssignCode);
            }
            appendTabs(buf,2);
            buf.append(typeName);
            buf.append(""String_Node_Str"");
            buf.append(constructorMeta.argNames.get(i));
            buf.append(""String_Node_Str"");
            buf.append(ins.assignCode.trim());
            appendCRLF(buf);
            if (ins.postAssignCode != null && ins.postAssignCode.trim().length() > 0) {
              appendExtensionPostAssignSourceCode(buf,ins.postAssignCode,new String[]{""String_Node_Str""},constructorMeta.argNames.get(i));
            }
            isAssigned=true;
          }
        }
      }
      if (!isAssigned) {
        appendTabs(buf,2);
        buf.append(typeName);
        buf.append(""String_Node_Str"");
        buf.append(constructorMeta.argNames.get(i));
        buf.append(""String_Node_Str"");
        if (PrimitiveTypeUtil.isPrimitive(typeName)) {
          buf.append(PrimitiveTypeUtil.getTypeDefaultValue(typeName));
        }
 else {
          buf.append(""String_Node_Str"");
        }
        buf.append(StringValue.Semicolon);
        appendCRLF(buf);
      }
    }
    appendTabs(buf,2);
    buf.append(classMeta.name);
    buf.append(""String_Node_Str"");
    buf.append(classMeta.name);
    buf.append(""String_Node_Str"");
    if (len > 0) {
      buf.append(constructorMeta.argNames.get(0));
    }
    if (len > 1) {
      for (int i=1; i < len; i++) {
        buf.append(StringValue.Comma);
        buf.append(StringValue.Space);
        buf.append(constructorMeta.argNames.get(i));
      }
    }
    buf.append(""String_Node_Str"");
    buf.append(StringValue.Semicolon);
    appendCRLF(buf);
  }
  return buf.toString();
}",0.6421303312405282
11982,"@Override public List<String> getAllInstantiationSourceCodeList(ClassMeta classMeta){
  List<String> dest=new ArrayList<String>();
  for (  ConstructorMeta constructorMeta : classMeta.constructors) {
    dest.add(getInstantiationSourceCode(classMeta,constructorMeta));
  }
  return dest;
}","@Override public List<String> getAllInstantiationSourceCodeList(Configuration config,ClassMeta classMeta){
  List<String> dest=new ArrayList<String>();
  for (  ConstructorMeta constructorMeta : classMeta.constructors) {
    dest.add(getInstantiationSourceCode(config,classMeta,constructorMeta));
  }
  return dest;
}",0.9273927392739274
11983,"static String getInstantiationSourceCode(Configuration config,TestMethodMeta testMethodMeta){
  Assertion.on(""String_Node_Str"").mustNotBeNull(config);
  Assertion.on(""String_Node_Str"").mustNotBeNull(testMethodMeta);
  if (config.isExtensionEnabled && config.extConfiguration.extInstantiations != null) {
    for (    ExtInstantiation ins : config.extConfiguration.extInstantiations) {
      if (isCanonicalClassNameUsed(ins.canonicalClassName,testMethodMeta.classMeta.name,testMethodMeta.classMeta)) {
        for (        String newImport : ins.importList) {
          testMethodMeta.classMeta.importedList.add(newImport);
        }
        StringBuilder buf=new StringBuilder();
        if (ins.preAssignCode != null && ins.preAssignCode.trim().length() > 0) {
          appendExtensionSourceCode(buf,ins.preAssignCode);
        }
        buf.append(StringValue.Tab);
        buf.append(StringValue.Tab);
        buf.append(testMethodMeta.classMeta.name);
        buf.append(""String_Node_Str"");
        buf.append(ins.assignCode.trim());
        buf.append(StringValue.CarriageReturn);
        buf.append(StringValue.LineFeed);
        if (ins.postAssignCode != null && ins.postAssignCode.trim().length() > 0) {
          appendExtensionPostAssignSourceCode(buf,ins.postAssignCode,new String[]{""String_Node_Str""},""String_Node_Str"");
        }
        return buf.toString();
      }
    }
  }
  return new DefaultConstructorGenerator().getFirstInstantiationSourceCode(testMethodMeta.classMeta);
}","static String getInstantiationSourceCode(Configuration config,TestMethodMeta testMethodMeta){
  Assertion.on(""String_Node_Str"").mustNotBeNull(config);
  Assertion.on(""String_Node_Str"").mustNotBeNull(testMethodMeta);
  if (config.isExtensionEnabled && config.extConfiguration.extInstantiations != null) {
    for (    ExtInstantiation ins : config.extConfiguration.extInstantiations) {
      if (isCanonicalClassNameUsed(ins.canonicalClassName,testMethodMeta.classMeta.name,testMethodMeta.classMeta)) {
        for (        String newImport : ins.importList) {
          testMethodMeta.classMeta.importedList.add(newImport);
        }
        StringBuilder buf=new StringBuilder();
        if (ins.preAssignCode != null && ins.preAssignCode.trim().length() > 0) {
          appendExtensionSourceCode(buf,ins.preAssignCode);
        }
        buf.append(StringValue.Tab);
        buf.append(StringValue.Tab);
        buf.append(testMethodMeta.classMeta.name);
        buf.append(""String_Node_Str"");
        buf.append(ins.assignCode.trim());
        buf.append(StringValue.CarriageReturn);
        buf.append(StringValue.LineFeed);
        if (ins.postAssignCode != null && ins.postAssignCode.trim().length() > 0) {
          appendExtensionPostAssignSourceCode(buf,ins.postAssignCode,new String[]{""String_Node_Str""},""String_Node_Str"");
        }
        return buf.toString();
      }
    }
  }
  return new DefaultConstructorGenerator().getFirstInstantiationSourceCode(config,testMethodMeta.classMeta);
}",0.9976674441852716
11984,"static void appendExtensionPostAssignSourceCode(StringBuilder buf,String code,String[] fromList,String to){
  Assertion.on(""String_Node_Str"").mustNotBeNull(code);
  Assertion.on(""String_Node_Str"").mustNotBeNull(fromList);
  Assertion.on(""String_Node_Str"").mustNotBeNull(to);
  String[] separatedListBySemicolon=code.split(StringValue.Semicolon);
  for (  String separatedBySemicolon : separatedListBySemicolon) {
    if (separatedBySemicolon != null && separatedBySemicolon.trim().length() > 0) {
      separatedBySemicolon=separatedBySemicolon.trim().replaceAll(StringValue.CarriageReturn,""String_Node_Str"");
      String[] lines=separatedBySemicolon.split(StringValue.LineFeed);
      for (      String line : lines) {
        if (line != null && line.trim().length() > 0) {
          appendTabs(buf,2);
          line=line.trim();
          for (          String from : fromList) {
            line=line.replaceAll(from,to);
          }
          buf.append(line);
          if (!line.endsWith(""String_Node_Str"") && !line.endsWith(""String_Node_Str"")) {
            buf.append(StringValue.Semicolon);
          }
          appendCRLF(buf);
        }
      }
    }
  }
}","static void appendExtensionPostAssignSourceCode(StringBuilder buf,String code,String[] fromList,String to){
  Assertion.on(""String_Node_Str"").mustNotBeNull(code);
  Assertion.on(""String_Node_Str"").mustNotBeNull(fromList);
  Assertion.on(""String_Node_Str"").mustNotBeNull(to);
  String[] separatedListBySemicolon=code.split(StringValue.Semicolon);
  for (  String separatedBySemicolon : separatedListBySemicolon) {
    if (separatedBySemicolon != null && separatedBySemicolon.trim().length() > 0) {
      separatedBySemicolon=separatedBySemicolon.trim().replaceAll(StringValue.CarriageReturn,""String_Node_Str"");
      String[] lines=separatedBySemicolon.split(StringValue.LineFeed);
      for (      String line : lines) {
        if (line != null && line.trim().length() > 0) {
          appendTabs(buf,2);
          line=line.trim();
          for (          String from : fromList) {
            line=line.replaceAll(from,to);
          }
          buf.append(line);
          if (!line.endsWith(""String_Node_Str"") && !line.endsWith(""String_Node_Str"") && !line.endsWith(""String_Node_Str"")&& !line.endsWith(""String_Node_Str"")) {
            buf.append(StringValue.Semicolon);
          }
          appendCRLF(buf);
        }
      }
    }
  }
}",0.9697722567287784
11985,"static void appendExtensionSourceCode(StringBuilder buf,String code){
  Assertion.on(""String_Node_Str"").mustNotBeNull(code);
  String[] separatedListBySemicolon=code.split(StringValue.Semicolon);
  for (  String separatedBySemicolon : separatedListBySemicolon) {
    if (separatedBySemicolon != null && separatedBySemicolon.trim().length() > 0) {
      separatedBySemicolon=separatedBySemicolon.trim().replaceAll(StringValue.CarriageReturn,""String_Node_Str"");
      String[] lines=separatedBySemicolon.split(StringValue.LineFeed);
      for (      String line : lines) {
        if (line != null && line.trim().length() > 0) {
          appendTabs(buf,2);
          buf.append(line.trim());
          if (!line.endsWith(""String_Node_Str"") && !line.endsWith(""String_Node_Str"")) {
            buf.append(StringValue.Semicolon);
          }
          appendCRLF(buf);
        }
      }
    }
  }
}","static void appendExtensionSourceCode(StringBuilder buf,String code){
  Assertion.on(""String_Node_Str"").mustNotBeNull(buf);
  Assertion.on(""String_Node_Str"").mustNotBeNull(code);
  String[] separatedListBySemicolon=code.split(StringValue.Semicolon);
  for (  String separatedBySemicolon : separatedListBySemicolon) {
    if (separatedBySemicolon != null && separatedBySemicolon.trim().length() > 0) {
      separatedBySemicolon=separatedBySemicolon.trim().replaceAll(StringValue.CarriageReturn,""String_Node_Str"");
      String[] lines=separatedBySemicolon.split(StringValue.LineFeed);
      for (      String line : lines) {
        if (line != null && line.trim().length() > 0) {
          appendTabs(buf,2);
          buf.append(line.trim());
          if (!line.endsWith(""String_Node_Str"") && !line.endsWith(""String_Node_Str"") && !line.endsWith(""String_Node_Str"")&& !line.endsWith(""String_Node_Str"")) {
            buf.append(StringValue.Semicolon);
          }
          appendCRLF(buf);
        }
      }
    }
  }
}",0.933681462140992
11986,"@Test public void appendIfNotExists_A$StringBuilder$String$String_StringIsNull() throws Exception {
  StringBuilder buf=new StringBuilder();
  String src=null;
  String importLine=null;
  try {
    DefaultGeneratorUtil.appendIfNotExists(buf,src,importLine);
    fail();
  }
 catch (  JUnitHelperCoreException e) {
  }
}","@Test(expected=JUnitHelperCoreException.class) public void appendIfNotExists_A$StringBuilder$String$String_StringIsNull() throws Exception {
  StringBuilder buf=new StringBuilder();
  String src=null;
  String importLine=null;
  DefaultGeneratorUtil.appendIfNotExists(buf,src,importLine);
}",0.8177339901477833
11987,"@Test public void appendTabs_A$StringBuilder$int_intIsMaxValue() throws Exception {
  StringBuilder buf=null;
  int times=Integer.MAX_VALUE;
  try {
    DefaultGeneratorUtil.appendTabs(buf,times);
    fail();
  }
 catch (  JUnitHelperCoreException e) {
  }
}","@Test(expected=JUnitHelperCoreException.class) public void appendTabs_A$StringBuilder$int_intIsMaxValue() throws Exception {
  StringBuilder buf=null;
  int times=Integer.MAX_VALUE;
  DefaultGeneratorUtil.appendTabs(buf,times);
}",0.7720739219712526
11988,"@Test public void appendTabs_A$StringBuilder$int_intIsMinValue() throws Exception {
  StringBuilder buf=null;
  int times=Integer.MIN_VALUE;
  try {
    DefaultGeneratorUtil.appendTabs(buf,times);
    fail();
  }
 catch (  JUnitHelperCoreException e) {
  }
}","@Test(expected=JUnitHelperCoreException.class) public void appendTabs_A$StringBuilder$int_intIsMinValue() throws Exception {
  StringBuilder buf=null;
  int times=Integer.MIN_VALUE;
  DefaultGeneratorUtil.appendTabs(buf,times);
}",0.7720739219712526
11989,"@Test public void appendExtensionPostAssignSourceCode_A$StringBuilder$String$StringArray$String_StringIsNull() throws Exception {
  StringBuilder buf=new StringBuilder();
  String code=null;
  String[] fromList=new String[]{};
  String to=null;
  try {
    DefaultGeneratorUtil.appendExtensionPostAssignSourceCode(buf,code,fromList,to);
    fail();
  }
 catch (  JUnitHelperCoreException e) {
  }
}","@Test(expected=JUnitHelperCoreException.class) public void appendExtensionPostAssignSourceCode_A$StringBuilder$String$StringArray$String_StringIsNull() throws Exception {
  StringBuilder buf=new StringBuilder();
  String code=null;
  String[] fromList=new String[]{};
  String to=null;
  DefaultGeneratorUtil.appendExtensionPostAssignSourceCode(buf,code,fromList,to);
}",0.8552803129074316
11990,"@Test public void getInstantiationSourceCode_A$Configuration$TestMethodMeta_Null() throws Exception {
  Configuration config=null;
  TestMethodMeta testMethodMeta=null;
  try {
    DefaultGeneratorUtil.getInstantiationSourceCode(config,testMethodMeta);
    fail();
  }
 catch (  JUnitHelperCoreException e) {
  }
}","@Test(expected=JUnitHelperCoreException.class) public void getInstantiationSourceCode_A$Configuration$TestMethodMeta_Null() throws Exception {
  Configuration config=null;
  TestMethodMeta testMethodMeta=null;
  DefaultGeneratorUtil.getInstantiationSourceCode(config,testMethodMeta);
}",0.8146911519198664
11991,"@Test public void appendExtensionSourceCode_A$StringBuilder$String_StringIsNull() throws Exception {
  StringBuilder buf=new StringBuilder();
  String code=null;
  try {
    DefaultGeneratorUtil.appendExtensionSourceCode(buf,code);
    fail();
  }
 catch (  JUnitHelperCoreException e) {
  }
}","@Test(expected=JUnitHelperCoreException.class) public void appendExtensionSourceCode_A$StringBuilder$String_StringIsNull() throws Exception {
  StringBuilder buf=new StringBuilder();
  String code=null;
  DefaultGeneratorUtil.appendExtensionSourceCode(buf,code);
}",0.800718132854578
11992,"@Test public void appendTabs_A$StringBuilder$int_intIsMinus1() throws Exception {
  StringBuilder buf=new StringBuilder();
  int times=-1;
  try {
    DefaultGeneratorUtil.appendTabs(buf,times);
    fail();
  }
 catch (  JUnitHelperCoreException e) {
  }
}","@Test(expected=JUnitHelperCoreException.class) public void appendTabs_A$StringBuilder$int_intIsMinus1() throws Exception {
  StringBuilder buf=new StringBuilder();
  int times=-1;
  DefaultGeneratorUtil.appendTabs(buf,times);
}",0.7701863354037267
11993,"@Test public void isCanonicalClassNameUsed_A$String$String$ClassMeta_StringIsNull() throws Exception {
  String expectedCanonicalClassName=null;
  String usedClassName=null;
  ClassMeta targetClassMeta=null;
  try {
    DefaultGeneratorUtil.isCanonicalClassNameUsed(expectedCanonicalClassName,usedClassName,targetClassMeta);
    fail();
  }
 catch (  JUnitHelperCoreException e) {
  }
}","@Test(expected=JUnitHelperCoreException.class) public void isCanonicalClassNameUsed_A$String$String$ClassMeta_StringIsNull() throws Exception {
  String expectedCanonicalClassName=null;
  String usedClassName=null;
  ClassMeta targetClassMeta=null;
  DefaultGeneratorUtil.isCanonicalClassNameUsed(expectedCanonicalClassName,usedClassName,targetClassMeta);
}",0.8506056527590848
11994,"static String getInstantiationSourceCode(Configuration config,TestMethodMeta testMethodMeta){
  Assertion.mustNotBeNull(config,""String_Node_Str"");
  Assertion.mustNotBeNull(testMethodMeta,""String_Node_Str"");
  if (config.isExtensionEnabled && config.extConfiguration.extInstantiations != null) {
    for (    ExtInstantiation ins : config.extConfiguration.extInstantiations) {
      if (isCanonicalClassNameUsed(ins.canonicalClassName,testMethodMeta.classMeta.name,testMethodMeta.classMeta)) {
        for (        String newImport : ins.importList) {
          testMethodMeta.classMeta.importedList.add(newImport);
        }
        StringBuilder buf=new StringBuilder();
        if (ins.preAssignCode != null && ins.preAssignCode.trim().length() > 0) {
          buf.append(StringValue.Tab);
          buf.append(StringValue.Tab);
          String[] lines=ins.preAssignCode.split(StringValue.Semicolon);
          for (          String line : lines) {
            buf.append(line);
            buf.append(StringValue.Semicolon);
          }
          buf.append(StringValue.CarriageReturn);
          buf.append(StringValue.LineFeed);
        }
        buf.append(StringValue.Tab);
        buf.append(StringValue.Tab);
        buf.append(testMethodMeta.classMeta.name);
        buf.append(""String_Node_Str"");
        buf.append(ins.assignCode);
        buf.append(StringValue.CarriageReturn);
        buf.append(StringValue.LineFeed);
        if (ins.postAssignCode != null && ins.postAssignCode.trim().length() > 0) {
          buf.append(StringValue.Tab);
          buf.append(StringValue.Tab);
          String[] lines=ins.postAssignCode.split(StringValue.Semicolon);
          for (          String line : lines) {
            buf.append(line);
            buf.append(StringValue.Semicolon);
          }
          buf.append(StringValue.CarriageReturn);
          buf.append(StringValue.LineFeed);
        }
        return buf.toString();
      }
    }
  }
  return new DefaultConstructorGenerator().getFirstInstantiationSourceCode(testMethodMeta.classMeta);
}","static String getInstantiationSourceCode(Configuration config,TestMethodMeta testMethodMeta){
  Assertion.mustNotBeNull(config,""String_Node_Str"");
  Assertion.mustNotBeNull(testMethodMeta,""String_Node_Str"");
  if (config.isExtensionEnabled && config.extConfiguration.extInstantiations != null) {
    for (    ExtInstantiation ins : config.extConfiguration.extInstantiations) {
      if (isCanonicalClassNameUsed(ins.canonicalClassName,testMethodMeta.classMeta.name,testMethodMeta.classMeta)) {
        for (        String newImport : ins.importList) {
          testMethodMeta.classMeta.importedList.add(newImport);
        }
        StringBuilder buf=new StringBuilder();
        if (ins.preAssignCode != null && ins.preAssignCode.trim().length() > 0) {
          String[] lines=ins.preAssignCode.split(StringValue.Semicolon);
          for (          String line : lines) {
            buf.append(StringValue.Tab);
            buf.append(StringValue.Tab);
            line=line.trim().replaceAll(StringValue.CarriageReturn,""String_Node_Str"").replaceAll(StringValue.LineFeed,""String_Node_Str"");
            buf.append(line);
            buf.append(StringValue.Semicolon);
            buf.append(StringValue.CarriageReturn);
            buf.append(StringValue.LineFeed);
          }
        }
        buf.append(StringValue.Tab);
        buf.append(StringValue.Tab);
        buf.append(testMethodMeta.classMeta.name);
        buf.append(""String_Node_Str"");
        buf.append(ins.assignCode.trim());
        buf.append(StringValue.CarriageReturn);
        buf.append(StringValue.LineFeed);
        if (ins.postAssignCode != null && ins.postAssignCode.trim().length() > 0) {
          String[] lines=ins.postAssignCode.split(StringValue.Semicolon);
          for (          String line : lines) {
            buf.append(StringValue.Tab);
            buf.append(StringValue.Tab);
            line=line.trim().replaceAll(StringValue.CarriageReturn,""String_Node_Str"").replaceAll(StringValue.LineFeed,""String_Node_Str"").replaceAll(""String_Node_Str"",""String_Node_Str"");
            buf.append(line);
            buf.append(StringValue.Semicolon);
            buf.append(StringValue.CarriageReturn);
            buf.append(StringValue.LineFeed);
          }
        }
        return buf.toString();
      }
    }
  }
  return new DefaultConstructorGenerator().getFirstInstantiationSourceCode(testMethodMeta.classMeta);
}",0.5889707524000893
11995,"String getArgValue(TestMethodMeta testMethodMeta,ArgTypeMeta argTypeMeta,String argName){
  Assertion.mustNotBeNull(testMethodMeta,""String_Node_Str"");
  Assertion.mustNotBeNull(argTypeMeta,""String_Node_Str"");
  Assertion.mustNotBeEmpty(argName,""String_Node_Str"");
  if (config.isExtensionEnabled && config.extConfiguration.extInstantiations != null) {
    for (    ExtInstantiation ins : config.extConfiguration.extInstantiations) {
      if (isCanonicalClassNameUsed(ins.canonicalClassName,argTypeMeta.name,testMethodMeta.classMeta)) {
        return ins.assignCode;
      }
    }
  }
  AvailableTypeDetector availableTypeDetector=new AvailableTypeDetector(targetClassMeta);
  if (availableTypeDetector.isJavaLangPackageType(argTypeMeta.name)) {
    return ""String_Node_Str"";
  }
 else   if (PrimitiveTypeUtil.isPrimitive(argTypeMeta.name)) {
    return PrimitiveTypeUtil.getTypeDefaultValue(argTypeMeta.name);
  }
 else   if (argTypeMeta.name.matches(""String_Node_Str"")) {
    return ""String_Node_Str"" + argTypeMeta.name + ""String_Node_Str"";
  }
 else   if (argTypeMeta.name.matches(""String_Node_Str"") && availableTypeDetector.isAvailableType(""String_Node_Str"",config)) {
    targetClassMeta.importedList.add(""String_Node_Str"");
    String genericsString=argTypeMeta.getGenericsAsString();
    if (genericsString.equals(""String_Node_Str"")) {
      genericsString=""String_Node_Str"";
    }
    return ""String_Node_Str"" + genericsString + ""String_Node_Str"";
  }
 else   if (argTypeMeta.name.matches(""String_Node_Str"") && availableTypeDetector.isAvailableType(""String_Node_Str"",config)) {
    targetClassMeta.importedList.add(""String_Node_Str"");
    String genericsString=argTypeMeta.getGenericsAsString();
    if (genericsString.matches(""String_Node_Str"")) {
      genericsString=""String_Node_Str"";
    }
    return ""String_Node_Str"" + genericsString + ""String_Node_Str"";
  }
 else   if (config.mockObjectFramework == MockObjectFramework.EasyMock) {
    return ""String_Node_Str"" + argTypeMeta.name.replaceAll(RegExp.Generics,StringValue.Empty) + ""String_Node_Str"";
  }
 else   if (config.mockObjectFramework == MockObjectFramework.JMock2) {
    return ""String_Node_Str"" + argTypeMeta.name.replaceAll(RegExp.Generics,StringValue.Empty) + ""String_Node_Str"";
  }
 else   if (config.mockObjectFramework == MockObjectFramework.JMockit) {
    if (new AvailableTypeDetector(targetClassMeta).isJMockitMockableType(argTypeMeta.name)) {
      return ""String_Node_Str"" + getTestMethodNamePrefix(testMethodMeta,testMethodMeta.testingTargetException) + ""String_Node_Str""+ argName;
    }
 else {
      return ""String_Node_Str"";
    }
  }
 else   if (config.mockObjectFramework == MockObjectFramework.Mockito) {
    return ""String_Node_Str"" + argTypeMeta.name.replaceAll(RegExp.Generics,StringValue.Empty) + ""String_Node_Str"";
  }
 else {
    return ""String_Node_Str"";
  }
}","String getArgValue(TestMethodMeta testMethodMeta,ArgTypeMeta argTypeMeta,String argName){
  Assertion.mustNotBeNull(testMethodMeta,""String_Node_Str"");
  Assertion.mustNotBeNull(argTypeMeta,""String_Node_Str"");
  Assertion.mustNotBeEmpty(argName,""String_Node_Str"");
  if (config.isExtensionEnabled && config.extConfiguration.extInstantiations != null) {
    for (    ExtInstantiation ins : config.extConfiguration.extInstantiations) {
      if (isCanonicalClassNameUsed(ins.canonicalClassName,argTypeMeta.name,testMethodMeta.classMeta)) {
        return ins.assignCode.trim();
      }
    }
  }
  AvailableTypeDetector availableTypeDetector=new AvailableTypeDetector(targetClassMeta);
  if (availableTypeDetector.isJavaLangPackageType(argTypeMeta.name)) {
    return ""String_Node_Str"";
  }
 else   if (PrimitiveTypeUtil.isPrimitive(argTypeMeta.name)) {
    return PrimitiveTypeUtil.getTypeDefaultValue(argTypeMeta.name);
  }
 else   if (argTypeMeta.name.matches(""String_Node_Str"")) {
    return ""String_Node_Str"" + argTypeMeta.name + ""String_Node_Str"";
  }
 else   if (argTypeMeta.name.matches(""String_Node_Str"") && availableTypeDetector.isAvailableType(""String_Node_Str"",config)) {
    targetClassMeta.importedList.add(""String_Node_Str"");
    String genericsString=argTypeMeta.getGenericsAsString();
    if (genericsString.equals(""String_Node_Str"")) {
      genericsString=""String_Node_Str"";
    }
    return ""String_Node_Str"" + genericsString + ""String_Node_Str"";
  }
 else   if (argTypeMeta.name.matches(""String_Node_Str"") && availableTypeDetector.isAvailableType(""String_Node_Str"",config)) {
    targetClassMeta.importedList.add(""String_Node_Str"");
    String genericsString=argTypeMeta.getGenericsAsString();
    if (genericsString.matches(""String_Node_Str"")) {
      genericsString=""String_Node_Str"";
    }
    return ""String_Node_Str"" + genericsString + ""String_Node_Str"";
  }
 else   if (config.mockObjectFramework == MockObjectFramework.EasyMock) {
    return ""String_Node_Str"" + argTypeMeta.name.replaceAll(RegExp.Generics,StringValue.Empty) + ""String_Node_Str"";
  }
 else   if (config.mockObjectFramework == MockObjectFramework.JMock2) {
    return ""String_Node_Str"" + argTypeMeta.name.replaceAll(RegExp.Generics,StringValue.Empty) + ""String_Node_Str"";
  }
 else   if (config.mockObjectFramework == MockObjectFramework.JMockit) {
    if (new AvailableTypeDetector(targetClassMeta).isJMockitMockableType(argTypeMeta.name)) {
      return ""String_Node_Str"" + getTestMethodNamePrefix(testMethodMeta,testMethodMeta.testingTargetException) + ""String_Node_Str""+ argName;
    }
 else {
      return ""String_Node_Str"";
    }
  }
 else   if (config.mockObjectFramework == MockObjectFramework.Mockito) {
    return ""String_Node_Str"" + argTypeMeta.name.replaceAll(RegExp.Generics,StringValue.Empty) + ""String_Node_Str"";
  }
 else {
    return ""String_Node_Str"";
  }
}",0.9987768652804472
11996,"void appendPreparingArgs(StringBuilder buf,TestMethodMeta testMethodMeta){
  int argsLen=testMethodMeta.methodMeta.argTypes.size();
  if (argsLen > 0) {
    for (int i=0; i < argsLen; i++) {
      ArgTypeMeta argTypeMeta=testMethodMeta.methodMeta.argTypes.get(i);
      String typeName=argTypeMeta.name;
      String argName=testMethodMeta.methodMeta.argNames.get(i);
      ExtArgPattern extArgPattern=testMethodMeta.extArgPattern;
      boolean isExtArgPatternTarget=false;
      if (extArgPattern != null && isCanonicalClassNameUsed(extArgPattern.extArg.canonicalClassName,argTypeMeta.name,testMethodMeta.classMeta)) {
        isExtArgPatternTarget=true;
      }
      ExtInstantiation extInstantiation=null;
      if (config.isExtensionEnabled && config.extConfiguration.extInstantiations != null) {
        for (        ExtInstantiation ins : config.extConfiguration.extInstantiations) {
          if (isCanonicalClassNameUsed(ins.canonicalClassName,argTypeMeta.name,testMethodMeta.classMeta)) {
            extInstantiation=ins;
            for (            String newImport : ins.importList) {
              testMethodMeta.classMeta.importedList.add(newImport);
            }
            break;
          }
        }
      }
      if (isExtArgPatternTarget && extArgPattern.preAssignCode != null) {
        String[] lines=extArgPattern.preAssignCode.split(StringValue.Semicolon);
        for (        String line : lines) {
          if (line != null && line.trim().length() > 0) {
            appendTabs(buf,2);
            line=line.trim().replaceAll(StringValue.CarriageReturn,""String_Node_Str"").replaceAll(StringValue.LineFeed,""String_Node_Str"");
            buf.append(line);
            buf.append(StringValue.Semicolon);
            appendCRLF(buf);
          }
        }
      }
 else       if (extInstantiation != null) {
        if (extInstantiation.preAssignCode != null && extInstantiation.preAssignCode.trim().length() > 0) {
          String[] lines=extInstantiation.preAssignCode.split(StringValue.Semicolon);
          for (          String line : lines) {
            if (line != null && line.trim().length() > 0) {
              appendTabs(buf,2);
              line=line.trim().replaceAll(StringValue.CarriageReturn,""String_Node_Str"").replaceAll(StringValue.LineFeed,""String_Node_Str"");
              buf.append(line);
              buf.append(StringValue.Semicolon);
              appendCRLF(buf);
            }
          }
        }
      }
      appendTabs(buf,2);
      if (config.mockObjectFramework == MockObjectFramework.JMock2) {
        buf.append(""String_Node_Str"");
      }
      buf.append(typeName);
      buf.append(""String_Node_Str"");
      buf.append(argName);
      buf.append(""String_Node_Str"");
      if (isExtArgPatternTarget) {
        buf.append(extArgPattern.assignCode.trim());
        if (!extArgPattern.assignCode.endsWith(StringValue.Semicolon)) {
          buf.append(StringValue.Semicolon);
        }
      }
 else {
        buf.append(getArgValue(testMethodMeta,argTypeMeta,argName));
        buf.append(StringValue.Semicolon);
      }
      appendCRLF(buf);
      if (isExtArgPatternTarget && extArgPattern.postAssignCode != null) {
        String[] lines=extArgPattern.postAssignCode.replaceAll(""String_Node_Str"",argName).split(StringValue.Semicolon);
        for (        String line : lines) {
          if (line != null && line.trim().length() > 0) {
            appendTabs(buf,2);
            line=line.trim().replaceAll(StringValue.CarriageReturn,""String_Node_Str"").replaceAll(StringValue.LineFeed,""String_Node_Str"");
            buf.append(line);
            buf.append(StringValue.Semicolon);
            appendCRLF(buf);
          }
        }
      }
 else       if (extInstantiation != null) {
        if (extInstantiation.postAssignCode != null && extInstantiation.postAssignCode.trim().length() > 0) {
          String[] lines=extInstantiation.postAssignCode.split(StringValue.Semicolon);
          for (          String line : lines) {
            if (line != null && line.trim().length() > 0) {
              appendTabs(buf,2);
              buf.append(line);
              buf.append(StringValue.Semicolon);
              appendCRLF(buf);
            }
          }
        }
      }
    }
  }
}","void appendPreparingArgs(StringBuilder buf,TestMethodMeta testMethodMeta){
  int argsLen=testMethodMeta.methodMeta.argTypes.size();
  if (argsLen > 0) {
    for (int i=0; i < argsLen; i++) {
      ArgTypeMeta argTypeMeta=testMethodMeta.methodMeta.argTypes.get(i);
      String typeName=argTypeMeta.name;
      String argName=testMethodMeta.methodMeta.argNames.get(i);
      ExtArgPattern extArgPattern=testMethodMeta.extArgPattern;
      boolean isExtArgPatternTarget=false;
      if (extArgPattern != null && isCanonicalClassNameUsed(extArgPattern.extArg.canonicalClassName,argTypeMeta.name,testMethodMeta.classMeta)) {
        isExtArgPatternTarget=true;
      }
      ExtInstantiation extInstantiation=null;
      if (config.isExtensionEnabled && config.extConfiguration.extInstantiations != null) {
        for (        ExtInstantiation ins : config.extConfiguration.extInstantiations) {
          if (isCanonicalClassNameUsed(ins.canonicalClassName,argTypeMeta.name,testMethodMeta.classMeta)) {
            extInstantiation=ins;
            for (            String newImport : ins.importList) {
              testMethodMeta.classMeta.importedList.add(newImport);
            }
            break;
          }
        }
      }
      if (isExtArgPatternTarget && extArgPattern.preAssignCode != null) {
        String[] lines=extArgPattern.preAssignCode.split(StringValue.Semicolon);
        for (        String line : lines) {
          if (line != null && line.trim().length() > 0) {
            appendTabs(buf,2);
            line=line.trim().replaceAll(StringValue.CarriageReturn,""String_Node_Str"").replaceAll(StringValue.LineFeed,""String_Node_Str"");
            buf.append(line);
            buf.append(StringValue.Semicolon);
            appendCRLF(buf);
          }
        }
      }
 else       if (extInstantiation != null) {
        if (extInstantiation.preAssignCode != null && extInstantiation.preAssignCode.trim().length() > 0) {
          String[] lines=extInstantiation.preAssignCode.split(StringValue.Semicolon);
          for (          String line : lines) {
            if (line != null && line.trim().length() > 0) {
              appendTabs(buf,2);
              line=line.trim().replaceAll(StringValue.CarriageReturn,""String_Node_Str"").replaceAll(StringValue.LineFeed,""String_Node_Str"");
              buf.append(line);
              buf.append(StringValue.Semicolon);
              appendCRLF(buf);
            }
          }
        }
      }
      appendTabs(buf,2);
      if (config.mockObjectFramework == MockObjectFramework.JMock2) {
        buf.append(""String_Node_Str"");
      }
      buf.append(typeName);
      buf.append(""String_Node_Str"");
      buf.append(argName);
      buf.append(""String_Node_Str"");
      if (isExtArgPatternTarget) {
        buf.append(extArgPattern.assignCode.trim());
        if (!extArgPattern.assignCode.endsWith(StringValue.Semicolon)) {
          buf.append(StringValue.Semicolon);
        }
      }
 else {
        buf.append(getArgValue(testMethodMeta,argTypeMeta,argName));
        buf.append(StringValue.Semicolon);
      }
      appendCRLF(buf);
      if (isExtArgPatternTarget && extArgPattern.postAssignCode != null) {
        String[] lines=extArgPattern.postAssignCode.replaceAll(""String_Node_Str"",argName).split(StringValue.Semicolon);
        for (        String line : lines) {
          if (line != null && line.trim().length() > 0) {
            appendTabs(buf,2);
            line=line.trim().replaceAll(StringValue.CarriageReturn,""String_Node_Str"").replaceAll(StringValue.LineFeed,""String_Node_Str"");
            buf.append(line);
            buf.append(StringValue.Semicolon);
            appendCRLF(buf);
          }
        }
      }
 else       if (extInstantiation != null) {
        if (extInstantiation.postAssignCode != null && extInstantiation.postAssignCode.trim().length() > 0) {
          String[] lines=extInstantiation.postAssignCode.split(StringValue.Semicolon);
          for (          String line : lines) {
            if (line != null && line.trim().length() > 0) {
              appendTabs(buf,2);
              line=line.trim().replaceAll(StringValue.CarriageReturn,""String_Node_Str"").replaceAll(StringValue.LineFeed,""String_Node_Str"").replaceAll(""String_Node_Str"",argName);
              buf.append(line);
              buf.append(StringValue.Semicolon);
              appendCRLF(buf);
            }
          }
        }
      }
    }
  }
}",0.9795590261828204
11997,"@Override public String getTestMethodSourceCode(TestMethodMeta testMethodMeta){
  StringBuilder buf=new StringBuilder();
  if (config.mockObjectFramework == MockObjectFramework.JMockit) {
    List<String> mockedFieldsForJMockit=getMockedFieldsForJMockit(testMethodMeta);
    for (    String mocked : mockedFieldsForJMockit) {
      appendTabs(buf,1);
      buf.append(""String_Node_Str"");
      appendCRLF(buf);
      appendTabs(buf,1);
      buf.append(mocked);
      buf.append(StringValue.Semicolon);
      appendCRLF(buf);
    }
    if (mockedFieldsForJMockit.size() > 0) {
      appendCRLF(buf);
    }
  }
  if (config.junitVersion == JUnitVersion.version3) {
    appendTabs(buf,1);
    buf.append(""String_Node_Str"");
    buf.append(StringValue.JUnit.TestMethodNamePrefixForJUnitVersion3);
    buf.append(config.testMethodName.basicDelimiter);
  }
 else {
    appendTabs(buf,1);
    buf.append(""String_Node_Str"");
    appendCRLF(buf);
    appendTabs(buf,1);
    buf.append(""String_Node_Str"");
  }
  buf.append(getTestMethodNamePrefix(testMethodMeta,testMethodMeta.testingTargetException));
  boolean isThrowableRequired=false;
  if (testMethodMeta.methodMeta != null && testMethodMeta.methodMeta.throwsExceptions != null) {
    for (    ExceptionMeta ex : testMethodMeta.methodMeta.throwsExceptions) {
      if (ex.name.equals(""String_Node_Str"")) {
        isThrowableRequired=true;
        break;
      }
    }
  }
  buf.append(""String_Node_Str"");
  buf.append(isThrowableRequired ? ""String_Node_Str"" : ""String_Node_Str"");
  buf.append(""String_Node_Str"");
  appendCRLF(buf);
  appendTabs(buf,2);
  buf.append(""String_Node_Str"");
  buf.append(messageValue.getAutoGeneratedTODOMessage());
  appendCRLF(buf);
  if (testMethodMeta.isTypeTest) {
    appendTabs(buf,2);
    if (config.junitVersion == JUnitVersion.version3) {
      buf.append(""String_Node_Str"");
      buf.append(testMethodMeta.classMeta.name);
      buf.append(""String_Node_Str"");
    }
 else {
      buf.append(""String_Node_Str"");
      buf.append(testMethodMeta.classMeta.name);
      buf.append(""String_Node_Str"");
    }
    appendCRLF(buf);
  }
 else   if (testMethodMeta.isInstantiationTest) {
    String instantiation=getInstantiationSourceCode(config,testMethodMeta);
    buf.append(instantiation);
    appendTabs(buf,2);
    if (config.junitVersion == JUnitVersion.version3) {
      buf.append(""String_Node_Str"");
    }
 else {
      buf.append(""String_Node_Str"");
    }
    appendCRLF(buf);
  }
 else   if (config.isTemplateImplementationRequired) {
    appendTestingPatternExplicitComment(buf,""String_Node_Str"",2);
    if (config.mockObjectFramework == MockObjectFramework.JMock2) {
      appendTabs(buf,2);
      buf.append(""String_Node_Str"");
      appendCRLF(buf);
      appendTabs(buf,3);
      buf.append(""String_Node_Str"");
      appendCRLF(buf);
      appendTabs(buf,2);
      buf.append(""String_Node_Str"");
      appendCRLF(buf);
    }
    if (config.mockObjectFramework == MockObjectFramework.EasyMock) {
      appendTabs(buf,2);
      buf.append(""String_Node_Str"");
      appendCRLF(buf);
    }
    if (!testMethodMeta.methodMeta.isStatic) {
      String instantiation=getInstantiationSourceCode(config,testMethodMeta);
      buf.append(instantiation);
    }
    appendBDDMockitoComment(buf,""String_Node_Str"",2);
    if (testMethodMeta.testingTargetException == null) {
      appendPreparingArgs(buf,testMethodMeta);
      appendMockChecking(buf,2);
      appendTestingPatternExplicitComment(buf,""String_Node_Str"",2);
      appendBDDMockitoComment(buf,""String_Node_Str"",2);
      if (testMethodMeta.methodMeta.returnType != null && testMethodMeta.methodMeta.returnType.name != null) {
        appendTabs(buf,2);
        buf.append(testMethodMeta.methodMeta.returnType.name);
        buf.append(""String_Node_Str"");
      }
 else {
        appendTabs(buf,2);
      }
      appendExecutingTargetMethod(buf,testMethodMeta);
      appendTestingPatternExplicitComment(buf,""String_Node_Str"",2);
      appendBDDMockitoComment(buf,""String_Node_Str"",2);
      appendMockVerifying(buf,2);
      if (testMethodMeta.methodMeta.returnType != null && testMethodMeta.methodMeta.returnType.name != null) {
        if (testMethodMeta.extReturn != null) {
          if (isCanonicalClassNameUsed(testMethodMeta.extReturn.canonicalClassName,testMethodMeta.methodMeta.returnType.name,targetClassMeta)) {
            for (            String assertion : testMethodMeta.extReturn.asserts) {
              String[] lines=assertion.split(StringValue.Semicolon);
              for (              String line : lines) {
                if (line != null && line.trim().length() > 0) {
                  appendTabs(buf,2);
                  buf.append(line.trim());
                  buf.append(StringValue.Semicolon);
                  appendCRLF(buf);
                }
              }
            }
          }
        }
 else {
          appendTabs(buf,2);
          buf.append(testMethodMeta.methodMeta.returnType.name);
          buf.append(""String_Node_Str"");
          if (PrimitiveTypeUtil.isPrimitive(testMethodMeta.methodMeta.returnType.name)) {
            buf.append(PrimitiveTypeUtil.getTypeDefaultValue(testMethodMeta.methodMeta.returnType.name));
          }
 else {
            buf.append(""String_Node_Str"");
          }
          buf.append(StringValue.Semicolon);
          appendCRLF(buf);
          appendTabs(buf,2);
          if (config.junitVersion == JUnitVersion.version3) {
            buf.append(""String_Node_Str"");
          }
 else {
            buf.append(""String_Node_Str"");
          }
          buf.append(StringValue.Semicolon);
          appendCRLF(buf);
        }
      }
    }
 else {
      appendPreparingArgs(buf,testMethodMeta);
      appendMockChecking(buf,2);
      appendTabs(buf,2);
      buf.append(""String_Node_Str"");
      appendCRLF(buf);
      appendTestingPatternExplicitComment(buf,""String_Node_Str"",3);
      appendBDDMockitoComment(buf,""String_Node_Str"",3);
      appendTabs(buf,3);
      appendExecutingTargetMethod(buf,testMethodMeta);
      appendTabs(buf,3);
      buf.append(""String_Node_Str"");
      buf.append(StringValue.Semicolon);
      appendCRLF(buf);
      appendTabs(buf,2);
      buf.append(""String_Node_Str"");
      buf.append(testMethodMeta.testingTargetException.name);
      buf.append(""String_Node_Str"");
      appendCRLF(buf);
      appendBDDMockitoComment(buf,""String_Node_Str"",3);
      appendTabs(buf,2);
      buf.append(""String_Node_Str"");
      appendCRLF(buf);
    }
  }
  appendTabs(buf,1);
  buf.append(""String_Node_Str"");
  appendCRLF(buf);
  return buf.toString();
}","@Override public String getTestMethodSourceCode(TestMethodMeta testMethodMeta){
  StringBuilder buf=new StringBuilder();
  if (config.mockObjectFramework == MockObjectFramework.JMockit) {
    List<String> mockedFieldsForJMockit=getMockedFieldsForJMockit(testMethodMeta);
    for (    String mocked : mockedFieldsForJMockit) {
      appendTabs(buf,1);
      buf.append(""String_Node_Str"");
      appendCRLF(buf);
      appendTabs(buf,1);
      buf.append(mocked);
      buf.append(StringValue.Semicolon);
      appendCRLF(buf);
    }
    if (mockedFieldsForJMockit.size() > 0) {
      appendCRLF(buf);
    }
  }
  if (config.junitVersion == JUnitVersion.version3) {
    appendTabs(buf,1);
    buf.append(""String_Node_Str"");
    buf.append(StringValue.JUnit.TestMethodNamePrefixForJUnitVersion3);
    buf.append(config.testMethodName.basicDelimiter);
  }
 else {
    appendTabs(buf,1);
    buf.append(""String_Node_Str"");
    appendCRLF(buf);
    appendTabs(buf,1);
    buf.append(""String_Node_Str"");
  }
  buf.append(getTestMethodNamePrefix(testMethodMeta,testMethodMeta.testingTargetException));
  boolean isThrowableRequired=false;
  if (testMethodMeta.methodMeta != null && testMethodMeta.methodMeta.throwsExceptions != null) {
    for (    ExceptionMeta ex : testMethodMeta.methodMeta.throwsExceptions) {
      if (ex.name.equals(""String_Node_Str"")) {
        isThrowableRequired=true;
        break;
      }
    }
  }
  buf.append(""String_Node_Str"");
  buf.append(isThrowableRequired ? ""String_Node_Str"" : ""String_Node_Str"");
  buf.append(""String_Node_Str"");
  appendCRLF(buf);
  appendTabs(buf,2);
  buf.append(""String_Node_Str"");
  buf.append(messageValue.getAutoGeneratedTODOMessage());
  appendCRLF(buf);
  if (testMethodMeta.isTypeTest) {
    appendTabs(buf,2);
    if (config.junitVersion == JUnitVersion.version3) {
      buf.append(""String_Node_Str"");
      buf.append(testMethodMeta.classMeta.name);
      buf.append(""String_Node_Str"");
    }
 else {
      buf.append(""String_Node_Str"");
      buf.append(testMethodMeta.classMeta.name);
      buf.append(""String_Node_Str"");
    }
    appendCRLF(buf);
  }
 else   if (testMethodMeta.isInstantiationTest) {
    String instantiation=getInstantiationSourceCode(config,testMethodMeta);
    buf.append(instantiation);
    appendTabs(buf,2);
    if (config.junitVersion == JUnitVersion.version3) {
      buf.append(""String_Node_Str"");
    }
 else {
      buf.append(""String_Node_Str"");
    }
    appendCRLF(buf);
  }
 else   if (config.isTemplateImplementationRequired) {
    appendTestingPatternExplicitComment(buf,""String_Node_Str"",2);
    if (config.mockObjectFramework == MockObjectFramework.JMock2) {
      appendTabs(buf,2);
      buf.append(""String_Node_Str"");
      appendCRLF(buf);
      appendTabs(buf,3);
      buf.append(""String_Node_Str"");
      appendCRLF(buf);
      appendTabs(buf,2);
      buf.append(""String_Node_Str"");
      appendCRLF(buf);
    }
    if (config.mockObjectFramework == MockObjectFramework.EasyMock) {
      appendTabs(buf,2);
      buf.append(""String_Node_Str"");
      appendCRLF(buf);
    }
    if (!testMethodMeta.methodMeta.isStatic) {
      String instantiation=getInstantiationSourceCode(config,testMethodMeta);
      buf.append(instantiation);
    }
    appendBDDMockitoComment(buf,""String_Node_Str"",2);
    if (testMethodMeta.testingTargetException == null) {
      appendPreparingArgs(buf,testMethodMeta);
      appendMockChecking(buf,2);
      appendTestingPatternExplicitComment(buf,""String_Node_Str"",2);
      appendBDDMockitoComment(buf,""String_Node_Str"",2);
      if (testMethodMeta.methodMeta.returnType != null && testMethodMeta.methodMeta.returnType.name != null) {
        appendTabs(buf,2);
        buf.append(testMethodMeta.methodMeta.returnType.name);
        buf.append(""String_Node_Str"");
      }
 else {
        appendTabs(buf,2);
      }
      appendExecutingTargetMethod(buf,testMethodMeta);
      appendTestingPatternExplicitComment(buf,""String_Node_Str"",2);
      appendBDDMockitoComment(buf,""String_Node_Str"",2);
      appendMockVerifying(buf,2);
      if (testMethodMeta.methodMeta.returnType != null && testMethodMeta.methodMeta.returnType.name != null) {
        if (testMethodMeta.extReturn != null) {
          if (isCanonicalClassNameUsed(testMethodMeta.extReturn.canonicalClassName,testMethodMeta.methodMeta.returnType.name,targetClassMeta)) {
            for (            String assertion : testMethodMeta.extReturn.asserts) {
              String[] lines=assertion.split(StringValue.Semicolon);
              for (              String line : lines) {
                if (line != null && line.trim().length() > 0) {
                  appendTabs(buf,2);
                  line=line.trim().replaceAll(StringValue.CarriageReturn,""String_Node_Str"").replaceAll(StringValue.LineFeed,""String_Node_Str"");
                  buf.append(line);
                  buf.append(StringValue.Semicolon);
                  appendCRLF(buf);
                }
              }
            }
          }
        }
 else {
          appendTabs(buf,2);
          buf.append(testMethodMeta.methodMeta.returnType.name);
          buf.append(""String_Node_Str"");
          if (PrimitiveTypeUtil.isPrimitive(testMethodMeta.methodMeta.returnType.name)) {
            buf.append(PrimitiveTypeUtil.getTypeDefaultValue(testMethodMeta.methodMeta.returnType.name));
          }
 else {
            buf.append(""String_Node_Str"");
          }
          buf.append(StringValue.Semicolon);
          appendCRLF(buf);
          appendTabs(buf,2);
          if (config.junitVersion == JUnitVersion.version3) {
            buf.append(""String_Node_Str"");
          }
 else {
            buf.append(""String_Node_Str"");
          }
          buf.append(StringValue.Semicolon);
          appendCRLF(buf);
        }
      }
    }
 else {
      appendPreparingArgs(buf,testMethodMeta);
      appendMockChecking(buf,2);
      appendTabs(buf,2);
      buf.append(""String_Node_Str"");
      appendCRLF(buf);
      appendTestingPatternExplicitComment(buf,""String_Node_Str"",3);
      appendBDDMockitoComment(buf,""String_Node_Str"",3);
      appendTabs(buf,3);
      appendExecutingTargetMethod(buf,testMethodMeta);
      appendTabs(buf,3);
      buf.append(""String_Node_Str"");
      buf.append(StringValue.Semicolon);
      appendCRLF(buf);
      appendTabs(buf,2);
      buf.append(""String_Node_Str"");
      buf.append(testMethodMeta.testingTargetException.name);
      buf.append(""String_Node_Str"");
      appendCRLF(buf);
      appendBDDMockitoComment(buf,""String_Node_Str"",3);
      appendTabs(buf,2);
      buf.append(""String_Node_Str"");
      appendCRLF(buf);
    }
  }
  appendTabs(buf,1);
  buf.append(""String_Node_Str"");
  appendCRLF(buf);
  return buf.toString();
}",0.9864449936343892
11998,"protected Configuration getConfiguration(IPreferenceStore store){
  return new PreferenceLoader(store).getConfig();
}","protected Configuration getConfiguration(IPreferenceStore store,ISelection selection){
  StructuredSelection structuredSelection=null;
  if (selection instanceof StructuredSelection) {
    structuredSelection=(StructuredSelection)selection;
  }
  if (!isNotSelected(structuredSelection) && !isSelectedSeveral(structuredSelection)) {
    String projectName=getProjectName(structuredSelection);
    String projectRootPath=getWorkspaceRootAbsolutePath(getIWorkspaceRoot()) + StringValue.DirectorySeparator.General + projectName+ StringValue.DirectorySeparator.General;
    String filepath=projectRootPath + ""String_Node_Str"";
    File configProperites=new File(filepath);
    if (configProperites.exists()) {
      try {
        return new ConfigurationLoader().load(filepath);
      }
 catch (      Exception e) {
        e.printStackTrace();
      }
    }
  }
  return new PreferenceLoader(store).getConfig();
}",0.1888997078870496
11999,"public void run(IAction action){
  store=getIPreferenceStore();
  Configuration config=getConfiguration(store);
  PropertiesLoader props=getPropertiesLoader(config.language);
  StructuredSelection structuredSelection=null;
  InputStream inputStream=null;
  FileOutputStream outputStream=null;
  OutputStreamWriter writer=null;
  String projectName=null;
  String testCaseFileName=null;
  String testCaseCreateFilePath=null;
  String resourcePathForTargetClassFile=null;
  String resourcePathForTestClassFile=null;
  try {
    if (selection instanceof StructuredSelection) {
      structuredSelection=(StructuredSelection)selection;
    }
    if (isNotSelected(structuredSelection)) {
      openWarningForRequired(props);
      return;
    }
 else     if (isSelectedSeveral(structuredSelection)) {
      openWarningForSelectOneOnly(props);
      return;
    }
    projectName=getProjectName(structuredSelection);
    resourcePathForTargetClassFile=getResourcePathForTargetClassFile(structuredSelection);
    String projectRootAbsolutePath=getWorkspaceRootAbsolutePath(getIWorkspaceRoot()) + StringValue.DirectorySeparator.General + projectName+ StringValue.DirectorySeparator.General;
    resourcePathForTestClassFile=resourcePathForTargetClassFile.replaceFirst(config.directoryPathOfProductSourceCode,config.directoryPathOfTestSourceCode).replace(StringValue.FileExtension.JavaFile,StringValue.JUnit.TestClassNameSuffix + StringValue.FileExtension.JavaFile);
    testCaseCreateFilePath=projectRootAbsolutePath + getResourcePathForTargetClassFile(structuredSelection).replace(config.directoryPathOfProductSourceCode,config.directoryPathOfTestSourceCode).replace(StringValue.FileExtension.JavaFile,StringValue.JUnit.TestClassNameSuffix + StringValue.FileExtension.JavaFile);
    testCaseFileName=(getClassNameFromResourcePathForTargetClassFile(resourcePathForTargetClassFile) + StringValue.FileExtension.JavaFile).replace(StringValue.FileExtension.JavaFile,StringValue.JUnit.TestClassNameSuffix + StringValue.FileExtension.JavaFile);
    String testCaseCreateDirPath=testCaseCreateFilePath.replaceFirst(""String_Node_Str"",""String_Node_Str"");
    File testDir=new File(testCaseCreateDirPath);
    String[] dirArr=testCaseCreateDirPath.split(StringValue.DirectorySeparator.General);
    String tmpDirPath=StringValue.Empty;
    String tmpResourceDirPath=StringValue.Empty;
    for (    String each : dirArr) {
      tmpDirPath+=StringValue.DirectorySeparator.General + each;
      File tmpDir=new File(tmpDirPath);
      if (tmpDir.getPath().length() <= projectRootAbsolutePath.length()) {
        continue;
      }
      tmpResourceDirPath+=StringValue.DirectorySeparator.General + each;
      if (!tmpDir.exists()) {
        if (!tmpDir.mkdir()) {
          System.err.println(""String_Node_Str"" + tmpDir.getPath());
        }
        String parentPathOfCreatedDir=projectName + StringValue.DirectorySeparator.General + tmpResourceDirPath+ ""String_Node_Str"";
        if (!ResourceRefreshUtil.refreshLocal(null,parentPathOfCreatedDir)) {
          System.err.println(""String_Node_Str"" + parentPathOfCreatedDir);
        }
      }
    }
    if (!testDir.mkdirs()) {
      System.err.println(""String_Node_Str"");
    }
    String pathOfTestCaseDir=projectName + StringValue.DirectorySeparator.General + resourcePathForTestClassFile+ ""String_Node_Str"";
    if (!ResourceRefreshUtil.refreshLocal(null,pathOfTestCaseDir)) {
      openWarningForResourceRefreshError(props);
      return;
    }
    try {
      File outputIOFile=new File(testCaseCreateDirPath + StringValue.DirectorySeparator.General + testCaseFileName);
      String msg=props.get(Dialog.Common.alreadyExist) + ""String_Node_Str"" + testCaseFileName+ ""String_Node_Str""+ StringValue.LineFeed+ props.get(Dialog.Common.confirmToProceed);
      if (outputIOFile.exists() && !openConfirm(props,msg)) {
        return;
      }
      IResource targetClassResource=getIWorkspaceRoot().findMember(""String_Node_Str"" + projectName + ""String_Node_Str""+ resourcePathForTargetClassFile);
      IFile targetClassFile=(IFile)targetClassResource;
      TestCaseGenerator generator=new DefaultTestCaseGenerator(config);
      String encoding=UniversalDetectorUtil.getDetectedEncoding(EclipseIFileUtil.getInputStreamFrom(targetClassFile));
      String sourceCodeString=IOUtil.readAsString(EclipseIFileUtil.getInputStreamFrom(targetClassFile),encoding);
      generator.initialize(new ClassMetaExtractor(config).extract(sourceCodeString));
      outputStream=new FileOutputStream(testCaseCreateDirPath + StringValue.DirectorySeparator.General + testCaseFileName);
      writer=new OutputStreamWriter(outputStream,getDetectedEncodingFrom(targetClassFile,config.outputFileEncoding));
      writer.write(generator.getNewTestCaseSourceCode());
    }
 catch (    InvalidPreferenceException ipe) {
      ipe.printStackTrace();
      openWarning(props,props.get(Dialog.Common.invalidPreference));
      return;
    }
catch (    FileNotFoundException fnfe) {
      fnfe.printStackTrace();
    }
 finally {
      IOUtil.close(writer);
      IOUtil.close(outputStream);
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
 finally {
    IOUtil.close(inputStream);
    IOUtil.close(outputStream);
    IOUtil.close(writer);
  }
  if (!ResourceRefreshUtil.refreshLocal(null,projectName + StringValue.DirectorySeparator.General + resourcePathForTestClassFile+ ""String_Node_Str"")) {
    openWarningForResourceRefreshError(props);
    System.err.println(""String_Node_Str"");
    return;
  }
  int retryCount=0;
  IEditorPart editorPart=null;
  ThreadUtil.sleep(1500);
  while (true) {
    try {
      IProject project=getIProject(projectName);
      IFile testCaseFile=getIFile(project,resourcePathForTestClassFile);
      IWorkbenchPage page=getIWorkbenchPage();
      editorPart=getIEditorPart(page,testCaseFile);
      if (editorPart == null) {
        throw new NullPointerException();
      }
      break;
    }
 catch (    Exception e) {
      retryCount++;
      if (retryCount > 3) {
        break;
      }
      ThreadUtil.sleep(1500);
    }
  }
  editorPart.setFocus();
}","public void run(IAction action){
  store=getIPreferenceStore();
  Configuration config=getConfiguration(store,selection);
  PropertiesLoader props=getPropertiesLoader(config.language);
  StructuredSelection structuredSelection=null;
  InputStream inputStream=null;
  FileOutputStream outputStream=null;
  OutputStreamWriter writer=null;
  String projectName=null;
  String testCaseFileName=null;
  String testCaseCreateFilePath=null;
  String resourcePathForTargetClassFile=null;
  String resourcePathForTestClassFile=null;
  try {
    if (selection instanceof StructuredSelection) {
      structuredSelection=(StructuredSelection)selection;
    }
    if (isNotSelected(structuredSelection)) {
      openWarningForRequired(props);
      return;
    }
 else     if (isSelectedSeveral(structuredSelection)) {
      openWarningForSelectOneOnly(props);
      return;
    }
    projectName=getProjectName(structuredSelection);
    resourcePathForTargetClassFile=getResourcePathForTargetClassFile(structuredSelection);
    String projectRootAbsolutePath=getWorkspaceRootAbsolutePath(getIWorkspaceRoot()) + StringValue.DirectorySeparator.General + projectName+ StringValue.DirectorySeparator.General;
    resourcePathForTestClassFile=resourcePathForTargetClassFile.replaceFirst(config.directoryPathOfProductSourceCode,config.directoryPathOfTestSourceCode).replace(StringValue.FileExtension.JavaFile,StringValue.JUnit.TestClassNameSuffix + StringValue.FileExtension.JavaFile);
    testCaseCreateFilePath=projectRootAbsolutePath + getResourcePathForTargetClassFile(structuredSelection).replace(config.directoryPathOfProductSourceCode,config.directoryPathOfTestSourceCode).replace(StringValue.FileExtension.JavaFile,StringValue.JUnit.TestClassNameSuffix + StringValue.FileExtension.JavaFile);
    testCaseFileName=(getClassNameFromResourcePathForTargetClassFile(resourcePathForTargetClassFile) + StringValue.FileExtension.JavaFile).replace(StringValue.FileExtension.JavaFile,StringValue.JUnit.TestClassNameSuffix + StringValue.FileExtension.JavaFile);
    String testCaseCreateDirPath=testCaseCreateFilePath.replaceFirst(""String_Node_Str"",""String_Node_Str"");
    File testDir=new File(testCaseCreateDirPath);
    String[] dirArr=testCaseCreateDirPath.split(StringValue.DirectorySeparator.General);
    String tmpDirPath=StringValue.Empty;
    String tmpResourceDirPath=StringValue.Empty;
    for (    String each : dirArr) {
      tmpDirPath+=StringValue.DirectorySeparator.General + each;
      File tmpDir=new File(tmpDirPath);
      if (tmpDir.getPath().length() <= projectRootAbsolutePath.length()) {
        continue;
      }
      tmpResourceDirPath+=StringValue.DirectorySeparator.General + each;
      if (!tmpDir.exists()) {
        if (!tmpDir.mkdir()) {
          System.err.println(""String_Node_Str"" + tmpDir.getPath());
        }
        String parentPathOfCreatedDir=projectName + StringValue.DirectorySeparator.General + tmpResourceDirPath+ ""String_Node_Str"";
        if (!ResourceRefreshUtil.refreshLocal(null,parentPathOfCreatedDir)) {
          System.err.println(""String_Node_Str"" + parentPathOfCreatedDir);
        }
      }
    }
    if (!testDir.mkdirs()) {
      System.err.println(""String_Node_Str"");
    }
    String pathOfTestCaseDir=projectName + StringValue.DirectorySeparator.General + resourcePathForTestClassFile+ ""String_Node_Str"";
    if (!ResourceRefreshUtil.refreshLocal(null,pathOfTestCaseDir)) {
      openWarningForResourceRefreshError(props);
      return;
    }
    try {
      File outputIOFile=new File(testCaseCreateDirPath + StringValue.DirectorySeparator.General + testCaseFileName);
      String msg=props.get(Dialog.Common.alreadyExist) + ""String_Node_Str"" + testCaseFileName+ ""String_Node_Str""+ StringValue.LineFeed+ props.get(Dialog.Common.confirmToProceed);
      if (outputIOFile.exists() && !openConfirm(props,msg)) {
        return;
      }
      IResource targetClassResource=getIWorkspaceRoot().findMember(""String_Node_Str"" + projectName + ""String_Node_Str""+ resourcePathForTargetClassFile);
      IFile targetClassFile=(IFile)targetClassResource;
      TestCaseGenerator generator=new DefaultTestCaseGenerator(config);
      String encoding=UniversalDetectorUtil.getDetectedEncoding(EclipseIFileUtil.getInputStreamFrom(targetClassFile));
      String sourceCodeString=IOUtil.readAsString(EclipseIFileUtil.getInputStreamFrom(targetClassFile),encoding);
      generator.initialize(new ClassMetaExtractor(config).extract(sourceCodeString));
      outputStream=new FileOutputStream(testCaseCreateDirPath + StringValue.DirectorySeparator.General + testCaseFileName);
      writer=new OutputStreamWriter(outputStream,getDetectedEncodingFrom(targetClassFile,config.outputFileEncoding));
      writer.write(generator.getNewTestCaseSourceCode());
    }
 catch (    InvalidPreferenceException ipe) {
      ipe.printStackTrace();
      openWarning(props,props.get(Dialog.Common.invalidPreference));
      return;
    }
catch (    FileNotFoundException fnfe) {
      fnfe.printStackTrace();
    }
 finally {
      IOUtil.close(writer);
      IOUtil.close(outputStream);
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
 finally {
    IOUtil.close(inputStream);
    IOUtil.close(outputStream);
    IOUtil.close(writer);
  }
  if (!ResourceRefreshUtil.refreshLocal(null,projectName + StringValue.DirectorySeparator.General + resourcePathForTestClassFile+ ""String_Node_Str"")) {
    openWarningForResourceRefreshError(props);
    System.err.println(""String_Node_Str"");
    return;
  }
  int retryCount=0;
  IEditorPart editorPart=null;
  ThreadUtil.sleep(1500);
  while (true) {
    try {
      IProject project=getIProject(projectName);
      IFile testCaseFile=getIFile(project,resourcePathForTestClassFile);
      IWorkbenchPage page=getIWorkbenchPage();
      editorPart=getIEditorPart(page,testCaseFile);
      if (editorPart == null) {
        throw new NullPointerException();
      }
      break;
    }
 catch (    Exception e) {
      retryCount++;
      if (retryCount > 3) {
        break;
      }
      ThreadUtil.sleep(1500);
    }
  }
  editorPart.setFocus();
}",0.999182338511856
12000,"public void run(IAction action){
  store=getIPreferenceStore();
  Configuration config=getConfiguration(store);
  PropertiesLoader props=getPropertiesLoader(store.getString(Preference.lang));
  StructuredSelection structuredSelection=null;
  try {
    if (selection instanceof StructuredSelection) {
      structuredSelection=(StructuredSelection)selection;
    }
    if (isNotSelected(structuredSelection)) {
      openWarningForRequired(props);
      return;
    }
 else     if (isSelectedSeveral(structuredSelection)) {
      openWarningForSelectOneOnly(props);
      return;
    }
    String resourcePathForTargetClassFile=getResourcePathForTargetClassFile(structuredSelection).replaceFirst(config.directoryPathOfTestSourceCode,config.directoryPathOfProductSourceCode);
    String resourcePathForTestCaseFile=resourcePathForTargetClassFile.replaceFirst(config.directoryPathOfProductSourceCode,config.directoryPathOfTestSourceCode).replaceFirst(""String_Node_Str"",StringValue.JUnit.TestClassNameSuffix + StringValue.FileExtension.JavaFile);
    String projectName=getProjectName(structuredSelection);
    String projectRootAbsolutePath=getWorkspaceRootAbsolutePath(getIWorkspaceRoot()) + StringValue.DirectorySeparator.General + projectName+ StringValue.DirectorySeparator.General;
    if (!resourcePathForTestCaseFile.matches(""String_Node_Str"" + RegExp.FileExtension.JavaFile)) {
      openWarningForSelectJavaFile(props);
      return;
    }
    String targetClassName=getClassNameFromResourcePathForTargetClassFile(resourcePathForTargetClassFile);
    String testCaseFilename=getTestClassNameFromClassName(targetClassName);
    String msg=props.get(Dialog.Common.confirmToChangeToJUnitVersion3) + ""String_Node_Str"" + testCaseFilename+ ""String_Node_Str"";
    if (testCaseFilename == null || !openConfirm(props,msg)) {
      return;
    }
    System.setProperty(""String_Node_Str"",""String_Node_Str"");
    ForceJUnitVersion3Command.main(new String[]{projectRootAbsolutePath + resourcePathForTargetClassFile});
    ThreadUtil.sleep(200);
    int retryCount=0;
    while (true) {
      try {
        if (!ResourceRefreshUtil.refreshLocal(null,projectName + StringValue.DirectorySeparator.General + resourcePathForTestCaseFile+ ""String_Node_Str"")) {
          openWarningForResourceRefreshError(props);
          System.err.println(""String_Node_Str"");
          return;
        }
        retryCount=0;
        ThreadUtil.sleep(1500);
      }
 catch (      Exception e) {
        retryCount++;
        if (retryCount > 10) {
          break;
        }
        e.printStackTrace();
        ThreadUtil.sleep(1500);
      }
      break;
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}","public void run(IAction action){
  store=getIPreferenceStore();
  Configuration config=getConfiguration(store,selection);
  PropertiesLoader props=getPropertiesLoader(store.getString(Preference.lang));
  StructuredSelection structuredSelection=null;
  try {
    if (selection instanceof StructuredSelection) {
      structuredSelection=(StructuredSelection)selection;
    }
    if (isNotSelected(structuredSelection)) {
      openWarningForRequired(props);
      return;
    }
 else     if (isSelectedSeveral(structuredSelection)) {
      openWarningForSelectOneOnly(props);
      return;
    }
    String resourcePathForTargetClassFile=getResourcePathForTargetClassFile(structuredSelection).replaceFirst(config.directoryPathOfTestSourceCode,config.directoryPathOfProductSourceCode);
    String resourcePathForTestCaseFile=resourcePathForTargetClassFile.replaceFirst(config.directoryPathOfProductSourceCode,config.directoryPathOfTestSourceCode).replaceFirst(""String_Node_Str"",StringValue.JUnit.TestClassNameSuffix + StringValue.FileExtension.JavaFile);
    String projectName=getProjectName(structuredSelection);
    String projectRootAbsolutePath=getWorkspaceRootAbsolutePath(getIWorkspaceRoot()) + StringValue.DirectorySeparator.General + projectName+ StringValue.DirectorySeparator.General;
    if (!resourcePathForTestCaseFile.matches(""String_Node_Str"" + RegExp.FileExtension.JavaFile)) {
      openWarningForSelectJavaFile(props);
      return;
    }
    String targetClassName=getClassNameFromResourcePathForTargetClassFile(resourcePathForTargetClassFile);
    String testCaseFilename=getTestClassNameFromClassName(targetClassName);
    String msg=props.get(Dialog.Common.confirmToChangeToJUnitVersion3) + ""String_Node_Str"" + testCaseFilename+ ""String_Node_Str"";
    if (testCaseFilename == null || !openConfirm(props,msg)) {
      return;
    }
    System.setProperty(""String_Node_Str"",""String_Node_Str"");
    ForceJUnitVersion3Command.main(new String[]{projectRootAbsolutePath + resourcePathForTargetClassFile});
    ThreadUtil.sleep(200);
    int retryCount=0;
    while (true) {
      try {
        if (!ResourceRefreshUtil.refreshLocal(null,projectName + StringValue.DirectorySeparator.General + resourcePathForTestCaseFile+ ""String_Node_Str"")) {
          openWarningForResourceRefreshError(props);
          System.err.println(""String_Node_Str"");
          return;
        }
        retryCount=0;
        ThreadUtil.sleep(1500);
      }
 catch (      Exception e) {
        retryCount++;
        if (retryCount > 10) {
          break;
        }
        e.printStackTrace();
        ThreadUtil.sleep(1500);
      }
      break;
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
}",0.998148833765272
