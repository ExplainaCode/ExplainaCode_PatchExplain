record_number,buggy_code,fixed_code,code_similarity
158001,"/** 
 * bookmarks the current state and restores it if player doesn't pay the mana cost
 * @param ability
 * @param game
 * @param sourceId
 * @param payingPlayerId
 * @return true if the cost was paid
 */
@Override public boolean payOrRollback(Ability ability,Game game,UUID sourceId,UUID payingPlayerId){
  int bookmark=game.bookmarkState();
  if (pay(ability,game,sourceId,payingPlayerId,false,null)) {
    game.removeBookmark(bookmark);
    return true;
  }
  game.restoreState(bookmark,ability.getRule());
  return false;
}","/** 
 * bookmarks the current state and restores it if player doesn't pay the mana cost
 * @param ability
 * @param game
 * @param sourceId
 * @param payingPlayerId
 * @return true if the cost was paid
 */
@Override public boolean payOrRollback(Ability ability,Game game,UUID sourceId,UUID payingPlayerId){
  int bookmark=game.bookmarkState();
  handlePhyrexianManaCosts(payingPlayerId,ability,game);
  if (pay(ability,game,sourceId,payingPlayerId,false,null)) {
    game.removeBookmark(bookmark);
    return true;
  }
  game.restoreState(bookmark,ability.getRule());
  return false;
}",0.9487870619946092
158002,"private boolean handleManaCosts(ManaCosts attackBlockManaTax,GameEvent event,Ability source,Game game){
  Player player=game.getPlayer(event.getPlayerId());
  if (player != null) {
    String chooseText;
    if (event.getType() == EventType.DECLARE_ATTACKER) {
      chooseText=""String_Node_Str"" + attackBlockManaTax.getText() + ""String_Node_Str"";
    }
 else {
      chooseText=""String_Node_Str"" + attackBlockManaTax.getText() + ""String_Node_Str"";
    }
    attackBlockManaTax.clearPaid();
    if (attackBlockManaTax.canPay(source,source.getSourceId(),player.getId(),game) && player.chooseUse(Outcome.Neutral,chooseText,source,game)) {
      handlePhyrexianManaCosts(getManaCostToPay(event,source,game),player,source,game);
      if (attackBlockManaTax instanceof ManaCostsImpl) {
        if (attackBlockManaTax.payOrRollback(source,game,source.getSourceId(),event.getPlayerId())) {
          return false;
        }
      }
    }
    return true;
  }
  return false;
}","private boolean handleManaCosts(ManaCosts attackBlockManaTax,GameEvent event,Ability source,Game game){
  Player player=game.getPlayer(event.getPlayerId());
  if (player != null) {
    String chooseText;
    if (event.getType() == EventType.DECLARE_ATTACKER) {
      chooseText=""String_Node_Str"" + attackBlockManaTax.getText() + ""String_Node_Str"";
    }
 else {
      chooseText=""String_Node_Str"" + attackBlockManaTax.getText() + ""String_Node_Str"";
    }
    attackBlockManaTax.clearPaid();
    if (attackBlockManaTax.canPay(source,source.getSourceId(),player.getId(),game) && player.chooseUse(Outcome.Neutral,chooseText,source,game)) {
      if (attackBlockManaTax instanceof ManaCostsImpl) {
        if (attackBlockManaTax.payOrRollback(source,game,source.getSourceId(),event.getPlayerId())) {
          return false;
        }
      }
    }
    return true;
  }
  return false;
}",0.9524838012958964
158003,"public PayCostToAttackBlockEffectImpl(PayCostToAttackBlockEffectImpl effect){
  super(effect);
  if (effect.cost != null) {
    this.cost=effect.cost.copy();
  }
 else {
    this.cost=null;
  }
  if (effect.manaCosts != null) {
    this.manaCosts=effect.manaCosts.copy();
  }
 else {
    this.manaCosts=null;
  }
  this.restrictType=effect.restrictType;
}","public PayCostToAttackBlockEffectImpl(final PayCostToAttackBlockEffectImpl effect){
  super(effect);
  if (effect.cost != null) {
    this.cost=effect.cost.copy();
  }
 else {
    this.cost=null;
  }
  if (effect.manaCosts != null) {
    this.manaCosts=effect.manaCosts.copy();
  }
 else {
    this.manaCosts=null;
  }
  this.restrictType=effect.restrictType;
}",0.9916201117318436
158004,"@Override public boolean replaceEvent(GameEvent event,Ability source,Game game){
  ManaCosts attackBlockManaTax=getManaCostToPay(event,source,game);
  if (attackBlockManaTax != null) {
    return handleManaCosts(attackBlockManaTax,event,source,game);
  }
  Cost attackBlockOtherTax=getOtherCostToPay(event,source,game);
  if (attackBlockOtherTax != null) {
    return handleOtherCosts(attackBlockOtherTax,event,source,game);
  }
  return false;
}","@Override public boolean replaceEvent(GameEvent event,Ability source,Game game){
  ManaCosts attackBlockManaTax=getManaCostToPay(event,source,game);
  if (attackBlockManaTax != null) {
    return handleManaCosts(attackBlockManaTax.copy(),event,source,game);
  }
  Cost attackBlockOtherTax=getOtherCostToPay(event,source,game);
  if (attackBlockOtherTax != null) {
    return handleOtherCosts(attackBlockOtherTax.copy(),event,source,game);
  }
  return false;
}",0.9845474613686536
158005,"public CantAttackYouUnlessPayManaAllEffect(CantAttackYouUnlessPayManaAllEffect effect){
  super(effect);
  this.payAlsoForAttackingPlaneswalker=effect.payAlsoForAttackingPlaneswalker;
  this.filterCreaturePermanent=effect.filterCreaturePermanent;
}","public CantAttackYouUnlessPayManaAllEffect(final CantAttackYouUnlessPayManaAllEffect effect){
  super(effect);
  this.payAlsoForAttackingPlaneswalker=effect.payAlsoForAttackingPlaneswalker;
  this.filterCreaturePermanent=effect.filterCreaturePermanent;
}",0.9880478087649402
158006,"protected void init(UUID choosingPlayerId){
  for (  Player player : state.getPlayers().values()) {
    player.beginTurn(this);
    if (priorityTime > 0 && player.getPriorityTimeLeft() == Integer.MAX_VALUE) {
      initTimer(player.getId());
    }
  }
  if (startMessage == null || startMessage.isEmpty()) {
    startMessage=""String_Node_Str"";
  }
  fireStatusEvent(startMessage,false);
  saveState(false);
  if (gameOver(null)) {
    return;
  }
  if (!gameOptions.skipInitShuffling) {
    for (    Player player : state.getPlayers().values()) {
      player.shuffleLibrary(null,this);
    }
  }
  TargetPlayer targetPlayer=new TargetPlayer();
  targetPlayer.setTargetName(""String_Node_Str"");
  Player choosingPlayer=null;
  if (choosingPlayerId != null) {
    choosingPlayer=this.getPlayer(choosingPlayerId);
    if (choosingPlayer != null && !choosingPlayer.isInGame()) {
      choosingPlayer=null;
    }
  }
  if (choosingPlayer == null) {
    choosingPlayerId=pickChoosingPlayer();
    if (choosingPlayerId == null) {
      return;
    }
    choosingPlayer=getPlayer(choosingPlayerId);
  }
  if (choosingPlayer == null) {
    return;
  }
  getState().setChoosingPlayerId(choosingPlayerId);
  if (choosingPlayer.choose(Outcome.Benefit,targetPlayer,null,this)) {
    startingPlayerId=targetPlayer.getTargets().get(0);
  }
 else   if (getState().getPlayers().size() < 3) {
    return;
  }
  if (startingPlayerId == null) {
    for (    Player player : state.getPlayers().values()) {
      if (player.isInGame()) {
        startingPlayerId=player.getId();
        break;
      }
    }
    if (startingPlayerId == null) {
      return;
    }
  }
  Player startingPlayer=state.getPlayer(startingPlayerId);
  if (startingPlayer == null) {
    logger.debug(""String_Node_Str"" + startingPlayerId);
    return;
  }
  StringBuilder message=new StringBuilder(choosingPlayer.getLogName()).append(""String_Node_Str"");
  if (choosingPlayer.getId().equals(startingPlayerId)) {
    message.append(""String_Node_Str"");
  }
 else {
    message.append(startingPlayer.getLogName());
  }
  message.append(""String_Node_Str"");
  this.informPlayers(message.toString());
  int startingHandSize=7;
  for (  UUID playerId : state.getPlayerList(startingPlayerId)) {
    Player player=getPlayer(playerId);
    if (!gameOptions.testMode || player.getLife() == 0) {
      player.initLife(this.getLife());
    }
    if (!gameOptions.testMode) {
      player.drawCards(startingHandSize,this);
    }
  }
  List<UUID> keepPlayers=new ArrayList<>();
  List<UUID> mulliganPlayers=new ArrayList<>();
  do {
    mulliganPlayers.clear();
    for (    UUID playerId : state.getPlayerList(startingPlayerId)) {
      if (!keepPlayers.contains(playerId)) {
        Player player=getPlayer(playerId);
        boolean keep=true;
        while (true) {
          if (player.getHand().isEmpty()) {
            break;
          }
          GameEvent event=new GameEvent(GameEvent.EventType.CAN_TAKE_MULLIGAN,null,null,playerId);
          if (!replaceEvent(event)) {
            fireEvent(event);
            getState().setChoosingPlayerId(playerId);
            if (player.chooseMulligan(this)) {
              keep=false;
            }
            break;
          }
        }
        if (keep) {
          endMulligan(player.getId());
          keepPlayers.add(playerId);
          fireInformEvent(player.getLogName() + ""String_Node_Str"");
        }
 else {
          mulliganPlayers.add(playerId);
          fireInformEvent(player.getLogName() + ""String_Node_Str"");
        }
      }
    }
    for (    UUID mulliganPlayerId : mulliganPlayers) {
      mulligan(mulliganPlayerId);
    }
    saveState(false);
  }
 while (!mulliganPlayers.isEmpty());
  for (  UUID playerId : state.getPlayerList(startingPlayerId)) {
    Player player=getPlayer(playerId);
    if (player != null && player.getHand().size() < startingHandSize) {
      player.scry(1,null,this);
    }
  }
  getState().setChoosingPlayerId(null);
  Watchers watchers=state.getWatchers();
  for (  UUID playerId : state.getPlayerList(startingPlayerId)) {
    watchers.add(new PlayerDamagedBySourceWatcher(playerId));
    watchers.add(new BloodthirstWatcher(playerId));
  }
  watchers.add(new MorbidWatcher());
  watchers.add(new CastSpellLastTurnWatcher());
  watchers.add(new PlayerLostLifeWatcher());
  watchers.add(new BlockedAttackerWatcher());
  watchers.add(new DamageDoneWatcher());
  for (  UUID playerId : state.getPlayerList(startingPlayerId)) {
    Player player=getPlayer(playerId);
    Cards cardsWithOpeningAction=new CardsImpl();
    for (    Card card : player.getHand().getCards(this)) {
      for (      Ability ability : card.getAbilities()) {
        if (ability instanceof OpeningHandAction) {
          OpeningHandAction action=(OpeningHandAction)ability;
          if (action.isOpeningHandActionAllowed(card,player,this)) {
            cardsWithOpeningAction.add(card);
          }
        }
      }
    }
    while (!cardsWithOpeningAction.isEmpty() && player.canRespond()) {
      Card card;
      if (cardsWithOpeningAction.size() > 1) {
        TargetCard targetCard=new TargetCard(1,Zone.HAND,new FilterCard(""String_Node_Str""));
        player.chooseTarget(Outcome.Benefit,cardsWithOpeningAction,targetCard,null,this);
        card=getCard(targetCard.getFirstTarget());
      }
 else {
        card=cardsWithOpeningAction.getRandom(this);
      }
      if (card != null) {
        for (        Ability ability : card.getAbilities()) {
          if (ability instanceof OpeningHandAction) {
            OpeningHandAction action=(OpeningHandAction)ability;
            if (action.askUseOpeningHandAction(card,player,this)) {
              action.doOpeningHandAction(card,player,this);
            }
          }
        }
      }
      cardsWithOpeningAction.remove(card);
    }
  }
}","protected void init(UUID choosingPlayerId){
  for (  Player player : state.getPlayers().values()) {
    player.beginTurn(this);
    if (priorityTime > 0 && player.getPriorityTimeLeft() == Integer.MAX_VALUE) {
      initTimer(player.getId());
    }
  }
  if (startMessage == null || startMessage.isEmpty()) {
    startMessage=""String_Node_Str"";
  }
  fireStatusEvent(startMessage,false);
  saveState(false);
  if (gameOver(null)) {
    return;
  }
  if (!gameOptions.skipInitShuffling) {
    for (    Player player : state.getPlayers().values()) {
      player.shuffleLibrary(null,this);
    }
  }
  TargetPlayer targetPlayer=new TargetPlayer();
  targetPlayer.setTargetName(""String_Node_Str"");
  Player choosingPlayer=null;
  if (choosingPlayerId != null) {
    choosingPlayer=this.getPlayer(choosingPlayerId);
    if (choosingPlayer != null && !choosingPlayer.isInGame()) {
      choosingPlayer=null;
    }
  }
  if (choosingPlayer == null) {
    choosingPlayerId=pickChoosingPlayer();
    if (choosingPlayerId == null) {
      return;
    }
    choosingPlayer=getPlayer(choosingPlayerId);
  }
  if (choosingPlayer == null) {
    return;
  }
  getState().setChoosingPlayerId(choosingPlayerId);
  if (choosingPlayer.choose(Outcome.Benefit,targetPlayer,null,this)) {
    startingPlayerId=targetPlayer.getTargets().get(0);
  }
 else   if (getState().getPlayers().size() < 3) {
    return;
  }
  if (startingPlayerId == null) {
    for (    Player player : state.getPlayers().values()) {
      if (player.isInGame()) {
        startingPlayerId=player.getId();
        break;
      }
    }
    if (startingPlayerId == null) {
      return;
    }
  }
  Player startingPlayer=state.getPlayer(startingPlayerId);
  if (startingPlayer == null) {
    logger.debug(""String_Node_Str"" + startingPlayerId);
    return;
  }
  StringBuilder message=new StringBuilder(choosingPlayer.getLogName()).append(""String_Node_Str"");
  if (choosingPlayer.getId().equals(startingPlayerId)) {
    message.append(""String_Node_Str"");
  }
 else {
    message.append(startingPlayer.getLogName());
  }
  message.append(""String_Node_Str"");
  this.informPlayers(message.toString());
  int startingHandSize=7;
  for (  UUID playerId : state.getPlayerList(startingPlayerId)) {
    Player player=getPlayer(playerId);
    if (!gameOptions.testMode || player.getLife() == 0) {
      player.initLife(this.getLife());
    }
    if (!gameOptions.testMode) {
      player.drawCards(startingHandSize,this);
    }
  }
  List<UUID> keepPlayers=new ArrayList<>();
  List<UUID> mulliganPlayers=new ArrayList<>();
  do {
    mulliganPlayers.clear();
    for (    UUID playerId : state.getPlayerList(startingPlayerId)) {
      if (!keepPlayers.contains(playerId)) {
        Player player=getPlayer(playerId);
        boolean keep=true;
        while (true) {
          if (player.getHand().isEmpty()) {
            break;
          }
          GameEvent event=new GameEvent(GameEvent.EventType.CAN_TAKE_MULLIGAN,null,null,playerId);
          if (!replaceEvent(event)) {
            fireEvent(event);
            getState().setChoosingPlayerId(playerId);
            if (player.chooseMulligan(this)) {
              keep=false;
            }
            break;
          }
        }
        if (keep) {
          endMulligan(player.getId());
          keepPlayers.add(playerId);
          fireInformEvent(player.getLogName() + ""String_Node_Str"");
        }
 else {
          mulliganPlayers.add(playerId);
          fireInformEvent(player.getLogName() + ""String_Node_Str"");
        }
      }
    }
    for (    UUID mulliganPlayerId : mulliganPlayers) {
      mulligan(mulliganPlayerId);
    }
    saveState(false);
  }
 while (!mulliganPlayers.isEmpty());
  for (  UUID playerId : state.getPlayerList(startingPlayerId)) {
    Player player=getPlayer(playerId);
    if (player != null && player.getHand().size() < startingHandSize) {
      player.scry(1,null,this);
    }
  }
  getState().setChoosingPlayerId(null);
  state.getWatchers().reset();
  Watchers watchers=state.getWatchers();
  for (  UUID playerId : state.getPlayerList(startingPlayerId)) {
    watchers.add(new PlayerDamagedBySourceWatcher(playerId));
    watchers.add(new BloodthirstWatcher(playerId));
  }
  watchers.add(new MorbidWatcher());
  watchers.add(new CastSpellLastTurnWatcher());
  watchers.add(new PlayerLostLifeWatcher());
  watchers.add(new BlockedAttackerWatcher());
  watchers.add(new DamageDoneWatcher());
  for (  UUID playerId : state.getPlayerList(startingPlayerId)) {
    Player player=getPlayer(playerId);
    Cards cardsWithOpeningAction=new CardsImpl();
    for (    Card card : player.getHand().getCards(this)) {
      for (      Ability ability : card.getAbilities()) {
        if (ability instanceof OpeningHandAction) {
          OpeningHandAction action=(OpeningHandAction)ability;
          if (action.isOpeningHandActionAllowed(card,player,this)) {
            cardsWithOpeningAction.add(card);
          }
        }
      }
    }
    while (!cardsWithOpeningAction.isEmpty() && player.canRespond()) {
      Card card;
      if (cardsWithOpeningAction.size() > 1) {
        TargetCard targetCard=new TargetCard(1,Zone.HAND,new FilterCard(""String_Node_Str""));
        player.chooseTarget(Outcome.Benefit,cardsWithOpeningAction,targetCard,null,this);
        card=getCard(targetCard.getFirstTarget());
      }
 else {
        card=cardsWithOpeningAction.getRandom(this);
      }
      if (card != null) {
        for (        Ability ability : card.getAbilities()) {
          if (ability instanceof OpeningHandAction) {
            OpeningHandAction action=(OpeningHandAction)ability;
            if (action.askUseOpeningHandAction(card,player,this)) {
              action.doOpeningHandAction(card,player,this);
            }
          }
        }
      }
      cardsWithOpeningAction.remove(card);
    }
  }
}",0.997345663156092
158007,"@Override public void watch(GameEvent event,Game game){
  if (condition) {
    return;
  }
  if (event.getType() == GameEvent.EventType.ZONE_CHANGE && ((ZoneChangeEvent)event).isDiesEvent()) {
    Permanent p=(Permanent)game.getLastKnownInformation(event.getTargetId(),Zone.BATTLEFIELD);
    if (p != null && p.isCreature()) {
      condition=true;
    }
  }
}","@Override public void watch(GameEvent event,Game game){
  if (condition) {
    return;
  }
  if (event.getType() == GameEvent.EventType.ZONE_CHANGE && ((ZoneChangeEvent)event).isDiesEvent() && ((ZoneChangeEvent)event).getTarget().isCreature()) {
    condition=true;
  }
}",0.6497622820919176
158008,"public void downloadImages(){
  List<CardInfo> cards=CardRepository.instance.findCards(new CardCriteria());
  DownloadPictures.startDownload(null,cards);
}","public void downloadImages(){
  java.util.List<CardInfo> cards=CardRepository.instance.findCards(new CardCriteria());
  DownloadPictures.startDownload(null,cards);
}",0.96875
158009,"public static void setActive(MagePane frame){
  if (activeFrame == frame) {
    return;
  }
  if (activeFrame != null) {
    activeFrame.deactivated();
  }
  if (frame == null) {
    activeFrame=null;
    return;
  }
  LOGGER.debug(""String_Node_Str"" + frame.getTitle() + ""String_Node_Str"");
  activeFrame=frame;
  desktopPane.moveToFront(frame);
  activeFrame.setBounds(0,0,desktopPane.getWidth(),desktopPane.getHeight());
  activeFrame.revalidate();
  activeFrame.activated();
  activeFrame.setVisible(true);
  ArrowBuilder.getBuilder().hideAllPanels();
  if (frame instanceof GamePane) {
    ArrowBuilder.getBuilder().showPanel(((GamePane)frame).getGameId());
    MusicPlayer.playBGM();
  }
 else {
    MusicPlayer.stopBGM();
  }
}","public static void setActive(MagePane frame){
  try {
    ActionCallback callback=Plugins.instance.getActionCallback();
    if (callback != null && callback instanceof MageActionCallback) {
      ((MageActionCallback)callback).hideEnlargedCard();
    }
    Component container=MageFrame.getUI().getComponent(MageComponents.POPUP_CONTAINER);
    if (container.isVisible()) {
      container.setVisible(false);
      container.repaint();
    }
  }
 catch (  InterruptedException e) {
  }
  if (activeFrame == frame) {
    return;
  }
  if (activeFrame != null) {
    activeFrame.deactivated();
  }
  if (frame == null) {
    activeFrame=null;
    return;
  }
  LOGGER.debug(""String_Node_Str"" + frame.getTitle() + ""String_Node_Str"");
  activeFrame=frame;
  desktopPane.moveToFront(frame);
  activeFrame.setBounds(0,0,desktopPane.getWidth(),desktopPane.getHeight());
  activeFrame.revalidate();
  activeFrame.activated();
  activeFrame.setVisible(true);
  ArrowBuilder.getBuilder().hideAllPanels();
  if (frame instanceof GamePane) {
    ArrowBuilder.getBuilder().showPanel(((GamePane)frame).getGameId());
    MusicPlayer.playBGM();
  }
 else {
    MusicPlayer.stopBGM();
  }
}",0.7691500524658972
158010,"@Override public boolean applies(UUID sourceId,Ability source,UUID affectedControllerId,Game game){
  if (affectedControllerId.equals(source.getControllerId())) {
    if (getTargetPointer().getFirst(game,source) == null) {
      this.discard();
      return false;
    }
    if (sourceId.equals(getTargetPointer().getFirst(game,source))) {
      Card card=game.getCard(sourceId);
      if (card != null) {
        if (game.getState().getZone(sourceId) == Zone.EXILED) {
          Player player=game.getPlayer(affectedControllerId);
          player.setCastSourceIdWithAlternateMana(sourceId,null,null);
          return true;
        }
 else {
          this.discard();
        }
      }
    }
  }
  return false;
}","@Override public boolean applies(UUID sourceId,Ability source,UUID affectedControllerId,Game game){
  if (affectedControllerId.equals(source.getControllerId())) {
    if (getTargetPointer().getFirst(game,source) == null) {
      this.discard();
      return false;
    }
    if (sourceId.equals(getTargetPointer().getFirst(game,source))) {
      Card card=game.getCard(sourceId);
      if (card != null) {
        if (game.getState().getZone(sourceId) == Zone.EXILED) {
          Player player=game.getPlayer(affectedControllerId);
          player.setCastSourceIdWithAlternateMana(sourceId,null,card.getSpellAbility().getCosts());
          return true;
        }
 else {
          this.discard();
        }
      }
    }
  }
  return false;
}",0.9746401644962304
158011,"@Override public boolean applies(UUID sourceId,Ability source,UUID affectedControllerId,Game game){
  UUID targetId=getTargetPointer().getFirst(game,source);
  if (targetId != null && targetId.equals(sourceId)) {
    if (affectedControllerId.equals(source.getControllerId())) {
      Card card=game.getCard(sourceId);
      if (card != null && game.getState().getZone(sourceId) == Zone.EXILED) {
        Player player=game.getPlayer(affectedControllerId);
        player.setCastSourceIdWithAlternateMana(sourceId,null,null);
        return true;
      }
    }
  }
  return false;
}","@Override public boolean applies(UUID sourceId,Ability source,UUID affectedControllerId,Game game){
  UUID targetId=getTargetPointer().getFirst(game,source);
  if (targetId != null && targetId.equals(sourceId)) {
    if (affectedControllerId.equals(source.getControllerId())) {
      Card card=game.getCard(sourceId);
      if (card != null && game.getState().getZone(sourceId) == Zone.EXILED) {
        Player player=game.getPlayer(affectedControllerId);
        player.setCastSourceIdWithAlternateMana(sourceId,null,card.getSpellAbility().getCosts());
        return true;
      }
    }
  }
  return false;
}",0.9689336691855585
158012,"@Override public boolean applies(UUID sourceId,Ability source,UUID affectedControllerId,Game game){
  if (sourceId != null && sourceId.equals(getTargetPointer().getFirst(game,source)) && affectedControllerId.equals(source.getControllerId())) {
    Card card=game.getCard(sourceId);
    if (card != null && game.getState().getZone(sourceId) == Zone.EXILED) {
      Player player=game.getPlayer(affectedControllerId);
      player.setCastSourceIdWithAlternateMana(sourceId,null,null);
      return true;
    }
  }
  return false;
}","@Override public boolean applies(UUID sourceId,Ability source,UUID affectedControllerId,Game game){
  if (sourceId != null && sourceId.equals(getTargetPointer().getFirst(game,source)) && affectedControllerId.equals(source.getControllerId())) {
    Card card=game.getCard(sourceId);
    if (card != null && game.getState().getZone(sourceId) == Zone.EXILED) {
      Player player=game.getPlayer(affectedControllerId);
      player.setCastSourceIdWithAlternateMana(sourceId,null,card.getSpellAbility().getCosts());
      return true;
    }
  }
  return false;
}",0.965961361545538
158013,"@Override public boolean applies(UUID objectId,Ability source,UUID affectedControllerId,Game game){
  if (objectId.equals(getTargetPointer().getFirst(game,source)) && affectedControllerId.equals(source.getControllerId())) {
    Card card=game.getCard(objectId);
    if (card != null) {
      Player player=game.getPlayer(affectedControllerId);
      if (player != null) {
        player.setCastSourceIdWithAlternateMana(objectId,null,null);
        return true;
      }
    }
  }
  return false;
}","@Override public boolean applies(UUID objectId,Ability source,UUID affectedControllerId,Game game){
  if (objectId.equals(getTargetPointer().getFirst(game,source)) && affectedControllerId.equals(source.getControllerId())) {
    Card card=game.getCard(objectId);
    if (card != null) {
      Player player=game.getPlayer(affectedControllerId);
      if (player != null) {
        player.setCastSourceIdWithAlternateMana(objectId,null,card.getSpellAbility().getCosts());
        return true;
      }
    }
  }
  return false;
}",0.9638318670576737
158014,"@Override public boolean checkTrigger(GameEvent event,Game game){
  boolean weAreDoingIt=getControllerId().equals(event.getPlayerId());
  boolean isM1M1Counters=event.getData().equals(CounterType.M1M1.getName());
  if (weAreDoingIt && isM1M1Counters && event.getAmount() > 0) {
    Permanent permanent=game.getPermanentOrLKIBattlefield(event.getTargetId());
    if (permanent == null) {
      permanent=game.getPermanentEntering(event.getTargetId());
    }
    if (permanent.isCreature()) {
      getEffects().forEach(effect -> effect.setValue(""String_Node_Str"",event.getAmount()));
      return true;
    }
  }
  return false;
}","@Override public boolean checkTrigger(GameEvent event,Game game){
  boolean weAreDoingIt=getControllerId().equals(game.getControllerId(event.getSourceId()));
  boolean isM1M1Counters=event.getData().equals(CounterType.M1M1.getName());
  if (weAreDoingIt && isM1M1Counters && event.getAmount() > 0) {
    Permanent permanent=game.getPermanentOrLKIBattlefield(event.getTargetId());
    if (permanent == null) {
      permanent=game.getPermanentEntering(event.getTargetId());
    }
    if (permanent.isCreature()) {
      getEffects().forEach(effect -> effect.setValue(""String_Node_Str"",event.getAmount()));
      return true;
    }
  }
  return false;
}",0.9546875
158015,"@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  MageObject sourceObject=game.getObject(source.getSourceId());
  if (controller != null) {
    Choice typeChoice=new ChoiceImpl(true);
    typeChoice.setMessage(""String_Node_Str"");
    typeChoice.setChoices(CardRepository.instance.getCreatureTypes());
    while (!controller.choose(outcome,typeChoice,game)) {
      if (!controller.canRespond()) {
        return false;
      }
    }
    if (typeChoice.getChoice() != null) {
      game.informPlayers(sourceObject.getLogName() + ""String_Node_Str"" + typeChoice.getChoice());
    }
    FilterCard filterSubtype=new FilterCard();
    filterSubtype.add(new SubtypePredicate(typeChoice.getChoice()));
    if (controller.getLibrary().hasCards()) {
      Card card=controller.getLibrary().getFromTop(game);
      Cards cards=new CardsImpl(card);
      controller.revealCards(sourceObject.getIdName(),cards,game);
      if (card != null) {
        if (filterSubtype.match(card,game)) {
          controller.moveCards(card,Zone.HAND,source,game);
        }
 else {
          controller.moveCards(card,Zone.GRAVEYARD,source,game);
        }
      }
    }
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  MageObject sourceObject=game.getObject(source.getSourceId());
  if (controller != null) {
    Choice typeChoice=new ChoiceImpl(true);
    typeChoice.setMessage(""String_Node_Str"");
    typeChoice.setChoices(CardRepository.instance.getCreatureTypes());
    while (!controller.choose(outcome,typeChoice,game)) {
      if (!controller.canRespond()) {
        return false;
      }
    }
    if (typeChoice.getChoice() != null) {
      game.informPlayers(sourceObject.getLogName() + ""String_Node_Str"" + typeChoice.getChoice());
    }
    FilterCard filterSubtype=new FilterCard();
    filterSubtype.add(new SubtypePredicate(SubType.byDescription(typeChoice.getChoice())));
    if (controller.getLibrary().hasCards()) {
      Card card=controller.getLibrary().getFromTop(game);
      Cards cards=new CardsImpl(card);
      controller.revealCards(sourceObject.getIdName(),cards,game);
      if (card != null) {
        if (filterSubtype.match(card,game)) {
          controller.moveCards(card,Zone.HAND,source,game);
        }
 else {
          controller.moveCards(card,Zone.GRAVEYARD,source,game);
        }
      }
    }
    return true;
  }
  return false;
}",0.9743184512050572
158016,"@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  Permanent enchantment=game.getPermanent(source.getSourceId());
  if (enchantment == null || controller == null || enchantment.getAttachedTo() == null) {
    return false;
  }
  Permanent creature=game.getPermanent(enchantment.getAttachedTo());
  if (creature == null) {
    return false;
  }
  Cards cards=new CardsImpl();
  cards.addAll(controller.getLibrary().getTopCards(game,5));
  controller.lookAtCards(enchantment.getIdName(),cards,game);
  FilterCreatureCard filter=new FilterCreatureCard();
  if (!creature.getAbilities().contains(ChangelingAbility.getInstance())) {
    StringBuilder sb=new StringBuilder(""String_Node_Str"");
    ArrayList<Predicate<MageObject>> subtypes=new ArrayList<>();
    for (    String subtype : creature.getSubtype(game)) {
      subtypes.add(new SubtypePredicate(subtype));
      sb.append(subtype).append(""String_Node_Str"");
    }
    filter.add(Predicates.or(subtypes));
    sb.delete(sb.length() - 2,sb.length());
    filter.setMessage(sb.toString());
  }
 else {
    filter.setMessage(""String_Node_Str"");
  }
  if (cards.count(filter,game) > 0 && controller.chooseUse(Outcome.DrawCard,""String_Node_Str"",source,game)) {
    TargetCard target=new TargetCard(Zone.LIBRARY,filter);
    if (controller.choose(Outcome.PutCreatureInPlay,cards,target,game)) {
      Card card=cards.get(target.getFirstTarget(),game);
      if (card != null) {
        cards.remove(card);
        controller.moveCards(card,Zone.BATTLEFIELD,source,game);
      }
    }
  }
  controller.putCardsOnBottomOfLibrary(cards,game,source,true);
  return true;
}","@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  Permanent enchantment=game.getPermanent(source.getSourceId());
  if (enchantment == null || controller == null || enchantment.getAttachedTo() == null) {
    return false;
  }
  Permanent creature=game.getPermanent(enchantment.getAttachedTo());
  if (creature == null) {
    return false;
  }
  Cards cards=new CardsImpl();
  cards.addAll(controller.getLibrary().getTopCards(game,5));
  controller.lookAtCards(enchantment.getIdName(),cards,game);
  FilterCreatureCard filter=new FilterCreatureCard();
  if (!creature.getAbilities().contains(ChangelingAbility.getInstance())) {
    StringBuilder sb=new StringBuilder(""String_Node_Str"");
    ArrayList<Predicate<MageObject>> subtypes=new ArrayList<>();
    for (    String subtype : creature.getSubtype(game)) {
      subtypes.add(new SubtypePredicate(SubType.byDescription(subtype)));
      sb.append(subtype).append(""String_Node_Str"");
    }
    filter.add(Predicates.or(subtypes));
    sb.delete(sb.length() - 2,sb.length());
    filter.setMessage(sb.toString());
  }
 else {
    filter.setMessage(""String_Node_Str"");
  }
  if (cards.count(filter,game) > 0 && controller.chooseUse(Outcome.DrawCard,""String_Node_Str"",source,game)) {
    TargetCard target=new TargetCard(Zone.LIBRARY,filter);
    if (controller.choose(Outcome.PutCreatureInPlay,cards,target,game)) {
      Card card=cards.get(target.getFirstTarget(),game);
      if (card != null) {
        cards.remove(card);
        controller.moveCards(card,Zone.BATTLEFIELD,source,game);
      }
    }
  }
  controller.putCardsOnBottomOfLibrary(cards,game,source,true);
  return true;
}",0.989114445425125
158017,"@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller != null) {
    Choice choice=new ChoiceImpl(true);
    choice.setMessage(""String_Node_Str"");
    choice.setChoices(CardRepository.instance.getCreatureTypes());
    if (controller.choose(Outcome.Damage,choice,game)) {
      String chosenType=choice.getChoice();
      FilterControlledPermanent filter=new FilterControlledPermanent();
      filter.add(new SubtypePredicate(chosenType));
      int damageDealt=game.getBattlefield().count(filter,source.getSourceId(),source.getControllerId(),game);
      Permanent permanent=game.getPermanent(this.getTargetPointer().getFirst(game,source));
      if (permanent != null) {
        permanent.damage(damageDealt,source.getSourceId(),game,false,true);
      }
      return true;
    }
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller != null) {
    Choice choice=new ChoiceImpl(true);
    choice.setMessage(""String_Node_Str"");
    choice.setChoices(SubType.getCreatureTypes(false));
    if (controller.choose(Outcome.Damage,choice,game)) {
      String chosenType=choice.getChoice();
      FilterControlledPermanent filter=new FilterControlledPermanent();
      filter.add(new SubtypePredicate(SubType.byDescription(chosenType)));
      int damageDealt=game.getBattlefield().count(filter,source.getSourceId(),source.getControllerId(),game);
      Permanent permanent=game.getPermanent(this.getTargetPointer().getFirst(game,source));
      if (permanent != null) {
        permanent.damage(damageDealt,source.getSourceId(),game,false,true);
      }
      return true;
    }
  }
  return false;
}",0.7205387205387206
158018,"private void searchCard(Player player,Ability source,Game game,Cards cards,String subtype){
  FilterCard filter=new FilterCard(subtype);
  filter.add(new SubtypePredicate(subtype));
  TargetCardInLibrary target=new TargetCardInLibrary(filter);
  if (player.searchLibrary(target,game)) {
    Card card=player.getLibrary().remove(target.getFirstTarget(),game);
    if (card != null) {
      card.moveToZone(Zone.HAND,source.getSourceId(),game,false);
      cards.add(card);
    }
  }
}","private void searchCard(Player player,Ability source,Game game,Cards cards,String subtype){
  FilterCard filter=new FilterCard(subtype);
  filter.add(new SubtypePredicate(SubType.byDescription(subtype)));
  TargetCardInLibrary target=new TargetCardInLibrary(filter);
  if (player.searchLibrary(target,game)) {
    Card card=player.getLibrary().remove(target.getFirstTarget(),game);
    if (card != null) {
      card.moveToZone(Zone.HAND,source.getSourceId(),game,false);
      cards.add(card);
    }
  }
}",0.962588473205258
158019,"@Override public boolean apply(Game game,Ability source){
  Player player=game.getPlayer(source.getControllerId());
  if (source == null || source.getCosts() == null) {
    return false;
  }
  FilterCard filter=new FilterCreatureCard(""String_Node_Str"");
  for (  Cost cost : source.getCosts()) {
    if (cost instanceof CrypticGatewayCost) {
      UUID id=((CrypticGatewayCost)cost).getTargetCreatureId();
      UUID id2=((CrypticGatewayCost)cost).getTargetCreatureId2();
      Permanent creature=game.getPermanentOrLKIBattlefield(id);
      Permanent creature2=game.getPermanentOrLKIBattlefield(id2);
      if (creature == null || creature2 == null) {
        return false;
      }
      boolean commonSubType=false;
      boolean changeling=false;
      boolean changeling2=false;
      if (creature.getAbilities().containsKey(ChangelingAbility.getInstance().getId()) || creature.getSubtype(game).contains(ChangelingAbility.ALL_CREATURE_TYPE)) {
        changeling=true;
      }
      if (creature2.getAbilities().containsKey(ChangelingAbility.getInstance().getId()) || creature2.getSubtype(game).contains(ChangelingAbility.ALL_CREATURE_TYPE)) {
        changeling2=true;
      }
      ArrayList<SubtypePredicate> subtypes=new ArrayList<>();
      for (      String subtype : creature.getSubtype(game)) {
        if (creature2.getSubtype(game).contains(subtype) || changeling2) {
          subtypes.add(new SubtypePredicate(subtype));
          commonSubType=true;
        }
      }
      for (      String subtype : creature2.getSubtype(game)) {
        if (creature.getSubtype(game).contains(subtype) || changeling) {
          subtypes.add(new SubtypePredicate(subtype));
          commonSubType=true;
        }
      }
      if (changeling && changeling2) {
        filter=new FilterCreatureCard(""String_Node_Str"");
      }
 else       if (commonSubType) {
        filter.add(Predicates.or(subtypes));
      }
      if (commonSubType) {
        PutPermanentOnBattlefieldEffect putIntoPlay=new PutPermanentOnBattlefieldEffect(filter);
        putIntoPlay.apply(game,source);
      }
    }
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Player player=game.getPlayer(source.getControllerId());
  if (source == null || source.getCosts() == null) {
    return false;
  }
  FilterCard filter=new FilterCreatureCard(""String_Node_Str"");
  for (  Cost cost : source.getCosts()) {
    if (cost instanceof CrypticGatewayCost) {
      UUID id=((CrypticGatewayCost)cost).getTargetCreatureId();
      UUID id2=((CrypticGatewayCost)cost).getTargetCreatureId2();
      Permanent creature=game.getPermanentOrLKIBattlefield(id);
      Permanent creature2=game.getPermanentOrLKIBattlefield(id2);
      if (creature == null || creature2 == null) {
        return false;
      }
      boolean commonSubType=false;
      boolean changeling=false;
      boolean changeling2=false;
      if (creature.getAbilities().containsKey(ChangelingAbility.getInstance().getId()) || creature.getSubtype(game).contains(ChangelingAbility.ALL_CREATURE_TYPE)) {
        changeling=true;
      }
      if (creature2.getAbilities().containsKey(ChangelingAbility.getInstance().getId()) || creature2.getSubtype(game).contains(ChangelingAbility.ALL_CREATURE_TYPE)) {
        changeling2=true;
      }
      ArrayList<SubtypePredicate> subtypes=new ArrayList<>();
      for (      String subtype : creature.getSubtype(game)) {
        if (creature2.getSubtype(game).contains(subtype) || changeling2) {
          subtypes.add(new SubtypePredicate(SubType.byDescription(subtype)));
          commonSubType=true;
        }
      }
      for (      String subtype : creature2.getSubtype(game)) {
        if (creature.getSubtype(game).contains(subtype) || changeling) {
          subtypes.add(new SubtypePredicate(SubType.byDescription(subtype)));
          commonSubType=true;
        }
      }
      if (changeling && changeling2) {
        filter=new FilterCreatureCard(""String_Node_Str"");
      }
 else       if (commonSubType) {
        filter.add(Predicates.or(subtypes));
      }
      if (commonSubType) {
        PutPermanentOnBattlefieldEffect putIntoPlay=new PutPermanentOnBattlefieldEffect(filter);
        putIntoPlay.apply(game,source);
      }
    }
  }
  return false;
}",0.9826941066417212
158020,"@Override public boolean apply(Game game,Ability source){
  Player player=game.getPlayer(source.getControllerId());
  if (player != null) {
    Choice typeChoice=new ChoiceImpl(true);
    typeChoice.setMessage(""String_Node_Str"");
    typeChoice.setChoices(CardRepository.instance.getCreatureTypes());
    while (!player.choose(Outcome.BoostCreature,typeChoice,game)) {
      if (!player.canRespond()) {
        return false;
      }
    }
    FilterControlledCreaturePermanent filter=new FilterControlledCreaturePermanent();
    filter.add(new SubtypePredicate(typeChoice.getChoice()));
    return new DrawCardSourceControllerEffect(new PermanentsOnBattlefieldCount(filter)).apply(game,source);
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Player player=game.getPlayer(source.getControllerId());
  if (player != null) {
    Choice typeChoice=new ChoiceImpl(true);
    typeChoice.setMessage(""String_Node_Str"");
    typeChoice.setChoices(CardRepository.instance.getCreatureTypes());
    while (!player.choose(Outcome.BoostCreature,typeChoice,game)) {
      if (!player.canRespond()) {
        return false;
      }
    }
    FilterControlledCreaturePermanent filter=new FilterControlledCreaturePermanent();
    filter.add(new SubtypePredicate(SubType.byDescription(typeChoice.getChoice())));
    return new DrawCardSourceControllerEffect(new PermanentsOnBattlefieldCount(filter)).apply(game,source);
  }
  return false;
}",0.9553264604810996
158021,"@Override public boolean checkTrigger(GameEvent event,Game game){
  Permanent doorOfDestinies=game.getPermanent(getSourceId());
  if (doorOfDestinies != null) {
    String subtype=(String)game.getState().getValue(doorOfDestinies.getId() + ""String_Node_Str"");
    if (subtype != null) {
      FilterSpell filter=new FilterSpell();
      filter.add(new ControllerPredicate(TargetController.YOU));
      filter.add(new SubtypePredicate(subtype));
      Spell spell=game.getStack().getSpell(event.getTargetId());
      if (spell != null && filter.match(spell,getSourceId(),getControllerId(),game)) {
        return true;
      }
    }
  }
  return false;
}","@Override public boolean checkTrigger(GameEvent event,Game game){
  Permanent doorOfDestinies=game.getPermanent(getSourceId());
  if (doorOfDestinies != null) {
    String subtype=(String)game.getState().getValue(doorOfDestinies.getId() + ""String_Node_Str"");
    if (subtype != null) {
      FilterSpell filter=new FilterSpell();
      filter.add(new ControllerPredicate(TargetController.YOU));
      filter.add(new SubtypePredicate(SubType.byDescription(subtype)));
      Spell spell=game.getStack().getSpell(event.getTargetId());
      if (spell != null && filter.match(spell,getSourceId(),getControllerId(),game)) {
        return true;
      }
    }
  }
  return false;
}",0.9766390354182366
158022,"@Override public boolean apply(Game game,Ability source){
  Player player=game.getPlayer(source.getControllerId());
  MageObject sourceObject=game.getObject(source.getSourceId());
  if (player != null) {
    Choice typeChoice=new ChoiceImpl(true);
    typeChoice.setMessage(""String_Node_Str"");
    typeChoice.setChoices(CardRepository.instance.getCreatureTypes());
    while (!player.choose(outcome,typeChoice,game)) {
      if (!player.canRespond()) {
        return false;
      }
    }
    if (typeChoice.getChoice() != null) {
      game.informPlayers(sourceObject.getLogName() + ""String_Node_Str"" + typeChoice.getChoice());
    }
    FilterCreaturePermanent filterCreaturePermanent=new FilterCreaturePermanent();
    filterCreaturePermanent.add(new SubtypePredicate(typeChoice.getChoice()));
    for (    Permanent creature : game.getBattlefield().getActivePermanents(filterCreaturePermanent,source.getSourceId(),game)) {
      creature.destroy(source.getSourceId(),game,true);
    }
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Player player=game.getPlayer(source.getControllerId());
  MageObject sourceObject=game.getObject(source.getSourceId());
  if (player != null) {
    Choice typeChoice=new ChoiceImpl(true);
    typeChoice.setMessage(""String_Node_Str"");
    typeChoice.setChoices(SubType.getCreatureTypes(false));
    while (!player.choose(outcome,typeChoice,game)) {
      if (!player.canRespond()) {
        return false;
      }
    }
    if (typeChoice.getChoice() != null) {
      game.informPlayers(sourceObject.getLogName() + ""String_Node_Str"" + typeChoice.getChoice());
    }
    FilterCreaturePermanent filterCreaturePermanent=new FilterCreaturePermanent();
    filterCreaturePermanent.add(new SubtypePredicate(SubType.byDescription(typeChoice.getChoice())));
    for (    Permanent creature : game.getBattlefield().getActivePermanents(filterCreaturePermanent,source.getSourceId(),game)) {
      creature.destroy(source.getSourceId(),game,true);
    }
    return true;
  }
  return false;
}",0.9380445304937076
158023,"private void searchLand(Player player,Ability source,Game game,Cards cards,String subtype){
  FilterLandCard filter=new FilterLandCard(subtype);
  filter.add(new SubtypePredicate(subtype));
  TargetCardInLibrary target=new TargetCardInLibrary(filter);
  if (player.searchLibrary(target,game)) {
    Card card=player.getLibrary().remove(target.getFirstTarget(),game);
    if (card != null) {
      card.moveToZone(Zone.HAND,source.getSourceId(),game,false);
      cards.add(card);
    }
  }
}","private void searchLand(Player player,Ability source,Game game,Cards cards,String subtype){
  FilterLandCard filter=new FilterLandCard(subtype);
  filter.add(new SubtypePredicate(SubType.byDescription(subtype)));
  TargetCardInLibrary target=new TargetCardInLibrary(filter);
  if (player.searchLibrary(target,game)) {
    Card card=player.getLibrary().remove(target.getFirstTarget(),game);
    if (card != null) {
      card.moveToZone(Zone.HAND,source.getSourceId(),game,false);
      cards.add(card);
    }
  }
}",0.96318407960199
158024,"@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  MageObject sourceObject=game.getObject(source.getSourceId());
  if (sourceObject != null && controller != null) {
    Choice typeChoice=new ChoiceImpl(true);
    typeChoice.setMessage(""String_Node_Str"");
    typeChoice.setChoices(CardRepository.instance.getCreatureTypes());
    while (!controller.choose(Outcome.BoostCreature,typeChoice,game)) {
      if (!controller.canRespond()) {
        return false;
      }
    }
    String typeChosen=typeChoice.getChoice();
    if (!typeChosen.isEmpty()) {
      game.informPlayers(controller.getLogName() + ""String_Node_Str"" + typeChosen);
      FilterCreaturePermanent filter=new FilterCreaturePermanent();
      filter.add(new SubtypePredicate(typeChosen));
      game.addEffect(new BoostAllEffect(3,3,Duration.EndOfTurn,filter,false),source);
    }
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  MageObject sourceObject=game.getObject(source.getSourceId());
  if (sourceObject != null && controller != null) {
    Choice typeChoice=new ChoiceImpl(true);
    typeChoice.setMessage(""String_Node_Str"");
    typeChoice.setChoices(CardRepository.instance.getCreatureTypes());
    while (!controller.choose(Outcome.BoostCreature,typeChoice,game)) {
      if (!controller.canRespond()) {
        return false;
      }
    }
    String typeChosen=typeChoice.getChoice();
    if (!typeChosen.isEmpty()) {
      game.informPlayers(controller.getLogName() + ""String_Node_Str"" + typeChosen);
      FilterCreaturePermanent filter=new FilterCreaturePermanent();
      filter.add(new SubtypePredicate(SubType.byDescription(typeChosen)));
      game.addEffect(new BoostAllEffect(3,3,Duration.EndOfTurn,filter,false),source);
    }
    return true;
  }
  return false;
}",0.9777777777777776
158025,"@Override public boolean apply(Game game,Ability source){
  Player player=game.getPlayer(source.getControllerId());
  if (player != null) {
    Choice typeChoice=new ChoiceImpl(true);
    typeChoice.setMessage(""String_Node_Str"");
    typeChoice.setChoices(CardRepository.instance.getCreatureTypes());
    while (!player.choose(Outcome.UnboostCreature,typeChoice,game)) {
      if (!player.canRespond()) {
        return false;
      }
    }
    FilterControlledCreaturePermanent filter=new FilterControlledCreaturePermanent();
    filter.add(new SubtypePredicate(typeChoice.getChoice()));
    DynamicValue negativePermanentsCount=new PermanentsOnBattlefieldCount(filter,-1);
    ContinuousEffect effect=new BoostTargetEffect(negativePermanentsCount,negativePermanentsCount,Duration.EndOfTurn,true);
    effect.setTargetPointer(new FixedTarget(source.getFirstTarget()));
    game.addEffect(effect,source);
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Player player=game.getPlayer(source.getControllerId());
  if (player != null) {
    Choice typeChoice=new ChoiceImpl(true);
    typeChoice.setMessage(""String_Node_Str"");
    typeChoice.setChoices(CardRepository.instance.getCreatureTypes());
    while (!player.choose(Outcome.UnboostCreature,typeChoice,game)) {
      if (!player.canRespond()) {
        return false;
      }
    }
    FilterControlledCreaturePermanent filter=new FilterControlledCreaturePermanent();
    filter.add(new SubtypePredicate(SubType.byDescription(typeChoice.getChoice())));
    DynamicValue negativePermanentsCount=new PermanentsOnBattlefieldCount(filter,-1);
    ContinuousEffect effect=new BoostTargetEffect(negativePermanentsCount,negativePermanentsCount,Duration.EndOfTurn,true);
    effect.setTargetPointer(new FixedTarget(source.getFirstTarget()));
    game.addEffect(effect,source);
    return true;
  }
  return false;
}",0.965950759559979
158026,"@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  MageObject sourceObject=game.getObject(source.getSourceId());
  if (controller != null) {
    Set<String> chosenTypes=new HashSet<>();
    for (    UUID playerId : game.getState().getPlayersInRange(controller.getId(),game)) {
      Player player=game.getPlayer(playerId);
      Choice typeChoice=new ChoiceImpl(true);
      typeChoice.setMessage(""String_Node_Str"");
      typeChoice.setChoices(CardRepository.instance.getCreatureTypes());
      while (!player.choose(Outcome.PutCreatureInPlay,typeChoice,game)) {
        if (!player.canRespond()) {
          break;
        }
      }
      String chosenType=typeChoice.getChoice();
      if (chosenType != null) {
        game.informPlayers(sourceObject.getLogName() + ""String_Node_Str"" + player.getLogName()+ ""String_Node_Str""+ chosenType);
        chosenTypes.add(chosenType);
      }
    }
    List<SubtypePredicate> predicates=new ArrayList<>();
    for (    String type : chosenTypes) {
      predicates.add(new SubtypePredicate(type));
    }
    FilterCard filter=new FilterCreatureCard();
    filter.add(Predicates.or(predicates));
    for (    UUID playerId : game.getState().getPlayersInRange(controller.getId(),game)) {
      Player player=game.getPlayer(playerId);
      if (player != null) {
        player.moveCards(player.getGraveyard().getCards(filter,game),Zone.BATTLEFIELD,source,game);
      }
    }
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  MageObject sourceObject=game.getObject(source.getSourceId());
  if (controller != null) {
    Set<String> chosenTypes=new HashSet<>();
    for (    UUID playerId : game.getState().getPlayersInRange(controller.getId(),game)) {
      Player player=game.getPlayer(playerId);
      Choice typeChoice=new ChoiceImpl(true);
      typeChoice.setMessage(""String_Node_Str"");
      typeChoice.setChoices(CardRepository.instance.getCreatureTypes());
      while (!player.choose(Outcome.PutCreatureInPlay,typeChoice,game)) {
        if (!player.canRespond()) {
          break;
        }
      }
      String chosenType=typeChoice.getChoice();
      if (chosenType != null) {
        game.informPlayers(sourceObject.getLogName() + ""String_Node_Str"" + player.getLogName()+ ""String_Node_Str""+ chosenType);
        chosenTypes.add(chosenType);
      }
    }
    List<SubtypePredicate> predicates=new ArrayList<>();
    for (    String type : chosenTypes) {
      predicates.add(new SubtypePredicate(SubType.byDescription(type)));
    }
    FilterCard filter=new FilterCreatureCard();
    filter.add(Predicates.or(predicates));
    for (    UUID playerId : game.getState().getPlayersInRange(controller.getId(),game)) {
      Player player=game.getPlayer(playerId);
      if (player != null) {
        player.moveCards(player.getGraveyard().getCards(filter,game),Zone.BATTLEFIELD,source,game);
      }
    }
    return true;
  }
  return false;
}",0.9899317960376746
158027,"@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller != null) {
    Set<Card> lands=new HashSet<>();
    for (    UUID playerId : game.getState().getPlayersInRange(controller.getId(),game)) {
      Player player=game.getPlayer(playerId);
      if (player != null) {
        for (        String landName : new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""}) {
          FilterLandPermanent filter=new FilterLandPermanent(landName + ""String_Node_Str"");
          filter.add(new SubtypePredicate(landName));
          filter.add(new ControllerPredicate(TargetController.YOU));
          Target target=new TargetLandPermanent(1,1,filter,true);
          if (target.canChoose(source.getSourceId(),player.getId(),game)) {
            player.chooseTarget(outcome,target,source,game);
            lands.add(game.getPermanent(target.getFirstTarget()));
          }
        }
      }
    }
    controller.moveCards(lands,Zone.HAND,source,game);
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller != null) {
    Set<Card> lands=new HashSet<>();
    for (    UUID playerId : game.getState().getPlayersInRange(controller.getId(),game)) {
      Player player=game.getPlayer(playerId);
      if (player != null) {
        for (        String landName : SubType.getBasicLands(false)) {
          FilterLandPermanent filter=new FilterLandPermanent(landName + ""String_Node_Str"");
          filter.add(new SubtypePredicate(SubType.byDescription(landName)));
          filter.add(new ControllerPredicate(TargetController.YOU));
          Target target=new TargetLandPermanent(1,1,filter,true);
          if (target.canChoose(source.getSourceId(),player.getId(),game)) {
            player.chooseTarget(outcome,target,source,game);
            lands.add(game.getPermanent(target.getFirstTarget()));
          }
        }
      }
    }
    controller.moveCards(lands,Zone.HAND,source,game);
    return true;
  }
  return false;
}",0.8154981549815498
158028,"@Override public boolean apply(Game game,Ability source){
  Player player=game.getPlayer(source.getControllerId());
  MageObject sourceObject=game.getObject(source.getSourceId());
  if (player != null) {
    Choice typeChoice=new ChoiceImpl(true);
    typeChoice.setMessage(""String_Node_Str"");
    typeChoice.setChoices(CardRepository.instance.getCreatureTypes());
    while (!player.choose(outcome,typeChoice,game)) {
      if (!player.canRespond()) {
        return false;
      }
    }
    if (typeChoice.getChoice() != null) {
      game.informPlayers(sourceObject.getLogName() + ""String_Node_Str"" + typeChoice.getChoice());
    }
    FilterCreaturePermanent filterCreaturePermanent=new FilterCreaturePermanent();
    filterCreaturePermanent.add(new SubtypePredicate(typeChoice.getChoice()));
    for (    Permanent creature : game.getBattlefield().getActivePermanents(filterCreaturePermanent,source.getSourceId(),game)) {
      creature.untap(game);
    }
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Player player=game.getPlayer(source.getControllerId());
  MageObject sourceObject=game.getObject(source.getSourceId());
  if (player != null) {
    Choice typeChoice=new ChoiceImpl(true);
    typeChoice.setMessage(""String_Node_Str"");
    typeChoice.setChoices(SubType.getCreatureTypes(false));
    while (!player.choose(outcome,typeChoice,game)) {
      if (!player.canRespond()) {
        return false;
      }
    }
    if (typeChoice.getChoice() != null) {
      game.informPlayers(sourceObject.getLogName() + ""String_Node_Str"" + typeChoice.getChoice());
    }
    FilterCreaturePermanent filterCreaturePermanent=new FilterCreaturePermanent();
    filterCreaturePermanent.add(new SubtypePredicate(SubType.byDescription(typeChoice.getChoice())));
    for (    Permanent creature : game.getBattlefield().getActivePermanents(filterCreaturePermanent,source.getSourceId(),game)) {
      creature.untap(game);
    }
    return true;
  }
  return false;
}",0.936318407960199
158029,"private Mana getManaTypes(Game game,Ability source){
  List<Permanent> lands=game.getBattlefield().getActivePermanents(filter,source.getControllerId(),game);
  Mana types=new Mana();
  for (  Permanent land : lands) {
    Abilities<Ability> manaAbilities=land.getAbilities().getManaAbilities(Zone.BATTLEFIELD);
    for (    Ability basicAbility : manaAbilities) {
      ManaAbility ability=(ManaAbility)basicAbility;
      if (!ability.equals(source) && ability.definesMana(game)) {
        for (        Mana netMana : ability.getNetMana(game)) {
          types.add(netMana);
          if (netMana.getAny() > 0) {
            return types;
          }
        }
      }
    }
  }
  return types;
}","private Mana getManaTypes(Game game,Ability source){
  Mana types=new Mana();
  if (game == null || game.getPhase() == null) {
    return types;
  }
  List<Permanent> lands=game.getBattlefield().getActivePermanents(filter,source.getControllerId(),source.getSourceId(),game);
  for (  Permanent land : lands) {
    Abilities<Ability> manaAbilities=land.getAbilities().getManaAbilities(Zone.BATTLEFIELD);
    for (    Ability basicAbility : manaAbilities) {
      ManaAbility ability=(ManaAbility)basicAbility;
      if (!(ability instanceof ReflectingPoolManaAbility) && ability.definesMana(game)) {
        for (        Mana netMana : ability.getNetMana(game)) {
          types.add(netMana);
          if (netMana.getAny() > 0) {
            return types;
          }
        }
      }
    }
  }
  return types;
}",0.8597883597883598
158030,"private Mana getManaTypes(Game game,Ability source){
  Logger.getLogger(this.getClass().getName()).log(Level.WARNING,""String_Node_Str"",source.getSourceObject(game).getName());
  List<Permanent> lands=game.getBattlefield().getActivePermanents(filter,source.getControllerId(),source.getSourceId(),game);
  Mana types=new Mana();
  for (  Permanent land : lands) {
    Abilities<ActivatedManaAbilityImpl> mana=land.getAbilities().getActivatedManaAbilities(Zone.BATTLEFIELD);
    for (    ActivatedManaAbilityImpl ability : mana) {
      if (!ability.equals(source) && ability.definesMana(game)) {
        for (        Mana netMana : ability.getNetMana(game)) {
          types.add(netMana);
        }
      }
    }
  }
  return types;
}","private Mana getManaTypes(Game game,Ability source){
  List<Permanent> lands=game.getBattlefield().getActivePermanents(filter,source.getControllerId(),source.getSourceId(),game);
  Mana types=new Mana();
  for (  Permanent land : lands) {
    Abilities<ActivatedManaAbilityImpl> mana=land.getAbilities().getActivatedManaAbilities(Zone.BATTLEFIELD);
    for (    ActivatedManaAbilityImpl ability : mana) {
      if (!ability.equals(source) && ability.definesMana(game)) {
        for (        Mana netMana : ability.getNetMana(game)) {
          types.add(netMana);
        }
      }
    }
  }
  return types;
}",0.9084139985107968
158031,"protected void copyFromCard(final Card card,final Game game){
  this.name=card.getName();
  this.abilities.clear();
  if (this.faceDown) {
    for (    Ability ability : card.getAbilities()) {
      if (ability.getWorksFaceDown()) {
        this.abilities.add(ability.copy());
      }
    }
  }
 else {
    this.abilities=card.getAbilities().copy();
  }
  this.abilities.setControllerId(this.controllerId);
  this.abilities.setSourceId(objectId);
  this.cardType.clear();
  this.cardType.addAll(card.getCardType());
  this.color=card.getColor(null).copy();
  this.frameColor=card.getFrameColor(null).copy();
  this.frameStyle=card.getFrameStyle();
  this.manaCost=card.getManaCost().copy();
  if (card instanceof PermanentCard) {
    this.maxLevelCounters=((PermanentCard)card).maxLevelCounters;
  }
  this.subtype.clear();
  this.subtype.addAll(card.getSubtype(game));
  this.supertype.clear();
  supertype.addAll(card.getSuperType());
  this.expansionSetCode=card.getExpansionSetCode();
  this.rarity=card.getRarity();
  this.cardNumber=card.getCardNumber();
  this.usesVariousArt=card.getUsesVariousArt();
  transformable=card.isTransformable();
  if (transformable) {
    this.nightCard=card.isNightCard();
    if (!this.nightCard) {
      this.secondSideCard=card.getSecondCardFace();
      this.secondSideCardClazz=this.secondSideCard.getClass();
    }
  }
  this.flipCard=card.isFlipCard();
  this.flipCardName=card.getFlipCardName();
}","protected void copyFromCard(final Card card,final Game game){
  this.name=card.getName();
  this.abilities.clear();
  if (this.faceDown) {
    for (    Ability ability : card.getAbilities()) {
      if (ability.getWorksFaceDown()) {
        this.abilities.add(ability.copy());
      }
    }
  }
 else {
    this.abilities=card.getAbilities().copy();
  }
  this.abilities.setControllerId(this.controllerId);
  this.abilities.setSourceId(objectId);
  this.cardType.clear();
  this.cardType.addAll(card.getCardType());
  this.color=card.getColor(null).copy();
  this.frameColor=card.getFrameColor(game).copy();
  this.frameStyle=card.getFrameStyle();
  this.manaCost=card.getManaCost().copy();
  if (card instanceof PermanentCard) {
    this.maxLevelCounters=((PermanentCard)card).maxLevelCounters;
  }
  this.subtype.clear();
  this.subtype.addAll(card.getSubtype(game));
  this.supertype.clear();
  supertype.addAll(card.getSuperType());
  this.expansionSetCode=card.getExpansionSetCode();
  this.rarity=card.getRarity();
  this.cardNumber=card.getCardNumber();
  this.usesVariousArt=card.getUsesVariousArt();
  transformable=card.isTransformable();
  if (transformable) {
    this.nightCard=card.isNightCard();
    if (!this.nightCard) {
      this.secondSideCard=card.getSecondCardFace();
      this.secondSideCardClazz=this.secondSideCard.getClass();
    }
  }
  this.flipCard=card.isFlipCard();
  this.flipCardName=card.getFlipCardName();
}",0.9972279972279972
158032,"@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller != null) {
    int destroyedCreature=0;
    FilterCreaturePermanent filter=new FilterCreaturePermanent(""String_Node_Str"");
    filter.add(Predicates.not(new ColorPredicate(ObjectColor.BLACK)));
    for (    Permanent creature : game.getState().getBattlefield().getActivePermanents(filter,controller.getId(),game)) {
      if (creature.destroy(source.getSourceId(),game,false)) {
        destroyedCreature++;
      }
    }
    if (destroyedCreature > 0) {
      new DamageControllerEffect(destroyedCreature + 3).apply(game,source);
    }
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller != null) {
    int destroyedCreature=0;
    FilterCreaturePermanent filter=new FilterCreaturePermanent(""String_Node_Str"");
    filter.add(Predicates.not(new ColorPredicate(ObjectColor.BLACK)));
    for (    Permanent creature : game.getState().getBattlefield().getActivePermanents(filter,controller.getId(),game)) {
      if (creature.destroy(source.getSourceId(),game,false) && game.getState().getZone(creature.getId()).equals(Zone.GRAVEYARD)) {
        destroyedCreature++;
      }
    }
    if (destroyedCreature > 0) {
      new DamageControllerEffect(destroyedCreature + 3).apply(game,source);
    }
    return true;
  }
  return false;
}",0.9544235924932976
158033,"@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller != null && getTargetPointer().getFirst(game,source) != null) {
    for (    Permanent permanent : game.getBattlefield().getAllActivePermanents(new FilterCreaturePermanent(),getTargetPointer().getFirst(game,source),game)) {
      if (permanent.destroy(source.getSourceId(),game,false)) {
        Effect effect=new CreateTokenTargetEffect(new GoblinToken(),2);
        effect.setTargetPointer(getTargetPointer());
        effect.apply(game,source);
      }
    }
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller != null && getTargetPointer().getFirst(game,source) != null) {
    for (    Permanent permanent : game.getBattlefield().getAllActivePermanents(new FilterCreaturePermanent(),getTargetPointer().getFirst(game,source),game)) {
      if (permanent.destroy(source.getSourceId(),game,false)) {
        if (game.getState().getZone(permanent.getId()).equals(Zone.GRAVEYARD)) {
          Effect effect=new CreateTokenTargetEffect(new GoblinToken(),2);
          effect.setTargetPointer(getTargetPointer());
          effect.apply(game,source);
        }
      }
    }
    return true;
  }
  return false;
}",0.929145361577794
158034,"@Override protected Game createNewGameAndPlayers() throws GameException, FileNotFoundException {
  setDecknamePlayerA(""String_Node_Str"");
  return super.createNewGameAndPlayers();
}","@Override protected Game createNewGameAndPlayers() throws GameException, FileNotFoundException {
  setDecknamePlayerA(""String_Node_Str"");
  setDecknamePlayerB(""String_Node_Str"");
  return super.createNewGameAndPlayers();
}",0.8982630272952854
158035,"@Override public boolean apply(Game game,Ability source){
  for (  UUID opponentId : game.getOpponents(source.getControllerId())) {
    PlayerDamagedBySourceWatcher watcher=(PlayerDamagedBySourceWatcher)game.getState().getWatchers().get(PlayerDamagedBySourceWatcher.class.getSimpleName(),opponentId);
    if (watcher != null) {
      return watcher.hasSourceDoneDamage(source.getSourceId(),game);
    }
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  for (  UUID opponentId : game.getOpponents(source.getControllerId())) {
    PlayerDamagedBySourceWatcher watcher=(PlayerDamagedBySourceWatcher)game.getState().getWatchers().get(PlayerDamagedBySourceWatcher.class.getSimpleName(),opponentId);
    if (watcher != null) {
      if (watcher.hasSourceDoneDamage(source.getSourceId(),game)) {
        return true;
      }
    }
  }
  return false;
}",0.952054794520548
158036,"private Mana getManaTypes(Game game,Ability source){
  List<Permanent> lands=game.getBattlefield().getActivePermanents(filter,source.getControllerId(),game);
  Mana types=new Mana();
  for (  Permanent land : lands) {
    Abilities<Ability> manaAbilities=land.getAbilities().getManaAbilities(Zone.BATTLEFIELD);
    for (    Ability basicAbility : manaAbilities) {
      ManaAbility ability=(ManaAbility)basicAbility;
      if (!ability.equals(source) && ability.definesMana()) {
        for (        Mana netMana : ability.getNetMana(game)) {
          types.add(netMana);
          if (netMana.getAny() > 0) {
            return types;
          }
        }
      }
    }
  }
  return types;
}","private Mana getManaTypes(Game game,Ability source){
  List<Permanent> lands=game.getBattlefield().getActivePermanents(filter,source.getControllerId(),game);
  Mana types=new Mana();
  for (  Permanent land : lands) {
    Abilities<Ability> manaAbilities=land.getAbilities(game).getManaAbilities(Zone.BATTLEFIELD);
    for (    Ability basicAbility : manaAbilities) {
      ManaAbility ability=(ManaAbility)basicAbility;
      if (!ability.equals(source) && ability.definesMana(game)) {
        for (        Mana netMana : ability.getNetMana(game)) {
          types.add(netMana);
          if (netMana.getAny() > 0) {
            return types;
          }
        }
      }
    }
  }
  return types;
}",0.994269340974212
158037,"private Mana getManaTypes(Game game,Ability source){
  List<Permanent> lands=game.getBattlefield().getActivePermanents(filter,source.getControllerId(),game);
  Mana types=new Mana();
  for (  Permanent land : lands) {
    Abilities<Ability> manaAbilities=land.getAbilities().getManaAbilities(Zone.BATTLEFIELD);
    for (    Ability basicAbility : manaAbilities) {
      ManaAbility ability=(ManaAbility)basicAbility;
      if (!ability.equals(source) && ability.definesMana()) {
        for (        Mana netMana : ability.getNetMana(game)) {
          types.add(netMana);
          if (netMana.getAny() > 0) {
            return types;
          }
        }
      }
    }
  }
  return types;
}","private Mana getManaTypes(Game game,Ability source){
  List<Permanent> lands=game.getBattlefield().getActivePermanents(filter,source.getControllerId(),game);
  Mana types=new Mana();
  for (  Permanent land : lands) {
    Abilities<Ability> manaAbilities=land.getAbilities().getManaAbilities(Zone.BATTLEFIELD);
    for (    Ability basicAbility : manaAbilities) {
      ManaAbility ability=(ManaAbility)basicAbility;
      if (!ability.equals(source) && ability.definesMana(game)) {
        for (        Mana netMana : ability.getNetMana(game)) {
          types.add(netMana);
          if (netMana.getAny() > 0) {
            return types;
          }
        }
      }
    }
  }
  return types;
}",0.9971264367816092
158038,"private Mana getManaTypes(Game game,Ability source){
  Mana types=new Mana();
  for (  Cost cost : source.getCosts()) {
    if (cost instanceof SacrificeTargetCost && !((SacrificeTargetCost)cost).getPermanents().isEmpty()) {
      Permanent land=((SacrificeTargetCost)cost).getPermanents().get(0);
      if (land != null) {
        Abilities<ActivatedManaAbilityImpl> manaAbilities=land.getAbilities().getActivatedManaAbilities(Zone.BATTLEFIELD);
        for (        ActivatedManaAbilityImpl ability : manaAbilities) {
          if (!ability.equals(source) && ability.definesMana()) {
            for (            Mana netMana : ability.getNetMana(game)) {
              types.add(netMana);
            }
          }
        }
      }
    }
  }
  return types;
}","private Mana getManaTypes(Game game,Ability source){
  Mana types=new Mana();
  for (  Cost cost : source.getCosts()) {
    if (cost instanceof SacrificeTargetCost && !((SacrificeTargetCost)cost).getPermanents().isEmpty()) {
      Permanent land=((SacrificeTargetCost)cost).getPermanents().get(0);
      if (land != null) {
        Abilities<ActivatedManaAbilityImpl> manaAbilities=land.getAbilities().getActivatedManaAbilities(Zone.BATTLEFIELD);
        for (        ActivatedManaAbilityImpl ability : manaAbilities) {
          if (!ability.equals(source) && ability.definesMana(game)) {
            for (            Mana netMana : ability.getNetMana(game)) {
              types.add(netMana);
            }
          }
        }
      }
    }
  }
  return types;
}",0.9973856209150328
158039,"private Mana getManaTypes(Game game,Ability source){
  List<Permanent> lands=game.getBattlefield().getActivePermanents(filter,source.getControllerId(),game);
  Mana types=new Mana();
  for (  Permanent land : lands) {
    Abilities<ActivatedManaAbilityImpl> manaAbilities=land.getAbilities().getActivatedManaAbilities(Zone.BATTLEFIELD);
    for (    ActivatedManaAbilityImpl ability : manaAbilities) {
      if (!ability.equals(source) && ability.definesMana()) {
        for (        Mana netMana : ability.getNetMana(game)) {
          types.add(netMana);
        }
      }
    }
  }
  return types;
}","private Mana getManaTypes(Game game,Ability source){
  List<Permanent> lands=game.getBattlefield().getActivePermanents(filter,source.getControllerId(),game);
  Mana types=new Mana();
  for (  Permanent land : lands) {
    Abilities<ActivatedManaAbilityImpl> manaAbilities=land.getAbilities().getActivatedManaAbilities(Zone.BATTLEFIELD);
    for (    ActivatedManaAbilityImpl ability : manaAbilities) {
      if (!ability.equals(source) && ability.definesMana(game)) {
        for (        Mana netMana : ability.getNetMana(game)) {
          types.add(netMana);
        }
      }
    }
  }
  return types;
}",0.996694214876033
158040,"@Test public void nagaVitalist_InteractionGiftOfParadise(){
  String giftParadise=""String_Node_Str"";
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"",3);
  addCard(Zone.BATTLEFIELD,playerA,nagaVitalist);
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"");
  addCard(Zone.HAND,playerA,giftParadise);
  castSpell(1,PhaseStep.PRECOMBAT_MAIN,playerA,giftParadise,""String_Node_Str"");
  activateManaAbility(3,PhaseStep.PRECOMBAT_MAIN,playerA,""String_Node_Str"");
  setChoice(playerA,""String_Node_Str"");
  setStopAt(3,PhaseStep.PRECOMBAT_MAIN);
  execute();
  assertLife(playerA,23);
  assertTapped(nagaVitalist,true);
  Assert.assertEquals(""String_Node_Str"",1,playerA.getManaPool().get(ManaType.GREEN));
}","@Test public void nagaVitalist_InteractionGiftOfParadise(){
  String giftParadise=""String_Node_Str"";
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"",3);
  addCard(Zone.BATTLEFIELD,playerA,nagaVitalist);
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"");
  addCard(Zone.HAND,playerA,giftParadise);
  castSpell(1,PhaseStep.PRECOMBAT_MAIN,playerA,giftParadise,""String_Node_Str"");
  activateManaAbility(3,PhaseStep.PRECOMBAT_MAIN,playerA,""String_Node_Str"");
  setChoice(playerA,""String_Node_Str"");
  setStopAt(3,PhaseStep.PRECOMBAT_MAIN);
  execute();
  assertLife(playerA,23);
  assertTapped(nagaVitalist,true);
  Assert.assertEquals(""String_Node_Str"",1,playerA.getManaPool().get(ManaType.RED));
}",0.9971590909090908
158041,"/** 
 * Used to check if the ability itself defines mana types it can produce.
 * @return
 */
@Override public boolean definesMana(){
  return !netMana.isEmpty();
}","/** 
 * Used to check if the ability itself defines mana types it can produce.
 * @return
 */
@Override public boolean definesMana(Game game){
  return !getNetMana(game).isEmpty();
}",0.9421965317919077
158042,"/** 
 * Is it allowed to undo the mana creation. It's e.g. not allowed if some game revealing information is related (like reveal the top card of the library)
 * @return 
 */
public boolean isUndoPossible(){
  return undoPossible;
}","/** 
 * Is it allowed to undo the mana creation. It's e.g. not allowed if some game revealing information is related (like reveal the top card of the library)
 * @return
 */
public boolean isUndoPossible(){
  return undoPossible;
}",0.9978401727861772
158043,"@Override public boolean definesMana(){
  return true;
}","@Override public boolean definesMana(Game game){
  return true;
}",0.9256198347107438
158044,"private Mana getManaTypes(Game game,Ability source){
  Logger.getLogger(this.getClass().getName()).log(Level.WARNING,""String_Node_Str"",source.getSourceObject(game).getName());
  List<Permanent> lands=game.getBattlefield().getActivePermanents(filter,source.getControllerId(),source.getSourceId(),game);
  Mana types=new Mana();
  for (  Permanent land : lands) {
    Abilities<ActivatedManaAbilityImpl> mana=land.getAbilities().getActivatedManaAbilities(Zone.BATTLEFIELD);
    for (    ActivatedManaAbilityImpl ability : mana) {
      if (!ability.equals(source) && ability.definesMana()) {
        for (        Mana netMana : ability.getNetMana(game)) {
          types.add(netMana);
        }
      }
    }
  }
  return types;
}","private Mana getManaTypes(Game game,Ability source){
  Logger.getLogger(this.getClass().getName()).log(Level.WARNING,""String_Node_Str"",source.getSourceObject(game).getName());
  List<Permanent> lands=game.getBattlefield().getActivePermanents(filter,source.getControllerId(),source.getSourceId(),game);
  Mana types=new Mana();
  for (  Permanent land : lands) {
    Abilities<ActivatedManaAbilityImpl> mana=land.getAbilities().getActivatedManaAbilities(Zone.BATTLEFIELD);
    for (    ActivatedManaAbilityImpl ability : mana) {
      if (!ability.equals(source) && ability.definesMana(game)) {
        for (        Mana netMana : ability.getNetMana(game)) {
          types.add(netMana);
        }
      }
    }
  }
  return types;
}",0.9972640218878248
158045,"@Override public boolean definesMana(){
  return true;
}","@Override public boolean definesMana(Game game){
  return true;
}",0.9256198347107438
158046,"@Override public boolean definesMana(){
  return true;
}","@Override public boolean definesMana(Game game){
  return true;
}",0.9256198347107438
158047,"@Override public boolean definesMana(){
  return true;
}","@Override public boolean definesMana(Game game){
  return true;
}",0.9256198347107438
158048,"/** 
 * Used to check if the ability itself defines mana types it can produce.
 * @return
 */
boolean definesMana();","/** 
 * Used to check if the ability itself defines mana types it can produce.
 * @param game
 * @return
 */
boolean definesMana(Game game);",0.90625
158049,"/** 
 * Used to check if the ability itself defines mana types it can produce.
 * @return
 */
@Override public boolean definesMana(){
  return !netMana.isEmpty();
}","/** 
 * Used to check if the ability itself defines mana types it can produce.
 * @return
 */
@Override public boolean definesMana(Game game){
  return !netMana.isEmpty();
}",0.973293768545994
158050,"@Override public boolean applies(GameEvent event,Ability source,Game game){
  MageObject object=game.getObject(event.getSourceId());
  Optional<Ability> ability=game.getAbility(event.getTargetId(),event.getSourceId());
  if (ability.isPresent() && object != null) {
    if (ability.get().getAbilityType() != AbilityType.MANA && object.getName().equals(game.getState().getValue(source.getSourceId().toString() + NameACardEffect.INFO_KEY))) {
      return true;
    }
  }
  return false;
}","@Override public boolean applies(GameEvent event,Ability source,Game game){
  MageObject object=game.getObject(event.getSourceId());
  Optional<Ability> ability=game.getAbility(event.getTargetId(),event.getSourceId());
  if (ability.isPresent() && object != null) {
    if (game.getState().getPlayersInRange(source.getControllerId(),game).contains(event.getPlayerId()) && ability.get().getAbilityType() != AbilityType.MANA && object.getName().equals(game.getState().getValue(source.getSourceId().toString() + NameACardEffect.INFO_KEY))) {
      return true;
    }
  }
  return false;
}",0.9085820895522388
158051,"@Override public boolean apply(Game game,Ability source){
  Player player=game.getPlayer(source.getControllerId());
  if (player != null) {
    for (    UUID attachmentId : player.getAttachments()) {
      Permanent attachment=game.getPermanent(attachmentId);
      if (attachment != null && attachment.getSubtype(game).contains(""String_Node_Str"")) {
        attachment.destroy(source.getSourceId(),game,false);
      }
    }
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller != null) {
    ArrayList<Permanent> toDestroy=new ArrayList<>();
    for (    UUID attachmentId : controller.getAttachments()) {
      Permanent attachment=game.getPermanent(attachmentId);
      if (attachment != null && attachment.getSubtype(game).contains(""String_Node_Str"")) {
        toDestroy.add(attachment);
      }
    }
    for (    Permanent curse : toDestroy) {
      curse.destroy(source.getSourceId(),game,false);
    }
    return true;
  }
  return false;
}",0.7798507462686567
158052,"@Override public MagmaSpray copy(){
  return new MagmaSpray(this);
}","@Override public MagmaSprayEffect copy(){
  return new MagmaSprayEffect(this);
}",0.918918918918919
158053,"public EnterBattlefieldPayCostOrPutGraveyardEffect(final EnterBattlefieldPayCostOrPutGraveyardEffect effect){
  super(effect);
  this.cost=effect.cost;
}","public EnterBattlefieldPayCostOrPutGraveyardEffect(final EnterBattlefieldPayCostOrPutGraveyardEffect effect){
  super(effect);
  this.cost=effect.cost.copy();
}",0.977635782747604
158054,"@Override public boolean replaceEvent(GameEvent event,Ability source,Game game){
  Player player=game.getPlayer(source.getControllerId());
  MageObject sourceObject=game.getObject(source.getSourceId());
  if (player != null && cost != null && sourceObject != null) {
    boolean replace=true;
    if (cost.canPay(source,source.getSourceId(),player.getId(),game)) {
      if (player.chooseUse(outcome,cost.getText() + ""String_Node_Str"" + sourceObject.getLogName()+ ""String_Node_Str"",source,game)) {
        cost.clearPaid();
        replace=!cost.pay(source,game,source.getSourceId(),source.getControllerId(),false,null);
      }
    }
    if (replace) {
      Card card=game.getCard(event.getTargetId());
      if (card != null) {
        player.moveCards(card,Zone.GRAVEYARD,source,game);
      }
      return true;
    }
  }
  return false;
}","@Override public boolean replaceEvent(GameEvent event,Ability source,Game game){
  Player player=game.getPlayer(source.getControllerId());
  MageObject sourceObject=game.getObject(source.getSourceId());
  if (player != null && cost != null && sourceObject != null) {
    boolean replace=true;
    if (cost.canPay(source,source.getSourceId(),player.getId(),game)) {
      if (player.chooseUse(outcome,cost.getText().substring(0,1).toUpperCase() + cost.getText().substring(1) + ""String_Node_Str""+ sourceObject.getLogName()+ ""String_Node_Str"",source,game)) {
        cost.clearPaid();
        replace=!cost.pay(source,game,source.getSourceId(),source.getControllerId(),false,null);
      }
    }
    if (replace) {
      Card card=game.getCard(event.getTargetId());
      if (card != null) {
        player.moveCards(card,Zone.GRAVEYARD,source,game);
      }
      return true;
    }
  }
  return false;
}",0.9656357388316152
158055,"@Override public void mouseWheelMoved(MouseWheelEvent e,TransferData transferData){
  int notches=e.getWheelRotation();
  if (enlargedWindowState != EnlargedWindowState.CLOSED) {
    if (new Date().getTime() - enlargeredViewOpened.getTime() > 1000) {
      hideEnlargedCard();
      handleOverNewView(transferData);
    }
 else     if (enlargeMode == EnlargeMode.NORMAL) {
      if (notches > 0) {
        hideEnlargedCard();
        handleOverNewView(transferData);
      }
    }
 else     if (notches < 0) {
      hideEnlargedCard();
      handleOverNewView(transferData);
    }
    return;
  }
  if (notches < 0) {
    enlargeCard(EnlargeMode.NORMAL);
  }
 else {
    enlargeCard(EnlargeMode.ALTERNATE);
  }
}","@Override public void mouseWheelMoved(MouseWheelEvent e,TransferData transferData){
  int notches=e.getWheelRotation();
  if (enlargedWindowState != EnlargedWindowState.CLOSED) {
    if (enlargeredViewOpened != null && new Date().getTime() - enlargeredViewOpened.getTime() > 1000) {
      hideEnlargedCard();
      handleOverNewView(transferData);
    }
 else     if (enlargeMode == EnlargeMode.NORMAL) {
      if (notches > 0) {
        hideEnlargedCard();
        handleOverNewView(transferData);
      }
    }
 else     if (notches < 0) {
      hideEnlargedCard();
      handleOverNewView(transferData);
    }
    return;
  }
  if (notches < 0) {
    enlargeCard(EnlargeMode.NORMAL);
  }
 else {
    enlargeCard(EnlargeMode.ALTERNATE);
  }
}",0.978021978021978
158056,"/** 
 * Test to remove a Aftermath card from spell
 */
@Test public void testSpellAftermath(){
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"",2);
  addCard(Zone.GRAVEYARD,playerA,""String_Node_Str"");
  addCard(Zone.BATTLEFIELD,playerB,""String_Node_Str"",3);
  addCard(Zone.HAND,playerB,""String_Node_Str"");
  castSpell(1,PhaseStep.PRECOMBAT_MAIN,playerA,""String_Node_Str"",""String_Node_Str"");
  addTarget(playerA,playerB);
  castSpell(1,PhaseStep.PRECOMBAT_MAIN,playerA,""String_Node_Str"",NO_TARGET,""String_Node_Str"");
  setStopAt(1,PhaseStep.BEGIN_COMBAT);
  execute();
  assertExileCount(playerA,""String_Node_Str"",1);
  assertGraveyardCount(playerB,""String_Node_Str"",0);
  assertHandCount(playerA,0);
  assertHandCount(playerB,0);
}","/** 
 * Test to remove a Aftermath card from spell
 */
@Test public void testSpellAftermath(){
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"",3);
  addCard(Zone.GRAVEYARD,playerA,""String_Node_Str"");
  addCard(Zone.BATTLEFIELD,playerB,""String_Node_Str"",1);
  addCard(Zone.BATTLEFIELD,playerB,""String_Node_Str"",3);
  addCard(Zone.HAND,playerB,""String_Node_Str"");
  castSpell(1,PhaseStep.PRECOMBAT_MAIN,playerA,""String_Node_Str"",""String_Node_Str"");
  addTarget(playerA,playerB);
  castSpell(1,PhaseStep.PRECOMBAT_MAIN,playerB,""String_Node_Str"",NO_TARGET,""String_Node_Str"");
  setStopAt(1,PhaseStep.BEGIN_COMBAT);
  execute();
  assertExileCount(playerB,""String_Node_Str"",1);
  assertGraveyardCount(playerA,""String_Node_Str"",0);
  assertExileCount(playerA,""String_Node_Str"",1);
  assertGraveyardCount(playerB,""String_Node_Str"",0);
  assertHandCount(playerA,0);
  assertHandCount(playerB,1);
}",0.896255371393493
158057,"/** 
 * Used for some spells with end turn effect (e.g. Time Stop).
 * @param game
 * @param activePlayerId
 * @param source
 */
public void endTurn(Game game,UUID activePlayerId,Ability source){
  setEndTurnRequested(true);
  while (!game.getStack().isEmpty()) {
    StackObject stackObject=game.getStack().peekFirst();
    if (stackObject instanceof Spell) {
      ((Spell)stackObject).moveToExile(null,""String_Node_Str"",source.getSourceId(),game);
    }
  }
  for (  UUID attackerId : game.getCombat().getAttackers()) {
    Permanent permanent=game.getPermanent(attackerId);
    if (permanent != null) {
      permanent.removeFromCombat(game);
    }
    game.getCombat().removeAttacker(attackerId,game);
  }
  for (  UUID blockerId : game.getCombat().getBlockers()) {
    Permanent permanent=game.getPermanent(blockerId);
    if (permanent != null) {
      permanent.removeFromCombat(game);
    }
  }
  game.getState().clearTriggeredAbilities();
  game.checkStateAndTriggered();
}","/** 
 * Used for some spells with end turn effect (e.g. Time Stop).
 * @param game
 * @param activePlayerId
 * @param source
 */
public void endTurn(Game game,UUID activePlayerId,Ability source){
  setEndTurnRequested(true);
  while (!game.hasEnded() && !game.getStack().isEmpty()) {
    StackObject stackObject=game.getStack().peekFirst();
    if (stackObject instanceof Spell) {
      ((Spell)stackObject).moveToExile(null,""String_Node_Str"",source.getSourceId(),game);
    }
 else {
      game.getStack().remove(stackObject);
    }
  }
  for (  UUID attackerId : game.getCombat().getAttackers()) {
    Permanent permanent=game.getPermanent(attackerId);
    if (permanent != null) {
      permanent.removeFromCombat(game);
    }
    game.getCombat().removeAttacker(attackerId,game);
  }
  for (  UUID blockerId : game.getCombat().getBlockers()) {
    Permanent permanent=game.getPermanent(blockerId);
    if (permanent != null) {
      permanent.removeFromCombat(game);
    }
  }
  game.getState().clearTriggeredAbilities();
  game.checkStateAndTriggered();
}",0.9623103279490944
158058,"@Override public boolean sacrifice(UUID sourceId,Game game){
  if (isPhasedIn() && !game.replaceEvent(GameEvent.getEvent(EventType.SACRIFICE_PERMANENT,objectId,sourceId,controllerId))) {
    moveToZone(Zone.GRAVEYARD,sourceId,game,false);
    Player player=game.getPlayer(getControllerId());
    if (player != null && !game.isSimulation()) {
      game.informPlayers(player.getLogName() + ""String_Node_Str"" + this.getLogName());
    }
    game.fireEvent(GameEvent.getEvent(EventType.SACRIFICED_PERMANENT,objectId,sourceId,controllerId));
    game.checkStateAndTriggered();
    return true;
  }
  return false;
}","@Override public boolean sacrifice(UUID sourceId,Game game){
  if (isPhasedIn() && !game.replaceEvent(GameEvent.getEvent(EventType.SACRIFICE_PERMANENT,objectId,sourceId,controllerId))) {
    moveToZone(Zone.GRAVEYARD,sourceId,game,false);
    Player player=game.getPlayer(getControllerId());
    if (player != null && !game.isSimulation()) {
      game.informPlayers(player.getLogName() + ""String_Node_Str"" + this.getLogName());
    }
    game.fireEvent(GameEvent.getEvent(EventType.SACRIFICED_PERMANENT,objectId,sourceId,controllerId));
    game.checkStateAndTriggered();
    game.applyEffects();
    return true;
  }
  return false;
}",0.9799518845228548
158059,"@Override public boolean apply(Game game,Ability source){
  Permanent targetCreature=game.getPermanent(getTargetPointer().getFirst(game,source));
  if (targetCreature != null) {
    Effect effect=new RemoveCounterTargetEffect(CounterType.M1M1.createInstance(1));
    effect.setTargetPointer(targetPointer);
    effect.apply(game,source);
  }
  targetCreature=game.getPermanent(source.getTargets().get(1).getFirstTarget());
  if (targetCreature != null) {
    Effect effect=new AddCountersTargetEffect(CounterType.M1M1.createInstance(1));
    effect.setTargetPointer(new FixedTarget(source.getTargets().get(1).getFirstTarget()));
    effect.apply(game,source);
  }
  return true;
}","@Override public boolean apply(Game game,Ability source){
  Permanent targetCreature=game.getPermanent(getTargetPointer().getFirst(game,source));
  if (targetCreature != null && targetCreature.getCounters(game).containsKey(CounterType.M1M1)) {
    Effect effect=new RemoveCounterTargetEffect(CounterType.M1M1.createInstance(1));
    effect.setTargetPointer(targetPointer);
    effect.apply(game,source);
  }
  targetCreature=game.getPermanent(source.getTargets().get(1).getFirstTarget());
  if (targetCreature != null) {
    Effect effect=new AddCountersTargetEffect(CounterType.M1M1.createInstance(1));
    effect.setTargetPointer(new FixedTarget(source.getTargets().get(1).getFirstTarget()));
    effect.apply(game,source);
  }
  return true;
}",0.9537166900420756
158060,"@Override public void adjustTargets(Ability ability,Game game){
  if (ability.getOriginalId().equals(originalId)) {
    ability.getTargets().clear();
    ability.addTarget(new TargetControlledCreaturePermanent());
    FilterCreaturePermanent filter=new FilterCreaturePermanent(""String_Node_Str"");
    UUID defenderId=game.getCombat().getDefenderId(ability.getSourceId());
    filter.add(new ControllerIdPredicate(defenderId));
    TargetCreaturePermanent target=new TargetCreaturePermanent(filter);
    ability.addTarget(target);
  }
}","@Override public void adjustTargets(Ability ability,Game game){
  if (ability.getOriginalId().equals(originalId)) {
    ability.getTargets().clear();
    ability.addTarget(new TargetControlledCreaturePermanent());
    FilterCreaturePermanent filter=new FilterCreaturePermanent(""String_Node_Str"");
    UUID defenderId=game.getCombat().getDefenderId(ability.getSourceId());
    filter.add(new ControllerIdPredicate(defenderId));
    TargetCreaturePermanent target=new TargetCreaturePermanent(0,1,filter,false);
    ability.addTarget(target);
  }
}",0.9796296296296296
158061,"public GlyphKeeperAbility(final GlyphKeeperAbility ability){
  super(ability);
  turnUsed=ability.turnUsed;
}","public GlyphKeeperAbility(final GlyphKeeperAbility ability){
  super(ability);
}",0.8465608465608465
158062,"@Override public boolean checkTrigger(GameEvent event,Game game){
  if (event.getTargetId().equals(this.getSourceId()) && game.getTurnNum() > turnUsed) {
    this.getTargets().clear();
    TargetStackObject target=new TargetStackObject();
    target.add(event.getSourceId(),game);
    this.addTarget(target);
    turnUsed=game.getTurnNum();
    return true;
  }
  return false;
}","@Override public boolean checkTrigger(GameEvent event,Game game){
  if (event.getTargetId().equals(this.getSourceId())) {
    Permanent permanent=game.getPermanent(event.getTargetId());
    if (permanent != null && permanent.isCreature()) {
      NumberOfTimesPermanentTargetedATurnWatcher watcher=(NumberOfTimesPermanentTargetedATurnWatcher)game.getState().getWatchers().get(NumberOfTimesPermanentTargetedATurnWatcher.class.getName());
      if (watcher != null && watcher.notMoreThanOnceTargetedThisTurn(permanent,game)) {
        for (        Effect effect : getEffects()) {
          effect.setTargetPointer(new FixedTarget(event.getSourceId()));
        }
        return true;
      }
    }
  }
  return false;
}",0.3156934306569343
158063,"@Override public boolean checkTrigger(GameEvent event,Game game){
  if (event.getTargetId().equals(this.getSourceId())) {
    Permanent permanent=game.getPermanent(event.getTargetId());
    if (permanent != null && permanent.isCreature()) {
      KiraGreatGlassSpinnerWatcher watcher=(KiraGreatGlassSpinnerWatcher)game.getState().getWatchers().get(KiraGreatGlassSpinnerWatcher.class.getName());
      if (watcher != null && watcher.notMoreThanOnceTargetedThisTurn(permanent,game)) {
        for (        Effect effect : getEffects()) {
          effect.setTargetPointer(new FixedTarget(event.getSourceId()));
        }
        return true;
      }
    }
  }
  return false;
}","@Override public boolean checkTrigger(GameEvent event,Game game){
  if (event.getTargetId().equals(this.getSourceId())) {
    Permanent permanent=game.getPermanent(event.getTargetId());
    if (permanent != null && permanent.isCreature()) {
      NumberOfTimesPermanentTargetedATurnWatcher watcher=(NumberOfTimesPermanentTargetedATurnWatcher)game.getState().getWatchers().get(NumberOfTimesPermanentTargetedATurnWatcher.class.getName());
      if (watcher != null && watcher.notMoreThanOnceTargetedThisTurn(permanent,game)) {
        for (        Effect effect : getEffects()) {
          effect.setTargetPointer(new FixedTarget(event.getSourceId()));
        }
        return true;
      }
    }
  }
  return false;
}",0.8060344827586207
158064,"@Override public KiraGreatGlassSpinnerWatcher copy(){
  return new KiraGreatGlassSpinnerWatcher(this);
}","@Override public KiraGreatGlassSpinnerAbility copy(){
  return new KiraGreatGlassSpinnerAbility(this);
}",0.8846153846153846
158065,"@Override public boolean apply(Game game,Ability source){
  Player cursedPlayer=game.getPlayer(targetPointer.getFirst(game,source));
  Player controller=game.getPlayer(source.getControllerId());
  if (cursedPlayer != null && controller != null) {
    if (cursedPlayer.chooseUse(outcome,""String_Node_Str"",source,game)) {
      FilterControlledPermanent filter=new FilterControlledPermanent();
      filter.add(Predicates.or(new CardTypePredicate(CardType.CREATURE),new CardTypePredicate(CardType.PLANESWALKER)));
      TargetPermanent target=new TargetPermanent(filter);
      if (cursedPlayer.choose(outcome,target,source.getId(),game)) {
        Permanent objectToBeSacrificed=game.getPermanent(target.getFirstTarget());
        if (objectToBeSacrificed != null) {
          if (objectToBeSacrificed.sacrifice(source.getId(),game)) {
            return true;
          }
        }
      }
    }
    cursedPlayer.loseLife(5,game,false);
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Player cursedPlayer=game.getPlayer(targetPointer.getFirst(game,source));
  Player controller=game.getPlayer(source.getControllerId());
  if (cursedPlayer != null && controller != null) {
    FilterControlledPermanent filter=new FilterControlledPermanent(""String_Node_Str"");
    filter.add(Predicates.or(new CardTypePredicate(CardType.CREATURE),new CardTypePredicate(CardType.PLANESWALKER)));
    TargetPermanent target=new TargetPermanent(filter);
    if (cursedPlayer.choose(Outcome.Sacrifice,target,source.getId(),game)) {
      Permanent objectToBeSacrificed=game.getPermanent(target.getFirstTarget());
      if (objectToBeSacrificed != null) {
        if (objectToBeSacrificed.sacrifice(source.getId(),game)) {
          return true;
        }
      }
    }
    cursedPlayer.loseLife(5,game,false);
  }
  return false;
}",0.8740499457111836
158066,"@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  Spell spell=game.getStack().getSpell(source.getSourceId());
  if (controller != null && spell != null) {
    ApproachOfTheSecondSunWatcher watcher=(ApproachOfTheSecondSunWatcher)game.getState().getWatchers().get(ApproachOfTheSecondSunWatcher.class.getName());
    if (watcher != null && watcher.getApproachesCast(controller.getId()) > 1 && spell.getFromZone() == Zone.HAND) {
      controller.won(game);
    }
 else {
      controller.gainLife(7,game);
      Card spellCard=game.getStack().getSpell(source.getSourceId()).getCard();
      if (spellCard != null) {
        List<Card> top6=new ArrayList<>();
        for (int i=0; i < 6 && controller.getLibrary().hasCards(); ++i) {
          top6.add(controller.getLibrary().removeFromTop(game));
        }
        boolean isOnBottom=!controller.getLibrary().hasCards();
        spellCard.moveToZone(Zone.LIBRARY,source.getSourceId(),game,true);
        for (int i=top6.size() - 1; i >= 0; --i) {
          controller.getLibrary().putOnTop(top6.get(i),game);
        }
        if (isOnBottom) {
          game.informPlayers(controller.getLogName() + ""String_Node_Str"" + spell.getLogName()+ ""String_Node_Str"");
        }
 else {
          game.informPlayers(controller.getLogName() + ""String_Node_Str"" + spell.getLogName()+ ""String_Node_Str"");
        }
      }
    }
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  Spell spell=game.getStack().getSpell(source.getSourceId());
  if (controller != null && spell != null) {
    ApproachOfTheSecondSunWatcher watcher=(ApproachOfTheSecondSunWatcher)game.getState().getWatchers().get(ApproachOfTheSecondSunWatcher.class.getName());
    if (watcher != null && watcher.getApproachesCast(controller.getId()) > 1 && spell.getFromZone() == Zone.HAND) {
      controller.won(game);
    }
 else {
      controller.gainLife(7,game);
      Card spellCard=game.getStack().getSpell(source.getSourceId()).getCard();
      if (spellCard != null) {
        List<Card> top6=new ArrayList<>();
        for (int i=0; i < 6 && controller.getLibrary().hasCards(); ++i) {
          top6.add(controller.getLibrary().removeFromTop(game));
        }
        boolean isOnBottom=controller.getLibrary().size() < 6;
        spellCard.moveToZone(Zone.LIBRARY,source.getSourceId(),game,true);
        for (int i=top6.size() - 1; i >= 0; --i) {
          controller.getLibrary().putOnTop(top6.get(i),game);
        }
        if (isOnBottom) {
          game.informPlayers(controller.getLogName() + ""String_Node_Str"" + spell.getLogName()+ ""String_Node_Str"");
        }
 else {
          game.informPlayers(controller.getLogName() + ""String_Node_Str"" + spell.getLogName()+ ""String_Node_Str"");
        }
      }
    }
    return true;
  }
  return false;
}",0.992878942014242
158067,"/** 
 * Returns a predicate that evaluates to   {@code true} if either of its components evaluates to {@code true}. The components are evaluated in order, and evaluation will be ""short-circuited"" as soon as a true predicate is found.
 * @param < T >
 * @param first
 * @param second
 * @return 
 */
public static <T>Predicate<T> or(Predicate<? super T> first,Predicate<? super T> second){
  return new OrPredicate<>(Predicates.<T>asList(first,second));
}","/** 
 * Returns a predicate that evaluates to   {@code true} if either of its components evaluates to {@code true}. The components are evaluated in order, and evaluation will be ""short-circuited"" as soon as a true predicate is found.
 * @param < T >
 * @param first
 * @param second
 * @return 
 */
public static <T>Predicate<T> or(Predicate<? super T> first,Predicate<? super T> second){
  return new OrPredicate<T>(Predicates.<T>asList(first,second));
}",0.9988998899889988
158068,"static <T>List<T> defensiveCopy(Iterable<T> iterable){
  ArrayList<T> list=new ArrayList<>();
  for (  T element : iterable) {
    list.add(checkNotNull(element));
  }
  return list;
}","static <T>List<T> defensiveCopy(Iterable<T> iterable){
  ArrayList<T> list=new ArrayList<T>();
  for (  T element : iterable) {
    list.add(checkNotNull(element));
  }
  return list;
}",0.997289972899729
158069,"/** 
 * Returns a predicate that evaluates to   {@code true} if the given predicate evaluates to {@code false}.
 * @param < T >
 * @param predicate
 * @return 
 */
public static <T>Predicate<T> not(Predicate<T> predicate){
  return new NotPredicate<>(predicate);
}","/** 
 * Returns a predicate that evaluates to   {@code true} if the given predicate evaluates to {@code false}.
 * @param < T >
 * @param predicate
 * @return 
 */
public static <T>Predicate<T> not(Predicate<T> predicate){
  return new NotPredicate<T>(predicate);
}",0.998109640831758
158070,"/** 
 * Returns a predicate that evaluates to   {@code true} if both of its components evaluate to {@code true}. The components are evaluated in order, and evaluation will be ""short-circuited"" as soon as a false predicate is found.
 * @param < T >
 * @param first
 * @param second
 * @return 
 */
public static <T>Predicate<T> and(Predicate<? super T> first,Predicate<? super T> second){
  return new AndPredicate<>(Predicates.<T>asList(checkNotNull(first),checkNotNull(second)));
}","/** 
 * Returns a predicate that evaluates to   {@code true} if both of its components evaluate to {@code true}. The components are evaluated in order, and evaluation will be ""short-circuited"" as soon as a false predicate is found.
 * @param < T >
 * @param first
 * @param second
 * @return 
 */
public static <T>Predicate<T> and(Predicate<? super T> first,Predicate<? super T> second){
  return new AndPredicate<T>(Predicates.<T>asList(checkNotNull(first),checkNotNull(second)));
}",0.998963730569948
158071,"@Override public boolean applies(GameEvent event,Ability source,Game game){
  boolean weControlSource=game.getControllerId(event.getSourceId()).equals(source.getControllerId());
  boolean isNoncombatDamage=!((DamageCreatureEvent)event).isCombatDamage();
  return weControlSource && isNoncombatDamage;
}","@Override public boolean applies(GameEvent event,Ability source,Game game){
  UUID sourceControllerId=game.getControllerId(event.getSourceId());
  UUID targetControllerId=game.getControllerId(event.getTargetId());
  UUID controllerId=source.getControllerId();
  boolean weControlSource=controllerId == sourceControllerId;
  boolean opponentControlsTarget=game.getOpponents(sourceControllerId).contains(targetControllerId);
  boolean isNoncombatDamage=!((DamageCreatureEvent)event).isCombatDamage();
  return weControlSource && isNoncombatDamage && opponentControlsTarget;
}",0.5234285714285715
158072,"@Override public boolean activate(Game game,boolean noMana){
  Player controller=game.getPlayer(this.getControllerId());
  if (controller == null) {
    return false;
  }
  game.applyEffects();
  if (!getModes().choose(game,this)) {
    return false;
  }
  getSourceObject(game);
  if (controller.isTestMode()) {
    if (!controller.addTargets(this,game)) {
      return false;
    }
  }
  if (this.abilityType == AbilityType.SPELL) {
    game.getContinuousEffects().applySpliceEffects(this,game);
  }
  if (noMana) {
    if (!this.getManaCostsToPay().getVariableCosts().isEmpty()) {
      int xValue=this.getManaCostsToPay().getX();
      this.getManaCostsToPay().clear();
      VariableManaCost xCosts=new VariableManaCost();
      xCosts.setAmount(xValue);
      this.getManaCostsToPay().add(xCosts);
    }
 else {
      this.getManaCostsToPay().clear();
    }
  }
  if (modes.getAdditionalCost() != null) {
    ((OptionalAdditionalModeSourceCosts)modes.getAdditionalCost()).addOptionalAdditionalModeCosts(this,game);
  }
  if (!activateAlternateOrAdditionalCosts(sourceObject,noMana,controller,game)) {
    if (getAbilityType() == AbilityType.SPELL && ((SpellAbility)this).getSpellAbilityType() == SpellAbilityType.FACE_DOWN_CREATURE) {
      return false;
    }
  }
  if (getAbilityType() == AbilityType.SPELL && getManaCostsToPay().isEmpty() && !noMana) {
    return false;
  }
  VariableManaCost variableManaCost=handleManaXCosts(game,noMana,controller);
  String announceString=handleOtherXCosts(game,controller);
  if (this.getAbilityType() == AbilityType.SPELL && game.replaceEvent(GameEvent.getEvent(GameEvent.EventType.CAST_SPELL_LATE,getId(),getSourceId(),getControllerId()),this)) {
    return false;
  }
  handlePhyrexianManaCosts(game,sourceId,controller);
  for (  UUID modeId : this.getModes().getSelectedModes()) {
    this.getModes().setActiveMode(modeId);
    if (sourceObject != null && this.getAbilityType() != AbilityType.TRIGGERED) {
      sourceObject.adjustTargets(this,game);
    }
    if (!(this instanceof FlashbackAbility) && !getTargets().isEmpty()) {
      Outcome outcome=getEffects().isEmpty() ? Outcome.Detriment : getEffects().get(0).getOutcome();
      if (getTargets().chooseTargets(outcome,this.controllerId,this,noMana,game) == false) {
        if ((variableManaCost != null || announceString != null) && !game.isSimulation()) {
          game.informPlayer(controller,(sourceObject != null ? sourceObject.getIdName() : ""String_Node_Str"") + ""String_Node_Str"");
        }
        return false;
      }
    }
  }
  for (  Cost cost : optionalCosts) {
    if (cost instanceof ManaCost) {
      cost.clearPaid();
      if (controller.chooseUse(Outcome.Benefit,""String_Node_Str"" + cost.getText() + '?',this,game)) {
        manaCostsToPay.add((ManaCost)cost);
      }
    }
  }
  if (sourceObject != null) {
    sourceObject.adjustCosts(this,game);
    if (sourceObject instanceof Card) {
      for (      Ability ability : ((Card)sourceObject).getAbilities(game)) {
        if (ability instanceof AdjustingSourceCosts) {
          ((AdjustingSourceCosts)ability).adjustCosts(this,game);
        }
      }
    }
 else {
      for (      Ability ability : sourceObject.getAbilities()) {
        if (ability instanceof AdjustingSourceCosts) {
          ((AdjustingSourceCosts)ability).adjustCosts(this,game);
        }
      }
    }
  }
  if (this instanceof ActivatedManaAbilityImpl && !costs.pay(this,game,sourceId,controllerId,noMana,null)) {
    logger.debug(""String_Node_Str"");
    return false;
  }
  if (costModificationActive) {
    game.getContinuousEffects().costModification(this,game);
  }
 else {
    costModificationActive=true;
  }
  UUID activatorId=controllerId;
  if ((this instanceof ActivatedAbilityImpl) && ((ActivatedAbilityImpl)this).getActivatorId() != null) {
    activatorId=((ActivatedAbilityImpl)this).getActivatorId();
  }
  if (!manaCostsToPay.pay(this,game,sourceId,activatorId,false,null)) {
    return false;
  }
  if (!costs.pay(this,game,sourceId,activatorId,noMana,null)) {
    logger.debug(""String_Node_Str"");
    return false;
  }
  if (!game.isSimulation()) {
    if (announceString != null) {
      game.informPlayers(announceString);
    }
    if (variableManaCost != null) {
      int xValue=getManaCostsToPay().getX();
      game.informPlayers(controller.getLogName() + ""String_Node_Str"" + xValue+ ""String_Node_Str""+ variableManaCost.getText());
    }
  }
  activated=true;
  if (this.getAbilityType() == AbilityType.MANA) {
    for (    Cost cost : costs) {
      if (cost instanceof TapSourceCost) {
        Mana mana=null;
        Effect effect=getEffects().get(0);
        if (effect instanceof DynamicManaEffect) {
          mana=((DynamicManaEffect)effect).getMana(game,this);
        }
 else         if (effect instanceof ManaEffect) {
          mana=((ManaEffect)effect).getMana(game,this);
        }
        if (mana != null && mana.getAny() == 0) {
          ManaEvent event=new ManaEvent(GameEvent.EventType.TAPPED_FOR_MANA,sourceId,sourceId,controllerId,mana);
          if (!game.replaceEvent(event)) {
            game.fireEvent(event);
          }
        }
        break;
      }
    }
  }
  return true;
}","@Override public boolean activate(Game game,boolean noMana){
  Player controller=game.getPlayer(this.getControllerId());
  if (controller == null) {
    return false;
  }
  game.applyEffects();
  if (!getModes().choose(game,this)) {
    return false;
  }
  getSourceObject(game);
  if (controller.isTestMode()) {
    if (!controller.addTargets(this,game)) {
      return false;
    }
  }
  if (this.abilityType == AbilityType.SPELL) {
    game.getContinuousEffects().applySpliceEffects(this,game);
  }
  if (noMana) {
    if (!this.getManaCostsToPay().getVariableCosts().isEmpty()) {
      int xValue=this.getManaCostsToPay().getX();
      this.getManaCostsToPay().clear();
      VariableManaCost xCosts=new VariableManaCost();
      xCosts.setAmount(xValue);
      this.getManaCostsToPay().add(xCosts);
    }
 else {
      this.getManaCostsToPay().clear();
    }
  }
  if (modes.getAdditionalCost() != null) {
    ((OptionalAdditionalModeSourceCosts)modes.getAdditionalCost()).addOptionalAdditionalModeCosts(this,game);
  }
  if (!activateAlternateOrAdditionalCosts(sourceObject,noMana,controller,game)) {
    if (getAbilityType() == AbilityType.SPELL && ((SpellAbility)this).getSpellAbilityType() == SpellAbilityType.FACE_DOWN_CREATURE) {
      return false;
    }
  }
  if (getAbilityType() == AbilityType.SPELL && (getManaCostsToPay().isEmpty() && getCosts().isEmpty()) && !noMana) {
    return false;
  }
  VariableManaCost variableManaCost=handleManaXCosts(game,noMana,controller);
  String announceString=handleOtherXCosts(game,controller);
  if (this.getAbilityType() == AbilityType.SPELL && game.replaceEvent(GameEvent.getEvent(GameEvent.EventType.CAST_SPELL_LATE,getId(),getSourceId(),getControllerId()),this)) {
    return false;
  }
  handlePhyrexianManaCosts(game,sourceId,controller);
  for (  UUID modeId : this.getModes().getSelectedModes()) {
    this.getModes().setActiveMode(modeId);
    if (sourceObject != null && this.getAbilityType() != AbilityType.TRIGGERED) {
      sourceObject.adjustTargets(this,game);
    }
    if (!(this instanceof FlashbackAbility) && !getTargets().isEmpty()) {
      Outcome outcome=getEffects().isEmpty() ? Outcome.Detriment : getEffects().get(0).getOutcome();
      if (getTargets().chooseTargets(outcome,this.controllerId,this,noMana,game) == false) {
        if ((variableManaCost != null || announceString != null) && !game.isSimulation()) {
          game.informPlayer(controller,(sourceObject != null ? sourceObject.getIdName() : ""String_Node_Str"") + ""String_Node_Str"");
        }
        return false;
      }
    }
  }
  for (  Cost cost : optionalCosts) {
    if (cost instanceof ManaCost) {
      cost.clearPaid();
      if (controller.chooseUse(Outcome.Benefit,""String_Node_Str"" + cost.getText() + '?',this,game)) {
        manaCostsToPay.add((ManaCost)cost);
      }
    }
  }
  if (sourceObject != null) {
    sourceObject.adjustCosts(this,game);
    if (sourceObject instanceof Card) {
      for (      Ability ability : ((Card)sourceObject).getAbilities(game)) {
        if (ability instanceof AdjustingSourceCosts) {
          ((AdjustingSourceCosts)ability).adjustCosts(this,game);
        }
      }
    }
 else {
      for (      Ability ability : sourceObject.getAbilities()) {
        if (ability instanceof AdjustingSourceCosts) {
          ((AdjustingSourceCosts)ability).adjustCosts(this,game);
        }
      }
    }
  }
  if (this instanceof ActivatedManaAbilityImpl && !costs.pay(this,game,sourceId,controllerId,noMana,null)) {
    logger.debug(""String_Node_Str"");
    return false;
  }
  if (costModificationActive) {
    game.getContinuousEffects().costModification(this,game);
  }
 else {
    costModificationActive=true;
  }
  UUID activatorId=controllerId;
  if ((this instanceof ActivatedAbilityImpl) && ((ActivatedAbilityImpl)this).getActivatorId() != null) {
    activatorId=((ActivatedAbilityImpl)this).getActivatorId();
  }
  if (!manaCostsToPay.pay(this,game,sourceId,activatorId,false,null)) {
    return false;
  }
  if (!costs.pay(this,game,sourceId,activatorId,noMana,null)) {
    logger.debug(""String_Node_Str"");
    return false;
  }
  if (!game.isSimulation()) {
    if (announceString != null) {
      game.informPlayers(announceString);
    }
    if (variableManaCost != null) {
      int xValue=getManaCostsToPay().getX();
      game.informPlayers(controller.getLogName() + ""String_Node_Str"" + xValue+ ""String_Node_Str""+ variableManaCost.getText());
    }
  }
  activated=true;
  if (this.getAbilityType() == AbilityType.MANA) {
    for (    Cost cost : costs) {
      if (cost instanceof TapSourceCost) {
        Mana mana=null;
        Effect effect=getEffects().get(0);
        if (effect instanceof DynamicManaEffect) {
          mana=((DynamicManaEffect)effect).getMana(game,this);
        }
 else         if (effect instanceof ManaEffect) {
          mana=((ManaEffect)effect).getMana(game,this);
        }
        if (mana != null && mana.getAny() == 0) {
          ManaEvent event=new ManaEvent(GameEvent.EventType.TAPPED_FOR_MANA,sourceId,sourceId,controllerId,mana);
          if (!game.replaceEvent(event)) {
            game.fireEvent(event);
          }
        }
        break;
      }
    }
  }
  return true;
}",0.9975052772980234
158073,"public void ask(final String question,final Map<String,Serializable> options){
  if (!killed) {
    UserManager.instance.getUser(userId).ifPresent(user -> user.fireCallback(new ClientCallback(ClientCallbackMethod.GAME_TARGET,game.getId(),new GameClientMessage(getGameView(),question,options))));
  }
}","public void ask(final String question,final Map<String,Serializable> options){
  if (!killed) {
    UserManager.instance.getUser(userId).ifPresent(user -> user.fireCallback(new ClientCallback(ClientCallbackMethod.GAME_ASK,game.getId(),new GameClientMessage(getGameView(),question,options))));
  }
}",0.8514190317195326
158074,"public final EnumSet<SuperType> getSupertypes(){
  EnumSet<SuperType> list=EnumSet.noneOf(SuperType.class);
  for (  String type : this.types.split(SEPARATOR)) {
    try {
      list.add(SuperType.valueOf(type));
    }
 catch (    IllegalArgumentException e) {
    }
  }
  return list;
}","public final EnumSet<SuperType> getSupertypes(){
  EnumSet<SuperType> list=EnumSet.noneOf(SuperType.class);
  for (  String type : this.supertypes.split(SEPARATOR)) {
    try {
      list.add(SuperType.valueOf(type));
    }
 catch (    IllegalArgumentException e) {
    }
  }
  return list;
}",0.9913644214162348
158075,"@Override public boolean checkTrigger(GameEvent event,Game game){
  if (event.getData().equals(CounterType.M1M1.getName())) {
    Permanent permanent=game.getPermanentOrLKIBattlefield(event.getTargetId());
    if (permanent == null) {
      permanent=game.getPermanentEntering(event.getTargetId());
    }
    return (permanent != null && permanent.isCreature());
  }
  return false;
}","@Override public boolean checkTrigger(GameEvent event,Game game){
  if (event.getData().equals(CounterType.M1M1.getName()) && controllerId.equals(game.getControllerId(event.getSourceId()))) {
    Permanent permanent=game.getPermanentOrLKIBattlefield(event.getTargetId());
    if (permanent == null) {
      permanent=game.getPermanentEntering(event.getTargetId());
    }
    return (permanent != null && permanent.isCreature());
  }
  return false;
}",0.920863309352518
158076,"@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  MageObject sourceObject=game.getLastKnownInformation(source.getSourceId(),Zone.BATTLEFIELD);
  if (controller != null) {
    for (    UUID opponentId : game.getState().getPlayersInRange(controller.getId(),game)) {
      Player opponent=game.getPlayer(opponentId);
      if (opponent != null && opponent != controller) {
        TargetCard target=new TargetCardInYourGraveyard(2,2,new FilterCard());
        target.setNotTarget(true);
        Cards cardsInGraveyard=opponent.getGraveyard();
        opponent.choose(outcome,cardsInGraveyard,target,game);
        if (!cardsInGraveyard.isEmpty()) {
          for (          Card cardInGraveyard : cardsInGraveyard.getCards(game)) {
            if (!target.getTargets().contains(cardInGraveyard.getId())) {
              opponent.moveCardToExileWithInfo(cardInGraveyard,CardUtil.getCardExileZoneId(game,source.getId()),sourceObject.getLogName(),source.getId(),game,Zone.GRAVEYARD,true);
            }
          }
        }
      }
    }
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  MageObject sourceObject=game.getLastKnownInformation(source.getSourceId(),Zone.BATTLEFIELD);
  if (controller != null) {
    for (    UUID opponentId : game.getState().getPlayersInRange(controller.getId(),game)) {
      Player opponent=game.getPlayer(opponentId);
      if (opponent != null && opponent != controller) {
        TargetCard target=new TargetCardInYourGraveyard(2,2,new FilterCard());
        target.setNotTarget(true);
        Cards cardsInGraveyard=opponent.getGraveyard();
        if (cardsInGraveyard.size() > 2) {
          opponent.choose(outcome,cardsInGraveyard,target,game);
          for (          Card cardInGraveyard : cardsInGraveyard.getCards(game)) {
            if (!target.getTargets().contains(cardInGraveyard.getId())) {
              opponent.moveCardToExileWithInfo(cardInGraveyard,CardUtil.getCardExileZoneId(game,source.getId()),sourceObject.getLogName(),source.getId(),game,Zone.GRAVEYARD,true);
            }
          }
        }
      }
    }
    return true;
  }
  return false;
}",0.9615384615384616
158077,"private void startMatch(TournamentPairing pair,MatchOptions matchOptions){
  try {
    TableManager tableManager=TableManager.instance;
    Table table=tableManager.createTable(GamesRoomManager.instance.getMainRoomId(),matchOptions);
    table.setTournamentSubTable(true);
    table.setTournament(tournament);
    table.setState(TableState.WAITING);
    TournamentPlayer player1=pair.getPlayer1();
    TournamentPlayer player2=pair.getPlayer2();
    Optional<UUID> user1Id=getPlayerUserId(player1.getPlayer().getId());
    Optional<UUID> user2Id=getPlayerUserId(player2.getPlayer().getId());
    if (user1Id.isPresent() && user2Id.isPresent()) {
      tableManager.addPlayer(getPlayerUserId(player1.getPlayer().getId()).get(),table.getId(),player1);
      tableManager.addPlayer(getPlayerUserId(player2.getPlayer().getId()).get(),table.getId(),player2);
      table.setState(TableState.STARTING);
      tableManager.startTournamentSubMatch(null,table.getId());
      tableManager.getMatch(table.getId()).ifPresent(match -> {
        match.setTableId(tableId);
        pair.setMatch(match);
        pair.setTableId(table.getId());
        player1.setState(TournamentPlayerState.DUELING);
        player2.setState(TournamentPlayerState.DUELING);
      }
);
    }
  }
 catch (  GameException ex) {
    logger.fatal(""String_Node_Str"",ex);
  }
}","private void startMatch(TournamentPairing pair,MatchOptions matchOptions){
  try {
    TableManager tableManager=TableManager.instance;
    Table table=tableManager.createTable(GamesRoomManager.instance.getMainRoomId(),matchOptions);
    table.setTournamentSubTable(true);
    table.setTournament(tournament);
    table.setState(TableState.WAITING);
    TournamentPlayer player1=pair.getPlayer1();
    TournamentPlayer player2=pair.getPlayer2();
    UUID user1Uuid=null;
    UUID user2Uuid=null;
    if (player1.getPlayerType() == PlayerType.HUMAN) {
      Optional<UUID> user1Id=getPlayerUserId(player1.getPlayer().getId());
      if (!user1Id.isPresent()) {
        logger.fatal(""String_Node_Str"");
      }
 else {
        user1Uuid=user1Id.get();
      }
    }
    if (player2.getPlayerType() == PlayerType.HUMAN) {
      Optional<UUID> user2Id=getPlayerUserId(player2.getPlayer().getId());
      if (!user2Id.isPresent()) {
        logger.fatal(""String_Node_Str"");
      }
 else {
        user2Uuid=user2Id.get();
      }
    }
    tableManager.addPlayer(user1Uuid,table.getId(),player1);
    tableManager.addPlayer(user2Uuid,table.getId(),player2);
    table.setState(TableState.STARTING);
    tableManager.startTournamentSubMatch(null,table.getId());
    tableManager.getMatch(table.getId()).ifPresent(match -> {
      match.setTableId(tableId);
      pair.setMatch(match);
      pair.setTableId(table.getId());
      player1.setState(TournamentPlayerState.DUELING);
      player2.setState(TournamentPlayerState.DUELING);
    }
);
  }
 catch (  GameException ex) {
    logger.fatal(""String_Node_Str"",ex);
  }
}",0.7185385656292287
158078,"private void btnOkActionPerformed(java.awt.event.ActionEvent evt){
  TournamentTypeView tournamentType=(TournamentTypeView)cbTournamentType.getSelectedItem();
  int numSeats=(Integer)this.spnNumSeats.getValue();
  TournamentOptions tOptions=new TournamentOptions(this.txtName.getText(),""String_Node_Str"",numSeats);
  tOptions.setTournamentType(tournamentType.getName());
  tOptions.setPassword(txtPassword.getText());
  tOptions.getPlayerTypes().add(PlayerType.HUMAN);
  tOptions.setWatchingAllowed(cbAllowSpectators.isSelected());
  tOptions.setQuitRatio((Integer)spnQuitRatio.getValue());
  for (  TournamentPlayerPanel player : players) {
    tOptions.getPlayerTypes().add((PlayerType)player.getPlayerType().getSelectedItem());
  }
  if (!tournamentType.isElimination()) {
    tOptions.setNumberRounds((Integer)spnNumRounds.getValue());
  }
  if (tournamentType.isDraft()) {
    DraftOptions options=new DraftOptions();
    options.setDraftType(""String_Node_Str"");
    options.setTiming((TimingOption)this.cbDraftTiming.getSelectedItem());
    tOptions.setLimitedOptions(options);
  }
  if (tOptions.getLimitedOptions() == null) {
    tOptions.setLimitedOptions(new LimitedOptions());
  }
  if (tournamentType.isLimited()) {
    tOptions.getLimitedOptions().setConstructionTime((Integer)this.spnConstructTime.getValue() * 60);
    tOptions.getLimitedOptions().setIsRandom(tournamentType.isRandom());
    if (tournamentType.isCubeBooster()) {
      tOptions.getLimitedOptions().setDraftCubeName(this.cbDraftCube.getSelectedItem().toString());
      if (!(cubeFromDeckFilename.isEmpty())) {
        Deck cubeFromDeck=new Deck();
        try {
          cubeFromDeck=Deck.load(DeckImporterUtil.importDeck(cubeFromDeckFilename),true,true);
        }
 catch (        GameException e1) {
          JOptionPane.showMessageDialog(MageFrame.getDesktop(),e1.getMessage(),""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
        }
        if (cubeFromDeck != null) {
          cubeFromDeck.clearLayouts();
          tOptions.getLimitedOptions().setCubeFromDeck(cubeFromDeck);
        }
      }
    }
 else     if (tournamentType.isRandom() || tournamentType.isRichMan()) {
      this.isRandom=tournamentType.isRandom();
      this.isRichMan=tournamentType.isRichMan();
      tOptions.getLimitedOptions().getSetCodes().clear();
      ArrayList<String> selected=randomPackSelector.getSelectedPacks();
      int maxPacks=3 * (players.size() + 1);
      if (tournamentType.isRichMan()) {
        maxPacks=36;
      }
      if (selected.size() > maxPacks) {
        StringBuilder infoString=new StringBuilder(""String_Node_Str"");
        infoString.append(maxPacks);
        infoString.append(""String_Node_Str"");
        JOptionPane.showMessageDialog(MageFrame.getDesktop(),infoString,""String_Node_Str"",JOptionPane.INFORMATION_MESSAGE);
        Collections.shuffle(selected);
        tOptions.getLimitedOptions().getSetCodes().addAll(selected.subList(0,maxPacks));
      }
 else {
        tOptions.getLimitedOptions().getSetCodes().addAll(selected);
      }
    }
 else {
      for (      JComboBox pack : packs) {
        tOptions.getLimitedOptions().getSetCodes().add(((ExpansionInfo)pack.getSelectedItem()).getCode());
      }
    }
    tOptions.getMatchOptions().setDeckType(""String_Node_Str"");
    tOptions.getMatchOptions().setGameType(""String_Node_Str"");
    tOptions.getMatchOptions().setLimited(true);
  }
 else {
    tOptions.getLimitedOptions().setConstructionTime(0);
    tOptions.getLimitedOptions().setNumberBoosters(0);
    tOptions.getLimitedOptions().setDraftCube(null);
    tOptions.getLimitedOptions().setDraftCubeName(""String_Node_Str"");
    tOptions.getMatchOptions().setDeckType((String)this.cbDeckType.getSelectedItem());
    tOptions.getMatchOptions().setGameType(((GameTypeView)this.cbGameType.getSelectedItem()).getName());
    tOptions.getMatchOptions().setLimited(false);
  }
  tOptions.getMatchOptions().setMatchTimeLimit((MatchTimeLimit)this.cbTimeLimit.getSelectedItem());
  tOptions.getMatchOptions().setSkillLevel((SkillLevel)this.cbSkillLevel.getSelectedItem());
  tOptions.getMatchOptions().setWinsNeeded((Integer)this.spnNumWins.getValue());
  tOptions.getMatchOptions().setFreeMulligans((Integer)this.spnFreeMulligans.getValue());
  tOptions.getMatchOptions().setAttackOption(MultiplayerAttackOption.LEFT);
  tOptions.getMatchOptions().setRange(RangeOfInfluence.ALL);
  tOptions.getMatchOptions().setRollbackTurnsAllowed(this.chkRollbackTurnsAllowed.isSelected());
  tOptions.getMatchOptions().setRated(this.chkRated.isSelected());
  saveTournamentSettingsToPrefs(tOptions);
  table=SessionHandler.createTournamentTable(roomId,tOptions);
  if (table == null) {
    return;
  }
  if (SessionHandler.joinTournamentTable(roomId,table.getTableId(),this.player1Panel.getPlayerName(),PlayerType.HUMAN,1,DeckImporterUtil.importDeck(this.player1Panel.getDeckFile()),tOptions.getPassword())) {
    for (    TournamentPlayerPanel player : players) {
      if (!player.getPlayerType().toString().equals(""String_Node_Str"")) {
        if (!player.joinTournamentTable(roomId,table.getTableId(),DeckImporterUtil.importDeck(this.player1Panel.getDeckFile()))) {
          SessionHandler.removeTable(roomId,table.getTableId());
          table=null;
          return;
        }
      }
    }
    this.hideDialog();
    return;
  }
  JOptionPane.showMessageDialog(MageFrame.getDesktop(),""String_Node_Str"",""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
  SessionHandler.removeTable(roomId,table.getTableId());
  table=null;
}","private void btnOkActionPerformed(java.awt.event.ActionEvent evt){
  TournamentTypeView tournamentType=(TournamentTypeView)cbTournamentType.getSelectedItem();
  int numSeats=(Integer)this.spnNumSeats.getValue();
  TournamentOptions tOptions=new TournamentOptions(this.txtName.getText(),""String_Node_Str"",numSeats);
  tOptions.setTournamentType(tournamentType.getName());
  tOptions.setPassword(txtPassword.getText());
  tOptions.getPlayerTypes().add(PlayerType.HUMAN);
  tOptions.setWatchingAllowed(cbAllowSpectators.isSelected());
  tOptions.setQuitRatio((Integer)spnQuitRatio.getValue());
  for (  TournamentPlayerPanel player : players) {
    tOptions.getPlayerTypes().add((PlayerType)player.getPlayerType().getSelectedItem());
  }
  if (!tournamentType.isElimination()) {
    tOptions.setNumberRounds((Integer)spnNumRounds.getValue());
  }
  if (tournamentType.isDraft()) {
    DraftOptions options=new DraftOptions();
    options.setDraftType(""String_Node_Str"");
    options.setTiming((TimingOption)this.cbDraftTiming.getSelectedItem());
    tOptions.setLimitedOptions(options);
  }
  if (tOptions.getLimitedOptions() == null) {
    tOptions.setLimitedOptions(new LimitedOptions());
  }
  if (tournamentType.isLimited()) {
    tOptions.getLimitedOptions().setConstructionTime((Integer)this.spnConstructTime.getValue() * 60);
    tOptions.getLimitedOptions().setIsRandom(tournamentType.isRandom());
    if (tournamentType.isCubeBooster()) {
      tOptions.getLimitedOptions().setDraftCubeName(this.cbDraftCube.getSelectedItem().toString());
      if (!(cubeFromDeckFilename.isEmpty())) {
        Deck cubeFromDeck=new Deck();
        try {
          cubeFromDeck=Deck.load(DeckImporterUtil.importDeck(cubeFromDeckFilename),true,true);
        }
 catch (        GameException e1) {
          JOptionPane.showMessageDialog(MageFrame.getDesktop(),e1.getMessage(),""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
        }
        if (cubeFromDeck != null) {
          cubeFromDeck.clearLayouts();
          tOptions.getLimitedOptions().setCubeFromDeck(cubeFromDeck);
        }
      }
    }
 else     if (tournamentType.isRandom() || tournamentType.isRichMan()) {
      this.isRandom=tournamentType.isRandom();
      this.isRichMan=tournamentType.isRichMan();
      tOptions.getLimitedOptions().getSetCodes().clear();
      ArrayList<String> selected=randomPackSelector.getSelectedPacks();
      int maxPacks=3 * (players.size() + 1);
      if (tournamentType.isRichMan()) {
        maxPacks=36;
      }
      if (selected.size() > maxPacks) {
        StringBuilder infoString=new StringBuilder(""String_Node_Str"");
        infoString.append(maxPacks);
        infoString.append(""String_Node_Str"");
        JOptionPane.showMessageDialog(MageFrame.getDesktop(),infoString,""String_Node_Str"",JOptionPane.INFORMATION_MESSAGE);
        Collections.shuffle(selected);
        tOptions.getLimitedOptions().getSetCodes().addAll(selected.subList(0,maxPacks));
      }
 else {
        tOptions.getLimitedOptions().getSetCodes().addAll(selected);
      }
    }
 else {
      for (      JComboBox pack : packs) {
        tOptions.getLimitedOptions().getSetCodes().add(((ExpansionInfo)pack.getSelectedItem()).getCode());
      }
    }
    tOptions.getMatchOptions().setDeckType(""String_Node_Str"");
    tOptions.getMatchOptions().setGameType(""String_Node_Str"");
    tOptions.getMatchOptions().setLimited(true);
  }
 else {
    tOptions.getLimitedOptions().setConstructionTime(0);
    tOptions.getLimitedOptions().setNumberBoosters(0);
    tOptions.getLimitedOptions().setDraftCube(null);
    tOptions.getLimitedOptions().setDraftCubeName(""String_Node_Str"");
    tOptions.getMatchOptions().setDeckType((String)this.cbDeckType.getSelectedItem());
    tOptions.getMatchOptions().setGameType(((GameTypeView)this.cbGameType.getSelectedItem()).getName());
    tOptions.getMatchOptions().setLimited(false);
  }
  tOptions.getMatchOptions().setMatchTimeLimit((MatchTimeLimit)this.cbTimeLimit.getSelectedItem());
  tOptions.getMatchOptions().setSkillLevel((SkillLevel)this.cbSkillLevel.getSelectedItem());
  tOptions.getMatchOptions().setWinsNeeded((Integer)this.spnNumWins.getValue());
  tOptions.getMatchOptions().setFreeMulligans((Integer)this.spnFreeMulligans.getValue());
  tOptions.getMatchOptions().setAttackOption(MultiplayerAttackOption.LEFT);
  tOptions.getMatchOptions().setRange(RangeOfInfluence.ALL);
  tOptions.getMatchOptions().setRollbackTurnsAllowed(this.chkRollbackTurnsAllowed.isSelected());
  tOptions.getMatchOptions().setRated(this.chkRated.isSelected());
  saveTournamentSettingsToPrefs(tOptions);
  table=SessionHandler.createTournamentTable(roomId,tOptions);
  if (table == null) {
    return;
  }
  if (SessionHandler.joinTournamentTable(roomId,table.getTableId(),this.player1Panel.getPlayerName(),PlayerType.HUMAN,1,DeckImporterUtil.importDeck(this.player1Panel.getDeckFile()),tOptions.getPassword())) {
    for (    TournamentPlayerPanel player : players) {
      if (!player.getPlayerType().getSelectedItem().toString().equals(""String_Node_Str"")) {
        if (!player.joinTournamentTable(roomId,table.getTableId(),DeckImporterUtil.importDeck(this.player1Panel.getDeckFile()))) {
          SessionHandler.removeTable(roomId,table.getTableId());
          table=null;
          return;
        }
      }
    }
    this.hideDialog();
    return;
  }
  JOptionPane.showMessageDialog(MageFrame.getDesktop(),""String_Node_Str"",""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
  SessionHandler.removeTable(roomId,table.getTableId());
  table=null;
}",0.99837339598771
158079,"@Override public boolean checkTrigger(GameEvent event,Game game){
  int inputValue=game.getBattlefield().countAll(filter,getControllerId(),game);
  return ComparisonType.compare(value,type,inputValue);
}","@Override public boolean checkTrigger(GameEvent event,Game game){
  int inputValue=game.getBattlefield().countAll(filter,getControllerId(),game);
  return ComparisonType.compare(inputValue,type,value);
}",0.9655172413793104
158080,"@Override public boolean apply(Game game,Ability source){
  Player player=game.getPlayer(source.getControllerId());
  if (player == null) {
    return false;
  }
  int count=1 + new CountersSourceCount(CounterType.LOYALTY).calculate(game,source,this);
  FilterPermanentCard filter=new FilterPermanentCard();
  filter.add(Predicates.or(new CardTypePredicate(CardType.CREATURE),new CardTypePredicate(CardType.LAND)));
  filter.add(new ConvertedManaCostPredicate(Filter.ComparisonType.LessThan,count));
  Card card=player.getLibrary().getFromTop(game);
  if (card != null) {
    Cards cards=new CardsImpl();
    cards.add(card);
    player.lookAtCards(""String_Node_Str"",cards,game);
    if (filter.match(card,game)) {
      String message=""String_Node_Str"" + card.getName() + ""String_Node_Str"";
      if (player.chooseUse(outcome,message,source,game)) {
        return card.putOntoBattlefield(game,Zone.LIBRARY,source.getSourceId(),source.getControllerId(),false);
      }
    }
  }
  return true;
}","@Override public boolean apply(Game game,Ability source){
  Player player=game.getPlayer(source.getControllerId());
  if (player == null) {
    return false;
  }
  int count=1 + new CountersSourceCount(CounterType.LOYALTY).calculate(game,source,this);
  FilterPermanentCard filter=new FilterPermanentCard();
  filter.add(Predicates.or(new CardTypePredicate(CardType.CREATURE),new CardTypePredicate(CardType.LAND)));
  filter.add(new ConvertedManaCostPredicate(ComparisonType.FEWER_THAN,count));
  Card card=player.getLibrary().getFromTop(game);
  if (card != null) {
    Cards cards=new CardsImpl();
    cards.add(card);
    player.lookAtCards(""String_Node_Str"",cards,game);
    if (filter.match(card,game)) {
      String message=""String_Node_Str"" + card.getName() + ""String_Node_Str"";
      if (player.chooseUse(outcome,message,source,game)) {
        return card.putOntoBattlefield(game,Zone.LIBRARY,source.getSourceId(),source.getControllerId(),false);
      }
    }
  }
  return true;
}",0.9743331655762456
158081,"@Override public boolean applies(Permanent permanent,Ability source,Game game){
  FilterControlledCreaturePermanent filter=new FilterControlledCreaturePermanent();
  filter.add(new PowerPredicate(Filter.ComparisonType.GreaterThan,3));
  filter.add(new AnotherPredicate());
  if (permanent.getId().equals(source.getSourceId())) {
    Player controller=game.getPlayer(source.getControllerId());
    if (controller != null) {
      int permanentsOnBattlefield=game.getBattlefield().count(filter,source.getSourceId(),source.getControllerId(),game);
      return (CountType.compare(permanentsOnBattlefield,CountType.FEWER_THAN,1));
    }
    return true;
  }
  return false;
}","@Override public boolean applies(Permanent permanent,Ability source,Game game){
  FilterControlledCreaturePermanent filter=new FilterControlledCreaturePermanent();
  filter.add(new PowerPredicate(ComparisonType.MORE_THAN,3));
  filter.add(new AnotherPredicate());
  if (permanent.getId().equals(source.getSourceId())) {
    Player controller=game.getPlayer(source.getControllerId());
    if (controller != null) {
      int permanentsOnBattlefield=game.getBattlefield().count(filter,source.getSourceId(),source.getControllerId(),game);
      return permanentsOnBattlefield < 1;
    }
    return true;
  }
  return false;
}",0.411446249033256
158082,"@Override public boolean apply(Game game,Ability source){
  Player player=game.getPlayer(source.getControllerId());
  if (player == null) {
    return false;
  }
  int count=1 + new CountersSourceCount(CounterType.LOYALTY).calculate(game,source,this);
  FilterPermanentCard filter=new FilterPermanentCard();
  filter.add(Predicates.or(new CardTypePredicate(CardType.CREATURE),new CardTypePredicate(CardType.LAND)));
  filter.add(new ConvertedManaCostPredicate(Filter.ComparisonType.LessThan,count));
  Card card=player.getLibrary().getFromTop(game);
  if (card != null) {
    Cards cards=new CardsImpl();
    cards.add(card);
    player.lookAtCards(""String_Node_Str"",cards,game);
    if (filter.match(card,game)) {
      String message=""String_Node_Str"" + card.getName() + ""String_Node_Str"";
      if (player.chooseUse(outcome,message,source,game)) {
        return card.putOntoBattlefield(game,Zone.LIBRARY,source.getSourceId(),source.getControllerId(),false);
      }
    }
  }
  return true;
}","@Override public boolean apply(Game game,Ability source){
  Player player=game.getPlayer(source.getControllerId());
  if (player == null) {
    return false;
  }
  int count=1 + new CountersSourceCount(CounterType.LOYALTY).calculate(game,source,this);
  FilterPermanentCard filter=new FilterPermanentCard();
  filter.add(Predicates.or(new CardTypePredicate(CardType.CREATURE),new CardTypePredicate(CardType.LAND)));
  filter.add(new ConvertedManaCostPredicate(ComparisonType.FEWER_THAN,count));
  Card card=player.getLibrary().getFromTop(game);
  if (card != null) {
    Cards cards=new CardsImpl();
    cards.add(card);
    player.lookAtCards(""String_Node_Str"",cards,game);
    if (filter.match(card,game)) {
      String message=""String_Node_Str"" + card.getName() + ""String_Node_Str"";
      if (player.chooseUse(outcome,message,source,game)) {
        return card.putOntoBattlefield(game,Zone.LIBRARY,source.getSourceId(),source.getControllerId(),false);
      }
    }
  }
  return true;
}",0.9743331655762456
158083,"@Override public boolean applies(Permanent permanent,Ability source,Game game){
  FilterControlledCreaturePermanent filter=new FilterControlledCreaturePermanent();
  filter.add(new PowerPredicate(Filter.ComparisonType.GreaterThan,3));
  filter.add(new AnotherPredicate());
  if (permanent.getId().equals(source.getSourceId())) {
    Player controller=game.getPlayer(source.getControllerId());
    if (controller != null) {
      int permanentsOnBattlefield=game.getBattlefield().count(filter,source.getSourceId(),source.getControllerId(),game);
      return (CountType.compare(permanentsOnBattlefield,CountType.FEWER_THAN,1));
    }
    return true;
  }
  return false;
}","@Override public boolean applies(Permanent permanent,Ability source,Game game){
  FilterControlledCreaturePermanent filter=new FilterControlledCreaturePermanent();
  filter.add(new PowerPredicate(ComparisonType.MORE_THAN,3));
  filter.add(new AnotherPredicate());
  if (permanent.getId().equals(source.getSourceId())) {
    Player controller=game.getPlayer(source.getControllerId());
    if (controller != null) {
      int permanentsOnBattlefield=game.getBattlefield().count(filter,source.getSourceId(),source.getControllerId(),game);
      return permanentsOnBattlefield < 1;
    }
    return true;
  }
  return false;
}",0.411446249033256
158084,"public void installComponents(){
  jLayeredPane.setOpaque(false);
  jLayeredPane.add(abilityPicker);
  jLayeredPane.add(DialogManager.getManager(gameId),JLayeredPane.MODAL_LAYER,0);
  abilityPicker.setVisible(false);
}","public void installComponents(){
  jLayeredPane.setOpaque(false);
  jLayeredPane.add(abilityPicker,JLayeredPane.MODAL_LAYER);
  jLayeredPane.add(DialogManager.getManager(gameId),JLayeredPane.MODAL_LAYER,0);
  abilityPicker.setVisible(false);
}",0.945770065075922
158085,"@Override public void init(Game game,boolean testMode){
  this.abort=false;
  if (!testMode) {
    this.hand.clear();
    this.graveyard.clear();
  }
  this.library.reset();
  this.abilities.clear();
  this.counters.clear();
  this.wins=false;
  this.loses=false;
  this.left=false;
  this.quit=false;
  this.timerTimeout=false;
  this.idleTimeout=false;
  this.turns=0;
  this.isGameUnderControl=true;
  this.turnController=this.getId();
  this.playersUnderYourControl.clear();
  this.passed=false;
  this.passedTurn=false;
  this.passedTurnSkipStack=false;
  this.passedUntilEndOfTurn=false;
  this.passedUntilNextMain=false;
  this.skippedAtLeastOnce=false;
  this.passedUntilStackResolved=false;
  this.passedUntilEndStepBeforeMyTurn=false;
  this.passedAllTurns=false;
  this.justActivatedType=null;
  this.canGainLife=true;
  this.canLoseLife=true;
  this.topCardRevealed=false;
  this.payManaMode=false;
  this.setLife(game.getLife(),game);
  this.setReachedNextTurnAfterLeaving(false);
  this.castSourceIdWithAlternateMana=null;
  this.castSourceIdManaCosts=null;
  this.castSourceIdCosts=null;
}","@Override public void init(Game game,boolean testMode){
  this.abort=false;
  if (!testMode) {
    this.hand.clear();
    this.graveyard.clear();
  }
  this.library.reset();
  this.abilities.clear();
  this.counters.clear();
  this.wins=false;
  this.loses=false;
  this.left=false;
  this.quit=false;
  this.timerTimeout=false;
  this.idleTimeout=false;
  this.turns=0;
  this.isGameUnderControl=true;
  this.turnController=this.getId();
  this.playersUnderYourControl.clear();
  this.passed=false;
  this.passedTurn=false;
  this.passedTurnSkipStack=false;
  this.passedUntilEndOfTurn=false;
  this.passedUntilNextMain=false;
  this.skippedAtLeastOnce=false;
  this.passedUntilStackResolved=false;
  this.passedUntilEndStepBeforeMyTurn=false;
  this.passedAllTurns=false;
  this.justActivatedType=null;
  this.canGainLife=true;
  this.canLoseLife=true;
  this.topCardRevealed=false;
  this.payManaMode=false;
  this.setLife(game.getLife(),game);
  this.setReachedNextTurnAfterLeaving(false);
  this.castSourceIdWithAlternateMana=null;
  this.castSourceIdManaCosts=null;
  this.castSourceIdCosts=null;
  this.getManaPool().init();
}",0.9870362092087618
158086,"@Override public boolean apply(Game game,Ability source,UUID originalId,Cost costToPay){
  if (!(source instanceof SpellAbility)) {
    Permanent object=game.getPermanentOrLKIBattlefield(source.getSourceId());
    if (object != null && object.getColor(game).isColorless()) {
      return true;
    }
  }
  if (costToPay instanceof ManaCost) {
    return ((ManaCost)costToPay).getText().contains(""String_Node_Str"");
  }
  return false;
}","@Override public boolean apply(Game game,Ability source,UUID originalId,Cost costToPay){
  if (!(source instanceof Spell)) {
    Permanent permanent=game.getPermanentOrLKIBattlefield(source.getSourceId());
    return permanent != null;
  }
  return false;
}",0.6349206349206349
158087,"@Test public void testConflagrateFlashback(){
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"",2);
  addCard(Zone.HAND,playerA,""String_Node_Str"",1);
  addCard(Zone.GRAVEYARD,playerB,""String_Node_Str"",1);
  addCard(Zone.BATTLEFIELD,playerB,""String_Node_Str"",2);
  addCard(Zone.HAND,playerB,""String_Node_Str"",1);
  castSpell(1,PhaseStep.PRECOMBAT_MAIN,playerA,""String_Node_Str"");
  setChoice(playerA,""String_Node_Str"");
  activateAbility(2,PhaseStep.PRECOMBAT_MAIN,playerB,""String_Node_Str"");
  setChoice(playerB,""String_Node_Str"");
  addTarget(playerB,playerA);
  setStopAt(2,PhaseStep.BEGIN_COMBAT);
  execute();
  assertLife(playerA,19);
  assertLife(playerB,20);
  assertExileCount(playerB,""String_Node_Str"",1);
}","@Test public void testConflagrateFlashback(){
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"",2);
  addCard(Zone.HAND,playerA,""String_Node_Str"",1);
  addCard(Zone.GRAVEYARD,playerB,""String_Node_Str"",1);
  addCard(Zone.BATTLEFIELD,playerB,""String_Node_Str"",2);
  addCard(Zone.HAND,playerB,""String_Node_Str"",1);
  castSpell(1,PhaseStep.PRECOMBAT_MAIN,playerA,""String_Node_Str"");
  setChoice(playerA,""String_Node_Str"");
  activateAbility(2,PhaseStep.PRECOMBAT_MAIN,playerB,""String_Node_Str"");
  setChoice(playerB,""String_Node_Str"");
  addTarget(playerB,playerA);
  setStopAt(2,PhaseStep.BEGIN_COMBAT);
  execute();
  assertExileCount(playerB,""String_Node_Str"",1);
  assertGraveyardCount(playerB,""String_Node_Str"",1);
  assertLife(playerA,19);
  assertLife(playerB,20);
}",0.8987256874580818
158088,"/** 
 * Handles the setting of non mana X costs
 * @param controller
 * @param game
 * @return announce message
 */
protected String handleOtherXCosts(Game game,Player controller){
  StringBuilder announceString=new StringBuilder();
  for (  VariableCost variableCost : this.costs.getVariableCosts()) {
    if (!(variableCost instanceof VariableManaCost)) {
      int xValue=variableCost.announceXValue(this,game);
      Cost fixedCost=variableCost.getFixedCostsFromAnnouncedValue(xValue);
      if (fixedCost != null) {
        costs.add(fixedCost);
      }
      variableCost.setAmount(xValue);
      ((Cost)variableCost).setPaid();
      String message=controller.getLogName() + ""String_Node_Str"" + xValue+ ""String_Node_Str""+ variableCost.getActionText()+ ')';
      announceString.append(message);
    }
  }
  return announceString.toString();
}","/** 
 * Handles the setting of non mana X costs
 * @param controller
 * @param game
 * @return announce message
 */
protected String handleOtherXCosts(Game game,Player controller){
  StringBuilder announceString=new StringBuilder();
  for (  VariableCost variableCost : this.costs.getVariableCosts()) {
    if (!(variableCost instanceof VariableManaCost) && !((Cost)variableCost).isPaid()) {
      int xValue=variableCost.announceXValue(this,game);
      Cost fixedCost=variableCost.getFixedCostsFromAnnouncedValue(xValue);
      if (fixedCost != null) {
        costs.add(fixedCost);
      }
      variableCost.setAmount(xValue);
      ((Cost)variableCost).setPaid();
      String message=controller.getLogName() + ""String_Node_Str"" + xValue+ ""String_Node_Str""+ variableCost.getActionText()+ ')';
      announceString.append(message);
    }
  }
  return announceString.toString();
}",0.9803695150115472
158089,"@Override public int announceXValue(Ability source,Game game){
  int xValue=0;
  Player controller=game.getPlayer(source.getControllerId());
  StackObject stackObject=game.getStack().getStackObject(source.getId());
  if (controller != null && stackObject != null) {
    xValue=controller.announceXCost(getMinValue(source,game),getMaxValue(source,game),""String_Node_Str"" + actionText,game,source,this);
  }
  return xValue;
}","@Override public int announceXValue(Ability source,Game game){
  int xValue=0;
  Player controller=game.getPlayer(source.getControllerId());
  StackObject stackObject=game.getStack().getStackObject(source.getId());
  if (controller != null && (source instanceof FlashbackAbility || stackObject != null)) {
    xValue=controller.announceXCost(getMinValue(source,game),getMaxValue(source,game),""String_Node_Str"" + actionText,game,source,this);
  }
  return xValue;
}",0.954954954954955
158090,"@Override public boolean replaceEvent(GameEvent event,Ability source,Game game){
  Permanent creature=((EntersTheBattlefieldEvent)event).getTarget();
  if (creature != null) {
    creature.addCounters(CounterType.P1P1.createInstance(),source,game);
  }
  return false;
}","@Override public boolean replaceEvent(GameEvent event,Ability source,Game game){
  Permanent creature=((EntersTheBattlefieldEvent)event).getTarget();
  if (creature != null) {
    creature.addCounters(CounterType.P1P1.createInstance(),source,game,event.getAppliedEffects());
  }
  return false;
}",0.9540636042402828
158091,"@Override public boolean apply(Game game,Ability source){
  int maxPower=0;
  for (  Permanent perm : game.getBattlefield().getAllActivePermanents(new FilterCreaturePermanent(),source.getControllerId(),game)) {
    if (perm.getPower().getValue() > maxPower) {
      maxPower=perm.getPower().getValue();
    }
  }
  ContinuousEffect effect=new GainAbilityControlledEffect(TrampleAbility.getInstance(),Duration.EndOfStep,new FilterCreaturePermanent());
  game.addEffect(effect,source);
  if (maxPower != 0) {
    effect=new BoostControlledEffect(maxPower,maxPower,Duration.EndOfTurn);
    game.addEffect(effect,source);
  }
  return true;
}","@Override public boolean apply(Game game,Ability source){
  int maxPower=0;
  for (  Permanent perm : game.getBattlefield().getAllActivePermanents(new FilterCreaturePermanent(),source.getControllerId(),game)) {
    if (perm.getPower().getValue() > maxPower) {
      maxPower=perm.getPower().getValue();
    }
  }
  ContinuousEffect effect=new GainAbilityControlledEffect(TrampleAbility.getInstance(),Duration.EndOfTurn,new FilterCreaturePermanent());
  game.addEffect(effect,source);
  if (maxPower != 0) {
    effect=new BoostControlledEffect(maxPower,maxPower,Duration.EndOfTurn);
    game.addEffect(effect,source);
  }
  return true;
}",0.9937304075235108
158092,"@Override public int calculate(Game game,Ability sourceAbility,Effect effect){
  for (  Cost cost : sourceAbility.getCosts()) {
    if (cost instanceof DiscardTargetCost) {
      return ((DiscardTargetCost)cost).getCards().size();
    }
  }
  return sourceAbility.getManaCostsToPay().getX();
}","@Override public int calculate(Game game,Ability sourceAbility,Effect effect){
  int xValue=sourceAbility.getManaCostsToPay().getX();
  for (  Cost cost : sourceAbility.getCosts()) {
    if (cost instanceof DiscardTargetCost) {
      xValue=((DiscardTargetCost)cost).getCards().size();
    }
  }
  return xValue;
}",0.8105436573311368
158093,"@Override public int announceXValue(Ability source,Game game){
  int xValue=0;
  Player controller=game.getPlayer(source.getControllerId());
  if (controller != null) {
    xValue=controller.announceXCost(getMinValue(source,game),getMaxValue(source,game),""String_Node_Str"" + actionText,game,source,this);
  }
  return xValue;
}","@Override public int announceXValue(Ability source,Game game){
  int xValue=0;
  Player controller=game.getPlayer(source.getControllerId());
  Spell spell=game.getStack().getSpell(source.getId());
  if (controller != null && spell != null) {
    xValue=controller.announceXCost(getMinValue(source,game),getMaxValue(source,game),""String_Node_Str"" + actionText,game,source,this);
  }
  return xValue;
}",0.8995873452544704
158094,"@Override public int announceXValue(Ability source,Game game){
  int xValue=0;
  Player controller=game.getPlayer(source.getControllerId());
  Spell spell=game.getStack().getSpell(source.getId());
  if (controller != null && spell != null) {
    xValue=controller.announceXCost(getMinValue(source,game),getMaxValue(source,game),""String_Node_Str"" + actionText,game,source,this);
  }
  return xValue;
}","@Override public int announceXValue(Ability source,Game game){
  int xValue=0;
  Player controller=game.getPlayer(source.getControllerId());
  StackObject stackObject=game.getStack().getStackObject(source.getId());
  if (controller != null && stackObject != null) {
    xValue=controller.announceXCost(getMinValue(source,game),getMaxValue(source,game),""String_Node_Str"" + actionText,game,source,this);
  }
  return xValue;
}",0.9271844660194176
158095,"@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller == null) {
    return false;
  }
  Permanent arsenalThresher=game.getPermanentEntering(source.getSourceId());
  FilterArtifactCard filter=new FilterArtifactCard();
  filter.add(new AnotherCardPredicate());
  if (controller.chooseUse(Outcome.Benefit,""String_Node_Str"",source,game)) {
    Cards cards=new CardsImpl();
    if (controller.getHand().count(filter,source.getSourceId(),source.getControllerId(),game) > 0) {
      TargetCardInHand target=new TargetCardInHand(0,Integer.MAX_VALUE,filter);
      if (controller.choose(Outcome.Benefit,target,source.getSourceId(),game)) {
        for (        UUID uuid : target.getTargets()) {
          cards.add(controller.getHand().get(uuid,game));
        }
        if (arsenalThresher != null) {
          controller.revealCards(arsenalThresher.getIdName(),cards,game);
          arsenalThresher.addCounters(CounterType.P1P1.createInstance(cards.size()),source,game);
        }
      }
    }
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller == null) {
    return false;
  }
  Permanent arsenalThresher=game.getPermanentEntering(source.getSourceId());
  FilterArtifactCard filter=new FilterArtifactCard();
  filter.add(new AnotherCardPredicate());
  if (controller.chooseUse(Outcome.Benefit,""String_Node_Str"",source,game)) {
    Cards cards=new CardsImpl();
    if (controller.getHand().count(filter,source.getSourceId(),source.getControllerId(),game) > 0) {
      TargetCardInHand target=new TargetCardInHand(0,Integer.MAX_VALUE,filter);
      if (controller.choose(Outcome.Benefit,target,source.getSourceId(),game)) {
        for (        UUID uuid : target.getTargets()) {
          cards.add(controller.getHand().get(uuid,game));
        }
        if (arsenalThresher != null) {
          controller.revealCards(arsenalThresher.getIdName(),cards,game);
          ArrayList<UUID> appliedEffects=(ArrayList<UUID>)this.getValue(""String_Node_Str"");
          arsenalThresher.addCounters(CounterType.P1P1.createInstance(cards.size()),source,game,appliedEffects);
        }
      }
    }
    return true;
  }
  return false;
}",0.954096954096954
158096,"@Override public boolean replaceEvent(GameEvent event,Ability source,Game game){
  Permanent creature=((EntersTheBattlefieldEvent)event).getTarget();
  if (creature != null) {
    creature.addCounters(CounterType.P1P1.createInstance(),source,game);
  }
  return false;
}","@Override public boolean replaceEvent(GameEvent event,Ability source,Game game){
  Permanent creature=((EntersTheBattlefieldEvent)event).getTarget();
  if (creature != null) {
    creature.addCounters(CounterType.P1P1.createInstance(),source,game,event.getAppliedEffects());
  }
  return false;
}",0.9540636042402828
158097,"@Override public boolean replaceEvent(GameEvent event,Ability source,Game game){
  Permanent creature=((EntersTheBattlefieldEvent)event).getTarget();
  Map<String,Integer> spellX=(Map<String,Integer>)game.getState().getValue(""String_Node_Str"" + source.getSourceId());
  MageObject sourceObject=source.getSourceObject(game);
  if (sourceObject != null && creature != null && spellX != null) {
    String key=event.getSourceId().toString() + (game.getState().getZoneChangeCounter(event.getSourceId()) - 1);
    int xValue=spellX.get(key);
    if (xValue > 0) {
      creature.addCounters(CounterType.P1P1.createInstance(xValue),source,game);
      game.informPlayers(sourceObject.getLogName() + ""String_Node_Str"" + creature.getLogName()+ ""String_Node_Str""+ xValue+ ""String_Node_Str""+ (xValue > 1 ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str"");
    }
    spellX.remove(key);
  }
  return false;
}","@Override public boolean replaceEvent(GameEvent event,Ability source,Game game){
  Permanent creature=((EntersTheBattlefieldEvent)event).getTarget();
  Map<String,Integer> spellX=(Map<String,Integer>)game.getState().getValue(""String_Node_Str"" + source.getSourceId());
  MageObject sourceObject=source.getSourceObject(game);
  if (sourceObject != null && creature != null && spellX != null) {
    String key=event.getSourceId().toString() + (game.getState().getZoneChangeCounter(event.getSourceId()) - 1);
    int xValue=spellX.get(key);
    if (xValue > 0) {
      creature.addCounters(CounterType.P1P1.createInstance(xValue),source,game,event.getAppliedEffects());
      game.informPlayers(sourceObject.getLogName() + ""String_Node_Str"" + creature.getLogName()+ ""String_Node_Str""+ xValue+ ""String_Node_Str""+ (xValue > 1 ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str"");
    }
    spellX.remove(key);
  }
  return false;
}",0.9858695652173912
158098,"@Override public boolean replaceEvent(GameEvent event,Ability source,Game game){
  Permanent target=((EntersTheBattlefieldEvent)event).getTarget();
  if (target != null) {
    target.addCounters(CounterType.P1P1.createInstance(),source,game);
  }
  return false;
}","@Override public boolean replaceEvent(GameEvent event,Ability source,Game game){
  Permanent target=((EntersTheBattlefieldEvent)event).getTarget();
  if (target != null) {
    target.addCounters(CounterType.P1P1.createInstance(),source,game,event.getAppliedEffects());
  }
  return false;
}",0.9530685920577616
158099,"@Override public boolean replaceEvent(GameEvent event,Ability source,Game game){
  Permanent permanent=((EntersTheBattlefieldEvent)event).getTarget();
  if (permanent != null) {
    permanent.addCounters(CounterType.P1P1.createInstance(),source,game);
    discard();
  }
  return false;
}","@Override public boolean replaceEvent(GameEvent event,Ability source,Game game){
  Permanent permanent=((EntersTheBattlefieldEvent)event).getTarget();
  if (permanent != null) {
    permanent.addCounters(CounterType.P1P1.createInstance(),source,game,event.getAppliedEffects());
    discard();
  }
  return false;
}",0.956810631229236
158100,"@Override public boolean apply(Game game,Ability source){
  Permanent permanent=game.getPermanent(source.getFirstTarget());
  if (permanent != null) {
    permanent.addCounters(CounterType.P1P1.createInstance(2),source,game);
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  return false;
}",0.4424778761061947
158101,"@Override public NecromanticSummoningEffect copy(){
  return new NecromanticSummoningEffect(this);
}","@Override public NecromanticSummoningReplacementEffect copy(){
  return new NecromanticSummoningReplacementEffect(this);
}",0.9009009009009008
158102,"@Override public boolean replaceEvent(GameEvent event,Ability source,Game game){
  Permanent creature=((EntersTheBattlefieldEvent)event).getTarget();
  if (creature != null) {
    creature.addCounters(CounterType.P1P1.createInstance(),source,game);
  }
  return false;
}","@Override public boolean replaceEvent(GameEvent event,Ability source,Game game){
  Permanent creature=((EntersTheBattlefieldEvent)event).getTarget();
  if (creature != null) {
    creature.addCounters(CounterType.P1P1.createInstance(),source,game,event.getAppliedEffects());
  }
  return false;
}",0.9540636042402828
158103,"@Override public boolean replaceEvent(GameEvent event,Ability source,Game game){
  Permanent permanent=((EntersTheBattlefieldEvent)event).getTarget();
  if (permanent != null) {
    permanent.addCounters(CounterType.P1P1.createInstance(),source,game);
    discard();
  }
  return false;
}","@Override public boolean replaceEvent(GameEvent event,Ability source,Game game){
  Permanent permanent=((EntersTheBattlefieldEvent)event).getTarget();
  if (permanent != null) {
    permanent.addCounters(CounterType.P1P1.createInstance(),source,game,event.getAppliedEffects());
    discard();
  }
  return false;
}",0.956810631229236
158104,"@Override public boolean replaceEvent(GameEvent event,Ability source,Game game){
  Permanent creature=((EntersTheBattlefieldEvent)event).getTarget();
  if (creature != null) {
    creature.addCounters(CounterType.P1P1.createInstance(),source,game);
  }
  return false;
}","@Override public boolean replaceEvent(GameEvent event,Ability source,Game game){
  Permanent creature=((EntersTheBattlefieldEvent)event).getTarget();
  if (creature != null) {
    creature.addCounters(CounterType.P1P1.createInstance(),source,game,event.getAppliedEffects());
  }
  return false;
}",0.9540636042402828
158105,"@Override public boolean replaceEvent(GameEvent event,Ability source,Game game){
  Permanent creature=((EntersTheBattlefieldEvent)event).getTarget();
  if (creature != null) {
    creature.addCounters(CounterType.P1P1.createInstance(),source,game);
  }
  discard();
  return false;
}","@Override public boolean replaceEvent(GameEvent event,Ability source,Game game){
  Permanent creature=((EntersTheBattlefieldEvent)event).getTarget();
  if (creature != null) {
    creature.addCounters(CounterType.P1P1.createInstance(),source,game,event.getAppliedEffects());
  }
  discard();
  return false;
}",0.956081081081081
158106,"public String connectUserHandling(String userName,String password) throws MageException {
  this.isAdmin=false;
  AuthorizedUser authorizedUser=null;
  if (ConfigSettings.instance.isAuthenticationActivated()) {
    authorizedUser=AuthorizedUserRepository.instance.getByName(userName);
    String errorMsg=""String_Node_Str"";
    if (authorizedUser == null) {
      return errorMsg;
    }
    if (!Main.isTestMode() && !authorizedUser.doCredentialsMatch(userName,password)) {
      return errorMsg;
    }
    if (!authorizedUser.active) {
      return ""String_Node_Str"";
    }
    if (authorizedUser.lockedUntil != null) {
      if (authorizedUser.lockedUntil.compareTo(Calendar.getInstance().getTime()) > 0) {
        return ""String_Node_Str"" + SystemUtil.dateFormat.format(authorizedUser.lockedUntil);
      }
 else {
        UserManager.instance.createUser(userName,host,authorizedUser).ifPresent(user -> user.setLockedUntil(null));
      }
      Optional<User> selectUser=UserManager.instance.createUser(userName,host,authorizedUser);
      boolean reconnect=false;
      if (!selectUser.isPresent()) {
        selectUser=UserManager.instance.getUserByName(userName);
        if (selectUser.isPresent()) {
          User user=selectUser.get();
          if (ConfigSettings.instance.isAuthenticationActivated() || user.getHost().equals(host)) {
            user.updateLastActivity(null);
            this.userId=user.getId();
            if (user.getSessionId().isEmpty()) {
              logger.info(""String_Node_Str"" + userName);
              reconnect=true;
            }
 else {
              logger.info(""String_Node_Str"" + userName);
              SessionManager.instance.disconnect(user.getSessionId(),DisconnectReason.ConnectingOtherInstance);
            }
          }
 else {
            return ""String_Node_Str"" + userName + ""String_Node_Str"";
          }
        }
      }
      User user=selectUser.get();
      if (!UserManager.instance.connectToSession(sessionId,user.getId())) {
        return ""String_Node_Str"" + userName;
      }
      this.userId=user.getId();
      if (reconnect) {
        Optional<GamesRoom> room=GamesRoomManager.instance.getRoom(GamesRoomManager.instance.getMainRoomId());
        if (!room.isPresent()) {
          logger.error(""String_Node_Str"");
          return null;
        }
        ChatManager.instance.joinChat(room.get().getChatId(),userId);
        ChatManager.instance.sendReconnectMessage(userId);
      }
    }
  }
  return null;
}","public String connectUserHandling(String userName,String password) throws MageException {
  this.isAdmin=false;
  AuthorizedUser authorizedUser=null;
  if (ConfigSettings.instance.isAuthenticationActivated()) {
    authorizedUser=AuthorizedUserRepository.instance.getByName(userName);
    String errorMsg=""String_Node_Str"";
    if (authorizedUser == null) {
      return errorMsg;
    }
    if (!Main.isTestMode() && !authorizedUser.doCredentialsMatch(userName,password)) {
      return errorMsg;
    }
    if (!authorizedUser.active) {
      return ""String_Node_Str"";
    }
    if (authorizedUser.lockedUntil != null) {
      if (authorizedUser.lockedUntil.compareTo(Calendar.getInstance().getTime()) > 0) {
        return ""String_Node_Str"" + SystemUtil.dateFormat.format(authorizedUser.lockedUntil);
      }
 else {
        UserManager.instance.createUser(userName,host,authorizedUser).ifPresent(user -> user.setLockedUntil(null));
      }
    }
  }
  Optional<User> selectUser=UserManager.instance.createUser(userName,host,authorizedUser);
  boolean reconnect=false;
  if (!selectUser.isPresent()) {
    selectUser=UserManager.instance.getUserByName(userName);
    if (selectUser.isPresent()) {
      User user=selectUser.get();
      if (ConfigSettings.instance.isAuthenticationActivated() || user.getHost().equals(host)) {
        user.updateLastActivity(null);
        this.userId=user.getId();
        if (user.getSessionId().isEmpty()) {
          logger.info(""String_Node_Str"" + userName);
          reconnect=true;
        }
 else {
          logger.info(""String_Node_Str"" + userName);
          SessionManager.instance.disconnect(user.getSessionId(),DisconnectReason.ConnectingOtherInstance);
        }
      }
 else {
        return ""String_Node_Str"" + userName + ""String_Node_Str"";
      }
    }
  }
  User user=selectUser.get();
  if (!UserManager.instance.connectToSession(sessionId,user.getId())) {
    return ""String_Node_Str"" + userName;
  }
  this.userId=user.getId();
  if (reconnect) {
    Optional<GamesRoom> room=GamesRoomManager.instance.getRoom(GamesRoomManager.instance.getMainRoomId());
    if (!room.isPresent()) {
      logger.error(""String_Node_Str"");
      return null;
    }
    ChatManager.instance.joinChat(room.get().getChatId(),userId);
    ChatManager.instance.sendReconnectMessage(userId);
  }
  return null;
}",0.957816377171216
158107,"@Override public boolean apply(Game game,Ability source){
  Player player=game.getPlayer(getTargetPointer().getFirst(game,source));
  Object object=(String)game.getState().getValue(source.getSourceId().toString() + NameACardEffect.INFO_KEY);
  if (player != null && object instanceof String) {
    String namedCard=(String)object;
    for (    Card card : player.getHand().getCards(game)) {
      if (card != null && card.getName().equals(namedCard)) {
        return new SearchLibraryPutInHandEffect(new TargetCardInLibrary(filter),true,true).apply(game,source);
      }
    }
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Player player=game.getPlayer(getTargetPointer().getFirst(game,source));
  Object object=(String)game.getState().getValue(source.getSourceId().toString() + NameACardEffect.INFO_KEY);
  if (player != null && object instanceof String) {
    player.revealCards(player.getLogName() + ""String_Node_Str"",player.getHand(),game,true);
    String namedCard=(String)object;
    for (    Card card : player.getHand().getCards(game)) {
      if (card != null && card.getName().equals(namedCard)) {
        return new SearchLibraryPutInHandEffect(new TargetCardInLibrary(filter),true,true).apply(game,source);
      }
    }
    return true;
  }
  return false;
}",0.9305135951661632
158108,"@Override public TargetCreaturePermanentSameController copy(){
  return new TargetCreaturePermanentSameController(this);
}","@Override public CannibalizeEffect copy(){
  return new CannibalizeEffect(this);
}",0.5686274509803921
158109,"@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  MageObject sourceObject=source.getSourceObject(game);
  if (controller != null && sourceObject != null) {
    ArrayList<Permanent> destroyedPermanents=new ArrayList<>();
    for (    UUID targetId : getTargetPointer().getTargets(game,source)) {
      Permanent target=game.getPermanent(targetId);
      if (target != null) {
        if (target.destroy(source.getSourceId(),game,false)) {
          destroyedPermanents.add(target);
        }
      }
    }
    HashMap<Player,Cards> cardsToReveal=new HashMap<>();
    for (    Permanent permanent : destroyedPermanents) {
      Player controllerOfDestroyedCreature=game.getPlayer(permanent.getControllerId());
      if (controllerOfDestroyedCreature != null) {
        Library library=controllerOfDestroyedCreature.getLibrary();
        if (library.hasCards()) {
          Cards cards=new CardsImpl();
          Cards revealCards;
          if (cardsToReveal.containsKey(controllerOfDestroyedCreature)) {
            revealCards=cardsToReveal.get(controllerOfDestroyedCreature);
          }
 else {
            revealCards=new CardsImpl();
            cardsToReveal.put(controllerOfDestroyedCreature,revealCards);
          }
          Card card=library.removeFromTop(game);
          cards.add(card);
          while (!card.isCreature() && !card.isArtifact() && library.hasCards()) {
            card=library.removeFromTop(game);
            cards.add(card);
          }
          if (card.isCreature() || card.isArtifact()) {
            controllerOfDestroyedCreature.moveCards(card,Zone.BATTLEFIELD,source,game);
          }
          if (!cards.isEmpty()) {
            revealCards.addAll(cards);
            Set<Card> cardsToShuffle=cards.getCards(game);
            cardsToShuffle.remove(card);
            library.addAll(cardsToShuffle,game);
          }
          controllerOfDestroyedCreature.shuffleLibrary(source,game);
        }
      }
    }
    for (    Player player : cardsToReveal.keySet()) {
      player.revealCards(sourceObject.getIdName(),cardsToReveal.get(player),game);
    }
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  MageObject sourceObject=source.getSourceObject(game);
  if (controller != null && sourceObject != null) {
    ArrayList<Permanent> destroyedPermanents=new ArrayList<>();
    for (    UUID targetId : getTargetPointer().getTargets(game,source)) {
      Permanent target=game.getPermanent(targetId);
      if (target != null) {
        if (target.destroy(source.getSourceId(),game,false)) {
          destroyedPermanents.add(target);
        }
      }
    }
    HashMap<Player,Cards> cardsToReveal=new HashMap<>();
    for (    Permanent permanent : destroyedPermanents) {
      Player controllerOfDestroyedCreature=game.getPlayer(permanent.getControllerId());
      if (controllerOfDestroyedCreature != null) {
        Library library=controllerOfDestroyedCreature.getLibrary();
        if (library.hasCards()) {
          Cards cards=new CardsImpl();
          Cards revealCards;
          if (cardsToReveal.containsKey(controllerOfDestroyedCreature)) {
            revealCards=cardsToReveal.get(controllerOfDestroyedCreature);
          }
 else {
            revealCards=new CardsImpl();
            cardsToReveal.put(controllerOfDestroyedCreature,revealCards);
          }
          Card card=library.removeFromTop(game);
          cards.add(card);
          while (!card.isCreature() && !card.isArtifact() && library.hasCards()) {
            card=library.removeFromTop(game);
            cards.add(card);
          }
          if (!cards.isEmpty()) {
            revealCards.addAll(cards);
            if (card.isCreature() || card.isArtifact()) {
              controllerOfDestroyedCreature.moveCards(card,Zone.EXILED,source,game);
              controllerOfDestroyedCreature.moveCards(card,Zone.BATTLEFIELD,source,game);
            }
            Set<Card> cardsToShuffle=cards.getCards(game);
            cardsToShuffle.remove(card);
            library.addAll(cardsToShuffle,game);
          }
          controllerOfDestroyedCreature.shuffleLibrary(source,game);
        }
      }
    }
    for (    Player player : cardsToReveal.keySet()) {
      player.revealCards(sourceObject.getIdName(),cardsToReveal.get(player),game);
    }
    return true;
  }
  return false;
}",0.9473917869034406
158110,"@Override public boolean canTarget(UUID controllerId,UUID id,Ability source,Game game){
  if (super.canTarget(controllerId,id,source,game)) {
    Permanent firstTargetPermanent=game.getPermanent(id);
    if (firstTargetPermanent != null) {
      for (      Object object : getTargets()) {
        UUID targetId=(UUID)object;
        Permanent targetPermanent=game.getPermanent(targetId);
        if (targetPermanent != null) {
          if (firstTargetPermanent.getId() != targetPermanent.getId()) {
            if (!firstTargetPermanent.getControllerId().equals(targetPermanent.getOwnerId())) {
              return false;
            }
          }
        }
      }
      return true;
    }
  }
  return false;
}","@Override public boolean canTarget(UUID controllerId,UUID id,Ability source,Game game){
  if (super.canTarget(controllerId,id,source,game)) {
    Permanent firstTargetPermanent=game.getPermanent(id);
    if (firstTargetPermanent != null) {
      for (      Object object : getTargets()) {
        UUID targetId=(UUID)object;
        Permanent targetPermanent=game.getPermanent(targetId);
        if (targetPermanent != null) {
          if (!firstTargetPermanent.getId().equals(targetPermanent.getId())) {
            if (!firstTargetPermanent.getControllerId().equals(targetPermanent.getOwnerId())) {
              return false;
            }
          }
        }
      }
      return true;
    }
  }
  return false;
}",0.9595536959553695
158111,"@Override public boolean canTarget(UUID controllerId,UUID id,Ability source,Game game){
  if (super.canTarget(controllerId,id,source,game)) {
    Permanent creature=game.getPermanent(id);
    if (creature != null) {
      for (      Object object : getTargets()) {
        UUID targetId=(UUID)object;
        Permanent selectedCreature=game.getPermanent(targetId);
        if (creature.getId() != selectedCreature.getId()) {
          if (CardUtil.shareSubtypes(creature,selectedCreature,game)) {
            return false;
          }
        }
      }
      return true;
    }
  }
  return false;
}","@Override public boolean canTarget(UUID controllerId,UUID id,Ability source,Game game){
  if (super.canTarget(controllerId,id,source,game)) {
    Permanent creature=game.getPermanent(id);
    if (creature != null) {
      for (      Object object : getTargets()) {
        UUID targetId=(UUID)object;
        Permanent selectedCreature=game.getPermanent(targetId);
        if (!creature.getId().equals(selectedCreature.getId())) {
          if (CardUtil.shareSubtypes(creature,selectedCreature,game)) {
            return false;
          }
        }
      }
      return true;
    }
  }
  return false;
}",0.9883720930232558
158112,"@Override public boolean applies(UUID sourceId,Ability source,UUID affectedControllerId,Game game){
  if (sourceId.equals(source.getSourceId())) {
    Card card=game.getCard(source.getSourceId());
    if (card != null && card.getOwnerId().equals(source.getControllerId()) && game.getState().getZone(source.getSourceId()) == Zone.EXILED) {
      return true;
    }
  }
  return false;
}","@Override public boolean applies(UUID sourceId,Ability source,UUID affectedControllerId,Game game){
  if (sourceId.equals(source.getSourceId())) {
    Card card=game.getCard(source.getSourceId());
    if (card != null && card.getOwnerId().equals(affectedControllerId) && game.getState().getZone(source.getSourceId()) == Zone.EXILED) {
      return true;
    }
  }
  return false;
}",0.9738903394255874
158113,"@Override public boolean sacrifice(UUID sourceId,Game game){
  if (isPhasedIn() && !game.replaceEvent(GameEvent.getEvent(EventType.SACRIFICE_PERMANENT,objectId,sourceId,controllerId))) {
    moveToZone(Zone.GRAVEYARD,sourceId,game,false);
    Player player=game.getPlayer(getControllerId());
    if (player != null && !game.isSimulation()) {
      game.informPlayers(player.getLogName() + ""String_Node_Str"" + this.getLogName());
    }
    game.fireEvent(GameEvent.getEvent(EventType.SACRIFICED_PERMANENT,objectId,sourceId,controllerId));
    return true;
  }
  return false;
}","@Override public boolean sacrifice(UUID sourceId,Game game){
  if (isPhasedIn() && !game.replaceEvent(GameEvent.getEvent(EventType.SACRIFICE_PERMANENT,objectId,sourceId,controllerId))) {
    moveToZone(Zone.GRAVEYARD,sourceId,game,false);
    Player player=game.getPlayer(getControllerId());
    if (player != null && !game.isSimulation()) {
      game.informPlayers(player.getLogName() + ""String_Node_Str"" + this.getLogName());
    }
    game.fireEvent(GameEvent.getEvent(EventType.SACRIFICED_PERMANENT,objectId,sourceId,controllerId));
    game.checkStateAndTriggered();
    return true;
  }
  return false;
}",0.9519797809604044
158114,"public static String getStringManaCost(List<String> manaCost){
  StringBuilder sb=new StringBuilder();
  for (  String s : manaCost) {
    sb.append(s);
  }
  return sb.toString().replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str"").trim();
}","public static String getStringManaCost(List<String> manaCost){
  StringBuilder sb=new StringBuilder();
  for (  String s : manaCost) {
    sb.append(s);
  }
  return sb.toString().replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str"").trim();
}",0.9253731343283582
158115,"/** 
 * Reported bug: ""Silverfur Partisan and fellow wolves did not trigger off of copies of Strength of Arms made by Zada, Hedron Grinder.  Not sure about other spells, but I imagine similar results.""
 */
@Test public void ZadaHedronSilverfurPartisan(){
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"");
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"",1);
  addCard(Zone.HAND,playerA,""String_Node_Str"",1);
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"",3);
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"",3);
  castSpell(1,PhaseStep.PRECOMBAT_MAIN,playerA,""String_Node_Str"",""String_Node_Str"");
  setStopAt(1,PhaseStep.BEGIN_COMBAT);
  execute();
  assertGraveyardCount(playerA,""String_Node_Str"",1);
  assertPowerToughness(playerA,""String_Node_Str"",5,5);
  assertPowerToughness(playerA,""String_Node_Str"",6,6);
  assertPermanentCount(playerA,""String_Node_Str"",1);
}","/** 
 * Reported bug: ""Silverfur Partisan and fellow wolves did not trigger off of copies of Strength of Arms made by Zada, Hedron Grinder. Not sure about other spells, but I imagine similar results.""
 */
@Test public void ZadaHedronSilverfurPartisan(){
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"");
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"",1);
  addCard(Zone.HAND,playerA,""String_Node_Str"",1);
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"",3);
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"",3);
  castSpell(1,PhaseStep.PRECOMBAT_MAIN,playerA,""String_Node_Str"",""String_Node_Str"");
  setStopAt(1,PhaseStep.BEGIN_COMBAT);
  execute();
  assertGraveyardCount(playerA,""String_Node_Str"",1);
  assertPowerToughness(playerA,""String_Node_Str"",5,5);
  assertPowerToughness(playerA,""String_Node_Str"",6,6);
  assertPermanentCount(playerA,""String_Node_Str"",1);
}",0.9994347088750708
158116,"/** 
 * {4}{U} Enchantment (Enchant Player) Whenever enchanted player casts an instant or sorcery spell, each other player may copy that spell  and may choose new targets for the copy he or she controls. Reported bug: ""A player with Curse of Echoes attached to them played Bribery and the player who controlled the curse had control  of all 3 copies. This seems to be the case for all spells.""
 */
@Test public void testCurseOfEchoes(){
  addCard(Zone.HAND,playerA,""String_Node_Str"");
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"",5);
  addCard(Zone.HAND,playerB,""String_Node_Str"");
  addCard(Zone.BATTLEFIELD,playerB,""String_Node_Str"");
  castSpell(1,PhaseStep.PRECOMBAT_MAIN,playerA,""String_Node_Str"");
  addTarget(playerA,playerB);
  castSpell(2,PhaseStep.PRECOMBAT_MAIN,playerB,""String_Node_Str"");
  addTarget(playerB,playerA);
  setChoice(playerA,""String_Node_Str"");
  addTarget(playerA,playerB);
  setStopAt(2,PhaseStep.BEGIN_COMBAT);
  execute();
  assertGraveyardCount(playerB,""String_Node_Str"",1);
  assertLife(playerA,17);
  assertLife(playerB,17);
}","/** 
 * {4}{U} Enchantment (Enchant Player) Whenever enchanted player casts an instant or sorcery spell, each other player may copy that spell and may choose new targets for the copy he or she controls. Reported bug: ""A player with Curse of Echoes attached to them played Bribery and the player who controlled the curse had control of all 3 copies. This seems to be the case for all spells.""
 */
@Test public void testCurseOfEchoes(){
  addCard(Zone.HAND,playerA,""String_Node_Str"");
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"",5);
  addCard(Zone.HAND,playerB,""String_Node_Str"");
  addCard(Zone.BATTLEFIELD,playerB,""String_Node_Str"");
  castSpell(1,PhaseStep.PRECOMBAT_MAIN,playerA,""String_Node_Str"");
  addTarget(playerA,playerB);
  castSpell(2,PhaseStep.PRECOMBAT_MAIN,playerB,""String_Node_Str"");
  addTarget(playerB,playerA);
  setChoice(playerA,""String_Node_Str"");
  addTarget(playerA,playerB);
  setStopAt(2,PhaseStep.BEGIN_COMBAT);
  execute();
  assertGraveyardCount(playerB,""String_Node_Str"",1);
  assertLife(playerA,17);
  assertLife(playerB,17);
}",0.99906191369606
158117,"@Override public boolean addTargets(Ability ability,Game game){
  if (groupsForTargetHandling == null) {
    return true;
  }
  boolean result=true;
  for (int i=1; i < groupsForTargetHandling.length; i++) {
    String group=groupsForTargetHandling[i];
    if (group.startsWith(""String_Node_Str"") || group.startsWith(""String_Node_Str"") || group.startsWith(""String_Node_Str"")|| group.startsWith(""String_Node_Str"")|| group.startsWith(""String_Node_Str"")) {
      break;
    }
    if (ability instanceof SpellAbility && ((SpellAbility)ability).getSpellAbilityType().equals(SpellAbilityType.SPLIT_FUSED)) {
      if (group.contains(""String_Node_Str"")) {
        result=handleTargetString(group.substring(group.indexOf(""String_Node_Str"") + 9),ability,game);
      }
 else       if (group.startsWith(""String_Node_Str"")) {
        result=handleTargetString(group.substring(group.indexOf(""String_Node_Str"") + 10),ability,game);
      }
 else {
        result=false;
      }
    }
 else {
      result=handleTargetString(group,ability,game);
    }
  }
  return result;
}","@Override public boolean addTargets(Ability ability,Game game){
  if (groupsForTargetHandling == null) {
    return true;
  }
  boolean result=true;
  for (int i=1; i < groupsForTargetHandling.length; i++) {
    String group=groupsForTargetHandling[i];
    if (group.startsWith(""String_Node_Str"") || group.startsWith(""String_Node_Str"") || group.startsWith(""String_Node_Str"")|| group.startsWith(""String_Node_Str"")) {
      break;
    }
    if (ability instanceof SpellAbility && ((SpellAbility)ability).getSpellAbilityType().equals(SpellAbilityType.SPLIT_FUSED)) {
      if (group.contains(""String_Node_Str"")) {
        result=handleTargetString(group.substring(group.indexOf(""String_Node_Str"") + 9),ability,game);
      }
 else       if (group.startsWith(""String_Node_Str"")) {
        result=handleTargetString(group.substring(group.indexOf(""String_Node_Str"") + 10),ability,game);
      }
 else {
        result=false;
      }
    }
 else {
      result=handleTargetString(group,ability,game);
    }
  }
  return result;
}",0.9817483189241114
158118,"private boolean checkExecuteCondition(String[] groups,Game game){
  if (groups[2].startsWith(""String_Node_Str"")) {
    String spellOnStack=groups[2].substring(13);
    for (    StackObject stackObject : game.getStack()) {
      if (stackObject.getStackAbility().toString().contains(spellOnStack)) {
        return true;
      }
    }
    return false;
  }
 else   if (groups[2].startsWith(""String_Node_Str"")) {
    String spellNotOnStack=groups[2].substring(14);
    for (    StackObject stackObject : game.getStack()) {
      if (stackObject.getStackAbility().toString().contains(spellNotOnStack)) {
        return false;
      }
    }
    return true;
  }
 else   if (groups[2].startsWith(""String_Node_Str"")) {
    String spellOnTopOFStack=groups[2].substring(18);
    if (!game.getStack().isEmpty()) {
      StackObject stackObject=game.getStack().getFirst();
      if (stackObject != null && stackObject.getStackAbility().toString().contains(spellOnTopOFStack)) {
        return true;
      }
    }
    return false;
  }
 else   if (groups[2].startsWith(""String_Node_Str"")) {
    String manaInPool=groups[2].substring(11);
    int amountOfMana=Integer.parseInt(manaInPool);
    return computerPlayer.getManaPool().getMana().count() >= amountOfMana;
  }
  return true;
}","private boolean checkExecuteCondition(String[] groups,Game game){
  if (groups[2].startsWith(""String_Node_Str"")) {
    String spellOnStack=groups[2].substring(13);
    for (    StackObject stackObject : game.getStack()) {
      if (stackObject.getStackAbility().toString().contains(spellOnStack)) {
        return true;
      }
    }
    return false;
  }
 else   if (groups[2].startsWith(""String_Node_Str"")) {
    String spellOnStack=groups[2].substring(17);
    for (    StackObject stackObject : game.getStack()) {
      if (stackObject.getStackAbility().toString().contains(spellOnStack)) {
        if (stackObject.isCopy()) {
          return true;
        }
      }
    }
    return false;
  }
 else   if (groups[2].startsWith(""String_Node_Str"")) {
    String spellNotOnStack=groups[2].substring(14);
    for (    StackObject stackObject : game.getStack()) {
      if (stackObject.getStackAbility().toString().contains(spellNotOnStack)) {
        return false;
      }
    }
    return true;
  }
 else   if (groups[2].startsWith(""String_Node_Str"")) {
    String spellOnTopOFStack=groups[2].substring(18);
    if (!game.getStack().isEmpty()) {
      StackObject stackObject=game.getStack().getFirst();
      if (stackObject != null && stackObject.getStackAbility().toString().contains(spellOnTopOFStack)) {
        return true;
      }
    }
    return false;
  }
 else   if (groups[2].startsWith(""String_Node_Str"")) {
    String manaInPool=groups[2].substring(11);
    int amountOfMana=Integer.parseInt(manaInPool);
    return computerPlayer.getManaPool().getMana().count() >= amountOfMana;
  }
  return true;
}",0.7169550173010381
158119,"/** 
 * @param turnNum
 * @param step
 * @param player
 * @param ability
 * @param targetName if not target has to be defined use the constantNO_TARGET
 * @param spellOnStack
 */
public void activateAbility(int turnNum,PhaseStep step,TestPlayer player,String ability,String targetName,String spellOnStack,StackClause clause){
  StringBuilder sb=new StringBuilder(""String_Node_Str"").append(ability);
  if (targetName != null && !targetName.isEmpty()) {
    sb.append(""String_Node_Str"").append(targetName);
  }
  if (spellOnStack != null && !spellOnStack.isEmpty()) {
    sb.append('$').append(StackClause.WHILE_ON_STACK.equals(clause) ? ""String_Node_Str"" : ""String_Node_Str"").append(""String_Node_Str"").append(spellOnStack);
  }
  player.addAction(turnNum,step,sb.toString());
}","/** 
 * @param turnNum
 * @param step
 * @param player
 * @param ability
 * @param targetName if not target has to be defined use the constantNO_TARGET
 * @param spellOnStack
 * @param clause
 */
public void activateAbility(int turnNum,PhaseStep step,TestPlayer player,String ability,String targetName,String spellOnStack,StackClause clause){
  StringBuilder sb=new StringBuilder(""String_Node_Str"").append(ability);
  if (targetName != null && !targetName.isEmpty()) {
    sb.append(""String_Node_Str"").append(targetName);
  }
  if (spellOnStack != null && !spellOnStack.isEmpty()) {
    sb.append('$');
switch (clause) {
case WHILE_ON_STACK:
      sb.append(""String_Node_Str"");
    break;
case WHILE_NOT_ON_STACK:
  sb.append(""String_Node_Str"");
break;
case WHILE_COPY_ON_STACK:
sb.append(""String_Node_Str"");
break;
}
sb.append(spellOnStack);
}
player.addAction(turnNum,step,sb.toString());
}",0.7781774580335732
158120,"@Override public void counter(UUID sourceId,Game game,Zone zone,boolean owner,ZoneDetail zoneDetail){
  this.countered=true;
  if (!isCopiedSpell()) {
    Player player=game.getPlayer(game.getControllerId(sourceId));
    if (player == null) {
      player=game.getPlayer(getControllerId());
    }
    if (player != null) {
      Ability counteringAbility=null;
      MageObject counteringObject=game.getObject(sourceId);
      if (counteringObject instanceof StackObject) {
        counteringAbility=((StackObject)counteringObject).getStackAbility();
      }
      if (zone.equals(Zone.LIBRARY)) {
        if (zoneDetail.equals(ZoneDetail.CHOOSE)) {
          if (player.chooseUse(Outcome.Detriment,""String_Node_Str"",counteringAbility,game)) {
            zoneDetail=ZoneDetail.TOP;
          }
 else {
            zoneDetail=ZoneDetail.BOTTOM;
          }
        }
        if (zoneDetail.equals(ZoneDetail.TOP)) {
          player.putCardsOnTopOfLibrary(new CardsImpl(card),game,counteringAbility,false);
        }
 else {
          player.putCardsOnBottomOfLibrary(new CardsImpl(card),game,counteringAbility,false);
        }
      }
 else {
        player.moveCards(card,zone,counteringAbility,game,false,false,owner,null);
      }
    }
  }
 else {
    card.removeFromZone(game,Zone.STACK,sourceId);
  }
}","@Override public void counter(UUID sourceId,Game game,Zone zone,boolean owner,ZoneDetail zoneDetail){
  this.countered=true;
  if (!isCopiedSpell()) {
    Player player=game.getPlayer(game.getControllerId(sourceId));
    if (player == null) {
      player=game.getPlayer(getControllerId());
    }
    if (player != null) {
      Ability counteringAbility=null;
      MageObject counteringObject=game.getObject(sourceId);
      if (counteringObject instanceof StackObject) {
        counteringAbility=((StackObject)counteringObject).getStackAbility();
      }
      if (zone.equals(Zone.LIBRARY)) {
        if (zoneDetail.equals(ZoneDetail.CHOOSE)) {
          if (player.chooseUse(Outcome.Detriment,""String_Node_Str"",counteringAbility,game)) {
            zoneDetail=ZoneDetail.TOP;
          }
 else {
            zoneDetail=ZoneDetail.BOTTOM;
          }
        }
        if (zoneDetail.equals(ZoneDetail.TOP)) {
          player.putCardsOnTopOfLibrary(new CardsImpl(card),game,counteringAbility,false);
        }
 else {
          player.putCardsOnBottomOfLibrary(new CardsImpl(card),game,counteringAbility,false);
        }
      }
 else {
        player.moveCards(card,zone,counteringAbility,game,false,false,owner,null);
      }
    }
  }
 else {
    game.getStack().remove(this);
  }
}",0.978102189781022
158121,"@Override public boolean apply(Game game,Ability source){
  StackObject stackObject=game.getStack().getStackObject(source.getFirstTarget());
  MageObject sourceObject=game.getObject(source.getSourceId());
  if (stackObject != null && sourceObject != null) {
    Targets targets=new Targets();
    Ability sourceAbility;
    String oldTargetName=null;
    if (stackObject instanceof Spell) {
      Spell spell=(Spell)stackObject;
      sourceAbility=spell.getSpellAbility();
    }
 else     if (stackObject instanceof StackAbility) {
      StackAbility stackAbility=(StackAbility)stackObject;
      sourceAbility=stackAbility;
    }
 else {
      return false;
    }
    for (    UUID modeId : sourceAbility.getModes().getSelectedModes()) {
      Mode mode=sourceAbility.getModes().get(modeId);
      targets.addAll(mode.getTargets());
    }
    boolean twoTimesTarget=false;
    if (targets.size() == 1 && targets.get(0).getTargets().size() == 1) {
      Target target=targets.get(0);
      if (target.getFirstTarget().equals(source.getSourceId())) {
        return true;
      }
      if (target.canTarget(stackObject.getControllerId(),source.getSourceId(),sourceAbility,game)) {
        oldTargetName=getTargetName(targets.getFirstTarget(),game);
        target.clearChosen();
        target.addTarget(source.getSourceId(),stackObject.getStackAbility(),game);
      }
    }
 else {
      Player controller=game.getPlayer(source.getControllerId());
      boolean validTargets=false;
      do {
        for (        Target target : targets) {
          for (          UUID targetId : target.getTargets()) {
            String name=getTargetName(targetId,game);
            if (targetId.equals(source.getSourceId()) || target.getTargets().contains(source.getSourceId())) {
              twoTimesTarget=true;
              continue;
            }
            if (target.canTarget(stackObject.getControllerId(),source.getSourceId(),sourceAbility,game) && !twoTimesTarget) {
              validTargets=true;
              if (name != null && controller.chooseUse(Outcome.Neutral,""String_Node_Str"" + name + ""String_Node_Str""+ sourceObject.getLogName()+ '?',source,game)) {
                oldTargetName=getTargetName(targetId,game);
                int damageAmount=target.getTargetAmount(targetId);
                target.remove(targetId);
                target.addTarget(source.getSourceId(),stackObject.getStackAbility(),game);
                target.setTargetAmount(source.getSourceId(),damageAmount,game);
                break;
              }
            }
          }
          if (oldTargetName != null) {
            break;
          }
        }
        if (oldTargetName == null) {
          game.informPlayer(controller,""String_Node_Str"" + sourceObject.getIdName() + '!');
        }
      }
 while (validTargets && oldTargetName == null);
    }
    if (oldTargetName != null) {
      game.informPlayers(sourceObject.getLogName() + ""String_Node_Str"" + stackObject.getLogName()+ ""String_Node_Str""+ oldTargetName+ ""String_Node_Str""+ sourceObject.getLogName());
    }
 else     if (twoTimesTarget) {
      game.informPlayers(sourceObject.getLogName() + ""String_Node_Str"" + sourceObject.getLogName()+ ""String_Node_Str""+ stackObject.getLogName());
    }
 else {
      game.informPlayers(sourceObject.getLogName() + ""String_Node_Str"" + sourceObject.getLogName()+ ""String_Node_Str""+ stackObject.getLogName());
    }
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  StackObject stackObject=game.getStack().getStackObject(source.getFirstTarget());
  MageObject sourceObject=game.getObject(source.getSourceId());
  if (stackObject != null && sourceObject != null) {
    Targets targets=new Targets();
    Ability sourceAbility;
    String oldTargetName=null;
    if (stackObject instanceof Spell) {
      Spell spell=(Spell)stackObject;
      sourceAbility=spell.getSpellAbility();
    }
 else     if (stackObject instanceof StackAbility) {
      StackAbility stackAbility=(StackAbility)stackObject;
      sourceAbility=stackAbility;
    }
 else {
      return false;
    }
    for (    UUID modeId : sourceAbility.getModes().getSelectedModes()) {
      Mode mode=sourceAbility.getModes().get(modeId);
      targets.addAll(mode.getTargets());
    }
    boolean twoTimesTarget=false;
    if (targets.size() == 1 && targets.get(0).getTargets().size() == 1) {
      Target target=targets.get(0);
      if (target.getFirstTarget().equals(source.getSourceId())) {
        return true;
      }
      if (target.canTarget(stackObject.getControllerId(),source.getSourceId(),sourceAbility,game)) {
        oldTargetName=getTargetName(targets.getFirstTarget(),game);
        target.clearChosen();
        target.addTarget(source.getSourceId(),stackObject.getStackAbility(),game);
      }
    }
 else {
      Player controller=game.getPlayer(source.getControllerId());
      boolean validTargets=false;
      do {
        for (        Target target : targets) {
          if (target.getTargets().contains(source.getSourceId())) {
            continue;
          }
          for (          UUID targetId : target.getTargets()) {
            String name=getTargetName(targetId,game);
            if (target.canTarget(stackObject.getControllerId(),source.getSourceId(),sourceAbility,game)) {
              validTargets=true;
              if (name != null && controller.chooseUse(Outcome.Neutral,""String_Node_Str"" + name + ""String_Node_Str""+ sourceObject.getLogName()+ '?',source,game)) {
                oldTargetName=getTargetName(targetId,game);
                int damageAmount=target.getTargetAmount(targetId);
                target.remove(targetId);
                target.addTarget(source.getSourceId(),stackObject.getStackAbility(),game);
                target.setTargetAmount(source.getSourceId(),damageAmount,game);
                break;
              }
            }
          }
          if (oldTargetName != null) {
            break;
          }
        }
        if (oldTargetName == null) {
          game.informPlayer(controller,""String_Node_Str"" + sourceObject.getIdName() + '!');
        }
      }
 while (validTargets && oldTargetName == null);
    }
    if (oldTargetName != null) {
      game.informPlayers(sourceObject.getLogName() + ""String_Node_Str"" + stackObject.getLogName()+ ""String_Node_Str""+ oldTargetName+ ""String_Node_Str""+ sourceObject.getLogName());
    }
 else     if (twoTimesTarget) {
      game.informPlayers(sourceObject.getLogName() + ""String_Node_Str"" + sourceObject.getLogName()+ ""String_Node_Str""+ stackObject.getLogName());
    }
 else {
      game.informPlayers(sourceObject.getLogName() + ""String_Node_Str"" + sourceObject.getLogName()+ ""String_Node_Str""+ stackObject.getLogName());
    }
    return true;
  }
  return false;
}",0.9551931834875864
158122,"@Override public int chooseReplacementEffect(Map<String,String> rEffects,Game game){
  updateGameStatePriority(""String_Node_Str"",game);
  if (rEffects.size() == 1) {
    return 0;
  }
  if (!autoSelectReplacementEffects.isEmpty()) {
    for (    String autoKey : autoSelectReplacementEffects) {
      int count=0;
      for (      String effectKey : rEffects.keySet()) {
        if (effectKey.equals(autoKey)) {
          return count;
        }
        count++;
      }
    }
  }
  replacementEffectChoice.getChoices().clear();
  replacementEffectChoice.setKeyChoices(rEffects);
  while (!abort) {
    game.fireChooseChoiceEvent(playerId,replacementEffectChoice);
    waitForResponse(game);
    logger.debug(""String_Node_Str"" + response.getString());
    if (response.getString() != null) {
      if (response.getString().startsWith(""String_Node_Str"")) {
        autoSelectReplacementEffects.add(response.getString().substring(1));
        replacementEffectChoice.setChoiceByKey(response.getString().substring(1));
      }
 else {
        replacementEffectChoice.setChoiceByKey(response.getString());
      }
      if (replacementEffectChoice.getChoiceKey() != null) {
        int index=0;
        for (        String key : rEffects.keySet()) {
          if (replacementEffectChoice.getChoiceKey().equals(key)) {
            return index;
          }
          index++;
        }
      }
    }
  }
  return 0;
}","@Override public int chooseReplacementEffect(Map<String,String> rEffects,Game game){
  updateGameStatePriority(""String_Node_Str"",game);
  if (rEffects.size() <= 1) {
    return 0;
  }
  if (!autoSelectReplacementEffects.isEmpty()) {
    for (    String autoKey : autoSelectReplacementEffects) {
      int count=0;
      for (      String effectKey : rEffects.keySet()) {
        if (effectKey.equals(autoKey)) {
          return count;
        }
        count++;
      }
    }
  }
  replacementEffectChoice.getChoices().clear();
  replacementEffectChoice.setKeyChoices(rEffects);
  while (!abort) {
    game.fireChooseChoiceEvent(playerId,replacementEffectChoice);
    waitForResponse(game);
    logger.debug(""String_Node_Str"" + response.getString());
    if (response.getString() != null) {
      if (response.getString().startsWith(""String_Node_Str"")) {
        autoSelectReplacementEffects.add(response.getString().substring(1));
        replacementEffectChoice.setChoiceByKey(response.getString().substring(1));
      }
 else {
        replacementEffectChoice.setChoiceByKey(response.getString());
      }
      if (replacementEffectChoice.getChoiceKey() != null) {
        int index=0;
        for (        String key : rEffects.keySet()) {
          if (replacementEffectChoice.getChoiceKey().equals(key)) {
            return index;
          }
          index++;
        }
      }
    }
  }
  return 0;
}",0.9992917847025496
158123,"public FirstSpellCastThisTurnWatcher(final FirstSpellCastThisTurnWatcher watcher){
  super(watcher);
  playerFirstSpellCast.putAll(watcher.playerFirstSpellCast);
  playerFirstCastSpell.putAll(watcher.playerFirstSpellCast);
}","public FirstSpellCastThisTurnWatcher(final FirstSpellCastThisTurnWatcher watcher){
  super(watcher);
  playerFirstSpellCast.putAll(watcher.playerFirstSpellCast);
  playerFirstCastSpell.putAll(watcher.playerFirstCastSpell);
}",0.9598214285714286
158124,"@Override public ViewFactory getViewFactory(){
  return new HTMLFactory(){
    @Override public View create(    Element elem){
      Object o=elem.getAttributes().getAttribute(StyleConstants.NameAttribute);
      if (o instanceof HTML.Tag) {
        HTML.Tag kind=(HTML.Tag)o;
        if (kind == HTML.Tag.IMG) {
          return new ImageView(elem){
            @Override public URL getImageURL(){
              URL url=super.getImageURL();
              URI uri=null;
              try {
                uri=url.toURI();
              }
 catch (              URISyntaxException ex) {
              }
              if (uri != null && imageCache.get(uri) == null) {
                imageCache.put(uri,Toolkit.getDefaultToolkit().createImage(url));
              }
              return url;
            }
          }
;
        }
      }
      return super.create(elem);
    }
  }
;
}","@Override public ViewFactory getViewFactory(){
  return new HTMLFactory(){
    @Override public View create(    Element elem){
      Object o=elem.getAttributes().getAttribute(StyleConstants.NameAttribute);
      if (o instanceof HTML.Tag) {
        HTML.Tag kind=(HTML.Tag)o;
        if (Objects.equals(kind,HTML.Tag.IMG)) {
          return new ImageView(elem){
            @Override public URL getImageURL(){
              URL url=super.getImageURL();
              URI uri=null;
              try {
                uri=url.toURI();
              }
 catch (              URISyntaxException ex) {
              }
              if (uri != null && imageCache.get(uri) == null) {
                imageCache.put(uri,Toolkit.getDefaultToolkit().createImage(url));
              }
              return url;
            }
          }
;
        }
      }
      return super.create(elem);
    }
  }
;
}",0.988182329769274
158125,"public static void setHTMLEditorKit(JEditorPane editorPane){
  editorPane.getDocument().putProperty(""String_Node_Str"",imageCache);
  editorPane.setEditorKit(new HTMLEditorKit(){
    private static final long serialVersionUID=-54602188235105448L;
    @Override public ViewFactory getViewFactory(){
      return new HTMLFactory(){
        @Override public View create(        Element elem){
          Object o=elem.getAttributes().getAttribute(StyleConstants.NameAttribute);
          if (o instanceof HTML.Tag) {
            HTML.Tag kind=(HTML.Tag)o;
            if (kind == HTML.Tag.IMG) {
              return new ImageView(elem){
                @Override public URL getImageURL(){
                  URL url=super.getImageURL();
                  URI uri=null;
                  try {
                    uri=url.toURI();
                  }
 catch (                  URISyntaxException ex) {
                  }
                  if (uri != null && imageCache.get(uri) == null) {
                    imageCache.put(uri,Toolkit.getDefaultToolkit().createImage(url));
                  }
                  return url;
                }
              }
;
            }
          }
          return super.create(elem);
        }
      }
;
    }
  }
);
}","public static void setHTMLEditorKit(JEditorPane editorPane){
  editorPane.getDocument().putProperty(""String_Node_Str"",imageCache);
  editorPane.setEditorKit(new HTMLEditorKit(){
    private static final long serialVersionUID=-54602188235105448L;
    @Override public ViewFactory getViewFactory(){
      return new HTMLFactory(){
        @Override public View create(        Element elem){
          Object o=elem.getAttributes().getAttribute(StyleConstants.NameAttribute);
          if (o instanceof HTML.Tag) {
            HTML.Tag kind=(HTML.Tag)o;
            if (Objects.equals(kind,HTML.Tag.IMG)) {
              return new ImageView(elem){
                @Override public URL getImageURL(){
                  URL url=super.getImageURL();
                  URI uri=null;
                  try {
                    uri=url.toURI();
                  }
 catch (                  URISyntaxException ex) {
                  }
                  if (uri != null && imageCache.get(uri) == null) {
                    imageCache.put(uri,Toolkit.getDefaultToolkit().createImage(url));
                  }
                  return url;
                }
              }
;
            }
          }
          return super.create(elem);
        }
      }
;
    }
  }
);
}",0.9916633584755856
158126,"@Override public View create(Element elem){
  Object o=elem.getAttributes().getAttribute(StyleConstants.NameAttribute);
  if (o instanceof HTML.Tag) {
    HTML.Tag kind=(HTML.Tag)o;
    if (kind == HTML.Tag.IMG) {
      return new ImageView(elem){
        @Override public URL getImageURL(){
          URL url=super.getImageURL();
          URI uri=null;
          try {
            uri=url.toURI();
          }
 catch (          URISyntaxException ex) {
          }
          if (uri != null && imageCache.get(uri) == null) {
            imageCache.put(uri,Toolkit.getDefaultToolkit().createImage(url));
          }
          return url;
        }
      }
;
    }
  }
  return super.create(elem);
}","@Override public View create(Element elem){
  Object o=elem.getAttributes().getAttribute(StyleConstants.NameAttribute);
  if (o instanceof HTML.Tag) {
    HTML.Tag kind=(HTML.Tag)o;
    if (Objects.equals(kind,HTML.Tag.IMG)) {
      return new ImageView(elem){
        @Override public URL getImageURL(){
          URL url=super.getImageURL();
          URI uri=null;
          try {
            uri=url.toURI();
          }
 catch (          URISyntaxException ex) {
          }
          if (uri != null && imageCache.get(uri) == null) {
            imageCache.put(uri,Toolkit.getDefaultToolkit().createImage(url));
          }
          return url;
        }
      }
;
    }
  }
  return super.create(elem);
}",0.9851169383416016
158127,"private static List<CardDownloadData> getNeededCards(List<CardInfo> allCards){
  HashSet<String> ignoreUrls=SettingsManager.getIntance().getIgnoreUrls();
  Set<String> type2SetsFilter=new HashSet<>();
  List<String> constructedFormats=ConstructedFormats.getSetsByFormat(ConstructedFormats.STANDARD);
  if (constructedFormats != null && !constructedFormats.isEmpty()) {
    type2SetsFilter.addAll(constructedFormats);
  }
 else {
    logger.warn(""String_Node_Str"");
  }
  int numberCardImages=allCards.size();
  int numberWithoutTokens=0;
  List<CardDownloadData> allCardsUrls=Collections.synchronizedList(new ArrayList<>());
  try {
    offlineMode=true;
    allCards.parallelStream().forEach(card -> {
      if (!card.getCardNumber().isEmpty() && !""String_Node_Str"".equals(card.getCardNumber()) && !card.getSetCode().isEmpty()&& !ignoreUrls.contains(card.getSetCode())) {
        String cardName=card.getName();
        boolean isType2=type2SetsFilter.contains(card.getSetCode());
        CardDownloadData url=new CardDownloadData(cardName,card.getSetCode(),card.getCardNumber(),card.usesVariousArt(),0,""String_Node_Str"",""String_Node_Str"",false,card.isDoubleFaced(),card.isNightCard());
        if (url.getUsesVariousArt()) {
          url.setDownloadName(createDownloadName(card));
        }
        url.setFlipCard(card.isFlipCard());
        url.setSplitCard(card.isSplitCard());
        url.setType2(isType2);
        allCardsUrls.add(url);
        if (card.isDoubleFaced()) {
          if (card.getSecondSideName() == null || card.getSecondSideName().trim().isEmpty()) {
            throw new IllegalStateException(""String_Node_Str"");
          }
          url=new CardDownloadData(card.getSecondSideName(),card.getSetCode(),card.getCardNumber(),card.usesVariousArt(),0,""String_Node_Str"",""String_Node_Str"",false,card.isDoubleFaced(),true);
          url.setType2(isType2);
          allCardsUrls.add(url);
        }
        if (card.isFlipCard()) {
          if (card.getFlipCardName() == null || card.getFlipCardName().trim().isEmpty()) {
            throw new IllegalStateException(""String_Node_Str"");
          }
          CardDownloadData cardDownloadData=new CardDownloadData(card.getFlipCardName(),card.getSetCode(),card.getCardNumber(),card.usesVariousArt(),0,""String_Node_Str"",""String_Node_Str"",false,card.isDoubleFaced(),card.isNightCard());
          cardDownloadData.setFlipCard(true);
          cardDownloadData.setFlippedSide(true);
          cardDownloadData.setType2(isType2);
          allCardsUrls.add(cardDownloadData);
        }
      }
 else       if (card.getCardNumber().isEmpty() || ""String_Node_Str"".equals(card.getCardNumber())) {
        System.err.println(""String_Node_Str"");
        logger.error(""String_Node_Str"" + card);
      }
 else       if (card.getSetCode().isEmpty()) {
        System.err.println(""String_Node_Str"");
        logger.error(""String_Node_Str"" + card);
      }
    }
);
    numberWithoutTokens=allCards.size();
    allCardsUrls.addAll(getTokenCardUrls());
  }
 catch (  Exception e) {
    logger.error(e);
  }
  int numberAllTokenImages=allCardsUrls.size() - numberWithoutTokens;
  List<CardDownloadData> cardsToDownload=Collections.synchronizedList(new ArrayList<>());
  allCardsUrls.parallelStream().forEach(card -> {
    TFile file=new TFile(CardImageUtils.generateImagePath(card));
    if (!file.exists()) {
      logger.debug(""String_Node_Str"" + file.getAbsolutePath());
      cardsToDownload.add(card);
    }
  }
);
  int tokenImages=0;
  for (  CardDownloadData card : cardsToDownload) {
    logger.debug((card.isToken() ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"" + card.getName()+ ""String_Node_Str""+ card.getSet()+ ')');
    if (card.isToken()) {
      tokenImages++;
    }
  }
  logger.info(""String_Node_Str"" + numberCardImages + ""String_Node_Str""+ numberAllTokenImages+ ')');
  logger.info(""String_Node_Str"" + (cardsToDownload.size() - tokenImages));
  logger.info(""String_Node_Str"" + tokenImages);
  return new ArrayList<>(cardsToDownload);
}","private static List<CardDownloadData> getNeededCards(List<CardInfo> allCards){
  HashSet<String> ignoreUrls=SettingsManager.getIntance().getIgnoreUrls();
  Set<String> type2SetsFilter=new HashSet<>();
  List<String> constructedFormats=ConstructedFormats.getSetsByFormat(ConstructedFormats.STANDARD);
  if (constructedFormats != null && !constructedFormats.isEmpty()) {
    type2SetsFilter.addAll(constructedFormats);
  }
 else {
    logger.warn(""String_Node_Str"");
  }
  int numberCardImages=allCards.size();
  int numberWithoutTokens=0;
  List<CardDownloadData> allCardsUrls=Collections.synchronizedList(new ArrayList<>());
  try {
    offlineMode=true;
    allCards.parallelStream().forEach(card -> {
      if (!card.getCardNumber().isEmpty() && !""String_Node_Str"".equals(card.getCardNumber()) && !card.getSetCode().isEmpty()&& !ignoreUrls.contains(card.getSetCode())) {
        String cardName=card.getName();
        boolean isType2=type2SetsFilter.contains(card.getSetCode());
        CardDownloadData url=new CardDownloadData(cardName,card.getSetCode(),card.getCardNumber(),card.usesVariousArt(),0,""String_Node_Str"",""String_Node_Str"",false,card.isDoubleFaced(),card.isNightCard());
        if (url.getUsesVariousArt()) {
          url.setDownloadName(createDownloadName(card));
        }
        url.setFlipCard(card.isFlipCard());
        url.setSplitCard(card.isSplitCard());
        url.setType2(isType2);
        allCardsUrls.add(url);
        if (card.isDoubleFaced()) {
          if (card.getSecondSideName() == null || card.getSecondSideName().trim().isEmpty()) {
            throw new IllegalStateException(""String_Node_Str"");
          }
          url=new CardDownloadData(card.getSecondSideName(),card.getSetCode(),card.getCardNumber(),card.usesVariousArt(),0,""String_Node_Str"",""String_Node_Str"",false,card.isDoubleFaced(),true);
          url.setType2(isType2);
          allCardsUrls.add(url);
        }
        if (card.isFlipCard()) {
          if (card.getFlipCardName() == null || card.getFlipCardName().trim().isEmpty()) {
            throw new IllegalStateException(""String_Node_Str"");
          }
          CardDownloadData cardDownloadData=new CardDownloadData(card.getFlipCardName(),card.getSetCode(),card.getCardNumber(),card.usesVariousArt(),0,""String_Node_Str"",""String_Node_Str"",false,card.isDoubleFaced(),card.isNightCard());
          cardDownloadData.setFlipCard(true);
          cardDownloadData.setFlippedSide(true);
          cardDownloadData.setType2(isType2);
          allCardsUrls.add(cardDownloadData);
        }
      }
 else       if (card.getCardNumber().isEmpty() || ""String_Node_Str"".equals(card.getCardNumber())) {
        System.err.println(""String_Node_Str"");
        logger.error(""String_Node_Str"" + card.getName());
      }
 else       if (card.getSetCode().isEmpty()) {
        System.err.println(""String_Node_Str"");
        logger.error(""String_Node_Str"" + card.getName());
      }
    }
);
    numberWithoutTokens=allCards.size();
    allCardsUrls.addAll(getTokenCardUrls());
  }
 catch (  Exception e) {
    logger.error(e);
  }
  int numberAllTokenImages=allCardsUrls.size() - numberWithoutTokens;
  List<CardDownloadData> cardsToDownload=Collections.synchronizedList(new ArrayList<>());
  allCardsUrls.parallelStream().forEach(card -> {
    TFile file=new TFile(CardImageUtils.generateImagePath(card));
    if (!file.exists()) {
      logger.debug(""String_Node_Str"" + file.getAbsolutePath());
      cardsToDownload.add(card);
    }
  }
);
  int tokenImages=0;
  for (  CardDownloadData card : cardsToDownload) {
    logger.debug((card.isToken() ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"" + card.getName()+ ""String_Node_Str""+ card.getSet()+ ')');
    if (card.isToken()) {
      tokenImages++;
    }
  }
  logger.info(""String_Node_Str"" + numberCardImages + ""String_Node_Str""+ numberAllTokenImages+ ')');
  logger.info(""String_Node_Str"" + (cardsToDownload.size() - tokenImages));
  logger.info(""String_Node_Str"" + tokenImages);
  return new ArrayList<>(cardsToDownload);
}",0.9975216852540272
158128,"private boolean checkPassStep(Game game,HumanPlayer controllingPlayer){
  try {
    if (playerId.equals(game.getActivePlayerId())) {
      return !controllingPlayer.getUserData().getUserSkipPrioritySteps().getYourTurn().isPhaseStepSet(game.getStep().getType());
    }
 else {
      return !controllingPlayer.getUserData().getUserSkipPrioritySteps().getOpponentTurn().isPhaseStepSet(game.getStep().getType());
    }
  }
 catch (  NullPointerException ex) {
    logger.error(""String_Node_Str"" + userData == null ? ""String_Node_Str"" : ""String_Node_Str"");
  }
  return true;
}","private boolean checkPassStep(Game game,HumanPlayer controllingPlayer){
  try {
    if (playerId.equals(game.getActivePlayerId())) {
      return !controllingPlayer.getUserData().getUserSkipPrioritySteps().getYourTurn().isPhaseStepSet(game.getStep().getType());
    }
 else {
      return !controllingPlayer.getUserData().getUserSkipPrioritySteps().getOpponentTurn().isPhaseStepSet(game.getStep().getType());
    }
  }
 catch (  NullPointerException ex) {
    String isNull=userData == null ? ""String_Node_Str"" : ""String_Node_Str"";
    logger.error(""String_Node_Str"" + isNull);
  }
  return true;
}",0.9162393162393162
158129,"private static MatchType loadGameType(GamePlugin plugin){
  try {
    classLoader.addURL(new File(pluginFolder,plugin.getJar()).toURI().toURL());
    logger.debug(""String_Node_Str"" + plugin.getClassName());
    return (MatchType)Class.forName(plugin.getTypeName(),true,classLoader).newInstance();
  }
 catch (  ClassNotFoundException ex) {
    logger.warn(""String_Node_Str"" + plugin.getJar() + ""String_Node_Str"",ex);
  }
catch (  Exception ex) {
    logger.fatal(""String_Node_Str"" + plugin.getJar(),ex);
  }
  return null;
}","private static MatchType loadGameType(GamePlugin plugin){
  try {
    classLoader.addURL(new File(pluginFolder,plugin.getJar()).toURI().toURL());
    logger.debug(""String_Node_Str"" + plugin.getClassName());
    return (MatchType)Class.forName(plugin.getTypeName(),true,classLoader).getConstructor().newInstance();
  }
 catch (  ClassNotFoundException ex) {
    logger.warn(""String_Node_Str"" + plugin.getJar() + ""String_Node_Str"",ex);
  }
catch (  Exception ex) {
    logger.fatal(""String_Node_Str"" + plugin.getJar(),ex);
  }
  return null;
}",0.984037558685446
158130,"private static TournamentType loadTournamentType(GamePlugin plugin){
  try {
    classLoader.addURL(new File(pluginFolder,plugin.getJar()).toURI().toURL());
    logger.debug(""String_Node_Str"" + plugin.getClassName());
    return (TournamentType)Class.forName(plugin.getTypeName(),true,classLoader).newInstance();
  }
 catch (  ClassNotFoundException ex) {
    logger.warn(""String_Node_Str"" + plugin.getName() + ""String_Node_Str""+ plugin.getJar()+ ""String_Node_Str"",ex);
  }
catch (  Exception ex) {
    logger.fatal(""String_Node_Str"" + plugin.getJar(),ex);
  }
  return null;
}","private static TournamentType loadTournamentType(GamePlugin plugin){
  try {
    classLoader.addURL(new File(pluginFolder,plugin.getJar()).toURI().toURL());
    logger.debug(""String_Node_Str"" + plugin.getClassName());
    return (TournamentType)Class.forName(plugin.getTypeName(),true,classLoader).getConstructor().newInstance();
  }
 catch (  ClassNotFoundException ex) {
    logger.warn(""String_Node_Str"" + plugin.getName() + ""String_Node_Str""+ plugin.getJar()+ ""String_Node_Str"",ex);
  }
catch (  Exception ex) {
    logger.fatal(""String_Node_Str"" + plugin.getJar(),ex);
  }
  return null;
}",0.9854824935952178
158131,"@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  MageObject mageObject=game.getObject(source.getSourceId());
  if (controller != null) {
    Set<Card> topCards=controller.getLibrary().getTopCards(game,5);
    Cards cardsFromLibrary=new CardsImpl();
    for (    Card card : topCards) {
      cardsFromLibrary.add(card);
    }
    controller.lookAtCards(mageObject.getIdName(),cardsFromLibrary,game);
    int max=0;
    for (    UUID playerId : game.getState().getPlayersInRange(controller.getId(),game)) {
      FilterCreaturePermanent filter=new FilterCreaturePermanent();
      filter.add(new ControllerIdPredicate(playerId));
      if (playerId != controller.getId()) {
        if (max < game.getBattlefield().countAll(filter,playerId,game)) {
          max=game.getBattlefield().countAll(filter,playerId,game);
        }
      }
    }
    boolean moreCreatures=game.getBattlefield().countAll(new FilterControlledCreaturePermanent(),controller.getId(),game) > max;
    TargetCard target=new TargetCard(moreCreatures ? 2 : 1,Zone.LIBRARY,new FilterCard());
    if (controller.choose(Outcome.DrawCard,cardsFromLibrary,target,game)) {
      cardsFromLibrary.removeAll(target.getTargets());
      controller.moveCards(new CardsImpl(target.getTargets()),Zone.HAND,source,game);
    }
    controller.putCardsOnBottomOfLibrary(cardsFromLibrary,game,source,true);
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  MageObject mageObject=game.getObject(source.getSourceId());
  if (controller != null) {
    Set<Card> topCards=controller.getLibrary().getTopCards(game,5);
    Cards cardsFromLibrary=new CardsImpl();
    for (    Card card : topCards) {
      cardsFromLibrary.add(card);
    }
    controller.lookAtCards(mageObject.getIdName(),cardsFromLibrary,game);
    int max=0;
    for (    UUID playerId : game.getState().getPlayersInRange(controller.getId(),game)) {
      FilterCreaturePermanent filter=new FilterCreaturePermanent();
      filter.add(new ControllerIdPredicate(playerId));
      if (!Objects.equals(playerId,controller.getId())) {
        if (max < game.getBattlefield().countAll(filter,playerId,game)) {
          max=game.getBattlefield().countAll(filter,playerId,game);
        }
      }
    }
    boolean moreCreatures=game.getBattlefield().countAll(new FilterControlledCreaturePermanent(),controller.getId(),game) > max;
    TargetCard target=new TargetCard(moreCreatures ? 2 : 1,Zone.LIBRARY,new FilterCard());
    if (controller.choose(Outcome.DrawCard,cardsFromLibrary,target,game)) {
      cardsFromLibrary.removeAll(target.getTargets());
      controller.moveCards(new CardsImpl(target.getTargets()),Zone.HAND,source,game);
    }
    controller.putCardsOnBottomOfLibrary(cardsFromLibrary,game,source,true);
    return true;
  }
  return false;
}",0.981042654028436
158132,"@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller != null) {
    Cards revealedCards=new CardsImpl();
    for (    UUID playerId : game.getState().getPlayersInRange(controller.getId(),game)) {
      if (playerId != controller.getId()) {
        Player opponent=game.getPlayer(playerId);
        if (opponent != null) {
          Cards cards=new CardsImpl(opponent.getHand());
          opponent.revealCards(opponent.getName() + ""String_Node_Str"",cards,game);
          revealedCards.addAll(cards);
        }
      }
    }
    TargetCard target=new TargetCard(Zone.HAND,new FilterNonlandCard(""String_Node_Str""));
    controller.chooseTarget(Outcome.Benefit,revealedCards,target,source,game);
    Card card=game.getCard(target.getFirstTarget());
    if (card != null) {
      game.informPlayers(""String_Node_Str"" + GameLog.getColoredObjectName(card) + ']');
      Permanent sourcePermanent=game.getPermanent(source.getSourceId());
      if (sourcePermanent != null) {
        sourcePermanent.addInfo(""String_Node_Str"",CardUtil.addToolTipMarkTags(""String_Node_Str"" + card.getName()),game);
      }
      game.addEffect(new AlhammarretHighArbiterCantCastEffect(card.getName()),source);
    }
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller != null) {
    Cards revealedCards=new CardsImpl();
    for (    UUID playerId : game.getState().getPlayersInRange(controller.getId(),game)) {
      if (!Objects.equals(playerId,controller.getId())) {
        Player opponent=game.getPlayer(playerId);
        if (opponent != null) {
          Cards cards=new CardsImpl(opponent.getHand());
          opponent.revealCards(opponent.getName() + ""String_Node_Str"",cards,game);
          revealedCards.addAll(cards);
        }
      }
    }
    TargetCard target=new TargetCard(Zone.HAND,new FilterNonlandCard(""String_Node_Str""));
    controller.chooseTarget(Outcome.Benefit,revealedCards,target,source,game);
    Card card=game.getCard(target.getFirstTarget());
    if (card != null) {
      game.informPlayers(""String_Node_Str"" + GameLog.getColoredObjectName(card) + ']');
      Permanent sourcePermanent=game.getPermanent(source.getSourceId());
      if (sourcePermanent != null) {
        sourcePermanent.addInfo(""String_Node_Str"",CardUtil.addToolTipMarkTags(""String_Node_Str"" + card.getName()),game);
      }
      game.addEffect(new AlhammarretHighArbiterCantCastEffect(card.getName()),source);
    }
    return true;
  }
  return false;
}",0.9916666666666668
158133,"@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller != null) {
    int xSum=0;
    xSum+=playerPaysXGenericMana(controller,source,game);
    for (    UUID playerId : game.getState().getPlayersInRange(controller.getId(),game)) {
      if (playerId != controller.getId()) {
        Player player=game.getPlayer(playerId);
        if (player != null) {
          xSum+=playerPaysXGenericMana(player,source,game);
        }
      }
    }
    if (xSum > 0) {
      for (      UUID playerId : game.getState().getPlayersInRange(controller.getId(),game)) {
        Effect effect=new CreateTokenTargetEffect(new SoldierToken(),xSum);
        effect.setTargetPointer(new FixedTarget(playerId));
        effect.apply(game,source);
      }
    }
    controller.resetStoredBookmark(game);
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller != null) {
    int xSum=0;
    xSum+=playerPaysXGenericMana(controller,source,game);
    for (    UUID playerId : game.getState().getPlayersInRange(controller.getId(),game)) {
      if (!Objects.equals(playerId,controller.getId())) {
        Player player=game.getPlayer(playerId);
        if (player != null) {
          xSum+=playerPaysXGenericMana(player,source,game);
        }
      }
    }
    if (xSum > 0) {
      for (      UUID playerId : game.getState().getPlayersInRange(controller.getId(),game)) {
        Effect effect=new CreateTokenTargetEffect(new SoldierToken(),xSum);
        effect.setTargetPointer(new FixedTarget(playerId));
        effect.apply(game,source);
      }
    }
    controller.resetStoredBookmark(game);
    return true;
  }
  return false;
}",0.9613686534216336
158134,"@Override public boolean checkTrigger(GameEvent event,Game game){
  Permanent blocker=game.getPermanent(event.getSourceId());
  Permanent blocked=game.getPermanent(event.getTargetId());
  Permanent arrogantBloodlord=game.getPermanent(sourceId);
  if (blocker != null && blocker != arrogantBloodlord && blocker.getPower().getValue() < 2 && blocked == arrogantBloodlord) {
    return true;
  }
  if (blocker != null && blocker == arrogantBloodlord && game.getPermanent(event.getTargetId()).getPower().getValue() < 2) {
    return true;
  }
  return false;
}","@Override public boolean checkTrigger(GameEvent event,Game game){
  Permanent blocker=game.getPermanent(event.getSourceId());
  Permanent blocked=game.getPermanent(event.getTargetId());
  Permanent arrogantBloodlord=game.getPermanent(sourceId);
  if (blocker != null && !Objects.equals(blocker,arrogantBloodlord) && blocker.getPower().getValue() < 2 && Objects.equals(blocked,arrogantBloodlord)) {
    return true;
  }
  if (blocker != null && Objects.equals(blocker,arrogantBloodlord) && game.getPermanent(event.getTargetId()).getPower().getValue() < 2) {
    return true;
  }
  return false;
}",0.6191304347826087
158135,"@Override public boolean checkTrigger(GameEvent event,Game game){
  Permanent permanent=game.getPermanent(getSourceId());
  if (permanent != null && permanent.isAttacking()) {
    UUID sourceDefenderId=game.getCombat().getDefenderId(permanent.getId());
    Player attackedPlayer=game.getPlayer(sourceDefenderId);
    if (attackedPlayer != null) {
      for (      UUID attacker : game.getCombat().getAttackers()) {
        if (attacker != permanent.getId()) {
          UUID defenderId=game.getCombat().getDefenderId(attacker);
          Player attackedPlayer2=game.getPlayer(defenderId);
          if (attackedPlayer2 != null && attackedPlayer.getId().equals(attackedPlayer2.getId())) {
            return true;
          }
        }
      }
    }
  }
  return false;
}","@Override public boolean checkTrigger(GameEvent event,Game game){
  Permanent permanent=game.getPermanent(getSourceId());
  if (permanent != null && permanent.isAttacking()) {
    UUID sourceDefenderId=game.getCombat().getDefenderId(permanent.getId());
    Player attackedPlayer=game.getPlayer(sourceDefenderId);
    if (attackedPlayer != null) {
      for (      UUID attacker : game.getCombat().getAttackers()) {
        if (!Objects.equals(attacker,permanent.getId())) {
          UUID defenderId=game.getCombat().getDefenderId(attacker);
          Player attackedPlayer2=game.getPlayer(defenderId);
          if (attackedPlayer2 != null && attackedPlayer.getId().equals(attackedPlayer2.getId())) {
            return true;
          }
        }
      }
    }
  }
  return false;
}",0.7451737451737451
158136,"@Override public boolean checkTrigger(GameEvent event,Game game){
  Permanent land=game.getPermanent(event.getTargetId());
  return land.getCardType().contains(CardType.LAND) && land.getControllerId().equals(this.controllerId) && event.getTargetId() != this.getSourceId();
}","@Override public boolean checkTrigger(GameEvent event,Game game){
  Permanent land=game.getPermanent(event.getTargetId());
  return land.getCardType().contains(CardType.LAND) && land.getControllerId().equals(this.controllerId) && !Objects.equals(event.getTargetId(),this.getSourceId());
}",0.896797153024911
158137,"@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller != null) {
    int xSum=0;
    xSum+=playerPaysXGenericMana(controller,source,game);
    for (    UUID playerId : game.getState().getPlayersInRange(controller.getId(),game)) {
      if (playerId != controller.getId()) {
        Player player=game.getPlayer(playerId);
        if (player != null) {
          xSum+=playerPaysXGenericMana(player,source,game);
        }
      }
    }
    for (    UUID playerId : game.getState().getPlayersInRange(controller.getId(),game)) {
      Player player=game.getPlayer(playerId);
      if (player != null) {
        TargetCardInLibrary target=new TargetCardInLibrary(0,xSum,new FilterBasicLandCard());
        if (player.searchLibrary(target,game)) {
          for (          UUID cardId : target.getTargets()) {
            Card card=player.getLibrary().getCard(cardId,game);
            if (card != null) {
              card.putOntoBattlefield(game,Zone.LIBRARY,source.getSourceId(),player.getId(),true);
            }
          }
          player.shuffleLibrary(source,game);
        }
      }
    }
    controller.resetStoredBookmark(game);
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller != null) {
    int xSum=0;
    xSum+=playerPaysXGenericMana(controller,source,game);
    for (    UUID playerId : game.getState().getPlayersInRange(controller.getId(),game)) {
      if (!Objects.equals(playerId,controller.getId())) {
        Player player=game.getPlayer(playerId);
        if (player != null) {
          xSum+=playerPaysXGenericMana(player,source,game);
        }
      }
    }
    for (    UUID playerId : game.getState().getPlayersInRange(controller.getId(),game)) {
      Player player=game.getPlayer(playerId);
      if (player != null) {
        TargetCardInLibrary target=new TargetCardInLibrary(0,xSum,new FilterBasicLandCard());
        if (player.searchLibrary(target,game)) {
          for (          UUID cardId : target.getTargets()) {
            Card card=player.getLibrary().getCard(cardId,game);
            if (card != null) {
              card.putOntoBattlefield(game,Zone.LIBRARY,source.getSourceId(),player.getId(),true);
            }
          }
          player.shuffleLibrary(source,game);
        }
      }
    }
    controller.resetStoredBookmark(game);
    return true;
  }
  return false;
}",0.9723756906077348
158138,"@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  Player newController=game.getPlayer(getTargetPointer().getFirst(game,source));
  if (controller != null && newController != null && controller.getId() != newController.getId()) {
    ContinuousEffect effect=new GainControlTargetEffect(Duration.Custom,newController.getId());
    effect.setTargetPointer(new FixedTarget(source.getSourceId()));
    game.addEffect(effect,source);
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  Player newController=game.getPlayer(getTargetPointer().getFirst(game,source));
  if (controller != null && newController != null && !Objects.equals(controller.getId(),newController.getId())) {
    ContinuousEffect effect=new GainControlTargetEffect(Duration.Custom,newController.getId());
    effect.setTargetPointer(new FixedTarget(source.getSourceId()));
    game.addEffect(effect,source);
    return true;
  }
  return false;
}",0.6403669724770642
158139,"@Override public boolean applies(UUID objectId,Ability source,UUID affectedControllerId,Game game){
  return source.getControllerId().equals(affectedControllerId) && objectId == ((FixedTarget)getTargetPointer()).getTarget() && ((FixedTarget)getTargetPointer()).getZoneChangeCounter() + 1 == game.getState().getZoneChangeCounter(objectId) && (((FixedTarget)getTargetPointer()).getZoneChangeCounter() + 1 == game.getState().getZoneChangeCounter(objectId)) && game.getState().getZone(objectId).equals(Zone.STACK);
}","@Override public boolean applies(UUID objectId,Ability source,UUID affectedControllerId,Game game){
  return source.getControllerId().equals(affectedControllerId) && Objects.equals(objectId,((FixedTarget)getTargetPointer()).getTarget()) && ((FixedTarget)getTargetPointer()).getZoneChangeCounter() + 1 == game.getState().getZoneChangeCounter(objectId) && (((FixedTarget)getTargetPointer()).getZoneChangeCounter() + 1 == game.getState().getZoneChangeCounter(objectId)) && game.getState().getZone(objectId).equals(Zone.STACK);
}",0.973963355834137
158140,"@Override public boolean checkTrigger(GameEvent event,Game game){
  if (event.getData().equals(CounterType.INTERVENTION.getName()) && event.getTargetId().equals(this.getSourceId())) {
    boolean onlyYouOnStack=true;
    boolean onlyOpponentOnStack=true;
    UUID you=getControllerId();
    boolean firstOnStack=false;
    for (    StackObject stackObject : game.getStack()) {
      if (stackObject.getControllerId() != null && !firstOnStack) {
        if (you != stackObject.getControllerId()) {
          onlyYouOnStack=false;
        }
 else         if (you == stackObject.getControllerId()) {
          onlyOpponentOnStack=false;
        }
        firstOnStack=true;
      }
    }
    if (onlyYouOnStack && !onlyOpponentOnStack) {
      return true;
    }
 else     if (!onlyYouOnStack && onlyOpponentOnStack) {
      return false;
    }
  }
  return false;
}","@Override public boolean checkTrigger(GameEvent event,Game game){
  if (event.getData().equals(CounterType.INTERVENTION.getName()) && event.getTargetId().equals(this.getSourceId())) {
    boolean onlyYouOnStack=true;
    boolean onlyOpponentOnStack=true;
    UUID you=getControllerId();
    boolean firstOnStack=false;
    for (    StackObject stackObject : game.getStack()) {
      if (stackObject.getControllerId() != null && !firstOnStack) {
        if (!Objects.equals(you,stackObject.getControllerId())) {
          onlyYouOnStack=false;
        }
 else         if (Objects.equals(you,stackObject.getControllerId())) {
          onlyOpponentOnStack=false;
        }
        firstOnStack=true;
      }
    }
    if (onlyYouOnStack && !onlyOpponentOnStack) {
      return true;
    }
 else     if (!onlyYouOnStack && onlyOpponentOnStack) {
      return false;
    }
  }
  return false;
}",0.9697661152310324
158141,"@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller != null) {
    Target target=new TargetCreaturePermanent(0,1,new FilterCreaturePermanent(""String_Node_Str""),true);
    target.setRequired(true);
    Permanent creatureToKeep=null;
    if (controller.choose(outcome,target,source.getSourceId(),game)) {
      creatureToKeep=game.getPermanent(target.getFirstTarget());
    }
    for (    Permanent creature : game.getBattlefield().getActivePermanents(new FilterCreaturePermanent(),source.getControllerId(),source.getSourceId(),game)) {
      if (creature != creatureToKeep) {
        creature.destroy(source.getSourceId(),game,false);
      }
    }
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller != null) {
    Target target=new TargetCreaturePermanent(0,1,new FilterCreaturePermanent(""String_Node_Str""),true);
    target.setRequired(true);
    Permanent creatureToKeep=null;
    if (controller.choose(outcome,target,source.getSourceId(),game)) {
      creatureToKeep=game.getPermanent(target.getFirstTarget());
    }
    for (    Permanent creature : game.getBattlefield().getActivePermanents(new FilterCreaturePermanent(),source.getControllerId(),source.getSourceId(),game)) {
      if (!Objects.equals(creature,creatureToKeep)) {
        creature.destroy(source.getSourceId(),game,false);
      }
    }
    return true;
  }
  return false;
}",0.9768637532133676
158142,"@Override public boolean applies(GameEvent event,Ability source,Game game){
  if (event.getType() == GameEvent.EventType.DAMAGE_PLAYER) {
    if (event.getTargetId().equals(source.getControllerId()) && game.getControllerId(event.getSourceId()) != source.getControllerId()) {
      return super.applies(event,source,game);
    }
  }
  return false;
}","@Override public boolean applies(GameEvent event,Ability source,Game game){
  if (event.getType() == GameEvent.EventType.DAMAGE_PLAYER) {
    if (event.getTargetId().equals(source.getControllerId()) && !Objects.equals(game.getControllerId(event.getSourceId()),source.getControllerId())) {
      return super.applies(event,source,game);
    }
  }
  return false;
}",0.9691011235955056
158143,"@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  Player targetPlayer=game.getPlayer(getTargetPointer().getFirst(game,source));
  if (controller != null && targetPlayer != null) {
    if (targetPlayer != controller) {
      phaseOutCardType(controller,targetPlayer,CardType.LAND,source,game);
      phaseOutCardType(controller,targetPlayer,CardType.ARTIFACT,source,game);
      phaseOutCardType(controller,targetPlayer,CardType.CREATURE,source,game);
    }
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  Player targetPlayer=game.getPlayer(getTargetPointer().getFirst(game,source));
  if (controller != null && targetPlayer != null) {
    if (!Objects.equals(targetPlayer,controller)) {
      phaseOutCardType(controller,targetPlayer,CardType.LAND,source,game);
      phaseOutCardType(controller,targetPlayer,CardType.ARTIFACT,source,game);
      phaseOutCardType(controller,targetPlayer,CardType.CREATURE,source,game);
    }
    return true;
  }
  return false;
}",0.9442508710801394
158144,"@Override public boolean apply(Game game,Ability source){
  HashMap<UUID,Integer> toDestroy=new HashMap<>();
  Permanent etbPermanent=game.getPermanentOrLKIBattlefield(getTargetPointer().getFirst(game,source));
  if (etbPermanent == null) {
    return false;
  }
  String cn=etbPermanent.getName();
  for (  Permanent permanent : game.getBattlefield().getActivePermanents(filter,source.getControllerId(),source.getSourceId(),game)) {
    String cardName=permanent.getName();
    if (cardName.equals(cn) && permanent.getId() != etbPermanent.getId()) {
      toDestroy.put(permanent.getId(),1);
    }
  }
  for (  UUID id : toDestroy.keySet()) {
    Permanent permanent=game.getPermanent(id);
    if (permanent != null) {
      permanent.destroy(source.getSourceId(),game,false);
    }
  }
  return true;
}","@Override public boolean apply(Game game,Ability source){
  HashMap<UUID,Integer> toDestroy=new HashMap<>();
  Permanent etbPermanent=game.getPermanentOrLKIBattlefield(getTargetPointer().getFirst(game,source));
  if (etbPermanent == null) {
    return false;
  }
  String cn=etbPermanent.getName();
  for (  Permanent permanent : game.getBattlefield().getActivePermanents(filter,source.getControllerId(),source.getSourceId(),game)) {
    String cardName=permanent.getName();
    if (cardName.equals(cn) && !Objects.equals(permanent.getId(),etbPermanent.getId())) {
      toDestroy.put(permanent.getId(),1);
    }
  }
  for (  UUID id : toDestroy.keySet()) {
    Permanent permanent=game.getPermanent(id);
    if (permanent != null) {
      permanent.destroy(source.getSourceId(),game,false);
    }
  }
  return true;
}",0.6707768187422934
158145,"@Override public boolean checkTrigger(GameEvent event,Game game){
  if (event.getData().equals(CounterType.ENERGY.getName())) {
    return event.getTargetId() == this.getControllerId();
  }
  return false;
}","@Override public boolean checkTrigger(GameEvent event,Game game){
  if (event.getData().equals(CounterType.ENERGY.getName())) {
    return Objects.equals(event.getTargetId(),this.getControllerId());
  }
  return false;
}",0.9508196721311476
158146,"@Override public boolean applies(GameEvent event,Ability source,Game game){
  Permanent sourceObject=game.getPermanent(source.getSourceId());
  Permanent targetPermanent=game.getPermanent(event.getTargetId());
  Permanent guardianBeast=game.getPermanent(guardianBeastId);
  if (guardianBeast == null || guardianBeast.isTapped() || sourceObject == null || targetPermanent == null) {
    return false;
  }
  if (targetPermanent.getControllerId() != guardianBeast.getControllerId()) {
    return false;
  }
  StackObject spell=game.getStack().getStackObject(event.getSourceId());
  if (event.getType() == EventType.LOSE_CONTROL || event.getType() == EventType.ATTACH || event.getType() == EventType.TARGET && spell != null && spell.getCardType().contains(CardType.ENCHANTMENT) && spell.getSubtype(game).contains(""String_Node_Str"")) {
    for (    Permanent perm : game.getBattlefield().getAllActivePermanents(filter,source.getControllerId(),game)) {
      if (perm != null && perm.getId() == targetPermanent.getId() && !perm.getCardType().contains(CardType.CREATURE)) {
        return true;
      }
    }
  }
  return false;
}","@Override public boolean applies(GameEvent event,Ability source,Game game){
  Permanent sourceObject=game.getPermanent(source.getSourceId());
  Permanent targetPermanent=game.getPermanent(event.getTargetId());
  Permanent guardianBeast=game.getPermanent(guardianBeastId);
  if (guardianBeast == null || guardianBeast.isTapped() || sourceObject == null || targetPermanent == null) {
    return false;
  }
  if (!Objects.equals(targetPermanent.getControllerId(),guardianBeast.getControllerId())) {
    return false;
  }
  StackObject spell=game.getStack().getStackObject(event.getSourceId());
  if (event.getType() == EventType.LOSE_CONTROL || event.getType() == EventType.ATTACH || event.getType() == EventType.TARGET && spell != null && spell.getCardType().contains(CardType.ENCHANTMENT) && spell.getSubtype(game).contains(""String_Node_Str"")) {
    for (    Permanent perm : game.getBattlefield().getAllActivePermanents(filter,source.getControllerId(),game)) {
      if (perm != null && Objects.equals(perm.getId(),targetPermanent.getId()) && !perm.getCardType().contains(CardType.CREATURE)) {
        return true;
      }
    }
  }
  return false;
}",0.9810822701275846
158147,"@Override public boolean apply(Game game,Ability source){
  Player player=game.getPlayer(source.getControllerId());
  Permanent hellcarverDemon=game.getPermanent(source.getSourceId());
  for (  Permanent permanent : game.getBattlefield().getActivePermanents(filterPermanents,source.getControllerId(),game)) {
    if (permanent != hellcarverDemon) {
      permanent.sacrifice(source.getSourceId(),game);
    }
  }
  if (player != null && !player.getHand().isEmpty()) {
    int cardsInHand=player.getHand().size();
    player.discard(cardsInHand,source,game);
  }
  for (int i=0; i < 6; i++) {
    if (player != null && player.getLibrary().size() > 0) {
      Card topCard=player.getLibrary().getFromTop(game);
      topCard.moveToExile(source.getSourceId(),""String_Node_Str"",source.getSourceId(),game);
    }
  }
  while (player != null && player.canRespond() && player.chooseUse(Outcome.PlayForFree,""String_Node_Str"",source,game)) {
    TargetCardInExile target=new TargetCardInExile(filter,source.getSourceId());
    while (player.choose(Outcome.PlayForFree,game.getExile().getExileZone(source.getSourceId()),target,game)) {
      Card card=game.getCard(target.getFirstTarget());
      if (card != null) {
        game.getExile().removeCard(card,game);
        player.cast(card.getSpellAbility(),game,true);
      }
      target.clearChosen();
    }
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Player player=game.getPlayer(source.getControllerId());
  Permanent hellcarverDemon=game.getPermanent(source.getSourceId());
  for (  Permanent permanent : game.getBattlefield().getActivePermanents(filterPermanents,source.getControllerId(),game)) {
    if (!Objects.equals(permanent,hellcarverDemon)) {
      permanent.sacrifice(source.getSourceId(),game);
    }
  }
  if (player != null && !player.getHand().isEmpty()) {
    int cardsInHand=player.getHand().size();
    player.discard(cardsInHand,source,game);
  }
  for (int i=0; i < 6; i++) {
    if (player != null && player.getLibrary().size() > 0) {
      Card topCard=player.getLibrary().getFromTop(game);
      topCard.moveToExile(source.getSourceId(),""String_Node_Str"",source.getSourceId(),game);
    }
  }
  while (player != null && player.canRespond() && player.chooseUse(Outcome.PlayForFree,""String_Node_Str"",source,game)) {
    TargetCardInExile target=new TargetCardInExile(filter,source.getSourceId());
    while (player.choose(Outcome.PlayForFree,game.getExile().getExileZone(source.getSourceId()),target,game)) {
      Card card=game.getCard(target.getFirstTarget());
      if (card != null) {
        game.getExile().removeCard(card,game);
        player.cast(card.getSpellAbility(),game,true);
      }
      target.clearChosen();
    }
    return true;
  }
  return false;
}",0.4469914040114613
158148,"@Override public boolean checkTrigger(GameEvent event,Game game){
  Permanent equipment=game.getPermanent(this.getSourceId());
  if (equipment != null && equipment.getAttachedTo() != null) {
    if (event.getTargetId() == equipment.getAttachedTo()) {
      for (      Effect effect : this.getEffects()) {
        effect.setTargetPointer(new FixedTarget(equipment.getAttachedTo()));
      }
      return true;
    }
  }
  return false;
}","@Override public boolean checkTrigger(GameEvent event,Game game){
  Permanent equipment=game.getPermanent(this.getSourceId());
  if (equipment != null && equipment.getAttachedTo() != null) {
    if (Objects.equals(event.getTargetId(),equipment.getAttachedTo())) {
      for (      Effect effect : this.getEffects()) {
        effect.setTargetPointer(new FixedTarget(equipment.getAttachedTo()));
      }
      return true;
    }
  }
  return false;
}",0.976271186440678
158149,"/** 
 * Removes all arrows from the screen.
 */
public void removeAllArrows(UUID gameId){
  if (map.containsKey(gameId)) {
    Map<Type,List<Arrow>> innerMap=map.get(gameId);
    JPanel p=getArrowsPanel(gameId);
    if (p != null && p.getComponentCount() > 0) {
      p.removeAll();
      p.revalidate();
      p.repaint();
    }
    innerMap.clear();
    map.remove(gameId);
  }
}","/** 
 * Removes all arrows from the screen.
 */
public void removeAllArrows(UUID gameId){
  if (map.containsKey(gameId)) {
    Map<Type,List<Arrow>> innerMap=map.get(gameId);
    JPanel p=getArrowsPanel(gameId);
synchronized (map) {
      if (p != null && p.getComponentCount() > 0) {
        p.removeAll();
        p.revalidate();
        p.repaint();
      }
      innerMap.clear();
      map.remove(gameId);
    }
  }
}",0.8119551681195517
158150,"/** 
 * Adds new arrow.
 * @param startX
 * @param startY
 * @param endX
 * @param endY
 * @param color
 */
public void addArrow(UUID gameId,int startX,int startY,int endX,int endY,Color color,Type type){
  JPanel p=getArrowsPanel(gameId);
  Arrow arrow=new Arrow();
  arrow.setColor(color);
  arrow.setArrowLocation(startX,startY,endX,endY);
  arrow.setBounds(0,0,Math.max(startX,endX) + 40,Math.max(startY,endY) + 30);
  p.add(arrow);
  Map<Type,List<Arrow>> innerMap=map.computeIfAbsent(gameId,k -> new HashMap<>());
  List<Arrow> arrows=innerMap.computeIfAbsent(type,k -> new ArrayList<>());
  arrows.add(arrow);
  p.revalidate();
  p.repaint();
}","/** 
 * Adds new arrow.
 * @param startX
 * @param startY
 * @param endX
 * @param endY
 * @param color
 */
public void addArrow(UUID gameId,int startX,int startY,int endX,int endY,Color color,Type type){
  JPanel p=getArrowsPanel(gameId);
  Arrow arrow=new Arrow();
  arrow.setColor(color);
  arrow.setArrowLocation(startX,startY,endX,endY);
  arrow.setBounds(0,0,Math.max(startX,endX) + 40,Math.max(startY,endY) + 30);
synchronized (map) {
    p.add(arrow);
    Map<Type,java.util.List<Arrow>> innerMap=map.get(gameId);
    if (innerMap == null) {
      innerMap=new HashMap<Type,List<Arrow>>();
      map.put(gameId,innerMap);
    }
    java.util.List<Arrow> arrows=innerMap.get(type);
    if (arrows == null) {
      arrows=new ArrayList<Arrow>();
      innerMap.put(type,arrows);
    }
    arrows.add(arrow);
  }
  p.revalidate();
  p.repaint();
}",0.6852960745176314
158151,"public void removeArrowsByType(UUID gameId,Type type){
  if (map.containsKey(gameId)) {
    Map<Type,List<Arrow>> innerMap=map.get(gameId);
    java.util.List<Arrow> arrows=innerMap.get(type);
    if (arrows != null && !arrows.isEmpty()) {
      JPanel p=getArrowsPanel(gameId);
      for (      Arrow arrow : arrows) {
        p.remove(arrow);
      }
      innerMap.put(type,new ArrayList<>());
      p.revalidate();
      p.repaint();
    }
  }
}","public void removeArrowsByType(UUID gameId,Type type){
  if (map.containsKey(gameId)) {
    Map<Type,List<Arrow>> innerMap=map.get(gameId);
    java.util.List<Arrow> arrows=innerMap.get(type);
    if (arrows != null && arrows.size() > 0) {
      JPanel p=getArrowsPanel(gameId);
synchronized (map) {
        for (        Arrow arrow : arrows) {
          p.remove(arrow);
        }
        innerMap.put(type,new ArrayList<Arrow>());
      }
      p.revalidate();
      p.repaint();
    }
  }
}",0.9171974522292994
158152,"@Override public boolean apply(Game game,Ability source){
}","@Override public boolean apply(Game game,Ability source){
  Card card;
  Player controller=game.getPlayer(source.getControllerId());
  if (controller == null) {
    return false;
  }
  ExileZone exile=game.getExile().createZone(source.getSourceId(),controller.getName() + ""String_Node_Str"");
  int sourceCost=game.getCard(source.getSourceId()).getConvertedManaCost();
  do {
    card=controller.getLibrary().getFromTop(game);
    if (card == null) {
      break;
    }
    controller.moveCardsToExile(card,source,game,true,exile.getId(),exile.getName());
  }
 while (controller.isInGame() && (card.getCardType().contains(CardType.LAND) || !cardThatCostsLess(sourceCost,card,game)));
  controller.getLibrary().reset();
  if (card != null) {
    if (controller.chooseUse(outcome,""String_Node_Str"" + card.getLogName() + '?',source,game)) {
      controller.cast(card.getSpellAbility(),game,true);
    }
    Cards cardsFromExile=new CardsImpl();
    Cards cardsToLibrary=new CardsImpl();
    cardsFromExile.addAll(exile);
    while (!cardsFromExile.isEmpty()) {
      card=cardsFromExile.getRandom(game);
      cardsFromExile.remove(card.getId());
      cardsToLibrary.add(card);
    }
    controller.putCardsOnBottomOfLibrary(cardsToLibrary,game,source,false);
  }
  return true;
}",0.0882572924457741
158153,"public void fireCallback(final ClientCallback call){
  if (isConnected()) {
    SessionManager.getInstance().getSession(sessionId).fireCallback(call);
  }
}","public void fireCallback(final ClientCallback call){
  if (isConnected()) {
    Session session=SessionManager.getInstance().getSession(sessionId);
    if (session != null) {
      session.fireCallback(call);
    }
  }
}",0.8297872340425532
158154,"private void defenderDamage(Permanent attacker,int amount,Game game){
  if (this.defenderIsPlaneswalker) {
    Permanent defender=game.getPermanent(defenderId);
    if (defender != null) {
      defender.markDamage(amount,attacker.getId(),game,true,true);
    }
  }
 else {
    Player defender=game.getPlayer(defenderId);
    defender.damage(amount,attacker.getId(),game,true,true);
  }
}","private void defenderDamage(Permanent attacker,int amount,Game game){
  if (this.defenderIsPlaneswalker) {
    Permanent defender=game.getPermanent(defenderId);
    if (defender != null) {
      defender.markDamage(amount,attacker.getId(),game,true,true);
    }
  }
 else {
    Player defender=game.getPlayer(defenderId);
    if (defender.isInGame()) {
      defender.damage(amount,attacker.getId(),game,true,true);
    }
  }
}",0.9521472392638036
158155,"@Override public boolean apply(Game game,Ability source){
  UUID exileId=source.getSourceId();
  Permanent targetPermanent=game.getPermanent(getTargetPointer().getFirst(game,source));
  if (targetPermanent != null) {
    UUID controllerPermanentId=targetPermanent.getControllerId();
    Player you=game.getPlayer(source.getControllerId());
    MageObject sourceObject=game.getObject(source.getSourceId());
    if (sourceObject != null && exileId != null && you != null) {
      int exiledCount=0;
      if (targetPermanent.getName().isEmpty()) {
        you.moveCardToExileWithInfo(targetPermanent,exileId,sourceObject.getIdName(),source.getSourceId(),game,Zone.BATTLEFIELD,true);
        exiledCount=1;
      }
 else {
        String name=targetPermanent.getName();
        for (        Permanent permanent : game.getBattlefield().getAllActivePermanents(controllerPermanentId)) {
          if (permanent != null && permanent.getName().equals(name)) {
            if (creaturesOnly.match(permanent,game)) {
              you.moveCardToExileWithInfo(permanent,null,""String_Node_Str"",source.getSourceId(),game,Zone.BATTLEFIELD,true);
            }
            if (nonTokenFilter.match(permanent,game)) {
              exiledCount++;
            }
          }
        }
      }
      if (exiledCount > 0) {
        Token token=new ClueArtifactToken();
        token.putOntoBattlefield(exiledCount,game,source.getSourceId(),controllerPermanentId,false,false);
      }
      return true;
    }
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  MageObject sourceObject=game.getObject(source.getSourceId());
  if (sourceObject != null && controller != null) {
    Permanent targetPermanent=game.getPermanent(getTargetPointer().getFirst(game,source));
    if (targetPermanent != null) {
      Set<Card> cardsToExile=new HashSet<>();
      int nonTokenCount=0;
      if (targetPermanent.getName().isEmpty()) {
        cardsToExile.add(targetPermanent);
        if (!(targetPermanent instanceof PermanentToken)) {
          nonTokenCount++;
        }
      }
 else {
        for (        Permanent permanent : game.getBattlefield().getAllActivePermanents(new FilterCreaturePermanent(),targetPermanent.getControllerId(),game)) {
          if (!permanent.getId().equals(targetPermanent.getId()) && permanent.getName().equals(targetPermanent.getName())) {
            cardsToExile.add(permanent);
            if (!(permanent instanceof PermanentToken)) {
              nonTokenCount++;
            }
          }
        }
      }
      controller.moveCards(cardsToExile,Zone.EXILED,source,game);
      game.applyEffects();
      if (nonTokenCount > 0) {
        new ClueArtifactToken().putOntoBattlefield(nonTokenCount,game,source.getSourceId(),targetPermanent.getControllerId(),false,false);
      }
      return true;
    }
  }
  return false;
}",0.2569183464297916
158156,"@Test public void testBlockedByTwo22s(){
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"");
  addCard(Zone.BATTLEFIELD,playerB,""String_Node_Str"");
  addCard(Zone.BATTLEFIELD,playerB,""String_Node_Str"");
  attack(3,playerA,""String_Node_Str"");
  block(3,playerB,""String_Node_Str"",""String_Node_Str"");
  block(3,playerB,""String_Node_Str"",""String_Node_Str"");
  setStopAt(3,PhaseStep.POSTCOMBAT_MAIN);
  execute();
  assertLife(playerA,20);
  assertLife(playerB,20);
  assertPermanentCount(playerA,""String_Node_Str"",1);
  assertGraveyardCount(playerA,""String_Node_Str"",0);
  assertPermanentCount(playerB,""String_Node_Str"",0);
  assertGraveyardCount(playerB,""String_Node_Str"",1);
  assertPermanentCount(playerB,""String_Node_Str"",0);
  assertGraveyardCount(playerB,""String_Node_Str"",1);
}","@Test public void testBlockedByTwo22s(){
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"");
  addCard(Zone.BATTLEFIELD,playerB,""String_Node_Str"");
  addCard(Zone.BATTLEFIELD,playerB,""String_Node_Str"");
  attack(3,playerA,""String_Node_Str"");
  block(3,playerB,""String_Node_Str"",""String_Node_Str"");
  block(3,playerB,""String_Node_Str"",""String_Node_Str"");
  setStopAt(3,PhaseStep.POSTCOMBAT_MAIN);
  execute();
  assertLife(playerA,20);
  assertLife(playerB,20);
  assertGraveyardCount(playerA,""String_Node_Str"",0);
  assertPermanentCount(playerA,""String_Node_Str"",1);
  assertPermanentCount(playerB,""String_Node_Str"",0);
  assertGraveyardCount(playerB,""String_Node_Str"",1);
  assertPermanentCount(playerB,""String_Node_Str"",0);
  assertGraveyardCount(playerB,""String_Node_Str"",1);
}",0.7841634738186463
158157,"private void sendInfoAboutPlayersNotJoinedYet(){
  for (  Player player : game.getPlayers().values()) {
    if (!player.hasLeft() && player.isHuman()) {
      User user=getUserByPlayerId(player.getId()).get();
      if (user != null) {
        if (!user.isConnected()) {
          if (gameSessions.get(player.getId()) == null) {
            user.removeConstructing(player.getId());
            GameManager.getInstance().joinGame(game.getId(),user.getId());
            logger.debug(""String_Node_Str"" + player.getName() + ""String_Node_Str""+ game.getId());
          }
          ChatManager.getInstance().broadcast(chatId,player.getName(),user.getPingInfo() + ""String_Node_Str"",MessageColor.BLUE,true,ChatMessage.MessageType.STATUS,null);
          if (user.getSecondsDisconnected() > 240) {
            logger.debug(""String_Node_Str"" + player.getName() + ""String_Node_Str""+ game.getId());
            player.leave();
          }
        }
      }
 else       if (!player.hasLeft()) {
        logger.debug(""String_Node_Str"" + player.getName() + ""String_Node_Str""+ game.getId());
        player.leave();
      }
    }
  }
  checkStart();
}","private void sendInfoAboutPlayersNotJoinedYet(){
  for (  Player player : game.getPlayers().values()) {
    if (!player.hasLeft() && player.isHuman()) {
      Optional<User> requestedUser=getUserByPlayerId(player.getId());
      if (requestedUser.isPresent()) {
        User user=requestedUser.get();
        if (!user.isConnected()) {
          if (gameSessions.get(player.getId()) == null) {
            user.removeConstructing(player.getId());
            GameManager.getInstance().joinGame(game.getId(),user.getId());
            logger.debug(""String_Node_Str"" + player.getName() + ""String_Node_Str""+ game.getId());
          }
          ChatManager.getInstance().broadcast(chatId,player.getName(),user.getPingInfo() + ""String_Node_Str"",MessageColor.BLUE,true,ChatMessage.MessageType.STATUS,null);
          if (user.getSecondsDisconnected() > 240) {
            logger.debug(""String_Node_Str"" + player.getName() + ""String_Node_Str""+ game.getId());
            player.leave();
          }
        }
      }
 else       if (!player.hasLeft()) {
        logger.debug(""String_Node_Str"" + player.getName() + ""String_Node_Str""+ game.getId());
        player.leave();
      }
    }
  }
  checkStart();
}",0.9533590072742832
158158,"@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller != null) {
    filter.add(new ConvertedManaCostPredicate(Filter.ComparisonType.LessThan,source.getManaCostsToPay().getX() + 1));
    TargetCardInLibrary target=new TargetCardInLibrary(filter);
    if (controller.searchLibrary(target,game)) {
      if (target.getTargets().size() > 0) {
        Card card=controller.getLibrary().getCard(target.getFirstTarget(),game);
        if (card != null) {
          controller.moveCards(card,Zone.BATTLEFIELD,source,game);
        }
      }
      controller.shuffleLibrary(source,game);
    }
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller != null) {
    FilterCard advancedFilter=filter.copy();
    advancedFilter.add(new ConvertedManaCostPredicate(Filter.ComparisonType.LessThan,source.getManaCostsToPay().getX() + 1));
    TargetCardInLibrary target=new TargetCardInLibrary(advancedFilter);
    if (controller.searchLibrary(target,game)) {
      if (target.getTargets().size() > 0) {
        Card card=controller.getLibrary().getCard(target.getFirstTarget(),game);
        if (card != null) {
          controller.moveCards(card,Zone.BATTLEFIELD,source,game);
        }
      }
      controller.shuffleLibrary(source,game);
    }
    return true;
  }
  return false;
}",0.9572881355932203
158159,"public void requestPermissionToRollbackTurn(UUID requestingUserId,int numberTurns){
  if (!killed) {
    Optional<User> requestingUser=UserManager.getInstance().getUser(requestingUserId);
    Optional<User> requestedUser=UserManager.getInstance().getUser(userId);
    if (!requestedUser.isPresent() && !requestingUser.isPresent()) {
      String message;
switch (numberTurns) {
case 0:
        message=""String_Node_Str"";
      break;
case 1:
    message=""String_Node_Str"";
  break;
default :
message=""String_Node_Str"" + numberTurns + ""String_Node_Str"";
}
UserRequestMessage userRequestMessage=new UserRequestMessage(""String_Node_Str"" + requestedUser.get().getName(),message);
userRequestMessage.setRelatedUser(requestingUserId,requestingUser.get().getName());
userRequestMessage.setGameId(game.getId());
userRequestMessage.setButton1(""String_Node_Str"",PlayerAction.ADD_PERMISSION_TO_ROLLBACK_TURN);
userRequestMessage.setButton2(""String_Node_Str"",PlayerAction.DENY_PERMISSON_TO_ROLLBACK_TURN);
requestedUser.get().fireCallback(new ClientCallback(""String_Node_Str"",game.getId(),userRequestMessage));
}
}
}","public void requestPermissionToRollbackTurn(UUID requestingUserId,int numberTurns){
  if (!killed) {
    Optional<User> requestingUser=UserManager.getInstance().getUser(requestingUserId);
    Optional<User> requestedUser=UserManager.getInstance().getUser(userId);
    if (requestedUser.isPresent() && requestingUser.isPresent()) {
      String message;
switch (numberTurns) {
case 0:
        message=""String_Node_Str"";
      break;
case 1:
    message=""String_Node_Str"";
  break;
default :
message=""String_Node_Str"" + numberTurns + ""String_Node_Str"";
}
UserRequestMessage userRequestMessage=new UserRequestMessage(""String_Node_Str"" + requestedUser.get().getName(),message);
userRequestMessage.setRelatedUser(requestingUserId,requestingUser.get().getName());
userRequestMessage.setGameId(game.getId());
userRequestMessage.setButton1(""String_Node_Str"",PlayerAction.ADD_PERMISSION_TO_ROLLBACK_TURN);
userRequestMessage.setButton2(""String_Node_Str"",PlayerAction.DENY_PERMISSON_TO_ROLLBACK_TURN);
requestedUser.get().fireCallback(new ClientCallback(""String_Node_Str"",game.getId(),userRequestMessage));
}
}
}",0.99909338168631
158160,"@Override public boolean activate(Game game,boolean noMana){
  Player controller=game.getPlayer(this.getControllerId());
  if (controller == null) {
    return false;
  }
  game.applyEffects();
  if (!getModes().choose(game,this)) {
    return false;
  }
  getSourceObject(game);
  if (controller.isTestMode()) {
    if (!controller.addTargets(this,game)) {
      return false;
    }
  }
  if (this.abilityType == AbilityType.SPELL) {
    game.getContinuousEffects().applySpliceEffects(this,game);
  }
  if (noMana) {
    if (this.getManaCostsToPay().getVariableCosts().size() > 0) {
      int xValue=this.getManaCostsToPay().getX();
      this.getManaCostsToPay().clear();
      VariableManaCost xCosts=new VariableManaCost();
      xCosts.setAmount(xValue);
      this.getManaCostsToPay().add(xCosts);
    }
 else {
      this.getManaCostsToPay().clear();
    }
  }
  if (modes.getAdditionalCost() != null) {
    ((OptionalAdditionalModeSourceCosts)modes.getAdditionalCost()).addOptionalAdditionalModeCosts(this,game);
  }
  if (!activateAlternateOrAdditionalCosts(sourceObject,noMana,controller,game)) {
    if (getAbilityType() == AbilityType.SPELL && ((SpellAbility)this).getSpellAbilityType() == SpellAbilityType.FACE_DOWN_CREATURE) {
      return false;
    }
  }
  VariableManaCost variableManaCost=handleManaXCosts(game,noMana,controller);
  String announceString=handleOtherXCosts(game,controller);
  if (this.getAbilityType() == AbilityType.SPELL && game.replaceEvent(GameEvent.getEvent(GameEvent.EventType.CAST_SPELL_LATE,getId(),getSourceId(),getControllerId()),this)) {
    return false;
  }
  for (  UUID modeId : this.getModes().getSelectedModes()) {
    this.getModes().setActiveMode(modeId);
    if (sourceObject != null && this.getAbilityType() != AbilityType.TRIGGERED) {
      sourceObject.adjustTargets(this,game);
    }
    if (!(this instanceof FlashbackAbility) && getTargets().size() > 0) {
      Outcome outcome=getEffects().isEmpty() ? Outcome.Detriment : getEffects().get(0).getOutcome();
      if (getTargets().chooseTargets(outcome,this.controllerId,this,noMana,game) == false) {
        if ((variableManaCost != null || announceString != null) && !game.isSimulation()) {
          game.informPlayer(controller,(sourceObject != null ? sourceObject.getIdName() : ""String_Node_Str"") + ""String_Node_Str"");
        }
        return false;
      }
    }
  }
  for (  Cost cost : optionalCosts) {
    if (cost instanceof ManaCost) {
      cost.clearPaid();
      if (controller.chooseUse(Outcome.Benefit,""String_Node_Str"" + cost.getText() + ""String_Node_Str"",this,game)) {
        manaCostsToPay.add((ManaCost)cost);
      }
    }
  }
  if (sourceObject != null) {
    sourceObject.adjustCosts(this,game);
    if (sourceObject instanceof Card) {
      for (      Ability ability : ((Card)sourceObject).getAbilities(game)) {
        if (ability instanceof AdjustingSourceCosts) {
          ((AdjustingSourceCosts)ability).adjustCosts(this,game);
        }
      }
    }
 else {
      for (      Ability ability : sourceObject.getAbilities()) {
        if (ability instanceof AdjustingSourceCosts) {
          ((AdjustingSourceCosts)ability).adjustCosts(this,game);
        }
      }
    }
  }
  if (this instanceof ActivatedManaAbilityImpl && !costs.pay(this,game,sourceId,controllerId,noMana,null)) {
    logger.debug(""String_Node_Str"");
    return false;
  }
  if (costModificationActive) {
    game.getContinuousEffects().costModification(this,game);
  }
 else {
    costModificationActive=true;
  }
  UUID activatorId=controllerId;
  if ((this instanceof ActivatedAbilityImpl) && ((ActivatedAbilityImpl)this).getActivatorId() != null) {
    activatorId=((ActivatedAbilityImpl)this).getActivatorId();
  }
  if (!manaCostsToPay.pay(this,game,sourceId,activatorId,false,null)) {
    return false;
  }
  if (!costs.pay(this,game,sourceId,activatorId,noMana,null)) {
    logger.debug(""String_Node_Str"");
    return false;
  }
  if (!game.isSimulation()) {
    if (announceString != null) {
      game.informPlayers(announceString);
    }
    if (variableManaCost != null) {
      int xValue=getManaCostsToPay().getX();
      game.informPlayers(controller.getLogName() + ""String_Node_Str"" + xValue+ ""String_Node_Str""+ variableManaCost.getText());
    }
  }
  activated=true;
  if (this.getAbilityType() == AbilityType.MANA) {
    for (    Cost cost : costs) {
      if (cost instanceof TapSourceCost) {
        Mana mana=null;
        Effect effect=getEffects().get(0);
        if (effect instanceof DynamicManaEffect) {
          mana=((DynamicManaEffect)effect).getMana(game,this);
        }
 else         if (effect instanceof BasicManaEffect) {
          mana=((BasicManaEffect)effect).getMana(game,this);
        }
        if (mana != null && mana.getAny() == 0) {
          ManaEvent event=new ManaEvent(GameEvent.EventType.TAPPED_FOR_MANA,sourceId,sourceId,controllerId,mana);
          if (!game.replaceEvent(event)) {
            game.fireEvent(event);
          }
        }
        break;
      }
    }
  }
  return true;
}","@Override public boolean activate(Game game,boolean noMana){
  Player controller=game.getPlayer(this.getControllerId());
  if (controller == null) {
    return false;
  }
  game.applyEffects();
  if (!getModes().choose(game,this)) {
    return false;
  }
  getSourceObject(game);
  if (controller.isTestMode()) {
    if (!controller.addTargets(this,game)) {
      return false;
    }
  }
  if (this.abilityType == AbilityType.SPELL) {
    game.getContinuousEffects().applySpliceEffects(this,game);
  }
  if (noMana) {
    if (this.getManaCostsToPay().getVariableCosts().size() > 0) {
      int xValue=this.getManaCostsToPay().getX();
      this.getManaCostsToPay().clear();
      VariableManaCost xCosts=new VariableManaCost();
      xCosts.setAmount(xValue);
      this.getManaCostsToPay().add(xCosts);
    }
 else {
      this.getManaCostsToPay().clear();
    }
  }
  if (modes.getAdditionalCost() != null) {
    ((OptionalAdditionalModeSourceCosts)modes.getAdditionalCost()).addOptionalAdditionalModeCosts(this,game);
  }
  if (!activateAlternateOrAdditionalCosts(sourceObject,noMana,controller,game)) {
    if (getAbilityType() == AbilityType.SPELL && ((SpellAbility)this).getSpellAbilityType() == SpellAbilityType.FACE_DOWN_CREATURE) {
      return false;
    }
  }
  VariableManaCost variableManaCost=handleManaXCosts(game,noMana,controller);
  String announceString=handleOtherXCosts(game,controller);
  if (this.getAbilityType() == AbilityType.SPELL && game.replaceEvent(GameEvent.getEvent(GameEvent.EventType.CAST_SPELL_LATE,getId(),getSourceId(),getControllerId()),this)) {
    return false;
  }
  for (  UUID modeId : this.getModes().getSelectedModes()) {
    this.getModes().setActiveMode(modeId);
    if (sourceObject != null && this.getAbilityType() != AbilityType.TRIGGERED) {
      sourceObject.adjustTargets(this,game);
    }
    if (!(this instanceof FlashbackAbility) && getTargets().size() > 0) {
      Outcome outcome=getEffects().isEmpty() ? Outcome.Detriment : getEffects().get(0).getOutcome();
      if (getTargets().chooseTargets(outcome,this.controllerId,this,noMana,game) == false) {
        if ((variableManaCost != null || announceString != null) && !game.isSimulation()) {
          game.informPlayer(controller,(sourceObject != null ? sourceObject.getIdName() : ""String_Node_Str"") + ""String_Node_Str"");
        }
        return false;
      }
    }
  }
  for (  Cost cost : optionalCosts) {
    if (cost instanceof ManaCost) {
      cost.clearPaid();
      if (controller.chooseUse(Outcome.Benefit,""String_Node_Str"" + cost.getText() + ""String_Node_Str"",this,game)) {
        manaCostsToPay.add((ManaCost)cost);
      }
    }
  }
  if (sourceObject != null) {
    sourceObject.adjustCosts(this,game);
    if (sourceObject instanceof Card) {
      for (      Ability ability : ((Card)sourceObject).getAbilities(game)) {
        if (ability instanceof AdjustingSourceCosts) {
          ((AdjustingSourceCosts)ability).adjustCosts(this,game);
        }
      }
    }
 else {
      for (      Ability ability : sourceObject.getAbilities()) {
        if (ability instanceof AdjustingSourceCosts) {
          ((AdjustingSourceCosts)ability).adjustCosts(this,game);
        }
      }
    }
  }
  if (this instanceof ActivatedManaAbilityImpl && !costs.pay(this,game,sourceId,controllerId,noMana,null)) {
    logger.debug(""String_Node_Str"");
    return false;
  }
  if (costModificationActive) {
    game.getContinuousEffects().costModification(this,game);
  }
 else {
    costModificationActive=true;
  }
  UUID activatorId=controllerId;
  if ((this instanceof ActivatedAbilityImpl) && ((ActivatedAbilityImpl)this).getActivatorId() != null) {
    activatorId=((ActivatedAbilityImpl)this).getActivatorId();
  }
  if (!manaCostsToPay.pay(this,game,sourceId,activatorId,false,null)) {
    return false;
  }
  if (!costs.pay(this,game,sourceId,activatorId,noMana,null)) {
    logger.debug(""String_Node_Str"");
    return false;
  }
  if (!game.isSimulation()) {
    if (announceString != null) {
      game.informPlayers(announceString);
    }
    if (variableManaCost != null) {
      int xValue=getManaCostsToPay().getX();
      game.informPlayers(controller.getLogName() + ""String_Node_Str"" + xValue+ ""String_Node_Str""+ variableManaCost.getText());
    }
  }
  activated=true;
  if (this.getAbilityType() == AbilityType.MANA) {
    for (    Cost cost : costs) {
      if (cost instanceof TapSourceCost) {
        Mana mana=null;
        Effect effect=getEffects().get(0);
        if (effect instanceof DynamicManaEffect) {
          mana=((DynamicManaEffect)effect).getMana(game,this);
        }
 else         if (effect instanceof ManaEffect) {
          mana=((ManaEffect)effect).getMana(game,this);
        }
        if (mana != null && mana.getAny() == 0) {
          ManaEvent event=new ManaEvent(GameEvent.EventType.TAPPED_FOR_MANA,sourceId,sourceId,controllerId,mana);
          if (!game.replaceEvent(event)) {
            game.fireEvent(event);
          }
        }
        break;
      }
    }
  }
  return true;
}",0.999009900990099
158161,"@Test public void testKessigForgemaster(){
  System.out.println(""String_Node_Str"");
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"");
  addCard(Zone.BATTLEFIELD,playerB,""String_Node_Str"");
  addCard(Zone.BATTLEFIELD,playerB,""String_Node_Str"");
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"");
  addCard(Zone.BATTLEFIELD,playerB,""String_Node_Str"");
  addCard(Zone.HAND,playerA,""String_Node_Str"");
  addCard(Zone.HAND,playerB,""String_Node_Str"");
  castSpell(1,PhaseStep.PRECOMBAT_MAIN,playerA,""String_Node_Str"");
  castSpell(2,PhaseStep.PRECOMBAT_MAIN,playerB,""String_Node_Str"");
  attack(3,playerA,""String_Node_Str"");
  block(3,playerB,""String_Node_Str"",""String_Node_Str"");
  block(3,playerB,""String_Node_Str"",""String_Node_Str"");
  setStopAt(3,PhaseStep.POSTCOMBAT_MAIN);
  execute();
  assertLife(playerA,20);
  assertLife(playerB,20);
  assertPermanentCount(playerA,""String_Node_Str"",1);
  assertGraveyardCount(playerA,""String_Node_Str"",0);
  assertPermanentCount(playerB,""String_Node_Str"",0);
  assertGraveyardCount(playerB,""String_Node_Str"",1);
  assertPermanentCount(playerB,""String_Node_Str"",0);
  assertGraveyardCount(playerB,""String_Node_Str"",1);
}","@Test public void testKessigForgemaster(){
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"");
  addCard(Zone.BATTLEFIELD,playerB,""String_Node_Str"");
  addCard(Zone.BATTLEFIELD,playerB,""String_Node_Str"");
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"");
  addCard(Zone.BATTLEFIELD,playerB,""String_Node_Str"");
  addCard(Zone.HAND,playerA,""String_Node_Str"");
  addCard(Zone.HAND,playerB,""String_Node_Str"");
  castSpell(1,PhaseStep.PRECOMBAT_MAIN,playerA,""String_Node_Str"");
  castSpell(2,PhaseStep.PRECOMBAT_MAIN,playerB,""String_Node_Str"");
  attack(3,playerA,""String_Node_Str"");
  block(3,playerB,""String_Node_Str"",""String_Node_Str"");
  block(3,playerB,""String_Node_Str"",""String_Node_Str"");
  setStopAt(3,PhaseStep.POSTCOMBAT_MAIN);
  execute();
  assertLife(playerA,20);
  assertLife(playerB,20);
  assertPermanentCount(playerA,""String_Node_Str"",1);
  assertGraveyardCount(playerA,""String_Node_Str"",0);
  assertPermanentCount(playerB,""String_Node_Str"",0);
  assertGraveyardCount(playerB,""String_Node_Str"",1);
  assertPermanentCount(playerB,""String_Node_Str"",0);
  assertGraveyardCount(playerB,""String_Node_Str"",1);
}",0.9821038847664776
158162,"@Test public void testBlockedByTwo22s(){
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"");
  addCard(Zone.BATTLEFIELD,playerB,""String_Node_Str"");
  addCard(Zone.BATTLEFIELD,playerB,""String_Node_Str"");
  attack(3,playerA,""String_Node_Str"");
  block(3,playerB,""String_Node_Str"",""String_Node_Str"");
  block(3,playerB,""String_Node_Str"",""String_Node_Str"");
  setStopAt(3,PhaseStep.POSTCOMBAT_MAIN);
  execute();
  assertLife(playerA,20);
  assertLife(playerB,20);
  assertPermanentCount(playerA,""String_Node_Str"",1);
  assertGraveyardCount(playerA,""String_Node_Str"",0);
  assertPermanentCount(playerB,""String_Node_Str"",0);
  assertGraveyardCount(playerB,""String_Node_Str"",1);
  assertPermanentCount(playerB,""String_Node_Str"",0);
  assertGraveyardCount(playerB,""String_Node_Str"",1);
  System.out.println(""String_Node_Str"");
}","@Test public void testBlockedByTwo22s(){
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"");
  addCard(Zone.BATTLEFIELD,playerB,""String_Node_Str"");
  addCard(Zone.BATTLEFIELD,playerB,""String_Node_Str"");
  attack(3,playerA,""String_Node_Str"");
  block(3,playerB,""String_Node_Str"",""String_Node_Str"");
  block(3,playerB,""String_Node_Str"",""String_Node_Str"");
  setStopAt(3,PhaseStep.POSTCOMBAT_MAIN);
  execute();
  assertLife(playerA,20);
  assertLife(playerB,20);
  assertPermanentCount(playerA,""String_Node_Str"",1);
  assertGraveyardCount(playerA,""String_Node_Str"",0);
  assertPermanentCount(playerB,""String_Node_Str"",0);
  assertGraveyardCount(playerB,""String_Node_Str"",1);
  assertPermanentCount(playerB,""String_Node_Str"",0);
  assertGraveyardCount(playerB,""String_Node_Str"",1);
}",0.9744866210329808
158163,"@Override public boolean apply(Game game,Ability source){
  Spell spell=game.getStack().getSpell(targetPointer.getFirst(game,source));
  MageObject sourceObject=source.getSourceObject(game);
  if (sourceObject != null && spell != null) {
    Player spellController=game.getPlayer(spell.getControllerId());
    if (spellController != null && spellController.moveCardToExileWithInfo(spell,source.getSourceId(),sourceObject.getIdName(),source.getSourceId(),game,Zone.STACK,true)) {
      if (spellController.getLibrary().size() > 0) {
        Library library=spellController.getLibrary();
        Card card;
        do {
          card=library.removeFromTop(game);
          if (card != null) {
            spellController.moveCardToExileWithInfo(card,source.getSourceId(),sourceObject.getIdName(),source.getSourceId(),game,Zone.LIBRARY,true);
          }
        }
 while (library.size() > 0 && card != null && !sharesType(card,spell.getCardType()));
        if (card != null && sharesType(card,spell.getCardType()) && !card.getCardType().contains(CardType.LAND) && card.getSpellAbility().canChooseTarget(game)) {
          if (spellController.chooseUse(Outcome.PlayForFree,""String_Node_Str"" + card.getLogName() + ""String_Node_Str"",source,game)) {
            spellController.cast(card.getSpellAbility(),game,true);
          }
        }
        ExileZone exile=game.getExile().getExileZone(source.getSourceId());
        if (exile != null) {
          while (exile.size() > 0) {
            card=exile.getRandom(game);
            spellController.moveCardToLibraryWithInfo(card,source.getSourceId(),game,Zone.EXILED,false,false);
          }
        }
      }
      return true;
    }
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Spell spell=game.getStack().getSpell(targetPointer.getFirst(game,source));
  MageObject sourceObject=source.getSourceObject(game);
  if (sourceObject != null && spell != null) {
    Player spellController=game.getPlayer(spell.getControllerId());
    if (spellController != null && spellController.moveCardsToExile(spell,source,game,true,source.getSourceId(),sourceObject.getIdName())) {
      if (spellController.getLibrary().size() > 0) {
        Library library=spellController.getLibrary();
        Card card;
        do {
          card=library.getFromTop(game);
          if (card != null) {
            spellController.moveCardsToExile(card,source,game,true,source.getSourceId(),sourceObject.getIdName());
          }
        }
 while (library.size() > 0 && card != null && !sharesType(card,spell.getCardType()));
        if (card != null && sharesType(card,spell.getCardType()) && !card.getCardType().contains(CardType.LAND) && card.getSpellAbility().canChooseTarget(game)) {
          if (spellController.chooseUse(Outcome.PlayForFree,""String_Node_Str"" + card.getLogName() + ""String_Node_Str"",source,game)) {
            spellController.cast(card.getSpellAbility(),game,true);
          }
        }
        ExileZone exile=game.getExile().getExileZone(source.getSourceId());
        if (exile != null) {
          spellController.putCardsOnBottomOfLibrary(exile,game,source,false);
        }
      }
      return true;
    }
  }
  return false;
}",0.7051879465672569
158164,"/** 
 * There's currently a bug with Possibility Storm and Zoetic Cavern. The way it's supposed to work is the P. Storm trigger exiles Zoetic Cavern and then uses last known information about the spell to determine the type of card the trigger is looking for(creature in this instance). Instead it's basing the type solely off what's printed on the card. What happened to me earlier was the trigger skipped right over an Emrakul and then revealed a Flooded Strand. I was prompted whether or not I wanted to ""cast"" Flooded Strand without paying it's cost. Eventually I clicked yes and it produced a Game Error that resulted in rollback. I recreated the error against an AI opponent and copied the code. Can't actually post it because the filter on this site claims it makes my post look too ""spammy"". Here's a screenshot of it instead(in spoiler tag).
 */
@Test public void TestWithZoeticCavern(){
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"",3);
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"",2);
  addCard(Zone.HAND,playerA,""String_Node_Str"");
  addCard(Zone.LIBRARY,playerA,""String_Node_Str"");
  skipInitShuffling();
  playLand(1,PhaseStep.PRECOMBAT_MAIN,playerA,""String_Node_Str"");
  setChoice(playerA,""String_Node_Str"");
  setStopAt(1,PhaseStep.BEGIN_COMBAT);
  execute();
  assertPermanentCount(playerA,""String_Node_Str"",0);
  boolean zoeticCavernInLibrary=false;
  for (  Card card : playerA.getLibrary().getCards(currentGame)) {
    if (card.getName().equals(""String_Node_Str"")) {
      zoeticCavernInLibrary=true;
    }
  }
  Assert.assertEquals(""String_Node_Str"",true,zoeticCavernInLibrary);
  assertPermanentCount(playerA,""String_Node_Str"",1);
}","/** 
 * There's currently a bug with Possibility Storm and Zoetic Cavern. The way it's supposed to work is the P. Storm trigger exiles Zoetic Cavern and then uses last known information about the spell to determine the type of card the trigger is looking for(creature in this instance). Instead it's basing the type solely off what's printed on the card. What happened to me earlier was the trigger skipped right over an Emrakul and then revealed a Flooded Strand. I was prompted whether or not I wanted to ""cast"" Flooded Strand without paying it's cost. Eventually I clicked yes and it produced a Game Error that resulted in rollback. I recreated the error against an AI opponent and copied the code. Can't actually post it because the filter on this site claims it makes my post look too ""spammy"". Here's a screenshot of it instead(in spoiler tag).
 */
@Test public void TestWithZoeticCavern(){
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"",3);
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"",1);
  addCard(Zone.HAND,playerA,""String_Node_Str"");
  addCard(Zone.LIBRARY,playerA,""String_Node_Str"");
  skipInitShuffling();
  playLand(1,PhaseStep.PRECOMBAT_MAIN,playerA,""String_Node_Str"");
  setChoice(playerA,""String_Node_Str"");
  setStopAt(1,PhaseStep.BEGIN_COMBAT);
  execute();
  assertPermanentCount(playerA,""String_Node_Str"",0);
  assertLibraryCount(playerA,""String_Node_Str"",1);
  assertPermanentCount(playerA,""String_Node_Str"",1);
}",0.8871071199486851
158165,"/** 
 * Moves the cards from cards to the bottom of the players library.
 * @param cards - list of cards that have to be moved
 * @param game - game
 * @param anyOrder - true if player can determine the order of the cards
 * @param source - source ability
 * @return
 */
boolean putCardsOnBottomOfLibrary(Cards cards,Game game,Ability source,boolean anyOrder);","/** 
 * Moves the cards from cards to the bottom of the players library.
 * @param cards - list of cards that have to be moved
 * @param game - game
 * @param anyOrder - true if player can determine the order of the cardselse random order
 * @param source - source ability
 * @return
 */
boolean putCardsOnBottomOfLibrary(Cards cards,Game game,Ability source,boolean anyOrder);",0.9769335142469472
158166,"/** 
 * Can be cards or permanents that go to library
 * @param cardsToLibrary
 * @param game
 * @param source
 * @param anyOrder
 * @return
 */
@Override public boolean putCardsOnTopOfLibrary(Cards cardsToLibrary,Game game,Ability source,boolean anyOrder){
  if (cardsToLibrary != null && !cardsToLibrary.isEmpty()) {
    Cards cards=new CardsImpl(cardsToLibrary);
    UUID sourceId=(source == null ? null : source.getSourceId());
    if (!anyOrder) {
      for (      UUID cardId : cards) {
        moveObjectToLibrary(cardId,sourceId,game,true,false);
      }
    }
 else {
      TargetCard target=new TargetCard(Zone.LIBRARY,new FilterCard(""String_Node_Str""));
      target.setRequired(true);
      while (cards.size() > 1) {
        this.choose(Outcome.Neutral,cards,target,game);
        if (!canRespond()) {
          return false;
        }
        UUID targetObjectId=target.getFirstTarget();
        cards.remove(targetObjectId);
        moveObjectToLibrary(targetObjectId,sourceId,game,true,false);
        target.clearChosen();
      }
      if (cards.size() == 1) {
        moveObjectToLibrary(cards.iterator().next(),sourceId,game,true,false);
      }
    }
  }
  return true;
}","/** 
 * Can be cards or permanents that go to library
 * @param cardsToLibrary
 * @param game
 * @param source
 * @param anyOrder
 * @return
 */
@Override public boolean putCardsOnTopOfLibrary(Cards cardsToLibrary,Game game,Ability source,boolean anyOrder){
  if (cardsToLibrary != null && !cardsToLibrary.isEmpty()) {
    Cards cards=new CardsImpl(cardsToLibrary);
    UUID sourceId=(source == null ? null : source.getSourceId());
    if (!anyOrder) {
      while (!cards.isEmpty()) {
        UUID cardId=cards.getRandom(game).getId();
        cards.remove(cardId);
        moveObjectToLibrary(cardId,source == null ? null : source.getSourceId(),game,true,false);
      }
    }
 else {
      TargetCard target=new TargetCard(Zone.LIBRARY,new FilterCard(""String_Node_Str""));
      target.setRequired(true);
      while (cards.size() > 1) {
        this.choose(Outcome.Neutral,cards,target,game);
        if (!canRespond()) {
          return false;
        }
        UUID targetObjectId=target.getFirstTarget();
        cards.remove(targetObjectId);
        moveObjectToLibrary(targetObjectId,sourceId,game,true,false);
        target.clearChosen();
      }
      if (cards.size() == 1) {
        moveObjectToLibrary(cards.iterator().next(),sourceId,game,true,false);
      }
    }
  }
  return true;
}",0.9101844426623896
158167,"@Override public boolean putCardsOnBottomOfLibrary(Cards cardsToLibrary,Game game,Ability source,boolean anyOrder){
  if (!cardsToLibrary.isEmpty()) {
    Cards cards=new CardsImpl(cardsToLibrary);
    if (!anyOrder) {
      for (      UUID objectId : cards) {
        moveObjectToLibrary(objectId,source == null ? null : source.getSourceId(),game,false,false);
      }
    }
 else {
      TargetCard target=new TargetCard(Zone.ALL,new FilterCard(""String_Node_Str""));
      target.setRequired(true);
      while (cards.size() > 1) {
        this.choose(Outcome.Neutral,cards,target,game);
        if (!canRespond()) {
          return false;
        }
        UUID targetObjectId=target.getFirstTarget();
        cards.remove(targetObjectId);
        moveObjectToLibrary(targetObjectId,source == null ? null : source.getSourceId(),game,false,false);
        target.clearChosen();
      }
      if (cards.size() == 1) {
        moveObjectToLibrary(cards.iterator().next(),source == null ? null : source.getSourceId(),game,false,false);
      }
    }
  }
  return true;
}","@Override public boolean putCardsOnBottomOfLibrary(Cards cardsToLibrary,Game game,Ability source,boolean anyOrder){
  if (!cardsToLibrary.isEmpty()) {
    Cards cards=new CardsImpl(cardsToLibrary);
    if (!anyOrder) {
      while (!cards.isEmpty()) {
        UUID cardId=cards.getRandom(game).getId();
        cards.remove(cardId);
        moveObjectToLibrary(cardId,source == null ? null : source.getSourceId(),game,false,false);
      }
    }
 else {
      TargetCard target=new TargetCard(Zone.ALL,new FilterCard(""String_Node_Str""));
      target.setRequired(true);
      while (cards.size() > 1) {
        this.choose(Outcome.Neutral,cards,target,game);
        if (!canRespond()) {
          return false;
        }
        UUID targetObjectId=target.getFirstTarget();
        cards.remove(targetObjectId);
        moveObjectToLibrary(targetObjectId,source == null ? null : source.getSourceId(),game,false,false);
        target.clearChosen();
      }
      if (cards.size() == 1) {
        moveObjectToLibrary(cards.iterator().next(),source == null ? null : source.getSourceId(),game,false,false);
      }
    }
  }
  return true;
}",0.9284420289855072
158168,"public static void loadImages(){
  renameSymbols(getSymbolsPath() + File.separator + ""String_Node_Str"");
  smallSymbolsFound=loadSymbolsImages(15);
  mediumSymbolsFound=loadSymbolsImages(25);
  List<String> setCodes=ExpansionRepository.instance.getSetCodes();
  if (setCodes == null) {
    LOGGER.warn(""String_Node_Str"");
    return;
  }
  for (  String set : setCodes) {
    String[] codes=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
    Map<String,Image> rarityImages=new HashMap<>();
    setImages.put(set,rarityImages);
    for (    String rarityCode : codes) {
      File file=new File(getSymbolsPath() + Constants.RESOURCE_PATH_SET + set+ ""String_Node_Str""+ rarityCode+ ""String_Node_Str"");
      try {
        Image image=UI.getImageIcon(file.getAbsolutePath()).getImage();
        int width=image.getWidth(null);
        if (width > 21) {
          int h=image.getHeight(null);
          if (h > 0) {
            Rectangle r=new Rectangle(21,(int)(h * 21.0f / width));
            BufferedImage resized=ImageHelper.getResizedImage(BufferedImageBuilder.bufferImage(image,BufferedImage.TYPE_INT_ARGB),r);
            rarityImages.put(set,resized);
          }
        }
 else {
          rarityImages.put(rarityCode,image);
        }
      }
 catch (      Exception e) {
      }
    }
    try {
      File file=new File(getSymbolsPath() + Constants.RESOURCE_PATH_SET_SMALL);
      if (!file.exists()) {
        file.mkdirs();
      }
      for (      String code : codes) {
        file=new File(getSymbolsPath() + Constants.RESOURCE_PATH_SET_SMALL + set+ ""String_Node_Str""+ code+ ""String_Node_Str"");
        if (file.exists()) {
          continue;
        }
        file=new File(getSymbolsPath() + Constants.RESOURCE_PATH_SET + set+ ""String_Node_Str""+ code+ ""String_Node_Str"");
        Image image=UI.getImageIcon(file.getAbsolutePath()).getImage();
        try {
          int width=image.getWidth(null);
          int height=image.getHeight(null);
          if (height > 0) {
            int dx=0;
            if (set.equals(""String_Node_Str"") || set.equals(""String_Node_Str"") || set.equals(""String_Node_Str"")) {
              dx=6;
            }
            Rectangle r=new Rectangle(15 + dx,(int)(height * (15.0f + dx) / width));
            BufferedImage resized=ImageHelper.getResizedImage(BufferedImageBuilder.bufferImage(image,BufferedImage.TYPE_INT_ARGB),r);
            File newFile=new File(getSymbolsPath() + Constants.RESOURCE_PATH_SET_SMALL + File.separator+ set+ ""String_Node_Str""+ code+ ""String_Node_Str"");
            ImageIO.write(resized,""String_Node_Str"",newFile);
          }
        }
 catch (        Exception e) {
          if (file.exists()) {
            file.delete();
          }
        }
      }
    }
 catch (    Exception e) {
    }
  }
  File file;
  for (  String set : ExpansionRepository.instance.getSetCodes()) {
    file=new File(getSymbolsPath() + Constants.RESOURCE_PATH_SET_SMALL);
    if (!file.exists()) {
      break;
    }
    file=new File(getSymbolsPath() + Constants.RESOURCE_PATH_SET_SMALL + set+ ""String_Node_Str"");
    try {
      Image image=UI.getImageIcon(file.getAbsolutePath()).getImage();
      int width=image.getWidth(null);
      int height=image.getHeight(null);
      setImagesExist.put(set,new Dimension(width,height));
    }
 catch (    Exception e) {
    }
  }
}","public static void loadImages(){
  renameSymbols(getSymbolsPath() + File.separator + ""String_Node_Str"");
  smallSymbolsFound=loadSymbolsImages(15);
  mediumSymbolsFound=loadSymbolsImages(25);
  List<String> setCodes=ExpansionRepository.instance.getSetCodes();
  if (setCodes == null) {
    LOGGER.warn(""String_Node_Str"");
    return;
  }
  for (  String set : setCodes) {
    if (withoutSymbols.contains(set)) {
      continue;
    }
    String[] codes;
    if (onlyMythics.contains(set)) {
      codes=new String[]{""String_Node_Str""};
    }
 else {
      codes=new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
    }
    Map<String,Image> rarityImages=new HashMap<>();
    setImages.put(set,rarityImages);
    for (    String rarityCode : codes) {
      File file=new File(getSymbolsPath() + Constants.RESOURCE_PATH_SET + set+ ""String_Node_Str""+ rarityCode+ ""String_Node_Str"");
      try {
        Image image=UI.getImageIcon(file.getAbsolutePath()).getImage();
        int width=image.getWidth(null);
        if (width > 21) {
          int h=image.getHeight(null);
          if (h > 0) {
            Rectangle r=new Rectangle(21,(int)(h * 21.0f / width));
            BufferedImage resized=ImageHelper.getResizedImage(BufferedImageBuilder.bufferImage(image,BufferedImage.TYPE_INT_ARGB),r);
            rarityImages.put(rarityCode,resized);
          }
        }
 else {
          rarityImages.put(rarityCode,image);
        }
      }
 catch (      Exception e) {
      }
    }
    try {
      File file=new File(getSymbolsPath() + Constants.RESOURCE_PATH_SET_SMALL);
      if (!file.exists()) {
        file.mkdirs();
      }
      for (      String code : codes) {
        file=new File(getSymbolsPath() + Constants.RESOURCE_PATH_SET_SMALL + set+ ""String_Node_Str""+ code+ ""String_Node_Str"");
        if (file.exists()) {
          continue;
        }
        file=new File(getSymbolsPath() + Constants.RESOURCE_PATH_SET + set+ ""String_Node_Str""+ code+ ""String_Node_Str"");
        Image image=UI.getImageIcon(file.getAbsolutePath()).getImage();
        try {
          int width=image.getWidth(null);
          int height=image.getHeight(null);
          if (height > 0) {
            int dx=0;
            if (set.equals(""String_Node_Str"") || set.equals(""String_Node_Str"") || set.equals(""String_Node_Str"")) {
              dx=6;
            }
            Rectangle r=new Rectangle(15 + dx,(int)(height * (15.0f + dx) / width));
            BufferedImage resized=ImageHelper.getResizedImage(BufferedImageBuilder.bufferImage(image,BufferedImage.TYPE_INT_ARGB),r);
            File newFile=new File(getSymbolsPath() + Constants.RESOURCE_PATH_SET_SMALL + File.separator+ set+ ""String_Node_Str""+ code+ ""String_Node_Str"");
            ImageIO.write(resized,""String_Node_Str"",newFile);
          }
        }
 catch (        Exception e) {
          if (file.exists()) {
            file.delete();
          }
        }
      }
    }
 catch (    Exception e) {
    }
  }
  File file;
  for (  String set : ExpansionRepository.instance.getSetCodes()) {
    file=new File(getSymbolsPath() + Constants.RESOURCE_PATH_SET_SMALL);
    if (!file.exists()) {
      break;
    }
    file=new File(getSymbolsPath() + Constants.RESOURCE_PATH_SET_SMALL + set+ ""String_Node_Str"");
    try {
      Image image=UI.getImageIcon(file.getAbsolutePath()).getImage();
      int width=image.getWidth(null);
      int height=image.getHeight(null);
      setImagesExist.put(set,new Dimension(width,height));
    }
 catch (    Exception e) {
    }
  }
}",0.9726224783861672
158169,"@Override public Iterator<DownloadJob> iterator(){
  Calendar c=Calendar.getInstance();
  c.setTime(new Date());
  c.add(Calendar.DATE,-14);
  Date compareDate=c.getTime();
  ArrayList<DownloadJob> jobs=new ArrayList<>();
  for (  String symbol : symbols) {
    ExpansionSet exp=Sets.findSet(symbol);
    if (exp != null && exp.getReleaseDate().before(compareDate)) {
      jobs.add(generateDownloadJob(symbol,""String_Node_Str""));
      jobs.add(generateDownloadJob(symbol,""String_Node_Str""));
      jobs.add(generateDownloadJob(symbol,""String_Node_Str""));
    }
  }
  for (  String symbol : withMythics) {
    ExpansionSet exp=Sets.findSet(symbol);
    if (exp != null && exp.getReleaseDate().before(compareDate)) {
      jobs.add(generateDownloadJob(symbol,""String_Node_Str""));
      jobs.add(generateDownloadJob(symbol,""String_Node_Str""));
      jobs.add(generateDownloadJob(symbol,""String_Node_Str""));
      jobs.add(generateDownloadJob(symbol,""String_Node_Str""));
    }
  }
  for (  String symbol : onlyMythics) {
    ExpansionSet exp=Sets.findSet(symbol);
    if (exp != null && exp.getReleaseDate().before(compareDate)) {
      jobs.add(generateDownloadJob(symbol,""String_Node_Str""));
    }
  }
  return jobs.iterator();
}","@Override public Iterator<DownloadJob> iterator(){
  Calendar c=Calendar.getInstance();
  c.setTime(new Date());
  c.add(Calendar.DATE,-14);
  Date compareDate=c.getTime();
  ArrayList<DownloadJob> jobs=new ArrayList<>();
  for (  String symbol : symbols) {
    ExpansionSet exp=Sets.findSet(symbol);
    if (exp != null && exp.getReleaseDate().before(compareDate)) {
      jobs.add(generateDownloadJob(symbol,""String_Node_Str"",""String_Node_Str""));
      jobs.add(generateDownloadJob(symbol,""String_Node_Str"",""String_Node_Str""));
      jobs.add(generateDownloadJob(symbol,""String_Node_Str"",""String_Node_Str""));
    }
  }
  for (  String symbol : withMythics) {
    ExpansionSet exp=Sets.findSet(symbol);
    if (exp != null && exp.getReleaseDate().before(compareDate)) {
      jobs.add(generateDownloadJob(symbol,""String_Node_Str"",""String_Node_Str""));
      jobs.add(generateDownloadJob(symbol,""String_Node_Str"",""String_Node_Str""));
      jobs.add(generateDownloadJob(symbol,""String_Node_Str"",""String_Node_Str""));
      jobs.add(generateDownloadJob(symbol,""String_Node_Str"",""String_Node_Str""));
    }
  }
  for (  String symbol : onlyMythics) {
    ExpansionSet exp=Sets.findSet(symbol);
    if (exp != null && exp.getReleaseDate().before(compareDate)) {
      jobs.add(generateDownloadJob(symbol,""String_Node_Str"",""String_Node_Str""));
    }
  }
  for (  String symbol : onlyMythicsAsSpecial) {
    ExpansionSet exp=Sets.findSet(symbol);
    if (exp != null && exp.getReleaseDate().before(compareDate)) {
      jobs.add(generateDownloadJob(symbol,""String_Node_Str"",""String_Node_Str""));
    }
  }
  return jobs.iterator();
}",0.8499298737727911
158170,"private DownloadJob generateDownloadJob(String set,String rarity){
  File dst=new File(outDir,set + ""String_Node_Str"" + rarity+ ""String_Node_Str"");
  if (symbolsReplacements.containsKey(set)) {
    set=symbolsReplacements.get(set);
  }
  String url=""String_Node_Str"" + set + ""String_Node_Str""+ rarity;
  return new DownloadJob(set + ""String_Node_Str"" + rarity,fromURL(url),toFile(dst));
}","private DownloadJob generateDownloadJob(String set,String rarity,String urlRarity){
  File dst=new File(outDir,set + ""String_Node_Str"" + rarity+ ""String_Node_Str"");
  if (symbolsReplacements.containsKey(set)) {
    set=symbolsReplacements.get(set);
  }
  String url=""String_Node_Str"" + set + ""String_Node_Str""+ urlRarity;
  return new DownloadJob(set + ""String_Node_Str"" + rarity,fromURL(url),toFile(dst));
}",0.9723618090452262
158171,"private MagicPlayerRewards(){
  super(""String_Node_Str"",""String_Node_Str"",ExpansionSet.buildDate(1990,1,1),SetType.PROMOTIONAL);
  this.hasBoosters=false;
  this.hasBasicLands=false;
  cards.add(new SetCardInfo(""String_Node_Str"",46,Rarity.SPECIAL,mage.cards.b.BituminousBlast.class));
  cards.add(new SetCardInfo(""String_Node_Str"",36,Rarity.SPECIAL,mage.cards.b.Blightning.class));
  cards.add(new SetCardInfo(""String_Node_Str"",50,Rarity.SPECIAL,mage.cards.b.BraveTheElements.class));
  cards.add(new SetCardInfo(""String_Node_Str"",47,Rarity.SPECIAL,mage.cards.b.BurstLightning.class));
  cards.add(new SetCardInfo(""String_Node_Str"",41,Rarity.SPECIAL,mage.cards.c.Cancel.class));
  cards.add(new SetCardInfo(""String_Node_Str"",45,Rarity.SPECIAL,mage.cards.c.CelestialPurge.class));
  cards.add(new SetCardInfo(""String_Node_Str"",18,Rarity.SPECIAL,mage.cards.c.Condemn.class));
  cards.add(new SetCardInfo(""String_Node_Str"",30,Rarity.SPECIAL,mage.cards.c.Corrupt.class));
  cards.add(new SetCardInfo(""String_Node_Str"",21,Rarity.SPECIAL,mage.cards.c.CruelEdict.class));
  cards.add(new SetCardInfo(""String_Node_Str"",31,Rarity.SPECIAL,mage.cards.c.CrypticCommand.class));
  cards.add(new SetCardInfo(""String_Node_Str"",24,Rarity.SPECIAL,mage.cards.d.Damnation.class));
  cards.add(new SetCardInfo(""String_Node_Str"",49,Rarity.SPECIAL,mage.cards.d.DayOfJudgment.class));
  cards.add(new SetCardInfo(""String_Node_Str"",22,Rarity.SPECIAL,mage.cards.d.Disenchant.class));
  cards.add(new SetCardInfo(""String_Node_Str"",51,Rarity.SPECIAL,mage.cards.d.DoomBlade.class));
  cards.add(new SetCardInfo(""String_Node_Str"",6,Rarity.SPECIAL,mage.cards.f.Fireball.class));
  cards.add(new SetCardInfo(""String_Node_Str"",32,Rarity.SPECIAL,mage.cards.f.FlameJavelin.class));
  cards.add(new SetCardInfo(""String_Node_Str"",13,Rarity.SPECIAL,mage.cards.g.GiantGrowth.class));
  cards.add(new SetCardInfo(""String_Node_Str"",28,Rarity.SPECIAL,mage.cards.h.Harmonize.class));
  cards.add(new SetCardInfo(""String_Node_Str"",48,Rarity.SPECIAL,mage.cards.h.Harrow.class));
  cards.add(new SetCardInfo(""String_Node_Str"",11,Rarity.SPECIAL,mage.cards.h.Hinder.class));
  cards.add(new SetCardInfo(""String_Node_Str"",10,Rarity.SPECIAL,mage.cards.h.HypnoticSpecter.class));
  cards.add(new SetCardInfo(""String_Node_Str"",26,Rarity.SPECIAL,mage.cards.i.Incinerate.class));
  cards.add(new SetCardInfo(""String_Node_Str"",43,Rarity.SPECIAL,mage.cards.i.Infest.class));
  cards.add(new SetCardInfo(""String_Node_Str"",40,Rarity.SPECIAL,mage.cards.l.LightningBolt.class));
  cards.add(new SetCardInfo(""String_Node_Str"",16,Rarity.SPECIAL,mage.cards.l.LightningHelix.class));
  cards.add(new SetCardInfo(""String_Node_Str"",8,Rarity.SPECIAL,mage.cards.m.ManaLeak.class));
  cards.add(new SetCardInfo(""String_Node_Str"",27,Rarity.SPECIAL,mage.cards.m.ManaTithe.class));
  cards.add(new SetCardInfo(""String_Node_Str"",19,Rarity.SPECIAL,mage.cards.m.Mortify.class));
  cards.add(new SetCardInfo(""String_Node_Str"",34,Rarity.SPECIAL,mage.cards.n.NamelessInversion.class));
  cards.add(new SetCardInfo(""String_Node_Str"",38,Rarity.SPECIAL,mage.cards.n.Negate.class));
  cards.add(new SetCardInfo(""String_Node_Str"",7,Rarity.SPECIAL,mage.cards.o.Oxidize.class));
  cards.add(new SetCardInfo(""String_Node_Str"",29,Rarity.SPECIAL,mage.cards.p.Ponder.class));
  cards.add(new SetCardInfo(""String_Node_Str"",3,Rarity.SPECIAL,mage.cards.p.PowderKeg.class));
  cards.add(new SetCardInfo(""String_Node_Str"",20,Rarity.COMMON,mage.cards.p.PsionicBlast.class));
  cards.add(new SetCardInfo(""String_Node_Str"",4,Rarity.SPECIAL,mage.cards.p.Psychatog.class));
  cards.add(new SetCardInfo(""String_Node_Str"",14,Rarity.SPECIAL,mage.cards.p.Putrefy.class));
  cards.add(new SetCardInfo(""String_Node_Str"",12,Rarity.SPECIAL,mage.cards.p.Pyroclasm.class));
  cards.add(new SetCardInfo(""String_Node_Str"",37,Rarity.SPECIAL,mage.cards.r.RampantGrowth.class));
  cards.add(new SetCardInfo(""String_Node_Str"",9,Rarity.SPECIAL,mage.cards.r.Reciprocate.class));
  cards.add(new SetCardInfo(""String_Node_Str"",23,Rarity.SPECIAL,mage.cards.r.Recollect.class));
  cards.add(new SetCardInfo(""String_Node_Str"",35,Rarity.SPECIAL,mage.cards.r.RemoveSoul.class));
  cards.add(new SetCardInfo(""String_Node_Str"",53,Rarity.SPECIAL,mage.cards.s.SearingBlaze.class));
  cards.add(new SetCardInfo(""String_Node_Str"",42,Rarity.SPECIAL,mage.cards.s.SignInBlood.class));
  cards.add(new SetCardInfo(""String_Node_Str"",39,Rarity.SPECIAL,mage.cards.t.Terminate.class));
  cards.add(new SetCardInfo(""String_Node_Str"",5,Rarity.SPECIAL,mage.cards.t.Terror.class));
  cards.add(new SetCardInfo(""String_Node_Str"",25,Rarity.SPECIAL,mage.cards.t.Tidings.class));
  cards.add(new SetCardInfo(""String_Node_Str"",52,Rarity.SPECIAL,mage.cards.t.TreasureHunt.class));
  cards.add(new SetCardInfo(""String_Node_Str"",33,Rarity.SPECIAL,mage.cards.u.Unmake.class));
  cards.add(new SetCardInfo(""String_Node_Str"",2,Rarity.SPECIAL,mage.cards.v.VoidmageProdigy.class));
  cards.add(new SetCardInfo(""String_Node_Str"",44,Rarity.SPECIAL,mage.cards.v.VolcanicFallout.class));
  cards.add(new SetCardInfo(""String_Node_Str"",1,Rarity.SPECIAL,mage.cards.w.Wasteland.class));
  cards.add(new SetCardInfo(""String_Node_Str"",17,Rarity.SPECIAL,mage.cards.w.WrathOfGod.class));
  cards.add(new SetCardInfo(""String_Node_Str"",15,Rarity.SPECIAL,mage.cards.z.Zombify.class));
}","private MagicPlayerRewards(){
  super(""String_Node_Str"",""String_Node_Str"",ExpansionSet.buildDate(1990,1,1),SetType.PROMOTIONAL);
  this.hasBoosters=false;
  this.hasBasicLands=false;
  CardGraphicInfo graphicInfo=new CardGraphicInfo(FrameStyle.MPRP_FULL_ART_BASIC,false);
  cards.add(new SetCardInfo(""String_Node_Str"",46,Rarity.SPECIAL,mage.cards.b.BituminousBlast.class,graphicInfo));
  cards.add(new SetCardInfo(""String_Node_Str"",36,Rarity.SPECIAL,mage.cards.b.Blightning.class,graphicInfo));
  cards.add(new SetCardInfo(""String_Node_Str"",50,Rarity.SPECIAL,mage.cards.b.BraveTheElements.class,graphicInfo));
  cards.add(new SetCardInfo(""String_Node_Str"",47,Rarity.SPECIAL,mage.cards.b.BurstLightning.class,graphicInfo));
  cards.add(new SetCardInfo(""String_Node_Str"",41,Rarity.SPECIAL,mage.cards.c.Cancel.class,graphicInfo));
  cards.add(new SetCardInfo(""String_Node_Str"",45,Rarity.SPECIAL,mage.cards.c.CelestialPurge.class,graphicInfo));
  cards.add(new SetCardInfo(""String_Node_Str"",18,Rarity.SPECIAL,mage.cards.c.Condemn.class,graphicInfo));
  cards.add(new SetCardInfo(""String_Node_Str"",30,Rarity.SPECIAL,mage.cards.c.Corrupt.class,graphicInfo));
  cards.add(new SetCardInfo(""String_Node_Str"",21,Rarity.SPECIAL,mage.cards.c.CruelEdict.class,graphicInfo));
  cards.add(new SetCardInfo(""String_Node_Str"",31,Rarity.SPECIAL,mage.cards.c.CrypticCommand.class,graphicInfo));
  cards.add(new SetCardInfo(""String_Node_Str"",24,Rarity.SPECIAL,mage.cards.d.Damnation.class,graphicInfo));
  cards.add(new SetCardInfo(""String_Node_Str"",49,Rarity.SPECIAL,mage.cards.d.DayOfJudgment.class,graphicInfo));
  cards.add(new SetCardInfo(""String_Node_Str"",22,Rarity.SPECIAL,mage.cards.d.Disenchant.class,graphicInfo));
  cards.add(new SetCardInfo(""String_Node_Str"",51,Rarity.SPECIAL,mage.cards.d.DoomBlade.class,graphicInfo));
  cards.add(new SetCardInfo(""String_Node_Str"",6,Rarity.SPECIAL,mage.cards.f.Fireball.class,graphicInfo));
  cards.add(new SetCardInfo(""String_Node_Str"",32,Rarity.SPECIAL,mage.cards.f.FlameJavelin.class,graphicInfo));
  cards.add(new SetCardInfo(""String_Node_Str"",13,Rarity.SPECIAL,mage.cards.g.GiantGrowth.class,graphicInfo));
  cards.add(new SetCardInfo(""String_Node_Str"",28,Rarity.SPECIAL,mage.cards.h.Harmonize.class,graphicInfo));
  cards.add(new SetCardInfo(""String_Node_Str"",48,Rarity.SPECIAL,mage.cards.h.Harrow.class,graphicInfo));
  cards.add(new SetCardInfo(""String_Node_Str"",11,Rarity.SPECIAL,mage.cards.h.Hinder.class,graphicInfo));
  cards.add(new SetCardInfo(""String_Node_Str"",10,Rarity.SPECIAL,mage.cards.h.HypnoticSpecter.class));
  cards.add(new SetCardInfo(""String_Node_Str"",26,Rarity.SPECIAL,mage.cards.i.Incinerate.class,graphicInfo));
  cards.add(new SetCardInfo(""String_Node_Str"",43,Rarity.SPECIAL,mage.cards.i.Infest.class,graphicInfo));
  cards.add(new SetCardInfo(""String_Node_Str"",40,Rarity.SPECIAL,mage.cards.l.LightningBolt.class,graphicInfo));
  cards.add(new SetCardInfo(""String_Node_Str"",16,Rarity.SPECIAL,mage.cards.l.LightningHelix.class,graphicInfo));
  cards.add(new SetCardInfo(""String_Node_Str"",8,Rarity.SPECIAL,mage.cards.m.ManaLeak.class,graphicInfo));
  cards.add(new SetCardInfo(""String_Node_Str"",27,Rarity.SPECIAL,mage.cards.m.ManaTithe.class,graphicInfo));
  cards.add(new SetCardInfo(""String_Node_Str"",19,Rarity.SPECIAL,mage.cards.m.Mortify.class,graphicInfo));
  cards.add(new SetCardInfo(""String_Node_Str"",34,Rarity.SPECIAL,mage.cards.n.NamelessInversion.class,graphicInfo));
  cards.add(new SetCardInfo(""String_Node_Str"",38,Rarity.SPECIAL,mage.cards.n.Negate.class,graphicInfo));
  cards.add(new SetCardInfo(""String_Node_Str"",7,Rarity.SPECIAL,mage.cards.o.Oxidize.class,graphicInfo));
  cards.add(new SetCardInfo(""String_Node_Str"",29,Rarity.SPECIAL,mage.cards.p.Ponder.class,graphicInfo));
  cards.add(new SetCardInfo(""String_Node_Str"",3,Rarity.SPECIAL,mage.cards.p.PowderKeg.class));
  cards.add(new SetCardInfo(""String_Node_Str"",20,Rarity.SPECIAL,mage.cards.p.PsionicBlast.class,graphicInfo));
  cards.add(new SetCardInfo(""String_Node_Str"",4,Rarity.SPECIAL,mage.cards.p.Psychatog.class));
  cards.add(new SetCardInfo(""String_Node_Str"",14,Rarity.SPECIAL,mage.cards.p.Putrefy.class,graphicInfo));
  cards.add(new SetCardInfo(""String_Node_Str"",12,Rarity.SPECIAL,mage.cards.p.Pyroclasm.class,graphicInfo));
  cards.add(new SetCardInfo(""String_Node_Str"",37,Rarity.SPECIAL,mage.cards.r.RampantGrowth.class,graphicInfo));
  cards.add(new SetCardInfo(""String_Node_Str"",9,Rarity.SPECIAL,mage.cards.r.Reciprocate.class,graphicInfo));
  cards.add(new SetCardInfo(""String_Node_Str"",23,Rarity.SPECIAL,mage.cards.r.Recollect.class,graphicInfo));
  cards.add(new SetCardInfo(""String_Node_Str"",35,Rarity.SPECIAL,mage.cards.r.RemoveSoul.class,graphicInfo));
  cards.add(new SetCardInfo(""String_Node_Str"",53,Rarity.SPECIAL,mage.cards.s.SearingBlaze.class,graphicInfo));
  cards.add(new SetCardInfo(""String_Node_Str"",42,Rarity.SPECIAL,mage.cards.s.SignInBlood.class,graphicInfo));
  cards.add(new SetCardInfo(""String_Node_Str"",39,Rarity.SPECIAL,mage.cards.t.Terminate.class,graphicInfo));
  cards.add(new SetCardInfo(""String_Node_Str"",5,Rarity.SPECIAL,mage.cards.t.Terror.class,graphicInfo));
  cards.add(new SetCardInfo(""String_Node_Str"",25,Rarity.SPECIAL,mage.cards.t.Tidings.class,graphicInfo));
  cards.add(new SetCardInfo(""String_Node_Str"",52,Rarity.SPECIAL,mage.cards.t.TreasureHunt.class,graphicInfo));
  cards.add(new SetCardInfo(""String_Node_Str"",33,Rarity.SPECIAL,mage.cards.u.Unmake.class,graphicInfo));
  cards.add(new SetCardInfo(""String_Node_Str"",2,Rarity.SPECIAL,mage.cards.v.VoidmageProdigy.class));
  cards.add(new SetCardInfo(""String_Node_Str"",44,Rarity.SPECIAL,mage.cards.v.VolcanicFallout.class,graphicInfo));
  cards.add(new SetCardInfo(""String_Node_Str"",1,Rarity.SPECIAL,mage.cards.w.Wasteland.class,graphicInfo));
  cards.add(new SetCardInfo(""String_Node_Str"",17,Rarity.SPECIAL,mage.cards.w.WrathOfGod.class,graphicInfo));
  cards.add(new SetCardInfo(""String_Node_Str"",15,Rarity.SPECIAL,mage.cards.z.Zombify.class,graphicInfo));
}",0.939002828854314
158172,"@Override public Iterator<DownloadJob> iterator(){
  Calendar c=Calendar.getInstance();
  c.setTime(new Date());
  c.add(Calendar.DATE,-14);
  Date compareDate=c.getTime();
  ArrayList<DownloadJob> jobs=new ArrayList<>();
  for (  String symbol : symbols) {
    ExpansionSet exp=Sets.findSet(symbol);
    if (exp != null && exp.getReleaseDate().before(compareDate)) {
      jobs.add(generateDownloadJob(symbol,""String_Node_Str"",""String_Node_Str""));
      jobs.add(generateDownloadJob(symbol,""String_Node_Str"",""String_Node_Str""));
      jobs.add(generateDownloadJob(symbol,""String_Node_Str"",""String_Node_Str""));
    }
  }
  for (  String symbol : withMythics) {
    ExpansionSet exp=Sets.findSet(symbol);
    if (exp != null && exp.getReleaseDate().before(compareDate)) {
      jobs.add(generateDownloadJob(symbol,""String_Node_Str"",""String_Node_Str""));
      jobs.add(generateDownloadJob(symbol,""String_Node_Str"",""String_Node_Str""));
      jobs.add(generateDownloadJob(symbol,""String_Node_Str"",""String_Node_Str""));
      jobs.add(generateDownloadJob(symbol,""String_Node_Str"",""String_Node_Str""));
    }
  }
  for (  String symbol : onlyMythics) {
    ExpansionSet exp=Sets.findSet(symbol);
    if (exp != null && exp.getReleaseDate().before(compareDate)) {
      jobs.add(generateDownloadJob(symbol,""String_Node_Str"",""String_Node_Str""));
    }
  }
  for (  String symbol : onlyMythicsAsSpecial) {
    ExpansionSet exp=Sets.findSet(symbol);
    if (exp != null && exp.getReleaseDate().before(compareDate)) {
      jobs.add(generateDownloadJob(symbol,""String_Node_Str"",""String_Node_Str""));
    }
  }
  return jobs.iterator();
}","@Override public Iterator<DownloadJob> iterator(){
  Calendar c=Calendar.getInstance();
  c.setTime(new Date());
  c.add(Calendar.DATE,+14);
  Date compareDate=c.getTime();
  ArrayList<DownloadJob> jobs=new ArrayList<>();
  for (  String symbol : symbols) {
    ExpansionSet exp=Sets.findSet(symbol);
    if (exp != null && exp.getReleaseDate().before(compareDate)) {
      jobs.add(generateDownloadJob(symbol,""String_Node_Str"",""String_Node_Str""));
      jobs.add(generateDownloadJob(symbol,""String_Node_Str"",""String_Node_Str""));
      jobs.add(generateDownloadJob(symbol,""String_Node_Str"",""String_Node_Str""));
    }
  }
  for (  String symbol : withMythics) {
    ExpansionSet exp=Sets.findSet(symbol);
    if (exp != null && exp.getReleaseDate().before(compareDate)) {
      jobs.add(generateDownloadJob(symbol,""String_Node_Str"",""String_Node_Str""));
      jobs.add(generateDownloadJob(symbol,""String_Node_Str"",""String_Node_Str""));
      jobs.add(generateDownloadJob(symbol,""String_Node_Str"",""String_Node_Str""));
      jobs.add(generateDownloadJob(symbol,""String_Node_Str"",""String_Node_Str""));
    }
  }
  for (  String symbol : onlyMythics) {
    ExpansionSet exp=Sets.findSet(symbol);
    if (exp != null && exp.getReleaseDate().before(compareDate)) {
      jobs.add(generateDownloadJob(symbol,""String_Node_Str"",""String_Node_Str""));
    }
  }
  for (  String symbol : onlyMythicsAsSpecial) {
    ExpansionSet exp=Sets.findSet(symbol);
    if (exp != null && exp.getReleaseDate().before(compareDate)) {
      jobs.add(generateDownloadJob(symbol,""String_Node_Str"",""String_Node_Str""));
    }
  }
  return jobs.iterator();
}",0.9993838570548368
158173,"private void startGame(UUID choosingPlayerId) throws GameException {
  try {
    match.startGame();
    table.initGame();
    GameOptions gameOptions=new GameOptions();
    gameOptions.rollbackTurnsAllowed=match.getOptions().isRollbackTurnsAllowed();
    match.getGame().setGameOptions(gameOptions);
    GameManager.getInstance().createGameSession(match.getGame(),userPlayerMap,table.getId(),choosingPlayerId,gameOptions);
    String creator=null;
    StringBuilder opponent=new StringBuilder();
    for (    Entry<UUID,UUID> entry : userPlayerMap.entrySet()) {
      if (match.getPlayer(entry.getValue()) != null && !match.getPlayer(entry.getValue()).hasQuit()) {
        Optional<User> _user=UserManager.getInstance().getUser(entry.getKey());
        if (!_user.isPresent()) {
          User user=_user.get();
          user.ccGameStarted(match.getGame().getId(),entry.getValue());
          if (creator == null) {
            creator=user.getName();
          }
 else {
            if (opponent.length() > 0) {
              opponent.append(""String_Node_Str"");
            }
            opponent.append(user.getName());
          }
        }
 else {
          logger.error(""String_Node_Str"" + entry.getKey() + ""String_Node_Str""+ entry.getValue());
          MatchPlayer matchPlayer=match.getPlayer(entry.getValue());
          if (matchPlayer != null && !matchPlayer.hasQuit()) {
            matchPlayer.setQuit(true);
          }
        }
      }
    }
    for (    MatchPlayer mPlayer : match.getPlayers()) {
      if (!mPlayer.getPlayer().isHuman()) {
        if (opponent.length() > 0) {
          opponent.append(""String_Node_Str"");
        }
        opponent.append(mPlayer.getName());
      }
    }
    ServerMessagesUtil.getInstance().incGamesStarted();
    logger.info(""String_Node_Str"" + (match.getGame() != null ? match.getGame().getId() : ""String_Node_Str"") + ""String_Node_Str""+ match.getName()+ ""String_Node_Str""+ creator+ ""String_Node_Str""+ opponent.toString());
    logger.debug(""String_Node_Str"" + match.getId() + ""String_Node_Str""+ match.getName()+ ""String_Node_Str"");
    if (match.getGame() != null) {
      logger.debug(""String_Node_Str"" + GameManager.getInstance().getChatId(match.getGame().getId()));
    }
  }
 catch (  Exception ex) {
    logger.fatal(""String_Node_Str"" + table.getId(),ex);
    if (table != null) {
      TableManager.getInstance().removeTable(table.getId());
    }
    if (match != null) {
      Game game=match.getGame();
      if (game != null) {
        GameManager.getInstance().removeGame(game.getId());
      }
    }
  }
}","private void startGame(UUID choosingPlayerId) throws GameException {
  try {
    match.startGame();
    table.initGame();
    GameOptions gameOptions=new GameOptions();
    gameOptions.rollbackTurnsAllowed=match.getOptions().isRollbackTurnsAllowed();
    match.getGame().setGameOptions(gameOptions);
    GameManager.getInstance().createGameSession(match.getGame(),userPlayerMap,table.getId(),choosingPlayerId,gameOptions);
    String creator=null;
    StringBuilder opponent=new StringBuilder();
    for (    Entry<UUID,UUID> entry : userPlayerMap.entrySet()) {
      if (match.getPlayer(entry.getValue()) != null && !match.getPlayer(entry.getValue()).hasQuit()) {
        Optional<User> _user=UserManager.getInstance().getUser(entry.getKey());
        if (_user.isPresent()) {
          User user=_user.get();
          user.ccGameStarted(match.getGame().getId(),entry.getValue());
          if (creator == null) {
            creator=user.getName();
          }
 else {
            if (opponent.length() > 0) {
              opponent.append(""String_Node_Str"");
            }
            opponent.append(user.getName());
          }
        }
 else {
          logger.error(""String_Node_Str"" + entry.getKey() + ""String_Node_Str""+ entry.getValue());
          MatchPlayer matchPlayer=match.getPlayer(entry.getValue());
          if (matchPlayer != null && !matchPlayer.hasQuit()) {
            matchPlayer.setQuit(true);
          }
        }
      }
    }
    for (    MatchPlayer mPlayer : match.getPlayers()) {
      if (!mPlayer.getPlayer().isHuman()) {
        if (opponent.length() > 0) {
          opponent.append(""String_Node_Str"");
        }
        opponent.append(mPlayer.getName());
      }
    }
    ServerMessagesUtil.getInstance().incGamesStarted();
    logger.info(""String_Node_Str"" + (match.getGame() != null ? match.getGame().getId() : ""String_Node_Str"") + ""String_Node_Str""+ match.getName()+ ""String_Node_Str""+ creator+ ""String_Node_Str""+ opponent.toString());
    logger.debug(""String_Node_Str"" + match.getId() + ""String_Node_Str""+ match.getName()+ ""String_Node_Str"");
    if (match.getGame() != null) {
      logger.debug(""String_Node_Str"" + GameManager.getInstance().getChatId(match.getGame().getId()));
    }
  }
 catch (  Exception ex) {
    logger.fatal(""String_Node_Str"" + table.getId(),ex);
    if (table != null) {
      TableManager.getInstance().removeTable(table.getId());
    }
    if (match != null) {
      Game game=match.getGame();
      if (game != null) {
        GameManager.getInstance().removeGame(game.getId());
      }
    }
  }
}",0.9998057120652808
158174,"@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller != null) {
    new GetEnergyCountersControllerEffect(2).apply(game,source);
    if (controller.getCounters().getCount(CounterType.ENERGY) > 5) {
      Cost cost=new PayEnergyCost(6);
      if (cost.pay(source,game,source.getSourceId(),source.getControllerId(),true)) {
        new UntapAllControllerEffect(new FilterControlledCreaturePermanent(),""String_Node_Str"").apply(game,source);
        new AdditionalCombatPhaseEffect(""String_Node_Str"").apply(game,source);
      }
    }
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller != null) {
    new GetEnergyCountersControllerEffect(2).apply(game,source);
    if (controller.getCounters().getCount(CounterType.ENERGY) > 7) {
      Cost cost=new PayEnergyCost(8);
      if (controller.chooseUse(outcome,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",source,game) && cost.pay(source,game,source.getSourceId(),source.getControllerId(),true)) {
        new UntapAllControllerEffect(new FilterControlledCreaturePermanent()).apply(game,source);
        new AdditionalCombatPhaseEffect().apply(game,source);
      }
    }
    return true;
  }
  return false;
}",0.6988472622478387
158175,"@Override public boolean apply(Game game,Ability source){
  Player player=game.getPlayer(source.getControllerId());
  if (player != null) {
    return player.addCounters(CounterType.ENERGY.createInstance(value.calculate(game,source,this)),game);
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller != null) {
    return controller.addCounters(CounterType.ENERGY.createInstance(value.calculate(game,source,this)),game);
  }
  return false;
}",0.934065934065934
158176,"@Override public boolean apply(Game game,Ability source){
  RevoltWatcher watcher=(RevoltWatcher)game.getState().getWatchers().get(""String_Node_Str"");
  return watcher != null && watcher.revoltActive(source.getControllerId());
}","@Override public boolean apply(Game game,Ability source){
  RevoltWatcher watcher=(RevoltWatcher)game.getState().getWatchers().get(RevoltWatcher.class.getName());
  return watcher != null && watcher.revoltActive(source.getControllerId());
}",0.905982905982906
158177,"public RevoltWatcher(final RevoltWatcher watcher){
  super(watcher);
}","public RevoltWatcher(final RevoltWatcher watcher){
  super(watcher);
  this.revoltActivePlayerIds.addAll(watcher.revoltActivePlayerIds);
}",0.6730769230769231
158178,"public boolean activate(Game game,boolean noMana){
  if (!spellAbilities.get(0).activate(game,noMana)) {
    return false;
  }
  if (spellAbilities.size() > 1) {
    boolean ignoreAbility=true;
    boolean payNoMana=noMana;
    for (    SpellAbility spellAbility : spellAbilities) {
      if (ignoreAbility) {
        ignoreAbility=false;
      }
 else {
        payNoMana|=spellAbility.getSpellAbilityType().equals(SpellAbilityType.SPLICE);
        if (!spellAbility.activate(game,payNoMana)) {
          return false;
        }
      }
    }
  }
  return true;
}","public boolean activate(Game game,boolean noMana){
  if (!spellAbilities.get(0).activate(game,noMana)) {
    return false;
  }
  if (spellAbilities.size() > 1) {
    boolean ignoreAbility=true;
    boolean payNoMana=noMana;
    for (    SpellAbility spellAbility : spellAbilities) {
      if (ignoreAbility) {
        ignoreAbility=false;
      }
 else {
        payNoMana|=spellAbility.getSpellAbilityType().equals(SpellAbilityType.SPLICE);
        if (!spellAbility.activate(game,payNoMana)) {
          return false;
        }
      }
    }
  }
  setDoneActivatingManaAbilities(false);
  return true;
}",0.9649272882805816
158179,"@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller != null) {
    Set<Card> toExile=new LinkedHashSet<>();
    if (multitargetHandling && source.getTargets().size() > 1 && targetPointer instanceof FirstTargetPointer) {
      for (      Target target : source.getTargets()) {
        for (        UUID targetId : target.getTargets()) {
          Permanent permanent=game.getPermanent(targetId);
          if (permanent != null) {
            Zone currentZone=game.getState().getZone(permanent.getId());
            if (!currentZone.equals(Zone.EXILED) && (onlyFromZone == null || onlyFromZone.equals(Zone.BATTLEFIELD))) {
              toExile.add(permanent);
            }
          }
 else {
            Card card=game.getCard(targetId);
            if (card != null) {
              Zone currentZone=game.getState().getZone(card.getId());
              if (!currentZone.equals(Zone.EXILED) && (onlyFromZone == null || onlyFromZone.equals(currentZone))) {
                toExile.add(card);
              }
            }
          }
        }
      }
    }
 else {
      for (      UUID targetId : getTargetPointer().getTargets(game,source)) {
        Permanent permanent=game.getPermanent(targetId);
        if (permanent != null) {
          Zone currentZone=game.getState().getZone(permanent.getId());
          if (!currentZone.equals(Zone.EXILED) && (onlyFromZone == null || onlyFromZone.equals(Zone.BATTLEFIELD))) {
            toExile.add(permanent);
          }
        }
 else {
          Card card=game.getCard(targetId);
          if (card != null) {
            Zone currentZone=game.getState().getZone(card.getId());
            if (!currentZone.equals(Zone.EXILED) && (onlyFromZone == null || onlyFromZone.equals(currentZone))) {
              toExile.add(card);
            }
          }
 else {
            StackObject stackObject=game.getStack().getStackObject(targetId);
            if (stackObject instanceof Spell && ((Spell)stackObject).getCard() != null) {
              toExile.add(((Spell)stackObject).getCard());
            }
          }
        }
      }
    }
    controller.moveCardsToExile(toExile,source,game,true,exileId,exileZone);
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller != null) {
    Set<Card> toExile=new LinkedHashSet<>();
    if (multitargetHandling && source.getTargets().size() > 1 && targetPointer instanceof FirstTargetPointer) {
      for (      Target target : source.getTargets()) {
        for (        UUID targetId : target.getTargets()) {
          Permanent permanent=game.getPermanent(targetId);
          if (permanent != null) {
            Zone currentZone=game.getState().getZone(permanent.getId());
            if (!currentZone.equals(Zone.EXILED) && (onlyFromZone == null || onlyFromZone.equals(Zone.BATTLEFIELD))) {
              toExile.add(permanent);
            }
          }
 else {
            Card card=game.getCard(targetId);
            if (card != null) {
              Zone currentZone=game.getState().getZone(card.getId());
              if (!currentZone.equals(Zone.EXILED) && (onlyFromZone == null || onlyFromZone.equals(currentZone))) {
                toExile.add(card);
              }
            }
          }
        }
      }
    }
 else {
      for (      UUID targetId : getTargetPointer().getTargets(game,source)) {
        Permanent permanent=game.getPermanent(targetId);
        if (permanent != null) {
          Zone currentZone=game.getState().getZone(permanent.getId());
          if (!currentZone.equals(Zone.EXILED) && (onlyFromZone == null || onlyFromZone.equals(Zone.BATTLEFIELD))) {
            toExile.add(permanent);
          }
        }
 else {
          Card card=game.getCard(targetId);
          if (card != null) {
            Zone currentZone=game.getState().getZone(card.getId());
            if (!currentZone.equals(Zone.EXILED) && (onlyFromZone == null || onlyFromZone.equals(currentZone))) {
              toExile.add(card);
            }
          }
 else {
            StackObject stackObject=game.getStack().getStackObject(targetId);
            if (stackObject instanceof Spell) {
              toExile.add((Spell)stackObject);
            }
          }
        }
      }
    }
    controller.moveCardsToExile(toExile,source,game,true,exileId,exileZone);
    return true;
  }
  return false;
}",0.932832523199293
158180,"@Override public boolean moveCardToExileWithInfo(Card card,UUID exileId,String exileName,UUID sourceId,Game game,Zone fromZone,boolean withName){
  boolean result=false;
  if (card.moveToExile(exileId,exileName,sourceId,game)) {
    if (!game.isSimulation()) {
      if (card instanceof PermanentCard) {
        Card basicCard=game.getCard(card.getId());
        if (basicCard != null) {
          card=basicCard;
        }
      }
      game.informPlayers(this.getLogName() + ""String_Node_Str"" + (withName ? card.getLogName() : ""String_Node_Str"")+ ""String_Node_Str""+ (fromZone != null ? ""String_Node_Str"" + fromZone.toString().toLowerCase(Locale.ENGLISH) + ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str"");
    }
    result=true;
  }
  return result;
}","@Override public boolean moveCardToExileWithInfo(Card card,UUID exileId,String exileName,UUID sourceId,Game game,Zone fromZone,boolean withName){
  boolean result=false;
  if (card.moveToExile(exileId,exileName,sourceId,game)) {
    if (!game.isSimulation()) {
      if (card instanceof PermanentCard) {
        Card basicCard=game.getCard(card.getId());
        if (basicCard != null) {
          card=basicCard;
        }
      }
      game.informPlayers(this.getLogName() + ""String_Node_Str"" + (withName ? card.getLogName() + (card.isCopy() ? ""String_Node_Str"" : ""String_Node_Str"") : ""String_Node_Str"")+ ""String_Node_Str""+ (fromZone != null ? ""String_Node_Str"" + fromZone.toString().toLowerCase(Locale.ENGLISH) + ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str"");
    }
    result=true;
  }
  return result;
}",0.9633838383838385
158181,"/** 
 * @param ability
 * @param available    if null, it won't be checked if enough mana is available
 * @param sourceObject
 * @param game
 * @return
 */
protected boolean canPlay(ActivatedAbility ability,ManaOptions available,MageObject sourceObject,Game game){
  if (!(ability instanceof ActivatedManaAbilityImpl)) {
    ActivatedAbility copy=ability.copy();
    copy.setCheckPlayableMode();
    if (!copy.canActivate(playerId,game)) {
      return false;
    }
    game.getContinuousEffects().costModification(copy,game);
    Card card=game.getCard(ability.getSourceId());
    if (card != null) {
      for (      Ability ability0 : card.getAbilities()) {
        if (ability0 instanceof AdjustingSourceCosts) {
          if (!(ability0 instanceof ConvokeAbility)) {
            ((AdjustingSourceCosts)ability0).adjustCosts(copy,game);
          }
        }
      }
    }
    boolean canBeCastRegularly=true;
    if (copy instanceof SpellAbility && copy.getManaCosts().isEmpty() && copy.getCosts().isEmpty()) {
      canBeCastRegularly=false;
    }
    if (canBeCastRegularly) {
      ManaOptions abilityOptions=copy.getMinimumCostToActivate(playerId,game);
      if (abilityOptions.isEmpty()) {
        return true;
      }
 else {
        if (available == null) {
          return true;
        }
        boolean spendAnyMana=game.getContinuousEffects().asThough(ability.getSourceId(),AsThoughEffectType.SPEND_OTHER_MANA,ability,ability.getControllerId(),game);
        for (        Mana mana : abilityOptions) {
          for (          Mana avail : available) {
            if (spendAnyMana && mana.count() <= avail.count()) {
              return true;
            }
            if (mana.enough(avail)) {
              return true;
            }
          }
        }
      }
    }
    for (    Ability objectAbility : sourceObject.getAbilities()) {
      if (objectAbility instanceof AlternativeCostSourceAbility) {
        if (objectAbility.getCosts().canPay(ability,ability.getSourceId(),playerId,game)) {
          return true;
        }
      }
    }
    if (canPlayCardByAlternateCost(card,available,ability,game)) {
      return true;
    }
  }
  return false;
}","/** 
 * @param ability
 * @param available if null, it won't be checked if enough mana is available
 * @param sourceObject
 * @param game
 * @return
 */
protected boolean canPlay(ActivatedAbility ability,ManaOptions available,MageObject sourceObject,Game game){
  if (!(ability instanceof ActivatedManaAbilityImpl)) {
    ActivatedAbility copy=ability.copy();
    copy.setCheckPlayableMode();
    if (!copy.canActivate(playerId,game)) {
      return false;
    }
    game.getContinuousEffects().costModification(copy,game);
    Card card=game.getCard(ability.getSourceId());
    if (card != null) {
      for (      Ability ability0 : card.getAbilities()) {
        if (ability0 instanceof AdjustingSourceCosts) {
          if (!(ability0 instanceof ConvokeAbility)) {
            ((AdjustingSourceCosts)ability0).adjustCosts(copy,game);
          }
        }
      }
    }
    boolean canBeCastRegularly=true;
    if (copy instanceof SpellAbility && copy.getManaCosts().isEmpty() && copy.getCosts().isEmpty()) {
      canBeCastRegularly=false;
    }
    if (canBeCastRegularly) {
      ManaOptions abilityOptions=copy.getMinimumCostToActivate(playerId,game);
      if (abilityOptions.isEmpty()) {
        return true;
      }
 else {
        if (available == null) {
          return true;
        }
        boolean spendAnyMana=game.getContinuousEffects().asThough(ability.getSourceId(),AsThoughEffectType.SPEND_OTHER_MANA,ability,ability.getControllerId(),game);
        for (        Mana mana : abilityOptions) {
          for (          Mana avail : available) {
            if (spendAnyMana && mana.count() <= avail.count()) {
              return true;
            }
            if (mana.enough(avail)) {
              return true;
            }
          }
        }
      }
    }
    for (    Ability objectAbility : sourceObject.getAbilities()) {
      if (objectAbility instanceof AlternativeCostSourceAbility) {
        if (objectAbility.getCosts().canPay(ability,ability.getSourceId(),playerId,game)) {
          return true;
        }
      }
    }
    if (canPlayCardByAlternateCost(card,available,ability,game)) {
      return true;
    }
  }
  return false;
}",0.9993111366245696
158182,"@Override public boolean apply(Game game,Ability source){
  for (  UUID targetPlayerId : targetPointer.getTargets(game,source)) {
    Player player=game.getPlayer(targetPlayerId);
    if (player != null) {
      player.discard(amount.calculate(game,source,this),randomDiscard,source,game);
    }
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  for (  UUID targetPlayerId : targetPointer.getTargets(game,source)) {
    Player player=game.getPlayer(targetPlayerId);
    if (player != null) {
      player.discard(amount.calculate(game,source,this),randomDiscard,source,game);
    }
  }
  return true;
}",0.966153846153846
158183,"public LazavDimirEffect(final LazavDimirEffect effect){
  super(effect);
  this.cardToCopy=effect.cardToCopy;
  this.IdOfCopiedCard=effect.IdOfCopiedCard;
}","public LazavDimirEffect(final LazavDimirEffect effect){
  super(effect);
  this.cardToCopy=effect.cardToCopy;
}",0.8314606741573034
158184,"@Override public boolean apply(Game game,Ability source){
  Card card=game.getCard(((FixedTarget)getTargetPointer()).getTarget());
  Permanent permanent=game.getPermanent(source.getSourceId());
  if (card == null || permanent == null) {
    discard();
    return false;
  }
  if (IdOfCopiedCard == null || !IdOfCopiedCard.equals(card.getId())) {
    IdOfCopiedCard=card.getId();
    cardToCopy=card.copy();
    cardToCopy.assignNewId();
  }
  permanent.getPower().setValue(cardToCopy.getPower().getValue());
  permanent.getToughness().setValue(cardToCopy.getToughness().getValue());
  permanent.getColor(game).setColor(cardToCopy.getColor(game));
  permanent.getManaCost().clear();
  permanent.getManaCost().add(cardToCopy.getManaCost());
  permanent.getCardType().clear();
  for (  CardType type : cardToCopy.getCardType()) {
    if (!permanent.getCardType().contains(type)) {
      permanent.getCardType().add(type);
    }
  }
  permanent.getSubtype(game).clear();
  for (  String type : cardToCopy.getSubtype(game)) {
    if (!permanent.getSubtype(game).contains(type)) {
      permanent.getSubtype(game).add(type);
    }
  }
  permanent.getSupertype().clear();
  permanent.getSupertype().add(""String_Node_Str"");
  for (  String type : cardToCopy.getSupertype()) {
    if (!permanent.getSupertype().contains(type)) {
      permanent.getSupertype().add(type);
    }
  }
  permanent.removeAllAbilities(source.getSourceId(),game);
  permanent.addAbility(HexproofAbility.getInstance(),source.getSourceId(),game);
  permanent.addAbility(new PutCardIntoGraveFromAnywhereAllTriggeredAbility(new LazavDimirEffect(),true,new FilterCreatureCard(""String_Node_Str""),TargetController.OPPONENT,SetTargetPointer.CARD),source.getSourceId(),game);
  for (  Ability ability : cardToCopy.getAbilities()) {
    if (!permanent.getAbilities().contains(ability)) {
      permanent.addAbility(ability,source.getSourceId(),game);
    }
  }
  return true;
}","@Override public boolean apply(Game game,Ability source){
  Permanent permanent=game.getPermanent(source.getSourceId());
  if (permanent == null) {
    discard();
    return true;
  }
  permanent.getPower().setValue(cardToCopy.getPower().getValue());
  permanent.getToughness().setValue(cardToCopy.getToughness().getValue());
  permanent.getColor(game).setColor(cardToCopy.getColor(game));
  permanent.getManaCost().clear();
  permanent.getManaCost().add(cardToCopy.getManaCost());
  permanent.getCardType().clear();
  for (  CardType type : cardToCopy.getCardType()) {
    if (!permanent.getCardType().contains(type)) {
      permanent.getCardType().add(type);
    }
  }
  permanent.getSubtype(game).clear();
  for (  String type : cardToCopy.getSubtype(game)) {
    if (!permanent.getSubtype(game).contains(type)) {
      permanent.getSubtype(game).add(type);
    }
  }
  permanent.getSupertype().clear();
  permanent.getSupertype().add(""String_Node_Str"");
  for (  String type : cardToCopy.getSupertype()) {
    if (!permanent.getSupertype().contains(type)) {
      permanent.getSupertype().add(type);
    }
  }
  permanent.removeAllAbilities(source.getSourceId(),game);
  permanent.addAbility(HexproofAbility.getInstance(),source.getSourceId(),game);
  permanent.addAbility(new PutCardIntoGraveFromAnywhereAllTriggeredAbility(new LazavDimirEffect(),true,new FilterCreatureCard(""String_Node_Str""),TargetController.OPPONENT,SetTargetPointer.CARD),source.getSourceId(),game);
  for (  Ability ability : cardToCopy.getAbilities()) {
    if (!permanent.getAbilities().contains(ability)) {
      permanent.addAbility(ability,source.getSourceId(),game);
    }
  }
  return true;
}",0.9111049570756024
158185,"@Override public boolean apply(Game game,Ability source){
  FairgroundsTrumpeterWatcher watcher=(FairgroundsTrumpeterWatcher)game.getState().getWatchers().get(""String_Node_Str"");
  return watcher != null && watcher.p1p1AddedToPermanent(source.getControllerId());
}","@Override public boolean apply(Game game,Ability source){
  FairgroundsTrumpeterWatcher watcher=(FairgroundsTrumpeterWatcher)game.getState().getWatchers().get(FairgroundsTrumpeterWatcher.class.getName());
  return watcher != null && watcher.p1p1AddedToPermanent(source.getControllerId());
}",0.8953068592057761
158186,"@Override public void watch(GameEvent event,Game game){
  if (event.getType() == GameEvent.EventType.COUNTER_ADDED && event.getData().equals(CounterType.P1P1.getName())) {
    Permanent permanent=game.getPermanentOrLKIBattlefield(event.getTargetId());
    if (permanent != null && permanent.getCardType().contains(CardType.CREATURE)) {
      players.add(permanent.getControllerId());
    }
  }
}","@Override public void watch(GameEvent event,Game game){
  if (event.getType() == GameEvent.EventType.COUNTER_ADDED && event.getData().equals(CounterType.P1P1.getName())) {
    Permanent permanent=game.getPermanentOrLKIBattlefield(event.getTargetId());
    if (permanent != null) {
      players.add(permanent.getControllerId());
    }
  }
}",0.9251700680272108
158187,"@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller != null) {
    Player player=game.getPlayer(getTargetPointer().getFirst(game,source));
    if (player != null) {
      for (      Counter counter : player.getCounters().values()) {
        counter.increase();
      }
    }
    Permanent permanent=game.getPermanent(getTargetPointer().getFirst(game,source));
    if (permanent != null) {
      for (      Counter counter : permanent.getCounters(game).values()) {
        counter.increase();
      }
    }
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller != null) {
    Player player=game.getPlayer(getTargetPointer().getFirst(game,source));
    if (player != null) {
      Counters counters=player.getCounters().copy();
      for (      Counter counter : counters.values()) {
        CounterType counterType=CounterType.findByName(counter.getName());
        Counter counterToAdd;
        if (counterType != null) {
          counterToAdd=counterType.createInstance();
        }
 else {
          counterToAdd=new Counter(counter.getName());
        }
        player.addCounters(counterToAdd,game);
      }
      return true;
    }
    Permanent permanent=game.getPermanent(getTargetPointer().getFirst(game,source));
    if (permanent != null) {
      Counters counters=permanent.getCounters(game).copy();
      for (      Counter counter : counters.values()) {
        CounterType counterType=CounterType.findByName(counter.getName());
        Counter counterToAdd;
        if (counterType != null) {
          counterToAdd=counterType.createInstance();
        }
 else {
          counterToAdd=new Counter(counter.getName());
        }
        permanent.addCounters(counterToAdd,source,game);
      }
    }
    return true;
  }
  return false;
}",0.5400714650331802
158188,"@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller != null) {
    Player player=game.getPlayer(getTargetPointer().getFirst(game,source));
    if (player != null) {
      for (      Counter counter : player.getCounters().values()) {
        counter.increase();
      }
    }
    Permanent permanent=game.getPermanent(getTargetPointer().getFirst(game,source));
    if (permanent != null) {
      for (      Counter counter : permanent.getCounters(game).values()) {
        counter.increase();
      }
    }
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller != null) {
    Player player=game.getPlayer(getTargetPointer().getFirst(game,source));
    if (player != null) {
      Counters counters=player.getCounters().copy();
      for (      Counter counter : counters.values()) {
        CounterType counterType=CounterType.findByName(counter.getName());
        Counter counterToAdd;
        if (counterType != null) {
          counterToAdd=counterType.createInstance();
        }
 else {
          counterToAdd=new Counter(counter.getName());
        }
        player.addCounters(counterToAdd,game);
      }
      return true;
    }
    Permanent permanent=game.getPermanent(getTargetPointer().getFirst(game,source));
    if (permanent != null) {
      Counters counters=permanent.getCounters(game).copy();
      for (      Counter counter : counters.values()) {
        CounterType counterType=CounterType.findByName(counter.getName());
        Counter counterToAdd;
        if (counterType != null) {
          counterToAdd=counterType.createInstance();
        }
 else {
          counterToAdd=new Counter(counter.getName());
        }
        permanent.addCounters(counterToAdd,source,game);
      }
    }
    return true;
  }
  return false;
}",0.5400714650331802
158189,"@Override public boolean apply(Game game,Ability source){
  Player player=game.getPlayer(source.getControllerId());
  ManaCostsImpl cost=new ManaCostsImpl(""String_Node_Str"");
  if (player != null) {
    if (player.chooseUse(Outcome.Benefit,""String_Node_Str"" + cost.getText() + ""String_Node_Str"",source,game)) {
      if (cost.pay(source,game,source.getSourceId(),source.getControllerId(),false,null)) {
        StackAbility ability=(StackAbility)getValue(""String_Node_Str"");
        Player controller=game.getPlayer(source.getControllerId());
        Permanent sourcePermanent=game.getPermanent(source.getSourceId());
        if (ability != null && controller != null) {
          ability.createCopyOnStack(game,source,source.getControllerId(),true);
          game.informPlayers(new StringBuilder(sourcePermanent.getName()).append(""String_Node_Str"").append(controller.getLogName()).append(""String_Node_Str"").toString());
          return true;
        }
        return false;
      }
    }
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Player player=game.getPlayer(source.getControllerId());
  ManaCostsImpl cost=new ManaCostsImpl(""String_Node_Str"");
  if (player != null) {
    if (player.chooseUse(Outcome.Benefit,""String_Node_Str"" + cost.getText() + ""String_Node_Str"",source,game)) {
      if (cost.pay(source,game,source.getSourceId(),source.getControllerId(),false,null)) {
        StackAbility ability=(StackAbility)getValue(""String_Node_Str"");
        Player controller=game.getPlayer(source.getControllerId());
        Permanent sourcePermanent=game.getPermanentOrLKIBattlefield(source.getSourceId());
        if (ability != null && controller != null && sourcePermanent != null) {
          ability.createCopyOnStack(game,source,source.getControllerId(),true);
          game.informPlayers(sourcePermanent.getIdName() + ""String_Node_Str"" + controller.getLogName()+ ""String_Node_Str"");
          return true;
        }
        return false;
      }
    }
  }
  return false;
}",0.9455445544554456
158190,"@Override public String getText(Mode mode){
  StringBuilder sb=new StringBuilder(""String_Node_Str"");
  sb.append(mode.getTargets().get(0).getTargetName());
  sb.append(""String_Node_Str"");
  if (targetZone.equals(Zone.EXILED)) {
    sb.append(""String_Node_Str"");
  }
  if (targetZone.equals(Zone.HAND)) {
    sb.append(""String_Node_Str"");
  }
  if (targetZone.equals(Zone.LIBRARY)) {
    sb.append(""String_Node_Str"");
switch (zoneDetail) {
case BOTTOM:
      sb.append(""String_Node_Str"");
case TOP:
    sb.append(""String_Node_Str"");
case CHOOSE:
  sb.append(""String_Node_Str"");
case NONE:
sb.append(""String_Node_Str"");
}
sb.append(""String_Node_Str"");
}
return sb.toString();
}","@Override public String getText(Mode mode){
  StringBuilder sb=new StringBuilder(""String_Node_Str"");
  sb.append(mode.getTargets().get(0).getTargetName());
  sb.append(""String_Node_Str"");
  if (targetZone.equals(Zone.EXILED)) {
    sb.append(""String_Node_Str"");
  }
  if (targetZone.equals(Zone.HAND)) {
    sb.append(""String_Node_Str"");
  }
  if (targetZone.equals(Zone.LIBRARY)) {
    sb.append(""String_Node_Str"");
switch (zoneDetail) {
case BOTTOM:
      sb.append(""String_Node_Str"");
    break;
case TOP:
  sb.append(""String_Node_Str"");
break;
case CHOOSE:
sb.append(""String_Node_Str"");
break;
case NONE:
sb.append(""String_Node_Str"");
break;
}
sb.append(""String_Node_Str"");
}
return sb.toString();
}",0.8925979680696662
158191,"/** 
 * Creates new form TablesPanel
 */
public TablesPanel(){
  tableModel=new TableTableModel();
  matchesModel=new MatchesTableModel();
  gameChooser=new GameChooser();
  initComponents();
  tableTables.createDefaultColumnsFromModel();
  activeTablesSorter=new MageTableRowSorter(tableModel);
  tableTables.setRowSorter(activeTablesSorter);
  TableUtil.setColumnWidthAndOrder(tableTables,DEFAULT_COLUMNS_WIDTH,PreferencesDialog.KEY_TABLES_COLUMNS_WIDTH,PreferencesDialog.KEY_TABLES_COLUMNS_ORDER);
  tableCompleted.setRowSorter(new MageTableRowSorter(matchesModel));
  chatPanelMain.getUserChatPanel().useExtendedView(ChatPanelBasic.VIEW_MODE.NONE);
  chatPanelMain.getUserChatPanel().setBorder(null);
  chatPanelMain.getUserChatPanel().setChatType(ChatPanelBasic.ChatType.TABLES);
  filterButtons=new JToggleButton[]{btnStateWaiting,btnStateActive,btnStateFinished,btnTypeMatch,btnTypeTourneyConstructed,btnTypeTourneyLimited,btnFormatBlock,btnFormatStandard,btnFormatModern,btnFormatLegacy,btnFormatVintage,btnFormatCommander,btnFormatTinyLeader,btnFormatLimited,btnFormatOther,btnSkillBeginner,btnSkillCasual,btnSkillSerious,btnRated,btnUnrated,btnOpen,btnPassword};
  JComponent[] components=new JComponent[]{chatPanelMain,jSplitPane1,jScrollPaneTablesActive,jScrollPaneTablesFinished,jPanelTop,jPanelTables};
  for (  JComponent component : components) {
    component.setOpaque(false);
  }
  jScrollPaneTablesActive.getViewport().setBackground(new Color(255,255,255,50));
  jScrollPaneTablesFinished.getViewport().setBackground(new Color(255,255,255,50));
  restoreSettings();
  setGUISize();
  Action openTableAction;
  openTableAction=new AbstractAction(){
    @Override public void actionPerformed(    ActionEvent e){
      int modelRow=Integer.valueOf(e.getActionCommand());
      UUID tableId=(UUID)tableModel.getValueAt(modelRow,TableTableModel.ACTION_COLUMN + 3);
      UUID gameId=(UUID)tableModel.getValueAt(modelRow,TableTableModel.ACTION_COLUMN + 2);
      String action=(String)tableModel.getValueAt(modelRow,TableTableModel.ACTION_COLUMN);
      String deckType=(String)tableModel.getValueAt(modelRow,TableTableModel.COLUMN_DECK_TYPE);
      String status=(String)tableModel.getValueAt(modelRow,TableTableModel.COLUMN_STATUS);
      boolean isTournament=(Boolean)tableModel.getValueAt(modelRow,TableTableModel.ACTION_COLUMN + 1);
      String owner=(String)tableModel.getValueAt(modelRow,TableTableModel.COLUMN_OWNER);
switch (action) {
case ""String_Node_Str"":
        if (owner.equals(SessionHandler.getUserName()) || owner.startsWith(SessionHandler.getUserName() + ""String_Node_Str"")) {
          try {
            JDesktopPane desktopPane=(JDesktopPane)MageFrame.getUI().getComponent(MageComponents.DESKTOP_PANE);
            JInternalFrame[] windows=desktopPane.getAllFramesInLayer(javax.swing.JLayeredPane.DEFAULT_LAYER);
            for (            JInternalFrame frame : windows) {
              if (frame.getTitle().equals(""String_Node_Str"")) {
                frame.toFront();
                frame.setVisible(true);
                try {
                  frame.setSelected(true);
                }
 catch (                PropertyVetoException ve) {
                  LOGGER.error(ve);
                }
              }
            }
          }
 catch (          InterruptedException ex) {
            LOGGER.error(ex);
          }
          return;
        }
      if (isTournament) {
        LOGGER.info(""String_Node_Str"" + tableId);
        if (deckType.startsWith(""String_Node_Str"")) {
          if (!status.endsWith(""String_Node_Str"")) {
            SessionHandler.joinTournamentTable(roomId,tableId,SessionHandler.getUserName(),""String_Node_Str"",1,null,""String_Node_Str"");
          }
 else {
            joinTableDialog.showDialog(roomId,tableId,true,deckType.startsWith(""String_Node_Str""));
          }
        }
 else {
          joinTableDialog.showDialog(roomId,tableId,true,deckType.startsWith(""String_Node_Str""));
        }
      }
 else {
        LOGGER.info(""String_Node_Str"" + tableId);
        joinTableDialog.showDialog(roomId,tableId,false,false);
      }
    break;
case ""String_Node_Str"":
  UserRequestMessage message=new UserRequestMessage(""String_Node_Str"",""String_Node_Str"");
message.setButton1(""String_Node_Str"",null);
message.setButton2(""String_Node_Str"",PlayerAction.CLIENT_REMOVE_TABLE);
MageFrame.getInstance().showUserRequestDialog(message);
break;
case ""String_Node_Str"":
if (isTournament) {
LOGGER.info(""String_Node_Str"" + tableId);
SessionHandler.watchTable(roomId,tableId);
}
break;
case ""String_Node_Str"":
if (!isTournament) {
LOGGER.info(""String_Node_Str"" + tableId);
SessionHandler.watchTable(roomId,tableId);
}
break;
case ""String_Node_Str"":
LOGGER.info(""String_Node_Str"" + gameId);
SessionHandler.replayGame(gameId);
break;
}
}
}
;
Action closedTableAction;
closedTableAction=new AbstractAction(){
@Override public void actionPerformed(ActionEvent e){
int modelRow=Integer.valueOf(e.getActionCommand());
String action=(String)matchesModel.getValueAt(modelRow,MatchesTableModel.ACTION_COLUMN);
switch (action) {
case ""String_Node_Str"":
List<UUID> gameList=matchesModel.getListofGames(modelRow);
if (gameList != null && gameList.size() > 0) {
if (gameList.size() == 1) {
SessionHandler.replayGame(gameList.get(0));
}
 else {
gameChooser.show(gameList,MageFrame.getDesktop().getMousePosition());
}
}
break;
case ""String_Node_Str"":
if (matchesModel.isTournament(modelRow)) {
LOGGER.info(""String_Node_Str"" + matchesModel.getTableId(modelRow));
SessionHandler.watchTable(roomId,matchesModel.getTableId(modelRow));
}
break;
}
}
}
;
actionButton1=new ButtonColumn(tableTables,openTableAction,tableTables.convertColumnIndexToView(TableTableModel.ACTION_COLUMN));
actionButton2=new ButtonColumn(tableCompleted,closedTableAction,tableCompleted.convertColumnIndexToView(MatchesTableModel.ACTION_COLUMN));
}","/** 
 * Creates new form TablesPanel
 */
public TablesPanel(){
  tableModel=new TableTableModel();
  matchesModel=new MatchesTableModel();
  gameChooser=new GameChooser();
  initComponents();
  tableTables.createDefaultColumnsFromModel();
  activeTablesSorter=new MageTableRowSorter(tableModel);
  tableTables.setRowSorter(activeTablesSorter);
  TableUtil.setColumnWidthAndOrder(tableTables,DEFAULT_COLUMNS_WIDTH,PreferencesDialog.KEY_TABLES_COLUMNS_WIDTH,PreferencesDialog.KEY_TABLES_COLUMNS_ORDER);
  tableCompleted.setRowSorter(new MageTableRowSorter(matchesModel));
  chatPanelMain.getUserChatPanel().useExtendedView(ChatPanelBasic.VIEW_MODE.NONE);
  chatPanelMain.getUserChatPanel().setBorder(null);
  chatPanelMain.getUserChatPanel().setChatType(ChatPanelBasic.ChatType.TABLES);
  filterButtons=new JToggleButton[]{btnStateWaiting,btnStateActive,btnStateFinished,btnTypeMatch,btnTypeTourneyConstructed,btnTypeTourneyLimited,btnFormatBlock,btnFormatStandard,btnFormatModern,btnFormatLegacy,btnFormatVintage,btnFormatCommander,btnFormatTinyLeader,btnFormatLimited,btnFormatOther,btnSkillBeginner,btnSkillCasual,btnSkillSerious,btnRated,btnUnrated,btnOpen,btnPassword};
  JComponent[] components=new JComponent[]{chatPanelMain,jSplitPane1,jScrollPaneTablesActive,jScrollPaneTablesFinished,jPanelTop,jPanelTables};
  for (  JComponent component : components) {
    component.setOpaque(false);
  }
  jScrollPaneTablesActive.getViewport().setBackground(new Color(255,255,255,50));
  jScrollPaneTablesFinished.getViewport().setBackground(new Color(255,255,255,50));
  restoreSettings();
  setGUISize();
  Action openTableAction;
  openTableAction=new AbstractAction(){
    @Override public void actionPerformed(    ActionEvent e){
      int modelRow=Integer.valueOf(e.getActionCommand());
      UUID tableId=(UUID)tableModel.getValueAt(modelRow,TableTableModel.ACTION_COLUMN + 3);
      UUID gameId=(UUID)tableModel.getValueAt(modelRow,TableTableModel.ACTION_COLUMN + 2);
      String action=(String)tableModel.getValueAt(modelRow,TableTableModel.ACTION_COLUMN);
      String deckType=(String)tableModel.getValueAt(modelRow,TableTableModel.COLUMN_DECK_TYPE);
      boolean isTournament=(Boolean)tableModel.getValueAt(modelRow,TableTableModel.ACTION_COLUMN + 1);
      String owner=(String)tableModel.getValueAt(modelRow,TableTableModel.COLUMN_OWNER);
      String pwdColumn=(String)tableModel.getValueAt(modelRow,TableTableModel.COLUMN_PASSWORD);
switch (action) {
case ""String_Node_Str"":
        if (owner.equals(SessionHandler.getUserName()) || owner.startsWith(SessionHandler.getUserName() + ""String_Node_Str"")) {
          try {
            JDesktopPane desktopPane=(JDesktopPane)MageFrame.getUI().getComponent(MageComponents.DESKTOP_PANE);
            JInternalFrame[] windows=desktopPane.getAllFramesInLayer(javax.swing.JLayeredPane.DEFAULT_LAYER);
            for (            JInternalFrame frame : windows) {
              if (frame.getTitle().equals(""String_Node_Str"")) {
                frame.toFront();
                frame.setVisible(true);
                try {
                  frame.setSelected(true);
                }
 catch (                PropertyVetoException ve) {
                  LOGGER.error(ve);
                }
              }
            }
          }
 catch (          InterruptedException ex) {
            LOGGER.error(ex);
          }
          return;
        }
      if (isTournament) {
        LOGGER.info(""String_Node_Str"" + tableId);
        if (deckType.startsWith(""String_Node_Str"")) {
          if (PASSWORDED.equals(pwdColumn)) {
            joinTableDialog.showDialog(roomId,tableId,true,deckType.startsWith(""String_Node_Str""));
          }
 else {
            SessionHandler.joinTournamentTable(roomId,tableId,SessionHandler.getUserName(),""String_Node_Str"",1,null,""String_Node_Str"");
          }
        }
 else {
          joinTableDialog.showDialog(roomId,tableId,true,deckType.startsWith(""String_Node_Str""));
        }
      }
 else {
        LOGGER.info(""String_Node_Str"" + tableId);
        joinTableDialog.showDialog(roomId,tableId,false,false);
      }
    break;
case ""String_Node_Str"":
  UserRequestMessage message=new UserRequestMessage(""String_Node_Str"",""String_Node_Str"");
message.setButton1(""String_Node_Str"",null);
message.setButton2(""String_Node_Str"",PlayerAction.CLIENT_REMOVE_TABLE);
MageFrame.getInstance().showUserRequestDialog(message);
break;
case ""String_Node_Str"":
if (isTournament) {
LOGGER.info(""String_Node_Str"" + tableId);
SessionHandler.watchTable(roomId,tableId);
}
break;
case ""String_Node_Str"":
if (!isTournament) {
LOGGER.info(""String_Node_Str"" + tableId);
SessionHandler.watchTable(roomId,tableId);
}
break;
case ""String_Node_Str"":
LOGGER.info(""String_Node_Str"" + gameId);
SessionHandler.replayGame(gameId);
break;
}
}
}
;
Action closedTableAction;
closedTableAction=new AbstractAction(){
@Override public void actionPerformed(ActionEvent e){
int modelRow=Integer.valueOf(e.getActionCommand());
String action=(String)matchesModel.getValueAt(modelRow,MatchesTableModel.ACTION_COLUMN);
switch (action) {
case ""String_Node_Str"":
List<UUID> gameList=matchesModel.getListofGames(modelRow);
if (gameList != null && gameList.size() > 0) {
if (gameList.size() == 1) {
SessionHandler.replayGame(gameList.get(0));
}
 else {
gameChooser.show(gameList,MageFrame.getDesktop().getMousePosition());
}
}
break;
case ""String_Node_Str"":
if (matchesModel.isTournament(modelRow)) {
LOGGER.info(""String_Node_Str"" + matchesModel.getTableId(modelRow));
SessionHandler.watchTable(roomId,matchesModel.getTableId(modelRow));
}
break;
}
}
}
;
actionButton1=new ButtonColumn(tableTables,openTableAction,tableTables.convertColumnIndexToView(TableTableModel.ACTION_COLUMN));
actionButton2=new ButtonColumn(tableCompleted,closedTableAction,tableCompleted.convertColumnIndexToView(MatchesTableModel.ACTION_COLUMN));
}",0.9521049940344298
158192,"@Override public boolean apply(Game game,Ability source){
  RevoltWatcher watcher=(RevoltWatcher)game.getState().getWatchers().get(""String_Node_Str"");
  return watcher.revoltActive(source.getControllerId());
}","@Override public boolean apply(Game game,Ability source){
  RevoltWatcher watcher=(RevoltWatcher)game.getState().getWatchers().get(""String_Node_Str"");
  return watcher != null && watcher.revoltActive(source.getControllerId());
}",0.9565217391304348
158193,"@Override public boolean applies(UUID objectId,Ability source,UUID affectedControllerId,Game game){
  Card card=game.getCard(objectId);
  if (card != null && affectedControllerId.equals(card.getOwnerId()) && game.getState().getZone(card.getId()) == Zone.EXILED) {
    HashSet<MageObjectReference> exiledCardsByPlayer=(HashSet)game.getState().getValue(UbaMask.UBA_MASK_VALUE_KEY + affectedControllerId);
    if (exiledCardsByPlayer != null) {
      return exiledCardsByPlayer.contains(new MageObjectReference(card,game));
    }
  }
  return false;
}","@Override public boolean applies(UUID objectId,Ability source,UUID affectedControllerId,Game game){
  Card card=game.getCard(objectId);
  if (card != null && affectedControllerId.equals(card.getOwnerId()) && game.getState().getZone(card.getId()) == Zone.EXILED) {
    UbaMaskExiledCardsWatcher watcher=(UbaMaskExiledCardsWatcher)game.getState().getWatchers().get(UbaMaskExiledCardsWatcher.class.getName());
    if (watcher != null) {
      List<MageObjectReference> exiledThisTurn=watcher.getUbaMaskExiledCardsThisTurn(affectedControllerId);
      return exiledThisTurn != null && exiledThisTurn.contains(new MageObjectReference(card,game));
    }
  }
  return false;
}",0.5127362366474938
158194,"@Override public boolean checksEventType(GameEvent event,Game game){
  return event.getType() == GameEvent.EventType.DRAW_CARD || event.getType() == GameEvent.EventType.PLAY_TURN;
}","@Override public boolean checksEventType(GameEvent event,Game game){
  return event.getType() == GameEvent.EventType.DRAW_CARD;
}",0.832258064516129
158195,"@Override public boolean replaceEvent(GameEvent event,Ability source,Game game){
  if (event.getType().equals(GameEvent.EventType.PLAY_TURN)) {
    for (    UUID playerId : game.getPlayerList()) {
      game.getState().setValue(UbaMask.UBA_MASK_VALUE_KEY + source.getSourceId() + playerId,null);
    }
    return false;
  }
  MageObject sourceObject=source.getSourceObject(game);
  Player player=game.getPlayer(event.getPlayerId());
  if (player != null && sourceObject != null) {
    Card card=player.getLibrary().getFromTop(game);
    if (card != null) {
      player.moveCardsToExile(card,source,game,true,source.getId(),sourceObject.getIdName());
      HashSet<MageObjectReference> exiledCardsByPlayer=(HashSet)game.getState().getValue(UbaMask.UBA_MASK_VALUE_KEY + event.getPlayerId());
      if (exiledCardsByPlayer == null) {
        exiledCardsByPlayer=new HashSet<>();
        game.getState().setValue(UbaMask.UBA_MASK_VALUE_KEY + event.getPlayerId(),exiledCardsByPlayer);
      }
      exiledCardsByPlayer.add(new MageObjectReference(card.getId(),game));
    }
  }
  return true;
}","@Override public boolean replaceEvent(GameEvent event,Ability source,Game game){
  MageObject sourceObject=source.getSourceObject(game);
  Player player=game.getPlayer(event.getPlayerId());
  if (player != null && sourceObject != null) {
    Card card=player.getLibrary().getFromTop(game);
    if (card != null) {
      if (player.moveCardsToExile(card,source,game,true,source.getSourceId(),sourceObject.getIdName())) {
        UbaMaskExiledCardsWatcher watcher=(UbaMaskExiledCardsWatcher)game.getState().getWatchers().get(UbaMaskExiledCardsWatcher.class.getName());
        if (watcher != null) {
          watcher.addExiledCard(event.getPlayerId(),card,game);
        }
      }
    }
  }
  return true;
}",0.4966592427616926
158196,"@Override public UbaMaskPlayEffect copy(){
  return new UbaMaskPlayEffect(this);
}","@Override public UbaMaskExiledCardsWatcher copy(){
  return new UbaMaskExiledCardsWatcher(this);
}",0.7555555555555555
158197,"/** 
 * Tooth and Nail off a cascade is bugged. It let me pay the entwine cost for free even though I had no mana open and the entwine is an additional cost.
 */
@Test public void testHaveToPayAdditionalCosts(){
  playerA.getLibrary().clear();
  addCard(Zone.LIBRARY,playerA,""String_Node_Str"",2);
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"",3);
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"",3);
  addCard(Zone.HAND,playerA,""String_Node_Str"");
  castSpell(1,PhaseStep.PRECOMBAT_MAIN,playerA,""String_Node_Str"");
  setStopAt(1,PhaseStep.END_TURN);
  execute();
  assertPermanentCount(playerA,""String_Node_Str"",1);
  assertLife(playerA,15);
  assertHandCount(playerA,5);
  assertPermanentCount(playerA,""String_Node_Str"",1);
}","/** 
 * Tooth and Nail off a cascade is bugged. It let me pay the entwine cost for free even though I had no mana open and the entwine is an additional cost.
 */
@Test public void testHaveToPayAdditionalCosts(){
  playerA.getLibrary().clear();
  addCard(Zone.LIBRARY,playerA,""String_Node_Str"",2);
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"",3);
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"",3);
  addCard(Zone.HAND,playerA,""String_Node_Str"");
  castSpell(1,PhaseStep.PRECOMBAT_MAIN,playerA,""String_Node_Str"");
  setStopAt(1,PhaseStep.END_TURN);
  execute();
  assertPermanentCount(playerA,""String_Node_Str"",1);
  assertLife(playerA,15);
  assertHandCount(playerA,5);
  assertPermanentCount(playerA,""String_Node_Str"",0);
}",0.9986431478968792
158198,"@Override public boolean checkTrigger(GameEvent event,Game game){
  Player you=game.getPlayer(this.getControllerId());
  Player upkeepPlayer=game.getPlayer(event.getPlayerId());
  if (you != null && upkeepPlayer != null && upkeepPlayer.getHand().isEmpty()) {
    you.drawCards(1,game);
    you.loseLife(1,game,false);
    return true;
  }
  return false;
}","@Override public boolean checkTrigger(GameEvent event,Game game){
  Player upkeepPlayer=game.getPlayer(event.getPlayerId());
  if (upkeepPlayer != null && upkeepPlayer.getHand().isEmpty()) {
    return true;
  }
  return false;
}",0.5538461538461539
158199,"@Override public AsylumVisitorTriggeredAbility copy(){
  return new AsylumVisitorTriggeredAbility(this);
}","@Override public AsylumVisitorEffect copy(){
  return new AsylumVisitorEffect(this);
}",0.8125
158200,"@Override public SpinedSliver copy(){
  return new SpinedSliver(this);
}","@Override public BlockersCount copy(){
  return new BlockersCount(this);
}",0.7397260273972602
158201,"@Override public boolean chooseTargetAmount(Outcome outcome,TargetAmount target,Ability source,Game game){
  if (log.isDebugEnabled()) {
    log.debug(""String_Node_Str"" + outcome.toString() + ""String_Node_Str""+ target.toString());
  }
  UUID opponentId=game.getOpponents(playerId).iterator().next();
  if (target instanceof TargetCreatureOrPlayerAmount) {
    if (outcome.equals(Outcome.Damage) && game.getPlayer(opponentId).getLife() <= target.getAmountRemaining()) {
      target.addTarget(opponentId,target.getAmountRemaining(),source,game);
      return true;
    }
    List<Permanent> targets;
    if (outcome.isGood()) {
      targets=threats(playerId,source.getSourceId(),new FilterCreaturePermanent(),game,target.getTargets());
    }
 else {
      targets=threats(opponentId,source.getSourceId(),new FilterCreaturePermanent(),game,target.getTargets());
    }
    for (    Permanent permanent : targets) {
      if (target.canTarget(getId(),permanent.getId(),source,game)) {
        if (permanent.getToughness().getValue() <= target.getAmountRemaining()) {
          target.addTarget(permanent.getId(),permanent.getToughness().getValue(),source,game);
          return true;
        }
      }
    }
    if (outcome.isGood() && target.canTarget(getId(),getId(),source,game)) {
      target.addTarget(opponentId,target.getAmountRemaining(),source,game);
      return true;
    }
 else     if (target.canTarget(getId(),opponentId,source,game)) {
      target.addTarget(opponentId,target.getAmountRemaining(),source,game);
      return true;
    }
 else     if (target.canTarget(getId(),playerId,source,game)) {
      target.addTarget(opponentId,target.getAmountRemaining(),source,game);
      return true;
    }
  }
  return false;
}","@Override public boolean chooseTargetAmount(Outcome outcome,TargetAmount target,Ability source,Game game){
  if (log.isDebugEnabled()) {
    log.debug(""String_Node_Str"" + outcome.toString() + ""String_Node_Str""+ target.toString());
  }
  UUID opponentId=game.getOpponents(playerId).iterator().next();
  if (target.getOriginalTarget() instanceof TargetCreatureOrPlayerAmount) {
    if (outcome.equals(Outcome.Damage) && game.getPlayer(opponentId).getLife() <= target.getAmountRemaining()) {
      target.addTarget(opponentId,target.getAmountRemaining(),source,game);
      return true;
    }
    List<Permanent> targets;
    if (outcome.isGood()) {
      targets=threats(playerId,source.getSourceId(),new FilterCreaturePermanent(),game,target.getTargets());
    }
 else {
      targets=threats(opponentId,source.getSourceId(),new FilterCreaturePermanent(),game,target.getTargets());
    }
    for (    Permanent permanent : targets) {
      if (target.canTarget(getId(),permanent.getId(),source,game)) {
        if (permanent.getToughness().getValue() <= target.getAmountRemaining()) {
          target.addTarget(permanent.getId(),permanent.getToughness().getValue(),source,game);
          return true;
        }
      }
    }
    if (outcome.isGood() && target.canTarget(getId(),getId(),source,game)) {
      target.addTarget(opponentId,target.getAmountRemaining(),source,game);
      return true;
    }
 else     if (target.canTarget(getId(),opponentId,source,game)) {
      target.addTarget(opponentId,target.getAmountRemaining(),source,game);
      return true;
    }
 else     if (target.canTarget(getId(),playerId,source,game)) {
      target.addTarget(opponentId,target.getAmountRemaining(),source,game);
      return true;
    }
  }
  return false;
}",0.9942759015455066
158202,"/** 
 * Sets a possible target player
 */
private boolean setTargetPlayer(Outcome outcome,Target target,Ability source,UUID sourceId,UUID abilityControllerId,UUID randomOpponentId,Game game){
  if (target instanceof TargetOpponent) {
    if (source == null) {
      if (((TargetOpponent)target).canTarget(randomOpponentId,game)) {
        target.add(randomOpponentId,game);
        return true;
      }
    }
 else     if (((TargetOpponent)target).canTarget(randomOpponentId,source,game)) {
      target.add(randomOpponentId,game);
      return true;
    }
    for (    UUID currentId : game.getOpponents(abilityControllerId)) {
      if (source == null) {
        if (((TargetOpponent)target).canTarget(currentId,game)) {
          target.add(currentId,game);
          return true;
        }
      }
 else       if (((TargetOpponent)target).canTarget(currentId,source,game)) {
        target.add(currentId,game);
        return true;
      }
    }
    return false;
  }
  if (target instanceof TargetPlayer) {
    if (outcome.isGood()) {
      if (source == null) {
        if (target.canTarget(abilityControllerId,game)) {
          target.add(abilityControllerId,game);
          return true;
        }
        if (target.isRequired(sourceId,game)) {
          if (target.canTarget(randomOpponentId,game)) {
            target.add(randomOpponentId,game);
            return true;
          }
        }
      }
 else {
        if (target.canTarget(abilityControllerId,abilityControllerId,source,game)) {
          target.addTarget(playerId,source,game);
          return true;
        }
        if (target.isRequired(sourceId,game)) {
          if (target.canTarget(randomOpponentId,game)) {
            target.add(randomOpponentId,game);
            return true;
          }
        }
      }
    }
 else     if (source == null) {
      if (target.canTarget(randomOpponentId,game)) {
        target.add(randomOpponentId,game);
        return true;
      }
      if (target.isRequired(sourceId,game)) {
        if (target.canTarget(abilityControllerId,game)) {
          target.add(abilityControllerId,game);
          return true;
        }
      }
    }
 else {
      if (target.canTarget(randomOpponentId,game)) {
        target.add(randomOpponentId,game);
        return true;
      }
      if (target.isRequired(sourceId,game)) {
        if (target.canTarget(abilityControllerId,game)) {
          target.add(abilityControllerId,game);
          return true;
        }
      }
    }
    return false;
  }
  return false;
}","/** 
 * Sets a possible target player
 */
private boolean setTargetPlayer(Outcome outcome,Target target,Ability source,UUID sourceId,UUID abilityControllerId,UUID randomOpponentId,Game game){
  if (target.getOriginalTarget() instanceof TargetOpponent) {
    if (source == null) {
      if (((TargetOpponent)target).canTarget(randomOpponentId,game)) {
        target.add(randomOpponentId,game);
        return true;
      }
    }
 else     if (((TargetOpponent)target).canTarget(randomOpponentId,source,game)) {
      target.add(randomOpponentId,game);
      return true;
    }
    for (    UUID currentId : game.getOpponents(abilityControllerId)) {
      if (source == null) {
        if (((TargetOpponent)target).canTarget(currentId,game)) {
          target.add(currentId,game);
          return true;
        }
      }
 else       if (((TargetOpponent)target).canTarget(currentId,source,game)) {
        target.add(currentId,game);
        return true;
      }
    }
    return false;
  }
  if (target.getOriginalTarget() instanceof TargetPlayer) {
    if (outcome.isGood()) {
      if (source == null) {
        if (target.canTarget(abilityControllerId,game)) {
          target.add(abilityControllerId,game);
          return true;
        }
        if (target.isRequired(sourceId,game)) {
          if (target.canTarget(randomOpponentId,game)) {
            target.add(randomOpponentId,game);
            return true;
          }
        }
      }
 else {
        if (target.canTarget(abilityControllerId,abilityControllerId,source,game)) {
          target.addTarget(playerId,source,game);
          return true;
        }
        if (target.isRequired(sourceId,game)) {
          if (target.canTarget(randomOpponentId,game)) {
            target.add(randomOpponentId,game);
            return true;
          }
        }
      }
    }
 else     if (source == null) {
      if (target.canTarget(randomOpponentId,game)) {
        target.add(randomOpponentId,game);
        return true;
      }
      if (target.isRequired(sourceId,game)) {
        if (target.canTarget(abilityControllerId,game)) {
          target.add(abilityControllerId,game);
          return true;
        }
      }
    }
 else {
      if (target.canTarget(randomOpponentId,game)) {
        target.add(randomOpponentId,game);
        return true;
      }
      if (target.isRequired(sourceId,game)) {
        if (target.canTarget(abilityControllerId,game)) {
          target.add(abilityControllerId,game);
          return true;
        }
      }
    }
    return false;
  }
  return false;
}",0.992156862745098
158203,"public TargetWithAdditionalFilter(Target originalTarget,FilterInPlay<T> additionalFilter,boolean notTarget){
  originalTarget=originalTarget.copy();
  originalTarget.clearChosen();
  this.originalTarget=originalTarget;
  this.targetName=originalTarget.getFilter().getMessage();
  this.notTarget=notTarget;
  this.additionalFilter=additionalFilter;
}","public TargetWithAdditionalFilter(Target originalTarget,FilterInPlay<T> additionalFilter,boolean notTarget){
  this.originalTarget=originalTarget.copy();
  this.originalTarget.clearChosen();
  this.targetName=originalTarget.getFilter().getMessage();
  this.notTarget=notTarget;
  this.additionalFilter=additionalFilter;
}",0.6686567164179105
158204,"public PreventDamageToSourceByCardTypeEffect(CardType cardT){
  super(Duration.WhileOnBattlefield);
  cardType=cardT;
}","public PreventDamageToSourceByCardTypeEffect(final PreventDamageToSourceByCardTypeEffect effect){
  super(effect.duration);
}",0.6311475409836066
158205,"@Override public boolean applies(GameEvent event,Ability source,Game game){
  if (super.applies(event,source,game)) {
    if (game.getObject(event.getSourceId()).getCardType().contains(cardType)) {
      if (event.getTargetId().equals(source.getSourceId())) {
        return true;
      }
    }
  }
  return false;
}","@Override public boolean applies(GameEvent event,Ability source,Game game){
  if (super.applies(event,source,game)) {
    MageObject sourceObject=game.getObject(event.getSourceId());
    if (sourceObject != null && sourceObject.getCardType().contains(CardType.CREATURE)) {
      if (event.getTargetId().equals(source.getSourceId())) {
        return true;
      }
    }
  }
  return false;
}",0.7920792079207921
158206,"@Override public UncleIstvan copy(){
  return new UncleIstvan(this);
}","@Override public PreventAllDamageToSourceEffect copy(){
  return new PreventAllDamageToSourceEffect(this);
}",0.6292134831460674
158207,"private void checkForNewImages(){
  long beforeCall=System.currentTimeMillis();
  missingCards=CardRepository.instance.findCards(new CardCriteria());
  LOGGER.info(""String_Node_Str"" + ((System.currentTimeMillis() - beforeCall) / 1000 + ""String_Node_Str""));
  beforeCall=System.currentTimeMillis();
  if (DownloadPictures.checkForNewCards(missingCards)) {
    LOGGER.info(""String_Node_Str"" + ((System.currentTimeMillis() - beforeCall) / 1000 + ""String_Node_Str""));
    UserRequestMessage message=new UserRequestMessage(""String_Node_Str"",""String_Node_Str"" + missingCards.size() + ""String_Node_Str""+ ""String_Node_Str"");
    message.setButton1(""String_Node_Str"",null);
    message.setButton2(""String_Node_Str"",PlayerAction.CLIENT_DOWNLOAD_CARD_IMAGES);
    showUserRequestDialog(message);
  }
}","private void checkForNewImages(){
  long beforeCall=System.currentTimeMillis();
  missingCards=CardRepository.instance.findCards(new CardCriteria());
  LOGGER.info(""String_Node_Str"" + ((System.currentTimeMillis() - beforeCall) / 1000 + ""String_Node_Str""));
  beforeCall=System.currentTimeMillis();
  if (DownloadPictures.checkForMissingCardImages(missingCards)) {
    LOGGER.info(""String_Node_Str"" + ((System.currentTimeMillis() - beforeCall) / 1000 + ""String_Node_Str""));
    UserRequestMessage message=new UserRequestMessage(""String_Node_Str"",""String_Node_Str"" + missingCards.size() + ""String_Node_Str""+ ""String_Node_Str"");
    message.setButton1(""String_Node_Str"",null);
    message.setButton2(""String_Node_Str"",PlayerAction.CLIENT_DOWNLOAD_CARD_IMAGES);
    showUserRequestDialog(message);
  }
}",0.9855254877281308
158208,"private void jToggleCardViewActionPerformed(java.awt.event.ActionEvent evt){
  if (currentView.cardsSize() > CardGrid.MAX_IMAGES) {
    jToggleCardView.setSelected(false);
    jToggleListView.setSelected(true);
    JOptionPane.showMessageDialog(this,new StringBuilder(""String_Node_Str"").append(CardGrid.MAX_IMAGES).append(""String_Node_Str"").toString());
  }
 else {
    if (!(currentView instanceof CardGrid)) {
      toggleViewMode();
    }
    filterCards();
  }
}","private void jToggleCardViewActionPerformed(java.awt.event.ActionEvent evt){
  if (currentView.cardsSize() > CardGrid.MAX_IMAGES) {
    jToggleCardView.setSelected(false);
    jToggleListView.setSelected(true);
    MageFrame.getInstance().showMessage(""String_Node_Str"" + CardGrid.MAX_IMAGES + ""String_Node_Str"");
  }
 else {
    if (!(currentView instanceof CardGrid)) {
      toggleViewMode();
    }
    filterCards();
  }
}",0.8888888888888888
158209,"private void btnBoosterActionPerformed(java.awt.event.ActionEvent evt){
  List<String> sets=ConstructedFormats.getSetsByFormat(this.cbExpansionSet.getSelectedItem().toString());
  if (sets.size() == 1) {
    if (!this.limited) {
      this.limited=true;
      cards.clear();
    }
    ExpansionSet expansionSet=Sets.getInstance().get(sets.get(0));
    if (expansionSet != null) {
      List<Card> booster=expansionSet.createBooster();
      cards.addAll(booster);
      filterCards();
    }
  }
 else {
    JOptionPane.showMessageDialog(null,""String_Node_Str"");
  }
}","private void btnBoosterActionPerformed(java.awt.event.ActionEvent evt){
  List<String> sets=ConstructedFormats.getSetsByFormat(this.cbExpansionSet.getSelectedItem().toString());
  if (sets.size() == 1) {
    if (!this.limited) {
      this.limited=true;
      cards.clear();
    }
    ExpansionSet expansionSet=Sets.getInstance().get(sets.get(0));
    if (expansionSet != null) {
      List<Card> booster=expansionSet.createBooster();
      cards.addAll(booster);
      filterCards();
    }
  }
 else {
    MageFrame.getInstance().showMessage(""String_Node_Str"");
  }
}",0.958590308370044
158210,"public synchronized void updateGame(GameView game,Map<String,Serializable> options){
  if (playerId == null && game.getWatchedHands() == null) {
    this.handContainer.setVisible(false);
  }
 else {
    this.handContainer.setVisible(true);
    handCards.clear();
    if (game.getWatchedHands() != null) {
      for (      Map.Entry<String,SimpleCardsView> hand : game.getWatchedHands().entrySet()) {
        handCards.put(hand.getKey(),CardsViewUtil.convertSimple(hand.getValue(),loadedCards));
      }
    }
    if (playerId != null) {
      handCards.put(YOUR_HAND,game.getHand());
      if (game.getCanPlayInHand() != null) {
        for (        CardView card : handCards.get(YOUR_HAND).values()) {
          if (game.getCanPlayInHand().contains(card.getId())) {
            card.setPlayable(true);
          }
        }
      }
      if (game.getOpponentHands() != null) {
        for (        Map.Entry<String,SimpleCardsView> hand : game.getOpponentHands().entrySet()) {
          handCards.put(hand.getKey(),CardsViewUtil.convertSimple(hand.getValue(),loadedCards));
        }
      }
      if (!handCards.containsKey(chosenHandKey)) {
        chosenHandKey=YOUR_HAND;
      }
    }
 else     if (chosenHandKey.isEmpty() && handCards.size() > 0) {
      chosenHandKey=handCards.keySet().iterator().next();
    }
    if (chosenHandKey != null && handCards.containsKey(chosenHandKey)) {
      handContainer.loadCards(handCards.get(chosenHandKey),bigCard,gameId);
    }
    hideAll();
    if (playerId != null) {
      btnSwitchHands.setVisible(handCards.size() > 1);
      boolean change=(handCardsOfOpponentAvailable != (game.getOpponentHands() != null));
      if (change) {
        handCardsOfOpponentAvailable=!handCardsOfOpponentAvailable;
        if (handCardsOfOpponentAvailable) {
          JOptionPane.showMessageDialog(null,""String_Node_Str"");
        }
 else {
          JOptionPane.showMessageDialog(null,""String_Node_Str"");
        }
      }
    }
 else {
      btnSwitchHands.setVisible(!handCards.isEmpty());
    }
  }
  if (game.getPhase() != null) {
    this.txtPhase.setText(game.getPhase().toString());
  }
 else {
    this.txtPhase.setText(""String_Node_Str"");
  }
  if (game.getStep() != null) {
    updatePhases(game.getStep());
    this.txtStep.setText(game.getStep().toString());
  }
 else {
    logger.debug(""String_Node_Str"");
    this.txtStep.setText(""String_Node_Str"");
  }
  if (game.getSpellsCastCurrentTurn() > 0 && PreferencesDialog.getCachedValue(PreferencesDialog.KEY_GAME_SHOW_STORM_COUNTER,""String_Node_Str"").equals(""String_Node_Str"")) {
    this.txtSpellsCast.setVisible(true);
    this.txtSpellsCast.setText(""String_Node_Str"" + Integer.toString(game.getSpellsCastCurrentTurn()) + ""String_Node_Str"");
  }
 else {
    this.txtSpellsCast.setVisible(false);
  }
  this.txtActivePlayer.setText(game.getActivePlayerName());
  this.txtPriority.setText(game.getPriorityPlayerName());
  this.txtTurn.setText(Integer.toString(game.getTurn()));
  List<UUID> possibleAttackers=new ArrayList<>();
  if (options != null && options.containsKey(Constants.Option.POSSIBLE_ATTACKERS)) {
    if (options.get(Constants.Option.POSSIBLE_ATTACKERS) instanceof List) {
      possibleAttackers.addAll((List)options.get(Constants.Option.POSSIBLE_ATTACKERS));
    }
  }
  for (  PlayerView player : game.getPlayers()) {
    if (players.containsKey(player.getPlayerId())) {
      if (!possibleAttackers.isEmpty()) {
        for (        UUID permanentId : possibleAttackers) {
          if (player.getBattlefield().containsKey(permanentId)) {
            player.getBattlefield().get(permanentId).setCanAttack(true);
          }
        }
      }
      players.get(player.getPlayerId()).update(player);
      if (player.getPlayerId().equals(playerId)) {
        updateSkipButtons(player.isPassedTurn(),player.isPassedUntilEndOfTurn(),player.isPassedUntilNextMain(),player.isPassedAllTurns(),player.isPassedUntilStackResolved(),player.isPassedUntilEndStepBeforeMyTurn());
      }
      graveyards.put(player.getName(),player.getGraveyard());
      if (graveyardWindows.containsKey(player.getName())) {
        CardInfoWindowDialog cardInfoWindowDialog=graveyardWindows.get(player.getName());
        if (cardInfoWindowDialog.isClosed()) {
          graveyardWindows.remove(player.getName());
        }
 else {
          cardInfoWindowDialog.loadCards(player.getGraveyard(),bigCard,gameId,false);
        }
      }
      if (player.getTopCard() != null) {
        CardsView cardsView=new CardsView();
        cardsView.put(player.getTopCard().getId(),player.getTopCard());
        handleGameInfoWindow(revealed,ShowType.REVEAL_TOP_LIBRARY,player.getName() + ""String_Node_Str"",cardsView);
      }
    }
 else {
      logger.warn(""String_Node_Str"");
      logger.warn(""String_Node_Str"" + player.getPlayerId());
      logger.warn(""String_Node_Str"");
      for (      PlayAreaPanel p : players.values()) {
        logger.warn(""String_Node_Str"" + p);
      }
    }
  }
  if (!menuNameSet) {
    StringBuilder sb=new StringBuilder();
    if (playerId == null) {
      sb.append(""String_Node_Str"");
    }
 else {
      sb.append(""String_Node_Str"");
    }
    boolean first=true;
    for (    PlayerView player : game.getPlayers()) {
      if (first) {
        first=false;
      }
 else {
        sb.append(""String_Node_Str"");
      }
      sb.append(player.getName());
    }
    menuNameSet=true;
    gamePane.setTitle(sb.toString());
  }
  GameManager.getInstance().setStackSize(game.getStack().size());
  displayStack(game,bigCard,feedbackPanel,gameId);
  for (  ExileView exile : game.getExile()) {
    if (!exiles.containsKey(exile.getId())) {
      CardInfoWindowDialog newExile=new CardInfoWindowDialog(ShowType.EXILE,exile.getName());
      exiles.put(exile.getId(),newExile);
      MageFrame.getDesktop().add(newExile,JLayeredPane.MODAL_LAYER);
      newExile.show();
    }
    exiles.get(exile.getId()).loadCards(exile,bigCard,gameId);
  }
  showRevealed(game);
  showLookedAt(game);
  if (game.getCombat().size() > 0) {
    CombatManager.getInstance().showCombat(game.getCombat(),gameId);
  }
 else {
    CombatManager.getInstance().hideCombat(gameId);
  }
  for (  PlayerView player : game.getPlayers()) {
    if (player.hasLeft() && !playersWhoLeft.get(player.getPlayerId())) {
      PlayAreaPanel playerLeftPanel=players.get(player.getPlayerId());
      playersWhoLeft.put(player.getPlayerId(),true);
      Container parent=playerLeftPanel.getParent();
      GridBagLayout layout=(GridBagLayout)parent.getLayout();
      for (      Component otherPanel : parent.getComponents()) {
        if (otherPanel instanceof PlayAreaPanel) {
          GridBagConstraints gbc=layout.getConstraints(otherPanel);
          if (gbc.weightx > 0.1) {
            gbc.weightx=0.99;
          }
          gbc.fill=GridBagConstraints.BOTH;
          gbc.anchor=GridBagConstraints.WEST;
          if (gbc.gridx > 0) {
            gbc.anchor=GridBagConstraints.EAST;
          }
          if (otherPanel == playerLeftPanel) {
            gbc.weightx=0.01;
            Dimension d=playerLeftPanel.getPreferredSize();
            d.width=95;
            otherPanel.setPreferredSize(d);
          }
          parent.remove(otherPanel);
          parent.add(otherPanel,gbc);
        }
      }
      parent.validate();
      parent.repaint();
    }
  }
  feedbackPanel.disableUndo();
  this.revalidate();
  this.repaint();
}","public synchronized void updateGame(GameView game,Map<String,Serializable> options){
  if (playerId == null && game.getWatchedHands() == null) {
    this.handContainer.setVisible(false);
  }
 else {
    this.handContainer.setVisible(true);
    handCards.clear();
    if (game.getWatchedHands() != null) {
      for (      Map.Entry<String,SimpleCardsView> hand : game.getWatchedHands().entrySet()) {
        handCards.put(hand.getKey(),CardsViewUtil.convertSimple(hand.getValue(),loadedCards));
      }
    }
    if (playerId != null) {
      handCards.put(YOUR_HAND,game.getHand());
      if (game.getCanPlayInHand() != null) {
        for (        CardView card : handCards.get(YOUR_HAND).values()) {
          if (game.getCanPlayInHand().contains(card.getId())) {
            card.setPlayable(true);
          }
        }
      }
      if (game.getOpponentHands() != null) {
        for (        Map.Entry<String,SimpleCardsView> hand : game.getOpponentHands().entrySet()) {
          handCards.put(hand.getKey(),CardsViewUtil.convertSimple(hand.getValue(),loadedCards));
        }
      }
      if (!handCards.containsKey(chosenHandKey)) {
        chosenHandKey=YOUR_HAND;
      }
    }
 else     if (chosenHandKey.isEmpty() && handCards.size() > 0) {
      chosenHandKey=handCards.keySet().iterator().next();
    }
    if (chosenHandKey != null && handCards.containsKey(chosenHandKey)) {
      handContainer.loadCards(handCards.get(chosenHandKey),bigCard,gameId);
    }
    hideAll();
    if (playerId != null) {
      btnSwitchHands.setVisible(handCards.size() > 1);
      boolean change=(handCardsOfOpponentAvailable != (game.getOpponentHands() != null));
      if (change) {
        handCardsOfOpponentAvailable=!handCardsOfOpponentAvailable;
        if (handCardsOfOpponentAvailable) {
          MageFrame.getInstance().showMessage(""String_Node_Str"");
        }
 else {
          MageFrame.getInstance().showMessage(""String_Node_Str"");
        }
      }
    }
 else {
      btnSwitchHands.setVisible(!handCards.isEmpty());
    }
  }
  if (game.getPhase() != null) {
    this.txtPhase.setText(game.getPhase().toString());
  }
 else {
    this.txtPhase.setText(""String_Node_Str"");
  }
  if (game.getStep() != null) {
    updatePhases(game.getStep());
    this.txtStep.setText(game.getStep().toString());
  }
 else {
    logger.debug(""String_Node_Str"");
    this.txtStep.setText(""String_Node_Str"");
  }
  if (game.getSpellsCastCurrentTurn() > 0 && PreferencesDialog.getCachedValue(PreferencesDialog.KEY_GAME_SHOW_STORM_COUNTER,""String_Node_Str"").equals(""String_Node_Str"")) {
    this.txtSpellsCast.setVisible(true);
    this.txtSpellsCast.setText(""String_Node_Str"" + Integer.toString(game.getSpellsCastCurrentTurn()) + ""String_Node_Str"");
  }
 else {
    this.txtSpellsCast.setVisible(false);
  }
  this.txtActivePlayer.setText(game.getActivePlayerName());
  this.txtPriority.setText(game.getPriorityPlayerName());
  this.txtTurn.setText(Integer.toString(game.getTurn()));
  List<UUID> possibleAttackers=new ArrayList<>();
  if (options != null && options.containsKey(Constants.Option.POSSIBLE_ATTACKERS)) {
    if (options.get(Constants.Option.POSSIBLE_ATTACKERS) instanceof List) {
      possibleAttackers.addAll((List)options.get(Constants.Option.POSSIBLE_ATTACKERS));
    }
  }
  for (  PlayerView player : game.getPlayers()) {
    if (players.containsKey(player.getPlayerId())) {
      if (!possibleAttackers.isEmpty()) {
        for (        UUID permanentId : possibleAttackers) {
          if (player.getBattlefield().containsKey(permanentId)) {
            player.getBattlefield().get(permanentId).setCanAttack(true);
          }
        }
      }
      players.get(player.getPlayerId()).update(player);
      if (player.getPlayerId().equals(playerId)) {
        updateSkipButtons(player.isPassedTurn(),player.isPassedUntilEndOfTurn(),player.isPassedUntilNextMain(),player.isPassedAllTurns(),player.isPassedUntilStackResolved(),player.isPassedUntilEndStepBeforeMyTurn());
      }
      graveyards.put(player.getName(),player.getGraveyard());
      if (graveyardWindows.containsKey(player.getName())) {
        CardInfoWindowDialog cardInfoWindowDialog=graveyardWindows.get(player.getName());
        if (cardInfoWindowDialog.isClosed()) {
          graveyardWindows.remove(player.getName());
        }
 else {
          cardInfoWindowDialog.loadCards(player.getGraveyard(),bigCard,gameId,false);
        }
      }
      if (player.getTopCard() != null) {
        CardsView cardsView=new CardsView();
        cardsView.put(player.getTopCard().getId(),player.getTopCard());
        handleGameInfoWindow(revealed,ShowType.REVEAL_TOP_LIBRARY,player.getName() + ""String_Node_Str"",cardsView);
      }
    }
 else {
      logger.warn(""String_Node_Str"");
      logger.warn(""String_Node_Str"" + player.getPlayerId());
      logger.warn(""String_Node_Str"");
      for (      PlayAreaPanel p : players.values()) {
        logger.warn(""String_Node_Str"" + p);
      }
    }
  }
  if (!menuNameSet) {
    StringBuilder sb=new StringBuilder();
    if (playerId == null) {
      sb.append(""String_Node_Str"");
    }
 else {
      sb.append(""String_Node_Str"");
    }
    boolean first=true;
    for (    PlayerView player : game.getPlayers()) {
      if (first) {
        first=false;
      }
 else {
        sb.append(""String_Node_Str"");
      }
      sb.append(player.getName());
    }
    menuNameSet=true;
    gamePane.setTitle(sb.toString());
  }
  GameManager.getInstance().setStackSize(game.getStack().size());
  displayStack(game,bigCard,feedbackPanel,gameId);
  for (  ExileView exile : game.getExile()) {
    if (!exiles.containsKey(exile.getId())) {
      CardInfoWindowDialog newExile=new CardInfoWindowDialog(ShowType.EXILE,exile.getName());
      exiles.put(exile.getId(),newExile);
      MageFrame.getDesktop().add(newExile,JLayeredPane.MODAL_LAYER);
      newExile.show();
    }
    exiles.get(exile.getId()).loadCards(exile,bigCard,gameId);
  }
  showRevealed(game);
  showLookedAt(game);
  if (game.getCombat().size() > 0) {
    CombatManager.getInstance().showCombat(game.getCombat(),gameId);
  }
 else {
    CombatManager.getInstance().hideCombat(gameId);
  }
  for (  PlayerView player : game.getPlayers()) {
    if (player.hasLeft() && !playersWhoLeft.get(player.getPlayerId())) {
      PlayAreaPanel playerLeftPanel=players.get(player.getPlayerId());
      playersWhoLeft.put(player.getPlayerId(),true);
      Container parent=playerLeftPanel.getParent();
      GridBagLayout layout=(GridBagLayout)parent.getLayout();
      for (      Component otherPanel : parent.getComponents()) {
        if (otherPanel instanceof PlayAreaPanel) {
          GridBagConstraints gbc=layout.getConstraints(otherPanel);
          if (gbc.weightx > 0.1) {
            gbc.weightx=0.99;
          }
          gbc.fill=GridBagConstraints.BOTH;
          gbc.anchor=GridBagConstraints.WEST;
          if (gbc.gridx > 0) {
            gbc.anchor=GridBagConstraints.EAST;
          }
          if (otherPanel == playerLeftPanel) {
            gbc.weightx=0.01;
            Dimension d=playerLeftPanel.getPreferredSize();
            d.width=95;
            otherPanel.setPreferredSize(d);
          }
          parent.remove(otherPanel);
          parent.add(otherPanel,gbc);
        }
      }
      parent.validate();
      parent.repaint();
    }
  }
  feedbackPanel.disableUndo();
  this.revalidate();
  this.repaint();
}",0.9936640603936372
158211,"private List<TokenData> getTokensData() throws IOException {
  if (tokensData == null) {
synchronized (tokensDataSync) {
      if (tokensData == null) {
        tokensData=new ArrayList<TokenData>();
        InputStream inputStream=null;
        try {
          inputStream=this.getClass().getResourceAsStream(""String_Node_Str"");
          List<TokenData> fileTokensData=parseTokensData(inputStream);
          tokensData.addAll(fileTokensData);
        }
 catch (        Exception exception) {
          logger.warn(""String_Node_Str"",exception);
        }
 finally {
          if (inputStream != null) {
            try {
              inputStream.close();
            }
 catch (            Exception e) {
              logger.error(""String_Node_Str"",e);
            }
          }
        }
        try {
          URL url=new URL(""String_Node_Str"");
          inputStream=url.openStream();
          List<TokenData> siteTokensData=parseTokensData(inputStream);
          List<TokenData> newTokensData=new ArrayList<TokenData>();
          for (          TokenData siteData : siteTokensData) {
            boolean isNew=true;
            for (            TokenData fileData : tokensData) {
              if (siteData.getName().equalsIgnoreCase(fileData.getName()) && siteData.getNumber().equalsIgnoreCase(fileData.getNumber()) && siteData.getExpansionSetCode().equalsIgnoreCase(fileData.getExpansionSetCode())) {
                isNew=false;
                break;
              }
            }
            if (isNew) {
              newTokensData.add(siteData);
            }
          }
          tokensData.addAll(newTokensData);
        }
 catch (        Exception exception) {
          logger.warn(""String_Node_Str"",exception);
        }
 finally {
          if (inputStream != null) {
            try {
              inputStream.close();
            }
 catch (            Exception e) {
              logger.error(""String_Node_Str"",e);
            }
          }
        }
      }
    }
  }
  return tokensData;
}","private List<TokenData> getTokensData() throws IOException {
synchronized (tokensDataSync) {
    if (tokensData == null) {
      tokensData=new ArrayList<>();
      InputStream inputStream=null;
      try {
        inputStream=this.getClass().getResourceAsStream(""String_Node_Str"");
        List<TokenData> fileTokensData=parseTokensData(inputStream);
        tokensData.addAll(fileTokensData);
      }
 catch (      Exception exception) {
        logger.warn(""String_Node_Str"",exception);
      }
 finally {
        if (inputStream != null) {
          try {
            inputStream.close();
          }
 catch (          Exception e) {
            logger.error(""String_Node_Str"",e);
          }
        }
      }
      try {
        URL url=new URL(""String_Node_Str"");
        inputStream=url.openStream();
        List<TokenData> siteTokensData=parseTokensData(inputStream);
        List<TokenData> newTokensData=new ArrayList<>();
        for (        TokenData siteData : siteTokensData) {
          boolean isNew=true;
          for (          TokenData fileData : tokensData) {
            if (siteData.getName().equalsIgnoreCase(fileData.getName()) && siteData.getNumber().equalsIgnoreCase(fileData.getNumber()) && siteData.getExpansionSetCode().equalsIgnoreCase(fileData.getExpansionSetCode())) {
              isNew=false;
              break;
            }
          }
          if (isNew) {
            newTokensData.add(siteData);
          }
        }
        tokensData.addAll(newTokensData);
      }
 catch (      Exception exception) {
        logger.warn(""String_Node_Str"",exception);
      }
 finally {
        if (inputStream != null) {
          try {
            inputStream.close();
          }
 catch (          Exception e) {
            logger.error(""String_Node_Str"",e);
          }
        }
      }
    }
  }
  return tokensData;
}",0.9097938144329896
158212,"@Override public String generateTokenUrl(CardDownloadData card) throws IOException {
  String name=card.getName();
  String set=card.getSet();
  int type=card.getType();
  if (name.toLowerCase().contains(""String_Node_Str"")) {
    for (    String emblem : EMBLEMS) {
      if (name.toLowerCase().contains(emblem.toLowerCase())) {
        name=emblem + ""String_Node_Str"";
        break;
      }
    }
  }
  if (SET_NAMES_REPLACEMENT.containsKey(set.toLowerCase())) {
    set=SET_NAMES_REPLACEMENT.get(set.toLowerCase());
  }
  List<TokenData> tokensData=getTokensData();
  if (tokensData.isEmpty()) {
    return null;
  }
  List<TokenData> matchedTokens=new ArrayList<TokenData>();
  for (  TokenData token : tokensData) {
    if (name.equalsIgnoreCase(token.getName()) && set.equalsIgnoreCase(token.getExpansionSetCode())) {
      matchedTokens.add(token);
    }
  }
  if (matchedTokens.isEmpty()) {
    logger.info(""String_Node_Str"" + name + ""String_Node_Str""+ set+ ""String_Node_Str"");
    return null;
  }
  TokenData tokenData;
  if (type == 0) {
    if (matchedTokens.size() > 1) {
      logger.info(""String_Node_Str"" + name + ""String_Node_Str""+ set+ ""String_Node_Str"");
    }
    tokenData=matchedTokens.get(0);
  }
 else {
    if (type > matchedTokens.size()) {
      logger.warn(""String_Node_Str"" + type + ""String_Node_Str""+ name+ ""String_Node_Str""+ set+ ""String_Node_Str"");
      return null;
    }
    tokenData=matchedTokens.get(card.getType() - 1);
  }
  String url=""String_Node_Str"" + tokenData.getExpansionSetCode().trim() + ""String_Node_Str""+ tokenData.getNumber().trim()+ ""String_Node_Str""+ tokenData.getName().trim()+ ""String_Node_Str"";
  url=url.replace(' ','-');
  return url;
}","@Override public String generateTokenUrl(CardDownloadData card) throws IOException {
  String name=card.getName();
  String set=card.getSet();
  int type=card.getType();
  if (name.toLowerCase().contains(""String_Node_Str"")) {
    for (    String emblem : EMBLEMS) {
      if (name.toLowerCase().contains(emblem.toLowerCase())) {
        name=emblem + ""String_Node_Str"";
        break;
      }
    }
  }
  if (SET_NAMES_REPLACEMENT.containsKey(set.toLowerCase())) {
    set=SET_NAMES_REPLACEMENT.get(set.toLowerCase());
  }
  List<TokenData> newTokensData=getTokensData();
  if (newTokensData.isEmpty()) {
    return null;
  }
  List<TokenData> matchedTokens=new ArrayList<>();
  for (  TokenData token : newTokensData) {
    if (name.equalsIgnoreCase(token.getName()) && set.equalsIgnoreCase(token.getExpansionSetCode())) {
      matchedTokens.add(token);
    }
  }
  TokenData tokenData;
  if (type == 0) {
    if (matchedTokens.size() > 1) {
      logger.info(""String_Node_Str"" + name + ""String_Node_Str""+ set+ ""String_Node_Str"");
    }
    tokenData=matchedTokens.get(0);
  }
 else {
    if (type > matchedTokens.size()) {
      logger.warn(""String_Node_Str"" + type + ""String_Node_Str""+ name+ ""String_Node_Str""+ set+ ""String_Node_Str"");
      return null;
    }
    tokenData=matchedTokens.get(card.getType() - 1);
  }
  String url=""String_Node_Str"" + tokenData.getExpansionSetCode().trim() + ""String_Node_Str""+ tokenData.getNumber().trim()+ ""String_Node_Str""+ tokenData.getName().trim()+ ""String_Node_Str"";
  url=url.replace(' ','-');
  return url;
}",0.940597106802093
158213,"private List<TokenData> parseTokensData(InputStream inputStream) throws IOException {
  List<TokenData> tokensData=new ArrayList<TokenData>();
  InputStreamReader inputReader=null;
  BufferedReader reader=null;
  try {
    inputReader=new InputStreamReader(inputStream,""String_Node_Str"");
    reader=new BufferedReader(inputReader);
    reader.readLine();
    String line=reader.readLine();
    int state=0;
    String set=null;
    while (line != null) {
      if (line.trim().isEmpty()) {
        if (state == 2) {
          state=0;
        }
      }
 else {
        if (state == 0) {
          set=line.substring(0,3);
          state=1;
        }
 else {
          if (state == 1) {
            state=2;
          }
          String[] split=line.split(""String_Node_Str"");
          String name=split[0].replace('',',');
          String number=split[1];
          TokenData token=new TokenData(name,number,set);
          tokensData.add(token);
        }
      }
      line=reader.readLine();
    }
  }
  finally {
    if (inputReader != null) {
      try {
        inputReader.close();
      }
 catch (      Exception e) {
        logger.error(""String_Node_Str"",e);
      }
    }
    if (reader != null) {
      try {
        reader.close();
      }
 catch (      Exception e) {
        logger.error(""String_Node_Str"",e);
      }
    }
  }
  return tokensData;
}","private List<TokenData> parseTokensData(InputStream inputStream) throws IOException {
  List<TokenData> newTokensData=new ArrayList<>();
  InputStreamReader inputReader=null;
  BufferedReader reader=null;
  try {
    inputReader=new InputStreamReader(inputStream,""String_Node_Str"");
    reader=new BufferedReader(inputReader);
    reader.readLine();
    String line=reader.readLine();
    int state=0;
    String set=null;
    while (line != null) {
      if (line.trim().isEmpty()) {
        if (state == 2) {
          state=0;
        }
      }
 else       if (state == 0) {
        set=line.substring(0,3);
        state=1;
      }
 else {
        if (state == 1) {
          state=2;
        }
        String[] split=line.split(""String_Node_Str"");
        String name=split[0].replace('',',');
        String number=split[1];
        TokenData token=new TokenData(name,number,set);
        newTokensData.add(token);
      }
      line=reader.readLine();
    }
  }
  finally {
    if (inputReader != null) {
      try {
        inputReader.close();
      }
 catch (      Exception e) {
        logger.error(""String_Node_Str"",e);
      }
    }
    if (reader != null) {
      try {
        reader.close();
      }
 catch (      Exception e) {
        logger.error(""String_Node_Str"",e);
      }
    }
  }
  return newTokensData;
}",0.9689119170984456
158214,"@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller != null) {
    int highestPower=Integer.MIN_VALUE;
    Permanent selectedCreature=null;
    for (    Permanent permanent : game.getBattlefield().getActivePermanents(new FilterCreaturePermanent(),controller.getId(),game)) {
      if (highestPower < permanent.getPower().getValue()) {
        highestPower=permanent.getPower().getValue();
        selectedCreature=permanent;
      }
 else       if (highestPower == permanent.getPower().getValue()) {
        highestPower=permanent.getToughness().getValue();
        selectedCreature=null;
      }
    }
    if (highestPower != Integer.MIN_VALUE) {
      if (selectedCreature == null) {
        FilterPermanent filter=new FilterCreaturePermanent(""String_Node_Str"" + highestPower);
        filter.add(new PowerPredicate(Filter.ComparisonType.Equal,highestPower));
        Target target=new TargetPermanent(1,1,filter,true);
        if (controller.chooseTarget(outcome,target,source,game)) {
          selectedCreature=game.getPermanent(target.getFirstTarget());
        }
      }
      if (selectedCreature != null) {
        FixedTarget target=new FixedTarget(selectedCreature.getId());
        Effect effect=new AddCountersTargetEffect(CounterType.P1P1.createInstance(4));
        effect.setTargetPointer(target);
        effect.apply(game,source);
        ContinuousEffect continuousEffect=new GainAbilityTargetEffect(TrampleAbility.getInstance(),Duration.EndOfTurn);
        continuousEffect.setTargetPointer(target);
        game.addEffect(continuousEffect,source);
        return true;
      }
    }
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller != null) {
    int highestPower=Integer.MIN_VALUE;
    Permanent selectedCreature=null;
    for (    Permanent permanent : game.getBattlefield().getActivePermanents(new FilterCreaturePermanent(),controller.getId(),game)) {
      if (highestPower < permanent.getPower().getValue()) {
        highestPower=permanent.getPower().getValue();
        selectedCreature=permanent;
      }
 else       if (highestPower == permanent.getPower().getValue()) {
        highestPower=permanent.getPower().getValue();
        selectedCreature=null;
      }
    }
    if (highestPower != Integer.MIN_VALUE) {
      if (selectedCreature == null) {
        FilterPermanent filter=new FilterCreaturePermanent(""String_Node_Str"" + highestPower);
        filter.add(new PowerPredicate(Filter.ComparisonType.Equal,highestPower));
        Target target=new TargetPermanent(1,1,filter,true);
        if (controller.chooseTarget(outcome,target,source,game)) {
          selectedCreature=game.getPermanent(target.getFirstTarget());
        }
      }
      if (selectedCreature != null) {
        FixedTarget target=new FixedTarget(selectedCreature.getId());
        Effect effect=new AddCountersTargetEffect(CounterType.P1P1.createInstance(4));
        effect.setTargetPointer(target);
        effect.apply(game,source);
        ContinuousEffect continuousEffect=new GainAbilityTargetEffect(TrampleAbility.getInstance(),Duration.EndOfTurn);
        continuousEffect.setTargetPointer(target);
        game.addEffect(continuousEffect,source);
        return true;
      }
    }
    return true;
  }
  return false;
}",0.9959420289855072
158215,"public GainProtectionFromColorTargetEffect(final GainProtectionFromColorTargetEffect effect){
  super(effect);
  choice=effect.choice;
}","public GainProtectionFromColorTargetEffect(final GainProtectionFromColorTargetEffect effect){
  super(effect);
  this.choice=effect.choice.copy();
}",0.9577464788732394
158216,"@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  Permanent permanentToDestroy=game.getPermanent(getTargetPointer().getFirst(game,source));
  Permanent permanentToPutCounter=game.getPermanent(getTargetPointer().getTargets(game,source).get(1));
  if (controller != null) {
    if (permanentToDestroy != null && permanentToDestroy.destroy(source.getSourceId(),game,false)) {
      if (permanentToPutCounter != null) {
        permanentToPutCounter.addCounters(CounterType.P1P1.createInstance(),game);
      }
    }
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  Permanent permanentToDestroy=game.getPermanent(getTargetPointer().getFirst(game,source));
  Permanent permanentToPutCounter=game.getPermanent(source.getTargets().get(1).getFirstTarget());
  if (controller != null) {
    if (permanentToDestroy != null && permanentToDestroy.destroy(source.getSourceId(),game,false)) {
      if (permanentToPutCounter != null) {
        permanentToPutCounter.addCounters(CounterType.P1P1.createInstance(),game);
      }
    }
    return true;
  }
  return false;
}",0.9387096774193548
158217,"@Override public boolean apply(Game game,Ability source){
  int tappedAmount=0;
  Player you=game.getPlayer(source.getControllerId());
  TargetCreaturePermanent target=new TargetCreaturePermanent(filter);
  while (true) {
    target.clearChosen();
    if (target.canChoose(source.getControllerId(),game) && target.choose(Outcome.Tap,source.getControllerId(),source.getSourceId(),game)) {
      UUID creature=target.getFirstTarget();
      if (creature != null) {
        game.getPermanent(creature).tap(game);
        tappedAmount++;
      }
    }
 else {
      break;
    }
  }
  if (tappedAmount > 0) {
    you.gainLife(tappedAmount * 2,game);
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  int tappedAmount=0;
  Player you=game.getPlayer(source.getControllerId());
  TargetCreaturePermanent target=new TargetCreaturePermanent(0,Integer.MAX_VALUE,filter,true);
  if (target.canChoose(source.getControllerId(),game) && target.choose(Outcome.Tap,source.getControllerId(),source.getSourceId(),game)) {
    for (    UUID creature : target.getTargets()) {
      if (creature != null) {
        game.getPermanent(creature).tap(game);
        tappedAmount++;
      }
    }
  }
  if (tappedAmount > 0) {
    you.gainLife(tappedAmount * 2,game);
    return true;
  }
  return false;
}",0.7243975903614458
158218,"@Override public boolean apply(Game game,Ability source){
  Player you=game.getPlayer(source.getControllerId());
  Player damagedPlayer=game.getPlayer(targetPointer.getFirst(game,source));
  filter.add(new OwnerIdPredicate(damagedPlayer.getId()));
  filter.add(Predicates.or(new CardTypePredicate(CardType.INSTANT),new CardTypePredicate(CardType.SORCERY)));
  Target target=new TargetCardInGraveyard(filter);
  if (you != null) {
    if (you.chooseTarget(Outcome.PlayForFree,target,source,game)) {
      Card card=game.getCard(target.getFirstTarget());
      if (card != null) {
        you.cast(card.getSpellAbility(),game,true);
        game.addEffect(new WrexialReplacementEffect(card.getId()),source);
      }
    }
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller != null) {
    Player damagedPlayer=game.getPlayer(targetPointer.getFirst(game,source));
    if (damagedPlayer == null) {
      return false;
    }
    FilterCard filter=new FilterCard(""String_Node_Str"" + damagedPlayer.getName() + ""String_Node_Str"");
    filter.add(new OwnerIdPredicate(damagedPlayer.getId()));
    filter.add(Predicates.or(new CardTypePredicate(CardType.INSTANT),new CardTypePredicate(CardType.SORCERY)));
    Target target=new TargetCardInGraveyard(filter);
    if (controller.chooseTarget(Outcome.PlayForFree,target,source,game)) {
      Card card=game.getCard(target.getFirstTarget());
      if (card != null) {
        controller.cast(card.getSpellAbility(),game,true);
        game.addEffect(new WrexialReplacementEffect(card.getId()),source);
      }
    }
    return true;
  }
  return false;
}",0.6540954625810254
158219,"@Override public boolean checkTrigger(GameEvent event,Game game){
  DamagedPlayerEvent damageEvent=(DamagedPlayerEvent)event;
  Permanent p=game.getPermanent(event.getSourceId());
  if (damageEvent.isCombatDamage() && p != null && p.getAttachments().contains(this.getSourceId())) {
    getTargets().get(0).add(event.getPlayerId(),game);
    return true;
  }
  return false;
}","@Override public boolean checkTrigger(GameEvent event,Game game){
  DamagedPlayerEvent damageEvent=(DamagedPlayerEvent)event;
  Permanent damageSource=game.getPermanentOrLKIBattlefield(event.getSourceId());
  if (damageEvent.isCombatDamage() && damageSource != null && damageSource.getAttachments().contains(this.getSourceId())) {
    getTargets().get(0).clearChosen();
    getTargets().get(0).add(event.getPlayerId(),game);
    return true;
  }
  return false;
}",0.8878281622911695
158220,"@Override public boolean apply(Game game,Ability source){
  Player target=game.getPlayer(source.getFirstTarget());
  if (target != null) {
    target.damage(target.getHand().size(),source.getSourceId(),game,false,true);
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Player target=game.getPlayer(source.getFirstTarget());
  if (target != null) {
    target.damage(target.getHand().size(),source.getSourceId(),game,false,true);
  }
  return true;
}",0.9854469854469856
158221,"@Override public boolean checkTrigger(GameEvent event,Game game){
  if (super.checkTrigger(event,game)) {
    if (game.getTurn().getStepType().equals(PhaseStep.COMBAT_DAMAGE) || game.getTurn().getStepType().equals(PhaseStep.FIRST_COMBAT_DAMAGE)) {
      Integer stepHash=(Integer)game.getState().getValue(""String_Node_Str"" + getOriginalId());
      if (stepHash == null || game.getStep().hashCode() != stepHash) {
        game.getState().setValue(""String_Node_Str"" + getOriginalId(),game.getStep().hashCode());
        return true;
      }
    }
 else {
      game.getState().setValue(""String_Node_Str"" + getOriginalId(),null);
      return true;
    }
  }
  return false;
}","@Override public boolean checkTrigger(GameEvent event,Game game){
  if (super.checkTrigger(event,game)) {
    if (game.getTurn().getStepType().equals(PhaseStep.COMBAT_DAMAGE) || game.getTurn().getStepType().equals(PhaseStep.FIRST_COMBAT_DAMAGE)) {
      String stepHash=(String)game.getState().getValue(""String_Node_Str"" + getOriginalId());
      String newStepHash=game.getStep().getType().toString() + game.getTurnNum();
      if (stepHash == null || !newStepHash.equals(stepHash)) {
        game.getState().setValue(""String_Node_Str"" + getOriginalId(),game.getStep().getType().toString() + game.getTurnNum());
        return true;
      }
    }
 else {
      game.getState().setValue(""String_Node_Str"" + getOriginalId(),null);
      return true;
    }
  }
  return false;
}",0.8606896551724138
158222,"@Override protected Player getPayingPlayer(Game game,Ability source){
  Permanent attachment=game.getPermanent(source.getSourceId());
  Permanent attachedTo=game.getPermanent(attachment.getAttachedTo());
  return game.getPlayer(attachedTo.getControllerId());
}","@Override protected Player getPayingPlayer(Game game,Ability source){
  Permanent attachment=game.getPermanentOrLKIBattlefield(source.getSourceId());
  if (attachment != null) {
    Permanent attachedTo=game.getPermanentOrLKIBattlefield(attachment.getAttachedTo());
    if (attachedTo != null) {
      return game.getPlayer(attachedTo.getControllerId());
    }
  }
  return null;
}",0.7457098283931357
158223,"@Override public String getText(Mode mode){
  return new StringBuilder(""String_Node_Str"").append(getCostText()).append(""String_Node_Str"").append(executingEffects.getText(mode)).toString();
}","@Override public String getText(Mode mode){
  return ""String_Node_Str"" + getCostText() + ""String_Node_Str""+ executingEffects.getText(mode);
}",0.8036253776435045
158224,"@Override public AnimateArtifact copy(){
  return new AnimateArtifact(this);
}","@Override public AnimateArtifactContinuousEffect copy(){
  return new AnimateArtifactContinuousEffect(this);
}",0.8297872340425532
158225,"/** 
 * Assert whether a permanent is a specified type
 * @param cardName Name of the permanent that should be checked.
 * @param type A type to test for
 * @param subType a subtype to test for
 */
public void assertType(String cardName,CardType type,String subType) throws AssertionError {
  Permanent found=null;
  for (  Permanent permanent : currentGame.getBattlefield().getAllActivePermanents()) {
    if (permanent.getName().equals(cardName)) {
      found=permanent;
      break;
    }
  }
  Assert.assertNotNull(""String_Node_Str"" + cardName,found);
  Assert.assertTrue(""String_Node_Str"" + cardName + ""String_Node_Str""+ type+ ""String_Node_Str"",found.getCardType().contains(type));
  Assert.assertTrue(""String_Node_Str"" + cardName + ""String_Node_Str""+ subType+ ""String_Node_Str"",found.getSubtype(currentGame).contains(subType));
}","/** 
 * Assert whether a permanent is a specified type
 * @param cardName Name of the permanent that should be checked.
 * @param type A type to test for
 * @param subType a subtype to test for
 */
public void assertType(String cardName,CardType type,String subType) throws AssertionError {
  Permanent found=null;
  for (  Permanent permanent : currentGame.getBattlefield().getAllActivePermanents()) {
    if (permanent.getName().equals(cardName)) {
      found=permanent;
      break;
    }
  }
  Assert.assertNotNull(""String_Node_Str"" + cardName,found);
  Assert.assertTrue(""String_Node_Str"" + cardName + ""String_Node_Str""+ type+ ""String_Node_Str"",found.getCardType().contains(type));
  if (subType != null) {
    Assert.assertTrue(""String_Node_Str"" + cardName + ""String_Node_Str""+ subType+ ""String_Node_Str"",found.getSubtype(currentGame).contains(subType));
  }
}",0.9817968291250734
158226,"@Override public boolean apply(Game game,Ability source){
  Player player=game.getPlayer(targetPointer.getFirst(game,source));
  if (player != null) {
    UntappedLandsAtBeginningOfTurnWatcher watcher=(UntappedLandsAtBeginningOfTurnWatcher)game.getState().getWatchers().get(""String_Node_Str"");
    int damage=watcher.getUntappedLandCount(targetPointer.getFirst(game,source));
    player.damage(damage,source.getSourceId(),game,false,true);
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Player player=game.getPlayer(targetPointer.getFirst(game,source));
  if (player != null) {
    PowerSurgeWatcher watcher=(PowerSurgeWatcher)game.getState().getWatchers().get(PowerSurgeWatcher.class.getName());
    int damage=watcher.getUntappedLandCount();
    player.damage(damage,source.getSourceId(),game,false,true);
    return true;
  }
  return false;
}",0.8205128205128205
158227,"@Override public PowerSurgeDamageEffect copy(){
  return new PowerSurgeDamageEffect(this);
}","@Override public PowerSurgeWatcher copy(){
  return new PowerSurgeWatcher(this);
}",0.8275862068965517
158228,"@Override public boolean apply(Game game,Ability source){
  Card card=game.getCard(source.getSourceId());
  if (card != null) {
    ExileZone currentZone=game.getState().getExile().getExileZone(source.getSourceId());
    if (currentZone != null && currentZone.size() > 0) {
      Player owner=game.getPlayer(card.getOwnerId());
      if (owner != null && owner.moveCards(card,Zone.BATTLEFIELD,source,game)) {
        return true;
      }
    }
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Card card=game.getCard(source.getSourceId());
  if (card != null) {
    Zone zone=game.getState().getZone(source.getSourceId());
    if (!zone.equals(Zone.BATTLEFIELD) && !zone.equals(Zone.LIBRARY) && !zone.equals(Zone.HAND)) {
      Player owner=game.getPlayer(card.getOwnerId());
      if (owner != null) {
        owner.moveCards(card,Zone.BATTLEFIELD,source,game);
      }
    }
    return true;
  }
  return false;
}",0.5243128964059197
158229,"@Override public boolean apply(Game game,Ability source){
  Card card=game.getCard(source.getFirstTarget());
  Player controller=game.getPlayer(source.getControllerId());
  if (controller != null && card != null) {
    if (controller.moveCards(card,Zone.EXILED,source,game)) {
      PutTokenOntoBattlefieldCopyTargetEffect effect=new PutTokenOntoBattlefieldCopyTargetEffect(source.getControllerId(),null,false);
      effect.setTargetPointer(new FixedTarget(card.getId(),card.getZoneChangeCounter(game)));
      effect.setAdditionalSubType(""String_Node_Str"");
      effect.apply(game,source);
      ExileTargetEffect exileEffect=new ExileTargetEffect();
      exileEffect.setTargetPointer(new FixedTargets(effect.getAddedPermanent(),game));
      DelayedTriggeredAbility delayedAbility=new AtTheBeginOfNextEndStepDelayedTriggeredAbility(exileEffect);
      game.addDelayedTriggeredAbility(delayedAbility,source);
    }
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Card card=game.getCard(source.getFirstTarget());
  Player controller=game.getPlayer(source.getControllerId());
  if (controller != null && card != null) {
    controller.moveCards(card,Zone.EXILED,source,game);
    PutTokenOntoBattlefieldCopyTargetEffect effect=new PutTokenOntoBattlefieldCopyTargetEffect(source.getControllerId(),null,false);
    effect.setTargetPointer(new FixedTarget(card.getId(),card.getZoneChangeCounter(game)));
    effect.setAdditionalSubType(""String_Node_Str"");
    effect.apply(game,source);
    ExileTargetEffect exileEffect=new ExileTargetEffect();
    exileEffect.setTargetPointer(new FixedTargets(effect.getAddedPermanent(),game));
    DelayedTriggeredAbility delayedAbility=new AtTheBeginOfNextEndStepDelayedTriggeredAbility(exileEffect);
    game.addDelayedTriggeredAbility(delayedAbility,source);
    return true;
  }
  return false;
}",0.9522799575821844
158230,"@Override public boolean apply(Game game,Ability source){
  int cmc=0;
  for (  Cost cost : source.getCosts()) {
    if (cost instanceof SacrificeTargetCost && ((SacrificeTargetCost)cost).getPermanents().size() > 0) {
      cmc=((SacrificeTargetCost)cost).getPermanents().get(0).getConvertedManaCost();
      break;
    }
  }
  for (  Permanent permanent : game.getBattlefield().getAllActivePermanents(new FilterCreaturePermanent(),game)) {
    if (permanent.getConvertedManaCost() == cmc) {
      permanent.destroy(source.getSourceId(),game,false);
    }
  }
  return true;
}","@Override public boolean apply(Game game,Ability source){
  int cmc=0;
  for (  Cost cost : source.getCosts()) {
    if (cost instanceof SacrificeTargetCost && ((SacrificeTargetCost)cost).getPermanents().size() > 0) {
      cmc=((SacrificeTargetCost)cost).getPermanents().get(0).getConvertedManaCost();
      break;
    }
  }
  for (  Permanent permanent : game.getBattlefield().getActivePermanents(new FilterCreaturePermanent(),source.getControllerId(),game)) {
    if (permanent.getConvertedManaCost() == cmc) {
      permanent.destroy(source.getSourceId(),game,false);
    }
  }
  return true;
}",0.9761499148211245
158231,"@Override public boolean resolve(Game game){
  if (isOptional()) {
    MageObject object=game.getObject(getSourceId());
    Player player=game.getPlayer(this.getControllerId());
    if (player != null && object != null) {
      if (!player.chooseUse(getEffects().get(0).getOutcome(),this.getRule(object.getLogName()),this,game)) {
        return false;
      }
    }
 else {
      return false;
    }
  }
  if (checkInterveningIfClause(game)) {
    return super.resolve(game);
  }
  return false;
}","@Override public boolean resolve(Game game){
  if (isOptional()) {
    MageObject object=game.getObject(getSourceId());
    Player player=game.getPlayer(this.getControllerId());
    if (player != null && object != null) {
      if (!player.chooseUse(getEffects().isEmpty() ? Outcome.Detriment : getEffects().get(0).getOutcome(),this.getRule(object.getLogName()),this,game)) {
        return false;
      }
    }
 else {
      return false;
    }
  }
  if (checkInterveningIfClause(game)) {
    return super.resolve(game);
  }
  return false;
}",0.956772334293948
158232,"@Override public StackObject createCopyOnStack(Game game,Ability source,UUID newControllerId,boolean chooseNewTargets){
  Ability newAbility=this.copy();
  newAbility.newId();
  StackAbility newStackAbility=new StackAbility(newAbility,newControllerId);
  game.getStack().push(newStackAbility);
  if (chooseNewTargets && newAbility.getTargets().size() > 0) {
    Player controller=game.getPlayer(newControllerId);
    if (controller.chooseUse(newAbility.getEffects().get(0).getOutcome(),""String_Node_Str"",source,game)) {
      newAbility.getTargets().clearChosen();
      newAbility.getTargets().chooseTargets(newAbility.getEffects().get(0).getOutcome(),newControllerId,newAbility,false,game);
    }
  }
  game.fireEvent(new GameEvent(GameEvent.EventType.COPIED_STACKOBJECT,newStackAbility.getId(),this.getId(),newControllerId));
  return newStackAbility;
}","@Override public StackObject createCopyOnStack(Game game,Ability source,UUID newControllerId,boolean chooseNewTargets){
  Ability newAbility=this.copy();
  newAbility.newId();
  StackAbility newStackAbility=new StackAbility(newAbility,newControllerId);
  game.getStack().push(newStackAbility);
  if (chooseNewTargets && newAbility.getTargets().size() > 0) {
    Player controller=game.getPlayer(newControllerId);
    Outcome outcome=newAbility.getEffects().isEmpty() ? Outcome.Detriment : newAbility.getEffects().get(0).getOutcome();
    if (controller.chooseUse(outcome,""String_Node_Str"",source,game)) {
      newAbility.getTargets().clearChosen();
      newAbility.getTargets().chooseTargets(outcome,newControllerId,newAbility,false,game);
    }
  }
  game.fireEvent(new GameEvent(GameEvent.EventType.COPIED_STACKOBJECT,newStackAbility.getId(),this.getId(),newControllerId));
  return newStackAbility;
}",0.7893242475865985
158233,"/** 
 * Handles the change of one target instance of a mode
 * @param targetController - player that can choose the new target
 * @param ability
 * @param mode
 * @param target
 * @param forceChange
 * @param game
 * @return
 */
private Target chooseNewTarget(Player targetController,Ability ability,Mode mode,Target target,boolean forceChange,FilterPermanent filterNewTarget,Game game){
  Target newTarget=target.copy();
  if (!targetController.getId().equals(getControllerId())) {
    newTarget.setTargetController(targetController.getId());
    newTarget.setAbilityController(getControllerId());
  }
  newTarget.clearChosen();
  for (  UUID targetId : target.getTargets()) {
    String targetNames=getNamesOftargets(targetId,game);
    if (targetNames != null && (forceChange || targetController.chooseUse(mode.getEffects().get(0).getOutcome(),""String_Node_Str"" + targetNames + ""String_Node_Str"",ability,game))) {
      Set<UUID> possibleTargets=target.possibleTargets(this.getSourceId(),getControllerId(),game);
      if (forceChange && possibleTargets != null && possibleTargets.size() > 1) {
        int iteration=0;
        do {
          if (iteration > 0 && !game.isSimulation()) {
            game.informPlayer(targetController,""String_Node_Str"");
          }
          iteration++;
          newTarget.clearChosen();
          newTarget.chooseTarget(mode.getEffects().get(0).getOutcome(),getControllerId(),ability,game);
          if (newTarget.getFirstTarget() != null && filterNewTarget != null) {
            Permanent newTargetPermanent=game.getPermanent(newTarget.getFirstTarget());
            if (newTargetPermanent == null || !filterNewTarget.match(newTargetPermanent,game)) {
              game.informPlayer(targetController,""String_Node_Str"" + filterNewTarget.getMessage() + ""String_Node_Str"");
              newTarget.clearChosen();
            }
          }
        }
 while (targetController.canRespond() && (targetId.equals(newTarget.getFirstTarget()) || newTarget.getTargets().size() != 1));
      }
 else {
        Target tempTarget=target.copy();
        if (target instanceof TargetAmount) {
          ((TargetAmount)tempTarget).setAmountDefinition(new StaticValue(target.getTargetAmount(targetId)));
        }
        tempTarget.setMinNumberOfTargets(1);
        tempTarget.setMaxNumberOfTargets(1);
        if (!targetController.getId().equals(getControllerId())) {
          tempTarget.setTargetController(targetController.getId());
          tempTarget.setAbilityController(getControllerId());
        }
        boolean again;
        do {
          again=false;
          tempTarget.clearChosen();
          if (!tempTarget.chooseTarget(mode.getEffects().get(0).getOutcome(),getControllerId(),ability,game)) {
            if (targetController.chooseUse(Outcome.Benefit,""String_Node_Str"",ability,game)) {
              newTarget.addTarget(targetId,target.getTargetAmount(targetId),ability,game,false);
            }
 else {
              again=true;
            }
          }
 else           if (newTarget.getTargets().contains(tempTarget.getFirstTarget()) || target.getTargets().contains(tempTarget.getFirstTarget())) {
            if (targetController.isHuman()) {
              if (targetController.chooseUse(Outcome.Benefit,""String_Node_Str"",ability,game)) {
                newTarget.addTarget(targetId,target.getTargetAmount(targetId),ability,game,false);
              }
 else {
                again=true;
              }
            }
 else {
              newTarget.addTarget(targetId,target.getTargetAmount(targetId),ability,game,false);
            }
          }
 else           if (!target.canTarget(getControllerId(),tempTarget.getFirstTarget(),ability,game)) {
            if (targetController.isHuman()) {
              game.informPlayer(targetController,""String_Node_Str"");
              again=true;
            }
 else {
              newTarget.addTarget(targetId,target.getTargetAmount(targetId),ability,game,false);
            }
          }
 else           if (newTarget.getFirstTarget() != null && filterNewTarget != null) {
            Permanent newTargetPermanent=game.getPermanent(newTarget.getFirstTarget());
            if (newTargetPermanent == null || !filterNewTarget.match(newTargetPermanent,game)) {
              game.informPlayer(targetController,""String_Node_Str"" + filterNewTarget.getMessage() + ""String_Node_Str"");
              again=true;
            }
          }
 else {
            newTarget.addTarget(tempTarget.getFirstTarget(),target.getTargetAmount(targetId),ability,game,false);
          }
        }
 while (again && targetController.canRespond());
      }
    }
 else {
      newTarget.addTarget(targetId,target.getTargetAmount(targetId),ability,game,false);
    }
  }
  return newTarget;
}","/** 
 * Handles the change of one target instance of a mode
 * @param targetController - player that can choose the new target
 * @param ability
 * @param mode
 * @param target
 * @param forceChange
 * @param game
 * @return
 */
private Target chooseNewTarget(Player targetController,Ability ability,Mode mode,Target target,boolean forceChange,FilterPermanent filterNewTarget,Game game){
  Target newTarget=target.copy();
  if (!targetController.getId().equals(getControllerId())) {
    newTarget.setTargetController(targetController.getId());
    newTarget.setAbilityController(getControllerId());
  }
  newTarget.clearChosen();
  for (  UUID targetId : target.getTargets()) {
    String targetNames=getNamesOftargets(targetId,game);
    Outcome outcome=mode.getEffects().isEmpty() ? Outcome.Detriment : mode.getEffects().get(0).getOutcome();
    if (targetNames != null && (forceChange || targetController.chooseUse(outcome,""String_Node_Str"" + targetNames + ""String_Node_Str"",ability,game))) {
      Set<UUID> possibleTargets=target.possibleTargets(this.getSourceId(),getControllerId(),game);
      if (forceChange && possibleTargets != null && possibleTargets.size() > 1) {
        int iteration=0;
        do {
          if (iteration > 0 && !game.isSimulation()) {
            game.informPlayer(targetController,""String_Node_Str"");
          }
          iteration++;
          newTarget.clearChosen();
          newTarget.chooseTarget(outcome,getControllerId(),ability,game);
          if (newTarget.getFirstTarget() != null && filterNewTarget != null) {
            Permanent newTargetPermanent=game.getPermanent(newTarget.getFirstTarget());
            if (newTargetPermanent == null || !filterNewTarget.match(newTargetPermanent,game)) {
              game.informPlayer(targetController,""String_Node_Str"" + filterNewTarget.getMessage() + ""String_Node_Str"");
              newTarget.clearChosen();
            }
          }
        }
 while (targetController.canRespond() && (targetId.equals(newTarget.getFirstTarget()) || newTarget.getTargets().size() != 1));
      }
 else {
        Target tempTarget=target.copy();
        if (target instanceof TargetAmount) {
          ((TargetAmount)tempTarget).setAmountDefinition(new StaticValue(target.getTargetAmount(targetId)));
        }
        tempTarget.setMinNumberOfTargets(1);
        tempTarget.setMaxNumberOfTargets(1);
        if (!targetController.getId().equals(getControllerId())) {
          tempTarget.setTargetController(targetController.getId());
          tempTarget.setAbilityController(getControllerId());
        }
        boolean again;
        do {
          again=false;
          tempTarget.clearChosen();
          if (!tempTarget.chooseTarget(outcome,getControllerId(),ability,game)) {
            if (targetController.chooseUse(Outcome.Benefit,""String_Node_Str"",ability,game)) {
              newTarget.addTarget(targetId,target.getTargetAmount(targetId),ability,game,false);
            }
 else {
              again=true;
            }
          }
 else {
            if (newTarget.getTargets().contains(tempTarget.getFirstTarget()) || target.getTargets().contains(tempTarget.getFirstTarget())) {
              if (targetController.isHuman()) {
                if (targetController.chooseUse(Outcome.Benefit,""String_Node_Str"",ability,game)) {
                  newTarget.addTarget(targetId,target.getTargetAmount(targetId),ability,game,false);
                }
 else {
                  again=true;
                }
              }
 else {
                newTarget.addTarget(targetId,target.getTargetAmount(targetId),ability,game,false);
              }
            }
 else             if (!target.canTarget(getControllerId(),tempTarget.getFirstTarget(),ability,game)) {
              if (targetController.isHuman()) {
                game.informPlayer(targetController,""String_Node_Str"");
                again=true;
              }
 else {
                newTarget.addTarget(targetId,target.getTargetAmount(targetId),ability,game,false);
              }
            }
 else             if (newTarget.getFirstTarget() != null && filterNewTarget != null) {
              Permanent newTargetPermanent=game.getPermanent(newTarget.getFirstTarget());
              if (newTargetPermanent == null || !filterNewTarget.match(newTargetPermanent,game)) {
                game.informPlayer(targetController,""String_Node_Str"" + filterNewTarget.getMessage() + ""String_Node_Str"");
                again=true;
              }
            }
 else {
              newTarget.addTarget(tempTarget.getFirstTarget(),target.getTargetAmount(targetId),ability,game,false);
            }
          }
        }
 while (again && targetController.canRespond());
      }
    }
 else {
      newTarget.addTarget(targetId,target.getTargetAmount(targetId),ability,game,false);
    }
  }
  return newTarget;
}",0.6550399667808575
158234,"/** 
 * Selects a defender for an attacker and adds the attacker to combat
 * @param defenders - list of possible defender
 * @param attackerId - UUID of attacker
 * @param game
 * @return
 */
protected boolean selectDefender(Set<UUID> defenders,UUID attackerId,Game game){
  boolean forcedToAttack=false;
  Set<UUID> possibleDefender=game.getCombat().getCreaturesForcedToAttack().get(attackerId);
  if (possibleDefender != null) {
    forcedToAttack=true;
  }
  if (possibleDefender == null || possibleDefender.isEmpty()) {
    possibleDefender=defenders;
  }
  if (possibleDefender.size() == 1) {
    declareAttacker(attackerId,possibleDefender.iterator().next(),game,true);
    return true;
  }
 else {
    TargetDefender target=new TargetDefender(possibleDefender,attackerId);
    target.setNotTarget(true);
    if (forcedToAttack) {
      StringBuilder sb=new StringBuilder(target.getTargetName());
      Permanent attacker=game.getPermanent(attackerId);
      if (attacker != null) {
        sb.append(""String_Node_Str"").append(attacker.getName()).append(""String_Node_Str"");
        target.setTargetName(sb.toString());
      }
    }
    if (chooseTarget(Outcome.Damage,target,null,game)) {
      declareAttacker(attackerId,response.getUUID(),game,true);
      return true;
    }
  }
  return false;
}","/** 
 * Selects a defender for an attacker and adds the attacker to combat
 * @param defenders - list of possible defender
 * @param attackerId - UUID of attacker
 * @param game
 * @return
 */
protected boolean selectDefender(Set<UUID> defenders,UUID attackerId,Game game){
  boolean forcedToAttack=false;
  Set<UUID> possibleDefender=game.getCombat().getCreaturesForcedToAttack().get(attackerId);
  if (possibleDefender != null) {
    forcedToAttack=true;
  }
  if (possibleDefender == null || possibleDefender.isEmpty()) {
    possibleDefender=defenders;
  }
  if (possibleDefender.size() == 1) {
    declareAttacker(attackerId,possibleDefender.iterator().next(),game,true);
    return true;
  }
 else {
    TargetDefender target=new TargetDefender(possibleDefender,attackerId);
    target.setNotTarget(true);
    if (forcedToAttack) {
      StringBuilder sb=new StringBuilder(target.getTargetName());
      Permanent attacker=game.getPermanent(attackerId);
      if (attacker != null) {
        sb.append(""String_Node_Str"").append(attacker.getName()).append(""String_Node_Str"");
        target.setTargetName(sb.toString());
      }
    }
    if (chooseTarget(Outcome.Damage,target,null,game)) {
      UUID defenderId=response.getUUID();
      for (      Player player : game.getPlayers().values()) {
        if (player.getId().equals(response.getUUID())) {
          defenderId=player.getId();
          break;
        }
      }
      declareAttacker(attackerId,defenderId,game,true);
      return true;
    }
  }
  return false;
}",0.8887323943661972
158235,"@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  Permanent sourceObject=game.getPermanentOrLKIBattlefield(source.getSourceId());
  if (controller != null && sourceObject != null) {
    UUID defendingPlayerId=game.getCombat().getDefendingPlayerId(source.getSourceId(),game);
    if (defendingPlayerId == null) {
      Logger.getLogger(MyriadEffect.class).error(""String_Node_Str"" + sourceObject.getName() + ""String_Node_Str""+ (sourceObject.isAttacking() ? ""String_Node_Str"" : ""String_Node_Str""));
      return false;
    }
    List<Permanent> tokens=new ArrayList<>();
    for (    UUID playerId : game.getState().getPlayersInRange(controller.getId(),game)) {
      if (playerId != defendingPlayerId && controller.hasOpponent(playerId,game)) {
        Player opponent=game.getPlayer(playerId);
        if (opponent != null && controller.chooseUse(Outcome.PutCreatureInPlay,""String_Node_Str"" + sourceObject.getIdName() + ""String_Node_Str""+ opponent.getName()+ ""String_Node_Str"",source,game)) {
          PutTokenOntoBattlefieldCopyTargetEffect effect=new PutTokenOntoBattlefieldCopyTargetEffect(controller.getId(),null,false,1,true,true,playerId);
          effect.setTargetPointer(new FixedTarget(sourceObject,game));
          effect.apply(game,source);
          tokens.addAll(effect.getAddedPermanent());
        }
      }
    }
    if (!tokens.isEmpty()) {
      ExileTargetEffect exileEffect=new ExileTargetEffect();
      exileEffect.setTargetPointer(new FixedTargets(tokens,game));
      game.addDelayedTriggeredAbility(new AtTheEndOfCombatDelayedTriggeredAbility(exileEffect),source);
    }
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  Permanent sourceObject=game.getPermanentOrLKIBattlefield(source.getSourceId());
  if (controller != null && sourceObject != null) {
    UUID defendingPlayerId=game.getCombat().getDefendingPlayerId(source.getSourceId(),game);
    if (defendingPlayerId == null) {
      Logger.getLogger(MyriadEffect.class).error(""String_Node_Str"" + sourceObject.getName() + ""String_Node_Str""+ (sourceObject.isAttacking() ? ""String_Node_Str"" : ""String_Node_Str""));
      return false;
    }
    List<Permanent> tokens=new ArrayList<>();
    for (    UUID playerId : game.getState().getPlayersInRange(controller.getId(),game)) {
      if (!playerId.equals(defendingPlayerId) && controller.hasOpponent(playerId,game)) {
        Player opponent=game.getPlayer(playerId);
        if (opponent != null && controller.chooseUse(Outcome.PutCreatureInPlay,""String_Node_Str"" + sourceObject.getIdName() + ""String_Node_Str""+ opponent.getName()+ ""String_Node_Str"",source,game)) {
          PutTokenOntoBattlefieldCopyTargetEffect effect=new PutTokenOntoBattlefieldCopyTargetEffect(controller.getId(),null,false,1,true,true,playerId);
          effect.setTargetPointer(new FixedTarget(sourceObject,game));
          effect.apply(game,source);
          tokens.addAll(effect.getAddedPermanent());
        }
      }
    }
    if (!tokens.isEmpty()) {
      ExileTargetEffect exileEffect=new ExileTargetEffect();
      exileEffect.setTargetPointer(new FixedTargets(tokens,game));
      game.addDelayedTriggeredAbility(new AtTheEndOfCombatDelayedTriggeredAbility(exileEffect),source);
    }
    return true;
  }
  return false;
}",0.9818819403857392
158236,"@Override public boolean apply(Game game,Ability source){
  Permanent controlledCreature=game.getPermanent(source.getFirstTarget());
  if (controlledCreature != null) {
    DelayedTriggeredAbility delayedAbility=new MeriekeRiBeritDelayedTriggeredAbility();
    delayedAbility.getEffects().get(0).setTargetPointer(new FixedTarget(controlledCreature.getId()));
    delayedAbility.setSourceId(source.getSourceId());
    delayedAbility.setControllerId(source.getControllerId());
    delayedAbility.setSourceObject(source.getSourceObject(game),game);
    delayedAbility.init(game);
    game.addDelayedTriggeredAbility(delayedAbility);
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Permanent controlledCreature=game.getPermanent(source.getFirstTarget());
  if (controlledCreature != null) {
    DelayedTriggeredAbility delayedAbility=new MeriekeRiBeritDelayedTriggeredAbility();
    delayedAbility.getEffects().get(0).setTargetPointer(new FixedTarget(controlledCreature,game));
    game.addDelayedTriggeredAbility(delayedAbility,source);
    return true;
  }
  return false;
}",0.7967914438502673
158237,"@Override public boolean checkTrigger(GameEvent event,Game game){
  if (event.getSourceId() != null) {
    if (GameEvent.EventType.ZONE_CHANGE.equals(event.getType()) && event.getTargetId().equals(getSourceId())) {
      ZoneChangeEvent zEvent=(ZoneChangeEvent)event;
      return zEvent.getFromZone().equals(Zone.BATTLEFIELD);
    }
  }
  return GameEvent.EventType.UNTAPPED.equals(event.getType()) && event.getTargetId() != null && event.getTargetId().equals(getSourceId());
}","@Override public boolean checkTrigger(GameEvent event,Game game){
  if (event.getTargetId() != null) {
    if (GameEvent.EventType.ZONE_CHANGE.equals(event.getType()) && event.getTargetId().equals(getSourceId())) {
      ZoneChangeEvent zEvent=(ZoneChangeEvent)event;
      return zEvent.getFromZone().equals(Zone.BATTLEFIELD);
    }
  }
  return GameEvent.EventType.UNTAPPED.equals(event.getType()) && event.getTargetId() != null && event.getTargetId().equals(getSourceId());
}",0.98744769874477
158238,"/** 
 * Reflecting Pool does not count Crumbling Vestige as a source of all mana colors
 */
@Test public void testTriggeredManaAbility(){
  addCard(Zone.HAND,playerA,""String_Node_Str"",1);
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"",1);
  addCard(Zone.HAND,playerA,""String_Node_Str"",1);
  playLand(1,PhaseStep.PRECOMBAT_MAIN,playerA,""String_Node_Str"");
  castSpell(1,PhaseStep.PRECOMBAT_MAIN,playerA,""String_Node_Str"",playerB);
  setStopAt(1,PhaseStep.BEGIN_COMBAT);
  execute();
  assertPermanentCount(playerA,""String_Node_Str"",1);
  assertGraveyardCount(playerA,""String_Node_Str"",1);
  assertLife(playerA,20);
  assertLife(playerB,17);
}","/** 
 * Reflecting Pool does not count Crumbling Vestige as a source of all mana colors
 */
@Test public void testTriggeredManaAbility(){
  addCard(Zone.HAND,playerA,""String_Node_Str"",1);
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"",1);
  addCard(Zone.HAND,playerA,""String_Node_Str"",1);
  playLand(1,PhaseStep.PRECOMBAT_MAIN,playerA,""String_Node_Str"");
  setChoice(playerA,""String_Node_Str"");
  castSpell(1,PhaseStep.PRECOMBAT_MAIN,playerA,""String_Node_Str"",playerB);
  setStopAt(1,PhaseStep.BEGIN_COMBAT);
  execute();
  assertPermanentCount(playerA,""String_Node_Str"",1);
  assertGraveyardCount(playerA,""String_Node_Str"",1);
  assertLife(playerA,20);
  assertLife(playerB,17);
}",0.970014992503748
158239,"public void applyEffects(Game game){
  game.resetShortLivingLKI();
  for (  Player player : players.values()) {
    player.reset();
  }
  battlefield.reset(game);
  combat.reset(game);
  this.reset();
  effects.apply(game);
  combat.checkForRemoveFromCombat(game);
}","public void applyEffects(Game game){
  for (  Player player : players.values()) {
    player.reset();
  }
  battlefield.reset(game);
  combat.reset(game);
  this.reset();
  effects.apply(game);
  combat.checkForRemoveFromCombat(game);
}",0.9402390438247012
158240,"public void processAction(Game game){
  game.getState().handleSimultaneousEvent(game);
  applyEffects(game);
}","public void processAction(Game game){
  game.getState().handleSimultaneousEvent(game);
  game.applyEffects();
}",0.9592760180995475
158241,"public void removeEocEffects(Game game){
  effects.removeEndOfCombatEffects();
  delayed.removeEndOfCombatAbilities();
  applyEffects(game);
}","public void removeEocEffects(Game game){
  effects.removeEndOfCombatEffects();
  delayed.removeEndOfCombatAbilities();
  game.applyEffects();
}",0.968421052631579
158242,"public void removeEotEffects(Game game){
  effects.removeEndOfTurnEffects();
  delayed.removeEndOfTurnAbilities();
  applyEffects(game);
}","public void removeEotEffects(Game game){
  effects.removeEndOfTurnEffects();
  delayed.removeEndOfTurnAbilities();
  game.applyEffects();
}",0.967509025270758
158243,"public boolean putOntoBattlefield(int amount,Game game,UUID sourceId,UUID controllerId,boolean tapped,boolean attacking,UUID attackedPlayer){
  Player controller=game.getPlayer(controllerId);
  if (controller == null) {
    return false;
  }
  lastAddedTokenIds.clear();
  String setCode=null;
  if (this.getOriginalExpansionSetCode() != null && !this.getOriginalExpansionSetCode().isEmpty()) {
    setCode=this.getOriginalExpansionSetCode();
  }
 else {
    Card source=game.getCard(sourceId);
    if (source != null) {
      setCode=source.getExpansionSetCode();
    }
 else {
      MageObject object=game.getObject(sourceId);
      if (object instanceof PermanentToken) {
        setCode=((PermanentToken)object).getExpansionSetCode();
      }
    }
  }
  if (!expansionSetCodeChecked) {
    expansionSetCodeChecked=this.updateExpansionSetCode(setCode);
  }
  GameEvent event=new GameEvent(EventType.CREATE_TOKEN,null,sourceId,controllerId,amount,this.getCardType().contains(CardType.CREATURE));
  if (!game.replaceEvent(event)) {
    amount=event.getAmount();
    List<Permanent> permanents=new ArrayList<>();
    List<Permanent> permanentsEntered=new ArrayList<>();
    for (int i=0; i < amount; i++) {
      PermanentToken newToken=new PermanentToken(this,event.getPlayerId(),setCode,game);
      game.getState().addCard(newToken);
      permanents.add(newToken);
      game.getPermanentsEntering().put(newToken.getId(),newToken);
      newToken.setTapped(tapped);
    }
    game.setScopeRelevant(true);
    for (    Permanent permanent : permanents) {
      if (permanent.entersBattlefield(sourceId,game,Zone.OUTSIDE,true)) {
        permanentsEntered.add(permanent);
      }
 else {
        game.getPermanentsEntering().remove(permanent.getId());
      }
    }
    game.setScopeRelevant(false);
    for (    Permanent permanent : permanentsEntered) {
      game.addPermanent(permanent);
      permanent.setZone(Zone.BATTLEFIELD,game);
      game.getPermanentsEntering().remove(permanent.getId());
      this.lastAddedTokenIds.add(permanent.getId());
      this.lastAddedTokenId=permanent.getId();
      game.addSimultaneousEvent(new ZoneChangeEvent(permanent,permanent.getControllerId(),Zone.OUTSIDE,Zone.BATTLEFIELD));
      if (attacking && game.getCombat() != null) {
        game.getCombat().addAttackingCreature(permanent.getId(),game,attackedPlayer);
      }
      if (!game.isSimulation()) {
        game.informPlayers(controller.getLogName() + ""String_Node_Str"" + permanent.getLogName()+ ""String_Node_Str"");
      }
    }
    return true;
  }
  return false;
}","public boolean putOntoBattlefield(int amount,Game game,UUID sourceId,UUID controllerId,boolean tapped,boolean attacking,UUID attackedPlayer){
  Player controller=game.getPlayer(controllerId);
  if (controller == null) {
    return false;
  }
  lastAddedTokenIds.clear();
  String setCode=null;
  if (this.getOriginalExpansionSetCode() != null && !this.getOriginalExpansionSetCode().isEmpty()) {
    setCode=this.getOriginalExpansionSetCode();
  }
 else {
    Card source=game.getCard(sourceId);
    if (source != null) {
      setCode=source.getExpansionSetCode();
    }
 else {
      MageObject object=game.getObject(sourceId);
      if (object instanceof PermanentToken) {
        setCode=((PermanentToken)object).getExpansionSetCode();
      }
    }
  }
  if (!expansionSetCodeChecked) {
    expansionSetCodeChecked=this.updateExpansionSetCode(setCode);
  }
  GameEvent event=new GameEvent(EventType.CREATE_TOKEN,null,sourceId,controllerId,amount,this.getCardType().contains(CardType.CREATURE));
  if (!game.replaceEvent(event)) {
    amount=event.getAmount();
    List<Permanent> permanents=new ArrayList<>();
    List<Permanent> permanentsEntered=new ArrayList<>();
    for (int i=0; i < amount; i++) {
      PermanentToken newToken=new PermanentToken(this,event.getPlayerId(),setCode,game);
      game.getState().addCard(newToken);
      permanents.add(newToken);
      game.getPermanentsEntering().put(newToken.getId(),newToken);
      newToken.setTapped(tapped);
    }
    game.setScopeRelevant(true);
    for (    Permanent permanent : permanents) {
      if (permanent.entersBattlefield(sourceId,game,Zone.OUTSIDE,true)) {
        permanentsEntered.add(permanent);
      }
 else {
        game.getPermanentsEntering().remove(permanent.getId());
      }
    }
    game.setScopeRelevant(false);
    for (    Permanent permanent : permanentsEntered) {
      game.addPermanent(permanent);
      permanent.setZone(Zone.BATTLEFIELD,game);
      game.getPermanentsEntering().remove(permanent.getId());
      this.lastAddedTokenIds.add(permanent.getId());
      this.lastAddedTokenId=permanent.getId();
      game.addSimultaneousEvent(new ZoneChangeEvent(permanent,permanent.getControllerId(),Zone.OUTSIDE,Zone.BATTLEFIELD));
      if (attacking && game.getCombat() != null) {
        game.getCombat().addAttackingCreature(permanent.getId(),game,attackedPlayer);
      }
      if (!game.isSimulation()) {
        game.informPlayers(controller.getLogName() + ""String_Node_Str"" + permanent.getLogName()+ ""String_Node_Str"");
      }
    }
    game.getState().applyEffects(game);
    return true;
  }
  return false;
}",0.9922958397534668
158244,"@Override public synchronized void applyEffects(){
  state.applyEffects(this);
}","@Override public synchronized void applyEffects(){
  resetShortLivingLKI();
  state.applyEffects(this);
}",0.8648648648648649
158245,"@Override public boolean apply(Game game,Ability source){
  MageObject sourceObject=source.getSourceObject(game);
  if (sourceObject == null) {
    return false;
  }
  Map<UUID,Set<Card>> permanentsOwned=new HashMap<>();
  Collection<Permanent> permanents=game.getBattlefield().getAllActivePermanents();
  for (  Permanent permanent : permanents) {
    Set<Card> set=permanentsOwned.get(permanent.getOwnerId());
    if (set == null) {
      set=new LinkedHashSet<>();
    }
    set.add(permanent);
    permanentsOwned.put(permanent.getOwnerId(),set);
  }
  Map<UUID,Integer> permanentsCount=new HashMap<>();
  for (  UUID playerId : game.getState().getPlayersInRange(source.getControllerId(),game)) {
    Player player=game.getPlayer(playerId);
    if (player != null) {
      Set<Card> set=permanentsOwned.remove(playerId);
      Integer count=0;
      if (set != null) {
        count=set.size();
        player.moveCards(set,Zone.LIBRARY,source,game);
      }
      if (count > 0) {
        player.shuffleLibrary(source,game);
      }
      permanentsCount.put(playerId,count);
    }
  }
  game.applyEffects();
  Map<UUID,CardsImpl> cardsRevealed=new HashMap<>();
  for (  UUID playerId : game.getState().getPlayersInRange(source.getControllerId(),game)) {
    Player player=game.getPlayer(playerId);
    if (player != null) {
      Integer count=Math.min(permanentsCount.get(player.getId()),player.getLibrary().size());
      CardsImpl cards=new CardsImpl();
      for (int i=0; i < count; i++) {
        Card card=player.getLibrary().removeFromTop(game);
        if (card != null) {
          cards.add(card);
        }
      }
      player.revealCards(sourceObject.getIdName() + ""String_Node_Str"" + player.getName()+ ""String_Node_Str"",cards,game);
      cardsRevealed.put(player.getId(),cards);
    }
  }
  for (  UUID playerId : game.getState().getPlayersInRange(source.getControllerId(),game)) {
    Player player=game.getPlayer(playerId);
    if (player != null) {
      CardsImpl cards=cardsRevealed.get(player.getId());
      for (      Card card : cards.getCards(game)) {
        if (card != null && (card.getCardType().contains(CardType.ARTIFACT) || card.getCardType().contains(CardType.CREATURE) || card.getCardType().contains(CardType.LAND))) {
          card.putOntoBattlefield(game,Zone.LIBRARY,source.getSourceId(),player.getId());
          cards.remove(card);
        }
      }
    }
  }
  for (  UUID playerId : game.getState().getPlayersInRange(source.getControllerId(),game)) {
    Player player=game.getPlayer(playerId);
    if (player != null) {
      CardsImpl cards=cardsRevealed.get(player.getId());
      for (      Card card : cards.getCards(game)) {
        if (card != null && card.getCardType().contains(CardType.ENCHANTMENT)) {
          card.putOntoBattlefield(game,Zone.LIBRARY,source.getSourceId(),player.getId());
          cards.remove(card);
        }
      }
    }
  }
  for (  UUID playerId : game.getState().getPlayersInRange(source.getControllerId(),game)) {
    Player player=game.getPlayer(playerId);
    if (player != null) {
      CardsImpl cards=cardsRevealed.get(player.getId());
      player.putCardsOnBottomOfLibrary(cards,game,source,false);
    }
  }
  return true;
}","@Override public boolean apply(Game game,Ability source){
  MageObject sourceObject=source.getSourceObject(game);
  if (sourceObject == null) {
    return false;
  }
  Map<UUID,Set<Card>> permanentsOwned=new HashMap<>();
  Collection<Permanent> permanents=game.getBattlefield().getAllActivePermanents();
  for (  Permanent permanent : permanents) {
    Set<Card> set=permanentsOwned.get(permanent.getOwnerId());
    if (set == null) {
      set=new LinkedHashSet<>();
    }
    set.add(permanent);
    permanentsOwned.put(permanent.getOwnerId(),set);
  }
  Map<UUID,Integer> permanentsCount=new HashMap<>();
  for (  UUID playerId : game.getState().getPlayersInRange(source.getControllerId(),game)) {
    Player player=game.getPlayer(playerId);
    if (player != null) {
      Set<Card> set=permanentsOwned.remove(playerId);
      Integer count=0;
      if (set != null) {
        count=set.size();
        player.moveCards(set,Zone.LIBRARY,source,game);
      }
      if (count > 0) {
        player.shuffleLibrary(source,game);
      }
      permanentsCount.put(playerId,count);
    }
  }
  game.applyEffects();
  Map<UUID,CardsImpl> cardsRevealed=new HashMap<>();
  for (  UUID playerId : game.getState().getPlayersInRange(source.getControllerId(),game)) {
    Player player=game.getPlayer(playerId);
    if (player != null) {
      CardsImpl cards=new CardsImpl();
      cards.addAll(player.getLibrary().getTopCards(game,permanentsCount.get(player.getId())));
      player.revealCards(sourceObject.getIdName() + ""String_Node_Str"" + player.getName()+ ""String_Node_Str"",cards,game);
      cardsRevealed.put(player.getId(),cards);
    }
  }
  for (  UUID playerId : game.getState().getPlayersInRange(source.getControllerId(),game)) {
    Player player=game.getPlayer(playerId);
    if (player != null) {
      CardsImpl cards=cardsRevealed.get(player.getId());
      for (      Card card : cards.getCards(game)) {
        if (card != null && (card.getCardType().contains(CardType.ARTIFACT) || card.getCardType().contains(CardType.CREATURE) || card.getCardType().contains(CardType.LAND))) {
          card.putOntoBattlefield(game,Zone.LIBRARY,source.getSourceId(),player.getId());
          cards.remove(card);
        }
      }
    }
  }
  for (  UUID playerId : game.getState().getPlayersInRange(source.getControllerId(),game)) {
    Player player=game.getPlayer(playerId);
    if (player != null) {
      CardsImpl cards=cardsRevealed.get(player.getId());
      for (      Card card : cards.getCards(game)) {
        if (card != null && card.getCardType().contains(CardType.ENCHANTMENT)) {
          card.putOntoBattlefield(game,Zone.LIBRARY,source.getSourceId(),player.getId());
          cards.remove(card);
        }
      }
    }
  }
  for (  UUID playerId : game.getState().getPlayersInRange(source.getControllerId(),game)) {
    Player player=game.getPlayer(playerId);
    if (player != null) {
      CardsImpl cards=cardsRevealed.get(player.getId());
      player.putCardsOnBottomOfLibrary(cards,game,source,false);
    }
  }
  return true;
}",0.9402199904351984
158246,"@Override public boolean apply(Permanent input,Game game){
  Player owner=game.getPlayer(input.getOwnerId());
  return input.getCardType().contains(CardType.CREATURE) && owner != null && input.getId().equals(owner.getCommandersIds());
}","@Override public boolean apply(Permanent input,Game game){
  Player owner=game.getPlayer(input.getOwnerId());
  return input.getCardType().contains(CardType.CREATURE) && owner != null && owner.getCommandersIds().contains(input.getId());
}",0.8312236286919831
158247,"@Override public boolean apply(Game game,Ability source){
  Player player=game.getPlayer(targetPointer.getFirst(game,source));
  if (player != null) {
    Token lightningRagerToken=new LightningRagerToken();
    lightningRagerToken.putOntoBattlefield(1,game,this.getId(),player.getId());
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Player player=game.getPlayer(targetPointer.getFirst(game,source));
  if (player != null) {
    return new LightningRagerToken().putOntoBattlefield(1,game,source.getSourceId(),player.getId());
  }
  return false;
}",0.5807560137457045
158248,"@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller != null) {
    ArrayList<UUID> players=new ArrayList<>();
    ArrayList<UUID> creatures=new ArrayList<>();
    for (    UUID playerId : game.getState().getPlayersInRange(controller.getId(),game)) {
      Player player=game.getPlayer(playerId);
      if (player != null) {
        if (player.chooseUse(outcome,""String_Node_Str"",source,game)) {
          Target target=new TargetControlledCreaturePermanent(new FilterControlledCreaturePermanent(""String_Node_Str""));
          if (player.choose(outcome,target,playerId,game)) {
            creatures.add(target.getFirstTarget());
            players.add(player.getId());
          }
        }
      }
    }
    for (    UUID creatureId : creatures) {
      Permanent creature=game.getPermanent(creatureId);
      if (creature != null) {
        creature.addCounters(CounterType.P1P1.createInstance(2),game);
      }
    }
    for (    UUID playerId : players) {
      FilterCreaturePermanent filter=new FilterCreaturePermanent();
      filter.add(new PlayerIdPredicate(playerId));
      game.addEffect(new CantAttackYouAllEffect(Duration.UntilYourNextTurn,filter,true),source);
    }
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller != null) {
    ArrayList<UUID> players=new ArrayList<>();
    ArrayList<UUID> creatures=new ArrayList<>();
    for (    UUID playerId : game.getState().getPlayersInRange(controller.getId(),game)) {
      Player player=game.getPlayer(playerId);
      if (player != null) {
        if (player.chooseUse(outcome,""String_Node_Str"",source,game)) {
          Target target=new TargetControlledCreaturePermanent(new FilterControlledCreaturePermanent(""String_Node_Str""));
          if (player.choose(outcome,target,playerId,game)) {
            creatures.add(target.getFirstTarget());
            players.add(player.getId());
          }
        }
      }
    }
    for (    UUID creatureId : creatures) {
      Permanent creature=game.getPermanent(creatureId);
      if (creature != null) {
        creature.addCounters(CounterType.P1P1.createInstance(2),game);
      }
    }
    for (    UUID playerId : players) {
      FilterCreaturePermanent filter=new FilterCreaturePermanent();
      filter.add(new ControllerIdPredicate(playerId));
      game.addEffect(new CantAttackYouAllEffect(Duration.UntilYourNextTurn,filter,true),source);
    }
    return true;
  }
  return false;
}",0.9954128440366972
158249,"@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  Player opponent=game.getPlayer(this.getTargetPointer().getFirst(game,source));
  if (controller != null && opponent != null) {
    Cards cards=new CardsImpl();
    int numLooked=Math.min(2,opponent.getLibrary().size());
    if (numLooked > 0) {
      for (int i=0; i < numLooked; i++) {
        cards.add(opponent.getLibrary().removeFromTop(game));
      }
      TargetCard target=new TargetCardInLibrary(new FilterCard(""String_Node_Str""));
      controller.choose(Outcome.Exile,cards,target,game);
      Card card=cards.get(target.getFirstTarget(),game);
      cards.remove(card);
      opponent.moveCardToExileWithInfo(card,null,""String_Node_Str"",source.getSourceId(),game,Zone.LIBRARY,true);
      if (cards.size() == 1) {
        card=cards.get(cards.iterator().next(),game);
        opponent.moveCardToLibraryWithInfo(card,source.getSourceId(),game,Zone.LIBRARY,true,false);
      }
    }
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  Player opponent=game.getPlayer(this.getTargetPointer().getFirst(game,source));
  if (controller != null && opponent != null) {
    Cards cards=new CardsImpl();
    cards.addAll(opponent.getLibrary().getTopCards(game,2));
    if (cards.size() > 0) {
      TargetCard target=new TargetCardInLibrary(new FilterCard(""String_Node_Str""));
      if (controller.choose(Outcome.Exile,cards,target,game)) {
        Card card=cards.get(target.getFirstTarget(),game);
        if (card != null) {
          cards.remove(card);
          opponent.moveCards(card,Zone.EXILED,source,game);
        }
      }
    }
    return true;
  }
  return false;
}",0.6103752759381899
158250,"public void setExpansionSetCodeForImage(String code){
  if (availableImageSetCodes.size() > 0) {
    if (availableImageSetCodes.contains(code)) {
      setOriginalExpansionSetCode(code);
    }
 else     if (getOriginalExpansionSetCode() == null || getOriginalExpansionSetCode().isEmpty() || !availableImageSetCodes.contains(getOriginalExpansionSetCode())) {
      setOriginalExpansionSetCode(availableImageSetCodes.get(RandomUtil.nextInt(availableImageSetCodes.size())));
    }
  }
 else   if (getOriginalExpansionSetCode() == null || getOriginalExpansionSetCode().isEmpty()) {
    setOriginalExpansionSetCode(code);
  }
  setTokenDescriptor();
}","public void setExpansionSetCodeForImage(String code){
  if (availableImageSetCodes.size() > 0) {
    if (availableImageSetCodes.contains(code)) {
      setOriginalExpansionSetCode(code);
    }
 else {
      if (getOriginalExpansionSetCode() == null || getOriginalExpansionSetCode().isEmpty() || !availableImageSetCodes.contains(getOriginalExpansionSetCode())) {
        setOriginalExpansionSetCode(availableImageSetCodes.get(RandomUtil.nextInt(availableImageSetCodes.size())));
      }
    }
  }
 else   if (getOriginalExpansionSetCode() == null || getOriginalExpansionSetCode().isEmpty()) {
    setOriginalExpansionSetCode(code);
  }
  setTokenDescriptor();
}",0.9892802450229708
158251,"@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller != null) {
    UUID playerId=(UUID)game.getState().getValue(source.getSourceId() + ""String_Node_Str"");
    Player player=game.getPlayer(playerId);
    if (player != null && player.canRespond()) {
      player.damage((Integer)this.getValue(""String_Node_Str""),source.getSourceId(),game,false,true);
    }
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller != null) {
    UUID playerId=(UUID)game.getState().getValue(source.getSourceId() + ""String_Node_Str"");
    Player player=game.getPlayer(playerId);
    if (player != null && player.canRespond()) {
      Integer damage=(Integer)this.getValue(""String_Node_Str"");
      if (damage > 0) {
        player.damage(damage,source.getSourceId(),game,false,true);
      }
    }
    return true;
  }
  return false;
}",0.8812561334641805
158252,"@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  MageObject sourceObject=game.getObject(source.getSourceId());
  if (controller != null && sourceObject != null) {
    Cards cards=new CardsImpl();
    cards.addAll(controller.getLibrary().getTopCards(game,4));
    boolean properCardFound=cards.count(filterPutInHand,source.getControllerId(),source.getSourceId(),game) > 0;
    if (!cards.isEmpty()) {
      controller.revealCards(sourceObject.getName(),cards,game);
      TargetCard target=new TargetCard(Zone.LIBRARY,filterPutInHand);
      if (properCardFound && controller.chooseUse(outcome,""String_Node_Str"",source,game) && controller.choose(Outcome.DrawCard,cards,target,game)) {
        Card card=game.getCard(target.getFirstTarget());
        if (card != null) {
          cards.remove(card);
          controller.moveCards(card,Zone.HAND,source,game);
        }
      }
      controller.moveCards(cards,Zone.GRAVEYARD,source,game);
    }
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  MageObject sourceObject=game.getObject(source.getSourceId());
  if (controller != null && sourceObject != null) {
    Cards cards=new CardsImpl();
    cards.addAll(controller.getLibrary().getTopCards(game,4));
    boolean properCardFound=cards.count(filterPutInHand,source.getControllerId(),source.getSourceId(),game) > 0;
    if (!cards.isEmpty()) {
      controller.revealCards(sourceObject.getIdName(),cards,game);
      TargetCard target=new TargetCard(Zone.LIBRARY,filterPutInHand);
      if (properCardFound && controller.chooseUse(outcome,""String_Node_Str"",source,game) && controller.choose(Outcome.DrawCard,cards,target,game)) {
        Card card=game.getCard(target.getFirstTarget());
        if (card != null) {
          cards.remove(card);
          controller.moveCards(card,Zone.HAND,source,game);
        }
      }
      controller.moveCards(cards,Zone.GRAVEYARD,source,game);
    }
    return true;
  }
  return false;
}",0.999053926206244
158253,"@Override public boolean checkTrigger(GameEvent event,Game game){
  if (!onlyCombat || ((DamagedPlayerEvent)event).isCombatDamage()) {
    Permanent permanent=game.getPermanent(event.getSourceId());
    if (permanent != null) {
      if (filter.match(permanent,getSourceId(),getControllerId(),game)) {
        if (!setTargetPointer.equals(SetTargetPointer.NONE)) {
          for (          Effect effect : this.getEffects()) {
            effect.setValue(""String_Node_Str"",event.getAmount());
switch (setTargetPointer) {
case PLAYER:
              effect.setTargetPointer(new FixedTarget(permanent.getControllerId()));
            break;
case PERMANENT:
          effect.setTargetPointer(new FixedTarget(permanent.getId(),permanent.getZoneChangeCounter(game)));
        break;
    }
  }
}
return true;
}
}
}
return false;
}","@Override public boolean checkTrigger(GameEvent event,Game game){
  if (!onlyCombat || ((DamagedPlayerEvent)event).isCombatDamage()) {
    Permanent permanent=game.getPermanent(event.getSourceId());
    if (permanent != null) {
      if (filter.match(permanent,getSourceId(),getControllerId(),game)) {
        for (        Effect effect : this.getEffects()) {
          effect.setValue(""String_Node_Str"",event.getAmount());
switch (setTargetPointer) {
case PLAYER:
            effect.setTargetPointer(new FixedTarget(permanent.getControllerId()));
          break;
case PERMANENT:
        effect.setTargetPointer(new FixedTarget(permanent.getId(),permanent.getZoneChangeCounter(game)));
      break;
  }
}
return true;
}
}
}
return false;
}",0.854766474728087
158254,"@Override public CardsDrawnThisTurnWatcher copy(){
  return new CardsDrawnThisTurnWatcher(this);
}","@Override public KydeleCardsDrawnThisTurnWatcher copy(){
  return new KydeleCardsDrawnThisTurnWatcher(this);
}",0.9423076923076924
158255,"@Override public int calculate(Game game,Ability sourceAbility,Effect effect){
  CardsDrawnThisTurnWatcher watcher=(CardsDrawnThisTurnWatcher)game.getState().getWatchers().get(""String_Node_Str"");
  return watcher.getNumCardsDrawnThisTurn(sourceAbility.getControllerId());
}","@Override public int calculate(Game game,Ability sourceAbility,Effect effect){
  KydeleCardsDrawnThisTurnWatcher watcher=(KydeleCardsDrawnThisTurnWatcher)game.getState().getWatchers().get(KydeleCardsDrawnThisTurnWatcher.class.getName());
  return watcher.getNumCardsDrawnThisTurn(sourceAbility.getControllerId());
}",0.8741496598639455
158256,"@Override public CardsDrawnThisTurnWatcher copy(){
  return new CardsDrawnThisTurnWatcher(this);
}","@Override public SylvanLibraryCardsDrawnThisTurnWatcher copy(){
  return new SylvanLibraryCardsDrawnThisTurnWatcher(this);
}",0.8828828828828829
158257,"/** 
 * Determines if permanent can damage in current (First Strike or not) combat damage step
 * @param perm Permanent to check
 * @param first First strike or common combat damage step
 * @return
 */
private boolean canDamage(Permanent perm,boolean first){
  if (first) {
    return hasFirstOrDoubleStrike(perm);
  }
 else {
    if (hasFirstStrike(perm)) {
      return hasDoubleStrike(perm);
    }
    return true;
  }
}","/** 
 * Determines if permanent can damage in current (First Strike or not) combat damage step
 * @param perm Permanent to check
 * @param first First strike or common combat damage step
 * @return
 */
private boolean canDamage(Permanent perm,boolean first){
  if (perm == null) {
    return false;
  }
  if (first) {
    return hasFirstOrDoubleStrike(perm);
  }
 else {
    if (hasFirstStrike(perm)) {
      return hasDoubleStrike(perm);
    }
    return true;
  }
}",0.9393258426966292
158258,"/** 
 * returns a list of Permanents that produce mana sorted by the number of mana the Permanent produces that match the unpaid costs in ascending order the idea is that we should pay costs first from mana producers that produce only one type of mana and save the multi-mana producers for those costs that can't be paid by any other producers
 * @param unpaid - the amount of unpaid mana costs
 * @param game
 * @return List<Permanent>
 */
private List<MageObject> getSortedProducers(ManaCosts<ManaCost> unpaid,Game game){
  List<MageObject> unsorted=this.getAvailableManaProducers(game);
  unsorted.addAll(this.getAvailableManaProducersWithCost(game));
  Map<MageObject,Integer> scored=new HashMap<>();
  for (  MageObject mageObject : unsorted) {
    int score=0;
    for (    ManaCost cost : unpaid) {
      Abilities:       for (      ManaAbility ability : mageObject.getAbilities().getAvailableManaAbilities(Zone.BATTLEFIELD,game)) {
        for (        Mana netMana : ability.getNetMana(game)) {
          if (cost.testPay(netMana)) {
            score++;
            break Abilities;
          }
        }
      }
    }
    if (score > 0) {
      score+=mageObject.getAbilities().getAvailableManaAbilities(Zone.BATTLEFIELD,game).size();
      score+=mageObject.getAbilities().getActivatedAbilities(Zone.BATTLEFIELD).size();
      if (!mageObject.getCardType().contains(CardType.LAND)) {
        score+=2;
      }
 else       if (mageObject.getCardType().contains(CardType.CREATURE)) {
        score+=2;
      }
    }
    scored.put(mageObject,score);
  }
  return sortByValue(scored);
}","/** 
 * returns a list of Permanents that produce mana sorted by the number of mana the Permanent produces that match the unpaid costs in ascending order the idea is that we should pay costs first from mana producers that produce only one type of mana and save the multi-mana producers for those costs that can't be paid by any other producers
 * @param unpaid - the amount of unpaid mana costs
 * @param game
 * @return List<Permanent>
 */
private List<MageObject> getSortedProducers(ManaCosts<ManaCost> unpaid,Game game){
  List<MageObject> unsorted=this.getAvailableManaProducers(game);
  unsorted.addAll(this.getAvailableManaProducersWithCost(game));
  Map<MageObject,Integer> scored=new HashMap<>();
  for (  MageObject mageObject : unsorted) {
    int score=0;
    for (    ManaCost cost : unpaid) {
      Abilities:       for (      ActivatedManaAbilityImpl ability : mageObject.getAbilities().getAvailableActivatedManaAbilities(Zone.BATTLEFIELD,game)) {
        for (        Mana netMana : ability.getNetMana(game)) {
          if (cost.testPay(netMana)) {
            score++;
            break Abilities;
          }
        }
      }
    }
    if (score > 0) {
      score+=mageObject.getAbilities().getAvailableActivatedManaAbilities(Zone.BATTLEFIELD,game).size();
      score+=mageObject.getAbilities().getActivatedAbilities(Zone.BATTLEFIELD).size();
      if (!mageObject.getCardType().contains(CardType.LAND)) {
        score+=2;
      }
 else       if (mageObject.getCardType().contains(CardType.CREATURE)) {
        score+=2;
      }
    }
    scored.put(mageObject,score);
  }
  return sortByValue(scored);
}",0.990375659733002
158259,"protected void playALand(Set<Card> lands,Game game){
  log.debug(""String_Node_Str"");
  for (  Mana mana : unplayable.keySet()) {
    for (    Card card : lands) {
      for (      ManaAbility ability : card.getAbilities().getManaAbilities(Zone.BATTLEFIELD)) {
        for (        Mana netMana : ability.getNetMana(game)) {
          if (netMana.enough(mana)) {
            this.playLand(card,game,false);
            lands.remove(card);
            return;
          }
        }
      }
    }
  }
  for (  Mana mana : unplayable.keySet()) {
    for (    Card card : lands) {
      for (      ManaAbility ability : card.getAbilities().getManaAbilities(Zone.BATTLEFIELD)) {
        for (        Mana netMana : ability.getNetMana(game)) {
          if (mana.contains(netMana)) {
            this.playLand(card,game,false);
            lands.remove(card);
            return;
          }
        }
      }
    }
  }
  this.playLand(lands.iterator().next(),game,false);
  lands.remove(lands.iterator().next());
}","protected void playALand(Set<Card> lands,Game game){
  log.debug(""String_Node_Str"");
  for (  Mana mana : unplayable.keySet()) {
    for (    Card card : lands) {
      for (      ActivatedManaAbilityImpl ability : card.getAbilities().getActivatedManaAbilities(Zone.BATTLEFIELD)) {
        for (        Mana netMana : ability.getNetMana(game)) {
          if (netMana.enough(mana)) {
            this.playLand(card,game,false);
            lands.remove(card);
            return;
          }
        }
      }
    }
  }
  for (  Mana mana : unplayable.keySet()) {
    for (    Card card : lands) {
      for (      ActivatedManaAbilityImpl ability : card.getAbilities().getActivatedManaAbilities(Zone.BATTLEFIELD)) {
        for (        Mana netMana : ability.getNetMana(game)) {
          if (mana.contains(netMana)) {
            this.playLand(card,game,false);
            lands.remove(card);
            return;
          }
        }
      }
    }
  }
  this.playLand(lands.iterator().next(),game,false);
  lands.remove(lands.iterator().next());
}",0.9572815533980582
158260,"protected boolean playManaHandling(Ability ability,ManaCost unpaid,Game game){
  boolean spendAnyMana=game.getContinuousEffects().asThough(ability.getSourceId(),AsThoughEffectType.SPEND_OTHER_MANA,ability,ability.getControllerId(),game);
  ManaCost cost;
  List<MageObject> producers;
  if (unpaid instanceof ManaCosts) {
    ManaCosts<ManaCost> manaCosts=(ManaCosts<ManaCost>)unpaid;
    cost=manaCosts.get(manaCosts.size() - 1);
    producers=getSortedProducers((ManaCosts)unpaid,game);
  }
 else {
    cost=unpaid;
    producers=this.getAvailableManaProducers(game);
    producers.addAll(this.getAvailableManaProducersWithCost(game));
  }
  for (  MageObject mageObject : producers) {
    ManaAbility:     for (    ManaAbility manaAbility : mageObject.getAbilities().getAvailableManaAbilities(Zone.BATTLEFIELD,game)) {
      int colored=0;
      for (      Mana mana : manaAbility.getNetMana(game)) {
        if (!unpaid.getMana().includesMana(mana)) {
          continue ManaAbility;
        }
        colored+=mana.countColored();
      }
      if (colored > 1 && (cost instanceof ColoredManaCost)) {
        for (        Mana netMana : manaAbility.getNetMana(game)) {
          if (cost.testPay(netMana)) {
            if (activateAbility(manaAbility,game)) {
              return true;
            }
          }
        }
      }
    }
  }
  for (  MageObject mageObject : producers) {
    for (    ManaAbility manaAbility : mageObject.getAbilities().getAvailableManaAbilities(Zone.BATTLEFIELD,game)) {
      if (cost instanceof ColoredManaCost) {
        for (        Mana netMana : manaAbility.getNetMana(game)) {
          if (cost.testPay(netMana) || spendAnyMana) {
            if (activateAbility(manaAbility,game)) {
              return true;
            }
          }
        }
      }
    }
    for (    ManaAbility manaAbility : mageObject.getAbilities().getAvailableManaAbilities(Zone.BATTLEFIELD,game)) {
      if (cost instanceof HybridManaCost) {
        for (        Mana netMana : manaAbility.getNetMana(game)) {
          if (cost.testPay(netMana) || spendAnyMana) {
            if (activateAbility(manaAbility,game)) {
              return true;
            }
          }
        }
      }
    }
    for (    ManaAbility manaAbility : mageObject.getAbilities().getAvailableManaAbilities(Zone.BATTLEFIELD,game)) {
      if (cost instanceof MonoHybridManaCost) {
        for (        Mana netMana : manaAbility.getNetMana(game)) {
          if (cost.testPay(netMana) || spendAnyMana) {
            if (activateAbility(manaAbility,game)) {
              return true;
            }
          }
        }
      }
    }
    for (    ManaAbility manaAbility : mageObject.getAbilities().getAvailableManaAbilities(Zone.BATTLEFIELD,game)) {
      if (cost instanceof ColorlessManaCost) {
        for (        Mana netMana : manaAbility.getNetMana(game)) {
          if (cost.testPay(netMana) || spendAnyMana) {
            if (activateAbility(manaAbility,game)) {
              return true;
            }
          }
        }
      }
    }
    for (    ManaAbility manaAbility : mageObject.getAbilities().getAvailableManaAbilities(Zone.BATTLEFIELD,game)) {
      if (cost instanceof GenericManaCost) {
        for (        Mana netMana : manaAbility.getNetMana(game)) {
          if (cost.testPay(netMana) || spendAnyMana) {
            if (activateAbility(manaAbility,game)) {
              return true;
            }
          }
        }
      }
    }
  }
  if (cost instanceof PhyrexianManaCost) {
    if (cost.pay(null,game,null,playerId,false,null) || spendAnyMana) {
      return true;
    }
  }
  return false;
}","protected boolean playManaHandling(Ability ability,ManaCost unpaid,Game game){
  boolean spendAnyMana=game.getContinuousEffects().asThough(ability.getSourceId(),AsThoughEffectType.SPEND_OTHER_MANA,ability,ability.getControllerId(),game);
  ManaCost cost;
  List<MageObject> producers;
  if (unpaid instanceof ManaCosts) {
    ManaCosts<ManaCost> manaCosts=(ManaCosts<ManaCost>)unpaid;
    cost=manaCosts.get(manaCosts.size() - 1);
    producers=getSortedProducers((ManaCosts)unpaid,game);
  }
 else {
    cost=unpaid;
    producers=this.getAvailableManaProducers(game);
    producers.addAll(this.getAvailableManaProducersWithCost(game));
  }
  for (  MageObject mageObject : producers) {
    ManaAbility:     for (    ActivatedManaAbilityImpl manaAbility : mageObject.getAbilities().getAvailableActivatedManaAbilities(Zone.BATTLEFIELD,game)) {
      int colored=0;
      for (      Mana mana : manaAbility.getNetMana(game)) {
        if (!unpaid.getMana().includesMana(mana)) {
          continue ManaAbility;
        }
        colored+=mana.countColored();
      }
      if (colored > 1 && (cost instanceof ColoredManaCost)) {
        for (        Mana netMana : manaAbility.getNetMana(game)) {
          if (cost.testPay(netMana)) {
            if (activateAbility(manaAbility,game)) {
              return true;
            }
          }
        }
      }
    }
  }
  for (  MageObject mageObject : producers) {
    for (    ActivatedManaAbilityImpl manaAbility : mageObject.getAbilities().getAvailableActivatedManaAbilities(Zone.BATTLEFIELD,game)) {
      if (cost instanceof ColoredManaCost) {
        for (        Mana netMana : manaAbility.getNetMana(game)) {
          if (cost.testPay(netMana) || spendAnyMana) {
            if (activateAbility(manaAbility,game)) {
              return true;
            }
          }
        }
      }
    }
    for (    ActivatedManaAbilityImpl manaAbility : mageObject.getAbilities().getAvailableActivatedManaAbilities(Zone.BATTLEFIELD,game)) {
      if (cost instanceof HybridManaCost) {
        for (        Mana netMana : manaAbility.getNetMana(game)) {
          if (cost.testPay(netMana) || spendAnyMana) {
            if (activateAbility(manaAbility,game)) {
              return true;
            }
          }
        }
      }
    }
    for (    ActivatedManaAbilityImpl manaAbility : mageObject.getAbilities().getAvailableActivatedManaAbilities(Zone.BATTLEFIELD,game)) {
      if (cost instanceof MonoHybridManaCost) {
        for (        Mana netMana : manaAbility.getNetMana(game)) {
          if (cost.testPay(netMana) || spendAnyMana) {
            if (activateAbility(manaAbility,game)) {
              return true;
            }
          }
        }
      }
    }
    for (    ActivatedManaAbilityImpl manaAbility : mageObject.getAbilities().getAvailableActivatedManaAbilities(Zone.BATTLEFIELD,game)) {
      if (cost instanceof ColorlessManaCost) {
        for (        Mana netMana : manaAbility.getNetMana(game)) {
          if (cost.testPay(netMana) || spendAnyMana) {
            if (activateAbility(manaAbility,game)) {
              return true;
            }
          }
        }
      }
    }
    for (    ActivatedManaAbilityImpl manaAbility : mageObject.getAbilities().getAvailableActivatedManaAbilities(Zone.BATTLEFIELD,game)) {
      if (cost instanceof GenericManaCost) {
        for (        Mana netMana : manaAbility.getNetMana(game)) {
          if (cost.testPay(netMana) || spendAnyMana) {
            if (activateAbility(manaAbility,game)) {
              return true;
            }
          }
        }
      }
    }
  }
  if (cost instanceof PhyrexianManaCost) {
    if (cost.pay(null,game,null,playerId,false,null) || spendAnyMana) {
      return true;
    }
  }
  return false;
}",0.9643532271131516
158261,"protected void findPlayables(Game game){
  playableInstant.clear();
  playableNonInstant.clear();
  unplayable.clear();
  playableAbilities.clear();
  Set<Card> nonLands=hand.getCards(new FilterNonlandCard(),game);
  ManaOptions available=getManaAvailable(game);
  available.addMana(manaPool.getMana());
  for (  Card card : nonLands) {
    ManaOptions options=card.getManaCost().getOptions();
    if (card.getManaCost().getVariableCosts().size() > 0) {
      for (      Mana option : options) {
        option.add(Mana.GenericMana(3));
      }
    }
    for (    Mana mana : options) {
      for (      Mana avail : available) {
        if (mana.enough(avail)) {
          SpellAbility ability=card.getSpellAbility();
          if (ability != null && ability.canActivate(playerId,game) && game.getContinuousEffects().preventedByRuleModification(GameEvent.getEvent(GameEvent.EventType.CAST_SPELL,ability.getSourceId(),ability.getSourceId(),playerId),ability,game,true)) {
            if (card.getCardType().contains(CardType.INSTANT) || card.hasAbility(FlashAbility.getInstance().getId(),game)) {
              playableInstant.add(card);
            }
 else {
              playableNonInstant.add(card);
            }
          }
        }
 else         if (!playableInstant.contains(card) && !playableNonInstant.contains(card)) {
          unplayable.put(mana.needed(avail),card);
        }
      }
    }
  }
  for (  Permanent permanent : game.getBattlefield().getAllActivePermanents(playerId)) {
    for (    ActivatedAbility ability : permanent.getAbilities().getActivatedAbilities(Zone.BATTLEFIELD)) {
      if (!(ability instanceof ManaAbility) && ability.canActivate(playerId,game)) {
        if (ability instanceof EquipAbility && permanent.getAttachedTo() != null) {
          continue;
        }
        ManaOptions abilityOptions=ability.getManaCosts().getOptions();
        if (ability.getManaCosts().getVariableCosts().size() > 0) {
          for (          Mana option : abilityOptions) {
            option.add(Mana.GenericMana(3));
          }
        }
        if (abilityOptions.isEmpty()) {
          playableAbilities.add(ability);
        }
 else {
          for (          Mana mana : abilityOptions) {
            for (            Mana avail : available) {
              if (mana.enough(avail)) {
                playableAbilities.add(ability);
              }
            }
          }
        }
      }
    }
  }
  for (  Card card : graveyard.getCards(game)) {
    for (    ActivatedAbility ability : card.getAbilities().getActivatedAbilities(Zone.GRAVEYARD)) {
      if (ability.canActivate(playerId,game)) {
        ManaOptions abilityOptions=ability.getManaCosts().getOptions();
        if (abilityOptions.isEmpty()) {
          playableAbilities.add(ability);
        }
 else {
          for (          Mana mana : abilityOptions) {
            for (            Mana avail : available) {
              if (mana.enough(avail)) {
                playableAbilities.add(ability);
              }
            }
          }
        }
      }
    }
  }
  if (log.isDebugEnabled()) {
    log.debug(""String_Node_Str"" + playableInstant.toString() + ""String_Node_Str""+ playableNonInstant.toString()+ ""String_Node_Str""+ playableAbilities.toString());
  }
}","protected void findPlayables(Game game){
  playableInstant.clear();
  playableNonInstant.clear();
  unplayable.clear();
  playableAbilities.clear();
  Set<Card> nonLands=hand.getCards(new FilterNonlandCard(),game);
  ManaOptions available=getManaAvailable(game);
  available.addMana(manaPool.getMana());
  for (  Card card : nonLands) {
    ManaOptions options=card.getManaCost().getOptions();
    if (card.getManaCost().getVariableCosts().size() > 0) {
      for (      Mana option : options) {
        option.add(Mana.GenericMana(3));
      }
    }
    for (    Mana mana : options) {
      for (      Mana avail : available) {
        if (mana.enough(avail)) {
          SpellAbility ability=card.getSpellAbility();
          if (ability != null && ability.canActivate(playerId,game) && game.getContinuousEffects().preventedByRuleModification(GameEvent.getEvent(GameEvent.EventType.CAST_SPELL,ability.getSourceId(),ability.getSourceId(),playerId),ability,game,true)) {
            if (card.getCardType().contains(CardType.INSTANT) || card.hasAbility(FlashAbility.getInstance().getId(),game)) {
              playableInstant.add(card);
            }
 else {
              playableNonInstant.add(card);
            }
          }
        }
 else         if (!playableInstant.contains(card) && !playableNonInstant.contains(card)) {
          unplayable.put(mana.needed(avail),card);
        }
      }
    }
  }
  for (  Permanent permanent : game.getBattlefield().getAllActivePermanents(playerId)) {
    for (    ActivatedAbility ability : permanent.getAbilities().getActivatedAbilities(Zone.BATTLEFIELD)) {
      if (!(ability instanceof ActivatedManaAbilityImpl) && ability.canActivate(playerId,game)) {
        if (ability instanceof EquipAbility && permanent.getAttachedTo() != null) {
          continue;
        }
        ManaOptions abilityOptions=ability.getManaCosts().getOptions();
        if (ability.getManaCosts().getVariableCosts().size() > 0) {
          for (          Mana option : abilityOptions) {
            option.add(Mana.GenericMana(3));
          }
        }
        if (abilityOptions.isEmpty()) {
          playableAbilities.add(ability);
        }
 else {
          for (          Mana mana : abilityOptions) {
            for (            Mana avail : available) {
              if (mana.enough(avail)) {
                playableAbilities.add(ability);
              }
            }
          }
        }
      }
    }
  }
  for (  Card card : graveyard.getCards(game)) {
    for (    ActivatedAbility ability : card.getAbilities().getActivatedAbilities(Zone.GRAVEYARD)) {
      if (ability.canActivate(playerId,game)) {
        ManaOptions abilityOptions=ability.getManaCosts().getOptions();
        if (abilityOptions.isEmpty()) {
          playableAbilities.add(ability);
        }
 else {
          for (          Mana mana : abilityOptions) {
            for (            Mana avail : available) {
              if (mana.enough(avail)) {
                playableAbilities.add(ability);
              }
            }
          }
        }
      }
    }
  }
  if (log.isDebugEnabled()) {
    log.debug(""String_Node_Str"" + playableInstant.toString() + ""String_Node_Str""+ playableNonInstant.toString()+ ""String_Node_Str""+ playableAbilities.toString());
  }
}",0.9980185947264136
158262,"public int evaluate(Permanent permanent,Game game){
  if (!values.containsKey(permanent.getId())) {
    int value=0;
    if (permanent.getCardType().contains(CardType.CREATURE)) {
      value+=combat.evaluate(permanent,game);
    }
    value+=permanent.getAbilities().getManaAbilities(Zone.BATTLEFIELD).size();
    value+=permanent.getAbilities().getActivatedAbilities(Zone.BATTLEFIELD).size();
    values.put(permanent.getId(),value);
  }
  return values.get(permanent.getId());
}","public int evaluate(Permanent permanent,Game game){
  if (!values.containsKey(permanent.getId())) {
    int value=0;
    if (permanent.getCardType().contains(CardType.CREATURE)) {
      value+=combat.evaluate(permanent,game);
    }
    value+=permanent.getAbilities().getActivatedManaAbilities(Zone.BATTLEFIELD).size();
    value+=permanent.getAbilities().getActivatedAbilities(Zone.BATTLEFIELD).size();
    values.put(permanent.getId(),value);
  }
  return values.get(permanent.getId());
}",0.9907312049433572
158263,"public static int evaluatePermanent(Permanent permanent,Game game,boolean ignoreTapped){
  int value=0;
  if (ignoreTapped)   value=5;
 else   value=permanent.isTapped() ? 4 : 5;
  if (permanent.getCardType().contains(CardType.CREATURE)) {
    value+=evaluateCreature(permanent,game) * CREATURE_FACTOR;
  }
  value+=permanent.getAbilities().getManaAbilities(Zone.BATTLEFIELD).size();
  for (  ActivatedAbility ability : permanent.getAbilities().getActivatedAbilities(Zone.BATTLEFIELD)) {
    if (!(ability instanceof ManaAbility) && ability.canActivate(ability.getControllerId(),game))     value+=ability.getEffects().size();
  }
  for (  Counter counter : permanent.getCounters(game).values()) {
    if (!(counter instanceof BoostCounter)) {
      value+=counter.getCount();
    }
  }
  value+=permanent.getAbilities().getStaticAbilities(Zone.BATTLEFIELD).size();
  value+=permanent.getAbilities().getTriggeredAbilities(Zone.BATTLEFIELD).size();
  value+=permanent.getManaCost().convertedManaCost();
  return value;
}","public static int evaluatePermanent(Permanent permanent,Game game,boolean ignoreTapped){
  int value=0;
  if (ignoreTapped)   value=5;
 else   value=permanent.isTapped() ? 4 : 5;
  if (permanent.getCardType().contains(CardType.CREATURE)) {
    value+=evaluateCreature(permanent,game) * CREATURE_FACTOR;
  }
  value+=permanent.getAbilities().getActivatedManaAbilities(Zone.BATTLEFIELD).size();
  for (  ActivatedAbility ability : permanent.getAbilities().getActivatedAbilities(Zone.BATTLEFIELD)) {
    if (!(ability instanceof ActivatedManaAbilityImpl) && ability.canActivate(ability.getControllerId(),game))     value+=ability.getEffects().size();
  }
  for (  Counter counter : permanent.getCounters(game).values()) {
    if (!(counter instanceof BoostCounter)) {
      value+=counter.getCount();
    }
  }
  value+=permanent.getAbilities().getStaticAbilities(Zone.BATTLEFIELD).size();
  value+=permanent.getAbilities().getTriggeredAbilities(Zone.BATTLEFIELD).size();
  value+=permanent.getManaCost().convertedManaCost();
  return value;
}",0.989310009718173
158264,"protected void playManaAbilities(ManaCost unpaid,Game game){
  updateGameStatePriority(""String_Node_Str"",game);
  MageObject object=game.getObject(response.getUUID());
  if (object == null) {
    return;
  }
  Zone zone=game.getState().getZone(object.getId());
  if (zone != null) {
    LinkedHashMap<UUID,ManaAbility> useableAbilities=getUseableManaAbilities(object,zone,game);
    if (useableAbilities != null && useableAbilities.size() > 0) {
      useableAbilities=ManaUtil.tryToAutoPay(unpaid,useableAbilities);
      currentlyUnpaidMana=unpaid;
      activateAbility(useableAbilities,object,game);
      currentlyUnpaidMana=null;
    }
  }
}","protected void playManaAbilities(ManaCost unpaid,Game game){
  updateGameStatePriority(""String_Node_Str"",game);
  MageObject object=game.getObject(response.getUUID());
  if (object == null) {
    return;
  }
  Zone zone=game.getState().getZone(object.getId());
  if (zone != null) {
    LinkedHashMap<UUID,ActivatedManaAbilityImpl> useableAbilities=getUseableManaAbilities(object,zone,game);
    if (useableAbilities != null && useableAbilities.size() > 0) {
      useableAbilities=ManaUtil.tryToAutoPay(unpaid,useableAbilities);
      currentlyUnpaidMana=unpaid;
      activateAbility(useableAbilities,object,game);
      currentlyUnpaidMana=null;
    }
  }
}",0.973221117061974
158265,"private boolean suppressAbilityPicker(ActivatedAbility ability){
  if (this.getUserData().isShowAbilityPickerForced()) {
    if (ability instanceof PlayLandAbility) {
      return true;
    }
    if (!ability.getSourceId().equals(getCastSourceIdWithAlternateMana()) && ability.getManaCostsToPay().convertedManaCost() > 0) {
      return true;
    }
    return ability instanceof ManaAbility;
  }
  return true;
}","private boolean suppressAbilityPicker(ActivatedAbility ability){
  if (this.getUserData().isShowAbilityPickerForced()) {
    if (ability instanceof PlayLandAbility) {
      return true;
    }
    if (!ability.getSourceId().equals(getCastSourceIdWithAlternateMana()) && ability.getManaCostsToPay().convertedManaCost() > 0) {
      return true;
    }
    return ability instanceof ActivatedManaAbilityImpl;
  }
  return true;
}",0.984468339307049
158266,"protected void activateAbility(LinkedHashMap<UUID,? extends ActivatedAbility> abilities,MageObject object,Game game){
  updateGameStatePriority(""String_Node_Str"",game);
  if (abilities.size() == 1 && suppressAbilityPicker(abilities.values().iterator().next())) {
    ActivatedAbility ability=abilities.values().iterator().next();
    if (!ability.getTargets().isEmpty() || !(ability.getCosts().size() == 1 && ability.getCosts().get(0) instanceof SacrificeSourceCost) || !(ability.getCosts().size() == 2 && ability.getCosts().get(0) instanceof TapSourceCost && ability.getCosts().get(0) instanceof SacrificeSourceCost)) {
      activateAbility(ability,game);
      return;
    }
  }
  if (userData.isUseFirstManaAbility() && object instanceof Permanent && object.getCardType().contains(CardType.LAND)) {
    ActivatedAbility ability=abilities.values().iterator().next();
    if (ability instanceof ManaAbility) {
      activateAbility(ability,game);
      return;
    }
  }
  game.fireGetChoiceEvent(playerId,name,object,new ArrayList<>(abilities.values()));
  waitForResponse(game);
  if (response.getUUID() != null && isInGame()) {
    if (abilities.containsKey(response.getUUID())) {
      activateAbility(abilities.get(response.getUUID()),game);
    }
  }
}","protected void activateAbility(LinkedHashMap<UUID,? extends ActivatedAbility> abilities,MageObject object,Game game){
  updateGameStatePriority(""String_Node_Str"",game);
  if (abilities.size() == 1 && suppressAbilityPicker(abilities.values().iterator().next())) {
    ActivatedAbility ability=abilities.values().iterator().next();
    if (!ability.getTargets().isEmpty() || !(ability.getCosts().size() == 1 && ability.getCosts().get(0) instanceof SacrificeSourceCost) || !(ability.getCosts().size() == 2 && ability.getCosts().get(0) instanceof TapSourceCost && ability.getCosts().get(0) instanceof SacrificeSourceCost)) {
      activateAbility(ability,game);
      return;
    }
  }
  if (userData.isUseFirstManaAbility() && object instanceof Permanent && object.getCardType().contains(CardType.LAND)) {
    ActivatedAbility ability=abilities.values().iterator().next();
    if (ability instanceof ActivatedManaAbilityImpl) {
      activateAbility(ability,game);
      return;
    }
  }
  game.fireGetChoiceEvent(playerId,name,object,new ArrayList<>(abilities.values()));
  waitForResponse(game);
  if (response.getUUID() != null && isInGame()) {
    if (abilities.containsKey(response.getUUID())) {
      activateAbility(abilities.get(response.getUUID()),game);
    }
  }
}",0.9948677457560204
158267,"@Override public boolean applies(GameEvent event,Ability source,Game game){
  if (event.getPlayerId().equals(source.getFirstTarget())) {
    MageObject object=game.getObject(event.getSourceId());
    if (event.getType() == GameEvent.EventType.CAST_SPELL) {
      if (object.getCardType().contains(CardType.INSTANT) || object.getCardType().contains(CardType.SORCERY)) {
        return true;
      }
    }
    if (event.getType() == GameEvent.EventType.ACTIVATE_ABILITY) {
      Ability ability=game.getAbility(event.getTargetId(),event.getSourceId());
      if (ability != null && !(ability instanceof ManaAbility)) {
        return true;
      }
    }
  }
  return false;
}","@Override public boolean applies(GameEvent event,Ability source,Game game){
  if (event.getPlayerId().equals(source.getFirstTarget())) {
    MageObject object=game.getObject(event.getSourceId());
    if (event.getType() == GameEvent.EventType.CAST_SPELL) {
      if (object.getCardType().contains(CardType.INSTANT) || object.getCardType().contains(CardType.SORCERY)) {
        return true;
      }
    }
    if (event.getType() == GameEvent.EventType.ACTIVATE_ABILITY) {
      Ability ability=game.getAbility(event.getTargetId(),event.getSourceId());
      if (ability != null && !(ability instanceof ActivatedManaAbilityImpl)) {
        return true;
      }
    }
  }
  return false;
}",0.9904341427520236
158268,"@Override public boolean applies(GameEvent event,Ability source,Game game){
  Player controller=game.getPlayer(source.getControllerId());
  Player targetingPlayer=game.getPlayer(event.getPlayerId());
  if (controller != null && targetingPlayer.isHuman() && controller.hasOpponent(event.getPlayerId(),game)) {
    StackObject stackObject=game.getStack().getStackObject(event.getSourceId());
    if (stackObject.isCopy()) {
      return false;
    }
    Ability ability=(Ability)getValue(""String_Node_Str"");
    if (ability != null) {
      List<Permanent> allowedPermanents=game.getBattlefield().getActivePermanents(filter,event.getPlayerId(),event.getSourceId(),game);
      if (!allowedPermanents.isEmpty()) {
        boolean canTargetAllowedPermanent=false;
        for (        UUID modeId : ability.getModes().getSelectedModes()) {
          ability.getModes().setActiveMode(modeId);
          for (          Target target : ability.getTargets()) {
            for (            Permanent allowedPermanent : allowedPermanents) {
              if (target.getTargets().contains(allowedPermanent.getId())) {
                return false;
              }
              if (target.canTarget(allowedPermanent.getId(),source,game)) {
                canTargetAllowedPermanent=true;
              }
            }
          }
        }
        return canTargetAllowedPermanent;
      }
    }
  }
  return false;
}","@Override public boolean applies(GameEvent event,Ability source,Game game){
  Player controller=game.getPlayer(source.getControllerId());
  Player targetingPlayer=game.getPlayer(event.getPlayerId());
  if (controller != null && targetingPlayer.isHuman() && controller.hasOpponent(event.getPlayerId(),game)) {
    StackObject stackObject=game.getStack().getStackObject(event.getSourceId());
    if (stackObject.isCopy()) {
      return false;
    }
    Ability ability=(Ability)getValue(""String_Node_Str"");
    if (ability != null) {
      List<Permanent> allowedPermanents=game.getBattlefield().getActivePermanents(filter,event.getPlayerId(),event.getSourceId(),game);
      if (!allowedPermanents.isEmpty()) {
        boolean canTargetAllowedPermanent=false;
        for (        UUID modeId : ability.getModes().getSelectedModes()) {
          ability.getModes().setActiveMode(modeId);
          for (          Target target : ability.getTargets()) {
            for (            Permanent allowedPermanent : allowedPermanents) {
              if (target.getTargets().contains(allowedPermanent.getId())) {
                return false;
              }
              if (target.canTarget(stackObject.getControllerId(),allowedPermanent.getId(),source,game)) {
                canTargetAllowedPermanent=true;
              }
            }
          }
        }
        return canTargetAllowedPermanent;
      }
    }
  }
  return false;
}",0.989451476793249
158269,"@Override public String getText(Mode mode){
  StringBuilder sb=new StringBuilder();
  if (!""String_Node_Str"".equals(duration.toString())) {
    sb.append(duration.toString()).append(""String_Node_Str"");
  }
  sb.append(filter.getMessage());
  sb.append(""String_Node_Str"").append(token.getDescription());
  if (type != null && type.length() > 0) {
    sb.append(""String_Node_Str"").append(type);
  }
  return sb.toString();
}","@Override public String getText(Mode mode){
  StringBuilder sb=new StringBuilder();
  if (!""String_Node_Str"".equals(duration.toString())) {
    sb.append(duration.toString()).append(""String_Node_Str"");
  }
  sb.append(""String_Node_Str"");
  sb.append(filter.getMessage());
  if (""String_Node_Str"".equals(duration.toString())) {
    sb.append(""String_Node_Str"");
  }
 else {
    sb.append(""String_Node_Str"");
  }
  sb.append(token.getDescription());
  if (type != null && type.length() > 0) {
    sb.append(""String_Node_Str"").append(type);
  }
  return sb.toString();
}",0.7967644084934277
158270,"protected List<MageObject> getAvailableManaProducers(Game game){
  List<MageObject> result=new ArrayList<>();
  for (  Permanent permanent : game.getBattlefield().getAllActivePermanents(playerId)) {
    boolean canAdd=false;
    for (    ManaAbility ability : permanent.getAbilities().getManaAbilities(Zone.BATTLEFIELD)) {
      if (!ability.getManaCosts().isEmpty()) {
        canAdd=false;
        break;
      }
      if (ability.canActivate(playerId,game)) {
        canAdd=true;
      }
    }
    if (canAdd) {
      result.add(permanent);
    }
  }
  for (  Card card : getHand().getCards(game)) {
    boolean canAdd=false;
    for (    ManaAbility ability : card.getAbilities(game).getManaAbilities(Zone.HAND)) {
      if (!ability.getManaCosts().isEmpty()) {
        canAdd=false;
        break;
      }
      if (ability.canActivate(playerId,game)) {
        canAdd=true;
      }
    }
    if (canAdd) {
      result.add(card);
    }
  }
  return result;
}","protected List<MageObject> getAvailableManaProducers(Game game){
  List<MageObject> result=new ArrayList<>();
  for (  Permanent permanent : game.getBattlefield().getAllActivePermanents(playerId)) {
    Boolean canUse=null;
    boolean canAdd=false;
    for (    ManaAbility ability : permanent.getAbilities().getManaAbilities(Zone.BATTLEFIELD)) {
      if (!ability.getManaCosts().isEmpty()) {
        canAdd=false;
        break;
      }
      if (canUse == null) {
        canUse=permanent.canUseActivatedAbilities(game);
      }
      if (canUse && ability.canActivate(playerId,game)) {
        canAdd=true;
      }
    }
    if (canAdd) {
      result.add(permanent);
    }
  }
  for (  Card card : getHand().getCards(game)) {
    boolean canAdd=false;
    for (    ManaAbility ability : card.getAbilities(game).getManaAbilities(Zone.HAND)) {
      if (!ability.getManaCosts().isEmpty()) {
        canAdd=false;
        break;
      }
      if (ability.canActivate(playerId,game)) {
        canAdd=true;
      }
    }
    if (canAdd) {
      result.add(card);
    }
  }
  return result;
}",0.9378036929057336
158271,"public List<Permanent> getAvailableManaProducersWithCost(Game game){
  List<Permanent> result=new ArrayList<>();
  for (  Permanent permanent : game.getBattlefield().getAllActivePermanents(playerId)) {
    for (    ManaAbility ability : permanent.getAbilities().getManaAbilities(Zone.BATTLEFIELD)) {
      if (ability.canActivate(playerId,game) && !ability.getManaCosts().isEmpty()) {
        result.add(permanent);
        break;
      }
    }
  }
  return result;
}","public List<Permanent> getAvailableManaProducersWithCost(Game game){
  List<Permanent> result=new ArrayList<>();
  for (  Permanent permanent : game.getBattlefield().getAllActivePermanents(playerId)) {
    Boolean canUse=null;
    for (    ManaAbility ability : permanent.getAbilities().getManaAbilities(Zone.BATTLEFIELD)) {
      if (canUse == null) {
        canUse=permanent.canUseActivatedAbilities(game);
      }
      if (canUse && ability.canActivate(playerId,game) && !ability.getManaCosts().isEmpty()) {
        result.add(permanent);
        break;
      }
    }
  }
  return result;
}",0.8305084745762712
158272,"@Override public boolean putCardsOnBottomOfLibrary(Cards cardsToLibrary,Game game,Ability source,boolean anyOrder){
  if (!cardsToLibrary.isEmpty()) {
    Cards cards=new CardsImpl(cardsToLibrary);
    if (!anyOrder) {
      for (      UUID objectId : cards) {
        moveObjectToLibrary(objectId,source == null ? null : source.getSourceId(),game,false,false);
      }
    }
 else {
      TargetCard target=new TargetCard(Zone.ALL,new FilterCard(""String_Node_Str""));
      target.setRequired(true);
      while (isInGame() && cards.size() > 1) {
        this.choose(Outcome.Neutral,cards,target,game);
        UUID targetObjectId=target.getFirstTarget();
        cards.remove(targetObjectId);
        moveObjectToLibrary(targetObjectId,source == null ? null : source.getSourceId(),game,false,false);
        target.clearChosen();
      }
      if (cards.size() == 1) {
        moveObjectToLibrary(cards.iterator().next(),source == null ? null : source.getSourceId(),game,false,false);
      }
    }
  }
  return true;
}","@Override public boolean putCardsOnBottomOfLibrary(Cards cardsToLibrary,Game game,Ability source,boolean anyOrder){
  if (!cardsToLibrary.isEmpty()) {
    Cards cards=new CardsImpl(cardsToLibrary);
    if (!anyOrder) {
      for (      UUID objectId : cards) {
        moveObjectToLibrary(objectId,source == null ? null : source.getSourceId(),game,false,false);
      }
    }
 else {
      TargetCard target=new TargetCard(Zone.ALL,new FilterCard(""String_Node_Str""));
      target.setRequired(true);
      while (cards.size() > 1) {
        this.choose(Outcome.Neutral,cards,target,game);
        if (!canRespond()) {
          return false;
        }
        UUID targetObjectId=target.getFirstTarget();
        cards.remove(targetObjectId);
        moveObjectToLibrary(targetObjectId,source == null ? null : source.getSourceId(),game,false,false);
        target.clearChosen();
      }
      if (cards.size() == 1) {
        moveObjectToLibrary(cards.iterator().next(),source == null ? null : source.getSourceId(),game,false,false);
      }
    }
  }
  return true;
}",0.9631402584968884
158273,"@Override public ManaOptions getManaAvailable(Game game){
  ManaOptions available=new ManaOptions();
  List<Abilities<ManaAbility>> sourceWithoutManaCosts=new ArrayList<>();
  List<Abilities<ManaAbility>> sourceWithCosts=new ArrayList<>();
  for (  Permanent permanent : game.getBattlefield().getAllActivePermanents(playerId)) {
    boolean canAdd=false;
    boolean withCost=false;
    Abilities<ManaAbility> manaAbilities=permanent.getAbilities().getAvailableManaAbilities(Zone.BATTLEFIELD,game);
    for (    ManaAbility ability : manaAbilities) {
      if (ability.canActivate(playerId,game)) {
        canAdd=true;
        if (!ability.getManaCosts().isEmpty()) {
          withCost=true;
          break;
        }
      }
    }
    if (canAdd) {
      if (withCost) {
        sourceWithCosts.add(manaAbilities);
      }
 else {
        sourceWithoutManaCosts.add(manaAbilities);
      }
    }
  }
  for (  Abilities<ManaAbility> manaAbilities : sourceWithoutManaCosts) {
    available.addMana(manaAbilities,game);
  }
  for (  Abilities<ManaAbility> manaAbilities : sourceWithCosts) {
    available.addManaWithCost(manaAbilities,game);
  }
  return available;
}","@Override public ManaOptions getManaAvailable(Game game){
  ManaOptions available=new ManaOptions();
  List<Abilities<ManaAbility>> sourceWithoutManaCosts=new ArrayList<>();
  List<Abilities<ManaAbility>> sourceWithCosts=new ArrayList<>();
  for (  Permanent permanent : game.getBattlefield().getAllActivePermanents(playerId)) {
    Boolean canUse=null;
    boolean canAdd=false;
    boolean withCost=false;
    Abilities<ManaAbility> manaAbilities=permanent.getAbilities().getAvailableManaAbilities(Zone.BATTLEFIELD,game);
    for (    ManaAbility ability : manaAbilities) {
      if (canUse == null) {
        canUse=permanent.canUseActivatedAbilities(game);
      }
      if (canUse && ability.canActivate(playerId,game)) {
        canAdd=true;
        if (!ability.getManaCosts().isEmpty()) {
          withCost=true;
          break;
        }
      }
    }
    if (canAdd) {
      if (withCost) {
        sourceWithCosts.add(manaAbilities);
      }
 else {
        sourceWithoutManaCosts.add(manaAbilities);
      }
    }
  }
  for (  Abilities<ManaAbility> manaAbilities : sourceWithoutManaCosts) {
    available.addMana(manaAbilities,game);
  }
  for (  Abilities<ManaAbility> manaAbilities : sourceWithCosts) {
    available.addManaWithCost(manaAbilities,game);
  }
  return available;
}",0.948051948051948
158274,"@Override public boolean apply(Game game,Ability source){
  Player player=game.getPlayer(source.getControllerId());
  if (player != null) {
    while (player.chooseUse(Outcome.Benefit,choiceText,source,game)) {
      Cards cards=player.getSideboard();
      if (cards.isEmpty()) {
        game.informPlayer(player,""String_Node_Str"");
        break;
      }
      Set<Card> filtered=cards.getCards(filter,game);
      if (filtered.isEmpty()) {
        game.informPlayer(player,""String_Node_Str"" + filter.getMessage() + ""String_Node_Str"");
        break;
      }
      Cards filteredCards=new CardsImpl();
      for (      Card card : filtered) {
        filteredCards.add(card.getId());
      }
      TargetCard target=new TargetCard(Zone.OUTSIDE,filter);
      if (player.choose(Outcome.Benefit,filteredCards,target,game)) {
        Card card=player.getSideboard().get(target.getFirstTarget(),game);
        if (card != null) {
          card.moveToZone(Zone.HAND,source.getSourceId(),game,false);
          Cards revealCard=new CardsImpl();
          revealCard.add(card);
          player.revealCards(""String_Node_Str"",revealCard,game);
          break;
        }
      }
    }
    Card cardToExile=game.getCard(source.getSourceId());
    if (cardToExile != null) {
      cardToExile.moveToExile(null,""String_Node_Str"",source.getSourceId(),game);
    }
  }
  return true;
}","@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  MageObject sourceObject=source.getSourceObject(game);
  if (controller != null && sourceObject != null) {
    while (controller.chooseUse(Outcome.Benefit,choiceText,source,game)) {
      Cards cards=controller.getSideboard();
      if (cards.isEmpty()) {
        game.informPlayer(controller,""String_Node_Str"");
        break;
      }
      Set<Card> filtered=cards.getCards(filter,game);
      if (filtered.isEmpty()) {
        game.informPlayer(controller,""String_Node_Str"" + filter.getMessage() + ""String_Node_Str"");
        break;
      }
      Cards filteredCards=new CardsImpl();
      for (      Card card : filtered) {
        filteredCards.add(card.getId());
      }
      TargetCard target=new TargetCard(Zone.OUTSIDE,filter);
      if (controller.choose(Outcome.Benefit,filteredCards,target,game)) {
        Card card=controller.getSideboard().get(target.getFirstTarget(),game);
        if (card != null) {
          card.moveToZone(Zone.HAND,source.getSourceId(),game,false);
          Cards revealCard=new CardsImpl();
          revealCard.add(card);
          controller.revealCards(sourceObject.getIdName(),revealCard,game);
          break;
        }
      }
    }
    return true;
  }
  return false;
}",0.7098674521354934
158275,"@Override public boolean apply(Game game,Ability source){
  Player player=game.getPlayer(source.getControllerId());
  if (player != null) {
    while (player.chooseUse(Outcome.Benefit,choiceText,source,game)) {
      Cards cards=player.getSideboard();
      if (cards.isEmpty()) {
        game.informPlayer(player,""String_Node_Str"");
        break;
      }
      Set<Card> filtered=cards.getCards(filter,game);
      if (filtered.isEmpty()) {
        game.informPlayer(player,""String_Node_Str"" + filter.getMessage() + ""String_Node_Str"");
        break;
      }
      Cards filteredCards=new CardsImpl();
      for (      Card card : filtered) {
        filteredCards.add(card.getId());
      }
      TargetCard target=new TargetCard(Zone.OUTSIDE,filter);
      if (player.choose(Outcome.Benefit,filteredCards,target,game)) {
        Card card=player.getSideboard().get(target.getFirstTarget(),game);
        if (card != null) {
          card.moveToZone(Zone.HAND,source.getSourceId(),game,false);
          Cards revealCard=new CardsImpl();
          revealCard.add(card);
          player.revealCards(""String_Node_Str"",revealCard,game);
          break;
        }
      }
    }
    Card cardToExile=game.getCard(source.getSourceId());
    if (cardToExile != null) {
      cardToExile.moveToExile(null,""String_Node_Str"",source.getSourceId(),game);
    }
  }
  return true;
}","@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  MageObject sourceObject=source.getSourceObject(game);
  if (controller != null && sourceObject != null) {
    while (controller.chooseUse(Outcome.Benefit,choiceText,source,game)) {
      Cards cards=controller.getSideboard();
      if (cards.isEmpty()) {
        game.informPlayer(controller,""String_Node_Str"");
        break;
      }
      Set<Card> filtered=cards.getCards(filter,game);
      if (filtered.isEmpty()) {
        game.informPlayer(controller,""String_Node_Str"" + filter.getMessage() + ""String_Node_Str"");
        break;
      }
      Cards filteredCards=new CardsImpl();
      for (      Card card : filtered) {
        filteredCards.add(card.getId());
      }
      TargetCard target=new TargetCard(Zone.OUTSIDE,filter);
      if (controller.choose(Outcome.Benefit,filteredCards,target,game)) {
        Card card=controller.getSideboard().get(target.getFirstTarget(),game);
        if (card != null) {
          card.moveToZone(Zone.HAND,source.getSourceId(),game,false);
          Cards revealCard=new CardsImpl();
          revealCard.add(card);
          controller.revealCards(sourceObject.getIdName(),revealCard,game);
          break;
        }
      }
    }
    return true;
  }
  return false;
}",0.7098674521354934
158276,"@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller != null) {
    while (controller.chooseUse(Outcome.Benefit,choiceText,source,game)) {
      Cards cards=controller.getSideboard();
      if (cards.isEmpty()) {
        game.informPlayer(controller,""String_Node_Str"");
        break;
      }
      Set<Card> filtered=cards.getCards(filter,game);
      if (filtered.isEmpty()) {
        game.informPlayer(controller,""String_Node_Str"" + filter.getMessage() + ""String_Node_Str"");
        break;
      }
      Cards filteredCards=new CardsImpl();
      for (      Card card : filtered) {
        filteredCards.add(card.getId());
      }
      TargetCard target=new TargetCard(Zone.OUTSIDE,filter);
      if (controller.choose(Outcome.Benefit,filteredCards,target,game)) {
        Card card=controller.getSideboard().get(target.getFirstTarget(),game);
        if (card != null) {
          card.moveToZone(Zone.HAND,source.getSourceId(),game,false);
          Cards revealCard=new CardsImpl();
          revealCard.add(card);
          controller.revealCards(""String_Node_Str"",revealCard,game);
          break;
        }
      }
    }
  }
  return true;
}","@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  MageObject sourceObject=source.getSourceObject(game);
  if (controller != null && sourceObject != null) {
    while (controller.chooseUse(Outcome.Benefit,choiceText,source,game)) {
      Cards cards=controller.getSideboard();
      if (cards.isEmpty()) {
        game.informPlayer(controller,""String_Node_Str"");
        break;
      }
      Set<Card> filtered=cards.getCards(filter,game);
      if (filtered.isEmpty()) {
        game.informPlayer(controller,""String_Node_Str"" + filter.getMessage() + ""String_Node_Str"");
        break;
      }
      Cards filteredCards=new CardsImpl();
      for (      Card card : filtered) {
        filteredCards.add(card.getId());
      }
      TargetCard target=new TargetCard(Zone.OUTSIDE,filter);
      if (controller.choose(Outcome.Benefit,filteredCards,target,game)) {
        Card card=controller.getSideboard().get(target.getFirstTarget(),game);
        if (card != null) {
          card.moveToZone(Zone.HAND,source.getSourceId(),game,false);
          Cards revealCard=new CardsImpl();
          revealCard.add(card);
          controller.revealCards(sourceObject.getIdName(),revealCard,game);
          break;
        }
      }
    }
  }
  return true;
}",0.9425556858147714
158277,"@Override public boolean apply(Game game,Ability source){
  Player player=game.getPlayer(source.getControllerId());
  if (player != null) {
    while (player.chooseUse(Outcome.Benefit,choiceText,source,game)) {
      Cards cards=player.getSideboard();
      if (cards.isEmpty()) {
        game.informPlayer(player,""String_Node_Str"");
        break;
      }
      Set<Card> filtered=cards.getCards(filter,game);
      if (filtered.isEmpty()) {
        game.informPlayer(player,""String_Node_Str"" + filter.getMessage() + ""String_Node_Str"");
        break;
      }
      Cards filteredCards=new CardsImpl();
      for (      Card card : filtered) {
        filteredCards.add(card.getId());
      }
      TargetCard target=new TargetCard(Zone.OUTSIDE,filter);
      if (player.choose(Outcome.Benefit,filteredCards,target,game)) {
        Card card=player.getSideboard().get(target.getFirstTarget(),game);
        if (card != null) {
          card.moveToZone(Zone.HAND,source.getSourceId(),game,false);
          Cards revealCard=new CardsImpl();
          revealCard.add(card);
          player.revealCards(""String_Node_Str"",revealCard,game);
          break;
        }
      }
    }
    Card cardToExile=game.getCard(source.getSourceId());
    if (cardToExile != null) {
      cardToExile.moveToExile(null,""String_Node_Str"",source.getSourceId(),game);
    }
  }
  return true;
}","@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  MageObject sourceObject=source.getSourceObject(game);
  if (controller != null && sourceObject != null) {
    while (controller.chooseUse(Outcome.Benefit,choiceText,source,game)) {
      Cards cards=controller.getSideboard();
      if (cards.isEmpty()) {
        game.informPlayer(controller,""String_Node_Str"");
        break;
      }
      Set<Card> filtered=cards.getCards(filter,game);
      if (filtered.isEmpty()) {
        game.informPlayer(controller,""String_Node_Str"" + filter.getMessage() + ""String_Node_Str"");
        break;
      }
      Cards filteredCards=new CardsImpl();
      filteredCards.addAll(filtered);
      TargetCard target=new TargetCard(Zone.OUTSIDE,filter);
      if (controller.choose(Outcome.Benefit,filteredCards,target,game)) {
        Card card=controller.getSideboard().get(target.getFirstTarget(),game);
        if (card != null) {
          card.moveToZone(Zone.HAND,source.getSourceId(),game,false);
          controller.revealCards(sourceObject.getIdName(),new CardsImpl(card),game);
          break;
        }
      }
    }
    return true;
  }
  return false;
}",0.6184058529072006
158278,"@Override public boolean apply(Game game,Ability source){
  Permanent permanent=game.getPermanent(source.getSourceId());
  Permanent targetCreature=game.getPermanentOrLKIBattlefield(getTargetPointer().getFirst(game,source));
  if (targetCreature != null && permanent != null) {
    game.copyPermanent(Duration.EndOfTurn,targetCreature,permanent.getId(),source,new EmptyApplyToPermanent());
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Permanent permanent=game.getPermanent(source.getSourceId());
  Permanent targetCreature=game.getPermanentOrLKIBattlefield(getTargetPointer().getFirst(game,source));
  if (targetCreature != null && permanent != null) {
    Permanent blueprintPermanent=game.copyPermanent(Duration.Custom,targetCreature,permanent.getId(),source,new EmptyApplyToPermanent());
    blueprintPermanent.addAbility(new EntersBattlefieldAllTriggeredAbility(Zone.BATTLEFIELD,new UnstableShapeshifterEffect(),filterAnotherCreature,false,SetTargetPointer.PERMANENT,""String_Node_Str""),game);
    return true;
  }
  return false;
}",0.75
158279,"@Override public Permanent copyPermanent(Duration duration,Permanent copyFromPermanent,UUID copyToPermanentId,Ability source,ApplyToPermanent applier){
  Permanent newBluePrint=null;
  for (  Effect effect : getState().getContinuousEffects().getLayeredEffects(this)) {
    if (effect instanceof CopyEffect) {
      CopyEffect copyEffect=(CopyEffect)effect;
      if (copyEffect.getSourceId().equals(copyFromPermanent.getId())) {
        MageObject oldBluePrint=((CopyEffect)effect).getTarget();
        if (oldBluePrint instanceof Permanent) {
          newBluePrint=((Permanent)oldBluePrint).copy();
        }
      }
    }
  }
  if (newBluePrint == null) {
    newBluePrint=copyFromPermanent.copy();
    newBluePrint.reset(this);
    if (copyFromPermanent.isMorphed() || copyFromPermanent.isManifested()) {
      MorphAbility.setPermanentToFaceDownCreature(newBluePrint);
    }
    newBluePrint.assignNewId();
    if (copyFromPermanent.isTransformed()) {
      TransformAbility.transform(newBluePrint,copyFromPermanent.getSecondCardFace(),this);
    }
  }
  if (applier != null) {
    applier.apply(this,newBluePrint);
  }
  CopyEffect newEffect=new CopyEffect(duration,newBluePrint,copyToPermanentId);
  newEffect.newId();
  newEffect.setApplier(applier);
  Ability newAbility=source.copy();
  newEffect.init(newAbility,this);
  state.addEffect(newEffect,newAbility);
  return newBluePrint;
}","@Override public Permanent copyPermanent(Duration duration,Permanent copyFromPermanent,UUID copyToPermanentId,Ability source,ApplyToPermanent applier){
  Permanent newBluePrint=null;
  for (  Effect effect : getState().getContinuousEffects().getLayeredEffects(this)) {
    if (effect instanceof CopyEffect) {
      CopyEffect copyEffect=(CopyEffect)effect;
      if (copyEffect.getSourceId().equals(copyFromPermanent.getId())) {
        MageObject oldBluePrint=((CopyEffect)effect).getTarget();
        if (oldBluePrint instanceof Permanent) {
          newBluePrint=((Permanent)oldBluePrint).copy();
        }
      }
    }
  }
  if (newBluePrint == null) {
    newBluePrint=copyFromPermanent.copy();
    newBluePrint.reset(this);
    if (copyFromPermanent.isMorphed() || copyFromPermanent.isManifested()) {
      MorphAbility.setPermanentToFaceDownCreature(newBluePrint);
    }
    newBluePrint.assignNewId();
    if (copyFromPermanent.isTransformed()) {
      TransformAbility.transform(newBluePrint,copyFromPermanent.getSecondCardFace(),this);
    }
  }
  if (applier != null) {
    applier.apply(this,newBluePrint);
  }
  CopyEffect newEffect=new CopyEffect(duration,newBluePrint,copyToPermanentId);
  newEffect.newId();
  newEffect.setApplier(applier);
  Ability newAbility=source.copy();
  newEffect.init(newAbility,this);
  if (Duration.Custom.equals(duration)) {
    for (    Effect effect : getState().getContinuousEffects().getLayeredEffects(this)) {
      if (effect instanceof CopyEffect) {
        CopyEffect copyEffect=(CopyEffect)effect;
        if (copyEffect.getSourceId().equals(copyToPermanentId) && copyEffect.getDuration().equals(Duration.Custom)) {
          copyEffect.discard();
        }
      }
    }
  }
  state.addEffect(newEffect,newAbility);
  return newBluePrint;
}",0.8740601503759399
158280,"@Override public boolean apply(Game game,Ability source){
  Permanent permanent=game.getPermanent(source.getSourceId());
  Permanent targetCreature=game.getPermanent(getTargetPointer().getFirst(game,source));
  if (targetCreature == null) {
    targetCreature=(Permanent)game.getLastKnownInformation(getTargetPointer().getFirst(game,source),Zone.BATTLEFIELD);
  }
  Permanent newPermanent=game.copyPermanent(targetCreature,permanent.getId(),source,new EmptyApplyToPermanent());
  newPermanent.addAbility(new UnstableShapeshifterTriggeredAbility(),source.getSourceId(),game);
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Permanent permanent=game.getPermanent(source.getSourceId());
  Permanent targetCreature=game.getPermanentOrLKIBattlefield(getTargetPointer().getFirst(game,source));
  if (targetCreature != null && permanent != null) {
    game.copyPermanent(Duration.EndOfTurn,targetCreature,permanent.getId(),source,new EmptyApplyToPermanent());
    return true;
  }
  return false;
}",0.6333333333333333
158281,"@Override public boolean apply(Game game,Ability source){
  UUID activePlayerId=game.getActivePlayerId();
  Player player=game.getPlayer(activePlayerId);
  if (player != null) {
    player.loseLife(3,game,false);
    TargetCardInLibrary target=new TargetCardInLibrary();
    if (player.searchLibrary(target,game)) {
      for (      UUID cardId : target.getTargets()) {
        Card card=player.getLibrary().getCard(cardId,game);
        player.putInHand(card,game);
      }
    }
    player.shuffleLibrary(source,game);
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  UUID activePlayerId=game.getActivePlayerId();
  Player player=game.getPlayer(activePlayerId);
  if (player != null) {
    player.loseLife(3,game,false);
    TargetCardInLibrary target=new TargetCardInLibrary();
    if (player.searchLibrary(target,game)) {
      player.moveCards(new CardsImpl(target.getTargets()),Zone.HAND,source,game);
    }
    player.shuffleLibrary(source,game);
    return true;
  }
  return false;
}",0.6493756003842459
158282,"private void setupLinks(){
  if (copyUrlToImage != null) {
    return;
  }
  copyUrlToImage=new HashMap<>();
  copyImageToUrl=new HashMap<>();
  copyUrlToImageDone=new HashMap<>();
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  for (  String key : copyUrlToImage.keySet()) {
    copyUrlToImageDone.put(key,maxTimes);
    copyImageToUrl.put(copyUrlToImage.get(key),key);
  }
}","private void setupLinks(){
  if (copyUrlToImage != null) {
    return;
  }
  copyUrlToImage=new HashMap<>();
  copyImageToUrl=new HashMap<>();
  copyUrlToImageDone=new HashMap<>();
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  copyUrlToImage.put(""String_Node_Str"",""String_Node_Str"");
  for (  String key : copyUrlToImage.keySet()) {
    copyUrlToImageDone.put(key,maxTimes);
    copyImageToUrl.put(copyUrlToImage.get(key),key);
  }
}",0.9862978185608658
158283,"private void doPause(String httpImageUrl){
  if (!httpImageUrl.startsWith(""String_Node_Str"")) {
    try {
      Thread.sleep(2000);
    }
 catch (    InterruptedException ex) {
    }
  }
}","@Override public void doPause(String httpImageUrl){
  if (!httpImageUrl.startsWith(""String_Node_Str"")) {
    try {
      Thread.sleep(2000);
    }
 catch (    InterruptedException ex) {
    }
  }
}",0.9558441558441558
158284,"@Override public String getNextHttpImageUrl(){
  if (copyUrlToImage == null) {
    setupLinks();
  }
  for (  String key : copyUrlToImageDone.keySet()) {
    if (copyUrlToImageDone.get(key) < maxTimes) {
      copyUrlToImageDone.put(key,maxTimes);
      doPause(key);
      return getSourceName(key) + key;
    }
  }
  if (maxTimes < 2) {
    maxTimes++;
  }
  for (  String key : copyUrlToImageDone.keySet()) {
    if (copyUrlToImageDone.get(key) < maxTimes) {
      copyUrlToImageDone.put(key,maxTimes);
      doPause(key);
      return getSourceName(key) + key;
    }
  }
  return null;
}","@Override public String getNextHttpImageUrl(){
  if (copyUrlToImage == null) {
    setupLinks();
  }
  for (  String key : copyUrlToImageDone.keySet()) {
    if (copyUrlToImageDone.get(key) < maxTimes) {
      copyUrlToImageDone.put(key,maxTimes);
      return getSourceName(key) + key;
    }
  }
  if (maxTimes < 2) {
    maxTimes++;
  }
  for (  String key : copyUrlToImageDone.keySet()) {
    if (copyUrlToImageDone.get(key) < maxTimes) {
      copyUrlToImageDone.put(key,maxTimes);
      return getSourceName(key) + key;
    }
  }
  return null;
}",0.9649737302977232
158285,"@Override public void run(){
  StringBuilder filePath=new StringBuilder();
  File temporaryFile=null;
  TFile outputFile=null;
  try {
    filePath.append(Constants.IO.imageBaseDir);
    if (!useSpecifiedPaths && card != null) {
      filePath.append(card.hashCode()).append(""String_Node_Str"").append(card.getName().replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str"")).append(""String_Node_Str"");
      temporaryFile=new File(filePath.toString());
    }
    String imagePath;
    if (useSpecifiedPaths) {
      if (card != null && card.isToken()) {
        imagePath=CardImageUtils.getTokenBasePath() + actualFilename;
      }
 else       if (card != null) {
        imagePath=CardImageUtils.getImageBasePath() + actualFilename;
      }
 else {
        imagePath=Constants.IO.imageBaseDir;
      }
      String tmpFile=filePath + ""String_Node_Str"" + actualFilename;
      temporaryFile=new File(tmpFile);
      if (!temporaryFile.exists()) {
        temporaryFile.getParentFile().mkdirs();
      }
    }
 else {
      imagePath=CardImageUtils.generateImagePath(card);
    }
    outputFile=new TFile(imagePath);
    if (!outputFile.exists()) {
      outputFile.getParentFile().mkdirs();
    }
    File existingFile=new File(imagePath.replaceFirst(""String_Node_Str"",""String_Node_Str""));
    if (existingFile.exists()) {
      new TFile(existingFile).cp_rp(outputFile);
synchronized (sync) {
        update(cardIndex + 1,count);
      }
      existingFile.delete();
      File parent=existingFile.getParentFile();
      if (parent != null && parent.isDirectory() && parent.list().length == 0) {
        parent.delete();
      }
      return;
    }
    BufferedOutputStream out;
    boolean useTempFile=false;
    int responseCode=0;
    URLConnection httpConn=null;
    if (temporaryFile != null && temporaryFile.length() > 100) {
      useTempFile=true;
    }
 else {
      httpConn=url.openConnection(p);
      setUpConnection(httpConn);
      httpConn.connect();
      responseCode=((HttpURLConnection)httpConn).getResponseCode();
    }
    if (responseCode == 200 || useTempFile) {
      if (!useTempFile) {
        try (BufferedInputStream in=new BufferedInputStream(((HttpURLConnection)httpConn).getInputStream())){
          out=new BufferedOutputStream(new TFileOutputStream(temporaryFile));
          byte[] buf=new byte[1024];
          int len;
          while ((len=in.read(buf)) != -1) {
            if (cancel) {
              in.close();
              out.flush();
              out.close();
              temporaryFile.delete();
              return;
            }
            out.write(buf,0,len);
          }
        }
         out.flush();
        out.close();
      }
      if (card != null && card.isTwoFacedCard()) {
        BufferedImage image=ImageIO.read(temporaryFile);
        if (image.getHeight() == 470) {
          BufferedImage renderedImage=new BufferedImage(265,370,BufferedImage.TYPE_INT_RGB);
          renderedImage.getGraphics();
          Graphics2D graphics2D=renderedImage.createGraphics();
          if (card.isTwoFacedCard() && card.isSecondSide()) {
            graphics2D.drawImage(image,0,0,265,370,313,62,578,432,null);
          }
 else {
            graphics2D.drawImage(image,0,0,265,370,41,62,306,432,null);
          }
          graphics2D.dispose();
          writeImageToFile(renderedImage,outputFile);
        }
 else {
          outputFile.getParentFile().mkdirs();
          new TFile(temporaryFile).cp_rp(outputFile);
        }
      }
 else {
        outputFile.getParentFile().mkdirs();
        new TFile(temporaryFile).cp_rp(outputFile);
      }
    }
 else {
      if (card != null && !useSpecifiedPaths) {
        logger.warn(""String_Node_Str"" + card.getName() + (!card.getDownloadName().equals(card.getName()) ? ""String_Node_Str"" + card.getDownloadName() : ""String_Node_Str"")+ ""String_Node_Str""+ card.getSet()+ ""String_Node_Str""+ responseCode+ ""String_Node_Str""+ url.toString());
      }
      if (logger.isDebugEnabled()) {
        logger.debug(""String_Node_Str"" + convertStreamToString(((HttpURLConnection)httpConn).getErrorStream()));
      }
    }
  }
 catch (  AccessDeniedException e) {
    logger.error(""String_Node_Str"" + (outputFile != null ? outputFile.toString() : ""String_Node_Str"" + card.getName() + ""String_Node_Str""+ card.getSet()+ ""String_Node_Str"") + ""String_Node_Str"");
  }
catch (  Exception e) {
    logger.error(e,e);
  }
 finally {
    if (temporaryFile != null) {
    }
  }
synchronized (sync) {
    update(cardIndex + 1,count);
  }
}","@Override public void run(){
  StringBuilder filePath=new StringBuilder();
  File temporaryFile=null;
  TFile outputFile=null;
  try {
    filePath.append(Constants.IO.imageBaseDir);
    if (!useSpecifiedPaths && card != null) {
      filePath.append(card.hashCode()).append(""String_Node_Str"").append(card.getName().replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str"")).append(""String_Node_Str"");
      temporaryFile=new File(filePath.toString());
    }
    String imagePath;
    if (useSpecifiedPaths) {
      if (card != null && card.isToken()) {
        imagePath=CardImageUtils.getTokenBasePath() + actualFilename;
      }
 else       if (card != null) {
        imagePath=CardImageUtils.getImageBasePath() + actualFilename;
      }
 else {
        imagePath=Constants.IO.imageBaseDir;
      }
      String tmpFile=filePath + ""String_Node_Str"" + actualFilename;
      temporaryFile=new File(tmpFile);
      if (!temporaryFile.exists()) {
        temporaryFile.getParentFile().mkdirs();
      }
    }
 else {
      imagePath=CardImageUtils.generateImagePath(card);
    }
    outputFile=new TFile(imagePath);
    if (!outputFile.exists()) {
      outputFile.getParentFile().mkdirs();
    }
    File existingFile=new File(imagePath.replaceFirst(""String_Node_Str"",""String_Node_Str""));
    if (existingFile.exists()) {
      new TFile(existingFile).cp_rp(outputFile);
synchronized (sync) {
        update(cardIndex + 1,count);
      }
      existingFile.delete();
      File parent=existingFile.getParentFile();
      if (parent != null && parent.isDirectory() && parent.list().length == 0) {
        parent.delete();
      }
      return;
    }
    BufferedOutputStream out;
    boolean useTempFile=false;
    int responseCode=0;
    URLConnection httpConn=null;
    if (temporaryFile != null && temporaryFile.length() > 100) {
      useTempFile=true;
    }
 else {
      cardImageSource.doPause(url.getPath());
      httpConn=url.openConnection(p);
      setUpConnection(httpConn);
      httpConn.connect();
      responseCode=((HttpURLConnection)httpConn).getResponseCode();
    }
    if (responseCode == 200 || useTempFile) {
      if (!useTempFile) {
        try (BufferedInputStream in=new BufferedInputStream(((HttpURLConnection)httpConn).getInputStream())){
          out=new BufferedOutputStream(new TFileOutputStream(temporaryFile));
          byte[] buf=new byte[1024];
          int len;
          while ((len=in.read(buf)) != -1) {
            if (cancel) {
              in.close();
              out.flush();
              out.close();
              temporaryFile.delete();
              return;
            }
            out.write(buf,0,len);
          }
        }
         out.flush();
        out.close();
      }
      if (card != null && card.isTwoFacedCard()) {
        BufferedImage image=ImageIO.read(temporaryFile);
        if (image.getHeight() == 470) {
          BufferedImage renderedImage=new BufferedImage(265,370,BufferedImage.TYPE_INT_RGB);
          renderedImage.getGraphics();
          Graphics2D graphics2D=renderedImage.createGraphics();
          if (card.isTwoFacedCard() && card.isSecondSide()) {
            graphics2D.drawImage(image,0,0,265,370,313,62,578,432,null);
          }
 else {
            graphics2D.drawImage(image,0,0,265,370,41,62,306,432,null);
          }
          graphics2D.dispose();
          writeImageToFile(renderedImage,outputFile);
        }
 else {
          outputFile.getParentFile().mkdirs();
          new TFile(temporaryFile).cp_rp(outputFile);
        }
      }
 else {
        outputFile.getParentFile().mkdirs();
        new TFile(temporaryFile).cp_rp(outputFile);
      }
    }
 else {
      if (card != null && !useSpecifiedPaths) {
        logger.warn(""String_Node_Str"" + card.getName() + (!card.getDownloadName().equals(card.getName()) ? ""String_Node_Str"" + card.getDownloadName() : ""String_Node_Str"")+ ""String_Node_Str""+ card.getSet()+ ""String_Node_Str""+ responseCode+ ""String_Node_Str""+ url.toString());
      }
      if (logger.isDebugEnabled()) {
        logger.debug(""String_Node_Str"" + convertStreamToString(((HttpURLConnection)httpConn).getErrorStream()));
      }
    }
  }
 catch (  AccessDeniedException e) {
    logger.error(""String_Node_Str"" + (outputFile != null ? outputFile.toString() : ""String_Node_Str"" + card.getName() + ""String_Node_Str""+ card.getSet()+ ""String_Node_Str"") + ""String_Node_Str"");
  }
catch (  Exception e) {
    logger.error(e,e);
  }
 finally {
    if (temporaryFile != null) {
    }
  }
synchronized (sync) {
    update(cardIndex + 1,count);
  }
}",0.9949759720401922
158286,"public void loadBooster(DraftPickView draftPickView){
  logLastPick(draftPickView);
  loadCardsToPickedCardsArea(draftPickView.getPicks());
  this.draftPicks.clearCardEventListeners();
  this.draftPicks.addCardEventListener(new Listener<Event>(){
    @Override public void event(    Event event){
      if (event.getEventName().equals(""String_Node_Str"")) {
        if (event.getSource() != null) {
          cardIdPopupMenu=((SimpleCardView)event.getSource()).getId();
          popupMenuCardPanel.show(event.getComponent(),event.getxPos(),event.getyPos());
        }
 else {
          popupMenuPickedArea.show(event.getComponent(),event.getxPos(),event.getyPos());
        }
      }
    }
  }
);
  draftBooster.loadBooster(CardsViewUtil.convertSimple(draftPickView.getBooster()),bigCard);
  this.draftBooster.clearCardEventListeners();
  this.draftBooster.addCardEventListener(new Listener<Event>(){
    @Override public void event(    Event event){
      if (event.getEventName().equals(""String_Node_Str"")) {
        SimpleCardView source=(SimpleCardView)event.getSource();
        DraftPickView view=SessionHandler.sendCardPick(draftId,source.getId(),cardsHidden);
        if (view != null) {
          loadCardsToPickedCardsArea(view.getPicks());
          draftBooster.loadBooster(EMPTY_VIEW,bigCard);
          Plugins.getInstance().getActionCallback().hideTooltipPopup();
          setMessage(""String_Node_Str"");
        }
      }
      if (event.getEventName().equals(""String_Node_Str"")) {
        SimpleCardView source=(SimpleCardView)event.getSource();
        SessionHandler.sendCardMark(draftId,source.getId());
      }
    }
  }
);
  setMessage(""String_Node_Str"");
  if (!MageFrame.getInstance().isActive()) {
    MageTray.getInstance().displayMessage(""String_Node_Str"");
    MageTray.getInstance().blink();
  }
  countdown.stop();
  this.timeout=draftPickView.getTimeout();
  setTimeout(timeout);
  if (timeout != 0) {
    countdown.start();
  }
}","public void loadBooster(DraftPickView draftPickView){
  logLastPick(draftPickView);
  loadCardsToPickedCardsArea(draftPickView.getPicks());
  this.draftPicks.clearCardEventListeners();
  this.draftPicks.addCardEventListener(new Listener<Event>(){
    @Override public void event(    Event event){
      if (event.getEventName().equals(""String_Node_Str"")) {
        if (event.getSource() != null) {
          cardIdPopupMenu=((SimpleCardView)event.getSource()).getId();
          popupMenuCardPanel.show(event.getComponent(),event.getxPos(),event.getyPos());
        }
 else {
          popupMenuPickedArea.show(event.getComponent(),event.getxPos(),event.getyPos());
        }
      }
    }
  }
);
  draftBooster.loadBooster(CardsViewUtil.convertSimple(draftPickView.getBooster()),bigCard);
  this.draftBooster.clearCardEventListeners();
  this.draftBooster.addCardEventListener(new Listener<Event>(){
    @Override public void event(    Event event){
      if (event.getEventName().equals(""String_Node_Str"")) {
        SimpleCardView source=(SimpleCardView)event.getSource();
        DraftPickView view=SessionHandler.sendCardPick(draftId,source.getId(),cardsHidden);
        if (view != null) {
          loadCardsToPickedCardsArea(view.getPicks());
          draftBooster.loadBooster(EMPTY_VIEW,bigCard);
          Plugins.getInstance().getActionCallback().hideOpenComponents();
          setMessage(""String_Node_Str"");
        }
      }
      if (event.getEventName().equals(""String_Node_Str"")) {
        SimpleCardView source=(SimpleCardView)event.getSource();
        SessionHandler.sendCardMark(draftId,source.getId());
      }
    }
  }
);
  setMessage(""String_Node_Str"");
  if (!MageFrame.getInstance().isActive()) {
    MageTray.getInstance().displayMessage(""String_Node_Str"");
    MageTray.getInstance().blink();
  }
  countdown.stop();
  this.timeout=draftPickView.getTimeout();
  setTimeout(timeout);
  if (timeout != 0) {
    countdown.start();
  }
}",0.9933741080530072
158287,"@Override public void event(Event event){
  if (event.getEventName().equals(""String_Node_Str"")) {
    SimpleCardView source=(SimpleCardView)event.getSource();
    DraftPickView view=SessionHandler.sendCardPick(draftId,source.getId(),cardsHidden);
    if (view != null) {
      loadCardsToPickedCardsArea(view.getPicks());
      draftBooster.loadBooster(EMPTY_VIEW,bigCard);
      Plugins.getInstance().getActionCallback().hideTooltipPopup();
      setMessage(""String_Node_Str"");
    }
  }
  if (event.getEventName().equals(""String_Node_Str"")) {
    SimpleCardView source=(SimpleCardView)event.getSource();
    SessionHandler.sendCardMark(draftId,source.getId());
  }
}","@Override public void event(Event event){
  if (event.getEventName().equals(""String_Node_Str"")) {
    SimpleCardView source=(SimpleCardView)event.getSource();
    DraftPickView view=SessionHandler.sendCardPick(draftId,source.getId(),cardsHidden);
    if (view != null) {
      loadCardsToPickedCardsArea(view.getPicks());
      draftBooster.loadBooster(EMPTY_VIEW,bigCard);
      Plugins.getInstance().getActionCallback().hideOpenComponents();
      setMessage(""String_Node_Str"");
    }
  }
  if (event.getEventName().equals(""String_Node_Str"")) {
    SimpleCardView source=(SimpleCardView)event.getSource();
    SessionHandler.sendCardMark(draftId,source.getId());
  }
}",0.98355754857997
158288,"@Override public String getText(Mode mode){
  if (staticText != null && !staticText.isEmpty()) {
    return staticText + ""String_Node_Str"";
  }
  StringBuilder sb=new StringBuilder();
  if (targetDescription.length() > 0) {
    sb.append(targetDescription);
  }
 else {
    sb.append(""String_Node_Str"").append(mode.getTargets().get(0).getTargetName());
  }
  sb.append(""String_Node_Str"");
  return sb.toString();
}","@Override public String getText(Mode mode){
  if (staticText != null && !staticText.isEmpty()) {
    return staticText + ""String_Node_Str"";
  }
  StringBuilder sb=new StringBuilder();
  if (targetDescription == null || targetDescription.length() > 0) {
    sb.append(targetDescription);
  }
 else {
    sb.append(""String_Node_Str"").append(mode.getTargets().get(0).getTargetName());
  }
  sb.append(""String_Node_Str"");
  return sb.toString();
}",0.9661610268378062
158289,"@Override public boolean replaceEvent(GameEvent event,Ability source,Game game){
  if (optional) {
    Player controller=game.getPlayer(source.getControllerId());
    MageObject object=game.getObject(source.getSourceId());
    if (controller == null || object == null) {
      return false;
    }
    if (!controller.chooseUse(outcome,""String_Node_Str"" + object.getLogName() + ""String_Node_Str"",source,game)) {
      return false;
    }
  }
  Spell spell=game.getStack().getSpell(event.getSourceId());
  if (spell == null) {
    StackObject stackObject=(StackObject)game.getLastKnownInformation(event.getSourceId(),Zone.STACK);
    if (stackObject instanceof Spell) {
      spell=(Spell)stackObject;
    }
  }
  for (  Effect effect : baseEffects) {
    if (effect instanceof ContinuousEffect) {
      game.addEffect((ContinuousEffect)effect,source);
    }
 else {
      if (spell != null) {
        effect.setValue(SOURCE_CAST_SPELL_ABILITY,spell.getSpellAbility());
      }
      effect.apply(game,source);
    }
  }
  return false;
}","@Override public boolean replaceEvent(GameEvent event,Ability source,Game game){
  if (optional) {
    Player controller=game.getPlayer(source.getControllerId());
    MageObject object=game.getPermanentEntering(source.getSourceId());
    if (object == null) {
      object=game.getObject(source.getSourceId());
    }
    if (controller == null || object == null) {
      return false;
    }
    if (!controller.chooseUse(outcome,""String_Node_Str"" + object.getLogName() + ""String_Node_Str"",source,game)) {
      return false;
    }
  }
  Spell spell=game.getStack().getSpell(event.getSourceId());
  if (spell == null) {
    StackObject stackObject=(StackObject)game.getLastKnownInformation(event.getSourceId(),Zone.STACK);
    if (stackObject instanceof Spell) {
      spell=(Spell)stackObject;
    }
  }
  for (  Effect effect : baseEffects) {
    if (effect instanceof ContinuousEffect) {
      game.addEffect((ContinuousEffect)effect,source);
    }
 else {
      if (spell != null) {
        effect.setValue(SOURCE_CAST_SPELL_ABILITY,spell.getSpellAbility());
      }
      effect.apply(game,source);
    }
  }
  return false;
}",0.951061865189289
158290,"public LifeLossOtherFromCombatWatcher(final LifeLossOtherFromCombatWatcher watcher){
  super(watcher);
}","public LifeLossOtherFromCombatWatcher(final LifeLossOtherFromCombatWatcher watcher){
  super(watcher);
  this.players.addAll(watcher.players);
}",0.8387096774193549
158291,"@Override public boolean apply(Game game,Ability source){
  List<UUID> permanents=(List<UUID>)game.getState().getValue(source.getSourceId() + ""String_Node_Str"");
  if (permanents != null) {
    for (    UUID permanentId : permanents) {
      Permanent permanent=game.getPermanent(permanentId);
      if (permanent != null) {
        int convertedManaCost=permanent.getConvertedManaCost();
        permanent.addAbility(new EquipAbility(Outcome.BoostCreature,new GenericManaCost(convertedManaCost)),game);
        permanent.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD,new BoostEquippedEffect(convertedManaCost,0)),game);
      }
    }
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Cards permanents=(Cards)game.getState().getValue(source.getSourceId() + ""String_Node_Str"");
  if (permanents != null) {
    for (    UUID permanentId : permanents) {
      Permanent permanent=game.getPermanent(permanentId);
      if (permanent != null) {
        int convertedManaCost=permanent.getConvertedManaCost();
        permanent.addAbility(new EquipAbility(Outcome.BoostCreature,new GenericManaCost(convertedManaCost)),game);
        permanent.addAbility(new SimpleStaticAbility(Zone.BATTLEFIELD,new BoostEquippedEffect(convertedManaCost,0)),game);
      }
    }
    return true;
  }
  return false;
}",0.9777448071216616
158292,"@Override public boolean apply(Game game,Ability source){
  Permanent permanent=game.getPermanent(source.getSourceId());
  if (permanent != null) {
    if (objectReference == null || !objectReference.refersTo(permanent,game)) {
      abilitiesToAdd=new HashSet<>();
      this.objectReference=new MageObjectReference(permanent,game);
      String keyString=CardUtil.getCardZoneString(""String_Node_Str"",source.getSourceId(),game,true);
      List<Card> delvedCards=(List<Card>)game.getState().getValue(keyString);
      if (delvedCards != null) {
        for (        Card card : delvedCards) {
          if (!card.getCardType().contains(CardType.CREATURE)) {
            continue;
          }
          for (          Ability cardAbility : card.getAbilities()) {
            if (cardAbility instanceof FlyingAbility) {
              abilitiesToAdd.add(FlyingAbility.getInstance());
            }
            if (cardAbility instanceof FirstStrikeAbility) {
              abilitiesToAdd.add(FirstStrikeAbility.getInstance());
            }
            if (cardAbility instanceof DoubleStrikeAbility) {
              abilitiesToAdd.add(DoubleStrikeAbility.getInstance());
            }
            if (cardAbility instanceof DeathtouchAbility) {
              abilitiesToAdd.add(DeathtouchAbility.getInstance());
            }
            if (cardAbility instanceof HasteAbility) {
              abilitiesToAdd.add(HasteAbility.getInstance());
            }
            if (cardAbility instanceof HexproofAbility) {
              abilitiesToAdd.add(HexproofAbility.getInstance());
            }
            if (cardAbility instanceof IndestructibleAbility) {
              abilitiesToAdd.add(IndestructibleAbility.getInstance());
            }
            if (cardAbility instanceof LifelinkAbility) {
              abilitiesToAdd.add(LifelinkAbility.getInstance());
            }
            if (cardAbility instanceof ReachAbility) {
              abilitiesToAdd.add(ReachAbility.getInstance());
            }
            if (cardAbility instanceof TrampleAbility) {
              abilitiesToAdd.add(TrampleAbility.getInstance());
            }
            if (cardAbility instanceof VigilanceAbility) {
              abilitiesToAdd.add(VigilanceAbility.getInstance());
            }
          }
        }
      }
    }
    for (    Ability ability : abilitiesToAdd) {
      permanent.addAbility(ability,source.getSourceId(),game);
    }
    return true;
  }
 else {
    if (abilitiesToAdd != null) {
      abilitiesToAdd=null;
    }
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Permanent permanent=game.getPermanent(source.getSourceId());
  if (permanent != null) {
    if (objectReference == null || !objectReference.refersTo(permanent,game)) {
      abilitiesToAdd=new HashSet<>();
      this.objectReference=new MageObjectReference(permanent,game);
      String keyString=CardUtil.getCardZoneString(""String_Node_Str"",source.getSourceId(),game,true);
      Cards delvedCards=(Cards)game.getState().getValue(keyString);
      if (delvedCards != null) {
        for (        Card card : delvedCards.getCards(game)) {
          if (!card.getCardType().contains(CardType.CREATURE)) {
            continue;
          }
          for (          Ability cardAbility : card.getAbilities()) {
            if (cardAbility instanceof FlyingAbility) {
              abilitiesToAdd.add(FlyingAbility.getInstance());
            }
            if (cardAbility instanceof FirstStrikeAbility) {
              abilitiesToAdd.add(FirstStrikeAbility.getInstance());
            }
            if (cardAbility instanceof DoubleStrikeAbility) {
              abilitiesToAdd.add(DoubleStrikeAbility.getInstance());
            }
            if (cardAbility instanceof DeathtouchAbility) {
              abilitiesToAdd.add(DeathtouchAbility.getInstance());
            }
            if (cardAbility instanceof HasteAbility) {
              abilitiesToAdd.add(HasteAbility.getInstance());
            }
            if (cardAbility instanceof HexproofAbility) {
              abilitiesToAdd.add(HexproofAbility.getInstance());
            }
            if (cardAbility instanceof IndestructibleAbility) {
              abilitiesToAdd.add(IndestructibleAbility.getInstance());
            }
            if (cardAbility instanceof LifelinkAbility) {
              abilitiesToAdd.add(LifelinkAbility.getInstance());
            }
            if (cardAbility instanceof ReachAbility) {
              abilitiesToAdd.add(ReachAbility.getInstance());
            }
            if (cardAbility instanceof TrampleAbility) {
              abilitiesToAdd.add(TrampleAbility.getInstance());
            }
            if (cardAbility instanceof VigilanceAbility) {
              abilitiesToAdd.add(VigilanceAbility.getInstance());
            }
          }
        }
      }
    }
    for (    Ability ability : abilitiesToAdd) {
      permanent.addAbility(ability,source.getSourceId(),game);
    }
    return true;
  }
 else   if (abilitiesToAdd != null) {
    abilitiesToAdd=null;
  }
  return false;
}",0.9864785420340976
158293,"@Override public boolean applies(UUID objectId,Ability source,UUID affectedControllerId,Game game){
  Card card=game.getCard(objectId);
  if (card != null && affectedControllerId.equals(card.getOwnerId()) && game.getState().getZone(card.getId()) == Zone.EXILED) {
    Map<UUID,HashSet<MageObjectReference>> exiledCards=(Map)game.getState().getValue(UbaMask.UBA_MASK_VALUE_KEY);
    if (exiledCards != null) {
      Set<MageObjectReference> exiledCardsByPlayer=exiledCards.get(affectedControllerId);
      if (exiledCardsByPlayer != null) {
        return exiledCardsByPlayer.contains(new MageObjectReference(card,game));
      }
    }
  }
  return false;
}","@Override public boolean applies(UUID objectId,Ability source,UUID affectedControllerId,Game game){
  Card card=game.getCard(objectId);
  if (card != null && affectedControllerId.equals(card.getOwnerId()) && game.getState().getZone(card.getId()) == Zone.EXILED) {
    HashSet<MageObjectReference> exiledCardsByPlayer=(HashSet)game.getState().getValue(UbaMask.UBA_MASK_VALUE_KEY + affectedControllerId);
    if (exiledCardsByPlayer != null) {
      return exiledCardsByPlayer.contains(new MageObjectReference(card,game));
    }
  }
  return false;
}",0.7159468438538206
158294,"@Override public boolean replaceEvent(GameEvent event,Ability source,Game game){
  if (event.getType().equals(GameEvent.EventType.PLAY_TURN)) {
    game.getState().setValue(UbaMask.UBA_MASK_VALUE_KEY,null);
    return false;
  }
  MageObject sourceObject=source.getSourceObject(game);
  Player player=game.getPlayer(event.getPlayerId());
  if (player != null && sourceObject != null) {
    Card card=player.getLibrary().getFromTop(game);
    if (card != null) {
      player.moveCardsToExile(card,source,game,true,source.getId(),sourceObject.getIdName());
      Map<UUID,HashSet<MageObjectReference>> exiledCards=(Map)game.getState().getValue(UbaMask.UBA_MASK_VALUE_KEY);
      if (exiledCards == null) {
        exiledCards=new HashMap<>();
        game.getState().setValue(UbaMask.UBA_MASK_VALUE_KEY,exiledCards);
      }
      HashSet<MageObjectReference> exiledCardsByPlayer=exiledCards.get(event.getPlayerId());
      if (exiledCardsByPlayer == null) {
        exiledCardsByPlayer=new HashSet<>();
        exiledCards.put(event.getPlayerId(),exiledCardsByPlayer);
      }
      exiledCardsByPlayer.add(new MageObjectReference(card.getId(),game));
    }
  }
  return true;
}","@Override public boolean replaceEvent(GameEvent event,Ability source,Game game){
  if (event.getType().equals(GameEvent.EventType.PLAY_TURN)) {
    for (    UUID playerId : game.getPlayerList()) {
      game.getState().setValue(UbaMask.UBA_MASK_VALUE_KEY + source.getSourceId() + playerId,null);
    }
    return false;
  }
  MageObject sourceObject=source.getSourceObject(game);
  Player player=game.getPlayer(event.getPlayerId());
  if (player != null && sourceObject != null) {
    Card card=player.getLibrary().getFromTop(game);
    if (card != null) {
      player.moveCardsToExile(card,source,game,true,source.getId(),sourceObject.getIdName());
      HashSet<MageObjectReference> exiledCardsByPlayer=(HashSet)game.getState().getValue(UbaMask.UBA_MASK_VALUE_KEY + event.getPlayerId());
      if (exiledCardsByPlayer == null) {
        exiledCardsByPlayer=new HashSet<>();
        game.getState().setValue(UbaMask.UBA_MASK_VALUE_KEY + event.getPlayerId(),exiledCardsByPlayer);
      }
      exiledCardsByPlayer.add(new MageObjectReference(card.getId(),game));
    }
  }
  return true;
}",0.7469135802469136
158295,"protected ActivationInfo(Game game){
  this.turnNum=game.getTurnNum();
  this.activationCounter=0;
}","protected ActivationInfo(Game game,int turnNum,int activationCounter){
  this.turnNum=turnNum;
  this.activationCounter=activationCounter;
}",0.7416666666666667
158296,"public static ActivationInfo getInstance(Game game,UUID sourceId,int zoneChangeCounter){
  String key=""String_Node_Str"" + sourceId.toString() + zoneChangeCounter;
  ActivationInfo activationInfo=(ActivationInfo)game.getState().getValue(key);
  if (activationInfo == null) {
    activationInfo=new ActivationInfo(game);
    game.getState().setValue(key,activationInfo);
  }
  return activationInfo;
}","public static ActivationInfo getInstance(Game game,UUID sourceId,int zoneChangeCounter){
  String key=""String_Node_Str"" + sourceId.toString() + zoneChangeCounter;
  Integer activations=(Integer)game.getState().getValue(key);
  ActivationInfo activationInfo;
  if (activations != null) {
    Integer turnNum=(Integer)game.getState().getValue(key + ""String_Node_Str"");
    activationInfo=new ActivationInfo(game,turnNum,activations);
  }
 else {
    activationInfo=new ActivationInfo(game,game.getTurnNum(),0);
  }
  activationInfo.setKey(key);
  return activationInfo;
}",0.4917355371900826
158297,"public void addActivation(Game game){
  if (game.getTurnNum() != turnNum) {
    activationCounter=1;
    turnNum=game.getTurnNum();
  }
 else {
    activationCounter++;
  }
}","public void addActivation(Game game){
  if (game.getTurnNum() != turnNum) {
    activationCounter=1;
    turnNum=game.getTurnNum();
  }
 else {
    activationCounter++;
  }
  game.getState().setValue(key,activationCounter);
  game.getState().setValue(key + ""String_Node_Str"",turnNum);
}",0.7565217391304347
158298,"@Override public boolean checkTrigger(GameEvent event,Game game){
  if (super.checkTrigger(event,game)) {
    if (game.getTurn().getStepType().equals(PhaseStep.COMBAT_DAMAGE) || game.getTurn().getStepType().equals(PhaseStep.FIRST_COMBAT_DAMAGE)) {
      Step step=(Step)game.getState().getValue(""String_Node_Str"" + getOriginalId());
      if (!game.getStep().equals(step)) {
        game.getState().setValue(""String_Node_Str"" + getOriginalId(),game.getStep());
        return true;
      }
    }
 else {
      game.getState().setValue(""String_Node_Str"" + getOriginalId(),null);
      return true;
    }
  }
  return false;
}","@Override public boolean checkTrigger(GameEvent event,Game game){
  if (super.checkTrigger(event,game)) {
    if (game.getTurn().getStepType().equals(PhaseStep.COMBAT_DAMAGE) || game.getTurn().getStepType().equals(PhaseStep.FIRST_COMBAT_DAMAGE)) {
      Integer stepHash=(Integer)game.getState().getValue(""String_Node_Str"" + getOriginalId());
      if (stepHash == null || game.getStep().hashCode() != stepHash) {
        game.getState().setValue(""String_Node_Str"" + getOriginalId(),game.getStep().hashCode());
        return true;
      }
    }
 else {
      game.getState().setValue(""String_Node_Str"" + getOriginalId(),null);
      return true;
    }
  }
  return false;
}",0.8998459167950693
158299,"@Override public AetherTradewindsEffect copy(){
  return new AetherTradewindsEffect(this);
}","@Override public AetherTradewinds copy(){
  return new AetherTradewinds(this);
}",0.9302325581395348
158300,"@Override public List<Ability> getPlayable(Game game,boolean hidden){
  List<Ability> playable=new ArrayList<>();
  if (!shouldSkipGettingPlayable(game)) {
    ManaOptions availableMana=getManaAvailable(game);
    availableMana.addMana(manaPool.getMana());
    for (    ConditionalMana conditionalMana : manaPool.getConditionalMana()) {
      availableMana.addMana(conditionalMana);
    }
    if (hidden) {
      for (      Card card : hand.getUniqueCards(game)) {
        for (        Ability ability : card.getAbilities(game)) {
          if (ability.getZone().match(Zone.HAND)) {
            if (ability instanceof ActivatedAbility) {
              if (!(ability instanceof PlayLandAbility) || !game.getContinuousEffects().preventedByRuleModification(GameEvent.getEvent(GameEvent.EventType.PLAY_LAND,ability.getSourceId(),ability.getSourceId(),playerId),ability,game,true)) {
                if (canPlay((ActivatedAbility)ability,availableMana,card,game)) {
                  playable.add(ability);
                }
              }
            }
 else             if (ability instanceof AlternativeSourceCosts) {
              if (card.getCardType().contains(CardType.LAND)) {
                if (canLandPlayAlternateSourceCostsAbility(card,availableMana,ability,game)) {
                  playable.add(ability);
                }
              }
 else               if (card.getCardType().contains(CardType.CREATURE)) {
                if (!playable.contains(card.getSpellAbility())) {
                  if (((AlternativeSourceCosts)ability).isAvailable(card.getSpellAbility(),game)) {
                    playable.add(card.getSpellAbility());
                  }
                }
              }
            }
          }
        }
      }
    }
    for (    Card card : graveyard.getUniqueCards(game)) {
      boolean asThoughtCast=game.getContinuousEffects().asThough(card.getId(),AsThoughEffectType.PLAY_FROM_NOT_OWN_HAND_ZONE,this.getId(),game);
      for (      ActivatedAbility ability : card.getAbilities().getActivatedAbilities(Zone.ALL)) {
        boolean possible=false;
        if (ability.getZone().match(Zone.GRAVEYARD)) {
          possible=true;
        }
 else         if (ability.getZone().match(Zone.HAND) && (ability instanceof SpellAbility || ability instanceof PlayLandAbility)) {
          if (asThoughtCast || canPlayCardsFromGraveyard()) {
            possible=true;
          }
        }
        if (possible && canPlay(ability,availableMana,card,game)) {
          playable.add(ability);
        }
      }
      LinkedHashMap<UUID,ActivatedAbility> useable=new LinkedHashMap<>();
      getOtherUseableActivatedAbilities(card,Zone.GRAVEYARD,game,useable);
      for (      Ability ability : useable.values()) {
        playable.add(ability);
      }
    }
    for (    ExileZone exile : game.getExile().getExileZones()) {
      for (      Card card : exile.getCards(game)) {
        if (game.getContinuousEffects().asThough(card.getId(),AsThoughEffectType.PLAY_FROM_NOT_OWN_HAND_ZONE,this.getId(),game)) {
          for (          Ability ability : card.getAbilities()) {
            if (ability.getZone().match(Zone.HAND)) {
              ability.setControllerId(this.getId());
              if (ability instanceof ActivatedAbility) {
                if (((ActivatedAbility)ability).canActivate(playerId,game)) {
                  playable.add(ability);
                }
              }
            }
          }
        }
      }
    }
    for (    Cards cards : game.getState().getRevealed().values()) {
      for (      Card card : cards.getCards(game)) {
        if (game.getContinuousEffects().asThough(card.getId(),AsThoughEffectType.PLAY_FROM_NOT_OWN_HAND_ZONE,this.getId(),game)) {
          for (          ActivatedAbility ability : card.getAbilities().getActivatedAbilities(Zone.HAND)) {
            if (ability instanceof SpellAbility || ability instanceof PlayLandAbility) {
              playable.add(ability);
            }
          }
        }
      }
    }
    for (    UUID playerInRangeId : game.getState().getPlayersInRange(getId(),game)) {
      Player player=game.getPlayer(playerInRangeId);
      if (player != null) {
        if (player.isTopCardRevealed() && player.getLibrary().size() > 0) {
          Card card=player.getLibrary().getFromTop(game);
          if (game.getContinuousEffects().asThough(card.getId(),AsThoughEffectType.PLAY_FROM_NOT_OWN_HAND_ZONE,getId(),game)) {
            for (            ActivatedAbility ability : card.getAbilities().getActivatedAbilities(Zone.HAND)) {
              if (ability instanceof SpellAbility || ability instanceof PlayLandAbility) {
                playable.add(ability);
              }
            }
          }
        }
      }
    }
    Map<String,Ability> playableActivated=new HashMap<>();
    for (    Permanent permanent : game.getBattlefield().getAllActivePermanents(playerId)) {
      LinkedHashMap<UUID,ActivatedAbility> useableAbilities=getUseableActivatedAbilities(permanent,Zone.BATTLEFIELD,game);
      for (      ActivatedAbility ability : useableAbilities.values()) {
        if (!playableActivated.containsKey(ability.toString())) {
          playableActivated.put(ability.toString(),ability);
        }
      }
    }
    for (    StackObject stackObject : game.getState().getStack()) {
      for (      ActivatedAbility ability : stackObject.getAbilities().getActivatedAbilities(Zone.STACK)) {
        if (ability instanceof ActivatedAbility && canPlay(ability,availableMana,game.getObject(ability.getSourceId()),game)) {
          playableActivated.put(ability.toString(),ability);
        }
      }
    }
    for (    CommandObject commandObject : game.getState().getCommand()) {
      for (      ActivatedAbility ability : commandObject.getAbilities().getActivatedAbilities(Zone.COMMAND)) {
        if (ability.getControllerId().equals(getId()) && ability instanceof ActivatedAbility && canPlay(ability,availableMana,game.getObject(ability.getSourceId()),game)) {
          playableActivated.put(ability.toString(),ability);
        }
      }
    }
    playable.addAll(playableActivated.values());
  }
  return playable;
}","@Override public List<Ability> getPlayable(Game game,boolean hidden){
  List<Ability> playable=new ArrayList<>();
  if (!shouldSkipGettingPlayable(game)) {
    ManaOptions availableMana=getManaAvailable(game);
    availableMana.addMana(manaPool.getMana());
    for (    ConditionalMana conditionalMana : manaPool.getConditionalMana()) {
      availableMana.addMana(conditionalMana);
    }
    if (hidden) {
      for (      Card card : hand.getUniqueCards(game)) {
        for (        Ability ability : card.getAbilities(game)) {
          if (ability.getZone().match(Zone.HAND)) {
            if (ability instanceof ActivatedAbility) {
              if (!(ability instanceof PlayLandAbility) || !game.getContinuousEffects().preventedByRuleModification(GameEvent.getEvent(GameEvent.EventType.PLAY_LAND,ability.getSourceId(),ability.getSourceId(),playerId),ability,game,true)) {
                if (canPlay((ActivatedAbility)ability,availableMana,card,game)) {
                  playable.add(ability);
                }
              }
            }
 else             if (ability instanceof AlternativeSourceCosts) {
              if (card.getCardType().contains(CardType.LAND)) {
                if (canLandPlayAlternateSourceCostsAbility(card,availableMana,ability,game)) {
                  playable.add(ability);
                }
              }
 else               if (card.getCardType().contains(CardType.CREATURE)) {
                if (!playable.contains(card.getSpellAbility())) {
                  if (((AlternativeSourceCosts)ability).isAvailable(card.getSpellAbility(),game)) {
                    playable.add(card.getSpellAbility());
                  }
                }
              }
            }
          }
        }
      }
    }
    for (    Card card : graveyard.getUniqueCards(game)) {
      boolean asThoughtCast=game.getContinuousEffects().asThough(card.getId(),AsThoughEffectType.PLAY_FROM_NOT_OWN_HAND_ZONE,this.getId(),game);
      for (      ActivatedAbility ability : card.getAbilities().getActivatedAbilities(Zone.ALL)) {
        boolean possible=false;
        if (ability.getZone().match(Zone.GRAVEYARD)) {
          possible=true;
        }
 else         if (ability.getZone().match(Zone.HAND) && (ability instanceof SpellAbility || ability instanceof PlayLandAbility)) {
          if (asThoughtCast || canPlayCardsFromGraveyard()) {
            possible=true;
          }
        }
        if (possible && canPlay(ability,availableMana,card,game)) {
          playable.add(ability);
        }
      }
      LinkedHashMap<UUID,ActivatedAbility> useable=new LinkedHashMap<>();
      getOtherUseableActivatedAbilities(card,Zone.GRAVEYARD,game,useable);
      for (      Ability ability : useable.values()) {
        playable.add(ability);
      }
    }
    for (    ExileZone exile : game.getExile().getExileZones()) {
      for (      Card card : exile.getCards(game)) {
        if (game.getContinuousEffects().asThough(card.getId(),AsThoughEffectType.PLAY_FROM_NOT_OWN_HAND_ZONE,this.getId(),game)) {
          for (          Ability ability : card.getAbilities()) {
            if (ability.getZone().match(Zone.HAND)) {
              ability.setControllerId(this.getId());
              if (ability instanceof ActivatedAbility) {
                if (((ActivatedAbility)ability).canActivate(playerId,game)) {
                  playable.add(ability);
                }
              }
              ability.setControllerId(card.getOwnerId());
            }
          }
        }
      }
    }
    for (    Cards cards : game.getState().getRevealed().values()) {
      for (      Card card : cards.getCards(game)) {
        if (game.getContinuousEffects().asThough(card.getId(),AsThoughEffectType.PLAY_FROM_NOT_OWN_HAND_ZONE,this.getId(),game)) {
          for (          ActivatedAbility ability : card.getAbilities().getActivatedAbilities(Zone.HAND)) {
            if (ability instanceof SpellAbility || ability instanceof PlayLandAbility) {
              playable.add(ability);
            }
          }
        }
      }
    }
    for (    UUID playerInRangeId : game.getState().getPlayersInRange(getId(),game)) {
      Player player=game.getPlayer(playerInRangeId);
      if (player != null) {
        if (player.isTopCardRevealed() && player.getLibrary().size() > 0) {
          Card card=player.getLibrary().getFromTop(game);
          if (game.getContinuousEffects().asThough(card.getId(),AsThoughEffectType.PLAY_FROM_NOT_OWN_HAND_ZONE,getId(),game)) {
            for (            ActivatedAbility ability : card.getAbilities().getActivatedAbilities(Zone.HAND)) {
              if (ability instanceof SpellAbility || ability instanceof PlayLandAbility) {
                playable.add(ability);
              }
            }
          }
        }
      }
    }
    Map<String,Ability> playableActivated=new HashMap<>();
    for (    Permanent permanent : game.getBattlefield().getAllActivePermanents(playerId)) {
      LinkedHashMap<UUID,ActivatedAbility> useableAbilities=getUseableActivatedAbilities(permanent,Zone.BATTLEFIELD,game);
      for (      ActivatedAbility ability : useableAbilities.values()) {
        if (!playableActivated.containsKey(ability.toString())) {
          playableActivated.put(ability.toString(),ability);
        }
      }
    }
    for (    StackObject stackObject : game.getState().getStack()) {
      for (      ActivatedAbility ability : stackObject.getAbilities().getActivatedAbilities(Zone.STACK)) {
        if (ability instanceof ActivatedAbility && canPlay(ability,availableMana,game.getObject(ability.getSourceId()),game)) {
          playableActivated.put(ability.toString(),ability);
        }
      }
    }
    for (    CommandObject commandObject : game.getState().getCommand()) {
      for (      ActivatedAbility ability : commandObject.getAbilities().getActivatedAbilities(Zone.COMMAND)) {
        if (ability.getControllerId().equals(getId()) && ability instanceof ActivatedAbility && canPlay(ability,availableMana,game.getObject(ability.getSourceId()),game)) {
          playableActivated.put(ability.toString(),ability);
        }
      }
    }
    playable.addAll(playableActivated.values());
  }
  return playable;
}",0.9953089615011323
158301,"@Override public boolean apply(Game game,Ability source){
  Permanent permanent=game.getPermanent(source.getSourceId());
  MageObject sourceObject=game.getObject(source.getSourceId());
  if (permanent != null && sourceObject != null) {
    if (permanent.moveToExile(source.getSourceId(),sourceObject.getIdName(),source.getSourceId(),game)) {
      AtTheBeginOfNextEndStepDelayedTriggeredAbility delayedAbility=new AtTheBeginOfNextEndStepDelayedTriggeredAbility(new ReturnFromExileEffect(source.getSourceId(),Zone.BATTLEFIELD));
      game.addDelayedTriggeredAbility(delayedAbility,source);
      return true;
    }
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Permanent permanent=game.getPermanent(source.getSourceId());
  MageObject sourceObject=game.getObject(source.getSourceId());
  if (permanent != null && sourceObject != null) {
    if (permanent.moveToExile(source.getSourceId(),sourceObject.getIdName(),source.getSourceId(),game)) {
      Effect effect=new ReturnToBattlefieldUnderYourControlTargetEffect();
      effect.setText(""String_Node_Str"");
      effect.setTargetPointer(new FixedTarget(source.getSourceId(),game));
      game.addDelayedTriggeredAbility(new AtTheBeginOfNextEndStepDelayedTriggeredAbility(effect),source);
      return true;
    }
  }
  return false;
}",0.6828160484481454
158302,"@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  MageObject sourceObject=source.getSourceObject(game);
  if (controller != null && sourceObject != null) {
    Permanent permanent=game.getPermanent(getTargetPointer().getFirst(game,source));
    if (permanent != null) {
      UUID exileId=UUID.randomUUID();
      if (controller.moveCardsToExile(permanent,source,game,true,exileId,sourceObject.getIdName())) {
        AtTheBeginOfNextEndStepDelayedTriggeredAbility delayedAbility=new AtTheBeginOfNextEndStepDelayedTriggeredAbility(new ReturnFromExileEffect(exileId,Zone.BATTLEFIELD,false));
        game.addDelayedTriggeredAbility(delayedAbility,source);
      }
    }
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  MageObject sourceObject=source.getSourceObject(game);
  if (controller != null && sourceObject != null) {
    Permanent permanent=game.getPermanent(getTargetPointer().getFirst(game,source));
    if (permanent != null) {
      UUID exileId=UUID.randomUUID();
      if (controller.moveCardsToExile(permanent,source,game,true,exileId,sourceObject.getIdName())) {
        Effect effect=new ReturnToBattlefieldUnderOwnerControlTargetEffect();
        effect.setText(""String_Node_Str"");
        effect.setTargetPointer(new FixedTarget(permanent.getId(),game));
        game.addDelayedTriggeredAbility(new AtTheBeginOfNextEndStepDelayedTriggeredAbility(effect),source);
      }
    }
    return true;
  }
  return false;
}",0.7400990099009901
158303,"@Override public boolean apply(Game game,Ability source){
  Permanent permanent=game.getPermanent(source.getFirstTarget());
  MageObject sourceObject=game.getObject(source.getSourceId());
  if (permanent != null && sourceObject != null) {
    if (permanent.moveToExile(source.getSourceId(),sourceObject.getIdName(),source.getSourceId(),game)) {
      AtTheBeginOfNextEndStepDelayedTriggeredAbility delayedAbility=new AtTheBeginOfNextEndStepDelayedTriggeredAbility(new ReturnFromExileEffect(source.getSourceId(),Zone.BATTLEFIELD,false));
      game.addDelayedTriggeredAbility(delayedAbility,source);
      return true;
    }
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Permanent permanent=game.getPermanent(source.getFirstTarget());
  MageObject sourceObject=game.getObject(source.getSourceId());
  if (permanent != null && sourceObject != null) {
    if (permanent.moveToExile(source.getSourceId(),sourceObject.getIdName(),source.getSourceId(),game)) {
      Effect effect=new ReturnToBattlefieldUnderOwnerControlTargetEffect();
      effect.setText(""String_Node_Str"");
      effect.setTargetPointer(new FixedTarget(source.getFirstTarget(),game));
      game.addDelayedTriggeredAbility(new AtTheBeginOfNextEndStepDelayedTriggeredAbility(effect),source);
      return true;
    }
  }
  return false;
}",0.6791323859386686
158304,"@Override public boolean apply(Game game,Ability source){
  Permanent permanent=game.getPermanent(source.getFirstTarget());
  Player controller=game.getPlayer(source.getControllerId());
  Permanent sourcePermanent=game.getPermanentOrLKIBattlefield(source.getSourceId());
  if (controller != null && permanent != null && sourcePermanent != null) {
    if (controller.moveCardToExileWithInfo(permanent,source.getSourceId(),sourcePermanent.getIdName(),source.getSourceId(),game,Zone.BATTLEFIELD,true)) {
      game.addDelayedTriggeredAbility(new AtTheBeginOfNextEndStepDelayedTriggeredAbility(new ReturnFromExileEffect(source.getSourceId(),Zone.BATTLEFIELD,false)),source);
      return true;
    }
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Permanent permanent=game.getPermanent(source.getFirstTarget());
  Player controller=game.getPlayer(source.getControllerId());
  Permanent sourcePermanent=game.getPermanentOrLKIBattlefield(source.getSourceId());
  if (controller != null && permanent != null && sourcePermanent != null) {
    if (controller.moveCardToExileWithInfo(permanent,source.getSourceId(),sourcePermanent.getIdName(),source.getSourceId(),game,Zone.BATTLEFIELD,true)) {
      Effect effect=new ReturnToBattlefieldUnderOwnerControlTargetEffect();
      effect.setText(""String_Node_Str"");
      effect.setTargetPointer(new FixedTarget(source.getFirstTarget(),game));
      game.addDelayedTriggeredAbility(new AtTheBeginOfNextEndStepDelayedTriggeredAbility(effect),source);
      return true;
    }
  }
  return false;
}",0.8268370607028754
158305,"@Override public boolean apply(Game game,Ability source){
  Permanent permanent=game.getPermanent(source.getFirstTarget());
  Player controller=game.getPlayer(source.getControllerId());
  Permanent sourcePermanent=game.getPermanentOrLKIBattlefield(source.getSourceId());
  if (controller != null && permanent != null && sourcePermanent != null) {
    Permanent permanentReset=permanent.copy();
    permanentReset.getCounters(game).clear();
    permanentReset.getPower().resetToBaseValue();
    permanentReset.getToughness().resetToBaseValue();
    CopyEffect copyEffect=new CopyEffect(Duration.EndOfTurn,permanentReset,source.getSourceId());
    if (controller.moveCardToExileWithInfo(permanent,source.getSourceId(),sourcePermanent.getIdName(),source.getSourceId(),game,Zone.BATTLEFIELD,true)) {
      game.addEffect(copyEffect,source);
      game.addDelayedTriggeredAbility(new AtTheBeginOfNextEndStepDelayedTriggeredAbility(new ReturnFromExileEffect(source.getSourceId(),Zone.BATTLEFIELD,false)),source);
      return true;
    }
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Permanent permanent=game.getPermanent(source.getFirstTarget());
  Player controller=game.getPlayer(source.getControllerId());
  Permanent sourcePermanent=game.getPermanentOrLKIBattlefield(source.getSourceId());
  if (controller != null && permanent != null && sourcePermanent != null) {
    Permanent permanentReset=permanent.copy();
    permanentReset.getCounters(game).clear();
    permanentReset.getPower().resetToBaseValue();
    permanentReset.getToughness().resetToBaseValue();
    CopyEffect copyEffect=new CopyEffect(Duration.EndOfTurn,permanentReset,source.getSourceId());
    if (controller.moveCardToExileWithInfo(permanent,source.getSourceId(),sourcePermanent.getIdName(),source.getSourceId(),game,Zone.BATTLEFIELD,true)) {
      game.addEffect(copyEffect,source);
      Effect effect=new ReturnToBattlefieldUnderOwnerControlTargetEffect();
      effect.setText(""String_Node_Str"");
      effect.setTargetPointer(new FixedTarget(source.getFirstTarget(),game));
      game.addDelayedTriggeredAbility(new AtTheBeginOfNextEndStepDelayedTriggeredAbility(effect),source);
      return true;
    }
  }
  return false;
}",0.8788556101922217
158306,"@Override public boolean apply(Game game,Ability source){
  Permanent permanent=game.getPermanent(source.getFirstTarget());
  MageObject sourceObject=game.getObject(source.getSourceId());
  if (permanent != null && sourceObject != null) {
    if (permanent.moveToExile(source.getSourceId(),sourceObject.getIdName(),source.getSourceId(),game)) {
      AtTheBeginOfNextEndStepDelayedTriggeredAbility delayedAbility=new AtTheBeginOfNextEndStepDelayedTriggeredAbility(new ReturnFromExileEffect(source.getSourceId(),Zone.BATTLEFIELD,false));
      game.addDelayedTriggeredAbility(delayedAbility,source);
      return true;
    }
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Permanent permanent=game.getPermanent(source.getFirstTarget());
  MageObject sourceObject=game.getObject(source.getSourceId());
  if (permanent != null && sourceObject != null) {
    if (permanent.moveToExile(source.getSourceId(),sourceObject.getIdName(),source.getSourceId(),game)) {
      Effect effect=new ReturnToBattlefieldUnderOwnerControlTargetEffect();
      effect.setText(""String_Node_Str"");
      effect.setTargetPointer(new FixedTarget(source.getFirstTarget(),game));
      game.addDelayedTriggeredAbility(new AtTheBeginOfNextEndStepDelayedTriggeredAbility(effect),source);
      return true;
    }
  }
  return false;
}",0.6791323859386686
158307,"@Override public boolean apply(Game game,Ability source){
  Permanent permanent=game.getPermanent(source.getFirstTarget());
  if (permanent != null) {
    if (permanent.moveToExile(source.getSourceId(),""String_Node_Str"",source.getSourceId(),game)) {
      game.addDelayedTriggeredAbility(new AtTheBeginOfNextEndStepDelayedTriggeredAbility(new ReturnFromExileEffect(source.getSourceId(),Zone.BATTLEFIELD,true)),source);
      return true;
    }
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Permanent permanent=game.getPermanent(source.getFirstTarget());
  MageObject sourceObject=source.getSourceObject(game);
  if (permanent != null && sourceObject != null) {
    if (permanent.moveToExile(source.getSourceId(),sourceObject.getIdName(),source.getSourceId(),game)) {
      Effect effect=new ReturnToBattlefieldUnderOwnerControlTargetEffect();
      effect.setText(""String_Node_Str"");
      effect.setTargetPointer(new FixedTarget(source.getFirstTarget(),game));
      game.addDelayedTriggeredAbility(new AtTheBeginOfNextEndStepDelayedTriggeredAbility(effect),source);
      return true;
    }
  }
  return false;
}",0.63881636205396
158308,"@Override public boolean apply(Game game,Ability source){
  Permanent permanent=game.getPermanent(getTargetPointer().getFirst(game,source));
  Permanent sourcePermanent=game.getPermanentOrLKIBattlefield(source.getSourceId());
  if (permanent != null && sourcePermanent != null) {
    if (permanent.moveToExile(source.getSourceId(),sourcePermanent.getName(),source.getSourceId(),game)) {
      AtTheBeginOfNextEndStepDelayedTriggeredAbility delayedAbility=new AtTheBeginOfNextEndStepDelayedTriggeredAbility(new ReturnFromExileEffect(source.getSourceId(),Zone.BATTLEFIELD));
      game.addDelayedTriggeredAbility(delayedAbility,source);
      return true;
    }
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Permanent permanent=game.getPermanent(getTargetPointer().getFirst(game,source));
  Permanent sourcePermanent=game.getPermanentOrLKIBattlefield(source.getSourceId());
  if (permanent != null && sourcePermanent != null) {
    if (permanent.moveToExile(source.getSourceId(),sourcePermanent.getName(),source.getSourceId(),game)) {
      Effect effect=new ReturnToBattlefieldUnderOwnerControlTargetEffect();
      effect.setText(""String_Node_Str"");
      effect.setTargetPointer(new FixedTarget(getTargetPointer().getFirst(game,source),game));
      game.addDelayedTriggeredAbility(new AtTheBeginOfNextEndStepDelayedTriggeredAbility(effect),source);
      return true;
    }
  }
  return false;
}",0.6424581005586593
158309,"private Object getColumn(Object obj,int column){
  CardView c=(CardView)obj;
switch (column) {
case 0:
    if (displayNoCopies) {
      String key=c.getName() + c.getExpansionSetCode() + c.getCardNumber();
      Integer count=cardsNoCopies.get(key);
      return count != null ? count : ""String_Node_Str"";
    }
  return ""String_Node_Str"";
case 1:
return c.getName();
case 2:
String manaCost=""String_Node_Str"";
for (String m : c.getManaCost()) {
manaCost+=m;
}
String castingCost=UI.getDisplayManaCost(manaCost);
castingCost=ManaSymbols.replaceSymbolsWithHTML(castingCost,ManaSymbols.Type.TABLE);
return ""String_Node_Str"" + castingCost + ""String_Node_Str"";
case 3:
return CardHelper.getColor(c);
case 4:
return CardHelper.getType(c);
case 5:
return CardHelper.isCreature(c) ? c.getPower() + ""String_Node_Str"" + c.getToughness() : ""String_Node_Str"";
case 6:
return c.getRarity().toString();
case 7:
return c.getExpansionSetCode();
default :
return ""String_Node_Str"";
}
}","private Object getColumn(Object obj,int column){
  CardView c=(CardView)obj;
switch (column) {
case 0:
    if (displayNoCopies) {
      String key=c.getName() + c.getExpansionSetCode() + c.getCardNumber();
      Integer count=cardsNoCopies.get(key);
      return count != null ? count : ""String_Node_Str"";
    }
  return ""String_Node_Str"";
case 1:
return c.getName();
case 2:
String manaCost=""String_Node_Str"";
for (String m : c.getManaCost()) {
manaCost+=m;
}
String castingCost=UI.getDisplayManaCost(manaCost);
castingCost=ManaSymbols.replaceSymbolsWithHTML(castingCost,ManaSymbols.Type.TABLE);
return ""String_Node_Str"" + castingCost + ""String_Node_Str"";
case 3:
return CardHelper.getColor(c);
case 4:
return CardHelper.getType(c);
case 5:
return CardHelper.isCreature(c) ? c.getPower() + ""String_Node_Str"" + c.getToughness() : ""String_Node_Str"";
case 6:
return c.getRarity().toString();
case 7:
return c.getExpansionSetCode();
case 8:
return c.getCardNumber();
default :
return ""String_Node_Str"";
}
}",0.9827586206896552
158310,"public CardSetInfo(String name,String expansionSetCode,String cardNumber,Rarity rarity,CardGraphicInfo graphicInfo){
  this.name=name;
  this.expansionSetCode=expansionSetCode;
  this.cardNumber=cardNumber;
  this.rarity=rarity;
  this.graphicInfo=graphicInfo;
}","public CardSetInfo(String name,String expansionSetCode,String cardNumber,Rarity rarity,CardGraphicInfo graphicInfo){
  this.name=name;
  this.expansionSetCode=expansionSetCode;
  this.cardNumber=cardNumber;
  this.rarity=rarity;
  if (graphicInfo == null && Rarity.LAND.equals(rarity)) {
    this.graphicInfo=new CardGraphicInfo(null,true);
  }
 else {
    this.graphicInfo=graphicInfo;
  }
}",0.709480122324159
158311,"public SetCardInfo(String name,String cardNumber,Rarity rarity,Class<?> cardClass,CardGraphicInfo graphicInfo){
  this.name=name;
  this.cardNumber=cardNumber;
  this.rarity=rarity;
  this.cardClass=cardClass;
  this.usesVariousArt=false;
  this.graphicInfo=graphicInfo;
}","public SetCardInfo(String name,String cardNumber,Rarity rarity,Class<?> cardClass,CardGraphicInfo graphicInfo){
  this.name=name;
  this.cardNumber=cardNumber;
  this.rarity=rarity;
  this.cardClass=cardClass;
  if (graphicInfo != null) {
    this.usesVariousArt=graphicInfo.getUsesVariousArt();
  }
 else {
    usesVariousArt=false;
  }
  this.graphicInfo=graphicInfo;
}",0.7247278382581649
158312,"private static boolean cardViewEquals(CardView a,CardView b){
  if (a == b) {
    return true;
  }
  if (a.getClass() != b.getClass()) {
    return false;
  }
  if (!a.getName().equals(b.getName())) {
    return false;
  }
  if (!a.getPower().equals(b.getPower())) {
    return false;
  }
  if (!a.getToughness().equals(b.getToughness())) {
    return false;
  }
  if (!a.getLoyalty().equals(b.getLoyalty())) {
    return false;
  }
  if (0 != a.getColor().compareTo(b.getColor())) {
    return false;
  }
  if (!a.getCardTypes().equals(b.getCardTypes())) {
    return false;
  }
  if (!a.getSubTypes().equals(b.getSubTypes())) {
    return false;
  }
  if (!a.getSuperTypes().equals(b.getSuperTypes())) {
    return false;
  }
  if (!a.getManaCost().equals(b.getManaCost())) {
    return false;
  }
  if (!a.getRules().equals(b.getRules())) {
    return false;
  }
  String expA=a.getExpansionSetCode();
  if (expA == null) {
    expA=""String_Node_Str"";
  }
  String expB=b.getExpansionSetCode();
  if (expB == null) {
    expB=""String_Node_Str"";
  }
  if (!expA.equals(expB)) {
    return false;
  }
  if (a.getFrameStyle() != b.getFrameStyle()) {
    return false;
  }
  if (a.getCounters() == null) {
    if (b.getCounters() != null) {
      return false;
    }
  }
 else   if (!a.getCounters().equals(b.getCounters())) {
    return false;
  }
  if (a.isFaceDown() != b.isFaceDown()) {
    return false;
  }
  if ((a instanceof PermanentView)) {
    PermanentView aa=(PermanentView)a;
    PermanentView bb=(PermanentView)b;
    if (aa.hasSummoningSickness() != bb.hasSummoningSickness()) {
      return false;
    }
    if (aa.getDamage() != bb.getDamage()) {
      return false;
    }
  }
  return true;
}","private static boolean cardViewEquals(CardView a,CardView b){
  if (a == b) {
    return true;
  }
  if (a.getClass() != b.getClass()) {
    return false;
  }
  if (!a.getName().equals(b.getName())) {
    return false;
  }
  if (!a.getPower().equals(b.getPower())) {
    return false;
  }
  if (!a.getToughness().equals(b.getToughness())) {
    return false;
  }
  if (!a.getLoyalty().equals(b.getLoyalty())) {
    return false;
  }
  if (0 != a.getColor().compareTo(b.getColor())) {
    return false;
  }
  if (!a.getCardTypes().equals(b.getCardTypes())) {
    return false;
  }
  if (!a.getSubTypes().equals(b.getSubTypes())) {
    return false;
  }
  if (!a.getSuperTypes().equals(b.getSuperTypes())) {
    return false;
  }
  if (!a.getManaCost().equals(b.getManaCost())) {
    return false;
  }
  if (!a.getRules().equals(b.getRules())) {
    return false;
  }
  if (!a.getRarity().equals(b.getRarity())) {
    return false;
  }
  if (!a.getCardNumber().equals(b.getCardNumber())) {
    return false;
  }
  String expA=a.getExpansionSetCode();
  if (expA == null) {
    expA=""String_Node_Str"";
  }
  String expB=b.getExpansionSetCode();
  if (expB == null) {
    expB=""String_Node_Str"";
  }
  if (!expA.equals(expB)) {
    return false;
  }
  if (a.getFrameStyle() != b.getFrameStyle()) {
    return false;
  }
  if (a.getCounters() == null) {
    if (b.getCounters() != null) {
      return false;
    }
  }
 else   if (!a.getCounters().equals(b.getCounters())) {
    return false;
  }
  if (a.isFaceDown() != b.isFaceDown()) {
    return false;
  }
  if ((a instanceof PermanentView)) {
    PermanentView aa=(PermanentView)a;
    PermanentView bb=(PermanentView)b;
    if (aa.hasSummoningSickness() != bb.hasSummoningSickness()) {
      return false;
    }
    if (aa.getDamage() != bb.getDamage()) {
      return false;
    }
  }
  return true;
}",0.9595959595959596
158313,"/** 
 * Returns the image appropriate to display for a card in a picture panel, but only it was ALREADY LOADED. That is, the call is immediate and will not block on file IO.
 * @param card
 * @param width
 * @param height
 * @return 
 */
public static BufferedImage tryGetImage(CardView card,int width,int height){
  if (Constants.THUMBNAIL_SIZE_FULL.width + 10 > width) {
    return tryGetThumbnail(card);
  }
  String key=getKey(card,card.getName(),Integer.toString(width));
  BufferedImage original=tryGetImage(key);
  if (original == null) {
    LOGGER.debug(key + ""String_Node_Str"");
    return null;
  }
  double scale=Math.min((double)width / original.getWidth(),(double)height / original.getHeight());
  if (scale >= 1) {
    return original;
  }
  return TransformedImageCache.getResizedImage(original,(int)(original.getWidth() * scale),(int)(original.getHeight() * scale));
}","/** 
 * Returns the image appropriate to display for a card in a picture panel, but only it was ALREADY LOADED. That is, the call is immediate and will not block on file IO.
 * @param card
 * @param width
 * @param height
 * @return
 */
public static BufferedImage tryGetImage(CardView card,int width,int height){
  if (Constants.THUMBNAIL_SIZE_FULL.width + 10 > width) {
    return tryGetThumbnail(card);
  }
  String key=getKey(card,card.getName(),Integer.toString(width));
  BufferedImage original=tryGetImage(key);
  if (original == null) {
    LOGGER.debug(key + ""String_Node_Str"");
    return null;
  }
  double scale=Math.min((double)width / original.getWidth(),(double)height / original.getHeight());
  if (scale >= 1) {
    return original;
  }
  return TransformedImageCache.getResizedImage(original,(int)(original.getWidth() * scale),(int)(original.getHeight() * scale));
}",0.9994347088750708
158314,"@Override public BufferedImage apply(String key){
  try {
    boolean usesVariousArt=false;
    if (key.matches(""String_Node_Str"")) {
      usesVariousArt=true;
      key=key.replace(""String_Node_Str"",""String_Node_Str"");
    }
    boolean thumbnail=false;
    if (key.matches(""String_Node_Str"")) {
      thumbnail=true;
      key=key.replace(""String_Node_Str"",""String_Node_Str"");
    }
    Matcher m=KEY_PATTERN.matcher(key);
    if (m.matches()) {
      String name=m.group(1);
      String set=m.group(2);
      Integer type=Integer.parseInt(m.group(3));
      String collectorId=m.group(4);
      if (collectorId.equals(""String_Node_Str"")) {
        collectorId=""String_Node_Str"";
      }
      String tokenSetCode=m.group(5);
      String tokenDescriptor=m.group(6);
      CardDownloadData info=new CardDownloadData(name,set,collectorId,usesVariousArt,type,tokenSetCode,tokenDescriptor);
      String path;
      if (collectorId.isEmpty() || ""String_Node_Str"".equals(collectorId)) {
        info.setToken(true);
        path=CardImageUtils.generateTokenImagePath(info);
        if (path == null) {
          path=DirectLinksForDownload.outDir + File.separator + DirectLinksForDownload.cardbackFilename;
        }
      }
 else {
        path=CardImageUtils.generateImagePath(info);
      }
      if (path == null) {
        return null;
      }
      TFile file=getTFile(path);
      if (file == null) {
        return null;
      }
      if (thumbnail && path.endsWith(""String_Node_Str"")) {
        String thumbnailPath=buildThumbnailPath(path);
        TFile thumbnailFile=null;
        try {
          thumbnailFile=new TFile(thumbnailPath);
        }
 catch (        Exception ex) {
        }
        boolean exists=false;
        if (thumbnailFile != null) {
          try {
            exists=thumbnailFile.exists();
          }
 catch (          Exception ex) {
            exists=false;
          }
        }
        if (exists) {
          LOGGER.debug(""String_Node_Str"" + key + ""String_Node_Str""+ thumbnailPath);
          BufferedImage thumbnailImage=loadImage(thumbnailFile);
          if (thumbnailImage == null) {
            LOGGER.warn(""String_Node_Str"" + key + ""String_Node_Str""+ thumbnailPath+ ""String_Node_Str"");
            thumbnailImage=makeThumbnailByFile(key,file,thumbnailPath);
          }
          return thumbnailImage;
        }
 else {
          return makeThumbnailByFile(key,file,thumbnailPath);
        }
      }
 else {
        return getWizardsCard(loadImage(file));
      }
    }
 else {
      throw new RuntimeException(""String_Node_Str"" + key);
    }
  }
 catch (  Exception ex) {
    if (ex instanceof ComputationException) {
      throw (ComputationException)ex;
    }
 else {
      throw new ComputationException(ex);
    }
  }
}","@Override public BufferedImage apply(String key){
  try {
    boolean usesVariousArt=false;
    LOGGER.info(""String_Node_Str"" + key);
    if (key.matches(""String_Node_Str"")) {
      usesVariousArt=true;
      key=key.replace(""String_Node_Str"",""String_Node_Str"");
    }
    boolean thumbnail=false;
    if (key.matches(""String_Node_Str"")) {
      thumbnail=true;
      key=key.replace(""String_Node_Str"",""String_Node_Str"");
    }
    Matcher m=KEY_PATTERN.matcher(key);
    if (m.matches()) {
      String name=m.group(1);
      String set=m.group(2);
      Integer type=Integer.parseInt(m.group(3));
      String collectorId=m.group(4);
      if (collectorId.equals(""String_Node_Str"")) {
        collectorId=""String_Node_Str"";
      }
      String tokenSetCode=m.group(5);
      String tokenDescriptor=m.group(6);
      CardDownloadData info=new CardDownloadData(name,set,collectorId,usesVariousArt,type,tokenSetCode,tokenDescriptor);
      String path;
      if (collectorId.isEmpty() || ""String_Node_Str"".equals(collectorId)) {
        info.setToken(true);
        path=CardImageUtils.generateTokenImagePath(info);
        if (path == null) {
          path=DirectLinksForDownload.outDir + File.separator + DirectLinksForDownload.cardbackFilename;
        }
      }
 else {
        path=CardImageUtils.generateImagePath(info);
      }
      if (path == null) {
        return null;
      }
      TFile file=getTFile(path);
      if (file == null) {
        return null;
      }
      if (thumbnail && path.endsWith(""String_Node_Str"")) {
        String thumbnailPath=buildThumbnailPath(path);
        TFile thumbnailFile=null;
        try {
          thumbnailFile=new TFile(thumbnailPath);
        }
 catch (        Exception ex) {
        }
        boolean exists=false;
        if (thumbnailFile != null) {
          try {
            exists=thumbnailFile.exists();
          }
 catch (          Exception ex) {
            exists=false;
          }
        }
        if (exists) {
          LOGGER.debug(""String_Node_Str"" + key + ""String_Node_Str""+ thumbnailPath);
          BufferedImage thumbnailImage=loadImage(thumbnailFile);
          if (thumbnailImage == null) {
            LOGGER.warn(""String_Node_Str"" + key + ""String_Node_Str""+ thumbnailPath+ ""String_Node_Str"");
            thumbnailImage=makeThumbnailByFile(key,file,thumbnailPath);
          }
          return thumbnailImage;
        }
 else {
          return makeThumbnailByFile(key,file,thumbnailPath);
        }
      }
 else {
        BufferedImage image=loadImage(file);
        LOGGER.info(""String_Node_Str"" + Integer.toHexString(image.hashCode()));
        image=getWizardsCard(image);
        LOGGER.info(""String_Node_Str"" + Integer.toHexString(image.hashCode()));
        return image;
      }
    }
 else {
      throw new RuntimeException(""String_Node_Str"" + key);
    }
  }
 catch (  Exception ex) {
    if (ex instanceof ComputationException) {
      throw (ComputationException)ex;
    }
 else {
      throw new ComputationException(ex);
    }
  }
}",0.9480027548209368
158315,"public Ooze2Token(){
  super(""String_Node_Str"",""String_Node_Str"");
  cardType.add(CardType.CREATURE);
  subtype.add(""String_Node_Str"");
  color.setGreen(true);
  power=new MageInt(2);
  toughness=new MageInt(2);
  this.addAbility(new DiesTriggeredAbility(new CreateTokenEffect(new OozeToken(new MageInt(1),new MageInt(1)),2),false));
}","public Ooze2Token(){
  super(""String_Node_Str"",""String_Node_Str"");
  cardType.add(CardType.CREATURE);
  subtype.add(""String_Node_Str"");
  color.setGreen(true);
  power=new MageInt(2);
  toughness=new MageInt(2);
  this.addAbility(new DiesTriggeredAbility(new CreateTokenEffect(new OozeToken(1,1),2),false));
}",0.9596273291925466
158316,"private void showImage(int row){
  CardView card=view.get(row);
  if (!card.getId().equals(bigCard.getCardId())) {
    if (!MageFrame.isLite()) {
      Image image=Plugins.getInstance().getOriginalImage(card);
      if (image != null && image instanceof BufferedImage) {
        bigCard.setCard(card.getId(),EnlargeMode.NORMAL,image,new ArrayList<String>(),false);
      }
 else {
        drawCardText(card);
      }
    }
 else {
      drawCardText(card);
    }
  }
}","private void showImage(int row){
  CardView card=view.get(row);
  if (!card.getId().equals(bigCard.getCardId())) {
    if (!MageFrame.isLite()) {
      Image image=Plugins.getInstance().getOriginalImage(card);
      if (image != null && image instanceof BufferedImage) {
        bigCard.setCard(card.getId(),EnlargeMode.NORMAL,image,new ArrayList<>(),false);
      }
 else {
        drawCardText(card);
      }
    }
 else {
      drawCardText(card);
    }
  }
}",0.9935483870967742
158317,"@Override public boolean joinTable(UUID roomId,UUID tableId,String playerName,String playerType,int skill,DeckCardLists deckList,String password){
  try {
    if (isConnected()) {
      return server.joinTable(sessionId,roomId,tableId,playerName,playerType,skill,deckList,password);
    }
  }
 catch (  InvalidDeckException iex) {
    handleInvalidDeckException(iex);
  }
catch (  GameException ex) {
    handleGameException(ex);
  }
catch (  MageException ex) {
    handleMageException(ex);
  }
catch (  Throwable t) {
    handleThrowable(t);
  }
  return false;
}","@Override public boolean joinTable(UUID roomId,UUID tableId,String playerName,String playerType,int skill,DeckCardLists deckList,String password){
  try {
    if (isConnected()) {
      deckList.setCardLayout(null);
      deckList.setSideboardLayout(null);
      return server.joinTable(sessionId,roomId,tableId,playerName,playerType,skill,deckList,password);
    }
  }
 catch (  InvalidDeckException iex) {
    handleInvalidDeckException(iex);
  }
catch (  GameException ex) {
    handleGameException(ex);
  }
catch (  MageException ex) {
    handleMageException(ex);
  }
catch (  Throwable t) {
    handleThrowable(t);
  }
  return false;
}",0.936205468102734
158318,"@Override public boolean updateDeck(UUID tableId,DeckCardLists deck){
  try {
    if (isConnected()) {
      server.updateDeck(sessionId,tableId,deck);
      return true;
    }
  }
 catch (  GameException ex) {
    handleGameException(ex);
  }
catch (  MageException ex) {
    handleMageException(ex);
  }
catch (  Throwable t) {
    handleThrowable(t);
  }
  return false;
}","@Override public boolean updateDeck(UUID tableId,DeckCardLists deck){
  try {
    if (isConnected()) {
      deck.setCardLayout(null);
      deck.setSideboardLayout(null);
      server.updateDeck(sessionId,tableId,deck);
      return true;
    }
  }
 catch (  GameException ex) {
    handleGameException(ex);
  }
catch (  MageException ex) {
    handleMageException(ex);
  }
catch (  Throwable t) {
    handleThrowable(t);
  }
  return false;
}",0.9157509157509156
158319,"@Override public boolean submitDeck(UUID tableId,DeckCardLists deck){
  try {
    if (isConnected()) {
      return server.submitDeck(sessionId,tableId,deck);
    }
  }
 catch (  GameException ex) {
    handleGameException(ex);
  }
catch (  MageException ex) {
    handleMageException(ex);
  }
catch (  Throwable t) {
    handleThrowable(t);
  }
  return false;
}","@Override public boolean submitDeck(UUID tableId,DeckCardLists deck){
  try {
    if (isConnected()) {
      deck.setCardLayout(null);
      deck.setSideboardLayout(null);
      return server.submitDeck(sessionId,tableId,deck);
    }
  }
 catch (  GameException ex) {
    handleGameException(ex);
  }
catch (  MageException ex) {
    handleMageException(ex);
  }
catch (  Throwable t) {
    handleThrowable(t);
  }
  return false;
}",0.9132075471698112
158320,"@Override public boolean joinTournamentTable(UUID roomId,UUID tableId,String playerName,String playerType,int skill,DeckCardLists deckList,String password){
  try {
    if (isConnected()) {
      return server.joinTournamentTable(sessionId,roomId,tableId,playerName,playerType,skill,deckList,password);
    }
  }
 catch (  GameException ex) {
    handleGameException(ex);
  }
catch (  MageException ex) {
    handleMageException(ex);
  }
catch (  Throwable t) {
    handleThrowable(t);
  }
  return false;
}","@Override public boolean joinTournamentTable(UUID roomId,UUID tableId,String playerName,String playerType,int skill,DeckCardLists deckList,String password){
  try {
    if (isConnected()) {
      deckList.setCardLayout(null);
      deckList.setSideboardLayout(null);
      return server.joinTournamentTable(sessionId,roomId,tableId,playerName,playerType,skill,deckList,password);
    }
  }
 catch (  GameException ex) {
    handleGameException(ex);
  }
catch (  MageException ex) {
    handleMageException(ex);
  }
catch (  Throwable t) {
    handleThrowable(t);
  }
  return false;
}",0.92942254812099
158321,"@Override protected void readLine(String line,DeckCardLists deckList){
  if (line.isEmpty() || line.startsWith(""String_Node_Str"")) {
    return;
  }
  Matcher m=pattern.matcher(line);
  if (m.matches()) {
    boolean sideboard=false;
    if (""String_Node_Str"".equals(m.group(1))) {
      sideboard=true;
    }
    int count=Integer.parseInt(m.group(2));
    String setCode=m.group(3);
    String cardNum=m.group(4);
    DeckCardInfo deckCardInfo=null;
    CardInfo cardInfo=CardRepository.instance.findCard(setCode,cardNum);
    if (cardInfo != null) {
      deckCardInfo=new DeckCardInfo(cardInfo.getName(),cardInfo.getCardNumber(),cardInfo.getSetCode());
    }
    if (deckCardInfo != null) {
      for (int i=0; i < count; i++) {
        if (!sideboard) {
          deckList.getCards().add(deckCardInfo);
        }
 else {
          deckList.getSideboard().add(deckCardInfo);
        }
      }
    }
 else {
      sbMessage.append(""String_Node_Str"").append(""String_Node_Str"").append(lineCount).append(""String_Node_Str"").append(line).append(""String_Node_Str"");
    }
  }
 else   if (line.startsWith(""String_Node_Str"")) {
    deckList.setName(line.substring(5,line.length()));
  }
 else   if (line.startsWith(""String_Node_Str"")) {
    deckList.setAuthor(line.substring(7,line.length()));
  }
 else   if (line.startsWith(""String_Node_Str"")) {
    Matcher m2=layoutPattern.matcher(line);
    if (m2.find()) {
      String target=m2.group(1);
      int rows=Integer.parseInt(m2.group(2));
      int cols=Integer.parseInt(m2.group(3));
      String settings=m2.group(4);
      String stackData=m2.group(5);
      Matcher stackMatcher=layoutStackPattern.matcher(stackData);
      List<List<List<DeckCardInfo>>> grid=new ArrayList<>();
      int totalCardCount=0;
      for (int row=0; row < rows; ++row) {
        List<List<DeckCardInfo>> rowData=new ArrayList<>();
        grid.add(rowData);
        for (int col=0; col < cols; ++col) {
          List<DeckCardInfo> stack=new ArrayList<>();
          rowData.add(stack);
          if (stackMatcher.find()) {
            String thisStackData=stackMatcher.group(1);
            Matcher stackEntries=layoutStackEntryPattern.matcher(thisStackData);
            while (stackEntries.find()) {
              ++totalCardCount;
              stack.add(new DeckCardInfo(""String_Node_Str"",stackEntries.group(2),stackEntries.group(1)));
            }
          }
 else {
            sbMessage.append(""String_Node_Str"");
          }
        }
      }
      DeckCardLayout layout=new DeckCardLayout(grid,settings);
      int expectedCount=0;
      if (target.equals(""String_Node_Str"")) {
        deckList.setCardLayout(layout);
        expectedCount=deckList.getCards().size();
      }
 else       if (target.equals(""String_Node_Str"")) {
        deckList.setSideboardLayout(layout);
        expectedCount=deckList.getSideboard().size();
      }
 else {
        sbMessage.append(""String_Node_Str"" + target + ""String_Node_Str"");
      }
      if (totalCardCount != expectedCount) {
        sbMessage.append(""String_Node_Str"" + expectedCount + ""String_Node_Str""+ totalCardCount+ ""String_Node_Str""+ target+ ""String_Node_Str"");
      }
    }
 else {
      sbMessage.append(""String_Node_Str"");
    }
  }
}","@Override protected void readLine(String line,DeckCardLists deckList){
  if (line.isEmpty() || line.startsWith(""String_Node_Str"")) {
    return;
  }
  Matcher m=pattern.matcher(line);
  if (m.matches()) {
    boolean sideboard=false;
    if (""String_Node_Str"".equals(m.group(1))) {
      sideboard=true;
    }
    int count=Integer.parseInt(m.group(2));
    String setCode=m.group(3);
    String cardNum=m.group(4);
    DeckCardInfo deckCardInfo=null;
    CardInfo cardInfo=CardRepository.instance.findCard(setCode,cardNum);
    if (cardInfo != null) {
      deckCardInfo=new DeckCardInfo(cardInfo.getName(),cardInfo.getCardNumber(),cardInfo.getSetCode());
    }
    if (deckCardInfo != null) {
      for (int i=0; i < count; i++) {
        if (!sideboard) {
          deckList.getCards().add(deckCardInfo);
        }
 else {
          deckList.getSideboard().add(deckCardInfo);
        }
      }
    }
 else {
      sbMessage.append(""String_Node_Str"").append(""String_Node_Str"").append(lineCount).append(""String_Node_Str"").append(line).append(""String_Node_Str"");
    }
  }
 else   if (line.startsWith(""String_Node_Str"")) {
    deckList.setName(line.substring(5,line.length()));
  }
 else   if (line.startsWith(""String_Node_Str"")) {
    deckList.setAuthor(line.substring(7,line.length()));
  }
 else   if (line.startsWith(""String_Node_Str"")) {
    Matcher m2=layoutPattern.matcher(line);
    if (m2.find()) {
      String target=m2.group(1);
      int rows=Integer.parseInt(m2.group(2));
      int cols=Integer.parseInt(m2.group(3));
      String settings=m2.group(4);
      String stackData=m2.group(5);
      Matcher stackMatcher=layoutStackPattern.matcher(stackData);
      List<List<List<DeckCardInfo>>> grid=new ArrayList<>();
      int totalCardCount=0;
      for (int row=0; row < rows; ++row) {
        List<List<DeckCardInfo>> rowData=new ArrayList<>();
        grid.add(rowData);
        for (int col=0; col < cols; ++col) {
          List<DeckCardInfo> stack=new ArrayList<>();
          rowData.add(stack);
          if (stackMatcher.find()) {
            String thisStackData=stackMatcher.group(1);
            Matcher stackEntries=layoutStackEntryPattern.matcher(thisStackData);
            while (stackEntries.find()) {
              ++totalCardCount;
              stack.add(new DeckCardInfo(""String_Node_Str"",stackEntries.group(2),stackEntries.group(1)));
            }
          }
 else {
            sbMessage.append(""String_Node_Str"");
          }
        }
      }
      DeckCardLayout layout=new DeckCardLayout(grid,settings);
      int expectedCount=0;
switch (target) {
case ""String_Node_Str"":
        deckList.setCardLayout(layout);
      expectedCount=deckList.getCards().size();
    break;
case ""String_Node_Str"":
  deckList.setSideboardLayout(layout);
expectedCount=deckList.getSideboard().size();
break;
default :
sbMessage.append(""String_Node_Str"").append(target).append(""String_Node_Str"");
break;
}
if (totalCardCount != expectedCount) {
sbMessage.append(""String_Node_Str"").append(expectedCount).append(""String_Node_Str"").append(totalCardCount).append(""String_Node_Str"").append(target).append(""String_Node_Str"");
}
}
 else {
sbMessage.append(""String_Node_Str"");
}
}
}",0.9447814590138436
158322,"@Override public boolean apply(Game game,Ability source){
  Permanent permanent=game.getPermanent(targetPointer.getFirst(game,source));
  if (permanent != null) {
    if (permanent.moveToZone(Zone.LIBRARY,source.getSourceId(),game,true)) {
      game.getPlayer(permanent.getOwnerId()).shuffleLibrary(source,game);
      return true;
    }
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Permanent permanent=game.getPermanent(targetPointer.getFirst(game,source));
  Player controller=game.getPlayer(source.getControllerId());
  if (permanent != null && controller != null) {
    if (controller.moveCards(permanent,Zone.LIBRARY,source,game)) {
      game.getPlayer(permanent.getOwnerId()).shuffleLibrary(source,game);
    }
    return true;
  }
  return false;
}",0.6456494325346784
158323,"/** 
 * Set a flag to know, that the ability is only created adn used to check  what's playbable for the player.
 */
void setCheckPlayableMode();","/** 
 * Set a flag to know, that the ability is only created adn used to check what's playbable for the player.
 */
void setCheckPlayableMode();",0.9965397923875432
158324,"/** 
 * @param ability
 * @param available if null, it won't be checked if enough mana is available
 * @param sourceObject
 * @param game
 * @return
 */
protected boolean canPlay(ActivatedAbility ability,ManaOptions available,MageObject sourceObject,Game game){
  if (!(ability instanceof ManaAbility)) {
    ActivatedAbility copy=ability.copy();
    copy.setCheckPlayableMode();
    if (!copy.canActivate(playerId,game)) {
      return false;
    }
    game.getContinuousEffects().costModification(copy,game);
    Card card=game.getCard(ability.getSourceId());
    if (card != null) {
      for (      Ability ability0 : card.getAbilities()) {
        if (ability0 instanceof AdjustingSourceCosts) {
          if (!(ability0 instanceof ConvokeAbility)) {
            ((AdjustingSourceCosts)ability0).adjustCosts(copy,game);
          }
        }
      }
    }
    boolean canBeCastRegularly=true;
    if (copy instanceof SpellAbility && copy.getManaCosts().isEmpty() && copy.getCosts().isEmpty()) {
      canBeCastRegularly=false;
    }
    if (canBeCastRegularly) {
      ManaOptions abilityOptions=copy.getManaCostsToPay().getOptions();
      if (abilityOptions.isEmpty()) {
        return true;
      }
 else {
        if (available == null) {
          return true;
        }
        boolean spendAnyMana=game.getContinuousEffects().asThough(ability.getSourceId(),AsThoughEffectType.SPEND_OTHER_MANA,ability,ability.getControllerId(),game);
        for (        Mana mana : abilityOptions) {
          for (          Mana avail : available) {
            if (spendAnyMana && mana.count() <= avail.count()) {
              return true;
            }
            if (mana.enough(avail)) {
              return true;
            }
          }
        }
      }
    }
    for (    Ability objectAbility : sourceObject.getAbilities()) {
      if (objectAbility instanceof AlternativeCostSourceAbility) {
        if (objectAbility.getCosts().canPay(ability,ability.getSourceId(),playerId,game)) {
          return true;
        }
      }
    }
    if (canPlayCardByAlternateCost(card,available,ability,game)) {
      return true;
    }
  }
  return false;
}","/** 
 * @param ability
 * @param available if null, it won't be checked if enough mana is available
 * @param sourceObject
 * @param game
 * @return
 */
protected boolean canPlay(ActivatedAbility ability,ManaOptions available,MageObject sourceObject,Game game){
  if (!(ability instanceof ManaAbility)) {
    ActivatedAbility copy=ability.copy();
    copy.setCheckPlayableMode();
    if (!copy.canActivate(playerId,game)) {
      return false;
    }
    game.getContinuousEffects().costModification(copy,game);
    Card card=game.getCard(ability.getSourceId());
    if (card != null) {
      for (      Ability ability0 : card.getAbilities()) {
        if (ability0 instanceof AdjustingSourceCosts) {
          if (!(ability0 instanceof ConvokeAbility)) {
            ((AdjustingSourceCosts)ability0).adjustCosts(copy,game);
          }
        }
      }
    }
    boolean canBeCastRegularly=true;
    if (copy instanceof SpellAbility && copy.getManaCosts().isEmpty() && copy.getCosts().isEmpty()) {
      canBeCastRegularly=false;
    }
    if (canBeCastRegularly) {
      ManaOptions abilityOptions=copy.getMinimumCostToActivate(playerId,game);
      if (abilityOptions.isEmpty()) {
        return true;
      }
 else {
        if (available == null) {
          return true;
        }
        boolean spendAnyMana=game.getContinuousEffects().asThough(ability.getSourceId(),AsThoughEffectType.SPEND_OTHER_MANA,ability,ability.getControllerId(),game);
        for (        Mana mana : abilityOptions) {
          for (          Mana avail : available) {
            if (spendAnyMana && mana.count() <= avail.count()) {
              return true;
            }
            if (mana.enough(avail)) {
              return true;
            }
          }
        }
      }
    }
    for (    Ability objectAbility : sourceObject.getAbilities()) {
      if (objectAbility instanceof AlternativeCostSourceAbility) {
        if (objectAbility.getCosts().canPay(ability,ability.getSourceId(),playerId,game)) {
          return true;
        }
      }
    }
    if (canPlayCardByAlternateCost(card,available,ability,game)) {
      return true;
    }
  }
  return false;
}",0.9886547811993516
158325,"@Override public void init(Ability source,Game game){
  super.init(source,game);
  if (chooseLandType) {
    Player controller=game.getPlayer(source.getControllerId());
    if (controller != null) {
      Choice choice=new ChoiceBasicLandType();
      controller.choose(outcome,choice,game);
      landTypes.add(choice.getChoice());
    }
 else {
      this.discard();
    }
  }
  if (!loseOther) {
    for (    UUID targetPermanent : targetPointer.getTargets(game,source)) {
      Permanent land=game.getPermanent(targetPermanent);
      if (land != null) {
        for (        String type : land.getSubtype(game)) {
          if (!landTypes.contains(type)) {
            landTypes.add(type);
          }
        }
      }
    }
  }
}","@Override public void init(Ability source,Game game){
  super.init(source,game);
  if (chooseLandType) {
    Player controller=game.getPlayer(source.getControllerId());
    if (controller != null) {
      Choice choice=new ChoiceBasicLandType();
      controller.choose(outcome,choice,game);
      landTypes.add(choice.getChoice());
    }
 else {
      this.discard();
    }
  }
  if (loseOther) {
    landTypesToAdd.addAll(landTypes);
  }
}",0.6915887850467289
158326,"public BecomesBasicLandTargetEffect(final BecomesBasicLandTargetEffect effect){
  super(effect);
  this.landTypes.addAll(effect.landTypes);
  this.chooseLandType=effect.chooseLandType;
  this.loseOther=effect.loseOther;
}","public BecomesBasicLandTargetEffect(final BecomesBasicLandTargetEffect effect){
  super(effect);
  this.landTypes.addAll(effect.landTypes);
  this.landTypesToAdd.addAll(effect.landTypesToAdd);
  this.chooseLandType=effect.chooseLandType;
  this.loseOther=effect.loseOther;
}",0.8929292929292929
158327,"@Override public boolean apply(Layer layer,SubLayer sublayer,Ability source,Game game){
  for (  UUID targetPermanent : targetPointer.getTargets(game,source)) {
    Permanent land=game.getPermanent(targetPermanent);
    if (land != null) {
switch (layer) {
case TypeChangingEffects_4:
        if (!land.getCardType().contains(CardType.LAND)) {
          land.getCardType().add(CardType.LAND);
        }
      land.removeAllAbilities(source.getSourceId(),game);
    land.getSubtype(game).removeAll(CardRepository.instance.getLandTypes());
  land.getSubtype(game).addAll(landTypes);
break;
case AbilityAddingRemovingEffects_6:
for (String landType : landTypes) {
switch (landType) {
case ""String_Node_Str"":
  land.addAbility(new BlackManaAbility(),source.getSourceId(),game);
break;
case ""String_Node_Str"":
land.addAbility(new RedManaAbility(),source.getSourceId(),game);
break;
case ""String_Node_Str"":
land.addAbility(new GreenManaAbility(),source.getSourceId(),game);
break;
case ""String_Node_Str"":
land.addAbility(new BlueManaAbility(),source.getSourceId(),game);
break;
case ""String_Node_Str"":
land.addAbility(new WhiteManaAbility(),source.getSourceId(),game);
break;
}
}
break;
}
}
}
return true;
}","@Override public boolean apply(Layer layer,SubLayer sublayer,Ability source,Game game){
  for (  UUID targetPermanent : targetPointer.getTargets(game,source)) {
    Permanent land=game.getPermanent(targetPermanent);
    if (land != null) {
switch (layer) {
case TypeChangingEffects_4:
        if (!land.getCardType().contains(CardType.LAND)) {
          land.getCardType().add(CardType.LAND);
        }
      if (loseOther) {
        land.removeAllAbilities(source.getSourceId(),game);
        land.getSubtype(game).removeAll(CardRepository.instance.getLandTypes());
        land.getSubtype(game).addAll(landTypes);
      }
 else {
        landTypesToAdd.clear();
        for (        String subtype : landTypes) {
          if (!land.getSubtype(game).contains(subtype)) {
            land.getSubtype(game).add(subtype);
            landTypesToAdd.add(subtype);
          }
        }
      }
    break;
case AbilityAddingRemovingEffects_6:
  for (  String landType : landTypesToAdd) {
switch (landType) {
case ""String_Node_Str"":
      land.addAbility(new BlackManaAbility(),source.getSourceId(),game);
    break;
case ""String_Node_Str"":
  land.addAbility(new RedManaAbility(),source.getSourceId(),game);
break;
case ""String_Node_Str"":
land.addAbility(new GreenManaAbility(),source.getSourceId(),game);
break;
case ""String_Node_Str"":
land.addAbility(new BlueManaAbility(),source.getSourceId(),game);
break;
case ""String_Node_Str"":
land.addAbility(new WhiteManaAbility(),source.getSourceId(),game);
break;
}
}
break;
}
}
}
return true;
}",0.847953216374269
158328,"public String saveDeck(Deck deck){
  try {
    String tempDir=System.getProperty(""String_Node_Str"");
    String deckName=""String_Node_Str"" + dateFormat.format(new Date());
    File tmp=new File(tempDir + File.separator + deckName+ ""String_Node_Str"");
    tmp.createNewFile();
    deck.setName(deckName);
    Sets.saveDeck(tmp.getAbsolutePath(),deck.getDeckCardLists());
    cleanUp();
    return tmp.getAbsolutePath();
  }
 catch (  Exception e) {
    JOptionPane.showMessageDialog(null,""String_Node_Str"");
  }
  return null;
}","public String saveDeck(Deck deck){
  try {
    String tempDir=System.getProperty(""String_Node_Str"");
    String deckName=""String_Node_Str"" + dateFormat.format(new Date());
    File tmp=new File(tempDir + File.separator + deckName+ ""String_Node_Str"");
    tmp.createNewFile();
    deck.setName(deckName);
    Sets.saveDeck(tmp.getAbsolutePath(),deck.getDeckCardLists());
    cleanUp();
    return tmp.getAbsolutePath();
  }
 catch (  Exception e) {
    MageFrame.getInstance().showError(""String_Node_Str"");
  }
  return null;
}",0.8717948717948718
158329,"private static boolean loadSymbolsImages(int size){
  boolean fileErrors=false;
  HashMap<String,BufferedImage> sizedSymbols=new HashMap<>();
  String resourcePath=Constants.RESOURCE_PATH_MANA_SMALL;
  if (size > 25) {
    resourcePath=Constants.RESOURCE_PATH_MANA_LARGE;
  }
 else   if (size > 15) {
    resourcePath=Constants.RESOURCE_PATH_MANA_MEDIUM;
  }
  for (  String symbol : symbols) {
    File file=new File(getSymbolsPath() + resourcePath + ""String_Node_Str""+ symbol+ ""String_Node_Str"");
    try {
      if (size == 15 || size == 25) {
        BufferedImage notResized=ImageIO.read(file);
        sizedSymbols.put(symbol,notResized);
      }
 else {
        Rectangle r=new Rectangle(size,size);
        BufferedImage image=ImageIO.read(file);
        BufferedImage resized=ImageHelper.getResizedImage(image,r);
        sizedSymbols.put(symbol,resized);
      }
    }
 catch (    IOException e) {
      LOGGER.error(""String_Node_Str"" + symbol);
      fileErrors=true;
    }
  }
  manaImages.put(size,sizedSymbols);
  return !fileErrors;
}","private static boolean loadSymbolsImages(int size){
  boolean fileErrors=false;
  HashMap<String,BufferedImage> sizedSymbols=new HashMap<>();
  String resourcePath=Constants.RESOURCE_PATH_MANA_SMALL;
  if (size > 25) {
    resourcePath=Constants.RESOURCE_PATH_MANA_LARGE;
  }
 else   if (size > 15) {
    resourcePath=Constants.RESOURCE_PATH_MANA_MEDIUM;
  }
  for (  String symbol : symbols) {
    File file=new File(getSymbolsPath() + resourcePath + ""String_Node_Str""+ symbol+ ""String_Node_Str"");
    try {
      if (size == 15 || size == 25) {
        BufferedImage notResized=ImageIO.read(file);
        sizedSymbols.put(symbol,notResized);
      }
 else {
        Rectangle r=new Rectangle(size,size);
        BufferedImage image=ImageIO.read(file);
        if (image != null) {
          BufferedImage resized=ImageHelper.getResizedImage(image,r);
          sizedSymbols.put(symbol,resized);
        }
      }
    }
 catch (    IOException e) {
      LOGGER.error(""String_Node_Str"" + symbol);
      fileErrors=true;
    }
  }
  manaImages.put(size,sizedSymbols);
  return !fileErrors;
}",0.979915927136852
158330,"public void addSet(ExpansionSet set){
  if (containsKey(set.getCode()))   throw new IllegalArgumentException(""String_Node_Str"" + set.getCode() + ""String_Node_Str"");
  this.put(set.getCode(),set);
  if (set.isCustomSet())   customSets.add(set.getCode());
}","public void addSet(ExpansionSet set){
  if (containsKey(set.getCode())) {
    throw new IllegalArgumentException(""String_Node_Str"" + set.getCode() + ""String_Node_Str"");
  }
  this.put(set.getCode(),set);
  if (set.isCustomSet()) {
    customSets.add(set.getCode());
  }
}",0.9695817490494296
158331,"private static void writeCardLayout(PrintWriter out,DeckCardLayout layout){
  List<List<List<DeckCardInfo>>> cardGrid=layout.getCards();
  int height=cardGrid.size();
  int width=(height > 0) ? cardGrid.get(0).size() : 0;
  out.print(""String_Node_Str"" + height + ""String_Node_Str""+ width+ ""String_Node_Str"");
  out.print(layout.getSettings());
  out.print(""String_Node_Str"");
  for (  List<List<DeckCardInfo>> row : cardGrid) {
    for (    List<DeckCardInfo> stack : row) {
      out.print(""String_Node_Str"");
      for (int i=0; i < stack.size(); ++i) {
        DeckCardInfo info=stack.get(i);
        out.printf(""String_Node_Str"",info.getSetCode(),info.getCardNum());
        if (i != stack.size() - 1) {
          out.print(""String_Node_Str"");
        }
      }
      out.print(""String_Node_Str"");
    }
  }
}","private static void writeCardLayout(PrintWriter out,DeckCardLayout layout){
  if (layout == null) {
    return;
  }
  List<List<List<DeckCardInfo>>> cardGrid=layout.getCards();
  int height=cardGrid.size();
  int width=(height > 0) ? cardGrid.get(0).size() : 0;
  out.print(""String_Node_Str"" + height + ""String_Node_Str""+ width+ ""String_Node_Str"");
  out.print(layout.getSettings());
  out.print(""String_Node_Str"");
  for (  List<List<DeckCardInfo>> row : cardGrid) {
    for (    List<DeckCardInfo> stack : row) {
      out.print(""String_Node_Str"");
      for (int i=0; i < stack.size(); ++i) {
        DeckCardInfo info=stack.get(i);
        out.printf(""String_Node_Str"",info.getSetCode(),info.getCardNum());
        if (i != stack.size() - 1) {
          out.print(""String_Node_Str"");
        }
      }
      out.print(""String_Node_Str"");
    }
  }
}",0.9759903961584634
158332,"@Override public String getText(Mode mode){
  if (staticText != null && !staticText.isEmpty()) {
    return staticText;
  }
  Target target=mode.getTargets().get(0);
  StringBuilder sb=new StringBuilder();
  sb.append(""String_Node_Str"");
  if (target.getNumberOfTargets() == 0) {
    sb.append(""String_Node_Str"");
  }
  if (target.getMaxNumberOfTargets() > 1 || target.getNumberOfTargets() == 0) {
    sb.append(target.getMaxNumberOfTargets()).append(""String_Node_Str"").append(target.getTargetName()).append(""String_Node_Str"");
  }
 else {
    if (!target.getTargetName().startsWith(""String_Node_Str"")) {
      sb.append(""String_Node_Str"");
    }
    sb.append(target.getTargetName());
  }
  return sb.toString();
}","@Override public String getText(Mode mode){
  if (staticText != null && !staticText.isEmpty()) {
    return staticText;
  }
  Target target=mode.getTargets().get(0);
  StringBuilder sb=new StringBuilder();
  sb.append(""String_Node_Str"");
  if (target.getNumberOfTargets() == 0) {
    sb.append(""String_Node_Str"");
  }
  if (target.getMaxNumberOfTargets() > 1 || target.getNumberOfTargets() == 0) {
    sb.append(CardUtil.numberToText(target.getMaxNumberOfTargets())).append(""String_Node_Str"").append(target.getTargetName()).append(""String_Node_Str"");
  }
 else {
    if (!target.getTargetName().startsWith(""String_Node_Str"")) {
      sb.append(""String_Node_Str"");
    }
    sb.append(target.getTargetName());
  }
  return sb.toString();
}",0.9841706813489332
158333,"@Override public boolean canAttack(Game game){
  return true;
}","@Override public boolean canAttack(Game game){
  Ability source=(Ability)getValue(""String_Node_Str"");
  return game.getBattlefield().count(filter,source.getSourceId(),source.getControllerId(),game) > 0 || HateCondition.getInstance().apply(game,source);
}",0.3280757097791798
158334,"@Override public boolean applies(Permanent permanent,Ability source,Game game){
  if (permanent.getId().equals(source.getSourceId())) {
    LifeLossOtherFromCombatWatcher watcher=(LifeLossOtherFromCombatWatcher)game.getState().getWatchers().get(""String_Node_Str"");
    return watcher != null && watcher.opponentLostLifeOtherFromCombat(source.getControllerId());
  }
  return false;
}","@Override public boolean applies(Permanent permanent,Ability source,Game game){
  if (permanent.getId().equals(source.getSourceId())) {
    setValue(""String_Node_Str"",source);
    return true;
  }
  return false;
}",0.5896147403685092
158335,"@Override public boolean canBlock(Permanent attacker,Permanent blocker,Ability source,Game game){
  return false;
}","@Override public boolean canBlock(Permanent attacker,Permanent blocker,Ability source,Game game){
  return game.getBattlefield().count(filter,source.getSourceId(),source.getControllerId(),game) > 0;
}",0.7111111111111111
158336,"@Override public Terentatek2RestrictionEffect copy(){
  return new Terentatek2RestrictionEffect(this);
}","@Override public Terentatek1RestrictionEffect copy(){
  return new Terentatek1RestrictionEffect(this);
}",0.9807692307692308
158337,"@Override public boolean apply(Game game,Ability source){
  LifeLossOtherFromCombatWatcher watcher=(LifeLossOtherFromCombatWatcher)game.getState().getWatchers().get(LifeLossOtherFromCombatWatcher.class.getName());
  return watcher != null && watcher.opponentLostLifeOtherFromCombat(source.getControllerId());
}","@Override public boolean apply(Game game,Ability source){
  LifeLossOtherFromCombatWatcher watcher=(LifeLossOtherFromCombatWatcher)game.getState().getWatchers().get(LifeLossOtherFromCombatWatcher.class.getName());
  return watcher != null && watcher.opponentLostLifeOtherFromCombat(source.getControllerId(),game);
}",0.992
158338,"@Override public boolean pay(Ability ability,Game game,UUID sourceId,UUID controllerId,boolean noMana,Cost costToPay){
  this.cards.clear();
  this.targets.clearChosen();
  Player player=game.getPlayer(controllerId);
  if (player == null) {
    return false;
  }
  int amount=this.getTargets().get(0).getNumberOfTargets();
  if (randomDiscard) {
    this.cards.addAll(player.discard(amount,true,ability,game).getCards(game));
  }
 else {
    if (targets.choose(Outcome.Discard,controllerId,sourceId,game)) {
      for (      UUID targetId : targets.get(0).getTargets()) {
        Card card=player.getHand().get(targetId,game);
        if (card == null) {
          return false;
        }
        player.discard(card,ability,game);
        this.cards.add(card);
      }
    }
  }
  paid=cards.size() >= amount;
  return paid;
}","@Override public boolean pay(Ability ability,Game game,UUID sourceId,UUID controllerId,boolean noMana,Cost costToPay){
  this.cards.clear();
  this.targets.clearChosen();
  Player player=game.getPlayer(controllerId);
  if (player == null) {
    return false;
  }
  int amount=this.getTargets().get(0).getNumberOfTargets();
  if (randomDiscard) {
    this.cards.addAll(player.discard(amount,true,ability,game).getCards(game));
  }
 else   if (targets.choose(Outcome.Discard,controllerId,sourceId,game)) {
    for (    UUID targetId : targets.get(0).getTargets()) {
      Card card=player.getHand().get(targetId,game);
      if (card == null) {
        return false;
      }
      player.discard(card,ability,game);
      this.cards.add(card);
    }
  }
  paid=cards.size() >= amount;
  return paid;
}",0.8425584255842559
158339,"public boolean opponentLostLifeOtherFromCombat(UUID playerId){
  return (!players.contains(playerId) && players.size() > 0) || (players.contains(playerId) && players.size() > 1);
}","public boolean opponentLostLifeOtherFromCombat(UUID playerId,Game game){
  Player player=game.getPlayer(playerId);
  if (player != null) {
    if (players.stream().anyMatch((damagedPlayerId) -> (player.hasOpponent(damagedPlayerId,game)))) {
      return true;
    }
  }
  return false;
}",0.3083511777301927
158340,"@Override public boolean applies(GameEvent event,Ability source,Game game){
  Permanent permanent=game.getPermanent(event.getTargetId());
  if (permanent != null && filterTarget.match(permanent,source.getSourceId(),source.getControllerId(),game)) {
    StackObject stackObject=game.getStack().getStackObject(event.getSourceId());
    MageObject sourceObject;
    if (stackObject instanceof StackAbility) {
      sourceObject=((StackAbility)stackObject).getSourceObject(game);
    }
 else {
      sourceObject=stackObject;
    }
    if (sourceObject != null && filterSource.match(sourceObject,game)) {
      return true;
    }
  }
  return false;
}","@Override public boolean applies(GameEvent event,Ability source,Game game){
  Permanent permanent=game.getPermanent(event.getTargetId());
  if (permanent != null && filterTarget.match(permanent,source.getSourceId(),source.getControllerId(),game)) {
    StackObject stackObject=game.getStack().getStackObject(event.getSourceId());
    MageObject sourceObject;
    if (stackObject instanceof StackAbility) {
      if (filterSource instanceof FilterSpell) {
        return false;
      }
      sourceObject=((StackAbility)stackObject).getSourceObject(game);
    }
 else {
      sourceObject=stackObject;
    }
    if (sourceObject != null && filterSource.match(sourceObject,game)) {
      return true;
    }
  }
  return false;
}",0.942461762563729
158341,"@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller != null) {
    FilterCard filter=new FilterCard();
    filter.add(new ConvertedManaCostPredicate(Filter.ComparisonType.Equal,source.getManaCostsToPay().getX()));
    TargetCardInExile target=new TargetCardInExile(filter,CardUtil.getCardExileZoneId(game,source));
    Cards cards=game.getExile().getExileZone(CardUtil.getCardExileZoneId(game,source));
    if (cards.size() > 0 && controller.choose(Outcome.PlayForFree,cards,target,game)) {
      Card card=game.getCard(target.getFirstTarget());
      if (card != null) {
        game.getExile().removeCard(card,game);
        controller.cast(card.getSpellAbility(),game,true);
      }
    }
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller != null) {
    FilterCard filter=new FilterCard();
    filter.add(new ConvertedManaCostPredicate(Filter.ComparisonType.Equal,source.getManaCostsToPay().getX()));
    TargetCardInExile target=new TargetCardInExile(filter,CardUtil.getCardExileZoneId(game,source));
    Cards cards=game.getExile().getExileZone(CardUtil.getCardExileZoneId(game,source));
    if (cards.size() > 0 && controller.choose(Outcome.PlayForFree,cards,target,game)) {
      Card card=game.getCard(target.getFirstTarget());
      if (card != null) {
        controller.cast(card.getSpellAbility(),game,true);
      }
    }
    return true;
  }
  return false;
}",0.9703095388502844
158342,"private static void buildLists(){
  final Map<String,ExpansionInfo> expansionInfo=new HashMap<>();
  formats.clear();
  for (  ExpansionInfo set : ExpansionRepository.instance.getAll()) {
    expansionInfo.put(set.getName(),set);
    formats.add(set.getName());
    if (set.getType().equals(SetType.CORE) || set.getType().equals(SetType.EXPANSION) || set.getType().equals(SetType.SUPPLEMENTAL_STANDARD_LEGAL)) {
      if (STANDARD_CARDS.getSetCodes().contains(set.getCode())) {
        if (underlyingSetCodesPerFormat.get(STANDARD) == null) {
          underlyingSetCodesPerFormat.put(STANDARD,new ArrayList<>());
        }
        underlyingSetCodesPerFormat.get(STANDARD).add(set.getCode());
      }
      if (set.getReleaseDate().after(extendedDate)) {
        if (underlyingSetCodesPerFormat.get(EXTENDED) == null) {
          underlyingSetCodesPerFormat.put(EXTENDED,new ArrayList<>());
        }
        underlyingSetCodesPerFormat.get(EXTENDED).add(set.getCode());
      }
      if (set.getReleaseDate().after(frontierDate)) {
        if (underlyingSetCodesPerFormat.get(FRONTIER) == null) {
          underlyingSetCodesPerFormat.put(FRONTIER,new ArrayList<>());
        }
        underlyingSetCodesPerFormat.get(FRONTIER).add(set.getCode());
      }
      if (set.getReleaseDate().after(modernDate)) {
        if (underlyingSetCodesPerFormat.get(MODERN) == null) {
          underlyingSetCodesPerFormat.put(MODERN,new ArrayList<>());
        }
        underlyingSetCodesPerFormat.get(MODERN).add(set.getCode());
      }
    }
    if (underlyingSetCodesPerFormat.get(set.getName()) == null) {
      underlyingSetCodesPerFormat.put(set.getName(),new ArrayList<>());
    }
    underlyingSetCodesPerFormat.get(set.getName()).add(set.getCode());
    if (set.getType().equals(SetType.EXPANSION) && set.getBlockName() != null) {
      String blockDisplayName=getBlockDisplayName(set.getBlockName());
      if (underlyingSetCodesPerFormat.get(blockDisplayName) == null) {
        underlyingSetCodesPerFormat.put(blockDisplayName,new ArrayList<>());
      }
      underlyingSetCodesPerFormat.get(blockDisplayName).add(set.getCode());
      if (expansionInfo.get(blockDisplayName) == null) {
        expansionInfo.put(blockDisplayName,set);
        formats.add(blockDisplayName);
      }
      if (expansionInfo.get(blockDisplayName).getReleaseDate().after(set.getReleaseDate())) {
        expansionInfo.put(blockDisplayName,set);
      }
    }
    if (set.getType().equals(SetType.SUPPLEMENTAL) && set.getBlockName() != null) {
      if (expansionInfo.get(set.getBlockName()) == null) {
        expansionInfo.put(set.getBlockName(),set);
      }
      if (expansionInfo.get(set.getBlockName()).getReleaseDate().before(set.getReleaseDate())) {
        expansionInfo.put(set.getBlockName(),set);
      }
    }
  }
  Collections.sort(formats,new Comparator<String>(){
    @Override public int compare(    String name1,    String name2){
      ExpansionInfo expansionInfo1=expansionInfo.get(name1);
      ExpansionInfo expansionInfo2=expansionInfo.get(name2);
      if (expansionInfo1.getType().compareTo(expansionInfo2.getType()) == 0) {
        SetType setType=expansionInfo1.getType();
switch (setType) {
case EXPANSION:
          if (expansionInfo1.getBlockName() == null) {
            if (expansionInfo2.getBlockName() == null) {
              return expansionInfo2.getReleaseDate().compareTo(expansionInfo1.getReleaseDate());
            }
            return 1;
          }
        if (expansionInfo2.getBlockName() == null) {
          return -1;
        }
      if (name1.endsWith(""String_Node_Str"") && name2.endsWith(""String_Node_Str"")) {
        return expansionInfo2.getReleaseDate().compareTo(expansionInfo1.getReleaseDate());
      }
    if (name1.endsWith(""String_Node_Str"")) {
      if (expansionInfo1.getBlockName().equals(expansionInfo2.getBlockName())) {
        return -1;
      }
    }
  if (name2.endsWith(""String_Node_Str"")) {
    if (expansionInfo1.getBlockName().equals(expansionInfo2.getBlockName())) {
      return 1;
    }
  }
return expansionInfo2.getReleaseDate().compareTo(expansionInfo1.getReleaseDate());
case SUPPLEMENTAL:
if (expansionInfo1.getBlockName() == null) {
if (expansionInfo2.getBlockName() == null) {
  return expansionInfo2.getReleaseDate().compareTo(expansionInfo1.getReleaseDate());
}
return -1;
}
if (expansionInfo2.getBlockName() == null) {
return 1;
}
if (expansionInfo1.getBlockName().equals(expansionInfo2.getBlockName())) {
if (expansionInfo2.getReleaseDate().compareTo(expansionInfo1.getReleaseDate()) == 0) {
return name1.compareTo(name2);
}
return expansionInfo2.getReleaseDate().compareTo(expansionInfo1.getReleaseDate());
}
if (expansionInfo1.getBlockName().startsWith(""String_Node_Str"")) {
if (expansionInfo1.getBlockName().startsWith(""String_Node_Str"")) {
return 1;
}
return 1;
}
if (expansionInfo2.getBlockName().startsWith(""String_Node_Str"")) {
return -1;
}
ExpansionInfo blockInfo1=expansionInfo.get(expansionInfo1.getBlockName());
ExpansionInfo blockInfo2=expansionInfo.get(expansionInfo2.getBlockName());
return blockInfo2.getReleaseDate().compareTo(blockInfo1.getReleaseDate());
default :
return expansionInfo2.getReleaseDate().compareTo(expansionInfo1.getReleaseDate());
}
}
return expansionInfo1.getType().compareTo(expansionInfo2.getType());
}
}
);
if (!formats.isEmpty()) {
formats.add(0,MODERN);
formats.add(0,FRONTIER);
formats.add(0,EXTENDED);
formats.add(0,STANDARD);
}
formats.add(0,ALL);
}","private static void buildLists(){
  underlyingSetCodesPerFormat.put(STANDARD,new ArrayList<>());
  underlyingSetCodesPerFormat.put(EXTENDED,new ArrayList<>());
  underlyingSetCodesPerFormat.put(FRONTIER,new ArrayList<>());
  underlyingSetCodesPerFormat.put(MODERN,new ArrayList<>());
  underlyingSetCodesPerFormat.put(VINTAGE_LEGACY,new ArrayList<>());
  underlyingSetCodesPerFormat.put(CUSTOM,new ArrayList<>());
  final Map<String,ExpansionInfo> expansionInfo=new HashMap<>();
  formats.clear();
  for (  ExpansionInfo set : ExpansionRepository.instance.getAll()) {
    expansionInfo.put(set.getName(),set);
    formats.add(set.getName());
    underlyingSetCodesPerFormat.put(set.getName(),new ArrayList<>());
    underlyingSetCodesPerFormat.get(set.getName()).add(set.getCode());
    if (set.getType().equals(SetType.CUSTOM_SET)) {
      underlyingSetCodesPerFormat.get(CUSTOM).add(set.getCode());
      continue;
    }
    underlyingSetCodesPerFormat.get(VINTAGE_LEGACY).add(set.getCode());
    if (set.getType().equals(SetType.CORE) || set.getType().equals(SetType.EXPANSION) || set.getType().equals(SetType.SUPPLEMENTAL_STANDARD_LEGAL)) {
      if (STANDARD_CARDS.getSetCodes().contains(set.getCode())) {
        underlyingSetCodesPerFormat.get(STANDARD).add(set.getCode());
      }
      if (set.getReleaseDate().after(extendedDate)) {
        underlyingSetCodesPerFormat.get(EXTENDED).add(set.getCode());
      }
      if (set.getReleaseDate().after(frontierDate)) {
        underlyingSetCodesPerFormat.get(FRONTIER).add(set.getCode());
      }
      if (set.getReleaseDate().after(modernDate)) {
        underlyingSetCodesPerFormat.get(MODERN).add(set.getCode());
      }
    }
    if (set.getType().equals(SetType.EXPANSION) && set.getBlockName() != null) {
      String blockDisplayName=getBlockDisplayName(set.getBlockName());
      if (underlyingSetCodesPerFormat.get(blockDisplayName) == null) {
        underlyingSetCodesPerFormat.put(blockDisplayName,new ArrayList<>());
      }
      underlyingSetCodesPerFormat.get(blockDisplayName).add(set.getCode());
      if (expansionInfo.get(blockDisplayName) == null) {
        expansionInfo.put(blockDisplayName,set);
        formats.add(blockDisplayName);
      }
      if (expansionInfo.get(blockDisplayName).getReleaseDate().after(set.getReleaseDate())) {
        expansionInfo.put(blockDisplayName,set);
      }
    }
    if (set.getType().equals(SetType.SUPPLEMENTAL) && set.getBlockName() != null) {
      if (expansionInfo.get(set.getBlockName()) == null) {
        expansionInfo.put(set.getBlockName(),set);
      }
      if (expansionInfo.get(set.getBlockName()).getReleaseDate().before(set.getReleaseDate())) {
        expansionInfo.put(set.getBlockName(),set);
      }
    }
  }
  Collections.sort(formats,new Comparator<String>(){
    @Override public int compare(    String name1,    String name2){
      ExpansionInfo expansionInfo1=expansionInfo.get(name1);
      ExpansionInfo expansionInfo2=expansionInfo.get(name2);
      if (expansionInfo1.getType().compareTo(expansionInfo2.getType()) == 0) {
        SetType setType=expansionInfo1.getType();
switch (setType) {
case EXPANSION:
          if (expansionInfo1.getBlockName() == null) {
            if (expansionInfo2.getBlockName() == null) {
              return expansionInfo2.getReleaseDate().compareTo(expansionInfo1.getReleaseDate());
            }
            return 1;
          }
        if (expansionInfo2.getBlockName() == null) {
          return -1;
        }
      if (name1.endsWith(""String_Node_Str"") && name2.endsWith(""String_Node_Str"")) {
        return expansionInfo2.getReleaseDate().compareTo(expansionInfo1.getReleaseDate());
      }
    if (name1.endsWith(""String_Node_Str"")) {
      if (expansionInfo1.getBlockName().equals(expansionInfo2.getBlockName())) {
        return -1;
      }
    }
  if (name2.endsWith(""String_Node_Str"")) {
    if (expansionInfo1.getBlockName().equals(expansionInfo2.getBlockName())) {
      return 1;
    }
  }
return expansionInfo2.getReleaseDate().compareTo(expansionInfo1.getReleaseDate());
case SUPPLEMENTAL:
if (expansionInfo1.getBlockName() == null) {
if (expansionInfo2.getBlockName() == null) {
  return expansionInfo2.getReleaseDate().compareTo(expansionInfo1.getReleaseDate());
}
return -1;
}
if (expansionInfo2.getBlockName() == null) {
return 1;
}
if (expansionInfo1.getBlockName().equals(expansionInfo2.getBlockName())) {
if (expansionInfo2.getReleaseDate().compareTo(expansionInfo1.getReleaseDate()) == 0) {
return name1.compareTo(name2);
}
return expansionInfo2.getReleaseDate().compareTo(expansionInfo1.getReleaseDate());
}
if (expansionInfo1.getBlockName().startsWith(""String_Node_Str"")) {
if (expansionInfo1.getBlockName().startsWith(""String_Node_Str"")) {
return 1;
}
return 1;
}
if (expansionInfo2.getBlockName().startsWith(""String_Node_Str"")) {
return -1;
}
ExpansionInfo blockInfo1=expansionInfo.get(expansionInfo1.getBlockName());
ExpansionInfo blockInfo2=expansionInfo.get(expansionInfo2.getBlockName());
return blockInfo2.getReleaseDate().compareTo(blockInfo1.getReleaseDate());
default :
return expansionInfo2.getReleaseDate().compareTo(expansionInfo1.getReleaseDate());
}
}
return expansionInfo1.getType().compareTo(expansionInfo2.getType());
}
}
);
if (!formats.isEmpty()) {
formats.add(0,CUSTOM);
formats.add(0,VINTAGE_LEGACY);
formats.add(0,MODERN);
formats.add(0,EXTENDED);
formats.add(0,FRONTIER);
formats.add(0,STANDARD);
}
formats.add(0,ALL);
}",0.8021253206302675
158343,"public static void ensureLists(){
  if (getSetsByFormat(ConstructedFormats.STANDARD) == null) {
    buildLists();
  }
}","public static void ensureLists(){
  if (underlyingSetCodesPerFormat.isEmpty()) {
    buildLists();
  }
}",0.7174887892376681
158344,"public Legacy(){
  super(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
}","public Legacy(){
  super(""String_Node_Str"");
  for (  ExpansionSet set : Sets.getInstance().values()) {
    if (set.getSetType() != SetType.CUSTOM_SET) {
      setCodes.add(set.getCode());
    }
  }
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
}",0.0189573459715639
158345,"public Vintage(){
  super(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  restricted.add(""String_Node_Str"");
  restricted.add(""String_Node_Str"");
  restricted.add(""String_Node_Str"");
  restricted.add(""String_Node_Str"");
  restricted.add(""String_Node_Str"");
  restricted.add(""String_Node_Str"");
  restricted.add(""String_Node_Str"");
  restricted.add(""String_Node_Str"");
  restricted.add(""String_Node_Str"");
  restricted.add(""String_Node_Str"");
  restricted.add(""String_Node_Str"");
  restricted.add(""String_Node_Str"");
  restricted.add(""String_Node_Str"");
  restricted.add(""String_Node_Str"");
  restricted.add(""String_Node_Str"");
  restricted.add(""String_Node_Str"");
  restricted.add(""String_Node_Str"");
  restricted.add(""String_Node_Str"");
  restricted.add(""String_Node_Str"");
  restricted.add(""String_Node_Str"");
  restricted.add(""String_Node_Str"");
  restricted.add(""String_Node_Str"");
  restricted.add(""String_Node_Str"");
  restricted.add(""String_Node_Str"");
  restricted.add(""String_Node_Str"");
  restricted.add(""String_Node_Str"");
  restricted.add(""String_Node_Str"");
  restricted.add(""String_Node_Str"");
  restricted.add(""String_Node_Str"");
  restricted.add(""String_Node_Str"");
  restricted.add(""String_Node_Str"");
  restricted.add(""String_Node_Str"");
  restricted.add(""String_Node_Str"");
  restricted.add(""String_Node_Str"");
  restricted.add(""String_Node_Str"");
  restricted.add(""String_Node_Str"");
  restricted.add(""String_Node_Str"");
  restricted.add(""String_Node_Str"");
  restricted.add(""String_Node_Str"");
  restricted.add(""String_Node_Str"");
  restricted.add(""String_Node_Str"");
  restricted.add(""String_Node_Str"");
  restricted.add(""String_Node_Str"");
}","public Vintage(){
  super(""String_Node_Str"");
  for (  ExpansionSet set : Sets.getInstance().values()) {
    if (set.getSetType() != SetType.CUSTOM_SET) {
      setCodes.add(set.getCode());
    }
  }
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  banned.add(""String_Node_Str"");
  restricted.add(""String_Node_Str"");
  restricted.add(""String_Node_Str"");
  restricted.add(""String_Node_Str"");
  restricted.add(""String_Node_Str"");
  restricted.add(""String_Node_Str"");
  restricted.add(""String_Node_Str"");
  restricted.add(""String_Node_Str"");
  restricted.add(""String_Node_Str"");
  restricted.add(""String_Node_Str"");
  restricted.add(""String_Node_Str"");
  restricted.add(""String_Node_Str"");
  restricted.add(""String_Node_Str"");
  restricted.add(""String_Node_Str"");
  restricted.add(""String_Node_Str"");
  restricted.add(""String_Node_Str"");
  restricted.add(""String_Node_Str"");
  restricted.add(""String_Node_Str"");
  restricted.add(""String_Node_Str"");
  restricted.add(""String_Node_Str"");
  restricted.add(""String_Node_Str"");
  restricted.add(""String_Node_Str"");
  restricted.add(""String_Node_Str"");
  restricted.add(""String_Node_Str"");
  restricted.add(""String_Node_Str"");
  restricted.add(""String_Node_Str"");
  restricted.add(""String_Node_Str"");
  restricted.add(""String_Node_Str"");
  restricted.add(""String_Node_Str"");
  restricted.add(""String_Node_Str"");
  restricted.add(""String_Node_Str"");
  restricted.add(""String_Node_Str"");
  restricted.add(""String_Node_Str"");
  restricted.add(""String_Node_Str"");
  restricted.add(""String_Node_Str"");
  restricted.add(""String_Node_Str"");
  restricted.add(""String_Node_Str"");
  restricted.add(""String_Node_Str"");
  restricted.add(""String_Node_Str"");
  restricted.add(""String_Node_Str"");
  restricted.add(""String_Node_Str"");
  restricted.add(""String_Node_Str"");
  restricted.add(""String_Node_Str"");
  restricted.add(""String_Node_Str"");
}",0.9696850393700788
158346,"public void userLostConnection(){
  boolean lockSet=false;
  try {
    if (lock.tryLock(5000,TimeUnit.MILLISECONDS)) {
      lockSet=true;
      logger.debug(""String_Node_Str"" + sessionId);
    }
 else {
      logger.error(""String_Node_Str"" + userId);
    }
    User user=UserManager.getInstance().getUser(userId);
    if (user == null || !user.isConnected()) {
      return;
    }
    if (!user.getSessionId().equals(sessionId)) {
      logger.info(""String_Node_Str"" + user.getName());
      return;
    }
    UserManager.getInstance().disconnect(userId,DisconnectReason.LostConnection);
  }
 catch (  InterruptedException ex) {
    logger.error(""String_Node_Str"" + userId,ex);
  }
 finally {
    if (lockSet) {
      lock.unlock();
      logger.trace(""String_Node_Str"" + sessionId);
    }
  }
}","public void userLostConnection(){
  boolean lockSet=false;
  try {
    if (lock.tryLock(5000,TimeUnit.MILLISECONDS)) {
      lockSet=true;
      logger.debug(""String_Node_Str"" + sessionId);
    }
 else {
      logger.error(""String_Node_Str"" + userId + ""String_Node_Str""+ lock.getHoldCount());
    }
    User user=UserManager.getInstance().getUser(userId);
    if (user == null || !user.isConnected()) {
      return;
    }
    if (!user.getSessionId().equals(sessionId)) {
      logger.info(""String_Node_Str"" + user.getName());
      return;
    }
    UserManager.getInstance().disconnect(userId,DisconnectReason.LostConnection);
  }
 catch (  InterruptedException ex) {
    logger.error(""String_Node_Str"" + userId,ex);
  }
 finally {
    if (lockSet) {
      lock.unlock();
      logger.trace(""String_Node_Str"" + sessionId);
    }
  }
}",0.9748928352725046
158347,"@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller != null) {
    Mana parley=getMana(game,source);
    if (parley.getAny() > 0) {
      controller.getManaPool().addMana(parley,game,source);
      controller.gainLife(parley.getAny(),game);
    }
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller != null) {
    Mana parley=getMana(game,source);
    if (parley.getGreen() > 0) {
      controller.getManaPool().addMana(parley,game,source);
      controller.gainLife(parley.getAny(),game);
    }
    return true;
  }
  return false;
}",0.9892183288409704
158348,"/** 
 * Add a card to the cardGrid, in the position that the current sort dictates
 * @param newCard
 */
private void sortIntoGrid(CardView newCard){
  if (cardGrid.size() == 0) {
    cardGrid.add(0,new ArrayList<ArrayList<CardView>>());
    maxStackSize.add(0,0);
  }
  ArrayList<ArrayList<CardView>> targetRow;
  if (separateCreatures && !newCard.getCardTypes().contains(CardType.CREATURE)) {
    if (cardGrid.size() < 2) {
      cardGrid.add(1,new ArrayList<ArrayList<CardView>>());
      maxStackSize.add(1,0);
      for (int i=0; i < cardGrid.get(0).size(); ++i) {
        cardGrid.get(1).add(new ArrayList<CardView>());
      }
    }
    targetRow=cardGrid.get(1);
  }
 else {
    targetRow=cardGrid.get(0);
  }
  boolean didInsert=false;
  for (int currentColumn=0; currentColumn < cardGrid.get(0).size(); ++currentColumn) {
    CardView cardInColumn=null;
    for (    ArrayList<ArrayList<CardView>> gridRow : cardGrid) {
      for (      CardView card : gridRow.get(currentColumn)) {
        cardInColumn=card;
        break;
      }
    }
    if (cardInColumn == null) {
      LOGGER.error(""String_Node_Str"");
    }
 else {
      int res=cardSort.getComparator().compare(newCard,cardInColumn);
      if (res <= 0) {
        if (res < 0) {
          for (int rowIndex=0; rowIndex < cardGrid.size(); ++rowIndex) {
            cardGrid.get(rowIndex).add(currentColumn,new ArrayList<CardView>());
          }
        }
        targetRow.get(currentColumn).add(newCard);
        didInsert=true;
        break;
      }
 else {
      }
    }
  }
  if (!didInsert) {
    for (int rowIndex=0; rowIndex < cardGrid.size(); ++rowIndex) {
      cardGrid.get(rowIndex).add(new ArrayList<CardView>());
    }
    targetRow.get(targetRow.size() - 1).add(newCard);
  }
}","/** 
 * Add a card to the cardGrid, in the position that the current sort dictates
 * @param newCard
 */
private void sortIntoGrid(CardView newCard){
  if (cardGrid.size() == 0) {
    cardGrid.add(0,new ArrayList<ArrayList<CardView>>());
    maxStackSize.add(0,0);
  }
  ArrayList<ArrayList<CardView>> targetRow;
  if (separateCreatures && !newCard.getCardTypes().contains(CardType.CREATURE)) {
    if (cardGrid.size() < 2) {
      cardGrid.add(1,new ArrayList<ArrayList<CardView>>());
      maxStackSize.add(1,0);
      for (int i=0; i < cardGrid.get(0).size(); ++i) {
        cardGrid.get(1).add(new ArrayList<CardView>());
      }
    }
    targetRow=cardGrid.get(1);
  }
 else {
    targetRow=cardGrid.get(0);
  }
  boolean didInsert=false;
  for (int currentColumn=0; currentColumn < cardGrid.get(0).size(); ++currentColumn) {
    CardView cardInColumn=null;
    for (    ArrayList<ArrayList<CardView>> gridRow : cardGrid) {
      for (      CardView card : gridRow.get(currentColumn)) {
        cardInColumn=card;
        break;
      }
    }
    if (cardInColumn == null) {
      LOGGER.error(""String_Node_Str"" + currentColumn);
    }
 else {
      int res=cardSort.getComparator().compare(newCard,cardInColumn);
      if (res <= 0) {
        if (res < 0) {
          for (int rowIndex=0; rowIndex < cardGrid.size(); ++rowIndex) {
            cardGrid.get(rowIndex).add(currentColumn,new ArrayList<CardView>());
          }
        }
        targetRow.get(currentColumn).add(newCard);
        didInsert=true;
        break;
      }
 else {
      }
    }
  }
  if (!didInsert) {
    for (int rowIndex=0; rowIndex < cardGrid.size(); ++rowIndex) {
      cardGrid.get(rowIndex).add(new ArrayList<CardView>());
    }
    targetRow.get(targetRow.size() - 1).add(newCard);
  }
}",0.9954802259887006
158349,"public static void main(String[] args){
  GUISizeHelper.calculateGUISizes();
  Plugins.getInstance().loadPlugins();
  JFrame frame=new JFrame();
  frame.setTitle(""String_Node_Str"");
  frame.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);
  frame.setBackground(Color.BLUE);
  DragCardGrid grid=new DragCardGrid();
  grid.setPreferredSize(new Dimension(800,600));
  frame.add(grid,BorderLayout.CENTER);
  frame.pack();
  frame.setVisible(true);
}","public static void main(String[] args){
  JFrame frame=new JFrame();
  try {
    UIManager.setLookAndFeel(""String_Node_Str"");
  }
 catch (  UnsupportedLookAndFeelException|ClassNotFoundException|IllegalAccessException|InstantiationException e) {
  }
  frame.setVisible(true);
  JFileChooser choose=new JFileChooser();
  choose.setAcceptAllFileFilterUsed(false);
  choose.addChoosableFileFilter(new DeckFilter());
  choose.showOpenDialog(frame);
  LOGGER.info(""String_Node_Str"" + choose.getSelectedFile());
  String st=""String_Node_Str"";
  try {
    st=choose.getSelectedFile().getCanonicalPath();
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  LOGGER.info(""String_Node_Str"" + st);
  choose.setSelectedFile(new File(st));
  choose.showOpenDialog(frame);
  LOGGER.info(""String_Node_Str"" + choose.getSelectedFile());
  frame.setVisible(false);
}",0.1345565749235474
158350,"public void setCards(CardsView cardsView,BigCard bigCard){
  if (bigCard != null) {
    lastBigCard=bigCard;
  }
  boolean didModify=false;
  for (int i=0; i < cardGrid.size(); ++i) {
    ArrayList<ArrayList<CardView>> gridRow=cardGrid.get(i);
    for (int j=0; j < gridRow.size(); ++j) {
      ArrayList<CardView> stack=gridRow.get(j);
      for (int k=0; k < stack.size(); ++k) {
        CardView card=stack.get(k);
        if (!cardsView.containsKey(card.getId())) {
          removeCardView(card);
          stack.remove(k--);
          didModify=true;
        }
      }
    }
  }
  for (  CardView newCard : cardsView.values()) {
    if (!cardViews.containsKey(newCard.getId())) {
      addCardView(newCard);
      try {
        sortIntoGrid(newCard);
      }
 catch (      Exception e) {
        e.printStackTrace();
      }
      didModify=true;
    }
  }
  if (didModify) {
    trimGrid();
    layoutGrid();
    cardScroll.revalidate();
    repaint();
  }
}","public void setCards(CardsView cardsView,BigCard bigCard){
  if (bigCard != null) {
    lastBigCard=bigCard;
  }
  boolean didModify=false;
  for (int i=0; i < cardGrid.size(); ++i) {
    ArrayList<ArrayList<CardView>> gridRow=cardGrid.get(i);
    for (int j=0; j < gridRow.size(); ++j) {
      ArrayList<CardView> stack=gridRow.get(j);
      for (int k=0; k < stack.size(); ++k) {
        CardView card=stack.get(k);
        if (!cardsView.containsKey(card.getId())) {
          removeCardView(card);
          stack.remove(k--);
          didModify=true;
        }
      }
    }
  }
  if (didModify) {
    trimGrid();
  }
  for (  CardView newCard : cardsView.values()) {
    if (!cardViews.containsKey(newCard.getId())) {
      addCardView(newCard);
      try {
        sortIntoGrid(newCard);
      }
 catch (      Exception e) {
        e.printStackTrace();
      }
      didModify=true;
    }
  }
  if (didModify) {
    layoutGrid();
    cardScroll.revalidate();
    repaint();
  }
}",0.9656938044034818
158351,"private void btnSaveActionPerformed(java.awt.event.ActionEvent evt){
  String lastFolder=MageFrame.getPreferences().get(""String_Node_Str"",""String_Node_Str"");
  if (!lastFolder.isEmpty()) {
    fcSelectDeck.setCurrentDirectory(new File(lastFolder));
  }
  deck.setName(this.txtDeckName.getText());
  int ret=fcSelectDeck.showSaveDialog(this);
  if (ret == JFileChooser.APPROVE_OPTION) {
    File file=fcSelectDeck.getSelectedFile();
    try {
      String fileName=file.getPath();
      if (!fileName.endsWith(""String_Node_Str"")) {
        fileName+=""String_Node_Str"";
      }
      setCursor(new Cursor(Cursor.WAIT_CURSOR));
      Sets.saveDeck(fileName,deck.getDeckCardLists());
    }
 catch (    Exception ex) {
      logger.fatal(ex);
    }
 finally {
      setCursor(new Cursor(Cursor.DEFAULT_CURSOR));
    }
    try {
      MageFrame.getPreferences().put(""String_Node_Str"",file.getCanonicalPath());
    }
 catch (    IOException ex) {
    }
  }
}","private void btnSaveActionPerformed(java.awt.event.ActionEvent evt){
  String lastFolder=MageFrame.getPreferences().get(""String_Node_Str"",""String_Node_Str"");
  if (!lastFolder.isEmpty()) {
    fcSelectDeck.setCurrentDirectory(new File(lastFolder));
  }
  deck.setName(this.txtDeckName.getText());
  int ret=fcSelectDeck.showSaveDialog(this);
  if (ret == JFileChooser.APPROVE_OPTION) {
    File file=fcSelectDeck.getSelectedFile();
{
      if (file == null) {
        if (!lastFolder.isEmpty()) {
          file=new File(lastFolder);
        }
      }
    }
    try {
      String fileName=file.getPath();
      if (!fileName.endsWith(""String_Node_Str"")) {
        fileName+=""String_Node_Str"";
      }
      setCursor(new Cursor(Cursor.WAIT_CURSOR));
      Sets.saveDeck(fileName,deck.getDeckCardLists());
    }
 catch (    FileNotFoundException ex) {
      JOptionPane.showMessageDialog(MageFrame.getDesktop(),ex.getMessage() + ""String_Node_Str"",""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
    }
 finally {
      setCursor(new Cursor(Cursor.DEFAULT_CURSOR));
    }
    try {
      MageFrame.getPreferences().put(""String_Node_Str"",file.getCanonicalPath());
    }
 catch (    IOException ex) {
      ex.printStackTrace();
    }
  }
}",0.8585812356979405
158352,"private void btnLoadActionPerformed(java.awt.event.ActionEvent evt){
  String lastFolder=MageFrame.getPreferences().get(""String_Node_Str"",""String_Node_Str"");
  if (!lastFolder.isEmpty()) {
    fcSelectDeck.setCurrentDirectory(new File(lastFolder));
  }
  int ret=fcSelectDeck.showOpenDialog(this);
  if (ret == JFileChooser.APPROVE_OPTION) {
    File file=fcSelectDeck.getSelectedFile();
    try {
      setCursor(new Cursor(Cursor.WAIT_CURSOR));
      deck=Deck.load(DeckImporterUtil.importDeck(file.getPath()),true,true);
    }
 catch (    GameException ex) {
      JOptionPane.showMessageDialog(MageFrame.getDesktop(),ex.getMessage(),""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
    }
catch (    Exception ex) {
      logger.fatal(ex);
    }
 finally {
      setCursor(new Cursor(Cursor.DEFAULT_CURSOR));
    }
    refreshDeck();
    try {
      if (file != null) {
        MageFrame.getPreferences().put(""String_Node_Str"",file.getCanonicalPath());
      }
    }
 catch (    IOException ex) {
    }
  }
  fcSelectDeck.setSelectedFile(null);
}","private void btnLoadActionPerformed(java.awt.event.ActionEvent evt){
  String lastFolder=MageFrame.getPreferences().get(""String_Node_Str"",""String_Node_Str"");
  if (!lastFolder.isEmpty()) {
    fcSelectDeck.setCurrentDirectory(new File(lastFolder));
  }
  int ret=fcSelectDeck.showOpenDialog(this);
  if (ret == JFileChooser.APPROVE_OPTION) {
    File file=fcSelectDeck.getSelectedFile();
{
      if (file == null) {
        if (!lastFolder.isEmpty()) {
          file=new File(lastFolder);
        }
      }
    }
    try {
      setCursor(new Cursor(Cursor.WAIT_CURSOR));
      deck=Deck.load(DeckImporterUtil.importDeck(file.getPath()),true,true);
    }
 catch (    GameException ex) {
      JOptionPane.showMessageDialog(MageFrame.getDesktop(),ex.getMessage(),""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
    }
 finally {
      setCursor(new Cursor(Cursor.DEFAULT_CURSOR));
    }
    refreshDeck();
    try {
      if (file != null) {
        MageFrame.getPreferences().put(""String_Node_Str"",file.getCanonicalPath());
      }
    }
 catch (    IOException ex) {
    }
  }
  fcSelectDeck.setSelectedFile(null);
}",0.9153169828782972
158353,"private Card retrieveTemporaryCard(SimpleCardView cardView){
  Card card=temporaryCards.get(cardView.getId());
  if (card == null) {
    card=CardRepository.instance.findCard(cardView.getExpansionSetCode(),cardView.getCardNumber()).getCard();
  }
 else {
    temporaryCards.remove(cardView.getId());
  }
  return card;
}","private Card retrieveTemporaryCard(SimpleCardView cardView){
  Card card=temporaryCards.get(cardView.getId());
  if (card == null) {
    Logger.getLogger(DeckEditorPanel.class).info(""String_Node_Str"" + cardView.getCardNumber() + ""String_Node_Str"");
    card=CardRepository.instance.findCard(cardView.getExpansionSetCode(),cardView.getCardNumber()).getCard();
  }
 else {
    temporaryCards.remove(cardView.getId());
  }
  return card;
}",0.8465608465608465
158354,"@Override public boolean apply(Game game,Ability source){
  Player defendingPlayer=game.getPlayer(getTargetPointer().getFirst(game,source));
  if (defendingPlayer != null) {
    Target target=new TargetControlledPermanent(2);
    defendingPlayer.chooseTarget(outcome,target,source,game);
    defendingPlayer.moveCards(new CardsImpl(target.getTargets()),Zone.EXILED,source,game);
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Player defendingPlayer=game.getPlayer(getTargetPointer().getFirst(game,source));
  if (defendingPlayer != null) {
    Target target=new TargetControlledPermanent(2);
    defendingPlayer.chooseTarget(outcome,target,source,game);
    Cards toExile=new CardsImpl();
    target.getTargets().stream().map((targetId) -> game.getPermanent(targetId)).filter((permanent) -> (permanent != null)).forEach((permanent) -> {
      toExile.add(permanent);
    }
);
    defendingPlayer.moveCards(toExile,Zone.EXILED,source,game);
    return true;
  }
  return false;
}",0.7444120505344995
158355,"public DarkDecisionMayPlayExiledEffect(final DarkDecisionMayPlayExiledEffect effect){
  super(effect);
  this.card=effect.card;
}","public DarkDecisionMayPlayExiledEffect(final DarkDecisionMayPlayExiledEffect effect){
  super(effect);
}",0.8927038626609443
158356,"@Override public boolean applies(UUID sourceId,Ability source,UUID affectedControllerId,Game game){
  Card card=game.getCard(sourceId);
  Player controller=game.getPlayer(source.getControllerId());
  if (controller != null && card != null && game.getState().getZone(sourceId) == Zone.EXILED && this.card.equals(sourceId)) {
    return true;
  }
  return false;
}","@Override public boolean applies(UUID objectId,Ability source,UUID affectedControllerId,Game game){
  if (objectId.equals(getTargetPointer().getFirst(game,source)) && affectedControllerId.equals(source.getSourceId())) {
    ExileZone exileZone=game.getExile().getExileZone(source.getSourceId());
    return exileZone != null && exileZone.contains(getTargetPointer().getFirst(game,source));
  }
  return false;
}",0.3880983182406209
158357,"@Override public boolean apply(Game game,Ability source){
  Player player=game.getPlayer(source.getControllerId());
  if (player != null) {
    NonArtifactCreaturesDiedWatcher watcher=(NonArtifactCreaturesDiedWatcher)game.getState().getWatchers().get(""String_Node_Str"");
    if (watcher != null && watcher.conditionMet()) {
      Permanent permanent=game.getPermanentEntering(source.getSourceId());
      if (permanent != null) {
        permanent.addCounters(CounterType.P1P1.createInstance(1),game);
      }
    }
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller != null) {
    NonArtifactCreaturesDiedWatcher watcher=(NonArtifactCreaturesDiedWatcher)game.getState().getWatchers().get(""String_Node_Str"");
    if (watcher != null && watcher.conditionMet()) {
      Permanent permanent=game.getPermanentEntering(source.getSourceId());
      if (permanent != null) {
        permanent.addCounters(CounterType.P1P1.createInstance(1),game);
      }
    }
    return true;
  }
  return false;
}",0.956989247311828
158358,"@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller != null) {
    Set<Card> cards=controller.getGraveyard().getCards(filterCard,game);
    for (    Card card : cards) {
      if (card != null) {
        RepairAbility ability=new RepairAbility(6);
        ability.setSourceId(card.getId());
        ability.setControllerId(card.getOwnerId());
        game.getState().addOtherAbility(card,ability);
      }
    }
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller != null) {
    Set<Card> cards=controller.getGraveyard().getCards(filterCard,game);
    cards.stream().forEach((card) -> {
      game.getState().addOtherAbility(card,new RepairAbility(6));
    }
);
    return true;
  }
  return false;
}",0.526431718061674
158359,"public YodaEmblem(){
  this.setName(""String_Node_Str"");
  Effect effect=new GainAbilityControlledEffect(HexproofAbility.getInstance(),Duration.EndOfGame);
  effect.setText(""String_Node_Str"");
  Ability ability=new SimpleStaticAbility(Zone.COMMAND,effect);
  effect=new GainAbilityControllerEffect(HexproofAbility.getInstance(),Duration.EndOfGame);
  effect.setText(""String_Node_Str"");
  ability.addEffect(effect);
  getAbilities().add(ability);
}","public YodaEmblem(){
  this.setName(""String_Node_Str"");
  Effect effect=new GainAbilityControllerEffect(HexproofAbility.getInstance(),Duration.EndOfGame);
  effect.setText(""String_Node_Str"");
  Ability ability=new SimpleStaticAbility(Zone.COMMAND,effect);
  effect=new GainAbilityControlledEffect(HexproofAbility.getInstance(),Duration.EndOfGame,new FilterCreaturePermanent());
  effect.setText(""String_Node_Str"");
  ability.addEffect(effect);
  getAbilities().add(ability);
}",0.9631236442516268
158360,"@Override public boolean apply(Game game,Ability source){
  Player targetPlayer=game.getPlayer(source.getFirstTarget());
  if (targetPlayer != null && !targetPlayer.getHand().isEmpty()) {
    Cards revealed=new CardsImpl();
    Card card=targetPlayer.getHand().getRandom(game);
    revealed.add(card);
    targetPlayer.revealCards(""String_Node_Str"",revealed,game);
    targetPlayer.loseLife(card.getConvertedManaCost(),game);
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Player targetPlayer=game.getPlayer(source.getFirstTarget());
  if (targetPlayer != null && !targetPlayer.getHand().isEmpty()) {
    Cards revealed=new CardsImpl();
    Card card=targetPlayer.getHand().getRandom(game);
    revealed.add(card);
    targetPlayer.revealCards(""String_Node_Str"",revealed,game);
    targetPlayer.loseLife(card.getConvertedManaCost(),game,false);
    return true;
  }
  return false;
}",0.9935760171306208
158361,"@Override public boolean apply(Game game,Ability source){
  Card creatureCard=game.getCard(this.getTargetPointer().getFirst(game,source));
  Player controller=game.getPlayer(source.getControllerId());
  if (creatureCard != null && controller != null) {
    boolean result=false;
    if (game.getState().getZone(creatureCard.getId()).equals(Zone.GRAVEYARD)) {
      controller.moveCards(creatureCard,Zone.BATTLEFIELD,source,game);
    }
    controller.loseLife(creatureCard.getConvertedManaCost(),game);
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Card creatureCard=game.getCard(this.getTargetPointer().getFirst(game,source));
  Player controller=game.getPlayer(source.getControllerId());
  if (creatureCard != null && controller != null) {
    boolean result=false;
    if (game.getState().getZone(creatureCard.getId()).equals(Zone.GRAVEYARD)) {
      controller.moveCards(creatureCard,Zone.BATTLEFIELD,source,game);
    }
    controller.loseLife(creatureCard.getConvertedManaCost(),game,false);
    return true;
  }
  return false;
}",0.9944852941176472
158362,"@Override public boolean apply(Game game,Ability source){
  Player player=game.getPlayer(source.getControllerId());
  Player targetPlayer=game.getPlayer(source.getFirstTarget());
  if (player != null && targetPlayer != null) {
    List<Permanent> creatures=game.getBattlefield().getAllActivePermanents(new FilterCreaturePermanent(),player.getId(),game);
    int amount=0;
    for (    Permanent creature : creatures) {
      int power=creature.getPower().getValue();
      if (amount < power) {
        amount=power;
      }
    }
    if (amount > 0) {
      targetPlayer.loseLife(amount,game);
      player.gainLife(amount,game);
    }
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Player player=game.getPlayer(source.getControllerId());
  Player targetPlayer=game.getPlayer(source.getFirstTarget());
  if (player != null && targetPlayer != null) {
    List<Permanent> creatures=game.getBattlefield().getAllActivePermanents(new FilterCreaturePermanent(),player.getId(),game);
    int amount=0;
    for (    Permanent creature : creatures) {
      int power=creature.getPower().getValue();
      if (amount < power) {
        amount=power;
      }
    }
    if (amount > 0) {
      targetPlayer.loseLife(amount,game,false);
      player.gainLife(amount,game);
    }
    return true;
  }
  return false;
}",0.995575221238938
158363,"@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller == null) {
    return false;
  }
  int amount=(new ManacostVariableValue()).calculate(game,source,this);
  if (amount > 0) {
    LinkedList<Permanent> sacrifices=new LinkedList<Permanent>();
    HashMap<UUID,Integer> lifePaidAmounts=new HashMap<UUID,Integer>();
    FilterCreaturePermanent filter=new FilterCreaturePermanent();
    for (    UUID playerId : game.getState().getPlayersInRange(controller.getId(),game)) {
      Player player=game.getPlayer(playerId);
      List<Permanent> creatures=game.getBattlefield().getAllActivePermanents(filter,playerId,game);
      int lifePaid=0;
      int playerLife=player.getLife();
      for (      Permanent creature : creatures) {
        String message=""String_Node_Str"" + amount + ""String_Node_Str""+ creature.getName()+ ""String_Node_Str"";
        if (playerLife - amount - lifePaid >= 0 && player != null && player.chooseUse(Outcome.Neutral,message,source,game)) {
          game.informPlayers(player.getLogName() + ""String_Node_Str"" + amount+ ""String_Node_Str""+ creature.getName());
          lifePaid+=amount;
        }
 else {
          game.informPlayers(player.getLogName() + ""String_Node_Str"" + creature.getName());
          sacrifices.add(creature);
        }
      }
      lifePaidAmounts.put(playerId,lifePaid);
    }
    for (    UUID playerId : game.getState().getPlayersInRange(controller.getId(),game)) {
      int lifePaid=lifePaidAmounts.get(playerId);
      if (lifePaid > 0) {
        Player player=game.getPlayer(playerId);
        if (player != null) {
          player.loseLife(lifePaid,game);
        }
      }
    }
    for (    Permanent creature : sacrifices) {
      creature.sacrifice(source.getSourceId(),game);
    }
  }
  return true;
}","@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller == null) {
    return false;
  }
  int amount=(new ManacostVariableValue()).calculate(game,source,this);
  if (amount > 0) {
    LinkedList<Permanent> sacrifices=new LinkedList<Permanent>();
    HashMap<UUID,Integer> lifePaidAmounts=new HashMap<UUID,Integer>();
    FilterCreaturePermanent filter=new FilterCreaturePermanent();
    for (    UUID playerId : game.getState().getPlayersInRange(controller.getId(),game)) {
      Player player=game.getPlayer(playerId);
      List<Permanent> creatures=game.getBattlefield().getAllActivePermanents(filter,playerId,game);
      int lifePaid=0;
      int playerLife=player.getLife();
      for (      Permanent creature : creatures) {
        String message=""String_Node_Str"" + amount + ""String_Node_Str""+ creature.getName()+ ""String_Node_Str"";
        if (playerLife - amount - lifePaid >= 0 && player != null && player.chooseUse(Outcome.Neutral,message,source,game)) {
          game.informPlayers(player.getLogName() + ""String_Node_Str"" + amount+ ""String_Node_Str""+ creature.getName());
          lifePaid+=amount;
        }
 else {
          game.informPlayers(player.getLogName() + ""String_Node_Str"" + creature.getName());
          sacrifices.add(creature);
        }
      }
      lifePaidAmounts.put(playerId,lifePaid);
    }
    for (    UUID playerId : game.getState().getPlayersInRange(controller.getId(),game)) {
      int lifePaid=lifePaidAmounts.get(playerId);
      if (lifePaid > 0) {
        Player player=game.getPlayer(playerId);
        if (player != null) {
          player.loseLife(lifePaid,game,false);
        }
      }
    }
    for (    Permanent creature : sacrifices) {
      creature.sacrifice(source.getSourceId(),game);
    }
  }
  return true;
}",0.9983818770226536
158364,"@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller != null) {
    if (game.getBattlefield().countAll(new FilterCreaturePermanent(""String_Node_Str"",""String_Node_Str""),source.getControllerId(),game) < 1) {
      controller.loseLife(2,game);
    }
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller != null) {
    if (game.getBattlefield().countAll(new FilterCreaturePermanent(""String_Node_Str"",""String_Node_Str""),source.getControllerId(),game) < 1) {
      controller.loseLife(2,game,false);
    }
    return true;
  }
  return false;
}",0.9919354838709676
158365,"@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller != null) {
    if (game.getBattlefield().countAll(new FilterCreaturePermanent(""String_Node_Str"",""String_Node_Str""),source.getControllerId(),game) < 1) {
      controller.loseLife(1,game);
    }
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller != null) {
    if (game.getBattlefield().countAll(new FilterCreaturePermanent(""String_Node_Str"",""String_Node_Str""),source.getControllerId(),game) < 1) {
      controller.loseLife(1,game,false);
    }
    return true;
  }
  return false;
}",0.9919354838709676
158366,"@Override public boolean apply(Game game,Ability source){
  Player player=game.getPlayer(source.getControllerId());
  if (player == null) {
    return false;
  }
  if (player.getLibrary().size() > 0) {
    Card card=player.getLibrary().getFromTop(game);
    Cards cards=new CardsImpl();
    cards.add(card);
    player.revealCards(""String_Node_Str"",cards,game);
    if (card != null && card.moveToZone(Zone.HAND,source.getSourceId(),game,false)) {
      player.loseLife(card.getConvertedManaCost(),game);
      return true;
    }
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Player player=game.getPlayer(source.getControllerId());
  if (player == null) {
    return false;
  }
  if (player.getLibrary().size() > 0) {
    Card card=player.getLibrary().getFromTop(game);
    Cards cards=new CardsImpl();
    cards.add(card);
    player.revealCards(""String_Node_Str"",cards,game);
    if (card != null && card.moveToZone(Zone.HAND,source.getSourceId(),game,false)) {
      player.loseLife(card.getConvertedManaCost(),game,false);
      return true;
    }
  }
  return false;
}",0.9945848375451264
158367,"@Override public boolean apply(Game game,Ability source){
  int lostAmount=0;
  for (  UUID opponentId : game.getOpponents(source.getControllerId())) {
    lostAmount+=game.getPlayer(opponentId).loseLife(1,game);
  }
  game.getPlayer(source.getControllerId()).gainLife(lostAmount,game);
  return true;
}","@Override public boolean apply(Game game,Ability source){
  int lostAmount=0;
  for (  UUID opponentId : game.getOpponents(source.getControllerId())) {
    lostAmount+=game.getPlayer(opponentId).loseLife(1,game,false);
  }
  game.getPlayer(source.getControllerId()).gainLife(lostAmount,game);
  return true;
}",0.9901960784313726
158368,"@Override public boolean apply(Game game,Ability source){
  int numberSpirits=0;
  for (  Cost cost : source.getCosts()) {
    if (cost instanceof SacrificeTargetCost) {
      numberSpirits+=((SacrificeTargetCost)cost).getPermanents().size();
    }
  }
  int amount=2 + (numberSpirits * 2);
  Player targetPlayer=game.getPlayer(getTargetPointer().getFirst(game,source));
  Player sourcePlayer=game.getPlayer(source.getControllerId());
  if (targetPlayer != null && sourcePlayer != null) {
    targetPlayer.loseLife(amount,game);
    sourcePlayer.gainLife(amount,game);
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  int numberSpirits=0;
  for (  Cost cost : source.getCosts()) {
    if (cost instanceof SacrificeTargetCost) {
      numberSpirits+=((SacrificeTargetCost)cost).getPermanents().size();
    }
  }
  int amount=2 + (numberSpirits * 2);
  Player targetPlayer=game.getPlayer(getTargetPointer().getFirst(game,source));
  Player sourcePlayer=game.getPlayer(source.getControllerId());
  if (targetPlayer != null && sourcePlayer != null) {
    targetPlayer.loseLife(amount,game,false);
    sourcePlayer.gainLife(amount,game);
    return true;
  }
  return false;
}",0.9950819672131148
158369,"@Override public boolean apply(Game game,Ability source){
  int loseLife=0;
  for (  UUID opponentId : game.getOpponents(source.getControllerId())) {
    loseLife+=game.getPlayer(opponentId).loseLife(5,game);
  }
  if (loseLife > 0)   game.getPlayer(source.getControllerId()).gainLife(loseLife,game);
  return true;
}","@Override public boolean apply(Game game,Ability source){
  int loseLife=0;
  for (  UUID opponentId : game.getOpponents(source.getControllerId())) {
    loseLife+=game.getPlayer(opponentId).loseLife(5,game,false);
  }
  if (loseLife > 0)   game.getPlayer(source.getControllerId()).gainLife(loseLife,game);
  return true;
}",0.990625
158370,"@Override public boolean apply(Game game,Ability source){
  Player player=game.getPlayer(source.getControllerId());
  if (player == null) {
    return false;
  }
  boolean doAgain;
  do {
    Cards cards=new CardsImpl();
    int count=Math.min(player.getLibrary().size(),5);
    for (int i=0; i < count; i++) {
      Card card=player.getLibrary().removeFromTop(game);
      if (card != null) {
        cards.add(card);
      }
    }
    player.lookAtCards(""String_Node_Str"",cards,game);
    doAgain=player.chooseUse(outcome,""String_Node_Str"",source,game);
    if (doAgain) {
      player.loseLife(1,game);
    }
 else {
      player.shuffleLibrary(source,game);
    }
    TargetCard target=new TargetCard(Zone.LIBRARY,new FilterCard(doAgain ? textBottom : textTop));
    while (player.canRespond() && cards.size() > 1) {
      player.choose(Outcome.Neutral,cards,target,game);
      Card card=cards.get(target.getFirstTarget(),game);
      if (card != null) {
        cards.remove(card);
        card.moveToZone(Zone.LIBRARY,source.getSourceId(),game,!doAgain);
      }
      target.clearChosen();
    }
    if (cards.size() == 1) {
      Card card=cards.get(cards.iterator().next(),game);
      card.moveToZone(Zone.LIBRARY,source.getSourceId(),game,!doAgain);
    }
  }
 while (doAgain);
  return true;
}","@Override public boolean apply(Game game,Ability source){
  Player player=game.getPlayer(source.getControllerId());
  if (player == null) {
    return false;
  }
  boolean doAgain;
  do {
    Cards cards=new CardsImpl();
    int count=Math.min(player.getLibrary().size(),5);
    for (int i=0; i < count; i++) {
      Card card=player.getLibrary().removeFromTop(game);
      if (card != null) {
        cards.add(card);
      }
    }
    player.lookAtCards(""String_Node_Str"",cards,game);
    doAgain=player.chooseUse(outcome,""String_Node_Str"",source,game);
    if (doAgain) {
      player.loseLife(1,game,false);
    }
 else {
      player.shuffleLibrary(source,game);
    }
    TargetCard target=new TargetCard(Zone.LIBRARY,new FilterCard(doAgain ? textBottom : textTop));
    while (player.canRespond() && cards.size() > 1) {
      player.choose(Outcome.Neutral,cards,target,game);
      Card card=cards.get(target.getFirstTarget(),game);
      if (card != null) {
        cards.remove(card);
        card.moveToZone(Zone.LIBRARY,source.getSourceId(),game,!doAgain);
      }
      target.clearChosen();
    }
    if (cards.size() == 1) {
      Card card=cards.get(cards.iterator().next(),game);
      card.moveToZone(Zone.LIBRARY,source.getSourceId(),game,!doAgain);
    }
  }
 while (doAgain);
  return true;
}",0.9977081741787625
158371,"@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller != null) {
    int loseLife=0;
    for (    UUID opponentId : game.getOpponents(source.getControllerId())) {
      Player opponent=game.getPlayer(opponentId);
      if (opponent != null) {
        loseLife+=opponent.loseLife(1,game);
      }
    }
    controller.gainLife(loseLife,game);
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller != null) {
    int loseLife=0;
    for (    UUID opponentId : game.getOpponents(source.getControllerId())) {
      Player opponent=game.getPlayer(opponentId);
      if (opponent != null) {
        loseLife+=opponent.loseLife(1,game,false);
      }
    }
    controller.gainLife(loseLife,game);
    return true;
  }
  return false;
}",0.9935622317596566
158372,"@Override public boolean apply(Game game,Ability source){
  Player player=game.getPlayer(getTargetPointer().getFirst(game,source));
  if (player != null) {
    Integer amount=(int)Math.ceil(player.getLife() / 2f);
    if (amount > 0) {
      player.loseLife(amount,game);
    }
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Player player=game.getPlayer(getTargetPointer().getFirst(game,source));
  if (player != null) {
    Integer amount=(int)Math.ceil(player.getLife() / 2f);
    if (amount > 0) {
      player.loseLife(amount,game,false);
    }
    return true;
  }
  return false;
}",0.9905956112852664
158373,"@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller != null) {
    HashMap<UUID,Integer> destroyedCreatures=new HashMap<>();
    for (    Permanent permanent : game.getBattlefield().getActivePermanents(new FilterCreaturePermanent(),source.getControllerId(),source.getSourceId(),game)) {
      if (permanent.destroy(source.getSourceId(),game,false)) {
        int count=destroyedCreatures.containsKey(permanent.getControllerId()) ? destroyedCreatures.get(permanent.getControllerId()) : 0;
        destroyedCreatures.put(permanent.getControllerId(),count + 1);
      }
    }
    for (    UUID playerId : game.getState().getPlayerList(source.getControllerId())) {
      int count=destroyedCreatures.containsKey(playerId) ? destroyedCreatures.get(playerId) : 0;
      if (count > 0) {
        Player player=game.getPlayer(playerId);
        if (player != null) {
          player.loseLife(count,game);
        }
      }
    }
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller != null) {
    HashMap<UUID,Integer> destroyedCreatures=new HashMap<>();
    for (    Permanent permanent : game.getBattlefield().getActivePermanents(new FilterCreaturePermanent(),source.getControllerId(),source.getSourceId(),game)) {
      if (permanent.destroy(source.getSourceId(),game,false)) {
        int count=destroyedCreatures.containsKey(permanent.getControllerId()) ? destroyedCreatures.get(permanent.getControllerId()) : 0;
        destroyedCreatures.put(permanent.getControllerId(),count + 1);
      }
    }
    for (    UUID playerId : game.getState().getPlayerList(source.getControllerId())) {
      int count=destroyedCreatures.containsKey(playerId) ? destroyedCreatures.get(playerId) : 0;
      if (count > 0) {
        Player player=game.getPlayer(playerId);
        if (player != null) {
          player.loseLife(count,game,false);
        }
      }
    }
    return true;
  }
  return false;
}",0.9971374045801528
158374,"@Override public boolean apply(Game game,Ability source){
  Player player=game.getPlayer(getTargetPointer().getFirst(game,source));
  if (player != null) {
    Integer amount=(int)Math.ceil(player.getLife() / 2f);
    if (amount > 0) {
      player.loseLife(amount,game);
    }
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Player player=game.getPlayer(getTargetPointer().getFirst(game,source));
  if (player != null) {
    Integer amount=(int)Math.ceil(player.getLife() / 2f);
    if (amount > 0) {
      player.loseLife(amount,game,false);
    }
    return true;
  }
  return false;
}",0.9905956112852664
158375,"@Override public boolean apply(Game game,Ability source){
  int counters=0;
  Player controller=game.getPlayer(source.getControllerId());
  if (controller != null) {
    for (    UUID playerId : game.getState().getPlayersInRange(controller.getId(),game)) {
      Player player=game.getPlayer(playerId);
      if (player != null) {
        if (player.loseLife(1,game) > 0) {
          counters++;
        }
      }
    }
    Permanent bloodTyrant=game.getPermanent(source.getSourceId());
    if (bloodTyrant != null && counters > 0) {
      bloodTyrant.addCounters(CounterType.P1P1.createInstance(counters),game);
    }
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  int counters=0;
  Player controller=game.getPlayer(source.getControllerId());
  if (controller != null) {
    for (    UUID playerId : game.getState().getPlayersInRange(controller.getId(),game)) {
      Player player=game.getPlayer(playerId);
      if (player != null) {
        if (player.loseLife(1,game,false) > 0) {
          counters++;
        }
      }
    }
    Permanent bloodTyrant=game.getPermanent(source.getSourceId());
    if (bloodTyrant != null && counters > 0) {
      bloodTyrant.addCounters(CounterType.P1P1.createInstance(counters),game);
    }
    return true;
  }
  return false;
}",0.9954545454545456
158376,"@Override public boolean apply(Game game,Ability source){
  for (  UUID opponentId : game.getOpponents(source.getControllerId())) {
    Player opponent=game.getPlayer(opponentId);
    if (opponent != null) {
      opponent.loseLife(2,game);
    }
  }
  return true;
}","@Override public boolean apply(Game game,Ability source){
  for (  UUID opponentId : game.getOpponents(source.getControllerId())) {
    Player opponent=game.getPlayer(opponentId);
    if (opponent != null) {
      opponent.loseLife(2,game,false);
    }
  }
  return true;
}",0.9888888888888888
158377,"@Override public boolean apply(Game game,Ability source){
  Player targetPlayer=game.getPlayer(source.getFirstTarget());
  Player you=game.getPlayer(source.getControllerId());
  if (targetPlayer != null) {
    targetPlayer.loseLife(1,game);
  }
  if (you != null) {
    you.gainLife(1,game);
  }
  return true;
}","@Override public boolean apply(Game game,Ability source){
  Player targetPlayer=game.getPlayer(source.getFirstTarget());
  Player you=game.getPlayer(source.getControllerId());
  if (targetPlayer != null) {
    targetPlayer.loseLife(1,game,false);
  }
  if (you != null) {
    you.gainLife(1,game);
  }
  return true;
}",0.9904761904761904
158378,"@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller != null) {
    for (    UUID playerId : game.getState().getPlayersInRange(controller.getId(),game)) {
      final int count=game.getBattlefield().getAllActivePermanents(new FilterCreaturePermanent(),playerId,game).size();
      if (count > 0) {
        Player player=game.getPlayer(playerId);
        if (player != null) {
          player.loseLife(count,game);
        }
      }
    }
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller != null) {
    for (    UUID playerId : game.getState().getPlayersInRange(controller.getId(),game)) {
      final int count=game.getBattlefield().getAllActivePermanents(new FilterCreaturePermanent(),playerId,game).size();
      if (count > 0) {
        Player player=game.getPlayer(playerId);
        if (player != null) {
          player.loseLife(count,game,false);
        }
      }
    }
    return true;
  }
  return false;
}",0.9946808510638298
158379,"@Override public boolean apply(Game game,Ability source){
  for (  UUID opponentId : game.getOpponents(source.getControllerId())) {
    game.getPlayer(opponentId).loseLife(4,game);
  }
  return true;
}","@Override public boolean apply(Game game,Ability source){
  for (  UUID opponentId : game.getOpponents(source.getControllerId())) {
    game.getPlayer(opponentId).loseLife(4,game,false);
  }
  return true;
}",0.9852941176470588
158380,"@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  Permanent sourcePermanent=game.getPermanent(source.getSourceId());
  if (controller != null && sourcePermanent != null) {
    if (getTargetPointer().getFirst(game,source) != null) {
      Permanent targetCreature=game.getPermanent(getTargetPointer().getFirst(game,source));
      if (targetCreature != null) {
        int zcc=targetCreature.getZoneChangeCounter(game);
        if (controller.moveCards(targetCreature,Zone.EXILED,source,game)) {
          Effect effect=new ReturnToBattlefieldUnderOwnerControlTargetEffect();
          effect.setTargetPointer(new FixedTarget(targetCreature.getId(),zcc + 1));
          AtTheBeginOfYourNextUpkeepDelayedTriggeredAbility delayedAbility=new AtTheBeginOfYourNextUpkeepDelayedTriggeredAbility(effect);
          game.addDelayedTriggeredAbility(delayedAbility,source);
        }
      }
    }
 else {
      int zcc=sourcePermanent.getZoneChangeCounter(game);
      if (controller.moveCards(sourcePermanent,Zone.EXILED,source,game)) {
        Effect effect=new ReturnToBattlefieldUnderOwnerControlTargetEffect();
        effect.setTargetPointer(new FixedTarget(sourcePermanent.getId(),zcc + 1));
        AtTheBeginOfYourNextUpkeepDelayedTriggeredAbility delayedAbility=new AtTheBeginOfYourNextUpkeepDelayedTriggeredAbility(effect);
        game.addDelayedTriggeredAbility(delayedAbility,source);
      }
    }
    controller.loseLife(2,game);
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  Permanent sourcePermanent=game.getPermanent(source.getSourceId());
  if (controller != null && sourcePermanent != null) {
    if (getTargetPointer().getFirst(game,source) != null) {
      Permanent targetCreature=game.getPermanent(getTargetPointer().getFirst(game,source));
      if (targetCreature != null) {
        int zcc=targetCreature.getZoneChangeCounter(game);
        if (controller.moveCards(targetCreature,Zone.EXILED,source,game)) {
          Effect effect=new ReturnToBattlefieldUnderOwnerControlTargetEffect();
          effect.setTargetPointer(new FixedTarget(targetCreature.getId(),zcc + 1));
          AtTheBeginOfYourNextUpkeepDelayedTriggeredAbility delayedAbility=new AtTheBeginOfYourNextUpkeepDelayedTriggeredAbility(effect);
          game.addDelayedTriggeredAbility(delayedAbility,source);
        }
      }
    }
 else {
      int zcc=sourcePermanent.getZoneChangeCounter(game);
      if (controller.moveCards(sourcePermanent,Zone.EXILED,source,game)) {
        Effect effect=new ReturnToBattlefieldUnderOwnerControlTargetEffect();
        effect.setTargetPointer(new FixedTarget(sourcePermanent.getId(),zcc + 1));
        AtTheBeginOfYourNextUpkeepDelayedTriggeredAbility delayedAbility=new AtTheBeginOfYourNextUpkeepDelayedTriggeredAbility(effect);
        game.addDelayedTriggeredAbility(delayedAbility,source);
      }
    }
    controller.loseLife(2,game,false);
    return true;
  }
  return false;
}",0.998063266623628
158381,"@Override public boolean replaceEvent(GameEvent event,Ability source,Game game){
  Player player=game.getPlayer(event.getPlayerId());
  if (player != null) {
    player.loseLife(event.getAmount(),game);
  }
  return true;
}","@Override public boolean replaceEvent(GameEvent event,Ability source,Game game){
  Player player=game.getPlayer(event.getPlayerId());
  if (player != null) {
    player.loseLife(event.getAmount(),game,false);
  }
  return true;
}",0.986725663716814
158382,"@Override public boolean replaceEvent(GameEvent event,Ability source,Game game){
  Player player=game.getPlayer(event.getPlayerId());
  if (player != null) {
    player.drawCards(2,game,event.getAppliedEffects());
    player.loseLife(1,game);
  }
  return true;
}","@Override public boolean replaceEvent(GameEvent event,Ability source,Game game){
  Player player=game.getPlayer(event.getPlayerId());
  if (player != null) {
    player.drawCards(2,game,event.getAppliedEffects());
    player.loseLife(1,game,false);
  }
  return true;
}",0.9887218045112782
158383,"@Override public boolean apply(Game game,Ability source){
  Player targetPlayer=game.getPlayer(targetPointer.getFirst(game,source));
  if (targetPlayer != null) {
    targetPlayer.drawCards(source.getManaCostsToPay().getX(),game);
    targetPlayer.loseLife(source.getManaCostsToPay().getX(),game);
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Player targetPlayer=game.getPlayer(targetPointer.getFirst(game,source));
  if (targetPlayer != null) {
    targetPlayer.drawCards(source.getManaCostsToPay().getX(),game);
    targetPlayer.loseLife(source.getManaCostsToPay().getX(),game,false);
    return true;
  }
  return false;
}",0.991150442477876
158384,"@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  Player targetOpponent=game.getPlayer(getTargetPointer().getFirst(game,source));
  if (controller != null && targetOpponent != null) {
    int amount=new AttackingFilterCreatureCount(filter).calculate(game,source,this);
    if (amount > 0) {
      targetOpponent.loseLife(amount,game);
      controller.gainLife(amount,game);
    }
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  Player targetOpponent=game.getPlayer(getTargetPointer().getFirst(game,source));
  if (controller != null && targetOpponent != null) {
    int amount=new AttackingFilterCreatureCount(filter).calculate(game,source,this);
    if (amount > 0) {
      targetOpponent.loseLife(amount,game,false);
      controller.gainLife(amount,game);
    }
    return true;
  }
  return false;
}",0.9939271255060728
158385,"@Override public boolean apply(Game game,Ability source){
  Player targetOpponent=game.getPlayer(source.getTargets().getFirstTarget());
  Player controller=game.getPlayer(source.getControllerId());
  if (targetOpponent == null || controller == null) {
    return false;
  }
  FilterControlledPermanent filter=new FilterControlledPermanent(""String_Node_Str"");
  filter.add(new CardTypePredicate(CardType.CREATURE));
  filter.add(new ControllerPredicate(TargetController.YOU));
  filter.add(Predicates.or(new ColorPredicate(ObjectColor.GREEN),new ColorPredicate(ObjectColor.WHITE)));
  TargetControlledPermanent target=new TargetControlledPermanent(1,1,filter,true);
  if (target.canChoose(source.getSourceId(),targetOpponent.getId(),game)) {
    targetOpponent.chooseTarget(Outcome.Sacrifice,target,source,game);
    Permanent permanent=game.getPermanent(target.getFirstTarget());
    if (permanent != null) {
      if (permanent.sacrifice(source.getSourceId(),game)) {
        targetOpponent.loseLife(2,game);
      }
    }
  }
  return true;
}","@Override public boolean apply(Game game,Ability source){
  Player targetOpponent=game.getPlayer(source.getTargets().getFirstTarget());
  Player controller=game.getPlayer(source.getControllerId());
  if (targetOpponent == null || controller == null) {
    return false;
  }
  FilterControlledPermanent filter=new FilterControlledPermanent(""String_Node_Str"");
  filter.add(new CardTypePredicate(CardType.CREATURE));
  filter.add(new ControllerPredicate(TargetController.YOU));
  filter.add(Predicates.or(new ColorPredicate(ObjectColor.GREEN),new ColorPredicate(ObjectColor.WHITE)));
  TargetControlledPermanent target=new TargetControlledPermanent(1,1,filter,true);
  if (target.canChoose(source.getSourceId(),targetOpponent.getId(),game)) {
    targetOpponent.chooseTarget(Outcome.Sacrifice,target,source,game);
    Permanent permanent=game.getPermanent(target.getFirstTarget());
    if (permanent != null) {
      if (permanent.sacrifice(source.getSourceId(),game)) {
        targetOpponent.loseLife(2,game,false);
      }
    }
  }
  return true;
}",0.997134670487106
158386,"@Override public boolean pay(Ability ability,Game game,UUID sourceId,UUID controllerId,boolean noMana,Cost costToPay){
  Player controller=game.getPlayer(controllerId);
  if (controller != null) {
    int currentLife=controller.getLife();
    int lifeToPay=(currentLife + currentLife % 2) / 2;
    if (lifeToPay < 0) {
      this.paid=true;
    }
 else {
      this.paid=(controller.loseLife(lifeToPay,game) == lifeToPay);
    }
    return this.paid;
  }
  return false;
}","@Override public boolean pay(Ability ability,Game game,UUID sourceId,UUID controllerId,boolean noMana,Cost costToPay){
  Player controller=game.getPlayer(controllerId);
  if (controller != null) {
    int currentLife=controller.getLife();
    int lifeToPay=(currentLife + currentLife % 2) / 2;
    if (lifeToPay < 0) {
      this.paid=true;
    }
 else {
      this.paid=(controller.loseLife(lifeToPay,game,false) == lifeToPay);
    }
    return this.paid;
  }
  return false;
}",0.9936842105263158
158387,"@Override public boolean apply(Game game,Ability source){
  Player you=game.getPlayer(source.getControllerId());
  Permanent permanent=game.getPermanent(this.getTargetPointer().getFirst(game,source));
  if (permanent != null && you != null) {
    permanent.destroy(source.getSourceId(),game,false);
    Player permController=game.getPlayer(permanent.getControllerId());
    if (permController != null) {
      permController.loseLife(2,game);
      you.gainLife(2,game);
      return true;
    }
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Player you=game.getPlayer(source.getControllerId());
  Permanent permanent=game.getPermanent(this.getTargetPointer().getFirst(game,source));
  if (permanent != null && you != null) {
    permanent.destroy(source.getSourceId(),game,false);
    Player permController=game.getPlayer(permanent.getControllerId());
    if (permController != null) {
      permController.loseLife(2,game,false);
      you.gainLife(2,game);
      return true;
    }
  }
  return false;
}",0.9942307692307693
158388,"@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller != null) {
    for (    UUID playerId : game.getState().getPlayersInRange(controller.getId(),game)) {
      final int amount=game.getBattlefield().getAllActivePermanents(new FilterAttackingCreature(),playerId,game).size();
      if (amount > 0) {
        Player player=game.getPlayer(playerId);
        if (player != null) {
          player.loseLife(amount,game);
        }
      }
    }
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller != null) {
    for (    UUID playerId : game.getState().getPlayersInRange(controller.getId(),game)) {
      final int amount=game.getBattlefield().getAllActivePermanents(new FilterAttackingCreature(),playerId,game).size();
      if (amount > 0) {
        Player player=game.getPlayer(playerId);
        if (player != null) {
          player.loseLife(amount,game,false);
        }
      }
    }
    return true;
  }
  return false;
}",0.9947089947089948
158389,"@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  MageObject sourceObject=source.getSourceObject(game);
  if (controller != null && sourceObject != null) {
    if (controller.getLibrary().size() > 0) {
      Card card=controller.getLibrary().getFromTop(game);
      Cards cards=new CardsImpl(card);
      controller.revealCards(sourceObject.getIdName(),cards,game);
      if (card.getCardType().contains(CardType.CREATURE)) {
        controller.gainLife(card.getToughness().getValue(),game);
        controller.loseLife(card.getPower().getValue(),game);
        return controller.moveCards(cards.getCards(game),Zone.HAND,source,game);
      }
    }
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  MageObject sourceObject=source.getSourceObject(game);
  if (controller != null && sourceObject != null) {
    if (controller.getLibrary().size() > 0) {
      Card card=controller.getLibrary().getFromTop(game);
      Cards cards=new CardsImpl(card);
      controller.revealCards(sourceObject.getIdName(),cards,game);
      if (card.getCardType().contains(CardType.CREATURE)) {
        controller.gainLife(card.getToughness().getValue(),game);
        controller.loseLife(card.getPower().getValue(),game,false);
        return controller.moveCards(cards.getCards(game),Zone.HAND,source,game);
      }
    }
    return true;
  }
  return false;
}",0.9960629921259844
158390,"@Override public boolean apply(Game game,Ability source){
  Player caster=game.getPlayer(targetPointer.getFirst(game,source));
  if (caster != null) {
    caster.loseLife(1,game);
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Player caster=game.getPlayer(targetPointer.getFirst(game,source));
  if (caster != null) {
    caster.loseLife(1,game,false);
    return true;
  }
  return false;
}",0.986425339366516
158391,"@Override public boolean apply(Game game,Ability source){
  Permanent creature=game.getPermanentOrLKIBattlefield(getTargetPointer().getFirst(game,source));
  if (creature != null) {
    Player controller=game.getPlayer(creature.getControllerId());
    if (controller != null) {
      controller.loseLife(3,game);
      return true;
    }
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Permanent creature=game.getPermanentOrLKIBattlefield(getTargetPointer().getFirst(game,source));
  if (creature != null) {
    Player controller=game.getPlayer(creature.getControllerId());
    if (controller != null) {
      controller.loseLife(3,game,false);
      return true;
    }
  }
  return false;
}",0.9917127071823204
158392,"@Override public boolean apply(Game game,Ability source){
  Player player=game.getPlayer(source.getControllerId());
  Permanent target=game.getPermanentOrLKIBattlefield(this.getTargetPointer().getFirst(game,source));
  if (player != null && target != null) {
    player.loseLife(target.getToughness().getValue(),game);
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Player player=game.getPlayer(source.getControllerId());
  Permanent target=game.getPermanentOrLKIBattlefield(this.getTargetPointer().getFirst(game,source));
  if (player != null && target != null) {
    player.loseLife(target.getToughness().getValue(),game,false);
    return true;
  }
  return false;
}",0.9916666666666668
158393,"@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller != null) {
    for (    UUID playerId : game.getState().getPlayersInRange(controller.getId(),game)) {
      Player player=game.getPlayer(playerId);
      if (player != null) {
        int lifeToLose=(int)Math.ceil(player.getLife() / 3.0);
        player.loseLife(lifeToLose,game);
      }
    }
    for (    UUID playerId : game.getState().getPlayersInRange(controller.getId(),game)) {
      Player player=game.getPlayer(playerId);
      if (player != null) {
        int cardsToDiscard=(int)Math.ceil(player.getHand().size() / 3.0);
        if (cardsToDiscard > 0) {
          player.discard(cardsToDiscard,false,source,game);
        }
      }
    }
    for (    UUID playerId : game.getState().getPlayersInRange(controller.getId(),game)) {
      Player player=game.getPlayer(playerId);
      if (player != null) {
        FilterControlledCreaturePermanent filter=new FilterControlledCreaturePermanent();
        int creaturesToSacrifice=(int)Math.ceil(game.getBattlefield().count(filter,source.getSourceId(),player.getId(),game) / 3.0);
        if (creaturesToSacrifice > 0) {
          Target target=new TargetControlledCreaturePermanent(creaturesToSacrifice,creaturesToSacrifice,filter,true);
          target.chooseTarget(Outcome.Sacrifice,playerId,source,game);
          for (          UUID permanentId : target.getTargets()) {
            Permanent permanent=game.getPermanent(permanentId);
            if (permanent != null) {
              permanent.sacrifice(source.getSourceId(),game);
            }
          }
        }
      }
    }
    for (    UUID playerId : game.getState().getPlayersInRange(controller.getId(),game)) {
      Player player=game.getPlayer(playerId);
      if (player != null) {
        FilterControlledLandPermanent filter=new FilterControlledLandPermanent();
        int landsToSacrifice=(int)Math.ceil(game.getBattlefield().count(filter,source.getSourceId(),player.getId(),game) / 3.0);
        if (landsToSacrifice > 0) {
          Target target=new TargetControlledPermanent(landsToSacrifice,landsToSacrifice,filter,true);
          target.chooseTarget(Outcome.Sacrifice,playerId,source,game);
          for (          UUID permanentId : target.getTargets()) {
            Permanent permanent=game.getPermanent(permanentId);
            if (permanent != null) {
              permanent.sacrifice(source.getSourceId(),game);
            }
          }
        }
      }
    }
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller != null) {
    for (    UUID playerId : game.getState().getPlayersInRange(controller.getId(),game)) {
      Player player=game.getPlayer(playerId);
      if (player != null) {
        int lifeToLose=(int)Math.ceil(player.getLife() / 3.0);
        player.loseLife(lifeToLose,game,false);
      }
    }
    for (    UUID playerId : game.getState().getPlayersInRange(controller.getId(),game)) {
      Player player=game.getPlayer(playerId);
      if (player != null) {
        int cardsToDiscard=(int)Math.ceil(player.getHand().size() / 3.0);
        if (cardsToDiscard > 0) {
          player.discard(cardsToDiscard,false,source,game);
        }
      }
    }
    for (    UUID playerId : game.getState().getPlayersInRange(controller.getId(),game)) {
      Player player=game.getPlayer(playerId);
      if (player != null) {
        FilterControlledCreaturePermanent filter=new FilterControlledCreaturePermanent();
        int creaturesToSacrifice=(int)Math.ceil(game.getBattlefield().count(filter,source.getSourceId(),player.getId(),game) / 3.0);
        if (creaturesToSacrifice > 0) {
          Target target=new TargetControlledCreaturePermanent(creaturesToSacrifice,creaturesToSacrifice,filter,true);
          target.chooseTarget(Outcome.Sacrifice,playerId,source,game);
          for (          UUID permanentId : target.getTargets()) {
            Permanent permanent=game.getPermanent(permanentId);
            if (permanent != null) {
              permanent.sacrifice(source.getSourceId(),game);
            }
          }
        }
      }
    }
    for (    UUID playerId : game.getState().getPlayersInRange(controller.getId(),game)) {
      Player player=game.getPlayer(playerId);
      if (player != null) {
        FilterControlledLandPermanent filter=new FilterControlledLandPermanent();
        int landsToSacrifice=(int)Math.ceil(game.getBattlefield().count(filter,source.getSourceId(),player.getId(),game) / 3.0);
        if (landsToSacrifice > 0) {
          Target target=new TargetControlledPermanent(landsToSacrifice,landsToSacrifice,filter,true);
          target.chooseTarget(Outcome.Sacrifice,playerId,source,game);
          for (          UUID permanentId : target.getTargets()) {
            Permanent permanent=game.getPermanent(permanentId);
            if (permanent != null) {
              permanent.sacrifice(source.getSourceId(),game);
            }
          }
        }
      }
    }
    return true;
  }
  return false;
}",0.9988425925925926
158394,"@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller != null) {
    int creaturesControlled=game.getBattlefield().countAll(new FilterCreaturePermanent(),controller.getId(),game);
    controller.drawCards(creaturesControlled,game);
    controller.loseLife(creaturesControlled,game);
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller != null) {
    int creaturesControlled=game.getBattlefield().countAll(new FilterCreaturePermanent(),controller.getId(),game);
    controller.drawCards(creaturesControlled,game);
    controller.loseLife(creaturesControlled,game,false);
    return true;
  }
  return false;
}",0.9926289926289926
158395,"@Override public boolean apply(Game game,Ability source){
  Card sourceCard=game.getCard(source.getSourceId());
  if (sourceCard == null) {
    return false;
  }
  for (  Player player : game.getPlayers().values()) {
    if (player.getLibrary().size() > 0) {
      Card card=player.getLibrary().removeFromTop(game);
      if (card != null) {
        Cards cards=new CardsImpl();
        cards.add(card);
        player.revealCards(sourceCard.getName() + ""String_Node_Str"" + player.getName(),cards,game);
        player.loseLife(card.getConvertedManaCost(),game);
        card.moveToZone(Zone.HAND,source.getSourceId(),game,true);
      }
    }
  }
  return true;
}","@Override public boolean apply(Game game,Ability source){
  Card sourceCard=game.getCard(source.getSourceId());
  if (sourceCard == null) {
    return false;
  }
  for (  Player player : game.getPlayers().values()) {
    if (player.getLibrary().size() > 0) {
      Card card=player.getLibrary().removeFromTop(game);
      if (card != null) {
        Cards cards=new CardsImpl();
        cards.add(card);
        player.revealCards(sourceCard.getName() + ""String_Node_Str"" + player.getName(),cards,game);
        player.loseLife(card.getConvertedManaCost(),game,false);
        card.moveToZone(Zone.HAND,source.getSourceId(),game,true);
      }
    }
  }
  return true;
}",0.9955022488755624
158396,"@Override public boolean apply(Game game,Ability source){
  Permanent target=game.getPermanent(getTargetPointer().getFirst(game,source));
  Player controller=game.getPlayer(source.getControllerId());
  if (target != null && controller != null) {
    int toughness=target.getToughness().getValue();
    target.destroy(source.getSourceId(),game,false);
    if (toughness > 0) {
      controller.loseLife(toughness,game);
    }
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Permanent target=game.getPermanent(getTargetPointer().getFirst(game,source));
  Player controller=game.getPlayer(source.getControllerId());
  if (target != null && controller != null) {
    int toughness=target.getToughness().getValue();
    target.destroy(source.getSourceId(),game,false);
    if (toughness > 0) {
      controller.loseLife(toughness,game,false);
    }
    return true;
  }
  return false;
}",0.9935622317596566
158397,"@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  Player targetPlayer=game.getPlayer(source.getFirstTarget());
  Card sourceCard=game.getCard(source.getSourceId());
  if (controller != null && targetPlayer != null && sourceCard != null) {
    int payLife=controller.getAmount(0,controller.getLife(),""String_Node_Str"",game);
    if (payLife > 0) {
      controller.loseLife(payLife,game);
      game.informPlayers(new StringBuilder(sourceCard.getName()).append(""String_Node_Str"").append(controller.getLogName()).append(""String_Node_Str"").append(payLife).append(""String_Node_Str"").toString());
      Cards cardsInHand=new CardsImpl();
      cardsInHand.addAll(targetPlayer.getHand());
      int count=Math.min(cardsInHand.size(),payLife);
      TargetCard target=new TargetCard(count,Zone.HAND,new FilterCard());
      Cards revealedCards=new CardsImpl();
      if (targetPlayer.chooseTarget(Outcome.Discard,cardsInHand,target,source,game)) {
        List<UUID> targets=target.getTargets();
        for (        UUID targetId : targets) {
          Card card=game.getCard(targetId);
          if (card != null) {
            revealedCards.add(card);
          }
        }
      }
      TargetCard targetInHand=new TargetCard(Zone.HAND,new FilterCard(""String_Node_Str""));
      if (!revealedCards.isEmpty()) {
        targetPlayer.revealCards(sourceCard.getName(),revealedCards,game);
        controller.chooseTarget(Outcome.Exile,revealedCards,targetInHand,source,game);
        Card card=revealedCards.get(targetInHand.getFirstTarget(),game);
        if (card != null) {
          controller.moveCardToExileWithInfo(card,null,null,source.getSourceId(),game,Zone.HAND,true);
        }
      }
      return true;
    }
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  Player targetPlayer=game.getPlayer(source.getFirstTarget());
  Card sourceCard=game.getCard(source.getSourceId());
  if (controller != null && targetPlayer != null && sourceCard != null) {
    int payLife=controller.getAmount(0,controller.getLife(),""String_Node_Str"",game);
    if (payLife > 0) {
      controller.loseLife(payLife,game,false);
      game.informPlayers(new StringBuilder(sourceCard.getName()).append(""String_Node_Str"").append(controller.getLogName()).append(""String_Node_Str"").append(payLife).append(""String_Node_Str"").toString());
      Cards cardsInHand=new CardsImpl();
      cardsInHand.addAll(targetPlayer.getHand());
      int count=Math.min(cardsInHand.size(),payLife);
      TargetCard target=new TargetCard(count,Zone.HAND,new FilterCard());
      Cards revealedCards=new CardsImpl();
      if (targetPlayer.chooseTarget(Outcome.Discard,cardsInHand,target,source,game)) {
        List<UUID> targets=target.getTargets();
        for (        UUID targetId : targets) {
          Card card=game.getCard(targetId);
          if (card != null) {
            revealedCards.add(card);
          }
        }
      }
      TargetCard targetInHand=new TargetCard(Zone.HAND,new FilterCard(""String_Node_Str""));
      if (!revealedCards.isEmpty()) {
        targetPlayer.revealCards(sourceCard.getName(),revealedCards,game);
        controller.chooseTarget(Outcome.Exile,revealedCards,targetInHand,source,game);
        Card card=revealedCards.get(targetInHand.getFirstTarget(),game);
        if (card != null) {
          controller.moveCardToExileWithInfo(card,null,null,source.getSourceId(),game,Zone.HAND,true);
        }
      }
      return true;
    }
  }
  return false;
}",0.9983443708609272
158398,"@Override public boolean apply(Game game,Ability source){
  Integer amountLifeGained=(Integer)this.getValue(""String_Node_Str"");
  if (amountLifeGained != null) {
    for (    UUID opponentId : game.getOpponents(source.getControllerId())) {
      Player opponent=game.getPlayer(opponentId);
      if (opponent != null) {
        opponent.loseLife(amountLifeGained,game);
      }
    }
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Integer amountLifeGained=(Integer)this.getValue(""String_Node_Str"");
  if (amountLifeGained != null) {
    for (    UUID opponentId : game.getOpponents(source.getControllerId())) {
      Player opponent=game.getPlayer(opponentId);
      if (opponent != null) {
        opponent.loseLife(amountLifeGained,game,false);
      }
    }
  }
  return false;
}",0.9926470588235294
158399,"@Override public boolean apply(Game game,Ability source){
  int loseLife=0;
  for (  UUID opponentId : game.getOpponents(source.getControllerId())) {
    loseLife+=game.getPlayer(opponentId).loseLife(1,game);
  }
  if (loseLife > 0)   game.getPlayer(source.getControllerId()).gainLife(loseLife,game);
  return true;
}","@Override public boolean apply(Game game,Ability source){
  int loseLife=0;
  for (  UUID opponentId : game.getOpponents(source.getControllerId())) {
    loseLife+=game.getPlayer(opponentId).loseLife(1,game,false);
  }
  if (loseLife > 0)   game.getPlayer(source.getControllerId()).gainLife(loseLife,game);
  return true;
}",0.990625
158400,"@Override public boolean apply(Game game,Ability source){
  Player targetPlayer=game.getPlayer(source.getFirstTarget());
  Player controllerPlayer=game.getPlayer(source.getControllerId());
  if (targetPlayer != null && controllerPlayer != null) {
    targetPlayer.loseLife(1,game);
    controllerPlayer.gainLife(1,game);
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Player targetPlayer=game.getPlayer(source.getFirstTarget());
  Player controllerPlayer=game.getPlayer(source.getControllerId());
  if (targetPlayer != null && controllerPlayer != null) {
    targetPlayer.loseLife(1,game,false);
    controllerPlayer.gainLife(1,game);
  }
  return false;
}",0.991304347826087
158401,"@Override public boolean apply(Game game,Ability source){
  Integer amount=(Integer)this.getValue(""String_Node_Str"");
  Player player=game.getPlayer(source.getControllerId());
  if (player != null) {
    player.gainLife(amount,game);
  }
  UUID attackerId=(UUID)this.getValue(""String_Node_Str"");
  Player attacker=game.getPlayer(attackerId);
  if (attacker != null) {
    attacker.loseLife(amount,game);
  }
  return true;
}","@Override public boolean apply(Game game,Ability source){
  Integer amount=(Integer)this.getValue(""String_Node_Str"");
  Player player=game.getPlayer(source.getControllerId());
  if (player != null) {
    player.gainLife(amount,game);
  }
  UUID attackerId=(UUID)this.getValue(""String_Node_Str"");
  Player attacker=game.getPlayer(attackerId);
  if (attacker != null) {
    attacker.loseLife(amount,game,false);
  }
  return true;
}",0.9929742388758782
158402,"public Modes(final Modes modes){
  for (  Map.Entry<UUID,Mode> entry : modes.entrySet()) {
    this.put(entry.getKey(),entry.getValue().copy());
  }
  this.minModes=modes.minModes;
  this.maxModes=modes.maxModes;
  this.currentMode=values().iterator().next();
  selectedModes.addAll(modes.getSelectedModes());
  this.modeChooser=modes.modeChooser;
  this.eachModeOnlyOnce=modes.eachModeOnlyOnce;
  this.eachModeMoreThanOnce=modes.eachModeMoreThanOnce;
}","public Modes(final Modes modes){
  for (  Map.Entry<UUID,Mode> entry : modes.entrySet()) {
    this.put(entry.getKey(),entry.getValue().copy());
  }
  this.minModes=modes.minModes;
  this.maxModes=modes.maxModes;
  this.selectedModes.addAll(modes.getSelectedModes());
  if (modes.getSelectedModes().isEmpty()) {
    this.currentMode=values().iterator().next();
  }
 else {
    this.currentMode=get(selectedModes.get(0));
  }
  this.modeChooser=modes.modeChooser;
  this.eachModeOnlyOnce=modes.eachModeOnlyOnce;
  this.eachModeMoreThanOnce=modes.eachModeMoreThanOnce;
}",0.801175318315377
158403,"@Override public boolean applies(GameEvent event,Ability source,Game game){
  if (event.getTargetId().equals(source.getSourceId())) {
    ZoneChangeEvent zEvent=(ZoneChangeEvent)event;
    if (zEvent.getFromZone() == Zone.STACK && source.getSourceId().equals(event.getSourceId())) {
      return true;
    }
  }
  return false;
}","@Override public boolean applies(GameEvent event,Ability source,Game game){
  if (event.getTargetId().equals(source.getSourceId())) {
    ZoneChangeEvent zEvent=(ZoneChangeEvent)event;
    if (zEvent.getFromZone() == Zone.STACK && zEvent.getToZone() == Zone.GRAVEYARD && source.getSourceId().equals(event.getSourceId())) {
      return true;
    }
  }
  return false;
}",0.9426934097421203
158404,"/** 
 * Tatterkite is getting counters on it, i have him in a edh deck with Mikaeus, the Lunarch and when Tatterkite dies it triggers the undying and he gets the +1/+1 counters
 */
@Test public void testUndyingMikaeusAndTatterkite(){
  addCard(Zone.HAND,playerA,""String_Node_Str"",1);
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"",1);
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"",1);
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"",1);
  castSpell(1,PhaseStep.PRECOMBAT_MAIN,playerA,""String_Node_Str"",""String_Node_Str"");
  setStopAt(1,PhaseStep.BEGIN_COMBAT);
  execute();
  assertGraveyardCount(playerA,""String_Node_Str"",1);
  assertPermanentCount(playerA,""String_Node_Str"",1);
  assertPermanentCount(playerA,""String_Node_Str"",1);
  assertCounterCount(""String_Node_Str"",CounterType.P1P1,0);
  assertPowerToughness(playerA,""String_Node_Str"",3,2);
}","/** 
 * Tatterkite is getting counters on it, I have him in a edh deck with Mikaeus, the Lunarch and when Tatterkite dies it triggers the undying and he gets the +1/+1 counters
 */
@Test public void testUndyingMikaeusAndTatterkite(){
  addCard(Zone.HAND,playerA,""String_Node_Str"",1);
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"",1);
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"",1);
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"",1);
  castSpell(1,PhaseStep.PRECOMBAT_MAIN,playerA,""String_Node_Str"",""String_Node_Str"");
  setStopAt(1,PhaseStep.BEGIN_COMBAT);
  execute();
  assertGraveyardCount(playerA,""String_Node_Str"",1);
  assertPermanentCount(playerA,""String_Node_Str"",1);
  assertPermanentCount(playerA,""String_Node_Str"",1);
  assertCounterCount(""String_Node_Str"",CounterType.P1P1,0);
  assertPowerToughness(playerA,""String_Node_Str"",3,2);
}",0.9988465974625144
158405,"@Override public boolean isInUseableZone(Game game,MageObject source,GameEvent event){
  if (game.getShortLivingLKI(getSourceId(),zone)) {
    return true;
  }
  return super.isInUseableZone(game,source,event);
}","@Override public boolean isInUseableZone(Game game,MageObject source,GameEvent event){
  if (game.getShortLivingLKI(getSourceId(),zone)) {
    return true;
  }
  if (game.getPermanentEntering(getSourceId()) != null && zone.equals(Zone.BATTLEFIELD)) {
    return true;
  }
  return super.isInUseableZone(game,source,event);
}",0.7910447761194029
158406,"@Override public boolean moveToZone(Zone toZone,UUID sourceId,Game game,boolean flag,ArrayList<UUID> appliedEffects){
  Zone fromZone=game.getState().getZone(objectId);
  ZoneChangeEvent event=new ZoneChangeEvent(this.objectId,sourceId,ownerId,fromZone,toZone,appliedEffects);
  ZoneChangeInfo zoneChangeInfo;
  if (toZone == Zone.LIBRARY) {
    zoneChangeInfo=new ZoneChangeInfo.Library(event,flag);
  }
 else   if (toZone == Zone.BATTLEFIELD) {
    zoneChangeInfo=new ZoneChangeInfo.Battlefield(event,flag);
  }
 else {
    zoneChangeInfo=new ZoneChangeInfo(event);
  }
  return ZonesHandler.moveCard(zoneChangeInfo,game);
}","@Override public boolean moveToZone(Zone toZone,UUID sourceId,Game game,boolean flag,ArrayList<UUID> appliedEffects){
  Zone fromZone=game.getState().getZone(objectId);
  ZoneChangeEvent event=new ZoneChangeEvent(this.objectId,sourceId,ownerId,fromZone,toZone,appliedEffects);
  ZoneChangeInfo zoneChangeInfo;
  if (null != toZone) {
switch (toZone) {
case LIBRARY:
      zoneChangeInfo=new ZoneChangeInfo.Library(event,flag);
    break;
case BATTLEFIELD:
  zoneChangeInfo=new ZoneChangeInfo.Battlefield(event,flag);
break;
default :
zoneChangeInfo=new ZoneChangeInfo(event);
break;
}
return ZonesHandler.moveCard(zoneChangeInfo,game);
}
return false;
}",0.7584050039093041
158407,"@Override public boolean putCardsOnBottomOfLibrary(Cards cards,Game game,Ability source,boolean anyOrder){
  if (!cards.isEmpty()) {
    if (!anyOrder) {
      for (      UUID objectId : cards) {
        moveObjectToLibrary(objectId,source == null ? null : source.getSourceId(),game,false,false);
      }
    }
 else {
      TargetCard target=new TargetCard(Zone.ALL,new FilterCard(""String_Node_Str""));
      target.setRequired(true);
      while (isInGame() && cards.size() > 1) {
        this.choose(Outcome.Neutral,cards,target,game);
        UUID targetObjectId=target.getFirstTarget();
        cards.remove(targetObjectId);
        moveObjectToLibrary(targetObjectId,source == null ? null : source.getSourceId(),game,false,false);
        target.clearChosen();
      }
      if (cards.size() == 1) {
        moveObjectToLibrary(cards.iterator().next(),source == null ? null : source.getSourceId(),game,false,false);
      }
    }
  }
  return true;
}","@Override public boolean putCardsOnBottomOfLibrary(Cards cardsToLibrary,Game game,Ability source,boolean anyOrder){
  if (!cardsToLibrary.isEmpty()) {
    Cards cards=new CardsImpl(cardsToLibrary);
    if (!anyOrder) {
      for (      UUID objectId : cards) {
        moveObjectToLibrary(objectId,source == null ? null : source.getSourceId(),game,false,false);
      }
    }
 else {
      TargetCard target=new TargetCard(Zone.ALL,new FilterCard(""String_Node_Str""));
      target.setRequired(true);
      while (isInGame() && cards.size() > 1) {
        this.choose(Outcome.Neutral,cards,target,game);
        UUID targetObjectId=target.getFirstTarget();
        cards.remove(targetObjectId);
        moveObjectToLibrary(targetObjectId,source == null ? null : source.getSourceId(),game,false,false);
        target.clearChosen();
      }
      if (cards.size() == 1) {
        moveObjectToLibrary(cards.iterator().next(),source == null ? null : source.getSourceId(),game,false,false);
      }
    }
  }
  return true;
}",0.9670886075949368
158408,"@Override public boolean removeFromZone(Game game,Zone fromZone,UUID sourceId){
  boolean removed=false;
  MageObject lkiObject=null;
switch (fromZone) {
case GRAVEYARD:
    removed=game.getPlayer(ownerId).removeFromGraveyard(this,game);
  break;
case HAND:
removed=game.getPlayer(ownerId).removeFromHand(this,game);
break;
case LIBRARY:
removed=game.getPlayer(ownerId).removeFromLibrary(this,game);
break;
case EXILED:
if (game.getExile().getCard(getId(),game) != null) {
removed=game.getExile().removeCard(this,game);
}
break;
case STACK:
StackObject stackObject;
if (getSpellAbility() != null) {
stackObject=game.getStack().getSpell(getSpellAbility().getId());
}
 else {
stackObject=game.getStack().getSpell(this.getId());
}
if (stackObject == null && (this instanceof SplitCard)) {
stackObject=game.getStack().getSpell(((SplitCard)this).getLeftHalfCard().getId());
if (stackObject == null) {
stackObject=game.getStack().getSpell(((SplitCard)this).getRightHalfCard().getId());
}
}
if (stackObject == null) {
stackObject=game.getStack().getSpell(getId());
}
if (stackObject != null) {
removed=game.getStack().remove(stackObject);
lkiObject=stackObject;
}
break;
case COMMAND:
lkiObject=(Commander)game.getObject(objectId);
if (lkiObject != null) {
removed=game.getState().getCommand().remove((Commander)game.getObject(objectId));
}
break;
case OUTSIDE:
if (isCopy()) {
removed=true;
}
 else if (game.getPlayer(ownerId).getSideboard().contains(this.getId())) {
game.getPlayer(ownerId).getSideboard().remove(this.getId());
removed=true;
}
break;
case BATTLEFIELD:
removed=true;
break;
default :
MageObject sourceObject=game.getObject(sourceId);
logger.fatal(""String_Node_Str"" + fromZone + ""String_Node_Str""+ this.getIdName()+ ""String_Node_Str""+ (sourceObject != null ? sourceObject.getName() : ""String_Node_Str"")+ ""String_Node_Str"");
break;
}
if (removed) {
game.rememberLKI(lkiObject != null ? lkiObject.getId() : objectId,fromZone,lkiObject != null ? lkiObject : this);
}
 else {
logger.warn(""String_Node_Str"" + getIdName() + ""String_Node_Str""+ fromZone);
}
return removed;
}","@Override public boolean removeFromZone(Game game,Zone fromZone,UUID sourceId){
  boolean removed=false;
  MageObject lkiObject=null;
switch (fromZone) {
case GRAVEYARD:
    removed=game.getPlayer(ownerId).removeFromGraveyard(this,game);
  break;
case HAND:
removed=game.getPlayer(ownerId).removeFromHand(this,game);
break;
case LIBRARY:
removed=game.getPlayer(ownerId).removeFromLibrary(this,game);
break;
case EXILED:
if (game.getExile().getCard(getId(),game) != null) {
removed=game.getExile().removeCard(this,game);
}
break;
case STACK:
StackObject stackObject;
if (getSpellAbility() != null) {
stackObject=game.getStack().getSpell(getSpellAbility().getId());
}
 else {
stackObject=game.getStack().getSpell(this.getId());
}
if (stackObject == null && (this instanceof SplitCard)) {
stackObject=game.getStack().getSpell(((SplitCard)this).getLeftHalfCard().getId());
if (stackObject == null) {
stackObject=game.getStack().getSpell(((SplitCard)this).getRightHalfCard().getId());
}
}
if (stackObject == null) {
stackObject=game.getStack().getSpell(getId());
}
if (stackObject != null) {
removed=game.getStack().remove(stackObject);
lkiObject=stackObject;
}
break;
case COMMAND:
lkiObject=(Commander)game.getObject(objectId);
if (lkiObject != null) {
removed=game.getState().getCommand().remove((Commander)game.getObject(objectId));
}
break;
case OUTSIDE:
if (isCopy()) {
removed=true;
}
 else if (game.getPlayer(ownerId).getSideboard().contains(this.getId())) {
game.getPlayer(ownerId).getSideboard().remove(this.getId());
removed=true;
}
 else if (game.getPhase() == null) {
removed=true;
}
break;
case BATTLEFIELD:
removed=true;
break;
default :
MageObject sourceObject=game.getObject(sourceId);
logger.fatal(""String_Node_Str"" + fromZone + ""String_Node_Str""+ this.getIdName()+ ""String_Node_Str""+ (sourceObject != null ? sourceObject.getName() : ""String_Node_Str"")+ ""String_Node_Str"");
break;
}
if (removed) {
if (!fromZone.equals(Zone.OUTSIDE)) {
game.rememberLKI(lkiObject != null ? lkiObject.getId() : objectId,fromZone,lkiObject != null ? lkiObject : this);
}
}
 else {
logger.warn(""String_Node_Str"" + getIdName() + ""String_Node_Str""+ fromZone);
}
return removed;
}",0.978102189781022
158409,"public static List<ZoneChangeInfo> moveCards(List<ZoneChangeInfo> zoneChangeInfos,Game game){
  for (ListIterator<ZoneChangeInfo> itr=zoneChangeInfos.listIterator(); itr.hasNext(); ) {
    ZoneChangeInfo info=itr.next();
    MeldCard card=game.getMeldCard(info.event.getTargetId());
    if (card != null && !card.isMelded() && !card.isCopy()) {
      ZoneChangeInfo.Unmelded unmelded=new ZoneChangeInfo.Unmelded(info,game);
      if (unmelded.subInfo.isEmpty()) {
        itr.remove();
      }
 else {
        itr.set(unmelded);
      }
    }
  }
  for (Iterator<ZoneChangeInfo> itr=zoneChangeInfos.iterator(); itr.hasNext(); ) {
    if (!maybeRemoveFromSourceZone(itr.next(),game)) {
      itr.remove();
    }
  }
  for (  ZoneChangeInfo zoneChangeInfo : zoneChangeInfos) {
    placeInDestinationZone(zoneChangeInfo,game);
    game.addSimultaneousEvent(zoneChangeInfo.event);
  }
  return zoneChangeInfos;
}","public static List<ZoneChangeInfo> moveCards(List<ZoneChangeInfo> zoneChangeInfos,Game game){
  for (ListIterator<ZoneChangeInfo> itr=zoneChangeInfos.listIterator(); itr.hasNext(); ) {
    ZoneChangeInfo info=itr.next();
    MeldCard card=game.getMeldCard(info.event.getTargetId());
    if (card != null && !card.isMelded() && !card.isCopy()) {
      ZoneChangeInfo.Unmelded unmelded=new ZoneChangeInfo.Unmelded(info,game);
      if (unmelded.subInfo.isEmpty()) {
        itr.remove();
      }
 else {
        itr.set(unmelded);
      }
    }
  }
  for (Iterator<ZoneChangeInfo> itr=zoneChangeInfos.iterator(); itr.hasNext(); ) {
    if (!maybeRemoveFromSourceZone(itr.next(),game)) {
      itr.remove();
    }
  }
  for (  ZoneChangeInfo zoneChangeInfo : zoneChangeInfos) {
    placeInDestinationZone(zoneChangeInfo,game);
    if (game.getPhase() != null) {
      game.addSimultaneousEvent(zoneChangeInfo.event);
    }
  }
  return zoneChangeInfos;
}",0.9768692845615924
158410,"@Override public boolean apply(Game game,Ability source){
  Permanent permanent=affectedObjectList.get(0).getPermanent(game);
  if (permanent == null) {
    permanent=(Permanent)game.getLastKnownInformation(getSourceId(),Zone.BATTLEFIELD,source.getSourceObjectZoneChangeCounter());
    if (permanent == null) {
      discard();
      return false;
    }
  }
  return copyToPermanent(permanent,game,source);
}","@Override public boolean apply(Game game,Ability source){
  if (affectedObjectList.isEmpty()) {
    this.discard();
    return false;
  }
  Permanent permanent=affectedObjectList.get(0).getPermanent(game);
  if (permanent == null) {
    permanent=(Permanent)game.getLastKnownInformation(getSourceId(),Zone.BATTLEFIELD,source.getSourceObjectZoneChangeCounter());
    if (permanent == null) {
      discard();
      return false;
    }
  }
  return copyToPermanent(permanent,game,source);
}",0.9107142857142856
158411,"@Override public boolean apply(Game game,Ability source){
  Player targetPlayer=game.getPlayer(targetPointer.getFirst(game,source));
  Player controller=game.getPlayer(source.getControllerId());
  MageObject sourceObject=game.getObject(source.getSourceId());
  if (targetPlayer != null && controller != null && sourceObject != null) {
    String cardName=(String)game.getState().getValue(source.getSourceId().toString() + NameACardEffect.INFO_KEY);
    for (    Card card : targetPlayer.getHand().getCards(game)) {
      if (card.getName().equals(cardName)) {
        targetPlayer.discard(card,source,game);
      }
    }
    controller.lookAtCards(sourceObject.getName() + ""String_Node_Str"",targetPlayer.getHand(),game);
  }
  return true;
}","@Override public boolean apply(Game game,Ability source){
  Player targetPlayer=game.getPlayer(targetPointer.getFirst(game,source));
  Player controller=game.getPlayer(source.getControllerId());
  MageObject sourceObject=game.getObject(source.getSourceId());
  if (targetPlayer != null && controller != null && sourceObject != null) {
    String cardName=(String)game.getState().getValue(source.getSourceId().toString() + NameACardEffect.INFO_KEY);
    Cards hand=targetPlayer.getHand();
    for (    Card card : hand.getCards(game)) {
      if (card.getName().equals(cardName)) {
        targetPlayer.discard(card,source,game);
      }
    }
    targetPlayer.revealCards(""String_Node_Str"",hand,game);
  }
  return true;
}",0.8961748633879781
158412,"private static BufferedImage createImage(Key key){
  int cardWidth=key.cardWidth;
  int cardHeight=key.cardHeight;
  int cardXOffset=key.cardXOffset;
  int cardYOffset=key.cardYOffset;
  BufferedImage image=GraphicsUtilities.createCompatibleTranslucentImage(key.width,key.height);
  Graphics2D g2d=image.createGraphics();
  g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING,RenderingHints.VALUE_ANTIALIAS_ON);
  if (!key.hasImage) {
    g2d.setColor(new Color(30,200,200,120));
  }
 else {
    g2d.setColor(new Color(0,0,0,255));
  }
  int cornerSize=Math.max(4,Math.round(cardWidth * ROUNDED_CORNER_SIZE));
  g2d.fillRoundRect(cardXOffset,cardYOffset,cardWidth,cardHeight,cornerSize,cornerSize);
  if (key.isSelected) {
    g2d.setColor(Color.green);
    g2d.fillRoundRect(cardXOffset + 1,cardYOffset + 1,cardWidth - 2,cardHeight - 2,cornerSize,cornerSize);
  }
 else   if (key.isChoosable) {
    g2d.setColor(new Color(250,250,0,230));
    g2d.fillRoundRect(cardXOffset + 1,cardYOffset + 1,cardWidth - 2,cardHeight - 2,cornerSize,cornerSize);
  }
 else   if (key.isPlayable) {
    g2d.setColor(new Color(153,102,204,200));
    g2d.fillRoundRect(cardXOffset,cardYOffset,cardWidth,cardHeight,cornerSize,cornerSize);
  }
  if (key.canAttack) {
    g2d.setColor(new Color(0,0,255,230));
    g2d.fillRoundRect(cardXOffset + 1,cardYOffset + 1,cardWidth - 2,cardHeight - 2,cornerSize,cornerSize);
  }
  g2d.dispose();
  return image;
}","private static BufferedImage createImage(Key key){
  int cardWidth=key.cardWidth;
  int cardHeight=key.cardHeight;
  int cardXOffset=key.cardXOffset;
  int cardYOffset=key.cardYOffset;
  BufferedImage image=GraphicsUtilities.createCompatibleTranslucentImage(key.width,key.height);
  Graphics2D g2d=image.createGraphics();
  g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING,RenderingHints.VALUE_ANTIALIAS_ON);
  if (!key.hasImage) {
    g2d.setColor(new Color(30,200,200,120));
  }
 else {
    g2d.setColor(new Color(0,0,0,0));
  }
  int cornerSize=Math.max(4,Math.round(cardWidth * ROUNDED_CORNER_SIZE));
  g2d.fillRoundRect(cardXOffset,cardYOffset,cardWidth,cardHeight,cornerSize,cornerSize);
  if (key.isSelected) {
    g2d.setColor(Color.green);
    g2d.fillRoundRect(cardXOffset + 1,cardYOffset + 1,cardWidth - 2,cardHeight - 2,cornerSize,cornerSize);
  }
 else   if (key.isChoosable) {
    g2d.setColor(new Color(250,250,0,230));
    g2d.fillRoundRect(cardXOffset + 1,cardYOffset + 1,cardWidth - 2,cardHeight - 2,cornerSize,cornerSize);
  }
 else   if (key.isPlayable) {
    g2d.setColor(new Color(153,102,204,200));
    g2d.fillRoundRect(cardXOffset,cardYOffset,cardWidth,cardHeight,cornerSize,cornerSize);
  }
  if (key.canAttack) {
    g2d.setColor(new Color(0,0,255,230));
    g2d.fillRoundRect(cardXOffset + 1,cardYOffset + 1,cardWidth - 2,cardHeight - 2,cornerSize,cornerSize);
  }
  g2d.dispose();
  return image;
}",0.9986033519553073
158413,"/** 
 * Swap cards between specified card from library and any hand card.
 * @param game
 * @param card Card to put to player's hand
 */
private static void swapWithAnyCard(Game game,Player player,Card card,Zone zone){
  game.getExile().getPermanentExile().add(card);
  game.setZone(card.getId(),Zone.EXILED);
  if (zone.equals(Zone.BATTLEFIELD)) {
    card.putOntoBattlefield(game,Zone.EXILED,null,player.getId());
  }
 else   if (zone.equals(Zone.LIBRARY)) {
    card.setZone(Zone.LIBRARY,game);
    player.getLibrary().putOnTop(card,game);
  }
 else {
    card.moveToZone(zone,null,game,false);
  }
  logger.info(""String_Node_Str"" + zone.toString() + ""String_Node_Str""+ card.getName()+ ""String_Node_Str""+ player.getName());
}","/** 
 * Swap cards between specified card from library and any hand card.
 * @param game
 * @param card Card to put to player's hand
 */
private static void swapWithAnyCard(Game game,Player player,Card card,Zone zone){
  game.getExile().getPermanentExile().add(card);
  game.setZone(card.getId(),Zone.EXILED);
  if (zone.equals(Zone.BATTLEFIELD)) {
    card.putOntoBattlefield(game,Zone.EXILED,null,player.getId());
  }
 else   if (zone.equals(Zone.LIBRARY)) {
    card.setZone(Zone.LIBRARY,game);
    game.getExile().getPermanentExile().remove(card);
    player.getLibrary().putOnTop(card,game);
  }
 else {
    card.moveToZone(zone,null,game,false);
  }
  logger.info(""String_Node_Str"" + zone.toString() + ""String_Node_Str""+ card.getName()+ ""String_Node_Str""+ player.getName());
}",0.9642384105960264
158414,"@Override public boolean apply(Game game,Ability source){
  for (  UUID targetID : this.targetPointer.getTargets(game,source)) {
    Permanent permanent=game.getPermanent(targetID);
    if (permanent != null) {
      if (permanent.destroy(source.getSourceId(),game,false)) {
        if (game.getState().getZone(permanent.getId()) == Zone.GRAVEYARD) {
          Player controller=game.getPlayer(permanent.getControllerId());
          ElephantToken elephantToken=new ElephantToken();
          elephantToken.putOntoBattlefield(1,game,source.getSourceId(),controller.getId());
        }
      }
    }
  }
  return true;
}","@Override public boolean apply(Game game,Ability source){
  HashMap<UUID,Integer> destroyedPermanents=new HashMap<>();
  for (  UUID targetID : this.targetPointer.getTargets(game,source)) {
    Permanent permanent=game.getPermanent(targetID);
    if (permanent != null) {
      if (permanent.destroy(source.getSourceId(),game,false)) {
        if (game.getState().getZone(permanent.getId()) == Zone.GRAVEYARD) {
          int numberPermanents=0;
          if (destroyedPermanents.containsKey(permanent.getControllerId())) {
            numberPermanents=destroyedPermanents.get(permanent.getControllerId());
          }
          destroyedPermanents.put(permanent.getControllerId(),numberPermanents);
        }
      }
    }
  }
  ElephantToken elephantToken=new ElephantToken();
  for (  Entry<UUID,Integer> entry : destroyedPermanents.entrySet()) {
    elephantToken.putOntoBattlefield(entry.getValue(),game,source.getSourceId(),entry.getKey());
  }
  return true;
}",0.6733921815889029
158415,"@Override public void adjustTargets(Ability ability,Game game){
  if (ability.getOriginalId().equals(abilityId)) {
    Card sourceCard=game.getCard(ability.getSourceId());
    if (sourceCard != null) {
      ability.getTargets().clear();
      FilterPlayer filter=new FilterPlayer(""String_Node_Str"" + sourceCard.getIdName() + ""String_Node_Str"");
      filter.add(Predicates.not(new OwnerIdPredicate(sourceCard.getOwnerId())));
      ability.addTarget(new TargetPlayer(1,1,false,filter));
    }
  }
}","@Override public void adjustTargets(Ability ability,Game game){
  if (ability.getOriginalId().equals(abilityId)) {
    Card sourceCard=game.getCard(ability.getSourceId());
    if (sourceCard != null) {
      ability.getTargets().clear();
      FilterPlayer filter=new FilterPlayer(""String_Node_Str"" + sourceCard.getIdName() + ""String_Node_Str"");
      filter.add(Predicates.not(new PlayerIdPredicate(sourceCard.getOwnerId())));
      ability.addTarget(new TargetPlayer(1,1,false,filter));
    }
  }
}",0.992992992992993
158416,"@Override public Set<Card> getCards(Game game){
  Set<Card> cards=new LinkedHashSet<>();
  for (Iterator<UUID> it=this.iterator(); it.hasNext(); ) {
    UUID cardId=it.next();
    Card card=game.getCard(cardId);
    if (card != null) {
      cards.add(card);
    }
  }
  return cards;
}","@Override public Set<Card> getCards(Game game){
  Set<Card> cards=new LinkedHashSet<>();
  for (Iterator<UUID> it=this.iterator(); it.hasNext(); ) {
    UUID cardId=it.next();
    Card card=game.getCard(cardId);
    if (card == null) {
      card=game.getPermanent(cardId);
    }
    if (card != null) {
      cards.add(card);
    }
  }
  return cards;
}",0.89375
158417,"@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller != null) {
    ExileZone exileZone=game.getExile().getExileZone(CardUtil.getCardExileZoneId(game,source));
    if (exileZone != null && exileZone.count(new FilterInstantOrSorceryCard(),game) > 0) {
      if (controller.chooseUse(outcome,""String_Node_Str"",source,game)) {
        TargetCardInExile target=new TargetCardInExile(new FilterInstantOrSorceryCard(),CardUtil.getCardExileZoneId(game,source));
        if (controller.choose(Outcome.PlayForFree,exileZone,target,game)) {
          Card card=game.getCard(target.getFirstTarget());
          if (card != null) {
            game.getExile().removeCard(card,game);
            return controller.cast(card.getSpellAbility(),game,true);
          }
        }
      }
    }
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller != null) {
    ExileZone exileZone=game.getExile().getExileZone(CardUtil.getCardExileZoneId(game,source));
    if (exileZone != null && exileZone.count(new FilterInstantOrSorceryCard(),game) > 0) {
      if (controller.chooseUse(outcome,""String_Node_Str"",source,game)) {
        TargetCardInExile target=new TargetCardInExile(new FilterInstantOrSorceryCard(),CardUtil.getCardExileZoneId(game,source));
        if (controller.choose(Outcome.PlayForFree,exileZone,target,game)) {
          Card card=game.getCard(target.getFirstTarget());
          if (card != null) {
            return controller.cast(card.getSpellAbility(),game,true);
          }
        }
      }
    }
    return true;
  }
  return false;
}",0.9708070978820836
158418,"@Override public boolean apply(Game game,Ability source){
  Spell spell=game.getStack().getSpell(targetPointer.getFirst(game,source));
  Permanent sourceObject=game.getPermanentOrLKIBattlefield(source.getSourceId());
  Player controller=game.getPlayer(source.getControllerId());
  if (controller != null && spell != null && sourceObject != null) {
    UUID exileZoneId=CardUtil.getExileZoneId(game,source.getSourceId(),sourceObject.getZoneChangeCounter(game));
    if (controller.moveCardsToExile(spell,source,game,true,exileZoneId,sourceObject.getIdName())) {
      Player player=game.getPlayer(spell.getControllerId());
      if (player != null && player.chooseUse(Outcome.PlayForFree,""String_Node_Str"" + sourceObject.getLogName() + ""String_Node_Str"",source,game)) {
        TargetCardInExile target=new TargetCardInExile(filter,source.getSourceId());
        while (player.choose(Outcome.PlayForFree,game.getExile().getExileZone(exileZoneId),target,game)) {
          Card card=game.getCard(target.getFirstTarget());
          if (card != null && !card.getId().equals(spell.getSourceId())) {
            game.getExile().removeCard(card,game);
            return player.cast(card.getSpellAbility(),game,true);
          }
          target.clearChosen();
        }
      }
      return true;
    }
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Spell spell=game.getStack().getSpell(targetPointer.getFirst(game,source));
  Permanent sourceObject=game.getPermanentOrLKIBattlefield(source.getSourceId());
  Player controller=game.getPlayer(source.getControllerId());
  if (controller != null && spell != null && sourceObject != null) {
    UUID exileZoneId=CardUtil.getExileZoneId(game,source.getSourceId(),sourceObject.getZoneChangeCounter(game));
    if (controller.moveCardsToExile(spell,source,game,true,exileZoneId,sourceObject.getIdName())) {
      Player player=game.getPlayer(spell.getControllerId());
      if (player != null && player.chooseUse(Outcome.PlayForFree,""String_Node_Str"" + sourceObject.getLogName() + ""String_Node_Str"",source,game)) {
        TargetCardInExile target=new TargetCardInExile(filter,source.getSourceId());
        while (player.choose(Outcome.PlayForFree,game.getExile().getExileZone(exileZoneId),target,game)) {
          Card card=game.getCard(target.getFirstTarget());
          if (card != null && !card.getId().equals(spell.getSourceId())) {
            return player.cast(card.getSpellAbility(),game,true);
          }
          target.clearChosen();
        }
      }
      return true;
    }
  }
  return false;
}",0.9803012746234068
158419,"@Override public List<CardInfo> getCardsByRarity(Rarity rarity){
  if (rarity.equals(Rarity.COMMON)) {
    List<CardInfo> savedCardsInfos=savedCards.get(rarity);
    if (savedCardsInfos == null) {
      CardCriteria criteria=new CardCriteria();
      criteria.setCodes(this.code).notTypes(CardType.LAND);
      if (maxCardNumberInBooster != Integer.MAX_VALUE) {
        criteria.maxCardNumber(maxCardNumberInBooster);
      }
      savedCardsInfos=CardRepository.instance.findCards(criteria);
      savedCards.put(rarity,savedCardsInfos);
    }
    return new ArrayList<>(savedCardsInfos);
  }
 else {
    return super.getCardsByRarity(rarity);
  }
}","@Override public List<CardInfo> getCardsByRarity(Rarity rarity){
  if (rarity.equals(Rarity.COMMON)) {
    List<CardInfo> savedCardsInfos=savedCards.get(rarity);
    if (savedCardsInfos == null) {
      CardCriteria criteria=new CardCriteria();
      criteria.rarities(Rarity.COMMON);
      criteria.setCodes(this.code).notTypes(CardType.LAND);
      if (maxCardNumberInBooster != Integer.MAX_VALUE) {
        criteria.maxCardNumber(maxCardNumberInBooster);
      }
      savedCardsInfos=CardRepository.instance.findCards(criteria);
      savedCards.put(rarity,savedCardsInfos);
    }
    return new ArrayList<>(savedCardsInfos);
  }
 else {
    return super.getCardsByRarity(rarity);
  }
}",0.9701492537313432
158420,"@Override public boolean apply(Game game,Ability source){
  UUID targetId;
  if (getTargetPointer() instanceof FixedTarget) {
    targetId=((FixedTarget)getTargetPointer()).getTarget();
  }
 else {
    targetId=getTargetPointer().getFirst(game,source);
  }
  Permanent permanent=game.getPermanentOrLKIBattlefield(targetId);
  Card copyFrom;
  ApplyToPermanent applier=new EmptyApplyToPermanent();
  if (permanent != null) {
    Permanent copyFromPermanent=permanent;
    for (    Effect effect : game.getState().getContinuousEffects().getLayeredEffects(game)) {
      if (effect instanceof CopyEffect) {
        CopyEffect copyEffect=(CopyEffect)effect;
        if (copyEffect.getSourceId().equals(permanent.getId())) {
          MageObject object=((CopyEffect)effect).getTarget();
          if (object instanceof Permanent) {
            copyFromPermanent=(Permanent)object;
            if (copyEffect.getApplier() != null) {
              applier=copyEffect.getApplier();
            }
          }
        }
      }
    }
    copyFrom=copyFromPermanent;
  }
 else {
    copyFrom=game.getCard(getTargetPointer().getFirst(game,source));
  }
  if (permanent == null && copyFrom == null) {
    return false;
  }
  EmptyToken token=new EmptyToken();
  CardUtil.copyTo(token).from(copyFrom);
  applier.apply(game,token);
  if (additionalCardType != null && !token.getCardType().contains(additionalCardType)) {
    token.getCardType().add(additionalCardType);
  }
  if (gainsHaste) {
    token.addAbility(HasteAbility.getInstance());
  }
  if (gainsFlying) {
    token.addAbility(FlyingAbility.getInstance());
  }
  if (tokenPower != Integer.MIN_VALUE) {
    token.setPower(tokenPower);
  }
  if (tokenToughness != Integer.MIN_VALUE) {
    token.setToughness(tokenToughness);
  }
  if (additionalSubType != null && !token.getSubtype(game).contains(additionalSubType)) {
    token.getSubtype(game).add(additionalSubType);
  }
  token.putOntoBattlefield(number,game,source.getSourceId(),playerId == null ? source.getControllerId() : playerId,tapped,attacking,attackedPlayer);
  for (  UUID tokenId : token.getLastAddedTokenIds()) {
    Permanent tokenPermanent=game.getPermanent(tokenId);
    if (tokenPermanent != null) {
      addedTokenPermanents.add(tokenPermanent);
    }
  }
  return true;
}","@Override public boolean apply(Game game,Ability source){
  UUID targetId;
  if (getTargetPointer() instanceof FixedTarget) {
    targetId=((FixedTarget)getTargetPointer()).getTarget();
  }
 else {
    targetId=getTargetPointer().getFirst(game,source);
  }
  Permanent permanent=game.getPermanentOrLKIBattlefield(targetId);
  Card copyFrom;
  ApplyToPermanent applier=new EmptyApplyToPermanent();
  if (permanent != null) {
    Permanent copyFromPermanent=permanent;
    for (    Effect effect : game.getState().getContinuousEffects().getLayeredEffects(game)) {
      if (effect instanceof CopyEffect) {
        CopyEffect copyEffect=(CopyEffect)effect;
        if (copyEffect.getSourceId().equals(permanent.getId())) {
          MageObject object=((CopyEffect)effect).getTarget();
          if (object instanceof Permanent) {
            copyFromPermanent=(Permanent)object;
            if (copyEffect.getApplier() != null) {
              applier=copyEffect.getApplier();
            }
          }
        }
      }
    }
    copyFrom=copyFromPermanent;
  }
 else {
    copyFrom=game.getCard(getTargetPointer().getFirst(game,source));
  }
  if (permanent == null && copyFrom == null) {
    return false;
  }
  EmptyToken token=new EmptyToken();
  CardUtil.copyTo(token).from(copyFrom);
  applier.apply(game,token);
  if (additionalCardType != null && !token.getCardType().contains(additionalCardType)) {
    token.getCardType().add(additionalCardType);
  }
  if (gainsHaste) {
    token.addAbility(HasteAbility.getInstance());
  }
  if (gainsFlying) {
    token.addAbility(FlyingAbility.getInstance());
  }
  if (tokenPower != Integer.MIN_VALUE) {
    token.getPower().modifyBaseValue(tokenPower);
  }
  if (tokenToughness != Integer.MIN_VALUE) {
    token.getToughness().modifyBaseValue(tokenToughness);
  }
  if (additionalSubType != null && !token.getSubtype(game).contains(additionalSubType)) {
    token.getSubtype(game).add(additionalSubType);
  }
  token.putOntoBattlefield(number,game,source.getSourceId(),playerId == null ? source.getControllerId() : playerId,tapped,attacking,attackedPlayer);
  for (  UUID tokenId : token.getLastAddedTokenIds()) {
    Permanent tokenPermanent=game.getPermanent(tokenId);
    if (tokenPermanent != null) {
      addedTokenPermanents.add(tokenPermanent);
    }
  }
  return true;
}",0.9913344887348352
158421,"private void copyFromToken(Token token,Game game,boolean reset){
  this.name=token.getName();
  this.abilities.clear();
  if (reset) {
    this.abilities.addAll(token.getAbilities());
  }
 else {
    for (    Ability ability : token.getAbilities()) {
      this.addAbility(ability,game);
    }
  }
  this.abilities.setControllerId(this.controllerId);
  this.manaCost.clear();
  for (  ManaCost cost : token.getManaCost()) {
    this.getManaCost().add(cost.copy());
  }
  this.cardType=token.getCardType();
  this.color=token.getColor(game).copy();
  this.frameColor=token.getFrameColor(game);
  this.frameStyle=token.getFrameStyle();
  this.power.modifyBaseValue(token.getPower().getBaseValueModified());
  this.toughness.modifyBaseValue(token.getToughness().getBaseValueModified());
  this.supertype=token.getSupertype();
  this.subtype=token.getSubtype(game);
  this.tokenDescriptor=token.getTokenDescriptor();
}","private void copyFromToken(Token token,Game game,boolean reset){
  this.name=token.getName();
  this.abilities.clear();
  if (reset) {
    this.abilities.addAll(token.getAbilities());
  }
 else {
    for (    Ability ability : token.getAbilities()) {
      this.addAbility(ability,game);
    }
  }
  this.abilities.setControllerId(this.controllerId);
  this.manaCost.clear();
  for (  ManaCost cost : token.getManaCost()) {
    this.getManaCost().add(cost.copy());
  }
  this.cardType=token.getCardType();
  this.color=token.getColor(game).copy();
  this.frameColor=token.getFrameColor(game);
  this.frameStyle=token.getFrameStyle();
  this.supertype=token.getSupertype();
  this.subtype=token.getSubtype(game);
  this.tokenDescriptor=token.getTokenDescriptor();
}",0.9106078665077472
158422,"@Override public void reset(Game game){
  copyFromToken(token,game,true);
  super.reset(game);
}","@Override public void reset(Game game){
  copyFromToken(token,game,true);
  super.reset(game);
  this.power.resetToBaseValue();
  this.toughness.resetToBaseValue();
}",0.732824427480916
158423,"@Override public boolean applies(GameEvent event,Ability source,Game game){
  Permanent permanent=game.getPermanentOrLKIBattlefield(event.getSourceId());
  return permanent != null && permanent.getControllerId().equals(source.getControllerId());
}","@Override public boolean applies(GameEvent event,Ability source,Game game){
  Permanent permanent=game.getPermanentOrLKIBattlefield(event.getSourceId());
  return permanent != null && permanent.getCardType().contains(CardType.CREATURE) && permanent.getControllerId().equals(source.getControllerId());
}",0.8998178506375227
158424,"@Override public boolean apply(Game game,Ability source){
  Player opponent=game.getPlayer(source.getFirstTarget());
  if (opponent != null && opponent.isLifeTotalCanChange()) {
    Permanent perm=game.getPermanent(source.getSourceId());
    if (perm != null) {
      int amount=perm.getToughness().getValue();
      int life=opponent.getLife();
      if (life == amount) {
        return false;
      }
      if (life < amount && !opponent.isCanGainLife()) {
        return false;
      }
      if (life > amount && !opponent.isCanLoseLife()) {
        return false;
      }
      opponent.setLife(amount,game);
      perm.getPower().modifyBaseValue(life);
      perm.getToughness().modifyBaseValue(life);
      return true;
    }
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Player opponent=game.getPlayer(source.getFirstTarget());
  if (opponent != null && opponent.isLifeTotalCanChange()) {
    Permanent perm=game.getPermanent(source.getSourceId());
    if (perm != null) {
      int amount=perm.getToughness().getValue();
      int life=opponent.getLife();
      if (life == amount) {
        return false;
      }
      if (life < amount && !opponent.isCanGainLife()) {
        return false;
      }
      if (life > amount && !opponent.isCanLoseLife()) {
        return false;
      }
      opponent.setLife(amount,game);
      perm.getToughness().modifyBaseValue(life);
      return true;
    }
  }
  return false;
}",0.9568788501026694
158425,"@Override public boolean apply(Game game,Ability source){
  Player damagedPlayer=game.getPlayer(targetPointer.getFirst(game,source));
  Player you=game.getPlayer(source.getControllerId());
  FilterCard filter=new FilterCard(""String_Node_Str"");
  filter.add(new CardTypePredicate(CardType.CREATURE));
  filter.add(new OwnerIdPredicate(damagedPlayer.getId()));
  TargetCardInGraveyard target=new TargetCardInGraveyard(filter);
  if (target.canChoose(source.getSourceId(),you.getId(),game)) {
    if (you.chooseTarget(Outcome.PutCreatureInPlay,target,source,game)) {
      Card card=game.getCard(target.getFirstTarget());
      if (card != null) {
        card.putOntoBattlefield(game,Zone.GRAVEYARD,id,you.getId());
        return true;
      }
    }
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Player damagedPlayer=game.getPlayer(targetPointer.getFirst(game,source));
  Player you=game.getPlayer(source.getControllerId());
  FilterCard filter=new FilterCard(""String_Node_Str"");
  filter.add(new CardTypePredicate(CardType.CREATURE));
  filter.add(new OwnerIdPredicate(damagedPlayer.getId()));
  TargetCardInGraveyard target=new TargetCardInGraveyard(filter);
  if (target.canChoose(source.getSourceId(),you.getId(),game)) {
    if (you.chooseTarget(Outcome.PutCreatureInPlay,target,source,game)) {
      Card card=game.getCard(target.getFirstTarget());
      if (card != null) {
        you.moveCards(card,Zone.BATTLEFIELD,source,game);
        return true;
      }
    }
  }
  return false;
}",0.8580771746239372
158426,"@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  Player newController=game.getPlayer(getTargetPointer().getFirst(game,source));
  if (controller != null && newController != null && controller.getId() != newController.getId()) {
    ContinuousEffect effect=new GainControlTargetEffect(Duration.EndOfGame,newController.getId());
    effect.setTargetPointer(new FixedTarget(source.getSourceId()));
    game.addEffect(effect,source);
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  Player newController=game.getPlayer(getTargetPointer().getFirst(game,source));
  if (controller != null && newController != null && controller.getId() != newController.getId()) {
    ContinuousEffect effect=new GainControlTargetEffect(Duration.Custom,newController.getId());
    effect.setTargetPointer(new FixedTarget(source.getSourceId()));
    game.addEffect(effect,source);
    return true;
  }
  return false;
}",0.7692307692307693
158427,"@Override public void adjustTargets(Ability ability,Game game){
  if (ability.getOriginalId().equals(abilityId)) {
    Card sourceCard=game.getCard(ability.getSourceId());
    if (sourceCard != null) {
      ability.getTargets().clear();
      FilterPlayer filter=new FilterPlayer(""String_Node_Str"" + sourceCard.getName() + ""String_Node_Str"");
      filter.add(Predicates.not(new OwnerIdPredicate(sourceCard.getOwnerId())));
      ability.addTarget(new TargetPlayer(1,1,false,filter));
    }
  }
}","@Override public void adjustTargets(Ability ability,Game game){
  if (ability.getOriginalId().equals(abilityId)) {
    Card sourceCard=game.getCard(ability.getSourceId());
    if (sourceCard != null) {
      ability.getTargets().clear();
      FilterPlayer filter=new FilterPlayer(""String_Node_Str"" + sourceCard.getIdName() + ""String_Node_Str"");
      filter.add(Predicates.not(new OwnerIdPredicate(sourceCard.getOwnerId())));
      ability.addTarget(new TargetPlayer(1,1,false,filter));
    }
  }
}",0.997991967871486
158428,"@Override public Token apply(Card source){
  if (target == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  MageObject sourceObj=source;
  if (source instanceof PermanentToken) {
    sourceObj=((PermanentToken)source).getToken();
    target.setOriginalExpansionSetCode(((Token)sourceObj).getOriginalExpansionSetCode());
    target.setOriginalCardNumber(((Token)sourceObj).getOriginalCardNumber());
    target.setCopySourceCard(((PermanentToken)source).getToken().getCopySourceCard());
  }
 else   if (source instanceof PermanentCard) {
    if (((PermanentCard)source).isMorphed() || ((PermanentCard)source).isManifested()) {
      MorphAbility.setPermanentToFaceDownCreature(target);
      return target;
    }
 else {
      sourceObj=((PermanentCard)source).getCard();
      target.setOriginalExpansionSetCode(source.getExpansionSetCode());
      target.setOriginalCardNumber(source.getCardNumber());
      target.setCopySourceCard((Card)sourceObj);
    }
  }
 else {
    target.setOriginalExpansionSetCode(source.getExpansionSetCode());
    target.setOriginalCardNumber(source.getCardNumber());
    if (source instanceof Card) {
      target.setCopySourceCard(source);
    }
  }
  target.setName(sourceObj.getName());
  target.getColor(null).setColor(sourceObj.getColor(null));
  target.getManaCost().clear();
  target.getManaCost().add(sourceObj.getManaCost());
  target.getCardType().clear();
  for (  CardType type : sourceObj.getCardType()) {
    target.getCardType().add(type);
  }
  target.getSubtype().clear();
  for (  String type : sourceObj.getSubtype()) {
    target.getSubtype().add(type);
  }
  target.getSupertype().clear();
  for (  String type : sourceObj.getSupertype()) {
    target.getSupertype().add(type);
  }
  target.getAbilities().clear();
  for (  Ability ability0 : sourceObj.getAbilities()) {
    Ability ability=ability0.copy();
    ability.newId();
    ability.setSourceId(target.getId());
    target.addAbility(ability);
  }
  target.getPower().modifyBaseValue(sourceObj.getPower().getBaseValueModified());
  target.getToughness().modifyBaseValue(sourceObj.getToughness().getBaseValueModified());
  return target;
}","@Override public Token apply(Card source){
  if (target == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  MageObject sourceObj=source;
  if (source instanceof PermanentToken) {
    sourceObj=((PermanentToken)source).getToken();
    target.setOriginalExpansionSetCode(((Token)sourceObj).getOriginalExpansionSetCode());
    target.setOriginalCardNumber(((Token)sourceObj).getOriginalCardNumber());
    target.setCopySourceCard(((PermanentToken)source).getToken().getCopySourceCard());
  }
 else   if (source instanceof PermanentCard) {
    if (((PermanentCard)source).isMorphed() || ((PermanentCard)source).isManifested()) {
      MorphAbility.setPermanentToFaceDownCreature(target);
      return target;
    }
 else {
      if (((PermanentCard)source).isTransformed() && source.getSecondCardFace() != null) {
        sourceObj=((PermanentCard)source).getSecondCardFace();
      }
 else {
        sourceObj=((PermanentCard)source).getCard();
      }
      target.setOriginalExpansionSetCode(source.getExpansionSetCode());
      target.setOriginalCardNumber(source.getCardNumber());
      target.setCopySourceCard((Card)sourceObj);
    }
  }
 else {
    target.setOriginalExpansionSetCode(source.getExpansionSetCode());
    target.setOriginalCardNumber(source.getCardNumber());
    if (source instanceof Card) {
      target.setCopySourceCard(source);
    }
  }
  target.setName(sourceObj.getName());
  target.getColor(null).setColor(sourceObj.getColor(null));
  target.getManaCost().clear();
  target.getManaCost().add(sourceObj.getManaCost());
  target.getCardType().clear();
  for (  CardType type : sourceObj.getCardType()) {
    target.getCardType().add(type);
  }
  target.getSubtype().clear();
  for (  String type : sourceObj.getSubtype()) {
    target.getSubtype().add(type);
  }
  target.getSupertype().clear();
  for (  String type : sourceObj.getSupertype()) {
    target.getSupertype().add(type);
  }
  target.getAbilities().clear();
  for (  Ability ability0 : sourceObj.getAbilities()) {
    Ability ability=ability0.copy();
    ability.newId();
    ability.setSourceId(target.getId());
    target.addAbility(ability);
  }
  target.getPower().modifyBaseValue(sourceObj.getPower().getBaseValueModified());
  target.getToughness().modifyBaseValue(sourceObj.getToughness().getBaseValueModified());
  return target;
}",0.9570986289252544
158429,"@Override public boolean replaceEvent(GameEvent event,Ability source,Game game){
  DamagePlayerEvent damageEvent=(DamagePlayerEvent)event;
  Permanent equipment=game.getPermanent(source.getSourceId());
  if (equipment != null) {
    Permanent p=game.getPermanent(equipment.getAttachedTo());
    if (p != null) {
      p.damage(damageEvent.getAmount(),event.getSourceId(),game,damageEvent.isCombatDamage(),damageEvent.isPreventable());
      return true;
    }
  }
  return true;
}","@Override public boolean replaceEvent(GameEvent event,Ability source,Game game){
  Permanent equipment=game.getPermanent(source.getSourceId());
  if (equipment != null) {
    Permanent p=game.getPermanent(equipment.getAttachedTo());
    if (p != null) {
      DamagePlayerEvent damageEvent=(DamagePlayerEvent)event;
      p.damage(damageEvent.getAmount(),event.getSourceId(),game,damageEvent.isCombatDamage(),damageEvent.isPreventable());
      return true;
    }
  }
  return false;
}",0.8683937823834197
158430,"@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller != null) {
    UUID sourceId=source.getSourceId();
    FilterControlledCreaturePermanent filter=new FilterControlledCreaturePermanent(""String_Node_Str"" + meldWithName);
    filter.add(new NamePredicate(meldWithName));
    TargetPermanent target=new TargetControlledCreaturePermanent(filter);
    Set<UUID> meldWithList=target.possibleTargets(sourceId,source.getControllerId(),game);
    UUID meldWithId;
    if (meldWithList.size() == 1) {
      meldWithId=meldWithList.iterator().next();
    }
 else {
      controller.choose(Outcome.BoostCreature,target,sourceId,game);
      meldWithId=target.getFirstTarget();
    }
    Permanent sourcePermanent=game.getPermanent(sourceId);
    Permanent meldWithPermanent=game.getPermanent(meldWithId);
    sourcePermanent.moveToExile(null,""String_Node_Str"",sourceId,game);
    meldWithPermanent.moveToExile(null,""String_Node_Str"",sourceId,game);
    Card sourceCard=game.getExile().getCard(sourceId,game);
    Card meldWithCard=game.getExile().getCard(meldWithId,game);
    if (!sourceCard.isCopy() && !meldWithCard.isCopy()) {
      meldCard.setOwnerId(controller.getId());
      meldCard.setTopHalfCard(meldWithCard,game);
      meldCard.setbottomHalfCard(sourceCard,game);
      meldCard.setMelded(true);
      game.addMeldCard(meldCard.getId(),meldCard);
      game.getState().addCard(meldCard);
      meldCard.moveToZone(Zone.BATTLEFIELD,sourceId,game,false);
    }
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller != null) {
    UUID sourceId=source.getSourceId();
    FilterControlledCreaturePermanent filter=new FilterControlledCreaturePermanent(""String_Node_Str"" + meldWithName);
    filter.add(new NamePredicate(meldWithName));
    TargetPermanent target=new TargetControlledCreaturePermanent(filter);
    Set<UUID> meldWithList=target.possibleTargets(sourceId,source.getControllerId(),game);
    if (meldWithList.isEmpty()) {
      return false;
    }
    UUID meldWithId;
    if (meldWithList.size() == 1) {
      meldWithId=meldWithList.iterator().next();
    }
 else {
      controller.choose(Outcome.BoostCreature,target,sourceId,game);
      meldWithId=target.getFirstTarget();
    }
    Permanent sourcePermanent=game.getPermanent(sourceId);
    Permanent meldWithPermanent=game.getPermanent(meldWithId);
    if (sourcePermanent != null && meldWithPermanent != null) {
      sourcePermanent.moveToExile(null,""String_Node_Str"",sourceId,game);
      meldWithPermanent.moveToExile(null,""String_Node_Str"",sourceId,game);
      Card sourceCard=game.getExile().getCard(sourceId,game);
      Card meldWithCard=game.getExile().getCard(meldWithId,game);
      if (!sourceCard.isCopy() && !meldWithCard.isCopy()) {
        meldCard.setOwnerId(controller.getId());
        meldCard.setTopHalfCard(meldWithCard,game);
        meldCard.setbottomHalfCard(sourceCard,game);
        meldCard.setMelded(true);
        game.addMeldCard(meldCard.getId(),meldCard);
        game.getState().addCard(meldCard);
        meldCard.moveToZone(Zone.BATTLEFIELD,sourceId,game,false);
      }
      return true;
    }
  }
  return false;
}",0.9447447447447448
158431,"public FalkenrathGorgerEffect(final FalkenrathGorgerEffect effect){
  super(effect);
}","public FalkenrathGorgerEffect(final FalkenrathGorgerEffect effect){
  super(effect);
  this.madnessAbilities.putAll(effect.madnessAbilities);
}",0.7510917030567685
158432,"@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller != null) {
    for (    Card card : controller.getHand().getCards(filter,game)) {
      game.getState().addOtherAbility(card,new MadnessAbility(card,card.getSpellAbility().getManaCosts()));
    }
    for (    Card card : controller.getGraveyard().getCards(filter,game)) {
      game.getState().addOtherAbility(card,new MadnessAbility(card,card.getSpellAbility().getManaCosts()));
    }
    for (    Card card : game.getExile().getAllCards(game)) {
      if (filter.match(card,source.getSourceId(),controller.getId(),game)) {
        if (card.getOwnerId().equals(controller.getId())) {
          game.getState().addOtherAbility(card,new MadnessAbility(card,card.getSpellAbility().getManaCosts()));
        }
      }
    }
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller != null) {
    HashMap<UUID,MadnessAbility> usedMadnessAbilities=new HashMap<>();
    for (    Card card : controller.getHand().getCards(filter,game)) {
      addMadnessToCard(game,card,usedMadnessAbilities);
    }
    for (    Card card : controller.getGraveyard().getCards(filter,game)) {
      addMadnessToCard(game,card,usedMadnessAbilities);
    }
    for (    Card card : game.getExile().getAllCards(game)) {
      if (filter.match(card,source.getSourceId(),controller.getId(),game)) {
        if (card.getOwnerId().equals(controller.getId())) {
          addMadnessToCard(game,card,usedMadnessAbilities);
        }
      }
    }
    madnessAbilities.clear();
    madnessAbilities.putAll(usedMadnessAbilities);
    return true;
  }
  return false;
}",0.5548098434004475
158433,"MadnessTriggeredAbility(final MadnessTriggeredAbility ability){
  super(ability);
}","MadnessTriggeredAbility(final MadnessTriggeredAbility ability){
  super(ability);
  this.madnessOriginalId=ability.madnessOriginalId;
}",0.7614678899082569
158434,"@Override public boolean checkTrigger(GameEvent event,Game game){
  return event.getTargetId().equals(getSourceId());
}","@Override public boolean checkTrigger(GameEvent event,Game game){
  return event.getSourceId().equals(madnessOriginalId);
}",0.8677685950413223
158435,"@Override public boolean replaceEvent(GameEvent event,Ability source,Game game){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller != null) {
    Card card=game.getCard(event.getTargetId());
    if (card != null) {
      if (controller.moveCardToExileWithInfo(card,source.getSourceId(),""String_Node_Str"",source.getSourceId(),game,((ZoneChangeEvent)event).getFromZone(),true)) {
        game.applyEffects();
        game.fireEvent(GameEvent.getEvent(GameEvent.EventType.MADNESS_CARD_EXILED,card.getId(),card.getId(),controller.getId()));
      }
      return true;
    }
  }
  return false;
}","@Override public boolean replaceEvent(GameEvent event,Ability source,Game game){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller != null) {
    Card card=game.getCard(event.getTargetId());
    if (card != null) {
      if (controller.moveCardToExileWithInfo(card,source.getSourceId(),""String_Node_Str"",source.getSourceId(),game,((ZoneChangeEvent)event).getFromZone(),true)) {
        game.applyEffects();
        GameEvent gameEvent=GameEvent.getEvent(GameEvent.EventType.MADNESS_CARD_EXILED,card.getId(),source.getOriginalId(),controller.getId());
        game.fireEvent(gameEvent);
      }
      return true;
    }
  }
  return false;
}",0.8906128782001551
158436,"public static StringBuilder getRulefromCardView(CardView card,TextLines textLines){
  String manaCost=""String_Node_Str"";
  for (  String m : card.getManaCost()) {
    manaCost+=m;
  }
  String castingCost=UI.getDisplayManaCost(manaCost);
  castingCost=ManaSymbols.replaceSymbolsWithHTML(castingCost,ManaSymbols.Type.TOOLTIP);
  int symbolCount=0;
  int offset=0;
  while ((offset=castingCost.indexOf(""String_Node_Str"",offset) + 1) != 0) {
    symbolCount++;
  }
  String fontFamily=""String_Node_Str"";
  int fontSize=GUISizeHelper.cardTooltipFontSize;
  final StringBuilder buffer=new StringBuilder(512);
  buffer.append(""String_Node_Str"");
  buffer.append(fontFamily);
  buffer.append(""String_Node_Str"");
  buffer.append(fontSize);
  buffer.append(""String_Node_Str"");
  buffer.append(""String_Node_Str"");
  buffer.append(""String_Node_Str"");
  buffer.append(card.getDisplayName());
  if (card.isGameObject()) {
    buffer.append(""String_Node_Str"").append(card.getId().toString().substring(0,3)).append(""String_Node_Str"");
  }
  buffer.append(""String_Node_Str"");
  buffer.append(symbolCount * GUISizeHelper.cardTooltipFontSize);
  buffer.append(""String_Node_Str"");
  if (!card.isSplitCard()) {
    buffer.append(castingCost);
  }
  buffer.append(""String_Node_Str"");
  buffer.append(""String_Node_Str"");
  String imageSize=""String_Node_Str"" + GUISizeHelper.cardTooltipFontSize + ""String_Node_Str""+ GUISizeHelper.cardTooltipFontSize+ ""String_Node_Str"";
  if (card.getColor().isWhite()) {
    buffer.append(""String_Node_Str"").append(getResourcePath(""String_Node_Str"")).append(""String_Node_Str"").append(imageSize);
  }
  if (card.getColor().isBlue()) {
    buffer.append(""String_Node_Str"").append(getResourcePath(""String_Node_Str"")).append(""String_Node_Str"").append(imageSize);
  }
  if (card.getColor().isBlack()) {
    buffer.append(""String_Node_Str"").append(getResourcePath(""String_Node_Str"")).append(""String_Node_Str"").append(imageSize);
  }
  if (card.getColor().isRed()) {
    buffer.append(""String_Node_Str"").append(getResourcePath(""String_Node_Str"")).append(""String_Node_Str"").append(imageSize);
  }
  if (card.getColor().isGreen()) {
    buffer.append(""String_Node_Str"").append(getResourcePath(""String_Node_Str"")).append(""String_Node_Str"").append(imageSize);
  }
  if (!card.getColor().isColorless()) {
    buffer.append(""String_Node_Str"");
  }
  buffer.append(getTypes(card));
  buffer.append(""String_Node_Str"");
  String rarity;
  if (card.getRarity() == null) {
    rarity=Rarity.COMMON.getCode();
    buffer.append(""String_Node_Str"");
  }
 else {
switch (card.getRarity()) {
case RARE:
      buffer.append(""String_Node_Str"");
    break;
case UNCOMMON:
  buffer.append(""String_Node_Str"");
break;
case COMMON:
buffer.append(""String_Node_Str"");
break;
case MYTHIC:
buffer.append(""String_Node_Str"");
break;
}
rarity=card.getRarity().getCode();
}
if (card.getExpansionSetCode() != null) {
buffer.append(ManaSymbols.replaceSetCodeWithHTML(card.getExpansionSetCode().toUpperCase(),rarity,GUISizeHelper.symbolTooltipSize));
}
buffer.append(""String_Node_Str"");
String pt=""String_Node_Str"";
if (CardUtil.isCreature(card)) {
pt=card.getPower() + ""String_Node_Str"" + card.getToughness();
}
 else if (CardUtil.isPlaneswalker(card)) {
pt=card.getLoyalty();
}
buffer.append(""String_Node_Str"");
buffer.append(pt).append(""String_Node_Str"");
buffer.append(""String_Node_Str"");
if (!card.isControlledByOwner()) {
if (card instanceof PermanentView) {
buffer.append(""String_Node_Str"").append(((PermanentView)card).getNameOwner()).append(""String_Node_Str"");
}
 else {
buffer.append(""String_Node_Str"");
}
}
if (!card.getMageObjectType().equals(MageObjectType.NULL)) {
buffer.append(card.getMageObjectType().toString());
}
buffer.append(""String_Node_Str"");
StringBuilder rule=new StringBuilder(""String_Node_Str"");
if (card.isSplitCard()) {
rule.append(""String_Node_Str"");
rule.append(""String_Node_Str"");
rule.append(card.getLeftSplitName());
rule.append(""String_Node_Str"");
rule.append(card.getLeftSplitCosts().getSymbols().size() * GUISizeHelper.symbolTooltipSize + 1);
rule.append(""String_Node_Str"");
rule.append(card.getLeftSplitCosts().getText());
rule.append(""String_Node_Str"");
for (String ruling : card.getLeftSplitRules()) {
if (ruling != null && !ruling.replace(""String_Node_Str"",""String_Node_Str"").trim().isEmpty()) {
rule.append(""String_Node_Str"").append(ruling).append(""String_Node_Str"");
}
}
rule.append(""String_Node_Str"");
rule.append(""String_Node_Str"");
rule.append(card.getRightSplitName());
rule.append(""String_Node_Str"");
rule.append(card.getRightSplitCosts().getSymbols().size() * GUISizeHelper.symbolTooltipSize + 1);
rule.append(""String_Node_Str"");
rule.append(card.getRightSplitCosts().getText());
rule.append(""String_Node_Str"");
for (String ruling : card.getRightSplitRules()) {
if (ruling != null && !ruling.replace(""String_Node_Str"",""String_Node_Str"").trim().isEmpty()) {
rule.append(""String_Node_Str"").append(ruling).append(""String_Node_Str"");
}
}
}
if (textLines.lines.size() > 0) {
for (String textLine : textLines.lines) {
if (textLine != null && !textLine.replace(""String_Node_Str"",""String_Node_Str"").trim().isEmpty()) {
rule.append(""String_Node_Str"").append(textLine).append(""String_Node_Str"");
}
}
}
String legal=rule.toString();
if (legal.length() > 0) {
legal=legal.replaceAll(""String_Node_Str"",card.getName().isEmpty() ? ""String_Node_Str"" : card.getName());
legal=legal.replaceAll(""String_Node_Str"",card.getName().isEmpty() ? ""String_Node_Str"" : card.getName());
buffer.append(ManaSymbols.replaceSymbolsWithHTML(legal,ManaSymbols.Type.TOOLTIP));
}
buffer.append(""String_Node_Str"");
return buffer;
}","public static StringBuilder getRulefromCardView(CardView card,TextLines textLines){
  String manaCost=""String_Node_Str"";
  for (  String m : card.getManaCost()) {
    manaCost+=m;
  }
  String castingCost=UI.getDisplayManaCost(manaCost);
  castingCost=ManaSymbols.replaceSymbolsWithHTML(castingCost,ManaSymbols.Type.TOOLTIP);
  int symbolCount=0;
  int offset=0;
  while ((offset=castingCost.indexOf(""String_Node_Str"",offset) + 1) != 0) {
    symbolCount++;
  }
  String fontFamily=""String_Node_Str"";
  int fontSize=GUISizeHelper.cardTooltipFontSize;
  final StringBuilder buffer=new StringBuilder(512);
  buffer.append(""String_Node_Str"");
  buffer.append(fontFamily);
  buffer.append(""String_Node_Str"");
  buffer.append(fontSize);
  buffer.append(""String_Node_Str"");
  buffer.append(""String_Node_Str"");
  buffer.append(""String_Node_Str"");
  buffer.append(card.getDisplayName());
  if (card.isGameObject()) {
    buffer.append(""String_Node_Str"").append(card.getId().toString().substring(0,3)).append(""String_Node_Str"");
  }
  buffer.append(""String_Node_Str"");
  buffer.append(symbolCount * GUISizeHelper.cardTooltipFontSize);
  buffer.append(""String_Node_Str"");
  if (!card.isSplitCard()) {
    buffer.append(castingCost);
  }
  buffer.append(""String_Node_Str"");
  buffer.append(""String_Node_Str"");
  String imageSize=""String_Node_Str"" + GUISizeHelper.cardTooltipFontSize + ""String_Node_Str""+ GUISizeHelper.cardTooltipFontSize+ ""String_Node_Str"";
  if (card.getColor().isWhite()) {
    buffer.append(""String_Node_Str"").append(getResourcePath(""String_Node_Str"")).append(""String_Node_Str"").append(imageSize);
  }
  if (card.getColor().isBlue()) {
    buffer.append(""String_Node_Str"").append(getResourcePath(""String_Node_Str"")).append(""String_Node_Str"").append(imageSize);
  }
  if (card.getColor().isBlack()) {
    buffer.append(""String_Node_Str"").append(getResourcePath(""String_Node_Str"")).append(""String_Node_Str"").append(imageSize);
  }
  if (card.getColor().isRed()) {
    buffer.append(""String_Node_Str"").append(getResourcePath(""String_Node_Str"")).append(""String_Node_Str"").append(imageSize);
  }
  if (card.getColor().isGreen()) {
    buffer.append(""String_Node_Str"").append(getResourcePath(""String_Node_Str"")).append(""String_Node_Str"").append(imageSize);
  }
  if (!card.getColor().isColorless()) {
    buffer.append(""String_Node_Str"");
  }
  buffer.append(getTypes(card));
  buffer.append(""String_Node_Str"");
  String rarity;
  if (card.getRarity() == null) {
    rarity=Rarity.COMMON.getCode();
    buffer.append(""String_Node_Str"");
  }
 else {
switch (card.getRarity()) {
case RARE:
      buffer.append(""String_Node_Str"");
    break;
case UNCOMMON:
  buffer.append(""String_Node_Str"");
break;
case COMMON:
buffer.append(""String_Node_Str"");
break;
case MYTHIC:
buffer.append(""String_Node_Str"");
break;
}
rarity=card.getRarity().getCode();
}
if (card.getExpansionSetCode() != null) {
buffer.append(ManaSymbols.replaceSetCodeWithHTML(card.getExpansionSetCode().toUpperCase(),rarity,GUISizeHelper.symbolTooltipSize));
}
buffer.append(""String_Node_Str"");
String pt=""String_Node_Str"";
if (CardUtil.isCreature(card)) {
pt=card.getPower() + ""String_Node_Str"" + card.getToughness();
}
 else if (CardUtil.isPlaneswalker(card)) {
pt=card.getLoyalty();
}
buffer.append(""String_Node_Str"");
buffer.append(pt).append(""String_Node_Str"");
buffer.append(""String_Node_Str"");
if (!card.isControlledByOwner()) {
if (card instanceof PermanentView) {
buffer.append(""String_Node_Str"").append(((PermanentView)card).getNameOwner()).append(""String_Node_Str"");
}
 else {
buffer.append(""String_Node_Str"");
}
}
if (!card.getMageObjectType().equals(MageObjectType.NULL)) {
buffer.append(card.getMageObjectType().toString());
}
buffer.append(""String_Node_Str"");
StringBuilder rule=new StringBuilder(""String_Node_Str"");
if (card.isSplitCard()) {
rule.append(""String_Node_Str"");
rule.append(""String_Node_Str"");
rule.append(card.getLeftSplitName());
rule.append(""String_Node_Str"");
rule.append(card.getLeftSplitCosts().getSymbols().size() * GUISizeHelper.symbolTooltipSize + 1);
rule.append(""String_Node_Str"");
rule.append(card.getLeftSplitCosts().getText());
rule.append(""String_Node_Str"");
for (String ruling : card.getLeftSplitRules()) {
if (ruling != null && !ruling.replace(""String_Node_Str"",""String_Node_Str"").trim().isEmpty()) {
rule.append(""String_Node_Str"").append(ruling).append(""String_Node_Str"");
}
}
rule.append(""String_Node_Str"");
rule.append(""String_Node_Str"");
rule.append(card.getRightSplitName());
rule.append(""String_Node_Str"");
rule.append(card.getRightSplitCosts().getSymbols().size() * GUISizeHelper.symbolTooltipSize + 1);
rule.append(""String_Node_Str"");
rule.append(card.getRightSplitCosts().getText());
rule.append(""String_Node_Str"");
for (String ruling : card.getRightSplitRules()) {
if (ruling != null && !ruling.replace(""String_Node_Str"",""String_Node_Str"").trim().isEmpty()) {
rule.append(""String_Node_Str"").append(ruling).append(""String_Node_Str"");
}
}
}
if (textLines.lines.size() > 0) {
for (String textLine : textLines.lines) {
if (textLine != null && !textLine.replace(""String_Node_Str"",""String_Node_Str"").trim().isEmpty()) {
rule.append(""String_Node_Str"").append(textLine).append(""String_Node_Str"");
}
}
}
String legal=rule.toString();
if (legal.length() > 0) {
legal=legal.replaceAll(""String_Node_Str"",card.getName().isEmpty() ? ""String_Node_Str"" : card.getName());
legal=legal.replaceAll(""String_Node_Str"",card.getName().isEmpty() ? ""String_Node_Str"" : card.getName());
buffer.append(ManaSymbols.replaceSymbolsWithHTML(legal,ManaSymbols.Type.TOOLTIP));
}
Zone zone=card.getZone();
if (zone != null) {
buffer.append(""String_Node_Str"").append(zone).append(""String_Node_Str"");
}
buffer.append(""String_Node_Str"");
return buffer;
}",0.9810522605093858
158437,"@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  MageObject sourceObject=source.getSourceObject(game);
  if (controller != null && sourceObject != null) {
    Cards cards=controller.getSideboard();
    Card card=null;
    if (!cards.isEmpty()) {
      if (controller.chooseUse(Outcome.Benefit,choiceText,source,game)) {
        Set<Card> filtered=cards.getCards(filter,game);
        if (filtered.isEmpty()) {
          game.informPlayer(controller,""String_Node_Str"" + filter.getMessage() + ""String_Node_Str"");
        }
 else {
          Cards filteredCards=new CardsImpl();
          for (          Card sideboardCard : filtered) {
            filteredCards.add(sideboardCard.getId());
          }
          TargetCard target=new TargetCard(Zone.OUTSIDE,filter);
          target.setNotTarget(true);
          if (controller.choose(outcome,filteredCards,target,game)) {
            card=controller.getSideboard().get(target.getFirstTarget(),game);
          }
        }
      }
    }
    Cards filteredCards=new CardsImpl();
    for (    Card exileCard : game.getExile().getAllCards(game)) {
      if (exileCard.getOwnerId().equals(source.getControllerId()) && exileCard.hasSubtype(""String_Node_Str"")) {
        filteredCards.add(exileCard);
      }
    }
    if (filteredCards.isEmpty()) {
      game.informPlayer(controller,""String_Node_Str"");
    }
 else {
      TargetCard target=new TargetCard(Zone.EXILED,filter);
      target.setNotTarget(true);
      if (controller.choose(Outcome.Benefit,filteredCards,target,game)) {
        card=game.getCard(target.getFirstTarget());
      }
    }
    if (card != null) {
      card.moveToZone(Zone.HAND,source.getSourceId(),game,false);
      controller.revealCards(sourceObject.getIdName(),new CardsImpl(card),game);
    }
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  MageObject sourceObject=source.getSourceObject(game);
  if (controller != null && sourceObject != null) {
    if (controller.chooseUse(Outcome.Benefit,choiceText,source,game)) {
      Set<Card> sideboard=controller.getSideboard().getCards(filter,game);
      List<Card> exile=game.getExile().getAllCards(game);
      Cards filteredCards=new CardsImpl();
      Card card=null;
      for (      Card sideboardCard : sideboard) {
        filteredCards.add(sideboardCard.getId());
      }
      for (      Card exileCard : exile) {
        if (exileCard.getOwnerId().equals(source.getControllerId()) && exileCard.hasSubtype(""String_Node_Str"")) {
          filteredCards.add(exileCard);
        }
      }
      if (filteredCards.isEmpty()) {
        game.informPlayer(controller,""String_Node_Str"" + filter.getMessage() + ""String_Node_Str"");
      }
 else {
        TargetCard target=new TargetCard(Zone.OUTSIDE,filter);
        target.setNotTarget(true);
        if (controller.choose(outcome,filteredCards,target,game)) {
          card=controller.getSideboard().get(target.getFirstTarget(),game);
          if (card == null) {
            card=game.getCard(target.getFirstTarget());
          }
        }
      }
      if (card != null) {
        card.moveToZone(Zone.HAND,source.getSourceId(),game,false);
        controller.revealCards(sourceObject.getIdName(),new CardsImpl(card),game);
      }
    }
    return true;
  }
  return false;
}",0.4976771196283391
158438,"@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  Player newController=game.getPlayer(getTargetPointer().getFirst(game,source));
  if (controller != null && newController != null) {
    ContinuousEffect effect=new GainControlTargetEffect(Duration.EndOfGame,newController.getId());
    effect.setTargetPointer(new FixedTarget(source.getSourceId()));
    game.addEffect(effect,source);
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  Player newController=game.getPlayer(getTargetPointer().getFirst(game,source));
  if (controller != null && newController != null && controller.getId() != newController.getId()) {
    ContinuousEffect effect=new GainControlTargetEffect(Duration.EndOfGame,newController.getId());
    effect.setTargetPointer(new FixedTarget(source.getSourceId()));
    game.addEffect(effect,source);
    return true;
  }
  return false;
}",0.9545893719806764
158439,"@Override public void adjustTargets(Ability ability,Game game){
  if (ability.getOriginalId().equals(ability2Id)) {
    int cmc=0;
    for (    Cost cost : ability.getCosts()) {
      if (cost instanceof PayVariableLoyaltyCost) {
        cmc=((PayVariableLoyaltyCost)cost).getAmount();
      }
    }
    FilterCard newFilter=filter.copy();
    newFilter.add(new ConvertedManaCostPredicate(Filter.ComparisonType.Equal,cmc));
    ability.getTargets().clear();
    ability.addTarget(new TargetCardInYourGraveyard(filter));
  }
}","@Override public void adjustTargets(Ability ability,Game game){
  if (ability.getOriginalId().equals(ability2Id)) {
    int cmc=0;
    for (    Cost cost : ability.getCosts()) {
      if (cost instanceof PayVariableLoyaltyCost) {
        cmc=((PayVariableLoyaltyCost)cost).getAmount();
      }
    }
    FilterCard newFilter=filter.copy();
    newFilter.add(new ConvertedManaCostPredicate(Filter.ComparisonType.Equal,cmc));
    ability.getTargets().clear();
    ability.addTarget(new TargetCardInYourGraveyard(newFilter));
  }
}",0.9952516619183286
158440,"@Test public void testMinusAbilityShouldNotReturnHigherCmcCreature(){
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"",1);
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"",3);
  addCard(Zone.HAND,playerA,""String_Node_Str"");
  addCard(Zone.HAND,playerB,""String_Node_Str"");
  addCard(Zone.BATTLEFIELD,playerB,""String_Node_Str"",1);
  castSpell(1,PhaseStep.PRECOMBAT_MAIN,playerA,""String_Node_Str"");
  castSpell(1,PhaseStep.BEGIN_COMBAT,playerB,""String_Node_Str"");
  addTarget(playerB,""String_Node_Str"");
  activateAbility(1,PhaseStep.POSTCOMBAT_MAIN,playerA,""String_Node_Str"");
  setChoice(playerA,""String_Node_Str"");
  addTarget(playerA,""String_Node_Str"");
  setChoice(playerA,""String_Node_Str"");
  setStopAt(1,PhaseStep.END_TURN);
  execute();
  assertGraveyardCount(playerB,""String_Node_Str"",1);
  assertPermanentCount(playerA,""String_Node_Str"",0);
  assertPermanentCount(playerA,""String_Node_Str"",1);
  assertPermanentCount(playerA,""String_Node_Str"",1);
  assertCounterCount(""String_Node_Str"",CounterType.LOYALTY,2);
  assertPermanentCount(playerA,""String_Node_Str"",0);
  assertGraveyardCount(playerA,""String_Node_Str"",1);
}","@Test public void testMinusAbilityShouldNotReturnHigherCmcCreature(){
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"",1);
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"",3);
  addCard(Zone.HAND,playerA,""String_Node_Str"");
  addCard(Zone.HAND,playerB,""String_Node_Str"");
  addCard(Zone.BATTLEFIELD,playerB,""String_Node_Str"",1);
  castSpell(1,PhaseStep.PRECOMBAT_MAIN,playerA,""String_Node_Str"");
  castSpell(1,PhaseStep.BEGIN_COMBAT,playerB,""String_Node_Str"",""String_Node_Str"");
  activateAbility(1,PhaseStep.POSTCOMBAT_MAIN,playerA,""String_Node_Str"",""String_Node_Str"");
  setChoice(playerA,""String_Node_Str"");
  setStopAt(1,PhaseStep.END_TURN);
  execute();
  assertGraveyardCount(playerB,""String_Node_Str"",1);
  assertPermanentCount(playerA,""String_Node_Str"",0);
  assertPermanentCount(playerA,""String_Node_Str"",1);
  assertPermanentCount(playerA,""String_Node_Str"",1);
  assertCounterCount(""String_Node_Str"",CounterType.LOYALTY,3);
  assertPermanentCount(playerA,""String_Node_Str"",0);
  assertGraveyardCount(playerA,""String_Node_Str"",1);
}",0.9605866177818516
158441,"@Override public boolean activate(Game game,boolean noMana){
  Player controller=game.getPlayer(this.getControllerId());
  if (controller == null) {
    return false;
  }
  game.applyEffects();
  if (!getModes().choose(game,this)) {
    return false;
  }
  if (controller.isTestMode()) {
    if (!controller.addTargets(this,game)) {
      return false;
    }
  }
  getSourceObject(game);
  if (this.abilityType.equals(AbilityType.SPELL)) {
    game.getContinuousEffects().applySpliceEffects(this,game);
  }
  if (noMana) {
    if (this.getManaCostsToPay().getVariableCosts().size() > 0) {
      int xValue=this.getManaCostsToPay().getX();
      this.getManaCostsToPay().clear();
      VariableManaCost xCosts=new VariableManaCost();
      xCosts.setAmount(xValue);
      this.getManaCostsToPay().add(xCosts);
    }
 else {
      this.getManaCostsToPay().clear();
    }
  }
  if (!activateAlternateOrAdditionalCosts(sourceObject,noMana,controller,game)) {
    if (getAbilityType().equals(AbilityType.SPELL) && ((SpellAbility)this).getSpellAbilityType().equals(SpellAbilityType.FACE_DOWN_CREATURE)) {
      return false;
    }
  }
  VariableManaCost variableManaCost=handleManaXCosts(game,noMana,controller);
  String announceString=handleOtherXCosts(game,controller);
  if (this.getAbilityType().equals(AbilityType.SPELL) && game.replaceEvent(GameEvent.getEvent(GameEvent.EventType.CAST_SPELL_LATE,getId(),getSourceId(),getControllerId()),this)) {
    return false;
  }
  for (  Mode mode : this.getModes().getSelectedModes()) {
    this.getModes().setActiveMode(mode);
    if (sourceObject != null && !this.getAbilityType().equals(AbilityType.TRIGGERED)) {
      sourceObject.adjustTargets(this,game);
    }
    if (mode.getTargets().size() > 0 && mode.getTargets().chooseTargets(getEffects().get(0).getOutcome(),this.controllerId,this,noMana,game) == false) {
      if ((variableManaCost != null || announceString != null) && !game.isSimulation()) {
        game.informPlayer(controller,(sourceObject != null ? sourceObject.getIdName() : ""String_Node_Str"") + ""String_Node_Str"");
      }
      return false;
    }
  }
  for (  Cost cost : optionalCosts) {
    if (cost instanceof ManaCost) {
      cost.clearPaid();
      if (controller.chooseUse(Outcome.Benefit,""String_Node_Str"" + cost.getText() + ""String_Node_Str"",this,game)) {
        manaCostsToPay.add((ManaCost)cost);
      }
    }
  }
  if (sourceObject != null) {
    sourceObject.adjustCosts(this,game);
    if (sourceObject instanceof Card) {
      for (      Ability ability : ((Card)sourceObject).getAbilities(game)) {
        if (ability instanceof AdjustingSourceCosts) {
          ((AdjustingSourceCosts)ability).adjustCosts(this,game);
        }
      }
    }
 else {
      for (      Ability ability : sourceObject.getAbilities()) {
        if (ability instanceof AdjustingSourceCosts) {
          ((AdjustingSourceCosts)ability).adjustCosts(this,game);
        }
      }
    }
  }
  if (this instanceof ManaAbility && !costs.pay(this,game,sourceId,controllerId,noMana,null)) {
    logger.debug(""String_Node_Str"");
    return false;
  }
  if (costModificationActive) {
    game.getContinuousEffects().costModification(this,game);
  }
 else {
    costModificationActive=true;
  }
  UUID activatorId=controllerId;
  if ((this instanceof ActivatedAbilityImpl) && ((ActivatedAbilityImpl)this).getActivatorId() != null) {
    activatorId=((ActivatedAbilityImpl)this).getActivatorId();
  }
  if (!manaCostsToPay.pay(this,game,sourceId,activatorId,false,null)) {
    return false;
  }
  if (!costs.pay(this,game,sourceId,activatorId,noMana,null)) {
    logger.debug(""String_Node_Str"");
    return false;
  }
  if (!game.isSimulation()) {
    if (announceString != null) {
      game.informPlayers(announceString);
    }
    if (variableManaCost != null) {
      int xValue=getManaCostsToPay().getX();
      game.informPlayers(controller.getLogName() + ""String_Node_Str"" + xValue+ ""String_Node_Str""+ variableManaCost.getText());
    }
  }
  activated=true;
  if (this.getAbilityType().equals(AbilityType.MANA)) {
    for (    Cost cost : costs) {
      if (cost instanceof TapSourceCost) {
        Mana mana=null;
        Effect effect=getEffects().get(0);
        if (effect instanceof DynamicManaEffect) {
          mana=((DynamicManaEffect)effect).getMana(game,this);
        }
 else         if (effect instanceof BasicManaEffect) {
          mana=((BasicManaEffect)effect).getMana(game,this);
        }
        if (mana != null && mana.getAny() == 0) {
          ManaEvent event=new ManaEvent(GameEvent.EventType.TAPPED_FOR_MANA,sourceId,sourceId,controllerId,mana);
          if (!game.replaceEvent(event)) {
            game.fireEvent(event);
          }
        }
        break;
      }
    }
  }
  return true;
}","@Override public boolean activate(Game game,boolean noMana){
  Player controller=game.getPlayer(this.getControllerId());
  if (controller == null) {
    return false;
  }
  game.applyEffects();
  if (!getModes().choose(game,this)) {
    return false;
  }
  getSourceObject(game);
  if (controller.isTestMode()) {
    if (!controller.addTargets(this,game)) {
      return false;
    }
  }
  if (this.abilityType.equals(AbilityType.SPELL)) {
    game.getContinuousEffects().applySpliceEffects(this,game);
  }
  if (noMana) {
    if (this.getManaCostsToPay().getVariableCosts().size() > 0) {
      int xValue=this.getManaCostsToPay().getX();
      this.getManaCostsToPay().clear();
      VariableManaCost xCosts=new VariableManaCost();
      xCosts.setAmount(xValue);
      this.getManaCostsToPay().add(xCosts);
    }
 else {
      this.getManaCostsToPay().clear();
    }
  }
  if (!activateAlternateOrAdditionalCosts(sourceObject,noMana,controller,game)) {
    if (getAbilityType().equals(AbilityType.SPELL) && ((SpellAbility)this).getSpellAbilityType().equals(SpellAbilityType.FACE_DOWN_CREATURE)) {
      return false;
    }
  }
  VariableManaCost variableManaCost=handleManaXCosts(game,noMana,controller);
  String announceString=handleOtherXCosts(game,controller);
  if (this.getAbilityType().equals(AbilityType.SPELL) && game.replaceEvent(GameEvent.getEvent(GameEvent.EventType.CAST_SPELL_LATE,getId(),getSourceId(),getControllerId()),this)) {
    return false;
  }
  for (  Mode mode : this.getModes().getSelectedModes()) {
    this.getModes().setActiveMode(mode);
    if (sourceObject != null && !this.getAbilityType().equals(AbilityType.TRIGGERED)) {
      sourceObject.adjustTargets(this,game);
    }
    if (mode.getTargets().size() > 0 && mode.getTargets().chooseTargets(getEffects().get(0).getOutcome(),this.controllerId,this,noMana,game) == false) {
      if ((variableManaCost != null || announceString != null) && !game.isSimulation()) {
        game.informPlayer(controller,(sourceObject != null ? sourceObject.getIdName() : ""String_Node_Str"") + ""String_Node_Str"");
      }
      return false;
    }
  }
  for (  Cost cost : optionalCosts) {
    if (cost instanceof ManaCost) {
      cost.clearPaid();
      if (controller.chooseUse(Outcome.Benefit,""String_Node_Str"" + cost.getText() + ""String_Node_Str"",this,game)) {
        manaCostsToPay.add((ManaCost)cost);
      }
    }
  }
  if (sourceObject != null) {
    sourceObject.adjustCosts(this,game);
    if (sourceObject instanceof Card) {
      for (      Ability ability : ((Card)sourceObject).getAbilities(game)) {
        if (ability instanceof AdjustingSourceCosts) {
          ((AdjustingSourceCosts)ability).adjustCosts(this,game);
        }
      }
    }
 else {
      for (      Ability ability : sourceObject.getAbilities()) {
        if (ability instanceof AdjustingSourceCosts) {
          ((AdjustingSourceCosts)ability).adjustCosts(this,game);
        }
      }
    }
  }
  if (this instanceof ManaAbility && !costs.pay(this,game,sourceId,controllerId,noMana,null)) {
    logger.debug(""String_Node_Str"");
    return false;
  }
  if (costModificationActive) {
    game.getContinuousEffects().costModification(this,game);
  }
 else {
    costModificationActive=true;
  }
  UUID activatorId=controllerId;
  if ((this instanceof ActivatedAbilityImpl) && ((ActivatedAbilityImpl)this).getActivatorId() != null) {
    activatorId=((ActivatedAbilityImpl)this).getActivatorId();
  }
  if (!manaCostsToPay.pay(this,game,sourceId,activatorId,false,null)) {
    return false;
  }
  if (!costs.pay(this,game,sourceId,activatorId,noMana,null)) {
    logger.debug(""String_Node_Str"");
    return false;
  }
  if (!game.isSimulation()) {
    if (announceString != null) {
      game.informPlayers(announceString);
    }
    if (variableManaCost != null) {
      int xValue=getManaCostsToPay().getX();
      game.informPlayers(controller.getLogName() + ""String_Node_Str"" + xValue+ ""String_Node_Str""+ variableManaCost.getText());
    }
  }
  activated=true;
  if (this.getAbilityType().equals(AbilityType.MANA)) {
    for (    Cost cost : costs) {
      if (cost instanceof TapSourceCost) {
        Mana mana=null;
        Effect effect=getEffects().get(0);
        if (effect instanceof DynamicManaEffect) {
          mana=((DynamicManaEffect)effect).getMana(game,this);
        }
 else         if (effect instanceof BasicManaEffect) {
          mana=((BasicManaEffect)effect).getMana(game,this);
        }
        if (mana != null && mana.getAny() == 0) {
          ManaEvent event=new ManaEvent(GameEvent.EventType.TAPPED_FOR_MANA,sourceId,sourceId,controllerId,mana);
          if (!game.replaceEvent(event)) {
            game.fireEvent(event);
          }
        }
        break;
      }
    }
  }
  return true;
}",0.9947709684166492
158442,"@Override public void adjustTargets(Ability ability,Game game){
  card.adjustTargets(ability,game);
}","@Override public void adjustTargets(Ability ability,Game game){
  if (this.isTransformed()) {
    card.getSecondCardFace().adjustTargets(ability,game);
  }
 else {
    card.adjustTargets(ability,game);
  }
}",0.6298701298701299
158443,"@Override public void adjustCosts(Ability ability,Game game){
  card.adjustCosts(ability,game);
}","@Override public void adjustCosts(Ability ability,Game game){
  if (this.isTransformed()) {
    card.getSecondCardFace().adjustCosts(ability,game);
  }
 else {
    card.adjustCosts(ability,game);
  }
}",0.6241610738255033
158444,"@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  MageObject sourceObject=source.getSourceObject(game);
  if (controller != null && sourceObject != null) {
    Permanent permanentLeftBattlefield=(Permanent)getValue(""String_Node_Str"");
    if (permanentLeftBattlefield == null) {
      Logger.getLogger(ReturnFromExileForSourceEffect.class).error(""String_Node_Str"" + sourceObject.getName());
      return false;
    }
    ExileZone exile=game.getExile().getExileZone(CardUtil.getExileZoneId(game,source.getSourceId(),permanentLeftBattlefield.getZoneChangeCounter(game)));
    if (exile != null) {
      Card card=exile.getCards(game).iterator().next();
      if (card != null) {
        Player cardOwner=game.getPlayer(card.getOwnerId());
        if (cardOwner != null) {
          if (cardOwner.chooseUse(Outcome.PlayForFree,""String_Node_Str"" + card.getLogName() + ""String_Node_Str"",source,game)) {
            cardOwner.cast(card.getSpellAbility(),game,true);
          }
        }
      }
    }
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  MageObject sourceObject=source.getSourceObject(game);
  if (controller != null && sourceObject != null) {
    Permanent permanentLeftBattlefield=(Permanent)getValue(""String_Node_Str"");
    if (permanentLeftBattlefield == null) {
      Logger.getLogger(ReturnFromExileForSourceEffect.class).error(""String_Node_Str"" + sourceObject.getName());
      return false;
    }
    ExileZone exile=game.getExile().getExileZone(CardUtil.getExileZoneId(game,source.getSourceId(),permanentLeftBattlefield.getZoneChangeCounter(game)));
    if (exile != null) {
      Card card=null;
      Set<Card> exiledCards=exile.getCards(game);
      if (exiledCards != null && !exiledCards.isEmpty()) {
        card=exiledCards.iterator().next();
        if (card != null) {
          Player cardOwner=game.getPlayer(card.getOwnerId());
          if (cardOwner != null) {
            if (cardOwner.chooseUse(Outcome.PlayForFree,""String_Node_Str"" + card.getLogName() + ""String_Node_Str"",source,game)) {
              cardOwner.cast(card.getSpellAbility(),game,true);
            }
          }
        }
      }
    }
    return true;
  }
  return false;
}",0.9147221043699618
158445,"@Override public boolean apply(Game game,Ability source){
  Player targetPlayer=game.getPlayer(source.getFirstTarget());
  if (targetPlayer != null && targetPlayer.getHand().size() > 0) {
    Cards revealed=new CardsImpl();
    Card card=targetPlayer.getHand().getRandom(game);
    revealed.add(card);
    targetPlayer.revealCards(""String_Node_Str"",revealed,game);
    targetPlayer.loseLife(card.getConvertedManaCost(),game);
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Player targetPlayer=game.getPlayer(source.getFirstTarget());
  if (targetPlayer != null && !targetPlayer.getHand().isEmpty()) {
    Cards revealed=new CardsImpl();
    Card card=targetPlayer.getHand().getRandom(game);
    revealed.add(card);
    targetPlayer.revealCards(""String_Node_Str"",revealed,game);
    targetPlayer.loseLife(card.getConvertedManaCost(),game);
    return true;
  }
  return false;
}",0.978448275862069
158446,"@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller != null) {
    HashMap<UUID,Integer> destroyedCreatures=new HashMap<>();
    for (    Permanent permanent : game.getBattlefield().getActivePermanents(new FilterCreaturePermanent(),source.getControllerId(),source.getSourceId(),game)) {
      if (permanent.destroy(source.getSourceId(),game,false)) {
        int count=destroyedCreatures.containsKey(permanent.getControllerId()) ? destroyedCreatures.get(permanent.getControllerId()) : 0;
        destroyedCreatures.put(permanent.getControllerId(),count + 1);
      }
    }
    for (    UUID playerId : game.getState().getPlayerList(source.getControllerId())) {
      int count=destroyedCreatures.containsKey(playerId) ? destroyedCreatures.get(playerId) : 0;
      if (count > 0) {
        Player player=game.getPlayer(playerId);
        if (player != null) {
          player.damage(count,playerId,game,false,true);
        }
      }
    }
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller != null) {
    HashMap<UUID,Integer> destroyedCreatures=new HashMap<>();
    for (    Permanent permanent : game.getBattlefield().getActivePermanents(new FilterCreaturePermanent(),source.getControllerId(),source.getSourceId(),game)) {
      if (permanent.destroy(source.getSourceId(),game,false)) {
        int count=destroyedCreatures.containsKey(permanent.getControllerId()) ? destroyedCreatures.get(permanent.getControllerId()) : 0;
        destroyedCreatures.put(permanent.getControllerId(),count + 1);
      }
    }
    for (    UUID playerId : game.getState().getPlayerList(source.getControllerId())) {
      int count=destroyedCreatures.containsKey(playerId) ? destroyedCreatures.get(playerId) : 0;
      if (count > 0) {
        Player player=game.getPlayer(playerId);
        if (player != null) {
          player.loseLife(count,game);
        }
      }
    }
    return true;
  }
  return false;
}",0.926944971537002
158447,"@Override public MortisDogsEffect copy(){
  return new MortisDogsEffect();
}","@Override public MortisDogs copy(){
  return new MortisDogs(this);
}",0.8888888888888888
158448,"@Override public boolean apply(Game game,Ability source){
  int amount=0;
  for (  Cost cost : source.getCosts()) {
    if (cost instanceof SacrificeTargetCost && ((SacrificeTargetCost)cost).getPermanents().size() > 0) {
      amount=((SacrificeTargetCost)cost).getPermanents().get(0).getPower().getValue();
      break;
    }
  }
  if (amount > 0) {
    Player player=game.getPlayer(source.getFirstTarget());
    if (player != null) {
      player.damage(amount,source.getSourceId(),game,false,true);
      return true;
    }
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  int amount=0;
  for (  Cost cost : source.getCosts()) {
    if (cost instanceof SacrificeTargetCost && ((SacrificeTargetCost)cost).getPermanents().size() > 0) {
      amount=((SacrificeTargetCost)cost).getPermanents().get(0).getPower().getValue();
      break;
    }
  }
  if (amount > 0) {
    Player player=game.getPlayer(source.getFirstTarget());
    if (player != null) {
      player.loseLife(amount,game);
      return true;
    }
  }
  return false;
}",0.953095684803002
158449,"@Override public boolean apply(Game game,Ability source){
  Player you=game.getPlayer(source.getControllerId());
  Player targetPlayer=game.getPlayer(source.getFirstTarget());
  if (targetPlayer != null && you != null) {
    FilterCard filter=new FilterCard(""String_Node_Str"");
    filter.add(new OwnerIdPredicate(targetPlayer.getId()));
    TargetCardInGraveyard target=new TargetCardInGraveyard(filter);
    boolean opponentChoosesExile=targetPlayer.chooseUse(Outcome.Exile,""String_Node_Str"",source,game);
    if (opponentChoosesExile && targetPlayer.chooseTarget(Outcome.Exile,target,source,game)) {
      Card card=game.getCard(target.getFirstTarget());
      if (card != null) {
        if (targetPlayer.moveCardToExileWithInfo(card,null,""String_Node_Str"",source.getSourceId(),game,Zone.GRAVEYARD,true)) {
          if (you.chooseUse(Outcome.DrawCard,""String_Node_Str"",source,game)) {
            you.drawCards(1,game);
          }
        }
      }
      return true;
    }
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Player you=game.getPlayer(source.getControllerId());
  Player targetPlayer=game.getPlayer(source.getFirstTarget());
  if (targetPlayer != null && you != null) {
    FilterCard filter=new FilterCard(""String_Node_Str"");
    filter.add(new OwnerIdPredicate(targetPlayer.getId()));
    TargetCardInGraveyard target=new TargetCardInGraveyard(filter);
    boolean opponentChoosesExile=targetPlayer.chooseUse(Outcome.Exile,""String_Node_Str"",source,game);
    boolean opponentExilesACard=false;
    if (opponentChoosesExile && targetPlayer.chooseTarget(Outcome.Exile,target,source,game)) {
      Card card=game.getCard(target.getFirstTarget());
      if (card != null) {
        opponentExilesACard=targetPlayer.moveCardToExileWithInfo(card,null,""String_Node_Str"",source.getSourceId(),game,Zone.GRAVEYARD,true);
      }
    }
    if (!opponentExilesACard) {
      if (you.chooseUse(Outcome.DrawCard,""String_Node_Str"",source,game)) {
        you.drawCards(1,game);
      }
    }
    return true;
  }
  return false;
}",0.88835186080232
158450,"@Override public boolean apply(Game game,Ability source){
  int amount=0;
  boolean result=false;
  Player you=game.getPlayer(source.getControllerId());
  for (  UUID playerId : you.getInRange()) {
    if (!playerId.equals(source.getControllerId())) {
      Player otherPlayer=game.getPlayer(playerId);
      if (otherPlayer != null && otherPlayer.getHand().size() > 0) {
        TargetCardInHand target=new TargetCardInHand();
        if (otherPlayer.choose(Outcome.Discard,target,source.getSourceId(),game)) {
          Card card=game.getCard(target.getFirstTarget());
          if (card != null) {
            if (otherPlayer.discard(card,source,game)) {
              amount+=1;
              result=true;
              target.clearChosen();
            }
          }
        }
      }
    }
  }
  if (you != null) {
    you.drawCards(amount,game);
  }
  return result;
}","@Override public boolean apply(Game game,Ability source){
  int amount=0;
  boolean result=false;
  Player you=game.getPlayer(source.getControllerId());
  if (you != null) {
    for (    UUID playerId : you.getInRange()) {
      if (!playerId.equals(source.getControllerId())) {
        Player otherPlayer=game.getPlayer(playerId);
        if (otherPlayer != null && otherPlayer.getHand().size() > 0) {
          TargetCardInHand target=new TargetCardInHand();
          if (otherPlayer.choose(Outcome.Discard,target,source.getSourceId(),game)) {
            Card card=game.getCard(target.getFirstTarget());
            if (card != null) {
              if (otherPlayer.discard(card,source,game)) {
                amount+=1;
                result=true;
                target.clearChosen();
              }
            }
          }
        }
      }
    }
    you.drawCards(amount,game);
  }
  return result;
}",0.9362416107382552
158451,"@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  Player targetPlayer=game.getPlayer(this.getTargetPointer().getFirst(game,source));
  if (controller != null && targetPlayer != null) {
    game.getState().getTurnMods().add(new TurnMod(targetPlayer.getId(),false));
    game.getState().getTurnMods().add(new TurnMod(targetPlayer.getId(),controller.getId()));
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  Player targetPlayer=game.getPlayer(this.getTargetPointer().getFirst(game,source));
  if (controller != null && targetPlayer != null) {
    game.getState().getTurnMods().add(new TurnMod(targetPlayer.getId(),false));
  }
  return super.apply(game,source);
}",0.8142011834319527
158452,"@Override public boolean replaceEvent(GameEvent event,Ability source,Game game){
  if (event.getType().equals(GameEvent.EventType.DISCARD_CARD)) {
    Card card=game.getCard(event.getTargetId());
    if (card != null) {
      cardId=card.getId();
      zoneChangeCounter=game.getState().getZoneChangeCounter(cardId);
    }
    return false;
  }
  if (event.getType().equals(GameEvent.EventType.ZONE_CHANGE)) {
    Player controller=game.getPlayer(source.getControllerId());
    Card card=game.getCard(event.getTargetId());
    if (controller != null && card != null) {
      cardId=null;
      zoneChangeCounter=0;
      if (controller.chooseUse(outcome,""String_Node_Str"" + card.getIdName() + ""String_Node_Str"",source,game)) {
        Cards cardsToLibrary=new CardsImpl(card);
        controller.revealCards(card.getName(),cardsToLibrary,game);
        controller.putCardsOnTopOfLibrary(cardsToLibrary,game,source,false);
        return true;
      }
    }
  }
  return false;
}","@Override public boolean replaceEvent(GameEvent event,Ability source,Game game){
  if (event.getType().equals(GameEvent.EventType.DISCARD_CARD)) {
    Card card=game.getCard(event.getTargetId());
    if (card != null) {
      boolean isAnOpponentEffect=false;
      MageObject object=game.getObject(event.getSourceId());
      if (object instanceof PermanentCard) {
        isAnOpponentEffect=game.getOpponents(source.getControllerId()).contains(((PermanentCard)object).getControllerId());
      }
 else       if (object instanceof Spell) {
        isAnOpponentEffect=game.getOpponents(source.getControllerId()).contains(((Spell)object).getControllerId());
      }
 else       if (object instanceof Card) {
        isAnOpponentEffect=game.getOpponents(source.getControllerId()).contains(((Card)object).getOwnerId());
      }
      if (isAnOpponentEffect) {
        cardId=card.getId();
        zoneChangeCounter=game.getState().getZoneChangeCounter(cardId);
      }
    }
    return false;
  }
  if (event.getType().equals(GameEvent.EventType.ZONE_CHANGE)) {
    Player controller=game.getPlayer(source.getControllerId());
    Card card=game.getCard(event.getTargetId());
    if (controller != null && card != null) {
      cardId=null;
      zoneChangeCounter=0;
      if (controller.chooseUse(outcome,""String_Node_Str"" + card.getIdName() + ""String_Node_Str"",source,game)) {
        Cards cardsToLibrary=new CardsImpl(card);
        controller.revealCards(card.getName(),cardsToLibrary,game);
        controller.putCardsOnTopOfLibrary(cardsToLibrary,game,source,false);
        return true;
      }
    }
  }
  return false;
}",0.7401151631477927
158453,"@Override public boolean applies(GameEvent event,Ability source,Game game){
  if (event.getPlayerId().equals(source.getControllerId())) {
    MageObject object=game.getObject(event.getSourceId());
    if (object instanceof PermanentCard) {
      if (game.getOpponents(source.getControllerId()).contains(((PermanentCard)object).getControllerId())) {
        return true;
      }
    }
    if (object instanceof Spell) {
      if (game.getOpponents(source.getControllerId()).contains(((Spell)object).getControllerId())) {
        return true;
      }
    }
  }
  return false;
}","@Override public boolean applies(GameEvent event,Ability source,Game game){
  if (event.getPlayerId().equals(source.getControllerId())) {
    MageObject object=game.getObject(event.getSourceId());
    if (object instanceof PermanentCard) {
      if (game.getOpponents(source.getControllerId()).contains(((PermanentCard)object).getControllerId())) {
        return true;
      }
    }
    if (object instanceof Spell) {
      if (game.getOpponents(source.getControllerId()).contains(((Spell)object).getControllerId())) {
        return true;
      }
    }
    if (object instanceof Card) {
      if (game.getOpponents(source.getControllerId()).contains(((Card)object).getOwnerId())) {
        return true;
      }
    }
  }
  return false;
}",0.8753799392097265
158454,"@Test public void testUseWithMercilessExecutioner(){
  addCard(Zone.GRAVEYARD,playerA,""String_Node_Str"");
  addCard(Zone.BATTLEFIELD,playerB,""String_Node_Str"",5);
  addCard(Zone.GRAVEYARD,playerB,""String_Node_Str"");
  addCard(Zone.HAND,playerB,""String_Node_Str"");
  castSpell(2,PhaseStep.PRECOMBAT_MAIN,playerB,""String_Node_Str"");
  setChoice(playerB,""String_Node_Str"");
  setChoice(playerA,""String_Node_Str"");
  setStopAt(2,PhaseStep.POSTCOMBAT_MAIN);
  execute();
  assertGraveyardCount(playerB,""String_Node_Str"",1);
  assertGraveyardCount(playerA,""String_Node_Str"",0);
  assertGraveyardCount(playerB,""String_Node_Str"",0);
}","@Test public void testUseWithMercilessExecutioner(){
  addCard(Zone.GRAVEYARD,playerA,""String_Node_Str"");
  addCard(Zone.BATTLEFIELD,playerB,""String_Node_Str"",5);
  addCard(Zone.GRAVEYARD,playerB,""String_Node_Str"");
  addCard(Zone.HAND,playerB,""String_Node_Str"");
  castSpell(2,PhaseStep.PRECOMBAT_MAIN,playerB,""String_Node_Str"");
  setChoice(playerB,""String_Node_Str"");
  setChoice(playerA,""String_Node_Str"");
  setStopAt(2,PhaseStep.POSTCOMBAT_MAIN);
  execute();
  assertGraveyardCount(playerB,""String_Node_Str"",1);
  assertGraveyardCount(playerA,""String_Node_Str"",0);
  assertGraveyardCount(playerB,""String_Node_Str"",1);
}",0.9984025559105432
158455,"@Override public boolean checkTrigger(GameEvent event,Game game){
  if (!onlyCombat || ((DamagedPlayerEvent)event).isCombatDamage()) {
    Permanent permanent=game.getPermanent(event.getSourceId());
    if (permanent != null && filter.match(permanent,sourceId,controllerId,game)) {
      if (!setTargetPointer.equals(SetTargetPointer.NONE)) {
        for (        Effect effect : this.getEffects()) {
          effect.setValue(""String_Node_Str"",event.getAmount());
switch (setTargetPointer) {
case PLAYER:
            effect.setTargetPointer(new FixedTarget(permanent.getControllerId()));
          break;
case PERMANENT:
        effect.setTargetPointer(new FixedTarget(permanent.getId(),permanent.getZoneChangeCounter(game)));
      break;
  }
}
}
return true;
}
}
return false;
}","@Override public boolean checkTrigger(GameEvent event,Game game){
  if (!onlyCombat || ((DamagedPlayerEvent)event).isCombatDamage()) {
    Permanent permanent=game.getPermanent(event.getSourceId());
    if (permanent != null) {
      controllerId=permanent.getControllerId();
      if (filter.match(permanent,sourceId,controllerId,game)) {
        if (!setTargetPointer.equals(SetTargetPointer.NONE)) {
          for (          Effect effect : this.getEffects()) {
            effect.setValue(""String_Node_Str"",event.getAmount());
switch (setTargetPointer) {
case PLAYER:
              effect.setTargetPointer(new FixedTarget(permanent.getControllerId()));
            break;
case PERMANENT:
          effect.setTargetPointer(new FixedTarget(permanent.getId(),permanent.getZoneChangeCounter(game)));
        break;
    }
  }
}
return true;
}
}
}
return false;
}",0.9403166869671132
158456,"@Override public void adjustTargets(Ability ability,Game game){
  if (ability instanceof SpellAbility) {
    if (KickedCondition.getInstance().apply(game,ability)) {
      getSpellAbility().addTarget(new TargetLandPermanent(new FilterLandPermanent(""String_Node_Str"")));
    }
  }
}","@Override public void adjustTargets(Ability ability,Game game){
  if (ability instanceof SpellAbility) {
    if (KickedCondition.getInstance().apply(game,ability)) {
      ability.getTargets().clear();
      getSpellAbility().addTarget(new TargetLandPermanent(2));
    }
  }
}",0.8581687612208259
158457,"@Override public void adjustTargets(Ability ability,Game game){
  if (ability instanceof SpellAbility && KickedCondition.getInstance().apply(game,ability)) {
    ability.addTarget(new TargetOtherNonlandPermanent(new FilterNonlandPermanent(""String_Node_Str"")));
  }
}","@Override public void adjustTargets(Ability ability,Game game){
  if (ability instanceof SpellAbility && KickedCondition.getInstance().apply(game,ability)) {
    ability.getTargets().clear();
    ability.addTarget(new TargetNonlandPermanent(2));
  }
}",0.8355899419729207
158458,"@Override public TargetOtherNonlandPermanent copy(){
  return new TargetOtherNonlandPermanent(this);
}","@Override public RushingRiver copy(){
  return new RushingRiver(this);
}",0.6206896551724138
158459,"@Override public DissensionInTheRanksTarget copy(){
  return new DissensionInTheRanksTarget(this);
}","@Override public DissensionInTheRanks copy(){
  return new DissensionInTheRanks(this);
}",0.9361702127659576
158460,"@Override public boolean apply(Layer layer,SubLayer sublayer,Ability source,Game game){
  Permanent enchantment=game.getPermanent(source.getSourceId());
  if (enchantment != null && enchantment.getAttachedTo() != null) {
    Permanent permanent=game.getPermanent(enchantment.getAttachedTo());
    if (permanent != null) {
switch (layer) {
case ColorChangingEffects_5:
        permanent.getColor(game).setWhite(false);
      permanent.getColor(game).setGreen(false);
    permanent.getColor(game).setBlack(false);
  permanent.getColor(game).setBlue(false);
permanent.getColor(game).setRed(false);
break;
case AbilityAddingRemovingEffects_6:
permanent.removeAllAbilities(source.getSourceId(),game);
permanent.addAbility(new ColorlessManaAbility(),source.getSourceId(),game);
break;
case TypeChangingEffects_4:
permanent.getCardType().clear();
permanent.getCardType().add(CardType.LAND);
permanent.getSubtype().clear();
break;
}
return true;
}
}
return false;
}","@Override public boolean apply(Layer layer,SubLayer sublayer,Ability source,Game game){
  Permanent enchantment=game.getPermanent(source.getSourceId());
  if (enchantment != null && enchantment.getAttachedTo() != null) {
    Permanent permanent=game.getPermanent(enchantment.getAttachedTo());
    if (permanent != null) {
switch (layer) {
case ColorChangingEffects_5:
        permanent.getColor(game).setWhite(false);
      permanent.getColor(game).setGreen(false);
    permanent.getColor(game).setBlack(false);
  permanent.getColor(game).setBlue(false);
permanent.getColor(game).setRed(false);
break;
case AbilityAddingRemovingEffects_6:
permanent.removeAllAbilities(source.getSourceId(),game);
permanent.addAbility(new ColorlessManaAbility(),source.getSourceId(),game);
break;
case TypeChangingEffects_4:
boolean isLand=permanent.getCardType().contains(CardType.LAND);
permanent.getCardType().clear();
permanent.getCardType().add(CardType.LAND);
if (!isLand) {
permanent.getSubtype().clear();
}
break;
}
return true;
}
}
return false;
}",0.924310776942356
158461,"@Override public boolean apply(Game game,Ability source){
  MageObject sourceObject=game.getObject(source.getSourceId());
  Player targetPlayer=game.getPlayer(source.getFirstTarget());
  String cardName=(String)game.getState().getValue(source.getSourceId().toString() + NameACardEffect.INFO_KEY);
  if (sourceObject == null || targetPlayer == null || cardName == null || cardName.isEmpty()) {
    return false;
  }
  Cards cardsToReveal=new CardsImpl();
  Cards cardsToBury=new CardsImpl();
  boolean namedCardFound=false;
  while (targetPlayer.getLibrary().size() > 0) {
    Card card=targetPlayer.getLibrary().removeFromTop(game);
    if (card != null) {
      cardsToReveal.add(card);
      if (card.getName().equals(cardName)) {
        namedCardFound=true;
        targetPlayer.moveCards(cardsToBury,Zone.GRAVEYARD,source,game);
        targetPlayer.moveCards(card,Zone.LIBRARY,source,game);
        break;
      }
 else {
        cardsToBury.add(card);
      }
    }
  }
  targetPlayer.revealCards(sourceObject.getIdName(),cardsToReveal,game);
  if (!namedCardFound) {
    targetPlayer.shuffleLibrary(source,game);
  }
  return true;
}","@Override public boolean apply(Game game,Ability source){
  MageObject sourceObject=game.getObject(source.getSourceId());
  Player targetPlayer=game.getPlayer(source.getFirstTarget());
  String cardName=(String)game.getState().getValue(source.getSourceId().toString() + NameACardEffect.INFO_KEY);
  if (sourceObject == null || targetPlayer == null || cardName == null || cardName.isEmpty()) {
    return false;
  }
  Cards cardsToReveal=new CardsImpl();
  Cards cardsToBury=new CardsImpl();
  Card namedCard=null;
  boolean namedCardFound=false;
  while (targetPlayer.getLibrary().size() > 0) {
    Card card=targetPlayer.getLibrary().removeFromTop(game);
    if (card != null) {
      cardsToReveal.add(card);
      if (card.getName().equals(cardName)) {
        namedCardFound=true;
        namedCard=card;
        break;
      }
 else {
        cardsToBury.add(card);
      }
    }
  }
  targetPlayer.revealCards(sourceObject.getIdName(),cardsToReveal,game);
  if (namedCardFound) {
    targetPlayer.moveCards(cardsToBury,Zone.GRAVEYARD,source,game);
    targetPlayer.moveCards(namedCard,Zone.LIBRARY,source,game);
  }
 else {
    targetPlayer.shuffleLibrary(source,game);
  }
  return true;
}",0.8301240907145914
158462,"@Test public void testCopyNoxiousGhoul(){
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"",3);
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"",9);
  addCard(Zone.HAND,playerA,""String_Node_Str"",1);
  addCard(Zone.HAND,playerA,""String_Node_Str"",1);
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"",1);
  addCard(Zone.BATTLEFIELD,playerB,""String_Node_Str"",3);
  addCard(Zone.HAND,playerB,""String_Node_Str"",1);
  addCard(Zone.BATTLEFIELD,playerB,""String_Node_Str"",1);
  addCard(Zone.BATTLEFIELD,playerB,""String_Node_Str"",1);
  addCard(Zone.BATTLEFIELD,playerB,""String_Node_Str"",1);
  castSpell(1,PhaseStep.PRECOMBAT_MAIN,playerA,""String_Node_Str"");
  castSpell(1,PhaseStep.POSTCOMBAT_MAIN,playerA,""String_Node_Str"");
  setChoice(playerA,""String_Node_Str"");
  castSpell(1,PhaseStep.POSTCOMBAT_MAIN,playerB,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  setStopAt(1,PhaseStep.END_TURN);
  execute();
  assertPermanentCount(playerA,""String_Node_Str"",2);
  assertGraveyardCount(playerB,""String_Node_Str"",1);
  assertPowerToughness(playerA,""String_Node_Str"",-1,1,Filter.ComparisonScope.All);
  assertGraveyardCount(playerB,""String_Node_Str"",1);
  assertPowerToughness(playerB,""String_Node_Str"",2,3);
  assertPowerToughness(playerA,""String_Node_Str"",0,3);
}","@Test public void testCopyNoxiousGhoul(){
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"",3);
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"",9);
  addCard(Zone.HAND,playerA,""String_Node_Str"",1);
  addCard(Zone.HAND,playerA,""String_Node_Str"",1);
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"",1);
  addCard(Zone.BATTLEFIELD,playerB,""String_Node_Str"",3);
  addCard(Zone.HAND,playerB,""String_Node_Str"",1);
  addCard(Zone.BATTLEFIELD,playerB,""String_Node_Str"",1);
  addCard(Zone.BATTLEFIELD,playerB,""String_Node_Str"",1);
  addCard(Zone.BATTLEFIELD,playerB,""String_Node_Str"",1);
  castSpell(1,PhaseStep.PRECOMBAT_MAIN,playerA,""String_Node_Str"");
  castSpell(1,PhaseStep.POSTCOMBAT_MAIN,playerA,""String_Node_Str"");
  setChoice(playerA,""String_Node_Str"");
  castSpell(1,PhaseStep.POSTCOMBAT_MAIN,playerB,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  setStopAt(1,PhaseStep.END_TURN);
  execute();
  assertPermanentCount(playerA,""String_Node_Str"",2);
  assertGraveyardCount(playerB,""String_Node_Str"",1);
  assertPowerToughness(playerA,""String_Node_Str"",-1,1,Filter.ComparisonScope.All);
  assertGraveyardCount(playerB,""String_Node_Str"",1);
  assertPowerToughness(playerB,""String_Node_Str"",1,2);
  assertPowerToughness(playerA,""String_Node_Str"",-1,2);
}",0.9956744003145892
158463,"/** 
 * Tests trigger won't happen after Soul Warden died
 */
@Test public void testDisabledEffectOnChangeZone(){
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"",1);
  addCard(Zone.HAND,playerA,""String_Node_Str"");
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"",2);
  addCard(Zone.HAND,playerA,""String_Node_Str"",2);
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"",1);
  castSpell(1,PhaseStep.PRECOMBAT_MAIN,playerA,""String_Node_Str"");
  castSpell(1,PhaseStep.POSTCOMBAT_MAIN,playerA,""String_Node_Str"",""String_Node_Str"");
  castSpell(1,PhaseStep.POSTCOMBAT_MAIN,playerA,""String_Node_Str"");
  setStopAt(1,PhaseStep.END_TURN);
  execute();
  assertLife(playerA,21);
  assertLife(playerB,20);
}","/** 
 * Tests trigger won't happen after Soul Warden died
 */
@Test public void testDisabledEffectOnChangeZone(){
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"",1);
  addCard(Zone.HAND,playerA,""String_Node_Str"");
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"",4);
  addCard(Zone.HAND,playerA,""String_Node_Str"",2);
  addCard(Zone.HAND,playerA,""String_Node_Str"",1);
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"",1);
  castSpell(1,PhaseStep.PRECOMBAT_MAIN,playerA,""String_Node_Str"");
  castSpell(1,PhaseStep.PRECOMBAT_MAIN,playerA,""String_Node_Str"");
  castSpell(1,PhaseStep.POSTCOMBAT_MAIN,playerA,""String_Node_Str"",""String_Node_Str"");
  castSpell(1,PhaseStep.POSTCOMBAT_MAIN,playerA,""String_Node_Str"");
  setStopAt(1,PhaseStep.END_TURN);
  execute();
  assertLife(playerA,23);
  assertLife(playerB,20);
}",0.8749181401440733
158464,"public boolean putOntoBattlefield(int amount,Game game,UUID sourceId,UUID controllerId,boolean tapped,boolean attacking,UUID attackedPlayer){
  Player controller=game.getPlayer(controllerId);
  if (controller == null) {
    return false;
  }
  lastAddedTokenIds.clear();
  String setCode=null;
  if (this.getOriginalExpansionSetCode() != null && !this.getOriginalExpansionSetCode().isEmpty()) {
    setCode=this.getOriginalExpansionSetCode();
  }
 else {
    Card source=game.getCard(sourceId);
    if (source != null) {
      setCode=source.getExpansionSetCode();
    }
 else {
      MageObject object=game.getObject(sourceId);
      if (object instanceof PermanentToken) {
        ((PermanentToken)object).getExpansionSetCode();
      }
    }
  }
  if (!expansionSetCodeChecked) {
    expansionSetCodeChecked=this.updateExpansionSetCode(setCode);
  }
  GameEvent event=new GameEvent(EventType.CREATE_TOKEN,null,sourceId,controllerId,amount,this.getCardType().contains(CardType.CREATURE));
  if (!game.replaceEvent(event)) {
    amount=event.getAmount();
    List<Permanent> permanents=new ArrayList<>();
    List<Permanent> permanentsEntered=new ArrayList<>();
    for (int i=0; i < amount; i++) {
      PermanentToken newToken=new PermanentToken(this,event.getPlayerId(),setCode,game);
      game.getState().addCard(newToken);
      permanents.add(newToken);
      game.getPermanentsEntering().put(newToken.getId(),newToken);
      newToken.setTapped(tapped);
    }
    game.setScopeRelevant(true);
    for (    Permanent permanent : permanents) {
      if (permanent.entersBattlefield(sourceId,game,Zone.OUTSIDE,true)) {
        permanentsEntered.add(permanent);
      }
 else {
        game.getPermanentsEntering().remove(permanent.getId());
      }
    }
    game.setScopeRelevant(false);
    for (    Permanent permanent : permanentsEntered) {
      game.addPermanent(permanent);
      permanent.setZone(Zone.BATTLEFIELD,game);
      game.getPermanentsEntering().remove(permanent.getId());
      this.lastAddedTokenIds.add(permanent.getId());
      this.lastAddedTokenId=permanent.getId();
      game.addSimultaneousEvent(new ZoneChangeEvent(permanent,permanent.getControllerId(),Zone.OUTSIDE,Zone.BATTLEFIELD));
      if (attacking && game.getCombat() != null) {
        game.getCombat().addAttackingCreature(permanent.getId(),game,attackedPlayer);
      }
      if (!game.isSimulation()) {
        game.informPlayers(controller.getLogName() + ""String_Node_Str"" + permanent.getLogName()+ ""String_Node_Str"");
      }
    }
    game.applyEffects();
    return true;
  }
  return false;
}","public boolean putOntoBattlefield(int amount,Game game,UUID sourceId,UUID controllerId,boolean tapped,boolean attacking,UUID attackedPlayer){
  Player controller=game.getPlayer(controllerId);
  if (controller == null) {
    return false;
  }
  lastAddedTokenIds.clear();
  String setCode=null;
  if (this.getOriginalExpansionSetCode() != null && !this.getOriginalExpansionSetCode().isEmpty()) {
    setCode=this.getOriginalExpansionSetCode();
  }
 else {
    Card source=game.getCard(sourceId);
    if (source != null) {
      setCode=source.getExpansionSetCode();
    }
 else {
      MageObject object=game.getObject(sourceId);
      if (object instanceof PermanentToken) {
        ((PermanentToken)object).getExpansionSetCode();
      }
    }
  }
  if (!expansionSetCodeChecked) {
    expansionSetCodeChecked=this.updateExpansionSetCode(setCode);
  }
  GameEvent event=new GameEvent(EventType.CREATE_TOKEN,null,sourceId,controllerId,amount,this.getCardType().contains(CardType.CREATURE));
  if (!game.replaceEvent(event)) {
    amount=event.getAmount();
    List<Permanent> permanents=new ArrayList<>();
    List<Permanent> permanentsEntered=new ArrayList<>();
    for (int i=0; i < amount; i++) {
      PermanentToken newToken=new PermanentToken(this,event.getPlayerId(),setCode,game);
      game.getState().addCard(newToken);
      permanents.add(newToken);
      game.getPermanentsEntering().put(newToken.getId(),newToken);
      newToken.setTapped(tapped);
    }
    game.setScopeRelevant(true);
    for (    Permanent permanent : permanents) {
      if (permanent.entersBattlefield(sourceId,game,Zone.OUTSIDE,true)) {
        permanentsEntered.add(permanent);
      }
 else {
        game.getPermanentsEntering().remove(permanent.getId());
      }
    }
    game.setScopeRelevant(false);
    for (    Permanent permanent : permanentsEntered) {
      game.addPermanent(permanent);
      permanent.setZone(Zone.BATTLEFIELD,game);
      game.getPermanentsEntering().remove(permanent.getId());
      this.lastAddedTokenIds.add(permanent.getId());
      this.lastAddedTokenId=permanent.getId();
      game.addSimultaneousEvent(new ZoneChangeEvent(permanent,permanent.getControllerId(),Zone.OUTSIDE,Zone.BATTLEFIELD));
      if (attacking && game.getCombat() != null) {
        game.getCombat().addAttackingCreature(permanent.getId(),game,attackedPlayer);
      }
      if (!game.isSimulation()) {
        game.informPlayers(controller.getLogName() + ""String_Node_Str"" + permanent.getLogName()+ ""String_Node_Str"");
      }
    }
    return true;
  }
  return false;
}",0.9827552799844992
158465,"@Override public boolean apply(Game game,Ability source){
  Player player=game.getPlayer(source.getFirstTarget());
  if (player == null) {
    return false;
  }
  if (player.searchLibrary(target,game)) {
    if (target.getTargets().size() > 0) {
      Cards cards=new CardsImpl(target.getTargets());
      player.revealCards(""String_Node_Str"",cards,game);
      player.moveCards(cards,Zone.LIBRARY,Zone.GRAVEYARD,source,game);
    }
    player.shuffleLibrary(source,game);
    return true;
  }
  player.shuffleLibrary(source,game);
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  UUID targetPlayerID=source.getFirstTarget();
  if (controller.searchLibrary(target,game,targetPlayerID)) {
    if (target.getTargets().size() > 0) {
      Cards cards=new CardsImpl(target.getTargets());
      controller.revealCards(""String_Node_Str"",cards,game);
      controller.moveCards(cards,Zone.GRAVEYARD,source,game);
    }
    controller.shuffleLibrary(source,game);
    return true;
  }
  controller.shuffleLibrary(source,game);
  return false;
}",0.8117229129662522
158466,"@Override public boolean replaceEvent(GameEvent event,Ability source,Game game){
  Object object=this.getValue(""String_Node_Str"");
  if (object instanceof Integer) {
    int amount=((Integer)object);
    new AddCountersSourceEffect(CounterType.P1P1.createInstance(amount)).apply(game,source);
  }
  return false;
}","@Override public boolean replaceEvent(GameEvent event,Ability source,Game game){
  Object object=this.getValue(""String_Node_Str"");
  Permanent permanent=game.getPermanentEntering(source.getSourceId());
  if (permanent != null && object instanceof Integer) {
    int amount=((Integer)object);
    permanent.addCounters(CounterType.P1P1.createInstance(amount),game);
  }
  return false;
}",0.8
158467,"@Override public boolean apply(Game game,Ability source){
  Player player=game.getPlayer(source.getControllerId());
  MageObject sourceObject=game.getObject(source.getSourceId());
  int boost=amount.calculate(game,source,this);
  if (player != null) {
    Choice typeChoice=new ChoiceImpl(true);
    typeChoice.setMessage(""String_Node_Str"");
    typeChoice.setChoices(CardRepository.instance.getCreatureTypes());
    while (!player.choose(outcome,typeChoice,game)) {
      if (!player.canRespond()) {
        return false;
      }
    }
    if (typeChoice.getChoice() != null) {
      game.informPlayers(sourceObject.getLogName() + ""String_Node_Str"" + typeChoice.getChoice());
    }
    FilterCreaturePermanent filterCreaturePermanent=new FilterCreaturePermanent();
    filterCreaturePermanent.add(new SubtypePredicate(typeChoice.getChoice()));
    game.addEffect(new BoostAllOfChosenSubtypeEffect(boost,boost,Duration.EndOfTurn,filterCreaturePermanent,false),source);
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Player player=game.getPlayer(source.getControllerId());
  MageObject sourceObject=game.getObject(source.getSourceId());
  int boost=amount.calculate(game,source,this);
  if (player != null) {
    Choice typeChoice=new ChoiceImpl(true);
    typeChoice.setMessage(""String_Node_Str"");
    typeChoice.setChoices(CardRepository.instance.getCreatureTypes());
    while (!player.choose(outcome,typeChoice,game)) {
      if (!player.canRespond()) {
        return false;
      }
    }
    if (typeChoice.getChoice() != null) {
      game.informPlayers(sourceObject.getLogName() + ""String_Node_Str"" + typeChoice.getChoice());
    }
    FilterCreaturePermanent filterCreaturePermanent=new FilterCreaturePermanent();
    filterCreaturePermanent.add(new SubtypePredicate(typeChoice.getChoice()));
    game.addEffect(new BoostAllEffect(boost,boost,Duration.EndOfTurn,filterCreaturePermanent,false),source);
    return true;
  }
  return false;
}",0.992496248124062
158468,"@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  Permanent permanent=game.getPermanent(source.getSourceId());
  if (controller != null && permanent != null) {
    FilterCard filter=new FilterCard();
    filter.add(new SubtypePredicate(""String_Node_Str""));
    filter.add(new AuraCardCanAttachToPermanentId(permanent.getId()));
    TargetCardInHand target=new TargetCardInHand(0,1,filter);
    if (controller.choose(Outcome.PutCardInPlay,target,source.getSourceId(),game)) {
      Card auraInHand=game.getCard(target.getFirstTarget());
      if (auraInHand != null) {
        game.getState().setValue(""String_Node_Str"" + auraInHand.getId(),permanent);
        if (controller.moveCards(auraInHand,Zone.BATTLEFIELD,source,game)) {
          permanent.addAttachment(auraInHand.getId(),game);
        }
      }
    }
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  FilterCard filterCardInHand=new FilterCard();
  filterCardInHand.add(new SubtypePredicate(""String_Node_Str""));
  Player controller=game.getPlayer(source.getControllerId());
  Permanent academyResearchers=game.getPermanent(source.getSourceId());
  if (controller != null && academyResearchers != null) {
    filterCardInHand.add(new AuraCardCanAttachToPermanentId(academyResearchers.getId()));
    TargetCardInHand target=new TargetCardInHand(0,1,filterCardInHand);
    if (controller.choose(Outcome.PutCardInPlay,target,source.getSourceId(),game)) {
      Card auraInHand=game.getCard(target.getFirstTarget());
      if (auraInHand != null) {
        game.getState().setValue(""String_Node_Str"" + auraInHand.getId(),academyResearchers);
        auraInHand.putOntoBattlefield(game,Zone.HAND,source.getSourceId(),controller.getId());
        if (academyResearchers.addAttachment(auraInHand.getId(),game)) {
          game.informPlayers(controller.getLogName() + ""String_Node_Str"" + auraInHand.getLogName()+ ""String_Node_Str""+ academyResearchers.getLogName()+ ""String_Node_Str"");
          return true;
        }
      }
    }
  }
  return false;
}",0.6205923836389281
158469,"@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller != null) {
    Permanent auraPermanent=game.getPermanent(source.getSourceId());
    if (auraPermanent != null && auraPermanent.getSubtype().contains(""String_Node_Str"") && auraPermanent.getOwnerId().equals(source.getControllerId())) {
      Permanent enchantedPermanent=game.getPermanent(auraPermanent.getAttachedTo());
      filter.add(new AuraCardCanAttachToPermanentId(enchantedPermanent.getId()));
      TargetCardInHand target=new TargetCardInHand(0,1,filter);
      if (controller.choose(Outcome.PutCardInPlay,target,source.getSourceId(),game)) {
        Card auraInHand=game.getCard(target.getFirstTarget());
        if (auraInHand != null) {
          controller.moveCards(auraInHand,Zone.BATTLEFIELD,source,game);
          enchantedPermanent.addAttachment(auraInHand.getId(),game);
          controller.moveCards(auraPermanent,Zone.HAND,source,game);
          return true;
        }
      }
    }
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  FilterCard filterCardToCheck=new FilterCard();
  filterCardToCheck.add(new SubtypePredicate(""String_Node_Str""));
  Player controller=game.getPlayer(source.getControllerId());
  if (controller != null) {
    Permanent auraSourcePermanent=game.getPermanent(source.getSourceId());
    if (auraSourcePermanent != null && auraSourcePermanent.getSubtype().contains(""String_Node_Str"") && auraSourcePermanent.getOwnerId().equals(source.getControllerId())) {
      Permanent enchantedPermanent=game.getPermanent(auraSourcePermanent.getAttachedTo());
      filterCardToCheck.add(new AuraCardCanAttachToPermanentId(enchantedPermanent.getId()));
      TargetCardInHand target=new TargetCardInHand(filterCardToCheck);
      if (controller.choose(Outcome.PutCardInPlay,target,source.getSourceId(),game)) {
        Card auraInHand=game.getCard(target.getFirstTarget());
        if (auraInHand != null) {
          game.getState().setValue(""String_Node_Str"" + auraInHand.getId(),enchantedPermanent);
          auraInHand.putOntoBattlefield(game,Zone.HAND,source.getSourceId(),controller.getId());
          enchantedPermanent.addAttachment(auraInHand.getId(),game);
          game.informPlayers(controller.getLogName() + ""String_Node_Str"" + auraInHand.getLogName()+ ""String_Node_Str""+ enchantedPermanent.getLogName()+ ""String_Node_Str"");
          enchantedPermanent.removeAttachment(auraSourcePermanent.getId(),game);
          return controller.moveCardToHandWithInfo(auraSourcePermanent,source.getSourceId(),game);
        }
      }
    }
  }
  return false;
}",0.6609281437125748
158470,"@Override public String getText(Mode mode){
  return ""String_Node_Str"" + filter;
}","@Override public String getText(Mode mode){
  StringBuilder sb=new StringBuilder();
  sb.append(""String_Node_Str"").append(filter.getMessage());
  return sb.toString();
}",0.6215139442231076
158471,"@Test public void testExileNonLandCardAndCastIt(){
  removeAllCardsFromLibrary(playerA);
  addCard(Zone.BATTLEFIELD,playerB,""String_Node_Str"",1);
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"",1);
  addCard(Zone.HAND,playerA,""String_Node_Str"",1);
  addCard(Zone.LIBRARY,playerA,""String_Node_Str"",1);
  castSpell(1,PhaseStep.PRECOMBAT_MAIN,playerA,""String_Node_Str"",playerB);
  setChoice(playerB,""String_Node_Str"");
  setStopAt(1,PhaseStep.BEGIN_COMBAT);
  execute();
  assertLife(playerB,17);
  assertExileCount(""String_Node_Str"",1);
  assertHandCount(playerB,2);
}","@Test public void testExileNonLandCardAndCastIt(){
  addCard(Zone.BATTLEFIELD,playerB,""String_Node_Str"",1);
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"",1);
  addCard(Zone.HAND,playerA,""String_Node_Str"",1);
  addCard(Zone.LIBRARY,playerA,""String_Node_Str"",1);
  skipInitShuffling();
  castSpell(1,PhaseStep.PRECOMBAT_MAIN,playerA,""String_Node_Str"",playerB);
  setChoice(playerB,""String_Node_Str"");
  setStopAt(1,PhaseStep.BEGIN_COMBAT);
  execute();
  assertLife(playerB,17);
  assertExileCount(""String_Node_Str"",0);
  assertHandCount(playerB,2);
}",0.9440993788819876
158472,"@Override public Mode chooseMode(Modes modes,Ability source,Game game){
  if (!modesSet.isEmpty() && modes.getMaxModes() > modes.getSelectedModes().size()) {
    if (modesSet.get(0) == null) {
      modesSet.remove(0);
      return null;
    }
    int selectedMode=Integer.parseInt(modesSet.get(0));
    int i=1;
    for (    Mode mode : modes.getAvailableModes(source,game)) {
      if (i == selectedMode) {
        modesSet.remove(0);
        return mode;
      }
      i++;
    }
  }
  return computerPlayer.chooseMode(modes,source,game);
}","@Override public Mode chooseMode(Modes modes,Ability source,Game game){
  if (!modesSet.isEmpty() && modes.getMaxModes() > modes.getSelectedModes().size()) {
    if (modesSet.get(0) == null) {
      modesSet.remove(0);
      return null;
    }
    int selectedMode=Integer.parseInt(modesSet.get(0));
    int i=1;
    for (    Mode mode : modes.getAvailableModes(source,game)) {
      if (i == selectedMode) {
        modesSet.remove(0);
        return mode;
      }
      i++;
    }
  }
  if (modes.getMinModes() <= modes.getSelectedModes().size()) {
    return null;
  }
  return computerPlayer.chooseMode(modes,source,game);
}",0.9274124679760888
158473,"@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  Player targetOpponent=game.getPlayer(getTargetPointer().getFirst(game,source));
  if (controller != null && targetOpponent != null) {
    int amount=new AttackingCreatureCount().calculate(game,source,this);
    if (amount > 0) {
      targetOpponent.loseLife(amount,game);
      controller.gainLife(amount,game);
    }
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  Player targetOpponent=game.getPlayer(getTargetPointer().getFirst(game,source));
  if (controller != null && targetOpponent != null) {
    int amount=new AttackingFilterCreatureCount(filter).calculate(game,source,this);
    if (amount > 0) {
      targetOpponent.loseLife(amount,game);
      controller.gainLife(amount,game);
    }
    return true;
  }
  return false;
}",0.9876288659793816
158474,"@Override public boolean apply(Game game,Ability source){
  return true;
}","@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  MageObject sourceObject=source.getSourceObject(game);
  Player opponent=game.getPlayer(getTargetPointer().getFirst(game,source));
  if (controller != null && sourceObject != null && opponent != null) {
    if (opponent.getLibrary().size() > 0) {
      Card card=opponent.getLibrary().getFromTop(game);
      if (card != null && opponent.moveCards(card,Zone.EXILED,source,game)) {
        if (!card.getCardType().contains(CardType.LAND)) {
          if (controller.chooseUse(outcome,""String_Node_Str"" + card.getLogName() + ""String_Node_Str"",source,game)) {
            controller.cast(card.getSpellAbility(),game,true);
          }
        }
      }
    }
    return true;
  }
  return false;
}",0.1417322834645669
158475,"@Override public MindsDilationCastFromExileEffect copy(){
  return new MindsDilationCastFromExileEffect(this);
}","@Override public MindsDilationEffect copy(){
  return new MindsDilationEffect(this);
}",0.8686868686868687
158476,"public BecomesCreatureSourceEffect(final BecomesCreatureSourceEffect effect){
  super(effect);
  this.token=effect.token.copy();
  this.type=effect.type;
  this.losePreviousTypes=effect.losePreviousTypes;
  this.power=effect.power.copy();
  this.toughness=effect.toughness.copy();
}","public BecomesCreatureSourceEffect(final BecomesCreatureSourceEffect effect){
  super(effect);
  this.token=effect.token.copy();
  this.type=effect.type;
  this.losePreviousTypes=effect.losePreviousTypes;
  if (effect.power != null) {
    this.power=effect.power.copy();
  }
  if (effect.toughness != null) {
    this.toughness=effect.toughness.copy();
  }
}",0.75
158477,"public SpellsCastWatcher(final SpellsCastWatcher watcher){
  super(watcher);
}","public SpellsCastWatcher(final SpellsCastWatcher watcher){
  super(watcher);
  this.spellsCast.putAll(watcher.spellsCast);
}",0.7722772277227723
158478,"@Ignore @Test public void testFieldResearcherFirstEffect(){
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"",1);
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"",1);
  activateAbility(1,PhaseStep.PRECOMBAT_MAIN,playerA,""String_Node_Str"");
  activateAbility(3,PhaseStep.PRECOMBAT_MAIN,playerA,""String_Node_Str"");
  activateAbility(3,PhaseStep.PRECOMBAT_MAIN,playerA,""String_Node_Str"");
  addTarget(playerA,""String_Node_Str"");
  addTarget(playerA,""String_Node_Str"");
  attack(3,playerA,""String_Node_Str"");
  attack(3,playerA,""String_Node_Str"");
  setStopAt(3,PhaseStep.END_COMBAT);
  execute();
  assertLife(playerB,13);
  assertPermanentCount(playerA,""String_Node_Str"",1);
  assertPermanentCount(playerA,""String_Node_Str"",1);
  assertPermanentCount(playerA,""String_Node_Str"",1);
  assertHandCount(playerA,3);
}","@Test public void testFieldResearcherFirstEffect(){
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"",1);
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"",1);
  activateAbility(1,PhaseStep.PRECOMBAT_MAIN,playerA,""String_Node_Str"");
  activateAbility(3,PhaseStep.PRECOMBAT_MAIN,playerA,""String_Node_Str"");
  activateAbility(3,PhaseStep.PRECOMBAT_MAIN,playerA,""String_Node_Str"");
  addTarget(playerA,""String_Node_Str"");
  attack(3,playerA,""String_Node_Str"");
  attack(3,playerA,""String_Node_Str"");
  setStopAt(3,PhaseStep.END_COMBAT);
  execute();
  assertLife(playerB,13);
  assertPermanentCount(playerA,""String_Node_Str"",1);
  assertPermanentCount(playerA,""String_Node_Str"",1);
  assertPermanentCount(playerA,""String_Node_Str"",1);
  assertHandCount(playerA,3);
}",0.969735182849937
158479,"public GideonChampionOfJusticeToken(){
  super(""String_Node_Str"",""String_Node_Str"");
  cardType.add(CardType.CREATURE);
  subtype.add(""String_Node_Str"");
  subtype.add(""String_Node_Str"");
  power=new MageInt(0);
  toughness=new MageInt(0);
  this.addAbility(IndestructibleAbility.getInstance());
  this.addAbility(new SimpleStaticAbility(Zone.ALL,new SetPowerToughnessSourceEffect(new CountersCount(CounterType.LOYALTY),Duration.WhileOnBattlefield)));
}","public GideonChampionOfJusticeToken(){
  super(""String_Node_Str"",""String_Node_Str"");
  cardType.add(CardType.CREATURE);
  subtype.add(""String_Node_Str"");
  subtype.add(""String_Node_Str"");
  power=new MageInt(0);
  toughness=new MageInt(0);
  this.addAbility(IndestructibleAbility.getInstance());
  CountersCount loyaltyCount=new CountersCount(CounterType.LOYALTY);
  this.addAbility(new SimpleStaticAbility(Zone.ALL,new SetPowerToughnessSourceEffect(loyaltyCount,Duration.WhileOnBattlefield)));
}",0.8746048472075869
158480,"public GideonChampionOfJusticeToken(){
  super(""String_Node_Str"",""String_Node_Str"");
  cardType.add(CardType.CREATURE);
  subtype.add(""String_Node_Str"");
  subtype.add(""String_Node_Str"");
  power=new MageInt(0);
  toughness=new MageInt(0);
  this.addAbility(IndestructibleAbility.getInstance());
  CountersCount loyaltyCount=new CountersCount(CounterType.LOYALTY);
  this.addAbility(new SimpleStaticAbility(Zone.ALL,new SetPowerToughnessSourceEffect(loyaltyCount,Duration.WhileOnBattlefield)));
}","public GideonChampionOfJusticeToken(){
  super(""String_Node_Str"",""String_Node_Str"");
  cardType.add(CardType.CREATURE);
  subtype.add(""String_Node_Str"");
  subtype.add(""String_Node_Str"");
  power=new MageInt(0);
  toughness=new MageInt(0);
  this.addAbility(IndestructibleAbility.getInstance());
}",0.7490542244640606
158481,"public BecomesCreatureSourceEffect(final BecomesCreatureSourceEffect effect){
  super(effect);
  this.token=effect.token.copy();
  this.type=effect.type;
  this.losePreviousTypes=effect.losePreviousTypes;
}","public BecomesCreatureSourceEffect(final BecomesCreatureSourceEffect effect){
  super(effect);
  this.token=effect.token.copy();
  this.type=effect.type;
  this.losePreviousTypes=effect.losePreviousTypes;
  this.power=effect.power;
  this.toughness=effect.toughness;
}",0.869198312236287
158482,"@Override public boolean checkTrigger(GameEvent event,Game game){
switch (sacrificingPlayer) {
case YOU:
    if (event.getPlayerId().equals(getControllerId())) {
      return false;
    }
  break;
case OPPONENT:
Player controller=game.getPlayer(getControllerId());
if (controller == null || !controller.hasOpponent(event.getPlayerId(),game)) {
return false;
}
break;
}
Permanent sacrificedPermanent=game.getPermanentOrLKIBattlefield(event.getTargetId());
return sacrificedPermanent != null && filter.match(sacrificedPermanent,getSourceId(),getControllerId(),game);
}","@Override public boolean checkTrigger(GameEvent event,Game game){
  boolean sacrificed=false;
switch (sacrificingPlayer) {
case YOU:
    if (event.getPlayerId().equals(getControllerId())) {
      sacrificed=true;
    }
  break;
case OPPONENT:
Player controller=game.getPlayer(getControllerId());
if (controller == null || !controller.hasOpponent(event.getPlayerId(),game)) {
sacrificed=true;
}
break;
}
Permanent sacrificedPermanent=game.getPermanentOrLKIBattlefield(event.getTargetId());
return sacrificed && sacrificedPermanent != null && filter.match(sacrificedPermanent,getSourceId(),getControllerId(),game);
}",0.8932203389830509
158483,"@Override public boolean checkTrigger(GameEvent event,Game game){
  UUID targetId=event.getTargetId();
  Permanent permanent=game.getPermanent(targetId);
  if (permanent.getCardType().contains(CardType.ARTIFACT)) {
    for (    Effect effect : this.getEffects()) {
      effect.setTargetPointer(new FixedTarget(this));
    }
    return true;
  }
  return false;
}","@java.lang.Override public boolean checkTrigger(GameEvent event,Game game){
  UUID targetId=event.getTargetId();
  Permanent permanent=game.getPermanent(targetId);
  if (permanent.getCardType().contains(CardType.ARTIFACT)) {
    for (    Effect effect : this.getEffects()) {
      effect.setTargetPointer(new FixedTarget(permanent,game));
    }
    return true;
  }
  return false;
}",0.9624664879356568
158484,"@Override public boolean checkEventType(GameEvent event,Game game){
  return event.getType() == GameEvent.EventType.ENTERS_THE_BATTLEFIELD;
}","@java.lang.Override public boolean checkEventType(GameEvent event,Game game){
  return event.getType() == GameEvent.EventType.ENTERS_THE_BATTLEFIELD;
}",0.9657534246575342
158485,"@Override public String getRule(){
  return ""String_Node_Str"";
}","@java.lang.Override public String getRule(){
  return ""String_Node_Str"";
}",0.927536231884058
158486,"@Override public SerumTankTriggeredAbility copy(){
  return new SerumTankTriggeredAbility(this);
}","@java.lang.Override public SerumTankTriggeredAbility copy(){
  return new SerumTankTriggeredAbility(this);
}",0.9514563106796116
158487,"@Override public boolean apply(Game game,Ability source){
  Permanent permanent=game.getPermanent(source.getFirstTarget());
  Player controller=game.getPlayer(source.getControllerId());
  Permanent sourcePermanent=game.getPermanentOrLKIBattlefield(source.getSourceId());
  if (controller != null && permanent != null && sourcePermanent != null) {
    if (controller.moveCardToExileWithInfo(permanent,source.getSourceId(),sourcePermanent.getIdName(),source.getSourceId(),game,Zone.BATTLEFIELD,true)) {
      MageObject mageObject=game.getObject(permanent.getId());
      if (mageObject != null) {
        CopyEffect copyEffect=new CopyEffect(Duration.EndOfTurn,mageObject,source.getSourceId());
        game.addEffect(copyEffect,source);
      }
      AtTheBeginOfNextEndStepDelayedTriggeredAbility delayedAbility=new AtTheBeginOfNextEndStepDelayedTriggeredAbility(new ReturnFromExileEffect(source.getSourceId(),Zone.BATTLEFIELD,false));
      delayedAbility.setSourceId(source.getSourceId());
      delayedAbility.setControllerId(source.getControllerId());
      delayedAbility.setSourceObject(source.getSourceObject(game),game);
      game.addDelayedTriggeredAbility(delayedAbility);
      return true;
    }
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Permanent permanent=game.getPermanent(source.getFirstTarget());
  Player controller=game.getPlayer(source.getControllerId());
  Permanent sourcePermanent=game.getPermanentOrLKIBattlefield(source.getSourceId());
  if (controller != null && permanent != null && sourcePermanent != null) {
    CopyEffect copyEffect=new CopyEffect(Duration.EndOfTurn,permanent,source.getSourceId());
    if (controller.moveCardToExileWithInfo(permanent,source.getSourceId(),sourcePermanent.getIdName(),source.getSourceId(),game,Zone.BATTLEFIELD,true)) {
      game.addEffect(copyEffect,source);
      AtTheBeginOfNextEndStepDelayedTriggeredAbility delayedAbility=new AtTheBeginOfNextEndStepDelayedTriggeredAbility(new ReturnFromExileEffect(source.getSourceId(),Zone.BATTLEFIELD,false));
      delayedAbility.setSourceId(source.getSourceId());
      delayedAbility.setControllerId(source.getControllerId());
      delayedAbility.setSourceObject(source.getSourceObject(game),game);
      game.addDelayedTriggeredAbility(delayedAbility);
      return true;
    }
  }
  return false;
}",0.8469387755102041
158488,"@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  Permanent permanent=game.getPermanentEntering(source.getSourceId());
  if (controller != null && permanent != null) {
    if (controller.flipCoin(game)) {
      game.informPlayers(""String_Node_Str"");
      game.addEffect(new SetPowerSourceEffect(new StaticValue(5),Duration.WhileOnBattlefield),source);
      game.addEffect(new SetToughnessSourceEffect(new StaticValue(2),Duration.WhileOnBattlefield),source);
      game.addEffect(new GainAbilitySourceEffect(HasteAbility.getInstance(),Duration.WhileOnBattlefield),source);
      return true;
    }
 else {
      game.informPlayers(""String_Node_Str"");
      game.addEffect(new SetPowerSourceEffect(new StaticValue(2),Duration.WhileOnBattlefield),source);
      game.addEffect(new SetToughnessSourceEffect(new StaticValue(5),Duration.WhileOnBattlefield),source);
      game.addEffect(new GainAbilitySourceEffect(DefenderAbility.getInstance(),Duration.WhileOnBattlefield),source);
      return true;
    }
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  Permanent permanent=game.getPermanentEntering(source.getSourceId());
  if (controller != null && permanent != null) {
    if (controller.flipCoin(game)) {
      game.informPlayers(""String_Node_Str"" + permanent.getLogName() + ""String_Node_Str"");
      game.addEffect(new SetPowerSourceEffect(new StaticValue(5),Duration.WhileOnBattlefield),source);
      game.addEffect(new SetToughnessSourceEffect(new StaticValue(2),Duration.WhileOnBattlefield),source);
      game.addEffect(new GainAbilitySourceEffect(HasteAbility.getInstance(),Duration.WhileOnBattlefield),source);
      return true;
    }
 else {
      game.informPlayers(""String_Node_Str"" + permanent.getLogName() + ""String_Node_Str"");
      game.addEffect(new SetPowerSourceEffect(new StaticValue(2),Duration.WhileOnBattlefield),source);
      game.addEffect(new SetToughnessSourceEffect(new StaticValue(5),Duration.WhileOnBattlefield),source);
      game.addEffect(new GainAbilitySourceEffect(DefenderAbility.getInstance(),Duration.WhileOnBattlefield),source);
      return true;
    }
  }
  return false;
}",0.9605954465849388
158489,"@Override public boolean apply(Game game,Ability source,Ability abilityToModify){
  int numCosts=abilityToModify.getModes().getSelectedModes().size() - 1;
  for (int i=0; i < numCosts; i++) {
    abilityToModify.addCost(cost);
  }
  return true;
}","@Override public boolean apply(Game game,Ability source,Ability abilityToModify){
  int numCosts=abilityToModify.getModes().getSelectedModes().size() - 1;
  for (int i=0; i < numCosts; i++) {
    abilityToModify.addCost(cost.copy());
  }
  return true;
}",0.9860279441117764
158490,"@Override public BufferedImage apply(BufferedImage image){
  if (key.width != image.getWidth() || key.height != image.getHeight())   image=resizeImage(image,key.width,key.height);
  if (key.angle != 0.0)   image=rotateImage(image,key.angle);
  return image;
}","@Override public BufferedImage apply(BufferedImage image){
  if (key.width != image.getWidth() || key.height != image.getHeight()) {
    image=resizeImage(image,key.width,key.height);
  }
  if (key.angle != 0.0) {
    image=rotateImage(image,key.angle);
  }
  return image;
}",0.9700374531835206
158491,"public static BufferedImage getRotatedResizedImage(BufferedImage image,int width,int height,double angle){
  int imageWidth=image.getWidth();
  int imageHeight=image.getHeight();
  if (angle == 0.0 && (width < 0 || imageWidth == width) && (height < 0 || imageHeight == height))   return image;
  int resWidth;
  int resHeight;
  if (width < 0 && height < 0) {
    resWidth=imageWidth;
    resHeight=imageHeight;
  }
 else   if ((height < 0) || (width >= 0 && imageHeight * width <= imageWidth * height)) {
    resWidth=width;
    resHeight=imageHeight * width / imageWidth;
  }
 else {
    resWidth=imageWidth * height / imageHeight;
    resHeight=height;
  }
  if (angle == 0.0 && imageWidth == resWidth && imageHeight == resHeight)   return image;
  return IMAGE_CACHE.get(new Key(resWidth,resHeight,angle)).get(image);
}","public static BufferedImage getRotatedResizedImage(BufferedImage image,int width,int height,double angle){
  int imageWidth=image.getWidth();
  int imageHeight=image.getHeight();
  if (angle == 0.0 && (width < 0 || imageWidth == width) && (height < 0 || imageHeight == height)) {
    return image;
  }
  int resWidth;
  int resHeight;
  if (width < 0 && height < 0) {
    resWidth=imageWidth;
    resHeight=imageHeight;
  }
 else   if ((height < 0) || (width >= 0 && imageHeight * width <= imageWidth * height)) {
    resWidth=width;
    resHeight=imageHeight * width / imageWidth;
  }
 else {
    resWidth=imageWidth * height / imageHeight;
    resHeight=height;
  }
  if (angle == 0.0 && imageWidth == resWidth && imageHeight == resHeight) {
    return image;
  }
  if (resWidth < 3) {
    resWidth=3;
  }
  if (resHeight < 3) {
    resHeight=3;
  }
  return IMAGE_CACHE.get(new Key(resWidth,resHeight,angle)).get(image);
}",0.9416475972540046
158492,"@Override public void restoreState(int bookmark,String context){
  if (!simulation && !this.hasEnded()) {
    if (bookmark != 0) {
      if (!savedStates.contains(bookmark - 1)) {
        throw new UnsupportedOperationException(""String_Node_Str"" + (bookmark - 1) + ""String_Node_Str""+ context);
      }
      int stateNum=savedStates.get(bookmark - 1);
      removeBookmark(bookmark);
      GameState restore=gameStates.rollback(stateNum);
      if (restore != null) {
        state.restore(restore);
        playerList.setCurrent(state.getActivePlayerId());
      }
    }
  }
}","@Override public void restoreState(int bookmark,String context){
  if (!simulation && !this.hasEnded()) {
    if (bookmark != 0) {
      if (!savedStates.contains(bookmark - 1)) {
        throw new UnsupportedOperationException(""String_Node_Str"" + (bookmark - 1) + ""String_Node_Str""+ context);
      }
      int stateNum=savedStates.get(bookmark - 1);
      removeBookmark(bookmark);
      GameState restore=gameStates.rollback(stateNum);
      if (restore != null) {
        state.restore(restore);
        playerList.setCurrent(state.getPlayerList().get());
      }
    }
  }
}",0.9844290657439446
158493,"@Override public void saveState(boolean bookmark){
  if (!simulation && gameStates != null) {
    if (bookmark || saveGame) {
      gameStates.save(state);
    }
  }
}","@Override public void saveState(boolean bookmark){
  if (!simulation && gameStates != null) {
    if (bookmark || saveGame) {
      state.getPlayerList().setCurrent(playerList.get());
      gameStates.save(state);
    }
  }
}",0.8520408163265306
158494,"@Override public synchronized void rollbackTurns(int turnsToRollback){
  if (gameOptions.rollbackTurnsAllowed) {
    int turnToGoTo=getTurnNum() - turnsToRollback;
    if (turnToGoTo < 1 || !gameStatesRollBack.containsKey(turnToGoTo)) {
      informPlayers(GameLog.getPlayerRequestColoredText(""String_Node_Str"" + turnsToRollback + ""String_Node_Str""));
    }
 else {
      GameState restore=gameStatesRollBack.get(turnToGoTo);
      if (restore != null) {
        informPlayers(GameLog.getPlayerRequestColoredText(""String_Node_Str"" + restore.getTurnNum()));
        state.restoreForRollBack(restore);
        playerList.setCurrent(state.getActivePlayerId());
        gameStatesRollBack.put(getTurnNum(),state.copy());
        executingRollback=true;
        for (        Player playerObject : getPlayers().values()) {
          if (playerObject.isHuman() && playerObject.isInGame()) {
            playerObject.abort();
            playerObject.resetPlayerPassedActions();
          }
        }
        fireUpdatePlayersEvent();
      }
    }
  }
}","@Override public synchronized void rollbackTurns(int turnsToRollback){
  if (gameOptions.rollbackTurnsAllowed) {
    int turnToGoTo=getTurnNum() - turnsToRollback;
    if (turnToGoTo < 1 || !gameStatesRollBack.containsKey(turnToGoTo)) {
      informPlayers(GameLog.getPlayerRequestColoredText(""String_Node_Str"" + turnsToRollback + ""String_Node_Str""));
    }
 else {
      GameState restore=gameStatesRollBack.get(turnToGoTo);
      if (restore != null) {
        informPlayers(GameLog.getPlayerRequestColoredText(""String_Node_Str"" + restore.getTurnNum()));
        state.restoreForRollBack(restore);
        playerList.setCurrent(state.getPlayerList().get());
        gameStatesRollBack.put(getTurnNum(),state.copy());
        executingRollback=true;
        for (        Player playerObject : getPlayers().values()) {
          if (playerObject.isHuman() && playerObject.isInGame()) {
            playerObject.abort();
            playerObject.resetPlayerPassedActions();
          }
        }
        fireUpdatePlayersEvent();
      }
    }
  }
}",0.991404011461318
158495,"public void restore(GameState state){
  this.activePlayerId=state.activePlayerId;
  this.playerList.setCurrent(state.activePlayerId);
  this.priorityPlayerId=state.priorityPlayerId;
  this.stack=state.stack;
  this.command=state.command;
  this.exile=state.exile;
  this.battlefield=state.battlefield;
  this.turnNum=state.turnNum;
  this.stepNum=state.stepNum;
  this.extraTurn=state.extraTurn;
  this.legendaryRuleActive=state.legendaryRuleActive;
  this.effects=state.effects;
  this.triggered=state.triggered;
  this.triggers=state.triggers;
  this.delayed=state.delayed;
  this.specialActions=state.specialActions;
  this.combat=state.combat;
  this.turnMods=state.turnMods;
  this.watchers=state.watchers;
  this.values=state.values;
  for (  Player copyPlayer : state.players.values()) {
    Player origPlayer=players.get(copyPlayer.getId());
    origPlayer.restore(copyPlayer);
  }
  this.zones=state.zones;
  this.simultaneousEvents=state.simultaneousEvents;
  this.cardState=state.cardState;
  this.cardAttribute=state.cardAttribute;
  this.zoneChangeCounter=state.zoneChangeCounter;
  this.copiedCards=state.copiedCards;
  this.permanentOrderNumber=state.permanentOrderNumber;
}","public void restore(GameState state){
  this.activePlayerId=state.activePlayerId;
  this.playerList.setCurrent(state.playerList.get());
  this.priorityPlayerId=state.priorityPlayerId;
  this.stack=state.stack;
  this.command=state.command;
  this.exile=state.exile;
  this.battlefield=state.battlefield;
  this.turnNum=state.turnNum;
  this.stepNum=state.stepNum;
  this.extraTurn=state.extraTurn;
  this.legendaryRuleActive=state.legendaryRuleActive;
  this.effects=state.effects;
  this.triggered=state.triggered;
  this.triggers=state.triggers;
  this.delayed=state.delayed;
  this.specialActions=state.specialActions;
  this.combat=state.combat;
  this.turnMods=state.turnMods;
  this.watchers=state.watchers;
  this.values=state.values;
  for (  Player copyPlayer : state.players.values()) {
    Player origPlayer=players.get(copyPlayer.getId());
    origPlayer.restore(copyPlayer);
  }
  this.zones=state.zones;
  this.simultaneousEvents=state.simultaneousEvents;
  this.cardState=state.cardState;
  this.cardAttribute=state.cardAttribute;
  this.zoneChangeCounter=state.zoneChangeCounter;
  this.copiedCards=state.copiedCards;
  this.permanentOrderNumber=state.permanentOrderNumber;
}",0.4058823529411764
158496,"public static void transformCard(final CardPanel panel,final MagePermanent parent,final boolean transformed){
  new Animation(1200){
    private boolean state=false;
    @Override protected void start(){
      parent.onBeginAnimation();
    }
    @Override protected void update(    float percentage){
      double p=percentage * 2;
      if (percentage > 0.5) {
        if (!state) {
          parent.toggleTransformed();
        }
        state=true;
        p=(p - 0.5) * 2;
      }
      if (!state) {
        panel.transformAngle=Math.max(0.01,1 - p);
      }
 else {
        panel.transformAngle=Math.max(0.01,p - 1);
      }
      panel.repaint();
    }
    @Override protected void end(){
      if (!state) {
        parent.toggleTransformed();
      }
      state=true;
      panel.transformAngle=0;
      parent.onEndAnimation();
      parent.repaint();
    }
  }
;
}","public static void transformCard(final CardPanel panel,final MagePermanent parent,final boolean transformed){
  new Animation(1200){
    private boolean state=false;
    @Override protected void start(){
      parent.onBeginAnimation();
    }
    @Override protected void update(    float percentage){
      double p=percentage * 2;
      if (percentage > 0.5) {
        if (!state) {
          parent.toggleTransformed();
        }
        state=true;
        p=(p - 0.5) * 2;
      }
      if (!state) {
        panel.transformAngle=Math.max(0.01,1 - p);
      }
 else {
        panel.transformAngle=Math.max(0.01,p - 1);
      }
      panel.repaint();
    }
    @Override protected void end(){
      if (!state) {
        parent.toggleTransformed();
      }
      state=true;
      panel.transformAngle=1;
      parent.onEndAnimation();
      parent.repaint();
    }
  }
;
}",0.998859749144812
158497,"public PlayerView(Player player,GameState state,Game game,UUID createdForPlayerId,UUID watcherUserId){
  this.playerId=player.getId();
  this.name=player.getName();
  this.life=player.getLife();
  this.poison=player.getCounters().getCount(CounterType.POISON);
  this.experience=player.getCounters().getCount(CounterType.EXPERIENCE);
  this.wins=player.getMatchPlayer().getWins();
  this.winsNeeded=player.getMatchPlayer().getWinsNeeded();
  this.deckHashCode=player.getMatchPlayer().getDeck() != null ? player.getMatchPlayer().getDeck().getDeckHashCode() : 0;
  this.libraryCount=player.getLibrary().size();
  this.handCount=player.getHand().size();
  this.manaPool=new ManaPoolView(player.getManaPool());
  this.isActive=(player.getId().equals(state.getActivePlayerId()));
  this.hasPriority=player.getId().equals(state.getPriorityPlayerId());
  this.priorityTimeLeft=player.getPriorityTimeLeft();
  this.timerActive=(this.hasPriority && player.isGameUnderControl()) || (player.getPlayersUnderYourControl().contains(state.getPriorityPlayerId())) || player.getId().equals(game.getState().getChoosingPlayerId());
  this.hasLeft=player.hasLeft();
  for (  Card card : player.getGraveyard().getCards(game)) {
    graveyard.put(card.getId(),new CardView(card,game,false));
  }
  for (  ExileZone exileZone : game.getExile().getExileZones()) {
    for (    Card card : exileZone.getCards(game)) {
      if (player.getId().equals(card.getOwnerId())) {
        exile.put(card.getId(),new CardView(card,game,false));
      }
    }
  }
  for (  Permanent permanent : state.getBattlefield().getAllPermanents()) {
    if (showInBattlefield(permanent,state)) {
      PermanentView view=new PermanentView(permanent,game.getCard(permanent.getId()),createdForPlayerId,game);
      battlefield.put(view.getId(),view);
    }
  }
  this.topCard=player.isTopCardRevealed() && player.getLibrary().size() > 0 ? new CardView(player.getLibrary().getFromTop(game)) : null;
  if (player.getUserData() != null) {
    this.userData=player.getUserData();
  }
 else {
    this.userData=UserData.getDefaultUserDataView();
  }
  for (  CommandObject commandObject : game.getState().getCommand()) {
    if (commandObject instanceof Emblem) {
      Emblem emblem=(Emblem)commandObject;
      if (emblem.getControllerId().equals(this.playerId)) {
        Card sourceCard=game.getCard(((CommandObject)emblem).getSourceId());
        if (sourceCard != null) {
          if (!sourceCard.getCardType().contains(CardType.PLANESWALKER)) {
            if (sourceCard.getSecondCardFace() != null) {
              sourceCard=sourceCard.getSecondCardFace();
            }
          }
          commandList.add(new EmblemView(emblem,sourceCard));
        }
 else {
          commandList.add(new EmblemView(emblem));
        }
      }
    }
 else     if (commandObject instanceof Commander) {
      Commander commander=(Commander)commandObject;
      if (commander.getControllerId().equals(this.playerId)) {
        Card sourceCard=game.getCard(commander.getSourceId());
        if (sourceCard != null) {
          commandList.add(new CommanderView(commander,sourceCard,game));
        }
      }
    }
  }
  if (player.getAttachments() != null) {
    attachments.addAll(player.getAttachments());
  }
  this.statesSavedSize=player.getStoredBookmark();
  this.passedTurn=player.getPassedTurn();
  this.passedUntilEndOfTurn=player.getPassedUntilEndOfTurn();
  this.passedUntilNextMain=player.getPassedUntilNextMain();
  this.passedAllTurns=player.getPassedAllTurns();
  this.passedUntilStackResolved=player.getPassedUntilStackResolved();
  this.passedUntilEndStepBeforeMyTurn=player.getPassedUntilEndStepBeforeMyTurn();
}","public PlayerView(Player player,GameState state,Game game,UUID createdForPlayerId,UUID watcherUserId){
  this.playerId=player.getId();
  this.name=player.getName();
  this.life=player.getLife();
  this.poison=player.getCounters().getCount(CounterType.POISON);
  this.experience=player.getCounters().getCount(CounterType.EXPERIENCE);
  this.wins=player.getMatchPlayer().getWins();
  this.winsNeeded=player.getMatchPlayer().getWinsNeeded();
  this.deckHashCode=player.getMatchPlayer().getDeck() != null ? player.getMatchPlayer().getDeck().getDeckHashCode() : 0;
  this.libraryCount=player.getLibrary().size();
  this.handCount=player.getHand().size();
  this.manaPool=new ManaPoolView(player.getManaPool());
  this.isActive=(player.getId().equals(state.getActivePlayerId()));
  this.hasPriority=player.getId().equals(state.getPriorityPlayerId());
  this.priorityTimeLeft=player.getPriorityTimeLeft();
  this.timerActive=(this.hasPriority && player.isGameUnderControl()) || (player.getPlayersUnderYourControl().contains(state.getPriorityPlayerId())) || player.getId().equals(game.getState().getChoosingPlayerId());
  this.hasLeft=player.hasLeft();
  for (  Card card : player.getGraveyard().getCards(game)) {
    graveyard.put(card.getId(),new CardView(card,game,false));
  }
  for (  ExileZone exileZone : game.getExile().getExileZones()) {
    for (    Card card : exileZone.getCards(game)) {
      if (player.getId().equals(card.getOwnerId())) {
        exile.put(card.getId(),new CardView(card,game,false));
      }
    }
  }
  try {
    for (    Permanent permanent : state.getBattlefield().getAllPermanents()) {
      if (showInBattlefield(permanent,state)) {
        PermanentView view=new PermanentView(permanent,game.getCard(permanent.getId()),createdForPlayerId,game);
        battlefield.put(view.getId(),view);
      }
    }
  }
 catch (  ConcurrentModificationException e) {
  }
  this.topCard=player.isTopCardRevealed() && player.getLibrary().size() > 0 ? new CardView(player.getLibrary().getFromTop(game)) : null;
  if (player.getUserData() != null) {
    this.userData=player.getUserData();
  }
 else {
    this.userData=UserData.getDefaultUserDataView();
  }
  for (  CommandObject commandObject : game.getState().getCommand()) {
    if (commandObject instanceof Emblem) {
      Emblem emblem=(Emblem)commandObject;
      if (emblem.getControllerId().equals(this.playerId)) {
        Card sourceCard=game.getCard(((CommandObject)emblem).getSourceId());
        if (sourceCard != null) {
          if (!sourceCard.getCardType().contains(CardType.PLANESWALKER)) {
            if (sourceCard.getSecondCardFace() != null) {
              sourceCard=sourceCard.getSecondCardFace();
            }
          }
          commandList.add(new EmblemView(emblem,sourceCard));
        }
 else {
          commandList.add(new EmblemView(emblem));
        }
      }
    }
 else     if (commandObject instanceof Commander) {
      Commander commander=(Commander)commandObject;
      if (commander.getControllerId().equals(this.playerId)) {
        Card sourceCard=game.getCard(commander.getSourceId());
        if (sourceCard != null) {
          commandList.add(new CommanderView(commander,sourceCard,game));
        }
      }
    }
  }
  if (player.getAttachments() != null) {
    attachments.addAll(player.getAttachments());
  }
  this.statesSavedSize=player.getStoredBookmark();
  this.passedTurn=player.getPassedTurn();
  this.passedUntilEndOfTurn=player.getPassedUntilEndOfTurn();
  this.passedUntilNextMain=player.getPassedUntilNextMain();
  this.passedAllTurns=player.getPassedAllTurns();
  this.passedUntilStackResolved=player.getPassedUntilStackResolved();
  this.passedUntilEndStepBeforeMyTurn=player.getPassedUntilEndStepBeforeMyTurn();
}",0.9896240398868076
158498,"@Override public boolean apply(Game game,Ability source){
  Player defender=null;
  if (attackerIsSource) {
    defender=game.getPlayer(game.getCombat().getDefenderId(source.getSourceId()));
  }
 else {
    defender=game.getPlayer(game.getCombat().getDefenderId(getTargetPointer().getFirst(game,source)));
  }
  if (defender != null) {
    defender.loseLife(amount.calculate(game,source,this),game);
  }
  return true;
}","@Override public boolean apply(Game game,Ability source){
  Player defender=null;
  if (attackerIsSource) {
    defender=game.getPlayer(game.getCombat().getDefenderId(source.getSourceId()));
  }
 else {
    defender=game.getPlayer(getTargetPointer().getFirst(game,source));
  }
  if (defender != null) {
    defender.loseLife(amount.calculate(game,source,this),game);
  }
  return true;
}",0.9603960396039604
158499,"@Override public int calculate(Game game,Ability sourceAbility,Effect effect){
  CallerOfTheClawWatcher watcher=(CallerOfTheClawWatcher)game.getState().getWatchers().get(""String_Node_Str"",sourceAbility.getControllerId());
  if (watcher != null) {
    return watcher.getCreaturesCount();
  }
  return 0;
}","@Override public int calculate(Game game,Ability sourceAbility,Effect effect){
  CallerOfTheClawWatcher watcher=(CallerOfTheClawWatcher)game.getState().getWatchers().get(CallerOfTheClawWatcher.class.getName(),sourceAbility.getControllerId());
  if (watcher != null) {
    return watcher.getCreaturesCount();
  }
  return 0;
}",0.9157392686804452
158500,"@Override public int calculate(Game game,Ability sourceAbility,Effect effect){
  FreshMeatWatcher watcher=(FreshMeatWatcher)game.getState().getWatchers().get(""String_Node_Str"",sourceAbility.getControllerId());
  if (watcher != null) {
    return watcher.getCreaturesCount();
  }
  return 0;
}","@Override public int calculate(Game game,Ability sourceAbility,Effect effect){
  CreaturesDiedWatcher watcher=(CreaturesDiedWatcher)game.getState().getWatchers().get(""String_Node_Str"");
  if (watcher != null) {
    return watcher.getAmountOfCreaturesDiesThisTurn(sourceAbility.getControllerId());
  }
  return 0;
}",0.6864686468646864
158501,"@Override public void watch(GameEvent event,Game game){
  if (event.getType() == GameEvent.EventType.ZONE_CHANGE) {
    ZoneChangeEvent zEvent=(ZoneChangeEvent)event;
    if (zEvent.isDiesEvent() && zEvent.getTarget() != null && zEvent.getTarget().getCardType().contains(CardType.CREATURE)) {
      amountOfCreaturesThatDied++;
    }
  }
}","@Override public void watch(GameEvent event,Game game){
  if (event.getType() == GameEvent.EventType.ZONE_CHANGE) {
    ZoneChangeEvent zEvent=(ZoneChangeEvent)event;
    if (zEvent.isDiesEvent() && zEvent.getTarget() != null && zEvent.getTarget().getCardType().contains(CardType.CREATURE)) {
      amountOfCreaturesThatDied++;
      int amount=0;
      if (amountOfCreaturesThatDiedByController.containsKey(zEvent.getTarget().getControllerId())) {
        amount=amountOfCreaturesThatDiedByController.get(zEvent.getTarget().getControllerId());
      }
      amountOfCreaturesThatDiedByController.put(zEvent.getTarget().getControllerId(),amount + 1);
    }
  }
}",0.6773226773226774
158502,"public CreaturesDiedWatcher(final CreaturesDiedWatcher watcher){
  super(watcher);
  this.amountOfCreaturesThatDied=watcher.amountOfCreaturesThatDied;
}","public CreaturesDiedWatcher(final CreaturesDiedWatcher watcher){
  super(watcher);
  this.amountOfCreaturesThatDied=watcher.amountOfCreaturesThatDied;
  this.amountOfCreaturesThatDiedByController.putAll(watcher.amountOfCreaturesThatDiedByController);
}",0.7524752475247525
158503,"@Override public void reset(){
  amountOfCreaturesThatDied=0;
}","@Override public void reset(){
  amountOfCreaturesThatDied=0;
  amountOfCreaturesThatDiedByController.clear();
}",0.72
158504,"public int getAmountOfCreaturesDiesThisTurn(){
  return amountOfCreaturesThatDied;
}","public int getAmountOfCreaturesDiesThisTurn(UUID playerId){
  if (amountOfCreaturesThatDiedByController.containsKey(playerId)) {
    return amountOfCreaturesThatDiedByController.get(playerId);
  }
  return 0;
}",0.5238095238095238
158505,"@Override public void init(Ability source,Game game){
  landTypes.clear();
  Player controller=game.getPlayer(source.getControllerId());
  if (controller != null) {
    Set<String> choiceSet=new LinkedHashSet<>();
    choiceSet.add(""String_Node_Str"");
    choiceSet.add(""String_Node_Str"");
    ChoiceImpl choice=new ChoiceImpl(true);
    choice.setChoices(choiceSet);
    choice.setMessage(""String_Node_Str"");
    controller.choose(outcome,choice,game);
    landTypes.add(choice.getChoice());
  }
 else {
    this.discard();
  }
  super.init(source,game);
}","@Override public void init(Ability source,Game game){
  landTypes.clear();
  Player controller=game.getPlayer(source.getControllerId());
  if (controller != null) {
    Set<String> choiceSet=new LinkedHashSet<>();
    choiceSet.add(""String_Node_Str"");
    choiceSet.add(""String_Node_Str"");
    ChoiceImpl choice=new ChoiceImpl(true);
    choice.setChoices(choiceSet);
    choice.setMessage(""String_Node_Str"");
    while (!controller.choose(outcome,choice,game)) {
      if (!controller.canRespond()) {
        return;
      }
    }
    landTypes.add(choice.getChoice());
  }
 else {
    this.discard();
  }
  super.init(source,game);
}",0.9328859060402684
158506,"public TundraKavuEffect copy(){
  return new TundraKavuEffect(this);
}","@Override public TundraKavuEffect copy(){
  return new TundraKavuEffect(this);
}",0.9333333333333332
158507,"@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  Permanent sourcePermanent=game.getPermanent(source.getSourceId());
  if (controller != null && sourcePermanent != null) {
    Choice abilityChoice=new ChoiceImpl(true);
    Set<String> abilityChoices=new HashSet<>(3);
    abilityChoice.setMessage(""String_Node_Str"");
    abilityChoices.add(""String_Node_Str"");
    abilityChoices.add(""String_Node_Str"");
    abilityChoices.add(""String_Node_Str"");
    abilityChoice.setChoices(abilityChoices);
    Ability ability=null;
switch (abilityChoice.getChoice()) {
case ""String_Node_Str"":
      ability=FirstStrikeAbility.getInstance();
    break;
case ""String_Node_Str"":
  ability=VigilanceAbility.getInstance();
break;
case ""String_Node_Str"":
ability=LifelinkAbility.getInstance();
break;
default :
break;
}
if (ability != null) {
GainAbilityControlledEffect effect=new GainAbilityControlledEffect(ability,Duration.EndOfTurn,new FilterControlledCreaturePermanent());
game.addEffect(effect,source);
game.informPlayers(new StringBuilder(sourcePermanent.getName()).append(""String_Node_Str"").append(controller.getLogName()).append(""String_Node_Str"").append(abilityChoice.getChoice().toLowerCase()).toString());
return true;
}
}
return false;
}","@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  Permanent sourcePermanent=game.getPermanent(source.getSourceId());
  if (controller != null && sourcePermanent != null) {
    Choice abilityChoice=new ChoiceImpl(true);
    Set<String> abilityChoices=new HashSet<>(3);
    abilityChoice.setMessage(""String_Node_Str"");
    abilityChoices.add(""String_Node_Str"");
    abilityChoices.add(""String_Node_Str"");
    abilityChoices.add(""String_Node_Str"");
    abilityChoice.setChoices(abilityChoices);
    while (!controller.choose(outcome,abilityChoice,game)) {
      if (!controller.canRespond()) {
        return false;
      }
    }
    Ability ability=null;
    if (abilityChoice.getChoice() != null) {
switch (abilityChoice.getChoice()) {
case ""String_Node_Str"":
        ability=FirstStrikeAbility.getInstance();
      break;
case ""String_Node_Str"":
    ability=VigilanceAbility.getInstance();
  break;
case ""String_Node_Str"":
ability=LifelinkAbility.getInstance();
break;
default :
break;
}
if (ability != null) {
GainAbilityControlledEffect effect=new GainAbilityControlledEffect(ability,Duration.EndOfTurn,new FilterControlledCreaturePermanent());
game.addEffect(effect,source);
game.informPlayers(sourcePermanent.getName() + ""String_Node_Str"" + controller.getLogName()+ ""String_Node_Str""+ abilityChoice.getChoice().toLowerCase());
return true;
}
}
}
return false;
}",0.8065693430656934
158508,"@Override public boolean apply(Game game,Ability source){
  UUID targetId=null;
  if (source != null && source.getTargets() != null) {
    for (    Target target : source.getTargets()) {
      if (target.getFilter() != null && target.getFilter().getMessage().equals(filterMessage)) {
        targetId=target.getFirstTarget();
      }
    }
    if (targetId != null) {
      FixedTarget fixedTarget=new FixedTarget(targetId);
      ContinuousEffect continuousEffect=new BecomesCreatureTargetEffect(new AwakenElementalToken(),false,true,Duration.Custom);
      continuousEffect.setTargetPointer(fixedTarget);
      game.addEffect(continuousEffect,source);
      Effect effect=new AddCountersTargetEffect(CounterType.P1P1.createInstance(awakenValue));
      effect.setTargetPointer(fixedTarget);
      return effect.apply(game,source);
    }
  }
 else {
    if (source == null) {
      logger.fatal(""String_Node_Str"");
    }
 else     if (source.getTargets() == null) {
      MageObject sourceObj=source.getSourceObject(game);
      if (sourceObj != null) {
        Class<? extends MageObject> sourceClass=sourceObj.getClass();
        if (sourceClass != null) {
          logger.fatal(""String_Node_Str"" + sourceClass.toString() + ""String_Node_Str"");
        }
      }
    }
  }
  return true;
}","@Override public boolean apply(Game game,Ability source){
  UUID targetId=null;
  if (source != null && source.getTargets() != null) {
    for (    Target target : source.getTargets()) {
      if (target.getFilter() != null && target.getFilter().getMessage().equals(filterMessage)) {
        targetId=target.getFirstTarget();
      }
    }
    if (targetId != null) {
      FixedTarget fixedTarget=new FixedTarget(targetId);
      ContinuousEffect continuousEffect=new BecomesCreatureTargetEffect(new AwakenElementalToken(),false,true,Duration.Custom);
      continuousEffect.setTargetPointer(fixedTarget);
      game.addEffect(continuousEffect,source);
      Effect effect=new AddCountersTargetEffect(CounterType.P1P1.createInstance(awakenValue));
      effect.setTargetPointer(fixedTarget);
      return effect.apply(game,source);
    }
  }
 else   if (source == null) {
    logger.fatal(""String_Node_Str"");
  }
 else   if (source.getTargets() == null) {
    MageObject sourceObj=source.getSourceObject(game);
    if (sourceObj != null) {
      Class<? extends MageObject> sourceClass=sourceObj.getClass();
      if (sourceClass != null) {
        logger.fatal(""String_Node_Str"" + sourceClass.toString() + ""String_Node_Str"");
      }
    }
  }
  return true;
}",0.9608457321848082
158509,"public AwakenAbility(final AwakenAbility ability){
  super(ability);
  this.awakenValue=ability.awakenValue;
}","public AwakenAbility(final AwakenAbility ability){
  super(ability);
  this.awakenValue=ability.awakenValue;
  this.rule=ability.rule;
}",0.8943089430894309
158510,"@Override public LostAuramancers copy(){
  return new LostAuramancers(this);
}","@Override public DiesTriggeredAbility copy(){
  return new LostAuramancersAbility(this);
}",0.7976190476190477
158511,"protected void act(Game game){
  if (actions == null || actions.size() == 0) {
    pass(game);
  }
 else {
    boolean usedStack=false;
    while (actions.peek() != null) {
      Ability ability=actions.poll();
      logger.info(new StringBuilder(""String_Node_Str"").append(game.getPlayer(playerId).getName()).append(""String_Node_Str"").append(ability.toString()).toString());
      if (ability.getTargets().size() > 0) {
        for (        Target target : ability.getTargets()) {
          for (          UUID id : target.getTargets()) {
            target.updateTarget(id,game);
          }
        }
        Player player=game.getPlayer(ability.getFirstTarget());
        if (player != null) {
          logger.info(""String_Node_Str"" + player.getName());
        }
      }
      this.activateAbility((ActivatedAbility)ability,game);
      if (ability.isUsesStack()) {
        usedStack=true;
      }
      if (!suggested.isEmpty() && !(ability instanceof PassAbility)) {
        Iterator<String> it=suggested.iterator();
        while (it.hasNext()) {
          Card card=game.getCard(ability.getSourceId());
          String action=it.next();
          logger.info(""String_Node_Str"" + action + ""String_Node_Str""+ card);
          if (action.equals(card.getName())) {
            logger.info(""String_Node_Str"" + action);
            it.remove();
          }
        }
      }
    }
    if (usedStack) {
      pass(game);
    }
  }
}","protected void act(Game game){
  if (actions == null || actions.isEmpty()) {
    pass(game);
  }
 else {
    boolean usedStack=false;
    while (actions.peek() != null) {
      Ability ability=actions.poll();
      logger.info(new StringBuilder(""String_Node_Str"").append(game.getPlayer(playerId).getName()).append(""String_Node_Str"").append(ability.toString()).toString());
      if (ability.getTargets().size() > 0) {
        for (        Target target : ability.getTargets()) {
          for (          UUID id : target.getTargets()) {
            target.updateTarget(id,game);
            if (!target.isNotTarget()) {
              game.addSimultaneousEvent(GameEvent.getEvent(GameEvent.EventType.TARGETED,id,ability.getSourceId(),ability.getControllerId()));
            }
          }
        }
        Player player=game.getPlayer(ability.getFirstTarget());
        if (player != null) {
          logger.info(""String_Node_Str"" + player.getName());
        }
      }
      this.activateAbility((ActivatedAbility)ability,game);
      if (ability.isUsesStack()) {
        usedStack=true;
      }
      if (!suggested.isEmpty() && !(ability instanceof PassAbility)) {
        Iterator<String> it=suggested.iterator();
        while (it.hasNext()) {
          Card card=game.getCard(ability.getSourceId());
          String action=it.next();
          logger.info(""String_Node_Str"" + action + ""String_Node_Str""+ card);
          if (action.equals(card.getName())) {
            logger.info(""String_Node_Str"" + action);
            it.remove();
          }
        }
      }
    }
    if (usedStack) {
      pass(game);
    }
  }
}",0.929200652528548
158512,"@Override public boolean applies(GameEvent event,Ability source,Game game){
  Permanent sourcePermanent=(Permanent)source.getSourceObjectIfItStillExists(game);
  if (sourcePermanent == null || !sourcePermanent.getControllerId().equals(source.getControllerId())) {
    discard();
    return false;
  }
switch (event.getType()) {
case ZONE_CHANGE:
    if (event.getTargetId().equals(source.getSourceId())) {
      ZoneChangeEvent zEvent=(ZoneChangeEvent)event;
      if (zEvent.getFromZone() == Zone.BATTLEFIELD) {
        discard();
        return false;
      }
    }
  break;
case UNTAP:
if (game.getTurn().getStepType() == PhaseStep.UNTAP && event.getTargetId().equals(targetPointer.getFirst(game,source))) {
  Permanent targetCreature=game.getPermanent(targetPointer.getFirst(game,source));
  if (targetCreature != null) {
    return targetCreature.getControllerId().equals(game.getActivePlayerId());
  }
 else {
    discard();
    return false;
  }
}
break;
case LOST_CONTROL:
if (event.getTargetId().equals(source.getSourceId())) {
discard();
return false;
}
break;
}
return false;
}","@Override public boolean applies(GameEvent event,Ability source,Game game){
  MageObject sourceObject=source.getSourceObjectIfItStillExists(game);
  if (!(sourceObject instanceof Permanent) || !((Permanent)sourceObject).getControllerId().equals(source.getControllerId())) {
    discard();
    return false;
  }
switch (event.getType()) {
case ZONE_CHANGE:
    if (event.getTargetId().equals(source.getSourceId())) {
      ZoneChangeEvent zEvent=(ZoneChangeEvent)event;
      if (zEvent.getFromZone() == Zone.BATTLEFIELD) {
        discard();
        return false;
      }
    }
  break;
case UNTAP:
if (game.getTurn().getStepType() == PhaseStep.UNTAP && event.getTargetId().equals(targetPointer.getFirst(game,source))) {
  Permanent targetCreature=game.getPermanent(targetPointer.getFirst(game,source));
  if (targetCreature != null) {
    return targetCreature.getControllerId().equals(game.getActivePlayerId());
  }
 else {
    discard();
    return false;
  }
}
break;
case LOST_CONTROL:
if (event.getTargetId().equals(source.getSourceId())) {
discard();
return false;
}
break;
}
return false;
}",0.929551692589204
158513,"@Override public MageObject getSourceObjectIfItStillExists(Game game){
  MageObject currentObject=game.getObject(getSourceId());
  if (currentObject != null) {
    if (sourceObject == null) {
      setSourceObject(currentObject,game);
    }
    MageObjectReference mor=new MageObjectReference(currentObject,game);
    if (mor.getZoneChangeCounter() == getSourceObjectZoneChangeCounter()) {
      return sourceObject;
    }
  }
  return null;
}","@Override public MageObject getSourceObjectIfItStillExists(Game game){
  MageObject currentObject=game.getObject(getSourceId());
  if (currentObject != null) {
    if (sourceObject == null) {
      setSourceObject(currentObject,game);
    }
    MageObjectReference mor=new MageObjectReference(currentObject,game);
    if (mor.getZoneChangeCounter() == getSourceObjectZoneChangeCounter()) {
      return currentObject;
    }
  }
  return null;
}",0.9853438556933484
158514,"@Override public boolean checkTrigger(GameEvent event,Game game){
  Permanent attackingCreature=game.getPermanent(event.getTargetId());
  if (attackingCreature != null && attackingCreature.hasSubtype(""String_Node_Str"")) {
    for (    Effect effect : getEffects()) {
      effect.setTargetPointer(new FixedTarget(event.getTargetId()));
    }
    return true;
  }
  return false;
}","@Override public boolean checkTrigger(GameEvent event,Game game){
  Permanent sourcePermanent=game.getPermanent(getSourceId());
  if (sourcePermanent.isAttacking()) {
    for (    CombatGroup combatGroup : game.getCombat().getGroups()) {
      if (combatGroup.getBlockers().isEmpty() && combatGroup.getAttackers().contains(getSourceId())) {
        return true;
      }
    }
  }
  return false;
}",0.3912483912483912
158515,"@Override public boolean checkEventType(GameEvent event,Game game){
  return event.getType().equals(EventType.UNBLOCKED_ATTACKER);
}","@Override public boolean checkEventType(GameEvent event,Game game){
  return event.getType().equals(EventType.DECLARED_BLOCKERS);
}",0.9201520912547528
158516,"@Override public boolean apply(Game game,Ability source){
  Player newOwner=null;
  int lowLife=Integer.MIN_VALUE;
  boolean tie=false;
  for (  UUID playerID : game.getPlayerList()) {
    Player player=game.getPlayer(playerID);
    if (player.getLife() > lowLife) {
      lowLife=player.getLife();
      newOwner=player;
      tie=false;
    }
 else     if (player.getLife() == lowLife) {
      tie=true;
    }
  }
  if (!tie) {
    game.getPermanent(source.getId()).changeControllerId(newOwner.getId(),game);
  }
  return true;
}","@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller != null) {
    Permanent sourcePermanent=game.getPermanent(source.getSourceId());
    if (sourcePermanent != null) {
      Player newController=null;
      int lowLife=Integer.MIN_VALUE;
      boolean tie=false;
      for (      UUID playerID : game.getState().getPlayersInRange(source.getControllerId(),game)) {
        Player player=game.getPlayer(playerID);
        if (player != null) {
          if (player.getLife() > lowLife) {
            lowLife=player.getLife();
            newController=player;
            tie=false;
          }
 else           if (player.getLife() == lowLife) {
            tie=true;
          }
        }
      }
      if (!controller.equals(newController) && !tie && newController != null) {
        ContinuousEffect effect=new GainControlTargetEffect(Duration.Custom,newController.getId());
        effect.setTargetPointer(new FixedTarget(sourcePermanent,game));
        game.addEffect(effect,source);
      }
    }
    return true;
  }
  return false;
}",0.4879227053140096
158517,"/** 
 * Tron mana doesn't work with Oath of Nissa. (e.g. can't cast Chandra, Flamecaller with Urza's Tower, Power Plant, and Mine.)
 */
@Test public void testOathOfNissa(){
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"");
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"");
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"");
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"");
  addCard(Zone.HAND,playerA,""String_Node_Str"");
  castSpell(1,PhaseStep.PRECOMBAT_MAIN,playerA,""String_Node_Str"");
  setStopAt(1,PhaseStep.BEGIN_COMBAT);
  execute();
  assertPermanentCount(playerA,""String_Node_Str"",1);
}","/** 
 * Tron mana doesn't work with Oath of Nissa. (e.g. can't cast Chandra, Flamecaller with Urza's Tower, Power Plant, and Mine.) AI don't get the Planeswalker as playable card (probably because of the as thought effect)
 */
@Test public void testOathOfNissa(){
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"");
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"");
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"");
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"");
  addCard(Zone.HAND,playerA,""String_Node_Str"");
  castSpell(1,PhaseStep.PRECOMBAT_MAIN,playerA,""String_Node_Str"");
  setStopAt(1,PhaseStep.BEGIN_COMBAT);
  execute();
  assertPermanentCount(playerA,""String_Node_Str"",1);
}",0.931008339651251
158518,ManaCosts getCastSourceIdManaCosts();,ManaCosts<ManaCost> getCastSourceIdManaCosts();,0.8809523809523809
158519,"/** 
 * If the next spell cast has the set sourceId, the spell will be cast without mana (null) or the mana set to manaCosts instead of its normal mana costs.
 * @param sourceId the source that can be cast without mana
 * @param manaCosts alternate ManaCost, null if it can be cast without manacost
 * @param costs alternate other costs you need to pay
 */
void setCastSourceIdWithAlternateMana(UUID sourceId,ManaCosts<ManaCost> manaCosts,mage.abilities.costs.Costs costs);","/** 
 * If the next spell cast has the set sourceId, the spell will be cast without mana (null) or the mana set to manaCosts instead of its normal mana costs.
 * @param sourceId the source that can be cast without mana
 * @param manaCosts alternate ManaCost, null if it can be cast without manacost
 * @param costs alternate other costs you need to pay
 */
void setCastSourceIdWithAlternateMana(UUID sourceId,ManaCosts<ManaCost> manaCosts,Costs<Cost> costs);",0.9602577873254564
158520,"@Override public boolean putCardsOnBottomOfLibrary(Cards cards,Game game,Ability source,boolean anyOrder){
  if (cards.size() != 0) {
    if (!anyOrder) {
      for (      UUID objectId : cards) {
        moveObjectToLibrary(objectId,source == null ? null : source.getSourceId(),game,false,false);
      }
    }
 else {
      TargetCard target=new TargetCard(Zone.ALL,new FilterCard(""String_Node_Str""));
      target.setRequired(true);
      while (isInGame() && cards.size() > 1) {
        this.choose(Outcome.Neutral,cards,target,game);
        UUID targetObjectId=target.getFirstTarget();
        cards.remove(targetObjectId);
        moveObjectToLibrary(targetObjectId,source == null ? null : source.getSourceId(),game,false,false);
        target.clearChosen();
      }
      if (cards.size() == 1) {
        moveObjectToLibrary(cards.iterator().next(),source == null ? null : source.getSourceId(),game,false,false);
      }
    }
  }
  return true;
}","@Override public boolean putCardsOnBottomOfLibrary(Cards cards,Game game,Ability source,boolean anyOrder){
  if (!cards.isEmpty()) {
    if (!anyOrder) {
      for (      UUID objectId : cards) {
        moveObjectToLibrary(objectId,source == null ? null : source.getSourceId(),game,false,false);
      }
    }
 else {
      TargetCard target=new TargetCard(Zone.ALL,new FilterCard(""String_Node_Str""));
      target.setRequired(true);
      while (isInGame() && cards.size() > 1) {
        this.choose(Outcome.Neutral,cards,target,game);
        UUID targetObjectId=target.getFirstTarget();
        cards.remove(targetObjectId);
        moveObjectToLibrary(targetObjectId,source == null ? null : source.getSourceId(),game,false,false);
        target.clearChosen();
      }
      if (cards.size() == 1) {
        moveObjectToLibrary(cards.iterator().next(),source == null ? null : source.getSourceId(),game,false,false);
      }
    }
  }
  return true;
}",0.9837781266352696
158521,"@Override public void setCastSourceIdWithAlternateMana(UUID sourceId,ManaCosts manaCosts,mage.abilities.costs.Costs costs){
  castSourceIdWithAlternateMana=sourceId;
  castSourceIdManaCosts=manaCosts;
  castSourceIdCosts=costs;
}","@Override public void setCastSourceIdWithAlternateMana(UUID sourceId,ManaCosts<ManaCost> manaCosts,Costs<Cost> costs){
  castSourceIdWithAlternateMana=sourceId;
  castSourceIdManaCosts=manaCosts;
  castSourceIdCosts=costs;
}",0.8962472406181016
158522,"/** 
 * @param ability
 * @param available if null, it won't be checked if enough mana is available
 * @param sourceObject
 * @param game
 * @return
 */
protected boolean canPlay(ActivatedAbility ability,ManaOptions available,MageObject sourceObject,Game game){
  if (!(ability instanceof ManaAbility)) {
    ActivatedAbility copy=ability.copy();
    copy.setCheckPlayableMode();
    if (!copy.canActivate(playerId,game)) {
      return false;
    }
    game.getContinuousEffects().costModification(copy,game);
    Card card=game.getCard(ability.getSourceId());
    if (card != null) {
      for (      Ability ability0 : card.getAbilities()) {
        if (ability0 instanceof AdjustingSourceCosts) {
          if (!(ability0 instanceof ConvokeAbility)) {
            ((AdjustingSourceCosts)ability0).adjustCosts(copy,game);
          }
        }
      }
    }
    boolean canBeCastRegularly=true;
    if (copy instanceof SpellAbility && copy.getManaCosts().isEmpty() && copy.getCosts().isEmpty()) {
      canBeCastRegularly=false;
    }
    if (canBeCastRegularly) {
      ManaOptions abilityOptions=copy.getManaCostsToPay().getOptions();
      if (abilityOptions.isEmpty()) {
        return true;
      }
 else {
        if (available == null) {
          return true;
        }
        for (        Mana mana : abilityOptions) {
          for (          Mana avail : available) {
            if (mana.enough(avail)) {
              return true;
            }
          }
        }
      }
    }
    for (    Ability objectAbility : sourceObject.getAbilities()) {
      if (objectAbility instanceof AlternativeCostSourceAbility) {
        if (objectAbility.getCosts().canPay(ability,ability.getSourceId(),playerId,game)) {
          return true;
        }
      }
    }
    if (canPlayCardByAlternateCost(card,available,ability,game)) {
      return true;
    }
  }
  return false;
}","/** 
 * @param ability
 * @param available if null, it won't be checked if enough mana is available
 * @param sourceObject
 * @param game
 * @return
 */
protected boolean canPlay(ActivatedAbility ability,ManaOptions available,MageObject sourceObject,Game game){
  if (!(ability instanceof ManaAbility)) {
    ActivatedAbility copy=ability.copy();
    copy.setCheckPlayableMode();
    if (!copy.canActivate(playerId,game)) {
      return false;
    }
    game.getContinuousEffects().costModification(copy,game);
    Card card=game.getCard(ability.getSourceId());
    if (card != null) {
      for (      Ability ability0 : card.getAbilities()) {
        if (ability0 instanceof AdjustingSourceCosts) {
          if (!(ability0 instanceof ConvokeAbility)) {
            ((AdjustingSourceCosts)ability0).adjustCosts(copy,game);
          }
        }
      }
    }
    boolean canBeCastRegularly=true;
    if (copy instanceof SpellAbility && copy.getManaCosts().isEmpty() && copy.getCosts().isEmpty()) {
      canBeCastRegularly=false;
    }
    if (canBeCastRegularly) {
      ManaOptions abilityOptions=copy.getManaCostsToPay().getOptions();
      if (abilityOptions.isEmpty()) {
        return true;
      }
 else {
        if (available == null) {
          return true;
        }
        boolean spendAnyMana=game.getContinuousEffects().asThough(ability.getSourceId(),AsThoughEffectType.SPEND_OTHER_MANA,ability,ability.getControllerId(),game);
        for (        Mana mana : abilityOptions) {
          for (          Mana avail : available) {
            if (spendAnyMana && mana.count() <= avail.count()) {
              return true;
            }
            if (mana.enough(avail)) {
              return true;
            }
          }
        }
      }
    }
    for (    Ability objectAbility : sourceObject.getAbilities()) {
      if (objectAbility instanceof AlternativeCostSourceAbility) {
        if (objectAbility.getCosts().canPay(ability,ability.getSourceId(),playerId,game)) {
          return true;
        }
      }
    }
    if (canPlayCardByAlternateCost(card,available,ability,game)) {
      return true;
    }
  }
  return false;
}",0.9265033407572384
158523,"public void record(Table table){
  TableProto proto=table.toProto();
  TableRecordRepository.instance.add(new TableRecord(proto,proto.getEndTimeMs()));
  UserManager.getInstance().updateUserHistory();
}","@Override public void record(Table table){
  TableProto proto=table.toProto();
  TableRecordRepository.instance.add(new TableRecord(proto,proto.getEndTimeMs()));
  UserManager.getInstance().updateUserHistory();
}",0.9758454106280192
158524,"@Override public boolean applies(Permanent permanent,Ability source,Game game){
  if (game.getStep().getType() == PhaseStep.UNTAP) {
    if (game.getTurnNum() != turn) {
      turn=game.getTurnNum();
      applies=false;
      Permanent storageMatrix=game.getPermanent(source.getSourceId());
      if (storageMatrix != null && !storageMatrix.isTapped()) {
        Choice choiceImpl=new ChoiceImpl(true);
        choiceImpl.setMessage(""String_Node_Str"");
        choiceImpl.setChoices(choice);
        Player player=game.getPlayer(game.getActivePlayerId());
        if (player != null) {
          while (!player.choose(outcome,choiceImpl,game)) {
            if (player.canRespond()) {
              return false;
            }
          }
          String choosenType=choiceImpl.getChoice();
          game.informPlayers(storageMatrix.getLogName() + ""String_Node_Str"" + player.getLogName()+ ""String_Node_Str""+ choosenType);
          if (choosenType.equals(CardType.ARTIFACT.toString())) {
            type=CardType.ARTIFACT;
          }
 else           if (choosenType.equals(CardType.LAND.toString())) {
            type=CardType.LAND;
          }
 else {
            type=CardType.CREATURE;
          }
          applies=true;
        }
      }
    }
    if (applies) {
      return !permanent.getCardType().contains(type);
    }
  }
  return false;
}","@Override public boolean applies(Permanent permanent,Ability source,Game game){
  if (game.getStep().getType() == PhaseStep.UNTAP) {
    if (game.getTurnNum() != turn) {
      turn=game.getTurnNum();
      applies=false;
      Permanent storageMatrix=game.getPermanent(source.getSourceId());
      if (storageMatrix != null && !storageMatrix.isTapped()) {
        Choice choiceImpl=new ChoiceImpl(true);
        choiceImpl.setMessage(""String_Node_Str"");
        choiceImpl.setChoices(choice);
        Player player=game.getPlayer(game.getActivePlayerId());
        if (player != null) {
          while (!player.choose(outcome,choiceImpl,game)) {
            if (player.canRespond()) {
              return false;
            }
          }
          String choosenType=choiceImpl.getChoice();
          if (choosenType != null) {
            game.informPlayers(storageMatrix.getLogName() + ""String_Node_Str"" + player.getLogName()+ ""String_Node_Str""+ choosenType);
            if (choosenType.equals(CardType.ARTIFACT.toString())) {
              type=CardType.ARTIFACT;
            }
 else             if (choosenType.equals(CardType.LAND.toString())) {
              type=CardType.LAND;
            }
 else {
              type=CardType.CREATURE;
            }
            applies=true;
          }
        }
      }
    }
    if (applies) {
      return !permanent.getCardType().contains(type);
    }
  }
  return false;
}",0.9650953580424612
158525,"@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  MageObject sourceObject=game.getObject(source.getSourceId());
  if (controller == null || sourceObject == null) {
    return false;
  }
  TargetCardInLibrary target=new TargetCardInLibrary(0,2,new FilterBasicLandCard());
  if (controller.searchLibrary(target,game)) {
    if (target.getTargets().size() > 0) {
      Cards revealed=new CardsImpl();
      for (      UUID cardId : target.getTargets()) {
        Card card=controller.getLibrary().getCard(cardId,game);
        revealed.add(card);
      }
      controller.revealCards(sourceObject.getIdName(),revealed,game);
      if (target.getTargets().size() > 0) {
        TargetCard target2=new TargetCard(Zone.LIBRARY,filter);
        controller.choose(Outcome.Benefit,revealed,target2,game);
        Card card=revealed.get(target2.getFirstTarget(),game);
        if (card != null) {
          controller.moveCards(card,Zone.HAND,source,game);
          revealed.remove(card);
        }
        card=revealed.getCards(game).iterator().next();
        if (card != null) {
          controller.moveCards(card,Zone.GRAVEYARD,source,game);
        }
      }
 else       if (target.getTargets().size() == 1) {
        Card card=revealed.getCards(game).iterator().next();
        if (card != null) {
          controller.moveCards(card,Zone.HAND,source,game);
        }
      }
    }
    controller.shuffleLibrary(source,game);
    return true;
  }
  controller.shuffleLibrary(source,game);
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  MageObject sourceObject=game.getObject(source.getSourceId());
  if (controller == null || sourceObject == null) {
    return false;
  }
  TargetCardInLibrary target=new TargetCardInLibrary(0,2,new FilterBasicLandCard());
  if (controller.searchLibrary(target,game)) {
    if (target.getTargets().size() > 0) {
      Cards revealed=new CardsImpl();
      for (      UUID cardId : target.getTargets()) {
        Card card=controller.getLibrary().getCard(cardId,game);
        revealed.add(card);
      }
      controller.revealCards(sourceObject.getIdName(),revealed,game);
      if (target.getTargets().size() > 0) {
        TargetCard target2=new TargetCard(Zone.LIBRARY,filter);
        controller.choose(Outcome.Benefit,revealed,target2,game);
        Card card=revealed.get(target2.getFirstTarget(),game);
        if (card != null) {
          controller.moveCards(card,Zone.HAND,source,game);
          revealed.remove(card);
        }
        if (!revealed.isEmpty()) {
          card=revealed.getCards(game).iterator().next();
          if (card != null) {
            controller.moveCards(card,Zone.GRAVEYARD,source,game);
          }
        }
      }
 else       if (target.getTargets().size() == 1 && !revealed.isEmpty()) {
        Card card=revealed.getCards(game).iterator().next();
        if (card != null) {
          controller.moveCards(card,Zone.HAND,source,game);
        }
      }
    }
    controller.shuffleLibrary(source,game);
    return true;
  }
  controller.shuffleLibrary(source,game);
  return false;
}",0.973374613003096
158526,"@Override public boolean checkTrigger(GameEvent event,Game game){
  if (((ZoneChangeEvent)event).isDiesEvent()) {
    ZoneChangeEvent zEvent=(ZoneChangeEvent)event;
    boolean triggered=false;
    if (zEvent.getTarget().getAttachments().contains(this.getSourceId())) {
      triggered=true;
    }
 else {
      Permanent attachment=game.getPermanentOrLKIBattlefield(getSourceId());
      if (attachment != null && zEvent.getTargetId() != null && attachment.getAttachedTo() != null && zEvent.getTargetId().equals(attachment.getAttachedTo())) {
        Permanent attachedTo=game.getPermanentOrLKIBattlefield(attachment.getAttachedTo());
        if (attachedTo != null && attachment.getAttachedToZoneChangeCounter() == attachedTo.getZoneChangeCounter(game)) {
          triggered=true;
        }
      }
    }
    if (triggered) {
      for (      Effect effect : getEffects()) {
        effect.setValue(""String_Node_Str"",zEvent.getTarget());
        if (setTargetPointer.equals(SetTargetPointer.ATTACHED_TO_CONTROLLER)) {
          Permanent attachment=game.getPermanentOrLKIBattlefield(getSourceId());
          if (attachment != null && attachment.getAttachedTo() != null) {
            Permanent attachedTo=(Permanent)game.getLastKnownInformation(attachment.getAttachedTo(),Zone.BATTLEFIELD,attachment.getAttachedToZoneChangeCounter());
            if (attachedTo != null) {
              effect.setTargetPointer(new FixedTarget(attachedTo.getControllerId()));
            }
          }
        }
      }
      return true;
    }
  }
  return false;
}","@Override public boolean checkTrigger(GameEvent event,Game game){
  if (((ZoneChangeEvent)event).isDiesEvent()) {
    ZoneChangeEvent zEvent=(ZoneChangeEvent)event;
    boolean triggered=false;
    if (zEvent.getTarget().getAttachments() != null && zEvent.getTarget().getAttachments().contains(this.getSourceId())) {
      triggered=true;
    }
 else {
      Permanent attachment=game.getPermanentOrLKIBattlefield(getSourceId());
      if (attachment != null && zEvent.getTargetId() != null && attachment.getAttachedTo() != null && zEvent.getTargetId().equals(attachment.getAttachedTo())) {
        Permanent attachedTo=game.getPermanentOrLKIBattlefield(attachment.getAttachedTo());
        if (attachedTo != null && attachment.getAttachedToZoneChangeCounter() == attachedTo.getZoneChangeCounter(game)) {
          triggered=true;
        }
      }
    }
    if (triggered) {
      for (      Effect effect : getEffects()) {
        effect.setValue(""String_Node_Str"",zEvent.getTarget());
        if (setTargetPointer.equals(SetTargetPointer.ATTACHED_TO_CONTROLLER)) {
          Permanent attachment=game.getPermanentOrLKIBattlefield(getSourceId());
          if (attachment != null && attachment.getAttachedTo() != null) {
            Permanent attachedTo=(Permanent)game.getLastKnownInformation(attachment.getAttachedTo(),Zone.BATTLEFIELD,attachment.getAttachedToZoneChangeCounter());
            if (attachedTo != null) {
              effect.setTargetPointer(new FixedTarget(attachedTo.getControllerId()));
            }
          }
        }
      }
      return true;
    }
  }
  return false;
}",0.985093561687282
158527,"@Override public boolean apply(Game game,Ability source){
  boolean conditionApplies=false;
  Player controller=game.getPlayer(source.getControllerId());
  if (controller != null && controller.getLibrary().size() > 0) {
switch (this.type) {
case CREATURE:
      conditionApplies|=controller.getLibrary().getFromTop(game).getCardType().contains(CardType.CREATURE);
    break;
case LAND:
  conditionApplies|=controller.getLibrary().getFromTop(game).getCardType().contains(CardType.LAND);
break;
case SORCERY:
conditionApplies|=controller.getLibrary().getFromTop(game).getCardType().contains(CardType.SORCERY);
break;
case INSTANT:
conditionApplies|=controller.getLibrary().getFromTop(game).getCardType().contains(CardType.INSTANT);
break;
}
}
return conditionApplies;
}","@Override public boolean apply(Game game,Ability source){
  boolean conditionApplies=false;
  Player controller=game.getPlayer(source.getControllerId());
  if (controller != null && controller.getLibrary().size() > 0) {
    Card card=controller.getLibrary().getFromTop(game);
    if (card != null) {
switch (this.type) {
case CREATURE:
        conditionApplies|=card.getCardType().contains(CardType.CREATURE);
      break;
case LAND:
    conditionApplies|=card.getCardType().contains(CardType.LAND);
  break;
case SORCERY:
conditionApplies|=card.getCardType().contains(CardType.SORCERY);
break;
case INSTANT:
conditionApplies|=card.getCardType().contains(CardType.INSTANT);
break;
}
}
}
return conditionApplies;
}",0.8256756756756757
158528,"@Override public Set<Card> getCards(Game game){
  Set<Card> cards=new LinkedHashSet<>();
  for (  UUID cardId : this) {
    Card card=game.getCard(cardId);
    if (card != null) {
      cards.add(card);
    }
  }
  return cards;
}","@Override public Set<Card> getCards(Game game){
  Set<Card> cards=new LinkedHashSet<>();
  for (Iterator<UUID> it=this.iterator(); it.hasNext(); ) {
    UUID cardId=it.next();
    Card card=game.getCard(cardId);
    if (card != null) {
      cards.add(card);
    }
  }
  return cards;
}",0.8449612403100775
158529,"/** 
 * Damages attacking creatures by a creature that blocked several ones Damages only attackers as blocker was damage in either  {@link #singleBlockerDamage} or {@link #multiBlockerDamage}. Handles abilities like ""{this} an block any number of creatures."".
 * @param first
 * @param game
 */
private void multiAttackerDamage(boolean first,Game game){
  Permanent blocker=game.getPermanent(blockers.get(0));
  if (blocker == null) {
    return;
  }
  Player player=game.getPlayer(blocker.getControllerId());
  int damage=getDamageValueFromPermanent(blocker,game);
  if (canDamage(blocker,first)) {
    Map<UUID,Integer> assigned=new HashMap<>();
    for (    UUID attackerId : attackerOrder) {
      Permanent attacker=game.getPermanent(attackerId);
      int lethalDamage;
      if (blocker.getAbilities().containsKey(DeathtouchAbility.getInstance().getId())) {
        lethalDamage=1;
      }
 else {
        lethalDamage=attacker.getToughness().getValue() - attacker.getDamage();
      }
      if (lethalDamage >= damage) {
        assigned.put(attackerId,damage);
        break;
      }
      int damageAssigned=player.getAmount(lethalDamage,damage,""String_Node_Str"" + attacker.getName(),game);
      assigned.put(attackerId,damageAssigned);
      damage-=damageAssigned;
    }
    for (    Map.Entry<UUID,Integer> entry : assigned.entrySet()) {
      Permanent attacker=game.getPermanent(entry.getKey());
      attacker.markDamage(entry.getValue(),blocker.getId(),game,true,true);
    }
  }
}","/** 
 * Damages attacking creatures by a creature that blocked several ones Damages only attackers as blocker was damage in either  {@link #singleBlockerDamage} or {@link #multiBlockerDamage}. Handles abilities like ""{this} an block any number of creatures."".
 * @param first
 * @param game
 */
private void multiAttackerDamage(boolean first,Game game){
  Permanent blocker=game.getPermanent(blockers.get(0));
  if (blocker == null) {
    return;
  }
  Player player=game.getPlayer(blocker.getControllerId());
  int damage=getDamageValueFromPermanent(blocker,game);
  if (canDamage(blocker,first)) {
    Map<UUID,Integer> assigned=new HashMap<>();
    for (    UUID attackerId : attackerOrder) {
      Permanent attacker=game.getPermanent(attackerId);
      if (attacker != null) {
        int lethalDamage;
        if (blocker.getAbilities().containsKey(DeathtouchAbility.getInstance().getId())) {
          lethalDamage=1;
        }
 else {
          lethalDamage=attacker.getToughness().getValue() - attacker.getDamage();
        }
        if (lethalDamage >= damage) {
          assigned.put(attackerId,damage);
          break;
        }
        int damageAssigned=player.getAmount(lethalDamage,damage,""String_Node_Str"" + attacker.getName(),game);
        assigned.put(attackerId,damageAssigned);
        damage-=damageAssigned;
      }
    }
    for (    Map.Entry<UUID,Integer> entry : assigned.entrySet()) {
      Permanent attacker=game.getPermanent(entry.getKey());
      attacker.markDamage(entry.getValue(),blocker.getId(),game,true,true);
    }
  }
}",0.9790986283474852
158530,"@Override public boolean apply(Game game,Ability source){
  Spell spell=game.getStack().getSpell(targetPointer.getFirst(game,source));
  if (spell == null) {
    spell=(Spell)game.getLastKnownInformation(targetPointer.getFirst(game,source),Zone.STACK);
  }
  Player controller=game.getPlayer(source.getControllerId());
  if (spell != null && controller != null) {
    Target usedTarget=null;
    setUsedTarget:     for (    Ability ability : spell.getSpellAbilities()) {
      for (      Mode mode : ability.getModes().getSelectedModes()) {
        for (        Target target : mode.getTargets()) {
          if (!target.isNotTarget() && target.getFirstTarget().equals(source.getSourceId())) {
            usedTarget=target.copy();
            usedTarget.clearChosen();
            break setUsedTarget;
          }
        }
      }
    }
    if (usedTarget == null) {
      return false;
    }
    for (    Permanent creature : game.getState().getBattlefield().getAllActivePermanents(new FilterCreaturePermanent(),source.getControllerId(),game)) {
      if (!creature.getId().equals(source.getSourceId()) && usedTarget.canTarget(source.getControllerId(),creature.getId(),source,game)) {
        Spell copy=spell.copySpell(source.getControllerId());
        setTarget:         for (        Mode mode : spell.getSpellAbility().getModes().getSelectedModes()) {
          for (          Target target : mode.getTargets()) {
            if (target.getClass().equals(usedTarget.getClass())) {
              target.clearChosen();
              if (target.getMessage().equals(usedTarget.getMessage())) {
                target.add(creature.getId(),game);
                break setTarget;
              }
            }
          }
        }
        game.getStack().push(copy);
        String activateMessage=copy.getActivatedMessage(game);
        if (activateMessage.startsWith(""String_Node_Str"")) {
          activateMessage=activateMessage.substring(6);
        }
        if (!game.isSimulation()) {
          game.informPlayers(controller.getLogName() + activateMessage);
        }
      }
    }
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Spell spell=game.getStack().getSpell(targetPointer.getFirst(game,source));
  if (spell == null) {
    spell=(Spell)game.getLastKnownInformation(targetPointer.getFirst(game,source),Zone.STACK);
  }
  Player controller=game.getPlayer(source.getControllerId());
  if (spell != null && controller != null) {
    Target usedTarget=null;
    setUsedTarget:     for (    Ability ability : spell.getSpellAbilities()) {
      for (      Mode mode : ability.getModes().getSelectedModes()) {
        for (        Target target : mode.getTargets()) {
          if (!target.isNotTarget() && target.getFirstTarget().equals(source.getSourceId())) {
            usedTarget=target.copy();
            usedTarget.clearChosen();
            break setUsedTarget;
          }
        }
      }
    }
    if (usedTarget == null) {
      return false;
    }
    for (    Permanent creature : game.getState().getBattlefield().getAllActivePermanents(new FilterCreaturePermanent(),source.getControllerId(),game)) {
      if (!creature.getId().equals(source.getSourceId()) && usedTarget.canTarget(source.getControllerId(),creature.getId(),source,game)) {
        Spell copy=spell.copySpell(source.getControllerId());
        game.getStack().push(copy);
        setTarget:         for (        Mode mode : copy.getSpellAbility().getModes().getSelectedModes()) {
          for (          Target target : mode.getTargets()) {
            if (target.getClass().equals(usedTarget.getClass())) {
              target.clearChosen();
              if (target.getMessage().equals(usedTarget.getMessage())) {
                target.addTarget(creature.getId(),copy.getSpellAbility(),game,false);
                break setTarget;
              }
            }
          }
        }
        String activateMessage=copy.getActivatedMessage(game);
        if (activateMessage.startsWith(""String_Node_Str"")) {
          activateMessage=activateMessage.substring(6);
        }
        if (!game.isSimulation()) {
          game.informPlayers(controller.getLogName() + activateMessage);
        }
      }
    }
    return true;
  }
  return false;
}",0.9715882626921284
158531,"@Override public boolean checkTrigger(GameEvent event,Game game){
  Permanent permanent=game.getPermanent(event.getTargetId());
  if (permanent != null && permanent.getControllerId().equals(this.controllerId) && (permanent.getSubtype().contains(""String_Node_Str"") || permanent.getSubtype().contains(""String_Node_Str""))) {
    MageObject object=game.getObject(event.getSourceId());
    if (object != null && object instanceof Spell) {
      Card c=(Spell)object;
      if (c.getCardType().contains(CardType.INSTANT) || c.getCardType().contains(CardType.SORCERY)) {
        if (getTargets().size() == 0) {
          for (          Effect effect : getEffects()) {
            effect.setTargetPointer(new FixedTarget(event.getTargetId()));
          }
        }
        return true;
      }
    }
  }
  return false;
}","@Override public boolean checkTrigger(GameEvent event,Game game){
  Permanent permanent=game.getPermanent(event.getTargetId());
  if (permanent != null && permanent.getControllerId().equals(this.controllerId) && (permanent.getSubtype().contains(""String_Node_Str"") || permanent.getSubtype().contains(""String_Node_Str""))) {
    MageObject object=game.getObject(event.getSourceId());
    if (object != null && object instanceof Spell) {
      Card c=(Spell)object;
      if (c.getCardType().contains(CardType.INSTANT) || c.getCardType().contains(CardType.SORCERY)) {
        if (getTargets().isEmpty()) {
          for (          Effect effect : getEffects()) {
            effect.setTargetPointer(new FixedTarget(event.getTargetId()));
          }
        }
        return true;
      }
    }
  }
  return false;
}",0.98769987699877
158532,"@Override public boolean apply(Game game,Ability source){
  if (game.getBattlefield().contains(filterFlying,source.getControllerId(),1,game)) {
    game.addEffect(new GainAbilityControlledEffect(FlyingAbility.getInstance(),Duration.EndOfTurn),source);
  }
  if (game.getBattlefield().contains(filterFear,source.getControllerId(),1,game)) {
    game.addEffect(new GainAbilityControlledEffect(FearAbility.getInstance(),Duration.EndOfTurn),source);
  }
  if (game.getBattlefield().contains(filterFirstStrike,source.getControllerId(),1,game)) {
    game.addEffect(new GainAbilityControlledEffect(FirstStrikeAbility.getInstance(),Duration.EndOfTurn),source);
  }
  if (game.getBattlefield().contains(filterDoubleStrike,source.getControllerId(),1,game)) {
    game.addEffect(new GainAbilityControlledEffect(DoubleStrikeAbility.getInstance(),Duration.EndOfTurn),source);
  }
  for (  Permanent permanent : game.getBattlefield().getAllActivePermanents(filterLandwalk,source.getControllerId(),game)) {
    for (    Ability ability : permanent.getAbilities(game)) {
      if (ability instanceof LandwalkAbility) {
        game.addEffect(new GainAbilityControlledEffect(ability,Duration.EndOfTurn),source);
      }
    }
  }
  for (  Permanent permanent : game.getBattlefield().getAllActivePermanents(filterProtection,source.getControllerId(),game)) {
    for (    Ability ability : permanent.getAbilities(game)) {
      if (ability instanceof ProtectionAbility) {
        game.addEffect(new GainAbilityControlledEffect(ability,Duration.EndOfTurn),source);
      }
    }
  }
  if (game.getBattlefield().contains(filterTrample,source.getControllerId(),1,game)) {
    game.addEffect(new GainAbilityControlledEffect(TrampleAbility.getInstance(),Duration.EndOfTurn),source);
  }
  if (game.getBattlefield().contains(filterVigilance,source.getControllerId(),1,game)) {
    game.addEffect(new GainAbilityControlledEffect(VigilanceAbility.getInstance(),Duration.EndOfTurn),source);
  }
  return true;
}","@Override public boolean apply(Game game,Ability source){
  if (game.getBattlefield().contains(filterFlying,source.getControllerId(),1,game)) {
    game.addEffect(new GainAbilityControlledEffect(FlyingAbility.getInstance(),Duration.EndOfTurn,filterCreatures),source);
  }
  if (game.getBattlefield().contains(filterFear,source.getControllerId(),1,game)) {
    game.addEffect(new GainAbilityControlledEffect(FearAbility.getInstance(),Duration.EndOfTurn,filterCreatures),source);
  }
  if (game.getBattlefield().contains(filterFirstStrike,source.getControllerId(),1,game)) {
    game.addEffect(new GainAbilityControlledEffect(FirstStrikeAbility.getInstance(),Duration.EndOfTurn,filterCreatures),source);
  }
  if (game.getBattlefield().contains(filterDoubleStrike,source.getControllerId(),1,game)) {
    game.addEffect(new GainAbilityControlledEffect(DoubleStrikeAbility.getInstance(),Duration.EndOfTurn,filterCreatures),source);
  }
  for (  Permanent permanent : game.getBattlefield().getAllActivePermanents(filterLandwalk,source.getControllerId(),game)) {
    for (    Ability ability : permanent.getAbilities(game)) {
      if (ability instanceof LandwalkAbility) {
        game.addEffect(new GainAbilityControlledEffect(ability,Duration.EndOfTurn,filterCreatures),source);
      }
    }
  }
  for (  Permanent permanent : game.getBattlefield().getAllActivePermanents(filterProtection,source.getControllerId(),game)) {
    for (    Ability ability : permanent.getAbilities(game)) {
      if (ability instanceof ProtectionAbility) {
        game.addEffect(new GainAbilityControlledEffect(ability,Duration.EndOfTurn,filterCreatures),source);
      }
    }
  }
  if (game.getBattlefield().contains(filterTrample,source.getControllerId(),1,game)) {
    game.addEffect(new GainAbilityControlledEffect(TrampleAbility.getInstance(),Duration.EndOfTurn,filterCreatures),source);
  }
  if (game.getBattlefield().contains(filterVigilance,source.getControllerId(),1,game)) {
    game.addEffect(new GainAbilityControlledEffect(VigilanceAbility.getInstance(),Duration.EndOfTurn,filterCreatures),source);
  }
  return true;
}",0.96875
158533,"@Override public boolean apply(Game game,Ability source){
  if (game.getBattlefield().contains(filterFirstStrike,source.getControllerId(),1,game)) {
    game.addEffect(new GainAbilityControlledEffect(FirstStrikeAbility.getInstance(),Duration.EndOfTurn),source);
  }
  if (game.getBattlefield().contains(filterFlying,source.getControllerId(),1,game)) {
    game.addEffect(new GainAbilityControlledEffect(FlyingAbility.getInstance(),Duration.EndOfTurn),source);
  }
  if (game.getBattlefield().contains(filterDeathtouch,source.getControllerId(),1,game)) {
    game.addEffect(new GainAbilityControlledEffect(DeathtouchAbility.getInstance(),Duration.EndOfTurn),source);
  }
  if (game.getBattlefield().contains(filterDoubleStrike,source.getControllerId(),1,game)) {
    game.addEffect(new GainAbilityControlledEffect(DoubleStrikeAbility.getInstance(),Duration.EndOfTurn),source);
  }
  if (game.getBattlefield().contains(filterHaste,source.getControllerId(),1,game)) {
    game.addEffect(new GainAbilityControlledEffect(HasteAbility.getInstance(),Duration.EndOfTurn),source);
  }
  if (game.getBattlefield().contains(filterHexproof,source.getControllerId(),1,game)) {
    game.addEffect(new GainAbilityControlledEffect(HexproofAbility.getInstance(),Duration.EndOfTurn),source);
  }
  if (game.getBattlefield().contains(filterIndestructible,source.getControllerId(),1,game)) {
    game.addEffect(new GainAbilityControlledEffect(IndestructibleAbility.getInstance(),Duration.EndOfTurn),source);
  }
  if (game.getBattlefield().contains(filterLifelink,source.getControllerId(),1,game)) {
    game.addEffect(new GainAbilityControlledEffect(LifelinkAbility.getInstance(),Duration.EndOfTurn),source);
  }
  if (game.getBattlefield().contains(filterMenace,source.getControllerId(),1,game)) {
    game.addEffect(new GainAbilityControlledEffect(new MenaceAbility(),Duration.EndOfTurn),source);
  }
  if (game.getBattlefield().contains(filterReach,source.getControllerId(),1,game)) {
    game.addEffect(new GainAbilityControlledEffect(ReachAbility.getInstance(),Duration.EndOfTurn),source);
  }
  if (game.getBattlefield().contains(filterSkulk,source.getControllerId(),1,game)) {
    game.addEffect(new GainAbilityControlledEffect(new SkulkAbility(),Duration.EndOfTurn),source);
  }
  if (game.getBattlefield().contains(filterTrample,source.getControllerId(),1,game)) {
    game.addEffect(new GainAbilityControlledEffect(TrampleAbility.getInstance(),Duration.EndOfTurn),source);
  }
  if (game.getBattlefield().contains(filterVigilance,source.getControllerId(),1,game)) {
    game.addEffect(new GainAbilityControlledEffect(VigilanceAbility.getInstance(),Duration.EndOfTurn),source);
  }
  return true;
}","@Override public boolean apply(Game game,Ability source){
  if (game.getBattlefield().contains(filterFirstStrike,source.getControllerId(),1,game)) {
    game.addEffect(new GainAbilityControlledEffect(FirstStrikeAbility.getInstance(),Duration.EndOfTurn,filterCreatures),source);
  }
  if (game.getBattlefield().contains(filterFlying,source.getControllerId(),1,game)) {
    game.addEffect(new GainAbilityControlledEffect(FlyingAbility.getInstance(),Duration.EndOfTurn,filterCreatures),source);
  }
  if (game.getBattlefield().contains(filterDeathtouch,source.getControllerId(),1,game)) {
    game.addEffect(new GainAbilityControlledEffect(DeathtouchAbility.getInstance(),Duration.EndOfTurn,filterCreatures),source);
  }
  if (game.getBattlefield().contains(filterDoubleStrike,source.getControllerId(),1,game)) {
    game.addEffect(new GainAbilityControlledEffect(DoubleStrikeAbility.getInstance(),Duration.EndOfTurn,filterCreatures),source);
  }
  if (game.getBattlefield().contains(filterHaste,source.getControllerId(),1,game)) {
    game.addEffect(new GainAbilityControlledEffect(HasteAbility.getInstance(),Duration.EndOfTurn,filterCreatures),source);
  }
  if (game.getBattlefield().contains(filterHexproof,source.getControllerId(),1,game)) {
    game.addEffect(new GainAbilityControlledEffect(HexproofAbility.getInstance(),Duration.EndOfTurn,filterCreatures),source);
  }
  if (game.getBattlefield().contains(filterIndestructible,source.getControllerId(),1,game)) {
    game.addEffect(new GainAbilityControlledEffect(IndestructibleAbility.getInstance(),Duration.EndOfTurn,filterCreatures),source);
  }
  if (game.getBattlefield().contains(filterLifelink,source.getControllerId(),1,game)) {
    game.addEffect(new GainAbilityControlledEffect(LifelinkAbility.getInstance(),Duration.EndOfTurn,filterCreatures),source);
  }
  if (game.getBattlefield().contains(filterMenace,source.getControllerId(),1,game)) {
    game.addEffect(new GainAbilityControlledEffect(new MenaceAbility(),Duration.EndOfTurn,filterCreatures),source);
  }
  if (game.getBattlefield().contains(filterReach,source.getControllerId(),1,game)) {
    game.addEffect(new GainAbilityControlledEffect(ReachAbility.getInstance(),Duration.EndOfTurn,filterCreatures),source);
  }
  if (game.getBattlefield().contains(filterSkulk,source.getControllerId(),1,game)) {
    game.addEffect(new GainAbilityControlledEffect(new SkulkAbility(),Duration.EndOfTurn,filterCreatures),source);
  }
  if (game.getBattlefield().contains(filterTrample,source.getControllerId(),1,game)) {
    game.addEffect(new GainAbilityControlledEffect(TrampleAbility.getInstance(),Duration.EndOfTurn,filterCreatures),source);
  }
  if (game.getBattlefield().contains(filterVigilance,source.getControllerId(),1,game)) {
    game.addEffect(new GainAbilityControlledEffect(VigilanceAbility.getInstance(),Duration.EndOfTurn,filterCreatures),source);
  }
  return true;
}",0.9627507163323782
158534,"@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller != null) {
    return game.getStack().counter(targetPointer.getFirst(game,source),source.getSourceId(),game,Zone.BATTLEFIELD,false,ZoneDetail.NONE);
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller != null) {
    Spell targetSpell=game.getStack().getSpell(targetPointer.getFirst(game,source));
    if (targetSpell != null) {
      Set<CardType> cardTypes=new HashSet<>(targetSpell.getCardType());
      if (!cardTypes.isEmpty()) {
        if (cardTypes.contains(CardType.ARTIFACT) || cardTypes.contains(CardType.CREATURE)) {
          return game.getStack().counter(targetSpell.getId(),source.getSourceId(),game,Zone.BATTLEFIELD,false,ZoneDetail.NONE);
        }
 else {
          return game.getStack().counter(targetSpell.getId(),source.getSourceId(),game);
        }
      }
    }
  }
  return false;
}",0.5575642245480494
158535,"@java.lang.Override public boolean checkEventType(GameEvent event,Game game){
  return event instanceof DamageEvent;
}","@java.lang.Override public boolean checkEventType(GameEvent event,Game game){
  return event.getType() == GameEvent.EventType.DAMAGED_CREATURE || event.getType() == GameEvent.EventType.DAMAGED_PLANESWALKER || event.getType() == GameEvent.EventType.DAMAGED_PLAYER;
}",0.4960835509138381
158536,"@Override public boolean apply(Game game,Ability source){
  Spell spell=game.getStack().getSpell(targetPointer.getFirst(game,source));
  if (spell != null) {
    String chooseMessage=""String_Node_Str"";
    for (    UUID playerId : game.getState().getPlayersInRange(source.getControllerId(),game)) {
      if (!playerId.equals(spell.getControllerId())) {
        Player player=game.getPlayer(playerId);
        if (player.chooseUse(Outcome.Copy,chooseMessage,source,game)) {
          Spell copy=spell.copySpell(source.getControllerId());
          ;
          game.getStack().push(copy);
          copy.chooseNewTargets(game,playerId);
        }
      }
    }
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Spell spell=game.getStack().getSpell(targetPointer.getFirst(game,source));
  if (spell != null) {
    String chooseMessage=""String_Node_Str"";
    for (    UUID playerId : game.getState().getPlayersInRange(source.getControllerId(),game)) {
      if (!playerId.equals(spell.getControllerId())) {
        Player player=game.getPlayer(playerId);
        if (player.chooseUse(Outcome.Copy,chooseMessage,source,game)) {
          Spell copy=spell.copySpell(source.getControllerId());
          game.getStack().push(copy);
          copy.chooseNewTargets(game,playerId);
        }
      }
    }
    return true;
  }
  return false;
}",0.9913294797687862
158537,"public void update(UserData userData){
  this.groupId=userData.groupId;
  this.avatarId=userData.avatarId;
  this.showAbilityPickerForced=userData.showAbilityPickerForced;
  this.allowRequestShowHandCards=userData.allowRequestShowHandCards;
  this.userSkipPrioritySteps=userData.userSkipPrioritySteps;
  this.confirmEmptyManaPool=userData.confirmEmptyManaPool;
  this.flagName=userData.flagName;
  this.askMoveToGraveOrder=userData.askMoveToGraveOrder;
  this.manaPoolAutomatic=userData.manaPoolAutomatic;
  this.manaPoolAutomaticRestricted=userData.manaPoolAutomaticRestricted;
  this.passPriorityCast=userData.passPriorityCast;
  this.passPriorityActivation=userData.passPriorityActivation;
  this.autoOrderTrigger=userData.autoOrderTrigger;
  this.useFirstManaAbility=useFirstManaAbility;
}","public void update(UserData userData){
  this.groupId=userData.groupId;
  this.avatarId=userData.avatarId;
  this.showAbilityPickerForced=userData.showAbilityPickerForced;
  this.allowRequestShowHandCards=userData.allowRequestShowHandCards;
  this.userSkipPrioritySteps=userData.userSkipPrioritySteps;
  this.confirmEmptyManaPool=userData.confirmEmptyManaPool;
  this.flagName=userData.flagName;
  this.askMoveToGraveOrder=userData.askMoveToGraveOrder;
  this.manaPoolAutomatic=userData.manaPoolAutomatic;
  this.manaPoolAutomaticRestricted=userData.manaPoolAutomaticRestricted;
  this.passPriorityCast=userData.passPriorityCast;
  this.passPriorityActivation=userData.passPriorityActivation;
  this.autoOrderTrigger=userData.autoOrderTrigger;
  this.useFirstManaAbility=userData.useFirstManaAbility;
}",0.9943573667711598
158538,"@Override public UlvenwaldMysteries copy(){
  return new UlvenwaldMysteries(this);
}","@Override public UlvenwaldMysteriesTriggeredAbility copy(){
  return new UlvenwaldMysteriesTriggeredAbility(this);
}",0.84
158539,"@Override public FleetingMemories copy(){
  return new FleetingMemories(this);
}","@Override public FleetingMemoriesTriggeredAbility copy(){
  return new FleetingMemoriesTriggeredAbility(this);
}",0.8333333333333334
158540,"@Override public GrafMole copy(){
  return new GrafMole(this);
}","@Override public GrafMoleTriggeredAbility copy(){
  return new GrafMoleTriggeredAbility(this);
}",0.8
158541,"@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller != null) {
    if (controller.chooseUse(Outcome.BoostCreature,""String_Node_Str"",source,game)) {
      int costX=controller.announceXMana(0,Integer.MAX_VALUE,""String_Node_Str"",game,source);
      Cost cost=new GenericManaCost(costX);
      if (cost.pay(source,game,source.getSourceId(),source.getControllerId(),false,null)) {
        FilterCard filter=new FilterCard(""String_Node_Str"" + costX);
        filter.add(new SubtypePredicate(""String_Node_Str""));
        filter.add(new ConvertedManaCostPredicate(Filter.ComparisonType.Equal,costX));
        TargetCardInYourGraveyard target=new TargetCardInYourGraveyard(filter);
        if (controller.chooseTarget(outcome,target,source,game)) {
          Card card=game.getCard(target.getFirstTarget());
          if (card != null) {
            controller.moveCards(card,Zone.BATTLEFIELD,source,game);
          }
        }
      }
    }
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller != null) {
    if (controller.chooseUse(Outcome.BoostCreature,""String_Node_Str"",source,game)) {
      int costX=controller.announceXMana(0,Integer.MAX_VALUE,""String_Node_Str"",game,source);
      Cost cost=new GenericManaCost(costX);
      if (cost.pay(source,game,source.getSourceId(),source.getControllerId(),false,null)) {
        FilterCard filter=new FilterCard(""String_Node_Str"" + costX);
        filter.add(new SubtypePredicate(""String_Node_Str""));
        filter.add(new ConvertedManaCostPredicate(Filter.ComparisonType.Equal,costX));
        filter.add(new AnotherCardPredicate());
        TargetCardInYourGraveyard target=new TargetCardInYourGraveyard(filter);
        if (controller.chooseTarget(outcome,target,source,game)) {
          Card card=game.getCard(target.getFirstTarget());
          if (card != null) {
            controller.moveCards(card,Zone.BATTLEFIELD,source,game);
          }
        }
      }
    }
    return true;
  }
  return false;
}",0.977818853974122
158542,"@Override public void init(Ability source,Game game){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller != null) {
    int maxToughness=2;
    ManaCosts manaCosts=source.getManaCostsToPay();
    if (!manaCosts.getVariableCosts().isEmpty()) {
      maxToughness=source.getManaCostsToPay().getX();
    }
    Permanent permanent=game.getPermanent(getTargetPointer().getFirst(game,source));
    if (permanent != null && permanent.getToughness().getValue() <= maxToughness) {
      this.discard();
      return;
    }
  }
  super.init(source,game);
}","@Override public void init(Ability source,Game game){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller != null) {
    int maxToughness=2;
    ManaCosts manaCosts=source.getManaCostsToPay();
    if (!manaCosts.getVariableCosts().isEmpty()) {
      maxToughness=source.getManaCostsToPay().getX();
    }
    Permanent permanent=game.getPermanent(getTargetPointer().getFirst(game,source));
    if (permanent != null && permanent.getToughness().getValue() > maxToughness) {
      this.discard();
      return;
    }
  }
  super.init(source,game);
}",0.997384481255449
158543,"@Override public boolean apply(Game game,Ability source){
  PermanentsSacrificedWatcher watcher=(PermanentsSacrificedWatcher)game.getState().getWatchers().get(PermanentsSacrificedWatcher.class.getName());
  if (watcher != null) {
    List<Permanent> sacrificedPermanents=watcher.getThisTurnSacrificedPermanents(source.getControllerId());
    if (!sacrificedPermanents.isEmpty()) {
      int amountOfClues=0;
      for (      Permanent permanent : sacrificedPermanents) {
        if (permanent.getSubtype().contains(""String_Node_Str"")) {
          amountOfClues++;
        }
      }
      return amountOfClues > 2;
    }
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  PermanentsSacrificedWatcher watcher=(PermanentsSacrificedWatcher)game.getState().getWatchers().get(PermanentsSacrificedWatcher.class.getName());
  if (watcher != null) {
    List<Permanent> sacrificedPermanents=watcher.getThisTurnSacrificedPermanents(source.getControllerId());
    if (sacrificedPermanents != null && !sacrificedPermanents.isEmpty()) {
      int amountOfClues=0;
      for (      Permanent permanent : sacrificedPermanents) {
        if (permanent.getSubtype().contains(""String_Node_Str"")) {
          amountOfClues++;
        }
      }
      return amountOfClues > 2;
    }
  }
  return false;
}",0.9756468797564688
158544,"@Override public void watch(GameEvent event,Game game){
  if (event.getType() == EventType.COUNTERED) {
    StackObject stackObject=game.getStack().getStackObject(event.getTargetId());
    if (stackObject == null) {
      stackObject=(StackObject)game.getLastKnownInformation(event.getTargetId(),Zone.STACK);
    }
    if (stackObject != null && !players.contains(stackObject.getControllerId()) && stackObject.getCardType().contains(CardType.CREATURE)) {
      StackObject counterObject=game.getStack().getStackObject(event.getSourceId());
      if (counterObject == null) {
        counterObject=(StackObject)game.getLastKnownInformation(event.getSourceId(),Zone.STACK);
      }
      if (counterObject != null && game.getOpponents(stackObject.getControllerId()).contains(counterObject.getControllerId())) {
        players.add(stackObject.getControllerId());
      }
    }
  }
}","@Override public void watch(GameEvent event,Game game){
  if (event.getType() == EventType.COUNTERED) {
    StackObject conteredSpell=game.getStack().getStackObject(event.getTargetId());
    if (conteredSpell == null) {
      conteredSpell=(StackObject)game.getLastKnownInformation(event.getTargetId(),Zone.STACK);
    }
    if (conteredSpell != null && conteredSpell instanceof Spell && !players.contains(conteredSpell.getControllerId()) && conteredSpell.getCardType().contains(CardType.CREATURE)) {
      StackObject counteringStackObject=game.getStack().getStackObject(event.getSourceId());
      if (counteringStackObject == null) {
        counteringStackObject=(StackObject)game.getLastKnownInformation(event.getSourceId(),Zone.STACK);
      }
      if (counteringStackObject != null && game.getOpponents(conteredSpell.getControllerId()).contains(counteringStackObject.getControllerId())) {
        players.add(conteredSpell.getControllerId());
      }
    }
  }
}",0.76
158545,"/** 
 * Voice of Resurgence creates it's token under owner's control upon death even when it is controlled by an opponent when it dies. Happened with Treachery.
 */
@Test public void testDiesTriggeredAbility(){
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"",5);
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"",1);
  addCard(Zone.HAND,playerA,""String_Node_Str"");
  addCard(Zone.BATTLEFIELD,playerB,""String_Node_Str"",1);
  addCard(Zone.BATTLEFIELD,playerB,""String_Node_Str"",1);
  addCard(Zone.HAND,playerB,""String_Node_Str"");
  castSpell(1,PhaseStep.PRECOMBAT_MAIN,playerA,""String_Node_Str"",""String_Node_Str"");
  castSpell(1,PhaseStep.POSTCOMBAT_MAIN,playerB,""String_Node_Str"",""String_Node_Str"");
  setStopAt(1,PhaseStep.END_TURN);
  execute();
  assertLife(playerA,20);
  assertLife(playerB,20);
  assertGraveyardCount(playerA,""String_Node_Str"",1);
  assertGraveyardCount(playerB,""String_Node_Str"",1);
  assertPermanentCount(playerA,""String_Node_Str"",1);
  assertPowerToughness(playerA,""String_Node_Str"",2,2);
  assertTappedCount(""String_Node_Str"",true,0);
}","/** 
 * Voice of Resurgence creates it's token under owner's control upon death even when it is controlled by an opponent when it dies. Happened with Treachery.
 */
@Test public void testDiesTriggeredAbility(){
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"",5);
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"",1);
  addCard(Zone.HAND,playerA,""String_Node_Str"");
  addCard(Zone.BATTLEFIELD,playerB,""String_Node_Str"",1);
  addCard(Zone.BATTLEFIELD,playerB,""String_Node_Str"",1);
  addCard(Zone.HAND,playerB,""String_Node_Str"");
  castSpell(1,PhaseStep.PRECOMBAT_MAIN,playerA,""String_Node_Str"",""String_Node_Str"");
  castSpell(1,PhaseStep.POSTCOMBAT_MAIN,playerB,""String_Node_Str"",""String_Node_Str"");
  setStopAt(1,PhaseStep.END_TURN);
  execute();
  assertLife(playerA,20);
  assertLife(playerB,20);
  assertGraveyardCount(playerA,""String_Node_Str"",1);
  assertGraveyardCount(playerB,""String_Node_Str"",1);
  assertPermanentCount(playerA,""String_Node_Str"",2);
  assertPowerToughness(playerA,""String_Node_Str"",3,3,Filter.ComparisonScope.All);
  assertTappedCount(""String_Node_Str"",true,0);
}",0.9838187702265372
158546,"public List<Choice> getUnchosen(){
  List<Choice> unchosen=new ArrayList<Choice>();
  for (  Choice choice : this) {
    if (!choice.isChosen()) {
      unchosen.add(choice);
    }
  }
  return unchosen;
}","public List<Choice> getUnchosen(){
  List<Choice> unchosen=new ArrayList<>();
  for (  Choice choice : this) {
    if (!choice.isChosen()) {
      unchosen.add(choice);
    }
  }
  return unchosen;
}",0.9851485148514852
158547,"/** 
 * Uses card.moveToZone and posts a inform message about moving the card to graveyard into the game log
 * @param card
 * @param sourceId
 * @param game
 * @param fromZone if null, this info isn't postet
 * @param toTop to the top of the library else to the bottom
 * @param withName show the card name in the log
 * @return
 */
boolean moveCardToLibraryWithInfo(Card card,UUID sourceId,Game game,Zone fromZone,boolean toTop,boolean withName);","/** 
 * Uses card.moveToZone and posts a inform message about moving the card to library into the game log
 * @param card
 * @param sourceId
 * @param game
 * @param fromZone if null, this info isn't postet
 * @param toTop to the top of the library else to the bottom
 * @param withName show the card name in the log
 * @return
 */
boolean moveCardToLibraryWithInfo(Card card,UUID sourceId,Game game,Zone fromZone,boolean toTop,boolean withName);",0.9843400447427292
158548,"MultipliedValue(final MultipliedValue dynamicValue){
  this.value=dynamicValue.value.copy();
  this.multplier=dynamicValue.multplier;
}","MultipliedValue(final MultipliedValue dynamicValue){
  this.value=dynamicValue.value.copy();
  this.multiplier=dynamicValue.multiplier;
}",0.9926470588235294
158549,"@Override public String toString(){
  StringBuilder sb=new StringBuilder();
  if (multplier == 2) {
    sb.append(""String_Node_Str"");
  }
 else {
    sb.append(multplier).append(""String_Node_Str"");
  }
  return sb.append(value.toString()).toString();
}","@Override public String toString(){
  StringBuilder sb=new StringBuilder();
  if (multiplier == 2) {
    sb.append(""String_Node_Str"");
  }
 else {
    sb.append(multiplier).append(""String_Node_Str"");
  }
  return sb.append(value.toString()).toString();
}",0.9960474308300395
158550,"@Override public int calculate(Game game,Ability sourceAbility,Effect effect){
  return multplier * value.calculate(game,sourceAbility,effect);
}","@Override public int calculate(Game game,Ability sourceAbility,Effect effect){
  return multiplier * value.calculate(game,sourceAbility,effect);
}",0.9965635738831616
158551,"@Override public String getMessage(){
  return ""String_Node_Str"" + amount;
}","@Override public String getMessage(){
  return ""String_Node_Str"" + amount + ""String_Node_Str""+ amount+ ""String_Node_Str""+ amount+ ""String_Node_Str"";
}",0.672566371681416
158552,"@Override public int calculate(Game game,Ability sourceAbility,Effect effect){
  int count=0;
  for (  CombatGroup combatGroup : game.getCombat().getGroups()) {
    if (combatGroup.getAttackers().contains(sourceAbility.getSourceId())) {
      int blockers=combatGroup.getBlockers().size();
      return blockers > 1 ? (blockers - 1) * amount : 0;
    }
  }
  return 0;
}","@Override public int calculate(Game game,Ability sourceAbility,Effect effect){
  for (  CombatGroup combatGroup : game.getCombat().getGroups()) {
    if (combatGroup.getAttackers().contains(sourceAbility.getSourceId())) {
      int blockers=combatGroup.getBlockers().size();
      return blockers > 1 ? (blockers - 1) * amount : 0;
    }
  }
  return 0;
}",0.2537931034482759
158553,"/** 
 * Reported bug: When Breaker of Armies is granted Menace and there is only 1 valid blocker, the game enters a state that cannot be continued. He must be blocked by all creatures that are able, however, with menace the only valid blocks would be by more than one creature, so the expected behavior is no blocks can be made.
 */
@Ignore @Test public void testBreakerOfArmiesWithMenace(){
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"",1);
  addCard(Zone.BATTLEFIELD,playerB,""String_Node_Str"",1);
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"",8);
  addCard(Zone.HAND,playerA,""String_Node_Str"",1);
  castSpell(1,PhaseStep.PRECOMBAT_MAIN,playerA,""String_Node_Str"",""String_Node_Str"");
  attack(1,playerA,""String_Node_Str"");
  block(1,playerB,""String_Node_Str"",""String_Node_Str"");
  setStopAt(1,PhaseStep.POSTCOMBAT_MAIN);
  execute();
  assertPermanentCount(playerA,""String_Node_Str"",1);
  assertLife(playerB,10);
}","/** 
 * Reported bug: When Breaker of Armies is granted Menace and there is only 1 valid blocker, the game enters a state that cannot be continued. He must be blocked by all creatures that are able, however, with menace the only valid blocks would be by more than one creature, so the expected behavior is no blocks can be made.
 */
@Test public void testBreakerOfArmiesWithMenace(){
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"",1);
  addCard(Zone.BATTLEFIELD,playerB,""String_Node_Str"",1);
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"",8);
  addCard(Zone.HAND,playerA,""String_Node_Str"",1);
  castSpell(1,PhaseStep.PRECOMBAT_MAIN,playerA,""String_Node_Str"",""String_Node_Str"");
  attack(1,playerA,""String_Node_Str"");
  block(1,playerB,""String_Node_Str"",""String_Node_Str"");
  setStopAt(1,PhaseStep.POSTCOMBAT_MAIN);
  execute();
  assertPermanentCount(playerB,""String_Node_Str"",1);
  assertLife(playerB,8);
}",0.9929615592853276
158554,"/** 
 * 509.1c The defending player checks each creature he or she controls to see whether it's affected by any requirements (effects that say a creature must block, or that it must block if some condition is met). If the number of requirements that are being obeyed is fewer than the maximum possible number of requirements that could be obeyed without disobeying any restrictions, the declaration of blockers is illegal. If a creature can't block unless a player pays a cost, that player is not required to pay that cost, even if blocking with that creature would increase the number of requirements being obeyed. Example: A player controls one creature that ""blocks if able"" and another creature with no abilities. An effect states ""Creatures can't be blocked except by two or more creatures."" Having only the first creature block violates the restriction. Having neither creature block fulfills the restriction but not the requirement. Having both creatures block the same attacking creature fulfills both the restriction and the requirement, so that's the only option.
 * @param player
 * @param controller
 * @param game
 * @return
 */
public boolean checkBlockRequirementsAfter(Player player,Player controller,Game game){
  Set<UUID> opponents=game.getOpponents(attackerId);
  Map<UUID,Set<UUID>> mustBeBlockedByAtLeastOne=new HashMap<>();
  for (  Permanent creature : game.getBattlefield().getActivePermanents(new FilterControlledCreaturePermanent(),player.getId(),game)) {
    if (opponents.contains(creature.getControllerId())) {
      if (creature.getBlocking() > 0) {
        for (        Map.Entry<RequirementEffect,HashSet<Ability>> entry : game.getContinuousEffects().getApplicableRequirementEffects(creature,game).entrySet()) {
          RequirementEffect effect=entry.getKey();
          for (          Ability ability : entry.getValue()) {
            UUID toBeBlockedCreature=effect.mustBlockAttackerIfElseUnblocked(ability,game);
            if (toBeBlockedCreature != null) {
              Set<UUID> potentialBlockers;
              if (mustBeBlockedByAtLeastOne.containsKey(toBeBlockedCreature)) {
                potentialBlockers=mustBeBlockedByAtLeastOne.get(toBeBlockedCreature);
              }
 else {
                potentialBlockers=new HashSet<>();
                mustBeBlockedByAtLeastOne.put(toBeBlockedCreature,potentialBlockers);
              }
              potentialBlockers.add(creature.getId());
            }
          }
        }
      }
      if (creature.getBlocking() == 0) {
        for (        Map.Entry<RequirementEffect,HashSet<Ability>> entry : game.getContinuousEffects().getApplicableRequirementEffects(creature,game).entrySet()) {
          RequirementEffect effect=entry.getKey();
          for (          Ability ability : entry.getValue()) {
            UUID toBeBlockedCreature=effect.mustBlockAttackerIfElseUnblocked(ability,game);
            if (toBeBlockedCreature != null) {
              Set<UUID> potentialBlockers;
              if (mustBeBlockedByAtLeastOne.containsKey(toBeBlockedCreature)) {
                potentialBlockers=mustBeBlockedByAtLeastOne.get(toBeBlockedCreature);
              }
 else {
                potentialBlockers=new HashSet<>();
                mustBeBlockedByAtLeastOne.put(toBeBlockedCreature,potentialBlockers);
              }
              potentialBlockers.add(creature.getId());
            }
          }
          if (effect.mustBlockAny(game)) {
            boolean mayBlock=false;
            for (            UUID attackingCreatureId : getAttackers()) {
              if (creature.canBlock(attackingCreatureId,game)) {
                Permanent attackingCreature=game.getPermanent(attackingCreatureId);
                if (attackingCreature != null) {
                  if (attackingCreature.getMaxBlockedBy() != 0) {
                    int alreadyBlockingCreatures=0;
                    for (                    CombatGroup group : getGroups()) {
                      if (group.getAttackers().contains(attackingCreatureId)) {
                        alreadyBlockingCreatures=group.getBlockers().size();
                        break;
                      }
                    }
                    if (attackingCreature.getMaxBlockedBy() <= alreadyBlockingCreatures) {
                      continue;
                    }
                  }
                  if (attackingCreature.getMinBlockedBy() > 1) {
                  }
 else {
                    mayBlock=true;
                    break;
                  }
                }
              }
            }
            if (mayBlock) {
              if (controller.isHuman()) {
                if (!game.isSimulation()) {
                  game.informPlayer(controller,""String_Node_Str"" + creature.getIdName());
                }
              }
 else {
                Player defender=game.getPlayer(creature.getControllerId());
                if (defender != null) {
                  for (                  UUID attackingCreatureId : getAttackers()) {
                    if (creature.canBlock(attackingCreatureId,game)) {
                      defender.declareBlocker(defender.getId(),creature.getId(),attackingCreatureId,game);
                      break;
                    }
                  }
                }
              }
              return false;
            }
          }
        }
      }
    }
  }
  for (  UUID toBeBlockedCreatureId : mustBeBlockedByAtLeastOne.keySet()) {
    for (    CombatGroup combatGroup : game.getCombat().getGroups()) {
      if (combatGroup.getBlockers().isEmpty() && combatGroup.getAttackers().contains(toBeBlockedCreatureId)) {
        if (controller.isHuman()) {
          Permanent toBeBlockedCreature=game.getPermanent(toBeBlockedCreatureId);
          if (toBeBlockedCreature != null) {
            for (            UUID possibleBlockerId : mustBeBlockedByAtLeastOne.get(toBeBlockedCreatureId)) {
              String blockRequiredMessage=isCreatureDoingARequiredBlock(possibleBlockerId,mustBeBlockedByAtLeastOne,game);
              if (blockRequiredMessage != null) {
                removeBlocker(possibleBlockerId,game);
                game.informPlayer(controller,blockRequiredMessage + ""String_Node_Str"" + toBeBlockedCreature.getIdName()+ ""String_Node_Str"");
                return false;
              }
            }
          }
        }
 else {
          for (          UUID possibleBlockerId : mustBeBlockedByAtLeastOne.get(toBeBlockedCreatureId)) {
            String blockRequiredMessage=isCreatureDoingARequiredBlock(possibleBlockerId,mustBeBlockedByAtLeastOne,game);
            if (blockRequiredMessage != null) {
              Permanent possibleBlocker=game.getPermanent(possibleBlockerId);
              Player defender=game.getPlayer(possibleBlocker.getControllerId());
              if (defender != null) {
                if (possibleBlocker.getBlocking() > 0) {
                  removeBlocker(possibleBlockerId,game);
                }
                defender.declareBlocker(defender.getId(),possibleBlockerId,toBeBlockedCreatureId,game);
              }
              break;
            }
          }
        }
      }
    }
  }
  StringBuilder sb=new StringBuilder();
  for (  Map.Entry<UUID,Set<UUID>> entry : creatureMustBlockAttackers.entrySet()) {
    boolean blockIsValid;
    Permanent creatureForcedToBlock=game.getPermanent(entry.getKey());
    if (creatureForcedToBlock == null) {
      break;
    }
    if (!creatureForcedToBlock.getControllerId().equals(player.getId())) {
      continue;
    }
    if (creatureForcedToBlock.getBlocking() == 0) {
      blockIsValid=false;
    }
 else {
      blockIsValid=false;
      CombatGroups:       for (      CombatGroup combatGroup : game.getCombat().getGroups()) {
        if (combatGroup.getBlockers().contains(creatureForcedToBlock.getId())) {
          for (          UUID forcingAttackerId : combatGroup.getAttackers()) {
            if (entry.getValue().contains(forcingAttackerId)) {
              blockIsValid=true;
              break CombatGroups;
            }
 else             if (combatGroup.getBlockers().size() == 1) {
              if (mustBeBlockedByAtLeastOne.containsKey(forcingAttackerId)) {
                if (mustBeBlockedByAtLeastOne.get(forcingAttackerId).contains(creatureForcedToBlock.getId())) {
                  blockIsValid=true;
                  break CombatGroups;
                }
              }
            }
          }
        }
      }
    }
    if (!blockIsValid) {
      sb.append(""String_Node_Str"").append(creatureForcedToBlock.getIdName());
    }
  }
  if (sb.length() > 0) {
    if (!game.isSimulation()) {
      sb.insert(0,""String_Node_Str"");
      sb.append(""String_Node_Str"");
      game.informPlayer(controller,sb.toString());
    }
    return false;
  }
  return true;
}","/** 
 * 509.1c The defending player checks each creature he or she controls to see whether it's affected by any requirements (effects that say a creature must block, or that it must block if some condition is met). If the number of requirements that are being obeyed is fewer than the maximum possible number of requirements that could be obeyed without disobeying any restrictions, the declaration of blockers is illegal. If a creature can't block unless a player pays a cost, that player is not required to pay that cost, even if blocking with that creature would increase the number of requirements being obeyed. Example: A player controls one creature that ""blocks if able"" and another creature with no abilities. An effect states ""Creatures can't be blocked except by two or more creatures."" Having only the first creature block violates the restriction. Having neither creature block fulfills the restriction but not the requirement. Having both creatures block the same attacking creature fulfills both the restriction and the requirement, so that's the only option.
 * @param player
 * @param controller
 * @param game
 * @return
 */
public boolean checkBlockRequirementsAfter(Player player,Player controller,Game game){
  Set<UUID> opponents=game.getOpponents(attackerId);
  Map<UUID,Set<UUID>> mustBeBlockedByAtLeastOne=new HashMap<>();
  for (  Permanent creature : game.getBattlefield().getActivePermanents(new FilterControlledCreaturePermanent(),player.getId(),game)) {
    if (opponents.contains(creature.getControllerId())) {
      if (creature.getBlocking() > 0) {
        for (        Map.Entry<RequirementEffect,HashSet<Ability>> entry : game.getContinuousEffects().getApplicableRequirementEffects(creature,game).entrySet()) {
          RequirementEffect effect=entry.getKey();
          for (          Ability ability : entry.getValue()) {
            UUID toBeBlockedCreature=effect.mustBlockAttackerIfElseUnblocked(ability,game);
            if (toBeBlockedCreature != null) {
              Set<UUID> potentialBlockers;
              if (mustBeBlockedByAtLeastOne.containsKey(toBeBlockedCreature)) {
                potentialBlockers=mustBeBlockedByAtLeastOne.get(toBeBlockedCreature);
              }
 else {
                potentialBlockers=new HashSet<>();
                mustBeBlockedByAtLeastOne.put(toBeBlockedCreature,potentialBlockers);
              }
              potentialBlockers.add(creature.getId());
            }
          }
        }
      }
      if (creature.getBlocking() == 0) {
        for (        Map.Entry<RequirementEffect,HashSet<Ability>> entry : game.getContinuousEffects().getApplicableRequirementEffects(creature,game).entrySet()) {
          RequirementEffect effect=entry.getKey();
          for (          Ability ability : entry.getValue()) {
            UUID toBeBlockedCreature=effect.mustBlockAttackerIfElseUnblocked(ability,game);
            if (toBeBlockedCreature != null) {
              Set<UUID> potentialBlockers;
              if (mustBeBlockedByAtLeastOne.containsKey(toBeBlockedCreature)) {
                potentialBlockers=mustBeBlockedByAtLeastOne.get(toBeBlockedCreature);
              }
 else {
                potentialBlockers=new HashSet<>();
                mustBeBlockedByAtLeastOne.put(toBeBlockedCreature,potentialBlockers);
              }
              potentialBlockers.add(creature.getId());
            }
          }
          if (effect.mustBlockAny(game)) {
            boolean mayBlock=false;
            for (            UUID attackingCreatureId : getAttackers()) {
              if (creature.canBlock(attackingCreatureId,game)) {
                Permanent attackingCreature=game.getPermanent(attackingCreatureId);
                if (attackingCreature != null) {
                  if (attackingCreature.getMaxBlockedBy() != 0) {
                    int alreadyBlockingCreatures=0;
                    for (                    CombatGroup group : getGroups()) {
                      if (group.getAttackers().contains(attackingCreatureId)) {
                        alreadyBlockingCreatures=group.getBlockers().size();
                        break;
                      }
                    }
                    if (attackingCreature.getMaxBlockedBy() <= alreadyBlockingCreatures) {
                      continue;
                    }
                  }
                  if (attackingCreature.getMinBlockedBy() > 1) {
                  }
 else {
                    mayBlock=true;
                    break;
                  }
                }
              }
            }
            if (mayBlock) {
              if (controller.isHuman()) {
                if (!game.isSimulation()) {
                  game.informPlayer(controller,""String_Node_Str"" + creature.getIdName());
                }
              }
 else {
                Player defender=game.getPlayer(creature.getControllerId());
                if (defender != null) {
                  for (                  UUID attackingCreatureId : getAttackers()) {
                    if (creature.canBlock(attackingCreatureId,game)) {
                      defender.declareBlocker(defender.getId(),creature.getId(),attackingCreatureId,game);
                      break;
                    }
                  }
                }
              }
              return false;
            }
          }
        }
      }
    }
  }
  for (  UUID toBeBlockedCreatureId : mustBeBlockedByAtLeastOne.keySet()) {
    for (    CombatGroup combatGroup : game.getCombat().getGroups()) {
      if (combatGroup.getBlockers().isEmpty() && combatGroup.getAttackers().contains(toBeBlockedCreatureId)) {
        if (controller.isHuman()) {
          Permanent toBeBlockedCreature=game.getPermanent(toBeBlockedCreatureId);
          if (toBeBlockedCreature != null) {
            for (            UUID possibleBlockerId : mustBeBlockedByAtLeastOne.get(toBeBlockedCreatureId)) {
              String blockRequiredMessage=isCreatureDoingARequiredBlock(possibleBlockerId,mustBeBlockedByAtLeastOne,game);
              if (blockRequiredMessage != null) {
                removeBlocker(possibleBlockerId,game);
                game.informPlayer(controller,blockRequiredMessage + ""String_Node_Str"" + toBeBlockedCreature.getIdName()+ ""String_Node_Str"");
                return false;
              }
            }
          }
        }
 else {
          for (          UUID possibleBlockerId : mustBeBlockedByAtLeastOne.get(toBeBlockedCreatureId)) {
            String blockRequiredMessage=isCreatureDoingARequiredBlock(possibleBlockerId,mustBeBlockedByAtLeastOne,game);
            if (blockRequiredMessage != null) {
              Permanent possibleBlocker=game.getPermanent(possibleBlockerId);
              Player defender=game.getPlayer(possibleBlocker.getControllerId());
              if (defender != null) {
                if (possibleBlocker.getBlocking() > 0) {
                  removeBlocker(possibleBlockerId,game);
                }
                defender.declareBlocker(defender.getId(),possibleBlockerId,toBeBlockedCreatureId,game);
              }
              break;
            }
          }
        }
      }
    }
  }
  StringBuilder sb=new StringBuilder();
  for (  Map.Entry<UUID,Set<UUID>> entry : creatureMustBlockAttackers.entrySet()) {
    boolean blockIsValid;
    Permanent creatureForcedToBlock=game.getPermanent(entry.getKey());
    if (creatureForcedToBlock == null) {
      break;
    }
    if (!creatureForcedToBlock.getControllerId().equals(player.getId())) {
      continue;
    }
    if (creatureForcedToBlock.getBlocking() == 0) {
      boolean validBlockPossible=false;
      for (      UUID possibleAttackerId : entry.getValue()) {
        CombatGroup attackersGroup=findGroup(possibleAttackerId);
        if (attackersGroup.getBlockers().contains(creatureForcedToBlock.getId())) {
          validBlockPossible=true;
          break;
        }
        Permanent attackingCreature=game.getPermanent(possibleAttackerId);
        if (attackingCreature.getMinBlockedBy() > 1) {
          if (attackersGroup.getBlockers().size() + 1 >= attackingCreature.getMinBlockedBy()) {
            validBlockPossible=true;
          }
        }
      }
      if (!validBlockPossible) {
        continue;
      }
    }
    if (creatureForcedToBlock.getBlocking() == 0) {
      blockIsValid=false;
    }
 else {
      blockIsValid=false;
      CombatGroups:       for (      CombatGroup combatGroup : game.getCombat().getGroups()) {
        if (combatGroup.getBlockers().contains(creatureForcedToBlock.getId())) {
          for (          UUID forcingAttackerId : combatGroup.getAttackers()) {
            if (entry.getValue().contains(forcingAttackerId)) {
              blockIsValid=true;
              break CombatGroups;
            }
 else             if (combatGroup.getBlockers().size() == 1) {
              if (mustBeBlockedByAtLeastOne.containsKey(forcingAttackerId)) {
                if (mustBeBlockedByAtLeastOne.get(forcingAttackerId).contains(creatureForcedToBlock.getId())) {
                  blockIsValid=true;
                  break CombatGroups;
                }
              }
            }
          }
        }
      }
    }
    if (!blockIsValid) {
      sb.append(""String_Node_Str"").append(creatureForcedToBlock.getIdName());
    }
  }
  if (sb.length() > 0) {
    if (!game.isSimulation()) {
      sb.insert(0,""String_Node_Str"");
      sb.append(""String_Node_Str"");
      game.informPlayer(controller,sb.toString());
    }
    return false;
  }
  return true;
}",0.9342327150084316
158555,"@Override public boolean apply(Game game,Ability source){
  Player player=game.getPlayer(source.getControllerId());
  Permanent permanent=game.getPermanent(source.getSourceId());
  String chosenType=""String_Node_Str"";
  if (player != null && permanent != null) {
    Choice typeChoice=new ChoiceImpl(true);
    typeChoice.setMessage(""String_Node_Str"");
    Set<String> types=CardRepository.instance.getCreatureTypes();
    types.remove(""String_Node_Str"");
    typeChoice.setChoices(types);
    while (!player.choose(Outcome.BoostCreature,typeChoice,game)) {
      if (!player.canRespond()) {
        return false;
      }
    }
    game.informPlayers(permanent.getName() + ""String_Node_Str"" + player.getLogName()+ ""String_Node_Str""+ typeChoice.getChoice());
    chosenType=typeChoice.getChoice();
    if (chosenType != null && !chosenType.isEmpty()) {
      ContinuousEffect effect=new BecomesSubtypeAllEffect(Duration.EndOfTurn,chosenType);
      game.addEffect(effect,source);
      return true;
    }
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Player player=game.getPlayer(source.getControllerId());
  MageObject sourceObject=game.getObject(source.getSourceId());
  String chosenType=""String_Node_Str"";
  if (player != null && sourceObject != null) {
    Choice typeChoice=new ChoiceImpl(true);
    typeChoice.setMessage(""String_Node_Str"");
    Set<String> types=CardRepository.instance.getCreatureTypes();
    types.remove(""String_Node_Str"");
    typeChoice.setChoices(types);
    while (!player.choose(Outcome.BoostCreature,typeChoice,game)) {
      if (!player.canRespond()) {
        return false;
      }
    }
    game.informPlayers(sourceObject.getLogName() + ""String_Node_Str"" + player.getLogName()+ ""String_Node_Str""+ typeChoice.getChoice());
    chosenType=typeChoice.getChoice();
    if (chosenType != null && !chosenType.isEmpty()) {
      ContinuousEffect effect=new BecomesSubtypeAllEffect(Duration.EndOfTurn,chosenType);
      game.addEffect(effect,source);
      return true;
    }
  }
  return false;
}",0.9495145631067962
158556,"public void changeGUISize(){
  setGUISize();
  cardGrid.changeGUISize();
}","public void changeGUISize(){
  setGUISize();
  cardGrid.changeGUISize();
  if (currentView instanceof CardGrid) {
    this.currentView.drawCards(sortSetting);
  }
}",0.6218487394957983
158557,"@Override public boolean pay(Ability ability,Game game,UUID sourceId,UUID controllerId,boolean noMana,Cost costToPay){
  if (targets.choose(Outcome.Exile,controllerId,sourceId,game)) {
    Player controller=game.getPlayer(controllerId);
    if (controller != null) {
      Card card=controller.getGraveyard().get(targets.getFirstTarget(),game);
      if (card != null && controller.moveCards(card,null,Zone.EXILED,ability,game)) {
        ability.getEffects().get(0).setTargetPointer(new FixedTarget(card.getId()));
        paid=card.getManaCost().pay(ability,game,sourceId,controllerId,noMana);
      }
    }
  }
  return paid;
}","@Override public boolean pay(Ability ability,Game game,UUID sourceId,UUID controllerId,boolean noMana,Cost costToPay){
  if (targets.choose(Outcome.Exile,controllerId,sourceId,game)) {
    Player controller=game.getPlayer(controllerId);
    if (controller != null) {
      Card card=controller.getGraveyard().get(targets.getFirstTarget(),game);
      if (card != null && controller.moveCards(card,Zone.EXILED,ability,game)) {
        ability.getEffects().get(0).setTargetPointer(new FixedTarget(card.getId()));
        paid=card.getManaCost().pay(ability,game,sourceId,controllerId,noMana);
      }
    }
  }
  return paid;
}",0.99601593625498
158558,"@Override public void init(Ability source,Game game){
  super.init(source,game);
  if (!(copyFromObject instanceof Permanent) && (copyFromObject instanceof Card)) {
    this.copyFromObject=new PermanentCard((Card)copyFromObject,source.getControllerId(),game);
  }
  Permanent permanent=game.getPermanent(copyToObjectId);
  if (permanent != null) {
    affectedObjectList.add(new MageObjectReference(permanent,game));
  }
 else   if (source.getAbilityType().equals(AbilityType.STATIC)) {
    permanent=game.getPermanentEntering(copyToObjectId);
    if (permanent != null) {
      copyToPermanent(permanent,game,source);
      affectedObjectList.add(new MageObjectReference(permanent.getId(),game.getState().getZoneChangeCounter(copyToObjectId) + 1,game));
    }
  }
}","@Override public void init(Ability source,Game game){
  super.init(source,game);
  if (!(copyFromObject instanceof Permanent) && (copyFromObject instanceof Card)) {
    this.copyFromObject=new PermanentCard((Card)copyFromObject,source.getControllerId(),game);
  }
  Permanent permanent=game.getPermanent(copyToObjectId);
  if (permanent != null) {
    affectedObjectList.add(new MageObjectReference(permanent,game));
  }
 else   if (source.getAbilityType().equals(AbilityType.STATIC)) {
    permanent=game.getPermanentEntering(copyToObjectId);
    if (permanent != null) {
      copyToPermanent(permanent,game,source);
      int ZCCDiff=1;
      if (permanent instanceof PermanentToken) {
        ZCCDiff=0;
      }
      affectedObjectList.add(new MageObjectReference(permanent.getId(),game.getState().getZoneChangeCounter(copyToObjectId) + ZCCDiff,game));
    }
  }
}",0.9357798165137616
158559,"private void btnQuitTournamentActionPerformed(java.awt.event.ActionEvent evt){
  UserRequestMessage message=new UserRequestMessage(""String_Node_Str"",""String_Node_Str"");
  message.setButton1(""String_Node_Str"",null);
  message.setButton2(""String_Node_Str"",PlayerAction.CLIENT_QUIT_TOURNAMENT);
  MageFrame.getInstance().showUserRequestDialog(message);
}","private void btnQuitTournamentActionPerformed(java.awt.event.ActionEvent evt){
  UserRequestMessage message=new UserRequestMessage(""String_Node_Str"",""String_Node_Str"");
  message.setButton1(""String_Node_Str"",null);
  message.setButton2(""String_Node_Str"",PlayerAction.CLIENT_QUIT_TOURNAMENT);
  message.setTournamentId(tournamentId);
  MageFrame.getInstance().showUserRequestDialog(message);
}",0.9448183041722744
158560,"/** 
 * In a Commander FFA game, I controlled 5 vampires (one of which was Captivating Vampire). My opponent cast Progenitor Mimic, copying Captivating Vampire. I used the ability of my Captivating Vampire to gain control of his Mimic/Vampire but the buff didn't switch control. His other vampire still got the buff even after I gained control of the Mimic/Vampire. Did not get to see if the Mimic/Vampire produced tokens on the right side of the field (my side) as the game ended just after my turn.
 */
@Test public void testChangeControl(){
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"",1);
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"",4);
  addCard(Zone.HAND,playerB,""String_Node_Str"",1);
  addCard(Zone.BATTLEFIELD,playerB,""String_Node_Str"",3);
  addCard(Zone.BATTLEFIELD,playerB,""String_Node_Str"",3);
  castSpell(2,PhaseStep.PRECOMBAT_MAIN,playerB,""String_Node_Str"");
  setChoice(playerB,""String_Node_Str"");
  activateAbility(2,PhaseStep.POSTCOMBAT_MAIN,playerA,""String_Node_Str"",""String_Node_Str"");
  setChoice(playerA,""String_Node_Str"");
  setChoice(playerA,""String_Node_Str"");
  setChoice(playerA,""String_Node_Str"");
  setChoice(playerA,""String_Node_Str"");
  setChoice(playerA,""String_Node_Str"");
  setStopAt(2,PhaseStep.END_TURN);
  execute();
  assertPermanentCount(playerA,""String_Node_Str"",2);
  assertPowerToughness(playerA,""String_Node_Str"",3,3,Filter.ComparisonScope.All);
  assertPowerToughness(playerA,""String_Node_Str"",4,3,Filter.ComparisonScope.All);
}","/** 
 * In a Commander FFA game, I controlled 5 vampires (one of which was Captivating Vampire). My opponent cast Progenitor Mimic, copying Captivating Vampire. I used the ability of my Captivating Vampire to gain control of his Mimic/Vampire but the buff didn't switch control. His other vampire still got the buff even after I gained control of the Mimic/Vampire. Did not get to see if the Mimic/Vampire produced tokens on the right side of the field (my side) as the game ended just after my turn.
 */
@Test public void testChangeControl(){
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"",1);
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"",4);
  addCard(Zone.HAND,playerB,""String_Node_Str"",1);
  addCard(Zone.BATTLEFIELD,playerB,""String_Node_Str"",3);
  addCard(Zone.BATTLEFIELD,playerB,""String_Node_Str"",3);
  addCard(Zone.BATTLEFIELD,playerB,""String_Node_Str"",1);
  castSpell(2,PhaseStep.PRECOMBAT_MAIN,playerB,""String_Node_Str"");
  setChoice(playerB,""String_Node_Str"");
  activateAbility(2,PhaseStep.POSTCOMBAT_MAIN,playerA,""String_Node_Str"",""String_Node_Str"");
  setChoice(playerA,""String_Node_Str"");
  setChoice(playerA,""String_Node_Str"");
  setChoice(playerA,""String_Node_Str"");
  setChoice(playerA,""String_Node_Str"");
  setChoice(playerA,""String_Node_Str"");
  setStopAt(2,PhaseStep.END_TURN);
  execute();
  assertPermanentCount(playerA,""String_Node_Str"",2);
  assertPowerToughness(playerB,""String_Node_Str"",3,1);
  assertPowerToughness(playerA,""String_Node_Str"",3,3,Filter.ComparisonScope.All);
  assertPowerToughness(playerA,""String_Node_Str"",4,3,Filter.ComparisonScope.All);
}",0.9630589760207388
158561,"@Override public boolean checkControlChanged(Game game){
  if (!controllerId.equals(beforeResetControllerId)) {
    this.removeFromCombat(game);
    this.controlledFromStartOfControllerTurn=false;
    this.getAbilities(game).setControllerId(controllerId);
    game.getContinuousEffects().setController(objectId,controllerId);
    game.fireEvent(new GameEvent(EventType.LOST_CONTROL,objectId,objectId,beforeResetControllerId));
    game.fireEvent(new GameEvent(EventType.GAINED_CONTROL,objectId,objectId,controllerId));
    return true;
  }
  return false;
}","@Override public boolean checkControlChanged(Game game){
  if (!controllerId.equals(beforeResetControllerId)) {
    this.removeFromCombat(game);
    this.controlledFromStartOfControllerTurn=false;
    this.getAbilities(game).setControllerId(controllerId);
    game.getContinuousEffects().setController(objectId,controllerId);
    game.fireEvent(new GameEvent(EventType.LOST_CONTROL,objectId,objectId,beforeResetControllerId));
    game.fireEvent(new GameEvent(EventType.GAINED_CONTROL,objectId,objectId,controllerId));
    return true;
  }
 else   if (isCopy()) {
    this.getAbilities(game).setControllerId(controllerId);
    game.getContinuousEffects().setController(objectId,controllerId);
  }
  return false;
}",0.8528717545239969
158562,"private boolean performUserCommand(User user,String message,UUID chatId){
  String command=message.substring(1).trim().toUpperCase(Locale.ENGLISH);
  if (command.startsWith(""String_Node_Str"") || command.startsWith(""String_Node_Str"")) {
    message=UserManager.getInstance().getUserHistory(message.substring(command.startsWith(""String_Node_Str"") ? 3 : 9));
    chatSessions.get(chatId).broadcastInfoToUser(user,message);
    return true;
  }
  if (command.startsWith(""String_Node_Str"") || command.startsWith(""String_Node_Str"")) {
    String rest=message.substring(command.startsWith(""String_Node_Str"") ? 3 : 9);
    int first=rest.indexOf(""String_Node_Str"");
    if (first > 1) {
      String userToName=rest.substring(0,first);
      rest=rest.substring(first + 1).trim();
      User userTo=UserManager.getInstance().getUserByName(userToName);
      if (userTo != null) {
        if (!chatSessions.get(chatId).broadcastWhisperToUser(user,userTo,rest)) {
          message+=new StringBuilder(""String_Node_Str"").append(userToName).append(""String_Node_Str"").toString();
          chatSessions.get(chatId).broadcastInfoToUser(user,message);
        }
      }
 else {
        message+=new StringBuilder(""String_Node_Str"").append(userToName).append(""String_Node_Str"").toString();
        chatSessions.get(chatId).broadcastInfoToUser(user,message);
      }
      return true;
    }
  }
  if (command.equals(""String_Node_Str"") || command.equals(""String_Node_Str"")) {
    message+=new StringBuilder(""String_Node_Str"").append(""String_Node_Str"").append(""String_Node_Str"").append(""String_Node_Str"").toString();
    chatSessions.get(chatId).broadcastInfoToUser(user,message);
    return true;
  }
  return false;
}","private boolean performUserCommand(User user,String message,UUID chatId,boolean doError){
  String command=message.substring(1).trim().toUpperCase(Locale.ENGLISH);
  if (doError) {
    message+=new StringBuilder(""String_Node_Str"" + message + ""String_Node_Str"").append(""String_Node_Str"").append(""String_Node_Str"").append(""String_Node_Str"").append(""String_Node_Str"").toString();
    chatSessions.get(chatId).broadcastInfoToUser(user,message);
    return true;
  }
  if (command.startsWith(""String_Node_Str"") || command.startsWith(""String_Node_Str"")) {
    message=UserManager.getInstance().getUserHistory(message.substring(command.startsWith(""String_Node_Str"") ? 3 : 9));
    chatSessions.get(chatId).broadcastInfoToUser(user,message);
    return true;
  }
  if (command.startsWith(""String_Node_Str"") || command.startsWith(""String_Node_Str"")) {
    String rest=message.substring(command.startsWith(""String_Node_Str"") ? 3 : 9);
    int first=rest.indexOf(""String_Node_Str"");
    if (first > 1) {
      String userToName=rest.substring(0,first);
      rest=rest.substring(first + 1).trim();
      User userTo=UserManager.getInstance().getUserByName(userToName);
      if (userTo != null) {
        if (!chatSessions.get(chatId).broadcastWhisperToUser(user,userTo,rest)) {
          message+=new StringBuilder(""String_Node_Str"").append(userToName).append(""String_Node_Str"").toString();
          chatSessions.get(chatId).broadcastInfoToUser(user,message);
        }
      }
 else {
        message+=new StringBuilder(""String_Node_Str"").append(userToName).append(""String_Node_Str"").toString();
        chatSessions.get(chatId).broadcastInfoToUser(user,message);
      }
      return true;
    }
  }
  if (command.equals(""String_Node_Str"") || command.equals(""String_Node_Str"")) {
    message+=new StringBuilder(""String_Node_Str"").append(""String_Node_Str"").append(""String_Node_Str"").append(""String_Node_Str"").toString();
    chatSessions.get(chatId).broadcastInfoToUser(user,message);
    return true;
  }
  return false;
}",0.9155005382131324
158563,"@Override public void watch(GameEvent event,Game game){
  if (step != null && game.getTurn().getStep() != step) {
    spellsCastFromHand.clear();
    step=null;
  }
  if (event.getType() == GameEvent.EventType.SPELL_CAST && event.getZone().equals(Zone.HAND)) {
    step=game.getTurn().getStep();
    Spell spell=(Spell)game.getObject(event.getTargetId());
    if (this.getSourceId().equals(spell.getSourceId())) {
      condition=true;
    }
  }
}","@Override public void watch(GameEvent event,Game game){
  if (step != null && game.getTurn().getStep() != step) {
    spellsCastFromHand.clear();
    step=null;
  }
  if (event.getType() == GameEvent.EventType.SPELL_CAST && event.getZone().equals(Zone.HAND)) {
    if (step == null) {
      step=game.getTurn().getStep();
    }
    Spell spell=(Spell)game.getObject(event.getTargetId());
    spellsCastFromHand.add(spell.getSourceId());
  }
}",0.8571428571428571
158564,"@Override public boolean apply(Game game,Ability source){
}","@Override public boolean apply(Game game,Ability source){
  Permanent permanent=game.getPermanentEntering(source.getSourceId());
  int zccDiff=0;
  if (permanent == null) {
    permanent=game.getPermanentOrLKIBattlefield(source.getSourceId());
    zccDiff=-1;
  }
  if (permanent != null) {
    Spell spell=game.getStack().getSpell(source.getSourceId());
    if (spell == null || spell.getZoneChangeCounter(game) != permanent.getZoneChangeCounter(game) + zccDiff) {
      if (game.getLastKnownInformation(source.getSourceId(),Zone.STACK,permanent.getZoneChangeCounter(game) + zccDiff) == null) {
        return false;
      }
    }
    CastFromHandWatcher watcher=(CastFromHandWatcher)game.getState().getWatchers().get(CastFromHandWatcher.class.getName(),source.getSourceId());
    if (watcher != null && watcher.spellWasCastFromHand(source.getSourceId())) {
      return true;
    }
  }
  return false;
}",0.1224066390041493
158565,"@Override public boolean apply(Game game,Ability source){
  Permanent permanent=game.getPermanentEntering(source.getSourceId());
  int zccDiff=0;
  if (permanent == null) {
    permanent=game.getPermanentOrLKIBattlefield(source.getSourceId());
    zccDiff=-1;
  }
  if (permanent != null) {
    Spell spell=game.getStack().getSpell(source.getSourceId());
    if (spell == null || spell.getZoneChangeCounter(game) != permanent.getZoneChangeCounter(game) + zccDiff) {
      if (game.getLastKnownInformation(source.getSourceId(),Zone.STACK,permanent.getZoneChangeCounter(game) + zccDiff) == null) {
        return false;
      }
    }
    CastFromHandWatcher watcher=(CastFromHandWatcher)game.getState().getWatchers().get(CastFromHandWatcher.class.getName(),source.getSourceId());
    if (watcher != null && watcher.spellWasCastFromHand(source.getSourceId())) {
      return true;
    }
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Permanent permanent=game.getPermanentEntering(source.getSourceId());
  int zccDiff=0;
  if (permanent == null) {
    permanent=game.getPermanentOrLKIBattlefield(source.getSourceId());
    zccDiff=-1;
  }
  if (permanent != null) {
    Spell spell=game.getStack().getSpell(source.getSourceId());
    if (spell == null || spell.getZoneChangeCounter(game) != permanent.getZoneChangeCounter(game) + zccDiff) {
      if (game.getLastKnownInformation(source.getSourceId(),Zone.STACK,permanent.getZoneChangeCounter(game) + zccDiff) == null) {
        return false;
      }
    }
    CastFromHandWatcher watcher=(CastFromHandWatcher)game.getState().getWatchers().get(CastFromHandWatcher.class.getName());
    if (watcher != null && watcher.spellWasCastFromHand(source.getSourceId())) {
      return true;
    }
  }
  return false;
}",0.9882615986584684
158566,"@Override public boolean apply(Game game,Ability source){
  Permanent permanent=game.getPermanent(source.getSourceId());
  if (permanent == null) {
    permanent=game.getPermanentEntering(source.getSourceId());
  }
  if (permanent != null) {
    Watcher watcher=game.getState().getWatchers().get(""String_Node_Str"",source.getSourceId());
    if (watcher != null && watcher.conditionMet()) {
      return true;
    }
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Permanent permanent=game.getPermanentEntering(source.getSourceId());
  int zccDiff=0;
  if (permanent == null) {
    permanent=game.getPermanentOrLKIBattlefield(source.getSourceId());
    zccDiff=-1;
  }
  if (permanent != null) {
    Spell spell=game.getStack().getSpell(source.getSourceId());
    if (spell == null || spell.getZoneChangeCounter(game) != permanent.getZoneChangeCounter(game) + zccDiff) {
      if (game.getLastKnownInformation(source.getSourceId(),Zone.STACK,permanent.getZoneChangeCounter(game) + zccDiff) == null) {
        return false;
      }
    }
    Watcher watcher=game.getState().getWatchers().get(""String_Node_Str"",source.getSourceId());
    if (watcher != null && watcher.conditionMet()) {
      return true;
    }
  }
  return false;
}",0.6782884310618067
158567,"private static ArrayList<CardDownloadData> getNeededCards(List<CardInfo> allCards){
  ArrayList<CardDownloadData> cardsToDownload=new ArrayList<>();
  ArrayList<CardDownloadData> allCardsUrls=new ArrayList<>();
  HashSet<String> ignoreUrls=SettingsManager.getIntance().getIgnoreUrls();
  Set<String> type2SetsFilter=new HashSet<>();
  List<String> constructedFormats=ConstructedFormats.getSetsByFormat(ConstructedFormats.STANDARD);
  if (constructedFormats != null && !constructedFormats.isEmpty()) {
    type2SetsFilter.addAll(constructedFormats);
  }
 else {
    logger.warn(""String_Node_Str"");
  }
  int numberCardImages=allCards.size();
  try {
    offlineMode=true;
    for (    CardInfo card : allCards) {
      if (card.getCardNumber() > 0 && !card.getSetCode().isEmpty() && !ignoreUrls.contains(card.getSetCode())) {
        String cardName=card.getName();
        CardDownloadData url=new CardDownloadData(cardName,card.getSetCode(),card.getCardNumber(),card.usesVariousArt(),0,""String_Node_Str"",false,card.isDoubleFaced(),card.isNightCard());
        if (url.getUsesVariousArt()) {
          url.setDownloadName(createDownloadName(card));
        }
        url.setFlipCard(card.isFlipCard());
        url.setSplitCard(card.isSplitCard());
        if (type2SetsFilter.contains(card.getSetCode())) {
          url.setType2(true);
        }
        allCardsUrls.add(url);
        if (card.isDoubleFaced()) {
          if (card.getSecondSideName() == null || card.getSecondSideName().trim().isEmpty()) {
            throw new IllegalStateException(""String_Node_Str"");
          }
          url=new CardDownloadData(card.getSecondSideName(),card.getSetCode(),card.getCardNumber(),card.usesVariousArt(),0,""String_Node_Str"",false,card.isDoubleFaced(),true);
          allCardsUrls.add(url);
        }
        if (card.isFlipCard()) {
          if (card.getFlipCardName() == null || card.getFlipCardName().trim().isEmpty()) {
            throw new IllegalStateException(""String_Node_Str"");
          }
          url=new CardDownloadData(card.getFlipCardName(),card.getSetCode(),card.getCardNumber(),card.usesVariousArt(),0,""String_Node_Str"",false,card.isDoubleFaced(),card.isNightCard());
          url.setFlipCard(true);
          url.setFlippedSide(true);
          allCardsUrls.add(url);
        }
      }
 else {
        if (card.getCardNumber() < 1) {
          System.err.println(""String_Node_Str"");
          logger.error(""String_Node_Str"" + card);
        }
 else         if (card.getSetCode().isEmpty()) {
          System.err.println(""String_Node_Str"");
          logger.error(""String_Node_Str"" + card);
        }
      }
    }
    allCardsUrls.addAll(getTokenCardUrls());
  }
 catch (  Exception e) {
    logger.error(e);
  }
  int numberTokenImages=allCardsUrls.size() - numberCardImages;
  TFile file;
  for (  CardDownloadData card : allCardsUrls) {
    file=new TFile(CardImageUtils.generateImagePath(card));
    if (!file.exists()) {
      cardsToDownload.add(card);
    }
  }
  logger.info(""String_Node_Str"" + numberCardImages + ""String_Node_Str""+ numberTokenImages+ ""String_Node_Str""+ cardsToDownload.size());
  if (logger.isDebugEnabled()) {
    for (    CardDownloadData card : cardsToDownload) {
      if (card.isToken()) {
        logger.debug(""String_Node_Str"" + card.getName() + ""String_Node_Str"");
      }
 else {
        try {
          logger.debug(""String_Node_Str"" + card.getName() + ""String_Node_Str""+ card.getSet()+ ""String_Node_Str"");
        }
 catch (        Exception e) {
          logger.error(e);
        }
      }
    }
  }
  return cardsToDownload;
}","private static ArrayList<CardDownloadData> getNeededCards(List<CardInfo> allCards){
  ArrayList<CardDownloadData> cardsToDownload=new ArrayList<>();
  ArrayList<CardDownloadData> allCardsUrls=new ArrayList<>();
  HashSet<String> ignoreUrls=SettingsManager.getIntance().getIgnoreUrls();
  Set<String> type2SetsFilter=new HashSet<>();
  List<String> constructedFormats=ConstructedFormats.getSetsByFormat(ConstructedFormats.STANDARD);
  if (constructedFormats != null && !constructedFormats.isEmpty()) {
    type2SetsFilter.addAll(constructedFormats);
  }
 else {
    logger.warn(""String_Node_Str"");
  }
  int numberCardImages=allCards.size();
  try {
    offlineMode=true;
    for (    CardInfo card : allCards) {
      if (card.getCardNumber() > 0 && !card.getSetCode().isEmpty() && !ignoreUrls.contains(card.getSetCode())) {
        String cardName=card.getName();
        CardDownloadData url=new CardDownloadData(cardName,card.getSetCode(),card.getCardNumber(),card.usesVariousArt(),0,""String_Node_Str"",false,card.isDoubleFaced(),card.isNightCard());
        if (url.getUsesVariousArt()) {
          url.setDownloadName(createDownloadName(card));
        }
        url.setFlipCard(card.isFlipCard());
        url.setSplitCard(card.isSplitCard());
        if (type2SetsFilter.contains(card.getSetCode())) {
          url.setType2(true);
        }
        allCardsUrls.add(url);
        if (card.isDoubleFaced()) {
          if (card.getSecondSideName() == null || card.getSecondSideName().trim().isEmpty()) {
            throw new IllegalStateException(""String_Node_Str"");
          }
          url=new CardDownloadData(card.getSecondSideName(),card.getSetCode(),card.getCardNumber(),card.usesVariousArt(),0,""String_Node_Str"",false,card.isDoubleFaced(),true);
          allCardsUrls.add(url);
        }
        if (card.isFlipCard()) {
          if (card.getFlipCardName() == null || card.getFlipCardName().trim().isEmpty()) {
            throw new IllegalStateException(""String_Node_Str"");
          }
          url=new CardDownloadData(card.getFlipCardName(),card.getSetCode(),card.getCardNumber(),card.usesVariousArt(),0,""String_Node_Str"",false,card.isDoubleFaced(),card.isNightCard());
          url.setFlipCard(true);
          url.setFlippedSide(true);
          allCardsUrls.add(url);
        }
      }
 else       if (card.getCardNumber() < 1) {
        System.err.println(""String_Node_Str"");
        logger.error(""String_Node_Str"" + card);
      }
 else       if (card.getSetCode().isEmpty()) {
        System.err.println(""String_Node_Str"");
        logger.error(""String_Node_Str"" + card);
      }
    }
    allCardsUrls.addAll(getTokenCardUrls());
  }
 catch (  Exception e) {
    logger.error(e);
  }
  int numberTokenImages=allCardsUrls.size() - numberCardImages;
  TFile file;
  for (  CardDownloadData card : allCardsUrls) {
    file=new TFile(CardImageUtils.generateImagePath(card));
    if (!file.exists()) {
      cardsToDownload.add(card);
    }
  }
  logger.info(""String_Node_Str"" + numberCardImages + ""String_Node_Str""+ numberTokenImages+ ""String_Node_Str""+ cardsToDownload.size());
  if (logger.isDebugEnabled()) {
    for (    CardDownloadData card : cardsToDownload) {
      if (card.isToken()) {
        logger.debug(""String_Node_Str"" + card.getName() + ""String_Node_Str"");
      }
 else {
        try {
          logger.debug(""String_Node_Str"" + card.getName() + ""String_Node_Str""+ card.getSet()+ ""String_Node_Str"");
        }
 catch (        Exception e) {
          logger.error(e);
        }
      }
    }
  }
  return cardsToDownload;
}",0.9511036602402906
158568,"@Override public boolean apply(Layer layer,SubLayer sublayer,Ability source,Game game){
  Permanent enchantment=game.getPermanent(source.getSourceId());
  if (enchantment != null && enchantment.getAttachedTo() != null) {
    Permanent permanent=game.getPermanent(enchantment.getAttachedTo());
    if (permanent != null) {
switch (layer) {
case AbilityAddingRemovingEffects_6:
        permanent.removeAllAbilities(source.getSourceId(),game);
      for (      String landType : landTypes) {
switch (landType) {
case ""String_Node_Str"":
          permanent.addAbility(new BlackManaAbility(),source.getSourceId(),game);
        break;
case ""String_Node_Str"":
      permanent.addAbility(new RedManaAbility(),source.getSourceId(),game);
    break;
case ""String_Node_Str"":
  permanent.addAbility(new GreenManaAbility(),source.getSourceId(),game);
break;
case ""String_Node_Str"":
permanent.addAbility(new BlueManaAbility(),source.getSourceId(),game);
break;
case ""String_Node_Str"":
permanent.addAbility(new WhiteManaAbility(),source.getSourceId(),game);
break;
}
}
break;
case TypeChangingEffects_4:
permanent.getSubtype().removeAll(allLandTypes);
permanent.getSubtype().addAll(landTypes);
break;
}
return true;
}
}
return false;
}","@Override public boolean apply(Layer layer,SubLayer sublayer,Ability source,Game game){
  Permanent enchantment=game.getPermanent(source.getSourceId());
  if (enchantment != null && enchantment.getAttachedTo() != null) {
    Permanent permanent=game.getPermanent(enchantment.getAttachedTo());
    if (permanent != null) {
switch (layer) {
case AbilityAddingRemovingEffects_6:
        permanent.removeAllAbilities(source.getSourceId(),game);
      for (      String landType : landTypes) {
switch (landType) {
case ""String_Node_Str"":
          if (permanent.getSubtype().contains(""String_Node_Str"")) {
            permanent.addAbility(new BlackManaAbility(),source.getSourceId(),game);
          }
        break;
case ""String_Node_Str"":
      if (permanent.getSubtype().contains(""String_Node_Str"")) {
        permanent.addAbility(new RedManaAbility(),source.getSourceId(),game);
      }
    break;
case ""String_Node_Str"":
  if (permanent.getSubtype().contains(""String_Node_Str"")) {
    permanent.addAbility(new GreenManaAbility(),source.getSourceId(),game);
  }
break;
case ""String_Node_Str"":
if (permanent.getSubtype().contains(""String_Node_Str"")) {
permanent.addAbility(new BlueManaAbility(),source.getSourceId(),game);
}
break;
case ""String_Node_Str"":
if (permanent.getSubtype().contains(""String_Node_Str"")) {
permanent.addAbility(new WhiteManaAbility(),source.getSourceId(),game);
}
break;
}
}
break;
case TypeChangingEffects_4:
permanent.getSubtype().removeAll(allLandTypes);
permanent.getSubtype().addAll(landTypes);
break;
}
return true;
}
}
return false;
}",0.8771551724137931
158569,"public List<UUID> getCardList(){
  return new ArrayList(library);
}","public List<UUID> getCardList(){
  return new ArrayList<>(library);
}",0.9852941176470588
158570,"@Test public void testWithSurge(){
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"",1);
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"",5);
  addCard(Zone.HAND,playerA,""String_Node_Str"");
  addCard(Zone.HAND,playerA,""String_Node_Str"");
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"");
  addCard(Zone.BATTLEFIELD,playerB,""String_Node_Str"");
  castSpell(1,PhaseStep.PRECOMBAT_MAIN,playerA,""String_Node_Str"",playerB);
  castSpell(1,PhaseStep.PRECOMBAT_MAIN,playerA,""String_Node_Str"");
  setStopAt(1,PhaseStep.BEGIN_COMBAT);
  execute();
  assertGraveyardCount(playerA,""String_Node_Str"",1);
  assertGraveyardCount(playerA,""String_Node_Str"",1);
  assertPermanentCount(playerA,""String_Node_Str"",1);
  assertHandCount(playerA,""String_Node_Str"",1);
  assertHandCount(playerB,""String_Node_Str"",1);
  assertPermanentCount(playerA,7);
  assertLife(playerB,17);
}","@Test public void testWithSurge(){
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"",1);
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"",5);
  addCard(Zone.HAND,playerA,""String_Node_Str"");
  addCard(Zone.HAND,playerA,""String_Node_Str"");
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"");
  addCard(Zone.HAND,playerB,""String_Node_Str"");
  addCard(Zone.BATTLEFIELD,playerB,""String_Node_Str"",3);
  addCard(Zone.BATTLEFIELD,playerB,""String_Node_Str"");
  castSpell(1,PhaseStep.PRECOMBAT_MAIN,playerA,""String_Node_Str"",playerB);
  castSpell(1,PhaseStep.PRECOMBAT_MAIN,playerB,""String_Node_Str"",""String_Node_Str"");
  castSpell(1,PhaseStep.PRECOMBAT_MAIN,playerA,""String_Node_Str"");
  setStopAt(1,PhaseStep.BEGIN_COMBAT);
  execute();
  assertGraveyardCount(playerA,""String_Node_Str"",1);
  assertGraveyardCount(playerB,""String_Node_Str"",1);
  assertGraveyardCount(playerA,""String_Node_Str"",1);
  assertPermanentCount(playerA,""String_Node_Str"",1);
  assertPermanentCount(playerB,""String_Node_Str"",0);
  assertHandCount(playerA,""String_Node_Str"",1);
  assertHandCount(playerB,""String_Node_Str"",1);
  assertPermanentCount(playerA,7);
  assertLife(playerB,17);
}",0.8205128205128205
158571,"@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller != null) {
    Cards cardsToHand=new CardsImpl();
    for (    Permanent permanent : game.getBattlefield().getActivePermanents(filter,source.getControllerId(),source.getSourceId(),game)) {
      cardsToHand.add(permanent);
    }
    controller.moveCards(cardsToHand,Zone.HAND,source,game);
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller != null) {
    Set<Card> permanentsToHand=new HashSet<>();
    for (    Permanent permanent : game.getBattlefield().getActivePermanents(filter,source.getControllerId(),source.getSourceId(),game)) {
      permanentsToHand.add(permanent);
    }
    controller.moveCards(permanentsToHand,Zone.HAND,source,game);
    return true;
  }
  return false;
}",0.512118018967334
158572,"@Override public boolean checkTrigger(GameEvent event,Game game){
  StackObject item=game.getState().getStack().getFirst();
  if (item instanceof StackAbility && ((StackAbility)item).getStackAbility() instanceof CyclingAbility) {
    return true;
  }
  return false;
}","@Override public boolean checkTrigger(GameEvent event,Game game){
  if (game.getState().getStack().isEmpty()) {
    return false;
  }
  StackObject item=game.getState().getStack().getFirst();
  if (item instanceof StackAbility && ((StackAbility)item).getStackAbility() instanceof CyclingAbility) {
    return true;
  }
  return false;
}",0.8874172185430463
158573,"public final void init(PlayerView player,BigCard bigCard,UUID gameId,int priorityTime){
  this.playerPanel.init(gameId,player.getPlayerId(),bigCard,priorityTime);
  this.battlefieldPanel.init(gameId,bigCard);
  this.gameId=gameId;
  if (MageFrame.getSession().isTestMode()) {
    this.playerId=player.getPlayerId();
    this.btnCheat.setVisible(true);
  }
 else {
    this.btnCheat.setVisible(false);
  }
}","public final void init(PlayerView player,BigCard bigCard,UUID gameId,int priorityTime){
  this.playerPanel.init(gameId,player.getPlayerId(),bigCard,priorityTime);
  this.battlefieldPanel.init(gameId,bigCard);
  this.gameId=gameId;
  this.playerId=player.getPlayerId();
  if (MageFrame.getSession().isTestMode()) {
    this.btnCheat.setVisible(true);
  }
 else {
    this.btnCheat.setVisible(false);
  }
}",0.9037037037037036
158574,"@Override public boolean checkTrigger(GameEvent event,Game game){
  UUID targetId=event.getTargetId();
  Permanent permanent=game.getPermanent(targetId);
  if (permanent != null && filter.match(permanent,getSourceId(),getControllerId(),game)) {
    if (!setTargetPointer.equals(SetTargetPointer.NONE)) {
      for (      Effect effect : this.getEffects()) {
switch (setTargetPointer) {
case PERMANENT:
          effect.setTargetPointer(new FixedTarget(event.getTargetId()));
        break;
case PLAYER:
      effect.setTargetPointer(new FixedTarget(permanent.getControllerId()));
    break;
}
}
}
return true;
}
return false;
}","@Override public boolean checkTrigger(GameEvent event,Game game){
  UUID targetId=event.getTargetId();
  Permanent permanent=game.getPermanent(targetId);
  if (permanent != null && filter.match(permanent,getSourceId(),getControllerId(),game)) {
    if (!setTargetPointer.equals(SetTargetPointer.NONE)) {
      for (      Effect effect : this.getEffects()) {
switch (setTargetPointer) {
case PERMANENT:
          effect.setTargetPointer(new FixedTarget(permanent,game));
        break;
case PLAYER:
      effect.setTargetPointer(new FixedTarget(permanent.getControllerId()));
    break;
}
}
}
return true;
}
return false;
}",0.9735788630904724
158575,"private void btnSaveActionPerformed(java.awt.event.ActionEvent evt){
  String lastFolder=MageFrame.getPreferences().get(""String_Node_Str"",""String_Node_Str"");
  if (!lastFolder.isEmpty()) {
    fcSelectDeck.setCurrentDirectory(new File(lastFolder));
  }
  deck.setName(this.txtDeckName.getText());
  int ret=fcSelectDeck.showSaveDialog(this);
  if (ret == JFileChooser.APPROVE_OPTION) {
    File file=fcSelectDeck.getSelectedFile();
    try {
      String fileName=file.getPath();
      if (!fileName.endsWith(""String_Node_Str"")) {
        fileName+=""String_Node_Str"";
      }
      setCursor(new Cursor(Cursor.WAIT_CURSOR));
      Sets.saveDeck(fileName,deck.getDeckCardLists());
    }
 catch (    Exception ex) {
      LOGGER.fatal(ex);
    }
 finally {
      setCursor(new Cursor(Cursor.DEFAULT_CURSOR));
    }
    try {
      MageFrame.getPreferences().put(""String_Node_Str"",file.getCanonicalPath());
    }
 catch (    IOException ex) {
    }
  }
}","private void btnSaveActionPerformed(java.awt.event.ActionEvent evt){
  String lastFolder=MageFrame.getPreferences().get(""String_Node_Str"",""String_Node_Str"");
  if (!lastFolder.isEmpty()) {
    fcSelectDeck.setCurrentDirectory(new File(lastFolder));
  }
  deck.setName(this.txtDeckName.getText());
  int ret=fcSelectDeck.showSaveDialog(this);
  if (ret == JFileChooser.APPROVE_OPTION) {
    File file=fcSelectDeck.getSelectedFile();
    try {
      String fileName=file.getPath();
      if (!fileName.endsWith(""String_Node_Str"")) {
        fileName+=""String_Node_Str"";
      }
      setCursor(new Cursor(Cursor.WAIT_CURSOR));
      Sets.saveDeck(fileName,deck.getDeckCardLists());
    }
 catch (    Exception ex) {
      logger.fatal(ex);
    }
 finally {
      setCursor(new Cursor(Cursor.DEFAULT_CURSOR));
    }
    try {
      MageFrame.getPreferences().put(""String_Node_Str"",file.getCanonicalPath());
    }
 catch (    IOException ex) {
    }
  }
}",0.9936908517350158
158576,"@Override protected void done(){
  try {
    get();
  }
 catch (  InterruptedException|ExecutionException ex) {
    LOGGER.fatal(""String_Node_Str"",ex);
  }
catch (  CancellationException ex) {
  }
}","@Override protected void done(){
  try {
    get();
  }
 catch (  InterruptedException|ExecutionException ex) {
    logger.fatal(""String_Node_Str"",ex);
  }
catch (  CancellationException ex) {
  }
}",0.9696969696969696
158577,"private void btnLoadActionPerformed(java.awt.event.ActionEvent evt){
  String lastFolder=MageFrame.getPreferences().get(""String_Node_Str"",""String_Node_Str"");
  if (!lastFolder.isEmpty()) {
    fcSelectDeck.setCurrentDirectory(new File(lastFolder));
  }
  int ret=fcSelectDeck.showOpenDialog(this);
  if (ret == JFileChooser.APPROVE_OPTION) {
    File file=fcSelectDeck.getSelectedFile();
    try {
      setCursor(new Cursor(Cursor.WAIT_CURSOR));
      deck=Deck.load(DeckImporterUtil.importDeck(file.getPath()),true,true);
    }
 catch (    GameException ex) {
      JOptionPane.showMessageDialog(MageFrame.getDesktop(),ex.getMessage(),""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
    }
catch (    Exception ex) {
      LOGGER.fatal(ex);
    }
 finally {
      setCursor(new Cursor(Cursor.DEFAULT_CURSOR));
    }
    refreshDeck();
    try {
      if (file != null) {
        MageFrame.getPreferences().put(""String_Node_Str"",file.getCanonicalPath());
      }
    }
 catch (    IOException ex) {
    }
  }
  fcSelectDeck.setSelectedFile(null);
}","private void btnLoadActionPerformed(java.awt.event.ActionEvent evt){
  String lastFolder=MageFrame.getPreferences().get(""String_Node_Str"",""String_Node_Str"");
  if (!lastFolder.isEmpty()) {
    fcSelectDeck.setCurrentDirectory(new File(lastFolder));
  }
  int ret=fcSelectDeck.showOpenDialog(this);
  if (ret == JFileChooser.APPROVE_OPTION) {
    File file=fcSelectDeck.getSelectedFile();
    try {
      setCursor(new Cursor(Cursor.WAIT_CURSOR));
      deck=Deck.load(DeckImporterUtil.importDeck(file.getPath()),true,true);
    }
 catch (    GameException ex) {
      JOptionPane.showMessageDialog(MageFrame.getDesktop(),ex.getMessage(),""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
    }
catch (    Exception ex) {
      logger.fatal(ex);
    }
 finally {
      setCursor(new Cursor(Cursor.DEFAULT_CURSOR));
    }
    refreshDeck();
    try {
      if (file != null) {
        MageFrame.getPreferences().put(""String_Node_Str"",file.getCanonicalPath());
      }
    }
 catch (    IOException ex) {
    }
  }
  fcSelectDeck.setSelectedFile(null);
}",0.994263862332696
158578,"private void btnImportActionPerformed(java.awt.event.ActionEvent evt){
  String lastFolder=MageFrame.getPreferences().get(""String_Node_Str"",""String_Node_Str"");
  if (!lastFolder.isEmpty()) {
    fcImportDeck.setCurrentDirectory(new File(lastFolder));
  }
  int ret=fcImportDeck.showOpenDialog(this);
  if (ret == JFileChooser.APPROVE_OPTION) {
    File file=fcImportDeck.getSelectedFile();
    try {
      setCursor(new Cursor(Cursor.WAIT_CURSOR));
      DeckImporter importer=DeckImporterUtil.getDeckImporter(file.getPath());
      if (importer != null) {
        deck=Deck.load(importer.importDeck(file.getPath()));
        String errors=importer.getErrors();
        if (!errors.isEmpty()) {
          JOptionPane.showMessageDialog(MageFrame.getDesktop(),errors,""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
        }
      }
 else {
        JOptionPane.showMessageDialog(MageFrame.getDesktop(),""String_Node_Str"",""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
      }
    }
 catch (    Exception ex) {
      LOGGER.fatal(ex);
    }
 finally {
      setCursor(new Cursor(Cursor.DEFAULT_CURSOR));
    }
    refreshDeck();
    try {
      if (file != null) {
        MageFrame.getPreferences().put(""String_Node_Str"",file.getCanonicalPath());
      }
    }
 catch (    IOException ex) {
    }
  }
  fcImportDeck.setSelectedFile(null);
}","private void btnImportActionPerformed(java.awt.event.ActionEvent evt){
  String lastFolder=MageFrame.getPreferences().get(""String_Node_Str"",""String_Node_Str"");
  if (!lastFolder.isEmpty()) {
    fcImportDeck.setCurrentDirectory(new File(lastFolder));
  }
  int ret=fcImportDeck.showOpenDialog(this);
  if (ret == JFileChooser.APPROVE_OPTION) {
    File file=fcImportDeck.getSelectedFile();
    try {
      setCursor(new Cursor(Cursor.WAIT_CURSOR));
      DeckImporter importer=DeckImporterUtil.getDeckImporter(file.getPath());
      if (importer != null) {
        deck=Deck.load(importer.importDeck(file.getPath()));
        String errors=importer.getErrors();
        if (!errors.isEmpty()) {
          JOptionPane.showMessageDialog(MageFrame.getDesktop(),errors,""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
        }
      }
 else {
        JOptionPane.showMessageDialog(MageFrame.getDesktop(),""String_Node_Str"",""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
      }
    }
 catch (    Exception ex) {
      logger.fatal(ex);
    }
 finally {
      setCursor(new Cursor(Cursor.DEFAULT_CURSOR));
    }
    refreshDeck();
    try {
      if (file != null) {
        MageFrame.getPreferences().put(""String_Node_Str"",file.getCanonicalPath());
      }
    }
 catch (    IOException ex) {
    }
  }
  fcImportDeck.setSelectedFile(null);
}",0.9955022488755624
158579,"@Override protected void done(){
  try {
    get();
  }
 catch (  InterruptedException|ExecutionException ex) {
    LOGGER.fatal(""String_Node_Str"",ex);
  }
catch (  CancellationException ex) {
  }
}","@Override protected void done(){
  try {
    get();
  }
 catch (  InterruptedException|ExecutionException ex) {
    logger.fatal(""String_Node_Str"",ex);
  }
catch (  CancellationException ex) {
  }
}",0.9696969696969696
158580,"@Test public void testMageRingNetwork2(){
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"",1);
  addCounters(1,PhaseStep.UPKEEP,playerA,""String_Node_Str"",CounterType.STORAGE,4);
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"",1);
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"",1);
  setStopAt(1,PhaseStep.DRAW);
  execute();
  ManaOptions manaOptions=playerA.getAvailableManaTest(currentGame);
  Assert.assertEquals(""String_Node_Str"",2,manaOptions.size());
  Assert.assertEquals(""String_Node_Str"",getManaOption(0,manaOptions));
  Assert.assertEquals(""String_Node_Str"",getManaOption(1,manaOptions));
}","@Test public void testMageRingNetwork2(){
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"",1);
  addCounters(1,PhaseStep.UPKEEP,playerA,""String_Node_Str"",CounterType.STORAGE,4);
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"",1);
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"",1);
  setStopAt(1,PhaseStep.DRAW);
  execute();
  ManaOptions manaOptions=playerA.getAvailableManaTest(currentGame);
  Assert.assertEquals(""String_Node_Str"",1,manaOptions.size());
  Assert.assertEquals(""String_Node_Str"",getManaOption(0,manaOptions));
}",0.9370146678170836
158581,"/** 
 * Subtracts the passed in mana values from this instance. The difference between this and   {@code subtract()} is that if we do not have theavailable generic mana to pay, we take mana from our colored mana pools.
 * @param mana mana values to subtract
 * @throws ArithmeticException thrown if there is not enough availablecolored mana to pay the generic cost
 */
public void subtractCost(final Mana mana) throws ArithmeticException {
  red-=mana.red;
  green-=mana.green;
  blue-=mana.blue;
  white-=mana.white;
  black-=mana.black;
  any-=mana.any;
  generic-=mana.generic;
  colorless-=mana.colorless;
  while (generic < 0) {
    int oldColorless=generic;
    if (red > 0) {
      red--;
      generic++;
      continue;
    }
    if (green > 0) {
      green--;
      generic++;
      continue;
    }
    if (blue > 0) {
      blue--;
      generic++;
      continue;
    }
    if (white > 0) {
      white--;
      generic++;
      continue;
    }
    if (black > 0) {
      black--;
      generic++;
    }
    if (colorless > 0) {
      colorless--;
      generic++;
    }
    if (any > 0) {
      any--;
      generic++;
    }
    if (oldColorless == generic) {
      throw new ArithmeticException(""String_Node_Str"");
    }
  }
}","/** 
 * Subtracts the passed in mana values from this instance. The difference between this and   {@code subtract()} is that if we do not have theavailable generic mana to pay, we take mana from our colored mana pools.
 * @param mana mana values to subtract
 * @throws ArithmeticException thrown if there is not enough availablecolored mana to pay the generic cost
 */
public void subtractCost(final Mana mana) throws ArithmeticException {
  red-=mana.red;
  green-=mana.green;
  blue-=mana.blue;
  white-=mana.white;
  black-=mana.black;
  any-=mana.any;
  generic-=mana.generic;
  colorless-=mana.colorless;
  while (generic < 0) {
    int oldColorless=generic;
    if (red > 0) {
      red--;
      generic++;
      continue;
    }
    if (green > 0) {
      green--;
      generic++;
      continue;
    }
    if (blue > 0) {
      blue--;
      generic++;
      continue;
    }
    if (white > 0) {
      white--;
      generic++;
      continue;
    }
    if (black > 0) {
      black--;
      generic++;
      continue;
    }
    if (colorless > 0) {
      colorless--;
      generic++;
      continue;
    }
    if (any > 0) {
      any--;
      generic++;
      continue;
    }
    if (oldColorless == generic) {
      throw new ArithmeticException(""String_Node_Str"");
    }
  }
}",0.9810276679841896
158582,"@Override public boolean activate(Game game,boolean noMana){
  Player controller=game.getPlayer(this.getControllerId());
  if (controller == null) {
    return false;
  }
  game.applyEffects();
  if (!getModes().choose(game,this)) {
    return false;
  }
  if (controller.isTestMode()) {
    if (!controller.addTargets(this,game)) {
      return false;
    }
  }
  getSourceObject(game);
  if (this.abilityType.equals(AbilityType.SPELL)) {
    game.getContinuousEffects().applySpliceEffects(this,game);
  }
  if (sourceObject != null) {
    sourceObject.adjustChoices(this,game);
  }
  for (  Mode mode : this.getModes().getSelectedModes()) {
    if (mode.getChoices().size() > 0 && mode.getChoices().choose(game,this) == false) {
      logger.debug(""String_Node_Str"");
      return false;
    }
  }
  if (noMana) {
    if (this.getManaCostsToPay().getVariableCosts().size() > 0) {
      int xValue=this.getManaCostsToPay().getX();
      this.getManaCostsToPay().clear();
      VariableManaCost xCosts=new VariableManaCost();
      xCosts.setAmount(xValue);
      this.getManaCostsToPay().add(xCosts);
    }
 else {
      this.getManaCostsToPay().clear();
    }
  }
  if (!activateAlternateOrAdditionalCosts(sourceObject,noMana,controller,game)) {
    if (getAbilityType().equals(AbilityType.SPELL) && ((SpellAbility)this).getSpellAbilityType().equals(SpellAbilityType.FACE_DOWN_CREATURE)) {
      return false;
    }
  }
  VariableManaCost variableManaCost=handleManaXCosts(game,noMana,controller);
  String announceString=handleOtherXCosts(game,controller);
  if (game.replaceEvent(GameEvent.getEvent(GameEvent.EventType.CAST_SPELL_LATE,getId(),getSourceId(),getControllerId()),this)) {
    return false;
  }
  for (  Mode mode : this.getModes().getSelectedModes()) {
    this.getModes().setActiveMode(mode);
    if (sourceObject != null && !this.getAbilityType().equals(AbilityType.TRIGGERED)) {
      sourceObject.adjustTargets(this,game);
    }
    if (mode.getTargets().size() > 0 && mode.getTargets().chooseTargets(getEffects().get(0).getOutcome(),this.controllerId,this,noMana,game) == false) {
      if ((variableManaCost != null || announceString != null) && !game.isSimulation()) {
        game.informPlayer(controller,(sourceObject != null ? sourceObject.getIdName() : ""String_Node_Str"") + ""String_Node_Str"");
      }
      return false;
    }
  }
  for (  Cost cost : optionalCosts) {
    if (cost instanceof ManaCost) {
      cost.clearPaid();
      if (controller.chooseUse(Outcome.Benefit,""String_Node_Str"" + cost.getText() + ""String_Node_Str"",this,game)) {
        manaCostsToPay.add((ManaCost)cost);
      }
    }
  }
  if (sourceObject != null) {
    sourceObject.adjustCosts(this,game);
    if (sourceObject instanceof Card) {
      for (      Ability ability : ((Card)sourceObject).getAbilities(game)) {
        if (ability instanceof AdjustingSourceCosts) {
          ((AdjustingSourceCosts)ability).adjustCosts(this,game);
        }
      }
    }
 else {
      for (      Ability ability : sourceObject.getAbilities()) {
        if (ability instanceof AdjustingSourceCosts) {
          ((AdjustingSourceCosts)ability).adjustCosts(this,game);
        }
      }
    }
  }
  if (this instanceof ManaAbility && !costs.pay(this,game,sourceId,controllerId,noMana,null)) {
    logger.debug(""String_Node_Str"");
    return false;
  }
  if (costModificationActive) {
    game.getContinuousEffects().costModification(this,game);
  }
 else {
    costModificationActive=true;
  }
  UUID activatorId=controllerId;
  if ((this instanceof ActivatedAbilityImpl) && ((ActivatedAbilityImpl)this).getActivatorId() != null) {
    activatorId=((ActivatedAbilityImpl)this).getActivatorId();
  }
  if (!useAlternativeCost(game)) {
    if (!manaCostsToPay.pay(this,game,sourceId,activatorId,false,null)) {
      return false;
    }
  }
  if (!costs.pay(this,game,sourceId,activatorId,noMana,null)) {
    logger.debug(""String_Node_Str"");
    return false;
  }
  if (!game.isSimulation()) {
    if (announceString != null) {
      game.informPlayers(announceString);
    }
    if (variableManaCost != null) {
      int xValue=getManaCostsToPay().getX();
      game.informPlayers(controller.getLogName() + ""String_Node_Str"" + xValue+ ""String_Node_Str""+ variableManaCost.getText());
    }
  }
  activated=true;
  if (this.getAbilityType().equals(AbilityType.MANA)) {
    for (    Cost cost : costs) {
      if (cost instanceof TapSourceCost) {
        Mana mana=null;
        Effect effect=getEffects().get(0);
        if (effect instanceof BasicManaEffect) {
          mana=((BasicManaEffect)effect).getMana(game,this);
        }
 else         if (effect instanceof DynamicManaEffect) {
          mana=((DynamicManaEffect)effect).getMana(game,this);
        }
        if (mana != null && mana.getAny() == 0) {
          ManaEvent event=new ManaEvent(GameEvent.EventType.TAPPED_FOR_MANA,sourceId,sourceId,controllerId,mana);
          if (!game.replaceEvent(event)) {
            game.fireEvent(event);
          }
        }
        break;
      }
    }
  }
  return true;
}","@Override public boolean activate(Game game,boolean noMana){
  Player controller=game.getPlayer(this.getControllerId());
  if (controller == null) {
    return false;
  }
  game.applyEffects();
  if (!getModes().choose(game,this)) {
    return false;
  }
  if (controller.isTestMode()) {
    if (!controller.addTargets(this,game)) {
      return false;
    }
  }
  getSourceObject(game);
  if (this.abilityType.equals(AbilityType.SPELL)) {
    game.getContinuousEffects().applySpliceEffects(this,game);
  }
  if (sourceObject != null) {
    sourceObject.adjustChoices(this,game);
  }
  for (  Mode mode : this.getModes().getSelectedModes()) {
    if (mode.getChoices().size() > 0 && mode.getChoices().choose(game,this) == false) {
      logger.debug(""String_Node_Str"");
      return false;
    }
  }
  if (noMana) {
    if (this.getManaCostsToPay().getVariableCosts().size() > 0) {
      int xValue=this.getManaCostsToPay().getX();
      this.getManaCostsToPay().clear();
      VariableManaCost xCosts=new VariableManaCost();
      xCosts.setAmount(xValue);
      this.getManaCostsToPay().add(xCosts);
    }
 else {
      this.getManaCostsToPay().clear();
    }
  }
  if (!activateAlternateOrAdditionalCosts(sourceObject,noMana,controller,game)) {
    if (getAbilityType().equals(AbilityType.SPELL) && ((SpellAbility)this).getSpellAbilityType().equals(SpellAbilityType.FACE_DOWN_CREATURE)) {
      return false;
    }
  }
  VariableManaCost variableManaCost=handleManaXCosts(game,noMana,controller);
  String announceString=handleOtherXCosts(game,controller);
  if (game.replaceEvent(GameEvent.getEvent(GameEvent.EventType.CAST_SPELL_LATE,getId(),getSourceId(),getControllerId()),this)) {
    return false;
  }
  for (  Mode mode : this.getModes().getSelectedModes()) {
    this.getModes().setActiveMode(mode);
    if (sourceObject != null && !this.getAbilityType().equals(AbilityType.TRIGGERED)) {
      sourceObject.adjustTargets(this,game);
    }
    if (mode.getTargets().size() > 0 && mode.getTargets().chooseTargets(getEffects().get(0).getOutcome(),this.controllerId,this,noMana,game) == false) {
      if ((variableManaCost != null || announceString != null) && !game.isSimulation()) {
        game.informPlayer(controller,(sourceObject != null ? sourceObject.getIdName() : ""String_Node_Str"") + ""String_Node_Str"");
      }
      return false;
    }
  }
  for (  Cost cost : optionalCosts) {
    if (cost instanceof ManaCost) {
      cost.clearPaid();
      if (controller.chooseUse(Outcome.Benefit,""String_Node_Str"" + cost.getText() + ""String_Node_Str"",this,game)) {
        manaCostsToPay.add((ManaCost)cost);
      }
    }
  }
  if (sourceObject != null) {
    sourceObject.adjustCosts(this,game);
    if (sourceObject instanceof Card) {
      for (      Ability ability : ((Card)sourceObject).getAbilities(game)) {
        if (ability instanceof AdjustingSourceCosts) {
          ((AdjustingSourceCosts)ability).adjustCosts(this,game);
        }
      }
    }
 else {
      for (      Ability ability : sourceObject.getAbilities()) {
        if (ability instanceof AdjustingSourceCosts) {
          ((AdjustingSourceCosts)ability).adjustCosts(this,game);
        }
      }
    }
  }
  if (this instanceof ManaAbility && !costs.pay(this,game,sourceId,controllerId,noMana,null)) {
    logger.debug(""String_Node_Str"");
    return false;
  }
  if (costModificationActive) {
    game.getContinuousEffects().costModification(this,game);
  }
 else {
    costModificationActive=true;
  }
  UUID activatorId=controllerId;
  if ((this instanceof ActivatedAbilityImpl) && ((ActivatedAbilityImpl)this).getActivatorId() != null) {
    activatorId=((ActivatedAbilityImpl)this).getActivatorId();
  }
  if (!useAlternativeCost(game)) {
    if (!manaCostsToPay.pay(this,game,sourceId,activatorId,false,null)) {
      return false;
    }
  }
  if (!costs.pay(this,game,sourceId,activatorId,noMana,null)) {
    logger.debug(""String_Node_Str"");
    return false;
  }
  if (!game.isSimulation()) {
    if (announceString != null) {
      game.informPlayers(announceString);
    }
    if (variableManaCost != null) {
      int xValue=getManaCostsToPay().getX();
      game.informPlayers(controller.getLogName() + ""String_Node_Str"" + xValue+ ""String_Node_Str""+ variableManaCost.getText());
    }
  }
  activated=true;
  if (this.getAbilityType().equals(AbilityType.MANA)) {
    for (    Cost cost : costs) {
      if (cost instanceof TapSourceCost) {
        Mana mana=null;
        Effect effect=getEffects().get(0);
        if (effect instanceof DynamicManaEffect) {
          mana=((DynamicManaEffect)effect).getMana(game,this);
        }
 else         if (effect instanceof BasicManaEffect) {
          mana=((BasicManaEffect)effect).getMana(game,this);
        }
        if (mana != null && mana.getAny() == 0) {
          ManaEvent event=new ManaEvent(GameEvent.EventType.TAPPED_FOR_MANA,sourceId,sourceId,controllerId,mana);
          if (!game.replaceEvent(event)) {
            game.fireEvent(event);
          }
        }
        break;
      }
    }
  }
  return true;
}",0.9743488555643252
158583,"@Override public boolean resolve(Game game){
  if (isOptional()) {
    MageObject object=game.getObject(getSourceId());
    Player player=game.getPlayer(this.getControllerId());
    if (player != null) {
      if (!player.chooseUse(getEffects().get(0).getOutcome(),(object != null ? this.getRule(object.getLogName()) : this.getRule()),this,game)) {
        return false;
      }
    }
 else {
      return false;
    }
  }
  if (checkInterveningIfClause(game)) {
    return super.resolve(game);
  }
  return false;
}","@Override public boolean resolve(Game game){
  if (isOptional()) {
    MageObject object=game.getObject(getSourceId());
    Player player=game.getPlayer(this.getControllerId());
    if (player != null && object != null) {
      if (!player.chooseUse(getEffects().get(0).getOutcome(),(object != null ? this.getRule(object.getLogName()) : this.getRule()),this,game)) {
        return false;
      }
    }
 else {
      return false;
    }
  }
  if (checkInterveningIfClause(game)) {
    return super.resolve(game);
  }
  return false;
}",0.9828571428571428
158584,"@Override public String getRule(){
  String superRule=super.getRule(true);
  StringBuilder sb=new StringBuilder();
  if (!superRule.isEmpty()) {
    String ruleLow=superRule.toLowerCase();
    if (isOptional()) {
      if (ruleLow.startsWith(""String_Node_Str"")) {
        if (!ruleLow.startsWith(""String_Node_Str"")) {
          StringBuilder newRule=new StringBuilder(superRule);
          newRule.insert(4,""String_Node_Str"");
          superRule=newRule.toString();
        }
      }
 else {
        if (this.getTargets().isEmpty() || ruleLow.startsWith(""String_Node_Str"") || ruleLow.startsWith(""String_Node_Str"")|| ruleLow.startsWith(""String_Node_Str"")|| ruleLow.startsWith(""String_Node_Str"")|| ruleLow.startsWith(""String_Node_Str"")|| ruleLow.startsWith(""String_Node_Str"")|| ruleLow.startsWith(""String_Node_Str"")|| ruleLow.startsWith(""String_Node_Str"")) {
          sb.append(""String_Node_Str"");
        }
 else {
          if (!ruleLow.startsWith(""String_Node_Str"")) {
            sb.append(""String_Node_Str"");
          }
        }
      }
    }
    sb.append(superRule);
  }
  return sb.toString();
}","@Override public String getRule(){
  String superRule=super.getRule(true);
  StringBuilder sb=new StringBuilder();
  if (!superRule.isEmpty()) {
    String ruleLow=superRule.toLowerCase();
    if (isOptional()) {
      if (ruleLow.startsWith(""String_Node_Str"")) {
        if (!ruleLow.startsWith(""String_Node_Str"")) {
          StringBuilder newRule=new StringBuilder(superRule);
          newRule.insert(4,""String_Node_Str"");
          superRule=newRule.toString();
        }
      }
 else       if (this.getTargets().isEmpty() || ruleLow.startsWith(""String_Node_Str"") || ruleLow.startsWith(""String_Node_Str"")|| ruleLow.startsWith(""String_Node_Str"")|| ruleLow.startsWith(""String_Node_Str"")|| ruleLow.startsWith(""String_Node_Str"")|| ruleLow.startsWith(""String_Node_Str"")|| ruleLow.startsWith(""String_Node_Str"")|| ruleLow.startsWith(""String_Node_Str"")) {
        sb.append(""String_Node_Str"");
      }
 else       if (!ruleLow.startsWith(""String_Node_Str"")) {
        sb.append(""String_Node_Str"");
      }
    }
    sb.append(superRule);
  }
  return sb.toString();
}",0.8949308755760369
158585,"@Override public boolean isInUseableZone(Game game,MageObject source,GameEvent event){
  if (event != null && event.getTargetId() != null && event.getTargetId().equals(getSourceId())) {
switch (event.getType()) {
case ZONE_CHANGE:
case DESTROYED_PERMANENT:
      if (isLeavesTheBattlefieldTrigger()) {
        if (event.getType().equals(EventType.DESTROYED_PERMANENT)) {
          source=game.getLastKnownInformation(getSourceId(),Zone.BATTLEFIELD);
        }
 else {
          if (((ZoneChangeEvent)event).getTarget() != null) {
            source=((ZoneChangeEvent)event).getTarget();
          }
 else {
            source=game.getLastKnownInformation(getSourceId(),((ZoneChangeEvent)event).getZone());
          }
        }
      }
case PHASED_OUT:
case PHASED_IN:
    if (this.zone == Zone.ALL || game.getLastKnownInformation(getSourceId(),zone) != null) {
      return this.hasSourceObjectAbility(game,source,event);
    }
}
}
return super.isInUseableZone(game,source,event);
}","@Override public boolean isInUseableZone(Game game,MageObject source,GameEvent event){
  if (event != null && event.getTargetId() != null && event.getTargetId().equals(getSourceId())) {
switch (event.getType()) {
case ZONE_CHANGE:
case DESTROYED_PERMANENT:
      if (isLeavesTheBattlefieldTrigger()) {
        if (event.getType().equals(EventType.DESTROYED_PERMANENT)) {
          source=game.getLastKnownInformation(getSourceId(),Zone.BATTLEFIELD);
        }
 else         if (((ZoneChangeEvent)event).getTarget() != null) {
          source=((ZoneChangeEvent)event).getTarget();
        }
 else {
          source=game.getLastKnownInformation(getSourceId(),((ZoneChangeEvent)event).getZone());
        }
      }
case PHASED_OUT:
case PHASED_IN:
    if (this.zone == Zone.ALL || game.getLastKnownInformation(getSourceId(),zone) != null) {
      return this.hasSourceObjectAbility(game,source,event);
    }
}
}
return super.isInUseableZone(game,source,event);
}",0.9886831275720164
158586,"@Override public boolean apply(Game game,Ability source){
  Spell spell=game.getStack().getSpell(targetPointer.getFirst(game,source));
  if (spell != null) {
    Spell copy=spell.copySpell();
    copy.setControllerId(source.getControllerId());
    copy.setCopiedSpell(true);
    game.getStack().push(copy);
    copy.chooseNewTargets(game,source.getControllerId());
    Player player=game.getPlayer(source.getControllerId());
    String activateMessage=copy.getActivatedMessage(game);
    if (activateMessage.startsWith(""String_Node_Str"")) {
      activateMessage=activateMessage.substring(6);
    }
    game.informPlayers(player.getLogName() + ""String_Node_Str"" + activateMessage);
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Spell spell=game.getStack().getSpell(targetPointer.getFirst(game,source));
  if (spell != null) {
    Spell copy=spell.copySpell(source.getControllerId());
    game.getStack().push(copy);
    copy.chooseNewTargets(game,source.getControllerId());
    Player player=game.getPlayer(source.getControllerId());
    String activateMessage=copy.getActivatedMessage(game);
    if (activateMessage.startsWith(""String_Node_Str"")) {
      activateMessage=activateMessage.substring(6);
    }
    game.informPlayers(player.getLogName() + ""String_Node_Str"" + activateMessage);
    return true;
  }
  return false;
}",0.8066618392469225
158587,"@Override public boolean checkTrigger(GameEvent event,Game game){
  if (event.getPlayerId().equals(this.getControllerId())) {
    Spell spell=game.getStack().getSpell(event.getTargetId());
    if (isControlledInstantOrSorcery(spell)) {
      boolean targetsSource=false;
      for (      Mode mode : spell.getSpellAbility().getModes().getSelectedModes()) {
        for (        Target target : mode.getTargets()) {
          for (          UUID targetId : target.getTargets()) {
            if (targetId.equals(getSourceId())) {
              targetsSource=true;
            }
 else {
              return false;
            }
          }
        }
      }
      if (targetsSource) {
        this.getEffects().get(0).setTargetPointer(new FixedTarget(spell.getId()));
        return true;
      }
    }
  }
  return false;
}","@Override public boolean checkTrigger(GameEvent event,Game game){
  if (event.getPlayerId().equals(this.getControllerId())) {
    Spell spell=game.getStack().getSpell(event.getTargetId());
    if (isControlledInstantOrSorcery(spell)) {
      boolean targetsSource=false;
      for (      Ability ability : spell.getSpellAbilities()) {
        for (        Mode mode : ability.getModes().getSelectedModes()) {
          for (          Target target : mode.getTargets()) {
            if (!target.isNotTarget()) {
              for (              UUID targetId : target.getTargets()) {
                if (targetId.equals(getSourceId())) {
                  targetsSource=true;
                }
 else {
                  return false;
                }
              }
            }
          }
        }
      }
      if (targetsSource) {
        this.getEffects().get(0).setTargetPointer(new FixedTarget(spell.getId()));
        return true;
      }
    }
  }
  return false;
}",0.8795113825652415
158588,"@Override public boolean apply(Game game,Ability source){
  Spell spell=game.getStack().getSpell(targetPointer.getFirst(game,source));
  if (spell == null) {
    spell=(Spell)game.getLastKnownInformation(targetPointer.getFirst(game,source),Zone.STACK);
  }
  Player controller=game.getPlayer(source.getControllerId());
  if (spell != null && controller != null) {
    Target usedTarget=null;
    setUsedTarget:     for (    Mode mode : spell.getSpellAbility().getModes().getSelectedModes()) {
      for (      Target target : mode.getTargets()) {
        if (target.getFirstTarget().equals(source.getSourceId())) {
          usedTarget=target.copy();
          usedTarget.clearChosen();
          break setUsedTarget;
        }
      }
    }
    if (usedTarget == null) {
      return false;
    }
    for (    Permanent creature : game.getState().getBattlefield().getAllActivePermanents(new FilterCreaturePermanent(),source.getControllerId(),game)) {
      if (!creature.getId().equals(source.getSourceId()) && usedTarget.canTarget(source.getControllerId(),creature.getId(),source,game)) {
        Spell copy=spell.copySpell();
        setTarget:         for (        Mode mode : spell.getSpellAbility().getModes().getSelectedModes()) {
          for (          Target target : mode.getTargets()) {
            if (target.getClass().equals(usedTarget.getClass())) {
              target.clearChosen();
              if (target.getMessage().equals(usedTarget.getMessage())) {
                target.add(creature.getId(),game);
                break setTarget;
              }
            }
          }
        }
        copy.setControllerId(source.getControllerId());
        copy.setCopiedSpell(true);
        game.getStack().push(copy);
        String activateMessage=copy.getActivatedMessage(game);
        if (activateMessage.startsWith(""String_Node_Str"")) {
          activateMessage=activateMessage.substring(6);
        }
        if (!game.isSimulation()) {
          game.informPlayers(controller.getLogName() + activateMessage);
        }
      }
    }
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Spell spell=game.getStack().getSpell(targetPointer.getFirst(game,source));
  if (spell == null) {
    spell=(Spell)game.getLastKnownInformation(targetPointer.getFirst(game,source),Zone.STACK);
  }
  Player controller=game.getPlayer(source.getControllerId());
  if (spell != null && controller != null) {
    Target usedTarget=null;
    setUsedTarget:     for (    Ability ability : spell.getSpellAbilities()) {
      for (      Mode mode : ability.getModes().getSelectedModes()) {
        for (        Target target : mode.getTargets()) {
          if (!target.isNotTarget() && target.getFirstTarget().equals(source.getSourceId())) {
            usedTarget=target.copy();
            usedTarget.clearChosen();
            break setUsedTarget;
          }
        }
      }
    }
    if (usedTarget == null) {
      return false;
    }
    for (    Permanent creature : game.getState().getBattlefield().getAllActivePermanents(new FilterCreaturePermanent(),source.getControllerId(),game)) {
      if (!creature.getId().equals(source.getSourceId()) && usedTarget.canTarget(source.getControllerId(),creature.getId(),source,game)) {
        Spell copy=spell.copySpell(source.getControllerId());
        setTarget:         for (        Mode mode : spell.getSpellAbility().getModes().getSelectedModes()) {
          for (          Target target : mode.getTargets()) {
            if (target.getClass().equals(usedTarget.getClass())) {
              target.clearChosen();
              if (target.getMessage().equals(usedTarget.getMessage())) {
                target.add(creature.getId(),game);
                break setTarget;
              }
            }
          }
        }
        game.getStack().push(copy);
        String activateMessage=copy.getActivatedMessage(game);
        if (activateMessage.startsWith(""String_Node_Str"")) {
          activateMessage=activateMessage.substring(6);
        }
        if (!game.isSimulation()) {
          game.informPlayers(controller.getLogName() + activateMessage);
        }
      }
    }
    return true;
  }
  return false;
}",0.9347517730496454
158589,"@Override public boolean apply(Game game,Ability source){
  Spell spell=game.getStack().getSpell(targetPointer.getFirst(game,source));
  if (spell != null) {
    Spell copy=spell.copySpell();
    copy.setControllerId(source.getControllerId());
    copy.setCopiedSpell(true);
    game.getStack().push(copy);
    copy.chooseNewTargets(game,source.getControllerId());
    Player player=game.getPlayer(source.getControllerId());
    String activateMessage=copy.getActivatedMessage(game);
    if (activateMessage.startsWith(""String_Node_Str"")) {
      activateMessage=activateMessage.substring(6);
    }
    game.informPlayers(player.getLogName() + ""String_Node_Str"" + activateMessage);
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Spell spell=game.getStack().getSpell(targetPointer.getFirst(game,source));
  if (spell != null) {
    Spell copy=spell.copySpell(source.getControllerId());
    ;
    game.getStack().push(copy);
    copy.chooseNewTargets(game,source.getControllerId());
    Player player=game.getPlayer(source.getControllerId());
    String activateMessage=copy.getActivatedMessage(game);
    if (activateMessage.startsWith(""String_Node_Str"")) {
      activateMessage=activateMessage.substring(6);
    }
    game.informPlayers(player.getLogName() + ""String_Node_Str"" + activateMessage);
    return true;
  }
  return false;
}",0.8031723143475126
158590,"@Override public boolean apply(Game game,Ability source){
  Spell spell=game.getStack().getSpell(source.getFirstTarget());
  Player you=game.getPlayer(source.getControllerId());
  if (spell != null && you != null && you.chooseUse(Outcome.Benefit,""String_Node_Str"" + spell.getName() + ""String_Node_Str"",source,game)) {
    spell.chooseNewTargets(game,you.getId());
  }
  if (spell != null) {
    Spell copy=spell.copySpell();
    copy.setControllerId(source.getControllerId());
    copy.setCopiedSpell(true);
    game.getStack().push(copy);
    if (you != null && you.chooseUse(Outcome.Benefit,""String_Node_Str"" + spell.getName() + ""String_Node_Str"",source,game)) {
      return copy.chooseNewTargets(game,you.getId());
    }
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Spell spell=game.getStack().getSpell(source.getFirstTarget());
  Player you=game.getPlayer(source.getControllerId());
  if (spell != null && you != null && you.chooseUse(Outcome.Benefit,""String_Node_Str"" + spell.getName() + ""String_Node_Str"",source,game)) {
    spell.chooseNewTargets(game,you.getId());
  }
  if (spell != null) {
    Spell copy=spell.copySpell(source.getControllerId());
    ;
    game.getStack().push(copy);
    if (you != null && you.chooseUse(Outcome.Benefit,""String_Node_Str"" + spell.getName() + ""String_Node_Str"",source,game)) {
      return copy.chooseNewTargets(game,you.getId());
    }
  }
  return false;
}",0.9409312022237664
158591,"@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller != null) {
    Spell spell=game.getStack().getSpell(source.getSourceId());
    if (spell != null) {
      Spell spellCopy=spell.copySpell();
      spellCopy.setCopiedSpell(true);
      spellCopy.setControllerId(source.getControllerId());
      game.getStack().push(spellCopy);
      spellCopy.chooseNewTargets(game,controller.getId());
      String activateMessage=spellCopy.getActivatedMessage(game);
      if (activateMessage.startsWith(""String_Node_Str"")) {
        activateMessage=activateMessage.substring(6);
      }
      game.informPlayers(controller.getLogName() + ""String_Node_Str"" + activateMessage);
      return true;
    }
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller != null) {
    Spell spell=game.getStack().getSpell(source.getSourceId());
    if (spell != null) {
      Spell spellCopy=spell.copySpell(source.getControllerId());
      ;
      game.getStack().push(spellCopy);
      spellCopy.chooseNewTargets(game,controller.getId());
      String activateMessage=spellCopy.getActivatedMessage(game);
      if (activateMessage.startsWith(""String_Node_Str"")) {
        activateMessage=activateMessage.substring(6);
      }
      game.informPlayers(controller.getLogName() + ""String_Node_Str"" + activateMessage);
      return true;
    }
  }
  return false;
}",0.8144262295081968
158592,"@Override public boolean apply(Game game,Ability source){
  Spell spell=game.getStack().getSpell(targetPointer.getFirst(game,source));
  if (spell != null) {
    String chooseMessage=""String_Node_Str"";
    for (    UUID playerId : game.getPlayerList()) {
      if (!playerId.equals(spell.getControllerId())) {
        Player player=game.getPlayer(playerId);
        if (player.chooseUse(Outcome.Copy,chooseMessage,source,game)) {
          Spell copy=spell.copySpell();
          copy.setControllerId(playerId);
          copy.setCopiedSpell(true);
          game.getStack().push(copy);
          copy.chooseNewTargets(game,playerId);
        }
      }
    }
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Spell spell=game.getStack().getSpell(targetPointer.getFirst(game,source));
  if (spell != null) {
    String chooseMessage=""String_Node_Str"";
    for (    UUID playerId : game.getPlayerList()) {
      if (!playerId.equals(spell.getControllerId())) {
        Player player=game.getPlayer(playerId);
        if (player.chooseUse(Outcome.Copy,chooseMessage,source,game)) {
          Spell copy=spell.copySpell(source.getControllerId());
          ;
          game.getStack().push(copy);
          copy.chooseNewTargets(game,playerId);
        }
      }
    }
    return true;
  }
  return false;
}",0.93560325684678
158593,"@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller != null) {
    Spell spell=game.getStack().getSpell(targetPointer.getFirst(game,source));
    if (spell != null) {
      Spell copy=spell.copySpell();
      copy.setControllerId(source.getControllerId());
      copy.setCopiedSpell(true);
      game.getStack().push(copy);
      copy.chooseNewTargets(game,source.getControllerId());
      game.informPlayers(new StringBuilder(controller.getLogName()).append(copy.getActivatedMessage(game)).toString());
      Spell sourceSpell=(Spell)game.getStack().getStackObject(source.getSourceId());
      if (sourceSpell != null) {
        if (sourceSpell.getFromZone() == Zone.GRAVEYARD) {
          copy=spell.copySpell();
          copy.setControllerId(source.getControllerId());
          copy.setCopiedSpell(true);
          game.getStack().push(copy);
          copy.chooseNewTargets(game,source.getControllerId());
          game.informPlayers(new StringBuilder(controller.getLogName()).append(copy.getActivatedMessage(game)).toString());
        }
      }
      return true;
    }
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller != null) {
    Spell spell=game.getStack().getSpell(targetPointer.getFirst(game,source));
    if (spell != null) {
      Spell copy=spell.copySpell(source.getControllerId());
      game.getStack().push(copy);
      copy.chooseNewTargets(game,source.getControllerId());
      game.informPlayers(new StringBuilder(controller.getLogName()).append(copy.getActivatedMessage(game)).toString());
      Spell sourceSpell=(Spell)game.getStack().getStackObject(source.getSourceId());
      if (sourceSpell != null) {
        if (sourceSpell.getFromZone() == Zone.GRAVEYARD) {
          copy=spell.copySpell(source.getControllerId());
          game.getStack().push(copy);
          copy.chooseNewTargets(game,source.getControllerId());
          game.informPlayers(new StringBuilder(controller.getLogName()).append(copy.getActivatedMessage(game)).toString());
        }
      }
      return true;
    }
  }
  return false;
}",0.9239713774597496
158594,"/** 
 * Creates new form MageFrame
 */
public MageFrame(){
  setWindowTitle();
  clientId=UUID.randomUUID();
  EDTExceptionHandler.registerExceptionHandler();
  addWindowListener(new WindowAdapter(){
    @Override public void windowClosing(    WindowEvent e){
      exitApp();
    }
  }
);
  TConfig config=TConfig.current();
  config.setArchiveDetector(new TArchiveDetector(""String_Node_Str""));
  config.setAccessPreference(FsAccessOption.STORE,true);
  try {
    UIManager.put(""String_Node_Str"",new Color(0,0,0,0));
    UIManager.setLookAndFeel(""String_Node_Str"");
  }
 catch (  Exception ex) {
    logger.fatal(null,ex);
  }
  ManaSymbols.loadImages();
  Plugins.getInstance().loadPlugins();
  initComponents();
  desktopPane.setDesktopManager(new MageDesktopManager());
  setSize(1024,768);
  SettingsManager.getInstance().setScreenWidthAndHeight(1024,768);
  DialogManager.updateParams(768,1024,false);
  this.setExtendedState(JFrame.MAXIMIZED_BOTH);
  session=new SessionImpl(this);
  callbackClient=new CallbackClientImpl(this);
  connectDialog=new ConnectDialog();
  desktopPane.add(connectDialog,JLayeredPane.POPUP_LAYER);
  errorDialog=new ErrorDialog();
  errorDialog.setLocation(100,100);
  desktopPane.add(errorDialog,JLayeredPane.POPUP_LAYER);
  ui.addComponent(MageComponents.DESKTOP_PANE,desktopPane);
  pingTaskExecutor.scheduleAtFixedRate(new Runnable(){
    @Override public void run(){
      session.ping();
    }
  }
,60,60,TimeUnit.SECONDS);
  updateMemUsageTask=new UpdateMemUsageTask(jMemUsageLabel);
  try {
    tablesPane=new TablesPane();
    desktopPane.add(tablesPane,javax.swing.JLayeredPane.DEFAULT_LAYER);
    tablesPane.setMaximum(true);
  }
 catch (  PropertyVetoException ex) {
    logger.fatal(null,ex);
  }
  addTooltipContainer();
  setBackground();
  addMageLabel();
  setAppIcon();
  MageTray.getInstance().install();
  desktopPane.add(ArrowBuilder.getBuilder().getArrowsManagerPanel(),JLayeredPane.DRAG_LAYER);
  desktopPane.addComponentListener(new ComponentAdapter(){
    @Override public void componentResized(    ComponentEvent e){
      int width=((JComponent)e.getSource()).getWidth();
      int height=((JComponent)e.getSource()).getHeight();
      SettingsManager.getInstance().setScreenWidthAndHeight(width,height);
      if (!liteMode && !grayMode) {
        backgroundPane.setSize(width,height);
      }
      ArrowBuilder.getBuilder().setSize(width,height);
      if (title != null) {
        title.setBounds((int)(width - titleRectangle.getWidth()) / 2,(int)(height - titleRectangle.getHeight()) / 2,titleRectangle.width,titleRectangle.height);
      }
    }
  }
);
  mageToolbar.add(new javax.swing.JToolBar.Separator());
  mageToolbar.add(createWindowsButton());
  if (Plugins.getInstance().isCardPluginLoaded()) {
    Separator separator=new javax.swing.JToolBar.Separator();
    mageToolbar.add(separator);
    JButton btnDownloadSymbols=new JButton(""String_Node_Str"");
    btnDownloadSymbols.setFocusable(false);
    btnDownloadSymbols.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
    btnDownloadSymbols.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
    btnDownloadSymbols.addActionListener(new java.awt.event.ActionListener(){
      @Override public void actionPerformed(      java.awt.event.ActionEvent evt){
        btnSymbolsActionPerformed(evt);
      }
    }
);
    mageToolbar.add(btnDownloadSymbols);
    separator=new javax.swing.JToolBar.Separator();
    mageToolbar.add(separator);
    JButton btnDownload=new JButton(""String_Node_Str"");
    btnDownload.setFocusable(false);
    btnDownload.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
    btnDownload.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
    btnDownload.addActionListener(new java.awt.event.ActionListener(){
      @Override public void actionPerformed(      java.awt.event.ActionEvent evt){
        btnImagesActionPerformed(evt);
      }
    }
);
    mageToolbar.add(btnDownload);
  }
  if (Plugins.getInstance().isCounterPluginLoaded()) {
    int i=Plugins.getInstance().getGamesPlayed();
    JLabel label=new JLabel(""String_Node_Str"" + String.valueOf(i));
    desktopPane.add(label,JLayeredPane.DEFAULT_LAYER + 1);
    label.setVisible(true);
    label.setForeground(Color.white);
    label.setBounds(0,0,180,30);
  }
  ui.addButton(MageComponents.TABLES_MENU_BUTTON,btnGames);
  SwingUtilities.invokeLater(new Runnable(){
    @Override public void run(){
      disableButtons();
      if (PreferencesDialog.getCachedValue(PreferencesDialog.KEY_CARD_IMAGES_CHECK,""String_Node_Str"").equals(""String_Node_Str"")) {
        checkForNewImages();
      }
      updateMemUsageTask.execute();
      logger.info(""String_Node_Str"" + ((System.currentTimeMillis() - startTime) / 1000 + ""String_Node_Str""));
      if (autoConnect()) {
        enableButtons();
      }
 else {
        connectDialog.showDialog();
      }
      setWindowTitle();
    }
  }
);
  if (SystemUtil.isMacOSX()) {
    SystemUtil.enableMacOSFullScreenMode(this);
    if (fullscreenMode) {
      SystemUtil.toggleMacOSFullScreenMode(this);
    }
  }
}","/** 
 * Creates new form MageFrame
 */
public MageFrame(){
  setWindowTitle();
  clientId=UUID.randomUUID();
  EDTExceptionHandler.registerExceptionHandler();
  addWindowListener(new WindowAdapter(){
    @Override public void windowClosing(    WindowEvent e){
      exitApp();
    }
  }
);
  TConfig config=TConfig.current();
  config.setArchiveDetector(new TArchiveDetector(""String_Node_Str""));
  config.setAccessPreference(FsAccessOption.STORE,true);
  try {
    UIManager.put(""String_Node_Str"",new Color(0,0,0,0));
    UIManager.setLookAndFeel(""String_Node_Str"");
  }
 catch (  Exception ex) {
    LOGGER.fatal(null,ex);
  }
  ManaSymbols.loadImages();
  Plugins.getInstance().loadPlugins();
  initComponents();
  desktopPane.setDesktopManager(new MageDesktopManager());
  setSize(1024,768);
  SettingsManager.getInstance().setScreenWidthAndHeight(1024,768);
  DialogManager.updateParams(768,1024,false);
  this.setExtendedState(JFrame.MAXIMIZED_BOTH);
  session=new SessionImpl(this);
  callbackClient=new CallbackClientImpl(this);
  connectDialog=new ConnectDialog();
  desktopPane.add(connectDialog,JLayeredPane.POPUP_LAYER);
  errorDialog=new ErrorDialog();
  errorDialog.setLocation(100,100);
  desktopPane.add(errorDialog,JLayeredPane.POPUP_LAYER);
  UI.addComponent(MageComponents.DESKTOP_PANE,desktopPane);
  PING_TASK_EXECUTOR.scheduleAtFixedRate(new Runnable(){
    @Override public void run(){
      session.ping();
    }
  }
,60,60,TimeUnit.SECONDS);
  updateMemUsageTask=new UpdateMemUsageTask(jMemUsageLabel);
  try {
    tablesPane=new TablesPane();
    desktopPane.add(tablesPane,javax.swing.JLayeredPane.DEFAULT_LAYER);
    tablesPane.setMaximum(true);
  }
 catch (  PropertyVetoException ex) {
    LOGGER.fatal(null,ex);
  }
  addTooltipContainer();
  setBackground();
  addMageLabel();
  setAppIcon();
  MageTray.getInstance().install();
  desktopPane.add(ArrowBuilder.getBuilder().getArrowsManagerPanel(),JLayeredPane.DRAG_LAYER);
  desktopPane.addComponentListener(new ComponentAdapter(){
    @Override public void componentResized(    ComponentEvent e){
      int width=((JComponent)e.getSource()).getWidth();
      int height=((JComponent)e.getSource()).getHeight();
      SettingsManager.getInstance().setScreenWidthAndHeight(width,height);
      if (!liteMode && !grayMode) {
        backgroundPane.setSize(width,height);
      }
      ArrowBuilder.getBuilder().setSize(width,height);
      if (title != null) {
        title.setBounds((int)(width - titleRectangle.getWidth()) / 2,(int)(height - titleRectangle.getHeight()) / 2,titleRectangle.width,titleRectangle.height);
      }
    }
  }
);
  mageToolbar.add(new javax.swing.JToolBar.Separator());
  mageToolbar.add(createWindowsButton());
  if (Plugins.getInstance().isCardPluginLoaded()) {
    Separator separator=new javax.swing.JToolBar.Separator();
    mageToolbar.add(separator);
    JButton btnDownloadSymbols=new JButton(""String_Node_Str"");
    btnDownloadSymbols.setFocusable(false);
    btnDownloadSymbols.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
    btnDownloadSymbols.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
    btnDownloadSymbols.addActionListener(new java.awt.event.ActionListener(){
      @Override public void actionPerformed(      java.awt.event.ActionEvent evt){
        btnSymbolsActionPerformed(evt);
      }
    }
);
    mageToolbar.add(btnDownloadSymbols);
    separator=new javax.swing.JToolBar.Separator();
    mageToolbar.add(separator);
    JButton btnDownload=new JButton(""String_Node_Str"");
    btnDownload.setFocusable(false);
    btnDownload.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
    btnDownload.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
    btnDownload.addActionListener(new java.awt.event.ActionListener(){
      @Override public void actionPerformed(      java.awt.event.ActionEvent evt){
        btnImagesActionPerformed(evt);
      }
    }
);
    mageToolbar.add(btnDownload);
  }
  if (Plugins.getInstance().isCounterPluginLoaded()) {
    int i=Plugins.getInstance().getGamesPlayed();
    JLabel label=new JLabel(""String_Node_Str"" + String.valueOf(i));
    desktopPane.add(label,JLayeredPane.DEFAULT_LAYER + 1);
    label.setVisible(true);
    label.setForeground(Color.white);
    label.setBounds(0,0,180,30);
  }
  UI.addButton(MageComponents.TABLES_MENU_BUTTON,btnGames);
  SwingUtilities.invokeLater(new Runnable(){
    @Override public void run(){
      disableButtons();
      if (PreferencesDialog.getCachedValue(PreferencesDialog.KEY_CARD_IMAGES_CHECK,""String_Node_Str"").equals(""String_Node_Str"")) {
        checkForNewImages();
      }
      updateMemUsageTask.execute();
      LOGGER.info(""String_Node_Str"" + ((System.currentTimeMillis() - startTime) / 1000 + ""String_Node_Str""));
      if (autoConnect()) {
        enableButtons();
      }
 else {
        connectDialog.showDialog();
      }
      setWindowTitle();
    }
  }
);
  if (SystemUtil.isMacOSX()) {
    SystemUtil.enableMacOSFullScreenMode(this);
    if (fullscreenMode) {
      SystemUtil.toggleMacOSFullScreenMode(this);
    }
  }
}",0.9927522037218414
158595,"/** 
 * @param args the command line arguments
 */
public static void main(final String args[]){
  System.setProperty(""String_Node_Str"",""String_Node_Str"");
  logger.info(""String_Node_Str"" + version);
  logger.info(""String_Node_Str"" + logger.getEffectiveLevel());
  startTime=System.currentTimeMillis();
  Thread.setDefaultUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler(){
    @Override public void uncaughtException(    Thread t,    Throwable e){
      logger.fatal(null,e);
    }
  }
);
  SwingUtilities.invokeLater(new Runnable(){
    @Override public void run(){
      for (      String arg : args) {
        if (arg.startsWith(liteModeArg)) {
          liteMode=true;
        }
        if (arg.startsWith(grayModeArg)) {
          grayMode=true;
        }
        if (arg.startsWith(fullscreenArg)) {
          fullscreenMode=true;
        }
      }
      if (!liteMode) {
        final SplashScreen splash=SplashScreen.getSplashScreen();
        if (splash != null) {
          Graphics2D g=splash.createGraphics();
          if (g != null) {
            renderSplashFrame(g);
          }
          splash.update();
        }
      }
      instance=new MageFrame();
      instance.setVisible(true);
    }
  }
);
}","/** 
 * @param args the command line arguments
 */
public static void main(final String args[]){
  System.setProperty(""String_Node_Str"",""String_Node_Str"");
  LOGGER.info(""String_Node_Str"" + VERSION);
  LOGGER.info(""String_Node_Str"" + LOGGER.getEffectiveLevel());
  startTime=System.currentTimeMillis();
  Thread.setDefaultUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler(){
    @Override public void uncaughtException(    Thread t,    Throwable e){
      LOGGER.fatal(null,e);
    }
  }
);
  SwingUtilities.invokeLater(new Runnable(){
    @Override public void run(){
      for (      String arg : args) {
        if (arg.startsWith(LITE_MODE_ARG)) {
          liteMode=true;
        }
        if (arg.startsWith(GRAY_MODE_ARG)) {
          grayMode=true;
        }
        if (arg.startsWith(FILL_SCREEN_ARG)) {
          fullscreenMode=true;
        }
      }
      if (!liteMode) {
        final SplashScreen splash=SplashScreen.getSplashScreen();
        if (splash != null) {
          Graphics2D g=splash.createGraphics();
          if (g != null) {
            renderSplashFrame(g);
          }
          splash.update();
        }
      }
      instance=new MageFrame();
      instance.setVisible(true);
    }
  }
);
}",0.8947368421052632
158596,"public static void removeChat(UUID chatId){
  chats.remove(chatId);
}","public static void removeChat(UUID chatId){
  CHATS.remove(chatId);
}",0.927536231884058
158597,"@Override public void disconnected(final boolean errorCall){
  if (SwingUtilities.isEventDispatchThread()) {
    logger.info(""String_Node_Str"");
    setStatusText(""String_Node_Str"");
    disableButtons();
    hideGames();
    hideTables();
  }
 else {
    logger.info(""String_Node_Str"");
    SwingUtilities.invokeLater(new Runnable(){
      @Override public void run(){
        setStatusText(""String_Node_Str"");
        disableButtons();
        hideGames();
        hideTables();
        if (errorCall && JOptionPane.showConfirmDialog(MageFrame.this,""String_Node_Str"",""String_Node_Str"",JOptionPane.YES_NO_OPTION) == JOptionPane.YES_OPTION) {
          if (performConnect()) {
            enableButtons();
          }
        }
 else {
          session.disconnect(false);
        }
      }
    }
);
  }
}","@Override public void disconnected(final boolean errorCall){
  if (SwingUtilities.isEventDispatchThread()) {
    LOGGER.info(""String_Node_Str"");
    setStatusText(""String_Node_Str"");
    disableButtons();
    hideGames();
    hideTables();
  }
 else {
    LOGGER.info(""String_Node_Str"");
    SwingUtilities.invokeLater(new Runnable(){
      @Override public void run(){
        setStatusText(""String_Node_Str"");
        disableButtons();
        hideGames();
        hideTables();
        if (errorCall && JOptionPane.showConfirmDialog(MageFrame.this,""String_Node_Str"",""String_Node_Str"",JOptionPane.YES_NO_OPTION) == JOptionPane.YES_OPTION) {
          if (performConnect()) {
            enableButtons();
          }
        }
 else {
          session.disconnect(false);
        }
      }
    }
);
  }
}",0.9850931677018634
158598,"private void addMageLabel(){
  if (liteMode || grayMode) {
    return;
  }
  String filename=""String_Node_Str"";
  try {
    InputStream is=this.getClass().getResourceAsStream(filename);
    float ratio=1179.0f / 678.0f;
    titleRectangle=new Rectangle(540,(int)(640 / ratio));
    if (is != null) {
      BufferedImage image=ImageIO.read(is);
      title=new JLabel();
      title.setIcon(new ImageIcon(image));
      backgroundPane.setLayout(null);
      backgroundPane.add(title);
    }
  }
 catch (  IOException e) {
    logger.fatal(""String_Node_Str"",e);
  }
}","private void addMageLabel(){
  if (liteMode || grayMode) {
    return;
  }
  String filename=""String_Node_Str"";
  try {
    InputStream is=this.getClass().getResourceAsStream(filename);
    float ratio=1179.0f / 678.0f;
    titleRectangle=new Rectangle(540,(int)(640 / ratio));
    if (is != null) {
      BufferedImage image=ImageIO.read(is);
      title=new JLabel();
      title.setIcon(new ImageIcon(image));
      backgroundPane.setLayout(null);
      backgroundPane.add(title);
    }
  }
 catch (  IOException e) {
    LOGGER.fatal(""String_Node_Str"",e);
  }
}",0.9893805309734514
158599,"public static GamePanel getGame(UUID gameId){
  return games.get(gameId);
}","public static GamePanel getGame(UUID gameId){
  return GAMES.get(gameId);
}",0.9333333333333332
158600,"public static void addChat(UUID chatId,ChatPanelBasic chatPanel){
  chats.put(chatId,chatPanel);
}","public static void addChat(UUID chatId,ChatPanelBasic chatPanel){
  CHATS.put(chatId,chatPanel);
}",0.9489795918367347
158601,"public void showCollectionViewer(){
  JInternalFrame[] windows=desktopPane.getAllFramesInLayer(JLayeredPane.DEFAULT_LAYER);
  for (  JInternalFrame window : windows) {
    if (window instanceof CollectionViewerPane) {
      setActive((MagePane)window);
      return;
    }
  }
  try {
    CollectionViewerPane collectionViewerPane=new CollectionViewerPane();
    desktopPane.add(collectionViewerPane,javax.swing.JLayeredPane.DEFAULT_LAYER);
    collectionViewerPane.setMaximum(true);
    collectionViewerPane.setVisible(true);
    setActive(collectionViewerPane);
  }
 catch (  PropertyVetoException ex) {
    logger.fatal(null,ex);
  }
}","public void showCollectionViewer(){
  JInternalFrame[] windows=desktopPane.getAllFramesInLayer(JLayeredPane.DEFAULT_LAYER);
  for (  JInternalFrame window : windows) {
    if (window instanceof CollectionViewerPane) {
      setActive((MagePane)window);
      return;
    }
  }
  try {
    CollectionViewerPane collectionViewerPane=new CollectionViewerPane();
    desktopPane.add(collectionViewerPane,javax.swing.JLayeredPane.DEFAULT_LAYER);
    collectionViewerPane.setMaximum(true);
    collectionViewerPane.setVisible(true);
    setActive(collectionViewerPane);
  }
 catch (  PropertyVetoException ex) {
    LOGGER.fatal(null,ex);
  }
}",0.9905956112852664
158602,"public void showDeckEditor(DeckEditorMode mode,Deck deck,UUID tableId,int time){
  String name;
  if (mode == DeckEditorMode.SIDEBOARDING || mode == DeckEditorMode.LIMITED_BUILDING) {
    name=""String_Node_Str"" + tableId.toString();
  }
 else {
    if (deck != null) {
      name=""String_Node_Str"" + deck.getName();
    }
 else {
      name=""String_Node_Str"";
    }
    JInternalFrame[] windows=desktopPane.getAllFramesInLayer(JLayeredPane.DEFAULT_LAYER);
    for (    JInternalFrame window : windows) {
      if (window instanceof DeckEditorPane && window.getTitle().equals(name)) {
        setActive((MagePane)window);
        return;
      }
    }
  }
  try {
    DeckEditorPane deckEditorPane=new DeckEditorPane();
    desktopPane.add(deckEditorPane,JLayeredPane.DEFAULT_LAYER);
    deckEditorPane.setMaximum(true);
    deckEditorPane.setVisible(true);
    deckEditorPane.show(mode,deck,name,tableId,time);
    setActive(deckEditorPane);
  }
 catch (  PropertyVetoException ex) {
    logger.fatal(null,ex);
  }
}","public void showDeckEditor(DeckEditorMode mode,Deck deck,UUID tableId,int time){
  String name;
  if (mode == DeckEditorMode.SIDEBOARDING || mode == DeckEditorMode.LIMITED_BUILDING) {
    name=""String_Node_Str"" + tableId.toString();
  }
 else {
    if (deck != null) {
      name=""String_Node_Str"" + deck.getName();
    }
 else {
      name=""String_Node_Str"";
    }
    JInternalFrame[] windows=desktopPane.getAllFramesInLayer(JLayeredPane.DEFAULT_LAYER);
    for (    JInternalFrame window : windows) {
      if (window instanceof DeckEditorPane && window.getTitle().equals(name)) {
        setActive((MagePane)window);
        return;
      }
    }
  }
  try {
    DeckEditorPane deckEditorPane=new DeckEditorPane();
    desktopPane.add(deckEditorPane,JLayeredPane.DEFAULT_LAYER);
    deckEditorPane.setMaximum(true);
    deckEditorPane.setVisible(true);
    deckEditorPane.show(mode,deck,name,tableId,time);
    setActive(deckEditorPane);
  }
 catch (  PropertyVetoException ex) {
    LOGGER.fatal(null,ex);
  }
}",0.9940944881889764
158603,"public static MageUI getUI(){
  return ui;
}","public static MageUI getUI(){
  return UI;
}",0.9545454545454546
158604,"public static Preferences getPreferences(){
  return prefs;
}","public static Preferences getPreferences(){
  return PREFS;
}",0.918032786885246
158605,"public static ChatPanelBasic getChat(UUID chatId){
  return chats.get(chatId);
}","public static ChatPanelBasic getChat(UUID chatId){
  return CHATS.get(chatId);
}",0.9375
158606,"public static void addGame(UUID gameId,GamePanel gamePanel){
  games.put(gameId,gamePanel);
}","public static void addGame(UUID gameId,GamePanel gamePanel){
  GAMES.put(gameId,gamePanel);
}",0.946236559139785
158607,"private void setWindowTitle(){
  setTitle(TITLE_NAME + ""String_Node_Str"" + (version == null ? ""String_Node_Str"" : version.toString())+ ""String_Node_Str""+ ((session != null && session.isConnected()) ? session.getVersionInfo() : ""String_Node_Str""));
}","private void setWindowTitle(){
  setTitle(TITLE_NAME + ""String_Node_Str"" + (VERSION == null ? ""String_Node_Str"" : VERSION.toString())+ ""String_Node_Str""+ ((session != null && session.isConnected()) ? session.getVersionInfo() : ""String_Node_Str""));
}",0.9437751004016064
158608,"public void exitApp(){
  if (session.isConnected()) {
    if (JOptionPane.showConfirmDialog(this,""String_Node_Str"",""String_Node_Str"",JOptionPane.YES_NO_OPTION) != JOptionPane.YES_OPTION) {
      return;
    }
    session.disconnect(false);
  }
 else {
    if (JOptionPane.showConfirmDialog(this,""String_Node_Str"",""String_Node_Str"",JOptionPane.YES_NO_OPTION) != JOptionPane.YES_OPTION) {
      return;
    }
  }
  CardRepository.instance.closeDB();
  tablesPane.cleanUp();
  Plugins.getInstance().shutdown();
  dispose();
  System.exit(0);
}","public void exitApp(){
  if (session.isConnected()) {
    if (JOptionPane.showConfirmDialog(this,""String_Node_Str"",""String_Node_Str"",JOptionPane.YES_NO_OPTION) != JOptionPane.YES_OPTION) {
      return;
    }
    session.disconnect(false);
  }
 else   if (JOptionPane.showConfirmDialog(this,""String_Node_Str"",""String_Node_Str"",JOptionPane.YES_NO_OPTION) != JOptionPane.YES_OPTION) {
    return;
  }
  CardRepository.instance.closeDB();
  tablesPane.cleanUp();
  Plugins.getInstance().shutdown();
  dispose();
  System.exit(0);
}",0.9887640449438202
158609,"public static DraftPanel getDraft(UUID draftId){
  return drafts.get(draftId);
}","public static DraftPanel getDraft(UUID draftId){
  return DRAFTS.get(draftId);
}",0.925
158610,"private void addTooltipContainer(){
  final JEditorPane cardInfoPane=(JEditorPane)Plugins.getInstance().getCardInfoPane();
  if (cardInfoPane == null) {
    return;
  }
  cardInfoPane.setSize(Constants.TOOLTIP_WIDTH_MIN,Constants.TOOLTIP_HEIGHT_MIN);
  cardInfoPane.setLocation(40,40);
  cardInfoPane.setBackground(new Color(0,0,0,0));
  MageRoundPane popupContainer=new MageRoundPane();
  popupContainer.setLayout(null);
  popupContainer.add(cardInfoPane);
  popupContainer.setVisible(false);
  popupContainer.setBounds(0,0,Constants.TOOLTIP_WIDTH_MIN + Constants.TOOLTIP_BORDER_WIDTH,Constants.TOOLTIP_HEIGHT_MIN + Constants.TOOLTIP_BORDER_WIDTH);
  desktopPane.add(popupContainer,JLayeredPane.POPUP_LAYER);
  ui.addComponent(MageComponents.CARD_INFO_PANE,cardInfoPane);
  ui.addComponent(MageComponents.POPUP_CONTAINER,popupContainer);
  JPanel cardPreviewContainer=new JPanel();
  cardPreviewContainer.setOpaque(false);
  cardPreviewContainer.setLayout(null);
  BigCard bigCard=new BigCard();
  bigCard.setSize(320,500);
  bigCard.setLocation(40,40);
  bigCard.setBackground(new Color(0,0,0,0));
  cardPreviewContainer.add(bigCard);
  cardPreviewContainer.setVisible(false);
  cardPreviewContainer.setBounds(0,0,320 + 80,500 + 30);
  ui.addComponent(MageComponents.CARD_PREVIEW_PANE,bigCard);
  ui.addComponent(MageComponents.CARD_PREVIEW_CONTAINER,cardPreviewContainer);
  desktopPane.add(cardPreviewContainer,JLayeredPane.POPUP_LAYER);
  JPanel cardPreviewContainerRotated=new JPanel();
  cardPreviewContainerRotated.setOpaque(false);
  cardPreviewContainerRotated.setLayout(null);
  bigCard=new BigCard(true);
  bigCard.setSize(500,350);
  bigCard.setLocation(40,40);
  bigCard.setBackground(new Color(0,0,0,0));
  cardPreviewContainerRotated.add(bigCard);
  cardPreviewContainerRotated.setVisible(false);
  cardPreviewContainerRotated.setBounds(0,0,500 + 80,420 + 30);
  ui.addComponent(MageComponents.CARD_PREVIEW_PANE_ROTATED,bigCard);
  ui.addComponent(MageComponents.CARD_PREVIEW_CONTAINER_ROTATED,cardPreviewContainerRotated);
  desktopPane.add(cardPreviewContainerRotated,JLayeredPane.POPUP_LAYER);
}","private void addTooltipContainer(){
  final JEditorPane cardInfoPane=(JEditorPane)Plugins.getInstance().getCardInfoPane();
  if (cardInfoPane == null) {
    return;
  }
  cardInfoPane.setSize(Constants.TOOLTIP_WIDTH_MIN,Constants.TOOLTIP_HEIGHT_MIN);
  cardInfoPane.setLocation(40,40);
  cardInfoPane.setBackground(new Color(0,0,0,0));
  MageRoundPane popupContainer=new MageRoundPane();
  popupContainer.setLayout(null);
  popupContainer.add(cardInfoPane);
  popupContainer.setVisible(false);
  popupContainer.setBounds(0,0,Constants.TOOLTIP_WIDTH_MIN + Constants.TOOLTIP_BORDER_WIDTH,Constants.TOOLTIP_HEIGHT_MIN + Constants.TOOLTIP_BORDER_WIDTH);
  desktopPane.add(popupContainer,JLayeredPane.POPUP_LAYER);
  UI.addComponent(MageComponents.CARD_INFO_PANE,cardInfoPane);
  UI.addComponent(MageComponents.POPUP_CONTAINER,popupContainer);
  JPanel cardPreviewContainer=new JPanel();
  cardPreviewContainer.setOpaque(false);
  cardPreviewContainer.setLayout(null);
  BigCard bigCard=new BigCard();
  bigCard.setSize(320,500);
  bigCard.setLocation(40,40);
  bigCard.setBackground(new Color(0,0,0,0));
  cardPreviewContainer.add(bigCard);
  cardPreviewContainer.setVisible(false);
  cardPreviewContainer.setBounds(0,0,320 + 80,500 + 30);
  UI.addComponent(MageComponents.CARD_PREVIEW_PANE,bigCard);
  UI.addComponent(MageComponents.CARD_PREVIEW_CONTAINER,cardPreviewContainer);
  desktopPane.add(cardPreviewContainer,JLayeredPane.POPUP_LAYER);
  JPanel cardPreviewContainerRotated=new JPanel();
  cardPreviewContainerRotated.setOpaque(false);
  cardPreviewContainerRotated.setLayout(null);
  bigCard=new BigCard(true);
  bigCard.setSize(500,350);
  bigCard.setLocation(40,40);
  bigCard.setBackground(new Color(0,0,0,0));
  cardPreviewContainerRotated.add(bigCard);
  cardPreviewContainerRotated.setVisible(false);
  cardPreviewContainerRotated.setBounds(0,0,500 + 80,420 + 30);
  UI.addComponent(MageComponents.CARD_PREVIEW_PANE_ROTATED,bigCard);
  UI.addComponent(MageComponents.CARD_PREVIEW_CONTAINER_ROTATED,cardPreviewContainerRotated);
  desktopPane.add(cardPreviewContainerRotated,JLayeredPane.POPUP_LAYER);
}",0.9943235572374646
158611,"private void setBackground(){
  if (liteMode || grayMode) {
    return;
  }
  String filename=""String_Node_Str"";
  try {
    if (Plugins.getInstance().isThemePluginLoaded()) {
      backgroundPane=(ImagePanel)Plugins.getInstance().updateTablePanel(new HashMap<String,JComponent>());
    }
 else {
      InputStream is=this.getClass().getResourceAsStream(filename);
      BufferedImage background=ImageIO.read(is);
      backgroundPane=new ImagePanel(background,ImagePanel.SCALED);
    }
    backgroundPane.setSize(1024,768);
    desktopPane.add(backgroundPane,JLayeredPane.DEFAULT_LAYER);
  }
 catch (  IOException e) {
    logger.fatal(""String_Node_Str"",e);
  }
}","private void setBackground(){
  if (liteMode || grayMode) {
    return;
  }
  String filename=""String_Node_Str"";
  try {
    if (Plugins.getInstance().isThemePluginLoaded()) {
      backgroundPane=(ImagePanel)Plugins.getInstance().updateTablePanel(new HashMap<String,JComponent>());
    }
 else {
      InputStream is=this.getClass().getResourceAsStream(filename);
      BufferedImage background=ImageIO.read(is);
      backgroundPane=new ImagePanel(background,ImagePanel.SCALED);
    }
    backgroundPane.setSize(1024,768);
    desktopPane.add(backgroundPane,JLayeredPane.DEFAULT_LAYER);
  }
 catch (  IOException e) {
    LOGGER.fatal(""String_Node_Str"",e);
  }
}",0.9909638554216867
158612,"public static void addDraft(UUID draftId,DraftPanel draftPanel){
  drafts.put(draftId,draftPanel);
}","public static void addDraft(UUID draftId,DraftPanel draftPanel){
  DRAFTS.put(draftId,draftPanel);
}",0.94
158613,"private boolean performConnect(){
  String server=MagePreferences.getServerAddress();
  int port=MagePreferences.getServerPort();
  String userName=MagePreferences.getUserName(server);
  String password=MagePreferences.getPassword(server);
  String proxyServer=prefs.get(""String_Node_Str"",""String_Node_Str"");
  int proxyPort=Integer.parseInt(prefs.get(""String_Node_Str"",""String_Node_Str""));
  ProxyType proxyType=ProxyType.valueByText(prefs.get(""String_Node_Str"",""String_Node_Str""));
  String proxyUsername=prefs.get(""String_Node_Str"",""String_Node_Str"");
  String proxyPassword=prefs.get(""String_Node_Str"",""String_Node_Str"");
  try {
    setCursor(new Cursor(Cursor.WAIT_CURSOR));
    Connection connection=new Connection();
    connection.setUsername(userName);
    connection.setPassword(password);
    connection.setHost(server);
    connection.setPort(port);
    connection.setProxyType(proxyType);
    connection.setProxyHost(proxyServer);
    connection.setProxyPort(proxyPort);
    connection.setProxyUsername(proxyUsername);
    connection.setProxyPassword(proxyPassword);
    setUserPrefsToConnection(connection);
    logger.debug(""String_Node_Str"" + proxyType + ""String_Node_Str""+ proxyServer+ ""String_Node_Str""+ proxyPort+ ""String_Node_Str""+ proxyUsername);
    if (MageFrame.connect(connection)) {
      showGames(false);
      return true;
    }
 else {
      showMessage(""String_Node_Str"");
    }
  }
  finally {
    setCursor(new Cursor(Cursor.DEFAULT_CURSOR));
  }
  return false;
}","private boolean performConnect(){
  String server=MagePreferences.getServerAddress();
  int port=MagePreferences.getServerPort();
  String userName=MagePreferences.getUserName(server);
  String password=MagePreferences.getPassword(server);
  String proxyServer=PREFS.get(""String_Node_Str"",""String_Node_Str"");
  int proxyPort=Integer.parseInt(PREFS.get(""String_Node_Str"",""String_Node_Str""));
  ProxyType proxyType=ProxyType.valueByText(PREFS.get(""String_Node_Str"",""String_Node_Str""));
  String proxyUsername=PREFS.get(""String_Node_Str"",""String_Node_Str"");
  String proxyPassword=PREFS.get(""String_Node_Str"",""String_Node_Str"");
  try {
    setCursor(new Cursor(Cursor.WAIT_CURSOR));
    Connection connection=new Connection();
    connection.setUsername(userName);
    connection.setPassword(password);
    connection.setHost(server);
    connection.setPort(port);
    connection.setProxyType(proxyType);
    connection.setProxyHost(proxyServer);
    connection.setProxyPort(proxyPort);
    connection.setProxyUsername(proxyUsername);
    connection.setProxyPassword(proxyPassword);
    setUserPrefsToConnection(connection);
    LOGGER.debug(""String_Node_Str"" + proxyType + ""String_Node_Str""+ proxyServer+ ""String_Node_Str""+ proxyPort+ ""String_Node_Str""+ proxyUsername);
    if (MageFrame.connect(connection)) {
      showGames(false);
      return true;
    }
 else {
      showMessage(""String_Node_Str"");
    }
  }
  finally {
    setCursor(new Cursor(Cursor.DEFAULT_CURSOR));
  }
  return false;
}",0.979305740987984
158614,"@Override public MageVersion getVersion(){
  return version;
}","@Override public MageVersion getVersion(){
  return VERSION;
}",0.8870967741935484
158615,"public static void removeGame(UUID gameId){
  games.remove(gameId);
}","public static void removeGame(UUID gameId){
  GAMES.remove(gameId);
}",0.927536231884058
158616,"private void checkForNewImages(){
  long beforeCall=System.currentTimeMillis();
  List<CardInfo> cards=CardRepository.instance.findCards(new CardCriteria());
  logger.info(""String_Node_Str"" + ((System.currentTimeMillis() - beforeCall) / 1000 + ""String_Node_Str""));
  beforeCall=System.currentTimeMillis();
  if (DownloadPictures.checkForNewCards(cards)) {
    logger.info(""String_Node_Str"" + ((System.currentTimeMillis() - beforeCall) / 1000 + ""String_Node_Str""));
    if (JOptionPane.showConfirmDialog(this,""String_Node_Str"",""String_Node_Str"",JOptionPane.YES_NO_OPTION) == JOptionPane.YES_OPTION) {
      DownloadPictures.startDownload(null,cards);
    }
  }
}","private void checkForNewImages(){
  long beforeCall=System.currentTimeMillis();
  List<CardInfo> cards=CardRepository.instance.findCards(new CardCriteria());
  LOGGER.info(""String_Node_Str"" + ((System.currentTimeMillis() - beforeCall) / 1000 + ""String_Node_Str""));
  beforeCall=System.currentTimeMillis();
  if (DownloadPictures.checkForNewCards(cards)) {
    LOGGER.info(""String_Node_Str"" + ((System.currentTimeMillis() - beforeCall) / 1000 + ""String_Node_Str""));
    if (JOptionPane.showConfirmDialog(this,""String_Node_Str"",""String_Node_Str"",JOptionPane.YES_NO_OPTION) == JOptionPane.YES_OPTION) {
      DownloadPictures.startDownload(null,cards);
    }
  }
}",0.9818456883509834
158617,"public boolean autoConnect(){
  boolean autoConnectParamValue=Boolean.parseBoolean(prefs.get(""String_Node_Str"",""String_Node_Str""));
  boolean status=false;
  if (autoConnectParamValue) {
    status=performConnect();
  }
  return status;
}","public boolean autoConnect(){
  boolean autoConnectParamValue=Boolean.parseBoolean(PREFS.get(""String_Node_Str"",""String_Node_Str""));
  boolean status=false;
  if (autoConnectParamValue) {
    status=performConnect();
  }
  return status;
}",0.9789915966386554
158618,"public static void setActive(MagePane frame){
  if (frame == null) {
    activeFrame=null;
    return;
  }
  logger.debug(""String_Node_Str"" + frame.getTitle() + ""String_Node_Str"");
  if (activeFrame != null) {
    activeFrame.deactivated();
  }
  activeFrame=frame;
  activeFrame.setVisible(true);
  activeFrame.toFront();
  try {
    activeFrame.setSelected(true);
  }
 catch (  PropertyVetoException ex) {
    logger.error(""String_Node_Str"" + frame.getTitle() + ""String_Node_Str"");
  }
  activeFrame.activated();
  ArrowBuilder.getBuilder().hideAllPanels();
  if (frame instanceof GamePane) {
    ArrowBuilder.getBuilder().showPanel(((GamePane)frame).getGameId());
    MusicPlayer.playBGM();
  }
 else {
    MusicPlayer.stopBGM();
  }
}","public static void setActive(MagePane frame){
  if (frame == null) {
    activeFrame=null;
    return;
  }
  LOGGER.debug(""String_Node_Str"" + frame.getTitle() + ""String_Node_Str"");
  if (activeFrame != null) {
    activeFrame.deactivated();
  }
  activeFrame=frame;
  activeFrame.setVisible(true);
  activeFrame.toFront();
  try {
    activeFrame.setSelected(true);
  }
 catch (  PropertyVetoException ex) {
    LOGGER.error(""String_Node_Str"" + frame.getTitle() + ""String_Node_Str"");
  }
  activeFrame.activated();
  ArrowBuilder.getBuilder().hideAllPanels();
  if (frame instanceof GamePane) {
    ArrowBuilder.getBuilder().showPanel(((GamePane)frame).getGameId());
    MusicPlayer.playBGM();
  }
 else {
    MusicPlayer.stopBGM();
  }
}",0.983739837398374
158619,"public void btnAboutActionPerformed(java.awt.event.ActionEvent evt){
  JInternalFrame[] windows=desktopPane.getAllFramesInLayer(JLayeredPane.POPUP_LAYER);
  for (  JInternalFrame window : windows) {
    if (window instanceof AboutDialog) {
      return;
    }
  }
  AboutDialog aboutDialog=new AboutDialog();
  desktopPane.add(aboutDialog,JLayeredPane.POPUP_LAYER);
  aboutDialog.showDialog(version);
}","public void btnAboutActionPerformed(java.awt.event.ActionEvent evt){
  JInternalFrame[] windows=desktopPane.getAllFramesInLayer(JLayeredPane.POPUP_LAYER);
  for (  JInternalFrame window : windows) {
    if (window instanceof AboutDialog) {
      return;
    }
  }
  AboutDialog aboutDialog=new AboutDialog();
  desktopPane.add(aboutDialog,JLayeredPane.POPUP_LAYER);
  aboutDialog.showDialog(VERSION);
}",0.9825870646766168
158620,"@Override public void uncaughtException(Thread t,Throwable e){
  logger.fatal(null,e);
}","@Override public void uncaughtException(Thread t,Throwable e){
  LOGGER.fatal(null,e);
}",0.9318181818181818
158621,"public static void removeDraft(UUID draftId){
  DraftPanel draftPanel=drafts.get(draftId);
  if (draftPanel != null) {
    drafts.remove(draftId);
    draftPanel.hideDraft();
  }
}","public static void removeDraft(UUID draftId){
  DraftPanel draftPanel=DRAFTS.get(draftId);
  if (draftPanel != null) {
    DRAFTS.remove(draftId);
    draftPanel.hideDraft();
  }
}",0.9333333333333332
158622,"public void startTasks(){
  if (session != null) {
    if (updateTablesTask == null || updateTablesTask.isDone()) {
      updateTablesTask=new UpdateTablesTask(session,roomId,this);
      updateTablesTask.execute();
    }
    if (updatePlayersTask == null || updatePlayersTask.isDone()) {
      updatePlayersTask=new UpdatePlayersTask(session,roomId,this.chatPanelMain);
      updatePlayersTask.execute();
    }
    if (this.btnStateFinished.isSelected()) {
      if (updateMatchesTask == null || updateMatchesTask.isDone()) {
        updateMatchesTask=new UpdateMatchesTask(session,roomId,this);
        updateMatchesTask.execute();
      }
    }
 else {
      if (updateMatchesTask != null) {
        updateMatchesTask.cancel(true);
      }
    }
  }
}","public void startTasks(){
  if (session != null) {
    if (updateTablesTask == null || updateTablesTask.isDone()) {
      updateTablesTask=new UpdateTablesTask(session,roomId,this);
      updateTablesTask.execute();
    }
    if (updatePlayersTask == null || updatePlayersTask.isDone()) {
      updatePlayersTask=new UpdatePlayersTask(session,roomId,this.chatPanelMain);
      updatePlayersTask.execute();
    }
    if (this.btnStateFinished.isSelected()) {
      if (updateMatchesTask == null || updateMatchesTask.isDone()) {
        updateMatchesTask=new UpdateMatchesTask(session,roomId,this);
        updateMatchesTask.execute();
      }
    }
 else     if (updateMatchesTask != null) {
      updateMatchesTask.cancel(true);
    }
  }
}",0.9437751004016064
158623,"@Override public Object getValueAt(int arg0,int arg1){
switch (arg1) {
case 0:
    return matches[arg0].getDeckType();
case 1:
  return matches[arg0].getPlayers();
case 2:
return matches[arg0].getGameType();
case 3:
return matches[arg0].getResult();
case 4:
if (matches[arg0].getStartTime() != null) {
return timeFormatter.format(matches[arg0].getStartTime());
}
 else {
return ""String_Node_Str"";
}
case 5:
if (matches[arg0].getEndTime() != null) {
return timeFormatter.format(matches[arg0].getEndTime());
}
 else {
return ""String_Node_Str"";
}
case 6:
if (matches[arg0].isTournament()) {
return ""String_Node_Str"";
}
 else {
if (matches[arg0].isReplayAvailable()) {
return ""String_Node_Str"";
}
 else {
return ""String_Node_Str"";
}
}
case 7:
return matches[arg0].getGames();
}
return ""String_Node_Str"";
}","@Override public Object getValueAt(int arg0,int arg1){
switch (arg1) {
case 0:
    return matches[arg0].getDeckType();
case 1:
  return matches[arg0].getPlayers();
case 2:
return matches[arg0].getGameType();
case 3:
return matches[arg0].getResult();
case 4:
if (matches[arg0].getStartTime() != null) {
return timeFormatter.format(matches[arg0].getStartTime());
}
 else {
return ""String_Node_Str"";
}
case 5:
if (matches[arg0].getEndTime() != null) {
return timeFormatter.format(matches[arg0].getEndTime());
}
 else {
return ""String_Node_Str"";
}
case 6:
if (matches[arg0].isTournament()) {
return ""String_Node_Str"";
}
 else if (matches[arg0].isReplayAvailable()) {
return ""String_Node_Str"";
}
 else {
return ""String_Node_Str"";
}
case 7:
return matches[arg0].getGames();
}
return ""String_Node_Str"";
}",0.9974968710888612
158624,"private void btnQuickStartActionPerformed(java.awt.event.ActionEvent evt){
  TableView table;
  try {
    File f=new File(""String_Node_Str"");
    if (!f.exists()) {
      JOptionPane.showMessageDialog(null,""String_Node_Str"",""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
      return;
    }
    MatchOptions options=new MatchOptions(""String_Node_Str"",""String_Node_Str"");
    options.getPlayerTypes().add(""String_Node_Str"");
    options.getPlayerTypes().add(""String_Node_Str"");
    options.setDeckType(""String_Node_Str"");
    options.setAttackOption(MultiplayerAttackOption.LEFT);
    options.setRange(RangeOfInfluence.ALL);
    options.setWinsNeeded(1);
    options.setMatchTimeLimit(MatchTimeLimit.NONE);
    options.setFreeMulligans(2);
    options.setSkillLevel(SkillLevel.CASUAL);
    options.setRollbackTurnsAllowed(true);
    table=session.createTable(roomId,options);
    session.joinTable(roomId,table.getTableId(),""String_Node_Str"",""String_Node_Str"",1,DeckImporterUtil.importDeck(""String_Node_Str""),""String_Node_Str"");
    session.joinTable(roomId,table.getTableId(),""String_Node_Str"",""String_Node_Str"",5,DeckImporterUtil.importDeck(""String_Node_Str""),""String_Node_Str"");
    session.startMatch(roomId,table.getTableId());
  }
 catch (  HeadlessException ex) {
    handleError(ex);
  }
}","private void btnQuickStartActionPerformed(java.awt.event.ActionEvent evt){
  TableView table;
  try {
    File f=new File(""String_Node_Str"");
    if (!f.exists()) {
      JOptionPane.showMessageDialog(null,""String_Node_Str"",""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
      return;
    }
    MatchOptions options=new MatchOptions(""String_Node_Str"",""String_Node_Str"");
    options.getPlayerTypes().add(""String_Node_Str"");
    options.getPlayerTypes().add(""String_Node_Str"");
    options.setDeckType(""String_Node_Str"");
    options.setAttackOption(MultiplayerAttackOption.LEFT);
    options.setRange(RangeOfInfluence.ALL);
    options.setWinsNeeded(1);
    options.setMatchTimeLimit(MatchTimeLimit.NONE);
    options.setFreeMulligans(2);
    options.setSkillLevel(SkillLevel.CASUAL);
    options.setRollbackTurnsAllowed(true);
    options.setQuitRatio(100);
    table=session.createTable(roomId,options);
    session.joinTable(roomId,table.getTableId(),""String_Node_Str"",""String_Node_Str"",1,DeckImporterUtil.importDeck(""String_Node_Str""),""String_Node_Str"");
    session.joinTable(roomId,table.getTableId(),""String_Node_Str"",""String_Node_Str"",5,DeckImporterUtil.importDeck(""String_Node_Str""),""String_Node_Str"");
    session.startMatch(roomId,table.getTableId());
  }
 catch (  HeadlessException ex) {
    handleError(ex);
  }
}",0.9881724532621136
158625,"public void handleException(Exception ex){
  if (ex != null) {
    logger.fatal(""String_Node_Str"" + (ex.getMessage() == null ? ""String_Node_Str"" : ex.getMessage()));
    if (ex.getCause() != null) {
      logger.debug(""String_Node_Str"" + (ex.getCause().getMessage() == null ? ""String_Node_Str"" : ex.getCause().getMessage()));
    }
    ex.printStackTrace();
  }
 else {
    logger.fatal(""String_Node_Str"");
  }
}","public void handleException(Exception ex){
  if (ex != null) {
    LOGGER.fatal(""String_Node_Str"" + (ex.getMessage() == null ? ""String_Node_Str"" : ex.getMessage()));
    if (ex.getCause() != null) {
      LOGGER.debug(""String_Node_Str"" + (ex.getCause().getMessage() == null ? ""String_Node_Str"" : ex.getCause().getMessage()));
    }
    ex.printStackTrace();
  }
 else {
    LOGGER.fatal(""String_Node_Str"");
  }
}",0.9563106796116504
158626,"public void updateUserHistory(){
  callExecutor.execute(new Runnable(){
    @Override public void run(){
      for (      String updatedUser : UserStatsRepository.instance.updateUserStats()) {
        User user=getUserByName(updatedUser);
        if (user != null) {
          user.resetUserStats();
        }
      }
    }
  }
);
}","public void updateUserHistory(){
  CALL_EXECUTOR.execute(new Runnable(){
    @Override public void run(){
      for (      String updatedUser : UserStatsRepository.instance.updateUserStats()) {
        User user=getUserByName(updatedUser);
        if (user != null) {
          user.resetUserStats();
        }
      }
    }
  }
);
}",0.9654135338345864
158627,"public void removeUser(final UUID userId,final DisconnectReason reason){
  if (userId != null) {
    final User user=users.get(userId);
    if (user != null) {
      callExecutor.execute(new Runnable(){
        @Override public void run(){
          try {
            logger.info(""String_Node_Str"" + user.getName() + ""String_Node_Str""+ reason.toString()+ ""String_Node_Str""+ userId);
            user.remove(reason);
            logger.debug(""String_Node_Str"" + user.getName());
          }
 catch (          Exception ex) {
            handleException(ex);
          }
 finally {
            users.remove(userId);
            usersByName.remove(user.getName());
          }
        }
      }
);
    }
 else {
      logger.warn(""String_Node_Str"" + userId + ""String_Node_Str"");
    }
  }
}","public void removeUser(final UUID userId,final DisconnectReason reason){
  if (userId != null) {
    final User user=users.get(userId);
    if (user != null) {
      CALL_EXECUTOR.execute(new Runnable(){
        @Override public void run(){
          try {
            LOGGER.info(""String_Node_Str"" + user.getName() + ""String_Node_Str""+ reason.toString()+ ""String_Node_Str""+ userId);
            user.remove(reason);
            LOGGER.debug(""String_Node_Str"" + user.getName());
          }
 catch (          Exception ex) {
            handleException(ex);
          }
 finally {
            users.remove(userId);
            usersByName.remove(user.getName());
          }
        }
      }
);
    }
 else {
      LOGGER.warn(""String_Node_Str"" + userId + ""String_Node_Str"");
    }
  }
}",0.9625396825396826
158628,"@Override public int calculate(Game game,Ability sourceAbility,Effect effect){
  int count=0;
  for (  UUID playerId : game.getPlayer(sourceAbility.getControllerId()).getInRange()) {
    Player player=game.getPlayer(playerId);
    if (player != null) {
      count+=player.getGraveyard().size();
    }
  }
  return count;
}","@Override public int calculate(Game game,Ability sourceAbility,Effect effect){
  int count=0;
  for (  UUID playerId : game.getState().getPlayersInRange(sourceAbility.getControllerId(),game)) {
    Player player=game.getPlayer(playerId);
    if (player != null) {
      count+=player.getGraveyard().size();
    }
  }
  return count;
}",0.943683409436834
158629,"@Override public boolean apply(Game game,Ability source){
  for (  Permanent permanent : game.getBattlefield().getActivePermanents(filter,source.getControllerId(),source.getSourceId(),game)) {
    permanent.moveToZone(Zone.HAND,source.getSourceId(),game,true);
  }
  for (  UUID playerId : game.getPlayer(source.getControllerId()).getInRange()) {
    Player player=game.getPlayer(playerId);
    if (player != null) {
      for (      Card card : player.getGraveyard().getCards(filter2,game)) {
        card.moveToZone(Zone.HAND,source.getSourceId(),game,true);
      }
    }
  }
  return true;
}","@Override public boolean apply(Game game,Ability source){
  for (  Permanent permanent : game.getBattlefield().getActivePermanents(filter,source.getControllerId(),source.getSourceId(),game)) {
    permanent.moveToZone(Zone.HAND,source.getSourceId(),game,true);
  }
  for (  UUID playerId : game.getState().getPlayersInRange(source.getControllerId(),game)) {
    Player player=game.getPlayer(playerId);
    if (player != null) {
      for (      Card card : player.getGraveyard().getCards(filter2,game)) {
        card.moveToZone(Zone.HAND,source.getSourceId(),game,true);
      }
    }
  }
  return true;
}",0.9691923397169026
158630,"@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller != null) {
    for (    UUID playerId : controller.getInRange()) {
      Player player=game.getPlayer(playerId);
      if (player != null) {
        for (        Card card : player.getHand().getCards(game)) {
          card.moveToZone(Zone.LIBRARY,source.getSourceId(),game,true);
        }
        for (        Card card : player.getGraveyard().getCards(game)) {
          card.moveToZone(Zone.LIBRARY,source.getSourceId(),game,true);
        }
        player.shuffleLibrary(game);
      }
    }
    for (    Card card : controller.getLibrary().getTopCards(game,10)) {
      controller.moveCardToExileWithInfo(card,null,""String_Node_Str"",source.getSourceId(),game,Zone.LIBRARY,true);
    }
    for (    UUID playerId : controller.getInRange()) {
      Player player=game.getPlayer(playerId);
      if (player != null) {
        int cardsToDrawCount=player.getAmount(0,7,""String_Node_Str"",game);
        player.drawCards(cardsToDrawCount,game);
      }
    }
  }
  return true;
}","@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller != null) {
    for (    UUID playerId : game.getState().getPlayersInRange(controller.getId(),game)) {
      Player player=game.getPlayer(playerId);
      if (player != null) {
        for (        Card card : player.getHand().getCards(game)) {
          card.moveToZone(Zone.LIBRARY,source.getSourceId(),game,true);
        }
        for (        Card card : player.getGraveyard().getCards(game)) {
          card.moveToZone(Zone.LIBRARY,source.getSourceId(),game,true);
        }
        player.shuffleLibrary(game);
      }
    }
    for (    Card card : controller.getLibrary().getTopCards(game,10)) {
      controller.moveCardToExileWithInfo(card,null,""String_Node_Str"",source.getSourceId(),game,Zone.LIBRARY,true);
    }
    for (    UUID playerId : game.getState().getPlayersInRange(controller.getId(),game)) {
      Player player=game.getPlayer(playerId);
      if (player != null) {
        int cardsToDrawCount=player.getAmount(0,7,""String_Node_Str"",game);
        player.drawCards(cardsToDrawCount,game);
      }
    }
  }
  return true;
}",0.945264986967854
158631,"@Override public boolean apply(Game game,Ability source){
  for (  UUID playerId : game.getPlayer(source.getControllerId()).getInRange()) {
    Player player=game.getPlayer(playerId);
    if (player != null) {
      player.gainLife(1,game);
    }
  }
  return true;
}","@Override public boolean apply(Game game,Ability source){
  for (  UUID playerId : game.getState().getPlayersInRange(source.getControllerId(),game)) {
    Player player=game.getPlayer(playerId);
    if (player != null) {
      player.gainLife(1,game);
    }
  }
  return true;
}",0.9284403669724772
158632,"@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller == null) {
    return false;
  }
  int amount=(new ManacostVariableValue()).calculate(game,source,this);
  if (amount > 0) {
    LinkedList<Permanent> sacrifices=new LinkedList<Permanent>();
    HashMap<UUID,Integer> lifePaidAmounts=new HashMap<UUID,Integer>();
    FilterCreaturePermanent filter=new FilterCreaturePermanent();
    for (    UUID playerId : controller.getInRange()) {
      Player player=game.getPlayer(playerId);
      List<Permanent> creatures=game.getBattlefield().getAllActivePermanents(filter,playerId,game);
      int lifePaid=0;
      int playerLife=player.getLife();
      for (      Permanent creature : creatures) {
        String message=""String_Node_Str"" + amount + ""String_Node_Str""+ creature.getName()+ ""String_Node_Str"";
        if (playerLife - amount - lifePaid >= 0 && player != null && player.chooseUse(Outcome.Neutral,message,source,game)) {
          game.informPlayers(player.getLogName() + ""String_Node_Str"" + amount+ ""String_Node_Str""+ creature.getName());
          lifePaid+=amount;
        }
 else {
          game.informPlayers(player.getLogName() + ""String_Node_Str"" + creature.getName());
          sacrifices.add(creature);
        }
      }
      lifePaidAmounts.put(playerId,lifePaid);
    }
    for (    UUID playerId : controller.getInRange()) {
      int lifePaid=lifePaidAmounts.get(playerId);
      if (lifePaid > 0) {
        Player player=game.getPlayer(playerId);
        if (player != null) {
          player.loseLife(lifePaid,game);
        }
      }
    }
    for (    Permanent creature : sacrifices) {
      creature.sacrifice(source.getSourceId(),game);
    }
  }
  return true;
}","@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller == null) {
    return false;
  }
  int amount=(new ManacostVariableValue()).calculate(game,source,this);
  if (amount > 0) {
    LinkedList<Permanent> sacrifices=new LinkedList<Permanent>();
    HashMap<UUID,Integer> lifePaidAmounts=new HashMap<UUID,Integer>();
    FilterCreaturePermanent filter=new FilterCreaturePermanent();
    for (    UUID playerId : game.getState().getPlayersInRange(controller.getId(),game)) {
      Player player=game.getPlayer(playerId);
      List<Permanent> creatures=game.getBattlefield().getAllActivePermanents(filter,playerId,game);
      int lifePaid=0;
      int playerLife=player.getLife();
      for (      Permanent creature : creatures) {
        String message=""String_Node_Str"" + amount + ""String_Node_Str""+ creature.getName()+ ""String_Node_Str"";
        if (playerLife - amount - lifePaid >= 0 && player != null && player.chooseUse(Outcome.Neutral,message,source,game)) {
          game.informPlayers(player.getLogName() + ""String_Node_Str"" + amount+ ""String_Node_Str""+ creature.getName());
          lifePaid+=amount;
        }
 else {
          game.informPlayers(player.getLogName() + ""String_Node_Str"" + creature.getName());
          sacrifices.add(creature);
        }
      }
      lifePaidAmounts.put(playerId,lifePaid);
    }
    for (    UUID playerId : game.getState().getPlayersInRange(controller.getId(),game)) {
      int lifePaid=lifePaidAmounts.get(playerId);
      if (lifePaid > 0) {
        Player player=game.getPlayer(playerId);
        if (player != null) {
          player.loseLife(lifePaid,game);
        }
      }
    }
    for (    Permanent creature : sacrifices) {
      creature.sacrifice(source.getSourceId(),game);
    }
  }
  return true;
}",0.9653083700440528
158633,"@Override public boolean apply(Game game,Ability source){
  Player sourcePlayer=game.getPlayer(source.getControllerId());
  Permanent permanent=game.getPermanent(source.getSourceId());
  if (permanent != null) {
    int amount=permanent.getCounters().getCount(CounterType.CHARGE);
    if (amount > 0) {
      for (      UUID playerId : sourcePlayer.getInRange()) {
        Player player=game.getPlayer(playerId);
        if (player != null) {
          player.drawCards(amount,game);
        }
      }
    }
  }
  return true;
}","@Override public boolean apply(Game game,Ability source){
  Player sourcePlayer=game.getPlayer(source.getControllerId());
  Permanent permanent=game.getPermanent(source.getSourceId());
  if (permanent != null) {
    int amount=permanent.getCounters().getCount(CounterType.CHARGE);
    if (amount > 0) {
      for (      UUID playerId : game.getState().getPlayersInRange(sourcePlayer.getId(),game)) {
        Player player=game.getPlayer(playerId);
        if (player != null) {
          player.drawCards(amount,game);
        }
      }
    }
  }
  return true;
}",0.9385884509624198
158634,"@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller == null) {
    return false;
  }
  HashSet<String> choices=new HashSet<>();
  choices.add(""String_Node_Str"");
  choices.add(""String_Node_Str"");
  choices.add(""String_Node_Str"");
  LinkedList<CardType> order=new LinkedList<>();
  ChoiceImpl choice=new ChoiceImpl(true);
  choice.setChoices(choices);
  while (controller.canRespond() && controller.choose(Outcome.Sacrifice,choice,game) && choices.size() > 1) {
    order.add(getCardType(choice.getChoice()));
    choices.remove(choice.getChoice());
    choice.clearChoice();
  }
  order.add(getCardType(choices.iterator().next()));
  LinkedList<UUID> sacrifices=new LinkedList<>();
  int count=1;
  for (  CardType cardType : order) {
    FilterControlledPermanent filter=new FilterControlledPermanent(cardType + ""String_Node_Str"");
    filter.add(new CardTypePredicate(cardType));
    for (    UUID playerId : controller.getInRange()) {
      int amount=Math.min(count,game.getBattlefield().countAll(filter,playerId,game));
      TargetControlledPermanent target=new TargetControlledPermanent(amount,amount,filter,false);
      Player player=game.getPlayer(playerId);
      if (player != null && player.choose(Outcome.Sacrifice,target,source.getSourceId(),game)) {
        sacrifices.addAll(target.getTargets());
      }
    }
    for (    UUID targetId : sacrifices) {
      Permanent permanent=game.getPermanent(targetId);
      if (permanent != null) {
        permanent.sacrifice(source.getSourceId(),game);
      }
    }
    sacrifices.clear();
    count++;
  }
  return true;
}","@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller == null) {
    return false;
  }
  HashSet<String> choices=new HashSet<>();
  choices.add(""String_Node_Str"");
  choices.add(""String_Node_Str"");
  choices.add(""String_Node_Str"");
  LinkedList<CardType> order=new LinkedList<>();
  ChoiceImpl choice=new ChoiceImpl(true);
  choice.setChoices(choices);
  while (controller.canRespond() && controller.choose(Outcome.Sacrifice,choice,game) && choices.size() > 1) {
    order.add(getCardType(choice.getChoice()));
    choices.remove(choice.getChoice());
    choice.clearChoice();
  }
  order.add(getCardType(choices.iterator().next()));
  LinkedList<UUID> sacrifices=new LinkedList<>();
  int count=1;
  for (  CardType cardType : order) {
    FilterControlledPermanent filter=new FilterControlledPermanent(cardType + ""String_Node_Str"");
    filter.add(new CardTypePredicate(cardType));
    for (    UUID playerId : game.getState().getPlayersInRange(controller.getId(),game)) {
      int amount=Math.min(count,game.getBattlefield().countAll(filter,playerId,game));
      TargetControlledPermanent target=new TargetControlledPermanent(amount,amount,filter,false);
      Player player=game.getPlayer(playerId);
      if (player != null && player.choose(Outcome.Sacrifice,target,source.getSourceId(),game)) {
        sacrifices.addAll(target.getTargets());
      }
    }
    for (    UUID targetId : sacrifices) {
      Permanent permanent=game.getPermanent(targetId);
      if (permanent != null) {
        permanent.sacrifice(source.getSourceId(),game);
      }
    }
    sacrifices.clear();
    count++;
  }
  return true;
}",0.9813222650459532
158635,"@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller != null) {
    for (    UUID playerId : controller.getInRange()) {
      Player player=game.getPlayer(playerId);
      if (player != null) {
        int damage=player.getLife() / 2;
        player.damage(damage,source.getSourceId(),game,false,true);
      }
    }
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller != null) {
    for (    UUID playerId : game.getState().getPlayersInRange(controller.getId(),game)) {
      Player player=game.getPlayer(playerId);
      if (player != null) {
        int damage=player.getLife() / 2;
        player.damage(damage,source.getSourceId(),game,false,true);
      }
    }
    return true;
  }
  return false;
}",0.9309967141292442
158636,"@Override public boolean apply(Game game,Ability source){
  PreventDamageToTargetEffect effect=new PreventDamageToTargetEffect(Duration.EndOfTurn,1);
  List<Permanent> permanents=game.getBattlefield().getActivePermanents(new FilterCreaturePermanent(),source.getControllerId(),game);
  for (  Permanent permanent : permanents) {
    effect.setTargetPointer(new FixedTarget(permanent.getId()));
    game.addEffect(effect,source);
  }
  for (  UUID playerId : game.getPlayer(source.getControllerId()).getInRange()) {
    Player player=game.getPlayer(playerId);
    if (player != null) {
      effect.setTargetPointer(new FixedTarget(player.getId()));
      game.addEffect(effect,source);
    }
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  PreventDamageToTargetEffect effect=new PreventDamageToTargetEffect(Duration.EndOfTurn,1);
  List<Permanent> permanents=game.getBattlefield().getActivePermanents(new FilterCreaturePermanent(),source.getControllerId(),game);
  for (  Permanent permanent : permanents) {
    effect.setTargetPointer(new FixedTarget(permanent.getId()));
    game.addEffect(effect,source);
  }
  for (  UUID playerId : game.getState().getPlayersInRange(source.getControllerId(),game)) {
    Player player=game.getPlayer(playerId);
    if (player != null) {
      effect.setTargetPointer(new FixedTarget(player.getId()));
      game.addEffect(effect,source);
    }
  }
  return false;
}",0.9658536585365852
158637,"@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller != null) {
    MageObject target=game.getObject(source.getSourceId());
    if (target != null) {
      HashSet<CardType> foundCardTypes=new HashSet<>();
      for (      UUID playerId : controller.getInRange()) {
        Player player=game.getPlayer(playerId);
        if (player != null) {
          for (          Card card : player.getGraveyard().getCards(game)) {
            foundCardTypes.addAll(card.getCardType());
          }
        }
      }
      int number=foundCardTypes.size();
      return number < 4;
    }
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller != null) {
    MageObject target=game.getObject(source.getSourceId());
    if (target != null) {
      HashSet<CardType> foundCardTypes=new HashSet<>();
      for (      UUID playerId : game.getState().getPlayersInRange(controller.getId(),game)) {
        Player player=game.getPlayer(playerId);
        if (player != null) {
          for (          Card card : player.getGraveyard().getCards(game)) {
            foundCardTypes.addAll(card.getCardType());
          }
        }
      }
      int number=foundCardTypes.size();
      return number < 4;
    }
  }
  return false;
}",0.9549678341672624
158638,"@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller != null) {
    Map<UUID,Map<Integer,Set<UUID>>> playerPermanents=new LinkedHashMap<>();
    PlayerList playerList=game.getState().getPlayerList().copy();
    while (!playerList.get().equals(source.getControllerId()) && controller.canRespond()) {
      playerList.getNext();
    }
    Player currentPlayer=game.getPlayer(playerList.get());
    Player nextPlayer;
    UUID firstNextPlayer=null;
    while (!getNextPlayerInDirection(true,playerList,game).equals(firstNextPlayer) && controller.canRespond()) {
      nextPlayer=game.getPlayer(playerList.get());
      if (nextPlayer == null) {
        return false;
      }
      if (firstNextPlayer == null) {
        firstNextPlayer=nextPlayer.getId();
      }
      if (!nextPlayer.canRespond()) {
        continue;
      }
      if (currentPlayer != null && controller.getInRange().contains(currentPlayer.getId())) {
        Map<Integer,Set<UUID>> playerPiles=new HashMap<>();
        for (int i=1; i < 4; i++) {
          playerPiles.put(i,new LinkedHashSet<UUID>());
        }
        playerPermanents.put(currentPlayer.getId(),playerPiles);
        for (int i=1; i < 3; i++) {
          FilterPermanent filter=new FilterPermanent(new StringBuilder(""String_Node_Str"").append(i == 1 ? ""String_Node_Str"" : ""String_Node_Str"").append(""String_Node_Str"").toString());
          filter.add(new ControllerIdPredicate(currentPlayer.getId()));
          Target target;
          if (i == 1) {
            target=new TargetPermanent(0,Integer.MAX_VALUE,filter,true);
          }
 else {
            target=new TargetSecondPilePermanent(playerPiles.get(1),filter);
          }
          target.setRequired(false);
          currentPlayer.chooseTarget(outcome,target,source,game);
          StringBuilder message=new StringBuilder(currentPlayer.getLogName()).append(""String_Node_Str"").append(i).append(""String_Node_Str"");
          if (target.getTargets().isEmpty()) {
            message.append(""String_Node_Str"");
          }
 else {
            for (            UUID permanentId : target.getTargets()) {
              Permanent permanent=game.getPermanent(permanentId);
              if (permanent != null) {
                message.append(permanent.getName()).append(""String_Node_Str"");
              }
            }
          }
          game.informPlayers(message.toString());
          playerPiles.get(i).addAll(target.getTargets());
        }
        StringBuilder message=new StringBuilder(currentPlayer.getLogName()).append(""String_Node_Str"");
        for (        Permanent permanent : game.getState().getBattlefield().getAllActivePermanents(currentPlayer.getId())) {
          if (!playerPiles.get(1).contains(permanent.getId()) && !playerPiles.get(2).contains(permanent.getId())) {
            playerPiles.get(3).add(permanent.getId());
            message.append(permanent.getName()).append(""String_Node_Str"");
          }
        }
        if (playerPiles.get(3).isEmpty()) {
          message.append(""String_Node_Str"");
        }
        game.informPlayers(message.toString());
      }
      currentPlayer=nextPlayer;
    }
    for (    Map.Entry<UUID,Map<Integer,Set<UUID>>> playerPiles : playerPermanents.entrySet()) {
      Player player=game.getPlayer(playerPiles.getKey());
      if (player != null) {
        int sacrificePile=rnd.nextInt(3) + 1;
        game.informPlayers(new StringBuilder(player.getLogName()).append(""String_Node_Str"").append(sacrificePile).toString());
        for (        UUID permanentId : playerPiles.getValue().get(sacrificePile)) {
          Permanent permanent=game.getPermanent(permanentId);
          if (permanent != null) {
            permanent.sacrifice(source.getSourceId(),game);
          }
        }
      }
    }
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller != null) {
    Map<UUID,Map<Integer,Set<UUID>>> playerPermanents=new LinkedHashMap<>();
    PlayerList playerList=game.getState().getPlayerList().copy();
    while (!playerList.get().equals(source.getControllerId()) && controller.canRespond()) {
      playerList.getNext();
    }
    Player currentPlayer=game.getPlayer(playerList.get());
    Player nextPlayer;
    UUID firstNextPlayer=null;
    while (!getNextPlayerInDirection(true,playerList,game).equals(firstNextPlayer) && controller.canRespond()) {
      nextPlayer=game.getPlayer(playerList.get());
      if (nextPlayer == null) {
        return false;
      }
      if (firstNextPlayer == null) {
        firstNextPlayer=nextPlayer.getId();
      }
      if (!nextPlayer.canRespond()) {
        continue;
      }
      if (currentPlayer != null && game.getState().getPlayersInRange(controller.getId(),game).contains(currentPlayer.getId())) {
        Map<Integer,Set<UUID>> playerPiles=new HashMap<>();
        for (int i=1; i < 4; i++) {
          playerPiles.put(i,new LinkedHashSet<UUID>());
        }
        playerPermanents.put(currentPlayer.getId(),playerPiles);
        for (int i=1; i < 3; i++) {
          FilterPermanent filter=new FilterPermanent(new StringBuilder(""String_Node_Str"").append(i == 1 ? ""String_Node_Str"" : ""String_Node_Str"").append(""String_Node_Str"").toString());
          filter.add(new ControllerIdPredicate(currentPlayer.getId()));
          Target target;
          if (i == 1) {
            target=new TargetPermanent(0,Integer.MAX_VALUE,filter,true);
          }
 else {
            target=new TargetSecondPilePermanent(playerPiles.get(1),filter);
          }
          target.setRequired(false);
          currentPlayer.chooseTarget(outcome,target,source,game);
          StringBuilder message=new StringBuilder(currentPlayer.getLogName()).append(""String_Node_Str"").append(i).append(""String_Node_Str"");
          if (target.getTargets().isEmpty()) {
            message.append(""String_Node_Str"");
          }
 else {
            for (            UUID permanentId : target.getTargets()) {
              Permanent permanent=game.getPermanent(permanentId);
              if (permanent != null) {
                message.append(permanent.getName()).append(""String_Node_Str"");
              }
            }
          }
          game.informPlayers(message.toString());
          playerPiles.get(i).addAll(target.getTargets());
        }
        StringBuilder message=new StringBuilder(currentPlayer.getLogName()).append(""String_Node_Str"");
        for (        Permanent permanent : game.getState().getBattlefield().getAllActivePermanents(currentPlayer.getId())) {
          if (!playerPiles.get(1).contains(permanent.getId()) && !playerPiles.get(2).contains(permanent.getId())) {
            playerPiles.get(3).add(permanent.getId());
            message.append(permanent.getName()).append(""String_Node_Str"");
          }
        }
        if (playerPiles.get(3).isEmpty()) {
          message.append(""String_Node_Str"");
        }
        game.informPlayers(message.toString());
      }
      currentPlayer=nextPlayer;
    }
    for (    Map.Entry<UUID,Map<Integer,Set<UUID>>> playerPiles : playerPermanents.entrySet()) {
      Player player=game.getPlayer(playerPiles.getKey());
      if (player != null) {
        int sacrificePile=rnd.nextInt(3) + 1;
        game.informPlayers(new StringBuilder(player.getLogName()).append(""String_Node_Str"").append(sacrificePile).toString());
        for (        UUID permanentId : playerPiles.getValue().get(sacrificePile)) {
          Permanent permanent=game.getPermanent(permanentId);
          if (permanent != null) {
            permanent.sacrifice(source.getSourceId(),game);
          }
        }
      }
    }
    return true;
  }
  return false;
}",0.9919323857087976
158639,"@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller != null) {
    Choice lifeChoice=new ChoiceImpl(true);
    Set<String> choices=new HashSet<String>();
    for (    UUID playerId : controller.getInRange()) {
      Player player=game.getPlayer(playerId);
      if (player != null) {
        choices.add(new StringBuilder(Integer.toString(player.getLife())).append(""String_Node_Str"").append(player.getLogName()).toString());
      }
    }
    lifeChoice.setChoices(choices);
    for (    UUID playersId : controller.getInRange()) {
      Player player=game.getPlayer(playersId);
      if (player != null) {
        String selectedChoice;
        if (choices.size() > 1) {
          lifeChoice.setMessage(""String_Node_Str"" + player.getLogName());
          controller.choose(Outcome.Detriment,lifeChoice,game);
          selectedChoice=lifeChoice.getChoice();
        }
 else {
          selectedChoice=choices.iterator().next();
        }
        int index=selectedChoice.indexOf(""String_Node_Str"");
        if (index > 0) {
          String lifeString=selectedChoice.substring(0,index);
          int life=Integer.parseInt(lifeString);
          player.setLife(life,game);
          choices.remove(selectedChoice);
          game.informPlayers(new StringBuilder(""String_Node_Str"").append(player.getLogName()).append(""String_Node_Str"").append(life).toString());
        }
      }
    }
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller != null) {
    Choice lifeChoice=new ChoiceImpl(true);
    Set<String> choices=new HashSet<String>();
    for (    UUID playerId : game.getState().getPlayersInRange(controller.getId(),game)) {
      Player player=game.getPlayer(playerId);
      if (player != null) {
        choices.add(new StringBuilder(Integer.toString(player.getLife())).append(""String_Node_Str"").append(player.getLogName()).toString());
      }
    }
    lifeChoice.setChoices(choices);
    for (    UUID playersId : game.getState().getPlayersInRange(controller.getId(),game)) {
      Player player=game.getPlayer(playersId);
      if (player != null) {
        String selectedChoice;
        if (choices.size() > 1) {
          lifeChoice.setMessage(""String_Node_Str"" + player.getLogName());
          controller.choose(Outcome.Detriment,lifeChoice,game);
          selectedChoice=lifeChoice.getChoice();
        }
 else {
          selectedChoice=choices.iterator().next();
        }
        int index=selectedChoice.indexOf(""String_Node_Str"");
        if (index > 0) {
          String lifeString=selectedChoice.substring(0,index);
          int life=Integer.parseInt(lifeString);
          player.setLife(life,game);
          choices.remove(selectedChoice);
          game.informPlayers(new StringBuilder(""String_Node_Str"").append(player.getLogName()).append(""String_Node_Str"").append(life).toString());
        }
      }
    }
  }
  return false;
}",0.9587426326129664
158640,"@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller != null) {
    int xSum=0;
    xSum+=playerPaysXGenericMana(controller,source,game);
    for (    UUID playerId : controller.getInRange()) {
      if (playerId != controller.getId()) {
        Player player=game.getPlayer(playerId);
        if (player != null) {
          xSum+=playerPaysXGenericMana(player,source,game);
        }
      }
    }
    if (xSum > 0) {
      for (      UUID playerId : controller.getInRange()) {
        Effect effect=new CreateTokenTargetEffect(new SoldierToken(),xSum);
        effect.setTargetPointer(new FixedTarget(playerId));
        effect.apply(game,source);
      }
    }
    controller.resetStoredBookmark(game);
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller != null) {
    int xSum=0;
    xSum+=playerPaysXGenericMana(controller,source,game);
    for (    UUID playerId : game.getState().getPlayersInRange(controller.getId(),game)) {
      if (playerId != controller.getId()) {
        Player player=game.getPlayer(playerId);
        if (player != null) {
          xSum+=playerPaysXGenericMana(player,source,game);
        }
      }
    }
    if (xSum > 0) {
      for (      UUID playerId : game.getState().getPlayersInRange(controller.getId(),game)) {
        Effect effect=new CreateTokenTargetEffect(new SoldierToken(),xSum);
        effect.setTargetPointer(new FixedTarget(playerId));
        effect.apply(game,source);
      }
    }
    controller.resetStoredBookmark(game);
    return true;
  }
  return false;
}",0.9270833333333334
158641,"@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller != null) {
    int xSum=0;
    xSum+=playerPaysXGenericMana(controller,source,game);
    for (    UUID playerId : controller.getInRange()) {
      if (playerId != controller.getId()) {
        Player player=game.getPlayer(playerId);
        if (player != null) {
          xSum+=playerPaysXGenericMana(player,source,game);
        }
      }
    }
    for (    UUID playerId : controller.getInRange()) {
      Player player=game.getPlayer(playerId);
      if (player != null) {
        TargetCardInLibrary target=new TargetCardInLibrary(0,xSum,new FilterBasicLandCard());
        if (player.searchLibrary(target,game)) {
          for (          UUID cardId : target.getTargets()) {
            Card card=player.getLibrary().getCard(cardId,game);
            if (card != null) {
              card.putOntoBattlefield(game,Zone.LIBRARY,source.getSourceId(),player.getId(),true);
            }
          }
          player.shuffleLibrary(game);
        }
      }
    }
    controller.resetStoredBookmark(game);
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller != null) {
    int xSum=0;
    xSum+=playerPaysXGenericMana(controller,source,game);
    for (    UUID playerId : game.getState().getPlayersInRange(controller.getId(),game)) {
      if (playerId != controller.getId()) {
        Player player=game.getPlayer(playerId);
        if (player != null) {
          xSum+=playerPaysXGenericMana(player,source,game);
        }
      }
    }
    for (    UUID playerId : game.getState().getPlayersInRange(controller.getId(),game)) {
      Player player=game.getPlayer(playerId);
      if (player != null) {
        TargetCardInLibrary target=new TargetCardInLibrary(0,xSum,new FilterBasicLandCard());
        if (player.searchLibrary(target,game)) {
          for (          UUID cardId : target.getTargets()) {
            Card card=player.getLibrary().getCard(cardId,game);
            if (card != null) {
              card.putOntoBattlefield(game,Zone.LIBRARY,source.getSourceId(),player.getId(),true);
            }
          }
          player.shuffleLibrary(game);
        }
      }
    }
    controller.resetStoredBookmark(game);
    return true;
  }
  return false;
}",0.9482758620689656
158642,"@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller != null) {
    for (    UUID playerId : controller.getInRange()) {
      if (!playerId.equals(this.getTargetPointer().getFirst(game,source))) {
        Token token=new DragonToken2();
        token.putOntoBattlefield(1,game,source.getSourceId(),playerId);
      }
    }
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller != null) {
    for (    UUID playerId : game.getState().getPlayersInRange(controller.getId(),game)) {
      if (!playerId.equals(this.getTargetPointer().getFirst(game,source))) {
        Token token=new DragonToken2();
        token.putOntoBattlefield(1,game,source.getSourceId(),playerId);
      }
    }
    return true;
  }
  return false;
}",0.931891891891892
158643,"@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller != null) {
    int xSum=0;
    xSum+=playerPaysXGenericMana(controller,source,game);
    for (    UUID playerId : controller.getInRange()) {
      if (playerId != controller.getId()) {
        Player player=game.getPlayer(playerId);
        if (player != null) {
          xSum+=playerPaysXGenericMana(player,source,game);
        }
      }
    }
    ContinuousEffect effect=new BoostSourceEffect(xSum,0,Duration.EndOfTurn);
    game.addEffect(effect,source);
    controller.resetStoredBookmark(game);
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller != null) {
    int xSum=0;
    xSum+=playerPaysXGenericMana(controller,source,game);
    for (    UUID playerId : game.getState().getPlayersInRange(controller.getId(),game)) {
      if (playerId != controller.getId()) {
        Player player=game.getPlayer(playerId);
        if (player != null) {
          xSum+=playerPaysXGenericMana(player,source,game);
        }
      }
    }
    ContinuousEffect effect=new BoostSourceEffect(xSum,0,Duration.EndOfTurn);
    game.addEffect(effect,source);
    controller.resetStoredBookmark(game);
    return true;
  }
  return false;
}",0.9546436285097192
158644,"@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller != null) {
    int xSum=0;
    xSum+=playerPaysXGenericMana(controller,source,game);
    for (    UUID playerId : controller.getInRange()) {
      if (playerId != controller.getId()) {
        Player player=game.getPlayer(playerId);
        if (player != null) {
          xSum+=playerPaysXGenericMana(player,source,game);
        }
      }
    }
    if (xSum > 0) {
      for (      UUID playerId : controller.getInRange()) {
        Player player=game.getPlayer(playerId);
        if (player != null) {
          player.drawCards(xSum,game);
        }
      }
    }
    controller.resetStoredBookmark(game);
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller != null) {
    int xSum=0;
    xSum+=playerPaysXGenericMana(controller,source,game);
    for (    UUID playerId : game.getState().getPlayersInRange(controller.getId(),game)) {
      if (playerId != controller.getId()) {
        Player player=game.getPlayer(playerId);
        if (player != null) {
          xSum+=playerPaysXGenericMana(player,source,game);
        }
      }
    }
    if (xSum > 0) {
      for (      UUID playerId : game.getState().getPlayersInRange(controller.getId(),game)) {
        Player player=game.getPlayer(playerId);
        if (player != null) {
          player.drawCards(xSum,game);
        }
      }
    }
    controller.resetStoredBookmark(game);
    return true;
  }
  return false;
}",0.9231707317073172
158645,"@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller != null) {
    int xSum=0;
    xSum+=playerPaysXGenericMana(controller,source,game);
    for (    UUID playerId : controller.getInRange()) {
      if (playerId != controller.getId()) {
        Player player=game.getPlayer(playerId);
        if (player != null) {
          xSum+=playerPaysXGenericMana(player,source,game);
        }
      }
    }
    if (xSum > 0) {
      for (      UUID playerId : controller.getInRange()) {
        Effect effect=new PutTopCardOfLibraryIntoGraveTargetEffect(xSum);
        effect.setTargetPointer(new FixedTarget(playerId));
        effect.apply(game,source);
      }
    }
    controller.resetStoredBookmark(game);
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller != null) {
    int xSum=0;
    xSum+=playerPaysXGenericMana(controller,source,game);
    for (    UUID playerId : game.getState().getPlayersInRange(controller.getId(),game)) {
      if (playerId != controller.getId()) {
        Player player=game.getPlayer(playerId);
        if (player != null) {
          xSum+=playerPaysXGenericMana(player,source,game);
        }
      }
    }
    if (xSum > 0) {
      for (      UUID playerId : game.getState().getPlayersInRange(controller.getId(),game)) {
        Effect effect=new PutTopCardOfLibraryIntoGraveTargetEffect(xSum);
        effect.setTargetPointer(new FixedTarget(playerId));
        effect.apply(game,source);
      }
    }
    controller.resetStoredBookmark(game);
    return true;
  }
  return false;
}",0.9269141531322506
158646,"@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller != null) {
    List<Player> usingPlayers=new ArrayList<>();
    this.chooseAndSearchLibrary(usingPlayers,controller,source,game);
    for (    UUID playerId : controller.getInRange()) {
      if (!playerId.equals(controller.getId())) {
        Player player=game.getPlayer(playerId);
        if (player != null) {
          this.chooseAndSearchLibrary(usingPlayers,player,source,game);
        }
      }
    }
    for (    Player player : usingPlayers) {
      player.shuffleLibrary(game);
    }
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller != null) {
    List<Player> usingPlayers=new ArrayList<>();
    this.chooseAndSearchLibrary(usingPlayers,controller,source,game);
    for (    UUID playerId : game.getState().getPlayersInRange(controller.getId(),game)) {
      if (!playerId.equals(controller.getId())) {
        Player player=game.getPlayer(playerId);
        if (player != null) {
          this.chooseAndSearchLibrary(usingPlayers,player,source,game);
        }
      }
    }
    for (    Player player : usingPlayers) {
      player.shuffleLibrary(game);
    }
    return true;
  }
  return false;
}",0.954248366013072
158647,"@Override public void init(Ability source,Game game){
  super.init(source,game);
  Player controller=game.getPlayer(source.getControllerId());
  if (controller != null) {
    for (    UUID playerId : controller.getInRange()) {
      FilterPermanent playerFilter=filter.copy();
      playerFilter.add(new OwnerIdPredicate(playerId));
      for (      Permanent permanent : game.getBattlefield().getActivePermanents(playerFilter,playerId,game)) {
        affectedObjectList.add(new MageObjectReference(permanent,game));
      }
    }
  }
}","@Override public void init(Ability source,Game game){
  super.init(source,game);
  Player controller=game.getPlayer(source.getControllerId());
  if (controller != null) {
    for (    UUID playerId : game.getState().getPlayersInRange(controller.getId(),game)) {
      FilterPermanent playerFilter=filter.copy();
      playerFilter.add(new OwnerIdPredicate(playerId));
      for (      Permanent permanent : game.getBattlefield().getActivePermanents(playerFilter,playerId,game)) {
        affectedObjectList.add(new MageObjectReference(permanent,game));
      }
    }
  }
}",0.9431920649233544
158648,"public String getUserHistory(String userName){
  User user=getUserByName(userName);
  if (user == null) {
    UserStats userStats=UserStatsRepository.instance.getUser(userName);
    if (userStats == null) {
      return ""String_Node_Str"" + userName + ""String_Node_Str"";
    }
    return User.userStatsToString(userStats.getProto());
  }
  return ""String_Node_Str"" + userName + ""String_Node_Str""+ user.getUserData().getHistory();
}","public String getUserHistory(String userName){
  User user=getUserByName(userName);
  if (user == null) {
    UserStats userStats=UserStatsRepository.instance.getUser(userName);
    if (userStats == null) {
      return ""String_Node_Str"" + userName + ""String_Node_Str"";
    }
    return ""String_Node_Str"" + userName + ""String_Node_Str""+ User.userStatsToMatchHistory(userStats.getProto())+ ""String_Node_Str""+ User.userStatsToTourneyHistory(userStats.getProto());
  }
  return ""String_Node_Str"" + userName + ""String_Node_Str""+ user.getUserData().getMatchHistory()+ ""String_Node_Str""+ user.getUserData().getTourneyHistory();
}",0.805318138651472
158649,"@Override public boolean applies(GameEvent event,Ability source,Game game){
  if (event.getSourceId().equals(source.getSourceId())) {
    return (turnPhase == null || !game.getPhase().getType().equals(turnPhase)) && (phaseStep == null || !game.getTurn().getStepType().equals(phaseStep)) && (condition == null || !condition.apply(game,source));
  }
  return false;
}","@Override public boolean applies(GameEvent event,Ability source,Game game){
  if (event.getSourceId().equals(source.getSourceId())) {
    if ((turnPhase != null && !game.getPhase().getType().equals(turnPhase)) || (phaseStep != null && !game.getTurn().getStepType().equals(phaseStep)) || (condition != null && !condition.apply(game,source))) {
      return true;
    }
  }
  return false;
}",0.5570291777188329
158650,"@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  Permanent permanent=game.getPermanent(targetPointer.getFirst(game,source));
  if (permanent != null && controller != null) {
    if (permanent.isAttacking()) {
      if (controller.chooseUse(Outcome.Neutral,""String_Node_Str"" + permanent.getIdName() + ""String_Node_Str"",source,game)) {
        new PutOnLibraryTargetEffect(true).apply(game,source);
      }
    }
 else {
      new ReturnToHandTargetEffect(true).apply(game,source);
    }
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  Permanent permanent=game.getPermanent(targetPointer.getFirst(game,source));
  if (permanent != null && controller != null) {
    if (permanent.isAttacking()) {
      if (controller.chooseUse(Outcome.Neutral,""String_Node_Str"" + permanent.getIdName() + ""String_Node_Str"",source,game)) {
        new PutOnLibraryTargetEffect(true).apply(game,source);
      }
 else {
        new ReturnToHandTargetEffect(true).apply(game,source);
      }
    }
 else {
      new ReturnToHandTargetEffect(true).apply(game,source);
    }
    return true;
  }
  return false;
}",0.8939512961508248
158651,"public SeatView(Seat seat){
  if (seat.getPlayer() != null) {
    this.playerId=seat.getPlayer().getId();
    this.playerName=seat.getPlayer().getName();
    if (seat.getPlayer().getUserData() == null) {
      this.flagName=UserData.getDefaultFlagName();
      this.history=""String_Node_Str"";
    }
 else {
      this.flagName=seat.getPlayer().getUserData().getFlagName();
      this.history=seat.getPlayer().getUserData().getHistory();
    }
  }
 else {
    this.playerName=""String_Node_Str"";
    this.flagName=""String_Node_Str"";
    this.history=""String_Node_Str"";
  }
  this.playerType=seat.getPlayerType();
}","public SeatView(Seat seat){
  if (seat.getPlayer() != null) {
    this.playerId=seat.getPlayer().getId();
    this.playerName=seat.getPlayer().getName();
    if (seat.getPlayer().getUserData() == null) {
      this.flagName=UserData.getDefaultFlagName();
      this.history=""String_Node_Str"";
    }
 else {
      this.flagName=seat.getPlayer().getUserData().getFlagName();
      this.history=seat.getPlayer().getUserData().getMatchHistory() + ""String_Node_Str"" + seat.getPlayer().getUserData().getTourneyHistory();
    }
  }
 else {
    this.playerName=""String_Node_Str"";
    this.flagName=""String_Node_Str"";
    this.history=""String_Node_Str"";
  }
  this.playerType=seat.getPlayerType();
}",0.9400921658986175
158652,"@Override public boolean hasSourceObjectAbility(Game game,MageObject source,GameEvent event){
  MageObject object=source;
  if (object == null) {
    object=game.getPermanentEntering(getSourceId());
    if (object == null) {
      object=game.getObject(getSourceId());
    }
  }
  if (object != null && !object.getAbilities().contains(this)) {
    if (object instanceof Permanent) {
      return false;
    }
 else {
      Abilities<Ability> otherAbilities=game.getState().getAllOtherAbilities(this.getSourceId());
      if (otherAbilities == null || !otherAbilities.contains(this)) {
        return false;
      }
    }
  }
  if (object instanceof Permanent) {
    return ((Permanent)object).isPhasedIn();
  }
  return true;
}","@Override public boolean hasSourceObjectAbility(Game game,MageObject source,GameEvent event){
  MageObject object=source;
  if (object == null) {
    object=game.getPermanentEntering(getSourceId());
    if (object == null) {
      object=game.getObject(getSourceId());
    }
  }
  if (object != null) {
    if (object instanceof Permanent) {
      if (!((Permanent)object).getAbilities(game).contains(this)) {
        return false;
      }
      return ((Permanent)object).isPhasedIn();
    }
 else     if (!object.getAbilities().contains(this)) {
      Abilities<Ability> otherAbilities=game.getState().getAllOtherAbilities(this.getSourceId());
      if (otherAbilities == null || !otherAbilities.contains(this)) {
        return false;
      }
    }
  }
  return true;
}",0.7511674449633089
158653,"@Override public void setSourceId(UUID sourceId){
  if (this.sourceId == null) {
    this.sourceId=sourceId;
  }
 else {
    if (!(this instanceof MageSingleton)) {
      this.sourceId=sourceId;
    }
  }
  if (subAbilities != null) {
    for (    Ability subAbility : subAbilities) {
      subAbility.setSourceId(sourceId);
    }
  }
  if (watchers != null) {
    for (    Watcher watcher : watchers) {
      watcher.setSourceId(sourceId);
    }
  }
}","@Override public void setSourceId(UUID sourceId){
  if (this.sourceId == null) {
    this.sourceId=sourceId;
  }
 else   if (!(this instanceof MageSingleton)) {
    this.sourceId=sourceId;
  }
  if (subAbilities != null) {
    for (    Ability subAbility : subAbilities) {
      subAbility.setSourceId(sourceId);
    }
  }
  if (watchers != null) {
    for (    Watcher watcher : watchers) {
      watcher.setSourceId(sourceId);
    }
  }
}",0.9865470852017936
158654,"protected String getMessageText(Game game){
  StringBuilder sb=threadLocalBuilder.get();
  MageObject object=game.getObject(this.sourceId);
  if (object != null) {
    if (object instanceof StackAbility) {
      Card card=game.getCard(((StackAbility)object).getSourceId());
      if (card != null) {
        sb.append(GameLog.getColoredObjectIdName(card));
      }
 else {
        sb.append(GameLog.getColoredObjectIdName(object));
      }
    }
 else {
      if (object instanceof Spell) {
        Spell spell=(Spell)object;
        String castText=spell.getSpellCastText(game);
        sb.append((castText.startsWith(""String_Node_Str"") ? castText.substring(5) : castText));
        if (spell.getFromZone() == Zone.GRAVEYARD) {
          sb.append(""String_Node_Str"");
        }
        sb.append(getOptionalTextSuffix(game,spell));
      }
 else {
        sb.append(GameLog.getColoredObjectIdName(object));
      }
    }
  }
 else {
    sb.append(""String_Node_Str"");
  }
  if (object instanceof Spell && ((Spell)object).getSpellAbilities().size() > 1) {
    if (((Spell)object).getSpellAbility().getSpellAbilityType().equals(SpellAbilityType.SPLIT_FUSED)) {
      Spell spell=(Spell)object;
      int i=0;
      for (      SpellAbility spellAbility : spell.getSpellAbilities()) {
        i++;
        String half;
        if (i == 1) {
          half=""String_Node_Str"";
        }
 else {
          half=""String_Node_Str"";
        }
        if (spellAbility.getTargets().size() > 0) {
          sb.append(half).append(""String_Node_Str"");
          for (          Target target : spellAbility.getTargets()) {
            sb.append(target.getTargetedName(game));
          }
        }
      }
    }
 else {
      Spell spell=(Spell)object;
      int i=0;
      for (      SpellAbility spellAbility : spell.getSpellAbilities()) {
        i++;
        if (i > 1) {
          sb.append(""String_Node_Str"");
          if (spellAbility.name.length() > 5 && spellAbility.name.startsWith(""String_Node_Str"")) {
            sb.append(spellAbility.name.substring(5));
          }
 else {
            sb.append(spellAbility.name);
          }
        }
        sb.append(getTargetDescriptionForLog(spellAbility.getTargets(),game));
      }
    }
  }
 else   if (object instanceof Spell && ((Spell)object).getSpellAbility().getModes().size() > 1) {
    Modes spellModes=((Spell)object).getSpellAbility().getModes();
    for (    Mode selectedMode : spellModes.getSelectedModes()) {
      int item=0;
      for (      Mode mode : spellModes.values()) {
        item++;
        if (mode.getId().equals(selectedMode.getId())) {
          sb.append(""String_Node_Str"").append(item).append(""String_Node_Str"");
          sb.append(getTargetDescriptionForLog(selectedMode.getTargets(),game));
          break;
        }
      }
    }
  }
 else {
    sb.append(getTargetDescriptionForLog(getTargets(),game));
  }
  return sb.toString();
}","protected String getMessageText(Game game){
  StringBuilder sb=threadLocalBuilder.get();
  MageObject object=game.getObject(this.sourceId);
  if (object != null) {
    if (object instanceof StackAbility) {
      Card card=game.getCard(((StackAbility)object).getSourceId());
      if (card != null) {
        sb.append(GameLog.getColoredObjectIdName(card));
      }
 else {
        sb.append(GameLog.getColoredObjectIdName(object));
      }
    }
 else     if (object instanceof Spell) {
      Spell spell=(Spell)object;
      String castText=spell.getSpellCastText(game);
      sb.append((castText.startsWith(""String_Node_Str"") ? castText.substring(5) : castText));
      if (spell.getFromZone() == Zone.GRAVEYARD) {
        sb.append(""String_Node_Str"");
      }
      sb.append(getOptionalTextSuffix(game,spell));
    }
 else {
      sb.append(GameLog.getColoredObjectIdName(object));
    }
  }
 else {
    sb.append(""String_Node_Str"");
  }
  if (object instanceof Spell && ((Spell)object).getSpellAbilities().size() > 1) {
    if (((Spell)object).getSpellAbility().getSpellAbilityType().equals(SpellAbilityType.SPLIT_FUSED)) {
      Spell spell=(Spell)object;
      int i=0;
      for (      SpellAbility spellAbility : spell.getSpellAbilities()) {
        i++;
        String half;
        if (i == 1) {
          half=""String_Node_Str"";
        }
 else {
          half=""String_Node_Str"";
        }
        if (spellAbility.getTargets().size() > 0) {
          sb.append(half).append(""String_Node_Str"");
          for (          Target target : spellAbility.getTargets()) {
            sb.append(target.getTargetedName(game));
          }
        }
      }
    }
 else {
      Spell spell=(Spell)object;
      int i=0;
      for (      SpellAbility spellAbility : spell.getSpellAbilities()) {
        i++;
        if (i > 1) {
          sb.append(""String_Node_Str"");
          if (spellAbility.name.length() > 5 && spellAbility.name.startsWith(""String_Node_Str"")) {
            sb.append(spellAbility.name.substring(5));
          }
 else {
            sb.append(spellAbility.name);
          }
        }
        sb.append(getTargetDescriptionForLog(spellAbility.getTargets(),game));
      }
    }
  }
 else   if (object instanceof Spell && ((Spell)object).getSpellAbility().getModes().size() > 1) {
    Modes spellModes=((Spell)object).getSpellAbility().getModes();
    for (    Mode selectedMode : spellModes.getSelectedModes()) {
      int item=0;
      for (      Mode mode : spellModes.values()) {
        item++;
        if (mode.getId().equals(selectedMode.getId())) {
          sb.append(""String_Node_Str"").append(item).append(""String_Node_Str"");
          sb.append(getTargetDescriptionForLog(selectedMode.getTargets(),game));
          break;
        }
      }
    }
  }
 else {
    sb.append(getTargetDescriptionForLog(getTargets(),game));
  }
  return sb.toString();
}",0.9637806140048292
158655,"@Override public boolean checkTrigger(GameEvent event,Game game){
  ZoneChangeEvent zEvent=(ZoneChangeEvent)event;
  Permanent permanent=zEvent.getTarget();
  if (permanent != null && zEvent.getToZone() == Zone.GRAVEYARD && zEvent.getFromZone() == Zone.BATTLEFIELD && permanent.getId().equals(this.getSourceId())) {
    return true;
  }
  return false;
}","@Override public boolean checkTrigger(GameEvent event,Game game){
  if (event.getTargetId().equals(getSourceId())) {
    ZoneChangeEvent zEvent=(ZoneChangeEvent)event;
    Permanent permanent=zEvent.getTarget();
    if (permanent != null && zEvent.getToZone() == Zone.GRAVEYARD && zEvent.getFromZone() == Zone.BATTLEFIELD) {
      return true;
    }
  }
  return false;
}",0.7475862068965518
158656,"@Override public boolean apply(Game game,Ability source){
  return !game.getOpponents(source.getControllerId()).contains(game.getActivePlayerId());
}","@Override public boolean apply(Game game,Ability source){
  return game.getOpponents(source.getControllerId()).contains(game.getActivePlayerId());
}",0.9966329966329966
158657,"public static Condition getInstance(){
  return fInstance;
}","public static Condition getInstance(){
  return F_INSTANCE;
}",0.859504132231405
158658,"@Override public boolean replaceEvent(GameEvent event,Ability source,Game game){
  Zone fromZone=((ZoneChangeEvent)event).getFromZone();
  Card card=game.getCard(event.getTargetId());
  UUID sourceId=event.getSourceId();
  UUID controllerId=event.getPlayerId();
  if (card.isFaceDown(game)) {
    return false;
  }
  Object object=game.getState().getValue(""String_Node_Str"" + card.getId());
  if (object != null && object instanceof PermanentCard) {
    return false;
  }
  UUID targetId=null;
  MageObject sourceObject=game.getObject(sourceId);
  boolean enchantCardInGraveyard=false;
  if (sourceObject instanceof StackAbility) {
    StackAbility stackAbility=(StackAbility)sourceObject;
    if (!stackAbility.getEffects().isEmpty()) {
      targetId=stackAbility.getEffects().get(0).getTargetPointer().getFirst(game,stackAbility);
    }
  }
  game.applyEffects();
  if (targetId == null) {
    SpellAbility spellAbility=card.getSpellAbility();
    if (spellAbility.getTargets().isEmpty()) {
      for (      Ability ability : card.getAbilities(game)) {
        if ((ability instanceof SpellAbility) && SpellAbilityType.BASE_ALTERNATE.equals(((SpellAbility)ability).getSpellAbilityType()) && !ability.getTargets().isEmpty()) {
          spellAbility=(SpellAbility)ability;
          break;
        }
      }
    }
    if (spellAbility.getTargets().isEmpty()) {
      return false;
    }
    Target target=spellAbility.getTargets().get(0).copy();
    Outcome auraOutcome=Outcome.BoostCreature;
    for (    Effect effect : spellAbility.getEffects()) {
      if (effect instanceof AttachEffect) {
        auraOutcome=effect.getOutcome();
        break;
      }
    }
    enchantCardInGraveyard=target instanceof TargetCardInGraveyard;
    if (target != null) {
      target.setNotTarget(true);
      target.clearChosen();
    }
    Player player=game.getPlayer(card.getOwnerId());
    if (target != null && player != null && player.choose(auraOutcome,target,card.getId(),game)) {
      targetId=target.getFirstTarget();
    }
  }
  Card targetCard=null;
  Permanent targetPermanent=null;
  if (enchantCardInGraveyard) {
    targetCard=game.getCard(targetId);
  }
 else {
    targetPermanent=game.getPermanent(targetId);
  }
  Player targetPlayer=game.getPlayer(targetId);
  if (targetCard != null || targetPermanent != null || targetPlayer != null) {
    card.removeFromZone(game,fromZone,sourceId);
    card.updateZoneChangeCounter(game);
    PermanentCard permanent=new PermanentCard(card,card.getOwnerId(),game);
    game.getBattlefield().addPermanent(permanent);
    card.setZone(Zone.BATTLEFIELD,game);
    if (permanent.entersBattlefield(event.getSourceId(),game,fromZone,true)) {
      if (targetCard != null) {
        permanent.attachTo(targetCard.getId(),game);
      }
 else       if (targetPermanent != null) {
        targetPermanent.addAttachment(permanent.getId(),game);
      }
 else       if (targetPlayer != null) {
        targetPlayer.addAttachment(permanent.getId(),game);
      }
      game.applyEffects();
      game.fireEvent(new ZoneChangeEvent(permanent,controllerId,fromZone,Zone.BATTLEFIELD));
      return true;
    }
  }
  return false;
}","@Override public boolean replaceEvent(GameEvent event,Ability source,Game game){
  Zone fromZone=((ZoneChangeEvent)event).getFromZone();
  Card card=game.getCard(event.getTargetId());
  UUID sourceId=event.getSourceId();
  UUID controllerId=event.getPlayerId();
  if (card.isFaceDown(game)) {
    return false;
  }
  Object object=game.getState().getValue(""String_Node_Str"" + card.getId());
  if (object != null && object instanceof PermanentCard) {
    return false;
  }
  UUID targetId=null;
  MageObject sourceObject=game.getObject(sourceId);
  boolean enchantCardInGraveyard=false;
  if (sourceObject instanceof StackAbility) {
    StackAbility stackAbility=(StackAbility)sourceObject;
    if (!stackAbility.getEffects().isEmpty()) {
      targetId=stackAbility.getEffects().get(0).getTargetPointer().getFirst(game,stackAbility);
    }
  }
  game.applyEffects();
  Player controllingPlayer=null;
  if (targetId == null) {
    SpellAbility spellAbility=card.getSpellAbility();
    if (spellAbility.getTargets().isEmpty()) {
      for (      Ability ability : card.getAbilities(game)) {
        if ((ability instanceof SpellAbility) && SpellAbilityType.BASE_ALTERNATE.equals(((SpellAbility)ability).getSpellAbilityType()) && !ability.getTargets().isEmpty()) {
          spellAbility=(SpellAbility)ability;
          break;
        }
      }
    }
    if (spellAbility.getTargets().isEmpty()) {
      return false;
    }
    Target target=spellAbility.getTargets().get(0).copy();
    Outcome auraOutcome=Outcome.BoostCreature;
    for (    Effect effect : spellAbility.getEffects()) {
      if (effect instanceof AttachEffect) {
        auraOutcome=effect.getOutcome();
        break;
      }
    }
    enchantCardInGraveyard=target instanceof TargetCardInGraveyard;
    if (target != null) {
      target.setNotTarget(true);
      target.clearChosen();
    }
    if (event.getPlayerId() != null) {
      controllingPlayer=game.getPlayer(event.getPlayerId());
    }
 else {
      controllingPlayer=game.getPlayer(card.getOwnerId());
    }
    if (target != null && controllingPlayer != null && controllingPlayer.choose(auraOutcome,target,card.getId(),game)) {
      targetId=target.getFirstTarget();
    }
  }
  Card targetCard=null;
  Permanent targetPermanent=null;
  if (enchantCardInGraveyard) {
    targetCard=game.getCard(targetId);
  }
 else {
    targetPermanent=game.getPermanent(targetId);
  }
  Player targetPlayer=game.getPlayer(targetId);
  if (targetCard != null || targetPermanent != null || targetPlayer != null) {
    card.removeFromZone(game,fromZone,sourceId);
    card.updateZoneChangeCounter(game);
    PermanentCard permanent=new PermanentCard(card,(controllingPlayer == null ? card.getOwnerId() : controllingPlayer.getId()),game);
    game.getBattlefield().addPermanent(permanent);
    card.setZone(Zone.BATTLEFIELD,game);
    if (permanent.entersBattlefield(event.getSourceId(),game,fromZone,true)) {
      if (targetCard != null) {
        permanent.attachTo(targetCard.getId(),game);
      }
 else       if (targetPermanent != null) {
        targetPermanent.addAttachment(permanent.getId(),game);
      }
 else       if (targetPlayer != null) {
        targetPlayer.addAttachment(permanent.getId(),game);
      }
      game.applyEffects();
      game.fireEvent(new ZoneChangeEvent(permanent,controllerId,fromZone,Zone.BATTLEFIELD));
      return true;
    }
  }
  return false;
}",0.9624334600760456
158659,"public void addEffect(ContinuousEffect effect,Ability source){
  if (effect == null) {
    logger.error(""String_Node_Str"" + source.toString());
    return;
  }
 else   if (source == null) {
    logger.warn(""String_Node_Str"" + effect.toString());
  }
switch (effect.getEffectType()) {
case REPLACEMENT:
case REDIRECTION:
    ReplacementEffect newReplacementEffect=(ReplacementEffect)effect;
  replacementEffects.addEffect(newReplacementEffect,source);
break;
case PREVENTION:
PreventionEffect newPreventionEffect=(PreventionEffect)effect;
preventionEffects.addEffect(newPreventionEffect,source);
break;
case RESTRICTION:
RestrictionEffect newRestrictionEffect=(RestrictionEffect)effect;
restrictionEffects.addEffect(newRestrictionEffect,source);
break;
case RESTRICTION_UNTAP_NOT_MORE_THAN:
RestrictionUntapNotMoreThanEffect newRestrictionUntapNotMoreThanEffect=(RestrictionUntapNotMoreThanEffect)effect;
restrictionUntapNotMoreThanEffects.addEffect(newRestrictionUntapNotMoreThanEffect,source);
break;
case REQUIREMENT:
RequirementEffect newRequirementEffect=(RequirementEffect)effect;
requirementEffects.addEffect(newRequirementEffect,source);
break;
case ASTHOUGH:
AsThoughEffect newAsThoughEffect=(AsThoughEffect)effect;
if (!asThoughEffectsMap.containsKey(newAsThoughEffect.getAsThoughEffectType())) {
ContinuousEffectsList<AsThoughEffect> list=new ContinuousEffectsList<>();
allEffectsLists.add(list);
asThoughEffectsMap.put(newAsThoughEffect.getAsThoughEffectType(),list);
}
asThoughEffectsMap.get(newAsThoughEffect.getAsThoughEffectType()).addEffect(newAsThoughEffect,source);
break;
case COSTMODIFICATION:
CostModificationEffect newCostModificationEffect=(CostModificationEffect)effect;
costModificationEffects.addEffect(newCostModificationEffect,source);
break;
case SPLICE:
SpliceCardEffect newSpliceCardEffect=(SpliceCardEffect)effect;
spliceCardEffects.addEffect(newSpliceCardEffect,source);
break;
case CONTINUOUS_RULE_MODIFICATION:
ContinuousRuleModifyingEffect newContinuousRuleModifiyingEffect=(ContinuousRuleModifyingEffect)effect;
continuousRuleModifyingEffects.addEffect(newContinuousRuleModifiyingEffect,source);
break;
default :
layeredEffects.addEffect(effect,source);
break;
}
}","public void addEffect(ContinuousEffect effect,Ability source){
  if (effect == null) {
    LOGGER.error(""String_Node_Str"" + source.toString());
    return;
  }
 else   if (source == null) {
    LOGGER.warn(""String_Node_Str"" + effect.toString());
  }
switch (effect.getEffectType()) {
case REPLACEMENT:
case REDIRECTION:
    ReplacementEffect newReplacementEffect=(ReplacementEffect)effect;
  replacementEffects.addEffect(newReplacementEffect,source);
break;
case PREVENTION:
PreventionEffect newPreventionEffect=(PreventionEffect)effect;
preventionEffects.addEffect(newPreventionEffect,source);
break;
case RESTRICTION:
RestrictionEffect newRestrictionEffect=(RestrictionEffect)effect;
restrictionEffects.addEffect(newRestrictionEffect,source);
break;
case RESTRICTION_UNTAP_NOT_MORE_THAN:
RestrictionUntapNotMoreThanEffect newRestrictionUntapNotMoreThanEffect=(RestrictionUntapNotMoreThanEffect)effect;
restrictionUntapNotMoreThanEffects.addEffect(newRestrictionUntapNotMoreThanEffect,source);
break;
case REQUIREMENT:
RequirementEffect newRequirementEffect=(RequirementEffect)effect;
requirementEffects.addEffect(newRequirementEffect,source);
break;
case ASTHOUGH:
AsThoughEffect newAsThoughEffect=(AsThoughEffect)effect;
if (!asThoughEffectsMap.containsKey(newAsThoughEffect.getAsThoughEffectType())) {
ContinuousEffectsList<AsThoughEffect> list=new ContinuousEffectsList<>();
allEffectsLists.add(list);
asThoughEffectsMap.put(newAsThoughEffect.getAsThoughEffectType(),list);
}
asThoughEffectsMap.get(newAsThoughEffect.getAsThoughEffectType()).addEffect(newAsThoughEffect,source);
break;
case COSTMODIFICATION:
CostModificationEffect newCostModificationEffect=(CostModificationEffect)effect;
costModificationEffects.addEffect(newCostModificationEffect,source);
break;
case SPLICE:
SpliceCardEffect newSpliceCardEffect=(SpliceCardEffect)effect;
spliceCardEffects.addEffect(newSpliceCardEffect,source);
break;
case CONTINUOUS_RULE_MODIFICATION:
ContinuousRuleModifyingEffect newContinuousRuleModifiyingEffect=(ContinuousRuleModifyingEffect)effect;
continuousRuleModifyingEffects.addEffect(newContinuousRuleModifiyingEffect,source);
break;
default :
layeredEffects.addEffect(effect,source);
break;
}
}",0.9945479327578374
158660,"public boolean asThough(UUID objectId,AsThoughEffectType type,Ability affectedAbility,UUID controllerId,Game game){
  List<AsThoughEffect> asThoughEffectsList=getApplicableAsThoughEffects(type,game);
  for (  AsThoughEffect effect : asThoughEffectsList) {
    HashSet<Ability> abilities=asThoughEffectsMap.get(type).getAbility(effect.getId());
    for (    Ability ability : abilities) {
      if (affectedAbility == null) {
        if (effect.applies(objectId,ability,controllerId,game)) {
          return true;
        }
      }
 else {
        if (effect.applies(objectId,affectedAbility,ability,game)) {
          return true;
        }
      }
    }
  }
  return false;
}","public boolean asThough(UUID objectId,AsThoughEffectType type,Ability affectedAbility,UUID controllerId,Game game){
  List<AsThoughEffect> asThoughEffectsList=getApplicableAsThoughEffects(type,game);
  for (  AsThoughEffect effect : asThoughEffectsList) {
    HashSet<Ability> abilities=asThoughEffectsMap.get(type).getAbility(effect.getId());
    for (    Ability ability : abilities) {
      if (affectedAbility == null) {
        if (effect.applies(objectId,ability,controllerId,game)) {
          return true;
        }
      }
 else       if (effect.applies(objectId,affectedAbility,ability,game)) {
        return true;
      }
    }
  }
  return false;
}",0.8699551569506726
158661,"private boolean checkAbilityStillExists(Ability ability,ContinuousEffect effect,GameEvent event,Game game){
switch (effect.getDuration()) {
case EndOfCombat:
case EndOfGame:
case EndOfStep:
case EndOfTurn:
case OneUse:
case Custom:
    return true;
}
if (ability.getSourceId() == null) {
  return true;
}
MageObject object;
if (event.getType().equals(EventType.ZONE_CHANGE) && ((ZoneChangeEvent)event).getFromZone().equals(Zone.BATTLEFIELD) && event.getTargetId().equals(ability.getSourceId())) {
  object=((ZoneChangeEvent)event).getTarget();
}
 else {
  object=game.getObject(ability.getSourceId());
}
if (object == null) {
  return false;
}
boolean exists=true;
if (!object.getAbilities().contains(ability)) {
  exists=false;
  if (object instanceof PermanentCard) {
    PermanentCard permanent=(PermanentCard)object;
    if (permanent.canTransform() && event.getType() == GameEvent.EventType.TRANSFORMED) {
      exists=permanent.getCard().getAbilities().contains(ability);
    }
  }
}
 else {
  if (object instanceof PermanentCard) {
    PermanentCard permanent=(PermanentCard)object;
    if (permanent.isFaceDown(game) && !ability.getWorksFaceDown()) {
      return false;
    }
  }
 else   if (object instanceof Spell) {
    Spell spell=(Spell)object;
    if (spell.isFaceDown(game) && !ability.getWorksFaceDown()) {
      return false;
    }
  }
}
return exists;
}","private boolean checkAbilityStillExists(Ability ability,ContinuousEffect effect,GameEvent event,Game game){
switch (effect.getDuration()) {
case EndOfCombat:
case EndOfGame:
case EndOfStep:
case EndOfTurn:
case OneUse:
case Custom:
    return true;
}
if (ability.getSourceId() == null) {
  return true;
}
MageObject object;
if (event.getType().equals(EventType.ZONE_CHANGE) && ((ZoneChangeEvent)event).getFromZone().equals(Zone.BATTLEFIELD) && event.getTargetId().equals(ability.getSourceId())) {
  object=((ZoneChangeEvent)event).getTarget();
}
 else {
  object=game.getObject(ability.getSourceId());
}
if (object == null) {
  return false;
}
boolean exists=true;
if (!object.getAbilities().contains(ability)) {
  exists=false;
  if (object instanceof PermanentCard) {
    PermanentCard permanent=(PermanentCard)object;
    if (permanent.canTransform() && event.getType() == GameEvent.EventType.TRANSFORMED) {
      exists=permanent.getCard().getAbilities().contains(ability);
    }
  }
}
 else if (object instanceof PermanentCard) {
  PermanentCard permanent=(PermanentCard)object;
  if (permanent.isFaceDown(game) && !ability.getWorksFaceDown()) {
    return false;
  }
}
 else if (object instanceof Spell) {
  Spell spell=(Spell)object;
  if (spell.isFaceDown(game) && !ability.getWorksFaceDown()) {
    return false;
  }
}
return exists;
}",0.9005891016200295
158662,"public Map<String,String> getReplacementEffectsTexts(HashMap<ReplacementEffect,HashSet<Ability>> rEffects,Game game){
  Map<String,String> texts=new LinkedHashMap<>();
  for (  Map.Entry<ReplacementEffect,HashSet<Ability>> entry : rEffects.entrySet()) {
    if (entry.getValue() != null) {
      for (      Ability ability : entry.getValue()) {
        MageObject object=game.getObject(ability.getSourceId());
        if (object != null) {
          texts.put(ability.getId().toString() + ""String_Node_Str"" + entry.getKey().getId().toString(),object.getName() + ""String_Node_Str"" + ability.getRule(object.getName()));
        }
 else {
          texts.put(ability.getId().toString() + ""String_Node_Str"" + entry.getKey().getId().toString(),entry.getKey().getText(null));
        }
      }
    }
 else {
      logger.error(""String_Node_Str"" + entry.getKey().toString());
    }
  }
  return texts;
}","public Map<String,String> getReplacementEffectsTexts(HashMap<ReplacementEffect,HashSet<Ability>> rEffects,Game game){
  Map<String,String> texts=new LinkedHashMap<>();
  for (  Map.Entry<ReplacementEffect,HashSet<Ability>> entry : rEffects.entrySet()) {
    if (entry.getValue() != null) {
      for (      Ability ability : entry.getValue()) {
        MageObject object=game.getObject(ability.getSourceId());
        if (object != null) {
          texts.put(ability.getId().toString() + ""String_Node_Str"" + entry.getKey().getId().toString(),object.getName() + ""String_Node_Str"" + ability.getRule(object.getName()));
        }
 else {
          texts.put(ability.getId().toString() + ""String_Node_Str"" + entry.getKey().getId().toString(),entry.getKey().getText(null));
        }
      }
    }
 else {
      LOGGER.error(""String_Node_Str"" + entry.getKey().toString());
    }
  }
  return texts;
}",0.9933035714285714
158663,"public UUID getControllerOfSourceId(UUID sourceId){
  UUID controllerFound=null;
  for (  PreventionEffect effect : preventionEffects) {
    HashSet<Ability> abilities=preventionEffects.getAbility(effect.getId());
    for (    Ability ability : abilities) {
      if (ability.getSourceId().equals(sourceId)) {
        if (controllerFound == null || controllerFound.equals(ability.getControllerId())) {
          controllerFound=ability.getControllerId();
        }
 else {
          return null;
        }
      }
    }
  }
  for (  ReplacementEffect effect : replacementEffects) {
    HashSet<Ability> abilities=replacementEffects.getAbility(effect.getId());
    for (    Ability ability : abilities) {
      if (ability.getSourceId() != null) {
        if (ability.getSourceId().equals(sourceId)) {
          if (controllerFound == null || controllerFound.equals(ability.getControllerId())) {
            controllerFound=ability.getControllerId();
          }
 else {
            return null;
          }
        }
      }
 else {
        logger.warn(""String_Node_Str"" + ability.getRule());
      }
    }
  }
  return controllerFound;
}","public UUID getControllerOfSourceId(UUID sourceId){
  UUID controllerFound=null;
  for (  PreventionEffect effect : preventionEffects) {
    HashSet<Ability> abilities=preventionEffects.getAbility(effect.getId());
    for (    Ability ability : abilities) {
      if (ability.getSourceId().equals(sourceId)) {
        if (controllerFound == null || controllerFound.equals(ability.getControllerId())) {
          controllerFound=ability.getControllerId();
        }
 else {
          return null;
        }
      }
    }
  }
  for (  ReplacementEffect effect : replacementEffects) {
    HashSet<Ability> abilities=replacementEffects.getAbility(effect.getId());
    for (    Ability ability : abilities) {
      if (ability.getSourceId() != null) {
        if (ability.getSourceId().equals(sourceId)) {
          if (controllerFound == null || controllerFound.equals(ability.getControllerId())) {
            controllerFound=ability.getControllerId();
          }
 else {
            return null;
          }
        }
      }
 else {
        LOGGER.warn(""String_Node_Str"" + ability.getRule());
      }
    }
  }
  return controllerFound;
}",0.9947275922671354
158664,"private void setControllerForEffect(ContinuousEffectsList<?> effects,UUID sourceId,UUID controllerId){
  for (  Effect effect : effects) {
    HashSet<Ability> abilities=effects.getAbility(effect.getId());
    if (abilities != null) {
      for (      Ability ability : abilities) {
        if (ability.getSourceId() != null) {
          if (ability.getSourceId().equals(sourceId)) {
            ability.setControllerId(controllerId);
          }
        }
 else {
          if (!ability.getZone().equals(Zone.COMMAND)) {
            logger.fatal(""String_Node_Str"" + ability);
          }
        }
      }
    }
  }
}","private void setControllerForEffect(ContinuousEffectsList<?> effects,UUID sourceId,UUID controllerId){
  for (  Effect effect : effects) {
    HashSet<Ability> abilities=effects.getAbility(effect.getId());
    if (abilities != null) {
      for (      Ability ability : abilities) {
        if (ability.getSourceId() != null) {
          if (ability.getSourceId().equals(sourceId)) {
            ability.setControllerId(controllerId);
          }
        }
 else         if (!ability.getZone().equals(Zone.COMMAND)) {
          LOGGER.fatal(""String_Node_Str"" + ability);
        }
      }
    }
  }
}",0.9753694581280788
158665,"public List<ContinuousEffect> getLayeredEffects(Game game){
  List<ContinuousEffect> layerEffects=new ArrayList<>();
  for (  ContinuousEffect effect : layeredEffects) {
switch (effect.getDuration()) {
case WhileOnBattlefield:
case WhileOnStack:
case WhileInGraveyard:
      HashSet<Ability> abilities=layeredEffects.getAbility(effect.getId());
    if (abilities != null) {
      for (      Ability ability : abilities) {
        if (!(ability instanceof StaticAbility) || ability.isInUseableZone(game,null,null)) {
          layerEffects.add(effect);
          break;
        }
      }
    }
 else {
      logger.error(""String_Node_Str"" + effect.toString());
    }
  break;
default :
layerEffects.add(effect);
}
}
updateTimestamps(layerEffects);
Collections.sort(layerEffects,sorter);
return layerEffects;
}","public List<ContinuousEffect> getLayeredEffects(Game game){
  List<ContinuousEffect> layerEffects=new ArrayList<>();
  for (  ContinuousEffect effect : layeredEffects) {
switch (effect.getDuration()) {
case WhileOnBattlefield:
case WhileOnStack:
case WhileInGraveyard:
      HashSet<Ability> abilities=layeredEffects.getAbility(effect.getId());
    if (abilities != null) {
      for (      Ability ability : abilities) {
        if (!(ability instanceof StaticAbility) || ability.isInUseableZone(game,null,null)) {
          layerEffects.add(effect);
          break;
        }
      }
    }
 else {
      LOGGER.error(""String_Node_Str"" + effect.toString());
    }
  break;
default :
layerEffects.add(effect);
}
}
updateTimestamps(layerEffects);
Collections.sort(layerEffects,sorter);
return layerEffects;
}",0.9925742574257426
158666,"@Override public boolean apply(Game game,Ability source){
  UUID defendingPlayerId=(UUID)getValue(""String_Node_Str"");
  Player player=null;
  if (defendingPlayerId != null) {
    player=game.getPlayer(defendingPlayerId);
  }
  if (player != null) {
    int amount=Math.min(count,game.getBattlefield().countAll(filter,player.getId(),game));
    Target target=new TargetControlledPermanent(amount,amount,filter,true);
    if (target.canChoose(player.getId(),game)) {
      while (!target.isChosen() && target.canChoose(player.getId(),game) && player.canRespond()) {
        player.choose(Outcome.Sacrifice,target,source.getSourceId(),game);
      }
      for (int idx=0; idx < target.getTargets().size(); idx++) {
        Permanent permanent=game.getPermanent(target.getTargets().get(idx));
        if (permanent != null) {
          permanent.sacrifice(source.getSourceId(),game);
        }
      }
    }
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  UUID defendingPlayerId=(UUID)getValue(""String_Node_Str"");
  Player player=null;
  if (defendingPlayerId != null) {
    player=game.getPlayer(defendingPlayerId);
  }
  if (player != null) {
    int amount=Math.min(count,game.getBattlefield().countAll(FILTER,player.getId(),game));
    Target target=new TargetControlledPermanent(amount,amount,FILTER,true);
    if (target.canChoose(player.getId(),game)) {
      while (!target.isChosen() && target.canChoose(player.getId(),game) && player.canRespond()) {
        player.choose(Outcome.Sacrifice,target,source.getSourceId(),game);
      }
      for (int idx=0; idx < target.getTargets().size(); idx++) {
        Permanent permanent=game.getPermanent(target.getTargets().get(idx));
        if (permanent != null) {
          permanent.sacrifice(source.getSourceId(),game);
        }
      }
    }
    return true;
  }
  return false;
}",0.9575371549893844
158667,"/** 
 * Sets the job's state to   {@link State#ABORTED} and the error to the given exception. Logs a warning with thegiven message and exception.
 * @param message
 * @param error
 */
public void setError(String message,Exception error){
  if (message == null) {
    message=""String_Node_Str"" + this.getName() + ""String_Node_Str""+ this.getSource().toString()+ ""String_Node_Str""+ error.toString();
  }
  log.warn(message);
  this.state.setValue(State.ABORTED);
  this.error.setValue(error);
  this.message.setValue(message);
}","/** 
 * Sets the job's state to   {@link State#ABORTED} and the error to the givenexception. Logs a warning with the given message and exception.
 * @param message
 * @param error
 */
public void setError(String message,Exception error){
  if (message == null) {
    message=""String_Node_Str"" + this.getName() + ""String_Node_Str""+ this.getSource().toString()+ ""String_Node_Str""+ error.toString();
  }
  log.warn(message);
  this.state.setValue(State.ABORTED);
  this.error.setValue(error);
  this.message.setValue(message);
}",0.998095238095238
158668,"public static Destination toFile(final File file){
  return new Destination(){
    @Override public OutputStream open() throws IOException {
      File parent=file.getAbsoluteFile().getParentFile();
      if (!parent.mkdirs() && !parent.exists()) {
        throw new IOException(parent + ""String_Node_Str"");
      }
      return new FileOutputStream(file);
    }
    @Override public boolean exists(){
      return file.isFile();
    }
    @Override public void delete() throws IOException {
      if (file.exists() && !file.delete()) {
        throw new IOException(file + ""String_Node_Str"");
      }
    }
  }
;
}","public static Destination toFile(final File file){
  return new Destination(){
    @Override public OutputStream open() throws IOException {
      File parent=file.getAbsoluteFile().getParentFile();
      if (!parent.mkdirs() && !parent.exists()) {
        throw new IOException(parent + ""String_Node_Str"");
      }
      return new FileOutputStream(file);
    }
    @Override public boolean isValid() throws IOException {
      if (file.isFile()) {
        return file.length() > 0;
      }
      return false;
    }
    @Override public boolean exists(){
      return file.isFile();
    }
    @Override public void delete() throws IOException {
      if (file.exists() && !file.delete()) {
        throw new IOException(file + ""String_Node_Str"");
      }
    }
  }
;
}",0.8880866425992779
158669,"@Override public void onMessage(DownloadJob job){
synchronized (job) {
    if (job.getState() != State.NEW) {
      return;
    }
    job.setState(State.WORKING);
  }
  try {
    Source src=job.getSource();
    Destination dst=job.getDestination();
    BoundedRangeModel progress=job.getProgress();
    if (dst.exists()) {
      progress.setMaximum(1);
      progress.setValue(1);
    }
 else {
      progress.setMaximum(src.length());
      InputStream is=new BufferedInputStream(src.open());
      try {
        OutputStream os=new BufferedOutputStream(dst.open());
        try {
          byte[] buf=new byte[8 * 1024];
          int total=0;
          for (int len; (len=is.read(buf)) != -1; ) {
            if (job.getState() == State.ABORTED) {
              throw new IOException(""String_Node_Str"");
            }
            progress.setValue(total+=len);
            os.write(buf,0,len);
          }
        }
 catch (        IOException ex) {
          try {
            dst.delete();
          }
 catch (          IOException ex1) {
            logger.warn(""String_Node_Str"",ex1);
          }
          throw ex;
        }
 finally {
          try {
            os.close();
          }
 catch (          IOException ex) {
            logger.warn(""String_Node_Str"",ex);
          }
        }
      }
  finally {
        try {
          is.close();
        }
 catch (        IOException ex) {
          logger.warn(""String_Node_Str"",ex);
        }
      }
    }
    job.setState(State.FINISHED);
  }
 catch (  ConnectException ex) {
    String message;
    if (ex.getMessage() != null) {
      message=ex.getMessage();
    }
 else {
      message=""String_Node_Str"";
    }
    logger.warn(""String_Node_Str"" + job.getName() + ""String_Node_Str""+ job.getSource().toString()+ ""String_Node_Str""+ message);
  }
catch (  IOException ex) {
    job.setError(ex);
  }
}","@Override public void onMessage(DownloadJob job){
synchronized (job) {
    if (job.getState() != State.NEW) {
      return;
    }
    job.setState(State.WORKING);
  }
  try {
    Source src=job.getSource();
    Destination dst=job.getDestination();
    BoundedRangeModel progress=job.getProgress();
    if (dst.isValid()) {
      progress.setMaximum(1);
      progress.setValue(1);
    }
 else {
      if (dst.exists()) {
        try {
          dst.delete();
        }
 catch (        IOException ex1) {
          logger.warn(""String_Node_Str"",ex1);
        }
      }
      progress.setMaximum(src.length());
      InputStream is=new BufferedInputStream(src.open());
      try {
        OutputStream os=new BufferedOutputStream(dst.open());
        try {
          byte[] buf=new byte[8 * 1024];
          int total=0;
          for (int len; (len=is.read(buf)) != -1; ) {
            if (job.getState() == State.ABORTED) {
              throw new IOException(""String_Node_Str"");
            }
            progress.setValue(total+=len);
            os.write(buf,0,len);
          }
        }
 catch (        IOException ex) {
          try {
            dst.delete();
          }
 catch (          IOException ex1) {
            logger.warn(""String_Node_Str"",ex1);
          }
          throw ex;
        }
 finally {
          try {
            os.close();
          }
 catch (          IOException ex) {
            logger.warn(""String_Node_Str"",ex);
          }
        }
      }
  finally {
        try {
          is.close();
        }
 catch (        IOException ex) {
          logger.warn(""String_Node_Str"",ex);
        }
      }
    }
    job.setState(State.FINISHED);
  }
 catch (  ConnectException ex) {
    String message;
    if (ex.getMessage() != null) {
      message=ex.getMessage();
    }
 else {
      message=""String_Node_Str"";
    }
    logger.warn(""String_Node_Str"" + job.getName() + ""String_Node_Str""+ job.getSource().toString()+ ""String_Node_Str""+ message);
  }
catch (  IOException ex) {
    job.setError(ex);
  }
}",0.952405322415558
158670,"/** 
 * This test fails sometimes, probably because two plains are tapped for the first creature
 */
@Test public void testSimpleCast2(){
  addCard(Zone.HAND,playerA,""String_Node_Str"");
  addCard(Zone.HAND,playerA,""String_Node_Str"");
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"",2);
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"",2);
  setStopAt(1,PhaseStep.BEGIN_COMBAT);
  execute();
  assertPermanentCount(playerA,""String_Node_Str"",2);
}","/** 
 * This test fails sometimes, probably because two plains are tapped for the first creature
 */
@Test @Ignore public void testSimpleCast2(){
  addCard(Zone.HAND,playerA,""String_Node_Str"");
  addCard(Zone.HAND,playerA,""String_Node_Str"");
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"",2);
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"",2);
  setStopAt(1,PhaseStep.BEGIN_COMBAT);
  execute();
  assertPermanentCount(playerA,""String_Node_Str"",2);
}",0.9912663755458516
158671,"public void add(ManaType manaType,int amount){
switch (manaType) {
case BLACK:
    black+=amount;
  break;
case BLUE:
blue+=amount;
;
break;
case GREEN:
green+=amount;
;
break;
case RED:
red+=amount;
;
break;
case WHITE:
white+=amount;
;
break;
case COLORLESS:
generic+=amount;
;
break;
}
}","public void add(ManaType manaType,int amount){
switch (manaType) {
case BLACK:
    black+=amount;
  break;
case BLUE:
blue+=amount;
;
break;
case GREEN:
green+=amount;
;
break;
case RED:
red+=amount;
;
break;
case WHITE:
white+=amount;
;
break;
case COLORLESS:
colorless+=amount;
;
case GENERIC:
generic+=amount;
;
break;
}
}",0.943089430894309
158672,"public void clear(ManaType manaType){
switch (manaType) {
case BLACK:
    black=0;
  break;
case BLUE:
blue=0;
break;
case GREEN:
green=0;
break;
case RED:
red=0;
break;
case WHITE:
white=0;
break;
case COLORLESS:
generic=0;
break;
}
}","public void clear(ManaType manaType){
switch (manaType) {
case BLACK:
    black=0;
  break;
case BLUE:
blue=0;
break;
case GREEN:
green=0;
break;
case RED:
red=0;
break;
case WHITE:
white=0;
break;
case GENERIC:
generic=0;
break;
case COLORLESS:
colorless=0;
break;
}
}",0.9047619047619048
158673,"public void removeAll(FilterMana filter){
  if (filter == null) {
    return;
  }
  if (filter.isBlack()) {
    black=0;
  }
  if (filter.isBlue()) {
    blue=0;
  }
  if (filter.isWhite()) {
    white=0;
  }
  if (filter.isGreen()) {
    green=0;
  }
  if (filter.isRed()) {
    red=0;
  }
  if (filter.isGeneric()) {
    generic=0;
  }
}","public void removeAll(FilterMana filter){
  if (filter == null) {
    return;
  }
  if (filter.isBlack()) {
    black=0;
  }
  if (filter.isBlue()) {
    blue=0;
  }
  if (filter.isWhite()) {
    white=0;
  }
  if (filter.isGreen()) {
    green=0;
  }
  if (filter.isRed()) {
    red=0;
  }
  if (filter.isColorless()) {
    colorless=0;
  }
  if (filter.isGeneric()) {
    generic=0;
  }
}",0.9300411522633744
158674,"@Override public boolean apply(Game game,Ability source){
  Permanent permanent=game.getPermanent(source.getSourceId());
  if (permanent != null) {
    Player player=game.getPlayer(source.getControllerId());
    if (player != null) {
      TargetControlledPermanent target=new TargetControlledPermanent(1,1,filter,false);
      if (target.canChoose(player.getId(),game)) {
        player.choose(Outcome.Sacrifice,target,source.getSourceId(),game);
        Permanent artifactSacrifice=game.getPermanent(target.getFirstTarget());
        if (artifactSacrifice != null) {
          return artifactSacrifice.sacrifice(source.getSourceId(),game);
        }
 else {
          permanent.tap(game);
          player.damage(4,source.getSourceId(),game,false,true);
        }
      }
    }
    return true;
  }
  return false;
}","@java.lang.Override public boolean apply(Game game,Ability source){
  Permanent sourceObject=game.getPermanentOrLKIBattlefield(source.getSourceId());
  if (sourceObject != null) {
    Player controller=game.getPlayer(source.getControllerId());
    if (controller != null) {
      TargetControlledPermanent target=new TargetControlledPermanent(1,1,filter,true);
      if (target.canChoose(controller.getId(),game)) {
        controller.choose(Outcome.Sacrifice,target,source.getSourceId(),game);
        Permanent artifactSacrifice=game.getPermanent(target.getFirstTarget());
        if (artifactSacrifice != null) {
          artifactSacrifice.sacrifice(source.getSourceId(),game);
        }
      }
 else {
        sourceObject.tap(game);
        controller.damage(4,source.getSourceId(),game,false,true);
      }
    }
    return true;
  }
  return false;
}",0.8205128205128205
158675,"@Override public RustElementalEffect copy(){
  return new RustElementalEffect(this);
}","@java.lang.Override public RustElementalEffect copy(){
  return new RustElementalEffect(this);
}",0.945054945054945
158676,"@Override public boolean apply(Game game,Ability source){
  Mana types=getManaTypes(game,source);
  Choice choice=new ChoiceImpl(false);
  choice.setMessage(""String_Node_Str"");
  if (types.getBlack() > 0) {
    choice.getChoices().add(""String_Node_Str"");
  }
  if (types.getRed() > 0) {
    choice.getChoices().add(""String_Node_Str"");
  }
  if (types.getBlue() > 0) {
    choice.getChoices().add(""String_Node_Str"");
  }
  if (types.getGreen() > 0) {
    choice.getChoices().add(""String_Node_Str"");
  }
  if (types.getWhite() > 0) {
    choice.getChoices().add(""String_Node_Str"");
  }
  if (types.getGeneric() > 0) {
    choice.getChoices().add(""String_Node_Str"");
  }
  if (types.getAny() > 0) {
    choice.getChoices().add(""String_Node_Str"");
    choice.getChoices().add(""String_Node_Str"");
    choice.getChoices().add(""String_Node_Str"");
    choice.getChoices().add(""String_Node_Str"");
    choice.getChoices().add(""String_Node_Str"");
    choice.getChoices().add(""String_Node_Str"");
  }
  if (choice.getChoices().size() > 0) {
    Player player=game.getPlayer(source.getControllerId());
    if (choice.getChoices().size() == 1) {
      choice.setChoice(choice.getChoices().iterator().next());
    }
 else {
      player.choose(outcome,choice,game);
    }
    if (choice.getChoice() != null) {
      Mana mana=new Mana();
switch (choice.getChoice()) {
case ""String_Node_Str"":
        mana.setBlack(1);
      break;
case ""String_Node_Str"":
    mana.setBlue(1);
  break;
case ""String_Node_Str"":
mana.setRed(1);
break;
case ""String_Node_Str"":
mana.setGreen(1);
break;
case ""String_Node_Str"":
mana.setWhite(1);
break;
case ""String_Node_Str"":
mana.setGeneric(1);
break;
}
checkToFirePossibleEvents(mana,game,source);
player.getManaPool().addMana(mana,game,source);
return true;
}
return false;
}
return true;
}","@Override public boolean apply(Game game,Ability source){
  Mana types=getManaTypes(game,source);
  Choice choice=new ChoiceImpl(false);
  choice.setMessage(""String_Node_Str"");
  if (types.getBlack() > 0) {
    choice.getChoices().add(""String_Node_Str"");
  }
  if (types.getRed() > 0) {
    choice.getChoices().add(""String_Node_Str"");
  }
  if (types.getBlue() > 0) {
    choice.getChoices().add(""String_Node_Str"");
  }
  if (types.getGreen() > 0) {
    choice.getChoices().add(""String_Node_Str"");
  }
  if (types.getWhite() > 0) {
    choice.getChoices().add(""String_Node_Str"");
  }
  if (types.getColorless() > 0) {
    choice.getChoices().add(""String_Node_Str"");
  }
  if (types.getAny() > 0) {
    choice.getChoices().add(""String_Node_Str"");
    choice.getChoices().add(""String_Node_Str"");
    choice.getChoices().add(""String_Node_Str"");
    choice.getChoices().add(""String_Node_Str"");
    choice.getChoices().add(""String_Node_Str"");
    choice.getChoices().add(""String_Node_Str"");
  }
  if (choice.getChoices().size() > 0) {
    Player player=game.getPlayer(source.getControllerId());
    if (choice.getChoices().size() == 1) {
      choice.setChoice(choice.getChoices().iterator().next());
    }
 else {
      player.choose(outcome,choice,game);
    }
    if (choice.getChoice() != null) {
      Mana mana=new Mana();
switch (choice.getChoice()) {
case ""String_Node_Str"":
        mana.setBlack(1);
      break;
case ""String_Node_Str"":
    mana.setBlue(1);
  break;
case ""String_Node_Str"":
mana.setRed(1);
break;
case ""String_Node_Str"":
mana.setGreen(1);
break;
case ""String_Node_Str"":
mana.setWhite(1);
break;
case ""String_Node_Str"":
mana.setColorless(1);
break;
}
checkToFirePossibleEvents(mana,game,source);
player.getManaPool().addMana(mana,game,source);
return true;
}
return false;
}
return true;
}",0.9911455451023796
158677,"@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  Mana mana=(Mana)this.getValue(""String_Node_Str"");
  Permanent permanent=game.getPermanent(getTargetPointer().getFirst(game,source));
  if (controller != null && mana != null && permanent != null) {
    FilterPermanent filter=new FilterLandPermanent();
    filter.add(Predicates.not(new PermanentIdPredicate(permanent.getId())));
    filter.add(new NamePredicate(permanent.getName()));
    int count=game.getBattlefield().countAll(filter,controller.getId(),game);
    if (count > 0) {
      Choice choice=new ChoiceImpl(true);
      choice.setMessage(""String_Node_Str"");
      if (mana.getBlack() > 0) {
        choice.getChoices().add(""String_Node_Str"");
      }
      if (mana.getRed() > 0) {
        choice.getChoices().add(""String_Node_Str"");
      }
      if (mana.getBlue() > 0) {
        choice.getChoices().add(""String_Node_Str"");
      }
      if (mana.getGreen() > 0) {
        choice.getChoices().add(""String_Node_Str"");
      }
      if (mana.getWhite() > 0) {
        choice.getChoices().add(""String_Node_Str"");
      }
      if (mana.getGeneric() > 0) {
        choice.getChoices().add(""String_Node_Str"");
      }
      if (choice.getChoices().size() > 0) {
        Mana newMana=new Mana();
        for (int i=0; i < count; i++) {
          choice.clearChoice();
          if (choice.getChoices().size() == 1) {
            choice.setChoice(choice.getChoices().iterator().next());
          }
 else {
            while (!choice.isChosen()) {
              controller.choose(outcome,choice,game);
              if (!controller.canRespond()) {
                return false;
              }
            }
          }
          if (choice.getChoice() == null) {
            return false;
          }
switch (choice.getChoice()) {
case ""String_Node_Str"":
            newMana.increaseBlack();
          break;
case ""String_Node_Str"":
        newMana.increaseBlue();
      break;
case ""String_Node_Str"":
    newMana.increaseRed();
  break;
case ""String_Node_Str"":
newMana.increaseGreen();
break;
case ""String_Node_Str"":
newMana.increaseWhite();
break;
case ""String_Node_Str"":
newMana.increaseGeneric();
break;
}
}
controller.getManaPool().addMana(newMana,game,source);
checkToFirePossibleEvents(newMana,game,source);
}
}
return true;
}
return false;
}","@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  Mana mana=(Mana)this.getValue(""String_Node_Str"");
  Permanent permanent=game.getPermanent(getTargetPointer().getFirst(game,source));
  if (controller != null && mana != null && permanent != null) {
    FilterPermanent filter=new FilterLandPermanent();
    filter.add(Predicates.not(new PermanentIdPredicate(permanent.getId())));
    filter.add(new NamePredicate(permanent.getName()));
    int count=game.getBattlefield().countAll(filter,controller.getId(),game);
    if (count > 0) {
      Choice choice=new ChoiceImpl(true);
      choice.setMessage(""String_Node_Str"");
      if (mana.getBlack() > 0) {
        choice.getChoices().add(""String_Node_Str"");
      }
      if (mana.getRed() > 0) {
        choice.getChoices().add(""String_Node_Str"");
      }
      if (mana.getBlue() > 0) {
        choice.getChoices().add(""String_Node_Str"");
      }
      if (mana.getGreen() > 0) {
        choice.getChoices().add(""String_Node_Str"");
      }
      if (mana.getWhite() > 0) {
        choice.getChoices().add(""String_Node_Str"");
      }
      if (mana.getColorless() > 0) {
        choice.getChoices().add(""String_Node_Str"");
      }
      if (choice.getChoices().size() > 0) {
        Mana newMana=new Mana();
        for (int i=0; i < count; i++) {
          choice.clearChoice();
          if (choice.getChoices().size() == 1) {
            choice.setChoice(choice.getChoices().iterator().next());
          }
 else {
            while (!choice.isChosen()) {
              controller.choose(outcome,choice,game);
              if (!controller.canRespond()) {
                return false;
              }
            }
          }
          if (choice.getChoice() == null) {
            return false;
          }
switch (choice.getChoice()) {
case ""String_Node_Str"":
            newMana.increaseBlack();
          break;
case ""String_Node_Str"":
        newMana.increaseBlue();
      break;
case ""String_Node_Str"":
    newMana.increaseRed();
  break;
case ""String_Node_Str"":
newMana.increaseGreen();
break;
case ""String_Node_Str"":
newMana.increaseWhite();
break;
case ""String_Node_Str"":
newMana.increaseColorless();
break;
}
}
controller.getManaPool().addMana(newMana,game,source);
checkToFirePossibleEvents(newMana,game,source);
}
}
return true;
}
return false;
}",0.993280134397312
158678,"@Override public boolean replaceEvent(GameEvent event,Ability source,Game game){
  Mana mana=((ManaEvent)event).getMana();
  if (mana.getBlack() > 0) {
    mana.set(ManaType.BLACK,mana.getBlack() * 2);
  }
  if (mana.getBlue() > 0) {
    mana.set(ManaType.BLUE,mana.getBlue() * 2);
  }
  if (mana.getWhite() > 0) {
    mana.set(ManaType.WHITE,mana.getWhite() * 2);
  }
  if (mana.getGreen() > 0) {
    mana.set(ManaType.GREEN,mana.getGreen() * 2);
  }
  if (mana.getRed() > 0) {
    mana.set(ManaType.RED,mana.getRed() * 2);
  }
  if (mana.getGeneric() > 0) {
    mana.set(ManaType.COLORLESS,mana.getGeneric() * 2);
  }
  return false;
}","@Override public boolean replaceEvent(GameEvent event,Ability source,Game game){
  Mana mana=((ManaEvent)event).getMana();
  if (mana.getBlack() > 0) {
    mana.set(ManaType.BLACK,mana.getBlack() * 2);
  }
  if (mana.getBlue() > 0) {
    mana.set(ManaType.BLUE,mana.getBlue() * 2);
  }
  if (mana.getWhite() > 0) {
    mana.set(ManaType.WHITE,mana.getWhite() * 2);
  }
  if (mana.getGreen() > 0) {
    mana.set(ManaType.GREEN,mana.getGreen() * 2);
  }
  if (mana.getRed() > 0) {
    mana.set(ManaType.RED,mana.getRed() * 2);
  }
  if (mana.getColorless() > 0) {
    mana.set(ManaType.COLORLESS,mana.getColorless() * 2);
  }
  return false;
}",0.974960876369327
158679,"public List<Mana> getNetMana(Game game,Ability source){
  List<Mana> netManas=new ArrayList<>();
  Mana types=getManaTypes(game,source);
  if (types.getAny() > 0) {
    netManas.add(new Mana(0,0,0,0,0,0,1,0));
    return netManas;
  }
  if (types.getBlack() > 0) {
    netManas.add(new Mana(ColoredManaSymbol.B));
  }
  if (types.getRed() > 0) {
    netManas.add(new Mana(ColoredManaSymbol.R));
  }
  if (types.getBlue() > 0) {
    netManas.add(new Mana(ColoredManaSymbol.U));
  }
  if (types.getGreen() > 0) {
    netManas.add(new Mana(ColoredManaSymbol.G));
  }
  if (types.getWhite() > 0) {
    netManas.add(new Mana(ColoredManaSymbol.W));
  }
  if (types.getGeneric() > 0) {
    netManas.add(new Mana(0,0,0,0,0,0,0,1));
  }
  return netManas;
}","public List<Mana> getNetMana(Game game,Ability source){
  List<Mana> netManas=new ArrayList<>();
  Mana types=getManaTypes(game,source);
  if (types.getAny() > 0) {
    netManas.add(new Mana(0,0,0,0,0,0,1,0));
    return netManas;
  }
  if (types.getBlack() > 0) {
    netManas.add(new Mana(ColoredManaSymbol.B));
  }
  if (types.getRed() > 0) {
    netManas.add(new Mana(ColoredManaSymbol.R));
  }
  if (types.getBlue() > 0) {
    netManas.add(new Mana(ColoredManaSymbol.U));
  }
  if (types.getGreen() > 0) {
    netManas.add(new Mana(ColoredManaSymbol.G));
  }
  if (types.getWhite() > 0) {
    netManas.add(new Mana(ColoredManaSymbol.W));
  }
  if (types.getColorless() > 0) {
    netManas.add(new Mana(0,0,0,0,0,0,0,1));
  }
  return netManas;
}",0.9893190921228304
158680,"@Override public boolean apply(Game game,Ability source){
  Mana types=getManaTypes(game,source);
  Choice choice=new ChoiceImpl(false);
  choice.setMessage(""String_Node_Str"");
  if (types.getBlack() > 0) {
    choice.getChoices().add(""String_Node_Str"");
  }
  if (types.getRed() > 0) {
    choice.getChoices().add(""String_Node_Str"");
  }
  if (types.getBlue() > 0) {
    choice.getChoices().add(""String_Node_Str"");
  }
  if (types.getGreen() > 0) {
    choice.getChoices().add(""String_Node_Str"");
  }
  if (types.getWhite() > 0) {
    choice.getChoices().add(""String_Node_Str"");
  }
  if (types.getGeneric() > 0) {
    choice.getChoices().add(""String_Node_Str"");
  }
  if (types.getAny() > 0) {
    choice.getChoices().add(""String_Node_Str"");
    choice.getChoices().add(""String_Node_Str"");
    choice.getChoices().add(""String_Node_Str"");
    choice.getChoices().add(""String_Node_Str"");
    choice.getChoices().add(""String_Node_Str"");
    choice.getChoices().add(""String_Node_Str"");
  }
  if (choice.getChoices().size() > 0) {
    Player player=game.getPlayer(source.getControllerId());
    if (choice.getChoices().size() == 1) {
      choice.setChoice(choice.getChoices().iterator().next());
    }
 else {
      player.choose(outcome,choice,game);
    }
    if (choice.getChoice() != null) {
      Mana mana=new Mana();
switch (choice.getChoice()) {
case ""String_Node_Str"":
        mana.setBlack(1);
      break;
case ""String_Node_Str"":
    mana.setBlue(1);
  break;
case ""String_Node_Str"":
mana.setRed(1);
break;
case ""String_Node_Str"":
mana.setGreen(1);
break;
case ""String_Node_Str"":
mana.setWhite(1);
break;
case ""String_Node_Str"":
mana.setGeneric(1);
break;
}
checkToFirePossibleEvents(mana,game,source);
player.getManaPool().addMana(mana,game,source);
return true;
}
return false;
}
return true;
}","@Override public boolean apply(Game game,Ability source){
  Mana types=getManaTypes(game,source);
  Choice choice=new ChoiceImpl(false);
  choice.setMessage(""String_Node_Str"");
  if (types.getBlack() > 0) {
    choice.getChoices().add(""String_Node_Str"");
  }
  if (types.getRed() > 0) {
    choice.getChoices().add(""String_Node_Str"");
  }
  if (types.getBlue() > 0) {
    choice.getChoices().add(""String_Node_Str"");
  }
  if (types.getGreen() > 0) {
    choice.getChoices().add(""String_Node_Str"");
  }
  if (types.getWhite() > 0) {
    choice.getChoices().add(""String_Node_Str"");
  }
  if (types.getColorless() > 0) {
    choice.getChoices().add(""String_Node_Str"");
  }
  if (types.getAny() > 0) {
    choice.getChoices().add(""String_Node_Str"");
    choice.getChoices().add(""String_Node_Str"");
    choice.getChoices().add(""String_Node_Str"");
    choice.getChoices().add(""String_Node_Str"");
    choice.getChoices().add(""String_Node_Str"");
    choice.getChoices().add(""String_Node_Str"");
  }
  if (choice.getChoices().size() > 0) {
    Player player=game.getPlayer(source.getControllerId());
    if (choice.getChoices().size() == 1) {
      choice.setChoice(choice.getChoices().iterator().next());
    }
 else {
      player.choose(outcome,choice,game);
    }
    if (choice.getChoice() != null) {
      Mana mana=new Mana();
switch (choice.getChoice()) {
case ""String_Node_Str"":
        mana.setBlack(1);
      break;
case ""String_Node_Str"":
    mana.setBlue(1);
  break;
case ""String_Node_Str"":
mana.setRed(1);
break;
case ""String_Node_Str"":
mana.setGreen(1);
break;
case ""String_Node_Str"":
mana.setWhite(1);
break;
case ""String_Node_Str"":
mana.setColorless(1);
break;
}
checkToFirePossibleEvents(mana,game,source);
player.getManaPool().addMana(mana,game,source);
return true;
}
return false;
}
return true;
}",0.9911455451023796
158681,"@Override public boolean apply(Game game,Ability source){
  Permanent permanent=game.getPermanent(getTargetPointer().getFirst(game,source));
  if (permanent != null) {
    Player targetController=game.getPlayer(permanent.getControllerId());
    if (targetController == null) {
      return false;
    }
    Mana types=(Mana)this.getValue(""String_Node_Str"");
    Choice choice=new ChoiceImpl(true);
    choice.setMessage(""String_Node_Str"");
    if (types.getBlack() > 0) {
      choice.getChoices().add(""String_Node_Str"");
    }
    if (types.getRed() > 0) {
      choice.getChoices().add(""String_Node_Str"");
    }
    if (types.getBlue() > 0) {
      choice.getChoices().add(""String_Node_Str"");
    }
    if (types.getGreen() > 0) {
      choice.getChoices().add(""String_Node_Str"");
    }
    if (types.getWhite() > 0) {
      choice.getChoices().add(""String_Node_Str"");
    }
    if (types.getGeneric() > 0) {
      choice.getChoices().add(""String_Node_Str"");
    }
    if (choice.getChoices().size() > 0) {
      if (choice.getChoices().size() == 1) {
        choice.setChoice(choice.getChoices().iterator().next());
      }
 else {
        targetController.choose(outcome,choice,game);
      }
      if (choice.getChoice() == null) {
        return false;
      }
      Mana newMana=new Mana();
switch (choice.getChoice()) {
case ""String_Node_Str"":
        newMana.setBlack(1);
      break;
case ""String_Node_Str"":
    newMana.setBlue(1);
  break;
case ""String_Node_Str"":
newMana.setRed(1);
break;
case ""String_Node_Str"":
newMana.setGreen(1);
break;
case ""String_Node_Str"":
newMana.setWhite(1);
break;
case ""String_Node_Str"":
newMana.setColorless(1);
break;
}
checkToFirePossibleEvents(newMana,game,source);
targetController.getManaPool().addMana(newMana,game,source);
}
return true;
}
return false;
}","@Override public boolean apply(Game game,Ability source){
  Permanent permanent=game.getPermanent(getTargetPointer().getFirst(game,source));
  if (permanent != null) {
    Player targetController=game.getPlayer(permanent.getControllerId());
    if (targetController == null) {
      return false;
    }
    Mana types=(Mana)this.getValue(""String_Node_Str"");
    Choice choice=new ChoiceImpl(true);
    choice.setMessage(""String_Node_Str"");
    if (types.getBlack() > 0) {
      choice.getChoices().add(""String_Node_Str"");
    }
    if (types.getRed() > 0) {
      choice.getChoices().add(""String_Node_Str"");
    }
    if (types.getBlue() > 0) {
      choice.getChoices().add(""String_Node_Str"");
    }
    if (types.getGreen() > 0) {
      choice.getChoices().add(""String_Node_Str"");
    }
    if (types.getWhite() > 0) {
      choice.getChoices().add(""String_Node_Str"");
    }
    if (types.getColorless() > 0) {
      choice.getChoices().add(""String_Node_Str"");
    }
    if (choice.getChoices().size() > 0) {
      if (choice.getChoices().size() == 1) {
        choice.setChoice(choice.getChoices().iterator().next());
      }
 else {
        targetController.choose(outcome,choice,game);
      }
      if (choice.getChoice() == null) {
        return false;
      }
      Mana newMana=new Mana();
switch (choice.getChoice()) {
case ""String_Node_Str"":
        newMana.setBlack(1);
      break;
case ""String_Node_Str"":
    newMana.setBlue(1);
  break;
case ""String_Node_Str"":
newMana.setRed(1);
break;
case ""String_Node_Str"":
newMana.setGreen(1);
break;
case ""String_Node_Str"":
newMana.setWhite(1);
break;
case ""String_Node_Str"":
newMana.setColorless(1);
break;
}
checkToFirePossibleEvents(newMana,game,source);
targetController.getManaPool().addMana(newMana,game,source);
}
return true;
}
return false;
}",0.9955678670360112
158682,"/** 
 * Checks if a possible creature for a block is already doing another required block
 * @param possibleBlockerId
 * @param mustBeBlockedByAtLeastOne
 * @param game
 * @return null block is required otherwise message with reason why not
 */
protected String isCreatureDoingARequiredBlock(UUID possibleBlockerId,Map<UUID,Set<UUID>> mustBeBlockedByAtLeastOne,Game game){
  Permanent possibleBlocker=game.getPermanent(possibleBlockerId);
  if (possibleBlocker != null) {
    if (possibleBlocker.getBlocking() == 0) {
      return possibleBlocker.getIdName() + ""String_Node_Str"";
    }
    Set<UUID> forcingAttackers=creatureMustBlockAttackers.get(possibleBlockerId);
    if (forcingAttackers == null) {
      if (possibleBlocker.getBlocking() > 0) {
        CombatGroup combatGroupOfPossibleBlocker=findGroupOfBlocker(possibleBlockerId);
        if (combatGroupOfPossibleBlocker != null) {
          for (          UUID blockedAttackerId : combatGroupOfPossibleBlocker.getAttackers()) {
            if (mustBeBlockedByAtLeastOne.containsKey(blockedAttackerId)) {
              if (combatGroupOfPossibleBlocker.getBlockers().size() == 1) {
                return null;
              }
              Permanent blockedAttacker=game.getPermanent(blockedAttackerId);
              return possibleBlocker.getIdName() + ""String_Node_Str"" + blockedAttacker.getIdName()+ ""String_Node_Str"";
            }
          }
        }
      }
    }
  }
  return null;
}","/** 
 * Checks if a possible creature for a block is already doing another required block
 * @param possibleBlockerId
 * @param mustBeBlockedByAtLeastOne
 * @param game
 * @return null block is required otherwise message with reason why not
 */
protected String isCreatureDoingARequiredBlock(UUID possibleBlockerId,Map<UUID,Set<UUID>> mustBeBlockedByAtLeastOne,Game game){
  Permanent possibleBlocker=game.getPermanent(possibleBlockerId);
  if (possibleBlocker != null) {
    if (possibleBlocker.getBlocking() == 0) {
      return possibleBlocker.getIdName() + ""String_Node_Str"";
    }
    Set<UUID> forcingAttackers=creatureMustBlockAttackers.get(possibleBlockerId);
    if (forcingAttackers == null) {
      if (possibleBlocker.getBlocking() > 0) {
        CombatGroup combatGroupOfPossibleBlocker=findGroupOfBlocker(possibleBlockerId);
        if (combatGroupOfPossibleBlocker != null) {
          for (          UUID blockedAttackerId : combatGroupOfPossibleBlocker.getAttackers()) {
            if (mustBeBlockedByAtLeastOne.containsKey(blockedAttackerId)) {
              if (combatGroupOfPossibleBlocker.getBlockers().size() == 1) {
                return null;
              }
              Permanent blockedAttacker=game.getPermanent(blockedAttackerId);
              return possibleBlocker.getIdName() + ""String_Node_Str"" + blockedAttacker.getIdName()+ ""String_Node_Str"";
            }
            Permanent blockedAttacker=game.getPermanent(blockedAttackerId);
            return possibleBlocker.getIdName() + ""String_Node_Str"" + blockedAttacker.getIdName()+ ""String_Node_Str"";
          }
        }
      }
    }
  }
  return null;
}",0.9376816273813368
158683,"/** 
 * 509.1c The defending player checks each creature he or she controls to see whether it's affected by any requirements (effects that say a creature must block, or that it must block if some condition is met). If the number of requirements that are being obeyed is fewer than the maximum possible number of requirements that could be obeyed without disobeying any restrictions, the declaration of blockers is illegal. If a creature can't block unless a player pays a cost, that player is not required to pay that cost, even if blocking with that creature would increase the number of requirements being obeyed. Example: A player controls one creature that ""blocks if able"" and another creature with no abilities. An effect states ""Creatures can't be blocked except by two or more creatures."" Having only the first creature block violates the restriction. Having neither creature block fulfills the restriction but not the requirement. Having both creatures block the same attacking creature fulfills both the restriction and the requirement, so that's the only option.
 * @param player
 * @param controller
 * @param game
 * @return
 */
public boolean checkBlockRequirementsAfter(Player player,Player controller,Game game){
  Set<UUID> opponents=game.getOpponents(attackerId);
  Map<UUID,Set<UUID>> mustBeBlockedByAtLeastOne=new HashMap<>();
  for (  Permanent creature : game.getBattlefield().getActivePermanents(new FilterControlledCreaturePermanent(),player.getId(),game)) {
    if (opponents.contains(creature.getControllerId())) {
      if (creature.getBlocking() > 0) {
        for (        Map.Entry<RequirementEffect,HashSet<Ability>> entry : game.getContinuousEffects().getApplicableRequirementEffects(creature,game).entrySet()) {
          RequirementEffect effect=entry.getKey();
          for (          Ability ability : entry.getValue()) {
            UUID toBeBlockedCreature=effect.mustBlockAttackerIfElseUnblocked(ability,game);
            if (toBeBlockedCreature != null) {
              Set<UUID> potentialBlockers;
              if (mustBeBlockedByAtLeastOne.containsKey(toBeBlockedCreature)) {
                potentialBlockers=mustBeBlockedByAtLeastOne.get(toBeBlockedCreature);
              }
 else {
                potentialBlockers=new HashSet<>();
                mustBeBlockedByAtLeastOne.put(toBeBlockedCreature,potentialBlockers);
              }
              potentialBlockers.add(creature.getId());
            }
          }
        }
      }
      if (creature.getBlocking() == 0) {
        for (        Map.Entry<RequirementEffect,HashSet<Ability>> entry : game.getContinuousEffects().getApplicableRequirementEffects(creature,game).entrySet()) {
          RequirementEffect effect=entry.getKey();
          for (          Ability ability : entry.getValue()) {
            UUID toBeBlockedCreature=effect.mustBlockAttackerIfElseUnblocked(ability,game);
            if (toBeBlockedCreature != null) {
              Set<UUID> potentialBlockers;
              if (mustBeBlockedByAtLeastOne.containsKey(toBeBlockedCreature)) {
                potentialBlockers=mustBeBlockedByAtLeastOne.get(toBeBlockedCreature);
              }
 else {
                potentialBlockers=new HashSet<>();
                mustBeBlockedByAtLeastOne.put(toBeBlockedCreature,potentialBlockers);
              }
              potentialBlockers.add(creature.getId());
            }
          }
          if (effect.mustBlockAny(game)) {
            boolean mayBlock=false;
            for (            UUID attackingCreatureId : getAttackers()) {
              if (creature.canBlock(attackingCreatureId,game)) {
                Permanent attackingCreature=game.getPermanent(attackingCreatureId);
                if (attackingCreature != null) {
                  if (attackingCreature.getMaxBlockedBy() != 0) {
                    int alreadyBlockingCreatures=0;
                    for (                    CombatGroup group : getGroups()) {
                      if (group.getAttackers().contains(attackingCreatureId)) {
                        alreadyBlockingCreatures=group.getBlockers().size();
                        break;
                      }
                    }
                    if (attackingCreature.getMaxBlockedBy() <= alreadyBlockingCreatures) {
                      continue;
                    }
                  }
                  if (attackingCreature.getMinBlockedBy() > 1) {
                  }
 else {
                    mayBlock=true;
                    break;
                  }
                }
              }
            }
            if (mayBlock) {
              if (controller.isHuman()) {
                if (!game.isSimulation()) {
                  game.informPlayer(controller,""String_Node_Str"" + creature.getIdName());
                }
              }
 else {
                Player defender=game.getPlayer(creature.getControllerId());
                if (defender != null) {
                  for (                  UUID attackingCreatureId : getAttackers()) {
                    if (creature.canBlock(attackingCreatureId,game)) {
                      defender.declareBlocker(defender.getId(),creature.getId(),attackingCreatureId,game);
                      break;
                    }
                  }
                }
              }
              return false;
            }
          }
        }
      }
    }
  }
  for (  UUID toBeBlockedCreatureId : mustBeBlockedByAtLeastOne.keySet()) {
    for (    CombatGroup combatGroup : game.getCombat().getGroups()) {
      if (combatGroup.getBlockers().isEmpty() && combatGroup.getAttackers().contains(toBeBlockedCreatureId)) {
        if (controller.isHuman()) {
          Permanent toBeBlockedCreature=game.getPermanent(toBeBlockedCreatureId);
          if (toBeBlockedCreature != null) {
            for (            UUID possibleBlockerId : mustBeBlockedByAtLeastOne.get(toBeBlockedCreatureId)) {
              String blockRequiredMessage=isCreatureDoingARequiredBlock(possibleBlockerId,mustBeBlockedByAtLeastOne,game);
              if (blockRequiredMessage != null) {
                game.informPlayer(controller,blockRequiredMessage + ""String_Node_Str"" + toBeBlockedCreature.getIdName());
                return false;
              }
            }
          }
        }
 else {
          for (          UUID possibleBlockerId : mustBeBlockedByAtLeastOne.get(toBeBlockedCreatureId)) {
            String blockRequiredMessage=isCreatureDoingARequiredBlock(possibleBlockerId,mustBeBlockedByAtLeastOne,game);
            if (blockRequiredMessage != null) {
              Permanent possibleBlocker=game.getPermanent(possibleBlockerId);
              Player defender=game.getPlayer(possibleBlocker.getControllerId());
              if (defender != null) {
                defender.declareBlocker(defender.getId(),possibleBlockerId,toBeBlockedCreatureId,game);
              }
              break;
            }
          }
        }
      }
    }
  }
  StringBuilder sb=new StringBuilder();
  for (  Map.Entry<UUID,Set<UUID>> entry : creatureMustBlockAttackers.entrySet()) {
    boolean blockIsValid;
    Permanent creatureForcedToBlock=game.getPermanent(entry.getKey());
    if (creatureForcedToBlock == null) {
      break;
    }
    if (!creatureForcedToBlock.getControllerId().equals(player.getId())) {
      continue;
    }
    if (creatureForcedToBlock.getBlocking() == 0) {
      blockIsValid=false;
    }
 else {
      blockIsValid=false;
      CombatGroups:       for (      CombatGroup combatGroup : game.getCombat().getGroups()) {
        if (combatGroup.getBlockers().contains(creatureForcedToBlock.getId())) {
          for (          UUID forcingAttackerId : combatGroup.getAttackers()) {
            if (entry.getValue().contains(forcingAttackerId)) {
              blockIsValid=true;
              break CombatGroups;
            }
 else {
              if (combatGroup.getBlockers().size() == 1) {
                if (mustBeBlockedByAtLeastOne.containsKey(forcingAttackerId)) {
                  if (mustBeBlockedByAtLeastOne.get(forcingAttackerId).contains(creatureForcedToBlock.getId())) {
                    blockIsValid=true;
                    break CombatGroups;
                  }
                }
              }
            }
          }
        }
      }
    }
    if (!blockIsValid) {
      sb.append(""String_Node_Str"").append(creatureForcedToBlock.getIdName());
    }
  }
  if (sb.length() > 0) {
    if (!game.isSimulation()) {
      sb.insert(0,""String_Node_Str"");
      sb.append(""String_Node_Str"");
      game.informPlayer(controller,sb.toString());
    }
    return false;
  }
  return true;
}","/** 
 * 509.1c The defending player checks each creature he or she controls to see whether it's affected by any requirements (effects that say a creature must block, or that it must block if some condition is met). If the number of requirements that are being obeyed is fewer than the maximum possible number of requirements that could be obeyed without disobeying any restrictions, the declaration of blockers is illegal. If a creature can't block unless a player pays a cost, that player is not required to pay that cost, even if blocking with that creature would increase the number of requirements being obeyed. Example: A player controls one creature that ""blocks if able"" and another creature with no abilities. An effect states ""Creatures can't be blocked except by two or more creatures."" Having only the first creature block violates the restriction. Having neither creature block fulfills the restriction but not the requirement. Having both creatures block the same attacking creature fulfills both the restriction and the requirement, so that's the only option.
 * @param player
 * @param controller
 * @param game
 * @return
 */
public boolean checkBlockRequirementsAfter(Player player,Player controller,Game game){
  Set<UUID> opponents=game.getOpponents(attackerId);
  Map<UUID,Set<UUID>> mustBeBlockedByAtLeastOne=new HashMap<>();
  for (  Permanent creature : game.getBattlefield().getActivePermanents(new FilterControlledCreaturePermanent(),player.getId(),game)) {
    if (opponents.contains(creature.getControllerId())) {
      if (creature.getBlocking() > 0) {
        for (        Map.Entry<RequirementEffect,HashSet<Ability>> entry : game.getContinuousEffects().getApplicableRequirementEffects(creature,game).entrySet()) {
          RequirementEffect effect=entry.getKey();
          for (          Ability ability : entry.getValue()) {
            UUID toBeBlockedCreature=effect.mustBlockAttackerIfElseUnblocked(ability,game);
            if (toBeBlockedCreature != null) {
              Set<UUID> potentialBlockers;
              if (mustBeBlockedByAtLeastOne.containsKey(toBeBlockedCreature)) {
                potentialBlockers=mustBeBlockedByAtLeastOne.get(toBeBlockedCreature);
              }
 else {
                potentialBlockers=new HashSet<>();
                mustBeBlockedByAtLeastOne.put(toBeBlockedCreature,potentialBlockers);
              }
              potentialBlockers.add(creature.getId());
            }
          }
        }
      }
      if (creature.getBlocking() == 0) {
        for (        Map.Entry<RequirementEffect,HashSet<Ability>> entry : game.getContinuousEffects().getApplicableRequirementEffects(creature,game).entrySet()) {
          RequirementEffect effect=entry.getKey();
          for (          Ability ability : entry.getValue()) {
            UUID toBeBlockedCreature=effect.mustBlockAttackerIfElseUnblocked(ability,game);
            if (toBeBlockedCreature != null) {
              Set<UUID> potentialBlockers;
              if (mustBeBlockedByAtLeastOne.containsKey(toBeBlockedCreature)) {
                potentialBlockers=mustBeBlockedByAtLeastOne.get(toBeBlockedCreature);
              }
 else {
                potentialBlockers=new HashSet<>();
                mustBeBlockedByAtLeastOne.put(toBeBlockedCreature,potentialBlockers);
              }
              potentialBlockers.add(creature.getId());
            }
          }
          if (effect.mustBlockAny(game)) {
            boolean mayBlock=false;
            for (            UUID attackingCreatureId : getAttackers()) {
              if (creature.canBlock(attackingCreatureId,game)) {
                Permanent attackingCreature=game.getPermanent(attackingCreatureId);
                if (attackingCreature != null) {
                  if (attackingCreature.getMaxBlockedBy() != 0) {
                    int alreadyBlockingCreatures=0;
                    for (                    CombatGroup group : getGroups()) {
                      if (group.getAttackers().contains(attackingCreatureId)) {
                        alreadyBlockingCreatures=group.getBlockers().size();
                        break;
                      }
                    }
                    if (attackingCreature.getMaxBlockedBy() <= alreadyBlockingCreatures) {
                      continue;
                    }
                  }
                  if (attackingCreature.getMinBlockedBy() > 1) {
                  }
 else {
                    mayBlock=true;
                    break;
                  }
                }
              }
            }
            if (mayBlock) {
              if (controller.isHuman()) {
                if (!game.isSimulation()) {
                  game.informPlayer(controller,""String_Node_Str"" + creature.getIdName());
                }
              }
 else {
                Player defender=game.getPlayer(creature.getControllerId());
                if (defender != null) {
                  for (                  UUID attackingCreatureId : getAttackers()) {
                    if (creature.canBlock(attackingCreatureId,game)) {
                      defender.declareBlocker(defender.getId(),creature.getId(),attackingCreatureId,game);
                      break;
                    }
                  }
                }
              }
              return false;
            }
          }
        }
      }
    }
  }
  for (  UUID toBeBlockedCreatureId : mustBeBlockedByAtLeastOne.keySet()) {
    for (    CombatGroup combatGroup : game.getCombat().getGroups()) {
      if (combatGroup.getBlockers().isEmpty() && combatGroup.getAttackers().contains(toBeBlockedCreatureId)) {
        if (controller.isHuman()) {
          Permanent toBeBlockedCreature=game.getPermanent(toBeBlockedCreatureId);
          if (toBeBlockedCreature != null) {
            for (            UUID possibleBlockerId : mustBeBlockedByAtLeastOne.get(toBeBlockedCreatureId)) {
              String blockRequiredMessage=isCreatureDoingARequiredBlock(possibleBlockerId,mustBeBlockedByAtLeastOne,game);
              if (blockRequiredMessage != null) {
                removeBlocker(possibleBlockerId,game);
                game.informPlayer(controller,blockRequiredMessage + ""String_Node_Str"" + toBeBlockedCreature.getIdName()+ ""String_Node_Str"");
                return false;
              }
            }
          }
        }
 else {
          for (          UUID possibleBlockerId : mustBeBlockedByAtLeastOne.get(toBeBlockedCreatureId)) {
            String blockRequiredMessage=isCreatureDoingARequiredBlock(possibleBlockerId,mustBeBlockedByAtLeastOne,game);
            if (blockRequiredMessage != null) {
              Permanent possibleBlocker=game.getPermanent(possibleBlockerId);
              Player defender=game.getPlayer(possibleBlocker.getControllerId());
              if (defender != null) {
                if (possibleBlocker.getBlocking() > 0) {
                  removeBlocker(possibleBlockerId,game);
                }
                defender.declareBlocker(defender.getId(),possibleBlockerId,toBeBlockedCreatureId,game);
              }
              break;
            }
          }
        }
      }
    }
  }
  StringBuilder sb=new StringBuilder();
  for (  Map.Entry<UUID,Set<UUID>> entry : creatureMustBlockAttackers.entrySet()) {
    boolean blockIsValid;
    Permanent creatureForcedToBlock=game.getPermanent(entry.getKey());
    if (creatureForcedToBlock == null) {
      break;
    }
    if (!creatureForcedToBlock.getControllerId().equals(player.getId())) {
      continue;
    }
    if (creatureForcedToBlock.getBlocking() == 0) {
      blockIsValid=false;
    }
 else {
      blockIsValid=false;
      CombatGroups:       for (      CombatGroup combatGroup : game.getCombat().getGroups()) {
        if (combatGroup.getBlockers().contains(creatureForcedToBlock.getId())) {
          for (          UUID forcingAttackerId : combatGroup.getAttackers()) {
            if (entry.getValue().contains(forcingAttackerId)) {
              blockIsValid=true;
              break CombatGroups;
            }
 else {
              if (combatGroup.getBlockers().size() == 1) {
                if (mustBeBlockedByAtLeastOne.containsKey(forcingAttackerId)) {
                  if (mustBeBlockedByAtLeastOne.get(forcingAttackerId).contains(creatureForcedToBlock.getId())) {
                    blockIsValid=true;
                    break CombatGroups;
                  }
                }
              }
            }
          }
        }
      }
    }
    if (!blockIsValid) {
      sb.append(""String_Node_Str"").append(creatureForcedToBlock.getIdName());
    }
  }
  if (sb.length() > 0) {
    if (!game.isSimulation()) {
      sb.insert(0,""String_Node_Str"");
      sb.append(""String_Node_Str"");
      game.informPlayer(controller,sb.toString());
    }
    return false;
  }
  return true;
}",0.988239324046586
158684,"static private String validateUserName(String userName){
  if (userName.equals(""String_Node_Str"")) {
    return ""String_Node_Str"";
  }
  ConfigSettings config=ConfigSettings.getInstance();
  if (userName.length() < config.getMinUserNameLength()) {
    return ""String_Node_Str"" + config.getMinUserNameLength() + ""String_Node_Str"";
  }
  if (userName.length() > config.getMaxUserNameLength()) {
    return ""String_Node_Str"" + config.getMaxUserNameLength() + ""String_Node_Str"";
  }
  Matcher m=invalidUserNamePattern.matcher(userName);
  if (m.find()) {
    return ""String_Node_Str"" + userName + ""String_Node_Str"";
  }
  AuthorizedUser authorizedUser=AuthorizedUserRepository.instance.getByName(userName);
  if (authorizedUser != null) {
    return ""String_Node_Str"" + userName + ""String_Node_Str"";
  }
  return null;
}","static private String validateUserName(String userName){
  if (userName.equals(""String_Node_Str"")) {
    return ""String_Node_Str"";
  }
  ConfigSettings config=ConfigSettings.getInstance();
  if (userName.length() < config.getMinUserNameLength()) {
    return ""String_Node_Str"" + config.getMinUserNameLength() + ""String_Node_Str"";
  }
  if (userName.length() > config.getMaxUserNameLength()) {
    return ""String_Node_Str"" + config.getMaxUserNameLength() + ""String_Node_Str"";
  }
  Pattern invalidUserNamePattern=Pattern.compile(ConfigSettings.getInstance().getInvalidUserNamePattern(),Pattern.CASE_INSENSITIVE);
  Matcher m=invalidUserNamePattern.matcher(userName);
  if (m.find()) {
    return ""String_Node_Str"" + userName + ""String_Node_Str"";
  }
  AuthorizedUser authorizedUser=AuthorizedUserRepository.instance.getByName(userName);
  if (authorizedUser != null) {
    return ""String_Node_Str"" + userName + ""String_Node_Str"";
  }
  return null;
}",0.9246458923512748
158685,"@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  MageObject sourceObject=source.getSourceObject(game);
  if (controller == null || sourceObject == null) {
    return false;
  }
  if (controller.getLibrary().size() > 0) {
    Card card=controller.getLibrary().getFromTop(game);
    if (card != null) {
      Cards cards=new CardsImpl(card);
      controller.revealCards(sourceObject.getIdName(),cards,game);
      if (card.getCardType().contains(CardType.ARTIFACT)) {
        controller.moveCards(card,Zone.HAND,source,game);
      }
 else {
        controller.moveCards(card,Zone.GRAVEYARD,source,game);
      }
    }
  }
  return true;
}","@java.lang.Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  MageObject sourceObject=source.getSourceObject(game);
  if (controller == null || sourceObject == null) {
    return false;
  }
  if (controller.getLibrary().size() > 0) {
    Card card=controller.getLibrary().getFromTop(game);
    if (card != null) {
      Cards cards=new CardsImpl(card);
      controller.revealCards(sourceObject.getIdName(),cards,game);
      if (card.getCardType().contains(CardType.ARTIFACT)) {
        controller.moveCards(card,Zone.HAND,source,game);
      }
 else {
        controller.moveCards(card,Zone.GRAVEYARD,source,game);
      }
    }
  }
  return true;
}",0.9930167597765364
158686,"@Override public NeurokFamiliarEffect copy(){
  return new NeurokFamiliarEffect(this);
}","@java.lang.Override public NeurokFamiliarEffect copy(){
  return new NeurokFamiliarEffect(this);
}",0.946236559139785
158687,"private Map<String,String> getSetLinks(String cardSet){
  Map<String,String> setLinks=new HashMap<>();
  try {
    String setNames=setsAliases.get(cardSet.toLowerCase());
    Set<String> aliasesStart=new HashSet<>();
    if (cardNameAliasesStart.containsKey(cardSet)) {
      aliasesStart.addAll(cardNameAliasesStart.get(cardSet));
    }
    if (setNames == null) {
      setNames=cardSet.toLowerCase();
    }
    Preferences prefs=MageFrame.getPreferences();
    Connection.ProxyType proxyType=Connection.ProxyType.valueByText(prefs.get(""String_Node_Str"",""String_Node_Str""));
    for (    String setName : setNames.split(""String_Node_Str"")) {
      String URLSetName=URLEncoder.encode(setName,""String_Node_Str"");
      String baseUrl=""String_Node_Str"" + URLSetName + ""String_Node_Str"";
      String urlDocument;
      Document doc;
      if (proxyType.equals(ProxyType.NONE)) {
        urlDocument=baseUrl;
        doc=Jsoup.connect(urlDocument).get();
      }
 else {
        String proxyServer=prefs.get(""String_Node_Str"",""String_Node_Str"");
        int proxyPort=Integer.parseInt(prefs.get(""String_Node_Str"",""String_Node_Str""));
        URL url=new URL(baseUrl);
        Proxy proxy=new Proxy(Proxy.Type.HTTP,new InetSocketAddress(proxyServer,proxyPort));
        HttpURLConnection uc=(HttpURLConnection)url.openConnection(proxy);
        uc.connect();
        String line;
        StringBuffer tmp=new StringBuffer();
        BufferedReader in=new BufferedReader(new InputStreamReader(uc.getInputStream()));
        while ((line=in.readLine()) != null) {
          tmp.append(line);
        }
        doc=Jsoup.parse(String.valueOf(tmp));
      }
      Elements cardsImages=doc.select(""String_Node_Str"");
      if (!aliasesStart.isEmpty()) {
        for (        String text : aliasesStart) {
          cardsImages.addAll(doc.select(""String_Node_Str"" + text + ""String_Node_Str""));
        }
      }
      if (cardsImages.isEmpty()) {
        break;
      }
      for (      Element cardsImage : cardsImages) {
        String cardLink=cardsImage.attr(""String_Node_Str"");
        String cardName=null;
        if (cardLink.startsWith(""String_Node_Str"") && cardLink.endsWith(""String_Node_Str"")) {
          cardName=cardLink.substring(6,cardLink.length() - 4);
        }
 else         if (aliasesStart.contains(cardLink)) {
          cardName=cardLink.substring(0,cardLink.length() - 4);
          ;
        }
        if (cardName != null && !cardName.isEmpty()) {
          if (cardNameAliases.containsKey(cardSet + ""String_Node_Str"" + cardName)) {
            cardName=cardNameAliases.get(cardSet + ""String_Node_Str"" + cardName);
          }
          if (cardName.endsWith(""String_Node_Str"") || cardName.endsWith(""String_Node_Str"") || cardName.endsWith(""String_Node_Str"")|| cardName.endsWith(""String_Node_Str"")|| cardName.endsWith(""String_Node_Str"")) {
            if (!cardName.startsWith(""String_Node_Str"") && !cardName.startsWith(""String_Node_Str"") && !cardName.startsWith(""String_Node_Str"")&& !cardName.startsWith(""String_Node_Str"")&& !cardName.startsWith(""String_Node_Str"")) {
              cardName=cardName.substring(0,cardName.length() - 1);
            }
          }
          setLinks.put(cardName,baseUrl + cardLink);
        }
      }
    }
  }
 catch (  IOException ex) {
    System.out.println(""String_Node_Str"" + ex.getMessage());
  }
  return setLinks;
}","private Map<String,String> getSetLinks(String cardSet){
  Map<String,String> setLinks=new HashMap<>();
  try {
    String setNames=setsAliases.get(cardSet.toLowerCase());
    Set<String> aliasesStart=new HashSet<>();
    if (cardNameAliasesStart.containsKey(cardSet)) {
      aliasesStart.addAll(cardNameAliasesStart.get(cardSet));
    }
    if (setNames == null) {
      setNames=cardSet.toLowerCase();
    }
    Preferences prefs=MageFrame.getPreferences();
    Connection.ProxyType proxyType=Connection.ProxyType.valueByText(prefs.get(""String_Node_Str"",""String_Node_Str""));
    for (    String setName : setNames.split(""String_Node_Str"")) {
      String URLSetName=URLEncoder.encode(setName,""String_Node_Str"");
      String baseUrl=""String_Node_Str"" + URLSetName + ""String_Node_Str"";
      String urlDocument;
      Document doc;
      if (proxyType.equals(ProxyType.NONE)) {
        urlDocument=baseUrl;
        doc=Jsoup.connect(urlDocument).get();
      }
 else {
        String proxyServer=prefs.get(""String_Node_Str"",""String_Node_Str"");
        int proxyPort=Integer.parseInt(prefs.get(""String_Node_Str"",""String_Node_Str""));
        URL url=new URL(baseUrl);
        Proxy proxy=new Proxy(Proxy.Type.HTTP,new InetSocketAddress(proxyServer,proxyPort));
        HttpURLConnection uc=(HttpURLConnection)url.openConnection(proxy);
        uc.connect();
        String line;
        StringBuffer tmp=new StringBuffer();
        BufferedReader in=new BufferedReader(new InputStreamReader(uc.getInputStream()));
        while ((line=in.readLine()) != null) {
          tmp.append(line);
        }
        doc=Jsoup.parse(String.valueOf(tmp));
      }
      Elements cardsImages=doc.select(""String_Node_Str"");
      if (!aliasesStart.isEmpty()) {
        for (        String text : aliasesStart) {
          cardsImages.addAll(doc.select(""String_Node_Str"" + text + ""String_Node_Str""));
        }
      }
      if (cardsImages.isEmpty()) {
        break;
      }
      for (      Element cardsImage : cardsImages) {
        String cardLink=cardsImage.attr(""String_Node_Str"");
        String cardName=null;
        if (cardLink.startsWith(""String_Node_Str"") && cardLink.endsWith(""String_Node_Str"")) {
          cardName=cardLink.substring(6,cardLink.length() - 4);
        }
 else         if (aliasesStart.contains(cardLink)) {
          cardName=cardLink.substring(0,cardLink.length() - 4);
          ;
        }
        if (cardName != null && !cardName.isEmpty()) {
          if (cardNameAliases.containsKey(cardSet + ""String_Node_Str"" + cardName)) {
            cardName=cardNameAliases.get(cardSet + ""String_Node_Str"" + cardName);
          }
 else {
            if (cardName.endsWith(""String_Node_Str"") || cardName.endsWith(""String_Node_Str"") || cardName.endsWith(""String_Node_Str"")|| cardName.endsWith(""String_Node_Str"")|| cardName.endsWith(""String_Node_Str"")) {
              if (!cardName.startsWith(""String_Node_Str"") && !cardName.startsWith(""String_Node_Str"") && !cardName.startsWith(""String_Node_Str"")&& !cardName.startsWith(""String_Node_Str"")&& !cardName.startsWith(""String_Node_Str"")) {
                cardName=cardName.substring(0,cardName.length() - 1);
              }
            }
          }
          setLinks.put(cardName,baseUrl + cardLink);
        }
      }
    }
  }
 catch (  IOException ex) {
    System.out.println(""String_Node_Str"" + ex.getMessage());
  }
  return setLinks;
}",0.995575221238938
158688,"public MythicspoilerComSource(){
  sets=new LinkedHashMap<>();
  setsAliases=new HashMap<>();
  setsAliases.put(""String_Node_Str"",""String_Node_Str"");
  cardNameAliases=new HashMap<>();
  cardNameAliases.put(""String_Node_Str"",""String_Node_Str"");
  cardNameAliases.put(""String_Node_Str"",""String_Node_Str"");
  cardNameAliases.put(""String_Node_Str"",""String_Node_Str"");
  cardNameAliases.put(""String_Node_Str"",""String_Node_Str"");
  cardNameAliases.put(""String_Node_Str"",""String_Node_Str"");
  cardNameAliases.put(""String_Node_Str"",""String_Node_Str"");
  cardNameAliases.put(""String_Node_Str"",""String_Node_Str"");
  cardNameAliases.put(""String_Node_Str"",""String_Node_Str"");
  cardNameAliases.put(""String_Node_Str"",""String_Node_Str"");
  cardNameAliasesStart=new HashMap<>();
  HashSet<String> names=new HashSet<>();
  names.add(""String_Node_Str"");
  cardNameAliasesStart.put(""String_Node_Str"",names);
}","public MythicspoilerComSource(){
  sets=new LinkedHashMap<>();
  setsAliases=new HashMap<>();
  setsAliases.put(""String_Node_Str"",""String_Node_Str"");
  cardNameAliases=new HashMap<>();
  cardNameAliases.put(""String_Node_Str"",""String_Node_Str"");
  cardNameAliases.put(""String_Node_Str"",""String_Node_Str"");
  cardNameAliases.put(""String_Node_Str"",""String_Node_Str"");
  cardNameAliases.put(""String_Node_Str"",""String_Node_Str"");
  cardNameAliases.put(""String_Node_Str"",""String_Node_Str"");
  cardNameAliases.put(""String_Node_Str"",""String_Node_Str"");
  cardNameAliases.put(""String_Node_Str"",""String_Node_Str"");
  cardNameAliases.put(""String_Node_Str"",""String_Node_Str"");
  cardNameAliases.put(""String_Node_Str"",""String_Node_Str"");
  cardNameAliases.put(""String_Node_Str"",""String_Node_Str"");
  cardNameAliases.put(""String_Node_Str"",""String_Node_Str"");
  cardNameAliasesStart=new HashMap<>();
  HashSet<String> names=new HashSet<>();
  names.add(""String_Node_Str"");
  cardNameAliasesStart.put(""String_Node_Str"",names);
}",0.9369747899159664
158689,"@Override public void run(){
  StringBuilder filePath=new StringBuilder();
  File temporaryFile=null;
  TFile outputFile=null;
  try {
    filePath.append(Constants.IO.imageBaseDir);
    filePath.append(card.hashCode()).append(""String_Node_Str"").append(card.getName().replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str"")).append(""String_Node_Str"");
    temporaryFile=new File(filePath.toString());
    String imagePath=CardImageUtils.generateImagePath(card);
    outputFile=new TFile(imagePath);
    if (!outputFile.exists()) {
      outputFile.getParentFile().mkdirs();
    }
    File existingFile=new File(imagePath.replaceFirst(""String_Node_Str"",""String_Node_Str""));
    if (existingFile.exists()) {
      new TFile(existingFile).cp_rp(outputFile);
synchronized (sync) {
        update(cardIndex + 1,count);
      }
      existingFile.delete();
      File parent=existingFile.getParentFile();
      if (parent != null && parent.isDirectory() && parent.list().length == 0) {
        parent.delete();
      }
      return;
    }
    BufferedOutputStream out;
    URLConnection httpConn=url.openConnection(p);
    httpConn.connect();
    int responseCode=((HttpURLConnection)httpConn).getResponseCode();
    if (responseCode == 200) {
      try (BufferedInputStream in=new BufferedInputStream(((HttpURLConnection)httpConn).getInputStream())){
        out=new BufferedOutputStream(new TFileOutputStream(temporaryFile));
        byte[] buf=new byte[1024];
        int len;
        while ((len=in.read(buf)) != -1) {
          if (cancel) {
            in.close();
            out.flush();
            out.close();
            temporaryFile.delete();
            return;
          }
          out.write(buf,0,len);
        }
      }
       out.flush();
      out.close();
      if (card.isTwoFacedCard()) {
        BufferedImage image=ImageIO.read(temporaryFile);
        if (image.getHeight() == 470) {
          BufferedImage renderedImage=new BufferedImage(265,370,BufferedImage.TYPE_INT_RGB);
          renderedImage.getGraphics();
          Graphics2D graphics2D=renderedImage.createGraphics();
          if (card.isTwoFacedCard() && card.isSecondSide()) {
            graphics2D.drawImage(image,0,0,265,370,313,62,578,432,null);
          }
 else {
            graphics2D.drawImage(image,0,0,265,370,41,62,306,432,null);
          }
          graphics2D.dispose();
          writeImageToFile(renderedImage,outputFile);
        }
 else {
          new TFile(temporaryFile).cp_rp(outputFile);
        }
        temporaryFile.delete();
      }
 else {
        new TFile(temporaryFile).cp_rp(outputFile);
      }
    }
 else {
      logger.warn(""String_Node_Str"" + card.getName() + ""String_Node_Str""+ card.getSet()+ ""String_Node_Str""+ responseCode+ ""String_Node_Str""+ url.toString());
      if (logger.isDebugEnabled()) {
        logger.debug(""String_Node_Str"" + convertStreamToString(((HttpURLConnection)httpConn).getErrorStream()));
      }
    }
  }
 catch (  AccessDeniedException e) {
    logger.error(""String_Node_Str"" + (outputFile != null ? outputFile.toString() : ""String_Node_Str"" + card.getName() + ""String_Node_Str""+ card.getSet()+ ""String_Node_Str"") + ""String_Node_Str"");
  }
catch (  Exception e) {
    logger.error(e,e);
  }
 finally {
    if (temporaryFile != null) {
      temporaryFile.delete();
    }
  }
synchronized (sync) {
    update(cardIndex + 1,count);
  }
}","@Override public void run(){
  StringBuilder filePath=new StringBuilder();
  File temporaryFile=null;
  TFile outputFile=null;
  try {
    filePath.append(Constants.IO.imageBaseDir);
    filePath.append(card.hashCode()).append(""String_Node_Str"").append(card.getName().replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str"")).append(""String_Node_Str"");
    temporaryFile=new File(filePath.toString());
    String imagePath=CardImageUtils.generateImagePath(card);
    outputFile=new TFile(imagePath);
    if (!outputFile.exists()) {
      outputFile.getParentFile().mkdirs();
    }
    File existingFile=new File(imagePath.replaceFirst(""String_Node_Str"",""String_Node_Str""));
    if (existingFile.exists()) {
      new TFile(existingFile).cp_rp(outputFile);
synchronized (sync) {
        update(cardIndex + 1,count);
      }
      existingFile.delete();
      File parent=existingFile.getParentFile();
      if (parent != null && parent.isDirectory() && parent.list().length == 0) {
        parent.delete();
      }
      return;
    }
    BufferedOutputStream out;
    URLConnection httpConn=url.openConnection(p);
    httpConn.connect();
    int responseCode=((HttpURLConnection)httpConn).getResponseCode();
    if (responseCode == 200) {
      try (BufferedInputStream in=new BufferedInputStream(((HttpURLConnection)httpConn).getInputStream())){
        out=new BufferedOutputStream(new TFileOutputStream(temporaryFile));
        byte[] buf=new byte[1024];
        int len;
        while ((len=in.read(buf)) != -1) {
          if (cancel) {
            in.close();
            out.flush();
            out.close();
            temporaryFile.delete();
            return;
          }
          out.write(buf,0,len);
        }
      }
       out.flush();
      out.close();
      if (card.isTwoFacedCard()) {
        BufferedImage image=ImageIO.read(temporaryFile);
        if (image.getHeight() == 470) {
          BufferedImage renderedImage=new BufferedImage(265,370,BufferedImage.TYPE_INT_RGB);
          renderedImage.getGraphics();
          Graphics2D graphics2D=renderedImage.createGraphics();
          if (card.isTwoFacedCard() && card.isSecondSide()) {
            graphics2D.drawImage(image,0,0,265,370,313,62,578,432,null);
          }
 else {
            graphics2D.drawImage(image,0,0,265,370,41,62,306,432,null);
          }
          graphics2D.dispose();
          writeImageToFile(renderedImage,outputFile);
        }
 else {
          new TFile(temporaryFile).cp_rp(outputFile);
        }
        temporaryFile.delete();
      }
 else {
        new TFile(temporaryFile).cp_rp(outputFile);
      }
    }
 else {
      logger.warn(""String_Node_Str"" + card.getName() + (!card.getDownloadName().equals(card.getName()) ? ""String_Node_Str"" + card.getDownloadName() : ""String_Node_Str"")+ ""String_Node_Str""+ card.getSet()+ ""String_Node_Str""+ responseCode+ ""String_Node_Str""+ url.toString());
      if (logger.isDebugEnabled()) {
        logger.debug(""String_Node_Str"" + convertStreamToString(((HttpURLConnection)httpConn).getErrorStream()));
      }
    }
  }
 catch (  AccessDeniedException e) {
    logger.error(""String_Node_Str"" + (outputFile != null ? outputFile.toString() : ""String_Node_Str"" + card.getName() + ""String_Node_Str""+ card.getSet()+ ""String_Node_Str"") + ""String_Node_Str"");
  }
catch (  Exception e) {
    logger.error(e,e);
  }
 finally {
    if (temporaryFile != null) {
      temporaryFile.delete();
    }
  }
synchronized (sync) {
    update(cardIndex + 1,count);
  }
}",0.9834651329978432
158690,"@Override public boolean apply(Game game,Ability source){
  StackObject stackObject=game.getStack().getStackObject(source.getFirstTarget());
  MageObject sourceObject=game.getObject(source.getSourceId());
  if (stackObject != null && sourceObject != null) {
    Targets targets=new Targets();
    Ability sourceAbility;
    String oldTargetName=null;
    if (stackObject instanceof Spell) {
      Spell spell=(Spell)stackObject;
      sourceAbility=spell.getSpellAbility();
    }
 else     if (stackObject instanceof StackAbility) {
      StackAbility stackAbility=(StackAbility)stackObject;
      sourceAbility=stackAbility;
    }
 else {
      return false;
    }
    for (    Mode mode : sourceAbility.getModes().getSelectedModes()) {
      targets.addAll(mode.getTargets());
    }
    boolean twoTimesTarget=false;
    if (targets.size() == 1 && targets.get(0).getTargets().size() == 1) {
      Target target=targets.get(0);
      if (target.canTarget(stackObject.getControllerId(),source.getSourceId(),sourceAbility,game)) {
        oldTargetName=getTargetName(targets.getFirstTarget(),game);
        target.clearChosen();
        target.addTarget(source.getSourceId(),stackObject.getStackAbility(),game);
      }
    }
 else {
      Player controller=game.getPlayer(source.getControllerId());
      boolean validTargets=false;
      do {
        for (        Target target : targets) {
          for (          UUID targetId : target.getTargets()) {
            String name=getTargetName(targets.getFirstTarget(),game);
            if (!targetId.equals(source.getSourceId()) && target.getTargets().contains(source.getSourceId())) {
              twoTimesTarget=true;
              continue;
            }
            if (target.canTarget(stackObject.getControllerId(),source.getSourceId(),sourceAbility,game)) {
              validTargets=true;
              if (name != null && controller.chooseUse(Outcome.Neutral,""String_Node_Str"" + name + ""String_Node_Str""+ sourceObject.getLogName()+ ""String_Node_Str"",source,game)) {
                oldTargetName=getTargetName(targetId,game);
                target.remove(targetId);
                target.addTarget(source.getSourceId(),stackObject.getStackAbility(),game);
                break;
              }
            }
          }
          if (oldTargetName != null) {
            break;
          }
        }
        if (oldTargetName == null) {
          game.informPlayer(controller,""String_Node_Str"" + sourceObject.getIdName() + ""String_Node_Str"");
        }
      }
 while (validTargets && oldTargetName == null);
    }
    if (oldTargetName != null) {
      game.informPlayers(sourceObject.getLogName() + ""String_Node_Str"" + stackObject.getLogName()+ ""String_Node_Str""+ oldTargetName+ ""String_Node_Str""+ sourceObject.getLogName());
    }
 else {
      if (twoTimesTarget) {
        game.informPlayers(sourceObject.getLogName() + ""String_Node_Str"" + sourceObject.getLogName()+ ""String_Node_Str""+ stackObject.getLogName());
      }
 else {
        game.informPlayers(sourceObject.getLogName() + ""String_Node_Str"" + sourceObject.getLogName()+ ""String_Node_Str""+ stackObject.getLogName());
      }
    }
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  StackObject stackObject=game.getStack().getStackObject(source.getFirstTarget());
  MageObject sourceObject=game.getObject(source.getSourceId());
  if (stackObject != null && sourceObject != null) {
    Targets targets=new Targets();
    Ability sourceAbility;
    String oldTargetName=null;
    if (stackObject instanceof Spell) {
      Spell spell=(Spell)stackObject;
      sourceAbility=spell.getSpellAbility();
    }
 else     if (stackObject instanceof StackAbility) {
      StackAbility stackAbility=(StackAbility)stackObject;
      sourceAbility=stackAbility;
    }
 else {
      return false;
    }
    for (    Mode mode : sourceAbility.getModes().getSelectedModes()) {
      targets.addAll(mode.getTargets());
    }
    boolean twoTimesTarget=false;
    if (targets.size() == 1 && targets.get(0).getTargets().size() == 1) {
      Target target=targets.get(0);
      if (target.getFirstTarget().equals(source.getSourceId())) {
        return true;
      }
      if (target.canTarget(stackObject.getControllerId(),source.getSourceId(),sourceAbility,game)) {
        oldTargetName=getTargetName(targets.getFirstTarget(),game);
        target.clearChosen();
        target.addTarget(source.getSourceId(),stackObject.getStackAbility(),game);
      }
    }
 else {
      Player controller=game.getPlayer(source.getControllerId());
      boolean validTargets=false;
      do {
        for (        Target target : targets) {
          for (          UUID targetId : target.getTargets()) {
            String name=getTargetName(targets.getFirstTarget(),game);
            if (!targetId.equals(source.getSourceId()) && target.getTargets().contains(source.getSourceId())) {
              twoTimesTarget=true;
              continue;
            }
            if (target.canTarget(stackObject.getControllerId(),source.getSourceId(),sourceAbility,game)) {
              validTargets=true;
              if (name != null && controller.chooseUse(Outcome.Neutral,""String_Node_Str"" + name + ""String_Node_Str""+ sourceObject.getLogName()+ ""String_Node_Str"",source,game)) {
                oldTargetName=getTargetName(targetId,game);
                target.remove(targetId);
                target.addTarget(source.getSourceId(),stackObject.getStackAbility(),game);
                break;
              }
            }
          }
          if (oldTargetName != null) {
            break;
          }
        }
        if (oldTargetName == null) {
          game.informPlayer(controller,""String_Node_Str"" + sourceObject.getIdName() + ""String_Node_Str"");
        }
      }
 while (validTargets && oldTargetName == null);
    }
    if (oldTargetName != null) {
      game.informPlayers(sourceObject.getLogName() + ""String_Node_Str"" + stackObject.getLogName()+ ""String_Node_Str""+ oldTargetName+ ""String_Node_Str""+ sourceObject.getLogName());
    }
 else {
      if (twoTimesTarget) {
        game.informPlayers(sourceObject.getLogName() + ""String_Node_Str"" + sourceObject.getLogName()+ ""String_Node_Str""+ stackObject.getLogName());
      }
 else {
        game.informPlayers(sourceObject.getLogName() + ""String_Node_Str"" + sourceObject.getLogName()+ ""String_Node_Str""+ stackObject.getLogName());
      }
    }
    return true;
  }
  return false;
}",0.985373364126251
158691,"/** 
 * Test if a Thragtusk is copied by a Phyrexian Metamorph that leave battlefield ability does not work, if  the copy left all abilities by Turn to Frog
 */
@Test public void testPhyrexianMetamorphTurnToFrog(){
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"",4);
  addCard(Zone.HAND,playerA,""String_Node_Str"",1);
  addCard(Zone.BATTLEFIELD,playerB,""String_Node_Str"",6);
  addCard(Zone.BATTLEFIELD,playerB,""String_Node_Str"",6);
  addCard(Zone.HAND,playerB,""String_Node_Str"",1);
  addCard(Zone.HAND,playerB,""String_Node_Str"",1);
  addCard(Zone.HAND,playerB,""String_Node_Str"",1);
  addCard(Zone.BATTLEFIELD,playerB,""String_Node_Str"",1);
  castSpell(1,PhaseStep.PRECOMBAT_MAIN,playerA,""String_Node_Str"");
  setChoice(playerA,""String_Node_Str"");
  setChoice(playerA,""String_Node_Str"");
  castSpell(1,PhaseStep.BEGIN_COMBAT,playerB,""String_Node_Str"");
  castSpell(1,PhaseStep.DECLARE_ATTACKERS,playerB,""String_Node_Str"",""String_Node_Str"");
  castSpell(1,PhaseStep.POSTCOMBAT_MAIN,playerB,""String_Node_Str"",""String_Node_Str"");
  setStopAt(1,PhaseStep.END_TURN);
  execute();
  assertGraveyardCount(playerB,""String_Node_Str"",1);
  assertGraveyardCount(playerB,""String_Node_Str"",1);
  assertPermanentCount(playerB,""String_Node_Str"",1);
  assertPermanentCount(playerA,""String_Node_Str"",0);
  assertGraveyardCount(playerA,""String_Node_Str"",1);
  assertGraveyardCount(playerB,""String_Node_Str"",1);
  assertLife(playerA,25);
  assertLife(playerB,20);
  assertPermanentCount(playerA,""String_Node_Str"",0);
}","/** 
 * Test if a Thragtusk is copied by a Phyrexian Metamorph that leave battlefield ability does not work, if the copy left all abilities by Turn to Frog
 */
@Test public void testPhyrexianMetamorphTurnToFrog(){
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"",4);
  addCard(Zone.HAND,playerA,""String_Node_Str"",1);
  addCard(Zone.BATTLEFIELD,playerB,""String_Node_Str"",6);
  addCard(Zone.BATTLEFIELD,playerB,""String_Node_Str"",6);
  addCard(Zone.HAND,playerB,""String_Node_Str"",1);
  addCard(Zone.HAND,playerB,""String_Node_Str"",1);
  addCard(Zone.HAND,playerB,""String_Node_Str"",1);
  addCard(Zone.BATTLEFIELD,playerB,""String_Node_Str"",1);
  castSpell(1,PhaseStep.PRECOMBAT_MAIN,playerA,""String_Node_Str"");
  setChoice(playerA,""String_Node_Str"");
  setChoice(playerA,""String_Node_Str"");
  castSpell(1,PhaseStep.BEGIN_COMBAT,playerB,""String_Node_Str"");
  castSpell(1,PhaseStep.DECLARE_ATTACKERS,playerB,""String_Node_Str"",""String_Node_Str"");
  castSpell(1,PhaseStep.POSTCOMBAT_MAIN,playerB,""String_Node_Str"",""String_Node_Str"");
  setStopAt(1,PhaseStep.END_TURN);
  execute();
  assertGraveyardCount(playerB,""String_Node_Str"",1);
  assertGraveyardCount(playerB,""String_Node_Str"",1);
  assertPermanentCount(playerB,""String_Node_Str"",1);
  assertPermanentCount(playerA,""String_Node_Str"",0);
  assertGraveyardCount(playerA,""String_Node_Str"",1);
  assertGraveyardCount(playerB,""String_Node_Str"",1);
  assertLife(playerA,25);
  assertLife(playerB,20);
  assertPermanentCount(playerA,""String_Node_Str"",0);
}",0.9996667777407532
158692,"private void checkTrigger(TriggeredAbility ability,GameEvent event,Game game){
  MageObject object=game.getObject(ability.getSourceId());
  if (ability.isInUseableZone(game,object,event)) {
    if (event == null || !game.getContinuousEffects().preventedByRuleModification(event,ability,game,false)) {
      if (object != null) {
        boolean controllerSet=false;
        if (!ability.getZone().equals(Zone.COMMAND) && event != null && event.getTargetId() != null && ((event.getType().equals(EventType.ZONE_CHANGE) && ((ZoneChangeEvent)event).getFromZone().equals(Zone.BATTLEFIELD)) || event.getType().equals(EventType.DESTROYED_PERMANENT) || event.getType().equals(EventType.SACRIFICED_PERMANENT)) && game.getLKI().get(Zone.BATTLEFIELD) != null && game.getLKI().get(Zone.BATTLEFIELD).containsKey(ability.getSourceId())) {
          Permanent permanent=(Permanent)game.getLastKnownInformation(ability.getSourceId(),Zone.BATTLEFIELD,ability.getSourceObjectZoneChangeCounter() - 1);
          if (permanent != null) {
            if (!ability.getWorksFaceDown() && permanent.isFaceDown(game)) {
              return;
            }
            controllerSet=true;
            ability.setControllerId(permanent.getControllerId());
          }
        }
        if (!controllerSet) {
          if (object instanceof Permanent) {
            ability.setControllerId(((Permanent)object).getControllerId());
          }
 else           if (object instanceof Spell) {
            ability.setControllerId(((Spell)object).getControllerId());
          }
 else           if (object instanceof Card) {
            ability.setControllerId(((Card)object).getOwnerId());
          }
        }
      }
      if (ability.checkTrigger(event,game)) {
        ability.trigger(game,ability.getControllerId());
      }
    }
  }
}","private void checkTrigger(TriggeredAbility ability,GameEvent event,Game game){
  MageObject object=game.getObject(ability.getSourceId());
  if (ability.isInUseableZone(game,object,event)) {
    if (event == null || !game.getContinuousEffects().preventedByRuleModification(event,ability,game,false)) {
      if (object != null) {
        boolean controllerSet=false;
        if (!ability.getZone().equals(Zone.COMMAND) && event != null && event.getTargetId() != null && ability.isLeavesTheBattlefieldTrigger() && game.getLKI().get(Zone.BATTLEFIELD) != null && game.getLKI().get(Zone.BATTLEFIELD).containsKey(ability.getSourceId())) {
          Permanent permanent=(Permanent)game.getLastKnownInformation(ability.getSourceId(),Zone.BATTLEFIELD,ability.getSourceObjectZoneChangeCounter() - 1);
          if (permanent != null) {
            if (!ability.getWorksFaceDown() && permanent.isFaceDown(game)) {
              return;
            }
            controllerSet=true;
            ability.setControllerId(permanent.getControllerId());
          }
        }
        if (!controllerSet) {
          if (object instanceof Permanent) {
            ability.setControllerId(((Permanent)object).getControllerId());
          }
 else           if (object instanceof Spell) {
            ability.setControllerId(((Spell)object).getControllerId());
          }
 else           if (object instanceof Card) {
            ability.setControllerId(((Card)object).getOwnerId());
          }
        }
      }
      if (ability.checkTrigger(event,game)) {
        ability.trigger(game,ability.getControllerId());
      }
    }
  }
}",0.8347927612375948
158693,"@Override public boolean isInUseableZone(Game game,MageObject source,GameEvent event){
  if (event != null && event.getTargetId() != null && event.getTargetId().equals(getSourceId())) {
switch (event.getType()) {
case ZONE_CHANGE:
case DESTROYED_PERMANENT:
      if (event.getType().equals(EventType.DESTROYED_PERMANENT)) {
        source=game.getLastKnownInformation(getSourceId(),Zone.BATTLEFIELD);
      }
 else {
        if (((ZoneChangeEvent)event).getTarget() != null) {
          source=((ZoneChangeEvent)event).getTarget();
        }
 else {
          source=game.getLastKnownInformation(getSourceId(),((ZoneChangeEvent)event).getZone());
        }
      }
case PHASED_OUT:
case PHASED_IN:
    if (this.zone == Zone.ALL || game.getLastKnownInformation(getSourceId(),zone) != null) {
      return this.hasSourceObjectAbility(game,source,event);
    }
}
}
return super.isInUseableZone(game,source,event);
}","@Override public boolean isInUseableZone(Game game,MageObject source,GameEvent event){
  if (event != null && event.getTargetId() != null && event.getTargetId().equals(getSourceId())) {
switch (event.getType()) {
case ZONE_CHANGE:
case DESTROYED_PERMANENT:
      if (isLeavesTheBattlefieldTrigger()) {
        if (event.getType().equals(EventType.DESTROYED_PERMANENT)) {
          source=game.getLastKnownInformation(getSourceId(),Zone.BATTLEFIELD);
        }
 else {
          if (((ZoneChangeEvent)event).getTarget() != null) {
            source=((ZoneChangeEvent)event).getTarget();
          }
 else {
            source=game.getLastKnownInformation(getSourceId(),((ZoneChangeEvent)event).getZone());
          }
        }
      }
case PHASED_OUT:
case PHASED_IN:
    if (this.zone == Zone.ALL || game.getLastKnownInformation(getSourceId(),zone) != null) {
      return this.hasSourceObjectAbility(game,source,event);
    }
}
}
return super.isInUseableZone(game,source,event);
}",0.9625329815303432
158694,"public TriggeredAbilityImpl(final TriggeredAbilityImpl ability){
  super(ability);
  this.optional=ability.optional;
}","public TriggeredAbilityImpl(final TriggeredAbilityImpl ability){
  super(ability);
  this.optional=ability.optional;
  this.leavesTheBattlefieldTrigger=ability.leavesTheBattlefieldTrigger;
}",0.7662337662337663
158695,"@Override public boolean replaceEvent(GameEvent event,Ability source,Game game){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller != null) {
    EntersTheBattlefieldEvent entersTheBattlefieldEvent=(EntersTheBattlefieldEvent)event;
    controller.moveCards(entersTheBattlefieldEvent.getTarget(),Zone.EXILED,source,game,false,false,false,null);
    return true;
  }
  return false;
}","@Override public boolean replaceEvent(GameEvent event,Ability source,Game game){
  Player controller=game.getPlayer(source.getControllerId());
  Card targetCard=game.getCard(event.getTargetId());
  if (targetCard == null) {
    targetCard=((EntersTheBattlefieldEvent)event).getTarget();
  }
  if (controller != null && targetCard != null) {
    controller.moveCards(targetCard,Zone.EXILED,source,game,false,false,false,null);
    return true;
  }
  return false;
}",0.624
158696,"public int compare(CardView a,CardView b){
  Comparable aCom=null;
  Comparable bCom=null;
  if (column == 0) {
    aCom=Integer.valueOf(1);
    bCom=Integer.valueOf(1);
  }
 else   if (column == 1) {
    aCom=a.getName();
    bCom=b.getName();
    if (aCom.equals(bCom) && a.getExpansionSetCode().equals(b.getExpansionSetCode())) {
      aCom=a.getCardNumber();
      bCom=b.getCardNumber();
    }
  }
 else   if (column == 2) {
    aCom=a.getConvertedManaCost();
    bCom=b.getConvertedManaCost();
  }
 else   if (column == 3) {
    aCom=CardHelper.getColor(a);
    bCom=CardHelper.getColor(b);
  }
 else   if (column == 4) {
    aCom=CardHelper.getType(a);
    bCom=CardHelper.getType(b);
  }
 else   if (column == 5) {
    aCom=new Float(-1);
    bCom=new Float(-1);
    if (CardHelper.isCreature(a))     aCom=new Float(a.getPower() + ""String_Node_Str"" + a.getToughness());
    if (CardHelper.isCreature(b))     bCom=new Float(b.getPower() + ""String_Node_Str"" + b.getToughness());
  }
 else   if (column == 6) {
    aCom=a.getRarity().toString();
    bCom=b.getRarity().toString();
  }
 else   if (column == 7) {
    aCom=a.getExpansionSetCode();
    bCom=b.getExpansionSetCode();
  }
  if (ascending)   return aCom.compareTo(bCom);
 else   return bCom.compareTo(aCom);
}","@Override public int compare(CardView a,CardView b){
  Comparable aCom=null;
  Comparable bCom=null;
  if (column == 0) {
    aCom=1;
    bCom=1;
  }
 else   if (column == 1) {
    aCom=a.getName();
    bCom=b.getName();
    if (aCom.equals(bCom) && a.getExpansionSetCode().equals(b.getExpansionSetCode())) {
      aCom=a.getCardNumber();
      bCom=b.getCardNumber();
    }
  }
 else   if (column == 2) {
    aCom=a.getConvertedManaCost();
    bCom=b.getConvertedManaCost();
  }
 else   if (column == 3) {
    aCom=CardHelper.getColor(a);
    bCom=CardHelper.getColor(b);
  }
 else   if (column == 4) {
    aCom=CardHelper.getType(a);
    bCom=CardHelper.getType(b);
  }
 else   if (column == 5) {
    aCom=(float)-1;
    bCom=(float)-1;
    if (CardHelper.isCreature(a)) {
      aCom=new Float(a.getPower() + ""String_Node_Str"" + (a.getToughness().startsWith(""String_Node_Str"") ? ""String_Node_Str"" : a.getToughness()));
    }
    if (CardHelper.isCreature(b)) {
      bCom=new Float(b.getPower() + ""String_Node_Str"" + (b.getToughness().startsWith(""String_Node_Str"") ? ""String_Node_Str"" : b.getToughness()));
    }
  }
 else   if (column == 6) {
    aCom=a.getRarity().toString();
    bCom=b.getRarity().toString();
  }
 else   if (column == 7) {
    aCom=a.getExpansionSetCode();
    bCom=b.getExpansionSetCode();
  }
  if (ascending) {
    return aCom.compareTo(bCom);
  }
 else {
    return bCom.compareTo(aCom);
  }
}",0.8308605341246291
158697,"private void checkTrigger(TriggeredAbility ability,GameEvent event,Game game){
  MageObject object=game.getObject(ability.getSourceId());
  if (ability.isInUseableZone(game,object,event)) {
    if (event == null || !game.getContinuousEffects().preventedByRuleModification(event,ability,game,false)) {
      if (object != null) {
        boolean controllerSet=false;
        if (!ability.getZone().equals(Zone.COMMAND) && event != null && event.getTargetId() != null && event.getTargetId().equals(ability.getSourceId()) && (event.getType().equals(EventType.ZONE_CHANGE) || event.getType().equals(EventType.DESTROYED_PERMANENT) || event.getType().equals(EventType.SACRIFICED_PERMANENT))) {
          Permanent permanent=(Permanent)game.getLastKnownInformation(ability.getSourceId(),Zone.BATTLEFIELD,ability.getSourceObjectZoneChangeCounter() - 1);
          if (permanent != null) {
            if (!ability.getWorksFaceDown() && permanent.isFaceDown(game)) {
              return;
            }
            controllerSet=true;
            ability.setControllerId(permanent.getControllerId());
          }
        }
        if (!controllerSet) {
          if (object instanceof Permanent) {
            ability.setControllerId(((Permanent)object).getControllerId());
          }
 else           if (object instanceof Spell) {
            ability.setControllerId(((Spell)object).getControllerId());
          }
 else           if (object instanceof Card) {
            ability.setControllerId(((Card)object).getOwnerId());
          }
        }
      }
      if (ability.checkTrigger(event,game)) {
        ability.trigger(game,ability.getControllerId());
      }
    }
  }
}","private void checkTrigger(TriggeredAbility ability,GameEvent event,Game game){
  MageObject object=game.getObject(ability.getSourceId());
  if (ability.isInUseableZone(game,object,event)) {
    if (event == null || !game.getContinuousEffects().preventedByRuleModification(event,ability,game,false)) {
      if (object != null) {
        boolean controllerSet=false;
        if (!ability.getZone().equals(Zone.COMMAND) && event != null && event.getTargetId() != null && ((event.getType().equals(EventType.ZONE_CHANGE) && ((ZoneChangeEvent)event).getFromZone().equals(Zone.BATTLEFIELD)) || event.getType().equals(EventType.DESTROYED_PERMANENT) || event.getType().equals(EventType.SACRIFICED_PERMANENT)) && game.getLKI().get(Zone.BATTLEFIELD) != null && game.getLKI().get(Zone.BATTLEFIELD).containsKey(ability.getSourceId())) {
          Permanent permanent=(Permanent)game.getLastKnownInformation(ability.getSourceId(),Zone.BATTLEFIELD,ability.getSourceObjectZoneChangeCounter() - 1);
          if (permanent != null) {
            if (!ability.getWorksFaceDown() && permanent.isFaceDown(game)) {
              return;
            }
            controllerSet=true;
            ability.setControllerId(permanent.getControllerId());
          }
        }
        if (!controllerSet) {
          if (object instanceof Permanent) {
            ability.setControllerId(((Permanent)object).getControllerId());
          }
 else           if (object instanceof Spell) {
            ability.setControllerId(((Spell)object).getControllerId());
          }
 else           if (object instanceof Card) {
            ability.setControllerId(((Card)object).getOwnerId());
          }
        }
      }
      if (ability.checkTrigger(event,game)) {
        ability.trigger(game,ability.getControllerId());
      }
    }
  }
}",0.930192473427176
158698,"public ExchangeControlTargetEffect(final ExchangeControlTargetEffect effect){
  super(effect);
  this.rule=effect.rule;
  this.withSource=effect.withSource;
  this.withSecondTarget=effect.withSecondTarget;
  this.lockedControllers=new HashMap<UUID,UUID>(effect.lockedControllers);
  this.zoneChangeCounter=new HashMap<UUID,Integer>(effect.zoneChangeCounter);
}","public ExchangeControlTargetEffect(final ExchangeControlTargetEffect effect){
  super(effect);
  this.rule=effect.rule;
  this.withSource=effect.withSource;
  this.withSecondTarget=effect.withSecondTarget;
  this.lockedControllers=new HashMap<>(effect.lockedControllers);
  this.zoneChangeCounter=new HashMap<>(effect.zoneChangeCounter);
}",0.9699570815450644
158699,"@Override public boolean apply(Game game,Ability source){
  Player player=game.getPlayer(this.getTargetPointer().getFirst(game,source));
  Player controller=game.getPlayer(source.getControllerId());
  if (player == null || controller == null) {
    return false;
  }
  Cards cards=new CardsImpl();
  cards.addAll(player.getLibrary().getTopCards(game,7));
  controller.moveCards(cards,Zone.EXILED,source,game);
  if (cards.getCards(new FilterCreatureCard(),game).size() > 0) {
    TargetCard target=new TargetCard(Zone.EXILED,new FilterCreatureCard());
    if (controller.chooseTarget(outcome,cards,target,source,game)) {
      Card card=cards.get(target.getFirstTarget(),game);
      if (card != null) {
        controller.moveCards(cards.getCards(game),Zone.BATTLEFIELD,source,game,false,false,false,null);
      }
    }
  }
  return true;
}","@Override public boolean apply(Game game,Ability source){
  Player player=game.getPlayer(this.getTargetPointer().getFirst(game,source));
  Player controller=game.getPlayer(source.getControllerId());
  if (player == null || controller == null) {
    return false;
  }
  Cards cards=new CardsImpl();
  cards.addAll(player.getLibrary().getTopCards(game,7));
  controller.moveCards(cards,Zone.EXILED,source,game);
  if (cards.getCards(new FilterCreatureCard(),game).size() > 0) {
    TargetCard target=new TargetCard(Zone.EXILED,new FilterCreatureCard());
    if (controller.chooseTarget(outcome,cards,target,source,game)) {
      Card card=cards.get(target.getFirstTarget(),game);
      if (card != null) {
        controller.moveCards(card,Zone.BATTLEFIELD,source,game,false,false,false,null);
      }
    }
  }
  return true;
}",0.9904076738609112
158700,"@Override public WhirlpoolSDrakeTriggeredEffect copy(){
  return new WhirlpoolSDrakeTriggeredEffect(this);
}","@Override public WhirlpoolDrake copy(){
  return new WhirlpoolDrake(this);
}",0.8260869565217391
158701,"@Override public WhirlpoolRiderTriggeredEffect copy(){
  return new WhirlpoolRiderTriggeredEffect(this);
}","@Override public WhirlpoolRider copy(){
  return new WhirlpoolRider(this);
}",0.8351648351648352
158702,"@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller != null) {
    for (    UUID playerId : controller.getInRange()) {
      Player player=game.getPlayer(playerId);
      if (player != null) {
        int cardsHand=player.getHand().size();
        if (cardsHand > 0) {
          for (          Card card : player.getHand().getCards(game)) {
            if (card != null) {
              player.removeFromHand(card,game);
              card.moveToZone(Zone.LIBRARY,source.getSourceId(),game,true);
            }
          }
          game.informPlayers(player.getLogName() + ""String_Node_Str"");
          player.shuffleLibrary(game);
          player.drawCards(cardsHand,game);
        }
      }
    }
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller != null) {
    Map<UUID,Integer> playerCards=new LinkedHashMap<>();
    for (    UUID playerId : game.getState().getPlayersInRange(controller.getId(),game)) {
      Player player=game.getPlayer(playerId);
      if (player != null) {
        int cardsHand=player.getHand().size();
        if (cardsHand > 0) {
          playerCards.put(playerId,cardsHand);
          player.moveCards(player.getHand(),Zone.LIBRARY,source,game);
          player.shuffleLibrary(game);
        }
      }
    }
    for (    Entry<UUID,Integer> entry : playerCards.entrySet()) {
      Player player=game.getPlayer(entry.getKey());
      if (player != null) {
        player.drawCards(entry.getValue(),game);
      }
    }
    return true;
  }
  return false;
}",0.5709240729841083
158703,"/** 
 * Retrieves all requirements that apply and creates a Map with blockers and attackers it contains only records if attackers can be retrieved // Map<creature that can block, Set< all attackers the creature can block and force it to block the attacker>>
 * @param attackingPlayer - attacker
 * @param game
 */
private void retrieveMustBlockAttackerRequirements(Player attackingPlayer,Game game){
  if (!game.getContinuousEffects().existRequirementEffects()) {
    return;
  }
  for (  Permanent possibleBlocker : game.getBattlefield().getActivePermanents(filterBlockers,attackingPlayer.getId(),game)) {
    for (    Map.Entry<RequirementEffect,HashSet<Ability>> requirementEntry : game.getContinuousEffects().getApplicableRequirementEffects(possibleBlocker,game).entrySet()) {
      if (requirementEntry.getKey().mustBlock(game)) {
        for (        Ability ability : requirementEntry.getValue()) {
          UUID attackingCreatureId=requirementEntry.getKey().mustBlockAttacker(ability,game);
          Player defender=game.getPlayer(possibleBlocker.getControllerId());
          if (attackingCreatureId != null && defender != null && possibleBlocker.canBlock(attackingCreatureId,game)) {
            if (game.getContinuousEffects().checkIfThereArePayCostToAttackBlockEffects(GameEvent.getEvent(GameEvent.EventType.DECLARE_BLOCKER,attackingCreatureId,possibleBlocker.getId(),possibleBlocker.getControllerId()),game)) {
              continue;
            }
            if (!getDefendingPlayerId(attackingCreatureId,game).equals(possibleBlocker.getControllerId())) {
              continue;
            }
            if (creatureMustBlockAttackers.containsKey(possibleBlocker.getId())) {
              creatureMustBlockAttackers.get(possibleBlocker.getId()).add(attackingCreatureId);
            }
 else {
              Set<UUID> forcingAttackers=new HashSet<>();
              forcingAttackers.add(attackingCreatureId);
              creatureMustBlockAttackers.put(possibleBlocker.getId(),forcingAttackers);
              defender.declareBlocker(defender.getId(),possibleBlocker.getId(),attackingCreatureId,game);
            }
          }
        }
      }
    }
  }
}","/** 
 * Retrieves all requirements that apply and creates a Map with blockers and attackers it contains only records if attackers can be retrieved // Map<creature that can block, Set< all attackers the creature can block and force it to block the attacker>>
 * @param attackingPlayer - attacker
 * @param game
 */
private void retrieveMustBlockAttackerRequirements(Player attackingPlayer,Game game){
  if (!game.getContinuousEffects().existRequirementEffects()) {
    return;
  }
  for (  Permanent possibleBlocker : game.getBattlefield().getActivePermanents(filterBlockers,attackingPlayer.getId(),game)) {
    for (    Map.Entry<RequirementEffect,HashSet<Ability>> requirementEntry : game.getContinuousEffects().getApplicableRequirementEffects(possibleBlocker,game).entrySet()) {
      if (requirementEntry.getKey().mustBlock(game)) {
        for (        Ability ability : requirementEntry.getValue()) {
          UUID attackingCreatureId=requirementEntry.getKey().mustBlockAttacker(ability,game);
          Player defender=game.getPlayer(possibleBlocker.getControllerId());
          if (attackingCreatureId != null && defender != null && possibleBlocker.canBlock(attackingCreatureId,game)) {
            Permanent attackingCreature=game.getPermanent(attackingCreatureId);
            if (attackingCreature == null || !attackingCreature.isAttacking()) {
              continue;
            }
            if (game.getContinuousEffects().checkIfThereArePayCostToAttackBlockEffects(GameEvent.getEvent(GameEvent.EventType.DECLARE_BLOCKER,attackingCreatureId,possibleBlocker.getId(),possibleBlocker.getControllerId()),game)) {
              continue;
            }
            if (!getDefendingPlayerId(attackingCreatureId,game).equals(possibleBlocker.getControllerId())) {
              continue;
            }
            if (creatureMustBlockAttackers.containsKey(possibleBlocker.getId())) {
              creatureMustBlockAttackers.get(possibleBlocker.getId()).add(attackingCreatureId);
            }
 else {
              Set<UUID> forcingAttackers=new HashSet<>();
              forcingAttackers.add(attackingCreatureId);
              creatureMustBlockAttackers.put(possibleBlocker.getId(),forcingAttackers);
              defender.declareBlocker(defender.getId(),possibleBlocker.getId(),attackingCreatureId,game);
            }
          }
        }
      }
    }
  }
}",0.9562733465172488
158704,"@Override public boolean isInUseableZone(Game game,MageObject source,GameEvent event){
  Permanent sourcePermanent;
  if (game.getState().getZone(getSourceId()) == Zone.BATTLEFIELD) {
    sourcePermanent=game.getPermanent(getSourceId());
  }
 else {
    sourcePermanent=(Permanent)game.getLastKnownInformation(getSourceId(),Zone.BATTLEFIELD);
  }
  if (sourcePermanent == null) {
    return false;
  }
  return hasSourceObjectAbility(game,sourcePermanent,event);
}","@Override public boolean isInUseableZone(Game game,MageObject source,GameEvent event){
  Permanent sourcePermanent=null;
  if (game.getState().getZone(getSourceId()) == Zone.BATTLEFIELD) {
    sourcePermanent=game.getPermanent(getSourceId());
  }
 else {
    if (game.getShortLivingLKI(sourceId,Zone.BATTLEFIELD)) {
      sourcePermanent=(Permanent)game.getLastKnownInformation(getSourceId(),Zone.BATTLEFIELD);
    }
  }
  if (sourcePermanent == null) {
    return false;
  }
  return hasSourceObjectAbility(game,sourcePermanent,event);
}",0.8043912175648703
158705,"@Override public boolean checkTrigger(GameEvent event,Game game){
  if (event.getPlayerId().equals(this.getControllerId())) {
    Spell spell=game.getStack().getSpell(event.getTargetId());
    if (isControlledInstantOrSorcery(spell)) {
      this.getTargets().get(0).clearChosen();
      this.getTargets().get(0).add(spell.getId(),game);
      return true;
    }
  }
  return false;
}","@Override public boolean checkTrigger(GameEvent event,Game game){
  if (event.getPlayerId().equals(this.getControllerId())) {
    Spell spell=game.getStack().getSpell(event.getTargetId());
    if (isControlledInstantOrSorcery(spell)) {
      for (      Effect effect : getEffects()) {
        effect.setTargetPointer(new FixedTarget(spell.getId()));
      }
      return true;
    }
  }
  return false;
}",0.7055837563451777
158706,"@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  Card cardOne=game.getCard(source.getTargets().get(0).getFirstTarget());
  Card cardTwo=game.getCard(source.getTargets().get(1).getFirstTarget());
  if (controller != null) {
    if (cardOne != null) {
      controller.moveCardToExileWithInfo(cardOne,null,""String_Node_Str"",source.getSourceId(),game,Zone.GRAVEYARD,true);
    }
    if (cardTwo != null) {
      controller.moveCardToExileWithInfo(cardTwo,null,""String_Node_Str"",source.getSourceId(),game,Zone.GRAVEYARD,true);
    }
    boolean castCardOne=true;
    if (cardOne != null && controller.chooseUse(Outcome.Neutral,""String_Node_Str"" + cardOne.getName() + ""String_Node_Str"",source,game)) {
      Card copyOne=game.copyCard(cardOne,source,controller.getId());
      controller.cast(copyOne.getSpellAbility(),game,true);
      castCardOne=false;
    }
    if (cardTwo != null) {
      Card copyTwo=game.copyCard(cardTwo,source,controller.getId());
      controller.cast(copyTwo.getSpellAbility(),game,true);
    }
    if (cardOne != null && castCardOne) {
      Card copyOne=game.copyCard(cardOne,source,controller.getId());
      controller.cast(copyOne.getSpellAbility(),game,true);
    }
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  Card cardOne=game.getCard(source.getTargets().get(0).getFirstTarget());
  Card cardTwo=game.getCard(source.getTargets().get(1).getFirstTarget());
  if (controller != null) {
    if (cardOne != null) {
      controller.moveCards(cardOne,Zone.EXILED,source,game);
    }
    if (cardTwo != null) {
      controller.moveCards(cardTwo,Zone.EXILED,source,game);
    }
    boolean castCardOne=true;
    if (cardOne != null && controller.chooseUse(Outcome.Neutral,""String_Node_Str"" + cardOne.getName() + ""String_Node_Str"",source,game)) {
      Card copyOne=game.copyCard(cardOne,source,controller.getId());
      controller.cast(copyOne.getSpellAbility(),game,true);
      castCardOne=false;
    }
    if (cardTwo != null) {
      Card copyTwo=game.copyCard(cardTwo,source,controller.getId());
      controller.cast(copyTwo.getSpellAbility(),game,true);
    }
    if (cardOne != null && castCardOne) {
      Card copyOne=game.copyCard(cardOne,source,controller.getId());
      controller.cast(copyOne.getSpellAbility(),game,true);
    }
    return true;
  }
  return false;
}",0.4879807692307692
158707,"@Override public boolean applies(GameEvent event,Ability source,Game game){
  if (event.getType() == GameEvent.EventType.ACTIVATE_ABILITY) {
    MageObject object=game.getObject(event.getSourceId());
    Ability ability=game.getAbility(event.getTargetId(),event.getSourceId());
    if (ability != null && object != null) {
      if (ability.getAbilityType() != AbilityType.MANA && object.getName().equals(game.getState().getValue(source.getSourceId().toString() + NameACardEffect.INFO_KEY))) {
        return true;
      }
    }
  }
  return false;
}","@Override public boolean applies(GameEvent event,Ability source,Game game){
  MageObject object=game.getObject(event.getSourceId());
  Ability ability=game.getAbility(event.getTargetId(),event.getSourceId());
  if (ability != null && object != null) {
    if (!ability.getAbilityType().equals(AbilityType.MANA) && object.getName().equals(game.getState().getValue(source.getSourceId().toString() + NameACardEffect.INFO_KEY))) {
      return true;
    }
  }
  return false;
}",0.6588465298142717
158708,"/** 
 * Spelltwine Sorcery, 5U (6) Exile target instant or sorcery card from your graveyard and target instant  or sorcery card from an opponent's graveyard. Copy those cards. Cast the  copies if able without paying their mana costs. Exile Spelltwine.
 */
@Test public void testCopyCards(){
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"",6);
  addCard(Zone.HAND,playerA,""String_Node_Str"");
  addCard(Zone.GRAVEYARD,playerA,""String_Node_Str"");
  addCard(Zone.GRAVEYARD,playerB,""String_Node_Str"");
  castSpell(1,PhaseStep.PRECOMBAT_MAIN,playerA,""String_Node_Str"");
  addTarget(playerA,""String_Node_Str"");
  addTarget(playerA,""String_Node_Str"");
  setStopAt(1,PhaseStep.BEGIN_COMBAT);
  execute();
  assertExileCount(""String_Node_Str"",1);
  assertExileCount(""String_Node_Str"",1);
  assertExileCount(""String_Node_Str"",1);
  assertLife(playerB,15);
}","/** 
 * Spelltwine Sorcery, 5U (6) Exile target instant or sorcery card from your graveyard and target instant or sorcery card from an opponent's graveyard. Copy those cards. Cast the copies if able without paying their mana costs. Exile Spelltwine.
 */
@Test public void testCopyCards(){
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"",6);
  addCard(Zone.HAND,playerA,""String_Node_Str"");
  addCard(Zone.GRAVEYARD,playerA,""String_Node_Str"");
  addCard(Zone.GRAVEYARD,playerB,""String_Node_Str"");
  castSpell(1,PhaseStep.PRECOMBAT_MAIN,playerA,""String_Node_Str"");
  addTarget(playerA,""String_Node_Str"");
  addTarget(playerA,""String_Node_Str"");
  setStopAt(1,PhaseStep.BEGIN_COMBAT);
  execute();
  assertExileCount(""String_Node_Str"",1);
  assertExileCount(""String_Node_Str"",1);
  assertExileCount(""String_Node_Str"",1);
  assertLife(playerB,15);
}",0.9988235294117648
158709,"@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller != null) {
    Card spellCard=game.getStack().getSpell(source.getSourceId()).getCard();
    if (spellCard != null) {
      controller.moveCards(spellCard,Zone.EXILED,source,game);
    }
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller != null) {
    Spell spell=game.getStack().getSpell(source.getId());
    if (spell != null && !spell.isCopiedSpell()) {
      Card spellCard=spell.getCard();
      if (spellCard != null) {
        controller.moveCards(spellCard,Zone.EXILED,source,game);
      }
    }
    return true;
  }
  return false;
}",0.7487562189054726
158710,"@Override public boolean moveCardToGraveyardWithInfo(Card card,UUID sourceId,Game game,Zone fromZone){
  boolean result=false;
  if (card.moveToZone(Zone.GRAVEYARD,sourceId,game,fromZone != null ? fromZone.equals(Zone.BATTLEFIELD) : false)) {
    if (!game.isSimulation()) {
      if (card instanceof PermanentCard) {
        card=game.getCard(card.getId());
      }
      StringBuilder sb=new StringBuilder(this.getLogName()).append(""String_Node_Str"").append(card.getLogName()).append(""String_Node_Str"").append(fromZone != null ? ""String_Node_Str"" + fromZone.toString().toLowerCase(Locale.ENGLISH) + ""String_Node_Str"" : ""String_Node_Str"");
      if (card.getOwnerId().equals(getId())) {
        sb.append(""String_Node_Str"");
      }
 else {
        sb.append(""String_Node_Str"");
      }
      game.informPlayers(sb.toString());
    }
    result=true;
  }
  return result;
}","@Override public boolean moveCardToGraveyardWithInfo(Card card,UUID sourceId,Game game,Zone fromZone){
  boolean result=false;
  if (card.moveToZone(Zone.GRAVEYARD,sourceId,game,fromZone != null ? fromZone.equals(Zone.BATTLEFIELD) : false)) {
    if (!game.isSimulation()) {
      if (card instanceof PermanentCard) {
        card=game.getCard(card.getId());
      }
      StringBuilder sb=new StringBuilder(this.getLogName()).append(""String_Node_Str"").append(card.getLogName()).append(""String_Node_Str"").append(card.isCopy() ? ""String_Node_Str"" : ""String_Node_Str"").append(fromZone != null ? ""String_Node_Str"" + fromZone.toString().toLowerCase(Locale.ENGLISH) + ""String_Node_Str"" : ""String_Node_Str"");
      if (card.getOwnerId().equals(getId())) {
        sb.append(""String_Node_Str"");
      }
 else {
        sb.append(""String_Node_Str"");
      }
      game.informPlayers(sb.toString());
    }
    result=true;
  }
  return result;
}",0.9657458563535912
158711,"/** 
 * Handle the blocker selection process
 * @param blockController player that controlls how to block, if null thedefender is the controller
 * @param game
 */
public void selectBlockers(Player blockController,Game game){
  Player attacker=game.getPlayer(attackerId);
  this.retrieveMustBlockAttackerRequirements(attacker,game);
  Player controller;
  for (  UUID defenderId : getPlayerDefenders(game)) {
    Player defender=game.getPlayer(defenderId);
    if (defender != null) {
      boolean choose=true;
      if (blockController == null) {
        controller=defender;
      }
 else {
        controller=blockController;
      }
      while (choose) {
        controller.selectBlockers(game,defenderId);
        if (game.isPaused() || game.gameOver(null) || game.executingRollback()) {
          return;
        }
        if (!this.checkBlockRestrictions(defender,game)) {
          if (controller.isHuman()) {
            continue;
          }
        }
        choose=!this.checkBlockRequirementsAfter(defender,controller,game);
        if (!choose) {
          choose=!this.checkBlockRestrictionsAfter(defender,controller,game);
        }
      }
      game.fireEvent(GameEvent.getEvent(GameEvent.EventType.DECLARED_BLOCKERS,defenderId,defenderId));
      if (!game.isSimulation()) {
        this.logBlockerInfo(defender,game);
      }
    }
  }
  TraceUtil.traceCombatIfNeeded(game,this);
}","/** 
 * Handle the blocker selection process
 * @param blockController player that controlls how to block, if null thedefender is the controller
 * @param game
 */
public void selectBlockers(Player blockController,Game game){
  Player attacker=game.getPlayer(attackerId);
  game.getCombat().retrieveMustBlockAttackerRequirements(attacker,game);
  Player controller;
  for (  UUID defenderId : getPlayerDefenders(game)) {
    Player defender=game.getPlayer(defenderId);
    if (defender != null) {
      boolean choose=true;
      if (blockController == null) {
        controller=defender;
      }
 else {
        controller=blockController;
      }
      while (choose) {
        controller.selectBlockers(game,defenderId);
        if (game.isPaused() || game.gameOver(null) || game.executingRollback()) {
          return;
        }
        if (!game.getCombat().checkBlockRestrictions(defender,game)) {
          if (controller.isHuman()) {
            continue;
          }
        }
        choose=!game.getCombat().checkBlockRequirementsAfter(defender,controller,game);
        if (!choose) {
          choose=!game.getCombat().checkBlockRestrictionsAfter(defender,controller,game);
        }
      }
      game.fireEvent(GameEvent.getEvent(GameEvent.EventType.DECLARED_BLOCKERS,defenderId,defenderId));
      if (!game.isSimulation()) {
        game.getCombat().logBlockerInfo(defender,game);
      }
    }
  }
  TraceUtil.traceCombatIfNeeded(game,game.getCombat());
}",0.9583043780403058
158712,"@Override public boolean canActivate(UUID playerId,Game game){
  if (!controlsAbility(playerId,game) && !game.getContinuousEffects().asThough(getSourceId(),AsThoughEffectType.PLAY_FROM_NOT_OWN_HAND_ZONE,playerId,game)) {
    return false;
  }
  return game.getPlayer(playerId).canPlayLand();
}","@Override public boolean canActivate(UUID playerId,Game game){
  if (!controlsAbility(playerId,game) && !game.getContinuousEffects().asThough(getSourceId(),AsThoughEffectType.PLAY_FROM_NOT_OWN_HAND_ZONE,playerId,game)) {
    return false;
  }
  return game.getActivePlayerId().equals(playerId) && game.getPlayer(playerId).canPlayLand();
}",0.884310618066561
158713,"@Override public boolean playLand(Card card,Game game,boolean ignoreTiming){
  ActivatedAbility playLandAbility=null;
  boolean found=false;
  for (  Ability ability : card.getAbilities()) {
    if ((ability instanceof AlternativeSourceCosts) || (ability instanceof OptionalAdditionalSourceCosts)) {
      found=true;
    }
    if (ability instanceof PlayLandAbility) {
      playLandAbility=(ActivatedAbility)ability;
    }
  }
  if (found) {
    SpellAbility spellAbility=new SpellAbility(null,""String_Node_Str"",game.getState().getZone(card.getId()),SpellAbilityType.FACE_DOWN_CREATURE);
    spellAbility.setControllerId(this.getId());
    spellAbility.setSourceId(card.getId());
    if (cast(spellAbility,game,false)) {
      return true;
    }
  }
  if (playLandAbility == null) {
    return false;
  }
  if (!playLandAbility.canActivate(this.playerId,game)) {
    return false;
  }
  if (ignoreTiming) {
    if (!game.getActivePlayerId().equals(playerId)) {
      return false;
    }
  }
 else   if (!game.canPlaySorcery(playerId)) {
    return false;
  }
  if (!game.replaceEvent(GameEvent.getEvent(GameEvent.EventType.PLAY_LAND,card.getId(),card.getId(),playerId))) {
    if (moveCards(card,Zone.BATTLEFIELD,playLandAbility,game,false,false,false,null)) {
      landsPlayed++;
      game.fireEvent(GameEvent.getEvent(GameEvent.EventType.LAND_PLAYED,card.getId(),card.getId(),playerId));
      game.fireInformEvent(getLogName() + ""String_Node_Str"" + card.getLogName());
      resetStoredBookmark(game);
      return true;
    }
  }
  return true;
}","@Override public boolean playLand(Card card,Game game,boolean ignoreTiming){
  ActivatedAbility playLandAbility=null;
  boolean found=false;
  for (  Ability ability : card.getAbilities()) {
    if ((ability instanceof AlternativeSourceCosts) || (ability instanceof OptionalAdditionalSourceCosts)) {
      found=true;
    }
    if (ability instanceof PlayLandAbility) {
      playLandAbility=(ActivatedAbility)ability;
    }
  }
  if (found) {
    SpellAbility spellAbility=new SpellAbility(null,""String_Node_Str"",game.getState().getZone(card.getId()),SpellAbilityType.FACE_DOWN_CREATURE);
    spellAbility.setControllerId(this.getId());
    spellAbility.setSourceId(card.getId());
    if (cast(spellAbility,game,false)) {
      return true;
    }
  }
  if (playLandAbility == null) {
    return false;
  }
  if (!playLandAbility.canActivate(this.playerId,game)) {
    return false;
  }
  if (!ignoreTiming && !game.canPlaySorcery(playerId)) {
    return false;
  }
  if (!game.replaceEvent(GameEvent.getEvent(GameEvent.EventType.PLAY_LAND,card.getId(),card.getId(),playerId))) {
    if (moveCards(card,Zone.BATTLEFIELD,playLandAbility,game,false,false,false,null)) {
      landsPlayed++;
      game.fireEvent(GameEvent.getEvent(GameEvent.EventType.LAND_PLAYED,card.getId(),card.getId(),playerId));
      game.fireInformEvent(getLogName() + ""String_Node_Str"" + card.getLogName());
      resetStoredBookmark(game);
      return true;
    }
  }
  return true;
}",0.9651510122801196
158714,"@Override public boolean replaceEvent(GameEvent event,Ability source,Game game){
  Player player=game.getPlayer(source.getControllerId());
  MageObject sourceObject=game.getObject(source.getSourceId());
  if (player != null && cost != null && sourceObject != null) {
    boolean replace=true;
    if (cost.canPay(source,source.getSourceId(),player.getId(),game)) {
      if (player.chooseUse(outcome,cost.getText() + ""String_Node_Str"" + sourceObject.getLogName()+ ""String_Node_Str"",source,game)) {
        cost.clearPaid();
        replace=!cost.pay(source,game,source.getSourceId(),source.getControllerId(),false);
      }
    }
    if (replace) {
      Card card=game.getCard(event.getTargetId());
      if (card != null) {
        player.moveCards(card,game.getState().getZone(event.getTargetId()),Zone.GRAVEYARD,source,game);
      }
      return true;
    }
  }
  return false;
}","@Override public boolean replaceEvent(GameEvent event,Ability source,Game game){
  Player player=game.getPlayer(source.getControllerId());
  MageObject sourceObject=game.getObject(source.getSourceId());
  if (player != null && cost != null && sourceObject != null) {
    boolean replace=true;
    if (cost.canPay(source,source.getSourceId(),player.getId(),game)) {
      if (player.chooseUse(outcome,cost.getText() + ""String_Node_Str"" + sourceObject.getLogName()+ ""String_Node_Str"",source,game)) {
        cost.clearPaid();
        replace=!cost.pay(source,game,source.getSourceId(),source.getControllerId(),false);
      }
    }
    if (replace) {
      Card card=game.getCard(event.getTargetId());
      if (card != null) {
        player.moveCards(card,Zone.GRAVEYARD,source,game);
      }
      return true;
    }
  }
  return false;
}",0.9738827626233314
158715,"@Override public void resume(){
  playerList=state.getPlayerList(state.getActivePlayerId());
  Player player=getPlayer(playerList.get());
  boolean wasPaused=state.isPaused();
  state.resume();
  if (!gameOver(null)) {
    fireInformEvent(new StringBuilder(""String_Node_Str"").append(state.getTurnNum()).toString());
    if (checkStopOnTurnOption()) {
      return;
    }
    state.getTurn().resumePlay(this,wasPaused);
    if (!isPaused() && !gameOver(null)) {
      endOfTurn();
      player=playerList.getNext(this);
      state.setTurnNum(state.getTurnNum() + 1);
    }
  }
  play(player.getId());
}","@Override public void resume(){
  playerList=state.getPlayerList(state.getActivePlayerId());
  Player player=getPlayer(playerList.get());
  boolean wasPaused=state.isPaused();
  state.resume();
  if (!gameOver(null)) {
    fireInformEvent(""String_Node_Str"" + state.getTurnNum());
    if (checkStopOnTurnOption()) {
      return;
    }
    state.getTurn().resumePlay(this,wasPaused);
    if (!isPaused() && !gameOver(null)) {
      endOfTurn();
      player=playerList.getNext(this);
      state.setTurnNum(state.getTurnNum() + 1);
    }
  }
  play(player.getId());
}",0.964041095890411
158716,"@Override public boolean moveCards(Set<Card> cards,Zone toZone,Ability source,Game game,boolean tapped,boolean faceDown,boolean byOwner,ArrayList<UUID> appliedEffects){
  if (cards.isEmpty()) {
    return true;
  }
  Set<Card> successfulMovedCards=new LinkedHashSet<>();
  Zone fromZone=null;
switch (toZone) {
case GRAVEYARD:
    fromZone=game.getState().getZone(cards.iterator().next().getId());
  successfulMovedCards=moveCardsToGraveyardWithInfo(cards,source,game,fromZone);
return successfulMovedCards.size() > 0;
case BATTLEFIELD:
List<Permanent> permanents=new ArrayList<>();
List<Permanent> permanentsEntered=new ArrayList<>();
for (Card card : cards) {
UUID controllingPlayerId=byOwner ? card.getOwnerId() : getId();
fromZone=game.getState().getZone(card.getId());
if (faceDown) {
card.setFaceDown(true,game);
}
ZoneChangeEvent event=new ZoneChangeEvent(card.getId(),source.getSourceId(),controllingPlayerId,fromZone,Zone.BATTLEFIELD,appliedEffects,tapped);
if (!game.replaceEvent(event)) {
Permanent permanent=new PermanentCard(card,event.getPlayerId(),game);
permanents.add(permanent);
game.getPermanentsEntering().put(permanent.getId(),permanent);
card.checkForCountersToAdd(permanent,game);
permanent.setTapped(tapped);
permanent.setFaceDown(faceDown,game);
}
if (faceDown) {
card.setFaceDown(false,game);
}
}
game.setScopeRelevant(true);
for (Permanent permanent : permanents) {
fromZone=game.getState().getZone(permanent.getId());
game.getContinuousEffects().setController(permanent.getId(),permanent.getControllerId());
if (permanent.entersBattlefield(source.getSourceId(),game,fromZone,true)) {
permanentsEntered.add(permanent);
}
 else {
game.getContinuousEffects().setController(permanent.getId(),permanent.getOwnerId());
game.getPermanentsEntering().remove(permanent.getId());
}
}
game.setScopeRelevant(false);
for (Permanent permanent : permanentsEntered) {
fromZone=game.getState().getZone(permanent.getId());
if (((Card)permanent).removeFromZone(game,fromZone,source.getSourceId())) {
permanent.updateZoneChangeCounter(game);
game.addPermanent(permanent);
permanent.setZone(Zone.BATTLEFIELD,game);
game.getPermanentsEntering().remove(permanent.getId());
successfulMovedCards.add(permanent);
game.addSimultaneousEvent(new ZoneChangeEvent(permanent,permanent.getControllerId(),fromZone,Zone.BATTLEFIELD));
if (!game.isSimulation()) {
game.informPlayers(this.getLogName() + ""String_Node_Str"" + (faceDown ? ""String_Node_Str"" : permanent.getLogName())+ ""String_Node_Str""+ fromZone.toString().toLowerCase(Locale.ENGLISH)+ ""String_Node_Str"");
}
}
 else {
game.getPermanentsEntering().remove(permanent.getId());
}
}
game.applyEffects();
break;
case HAND:
for (Card card : cards) {
fromZone=game.getState().getZone(card.getId());
boolean hideCard=fromZone.equals(Zone.LIBRARY) || (card.isFaceDown(game) && !fromZone.equals(Zone.STACK) && !fromZone.equals(Zone.BATTLEFIELD));
if (moveCardToHandWithInfo(card,source == null ? null : source.getSourceId(),game,!hideCard)) {
successfulMovedCards.add(card);
}
}
break;
case EXILED:
for (Card card : cards) {
fromZone=game.getState().getZone(card.getId());
boolean withName=(fromZone.equals(Zone.BATTLEFIELD) || fromZone.equals(Zone.STACK)) || !card.isFaceDown(game);
if (moveCardToExileWithInfo(card,null,""String_Node_Str"",source == null ? null : source.getSourceId(),game,fromZone,withName)) {
successfulMovedCards.add(card);
}
}
break;
case LIBRARY:
for (Card card : cards) {
if (card instanceof Spell) {
fromZone=game.getState().getZone(((Spell)card).getSourceId());
}
 else {
fromZone=game.getState().getZone(card.getId());
}
boolean hideCard=fromZone.equals(Zone.HAND) || fromZone.equals(Zone.LIBRARY);
if (moveCardToLibraryWithInfo(card,source == null ? null : source.getSourceId(),game,fromZone,true,!hideCard)) {
successfulMovedCards.add(card);
}
}
break;
default :
throw new UnsupportedOperationException(""String_Node_Str"" + toZone.toString() + ""String_Node_Str"");
}
game.fireEvent(new ZoneChangeGroupEvent(successfulMovedCards,source == null ? null : source.getSourceId(),this.getId(),fromZone,toZone));
return successfulMovedCards.size() > 0;
}","@Override public boolean moveCards(Set<Card> cards,Zone toZone,Ability source,Game game,boolean tapped,boolean faceDown,boolean byOwner,ArrayList<UUID> appliedEffects){
  if (cards.isEmpty()) {
    return true;
  }
  Set<Card> successfulMovedCards=new LinkedHashSet<>();
  Zone fromZone=null;
switch (toZone) {
case GRAVEYARD:
    fromZone=game.getState().getZone(cards.iterator().next().getId());
  successfulMovedCards=moveCardsToGraveyardWithInfo(cards,source,game,fromZone);
return successfulMovedCards.size() > 0;
case BATTLEFIELD:
List<Permanent> permanents=new ArrayList<>();
List<Permanent> permanentsEntered=new ArrayList<>();
for (Card card : cards) {
UUID controllingPlayerId=byOwner ? card.getOwnerId() : getId();
fromZone=game.getState().getZone(card.getId());
if (faceDown) {
card.setFaceDown(true,game);
}
ZoneChangeEvent event=new ZoneChangeEvent(card.getId(),source.getSourceId(),controllingPlayerId,fromZone,Zone.BATTLEFIELD,appliedEffects,tapped);
if (!game.replaceEvent(event)) {
Permanent permanent=new PermanentCard(card,event.getPlayerId(),game);
permanents.add(permanent);
game.getPermanentsEntering().put(permanent.getId(),permanent);
card.checkForCountersToAdd(permanent,game);
permanent.setTapped(tapped);
permanent.setFaceDown(faceDown,game);
}
if (faceDown) {
card.setFaceDown(false,game);
}
}
game.setScopeRelevant(true);
for (Permanent permanent : permanents) {
fromZone=game.getState().getZone(permanent.getId());
game.getContinuousEffects().setController(permanent.getId(),permanent.getControllerId());
if (permanent.entersBattlefield(source.getSourceId(),game,fromZone,true)) {
permanentsEntered.add(permanent);
}
 else {
game.getContinuousEffects().setController(permanent.getId(),permanent.getOwnerId());
game.getPermanentsEntering().remove(permanent.getId());
}
}
game.setScopeRelevant(false);
for (Permanent permanent : permanentsEntered) {
fromZone=game.getState().getZone(permanent.getId());
if (((Card)permanent).removeFromZone(game,fromZone,source.getSourceId())) {
permanent.updateZoneChangeCounter(game);
game.addPermanent(permanent);
permanent.setZone(Zone.BATTLEFIELD,game);
game.getPermanentsEntering().remove(permanent.getId());
successfulMovedCards.add(permanent);
game.addSimultaneousEvent(new ZoneChangeEvent(permanent,permanent.getControllerId(),fromZone,Zone.BATTLEFIELD));
if (!game.isSimulation()) {
game.informPlayers(this.getLogName() + ""String_Node_Str"" + (faceDown ? ""String_Node_Str"" : permanent.getLogName())+ ""String_Node_Str""+ fromZone.toString().toLowerCase(Locale.ENGLISH)+ ""String_Node_Str"");
}
}
 else {
game.getPermanentsEntering().remove(permanent.getId());
}
}
game.applyEffects();
break;
case HAND:
for (Card card : cards) {
fromZone=game.getState().getZone(card.getId());
boolean hideCard=fromZone.equals(Zone.LIBRARY) || (card.isFaceDown(game) && !fromZone.equals(Zone.STACK) && !fromZone.equals(Zone.BATTLEFIELD));
if (moveCardToHandWithInfo(card,source == null ? null : source.getSourceId(),game,!hideCard)) {
successfulMovedCards.add(card);
}
}
break;
case EXILED:
for (Card card : cards) {
fromZone=game.getState().getZone(card.getId());
boolean withName=(fromZone.equals(Zone.BATTLEFIELD) || fromZone.equals(Zone.STACK)) || !card.isFaceDown(game);
if (moveCardToExileWithInfo(card,null,""String_Node_Str"",source == null ? null : source.getSourceId(),game,fromZone,withName)) {
successfulMovedCards.add(card);
}
}
break;
case LIBRARY:
for (Card card : cards) {
if (card instanceof Spell) {
fromZone=game.getState().getZone(((Spell)card).getSourceId());
}
 else {
fromZone=game.getState().getZone(card.getId());
}
boolean hideCard=fromZone.equals(Zone.HAND) || fromZone.equals(Zone.LIBRARY);
if (moveCardToLibraryWithInfo(card,source == null ? null : source.getSourceId(),game,fromZone,true,!hideCard)) {
successfulMovedCards.add(card);
}
}
break;
default :
throw new UnsupportedOperationException(""String_Node_Str"" + toZone.toString() + ""String_Node_Str"");
}
if (!successfulMovedCards.isEmpty()) {
game.fireEvent(new ZoneChangeGroupEvent(successfulMovedCards,source == null ? null : source.getSourceId(),this.getId(),fromZone,toZone));
}
return successfulMovedCards.size() > 0;
}",0.99504172209457
158717,"@Override public boolean playLand(Card card,Game game){
  ActivatedAbility playLandAbility=null;
  boolean found=false;
  for (  Ability ability : card.getAbilities()) {
    if ((ability instanceof AlternativeSourceCosts) || (ability instanceof OptionalAdditionalSourceCosts)) {
      found=true;
    }
    if (ability instanceof PlayLandAbility) {
      playLandAbility=(ActivatedAbility)ability;
    }
  }
  if (found) {
    SpellAbility spellAbility=new SpellAbility(null,""String_Node_Str"",game.getState().getZone(card.getId()),SpellAbilityType.FACE_DOWN_CREATURE);
    spellAbility.setControllerId(this.getId());
    spellAbility.setSourceId(card.getId());
    if (cast(spellAbility,game,false)) {
      return true;
    }
  }
  if (playLandAbility == null) {
    return false;
  }
  if (!playLandAbility.canActivate(this.playerId,game)) {
    return false;
  }
  if (!game.replaceEvent(GameEvent.getEvent(GameEvent.EventType.PLAY_LAND,card.getId(),card.getId(),playerId))) {
    if (moveCards(card,Zone.BATTLEFIELD,playLandAbility,game,false,false,false,null)) {
      landsPlayed++;
      game.fireEvent(GameEvent.getEvent(GameEvent.EventType.LAND_PLAYED,card.getId(),card.getId(),playerId));
      game.fireInformEvent(getLogName() + ""String_Node_Str"" + card.getLogName());
      resetStoredBookmark(game);
      return true;
    }
  }
  return false;
}","@Override public boolean playLand(Card card,Game game){
  ActivatedAbility playLandAbility=null;
  boolean found=false;
  for (  Ability ability : card.getAbilities()) {
    if ((ability instanceof AlternativeSourceCosts) || (ability instanceof OptionalAdditionalSourceCosts)) {
      found=true;
    }
    if (ability instanceof PlayLandAbility) {
      playLandAbility=(ActivatedAbility)ability;
    }
  }
  if (found) {
    SpellAbility spellAbility=new SpellAbility(null,""String_Node_Str"",game.getState().getZone(card.getId()),SpellAbilityType.FACE_DOWN_CREATURE);
    spellAbility.setControllerId(this.getId());
    spellAbility.setSourceId(card.getId());
    if (cast(spellAbility,game,false)) {
      return true;
    }
  }
  if (playLandAbility == null) {
    return false;
  }
  if (!playLandAbility.canActivate(this.playerId,game)) {
    return false;
  }
  if (!game.replaceEvent(GameEvent.getEvent(GameEvent.EventType.PLAY_LAND,card.getId(),card.getId(),playerId))) {
    if (moveCards(card,Zone.BATTLEFIELD,playLandAbility,game,false,false,false,null)) {
      landsPlayed++;
      game.fireEvent(GameEvent.getEvent(GameEvent.EventType.LAND_PLAYED,card.getId(),card.getId(),playerId));
      game.fireInformEvent(getLogName() + ""String_Node_Str"" + card.getLogName());
      resetStoredBookmark(game);
      return true;
    }
  }
  return true;
}",0.9974255240897388
158718,"private UUID getSourceControllerId(UUID sourceId,Game game){
  StackObject source=game.getStack().getStackObject(sourceId);
  if (source != null) {
    return source.getControllerId();
  }
  Permanent permanent=game.getBattlefield().getPermanent(sourceId);
  if (permanent != null) {
    return permanent.getControllerId();
  }
  return null;
}","private UUID getSourceControllerId(UUID sourceId,Game game){
  StackObject source=game.getStack().getStackObject(sourceId);
  if (source != null) {
    return source.getControllerId();
  }
  Permanent permanent=game.getBattlefield().getPermanent(sourceId);
  if (permanent != null) {
    return permanent.getControllerId();
  }
  return game.getContinuousEffects().getControllerOfSourceId(sourceId);
}",0.912751677852349
158719,"@Override public boolean checkTrigger(GameEvent event,Game game){
  if (((ZoneChangeEvent)event).isDiesEvent()) {
    ZoneChangeEvent zEvent=(ZoneChangeEvent)event;
    boolean triggered=false;
    if (zEvent.getTarget().getAttachments().contains(this.getSourceId())) {
      triggered=true;
    }
 else {
      Permanent attachment=game.getPermanentOrLKIBattlefield(getSourceId());
      if (attachment != null && zEvent.getTargetId() != null && attachment.getAttachedTo() != null && zEvent.getTargetId().equals(attachment.getAttachedTo()) && attachment.getAttachedToZoneChangeCounter() == zEvent.getTarget().getZoneChangeCounter(game) - 1) {
        triggered=true;
      }
    }
    if (triggered) {
      for (      Effect effect : getEffects()) {
        effect.setValue(""String_Node_Str"",zEvent.getTarget());
        if (setTargetPointer.equals(SetTargetPointer.ATTACHED_TO_CONTROLLER)) {
          Permanent attachment=game.getPermanentOrLKIBattlefield(getSourceId());
          if (attachment != null && attachment.getAttachedTo() != null) {
            Permanent attachedTo=(Permanent)game.getLastKnownInformation(attachment.getAttachedTo(),Zone.BATTLEFIELD,attachment.getAttachedToZoneChangeCounter());
            if (attachedTo != null) {
              effect.setTargetPointer(new FixedTarget(attachedTo.getControllerId()));
            }
          }
        }
      }
      return true;
    }
  }
  return false;
}","@Override public boolean checkTrigger(GameEvent event,Game game){
  if (((ZoneChangeEvent)event).isDiesEvent()) {
    ZoneChangeEvent zEvent=(ZoneChangeEvent)event;
    boolean triggered=false;
    if (zEvent.getTarget().getAttachments().contains(this.getSourceId())) {
      triggered=true;
    }
 else {
      Permanent attachment=game.getPermanentOrLKIBattlefield(getSourceId());
      if (attachment != null && zEvent.getTargetId() != null && attachment.getAttachedTo() != null && zEvent.getTargetId().equals(attachment.getAttachedTo())) {
        Permanent attachedTo=game.getPermanentOrLKIBattlefield(attachment.getAttachedTo());
        if (attachedTo != null && attachment.getAttachedToZoneChangeCounter() == attachedTo.getZoneChangeCounter(game)) {
          triggered=true;
        }
      }
    }
    if (triggered) {
      for (      Effect effect : getEffects()) {
        effect.setValue(""String_Node_Str"",zEvent.getTarget());
        if (setTargetPointer.equals(SetTargetPointer.ATTACHED_TO_CONTROLLER)) {
          Permanent attachment=game.getPermanentOrLKIBattlefield(getSourceId());
          if (attachment != null && attachment.getAttachedTo() != null) {
            Permanent attachedTo=(Permanent)game.getLastKnownInformation(attachment.getAttachedTo(),Zone.BATTLEFIELD,attachment.getAttachedToZoneChangeCounter());
            if (attachedTo != null) {
              effect.setTargetPointer(new FixedTarget(attachedTo.getControllerId()));
            }
          }
        }
      }
      return true;
    }
  }
  return false;
}",0.9429530201342282
158720,"@Override public boolean moveCards(Set<Card> cards,Zone toZone,Ability source,Game game,boolean tapped,boolean faceDown,boolean byOwner,ArrayList<UUID> appliedEffects){
  if (cards.isEmpty()) {
    return true;
  }
  Set<Card> successfulMovedCards=new LinkedHashSet<>();
  Zone fromZone=null;
switch (toZone) {
case GRAVEYARD:
    fromZone=game.getState().getZone(cards.iterator().next().getId());
  successfulMovedCards=moveCardsToGraveyardWithInfo(cards,source,game,fromZone);
break;
case BATTLEFIELD:
List<Permanent> permanents=new ArrayList<>();
List<Permanent> permanentsEntered=new ArrayList<>();
for (Card card : cards) {
UUID controllingPlayerId=byOwner ? card.getOwnerId() : getId();
fromZone=game.getState().getZone(card.getId());
if (faceDown) {
card.setFaceDown(true,game);
}
ZoneChangeEvent event=new ZoneChangeEvent(card.getId(),source.getSourceId(),controllingPlayerId,fromZone,Zone.BATTLEFIELD,appliedEffects,tapped);
if (!game.replaceEvent(event)) {
Permanent permanent=new PermanentCard(card,event.getPlayerId(),game);
permanents.add(permanent);
game.getPermanentsEntering().put(permanent.getId(),permanent);
card.checkForCountersToAdd(permanent,game);
permanent.setTapped(tapped);
permanent.setFaceDown(faceDown,game);
}
if (faceDown) {
card.setFaceDown(false,game);
}
}
game.setScopeRelevant(true);
for (Permanent permanent : permanents) {
fromZone=game.getState().getZone(permanent.getId());
game.getContinuousEffects().setController(permanent.getId(),permanent.getControllerId());
if (permanent.entersBattlefield(source.getSourceId(),game,fromZone,true)) {
permanentsEntered.add(permanent);
}
 else {
game.getContinuousEffects().setController(permanent.getId(),permanent.getOwnerId());
game.getPermanentsEntering().remove(permanent.getId());
}
}
game.setScopeRelevant(false);
for (Permanent permanent : permanentsEntered) {
fromZone=game.getState().getZone(permanent.getId());
if (((Card)permanent).removeFromZone(game,fromZone,source.getSourceId())) {
permanent.updateZoneChangeCounter(game);
game.addPermanent(permanent);
permanent.setZone(Zone.BATTLEFIELD,game);
game.getPermanentsEntering().remove(permanent.getId());
game.setScopeRelevant(true);
successfulMovedCards.add(permanent);
game.addSimultaneousEvent(new ZoneChangeEvent(permanent,permanent.getControllerId(),fromZone,Zone.BATTLEFIELD));
if (!game.isSimulation()) {
game.informPlayers(this.getLogName() + ""String_Node_Str"" + (faceDown ? ""String_Node_Str"" : permanent.getLogName())+ ""String_Node_Str""+ fromZone.toString().toLowerCase(Locale.ENGLISH)+ ""String_Node_Str"");
}
}
 else {
game.getPermanentsEntering().remove(permanent.getId());
}
}
game.applyEffects();
break;
case HAND:
for (Card card : cards) {
fromZone=game.getState().getZone(card.getId());
boolean hideCard=fromZone.equals(Zone.LIBRARY) || (card.isFaceDown(game) && !fromZone.equals(Zone.STACK) && !fromZone.equals(Zone.BATTLEFIELD));
if (moveCardToHandWithInfo(card,source == null ? null : source.getSourceId(),game,!hideCard)) {
successfulMovedCards.add(card);
}
}
break;
case EXILED:
for (Card card : cards) {
fromZone=game.getState().getZone(card.getId());
boolean withName=(fromZone.equals(Zone.BATTLEFIELD) || fromZone.equals(Zone.STACK)) || !card.isFaceDown(game);
if (moveCardToExileWithInfo(card,null,""String_Node_Str"",source == null ? null : source.getSourceId(),game,fromZone,withName)) {
successfulMovedCards.add(card);
}
}
break;
case LIBRARY:
for (Card card : cards) {
if (card instanceof Spell) {
fromZone=game.getState().getZone(((Spell)card).getSourceId());
}
 else {
fromZone=game.getState().getZone(card.getId());
}
boolean hideCard=fromZone.equals(Zone.HAND) || fromZone.equals(Zone.LIBRARY);
if (moveCardToLibraryWithInfo(card,source == null ? null : source.getSourceId(),game,fromZone,true,!hideCard)) {
successfulMovedCards.add(card);
}
}
break;
default :
throw new UnsupportedOperationException(""String_Node_Str"" + toZone.toString() + ""String_Node_Str"");
}
game.fireEvent(new ZoneChangeGroupEvent(successfulMovedCards,source == null ? null : source.getSourceId(),this.getId(),fromZone,toZone));
return successfulMovedCards.size() > 0;
}","@Override public boolean moveCards(Set<Card> cards,Zone toZone,Ability source,Game game,boolean tapped,boolean faceDown,boolean byOwner,ArrayList<UUID> appliedEffects){
  if (cards.isEmpty()) {
    return true;
  }
  Set<Card> successfulMovedCards=new LinkedHashSet<>();
  Zone fromZone=null;
switch (toZone) {
case GRAVEYARD:
    fromZone=game.getState().getZone(cards.iterator().next().getId());
  successfulMovedCards=moveCardsToGraveyardWithInfo(cards,source,game,fromZone);
break;
case BATTLEFIELD:
List<Permanent> permanents=new ArrayList<>();
List<Permanent> permanentsEntered=new ArrayList<>();
for (Card card : cards) {
UUID controllingPlayerId=byOwner ? card.getOwnerId() : getId();
fromZone=game.getState().getZone(card.getId());
if (faceDown) {
card.setFaceDown(true,game);
}
ZoneChangeEvent event=new ZoneChangeEvent(card.getId(),source.getSourceId(),controllingPlayerId,fromZone,Zone.BATTLEFIELD,appliedEffects,tapped);
if (!game.replaceEvent(event)) {
Permanent permanent=new PermanentCard(card,event.getPlayerId(),game);
permanents.add(permanent);
game.getPermanentsEntering().put(permanent.getId(),permanent);
card.checkForCountersToAdd(permanent,game);
permanent.setTapped(tapped);
permanent.setFaceDown(faceDown,game);
}
if (faceDown) {
card.setFaceDown(false,game);
}
}
game.setScopeRelevant(true);
for (Permanent permanent : permanents) {
fromZone=game.getState().getZone(permanent.getId());
game.getContinuousEffects().setController(permanent.getId(),permanent.getControllerId());
if (permanent.entersBattlefield(source.getSourceId(),game,fromZone,true)) {
permanentsEntered.add(permanent);
}
 else {
game.getContinuousEffects().setController(permanent.getId(),permanent.getOwnerId());
game.getPermanentsEntering().remove(permanent.getId());
}
}
game.setScopeRelevant(false);
for (Permanent permanent : permanentsEntered) {
fromZone=game.getState().getZone(permanent.getId());
if (((Card)permanent).removeFromZone(game,fromZone,source.getSourceId())) {
permanent.updateZoneChangeCounter(game);
game.addPermanent(permanent);
permanent.setZone(Zone.BATTLEFIELD,game);
game.getPermanentsEntering().remove(permanent.getId());
successfulMovedCards.add(permanent);
game.addSimultaneousEvent(new ZoneChangeEvent(permanent,permanent.getControllerId(),fromZone,Zone.BATTLEFIELD));
if (!game.isSimulation()) {
game.informPlayers(this.getLogName() + ""String_Node_Str"" + (faceDown ? ""String_Node_Str"" : permanent.getLogName())+ ""String_Node_Str""+ fromZone.toString().toLowerCase(Locale.ENGLISH)+ ""String_Node_Str"");
}
}
 else {
game.getPermanentsEntering().remove(permanent.getId());
}
}
game.applyEffects();
break;
case HAND:
for (Card card : cards) {
fromZone=game.getState().getZone(card.getId());
boolean hideCard=fromZone.equals(Zone.LIBRARY) || (card.isFaceDown(game) && !fromZone.equals(Zone.STACK) && !fromZone.equals(Zone.BATTLEFIELD));
if (moveCardToHandWithInfo(card,source == null ? null : source.getSourceId(),game,!hideCard)) {
successfulMovedCards.add(card);
}
}
break;
case EXILED:
for (Card card : cards) {
fromZone=game.getState().getZone(card.getId());
boolean withName=(fromZone.equals(Zone.BATTLEFIELD) || fromZone.equals(Zone.STACK)) || !card.isFaceDown(game);
if (moveCardToExileWithInfo(card,null,""String_Node_Str"",source == null ? null : source.getSourceId(),game,fromZone,withName)) {
successfulMovedCards.add(card);
}
}
break;
case LIBRARY:
for (Card card : cards) {
if (card instanceof Spell) {
fromZone=game.getState().getZone(((Spell)card).getSourceId());
}
 else {
fromZone=game.getState().getZone(card.getId());
}
boolean hideCard=fromZone.equals(Zone.HAND) || fromZone.equals(Zone.LIBRARY);
if (moveCardToLibraryWithInfo(card,source == null ? null : source.getSourceId(),game,fromZone,true,!hideCard)) {
successfulMovedCards.add(card);
}
}
break;
default :
throw new UnsupportedOperationException(""String_Node_Str"" + toZone.toString() + ""String_Node_Str"");
}
game.fireEvent(new ZoneChangeGroupEvent(successfulMovedCards,source == null ? null : source.getSourceId(),this.getId(),fromZone,toZone));
return successfulMovedCards.size() > 0;
}",0.9964595287510682
158721,"@Override public boolean canTarget(UUID id,Ability source,Game game){
  StackObject stackObject=game.getStack().getStackObject(id);
  if ((stackObject instanceof Spell) || (stackObject instanceof StackAbility)) {
    return true;
  }
  return false;
}","@Override public boolean canTarget(UUID id,Ability source,Game game){
  StackObject stackObject=game.getStack().getStackObject(id);
  return (stackObject instanceof Spell) || (stackObject instanceof StackAbility);
}",0.8927038626609443
158722,"public boolean counter(UUID objectId,UUID sourceId,Game game,Zone zone,boolean owner,boolean onTop){
  StackObject stackObject=getStackObject(objectId);
  MageObject sourceObject=game.getObject(sourceId);
  if (stackObject != null && sourceObject != null) {
    MageObject targetSourceObject=game.getObject(stackObject.getSourceId());
    String counteredObjectName, targetSourceName;
    if (targetSourceObject == null) {
      targetSourceName=""String_Node_Str"";
    }
 else {
      targetSourceName=game.getObject(stackObject.getSourceId()).getLogName();
    }
    if (stackObject instanceof Spell) {
      counteredObjectName=targetSourceName;
    }
 else {
      counteredObjectName=""String_Node_Str"" + stackObject.getStackAbility().getRule(targetSourceName) + ""String_Node_Str""+ targetSourceName;
    }
    if (!game.replaceEvent(GameEvent.getEvent(GameEvent.EventType.COUNTER,objectId,sourceId,stackObject.getControllerId()))) {
      stackObject.counter(sourceId,game,zone,owner,onTop);
      if (!game.isSimulation()) {
        game.informPlayers(counteredObjectName + ""String_Node_Str"" + sourceObject.getLogName());
      }
      game.fireEvent(GameEvent.getEvent(GameEvent.EventType.COUNTERED,objectId,sourceId,stackObject.getControllerId()));
    }
 else     if (!game.isSimulation()) {
      game.informPlayers(counteredObjectName + ""String_Node_Str"" + sourceObject.getLogName());
    }
    return true;
  }
  return false;
}","public boolean counter(UUID objectId,UUID sourceId,Game game,Zone zone,boolean owner,boolean onTop){
  StackObject stackObject=getStackObject(objectId);
  MageObject sourceObject=game.getObject(sourceId);
  if (stackObject != null && sourceObject != null) {
    MageObject targetSourceObject=game.getObject(stackObject.getSourceId());
    String counteredObjectName, targetSourceName;
    if (targetSourceObject == null) {
      targetSourceName=""String_Node_Str"";
    }
 else {
      targetSourceName=game.getObject(stackObject.getSourceId()).getLogName();
    }
    if (stackObject instanceof Spell) {
      counteredObjectName=targetSourceName;
    }
 else {
      counteredObjectName=""String_Node_Str"" + stackObject.getStackAbility().getRule(targetSourceName) + ""String_Node_Str""+ targetSourceName;
    }
    if (!game.replaceEvent(GameEvent.getEvent(GameEvent.EventType.COUNTER,objectId,sourceId,stackObject.getControllerId()))) {
      if (!(stackObject instanceof Spell)) {
        this.remove(stackObject);
      }
      stackObject.counter(sourceId,game,zone,owner,onTop);
      if (!game.isSimulation()) {
        game.informPlayers(counteredObjectName + ""String_Node_Str"" + sourceObject.getLogName());
      }
      game.fireEvent(GameEvent.getEvent(GameEvent.EventType.COUNTERED,objectId,sourceId,stackObject.getControllerId()));
    }
 else     if (!game.isSimulation()) {
      game.informPlayers(counteredObjectName + ""String_Node_Str"" + sourceObject.getLogName());
    }
    return true;
  }
  return false;
}",0.9706378670266622
158723,"@Override public boolean apply(Game game,Ability source){
  Card card=game.getCard(source.getFirstTarget());
  Permanent permanent=game.getPermanentEntering(source.getSourceId());
  if (permanent == null) {
    permanent=game.getPermanent(source.getSourceId());
  }
  if (permanent != null) {
    permanent.setName(card.getName());
    permanent.getColor(game).setColor(card.getColor(game));
    permanent.getManaCost().clear();
    permanent.getManaCost().add(card.getManaCost());
    permanent.getCardType().clear();
    for (    CardType type : card.getCardType()) {
      permanent.getCardType().add(type);
    }
    permanent.getSubtype().clear();
    for (    String type : card.getSubtype()) {
      permanent.getSubtype().add(type);
    }
    permanent.getSupertype().clear();
    for (    String type : card.getSupertype()) {
      permanent.getSupertype().add(type);
    }
    permanent.setExpansionSetCode(card.getExpansionSetCode());
    permanent.getAbilities().clear();
    for (    Ability ability : card.getAbilities()) {
      permanent.addAbility(ability,game);
    }
    return true;
  }
  return false;
}","@Override public Boolean apply(Game game,MageObject mageObject){
  mageObject.getPower().initValue(7);
  mageObject.getToughness().initValue(7);
  return true;
}",0.1634241245136186
158724,"@Override public QuicksilverGargantuanCopyEffect copy(){
  return new QuicksilverGargantuanCopyEffect(this);
}","@Override public QuicksilverGargantuan copy(){
  return new QuicksilverGargantuan(this);
}",0.9
158725,"@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller != null) {
    if (controller.getLibrary().size() > 0) {
      Card card=controller.getLibrary().removeFromBottom(game);
      if (card != null) {
        controller.moveCards(card,Zone.LIBRARY,Zone.GRAVEYARD,source,game);
        if (card.getCardType().contains(CardType.CREATURE)) {
          Permanent sourcePermanent=game.getPermanentOrLKIBattlefield(source.getSourceId());
          if (sourcePermanent != null && card.getPower().getValue() <= sourcePermanent.getPower().getValue()) {
            controller.moveCards(card,Zone.BATTLEFIELD,source,game);
          }
        }
      }
    }
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller != null) {
    if (controller.getLibrary().size() > 0) {
      Card card=controller.getLibrary().getFromBottom(game);
      if (card != null) {
        controller.moveCards(card,Zone.GRAVEYARD,source,game);
        if (card.getCardType().contains(CardType.CREATURE)) {
          Permanent sourcePermanent=game.getPermanentOrLKIBattlefield(source.getSourceId());
          if (sourcePermanent != null && card.getPower().getValue() <= sourcePermanent.getPower().getValue()) {
            controller.moveCards(card,Zone.BATTLEFIELD,source,game);
          }
        }
      }
    }
    return true;
  }
  return false;
}",0.9855643044619422
158726,"/** 
 * If the AI on a local server gets control of a Basalt Monolith it will infinite loop taping for three mana and then using the mana to untap lol. Seeing the computer durdle troll is quite the hillarious thing
 */
@Test public void testBasaltMonolith(){
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"",1);
  setStopAt(1,PhaseStep.END_TURN);
  execute();
  assertTapped(""String_Node_Str"",false);
}","/** 
 * If the AI on a local server gets control of a Basalt Monolith it will infinite loop taping for three mana and then using the mana to untap lol. Seeing the computer durdle troll is quite the hillarious thing
 */
@Test public void testBasaltMonolith(){
  addCard(Zone.HAND,playerA,""String_Node_Str"",1);
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"",3);
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"",1,true);
  setStopAt(5,PhaseStep.END_TURN);
  execute();
  assertPermanentCount(playerA,""String_Node_Str"",1);
  assertTapped(""String_Node_Str"",true);
  assertTappedCount(""String_Node_Str"",false,3);
}",0.75
158727,"@Override public void clearPaid(){
  super.clearPaid();
  this.cards.clear();
  this.targets.clear();
}","@Override public void clearPaid(){
  super.clearPaid();
  this.cards.clear();
  this.targets.clearChosen();
}",0.9716981132075472
158728,"public DiscardTargetCost(DiscardTargetCost cost){
  super(cost);
  for (  Card card : cost.cards) {
    this.cards.add(card.copy());
  }
  this.randomDiscard=cost.randomDiscard;
}","public DiscardTargetCost(DiscardTargetCost cost){
  super(cost);
  this.cards.addAll(cost.cards);
  this.randomDiscard=cost.randomDiscard;
}",0.8213166144200627
158729,"@Override public boolean pay(Ability ability,Game game,UUID sourceId,UUID controllerId,boolean noMana){
  this.cards.clear();
  this.targets.clearChosen();
  ;
  Player player=game.getPlayer(controllerId);
  if (player == null) {
    return false;
  }
  int amount=this.getTargets().get(0).getNumberOfTargets();
  if (randomDiscard) {
    this.cards.addAll(player.discard(amount,true,ability,game).getCards(game));
  }
 else {
    if (targets.choose(Outcome.Discard,controllerId,sourceId,game)) {
      for (      UUID targetId : targets.get(0).getTargets()) {
        Card card=player.getHand().get(targetId,game);
        if (card == null) {
          return false;
        }
        player.discard(card,ability,game);
        this.cards.add(card.copy());
      }
    }
  }
  paid=cards.size() >= amount;
  return paid;
}","@Override public boolean pay(Ability ability,Game game,UUID sourceId,UUID controllerId,boolean noMana){
  this.cards.clear();
  this.targets.clearChosen();
  ;
  Player player=game.getPlayer(controllerId);
  if (player == null) {
    return false;
  }
  int amount=this.getTargets().get(0).getNumberOfTargets();
  if (randomDiscard) {
    this.cards.addAll(player.discard(amount,true,ability,game).getCards(game));
  }
 else {
    if (targets.choose(Outcome.Discard,controllerId,sourceId,game)) {
      for (      UUID targetId : targets.get(0).getTargets()) {
        Card card=player.getHand().get(targetId,game);
        if (card == null) {
          return false;
        }
        player.discard(card,ability,game);
        this.cards.add(card);
      }
    }
  }
  paid=cards.size() >= amount;
  return paid;
}",0.9957291031116534
158730,"@Override public boolean apply(Game game,Ability source){
  Player player=game.getPlayer(source.getControllerId());
  Permanent permanent=game.getPermanentOrLKIBattlefield(source.getSourceId());
  MageObject sourceObject=source.getSourceObject(game);
  if (sourceObject != null && player != null && permanent != null) {
    StringBuilder sb=new StringBuilder(cost.getText()).append(""String_Node_Str"");
    if (!sb.toString().toLowerCase().startsWith(""String_Node_Str"") && !sb.toString().toLowerCase().startsWith(""String_Node_Str"")) {
      sb.insert(0,""String_Node_Str"");
    }
    String message=CardUtil.replaceSourceName(sb.toString(),sourceObject.getLogName());
    message=Character.toUpperCase(message.charAt(0)) + message.substring(1);
    if (player.chooseUse(Outcome.Benefit,message,source,game)) {
      cost.clearPaid();
      if (cost.pay(source,game,source.getSourceId(),source.getControllerId(),false)) {
        return true;
      }
    }
    permanent.sacrifice(source.getSourceId(),game);
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Player player=game.getPlayer(source.getControllerId());
  Permanent sourcePermanent=game.getPermanentOrLKIBattlefield(source.getSourceId());
  if (player != null && sourcePermanent != null) {
    StringBuilder sb=new StringBuilder(cost.getText()).append(""String_Node_Str"");
    if (!sb.toString().toLowerCase().startsWith(""String_Node_Str"") && !sb.toString().toLowerCase().startsWith(""String_Node_Str"")) {
      sb.insert(0,""String_Node_Str"");
    }
    String message=CardUtil.replaceSourceName(sb.toString(),sourcePermanent.getLogName());
    message=Character.toUpperCase(message.charAt(0)) + message.substring(1);
    if (player.chooseUse(Outcome.Benefit,message,source,game)) {
      cost.clearPaid();
      if (cost.pay(source,game,source.getSourceId(),source.getControllerId(),false)) {
        return true;
      }
    }
    sourcePermanent.sacrifice(source.getSourceId(),game);
    return true;
  }
  return false;
}",0.7254805322819122
158731,"@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller != null) {
    Map<UUID,Set<UUID>> exiledCards=new HashMap<>();
    for (    UUID playerId : game.getState().getPlayersInRange(controller.getId(),game)) {
      Player player=game.getPlayer(playerId);
      if (player != null) {
        Set cards=player.getGraveyard().getCards(new FilterArtifactCard(),game);
        controller.moveCards(cards,Zone.EXILED,source,game);
        exiledCards.put(player.getId(),cards);
      }
    }
    for (    UUID playerId : game.getState().getPlayersInRange(controller.getId(),game)) {
      Player player=game.getPlayer(playerId);
      if (player != null) {
        for (        Permanent permanent : game.getBattlefield().getAllActivePermanents(new FilterArtifactPermanent(),playerId,game)) {
          permanent.sacrifice(source.getSourceId(),game);
        }
      }
    }
    for (    UUID playerId : game.getState().getPlayersInRange(controller.getId(),game)) {
      Player player=game.getPlayer(playerId);
      if (player != null) {
        Cards playersExiledCards=new CardsImpl(exiledCards.get(playerId));
        controller.moveCards(playersExiledCards,Zone.BATTLEFIELD,source,game);
      }
    }
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller != null) {
    Map<UUID,Set<Card>> exiledCards=new HashMap<>();
    for (    UUID playerId : game.getState().getPlayersInRange(controller.getId(),game)) {
      Player player=game.getPlayer(playerId);
      if (player != null) {
        Set<Card> cards=player.getGraveyard().getCards(new FilterArtifactCard(),game);
        controller.moveCards(cards,Zone.EXILED,source,game);
        exiledCards.put(player.getId(),cards);
      }
    }
    for (    UUID playerId : game.getState().getPlayersInRange(controller.getId(),game)) {
      Player player=game.getPlayer(playerId);
      if (player != null) {
        for (        Permanent permanent : game.getBattlefield().getAllActivePermanents(new FilterArtifactPermanent(),playerId,game)) {
          permanent.sacrifice(source.getSourceId(),game);
        }
      }
    }
    for (    UUID playerId : game.getState().getPlayersInRange(controller.getId(),game)) {
      Player player=game.getPlayer(playerId);
      if (player != null) {
        controller.moveCards(exiledCards.get(playerId),Zone.BATTLEFIELD,source,game);
      }
    }
    return true;
  }
  return false;
}",0.9094427244582044
158732,"@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  Player targetPlayer=game.getPlayer(getTargetPointer().getFirst(game,source));
  if (controller != null && targetPlayer != null) {
    FilterLandCard filter=new FilterLandCard();
    filter.add(new OwnerIdPredicate(targetPlayer.getId()));
    Cards exiledCards=new CardsImpl();
    exiledCards.addAll(game.getExile().getAllCards(game));
    Cards exiledLands=new CardsImpl();
    exiledLands.addAll(exiledCards.getCards(filter,source.getSourceId(),controller.getId(),game));
    if (!exiledLands.isEmpty() && controller.chooseUse(outcome,""String_Node_Str"",source,game)) {
      FilterCard filterToPlay=new FilterCard(""String_Node_Str"" + (exiledLands.size() > 1 ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ targetPlayer.getName()+ ""String_Node_Str"");
      TargetCard targetCards=new TargetCard(0,exiledLands.size(),Zone.EXILED,filterToPlay);
      if (controller.chooseTarget(outcome,exiledLands,targetCards,source,game)) {
        controller.moveCards(new CardsImpl(targetCards.getTargets()),null,Zone.BATTLEFIELD,source,game);
      }
    }
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  Player targetPlayer=game.getPlayer(getTargetPointer().getFirst(game,source));
  if (controller != null && targetPlayer != null) {
    FilterLandCard filter=new FilterLandCard();
    filter.add(new OwnerIdPredicate(targetPlayer.getId()));
    Cards exiledCards=new CardsImpl();
    exiledCards.addAll(game.getExile().getAllCards(game));
    Cards exiledLands=new CardsImpl();
    exiledLands.addAll(exiledCards.getCards(filter,source.getSourceId(),controller.getId(),game));
    if (!exiledLands.isEmpty() && controller.chooseUse(outcome,""String_Node_Str"",source,game)) {
      FilterCard filterToPlay=new FilterCard(""String_Node_Str"" + (exiledLands.size() > 1 ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str""+ targetPlayer.getName()+ ""String_Node_Str"");
      TargetCard targetCards=new TargetCard(0,exiledLands.size(),Zone.EXILED,filterToPlay);
      if (controller.chooseTarget(outcome,exiledLands,targetCards,source,game)) {
        controller.moveCards(new CardsImpl(targetCards.getTargets()),Zone.BATTLEFIELD,source,game);
      }
    }
    return true;
  }
  return false;
}",0.9979449239621866
158733,"@Override public boolean chooseTarget(Outcome outcome,Cards cards,TargetCard target,Ability source,Game game){
  if (!targets.isEmpty()) {
    for (    String targetDefinition : targets) {
      String[] targetList=targetDefinition.split(""String_Node_Str"");
      boolean targetFound=false;
      for (      String targetName : targetList) {
        for (        Card card : cards.getCards(game)) {
          if (card.getName().equals(targetName)) {
            target.add(card.getId(),game);
            targetFound=true;
            break;
          }
        }
      }
      if (targetFound) {
        targets.remove(targetDefinition);
        return true;
      }
    }
  }
  return computerPlayer.chooseTarget(outcome,cards,target,source,game);
}","@Override public boolean chooseTarget(Outcome outcome,Cards cards,TargetCard target,Ability source,Game game){
  if (!targets.isEmpty()) {
    for (    String targetDefinition : targets) {
      String[] targetList=targetDefinition.split(""String_Node_Str"");
      boolean targetFound=false;
      for (      String targetName : targetList) {
        for (        Card card : cards.getCards(game)) {
          if (card.getName().equals(targetName) && !target.getTargets().contains(card.getId())) {
            target.add(card.getId(),game);
            targetFound=true;
            break;
          }
        }
      }
      if (targetFound) {
        targets.remove(targetDefinition);
        return true;
      }
    }
  }
  return computerPlayer.chooseTarget(outcome,cards,target,source,game);
}",0.9696578437701744
158734,"@Override public boolean moveCards(Set<Card> cards,Zone toZone,Ability source,Game game,boolean tapped,boolean faceDown,boolean byOwner,ArrayList<UUID> appliedEffects){
  if (cards.isEmpty()) {
    return true;
  }
  Set<Card> successfulMovedCards=new LinkedHashSet<>();
  Zone fromZone=null;
switch (toZone) {
case GRAVEYARD:
    fromZone=game.getState().getZone(cards.iterator().next().getId());
  successfulMovedCards=moveCardsToGraveyardWithInfo(cards,source,game,fromZone);
break;
case BATTLEFIELD:
List<Permanent> permanents=new ArrayList<>();
List<Permanent> permanentsEntered=new ArrayList<>();
for (Card card : cards) {
UUID controllingPlayerId=byOwner ? card.getOwnerId() : getId();
fromZone=game.getState().getZone(card.getId());
if (faceDown) {
card.setFaceDown(true,game);
}
ZoneChangeEvent event=new ZoneChangeEvent(card.getId(),source.getSourceId(),controllingPlayerId,fromZone,Zone.BATTLEFIELD,appliedEffects,tapped);
if (!game.replaceEvent(event)) {
Permanent permanent=new PermanentCard(card,event.getPlayerId(),game);
permanents.add(permanent);
game.getPermanentsEntering().put(permanent.getId(),permanent);
card.checkForCountersToAdd(permanent,game);
permanent.setTapped(tapped);
permanent.setFaceDown(faceDown,game);
}
if (faceDown) {
card.setFaceDown(false,game);
}
}
game.setScopeRelevant(true);
for (Permanent permanent : permanents) {
fromZone=game.getState().getZone(permanent.getId());
if (permanent.entersBattlefield(source.getSourceId(),game,fromZone,true)) {
permanentsEntered.add(permanent);
}
 else {
game.getPermanentsEntering().remove(permanent.getId());
}
}
game.setScopeRelevant(false);
for (Permanent permanent : permanentsEntered) {
fromZone=game.getState().getZone(permanent.getId());
if (((Card)permanent).removeFromZone(game,fromZone,source.getSourceId())) {
permanent.updateZoneChangeCounter(game);
game.getContinuousEffects().setController(permanent.getId(),permanent.getControllerId());
game.addPermanent(permanent);
permanent.setZone(Zone.BATTLEFIELD,game);
game.getPermanentsEntering().remove(permanent.getId());
game.setScopeRelevant(true);
successfulMovedCards.add(permanent);
game.addSimultaneousEvent(new ZoneChangeEvent(permanent,permanent.getControllerId(),fromZone,Zone.BATTLEFIELD));
if (!game.isSimulation()) {
game.informPlayers(this.getLogName() + ""String_Node_Str"" + (faceDown ? ""String_Node_Str"" : permanent.getLogName())+ ""String_Node_Str""+ fromZone.toString().toLowerCase(Locale.ENGLISH)+ ""String_Node_Str"");
}
}
 else {
game.getPermanentsEntering().remove(permanent.getId());
}
}
game.applyEffects();
break;
case HAND:
for (Card card : cards) {
fromZone=game.getState().getZone(card.getId());
boolean hideCard=fromZone.equals(Zone.LIBRARY) || (card.isFaceDown(game) && !fromZone.equals(Zone.STACK) && !fromZone.equals(Zone.BATTLEFIELD));
if (moveCardToHandWithInfo(card,source == null ? null : source.getSourceId(),game,!hideCard)) {
successfulMovedCards.add(card);
}
}
break;
case EXILED:
for (Card card : cards) {
fromZone=game.getState().getZone(card.getId());
boolean withName=(fromZone.equals(Zone.BATTLEFIELD) || fromZone.equals(Zone.STACK)) || !card.isFaceDown(game);
if (moveCardToExileWithInfo(card,null,""String_Node_Str"",source == null ? null : source.getSourceId(),game,fromZone,withName)) {
successfulMovedCards.add(card);
}
}
break;
case LIBRARY:
for (Card card : cards) {
if (card instanceof Spell) {
fromZone=game.getState().getZone(((Spell)card).getSourceId());
}
 else {
fromZone=game.getState().getZone(card.getId());
}
boolean hideCard=fromZone.equals(Zone.HAND) || fromZone.equals(Zone.LIBRARY);
if (moveCardToLibraryWithInfo(card,source == null ? null : source.getSourceId(),game,fromZone,true,!hideCard)) {
successfulMovedCards.add(card);
}
}
break;
default :
throw new UnsupportedOperationException(""String_Node_Str"" + toZone.toString() + ""String_Node_Str"");
}
game.fireEvent(new ZoneChangeGroupEvent(successfulMovedCards,source == null ? null : source.getSourceId(),this.getId(),fromZone,toZone));
return successfulMovedCards.size() > 0;
}","@Override public boolean moveCards(Set<Card> cards,Zone toZone,Ability source,Game game,boolean tapped,boolean faceDown,boolean byOwner,ArrayList<UUID> appliedEffects){
  if (cards.isEmpty()) {
    return true;
  }
  Set<Card> successfulMovedCards=new LinkedHashSet<>();
  Zone fromZone=null;
switch (toZone) {
case GRAVEYARD:
    fromZone=game.getState().getZone(cards.iterator().next().getId());
  successfulMovedCards=moveCardsToGraveyardWithInfo(cards,source,game,fromZone);
break;
case BATTLEFIELD:
List<Permanent> permanents=new ArrayList<>();
List<Permanent> permanentsEntered=new ArrayList<>();
for (Card card : cards) {
UUID controllingPlayerId=byOwner ? card.getOwnerId() : getId();
fromZone=game.getState().getZone(card.getId());
if (faceDown) {
card.setFaceDown(true,game);
}
ZoneChangeEvent event=new ZoneChangeEvent(card.getId(),source.getSourceId(),controllingPlayerId,fromZone,Zone.BATTLEFIELD,appliedEffects,tapped);
if (!game.replaceEvent(event)) {
Permanent permanent=new PermanentCard(card,event.getPlayerId(),game);
permanents.add(permanent);
game.getPermanentsEntering().put(permanent.getId(),permanent);
card.checkForCountersToAdd(permanent,game);
permanent.setTapped(tapped);
permanent.setFaceDown(faceDown,game);
}
if (faceDown) {
card.setFaceDown(false,game);
}
}
game.setScopeRelevant(true);
for (Permanent permanent : permanents) {
fromZone=game.getState().getZone(permanent.getId());
game.getContinuousEffects().setController(permanent.getId(),permanent.getControllerId());
if (permanent.entersBattlefield(source.getSourceId(),game,fromZone,true)) {
permanentsEntered.add(permanent);
}
 else {
game.getContinuousEffects().setController(permanent.getId(),permanent.getOwnerId());
game.getPermanentsEntering().remove(permanent.getId());
}
}
game.setScopeRelevant(false);
for (Permanent permanent : permanentsEntered) {
fromZone=game.getState().getZone(permanent.getId());
if (((Card)permanent).removeFromZone(game,fromZone,source.getSourceId())) {
permanent.updateZoneChangeCounter(game);
game.addPermanent(permanent);
permanent.setZone(Zone.BATTLEFIELD,game);
game.getPermanentsEntering().remove(permanent.getId());
game.setScopeRelevant(true);
successfulMovedCards.add(permanent);
game.addSimultaneousEvent(new ZoneChangeEvent(permanent,permanent.getControllerId(),fromZone,Zone.BATTLEFIELD));
if (!game.isSimulation()) {
game.informPlayers(this.getLogName() + ""String_Node_Str"" + (faceDown ? ""String_Node_Str"" : permanent.getLogName())+ ""String_Node_Str""+ fromZone.toString().toLowerCase(Locale.ENGLISH)+ ""String_Node_Str"");
}
}
 else {
game.getPermanentsEntering().remove(permanent.getId());
}
}
game.applyEffects();
break;
case HAND:
for (Card card : cards) {
fromZone=game.getState().getZone(card.getId());
boolean hideCard=fromZone.equals(Zone.LIBRARY) || (card.isFaceDown(game) && !fromZone.equals(Zone.STACK) && !fromZone.equals(Zone.BATTLEFIELD));
if (moveCardToHandWithInfo(card,source == null ? null : source.getSourceId(),game,!hideCard)) {
successfulMovedCards.add(card);
}
}
break;
case EXILED:
for (Card card : cards) {
fromZone=game.getState().getZone(card.getId());
boolean withName=(fromZone.equals(Zone.BATTLEFIELD) || fromZone.equals(Zone.STACK)) || !card.isFaceDown(game);
if (moveCardToExileWithInfo(card,null,""String_Node_Str"",source == null ? null : source.getSourceId(),game,fromZone,withName)) {
successfulMovedCards.add(card);
}
}
break;
case LIBRARY:
for (Card card : cards) {
if (card instanceof Spell) {
fromZone=game.getState().getZone(((Spell)card).getSourceId());
}
 else {
fromZone=game.getState().getZone(card.getId());
}
boolean hideCard=fromZone.equals(Zone.HAND) || fromZone.equals(Zone.LIBRARY);
if (moveCardToLibraryWithInfo(card,source == null ? null : source.getSourceId(),game,fromZone,true,!hideCard)) {
successfulMovedCards.add(card);
}
}
break;
default :
throw new UnsupportedOperationException(""String_Node_Str"" + toZone.toString() + ""String_Node_Str"");
}
game.fireEvent(new ZoneChangeGroupEvent(successfulMovedCards,source == null ? null : source.getSourceId(),this.getId(),fromZone,toZone));
return successfulMovedCards.size() > 0;
}",0.9674247080516288
158735,"@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  Permanent sourcePermanent=game.getPermanent(source.getSourceId());
  if (controller != null) {
    Choice choice=new ChoiceImpl(true);
    choice.setMessage(choiceMessage);
    choice.getChoices().addAll(modes);
    while (!choice.isChosen()) {
      if (!controller.canRespond()) {
        return false;
      }
      controller.choose(Outcome.Neutral,choice,game);
    }
    if (choice.isChosen()) {
      if (!game.isSimulation())       game.informPlayers(new StringBuilder(sourcePermanent.getLogName()).append(""String_Node_Str"").append(controller.getLogName()).append(""String_Node_Str"").append(choice.getChoice()).toString());
      game.getState().setValue(source.getSourceId() + ""String_Node_Str"",choice.getChoice());
      sourcePermanent.addInfo(""String_Node_Str"",""String_Node_Str"" + choice.getChoice() + ""String_Node_Str"",game);
    }
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  Permanent sourcePermanent=game.getPermanent(source.getSourceId());
  if (sourcePermanent == null) {
    sourcePermanent=game.getPermanentEntering(source.getSourceId());
  }
  if (controller != null) {
    Choice choice=new ChoiceImpl(true);
    choice.setMessage(choiceMessage);
    choice.getChoices().addAll(modes);
    while (!choice.isChosen()) {
      if (!controller.canRespond()) {
        return false;
      }
      controller.choose(Outcome.Neutral,choice,game);
    }
    if (choice.isChosen()) {
      if (!game.isSimulation()) {
        game.informPlayers(new StringBuilder(sourcePermanent.getLogName()).append(""String_Node_Str"").append(controller.getLogName()).append(""String_Node_Str"").append(choice.getChoice()).toString());
      }
      game.getState().setValue(source.getSourceId() + ""String_Node_Str"",choice.getChoice());
      sourcePermanent.addInfo(""String_Node_Str"",""String_Node_Str"" + choice.getChoice() + ""String_Node_Str"",game);
    }
    return true;
  }
  return false;
}",0.9444967074317968
158736,"protected void activateAbility(LinkedHashMap<UUID,? extends ActivatedAbility> abilities,MageObject object,Game game){
  updateGameStatePriority(""String_Node_Str"",game);
  if (abilities.size() == 1 && suppressAbilityPicker(abilities.values().iterator().next())) {
    ActivatedAbility ability=abilities.values().iterator().next();
    if (ability.getTargets().size() != 0 || !(ability.getCosts().size() == 1 && ability.getCosts().get(0) instanceof SacrificeSourceCost)) {
      activateAbility(ability,game);
      return;
    }
  }
  game.fireGetChoiceEvent(playerId,name,object,new ArrayList<>(abilities.values()));
  waitForResponse(game);
  if (response.getUUID() != null) {
    if (abilities.containsKey(response.getUUID())) {
      activateAbility(abilities.get(response.getUUID()),game);
    }
  }
}","protected void activateAbility(LinkedHashMap<UUID,? extends ActivatedAbility> abilities,MageObject object,Game game){
  updateGameStatePriority(""String_Node_Str"",game);
  if (abilities.size() == 1 && suppressAbilityPicker(abilities.values().iterator().next())) {
    ActivatedAbility ability=abilities.values().iterator().next();
    if (ability.getTargets().size() != 0 || !(ability.getCosts().size() == 1 && ability.getCosts().get(0) instanceof SacrificeSourceCost) || !(ability.getCosts().size() == 2 && ability.getCosts().get(0) instanceof TapSourceCost && ability.getCosts().get(0) instanceof SacrificeSourceCost)) {
      activateAbility(ability,game);
      return;
    }
  }
  game.fireGetChoiceEvent(playerId,name,object,new ArrayList<>(abilities.values()));
  waitForResponse(game);
  if (response.getUUID() != null) {
    if (abilities.containsKey(response.getUUID())) {
      activateAbility(abilities.get(response.getUUID()),game);
    }
  }
}",0.9142532651902328
158737,"@Override public LinkedHashMap<UUID,ActivatedAbility> getUseableActivatedAbilities(MageObject object,Zone zone,Game game){
  LinkedHashMap<UUID,ActivatedAbility> useable=new LinkedHashMap<>();
  boolean canUse=!(object instanceof Permanent) || ((Permanent)object).canUseActivatedAbilities(game);
  ManaOptions availableMana=null;
  for (  Ability ability : object.getAbilities()) {
    if (canUse || ability.getAbilityType().equals(AbilityType.SPECIAL_ACTION)) {
      if (ability.getZone().match(zone)) {
        if (ability instanceof ActivatedAbility) {
          if (canPlay(((ActivatedAbility)ability),availableMana,object,game)) {
            useable.put(ability.getId(),(ActivatedAbility)ability);
          }
        }
 else         if (ability instanceof AlternativeSourceCosts) {
          if (object.getCardType().contains(CardType.LAND)) {
            for (            Ability ability2 : object.getAbilities().copy()) {
              if (ability2 instanceof PlayLandAbility) {
                useable.put(ability2.getId(),(ActivatedAbility)ability2);
              }
            }
          }
        }
      }
    }
  }
  if (zone != Zone.HAND) {
    if (Zone.GRAVEYARD.equals(zone) && canPlayCardsFromGraveyard()) {
      for (      ActivatedAbility ability : object.getAbilities().getPlayableAbilities(Zone.HAND)) {
        if (canUse || ability.getAbilityType().equals(AbilityType.SPECIAL_ACTION)) {
          if (ability.canActivate(playerId,game)) {
            useable.put(ability.getId(),ability);
          }
        }
      }
    }
    if (zone != Zone.BATTLEFIELD && game.getContinuousEffects().asThough(object.getId(),AsThoughEffectType.PLAY_FROM_NOT_OWN_HAND_ZONE,this.getId(),game)) {
      for (      Ability ability : object.getAbilities()) {
        if (canUse || ability.getAbilityType().equals(AbilityType.SPECIAL_ACTION)) {
          ability.setControllerId(this.getId());
          if (ability instanceof ActivatedAbility && ability.getZone().match(Zone.HAND) && ((ActivatedAbility)ability).canActivate(playerId,game)) {
            useable.put(ability.getId(),(ActivatedAbility)ability);
          }
        }
      }
    }
  }
  getOtherUseableActivatedAbilities(object,zone,game,useable);
  return useable;
}","@Override public LinkedHashMap<UUID,ActivatedAbility> getUseableActivatedAbilities(MageObject object,Zone zone,Game game){
  LinkedHashMap<UUID,ActivatedAbility> useable=new LinkedHashMap<>();
  boolean canUse=!(object instanceof Permanent) || ((Permanent)object).canUseActivatedAbilities(game);
  ManaOptions availableMana=null;
  for (  Ability ability : object.getAbilities()) {
    if (canUse || ability.getAbilityType().equals(AbilityType.SPECIAL_ACTION)) {
      if (ability.getZone().match(zone)) {
        if (ability instanceof ActivatedAbility) {
          if (ability instanceof ManaAbility) {
            if (((ActivatedAbility)ability).canActivate(playerId,game)) {
              useable.put(ability.getId(),(ActivatedAbility)ability);
            }
          }
 else           if (canPlay(((ActivatedAbility)ability),availableMana,object,game)) {
            useable.put(ability.getId(),(ActivatedAbility)ability);
          }
        }
 else         if (ability instanceof AlternativeSourceCosts) {
          if (object.getCardType().contains(CardType.LAND)) {
            for (            Ability ability2 : object.getAbilities().copy()) {
              if (ability2 instanceof PlayLandAbility) {
                useable.put(ability2.getId(),(ActivatedAbility)ability2);
              }
            }
          }
        }
      }
    }
  }
  if (zone != Zone.HAND) {
    if (Zone.GRAVEYARD.equals(zone) && canPlayCardsFromGraveyard()) {
      for (      ActivatedAbility ability : object.getAbilities().getPlayableAbilities(Zone.HAND)) {
        if (canUse || ability.getAbilityType().equals(AbilityType.SPECIAL_ACTION)) {
          if (ability.canActivate(playerId,game)) {
            useable.put(ability.getId(),ability);
          }
        }
      }
    }
    if (zone != Zone.BATTLEFIELD && game.getContinuousEffects().asThough(object.getId(),AsThoughEffectType.PLAY_FROM_NOT_OWN_HAND_ZONE,this.getId(),game)) {
      for (      Ability ability : object.getAbilities()) {
        if (canUse || ability.getAbilityType().equals(AbilityType.SPECIAL_ACTION)) {
          ability.setControllerId(this.getId());
          if (ability instanceof ActivatedAbility && ability.getZone().match(Zone.HAND) && ((ActivatedAbility)ability).canActivate(playerId,game)) {
            useable.put(ability.getId(),(ActivatedAbility)ability);
          }
        }
      }
    }
  }
  getOtherUseableActivatedAbilities(object,zone,game,useable);
  return useable;
}",0.9524617996604414
158738,"@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  Permanent sourcePermanent=game.getPermanent(source.getSourceId());
  if (sourcePermanent == null) {
    sourcePermanent=game.getPermanentEntering(source.getSourceId());
  }
  if (controller != null) {
    Choice choice=new ChoiceImpl(true);
    choice.setMessage(choiceMessage);
    choice.getChoices().addAll(modes);
    while (!choice.isChosen()) {
      if (!controller.canRespond()) {
        return false;
      }
      controller.choose(Outcome.Neutral,choice,game);
    }
    if (choice.isChosen()) {
      if (!game.isSimulation()) {
        game.informPlayers(new StringBuilder(sourcePermanent.getLogName()).append(""String_Node_Str"").append(controller.getLogName()).append(""String_Node_Str"").append(choice.getChoice()).toString());
      }
      game.getState().setValue(source.getSourceId() + ""String_Node_Str"",choice.getChoice());
      sourcePermanent.addInfo(""String_Node_Str"",""String_Node_Str"" + choice.getChoice() + ""String_Node_Str"",game);
    }
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  Permanent sourcePermanent=game.getPermanent(source.getSourceId());
  if (sourcePermanent == null) {
    sourcePermanent=game.getPermanentEntering(source.getSourceId());
  }
  if (controller != null) {
    Choice choice=new ChoiceImpl(true);
    choice.setMessage(choiceMessage);
    choice.getChoices().addAll(modes);
    while (!choice.isChosen()) {
      if (!controller.canRespond()) {
        return false;
      }
      controller.choose(Outcome.Neutral,choice,game);
    }
    if (choice.isChosen()) {
      if (!game.isSimulation()) {
        game.informPlayers(sourcePermanent.getLogName() + ""String_Node_Str"" + controller.getLogName()+ ""String_Node_Str""+ choice.getChoice());
      }
      game.getState().setValue(source.getSourceId() + ""String_Node_Str"",choice.getChoice());
      sourcePermanent.addInfo(""String_Node_Str"",""String_Node_Str"" + choice.getChoice() + ""String_Node_Str"",game);
    }
    return true;
  }
  return false;
}",0.9652650822669104
158739,"/** 
 * Isochron Scepter Artifact, 2 (2) Imprint  When Isochron Scepter enters the battlefield, you may exile an  instant card with converted mana cost 2 or less from your hand. {2}, {T}: You may copy the exiled card. If you do, you may cast the copy  without paying its mana cost.
 */
@Test public void testImprint(){
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"",4);
  addCard(Zone.HAND,playerA,""String_Node_Str"");
  addCard(Zone.HAND,playerA,""String_Node_Str"");
  castSpell(1,PhaseStep.PRECOMBAT_MAIN,playerA,""String_Node_Str"");
  addTarget(playerA,""String_Node_Str"");
  setStopAt(1,PhaseStep.BEGIN_COMBAT);
  execute();
  assertPermanentCount(playerA,""String_Node_Str"",1);
  assertExileCount(""String_Node_Str"",1);
  assertLife(playerB,20);
}","/** 
 * Isochron Scepter Artifact, 2 (2) Imprint  When Isochron Scepter enters the battlefield, you may exile an instant card with converted mana cost 2 or less from your hand. {2}, {T}: You may copy the exiled card. If you do, you may cast the copy without paying its mana cost.
 */
@Test public void testImprint(){
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"",4);
  addCard(Zone.HAND,playerA,""String_Node_Str"");
  addCard(Zone.HAND,playerA,""String_Node_Str"");
  castSpell(1,PhaseStep.PRECOMBAT_MAIN,playerA,""String_Node_Str"");
  addTarget(playerA,""String_Node_Str"");
  setStopAt(1,PhaseStep.BEGIN_COMBAT);
  execute();
  assertPermanentCount(playerA,""String_Node_Str"",1);
  assertExileCount(""String_Node_Str"",1);
  assertLife(playerB,20);
}",0.9986702127659576
158740,"@Test public void testAngelsGrace(){
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"",4);
  addCard(Zone.HAND,playerA,""String_Node_Str"");
  addCard(Zone.HAND,playerA,""String_Node_Str"");
  addCard(Zone.BATTLEFIELD,playerB,""String_Node_Str"",4);
  castSpell(1,PhaseStep.PRECOMBAT_MAIN,playerA,""String_Node_Str"");
  addTarget(playerA,""String_Node_Str"");
  attack(2,playerB,""String_Node_Str"");
  attack(2,playerB,""String_Node_Str"");
  attack(2,playerB,""String_Node_Str"");
  attack(2,playerB,""String_Node_Str"");
  activateAbility(2,PhaseStep.DECLARE_BLOCKERS,playerA,""String_Node_Str"");
  setChoice(playerA,""String_Node_Str"");
  setChoice(playerA,""String_Node_Str"");
  setStopAt(2,PhaseStep.END_COMBAT);
  execute();
  assertPermanentCount(playerA,""String_Node_Str"",1);
  assertExileCount(""String_Node_Str"",1);
  assertGraveyardCount(playerA,""String_Node_Str"",0);
  assertLife(playerA,1);
  assertLife(playerB,20);
}","/** 
 * Not sure if it's triggered by just casting Angel's Grace or by casting it from an Isochron Scepter, but when the bug happens neither player is able to play spells or activate abilities anymore for the rest of the game. Maybe something related to Split Second?
 */
@Test public void testAngelsGrace(){
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"",4);
  addCard(Zone.HAND,playerA,""String_Node_Str"");
  addCard(Zone.HAND,playerA,""String_Node_Str"");
  addCard(Zone.BATTLEFIELD,playerB,""String_Node_Str"",4);
  addCard(Zone.HAND,playerB,""String_Node_Str"",2);
  addCard(Zone.BATTLEFIELD,playerB,""String_Node_Str"",2);
  castSpell(1,PhaseStep.PRECOMBAT_MAIN,playerA,""String_Node_Str"");
  addTarget(playerA,""String_Node_Str"");
  attack(2,playerB,""String_Node_Str"");
  attack(2,playerB,""String_Node_Str"");
  attack(2,playerB,""String_Node_Str"");
  attack(2,playerB,""String_Node_Str"");
  activateAbility(2,PhaseStep.DECLARE_BLOCKERS,playerA,""String_Node_Str"");
  setChoice(playerA,""String_Node_Str"");
  setChoice(playerA,""String_Node_Str"");
  castSpell(2,PhaseStep.POSTCOMBAT_MAIN,playerB,""String_Node_Str"",playerA);
  castSpell(3,PhaseStep.PRECOMBAT_MAIN,playerB,""String_Node_Str"",""String_Node_Str"");
  setStopAt(3,PhaseStep.BEGIN_COMBAT);
  execute();
  assertExileCount(""String_Node_Str"",1);
  assertGraveyardCount(playerA,""String_Node_Str"",0);
  assertLife(playerA,1);
  assertLife(playerB,20);
  assertGraveyardCount(playerB,""String_Node_Str"",2);
  assertGraveyardCount(playerB,""String_Node_Str"",1);
  assertPermanentCount(playerB,""String_Node_Str"",3);
  assertPermanentCount(playerA,""String_Node_Str"",1);
}",0.6706207987346777
158741,"/** 
 * Resolving a Silence cast from exile via Isochron Scepter during my opponent's upkeep does  not prevent that opponent from casting spells that turn.
 */
@Test public void testSilence(){
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"",4);
  addCard(Zone.HAND,playerA,""String_Node_Str"");
  addCard(Zone.HAND,playerA,""String_Node_Str"");
  addCard(Zone.BATTLEFIELD,playerB,""String_Node_Str"",2);
  addCard(Zone.HAND,playerB,""String_Node_Str"",1);
  castSpell(1,PhaseStep.PRECOMBAT_MAIN,playerA,""String_Node_Str"");
  addTarget(playerA,""String_Node_Str"");
  activateAbility(2,PhaseStep.UPKEEP,playerA,""String_Node_Str"");
  setChoice(playerA,""String_Node_Str"");
  setChoice(playerA,""String_Node_Str"");
  castSpell(2,PhaseStep.PRECOMBAT_MAIN,playerB,""String_Node_Str"");
  setStopAt(2,PhaseStep.BEGIN_COMBAT);
  execute();
  assertPermanentCount(playerA,""String_Node_Str"",1);
  assertExileCount(""String_Node_Str"",1);
  assertHandCount(playerB,""String_Node_Str"",1);
  assertPermanentCount(playerB,""String_Node_Str"",0);
}","/** 
 * Resolving a Silence cast from exile via Isochron Scepter during my opponent's upkeep does not prevent that opponent from casting spells that turn.
 */
@Test public void testSilence(){
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"",4);
  addCard(Zone.HAND,playerA,""String_Node_Str"");
  addCard(Zone.HAND,playerA,""String_Node_Str"");
  addCard(Zone.BATTLEFIELD,playerB,""String_Node_Str"",2);
  addCard(Zone.HAND,playerB,""String_Node_Str"",1);
  castSpell(1,PhaseStep.PRECOMBAT_MAIN,playerA,""String_Node_Str"");
  addTarget(playerA,""String_Node_Str"");
  activateAbility(2,PhaseStep.UPKEEP,playerA,""String_Node_Str"");
  setChoice(playerA,""String_Node_Str"");
  setChoice(playerA,""String_Node_Str"");
  castSpell(2,PhaseStep.PRECOMBAT_MAIN,playerB,""String_Node_Str"");
  setStopAt(2,PhaseStep.BEGIN_COMBAT);
  execute();
  assertPermanentCount(playerA,""String_Node_Str"",1);
  assertExileCount(""String_Node_Str"",1);
  assertHandCount(playerB,""String_Node_Str"",1);
  assertPermanentCount(playerB,""String_Node_Str"",0);
}",0.9995095635115252
158742,"@Override public boolean resolve(Game game){
  boolean result;
  Player controller=game.getPlayer(getControllerId());
  if (controller == null) {
    return false;
  }
  if (this.getCardType().contains(CardType.INSTANT) || this.getCardType().contains(CardType.SORCERY)) {
    int index=0;
    result=false;
    boolean legalParts=false;
    boolean notTargeted=true;
    for (    SpellAbility spellAbility : this.spellAbilities) {
      if (hasTargets(spellAbility,game)) {
        notTargeted=false;
        legalParts|=spellAbilityHasLegalParts(spellAbility,game);
      }
    }
    if (notTargeted || legalParts) {
      for (      SpellAbility spellAbility : this.spellAbilities) {
        if (spellAbilityHasLegalParts(spellAbility,game)) {
          for (          UUID modeId : spellAbility.getModes().getSelectedModes()) {
            spellAbility.getModes().setActiveMode(modeId);
            if (spellAbility.getTargets().stillLegal(spellAbility,game)) {
              if (!spellAbility.getSpellAbilityType().equals(SpellAbilityType.SPLICE)) {
                updateOptionalCosts(index);
              }
              result|=spellAbility.resolve(game);
            }
          }
          index++;
        }
      }
      if (game.getState().getZone(card.getMainCard().getId()) == Zone.STACK) {
        if (isCopy() == card.isCopy()) {
          Player player=game.getPlayer(getControllerId());
          if (player != null) {
            player.moveCards(card,Zone.STACK,Zone.GRAVEYARD,ability,game);
          }
        }
      }
      return result;
    }
    if (!game.isSimulation()) {
      game.informPlayers(getName() + ""String_Node_Str"");
    }
    counter(null,game);
    return false;
  }
 else   if (this.getCardType().contains(CardType.ENCHANTMENT) && this.getSubtype().contains(""String_Node_Str"")) {
    if (ability.getTargets().stillLegal(ability,game)) {
      updateOptionalCosts(0);
      boolean bestow=ability instanceof BestowAbility;
      if (bestow) {
        card.getCardType().remove(CardType.CREATURE);
        card.getSubtype().add(""String_Node_Str"");
      }
      if (controller.moveCards(card,Zone.BATTLEFIELD,ability,game,false,faceDown,false,null)) {
        if (bestow) {
          Permanent permanent=game.getPermanent(card.getId());
          if (permanent != null && permanent instanceof PermanentCard) {
            permanent.setSpellAbility(ability);
            ((PermanentCard)permanent).getCard().getCardType().add(CardType.CREATURE);
            ((PermanentCard)permanent).getCard().getSubtype().remove(""String_Node_Str"");
          }
        }
        return ability.resolve(game);
      }
      if (bestow) {
        card.getCardType().add(CardType.CREATURE);
      }
      return false;
    }
    if (this.getSpellAbility() instanceof BestowAbility) {
      updateOptionalCosts(0);
      return controller.moveCards(card,Zone.BATTLEFIELD,ability,game,false,faceDown,false,null);
    }
 else {
      if (!game.isSimulation()) {
        game.informPlayers(getName() + ""String_Node_Str"");
      }
      counter(null,game);
      return false;
    }
  }
 else {
    updateOptionalCosts(0);
    return controller.moveCards(card,Zone.BATTLEFIELD,ability,game,false,faceDown,false,null);
  }
}","@Override public boolean resolve(Game game){
  boolean result;
  Player controller=game.getPlayer(getControllerId());
  if (controller == null) {
    return false;
  }
  if (this.getCardType().contains(CardType.INSTANT) || this.getCardType().contains(CardType.SORCERY)) {
    int index=0;
    result=false;
    boolean legalParts=false;
    boolean notTargeted=true;
    for (    SpellAbility spellAbility : this.spellAbilities) {
      if (hasTargets(spellAbility,game)) {
        notTargeted=false;
        legalParts|=spellAbilityHasLegalParts(spellAbility,game);
      }
    }
    if (notTargeted || legalParts) {
      for (      SpellAbility spellAbility : this.spellAbilities) {
        if (spellAbilityHasLegalParts(spellAbility,game)) {
          for (          UUID modeId : spellAbility.getModes().getSelectedModes()) {
            spellAbility.getModes().setActiveMode(modeId);
            if (spellAbility.getTargets().stillLegal(spellAbility,game)) {
              if (!spellAbility.getSpellAbilityType().equals(SpellAbilityType.SPLICE)) {
                updateOptionalCosts(index);
              }
              result|=spellAbility.resolve(game);
            }
          }
          index++;
        }
      }
      if (game.getState().getZone(card.getMainCard().getId()) == Zone.STACK) {
        if (!isCopy()) {
          controller.moveCards(card,Zone.GRAVEYARD,ability,game);
        }
      }
      return result;
    }
    if (!game.isSimulation()) {
      game.informPlayers(getName() + ""String_Node_Str"");
    }
    counter(null,game);
    return false;
  }
 else   if (this.getCardType().contains(CardType.ENCHANTMENT) && this.getSubtype().contains(""String_Node_Str"")) {
    if (ability.getTargets().stillLegal(ability,game)) {
      updateOptionalCosts(0);
      boolean bestow=ability instanceof BestowAbility;
      if (bestow) {
        card.getCardType().remove(CardType.CREATURE);
        card.getSubtype().add(""String_Node_Str"");
      }
      if (controller.moveCards(card,Zone.BATTLEFIELD,ability,game,false,faceDown,false,null)) {
        if (bestow) {
          Permanent permanent=game.getPermanent(card.getId());
          if (permanent != null && permanent instanceof PermanentCard) {
            permanent.setSpellAbility(ability);
            ((PermanentCard)permanent).getCard().getCardType().add(CardType.CREATURE);
            ((PermanentCard)permanent).getCard().getSubtype().remove(""String_Node_Str"");
          }
        }
        return ability.resolve(game);
      }
      if (bestow) {
        card.getCardType().add(CardType.CREATURE);
      }
      return false;
    }
    if (this.getSpellAbility() instanceof BestowAbility) {
      updateOptionalCosts(0);
      return controller.moveCards(card,Zone.BATTLEFIELD,ability,game,false,faceDown,false,null);
    }
 else {
      if (!game.isSimulation()) {
        game.informPlayers(getName() + ""String_Node_Str"");
      }
      counter(null,game);
      return false;
    }
  }
 else {
    updateOptionalCosts(0);
    return controller.moveCards(card,Zone.BATTLEFIELD,ability,game,false,faceDown,false,null);
  }
}",0.9707455174583204
158743,"@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller != null) {
    Spell spell=game.getStack().getSpell(source.getSourceId());
    if (spell != null) {
      Card spellCard=spell.getCard();
      if (spellCard != null) {
        Player owner=game.getPlayer(spellCard.getOwnerId());
        if (owner != null) {
          controller.moveCardToLibraryWithInfo(spellCard,source.getSourceId(),game,Zone.STACK,true,true);
          owner.shuffleLibrary(game);
        }
      }
    }
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller != null) {
    Spell spell=game.getStack().getSpell(source.getId());
    if (spell != null) {
      if (controller.moveCards(spell,Zone.LIBRARY,source,game) && !spell.isCopy()) {
        Player owner=game.getPlayer(spell.getCard().getOwnerId());
        if (owner != null) {
          owner.shuffleLibrary(game);
        }
      }
    }
    return true;
  }
  return false;
}",0.5385996409335727
158744,"public Spell copySpell(){
  return new Spell(this.card.copy(),this.ability.copySpell(),this.controllerId,this.fromZone);
}","public Spell copySpell(){
  return new Spell(this.card,this.ability.copySpell(),this.controllerId,this.fromZone);
}",0.9704641350210972
158745,"@Override public boolean moveCards(Set<Card> cards,Zone toZone,Ability source,Game game,boolean tapped,boolean faceDown,boolean byOwner,ArrayList<UUID> appliedEffects){
  if (cards.isEmpty()) {
    return true;
  }
  Set<Card> successfulMovedCards=new LinkedHashSet<>();
  Zone fromZone=null;
switch (toZone) {
case GRAVEYARD:
    fromZone=game.getState().getZone(cards.iterator().next().getId());
  successfulMovedCards=moveCardsToGraveyardWithInfo(cards,source,game,fromZone);
break;
case BATTLEFIELD:
List<Permanent> permanents=new ArrayList<>();
List<Permanent> permanentsEntered=new ArrayList<>();
for (Card card : cards) {
UUID controllingPlayerId=byOwner ? card.getOwnerId() : getId();
fromZone=game.getState().getZone(card.getId());
if (faceDown) {
card.setFaceDown(true,game);
}
ZoneChangeEvent event=new ZoneChangeEvent(card.getId(),source.getSourceId(),controllingPlayerId,fromZone,Zone.BATTLEFIELD,appliedEffects,tapped);
if (!game.replaceEvent(event)) {
Permanent permanent=new PermanentCard(card,event.getPlayerId(),game);
permanents.add(permanent);
game.getPermanentsEntering().put(permanent.getId(),permanent);
card.checkForCountersToAdd(permanent,game);
permanent.setTapped(tapped);
permanent.setFaceDown(faceDown,game);
}
if (faceDown) {
card.setFaceDown(false,game);
}
}
game.setScopeRelevant(true);
for (Permanent permanent : permanents) {
fromZone=game.getState().getZone(permanent.getId());
if (permanent.entersBattlefield(source.getSourceId(),game,fromZone,true)) {
permanentsEntered.add(permanent);
}
 else {
game.getPermanentsEntering().remove(permanent.getId());
}
}
game.setScopeRelevant(false);
for (Permanent permanent : permanentsEntered) {
fromZone=game.getState().getZone(permanent.getId());
if (((Card)permanent).removeFromZone(game,fromZone,source.getSourceId())) {
permanent.updateZoneChangeCounter(game);
game.getContinuousEffects().setController(permanent.getId(),permanent.getControllerId());
game.addPermanent(permanent);
permanent.setZone(Zone.BATTLEFIELD,game);
game.getPermanentsEntering().remove(permanent.getId());
game.setScopeRelevant(true);
successfulMovedCards.add(permanent);
game.addSimultaneousEvent(new ZoneChangeEvent(permanent,permanent.getControllerId(),fromZone,Zone.BATTLEFIELD));
if (!game.isSimulation()) {
game.informPlayers(this.getLogName() + ""String_Node_Str"" + (faceDown ? ""String_Node_Str"" : permanent.getLogName())+ ""String_Node_Str""+ fromZone.toString().toLowerCase(Locale.ENGLISH)+ ""String_Node_Str"");
}
}
 else {
game.getPermanentsEntering().remove(permanent.getId());
}
}
game.applyEffects();
break;
case HAND:
for (Card card : cards) {
fromZone=game.getState().getZone(card.getId());
boolean hideCard=fromZone.equals(Zone.LIBRARY) || (card.isFaceDown(game) && !fromZone.equals(Zone.STACK) && !fromZone.equals(Zone.BATTLEFIELD));
if (moveCardToHandWithInfo(card,source == null ? null : source.getSourceId(),game,!hideCard)) {
successfulMovedCards.add(card);
}
}
break;
case EXILED:
for (Card card : cards) {
fromZone=game.getState().getZone(card.getId());
boolean withName=(fromZone.equals(Zone.BATTLEFIELD) || fromZone.equals(Zone.STACK)) || !card.isFaceDown(game);
if (moveCardToExileWithInfo(card,null,""String_Node_Str"",source == null ? null : source.getSourceId(),game,fromZone,withName)) {
successfulMovedCards.add(card);
}
}
break;
case LIBRARY:
for (Card card : cards) {
fromZone=game.getState().getZone(card.getId());
boolean hideCard=fromZone.equals(Zone.HAND) || fromZone.equals(Zone.LIBRARY);
if (moveCardToLibraryWithInfo(card,source == null ? null : source.getSourceId(),game,fromZone,true,!hideCard)) {
successfulMovedCards.add(card);
}
}
break;
default :
throw new UnsupportedOperationException(""String_Node_Str"" + toZone.toString() + ""String_Node_Str"");
}
game.fireEvent(new ZoneChangeGroupEvent(successfulMovedCards,source == null ? null : source.getSourceId(),this.getId(),fromZone,toZone));
return successfulMovedCards.size() > 0;
}","@Override public boolean moveCards(Set<Card> cards,Zone toZone,Ability source,Game game,boolean tapped,boolean faceDown,boolean byOwner,ArrayList<UUID> appliedEffects){
  if (cards.isEmpty()) {
    return true;
  }
  Set<Card> successfulMovedCards=new LinkedHashSet<>();
  Zone fromZone=null;
switch (toZone) {
case GRAVEYARD:
    fromZone=game.getState().getZone(cards.iterator().next().getId());
  successfulMovedCards=moveCardsToGraveyardWithInfo(cards,source,game,fromZone);
break;
case BATTLEFIELD:
List<Permanent> permanents=new ArrayList<>();
List<Permanent> permanentsEntered=new ArrayList<>();
for (Card card : cards) {
UUID controllingPlayerId=byOwner ? card.getOwnerId() : getId();
fromZone=game.getState().getZone(card.getId());
if (faceDown) {
card.setFaceDown(true,game);
}
ZoneChangeEvent event=new ZoneChangeEvent(card.getId(),source.getSourceId(),controllingPlayerId,fromZone,Zone.BATTLEFIELD,appliedEffects,tapped);
if (!game.replaceEvent(event)) {
Permanent permanent=new PermanentCard(card,event.getPlayerId(),game);
permanents.add(permanent);
game.getPermanentsEntering().put(permanent.getId(),permanent);
card.checkForCountersToAdd(permanent,game);
permanent.setTapped(tapped);
permanent.setFaceDown(faceDown,game);
}
if (faceDown) {
card.setFaceDown(false,game);
}
}
game.setScopeRelevant(true);
for (Permanent permanent : permanents) {
fromZone=game.getState().getZone(permanent.getId());
if (permanent.entersBattlefield(source.getSourceId(),game,fromZone,true)) {
permanentsEntered.add(permanent);
}
 else {
game.getPermanentsEntering().remove(permanent.getId());
}
}
game.setScopeRelevant(false);
for (Permanent permanent : permanentsEntered) {
fromZone=game.getState().getZone(permanent.getId());
if (((Card)permanent).removeFromZone(game,fromZone,source.getSourceId())) {
permanent.updateZoneChangeCounter(game);
game.getContinuousEffects().setController(permanent.getId(),permanent.getControllerId());
game.addPermanent(permanent);
permanent.setZone(Zone.BATTLEFIELD,game);
game.getPermanentsEntering().remove(permanent.getId());
game.setScopeRelevant(true);
successfulMovedCards.add(permanent);
game.addSimultaneousEvent(new ZoneChangeEvent(permanent,permanent.getControllerId(),fromZone,Zone.BATTLEFIELD));
if (!game.isSimulation()) {
game.informPlayers(this.getLogName() + ""String_Node_Str"" + (faceDown ? ""String_Node_Str"" : permanent.getLogName())+ ""String_Node_Str""+ fromZone.toString().toLowerCase(Locale.ENGLISH)+ ""String_Node_Str"");
}
}
 else {
game.getPermanentsEntering().remove(permanent.getId());
}
}
game.applyEffects();
break;
case HAND:
for (Card card : cards) {
fromZone=game.getState().getZone(card.getId());
boolean hideCard=fromZone.equals(Zone.LIBRARY) || (card.isFaceDown(game) && !fromZone.equals(Zone.STACK) && !fromZone.equals(Zone.BATTLEFIELD));
if (moveCardToHandWithInfo(card,source == null ? null : source.getSourceId(),game,!hideCard)) {
successfulMovedCards.add(card);
}
}
break;
case EXILED:
for (Card card : cards) {
fromZone=game.getState().getZone(card.getId());
boolean withName=(fromZone.equals(Zone.BATTLEFIELD) || fromZone.equals(Zone.STACK)) || !card.isFaceDown(game);
if (moveCardToExileWithInfo(card,null,""String_Node_Str"",source == null ? null : source.getSourceId(),game,fromZone,withName)) {
successfulMovedCards.add(card);
}
}
break;
case LIBRARY:
for (Card card : cards) {
if (card instanceof Spell) {
fromZone=game.getState().getZone(((Spell)card).getSourceId());
}
 else {
fromZone=game.getState().getZone(card.getId());
}
boolean hideCard=fromZone.equals(Zone.HAND) || fromZone.equals(Zone.LIBRARY);
if (moveCardToLibraryWithInfo(card,source == null ? null : source.getSourceId(),game,fromZone,true,!hideCard)) {
successfulMovedCards.add(card);
}
}
break;
default :
throw new UnsupportedOperationException(""String_Node_Str"" + toZone.toString() + ""String_Node_Str"");
}
game.fireEvent(new ZoneChangeGroupEvent(successfulMovedCards,source == null ? null : source.getSourceId(),this.getId(),fromZone,toZone));
return successfulMovedCards.size() > 0;
}",0.9833878681097408
158746,"@Override public boolean apply(Game game,Ability source){
  Spell spell=game.getStack().getSpell(source.getSourceId());
  if (spell != null) {
    SacrificeTargetCost cost=new SacrificeTargetCost(new TargetControlledCreaturePermanent());
    for (    UUID playerId : game.getState().getPlayerList(source.getControllerId())) {
      cost.clearPaid();
      Player player=game.getPlayer(playerId);
      if (cost.canPay(source,source.getSourceId(),player.getId(),game) && player.chooseUse(outcome,""String_Node_Str"" + spell.getIdName() + ""String_Node_Str"",source,game)) {
        if (cost.pay(source,game,source.getSourceId(),player.getId(),false)) {
          game.informPlayers(player.getLogName() + ""String_Node_Str"" + spell.getIdName()+ ""String_Node_Str"");
          game.getStack().counter(spell.getId(),source.getSourceId(),game);
        }
      }
    }
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  MageObject sourceObject=source.getSourceObject(game);
  if (sourceObject != null) {
    SacrificeTargetCost cost=new SacrificeTargetCost(new TargetControlledCreaturePermanent());
    for (    UUID playerId : game.getState().getPlayerList(source.getControllerId())) {
      cost.clearPaid();
      Player player=game.getPlayer(playerId);
      if (cost.canPay(source,source.getSourceId(),player.getId(),game) && player.chooseUse(outcome,""String_Node_Str"" + sourceObject.getIdName() + ""String_Node_Str"",source,game)) {
        if (cost.pay(source,game,source.getSourceId(),player.getId(),false)) {
          game.informPlayers(player.getLogName() + ""String_Node_Str"" + sourceObject.getIdName()+ ""String_Node_Str"");
          Spell spell=game.getStack().getSpell(source.getSourceId());
          if (spell != null) {
            game.getStack().counter(spell.getId(),source.getSourceId(),game);
          }
        }
      }
    }
    return true;
  }
  return false;
}",0.8126951092611863
158747,"@Override public boolean apply(Game game,Ability source){
  Spell spell=game.getStack().getSpell(source.getSourceId());
  if (spell != null) {
    PayLifeCost cost=new PayLifeCost(5);
    for (    UUID playerId : game.getState().getPlayerList(source.getControllerId())) {
      Player player=game.getPlayer(playerId);
      cost.clearPaid();
      if (cost.canPay(source,source.getSourceId(),player.getId(),game) && player.chooseUse(outcome,""String_Node_Str"" + spell.getIdName() + ""String_Node_Str"",source,game)) {
        if (cost.pay(source,game,source.getSourceId(),player.getId(),false)) {
          game.informPlayers(player.getLogName() + ""String_Node_Str"" + spell.getIdName()+ ""String_Node_Str"");
          game.getStack().counter(spell.getId(),source.getSourceId(),game);
        }
      }
    }
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  MageObject sourceObject=source.getSourceObject(game);
  if (sourceObject != null) {
    PayLifeCost cost=new PayLifeCost(5);
    for (    UUID playerId : game.getState().getPlayerList(source.getControllerId())) {
      Player player=game.getPlayer(playerId);
      cost.clearPaid();
      if (cost.canPay(source,source.getSourceId(),player.getId(),game) && player.chooseUse(outcome,""String_Node_Str"" + sourceObject.getIdName() + ""String_Node_Str"",source,game)) {
        if (cost.pay(source,game,source.getSourceId(),player.getId(),false)) {
          game.informPlayers(player.getLogName() + ""String_Node_Str"" + sourceObject.getIdName()+ ""String_Node_Str"");
          Spell spell=game.getStack().getSpell(source.getSourceId());
          if (spell != null) {
            game.getStack().counter(spell.getId(),source.getSourceId(),game);
          }
        }
      }
    }
    return true;
  }
  return false;
}",0.8015435501653804
158748,"@Override public boolean apply(Game game,Ability source){
  StackObject spell=null;
  for (  StackObject objet : game.getStack()) {
    if (objet instanceof Spell && objet.getSourceId().equals(source.getSourceId())) {
      spell=objet;
    }
  }
  if (spell != null) {
    DiscardTargetCost cost=new DiscardTargetCost(new TargetCardInHand(3,3,new FilterCard()));
    for (    UUID uuid : game.getPlayerList()) {
      Player player=game.getPlayer(uuid);
      cost.clearPaid();
      if (cost.canPay(source,source.getSourceId(),player.getId(),game) && player.chooseUse(Outcome.Detriment,""String_Node_Str"" + spell.getName() + ""String_Node_Str"",source,game)) {
        if (cost.pay(source,game,source.getSourceId(),uuid,false)) {
          game.informPlayers(player.getLogName() + ""String_Node_Str"" + spell.getName()+ ""String_Node_Str"");
          game.getStack().counter(spell.getId(),source.getSourceId(),game);
          return true;
        }
      }
    }
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  MageObject sourceObject=source.getSourceObject(game);
  if (sourceObject != null) {
    DiscardTargetCost cost=new DiscardTargetCost(new TargetCardInHand(3,3,new FilterCard()));
    for (    UUID playerId : game.getState().getPlayerList(source.getControllerId())) {
      Player player=game.getPlayer(playerId);
      cost.clearPaid();
      if (cost.canPay(source,source.getSourceId(),player.getId(),game) && player.chooseUse(outcome,""String_Node_Str"" + sourceObject.getIdName() + ""String_Node_Str"",source,game)) {
        if (cost.pay(source,game,source.getSourceId(),playerId,false)) {
          game.informPlayers(player.getLogName() + ""String_Node_Str"" + sourceObject.getIdName()+ ""String_Node_Str"");
          Spell spell=game.getStack().getSpell(source.getSourceId());
          if (spell != null) {
            game.getStack().counter(spell.getId(),source.getSourceId(),game);
          }
        }
      }
    }
    return true;
  }
  return false;
}",0.150718889439762
158749,"@Override public boolean apply(Game game,Ability source){
  Spell spell=game.getStack().getSpell(source.getSourceId());
  if (spell != null) {
    for (    UUID playerId : game.getState().getPlayerList(source.getControllerId())) {
      Player player=game.getPlayer(playerId);
      if (player.chooseUse(outcome,""String_Node_Str"" + spell.getIdName() + ""String_Node_Str"",source,game)) {
        Integer amount=(int)Math.ceil(player.getLife() / 2f);
        player.loseLife(amount,game);
        game.informPlayers(player.getLogName() + ""String_Node_Str"" + spell.getIdName()+ ""String_Node_Str"");
        game.getStack().counter(spell.getId(),source.getSourceId(),game);
      }
    }
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  MageObject sourceObject=source.getSourceObject(game);
  if (sourceObject != null) {
    for (    UUID playerId : game.getState().getPlayerList(source.getControllerId())) {
      Player player=game.getPlayer(playerId);
      if (player.chooseUse(outcome,""String_Node_Str"" + sourceObject.getIdName() + ""String_Node_Str"",source,game)) {
        Integer amount=(int)Math.ceil(player.getLife() / 2f);
        player.loseLife(amount,game);
        game.informPlayers(player.getLogName() + ""String_Node_Str"" + sourceObject.getIdName()+ ""String_Node_Str"");
        Spell spell=game.getStack().getSpell(source.getSourceId());
        if (spell != null) {
          game.getStack().counter(spell.getId(),source.getSourceId(),game);
        }
      }
    }
    return true;
  }
  return false;
}",0.8337595907928389
158750,"@Override public void clearPaid(){
  super.clearPaid();
  cards.clear();
}","@Override public void clearPaid(){
  super.clearPaid();
  this.cards.clear();
  this.targets.clear();
}",0.8361581920903954
158751,"@Override public boolean pay(Ability ability,Game game,UUID sourceId,UUID controllerId,boolean noMana){
  this.cards.clear();
  Player player=game.getPlayer(controllerId);
  if (player == null) {
    return false;
  }
  int amount=this.getTargets().get(0).getNumberOfTargets();
  if (randomDiscard) {
    this.cards.addAll(player.discard(amount,true,ability,game).getCards(game));
  }
 else {
    if (targets.choose(Outcome.Discard,controllerId,sourceId,game)) {
      for (      UUID targetId : targets.get(0).getTargets()) {
        Card card=player.getHand().get(targetId,game);
        if (card == null) {
          return false;
        }
        player.discard(card,ability,game);
        this.cards.add(card.copy());
      }
    }
  }
  paid=cards.size() >= amount;
  return paid;
}","@Override public boolean pay(Ability ability,Game game,UUID sourceId,UUID controllerId,boolean noMana){
  this.cards.clear();
  this.targets.clear();
  Player player=game.getPlayer(controllerId);
  if (player == null) {
    return false;
  }
  int amount=this.getTargets().get(0).getNumberOfTargets();
  if (randomDiscard) {
    this.cards.addAll(player.discard(amount,true,ability,game).getCards(game));
  }
 else {
    if (targets.choose(Outcome.Discard,controllerId,sourceId,game)) {
      for (      UUID targetId : targets.get(0).getTargets()) {
        Card card=player.getHand().get(targetId,game);
        if (card == null) {
          return false;
        }
        player.discard(card,ability,game);
        this.cards.add(card.copy());
      }
    }
  }
  paid=cards.size() >= amount;
  return paid;
}",0.9850187265917604
158752,"@Override public boolean apply(Game game,Ability source){
  Spell spell=game.getStack().getSpell(source.getSourceId());
  if (spell != null) {
    SacrificeTargetCost cost=new SacrificeTargetCost(new TargetControlledCreaturePermanent());
    for (    UUID playerId : game.getState().getPlayerList(source.getControllerId())) {
      cost.clearPaid();
      Player player=game.getPlayer(playerId);
      if (cost.canPay(source,source.getSourceId(),player.getId(),game) && player.chooseUse(outcome,""String_Node_Str"" + spell.getIdName() + ""String_Node_Str"",source,game)) {
        if (cost.pay(source,game,source.getSourceId(),player.getId(),false)) {
          game.informPlayers(player.getLogName() + ""String_Node_Str"" + spell.getIdName()+ ""String_Node_Str"");
          game.getStack().counter(spell.getId(),source.getSourceId(),game);
        }
      }
    }
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  MageObject sourceObject=source.getSourceObject(game);
  if (sourceObject != null) {
    SacrificeTargetCost cost=new SacrificeTargetCost(new TargetControlledCreaturePermanent());
    for (    UUID playerId : game.getState().getPlayerList(source.getControllerId())) {
      cost.clearPaid();
      Player player=game.getPlayer(playerId);
      if (cost.canPay(source,source.getSourceId(),player.getId(),game) && player.chooseUse(outcome,""String_Node_Str"" + sourceObject.getIdName() + ""String_Node_Str"",source,game)) {
        if (cost.pay(source,game,source.getSourceId(),player.getId(),false)) {
          game.informPlayers(player.getLogName() + ""String_Node_Str"" + sourceObject.getIdName()+ ""String_Node_Str"");
          Spell spell=game.getStack().getSpell(source.getSourceId());
          if (spell != null) {
            game.getStack().counter(spell.getId(),source.getSourceId(),game);
          }
        }
      }
    }
    return true;
  }
  return false;
}",0.8126951092611863
158753,"@Override public boolean apply(Game game,Ability source){
  Spell spell=game.getStack().getSpell(source.getSourceId());
  if (spell != null) {
    PayLifeCost cost=new PayLifeCost(5);
    for (    UUID playerId : game.getState().getPlayerList(source.getControllerId())) {
      Player player=game.getPlayer(playerId);
      cost.clearPaid();
      if (cost.canPay(source,source.getSourceId(),player.getId(),game) && player.chooseUse(outcome,""String_Node_Str"" + spell.getIdName() + ""String_Node_Str"",source,game)) {
        if (cost.pay(source,game,source.getSourceId(),player.getId(),false)) {
          game.informPlayers(player.getLogName() + ""String_Node_Str"" + spell.getIdName()+ ""String_Node_Str"");
          game.getStack().counter(spell.getId(),source.getSourceId(),game);
        }
      }
    }
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  MageObject sourceObject=source.getSourceObject(game);
  if (sourceObject != null) {
    PayLifeCost cost=new PayLifeCost(5);
    for (    UUID playerId : game.getState().getPlayerList(source.getControllerId())) {
      Player player=game.getPlayer(playerId);
      cost.clearPaid();
      if (cost.canPay(source,source.getSourceId(),player.getId(),game) && player.chooseUse(outcome,""String_Node_Str"" + sourceObject.getIdName() + ""String_Node_Str"",source,game)) {
        if (cost.pay(source,game,source.getSourceId(),player.getId(),false)) {
          game.informPlayers(player.getLogName() + ""String_Node_Str"" + sourceObject.getIdName()+ ""String_Node_Str"");
          Spell spell=game.getStack().getSpell(source.getSourceId());
          if (spell != null) {
            game.getStack().counter(spell.getId(),source.getSourceId(),game);
          }
        }
      }
    }
    return true;
  }
  return false;
}",0.8015435501653804
158754,"@Override public boolean apply(Game game,Ability source){
  StackObject spell=null;
  for (  StackObject objet : game.getStack()) {
    if (objet instanceof Spell && objet.getSourceId().equals(source.getSourceId())) {
      spell=objet;
    }
  }
  if (spell != null) {
    DiscardTargetCost cost=new DiscardTargetCost(new TargetCardInHand(3,3,new FilterCard()));
    for (    UUID uuid : game.getPlayerList()) {
      Player player=game.getPlayer(uuid);
      cost.clearPaid();
      if (cost.canPay(source,source.getSourceId(),player.getId(),game) && player.chooseUse(Outcome.Detriment,""String_Node_Str"" + spell.getName() + ""String_Node_Str"",source,game)) {
        if (cost.pay(source,game,source.getSourceId(),uuid,false)) {
          game.informPlayers(player.getLogName() + ""String_Node_Str"" + spell.getName()+ ""String_Node_Str"");
          game.getStack().counter(spell.getId(),source.getSourceId(),game);
          return true;
        }
      }
    }
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  MageObject sourceObject=source.getSourceObject(game);
  if (sourceObject != null) {
    DiscardTargetCost cost=new DiscardTargetCost(new TargetCardInHand(3,3,new FilterCard()));
    for (    UUID playerId : game.getState().getPlayerList(source.getControllerId())) {
      Player player=game.getPlayer(playerId);
      cost.clearPaid();
      if (cost.canPay(source,source.getSourceId(),player.getId(),game) && player.chooseUse(outcome,""String_Node_Str"" + sourceObject.getIdName() + ""String_Node_Str"",source,game)) {
        if (cost.pay(source,game,source.getSourceId(),playerId,false)) {
          game.informPlayers(player.getLogName() + ""String_Node_Str"" + sourceObject.getIdName()+ ""String_Node_Str"");
          Spell spell=game.getStack().getSpell(source.getSourceId());
          if (spell != null) {
            game.getStack().counter(spell.getId(),source.getSourceId(),game);
          }
        }
      }
    }
    return true;
  }
  return false;
}",0.150718889439762
158755,"@Override public boolean apply(Game game,Ability source){
  Spell spell=game.getStack().getSpell(source.getSourceId());
  if (spell != null) {
    for (    UUID playerId : game.getState().getPlayerList(source.getControllerId())) {
      Player player=game.getPlayer(playerId);
      if (player.chooseUse(outcome,""String_Node_Str"" + spell.getIdName() + ""String_Node_Str"",source,game)) {
        Integer amount=(int)Math.ceil(player.getLife() / 2f);
        player.loseLife(amount,game);
        game.informPlayers(player.getLogName() + ""String_Node_Str"" + spell.getIdName()+ ""String_Node_Str"");
        game.getStack().counter(spell.getId(),source.getSourceId(),game);
      }
    }
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  MageObject sourceObject=source.getSourceObject(game);
  if (sourceObject != null) {
    for (    UUID playerId : game.getState().getPlayerList(source.getControllerId())) {
      Player player=game.getPlayer(playerId);
      if (player.chooseUse(outcome,""String_Node_Str"" + sourceObject.getIdName() + ""String_Node_Str"",source,game)) {
        Integer amount=(int)Math.ceil(player.getLife() / 2f);
        player.loseLife(amount,game);
        game.informPlayers(player.getLogName() + ""String_Node_Str"" + sourceObject.getIdName()+ ""String_Node_Str"");
        Spell spell=game.getStack().getSpell(source.getSourceId());
        if (spell != null) {
          game.getStack().counter(spell.getId(),source.getSourceId(),game);
        }
      }
    }
    return true;
  }
  return false;
}",0.8337595907928389
158756,"@Override public void clearPaid(){
  super.clearPaid();
  cards.clear();
}","@Override public void clearPaid(){
  super.clearPaid();
  this.cards.clear();
  this.targets.clear();
}",0.8361581920903954
158757,"@Override public boolean pay(Ability ability,Game game,UUID sourceId,UUID controllerId,boolean noMana){
  this.cards.clear();
  Player player=game.getPlayer(controllerId);
  if (player == null) {
    return false;
  }
  int amount=this.getTargets().get(0).getNumberOfTargets();
  if (randomDiscard) {
    this.cards.addAll(player.discard(amount,true,ability,game).getCards(game));
  }
 else {
    if (targets.choose(Outcome.Discard,controllerId,sourceId,game)) {
      for (      UUID targetId : targets.get(0).getTargets()) {
        Card card=player.getHand().get(targetId,game);
        if (card == null) {
          return false;
        }
        player.discard(card,ability,game);
        this.cards.add(card.copy());
      }
    }
  }
  paid=cards.size() >= amount;
  return paid;
}","@Override public boolean pay(Ability ability,Game game,UUID sourceId,UUID controllerId,boolean noMana){
  this.cards.clear();
  this.targets.clear();
  Player player=game.getPlayer(controllerId);
  if (player == null) {
    return false;
  }
  int amount=this.getTargets().get(0).getNumberOfTargets();
  if (randomDiscard) {
    this.cards.addAll(player.discard(amount,true,ability,game).getCards(game));
  }
 else {
    if (targets.choose(Outcome.Discard,controllerId,sourceId,game)) {
      for (      UUID targetId : targets.get(0).getTargets()) {
        Card card=player.getHand().get(targetId,game);
        if (card == null) {
          return false;
        }
        player.discard(card,ability,game);
        this.cards.add(card.copy());
      }
    }
  }
  paid=cards.size() >= amount;
  return paid;
}",0.9850187265917604
158758,"/** 
 */
@Override public void updateResults(){
  for (  TournamentPlayer player : players.values()) {
    player.setResults(""String_Node_Str"");
    player.setPoints(0);
    player.setStateInfo(""String_Node_Str"");
  }
  for (  Round round : rounds) {
    for (    TournamentPairing pair : round.getPairs()) {
      Match match=pair.getMatch();
      if (match != null && match.hasEnded()) {
        TournamentPlayer tp1=pair.getPlayer1();
        TournamentPlayer tp2=pair.getPlayer2();
        MatchPlayer mp1=match.getPlayer(pair.getPlayer1().getPlayer().getId());
        MatchPlayer mp2=match.getPlayer(pair.getPlayer2().getPlayer().getId());
        if (round.getRoundNumber() == rounds.size()) {
          match.setTournamentRound(round.getRoundNumber());
          if (tp1.getState().equals(TournamentPlayerState.DUELING)) {
            if (round.getRoundNumber() == getNumberRounds()) {
              tp1.setState(TournamentPlayerState.FINISHED);
            }
 else {
              tp1.setState(TournamentPlayerState.WAITING);
            }
          }
          if (tp2.getState().equals(TournamentPlayerState.DUELING)) {
            if (round.getRoundNumber() == getNumberRounds()) {
              tp2.setState(TournamentPlayerState.FINISHED);
            }
 else {
              tp2.setState(TournamentPlayerState.WAITING);
            }
          }
        }
        tp1.setResults(addRoundResult(round.getRoundNumber(),pair,tp1,tp2));
        tp2.setResults(addRoundResult(round.getRoundNumber(),pair,tp2,tp1));
        if (mp2.hasQuit() || mp1.getWins() > mp2.getWins()) {
          tp1.setPoints(tp1.getPoints() + 3);
        }
 else         if (mp1.hasQuit() || mp1.getWins() < mp2.getWins()) {
          tp2.setPoints(tp2.getPoints() + 3);
        }
 else {
          tp1.setPoints(tp1.getPoints() + 1);
          tp2.setPoints(tp2.getPoints() + 1);
        }
      }
    }
    for (    TournamentPlayer tp : round.getPlayerByes()) {
      tp.setResults(new StringBuilder(tp.getResults()).append(""String_Node_Str"").append(round.getRoundNumber()).append(""String_Node_Str"").append(""String_Node_Str"").toString());
      tp.setPoints(tp.getPoints() + 3);
    }
  }
}","/** 
 */
@Override public void updateResults(){
  for (  TournamentPlayer player : players.values()) {
    player.setResults(""String_Node_Str"");
    player.setPoints(0);
    player.setStateInfo(""String_Node_Str"");
  }
  for (  Round round : rounds) {
    for (    TournamentPairing pair : round.getPairs()) {
      Match match=pair.getMatch();
      if (match != null && match.hasEnded()) {
        TournamentPlayer tp1=pair.getPlayer1();
        TournamentPlayer tp2=pair.getPlayer2();
        MatchPlayer mp1=match.getPlayer(pair.getPlayer1().getPlayer().getId());
        MatchPlayer mp2=match.getPlayer(pair.getPlayer2().getPlayer().getId());
        if (round.getRoundNumber() == rounds.size()) {
          match.setTournamentRound(round.getRoundNumber());
          if (tp1.getState().equals(TournamentPlayerState.DUELING)) {
            if (round.getRoundNumber() == getNumberRounds()) {
              tp1.setState(TournamentPlayerState.FINISHED);
            }
 else {
              tp1.setState(TournamentPlayerState.WAITING);
            }
          }
          if (tp2.getState().equals(TournamentPlayerState.DUELING)) {
            if (round.getRoundNumber() == getNumberRounds()) {
              tp2.setState(TournamentPlayerState.FINISHED);
            }
 else {
              tp2.setState(TournamentPlayerState.WAITING);
            }
          }
        }
        tp1.setResults(addRoundResult(round.getRoundNumber(),pair,tp1,tp2));
        tp2.setResults(addRoundResult(round.getRoundNumber(),pair,tp2,tp1));
        if ((!mp1.hasQuit() && mp1.getWins() > mp2.getWins()) || mp2.hasQuit()) {
          tp1.setPoints(tp1.getPoints() + 3);
        }
 else         if ((!mp2.hasQuit() && mp1.getWins() < mp2.getWins()) || mp1.hasQuit()) {
          tp2.setPoints(tp2.getPoints() + 3);
        }
 else {
          tp1.setPoints(tp1.getPoints() + 1);
          tp2.setPoints(tp2.getPoints() + 1);
        }
      }
    }
    for (    TournamentPlayer tp : round.getPlayerByes()) {
      tp.setResults(new StringBuilder(tp.getResults()).append(""String_Node_Str"").append(round.getRoundNumber()).append(""String_Node_Str"").append(""String_Node_Str"").toString());
      tp.setPoints(tp.getPoints() + 3);
    }
  }
}",0.9354545454545454
158759,"public ManaType asThoughMana(ManaType manaType,ManaPoolItem mana,UUID objectId,Ability affectedAbility,UUID controllerId,Game game){
  List<AsThoughEffect> asThoughEffectsList=getApplicableAsThoughEffects(AsThoughEffectType.SPEND_ONLY_MANA,game);
  for (  AsThoughEffect effect : asThoughEffectsList) {
    HashSet<Ability> abilities=asThoughEffectsMap.get(AsThoughEffectType.SPEND_ONLY_MANA).getAbility(effect.getId());
    for (    Ability ability : abilities) {
      if ((affectedAbility == null && effect.applies(objectId,ability,controllerId,game)) || effect.applies(objectId,affectedAbility,ability,game)) {
        if (((AsThoughManaEffect)effect).getAsThoughtManaType(manaType,mana,controllerId,ability,game) == null) {
          return null;
        }
      }
    }
  }
  asThoughEffectsList=getApplicableAsThoughEffects(AsThoughEffectType.SPEND_OTHER_MANA,game);
  for (  AsThoughEffect effect : asThoughEffectsList) {
    HashSet<Ability> abilities=asThoughEffectsMap.get(AsThoughEffectType.SPEND_OTHER_MANA).getAbility(effect.getId());
    for (    Ability ability : abilities) {
      if ((affectedAbility == null && effect.applies(objectId,ability,controllerId,game)) || effect.applies(objectId,affectedAbility,ability,game)) {
        ManaType usableManaType=((AsThoughManaEffect)effect).getAsThoughtManaType(manaType,mana,controllerId,ability,game);
        if (usableManaType != null) {
          return usableManaType;
        }
      }
    }
  }
  return manaType;
}","public ManaType asThoughMana(ManaType manaType,ManaPoolItem mana,UUID objectId,Ability affectedAbility,UUID controllerId,Game game){
  List<AsThoughEffect> asThoughEffectsList=getApplicableAsThoughEffects(AsThoughEffectType.SPEND_ONLY_MANA,game);
  for (  AsThoughEffect effect : asThoughEffectsList) {
    HashSet<Ability> abilities=asThoughEffectsMap.get(AsThoughEffectType.SPEND_ONLY_MANA).getAbility(effect.getId());
    for (    Ability ability : abilities) {
      if ((affectedAbility == null && effect.applies(objectId,ability,controllerId,game)) || effect.applies(objectId,affectedAbility,ability,game)) {
        if (((AsThoughManaEffect)effect).getAsThoughManaType(manaType,mana,controllerId,ability,game) == null) {
          return null;
        }
      }
    }
  }
  asThoughEffectsList=getApplicableAsThoughEffects(AsThoughEffectType.SPEND_OTHER_MANA,game);
  for (  AsThoughEffect effect : asThoughEffectsList) {
    HashSet<Ability> abilities=asThoughEffectsMap.get(AsThoughEffectType.SPEND_OTHER_MANA).getAbility(effect.getId());
    for (    Ability ability : abilities) {
      if ((affectedAbility == null && effect.applies(objectId,ability,controllerId,game)) || effect.applies(objectId,affectedAbility,ability,game)) {
        ManaType usableManaType=((AsThoughManaEffect)effect).getAsThoughManaType(manaType,mana,controllerId,ability,game);
        if (usableManaType != null) {
          return usableManaType;
        }
      }
    }
  }
  return manaType;
}",0.9993265993265992
158760,"@Override public boolean applies(GameEvent event,Ability source,Game game){
switch (((ZoneChangeEvent)event).getToZone()) {
case HAND:
    if (!alsoHand && ((ZoneChangeEvent)event).getToZone() == Zone.HAND) {
      return false;
    }
case LIBRARY:
  if (!alsoLibrary && ((ZoneChangeEvent)event).getToZone() == Zone.LIBRARY) {
    return false;
  }
case GRAVEYARD:
case EXILED:
if (commanderId.equals(event.getTargetId())) {
  return true;
}
break;
case STACK:
Spell spell=game.getStack().getSpell(event.getTargetId());
if (spell != null) {
if (commanderId.equals(spell.getSourceId())) {
return true;
}
}
break;
}
return false;
}","@Override public boolean applies(GameEvent event,Ability source,Game game){
switch (((ZoneChangeEvent)event).getToZone()) {
case HAND:
    if (!alsoHand && ((ZoneChangeEvent)event).getToZone() == Zone.HAND) {
      return false;
    }
case LIBRARY:
  if (!alsoLibrary && ((ZoneChangeEvent)event).getToZone() == Zone.LIBRARY) {
    return false;
  }
case GRAVEYARD:
case EXILED:
if (((ZoneChangeEvent)event).getFromZone().equals(Zone.STACK)) {
  Spell spell=game.getStack().getSpell(event.getTargetId());
  if (spell != null && commanderId.equals(spell.getSourceId())) {
    return true;
  }
}
if (commanderId.equals(event.getTargetId())) {
return true;
}
break;
case STACK:
Spell spell=game.getStack().getSpell(event.getTargetId());
if (spell != null) {
if (commanderId.equals(spell.getSourceId())) {
return true;
}
}
break;
}
return false;
}",0.8157715839564922
158761,"@Override public void selectAttackers(Game game,UUID attackingPlayerId){
  updateGameStatePriority(""String_Node_Str"",game);
  FilterCreatureForCombat filter=filterCreatureForCombat.copy();
  filter.add(new ControllerIdPredicate(attackingPlayerId));
  while (!abort) {
    if (passedAllTurns || (!getUserData().getUserSkipPrioritySteps().isStopOnDeclareAttackersDuringSkipAction() && (passedTurn || passedUntilEndOfTurn || passedUntilNextMain))) {
      return;
    }
    Map<String,Serializable> options=new HashMap<>();
    List<UUID> possibleAttackers=new ArrayList<>();
    for (    Permanent possibleAttacker : game.getBattlefield().getActivePermanents(filter,attackingPlayerId,game)) {
      if (possibleAttacker.canAttack(game)) {
        possibleAttackers.add(possibleAttacker.getId());
      }
    }
    options.put(Constants.Option.POSSIBLE_ATTACKERS,(Serializable)possibleAttackers);
    if (possibleAttackers.size() > 0) {
      options.put(Constants.Option.SPECIAL_BUTTON,(Serializable)""String_Node_Str"");
    }
    game.fireSelectEvent(playerId,""String_Node_Str"",options);
    waitForResponse(game);
    if (response.getString() != null && response.getString().equals(""String_Node_Str"")) {
      setStoredBookmark(game.bookmarkState());
      UUID attackedDefender=null;
      if (game.getCombat().getDefenders().size() > 1) {
        attackedDefender=selectDefenderForAllAttack(game.getCombat().getDefenders(),game);
      }
 else       if (game.getCombat().getDefenders().size() == 1) {
        attackedDefender=game.getCombat().getDefenders().iterator().next();
      }
      for (      Permanent attacker : game.getBattlefield().getAllActivePermanents(filterCreatureForCombat,getId(),game)) {
        if (game.getContinuousEffects().checkIfThereArePayCostToAttackBlockEffects(GameEvent.getEvent(GameEvent.EventType.DECLARE_ATTACKER,attackedDefender,attacker.getId(),attacker.getControllerId()),game)) {
          continue;
        }
        declareAttacker(attacker.getId(),attackedDefender,game,false);
      }
    }
 else     if (response.getBoolean() != null) {
      if (!game.getCombat().getCreaturesForcedToAttack().isEmpty()) {
        if (!game.getCombat().getAttackers().containsAll(game.getCombat().getCreaturesForcedToAttack().keySet())) {
          int forcedAttackers=0;
          StringBuilder sb=new StringBuilder();
          for (          UUID creatureId : game.getCombat().getCreaturesForcedToAttack().keySet()) {
            boolean validForcedAttacker=false;
            if (game.getCombat().getAttackers().contains(creatureId)) {
              Set<UUID> possibleDefender=game.getCombat().getCreaturesForcedToAttack().get(creatureId);
              if (possibleDefender.isEmpty() || possibleDefender.contains(game.getCombat().getDefenderId(creatureId))) {
                validForcedAttacker=true;
              }
            }
            if (validForcedAttacker) {
              forcedAttackers++;
            }
 else {
              Permanent creature=game.getPermanent(creatureId);
              if (creature != null) {
                sb.append(creature.getName()).append(""String_Node_Str"");
              }
            }
          }
          if (game.getCombat().getMaxAttackers() > forcedAttackers) {
            game.informPlayer(this,sb.insert(0,""String_Node_Str"").insert(0,Math.min(game.getCombat().getMaxAttackers() - forcedAttackers,game.getCombat().getCreaturesForcedToAttack().size() - forcedAttackers)).insert(0,""String_Node_Str"").toString());
            continue;
          }
        }
      }
      return;
    }
 else     if (response.getInteger() != null) {
      return;
    }
 else     if (response.getUUID() != null) {
      Permanent attacker=game.getPermanent(response.getUUID());
      if (attacker != null) {
        if (filterCreatureForCombat.match(attacker,null,playerId,game)) {
          selectDefender(game.getCombat().getDefenders(),attacker.getId(),game);
        }
 else         if (filterAttack.match(attacker,null,playerId,game) && game.getStack().isEmpty()) {
          removeAttackerIfPossible(game,attacker);
        }
      }
    }
  }
}","@Override public void selectAttackers(Game game,UUID attackingPlayerId){
  updateGameStatePriority(""String_Node_Str"",game);
  FilterCreatureForCombat filter=filterCreatureForCombat.copy();
  filter.add(new ControllerIdPredicate(attackingPlayerId));
  while (!abort) {
    if (passedAllTurns || (!getUserData().getUserSkipPrioritySteps().isStopOnDeclareAttackersDuringSkipAction() && (passedTurn || passedUntilEndOfTurn || passedUntilNextMain))) {
      return;
    }
    Map<String,Serializable> options=new HashMap<>();
    List<UUID> possibleAttackers=new ArrayList<>();
    for (    Permanent possibleAttacker : game.getBattlefield().getActivePermanents(filter,attackingPlayerId,game)) {
      if (possibleAttacker.canAttack(game)) {
        possibleAttackers.add(possibleAttacker.getId());
      }
    }
    options.put(Constants.Option.POSSIBLE_ATTACKERS,(Serializable)possibleAttackers);
    if (possibleAttackers.size() > 0) {
      options.put(Constants.Option.SPECIAL_BUTTON,(Serializable)""String_Node_Str"");
    }
    game.fireSelectEvent(playerId,""String_Node_Str"",options);
    waitForResponse(game);
    if (response.getString() != null && response.getString().equals(""String_Node_Str"")) {
      setStoredBookmark(game.bookmarkState());
      UUID attackedDefender=null;
      if (game.getCombat().getDefenders().size() > 1) {
        attackedDefender=selectDefenderForAllAttack(game.getCombat().getDefenders(),game);
      }
 else       if (game.getCombat().getDefenders().size() == 1) {
        attackedDefender=game.getCombat().getDefenders().iterator().next();
      }
      for (      Permanent attacker : game.getBattlefield().getAllActivePermanents(filterCreatureForCombat,getId(),game)) {
        if (game.getContinuousEffects().checkIfThereArePayCostToAttackBlockEffects(GameEvent.getEvent(GameEvent.EventType.DECLARE_ATTACKER,attackedDefender,attacker.getId(),attacker.getControllerId()),game)) {
          continue;
        }
        if (game.getCombat().getCreaturesForcedToAttack().containsKey(attacker.getId())) {
          Set<UUID> possibleDefenders=game.getCombat().getCreaturesForcedToAttack().get(attacker.getId());
          if (!possibleDefenders.isEmpty() && !possibleDefenders.contains(attackedDefender)) {
            declareAttacker(attacker.getId(),possibleDefenders.iterator().next(),game,false);
            continue;
          }
        }
        declareAttacker(attacker.getId(),attackedDefender,game,false);
      }
    }
 else     if (response.getBoolean() != null) {
      if (!game.getCombat().getCreaturesForcedToAttack().isEmpty()) {
        if (!game.getCombat().getAttackers().containsAll(game.getCombat().getCreaturesForcedToAttack().keySet())) {
          int forcedAttackers=0;
          StringBuilder sb=new StringBuilder();
          for (          UUID creatureId : game.getCombat().getCreaturesForcedToAttack().keySet()) {
            boolean validForcedAttacker=false;
            if (game.getCombat().getAttackers().contains(creatureId)) {
              Set<UUID> possibleDefender=game.getCombat().getCreaturesForcedToAttack().get(creatureId);
              if (possibleDefender.isEmpty() || possibleDefender.contains(game.getCombat().getDefenderId(creatureId))) {
                validForcedAttacker=true;
              }
            }
            if (validForcedAttacker) {
              forcedAttackers++;
            }
 else {
              Permanent creature=game.getPermanent(creatureId);
              if (creature != null) {
                sb.append(creature.getIdName()).append(""String_Node_Str"");
              }
            }
          }
          if (game.getCombat().getMaxAttackers() > forcedAttackers) {
            int requireToAttack=Math.min(game.getCombat().getMaxAttackers() - forcedAttackers,game.getCombat().getCreaturesForcedToAttack().size() - forcedAttackers);
            String message=(requireToAttack == 1 ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"" + (requireToAttack == 1 ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str"";
            game.informPlayer(this,sb.insert(0,message).insert(0,requireToAttack).insert(0,""String_Node_Str"").toString());
            continue;
          }
        }
      }
      return;
    }
 else     if (response.getInteger() != null) {
      return;
    }
 else     if (response.getUUID() != null) {
      Permanent attacker=game.getPermanent(response.getUUID());
      if (attacker != null) {
        if (filterCreatureForCombat.match(attacker,null,playerId,game)) {
          selectDefender(game.getCombat().getDefenders(),attacker.getId(),game);
        }
 else         if (filterAttack.match(attacker,null,playerId,game) && game.getStack().isEmpty()) {
          removeAttackerIfPossible(game,attacker);
        }
      }
    }
  }
}",0.5798045602605864
158762,"/** 
 * Selects a defender for an attacker and adds the attacker to combat
 * @param defenders - list of possible defender
 * @param attackerId - UUID of attacker
 * @param game
 * @return
 */
protected boolean selectDefender(Set<UUID> defenders,UUID attackerId,Game game){
  boolean forcedToAttack=false;
  Set<UUID> possibleDefender=game.getCombat().getCreaturesForcedToAttack().get(attackerId);
  if (possibleDefender != null) {
    forcedToAttack=true;
  }
  if (possibleDefender == null || possibleDefender.isEmpty()) {
    possibleDefender=defenders;
  }
  if (possibleDefender.size() == 1) {
    declareAttacker(attackerId,defenders.iterator().next(),game,true);
    return true;
  }
 else {
    TargetDefender target=new TargetDefender(possibleDefender,attackerId);
    target.setNotTarget(true);
    if (forcedToAttack) {
      StringBuilder sb=new StringBuilder(target.getTargetName());
      Permanent attacker=game.getPermanent(attackerId);
      if (attacker != null) {
        sb.append(""String_Node_Str"").append(attacker.getName()).append(""String_Node_Str"");
        target.setTargetName(sb.toString());
      }
    }
    if (chooseTarget(Outcome.Damage,target,null,game)) {
      declareAttacker(attackerId,response.getUUID(),game,true);
      return true;
    }
  }
  return false;
}","/** 
 * Selects a defender for an attacker and adds the attacker to combat
 * @param defenders - list of possible defender
 * @param attackerId - UUID of attacker
 * @param game
 * @return
 */
protected boolean selectDefender(Set<UUID> defenders,UUID attackerId,Game game){
  boolean forcedToAttack=false;
  Set<UUID> possibleDefender=game.getCombat().getCreaturesForcedToAttack().get(attackerId);
  if (possibleDefender != null) {
    forcedToAttack=true;
  }
  if (possibleDefender == null || possibleDefender.isEmpty()) {
    possibleDefender=defenders;
  }
  if (possibleDefender.size() == 1) {
    declareAttacker(attackerId,possibleDefender.iterator().next(),game,true);
    return true;
  }
 else {
    TargetDefender target=new TargetDefender(possibleDefender,attackerId);
    target.setNotTarget(true);
    if (forcedToAttack) {
      StringBuilder sb=new StringBuilder(target.getTargetName());
      Permanent attacker=game.getPermanent(attackerId);
      if (attacker != null) {
        sb.append(""String_Node_Str"").append(attacker.getName()).append(""String_Node_Str"");
        target.setTargetName(sb.toString());
      }
    }
    if (chooseTarget(Outcome.Damage,target,null,game)) {
      declareAttacker(attackerId,response.getUUID(),game,true);
      return true;
    }
  }
  return false;
}",0.9904104334484082
158763,"@Override public boolean isInactive(Ability source,Game game){
  if (targetPermanentReference == null) {
    return true;
  }
  Permanent targetPermanent=targetPermanentReference.getPermanent(game);
  if (targetPermanent == null) {
    return true;
  }
  if (nextTurnTargetController == 0 && startingTurn != game.getTurnNum() && game.getActivePlayerId().equals(targetPermanent.getControllerId())) {
    nextTurnTargetController=game.getTurnNum();
  }
  if (game.getPhase().getType() == TurnPhase.END && nextTurnTargetController > 0 && game.getTurnNum() > nextTurnTargetController) {
    return true;
  }
  return false;
}","@Override public boolean isInactive(Ability source,Game game){
  if (targetPermanentReference == null) {
    return true;
  }
  Permanent targetPermanent=targetPermanentReference.getPermanent(game);
  if (targetPermanent == null) {
    return true;
  }
  if (nextTurnTargetController == 0 && startingTurn != game.getTurnNum() && game.getActivePlayerId().equals(targetPermanent.getControllerId())) {
    nextTurnTargetController=game.getTurnNum();
  }
  return game.getPhase().getType() == TurnPhase.END && nextTurnTargetController > 0 && game.getTurnNum() > nextTurnTargetController;
}",0.9585406301824212
158764,"protected void checkAttackRequirements(Player player,Game game){
  for (  Permanent creature : player.getAvailableAttackers(game)) {
    boolean mustAttack=false;
    Set<UUID> defendersForcedToAttack=new HashSet<>();
    for (    Map.Entry<RequirementEffect,HashSet<Ability>> entry : game.getContinuousEffects().getApplicableRequirementEffects(creature,game).entrySet()) {
      RequirementEffect effect=entry.getKey();
      if (effect.mustAttack(game)) {
        mustAttack=true;
        for (        Ability ability : entry.getValue()) {
          UUID defenderId=effect.mustAttackDefender(ability,game);
          if (defenderId != null) {
            if (defenders.contains(defenderId)) {
              defendersForcedToAttack.add(defenderId);
            }
          }
          break;
        }
      }
    }
    if (mustAttack) {
      HashSet<UUID> defendersCostlessAttackable=new HashSet<>();
      defendersCostlessAttackable.addAll(defenders);
      for (      UUID defenderId : defenders) {
        if (game.getContinuousEffects().checkIfThereArePayCostToAttackBlockEffects(GameEvent.getEvent(GameEvent.EventType.DECLARE_ATTACKER,defenderId,creature.getId(),creature.getControllerId()),game)) {
          defendersCostlessAttackable.remove(defenderId);
          defendersForcedToAttack.remove(defenderId);
        }
      }
      if (!defendersCostlessAttackable.isEmpty()) {
        if (defendersForcedToAttack.isEmpty()) {
          creaturesForcedToAttack.put(creature.getId(),defendersForcedToAttack);
          if (defendersForcedToAttack.isEmpty()) {
            if (defendersCostlessAttackable.size() == 1) {
              player.declareAttacker(creature.getId(),defenders.iterator().next(),game,false);
            }
          }
 else {
            TargetDefender target=new TargetDefender(defendersCostlessAttackable,creature.getId());
            target.setRequired(true);
            if (player.chooseTarget(Outcome.Damage,target,null,game)) {
              player.declareAttacker(creature.getId(),target.getFirstTarget(),game,false);
            }
          }
        }
 else {
          player.declareAttacker(creature.getId(),defendersForcedToAttack.iterator().next(),game,false);
        }
      }
    }
  }
}","protected void checkAttackRequirements(Player player,Game game){
  for (  Permanent creature : player.getAvailableAttackers(game)) {
    boolean mustAttack=false;
    Set<UUID> defendersForcedToAttack=new HashSet<>();
    for (    Map.Entry<RequirementEffect,HashSet<Ability>> entry : game.getContinuousEffects().getApplicableRequirementEffects(creature,game).entrySet()) {
      RequirementEffect effect=entry.getKey();
      if (effect.mustAttack(game)) {
        mustAttack=true;
        for (        Ability ability : entry.getValue()) {
          UUID defenderId=effect.mustAttackDefender(ability,game);
          if (defenderId != null) {
            if (defenders.contains(defenderId)) {
              defendersForcedToAttack.add(defenderId);
            }
          }
          break;
        }
      }
    }
    if (mustAttack) {
      HashSet<UUID> defendersCostlessAttackable=new HashSet<>();
      defendersCostlessAttackable.addAll(defenders);
      for (      UUID defenderId : defenders) {
        if (game.getContinuousEffects().checkIfThereArePayCostToAttackBlockEffects(GameEvent.getEvent(GameEvent.EventType.DECLARE_ATTACKER,defenderId,creature.getId(),creature.getControllerId()),game)) {
          defendersCostlessAttackable.remove(defenderId);
          defendersForcedToAttack.remove(defenderId);
        }
      }
      if (!defendersCostlessAttackable.isEmpty()) {
        creaturesForcedToAttack.put(creature.getId(),defendersForcedToAttack);
        if (defendersForcedToAttack.isEmpty()) {
          if (defendersForcedToAttack.isEmpty()) {
            if (defendersCostlessAttackable.size() == 1) {
              player.declareAttacker(creature.getId(),defenders.iterator().next(),game,false);
            }
          }
 else {
            TargetDefender target=new TargetDefender(defendersCostlessAttackable,creature.getId());
            target.setRequired(true);
            if (player.chooseTarget(Outcome.Damage,target,null,game)) {
              player.declareAttacker(creature.getId(),target.getFirstTarget(),game,false);
            }
          }
        }
 else {
          player.declareAttacker(creature.getId(),defendersForcedToAttack.iterator().next(),game,false);
        }
      }
    }
  }
}",0.9588918677390528
158765,"private Map<String,String> getSetLinks(String cardSet){
  Map<String,String> setLinks=new HashMap<>();
  try {
    String setNames=setsAliases.get(cardSet.toLowerCase());
    Set<String> aliasesStart=cardNameAliasesStart.get(cardSet);
    if (setNames == null) {
      setNames=cardSet.toLowerCase();
    }
    Preferences prefs=MageFrame.getPreferences();
    Connection.ProxyType proxyType=Connection.ProxyType.valueByText(prefs.get(""String_Node_Str"",""String_Node_Str""));
    for (    String setName : setNames.split(""String_Node_Str"")) {
      String URLSetName=URLEncoder.encode(setName,""String_Node_Str"");
      String baseUrl=""String_Node_Str"" + URLSetName + ""String_Node_Str"";
      String urlDocument;
      Document doc;
      if (proxyType.equals(ProxyType.NONE)) {
        urlDocument=baseUrl;
        doc=Jsoup.connect(urlDocument).get();
      }
 else {
        String proxyServer=prefs.get(""String_Node_Str"",""String_Node_Str"");
        int proxyPort=Integer.parseInt(prefs.get(""String_Node_Str"",""String_Node_Str""));
        URL url=new URL(baseUrl);
        Proxy proxy=new Proxy(Proxy.Type.HTTP,new InetSocketAddress(proxyServer,proxyPort));
        HttpURLConnection uc=(HttpURLConnection)url.openConnection(proxy);
        uc.connect();
        String line;
        StringBuffer tmp=new StringBuffer();
        BufferedReader in=new BufferedReader(new InputStreamReader(uc.getInputStream()));
        while ((line=in.readLine()) != null) {
          tmp.append(line);
        }
        doc=Jsoup.parse(String.valueOf(tmp));
      }
      Elements cardsImages=doc.select(""String_Node_Str"");
      if (!aliasesStart.isEmpty()) {
        for (        String text : aliasesStart) {
          cardsImages.addAll(doc.select(""String_Node_Str"" + text + ""String_Node_Str""));
        }
      }
      if (cardsImages.isEmpty()) {
        break;
      }
      for (      Element cardsImage : cardsImages) {
        String cardLink=cardsImage.attr(""String_Node_Str"");
        String cardName=null;
        if (cardLink.startsWith(""String_Node_Str"") && cardLink.endsWith(""String_Node_Str"")) {
          cardName=cardLink.substring(6,cardLink.length() - 4);
        }
 else         if (aliasesStart.contains(cardLink)) {
          cardName=cardLink.substring(0,cardLink.length() - 4);
          ;
        }
        if (cardName != null && !cardName.isEmpty()) {
          if (cardNameAliases.containsKey(cardSet + ""String_Node_Str"" + cardName)) {
            cardName=cardNameAliases.get(cardSet + ""String_Node_Str"" + cardName);
          }
          if (cardName.endsWith(""String_Node_Str"") || cardName.endsWith(""String_Node_Str"") || cardName.endsWith(""String_Node_Str"")|| cardName.endsWith(""String_Node_Str"")|| cardName.endsWith(""String_Node_Str"")) {
            if (!cardName.startsWith(""String_Node_Str"") && !cardName.startsWith(""String_Node_Str"") && !cardName.startsWith(""String_Node_Str"")&& !cardName.startsWith(""String_Node_Str"")&& !cardName.startsWith(""String_Node_Str"")) {
              cardName=cardName.substring(0,cardName.length() - 1);
            }
          }
          setLinks.put(cardName,baseUrl + cardLink);
        }
      }
    }
  }
 catch (  IOException ex) {
    System.out.println(""String_Node_Str"" + ex.getMessage());
  }
  return setLinks;
}","private Map<String,String> getSetLinks(String cardSet){
  Map<String,String> setLinks=new HashMap<>();
  try {
    String setNames=setsAliases.get(cardSet.toLowerCase());
    Set<String> aliasesStart=new HashSet<>();
    if (cardNameAliasesStart.containsKey(cardSet)) {
      aliasesStart.addAll(cardNameAliasesStart.get(cardSet));
    }
    if (setNames == null) {
      setNames=cardSet.toLowerCase();
    }
    Preferences prefs=MageFrame.getPreferences();
    Connection.ProxyType proxyType=Connection.ProxyType.valueByText(prefs.get(""String_Node_Str"",""String_Node_Str""));
    for (    String setName : setNames.split(""String_Node_Str"")) {
      String URLSetName=URLEncoder.encode(setName,""String_Node_Str"");
      String baseUrl=""String_Node_Str"" + URLSetName + ""String_Node_Str"";
      String urlDocument;
      Document doc;
      if (proxyType.equals(ProxyType.NONE)) {
        urlDocument=baseUrl;
        doc=Jsoup.connect(urlDocument).get();
      }
 else {
        String proxyServer=prefs.get(""String_Node_Str"",""String_Node_Str"");
        int proxyPort=Integer.parseInt(prefs.get(""String_Node_Str"",""String_Node_Str""));
        URL url=new URL(baseUrl);
        Proxy proxy=new Proxy(Proxy.Type.HTTP,new InetSocketAddress(proxyServer,proxyPort));
        HttpURLConnection uc=(HttpURLConnection)url.openConnection(proxy);
        uc.connect();
        String line;
        StringBuffer tmp=new StringBuffer();
        BufferedReader in=new BufferedReader(new InputStreamReader(uc.getInputStream()));
        while ((line=in.readLine()) != null) {
          tmp.append(line);
        }
        doc=Jsoup.parse(String.valueOf(tmp));
      }
      Elements cardsImages=doc.select(""String_Node_Str"");
      if (!aliasesStart.isEmpty()) {
        for (        String text : aliasesStart) {
          cardsImages.addAll(doc.select(""String_Node_Str"" + text + ""String_Node_Str""));
        }
      }
      if (cardsImages.isEmpty()) {
        break;
      }
      for (      Element cardsImage : cardsImages) {
        String cardLink=cardsImage.attr(""String_Node_Str"");
        String cardName=null;
        if (cardLink.startsWith(""String_Node_Str"") && cardLink.endsWith(""String_Node_Str"")) {
          cardName=cardLink.substring(6,cardLink.length() - 4);
        }
 else         if (aliasesStart.contains(cardLink)) {
          cardName=cardLink.substring(0,cardLink.length() - 4);
          ;
        }
        if (cardName != null && !cardName.isEmpty()) {
          if (cardNameAliases.containsKey(cardSet + ""String_Node_Str"" + cardName)) {
            cardName=cardNameAliases.get(cardSet + ""String_Node_Str"" + cardName);
          }
          if (cardName.endsWith(""String_Node_Str"") || cardName.endsWith(""String_Node_Str"") || cardName.endsWith(""String_Node_Str"")|| cardName.endsWith(""String_Node_Str"")|| cardName.endsWith(""String_Node_Str"")) {
            if (!cardName.startsWith(""String_Node_Str"") && !cardName.startsWith(""String_Node_Str"") && !cardName.startsWith(""String_Node_Str"")&& !cardName.startsWith(""String_Node_Str"")&& !cardName.startsWith(""String_Node_Str"")) {
              cardName=cardName.substring(0,cardName.length() - 1);
            }
          }
          setLinks.put(cardName,baseUrl + cardLink);
        }
      }
    }
  }
 catch (  IOException ex) {
    System.out.println(""String_Node_Str"" + ex.getMessage());
  }
  return setLinks;
}",0.9805927486083948
158766,"@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  MageObject sourceObject=game.getObject(source.getSourceId());
  if (controller != null) {
    Player targetPlayer=game.getPlayer(getTargetPointer().getFirst(game,source));
    if (targetPlayer != null) {
      if (targetPlayer.getHand().size() > 0) {
        Cards cards=new CardsImpl();
        Card card=targetPlayer.getHand().getRandom(game);
        cards.add(card);
        if (targetPlayer.getHand().size() > 1) {
          do {
            card=targetPlayer.getHand().getRandom(game);
          }
 while (cards.contains(card.getId()));
          cards.add(card);
        }
        targetPlayer.revealCards(sourceObject.getName(),cards,game);
        for (        Card cardToDiscard : cards.getCards(game)) {
          if (!cardToDiscard.getCardType().contains(CardType.LAND)) {
            targetPlayer.discard(cardToDiscard,source,game);
          }
        }
      }
    }
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  MageObject sourceObject=game.getObject(source.getSourceId());
  if (controller != null) {
    Player targetPlayer=game.getPlayer(getTargetPointer().getFirst(game,source));
    if (targetPlayer != null) {
      if (targetPlayer.getHand().size() > 0) {
        Cards cards=new CardsImpl();
        Card card=targetPlayer.getHand().getRandom(game);
        cards.add(card);
        if (targetPlayer.getHand().size() > 1) {
          do {
            card=targetPlayer.getHand().getRandom(game);
          }
 while (cards.contains(card.getId()));
          cards.add(card);
        }
        targetPlayer.revealCards(sourceObject.getIdName(),cards,game);
        for (        Card cardToDiscard : cards.getCards(game)) {
          if (!cardToDiscard.getCardType().contains(CardType.LAND)) {
            targetPlayer.discard(cardToDiscard,source,game);
          }
        }
      }
    }
    return true;
  }
  return false;
}",0.9990412272291468
158767,"@Override public boolean isLegal(Ability source,Game game){
  Set<UUID> illegalTargets=new HashSet<>();
  for (  UUID targetId : targets.keySet()) {
    Card card=game.getCard(targetId);
    if (card != null) {
      if (zoneChangeCounters.containsKey(targetId) && zoneChangeCounters.get(targetId) != card.getZoneChangeCounter(game)) {
        illegalTargets.add(targetId);
        continue;
      }
    }
    if (!notTarget && game.replaceEvent(GameEvent.getEvent(EventType.TARGET,targetId,source.getSourceId(),source.getControllerId()))) {
      illegalTargets.add(targetId);
      continue;
    }
    if (!canTarget(targetId,source,game)) {
      illegalTargets.add(targetId);
    }
  }
  for (  UUID targetId : illegalTargets) {
    targets.remove(targetId);
  }
  if (getNumberOfTargets() == 0 && targets.isEmpty()) {
    return true;
  }
  return targets.size() > 0;
}","@Override public boolean isLegal(Ability source,Game game){
  Set<UUID> illegalTargets=new HashSet<>();
  for (  UUID targetId : targets.keySet()) {
    Card card=game.getCard(targetId);
    if (card != null) {
      if (zoneChangeCounters.containsKey(targetId) && zoneChangeCounters.get(targetId) != card.getZoneChangeCounter(game)) {
        illegalTargets.add(targetId);
        continue;
      }
    }
    if (!notTarget && game.replaceEvent(GameEvent.getEvent(EventType.TARGET,targetId,source.getSourceId(),source.getControllerId()))) {
      illegalTargets.add(targetId);
      continue;
    }
    if (!canTarget(targetId,source,game)) {
      illegalTargets.add(targetId);
    }
  }
  for (  UUID targetId : illegalTargets) {
    targets.remove(targetId);
  }
  if (targets.isEmpty()) {
    if (!illegalTargets.isEmpty()) {
      return false;
    }
    if (getNumberOfTargets() == 0) {
      return true;
    }
  }
  return targets.size() > 0;
}",0.9195402298850576
158768,"public String registerUserHandling(String userName) throws MageException {
  this.isAdmin=false;
  if (userName.equals(""String_Node_Str"")) {
    return ""String_Node_Str"";
  }
  if (userName.length() > ConfigSettings.getInstance().getMaxUserNameLength()) {
    return new StringBuilder(""String_Node_Str"").append(ConfigSettings.getInstance().getMaxUserNameLength()).append(""String_Node_Str"").toString();
  }
  if (userName.length() < ConfigSettings.getInstance().getMinUserNameLength()) {
    return new StringBuilder(""String_Node_Str"").append(ConfigSettings.getInstance().getMinUserNameLength()).append(""String_Node_Str"").toString();
  }
  Pattern p=Pattern.compile(ConfigSettings.getInstance().getUserNamePattern(),Pattern.CASE_INSENSITIVE);
  Matcher m=p.matcher(userName);
  if (m.find()) {
    return new StringBuilder(""String_Node_Str"").append(userName).append(""String_Node_Str"").toString();
  }
  User user=UserManager.getInstance().createUser(userName,host);
  boolean reconnect=false;
  if (user == null) {
    user=UserManager.getInstance().findUser(userName);
    if (user.getHost().equals(host)) {
      user.updateLastActivity(null);
      this.userId=user.getId();
      if (user.getSessionId().isEmpty()) {
        logger.info(""String_Node_Str"" + userName);
        reconnect=true;
      }
 else {
        logger.info(""String_Node_Str"" + userName);
        SessionManager.getInstance().disconnect(user.getSessionId(),DisconnectReason.ConnectingOtherInstance);
      }
    }
 else {
      return new StringBuilder(""String_Node_Str"").append(userName).append(""String_Node_Str"").toString();
    }
  }
  if (!UserManager.getInstance().connectToSession(sessionId,user.getId())) {
    return new StringBuilder(""String_Node_Str"").append(userName).toString();
  }
  this.userId=user.getId();
  if (reconnect) {
    UUID chatId=GamesRoomManager.getInstance().getRoom(GamesRoomManager.getInstance().getMainRoomId()).getChatId();
    if (chatId != null) {
      ChatManager.getInstance().joinChat(chatId,userId);
    }
    ChatManager.getInstance().sendReconnectMessage(userId);
  }
  return null;
}","public String registerUserHandling(String userName) throws MageException {
  this.isAdmin=false;
  if (userName.equals(""String_Node_Str"")) {
    return ""String_Node_Str"";
  }
  if (userName.length() > ConfigSettings.getInstance().getMaxUserNameLength()) {
    return ""String_Node_Str"" + ConfigSettings.getInstance().getMaxUserNameLength() + ""String_Node_Str"";
  }
  if (userName.length() < ConfigSettings.getInstance().getMinUserNameLength()) {
    return ""String_Node_Str"" + ConfigSettings.getInstance().getMinUserNameLength() + ""String_Node_Str"";
  }
  Pattern p=Pattern.compile(ConfigSettings.getInstance().getUserNamePattern(),Pattern.CASE_INSENSITIVE);
  Matcher m=p.matcher(userName);
  if (m.find()) {
    return ""String_Node_Str"" + userName + ""String_Node_Str"";
  }
  User user=UserManager.getInstance().createUser(userName,host);
  boolean reconnect=false;
  if (user == null) {
    user=UserManager.getInstance().findUser(userName);
    if (user.getHost().equals(host)) {
      user.updateLastActivity(null);
      this.userId=user.getId();
      if (user.getSessionId().isEmpty()) {
        logger.info(""String_Node_Str"" + userName);
        reconnect=true;
      }
 else {
        logger.info(""String_Node_Str"" + userName);
        SessionManager.getInstance().disconnect(user.getSessionId(),DisconnectReason.ConnectingOtherInstance);
      }
    }
 else {
      return ""String_Node_Str"" + userName + ""String_Node_Str"";
    }
  }
  if (!UserManager.getInstance().connectToSession(sessionId,user.getId())) {
    return ""String_Node_Str"" + userName;
  }
  this.userId=user.getId();
  if (reconnect) {
    UUID chatId=GamesRoomManager.getInstance().getRoom(GamesRoomManager.getInstance().getMainRoomId()).getChatId();
    if (chatId != null) {
      ChatManager.getInstance().joinChat(chatId,userId);
    }
    ChatManager.getInstance().sendReconnectMessage(userId);
  }
  return null;
}",0.8468468468468469
158769,"@Override public boolean checkTrigger(GameEvent event,Game game){
  if (event.getPlayerId().equals(this.getControllerId())) {
    Spell spell=game.getStack().getSpell(event.getTargetId());
    if (isControlledInstantOrSorcery(spell)) {
      boolean targetsSource=false;
      for (      Target target : spell.getSpellAbility().getTargets()) {
        for (        UUID targetId : target.getTargets()) {
          if (targetId.equals(getSourceId())) {
            targetsSource=true;
          }
 else {
            return false;
          }
        }
      }
      if (targetsSource) {
        this.getEffects().get(0).setTargetPointer(new FixedTarget(spell.getId()));
        return true;
      }
    }
  }
  return false;
}","@Override public boolean checkTrigger(GameEvent event,Game game){
  if (event.getPlayerId().equals(this.getControllerId())) {
    Spell spell=game.getStack().getSpell(event.getTargetId());
    if (isControlledInstantOrSorcery(spell)) {
      boolean targetsSource=false;
      for (      UUID modeId : spell.getSpellAbility().getModes().getSelectedModes()) {
        spell.getSpellAbility().getModes().setActiveMode(modeId);
        for (        Target target : spell.getSpellAbility().getTargets()) {
          for (          UUID targetId : target.getTargets()) {
            if (targetId.equals(getSourceId())) {
              targetsSource=true;
            }
 else {
              return false;
            }
          }
        }
      }
      if (targetsSource) {
        this.getEffects().get(0).setTargetPointer(new FixedTarget(spell.getId()));
        return true;
      }
    }
  }
  return false;
}",0.8655256723716381
158770,"@Override public boolean apply(Game game,Ability source){
  Spell spell=game.getStack().getSpell(targetPointer.getFirst(game,source));
  if (spell == null) {
    spell=(Spell)game.getLastKnownInformation(targetPointer.getFirst(game,source),Zone.STACK);
  }
  Player controller=game.getPlayer(source.getControllerId());
  if (spell != null && controller != null) {
    Target usedTarget=null;
    for (    Target target : spell.getSpellAbility().getTargets()) {
      if (target.getFirstTarget().equals(source.getSourceId())) {
        usedTarget=target.copy();
        usedTarget.clearChosen();
      }
    }
    if (usedTarget == null) {
      return false;
    }
    for (    Permanent creature : game.getState().getBattlefield().getAllActivePermanents(new FilterCreaturePermanent(),source.getControllerId(),game)) {
      if (!creature.getId().equals(source.getSourceId()) && usedTarget.canTarget(source.getControllerId(),creature.getId(),source,game)) {
        Spell copy=spell.copySpell();
        for (        Target target : spell.getSpellAbility().getTargets()) {
          if (target.getClass().equals(usedTarget.getClass()) && target.getMessage().equals(usedTarget.getMessage())) {
            target.clearChosen();
            target.add(creature.getId(),game);
            break;
          }
        }
        copy.setControllerId(source.getControllerId());
        copy.setCopiedSpell(true);
        game.getStack().push(copy);
        String activateMessage=copy.getActivatedMessage(game);
        if (activateMessage.startsWith(""String_Node_Str"")) {
          activateMessage=activateMessage.substring(6);
        }
        if (!game.isSimulation()) {
          game.informPlayers(controller.getLogName() + activateMessage);
        }
      }
    }
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Spell spell=game.getStack().getSpell(targetPointer.getFirst(game,source));
  if (spell == null) {
    spell=(Spell)game.getLastKnownInformation(targetPointer.getFirst(game,source),Zone.STACK);
  }
  Player controller=game.getPlayer(source.getControllerId());
  if (spell != null && controller != null) {
    Target usedTarget=null;
    setUsedTarget:     for (    UUID modeId : spell.getSpellAbility().getModes().getSelectedModes()) {
      spell.getSpellAbility().getModes().setActiveMode(modeId);
      for (      Target target : spell.getSpellAbility().getTargets()) {
        if (target.getFirstTarget().equals(source.getSourceId())) {
          usedTarget=target.copy();
          usedTarget.clearChosen();
          break setUsedTarget;
        }
      }
    }
    if (usedTarget == null) {
      return false;
    }
    for (    Permanent creature : game.getState().getBattlefield().getAllActivePermanents(new FilterCreaturePermanent(),source.getControllerId(),game)) {
      if (!creature.getId().equals(source.getSourceId()) && usedTarget.canTarget(source.getControllerId(),creature.getId(),source,game)) {
        Spell copy=spell.copySpell();
        setTarget:         for (        UUID modeId : spell.getSpellAbility().getModes().getSelectedModes()) {
          copy.getSpellAbility().getModes().setActiveMode(modeId);
          for (          Target target : copy.getSpellAbility().getTargets()) {
            if (target.getClass().equals(usedTarget.getClass()) && target.getMessage().equals(usedTarget.getMessage())) {
              target.clearChosen();
              target.add(creature.getId(),game);
              break setTarget;
            }
          }
        }
        copy.setControllerId(source.getControllerId());
        copy.setCopiedSpell(true);
        game.getStack().push(copy);
        String activateMessage=copy.getActivatedMessage(game);
        if (activateMessage.startsWith(""String_Node_Str"")) {
          activateMessage=activateMessage.substring(6);
        }
        if (!game.isSimulation()) {
          game.informPlayers(controller.getLogName() + activateMessage);
        }
      }
    }
    return true;
  }
  return false;
}",0.8803567005201882
158771,"/** 
 * Retrieves all requirements that apply and creates a Map with blockers and attackers it contains only records if attackers can be retrieved // Map<creature that can block, Set< all attackers the creature can block and force it to block the attacker>>
 * @param attackingPlayer - attacker
 * @param game
 */
private void retrieveMustBlockAttackerRequirements(Player attackingPlayer,Game game){
  if (!game.getContinuousEffects().existRequirementEffects()) {
    return;
  }
  for (  Permanent possibleBlocker : game.getBattlefield().getActivePermanents(filterBlockers,attackingPlayer.getId(),game)) {
    for (    Map.Entry<RequirementEffect,HashSet<Ability>> requirementEntry : game.getContinuousEffects().getApplicableRequirementEffects(possibleBlocker,game).entrySet()) {
      if (requirementEntry.getKey().mustBlock(game)) {
        for (        Ability ability : requirementEntry.getValue()) {
          UUID attackingCreatureId=requirementEntry.getKey().mustBlockAttacker(ability,game);
          Player defender=game.getPlayer(possibleBlocker.getControllerId());
          if (attackingCreatureId != null && defender != null && possibleBlocker.canBlock(attackingCreatureId,game)) {
            if (game.getContinuousEffects().checkIfThereArePayCostToAttackBlockEffects(GameEvent.getEvent(GameEvent.EventType.DECLARE_BLOCKER,attackingCreatureId,possibleBlocker.getId(),possibleBlocker.getControllerId()),game)) {
              continue;
            }
            if (creatureMustBlockAttackers.containsKey(possibleBlocker.getId())) {
              creatureMustBlockAttackers.get(possibleBlocker.getId()).add(attackingCreatureId);
            }
 else {
              Set<UUID> forcingAttackers=new HashSet<>();
              forcingAttackers.add(attackingCreatureId);
              creatureMustBlockAttackers.put(possibleBlocker.getId(),forcingAttackers);
              defender.declareBlocker(defender.getId(),possibleBlocker.getId(),attackingCreatureId,game);
            }
          }
        }
      }
    }
  }
}","/** 
 * Retrieves all requirements that apply and creates a Map with blockers and attackers it contains only records if attackers can be retrieved // Map<creature that can block, Set< all attackers the creature can block and force it to block the attacker>>
 * @param attackingPlayer - attacker
 * @param game
 */
private void retrieveMustBlockAttackerRequirements(Player attackingPlayer,Game game){
  if (!game.getContinuousEffects().existRequirementEffects()) {
    return;
  }
  for (  Permanent possibleBlocker : game.getBattlefield().getActivePermanents(filterBlockers,attackingPlayer.getId(),game)) {
    for (    Map.Entry<RequirementEffect,HashSet<Ability>> requirementEntry : game.getContinuousEffects().getApplicableRequirementEffects(possibleBlocker,game).entrySet()) {
      if (requirementEntry.getKey().mustBlock(game)) {
        for (        Ability ability : requirementEntry.getValue()) {
          UUID attackingCreatureId=requirementEntry.getKey().mustBlockAttacker(ability,game);
          Player defender=game.getPlayer(possibleBlocker.getControllerId());
          if (attackingCreatureId != null && defender != null && possibleBlocker.canBlock(attackingCreatureId,game)) {
            if (game.getContinuousEffects().checkIfThereArePayCostToAttackBlockEffects(GameEvent.getEvent(GameEvent.EventType.DECLARE_BLOCKER,attackingCreatureId,possibleBlocker.getId(),possibleBlocker.getControllerId()),game)) {
              continue;
            }
            if (!getDefendingPlayerId(attackingCreatureId,game).equals(possibleBlocker.getControllerId())) {
              continue;
            }
            if (creatureMustBlockAttackers.containsKey(possibleBlocker.getId())) {
              creatureMustBlockAttackers.get(possibleBlocker.getId()).add(attackingCreatureId);
            }
 else {
              Set<UUID> forcingAttackers=new HashSet<>();
              forcingAttackers.add(attackingCreatureId);
              creatureMustBlockAttackers.put(possibleBlocker.getId(),forcingAttackers);
              defender.declareBlocker(defender.getId(),possibleBlocker.getId(),attackingCreatureId,game);
            }
          }
        }
      }
    }
  }
}",0.9650416171224732
158772,"public UUID getDefendingPlayerId(UUID attackerId,Game game){
  UUID defenderId=null;
  for (  CombatGroup group : groups) {
    if (group.getAttackers().contains(attackerId)) {
      defenderId=group.getDefenderId();
      if (group.defenderIsPlaneswalker) {
        Permanent permanent=game.getPermanent(defenderId);
        if (permanent != null) {
          defenderId=permanent.getControllerId();
        }
 else {
          defenderId=null;
        }
      }
      break;
    }
  }
  return defenderId;
}","public UUID getDefendingPlayerId(UUID attackingCreatureId,Game game){
  UUID defenderId=null;
  for (  CombatGroup group : groups) {
    if (group.getAttackers().contains(attackingCreatureId)) {
      defenderId=group.getDefenderId();
      if (group.defenderIsPlaneswalker) {
        Permanent permanent=game.getPermanent(defenderId);
        if (permanent != null) {
          defenderId=permanent.getControllerId();
        }
 else {
          defenderId=null;
        }
      }
      break;
    }
  }
  return defenderId;
}",0.974903474903475
158773,"/** 
 * 509.1c The defending player checks each creature he or she controls to see whether it's affected by any requirements (effects that say a creature must block, or that it must block if some condition is met). If the number of requirements that are being obeyed is fewer than the maximum possible number of requirements that could be obeyed without disobeying any restrictions, the declaration of blockers is illegal. If a creature can't block unless a player pays a cost, that player is not required to pay that cost, even if blocking with that creature would increase the number of requirements being obeyed. Example: A player controls one creature that ""blocks if able"" and another creature with no abilities. An effect states ""Creatures can't be blocked except by two or more creatures."" Having only the first creature block violates the restriction. Having neither creature block fulfills the restriction but not the requirement. Having both creatures block the same attacking creature fulfills both the restriction and the requirement, so that's the only option.
 * @param player
 * @param controller
 * @param game
 * @return
 */
public boolean checkBlockRequirementsAfter(Player player,Player controller,Game game){
  Set<UUID> opponents=game.getOpponents(attackerId);
  Map<UUID,Set<UUID>> mustBeBlockedByAtLeastOne=new HashMap<>();
  for (  Permanent creature : game.getBattlefield().getActivePermanents(new FilterControlledCreaturePermanent(),player.getId(),game)) {
    if (opponents.contains(creature.getControllerId())) {
      if (creature.getBlocking() > 0) {
        for (        Map.Entry<RequirementEffect,HashSet<Ability>> entry : game.getContinuousEffects().getApplicableRequirementEffects(creature,game).entrySet()) {
          RequirementEffect effect=entry.getKey();
          for (          Ability ability : entry.getValue()) {
            UUID toBeBlockedCreature=effect.mustBlockAttackerIfElseUnblocked(ability,game);
            if (toBeBlockedCreature != null) {
              Set<UUID> potentialBlockers;
              if (mustBeBlockedByAtLeastOne.containsKey(toBeBlockedCreature)) {
                potentialBlockers=mustBeBlockedByAtLeastOne.get(toBeBlockedCreature);
              }
 else {
                potentialBlockers=new HashSet<>();
                mustBeBlockedByAtLeastOne.put(toBeBlockedCreature,potentialBlockers);
              }
              potentialBlockers.add(creature.getId());
            }
          }
        }
      }
      if (creature.getBlocking() == 0) {
        for (        Map.Entry<RequirementEffect,HashSet<Ability>> entry : game.getContinuousEffects().getApplicableRequirementEffects(creature,game).entrySet()) {
          RequirementEffect effect=entry.getKey();
          for (          Ability ability : entry.getValue()) {
            UUID toBeBlockedCreature=effect.mustBlockAttackerIfElseUnblocked(ability,game);
            if (toBeBlockedCreature != null) {
              Set<UUID> potentialBlockers;
              if (mustBeBlockedByAtLeastOne.containsKey(toBeBlockedCreature)) {
                potentialBlockers=mustBeBlockedByAtLeastOne.get(toBeBlockedCreature);
              }
 else {
                potentialBlockers=new HashSet<>();
                mustBeBlockedByAtLeastOne.put(toBeBlockedCreature,potentialBlockers);
              }
              potentialBlockers.add(creature.getId());
            }
          }
          if (effect.mustBlockAny(game)) {
            boolean mayBlock=false;
            for (            UUID attackingCreatureId : getAttackers()) {
              if (creature.canBlock(attackingCreatureId,game)) {
                Permanent attackingCreature=game.getPermanent(attackingCreatureId);
                if (attackingCreature != null) {
                  if (attackingCreature.getMaxBlockedBy() != 0) {
                    int alreadyBlockingCreatures=0;
                    for (                    CombatGroup group : getGroups()) {
                      if (group.getAttackers().contains(attackingCreatureId)) {
                        alreadyBlockingCreatures=group.getBlockers().size();
                        break;
                      }
                    }
                    if (attackingCreature.getMaxBlockedBy() <= alreadyBlockingCreatures) {
                      continue;
                    }
                  }
                  if (attackingCreature.getMinBlockedBy() > 1) {
                  }
 else {
                    mayBlock=true;
                    break;
                  }
                }
              }
            }
            if (mayBlock) {
              if (controller.isHuman()) {
                if (!game.isSimulation()) {
                  game.informPlayer(controller,""String_Node_Str"" + creature.getLogName());
                }
              }
 else {
                Player defender=game.getPlayer(creature.getControllerId());
                if (defender != null) {
                  for (                  UUID attackingCreatureId : getAttackers()) {
                    if (creature.canBlock(attackingCreatureId,game)) {
                      defender.declareBlocker(defender.getId(),creature.getId(),attackingCreatureId,game);
                      break;
                    }
                  }
                }
              }
              return false;
            }
          }
        }
      }
    }
  }
  for (  UUID toBeBlockedCreatureId : mustBeBlockedByAtLeastOne.keySet()) {
    for (    CombatGroup combatGroup : game.getCombat().getGroups()) {
      if (combatGroup.getBlockers().isEmpty() && combatGroup.getAttackers().contains(toBeBlockedCreatureId)) {
        if (controller.isHuman()) {
          Permanent toBeBlockedCreature=game.getPermanent(toBeBlockedCreatureId);
          if (toBeBlockedCreature != null) {
            for (            UUID possibleBlockerId : mustBeBlockedByAtLeastOne.get(toBeBlockedCreatureId)) {
              String blockRequiredMessage=isCreatureDoingARequiredBlock(possibleBlockerId,mustBeBlockedByAtLeastOne,game);
              if (blockRequiredMessage != null) {
                game.informPlayer(controller,blockRequiredMessage + ""String_Node_Str"" + toBeBlockedCreature.getIdName());
                return false;
              }
            }
          }
        }
 else {
          for (          UUID possibleBlockerId : mustBeBlockedByAtLeastOne.get(toBeBlockedCreatureId)) {
            String blockRequiredMessage=isCreatureDoingARequiredBlock(possibleBlockerId,mustBeBlockedByAtLeastOne,game);
            if (blockRequiredMessage != null) {
              Permanent possibleBlocker=game.getPermanent(possibleBlockerId);
              Player defender=game.getPlayer(possibleBlocker.getControllerId());
              if (defender != null) {
                defender.declareBlocker(defender.getId(),possibleBlockerId,toBeBlockedCreatureId,game);
              }
              break;
            }
          }
        }
      }
    }
  }
  StringBuilder sb=new StringBuilder();
  for (  Map.Entry<UUID,Set<UUID>> entry : creatureMustBlockAttackers.entrySet()) {
    boolean blockIsValid;
    Permanent creatureForcedToBlock=game.getPermanent(entry.getKey());
    if (creatureForcedToBlock == null) {
      break;
    }
    if (creatureForcedToBlock.getBlocking() == 0) {
      blockIsValid=false;
    }
 else {
      blockIsValid=false;
      CombatGroups:       for (      CombatGroup combatGroup : game.getCombat().getGroups()) {
        if (combatGroup.getBlockers().contains(creatureForcedToBlock.getId())) {
          for (          UUID forcingAttackerId : combatGroup.getAttackers()) {
            if (entry.getValue().contains(forcingAttackerId)) {
              blockIsValid=true;
              break CombatGroups;
            }
 else {
              if (combatGroup.getBlockers().size() == 1) {
                if (mustBeBlockedByAtLeastOne.containsKey(forcingAttackerId)) {
                  if (mustBeBlockedByAtLeastOne.get(forcingAttackerId).contains(creatureForcedToBlock.getId())) {
                    blockIsValid=true;
                    break CombatGroups;
                  }
                }
              }
            }
          }
        }
      }
    }
    if (!blockIsValid) {
      sb.append(""String_Node_Str"").append(creatureForcedToBlock.getIdName());
    }
  }
  if (sb.length() > 0) {
    if (!game.isSimulation()) {
      sb.insert(0,""String_Node_Str"");
      sb.append(""String_Node_Str"");
      game.informPlayer(controller,sb.toString());
    }
    return false;
  }
  return true;
}","/** 
 * 509.1c The defending player checks each creature he or she controls to see whether it's affected by any requirements (effects that say a creature must block, or that it must block if some condition is met). If the number of requirements that are being obeyed is fewer than the maximum possible number of requirements that could be obeyed without disobeying any restrictions, the declaration of blockers is illegal. If a creature can't block unless a player pays a cost, that player is not required to pay that cost, even if blocking with that creature would increase the number of requirements being obeyed. Example: A player controls one creature that ""blocks if able"" and another creature with no abilities. An effect states ""Creatures can't be blocked except by two or more creatures."" Having only the first creature block violates the restriction. Having neither creature block fulfills the restriction but not the requirement. Having both creatures block the same attacking creature fulfills both the restriction and the requirement, so that's the only option.
 * @param player
 * @param controller
 * @param game
 * @return
 */
public boolean checkBlockRequirementsAfter(Player player,Player controller,Game game){
  Set<UUID> opponents=game.getOpponents(attackerId);
  Map<UUID,Set<UUID>> mustBeBlockedByAtLeastOne=new HashMap<>();
  for (  Permanent creature : game.getBattlefield().getActivePermanents(new FilterControlledCreaturePermanent(),player.getId(),game)) {
    if (opponents.contains(creature.getControllerId())) {
      if (creature.getBlocking() > 0) {
        for (        Map.Entry<RequirementEffect,HashSet<Ability>> entry : game.getContinuousEffects().getApplicableRequirementEffects(creature,game).entrySet()) {
          RequirementEffect effect=entry.getKey();
          for (          Ability ability : entry.getValue()) {
            UUID toBeBlockedCreature=effect.mustBlockAttackerIfElseUnblocked(ability,game);
            if (toBeBlockedCreature != null) {
              Set<UUID> potentialBlockers;
              if (mustBeBlockedByAtLeastOne.containsKey(toBeBlockedCreature)) {
                potentialBlockers=mustBeBlockedByAtLeastOne.get(toBeBlockedCreature);
              }
 else {
                potentialBlockers=new HashSet<>();
                mustBeBlockedByAtLeastOne.put(toBeBlockedCreature,potentialBlockers);
              }
              potentialBlockers.add(creature.getId());
            }
          }
        }
      }
      if (creature.getBlocking() == 0) {
        for (        Map.Entry<RequirementEffect,HashSet<Ability>> entry : game.getContinuousEffects().getApplicableRequirementEffects(creature,game).entrySet()) {
          RequirementEffect effect=entry.getKey();
          for (          Ability ability : entry.getValue()) {
            UUID toBeBlockedCreature=effect.mustBlockAttackerIfElseUnblocked(ability,game);
            if (toBeBlockedCreature != null) {
              Set<UUID> potentialBlockers;
              if (mustBeBlockedByAtLeastOne.containsKey(toBeBlockedCreature)) {
                potentialBlockers=mustBeBlockedByAtLeastOne.get(toBeBlockedCreature);
              }
 else {
                potentialBlockers=new HashSet<>();
                mustBeBlockedByAtLeastOne.put(toBeBlockedCreature,potentialBlockers);
              }
              potentialBlockers.add(creature.getId());
            }
          }
          if (effect.mustBlockAny(game)) {
            boolean mayBlock=false;
            for (            UUID attackingCreatureId : getAttackers()) {
              if (creature.canBlock(attackingCreatureId,game)) {
                Permanent attackingCreature=game.getPermanent(attackingCreatureId);
                if (attackingCreature != null) {
                  if (attackingCreature.getMaxBlockedBy() != 0) {
                    int alreadyBlockingCreatures=0;
                    for (                    CombatGroup group : getGroups()) {
                      if (group.getAttackers().contains(attackingCreatureId)) {
                        alreadyBlockingCreatures=group.getBlockers().size();
                        break;
                      }
                    }
                    if (attackingCreature.getMaxBlockedBy() <= alreadyBlockingCreatures) {
                      continue;
                    }
                  }
                  if (attackingCreature.getMinBlockedBy() > 1) {
                  }
 else {
                    mayBlock=true;
                    break;
                  }
                }
              }
            }
            if (mayBlock) {
              if (controller.isHuman()) {
                if (!game.isSimulation()) {
                  game.informPlayer(controller,""String_Node_Str"" + creature.getLogName());
                }
              }
 else {
                Player defender=game.getPlayer(creature.getControllerId());
                if (defender != null) {
                  for (                  UUID attackingCreatureId : getAttackers()) {
                    if (creature.canBlock(attackingCreatureId,game)) {
                      defender.declareBlocker(defender.getId(),creature.getId(),attackingCreatureId,game);
                      break;
                    }
                  }
                }
              }
              return false;
            }
          }
        }
      }
    }
  }
  for (  UUID toBeBlockedCreatureId : mustBeBlockedByAtLeastOne.keySet()) {
    for (    CombatGroup combatGroup : game.getCombat().getGroups()) {
      if (combatGroup.getBlockers().isEmpty() && combatGroup.getAttackers().contains(toBeBlockedCreatureId)) {
        if (controller.isHuman()) {
          Permanent toBeBlockedCreature=game.getPermanent(toBeBlockedCreatureId);
          if (toBeBlockedCreature != null) {
            for (            UUID possibleBlockerId : mustBeBlockedByAtLeastOne.get(toBeBlockedCreatureId)) {
              String blockRequiredMessage=isCreatureDoingARequiredBlock(possibleBlockerId,mustBeBlockedByAtLeastOne,game);
              if (blockRequiredMessage != null) {
                game.informPlayer(controller,blockRequiredMessage + ""String_Node_Str"" + toBeBlockedCreature.getIdName());
                return false;
              }
            }
          }
        }
 else {
          for (          UUID possibleBlockerId : mustBeBlockedByAtLeastOne.get(toBeBlockedCreatureId)) {
            String blockRequiredMessage=isCreatureDoingARequiredBlock(possibleBlockerId,mustBeBlockedByAtLeastOne,game);
            if (blockRequiredMessage != null) {
              Permanent possibleBlocker=game.getPermanent(possibleBlockerId);
              Player defender=game.getPlayer(possibleBlocker.getControllerId());
              if (defender != null) {
                defender.declareBlocker(defender.getId(),possibleBlockerId,toBeBlockedCreatureId,game);
              }
              break;
            }
          }
        }
      }
    }
  }
  StringBuilder sb=new StringBuilder();
  for (  Map.Entry<UUID,Set<UUID>> entry : creatureMustBlockAttackers.entrySet()) {
    boolean blockIsValid;
    Permanent creatureForcedToBlock=game.getPermanent(entry.getKey());
    if (creatureForcedToBlock == null) {
      break;
    }
    if (!creatureForcedToBlock.getControllerId().equals(player.getId())) {
      continue;
    }
    if (creatureForcedToBlock.getBlocking() == 0) {
      blockIsValid=false;
    }
 else {
      blockIsValid=false;
      CombatGroups:       for (      CombatGroup combatGroup : game.getCombat().getGroups()) {
        if (combatGroup.getBlockers().contains(creatureForcedToBlock.getId())) {
          for (          UUID forcingAttackerId : combatGroup.getAttackers()) {
            if (entry.getValue().contains(forcingAttackerId)) {
              blockIsValid=true;
              break CombatGroups;
            }
 else {
              if (combatGroup.getBlockers().size() == 1) {
                if (mustBeBlockedByAtLeastOne.containsKey(forcingAttackerId)) {
                  if (mustBeBlockedByAtLeastOne.get(forcingAttackerId).contains(creatureForcedToBlock.getId())) {
                    blockIsValid=true;
                    break CombatGroups;
                  }
                }
              }
            }
          }
        }
      }
    }
    if (!blockIsValid) {
      sb.append(""String_Node_Str"").append(creatureForcedToBlock.getIdName());
    }
  }
  if (sb.length() > 0) {
    if (!game.isSimulation()) {
      sb.insert(0,""String_Node_Str"");
      sb.append(""String_Node_Str"");
      game.informPlayer(controller,sb.toString());
    }
    return false;
  }
  return true;
}",0.9943653790299156
158774,"@Override public boolean apply(Game game,Ability source){
  StackObject stackObject=game.getStack().getStackObject(source.getFirstTarget());
  MageObject sourceObject=game.getObject(source.getSourceId());
  if (stackObject != null && sourceObject != null) {
    Targets targets=new Targets();
    Ability sourceAbility;
    MageObject oldTarget=null;
    if (stackObject instanceof Spell) {
      Spell spell=(Spell)stackObject;
      sourceAbility=spell.getSpellAbility();
    }
 else     if (stackObject instanceof StackAbility) {
      StackAbility stackAbility=(StackAbility)stackObject;
      sourceAbility=stackAbility;
    }
 else {
      return false;
    }
    for (    UUID modeId : sourceAbility.getModes().getSelectedModes()) {
      sourceAbility.getModes().setActiveMode(modeId);
      targets.addAll(sourceAbility.getTargets());
    }
    boolean twoTimesTarget=false;
    if (targets.size() == 1 && targets.get(0).getTargets().size() == 1) {
      Target target=targets.get(0);
      if (target.canTarget(stackObject.getControllerId(),source.getSourceId(),sourceAbility,game)) {
        oldTarget=game.getObject(targets.getFirstTarget());
        target.clearChosen();
        target.addTarget(source.getSourceId(),stackObject.getStackAbility(),game);
      }
    }
 else {
      Player controller=game.getPlayer(source.getControllerId());
      boolean validTargets=false;
      do {
        for (        Target target : targets) {
          for (          UUID targetId : target.getTargets()) {
            MageObject object=game.getObject(targetId);
            String name;
            if (object == null) {
              Player targetPlayer=game.getPlayer(targetId);
              name=targetPlayer.getLogName();
            }
 else {
              name=object.getLogName();
            }
            if (!targetId.equals(source.getSourceId()) && target.getTargets().contains(source.getSourceId())) {
              twoTimesTarget=true;
              continue;
            }
            if (target.canTarget(stackObject.getControllerId(),source.getSourceId(),sourceAbility,game)) {
              validTargets=true;
              if (name != null && controller.chooseUse(Outcome.Neutral,""String_Node_Str"" + name + ""String_Node_Str""+ sourceObject.getLogName()+ ""String_Node_Str"",source,game)) {
                oldTarget=game.getObject(targetId);
                target.remove(targetId);
                target.addTarget(source.getSourceId(),stackObject.getStackAbility(),game);
                break;
              }
            }
          }
          if (oldTarget != null) {
            break;
          }
        }
        if (oldTarget == null) {
          game.informPlayer(controller,""String_Node_Str"");
        }
      }
 while (validTargets && oldTarget == null);
    }
    if (oldTarget != null) {
      game.informPlayers(sourceObject.getLogName() + ""String_Node_Str"" + stackObject.getLogName()+ ""String_Node_Str""+ oldTarget.getLogName()+ ""String_Node_Str""+ sourceObject.getLogName());
    }
 else {
      if (twoTimesTarget) {
        game.informPlayers(sourceObject.getLogName() + ""String_Node_Str"" + sourceObject.getLogName()+ ""String_Node_Str""+ stackObject.getLogName());
      }
 else {
        game.informPlayers(sourceObject.getLogName() + ""String_Node_Str"" + sourceObject.getLogName()+ ""String_Node_Str""+ stackObject.getLogName());
      }
    }
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  StackObject stackObject=game.getStack().getStackObject(source.getFirstTarget());
  MageObject sourceObject=game.getObject(source.getSourceId());
  if (stackObject != null && sourceObject != null) {
    Targets targets=new Targets();
    Ability sourceAbility;
    String oldTargetName=null;
    if (stackObject instanceof Spell) {
      Spell spell=(Spell)stackObject;
      sourceAbility=spell.getSpellAbility();
    }
 else     if (stackObject instanceof StackAbility) {
      StackAbility stackAbility=(StackAbility)stackObject;
      sourceAbility=stackAbility;
    }
 else {
      return false;
    }
    for (    UUID modeId : sourceAbility.getModes().getSelectedModes()) {
      sourceAbility.getModes().setActiveMode(modeId);
      targets.addAll(sourceAbility.getTargets());
    }
    boolean twoTimesTarget=false;
    if (targets.size() == 1 && targets.get(0).getTargets().size() == 1) {
      Target target=targets.get(0);
      if (target.canTarget(stackObject.getControllerId(),source.getSourceId(),sourceAbility,game)) {
        oldTargetName=getTargetName(targets.getFirstTarget(),game);
        target.clearChosen();
        target.addTarget(source.getSourceId(),stackObject.getStackAbility(),game);
      }
    }
 else {
      Player controller=game.getPlayer(source.getControllerId());
      boolean validTargets=false;
      do {
        for (        Target target : targets) {
          for (          UUID targetId : target.getTargets()) {
            String name=getTargetName(targets.getFirstTarget(),game);
            if (!targetId.equals(source.getSourceId()) && target.getTargets().contains(source.getSourceId())) {
              twoTimesTarget=true;
              continue;
            }
            if (target.canTarget(stackObject.getControllerId(),source.getSourceId(),sourceAbility,game)) {
              validTargets=true;
              if (name != null && controller.chooseUse(Outcome.Neutral,""String_Node_Str"" + name + ""String_Node_Str""+ sourceObject.getLogName()+ ""String_Node_Str"",source,game)) {
                oldTargetName=getTargetName(targetId,game);
                target.remove(targetId);
                target.addTarget(source.getSourceId(),stackObject.getStackAbility(),game);
                break;
              }
            }
          }
          if (oldTargetName != null) {
            break;
          }
        }
        if (oldTargetName == null) {
          game.informPlayer(controller,""String_Node_Str"");
        }
      }
 while (validTargets && oldTargetName == null);
    }
    if (oldTargetName != null) {
      game.informPlayers(sourceObject.getLogName() + ""String_Node_Str"" + stackObject.getLogName()+ ""String_Node_Str""+ oldTargetName+ ""String_Node_Str""+ sourceObject.getLogName());
    }
 else {
      if (twoTimesTarget) {
        game.informPlayers(sourceObject.getLogName() + ""String_Node_Str"" + sourceObject.getLogName()+ ""String_Node_Str""+ stackObject.getLogName());
      }
 else {
        game.informPlayers(sourceObject.getLogName() + ""String_Node_Str"" + sourceObject.getLogName()+ ""String_Node_Str""+ stackObject.getLogName());
      }
    }
    return true;
  }
  return false;
}",0.5442771084337349
158775,"@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller == null) {
    return false;
  }
  int value=amount.calculate(game,source,this);
  boolean result=false;
  ChoiceColor choice=new ChoiceColor();
  for (int i=0; i < value; i++) {
    if (!choice.isChosen()) {
      if (!controller.choose(outcome,choice,game)) {
        return false;
      }
    }
    Mana mana=null;
    if (choice.getColor().isBlack()) {
      mana=manaBuilder.setMana(Mana.BlackMana(1),source,game).build();
    }
 else     if (choice.getColor().isBlue()) {
      mana=manaBuilder.setMana(Mana.BlueMana(1),source,game).build();
    }
 else     if (choice.getColor().isRed()) {
      mana=manaBuilder.setMana(Mana.RedMana(1),source,game).build();
    }
 else     if (choice.getColor().isGreen()) {
      mana=manaBuilder.setMana(Mana.GreenMana(1),source,game).build();
    }
 else     if (choice.getColor().isWhite()) {
      mana=manaBuilder.setMana(Mana.WhiteMana(1),source,game).build();
    }
    if (mana != null) {
      checkToFirePossibleEvents(mana,game,source);
      controller.getManaPool().addMana(mana,game,source);
      result=true;
    }
    if (!oneChoice) {
      choice.clearChoice();
    }
  }
  return result;
}","@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller == null) {
    return false;
  }
  int value=amount.calculate(game,source,this);
  boolean result=false;
  ChoiceColor choice=new ChoiceColor(false);
  for (int i=0; i < value; i++) {
    if (!choice.isChosen()) {
      if (!controller.choose(outcome,choice,game)) {
        return false;
      }
    }
    Mana mana=null;
    if (choice.getColor().isBlack()) {
      mana=manaBuilder.setMana(Mana.BlackMana(1),source,game).build();
    }
 else     if (choice.getColor().isBlue()) {
      mana=manaBuilder.setMana(Mana.BlueMana(1),source,game).build();
    }
 else     if (choice.getColor().isRed()) {
      mana=manaBuilder.setMana(Mana.RedMana(1),source,game).build();
    }
 else     if (choice.getColor().isGreen()) {
      mana=manaBuilder.setMana(Mana.GreenMana(1),source,game).build();
    }
 else     if (choice.getColor().isWhite()) {
      mana=manaBuilder.setMana(Mana.WhiteMana(1),source,game).build();
    }
    if (mana != null) {
      checkToFirePossibleEvents(mana,game,source);
      controller.getManaPool().addMana(mana,game,source);
      result=true;
    }
    if (!oneChoice) {
      choice.clearChoice();
    }
  }
  return result;
}",0.9980642663569492
158776,"/** 
 * Execute action.
 * @param game Game context.
 */
public abstract int doAction(final Game game);","/** 
 * Execute action.
 * @param game Game context.
 * @return
 */
public abstract int doAction(final Game game);",0.9493087557603688
158777,"/** 
 * Set or change action score.
 * @param scorePlayer Set player.
 * @param score       Set score value.
 */
protected void setScore(Player scorePlayer,int score){
  this.scorePlayer=scorePlayer;
  this.score=score;
}","/** 
 * Set or change action score.
 * @param scorePlayer Set player.
 * @param score Set score value.
 */
protected void setScore(Player scorePlayer,int score){
  this.scorePlayer=scorePlayer;
  this.score=score;
}",0.9862385321100916
158778,"@Override public synchronized void concede(UUID playerId){
  Player player=state.getPlayer(playerId);
  if (player != null) {
    logger.debug(new StringBuilder(""String_Node_Str"").append(player.getName()).append(""String_Node_Str"").append(this.getId()));
    fireInformEvent(player.getLogName() + ""String_Node_Str"");
    player.concede(this);
  }
}","@Override public synchronized void concede(UUID playerId){
  Player player=state.getPlayer(playerId);
  if (player != null) {
    logger.debug(""String_Node_Str"" + player.getName() + ""String_Node_Str""+ this.getId());
    fireInformEvent(player.getLogName() + ""String_Node_Str"");
    player.concede(this);
  }
}",0.8140243902439024
158779,"protected boolean specialAction(SpecialAction action,Game game){
  if (!game.replaceEvent(GameEvent.getEvent(GameEvent.EventType.ACTIVATE_ABILITY,action.getSourceId(),action.getId(),playerId))) {
    int bookmark=game.bookmarkState();
    if (action.activate(game,false)) {
      game.fireEvent(GameEvent.getEvent(GameEvent.EventType.ACTIVATED_ABILITY,action.getSourceId(),action.getId(),playerId));
      if (!game.isSimulation()) {
        game.informPlayers(getLogName() + action.getGameLogMessage(game));
      }
      if (action.resolve(game)) {
        game.removeBookmark(bookmark);
        resetStoredBookmark(game);
        return true;
      }
    }
    game.restoreState(bookmark,action.getRule());
  }
  return false;
}","protected boolean specialAction(SpecialAction action,Game game){
  if (!game.replaceEvent(GameEvent.getEvent(GameEvent.EventType.ACTIVATE_ABILITY,action.getSourceId(),action.getId(),playerId))) {
    int bookmark=game.bookmarkState();
    if (action.activate(game,false)) {
      game.fireEvent(GameEvent.getEvent(GameEvent.EventType.ACTIVATED_ABILITY,action.getSourceId(),action.getId(),playerId));
      if (!game.isSimulation()) {
        game.informPlayers(getLogName() + action.getGameLogMessage(game));
      }
      if (action.resolve(game)) {
        game.removeBookmark(bookmark);
        resetStoredBookmark(game);
        return true;
      }
    }
    restoreState(bookmark,action.getRule(),game);
  }
  return false;
}",0.9931600547195624
158780,"@Override public boolean cast(SpellAbility ability,Game game,boolean noMana){
  if (!ability.getSpellAbilityType().equals(SpellAbilityType.BASE)) {
    ability=chooseSpellAbilityForCast(ability,game,noMana);
  }
  Card card=game.getCard(ability.getSourceId());
  if (card != null) {
    if (!game.replaceEvent(GameEvent.getEvent(GameEvent.EventType.CAST_SPELL,ability.getId(),ability.getSourceId(),playerId))) {
      int bookmark=game.bookmarkState();
      Zone fromZone=game.getState().getZone(card.getMainCard().getId());
      card.cast(game,fromZone,ability,playerId);
      Spell spell=game.getStack().getSpell(ability.getId());
      if (ability.getSourceId().equals(getCastSourceIdWithAlternateMana())) {
        ManaCosts alternateCosts=getCastSourceIdManaCosts();
        Ability spellAbility=spell.getSpellAbility();
        if (alternateCosts == null) {
          noMana=true;
        }
 else {
          spellAbility.getManaCosts().clear();
          spellAbility.getManaCosts().add(alternateCosts.copy());
          spellAbility.getManaCostsToPay().clear();
          spellAbility.getManaCostsToPay().add(alternateCosts.copy());
        }
      }
      setCastSourceIdWithAlternateMana(null,null);
      GameEvent event=GameEvent.getEvent(GameEvent.EventType.CAST_SPELL,spell.getSpellAbility().getId(),spell.getSpellAbility().getSourceId(),playerId);
      game.fireEvent(event);
      if (spell.activate(game,noMana)) {
        event=GameEvent.getEvent(GameEvent.EventType.SPELL_CAST,spell.getSpellAbility().getId(),spell.getSpellAbility().getSourceId(),playerId);
        event.setZone(fromZone);
        game.fireEvent(event);
        if (!game.isSimulation()) {
          game.informPlayers(getLogName() + spell.getActivatedMessage(game));
        }
        game.removeBookmark(bookmark);
        resetStoredBookmark(game);
        return true;
      }
      game.restoreState(bookmark,ability.getRule());
    }
  }
  return false;
}","@Override public boolean cast(SpellAbility ability,Game game,boolean noMana){
  if (!ability.getSpellAbilityType().equals(SpellAbilityType.BASE)) {
    ability=chooseSpellAbilityForCast(ability,game,noMana);
  }
  Card card=game.getCard(ability.getSourceId());
  if (card != null) {
    if (!game.replaceEvent(GameEvent.getEvent(GameEvent.EventType.CAST_SPELL,ability.getId(),ability.getSourceId(),playerId))) {
      int bookmark=game.bookmarkState();
      Zone fromZone=game.getState().getZone(card.getMainCard().getId());
      card.cast(game,fromZone,ability,playerId);
      Spell spell=game.getStack().getSpell(ability.getId());
      if (ability.getSourceId().equals(getCastSourceIdWithAlternateMana())) {
        ManaCosts alternateCosts=getCastSourceIdManaCosts();
        Ability spellAbility=spell.getSpellAbility();
        if (alternateCosts == null) {
          noMana=true;
        }
 else {
          spellAbility.getManaCosts().clear();
          spellAbility.getManaCosts().add(alternateCosts.copy());
          spellAbility.getManaCostsToPay().clear();
          spellAbility.getManaCostsToPay().add(alternateCosts.copy());
        }
      }
      setCastSourceIdWithAlternateMana(null,null);
      GameEvent event=GameEvent.getEvent(GameEvent.EventType.CAST_SPELL,spell.getSpellAbility().getId(),spell.getSpellAbility().getSourceId(),playerId);
      game.fireEvent(event);
      if (spell.activate(game,noMana)) {
        event=GameEvent.getEvent(GameEvent.EventType.SPELL_CAST,spell.getSpellAbility().getId(),spell.getSpellAbility().getSourceId(),playerId);
        event.setZone(fromZone);
        game.fireEvent(event);
        if (!game.isSimulation()) {
          game.informPlayers(getLogName() + spell.getActivatedMessage(game));
        }
        game.removeBookmark(bookmark);
        resetStoredBookmark(game);
        return true;
      }
      restoreState(bookmark,ability.getRule(),game);
    }
  }
  return false;
}",0.997438524590164
158781,"protected boolean playManaAbility(ManaAbility ability,Game game){
  if (!game.replaceEvent(GameEvent.getEvent(GameEvent.EventType.ACTIVATE_ABILITY,ability.getId(),ability.getSourceId(),playerId))) {
    int bookmark=game.bookmarkState();
    if (ability.activate(game,false)) {
      if (ability.resolve(game)) {
        if (ability.isUndoPossible() && (storedBookmark == -1 || storedBookmark > bookmark)) {
          setStoredBookmark(bookmark);
        }
 else {
          resetStoredBookmark(game);
        }
        return true;
      }
    }
    game.restoreState(bookmark,ability.getRule());
  }
  return false;
}","protected boolean playManaAbility(ManaAbility ability,Game game){
  if (!game.replaceEvent(GameEvent.getEvent(GameEvent.EventType.ACTIVATE_ABILITY,ability.getId(),ability.getSourceId(),playerId))) {
    int bookmark=game.bookmarkState();
    if (ability.activate(game,false)) {
      if (ability.resolve(game)) {
        if (ability.isUndoPossible()) {
          if (storedBookmark == -1 || storedBookmark > bookmark) {
            setStoredBookmark(bookmark);
          }
        }
 else {
          resetStoredBookmark(game);
        }
        return true;
      }
    }
    restoreState(bookmark,ability.getRule(),game);
  }
  return false;
}",0.9651898734177216
158782,"protected boolean playAbility(ActivatedAbility ability,Game game){
  if (ability.isUsesStack()) {
    if (!game.replaceEvent(GameEvent.getEvent(GameEvent.EventType.ACTIVATE_ABILITY,ability.getId(),ability.getSourceId(),playerId))) {
      int bookmark=game.bookmarkState();
      ability.newId();
      game.getStack().push(new StackAbility(ability,playerId));
      if (ability.activate(game,false)) {
        game.fireEvent(GameEvent.getEvent(GameEvent.EventType.ACTIVATED_ABILITY,ability.getId(),ability.getSourceId(),playerId));
        if (!game.isSimulation()) {
          game.informPlayers(getLogName() + ability.getGameLogMessage(game));
        }
        game.removeBookmark(bookmark);
        resetStoredBookmark(game);
        return true;
      }
      game.restoreState(bookmark,ability.getRule());
    }
  }
 else {
    int bookmark=game.bookmarkState();
    if (ability.activate(game,false)) {
      ability.resolve(game);
      game.removeBookmark(bookmark);
      resetStoredBookmark(game);
      return true;
    }
    game.restoreState(bookmark,ability.getRule());
  }
  return false;
}","protected boolean playAbility(ActivatedAbility ability,Game game){
  if (ability.isUsesStack()) {
    if (!game.replaceEvent(GameEvent.getEvent(GameEvent.EventType.ACTIVATE_ABILITY,ability.getId(),ability.getSourceId(),playerId))) {
      int bookmark=game.bookmarkState();
      ability.newId();
      game.getStack().push(new StackAbility(ability,playerId));
      if (ability.activate(game,false)) {
        game.fireEvent(GameEvent.getEvent(GameEvent.EventType.ACTIVATED_ABILITY,ability.getId(),ability.getSourceId(),playerId));
        if (!game.isSimulation()) {
          game.informPlayers(getLogName() + ability.getGameLogMessage(game));
        }
        game.removeBookmark(bookmark);
        resetStoredBookmark(game);
        return true;
      }
      restoreState(bookmark,ability.getRule(),game);
    }
  }
 else {
    int bookmark=game.bookmarkState();
    if (ability.activate(game,false)) {
      ability.resolve(game);
      game.removeBookmark(bookmark);
      resetStoredBookmark(game);
      return true;
    }
    restoreState(bookmark,ability.getRule(),game);
  }
  return false;
}",0.9909584086799276
158783,"@Override public boolean triggerAbility(TriggeredAbility source,Game game){
  if (source == null) {
    logger.warn(""String_Node_Str"");
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  int bookmark=game.bookmarkState();
  TriggeredAbility ability=source.copy();
  MageObject sourceObject=ability.getSourceObject(game);
  if (sourceObject != null) {
    sourceObject.adjustTargets(ability,game);
  }
  if (ability.canChooseTarget(game)) {
    if (ability.isUsesStack()) {
      game.getStack().push(new StackAbility(ability,playerId));
    }
    if (ability.activate(game,false)) {
      if ((ability.isUsesStack() || ability.getRuleVisible()) && !game.isSimulation()) {
        game.informPlayers(ability.getGameLogMessage(game));
      }
      if (!ability.isUsesStack()) {
        ability.resolve(game);
      }
      game.removeBookmark(bookmark);
      return true;
    }
  }
  game.restoreState(bookmark,source.getRule());
  return false;
}","@Override public boolean triggerAbility(TriggeredAbility source,Game game){
  if (source == null) {
    logger.warn(""String_Node_Str"");
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  int bookmark=game.bookmarkState();
  TriggeredAbility ability=source.copy();
  MageObject sourceObject=ability.getSourceObject(game);
  if (sourceObject != null) {
    sourceObject.adjustTargets(ability,game);
  }
  if (ability.canChooseTarget(game)) {
    if (ability.isUsesStack()) {
      game.getStack().push(new StackAbility(ability,playerId));
    }
    if (ability.activate(game,false)) {
      if ((ability.isUsesStack() || ability.getRuleVisible()) && !game.isSimulation()) {
        game.informPlayers(ability.getGameLogMessage(game));
      }
      if (!ability.isUsesStack()) {
        ability.resolve(game);
      }
      game.removeBookmark(bookmark);
      return true;
    }
  }
  restoreState(bookmark,source.getRule(),game);
  return false;
}",0.9947970863683664
158784,"@Override public boolean activateAbility(ActivatedAbility ability,Game game){
  boolean result;
  if (ability instanceof PassAbility) {
    pass(game);
    return true;
  }
  if (ability instanceof PlayLandAbility) {
    Card card=game.getCard(ability.getSourceId());
    result=playLand(card,game);
  }
 else {
    if (!ability.canActivate(this.playerId,game)) {
      return false;
    }
    if (ability.getAbilityType().equals(AbilityType.SPECIAL_ACTION)) {
      result=specialAction((SpecialAction)ability.copy(),game);
    }
 else     if (ability.getAbilityType().equals(AbilityType.MANA)) {
      result=playManaAbility((ManaAbility)ability.copy(),game);
    }
 else     if (ability.getAbilityType().equals(AbilityType.SPELL)) {
      if (ability instanceof FlashbackAbility) {
        result=playAbility(ability.copy(),game);
      }
 else {
        result=cast((SpellAbility)ability,game,false);
      }
    }
 else {
      result=playAbility(ability.copy(),game);
    }
  }
  justActivatedType=null;
  if (result) {
    if (isHuman() && (ability.getAbilityType().equals(AbilityType.SPELL) || ability.getAbilityType().equals(AbilityType.ACTIVATED))) {
      setJustActivatedType(ability.getAbilityType());
    }
    game.getPlayers().resetPassed();
  }
  return result;
}","@Override public boolean activateAbility(ActivatedAbility ability,Game game){
  boolean result;
  if (ability instanceof PassAbility) {
    pass(game);
    return true;
  }
  if (ability instanceof PlayLandAbility) {
    Card card=game.getCard(ability.getSourceId());
    result=playLand(card,game);
  }
 else {
    if (!ability.canActivate(this.playerId,game)) {
      return false;
    }
    if (ability.getAbilityType().equals(AbilityType.SPECIAL_ACTION)) {
      result=specialAction((SpecialAction)ability.copy(),game);
    }
 else     if (ability.getAbilityType().equals(AbilityType.MANA)) {
      result=playManaAbility((ManaAbility)ability.copy(),game);
    }
 else     if (ability.getAbilityType().equals(AbilityType.SPELL)) {
      if (ability instanceof FlashbackAbility) {
        result=playAbility(ability.copy(),game);
      }
 else {
        result=cast((SpellAbility)ability,game,false);
      }
    }
 else {
      result=playAbility(ability.copy(),game);
    }
  }
  justActivatedType=null;
  if (result) {
    if (isHuman() && (ability.getAbilityType().equals(AbilityType.SPELL) || ability.getAbilityType().equals(AbilityType.ACTIVATED))) {
      if (ability.isUsesStack()) {
        setJustActivatedType(ability.getAbilityType());
      }
    }
    game.getPlayers().resetPassed();
  }
  return result;
}",0.982725527831094
158785,"public DragonToken2(){
  super(""String_Node_Str"",""String_Node_Str"");
  cardType.add(CardType.CREATURE);
  color.setWhite(true);
  subtype.add(""String_Node_Str"");
  power=new MageInt(5);
  toughness=new MageInt(5);
  addAbility(FlyingAbility.getInstance());
  availableImageSetCodes.addAll(Arrays.asList(""String_Node_Str"",""String_Node_Str""));
}","public DragonToken2(){
  super(""String_Node_Str"",""String_Node_Str"");
  cardType.add(CardType.CREATURE);
  color.setRed(true);
  subtype.add(""String_Node_Str"");
  power=new MageInt(5);
  toughness=new MageInt(5);
  addAbility(FlyingAbility.getInstance());
  availableImageSetCodes.addAll(Arrays.asList(""String_Node_Str"",""String_Node_Str""));
}",0.9883040935672516
158786,"public GoatToken(){
  super(""String_Node_Str"",""String_Node_Str"");
  cardType.add(CardType.CREATURE);
  color.setWhite(true);
  subtype.add(""String_Node_Str"");
  power=new MageInt(1);
  toughness=new MageInt(1);
  availableImageSetCodes.addAll(Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
}","public GoatToken(){
  super(""String_Node_Str"",""String_Node_Str"");
  cardType.add(CardType.CREATURE);
  color.setWhite(true);
  subtype.add(""String_Node_Str"");
  power=new MageInt(0);
  toughness=new MageInt(1);
  availableImageSetCodes.addAll(Arrays.asList(""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""));
}",0.996996996996997
158787,"@Override public MindRakerEffect copy(){
  return new MindRakerEffect(this);
}","@Override public MindRaker copy(){
  return new MindRaker(this);
}",0.9166666666666666
158788,"@Override public MurkStriderEffect copy(){
  return new MurkStriderEffect(this);
}","@Override public MurkStrider copy(){
  return new MurkStrider(this);
}",0.9210526315789472
158789,"public TargetSpellOrPermanent(final TargetSpellOrPermanent target){
  super(target);
  this.filter=target.filter.copy();
  this.filterPermanent=target.filterPermanent.copy();
}","public TargetSpellOrPermanent(final TargetSpellOrPermanent target){
  super(target);
  this.filter=target.filter.copy();
}",0.8187919463087249
158790,"public FilterPermanent getPermanentFilter(){
  return this.filterPermanent;
}","public FilterPermanent getPermanentFilter(){
  return this.filter.getPermanentFilter();
}",0.927710843373494
158791,"@Override public Set<UUID> possibleTargets(UUID sourceControllerId,Game game){
  Set<UUID> possibleTargets=new HashSet<>();
  for (  StackObject stackObject : game.getStack()) {
    Spell spell=game.getStack().getSpell(stackObject.getId());
    if (spell != null && filter.match(spell,null,sourceControllerId,game) && filter.match(spell,game)) {
      possibleTargets.add(spell.getId());
    }
  }
  for (  Permanent permanent : game.getBattlefield().getActivePermanents(filterPermanent,sourceControllerId,game)) {
    if (filter.match(permanent,null,sourceControllerId,game)) {
      possibleTargets.add(permanent.getId());
    }
  }
  return possibleTargets;
}","@Override public Set<UUID> possibleTargets(UUID sourceControllerId,Game game){
  Set<UUID> possibleTargets=new HashSet<>();
  for (  StackObject stackObject : game.getStack()) {
    Spell spell=game.getStack().getSpell(stackObject.getId());
    if (spell != null && filter.match(spell,null,sourceControllerId,game) && filter.match(spell,game)) {
      possibleTargets.add(spell.getId());
    }
  }
  for (  Permanent permanent : game.getBattlefield().getActivePermanents(filter.getPermanentFilter(),sourceControllerId,game)) {
    if (filter.match(permanent,null,sourceControllerId,game)) {
      possibleTargets.add(permanent.getId());
    }
  }
  return possibleTargets;
}",0.9910179640718564
158792,"/** 
 * Checks if there are enough   {@link mage.game.permanent.Permanent} or {@link mage.game.stack.Spell} that can be selected.  Should not be usedfor Ability targets since this does not check for protection, shroud etc.
 * @param sourceControllerId - controller of the select event
 * @param game
 * @return - true if enough valid {@link mage.game.permanent.Permanent} or {@link mage.game.stack.Spell} exist
 */
@Override public boolean canChoose(UUID sourceControllerId,Game game){
  int count=0;
  for (  StackObject stackObject : game.getStack()) {
    Spell spell=game.getStack().getSpell(stackObject.getId());
    if (spell != null && filter.match(spell,null,sourceControllerId,game) && filter.match(spell,game)) {
      count++;
      if (count >= this.minNumberOfTargets) {
        return true;
      }
    }
  }
  for (  Permanent permanent : game.getBattlefield().getActivePermanents(filterPermanent,sourceControllerId,game)) {
    if (filter.match(permanent,null,sourceControllerId,game) && filter.match(permanent,game)) {
      count++;
      if (count >= this.minNumberOfTargets) {
        return true;
      }
    }
  }
  return false;
}","/** 
 * Checks if there are enough   {@link mage.game.permanent.Permanent} or{@link mage.game.stack.Spell} that can be selected. Should not be usedfor Ability targets since this does not check for protection, shroud etc.
 * @param sourceControllerId - controller of the select event
 * @param game
 * @return - true if enough valid {@link mage.game.permanent.Permanent} or{@link mage.game.stack.Spell} exist
 */
@Override public boolean canChoose(UUID sourceControllerId,Game game){
  int count=0;
  for (  StackObject stackObject : game.getStack()) {
    Spell spell=game.getStack().getSpell(stackObject.getId());
    if (spell != null && filter.match(spell,null,sourceControllerId,game) && filter.match(spell,game)) {
      count++;
      if (count >= this.minNumberOfTargets) {
        return true;
      }
    }
  }
  for (  Permanent permanent : game.getBattlefield().getActivePermanents(filter.getPermanentFilter(),sourceControllerId,game)) {
    if (filter.match(permanent,null,sourceControllerId,game) && filter.match(permanent,game)) {
      count++;
      if (count >= this.minNumberOfTargets) {
        return true;
      }
    }
  }
  return false;
}",0.9935205183585312
158793,"/** 
 * Add info about attacker blocked by blocker to the game log
 */
private void logBlockerInfo(Player defender,Game game){
  boolean shownDefendingPlayer=game.getPlayers().size() < 3;
  for (  CombatGroup group : this.getGroups()) {
    if (group.defendingPlayerId.equals(defender.getId())) {
      if (!shownDefendingPlayer) {
        game.informPlayers(""String_Node_Str"" + defender.getLogName());
        shownDefendingPlayer=true;
      }
      StringBuilder sb=new StringBuilder();
      boolean attackerExists=false;
      for (      UUID attackingCreatureId : group.getAttackers()) {
        attackerExists=true;
        Permanent attackingCreature=game.getPermanent(attackingCreatureId);
        if (attackingCreature != null) {
          sb.append(""String_Node_Str"");
          sb.append(attackingCreature.getLogName()).append(""String_Node_Str"");
          sb.append(attackingCreature.getPower().getValue()).append(""String_Node_Str"").append(attackingCreature.getToughness().getValue()).append(""String_Node_Str"");
        }
 else {
          attackingCreature=(Permanent)game.getLastKnownInformation(attackingCreatureId,Zone.BATTLEFIELD);
          if (attackingCreature != null) {
            sb.append(attackingCreature.getLogName()).append(""String_Node_Str"");
          }
        }
      }
      if (attackerExists) {
        if (group.getBlockers().size() > 0) {
          sb.append(""String_Node_Str"");
          for (          UUID blockingCreatureId : group.getBlockerOrder()) {
            Permanent blockingCreature=game.getPermanent(blockingCreatureId);
            if (blockingCreature != null) {
              sb.append(blockingCreature.getLogName()).append(""String_Node_Str"");
              sb.append(blockingCreature.getPower().getValue()).append(""String_Node_Str"").append(blockingCreature.getToughness().getValue()).append(""String_Node_Str"");
            }
          }
        }
 else {
          sb.append(""String_Node_Str"");
        }
      }
      game.informPlayers(sb.toString());
    }
  }
}","/** 
 * Add info about attacker blocked by blocker to the game log
 */
private void logBlockerInfo(Player defender,Game game){
  boolean shownDefendingPlayer=game.getPlayers().size() < 3;
  for (  CombatGroup group : game.getCombat().getGroups()) {
    if (group.defendingPlayerId.equals(defender.getId())) {
      if (!shownDefendingPlayer) {
        game.informPlayers(""String_Node_Str"" + defender.getLogName());
        shownDefendingPlayer=true;
      }
      StringBuilder sb=new StringBuilder();
      boolean attackerExists=false;
      for (      UUID attackingCreatureId : group.getAttackers()) {
        attackerExists=true;
        Permanent attackingCreature=game.getPermanent(attackingCreatureId);
        if (attackingCreature != null) {
          sb.append(""String_Node_Str"");
          sb.append(attackingCreature.getLogName()).append(""String_Node_Str"");
          sb.append(attackingCreature.getPower().getValue()).append(""String_Node_Str"").append(attackingCreature.getToughness().getValue()).append(""String_Node_Str"");
        }
 else {
          attackingCreature=(Permanent)game.getLastKnownInformation(attackingCreatureId,Zone.BATTLEFIELD);
          if (attackingCreature != null) {
            sb.append(attackingCreature.getLogName()).append(""String_Node_Str"");
          }
        }
      }
      if (attackerExists) {
        if (group.getBlockers().size() > 0) {
          sb.append(""String_Node_Str"");
          for (          UUID blockingCreatureId : group.getBlockerOrder()) {
            Permanent blockingCreature=game.getPermanent(blockingCreatureId);
            if (blockingCreature != null) {
              sb.append(blockingCreature.getLogName()).append(""String_Node_Str"");
              sb.append(blockingCreature.getPower().getValue()).append(""String_Node_Str"").append(blockingCreature.getToughness().getValue()).append(""String_Node_Str"");
            }
          }
        }
 else {
          sb.append(""String_Node_Str"");
        }
      }
      game.informPlayers(sb.toString());
    }
  }
}",0.995069033530572
158794,"@Override public boolean apply(Game game,Ability source){
  TargetPermanent target=(TargetPermanent)source.getTargets().get(0);
  Permanent permanent=game.getPermanent(target.getFirstTarget());
  Player player=game.getPlayer(source.getControllerId());
  if (permanent != null && player != null) {
    int toRemove=source.getManaCostsToPay().getX();
    int removed=0;
    String[] counterNames=permanent.getCounters().keySet().toArray(new String[0]);
    for (    String counterName : counterNames) {
      if (player.chooseUse(Outcome.Neutral,""String_Node_Str"" + counterName + ""String_Node_Str"",source,game)) {
        if (permanent.getCounters().get(counterName).getCount() == 1 || toRemove == 1) {
          permanent.getCounters().removeCounter(counterName,1);
        }
 else {
          int amount=player.getAmount(1,Math.min(permanent.getCounters().get(counterName).getCount(),toRemove - removed),""String_Node_Str"",game);
          if (amount > 0) {
            removed+=amount;
            permanent.getCounters().removeCounter(counterName,amount);
          }
        }
      }
      if (removed >= toRemove)       break;
    }
    game.addEffect(new BoostSourceEffect(removed,0,Duration.EndOfTurn),source);
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  TargetPermanent target=(TargetPermanent)source.getTargets().get(0);
  Permanent permanent=game.getPermanent(target.getFirstTarget());
  Player player=game.getPlayer(source.getControllerId());
  if (permanent != null && player != null) {
    int toRemove=source.getManaCostsToPay().getX();
    int removed=0;
    String[] counterNames=permanent.getCounters().keySet().toArray(new String[0]);
    for (    String counterName : counterNames) {
      if (player.chooseUse(Outcome.Neutral,""String_Node_Str"" + counterName + ""String_Node_Str"",source,game)) {
        if (permanent.getCounters().get(counterName).getCount() == 1 || toRemove == 1) {
          permanent.getCounters().removeCounter(counterName,1);
          removed++;
        }
 else {
          int amount=player.getAmount(1,Math.min(permanent.getCounters().get(counterName).getCount(),toRemove - removed),""String_Node_Str"",game);
          if (amount > 0) {
            removed+=amount;
            permanent.getCounters().removeCounter(counterName,amount);
          }
        }
      }
      if (removed >= toRemove) {
        break;
      }
    }
    game.addEffect(new BoostSourceEffect(removed,0,Duration.EndOfTurn),source);
    return true;
  }
  return false;
}",0.9870232009437672
158795,"@Override public Boolean apply(Game game,Permanent permanent){
  if (!permanent.getCardType().contains(CardType.ENCHANTMENT)) {
    permanent.getCardType().add(CardType.ENCHANTMENT);
  }
  return true;
}","@Override public boolean apply(Game game,Ability source){
  Player player=game.getPlayer(source.getControllerId());
  Permanent sourcePermanent=game.getPermanent(source.getSourceId());
  if (player != null && sourcePermanent != null) {
    Target target=new TargetPermanent(filter);
    target.setNotTarget(true);
    if (target.canChoose(source.getControllerId(),game)) {
      player.choose(Outcome.Copy,target,source.getSourceId(),game);
      Permanent copyFromPermanent=game.getPermanent(target.getFirstTarget());
      if (copyFromPermanent != null) {
        game.copyPermanent(copyFromPermanent,sourcePermanent,source,applier);
        return true;
      }
    }
  }
  return false;
}",0.1519553072625698
158796,"@Override public Boolean apply(Game game,Permanent permanent){
  if (!permanent.getSubtype().contains(""String_Node_Str"")) {
    permanent.getSubtype().add(""String_Node_Str"");
  }
  permanent.getAbilities().add(new BecomesTargetTriggeredAbility(new SacrificeSourceEffect()));
  return true;
}","@Override public Boolean apply(Game game,MageObject mageObject){
  if (!mageObject.getSubtype().contains(""String_Node_Str"")) {
    mageObject.getSubtype().add(""String_Node_Str"");
  }
  mageObject.getAbilities().add(new BecomesTargetTriggeredAbility(new SacrificeSourceEffect()));
  return true;
}",0.848381601362862
158797,"@Override public Boolean apply(Game game,Permanent permanent){
  Ability ability=new SimpleActivatedAbility(Zone.BATTLEFIELD,new ReturnToHandSourceEffect(true),new ManaCostsImpl(""String_Node_Str""));
  permanent.addAbility(ability,game);
  return true;
}","@Override public boolean apply(Game game,Ability source){
  Player player=game.getPlayer(source.getControllerId());
  Permanent sourcePermanent=game.getPermanent(source.getSourceId());
  if (player != null && sourcePermanent != null) {
    Target target=new TargetPermanent(new FilterControlledCreaturePermanent());
    target.setNotTarget(true);
    if (target.canChoose(source.getSourceId(),source.getControllerId(),game)) {
      player.choose(Outcome.Copy,target,source.getSourceId(),game);
      Permanent copyFromPermanent=game.getPermanent(target.getFirstTarget());
      if (copyFromPermanent != null) {
        game.copyPermanent(copyFromPermanent,sourcePermanent,source,new AbilityApplier(new SimpleActivatedAbility(Zone.BATTLEFIELD,new ReturnToHandSourceEffect(true),new ManaCostsImpl(""String_Node_Str""))));
        return true;
      }
    }
  }
  return false;
}",0.3226950354609929
158798,"@Override public Boolean apply(Game game,Permanent permanent){
  Ability upkeepAbility=new BeginningOfUpkeepTriggeredAbility(new CryptoplasmEffect(),TargetController.YOU,true);
  upkeepAbility.addTarget(new TargetCreaturePermanent());
  permanent.addAbility(upkeepAbility,source.getSourceId(),game);
  return true;
}","@Override public Boolean apply(Game game,MageObject mageObject){
  Ability upkeepAbility=new BeginningOfUpkeepTriggeredAbility(new CryptoplasmEffect(),TargetController.YOU,true);
  upkeepAbility.addTarget(new TargetCreaturePermanent());
  mageObject.getAbilities().add(upkeepAbility);
  return true;
}",0.8233387358184765
158799,"@Override public void selectAttackers(Game game,UUID attackingPlayerId){
  UUID defenderId=null;
  for (  PlayerAction action : actions) {
    if (action.getTurnNum() == game.getTurnNum() && action.getAction().startsWith(""String_Node_Str"")) {
      String command=action.getAction();
      command=command.substring(command.indexOf(""String_Node_Str"") + 7);
      String[] groups=command.split(""String_Node_Str"");
      for (int i=1; i < groups.length; i++) {
        String group=groups[i];
        if (group.startsWith(""String_Node_Str"")) {
          String planeswalkerName=group.substring(group.indexOf(""String_Node_Str"") + 13);
          for (          Permanent permanent : game.getBattlefield().getAllActivePermanents(new FilterPlaneswalkerPermanent(),game)) {
            if (permanent.getName().equals(planeswalkerName)) {
              defenderId=permanent.getId();
            }
          }
        }
        if (group.startsWith(""String_Node_Str"")) {
          String defendingPlayerName=group.substring(group.indexOf(""String_Node_Str"") + 16);
          for (          Player defendingPlayer : game.getPlayers().values()) {
            if (defendingPlayer.getName().equals(defendingPlayerName)) {
              defenderId=defendingPlayer.getId();
              break;
            }
          }
        }
      }
      if (defenderId == null) {
        for (        UUID uuid : game.getCombat().getDefenders()) {
          Player defender=game.getPlayer(uuid);
          if (defender != null) {
            defenderId=uuid;
          }
        }
      }
      FilterCreatureForCombat filter=new FilterCreatureForCombat();
      filter.add(new NamePredicate(groups[0]));
      filter.add(Predicates.not(new AttackingPredicate()));
      Permanent attacker=findPermanent(filter,computerPlayer.getId(),game);
      if (attacker != null && attacker.canAttack(defenderId,game)) {
        computerPlayer.declareAttacker(attacker.getId(),defenderId,game,false);
      }
    }
  }
}","@Override public void selectAttackers(Game game,UUID attackingPlayerId){
  UUID defenderId=null;
  for (  PlayerAction action : actions) {
    if (action.getTurnNum() == game.getTurnNum() && action.getAction().startsWith(""String_Node_Str"")) {
      String command=action.getAction();
      command=command.substring(command.indexOf(""String_Node_Str"") + 7);
      String[] groups=command.split(""String_Node_Str"");
      for (int i=1; i < groups.length; i++) {
        String group=groups[i];
        if (group.startsWith(""String_Node_Str"")) {
          String planeswalkerName=group.substring(group.indexOf(""String_Node_Str"") + 13);
          for (          Permanent permanent : game.getBattlefield().getAllActivePermanents(new FilterPlaneswalkerPermanent(),game)) {
            if (permanent.getName().equals(planeswalkerName)) {
              defenderId=permanent.getId();
            }
          }
        }
        if (group.startsWith(""String_Node_Str"")) {
          String defendingPlayerName=group.substring(group.indexOf(""String_Node_Str"") + 16);
          for (          Player defendingPlayer : game.getPlayers().values()) {
            if (defendingPlayer.getName().equals(defendingPlayerName)) {
              defenderId=defendingPlayer.getId();
              break;
            }
          }
        }
      }
      if (defenderId == null) {
        for (        UUID uuid : game.getCombat().getDefenders()) {
          Player defender=game.getPlayer(uuid);
          if (defender != null) {
            defenderId=uuid;
          }
        }
      }
      FilterCreatureForCombat filter=new FilterCreatureForCombat();
      filter.add(new NamePredicate(groups[0]));
      filter.add(Predicates.not(new AttackingPredicate()));
      filter.add(Predicates.not(new SummoningSicknessPredicate()));
      Permanent attacker=findPermanent(filter,computerPlayer.getId(),game);
      if (attacker != null && attacker.canAttack(defenderId,game)) {
        computerPlayer.declareAttacker(attacker.getId(),defenderId,game,false);
      }
    }
  }
}",0.983151635282458
158800,"@Override public boolean checkTrigger(GameEvent event,Game game){
  if (game.getOpponents(controllerId).contains(event.getPlayerId())) {
switch (setTargetPointer) {
case PLAYER:
      for (      Effect effect : getEffects()) {
        effect.setTargetPointer(new FixedTarget(event.getPlayerId()));
      }
    break;
default :
  throw new UnsupportedOperationException(setTargetPointer.toString() + ""String_Node_Str"");
}
return true;
}
return false;
}","@Override public boolean checkTrigger(GameEvent event,Game game){
  if (game.getOpponents(controllerId).contains(event.getPlayerId())) {
switch (setTargetPointer) {
case PLAYER:
      for (      Effect effect : getEffects()) {
        effect.setTargetPointer(new FixedTarget(event.getPlayerId()));
      }
    break;
case NONE:
  break;
default :
throw new UnsupportedOperationException(setTargetPointer.toString() + ""String_Node_Str"");
}
return true;
}
return false;
}",0.9630434782608696
158801,"public GameView(GameState state,Game game,UUID createdForPlayerId,UUID watcherUserId){
  Player createdForPlayer=null;
  this.isPlayer=createdForPlayerId != null;
  this.priorityTime=game.getPriorityTime();
  for (  Player player : state.getPlayers().values()) {
    players.add(new PlayerView(player,state,game,createdForPlayerId,watcherUserId));
    if (player.getId().equals(createdForPlayerId)) {
      createdForPlayer=player;
    }
  }
  for (  StackObject stackObject : state.getStack()) {
    if (stackObject instanceof StackAbility) {
      MageObject object=game.getObject(stackObject.getSourceId());
      Card card=game.getCard(stackObject.getSourceId());
      if (card != null) {
        if (object != null) {
          stack.put(stackObject.getId(),new StackAbilityView(game,(StackAbility)stackObject,card.getName(),new CardView(card)));
        }
 else {
          stack.put(stackObject.getId(),new StackAbilityView(game,(StackAbility)stackObject,""String_Node_Str"",new CardView(card)));
        }
        if (card.canTransform()) {
          updateLatestCardView(game,card,stackObject.getId());
        }
        checkPaid(stackObject.getId(),(StackAbility)stackObject);
      }
 else       if (object != null) {
        if (object instanceof PermanentToken) {
          PermanentToken token=(PermanentToken)object;
          stack.put(stackObject.getId(),new StackAbilityView(game,(StackAbility)stackObject,token.getName(),new CardView(token)));
          checkPaid(stackObject.getId(),(StackAbility)stackObject);
        }
 else         if (object instanceof Emblem) {
          Card sourceCard=game.getCard(((Emblem)object).getSourceId());
          if (sourceCard != null) {
            if (!sourceCard.getCardType().contains(CardType.PLANESWALKER)) {
              if (sourceCard.getSecondCardFace() != null) {
                sourceCard=sourceCard.getSecondCardFace();
              }
            }
            ((StackAbility)stackObject).setName(""String_Node_Str"" + sourceCard.getName());
            ((StackAbility)stackObject).setExpansionSetCode(sourceCard.getExpansionSetCode());
          }
 else {
            throw new IllegalArgumentException(""String_Node_Str"");
          }
          stack.put(stackObject.getId(),new StackAbilityView(game,(StackAbility)stackObject,object.getName(),new CardView(new EmblemView(((Emblem)object),sourceCard))));
          checkPaid(stackObject.getId(),((StackAbility)stackObject));
        }
 else {
          StackAbility stackAbility=((StackAbility)object);
          stackAbility.newId();
          stack.put(stackObject.getId(),new CardView(((StackAbility)stackObject)));
          checkPaid(stackObject.getId(),((StackAbility)stackObject));
        }
      }
 else {
        logger.error(""String_Node_Str"" + stackObject.getStackAbility().getRule());
      }
    }
 else {
      stack.put(stackObject.getId(),new CardView((Spell)stackObject,game,stackObject.getControllerId().equals(createdForPlayerId)));
      checkPaid(stackObject.getId(),(Spell)stackObject);
    }
  }
  for (  ExileZone exileZone : state.getExile().getExileZones()) {
    exiles.add(new ExileView(exileZone,game));
  }
  for (  String name : state.getRevealed().keySet()) {
    revealed.add(new RevealedView(name,state.getRevealed().get(name),game));
  }
  this.phase=state.getTurn().getPhaseType();
  this.step=state.getTurn().getStepType();
  this.turn=state.getTurnNum();
  this.activePlayerId=state.getActivePlayerId();
  if (state.getActivePlayerId() != null) {
    this.activePlayerName=state.getPlayer(state.getActivePlayerId()).getName();
  }
 else {
    this.activePlayerName=""String_Node_Str"";
  }
  if (state.getPriorityPlayerId() != null) {
    this.priorityPlayerName=state.getPlayer(state.getPriorityPlayerId()).getName();
  }
 else {
    this.priorityPlayerName=""String_Node_Str"";
  }
  for (  CombatGroup combatGroup : state.getCombat().getGroups()) {
    combat.add(new CombatGroupView(combatGroup,game));
  }
  if (isPlayer) {
    if (state.getPriorityPlayerId() == createdForPlayerId && createdForPlayer != null) {
      this.special=state.getSpecialActions().getControlledBy(state.getPriorityPlayerId(),createdForPlayer.isInPayManaMode()).size() > 0;
    }
  }
 else {
    this.special=false;
  }
  CastSpellLastTurnWatcher watcher=(CastSpellLastTurnWatcher)game.getState().getWatchers().get(""String_Node_Str"");
  if (watcher != null) {
    spellsCastCurrentTurn=watcher.getAmountOfSpellsAllPlayersCastOnCurrentTurn();
  }
 else {
    spellsCastCurrentTurn=0;
  }
  rollbackTurnsAllowed=game.getOptions().rollbackTurnsAllowed;
}","public GameView(GameState state,Game game,UUID createdForPlayerId,UUID watcherUserId){
  Player createdForPlayer=null;
  this.isPlayer=createdForPlayerId != null;
  this.priorityTime=game.getPriorityTime();
  for (  Player player : state.getPlayers().values()) {
    players.add(new PlayerView(player,state,game,createdForPlayerId,watcherUserId));
    if (player.getId().equals(createdForPlayerId)) {
      createdForPlayer=player;
    }
  }
  for (  StackObject stackObject : state.getStack()) {
    if (stackObject instanceof StackAbility) {
      MageObject object=game.getObject(stackObject.getSourceId());
      Card card=game.getCard(stackObject.getSourceId());
      if (card != null) {
        if (object != null) {
          stack.put(stackObject.getId(),new StackAbilityView(game,(StackAbility)stackObject,card.getName(),new CardView(card)));
        }
 else {
          stack.put(stackObject.getId(),new StackAbilityView(game,(StackAbility)stackObject,""String_Node_Str"",new CardView(card)));
        }
        if (card.canTransform()) {
          updateLatestCardView(game,card,stackObject.getId());
        }
        checkPaid(stackObject.getId(),(StackAbility)stackObject);
      }
 else       if (object != null) {
        if (object instanceof PermanentToken) {
          PermanentToken token=(PermanentToken)object;
          stack.put(stackObject.getId(),new StackAbilityView(game,(StackAbility)stackObject,token.getName(),new CardView(token)));
          checkPaid(stackObject.getId(),(StackAbility)stackObject);
        }
 else         if (object instanceof Emblem) {
          Card sourceCard=game.getCard(((Emblem)object).getSourceId());
          if (sourceCard != null) {
            if (!sourceCard.getCardType().contains(CardType.PLANESWALKER)) {
              if (sourceCard.getSecondCardFace() != null) {
                sourceCard=sourceCard.getSecondCardFace();
              }
            }
            ((StackAbility)stackObject).setName(""String_Node_Str"" + sourceCard.getName());
            ((StackAbility)stackObject).setExpansionSetCode(sourceCard.getExpansionSetCode());
          }
 else {
            throw new IllegalArgumentException(""String_Node_Str"");
          }
          stack.put(stackObject.getId(),new StackAbilityView(game,(StackAbility)stackObject,object.getName(),new CardView(new EmblemView(((Emblem)object),sourceCard))));
          checkPaid(stackObject.getId(),((StackAbility)stackObject));
        }
 else {
          if (object instanceof StackAbility) {
            StackAbility stackAbility=((StackAbility)object);
            stackAbility.newId();
            stack.put(stackObject.getId(),new CardView(((StackAbility)stackObject)));
            checkPaid(stackObject.getId(),((StackAbility)stackObject));
          }
 else {
            logger.fatal(""String_Node_Str"" + object.getName() + ""String_Node_Str""+ object.toString());
          }
        }
      }
 else {
        logger.error(""String_Node_Str"" + stackObject.getStackAbility().getRule());
      }
    }
 else {
      stack.put(stackObject.getId(),new CardView((Spell)stackObject,game,stackObject.getControllerId().equals(createdForPlayerId)));
      checkPaid(stackObject.getId(),(Spell)stackObject);
    }
  }
  for (  ExileZone exileZone : state.getExile().getExileZones()) {
    exiles.add(new ExileView(exileZone,game));
  }
  for (  String name : state.getRevealed().keySet()) {
    revealed.add(new RevealedView(name,state.getRevealed().get(name),game));
  }
  this.phase=state.getTurn().getPhaseType();
  this.step=state.getTurn().getStepType();
  this.turn=state.getTurnNum();
  this.activePlayerId=state.getActivePlayerId();
  if (state.getActivePlayerId() != null) {
    this.activePlayerName=state.getPlayer(state.getActivePlayerId()).getName();
  }
 else {
    this.activePlayerName=""String_Node_Str"";
  }
  if (state.getPriorityPlayerId() != null) {
    this.priorityPlayerName=state.getPlayer(state.getPriorityPlayerId()).getName();
  }
 else {
    this.priorityPlayerName=""String_Node_Str"";
  }
  for (  CombatGroup combatGroup : state.getCombat().getGroups()) {
    combat.add(new CombatGroupView(combatGroup,game));
  }
  if (isPlayer) {
    if (state.getPriorityPlayerId() == createdForPlayerId && createdForPlayer != null) {
      this.special=state.getSpecialActions().getControlledBy(state.getPriorityPlayerId(),createdForPlayer.isInPayManaMode()).size() > 0;
    }
  }
 else {
    this.special=false;
  }
  CastSpellLastTurnWatcher watcher=(CastSpellLastTurnWatcher)game.getState().getWatchers().get(""String_Node_Str"");
  if (watcher != null) {
    spellsCastCurrentTurn=watcher.getAmountOfSpellsAllPlayersCastOnCurrentTurn();
  }
 else {
    spellsCastCurrentTurn=0;
  }
  rollbackTurnsAllowed=game.getOptions().rollbackTurnsAllowed;
}",0.9791822355076332
158802,"/** 
 * Abilities that are applied to other objects or applie for a certain time span
 * @param ability
 * @param sourceId
 * @param attachedTo
 */
public void addAbility(Ability ability,UUID sourceId,Card attachedTo){
  if (ability instanceof StaticAbility) {
    for (    Mode mode : ability.getModes().values()) {
      for (      Effect effect : mode.getEffects()) {
        if (effect instanceof ContinuousEffect) {
          addEffect((ContinuousEffect)effect,sourceId,ability);
        }
      }
    }
  }
 else   if (ability instanceof TriggeredAbility) {
    this.triggers.add((TriggeredAbility)ability,sourceId,attachedTo);
  }
  for (  Watcher watcher : ability.getWatchers()) {
    watcher.setControllerId(attachedTo == null ? ability.getControllerId() : attachedTo.getOwnerId());
    watcher.setSourceId(attachedTo == null ? ability.getSourceId() : attachedTo.getId());
    watchers.add(watcher);
  }
  for (  Ability sub : ability.getSubAbilities()) {
    addAbility(sub,sourceId,attachedTo);
  }
}","/** 
 * Abilities that are applied to other objects or applie for a certain time span
 * @param ability
 * @param sourceId
 * @param attachedTo
 */
public void addAbility(Ability ability,UUID sourceId,Card attachedTo){
  if (ability instanceof StaticAbility) {
    for (    Mode mode : ability.getModes().values()) {
      for (      Effect effect : mode.getEffects()) {
        if (effect instanceof ContinuousEffect) {
          addEffect((ContinuousEffect)effect,sourceId,ability);
        }
      }
    }
  }
 else   if (ability instanceof TriggeredAbility) {
    this.triggers.add((TriggeredAbility)ability,sourceId,attachedTo);
  }
  List<Watcher> watcherList=new ArrayList<>(ability.getWatchers());
  for (  Watcher watcher : watcherList) {
    watcher.setControllerId(attachedTo == null ? ability.getControllerId() : attachedTo.getOwnerId());
    watcher.setSourceId(attachedTo == null ? ability.getSourceId() : attachedTo.getId());
    watchers.add(watcher);
  }
  for (  Ability sub : ability.getSubAbilities()) {
    addAbility(sub,sourceId,attachedTo);
  }
}",0.9452449567723344
158803,"@Override public boolean moveToZone(Zone toZone,UUID sourceId,Game game,boolean flag,ArrayList<UUID> appliedEffects){
  Zone fromZone=game.getState().getZone(objectId);
  ZoneChangeEvent event=new ZoneChangeEvent(this.objectId,sourceId,ownerId,fromZone,toZone,appliedEffects);
  if (!game.replaceEvent(event)) {
    if (event.getFromZone() != null) {
switch (event.getFromZone()) {
case GRAVEYARD:
        game.getPlayer(ownerId).removeFromGraveyard(this,game);
      break;
case HAND:
    game.getPlayer(ownerId).removeFromHand(this,game);
  break;
case LIBRARY:
game.getPlayer(ownerId).removeFromLibrary(this,game);
break;
case EXILED:
game.getExile().removeCard(this,game);
break;
case OUTSIDE:
game.getPlayer(ownerId).getSideboard().remove(this);
break;
case COMMAND:
game.getState().getCommand().remove((Commander)game.getObject(objectId));
break;
case STACK:
StackObject stackObject=game.getStack().getSpell(getSpellAbility().getId());
if (stackObject == null && (this instanceof SplitCard)) {
stackObject=game.getStack().getSpell(((SplitCard)this).getLeftHalfCard().getId());
if (stackObject == null) {
stackObject=game.getStack().getSpell(((SplitCard)this).getRightHalfCard().getId());
}
}
if (stackObject != null) {
game.getStack().remove(stackObject);
}
break;
case PICK:
case BATTLEFIELD:
break;
default :
Card sourceCard=game.getCard(sourceId);
logger.fatal(new StringBuilder(""String_Node_Str"").append(fromZone).append(""String_Node_Str"").append(this.getName()).append(""String_Node_Str"").append(toZone).append(""String_Node_Str"").append(sourceCard != null ? sourceCard.getName() : ""String_Node_Str"").append(""String_Node_Str"").toString());
break;
}
game.rememberLKI(objectId,event.getFromZone(),this);
}
setFaceDown(false,game);
updateZoneChangeCounter(game);
switch (event.getToZone()) {
case GRAVEYARD:
game.getPlayer(ownerId).putInGraveyard(this,game,!flag);
break;
case HAND:
game.getPlayer(ownerId).getHand().add(this);
break;
case STACK:
game.getStack().push(new Spell(this,this.getSpellAbility().copy(),ownerId,event.getFromZone()));
break;
case EXILED:
game.getExile().getPermanentExile().add(this);
break;
case COMMAND:
game.addCommander(new Commander(this));
break;
case LIBRARY:
if (flag) {
game.getPlayer(ownerId).getLibrary().putOnTop(this,game);
}
 else {
game.getPlayer(ownerId).getLibrary().putOnBottom(this,game);
}
break;
case BATTLEFIELD:
PermanentCard permanent=new PermanentCard(this,event.getPlayerId(),game);
game.addPermanent(permanent);
game.setZone(objectId,Zone.BATTLEFIELD);
game.setScopeRelevant(true);
game.applyEffects();
boolean entered=permanent.entersBattlefield(sourceId,game,event.getFromZone(),true);
game.setScopeRelevant(false);
game.applyEffects();
if (entered) {
if (flag) {
permanent.setTapped(true);
}
event.setTarget(permanent);
}
 else {
return false;
}
break;
default :
Card sourceCard=game.getCard(sourceId);
logger.fatal(new StringBuilder(""String_Node_Str"").append(toZone).append(""String_Node_Str"").append(this.getName()).append(""String_Node_Str"").append(toZone).append(""String_Node_Str"").append(sourceCard != null ? sourceCard.getName() : ""String_Node_Str"").append(""String_Node_Str"").toString());
return false;
}
game.setZone(objectId,event.getToZone());
game.addSimultaneousEvent(event);
return game.getState().getZone(objectId) == toZone;
}
return false;
}","@Override public boolean moveToZone(Zone toZone,UUID sourceId,Game game,boolean flag,ArrayList<UUID> appliedEffects){
  Zone fromZone=game.getState().getZone(objectId);
  ZoneChangeEvent event=new ZoneChangeEvent(this.objectId,sourceId,ownerId,fromZone,toZone,appliedEffects);
  if (!game.replaceEvent(event)) {
    if (event.getFromZone() != null) {
switch (event.getFromZone()) {
case GRAVEYARD:
        game.getPlayer(ownerId).removeFromGraveyard(this,game);
      break;
case HAND:
    game.getPlayer(ownerId).removeFromHand(this,game);
  break;
case LIBRARY:
game.getPlayer(ownerId).removeFromLibrary(this,game);
break;
case EXILED:
game.getExile().removeCard(this,game);
break;
case OUTSIDE:
game.getPlayer(ownerId).getSideboard().remove(this);
break;
case COMMAND:
game.getState().getCommand().remove((Commander)game.getObject(objectId));
break;
case STACK:
StackObject stackObject=game.getStack().getSpell(getSpellAbility().getId());
if (stackObject == null && (this instanceof SplitCard)) {
stackObject=game.getStack().getSpell(((SplitCard)this).getLeftHalfCard().getId());
if (stackObject == null) {
stackObject=game.getStack().getSpell(((SplitCard)this).getRightHalfCard().getId());
}
}
if (stackObject == null) {
stackObject=game.getStack().getSpell(getId());
}
if (stackObject != null) {
game.getStack().remove(stackObject);
}
break;
case PICK:
case BATTLEFIELD:
break;
default :
Card sourceCard=game.getCard(sourceId);
logger.fatal(new StringBuilder(""String_Node_Str"").append(fromZone).append(""String_Node_Str"").append(this.getName()).append(""String_Node_Str"").append(toZone).append(""String_Node_Str"").append(sourceCard != null ? sourceCard.getName() : ""String_Node_Str"").append(""String_Node_Str"").toString());
break;
}
game.rememberLKI(objectId,event.getFromZone(),this);
}
setFaceDown(false,game);
updateZoneChangeCounter(game);
switch (event.getToZone()) {
case GRAVEYARD:
game.getPlayer(ownerId).putInGraveyard(this,game,!flag);
break;
case HAND:
game.getPlayer(ownerId).getHand().add(this);
break;
case STACK:
game.getStack().push(new Spell(this,this.getSpellAbility().copy(),ownerId,event.getFromZone()));
break;
case EXILED:
game.getExile().getPermanentExile().add(this);
break;
case COMMAND:
game.addCommander(new Commander(this));
break;
case LIBRARY:
if (flag) {
game.getPlayer(ownerId).getLibrary().putOnTop(this,game);
}
 else {
game.getPlayer(ownerId).getLibrary().putOnBottom(this,game);
}
break;
case BATTLEFIELD:
PermanentCard permanent=new PermanentCard(this,event.getPlayerId(),game);
game.addPermanent(permanent);
game.setZone(objectId,Zone.BATTLEFIELD);
game.setScopeRelevant(true);
game.applyEffects();
boolean entered=permanent.entersBattlefield(sourceId,game,event.getFromZone(),true);
game.setScopeRelevant(false);
game.applyEffects();
if (entered) {
if (flag) {
permanent.setTapped(true);
}
event.setTarget(permanent);
}
 else {
return false;
}
break;
default :
Card sourceCard=game.getCard(sourceId);
logger.fatal(new StringBuilder(""String_Node_Str"").append(toZone).append(""String_Node_Str"").append(this.getName()).append(""String_Node_Str"").append(toZone).append(""String_Node_Str"").append(sourceCard != null ? sourceCard.getName() : ""String_Node_Str"").append(""String_Node_Str"").toString());
return false;
}
game.setZone(objectId,event.getToZone());
game.addSimultaneousEvent(event);
return game.getState().getZone(objectId) == toZone;
}
return false;
}",0.988670244484198
158804,"@Override public boolean apply(Game game,Ability source){
  Permanent targetedLand=game.getPermanent(source.getFirstTarget());
  if (targetedLand != null) {
    Player controller=game.getPlayer(targetedLand.getControllerId());
    targetedLand.destroy(id,game,true);
    int landsInGraveyard=controller.getGraveyard().count(filter,game);
    controller.damage(landsInGraveyard,id,game,false,true);
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Permanent targetedLand=game.getPermanent(getTargetPointer().getFirst(game,source));
  if (targetedLand != null) {
    targetedLand.destroy(source.getSourceId(),game,true);
    Player targetController=game.getPlayer(targetedLand.getControllerId());
    if (targetController != null) {
      int landsInGraveyard=targetController.getGraveyard().count(new FilterLandCard(),game);
      targetController.damage(landsInGraveyard,source.getSourceId(),game,false,true);
    }
    return true;
  }
  return false;
}",0.4865403788634098
158805,"public LandfallWatcher(final LandfallWatcher watcher){
  super(watcher);
  playerPlayedLand.addAll(playerPlayedLand);
}","public LandfallWatcher(final LandfallWatcher watcher){
  super(watcher);
  playerPlayedLand.addAll(watcher.playerPlayedLand);
}",0.967479674796748
158806,"@Override public boolean apply(Game game,Ability source){
  ExileZone zone=game.getExile().getExileZone(CardUtil.getCardExileZoneId(game,source));
  if (zone == null || zone.isEmpty()) {
    return false;
  }
  Card card=zone.getCards(game).iterator().next();
  Player controller=game.getPlayer(source.getControllerId());
  if (card != null && controller != null) {
    if (card.getCardType().contains(CardType.LAND)) {
      if (game.getActivePlayerId().equals(source.getControllerId()) && controller.canPlayLand()) {
        if (controller.chooseUse(Outcome.Benefit,""String_Node_Str"" + card.getLogName() + ""String_Node_Str"",source,game)) {
          card.setFaceDown(false,game);
          return controller.playLand(card,game);
        }
      }
 else       if (!game.isSimulation()) {
        game.informPlayer(controller,""String_Node_Str"");
      }
    }
 else {
      if (card.getSpellAbility() != null) {
        if (controller.chooseUse(Outcome.Benefit,""String_Node_Str"" + card.getLogName() + ""String_Node_Str"",source,game)) {
          card.setFaceDown(false,game);
          return controller.cast(card.getSpellAbility(),game,true);
        }
      }
 else {
        Logger.getLogger(HideawayPlayEffect.class).error(""String_Node_Str"" + card.getName());
        return false;
      }
    }
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  ExileZone zone=game.getExile().getExileZone(CardUtil.getCardExileZoneId(game,source));
  if (zone == null || zone.isEmpty()) {
    return false;
  }
  Card card=zone.getCards(game).iterator().next();
  Player controller=game.getPlayer(source.getControllerId());
  if (card != null && controller != null) {
    if (card.getCardType().contains(CardType.LAND)) {
      if (game.getActivePlayerId().equals(source.getControllerId()) && controller.canPlayLand() && MyMainPhaseCondition.getInstance().apply(game,source)) {
        if (controller.chooseUse(Outcome.Benefit,""String_Node_Str"" + card.getLogName() + ""String_Node_Str"",source,game)) {
          card.setFaceDown(false,game);
          return controller.moveCards(card,Zone.EXILED,Zone.BATTLEFIELD,source,game);
        }
      }
 else       if (!game.isSimulation()) {
        game.informPlayer(controller,""String_Node_Str"");
      }
    }
 else {
      if (card.getSpellAbility() != null) {
        if (controller.chooseUse(Outcome.Benefit,""String_Node_Str"" + card.getLogName() + ""String_Node_Str"",source,game)) {
          card.setFaceDown(false,game);
          return controller.cast(card.getSpellAbility(),game,true);
        }
      }
 else {
        Logger.getLogger(HideawayPlayEffect.class).error(""String_Node_Str"" + card.getName());
        return false;
      }
    }
    return true;
  }
  return false;
}",0.9573699421965318
158807,"@Override public boolean replaceEvent(GameEvent event,Ability source,Game game){
  Zone fromZone=((ZoneChangeEvent)event).getFromZone();
  Card card=game.getCard(event.getTargetId());
  UUID sourceId=event.getSourceId();
  UUID controllerId=event.getPlayerId();
  if (card.isFaceDown(game)) {
    return false;
  }
  Object object=game.getState().getValue(""String_Node_Str"" + card.getId());
  if (object != null && object instanceof PermanentCard) {
    return false;
  }
  UUID targetId=null;
  MageObject sourceObject=game.getObject(sourceId);
  boolean enchantCardInGraveyard=false;
  if (sourceObject instanceof Spell) {
    if (fromZone.equals(Zone.EXILED)) {
      return false;
    }
  }
  if (sourceObject instanceof StackAbility) {
    StackAbility stackAbility=(StackAbility)sourceObject;
    if (!stackAbility.getEffects().isEmpty()) {
      targetId=stackAbility.getEffects().get(0).getTargetPointer().getFirst(game,stackAbility);
    }
  }
  if (targetId == null) {
    Target target=card.getSpellAbility().getTargets().get(0);
    enchantCardInGraveyard=target instanceof TargetCardInGraveyard;
    if (target != null) {
      target.clearChosen();
    }
    Player player=game.getPlayer(card.getOwnerId());
    Outcome auraOutcome=Outcome.BoostCreature;
    Ability:     for (    Ability ability : card.getAbilities()) {
      if (ability instanceof SpellAbility) {
        for (        Effect effect : ability.getEffects()) {
          if (effect instanceof AttachEffect) {
            auraOutcome=effect.getOutcome();
            break Ability;
          }
        }
      }
    }
    if (target != null && player != null && player.choose(auraOutcome,target,card.getId(),game)) {
      targetId=target.getFirstTarget();
    }
  }
  Card targetCard=null;
  Permanent targetPermanent=null;
  if (enchantCardInGraveyard) {
    targetCard=game.getCard(targetId);
  }
 else {
    targetPermanent=game.getPermanent(targetId);
  }
  Player targetPlayer=game.getPlayer(targetId);
  if (targetCard != null || targetPermanent != null || targetPlayer != null) {
switch (fromZone) {
case EXILED:
      game.getExile().removeCard(card,game);
    break;
case GRAVEYARD:
  game.getPlayer(card.getOwnerId()).removeFromGraveyard(card,game);
break;
case HAND:
game.getPlayer(card.getOwnerId()).removeFromHand(card,game);
break;
case LIBRARY:
game.getPlayer(card.getOwnerId()).removeFromLibrary(card,game);
break;
default :
}
game.rememberLKI(card.getId(),fromZone,card);
PermanentCard permanent=new PermanentCard(card,card.getOwnerId(),game);
game.getBattlefield().addPermanent(permanent);
card.setZone(Zone.BATTLEFIELD,game);
game.applyEffects();
boolean entered=permanent.entersBattlefield(event.getSourceId(),game,fromZone,true);
game.applyEffects();
if (!entered) {
return false;
}
game.fireEvent(new ZoneChangeEvent(permanent,controllerId,fromZone,Zone.BATTLEFIELD));
if (targetCard != null) {
permanent.attachTo(targetCard.getId(),game);
}
if (targetPermanent != null) {
targetPermanent.addAttachment(permanent.getId(),game);
}
if (targetPlayer != null) {
targetPlayer.addAttachment(permanent.getId(),game);
}
}
return true;
}","@Override public boolean replaceEvent(GameEvent event,Ability source,Game game){
  Zone fromZone=((ZoneChangeEvent)event).getFromZone();
  Card card=game.getCard(event.getTargetId());
  UUID sourceId=event.getSourceId();
  UUID controllerId=event.getPlayerId();
  if (card.isFaceDown(game)) {
    return false;
  }
  Object object=game.getState().getValue(""String_Node_Str"" + card.getId());
  if (object != null && object instanceof PermanentCard) {
    return false;
  }
  UUID targetId=null;
  MageObject sourceObject=game.getObject(sourceId);
  boolean enchantCardInGraveyard=false;
  if (sourceObject instanceof Spell) {
    if (fromZone.equals(Zone.EXILED)) {
      return false;
    }
  }
  if (sourceObject instanceof StackAbility) {
    StackAbility stackAbility=(StackAbility)sourceObject;
    if (!stackAbility.getEffects().isEmpty()) {
      targetId=stackAbility.getEffects().get(0).getTargetPointer().getFirst(game,stackAbility);
    }
  }
  game.applyEffects();
  if (targetId == null) {
    Target target=card.getSpellAbility().getTargets().get(0);
    enchantCardInGraveyard=target instanceof TargetCardInGraveyard;
    if (target != null) {
      target.clearChosen();
    }
    Player player=game.getPlayer(card.getOwnerId());
    Outcome auraOutcome=Outcome.BoostCreature;
    Ability:     for (    Ability ability : card.getAbilities()) {
      if (ability instanceof SpellAbility) {
        for (        Effect effect : ability.getEffects()) {
          if (effect instanceof AttachEffect) {
            auraOutcome=effect.getOutcome();
            break Ability;
          }
        }
      }
    }
    if (target != null && player != null && player.choose(auraOutcome,target,card.getId(),game)) {
      targetId=target.getFirstTarget();
    }
  }
  Card targetCard=null;
  Permanent targetPermanent=null;
  if (enchantCardInGraveyard) {
    targetCard=game.getCard(targetId);
  }
 else {
    targetPermanent=game.getPermanent(targetId);
  }
  Player targetPlayer=game.getPlayer(targetId);
  if (targetCard != null || targetPermanent != null || targetPlayer != null) {
switch (fromZone) {
case EXILED:
      game.getExile().removeCard(card,game);
    break;
case GRAVEYARD:
  game.getPlayer(card.getOwnerId()).removeFromGraveyard(card,game);
break;
case HAND:
game.getPlayer(card.getOwnerId()).removeFromHand(card,game);
break;
case LIBRARY:
game.getPlayer(card.getOwnerId()).removeFromLibrary(card,game);
break;
default :
}
game.rememberLKI(card.getId(),fromZone,card);
PermanentCard permanent=new PermanentCard(card,card.getOwnerId(),game);
game.getBattlefield().addPermanent(permanent);
card.setZone(Zone.BATTLEFIELD,game);
boolean entered=permanent.entersBattlefield(event.getSourceId(),game,fromZone,true);
game.applyEffects();
if (!entered) {
return false;
}
game.fireEvent(new ZoneChangeEvent(permanent,controllerId,fromZone,Zone.BATTLEFIELD));
if (targetCard != null) {
permanent.attachTo(targetCard.getId(),game);
}
if (targetPermanent != null) {
targetPermanent.addAttachment(permanent.getId(),game);
}
if (targetPlayer != null) {
targetPlayer.addAttachment(permanent.getId(),game);
}
}
return true;
}",0.9929757343550448
158808,"@Override public boolean apply(Game game,Ability source){
  ExileZone exile=game.getExile().getExileZone(exileId);
  Player controller=game.getPlayer(source.getControllerId());
  if (controller != null && exile != null) {
    if (zone == Zone.GRAVEYARD) {
      controller.moveCards(exile,zone,Zone.EXILED,source,game);
    }
 else {
      exile=exile.copy();
      for (      UUID cardId : exile) {
        Card card=game.getCard(cardId);
        Player owner=game.getPlayer(card.getOwnerId());
        if (owner != null) {
switch (zone) {
case BATTLEFIELD:
            card.moveToZone(zone,source.getSourceId(),game,tapped);
          if (!game.isSimulation()) {
            game.informPlayers(controller.getLogName() + ""String_Node_Str"" + card.getName()+ ""String_Node_Str""+ zone.toString().toLowerCase());
          }
        break;
case HAND:
      controller.moveCards(card,Zone.EXILED,Zone.HAND,source,game);
    break;
case LIBRARY:
  controller.moveCardToLibraryWithInfo(card,source.getSourceId(),game,Zone.EXILED,true,true);
break;
case GRAVEYARD:
controller.moveCards(card,Zone.EXILED,Zone.GRAVEYARD,source,game);
break;
default :
card.moveToZone(zone,source.getSourceId(),game,tapped);
if (!game.isSimulation()) {
game.informPlayers(controller.getLogName() + ""String_Node_Str"" + card.getName()+ ""String_Node_Str""+ zone.toString().toLowerCase());
}
}
}
}
game.getExile().getExileZone(exileId).clear();
}
return true;
}
return false;
}","@Override public boolean apply(Game game,Ability source){
  ExileZone exile=game.getExile().getExileZone(exileId);
  Player controller=game.getPlayer(source.getControllerId());
  if (controller != null && exile != null) {
    if (zone == Zone.GRAVEYARD) {
      controller.moveCards(exile,zone,Zone.EXILED,source,game);
    }
 else {
      exile=exile.copy();
      for (      UUID cardId : exile) {
        Card card=game.getCard(cardId);
        Player owner=game.getPlayer(card.getOwnerId());
        if (owner != null) {
switch (zone) {
case BATTLEFIELD:
            card.moveToZone(zone,source.getSourceId(),game,tapped);
          if (!game.isSimulation()) {
            game.informPlayers(controller.getLogName() + ""String_Node_Str"" + card.getLogName()+ ""String_Node_Str""+ zone.toString().toLowerCase());
          }
        break;
case HAND:
      controller.moveCards(card,Zone.EXILED,Zone.HAND,source,game);
    break;
case LIBRARY:
  controller.moveCardToLibraryWithInfo(card,source.getSourceId(),game,Zone.EXILED,true,true);
break;
case GRAVEYARD:
controller.moveCards(card,Zone.EXILED,Zone.GRAVEYARD,source,game);
break;
default :
card.moveToZone(zone,source.getSourceId(),game,tapped);
if (!game.isSimulation()) {
game.informPlayers(controller.getLogName() + ""String_Node_Str"" + card.getLogName()+ ""String_Node_Str""+ zone.toString().toLowerCase());
}
}
}
}
game.getExile().getExileZone(exileId).clear();
}
return true;
}
return false;
}",0.9979267449896336
158809,"@Override public boolean replaceEvent(GameEvent event,Ability source,Game game){
  Player controller=game.getPlayer(source.getControllerId());
  MageObject sourceObject=game.getObject(source.getSourceId());
  if (controller != null && sourceObject != null) {
    Card card=game.getCard(event.getTargetId());
    if (card != null) {
      ZoneChangeEvent zEvent=(ZoneChangeEvent)event;
      Cards cards=new CardsImpl(card);
      controller.revealCards(sourceObject.getIdName(),cards,game);
      controller.moveCardToLibraryWithInfo(card,source.getSourceId(),game,zEvent.getFromZone(),false,true);
      return true;
    }
  }
  return false;
}","@Override public boolean replaceEvent(GameEvent event,Ability source,Game game){
  Player controller=game.getPlayer(source.getControllerId());
  MageObject sourceObject=game.getObject(source.getSourceId());
  if (controller != null && sourceObject != null) {
    Card card=game.getCard(event.getTargetId());
    if (card != null) {
      Cards cards=new CardsImpl(card);
      controller.revealCards(sourceObject.getIdName(),cards,game);
      controller.putCardsOnBottomOfLibrary(cards,game,source,false);
      return true;
    }
  }
  return false;
}",0.5943238731218697
158810,"@Override public boolean moveToZone(Zone zone,UUID sourceId,Game game,boolean flag,ArrayList<UUID> appliedEffects){
  if (this.isCopiedSpell() && !zone.equals(Zone.STACK)) {
    return true;
  }
  throw new UnsupportedOperationException(""String_Node_Str"");
}","@Override public boolean moveToZone(Zone zone,UUID sourceId,Game game,boolean flag,ArrayList<UUID> appliedEffects){
  if (this.isCopiedSpell() && !zone.equals(Zone.STACK)) {
    return true;
  }
  Card card=game.getCard(getSourceId());
  if (card != null) {
    return card.moveToZone(zone,sourceId,game,flag,appliedEffects);
  }
  throw new UnsupportedOperationException(""String_Node_Str"");
}",0.7926267281105991
158811,"/** 
 * Fixes undersized or oversized decks that have been generated. Removes random cards from an oversized deck until it is the correct size. Uses the reserve pool to fill up and undersized deck with cards.
 * @return a fixed list of cards for this deck.
 */
private List<Card> getFixedSpells(){
  Random random=new Random();
  int spellSize=deckCards.size();
  int nonLandSize=(deckSize - landCount);
  if (spellSize < nonLandSize) {
    int spellsNeeded=nonLandSize - spellSize;
    List<Card> spellsToAdd=new ArrayList<>(spellsNeeded);
    for (int i=0; i < spellsNeeded; i++)     spellsToAdd.add(reserveSpells.get(i));
    for (int i=spellsNeeded + 1; i < reserveSpells.size() - 1; i++) {
      int j=random.nextInt(i);
      Card randomCard=reserveSpells.get(j);
      if (isValidSpellCard(randomCard) && j < spellsToAdd.size()) {
        spellsToAdd.set(j,randomCard);
      }
    }
    deckCards.addAll(spellsToAdd);
  }
 else   if (spellSize > (deckSize - landCount)) {
    int spellsRemoved=(spellSize) - (deckSize - landCount);
    for (int i=0; i < spellsRemoved; ++i) {
      deckCards.remove(random.nextInt(deckCards.size()));
    }
  }
  if (deckCards.size() != nonLandSize)   throw new IllegalStateException(""String_Node_Str"");
  return deckCards;
}","/** 
 * Fixes undersized or oversized decks that have been generated. Removes random cards from an oversized deck until it is the correct size. Uses the reserve pool to fill up and undersized deck with cards.
 * @return a fixed list of cards for this deck.
 */
private List<Card> getFixedSpells(){
  Random random=new Random();
  int spellSize=deckCards.size();
  int nonLandSize=(deckSize - landCount);
  if (spellSize < nonLandSize) {
    int spellsNeeded=nonLandSize - spellSize;
    if (reserveSpells.size() < spellsNeeded) {
      throw new IllegalStateException(""String_Node_Str"");
    }
    List<Card> spellsToAdd=new ArrayList<>(spellsNeeded);
    for (int i=0; i < spellsNeeded; i++)     spellsToAdd.add(reserveSpells.get(i));
    for (int i=spellsNeeded + 1; i < reserveSpells.size() - 1; i++) {
      int j=random.nextInt(i);
      Card randomCard=reserveSpells.get(j);
      if (isValidSpellCard(randomCard) && j < spellsToAdd.size()) {
        spellsToAdd.set(j,randomCard);
      }
    }
    deckCards.addAll(spellsToAdd);
  }
 else   if (spellSize > (deckSize - landCount)) {
    int spellsRemoved=(spellSize) - (deckSize - landCount);
    for (int i=0; i < spellsRemoved; ++i) {
      deckCards.remove(random.nextInt(deckCards.size()));
    }
  }
  if (deckCards.size() != nonLandSize) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  return deckCards;
}",0.4300264051301395
158812,"/** 
 * Return a random basic land of the chosen color.
 * @param color the color the basic land should produce.
 * @param basicLands list of information about basic lands from the database.
 * @return a single basic land that produces the color needed.
 */
private static Card getBasicLand(ColoredManaSymbol color,Map<String,List<CardInfo>> basicLands){
  Random random=new Random();
  String landName=DeckGeneratorPool.getBasicLandName(color.toString());
  return basicLands.get(landName).get(random.nextInt(basicLands.size() - 1)).getMockCard().copy();
}","/** 
 * Return a random basic land of the chosen color.
 * @param color the color the basic land should produce.
 * @param basicLands list of information about basic lands from the database.
 * @return a single basic land that produces the color needed.
 */
private static Card getBasicLand(ColoredManaSymbol color,Map<String,List<CardInfo>> basicLands){
  Random random=new Random();
  String landName=DeckGeneratorPool.getBasicLandName(color.toString());
  List<CardInfo> basicLandsInfo=basicLands.get(landName);
  return basicLandsInfo.get(random.nextInt(basicLandsInfo.size() - 1)).getMockCard().copy();
}",0.9313893653516296
158813,"@Override public boolean apply(Game game,Ability source){
  StackObject stackObject=game.getStack().getStackObject(source.getFirstTarget());
  MageObject sourceObject=game.getObject(source.getSourceId());
  if (stackObject != null && sourceObject != null) {
    Targets targets=new Targets();
    Ability sourceAbility;
    MageObject oldTarget=null;
    if (stackObject instanceof Spell) {
      Spell spell=(Spell)stackObject;
      sourceAbility=spell.getSpellAbility();
    }
 else     if (stackObject instanceof StackAbility) {
      StackAbility stackAbility=(StackAbility)stackObject;
      sourceAbility=stackAbility;
    }
 else {
      return false;
    }
    for (    UUID modeId : sourceAbility.getModes().getSelectedModes()) {
      sourceAbility.getModes().setActiveMode(modeId);
      targets.addAll(sourceAbility.getTargets());
    }
    boolean twoTimesTarget=false;
    if (targets.size() == 1 && targets.get(0).getTargets().size() == 1) {
      Target target=targets.get(0);
      if (target.canTarget(stackObject.getControllerId(),source.getSourceId(),sourceAbility,game)) {
        oldTarget=game.getObject(targets.getFirstTarget());
        target.clearChosen();
        target.addTarget(source.getSourceId(),stackObject.getStackAbility(),game);
      }
    }
 else {
      Player player=game.getPlayer(source.getControllerId());
      for (      Target target : targets) {
        for (        UUID targetId : target.getTargets()) {
          MageObject object=game.getObject(targetId);
          String name;
          if (object == null) {
            Player targetPlayer=game.getPlayer(targetId);
            name=targetPlayer.getLogName();
          }
 else {
            name=object.getLogName();
          }
          if (!targetId.equals(source.getSourceId()) && target.getTargets().contains(source.getSourceId())) {
            twoTimesTarget=true;
            continue;
          }
          if (name != null && player.chooseUse(Outcome.Neutral,""String_Node_Str"" + name + ""String_Node_Str""+ sourceObject.getLogName()+ ""String_Node_Str"",source,game)) {
            if (target.canTarget(stackObject.getControllerId(),source.getSourceId(),sourceAbility,game)) {
              oldTarget=game.getObject(targets.getFirstTarget());
              target.remove(targetId);
              target.addTarget(source.getSourceId(),stackObject.getStackAbility(),game);
              break;
            }
          }
        }
      }
    }
    if (oldTarget != null) {
      game.informPlayers(sourceObject.getLogName() + ""String_Node_Str"" + stackObject.getLogName()+ ""String_Node_Str""+ oldTarget.getLogName()+ ""String_Node_Str""+ sourceObject.getLogName());
    }
 else {
      if (twoTimesTarget) {
        game.informPlayers(sourceObject.getLogName() + ""String_Node_Str"" + sourceObject.getLogName()+ ""String_Node_Str""+ stackObject.getLogName());
      }
 else {
        game.informPlayers(sourceObject.getLogName() + ""String_Node_Str"" + sourceObject.getLogName()+ ""String_Node_Str""+ stackObject.getLogName());
      }
    }
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  StackObject stackObject=game.getStack().getStackObject(source.getFirstTarget());
  MageObject sourceObject=game.getObject(source.getSourceId());
  if (stackObject != null && sourceObject != null) {
    Targets targets=new Targets();
    Ability sourceAbility;
    MageObject oldTarget=null;
    if (stackObject instanceof Spell) {
      Spell spell=(Spell)stackObject;
      sourceAbility=spell.getSpellAbility();
    }
 else     if (stackObject instanceof StackAbility) {
      StackAbility stackAbility=(StackAbility)stackObject;
      sourceAbility=stackAbility;
    }
 else {
      return false;
    }
    for (    UUID modeId : sourceAbility.getModes().getSelectedModes()) {
      sourceAbility.getModes().setActiveMode(modeId);
      targets.addAll(sourceAbility.getTargets());
    }
    boolean twoTimesTarget=false;
    if (targets.size() == 1 && targets.get(0).getTargets().size() == 1) {
      Target target=targets.get(0);
      if (target.canTarget(stackObject.getControllerId(),source.getSourceId(),sourceAbility,game)) {
        oldTarget=game.getObject(targets.getFirstTarget());
        target.clearChosen();
        target.addTarget(source.getSourceId(),stackObject.getStackAbility(),game);
      }
    }
 else {
      Player controller=game.getPlayer(source.getControllerId());
      boolean validTargets=false;
      do {
        for (        Target target : targets) {
          for (          UUID targetId : target.getTargets()) {
            MageObject object=game.getObject(targetId);
            String name;
            if (object == null) {
              Player targetPlayer=game.getPlayer(targetId);
              name=targetPlayer.getLogName();
            }
 else {
              name=object.getLogName();
            }
            if (!targetId.equals(source.getSourceId()) && target.getTargets().contains(source.getSourceId())) {
              twoTimesTarget=true;
              continue;
            }
            if (target.canTarget(stackObject.getControllerId(),source.getSourceId(),sourceAbility,game)) {
              validTargets=true;
              if (name != null && controller.chooseUse(Outcome.Neutral,""String_Node_Str"" + name + ""String_Node_Str""+ sourceObject.getLogName()+ ""String_Node_Str"",source,game)) {
                oldTarget=game.getObject(targetId);
                target.remove(targetId);
                target.addTarget(source.getSourceId(),stackObject.getStackAbility(),game);
                break;
              }
            }
          }
          if (oldTarget != null) {
            break;
          }
        }
        if (oldTarget == null) {
          game.informPlayer(controller,""String_Node_Str"");
        }
      }
 while (validTargets && oldTarget == null);
    }
    if (oldTarget != null) {
      game.informPlayers(sourceObject.getLogName() + ""String_Node_Str"" + stackObject.getLogName()+ ""String_Node_Str""+ oldTarget.getLogName()+ ""String_Node_Str""+ sourceObject.getLogName());
    }
 else {
      if (twoTimesTarget) {
        game.informPlayers(sourceObject.getLogName() + ""String_Node_Str"" + sourceObject.getLogName()+ ""String_Node_Str""+ stackObject.getLogName());
      }
 else {
        game.informPlayers(sourceObject.getLogName() + ""String_Node_Str"" + sourceObject.getLogName()+ ""String_Node_Str""+ stackObject.getLogName());
      }
    }
    return true;
  }
  return false;
}",0.6800984312519225
158814,"/** 
 * Inkmoth Nexus has no effect it he attacks becaus it has infect but there are no counters added http://www.mtgsalvation.com/forums/magic-fundamentals/magic-rulings/magic-rulings-archives/296553-melira-sylvok-outcast-vs-inkmoth-nexus
 */
@Test public void testInkmothNexusLoseInfect(){
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"");
  addCard(Zone.BATTLEFIELD,playerB,""String_Node_Str"",1);
  addCard(Zone.BATTLEFIELD,playerB,""String_Node_Str"");
  activateAbility(2,PhaseStep.PRECOMBAT_MAIN,playerB,""String_Node_Str"");
  attack(2,playerB,""String_Node_Str"");
  setStopAt(2,PhaseStep.POSTCOMBAT_MAIN);
  execute();
  assertTapped(""String_Node_Str"",true);
  assertTapped(""String_Node_Str"",true);
  assertCounterCount(playerA,CounterType.POISON,0);
  assertLife(playerA,20);
  assertLife(playerB,20);
}","/** 
 * Inkmoth Nexus has no effect it he attacks becaus it has infect but there are no counters added http://www.mtgsalvation.com/forums/magic-fundamentals/magic-rulings/magic-rulings-archives/296553-melira-sylvok-outcast-vs-inkmoth-nexus
 */
@Test public void testInkmothNexusLoseInfect(){
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"");
  addCard(Zone.HAND,playerA,""String_Node_Str"");
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"",1);
  addCard(Zone.BATTLEFIELD,playerB,""String_Node_Str"",1);
  addCard(Zone.BATTLEFIELD,playerB,""String_Node_Str"");
  castSpell(1,PhaseStep.PRECOMBAT_MAIN,playerA,""String_Node_Str"",""String_Node_Str"");
  activateAbility(2,PhaseStep.PRECOMBAT_MAIN,playerB,""String_Node_Str"");
  attack(2,playerB,""String_Node_Str"");
  setStopAt(2,PhaseStep.POSTCOMBAT_MAIN);
  execute();
  assertGraveyardCount(playerA,""String_Node_Str"",1);
  assertPowerToughness(playerA,""String_Node_Str"",2,2);
  assertTapped(""String_Node_Str"",true);
  assertTapped(""String_Node_Str"",true);
  assertCounterCount(playerA,CounterType.POISON,0);
  assertLife(playerA,20);
  assertLife(playerB,20);
}",0.7427083333333333
158815,"public Card getRightHalfCard(){
  return rightHalfCard;
}","public SplitCardHalf getRightHalfCard(){
  return (SplitCardHalf)rightHalfCard;
}",0.8260869565217391
158816,"public Card getLeftHalfCard(){
  return leftHalfCard;
}","public SplitCardHalf getLeftHalfCard(){
  return (SplitCardHalf)leftHalfCard;
}",0.8208955223880597
158817,"public SplitCard(SplitCard card){
  super(card);
  this.leftHalfCard=card.leftHalfCard.copy();
  this.rightHalfCard=card.rightHalfCard.copy();
}","public SplitCard(SplitCard card){
  super(card);
  this.leftHalfCard=card.getLeftHalfCard().copy();
  ((SplitCardHalf)leftHalfCard).setParentCard(this);
  this.rightHalfCard=card.rightHalfCard.copy();
  ((SplitCardHalf)rightHalfCard).setParentCard(this);
}",0.66
158818,@Override Card copy();,@Override SplitCardHalf copy();,0.8301886792452831
158819,"@Override public SplitCardHalfImpl copy(){
  return new SplitCardHalfImpl(this);
}","@Override public SplitCardHalf copy(){
  return new SplitCardHalfImpl(this);
}",0.975
158820,"@Override public Card getMainCard(){
  return splitCardParent;
}","@Override public SplitCard getMainCard(){
  return splitCardParent;
}",0.962406015037594
158821,"public List<Card> getAllCards(Game game){
  List<Card> cards=new ArrayList<Card>();
  for (  ExileZone exile : exileZones.values()) {
    cards.addAll(exile.getCards(game));
  }
  return cards;
}","public List<Card> getAllCards(Game game){
  List<Card> cards=new ArrayList<>();
  for (  ExileZone exile : exileZones.values()) {
    cards.addAll(exile.getCards(game));
  }
  return cards;
}",0.9896373056994818
158822,"/** 
 * 116.5. Each time a player would get priority, the game first performs all applicable state-based actions as a single event (see rule 704, State-Based Actions), then repeats this process until no state-based actions are performed. Then triggered abilities are put on the stack (see rule 603, Handling Triggered Abilities). These steps repeat in order until no further state-based actions are performed and no abilities trigger. Then the player who would have received priority does so.
 * @return
 */
protected boolean checkStateBasedActions(){
  boolean somethingHappened=false;
  for (  Player player : state.getPlayers().values()) {
    if (!player.hasLost() && ((player.getLife() <= 0 && player.canLoseByZeroOrLessLife()) || player.isEmptyDraw() || player.getCounters().getCount(CounterType.POISON) >= 10)) {
      player.lost(this);
    }
  }
  Iterator<Card> copiedCards=this.getState().getCopiedCards().iterator();
  while (copiedCards.hasNext()) {
    Card card=copiedCards.next();
    Zone zone=state.getZone(card.getId());
    if (zone != Zone.BATTLEFIELD && zone != Zone.STACK) {
switch (zone) {
case GRAVEYARD:
        for (        Player player : getPlayers().values()) {
          if (player.getGraveyard().contains(card.getId())) {
            player.getGraveyard().remove(card);
            break;
          }
        }
      break;
case HAND:
    for (    Player player : getPlayers().values()) {
      if (player.getHand().contains(card.getId())) {
        player.getHand().remove(card);
        break;
      }
    }
  break;
case LIBRARY:
for (Player player : getPlayers().values()) {
  if (player.getLibrary().getCard(card.getId(),this) != null) {
    player.getLibrary().remove(card.getId(),this);
    break;
  }
}
break;
case EXILED:
getExile().removeCard(card,this);
break;
}
copiedCards.remove();
}
}
List<Permanent> planeswalkers=new ArrayList<>();
List<Permanent> legendary=new ArrayList<>();
List<Permanent> worldEnchantment=new ArrayList<>();
for (Permanent perm : getBattlefield().getAllActivePermanents()) {
if (perm.getCardType().contains(CardType.CREATURE)) {
if (perm.getToughness().getValue() <= 0) {
if (movePermanentToGraveyardWithInfo(perm)) {
somethingHappened=true;
continue;
}
}
 else if (perm.getToughness().getValue() <= perm.getDamage() || perm.isDeathtouched()) {
if (perm.destroy(null,this,false)) {
somethingHappened=true;
continue;
}
}
if (perm.getPairedCard() != null) {
Permanent paired=getPermanent(perm.getPairedCard());
if (paired == null || !perm.getControllerId().equals(paired.getControllerId()) || paired.getPairedCard() == null) {
perm.setPairedCard(null);
if (paired != null) {
paired.setPairedCard(null);
}
somethingHappened=true;
}
}
}
 else if (perm.getPairedCard() != null) {
Permanent paired=getPermanent(perm.getPairedCard());
perm.setPairedCard(null);
if (paired != null) {
paired.setPairedCard(null);
}
somethingHappened=true;
}
if (perm.getCardType().contains(CardType.PLANESWALKER)) {
if (perm.getCounters().getCount(CounterType.LOYALTY) == 0) {
if (movePermanentToGraveyardWithInfo(perm)) {
somethingHappened=true;
continue;
}
}
planeswalkers.add(perm);
}
if (perm.getSupertype().contains(""String_Node_Str"")) {
worldEnchantment.add(perm);
}
if (filterAura.match(perm,this)) {
if (perm.getAttachedTo() == null) {
Card card=this.getCard(perm.getId());
if (card != null && !card.getCardType().contains(CardType.CREATURE)) {
if (movePermanentToGraveyardWithInfo(perm)) {
somethingHappened=true;
}
}
}
 else {
if (perm.getSpellAbility().getTargets().isEmpty()) {
Permanent enchanted=this.getPermanent(perm.getAttachedTo());
logger.error(""String_Node_Str"" + perm.getName() + ""String_Node_Str""+ (enchanted == null ? ""String_Node_Str"" : enchanted.getName()));
}
 else {
Target target=perm.getSpellAbility().getTargets().get(0);
if (target instanceof TargetPermanent) {
Permanent attachedTo=getPermanent(perm.getAttachedTo());
if (attachedTo == null || !attachedTo.getAttachments().contains(perm.getId())) {
Card card=this.getCard(perm.getId());
if (card != null && card.getCardType().contains(CardType.CREATURE)) {
UUID wasAttachedTo=perm.getAttachedTo();
perm.attachTo(null,this);
fireEvent(new GameEvent(GameEvent.EventType.UNATTACHED,wasAttachedTo,perm.getId(),perm.getControllerId()));
}
 else {
if (movePermanentToGraveyardWithInfo(perm)) {
  somethingHappened=true;
}
}
}
 else {
Filter auraFilter=perm.getSpellAbility().getTargets().get(0).getFilter();
if (auraFilter instanceof FilterControlledCreaturePermanent) {
if (!((FilterControlledCreaturePermanent)auraFilter).match(attachedTo,perm.getId(),perm.getControllerId(),this) || attachedTo.cantBeEnchantedBy(perm,this)) {
  if (movePermanentToGraveyardWithInfo(perm)) {
    somethingHappened=true;
  }
}
}
 else {
if (!auraFilter.match(attachedTo,this) || attachedTo.cantBeEnchantedBy(perm,this)) {
  Card card=this.getCard(perm.getId());
  if (card != null && card.getCardType().contains(CardType.CREATURE)) {
    UUID wasAttachedTo=perm.getAttachedTo();
    perm.attachTo(null,this);
    fireEvent(new GameEvent(GameEvent.EventType.UNATTACHED,wasAttachedTo,perm.getId(),perm.getControllerId()));
  }
 else {
    if (movePermanentToGraveyardWithInfo(perm)) {
      somethingHappened=true;
    }
  }
}
}
}
}
 else if (target instanceof TargetPlayer) {
Player attachedToPlayer=getPlayer(perm.getAttachedTo());
if (attachedToPlayer == null) {
if (movePermanentToGraveyardWithInfo(perm)) {
somethingHappened=true;
}
}
 else {
Filter auraFilter=perm.getSpellAbility().getTargets().get(0).getFilter();
if (!auraFilter.match(attachedToPlayer,this) || attachedToPlayer.hasProtectionFrom(perm,this)) {
if (movePermanentToGraveyardWithInfo(perm)) {
  somethingHappened=true;
}
}
}
}
}
}
}
if (this.getState().isLegendaryRuleActive() && filterLegendary.match(perm,this)) {
legendary.add(perm);
}
if (filterEquipment.match(perm,this)) {
if (perm.getAttachedTo() != null) {
Permanent creature=getPermanent(perm.getAttachedTo());
if (creature == null || !creature.getAttachments().contains(perm.getId())) {
UUID wasAttachedTo=perm.getAttachedTo();
perm.attachTo(null,this);
fireEvent(new GameEvent(GameEvent.EventType.UNATTACHED,wasAttachedTo,perm.getId(),perm.getControllerId()));
}
 else if (!creature.getCardType().contains(CardType.CREATURE) || creature.hasProtectionFrom(perm,this)) {
if (creature.removeAttachment(perm.getId(),this)) {
somethingHappened=true;
}
}
}
}
if (filterFortification.match(perm,this)) {
if (perm.getAttachedTo() != null) {
Permanent land=getPermanent(perm.getAttachedTo());
if (land == null || !land.getAttachments().contains(perm.getId())) {
perm.attachTo(null,this);
}
 else if (!land.getCardType().contains(CardType.LAND) || land.hasProtectionFrom(perm,this)) {
if (land.removeAttachment(perm.getId(),this)) {
somethingHappened=true;
}
}
}
}
if (perm.getAttachments().size() > 0) {
for (UUID attachmentId : perm.getAttachments()) {
Permanent attachment=getPermanent(attachmentId);
if (attachment != null && (attachment.getCardType().contains(CardType.CREATURE) || !(attachment.getSubtype().contains(""String_Node_Str"") || attachment.getSubtype().contains(""String_Node_Str"") || attachment.getSubtype().contains(""String_Node_Str"")))) {
if (perm.removeAttachment(attachment.getId(),this)) {
somethingHappened=true;
break;
}
}
}
}
if (perm.getCounters().containsKey(CounterType.P1P1) && perm.getCounters().containsKey(CounterType.M1M1)) {
int p1p1=perm.getCounters().getCount(CounterType.P1P1);
int m1m1=perm.getCounters().getCount(CounterType.M1M1);
int min=Math.min(p1p1,m1m1);
perm.getCounters().removeCounter(CounterType.P1P1,min);
perm.getCounters().removeCounter(CounterType.M1M1,min);
}
}
if (planeswalkers.size() > 1) {
for (Permanent planeswalker : planeswalkers) {
for (String planeswalkertype : planeswalker.getSubtype()) {
FilterPlaneswalkerPermanent filterPlaneswalker=new FilterPlaneswalkerPermanent();
filterPlaneswalker.add(new SubtypePredicate(planeswalkertype));
filterPlaneswalker.add(new ControllerIdPredicate(planeswalker.getControllerId()));
if (getBattlefield().contains(filterPlaneswalker,planeswalker.getControllerId(),this,2)) {
Player controller=this.getPlayer(planeswalker.getControllerId());
if (controller != null) {
Target targetPlaneswalkerToKeep=new TargetPermanent(filterPlaneswalker);
targetPlaneswalkerToKeep.setTargetName(new StringBuilder(planeswalker.getName()).append(""String_Node_Str"").toString());
controller.chooseTarget(Outcome.Benefit,targetPlaneswalkerToKeep,null,this);
for (Permanent dupPlaneswalker : this.getBattlefield().getActivePermanents(filterPlaneswalker,planeswalker.getControllerId(),this)) {
if (!targetPlaneswalkerToKeep.getTargets().contains(dupPlaneswalker.getId())) {
movePermanentToGraveyardWithInfo(dupPlaneswalker);
}
}
}
return true;
}
}
}
}
if (legendary.size() > 1) {
for (Permanent legend : legendary) {
FilterPermanent filterLegendName=new FilterPermanent();
filterLegendName.add(new SupertypePredicate(""String_Node_Str""));
filterLegendName.add(new NamePredicate(legend.getName()));
filterLegendName.add(new ControllerIdPredicate(legend.getControllerId()));
if (getBattlefield().contains(filterLegendName,legend.getControllerId(),this,2)) {
Player controller=this.getPlayer(legend.getControllerId());
if (controller != null) {
Target targetLegendaryToKeep=new TargetPermanent(filterLegendName);
targetLegendaryToKeep.setTargetName(new StringBuilder(legend.getName()).append(""String_Node_Str"").toString());
controller.chooseTarget(Outcome.Benefit,targetLegendaryToKeep,null,this);
for (Permanent dupLegend : getBattlefield().getActivePermanents(filterLegendName,legend.getControllerId(),this)) {
if (!targetLegendaryToKeep.getTargets().contains(dupLegend.getId())) {
movePermanentToGraveyardWithInfo(dupLegend);
}
}
}
return true;
}
}
}
if (worldEnchantment.size() > 1) {
int newestCard=-1;
Permanent newestPermanent=null;
for (Permanent permanent : worldEnchantment) {
if (newestCard == -1) {
newestCard=permanent.getCreateOrder();
newestPermanent=permanent;
}
 else if (newestCard < permanent.getCreateOrder()) {
newestCard=permanent.getCreateOrder();
newestPermanent=permanent;
}
 else if (newestCard == permanent.getCreateOrder()) {
newestPermanent=null;
}
}
for (Permanent permanent : worldEnchantment) {
if (newestPermanent != permanent) {
movePermanentToGraveyardWithInfo(permanent);
somethingHappened=true;
}
}
}
return somethingHappened;
}","/** 
 * 116.5. Each time a player would get priority, the game first performs all applicable state-based actions as a single event (see rule 704, State-Based Actions), then repeats this process until no state-based actions are performed. Then triggered abilities are put on the stack (see rule 603, Handling Triggered Abilities). These steps repeat in order until no further state-based actions are performed and no abilities trigger. Then the player who would have received priority does so.
 * @return
 */
protected boolean checkStateBasedActions(){
  boolean somethingHappened=false;
  for (  Player player : state.getPlayers().values()) {
    if (!player.hasLost() && ((player.getLife() <= 0 && player.canLoseByZeroOrLessLife()) || player.isEmptyDraw() || player.getCounters().getCount(CounterType.POISON) >= 10)) {
      player.lost(this);
    }
  }
  Iterator<Card> copiedCards=this.getState().getCopiedCards().iterator();
  while (copiedCards.hasNext()) {
    Card card=copiedCards.next();
    if (card instanceof SplitCardHalf) {
      continue;
    }
    Zone zone=state.getZone(card.getId());
    if (zone != Zone.BATTLEFIELD && zone != Zone.STACK) {
switch (zone) {
case GRAVEYARD:
        for (        Player player : getPlayers().values()) {
          if (player.getGraveyard().contains(card.getId())) {
            player.getGraveyard().remove(card);
            break;
          }
        }
      break;
case HAND:
    for (    Player player : getPlayers().values()) {
      if (player.getHand().contains(card.getId())) {
        player.getHand().remove(card);
        break;
      }
    }
  break;
case LIBRARY:
for (Player player : getPlayers().values()) {
  if (player.getLibrary().getCard(card.getId(),this) != null) {
    player.getLibrary().remove(card.getId(),this);
    break;
  }
}
break;
case EXILED:
getExile().removeCard(card,this);
break;
}
copiedCards.remove();
}
}
List<Permanent> planeswalkers=new ArrayList<>();
List<Permanent> legendary=new ArrayList<>();
List<Permanent> worldEnchantment=new ArrayList<>();
for (Permanent perm : getBattlefield().getAllActivePermanents()) {
if (perm.getCardType().contains(CardType.CREATURE)) {
if (perm.getToughness().getValue() <= 0) {
if (movePermanentToGraveyardWithInfo(perm)) {
somethingHappened=true;
continue;
}
}
 else if (perm.getToughness().getValue() <= perm.getDamage() || perm.isDeathtouched()) {
if (perm.destroy(null,this,false)) {
somethingHappened=true;
continue;
}
}
if (perm.getPairedCard() != null) {
Permanent paired=getPermanent(perm.getPairedCard());
if (paired == null || !perm.getControllerId().equals(paired.getControllerId()) || paired.getPairedCard() == null) {
perm.setPairedCard(null);
if (paired != null) {
paired.setPairedCard(null);
}
somethingHappened=true;
}
}
}
 else if (perm.getPairedCard() != null) {
Permanent paired=getPermanent(perm.getPairedCard());
perm.setPairedCard(null);
if (paired != null) {
paired.setPairedCard(null);
}
somethingHappened=true;
}
if (perm.getCardType().contains(CardType.PLANESWALKER)) {
if (perm.getCounters().getCount(CounterType.LOYALTY) == 0) {
if (movePermanentToGraveyardWithInfo(perm)) {
somethingHappened=true;
continue;
}
}
planeswalkers.add(perm);
}
if (perm.getSupertype().contains(""String_Node_Str"")) {
worldEnchantment.add(perm);
}
if (filterAura.match(perm,this)) {
if (perm.getAttachedTo() == null) {
Card card=this.getCard(perm.getId());
if (card != null && !card.getCardType().contains(CardType.CREATURE)) {
if (movePermanentToGraveyardWithInfo(perm)) {
somethingHappened=true;
}
}
}
 else {
if (perm.getSpellAbility().getTargets().isEmpty()) {
Permanent enchanted=this.getPermanent(perm.getAttachedTo());
logger.error(""String_Node_Str"" + perm.getName() + ""String_Node_Str""+ (enchanted == null ? ""String_Node_Str"" : enchanted.getName()));
}
 else {
Target target=perm.getSpellAbility().getTargets().get(0);
if (target instanceof TargetPermanent) {
Permanent attachedTo=getPermanent(perm.getAttachedTo());
if (attachedTo == null || !attachedTo.getAttachments().contains(perm.getId())) {
Card card=this.getCard(perm.getId());
if (card != null && card.getCardType().contains(CardType.CREATURE)) {
UUID wasAttachedTo=perm.getAttachedTo();
perm.attachTo(null,this);
fireEvent(new GameEvent(GameEvent.EventType.UNATTACHED,wasAttachedTo,perm.getId(),perm.getControllerId()));
}
 else {
if (movePermanentToGraveyardWithInfo(perm)) {
  somethingHappened=true;
}
}
}
 else {
Filter auraFilter=perm.getSpellAbility().getTargets().get(0).getFilter();
if (auraFilter instanceof FilterControlledCreaturePermanent) {
if (!((FilterControlledCreaturePermanent)auraFilter).match(attachedTo,perm.getId(),perm.getControllerId(),this) || attachedTo.cantBeEnchantedBy(perm,this)) {
  if (movePermanentToGraveyardWithInfo(perm)) {
    somethingHappened=true;
  }
}
}
 else {
if (!auraFilter.match(attachedTo,this) || attachedTo.cantBeEnchantedBy(perm,this)) {
  Card card=this.getCard(perm.getId());
  if (card != null && card.getCardType().contains(CardType.CREATURE)) {
    UUID wasAttachedTo=perm.getAttachedTo();
    perm.attachTo(null,this);
    fireEvent(new GameEvent(GameEvent.EventType.UNATTACHED,wasAttachedTo,perm.getId(),perm.getControllerId()));
  }
 else {
    if (movePermanentToGraveyardWithInfo(perm)) {
      somethingHappened=true;
    }
  }
}
}
}
}
 else if (target instanceof TargetPlayer) {
Player attachedToPlayer=getPlayer(perm.getAttachedTo());
if (attachedToPlayer == null) {
if (movePermanentToGraveyardWithInfo(perm)) {
somethingHappened=true;
}
}
 else {
Filter auraFilter=perm.getSpellAbility().getTargets().get(0).getFilter();
if (!auraFilter.match(attachedToPlayer,this) || attachedToPlayer.hasProtectionFrom(perm,this)) {
if (movePermanentToGraveyardWithInfo(perm)) {
  somethingHappened=true;
}
}
}
}
}
}
}
if (this.getState().isLegendaryRuleActive() && filterLegendary.match(perm,this)) {
legendary.add(perm);
}
if (filterEquipment.match(perm,this)) {
if (perm.getAttachedTo() != null) {
Permanent creature=getPermanent(perm.getAttachedTo());
if (creature == null || !creature.getAttachments().contains(perm.getId())) {
UUID wasAttachedTo=perm.getAttachedTo();
perm.attachTo(null,this);
fireEvent(new GameEvent(GameEvent.EventType.UNATTACHED,wasAttachedTo,perm.getId(),perm.getControllerId()));
}
 else if (!creature.getCardType().contains(CardType.CREATURE) || creature.hasProtectionFrom(perm,this)) {
if (creature.removeAttachment(perm.getId(),this)) {
somethingHappened=true;
}
}
}
}
if (filterFortification.match(perm,this)) {
if (perm.getAttachedTo() != null) {
Permanent land=getPermanent(perm.getAttachedTo());
if (land == null || !land.getAttachments().contains(perm.getId())) {
perm.attachTo(null,this);
}
 else if (!land.getCardType().contains(CardType.LAND) || land.hasProtectionFrom(perm,this)) {
if (land.removeAttachment(perm.getId(),this)) {
somethingHappened=true;
}
}
}
}
if (perm.getAttachments().size() > 0) {
for (UUID attachmentId : perm.getAttachments()) {
Permanent attachment=getPermanent(attachmentId);
if (attachment != null && (attachment.getCardType().contains(CardType.CREATURE) || !(attachment.getSubtype().contains(""String_Node_Str"") || attachment.getSubtype().contains(""String_Node_Str"") || attachment.getSubtype().contains(""String_Node_Str"")))) {
if (perm.removeAttachment(attachment.getId(),this)) {
somethingHappened=true;
break;
}
}
}
}
if (perm.getCounters().containsKey(CounterType.P1P1) && perm.getCounters().containsKey(CounterType.M1M1)) {
int p1p1=perm.getCounters().getCount(CounterType.P1P1);
int m1m1=perm.getCounters().getCount(CounterType.M1M1);
int min=Math.min(p1p1,m1m1);
perm.getCounters().removeCounter(CounterType.P1P1,min);
perm.getCounters().removeCounter(CounterType.M1M1,min);
}
}
if (planeswalkers.size() > 1) {
for (Permanent planeswalker : planeswalkers) {
for (String planeswalkertype : planeswalker.getSubtype()) {
FilterPlaneswalkerPermanent filterPlaneswalker=new FilterPlaneswalkerPermanent();
filterPlaneswalker.add(new SubtypePredicate(planeswalkertype));
filterPlaneswalker.add(new ControllerIdPredicate(planeswalker.getControllerId()));
if (getBattlefield().contains(filterPlaneswalker,planeswalker.getControllerId(),this,2)) {
Player controller=this.getPlayer(planeswalker.getControllerId());
if (controller != null) {
Target targetPlaneswalkerToKeep=new TargetPermanent(filterPlaneswalker);
targetPlaneswalkerToKeep.setTargetName(new StringBuilder(planeswalker.getName()).append(""String_Node_Str"").toString());
controller.chooseTarget(Outcome.Benefit,targetPlaneswalkerToKeep,null,this);
for (Permanent dupPlaneswalker : this.getBattlefield().getActivePermanents(filterPlaneswalker,planeswalker.getControllerId(),this)) {
if (!targetPlaneswalkerToKeep.getTargets().contains(dupPlaneswalker.getId())) {
movePermanentToGraveyardWithInfo(dupPlaneswalker);
}
}
}
return true;
}
}
}
}
if (legendary.size() > 1) {
for (Permanent legend : legendary) {
FilterPermanent filterLegendName=new FilterPermanent();
filterLegendName.add(new SupertypePredicate(""String_Node_Str""));
filterLegendName.add(new NamePredicate(legend.getName()));
filterLegendName.add(new ControllerIdPredicate(legend.getControllerId()));
if (getBattlefield().contains(filterLegendName,legend.getControllerId(),this,2)) {
Player controller=this.getPlayer(legend.getControllerId());
if (controller != null) {
Target targetLegendaryToKeep=new TargetPermanent(filterLegendName);
targetLegendaryToKeep.setTargetName(new StringBuilder(legend.getName()).append(""String_Node_Str"").toString());
controller.chooseTarget(Outcome.Benefit,targetLegendaryToKeep,null,this);
for (Permanent dupLegend : getBattlefield().getActivePermanents(filterLegendName,legend.getControllerId(),this)) {
if (!targetLegendaryToKeep.getTargets().contains(dupLegend.getId())) {
movePermanentToGraveyardWithInfo(dupLegend);
}
}
}
return true;
}
}
}
if (worldEnchantment.size() > 1) {
int newestCard=-1;
Permanent newestPermanent=null;
for (Permanent permanent : worldEnchantment) {
if (newestCard == -1) {
newestCard=permanent.getCreateOrder();
newestPermanent=permanent;
}
 else if (newestCard < permanent.getCreateOrder()) {
newestCard=permanent.getCreateOrder();
newestPermanent=permanent;
}
 else if (newestCard == permanent.getCreateOrder()) {
newestPermanent=null;
}
}
for (Permanent permanent : worldEnchantment) {
if (newestPermanent != permanent) {
movePermanentToGraveyardWithInfo(permanent);
somethingHappened=true;
}
}
}
return somethingHappened;
}",0.996970134179772
158823,"private synchronized void target(UUID playerId,final String question,final Collection<? extends Ability> abilities,final boolean required,final Map<String,Serializable> options) throws MageException {
  perform(playerId,new Command(){
    @Override public void execute(    UUID playerId){
      getGameSession(playerId).target(question,new CardsView(abilities,game),null,required,options);
    }
  }
);
}","private synchronized void target(UUID playerId,final String question,final Collection<? extends Ability> abilities,final boolean required,final Map<String,Serializable> options) throws MageException {
  perform(playerId,new Command(){
    @Override public void execute(    UUID playerId){
      CardsView cardsView=new CardsView(abilities,game);
      getGameSession(playerId).target(question,cardsView,null,required,options);
    }
  }
);
}",0.906508875739645
158824,"private ShowCardsDialog showCards(String title,CardsView cards,boolean required,Map<String,Serializable> options,PopUpMenuType popupMenuType){
  hideAll();
  ShowCardsDialog showCards=new ShowCardsDialog();
  JPopupMenu popupMenu=null;
  Listener<Event> eventListener=null;
  if (PopUpMenuType.TRIGGER_ORDER.equals(popupMenuType)) {
    popupMenu=getTriggerOrderPopupMenu();
    eventListener=getTriggerOrderEventListener(showCards);
  }
  showCards.loadCards(title,cards,bigCard,Config.dimensionsEnlarged,gameId,required,options,popupMenu,eventListener);
  return showCards;
}","private ShowCardsDialog showCards(String title,CardsView cards,boolean required,Map<String,Serializable> options,PopUpMenuType popupMenuType){
  hideAll();
  ShowCardsDialog showCards=new ShowCardsDialog();
  JPopupMenu popupMenu=null;
  if (PopUpMenuType.TRIGGER_ORDER.equals(popupMenuType)) {
    popupMenu=popupMenuTriggerOrder;
  }
  showCards.loadCards(title,cards,bigCard,Config.dimensionsEnlarged,gameId,required,options,popupMenu,getShowCardsEventListener(showCards));
  return showCards;
}",0.6437209302325582
158825,"public void handleTriggerOrderPopupMenuEvent(ActionEvent e){
  UUID abilityId=null;
  String abilityRuleText=null;
  if (cardViewPopupMenu instanceof CardView && cardViewPopupMenu.getAbility() != null) {
    abilityId=cardViewPopupMenu.getAbility().getId();
    if (!cardViewPopupMenu.getAbility().getRules().isEmpty() && !cardViewPopupMenu.getAbility().getRules().equals(""String_Node_Str"")) {
      abilityRuleText=cardViewPopupMenu.getAbility().getRules().get(0);
    }
  }
switch (e.getActionCommand()) {
case CMD_AUTO_ORDER_FIRST:
    session.sendPlayerAction(TRIGGER_AUTO_ORDER_ABILITY_FIRST,gameId,abilityId);
  break;
case CMD_AUTO_ORDER_LAST:
session.sendPlayerAction(TRIGGER_AUTO_ORDER_ABILITY_LAST,gameId,abilityId);
break;
case CMD_AUTO_ORDER_NAME_FIRST:
if (abilityRuleText != null) {
session.sendPlayerAction(TRIGGER_AUTO_ORDER_NAME_FIRST,gameId,abilityRuleText);
}
break;
case CMD_AUTO_ORDER_NAME_LAST:
if (abilityRuleText != null) {
session.sendPlayerAction(TRIGGER_AUTO_ORDER_NAME_LAST,gameId,abilityRuleText);
}
break;
case CMD_AUTO_ORDER_RESET_ALL:
session.sendPlayerAction(TRIGGER_AUTO_ORDER_RESET_ALL,gameId,null);
break;
}
}","public void handleTriggerOrderPopupMenuEvent(ActionEvent e){
  UUID abilityId=null;
  String abilityRuleText=null;
  if (cardViewPopupMenu instanceof CardView && cardViewPopupMenu.getAbility() != null) {
    abilityId=cardViewPopupMenu.getAbility().getId();
    if (!cardViewPopupMenu.getAbility().getRules().isEmpty() && !cardViewPopupMenu.getAbility().getRules().get(0).isEmpty()) {
      abilityRuleText=cardViewPopupMenu.getAbility().getRules().get(0);
    }
  }
switch (e.getActionCommand()) {
case CMD_AUTO_ORDER_FIRST:
    session.sendPlayerAction(TRIGGER_AUTO_ORDER_ABILITY_FIRST,gameId,abilityId);
  break;
case CMD_AUTO_ORDER_LAST:
session.sendPlayerAction(TRIGGER_AUTO_ORDER_ABILITY_LAST,gameId,abilityId);
break;
case CMD_AUTO_ORDER_NAME_FIRST:
if (abilityRuleText != null) {
session.sendPlayerAction(TRIGGER_AUTO_ORDER_NAME_FIRST,gameId,abilityRuleText);
}
break;
case CMD_AUTO_ORDER_NAME_LAST:
if (abilityRuleText != null) {
session.sendPlayerAction(TRIGGER_AUTO_ORDER_NAME_LAST,gameId,abilityRuleText);
}
break;
case CMD_AUTO_ORDER_RESET_ALL:
session.sendPlayerAction(TRIGGER_AUTO_ORDER_RESET_ALL,gameId,null);
break;
}
}",0.9829022358614644
158826,"public GamePanel(){
  initComponents();
  createTriggerOrderPupupMenu();
  this.add(popupMenuCardPanel);
  pickNumber=new PickNumberDialog();
  MageFrame.getDesktop().add(pickNumber,JLayeredPane.MODAL_LAYER);
  this.feedbackPanel.setConnectedChatPanel(this.userChatPanel);
  this.stack.setMinOffsetY(STACK_MIN_CARDS_OFFSET_Y);
  this.setLayout(new BorderLayout());
  final JLayeredPane jLayeredBackgroundPane=new JLayeredPane();
  jLayeredBackgroundPane.setSize(1024,768);
  this.add(jLayeredBackgroundPane);
  jLayeredBackgroundPane.add(jSplitPane0,JLayeredPane.DEFAULT_LAYER);
  Map<String,JComponent> myUi=getUIComponents(jLayeredBackgroundPane);
  Plugins.getInstance().updateGamePanel(myUi);
  addComponentListener(new ComponentAdapter(){
    @Override public void componentResized(    ComponentEvent e){
      int width=((JComponent)e.getSource()).getWidth();
      int height=((JComponent)e.getSource()).getHeight();
      jLayeredBackgroundPane.setSize(width,height);
      jSplitPane0.setSize(width,height);
      if (height < storedHeight) {
        pnlBattlefield.setSize(0,200);
      }
      storedHeight=height;
      sizeToScreen();
      if (!initialized) {
        String state=PreferencesDialog.getCachedValue(PreferencesDialog.KEY_BIG_CARD_TOGGLED,null);
        if (state != null && state.equals(""String_Node_Str"")) {
          jSplitPane0.setDividerLocation(1.0);
        }
        initialized=true;
      }
    }
  }
);
}","public GamePanel(){
  initComponents();
  initPopupMenuTriggerOrder();
  pickNumber=new PickNumberDialog();
  MageFrame.getDesktop().add(pickNumber,JLayeredPane.MODAL_LAYER);
  this.feedbackPanel.setConnectedChatPanel(this.userChatPanel);
  this.stack.setMinOffsetY(STACK_MIN_CARDS_OFFSET_Y);
  this.setLayout(new BorderLayout());
  final JLayeredPane jLayeredBackgroundPane=new JLayeredPane();
  jLayeredBackgroundPane.setSize(1024,768);
  this.add(jLayeredBackgroundPane);
  jLayeredBackgroundPane.add(jSplitPane0,JLayeredPane.DEFAULT_LAYER);
  Map<String,JComponent> myUi=getUIComponents(jLayeredBackgroundPane);
  Plugins.getInstance().updateGamePanel(myUi);
  addComponentListener(new ComponentAdapter(){
    @Override public void componentResized(    ComponentEvent e){
      int width=((JComponent)e.getSource()).getWidth();
      int height=((JComponent)e.getSource()).getHeight();
      jLayeredBackgroundPane.setSize(width,height);
      jSplitPane0.setSize(width,height);
      if (height < storedHeight) {
        pnlBattlefield.setSize(0,200);
      }
      storedHeight=height;
      sizeToScreen();
      if (!initialized) {
        String state=PreferencesDialog.getCachedValue(PreferencesDialog.KEY_BIG_CARD_TOGGLED,null);
        if (state != null && state.equals(""String_Node_Str"")) {
          jSplitPane0.setDividerLocation(1.0);
        }
        initialized=true;
      }
    }
  }
);
}",0.9782608695652174
158827,"@Override protected void readLine(String line,DeckCardLists deckList){
  if (line.length() == 0 || line.startsWith(""String_Node_Str"")) {
    return;
  }
  boolean sideboard=false;
  if (line.startsWith(""String_Node_Str"")) {
    line=line.substring(3).trim();
    sideboard=true;
  }
  int delim=line.indexOf(' ');
  String lineNum=line.substring(0,delim).trim();
  String lineName=line.substring(delim).trim();
  try {
    int num=Integer.parseInt(lineNum);
    CardInfo cardInfo=CardRepository.instance.findPreferedCoreExpansionCard(lineName);
    if (cardInfo == null) {
      sbMessage.append(""String_Node_Str"").append(lineName).append(""String_Node_Str"").append(lineCount).append(""String_Node_Str"");
    }
 else {
      for (int i=0; i < num; i++) {
        if (!sideboard) {
          deckList.getCards().add(new DeckCardInfo(cardInfo.getName(),cardInfo.getCardNumber(),cardInfo.getSetCode()));
        }
 else {
          deckList.getSideboard().add(new DeckCardInfo(cardInfo.getName(),cardInfo.getCardNumber(),cardInfo.getSetCode()));
        }
      }
    }
  }
 catch (  NumberFormatException nfe) {
    sbMessage.append(""String_Node_Str"").append(lineNum).append(""String_Node_Str"").append(lineCount).append(""String_Node_Str"");
  }
}","@Override protected void readLine(String line,DeckCardLists deckList){
  if (line.length() == 0 || line.startsWith(""String_Node_Str"")) {
    return;
  }
  boolean sideboard=false;
  if (line.startsWith(""String_Node_Str"")) {
    line=line.substring(3).trim();
    sideboard=true;
  }
  int delim=line.indexOf(' ');
  String lineNum=line.substring(0,delim).trim();
  String lineName=line.substring(delim).trim();
  try {
    int num=Integer.parseInt(lineNum);
    CardInfo cardInfo=CardRepository.instance.findPreferedCoreExpansionCard(lineName,true);
    if (cardInfo == null) {
      sbMessage.append(""String_Node_Str"").append(lineName).append(""String_Node_Str"").append(lineCount).append(""String_Node_Str"");
    }
 else {
      for (int i=0; i < num; i++) {
        if (!sideboard) {
          deckList.getCards().add(new DeckCardInfo(cardInfo.getName(),cardInfo.getCardNumber(),cardInfo.getSetCode()));
        }
 else {
          deckList.getSideboard().add(new DeckCardInfo(cardInfo.getName(),cardInfo.getCardNumber(),cardInfo.getSetCode()));
        }
      }
    }
  }
 catch (  NumberFormatException nfe) {
    sbMessage.append(""String_Node_Str"").append(lineNum).append(""String_Node_Str"").append(lineCount).append(""String_Node_Str"");
  }
}",0.9979879275653925
158828,"@Override protected void readLine(String line,DeckCardLists deckList){
  if (line.length() == 0 || line.startsWith(""String_Node_Str"")) {
    return;
  }
  boolean sideboard=false;
  if (line.startsWith(""String_Node_Str"")) {
    line=line.substring(3).trim();
    sideboard=true;
  }
  int delim=line.indexOf(' ');
  String lineNum=line.substring(0,delim).trim();
  String setCode=""String_Node_Str"";
  if (line.indexOf('[') != -1) {
    int setStart=line.indexOf('[') + 1;
    int setEnd=line.indexOf(']');
    setCode=line.substring(setStart,setEnd).trim();
    delim=setEnd;
  }
  String lineName=line.substring(delim + 1).trim();
  try {
    int num=Integer.parseInt(lineNum);
    CardInfo cardInfo=null;
    if (!setCode.isEmpty()) {
      CardCriteria criteria=new CardCriteria();
      criteria.name(lineName);
      criteria.setCodes(setCode);
      List<CardInfo> cards=null;
      cards=CardRepository.instance.findCards(criteria);
      if (!cards.isEmpty()) {
        cardInfo=cards.get(new Random().nextInt(cards.size()));
      }
    }
 else {
      cardInfo=CardRepository.instance.findPreferedCoreExpansionCard(lineName);
    }
    if (cardInfo == null) {
      sbMessage.append(""String_Node_Str"").append(lineName).append(""String_Node_Str"").append(lineCount).append(""String_Node_Str"");
    }
 else {
      for (int i=0; i < num; i++) {
        if (!sideboard) {
          deckList.getCards().add(new DeckCardInfo(cardInfo.getName(),cardInfo.getCardNumber(),cardInfo.getSetCode()));
        }
 else {
          deckList.getSideboard().add(new DeckCardInfo(cardInfo.getName(),cardInfo.getCardNumber(),cardInfo.getSetCode()));
        }
      }
    }
  }
 catch (  NumberFormatException nfe) {
    sbMessage.append(""String_Node_Str"").append(lineNum).append(""String_Node_Str"").append(lineCount).append(""String_Node_Str"");
  }
}","@Override protected void readLine(String line,DeckCardLists deckList){
  if (line.length() == 0 || line.startsWith(""String_Node_Str"")) {
    return;
  }
  boolean sideboard=false;
  if (line.startsWith(""String_Node_Str"")) {
    line=line.substring(3).trim();
    sideboard=true;
  }
  int delim=line.indexOf(' ');
  String lineNum=line.substring(0,delim).trim();
  String setCode=""String_Node_Str"";
  if (line.indexOf('[') != -1) {
    int setStart=line.indexOf('[') + 1;
    int setEnd=line.indexOf(']');
    setCode=line.substring(setStart,setEnd).trim();
    delim=setEnd;
  }
  String lineName=line.substring(delim + 1).trim();
  try {
    int num=Integer.parseInt(lineNum);
    CardInfo cardInfo=null;
    if (!setCode.isEmpty()) {
      CardCriteria criteria=new CardCriteria();
      criteria.name(lineName);
      criteria.setCodes(setCode);
      List<CardInfo> cards=null;
      cards=CardRepository.instance.findCards(criteria);
      if (!cards.isEmpty()) {
        cardInfo=cards.get(new Random().nextInt(cards.size()));
      }
    }
 else {
      cardInfo=CardRepository.instance.findPreferedCoreExpansionCard(lineName,true);
    }
    if (cardInfo == null) {
      sbMessage.append(""String_Node_Str"").append(lineName).append(""String_Node_Str"").append(lineCount).append(""String_Node_Str"");
    }
 else {
      for (int i=0; i < num; i++) {
        if (!sideboard) {
          deckList.getCards().add(new DeckCardInfo(cardInfo.getName(),cardInfo.getCardNumber(),cardInfo.getSetCode()));
        }
 else {
          deckList.getSideboard().add(new DeckCardInfo(cardInfo.getName(),cardInfo.getCardNumber(),cardInfo.getSetCode()));
        }
      }
    }
  }
 catch (  NumberFormatException nfe) {
    sbMessage.append(""String_Node_Str"").append(lineNum).append(""String_Node_Str"").append(lineCount).append(""String_Node_Str"");
  }
}",0.9986409350366948
158829,"@Override protected void readLine(String line,DeckCardLists deckList){
  if (line.toLowerCase().contains(""String_Node_Str"")) {
    sideboard=true;
    return;
  }
  if (line.startsWith(""String_Node_Str"")) {
    return;
  }
  if (line.length() == 0) {
    emptyLinesInARow++;
    if (emptyLinesInARow > 1) {
      sideboard=true;
    }
    return;
  }
 else {
    emptyLinesInARow=0;
  }
  line=line.replace(""String_Node_Str"",""String_Node_Str"");
  int delim=line.indexOf(' ');
  if (delim < 0) {
    return;
  }
  String lineNum=line.substring(0,delim).trim();
  String lineName=line.substring(delim).replace(""String_Node_Str"",""String_Node_Str"").trim();
  lineName=lineName.replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str"");
  if (lineName.contains(""String_Node_Str"") && !lineName.contains(""String_Node_Str"")) {
    lineName=lineName.replace(""String_Node_Str"",""String_Node_Str"");
  }
  if (lineName.contains(""String_Node_Str"")) {
    lineName=lineName.replace(""String_Node_Str"",""String_Node_Str"");
  }
  if (IGNORE_NAMES.contains(lineName) || IGNORE_NAMES.contains(lineNum)) {
    return;
  }
  try {
    int num=Integer.parseInt(lineNum.replaceAll(""String_Node_Str"",""String_Node_Str""));
    CardInfo cardInfo=CardRepository.instance.findPreferedCoreExpansionCard(lineName);
    if (cardInfo == null) {
      sbMessage.append(""String_Node_Str"").append(lineName).append(""String_Node_Str"").append(lineCount).append(""String_Node_Str"");
    }
 else {
      for (int i=0; i < num; i++) {
        if (!sideboard) {
          deckList.getCards().add(new DeckCardInfo(cardInfo.getName(),cardInfo.getCardNumber(),cardInfo.getSetCode()));
        }
 else {
          deckList.getSideboard().add(new DeckCardInfo(cardInfo.getName(),cardInfo.getCardNumber(),cardInfo.getSetCode()));
        }
      }
    }
  }
 catch (  NumberFormatException nfe) {
    sbMessage.append(""String_Node_Str"").append(lineNum).append(""String_Node_Str"").append(lineCount).append(""String_Node_Str"");
  }
}","@Override protected void readLine(String line,DeckCardLists deckList){
  if (line.toLowerCase().contains(""String_Node_Str"")) {
    sideboard=true;
    return;
  }
  if (line.startsWith(""String_Node_Str"")) {
    return;
  }
  if (line.length() == 0) {
    emptyLinesInARow++;
    if (emptyLinesInARow > 1) {
      sideboard=true;
    }
    return;
  }
 else {
    emptyLinesInARow=0;
  }
  line=line.replace(""String_Node_Str"",""String_Node_Str"");
  int delim=line.indexOf(' ');
  if (delim < 0) {
    return;
  }
  String lineNum=line.substring(0,delim).trim();
  String lineName=line.substring(delim).replace(""String_Node_Str"",""String_Node_Str"").trim();
  lineName=lineName.replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str"");
  if (lineName.contains(""String_Node_Str"") && !lineName.contains(""String_Node_Str"")) {
    lineName=lineName.replace(""String_Node_Str"",""String_Node_Str"");
  }
  if (lineName.contains(""String_Node_Str"")) {
    lineName=lineName.replace(""String_Node_Str"",""String_Node_Str"");
  }
  if (IGNORE_NAMES.contains(lineName) || IGNORE_NAMES.contains(lineNum)) {
    return;
  }
  try {
    int num=Integer.parseInt(lineNum.replaceAll(""String_Node_Str"",""String_Node_Str""));
    CardInfo cardInfo=CardRepository.instance.findPreferedCoreExpansionCard(lineName,true);
    if (cardInfo == null) {
      sbMessage.append(""String_Node_Str"").append(lineName).append(""String_Node_Str"").append(lineCount).append(""String_Node_Str"");
    }
 else {
      for (int i=0; i < num; i++) {
        if (!sideboard) {
          deckList.getCards().add(new DeckCardInfo(cardInfo.getName(),cardInfo.getCardNumber(),cardInfo.getSetCode()));
        }
 else {
          deckList.getSideboard().add(new DeckCardInfo(cardInfo.getName(),cardInfo.getCardNumber(),cardInfo.getSetCode()));
        }
      }
    }
  }
 catch (  NumberFormatException nfe) {
    sbMessage.append(""String_Node_Str"").append(lineNum).append(""String_Node_Str"").append(lineCount).append(""String_Node_Str"");
  }
}",0.9773970973114442
158830,"public List<Card> createBooster(){
  List<Card> booster=new ArrayList<>();
  if (leftCubeCards.isEmpty()) {
    leftCubeCards.addAll(cubeCards);
  }
  for (int i=0; i < boosterSize; i++) {
    boolean done=false;
    int notValid=0;
    while (!done) {
      int index=rnd.nextInt(leftCubeCards.size());
      CardIdentity cardId=leftCubeCards.get(index);
      leftCubeCards.remove(index);
      if (!cardId.getName().isEmpty()) {
        CardInfo cardInfo=null;
        if (!cardId.getExtension().isEmpty()) {
          CardCriteria criteria=new CardCriteria().name(cardId.getName()).setCodes(cardId.extension);
          List<CardInfo> cardList=CardRepository.instance.findCards(criteria);
          if (cardList != null && cardList.size() > 0) {
            cardInfo=cardList.get(0);
          }
        }
 else {
          cardInfo=CardRepository.instance.findPreferedCoreExpansionCard(cardId.getName());
        }
        if (cardInfo != null) {
          booster.add(cardInfo.getCard());
          done=true;
        }
 else {
          logger.warn(new StringBuilder(this.getName()).append(""String_Node_Str"").append(cardId.getName()).append(""String_Node_Str"").append(cardId.extension));
          notValid++;
        }
      }
 else {
        logger.error(new StringBuilder(this.getName()).append(""String_Node_Str"").append(cardId.getName()).append(""String_Node_Str"").append(cardId.extension));
        notValid++;
      }
      if (leftCubeCards.isEmpty()) {
        leftCubeCards.addAll(cubeCards);
      }
      if (notValid > cubeCards.size()) {
        logger.error(new StringBuilder(this.getName()).append(""String_Node_Str""));
        done=true;
      }
    }
  }
  return booster;
}","public List<Card> createBooster(){
  List<Card> booster=new ArrayList<>();
  if (leftCubeCards.isEmpty()) {
    leftCubeCards.addAll(cubeCards);
  }
  for (int i=0; i < boosterSize; i++) {
    boolean done=false;
    int notValid=0;
    while (!done) {
      int index=rnd.nextInt(leftCubeCards.size());
      CardIdentity cardId=leftCubeCards.get(index);
      leftCubeCards.remove(index);
      if (!cardId.getName().isEmpty()) {
        CardInfo cardInfo=null;
        if (!cardId.getExtension().isEmpty()) {
          CardCriteria criteria=new CardCriteria().name(cardId.getName()).setCodes(cardId.extension);
          List<CardInfo> cardList=CardRepository.instance.findCards(criteria);
          if (cardList != null && cardList.size() > 0) {
            cardInfo=cardList.get(0);
          }
        }
 else {
          cardInfo=CardRepository.instance.findPreferedCoreExpansionCard(cardId.getName(),false);
        }
        if (cardInfo != null) {
          booster.add(cardInfo.getCard());
          done=true;
        }
 else {
          logger.warn(new StringBuilder(this.getName()).append(""String_Node_Str"").append(cardId.getName()).append(""String_Node_Str"").append(cardId.extension));
          notValid++;
        }
      }
 else {
        logger.error(new StringBuilder(this.getName()).append(""String_Node_Str"").append(cardId.getName()).append(""String_Node_Str"").append(cardId.extension));
        notValid++;
      }
      if (leftCubeCards.isEmpty()) {
        leftCubeCards.addAll(cubeCards);
      }
      if (notValid > cubeCards.size()) {
        logger.error(new StringBuilder(this.getName()).append(""String_Node_Str""));
        done=true;
      }
    }
  }
  return booster;
}",0.9982332155477032
158831,"@Override public String getText(Mode mode){
  if (staticText != null && !staticText.isEmpty()) {
    return staticText;
  }
  StringBuilder sb=new StringBuilder();
  Target target=mode.getTargets().get(0);
  if (target.getMaxNumberOfTargets() > 1) {
    if (target.getNumberOfTargets() < target.getMaxNumberOfTargets()) {
      sb.append(""String_Node_Str"");
    }
    sb.append(target.getMaxNumberOfTargets()).append(""String_Node_Str"").append(target.getTargetName()).append(""String_Node_Str"");
  }
 else {
    if (!target.getTargetName().toUpperCase().startsWith(""String_Node_Str"")) {
      sb.append(""String_Node_Str"");
    }
    sb.append(target.getTargetName()).append(""String_Node_Str"");
  }
  if (durationPhaseStep != null) {
    sb.append(""String_Node_Str"").append(durationPhaseStep.toString().toLowerCase(Locale.ENGLISH));
  }
  if (!duration.toString().isEmpty()) {
    sb.append(ability.getRule()).append(""String_Node_Str"").append(duration.toString());
  }
  return sb.toString();
}","@Override public String getText(Mode mode){
  if (staticText != null && !staticText.isEmpty()) {
    return staticText;
  }
  StringBuilder sb=new StringBuilder();
  Target target=mode.getTargets().get(0);
  if (target.getMaxNumberOfTargets() > 1) {
    if (target.getNumberOfTargets() < target.getMaxNumberOfTargets()) {
      sb.append(""String_Node_Str"");
    }
    sb.append(target.getMaxNumberOfTargets()).append(""String_Node_Str"").append(target.getTargetName()).append(""String_Node_Str"");
  }
 else {
    if (!target.getTargetName().toUpperCase().startsWith(""String_Node_Str"")) {
      sb.append(""String_Node_Str"");
    }
    sb.append(target.getTargetName()).append(""String_Node_Str"");
  }
  sb.append(ability.getRule());
  if (durationPhaseStep != null) {
    sb.append(""String_Node_Str"").append(durationPhaseStep.toString().toLowerCase(Locale.ENGLISH));
  }
 else   if (!duration.toString().isEmpty()) {
    sb.append(""String_Node_Str"").append(duration.toString());
  }
  return sb.toString();
}",0.9679037111334002
158832,"private void logLastPick(DraftPickView pickView){
  if (!isLogging()) {
    return;
  }
  if (currentBooster != null) {
    String lastPick=getCardName(getLastPick(pickView.getPicks().values()));
    if (lastPick != null) {
      logPick(lastPick);
    }
    currentBooster=null;
  }
  setCurrentBoosterForLog(pickView.getBooster());
  if (currentBooster.length == 1) {
    logPick(currentBooster[0]);
  }
}","private void logLastPick(DraftPickView pickView){
  if (!isLogging()) {
    return;
  }
  if (currentBooster != null) {
    String lastPick=getCardName(getLastPick(pickView.getPicks().values()));
    if (lastPick != null && currentBooster.length > 1) {
      logPick(lastPick);
    }
    currentBooster=null;
  }
  setCurrentBoosterForLog(pickView.getBooster());
  if (currentBooster.length == 1) {
    logPick(currentBooster[0]);
  }
}",0.9655990510083036
158833,"/** 
 * Creates new form DraftPanel 
 */
public DraftPanel(){
  initComponents();
  draftBooster.setOpaque(false);
  draftPicks.setSortSetting(SortSettingDraft.getInstance());
  draftPicks.setOpaque(false);
  popupMenuPickedArea=new JPopupMenu();
  addPopupMenuPickArea();
  this.add(popupMenuPickedArea);
  popupMenuCardPanel=new JPopupMenu();
  addPopupMenuCardPanel();
  this.add(popupMenuCardPanel);
  draftLeftPane.setOpaque(false);
  countdown=new Timer(1000,new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      if (--timeout > 0) {
        setTimeout(timeout);
      }
 else {
        setTimeout(0);
        countdown.stop();
      }
    }
  }
);
}","/** 
 * Creates new form DraftPanel
 */
public DraftPanel(){
  initComponents();
  draftBooster.setOpaque(false);
  draftPicks.setSortSetting(SortSettingDraft.getInstance());
  draftPicks.setOpaque(false);
  popupMenuPickedArea=new JPopupMenu();
  addPopupMenuPickArea();
  this.add(popupMenuPickedArea);
  popupMenuCardPanel=new JPopupMenu();
  addPopupMenuCardPanel();
  this.add(popupMenuCardPanel);
  draftLeftPane.setOpaque(false);
  countdown=new Timer(1000,new ActionListener(){
    @Override public void actionPerformed(    ActionEvent e){
      if (--timeout > 0) {
        setTimeout(timeout);
      }
 else {
        setTimeout(0);
        countdown.stop();
      }
    }
  }
);
}",0.9992769342010124
158834,"@Override public boolean checkTrigger(GameEvent event,Game game){
  StackAbility stackAbility=(StackAbility)game.getStack().getStackObject(event.getSourceId());
  if (stackAbility.getAbilityType() == AbilityType.ACTIVATED) {
    this.getTargets().get(0).add(event.getPlayerId(),game);
    return true;
  }
  return false;
}","@Override public boolean checkTrigger(GameEvent event,Game game){
  StackAbility stackAbility=(StackAbility)game.getStack().getStackObject(event.getSourceId());
  if (stackAbility != null && stackAbility.getAbilityType() == AbilityType.ACTIVATED) {
    this.getTargets().get(0).add(event.getPlayerId(),game);
    return true;
  }
  return false;
}",0.964179104477612
158835,"@Override public void mouseClicked(MouseEvent e){
  this.hideDialog();
}","@Override public void mouseClicked(MouseEvent e){
  if (e.getSource() instanceof CardPanel) {
    this.hideDialog();
  }
}",0.7422680412371134
158836,"@Override public boolean moveCardToHandWithInfo(Card card,UUID sourceId,Game game,boolean withName){
  boolean result=false;
  Zone fromZone=game.getState().getZone(card.getId());
  if (card.moveToZone(Zone.HAND,sourceId,game,false)) {
    if (card instanceof PermanentCard) {
      card=game.getCard(card.getId());
    }
    if (!game.isSimulation()) {
      StringBuilder sb=new StringBuilder(this.getLogName()).append(""String_Node_Str"").append(withName ? card.getLogName() : (card.isFaceDown(game) ? ""String_Node_Str"" : ""String_Node_Str""));
switch (fromZone) {
case EXILED:
        sb.append(""String_Node_Str"");
      break;
default :
    sb.append(fromZone != null ? new StringBuilder(""String_Node_Str"").append(fromZone.toString().toLowerCase(Locale.ENGLISH)).append(""String_Node_Str"") : ""String_Node_Str"");
  break;
}
sb.append(card.getOwnerId().equals(this.getId()) ? ""String_Node_Str"" : ""String_Node_Str"");
game.informPlayers(sb.toString());
}
result=true;
}
return result;
}","@Override public boolean moveCardToHandWithInfo(Card card,UUID sourceId,Game game,boolean withName){
  boolean result=false;
  Zone fromZone=game.getState().getZone(card.getId());
  if (fromZone.equals(Zone.BATTLEFIELD) && !(card instanceof Permanent)) {
    card=game.getPermanent(card.getId());
  }
  if (card.moveToZone(Zone.HAND,sourceId,game,false)) {
    if (card instanceof PermanentCard) {
      card=game.getCard(card.getId());
    }
    if (!game.isSimulation()) {
      game.informPlayers(this.getLogName() + ""String_Node_Str"" + (withName ? card.getLogName() : (card.isFaceDown(game) ? ""String_Node_Str"" : ""String_Node_Str""))+ ""String_Node_Str""+ fromZone.toString().toLowerCase(Locale.ENGLISH)+ ""String_Node_Str""+ (card.getOwnerId().equals(this.getId()) ? ""String_Node_Str"" : ""String_Node_Str""));
    }
    result=true;
  }
  return result;
}",0.5656675749318801
158837,"@Override public boolean apply(Game game,Ability source){
  Player targetPlayer=game.getPlayer(source.getFirstTarget());
  Player controller=game.getPlayer(source.getControllerId());
  MageObject sourceObject=game.getObject(source.getSourceId());
  if (targetPlayer != null && sourceObject != null && controller != null) {
    targetPlayer.revealCards(sourceObject.getName(),targetPlayer.getHand(),game);
    TargetCardInHand target=new TargetCardInHand(filter);
    target.setNotTarget(true);
    Card chosenCard=null;
    if (controller.choose(Outcome.Benefit,targetPlayer.getHand(),target,game)) {
      chosenCard=game.getCard(target.getFirstTarget());
    }
    FilterCard filterNamedCards=new FilterCard();
    if (chosenCard != null) {
      filterNamedCards.add(new NamePredicate(chosenCard.getName()));
    }
 else {
      filterNamedCards.add(new NamePredicate(""String_Node_Str""));
    }
    Cards cardsToExile=new CardsImpl();
    if (chosenCard != null) {
      for (      Card checkCard : targetPlayer.getGraveyard().getCards(game)) {
        if (checkCard.getName().equals(chosenCard.getName())) {
          cardsToExile.add(checkCard);
        }
      }
      TargetCardInHand targetCardsHand=new TargetCardInHand(0,Integer.MAX_VALUE,filterNamedCards);
      controller.chooseTarget(outcome,targetPlayer.getGraveyard(),targetCardsHand,source,game);
      for (      UUID cardId : targetCardsHand.getTargets()) {
        Card card=game.getCard(cardId);
        if (card != null) {
          cardsToExile.add(card);
        }
      }
    }
    if (chosenCard != null || controller.chooseUse(outcome,""String_Node_Str"",source,game)) {
      TargetCardInLibrary targetCardsLibrary=new TargetCardInLibrary(0,Integer.MAX_VALUE,filterNamedCards);
      controller.searchLibrary(targetCardsLibrary,game,targetPlayer.getId());
      for (      UUID cardId : targetCardsLibrary.getTargets()) {
        Card card=game.getCard(cardId);
        if (card != null) {
          cardsToExile.add(card);
        }
      }
    }
    if (!cardsToExile.isEmpty()) {
      controller.moveCards(cardsToExile,null,Zone.EXILED,source,game);
    }
    targetPlayer.shuffleLibrary(game);
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Player targetPlayer=game.getPlayer(source.getFirstTarget());
  Player controller=game.getPlayer(source.getControllerId());
  MageObject sourceObject=game.getObject(source.getSourceId());
  if (targetPlayer != null && sourceObject != null && controller != null) {
    targetPlayer.revealCards(sourceObject.getIdName(),targetPlayer.getHand(),game);
    TargetCard target=new TargetCard(Zone.HAND,filter);
    target.setNotTarget(true);
    Card chosenCard=null;
    if (controller.chooseTarget(Outcome.Benefit,targetPlayer.getHand(),target,source,game)) {
      chosenCard=game.getCard(target.getFirstTarget());
    }
    FilterCard filterNamedCards=new FilterCard();
    if (chosenCard != null) {
      filterNamedCards.add(new NamePredicate(chosenCard.getName()));
      filterNamedCards.setMessage(""String_Node_Str"" + chosenCard.getName());
    }
 else {
      filterNamedCards.add(new NamePredicate(""String_Node_Str""));
    }
    Cards cardsToExile=new CardsImpl();
    if (chosenCard != null) {
      for (      Card checkCard : targetPlayer.getGraveyard().getCards(game)) {
        if (checkCard.getName().equals(chosenCard.getName())) {
          cardsToExile.add(checkCard);
        }
      }
      TargetCard targetCardsHand=new TargetCard(0,Integer.MAX_VALUE,Zone.HAND,filterNamedCards);
      controller.chooseTarget(outcome,targetPlayer.getHand(),targetCardsHand,source,game);
      for (      UUID cardId : targetCardsHand.getTargets()) {
        Card card=game.getCard(cardId);
        if (card != null) {
          cardsToExile.add(card);
        }
      }
    }
    if (chosenCard != null || controller.chooseUse(outcome,""String_Node_Str"",source,game)) {
      TargetCardInLibrary targetCardsLibrary=new TargetCardInLibrary(0,Integer.MAX_VALUE,filterNamedCards);
      controller.searchLibrary(targetCardsLibrary,game,targetPlayer.getId());
      for (      UUID cardId : targetCardsLibrary.getTargets()) {
        Card card=game.getCard(cardId);
        if (card != null) {
          cardsToExile.add(card);
        }
      }
    }
    if (!cardsToExile.isEmpty()) {
      controller.moveCards(cardsToExile,null,Zone.EXILED,source,game);
    }
    targetPlayer.shuffleLibrary(game);
    return true;
  }
  return false;
}",0.8822355289421158
158838,"private static List<Class> findClasses(File directory,String packageName,Class<?> type){
  List<Class> cards=new ArrayList<Class>();
  if (!directory.exists()) {
    return cards;
  }
  for (  File file : directory.listFiles()) {
    if (file.getName().endsWith(""String_Node_Str"")) {
      try {
        Class<?> clazz=Class.forName(packageName + '.' + file.getName().substring(0,file.getName().length() - 6));
        if (type.isAssignableFrom(clazz)) {
          cards.add(clazz);
        }
      }
 catch (      ClassNotFoundException ex) {
      }
    }
  }
  return cards;
}","private static List<Class> findClasses(File directory,String packageName,Class<?> type){
  List<Class> cards=new ArrayList<>();
  if (!directory.exists()) {
    return cards;
  }
  for (  File file : directory.listFiles()) {
    if (file.getName().endsWith(""String_Node_Str"")) {
      try {
        Class<?> clazz=Class.forName(packageName + '.' + file.getName().substring(0,file.getName().length() - 6));
        if (type.isAssignableFrom(clazz)) {
          cards.add(clazz);
        }
      }
 catch (      ClassNotFoundException ex) {
      }
    }
  }
  return cards;
}",0.9956634865568084
158839,"private static List<Class> findClassesInJar(File file,List<String> packages,Class<?> type){
  List<Class> cards=new ArrayList<Class>();
  if (!file.exists()) {
    return cards;
  }
  JarInputStream jarFile=null;
  try {
    jarFile=new JarInputStream(new FileInputStream(file));
    while (true) {
      JarEntry jarEntry=jarFile.getNextJarEntry();
      if (jarEntry == null) {
        break;
      }
      if (jarEntry.getName().endsWith(""String_Node_Str"")) {
        String className=jarEntry.getName().replace('/','.').replace(""String_Node_Str"",""String_Node_Str"");
        int packageNameEnd=className.lastIndexOf('.');
        String packageName=packageNameEnd != -1 ? className.substring(0,packageNameEnd) : ""String_Node_Str"";
        if (packages.contains(packageName)) {
          Class<?> clazz;
          try {
            clazz=Class.forName(className);
            if (type.isAssignableFrom(clazz)) {
              cards.add(clazz);
            }
          }
 catch (          ClassNotFoundException ex) {
          }
        }
      }
    }
  }
 catch (  IOException ex) {
  }
 finally {
    try {
      jarFile.close();
    }
 catch (    IOException ex) {
    }
  }
  return cards;
}","private static List<Class> findClassesInJar(File file,List<String> packages,Class<?> type){
  List<Class> cards=new ArrayList<>();
  if (!file.exists()) {
    return cards;
  }
  JarInputStream jarFile=null;
  try {
    jarFile=new JarInputStream(new FileInputStream(file));
    while (true) {
      JarEntry jarEntry=jarFile.getNextJarEntry();
      if (jarEntry == null) {
        break;
      }
      if (jarEntry.getName().endsWith(""String_Node_Str"")) {
        String className=jarEntry.getName().replace(""String_Node_Str"",""String_Node_Str"").replace('/','.');
        int packageNameEnd=className.lastIndexOf('.');
        String packageName=packageNameEnd != -1 ? className.substring(0,packageNameEnd) : ""String_Node_Str"";
        if (packages.contains(packageName)) {
          Class<?> clazz;
          try {
            clazz=Class.forName(className);
            if (type.isAssignableFrom(clazz)) {
              cards.add(clazz);
            }
          }
 catch (          ClassNotFoundException ex) {
          }
        }
      }
    }
  }
 catch (  IOException ex) {
  }
 finally {
    try {
      jarFile.close();
    }
 catch (    IOException ex) {
    }
  }
  return cards;
}",0.960267670430782
158840,"@Override public boolean replaceEvent(GameEvent event,Ability source,Game game){
  Zone fromZone=((ZoneChangeEvent)event).getFromZone();
  Card card=game.getCard(event.getTargetId());
  UUID sourceId=event.getSourceId();
  UUID controllerId=event.getPlayerId();
  if (card.isFaceDown(game)) {
    return false;
  }
  Object object=game.getState().getValue(""String_Node_Str"" + card.getId());
  if (object != null && object instanceof PermanentCard) {
    return false;
  }
  UUID targetId=null;
  MageObject sourceObject=game.getObject(sourceId);
  boolean enchantCardInGraveyard=false;
  if (sourceObject instanceof Spell) {
    if (fromZone.equals(Zone.EXILED)) {
      return false;
    }
  }
  if (sourceObject instanceof StackAbility) {
    StackAbility stackAbility=(StackAbility)sourceObject;
    if (!stackAbility.getEffects().isEmpty()) {
      targetId=stackAbility.getEffects().get(0).getTargetPointer().getFirst(game,stackAbility);
    }
  }
  if (targetId == null) {
    Target target=card.getSpellAbility().getTargets().get(0);
    enchantCardInGraveyard=target instanceof TargetCardInGraveyard;
    if (enchantCardInGraveyard && target != null) {
      target.clearChosen();
    }
    Player player=game.getPlayer(card.getOwnerId());
    Outcome auraOutcome=Outcome.BoostCreature;
    Ability:     for (    Ability ability : card.getAbilities()) {
      if (ability instanceof SpellAbility) {
        for (        Effect effect : ability.getEffects()) {
          if (effect instanceof AttachEffect) {
            auraOutcome=effect.getOutcome();
            break Ability;
          }
        }
      }
    }
    if (target != null && player != null && player.choose(auraOutcome,target,card.getId(),game)) {
      targetId=target.getFirstTarget();
    }
  }
  Card targetCard=null;
  Permanent targetPermanent=null;
  if (enchantCardInGraveyard) {
    targetCard=game.getCard(targetId);
  }
 else {
    targetPermanent=game.getPermanent(targetId);
  }
  Player targetPlayer=game.getPlayer(targetId);
  if (targetCard != null || targetPermanent != null || targetPlayer != null) {
switch (fromZone) {
case EXILED:
      game.getExile().removeCard(card,game);
    break;
case GRAVEYARD:
  game.getPlayer(card.getOwnerId()).removeFromGraveyard(card,game);
break;
case HAND:
game.getPlayer(card.getOwnerId()).removeFromHand(card,game);
break;
case LIBRARY:
game.getPlayer(card.getOwnerId()).removeFromLibrary(card,game);
break;
default :
}
game.rememberLKI(card.getId(),fromZone,card);
PermanentCard permanent=new PermanentCard(card,card.getOwnerId(),game);
game.getBattlefield().addPermanent(permanent);
card.setZone(Zone.BATTLEFIELD,game);
game.applyEffects();
boolean entered=permanent.entersBattlefield(event.getSourceId(),game,fromZone,true);
game.applyEffects();
if (!entered) {
return false;
}
game.fireEvent(new ZoneChangeEvent(permanent,controllerId,fromZone,Zone.BATTLEFIELD));
if (targetCard != null) {
permanent.attachTo(targetCard.getId(),game);
}
if (targetPermanent != null) {
targetPermanent.addAttachment(permanent.getId(),game);
}
if (targetPlayer != null) {
targetPlayer.addAttachment(permanent.getId(),game);
}
}
return true;
}","@Override public boolean replaceEvent(GameEvent event,Ability source,Game game){
  Zone fromZone=((ZoneChangeEvent)event).getFromZone();
  Card card=game.getCard(event.getTargetId());
  UUID sourceId=event.getSourceId();
  UUID controllerId=event.getPlayerId();
  if (card.isFaceDown(game)) {
    return false;
  }
  Object object=game.getState().getValue(""String_Node_Str"" + card.getId());
  if (object != null && object instanceof PermanentCard) {
    return false;
  }
  UUID targetId=null;
  MageObject sourceObject=game.getObject(sourceId);
  boolean enchantCardInGraveyard=false;
  if (sourceObject instanceof Spell) {
    if (fromZone.equals(Zone.EXILED)) {
      return false;
    }
  }
  if (sourceObject instanceof StackAbility) {
    StackAbility stackAbility=(StackAbility)sourceObject;
    if (!stackAbility.getEffects().isEmpty()) {
      targetId=stackAbility.getEffects().get(0).getTargetPointer().getFirst(game,stackAbility);
    }
  }
  if (targetId == null) {
    Target target=card.getSpellAbility().getTargets().get(0);
    enchantCardInGraveyard=target instanceof TargetCardInGraveyard;
    if (target != null) {
      target.clearChosen();
    }
    Player player=game.getPlayer(card.getOwnerId());
    Outcome auraOutcome=Outcome.BoostCreature;
    Ability:     for (    Ability ability : card.getAbilities()) {
      if (ability instanceof SpellAbility) {
        for (        Effect effect : ability.getEffects()) {
          if (effect instanceof AttachEffect) {
            auraOutcome=effect.getOutcome();
            break Ability;
          }
        }
      }
    }
    if (target != null && player != null && player.choose(auraOutcome,target,card.getId(),game)) {
      targetId=target.getFirstTarget();
    }
  }
  Card targetCard=null;
  Permanent targetPermanent=null;
  if (enchantCardInGraveyard) {
    targetCard=game.getCard(targetId);
  }
 else {
    targetPermanent=game.getPermanent(targetId);
  }
  Player targetPlayer=game.getPlayer(targetId);
  if (targetCard != null || targetPermanent != null || targetPlayer != null) {
switch (fromZone) {
case EXILED:
      game.getExile().removeCard(card,game);
    break;
case GRAVEYARD:
  game.getPlayer(card.getOwnerId()).removeFromGraveyard(card,game);
break;
case HAND:
game.getPlayer(card.getOwnerId()).removeFromHand(card,game);
break;
case LIBRARY:
game.getPlayer(card.getOwnerId()).removeFromLibrary(card,game);
break;
default :
}
game.rememberLKI(card.getId(),fromZone,card);
PermanentCard permanent=new PermanentCard(card,card.getOwnerId(),game);
game.getBattlefield().addPermanent(permanent);
card.setZone(Zone.BATTLEFIELD,game);
game.applyEffects();
boolean entered=permanent.entersBattlefield(event.getSourceId(),game,fromZone,true);
game.applyEffects();
if (!entered) {
return false;
}
game.fireEvent(new ZoneChangeEvent(permanent,controllerId,fromZone,Zone.BATTLEFIELD));
if (targetCard != null) {
permanent.attachTo(targetCard.getId(),game);
}
if (targetPermanent != null) {
targetPermanent.addAttachment(permanent.getId(),game);
}
if (targetPlayer != null) {
targetPlayer.addAttachment(permanent.getId(),game);
}
}
return true;
}",0.9958651399491094
158841,"@Override public boolean apply(Game game,Ability source){
  Permanent p=game.getPermanent(source.getSourceId());
  if (p != null) {
    int amount=p.getCounters().getCount(CounterType.TIME);
    if (amount > 0) {
      p.removeCounters(CounterType.TIME.createInstance(),game);
    }
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Permanent p=game.getPermanent(source.getSourceId());
  if (p != null) {
    int amount=p.getCounters().getCount(CounterType.TIME);
    if (amount > 0) {
      p.removeCounters(CounterType.TIME.createInstance(),game);
      game.informPlayers(""String_Node_Str"" + p.getLogName() + ""String_Node_Str""+ amount+ ""String_Node_Str"");
    }
    return true;
  }
  return false;
}",0.8548601864181092
158842,"@Override public String getRule(){
  return new StringBuilder(""String_Node_Str"").append(vanishingAmount).append(""String_Node_Str"").append(CardUtil.numberToText(vanishingAmount)).append(""String_Node_Str"").toString();
}","@Override public String getRule(){
  return ""String_Node_Str"" + vanishingAmount + ""String_Node_Str""+ CardUtil.numberToText(vanishingAmount)+ ""String_Node_Str"";
}",0.798941798941799
158843,"@Override public boolean checkTrigger(GameEvent event,Game game){
}","@Override public boolean checkTrigger(GameEvent event,Game game){
  if (((DamagedPlayerEvent)event).isCombatDamage() && game.getOpponents(this.controllerId).contains(((DamagedPlayerEvent)event).getPlayerId())) {
    Permanent creature=game.getPermanent(event.getSourceId());
    if (creature != null && creature.getControllerId().equals(controllerId)) {
      return true;
    }
  }
  return false;
}",0.2869379014989293
158844,"@Override public boolean apply(Game game,Ability source){
  int maxDiscarded=0;
  Player sourcePlayer=game.getPlayer(source.getControllerId());
  for (  UUID playerId : sourcePlayer.getInRange()) {
    Player player=game.getPlayer(playerId);
    if (player != null) {
      int discarded=0;
      for (      Card c : player.getHand().getCards(game)) {
        if (player.discard(c,source,game))         discarded++;
      }
      if (discarded > maxDiscarded)       maxDiscarded=discarded;
    }
  }
  for (  UUID playerId : sourcePlayer.getInRange()) {
    Player player=game.getPlayer(playerId);
    if (player != null) {
      player.drawCards(maxDiscarded,game);
    }
  }
  return true;
}","@Override public boolean apply(Game game,Ability source){
  int maxDiscarded=0;
  Player controller=game.getPlayer(source.getControllerId());
  for (  UUID playerId : game.getState().getPlayersInRange(controller.getId(),game)) {
    Player player=game.getPlayer(playerId);
    if (player != null) {
      int discarded=player.getHand().size();
      player.discard(discarded,false,source,game);
      if (discarded > maxDiscarded) {
        maxDiscarded=discarded;
      }
    }
  }
  for (  UUID playerId : game.getState().getPlayersInRange(controller.getId(),game)) {
    Player player=game.getPlayer(playerId);
    if (player != null) {
      player.drawCards(maxDiscarded,game);
    }
  }
  return true;
}",0.7731811697574893
158845,"/** 
 * One of my opponents in a multiplayer game had a Bloodchief Ascension in play. I took lethal damage on my turn,  but he didn't get a counter on Bloodchief Ascension at my end step. I think he should, even though I had left  the game from dying, because of: 800.4g. If a player leaves the game during his or her turn, that turn continues to its completion without an  active player. If the active player would receive priority, instead the next player in turn order receives priority, or the top object on the stack resolves, or the phase or step ends, whichever is appropriate.
 */
@Test public void testBloodchiefAscension(){
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"");
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"",3);
  addCard(Zone.HAND,playerA,""String_Node_Str"");
  addCard(Zone.BATTLEFIELD,playerD,""String_Node_Str"",3);
  addCard(Zone.HAND,playerD,""String_Node_Str"");
  addCard(Zone.BATTLEFIELD,playerC,""String_Node_Str"",3);
  addCard(Zone.HAND,playerC,""String_Node_Str"");
  addCard(Zone.BATTLEFIELD,playerB,""String_Node_Str"",21);
  addCard(Zone.HAND,playerB,""String_Node_Str"");
  castSpell(1,PhaseStep.PRECOMBAT_MAIN,playerA,""String_Node_Str"",playerA);
  setChoice(playerA,""String_Node_Str"");
  castSpell(2,PhaseStep.PRECOMBAT_MAIN,playerD,""String_Node_Str"",playerD);
  setChoice(playerD,""String_Node_Str"");
  castSpell(3,PhaseStep.PRECOMBAT_MAIN,playerC,""String_Node_Str"",playerC);
  setChoice(playerC,""String_Node_Str"");
  castSpell(4,PhaseStep.PRECOMBAT_MAIN,playerB,""String_Node_Str"",playerB);
  setChoice(playerB,""String_Node_Str"");
  setStopAt(4,PhaseStep.END_TURN);
  execute();
  assertLife(playerA,18);
  assertLife(playerB,0);
  assertLife(playerC,18);
  assertLife(playerD,18);
  Assert.assertTrue(""String_Node_Str"",playerB.hasLost());
  assertGraveyardCount(playerA,""String_Node_Str"",1);
  assertGraveyardCount(playerC,""String_Node_Str"",1);
  assertGraveyardCount(playerD,""String_Node_Str"",1);
  assertCounterCount(""String_Node_Str"",CounterType.QUEST,2);
}","/** 
 * One of my opponents in a multiplayer game had a Bloodchief Ascension in play. I took lethal damage on my turn, but he didn't get a counter on Bloodchief Ascension at my end step. I think he should, even though I had left the game from dying, because of: 800.4g. If a player leaves the game during his or her turn, that turn continues to its completion without an active player. If the active player would receive priority, instead the next player in turn order receives priority, or the top object on the stack resolves, or the phase or step ends, whichever is appropriate.
 */
@Test public void testBloodchiefAscension(){
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"");
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"",3);
  addCard(Zone.HAND,playerA,""String_Node_Str"");
  addCard(Zone.BATTLEFIELD,playerD,""String_Node_Str"",3);
  addCard(Zone.HAND,playerD,""String_Node_Str"");
  addCard(Zone.BATTLEFIELD,playerC,""String_Node_Str"",3);
  addCard(Zone.HAND,playerC,""String_Node_Str"");
  addCard(Zone.BATTLEFIELD,playerB,""String_Node_Str"",21);
  addCard(Zone.HAND,playerB,""String_Node_Str"");
  castSpell(1,PhaseStep.PRECOMBAT_MAIN,playerA,""String_Node_Str"",playerA);
  setChoice(playerA,""String_Node_Str"");
  castSpell(2,PhaseStep.PRECOMBAT_MAIN,playerD,""String_Node_Str"",playerD);
  setChoice(playerD,""String_Node_Str"");
  castSpell(3,PhaseStep.PRECOMBAT_MAIN,playerC,""String_Node_Str"",playerC);
  setChoice(playerC,""String_Node_Str"");
  castSpell(4,PhaseStep.PRECOMBAT_MAIN,playerB,""String_Node_Str"",playerB);
  setChoice(playerB,""String_Node_Str"");
  setStopAt(4,PhaseStep.END_TURN);
  execute();
  assertLife(playerA,18);
  assertLife(playerB,0);
  assertLife(playerC,18);
  assertLife(playerD,18);
  Assert.assertTrue(""String_Node_Str"",playerB.hasLost());
  assertGraveyardCount(playerA,""String_Node_Str"",1);
  assertGraveyardCount(playerC,""String_Node_Str"",1);
  assertGraveyardCount(playerD,""String_Node_Str"",1);
  assertCounterCount(""String_Node_Str"",CounterType.QUEST,2);
}",0.9992494370778084
158846,"@Override public boolean checkTrigger(GameEvent event,Game game){
  if (((ZoneChangeEvent)event).getToZone() == Zone.GRAVEYARD) {
    Card card=game.getCard(event.getTargetId());
    if (card != null && filter.match(card,getSourceId(),getControllerId(),game)) {
switch (setTargetPointer) {
case CARD:
        for (        Effect effect : getEffects()) {
          effect.setTargetPointer(new FixedTarget(card.getId()));
        }
      break;
case PLAYER:
    for (    Effect effect : getEffects()) {
      effect.setTargetPointer(new FixedTarget(card.getOwnerId()));
    }
  break;
}
return true;
}
}
return false;
}","@Override public boolean checkTrigger(GameEvent event,Game game){
  if (((ZoneChangeEvent)event).getToZone() == Zone.GRAVEYARD) {
    Card card=game.getCard(event.getTargetId());
    if (card != null && filter.match(card,getSourceId(),getControllerId(),game)) {
switch (setTargetPointer) {
case CARD:
        for (        Effect effect : getEffects()) {
          effect.setTargetPointer(new FixedTarget(card.getId(),card.getZoneChangeCounter(game)));
        }
      break;
case PLAYER:
    for (    Effect effect : getEffects()) {
      effect.setTargetPointer(new FixedTarget(card.getOwnerId(),0));
    }
  break;
}
return true;
}
}
return false;
}",0.973186119873817
158847,"public ConditionalTriggeredAbility(final ConditionalTriggeredAbility triggered){
  super(triggered);
  this.ability=triggered.ability;
  this.condition=triggered.condition;
  this.text=triggered.text;
}","public ConditionalTriggeredAbility(final ConditionalTriggeredAbility triggered){
  super(triggered);
  this.ability=triggered.ability.copy();
  this.condition=triggered.condition;
  this.text=triggered.text;
}",0.9829683698296836
158848,"@Override public Effects getEffects(){
  return ability.getEffects();
}","@Override public Effects getEffects(Game game,EffectType effectType){
  return ability.getEffects(game,effectType);
}",0.7553191489361702
158849,"@Override public boolean applies(GameEvent event,Ability source,Game game){
  MageObject object=game.getObject(event.getSourceId());
  return object != null && object.getName().equals(game.getState().getValue(source.getSourceId().toString() + NameACardEffect.INFO_KEY));
}","@Override public boolean applies(GameEvent event,Ability source,Game game){
  MageObject object=game.getObject(event.getSourceId());
  return object != null && !object.isCopy() && object.getName().equals(game.getState().getValue(source.getSourceId().toString() + NameACardEffect.INFO_KEY));
}",0.9645390070921984
158850,"/** 
 * Adds the ability to continuous or triggered abilities
 * @param attachedTo
 * @param ability
 */
public void addOtherAbility(Card attachedTo,Ability ability){
  ability.setSourceId(attachedTo.getId());
  ability.setControllerId(attachedTo.getOwnerId());
  if (!cardState.containsKey(attachedTo.getId())) {
    cardState.put(attachedTo.getId(),new CardState());
  }
  cardState.get(attachedTo.getId()).addAbility(ability);
  addAbility(ability,attachedTo.getId(),attachedTo);
}","/** 
 * Adds the ability to continuous or triggered abilities
 * @param attachedTo
 * @param ability
 */
public void addOtherAbility(Card attachedTo,Ability ability){
  Ability newAbility;
  if (ability instanceof MageSingleton) {
    newAbility=ability;
  }
 else {
    newAbility=ability.copy();
  }
  newAbility.setSourceId(attachedTo.getId());
  newAbility.setControllerId(attachedTo.getOwnerId());
  if (!cardState.containsKey(attachedTo.getId())) {
    cardState.put(attachedTo.getId(),new CardState());
  }
  cardState.get(attachedTo.getId()).addAbility(newAbility);
  addAbility(newAbility,attachedTo.getId(),attachedTo);
}",0.8035874439461883
158851,"public ThrummingStoneGainAbilitySpellsEffect(final ThrummingStoneGainAbilitySpellsEffect effect){
  super(effect);
  this.ability=effect.ability;
  this.filter=effect.filter;
}","public ThrummingStoneGainAbilitySpellsEffect(final ThrummingStoneGainAbilitySpellsEffect effect){
  super(effect);
  this.ability=effect.ability.copy();
  this.filter=effect.filter.copy();
}",0.9617486338797814
158852,"@Test @Ignore public void testApplyForNoneRippleCardsWhenMultiRipple() throws Exception {
  removeAllCardsFromLibrary(playerA);
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"");
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"");
  addCard(Zone.HAND,playerA,""String_Node_Str"");
  addCard(Zone.LIBRARY,playerA,""String_Node_Str"");
  addCard(Zone.LIBRARY,playerA,""String_Node_Str"",3);
  addCard(Zone.LIBRARY,playerA,""String_Node_Str"");
  skipInitShuffling();
  castSpell(1,PhaseStep.PRECOMBAT_MAIN,playerA,""String_Node_Str"");
  setChoice(playerA,""String_Node_Str"");
  setStopAt(2,PhaseStep.POSTCOMBAT_MAIN);
  execute();
  assertPermanentCount(playerA,""String_Node_Str"",3);
}","@Test public void testApplyForNoneRippleCardsWhenMultiRipple() throws Exception {
  removeAllCardsFromLibrary(playerA);
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"");
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"");
  addCard(Zone.HAND,playerA,""String_Node_Str"");
  addCard(Zone.LIBRARY,playerA,""String_Node_Str"");
  addCard(Zone.LIBRARY,playerA,""String_Node_Str"",3);
  addCard(Zone.LIBRARY,playerA,""String_Node_Str"");
  skipInitShuffling();
  castSpell(1,PhaseStep.PRECOMBAT_MAIN,playerA,""String_Node_Str"");
  setChoice(playerA,""String_Node_Str"");
  setStopAt(2,PhaseStep.POSTCOMBAT_MAIN);
  execute();
  assertPermanentCount(playerA,""String_Node_Str"",3);
}",0.9940828402366864
158853,"@Override public boolean apply(Game game,Ability source){
  DynamicValue value=new MultikickerCount();
  int damage=value.calculate(game,source,this) * 2;
  Player player=game.getPlayer(source.getFirstTarget());
  if (player != null) {
    player.damage(damage,id,game,false,true);
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  DynamicValue value=new MultikickerCount();
  int damage=value.calculate(game,source,this) * 2;
  Player player=game.getPlayer(source.getFirstTarget());
  if (player != null) {
    player.damage(damage,source.getSourceId(),game,false,true);
    return true;
  }
  return false;
}",0.9665653495440728
158854,"/** 
 * Returns a text suffix for the game log, that can be added to the cast message.
 * @param position - if there are multiple costs, it's the postion the cost is set (starting with 0)
 * @return
 */
@Override public String getCastSuffixMessage(int position){
  StringBuilder sb=new StringBuilder();
  if (isActivated() && (!isRepeatable() || getActivateCount() > 0)) {
    sb.append(position > 0 ? ""String_Node_Str"" : ""String_Node_Str"").append(""String_Node_Str"");
    if (isRepeatable()) {
      sb.append(getActivateCount()).append(getActivateCount() > 1 ? ""String_Node_Str"" : ""String_Node_Str"");
    }
    sb.append(name);
  }
  return sb.toString();
}","/** 
 * Returns a text suffix for the game log, that can be added to the cast message.
 * @param position - if there are multiple costs, it's the postion the costis set (starting with 0)
 * @return
 */
@Override public String getCastSuffixMessage(int position){
  StringBuilder sb=new StringBuilder();
  if (isActivated() && (!isRepeatable() || getActivateCount() > 0)) {
    sb.append(position > 0 ? ""String_Node_Str"" : ""String_Node_Str"").append(""String_Node_Str"");
    if (isRepeatable()) {
      sb.append(getActivateCount()).append(getActivateCount() > 1 ? ""String_Node_Str"" : ""String_Node_Str"");
    }
    sb.append(name);
  }
  return sb.toString();
}",0.9992395437262356
158855,"@Override public void addOptionalAdditionalCosts(Ability ability,Game game){
  if (ability instanceof SpellAbility) {
    Player player=game.getPlayer(controllerId);
    if (player != null) {
      this.resetKicker(game,ability);
      for (      OptionalAdditionalCost kickerCost : kickerCosts) {
        boolean again=true;
        while (player.isInGame() && again) {
          String times=""String_Node_Str"";
          if (kickerCost.isRepeatable()) {
            int activatedCount=getKickedCounter(game,ability);
            times=Integer.toString(activatedCount + 1) + (activatedCount == 0 ? ""String_Node_Str"" : ""String_Node_Str"");
          }
          if (kickerCost.canPay(ability,sourceId,controllerId,game) && player.chooseUse(Outcome.Benefit,""String_Node_Str"" + times + kickerCost.getText(false)+ ""String_Node_Str"",ability,game)) {
            this.activateKicker(kickerCost,ability,game);
            for (Iterator itKickerCost=kickerCost.iterator(); itKickerCost.hasNext(); ) {
              Object kickerCostObject=itKickerCost.next();
              if ((kickerCostObject instanceof Costs) || (kickerCostObject instanceof CostsImpl)) {
                for (@SuppressWarnings(""String_Node_Str"") Iterator<Cost> itDetails=((Costs)kickerCostObject).iterator(); itDetails.hasNext(); ) {
                  addKickerCostsToAbility(itDetails.next(),ability,game);
                }
              }
 else {
                addKickerCostsToAbility((Cost)kickerCostObject,ability,game);
              }
            }
            again=kickerCost.isRepeatable();
          }
 else {
            again=false;
          }
        }
      }
    }
  }
}","@Override public void addOptionalAdditionalCosts(Ability ability,Game game){
  if (ability instanceof SpellAbility) {
    Player player=game.getPlayer(controllerId);
    if (player != null) {
      this.resetKicker(game,ability);
      for (      OptionalAdditionalCost kickerCost : kickerCosts) {
        boolean again=true;
        while (player.isInGame() && again) {
          String times=""String_Node_Str"";
          if (kickerCost.isRepeatable()) {
            int activatedCount=getKickedCounter(game,ability);
            times=Integer.toString(activatedCount + 1) + (activatedCount == 0 ? ""String_Node_Str"" : ""String_Node_Str"");
          }
          if (kickerCost.canPay(ability,sourceId,controllerId,game) && player.chooseUse(Outcome.Benefit,""String_Node_Str"" + times + kickerCost.getText(false)+ ""String_Node_Str"",ability,game)) {
            this.activateKicker(kickerCost,ability,game);
            if (kickerCost instanceof Costs) {
              for (Iterator itKickerCost=((Costs)kickerCost).iterator(); itKickerCost.hasNext(); ) {
                Object kickerCostObject=itKickerCost.next();
                if ((kickerCostObject instanceof Costs) || (kickerCostObject instanceof CostsImpl)) {
                  for (@SuppressWarnings(""String_Node_Str"") Iterator<Cost> itDetails=((Costs)kickerCostObject).iterator(); itDetails.hasNext(); ) {
                    addKickerCostsToAbility(itDetails.next(),ability,game);
                  }
                }
 else {
                  addKickerCostsToAbility((Cost)kickerCostObject,ability,game);
                }
              }
            }
 else {
              addKickerCostsToAbility((Cost)kickerCost,ability,game);
            }
            again=kickerCost.isRepeatable();
          }
 else {
            again=false;
          }
        }
      }
    }
  }
}",0.9420871559633028
158856,"@Override public synchronized void rollbackTurns(int turnsToRollback){
  if (gameOptions.rollbackTurnsAllowed) {
    int turnToGoTo=getTurnNum() - turnsToRollback;
    if (turnToGoTo < 1 || !gameStatesRollBack.containsKey(turnToGoTo)) {
      informPlayers(GameLog.getPlayerRequestColoredText(""String_Node_Str"" + turnsToRollback + ""String_Node_Str""));
    }
 else {
      GameState restore=gameStatesRollBack.get(turnToGoTo);
      if (restore != null) {
        informPlayers(GameLog.getPlayerRequestColoredText(""String_Node_Str"" + restore.getTurnNum()));
        for (        Player playerObject : getPlayers().values()) {
          if (playerObject.isHuman() && playerObject.isInGame()) {
            playerObject.abort();
          }
        }
        state.restoreForRollBack(restore);
        playerList.setCurrent(state.getActivePlayerId());
        gameStatesRollBack.put(getTurnNum(),state.copy());
        executingRollback=true;
        fireUpdatePlayersEvent();
      }
    }
  }
}","@Override public synchronized void rollbackTurns(int turnsToRollback){
  if (gameOptions.rollbackTurnsAllowed) {
    int turnToGoTo=getTurnNum() - turnsToRollback;
    if (turnToGoTo < 1 || !gameStatesRollBack.containsKey(turnToGoTo)) {
      informPlayers(GameLog.getPlayerRequestColoredText(""String_Node_Str"" + turnsToRollback + ""String_Node_Str""));
    }
 else {
      GameState restore=gameStatesRollBack.get(turnToGoTo);
      if (restore != null) {
        informPlayers(GameLog.getPlayerRequestColoredText(""String_Node_Str"" + restore.getTurnNum()));
        state.restoreForRollBack(restore);
        playerList.setCurrent(state.getActivePlayerId());
        gameStatesRollBack.put(getTurnNum(),state.copy());
        executingRollback=true;
        for (        Player playerObject : getPlayers().values()) {
          if (playerObject.isHuman() && playerObject.isInGame()) {
            playerObject.abort();
          }
        }
        fireUpdatePlayersEvent();
      }
    }
  }
}",0.8066465256797583
158857,"@Override public boolean apply(Game game,Ability source){
  Map<UUID,List<Permanent>> permanentsOwned=new HashMap<>();
  Collection<Permanent> permanents=game.getBattlefield().getAllPermanents();
  for (  Permanent permanent : permanents) {
    List<Permanent> list=permanentsOwned.get(permanent.getOwnerId());
    if (list == null) {
      list=new ArrayList<>();
    }
    list.add(permanent);
    permanentsOwned.put(permanent.getOwnerId(),list);
  }
  Map<UUID,Integer> permanentsCount=new HashMap<>();
  for (  UUID playerId : game.getState().getPlayersInRange(source.getControllerId(),game)) {
    Player player=game.getPlayer(playerId);
    if (player != null) {
      int handCards=player.getHand().size();
      player.moveCards(player.getHand(),Zone.HAND,Zone.LIBRARY,source,game);
      List<Permanent> list=permanentsOwned.remove(player.getId());
      permanentsCount.put(playerId,handCards + (list != null ? list.size() : 0));
      for (      Permanent permanent : list) {
        permanent.moveToZone(Zone.LIBRARY,source.getSourceId(),game,true);
      }
      player.getLibrary().shuffle();
    }
  }
  for (  UUID playerId : game.getState().getPlayersInRange(source.getControllerId(),game)) {
    Player player=game.getPlayer(playerId);
    if (player != null) {
      int count=permanentsCount.get(playerId);
      if (count > 0) {
        player.drawCards(count,game);
      }
    }
  }
  for (  UUID playerId : game.getState().getPlayersInRange(source.getControllerId(),game)) {
    Player player=game.getPlayer(playerId);
    if (player != null) {
      TargetCard target=new TargetCardInHand(0,Integer.MAX_VALUE,new FilterLandCard(""String_Node_Str""));
      player.chooseTarget(Outcome.PutLandInPlay,player.getHand(),target,source,game);
      for (      UUID cardId : target.getTargets()) {
        Card card=game.getCard(cardId);
        if (card != null) {
          player.putOntoBattlefieldWithInfo(card,game,Zone.HAND,source.getSourceId(),true);
        }
      }
    }
  }
  return true;
}","@Override public boolean apply(Game game,Ability source){
  Map<UUID,List<Permanent>> permanentsOwned=new HashMap<>();
  Collection<Permanent> permanents=game.getBattlefield().getAllPermanents();
  for (  Permanent permanent : permanents) {
    List<Permanent> list=permanentsOwned.get(permanent.getOwnerId());
    if (list == null) {
      list=new ArrayList<>();
      permanentsOwned.put(permanent.getOwnerId(),list);
    }
    list.add(permanent);
  }
  Map<UUID,Integer> permanentsCount=new HashMap<>();
  for (  UUID playerId : game.getState().getPlayersInRange(source.getControllerId(),game)) {
    Player player=game.getPlayer(playerId);
    if (player != null) {
      int handCards=player.getHand().size();
      player.moveCards(player.getHand(),Zone.HAND,Zone.LIBRARY,source,game);
      List<Permanent> list=permanentsOwned.remove(player.getId());
      permanentsCount.put(playerId,handCards + (list != null ? list.size() : 0));
      for (      Permanent permanent : list) {
        player.moveCardToLibraryWithInfo(permanent,source.getSourceId(),game,Zone.BATTLEFIELD,true,true);
      }
      player.getLibrary().shuffle();
    }
  }
  for (  UUID playerId : game.getState().getPlayersInRange(source.getControllerId(),game)) {
    Player player=game.getPlayer(playerId);
    if (player != null) {
      int count=permanentsCount.get(playerId);
      if (count > 0) {
        player.drawCards(count,game);
      }
    }
  }
  for (  UUID playerId : game.getState().getPlayersInRange(source.getControllerId(),game)) {
    Player player=game.getPlayer(playerId);
    if (player != null) {
      TargetCard target=new TargetCardInHand(0,Integer.MAX_VALUE,new FilterLandCard(""String_Node_Str""));
      player.chooseTarget(Outcome.PutLandInPlay,player.getHand(),target,source,game);
      for (      UUID cardId : target.getTargets()) {
        Card card=game.getCard(cardId);
        if (card != null) {
          player.putOntoBattlefieldWithInfo(card,game,Zone.HAND,source.getSourceId(),false);
        }
      }
    }
  }
  return true;
}",0.9538310412573674
158858,"@Override public boolean moveCards(List<Card> cards,Zone fromZone,Zone toZone,Ability source,Game game){
  if (cards.isEmpty()) {
    return true;
  }
  game.fireEvent(new ZoneChangeGroupEvent(cards,source == null ? null : source.getSourceId(),this.getId(),fromZone,toZone));
switch (toZone) {
case EXILED:
    boolean result=false;
  for (  Card card : cards) {
    result|=moveCardToExileWithInfo(card,null,""String_Node_Str"",source == null ? null : source.getSourceId(),game,fromZone,true);
  }
return result;
case GRAVEYARD:
return moveCardsToGraveyardWithInfo(cards,source,game,fromZone);
case HAND:
result=false;
for (Card card : cards) {
result|=moveCardToHandWithInfo(card,source == null ? null : source.getSourceId(),game,fromZone);
}
return result;
case BATTLEFIELD:
result=false;
for (Card card : cards) {
result|=putOntoBattlefieldWithInfo(card,game,fromZone,source == null ? null : source.getSourceId());
}
return result;
default :
throw new UnsupportedOperationException(""String_Node_Str"");
}
}","@Override public boolean moveCards(List<Card> cards,Zone fromZone,Zone toZone,Ability source,Game game){
  if (cards.isEmpty()) {
    return true;
  }
  game.fireEvent(new ZoneChangeGroupEvent(cards,source == null ? null : source.getSourceId(),this.getId(),fromZone,toZone));
switch (toZone) {
case EXILED:
    boolean result=false;
  for (  Card card : cards) {
    result|=moveCardToExileWithInfo(card,null,""String_Node_Str"",source == null ? null : source.getSourceId(),game,fromZone,true);
  }
return result;
case GRAVEYARD:
return moveCardsToGraveyardWithInfo(cards,source,game,fromZone);
case HAND:
result=false;
for (Card card : cards) {
result|=moveCardToHandWithInfo(card,source == null ? null : source.getSourceId(),game,fromZone);
}
return result;
case BATTLEFIELD:
result=false;
for (Card card : cards) {
result|=putOntoBattlefieldWithInfo(card,game,fromZone,source == null ? null : source.getSourceId());
}
return result;
case LIBRARY:
result=false;
boolean withName=true;
if (fromZone.equals(Zone.HAND) || fromZone.equals(Zone.LIBRARY)) {
withName=false;
}
for (Card card : cards) {
result|=moveCardToLibraryWithInfo(card,source == null ? null : source.getSourceId(),game,fromZone,true,withName);
}
return result;
default :
throw new UnsupportedOperationException(""String_Node_Str"");
}
}",0.8729952319029042
158859,"DemonToken(){
  super(""String_Node_Str"",""String_Node_Str"");
  cardType.add(CardType.CREATURE);
  subtype.add(""String_Node_Str"");
  color.setBlack(true);
  power=new MageInt(5);
  toughness=new MageInt(5);
  addAbility(FlyingAbility.getInstance());
}","DemonToken(){
  super(""String_Node_Str"",""String_Node_Str"");
  cardType.add(CardType.CREATURE);
  subtype.add(""String_Node_Str"");
  setOriginalExpansionSetCode(""String_Node_Str"");
  color.setBlack(true);
  power=new MageInt(5);
  toughness=new MageInt(5);
  addAbility(FlyingAbility.getInstance());
}",0.9087591240875912
158860,"@Override public boolean removeFromBattlefield(Permanent permanent,Game game){
  permanent.removeFromCombat(game,false);
  game.getBattlefield().removePermanent(permanent.getId());
  if (permanent.getAttachedTo() != null) {
    Permanent attachedTo=game.getPermanent(permanent.getAttachedTo());
    if (attachedTo != null) {
      attachedTo.removeAttachment(permanent.getId(),game);
    }
 else {
      Player attachedToPlayer=game.getPlayer(permanent.getAttachedTo());
      if (attachedToPlayer != null) {
        attachedToPlayer.removeAttachment(permanent,game);
      }
    }
  }
  if (permanent.getPairedCard() != null) {
    Permanent pairedCard=game.getPermanent(permanent.getPairedCard());
    if (pairedCard != null) {
      pairedCard.clearPairedCard();
    }
  }
  return true;
}","@Override public boolean removeFromBattlefield(Permanent permanent,Game game){
  permanent.removeFromCombat(game,false);
  game.getBattlefield().removePermanent(permanent.getId());
  if (permanent.getAttachedTo() != null) {
    Permanent attachedTo=game.getPermanent(permanent.getAttachedTo());
    if (attachedTo != null) {
      attachedTo.removeAttachment(permanent.getId(),game);
    }
 else {
      Player attachedToPlayer=game.getPlayer(permanent.getAttachedTo());
      if (attachedToPlayer != null) {
        attachedToPlayer.removeAttachment(permanent,game);
      }
    }
  }
  if (permanent.getPairedCard() != null) {
    Permanent pairedCard=game.getPermanent(permanent.getPairedCard());
    if (pairedCard != null) {
      pairedCard.clearPairedCard();
    }
  }
  if (permanent instanceof PermanentToken) {
    game.getState().getTriggers().removeAbilitiesOfSource(permanent.getId());
  }
  return true;
}",0.9175920514319112
158861,"@Override public SpellAbility getSpellAbility(){
  if (spellAbility == null) {
    for (    Ability ability : abilities.getActivatedAbilities(Zone.HAND)) {
      if (ability instanceof SpellAbility && ability.toString().endsWith(getName())) {
        spellAbility=(SpellAbility)ability;
      }
    }
  }
  return spellAbility;
}","@Override public SpellAbility getSpellAbility(){
  if (spellAbility == null) {
    for (    Ability ability : abilities.getActivatedAbilities(Zone.HAND)) {
      if (ability instanceof SpellAbility) {
        spellAbility=(SpellAbility)ability;
      }
    }
  }
  return spellAbility;
}",0.9318181818181818
158862,"@Override public boolean apply(Game game,Ability source){
  Cards cardsToCast=new CardsImpl();
  Player targetOpponent=game.getPlayer(targetPointer.getFirst(game,source));
  MageObject sourceObject=source.getSourceObject(game);
  if (targetOpponent != null && sourceObject != null) {
    List<Card> allCards=targetOpponent.getLibrary().getTopCards(game,7);
    Cards cards=new CardsImpl(Zone.LIBRARY,allCards);
    targetOpponent.revealCards(sourceObject.getIdName() + ""String_Node_Str"" + targetOpponent.getName()+ ""String_Node_Str"",cards,game);
    for (    Card card : allCards) {
      if (filter.match(card,game)) {
        cardsToCast.add(card);
      }
    }
    if (cardsToCast.size() > 0) {
      int numberOfSpells=1;
      if (SpellMasteryCondition.getInstance().apply(game,source)) {
        numberOfSpells++;
      }
      Player controller=game.getPlayer(source.getControllerId());
      if (controller != null) {
        TargetCard target=new TargetCard(Zone.LIBRARY,filter);
        target.setNotTarget(true);
        while (numberOfSpells > 0 && cardsToCast.size() > 0 && controller.chooseUse(outcome,""String_Node_Str"",source,game) && controller.choose(outcome,cardsToCast,target,game)) {
          Card card=cardsToCast.get(target.getFirstTarget(),game);
          if (card != null) {
            controller.cast(card.getSpellAbility(),game,true);
            numberOfSpells--;
            cardsToCast.remove(card);
            allCards.remove(card);
          }
          if (!controller.isInGame()) {
            return false;
          }
          target.clearChosen();
        }
      }
      targetOpponent.moveCards(allCards,Zone.LIBRARY,Zone.GRAVEYARD,source,game);
    }
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Cards cardsToCast=new CardsImpl();
  Player targetOpponent=game.getPlayer(targetPointer.getFirst(game,source));
  MageObject sourceObject=source.getSourceObject(game);
  if (targetOpponent != null && sourceObject != null) {
    List<Card> allCards=targetOpponent.getLibrary().getTopCards(game,7);
    Cards cards=new CardsImpl(Zone.LIBRARY,allCards);
    targetOpponent.revealCards(sourceObject.getIdName() + ""String_Node_Str"" + targetOpponent.getName()+ ""String_Node_Str"",cards,game);
    for (    Card card : allCards) {
      if (filter.match(card,game)) {
        cardsToCast.add(card);
      }
    }
    if (cardsToCast.size() > 0) {
      int numberOfSpells=1;
      if (SpellMasteryCondition.getInstance().apply(game,source)) {
        numberOfSpells++;
      }
      Player controller=game.getPlayer(source.getControllerId());
      if (controller != null) {
        TargetCard target=new TargetCard(Zone.LIBRARY,filter);
        target.setNotTarget(true);
        while (numberOfSpells > 0 && cardsToCast.size() > 0 && controller.chooseUse(outcome,""String_Node_Str"",source,game) && controller.choose(outcome,cardsToCast,target,game)) {
          Card card=cardsToCast.get(target.getFirstTarget(),game);
          if (card != null) {
            controller.cast(card.getSpellAbility(),game,true);
            numberOfSpells--;
            cardsToCast.remove(card);
            allCards.remove(card);
          }
          if (!controller.isInGame()) {
            return false;
          }
          target.clearChosen();
        }
      }
    }
    targetOpponent.moveCards(allCards,Zone.LIBRARY,Zone.GRAVEYARD,source,game);
    return true;
  }
  return false;
}",0.9803808424697056
158863,"/** 
 * Test renown is gone after zone change / Test renown is gone after zone change
 */
@Test public void testRenownGoneAfterZoneChange(){
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"",1);
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"",6);
  addCard(Zone.HAND,playerA,""String_Node_Str"");
  addCard(Zone.HAND,playerA,""String_Node_Str"");
  castSpell(1,PhaseStep.PRECOMBAT_MAIN,playerA,""String_Node_Str"");
  castSpell(5,PhaseStep.POSTCOMBAT_MAIN,playerA,""String_Node_Str"",""String_Node_Str"");
  attack(3,playerA,""String_Node_Str"");
  attack(5,playerA,""String_Node_Str"");
  attack(7,playerA,""String_Node_Str"");
  setStopAt(7,PhaseStep.POSTCOMBAT_MAIN);
  execute();
  assertLife(playerA,20);
  assertLife(playerB,6);
  assertPowerToughness(playerA,""String_Node_Str"",4,4);
  Permanent rhoxMaulers=getPermanent(""String_Node_Str"",playerA);
  Assert.assertEquals(""String_Node_Str"",false,rhoxMaulers.isRenown());
}","/** 
 * Test renown is gone after zone change / Test renown is gone after zone change
 */
@Test public void testRenownGoneAfterZoneChange(){
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"",1);
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"",6);
  addCard(Zone.HAND,playerA,""String_Node_Str"");
  addCard(Zone.HAND,playerA,""String_Node_Str"");
  castSpell(1,PhaseStep.PRECOMBAT_MAIN,playerA,""String_Node_Str"");
  castSpell(5,PhaseStep.POSTCOMBAT_MAIN,playerA,""String_Node_Str"",""String_Node_Str"");
  attack(3,playerA,""String_Node_Str"");
  attack(5,playerA,""String_Node_Str"");
  attack(7,playerA,""String_Node_Str"");
  setStopAt(7,PhaseStep.POSTCOMBAT_MAIN);
  execute();
  assertLife(playerA,20);
  assertLife(playerB,6);
  assertPowerToughness(playerA,""String_Node_Str"",6,6);
  Permanent rhoxMaulers=getPermanent(""String_Node_Str"",playerA);
  Assert.assertEquals(""String_Node_Str"",true,rhoxMaulers.isRenown());
}",0.9929232444202504
158864,"public PermanentImpl(final PermanentImpl permanent){
  super(permanent);
  this.tapped=permanent.tapped;
  this.flipped=permanent.flipped;
  this.originalControllerId=permanent.originalControllerId;
  this.controllerId=permanent.controllerId;
  this.damage=permanent.damage;
  this.controlledFromStartOfControllerTurn=permanent.controlledFromStartOfControllerTurn;
  this.turnsOnBattlefield=permanent.turnsOnBattlefield;
  this.phasedIn=permanent.phasedIn;
  this.faceDown=permanent.faceDown;
  this.attacking=permanent.attacking;
  this.blocking=permanent.blocking;
  this.maxBlocks=permanent.maxBlocks;
  this.deathtouched=permanent.deathtouched;
  this.attachments.addAll(permanent.attachments);
  for (  Map.Entry<String,List<UUID>> entry : permanent.connectedCards.entrySet()) {
    this.connectedCards.put(entry.getKey(),entry.getValue());
  }
  if (permanent.dealtDamageByThisTurn != null) {
    dealtDamageByThisTurn=new HashSet<>(permanent.dealtDamageByThisTurn);
  }
  if (permanent.markedDamage != null) {
    markedDamage=new ArrayList<>();
    for (    Counter counter : permanent.markedDamage) {
      markedDamage.add(counter.copy());
    }
  }
  if (permanent.info != null) {
    info=new HashMap<>();
    info.putAll(permanent.info);
  }
  this.counters=permanent.counters.copy();
  this.attachedTo=permanent.attachedTo;
  this.minBlockedBy=permanent.minBlockedBy;
  this.maxBlockedBy=permanent.maxBlockedBy;
  this.transformed=permanent.transformed;
  this.monstrous=permanent.monstrous;
  this.pairedCard=permanent.pairedCard;
  this.timesLoyaltyUsed=permanent.timesLoyaltyUsed;
  this.morphed=permanent.morphed;
  this.manifested=permanent.manifested;
  this.createOrder=permanent.createOrder;
}","public PermanentImpl(final PermanentImpl permanent){
  super(permanent);
  this.tapped=permanent.tapped;
  this.flipped=permanent.flipped;
  this.originalControllerId=permanent.originalControllerId;
  this.controllerId=permanent.controllerId;
  this.damage=permanent.damage;
  this.controlledFromStartOfControllerTurn=permanent.controlledFromStartOfControllerTurn;
  this.turnsOnBattlefield=permanent.turnsOnBattlefield;
  this.phasedIn=permanent.phasedIn;
  this.faceDown=permanent.faceDown;
  this.attacking=permanent.attacking;
  this.blocking=permanent.blocking;
  this.maxBlocks=permanent.maxBlocks;
  this.deathtouched=permanent.deathtouched;
  this.attachments.addAll(permanent.attachments);
  for (  Map.Entry<String,List<UUID>> entry : permanent.connectedCards.entrySet()) {
    this.connectedCards.put(entry.getKey(),entry.getValue());
  }
  if (permanent.dealtDamageByThisTurn != null) {
    dealtDamageByThisTurn=new HashSet<>(permanent.dealtDamageByThisTurn);
  }
  if (permanent.markedDamage != null) {
    markedDamage=new ArrayList<>();
    for (    Counter counter : permanent.markedDamage) {
      markedDamage.add(counter.copy());
    }
  }
  if (permanent.info != null) {
    info=new HashMap<>();
    info.putAll(permanent.info);
  }
  this.counters=permanent.counters.copy();
  this.attachedTo=permanent.attachedTo;
  this.minBlockedBy=permanent.minBlockedBy;
  this.maxBlockedBy=permanent.maxBlockedBy;
  this.transformed=permanent.transformed;
  this.monstrous=permanent.monstrous;
  this.renown=permanent.renown;
  this.pairedCard=permanent.pairedCard;
  this.timesLoyaltyUsed=permanent.timesLoyaltyUsed;
  this.morphed=permanent.morphed;
  this.manifested=permanent.manifested;
  this.createOrder=permanent.createOrder;
}",0.9907567879838244
158865,"@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  MageObject sourceObject=source.getSourceObject(game);
  if (controller != null && sourceObject != null) {
    int number=2;
    if (SpellMasteryCondition.getInstance().apply(game,source)) {
      number++;
    }
    TargetCardInLibrary target=new TargetCardInLibrary(0,number,filter);
    controller.chooseTarget(outcome,target,source,game);
    if (!target.getTargets().isEmpty()) {
      Cards cards=new CardsImpl(target.getTargets());
      controller.revealCards(sourceObject.getIdName(),cards,game);
      if (!cards.isEmpty()) {
        Card card=cards.getRandom(game);
        if (card != null) {
          cards.remove(card);
          controller.putOntoBattlefieldWithInfo(card,game,Zone.LIBRARY,source.getSourceId(),true);
          controller.moveCards(cards,Zone.LIBRARY,Zone.HAND,source,game);
        }
      }
    }
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  MageObject sourceObject=source.getSourceObject(game);
  if (controller != null && sourceObject != null) {
    int number=2;
    if (SpellMasteryCondition.getInstance().apply(game,source)) {
      number++;
    }
    TargetCardInLibrary target=new TargetCardInLibrary(0,number,filter);
    controller.searchLibrary(target,game);
    if (!target.getTargets().isEmpty()) {
      Cards cards=new CardsImpl(target.getTargets());
      controller.revealCards(sourceObject.getIdName(),cards,game);
      if (!cards.isEmpty()) {
        Card card=cards.getRandom(game);
        if (card != null) {
          cards.remove(card);
          controller.putOntoBattlefieldWithInfo(card,game,Zone.LIBRARY,source.getSourceId(),true);
          controller.moveCards(cards,Zone.LIBRARY,Zone.HAND,source,game);
        }
      }
    }
    return true;
  }
  return false;
}",0.9745934959349594
158866,"public MenaceAbility(MenaceAbility ability){
  super(ability);
}","public MenaceAbility(final MenaceAbility ability){
  super(ability);
}",0.9552238805970148
158867,"@Override public Ability copy(){
  return fINSTANCE;
}","@Override public Ability copy(){
  return new MenaceAbility(this);
}",0.7540983606557377
158868,"private void requestFocusIfPossible(){
  boolean requestFocusAllowed=true;
  if (connectedChatPanel != null && connectedChatPanel.getTxtMessageInputComponent() != null) {
    if (connectedChatPanel.getTxtMessageInputComponent().hasFocus()) {
      requestFocusAllowed=false;
    }
  }
  if (requestFocusAllowed) {
    this.btnRight.requestFocus();
    this.helper.requestFocus();
  }
}","private void requestFocusIfPossible(){
  boolean requestFocusAllowed=true;
  if (MageFrame.getInstance().getFocusOwner() == null) {
    requestFocusAllowed=false;
  }
 else   if (connectedChatPanel != null && connectedChatPanel.getTxtMessageInputComponent() != null) {
    if (connectedChatPanel.getTxtMessageInputComponent().hasFocus()) {
      requestFocusAllowed=false;
    }
  }
  if (requestFocusAllowed) {
    this.btnRight.requestFocus();
    this.helper.requestFocus();
  }
}",0.8870967741935484
158869,"/** 
 * 509.1c The defending player checks each creature he or she controls to see whether it's affected by any requirements (effects that say a creature must block, or that it must block if some condition is met). If the number of requirements that are being obeyed is fewer than the maximum possible number of requirements that could be obeyed without disobeying any restrictions, the declaration of blockers is illegal. If a creature can't block unless a player pays a cost, that player is not required to pay that cost, even if blocking with that creature would increase the number of requirements being obeyed. Example: A player controls one creature that ""blocks if able"" and another creature with no abilities. An effect states ""Creatures can't be blocked except by two or more creatures."" Having only the first creature block violates the restriction. Having neither creature block fulfills the restriction but not the requirement. Having both creatures block the same attacking creature fulfills both the restriction and the requirement, so that's the only option.
 * @param player
 * @param controller
 * @param game
 * @return
 */
public boolean checkBlockRequirementsAfter(Player player,Player controller,Game game){
  Set<UUID> opponents=game.getOpponents(attackerId);
  Map<UUID,Set<UUID>> mustBeBlockedByAtLeastOne=new HashMap<>();
  for (  Permanent creature : game.getBattlefield().getActivePermanents(new FilterControlledCreaturePermanent(),player.getId(),game)) {
    if (opponents.contains(creature.getControllerId())) {
      if (creature.getBlocking() > 0) {
        for (        Map.Entry<RequirementEffect,HashSet<Ability>> entry : game.getContinuousEffects().getApplicableRequirementEffects(creature,game).entrySet()) {
          RequirementEffect effect=entry.getKey();
          for (          Ability ability : entry.getValue()) {
            UUID toBeBlockedCreature=effect.mustBlockAttackerIfElseUnblocked(ability,game);
            if (toBeBlockedCreature != null) {
              Set<UUID> potentialBlockers;
              if (mustBeBlockedByAtLeastOne.containsKey(toBeBlockedCreature)) {
                potentialBlockers=mustBeBlockedByAtLeastOne.get(toBeBlockedCreature);
              }
 else {
                potentialBlockers=new HashSet<>();
                mustBeBlockedByAtLeastOne.put(toBeBlockedCreature,potentialBlockers);
              }
              potentialBlockers.add(creature.getId());
            }
          }
        }
      }
      if (creature.getBlocking() == 0) {
        for (        Map.Entry<RequirementEffect,HashSet<Ability>> entry : game.getContinuousEffects().getApplicableRequirementEffects(creature,game).entrySet()) {
          RequirementEffect effect=entry.getKey();
          for (          Ability ability : entry.getValue()) {
            UUID toBeBlockedCreature=effect.mustBlockAttackerIfElseUnblocked(ability,game);
            if (toBeBlockedCreature != null) {
              Set<UUID> potentialBlockers;
              if (mustBeBlockedByAtLeastOne.containsKey(toBeBlockedCreature)) {
                potentialBlockers=mustBeBlockedByAtLeastOne.get(toBeBlockedCreature);
              }
 else {
                potentialBlockers=new HashSet<>();
                mustBeBlockedByAtLeastOne.put(toBeBlockedCreature,potentialBlockers);
              }
              potentialBlockers.add(creature.getId());
            }
          }
          if (effect.mustBlockAny(game)) {
            boolean mayBlock=false;
            for (            UUID attackingCreatureId : getAttackers()) {
              if (creature.canBlock(attackingCreatureId,game)) {
                Permanent attackingCreature=game.getPermanent(attackingCreatureId);
                if (attackingCreature != null) {
                  if (attackingCreature.getMaxBlockedBy() != 0) {
                    int alreadyBlockingCreatures=0;
                    for (                    CombatGroup group : getGroups()) {
                      if (group.getAttackers().contains(attackingCreatureId)) {
                        alreadyBlockingCreatures=group.getBlockers().size();
                        break;
                      }
                    }
                    if (attackingCreature.getMaxBlockedBy() <= alreadyBlockingCreatures) {
                      continue;
                    }
                  }
                  if (attackingCreature.getMinBlockedBy() > 1) {
                  }
 else {
                    mayBlock=true;
                    break;
                  }
                }
              }
            }
            if (mayBlock) {
              if (controller.isHuman()) {
                if (!game.isSimulation()) {
                  game.informPlayer(controller,""String_Node_Str"" + creature.getLogName());
                }
              }
 else {
                Player defender=game.getPlayer(creature.getControllerId());
                if (defender != null) {
                  for (                  UUID attackingCreatureId : getAttackers()) {
                    if (creature.canBlock(attackingCreatureId,game)) {
                      defender.declareBlocker(defender.getId(),creature.getId(),attackingCreatureId,game);
                      break;
                    }
                  }
                }
              }
              return false;
            }
          }
        }
      }
    }
  }
  for (  UUID toBeBlockedCreatureId : mustBeBlockedByAtLeastOne.keySet()) {
    for (    CombatGroup combatGroup : game.getCombat().getGroups()) {
      if (combatGroup.getBlockers().isEmpty() && combatGroup.getAttackers().contains(toBeBlockedCreatureId)) {
        if (controller.isHuman()) {
          Permanent toBeBlockedCreature=game.getPermanent(toBeBlockedCreatureId);
          if (toBeBlockedCreature != null) {
            boolean possibleBlockerAvailable=false;
            for (            UUID possibleBlockerId : mustBeBlockedByAtLeastOne.get(toBeBlockedCreatureId)) {
              Set<UUID> forcingAttackers=creatureMustBlockAttackers.get(possibleBlockerId);
              if (forcingAttackers == null) {
                possibleBlockerAvailable=true;
                break;
              }
              List<UUID> blockedAttackers=null;
              for (              CombatGroup combatGroupToCheck : game.getCombat().getGroups()) {
                if (combatGroupToCheck.getBlockers().contains(possibleBlockerId)) {
                  blockedAttackers=combatGroupToCheck.getAttackers();
                  break;
                }
              }
              if (blockedAttackers == null) {
                possibleBlockerAvailable=true;
                break;
              }
              possibleBlockerAvailable=true;
              for (              UUID blockedAttackerId : blockedAttackers) {
                if (creatureMustBlockAttackers.get(possibleBlockerId).contains(blockedAttackerId)) {
                  possibleBlockerAvailable=false;
                  break;
                }
              }
              if (possibleBlockerAvailable) {
                break;
              }
            }
            if (possibleBlockerAvailable) {
              if (!game.isSimulation()) {
                game.informPlayer(controller,new StringBuilder(toBeBlockedCreature.getLogName()).append(""String_Node_Str"").toString());
              }
              return false;
            }
          }
        }
 else {
          UUID blockingCreatureId=mustBeBlockedByAtLeastOne.get(toBeBlockedCreatureId).iterator().next();
          Permanent blockingCreature=game.getPermanent(blockingCreatureId);
          if (blockingCreature != null) {
            Player defender=game.getPlayer(blockingCreature.getControllerId());
            if (defender != null) {
              defender.declareBlocker(defender.getId(),blockingCreatureId,toBeBlockedCreatureId,game);
            }
          }
        }
      }
    }
  }
  StringBuilder sb=new StringBuilder();
  for (  Map.Entry<UUID,Set<UUID>> entry : creatureMustBlockAttackers.entrySet()) {
    boolean blockIsValid;
    Permanent creatureForcedToBlock=game.getPermanent(entry.getKey());
    if (creatureForcedToBlock == null) {
      break;
    }
    if (creatureForcedToBlock.getBlocking() == 0) {
      blockIsValid=false;
    }
 else {
      blockIsValid=false;
      CombatGroups:       for (      CombatGroup combatGroup : game.getCombat().getGroups()) {
        if (combatGroup.getBlockers().contains(creatureForcedToBlock.getId())) {
          for (          UUID forcingAttackerId : combatGroup.getAttackers()) {
            if (entry.getValue().contains(forcingAttackerId)) {
              blockIsValid=true;
              break CombatGroups;
            }
 else {
              if (combatGroup.getBlockers().size() == 1) {
                if (mustBeBlockedByAtLeastOne.containsKey(forcingAttackerId)) {
                  if (mustBeBlockedByAtLeastOne.get(forcingAttackerId).contains(creatureForcedToBlock.getId())) {
                    blockIsValid=true;
                    break CombatGroups;
                  }
                }
              }
            }
          }
        }
      }
    }
    if (!blockIsValid) {
      sb.append(""String_Node_Str"").append(creatureForcedToBlock.getIdName());
    }
  }
  if (sb.length() > 0) {
    if (!game.isSimulation()) {
      sb.insert(0,""String_Node_Str"");
      sb.append(""String_Node_Str"");
      game.informPlayer(controller,sb.toString());
    }
    return false;
  }
  return true;
}","/** 
 * 509.1c The defending player checks each creature he or she controls to see whether it's affected by any requirements (effects that say a creature must block, or that it must block if some condition is met). If the number of requirements that are being obeyed is fewer than the maximum possible number of requirements that could be obeyed without disobeying any restrictions, the declaration of blockers is illegal. If a creature can't block unless a player pays a cost, that player is not required to pay that cost, even if blocking with that creature would increase the number of requirements being obeyed. Example: A player controls one creature that ""blocks if able"" and another creature with no abilities. An effect states ""Creatures can't be blocked except by two or more creatures."" Having only the first creature block violates the restriction. Having neither creature block fulfills the restriction but not the requirement. Having both creatures block the same attacking creature fulfills both the restriction and the requirement, so that's the only option.
 * @param player
 * @param controller
 * @param game
 * @return
 */
public boolean checkBlockRequirementsAfter(Player player,Player controller,Game game){
  Set<UUID> opponents=game.getOpponents(attackerId);
  Map<UUID,Set<UUID>> mustBeBlockedByAtLeastOne=new HashMap<>();
  for (  Permanent creature : game.getBattlefield().getActivePermanents(new FilterControlledCreaturePermanent(),player.getId(),game)) {
    if (opponents.contains(creature.getControllerId())) {
      if (creature.getBlocking() > 0) {
        for (        Map.Entry<RequirementEffect,HashSet<Ability>> entry : game.getContinuousEffects().getApplicableRequirementEffects(creature,game).entrySet()) {
          RequirementEffect effect=entry.getKey();
          for (          Ability ability : entry.getValue()) {
            UUID toBeBlockedCreature=effect.mustBlockAttackerIfElseUnblocked(ability,game);
            if (toBeBlockedCreature != null) {
              Set<UUID> potentialBlockers;
              if (mustBeBlockedByAtLeastOne.containsKey(toBeBlockedCreature)) {
                potentialBlockers=mustBeBlockedByAtLeastOne.get(toBeBlockedCreature);
              }
 else {
                potentialBlockers=new HashSet<>();
                mustBeBlockedByAtLeastOne.put(toBeBlockedCreature,potentialBlockers);
              }
              potentialBlockers.add(creature.getId());
            }
          }
        }
      }
      if (creature.getBlocking() == 0) {
        for (        Map.Entry<RequirementEffect,HashSet<Ability>> entry : game.getContinuousEffects().getApplicableRequirementEffects(creature,game).entrySet()) {
          RequirementEffect effect=entry.getKey();
          for (          Ability ability : entry.getValue()) {
            UUID toBeBlockedCreature=effect.mustBlockAttackerIfElseUnblocked(ability,game);
            if (toBeBlockedCreature != null) {
              Set<UUID> potentialBlockers;
              if (mustBeBlockedByAtLeastOne.containsKey(toBeBlockedCreature)) {
                potentialBlockers=mustBeBlockedByAtLeastOne.get(toBeBlockedCreature);
              }
 else {
                potentialBlockers=new HashSet<>();
                mustBeBlockedByAtLeastOne.put(toBeBlockedCreature,potentialBlockers);
              }
              potentialBlockers.add(creature.getId());
            }
          }
          if (effect.mustBlockAny(game)) {
            boolean mayBlock=false;
            for (            UUID attackingCreatureId : getAttackers()) {
              if (creature.canBlock(attackingCreatureId,game)) {
                Permanent attackingCreature=game.getPermanent(attackingCreatureId);
                if (attackingCreature != null) {
                  if (attackingCreature.getMaxBlockedBy() != 0) {
                    int alreadyBlockingCreatures=0;
                    for (                    CombatGroup group : getGroups()) {
                      if (group.getAttackers().contains(attackingCreatureId)) {
                        alreadyBlockingCreatures=group.getBlockers().size();
                        break;
                      }
                    }
                    if (attackingCreature.getMaxBlockedBy() <= alreadyBlockingCreatures) {
                      continue;
                    }
                  }
                  if (attackingCreature.getMinBlockedBy() > 1) {
                  }
 else {
                    mayBlock=true;
                    break;
                  }
                }
              }
            }
            if (mayBlock) {
              if (controller.isHuman()) {
                if (!game.isSimulation()) {
                  game.informPlayer(controller,""String_Node_Str"" + creature.getLogName());
                }
              }
 else {
                Player defender=game.getPlayer(creature.getControllerId());
                if (defender != null) {
                  for (                  UUID attackingCreatureId : getAttackers()) {
                    if (creature.canBlock(attackingCreatureId,game)) {
                      defender.declareBlocker(defender.getId(),creature.getId(),attackingCreatureId,game);
                      break;
                    }
                  }
                }
              }
              return false;
            }
          }
        }
      }
    }
  }
  for (  UUID toBeBlockedCreatureId : mustBeBlockedByAtLeastOne.keySet()) {
    for (    CombatGroup combatGroup : game.getCombat().getGroups()) {
      if (combatGroup.getBlockers().isEmpty() && combatGroup.getAttackers().contains(toBeBlockedCreatureId)) {
        if (controller.isHuman()) {
          Permanent toBeBlockedCreature=game.getPermanent(toBeBlockedCreatureId);
          if (toBeBlockedCreature != null) {
            for (            UUID possibleBlockerId : mustBeBlockedByAtLeastOne.get(toBeBlockedCreatureId)) {
              String blockRequiredMessage=isCreatureDoingARequiredBlock(possibleBlockerId,mustBeBlockedByAtLeastOne,game);
              if (blockRequiredMessage != null) {
                game.informPlayer(controller,blockRequiredMessage + ""String_Node_Str"" + toBeBlockedCreature.getIdName());
                return false;
              }
            }
          }
        }
 else {
          for (          UUID possibleBlockerId : mustBeBlockedByAtLeastOne.get(toBeBlockedCreatureId)) {
            String blockRequiredMessage=isCreatureDoingARequiredBlock(possibleBlockerId,mustBeBlockedByAtLeastOne,game);
            if (blockRequiredMessage != null) {
              Permanent possibleBlocker=game.getPermanent(possibleBlockerId);
              Player defender=game.getPlayer(possibleBlocker.getControllerId());
              if (defender != null) {
                defender.declareBlocker(defender.getId(),possibleBlockerId,toBeBlockedCreatureId,game);
              }
              break;
            }
          }
        }
      }
    }
  }
  StringBuilder sb=new StringBuilder();
  for (  Map.Entry<UUID,Set<UUID>> entry : creatureMustBlockAttackers.entrySet()) {
    boolean blockIsValid;
    Permanent creatureForcedToBlock=game.getPermanent(entry.getKey());
    if (creatureForcedToBlock == null) {
      break;
    }
    if (creatureForcedToBlock.getBlocking() == 0) {
      blockIsValid=false;
    }
 else {
      blockIsValid=false;
      CombatGroups:       for (      CombatGroup combatGroup : game.getCombat().getGroups()) {
        if (combatGroup.getBlockers().contains(creatureForcedToBlock.getId())) {
          for (          UUID forcingAttackerId : combatGroup.getAttackers()) {
            if (entry.getValue().contains(forcingAttackerId)) {
              blockIsValid=true;
              break CombatGroups;
            }
 else {
              if (combatGroup.getBlockers().size() == 1) {
                if (mustBeBlockedByAtLeastOne.containsKey(forcingAttackerId)) {
                  if (mustBeBlockedByAtLeastOne.get(forcingAttackerId).contains(creatureForcedToBlock.getId())) {
                    blockIsValid=true;
                    break CombatGroups;
                  }
                }
              }
            }
          }
        }
      }
    }
    if (!blockIsValid) {
      sb.append(""String_Node_Str"").append(creatureForcedToBlock.getIdName());
    }
  }
  if (sb.length() > 0) {
    if (!game.isSimulation()) {
      sb.insert(0,""String_Node_Str"");
      sb.append(""String_Node_Str"");
      game.informPlayer(controller,sb.toString());
    }
    return false;
  }
  return true;
}",0.8678618857901726
158870,"private void setControllerForEffect(ContinuousEffectsList<?> effects,UUID cardId,UUID controllerId){
  for (  Effect effect : effects) {
    HashSet<Ability> abilities=effects.getAbility(effect.getId());
    for (    Ability ability : abilities) {
      if (ability.getSourceId() != null) {
        if (ability.getSourceId().equals(cardId)) {
          ability.setControllerId(controllerId);
        }
      }
 else {
        if (!ability.getZone().equals(Zone.COMMAND)) {
          logger.fatal(new StringBuilder(""String_Node_Str"").append(ability));
        }
      }
    }
  }
}","private void setControllerForEffect(ContinuousEffectsList<?> effects,UUID cardId,UUID controllerId){
  for (  Effect effect : effects) {
    HashSet<Ability> abilities=effects.getAbility(effect.getId());
    if (abilities != null) {
      for (      Ability ability : abilities) {
        if (ability.getSourceId() != null) {
          if (ability.getSourceId().equals(cardId)) {
            ability.setControllerId(controllerId);
          }
        }
 else {
          if (!ability.getZone().equals(Zone.COMMAND)) {
            logger.fatal(new StringBuilder(""String_Node_Str"").append(ability));
          }
        }
      }
    }
  }
}",0.771123872026251
158871,"public List<ContinuousEffect> getLayeredEffects(Game game){
  List<ContinuousEffect> layerEffects=new ArrayList<>();
  for (  ContinuousEffect effect : layeredEffects) {
switch (effect.getDuration()) {
case WhileOnBattlefield:
case WhileOnStack:
case WhileInGraveyard:
      HashSet<Ability> abilities=layeredEffects.getAbility(effect.getId());
    for (    Ability ability : abilities) {
      if (!(ability instanceof StaticAbility) || ability.isInUseableZone(game,null,null)) {
        layerEffects.add(effect);
        break;
      }
    }
  break;
default :
layerEffects.add(effect);
}
}
updateTimestamps(layerEffects);
Collections.sort(layerEffects,sorter);
return layerEffects;
}","public List<ContinuousEffect> getLayeredEffects(Game game){
  List<ContinuousEffect> layerEffects=new ArrayList<>();
  for (  ContinuousEffect effect : layeredEffects) {
switch (effect.getDuration()) {
case WhileOnBattlefield:
case WhileOnStack:
case WhileInGraveyard:
      HashSet<Ability> abilities=layeredEffects.getAbility(effect.getId());
    if (abilities != null) {
      for (      Ability ability : abilities) {
        if (!(ability instanceof StaticAbility) || ability.isInUseableZone(game,null,null)) {
          layerEffects.add(effect);
          break;
        }
      }
    }
 else {
      logger.error(""String_Node_Str"" + effect.toString());
    }
  break;
default :
layerEffects.add(effect);
}
}
updateTimestamps(layerEffects);
Collections.sort(layerEffects,sorter);
return layerEffects;
}",0.9116465863453816
158872,"protected UUID selectDefenderForAllAttack(Set<UUID> defenders,Game game){
  TargetDefender target=new TargetDefender(defenders,null);
  target.setNotTarget(true);
  if (chooseTarget(Outcome.Damage,target,null,game)) {
    response.getUUID();
  }
  return null;
}","protected UUID selectDefenderForAllAttack(Set<UUID> defenders,Game game){
  TargetDefender target=new TargetDefender(defenders,null);
  target.setNotTarget(true);
  if (chooseTarget(Outcome.Damage,target,null,game)) {
    return response.getUUID();
  }
  return null;
}",0.9868173258003766
158873,"/** 
 * Creates new form TournamentPanel
 */
public TournamentPanel(){
  playersModel=new TournamentPlayersTableModel();
  matchesModel=new TournamentMatchesTableModel();
  initComponents();
  this.restoreDividerLocations();
  btnQuitTournament.setVisible(false);
  df=DateFormat.getDateTimeInstance();
  tablePlayers.createDefaultColumnsFromModel();
  TableUtil.setColumnWidthAndOrder(tablePlayers,defaultColumnsWidthPlayers,KEY_TOURNAMENT_PLAYER_COLUMNS_WIDTH,KEY_TOURNAMENT_PLAYER_COLUMNS_ORDER);
  tablePlayers.setDefaultRenderer(Icon.class,new CountryCellRenderer());
  tableMatches.createDefaultColumnsFromModel();
  TableUtil.setColumnWidthAndOrder(tableMatches,defaultColumnsWidthMatches,KEY_TOURNAMENT_MATCH_COLUMNS_WIDTH,KEY_TOURNAMENT_MATCH_COLUMNS_ORDER);
  chatPanel1.useExtendedView(ChatPanel.VIEW_MODE.NONE);
  chatPanel1.setChatType(ChatPanel.ChatType.TOURNAMENT);
  Action action=new AbstractAction(){
    @Override public void actionPerformed(    ActionEvent e){
      int modelRow=Integer.valueOf(e.getActionCommand());
      String state=(String)tableMatches.getValueAt(modelRow,2);
      String actionText=(String)tableMatches.getValueAt(modelRow,TournamentMatchesTableModel.ACTION_COLUMN);
      UUID tableId=UUID.fromString((String)matchesModel.getValueAt(modelRow,TournamentMatchesTableModel.ACTION_COLUMN + 1));
      UUID gameId=UUID.fromString((String)matchesModel.getValueAt(modelRow,TournamentMatchesTableModel.ACTION_COLUMN + 3));
      if (state.startsWith(""String_Node_Str"") && actionText.equals(""String_Node_Str"")) {
        logger.info(""String_Node_Str"" + gameId);
        session.watchTournamentTable(tableId);
      }
    }
  }
;
  ButtonColumn buttonColumn=new ButtonColumn(tableMatches,action,TournamentMatchesTableModel.ACTION_COLUMN);
}","/** 
 * Creates new form TournamentPanel
 */
public TournamentPanel(){
  playersModel=new TournamentPlayersTableModel();
  matchesModel=new TournamentMatchesTableModel();
  initComponents();
  this.restoreDividerLocations();
  btnQuitTournament.setVisible(false);
  df=DateFormat.getDateTimeInstance();
  tablePlayers.createDefaultColumnsFromModel();
  TableUtil.setColumnWidthAndOrder(tablePlayers,defaultColumnsWidthPlayers,KEY_TOURNAMENT_PLAYER_COLUMNS_WIDTH,KEY_TOURNAMENT_PLAYER_COLUMNS_ORDER);
  tablePlayers.setDefaultRenderer(Icon.class,new CountryCellRenderer());
  tableMatches.createDefaultColumnsFromModel();
  TableUtil.setColumnWidthAndOrder(tableMatches,defaultColumnsWidthMatches,KEY_TOURNAMENT_MATCH_COLUMNS_WIDTH,KEY_TOURNAMENT_MATCH_COLUMNS_ORDER);
  chatPanel1.useExtendedView(ChatPanel.VIEW_MODE.NONE);
  chatPanel1.setChatType(ChatPanel.ChatType.TOURNAMENT);
  Action action=new AbstractAction(){
    @Override public void actionPerformed(    ActionEvent e){
      int modelRow=Integer.valueOf(e.getActionCommand());
      String state=(String)tableMatches.getValueAt(modelRow,tableMatches.convertColumnIndexToView(2));
      String actionText=(String)tableMatches.getValueAt(modelRow,tableMatches.convertColumnIndexToView(TournamentMatchesTableModel.ACTION_COLUMN));
      UUID tableId=UUID.fromString((String)matchesModel.getValueAt(modelRow,TournamentMatchesTableModel.ACTION_COLUMN + 1));
      UUID gameId=UUID.fromString((String)matchesModel.getValueAt(modelRow,TournamentMatchesTableModel.ACTION_COLUMN + 3));
      if (state.startsWith(""String_Node_Str"") && actionText.equals(""String_Node_Str"")) {
        logger.info(""String_Node_Str"" + gameId);
        session.watchTournamentTable(tableId);
      }
    }
  }
;
  ButtonColumn buttonColumn=new ButtonColumn(tableMatches,action,tableMatches.convertColumnIndexToView(TournamentMatchesTableModel.ACTION_COLUMN));
}",0.9681112019623876
158874,"@Override public boolean apply(Game game,Ability source){
  Spell spell=game.getStack().getSpell(targetPointer.getFirst(game,source));
  MageObject sourceObject=source.getSourceObject(game);
  if (sourceObject != null && spell != null) {
    Player spellController=game.getPlayer(spell.getControllerId());
    if (spellController != null && spellController.moveCardToExileWithInfo(spell,source.getSourceId(),sourceObject.getIdName(),source.getSourceId(),game,Zone.STACK,true)) {
      if (spellController.getLibrary().size() > 0) {
        Library library=spellController.getLibrary();
        Card card;
        do {
          card=library.removeFromTop(game);
          if (card != null) {
            spellController.moveCardToExileWithInfo(card,source.getSourceId(),sourceObject.getIdName(),source.getSourceId(),game,Zone.LIBRARY,true);
          }
        }
 while (library.size() > 0 && card != null && !sharesType(card,spell.getCardType()));
        if (card != null && sharesType(card,spell.getCardType()) && !card.getCardType().contains(CardType.LAND) && card.getSpellAbility().getTargets().canChoose(spellController.getId(),game)) {
          if (spellController.chooseUse(Outcome.PlayForFree,""String_Node_Str"" + card.getLogName() + ""String_Node_Str"",source,game)) {
            spellController.cast(card.getSpellAbility(),game,true);
          }
        }
        ExileZone exile=game.getExile().getExileZone(source.getSourceId());
        if (exile != null) {
          while (exile.size() > 0) {
            card=exile.getRandom(game);
            exile.remove(card.getId());
            spellController.moveCardToLibraryWithInfo(card,source.getSourceId(),game,Zone.EXILED,false,false);
          }
        }
      }
      return true;
    }
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Spell spell=game.getStack().getSpell(targetPointer.getFirst(game,source));
  MageObject sourceObject=source.getSourceObject(game);
  if (sourceObject != null && spell != null) {
    Player spellController=game.getPlayer(spell.getControllerId());
    if (spellController != null && spellController.moveCardToExileWithInfo(spell,source.getSourceId(),sourceObject.getIdName(),source.getSourceId(),game,Zone.STACK,true)) {
      if (spellController.getLibrary().size() > 0) {
        Library library=spellController.getLibrary();
        Card card;
        do {
          card=library.removeFromTop(game);
          if (card != null) {
            spellController.moveCardToExileWithInfo(card,source.getSourceId(),sourceObject.getIdName(),source.getSourceId(),game,Zone.LIBRARY,true);
          }
        }
 while (library.size() > 0 && card != null && !sharesType(card,spell.getCardType()));
        if (card != null && sharesType(card,spell.getCardType()) && !card.getCardType().contains(CardType.LAND) && card.getSpellAbility().canChooseTarget(game)) {
          if (spellController.chooseUse(Outcome.PlayForFree,""String_Node_Str"" + card.getLogName() + ""String_Node_Str"",source,game)) {
            spellController.cast(card.getSpellAbility(),game,true);
          }
        }
        ExileZone exile=game.getExile().getExileZone(source.getSourceId());
        if (exile != null) {
          while (exile.size() > 0) {
            card=exile.getRandom(game);
            exile.remove(card.getId());
            spellController.moveCardToLibraryWithInfo(card,source.getSourceId(),game,Zone.EXILED,false,false);
          }
        }
      }
      return true;
    }
  }
  return false;
}",0.985515478557228
158875,"@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  MageObject sourceObject=game.getObject(source.getSourceId());
  if (controller == null || sourceObject == null) {
    return false;
  }
  Cards cards=new CardsImpl();
  cards.addAll(controller.getLibrary().getTopCards(game,5));
  controller.revealCards(sourceObject.getName(),cards,game);
  Player opponent;
  Set<UUID> opponents=game.getOpponents(controller.getId());
  if (opponents.size() == 1) {
    opponent=game.getPlayer(opponents.iterator().next());
  }
 else {
    Target target=new TargetOpponent(true);
    controller.chooseTarget(Outcome.Detriment,target,source,game);
    opponent=game.getPlayer(target.getFirstTarget());
  }
  if (opponent != null) {
    TargetCard target=new TargetCard(0,cards.size(),Zone.PICK,new FilterCard(""String_Node_Str""));
    List<Card> pile1=new ArrayList<>();
    Cards pile1CardsIds=new CardsImpl();
    target.setRequired(false);
    if (controller.choose(Outcome.Neutral,cards,target,game)) {
      List<UUID> targets=target.getTargets();
      for (      UUID targetId : targets) {
        Card card=game.getCard(targetId);
        if (card != null) {
          pile1.add(card);
          pile1CardsIds.add(card.getId());
        }
      }
    }
    List<Card> pile2=new ArrayList<>();
    Cards pile2CardsIds=new CardsImpl();
    for (    UUID cardId : cards) {
      Card card=game.getCard(cardId);
      if (card != null && !pile1.contains(card)) {
        pile2.add(card);
        pile2CardsIds.add(card.getId());
      }
    }
    boolean choice=opponent.choosePile(Outcome.Detriment,new StringBuilder(""String_Node_Str"").append(controller.getLogName()).append(""String_Node_Str"").toString(),pile1,pile2,game);
    Zone pile1Zone=Zone.GRAVEYARD;
    Zone pile2Zone=Zone.HAND;
    if (choice) {
      pile1Zone=Zone.HAND;
      pile2Zone=Zone.GRAVEYARD;
    }
    StringBuilder sb=new StringBuilder(sourceObject.getLogName() + ""String_Node_Str"").append(pile1Zone.equals(Zone.HAND) ? ""String_Node_Str"" : ""String_Node_Str"").append(""String_Node_Str"");
    int i=0;
    for (    UUID cardUuid : pile1CardsIds) {
      i++;
      Card card=game.getCard(cardUuid);
      if (card != null) {
        sb.append(card.getName());
        if (i < pile1CardsIds.size()) {
          sb.append(""String_Node_Str"");
        }
        card.moveToZone(pile1Zone,source.getSourceId(),game,false);
      }
    }
    game.informPlayers(sb.toString());
    sb=new StringBuilder(sourceObject.getLogName() + ""String_Node_Str"").append(pile2Zone.equals(Zone.HAND) ? ""String_Node_Str"" : ""String_Node_Str"").append(""String_Node_Str"");
    i=0;
    for (    UUID cardUuid : pile2CardsIds) {
      Card card=game.getCard(cardUuid);
      if (card != null) {
        i++;
        sb.append(""String_Node_Str"").append(card.getName());
        if (i < pile2CardsIds.size()) {
          sb.append(""String_Node_Str"");
        }
        card.moveToZone(pile2Zone,source.getSourceId(),game,false);
      }
    }
    game.informPlayers(sb.toString());
  }
  return true;
}","@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  MageObject sourceObject=game.getObject(source.getSourceId());
  if (controller == null || sourceObject == null) {
    return false;
  }
  Cards cards=new CardsImpl();
  cards.addAll(controller.getLibrary().getTopCards(game,5));
  controller.revealCards(sourceObject.getIdName(),cards,game);
  Player opponent;
  Set<UUID> opponents=game.getOpponents(controller.getId());
  if (opponents.size() == 1) {
    opponent=game.getPlayer(opponents.iterator().next());
  }
 else {
    Target target=new TargetOpponent(true);
    controller.chooseTarget(Outcome.Detriment,target,source,game);
    opponent=game.getPlayer(target.getFirstTarget());
  }
  if (opponent != null) {
    TargetCard target=new TargetCard(0,cards.size(),Zone.PICK,new FilterCard(""String_Node_Str""));
    List<Card> pile1=new ArrayList<>();
    Cards pile1CardsIds=new CardsImpl();
    target.setRequired(false);
    if (controller.choose(Outcome.Neutral,cards,target,game)) {
      List<UUID> targets=target.getTargets();
      for (      UUID targetId : targets) {
        Card card=game.getCard(targetId);
        if (card != null) {
          pile1.add(card);
          pile1CardsIds.add(card.getId());
        }
      }
    }
    List<Card> pile2=new ArrayList<>();
    Cards pile2CardsIds=new CardsImpl();
    for (    UUID cardId : cards) {
      Card card=game.getCard(cardId);
      if (card != null && !pile1.contains(card)) {
        pile2.add(card);
        pile2CardsIds.add(card.getId());
      }
    }
    boolean choice=opponent.choosePile(Outcome.Detriment,""String_Node_Str"" + controller.getName() + ""String_Node_Str"",pile1,pile2,game);
    Zone pile1Zone=Zone.GRAVEYARD;
    Zone pile2Zone=Zone.HAND;
    if (choice) {
      pile1Zone=Zone.HAND;
      pile2Zone=Zone.GRAVEYARD;
    }
    StringBuilder sb=new StringBuilder(sourceObject.getLogName() + ""String_Node_Str"").append(pile1Zone.equals(Zone.HAND) ? ""String_Node_Str"" : ""String_Node_Str"").append(""String_Node_Str"");
    int i=0;
    for (    UUID cardUuid : pile1CardsIds) {
      i++;
      Card card=game.getCard(cardUuid);
      if (card != null) {
        sb.append(GameLog.getColoredObjectName(card));
        if (i < pile1CardsIds.size()) {
          sb.append(""String_Node_Str"");
        }
        card.moveToZone(pile1Zone,source.getSourceId(),game,false);
      }
    }
    game.informPlayers(sb.toString());
    sb=new StringBuilder(sourceObject.getLogName() + ""String_Node_Str"").append(pile2Zone.equals(Zone.HAND) ? ""String_Node_Str"" : ""String_Node_Str"").append(""String_Node_Str"");
    i=0;
    for (    UUID cardUuid : pile2CardsIds) {
      Card card=game.getCard(cardUuid);
      if (card != null) {
        i++;
        sb.append(""String_Node_Str"").append(GameLog.getColoredObjectName(card));
        if (i < pile2CardsIds.size()) {
          sb.append(""String_Node_Str"");
        }
        card.moveToZone(pile2Zone,source.getSourceId(),game,false);
      }
    }
    game.informPlayers(sb.toString());
  }
  return true;
}",0.9750120909237464
158876,"@Override public boolean canChooseTarget(Game game){
  for (  Mode mode : modes.values()) {
    if (mode.getTargets().canChoose(sourceId,controllerId,game)) {
      return true;
    }
  }
  return false;
}","@Override public boolean canChooseTarget(Game game){
  int found=0;
  for (  Mode mode : modes.values()) {
    if (mode.getTargets().canChoose(sourceId,controllerId,game)) {
      found++;
      if (found >= getModes().getMinModes()) {
        return true;
      }
    }
  }
  return false;
}",0.6639839034205232
158877,"private synchronized void startModal(){
  try {
    if (SwingUtilities.isEventDispatchThread()) {
      EventQueue theQueue=getToolkit().getSystemEventQueue();
      while (isVisible()) {
        AWTEvent event=theQueue.getNextEvent();
        Object source=event.getSource();
        boolean dispatch=true;
        if (event.getSource() != null && event.getSource() instanceof TrayIcon) {
          return;
        }
        if (event instanceof MouseEvent && event.getSource() instanceof Component) {
          MouseEvent e=(MouseEvent)event;
          MouseEvent m=SwingUtilities.convertMouseEvent((Component)e.getSource(),e,this);
          if (!this.contains(m.getPoint()) && e.getID() != MouseEvent.MOUSE_DRAGGED) {
            dispatch=false;
          }
        }
        if (dispatch) {
          if (event instanceof ActiveEvent) {
            ((ActiveEvent)event).dispatch();
          }
 else           if (source instanceof Component) {
            ((Component)source).dispatchEvent(event);
          }
 else           if (source instanceof MenuComponent) {
            ((MenuComponent)source).dispatchEvent(event);
          }
 else {
            logger.warn(""String_Node_Str"" + event);
          }
        }
      }
    }
 else {
      while (isVisible()) {
        wait();
      }
    }
  }
 catch (  InterruptedException ignored) {
  }
}","private synchronized void startModal(){
  try {
    if (SwingUtilities.isEventDispatchThread()) {
      EventQueue theQueue=getToolkit().getSystemEventQueue();
      while (isVisible()) {
        AWTEvent event=theQueue.getNextEvent();
        Object source=event.getSource();
        boolean dispatch=true;
        if (event instanceof MouseEvent && event.getSource() instanceof Component) {
          MouseEvent e=(MouseEvent)event;
          MouseEvent m=SwingUtilities.convertMouseEvent((Component)e.getSource(),e,this);
          if (!this.contains(m.getPoint()) && e.getID() != MouseEvent.MOUSE_DRAGGED) {
            dispatch=false;
          }
        }
        if (dispatch) {
          if (event instanceof ActiveEvent) {
            ((ActiveEvent)event).dispatch();
          }
 else           if (source instanceof Component) {
            ((Component)source).dispatchEvent(event);
          }
 else           if (source instanceof MenuComponent) {
            ((MenuComponent)source).dispatchEvent(event);
          }
 else {
            logger.warn(""String_Node_Str"" + event);
          }
        }
      }
    }
 else {
      while (isVisible()) {
        wait();
      }
    }
  }
 catch (  InterruptedException ignored) {
  }
}",0.9576597382602
158878,"@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getFirstTarget());
  if (controller != null) {
    ChoiceColor choice=new ChoiceColor();
    while (!choice.isChosen()) {
      controller.choose(outcome,choice,game);
      if (!controller.isInGame()) {
        return false;
      }
    }
    if (choice.getColor() == null) {
      return false;
    }
    Cards hand=controller.getHand();
    controller.revealCards(""String_Node_Str"",hand,game);
    Set<Card> cards=hand.getCards(game);
    for (    Card card : cards) {
      if (card != null && card.getColor(game).shares(choice.getColor())) {
        controller.discard(card,source,game);
      }
    }
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getFirstTarget());
  MageObject sourceObject=game.getObject(source.getSourceId());
  if (controller != null && sourceObject != null) {
    ChoiceColor choice=new ChoiceColor();
    while (!choice.isChosen()) {
      controller.choose(outcome,choice,game);
      if (!controller.isInGame()) {
        return false;
      }
    }
    if (choice.getColor() == null) {
      return false;
    }
    Cards hand=controller.getHand();
    controller.revealCards(sourceObject.getIdName(),hand,game);
    Set<Card> cards=hand.getCards(game);
    for (    Card card : cards) {
      if (card != null && card.getColor(game).shares(choice.getColor())) {
        controller.discard(card,source,game);
      }
    }
    return true;
  }
  return false;
}",0.2435331230283911
158879,"/** 
 * Mycosynth Golem Artifact Creature  Golem 4/5, 11 (11) Affinity for artifacts (This spell costs {1} less to cast for each  artifact you control.) Artifact creature spells you cast have affinity for artifacts. (They cost {1} less to cast for each artifact you control.)
 */
@Test public void testSpellsAffinity(){
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"",1);
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"",1);
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"");
  addCard(Zone.HAND,playerA,""String_Node_Str"");
  castSpell(1,PhaseStep.PRECOMBAT_MAIN,playerA,""String_Node_Str"");
  setStopAt(1,PhaseStep.BEGIN_COMBAT);
  execute();
  assertPermanentCount(playerA,""String_Node_Str"",1);
  assertHandCount(playerA,""String_Node_Str"",0);
  Permanent mountain=getPermanent(""String_Node_Str"",playerA);
  Permanent forest=getPermanent(""String_Node_Str"",playerA);
  int tappedLands=0;
  if (mountain.isTapped()) {
    tappedLands++;
  }
  if (forest.isTapped()) {
    tappedLands++;
  }
  Assert.assertEquals(""String_Node_Str"",1,tappedLands);
}","/** 
 * Mycosynth Golem Artifact Creature  Golem 4/5, 11 (11) Affinity for artifacts (This spell costs {1} less to cast for each artifact you control.) Artifact creature spells you cast have affinity for artifacts. (They cost {1} less to cast for each artifact you control.)
 */
@Test public void testSpellsAffinity(){
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"",1);
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"",1);
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"");
  addCard(Zone.HAND,playerA,""String_Node_Str"");
  castSpell(1,PhaseStep.PRECOMBAT_MAIN,playerA,""String_Node_Str"");
  setStopAt(1,PhaseStep.BEGIN_COMBAT);
  execute();
  assertPermanentCount(playerA,""String_Node_Str"",1);
  assertHandCount(playerA,""String_Node_Str"",0);
  Permanent mountain=getPermanent(""String_Node_Str"",playerA);
  Permanent forest=getPermanent(""String_Node_Str"",playerA);
  int tappedLands=0;
  if (mountain.isTapped()) {
    tappedLands++;
  }
  if (forest.isTapped()) {
    tappedLands++;
  }
  Assert.assertEquals(""String_Node_Str"",1,tappedLands);
}",0.9995280792826804
158880,"/** 
 * I activated the ability of Soulfire grand master, it resolved, then i cast Stoke the Flames  on Whisperwood Elemental, my opponenet sacrificed the elemental, so stoke didnt resolve,  but i still got the life from lifelink.
 */
@Test public void testSoulfireStokeTheFlames(){
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"",8);
  addCard(Zone.HAND,playerA,""String_Node_Str"");
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"",1);
  addCard(Zone.BATTLEFIELD,playerB,""String_Node_Str"",1);
  activateAbility(1,PhaseStep.PRECOMBAT_MAIN,playerA,""String_Node_Str"");
  castSpell(1,PhaseStep.POSTCOMBAT_MAIN,playerA,""String_Node_Str"",""String_Node_Str"");
  activateAbility(1,PhaseStep.POSTCOMBAT_MAIN,playerB,""String_Node_Str"",null,""String_Node_Str"");
  setStopAt(1,PhaseStep.END_TURN);
  execute();
  assertGraveyardCount(playerA,""String_Node_Str"",1);
  assertGraveyardCount(playerB,""String_Node_Str"",1);
  assertLife(playerB,20);
  assertLife(playerA,20);
}","/** 
 * I activated the ability of Soulfire grand master, it resolved, then i cast Stoke the Flames on Whisperwood Elemental, my opponenet sacrificed the elemental, so stoke didnt resolve, but i still got the life from lifelink.
 */
@Test public void testSoulfireStokeTheFlames(){
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"",8);
  addCard(Zone.HAND,playerA,""String_Node_Str"");
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"",1);
  addCard(Zone.BATTLEFIELD,playerB,""String_Node_Str"",1);
  activateAbility(1,PhaseStep.PRECOMBAT_MAIN,playerA,""String_Node_Str"");
  castSpell(1,PhaseStep.POSTCOMBAT_MAIN,playerA,""String_Node_Str"",""String_Node_Str"");
  activateAbility(1,PhaseStep.POSTCOMBAT_MAIN,playerB,""String_Node_Str"",null,""String_Node_Str"");
  setStopAt(1,PhaseStep.END_TURN);
  execute();
  assertGraveyardCount(playerA,""String_Node_Str"",1);
  assertGraveyardCount(playerB,""String_Node_Str"",1);
  assertLife(playerB,20);
  assertLife(playerA,20);
}",0.9989626556016598
158881,"/** 
 * With a Soulfire Grand Master in play, Deflecting Palm doesn't gain the caster life.  It should as it has lifelink, and it's Deflecting Palm (an instant) dealing damage.  I was playing against a human in Standard Constructed.
 */
@Test public void testWithDeflectingPalm(){
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"",1);
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"",1);
  addCard(Zone.HAND,playerA,""String_Node_Str"");
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"",1);
  addCard(Zone.BATTLEFIELD,playerB,""String_Node_Str"",1);
  addCard(Zone.HAND,playerB,""String_Node_Str"",1);
  castSpell(1,PhaseStep.PRECOMBAT_MAIN,playerB,""String_Node_Str"",playerA);
  castSpell(1,PhaseStep.PRECOMBAT_MAIN,playerA,""String_Node_Str"",null,""String_Node_Str"");
  setChoice(playerA,""String_Node_Str"");
  setStopAt(1,PhaseStep.BEGIN_COMBAT);
  execute();
  assertGraveyardCount(playerB,""String_Node_Str"",1);
  assertGraveyardCount(playerA,""String_Node_Str"",1);
  assertLife(playerB,17);
  assertLife(playerA,23);
}","/** 
 * With a Soulfire Grand Master in play, Deflecting Palm doesn't gain the caster life. It should as it has lifelink, and it's Deflecting Palm (an instant) dealing damage. I was playing against a human in Standard Constructed.
 */
@Test public void testWithDeflectingPalm(){
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"",1);
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"",1);
  addCard(Zone.HAND,playerA,""String_Node_Str"");
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"",1);
  addCard(Zone.BATTLEFIELD,playerB,""String_Node_Str"",1);
  addCard(Zone.HAND,playerB,""String_Node_Str"",1);
  castSpell(1,PhaseStep.PRECOMBAT_MAIN,playerB,""String_Node_Str"",playerA);
  castSpell(1,PhaseStep.PRECOMBAT_MAIN,playerA,""String_Node_Str"",null,""String_Node_Str"");
  setChoice(playerA,""String_Node_Str"");
  setStopAt(1,PhaseStep.BEGIN_COMBAT);
  execute();
  assertGraveyardCount(playerB,""String_Node_Str"",1);
  assertGraveyardCount(playerA,""String_Node_Str"",1);
  assertLife(playerB,17);
  assertLife(playerA,23);
}",0.9990215264187868
158882,"/** 
 * Soulfire Grand Master Creature - Human Monk 2/2, 1W (2) Lifelink Instant and sorcery spells you control have lifelink. {2}{U/R}{U/R}: The next time you cast an instant or sorcery spell from  your hand this turn, put that card into your hand instead of into your  graveyard as it resolves.
 */
@Test public void testSpellsGainLifelink(){
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"",1);
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"");
  addCard(Zone.HAND,playerA,""String_Node_Str"");
  castSpell(1,PhaseStep.PRECOMBAT_MAIN,playerA,""String_Node_Str"",playerB);
  setStopAt(1,PhaseStep.BEGIN_COMBAT);
  execute();
  assertGraveyardCount(playerA,""String_Node_Str"",1);
  assertHandCount(playerA,""String_Node_Str"",0);
  assertLife(playerB,17);
  assertLife(playerA,23);
}","/** 
 * Soulfire Grand Master Creature - Human Monk 2/2, 1W (2) Lifelink Instant and sorcery spells you control have lifelink. {2}{U/R}{U/R}: The next time you cast an instant or sorcery spell from your hand this turn, put that card into your hand instead of into your graveyard as it resolves.
 */
@Test public void testSpellsGainLifelink(){
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"",1);
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"");
  addCard(Zone.HAND,playerA,""String_Node_Str"");
  castSpell(1,PhaseStep.PRECOMBAT_MAIN,playerA,""String_Node_Str"",playerB);
  setStopAt(1,PhaseStep.BEGIN_COMBAT);
  execute();
  assertGraveyardCount(playerA,""String_Node_Str"",1);
  assertHandCount(playerA,""String_Node_Str"",0);
  assertLife(playerB,17);
  assertLife(playerA,23);
}",0.9987261146496816
158883,"/** 
 * Test that if Soulfire Grand Master has left the battlefield  spell has no longer lifelink 
 */
@Test public void testSoulfireLeft(){
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"",1);
  addCard(Zone.HAND,playerA,""String_Node_Str"");
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"",1);
  addCard(Zone.HAND,playerB,""String_Node_Str"",1);
  addCard(Zone.BATTLEFIELD,playerB,""String_Node_Str"",1);
  castSpell(1,PhaseStep.PRECOMBAT_MAIN,playerA,""String_Node_Str"",playerB);
  castSpell(1,PhaseStep.PRECOMBAT_MAIN,playerB,""String_Node_Str"",""String_Node_Str"");
  setStopAt(1,PhaseStep.BEGIN_COMBAT);
  execute();
  assertGraveyardCount(playerA,""String_Node_Str"",1);
  assertGraveyardCount(playerB,""String_Node_Str"",1);
  assertGraveyardCount(playerA,""String_Node_Str"",1);
  assertLife(playerB,17);
  assertLife(playerA,20);
}","/** 
 * Test that if Soulfire Grand Master has left the battlefield spell has no longer lifelink
 */
@Test public void testSoulfireLeft(){
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"",1);
  addCard(Zone.HAND,playerA,""String_Node_Str"");
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"",1);
  addCard(Zone.HAND,playerB,""String_Node_Str"",1);
  addCard(Zone.BATTLEFIELD,playerB,""String_Node_Str"",1);
  castSpell(1,PhaseStep.PRECOMBAT_MAIN,playerA,""String_Node_Str"",playerB);
  castSpell(1,PhaseStep.PRECOMBAT_MAIN,playerB,""String_Node_Str"",""String_Node_Str"");
  setStopAt(1,PhaseStep.BEGIN_COMBAT);
  execute();
  assertGraveyardCount(playerA,""String_Node_Str"",1);
  assertGraveyardCount(playerB,""String_Node_Str"",1);
  assertGraveyardCount(playerA,""String_Node_Str"",1);
  assertLife(playerB,17);
  assertLife(playerA,20);
}",0.9987995198079233
158884,"/** 
 * Check if second ability resolved, the next spell that is counterer  won't go to hand back because it did not resolve
 */
@Test public void testSoulfireCounteredSpellDontGoesBack(){
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"",8);
  addCard(Zone.HAND,playerA,""String_Node_Str"");
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"",1);
  addCard(Zone.BATTLEFIELD,playerB,""String_Node_Str"",2);
  addCard(Zone.HAND,playerB,""String_Node_Str"",1);
  addCard(Zone.BATTLEFIELD,playerB,""String_Node_Str"",1);
  activateAbility(1,PhaseStep.PRECOMBAT_MAIN,playerA,""String_Node_Str"");
  castSpell(1,PhaseStep.POSTCOMBAT_MAIN,playerA,""String_Node_Str"",""String_Node_Str"");
  castSpell(1,PhaseStep.POSTCOMBAT_MAIN,playerB,""String_Node_Str"",""String_Node_Str"");
  setStopAt(1,PhaseStep.END_TURN);
  execute();
  assertGraveyardCount(playerB,""String_Node_Str"",1);
  assertGraveyardCount(playerA,""String_Node_Str"",1);
  assertLife(playerB,20);
  assertLife(playerA,20);
}","/** 
 * Check if second ability resolved, the next spell that is counterer won't go to hand back because it did not resolve
 */
@Test public void testSoulfireCounteredSpellDontGoesBack(){
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"",8);
  addCard(Zone.HAND,playerA,""String_Node_Str"");
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"",1);
  addCard(Zone.BATTLEFIELD,playerB,""String_Node_Str"",2);
  addCard(Zone.HAND,playerB,""String_Node_Str"",1);
  addCard(Zone.BATTLEFIELD,playerB,""String_Node_Str"",1);
  activateAbility(1,PhaseStep.PRECOMBAT_MAIN,playerA,""String_Node_Str"");
  castSpell(1,PhaseStep.POSTCOMBAT_MAIN,playerA,""String_Node_Str"",""String_Node_Str"");
  castSpell(1,PhaseStep.POSTCOMBAT_MAIN,playerB,""String_Node_Str"",""String_Node_Str"");
  setStopAt(1,PhaseStep.END_TURN);
  execute();
  assertGraveyardCount(playerB,""String_Node_Str"",1);
  assertGraveyardCount(playerA,""String_Node_Str"",1);
  assertLife(playerB,20);
  assertLife(playerA,20);
}",0.999482669425763
158885,"@Override public String getText(Mode mode){
  if (staticText != null && !staticText.isEmpty()) {
    return staticText;
  }
  StringBuilder sb=new StringBuilder();
  Target target=mode.getTargets().get(0);
  if (target.getMaxNumberOfTargets() > 1) {
    if (target.getNumberOfTargets() < target.getNumberOfTargets()) {
      sb.append(""String_Node_Str"");
    }
    sb.append(CardUtil.numberToText(target.getMaxNumberOfTargets())).append(""String_Node_Str"").append(target.getTargetName()).append(""String_Node_Str"");
  }
 else {
    if (!target.getTargetName().toUpperCase().startsWith(""String_Node_Str"")) {
      sb.append(""String_Node_Str"");
    }
    sb.append(target.getTargetName()).append(""String_Node_Str"");
  }
  String p=power.toString();
  if (!p.startsWith(""String_Node_Str"")) {
    sb.append(""String_Node_Str"");
  }
  sb.append(p).append(""String_Node_Str"");
  String t=toughness.toString();
  if (!t.startsWith(""String_Node_Str"")) {
    if (p.startsWith(""String_Node_Str"")) {
      sb.append(""String_Node_Str"");
    }
 else {
      sb.append(""String_Node_Str"");
    }
  }
  sb.append(t);
  if (duration != Duration.WhileOnBattlefield) {
    sb.append(""String_Node_Str"").append(duration.toString());
  }
  String message=null;
  String fixedPart=null;
  if (t.equals(""String_Node_Str"")) {
    message=toughness.getMessage();
    fixedPart=""String_Node_Str"";
  }
 else   if (p.equals(""String_Node_Str"")) {
    message=power.getMessage();
    fixedPart=""String_Node_Str"";
  }
 else   if (!power.getMessage().isEmpty()) {
    message=power.getMessage();
    fixedPart=""String_Node_Str"";
  }
 else   if (!toughness.getMessage().isEmpty()) {
    message=toughness.getMessage();
    fixedPart=""String_Node_Str"";
  }
  if (message != null && !message.isEmpty() && fixedPart != null) {
    sb.append(fixedPart).append(message);
  }
  return sb.toString();
}","@Override public String getText(Mode mode){
  if (staticText != null && !staticText.isEmpty()) {
    return staticText;
  }
  StringBuilder sb=new StringBuilder();
  Target target=mode.getTargets().get(0);
  if (target.getMaxNumberOfTargets() > 1) {
    if (target.getNumberOfTargets() < target.getNumberOfTargets()) {
      sb.append(""String_Node_Str"");
    }
    sb.append(CardUtil.numberToText(target.getMaxNumberOfTargets())).append(""String_Node_Str"").append(target.getTargetName()).append(""String_Node_Str"");
  }
 else {
    if (!target.getTargetName().toUpperCase().startsWith(""String_Node_Str"")) {
      sb.append(""String_Node_Str"");
    }
    sb.append(target.getTargetName()).append(""String_Node_Str"");
  }
  String p=power.toString();
  if (!p.startsWith(""String_Node_Str"")) {
    sb.append(""String_Node_Str"");
  }
  sb.append(p).append(""String_Node_Str"");
  String t=toughness.toString();
  if (!t.startsWith(""String_Node_Str"")) {
    if (t.equals(""String_Node_Str"") && p.startsWith(""String_Node_Str"")) {
      sb.append(""String_Node_Str"");
    }
 else {
      sb.append(""String_Node_Str"");
    }
  }
  sb.append(t);
  if (duration != Duration.WhileOnBattlefield) {
    sb.append(""String_Node_Str"").append(duration.toString());
  }
  String message=null;
  String fixedPart=null;
  if (t.equals(""String_Node_Str"")) {
    message=toughness.getMessage();
    fixedPart=""String_Node_Str"";
  }
 else   if (p.equals(""String_Node_Str"")) {
    message=power.getMessage();
    fixedPart=""String_Node_Str"";
  }
 else   if (!power.getMessage().isEmpty()) {
    message=power.getMessage();
    fixedPart=""String_Node_Str"";
  }
 else   if (!toughness.getMessage().isEmpty()) {
    message=toughness.getMessage();
    fixedPart=""String_Node_Str"";
  }
  if (message != null && !message.isEmpty() && fixedPart != null) {
    sb.append(fixedPart).append(message);
  }
  return sb.toString();
}",0.9917222963951936
158886,"@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller == null) {
    return false;
  }
  StackObject spell=null;
  for (  StackObject object : game.getStack()) {
    if (object instanceof Spell && object.getSourceId().equals(source.getSourceId())) {
      spell=object;
    }
  }
  if (spell != null) {
    boolean destroyCreatures=true;
    for (    UUID playerId : game.getState().getPlayersInRange(controller.getId(),game)) {
      Player player=game.getPlayer(uuid);
      if (player != null && player.chooseUse(Outcome.Detriment,""String_Node_Str"" + spell.getLogName() + ""String_Node_Str"",game)) {
        destroyCreatures=false;
        player.damage(6,source.getSourceId(),game,false,true);
        game.informPlayers(player.getLogName() + ""String_Node_Str"" + spell.getName()+ ""String_Node_Str"");
      }
    }
    if (destroyCreatures) {
      for (      Permanent permanent : game.getBattlefield().getActivePermanents(new FilterCreaturePermanent(""String_Node_Str""),source.getControllerId(),source.getSourceId(),game)) {
        permanent.destroy(source.getSourceId(),game,true);
      }
    }
    return destroyCreatures;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller == null) {
    return false;
  }
  StackObject spell=null;
  for (  StackObject object : game.getStack()) {
    if (object instanceof Spell && object.getSourceId().equals(source.getSourceId())) {
      spell=object;
    }
  }
  if (spell != null) {
    boolean destroyCreatures=true;
    for (    UUID playerId : game.getState().getPlayersInRange(controller.getId(),game)) {
      Player player=game.getPlayer(playerId);
      if (player != null && player.chooseUse(Outcome.Detriment,""String_Node_Str"" + spell.getLogName() + ""String_Node_Str"",game)) {
        destroyCreatures=false;
        player.damage(6,source.getSourceId(),game,false,true);
        game.informPlayers(player.getLogName() + ""String_Node_Str"" + spell.getName()+ ""String_Node_Str"");
      }
    }
    if (destroyCreatures) {
      for (      Permanent permanent : game.getBattlefield().getActivePermanents(new FilterCreaturePermanent(""String_Node_Str""),source.getControllerId(),source.getSourceId(),game)) {
        permanent.destroy(source.getSourceId(),game,true);
      }
    }
    return destroyCreatures;
  }
  return false;
}",0.9959546925566344
158887,"@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller == null) {
    return false;
  }
  StackObject spell=null;
  for (  StackObject object : game.getStack()) {
    if (object instanceof Spell && object.getSourceId().equals(source.getSourceId())) {
      spell=object;
    }
  }
  if (spell != null) {
    boolean destroyCreatures=true;
    for (    UUID playerId : game.getState().getPlayersInRange(controller.getId(),game)) {
      Player player=game.getPlayer(playerId);
      if (player != null && player.chooseUse(Outcome.Detriment,""String_Node_Str"" + spell.getLogName() + ""String_Node_Str"",game)) {
        destroyCreatures=false;
        player.damage(6,source.getSourceId(),game,false,true);
        game.informPlayers(player.getLogName() + ""String_Node_Str"" + spell.getName()+ ""String_Node_Str"");
      }
    }
    if (destroyCreatures) {
      for (      Permanent permanent : game.getBattlefield().getActivePermanents(new FilterCreaturePermanent(""String_Node_Str""),source.getControllerId(),source.getSourceId(),game)) {
        permanent.destroy(source.getSourceId(),game,true);
      }
    }
    return destroyCreatures;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller == null) {
    return false;
  }
  StackObject spell=null;
  for (  StackObject object : game.getStack()) {
    if (object instanceof Spell && object.getSourceId().equals(source.getSourceId())) {
      spell=object;
    }
  }
  if (spell != null) {
    boolean destroyCreatures=true;
    for (    UUID playerId : game.getState().getPlayersInRange(controller.getId(),game)) {
      Player player=game.getPlayer(uuid);
      if (player != null && player.chooseUse(Outcome.Detriment,""String_Node_Str"" + spell.getLogName() + ""String_Node_Str"",game)) {
        destroyCreatures=false;
        player.damage(6,source.getSourceId(),game,false,true);
        game.informPlayers(player.getLogName() + ""String_Node_Str"" + spell.getName()+ ""String_Node_Str"");
      }
    }
    if (destroyCreatures) {
      for (      Permanent permanent : game.getBattlefield().getActivePermanents(new FilterCreaturePermanent(""String_Node_Str""),source.getControllerId(),source.getSourceId(),game)) {
        permanent.destroy(source.getSourceId(),game,true);
      }
    }
    return destroyCreatures;
  }
  return false;
}",0.9959546925566344
158888,"@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller == null) {
    return false;
  }
  StackObject spell=null;
  for (  StackObject object : game.getStack()) {
    if (object instanceof Spell && object.getSourceId().equals(source.getSourceId())) {
      spell=object;
    }
  }
  if (spell != null) {
    boolean destroyCreatures=true;
    for (    UUID playerId : game.getState().getPlayersInRange(controller.getId(),game)) {
      Player player=game.getPlayer(uuid);
      if (player != null && player.chooseUse(Outcome.Detriment,""String_Node_Str"" + spell.getLogName() + ""String_Node_Str"",game)) {
        destroyCreatures=false;
        player.damage(6,source.getSourceId(),game,false,true);
        game.informPlayers(player.getLogName() + ""String_Node_Str"" + spell.getName()+ ""String_Node_Str"");
      }
    }
    if (destroyCreatures) {
      for (      Permanent permanent : game.getBattlefield().getActivePermanents(new FilterCreaturePermanent(""String_Node_Str""),source.getControllerId(),source.getSourceId(),game)) {
        permanent.destroy(source.getSourceId(),game,true);
      }
    }
    return destroyCreatures;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller == null) {
    return false;
  }
  StackObject spell=null;
  for (  StackObject object : game.getStack()) {
    if (object instanceof Spell && object.getSourceId().equals(source.getSourceId())) {
      spell=object;
    }
  }
  if (spell != null) {
    boolean destroyCreatures=true;
    for (    UUID playerId : game.getState().getPlayersInRange(controller.getId(),game)) {
      Player player=game.getPlayer(playerId);
      if (player != null && player.chooseUse(Outcome.Detriment,""String_Node_Str"" + spell.getLogName() + ""String_Node_Str"",game)) {
        destroyCreatures=false;
        player.damage(6,source.getSourceId(),game,false,true);
        game.informPlayers(player.getLogName() + ""String_Node_Str"" + spell.getName()+ ""String_Node_Str"");
      }
    }
    if (destroyCreatures) {
      for (      Permanent permanent : game.getBattlefield().getActivePermanents(new FilterCreaturePermanent(""String_Node_Str""),source.getControllerId(),source.getSourceId(),game)) {
        permanent.destroy(source.getSourceId(),game,true);
      }
    }
    return destroyCreatures;
  }
  return false;
}",0.9959546925566344
158889,"@Override public boolean destroy(UUID sourceId,Game game,boolean noRegen){
  if (abilities.containsKey(IndestructibleAbility.getInstance().getId())) {
    return false;
  }
  if (!game.replaceEvent(GameEvent.getEvent(EventType.DESTROY_PERMANENT,objectId,sourceId,controllerId,noRegen ? 1 : 0))) {
    if (moveToZone(Zone.GRAVEYARD,sourceId,game,false)) {
      if (!game.isSimulation()) {
        String logName;
        Card card=game.getCard(this.getId());
        if (card != null) {
          logName=card.getLogName();
        }
 else {
          logName=this.getLogName();
        }
        if (this.getCardType().contains(CardType.CREATURE)) {
          game.informPlayers(logName + ""String_Node_Str"");
        }
 else {
          game.informPlayers(logName + ""String_Node_Str"");
        }
      }
      game.fireEvent(GameEvent.getEvent(EventType.DESTROYED_PERMANENT,objectId,sourceId,controllerId));
      return true;
    }
  }
  return false;
}","@Override public boolean destroy(UUID sourceId,Game game,boolean noRegen){
  if (abilities.containsKey(IndestructibleAbility.getInstance().getId())) {
    return false;
  }
  if (!game.replaceEvent(GameEvent.getEvent(EventType.DESTROY_PERMANENT,objectId,sourceId,controllerId,noRegen ? 1 : 0))) {
    if (moveToZone(Zone.GRAVEYARD,sourceId,game,false)) {
      if (!game.isSimulation()) {
        String logName;
        Card card=game.getCard(this.getId());
        if (card != null) {
          logName=card.getLogName();
        }
 else {
          logName=this.getLogName();
        }
        if (this.getCardType().contains(CardType.CREATURE)) {
          game.informPlayers(logName + ""String_Node_Str"");
        }
 else {
          game.informPlayers(logName + ""String_Node_Str"");
        }
      }
      game.fireEvent(GameEvent.getEvent(EventType.DESTROYED_PERMANENT,objectId,sourceId,controllerId));
    }
    return true;
  }
  return false;
}",0.980083857442348
158890,"/** 
 * @param damageAmount
 * @param sourceId
 * @param game
 * @param preventable
 * @param combat
 * @param markDamage   If true, damage will be dealt later in applyDamage method
 * @return
 */
private int damage(int damageAmount,UUID sourceId,Game game,boolean preventable,boolean combat,boolean markDamage,ArrayList<UUID> appliedEffects){
  int damageDone=0;
  if (damageAmount > 0 && canDamage(game.getObject(sourceId),game)) {
    if (cardType.contains(CardType.PLANESWALKER)) {
      damageDone=damagePlaneswalker(damageAmount,sourceId,game,preventable,combat,markDamage,appliedEffects);
    }
 else {
      damageDone=damageCreature(damageAmount,sourceId,game,preventable,combat,markDamage,appliedEffects);
    }
    if (damageDone > 0) {
      UUID sourceControllerId=null;
      Abilities sourceAbilities=null;
      MageObject source=game.getPermanentOrLKIBattlefield(sourceId);
      if (source == null) {
        StackObject stackObject=game.getStack().getStackObject(sourceId);
        if (stackObject != null) {
          source=stackObject.getStackAbility().getSourceObject(game);
        }
 else {
          source=game.getObject(sourceId);
        }
        if (source instanceof Spell) {
          sourceAbilities=((Spell)source).getAbilities(game);
          sourceControllerId=((Spell)source).getControllerId();
        }
 else         if (source instanceof Card) {
          sourceAbilities=((Card)source).getAbilities(game);
          sourceControllerId=((Card)source).getOwnerId();
        }
 else         if (source instanceof CommandObject) {
          sourceControllerId=((CommandObject)source).getControllerId();
          sourceAbilities=((CommandObject)source).getAbilities();
        }
 else {
          source=null;
        }
      }
 else {
        sourceAbilities=((Permanent)source).getAbilities(game);
        sourceControllerId=((Permanent)source).getControllerId();
      }
      if (source != null && sourceAbilities != null) {
        if (sourceAbilities.containsKey(LifelinkAbility.getInstance().getId())) {
          Player player=game.getPlayer(sourceControllerId);
          player.gainLife(damageAmount,game);
        }
        if (sourceAbilities.containsKey(DeathtouchAbility.getInstance().getId())) {
          deathtouched=true;
        }
        if (dealtDamageByThisTurn == null) {
          dealtDamageByThisTurn=new HashSet<>();
        }
        dealtDamageByThisTurn.add(new MageObjectReference(source,game));
      }
    }
  }
  return damageDone;
}","/** 
 * @param damageAmount
 * @param sourceId
 * @param game
 * @param preventable
 * @param combat
 * @param markDamage If true, damage will be dealt later in applyDamagemethod
 * @return
 */
private int damage(int damageAmount,UUID sourceId,Game game,boolean preventable,boolean combat,boolean markDamage,ArrayList<UUID> appliedEffects){
  int damageDone=0;
  if (damageAmount > 0 && canDamage(game.getObject(sourceId),game)) {
    if (cardType.contains(CardType.PLANESWALKER)) {
      damageDone=damagePlaneswalker(damageAmount,sourceId,game,preventable,combat,markDamage,appliedEffects);
    }
 else {
      damageDone=damageCreature(damageAmount,sourceId,game,preventable,combat,markDamage,appliedEffects);
    }
    if (damageDone > 0) {
      UUID sourceControllerId=null;
      Abilities sourceAbilities=null;
      MageObject source=game.getPermanentOrLKIBattlefield(sourceId);
      if (source == null) {
        StackObject stackObject=game.getStack().getStackObject(sourceId);
        if (stackObject != null) {
          source=stackObject.getStackAbility().getSourceObject(game);
        }
 else {
          source=game.getObject(sourceId);
        }
        if (source instanceof Spell) {
          sourceAbilities=((Spell)source).getAbilities(game);
          sourceControllerId=((Spell)source).getControllerId();
        }
 else         if (source instanceof Card) {
          sourceAbilities=((Card)source).getAbilities(game);
          sourceControllerId=((Card)source).getOwnerId();
        }
 else         if (source instanceof CommandObject) {
          sourceControllerId=((CommandObject)source).getControllerId();
          sourceAbilities=((CommandObject)source).getAbilities();
        }
 else {
          source=null;
        }
      }
 else {
        sourceAbilities=((Permanent)source).getAbilities(game);
        sourceControllerId=((Permanent)source).getControllerId();
      }
      if (source != null && sourceAbilities != null) {
        if (sourceAbilities.containsKey(LifelinkAbility.getInstance().getId())) {
          Player player=game.getPlayer(sourceControllerId);
          player.gainLife(damageAmount,game);
        }
        if (sourceAbilities.containsKey(DeathtouchAbility.getInstance().getId())) {
          deathtouched=true;
        }
        if (dealtDamageByThisTurn == null) {
          dealtDamageByThisTurn=new HashSet<>();
        }
        dealtDamageByThisTurn.add(new MageObjectReference(source,game));
      }
    }
  }
  return damageDone;
}",0.999401078059493
158891,"@Override public boolean phaseOut(Game game){
  if (phasedIn) {
    if (!replaceEvent(EventType.PHASE_OUT,game)) {
      this.phasedIn=false;
      if (!game.isSimulation())       game.informPlayers(getLogName() + ""String_Node_Str"");
      fireEvent(EventType.PHASED_OUT,game);
      return true;
    }
  }
  return false;
}","@Override public boolean phaseOut(Game game){
  if (phasedIn) {
    if (!replaceEvent(EventType.PHASE_OUT,game)) {
      this.phasedIn=false;
      if (!game.isSimulation()) {
        game.informPlayers(getLogName() + ""String_Node_Str"");
      }
      fireEvent(EventType.PHASED_OUT,game);
      return true;
    }
  }
  return false;
}",0.9818181818181818
158892,"@Override public boolean chooseTargetAmount(Outcome outcome,TargetAmount target,Ability source,Game game){
  if (log.isDebugEnabled()) {
    log.debug(""String_Node_Str"" + outcome.toString() + ""String_Node_Str""+ target.toString());
  }
  UUID opponentId=game.getOpponents(playerId).iterator().next();
  if (target instanceof TargetCreatureOrPlayerAmount) {
    if (outcome.equals(Outcome.Damage) && game.getPlayer(opponentId).getLife() <= target.getAmountRemaining()) {
      target.addTarget(opponentId,target.getAmountRemaining(),source,game);
      return true;
    }
    List<Permanent> targets;
    if (outcome.isGood()) {
      targets=threats(playerId,source.getSourceId(),new FilterCreaturePermanent(),game,target.getTargets());
    }
 else {
      targets=threats(opponentId,source.getSourceId(),new FilterCreaturePermanent(),game,target.getTargets());
    }
    for (    Permanent permanent : targets) {
      if (target.canTarget(permanent.getId(),source,game)) {
        if (permanent.getToughness().getValue() <= target.getAmountRemaining()) {
          target.addTarget(permanent.getId(),permanent.getToughness().getValue(),source,game);
          return true;
        }
      }
    }
    if (outcome.isGood() && target.canTarget(playerId,playerId,source,game)) {
      target.addTarget(opponentId,target.getAmountRemaining(),source,game);
      return true;
    }
 else     if (target.canTarget(playerId,opponentId,source,game)) {
      target.addTarget(opponentId,target.getAmountRemaining(),source,game);
      return true;
    }
 else     if (target.canTarget(playerId,playerId,source,game)) {
      target.addTarget(opponentId,target.getAmountRemaining(),source,game);
      return true;
    }
  }
  return false;
}","@Override public boolean chooseTargetAmount(Outcome outcome,TargetAmount target,Ability source,Game game){
  if (log.isDebugEnabled()) {
    log.debug(""String_Node_Str"" + outcome.toString() + ""String_Node_Str""+ target.toString());
  }
  UUID opponentId=game.getOpponents(playerId).iterator().next();
  if (target instanceof TargetCreatureOrPlayerAmount) {
    if (outcome.equals(Outcome.Damage) && game.getPlayer(opponentId).getLife() <= target.getAmountRemaining()) {
      target.addTarget(opponentId,target.getAmountRemaining(),source,game);
      return true;
    }
    List<Permanent> targets;
    if (outcome.isGood()) {
      targets=threats(playerId,source.getSourceId(),new FilterCreaturePermanent(),game,target.getTargets());
    }
 else {
      targets=threats(opponentId,source.getSourceId(),new FilterCreaturePermanent(),game,target.getTargets());
    }
    for (    Permanent permanent : targets) {
      if (target.canTarget(getId(),permanent.getId(),source,game)) {
        if (permanent.getToughness().getValue() <= target.getAmountRemaining()) {
          target.addTarget(permanent.getId(),permanent.getToughness().getValue(),source,game);
          return true;
        }
      }
    }
    if (outcome.isGood() && target.canTarget(getId(),getId(),source,game)) {
      target.addTarget(opponentId,target.getAmountRemaining(),source,game);
      return true;
    }
 else     if (target.canTarget(getId(),opponentId,source,game)) {
      target.addTarget(opponentId,target.getAmountRemaining(),source,game);
      return true;
    }
 else     if (target.canTarget(getId(),playerId,source,game)) {
      target.addTarget(opponentId,target.getAmountRemaining(),source,game);
      return true;
    }
  }
  return false;
}",0.7919308357348703
158893,"protected Card pickTarget(List<Card> cards,Outcome outcome,Target target,Ability source,Game game){
  Card card;
  while (!cards.isEmpty()) {
    if (outcome.isGood()) {
      card=pickBestCard(cards,null,target,source,game);
    }
 else {
      card=pickWorstCard(cards,null,target,source,game);
    }
    if (source != null) {
      if (target.canTarget(this.getId(),card.getId(),source,game)) {
        return card;
      }
    }
 else {
      return card;
    }
    cards.remove(card);
  }
  return null;
}","protected Card pickTarget(List<Card> cards,Outcome outcome,Target target,Ability source,Game game){
  Card card;
  while (!cards.isEmpty()) {
    if (outcome.isGood()) {
      card=pickBestCard(cards,null,target,source,game);
    }
 else {
      card=pickWorstCard(cards,null,target,source,game);
    }
    if (source != null) {
      if (target.canTarget(getId(),card.getId(),source,game)) {
        return card;
      }
    }
 else {
      return card;
    }
    cards.remove(card);
  }
  return null;
}",0.7881773399014779
158894,"public Card pickBestCard(List<Card> cards,List<ColoredManaSymbol> chosenColors,Target target,Ability source,Game game){
  if (cards.isEmpty()) {
    return null;
  }
  Card bestCard=null;
  int maxScore=0;
  for (  Card card : cards) {
    int score=RateCard.rateCard(card,chosenColors);
    boolean betterCard=false;
    if (bestCard == null) {
      betterCard=true;
    }
 else     if (score > maxScore) {
      if (target != null && source != null && game != null) {
        betterCard=target.canTarget(card.getId(),source,game);
      }
 else {
        betterCard=true;
      }
    }
    if (betterCard) {
      maxScore=score;
      bestCard=card;
    }
  }
  return bestCard;
}","public Card pickBestCard(List<Card> cards,List<ColoredManaSymbol> chosenColors,Target target,Ability source,Game game){
  if (cards.isEmpty()) {
    return null;
  }
  Card bestCard=null;
  int maxScore=0;
  for (  Card card : cards) {
    int score=RateCard.rateCard(card,chosenColors);
    boolean betterCard=false;
    if (bestCard == null) {
      betterCard=true;
    }
 else     if (score > maxScore) {
      if (target != null && source != null && game != null) {
        betterCard=target.canTarget(getId(),card.getId(),source,game);
      }
 else {
        betterCard=true;
      }
    }
    if (betterCard) {
      maxScore=score;
      bestCard=card;
    }
  }
  return bestCard;
}",0.994186046511628
158895,"@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller == null) {
    return false;
  }
  List<Card> cardsToPutIntoPlay=new ArrayList<>();
  TargetCardInHand target=new TargetCardInHand(filter);
  PlayerList playerList=game.getPlayerList().copy();
  playerList.setCurrent(game.getActivePlayerId());
  Player player=game.getPlayer(game.getActivePlayerId());
  do {
    if (player.chooseUse(outcome,""String_Node_Str"",game)) {
      target.clearChosen();
      if (player.chooseTarget(outcome,target,source,game)) {
        Card card=game.getCard(target.getFirstTarget());
        if (card != null) {
          cardsToPutIntoPlay.add(card);
        }
      }
    }
    player=playerList.getNextInRange(controller,game);
  }
 while (!player.getId().equals(game.getActivePlayerId()));
  for (  Card card : cardsToPutIntoPlay) {
    player=game.getPlayer(card.getOwnerId());
    if (player != null) {
      player.putOntoBattlefieldWithInfo(card,game,Zone.HAND,source.getSourceId());
    }
  }
  return true;
}","@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller == null) {
    return false;
  }
  List<Card> cardsToPutIntoPlay=new ArrayList<>();
  TargetCardInHand target=new TargetCardInHand(filter);
  for (  UUID playerId : game.getState().getPlayersInRange(controller.getId(),game)) {
    Player player=game.getPlayer(playerId);
    if (player != null) {
      if (player.chooseUse(outcome,""String_Node_Str"",game)) {
        target.clearChosen();
        if (player.chooseTarget(outcome,target,source,game)) {
          Card card=game.getCard(target.getFirstTarget());
          if (card != null) {
            cardsToPutIntoPlay.add(card);
          }
        }
      }
    }
  }
  for (  Card card : cardsToPutIntoPlay) {
    Player player=game.getPlayer(card.getOwnerId());
    if (player != null) {
      player.putOntoBattlefieldWithInfo(card,game,Zone.HAND,source.getSourceId());
    }
  }
  return true;
}",0.7818969667790082
158896,"@Override public void playPriority(UUID activePlayerId,boolean resuming){
  int bookmark=0;
  clearAllBookmarks();
  try {
    while (!isPaused() && !gameOver(null) && !this.getTurn().isEndTurnRequested()) {
      if (!resuming) {
        state.getPlayers().resetPassed();
        state.getPlayerList().setCurrent(activePlayerId);
      }
 else {
        state.getPlayerList().setCurrent(this.getPriorityPlayerId());
      }
      fireUpdatePlayersEvent();
      Player player;
      while (!isPaused() && !gameOver(null)) {
        try {
          if (bookmark == 0) {
            bookmark=bookmarkState();
          }
          player=getPlayer(state.getPlayerList().get());
          state.setPriorityPlayerId(player.getId());
          while (!player.isPassed() && player.isInGame() && !isPaused()&& !gameOver(null)) {
            if (!resuming) {
              checkStateAndTriggered();
              applyEffects();
              if (state.getStack().isEmpty()) {
                resetLKI();
              }
              saveState(false);
              if (isPaused() || gameOver(null)) {
                return;
              }
              if (player.priority(this)) {
                if (executingRollback()) {
                  return;
                }
                applyEffects();
              }
              if (isPaused()) {
                return;
              }
            }
            resuming=false;
          }
          resetShortLivingLKI();
          resuming=false;
          if (isPaused() || gameOver(null)) {
            return;
          }
          if (allPassed()) {
            if (!state.getStack().isEmpty()) {
              resolve();
              applyEffects();
              state.getPlayers().resetPassed();
              fireUpdatePlayersEvent();
              state.getRevealed().reset();
              resetShortLivingLKI();
              break;
            }
 else {
              resetLKI();
              return;
            }
          }
        }
 catch (        Exception ex) {
          logger.fatal(""String_Node_Str"" + getId(),ex);
          ex.printStackTrace();
          this.fireErrorEvent(""String_Node_Str"",ex);
          restoreState(bookmark,""String_Node_Str"");
          bookmark=0;
          continue;
        }
        state.getPlayerList().getNext();
      }
    }
  }
 catch (  Exception ex) {
    logger.fatal(""String_Node_Str"",ex);
    this.fireErrorEvent(""String_Node_Str"",ex);
  }
 finally {
    resetLKI();
    clearAllBookmarks();
  }
}","@Override public void playPriority(UUID activePlayerId,boolean resuming){
  int bookmark=0;
  clearAllBookmarks();
  try {
    applyEffects();
    while (!isPaused() && !gameOver(null) && !this.getTurn().isEndTurnRequested()) {
      if (!resuming) {
        state.getPlayers().resetPassed();
        state.getPlayerList().setCurrent(activePlayerId);
      }
 else {
        state.getPlayerList().setCurrent(this.getPriorityPlayerId());
      }
      fireUpdatePlayersEvent();
      Player player;
      while (!isPaused() && !gameOver(null)) {
        try {
          if (bookmark == 0) {
            bookmark=bookmarkState();
          }
          player=getPlayer(state.getPlayerList().get());
          state.setPriorityPlayerId(player.getId());
          while (!player.isPassed() && player.isInGame() && !isPaused()&& !gameOver(null)) {
            if (!resuming) {
              checkStateAndTriggered();
              applyEffects();
              if (state.getStack().isEmpty()) {
                resetLKI();
              }
              saveState(false);
              if (isPaused() || gameOver(null)) {
                return;
              }
              if (player.priority(this)) {
                if (executingRollback()) {
                  return;
                }
                applyEffects();
              }
              if (isPaused()) {
                return;
              }
            }
            resuming=false;
          }
          resetShortLivingLKI();
          resuming=false;
          if (isPaused() || gameOver(null)) {
            return;
          }
          if (allPassed()) {
            if (!state.getStack().isEmpty()) {
              resolve();
              applyEffects();
              state.getPlayers().resetPassed();
              fireUpdatePlayersEvent();
              state.getRevealed().reset();
              resetShortLivingLKI();
              break;
            }
 else {
              resetLKI();
              return;
            }
          }
        }
 catch (        Exception ex) {
          logger.fatal(""String_Node_Str"" + getId(),ex);
          ex.printStackTrace();
          this.fireErrorEvent(""String_Node_Str"",ex);
          restoreState(bookmark,""String_Node_Str"");
          bookmark=0;
          continue;
        }
        state.getPlayerList().getNext();
      }
    }
  }
 catch (  Exception ex) {
    logger.fatal(""String_Node_Str"",ex);
    this.fireErrorEvent(""String_Node_Str"",ex);
  }
 finally {
    resetLKI();
    clearAllBookmarks();
  }
}",0.9960364645263576
158897,"private void btnQuickStartActionPerformed(java.awt.event.ActionEvent evt){
  TableView table;
  try {
    File f=new File(""String_Node_Str"");
    if (!f.exists()) {
      JOptionPane.showMessageDialog(null,""String_Node_Str"",""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
      return;
    }
    MatchOptions options=new MatchOptions(""String_Node_Str"",""String_Node_Str"");
    options.getPlayerTypes().add(""String_Node_Str"");
    options.getPlayerTypes().add(""String_Node_Str"");
    options.setDeckType(""String_Node_Str"");
    options.setAttackOption(MultiplayerAttackOption.LEFT);
    options.setRange(RangeOfInfluence.ALL);
    options.setWinsNeeded(1);
    options.setMatchTimeLimit(MatchTimeLimit.NONE);
    options.setFreeMulligans(2);
    options.setSkillLevel(SkillLevel.CASUAL);
    table=session.createTable(roomId,options);
    session.joinTable(roomId,table.getTableId(),""String_Node_Str"",""String_Node_Str"",1,DeckImporterUtil.importDeck(""String_Node_Str""),""String_Node_Str"");
    session.joinTable(roomId,table.getTableId(),""String_Node_Str"",""String_Node_Str"",5,DeckImporterUtil.importDeck(""String_Node_Str""),""String_Node_Str"");
    session.startMatch(roomId,table.getTableId());
  }
 catch (  HeadlessException ex) {
    handleError(ex);
  }
}","private void btnQuickStartActionPerformed(java.awt.event.ActionEvent evt){
  TableView table;
  try {
    File f=new File(""String_Node_Str"");
    if (!f.exists()) {
      JOptionPane.showMessageDialog(null,""String_Node_Str"",""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
      return;
    }
    MatchOptions options=new MatchOptions(""String_Node_Str"",""String_Node_Str"");
    options.getPlayerTypes().add(""String_Node_Str"");
    options.getPlayerTypes().add(""String_Node_Str"");
    options.setDeckType(""String_Node_Str"");
    options.setAttackOption(MultiplayerAttackOption.LEFT);
    options.setRange(RangeOfInfluence.ALL);
    options.setWinsNeeded(1);
    options.setMatchTimeLimit(MatchTimeLimit.NONE);
    options.setFreeMulligans(2);
    options.setSkillLevel(SkillLevel.CASUAL);
    options.setRollbackTurnsAllowed(true);
    table=session.createTable(roomId,options);
    session.joinTable(roomId,table.getTableId(),""String_Node_Str"",""String_Node_Str"",1,DeckImporterUtil.importDeck(""String_Node_Str""),""String_Node_Str"");
    session.joinTable(roomId,table.getTableId(),""String_Node_Str"",""String_Node_Str"",5,DeckImporterUtil.importDeck(""String_Node_Str""),""String_Node_Str"");
    session.startMatch(roomId,table.getTableId());
  }
 catch (  HeadlessException ex) {
    handleError(ex);
  }
}",0.983117393011386
158898,"private ImageIcon getCountryFlagIcon(String countryCode){
  ImageIcon flagIcon=flagIconCache.get(countryCode);
  if (flagIcon == null) {
    flagIcon=new javax.swing.ImageIcon(getClass().getResource(""String_Node_Str"" + countryCode + ""String_Node_Str""));
    if (flagIcon.getImage() == null) {
      logger.warn(""String_Node_Str"" + countryCode);
    }
 else {
      flagIconCache.put(countryCode,flagIcon);
    }
  }
  return flagIcon;
}","private ImageIcon getCountryFlagIcon(String countryCode){
  ImageIcon flagIcon=flagIconCache.get(countryCode);
  if (flagIcon == null) {
    flagIcon=new javax.swing.ImageIcon(getClass().getResource(""String_Node_Str"" + countryCode + (countryCode.endsWith(""String_Node_Str"") ? ""String_Node_Str"" : ""String_Node_Str"")));
    if (flagIcon.getImage() == null) {
      logger.warn(""String_Node_Str"" + countryCode);
    }
 else {
      flagIconCache.put(countryCode,flagIcon);
    }
  }
  return flagIcon;
}",0.9316239316239316
158899,"@Override public boolean isAvailable(Game game,Ability source){
  RefractionTrapWatcher watcher=(RefractionTrapWatcher)game.getState().getWatchers().get(""String_Node_Str"");
  if (watcher != null && watcher.conditionMet()) {
    return true;
  }
  return false;
}","@Override public boolean isAvailable(Game game,Ability source){
  RefractionTrapWatcher watcher=(RefractionTrapWatcher)game.getState().getWatchers().get(""String_Node_Str"");
  return watcher != null && watcher.conditionMetForAnOpponent(source.getControllerId(),game);
}",0.8188679245283019
158900,"@Override public boolean applies(GameEvent event,Ability source,Game game){
  if (!this.used && super.applies(event,source,game)) {
    MageObject object=game.getObject(event.getSourceId());
    if (object == null) {
      game.informPlayers(""String_Node_Str"");
      return false;
    }
    if (!object.getId().equals(source.getFirstTarget())) {
      return false;
    }
    Permanent permanent=game.getPermanent(event.getTargetId());
    if (permanent != null) {
      if (permanent.getControllerId().equals(source.getControllerId())) {
        return true;
      }
    }
    Player player=game.getPlayer(event.getTargetId());
    if (player != null) {
      if (player.getId().equals(source.getControllerId())) {
        return true;
      }
    }
  }
  return false;
}","@Override public boolean applies(GameEvent event,Ability source,Game game){
  if (!this.used && super.applies(event,source,game)) {
    MageObject object=game.getObject(event.getSourceId());
    if (object == null) {
      game.informPlayers(""String_Node_Str"");
      return false;
    }
    if (!object.getId().equals(target.getFirstTarget()) && !((object instanceof StackObject) && ((StackObject)object).getSourceId().equals(target.getFirstTarget()))) {
      return false;
    }
    Permanent permanent=game.getPermanent(event.getTargetId());
    if (permanent != null) {
      if (permanent.getControllerId().equals(source.getControllerId())) {
        return true;
      }
    }
    Player player=game.getPlayer(event.getTargetId());
    if (player != null) {
      if (player.getId().equals(source.getControllerId())) {
        return true;
      }
    }
  }
  return false;
}",0.9268882175226586
158901,"@Override public void watch(GameEvent event,Game game){
  if (condition == true) {
    return;
  }
  if (event.getType() == GameEvent.EventType.SPELL_CAST && game.getOpponents(controllerId).contains(event.getPlayerId())) {
    Spell spell=game.getStack().getSpell(event.getTargetId());
    if (spell.getColor(game).isRed()) {
      if (spell.getCardType().contains(CardType.INSTANT) || spell.getCardType().contains(CardType.SORCERY)) {
        condition=true;
      }
    }
  }
}","@Override public void watch(GameEvent event,Game game){
  if (event.getType() == GameEvent.EventType.SPELL_CAST) {
    Spell spell=game.getStack().getSpell(event.getTargetId());
    if (spell.getColor(game).isRed()) {
      if (spell.getCardType().contains(CardType.INSTANT) || spell.getCardType().contains(CardType.SORCERY)) {
        playersMetCondition.add(event.getPlayerId());
      }
    }
  }
}",0.8113636363636364
158902,"@Override public boolean replaceEvent(GameEvent event,Ability source,Game game){
  GameEvent preventEvent=new GameEvent(GameEvent.EventType.PREVENT_DAMAGE,source.getFirstTarget(),source.getSourceId(),source.getControllerId(),event.getAmount(),false);
  if (!game.replaceEvent(preventEvent)) {
    int prevented=0;
    if (event.getAmount() >= this.amount) {
      int damage=amount;
      event.setAmount(event.getAmount() - amount);
      this.used=true;
      game.fireEvent(GameEvent.getEvent(GameEvent.EventType.PREVENTED_DAMAGE,source.getFirstTarget(),source.getSourceId(),source.getControllerId(),damage));
      prevented=damage;
    }
 else {
      int damage=event.getAmount();
      event.setAmount(0);
      amount-=damage;
      game.fireEvent(GameEvent.getEvent(GameEvent.EventType.PREVENTED_DAMAGE,source.getFirstTarget(),source.getSourceId(),source.getControllerId(),damage));
      prevented=damage;
    }
    if (prevented > 0) {
      UUID damageTarget=source.getTargets().get(1).getFirstTarget();
      Permanent target=game.getPermanent(damageTarget);
      if (target != null) {
        game.informPlayers(""String_Node_Str"" + prevented + ""String_Node_Str""+ target.getName());
        target.damage(prevented,source.getSourceId(),game,false,true);
      }
      Player player=game.getPlayer(damageTarget);
      if (player != null) {
        game.informPlayers(""String_Node_Str"" + prevented + ""String_Node_Str""+ player.getLogName());
        player.damage(prevented,source.getSourceId(),game,true,false);
      }
    }
  }
  return false;
}","@Override public boolean replaceEvent(GameEvent event,Ability source,Game game){
  PreventionEffectData preventionData=preventDamageAction(event,source,game);
  this.used=true;
  this.discard();
  if (preventionData.getPreventedDamage() > 0) {
    UUID damageTarget=getTargetPointer().getFirst(game,source);
    Permanent permanent=game.getPermanent(damageTarget);
    if (permanent != null) {
      game.informPlayers(""String_Node_Str"" + preventionData.getPreventedDamage() + ""String_Node_Str""+ permanent.getLogName());
      permanent.damage(preventionData.getPreventedDamage(),source.getSourceId(),game,false,true);
    }
    Player player=game.getPlayer(damageTarget);
    if (player != null) {
      game.informPlayers(""String_Node_Str"" + preventionData.getPreventedDamage() + ""String_Node_Str""+ player.getLogName());
      player.damage(preventionData.getPreventedDamage(),source.getSourceId(),game,true,false);
    }
  }
  return false;
}",0.4343313373253493
158903,"@Override public void reset(){
  super.reset();
  condition=false;
}","@Override public void reset(){
  playersMetCondition.clear();
  super.reset();
}",0.6621621621621622
158904,"public RefractionTrapPreventDamageEffect(final RefractionTrapPreventDamageEffect effect){
  super(effect);
  this.amount=effect.amount;
}","public RefractionTrapPreventDamageEffect(final RefractionTrapPreventDamageEffect effect){
  super(effect);
  this.amount=effect.amount;
  this.target=effect.target.copy();
}",0.8838709677419355
158905,"public RefractionTrapWatcher(final RefractionTrapWatcher watcher){
  super(watcher);
}","public RefractionTrapWatcher(final RefractionTrapWatcher watcher){
  super(watcher);
  this.playersMetCondition.addAll(watcher.playersMetCondition);
}",0.7288135593220338
158906,"@Override public boolean apply(MageObject input,Game game){
  Abilities<Ability> abilities=input.getAbilities();
  for (int i=0; i < abilities.size(); i++) {
    if (abilityClass.equals(abilities.get(i).getClass())) {
      return true;
    }
  }
  return false;
}","@Override public boolean apply(MageObject input,Game game){
  Abilities<Ability> abilities;
  if (input instanceof Card) {
    abilities=((Card)input).getAbilities(game);
  }
 else {
    abilities=input.getAbilities();
  }
  for (  Ability ability : abilities) {
    if (abilityClass.equals(ability.getClass())) {
      return true;
    }
  }
  return false;
}",0.3846153846153846
158907,"/** 
 * 800.4a When a player leaves the game, all objects (see rule 109) owned by that player leave the game and any effects which give that player control of any objects or players end. Then, if that player controlled any objects on the stack not represented by cards, those objects cease to exist. Then, if there are any objects still controlled by that player, those objects are exiled. This is not a state-based action. It happens as soon as the player leaves the game. If the player who left the game had priority at the time he or she left, priority passes to the next player in turn order who's still in the game. #
 * @param playerId
 */
protected void leave(UUID playerId){
  Player player=getPlayer(playerId);
  if (player == null || player.hasLeft()) {
    logger.debug(""String_Node_Str"" + (player != null ? player.getName() : playerId));
    return;
  }
  logger.debug(""String_Node_Str"" + player.getName());
  player.leave();
  if (checkIfGameIsOver()) {
    return;
  }
  for (Iterator<Permanent> it=getBattlefield().getAllPermanents().iterator(); it.hasNext(); ) {
    Permanent perm=it.next();
    if (perm.getOwnerId().equals(playerId)) {
      if (perm.getAttachedTo() != null) {
        Permanent attachedTo=getPermanent(perm.getAttachedTo());
        if (attachedTo != null) {
          attachedTo.removeAttachment(perm.getId(),this);
        }
 else {
          Player attachedToPlayer=getPlayer(perm.getAttachedTo());
          if (attachedToPlayer != null) {
            attachedToPlayer.removeAttachment(perm.getId(),this);
          }
        }
      }
      if (perm.getCardType().contains(CardType.CREATURE) && this.getCombat() != null) {
        this.getCombat().removeFromCombat(perm.getId(),this);
      }
      it.remove();
    }
  }
  this.getState().getContinuousEffects().removeInactiveEffects(this);
  for (Iterator<StackObject> it=getStack().iterator(); it.hasNext(); ) {
    StackObject object=it.next();
    if (object.getControllerId().equals(playerId)) {
      it.remove();
    }
  }
  List<Permanent> permanents=this.getBattlefield().getAllActivePermanents(playerId);
  for (  Permanent permanent : permanents) {
    permanent.moveToExile(null,""String_Node_Str"",null,this);
  }
  for (  ExileZone exile : this.getExile().getExileZones()) {
    for (Iterator<UUID> it=exile.iterator(); it.hasNext(); ) {
      Card card=this.getCard(it.next());
      if (card != null && card.getOwnerId().equals(playerId)) {
        it.remove();
      }
    }
  }
  Iterator it=gameCards.entrySet().iterator();
  while (it.hasNext()) {
    Entry<UUID,Card> entry=(Entry<UUID,Card>)it.next();
    Card card=entry.getValue();
    if (card.getOwnerId().equals(playerId)) {
      it.remove();
    }
  }
}","/** 
 * 800.4a When a player leaves the game, all objects (see rule 109) owned by that player leave the game and any effects which give that player control of any objects or players end. Then, if that player controlled any objects on the stack not represented by cards, those objects cease to exist. Then, if there are any objects still controlled by that player, those objects are exiled. This is not a state-based action. It happens as soon as the player leaves the game. If the player who left the game had priority at the time he or she left, priority passes to the next player in turn order who's still in the game. #
 * @param playerId
 */
protected void leave(UUID playerId){
  Player player=getPlayer(playerId);
  if (player == null || player.hasLeft()) {
    logger.debug(""String_Node_Str"" + (player != null ? player.getName() : playerId));
    return;
  }
  logger.debug(""String_Node_Str"" + player.getName());
  player.leave();
  if (checkIfGameIsOver()) {
    return;
  }
  for (Iterator<Permanent> it=getBattlefield().getAllPermanents().iterator(); it.hasNext(); ) {
    Permanent perm=it.next();
    if (perm.getOwnerId().equals(playerId)) {
      if (perm.getAttachedTo() != null) {
        Permanent attachedTo=getPermanent(perm.getAttachedTo());
        if (attachedTo != null) {
          attachedTo.removeAttachment(perm.getId(),this);
        }
 else {
          Player attachedToPlayer=getPlayer(perm.getAttachedTo());
          if (attachedToPlayer != null) {
            attachedToPlayer.removeAttachment(perm,this);
          }
        }
      }
      if (perm.getCardType().contains(CardType.CREATURE) && this.getCombat() != null) {
        this.getCombat().removeFromCombat(perm.getId(),this);
      }
      it.remove();
    }
  }
  this.getState().getContinuousEffects().removeInactiveEffects(this);
  for (Iterator<StackObject> it=getStack().iterator(); it.hasNext(); ) {
    StackObject object=it.next();
    if (object.getControllerId().equals(playerId)) {
      it.remove();
    }
  }
  List<Permanent> permanents=this.getBattlefield().getAllActivePermanents(playerId);
  for (  Permanent permanent : permanents) {
    permanent.moveToExile(null,""String_Node_Str"",null,this);
  }
  for (  ExileZone exile : this.getExile().getExileZones()) {
    for (Iterator<UUID> it=exile.iterator(); it.hasNext(); ) {
      Card card=this.getCard(it.next());
      if (card != null && card.getOwnerId().equals(playerId)) {
        it.remove();
      }
    }
  }
  Iterator it=gameCards.entrySet().iterator();
  while (it.hasNext()) {
    Entry<UUID,Card> entry=(Entry<UUID,Card>)it.next();
    Card card=entry.getValue();
    if (card.getOwnerId().equals(playerId)) {
      it.remove();
    }
  }
}",0.9985288709084222
158908,"boolean removeAttachment(UUID permanentId,Game game);","boolean removeAttachment(Permanent permanent,Game game);",0.8623853211009175
158909,"@Override public boolean removeAttachment(UUID permanentId,Game game){
  if (this.attachments.contains(permanentId)) {
    Permanent aura=game.getPermanent(permanentId);
    if (aura != null) {
      if (!game.replaceEvent(new GameEvent(GameEvent.EventType.UNATTACH,playerId,permanentId,aura.getControllerId()))) {
        this.attachments.remove(permanentId);
        aura.attachTo(null,game);
      }
      game.fireEvent(new GameEvent(GameEvent.EventType.UNATTACHED,playerId,permanentId,aura.getControllerId()));
      return true;
    }
  }
  return false;
}","@Override public boolean removeAttachment(Permanent attachment,Game game){
  if (this.attachments.contains(attachment.getId())) {
    if (!game.replaceEvent(new GameEvent(GameEvent.EventType.UNATTACH,playerId,attachment.getId(),attachment.getControllerId()))) {
      this.attachments.remove(attachment.getId());
      attachment.attachTo(null,game);
      game.fireEvent(new GameEvent(GameEvent.EventType.UNATTACHED,playerId,attachment.getId(),attachment.getControllerId()));
      return true;
    }
  }
  return false;
}",0.4995391705069124
158910,"@Override public boolean removeFromBattlefield(Permanent permanent,Game game){
  permanent.removeFromCombat(game,false);
  if (permanent.getAttachedTo() != null) {
    Permanent attachedTo=game.getPermanent(permanent.getAttachedTo());
    if (attachedTo != null) {
      attachedTo.removeAttachment(permanent.getId(),game);
    }
 else {
      Player attachedToPlayer=game.getPlayer(permanent.getAttachedTo());
      if (attachedToPlayer != null) {
        attachedToPlayer.removeAttachment(permanent.getId(),game);
      }
    }
  }
  if (permanent.getPairedCard() != null) {
    Permanent pairedCard=game.getPermanent(permanent.getPairedCard());
    if (pairedCard != null) {
      pairedCard.clearPairedCard();
    }
  }
  game.getBattlefield().removePermanent(permanent.getId());
  return true;
}","@Override public boolean removeFromBattlefield(Permanent permanent,Game game){
  permanent.removeFromCombat(game,false);
  game.getBattlefield().removePermanent(permanent.getId());
  if (permanent.getAttachedTo() != null) {
    Permanent attachedTo=game.getPermanent(permanent.getAttachedTo());
    if (attachedTo != null) {
      attachedTo.removeAttachment(permanent.getId(),game);
    }
 else {
      Player attachedToPlayer=game.getPlayer(permanent.getAttachedTo());
      if (attachedToPlayer != null) {
        attachedToPlayer.removeAttachment(permanent,game);
      }
    }
  }
  if (permanent.getPairedCard() != null) {
    Permanent pairedCard=game.getPermanent(permanent.getPairedCard());
    if (pairedCard != null) {
      pairedCard.clearPairedCard();
    }
  }
  return true;
}",0.9195979899497488
158911,"@Override public boolean applies(GameEvent event,Ability source,Game game){
  if (event.getType() == EventType.CAST_SPELL && game.getOpponents(source.getControllerId()).contains(event.getPlayerId())) {
    return true;
  }
  return false;
}","@Override public boolean applies(GameEvent event,Ability source,Game game){
  return game.getOpponents(source.getControllerId()).contains(event.getPlayerId());
}",0.7880299251870324
158912,"private boolean checkAbilityStillExists(Ability ability,ContinuousEffect effect,GameEvent event,Game game){
  if (effect.getDuration().equals(Duration.OneUse) || effect.getDuration().equals(Duration.Custom) || ability.getSourceId() == null) {
    return true;
  }
  MageObject object;
  if (event.getType().equals(EventType.ZONE_CHANGE) && ((ZoneChangeEvent)event).getFromZone().equals(Zone.BATTLEFIELD) && event.getTargetId().equals(ability.getSourceId())) {
    object=((ZoneChangeEvent)event).getTarget();
  }
 else {
    object=game.getObject(ability.getSourceId());
  }
  if (object == null) {
    return false;
  }
  boolean exists=true;
  if (!object.getAbilities().contains(ability)) {
    exists=false;
    if (object instanceof PermanentCard) {
      PermanentCard permanent=(PermanentCard)object;
      if (permanent.canTransform() && event.getType() == GameEvent.EventType.TRANSFORMED) {
        exists=permanent.getCard().getAbilities().contains(ability);
      }
    }
  }
 else {
    if (object instanceof PermanentCard) {
      PermanentCard permanent=(PermanentCard)object;
      if (permanent.isFaceDown(game) && !ability.getWorksFaceDown()) {
        return false;
      }
    }
 else     if (object instanceof Spell) {
      Spell spell=(Spell)object;
      if (spell.isFaceDown(game) && !ability.getWorksFaceDown()) {
        return false;
      }
    }
  }
  return exists;
}","private boolean checkAbilityStillExists(Ability ability,ContinuousEffect effect,GameEvent event,Game game){
switch (effect.getDuration()) {
case EndOfCombat:
case EndOfGame:
case EndOfStep:
case EndOfTurn:
case OneUse:
case Custom:
    return true;
}
if (ability.getSourceId() == null) {
  return true;
}
MageObject object;
if (event.getType().equals(EventType.ZONE_CHANGE) && ((ZoneChangeEvent)event).getFromZone().equals(Zone.BATTLEFIELD) && event.getTargetId().equals(ability.getSourceId())) {
  object=((ZoneChangeEvent)event).getTarget();
}
 else {
  object=game.getObject(ability.getSourceId());
}
if (object == null) {
  return false;
}
boolean exists=true;
if (!object.getAbilities().contains(ability)) {
  exists=false;
  if (object instanceof PermanentCard) {
    PermanentCard permanent=(PermanentCard)object;
    if (permanent.canTransform() && event.getType() == GameEvent.EventType.TRANSFORMED) {
      exists=permanent.getCard().getAbilities().contains(ability);
    }
  }
}
 else {
  if (object instanceof PermanentCard) {
    PermanentCard permanent=(PermanentCard)object;
    if (permanent.isFaceDown(game) && !ability.getWorksFaceDown()) {
      return false;
    }
  }
 else   if (object instanceof Spell) {
    Spell spell=(Spell)object;
    if (spell.isFaceDown(game) && !ability.getWorksFaceDown()) {
      return false;
    }
  }
}
return exists;
}",0.869628024557602
158913,"public void clear(){
  battlefield.clear();
  effects.clear();
  triggers.clear();
  delayed.clear();
  triggered.clear();
  stack.clear();
  exile.clear();
  command.clear();
  revealed.clear();
  lookedAt.clear();
  turnNum=0;
  stepNum=0;
  extraTurn=false;
  legendaryRuleActive=true;
  gameOver=false;
  specialActions.clear();
  cardState.clear();
  combat.clear();
  turnMods.clear();
  watchers.clear();
  values.clear();
  zones.clear();
  simultaneousEvents.clear();
  permanentOrderNumber=0;
}","public void clear(){
  battlefield.clear();
  effects.clear();
  triggers.clear();
  delayed.clear();
  triggered.clear();
  stack.clear();
  exile.clear();
  command.clear();
  revealed.clear();
  lookedAt.clear();
  turnNum=0;
  stepNum=0;
  extraTurn=false;
  legendaryRuleActive=true;
  gameOver=false;
  specialActions.clear();
  cardState.clear();
  combat.clear();
  turnMods.clear();
  watchers.clear();
  values.clear();
  zones.clear();
  simultaneousEvents.clear();
  copiedCards.clear();
  permanentOrderNumber=0;
}",0.9776915615906888
158914,"public ManaAbility(final ManaAbility ability){
  super(ability);
  this.netMana.addAll(ability.netMana);
}","public ManaAbility(final ManaAbility ability){
  super(ability);
  this.netMana.addAll(ability.netMana);
  this.undoPossible=ability.undoPossible;
}",0.8346456692913385
158915,"@Override public void pickCard(List<Card> cards,Deck deck,Draft draft){
  if (cards.isEmpty()) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  try {
    Card bestCard=pickBestCard(cards,chosenColors);
    int maxScore=RateCard.rateCard(bestCard,chosenColors);
    int pickedCardRate=RateCard.getCardRating(bestCard);
    if (pickedCardRate <= 3) {
      Card counterPick=pickBestCard(cards,null);
      int counterPickScore=RateCard.getCardRating(counterPick);
      if (counterPickScore >= 8) {
        bestCard=counterPick;
        maxScore=RateCard.rateCard(bestCard,chosenColors);
      }
    }
    String colors=""String_Node_Str"";
    if (chosenColors == null) {
      rememberPick(bestCard,maxScore);
      chosenColors=chooseDeckColorsIfPossible();
    }
    if (chosenColors != null) {
      colors=""String_Node_Str"";
      for (      ColoredManaSymbol symbol : chosenColors) {
        colors+=symbol.toString();
      }
    }
    log.debug(""String_Node_Str"" + bestCard.getName() + ""String_Node_Str""+ maxScore+ ""String_Node_Str""+ colors);
    draft.addPick(playerId,bestCard.getId(),null);
  }
 catch (  Exception e) {
    e.printStackTrace();
    draft.addPick(playerId,cards.get(0).getId(),null);
  }
}","@Override public void pickCard(List<Card> cards,Deck deck,Draft draft){
  if (cards.isEmpty()) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  try {
    Card bestCard=pickBestCard(cards,chosenColors);
    int maxScore=RateCard.rateCard(bestCard,chosenColors);
    int pickedCardRate=RateCard.getCardRating(bestCard);
    if (pickedCardRate <= 3) {
      Card counterPick=pickBestCard(cards,null);
      int counterPickScore=RateCard.getCardRating(counterPick);
      if (counterPickScore >= 8) {
        bestCard=counterPick;
        maxScore=RateCard.rateCard(bestCard,chosenColors);
      }
    }
    String colors=""String_Node_Str"";
    if (chosenColors == null) {
      rememberPick(bestCard,maxScore);
      chosenColors=chooseDeckColorsIfPossible();
    }
    if (chosenColors != null) {
      colors=""String_Node_Str"";
      for (      ColoredManaSymbol symbol : chosenColors) {
        colors+=symbol.toString();
      }
    }
    log.debug(""String_Node_Str"" + bestCard.getName() + ""String_Node_Str""+ maxScore+ ""String_Node_Str""+ colors);
    draft.addPick(playerId,bestCard.getId(),null);
  }
 catch (  Exception e) {
    log.debug(""String_Node_Str"" + getId());
    draft.addPick(playerId,cards.get(0).getId(),null);
  }
}",0.9609028617492946
158916,"@Override public boolean playMana(ManaCost unpaid,String promptText,Game game){
  payManaMode=true;
  boolean result=playManaHandling(unpaid,game);
  payManaMode=false;
  return result;
}","@Override public boolean playMana(ManaCost unpaid,String promptText,Game game){
  payManaMode=true;
  currentUnpaidMana=unpaid;
  boolean result=playManaHandling(unpaid,game);
  currentUnpaidMana=null;
  payManaMode=false;
  return result;
}",0.8738317757009346
158917,"@Override public boolean chooseTarget(Outcome outcome,Cards cards,TargetCard target,Ability source,Game game){
  log.debug(""String_Node_Str"");
  if (cards == null || cards.isEmpty()) {
    if (!target.isRequired(source)) {
      return false;
    }
    return true;
  }
  ArrayList<Card> cardChoices=new ArrayList<>(cards.getCards(target.getFilter(),game));
  while (!target.doneChosing()) {
    Card card=pickTarget(cardChoices,outcome,target,source,game);
    if (card != null) {
      target.addTarget(card.getId(),source,game);
      cardChoices.remove(card);
    }
 else {
      return target.getTargets().size() < target.getNumberOfTargets();
    }
    if (outcome.equals(Outcome.Neutral) && target.getTargets().size() > target.getNumberOfTargets() + (target.getMaxNumberOfTargets() - target.getNumberOfTargets()) / 2) {
      return true;
    }
  }
  return true;
}","@Override public boolean chooseTarget(Outcome outcome,Cards cards,TargetCard target,Ability source,Game game){
  log.debug(""String_Node_Str"");
  if (cards == null || cards.isEmpty()) {
    return target.isRequired(source);
  }
  ArrayList<Card> cardChoices=new ArrayList<>(cards.getCards(target.getFilter(),game));
  while (!target.doneChosing()) {
    Card card=pickTarget(cardChoices,outcome,target,source,game);
    if (card != null) {
      target.addTarget(card.getId(),source,game);
      cardChoices.remove(card);
    }
 else {
      return target.getTargets().size() < target.getNumberOfTargets();
    }
    if (outcome.equals(Outcome.Neutral) && target.getTargets().size() > target.getNumberOfTargets() + (target.getMaxNumberOfTargets() - target.getNumberOfTargets()) / 2) {
      return true;
    }
  }
  return true;
}",0.9664902998236332
158918,"@Override public boolean chooseTarget(Outcome outcome,Target target,Ability source,Game game){
  if (!targets.isEmpty()) {
    if ((target instanceof TargetPermanent) || (target instanceof TargetPermanentOrPlayer)) {
      for (      String targetDefinition : targets) {
        String[] targetList=targetDefinition.split(""String_Node_Str"");
        boolean targetFound=false;
        for (        String targetName : targetList) {
          boolean allowCopy=true;
          if (targetName.endsWith(""String_Node_Str"")) {
            allowCopy=false;
            targetName=targetName.substring(0,targetName.length() - 9);
          }
          for (          Permanent permanent : game.getBattlefield().getAllActivePermanents((FilterPermanent)target.getFilter(),game)) {
            if (permanent.getName().equals(targetName) || (permanent.getName() + ""String_Node_Str"" + permanent.getExpansionSetCode()).equals(targetName)) {
              if (((TargetPermanent)target).canTarget(source == null ? this.getId() : source.getControllerId(),permanent.getId(),source,game) && !target.getTargets().contains(permanent.getId())) {
                if (!permanent.isCopy() || allowCopy) {
                  target.add(permanent.getId(),game);
                  targetFound=true;
                  break;
                }
              }
            }
          }
        }
        if (targetFound) {
          targets.remove(targetDefinition);
          return true;
        }
      }
    }
    if (target instanceof TargetPlayer) {
      for (      String targetDefinition : targets) {
        if (targetDefinition.startsWith(""String_Node_Str"")) {
          String playerName=targetDefinition.substring(targetDefinition.indexOf(""String_Node_Str"") + 13);
          for (          Player player : game.getPlayers().values()) {
            if (player.getName().equals(playerName) && ((TargetPlayer)target).canTarget(playerId,player.getId(),source,game)) {
              target.add(player.getId(),game);
              return true;
            }
          }
        }
      }
    }
    if (target instanceof TargetCardInHand) {
      for (      String targetDefinition : targets) {
        String[] targetList=targetDefinition.split(""String_Node_Str"");
        boolean targetFound=false;
        for (        String targetName : targetList) {
          for (          Card card : this.getHand().getCards(((TargetCardInHand)target).getFilter(),game)) {
            if (card.getName().equals(targetName) || (card.getName() + ""String_Node_Str"" + card.getExpansionSetCode()).equals(targetName)) {
              if (((TargetCardInHand)target).canTarget(source.getControllerId(),card.getId(),source,game) && !target.getTargets().contains(card.getId())) {
                target.add(card.getId(),game);
                targetFound=true;
                break;
              }
            }
          }
        }
        if (targetFound) {
          targets.remove(targetDefinition);
          return true;
        }
      }
    }
    if (target instanceof TargetSpell) {
      for (      String targetDefinition : targets) {
        String[] targetList=targetDefinition.split(""String_Node_Str"");
        boolean targetFound=false;
        for (        String targetName : targetList) {
          for (          StackObject stackObject : game.getStack()) {
            if (stackObject.getName().equals(targetName)) {
              target.add(stackObject.getId(),game);
              targetFound=true;
              break;
            }
          }
        }
        if (targetFound) {
          targets.remove(targetDefinition);
          return true;
        }
      }
    }
  }
  return super.chooseTarget(outcome,target,source,game);
}","@Override public boolean chooseTarget(Outcome outcome,Target target,Ability source,Game game){
  if (!targets.isEmpty()) {
    if ((target instanceof TargetPermanent) || (target instanceof TargetPermanentOrPlayer)) {
      for (      String targetDefinition : targets) {
        String[] targetList=targetDefinition.split(""String_Node_Str"");
        boolean targetFound=false;
        for (        String targetName : targetList) {
          boolean originOnly=false;
          boolean copyOnly=false;
          if (targetName.endsWith(""String_Node_Str"")) {
            if (targetName.endsWith(""String_Node_Str"")) {
              originOnly=true;
              targetName=targetName.substring(0,targetName.length() - 9);
            }
            if (targetName.endsWith(""String_Node_Str"")) {
              copyOnly=true;
              targetName=targetName.substring(0,targetName.length() - 11);
            }
          }
          for (          Permanent permanent : game.getBattlefield().getAllActivePermanents((FilterPermanent)target.getFilter(),game)) {
            if (permanent.getName().equals(targetName) || (permanent.getName() + ""String_Node_Str"" + permanent.getExpansionSetCode()).equals(targetName)) {
              if (((TargetPermanent)target).canTarget(source == null ? this.getId() : source.getControllerId(),permanent.getId(),source,game) && !target.getTargets().contains(permanent.getId())) {
                if ((permanent.isCopy() && !originOnly) || (!permanent.isCopy() && !copyOnly)) {
                  target.add(permanent.getId(),game);
                  targetFound=true;
                  break;
                }
              }
            }
          }
        }
        if (targetFound) {
          targets.remove(targetDefinition);
          return true;
        }
      }
    }
    if (target instanceof TargetPlayer) {
      for (      String targetDefinition : targets) {
        if (targetDefinition.startsWith(""String_Node_Str"")) {
          String playerName=targetDefinition.substring(targetDefinition.indexOf(""String_Node_Str"") + 13);
          for (          Player player : game.getPlayers().values()) {
            if (player.getName().equals(playerName) && ((TargetPlayer)target).canTarget(playerId,player.getId(),source,game)) {
              target.add(player.getId(),game);
              return true;
            }
          }
        }
      }
    }
    if (target instanceof TargetCardInHand) {
      for (      String targetDefinition : targets) {
        String[] targetList=targetDefinition.split(""String_Node_Str"");
        boolean targetFound=false;
        for (        String targetName : targetList) {
          for (          Card card : this.getHand().getCards(((TargetCardInHand)target).getFilter(),game)) {
            if (card.getName().equals(targetName) || (card.getName() + ""String_Node_Str"" + card.getExpansionSetCode()).equals(targetName)) {
              if (((TargetCardInHand)target).canTarget(source.getControllerId(),card.getId(),source,game) && !target.getTargets().contains(card.getId())) {
                target.add(card.getId(),game);
                targetFound=true;
                break;
              }
            }
          }
        }
        if (targetFound) {
          targets.remove(targetDefinition);
          return true;
        }
      }
    }
    if (target instanceof TargetSpell) {
      for (      String targetDefinition : targets) {
        String[] targetList=targetDefinition.split(""String_Node_Str"");
        boolean targetFound=false;
        for (        String targetName : targetList) {
          for (          StackObject stackObject : game.getStack()) {
            if (stackObject.getName().equals(targetName)) {
              target.add(stackObject.getId(),game);
              targetFound=true;
              break;
            }
          }
        }
        if (targetFound) {
          targets.remove(targetDefinition);
          return true;
        }
      }
    }
  }
  return super.chooseTarget(outcome,target,source,game);
}",0.9501738122827348
158919,"protected void resolve(){
  StackObject top=null;
  try {
    top=state.getStack().peek();
    top.resolve(this);
  }
  finally {
    if (top != null) {
      state.getStack().remove(top);
      rememberLKI(top.getSourceId(),Zone.STACK,top);
      if (!getTurn().isEndTurnRequested()) {
        while (state.hasSimultaneousEvents()) {
          state.handleSimultaneousEvent(this);
          checkTriggered();
        }
      }
    }
  }
}","protected void resolve(){
  StackObject top=null;
  try {
    top=state.getStack().peek();
    top.resolve(this);
  }
  finally {
    if (top != null) {
      state.getStack().remove(top);
      rememberLKI(top.getSourceId(),Zone.STACK,top);
      if (!getTurn().isEndTurnRequested()) {
        while (state.hasSimultaneousEvents()) {
          state.handleSimultaneousEvent(this);
        }
      }
    }
  }
}",0.9176470588235294
158920,"@Override public boolean checkStateAndTriggered(){
  boolean trigger=!getTurn().isEndTurnRequested();
  boolean somethingHappened=false;
  while (!isPaused() && !gameOver(null)) {
    if (!checkStateBasedActions()) {
      if (trigger) {
        state.handleSimultaneousEvent(this);
      }
      if (isPaused() || gameOver(null) || !trigger|| !checkTriggered()) {
        break;
      }
    }
    applyEffects();
    somethingHappened=true;
  }
  return somethingHappened;
}","/** 
 * 116.5. Each time a player would get priority, the game first performs all applicable state-based actions as a single event (see rule 704, State-Based Actions), then repeats this process until no state-based actions are performed. Then triggered abilities are put on the stack (see rule 603, Handling Triggered Abilities). These steps repeat in order until no further state-based actions are performed and no abilities trigger. Then the player who would have received priority does so. 
 * @return 
 */
@Override public boolean checkStateAndTriggered(){
  boolean trigger=!getTurn().isEndTurnRequested();
  boolean somethingHappened=false;
  while (!isPaused() && !gameOver(null)) {
    if (!checkStateBasedActions()) {
      if (trigger) {
        state.handleSimultaneousEvent(this);
      }
      if (isPaused() || gameOver(null) || !trigger|| !checkTriggered()) {
        break;
      }
    }
    applyEffects();
    somethingHappened=true;
  }
  return somethingHappened;
}",0.6489071038251366
158921,"protected boolean checkStateBasedActions(){
  boolean somethingHappened=false;
  for (  Player player : state.getPlayers().values()) {
    if (!player.hasLost() && ((player.getLife() <= 0 && player.canLoseByZeroOrLessLife()) || player.isEmptyDraw() || player.getCounters().getCount(CounterType.POISON) >= 10)) {
      player.lost(this);
    }
  }
  Iterator<Card> copiedCards=this.getState().getCopiedCards().iterator();
  while (copiedCards.hasNext()) {
    Card card=copiedCards.next();
    Zone zone=state.getZone(card.getId());
    if (zone != Zone.BATTLEFIELD && zone != Zone.STACK) {
switch (zone) {
case GRAVEYARD:
        for (        Player player : getPlayers().values()) {
          if (player.getGraveyard().contains(card.getId())) {
            player.getGraveyard().remove(card);
            break;
          }
        }
      break;
case HAND:
    for (    Player player : getPlayers().values()) {
      if (player.getHand().contains(card.getId())) {
        player.getHand().remove(card);
        break;
      }
    }
  break;
case LIBRARY:
for (Player player : getPlayers().values()) {
  if (player.getLibrary().getCard(card.getId(),this) != null) {
    player.getLibrary().remove(card.getId(),this);
    break;
  }
}
break;
case EXILED:
getExile().removeCard(card,this);
break;
}
copiedCards.remove();
}
}
List<Permanent> planeswalkers=new ArrayList<>();
List<Permanent> legendary=new ArrayList<>();
for (Permanent perm : getBattlefield().getAllActivePermanents()) {
if (perm.getCardType().contains(CardType.CREATURE)) {
if (perm.getToughness().getValue() <= 0) {
if (movePermanentToGraveyardWithInfo(perm)) {
somethingHappened=true;
continue;
}
}
 else if (perm.getToughness().getValue() <= perm.getDamage() || perm.isDeathtouched()) {
if (perm.destroy(null,this,false)) {
somethingHappened=true;
continue;
}
}
if (perm.getPairedCard() != null) {
Permanent paired=getPermanent(perm.getPairedCard());
if (paired == null || !perm.getControllerId().equals(paired.getControllerId()) || paired.getPairedCard() == null) {
perm.setPairedCard(null);
if (paired != null) {
paired.setPairedCard(null);
}
somethingHappened=true;
}
}
}
 else if (perm.getPairedCard() != null) {
Permanent paired=getPermanent(perm.getPairedCard());
perm.setPairedCard(null);
if (paired != null) {
paired.setPairedCard(null);
}
somethingHappened=true;
}
if (perm.getCardType().contains(CardType.PLANESWALKER)) {
if (perm.getCounters().getCount(CounterType.LOYALTY) == 0) {
if (movePermanentToGraveyardWithInfo(perm)) {
somethingHappened=true;
continue;
}
}
planeswalkers.add(perm);
}
if (filterAura.match(perm,this)) {
if (perm.getAttachedTo() == null) {
Card card=this.getCard(perm.getId());
if (card != null && !card.getCardType().contains(CardType.CREATURE)) {
if (movePermanentToGraveyardWithInfo(perm)) {
somethingHappened=true;
}
}
}
 else {
if (perm.getSpellAbility().getTargets().isEmpty()) {
Permanent enchanted=this.getPermanent(perm.getAttachedTo());
logger.error(""String_Node_Str"" + perm.getName() + ""String_Node_Str""+ (enchanted == null ? ""String_Node_Str"" : enchanted.getName()));
}
 else {
Target target=perm.getSpellAbility().getTargets().get(0);
if (target instanceof TargetPermanent) {
Permanent attachedTo=getPermanent(perm.getAttachedTo());
if (attachedTo == null || !attachedTo.getAttachments().contains(perm.getId())) {
Card card=this.getCard(perm.getId());
if (card != null && card.getCardType().contains(CardType.CREATURE)) {
UUID wasAttachedTo=perm.getAttachedTo();
perm.attachTo(null,this);
fireEvent(new GameEvent(GameEvent.EventType.UNATTACHED,wasAttachedTo,perm.getId(),perm.getControllerId()));
}
 else {
if (movePermanentToGraveyardWithInfo(perm)) {
  somethingHappened=true;
}
}
}
 else {
Filter auraFilter=perm.getSpellAbility().getTargets().get(0).getFilter();
if (auraFilter instanceof FilterControlledCreaturePermanent) {
if (!((FilterControlledCreaturePermanent)auraFilter).match(attachedTo,perm.getId(),perm.getControllerId(),this) || attachedTo.cantBeEnchantedBy(perm,this)) {
  if (movePermanentToGraveyardWithInfo(perm)) {
    somethingHappened=true;
  }
}
}
 else {
if (!auraFilter.match(attachedTo,this) || attachedTo.cantBeEnchantedBy(perm,this)) {
  Card card=this.getCard(perm.getId());
  if (card != null && card.getCardType().contains(CardType.CREATURE)) {
    UUID wasAttachedTo=perm.getAttachedTo();
    perm.attachTo(null,this);
    fireEvent(new GameEvent(GameEvent.EventType.UNATTACHED,wasAttachedTo,perm.getId(),perm.getControllerId()));
  }
 else {
    if (movePermanentToGraveyardWithInfo(perm)) {
      somethingHappened=true;
    }
  }
}
}
}
}
 else if (target instanceof TargetPlayer) {
Player attachedToPlayer=getPlayer(perm.getAttachedTo());
if (attachedToPlayer == null) {
if (movePermanentToGraveyardWithInfo(perm)) {
somethingHappened=true;
}
}
 else {
Filter auraFilter=perm.getSpellAbility().getTargets().get(0).getFilter();
if (!auraFilter.match(attachedToPlayer,this) || attachedToPlayer.hasProtectionFrom(perm,this)) {
if (movePermanentToGraveyardWithInfo(perm)) {
  somethingHappened=true;
}
}
}
}
}
}
}
if (this.getState().isLegendaryRuleActive() && filterLegendary.match(perm,this)) {
legendary.add(perm);
}
if (filterEquipment.match(perm,this)) {
if (perm.getAttachedTo() != null) {
Permanent creature=getPermanent(perm.getAttachedTo());
if (creature == null || !creature.getAttachments().contains(perm.getId())) {
UUID wasAttachedTo=perm.getAttachedTo();
perm.attachTo(null,this);
fireEvent(new GameEvent(GameEvent.EventType.UNATTACHED,wasAttachedTo,perm.getId(),perm.getControllerId()));
}
 else if (!creature.getCardType().contains(CardType.CREATURE) || creature.hasProtectionFrom(perm,this)) {
if (creature.removeAttachment(perm.getId(),this)) {
somethingHappened=true;
}
}
}
}
if (filterFortification.match(perm,this)) {
if (perm.getAttachedTo() != null) {
Permanent land=getPermanent(perm.getAttachedTo());
if (land == null || !land.getAttachments().contains(perm.getId())) {
perm.attachTo(null,this);
}
 else if (!land.getCardType().contains(CardType.LAND) || land.hasProtectionFrom(perm,this)) {
if (land.removeAttachment(perm.getId(),this)) {
somethingHappened=true;
}
}
}
}
if (perm.getAttachments().size() > 0) {
for (UUID attachmentId : perm.getAttachments()) {
Permanent attachment=getPermanent(attachmentId);
if (attachment != null && (attachment.getCardType().contains(CardType.CREATURE) || !(attachment.getSubtype().contains(""String_Node_Str"") || attachment.getSubtype().contains(""String_Node_Str"") || attachment.getSubtype().contains(""String_Node_Str"")))) {
if (perm.removeAttachment(attachment.getId(),this)) {
somethingHappened=true;
break;
}
}
}
}
if (perm.getCounters().containsKey(CounterType.P1P1) && perm.getCounters().containsKey(CounterType.M1M1)) {
int p1p1=perm.getCounters().getCount(CounterType.P1P1);
int m1m1=perm.getCounters().getCount(CounterType.M1M1);
int min=Math.min(p1p1,m1m1);
perm.getCounters().removeCounter(CounterType.P1P1,min);
perm.getCounters().removeCounter(CounterType.M1M1,min);
}
}
if (planeswalkers.size() > 1) {
for (Permanent planeswalker : planeswalkers) {
for (String planeswalkertype : planeswalker.getSubtype()) {
FilterPlaneswalkerPermanent filterPlaneswalker=new FilterPlaneswalkerPermanent();
filterPlaneswalker.add(new SubtypePredicate(planeswalkertype));
filterPlaneswalker.add(new ControllerIdPredicate(planeswalker.getControllerId()));
if (getBattlefield().contains(filterPlaneswalker,planeswalker.getControllerId(),this,2)) {
Player controller=this.getPlayer(planeswalker.getControllerId());
if (controller != null) {
Target targetPlaneswalkerToKeep=new TargetPermanent(filterPlaneswalker);
targetPlaneswalkerToKeep.setTargetName(new StringBuilder(planeswalker.getName()).append(""String_Node_Str"").toString());
controller.chooseTarget(Outcome.Benefit,targetPlaneswalkerToKeep,null,this);
for (Permanent dupPlaneswalker : this.getBattlefield().getActivePermanents(filterPlaneswalker,planeswalker.getControllerId(),this)) {
if (!targetPlaneswalkerToKeep.getTargets().contains(dupPlaneswalker.getId())) {
movePermanentToGraveyardWithInfo(dupPlaneswalker);
}
}
}
return true;
}
}
}
}
if (legendary.size() > 1) {
for (Permanent legend : legendary) {
FilterPermanent filterLegendName=new FilterPermanent();
filterLegendName.add(new SupertypePredicate(""String_Node_Str""));
filterLegendName.add(new NamePredicate(legend.getName()));
filterLegendName.add(new ControllerIdPredicate(legend.getControllerId()));
if (getBattlefield().contains(filterLegendName,legend.getControllerId(),this,2)) {
Player controller=this.getPlayer(legend.getControllerId());
if (controller != null) {
Target targetLegendaryToKeep=new TargetPermanent(filterLegendName);
targetLegendaryToKeep.setTargetName(new StringBuilder(legend.getName()).append(""String_Node_Str"").toString());
controller.chooseTarget(Outcome.Benefit,targetLegendaryToKeep,null,this);
for (Permanent dupLegend : getBattlefield().getActivePermanents(filterLegendName,legend.getControllerId(),this)) {
if (!targetLegendaryToKeep.getTargets().contains(dupLegend.getId())) {
movePermanentToGraveyardWithInfo(dupLegend);
}
}
}
return true;
}
}
}
return somethingHappened;
}","/** 
 * 116.5. Each time a player would get priority, the game first performs all applicable state-based actions as a single event (see rule 704, State-Based Actions), then repeats this process until no state-based actions are performed. Then triggered abilities are put on the stack (see rule 603, Handling Triggered Abilities). These steps repeat in order until no further state-based actions are performed and no abilities trigger. Then the player who would have received priority does so.
 * @return 
 */
protected boolean checkStateBasedActions(){
  boolean somethingHappened=false;
  for (  Player player : state.getPlayers().values()) {
    if (!player.hasLost() && ((player.getLife() <= 0 && player.canLoseByZeroOrLessLife()) || player.isEmptyDraw() || player.getCounters().getCount(CounterType.POISON) >= 10)) {
      player.lost(this);
    }
  }
  Iterator<Card> copiedCards=this.getState().getCopiedCards().iterator();
  while (copiedCards.hasNext()) {
    Card card=copiedCards.next();
    Zone zone=state.getZone(card.getId());
    if (zone != Zone.BATTLEFIELD && zone != Zone.STACK) {
switch (zone) {
case GRAVEYARD:
        for (        Player player : getPlayers().values()) {
          if (player.getGraveyard().contains(card.getId())) {
            player.getGraveyard().remove(card);
            break;
          }
        }
      break;
case HAND:
    for (    Player player : getPlayers().values()) {
      if (player.getHand().contains(card.getId())) {
        player.getHand().remove(card);
        break;
      }
    }
  break;
case LIBRARY:
for (Player player : getPlayers().values()) {
  if (player.getLibrary().getCard(card.getId(),this) != null) {
    player.getLibrary().remove(card.getId(),this);
    break;
  }
}
break;
case EXILED:
getExile().removeCard(card,this);
break;
}
copiedCards.remove();
}
}
List<Permanent> planeswalkers=new ArrayList<>();
List<Permanent> legendary=new ArrayList<>();
for (Permanent perm : getBattlefield().getAllActivePermanents()) {
if (perm.getCardType().contains(CardType.CREATURE)) {
if (perm.getToughness().getValue() <= 0) {
if (movePermanentToGraveyardWithInfo(perm)) {
somethingHappened=true;
continue;
}
}
 else if (perm.getToughness().getValue() <= perm.getDamage() || perm.isDeathtouched()) {
if (perm.destroy(null,this,false)) {
somethingHappened=true;
continue;
}
}
if (perm.getPairedCard() != null) {
Permanent paired=getPermanent(perm.getPairedCard());
if (paired == null || !perm.getControllerId().equals(paired.getControllerId()) || paired.getPairedCard() == null) {
perm.setPairedCard(null);
if (paired != null) {
paired.setPairedCard(null);
}
somethingHappened=true;
}
}
}
 else if (perm.getPairedCard() != null) {
Permanent paired=getPermanent(perm.getPairedCard());
perm.setPairedCard(null);
if (paired != null) {
paired.setPairedCard(null);
}
somethingHappened=true;
}
if (perm.getCardType().contains(CardType.PLANESWALKER)) {
if (perm.getCounters().getCount(CounterType.LOYALTY) == 0) {
if (movePermanentToGraveyardWithInfo(perm)) {
somethingHappened=true;
continue;
}
}
planeswalkers.add(perm);
}
if (filterAura.match(perm,this)) {
if (perm.getAttachedTo() == null) {
Card card=this.getCard(perm.getId());
if (card != null && !card.getCardType().contains(CardType.CREATURE)) {
if (movePermanentToGraveyardWithInfo(perm)) {
somethingHappened=true;
}
}
}
 else {
if (perm.getSpellAbility().getTargets().isEmpty()) {
Permanent enchanted=this.getPermanent(perm.getAttachedTo());
logger.error(""String_Node_Str"" + perm.getName() + ""String_Node_Str""+ (enchanted == null ? ""String_Node_Str"" : enchanted.getName()));
}
 else {
Target target=perm.getSpellAbility().getTargets().get(0);
if (target instanceof TargetPermanent) {
Permanent attachedTo=getPermanent(perm.getAttachedTo());
if (attachedTo == null || !attachedTo.getAttachments().contains(perm.getId())) {
Card card=this.getCard(perm.getId());
if (card != null && card.getCardType().contains(CardType.CREATURE)) {
UUID wasAttachedTo=perm.getAttachedTo();
perm.attachTo(null,this);
fireEvent(new GameEvent(GameEvent.EventType.UNATTACHED,wasAttachedTo,perm.getId(),perm.getControllerId()));
}
 else {
if (movePermanentToGraveyardWithInfo(perm)) {
  somethingHappened=true;
}
}
}
 else {
Filter auraFilter=perm.getSpellAbility().getTargets().get(0).getFilter();
if (auraFilter instanceof FilterControlledCreaturePermanent) {
if (!((FilterControlledCreaturePermanent)auraFilter).match(attachedTo,perm.getId(),perm.getControllerId(),this) || attachedTo.cantBeEnchantedBy(perm,this)) {
  if (movePermanentToGraveyardWithInfo(perm)) {
    somethingHappened=true;
  }
}
}
 else {
if (!auraFilter.match(attachedTo,this) || attachedTo.cantBeEnchantedBy(perm,this)) {
  Card card=this.getCard(perm.getId());
  if (card != null && card.getCardType().contains(CardType.CREATURE)) {
    UUID wasAttachedTo=perm.getAttachedTo();
    perm.attachTo(null,this);
    fireEvent(new GameEvent(GameEvent.EventType.UNATTACHED,wasAttachedTo,perm.getId(),perm.getControllerId()));
  }
 else {
    if (movePermanentToGraveyardWithInfo(perm)) {
      somethingHappened=true;
    }
  }
}
}
}
}
 else if (target instanceof TargetPlayer) {
Player attachedToPlayer=getPlayer(perm.getAttachedTo());
if (attachedToPlayer == null) {
if (movePermanentToGraveyardWithInfo(perm)) {
somethingHappened=true;
}
}
 else {
Filter auraFilter=perm.getSpellAbility().getTargets().get(0).getFilter();
if (!auraFilter.match(attachedToPlayer,this) || attachedToPlayer.hasProtectionFrom(perm,this)) {
if (movePermanentToGraveyardWithInfo(perm)) {
  somethingHappened=true;
}
}
}
}
}
}
}
if (this.getState().isLegendaryRuleActive() && filterLegendary.match(perm,this)) {
legendary.add(perm);
}
if (filterEquipment.match(perm,this)) {
if (perm.getAttachedTo() != null) {
Permanent creature=getPermanent(perm.getAttachedTo());
if (creature == null || !creature.getAttachments().contains(perm.getId())) {
UUID wasAttachedTo=perm.getAttachedTo();
perm.attachTo(null,this);
fireEvent(new GameEvent(GameEvent.EventType.UNATTACHED,wasAttachedTo,perm.getId(),perm.getControllerId()));
}
 else if (!creature.getCardType().contains(CardType.CREATURE) || creature.hasProtectionFrom(perm,this)) {
if (creature.removeAttachment(perm.getId(),this)) {
somethingHappened=true;
}
}
}
}
if (filterFortification.match(perm,this)) {
if (perm.getAttachedTo() != null) {
Permanent land=getPermanent(perm.getAttachedTo());
if (land == null || !land.getAttachments().contains(perm.getId())) {
perm.attachTo(null,this);
}
 else if (!land.getCardType().contains(CardType.LAND) || land.hasProtectionFrom(perm,this)) {
if (land.removeAttachment(perm.getId(),this)) {
somethingHappened=true;
}
}
}
}
if (perm.getAttachments().size() > 0) {
for (UUID attachmentId : perm.getAttachments()) {
Permanent attachment=getPermanent(attachmentId);
if (attachment != null && (attachment.getCardType().contains(CardType.CREATURE) || !(attachment.getSubtype().contains(""String_Node_Str"") || attachment.getSubtype().contains(""String_Node_Str"") || attachment.getSubtype().contains(""String_Node_Str"")))) {
if (perm.removeAttachment(attachment.getId(),this)) {
somethingHappened=true;
break;
}
}
}
}
if (perm.getCounters().containsKey(CounterType.P1P1) && perm.getCounters().containsKey(CounterType.M1M1)) {
int p1p1=perm.getCounters().getCount(CounterType.P1P1);
int m1m1=perm.getCounters().getCount(CounterType.M1M1);
int min=Math.min(p1p1,m1m1);
perm.getCounters().removeCounter(CounterType.P1P1,min);
perm.getCounters().removeCounter(CounterType.M1M1,min);
}
}
if (planeswalkers.size() > 1) {
for (Permanent planeswalker : planeswalkers) {
for (String planeswalkertype : planeswalker.getSubtype()) {
FilterPlaneswalkerPermanent filterPlaneswalker=new FilterPlaneswalkerPermanent();
filterPlaneswalker.add(new SubtypePredicate(planeswalkertype));
filterPlaneswalker.add(new ControllerIdPredicate(planeswalker.getControllerId()));
if (getBattlefield().contains(filterPlaneswalker,planeswalker.getControllerId(),this,2)) {
Player controller=this.getPlayer(planeswalker.getControllerId());
if (controller != null) {
Target targetPlaneswalkerToKeep=new TargetPermanent(filterPlaneswalker);
targetPlaneswalkerToKeep.setTargetName(new StringBuilder(planeswalker.getName()).append(""String_Node_Str"").toString());
controller.chooseTarget(Outcome.Benefit,targetPlaneswalkerToKeep,null,this);
for (Permanent dupPlaneswalker : this.getBattlefield().getActivePermanents(filterPlaneswalker,planeswalker.getControllerId(),this)) {
if (!targetPlaneswalkerToKeep.getTargets().contains(dupPlaneswalker.getId())) {
movePermanentToGraveyardWithInfo(dupPlaneswalker);
}
}
}
return true;
}
}
}
}
if (legendary.size() > 1) {
for (Permanent legend : legendary) {
FilterPermanent filterLegendName=new FilterPermanent();
filterLegendName.add(new SupertypePredicate(""String_Node_Str""));
filterLegendName.add(new NamePredicate(legend.getName()));
filterLegendName.add(new ControllerIdPredicate(legend.getControllerId()));
if (getBattlefield().contains(filterLegendName,legend.getControllerId(),this,2)) {
Player controller=this.getPlayer(legend.getControllerId());
if (controller != null) {
Target targetLegendaryToKeep=new TargetPermanent(filterLegendName);
targetLegendaryToKeep.setTargetName(new StringBuilder(legend.getName()).append(""String_Node_Str"").toString());
controller.chooseTarget(Outcome.Benefit,targetLegendaryToKeep,null,this);
for (Permanent dupLegend : getBattlefield().getActivePermanents(filterLegendName,legend.getControllerId(),this)) {
if (!targetLegendaryToKeep.getTargets().contains(dupLegend.getId())) {
movePermanentToGraveyardWithInfo(dupLegend);
}
}
}
return true;
}
}
}
return somethingHappened;
}",0.9726793417478832
158922,"@Override public boolean resolve(Game game){
  boolean result;
  if (this.getCardType().contains(CardType.INSTANT) || this.getCardType().contains(CardType.SORCERY)) {
    int index=0;
    result=false;
    boolean legalParts=false;
    for (    SpellAbility spellAbility : this.spellAbilities) {
      legalParts|=spellAbilityHasLegalParts(spellAbility,game);
    }
    if (legalParts) {
      for (      SpellAbility spellAbility : this.spellAbilities) {
        if (spellAbilityHasLegalParts(spellAbility,game)) {
          for (          UUID modeId : spellAbility.getModes().getSelectedModes()) {
            spellAbility.getModes().setActiveMode(modeId);
            if (spellAbility.getTargets().stillLegal(spellAbility,game)) {
              if (!spellAbility.getSpellAbilityType().equals(SpellAbilityType.SPLICE)) {
                updateOptionalCosts(index);
              }
              result|=spellAbility.resolve(game);
            }
          }
          index++;
        }
      }
      if (game.getState().getZone(card.getMainCard().getId()) == Zone.STACK) {
        card.moveToZone(Zone.GRAVEYARD,ability.getSourceId(),game,false);
      }
      return result;
    }
    if (!game.isSimulation()) {
      game.informPlayers(getName() + ""String_Node_Str"");
    }
    counter(null,game);
    return false;
  }
 else   if (this.getCardType().contains(CardType.ENCHANTMENT) && this.getSubtype().contains(""String_Node_Str"")) {
    if (ability.getTargets().stillLegal(ability,game)) {
      updateOptionalCosts(0);
      boolean bestow=this.getSpellAbility() instanceof BestowAbility;
      if (bestow) {
        card.getCardType().remove(CardType.CREATURE);
        card.getSubtype().add(""String_Node_Str"");
      }
      if (card.putOntoBattlefield(game,fromZone,ability.getSourceId(),controllerId)) {
        if (bestow) {
          Permanent permanent=game.getPermanent(card.getId());
          if (permanent != null && permanent instanceof PermanentCard) {
            permanent.setSpellAbility(ability);
            ((PermanentCard)permanent).getCard().getCardType().add(CardType.CREATURE);
            ((PermanentCard)permanent).getCard().getSubtype().remove(""String_Node_Str"");
          }
          card.getCardType().add(CardType.CREATURE);
          card.getSubtype().remove(""String_Node_Str"");
        }
        game.getState().handleSimultaneousEvent(game);
        return ability.resolve(game);
      }
      if (bestow) {
        card.getCardType().add(CardType.CREATURE);
      }
      return false;
    }
    if (this.getSpellAbility() instanceof BestowAbility) {
      updateOptionalCosts(0);
      result=card.putOntoBattlefield(game,fromZone,ability.getSourceId(),controllerId);
      return result;
    }
 else {
      if (!game.isSimulation()) {
        game.informPlayers(getName() + ""String_Node_Str"");
      }
      counter(null,game);
      return false;
    }
  }
 else {
    updateOptionalCosts(0);
    result=card.putOntoBattlefield(game,fromZone,ability.getSourceId(),controllerId,false,faceDown);
    return result;
  }
}","@Override public boolean resolve(Game game){
  boolean result;
  if (this.getCardType().contains(CardType.INSTANT) || this.getCardType().contains(CardType.SORCERY)) {
    int index=0;
    result=false;
    boolean legalParts=false;
    for (    SpellAbility spellAbility : this.spellAbilities) {
      legalParts|=spellAbilityHasLegalParts(spellAbility,game);
    }
    if (legalParts) {
      for (      SpellAbility spellAbility : this.spellAbilities) {
        if (spellAbilityHasLegalParts(spellAbility,game)) {
          for (          UUID modeId : spellAbility.getModes().getSelectedModes()) {
            spellAbility.getModes().setActiveMode(modeId);
            if (spellAbility.getTargets().stillLegal(spellAbility,game)) {
              if (!spellAbility.getSpellAbilityType().equals(SpellAbilityType.SPLICE)) {
                updateOptionalCosts(index);
              }
              result|=spellAbility.resolve(game);
            }
          }
          index++;
        }
      }
      if (game.getState().getZone(card.getMainCard().getId()) == Zone.STACK) {
        card.moveToZone(Zone.GRAVEYARD,ability.getSourceId(),game,false);
      }
      return result;
    }
    if (!game.isSimulation()) {
      game.informPlayers(getName() + ""String_Node_Str"");
    }
    counter(null,game);
    return false;
  }
 else   if (this.getCardType().contains(CardType.ENCHANTMENT) && this.getSubtype().contains(""String_Node_Str"")) {
    if (ability.getTargets().stillLegal(ability,game)) {
      updateOptionalCosts(0);
      boolean bestow=this.getSpellAbility() instanceof BestowAbility;
      if (bestow) {
        card.getCardType().remove(CardType.CREATURE);
        card.getSubtype().add(""String_Node_Str"");
      }
      if (card.putOntoBattlefield(game,fromZone,ability.getSourceId(),controllerId)) {
        if (bestow) {
          Permanent permanent=game.getPermanent(card.getId());
          if (permanent != null && permanent instanceof PermanentCard) {
            permanent.setSpellAbility(ability);
            ((PermanentCard)permanent).getCard().getCardType().add(CardType.CREATURE);
            ((PermanentCard)permanent).getCard().getSubtype().remove(""String_Node_Str"");
          }
          card.getCardType().add(CardType.CREATURE);
          card.getSubtype().remove(""String_Node_Str"");
        }
        return ability.resolve(game);
      }
      if (bestow) {
        card.getCardType().add(CardType.CREATURE);
      }
      return false;
    }
    if (this.getSpellAbility() instanceof BestowAbility) {
      updateOptionalCosts(0);
      result=card.putOntoBattlefield(game,fromZone,ability.getSourceId(),controllerId);
      return result;
    }
 else {
      if (!game.isSimulation()) {
        game.informPlayers(getName() + ""String_Node_Str"");
      }
      counter(null,game);
      return false;
    }
  }
 else {
    updateOptionalCosts(0);
    result=card.putOntoBattlefield(game,fromZone,ability.getSourceId(),controllerId,false,faceDown);
    return result;
  }
}",0.9909435205005764
158923,"@Override public String getValue(Game game){
  StringBuilder sb=threadLocalBuilder.get();
  SortedSet<String> cards=new TreeSet<>();
  for (  UUID cardId : this) {
    Card card=game.getCard(cardId);
    cards.add(card.getName());
  }
  for (  String name : cards) {
    sb.append(name).append(""String_Node_Str"");
  }
  return sb.toString();
}","@Override public String getValue(Game game){
  StringBuilder sb=threadLocalBuilder.get();
  List<String> cards=new ArrayList<>();
  for (  UUID cardId : this) {
    Card card=game.getCard(cardId);
    cards.add(card.getName());
  }
  Collections.sort(cards);
  for (  String name : cards) {
    sb.append(name).append(""String_Node_Str"");
  }
  return sb.toString();
}",0.9267605633802816
158924,"boolean canBeTargetedBy(MageObject source,Game game);","boolean canBeTargetedBy(MageObject source,UUID sourceControllerId,Game game);",0.8153846153846154
158925,"@Override public boolean canBeTargetedBy(MageObject source,Game game){
  if (this.hasLost() || this.hasLeft()) {
    return false;
  }
  if (source != null) {
    if (abilities.containsKey(ShroudAbility.getInstance().getId())) {
      return false;
    }
    if (abilities.containsKey(HexproofAbility.getInstance().getId())) {
      UUID controllerId=null;
      if (source instanceof Permanent) {
        controllerId=((Permanent)source).getControllerId();
      }
 else       if (source instanceof StackObject) {
        controllerId=((StackObject)source).getControllerId();
      }
      if (controllerId != null && this.hasOpponent(controllerId,game) && !game.getContinuousEffects().asThough(this.getId(),AsThoughEffectType.HEXPROOF,this.getId(),game)) {
        return false;
      }
    }
    if (hasProtectionFrom(source,game)) {
      return false;
    }
  }
  return true;
}","@Override public boolean canBeTargetedBy(MageObject source,UUID sourceControllerId,Game game){
  if (this.hasLost() || this.hasLeft()) {
    return false;
  }
  if (source != null) {
    if (abilities.containsKey(ShroudAbility.getInstance().getId())) {
      return false;
    }
    if (abilities.containsKey(HexproofAbility.getInstance().getId())) {
      if (sourceControllerId != null && this.hasOpponent(sourceControllerId,game) && !game.getContinuousEffects().asThough(this.getId(),AsThoughEffectType.HEXPROOF,this.getId(),game)) {
        return false;
      }
    }
    if (hasProtectionFrom(source,game)) {
      return false;
    }
  }
  return true;
}",0.8031088082901554
158926,"@Override public boolean canTarget(UUID controllerId,UUID id,Ability source,Game game){
  Permanent permanent=game.getPermanent(id);
  Player player=game.getPlayer(id);
  if (source != null) {
    MageObject targetSource=game.getObject(source.getSourceId());
    if (permanent != null) {
      return permanent.canBeTargetedBy(targetSource,source.getControllerId(),game) && filter.match(permanent,source.getSourceId(),source.getControllerId(),game);
    }
    if (player != null) {
      return player.canBeTargetedBy(targetSource,game) && filter.match(player,game);
    }
  }
  if (permanent != null) {
    return filter.match(permanent,game);
  }
  if (player != null) {
    return filter.match(player,game);
  }
  return false;
}","@Override public boolean canTarget(UUID controllerId,UUID id,Ability source,Game game){
  Permanent permanent=game.getPermanent(id);
  Player player=game.getPlayer(id);
  if (source != null) {
    MageObject targetSource=game.getObject(source.getSourceId());
    if (permanent != null) {
      return permanent.canBeTargetedBy(targetSource,source.getControllerId(),game) && filter.match(permanent,source.getSourceId(),source.getControllerId(),game);
    }
    if (player != null) {
      return player.canBeTargetedBy(targetSource,source.getControllerId(),game) && filter.match(player,game);
    }
  }
  if (permanent != null) {
    return filter.match(permanent,game);
  }
  if (player != null) {
    return filter.match(player,game);
  }
  return false;
}",0.9832102081934184
158927,"@Override public boolean canTarget(UUID id,Ability source,Game game){
  Permanent permanent=game.getPermanent(id);
  Player player=game.getPlayer(id);
  if (source != null) {
    MageObject targetSource=game.getObject(source.getSourceId());
    if (permanent != null) {
      if (!isNotTarget()) {
        if (!permanent.canBeTargetedBy(game.getObject(source.getId()),source.getControllerId(),game) || !permanent.canBeTargetedBy(game.getObject(source.getSourceId()),source.getControllerId(),game)) {
          return false;
        }
      }
      return filter.match(permanent,source.getSourceId(),source.getControllerId(),game);
    }
    if (player != null) {
      if (!isNotTarget()) {
        if (!player.canBeTargetedBy(targetSource,game)) {
          return false;
        }
      }
      return filter.match(player,game);
    }
  }
  if (permanent != null) {
    return filter.match(permanent,game);
  }
  if (player != null) {
    return filter.match(player,game);
  }
  return false;
}","@Override public boolean canTarget(UUID id,Ability source,Game game){
  Permanent permanent=game.getPermanent(id);
  Player player=game.getPlayer(id);
  if (source != null) {
    MageObject targetSource=game.getObject(source.getSourceId());
    if (permanent != null) {
      if (!isNotTarget()) {
        if (!permanent.canBeTargetedBy(game.getObject(source.getId()),source.getControllerId(),game) || !permanent.canBeTargetedBy(game.getObject(source.getSourceId()),source.getControllerId(),game)) {
          return false;
        }
      }
      return filter.match(permanent,source.getSourceId(),source.getControllerId(),game);
    }
    if (player != null) {
      if (!isNotTarget()) {
        if (!player.canBeTargetedBy(targetSource,source.getControllerId(),game)) {
          return false;
        }
      }
      return filter.match(player,game);
    }
  }
  if (permanent != null) {
    return filter.match(permanent,game);
  }
  if (player != null) {
    return filter.match(player,game);
  }
  return false;
}",0.9876053544868616
158928,"@Override public boolean chooseTarget(Outcome outcome,Target target,Ability source,Game game){
  if (!targets.isEmpty()) {
    if ((target instanceof TargetPermanent) || (target instanceof TargetPermanentOrPlayer)) {
      for (      String targetDefinition : targets) {
        String[] targetList=targetDefinition.split(""String_Node_Str"");
        boolean targetFound=false;
        for (        String targetName : targetList) {
          boolean allowCopy=true;
          if (targetName.endsWith(""String_Node_Str"")) {
            allowCopy=false;
            targetName=targetName.substring(0,targetName.length() - 9);
          }
          for (          Permanent permanent : game.getBattlefield().getAllActivePermanents((FilterPermanent)target.getFilter(),game)) {
            if (permanent.getName().equals(targetName) || (permanent.getName() + ""String_Node_Str"" + permanent.getExpansionSetCode()).equals(targetName)) {
              if (((TargetPermanent)target).canTarget(source == null ? this.getId() : source.getControllerId(),permanent.getId(),source,game) && !target.getTargets().contains(permanent.getId())) {
                if (!permanent.isCopy() || allowCopy) {
                  target.add(permanent.getId(),game);
                  targetFound=true;
                  break;
                }
              }
            }
          }
        }
        if (targetFound) {
          targets.remove(targetDefinition);
          return true;
        }
      }
    }
    if (target instanceof TargetPlayer) {
      for (      String targetDefinition : targets) {
        if (targetDefinition.startsWith(""String_Node_Str"")) {
          String playerName=targetDefinition.substring(targetDefinition.indexOf(""String_Node_Str"") + 13);
          for (          Player player : game.getPlayers().values()) {
            if (player.getName().equals(playerName) && ((TargetPlayer)target).canTarget(playerId,player.getId(),source,game)) {
              target.add(player.getId(),game);
              return true;
            }
          }
        }
      }
    }
    if (target instanceof TargetCardInHand) {
      for (      String targetDefinition : targets) {
        String[] targetList=targetDefinition.split(""String_Node_Str"");
        boolean targetFound=false;
        for (        String targetName : targetList) {
          for (          Card card : this.getHand().getCards(((TargetCardInHand)target).getFilter(),game)) {
            if (card.getName().equals(targetName) || (card.getName() + ""String_Node_Str"" + card.getExpansionSetCode()).equals(targetName)) {
              if (((TargetCardInHand)target).canTarget(source.getControllerId(),card.getId(),source,game) && !target.getTargets().contains(card.getId())) {
                target.add(card.getId(),game);
                targetFound=true;
                break;
              }
            }
          }
        }
        if (targetFound) {
          targets.remove(targetDefinition);
          return true;
        }
      }
    }
  }
  return super.chooseTarget(outcome,target,source,game);
}","@Override public boolean chooseTarget(Outcome outcome,Target target,Ability source,Game game){
  if (!targets.isEmpty()) {
    if ((target instanceof TargetPermanent) || (target instanceof TargetPermanentOrPlayer)) {
      for (      String targetDefinition : targets) {
        String[] targetList=targetDefinition.split(""String_Node_Str"");
        boolean targetFound=false;
        for (        String targetName : targetList) {
          boolean allowCopy=true;
          if (targetName.endsWith(""String_Node_Str"")) {
            allowCopy=false;
            targetName=targetName.substring(0,targetName.length() - 9);
          }
          for (          Permanent permanent : game.getBattlefield().getAllActivePermanents((FilterPermanent)target.getFilter(),game)) {
            if (permanent.getName().equals(targetName) || (permanent.getName() + ""String_Node_Str"" + permanent.getExpansionSetCode()).equals(targetName)) {
              if (((TargetPermanent)target).canTarget(source == null ? this.getId() : source.getControllerId(),permanent.getId(),source,game) && !target.getTargets().contains(permanent.getId())) {
                if (!permanent.isCopy() || allowCopy) {
                  target.add(permanent.getId(),game);
                  targetFound=true;
                  break;
                }
              }
            }
          }
        }
        if (targetFound) {
          targets.remove(targetDefinition);
          return true;
        }
      }
    }
    if (target instanceof TargetPlayer) {
      for (      String targetDefinition : targets) {
        if (targetDefinition.startsWith(""String_Node_Str"")) {
          String playerName=targetDefinition.substring(targetDefinition.indexOf(""String_Node_Str"") + 13);
          for (          Player player : game.getPlayers().values()) {
            if (player.getName().equals(playerName) && ((TargetPlayer)target).canTarget(playerId,player.getId(),source,game)) {
              target.add(player.getId(),game);
              return true;
            }
          }
        }
      }
    }
    if (target instanceof TargetCardInHand) {
      for (      String targetDefinition : targets) {
        String[] targetList=targetDefinition.split(""String_Node_Str"");
        boolean targetFound=false;
        for (        String targetName : targetList) {
          for (          Card card : this.getHand().getCards(((TargetCardInHand)target).getFilter(),game)) {
            if (card.getName().equals(targetName) || (card.getName() + ""String_Node_Str"" + card.getExpansionSetCode()).equals(targetName)) {
              if (((TargetCardInHand)target).canTarget(source.getControllerId(),card.getId(),source,game) && !target.getTargets().contains(card.getId())) {
                target.add(card.getId(),game);
                targetFound=true;
                break;
              }
            }
          }
        }
        if (targetFound) {
          targets.remove(targetDefinition);
          return true;
        }
      }
    }
    if (target instanceof TargetSpell) {
      for (      String targetDefinition : targets) {
        String[] targetList=targetDefinition.split(""String_Node_Str"");
        boolean targetFound=false;
        for (        String targetName : targetList) {
          for (          StackObject stackObject : game.getStack()) {
            if (stackObject.getName().equals(targetName)) {
              target.add(stackObject.getId(),game);
              targetFound=true;
              break;
            }
          }
        }
        if (targetFound) {
          targets.remove(targetDefinition);
          return true;
        }
      }
    }
  }
  return super.chooseTarget(outcome,target,source,game);
}",0.9050493154718092
158929,"@Override public boolean apply(MageObject input,Game game){
  Spell spell=game.getStack().getSpell(input.getId());
  if (spell != null) {
    Targets spellTargets=spell.getSpellAbility().getTargets();
    int numberOfTargets=0;
    for (    Target target : spellTargets) {
      numberOfTargets+=target.getTargets().size();
    }
    if (numberOfTargets == targets) {
      return true;
    }
  }
  return false;
}","@Override public boolean apply(MageObject input,Game game){
  Spell spell=game.getStack().getSpell(input.getId());
  if (spell != null) {
    int numberOfTargets=0;
    for (    UUID modeId : spell.getSpellAbility().getModes().getSelectedModes()) {
      Mode mode=spell.getSpellAbility().getModes().get(modeId);
      for (      Target target : mode.getTargets()) {
        numberOfTargets+=target.getTargets().size();
      }
    }
    if (numberOfTargets == targets) {
      return true;
    }
  }
  return false;
}",0.7424892703862661
158930,"protected boolean isColoredPaid(ColoredManaSymbol mana){
switch (mana) {
case B:
    if (this.payment.getBlack() > 0) {
      return true;
    }
case U:
  if (this.payment.getBlue() > 0) {
    return true;
  }
case W:
if (this.payment.getWhite() > 0) {
  return true;
}
case G:
if (this.payment.getGreen() > 0) {
return true;
}
case R:
if (this.payment.getRed() > 0) {
return true;
}
}
return false;
}","protected boolean isColoredPaid(ColoredManaSymbol mana){
switch (mana) {
case B:
    return this.payment.getBlack() > 0;
case U:
  return this.payment.getBlue() > 0;
case W:
return this.payment.getWhite() > 0;
case G:
return this.payment.getGreen() > 0;
case R:
return this.payment.getRed() > 0;
}
return false;
}",0.2436974789915966
158931,"@Override public boolean applies(GameEvent event,Ability source,Game game){
  if (event.getType() == GameEvent.EventType.DRAW_CARD && event.getPlayerId().equals(source.getControllerId())) {
    return true;
  }
  return false;
}","@Override public boolean applies(GameEvent event,Ability source,Game game){
  return event.getPlayerId().equals(source.getControllerId());
}",0.7445652173913043
158932,"@Override public boolean applies(GameEvent event,Ability source,Game game){
  return EventType.DRAW_CARD.equals(event.getType()) && event.getPlayerId().equals(source.getControllerId());
}","@Override public boolean applies(GameEvent event,Ability source,Game game){
  return event.getPlayerId().equals(source.getControllerId());
}",0.8562691131498471
158933,"@Override public boolean applies(GameEvent event,Ability source,Game game){
  if (event.getType() == EventType.DRAW_CARD && event.getPlayerId().equals(source.getControllerId())) {
    Player player=game.getPlayer(event.getPlayerId());
    if (player.getHand().isEmpty()) {
      return true;
    }
  }
  return false;
}","@Override public boolean applies(GameEvent event,Ability source,Game game){
  if (event.getPlayerId().equals(source.getControllerId())) {
    Player player=game.getPlayer(event.getPlayerId());
    if (player.getHand().isEmpty()) {
      return true;
    }
  }
  return false;
}",0.3791946308724832
158934,"@Override public boolean applies(GameEvent event,Ability source,Game game){
  if (event.getType() == EventType.DRAW_CARD && game.getOpponents(source.getControllerId()).contains(event.getPlayerId())) {
    if (game.getActivePlayerId().equals(event.getPlayerId())) {
      CardsDrawnDuringDrawStepWatcher watcher=(CardsDrawnDuringDrawStepWatcher)game.getState().getWatchers().get(""String_Node_Str"");
      if (watcher != null && watcher.getAmountCardsDrawn(event.getPlayerId()) > 0) {
        return true;
      }
    }
 else {
      return true;
    }
  }
  return false;
}","@Override public boolean applies(GameEvent event,Ability source,Game game){
  if (game.getOpponents(source.getControllerId()).contains(event.getPlayerId())) {
    if (game.getActivePlayerId().equals(event.getPlayerId())) {
      CardsDrawnDuringDrawStepWatcher watcher=(CardsDrawnDuringDrawStepWatcher)game.getState().getWatchers().get(""String_Node_Str"");
      if (watcher != null && watcher.getAmountCardsDrawn(event.getPlayerId()) > 0) {
        return true;
      }
    }
 else {
      return true;
    }
  }
  return false;
}",0.2014519056261343
158935,"@Override public boolean applies(GameEvent event,Ability source,Game game){
  if (event.getType() == EventType.DRAW_CARD) {
    return true;
  }
  return false;
}","@Override public boolean applies(GameEvent event,Ability source,Game game){
  return true;
}",0.7244094488188977
158936,"@Override public boolean applies(GameEvent event,Ability source,Game game){
  if (event.getType() == EventType.DRAW_CARD) {
    if (game.getActivePlayerId().equals(event.getPlayerId()) && game.getPhase().getStep().getType().equals(PhaseStep.DRAW)) {
      CardsDrawnDuringDrawStepWatcher watcher=(CardsDrawnDuringDrawStepWatcher)game.getState().getWatchers().get(""String_Node_Str"");
      if (watcher != null && watcher.getAmountCardsDrawn(event.getPlayerId()) > 0) {
        return true;
      }
    }
 else {
      return true;
    }
  }
  return false;
}","@Override public boolean applies(GameEvent event,Ability source,Game game){
  if (game.getActivePlayerId().equals(event.getPlayerId()) && game.getPhase().getStep().getType().equals(PhaseStep.DRAW)) {
    CardsDrawnDuringDrawStepWatcher watcher=(CardsDrawnDuringDrawStepWatcher)game.getState().getWatchers().get(""String_Node_Str"");
    if (watcher != null && watcher.getAmountCardsDrawn(event.getPlayerId()) > 0) {
      return true;
    }
  }
 else {
    return true;
  }
  return false;
}",0.7189292543021033
158937,"@Override public boolean applies(GameEvent event,Ability source,Game game){
  if (event.getType() == EventType.ZONE_CHANGE && ((ZoneChangeEvent)event).getToZone() == Zone.GRAVEYARD) {
    Card card=game.getCard(event.getTargetId());
    if (card != null && card.getOwnerId().equals(source.getControllerId())) {
      Permanent permanent=((ZoneChangeEvent)event).getTarget();
      if (permanent == null || !(permanent instanceof PermanentToken)) {
        return true;
      }
    }
  }
  return false;
}","@Override public boolean applies(GameEvent event,Ability source,Game game){
  if (((ZoneChangeEvent)event).getToZone() == Zone.GRAVEYARD) {
    Card card=game.getCard(event.getTargetId());
    if (card != null && card.getOwnerId().equals(source.getControllerId())) {
      Permanent permanent=((ZoneChangeEvent)event).getTarget();
      if (permanent == null || !(permanent instanceof PermanentToken)) {
        return true;
      }
    }
  }
  return false;
}",0.9543568464730292
158938,"@Override public boolean applies(GameEvent event,Ability source,Game game){
  Permanent archmage=game.getPermanent(source.getSourceId());
  Player you=game.getPlayer(source.getControllerId());
  if (event.getType() == GameEvent.EventType.DRAW_CARD && event.getPlayerId().equals(source.getControllerId()) && archmage != null && you != null && you.chooseUse(Outcome.Benefit,""String_Node_Str"",game)) {
    return true;
  }
  return false;
}","@Override public boolean applies(GameEvent event,Ability source,Game game){
  Permanent archmage=game.getPermanent(source.getSourceId());
  Player you=game.getPlayer(source.getControllerId());
  if (event.getPlayerId().equals(source.getControllerId()) && archmage != null && you != null && you.chooseUse(Outcome.Benefit,""String_Node_Str"",game)) {
    return true;
  }
  return false;
}",0.9367396593673966
158939,"@Override public boolean applies(GameEvent event,Ability source,Game game){
  return event.getType() == EventType.DRAW_CARD && source.getControllerId().equals(event.getPlayerId()) && used == false;
}","@Override public boolean applies(GameEvent event,Ability source,Game game){
  return source.getControllerId().equals(event.getPlayerId());
}",0.8259587020648967
158940,"@Override public boolean replaceEvent(GameEvent event,Ability source,Game game){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller != null) {
    Player player=game.getPlayer(targetPointer.getFirst(game,source));
    if (player != null) {
      player.damage(2,source.getSourceId(),game,false,true);
      used=true;
      return true;
    }
    Permanent permanent=game.getPermanent(targetPointer.getFirst(game,source));
    if (permanent != null) {
      permanent.damage(2,source.getSourceId(),game,false,true);
      used=true;
      return true;
    }
  }
  return false;
}","@Override public boolean replaceEvent(GameEvent event,Ability source,Game game){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller != null) {
    Player player=game.getPlayer(targetPointer.getFirst(game,source));
    if (player != null) {
      player.damage(2,source.getSourceId(),game,false,true);
      discard();
      return true;
    }
    Permanent permanent=game.getPermanent(targetPointer.getFirst(game,source));
    if (permanent != null) {
      permanent.damage(2,source.getSourceId(),game,false,true);
      discard();
      return true;
    }
  }
  return false;
}",0.970345963756178
158941,"@Override public boolean applies(GameEvent event,Ability source,Game game){
  if (event.getType() == EventType.DRAW_CARD && source.getControllerId().equals(event.getPlayerId()) && used == false) {
    return true;
  }
  return false;
}","@Override public boolean applies(GameEvent event,Ability source,Game game){
  return source.getControllerId().equals(event.getPlayerId());
}",0.7306666666666667
158942,"@Override public boolean replaceEvent(GameEvent event,Ability source,Game game){
  game.informPlayers(""String_Node_Str"");
  for (  UUID playerId : game.getPlayerList()) {
    Player player=game.getPlayer(playerId);
    if (player != null) {
      TargetControlledPermanent target=new TargetControlledPermanent();
      List<Permanent> liste=game.getBattlefield().getActivePermanents(new FilterControlledPermanent(),playerId,game);
      if (!liste.isEmpty()) {
        while (!player.choose(Outcome.ReturnToHand,target,source.getSourceId(),game)) {
          if (!player.isInGame()) {
            return false;
          }
        }
        Permanent permanent=game.getPermanent(target.getFirstTarget());
        if (permanent != null) {
          permanent.moveToZone(Zone.HAND,source.getSourceId(),game,false);
        }
      }
    }
  }
  used=true;
  return apply(game,source);
}","@Override public boolean replaceEvent(GameEvent event,Ability source,Game game){
  game.informPlayers(""String_Node_Str"");
  for (  UUID playerId : game.getPlayerList()) {
    Player player=game.getPlayer(playerId);
    if (player != null) {
      TargetControlledPermanent target=new TargetControlledPermanent();
      List<Permanent> liste=game.getBattlefield().getActivePermanents(new FilterControlledPermanent(),playerId,game);
      if (!liste.isEmpty()) {
        while (!player.choose(Outcome.ReturnToHand,target,source.getSourceId(),game)) {
          if (!player.isInGame()) {
            return false;
          }
        }
        Permanent permanent=game.getPermanent(target.getFirstTarget());
        if (permanent != null) {
          permanent.moveToZone(Zone.HAND,source.getSourceId(),game,false);
        }
      }
    }
  }
  discard();
  return true;
}",0.9771949828962372
158943,"@Override public boolean applies(GameEvent event,Ability source,Game game){
  if (event.getType() == EventType.DRAW_CARD && event.getPlayerId().equals(source.getControllerId())) {
    Player player=game.getPlayer(source.getControllerId());
    if (player != null) {
      return player.chooseUse(Outcome.Benefit,""String_Node_Str"",game);
    }
  }
  return false;
}","@Override public boolean applies(GameEvent event,Ability source,Game game){
  if (event.getPlayerId().equals(source.getControllerId())) {
    Player player=game.getPlayer(source.getControllerId());
    if (player != null) {
      return player.chooseUse(Outcome.Benefit,""String_Node_Str"",game);
    }
  }
  return false;
}",0.9387755102040816
158944,"@Override public boolean applies(GameEvent event,Ability source,Game game){
  Permanent archmage=game.getPermanent(source.getSourceId());
  Player you=game.getPlayer(source.getControllerId());
  if (event.getType() == EventType.DRAW_CARD && event.getPlayerId().equals(source.getControllerId()) && archmage != null && archmage.getCounters().getCount(CounterType.QUEST) >= 6 && you != null && you.chooseUse(Outcome.Benefit,""String_Node_Str"",game)) {
    return true;
  }
  return false;
}","@Override public boolean applies(GameEvent event,Ability source,Game game){
  Permanent archmage=game.getPermanent(source.getSourceId());
  Player you=game.getPlayer(source.getControllerId());
  if (event.getPlayerId().equals(source.getControllerId()) && archmage != null && archmage.getCounters().getCount(CounterType.QUEST) >= 6 && you != null && you.chooseUse(Outcome.Benefit,""String_Node_Str"",game)) {
    return true;
  }
  return false;
}",0.9548387096774194
158945,"@Override public boolean checkTrigger(GameEvent event,Game game){
  Permanent archmage=game.getPermanent(super.getSourceId());
  CardsDrawnControllerWatcher watcher=(CardsDrawnControllerWatcher)game.getState().getWatchers().get(""String_Node_Str"");
  if (event.getType() == GameEvent.EventType.END_TURN_STEP_PRE && archmage != null && watcher != null && watcher.conditionMet()) {
    return true;
  }
  return false;
}","@Override public boolean checkTrigger(GameEvent event,Game game){
  Permanent archmage=game.getPermanent(super.getSourceId());
  CardsDrawnControllerWatcher watcher=(CardsDrawnControllerWatcher)game.getState().getWatchers().get(""String_Node_Str"");
  if (archmage != null && watcher != null && watcher.conditionMet()) {
    return true;
  }
  return false;
}",0.8656330749354005
158946,"@Override public boolean apply(Game game,Ability source){
  MageObject sourceObject=game.getObject(source.getSourceId());
  Player controller=game.getPlayer(source.getControllerId());
  if (sourceObject != null && controller != null) {
    Player owner=null;
    Cards cards=new CardsImpl();
    Permanent permanent=null;
    if (sourceObject instanceof Permanent) {
      permanent=(Permanent)sourceObject;
      owner=game.getPlayer(permanent.getOwnerId());
      if (sourceObject instanceof PermanentCard) {
        cards.add(permanent);
      }
    }
 else     if (sourceObject instanceof Card) {
      owner=game.getPlayer(((Card)sourceObject).getOwnerId());
      cards.add((Card)sourceObject);
    }
    if (owner != null) {
      Zone fromZone=game.getState().getZone(sourceObject.getId());
      if (!cards.isEmpty()) {
        controller.revealCards(sourceObject.getLogName(),cards,game);
      }
      if (permanent != null) {
        controller.moveCardToLibraryWithInfo(permanent,source.getSourceId(),game,fromZone,true,true);
      }
 else {
        controller.moveCardToLibraryWithInfo((Card)sourceObject,source.getSourceId(),game,fromZone,true,true);
      }
      if (!cards.isEmpty()) {
        controller.shuffleLibrary(game);
      }
    }
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  MageObject sourceObject=game.getObject(source.getSourceId());
  Player controller=game.getPlayer(source.getControllerId());
  if (sourceObject != null && controller != null) {
    Player owner=null;
    Cards cards=new CardsImpl();
    Permanent permanent=null;
    if (sourceObject instanceof Spell) {
      sourceObject=((Spell)sourceObject).getCard();
    }
    if (sourceObject instanceof Permanent) {
      permanent=(Permanent)sourceObject;
      owner=game.getPlayer(permanent.getOwnerId());
      if (sourceObject instanceof PermanentCard) {
        cards.add(permanent);
      }
    }
 else     if (sourceObject instanceof Card) {
      owner=game.getPlayer(((Card)sourceObject).getOwnerId());
      cards.add((Card)sourceObject);
    }
    if (owner != null) {
      Zone fromZone=game.getState().getZone(sourceObject.getId());
      if (!cards.isEmpty()) {
        controller.revealCards(sourceObject.getLogName(),cards,game);
      }
      if (permanent != null) {
        controller.moveCardToLibraryWithInfo(permanent,source.getSourceId(),game,fromZone,true,true);
      }
 else {
        controller.moveCardToLibraryWithInfo((Card)sourceObject,source.getSourceId(),game,fromZone,true,true);
      }
      if (!cards.isEmpty()) {
        controller.shuffleLibrary(game);
      }
    }
    return true;
  }
  return false;
}",0.963265306122449
158947,"/** 
 * Checks if Copy Enchantment works for palyer auras
 */
@Test public void testCurseOfExhaustion3(){
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"",4);
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"",2);
  addCard(Zone.BATTLEFIELD,playerB,""String_Node_Str"",3);
  addCard(Zone.HAND,playerA,""String_Node_Str"");
  addCard(Zone.HAND,playerA,""String_Node_Str"",2);
  addCard(Zone.HAND,playerB,""String_Node_Str"",1);
  castSpell(1,PhaseStep.PRECOMBAT_MAIN,playerA,""String_Node_Str"",playerB);
  castSpell(4,PhaseStep.POSTCOMBAT_MAIN,playerA,""String_Node_Str"",playerB);
  castSpell(4,PhaseStep.PRECOMBAT_MAIN,playerB,""String_Node_Str"");
  setChoice(playerB,""String_Node_Str"");
  setChoice(playerB,""String_Node_Str"");
  setChoice(playerB,""String_Node_Str"");
  castSpell(4,PhaseStep.POSTCOMBAT_MAIN,playerA,""String_Node_Str"",playerB);
  setStopAt(4,PhaseStep.END_TURN);
  execute();
  assertHandCount(playerB,""String_Node_Str"",0);
  assertGraveyardCount(playerB,""String_Node_Str"",0);
  assertPermanentCount(playerA,""String_Node_Str"",1);
  assertPermanentCount(playerB,""String_Node_Str"",1);
  assertLife(playerA,20);
  assertLife(playerB,17);
}","/** 
 * Checks if Copy Enchantment works for player auras
 */
@Test public void testCurseOfExhaustion3(){
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"",4);
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"",2);
  addCard(Zone.BATTLEFIELD,playerB,""String_Node_Str"",3);
  addCard(Zone.HAND,playerA,""String_Node_Str"");
  addCard(Zone.HAND,playerA,""String_Node_Str"",2);
  addCard(Zone.HAND,playerB,""String_Node_Str"",1);
  castSpell(1,PhaseStep.PRECOMBAT_MAIN,playerA,""String_Node_Str"",playerB);
  castSpell(4,PhaseStep.POSTCOMBAT_MAIN,playerA,""String_Node_Str"",playerB);
  castSpell(4,PhaseStep.PRECOMBAT_MAIN,playerB,""String_Node_Str"");
  setChoice(playerB,""String_Node_Str"");
  setChoice(playerB,""String_Node_Str"");
  setChoice(playerB,""String_Node_Str"");
  castSpell(4,PhaseStep.POSTCOMBAT_MAIN,playerA,""String_Node_Str"",playerB);
  setStopAt(4,PhaseStep.END_TURN);
  execute();
  assertHandCount(playerB,""String_Node_Str"",0);
  assertGraveyardCount(playerB,""String_Node_Str"",0);
  assertPermanentCount(playerA,""String_Node_Str"",1);
  assertPermanentCount(playerB,""String_Node_Str"",1);
  assertLife(playerA,20);
  assertLife(playerB,17);
}",0.998256320836966
158948,"public void removeEffects(UUID effectIdToRemove,Set<Ability> abilitiesToRemove){
  HashSet<Ability> abilities=effectAbilityMap.get(effectIdToRemove);
  if (abilitiesToRemove != null) {
    abilities.removeAll(abilitiesToRemove);
  }
  if (abilities.isEmpty()) {
    for (Iterator<T> iterator=this.iterator(); iterator.hasNext(); ) {
      ContinuousEffect effect=iterator.next();
      if (effect.getId().equals(effectIdToRemove)) {
        iterator.remove();
        break;
      }
    }
    effectAbilityMap.remove(effectIdToRemove);
  }
}","public void removeEffects(UUID effectIdToRemove,Set<Ability> abilitiesToRemove){
  HashSet<Ability> abilities=effectAbilityMap.get(effectIdToRemove);
  if (abilitiesToRemove != null && abilities != null) {
    abilities.removeAll(abilitiesToRemove);
  }
  if (abilities == null || abilities.isEmpty()) {
    for (Iterator<T> iterator=this.iterator(); iterator.hasNext(); ) {
      ContinuousEffect effect=iterator.next();
      if (effect.getId().equals(effectIdToRemove)) {
        iterator.remove();
        break;
      }
    }
    effectAbilityMap.remove(effectIdToRemove);
  }
}",0.9626334519572952
158949,"@Override public void addOptionalAdditionalCosts(Ability ability,Game game){
  if (ability instanceof SpellAbility) {
    Player player=game.getPlayer(controllerId);
    if (player != null) {
      this.resetKicker();
      for (      OptionalAdditionalCost kickerCost : kickerCosts) {
        boolean again=true;
        while (player.isInGame() && again) {
          String times=""String_Node_Str"";
          if (kickerCost.isRepeatable()) {
            int activatedCount=kickerCost.getActivateCount();
            times=Integer.toString(activatedCount + 1) + (activatedCount == 0 ? ""String_Node_Str"" : ""String_Node_Str"");
          }
          if (kickerCost.canPay(ability,sourceId,controllerId,game) && player.chooseUse(Outcome.Benefit,new StringBuilder(""String_Node_Str"").append(times).append(kickerCost.getText(false)).append(""String_Node_Str"").toString(),game)) {
            this.activateKicker(kickerCost,game);
            for (Iterator it=((Costs)kickerCost).iterator(); it.hasNext(); ) {
              Cost cost=(Cost)it.next();
              if (cost instanceof ManaCostsImpl) {
                List<VariableManaCost> varCosts=((ManaCostsImpl)cost).getVariableCosts();
                if (!varCosts.isEmpty()) {
                  xManaValue=game.getPlayer(this.controllerId).announceXMana(varCosts.get(0).getMinX(),Integer.MAX_VALUE,""String_Node_Str"" + varCosts.get(0).getText(),game,this);
                  if (!game.isSimulation())                   game.informPlayers(new StringBuilder(game.getPlayer(this.controllerId).getName()).append(""String_Node_Str"").append(xManaValue).append(""String_Node_Str"").append(""String_Node_Str"").toString());
                  ability.getManaCostsToPay().add(new GenericManaCost(xManaValue));
                }
 else {
                  ability.getManaCostsToPay().add((ManaCostsImpl)cost.copy());
                }
              }
 else {
                ability.getCosts().add(cost.copy());
              }
            }
            again=kickerCost.isRepeatable();
          }
 else {
            again=false;
          }
        }
      }
    }
  }
}","@Override public void addOptionalAdditionalCosts(Ability ability,Game game){
  if (ability instanceof SpellAbility) {
    Player player=game.getPlayer(controllerId);
    if (player != null) {
      this.resetKicker();
      for (      OptionalAdditionalCost kickerCost : kickerCosts) {
        boolean again=true;
        while (player.isInGame() && again) {
          String times=""String_Node_Str"";
          if (kickerCost.isRepeatable()) {
            int activatedCount=kickerCost.getActivateCount();
            times=Integer.toString(activatedCount + 1) + (activatedCount == 0 ? ""String_Node_Str"" : ""String_Node_Str"");
          }
          if (kickerCost.canPay(ability,sourceId,controllerId,game) && player.chooseUse(Outcome.Benefit,new StringBuilder(""String_Node_Str"").append(times).append(kickerCost.getText(false)).append(""String_Node_Str"").toString(),game)) {
            this.activateKicker(kickerCost,game);
            for (Iterator it=((Costs)kickerCost).iterator(); it.hasNext(); ) {
              Cost cost=(Cost)it.next();
              if (cost instanceof ManaCostsImpl) {
                List<VariableManaCost> varCosts=((ManaCostsImpl)cost).getVariableCosts();
                if (!varCosts.isEmpty()) {
                  xManaValue=game.getPlayer(this.controllerId).announceXMana(varCosts.get(0).getMinX(),Integer.MAX_VALUE,""String_Node_Str"" + varCosts.get(0).getText(),game,this);
                  if (!game.isSimulation()) {
                    game.informPlayers(new StringBuilder(game.getPlayer(this.controllerId).getName()).append(""String_Node_Str"").append(xManaValue).append(""String_Node_Str"").append(""String_Node_Str"").toString());
                  }
                  ability.getManaCostsToPay().add(new GenericManaCost(xManaValue));
                }
 else {
                  ability.getManaCostsToPay().add((ManaCostsImpl)cost.copy());
                }
              }
 else {
                ability.getCosts().add(cost.copy());
              }
            }
            again=kickerCost.isRepeatable();
          }
 else {
            again=false;
          }
        }
      }
    }
  }
}",0.9943316013226264
158950,"/** 
 * Tests that creature with Heavy Arbalest will use it and untap later after equip is equipped to another creature
 */
@Test public void testUntapsLater(){
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"",8);
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"");
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"");
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"");
  activateAbility(1,PhaseStep.PRECOMBAT_MAIN,playerA,""String_Node_Str"",""String_Node_Str"");
  activateAbility(1,PhaseStep.PRECOMBAT_MAIN,playerA,""String_Node_Str"",playerB);
  activateAbility(1,PhaseStep.PRECOMBAT_MAIN,playerA,""String_Node_Str"",""String_Node_Str"");
  setStopAt(5,PhaseStep.BEGIN_COMBAT);
  execute();
  assertLife(playerA,20);
  assertLife(playerB,18);
  Permanent eliteVanguard=getPermanent(""String_Node_Str"",playerA.getId());
  Assert.assertTrue(eliteVanguard.getAttachments().size() == 0);
  Assert.assertFalse(eliteVanguard.isTapped());
}","/** 
 * Tests that creature with Heavy Arbalest will use it and untap later after equip is equipped to another creature
 */
@Test public void testUntapsLater(){
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"",8);
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"");
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"");
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"");
  activateAbility(1,PhaseStep.PRECOMBAT_MAIN,playerA,""String_Node_Str"",""String_Node_Str"");
  activateAbility(1,PhaseStep.PRECOMBAT_MAIN,playerA,""String_Node_Str"",playerB);
  activateAbility(1,PhaseStep.PRECOMBAT_MAIN,playerA,""String_Node_Str"",""String_Node_Str"");
  setStopAt(5,PhaseStep.BEGIN_COMBAT);
  execute();
  assertLife(playerA,20);
  assertLife(playerB,18);
  Permanent eliteVanguard=getPermanent(""String_Node_Str"",playerA.getId());
  Assert.assertTrue(eliteVanguard.getAttachments().isEmpty());
  Assert.assertFalse(eliteVanguard.isTapped());
}",0.9893390191897654
158951,"@Override public boolean apply(Game game,Ability source){
  Permanent permanent=game.getPermanent(getTargetPointer().getFirst(game,source));
  if (permanent != null) {
    return permanent.addAttachment(source.getSourceId(),game);
  }
 else {
    Player player=game.getPlayer(getTargetPointer().getFirst(game,source));
    if (player != null) {
      return player.addAttachment(source.getSourceId(),game);
    }
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Permanent sourcePermanent=(Permanent)source.getSourceObjectIfItStillExists(game);
  if (sourcePermanent != null) {
    Permanent permanent=game.getPermanent(getTargetPointer().getFirst(game,source));
    if (permanent != null) {
      return permanent.addAttachment(source.getSourceId(),game);
    }
 else {
      Player player=game.getPlayer(getTargetPointer().getFirst(game,source));
      if (player != null) {
        return player.addAttachment(source.getSourceId(),game);
      }
    }
  }
  return false;
}",0.4389275074478649
158952,"@Override public boolean apply(Game game,Ability source){
  Permanent sourcePermanent=(Permanent)source.getSourceObjectIfItStillExists(game);
  if (sourcePermanent != null) {
    Permanent permanent=game.getPermanent(getTargetPointer().getFirst(game,source));
    if (permanent != null) {
      return permanent.addAttachment(source.getSourceId(),game);
    }
 else {
      Player player=game.getPlayer(getTargetPointer().getFirst(game,source));
      if (player != null) {
        return player.addAttachment(source.getSourceId(),game);
      }
    }
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Permanent sourcePermanent=game.getPermanent(source.getSourceId());
  if (sourcePermanent != null) {
    int zcc=game.getState().getZoneChangeCounter(sourcePermanent.getId());
    if (zcc == source.getSourceObjectZoneChangeCounter() || zcc == source.getSourceObjectZoneChangeCounter() + 1) {
      Permanent permanent=game.getPermanent(getTargetPointer().getFirst(game,source));
      if (permanent != null) {
        return permanent.addAttachment(source.getSourceId(),game);
      }
 else {
        Player player=game.getPlayer(getTargetPointer().getFirst(game,source));
        if (player != null) {
          return player.addAttachment(source.getSourceId(),game);
        }
      }
    }
  }
  return false;
}",0.1842496285289747
158953,"/** 
 * Tests first trigger happens both on enter battlefield and transform events
 */
@Test public void testCard2(){
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"",3);
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"");
  addCard(Zone.HAND,playerA,""String_Node_Str"");
  addCard(Zone.BATTLEFIELD,playerB,""String_Node_Str"");
  addCard(Zone.BATTLEFIELD,playerB,""String_Node_Str"",2);
  addCard(Zone.HAND,playerB,""String_Node_Str"",2);
  castSpell(1,PhaseStep.PRECOMBAT_MAIN,playerA,""String_Node_Str"");
  castSpell(3,PhaseStep.PRECOMBAT_MAIN,playerB,""String_Node_Str"",playerA);
  castSpell(3,PhaseStep.PRECOMBAT_MAIN,playerB,""String_Node_Str"",playerA);
  setStopAt(4,PhaseStep.DRAW);
  execute();
  assertLife(playerA,18);
  assertLife(playerB,18);
  assertPermanentCount(playerA,""String_Node_Str"",2);
  assertPermanentCount(playerA,""String_Node_Str"",0);
  assertPermanentCount(playerA,""String_Node_Str"",1);
  assertPermanentCount(playerB,""String_Node_Str"",0);
}","/** 
 * Tests first trigger happens both on enter battlefield and transform events
 */
@Test public void testCard2(){
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"",3);
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"");
  addCard(Zone.HAND,playerA,""String_Node_Str"");
  addCard(Zone.BATTLEFIELD,playerB,""String_Node_Str"",2);
  addCard(Zone.HAND,playerB,""String_Node_Str"",2);
  castSpell(1,PhaseStep.PRECOMBAT_MAIN,playerA,""String_Node_Str"");
  castSpell(3,PhaseStep.PRECOMBAT_MAIN,playerB,""String_Node_Str"",playerA);
  castSpell(3,PhaseStep.PRECOMBAT_MAIN,playerB,""String_Node_Str"",playerA);
  setStopAt(4,PhaseStep.DRAW);
  execute();
  assertLife(playerA,18);
  assertLife(playerB,18);
  assertPermanentCount(playerA,""String_Node_Str"",2);
  assertPermanentCount(playerA,""String_Node_Str"",0);
  assertPermanentCount(playerA,""String_Node_Str"",1);
}",0.9407894736842104
158954,"/** 
 * Ravager of the Fells Creature  Werewolf 4/4 Trample Whenever this creature transforms into Ravager of the Fells, it deals 2  damage to target opponent and 2 damage to up to one target creature that  player controls. At the beginning of each upkeep, if a player cast two or more spells last  turn, transform Ravager of the Fells.
 */
@Test public void testCard(){
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"",3);
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"");
  addCard(Zone.HAND,playerA,""String_Node_Str"");
  addCard(Zone.BATTLEFIELD,playerB,""String_Node_Str"");
  castSpell(1,PhaseStep.PRECOMBAT_MAIN,playerA,""String_Node_Str"");
  setStopAt(3,PhaseStep.DRAW);
  execute();
  assertLife(playerA,22);
  assertLife(playerB,18);
  assertPermanentCount(playerA,""String_Node_Str"",1);
  assertPermanentCount(playerA,""String_Node_Str"",0);
  assertPermanentCount(playerA,""String_Node_Str"",1);
  assertPermanentCount(playerB,""String_Node_Str"",0);
}","/** 
 * Ravager of the Fells Creature  Werewolf 4/4 Trample Whenever this creature transforms into Ravager of the Fells, it deals 2  damage to target opponent and 2 damage to up to one target creature that  player controls. At the beginning of each upkeep, if a player cast two or more spells last  turn, transform Ravager of the Fells.
 */
@Test public void testCard(){
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"",3);
  addCard(Zone.BATTLEFIELD,playerA,""String_Node_Str"");
  addCard(Zone.HAND,playerA,""String_Node_Str"");
  castSpell(1,PhaseStep.PRECOMBAT_MAIN,playerA,""String_Node_Str"");
  setStopAt(3,PhaseStep.DRAW);
  execute();
  assertLife(playerA,22);
  assertLife(playerB,18);
  assertPermanentCount(playerA,""String_Node_Str"",1);
  assertPermanentCount(playerA,""String_Node_Str"",0);
  assertPermanentCount(playerA,""String_Node_Str"",1);
}",0.9405940594059404
158955,"@Override public boolean isInUseableZone(Game game,MageObject source,GameEvent event){
  if (event != null && event.getTargetId() != null && event.getTargetId().equals(getSourceId())) {
switch (event.getType()) {
case ZONE_CHANGE:
      if (source == null && ((ZoneChangeEvent)event).getTarget() != null) {
        source=((ZoneChangeEvent)event).getTarget();
      }
case DESTROYED_PERMANENT:
case PHASED_OUT:
case PHASED_IN:
    if (game.getLastKnownInformation(getSourceId(),zone) != null) {
      return true;
    }
}
}
return super.isInUseableZone(game,source,event);
}","@Override public boolean isInUseableZone(Game game,MageObject source,GameEvent event){
  if (event != null && event.getTargetId() != null && event.getTargetId().equals(getSourceId())) {
switch (event.getType()) {
case ZONE_CHANGE:
      if (source == null && ((ZoneChangeEvent)event).getTarget() != null) {
        source=((ZoneChangeEvent)event).getTarget();
      }
case DESTROYED_PERMANENT:
case PHASED_OUT:
case PHASED_IN:
    if (this.zone == Zone.ALL || game.getLastKnownInformation(getSourceId(),zone) != null) {
      return true;
    }
}
}
return super.isInUseableZone(game,source,event);
}",0.9786871270247228
158956,"private String normalizeName(String name){
  return name.replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str"");
}","private String normalizeName(String name){
  return name.replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str"").replace(""String_Node_Str"",""String_Node_Str"");
}",0.9734199645599528
158957,"@Override public boolean applies(GameEvent event,Ability source,Game game){
  boolean applies=false;
  if (EventType.SEARCH_LIBRARY.equals(event.getType())) {
    applies=true;
    Permanent permanent=game.getPermanent(source.getSourceId());
    String key=permanent.getId() + keyString;
    Map.Entry<Long,Set<UUID>> turnIgnoringPlayersPair=(Map.Entry<Long,Set<UUID>>)game.getState().getValue(key);
    if (turnIgnoringPlayersPair != null) {
      long zoneChangeCount=permanent.getZoneChangeCounter(game);
      long turnNum=game.getTurnNum();
      Long activationState=zoneChangeCount << 32 | turnNum & 0xFFFFFFFFL;
      if (activationState.equals(turnIgnoringPlayersPair.getKey())) {
        applies=!turnIgnoringPlayersPair.getValue().contains(event.getPlayerId());
      }
    }
  }
  return applies;
}","@Override public boolean applies(GameEvent event,Ability source,Game game){
  Permanent permanent=game.getPermanent(source.getSourceId());
  if (permanent != null) {
    boolean applies=true;
    String key=permanent.getId() + keyString;
    Map.Entry<Long,Set<UUID>> turnIgnoringPlayersPair=(Map.Entry<Long,Set<UUID>>)game.getState().getValue(key);
    if (turnIgnoringPlayersPair != null) {
      long zoneChangeCount=permanent.getZoneChangeCounter(game);
      long turnNum=game.getTurnNum();
      Long activationState=zoneChangeCount << 32 | turnNum & 0xFFFFFFFFL;
      if (activationState.equals(turnIgnoringPlayersPair.getKey())) {
        applies=!turnIgnoringPlayersPair.getValue().contains(event.getPlayerId());
      }
    }
    return applies;
  }
  return false;
}",0.827455919395466
158958,"@Override public boolean apply(Game game,Ability source){
  MageObject mageObject=game.getObject(source.getSourceId());
  if (mageObject == null) {
    if (duration.equals(Duration.Custom)) {
      discard();
    }
    return false;
  }
  if (amount != null) {
    int value=amount.calculate(game,source,this);
    mageObject.getPower().setValue(value);
    mageObject.getToughness().setValue(value);
    return true;
  }
 else {
    if (power != Integer.MIN_VALUE) {
      mageObject.getPower().setValue(power);
    }
    if (toughness != Integer.MIN_VALUE) {
      mageObject.getToughness().setValue(toughness);
    }
  }
  return true;
}","@Override public boolean apply(Game game,Ability source){
  MageObject mageObject;
  if (source.getZone() == Zone.BATTLEFIELD) {
    mageObject=source.getSourceObjectIfItStillExists(game);
  }
 else {
    mageObject=game.getObject(source.getSourceId());
  }
  if (mageObject == null) {
    if (duration.equals(Duration.Custom)) {
      discard();
    }
    return false;
  }
  if (amount != null) {
    int value=amount.calculate(game,source,this);
    mageObject.getPower().setValue(value);
    mageObject.getToughness().setValue(value);
    return true;
  }
 else {
    if (power != Integer.MIN_VALUE) {
      mageObject.getPower().setValue(power);
    }
    if (toughness != Integer.MIN_VALUE) {
      mageObject.getToughness().setValue(toughness);
    }
  }
  return true;
}",0.9026798307475318
158959,"public synchronized boolean joinTournament(UUID userId,String name,String playerType,int skill,DeckCardLists deckList,String password) throws GameException {
  if (table.getState() != TableState.WAITING) {
    return false;
  }
  Seat seat=table.getNextAvailableSeat(playerType);
  if (seat == null) {
    throw new GameException(""String_Node_Str"");
  }
  User user=UserManager.getInstance().getUser(userId);
  if (user == null) {
    logger.fatal(new StringBuilder(""String_Node_Str"").append(name).append(""String_Node_Str"").append(userId).toString());
    return false;
  }
  if (!table.getTournament().getOptions().getPassword().isEmpty() && playerType.equals(""String_Node_Str"")) {
    if (!table.getTournament().getOptions().getPassword().equals(password)) {
      user.showUserMessage(""String_Node_Str"",""String_Node_Str"");
      return false;
    }
  }
  if (userPlayerMap.containsKey(userId) && playerType.equals(""String_Node_Str"")) {
    user.showUserMessage(""String_Node_Str"",new StringBuilder(""String_Node_Str"").toString());
    return false;
  }
  Deck deck=null;
  if (!table.getTournament().getTournamentType().isLimited()) {
    if (deckList != null) {
      deck=Deck.load(deckList,false,false);
    }
 else {
      user.showUserMessage(""String_Node_Str"",""String_Node_Str"");
      return false;
    }
    if (!Main.isTestMode() && !table.getValidator().validate(deck)) {
      StringBuilder sb=new StringBuilder(""String_Node_Str"").append(name).append(""String_Node_Str"").append(table.getValidator().getName()).append(""String_Node_Str"");
      for (      Map.Entry<String,String> entry : table.getValidator().getInvalid().entrySet()) {
        sb.append(entry.getKey()).append(""String_Node_Str"").append(entry.getValue()).append(""String_Node_Str"");
      }
      sb.append(""String_Node_Str"");
      user.showUserMessage(""String_Node_Str"",sb.toString());
      if (isOwner(userId)) {
        logger.debug(""String_Node_Str"" + table.getId());
        TableManager.getInstance().removeTable(table.getId());
      }
      return false;
    }
  }
  Player player=createPlayer(name,seat.getPlayerType(),skill);
  if (player != null) {
    if (!player.canJoinTable(table)) {
      user.showUserMessage(""String_Node_Str"",new StringBuilder(""String_Node_Str"").append(seat.getPlayerType()).append(""String_Node_Str"").toString());
      return false;
    }
    tournament.addPlayer(player,seat.getPlayerType());
    TournamentPlayer tournamentPlayer=tournament.getPlayer(player.getId());
    if (deck != null && tournamentPlayer != null) {
      tournamentPlayer.submitDeck(deck);
    }
    table.joinTable(player,seat);
    logger.debug(""String_Node_Str"" + player.getName() + ""String_Node_Str""+ player.getId()+ ""String_Node_Str""+ table.getId());
    if (seat.getPlayer().isHuman()) {
      user.addTable(player.getId(),table);
      user.ccJoinedTable(table.getRoomId(),table.getId(),true);
      userPlayerMap.put(userId,player.getId());
    }
    return true;
  }
 else {
    throw new GameException(""String_Node_Str"" + seat.getPlayerType() + ""String_Node_Str"");
  }
}","public synchronized boolean joinTournament(UUID userId,String name,String playerType,int skill,DeckCardLists deckList,String password) throws GameException {
  if (table.getState() != TableState.WAITING) {
    return false;
  }
  Seat seat=table.getNextAvailableSeat(playerType);
  if (seat == null) {
    throw new GameException(""String_Node_Str"");
  }
  User user=UserManager.getInstance().getUser(userId);
  if (user == null) {
    logger.fatal(new StringBuilder(""String_Node_Str"").append(name).append(""String_Node_Str"").append(userId).toString());
    return false;
  }
  if (!table.getTournament().getOptions().getPassword().isEmpty() && playerType.equals(""String_Node_Str"")) {
    if (!table.getTournament().getOptions().getPassword().equals(password)) {
      user.showUserMessage(""String_Node_Str"",""String_Node_Str"");
      return false;
    }
  }
  if (userPlayerMap.containsKey(userId) && playerType.equals(""String_Node_Str"")) {
    user.showUserMessage(""String_Node_Str"",new StringBuilder(""String_Node_Str"").toString());
    return false;
  }
  Deck deck=null;
  if (!table.getTournament().getTournamentType().isLimited()) {
    if (deckList != null) {
      deck=Deck.load(deckList,false,false);
    }
 else {
      user.showUserMessage(""String_Node_Str"",""String_Node_Str"");
      return false;
    }
    if (!Main.isTestMode() && !table.getValidator().validate(deck)) {
      StringBuilder sb=new StringBuilder(""String_Node_Str"").append(name).append(""String_Node_Str"").append(table.getValidator().getName()).append(""String_Node_Str"");
      for (      Map.Entry<String,String> entry : table.getValidator().getInvalid().entrySet()) {
        sb.append(entry.getKey()).append(""String_Node_Str"").append(entry.getValue()).append(""String_Node_Str"");
      }
      sb.append(""String_Node_Str"");
      user.showUserMessage(""String_Node_Str"",sb.toString());
      if (isOwner(userId)) {
        logger.debug(""String_Node_Str"" + table.getId());
        TableManager.getInstance().removeTable(table.getId());
      }
      return false;
    }
  }
  Player player=createPlayer(name,seat.getPlayerType(),skill);
  if (player != null) {
    if (!player.canJoinTable(table)) {
      user.showUserMessage(""String_Node_Str"",new StringBuilder(""String_Node_Str"").append(seat.getPlayerType()).append(""String_Node_Str"").toString());
      return false;
    }
    tournament.addPlayer(player,seat.getPlayerType());
    TournamentPlayer tournamentPlayer=tournament.getPlayer(player.getId());
    if (deck != null && tournamentPlayer != null) {
      tournamentPlayer.submitDeck(deck);
    }
    table.joinTable(player,seat);
    logger.debug(""String_Node_Str"" + player.getName() + ""String_Node_Str""+ player.getId()+ ""String_Node_Str""+ table.getId());
    if (seat.getPlayer().isHuman()) {
      seat.getPlayer().setUserData(user.getUserData());
      user.addTable(player.getId(),table);
      user.ccJoinedTable(table.getRoomId(),table.getId(),true);
      userPlayerMap.put(userId,player.getId());
    }
    return true;
  }
 else {
    throw new GameException(""String_Node_Str"" + seat.getPlayerType() + ""String_Node_Str"");
  }
}",0.990950226244344
158960,"public CavernOfSoulsWatcher(final CavernOfSoulsWatcher watcher){
  super(watcher);
  this.spells.addAll(watcher.spells);
}","public CavernOfSoulsWatcher(final CavernOfSoulsWatcher watcher){
  super(watcher);
  this.spells.addAll(watcher.spells);
  this.originalId=watcher.originalId;
}",0.8652482269503546
158961,"@Override public boolean applies(GameEvent event,Ability source,Game game){
  CavernOfSoulsWatcher watcher=(CavernOfSoulsWatcher)game.getState().getWatchers().get(""String_Node_Str"");
  Spell spell=game.getStack().getSpell(event.getTargetId());
  return spell != null && watcher.spells.contains(spell.getId());
}","@Override public boolean applies(GameEvent event,Ability source,Game game){
  CavernOfSoulsWatcher watcher=(CavernOfSoulsWatcher)game.getState().getWatchers().get(""String_Node_Str"",source.getSourceId());
  Spell spell=game.getStack().getSpell(event.getTargetId());
  return spell != null && watcher != null && watcher.spellCantBeCountered(spell.getId());
}",0.8845577211394303
158962,"@Override public ConditionalMana build(Object... options){
  this.mana.setFlag(true);
  return new CavernOfSoulsConditionalMana(this.mana,creatureType);
}","@Override public ConditionalMana build(Object... options){
  return new CavernOfSoulsConditionalMana(this.mana,creatureType);
}",0.9039145907473308
158963,"@Override public void watch(GameEvent event,Game game){
  if (event.getType() == GameEvent.EventType.MANA_PAYED) {
    MageObject object=game.getObject(event.getSourceId());
    if (object != null && object.getName().equals(""String_Node_Str"") && event.getFlag()) {
      spells.add(event.getTargetId());
    }
  }
}","@Override public void watch(GameEvent event,Game game){
  if (event.getType() == GameEvent.EventType.MANA_PAYED) {
    if (event.getData() != null && event.getData().equals(originalId)) {
      spells.add(event.getTargetId());
    }
  }
}",0.7269439421338155
158964,"public ConditionalMana(ConditionalMana conditionalMana){
  super(conditionalMana);
  conditions=conditionalMana.conditions;
  scope=conditionalMana.scope;
  staticText=conditionalMana.staticText;
  manaProducerId=conditionalMana.manaProducerId;
}","public ConditionalMana(final ConditionalMana conditionalMana){
  super(conditionalMana);
  conditions=conditionalMana.conditions;
  scope=conditionalMana.scope;
  staticText=conditionalMana.staticText;
  manaProducerId=conditionalMana.manaProducerId;
  manaProducerOriginalId=conditionalMana.manaProducerOriginalId;
}",0.8738898756660746
158965,"private void removeConditional(ManaType manaType,Ability ability,Game game){
  for (  ConditionalMana mana : getConditionalMana()) {
    if (mana.get(manaType) > 0 && mana.apply(ability,game,mana.getManaProducerId())) {
      mana.set(manaType,mana.get(manaType) - 1);
      game.fireEvent(new GameEvent(GameEvent.EventType.MANA_PAYED,ability.getId(),mana.getManaProducerId(),ability.getControllerId(),0,mana.getFlag()));
      break;
    }
  }
}","private void removeConditional(ManaType manaType,Ability ability,Game game){
  for (  ConditionalMana mana : getConditionalMana()) {
    if (mana.get(manaType) > 0 && mana.apply(ability,game,mana.getManaProducerId())) {
      mana.set(manaType,mana.get(manaType) - 1);
      GameEvent event=new GameEvent(GameEvent.EventType.MANA_PAYED,ability.getId(),mana.getManaProducerId(),ability.getControllerId(),0,mana.getFlag());
      event.setData(mana.getManaProducerOriginalId().toString());
      game.fireEvent(event);
      break;
    }
  }
}",0.8855116514690983
158966,"public void addMana(Mana manaToAdd,Game game,Ability source,boolean emptyOnTurnsEnd){
  Mana mana=manaToAdd.copy();
  if (!game.replaceEvent(new ManaEvent(EventType.ADD_MANA,source.getId(),source.getSourceId(),source.getControllerId(),mana))) {
    if (mana instanceof ConditionalMana) {
      ManaPoolItem item=new ManaPoolItem((ConditionalMana)mana,source.getSourceId());
      if (emptyOnTurnsEnd) {
        item.setDuration(Duration.EndOfTurn);
      }
      this.manaItems.add(item);
    }
 else {
      ManaPoolItem item=new ManaPoolItem(mana.getRed(),mana.getGreen(),mana.getBlue(),mana.getWhite(),mana.getBlack(),mana.getColorless(),source.getSourceId(),mana.getFlag());
      if (emptyOnTurnsEnd) {
        item.setDuration(Duration.EndOfTurn);
      }
      this.manaItems.add(item);
    }
    GameEvent event=GameEvent.getEvent(GameEvent.EventType.MANA_ADDED,source.getId(),source.getSourceId(),source.getControllerId());
    event.setData(mana.toString());
    game.fireEvent(event);
  }
}","public void addMana(Mana manaToAdd,Game game,Ability source,boolean emptyOnTurnsEnd){
  Mana mana=manaToAdd.copy();
  if (!game.replaceEvent(new ManaEvent(EventType.ADD_MANA,source.getId(),source.getSourceId(),source.getControllerId(),mana))) {
    if (mana instanceof ConditionalMana) {
      ManaPoolItem item=new ManaPoolItem((ConditionalMana)mana,source.getSourceId(),source.getOriginalId());
      if (emptyOnTurnsEnd) {
        item.setDuration(Duration.EndOfTurn);
      }
      this.manaItems.add(item);
    }
 else {
      ManaPoolItem item=new ManaPoolItem(mana.getRed(),mana.getGreen(),mana.getBlue(),mana.getWhite(),mana.getBlack(),mana.getColorless(),source.getSourceId(),source.getOriginalId(),mana.getFlag());
      if (emptyOnTurnsEnd) {
        item.setDuration(Duration.EndOfTurn);
      }
      this.manaItems.add(item);
    }
    GameEvent event=GameEvent.getEvent(GameEvent.EventType.MANA_ADDED,source.getId(),source.getSourceId(),source.getControllerId());
    event.setData(mana.toString());
    game.fireEvent(event);
  }
}",0.9775390625
158967,"public boolean pay(ManaType manaType,Ability ability,Filter filter,Game game){
  if (!autoPayment && !manaType.equals(unlockedManaType)) {
    return false;
  }
  if (getConditional(manaType,ability,filter,game) > 0) {
    removeConditional(manaType,ability,game);
    lockManaType();
    return true;
  }
  for (  ManaPoolItem mana : manaItems) {
    if (filter != null) {
      MageObject sourceObject=game.getObject(mana.getSourceId());
      if (!filter.match(sourceObject,game)) {
        continue;
      }
    }
    boolean spendAnyMana=spendAnyMana(ability,game);
    if (mana.get(manaType) > 0 || (spendAnyMana && mana.count() > 0)) {
      game.fireEvent(new GameEvent(GameEvent.EventType.MANA_PAYED,ability.getId(),mana.getSourceId(),ability.getControllerId(),0,mana.getFlag()));
      if (spendAnyMana) {
        mana.removeAny();
      }
 else {
        mana.remove(manaType);
      }
      lockManaType();
      return true;
    }
  }
  return false;
}","public boolean pay(ManaType manaType,Ability ability,Filter filter,Game game){
  if (!autoPayment && !manaType.equals(unlockedManaType)) {
    return false;
  }
  if (getConditional(manaType,ability,filter,game) > 0) {
    removeConditional(manaType,ability,game);
    lockManaType();
    return true;
  }
  for (  ManaPoolItem mana : manaItems) {
    if (filter != null) {
      MageObject sourceObject=game.getObject(mana.getSourceId());
      if (!filter.match(sourceObject,game)) {
        continue;
      }
    }
    boolean spendAnyMana=spendAnyMana(ability,game);
    if (mana.get(manaType) > 0 || (spendAnyMana && mana.count() > 0)) {
      GameEvent event=new GameEvent(GameEvent.EventType.MANA_PAYED,ability.getId(),mana.getSourceId(),ability.getControllerId(),0,mana.getFlag());
      event.setData(mana.getOriginalId().toString());
      game.fireEvent(event);
      if (spendAnyMana) {
        mana.removeAny();
      }
 else {
        mana.remove(manaType);
      }
      lockManaType();
      return true;
    }
  }
  return false;
}",0.949826130153999
158968,"public ManaPoolItem(final ManaPoolItem item){
  this.red=item.red;
  this.green=item.green;
  this.blue=item.blue;
  this.white=item.white;
  this.black=item.black;
  this.colorless=item.colorless;
  if (item.conditionalMana != null) {
    this.conditionalMana=item.conditionalMana.copy();
  }
  this.sourceId=item.sourceId;
  this.flag=item.flag;
  this.duration=item.duration;
}","public ManaPoolItem(final ManaPoolItem item){
  this.red=item.red;
  this.green=item.green;
  this.blue=item.blue;
  this.white=item.white;
  this.black=item.black;
  this.colorless=item.colorless;
  if (item.conditionalMana != null) {
    this.conditionalMana=item.conditionalMana.copy();
  }
  this.sourceId=item.sourceId;
  this.originalId=item.originalId;
  this.flag=item.flag;
  this.duration=item.duration;
}",0.9559748427672956
158969,"@Override public boolean apply(Game game,Ability source){
  Player targetPlayer=game.getPlayer(this.getTargetPointer().getFirst(game,source));
  boolean colorShared;
  if (targetPlayer != null) {
    int possibleIterations=targetPlayer.getLibrary().size() / 2;
    int iteration=0;
    do {
      iteration++;
      if (iteration > possibleIterations + 20) {
        game.setDraw(source.getControllerId());
        return true;
      }
      colorShared=false;
      Card card1=targetPlayer.getLibrary().removeFromTop(game);
      if (card1 != null) {
        targetPlayer.moveCardToGraveyardWithInfo(card1,source.getSourceId(),game,Zone.LIBRARY);
        Card card2=targetPlayer.getLibrary().removeFromTop(game);
        if (card2 != null) {
          targetPlayer.moveCardToGraveyardWithInfo(card2,source.getSourceId(),game,Zone.LIBRARY);
          if (card1.getColor().hasColor() && card2.getColor().hasColor()) {
            colorShared=card1.getColor().shares(card2.getColor());
          }
        }
      }
    }
 while (colorShared && targetPlayer.isInGame());
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Player targetPlayer=game.getPlayer(this.getTargetPointer().getFirst(game,source));
  boolean colorShared;
  if (targetPlayer != null) {
    int possibleIterations=targetPlayer.getLibrary().size() / 2;
    int iteration=0;
    do {
      iteration++;
      if (iteration > possibleIterations + 20) {
        game.setDraw(source.getControllerId());
        return true;
      }
      colorShared=false;
      Card card1=null;
      Card card2=null;
      if (targetPlayer.getLibrary().size() > 0) {
        card1=targetPlayer.getLibrary().removeFromTop(game);
        if (targetPlayer.getLibrary().size() > 0) {
          card2=targetPlayer.getLibrary().removeFromTop(game);
          if (card1.getColor().hasColor() && card2.getColor().hasColor()) {
            colorShared=card1.getColor().shares(card2.getColor());
          }
        }
      }
      if (card1 != null) {
        targetPlayer.moveCardToGraveyardWithInfo(card1,source.getSourceId(),game,Zone.LIBRARY);
      }
      if (card2 != null) {
        targetPlayer.moveCardToGraveyardWithInfo(card2,source.getSourceId(),game,Zone.LIBRARY);
      }
    }
 while (colorShared && targetPlayer.isInGame());
    return true;
  }
  return false;
}",0.6714527027027027
158970,"@Override public boolean apply(Game game,Ability source){
  Player player=game.getPlayer(source.getControllerId());
  Permanent permanent=game.getPermanent(source.getSourceId());
  if (player != null && permanent != null) {
    int ageCounter=permanent.getCounters().getCount(CounterType.AGE);
    if (cumulativeCost instanceof ManaCost) {
      ManaCostsImpl totalCost=new ManaCostsImpl();
      for (int i=0; i < ageCounter; i++) {
        totalCost.add(cumulativeCost.copy());
      }
      if (player.chooseUse(Outcome.Benefit,""String_Node_Str"" + totalCost.getText() + ""String_Node_Str"",game)) {
        totalCost.clearPaid();
        if (totalCost.payOrRollback(source,game,source.getSourceId(),source.getControllerId())) {
          return true;
        }
      }
      permanent.sacrifice(source.getSourceId(),game);
      return true;
    }
 else {
      CostsImpl totalCost=new CostsImpl();
      for (int i=0; i < ageCounter; i++) {
        totalCost.add(cumulativeCost.copy());
      }
      if (player.chooseUse(Outcome.Benefit,totalCost.getText() + ""String_Node_Str"",game)) {
        totalCost.clearPaid();
        int bookmark=game.bookmarkState();
        if (totalCost.pay(source,game,source.getSourceId(),source.getControllerId(),false)) {
          return true;
        }
 else {
          game.restoreState(bookmark,source.getRule());
        }
      }
      permanent.sacrifice(source.getSourceId(),game);
      return true;
    }
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Player player=game.getPlayer(source.getControllerId());
  Permanent permanent=game.getPermanent(source.getSourceId());
  if (player != null && permanent != null) {
    int ageCounter=permanent.getCounters().getCount(CounterType.AGE);
    if (cumulativeCost instanceof ManaCost) {
      ManaCostsImpl totalCost=new ManaCostsImpl();
      for (int i=0; i < ageCounter; i++) {
        totalCost.add((ManaCost)cumulativeCost.copy());
      }
      if (player.chooseUse(Outcome.Benefit,""String_Node_Str"" + totalCost.getText() + ""String_Node_Str"",game)) {
        totalCost.clearPaid();
        if (totalCost.payOrRollback(source,game,source.getSourceId(),source.getControllerId())) {
          return true;
        }
      }
      permanent.sacrifice(source.getSourceId(),game);
      return true;
    }
 else {
      CostsImpl totalCost=new CostsImpl();
      for (int i=0; i < ageCounter; i++) {
        totalCost.add(cumulativeCost.copy());
      }
      if (player.chooseUse(Outcome.Benefit,totalCost.getText() + ""String_Node_Str"",game)) {
        totalCost.clearPaid();
        int bookmark=game.bookmarkState();
        if (totalCost.pay(source,game,source.getSourceId(),source.getControllerId(),false)) {
          return true;
        }
 else {
          game.restoreState(bookmark,source.getRule());
        }
      }
      permanent.sacrifice(source.getSourceId(),game);
      return true;
    }
  }
  return false;
}",0.996614759647935
158971,"/** 
 * @param game
 * @param source
 * @return 
 */
@Override public boolean isInUseableZone(Game game,MageObject source,GameEvent event){
  if (zone.equals(Zone.COMMAND)) {
    if (this.getSourceId() == null) {
      return true;
    }
    MageObject object=game.getObject(this.getSourceId());
    if (object != null && object instanceof Emblem) {
      return true;
    }
  }
  MageObject object;
  UUID parameterSourceId;
  if (this instanceof MageSingleton && source != null) {
    object=source;
    parameterSourceId=source.getId();
  }
 else {
    object=game.getObject(getSourceId());
    parameterSourceId=getSourceId();
  }
  if (object != null && !object.getAbilities().contains(this)) {
    boolean found=false;
    if (object instanceof PermanentCard) {
      if (((PermanentCard)object).canTransform()) {
        PermanentCard permanent=(PermanentCard)object;
        found=permanent.getSecondCardFace().getAbilities().contains(this) || permanent.getCard().getAbilities().contains(this);
      }
    }
 else {
      Abilities<Ability> otherAbilities=game.getState().getAllOtherAbilities(this.getSourceId());
      found=otherAbilities != null && otherAbilities.contains(this);
    }
    if (!found) {
      return false;
    }
  }
  Zone test=game.getState().getZone(parameterSourceId);
  return test != null && zone.match(test);
}","/** 
 * @param game
 * @param source
 * @return 
 */
@Override public boolean isInUseableZone(Game game,MageObject source,GameEvent event){
  if (zone.equals(Zone.COMMAND)) {
    if (this.getSourceId() == null) {
      return true;
    }
    MageObject object=game.getObject(this.getSourceId());
    if (object != null && object instanceof Emblem) {
      return true;
    }
  }
  MageObject object;
  UUID parameterSourceId;
  if (this instanceof MageSingleton && source != null) {
    object=source;
    parameterSourceId=source.getId();
  }
 else {
    object=game.getObject(getSourceId());
    parameterSourceId=getSourceId();
  }
  if (object != null && !object.getAbilities().contains(this)) {
    if (!(object instanceof Permanent)) {
      Abilities<Ability> otherAbilities=game.getState().getAllOtherAbilities(this.getSourceId());
      if (otherAbilities == null || !otherAbilities.contains(this)) {
        return false;
      }
    }
  }
  Zone test=game.getState().getZone(parameterSourceId);
  return test != null && zone.match(test);
}",0.6143572621035058
158972,"@Override public boolean checkTrigger(GameEvent event,Game game){
  if (event.getType() == GameEvent.EventType.TRANSFORMED && event.getTargetId().equals(sourceId)) {
    Permanent permanent=game.getPermanent(sourceId);
    if (permanent != null && permanent.isTransformed()) {
      return true;
    }
  }
  return false;
}","@Override public boolean checkTrigger(GameEvent event,Game game){
  if (event.getTargetId().equals(sourceId)) {
    Permanent permanent=game.getPermanent(sourceId);
    if (permanent != null && permanent.isTransformed()) {
      return true;
    }
  }
  return false;
}",0.3682432432432432
158973,"/** 
 * @param game
 * @param source
 * @return 
 */
@Override public boolean isInUseableZone(Game game,MageObject source,GameEvent event){
  if (zone.equals(Zone.COMMAND)) {
    if (this.getSourceId() == null) {
      return true;
    }
    MageObject object=game.getObject(this.getSourceId());
    if (object != null && object instanceof Emblem) {
      return true;
    }
  }
  MageObject object;
  UUID parameterSourceId;
  if (this instanceof MageSingleton && source != null) {
    object=source;
    parameterSourceId=source.getId();
  }
 else {
    object=game.getObject(getSourceId());
    parameterSourceId=getSourceId();
  }
  if (object != null && !object.getAbilities().contains(this)) {
    if (!(object instanceof Permanent)) {
      Abilities<Ability> otherAbilities=game.getState().getAllOtherAbilities(this.getSourceId());
      if (otherAbilities == null || !otherAbilities.contains(this)) {
        return false;
      }
    }
  }
  Zone test=game.getState().getZone(parameterSourceId);
  return test != null && zone.match(test);
}","/** 
 * @param game
 * @param source
 * @return 
 */
@Override public boolean isInUseableZone(Game game,MageObject source,GameEvent event){
  if (zone.equals(Zone.COMMAND)) {
    if (this.getSourceId() == null) {
      return true;
    }
    MageObject object=game.getObject(this.getSourceId());
    if (object != null && object instanceof Emblem) {
      return true;
    }
  }
  MageObject object;
  UUID parameterSourceId;
  if (this instanceof MageSingleton && source != null) {
    object=source;
    parameterSourceId=source.getId();
  }
 else {
    object=game.getObject(getSourceId());
    parameterSourceId=getSourceId();
  }
  if (object != null && !object.getAbilities().contains(this)) {
    if (object instanceof Permanent) {
      return false;
    }
 else {
      Abilities<Ability> otherAbilities=game.getState().getAllOtherAbilities(this.getSourceId());
      if (otherAbilities == null || !otherAbilities.contains(this)) {
        return false;
      }
    }
  }
  Zone test=game.getState().getZone(parameterSourceId);
  return test != null && zone.match(test);
}",0.982637259502581
158974,"@Override public boolean apply(Game game,Ability source){
  Player target=game.getPlayer(source.getFirstTarget());
  if (target != null) {
    for (    Permanent p : game.getBattlefield().getAllActivePermanents(new FilterCreaturePermanent(),target.getId(),game)) {
      p.addCounters(CounterType.M1M1.createInstance(),game);
    }
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Player targetPlayer=game.getPlayer(getTargetPointer().getFirst(game,source));
  if (targetPlayer != null) {
    for (    Permanent creature : game.getBattlefield().getAllActivePermanents(new FilterCreaturePermanent(),targetPlayer.getId(),game)) {
      creature.addCounters(CounterType.M1M1.createInstance(),game);
    }
    return true;
  }
  return false;
}",0.899873257287706
158975,"@Override public boolean choose(Outcome outcome,Target target,UUID sourceId,Game game,Map<String,Serializable> options){
  if (!choices.isEmpty()) {
    if (target instanceof TargetPermanent) {
      for (      Permanent permanent : game.getBattlefield().getAllActivePermanents((FilterPermanent)target.getFilter(),game)) {
        for (        String choose2 : choices) {
          if (permanent.getName().equals(choose2)) {
            if (((TargetPermanent)target).canTarget(playerId,permanent.getId(),null,game) && !target.getTargets().contains(permanent.getId())) {
              target.add(permanent.getId(),game);
              choices.remove(choose2);
              return true;
            }
          }
 else           if ((permanent.getName() + ""String_Node_Str"" + permanent.getExpansionSetCode()).equals(choose2)) {
            if (((TargetPermanent)target).canTarget(playerId,permanent.getId(),null,game) && !target.getTargets().contains(permanent.getId())) {
              target.add(permanent.getId(),game);
              choices.remove(choose2);
              return true;
            }
          }
        }
      }
    }
    if (target instanceof TargetPlayer) {
      for (      Player player : game.getPlayers().values()) {
        for (        String choose2 : choices) {
          if (player.getName().equals(choose2)) {
            if (((TargetPlayer)target).canTarget(playerId,player.getId(),null,game) && !target.getTargets().contains(player.getId())) {
              target.add(player.getId(),game);
              choices.remove(choose2);
              return true;
            }
          }
        }
      }
    }
    if (target instanceof TargetSource) {
      Set<UUID> possibleTargets;
      TargetSource t=((TargetSource)target);
      possibleTargets=t.possibleTargets(sourceId,playerId,game);
      for (      UUID targetId : possibleTargets) {
        MageObject targetObject=game.getObject(targetId);
        if (targetObject != null) {
          for (          String choose2 : choices) {
            if (targetObject.getName().equals(choose2)) {
              List<UUID> alreadyTargetted=target.getTargets();
              if (t.canTarget(targetObject.getId(),game)) {
                if (alreadyTargetted != null && !alreadyTargetted.contains(targetObject.getId())) {
                  target.add(targetObject.getId(),game);
                  choices.remove(choose2);
                  return true;
                }
              }
            }
          }
        }
      }
    }
  }
  return super.choose(outcome,target,sourceId,game,options);
}","@Override public boolean choose(Outcome outcome,Target target,UUID sourceId,Game game,Map<String,Serializable> options){
  if (!choices.isEmpty()) {
    if ((target instanceof TargetPermanent) || (target instanceof TargetPermanentOrPlayer)) {
      FilterPermanent filterPermanent;
      if (target instanceof TargetPermanentOrPlayer) {
        filterPermanent=((TargetPermanentOrPlayer)target).getFilterPermanent();
      }
 else {
        filterPermanent=((TargetPermanent)target).getFilter();
      }
      for (      String choose2 : choices) {
        String[] targetList=choose2.split(""String_Node_Str"");
        boolean targetFound=false;
        for (        String targetName : targetList) {
          for (          Permanent permanent : game.getBattlefield().getAllActivePermanents(filterPermanent,game)) {
            if (target.getTargets().contains(permanent.getId())) {
              continue;
            }
            if (permanent.getName().equals(targetName)) {
              if (target.isNotTarget() || ((TargetPermanent)target).canTarget(playerId,permanent.getId(),null,game)) {
                target.add(permanent.getId(),game);
                targetFound=true;
                break;
              }
            }
 else             if ((permanent.getName() + ""String_Node_Str"" + permanent.getExpansionSetCode()).equals(targetName)) {
              if (target.isNotTarget() || ((TargetPermanent)target).canTarget(playerId,permanent.getId(),null,game)) {
                target.add(permanent.getId(),game);
                targetFound=true;
                break;
              }
            }
          }
        }
        if (targetFound) {
          choices.remove(choose2);
          return true;
        }
      }
    }
    if (target instanceof TargetPlayer) {
      for (      Player player : game.getPlayers().values()) {
        for (        String choose2 : choices) {
          if (player.getName().equals(choose2)) {
            if (((TargetPlayer)target).canTarget(playerId,player.getId(),null,game) && !target.getTargets().contains(player.getId())) {
              target.add(player.getId(),game);
              choices.remove(choose2);
              return true;
            }
          }
        }
      }
    }
    if (target instanceof TargetSource) {
      Set<UUID> possibleTargets;
      TargetSource t=((TargetSource)target);
      possibleTargets=t.possibleTargets(sourceId,playerId,game);
      for (      UUID targetId : possibleTargets) {
        MageObject targetObject=game.getObject(targetId);
        if (targetObject != null) {
          for (          String choose2 : choices) {
            if (targetObject.getName().equals(choose2)) {
              List<UUID> alreadyTargetted=target.getTargets();
              if (t.canTarget(targetObject.getId(),game)) {
                if (alreadyTargetted != null && !alreadyTargetted.contains(targetObject.getId())) {
                  target.add(targetObject.getId(),game);
                  choices.remove(choose2);
                  return true;
                }
              }
            }
          }
        }
      }
    }
  }
  return super.choose(outcome,target,sourceId,game,options);
}",0.7686721991701245
158976,"@Override public boolean chooseTarget(Outcome outcome,Target target,Ability source,Game game){
  if (!targets.isEmpty()) {
    if (target instanceof TargetPermanent) {
      for (      String targetDefinition : targets) {
        String[] targetList=targetDefinition.split(""String_Node_Str"");
        boolean targetFound=false;
        for (        String targetName : targetList) {
          boolean allowCopy=true;
          if (targetName.endsWith(""String_Node_Str"")) {
            allowCopy=false;
            targetName=targetName.substring(0,targetName.length() - 9);
          }
          for (          Permanent permanent : game.getBattlefield().getAllActivePermanents((FilterPermanent)target.getFilter(),game)) {
            if (permanent.getName().equals(targetName) || (permanent.getName() + ""String_Node_Str"" + permanent.getExpansionSetCode()).equals(targetName)) {
              if (((TargetPermanent)target).canTarget(source == null ? this.getId() : source.getControllerId(),permanent.getId(),source,game) && !target.getTargets().contains(permanent.getId())) {
                if (!permanent.isCopy() || allowCopy) {
                  target.add(permanent.getId(),game);
                  targetFound=true;
                  break;
                }
              }
            }
          }
        }
        if (targetFound) {
          targets.remove(targetDefinition);
          return true;
        }
      }
    }
    if (target instanceof TargetPlayer) {
      for (      String targetDefinition : targets) {
        if (targetDefinition.startsWith(""String_Node_Str"")) {
          String playerName=targetDefinition.substring(targetDefinition.indexOf(""String_Node_Str"") + 13);
          for (          Player player : game.getPlayers().values()) {
            if (player.getName().equals(playerName) && ((TargetPlayer)target).canTarget(playerId,player.getId(),source,game)) {
              target.add(player.getId(),game);
              return true;
            }
          }
        }
      }
    }
    if (target instanceof TargetCardInHand) {
      for (      String targetDefinition : targets) {
        String[] targetList=targetDefinition.split(""String_Node_Str"");
        boolean targetFound=false;
        for (        String targetName : targetList) {
          for (          Card card : this.getHand().getCards(((TargetCardInHand)target).getFilter(),game)) {
            if (card.getName().equals(targetName) || (card.getName() + ""String_Node_Str"" + card.getExpansionSetCode()).equals(targetName)) {
              if (((TargetCardInHand)target).canTarget(source.getControllerId(),card.getId(),source,game) && !target.getTargets().contains(card.getId())) {
                target.add(card.getId(),game);
                targetFound=true;
                break;
              }
            }
          }
        }
        if (targetFound) {
          targets.remove(targetDefinition);
          return true;
        }
      }
    }
  }
  return super.chooseTarget(outcome,target,source,game);
}","@Override public boolean chooseTarget(Outcome outcome,Target target,Ability source,Game game){
  if (!targets.isEmpty()) {
    if ((target instanceof TargetPermanent) || (target instanceof TargetPermanentOrPlayer)) {
      for (      String targetDefinition : targets) {
        String[] targetList=targetDefinition.split(""String_Node_Str"");
        boolean targetFound=false;
        for (        String targetName : targetList) {
          boolean allowCopy=true;
          if (targetName.endsWith(""String_Node_Str"")) {
            allowCopy=false;
            targetName=targetName.substring(0,targetName.length() - 9);
          }
          for (          Permanent permanent : game.getBattlefield().getAllActivePermanents((FilterPermanent)target.getFilter(),game)) {
            if (permanent.getName().equals(targetName) || (permanent.getName() + ""String_Node_Str"" + permanent.getExpansionSetCode()).equals(targetName)) {
              if (((TargetPermanent)target).canTarget(source == null ? this.getId() : source.getControllerId(),permanent.getId(),source,game) && !target.getTargets().contains(permanent.getId())) {
                if (!permanent.isCopy() || allowCopy) {
                  target.add(permanent.getId(),game);
                  targetFound=true;
                  break;
                }
              }
            }
          }
        }
        if (targetFound) {
          targets.remove(targetDefinition);
          return true;
        }
      }
    }
    if (target instanceof TargetPlayer) {
      for (      String targetDefinition : targets) {
        if (targetDefinition.startsWith(""String_Node_Str"")) {
          String playerName=targetDefinition.substring(targetDefinition.indexOf(""String_Node_Str"") + 13);
          for (          Player player : game.getPlayers().values()) {
            if (player.getName().equals(playerName) && ((TargetPlayer)target).canTarget(playerId,player.getId(),source,game)) {
              target.add(player.getId(),game);
              return true;
            }
          }
        }
      }
    }
    if (target instanceof TargetCardInHand) {
      for (      String targetDefinition : targets) {
        String[] targetList=targetDefinition.split(""String_Node_Str"");
        boolean targetFound=false;
        for (        String targetName : targetList) {
          for (          Card card : this.getHand().getCards(((TargetCardInHand)target).getFilter(),game)) {
            if (card.getName().equals(targetName) || (card.getName() + ""String_Node_Str"" + card.getExpansionSetCode()).equals(targetName)) {
              if (((TargetCardInHand)target).canTarget(source.getControllerId(),card.getId(),source,game) && !target.getTargets().contains(card.getId())) {
                target.add(card.getId(),game);
                targetFound=true;
                break;
              }
            }
          }
        }
        if (targetFound) {
          targets.remove(targetDefinition);
          return true;
        }
      }
    }
  }
  return super.chooseTarget(outcome,target,source,game);
}",0.9919658960485326
158977,"@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  Target target=new TargetPermanentOrPlayerWithCounter(0,Integer.MAX_VALUE,true);
  if (target.canChoose(controller.getId(),game)) {
    boolean abilityApplied=false;
    Map<String,Serializable> options=new HashMap<>();
    options.put(""String_Node_Str"",""String_Node_Str"");
    while (target.canChoose(controller.getId(),game)) {
      if (controller.choose(Outcome.Benefit,target,source.getSourceId(),game,options)) {
        break;
      }
    }
    for (int idx=0; idx < target.getTargets().size(); idx++) {
      UUID chosen=(UUID)target.getTargets().get(idx);
      Permanent permanent=game.getPermanent(chosen);
      if (permanent != null) {
        if (permanent.getCounters().size() > 0) {
          if (permanent.getCounters().size() == 1) {
            for (            Counter counter : permanent.getCounters().values()) {
              permanent.addCounters(counter.getName(),1,game);
            }
          }
 else {
            Choice choice=new ChoiceImpl(true);
            Set<String> choices=new HashSet<>();
            for (            Counter counter : permanent.getCounters().values()) {
              choices.add(counter.getName());
            }
            choice.setChoices(choices);
            choice.setMessage(""String_Node_Str"" + permanent.getName() + ""String_Node_Str"");
            controller.choose(Outcome.Benefit,choice,game);
            for (            Counter counter : permanent.getCounters().values()) {
              if (counter.getName().equals(choice.getChoice())) {
                permanent.addCounters(counter.getName(),1,game);
                break;
              }
            }
          }
        }
      }
 else {
        Player player=game.getPlayer(chosen);
        if (player != null) {
          if (player.getCounters().size() > 0) {
            if (player.getCounters().size() == 1) {
              for (              Counter counter : player.getCounters().values()) {
                Counter newCounter=new Counter(counter.getName());
                player.addCounters(newCounter,game);
              }
            }
 else {
              Choice choice=new ChoiceImpl(true);
              Set<String> choices=new HashSet<>();
              for (              Counter counter : player.getCounters().values()) {
                choices.add(counter.getName());
              }
              choice.setChoices(choices);
              choice.setMessage(""String_Node_Str"" + player.getName() + ""String_Node_Str"");
              controller.choose(Outcome.Benefit,choice,game);
              for (              Counter counter : player.getCounters().values()) {
                if (counter.getName().equals(choice.getChoice())) {
                  Counter newCounter=new Counter(counter.getName());
                  player.addCounters(newCounter,game);
                  break;
                }
              }
            }
          }
        }
      }
    }
    return abilityApplied;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller == null) {
    return false;
  }
  Target target=new TargetPermanentOrPlayerWithCounter(0,Integer.MAX_VALUE,true);
  Map<String,Serializable> options=new HashMap<>();
  options.put(""String_Node_Str"",""String_Node_Str"");
  controller.choose(Outcome.Benefit,target,source.getSourceId(),game,options);
  for (int idx=0; idx < target.getTargets().size(); idx++) {
    UUID chosen=(UUID)target.getTargets().get(idx);
    Permanent permanent=game.getPermanent(chosen);
    if (permanent != null) {
      if (permanent.getCounters().size() > 0) {
        if (permanent.getCounters().size() == 1) {
          for (          Counter counter : permanent.getCounters().values()) {
            permanent.addCounters(counter.getName(),1,game);
          }
        }
 else {
          Choice choice=new ChoiceImpl(true);
          Set<String> choices=new HashSet<>();
          for (          Counter counter : permanent.getCounters().values()) {
            choices.add(counter.getName());
          }
          choice.setChoices(choices);
          choice.setMessage(""String_Node_Str"" + permanent.getName() + ""String_Node_Str"");
          controller.choose(Outcome.Benefit,choice,game);
          for (          Counter counter : permanent.getCounters().values()) {
            if (counter.getName().equals(choice.getChoice())) {
              permanent.addCounters(counter.getName(),1,game);
              break;
            }
          }
        }
      }
    }
 else {
      Player player=game.getPlayer(chosen);
      if (player != null) {
        if (player.getCounters().size() > 0) {
          if (player.getCounters().size() == 1) {
            for (            Counter counter : player.getCounters().values()) {
              Counter newCounter=new Counter(counter.getName());
              player.addCounters(newCounter,game);
            }
          }
 else {
            Choice choice=new ChoiceImpl(true);
            Set<String> choices=new HashSet<>();
            for (            Counter counter : player.getCounters().values()) {
              choices.add(counter.getName());
            }
            choice.setChoices(choices);
            choice.setMessage(""String_Node_Str"" + player.getName() + ""String_Node_Str"");
            controller.choose(Outcome.Benefit,choice,game);
            for (            Counter counter : player.getCounters().values()) {
              if (counter.getName().equals(choice.getChoice())) {
                Counter newCounter=new Counter(counter.getName());
                player.addCounters(newCounter,game);
                break;
              }
            }
          }
        }
      }
    }
  }
  return true;
}",0.8874532471948317
158978,"@Override public boolean apply(Permanent input,Game game){
  return input.getCounters().containsKey(counter);
}","@Override public boolean apply(Permanent input,Game game){
  if (counter == null) {
    return !input.getCounters().keySet().isEmpty();
  }
 else {
    return input.getCounters().containsKey(counter);
  }
}",0.6561514195583596
158979,"public CounterPredicate(CounterType counter){
  this.counter=counter;
}","/** 
 * @param counter if null any counter selects the permanent
 */
public CounterPredicate(CounterType counter){
  this.counter=counter;
}",0.6729857819905213
158980,"@Override public boolean apply(Game game,Ability source){
  Player targetOpponent=game.getPlayer(source.getTargets().getFirstTarget());
  Player controller=game.getPlayer(source.getControllerId());
  if (targetOpponent == null || controller == null) {
    return false;
  }
  FilterControlledPermanent filter=new FilterControlledPermanent(""String_Node_Str"");
  filter.add(new CardTypePredicate(CardType.CREATURE));
  filter.add(new ControllerPredicate(TargetController.YOU));
  filter.add(Predicates.or(new ColorPredicate(ObjectColor.GREEN),new ColorPredicate(ObjectColor.WHITE)));
  TargetControlledPermanent target=new TargetControlledPermanent(1,1,filter,false);
  if (target.canChoose(targetOpponent.getId(),game)) {
    targetOpponent.chooseTarget(Outcome.Sacrifice,target,source,game);
    Permanent permanent=game.getPermanent(target.getFirstTarget());
    if (permanent != null) {
      if (permanent.sacrifice(source.getSourceId(),game)) {
        controller.loseLife(2,game);
      }
    }
  }
  return true;
}","@Override public boolean apply(Game game,Ability source){
  Player targetOpponent=game.getPlayer(source.getTargets().getFirstTarget());
  Player controller=game.getPlayer(source.getControllerId());
  if (targetOpponent == null || controller == null) {
    return false;
  }
  FilterControlledPermanent filter=new FilterControlledPermanent(""String_Node_Str"");
  filter.add(new CardTypePredicate(CardType.CREATURE));
  filter.add(new ControllerPredicate(TargetController.YOU));
  filter.add(Predicates.or(new ColorPredicate(ObjectColor.GREEN),new ColorPredicate(ObjectColor.WHITE)));
  TargetControlledPermanent target=new TargetControlledPermanent(1,1,filter,false);
  if (target.canChoose(targetOpponent.getId(),game)) {
    targetOpponent.chooseTarget(Outcome.Sacrifice,target,source,game);
    Permanent permanent=game.getPermanent(target.getFirstTarget());
    if (permanent != null) {
      if (permanent.sacrifice(source.getSourceId(),game)) {
        targetOpponent.loseLife(2,game);
      }
    }
  }
  return true;
}",0.9882583170254404
158981,"protected final String getType(CardView card){
  StringBuilder sbType=new StringBuilder();
  for (  String superType : card.getSuperTypes()) {
    sbType.append(superType).append(""String_Node_Str"");
  }
  for (  CardType cardType : card.getCardTypes()) {
    sbType.append(cardType.toString()).append(""String_Node_Str"");
  }
  if (card.getSubTypes().size() > 0) {
    sbType.append(""String_Node_Str"");
    for (    String subType : card.getSubTypes()) {
      sbType.append(subType).append(""String_Node_Str"");
    }
  }
  return sbType.toString();
}","protected final String getType(CardView card){
  StringBuilder sbType=new StringBuilder();
  for (  String superType : card.getSuperTypes()) {
    sbType.append(superType).append(""String_Node_Str"");
  }
  for (  CardType cardType : card.getCardTypes()) {
    sbType.append(cardType.toString()).append(""String_Node_Str"");
  }
  if (card.getSubTypes().size() > 0) {
    sbType.append(""String_Node_Str"");
    for (    String subType : card.getSubTypes()) {
      sbType.append(subType).append(""String_Node_Str"");
    }
  }
  return sbType.toString().trim();
}",0.9936651583710407
158982,"public CardPanel(CardView newGameCard,UUID gameId,final boolean loadImage,ActionCallback callback,final boolean foil,Dimension dimension){
  this.gameCard=newGameCard;
  this.callback=callback;
  this.gameId=gameId;
  this.setCardBounds(0,0,dimension.width,dimension.height);
  this.isPermanent=this.gameCard instanceof PermanentView;
  if (isPermanent) {
    this.hasSickness=((PermanentView)this.gameCard).hasSummoningSickness();
  }
  if (this.gameCard.canTransform()) {
    buttonPanel=new JPanel();
    buttonPanel.setLayout(null);
    buttonPanel.setOpaque(false);
    add(buttonPanel);
    dayNightButton=new JButton(""String_Node_Str"");
    dayNightButton.setLocation(2,2);
    dayNightButton.setSize(25,25);
    buttonPanel.setVisible(true);
    BufferedImage day=ImageManagerImpl.getInstance().getDayImage();
    dayNightButton.setIcon(new ImageIcon(day));
    buttonPanel.add(dayNightButton);
    dayNightButton.addActionListener(new ActionListener(){
      @Override public void actionPerformed(      ActionEvent e){
        if (animationInProgress || isTapped() || isPermanent) {
          return;
        }
        Animation.transformCard(CardPanel.this,CardPanel.this,true);
      }
    }
);
  }
  counterPanel=new JPanel();
  counterPanel.setLayout(null);
  counterPanel.setOpaque(false);
  add(counterPanel);
  plusCounterLabel=new JLabel(""String_Node_Str"");
  plusCounterLabel.setToolTipText(""String_Node_Str"");
  counterPanel.add(plusCounterLabel);
  minusCounterLabel=new JLabel(""String_Node_Str"");
  minusCounterLabel.setToolTipText(""String_Node_Str"");
  counterPanel.add(minusCounterLabel);
  loyaltyCounterLabel=new JLabel(""String_Node_Str"");
  loyaltyCounterLabel.setToolTipText(""String_Node_Str"");
  counterPanel.add(loyaltyCounterLabel);
  otherCounterLabel=new JLabel(""String_Node_Str"");
  counterPanel.add(otherCounterLabel);
  counterPanel.setVisible(false);
  if (newGameCard.isAbility()) {
    if (AbilityType.TRIGGERED.equals(newGameCard.getAbilityType())) {
      setTypeIcon(ImageManagerImpl.getInstance().getTriggeredAbilityImage(),""String_Node_Str"");
    }
 else     if (AbilityType.ACTIVATED.equals(newGameCard.getAbilityType())) {
      setTypeIcon(ImageManagerImpl.getInstance().getActivatedAbilityImage(),""String_Node_Str"");
    }
  }
  if (this.gameCard.isToken()) {
    setTypeIcon(ImageManagerImpl.getInstance().getTokenIconImage(),""String_Node_Str"");
  }
  if (this.gameCard instanceof PermanentView) {
    copyIconPanel=new JPanel();
    copyIconPanel.setLayout(null);
    copyIconPanel.setOpaque(false);
    add(copyIconPanel);
    showCopySourceButton=new JButton(""String_Node_Str"");
    showCopySourceButton.setLocation(2,2);
    showCopySourceButton.setSize(25,25);
    showCopySourceButton.setToolTipText(""String_Node_Str"");
    copyIconPanel.setVisible(((PermanentView)this.gameCard).isCopy());
    showCopySourceButton.setIcon(new ImageIcon(ImageManagerImpl.getInstance().getCopyInformIconImage()));
    copyIconPanel.add(showCopySourceButton);
    showCopySourceButton.addActionListener(new ActionListener(){
      @Override public void actionPerformed(      ActionEvent e){
        ActionCallback callback=Plugins.getInstance().getActionCallback();
        ((MageActionCallback)callback).enlargeCard(EnlargeMode.COPY);
      }
    }
);
  }
  setBackground(Color.black);
  setOpaque(false);
  addMouseListener(this);
  addMouseMotionListener(this);
  addMouseWheelListener(this);
  addComponentListener(this);
  displayTitleAnyway=PreferencesDialog.getCachedValue(PreferencesDialog.KEY_SHOW_CARD_NAMES,""String_Node_Str"").equals(""String_Node_Str"");
  titleText=new GlowText();
  setText(gameCard);
  titleText.setFont(getFont().deriveFont(Font.BOLD,13f));
  titleText.setForeground(Color.white);
  titleText.setGlow(Color.black,TEXT_GLOW_SIZE,TEXT_GLOW_INTENSITY);
  titleText.setWrap(true);
  add(titleText);
  ptText=new GlowText();
  if (CardUtil.isCreature(gameCard)) {
    ptText.setText(gameCard.getPower() + ""String_Node_Str"" + gameCard.getToughness());
  }
 else   if (CardUtil.isPlaneswalker(gameCard)) {
    ptText.setText(gameCard.getLoyalty());
  }
  ptText.setFont(getFont().deriveFont(Font.BOLD,13f));
  ptText.setForeground(Color.white);
  ptText.setGlow(Color.black,TEXT_GLOW_SIZE,TEXT_GLOW_INTENSITY);
  add(ptText);
  BufferedImage sickness=ImageManagerImpl.getInstance().getSicknessImage();
  overlayPanel=new ImagePanel(sickness,ImagePanel.SCALED);
  overlayPanel.setOpaque(false);
  add(overlayPanel);
  imagePanel=new ScaledImagePanel();
  imagePanel.setBorder(BorderFactory.createLineBorder(Color.white));
  add(imagePanel);
  imagePanel.setScaleLarger(true);
  imagePanel.setScalingType(ScalingType.nearestNeighbor);
  imagePanel.setScalingMultiPassType(MultipassType.none);
  String cardType=getType(newGameCard);
  popupText.setText(getText(cardType,newGameCard));
  Util.threadPool.submit(new Runnable(){
    @Override public void run(){
      try {
        tappedAngle=isTapped() ? CardPanel.TAPPED_ANGLE : 0;
        flippedAngle=isFlipped() ? CardPanel.FLIPPED_ANGLE : 0;
        if (!loadImage) {
          return;
        }
        BufferedImage srcImage;
        if (gameCard.isFaceDown()) {
          srcImage=getFaceDownImage();
        }
 else {
          srcImage=ImageCache.getImage(gameCard,getCardWidth(),getCardHeight());
        }
        if (srcImage != null) {
          hasImage=true;
          setText(gameCard);
          setImage(srcImage);
        }
        if (gameCard.isTransformed()) {
          toggleTransformed();
        }
        setText(gameCard);
      }
 catch (      Exception e) {
        e.printStackTrace();
      }
catch (      Error err) {
        err.printStackTrace();
      }
    }
  }
);
}","public CardPanel(CardView newGameCard,UUID gameId,final boolean loadImage,ActionCallback callback,final boolean foil,Dimension dimension){
  this.gameCard=newGameCard;
  this.callback=callback;
  this.gameId=gameId;
  this.setCardBounds(0,0,dimension.width,dimension.height);
  this.isPermanent=this.gameCard instanceof PermanentView;
  if (isPermanent) {
    this.hasSickness=((PermanentView)this.gameCard).hasSummoningSickness();
  }
  if (this.gameCard.canTransform()) {
    buttonPanel=new JPanel();
    buttonPanel.setLayout(null);
    buttonPanel.setOpaque(false);
    add(buttonPanel);
    dayNightButton=new JButton(""String_Node_Str"");
    dayNightButton.setLocation(2,2);
    dayNightButton.setSize(25,25);
    buttonPanel.setVisible(true);
    BufferedImage day=ImageManagerImpl.getInstance().getDayImage();
    dayNightButton.setIcon(new ImageIcon(day));
    buttonPanel.add(dayNightButton);
    dayNightButton.addActionListener(new ActionListener(){
      @Override public void actionPerformed(      ActionEvent e){
        if (animationInProgress || isTapped() || isPermanent) {
          return;
        }
        Animation.transformCard(CardPanel.this,CardPanel.this,true);
      }
    }
);
  }
  if (!newGameCard.isAbility()) {
    counterPanel=new JPanel();
    counterPanel.setLayout(null);
    counterPanel.setOpaque(false);
    add(counterPanel);
    plusCounterLabel=new JLabel(""String_Node_Str"");
    plusCounterLabel.setToolTipText(""String_Node_Str"");
    counterPanel.add(plusCounterLabel);
    minusCounterLabel=new JLabel(""String_Node_Str"");
    minusCounterLabel.setToolTipText(""String_Node_Str"");
    counterPanel.add(minusCounterLabel);
    loyaltyCounterLabel=new JLabel(""String_Node_Str"");
    loyaltyCounterLabel.setToolTipText(""String_Node_Str"");
    counterPanel.add(loyaltyCounterLabel);
    otherCounterLabel=new JLabel(""String_Node_Str"");
    counterPanel.add(otherCounterLabel);
    counterPanel.setVisible(false);
  }
  if (newGameCard.isAbility()) {
    if (AbilityType.TRIGGERED.equals(newGameCard.getAbilityType())) {
      setTypeIcon(ImageManagerImpl.getInstance().getTriggeredAbilityImage(),""String_Node_Str"");
    }
 else     if (AbilityType.ACTIVATED.equals(newGameCard.getAbilityType())) {
      setTypeIcon(ImageManagerImpl.getInstance().getActivatedAbilityImage(),""String_Node_Str"");
    }
  }
  if (this.gameCard.isToken()) {
    setTypeIcon(ImageManagerImpl.getInstance().getTokenIconImage(),""String_Node_Str"");
  }
  if (this.gameCard instanceof PermanentView) {
    copyIconPanel=new JPanel();
    copyIconPanel.setLayout(null);
    copyIconPanel.setOpaque(false);
    add(copyIconPanel);
    showCopySourceButton=new JButton(""String_Node_Str"");
    showCopySourceButton.setLocation(2,2);
    showCopySourceButton.setSize(25,25);
    showCopySourceButton.setToolTipText(""String_Node_Str"");
    copyIconPanel.setVisible(((PermanentView)this.gameCard).isCopy());
    showCopySourceButton.setIcon(new ImageIcon(ImageManagerImpl.getInstance().getCopyInformIconImage()));
    copyIconPanel.add(showCopySourceButton);
    showCopySourceButton.addActionListener(new ActionListener(){
      @Override public void actionPerformed(      ActionEvent e){
        ActionCallback callback=Plugins.getInstance().getActionCallback();
        ((MageActionCallback)callback).enlargeCard(EnlargeMode.COPY);
      }
    }
);
  }
  setBackground(Color.black);
  setOpaque(false);
  addMouseListener(this);
  addMouseMotionListener(this);
  addMouseWheelListener(this);
  addComponentListener(this);
  displayTitleAnyway=PreferencesDialog.getCachedValue(PreferencesDialog.KEY_SHOW_CARD_NAMES,""String_Node_Str"").equals(""String_Node_Str"");
  titleText=new GlowText();
  setText(gameCard);
  titleText.setFont(getFont().deriveFont(Font.BOLD,13f));
  titleText.setForeground(Color.white);
  titleText.setGlow(Color.black,TEXT_GLOW_SIZE,TEXT_GLOW_INTENSITY);
  titleText.setWrap(true);
  add(titleText);
  ptText=new GlowText();
  if (CardUtil.isCreature(gameCard)) {
    ptText.setText(gameCard.getPower() + ""String_Node_Str"" + gameCard.getToughness());
  }
 else   if (CardUtil.isPlaneswalker(gameCard)) {
    ptText.setText(gameCard.getLoyalty());
  }
  ptText.setFont(getFont().deriveFont(Font.BOLD,13f));
  ptText.setForeground(Color.white);
  ptText.setGlow(Color.black,TEXT_GLOW_SIZE,TEXT_GLOW_INTENSITY);
  add(ptText);
  BufferedImage sickness=ImageManagerImpl.getInstance().getSicknessImage();
  overlayPanel=new ImagePanel(sickness,ImagePanel.SCALED);
  overlayPanel.setOpaque(false);
  add(overlayPanel);
  imagePanel=new ScaledImagePanel();
  imagePanel.setBorder(BorderFactory.createLineBorder(Color.white));
  add(imagePanel);
  imagePanel.setScaleLarger(true);
  imagePanel.setScalingType(ScalingType.nearestNeighbor);
  imagePanel.setScalingMultiPassType(MultipassType.none);
  String cardType=getType(newGameCard);
  popupText.setText(getText(cardType,newGameCard));
  Util.threadPool.submit(new Runnable(){
    @Override public void run(){
      try {
        tappedAngle=isTapped() ? CardPanel.TAPPED_ANGLE : 0;
        flippedAngle=isFlipped() ? CardPanel.FLIPPED_ANGLE : 0;
        if (!loadImage) {
          return;
        }
        BufferedImage srcImage;
        if (gameCard.isFaceDown()) {
          srcImage=getFaceDownImage();
        }
 else {
          srcImage=ImageCache.getImage(gameCard,getCardWidth(),getCardHeight());
        }
        if (srcImage != null) {
          hasImage=true;
          setText(gameCard);
          setImage(srcImage);
        }
        if (gameCard.isTransformed()) {
          toggleTransformed();
        }
        setText(gameCard);
      }
 catch (      Exception e) {
        e.printStackTrace();
      }
catch (      Error err) {
        err.printStackTrace();
      }
    }
  }
);
}",0.9906021580229724
158983,"@Override public boolean applies(GameEvent event,Ability source,Game game){
  if (event.getTargetId().equals(source.getSourceId())) {
    Permanent sourcePermanent=game.getPermanent(source.getSourceId());
    game.getState().setValue(sourcePermanent.getId().toString() + ""String_Node_Str"",null);
    return true;
  }
  return false;
}","@Override public boolean applies(GameEvent event,Ability source,Game game){
  return event.getTargetId().equals(source.getSourceId());
}",0.5531914893617021
158984,"@Override public boolean replaceEvent(GameEvent event,Ability source,Game game){
  Permanent creature=game.getPermanent(event.getTargetId());
  Player controller=game.getPlayer(creature.getControllerId());
  if (controller != null) {
    for (    String subtype : creature.getSubtype()) {
      filter.add(new SubtypePredicate((subtype)));
    }
    if (controller.getHand().count(filter,source.getSourceId(),source.getControllerId(),game) > 0) {
      if (controller.chooseUse(Outcome.Benefit,""String_Node_Str"",game)) {
        TargetCardInHand target=new TargetCardInHand(0,Integer.MAX_VALUE,filter);
        if (controller.choose(Outcome.Benefit,target,source.getSourceId(),game)) {
          Cards cards=new CardsImpl();
          for (          UUID uuid : target.getTargets()) {
            cards.add(controller.getHand().get(uuid,game));
          }
          int amountCounters=cards.size() * amplifyFactor.getFactor();
          creature.addCounters(CounterType.P1P1.createInstance(amountCounters),game);
          controller.revealCards(""String_Node_Str"",cards,game);
        }
      }
    }
  }
  return false;
}","@Override public boolean replaceEvent(GameEvent event,Ability source,Game game){
  Permanent sourceCreature=game.getPermanent(event.getTargetId());
  Player controller=game.getPlayer(source.getControllerId());
  if (controller != null && sourceCreature != null) {
    FilterCreatureCard filter=new FilterCreatureCard(""String_Node_Str"");
    List<SubtypePredicate> filterSubtypes=new ArrayList<>();
    for (    String subtype : sourceCreature.getSubtype()) {
      filterSubtypes.add(new SubtypePredicate((subtype)));
    }
    filter.add(Predicates.or(filterSubtypes));
    if (controller.getHand().count(filter,source.getSourceId(),source.getControllerId(),game) > 0) {
      if (controller.chooseUse(outcome,""String_Node_Str"",game)) {
        TargetCardInHand target=new TargetCardInHand(0,Integer.MAX_VALUE,filter);
        if (controller.choose(outcome,target,source.getSourceId(),game) && !target.getTargets().isEmpty()) {
          Cards cards=new CardsImpl();
          cards.addAll(target.getTargets());
          int amountCounters=cards.size() * amplifyFactor.getFactor();
          sourceCreature.addCounters(CounterType.P1P1.createInstance(amountCounters),game);
          controller.revealCards(sourceCreature.getLogName(),cards,game);
        }
      }
    }
  }
  return false;
}",0.7907361455748553
158985,"protected boolean checkStateBasedActions(){
  boolean somethingHappened=false;
  for (  Player player : state.getPlayers().values()) {
    if (!player.hasLost() && ((player.getLife() <= 0 && player.canLoseByZeroOrLessLife()) || player.isEmptyDraw() || player.getCounters().getCount(CounterType.POISON) >= 10)) {
      player.lost(this);
    }
  }
  for (  Card card : this.getState().getCopiedCards()) {
    Zone zone=state.getZone(card.getId());
    if (zone != Zone.BATTLEFIELD && zone != Zone.STACK)     state.removeCopiedCard(card);
  }
  List<Permanent> planeswalkers=new ArrayList<>();
  List<Permanent> legendary=new ArrayList<>();
  for (  Permanent perm : getBattlefield().getAllActivePermanents()) {
    if (perm.getCardType().contains(CardType.CREATURE)) {
      if (perm.getToughness().getValue() <= 0) {
        if (movePermanentToGraveyardWithInfo(perm)) {
          somethingHappened=true;
          continue;
        }
      }
 else       if (perm.getToughness().getValue() <= perm.getDamage() || perm.isDeathtouched()) {
        if (perm.destroy(null,this,false)) {
          somethingHappened=true;
          continue;
        }
      }
      if (perm.getPairedCard() != null) {
        Permanent paired=getPermanent(perm.getPairedCard());
        if (paired == null || !perm.getControllerId().equals(paired.getControllerId()) || paired.getPairedCard() == null) {
          perm.setPairedCard(null);
          if (paired != null) {
            paired.setPairedCard(null);
          }
          somethingHappened=true;
        }
      }
    }
 else     if (perm.getPairedCard() != null) {
      Permanent paired=getPermanent(perm.getPairedCard());
      perm.setPairedCard(null);
      if (paired != null) {
        paired.setPairedCard(null);
      }
      somethingHappened=true;
    }
    if (perm.getCardType().contains(CardType.PLANESWALKER)) {
      if (perm.getCounters().getCount(CounterType.LOYALTY) == 0) {
        if (movePermanentToGraveyardWithInfo(perm)) {
          somethingHappened=true;
          continue;
        }
      }
      planeswalkers.add(perm);
    }
    if (filterAura.match(perm,this)) {
      if (perm.getAttachedTo() == null) {
        Card card=this.getCard(perm.getId());
        if (card != null && !card.getCardType().contains(CardType.CREATURE)) {
          if (movePermanentToGraveyardWithInfo(perm)) {
            somethingHappened=true;
          }
        }
      }
 else {
        if (perm.getSpellAbility().getTargets().isEmpty()) {
          Permanent enchanted=this.getPermanent(perm.getAttachedTo());
          logger.error(""String_Node_Str"" + perm.getName() + ""String_Node_Str""+ (enchanted == null ? ""String_Node_Str"" : enchanted.getName()));
        }
 else {
          Target target=perm.getSpellAbility().getTargets().get(0);
          if (target instanceof TargetPermanent) {
            Permanent attachedTo=getPermanent(perm.getAttachedTo());
            if (attachedTo == null || !attachedTo.getAttachments().contains(perm.getId())) {
              Card card=this.getCard(perm.getId());
              if (card != null && card.getCardType().contains(CardType.CREATURE)) {
                UUID wasAttachedTo=perm.getAttachedTo();
                perm.attachTo(null,this);
                fireEvent(new GameEvent(GameEvent.EventType.UNATTACHED,wasAttachedTo,perm.getId(),perm.getControllerId()));
              }
 else {
                if (movePermanentToGraveyardWithInfo(perm)) {
                  somethingHappened=true;
                }
              }
            }
 else {
              Filter auraFilter=perm.getSpellAbility().getTargets().get(0).getFilter();
              if (auraFilter instanceof FilterControlledCreaturePermanent) {
                if (!((FilterControlledCreaturePermanent)auraFilter).match(attachedTo,perm.getId(),perm.getControllerId(),this) || attachedTo.cantBeEnchantedBy(perm,this)) {
                  if (movePermanentToGraveyardWithInfo(perm)) {
                    somethingHappened=true;
                  }
                }
              }
 else {
                if (!auraFilter.match(attachedTo,this) || attachedTo.cantBeEnchantedBy(perm,this)) {
                  Card card=this.getCard(perm.getId());
                  if (card != null && card.getCardType().contains(CardType.CREATURE)) {
                    UUID wasAttachedTo=perm.getAttachedTo();
                    perm.attachTo(null,this);
                    fireEvent(new GameEvent(GameEvent.EventType.UNATTACHED,wasAttachedTo,perm.getId(),perm.getControllerId()));
                  }
 else {
                    if (movePermanentToGraveyardWithInfo(perm)) {
                      somethingHappened=true;
                    }
                  }
                }
              }
            }
          }
 else           if (target instanceof TargetPlayer) {
            Player attachedToPlayer=getPlayer(perm.getAttachedTo());
            if (attachedToPlayer == null) {
              if (movePermanentToGraveyardWithInfo(perm)) {
                somethingHappened=true;
              }
            }
 else {
              Filter auraFilter=perm.getSpellAbility().getTargets().get(0).getFilter();
              if (!auraFilter.match(attachedToPlayer,this) || attachedToPlayer.hasProtectionFrom(perm,this)) {
                if (movePermanentToGraveyardWithInfo(perm)) {
                  somethingHappened=true;
                }
              }
            }
          }
        }
      }
    }
    if (this.getState().isLegendaryRuleActive() && filterLegendary.match(perm,this)) {
      legendary.add(perm);
    }
    if (filterEquipment.match(perm,this)) {
      if (perm.getAttachedTo() != null) {
        Permanent creature=getPermanent(perm.getAttachedTo());
        if (creature == null || !creature.getAttachments().contains(perm.getId())) {
          UUID wasAttachedTo=perm.getAttachedTo();
          perm.attachTo(null,this);
          fireEvent(new GameEvent(GameEvent.EventType.UNATTACHED,wasAttachedTo,perm.getId(),perm.getControllerId()));
        }
 else         if (!creature.getCardType().contains(CardType.CREATURE) || creature.hasProtectionFrom(perm,this)) {
          if (creature.removeAttachment(perm.getId(),this)) {
            somethingHappened=true;
          }
        }
      }
    }
    if (filterFortification.match(perm,this)) {
      if (perm.getAttachedTo() != null) {
        Permanent land=getPermanent(perm.getAttachedTo());
        if (land == null || !land.getAttachments().contains(perm.getId())) {
          perm.attachTo(null,this);
        }
 else         if (!land.getCardType().contains(CardType.LAND) || land.hasProtectionFrom(perm,this)) {
          if (land.removeAttachment(perm.getId(),this)) {
            somethingHappened=true;
          }
        }
      }
    }
    if (perm.getAttachments().size() > 0) {
      for (      UUID attachmentId : perm.getAttachments()) {
        Permanent attachment=getPermanent(attachmentId);
        if (attachment != null && (attachment.getCardType().contains(CardType.CREATURE) || !(attachment.getSubtype().contains(""String_Node_Str"") || attachment.getSubtype().contains(""String_Node_Str"") || attachment.getSubtype().contains(""String_Node_Str"")))) {
          if (perm.removeAttachment(attachment.getId(),this)) {
            somethingHappened=true;
            break;
          }
        }
      }
    }
    if (perm.getCounters().containsKey(CounterType.P1P1) && perm.getCounters().containsKey(CounterType.M1M1)) {
      int p1p1=perm.getCounters().getCount(CounterType.P1P1);
      int m1m1=perm.getCounters().getCount(CounterType.M1M1);
      int min=Math.min(p1p1,m1m1);
      perm.getCounters().removeCounter(CounterType.P1P1,min);
      perm.getCounters().removeCounter(CounterType.M1M1,min);
    }
  }
  if (planeswalkers.size() > 1) {
    for (    Permanent planeswalker : planeswalkers) {
      for (      String planeswalkertype : planeswalker.getSubtype()) {
        FilterPlaneswalkerPermanent filterPlaneswalker=new FilterPlaneswalkerPermanent();
        filterPlaneswalker.add(new SubtypePredicate(planeswalkertype));
        filterPlaneswalker.add(new ControllerIdPredicate(planeswalker.getControllerId()));
        if (getBattlefield().contains(filterPlaneswalker,planeswalker.getControllerId(),this,2)) {
          Player controller=this.getPlayer(planeswalker.getControllerId());
          if (controller != null) {
            Target targetPlaneswalkerToKeep=new TargetPermanent(filterPlaneswalker);
            targetPlaneswalkerToKeep.setTargetName(new StringBuilder(planeswalker.getName()).append(""String_Node_Str"").toString());
            controller.chooseTarget(Outcome.Benefit,targetPlaneswalkerToKeep,null,this);
            for (            Permanent dupPlaneswalker : this.getBattlefield().getActivePermanents(filterPlaneswalker,planeswalker.getControllerId(),this)) {
              if (!targetPlaneswalkerToKeep.getTargets().contains(dupPlaneswalker.getId())) {
                movePermanentToGraveyardWithInfo(dupPlaneswalker);
              }
            }
          }
          return true;
        }
      }
    }
  }
  if (legendary.size() > 1) {
    for (    Permanent legend : legendary) {
      FilterPermanent filterLegendName=new FilterPermanent();
      filterLegendName.add(new SupertypePredicate(""String_Node_Str""));
      filterLegendName.add(new NamePredicate(legend.getName()));
      filterLegendName.add(new ControllerIdPredicate(legend.getControllerId()));
      if (getBattlefield().contains(filterLegendName,legend.getControllerId(),this,2)) {
        Player controller=this.getPlayer(legend.getControllerId());
        if (controller != null) {
          Target targetLegendaryToKeep=new TargetPermanent(filterLegendName);
          targetLegendaryToKeep.setTargetName(new StringBuilder(legend.getName()).append(""String_Node_Str"").toString());
          controller.chooseTarget(Outcome.Benefit,targetLegendaryToKeep,null,this);
          for (          Permanent dupLegend : getBattlefield().getActivePermanents(filterLegendName,legend.getControllerId(),this)) {
            if (!targetLegendaryToKeep.getTargets().contains(dupLegend.getId())) {
              movePermanentToGraveyardWithInfo(dupLegend);
            }
          }
        }
        return true;
      }
    }
  }
  return somethingHappened;
}","protected boolean checkStateBasedActions(){
  boolean somethingHappened=false;
  for (  Player player : state.getPlayers().values()) {
    if (!player.hasLost() && ((player.getLife() <= 0 && player.canLoseByZeroOrLessLife()) || player.isEmptyDraw() || player.getCounters().getCount(CounterType.POISON) >= 10)) {
      player.lost(this);
    }
  }
  Iterator<Card> copiedCards=this.getState().getCopiedCards().iterator();
  while (copiedCards.hasNext()) {
    Card card=copiedCards.next();
    Zone zone=state.getZone(card.getId());
    if (zone != Zone.BATTLEFIELD && zone != Zone.STACK) {
      copiedCards.remove();
    }
  }
  List<Permanent> planeswalkers=new ArrayList<>();
  List<Permanent> legendary=new ArrayList<>();
  for (  Permanent perm : getBattlefield().getAllActivePermanents()) {
    if (perm.getCardType().contains(CardType.CREATURE)) {
      if (perm.getToughness().getValue() <= 0) {
        if (movePermanentToGraveyardWithInfo(perm)) {
          somethingHappened=true;
          continue;
        }
      }
 else       if (perm.getToughness().getValue() <= perm.getDamage() || perm.isDeathtouched()) {
        if (perm.destroy(null,this,false)) {
          somethingHappened=true;
          continue;
        }
      }
      if (perm.getPairedCard() != null) {
        Permanent paired=getPermanent(perm.getPairedCard());
        if (paired == null || !perm.getControllerId().equals(paired.getControllerId()) || paired.getPairedCard() == null) {
          perm.setPairedCard(null);
          if (paired != null) {
            paired.setPairedCard(null);
          }
          somethingHappened=true;
        }
      }
    }
 else     if (perm.getPairedCard() != null) {
      Permanent paired=getPermanent(perm.getPairedCard());
      perm.setPairedCard(null);
      if (paired != null) {
        paired.setPairedCard(null);
      }
      somethingHappened=true;
    }
    if (perm.getCardType().contains(CardType.PLANESWALKER)) {
      if (perm.getCounters().getCount(CounterType.LOYALTY) == 0) {
        if (movePermanentToGraveyardWithInfo(perm)) {
          somethingHappened=true;
          continue;
        }
      }
      planeswalkers.add(perm);
    }
    if (filterAura.match(perm,this)) {
      if (perm.getAttachedTo() == null) {
        Card card=this.getCard(perm.getId());
        if (card != null && !card.getCardType().contains(CardType.CREATURE)) {
          if (movePermanentToGraveyardWithInfo(perm)) {
            somethingHappened=true;
          }
        }
      }
 else {
        if (perm.getSpellAbility().getTargets().isEmpty()) {
          Permanent enchanted=this.getPermanent(perm.getAttachedTo());
          logger.error(""String_Node_Str"" + perm.getName() + ""String_Node_Str""+ (enchanted == null ? ""String_Node_Str"" : enchanted.getName()));
        }
 else {
          Target target=perm.getSpellAbility().getTargets().get(0);
          if (target instanceof TargetPermanent) {
            Permanent attachedTo=getPermanent(perm.getAttachedTo());
            if (attachedTo == null || !attachedTo.getAttachments().contains(perm.getId())) {
              Card card=this.getCard(perm.getId());
              if (card != null && card.getCardType().contains(CardType.CREATURE)) {
                UUID wasAttachedTo=perm.getAttachedTo();
                perm.attachTo(null,this);
                fireEvent(new GameEvent(GameEvent.EventType.UNATTACHED,wasAttachedTo,perm.getId(),perm.getControllerId()));
              }
 else {
                if (movePermanentToGraveyardWithInfo(perm)) {
                  somethingHappened=true;
                }
              }
            }
 else {
              Filter auraFilter=perm.getSpellAbility().getTargets().get(0).getFilter();
              if (auraFilter instanceof FilterControlledCreaturePermanent) {
                if (!((FilterControlledCreaturePermanent)auraFilter).match(attachedTo,perm.getId(),perm.getControllerId(),this) || attachedTo.cantBeEnchantedBy(perm,this)) {
                  if (movePermanentToGraveyardWithInfo(perm)) {
                    somethingHappened=true;
                  }
                }
              }
 else {
                if (!auraFilter.match(attachedTo,this) || attachedTo.cantBeEnchantedBy(perm,this)) {
                  Card card=this.getCard(perm.getId());
                  if (card != null && card.getCardType().contains(CardType.CREATURE)) {
                    UUID wasAttachedTo=perm.getAttachedTo();
                    perm.attachTo(null,this);
                    fireEvent(new GameEvent(GameEvent.EventType.UNATTACHED,wasAttachedTo,perm.getId(),perm.getControllerId()));
                  }
 else {
                    if (movePermanentToGraveyardWithInfo(perm)) {
                      somethingHappened=true;
                    }
                  }
                }
              }
            }
          }
 else           if (target instanceof TargetPlayer) {
            Player attachedToPlayer=getPlayer(perm.getAttachedTo());
            if (attachedToPlayer == null) {
              if (movePermanentToGraveyardWithInfo(perm)) {
                somethingHappened=true;
              }
            }
 else {
              Filter auraFilter=perm.getSpellAbility().getTargets().get(0).getFilter();
              if (!auraFilter.match(attachedToPlayer,this) || attachedToPlayer.hasProtectionFrom(perm,this)) {
                if (movePermanentToGraveyardWithInfo(perm)) {
                  somethingHappened=true;
                }
              }
            }
          }
        }
      }
    }
    if (this.getState().isLegendaryRuleActive() && filterLegendary.match(perm,this)) {
      legendary.add(perm);
    }
    if (filterEquipment.match(perm,this)) {
      if (perm.getAttachedTo() != null) {
        Permanent creature=getPermanent(perm.getAttachedTo());
        if (creature == null || !creature.getAttachments().contains(perm.getId())) {
          UUID wasAttachedTo=perm.getAttachedTo();
          perm.attachTo(null,this);
          fireEvent(new GameEvent(GameEvent.EventType.UNATTACHED,wasAttachedTo,perm.getId(),perm.getControllerId()));
        }
 else         if (!creature.getCardType().contains(CardType.CREATURE) || creature.hasProtectionFrom(perm,this)) {
          if (creature.removeAttachment(perm.getId(),this)) {
            somethingHappened=true;
          }
        }
      }
    }
    if (filterFortification.match(perm,this)) {
      if (perm.getAttachedTo() != null) {
        Permanent land=getPermanent(perm.getAttachedTo());
        if (land == null || !land.getAttachments().contains(perm.getId())) {
          perm.attachTo(null,this);
        }
 else         if (!land.getCardType().contains(CardType.LAND) || land.hasProtectionFrom(perm,this)) {
          if (land.removeAttachment(perm.getId(),this)) {
            somethingHappened=true;
          }
        }
      }
    }
    if (perm.getAttachments().size() > 0) {
      for (      UUID attachmentId : perm.getAttachments()) {
        Permanent attachment=getPermanent(attachmentId);
        if (attachment != null && (attachment.getCardType().contains(CardType.CREATURE) || !(attachment.getSubtype().contains(""String_Node_Str"") || attachment.getSubtype().contains(""String_Node_Str"") || attachment.getSubtype().contains(""String_Node_Str"")))) {
          if (perm.removeAttachment(attachment.getId(),this)) {
            somethingHappened=true;
            break;
          }
        }
      }
    }
    if (perm.getCounters().containsKey(CounterType.P1P1) && perm.getCounters().containsKey(CounterType.M1M1)) {
      int p1p1=perm.getCounters().getCount(CounterType.P1P1);
      int m1m1=perm.getCounters().getCount(CounterType.M1M1);
      int min=Math.min(p1p1,m1m1);
      perm.getCounters().removeCounter(CounterType.P1P1,min);
      perm.getCounters().removeCounter(CounterType.M1M1,min);
    }
  }
  if (planeswalkers.size() > 1) {
    for (    Permanent planeswalker : planeswalkers) {
      for (      String planeswalkertype : planeswalker.getSubtype()) {
        FilterPlaneswalkerPermanent filterPlaneswalker=new FilterPlaneswalkerPermanent();
        filterPlaneswalker.add(new SubtypePredicate(planeswalkertype));
        filterPlaneswalker.add(new ControllerIdPredicate(planeswalker.getControllerId()));
        if (getBattlefield().contains(filterPlaneswalker,planeswalker.getControllerId(),this,2)) {
          Player controller=this.getPlayer(planeswalker.getControllerId());
          if (controller != null) {
            Target targetPlaneswalkerToKeep=new TargetPermanent(filterPlaneswalker);
            targetPlaneswalkerToKeep.setTargetName(new StringBuilder(planeswalker.getName()).append(""String_Node_Str"").toString());
            controller.chooseTarget(Outcome.Benefit,targetPlaneswalkerToKeep,null,this);
            for (            Permanent dupPlaneswalker : this.getBattlefield().getActivePermanents(filterPlaneswalker,planeswalker.getControllerId(),this)) {
              if (!targetPlaneswalkerToKeep.getTargets().contains(dupPlaneswalker.getId())) {
                movePermanentToGraveyardWithInfo(dupPlaneswalker);
              }
            }
          }
          return true;
        }
      }
    }
  }
  if (legendary.size() > 1) {
    for (    Permanent legend : legendary) {
      FilterPermanent filterLegendName=new FilterPermanent();
      filterLegendName.add(new SupertypePredicate(""String_Node_Str""));
      filterLegendName.add(new NamePredicate(legend.getName()));
      filterLegendName.add(new ControllerIdPredicate(legend.getControllerId()));
      if (getBattlefield().contains(filterLegendName,legend.getControllerId(),this,2)) {
        Player controller=this.getPlayer(legend.getControllerId());
        if (controller != null) {
          Target targetLegendaryToKeep=new TargetPermanent(filterLegendName);
          targetLegendaryToKeep.setTargetName(new StringBuilder(legend.getName()).append(""String_Node_Str"").toString());
          controller.chooseTarget(Outcome.Benefit,targetLegendaryToKeep,null,this);
          for (          Permanent dupLegend : getBattlefield().getActivePermanents(filterLegendName,legend.getControllerId(),this)) {
            if (!targetLegendaryToKeep.getTargets().contains(dupLegend.getId())) {
              movePermanentToGraveyardWithInfo(dupLegend);
            }
          }
        }
        return true;
      }
    }
  }
  return somethingHappened;
}",0.9920462762111352
158986,"@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  MageObject sourceObject=game.getObject(source.getSourceId());
  if (controller != null) {
    Player targetPlayer=game.getPlayer(getTargetPointer().getFirst(game,source));
    if (targetPlayer != null) {
      if (targetPlayer.getHand().size() > 0) {
        Cards cards=new CardsImpl();
        Card card=targetPlayer.getHand().getRandom(game);
        cards.add(card);
        if (targetPlayer.getHand().size() > 1) {
          do {
            card=targetPlayer.getHand().getRandom(game);
          }
 while (cards.contains(card.getId()));
          cards.add(card);
        }
        targetPlayer.revealCards(sourceObject.getLogName(),cards,game);
        for (        Card cardToDiscard : cards.getCards(game)) {
          if (!card.getCardType().contains(CardType.LAND)) {
            targetPlayer.discard(cardToDiscard,source,game);
          }
        }
      }
    }
    return true;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Player controller=game.getPlayer(source.getControllerId());
  MageObject sourceObject=game.getObject(source.getSourceId());
  if (controller != null) {
    Player targetPlayer=game.getPlayer(getTargetPointer().getFirst(game,source));
    if (targetPlayer != null) {
      if (targetPlayer.getHand().size() > 0) {
        Cards cards=new CardsImpl();
        Card card=targetPlayer.getHand().getRandom(game);
        cards.add(card);
        if (targetPlayer.getHand().size() > 1) {
          do {
            card=targetPlayer.getHand().getRandom(game);
          }
 while (cards.contains(card.getId()));
          cards.add(card);
        }
        targetPlayer.revealCards(sourceObject.getLogName(),cards,game);
        for (        Card cardToDiscard : cards.getCards(game)) {
          if (!cardToDiscard.getCardType().contains(CardType.LAND)) {
            targetPlayer.discard(cardToDiscard,source,game);
          }
        }
      }
    }
    return true;
  }
  return false;
}",0.995675156174916
158987,"@Override public boolean apply(Game game,Ability source){
  Player player=game.getPlayer(targetPointer.getFirst(game,source));
  if (player == null) {
    return false;
  }
  filter.add(new ControllerPredicate(TargetController.YOU));
  int amount=count.calculate(game,source,this);
  int realCount=game.getBattlefield().countAll(filter,player.getId(),game);
  amount=Math.min(amount,realCount);
  Target target=new TargetPermanent(amount,amount,filter,true);
  if (amount > 0 && target.canChoose(source.getSourceId(),player.getId(),game)) {
    boolean abilityApplied=false;
    while (!target.isChosen() && target.canChoose(player.getId(),game) && player.isInGame()) {
      player.chooseTarget(Outcome.Sacrifice,target,source,game);
    }
    for (int idx=0; idx < target.getTargets().size(); idx++) {
      Permanent permanent=game.getPermanent(target.getTargets().get(idx));
      if (permanent != null) {
        abilityApplied|=permanent.sacrifice(source.getSourceId(),game);
      }
    }
    return abilityApplied;
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Player player=game.getPlayer(targetPointer.getFirst(game,source));
  if (player == null) {
    return false;
  }
  FilterPermanent newFilter=filter.copy();
  newFilter.add(new ControllerIdPredicate(player.getId()));
  int amount=count.calculate(game,source,this);
  int realCount=game.getBattlefield().countAll(newFilter,player.getId(),game);
  amount=Math.min(amount,realCount);
  Target target=new TargetPermanent(amount,amount,newFilter,true);
  if (amount > 0 && target.canChoose(source.getSourceId(),player.getId(),game)) {
    boolean abilityApplied=false;
    while (!target.isChosen() && target.canChoose(player.getId(),game) && player.isInGame()) {
      player.chooseTarget(Outcome.Sacrifice,target,source,game);
    }
    for (int idx=0; idx < target.getTargets().size(); idx++) {
      Permanent permanent=game.getPermanent(target.getTargets().get(idx));
      if (permanent != null) {
        abilityApplied|=permanent.sacrifice(source.getSourceId(),game);
      }
    }
    return abilityApplied;
  }
  return false;
}",0.7677902621722846
158988,"@Override public boolean apply(Game game,Ability source){
  Permanent permanent=game.getPermanent(source.getSourceId());
  if (permanent != null) {
    Permanent attach=game.getPermanent(permanent.getAttachedTo());
    if (attach != null) {
      attach.tap(game);
      return true;
    }
  }
  return false;
}","@Override public boolean apply(Game game,Ability source){
  Permanent permanent=(Permanent)source.getSourceObject(game);
  if (permanent != null) {
    Permanent attach=game.getPermanent(permanent.getAttachedTo());
    if (attach != null) {
      attach.tap(game);
      return true;
    }
  }
  return false;
}",0.9131832797427653
158989,"@Override public boolean replaceEvent(GameEvent event,Ability source,Game game){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller != null) {
    Card card=game.getCard(getTargetPointer().getFirst(game,source));
    if (card != null) {
      controller.moveCardToGraveyardWithInfo(card,source.getSourceId(),game,Zone.STACK);
      return true;
    }
  }
  return false;
}","@Override public boolean replaceEvent(GameEvent event,Ability source,Game game){
  Player controller=game.getPlayer(source.getControllerId());
  if (controller != null) {
    Card card=game.getCard(getTargetPointer().getFirst(game,source));
    if (card != null) {
      controller.moveCardToExileWithInfo(card,null,""String_Node_Str"",source.getSourceId(),game,Zone.STACK);
      return true;
    }
  }
  return false;
}",0.9548229548229548
158990,"@Override public boolean applies(GameEvent event,Ability source,Game game){
  Spell spell=game.getStack().getSpell(event.getTargetId());
  if (spell != null && spell.getControllerId().equals(source.getControllerId()) && filterTarget.match(spell,game)) {
    if (filterSource == null) {
      return true;
    }
 else {
      MageObject sourceObject=game.getObject(source.getSourceId());
      if (sourceObject != null && filterSource.match(sourceObject,game)) {
        return true;
      }
    }
  }
  return false;
}","@Override public boolean applies(GameEvent event,Ability source,Game game){
  Spell spell=game.getStack().getSpell(event.getTargetId());
  if (spell != null && spell.getControllerId().equals(source.getControllerId()) && filterTarget.match(spell,source.getControllerId(),game)) {
    if (filterSource == null) {
      return true;
    }
 else {
      MageObject sourceObject=game.getObject(event.getSourceId());
      if (sourceObject != null && filterSource.match(sourceObject,game)) {
        return true;
      }
    }
  }
  return false;
}",0.9660377358490566
158991,"public CavernOfSoulsWatcher(final CavernOfSoulsWatcher watcher){
  super(watcher);
}","public CavernOfSoulsWatcher(final CavernOfSoulsWatcher watcher){
  super(watcher);
  this.spells.addAll(watcher.spells);
}",0.8155339805825242
158992,"@Override public boolean applies(GameEvent event,Ability source,Game game){
  if (event.getType() == GameEvent.EventType.COUNTER) {
    CavernOfSoulsWatcher watcher=(CavernOfSoulsWatcher)game.getState().getWatchers().get(""String_Node_Str"");
    Spell spell=game.getStack().getSpell(event.getTargetId());
    if (spell != null && watcher.spells.contains(spell.getId())) {
      return true;
    }
  }
  return false;
}","@Override public boolean applies(GameEvent event,Ability source,Game game){
  CavernOfSoulsWatcher watcher=(CavernOfSoulsWatcher)game.getState().getWatchers().get(""String_Node_Str"");
  Spell spell=game.getStack().getSpell(event.getTargetId());
  return spell != null && watcher.spells.contains(spell.getId());
}",0.8351648351648352
158993,"@Override public PredatoryRampageEffect copy(){
  return new PredatoryRampageEffect(this);
}","@Override public PredatoryRampage copy(){
  return new PredatoryRampage(this);
}",0.9302325581395348
158994,"/** 
 * Retrieves all requirements that apply and creates a Map with blockers and attackers // Map<creature that can block, Set< all attackers the creature can block and force it to block the attacker>>
 * @param attackingPlayer - attacker
 * @param game 
 */
private void retrieveMustBlockAttackerRequirements(Player attackingPlayer,Game game){
  if (!game.getContinuousEffects().existRequirementEffects()) {
    return;
  }
  for (  Permanent possibleBlocker : game.getBattlefield().getActivePermanents(filterBlockers,attackingPlayer.getId(),game)) {
    for (    Map.Entry<RequirementEffect,HashSet<Ability>> requirementEntry : game.getContinuousEffects().getApplicableRequirementEffects(possibleBlocker,game).entrySet()) {
      if (requirementEntry.getKey().mustBlock(game)) {
        for (        Ability ability : requirementEntry.getValue()) {
          UUID attackingCreatureId=requirementEntry.getKey().mustBlockAttacker(ability,game);
          Player defender=game.getPlayer(possibleBlocker.getControllerId());
          if (attackingCreatureId != null && defender != null) {
            if (creatureMustBlockAttackers.containsKey(possibleBlocker.getId())) {
              creatureMustBlockAttackers.get(possibleBlocker.getId()).add(attackingCreatureId);
            }
 else {
              Set<UUID> forcingAttackers=new HashSet<>();
              forcingAttackers.add(attackingCreatureId);
              creatureMustBlockAttackers.put(possibleBlocker.getId(),forcingAttackers);
              defender.declareBlocker(defender.getId(),possibleBlocker.getId(),attackingCreatureId,game);
            }
          }
        }
      }
    }
  }
}","/** 
 * Retrieves all requirements that apply and creates a Map with blockers and attackers it contains only records if attackers can be retrieved // Map<creature that can block, Set< all attackers the creature can block and force it to block the attacker>>
 * @param attackingPlayer - attacker
 * @param game 
 */
private void retrieveMustBlockAttackerRequirements(Player attackingPlayer,Game game){
  if (!game.getContinuousEffects().existRequirementEffects()) {
    return;
  }
  for (  Permanent possibleBlocker : game.getBattlefield().getActivePermanents(filterBlockers,attackingPlayer.getId(),game)) {
    for (    Map.Entry<RequirementEffect,HashSet<Ability>> requirementEntry : game.getContinuousEffects().getApplicableRequirementEffects(possibleBlocker,game).entrySet()) {
      if (requirementEntry.getKey().mustBlock(game)) {
        for (        Ability ability : requirementEntry.getValue()) {
          UUID attackingCreatureId=requirementEntry.getKey().mustBlockAttacker(ability,game);
          Player defender=game.getPlayer(possibleBlocker.getControllerId());
          if (attackingCreatureId != null && defender != null) {
            if (creatureMustBlockAttackers.containsKey(possibleBlocker.getId())) {
              creatureMustBlockAttackers.get(possibleBlocker.getId()).add(attackingCreatureId);
            }
 else {
              Set<UUID> forcingAttackers=new HashSet<>();
              forcingAttackers.add(attackingCreatureId);
              creatureMustBlockAttackers.put(possibleBlocker.getId(),forcingAttackers);
              defender.declareBlocker(defender.getId(),possibleBlocker.getId(),attackingCreatureId,game);
            }
          }
        }
      }
    }
  }
}",0.9836358226718238
158995,"/** 
 * 509.1c The defending player checks each creature he or she controls to see whether it's affected by any requirements (effects that say a creature must block, or that it must block if some condition is met). If the number of requirements that are being obeyed is fewer than the maximum possible number of requirements that could be obeyed without disobeying any restrictions, the declaration of blockers is illegal. If a creature can't block unless a player pays a cost, that player is not required to pay that cost, even if blocking with that creature would increase the number of requirements being obeyed. Example: A player controls one creature that ""blocks if able"" and another creature with no abilities. An effect states ""Creatures can't be blocked except by two or more creatures."" Having only the first creature block violates the restriction. Having neither creature block fulfills the restriction but not the requirement. Having both creatures block the same attacking creature fulfills both the restriction and the requirement, so that's the only option.
 * @param player
 * @param controller
 * @param game
 * @return
 */
public boolean checkBlockRequirementsAfter(Player player,Player controller,Game game){
  Set<UUID> opponents=game.getOpponents(attackerId);
  Map<UUID,Set<UUID>> mustBeBlockedByAtLeastOne=new HashMap<>();
  for (  Permanent creature : game.getBattlefield().getActivePermanents(new FilterControlledCreaturePermanent(),player.getId(),game)) {
    if (opponents.contains(creature.getControllerId())) {
      if (creature.getBlocking() > 0) {
        for (        Map.Entry<RequirementEffect,HashSet<Ability>> entry : game.getContinuousEffects().getApplicableRequirementEffects(creature,game).entrySet()) {
          RequirementEffect effect=entry.getKey();
          for (          Ability ability : entry.getValue()) {
            UUID toBeBlockedCreature=effect.mustBlockAttackerIfElseUnblocked(ability,game);
            if (toBeBlockedCreature != null) {
              Set<UUID> potentialBlockers;
              if (mustBeBlockedByAtLeastOne.containsKey(toBeBlockedCreature)) {
                potentialBlockers=mustBeBlockedByAtLeastOne.get(toBeBlockedCreature);
              }
 else {
                potentialBlockers=new HashSet<>();
                mustBeBlockedByAtLeastOne.put(toBeBlockedCreature,potentialBlockers);
              }
              potentialBlockers.add(creature.getId());
            }
          }
        }
      }
      if (creature.getBlocking() == 0) {
        for (        Map.Entry<RequirementEffect,HashSet<Ability>> entry : game.getContinuousEffects().getApplicableRequirementEffects(creature,game).entrySet()) {
          RequirementEffect effect=entry.getKey();
          for (          Ability ability : entry.getValue()) {
            UUID toBeBlockedCreature=effect.mustBlockAttackerIfElseUnblocked(ability,game);
            if (toBeBlockedCreature != null) {
              Set<UUID> potentialBlockers;
              if (mustBeBlockedByAtLeastOne.containsKey(toBeBlockedCreature)) {
                potentialBlockers=mustBeBlockedByAtLeastOne.get(toBeBlockedCreature);
              }
 else {
                potentialBlockers=new HashSet<>();
                mustBeBlockedByAtLeastOne.put(toBeBlockedCreature,potentialBlockers);
              }
              potentialBlockers.add(creature.getId());
            }
          }
          if (effect.mustBlockAny(game)) {
            boolean mayBlock=false;
            for (            UUID attackingCreatureId : getAttackers()) {
              if (creature.canBlock(attackingCreatureId,game)) {
                Permanent attackingCreature=game.getPermanent(attackingCreatureId);
                if (attackingCreature != null && attackingCreature.getMinBlockedBy() > 1) {
                }
 else {
                  mayBlock=true;
                  break;
                }
              }
            }
            if (mayBlock) {
              if (controller.isHuman()) {
                game.informPlayer(controller,""String_Node_Str"" + creature.getLogName());
              }
 else {
                Player defender=game.getPlayer(creature.getControllerId());
                if (defender != null) {
                  for (                  UUID attackingCreatureId : getAttackers()) {
                    if (creature.canBlock(attackingCreatureId,game)) {
                      defender.declareBlocker(defender.getId(),creature.getId(),attackingCreatureId,game);
                      break;
                    }
                  }
                }
              }
              return false;
            }
          }
        }
      }
    }
  }
  for (  UUID toBeBlockedCreatureId : mustBeBlockedByAtLeastOne.keySet()) {
    for (    CombatGroup combatGroup : game.getCombat().getGroups()) {
      if (combatGroup.getBlockers().isEmpty() && combatGroup.getAttackers().contains(toBeBlockedCreatureId)) {
        if (controller.isHuman()) {
          Permanent toBeBlockedCreature=game.getPermanent(toBeBlockedCreatureId);
          if (toBeBlockedCreature != null) {
            boolean possibleBlockerAvailable=false;
            for (            UUID possibleBlockerId : mustBeBlockedByAtLeastOne.get(toBeBlockedCreatureId)) {
              Set<UUID> forcingAttackers=creatureMustBlockAttackers.get(possibleBlockerId);
              if (forcingAttackers == null) {
                possibleBlockerAvailable=true;
                break;
              }
              List<UUID> blockedAttackers=null;
              for (              CombatGroup combatGroupToCheck : game.getCombat().getGroups()) {
                if (combatGroupToCheck.getBlockers().contains(possibleBlockerId)) {
                  blockedAttackers=combatGroupToCheck.getAttackers();
                  break;
                }
              }
              if (blockedAttackers == null) {
                possibleBlockerAvailable=true;
                break;
              }
              possibleBlockerAvailable=true;
              for (              UUID blockedAttackerId : blockedAttackers) {
                if (creatureMustBlockAttackers.get(possibleBlockerId).contains(blockedAttackerId)) {
                  possibleBlockerAvailable=false;
                  break;
                }
              }
              if (possibleBlockerAvailable) {
                break;
              }
            }
            if (possibleBlockerAvailable) {
              game.informPlayer(controller,new StringBuilder(toBeBlockedCreature.getLogName()).append(""String_Node_Str"").toString());
              return false;
            }
          }
        }
 else {
          UUID blockingCreatureId=mustBeBlockedByAtLeastOne.get(toBeBlockedCreatureId).iterator().next();
          Permanent blockingCreature=game.getPermanent(blockingCreatureId);
          if (blockingCreature != null) {
            Player defender=game.getPlayer(blockingCreature.getControllerId());
            if (defender != null) {
              defender.declareBlocker(defender.getId(),blockingCreatureId,toBeBlockedCreatureId,game);
            }
          }
        }
      }
    }
  }
  StringBuilder sb=new StringBuilder();
  for (  Map.Entry<UUID,Set<UUID>> entry : creatureMustBlockAttackers.entrySet()) {
    boolean blockIsValid;
    Permanent creatureForcedToBlock=game.getPermanent(entry.getKey());
    if (creatureForcedToBlock == null) {
      break;
    }
    if (creatureForcedToBlock.getBlocking() == 0) {
      blockIsValid=false;
    }
 else {
      blockIsValid=false;
      CombatGroups:       for (      CombatGroup combatGroup : game.getCombat().getGroups()) {
        if (combatGroup.getBlockers().contains(creatureForcedToBlock.getId())) {
          for (          UUID forcingAttackerId : combatGroup.getAttackers()) {
            if (entry.getValue().contains(forcingAttackerId)) {
              blockIsValid=true;
              break CombatGroups;
            }
 else {
              if (combatGroup.getBlockers().size() == 1) {
                if (mustBeBlockedByAtLeastOne.containsKey(forcingAttackerId)) {
                  if (mustBeBlockedByAtLeastOne.get(forcingAttackerId).contains(creatureForcedToBlock.getId())) {
                    blockIsValid=true;
                    break CombatGroups;
                  }
                }
              }
            }
          }
        }
      }
    }
    if (!blockIsValid) {
      sb.append(""String_Node_Str"").append(creatureForcedToBlock.getLogName());
    }
  }
  if (sb.length() > 0) {
    sb.insert(0,""String_Node_Str"");
    sb.append(""String_Node_Str"");
    game.informPlayer(controller,sb.toString());
    return false;
  }
  return true;
}","/** 
 * 509.1c The defending player checks each creature he or she controls to see whether it's affected by any requirements (effects that say a creature must block, or that it must block if some condition is met). If the number of requirements that are being obeyed is fewer than the maximum possible number of requirements that could be obeyed without disobeying any restrictions, the declaration of blockers is illegal. If a creature can't block unless a player pays a cost, that player is not required to pay that cost, even if blocking with that creature would increase the number of requirements being obeyed. Example: A player controls one creature that ""blocks if able"" and another creature with no abilities. An effect states ""Creatures can't be blocked except by two or more creatures."" Having only the first creature block violates the restriction. Having neither creature block fulfills the restriction but not the requirement. Having both creatures block the same attacking creature fulfills both the restriction and the requirement, so that's the only option.
 * @param player
 * @param controller
 * @param game
 * @return
 */
public boolean checkBlockRequirementsAfter(Player player,Player controller,Game game){
  Set<UUID> opponents=game.getOpponents(attackerId);
  Map<UUID,Set<UUID>> mustBeBlockedByAtLeastOne=new HashMap<>();
  for (  Permanent creature : game.getBattlefield().getActivePermanents(new FilterControlledCreaturePermanent(),player.getId(),game)) {
    if (opponents.contains(creature.getControllerId())) {
      if (creature.getBlocking() > 0) {
        for (        Map.Entry<RequirementEffect,HashSet<Ability>> entry : game.getContinuousEffects().getApplicableRequirementEffects(creature,game).entrySet()) {
          RequirementEffect effect=entry.getKey();
          for (          Ability ability : entry.getValue()) {
            UUID toBeBlockedCreature=effect.mustBlockAttackerIfElseUnblocked(ability,game);
            if (toBeBlockedCreature != null) {
              Set<UUID> potentialBlockers;
              if (mustBeBlockedByAtLeastOne.containsKey(toBeBlockedCreature)) {
                potentialBlockers=mustBeBlockedByAtLeastOne.get(toBeBlockedCreature);
              }
 else {
                potentialBlockers=new HashSet<>();
                mustBeBlockedByAtLeastOne.put(toBeBlockedCreature,potentialBlockers);
              }
              potentialBlockers.add(creature.getId());
            }
          }
        }
      }
      if (creature.getBlocking() == 0) {
        for (        Map.Entry<RequirementEffect,HashSet<Ability>> entry : game.getContinuousEffects().getApplicableRequirementEffects(creature,game).entrySet()) {
          RequirementEffect effect=entry.getKey();
          for (          Ability ability : entry.getValue()) {
            UUID toBeBlockedCreature=effect.mustBlockAttackerIfElseUnblocked(ability,game);
            if (toBeBlockedCreature != null) {
              Set<UUID> potentialBlockers;
              if (mustBeBlockedByAtLeastOne.containsKey(toBeBlockedCreature)) {
                potentialBlockers=mustBeBlockedByAtLeastOne.get(toBeBlockedCreature);
              }
 else {
                potentialBlockers=new HashSet<>();
                mustBeBlockedByAtLeastOne.put(toBeBlockedCreature,potentialBlockers);
              }
              potentialBlockers.add(creature.getId());
            }
          }
          if (effect.mustBlockAny(game)) {
            boolean mayBlock=false;
            for (            UUID attackingCreatureId : getAttackers()) {
              if (creature.canBlock(attackingCreatureId,game)) {
                Permanent attackingCreature=game.getPermanent(attackingCreatureId);
                if (attackingCreature != null) {
                  if (attackingCreature.getMaxBlockedBy() != 0) {
                    int alreadyBlockingCreatures=0;
                    for (                    CombatGroup group : getGroups()) {
                      if (group.getAttackers().contains(attackingCreatureId)) {
                        alreadyBlockingCreatures=group.getBlockers().size();
                        break;
                      }
                    }
                    if (attackingCreature.getMaxBlockedBy() <= alreadyBlockingCreatures) {
                      continue;
                    }
                  }
                  if (attackingCreature.getMinBlockedBy() > 1) {
                  }
 else {
                    mayBlock=true;
                    break;
                  }
                }
              }
            }
            if (mayBlock) {
              if (controller.isHuman()) {
                game.informPlayer(controller,""String_Node_Str"" + creature.getLogName());
              }
 else {
                Player defender=game.getPlayer(creature.getControllerId());
                if (defender != null) {
                  for (                  UUID attackingCreatureId : getAttackers()) {
                    if (creature.canBlock(attackingCreatureId,game)) {
                      defender.declareBlocker(defender.getId(),creature.getId(),attackingCreatureId,game);
                      break;
                    }
                  }
                }
              }
              return false;
            }
          }
        }
      }
    }
  }
  for (  UUID toBeBlockedCreatureId : mustBeBlockedByAtLeastOne.keySet()) {
    for (    CombatGroup combatGroup : game.getCombat().getGroups()) {
      if (combatGroup.getBlockers().isEmpty() && combatGroup.getAttackers().contains(toBeBlockedCreatureId)) {
        if (controller.isHuman()) {
          Permanent toBeBlockedCreature=game.getPermanent(toBeBlockedCreatureId);
          if (toBeBlockedCreature != null) {
            boolean possibleBlockerAvailable=false;
            for (            UUID possibleBlockerId : mustBeBlockedByAtLeastOne.get(toBeBlockedCreatureId)) {
              Set<UUID> forcingAttackers=creatureMustBlockAttackers.get(possibleBlockerId);
              if (forcingAttackers == null) {
                possibleBlockerAvailable=true;
                break;
              }
              List<UUID> blockedAttackers=null;
              for (              CombatGroup combatGroupToCheck : game.getCombat().getGroups()) {
                if (combatGroupToCheck.getBlockers().contains(possibleBlockerId)) {
                  blockedAttackers=combatGroupToCheck.getAttackers();
                  break;
                }
              }
              if (blockedAttackers == null) {
                possibleBlockerAvailable=true;
                break;
              }
              possibleBlockerAvailable=true;
              for (              UUID blockedAttackerId : blockedAttackers) {
                if (creatureMustBlockAttackers.get(possibleBlockerId).contains(blockedAttackerId)) {
                  possibleBlockerAvailable=false;
                  break;
                }
              }
              if (possibleBlockerAvailable) {
                break;
              }
            }
            if (possibleBlockerAvailable) {
              game.informPlayer(controller,new StringBuilder(toBeBlockedCreature.getLogName()).append(""String_Node_Str"").toString());
              return false;
            }
          }
        }
 else {
          UUID blockingCreatureId=mustBeBlockedByAtLeastOne.get(toBeBlockedCreatureId).iterator().next();
          Permanent blockingCreature=game.getPermanent(blockingCreatureId);
          if (blockingCreature != null) {
            Player defender=game.getPlayer(blockingCreature.getControllerId());
            if (defender != null) {
              defender.declareBlocker(defender.getId(),blockingCreatureId,toBeBlockedCreatureId,game);
            }
          }
        }
      }
    }
  }
  StringBuilder sb=new StringBuilder();
  for (  Map.Entry<UUID,Set<UUID>> entry : creatureMustBlockAttackers.entrySet()) {
    boolean blockIsValid;
    Permanent creatureForcedToBlock=game.getPermanent(entry.getKey());
    if (creatureForcedToBlock == null) {
      break;
    }
    if (creatureForcedToBlock.getBlocking() == 0) {
      blockIsValid=false;
    }
 else {
      blockIsValid=false;
      CombatGroups:       for (      CombatGroup combatGroup : game.getCombat().getGroups()) {
        if (combatGroup.getBlockers().contains(creatureForcedToBlock.getId())) {
          for (          UUID forcingAttackerId : combatGroup.getAttackers()) {
            if (entry.getValue().contains(forcingAttackerId)) {
              blockIsValid=true;
              break CombatGroups;
            }
 else {
              if (combatGroup.getBlockers().size() == 1) {
                if (mustBeBlockedByAtLeastOne.containsKey(forcingAttackerId)) {
                  if (mustBeBlockedByAtLeastOne.get(forcingAttackerId).contains(creatureForcedToBlock.getId())) {
                    blockIsValid=true;
                    break CombatGroups;
                  }
                }
              }
            }
          }
        }
      }
    }
    if (!blockIsValid) {
      sb.append(""String_Node_Str"").append(creatureForcedToBlock.getLogName());
    }
  }
  if (sb.length() > 0) {
    sb.insert(0,""String_Node_Str"");
    sb.append(""String_Node_Str"");
    game.informPlayer(controller,sb.toString());
    return false;
  }
  return true;
}",0.963595057350252
158996,"@Override public boolean applies(GameEvent event,Ability source,Game game){
  return event.getPlayerId().equals(source.getSourceId());
}","@Override public boolean applies(GameEvent event,Ability source,Game game){
  Player controller=game.getPlayer(source.getControllerId());
  return controller != null && controller.hasOpponent(event.getPlayerId(),game);
}",0.5393258426966292
158997,"@Override public boolean applies(GameEvent event,Ability source,Game game){
  if (event.getType() == GameEvent.EventType.ADD_COUNTER && event.getData().equals(CounterType.P1P1.getName())) {
    Permanent target=game.getPermanent(event.getTargetId());
    if (target != null && target.getControllerId().equals(source.getControllerId()) && target.getCardType().contains(CardType.CREATURE)) {
      return true;
    }
  }
  return false;
}","@Override public boolean applies(GameEvent event,Ability source,Game game){
  if (event.getData().equals(CounterType.P1P1.getName())) {
    Permanent target=game.getPermanent(event.getTargetId());
    if (target != null && target.getControllerId().equals(source.getControllerId()) && target.getCardType().contains(CardType.CREATURE)) {
      return true;
    }
  }
  return false;
}",0.9339853300733496
158998,"@Override public boolean moveCardsToGraveyardWithInfo(List<Card> allCards,Ability source,Game game,Zone fromZone){
  while (!allCards.isEmpty()) {
    Cards cards=new CardsImpl();
    UUID ownerId=null;
    for (    Card card : allCards) {
      if (cards.isEmpty()) {
        ownerId=card.getOwnerId();
      }
      if (card.getOwnerId().equals(ownerId)) {
        cards.add(card);
      }
    }
    allCards.removeAll(cards);
    if (cards.size() != 0) {
      TargetCard target=new TargetCard(fromZone,new FilterCard(""String_Node_Str""));
      target.setRequired(true);
      Player choosingPlayer=this;
      if (ownerId != this.getId()) {
        choosingPlayer=game.getPlayer(ownerId);
      }
      if (choosingPlayer == null) {
        continue;
      }
      boolean chooseOrder=true;
      if (cards.size() > 2) {
        chooseOrder=choosingPlayer.chooseUse(Outcome.Neutral,""String_Node_Str"",game);
      }
      if (chooseOrder) {
        while (choosingPlayer.isInGame() && cards.size() > 1) {
          choosingPlayer.chooseTarget(Outcome.Neutral,cards,target,source,game);
          UUID targetObjectId=target.getFirstTarget();
          Card card=cards.get(targetObjectId,game);
          cards.remove(targetObjectId);
          if (card != null) {
            choosingPlayer.moveCardToGraveyardWithInfo(card,source.getSourceId(),game,fromZone);
          }
          target.clearChosen();
        }
        if (cards.size() == 1) {
          choosingPlayer.moveCardToGraveyardWithInfo(cards.getCards(game).iterator().next(),source.getSourceId(),game,fromZone);
        }
      }
 else {
        for (        Card card : cards.getCards(game)) {
          choosingPlayer.moveCardToGraveyardWithInfo(card,source.getSourceId(),game,fromZone);
        }
      }
    }
  }
  return true;
}","@Override public boolean moveCardsToGraveyardWithInfo(List<Card> allCards,Ability source,Game game,Zone fromZone){
  while (!allCards.isEmpty()) {
    Cards cards=new CardsImpl();
    UUID ownerId=null;
    for (    Card card : allCards) {
      if (cards.isEmpty()) {
        ownerId=card.getOwnerId();
      }
      if (card.getOwnerId().equals(ownerId)) {
        cards.add(card);
      }
    }
    allCards.removeAll(cards.getCards(game));
    if (cards.size() != 0) {
      TargetCard target=new TargetCard(fromZone,new FilterCard(""String_Node_Str""));
      target.setRequired(true);
      Player choosingPlayer=this;
      if (ownerId != this.getId()) {
        choosingPlayer=game.getPlayer(ownerId);
      }
      if (choosingPlayer == null) {
        continue;
      }
      boolean chooseOrder=true;
      if (cards.size() > 2) {
        chooseOrder=choosingPlayer.chooseUse(Outcome.Neutral,""String_Node_Str"",game);
      }
      if (chooseOrder) {
        while (choosingPlayer.isInGame() && cards.size() > 1) {
          choosingPlayer.chooseTarget(Outcome.Neutral,cards,target,source,game);
          UUID targetObjectId=target.getFirstTarget();
          Card card=cards.get(targetObjectId,game);
          cards.remove(targetObjectId);
          if (card != null) {
            choosingPlayer.moveCardToGraveyardWithInfo(card,source.getSourceId(),game,fromZone);
          }
          target.clearChosen();
        }
        if (cards.size() == 1) {
          choosingPlayer.moveCardToGraveyardWithInfo(cards.getCards(game).iterator().next(),source.getSourceId(),game,fromZone);
        }
      }
 else {
        for (        Card card : cards.getCards(game)) {
          choosingPlayer.moveCardToGraveyardWithInfo(card,source.getSourceId(),game,fromZone);
        }
      }
    }
  }
  return true;
}",0.9958529167818634
158999,"@Override public boolean checkTrigger(GameEvent event,Game game){
  if (!event.getTargetId().equals(getSourceId())) {
    Permanent sourcePermanent=game.getPermanentOrLKIBattlefield(getSourceId());
    if (sourcePermanent != null) {
      if (sourcePermanent.isFaceDown(game)) {
        return false;
      }
    }
 else {
      return false;
    }
  }
  Permanent permanent=game.getPermanent(event.getTargetId());
  if (filter.match(permanent,getSourceId(),getControllerId(),game)) {
    if (setTargetPointer) {
      for (      Effect effect : getEffects()) {
        effect.setTargetPointer(new FixedTarget(event.getTargetId()));
      }
    }
    return true;
  }
  return false;
}","@Override public boolean checkTrigger(GameEvent event,Game game){
  if (!event.getTargetId().equals(getSourceId())) {
    MageObject sourceObj=this.getSourceObject(game);
    if (sourceObj != null) {
      if (sourceObj instanceof Card && ((Card)sourceObj).isFaceDown(game)) {
        return false;
      }
    }
 else {
      return false;
    }
  }
  Permanent permanent=game.getPermanent(event.getTargetId());
  if (filter.match(permanent,getSourceId(),getControllerId(),game)) {
    if (setTargetPointer) {
      for (      Effect effect : getEffects()) {
        effect.setTargetPointer(new FixedTarget(event.getTargetId()));
      }
    }
    return true;
  }
  return false;
}",0.2967836257309941
159000,"public static void scan(){
  if (scanned) {
    return;
  }
  scanned=true;
  List<CardInfo> cardsToAdd=new ArrayList<>();
  List<String> packages=new ArrayList<>();
  for (  ExpansionSet set : Sets.getInstance().values()) {
    packages.add(set.getPackageName());
    ExpansionRepository.instance.add(new ExpansionInfo(set));
  }
  ExpansionRepository.instance.setContentVersion(CardRepository.instance.getContentVersionConstant());
  for (  Class c : ClassScanner.findClasses(packages,CardImpl.class)) {
    if (!CardRepository.instance.cardExists(c.getCanonicalName())) {
      Card card=CardImpl.createCard(c);
      if (card != null) {
        cardsToAdd.add(new CardInfo(card));
        if (card instanceof SplitCard) {
          SplitCard splitCard=(SplitCard)card;
          cardsToAdd.add(new CardInfo(splitCard.getLeftHalfCard()));
          cardsToAdd.add(new CardInfo(splitCard.getRightHalfCard()));
        }
      }
    }
  }
  if (!cardsToAdd.isEmpty()) {
    logger.info(""String_Node_Str"" + cardsToAdd.size());
    CardRepository.instance.addCards(cardsToAdd);
  }
  CardRepository.instance.setContentVersion(CardRepository.instance.getContentVersionConstant());
}","public static void scan(){
  if (scanned) {
    return;
  }
  scanned=true;
  List<CardInfo> cardsToAdd=new ArrayList<>();
  List<String> packages=new ArrayList<>();
  for (  ExpansionSet set : Sets.getInstance().values()) {
    packages.add(set.getPackageName());
    ExpansionRepository.instance.add(new ExpansionInfo(set));
  }
  ExpansionRepository.instance.setContentVersion(ExpansionRepository.instance.getContentVersionConstant());
  for (  Class c : ClassScanner.findClasses(packages,CardImpl.class)) {
    if (!CardRepository.instance.cardExists(c.getCanonicalName())) {
      Card card=CardImpl.createCard(c);
      if (card != null) {
        cardsToAdd.add(new CardInfo(card));
        if (card instanceof SplitCard) {
          SplitCard splitCard=(SplitCard)card;
          cardsToAdd.add(new CardInfo(splitCard.getLeftHalfCard()));
          cardsToAdd.add(new CardInfo(splitCard.getRightHalfCard()));
        }
      }
    }
  }
  if (!cardsToAdd.isEmpty()) {
    logger.info(""String_Node_Str"" + cardsToAdd.size());
    CardRepository.instance.addCards(cardsToAdd);
  }
  CardRepository.instance.setContentVersion(CardRepository.instance.getContentVersionConstant());
}",0.9945031712473572
