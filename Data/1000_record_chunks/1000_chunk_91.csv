record_number,buggy_code,fixed_code,code_similarity
90001,"public CrawlLogIndexCache(String name,boolean blacklist,String mimeFilter){
  super(name,new CrawlLogDataCache());
  useBlacklist=blacklist;
  this.mimeFilter=mimeFilter;
}","/** 
 * Constructor for the CrawlLogIndexCache class.
 * @param name The name of the CrawlLogIndexCache
 * @param blacklist Shall the mimefilter be considered a blacklist or a whitelist?
 * @param mimeFilter A regular expression for the mimetypes toexclude/include
 */
public CrawlLogIndexCache(String name,boolean blacklist,String mimeFilter){
  super(name,new CrawlLogDataCache());
  useBlacklist=blacklist;
  this.mimeFilter=mimeFilter;
}",0.5611745513866232
90002,"/** 
 * Combine a number of crawl.log files into one Lucene index.  This index is placed as gzip files under the directory returned by getCacheFile().
 * @param rawfiles The map from job ID into crawl.log contents. Nonull values are allowed in this map.
 * @param askedJobIds The set of jobIds actually needed
 */
protected void combine(Map<Long,File> rawfiles){
  File resultFile=getCacheFile(rawfiles.keySet());
  String indexLocation=resultFile.getAbsolutePath() + ""String_Node_Str"";
  try {
    String indexingMode=DigestIndexer.MODE_BOTH;
    boolean includeNormalizedURL=false;
    boolean includeTimestamp=true;
    boolean includeEtag=true;
    boolean addToExistingIndex=false;
    DigestIndexer indexer=new DigestIndexer(indexLocation,indexingMode,includeNormalizedURL,includeTimestamp,includeEtag,addToExistingIndex);
    for (    Map.Entry<Long,File> entry : rawfiles.entrySet()) {
      indexFile(entry.getKey(),entry.getValue(),indexer);
    }
    indexer.close(OPTIMIZE_INDEX);
    ZipUtils.gzipFiles(new File(indexLocation),resultFile);
  }
 catch (  IOException e) {
    throw new IOFailure(""String_Node_Str"" + resultFile.getAbsolutePath(),e);
  }
 finally {
    FileUtils.removeRecursively(new File(indexLocation));
  }
}","/** 
 * Combine a number of crawl.log files into one Lucene index.  This index is placed as gzip files under the directory returned by getCacheFile().
 * @param rawfiles The map from job ID into crawl.log contents. Nonull values are allowed in this map.
 */
protected void combine(Map<Long,File> rawfiles){
  File resultFile=getCacheFile(rawfiles.keySet());
  String indexLocation=resultFile.getAbsolutePath() + ""String_Node_Str"";
  try {
    String indexingMode=DigestIndexer.MODE_BOTH;
    boolean includeNormalizedURL=false;
    boolean includeTimestamp=true;
    boolean includeEtag=true;
    boolean addToExistingIndex=false;
    DigestIndexer indexer=new DigestIndexer(indexLocation,indexingMode,includeNormalizedURL,includeTimestamp,includeEtag,addToExistingIndex);
    for (    Map.Entry<Long,File> entry : rawfiles.entrySet()) {
      indexFile(entry.getKey(),entry.getValue(),indexer);
    }
    indexer.close(OPTIMIZE_INDEX);
    ZipUtils.gzipFiles(new File(indexLocation),resultFile);
  }
 catch (  IOException e) {
    throw new IOFailure(""String_Node_Str"" + resultFile.getAbsolutePath(),e);
  }
 finally {
    FileUtils.removeRecursively(new File(indexLocation));
  }
}",0.976878612716763
90003,"/** 
 * Get an index for the given list of job IDs. The resulting file contains a suitably sorted list. This method should always be safe for asynchronous calling. This method may use a cached version of the file.
 * @param jobIDs Set of job IDs to generate index for.
 * @return An index, consisting of a file and the set this is an index for.This file must not be modified or deleted, since it is part of the cache of data.
 */
public Index<Set<Long>> getIndex(Set<Long> jobIDs);","/** 
 * Get an index for the given list of job IDs. The resulting file contains a suitably sorted list. This method should always be safe for asynchronous calling. This method may use a cached version of the file.
 * @param jobIDs Set of job IDs to generate index for.
 * @return An index, consisting of a file and the set this is an index for.This file must not be modified or deleted, since it is part of the cache of data.
 */
Index<Set<Long>> getIndex(Set<Long> jobIDs);",0.9926701570680628
90004,"/** 
 * Lookup and return the Class with the given className.
 * @param className The name of the class to lookup
 * @throws ClassNotFoundException If the class could not be found
 * @return the Class with the given className.
 * @Overrides ClassLoader.findClass()
 */
public Class findClass(String className) throws ClassNotFoundException {
  ArgumentNotValid.checkNotNullOrEmpty(className,""String_Node_Str"");
  String realClassName=className.replace(JAVA_PACKAGE_SEPARATOR,DIRECTOR_SEPARATOR) + ""String_Node_Str"";
  if (binaryData.isEmpty()) {
    log.warn(""String_Node_Str"" + className + ""String_Node_Str"");
  }
  if (binaryData.containsKey(realClassName)) {
    final byte[] bytes=binaryData.get(realClassName);
    return defineClass(className,bytes,0,bytes.length);
  }
 else {
    return super.findClass(className);
  }
}","/** 
 * Lookup and return the Class with the given className. This method overrides the ClassLoader.findClass method.
 * @param className The name of the class to lookup
 * @throws ClassNotFoundException If the class could not be found
 * @return the Class with the given className.
 */
public Class findClass(String className) throws ClassNotFoundException {
  ArgumentNotValid.checkNotNullOrEmpty(className,""String_Node_Str"");
  String realClassName=className.replace(JAVA_PACKAGE_SEPARATOR,DIRECTOR_SEPARATOR) + ""String_Node_Str"";
  if (binaryData.isEmpty()) {
    log.warn(""String_Node_Str"" + className + ""String_Node_Str"");
  }
  if (binaryData.containsKey(realClassName)) {
    final byte[] bytes=binaryData.get(realClassName);
    return defineClass(className,bytes,0,bytes.length);
  }
 else {
    return super.findClass(className);
  }
}",0.9438470728793308
90005,"/** 
 * Get statusInfo.
 * @See {@link JobDAO#getStatusInfo(long,long,boolean,Set)}
 */
public List<JobStatusInfo> getStatusInfo(long harvestId,long harvestNum,boolean asc,Set<JobStatus> selectedStatusSet){
  ArgumentNotValid.checkNotNegative(harvestId,""String_Node_Str"");
  ArgumentNotValid.checkNotNegative(harvestNum,""String_Node_Str"");
  ArgumentNotValid.checkNotNullOrEmpty(selectedStatusSet,""String_Node_Str"");
  String ascdescString=(asc) ? Constants.ASCENDING_SORT_ORDER : Constants.DESCENDING_SORT_ORDER;
  StringBuffer statusSortBuffer=new StringBuffer();
  boolean selectAllJobStates=(selectedStatusSet.size() == JobStatus.values().length);
  if (!selectAllJobStates) {
    if (selectedStatusSet.size() == 1) {
      int theWantedStatus=selectedStatusSet.iterator().next().ordinal();
      statusSortBuffer.append(""String_Node_Str"" + theWantedStatus);
    }
 else {
      Iterator<JobStatus> it=selectedStatusSet.iterator();
      int nextInt=it.next().ordinal();
      StringBuffer res=new StringBuffer(""String_Node_Str"" + nextInt);
      while (it.hasNext()) {
        nextInt=it.next().ordinal();
        res.append(""String_Node_Str"" + nextInt);
      }
      res.append(""String_Node_Str"");
      statusSortBuffer.append(res);
    }
  }
  Connection dbconnection=DBConnect.getDBConnection();
  PreparedStatement statement=null;
  try {
    statement=dbconnection.prepareStatement(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"" + harvestId + ""String_Node_Str""+ harvestNum+ statusSortBuffer.toString()+ ""String_Node_Str""+ ascdescString);
    ResultSet res=statement.executeQuery();
    return makeJobStatusInfoListFromResultset(res);
  }
 catch (  SQLException e) {
    String message=""String_Node_Str"" + ""String_Node_Str"" + ExceptionUtils.getSQLExceptionCause(e);
    log.warn(message,e);
    throw new IOFailure(message,e);
  }
 finally {
    DBUtils.closeStatementIfOpen(statement);
  }
}","/** 
 * Get statusInfo.
 * @see JobDAO#getStatusInfo(long,long,boolean,Set)
 */
public List<JobStatusInfo> getStatusInfo(long harvestId,long harvestNum,boolean asc,Set<JobStatus> selectedStatusSet){
  ArgumentNotValid.checkNotNegative(harvestId,""String_Node_Str"");
  ArgumentNotValid.checkNotNegative(harvestNum,""String_Node_Str"");
  ArgumentNotValid.checkNotNullOrEmpty(selectedStatusSet,""String_Node_Str"");
  String ascdescString=(asc) ? Constants.ASCENDING_SORT_ORDER : Constants.DESCENDING_SORT_ORDER;
  StringBuffer statusSortBuffer=new StringBuffer();
  boolean selectAllJobStates=(selectedStatusSet.size() == JobStatus.values().length);
  if (!selectAllJobStates) {
    if (selectedStatusSet.size() == 1) {
      int theWantedStatus=selectedStatusSet.iterator().next().ordinal();
      statusSortBuffer.append(""String_Node_Str"" + theWantedStatus);
    }
 else {
      Iterator<JobStatus> it=selectedStatusSet.iterator();
      int nextInt=it.next().ordinal();
      StringBuffer res=new StringBuffer(""String_Node_Str"" + nextInt);
      while (it.hasNext()) {
        nextInt=it.next().ordinal();
        res.append(""String_Node_Str"" + nextInt);
      }
      res.append(""String_Node_Str"");
      statusSortBuffer.append(res);
    }
  }
  Connection dbconnection=DBConnect.getDBConnection();
  PreparedStatement statement=null;
  try {
    statement=dbconnection.prepareStatement(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"" + harvestId + ""String_Node_Str""+ harvestNum+ statusSortBuffer.toString()+ ""String_Node_Str""+ ascdescString);
    ResultSet res=statement.executeQuery();
    return makeJobStatusInfoListFromResultset(res);
  }
 catch (  SQLException e) {
    String message=""String_Node_Str"" + ""String_Node_Str"" + ExceptionUtils.getSQLExceptionCause(e);
    log.warn(message,e);
    throw new IOFailure(message,e);
  }
 finally {
    DBUtils.closeStatementIfOpen(statement);
  }
}",0.9964753272910372
90006,"/** 
 * @see {@link HeritrixController#getQueuedUriCount()}
 */
public long getQueuedUriCount(){
  return myController.getFrontier().queuedUriCount();
}","/** 
 * @see HeritrixController#getQueuedUriCount() 
 */
public long getQueuedUriCount(){
  return myController.getFrontier().queuedUriCount();
}",0.9696969696969696
90007,"/** 
 * Sets the value of crawlIsEnded to false
 */
public SimpleCrawlStatusListener(){
  crawlIsEnded.set(false);
}","/** 
 * Sets the value of crawlIsEnded to false.
 */
public SimpleCrawlStatusListener(){
  crawlIsEnded.set(false);
}",0.9957081545064378
90008,"/** 
 * Check if the crawl has ended, either because Heritrix finished of its own, or because we terminated it.
 * @return True if the crawl has ended, either because Heritrix finishedor because we terminated it. Otherwise we return false.
 * @See {@link HeritrixController#crawlIsEnded()}
 */
public synchronized boolean crawlIsEnded(){
  if (processHasExited()) {
    return true;
  }
  TabularData jobs=(TabularData)executeHeritrixCommand(COMPLETED_JOBS_COMMAND);
  if (jobs != null && jobs.size() > 0) {
    for (    CompositeData value : (Collection<CompositeData>)jobs.values()) {
      String thisJobID=value.get(JmxUtils.NAME) + ""String_Node_Str"" + value.get(UID_PROPERTY);
      if (thisJobID.equals(jobName)) {
        return true;
      }
    }
  }
  String status=(String)getCrawlJobAttribute(STATUS_ATTRIBUTE);
  return status == null || status.equals(FINISHED_STATUS) || status.equals(ILLEGAL_STATUS);
}","/** 
 * Check if the crawl has ended, either because Heritrix finished of its own, or because we terminated it.
 * @return True if the crawl has ended, either because Heritrix finishedor because we terminated it. Otherwise we return false.
 * @see HeritrixController#crawlIsEnded()
 */
public synchronized boolean crawlIsEnded(){
  if (processHasExited()) {
    return true;
  }
  TabularData jobs=(TabularData)executeHeritrixCommand(COMPLETED_JOBS_COMMAND);
  if (jobs != null && jobs.size() > 0) {
    for (    CompositeData value : (Collection<CompositeData>)jobs.values()) {
      String thisJobID=value.get(JmxUtils.NAME) + ""String_Node_Str"" + value.get(UID_PROPERTY);
      if (thisJobID.equals(jobName)) {
        return true;
      }
    }
  }
  String status=(String)getCrawlJobAttribute(STATUS_ATTRIBUTE);
  return status == null || status.equals(FINISHED_STATUS) || status.equals(ILLEGAL_STATUS);
}",0.9923329682365828
90009,"/** 
 * Get the name to use for logging on to Heritrix' JMX with full control. The name cannot be set by the user.
 * @return Name to use when connecting to Heritrix JMX
 */
private String getJMXAdminName(){
  String jmxUsername=Settings.get(HarvesterSettings.HERITRIX_JMX_USERNAME);
  log.debug(""String_Node_Str"" + ""String_Node_Str"" + jmxUsername + ""String_Node_Str"");
  return jmxUsername;
}","/** 
 * Get the name to use for logging on to Heritrix' JMX with full control. The name cannot be set by the user.
 * @return Name to use when connecting to Heritrix JMX
 */
private String getJMXAdminName(){
  String jmxUsername=Settings.get(HarvesterSettings.HERITRIX_JMX_USERNAME);
  log.debug(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + jmxUsername + ""String_Node_Str"");
  return jmxUsername;
}",0.9751861042183624
90010,"/** 
 * This method does the following: Retrieves the path to the jmxremote.access and jmxremote.password files. Moves these files, if they are different from standard. Makes the jmxremote.access and jmxremote.password files readonly.
 * @return The commands for handling the jmxremote files.
 */
@Override protected String getJMXremoteFilesCommand(){
  String accessFilePath;
  String passwordFilePath;
  String[] options;
  options=settings.getLeafValues(Constants.SETTINGS_COMMON_JMX_ACCESSFILE);
  if (options == null || options.length < 0) {
    accessFilePath=Constants.JMX_ACCESS_FILE_PATH_DEFAULT;
  }
 else {
    accessFilePath=options[0];
    if (options.length > 1) {
      log.debug(Constants.MSG_WARN_TOO_MANY_JMXREMOTE_FILE_PATHS);
    }
  }
  options=settings.getLeafValues(Constants.SETTINGS_COMMON_JMX_PASSWORDFILE);
  if (options == null || options.length < 0) {
    passwordFilePath=Constants.JMX_PASSWORD_FILE_PATH_DEFAULT;
  }
 else {
    passwordFilePath=options[0];
    if (options.length > 1) {
      log.debug(Constants.MSG_WARN_TOO_MANY_JMXREMOTE_FILE_PATHS);
    }
  }
  accessFilePath=ScriptConstants.replaceWindowsDirSeparators(accessFilePath);
  passwordFilePath=ScriptConstants.replaceWindowsDirSeparators(passwordFilePath);
  StringBuilder res=new StringBuilder();
  res.append(ScriptConstants.ECHO_MAKE_PASSWORD_FILES);
  res.append(Constants.NEWLINE);
  if (!accessFilePath.equals(ScriptConstants.replaceWindowsDirSeparators(Constants.JMX_ACCESS_FILE_PATH_DEFAULT))) {
    res.append(ScriptConstants.SSH + Constants.SPACE);
    res.append(machineUserLogin());
    res.append(Constants.SPACE + Constants.QUOTE_MARK);
    res.append(ScriptConstants.WINDOWS_COMMAND_RUN + Constants.SPACE);
    res.append(ScriptConstants.MOVE);
    res.append(Constants.SPACE);
    res.append(ScriptConstants.doubleBackslashes(getLocalInstallDirPath()));
    res.append(ScriptConstants.replaceWindowsDirSeparators(Constants.JMX_ACCESS_FILE_PATH_DEFAULT));
    res.append(Constants.SPACE);
    res.append(ScriptConstants.doubleBackslashes(getLocalInstallDirPath()));
    res.append(accessFilePath);
    res.append(Constants.QUOTE_MARK);
    res.append(Constants.NEWLINE);
  }
  if (!passwordFilePath.equals(ScriptConstants.replaceWindowsDirSeparators(Constants.JMX_PASSWORD_FILE_PATH_DEFAULT))) {
    res.append(ScriptConstants.SSH + Constants.SPACE);
    res.append(machineUserLogin());
    res.append(Constants.SPACE + Constants.QUOTE_MARK);
    res.append(ScriptConstants.WINDOWS_COMMAND_RUN + Constants.SPACE);
    res.append(ScriptConstants.MOVE);
    res.append(Constants.SPACE);
    res.append(ScriptConstants.doubleBackslashes(getLocalInstallDirPath()));
    res.append(ScriptConstants.replaceWindowsDirSeparators(Constants.JMX_PASSWORD_FILE_PATH_DEFAULT));
    res.append(Constants.SPACE);
    res.append(ScriptConstants.doubleBackslashes(getLocalInstallDirPath()));
    res.append(passwordFilePath);
    res.append(Constants.QUOTE_MARK);
    res.append(Constants.NEWLINE);
  }
  res.append(ScriptConstants.ECHO_Y + Constants.SPACE + Constants.SEPARATOR+ Constants.SPACE+ ScriptConstants.SSH+ Constants.SPACE);
  res.append(machineUserLogin());
  res.append(Constants.SPACE + Constants.QUOTE_MARK + ScriptConstants.WINDOWS_COMMAND_RUN+ Constants.SPACE+ ScriptConstants.CACLS+ Constants.SPACE);
  res.append(ScriptConstants.doubleBackslashes(getLocalInstallDirPath()));
  res.append(passwordFilePath);
  res.append(Constants.SPACE + ScriptConstants.SLASH_P + Constants.SPACE+ ScriptConstants.BITARKIV_BACKSLASH_BACKSLASH);
  res.append(machineParameters.getMachineUserName().getText());
  res.append(ScriptConstants.COLON_R + Constants.QUOTE_MARK);
  res.append(Constants.NEWLINE);
  res.append(ScriptConstants.ECHO_Y + Constants.SPACE + Constants.SEPARATOR+ Constants.SPACE+ ScriptConstants.SSH+ Constants.SPACE);
  res.append(machineUserLogin());
  res.append(Constants.SPACE + Constants.QUOTE_MARK + ScriptConstants.WINDOWS_COMMAND_RUN+ Constants.SPACE+ ScriptConstants.CACLS+ Constants.SPACE);
  res.append(ScriptConstants.doubleBackslashes(getLocalInstallDirPath()));
  res.append(passwordFilePath);
  res.append(Constants.SPACE + ScriptConstants.SLASH_P + Constants.SPACE+ ScriptConstants.BITARKIV_BACKSLASH_BACKSLASH);
  res.append(machineParameters.getMachineUserName().getText());
  res.append(ScriptConstants.COLON_R + Constants.QUOTE_MARK);
  res.append(Constants.NEWLINE);
  return res.toString();
}","/** 
 * This method does the following: Retrieves the path to the jmxremote.access and jmxremote.password files. Moves these files, if they are different from standard. Makes the jmxremote.access and jmxremote.password files readonly.
 * @return The commands for handling the jmxremote files.
 */
@Override protected String getJMXremoteFilesCommand(){
  String accessFilePath;
  String passwordFilePath;
  String[] options;
  options=settings.getLeafValues(Constants.SETTINGS_COMMON_JMX_ACCESSFILE);
  if (options == null || options.length < 0) {
    accessFilePath=Constants.JMX_ACCESS_FILE_PATH_DEFAULT;
  }
 else {
    accessFilePath=options[0];
    if (options.length > 1) {
      log.debug(Constants.MSG_WARN_TOO_MANY_JMXREMOTE_FILE_PATHS);
    }
  }
  options=settings.getLeafValues(Constants.SETTINGS_COMMON_JMX_PASSWORDFILE);
  if (options == null || options.length < 0) {
    passwordFilePath=Constants.JMX_PASSWORD_FILE_PATH_DEFAULT;
  }
 else {
    passwordFilePath=options[0];
    if (options.length > 1) {
      log.debug(Constants.MSG_WARN_TOO_MANY_JMXREMOTE_FILE_PATHS);
    }
  }
  accessFilePath=ScriptConstants.replaceWindowsDirSeparators(accessFilePath);
  passwordFilePath=ScriptConstants.replaceWindowsDirSeparators(passwordFilePath);
  StringBuilder res=new StringBuilder();
  res.append(ScriptConstants.ECHO_MAKE_PASSWORD_FILES);
  res.append(Constants.NEWLINE);
  if (!accessFilePath.equals(ScriptConstants.replaceWindowsDirSeparators(Constants.JMX_ACCESS_FILE_PATH_DEFAULT))) {
    res.append(ScriptConstants.SSH + Constants.SPACE);
    res.append(machineUserLogin());
    res.append(Constants.SPACE + Constants.QUOTE_MARK);
    res.append(ScriptConstants.WINDOWS_COMMAND_RUN + Constants.SPACE);
    res.append(ScriptConstants.MOVE);
    res.append(Constants.SPACE);
    res.append(ScriptConstants.doubleBackslashes(getLocalInstallDirPath()));
    res.append(ScriptConstants.replaceWindowsDirSeparators(Constants.JMX_ACCESS_FILE_PATH_DEFAULT));
    res.append(Constants.SPACE);
    res.append(ScriptConstants.doubleBackslashes(getLocalInstallDirPath()));
    res.append(accessFilePath);
    res.append(Constants.QUOTE_MARK);
    res.append(Constants.NEWLINE);
  }
  if (!passwordFilePath.equals(ScriptConstants.replaceWindowsDirSeparators(Constants.JMX_PASSWORD_FILE_PATH_DEFAULT))) {
    res.append(ScriptConstants.SSH + Constants.SPACE);
    res.append(machineUserLogin());
    res.append(Constants.SPACE + Constants.QUOTE_MARK);
    res.append(ScriptConstants.WINDOWS_COMMAND_RUN + Constants.SPACE);
    res.append(ScriptConstants.MOVE);
    res.append(Constants.SPACE);
    res.append(ScriptConstants.doubleBackslashes(getLocalInstallDirPath()));
    res.append(ScriptConstants.replaceWindowsDirSeparators(Constants.JMX_PASSWORD_FILE_PATH_DEFAULT));
    res.append(Constants.SPACE);
    res.append(ScriptConstants.doubleBackslashes(getLocalInstallDirPath()));
    res.append(passwordFilePath);
    res.append(Constants.QUOTE_MARK);
    res.append(Constants.NEWLINE);
  }
  res.append(ScriptConstants.ECHO_Y + Constants.SPACE + Constants.SEPARATOR+ Constants.SPACE+ ScriptConstants.SSH+ Constants.SPACE);
  res.append(machineUserLogin());
  res.append(Constants.SPACE + Constants.QUOTE_MARK + ScriptConstants.WINDOWS_COMMAND_RUN+ Constants.SPACE+ ScriptConstants.CACLS+ Constants.SPACE);
  res.append(ScriptConstants.doubleBackslashes(getLocalInstallDirPath()));
  res.append(passwordFilePath);
  res.append(Constants.SPACE + ScriptConstants.SLASH_P + Constants.SPACE+ ScriptConstants.BITARKIV_BACKSLASH_BACKSLASH);
  res.append(machineParameters.getMachineUserName().getText());
  res.append(ScriptConstants.COLON_R + Constants.QUOTE_MARK);
  res.append(Constants.NEWLINE);
  res.append(ScriptConstants.ECHO_Y + Constants.SPACE + Constants.SEPARATOR+ Constants.SPACE+ ScriptConstants.SSH+ Constants.SPACE);
  res.append(machineUserLogin());
  res.append(Constants.SPACE + Constants.QUOTE_MARK + ScriptConstants.WINDOWS_COMMAND_RUN+ Constants.SPACE+ ScriptConstants.CACLS+ Constants.SPACE);
  res.append(ScriptConstants.doubleBackslashes(getLocalInstallDirPath()));
  res.append(accessFilePath);
  res.append(Constants.SPACE + ScriptConstants.SLASH_P + Constants.SPACE+ ScriptConstants.BITARKIV_BACKSLASH_BACKSLASH);
  res.append(machineParameters.getMachineUserName().getText());
  res.append(ScriptConstants.COLON_R + Constants.QUOTE_MARK);
  res.append(Constants.NEWLINE);
  return res.toString();
}",0.9984202211690364
90011,"/** 
 * Ensure that a file containing the appropriate content exists for the ID. If the content cannot be found, this method may return null (if I is a simple type) or an appropriate subset (if I is, say, a Set) indicating the data that is actually available.  In the latter case, calling cache on the returned set should always fill the file for that subset (barring catastrophic failure). Locking:  If the file is not immediately found, we enter a file-creation state.  To avoid corrupted data, we must ensure that only one cache instance, and only one thread within any instance, creates the file. Thus as long as somebody else seems to be creating the file, we wait and see if they finish.  This is checked by having an exclusive lock on a "".working"" file (we cannot use the result file, as it has to be created to be locked, and we may end up with a different cached file than we thought, see above).  The .working file itself is irrelevant, only the lock on it matters.
 * @param id Some sort of id that uniquely identifies the item withinthe cache.
 * @return The id given if it was successfully fetched, otherwise nullif the type parameter I does not allow subsets, or a subset of id if it does.  This subset should be immediately cacheable. FIXME added method synchronization. Try to fix bug 1547
 */
public I cache(I id){
  ArgumentNotValid.checkNotNull(id,""String_Node_Str"");
  File cachedFile=getCacheFile(id);
  if (cachedFile.exists()) {
    return id;
  }
 else {
    try {
      File fileBehindLockFile=new File(cachedFile.getAbsolutePath() + ""String_Node_Str"");
      FileOutputStream lockFile=new FileOutputStream(fileBehindLockFile);
      FileLock lock=null;
      try {
synchronized (fileBehindLockFile.getAbsolutePath().intern()) {
          log.debug(""String_Node_Str"" + fileBehindLockFile.getAbsolutePath() + ""String_Node_Str""+ Thread.currentThread().getName()+ ""String_Node_Str"");
          try {
            lock=lockFile.getChannel().lock();
          }
 catch (          OverlappingFileLockException e) {
            log.warn(e);
            throw new IOException(e);
          }
          if (cachedFile.exists()) {
            return id;
          }
          return cacheData(id);
        }
      }
  finally {
        if (lock != null) {
          log.debug(""String_Node_Str"" + lockFile.getChannel());
          lock.release();
        }
        lockFile.close();
      }
    }
 catch (    IOException e) {
      String errMsg=""String_Node_Str"" + cachedFile.getAbsolutePath() + ""String_Node_Str"";
      log.warn(errMsg,e);
      throw new IOFailure(errMsg,e);
    }
  }
}","/** 
 * Ensure that a file containing the appropriate content exists for the ID. If the content cannot be found, this method may return null (if I is a simple type) or an appropriate subset (if I is, say, a Set) indicating the data that is actually available.  In the latter case, calling cache on the returned set should always fill the file for that subset (barring catastrophic failure). Locking:  If the file is not immediately found, we enter a file-creation state.  To avoid corrupted data, we must ensure that only one cache instance, and only one thread within any instance, creates the file. Thus as long as somebody else seems to be creating the file, we wait and see if they finish.  This is checked by having an exclusive lock on a "".working"" file (we cannot use the result file, as it has to be created to be locked, and we may end up with a different cached file than we thought, see above).  The .working file itself is irrelevant, only the lock on it matters.
 * @param id Some sort of id that uniquely identifies the item withinthe cache.
 * @return The id given if it was successfully fetched, otherwise nullif the type parameter I does not allow subsets, or a subset of id if it does.  This subset should be immediately cacheable. FIXME added method synchronization. Try to fix bug 1547
 */
public I cache(I id){
  ArgumentNotValid.checkNotNull(id,""String_Node_Str"");
  File cachedFile=getCacheFile(id);
  if (cachedFile.exists()) {
    return id;
  }
 else {
    try {
      File fileBehindLockFile=new File(cachedFile.getAbsolutePath() + ""String_Node_Str"");
      FileOutputStream lockFile=new FileOutputStream(fileBehindLockFile);
      FileLock lock=null;
      try {
synchronized (fileBehindLockFile.getAbsolutePath().intern()) {
          log.debug(""String_Node_Str"" + fileBehindLockFile.getAbsolutePath() + ""String_Node_Str""+ Thread.currentThread().getName()+ ""String_Node_Str"");
          try {
            lock=lockFile.getChannel().lock();
          }
 catch (          OverlappingFileLockException e) {
            log.warn(e);
            throw new IOException(e);
          }
          if (cachedFile.exists()) {
            return id;
          }
          I found=cacheData(id);
          log.warn(""String_Node_Str"" + id + ""String_Node_Str""+ found);
          return id;
        }
      }
  finally {
        if (lock != null) {
          log.debug(""String_Node_Str"" + lockFile.getChannel());
          lock.release();
        }
        lockFile.close();
      }
    }
 catch (    IOException e) {
      String errMsg=""String_Node_Str"" + cachedFile.getAbsolutePath() + ""String_Node_Str"";
      log.warn(errMsg,e);
      throw new IOFailure(errMsg,e);
    }
  }
}",0.979807510851104
90012,"/** 
 * Combine parts of an index into one big index.
 * @param filesFound A map of IDs and the files caching their content.
 * @param filesRequired The Set of IDS required by the caller.
 */
protected void combine(Map<Long,File> filesFound,Set<Long> filesRequired){
  File resultFile=getCacheFile(filesFound.keySet());
  concatenateFiles(filesFound.values(),resultFile);
  sortFile(resultFile);
}","/** 
 * Combine parts of an index into one big index.
 * @param filesFound A map of IDs and the files caching their content.
 */
protected void combine(Map<Long,File> filesFound){
  File resultFile=getCacheFile(filesFound.keySet());
  concatenateFiles(filesFound.values(),resultFile);
  sortFile(resultFile);
}",0.8769448373408769
90013,"/** 
 * This is called when an appropriate file for the ids in question has not been found.  It is expected to do the actual operations necessary to get the data.  At the outset, the file for the given IDs is expected to be not present.
 * @param ids The set of identifiers for which we want the correspondingdata
 * @return The set of IDs, or subset if data fetching failed for some IDs.If some IDs failed, the file is not filled, though some data may be cached at a lower level.
 */
protected Set<T> cacheData(Set<T> ids){
  Map<T,File> filesFound=prepareCombine(ids);
  File resultFile=getCacheFile(ids);
  if (filesFound.size() == ids.size()) {
    combine(filesFound,ids);
  }
 else {
    FileUtils.remove(resultFile);
  }
  return filesFound.keySet();
}","/** 
 * This is called when an appropriate file for the ids in question has not been found.  It is expected to do the actual operations necessary to get the data.  At the outset, the file for the given IDs is expected to be not present.
 * @param ids The set of identifiers for which we want the correspondingdata
 * @return The set of IDs, or subset if data fetching failed for some IDs.If some IDs failed, the file is not filled, though some data may be cached at a lower level.
 */
protected Set<T> cacheData(Set<T> ids){
  Map<T,File> filesFound=prepareCombine(ids);
  File resultFile=getCacheFile(ids);
  if (filesFound.size() == ids.size()) {
    combine(filesFound);
  }
 else {
    FileUtils.remove(resultFile);
  }
  return filesFound.keySet();
}",0.9973579920739762
90014,"/** 
 * Combine a set of files found in the raw data cache to form our kind of file.
 * @param filesFound The files that were found for the IDs in the rawdata cache.  The map must not contain any null values.
 * @param filesRequired The set of IDs required
 */
protected abstract void combine(Map<T,File> filesFound,Set<T> filesRequired);","/** 
 * Combine a set of files found in the raw data cache to form our kind of file.
 * @param filesFound The files that were found for the IDs in the rawdata cache.  The map must not contain any null values.
 */
protected abstract void combine(Map<T,File> filesFound);",0.886326194398682
90015,"/** 
 * Combine a number of crawl.log files into one Lucene index.  This index is placed as gzip files under the directory returned by getCacheFile().
 * @param rawfiles The map from job ID into crawl.log contents. Nonull values are allowed in this map.
 * @param askedJobIds The set of jobIds actually needed
 */
protected void combine(Map<Long,File> rawfiles,Set<Long> askedJobIds){
  File resultFile=getCacheFile(askedJobIds);
  String indexLocation=resultFile.getAbsolutePath() + ""String_Node_Str"";
  try {
    String indexingMode=DigestIndexer.MODE_BOTH;
    boolean includeNormalizedURL=false;
    boolean includeTimestamp=true;
    boolean includeEtag=true;
    boolean addToExistingIndex=false;
    DigestIndexer indexer=new DigestIndexer(indexLocation,indexingMode,includeNormalizedURL,includeTimestamp,includeEtag,addToExistingIndex);
    for (    Map.Entry<Long,File> entry : rawfiles.entrySet()) {
      indexFile(entry.getKey(),entry.getValue(),indexer);
    }
    indexer.close(OPTIMIZE_INDEX);
    ZipUtils.gzipFiles(new File(indexLocation),resultFile);
  }
 catch (  IOException e) {
    throw new IOFailure(""String_Node_Str"" + resultFile.getAbsolutePath(),e);
  }
 finally {
    FileUtils.removeRecursively(new File(indexLocation));
  }
}","/** 
 * Combine a number of crawl.log files into one Lucene index.  This index is placed as gzip files under the directory returned by getCacheFile().
 * @param rawfiles The map from job ID into crawl.log contents. Nonull values are allowed in this map.
 * @param askedJobIds The set of jobIds actually needed
 */
protected void combine(Map<Long,File> rawfiles){
  File resultFile=getCacheFile(rawfiles.keySet());
  String indexLocation=resultFile.getAbsolutePath() + ""String_Node_Str"";
  try {
    String indexingMode=DigestIndexer.MODE_BOTH;
    boolean includeNormalizedURL=false;
    boolean includeTimestamp=true;
    boolean includeEtag=true;
    boolean addToExistingIndex=false;
    DigestIndexer indexer=new DigestIndexer(indexLocation,indexingMode,includeNormalizedURL,includeTimestamp,includeEtag,addToExistingIndex);
    for (    Map.Entry<Long,File> entry : rawfiles.entrySet()) {
      indexFile(entry.getKey(),entry.getValue(),indexer);
    }
    indexer.close(OPTIMIZE_INDEX);
    ZipUtils.gzipFiles(new File(indexLocation),resultFile);
  }
 catch (  IOException e) {
    throw new IOFailure(""String_Node_Str"" + resultFile.getAbsolutePath(),e);
  }
 finally {
    FileUtils.removeRecursively(new File(indexLocation));
  }
}",0.9550922213311948
90016,"/** 
 * Ensure that a file containing the appropriate content exists for the ID. If the content cannot be found, this method may return null (if I is a simple type) or an appropriate subset (if I is, say, a Set) indicating the data that is actually available.  In the latter case, calling cache on the returned set should always fill the file for that subset (barring catastrophic failure). Locking:  If the file is not immediately found, we enter a file-creation state.  To avoid corrupted data, we must ensure that only one cache instance, and only one thread within any instance, creates the file. Thus as long as somebody else seems to be creating the file, we wait and see if they finish.  This is checked by having an exclusive lock on a "".working"" file (we cannot use the result file, as it has to be created to be locked, and we may end up with a different cached file than we thought, see above).  The .working file itself is irrelevant, only the lock on it matters.
 * @param id Some sort of id that uniquely identifies the item withinthe cache.
 * @return The id given if it was successfully fetched, otherwise nullif the type parameter I does not allow subsets, or a subset of id if it does.  This subset should be immediately cacheable. FIXME added method synchronization. Try to fix bug 1547
 */
public I cache(I id){
  ArgumentNotValid.checkNotNull(id,""String_Node_Str"");
  File cachedFile=getCacheFile(id);
  if (cachedFile.exists()) {
    return id;
  }
 else {
    try {
      File fileBehindLockFile=new File(cachedFile.getAbsolutePath() + ""String_Node_Str"");
      FileOutputStream lockFile=new FileOutputStream(fileBehindLockFile);
      FileLock lock=null;
      try {
synchronized (fileBehindLockFile.getAbsolutePath().intern()) {
          log.debug(""String_Node_Str"" + fileBehindLockFile.getAbsolutePath() + ""String_Node_Str""+ Thread.currentThread().getName()+ ""String_Node_Str"");
          try {
            lock=lockFile.getChannel().lock();
          }
 catch (          OverlappingFileLockException e) {
            log.warn(e);
            throw new IOException(e);
          }
          if (cachedFile.exists()) {
            return id;
          }
          I found=cacheData(id);
          log.info(""String_Node_Str"" + id + ""String_Node_Str""+ found);
          return id;
        }
      }
  finally {
        if (lock != null) {
          log.debug(""String_Node_Str"" + lockFile.getChannel());
          lock.release();
        }
        lockFile.close();
      }
    }
 catch (    IOException e) {
      String errMsg=""String_Node_Str"" + cachedFile.getAbsolutePath() + ""String_Node_Str"";
      log.warn(errMsg,e);
      throw new IOFailure(errMsg,e);
    }
  }
}","/** 
 * Ensure that a file containing the appropriate content exists for the ID. If the content cannot be found, this method may return null (if I is a simple type) or an appropriate subset (if I is, say, a Set) indicating the data that is actually available.  In the latter case, calling cache on the returned set should always fill the file for that subset (barring catastrophic failure). Locking:  If the file is not immediately found, we enter a file-creation state.  To avoid corrupted data, we must ensure that only one cache instance, and only one thread within any instance, creates the file. Thus as long as somebody else seems to be creating the file, we wait and see if they finish.  This is checked by having an exclusive lock on a "".working"" file (we cannot use the result file, as it has to be created to be locked, and we may end up with a different cached file than we thought, see above).  The .working file itself is irrelevant, only the lock on it matters.
 * @param id Some sort of id that uniquely identifies the item withinthe cache.
 * @return The id given if it was successfully fetched, otherwise nullif the type parameter I does not allow subsets, or a subset of id if it does.  This subset should be immediately cacheable. FIXME added method synchronization. Try to fix bug 1547
 */
public I cache(I id){
  ArgumentNotValid.checkNotNull(id,""String_Node_Str"");
  File cachedFile=getCacheFile(id);
  if (cachedFile.exists()) {
    return id;
  }
 else {
    try {
      File fileBehindLockFile=new File(cachedFile.getAbsolutePath() + ""String_Node_Str"");
      FileOutputStream lockFile=new FileOutputStream(fileBehindLockFile);
      FileLock lock=null;
      try {
synchronized (fileBehindLockFile.getAbsolutePath().intern()) {
          log.debug(""String_Node_Str"" + fileBehindLockFile.getAbsolutePath() + ""String_Node_Str""+ Thread.currentThread().getName()+ ""String_Node_Str"");
          try {
            lock=lockFile.getChannel().lock();
          }
 catch (          OverlappingFileLockException e) {
            log.warn(e);
            throw new IOException(e);
          }
          if (cachedFile.exists()) {
            return id;
          }
          return cacheData(id);
        }
      }
  finally {
        if (lock != null) {
          log.debug(""String_Node_Str"" + lockFile.getChannel());
          lock.release();
        }
        lockFile.close();
      }
    }
 catch (    IOException e) {
      String errMsg=""String_Node_Str"" + cachedFile.getAbsolutePath() + ""String_Node_Str"";
      log.warn(errMsg,e);
      throw new IOFailure(errMsg,e);
    }
  }
}",0.979807510851104
90017,"public void testCombine() throws Exception {
  CDXIndexCache cache=new CDXIndexCache();
  Map<Long,File> files=new HashMap<Long,File>();
  files.put(4L,TestInfo.METADATA_FILE_4);
  files.put(3L,TestInfo.METADATA_FILE_3);
  Set<Long> requiredSet=new HashSet<Long>();
  requiredSet.add(3L);
  requiredSet.add(4L);
  cache.combine(files,requiredSet);
  File cacheFile=cache.getCacheFile(files.keySet());
  FileAsserts.assertFileNumberOfLines(""String_Node_Str"",cacheFile,(int)FileUtils.countLines(TestInfo.METADATA_FILE_3) + (int)FileUtils.countLines(TestInfo.METADATA_FILE_4));
  FileAsserts.assertFileContains(""String_Node_Str"",""String_Node_Str"",cacheFile);
}","public void testCombine() throws Exception {
  CDXIndexCache cache=new CDXIndexCache();
  Map<Long,File> files=new HashMap<Long,File>();
  files.put(4L,TestInfo.METADATA_FILE_4);
  files.put(3L,TestInfo.METADATA_FILE_3);
  Set<Long> requiredSet=new HashSet<Long>();
  requiredSet.add(3L);
  requiredSet.add(4L);
  cache.combine(files);
  File cacheFile=cache.getCacheFile(files.keySet());
  FileAsserts.assertFileNumberOfLines(""String_Node_Str"",cacheFile,(int)FileUtils.countLines(TestInfo.METADATA_FILE_3) + (int)FileUtils.countLines(TestInfo.METADATA_FILE_4));
  FileAsserts.assertFileContains(""String_Node_Str"",""String_Node_Str"",cacheFile);
}",0.9907834101382488
90018,"public void testCacheData() throws Exception {
  final Map<Integer,File> combined=new HashMap<Integer,File>();
  final Set<Integer> rawgotten=new HashSet<Integer>();
  CombiningMultiFileBasedCache<Integer> cache=new CombiningMultiFileBasedCache<Integer>(""String_Node_Str"",new FileBasedCache<Integer>(""String_Node_Str""){
    public File getCacheFile(    Integer id){
      return new File(TestInfo.CRAWLLOGS_DIR,""String_Node_Str"" + id + ""String_Node_Str"");
    }
    public Integer cache(    Integer id){
      rawgotten.add(id);
      return super.cache(id);
    }
    protected Integer cacheData(    Integer id){
      return null;
    }
  }
){
    protected void combine(    Map<Integer,File> filesFound,    Set<Integer> requiredSet){
      File resultFile=getCacheFile(filesFound.keySet());
      combined.clear();
      combined.putAll(filesFound);
      try {
        resultFile.createNewFile();
      }
 catch (      IOException e) {
        throw new IOFailure(""String_Node_Str"",e);
      }
    }
  }
;
  Set<Integer> ids=new HashSet<Integer>();
  ids.add(1);
  ids.add(4);
  checkContainsExactly(""String_Node_Str"",list(1,4),cache.cache(ids));
  checkContainsExactly(""String_Node_Str"",list(1,4),combined.keySet());
  combined.clear();
  checkContainsExactly(""String_Node_Str"",list(1,4),cache.cache(ids));
  assertTrue(""String_Node_Str"",combined.isEmpty());
  ids.remove(4);
  ids.add(5);
  rawgotten.clear();
  checkContainsExactly(""String_Node_Str"",list(1),cache.cache(ids));
  checkContainsExactly(""String_Node_Str"",list(1,5),rawgotten);
  assertEquals(""String_Node_Str"",0,combined.size());
}","public void testCacheData() throws Exception {
  final Map<Integer,File> combined=new HashMap<Integer,File>();
  final Set<Integer> rawgotten=new HashSet<Integer>();
  CombiningMultiFileBasedCache<Integer> cache=new CombiningMultiFileBasedCache<Integer>(""String_Node_Str"",new FileBasedCache<Integer>(""String_Node_Str""){
    public File getCacheFile(    Integer id){
      return new File(TestInfo.CRAWLLOGS_DIR,""String_Node_Str"" + id + ""String_Node_Str"");
    }
    public Integer cache(    Integer id){
      rawgotten.add(id);
      return super.cache(id);
    }
    protected Integer cacheData(    Integer id){
      return null;
    }
  }
){
    protected void combine(    Map<Integer,File> filesFound){
      File resultFile=getCacheFile(filesFound.keySet());
      combined.clear();
      combined.putAll(filesFound);
      try {
        resultFile.createNewFile();
      }
 catch (      IOException e) {
        throw new IOFailure(""String_Node_Str"",e);
      }
    }
  }
;
  Set<Integer> ids=new HashSet<Integer>();
  ids.add(1);
  ids.add(4);
  checkContainsExactly(""String_Node_Str"",list(1,4),cache.cache(ids));
  checkContainsExactly(""String_Node_Str"",list(1,4),combined.keySet());
  combined.clear();
  checkContainsExactly(""String_Node_Str"",list(1,4),cache.cache(ids));
  assertTrue(""String_Node_Str"",combined.isEmpty());
  ids.remove(4);
  ids.add(5);
  rawgotten.clear();
  checkContainsExactly(""String_Node_Str"",list(1),cache.cache(ids));
  checkContainsExactly(""String_Node_Str"",list(1,5),rawgotten);
  assertEquals(""String_Node_Str"",0,combined.size());
}",0.9908603844941696
90019,"protected void combine(Map<Integer,File> filesFound,Set<Integer> requiredSet){
  File resultFile=getCacheFile(filesFound.keySet());
  combined.clear();
  combined.putAll(filesFound);
  try {
    resultFile.createNewFile();
  }
 catch (  IOException e) {
    throw new IOFailure(""String_Node_Str"",e);
  }
}","protected void combine(Map<Integer,File> filesFound){
  File resultFile=getCacheFile(filesFound.keySet());
  combined.clear();
  combined.putAll(filesFound);
  try {
    resultFile.createNewFile();
  }
 catch (  IOException e) {
    throw new IOFailure(""String_Node_Str"",e);
  }
}",0.9572649572649572
90020,"public void testCombine() throws Exception {
  Map<String,String> origins=new HashMap<String,String>(8);
  origins.put(""String_Node_Str"",""String_Node_Str"");
  origins.put(""String_Node_Str"",""String_Node_Str"");
  origins.put(""String_Node_Str"",""String_Node_Str"");
  origins.put(""String_Node_Str"",""String_Node_Str"");
  origins.put(""String_Node_Str"",""String_Node_Str"");
  origins.put(""String_Node_Str"",""String_Node_Str"");
  origins.put(""String_Node_Str"",""String_Node_Str"");
  origins.put(""String_Node_Str"",""String_Node_Str"");
  Map<Long,File> files=new HashMap<Long,File>();
  files.put(1L,TestInfo.CRAWL_LOG_1);
  files.put(4L,TestInfo.CRAWL_LOG_4);
  Set<Long> requiredSet=new HashSet<Long>();
  requiredSet.add(1L);
  requiredSet.add(4L);
  DedupCrawlLogIndexCache cache=new DedupCrawlLogIndexCache();
  File resultFile=cache.getCacheFile(files.keySet());
  setDummyCDXCache(cache);
  cache.combine(files,requiredSet);
  assertTrue(""String_Node_Str"",resultFile.length() > 0);
  assertFalse(""String_Node_Str"",new File(resultFile.getAbsolutePath().substring(0,resultFile.getAbsolutePath().length() - 4)).exists());
  File unzipDir=new File(TestInfo.WORKING_DIR,""String_Node_Str"");
  unzipDir.mkdir();
  File[] resultFiles=resultFile.listFiles();
  for (  File f : resultFiles) {
    if (f.getName().endsWith(""String_Node_Str"")) {
      InputStream in=new GZIPInputStream(new FileInputStream(f));
      FileUtils.writeStreamToFile(in,new File(unzipDir,f.getName().substring(0,f.getName().length() - ""String_Node_Str"".length())));
      in.close();
    }
  }
  String indexName=unzipDir.getAbsolutePath();
  IndexSearcher index=new IndexSearcher(indexName);
  QueryParser queryParser=new QueryParser(""String_Node_Str"",new WhitespaceAnalyzer());
  Query q=queryParser.parse(""String_Node_Str"");
  Hits hits=index.search(q);
  for (int i=0; i < hits.length(); i++) {
    Document doc=hits.doc(i);
    String url=doc.get(""String_Node_Str"");
    String origin=doc.get(""String_Node_Str"");
    assertEquals(""String_Node_Str"" + url,origins.get(url),origin);
    origins.remove(url);
  }
  assertTrue(""String_Node_Str"" + origins,origins.isEmpty());
}","public void testCombine() throws Exception {
  Map<String,String> origins=new HashMap<String,String>(8);
  origins.put(""String_Node_Str"",""String_Node_Str"");
  origins.put(""String_Node_Str"",""String_Node_Str"");
  origins.put(""String_Node_Str"",""String_Node_Str"");
  origins.put(""String_Node_Str"",""String_Node_Str"");
  origins.put(""String_Node_Str"",""String_Node_Str"");
  origins.put(""String_Node_Str"",""String_Node_Str"");
  origins.put(""String_Node_Str"",""String_Node_Str"");
  origins.put(""String_Node_Str"",""String_Node_Str"");
  Map<Long,File> files=new HashMap<Long,File>();
  files.put(1L,TestInfo.CRAWL_LOG_1);
  files.put(4L,TestInfo.CRAWL_LOG_4);
  Set<Long> requiredSet=new HashSet<Long>();
  requiredSet.add(1L);
  requiredSet.add(4L);
  DedupCrawlLogIndexCache cache=new DedupCrawlLogIndexCache();
  File resultFile=cache.getCacheFile(files.keySet());
  setDummyCDXCache(cache);
  cache.combine(files);
  assertTrue(""String_Node_Str"",resultFile.length() > 0);
  assertFalse(""String_Node_Str"",new File(resultFile.getAbsolutePath().substring(0,resultFile.getAbsolutePath().length() - 4)).exists());
  File unzipDir=new File(TestInfo.WORKING_DIR,""String_Node_Str"");
  unzipDir.mkdir();
  File[] resultFiles=resultFile.listFiles();
  for (  File f : resultFiles) {
    if (f.getName().endsWith(""String_Node_Str"")) {
      InputStream in=new GZIPInputStream(new FileInputStream(f));
      FileUtils.writeStreamToFile(in,new File(unzipDir,f.getName().substring(0,f.getName().length() - ""String_Node_Str"".length())));
      in.close();
    }
  }
  String indexName=unzipDir.getAbsolutePath();
  IndexSearcher index=new IndexSearcher(indexName);
  QueryParser queryParser=new QueryParser(""String_Node_Str"",new WhitespaceAnalyzer());
  Query q=queryParser.parse(""String_Node_Str"");
  Hits hits=index.search(q);
  for (int i=0; i < hits.length(); i++) {
    Document doc=hits.doc(i);
    String url=doc.get(""String_Node_Str"");
    String origin=doc.get(""String_Node_Str"");
    assertEquals(""String_Node_Str"" + url,origins.get(url),origin);
    origins.remove(url);
  }
  assertTrue(""String_Node_Str"" + origins,origins.isEmpty());
}",0.9971817754814468
90021,"/** 
 * Combine parts of an index into one big index.
 * @param filesFound A map of IDs and the files caching their content.
 */
protected void combine(Map<Long,File> filesFound){
  File resultFile=getCacheFile(filesFound.keySet());
  concatenateFiles(filesFound.values(),resultFile);
  sortFile(resultFile);
}","/** 
 * Combine parts of an index into one big index.
 * @param filesFound A map of IDs and the files caching their content.
 */
protected void combine(Map<Long,File> filesFound,Set<Long> filesRequired){
  File resultFile=getCacheFile(filesFound.keySet());
  concatenateFiles(filesFound.values(),resultFile);
  sortFile(resultFile);
}",0.9627329192546584
90022,"/** 
 * This is called when an appropriate file for the ids in question has not been found.  It is expected to do the actual operations necessary to get the data.  At the outset, the file for the given IDs is expected to be not present.
 * @param ids
 * @return The set of IDs, or subset if data fetching failed for some IDs.If some IDs failed, the file is not filled, though some data may be cached at a lower level.
 */
protected Set<T> cacheData(Set<T> ids){
  Map<T,File> filesFound=prepareCombine(ids);
  File resultFile=getCacheFile(ids);
  if (filesFound.size() == ids.size()) {
    combine(filesFound);
  }
 else {
    FileUtils.remove(resultFile);
  }
  return filesFound.keySet();
}","/** 
 * This is called when an appropriate file for the ids in question has not been found.  It is expected to do the actual operations necessary to get the data.  At the outset, the file for the given IDs is expected to be not present.
 * @param ids
 * @return The set of IDs, or subset if data fetching failed for some IDs.If some IDs failed, the file is not filled, though some data may be cached at a lower level.
 */
protected Set<T> cacheData(Set<T> ids){
  Map<T,File> filesFound=prepareCombine(ids);
  File resultFile=getCacheFile(ids);
  if (filesFound.size() == ids.size()) {
    combine(filesFound,ids);
  }
 else {
    FileUtils.remove(resultFile);
  }
  return filesFound.keySet();
}",0.9971181556195964
90023,"/** 
 * Combine a set of files found in the raw data cache to form our kind of file.
 * @param filesFound The files that were found for the IDs in the rawdata cache.  The map must not contain any null values.
 */
protected abstract void combine(Map<T,File> filesFound);","/** 
 * Combine a set of files found in the raw data cache to form our kind of file.
 * @param filesFound The files that were found for the IDs in the rawdata cache.  The map must not contain any null values.
 * @param filesRequired The set of IDs required
 */
protected abstract void combine(Map<T,File> filesFound,Set<T> filesRequired);",0.886326194398682
90024,"/** 
 * Prepare data for combining.  This class overrides prepareCombine to make sure that CDX data is available.
 * @param IDs Set of IDs that will be combined.
 * @return Map of ID->File of data to combine for the IDs where we couldfind data.
 */
protected Map<Long,File> prepareCombine(Set<Long> IDs){
  log.info(""String_Node_Str"" + getCacheDir().getName() + ""String_Node_Str""+ IDs);
  Map<Long,File> returnMap=super.prepareCombine(IDs);
  Set<Long> missing=new HashSet<Long>();
  for (  Long ID : returnMap.keySet()) {
    Long cached=cdxcache.cache(ID);
    if (cached == null) {
      missing.add(ID);
    }
  }
  for (  Long ID : missing) {
    returnMap.remove(ID);
  }
  return returnMap;
}","/** 
 * Prepare data for combining.  This class overrides prepareCombine to make sure that CDX data is available.
 * @param IDs Set of IDs that will be combined.
 * @return Map of ID->File of data to combine for the IDs where we couldfind data.
 */
protected Map<Long,File> prepareCombine(Set<Long> IDs){
  log.info(""String_Node_Str"" + getCacheDir().getName() + ""String_Node_Str""+ IDs);
  Map<Long,File> returnMap=super.prepareCombine(IDs);
  Set<Long> missing=new HashSet<Long>();
  for (  Long ID : returnMap.keySet()) {
    Long cached=cdxcache.cache(ID);
    if (cached == null) {
      missing.add(ID);
    }
  }
  log.info(""String_Node_Str"" + missing);
  for (  Long ID : missing) {
    returnMap.remove(ID);
  }
  return returnMap;
}",0.9715079916608756
90025,"/** 
 * Combine a number of crawl.log files into one Lucene index.  This index is placed as gzip files under the directory returned by getCacheFile().
 * @param rawfiles The map from job ID into crawl.log contents.  Nonull values are allowed in this map.
 */
protected void combine(Map<Long,File> rawfiles){
  File resultFile=getCacheFile(rawfiles.keySet());
  String indexLocation=resultFile.getAbsolutePath() + ""String_Node_Str"";
  try {
    String indexingMode=DigestIndexer.MODE_BOTH;
    boolean includeNormalizedURL=false;
    boolean includeTimestamp=true;
    boolean includeEtag=true;
    boolean addToExistingIndex=false;
    DigestIndexer indexer=new DigestIndexer(indexLocation,indexingMode,includeNormalizedURL,includeTimestamp,includeEtag,addToExistingIndex);
    for (    Map.Entry<Long,File> entry : rawfiles.entrySet()) {
      indexFile(entry.getKey(),entry.getValue(),indexer);
    }
    indexer.close(OPTIMIZE_INDEX);
    ZipUtils.gzipFiles(new File(indexLocation),resultFile);
  }
 catch (  IOException e) {
    throw new IOFailure(""String_Node_Str"" + resultFile,e);
  }
 finally {
    FileUtils.removeRecursively(new File(indexLocation));
  }
}","/** 
 * Combine a number of crawl.log files into one Lucene index.  This index is placed as gzip files under the directory returned by getCacheFile().
 * @param rawfiles The map from job ID into crawl.log contents. Nonull values are allowed in this map.
 * @param askedJobIds The set of jobIds actually needed
 */
protected void combine(Map<Long,File> rawfiles,Set<Long> askedJobIds){
  File resultFile=getCacheFile(askedJobIds);
  String indexLocation=resultFile.getAbsolutePath() + ""String_Node_Str"";
  try {
    String indexingMode=DigestIndexer.MODE_BOTH;
    boolean includeNormalizedURL=false;
    boolean includeTimestamp=true;
    boolean includeEtag=true;
    boolean addToExistingIndex=false;
    DigestIndexer indexer=new DigestIndexer(indexLocation,indexingMode,includeNormalizedURL,includeTimestamp,includeEtag,addToExistingIndex);
    for (    Map.Entry<Long,File> entry : rawfiles.entrySet()) {
      indexFile(entry.getKey(),entry.getValue(),indexer);
    }
    indexer.close(OPTIMIZE_INDEX);
    ZipUtils.gzipFiles(new File(indexLocation),resultFile);
  }
 catch (  IOException e) {
    throw new IOFailure(""String_Node_Str"" + resultFile,e);
  }
 finally {
    FileUtils.removeRecursively(new File(indexLocation));
  }
}",0.957136912193092
90026,"public void testCombine() throws Exception {
  CDXIndexCache cache=new CDXIndexCache();
  Map<Long,File> files=new HashMap<Long,File>();
  files.put(4L,TestInfo.METADATA_FILE_4);
  files.put(3L,TestInfo.METADATA_FILE_3);
  cache.combine(files);
  File cacheFile=cache.getCacheFile(files.keySet());
  FileAsserts.assertFileNumberOfLines(""String_Node_Str"",cacheFile,(int)FileUtils.countLines(TestInfo.METADATA_FILE_3) + (int)FileUtils.countLines(TestInfo.METADATA_FILE_4));
  FileAsserts.assertFileContains(""String_Node_Str"",""String_Node_Str"",cacheFile);
}","public void testCombine() throws Exception {
  CDXIndexCache cache=new CDXIndexCache();
  Map<Long,File> files=new HashMap<Long,File>();
  files.put(4L,TestInfo.METADATA_FILE_4);
  files.put(3L,TestInfo.METADATA_FILE_3);
  Set<Long> requiredSet=new HashSet<Long>();
  requiredSet.add(3L);
  requiredSet.add(4L);
  cache.combine(files,requiredSet);
  File cacheFile=cache.getCacheFile(files.keySet());
  FileAsserts.assertFileNumberOfLines(""String_Node_Str"",cacheFile,(int)FileUtils.countLines(TestInfo.METADATA_FILE_3) + (int)FileUtils.countLines(TestInfo.METADATA_FILE_4));
  FileAsserts.assertFileContains(""String_Node_Str"",""String_Node_Str"",cacheFile);
}",0.9149463253509496
90027,"public void testCacheData() throws Exception {
  final Map<Integer,File> combined=new HashMap<Integer,File>();
  final Set<Integer> rawgotten=new HashSet<Integer>();
  CombiningMultiFileBasedCache<Integer> cache=new CombiningMultiFileBasedCache<Integer>(""String_Node_Str"",new FileBasedCache<Integer>(""String_Node_Str""){
    public File getCacheFile(    Integer id){
      return new File(TestInfo.CRAWLLOGS_DIR,""String_Node_Str"" + id + ""String_Node_Str"");
    }
    public Integer cache(    Integer id){
      rawgotten.add(id);
      return super.cache(id);
    }
    protected Integer cacheData(    Integer id){
      return null;
    }
  }
){
    protected void combine(    Map<Integer,File> filesFound){
      File resultFile=getCacheFile(filesFound.keySet());
      combined.clear();
      combined.putAll(filesFound);
      try {
        resultFile.createNewFile();
      }
 catch (      IOException e) {
        throw new IOFailure(""String_Node_Str"",e);
      }
    }
  }
;
  Set<Integer> ids=new HashSet<Integer>();
  ids.add(1);
  ids.add(4);
  checkContainsExactly(""String_Node_Str"",list(1,4),cache.cache(ids));
  checkContainsExactly(""String_Node_Str"",list(1,4),combined.keySet());
  combined.clear();
  checkContainsExactly(""String_Node_Str"",list(1,4),cache.cache(ids));
  assertTrue(""String_Node_Str"",combined.isEmpty());
  ids.remove(4);
  ids.add(5);
  rawgotten.clear();
  checkContainsExactly(""String_Node_Str"",list(1),cache.cache(ids));
  checkContainsExactly(""String_Node_Str"",list(1,5),rawgotten);
  assertEquals(""String_Node_Str"",0,combined.size());
}","public void testCacheData() throws Exception {
  final Map<Integer,File> combined=new HashMap<Integer,File>();
  final Set<Integer> rawgotten=new HashSet<Integer>();
  CombiningMultiFileBasedCache<Integer> cache=new CombiningMultiFileBasedCache<Integer>(""String_Node_Str"",new FileBasedCache<Integer>(""String_Node_Str""){
    public File getCacheFile(    Integer id){
      return new File(TestInfo.CRAWLLOGS_DIR,""String_Node_Str"" + id + ""String_Node_Str"");
    }
    public Integer cache(    Integer id){
      rawgotten.add(id);
      return super.cache(id);
    }
    protected Integer cacheData(    Integer id){
      return null;
    }
  }
){
    protected void combine(    Map<Integer,File> filesFound,    Set<Integer> requiredSet){
      File resultFile=getCacheFile(filesFound.keySet());
      combined.clear();
      combined.putAll(filesFound);
      try {
        resultFile.createNewFile();
      }
 catch (      IOException e) {
        throw new IOFailure(""String_Node_Str"",e);
      }
    }
  }
;
  Set<Integer> ids=new HashSet<Integer>();
  ids.add(1);
  ids.add(4);
  checkContainsExactly(""String_Node_Str"",list(1,4),cache.cache(ids));
  checkContainsExactly(""String_Node_Str"",list(1,4),combined.keySet());
  combined.clear();
  checkContainsExactly(""String_Node_Str"",list(1,4),cache.cache(ids));
  assertTrue(""String_Node_Str"",combined.isEmpty());
  ids.remove(4);
  ids.add(5);
  rawgotten.clear();
  checkContainsExactly(""String_Node_Str"",list(1),cache.cache(ids));
  checkContainsExactly(""String_Node_Str"",list(1,5),rawgotten);
  assertEquals(""String_Node_Str"",0,combined.size());
}",0.9908603844941696
90028,"protected void combine(Map<Integer,File> filesFound){
  File resultFile=getCacheFile(filesFound.keySet());
  combined.clear();
  combined.putAll(filesFound);
  try {
    resultFile.createNewFile();
  }
 catch (  IOException e) {
    throw new IOFailure(""String_Node_Str"",e);
  }
}","protected void combine(Map<Integer,File> filesFound,Set<Integer> requiredSet){
  File resultFile=getCacheFile(filesFound.keySet());
  combined.clear();
  combined.putAll(filesFound);
  try {
    resultFile.createNewFile();
  }
 catch (  IOException e) {
    throw new IOFailure(""String_Node_Str"",e);
  }
}",0.9572649572649572
90029,"public void testCombine() throws Exception {
  Map<String,String> origins=new HashMap<String,String>(8);
  origins.put(""String_Node_Str"",""String_Node_Str"");
  origins.put(""String_Node_Str"",""String_Node_Str"");
  origins.put(""String_Node_Str"",""String_Node_Str"");
  origins.put(""String_Node_Str"",""String_Node_Str"");
  origins.put(""String_Node_Str"",""String_Node_Str"");
  origins.put(""String_Node_Str"",""String_Node_Str"");
  origins.put(""String_Node_Str"",""String_Node_Str"");
  origins.put(""String_Node_Str"",""String_Node_Str"");
  Map<Long,File> files=new HashMap<Long,File>();
  files.put(1L,TestInfo.CRAWL_LOG_1);
  files.put(4L,TestInfo.CRAWL_LOG_4);
  DedupCrawlLogIndexCache cache=new DedupCrawlLogIndexCache();
  File resultFile=cache.getCacheFile(files.keySet());
  setDummyCDXCache(cache);
  cache.combine(files);
  assertTrue(""String_Node_Str"",resultFile.length() > 0);
  assertFalse(""String_Node_Str"",new File(resultFile.getAbsolutePath().substring(0,resultFile.getAbsolutePath().length() - 4)).exists());
  File unzipDir=new File(TestInfo.WORKING_DIR,""String_Node_Str"");
  unzipDir.mkdir();
  File[] resultFiles=resultFile.listFiles();
  for (  File f : resultFiles) {
    if (f.getName().endsWith(""String_Node_Str"")) {
      InputStream in=new GZIPInputStream(new FileInputStream(f));
      FileUtils.writeStreamToFile(in,new File(unzipDir,f.getName().substring(0,f.getName().length() - ""String_Node_Str"".length())));
      in.close();
    }
  }
  String indexName=unzipDir.getAbsolutePath();
  IndexSearcher index=new IndexSearcher(indexName);
  QueryParser queryParser=new QueryParser(""String_Node_Str"",new WhitespaceAnalyzer());
  Query q=queryParser.parse(""String_Node_Str"");
  Hits hits=index.search(q);
  for (int i=0; i < hits.length(); i++) {
    Document doc=hits.doc(i);
    String url=doc.get(""String_Node_Str"");
    String origin=doc.get(""String_Node_Str"");
    assertEquals(""String_Node_Str"" + url,origins.get(url),origin);
    origins.remove(url);
  }
  assertTrue(""String_Node_Str"" + origins,origins.isEmpty());
}","public void testCombine() throws Exception {
  Map<String,String> origins=new HashMap<String,String>(8);
  origins.put(""String_Node_Str"",""String_Node_Str"");
  origins.put(""String_Node_Str"",""String_Node_Str"");
  origins.put(""String_Node_Str"",""String_Node_Str"");
  origins.put(""String_Node_Str"",""String_Node_Str"");
  origins.put(""String_Node_Str"",""String_Node_Str"");
  origins.put(""String_Node_Str"",""String_Node_Str"");
  origins.put(""String_Node_Str"",""String_Node_Str"");
  origins.put(""String_Node_Str"",""String_Node_Str"");
  Map<Long,File> files=new HashMap<Long,File>();
  files.put(1L,TestInfo.CRAWL_LOG_1);
  files.put(4L,TestInfo.CRAWL_LOG_4);
  Set<Long> requiredSet=new HashSet<Long>();
  requiredSet.add(1L);
  requiredSet.add(4L);
  DedupCrawlLogIndexCache cache=new DedupCrawlLogIndexCache();
  File resultFile=cache.getCacheFile(files.keySet());
  setDummyCDXCache(cache);
  cache.combine(files,requiredSet);
  assertTrue(""String_Node_Str"",resultFile.length() > 0);
  assertFalse(""String_Node_Str"",new File(resultFile.getAbsolutePath().substring(0,resultFile.getAbsolutePath().length() - 4)).exists());
  File unzipDir=new File(TestInfo.WORKING_DIR,""String_Node_Str"");
  unzipDir.mkdir();
  File[] resultFiles=resultFile.listFiles();
  for (  File f : resultFiles) {
    if (f.getName().endsWith(""String_Node_Str"")) {
      InputStream in=new GZIPInputStream(new FileInputStream(f));
      FileUtils.writeStreamToFile(in,new File(unzipDir,f.getName().substring(0,f.getName().length() - ""String_Node_Str"".length())));
      in.close();
    }
  }
  String indexName=unzipDir.getAbsolutePath();
  IndexSearcher index=new IndexSearcher(indexName);
  QueryParser queryParser=new QueryParser(""String_Node_Str"",new WhitespaceAnalyzer());
  Query q=queryParser.parse(""String_Node_Str"");
  Hits hits=index.search(q);
  for (int i=0; i < hits.length(); i++) {
    Document doc=hits.doc(i);
    String url=doc.get(""String_Node_Str"");
    String origin=doc.get(""String_Node_Str"");
    assertEquals(""String_Node_Str"" + url,origins.get(url),origin);
    origins.remove(url);
  }
  assertTrue(""String_Node_Str"" + origins,origins.isEmpty());
}",0.9752819774418048
90030,"/** 
 * Creates the jmxremote.password file, based on the settings.
 * @param directory The local directory for this machine 
 */
protected void createJmxRemoteAccessFile(File directory){
  ArgumentNotValid.checkNotNull(directory,""String_Node_Str"");
  File jmxFile=new File(directory,Constants.JMX_ACCESS_FILE_NAME);
  try {
    PrintWriter jw=new PrintWriter(jmxFile);
    try {
      jw.print(ScriptConstants.JMXREMOTE_ACCESS_HEADER);
      StringBuilder logins=new StringBuilder();
      logins.append(getMonitorUsername());
      jw.print(logins.toString());
    }
  finally {
      jw.close();
    }
  }
 catch (  IOException e) {
    String msg=""String_Node_Str"" + e;
    log.trace(msg);
    throw new IOFailure(msg);
  }
catch (  Exception e) {
    String msg=""String_Node_Str"" + e;
    log.trace(msg);
    System.out.println(msg);
  }
}","/** 
 * Creates the jmxremote.password file, based on the settings.
 * @param directory The local directory for this machine 
 */
protected void createJmxRemoteAccessFile(File directory){
  ArgumentNotValid.checkNotNull(directory,""String_Node_Str"");
  File jmxFile=new File(directory,Constants.JMX_ACCESS_FILE_NAME);
  try {
    PrintWriter jw=new PrintWriter(jmxFile);
    try {
      jw.print(ScriptConstants.JMXREMOTE_ACCESS_HEADER);
      StringBuilder logins=new StringBuilder();
      logins.append(getMonitorUsername());
      logins.append(getHeritrixUsername());
      jw.print(logins.toString());
    }
  finally {
      jw.close();
    }
  }
 catch (  IOException e) {
    String msg=""String_Node_Str"" + e;
    log.trace(msg);
    throw new IOFailure(msg);
  }
catch (  Exception e) {
    String msg=""String_Node_Str"" + e;
    log.trace(msg);
    System.out.println(msg);
  }
}",0.97459584295612
90031,"/** 
 * For finding the jmxUsernames and jmxPasswords under the monitor branch in the settings.  Goes through all applications, which all must have the same  username and the same passwords.  
 * @return The string to add to the jmxremote.password file.
 * @throws Exception If there is a different amount of usernames and passwords, or if two application has different values for their username or passwords (applications without values are ignored). 
 */
protected String getMonitorLogin() throws Exception {
  StringBuilder res=new StringBuilder();
  List<String> usernames=new ArrayList<String>();
  List<String> passwords=new ArrayList<String>();
  String[] tmpVals;
  for (  Application app : applications) {
    tmpVals=app.getSettingsValues(Constants.SETTINGS_MONITOR_JMX_NAME_LEAF);
    if (tmpVals != null && tmpVals.length > 0) {
      for (      String st : tmpVals) {
        usernames.add(st);
      }
    }
    tmpVals=app.getSettingsValues(Constants.SETTINGS_MONITOR_JMX_PASSWORD_LEAF);
    if (tmpVals != null && tmpVals.length > 0) {
      for (      String st : tmpVals) {
        passwords.add(st);
      }
    }
  }
  if (usernames.size() != passwords.size()) {
    String msg=""String_Node_Str"" + ""String_Node_Str"" + name + ""String_Node_Str"";
    log.warn(msg);
    throw new Exception(msg);
  }
  if (usernames.size() == 0) {
    String msg=""String_Node_Str"" + name + ""String_Node_Str"";
    log.warn(msg);
    throw new IllegalState(msg);
  }
  for (int i=1; i < usernames.size(); i++) {
    if (!usernames.get(0).equals(usernames.get(i)) || !passwords.get(0).equals(passwords.get(i))) {
      String msg=""String_Node_Str"" + ""String_Node_Str"" + name + ""String_Node_Str"";
      log.warn(msg);
      throw new Exception(msg);
    }
  }
  if (usernames.size() > 0) {
    res.append(usernames.get(0));
    res.append(Constants.SPACE);
    res.append(passwords.get(0));
    res.append(Constants.NEWLINE);
  }
  return res.toString();
}","/** 
 * For finding the jmxUsernames and jmxPasswords under the monitor branch in the settings.  Goes through all applications, which all must have the same  username and the same passwords.  
 * @return The string to add to the jmxremote.password file.
 * @throws Exception If there is a different amount of usernames and passwords, or if two application has different values for their username or passwords (applications without values are ignored). 
 */
protected String getMonitorLogin() throws Exception {
  StringBuilder res=new StringBuilder();
  List<String> usernames=new ArrayList<String>();
  List<String> passwords=new ArrayList<String>();
  String[] tmpVals;
  for (  Application app : applications) {
    tmpVals=app.getSettingsValues(Constants.SETTINGS_MONITOR_JMX_NAME_LEAF);
    if (tmpVals != null && tmpVals.length > 0) {
      for (      String st : tmpVals) {
        usernames.add(st);
      }
    }
    tmpVals=app.getSettingsValues(Constants.SETTINGS_MONITOR_JMX_PASSWORD_LEAF);
    if (tmpVals != null && tmpVals.length > 0) {
      for (      String st : tmpVals) {
        passwords.add(st);
      }
    }
  }
  if (usernames.size() != passwords.size()) {
    String msg=""String_Node_Str"" + ""String_Node_Str"" + name + ""String_Node_Str"";
    log.warn(msg);
    throw new Exception(msg);
  }
  if (usernames.size() == 0) {
    log.warn(""String_Node_Str"" + name + ""String_Node_Str"");
  }
  for (int i=1; i < usernames.size(); i++) {
    if (!usernames.get(0).equals(usernames.get(i)) || !passwords.get(0).equals(passwords.get(i))) {
      String msg=""String_Node_Str"" + ""String_Node_Str"" + name + ""String_Node_Str"";
      log.warn(msg);
      throw new Exception(msg);
    }
  }
  if (usernames.size() > 0) {
    res.append(usernames.get(0));
    res.append(Constants.SPACE);
    res.append(passwords.get(0));
    res.append(Constants.NEWLINE);
  }
  return res.toString();
}",0.9815632303297844
90032,"/** 
 * For retrieving the monitor username for the jmxremote.access file. This will have the rights 'readonly'.
 * @return The string for the jmxremote.access file for allowing the monitor user to readonly.
 */
protected String getMonitorUsername(){
  StringBuilder res=new StringBuilder();
  List<String> usernames=new ArrayList<String>();
  String[] tmpVals;
  for (  Application app : applications) {
    tmpVals=app.getSettingsValues(Constants.SETTINGS_MONITOR_JMX_NAME_LEAF);
    if (tmpVals != null && tmpVals.length > 0) {
      for (      String st : tmpVals) {
        usernames.add(st);
      }
    }
  }
  if (usernames.size() == 0) {
    String msg=""String_Node_Str"" + name + ""String_Node_Str"";
    log.warn(msg);
    throw new IllegalState(msg);
  }
  for (int i=1; i < usernames.size(); i++) {
    if (!usernames.get(0).equals(usernames.get(i))) {
      String msg=""String_Node_Str"" + ""String_Node_Str"" + name + ""String_Node_Str"";
      log.warn(msg);
      throw new IllegalState(msg);
    }
  }
  if (usernames.size() > 0) {
    res.append(usernames.get(0));
    res.append(Constants.SPACE);
    res.append(ScriptConstants.JMXREMOTE_ACCESS_MONITORROLE);
    res.append(Constants.NEWLINE);
  }
  return res.toString();
}","/** 
 * For retrieving the monitor username for the jmxremote.access file. This will have the rights 'readonly'.
 * @return The string for the jmxremote.access file for allowing the monitor user to readonly.
 */
protected String getMonitorUsername(){
  StringBuilder res=new StringBuilder();
  List<String> usernames=new ArrayList<String>();
  String[] tmpVals;
  for (  Application app : applications) {
    tmpVals=app.getSettingsValues(Constants.SETTINGS_MONITOR_JMX_NAME_LEAF);
    if (tmpVals != null && tmpVals.length > 0) {
      for (      String st : tmpVals) {
        usernames.add(st);
      }
    }
  }
  for (int i=1; i < usernames.size(); i++) {
    if (!usernames.get(0).equals(usernames.get(i))) {
      String msg=""String_Node_Str"" + ""String_Node_Str"" + name + ""String_Node_Str"";
      log.warn(msg);
      throw new IllegalState(msg);
    }
  }
  if (usernames.size() > 0) {
    res.append(usernames.get(0));
    res.append(Constants.SPACE);
    res.append(ScriptConstants.JMXREMOTE_ACCESS_MONITOR);
    res.append(Constants.NEWLINE);
  }
  return res.toString();
}",0.9344827586206896
90033,"/** 
 * For retrieving the hetrix username for the jmxremote.access file. This will have the rights 'readonly'.
 * @return The string for the jmxremote.access file for allowing the heritrix user to readonly.
 */
protected String getHeritrixUsername(){
  StringBuilder res=new StringBuilder();
  List<String> usernames=new ArrayList<String>();
  String[] tmpVals;
  for (  Application app : applications) {
    tmpVals=app.getSettingsValues(Constants.SETTINGS_HERITRIX_JMX_USERNAME_LEAF);
    if (tmpVals != null && tmpVals.length > 0) {
      for (      String st : tmpVals) {
        usernames.add(st);
      }
    }
  }
  if (usernames.size() == 0) {
    String msg=""String_Node_Str"" + name + ""String_Node_Str"";
    log.warn(msg);
    throw new IllegalState(msg);
  }
  for (int i=1; i < usernames.size(); i++) {
    if (!usernames.get(0).equals(usernames.get(i))) {
      String msg=""String_Node_Str"" + ""String_Node_Str"" + name + ""String_Node_Str"";
      log.warn(msg);
      throw new IllegalState(msg);
    }
  }
  if (usernames.size() > 0) {
    res.append(usernames.get(0));
    res.append(Constants.SPACE);
    res.append(ScriptConstants.JMXREMOTE_ACCESS_CONTROLROLE);
    res.append(Constants.NEWLINE);
  }
  return res.toString();
}","/** 
 * For retrieving the hetrix username for the jmxremote.access file. This will have the rights 'readonly'.
 * @return The string for the jmxremote.access file for allowing the heritrix user to readonly.
 */
protected String getHeritrixUsername(){
  StringBuilder res=new StringBuilder();
  List<String> usernames=new ArrayList<String>();
  String[] tmpVals;
  for (  Application app : applications) {
    tmpVals=app.getSettingsValues(Constants.SETTINGS_HERITRIX_JMX_USERNAME_LEAF);
    if (tmpVals != null && tmpVals.length > 0) {
      for (      String st : tmpVals) {
        usernames.add(st);
      }
    }
  }
  for (int i=1; i < usernames.size(); i++) {
    if (!usernames.get(0).equals(usernames.get(i))) {
      String msg=""String_Node_Str"" + ""String_Node_Str"" + name + ""String_Node_Str"";
      log.warn(msg);
      throw new IllegalState(msg);
    }
  }
  if (usernames.size() > 0) {
    res.append(usernames.get(0));
    res.append(Constants.SPACE);
    res.append(ScriptConstants.JMXREMOTE_ACCESS_CONTROL);
    res.append(Constants.NEWLINE);
  }
  return res.toString();
}",0.934819897084048
90034,"/** 
 * This method does the following: Retrieves the path to the jmxremote.access and jmxremote.password files. Moves these files, if they are different from standard. Makes the jmxremote.access and jmxremote.password files readonly.
 * @return The commands for handling the jmxremote files.
 */
@Override protected String getJMXremoteFilesCommand(){
  String accessFilePath;
  String passwordFilePath;
  String[] options;
  options=settings.getLeafValues(Constants.SETTINGS_COMMON_JMX_ACCESSFILE);
  if (options == null || options.length < 0) {
    accessFilePath=Constants.JMX_ACCESS_FILE_PATH_DEFAULT;
  }
 else {
    accessFilePath=options[0];
    if (options.length > 1) {
      log.debug(Constants.MSG_WARN_TOO_MANY_JMXREMOTE_FILE_PATHS);
    }
  }
  options=settings.getLeafValues(Constants.SETTINGS_COMMON_JMX_PASSWORDFILE);
  if (options == null || options.length < 0) {
    passwordFilePath=Constants.JMX_PASSWORD_FILE_PATH_DEFAULT;
  }
 else {
    passwordFilePath=options[0];
    if (options.length > 1) {
      log.debug(Constants.MSG_WARN_TOO_MANY_JMXREMOTE_FILE_PATHS);
    }
  }
  accessFilePath=ScriptConstants.replaceWindowsDirSeparators(accessFilePath);
  passwordFilePath=ScriptConstants.replaceWindowsDirSeparators(passwordFilePath);
  StringBuilder res=new StringBuilder();
  res.append(ScriptConstants.ECHO_MAKE_PASSWORD_FILES);
  res.append(Constants.NEWLINE);
  if (!accessFilePath.equals(ScriptConstants.replaceWindowsDirSeparators(Constants.JMX_ACCESS_FILE_PATH_DEFAULT))) {
    res.append(ScriptConstants.SSH + Constants.SPACE);
    res.append(machineUserLogin());
    res.append(Constants.SPACE + Constants.QUOTE_MARK);
    res.append(ScriptConstants.WINDOWS_COMMAND_RUN + Constants.SPACE);
    res.append(ScriptConstants.MOVE);
    res.append(Constants.SPACE);
    res.append(ScriptConstants.doubleBackslashes(getLocalInstallDirPath()));
    res.append(ScriptConstants.replaceWindowsDirSeparators(Constants.JMX_ACCESS_FILE_PATH_DEFAULT));
    res.append(Constants.SPACE);
    res.append(ScriptConstants.doubleBackslashes(getLocalInstallDirPath()));
    res.append(accessFilePath);
    res.append(Constants.QUOTE_MARK);
    res.append(Constants.NEWLINE);
  }
  if (!passwordFilePath.equals(ScriptConstants.replaceWindowsDirSeparators(Constants.JMX_PASSWORD_FILE_PATH_DEFAULT))) {
    res.append(ScriptConstants.SSH + Constants.SPACE);
    res.append(machineUserLogin());
    res.append(Constants.SPACE + Constants.QUOTE_MARK);
    res.append(ScriptConstants.WINDOWS_COMMAND_RUN + Constants.SPACE);
    res.append(ScriptConstants.MOVE);
    res.append(Constants.SPACE);
    res.append(ScriptConstants.doubleBackslashes(getLocalInstallDirPath()));
    res.append(ScriptConstants.replaceWindowsDirSeparators(Constants.JMX_PASSWORD_FILE_PATH_DEFAULT));
    res.append(Constants.SPACE);
    res.append(ScriptConstants.doubleBackslashes(getLocalInstallDirPath()));
    res.append(passwordFilePath);
    res.append(Constants.QUOTE_MARK);
    res.append(Constants.NEWLINE);
  }
  res.append(ScriptConstants.ECHO_Y + Constants.SPACE + Constants.SEPARATOR+ Constants.SPACE+ ScriptConstants.SSH+ Constants.SPACE);
  res.append(machineUserLogin());
  res.append(Constants.SPACE + Constants.QUOTE_MARK + ScriptConstants.WINDOWS_COMMAND_RUN+ Constants.SPACE+ ScriptConstants.CACLS+ Constants.SPACE);
  res.append(ScriptConstants.doubleBackslashes(getLocalInstallDirPath()));
  res.append(passwordFilePath);
  res.append(Constants.SPACE + ScriptConstants.SLASH_P + Constants.SPACE+ ScriptConstants.BITARKIV_BACKSLASH_BACKSLASH);
  res.append(machineParameters.getMachineUserName().getText());
  res.append(ScriptConstants.COLON_R + Constants.QUOTE_MARK);
  res.append(Constants.NEWLINE);
  res.append(ScriptConstants.ECHO_Y + Constants.SPACE + Constants.SEPARATOR+ Constants.SPACE+ ScriptConstants.SSH+ Constants.SPACE);
  res.append(machineUserLogin());
  res.append(Constants.SPACE + Constants.QUOTE_MARK + ScriptConstants.WINDOWS_COMMAND_RUN+ Constants.SPACE+ ScriptConstants.CACLS+ Constants.SPACE);
  res.append(ScriptConstants.doubleBackslashes(getLocalInstallDirPath()));
  res.append(passwordFilePath);
  res.append(Constants.SPACE + ScriptConstants.SLASH_P + Constants.SPACE+ ScriptConstants.BITARKIV_BACKSLASH_BACKSLASH);
  res.append(machineParameters.getMachineUserName().getText());
  res.append(ScriptConstants.COLON_R + Constants.QUOTE_MARK);
  res.append(Constants.NEWLINE);
  System.out.println(res.toString());
  return res.toString();
}","/** 
 * This method does the following: Retrieves the path to the jmxremote.access and jmxremote.password files. Moves these files, if they are different from standard. Makes the jmxremote.access and jmxremote.password files readonly.
 * @return The commands for handling the jmxremote files.
 */
@Override protected String getJMXremoteFilesCommand(){
  String accessFilePath;
  String passwordFilePath;
  String[] options;
  options=settings.getLeafValues(Constants.SETTINGS_COMMON_JMX_ACCESSFILE);
  if (options == null || options.length < 0) {
    accessFilePath=Constants.JMX_ACCESS_FILE_PATH_DEFAULT;
  }
 else {
    accessFilePath=options[0];
    if (options.length > 1) {
      log.debug(Constants.MSG_WARN_TOO_MANY_JMXREMOTE_FILE_PATHS);
    }
  }
  options=settings.getLeafValues(Constants.SETTINGS_COMMON_JMX_PASSWORDFILE);
  if (options == null || options.length < 0) {
    passwordFilePath=Constants.JMX_PASSWORD_FILE_PATH_DEFAULT;
  }
 else {
    passwordFilePath=options[0];
    if (options.length > 1) {
      log.debug(Constants.MSG_WARN_TOO_MANY_JMXREMOTE_FILE_PATHS);
    }
  }
  accessFilePath=ScriptConstants.replaceWindowsDirSeparators(accessFilePath);
  passwordFilePath=ScriptConstants.replaceWindowsDirSeparators(passwordFilePath);
  StringBuilder res=new StringBuilder();
  res.append(ScriptConstants.ECHO_MAKE_PASSWORD_FILES);
  res.append(Constants.NEWLINE);
  if (!accessFilePath.equals(ScriptConstants.replaceWindowsDirSeparators(Constants.JMX_ACCESS_FILE_PATH_DEFAULT))) {
    res.append(ScriptConstants.SSH + Constants.SPACE);
    res.append(machineUserLogin());
    res.append(Constants.SPACE + Constants.QUOTE_MARK);
    res.append(ScriptConstants.WINDOWS_COMMAND_RUN + Constants.SPACE);
    res.append(ScriptConstants.MOVE);
    res.append(Constants.SPACE);
    res.append(ScriptConstants.doubleBackslashes(getLocalInstallDirPath()));
    res.append(ScriptConstants.replaceWindowsDirSeparators(Constants.JMX_ACCESS_FILE_PATH_DEFAULT));
    res.append(Constants.SPACE);
    res.append(ScriptConstants.doubleBackslashes(getLocalInstallDirPath()));
    res.append(accessFilePath);
    res.append(Constants.QUOTE_MARK);
    res.append(Constants.NEWLINE);
  }
  if (!passwordFilePath.equals(ScriptConstants.replaceWindowsDirSeparators(Constants.JMX_PASSWORD_FILE_PATH_DEFAULT))) {
    res.append(ScriptConstants.SSH + Constants.SPACE);
    res.append(machineUserLogin());
    res.append(Constants.SPACE + Constants.QUOTE_MARK);
    res.append(ScriptConstants.WINDOWS_COMMAND_RUN + Constants.SPACE);
    res.append(ScriptConstants.MOVE);
    res.append(Constants.SPACE);
    res.append(ScriptConstants.doubleBackslashes(getLocalInstallDirPath()));
    res.append(ScriptConstants.replaceWindowsDirSeparators(Constants.JMX_PASSWORD_FILE_PATH_DEFAULT));
    res.append(Constants.SPACE);
    res.append(ScriptConstants.doubleBackslashes(getLocalInstallDirPath()));
    res.append(passwordFilePath);
    res.append(Constants.QUOTE_MARK);
    res.append(Constants.NEWLINE);
  }
  res.append(ScriptConstants.ECHO_Y + Constants.SPACE + Constants.SEPARATOR+ Constants.SPACE+ ScriptConstants.SSH+ Constants.SPACE);
  res.append(machineUserLogin());
  res.append(Constants.SPACE + Constants.QUOTE_MARK + ScriptConstants.WINDOWS_COMMAND_RUN+ Constants.SPACE+ ScriptConstants.CACLS+ Constants.SPACE);
  res.append(ScriptConstants.doubleBackslashes(getLocalInstallDirPath()));
  res.append(passwordFilePath);
  res.append(Constants.SPACE + ScriptConstants.SLASH_P + Constants.SPACE+ ScriptConstants.BITARKIV_BACKSLASH_BACKSLASH);
  res.append(machineParameters.getMachineUserName().getText());
  res.append(ScriptConstants.COLON_R + Constants.QUOTE_MARK);
  res.append(Constants.NEWLINE);
  res.append(ScriptConstants.ECHO_Y + Constants.SPACE + Constants.SEPARATOR+ Constants.SPACE+ ScriptConstants.SSH+ Constants.SPACE);
  res.append(machineUserLogin());
  res.append(Constants.SPACE + Constants.QUOTE_MARK + ScriptConstants.WINDOWS_COMMAND_RUN+ Constants.SPACE+ ScriptConstants.CACLS+ Constants.SPACE);
  res.append(ScriptConstants.doubleBackslashes(getLocalInstallDirPath()));
  res.append(passwordFilePath);
  res.append(Constants.SPACE + ScriptConstants.SLASH_P + Constants.SPACE+ ScriptConstants.BITARKIV_BACKSLASH_BACKSLASH);
  res.append(machineParameters.getMachineUserName().getText());
  res.append(ScriptConstants.COLON_R + Constants.QUOTE_MARK);
  res.append(Constants.NEWLINE);
  return res.toString();
}",0.9943832846551336
90035,"/** 
 * Find the jobIds in the argumentList
 * @param argv
 * @return
 */
private static Set<Long> findJobIds(String[] argv){
  Set<Long> jobIds=new HashSet<Long>();
  for (  String arg : argv) {
    jobIds.add(Long.getLong(arg));
  }
  return jobIds;
}","/** 
 * Find the jobIds in the argumentList
 * @param argv
 * @return
 */
private static Set<Long> findJobIds(String[] argv){
  Set<Long> jobIds=new HashSet<Long>();
  for (  String arg : argv) {
    jobIds.add(Long.valueOf(arg));
  }
  return jobIds;
}",0.9723320158102768
90036,"/** 
 * Handle a reply received from a bitarchive. This method registers the information from the bitarchive in the batch status for this job, if any (otherwise logs and quits). If this is the last bitarchive we were missing replies from, notify observers with the batch status for this job.
 * @param bitarchiveBatchID  The ID of the batch job sent on to the bitarchives.
 * @param bitarchiveID       The ID of the replying bitarchive.
 * @param noOfFilesProcessed The number of files the bitarchive hasprocessed.
 * @param filesFailed        A collection of filenames of failed files inthat bitarchive. Might be null if no files failed.
 * @param remoteFile         A remote pointer to a file with results fromthat bitarchive. Might be null if job was not OK.
 * @param errMsg             An error message, if the job was not successfulon the bitarchive, or null for none.
 * @param exceptions         A list of exceptions caught duringbatch processing.
 * @throws ArgumentNotValid  If either ID is null.
 */
public void bitarchiveReply(String bitarchiveBatchID,String bitarchiveID,int noOfFilesProcessed,Collection<File> filesFailed,RemoteFile remoteFile,String errMsg,List<FileBatchJob.ExceptionOccurrence> exceptions){
  ArgumentNotValid.checkNotNullOrEmpty(bitarchiveBatchID,""String_Node_Str"");
  ArgumentNotValid.checkNotNullOrEmpty(bitarchiveID,""String_Node_Str"");
  ArgumentNotValid.checkNotNull(exceptions,""String_Node_Str"");
  ArgumentNotValid.checkNotNegative(noOfFilesProcessed,""String_Node_Str"");
  BatchJobStatus bjs=runningBatchJobs.get(bitarchiveBatchID);
  if (bjs == null) {
    log.debug(""String_Node_Str"" + bitarchiveBatchID + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ remoteFile+ ""String_Node_Str""+ ""String_Node_Str""+ runningBatchJobs.keySet());
    if (remoteFile != null) {
      remoteFile.cleanup();
    }
  }
 else {
    bjs.updateWithBitarchiveReply(bitarchiveID,noOfFilesProcessed,filesFailed,remoteFile,errMsg,exceptions);
  }
}","/** 
 * Handle a reply received from a bitarchive. This method registers the information from the bitarchive in the batch status for this job, if any (otherwise logs and quits). If this is the last bitarchive we were missing replies from, notify observers with the batch status for this job.
 * @param bitarchiveBatchID  The ID of the batch job sent on to the bitarchives.
 * @param bitarchiveID       The ID of the replying bitarchive.
 * @param noOfFilesProcessed The number of files the bitarchive hasprocessed.
 * @param filesFailed        A collection of filenames of failed files inthat bitarchive. Might be null if no files failed.
 * @param remoteFile         A remote pointer to a file with results fromthat bitarchive. Might be null if job was not OK.
 * @param errMsg             An error message, if the job was not successfulon the bitarchive, or null for none.
 * @param exceptions         A list of exceptions caught duringbatch processing.
 * @throws ArgumentNotValid  If either ID is null.
 */
public void bitarchiveReply(String bitarchiveBatchID,String bitarchiveID,int noOfFilesProcessed,Collection<File> filesFailed,RemoteFile remoteFile,String errMsg,List<FileBatchJob.ExceptionOccurrence> exceptions){
  ArgumentNotValid.checkNotNullOrEmpty(bitarchiveBatchID,""String_Node_Str"");
  ArgumentNotValid.checkNotNullOrEmpty(bitarchiveID,""String_Node_Str"");
  ArgumentNotValid.checkNotNegative(noOfFilesProcessed,""String_Node_Str"");
  BatchJobStatus bjs=runningBatchJobs.get(bitarchiveBatchID);
  if (bjs == null) {
    log.debug(""String_Node_Str"" + bitarchiveBatchID + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ remoteFile+ ""String_Node_Str""+ ""String_Node_Str""+ runningBatchJobs.keySet());
    if (remoteFile != null) {
      remoteFile.cleanup();
    }
  }
 else {
    bjs.updateWithBitarchiveReply(bitarchiveID,noOfFilesProcessed,filesFailed,remoteFile,errMsg,exceptions);
  }
}",0.9837754313674992
90037,"/** 
 * Verify that batch jobs do not have to wait for each other. In particular, check that the postprocessing of one job can overtake the postprocessing of another.
 */
public void testParallelBatchJobs() throws InterruptedException {
  bam_server=BitarchiveMonitorServer.getInstance();
  TestMessageListener client=new TestMessageListener();
  JMSConnectionFactory.getInstance().setListener(Channels.getThisReposClient(),client);
  final MockupBitarchiveBatch mockupBitarchiveBatch=new MockupBitarchiveBatch(""String_Node_Str"");
  final BlockingRF brf=new BlockingRF();
  mockupBitarchiveBatch.heartBeat(bam_server);
  bam_server.visit(noActionBatchMessage(""String_Node_Str""));
  new Thread(){
    public void run(){
      bam_server.visit(mockupBitarchiveBatch.replyForLatestJob(brf));
    }
  }
.start();
synchronized (this) {
    wait(50);
  }
  bam_server.visit(noActionBatchMessage(""String_Node_Str""));
  new Thread(){
    public void run(){
      bam_server.visit(mockupBitarchiveBatch.replyForLatestJob(brf.getWaker()));
    }
  }
.start();
synchronized (this) {
    wait(400);
  }
  TestMessageListener.waitForConcurrentTasksToFinish();
  assertEquals(""String_Node_Str"",null,brf.failed);
  assertEquals(""String_Node_Str"",2,client.getNumReceived());
  assertEquals(""String_Node_Str"",2,client.getNumOk());
  assertBatchResultIs(client,0,""String_Node_Str"",BlockingRF.WAKER_CONTENT);
  assertBatchResultIs(client,1,""String_Node_Str"",BlockingRF.STD_CONTENT);
}","/** 
 * Verify that batch jobs do not have to wait for each other. In particular, check that the postprocessing of one job can overtake the postprocessing of another.
 */
public void testParallelBatchJobs() throws InterruptedException {
  bam_server=BitarchiveMonitorServer.getInstance();
  TestMessageListener client=new TestMessageListener();
  JMSConnectionFactory.getInstance().setListener(Channels.getThisReposClient(),client);
  final MockupBitarchiveBatch mockupBitarchiveBatch=new MockupBitarchiveBatch(""String_Node_Str"");
  final BlockingRF brf=new BlockingRF();
  mockupBitarchiveBatch.heartBeat(bam_server);
  bam_server.visit(noActionBatchMessage(""String_Node_Str""));
  new Thread(){
    public void run(){
      bam_server.visit(mockupBitarchiveBatch.replyForLatestJob(brf));
    }
  }
.start();
synchronized (this) {
    wait(50);
  }
  bam_server.visit(noActionBatchMessage(""String_Node_Str""));
  new Thread(){
    public void run(){
      bam_server.visit(mockupBitarchiveBatch.replyForLatestJob(brf.getWaker()));
    }
  }
.start();
synchronized (this) {
    wait(400);
  }
  TestMessageListener.waitForConcurrentTasksToFinish();
  assertEquals(""String_Node_Str"",null,brf.failed);
  assertEquals(""String_Node_Str"",2,client.getNumReceived());
  assertEquals(""String_Node_Str"" + client.getNumNotOk(),0,client.getNumNotOk());
  assertEquals(""String_Node_Str"",2,client.getNumOk());
  assertBatchResultIs(client,0,""String_Node_Str"",BlockingRF.WAKER_CONTENT);
  assertBatchResultIs(client,1,""String_Node_Str"",BlockingRF.STD_CONTENT);
}",0.9730986383261376
90038,"/** 
 * This method does the following: Retrieves the path to the jmxremote.access and jmxremote.password files. Moves these files, if they are different from standard. Makes the jmxremote.access and jmxremote.password files readonly.
 * @return The commands for handling the jmxremote files.
 */
@Override protected String getJMXremoteFilesCommand(){
  String accessFilePath;
  String passwordFilePath;
  String[] options;
  options=settings.getLeafValues(Constants.SETTINGS_COMMON_JMX_ACCESSFILE);
  if (options == null || options.length < 0) {
    accessFilePath=Constants.JMX_ACCESS_FILE_PATH_DEFAULT;
  }
 else {
    accessFilePath=options[0];
    if (options.length > 1) {
      log.debug(Constants.MSG_WARN_TOO_MANY_JMXREMOTE_FILE_PATHS);
    }
  }
  options=settings.getLeafValues(Constants.SETTINGS_COMMON_JMX_PASSWORDFILE);
  if (options == null || options.length < 0) {
    passwordFilePath=Constants.JMX_PASSWORD_FILE_PATH_DEFAULT;
  }
 else {
    passwordFilePath=options[0];
    if (options.length > 1) {
      log.debug(Constants.MSG_WARN_TOO_MANY_JMXREMOTE_FILE_PATHS);
    }
  }
  StringBuilder res=new StringBuilder();
  res.append(ScriptConstants.ECHO_MAKE_PASSWORD_FILES);
  res.append(Constants.NEWLINE);
  if (accessFilePath != Constants.JMX_ACCESS_FILE_PATH_DEFAULT) {
    res.append(ScriptConstants.SSH + Constants.SPACE);
    res.append(machineUserLogin());
    res.append(Constants.SPACE + Constants.QUOTE_MARK);
    res.append(ScriptConstants.MV);
    res.append(Constants.SPACE);
    res.append(getInstallDirPath());
    res.append(Constants.SLASH);
    res.append(Constants.JMX_ACCESS_FILE_PATH_DEFAULT);
    res.append(Constants.SPACE);
    res.append(getInstallDirPath());
    res.append(Constants.SLASH);
    res.append(accessFilePath);
    res.append(Constants.QUOTE_MARK);
    res.append(Constants.NEWLINE);
  }
  if (passwordFilePath != Constants.JMX_PASSWORD_FILE_PATH_DEFAULT) {
    res.append(ScriptConstants.SSH + Constants.SPACE);
    res.append(machineUserLogin());
    res.append(Constants.SPACE + Constants.QUOTE_MARK);
    res.append(ScriptConstants.MV);
    res.append(Constants.SPACE);
    res.append(getInstallDirPath());
    res.append(Constants.SLASH);
    res.append(Constants.JMX_PASSWORD_FILE_PATH_DEFAULT);
    res.append(Constants.SPACE);
    res.append(getInstallDirPath());
    res.append(Constants.SLASH);
    res.append(passwordFilePath);
    res.append(Constants.QUOTE_MARK);
    res.append(Constants.NEWLINE);
  }
  res.append(ScriptConstants.SSH + Constants.SPACE);
  res.append(machineUserLogin());
  res.append(Constants.SPACE + Constants.QUOTE_MARK + ScriptConstants.LINUX_USER_400+ Constants.SPACE);
  res.append(getInstallDirPath());
  res.append(Constants.SLASH);
  res.append(passwordFilePath);
  res.append(Constants.QUOTE_MARK);
  res.append(Constants.NEWLINE);
  res.append(ScriptConstants.SSH + Constants.SPACE);
  res.append(machineUserLogin());
  res.append(Constants.SPACE + Constants.QUOTE_MARK + ScriptConstants.LINUX_USER_400+ Constants.SPACE);
  res.append(getInstallDirPath());
  res.append(Constants.SLASH);
  res.append(accessFilePath);
  res.append(Constants.QUOTE_MARK);
  res.append(Constants.NEWLINE);
  return res.toString();
}","/** 
 * This method does the following: Retrieves the path to the jmxremote.access and jmxremote.password files. Moves these files, if they are different from standard. Makes the jmxremote.access and jmxremote.password files readonly.
 * @return The commands for handling the jmxremote files.
 */
@Override protected String getJMXremoteFilesCommand(){
  String accessFilePath;
  String passwordFilePath;
  String[] options;
  options=settings.getLeafValues(Constants.SETTINGS_COMMON_JMX_ACCESSFILE);
  if (options == null || options.length < 0) {
    accessFilePath=Constants.JMX_ACCESS_FILE_PATH_DEFAULT;
  }
 else {
    accessFilePath=options[0];
    if (options.length > 1) {
      log.debug(Constants.MSG_WARN_TOO_MANY_JMXREMOTE_FILE_PATHS);
    }
  }
  options=settings.getLeafValues(Constants.SETTINGS_COMMON_JMX_PASSWORDFILE);
  if (options == null || options.length < 0) {
    passwordFilePath=Constants.JMX_PASSWORD_FILE_PATH_DEFAULT;
  }
 else {
    passwordFilePath=options[0];
    if (options.length > 1) {
      log.debug(Constants.MSG_WARN_TOO_MANY_JMXREMOTE_FILE_PATHS);
    }
  }
  StringBuilder res=new StringBuilder();
  res.append(ScriptConstants.ECHO_MAKE_PASSWORD_FILES);
  res.append(Constants.NEWLINE);
  if (!accessFilePath.equals(Constants.JMX_ACCESS_FILE_PATH_DEFAULT)) {
    res.append(ScriptConstants.SSH + Constants.SPACE);
    res.append(machineUserLogin());
    res.append(Constants.SPACE + Constants.QUOTE_MARK);
    res.append(ScriptConstants.MV);
    res.append(Constants.SPACE);
    res.append(getInstallDirPath());
    res.append(Constants.SLASH);
    res.append(Constants.JMX_ACCESS_FILE_PATH_DEFAULT);
    res.append(Constants.SPACE);
    res.append(getInstallDirPath());
    res.append(Constants.SLASH);
    res.append(accessFilePath);
    res.append(Constants.QUOTE_MARK);
    res.append(Constants.NEWLINE);
  }
  if (!passwordFilePath.equals(Constants.JMX_PASSWORD_FILE_PATH_DEFAULT)) {
    res.append(ScriptConstants.SSH + Constants.SPACE);
    res.append(machineUserLogin());
    res.append(Constants.SPACE + Constants.QUOTE_MARK);
    res.append(ScriptConstants.MV);
    res.append(Constants.SPACE);
    res.append(getInstallDirPath());
    res.append(Constants.SLASH);
    res.append(Constants.JMX_PASSWORD_FILE_PATH_DEFAULT);
    res.append(Constants.SPACE);
    res.append(getInstallDirPath());
    res.append(Constants.SLASH);
    res.append(passwordFilePath);
    res.append(Constants.QUOTE_MARK);
    res.append(Constants.NEWLINE);
  }
  res.append(ScriptConstants.SSH + Constants.SPACE);
  res.append(machineUserLogin());
  res.append(Constants.SPACE + Constants.QUOTE_MARK + ScriptConstants.LINUX_USER_400+ Constants.SPACE);
  res.append(getInstallDirPath());
  res.append(Constants.SLASH);
  res.append(passwordFilePath);
  res.append(Constants.QUOTE_MARK);
  res.append(Constants.NEWLINE);
  res.append(ScriptConstants.SSH + Constants.SPACE);
  res.append(machineUserLogin());
  res.append(Constants.SPACE + Constants.QUOTE_MARK + ScriptConstants.LINUX_USER_400+ Constants.SPACE);
  res.append(getInstallDirPath());
  res.append(Constants.SLASH);
  res.append(accessFilePath);
  res.append(Constants.QUOTE_MARK);
  res.append(Constants.NEWLINE);
  return res.toString();
}",0.9956521739130436
90039,"/** 
 * Name a JMX object name as expected by our CachingLogRecordMBean.
 * @param index The index attribute - may be null, for all
 * @return An ObjectName.
 * @throws MalformedObjectNameException
 */
private static ObjectName getObjectName(int index) throws MalformedObjectNameException {
  return new ObjectName(""String_Node_Str"" + Settings.get(CommonSettings.THIS_PHYSICAL_LOCATION) + ""String_Node_Str""+ Constants.PRIORITY_KEY_MACHINE+ ""String_Node_Str""+ SystemUtils.getLocalHostName()+ ""String_Node_Str""+ Settings.get(CommonSettings.HTTP_PORT_NUMBER)+ ""String_Node_Str""+ Constants.PRIORITY_KEY_REPLICA+ ""String_Node_Str""+ Constants.PRIORITY_KEY_PRIORITY+ ""String_Node_Str""+ ""String_Node_Str""+ Constants.PRIORITY_KEY_APPLICATIONNAME+ ""String_Node_Str""+ Settings.get(CommonSettings.APPLICATION_NAME)+ ""String_Node_Str""+ Constants.PRIORITY_KEY_APPLICATIONINSTANCEID+ ""String_Node_Str""+ Settings.get(CommonSettings.APPLICATION_INSTANCE_ID)+ ""String_Node_Str""+ (index == -1 ? ""String_Node_Str"" : ""String_Node_Str"" + index));
}","/** 
 * Name a JMX object name as expected by our CachingLogRecordMBean.
 * @param index The index attribute - may be null, for all
 * @return An ObjectName.
 * @throws MalformedObjectNameException
 */
private static ObjectName getObjectName(int index) throws MalformedObjectNameException {
  return new ObjectName(""String_Node_Str"" + Settings.get(CommonSettings.THIS_PHYSICAL_LOCATION) + ""String_Node_Str""+ Constants.PRIORITY_KEY_MACHINE+ ""String_Node_Str""+ SystemUtils.getLocalHostName()+ ""String_Node_Str""+ Settings.get(CommonSettings.HTTP_PORT_NUMBER)+ ""String_Node_Str""+ Constants.PRIORITY_KEY_REPLICANAME+ ""String_Node_Str""+ Constants.PRIORITY_KEY_PRIORITY+ ""String_Node_Str""+ ""String_Node_Str""+ Constants.PRIORITY_KEY_APPLICATIONNAME+ ""String_Node_Str""+ Settings.get(CommonSettings.APPLICATION_NAME)+ ""String_Node_Str""+ Constants.PRIORITY_KEY_APPLICATIONINSTANCEID+ ""String_Node_Str""+ Settings.get(CommonSettings.APPLICATION_INSTANCE_ID)+ ""String_Node_Str""+ (index == -1 ? ""String_Node_Str"" : ""String_Node_Str"" + index));
}",0.9980544747081712
90040,"/** 
 * Run a batch job on all ARC entries in the archive. <p/> This currently runs synchronously, and returns only after finish() has been called.
 * @param bitarchiveAppId A String representing the bitarchive AppId.
 * @param job An object that implements the ARCBatchJob interface. The initialize() method will be called before processing and the finish() method will be called afterwards. The process() method will be called with each ARC entry.
 * @throws ArgumentNotValid if job or file is null.
 * @throws IOFailure if there was problems writing to the RemoteFile
 * @return A localBatchStatus
 */
public BatchStatus batch(String bitarchiveAppId,final FileBatchJob job){
  ArgumentNotValid.checkNotNull(job,""String_Node_Str"");
  log.info(""String_Node_Str"" + job.getClass().getName());
  BatchStatus returnStatus;
  File tmpFile=null;
  try {
    tmpFile=File.createTempFile(""String_Node_Str"",""String_Node_Str"",FileUtils.getTempDir());
    final OutputStream os=new FileOutputStream(tmpFile);
    try {
      log.debug(""String_Node_Str"" + job + ""String_Node_Str""+ new Date());
      File[] processFiles=admin.getFilesMatching(job.getFilenamePattern());
      final BatchLocalFiles localBatchRunner=new BatchLocalFiles(processFiles);
      localBatchRunner.run(job,os);
      log.debug(""String_Node_Str"" + job + ""String_Node_Str""+ new Date());
    }
  finally {
      try {
        os.close();
      }
 catch (      IOException e) {
        log.warn(""String_Node_Str"");
      }
    }
    returnStatus=new BatchStatus(bitarchiveAppId,job.getFilesFailed(),job.getNoOfFilesProcessed(),RemoteFileFactory.getMovefileInstance(tmpFile),job.getExceptions());
  }
 catch (  IOException e) {
    log.fatal(""String_Node_Str"" + job,e);
    throw new IOFailure(""String_Node_Str"" + job,e);
  }
  log.info(""String_Node_Str"" + job.getClass().getName() + ""String_Node_Str""+ returnStatus);
  return returnStatus;
}","/** 
 * Run a batch job on all ARC entries in the archive. <p/> This currently runs synchronously, and returns only after finish() has been called.
 * @param bitarchiveAppId A String representing the bitarchive AppId.
 * @param job An object that implements the ARCBatchJob interface. The initialize() method will be called before processing and the finish() method will be called afterwards. The process() method will be called with each ARC entry.
 * @throws ArgumentNotValid if job or file is null.
 * @throws IOFailure if there was problems writing to the RemoteFile
 * @return A localBatchStatus
 */
public BatchStatus batch(String bitarchiveAppId,final FileBatchJob job){
  ArgumentNotValid.checkNotNull(job,""String_Node_Str"");
  log.info(""String_Node_Str"" + bitarchiveAppId + ""String_Node_Str""+ job.getClass().getName());
  BatchStatus returnStatus;
  File tmpFile=null;
  try {
    tmpFile=File.createTempFile(""String_Node_Str"",""String_Node_Str"",FileUtils.getTempDir());
    final OutputStream os=new FileOutputStream(tmpFile);
    try {
      log.debug(""String_Node_Str"" + job + ""String_Node_Str""+ new Date());
      File[] processFiles=admin.getFilesMatching(job.getFilenamePattern());
      final BatchLocalFiles localBatchRunner=new BatchLocalFiles(processFiles);
      localBatchRunner.run(job,os);
      log.debug(""String_Node_Str"" + job + ""String_Node_Str""+ new Date());
    }
  finally {
      try {
        os.close();
      }
 catch (      IOException e) {
        log.warn(""String_Node_Str"");
      }
    }
    returnStatus=new BatchStatus(bitarchiveAppId,job.getFilesFailed(),job.getNoOfFilesProcessed(),RemoteFileFactory.getMovefileInstance(tmpFile),job.getExceptions());
  }
 catch (  IOException e) {
    log.fatal(""String_Node_Str"" + job,e);
    throw new IOFailure(""String_Node_Str"" + job,e);
  }
  log.info(""String_Node_Str"" + job.getClass().getName() + ""String_Node_Str""+ returnStatus);
  return returnStatus;
}",0.9903620734566292
90041,"/** 
 * Returns a temporary place for the the file to be stored.
 * @param arcFile       The simple name (i.e. no dirs) of the ARC file.
 * @param requestedSize How large the file is in bytes.
 * @return The path where the arcFile should go.
 * @throws ArgumentNotValid If arcFile is null or empty, or requestedSize is negative.
 * @throws IOFailure if there is no more room left to store this file ofsize=requestedSize
 */
public File getTemporaryPath(String arcFile,long requestedSize) throws ArgumentNotValid, IOFailure {
  ArgumentNotValid.checkNotNullOrEmpty(arcFile,""String_Node_Str"");
  ArgumentNotValid.checkNotNegative(requestedSize,""String_Node_Str"");
  for (Iterator<File> i=archivePaths.iterator(); i.hasNext(); ) {
    File dir=i.next();
    if (checkArchiveDir(dir)) {
      if (FileUtils.getBytesFree(dir) > requestedSize) {
        File filedir=new File(dir,Constants.TEMPORARY_DIRECTORY_NAME);
        return new File(filedir,arcFile);
      }
    }
  }
  String errMsg=""String_Node_Str"" + arcFile + ""String_Node_Str""+ requestedSize;
  log.fatal(errMsg);
  throw new IOFailure(errMsg);
}","/** 
 * Returns a temporary place for the the file to be stored.
 * @param arcFileName The simple name (i.e. no dirs) of the ARC file.
 * @param requestedSize How large the file is in bytes.
 * @return The path where the arcFile should go.
 * @throws ArgumentNotValid If arcFileName is null or empty, or requestedSize is negative.
 * @throws IOFailure if there is no more room left to store this file ofsize=requestedSize
 */
public File getTemporaryPath(String arcFileName,long requestedSize) throws ArgumentNotValid, IOFailure {
  ArgumentNotValid.checkNotNullOrEmpty(arcFileName,""String_Node_Str"");
  ArgumentNotValid.checkNotNegative(requestedSize,""String_Node_Str"");
  for (Iterator<File> i=archivePaths.iterator(); i.hasNext(); ) {
    File dir=i.next();
    long bytesFreeInDir=FileUtils.getBytesFree(dir);
    if (checkArchiveDir(dir) && bytesFreeInDir > minSpaceLeft) {
      if (bytesFreeInDir > requestedSize) {
        File filedir=new File(dir,Constants.TEMPORARY_DIRECTORY_NAME);
        return new File(filedir,arcFileName);
      }
 else {
        log.warn(""String_Node_Str"" + dir.getAbsolutePath() + ""String_Node_Str""+ arcFileName+ ""String_Node_Str""+ requestedSize+ ""String_Node_Str""+ bytesFreeInDir+ ""String_Node_Str"");
      }
    }
  }
  String errMsg=""String_Node_Str"" + arcFileName + ""String_Node_Str""+ requestedSize;
  log.fatal(errMsg);
  throw new IOFailure(errMsg);
}",0.8642370845014017
90042,"/** 
 * Returns a String that identifies this bit archive application (within the bit archive, i.e. either with id ONE or TWO). The string has the following form: [hostaddress]_[port] fx. ""10.0.0.1_80""
 * @return String with IP address of this host and, if specified, theHTTP_PORT_NUMBER from settings
 * @throws UnknownID - if InetAddress.getLocalHost() failed
 */
private String createBitarchiveAppId() throws UnknownID {
  String id;
  id=SystemUtils.getLocalIP();
  try {
    String port=Settings.get(CommonSettings.HTTP_PORT_NUMBER);
    id+=""String_Node_Str"" + port;
  }
 catch (  UnknownID e) {
    log.warn(""String_Node_Str"");
  }
  return id;
}","/** 
 * Returns a String that identifies this bit archive application (within the bit archive, i.e. either with id ONE or TWO). The string has the following form: hostaddress[_applicationinstanceid] fx. ""10.0.0.1_appOne"" or just ""10.0.0.1"", if no applicationinstanceid has been chosen. 
 * @return String with IP address of this host and, if specified, theAPPLICATION_INSTANCE_ID from settings
 * @throws UnknownID - if InetAddress.getLocalHost() failed
 */
private String createBitarchiveAppId() throws UnknownID {
  String id;
  id=SystemUtils.getLocalIP();
  try {
    String applicationInstanceId=Settings.get(CommonSettings.APPLICATION_INSTANCE_ID);
    if (!applicationInstanceId.isEmpty()) {
      id+=""String_Node_Str"" + applicationInstanceId;
    }
  }
 catch (  UnknownID e) {
    log.warn(""String_Node_Str"");
  }
  return id;
}",0.8075117370892019
90043,"/** 
 * Returns a String that identifies this bit archive application (within the bit archive, i.e. either with id ONE or TWO)
 * @return String with IP address of this host and, if specified, theHTTP_PORT_NUMBER from settings
 */
public String getBitarchiveAppId(){
  return bitarchiveAppId;
}","/** 
 * Returns a String that identifies this bit archive application (within the bit archive, i.e. either with id ONE or TWO)
 * @return String with IP address of this host and, if specified, theAPPLICATION_INSTANCE_ID from settings
 */
public String getBitarchiveAppId(){
  return bitarchiveAppId;
}",0.9445378151260504
90044,"/** 
 * Tests that register works, and cannot be called twice.
 * @throws Exception
 */
public void testRegister() throws Exception {
  SingleMBeanObject test=new SingleMBeanObject(""String_Node_Str"",new MyTestInterfaceObject(),MyTestInterface.class,ManagementFactory.getPlatformMBeanServer());
  assertFalse(""String_Node_Str"",platformMBeanServer.isRegistered(name));
  test.register();
  assertTrue(""String_Node_Str"",platformMBeanServer.isRegistered(name));
  Object attribute=platformMBeanServer.getAttribute(name,""String_Node_Str"");
  assertEquals(""String_Node_Str"",""String_Node_Str"",attribute.toString());
  try {
    test.register();
    fail(""String_Node_Str"");
  }
 catch (  IllegalState e) {
  }
}","/** 
 * Tests that register works, and cannot be called twice.
 * @throws Exception
 */
public void testRegister() throws Exception {
  SingleMBeanObject test=new SingleMBeanObject(""String_Node_Str"",new MyTestInterfaceObject(),MyTestInterface.class,ManagementFactory.getPlatformMBeanServer());
  assertFalse(""String_Node_Str"" + name + ""String_Node_Str"",platformMBeanServer.isRegistered(name));
  test.register();
  assertTrue(""String_Node_Str"" + name + ""String_Node_Str"",platformMBeanServer.isRegistered(name));
  Object attribute=platformMBeanServer.getAttribute(name,""String_Node_Str"");
  assertEquals(""String_Node_Str"",""String_Node_Str"",attribute.toString());
  try {
    test.register();
    fail(""String_Node_Str"");
  }
 catch (  IllegalState e) {
  }
}",0.963064295485636
90045,"public void setUp(){
  rs.setUp();
  mBeanServer=ManagementFactory.getPlatformMBeanServer();
  Settings.set(CommonSettings.APPLICATION_NAME,""String_Node_Str"");
  Settings.set(MonitorSettings.LOGGING_HISTORY_SIZE,Integer.toString(LOG_HISTORY_SIZE));
  Settings.set(CommonSettings.HTTP_PORT_NUMBER,""String_Node_Str"");
  Settings.set(HarvesterSettings.HARVEST_CONTROLLER_PRIORITY,""String_Node_Str"");
  Settings.set(CommonSettings.USE_REPLICA_ID,""String_Node_Str"");
}","public void setUp(){
  rs.setUp();
  mBeanServer=ManagementFactory.getPlatformMBeanServer();
  Settings.set(CommonSettings.THIS_PHYSICAL_LOCATION,""String_Node_Str"");
  Settings.set(CommonSettings.APPLICATION_NAME,""String_Node_Str"");
  Settings.set(MonitorSettings.LOGGING_HISTORY_SIZE,Integer.toString(LOG_HISTORY_SIZE));
  Settings.set(CommonSettings.HTTP_PORT_NUMBER,""String_Node_Str"");
  Settings.set(HarvesterSettings.HARVEST_CONTROLLER_PRIORITY,""String_Node_Str"");
  Settings.set(CommonSettings.USE_REPLICA_ID,""String_Node_Str"");
}",0.9269269269269268
90046,"/** 
 * Test that the constructor exposes N MBeans, and each can be connected to and returns the empty string. It is tested that the names of the objects are generated from: ""location"" =  Settings.get(CommonSettings.ENVIRONMENT_THIS_PHYSICAL_LOCATION) ""machine"" = InetAddress.getLocalHost().getCanonicalHostName()  ""httpport"" = Settings.get(CommonSettings.HTTP_PORT_NUMBER)  ""applicationname"" = Settings.get(CommonSettings.APPLICATION_NAME)  ""applicationinstid"" = Settings.get(CommonSettings.APPLICATIONINSTANCE_ID)  ""index"" = (index in the cache; 0 is always the most recent log record) It is also tested that no MBeans were registered before this call.
 * @throws Exception
 */
public void testCachingLogHandler() throws Exception {
  int before=mBeanServer.getMBeanCount();
  ObjectName name=getObjectName(-1);
  assertEquals(""String_Node_Str"",0,mBeanServer.queryNames(name,null).size());
  cachingLogHandler=new CachingLogHandler();
  int after=mBeanServer.getMBeanCount();
  assertEquals(LOG_HISTORY_SIZE + ""String_Node_Str"",LOG_HISTORY_SIZE,after - before);
  assertEquals(""String_Node_Str"" + LOG_HISTORY_SIZE + ""String_Node_Str""+ name+ ""String_Node_Str"",LOG_HISTORY_SIZE,mBeanServer.queryNames(name,null).size());
  ObjectInstance mbean=getObjectInstance(mBeanServer,0);
  assertTrue(""String_Node_Str"",SingleLogRecord.class.isAssignableFrom(Class.forName(mbean.getClassName())));
  mbean=getObjectInstance(mBeanServer,LOG_HISTORY_SIZE - 1);
  assertTrue(""String_Node_Str"",SingleLogRecord.class.isAssignableFrom(Class.forName(mbean.getClassName())));
  try {
    getObjectInstance(mBeanServer,LOG_HISTORY_SIZE);
    fail(""String_Node_Str"" + LOG_HISTORY_SIZE);
  }
 catch (  InstanceNotFoundException e) {
  }
  for (int i=0; i < LOG_HISTORY_SIZE; i++) {
    String logRecordI=getLogRecordAtIndex(i,mBeanServer);
    assertEquals(""String_Node_Str"",""String_Node_Str"",logRecordI);
  }
}","/** 
 * Test that the constructor exposes N MBeans, and each can be connected to and returns the empty string. It is tested that the names of the objects are generated from: ""location"" =  Settings.get(CommonSettings.ENVIRONMENT_THIS_PHYSICAL_LOCATION) ""machine"" = InetAddress.getLocalHost().getCanonicalHostName()  ""httpport"" = Settings.get(CommonSettings.HTTP_PORT_NUMBER)  ""applicationname"" = Settings.get(CommonSettings.APPLICATION_NAME)  ""applicationinstid"" = Settings.get(CommonSettings.APPLICATIONINSTANCE_ID)  ""index"" = (index in the cache; 0 is always the most recent log record) It is also tested that no MBeans were registered before this call.
 * @throws Exception
 */
public void testCachingLogHandler() throws Exception {
  int before=mBeanServer.getMBeanCount();
  ObjectName name=getObjectName(-1);
  assertEquals(""String_Node_Str"",0,mBeanServer.queryNames(name,null).size());
  cachingLogHandler=new CachingLogHandler();
  int after=mBeanServer.getMBeanCount();
  assertEquals(LOG_HISTORY_SIZE + ""String_Node_Str"",LOG_HISTORY_SIZE,after - before);
  Set<ObjectName> names=mBeanServer.queryNames(null,null);
  for (  ObjectName currentName : names) {
    System.out.println(currentName);
  }
  assertEquals(""String_Node_Str"" + LOG_HISTORY_SIZE + ""String_Node_Str""+ name+ ""String_Node_Str"",LOG_HISTORY_SIZE,mBeanServer.queryNames(name,null).size());
  ObjectInstance mbean=getObjectInstance(mBeanServer,0);
  assertTrue(""String_Node_Str"",SingleLogRecord.class.isAssignableFrom(Class.forName(mbean.getClassName())));
  mbean=getObjectInstance(mBeanServer,LOG_HISTORY_SIZE - 1);
  assertTrue(""String_Node_Str"",SingleLogRecord.class.isAssignableFrom(Class.forName(mbean.getClassName())));
  try {
    getObjectInstance(mBeanServer,LOG_HISTORY_SIZE);
    fail(""String_Node_Str"" + LOG_HISTORY_SIZE);
  }
 catch (  InstanceNotFoundException e) {
  }
  for (int i=0; i < LOG_HISTORY_SIZE; i++) {
    String logRecordI=getLogRecordAtIndex(i,mBeanServer);
    assertEquals(""String_Node_Str"",""String_Node_Str"",logRecordI);
  }
}",0.9635297118082122
90047,"/** 
 * Get the unique index request server instance.
 * @return The index request server.
 */
public static IndexRequestServer getInstance(){
synchronized (instance) {
    if (instance == null) {
      instance=new IndexRequestServer();
    }
  }
  return instance;
}","/** 
 * Get the unique index request server instance.
 * @return The index request server.
 */
public static IndexRequestServer getInstance(){
  if (instance == null) {
    instance=new IndexRequestServer();
  }
  return instance;
}",0.86
90048,"/** 
 * Get a JMXConnector to a given host and port, using login and password.
 * @param hostName The host to attempt to connect to.
 * @param jmxPort The port on the host to connect to (a non-negative number)
 * @param login The login name to authenticate as (typically ""controlRole""or ""monitorRole"".
 * @param password The password for JMX access
 * @return A JMX connector to the given host and port, using default RMI
 */
public static JMXConnector getJMXConnector(String hostName,int jmxPort,final String login,final String password){
  ArgumentNotValid.checkNotNullOrEmpty(hostName,""String_Node_Str"");
  ArgumentNotValid.checkNotNegative(jmxPort,""String_Node_Str"");
  ArgumentNotValid.checkNotNullOrEmpty(login,""String_Node_Str"");
  ArgumentNotValid.checkNotNullOrEmpty(password,""String_Node_Str"");
  JMXServiceURL rmiurl=getUrl(hostName,jmxPort,-1);
  Map<String,?> environment=(Map<String,?>)packageCredentials(login,password);
  Throwable lastException;
  int retries=0;
  do {
    try {
      return JMXConnectorFactory.connect(rmiurl,environment);
    }
 catch (    IOException e) {
      lastException=e;
      if (retries < MAX_TRIES && e.getCause() != null && e.getCause() instanceof ServiceUnavailableException) {
        TimeUtils.exponentialBackoffSleep(retries);
        continue;
      }
      break;
    }
  }
 while (retries++ < MAX_TRIES);
  throw new IOFailure(""String_Node_Str"" + rmiurl + ""String_Node_Str""+ retries+ ""String_Node_Str"",lastException);
}","/** 
 * Get a JMXConnector to a given host and port, using login and password.
 * @param hostName The host to attempt to connect to.
 * @param jmxPort The port on the host to connect to (a non-negative number)
 * @param login The login name to authenticate as (typically ""controlRole""or ""monitorRole"".
 * @param password The password for JMX access
 * @return A JMX connector to the given host and port, using default RMI
 */
public static JMXConnector getJMXConnector(String hostName,int jmxPort,final String login,final String password){
  ArgumentNotValid.checkNotNullOrEmpty(hostName,""String_Node_Str"");
  ArgumentNotValid.checkNotNegative(jmxPort,""String_Node_Str"");
  ArgumentNotValid.checkNotNullOrEmpty(login,""String_Node_Str"");
  ArgumentNotValid.checkNotNullOrEmpty(password,""String_Node_Str"");
  JMXServiceURL rmiurl=getUrl(hostName,jmxPort,-1);
  Map<String,?> environment=(Map<String,?>)packageCredentials(login,password);
  Throwable lastException;
  int retries=0;
  do {
    try {
      return JMXConnectorFactory.connect(rmiurl,environment);
    }
 catch (    IOException e) {
      lastException=e;
      if (retries < MAX_TRIES && e.getCause() != null && (e.getCause() instanceof ServiceUnavailableException || e.getCause() instanceof SocketTimeoutException)) {
        TimeUtils.exponentialBackoffSleep(retries);
        continue;
      }
      break;
    }
  }
 while (retries++ < MAX_TRIES);
  throw new IOFailure(""String_Node_Str"" + rmiurl + ""String_Node_Str""+ retries+ ""String_Node_Str"",lastException);
}",0.9826897470039948
90049,"/** 
 * If a column is not active, this function generates the link  to showing a specific column again.
 * @param starredRequest A request to take parameters from.
 * @param parameter Reference to the column to show again.
 * @return The link to show the parameter again.
 */
public static String generateShowColumn(StarredRequest starredRequest,String parameter){
  ArgumentNotValid.checkNotNull(starredRequest,""String_Node_Str"");
  ArgumentNotValid.checkNotNull(parameter,""String_Node_Str"");
  if (""String_Node_Str"".equals(starredRequest.getParameter(parameter))) {
    return ""String_Node_Str"";
  }
  return generateLink(starredRequest,parameter,""String_Node_Str"",parameter) + ""String_Node_Str"";
}","/** 
 * If a column is not active, this function generates the link  to showing a specific column again.
 * @param starredRequest A request to take parameters from.
 * @param parameter Reference to the column to show again.
 * @return The link to show the parameter again.
 */
public static String generateShowColumn(StarredRequest starredRequest,String parameter){
  ArgumentNotValid.checkNotNull(starredRequest,""String_Node_Str"");
  ArgumentNotValid.checkNotNull(parameter,""String_Node_Str"");
  if (!""String_Node_Str"".equals(starredRequest.getParameter(parameter))) {
    return ""String_Node_Str"";
  }
  return generateLink(starredRequest,parameter,""String_Node_Str"",parameter) + ""String_Node_Str"";
}",0.9992872416250892
90050,"/** 
 * Execute an SQL statement and return the single long in the result set. This variant takes a query string and a single string arg and combines them to form a normal query.
 * @param query a query with ? for parameters
 * @param args parameters of type string, int, long or boolean
 * @return The long result
 * @throws IOFailure if the statement didn't result in exactly one long value
 */
public static Long selectLongValue(String query,Object... args){
  Connection c=DBConnect.getDBConnection();
  PreparedStatement s=null;
  try {
    s=DBUtils.prepareStatement(c,query,args);
    return selectLongValue(s);
  }
 catch (  SQLException e) {
    throw new IOFailure(""String_Node_Str"" + query + ""String_Node_Str""+ args,e);
  }
 finally {
    DBUtils.closeStatementIfOpen(s);
  }
}","/** 
 * Execute an SQL statement and return the single long in the result set. This variant takes a query string and a single string arg and combines them to form a normal query.
 * @param query a query with ? for parameters
 * @param args parameters of type string, int, long or boolean
 * @return The long result
 * @throws IOFailure if the statement didn't result in exactly one long value
 */
public static Long selectLongValue(String query,Object... args){
  Connection c=DBConnect.getDBConnection();
  PreparedStatement s=null;
  try {
    s=DBUtils.prepareStatement(c,query,args);
    return selectLongValue(s);
  }
 catch (  SQLException e) {
    throw new IOFailure(""String_Node_Str"" + query + ""String_Node_Str""+ args+ ""String_Node_Str""+ ExceptionUtils.getSQLExceptionCause(e),e);
  }
 finally {
    DBUtils.closeStatementIfOpen(s);
  }
}",0.963914373088685
90051,"/** 
 * Method to perform a rollback of complex DB updates.  If no commit has been performed, this will undo the entire transaction, otherwise nothing will happen.  This should be called in a finally block with no DB updates after the last commit. Thus exceptions while closing are ignored, but logged as warnings.
 * @param c the db-connection
 * @param action The action going on, before calling this method
 * @param o The being acted upon by this action
 */
public static void rollbackIfNeeded(Connection c,String action,Object o){
  try {
    c.rollback();
    c.setAutoCommit(true);
  }
 catch (  SQLException e) {
    log.warn(""String_Node_Str"" + action + ""String_Node_Str""+ o,e);
  }
}","/** 
 * Method to perform a rollback of complex DB updates.  If no commit has been performed, this will undo the entire transaction, otherwise nothing will happen.  This should be called in a finally block with no DB updates after the last commit. Thus exceptions while closing are ignored, but logged as warnings.
 * @param c the db-connection
 * @param action The action going on, before calling this method
 * @param o The being acted upon by this action
 */
public static void rollbackIfNeeded(Connection c,String action,Object o){
  try {
    c.rollback();
    c.setAutoCommit(true);
  }
 catch (  SQLException e) {
    log.warn(""String_Node_Str"" + action + ""String_Node_Str""+ o+ ""String_Node_Str""+ ExceptionUtils.getSQLExceptionCause(e),e);
  }
}",0.9591695501730104
90052,"/** 
 * Execute an SQL query and return whether the result contains any rows.
 * @param query a query with ? for parameters
 * @param args parameters of type string, int, long or boolean
 * @return True if executing the query resulted in at least one row.
 * @throws IOFailure if there were problems with the SQL query
 */
public static boolean selectAny(String query,Object... args){
  Connection c=DBConnect.getDBConnection();
  PreparedStatement s=null;
  try {
    s=prepareStatement(c,query,args);
    return s.executeQuery().next();
  }
 catch (  SQLException e) {
    throw new IOFailure(""String_Node_Str"" + query + ""String_Node_Str""+ args,e);
  }
 finally {
    closeStatementIfOpen(s);
  }
}","/** 
 * Execute an SQL query and return whether the result contains any rows.
 * @param query a query with ? for parameters
 * @param args parameters of type string, int, long or boolean
 * @return True if executing the query resulted in at least one row.
 * @throws IOFailure if there were problems with the SQL query
 */
public static boolean selectAny(String query,Object... args){
  Connection c=DBConnect.getDBConnection();
  PreparedStatement s=null;
  try {
    s=prepareStatement(c,query,args);
    return s.executeQuery().next();
  }
 catch (  SQLException e) {
    throw new IOFailure(""String_Node_Str"" + query + ""String_Node_Str""+ args+ ""String_Node_Str""+ ExceptionUtils.getSQLExceptionCause(e),e);
  }
 finally {
    closeStatementIfOpen(s);
  }
}",0.9595613433858808
90053,"/** 
 * Return a description of where an object is used elsewhere in the database, or null.
 * @param select A select statement finding the names of other uses.  Thestatement should result in exactly one column of string values.
 * @param victim The object being used.
 * @param args Any objects that may be used to prepare the select statement.
 * @return A string describing the usages, or null if no usages were found.
 */
public static String getUsages(String select,Object victim,Object... args){
  Connection c=DBConnect.getDBConnection();
  PreparedStatement s=null;
  try {
    s=prepareStatement(c,select,args);
    ResultSet res=s.executeQuery();
    if (res.next()) {
      List<String> usedIn=new ArrayList<String>();
      do {
        usedIn.add(res.getString(1));
      }
 while (res.next());
      return usedIn.toString();
    }
    return null;
  }
 catch (  SQLException e) {
    final String message=""String_Node_Str"" + victim;
    log.warn(message,e);
    throw new IOFailure(message,e);
  }
 finally {
    closeStatementIfOpen(s);
  }
}","/** 
 * Return a description of where an object is used elsewhere in the database, or null.
 * @param select A select statement finding the names of other uses.  Thestatement should result in exactly one column of string values.
 * @param victim The object being used.
 * @param args Any objects that may be used to prepare the select statement.
 * @return A string describing the usages, or null if no usages were found.
 */
public static String getUsages(String select,Object victim,Object... args){
  Connection c=DBConnect.getDBConnection();
  PreparedStatement s=null;
  try {
    s=prepareStatement(c,select,args);
    ResultSet res=s.executeQuery();
    if (res.next()) {
      List<String> usedIn=new ArrayList<String>();
      do {
        usedIn.add(res.getString(1));
      }
 while (res.next());
      return usedIn.toString();
    }
    return null;
  }
 catch (  SQLException e) {
    final String message=""String_Node_Str"" + victim + ""String_Node_Str""+ ExceptionUtils.getSQLExceptionCause(e);
    log.warn(message,e);
    throw new IOFailure(message,e);
  }
 finally {
    closeStatementIfOpen(s);
  }
}",0.9724264705882352
90054,"/** 
 * Execute an SQL statement and return the first long in the result set, or null if resultset is empty.
 * @param query a query with ? for parameters
 * @param args parameters of type string, int, long or boolean
 * @return The long result, or will return null in one of the two followingcases: There is no results, or the first result is a null-value.
 * @throws IOFailure on SQL errors.
 */
public static Long selectFirstLongValueIfAny(String query,Object... args){
  Connection c=DBConnect.getDBConnection();
  PreparedStatement s=null;
  try {
    s=DBUtils.prepareStatement(c,query,args);
    ResultSet rs=s.executeQuery();
    if (rs.next()) {
      return DBUtils.getLongMaybeNull(rs,1);
    }
 else {
      return null;
    }
  }
 catch (  SQLException e) {
    String message=""String_Node_Str"" + query + ""String_Node_Str"";
    log.warn(message,e);
    throw new IOFailure(message,e);
  }
 finally {
    DBUtils.closeStatementIfOpen(s);
  }
}","/** 
 * Execute an SQL statement and return the first long in the result set, or null if resultset is empty.
 * @param query a query with ? for parameters
 * @param args parameters of type string, int, long or boolean
 * @return The long result, or will return null in one of the two followingcases: There is no results, or the first result is a null-value.
 * @throws IOFailure on SQL errors.
 */
public static Long selectFirstLongValueIfAny(String query,Object... args){
  Connection c=DBConnect.getDBConnection();
  PreparedStatement s=null;
  try {
    s=DBUtils.prepareStatement(c,query,args);
    ResultSet rs=s.executeQuery();
    if (rs.next()) {
      return DBUtils.getLongMaybeNull(rs,1);
    }
 else {
      return null;
    }
  }
 catch (  SQLException e) {
    String message=""String_Node_Str"" + query + ""String_Node_Str""+ ""String_Node_Str""+ ExceptionUtils.getSQLExceptionCause(e);
    log.warn(message,e);
    throw new IOFailure(message,e);
  }
 finally {
    DBUtils.closeStatementIfOpen(s);
  }
}",0.9700355510411376
90055,"/** 
 * Execute an SQL statement and return the single string in the result set.
 * @param s A prepared statement
 * @return The string result, or null if the result was a null valueNote that a null value is not the same as no result rows.
 * @throws IOFailure if the statement didn't result in exactly one row witha string or null value
 */
public static String selectStringValue(PreparedStatement s){
  try {
    ResultSet res=s.executeQuery();
    if (!res.next()) {
      throw new IOFailure(""String_Node_Str"" + s);
    }
    String resultString=res.getString(1);
    if (res.wasNull()) {
      resultString=null;
    }
    if (res.next()) {
      throw new IOFailure(""String_Node_Str"" + s);
    }
    return resultString;
  }
 catch (  SQLException e) {
    throw new IOFailure(""String_Node_Str"" + s,e);
  }
}","/** 
 * Execute an SQL statement and return the single string in the result set.
 * @param s A prepared statement
 * @return The string result, or null if the result was a null valueNote that a null value is not the same as no result rows.
 * @throws IOFailure if the statement didn't result in exactly one row witha string or null value
 */
public static String selectStringValue(PreparedStatement s){
  try {
    ResultSet res=s.executeQuery();
    if (!res.next()) {
      throw new IOFailure(""String_Node_Str"" + s);
    }
    String resultString=res.getString(1);
    if (res.wasNull()) {
      resultString=null;
    }
    if (res.next()) {
      throw new IOFailure(""String_Node_Str"" + s);
    }
    return resultString;
  }
 catch (  SQLException e) {
    throw new IOFailure(""String_Node_Str"" + s + ""String_Node_Str""+ ExceptionUtils.getSQLExceptionCause(e),e);
  }
}",0.9644549763033176
90056,"/** 
 * Execute an SQL statement and return the single int in the result set. This variant takes a query string and a single string arg and combines them to form a normal query.
 * @param query a query with ? for parameters
 * @param args parameters of type string, int, long or boolean
 * @return The integer result
 * @throws IOFailure if the statement didn't result in exactly one integer
 */
public static Integer selectIntValue(String query,Object... args){
  Connection c=DBConnect.getDBConnection();
  PreparedStatement s=null;
  try {
    s=DBUtils.prepareStatement(c,query,args);
    return selectIntValue(s);
  }
 catch (  SQLException e) {
    throw new IOFailure(""String_Node_Str"" + query + ""String_Node_Str""+ args,e);
  }
 finally {
    DBUtils.closeStatementIfOpen(s);
  }
}","/** 
 * Execute an SQL statement and return the single int in the result set. This variant takes a query string and a single string arg and combines them to form a normal query.
 * @param query a query with ? for parameters
 * @param args parameters of type string, int, long or boolean
 * @return The integer result
 * @throws IOFailure if the statement didn't result in exactly one integer
 */
public static Integer selectIntValue(String query,Object... args){
  Connection c=DBConnect.getDBConnection();
  PreparedStatement s=null;
  try {
    s=DBUtils.prepareStatement(c,query,args);
    return selectIntValue(s);
  }
 catch (  SQLException e) {
    throw new IOFailure(""String_Node_Str"" + query + ""String_Node_Str""+ args+ ""String_Node_Str""+ ExceptionUtils.getSQLExceptionCause(e),e);
  }
 finally {
    DBUtils.closeStatementIfOpen(s);
  }
}",0.963914373088685
90057,"/** 
 * Returns the version of a table according to schemaversions, or 0 for the initial, unnumbered version.
 * @param tablename The name of a table in the database.
 * @return Version of the given table.
 * @throws IOFailure if DB table schemaversions does not exist
 */
public static int getTableVersion(String tablename) throws IOFailure {
  Connection c=DBConnect.getDBConnection();
  PreparedStatement s=null;
  int version=0;
  try {
    s=c.prepareStatement(""String_Node_Str"" + ""String_Node_Str"");
    s.setString(1,tablename);
    ResultSet res=s.executeQuery();
    if (!res.next()) {
      log.warn(""String_Node_Str"" + tablename + ""String_Node_Str"");
    }
 else {
      version=res.getInt(1);
      if (res.wasNull()) {
        log.warn(""String_Node_Str"" + tablename + ""String_Node_Str"");
      }
    }
    return version;
  }
 catch (  SQLException e) {
    String msg=""String_Node_Str"" + tablename;
    log.warn(msg,e);
    throw new IOFailure(msg,e);
  }
 finally {
    DBUtils.closeStatementIfOpen(s);
  }
}","/** 
 * Returns the version of a table according to schemaversions, or 0 for the initial, unnumbered version.
 * @param tablename The name of a table in the database.
 * @return Version of the given table.
 * @throws IOFailure if DB table schemaversions does not exist
 */
public static int getTableVersion(String tablename) throws IOFailure {
  Connection c=DBConnect.getDBConnection();
  PreparedStatement s=null;
  int version=0;
  try {
    s=c.prepareStatement(""String_Node_Str"" + ""String_Node_Str"");
    s.setString(1,tablename);
    ResultSet res=s.executeQuery();
    if (!res.next()) {
      log.warn(""String_Node_Str"" + tablename + ""String_Node_Str"");
    }
 else {
      version=res.getInt(1);
      if (res.wasNull()) {
        log.warn(""String_Node_Str"" + tablename + ""String_Node_Str"");
      }
    }
    return version;
  }
 catch (  SQLException e) {
    String msg=""String_Node_Str"" + tablename + ""String_Node_Str""+ ExceptionUtils.getSQLExceptionCause(e);
    log.warn(msg,e);
    throw new IOFailure(msg,e);
  }
 finally {
    DBUtils.closeStatementIfOpen(s);
  }
}",0.9715099715099716
90058,"/** 
 * Check whether an object is used elsewhere in the database.
 * @param select A select statement finding the names of other uses.  Thestatement should result in exactly one column of string values.
 * @param victim The object being used.
 * @param args Any objects that may be used to prepare the select statement.
 * @throws PermissionDenied if the object has usages.
 */
public static void checkForUses(String select,Object victim,Object... args){
  String usages=DBUtils.getUsages(select,victim,args);
  if (usages != null) {
    String message=""String_Node_Str"" + victim + ""String_Node_Str""+ usages;
    throw new PermissionDenied(message);
  }
  Connection c=DBConnect.getDBConnection();
  PreparedStatement s=null;
  try {
    s=prepareStatement(c,select,args);
    ResultSet res=s.executeQuery();
    if (res.next()) {
      List<String> usedIn=new ArrayList<String>();
      do {
        usedIn.add(res.getString(1));
      }
 while (res.next());
    }
  }
 catch (  SQLException e) {
    final String message=""String_Node_Str"" + victim;
    log.warn(message,e);
    throw new IOFailure(message,e);
  }
 finally {
    closeStatementIfOpen(s);
  }
}","/** 
 * Check whether an object is used elsewhere in the database.
 * @param select A select statement finding the names of other uses.  Thestatement should result in exactly one column of string values.
 * @param victim The object being used.
 * @param args Any objects that may be used to prepare the select statement.
 * @throws PermissionDenied if the object has usages.
 */
public static void checkForUses(String select,Object victim,Object... args){
  String usages=DBUtils.getUsages(select,victim,args);
  if (usages != null) {
    String message=""String_Node_Str"" + victim + ""String_Node_Str""+ usages;
    throw new PermissionDenied(message);
  }
  Connection c=DBConnect.getDBConnection();
  PreparedStatement s=null;
  try {
    s=prepareStatement(c,select,args);
    ResultSet res=s.executeQuery();
    if (res.next()) {
      List<String> usedIn=new ArrayList<String>();
      do {
        usedIn.add(res.getString(1));
      }
 while (res.next());
    }
  }
 catch (  SQLException e) {
    final String message=""String_Node_Str"" + victim;
    log.warn(message + ""String_Node_Str"" + ExceptionUtils.getSQLExceptionCause(e),e);
    throw new IOFailure(message + ""String_Node_Str"" + ExceptionUtils.getSQLExceptionCause(e),e);
  }
 finally {
    closeStatementIfOpen(s);
  }
}",0.9501226492232216
90059,"/** 
 * Close a statement, if not closed already Note: This does not throw any a SQLException, because it is always called inside a finally-clause. Exceptions are logged as warnings, though.
 * @param s a statement
 */
public static void closeStatementIfOpen(PreparedStatement s){
  if (s != null) {
    try {
      s.close();
    }
 catch (    SQLException e) {
      log.warn(""String_Node_Str"" + s,e);
    }
  }
}","/** 
 * Close a statement, if not closed already Note: This does not throw any a SQLException, because it is always called inside a finally-clause. Exceptions are logged as warnings, though.
 * @param s a statement
 */
public static void closeStatementIfOpen(PreparedStatement s){
  if (s != null) {
    try {
      s.close();
    }
 catch (    SQLException e) {
      log.warn(""String_Node_Str"" + s + ""String_Node_Str""+ ExceptionUtils.getSQLExceptionCause(e),e);
    }
  }
}",0.9325842696629212
90060,"/** 
 * Update a database by executing all the statements in the updates String array. NOTE: this must NOT be used for tables under version control It must only be used in connection with temporary tables e.g. used for backup.
 * @param updates The SQL statements that makes the necessaryupdates.
 * @throws IOFailure in case of problems in interacting with the database
 */
public static void executeSQL(final String... updates){
  Connection c=DBConnect.getDBConnection();
  PreparedStatement st=null;
  String s=""String_Node_Str"";
  try {
    c.setAutoCommit(false);
    for (    String update : updates) {
      s=update;
      log.debug(""String_Node_Str"" + update);
      st=prepareStatement(c,update);
      st.executeUpdate();
      st.close();
    }
    c.setAutoCommit(true);
    log.debug(""String_Node_Str"" + StringUtils.conjoin(""String_Node_Str"",updates) + ""String_Node_Str"");
  }
 catch (  SQLException e) {
    String msg=""String_Node_Str"" + s;
    log.warn(msg,e);
    throw new IOFailure(msg,e);
  }
 finally {
    rollbackIfNeeded(c,""String_Node_Str"",StringUtils.conjoin(""String_Node_Str"",updates) + ""String_Node_Str"");
    closeStatementIfOpen(st);
  }
}","/** 
 * Update a database by executing all the statements in the updates String array. NOTE: this must NOT be used for tables under version control It must only be used in connection with temporary tables e.g. used for backup.
 * @param updates The SQL statements that makes the necessaryupdates.
 * @throws IOFailure in case of problems in interacting with the database
 */
public static void executeSQL(final String... updates){
  Connection c=DBConnect.getDBConnection();
  PreparedStatement st=null;
  String s=""String_Node_Str"";
  try {
    c.setAutoCommit(false);
    for (    String update : updates) {
      s=update;
      log.debug(""String_Node_Str"" + update);
      st=prepareStatement(c,update);
      st.executeUpdate();
      st.close();
    }
    c.setAutoCommit(true);
    log.debug(""String_Node_Str"" + StringUtils.conjoin(""String_Node_Str"",updates) + ""String_Node_Str"");
  }
 catch (  SQLException e) {
    String msg=""String_Node_Str"" + s + ""String_Node_Str""+ ExceptionUtils.getSQLExceptionCause(e);
    log.warn(msg,e);
    throw new IOFailure(msg,e);
  }
 finally {
    rollbackIfNeeded(c,""String_Node_Str"",StringUtils.conjoin(""String_Node_Str"",updates) + ""String_Node_Str"");
    closeStatementIfOpen(st);
  }
}",0.9750208159866778
90061,"/** 
 * Returns <tt>true</tt> if the iteration has more elements. (In other words, returns <tt>true</tt> if <tt>next</tt> would return an element rather than throwing an exception.)
 * @return <tt>true</tt> if the iterator has more elements.
 */
public boolean hasNext(){
  if (objectCache == null) {
    try {
      if (!isClosed && res.next()) {
        objectCache=filter(res);
      }
 else {
        isClosed=true;
        res.close();
      }
    }
 catch (    SQLException e) {
      throw new IOFailure(""String_Node_Str"" + res,e);
    }
  }
  return objectCache != null;
}","/** 
 * Returns <tt>true</tt> if the iteration has more elements. (In other words, returns <tt>true</tt> if <tt>next</tt> would return an element rather than throwing an exception.)
 * @return <tt>true</tt> if the iterator has more elements.
 */
public boolean hasNext(){
  if (objectCache == null) {
    try {
      if (!isClosed && res.next()) {
        objectCache=filter(res);
      }
 else {
        isClosed=true;
        res.close();
      }
    }
 catch (    SQLException e) {
      throw new IOFailure(""String_Node_Str"" + res + ""String_Node_Str""+ ExceptionUtils.getSQLExceptionCause(e),e);
    }
  }
  return objectCache != null;
}",0.9508196721311476
90062,"/** 
 * this test confirms that the message generated by getSQLExceptionCause() contains all the information in the original SQLException
 */
public void testGetSQLExceptionCause(){
  SQLException ex1=new SQLException(""String_Node_Str"",""String_Node_Str"",101);
  SQLException ex2=new SQLException(""String_Node_Str"",""String_Node_Str"",102);
  SQLException ex3=new SQLException(""String_Node_Str"",""String_Node_Str"",103);
  ex1.setNextException(ex2);
  ex2.setNextException(ex3);
  String message=ExceptionUtils.getSQLExceptionCause(ex1);
  System.out.println(message);
  StringAsserts.assertStringContains(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",message,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
}","/** 
 * this test confirms that the message generated by getSQLExceptionCause() contains all the information in the original SQLException
 */
public void testGetSQLExceptionCause(){
  SQLException ex1=new SQLException(""String_Node_Str"",""String_Node_Str"",101);
  SQLException ex2=new SQLException(""String_Node_Str"",""String_Node_Str"",102);
  SQLException ex3=new SQLException(""String_Node_Str"",""String_Node_Str"",103);
  ex1.setNextException(ex2);
  ex2.setNextException(ex3);
  String message=dk.netarkivet.common.utils.ExceptionUtils.getSQLExceptionCause(ex1);
  System.out.println(message);
  StringAsserts.assertStringContains(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",message,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
}",0.984033116499113
90063,"/** 
 * Get a connection to our database. Assumes that AutoCommit is true.
 * @return a connection to our database
 * @throws IOFailure if we cannot connect to the database (or find thedriver).
 */
public static Connection getDBConnection(){
  if (connectionPool.get(Thread.currentThread()) == null) {
    try {
      Class.forName(DBSpecifics.getInstance().getDriverClassName());
      Connection connection=DriverManager.getConnection(Settings.get(CommonSettings.DB_URL));
      connectionPool.put(Thread.currentThread(),connection);
      log.info(""String_Node_Str"" + Settings.get(CommonSettings.DB_URL) + ""String_Node_Str""+ DBSpecifics.getInstance().getDriverClassName()+ ""String_Node_Str"");
    }
 catch (    ClassNotFoundException e) {
      final String message=""String_Node_Str"" + DBSpecifics.getInstance().getDriverClassName() + ""String_Node_Str"";
      log.warn(message,e);
      throw new IOFailure(message,e);
    }
catch (    SQLException e) {
      final String message=""String_Node_Str"" + Settings.get(CommonSettings.DB_URL) + ""String_Node_Str""+ DBSpecifics.getInstance().getDriverClassName()+ ""String_Node_Str"";
      log.warn(message,e);
      throw new IOFailure(message,e);
    }
  }
  return connectionPool.get(Thread.currentThread());
}","/** 
 * Get a connection to our database. Assumes that AutoCommit is true.
 * @return a connection to our database
 * @throws IOFailure if we cannot connect to the database (or find thedriver).
 */
public static Connection getDBConnection(){
  if (connectionPool.get(Thread.currentThread()) == null) {
    try {
      Class.forName(DBSpecifics.getInstance().getDriverClassName());
      Connection connection=DriverManager.getConnection(Settings.get(CommonSettings.DB_URL));
      connectionPool.put(Thread.currentThread(),connection);
      log.info(""String_Node_Str"" + Settings.get(CommonSettings.DB_URL) + ""String_Node_Str""+ DBSpecifics.getInstance().getDriverClassName()+ ""String_Node_Str"");
    }
 catch (    ClassNotFoundException e) {
      final String message=""String_Node_Str"" + DBSpecifics.getInstance().getDriverClassName() + ""String_Node_Str"";
      log.warn(message,e);
      throw new IOFailure(message,e);
    }
catch (    SQLException e) {
      final String message=""String_Node_Str"" + Settings.get(CommonSettings.DB_URL) + ""String_Node_Str""+ DBSpecifics.getInstance().getDriverClassName()+ ""String_Node_Str""+ ""String_Node_Str""+ ExceptionUtils.getSQLExceptionCause(e);
      log.warn(message,e);
      throw new IOFailure(message,e);
    }
  }
  return connectionPool.get(Thread.currentThread());
}",0.9770695685969684
90064,"/** 
 * Shutdown the database system, if running embeddedly.  Otherwise, this is ignored. <p/> Will log a warning on errors, but otherwise ignore them.
 */
public void shutdownDatabase(){
  try {
    DriverManager.getConnection(""String_Node_Str"");
    log.warn(""String_Node_Str"");
  }
 catch (  SQLException e) {
    log.info(""String_Node_Str"");
    log.debug(""String_Node_Str"",e);
  }
}","/** 
 * Shutdown the database system, if running embeddedly.  Otherwise, this is ignored. <p/> Will log a warning on errors, but otherwise ignore them.
 */
public void shutdownDatabase(){
  try {
    DriverManager.getConnection(""String_Node_Str"");
    log.warn(""String_Node_Str"");
  }
 catch (  SQLException e) {
    log.info(""String_Node_Str"");
    log.debug(""String_Node_Str"" + ""String_Node_Str"" + ExceptionUtils.getSQLExceptionCause(e),e);
  }
}",0.9269461077844312
90065,"/** 
 * Copy inherited securityPolicyFile to local directory.
 * @param directory The local directory for this machine
 */
protected void createSecurityPolicyFile(File directory){
  ArgumentNotValid.checkNotNull(directory,""String_Node_Str"");
  try {
    File secPolFile=new File(directory,""String_Node_Str"");
    FileWriter secfw=new FileWriter(secPolFile);
    String prop=FileUtils.readFile(inheritedSecurityPolicyFile);
    String monitorRole=settings.getLeafValue(Constants.SETTINGS_JMX_PASSWORD_LEAF);
    if (monitorRole != null) {
      prop=prop.replace(Constants.SECURITY_JMX_PRINCIPAL_NAME_TAG,monitorRole);
    }
    String ctd=settings.getLeafValue(Constants.SETTINGS_TEMPDIR_LEAF);
    if (ctd != null) {
      prop=prop.replace(Constants.SECURITY_COMMON_TEMP_DIR_TAG,ctd);
    }
    secfw.write(prop);
    List<String> dirs=new ArrayList<String>();
    for (    Application app : applications) {
      String[] tmpDirs=app.getSettingsValues(Constants.SETTINGS_BITARCHIVE_FILEDIR_LEAF);
      if (tmpDirs != null && tmpDirs.length > 0) {
        for (        String st : tmpDirs) {
          dirs.add(st);
        }
      }
    }
    if (dirs.size() > 0) {
      secfw.write(""String_Node_Str"" + ""String_Node_Str"");
      for (      String dir : dirs) {
        secfw.write(""String_Node_Str"");
        secfw.write(changeFileDirPathForSecurity(dir));
        secfw.write(""String_Node_Str"");
        secfw.write(""String_Node_Str"" + ""String_Node_Str"");
      }
      secfw.write(""String_Node_Str"");
    }
    secfw.close();
  }
 catch (  IOException e) {
    log.warn(""String_Node_Str"" + e);
  }
}","/** 
 * Copy inherited securityPolicyFile to local directory.
 * @param directory The local directory for this machine
 */
protected void createSecurityPolicyFile(File directory){
  ArgumentNotValid.checkNotNull(directory,""String_Node_Str"");
  try {
    File secPolFile=new File(directory,""String_Node_Str"");
    FileWriter secfw=new FileWriter(secPolFile);
    String prop=FileUtils.readFile(inheritedSecurityPolicyFile);
    String monitorRole=settings.getLeafValue(Constants.SETTINGS_JMX_NAME_LEAF);
    if (monitorRole != null) {
      prop=prop.replace(Constants.SECURITY_JMX_PRINCIPAL_NAME_TAG,monitorRole);
    }
    String ctd=settings.getLeafValue(Constants.SETTINGS_TEMPDIR_LEAF);
    if (ctd != null) {
      prop=prop.replace(Constants.SECURITY_COMMON_TEMP_DIR_TAG,ctd);
    }
    secfw.write(prop);
    List<String> dirs=new ArrayList<String>();
    for (    Application app : applications) {
      String[] tmpDirs=app.getSettingsValues(Constants.SETTINGS_BITARCHIVE_FILEDIR_LEAF);
      if (tmpDirs != null && tmpDirs.length > 0) {
        for (        String st : tmpDirs) {
          dirs.add(st);
        }
      }
    }
    if (dirs.size() > 0) {
      secfw.write(""String_Node_Str"" + ""String_Node_Str"");
      for (      String dir : dirs) {
        secfw.write(""String_Node_Str"");
        secfw.write(changeFileDirPathForSecurity(dir));
        secfw.write(""String_Node_Str"");
        secfw.write(""String_Node_Str"" + ""String_Node_Str"");
      }
      secfw.write(""String_Node_Str"");
    }
    secfw.close();
  }
 catch (  IOException e) {
    log.warn(""String_Node_Str"" + e);
  }
}",0.9968827930174564
90066,"/** 
 * Makes the install path with linux syntax.
 * @return The path in linux syntax.
 */
public String installPathLinux(){
  return machineParameters.getInstallDirValue() + ""String_Node_Str"" + settings.getSubChildValue(Constants.ENVIRONMENT_NAME_SETTING_PATH_LEAF);
}","/** 
 * Makes the install path with linux syntax.
 * @return The path in linux syntax.
 */
public String installPathLinux(){
  return machineParameters.getInstallDirValue() + ""String_Node_Str"" + settings.getSubChildValue(Constants.SETTINGS_ENVIRONMENT_NAME_LEAF);
}",0.9588014981273408
90067,"/** 
 * Extract the local variables from the root. Currently, this is the name and the optional applicationId.
 */
private void extractVariables(){
  try {
    Attribute at=applicationRoot.attribute(Constants.APPLICATION_NAME_ATTRIBUTE);
    if (at != null) {
      nameWithNamePath=at.getText();
      String[] stlist=nameWithNamePath.split(""String_Node_Str"");
      name=stlist[stlist.length - 1];
    }
 else {
      log.debug(""String_Node_Str"");
      name=""String_Node_Str"";
      nameWithNamePath=""String_Node_Str"";
    }
    Element elem=settings.getSubChild(Constants.APPLICATION_INSTANCE_ID_PATH);
    if (elem != null && !elem.getText().isEmpty()) {
      applicationId=elem.getText();
    }
 else {
      applicationId=null;
    }
  }
 catch (  Exception e) {
    log.debug(""String_Node_Str"" + e);
    throw new IOFailure(""String_Node_Str"" + e);
  }
}","/** 
 * Extract the local variables from the root. Currently, this is the name and the optional applicationId.
 */
private void extractVariables(){
  try {
    Attribute at=applicationRoot.attribute(Constants.APPLICATION_NAME_ATTRIBUTE);
    if (at != null) {
      nameWithNamePath=at.getText();
      String[] stlist=nameWithNamePath.split(""String_Node_Str"");
      name=stlist[stlist.length - 1];
      String xmlName=XmlStructure.pathAndContentToXML(nameWithNamePath,Constants.COMPLETE_APPLICATION_NAME_LEAF);
      Element appXmlName=XmlStructure.makeElementFromString(xmlName);
      settings.overWrite(appXmlName);
    }
 else {
      log.debug(""String_Node_Str"");
      name=""String_Node_Str"";
      nameWithNamePath=""String_Node_Str"";
    }
    Element elem=settings.getSubChild(Constants.SETTINGS_APPLICATION_INSTANCE_ID_LEAF);
    if (elem != null && !elem.getText().isEmpty()) {
      applicationId=elem.getText();
    }
 else {
      applicationId=null;
    }
  }
 catch (  Exception e) {
    log.debug(""String_Node_Str"" + e);
    throw new IOFailure(""String_Node_Str"" + e);
  }
}",0.7140664961636829
90068,"/** 
 * Makes the install path with windows syntax.
 * @return The path with windows syntax.
 */
public String installPathWindows(){
  return machineParameters.getInstallDirValue() + ""String_Node_Str"" + settings.getSubChildValue(Constants.ENVIRONMENT_NAME_SETTING_PATH_LEAF);
}","/** 
 * Makes the install path with windows syntax.
 * @return The path with windows syntax.
 */
public String installPathWindows(){
  return machineParameters.getInstallDirValue() + ""String_Node_Str"" + settings.getSubChildValue(Constants.SETTINGS_ENVIRONMENT_NAME_LEAF);
}",0.96
90069,"/** 
 * A application is the program to be run on a machine.
 * @param e The root of this instance in the XML document.
 * @param parentSettings The setting inherited by the parent.
 * @param param The machine parameters inherited by the parent.
 */
public Application(Element e,XmlStructure parentSettings,Parameters param){
  ArgumentNotValid.checkNotNull(e,""String_Node_Str"");
  ArgumentNotValid.checkNotNull(parentSettings,""String_Node_Str"");
  ArgumentNotValid.checkNotNull(param,""String_Node_Str"");
  settings=new XmlStructure(parentSettings.getRoot());
  applicationRoot=e;
  machineParameters=new Parameters(param);
  Element tmpSet=applicationRoot.element(Constants.SETTINGS_BRANCH);
  if (tmpSet != null) {
    settings.overWrite(tmpSet);
  }
  machineParameters.newParameters(applicationRoot);
  extractVariables();
}","/** 
 * A application is the program to be run on a machine.
 * @param e The root of this instance in the XML document.
 * @param parentSettings The setting inherited by the parent.
 * @param param The machine parameters inherited by the parent.
 */
public Application(Element e,XmlStructure parentSettings,Parameters param){
  ArgumentNotValid.checkNotNull(e,""String_Node_Str"");
  ArgumentNotValid.checkNotNull(parentSettings,""String_Node_Str"");
  ArgumentNotValid.checkNotNull(param,""String_Node_Str"");
  settings=new XmlStructure(parentSettings.getRoot());
  applicationRoot=e;
  machineParameters=new Parameters(param);
  Element tmpSet=applicationRoot.element(Constants.COMPLETE_SETTINGS_BRANCH);
  if (tmpSet != null) {
    settings.overWrite(tmpSet);
  }
  machineParameters.newParameters(applicationRoot);
  extractVariables();
}",0.9945945945945946
90070,"/** 
 * Function to apply the variables.
 * @param offset The input offset value (1-9 below httpPort).
 * @param httpPort The new value for the HTTP port.
 * @param environmentName The new value for the environment name.
 * @param mailReceiver The new value for the mailReceiver.
 */
public void applyTestArguments(String offset,String httpPort,String environmentName,String mailReceiver){
  ArgumentNotValid.checkNotNullOrEmpty(offset,""String_Node_Str"");
  ArgumentNotValid.checkNotNullOrEmpty(httpPort,""String_Node_Str"");
  ArgumentNotValid.checkNotNullOrEmpty(environmentName,""String_Node_Str"");
  ArgumentNotValid.checkNotNullOrEmpty(mailReceiver,""String_Node_Str"");
  int offsetInt=(new Integer(httpPort)).intValue() - (new Integer(offset)).intValue();
  if (offsetInt > Constants.TEST_OFFSET_INTEGER_MAXIMUM_VALUE || offsetInt < 0) {
    System.err.print(Constants.MSG_ERROR_TEST_OFFSET);
    System.out.println();
    System.exit(0);
  }
  offsetVal=new String(""String_Node_Str"" + offsetInt);
  httpPortVal=httpPort;
  environmentNameVal=environmentName;
  mailReceiverVal=mailReceiver;
  httpPortPath=Constants.SETTINGS_HTTP_PORT_PATH;
  environmentNamePath=Constants.ENVIRONMENT_NAME_TOTAL_PATH_LEAF;
  mailReceiverPath=Constants.SETTINGS_NOTIFICATION_RECEIVER_PATH;
  offsetPaths=new OffsetSystem[]{new OffsetSystem(2,Constants.TEXT_JMX_PORT_PATH),new OffsetSystem(2,Constants.TEXT_JMX_RMI_PORT_PATH),new OffsetSystem(1,Constants.TEXT_HARVEST_HETRIX_GUI_PORT),new OffsetSystem(1,Constants.TEXT_HARVEST_HETRIX_JMX_PORT)};
  apply();
}","/** 
 * Function to apply the variables.
 * @param offset The input offset value (1-9 below httpPort).
 * @param httpPort The new value for the HTTP port.
 * @param environmentName The new value for the environment name.
 * @param mailReceiver The new value for the mailReceiver.
 */
public void applyTestArguments(String offset,String httpPort,String environmentName,String mailReceiver){
  ArgumentNotValid.checkNotNullOrEmpty(offset,""String_Node_Str"");
  ArgumentNotValid.checkNotNullOrEmpty(httpPort,""String_Node_Str"");
  ArgumentNotValid.checkNotNullOrEmpty(environmentName,""String_Node_Str"");
  ArgumentNotValid.checkNotNullOrEmpty(mailReceiver,""String_Node_Str"");
  int offsetInt=(new Integer(httpPort)).intValue() - (new Integer(offset)).intValue();
  if (offsetInt > Constants.TEST_OFFSET_INTEGER_MAXIMUM_VALUE || offsetInt < 0) {
    System.err.print(Constants.MSG_ERROR_TEST_OFFSET);
    System.out.println();
    System.exit(0);
  }
  offsetVal=new String(""String_Node_Str"" + offsetInt);
  httpPortVal=httpPort;
  environmentNameVal=environmentName;
  mailReceiverVal=mailReceiver;
  httpPortPath=Constants.COMPLETE_HTTP_PORT_LEAF;
  environmentNamePath=Constants.COMPLETE_ENVIRONMENT_NAME_LEAF;
  mailReceiverPath=Constants.SETTINGS_NOTIFICATION_RECEIVER_PATH;
  offsetPaths=new OffsetSystem[]{new OffsetSystem(2,Constants.COMPLETE_JMX_PORT_PATH),new OffsetSystem(2,Constants.TEXT_JMX_RMI_PORT_PATH),new OffsetSystem(1,Constants.COMPLETE_HARVEST_HETRIX_GUI_PORT_PATH),new OffsetSystem(1,Constants.COMPLETE_HARVEST_HETRIX_JMX_PORT)};
  apply();
}",0.9725894872621736
90071,"/** 
 * Applies the new variables. Goes through all element instances and applies the variables.
 */
@SuppressWarnings(""String_Node_Str"") private void apply(){
  applyOnElement(set.getRoot());
  List<Element> physLocs=set.getChildren(Constants.PHYSICAL_LOCATION_BRANCH);
  for (  Element pl : physLocs) {
    applyOnElement(pl);
    List<Element> machines=pl.elements(Constants.MACHINE_BRANCH);
    for (    Element mac : machines) {
      applyOnElement(mac);
      List<Element> applications=mac.elements(Constants.APPLICATION_BRANCH);
      for (      Element app : applications) {
        applyOnElement(app);
        applyOnApplication(app);
      }
    }
  }
}","/** 
 * Applies the new variables. Goes through all element instances and applies the variables.
 */
@SuppressWarnings(""String_Node_Str"") private void apply(){
  applyOnElement(set.getRoot());
  List<Element> physLocs=set.getChildren(Constants.DEPLOY_PHYSICAL_LOCATION);
  for (  Element pl : physLocs) {
    applyOnElement(pl);
    List<Element> machines=pl.elements(Constants.DEPLOY_MACHINE);
    for (    Element mac : machines) {
      applyOnElement(mac);
      List<Element> applications=mac.elements(Constants.DEPLOY_APPLICATION_NAME);
      for (      Element app : applications) {
        applyOnElement(app);
        applyOnApplication(app);
      }
    }
  }
}",0.6192969334330591
90072,"/** 
 * Applies the environment name on the name of the file-directories. Thus: fileDir -> fileDir/environmentName
 * @param app The application where this has to be applied.
 */
@SuppressWarnings(""String_Node_Str"") private void applyOnApplication(Element app){
  Element current=app.element(Constants.SETTINGS_BRANCH);
  for (int i=0; i < Constants.SETTINGS_FILE_DIR_LEAF.length - 1; i++) {
    if (current == null) {
      return;
    }
    String st=Constants.SETTINGS_FILE_DIR_LEAF[i];
    current=current.element(st);
  }
  if (current == null) {
    return;
  }
  List<Element> elems=current.elements(Constants.SETTINGS_FILE_DIR_LEAF[Constants.SETTINGS_FILE_DIR_LEAF.length - 1]);
  for (  Element el : elems) {
    String content=el.getText();
    if (content.contains(""String_Node_Str"")) {
      content+=""String_Node_Str"" + environmentNameVal;
    }
 else {
      content+=""String_Node_Str"" + environmentNameVal;
    }
    el.setText(content);
  }
}","/** 
 * Applies the environment name on the name of the file-directories. Thus: fileDir -> fileDir/environmentName
 * @param app The application where this has to be applied.
 */
@SuppressWarnings(""String_Node_Str"") private void applyOnApplication(Element app){
  Element current=app.element(Constants.COMPLETE_SETTINGS_BRANCH);
  for (int i=0; i < Constants.SETTINGS_BITARCHIVE_FILEDIR_LEAF.length - 1; i++) {
    if (current == null) {
      return;
    }
    String st=Constants.SETTINGS_BITARCHIVE_FILEDIR_LEAF[i];
    current=current.element(st);
  }
  if (current == null) {
    return;
  }
  List<Element> elems=current.elements(Constants.SETTINGS_BITARCHIVE_FILEDIR_LEAF[Constants.SETTINGS_BITARCHIVE_FILEDIR_LEAF.length - 1]);
  for (  Element el : elems) {
    String content=el.getText();
    if (content.contains(""String_Node_Str"")) {
      content+=""String_Node_Str"" + environmentNameVal;
    }
 else {
      content+=""String_Node_Str"" + environmentNameVal;
    }
    el.setText(content);
  }
}",0.9709923664122138
90073,"/** 
 * Extracts the physical locations and put them into the list.
 */
private void extractElements(){
  physLocs=new ArrayList<PhysicalLocation>();
  List<Element> physList=config.getChildren(Constants.PHYSICAL_LOCATION_BRANCH);
  for (  Element elem : physList) {
    physLocs.add(new PhysicalLocation(elem,settings,machineParam,netarchiveSuiteFile.getName(),logPropFile,secPolicyFile,databaseFileName,resetDirectory));
  }
}","/** 
 * Extracts the physical locations and put them into the list.
 */
private void extractElements(){
  physLocs=new ArrayList<PhysicalLocation>();
  List<Element> physList=config.getChildren(Constants.DEPLOY_PHYSICAL_LOCATION);
  for (  Element elem : physList) {
    physLocs.add(new PhysicalLocation(elem,settings,machineParam,netarchiveSuiteFile.getName(),logPropFile,secPolicyFile,databaseFileName,resetDirectory));
  }
}",0.983644859813084
90074,"/** 
 * Initialise everything.
 * @param itConfigFileName Name of configuration file.
 * @param netarchiveSuiteFileName Name of installation file.
 * @param secPolicyFileName Name of security policy file.
 * @param logPropFileName Name of the log property file.
 * @param outputDirName Directory for the output.
 * @param dbFileName Name of the database.
 * @param resetDir Whether the temporary directory should be reset.
 */
public DeployConfiguration(File itConfigFileName,File netarchiveSuiteFileName,File secPolicyFileName,File logPropFileName,String outputDirName,File dbFileName,boolean resetDir){
  ArgumentNotValid.checkNotNull(itConfigFileName,""String_Node_Str"");
  ArgumentNotValid.checkNotNull(netarchiveSuiteFileName,""String_Node_Str"");
  ArgumentNotValid.checkNotNull(secPolicyFileName,""String_Node_Str"");
  ArgumentNotValid.checkNotNull(logPropFileName,""String_Node_Str"");
  ArgumentNotValid.checkNotNull(resetDir,""String_Node_Str"");
  itConfigFile=itConfigFileName;
  netarchiveSuiteFile=netarchiveSuiteFileName;
  secPolicyFile=secPolicyFileName;
  logPropFile=logPropFileName;
  databaseFileName=dbFileName;
  resetDirectory=resetDir;
  config=new XmlStructure(itConfigFile);
  settings=new XmlStructure(config.getChild(Constants.SETTINGS_BRANCH));
  machineParam=new Parameters(config);
  if (outputDirName == null) {
    outputDirName=""String_Node_Str"" + config.getSubChildValue(Constants.ENVIRONMENT_NAME_TOTAL_PATH_LEAF) + ""String_Node_Str"";
  }
  outputDir=new File(outputDirName);
  FileUtils.createDir(outputDir);
  extractElements();
}","/** 
 * Initialise everything.
 * @param itConfigFileName Name of configuration file.
 * @param netarchiveSuiteFileName Name of installation file.
 * @param secPolicyFileName Name of security policy file.
 * @param logPropFileName Name of the log property file.
 * @param outputDirName Directory for the output.
 * @param dbFileName Name of the database.
 * @param resetDir Whether the temporary directory should be reset.
 */
public DeployConfiguration(File itConfigFileName,File netarchiveSuiteFileName,File secPolicyFileName,File logPropFileName,String outputDirName,File dbFileName,boolean resetDir){
  ArgumentNotValid.checkNotNull(itConfigFileName,""String_Node_Str"");
  ArgumentNotValid.checkNotNull(netarchiveSuiteFileName,""String_Node_Str"");
  ArgumentNotValid.checkNotNull(secPolicyFileName,""String_Node_Str"");
  ArgumentNotValid.checkNotNull(logPropFileName,""String_Node_Str"");
  ArgumentNotValid.checkNotNull(resetDir,""String_Node_Str"");
  itConfigFile=itConfigFileName;
  netarchiveSuiteFile=netarchiveSuiteFileName;
  secPolicyFile=secPolicyFileName;
  logPropFile=logPropFileName;
  databaseFileName=dbFileName;
  resetDirectory=resetDir;
  config=new XmlStructure(itConfigFile);
  settings=new XmlStructure(config.getChild(Constants.COMPLETE_SETTINGS_BRANCH));
  machineParam=new Parameters(config);
  if (outputDirName == null) {
    outputDirName=""String_Node_Str"" + config.getSubChildValue(Constants.COMPLETE_ENVIRONMENT_NAME_LEAF) + ""String_Node_Str"";
  }
  outputDir=new File(outputDirName);
  FileUtils.createDir(outputDir);
  extractElements();
}",0.9907318632150848
90075,"/** 
 * Evaluates the config file. This is done by evaluating the settings branch for all the instances in  the XML-tree (global, physical locaiton, machine and application)
 */
@SuppressWarnings(""String_Node_Str"") public void evaluate(){
  evaluateElement(root.getChild(Constants.SETTINGS_BRANCH));
  List<Element> physLocs=root.getChildren(Constants.PHYSICAL_LOCATION_BRANCH);
  for (  Element pl : physLocs) {
    evaluateElement(pl.element(Constants.SETTINGS_BRANCH));
    List<Element> macs=pl.elements(Constants.MACHINE_BRANCH);
    for (    Element mac : macs) {
      evaluateElement(mac.element(Constants.SETTINGS_BRANCH));
      List<Element> apps=mac.elements(Constants.APPLICATION_BRANCH);
      for (      Element app : apps) {
        evaluateElement(app.element(Constants.SETTINGS_BRANCH));
      }
    }
  }
}","/** 
 * Evaluates the config file. This is done by evaluating the settings branch for all the instances in  the XML-tree (global, physical locaiton, machine and application)
 */
@SuppressWarnings(""String_Node_Str"") public void evaluate(){
  evaluateElement(root.getChild(Constants.COMPLETE_SETTINGS_BRANCH));
  List<Element> physLocs=root.getChildren(Constants.DEPLOY_PHYSICAL_LOCATION);
  for (  Element pl : physLocs) {
    evaluateElement(pl.element(Constants.COMPLETE_SETTINGS_BRANCH));
    List<Element> macs=pl.elements(Constants.DEPLOY_MACHINE);
    for (    Element mac : macs) {
      evaluateElement(mac.element(Constants.COMPLETE_SETTINGS_BRANCH));
      List<Element> apps=mac.elements(Constants.DEPLOY_APPLICATION_NAME);
      for (      Element app : apps) {
        evaluateElement(app.element(Constants.COMPLETE_SETTINGS_BRANCH));
      }
    }
  }
}",0.5771732702542874
90076,"/** 
 * Creates the script for creating the application specified directories.
 * @return The script for creating the application specified directories.
 */
@Override protected String getAppDirectories(){
  StringBuilder res=new StringBuilder(""String_Node_Str"");
  String[] dirs;
  for (  Application app : applications) {
    dirs=app.getSettingsValues(Constants.SETTINGS_FILE_DIR_LEAF);
    if (dirs != null && dirs.length > 0) {
      for (      String dir : dirs) {
        res.append(scriptCreateDir(dir,false));
      }
    }
    dirs=app.getSettingsValues(Constants.SETTINGS_HARVEST_SERVER_DIR_LEAF);
    if (dirs != null && dirs.length > 0) {
      for (      String dir : dirs) {
        res.append(scriptCreateDir(dir,false));
      }
    }
    dirs=app.getSettingsValues(Constants.SETTINGS_VIEWERPROXY_BASEDIR_LEAF);
    if (dirs != null && dirs.length > 0) {
      for (      String dir : dirs) {
        res.append(scriptCreateDir(dir,false));
      }
    }
  }
  return res.toString();
}","/** 
 * Creates the script for creating the application specified directories.
 * @return The script for creating the application specified directories.
 */
@Override protected String getAppDirectories(){
  StringBuilder res=new StringBuilder(""String_Node_Str"");
  String[] dirs;
  for (  Application app : applications) {
    dirs=app.getSettingsValues(Constants.SETTINGS_BITARCHIVE_FILEDIR_LEAF);
    if (dirs != null && dirs.length > 0) {
      for (      String dir : dirs) {
        res.append(scriptCreateDir(dir,false));
      }
    }
    dirs=app.getSettingsValues(Constants.SETTINGS_HARVEST_SERVERDIR_LEAF);
    if (dirs != null && dirs.length > 0) {
      for (      String dir : dirs) {
        res.append(scriptCreateDir(dir,false));
      }
    }
    dirs=app.getSettingsValues(Constants.SETTINGS_VIEWERPROXY_BASEDIR_LEAF);
    if (dirs != null && dirs.length > 0) {
      for (      String dir : dirs) {
        res.append(scriptCreateDir(dir,false));
      }
    }
  }
  return res.toString();
}",0.993535554450522
90077,"/** 
 * Changes the file directory path to the format used in the security  policy.
 * @param path The current path.
 * @return The formatted path.
 */
@Override protected String changeFileDirPathForSecurity(String path){
  path+=""String_Node_Str"" + Constants.SECURITY_FILE_DIR_ATTACHMENT + ""String_Node_Str"";
  return path.replace(""String_Node_Str"",""String_Node_Str"");
}","/** 
 * Changes the file directory path to the format used in the security  policy.
 * @param path The current path.
 * @return The formatted path.
 */
@Override protected String changeFileDirPathForSecurity(String path){
  path+=""String_Node_Str"" + Constants.SECURITY_FILE_DIR_TAG + ""String_Node_Str"";
  return path.replace(""String_Node_Str"",""String_Node_Str"");
}",0.9877551020408164
90078,"/** 
 * Creates the specified directories in the it-config. Structure - ssh login cd path; DIRS; CLEANDIR; exit; where: login = username@machine. path = path to install directory. DIRS = the way to create directories.  CLEANDIR = the command to clean the tempDir (if chosen as optional) The install creation of DIR has the following structure  for directory dir: if [ ! -d dir ]; then mkdir dir; fi;  
 * @return The script for creating the directories.
 */
@Override protected String osInstallScriptCreateDir(){
  StringBuilder res=new StringBuilder(""String_Node_Str"");
  res.append(""String_Node_Str"");
  res.append(""String_Node_Str"");
  res.append(""String_Node_Str"");
  res.append(machineUserLogin());
  res.append(""String_Node_Str"");
  res.append(getInstallDirPath());
  res.append(""String_Node_Str"");
  String dir;
  dir=settings.getLeafValue(Constants.SETTINGS_ARCHIVE_BP_BASEDIR_LEAF);
  if (dir != null && !dir.equalsIgnoreCase(""String_Node_Str"") && !dir.equalsIgnoreCase(""String_Node_Str"")) {
    res.append(scriptCreateDir(dir,false));
  }
  dir=settings.getLeafValue(Constants.SETTINGS_ARCHIVE_ARC_BASEDIR_LEAF);
  if (dir != null && !dir.equalsIgnoreCase(""String_Node_Str"") && !dir.equalsIgnoreCase(""String_Node_Str"")) {
    res.append(scriptCreateDir(dir,false));
  }
  res.append(getAppDirectories());
  dir=settings.getLeafValue(Constants.SETTINGS_TEMP_DIR_LEAF);
  if (dir != null && !dir.equalsIgnoreCase(""String_Node_Str"") && !dir.equalsIgnoreCase(""String_Node_Str"")) {
    res.append(scriptCreateDir(dir,resetTempDir));
  }
  res.append(""String_Node_Str"");
  return res.toString();
}","/** 
 * Creates the specified directories in the it-config. Structure - ssh login cd path; DIRS; CLEANDIR; exit; where: login = username@machine. path = path to install directory. DIRS = the way to create directories.  CLEANDIR = the command to clean the tempDir (if chosen as optional) The install creation of DIR has the following structure  for directory dir: if [ ! -d dir ]; then mkdir dir; fi;  
 * @return The script for creating the directories.
 */
@Override protected String osInstallScriptCreateDir(){
  StringBuilder res=new StringBuilder(""String_Node_Str"");
  res.append(""String_Node_Str"");
  res.append(""String_Node_Str"");
  res.append(""String_Node_Str"");
  res.append(machineUserLogin());
  res.append(""String_Node_Str"");
  res.append(getInstallDirPath());
  res.append(""String_Node_Str"");
  String dir;
  dir=settings.getLeafValue(Constants.SETTINGS_ARCHIVE_BP_BASEDIR_LEAF);
  if (dir != null && !dir.equalsIgnoreCase(""String_Node_Str"") && !dir.equalsIgnoreCase(""String_Node_Str"")) {
    res.append(scriptCreateDir(dir,false));
  }
  dir=settings.getLeafValue(Constants.SETTINGS_ARCHIVE_ARC_BASEDIR_LEAF);
  if (dir != null && !dir.equalsIgnoreCase(""String_Node_Str"") && !dir.equalsIgnoreCase(""String_Node_Str"")) {
    res.append(scriptCreateDir(dir,false));
  }
  res.append(getAppDirectories());
  dir=settings.getLeafValue(Constants.SETTINGS_TEMPDIR_LEAF);
  if (dir != null && !dir.equalsIgnoreCase(""String_Node_Str"") && !dir.equalsIgnoreCase(""String_Node_Str"")) {
    res.append(scriptCreateDir(dir,resetTempDir));
  }
  res.append(""String_Node_Str"");
  return res.toString();
}",0.999687597625742
90079,"/** 
 * For retrieving the environment name variable.
 * @return The environment name.
 */
protected String getEnvironmentName(){
  return settings.getSubChildValue(Constants.ENVIRONMENT_NAME_SETTING_PATH_LEAF);
}","/** 
 * For retrieving the environment name variable.
 * @return The environment name.
 */
protected String getEnvironmentName(){
  return settings.getSubChildValue(Constants.SETTINGS_ENVIRONMENT_NAME_LEAF);
}",0.9478672985781992
90080,"/** 
 * Creates the jmxremote.password file, based on the settings.
 * @param directory The local directory for this machine 
 */
protected void createJmxRemotePasswordFile(File directory){
  ArgumentNotValid.checkNotNull(directory,""String_Node_Str"");
  File jmxFile=new File(directory,Constants.JMX_FILE_NAME);
  try {
    PrintWriter jw=new PrintWriter(jmxFile);
    try {
      jw.println(""String_Node_Str"" + ""String_Node_Str"");
      jw.println(""String_Node_Str"");
      jw.println(""String_Node_Str"" + ""String_Node_Str"");
      jw.println(""String_Node_Str"");
      jw.println(""String_Node_Str"" + ""String_Node_Str"");
      jw.println(""String_Node_Str"" + ""String_Node_Str"");
      jw.println(""String_Node_Str"" + ""String_Node_Str"");
      jw.println(""String_Node_Str"" + ""String_Node_Str"");
      jw.println(""String_Node_Str"");
      jw.println(""String_Node_Str"");
      jw.println(""String_Node_Str"" + ""String_Node_Str"");
      jw.println(""String_Node_Str"" + ""String_Node_Str"");
      jw.println(""String_Node_Str"" + ""String_Node_Str"");
      jw.println(""String_Node_Str"" + ""String_Node_Str"");
      jw.println();
      jw.println();
      jw.println(""String_Node_Str"" + ""String_Node_Str"");
      jw.println(""String_Node_Str"" + ""String_Node_Str"");
      jw.println(""String_Node_Str"" + ""String_Node_Str"");
      jw.println(""String_Node_Str"" + ""String_Node_Str"");
      jw.println(""String_Node_Str"" + ""String_Node_Str"");
      jw.println(""String_Node_Str"" + ""String_Node_Str"");
      jw.println(""String_Node_Str"");
      jw.println(""String_Node_Str"" + ""String_Node_Str"");
      jw.println(""String_Node_Str"" + ""String_Node_Str"");
      jw.println(""String_Node_Str"");
      jw.println(""String_Node_Str"" + ""String_Node_Str"");
      jw.println(""String_Node_Str"");
      jw.println(""String_Node_Str"");
      jw.println(""String_Node_Str"");
      jw.println(""String_Node_Str"" + ""String_Node_Str"");
      jw.println(""String_Node_Str"" + ""String_Node_Str"");
      jw.println(""String_Node_Str"" + ""String_Node_Str"");
      jw.println(""String_Node_Str"" + ""String_Node_Str"");
      jw.println(""String_Node_Str"" + ""String_Node_Str"");
      jw.println(""String_Node_Str"");
      jw.println(""String_Node_Str"" + ""String_Node_Str"");
      jw.println(""String_Node_Str"");
      jw.println(""String_Node_Str"" + ""String_Node_Str"");
      jw.println(""String_Node_Str"");
      jw.println(""String_Node_Str"");
      jw.println(""String_Node_Str"" + ""String_Node_Str"");
      jw.println(""String_Node_Str"" + ""String_Node_Str"");
      jw.println(""String_Node_Str"" + ""String_Node_Str"");
      jw.println(""String_Node_Str"" + ""String_Node_Str"");
      jw.println(""String_Node_Str"");
      jw.println(""String_Node_Str"");
      StringBuilder monitor=new StringBuilder(""String_Node_Str"");
      monitor.append(settings.getSubChildValue(Constants.JMX_PASSWORD_MONITOR_BRANCH,Constants.JMX_PASSWORD_NAME_BRANCH));
      monitor.append(""String_Node_Str"");
      monitor.append(settings.getSubChildValue(Constants.JMX_PASSWORD_MONITOR_BRANCH,Constants.JMX_PASSWORD_PASSWORD_BRANCH));
      jw.print(monitor.toString());
    }
  finally {
      jw.close();
    }
  }
 catch (  IOException e) {
    log.trace(""String_Node_Str"");
    throw new IOFailure(""String_Node_Str"" + e);
  }
catch (  Exception e) {
    log.trace(""String_Node_Str"" + e);
    System.out.println(""String_Node_Str"" + e);
  }
}","/** 
 * Creates the jmxremote.password file, based on the settings.
 * @param directory The local directory for this machine 
 */
protected void createJmxRemotePasswordFile(File directory){
  ArgumentNotValid.checkNotNull(directory,""String_Node_Str"");
  File jmxFile=new File(directory,Constants.JMX_FILE_NAME);
  try {
    PrintWriter jw=new PrintWriter(jmxFile);
    try {
      jw.println(""String_Node_Str"" + ""String_Node_Str"");
      jw.println(""String_Node_Str"");
      jw.println(""String_Node_Str"" + ""String_Node_Str"");
      jw.println(""String_Node_Str"");
      jw.println(""String_Node_Str"" + ""String_Node_Str"");
      jw.println(""String_Node_Str"" + ""String_Node_Str"");
      jw.println(""String_Node_Str"" + ""String_Node_Str"");
      jw.println(""String_Node_Str"" + ""String_Node_Str"");
      jw.println(""String_Node_Str"");
      jw.println(""String_Node_Str"");
      jw.println(""String_Node_Str"" + ""String_Node_Str"");
      jw.println(""String_Node_Str"" + ""String_Node_Str"");
      jw.println(""String_Node_Str"" + ""String_Node_Str"");
      jw.println(""String_Node_Str"" + ""String_Node_Str"");
      jw.println();
      jw.println();
      jw.println(""String_Node_Str"" + ""String_Node_Str"");
      jw.println(""String_Node_Str"" + ""String_Node_Str"");
      jw.println(""String_Node_Str"" + ""String_Node_Str"");
      jw.println(""String_Node_Str"" + ""String_Node_Str"");
      jw.println(""String_Node_Str"" + ""String_Node_Str"");
      jw.println(""String_Node_Str"" + ""String_Node_Str"");
      jw.println(""String_Node_Str"");
      jw.println(""String_Node_Str"" + ""String_Node_Str"");
      jw.println(""String_Node_Str"" + ""String_Node_Str"");
      jw.println(""String_Node_Str"");
      jw.println(""String_Node_Str"" + ""String_Node_Str"");
      jw.println(""String_Node_Str"");
      jw.println(""String_Node_Str"");
      jw.println(""String_Node_Str"");
      jw.println(""String_Node_Str"" + ""String_Node_Str"");
      jw.println(""String_Node_Str"" + ""String_Node_Str"");
      jw.println(""String_Node_Str"" + ""String_Node_Str"");
      jw.println(""String_Node_Str"" + ""String_Node_Str"");
      jw.println(""String_Node_Str"" + ""String_Node_Str"");
      jw.println(""String_Node_Str"");
      jw.println(""String_Node_Str"" + ""String_Node_Str"");
      jw.println(""String_Node_Str"");
      jw.println(""String_Node_Str"" + ""String_Node_Str"");
      jw.println(""String_Node_Str"");
      jw.println(""String_Node_Str"");
      jw.println(""String_Node_Str"" + ""String_Node_Str"");
      jw.println(""String_Node_Str"" + ""String_Node_Str"");
      jw.println(""String_Node_Str"" + ""String_Node_Str"");
      jw.println(""String_Node_Str"" + ""String_Node_Str"");
      jw.println(""String_Node_Str"");
      jw.println(""String_Node_Str"");
      StringBuilder monitor=new StringBuilder(""String_Node_Str"");
      monitor.append(settings.getSubChildValue(Constants.SETTINGS_JMX_NAME_LEAF));
      monitor.append(""String_Node_Str"");
      monitor.append(settings.getSubChildValue(Constants.SETTINGS_JMX_PASSWORD_LEAF));
      jw.print(monitor.toString());
    }
  finally {
      jw.close();
    }
  }
 catch (  IOException e) {
    log.trace(""String_Node_Str"");
    throw new IOFailure(""String_Node_Str"" + e);
  }
catch (  Exception e) {
    log.trace(""String_Node_Str"" + e);
    System.out.println(""String_Node_Str"" + e);
  }
}",0.9467634603750756
90081,"/** 
 * A machine is referring to an actual computer at a physical location,  which can have independent applications from the other machines at the  same location.
 * @param e The root of this instance in the XML document.
 * @param parentSettings The setting inherited by the parent.
 * @param param The machine parameters inherited by the parent.
 * @param netarchiveSuiteSource The name of the NetarchiveSuite package file.
 * @param logProp The logging property file.
 * @param securityPolicy The security policy file.
 * @param dbFileName The name of the database file.
 * @param resetDir Whether the temporary directory should be reset.
 */
public Machine(Element e,XmlStructure parentSettings,Parameters param,String netarchiveSuiteSource,File logProp,File securityPolicy,File dbFileName,boolean resetDir){
  ArgumentNotValid.checkNotNull(e,""String_Node_Str"");
  ArgumentNotValid.checkNotNull(parentSettings,""String_Node_Str"");
  ArgumentNotValid.checkNotNull(param,""String_Node_Str"");
  ArgumentNotValid.checkNotNull(netarchiveSuiteSource,""String_Node_Str"");
  ArgumentNotValid.checkNotNull(logProp,""String_Node_Str"");
  ArgumentNotValid.checkNotNull(securityPolicy,""String_Node_Str"");
  ArgumentNotValid.checkNotNull(resetDir,""String_Node_Str"");
  settings=new XmlStructure(parentSettings.getRoot());
  machineRoot=e;
  machineParameters=new Parameters(param);
  netarchiveSuiteFileName=netarchiveSuiteSource;
  inheritedLogPropFile=logProp;
  inheritedSecurityPolicyFile=securityPolicy;
  databaseFile=dbFileName;
  resetTempDir=resetDir;
  Element tmpSet=machineRoot.element(Constants.SETTINGS_BRANCH);
  if (tmpSet != null) {
    settings.overWrite(tmpSet);
  }
  machineParameters.newParameters(machineRoot);
  extractVariables();
  extractApplications();
}","/** 
 * A machine is referring to an actual computer at a physical location,  which can have independent applications from the other machines at the  same location.
 * @param e The root of this instance in the XML document.
 * @param parentSettings The setting inherited by the parent.
 * @param param The machine parameters inherited by the parent.
 * @param netarchiveSuiteSource The name of the NetarchiveSuite package file.
 * @param logProp The logging property file.
 * @param securityPolicy The security policy file.
 * @param dbFileName The name of the database file.
 * @param resetDir Whether the temporary directory should be reset.
 */
public Machine(Element e,XmlStructure parentSettings,Parameters param,String netarchiveSuiteSource,File logProp,File securityPolicy,File dbFileName,boolean resetDir){
  ArgumentNotValid.checkNotNull(e,""String_Node_Str"");
  ArgumentNotValid.checkNotNull(parentSettings,""String_Node_Str"");
  ArgumentNotValid.checkNotNull(param,""String_Node_Str"");
  ArgumentNotValid.checkNotNull(netarchiveSuiteSource,""String_Node_Str"");
  ArgumentNotValid.checkNotNull(logProp,""String_Node_Str"");
  ArgumentNotValid.checkNotNull(securityPolicy,""String_Node_Str"");
  ArgumentNotValid.checkNotNull(resetDir,""String_Node_Str"");
  settings=new XmlStructure(parentSettings.getRoot());
  machineRoot=e;
  machineParameters=new Parameters(param);
  netarchiveSuiteFileName=netarchiveSuiteSource;
  inheritedLogPropFile=logProp;
  inheritedSecurityPolicyFile=securityPolicy;
  databaseFile=dbFileName;
  resetTempDir=resetDir;
  Element tmpSet=machineRoot.element(Constants.COMPLETE_SETTINGS_BRANCH);
  if (tmpSet != null) {
    settings.overWrite(tmpSet);
  }
  machineParameters.newParameters(machineRoot);
  extractVariables();
  extractApplications();
}",0.9974655026753028
90082,"/** 
 * Copy inherited securityPolicyFile to local directory.
 * @param directory The local directory for this machine
 */
protected void createSecurityPolicyFile(File directory){
  ArgumentNotValid.checkNotNull(directory,""String_Node_Str"");
  try {
    File secPolFile=new File(directory,""String_Node_Str"");
    FileWriter secfw=new FileWriter(secPolFile);
    String prop=FileUtils.readFile(inheritedSecurityPolicyFile);
    String monitorRole=settings.getLeafValue(Constants.JMX_PASSWORD_MONITOR_BRANCH,Constants.JMX_PASSWORD_NAME_BRANCH);
    if (monitorRole != null) {
      prop=prop.replace(Constants.SECURITY_JMX_PRINCIPAL_NAME_TAG,monitorRole);
    }
    String ctd=settings.getLeafValue(Constants.SETTINGS_TEMP_DIR_LEAF);
    if (monitorRole != null && ctd != null) {
      prop=prop.replace(Constants.SECURITY_COMMON_TEMP_DIR_TAG,ctd);
    }
    secfw.write(prop);
    List<String> dirs=new ArrayList<String>();
    for (    Application app : applications) {
      String[] tmpDirs=app.getSettingsValues(Constants.SETTINGS_FILE_DIR_LEAF);
      if (tmpDirs != null && tmpDirs.length > 0) {
        for (        String st : tmpDirs) {
          dirs.add(st);
        }
      }
    }
    if (dirs.size() > 0) {
      secfw.write(""String_Node_Str"" + ""String_Node_Str"");
      for (      String dir : dirs) {
        secfw.write(""String_Node_Str"");
        secfw.write(changeFileDirPathForSecurity(dir));
        secfw.write(""String_Node_Str"");
        secfw.write(""String_Node_Str"" + ""String_Node_Str"");
      }
      secfw.write(""String_Node_Str"");
    }
    secfw.close();
  }
 catch (  IOException e) {
    log.warn(""String_Node_Str"" + e);
  }
}","/** 
 * Copy inherited securityPolicyFile to local directory.
 * @param directory The local directory for this machine
 */
protected void createSecurityPolicyFile(File directory){
  ArgumentNotValid.checkNotNull(directory,""String_Node_Str"");
  try {
    File secPolFile=new File(directory,""String_Node_Str"");
    FileWriter secfw=new FileWriter(secPolFile);
    String prop=FileUtils.readFile(inheritedSecurityPolicyFile);
    String monitorRole=settings.getLeafValue(Constants.SETTINGS_JMX_PASSWORD_LEAF);
    if (monitorRole != null) {
      prop=prop.replace(Constants.SECURITY_JMX_PRINCIPAL_NAME_TAG,monitorRole);
    }
    String ctd=settings.getLeafValue(Constants.SETTINGS_TEMPDIR_LEAF);
    if (ctd != null) {
      prop=prop.replace(Constants.SECURITY_COMMON_TEMP_DIR_TAG,ctd);
    }
    secfw.write(prop);
    List<String> dirs=new ArrayList<String>();
    for (    Application app : applications) {
      String[] tmpDirs=app.getSettingsValues(Constants.SETTINGS_BITARCHIVE_FILEDIR_LEAF);
      if (tmpDirs != null && tmpDirs.length > 0) {
        for (        String st : tmpDirs) {
          dirs.add(st);
        }
      }
    }
    if (dirs.size() > 0) {
      secfw.write(""String_Node_Str"" + ""String_Node_Str"");
      for (      String dir : dirs) {
        secfw.write(""String_Node_Str"");
        secfw.write(changeFileDirPathForSecurity(dir));
        secfw.write(""String_Node_Str"");
        secfw.write(""String_Node_Str"" + ""String_Node_Str"");
      }
      secfw.write(""String_Node_Str"");
    }
    secfw.close();
  }
 catch (  IOException e) {
    log.warn(""String_Node_Str"" + e);
  }
}",0.970570202329859
90083,"/** 
 * Extracts the XML for the applications from the root,  creates the applications and puts them into the list.
 */
@SuppressWarnings(""String_Node_Str"") private void extractApplications(){
  applications=new ArrayList<Application>();
  List<Element> le=machineRoot.elements(Constants.APPLICATION_BRANCH);
  for (  Element e : le) {
    applications.add(new Application(e,settings,machineParameters));
  }
}","/** 
 * Extracts the XML for the applications from the root,  creates the applications and puts them into the list.
 */
@SuppressWarnings(""String_Node_Str"") private void extractApplications(){
  applications=new ArrayList<Application>();
  List<Element> le=machineRoot.elements(Constants.DEPLOY_APPLICATION_NAME);
  for (  Element e : le) {
    applications.add(new Application(e,settings,machineParameters));
  }
}",0.9818181818181818
90084,"/** 
 * Overwrites the inherited parameters, if the root has new specified.
 * @param root The root of the current instance.
 */
@SuppressWarnings(""String_Node_Str"") public void newParameters(Element root){
  ArgumentNotValid.checkNotNull(root,""String_Node_Str"");
  List<Element> tmp;
  tmp=root.elements(Constants.CLASS_PATH_BRANCH);
  if (tmp.size() > 0) {
    classPaths=tmp;
  }
  tmp=root.elements(Constants.JAVA_OPTIONS_BRANCH);
  if (tmp.size() > 0) {
    javaOptions=tmp;
  }
  tmp=root.elements(Constants.PARAMETER_INSTALL_DIR_BRANCH);
  if (tmp.size() > 0) {
    installDir=tmp.get(0);
  }
  tmp=root.elements(Constants.PARAMETER_MACHINE_USER_NAME_BRANCH);
  if (tmp.size() > 0) {
    machineUserName=tmp.get(0);
  }
  tmp=root.elements(Constants.PARAMETER_DATABASE_DIR_BRANCH);
  if (tmp.size() > 0) {
    databaseDir=tmp.get(0);
  }
}","/** 
 * Overwrites the inherited parameters, if the root has new specified.
 * @param root The root of the current instance.
 */
@SuppressWarnings(""String_Node_Str"") public void newParameters(Element root){
  ArgumentNotValid.checkNotNull(root,""String_Node_Str"");
  List<Element> tmp;
  tmp=root.elements(Constants.DEPLOY_CLASS_PATH);
  if (tmp.size() > 0) {
    classPaths=tmp;
  }
  tmp=root.elements(Constants.DEPLOY_JAVA_OPTIONS);
  if (tmp.size() > 0) {
    javaOptions=tmp;
  }
  tmp=root.elements(Constants.DEPLOY_INSTALL_DIR);
  if (tmp.size() > 0) {
    installDir=tmp.get(0);
  }
  tmp=root.elements(Constants.DEPLOY_MACHINE_USER_NAME);
  if (tmp.size() > 0) {
    machineUserName=tmp.get(0);
  }
  tmp=root.elements(Constants.DEPLOY_DATABASE_DIR);
  if (tmp.size() > 0) {
    databaseDir=tmp.get(0);
  }
}",0.6498194945848376
90085,"/** 
 * Extract the local variables from the root. It is only the name for this instance.
 */
private void extractVariables(){
  Attribute at=physLocRoot.attribute(Constants.PHYSICAL_LOCATION_NAME_ATTRIBUTES);
  if (at != null) {
    name=at.getText();
  }
 else {
    log.debug(""String_Node_Str"");
    name=""String_Node_Str"";
  }
}","/** 
 * Extract the local variables from the root. It is only the name for this instance. This is then set in settings.
 */
private void extractVariables(){
  Attribute at=physLocRoot.attribute(Constants.PHYSICAL_LOCATION_NAME_ATTRIBUTES);
  if (at != null) {
    name=at.getText();
    String xmlName=XmlStructure.pathAndContentToXML(name,Constants.COMPLETE_THIS_PHYSICAL_LOCATION_LEAF);
    Element physLocName=XmlStructure.makeElementFromString(xmlName);
    settings.overWrite(physLocName);
  }
 else {
    log.debug(""String_Node_Str"");
    name=""String_Node_Str"";
  }
}",0.7328918322295805
90086,"/** 
 * Extracts the XML for machines from the root, creates the machines, and puts them into the list.
 */
@SuppressWarnings(""String_Node_Str"") private void extractMachines(){
  machines=new ArrayList<Machine>();
  List<Element> le=physLocRoot.elements(Constants.MACHINE_BRANCH);
  for (  Element e : le) {
    String os=e.attributeValue(Constants.MACHINE_OPERATING_SYSTEM_ATTRIBUTE);
    if (os != null && os.equalsIgnoreCase(Constants.OPERATING_SYSTEM_WINDOWS_ATTRIBUTE)) {
      machines.add(new WindowsMachine(e,settings,machineParameters,netarchiveSuiteFileName,logPropFile,securityPolicyFile,databaseFile,resetDirectory));
    }
 else {
      machines.add(new LinuxMachine(e,settings,machineParameters,netarchiveSuiteFileName,logPropFile,securityPolicyFile,databaseFile,resetDirectory));
    }
  }
}","/** 
 * Extracts the XML for machines from the root, creates the machines, and puts them into the list.
 */
@SuppressWarnings(""String_Node_Str"") private void extractMachines(){
  machines=new ArrayList<Machine>();
  List<Element> le=physLocRoot.elements(Constants.DEPLOY_MACHINE);
  for (  Element e : le) {
    String os=e.attributeValue(Constants.MACHINE_OPERATING_SYSTEM_ATTRIBUTE);
    if (os != null && os.equalsIgnoreCase(Constants.OPERATING_SYSTEM_WINDOWS_ATTRIBUTE)) {
      machines.add(new WindowsMachine(e,settings,machineParameters,netarchiveSuiteFileName,logPropFile,securityPolicyFile,databaseFile,resetDirectory));
    }
 else {
      machines.add(new LinuxMachine(e,settings,machineParameters,netarchiveSuiteFileName,logPropFile,securityPolicyFile,databaseFile,resetDirectory));
    }
  }
}",0.9913151364764268
90087,"/** 
 * The physical locations is referring to the position in the real world where the computers are located. One physical location can contain many machines.
 * @param elem The root of this branch in the XML structure.
 * @param parentSettings The settings of the parent (it-config).
 * @param param The parameters of the parent (it-config).
 * @param netarchiveSuiteSource The name of the NetarchiveSuite file.
 * @param logProp The logging property file.
 * @param securityPolicy The security policy file.
 * @param dbFile The name of the database.
 * @param resetDir Whether the temporary directory should be reset.
 */
public PhysicalLocation(Element elem,XmlStructure parentSettings,Parameters param,String netarchiveSuiteSource,File logProp,File securityPolicy,File dbFile,boolean resetDir){
  ArgumentNotValid.checkNotNull(elem,""String_Node_Str"");
  ArgumentNotValid.checkNotNull(parentSettings,""String_Node_Str"");
  ArgumentNotValid.checkNotNull(param,""String_Node_Str"");
  ArgumentNotValid.checkNotNullOrEmpty(netarchiveSuiteSource,""String_Node_Str"");
  ArgumentNotValid.checkNotNull(logProp,""String_Node_Str"");
  ArgumentNotValid.checkNotNull(securityPolicy,""String_Node_Str"");
  ArgumentNotValid.checkNotNull(resetDir,""String_Node_Str"");
  settings=new XmlStructure(parentSettings.getRoot());
  physLocRoot=elem;
  machineParameters=new Parameters(param);
  netarchiveSuiteFileName=netarchiveSuiteSource;
  logPropFile=logProp;
  securityPolicyFile=securityPolicy;
  databaseFile=dbFile;
  resetDirectory=resetDir;
  Element tmpSet=physLocRoot.element(Constants.SETTINGS_BRANCH);
  if (tmpSet != null) {
    settings.overWrite(tmpSet);
  }
  machineParameters.newParameters(physLocRoot);
  extractVariables();
  extractMachines();
}","/** 
 * The physical locations is referring to the position in the real world where the computers are located. One physical location can contain many machines.
 * @param elem The root of this branch in the XML structure.
 * @param parentSettings The settings of the parent (it-config).
 * @param param The parameters of the parent (it-config).
 * @param netarchiveSuiteSource The name of the NetarchiveSuite file.
 * @param logProp The logging property file.
 * @param securityPolicy The security policy file.
 * @param dbFile The name of the database.
 * @param resetDir Whether the temporary directory should be reset.
 */
public PhysicalLocation(Element elem,XmlStructure parentSettings,Parameters param,String netarchiveSuiteSource,File logProp,File securityPolicy,File dbFile,boolean resetDir){
  ArgumentNotValid.checkNotNull(elem,""String_Node_Str"");
  ArgumentNotValid.checkNotNull(parentSettings,""String_Node_Str"");
  ArgumentNotValid.checkNotNull(param,""String_Node_Str"");
  ArgumentNotValid.checkNotNullOrEmpty(netarchiveSuiteSource,""String_Node_Str"");
  ArgumentNotValid.checkNotNull(logProp,""String_Node_Str"");
  ArgumentNotValid.checkNotNull(securityPolicy,""String_Node_Str"");
  ArgumentNotValid.checkNotNull(resetDir,""String_Node_Str"");
  settings=new XmlStructure(parentSettings.getRoot());
  physLocRoot=elem;
  machineParameters=new Parameters(param);
  netarchiveSuiteFileName=netarchiveSuiteSource;
  logPropFile=logProp;
  securityPolicyFile=securityPolicy;
  databaseFile=dbFile;
  resetDirectory=resetDir;
  Element tmpSet=physLocRoot.element(Constants.COMPLETE_SETTINGS_BRANCH);
  if (tmpSet != null) {
    settings.overWrite(tmpSet);
  }
  machineParameters.newParameters(physLocRoot);
  extractVariables();
  extractMachines();
}",0.9974278365247212
90088,"/** 
 * Creates the operation system specific installation script for  this machine.
 * @return Operation system specific part of the installscript
 */
@Override protected String osInstallScript(){
  StringBuilder res=new StringBuilder(""String_Node_Str"");
  res.append(""String_Node_Str"");
  res.append(netarchiveSuiteFileName);
  res.append(""String_Node_Str"");
  res.append(name);
  res.append(""String_Node_Str"");
  res.append(""String_Node_Str"");
  res.append(netarchiveSuiteFileName);
  res.append(""String_Node_Str"");
  res.append(machineUserLogin());
  res.append(""String_Node_Str"");
  res.append(machineParameters.getInstallDirValue());
  res.append(""String_Node_Str"");
  res.append(""String_Node_Str"");
  res.append(netarchiveSuiteFileName);
  res.append(""String_Node_Str"");
  res.append(name);
  res.append(""String_Node_Str"");
  res.append(""String_Node_Str"");
  res.append(machineUserLogin());
  res.append(""String_Node_Str"");
  res.append(machineParameters.getInstallDirValue());
  res.append(""String_Node_Str"");
  res.append(netarchiveSuiteFileName);
  res.append(""String_Node_Str"");
  res.append(getInstallDirPath());
  res.append(""String_Node_Str"");
  res.append(osInstallScriptCreateDir());
  res.append(""String_Node_Str"");
  res.append(""String_Node_Str"");
  res.append(""String_Node_Str"");
  res.append(name);
  res.append(""String_Node_Str"");
  res.append(machineUserLogin());
  res.append(""String_Node_Str"");
  res.append(getConfDirPath());
  res.append(""String_Node_Str"");
  res.append(osInstallDatabase());
  res.append(""String_Node_Str"");
  res.append(""String_Node_Str"");
  res.append(""String_Node_Str"");
  res.append(machineUserLogin());
  res.append(""String_Node_Str"");
  res.append(getConfDirPath());
  res.append(""String_Node_Str"");
  res.append(""String_Node_Str"");
  res.append(""String_Node_Str"");
  res.append(""String_Node_Str"");
  res.append(""String_Node_Str"");
  res.append(machineUserLogin());
  res.append(""String_Node_Str"");
  res.append(getConfDirPath());
  res.append(""String_Node_Str"");
  res.append(""String_Node_Str"");
  return res.toString();
}","/** 
 * Creates the operation system specific installation script for  this machine.
 * @return Operation system specific part of the installscript
 */
@Override protected String osInstallScript(){
  StringBuilder res=new StringBuilder(""String_Node_Str"");
  res.append(""String_Node_Str"");
  res.append(netarchiveSuiteFileName);
  res.append(""String_Node_Str"");
  res.append(name);
  res.append(""String_Node_Str"");
  res.append(""String_Node_Str"");
  res.append(netarchiveSuiteFileName);
  res.append(""String_Node_Str"");
  res.append(machineUserLogin());
  res.append(""String_Node_Str"");
  res.append(machineParameters.getInstallDirValue());
  res.append(""String_Node_Str"");
  res.append(""String_Node_Str"");
  res.append(netarchiveSuiteFileName);
  res.append(""String_Node_Str"");
  res.append(name);
  res.append(""String_Node_Str"");
  res.append(""String_Node_Str"");
  res.append(machineUserLogin());
  res.append(""String_Node_Str"");
  res.append(machineParameters.getInstallDirValue());
  res.append(""String_Node_Str"");
  res.append(netarchiveSuiteFileName);
  res.append(""String_Node_Str"");
  res.append(getInstallDirPath());
  res.append(""String_Node_Str"");
  res.append(osInstallScriptCreateDir());
  res.append(""String_Node_Str"");
  res.append(""String_Node_Str"");
  res.append(""String_Node_Str"");
  res.append(machineUserLogin());
  res.append(""String_Node_Str"");
  res.append(getConfDirPath());
  res.append(""String_Node_Str"");
  res.append(""String_Node_Str"");
  res.append(getConfDirPath());
  res.append(""String_Node_Str"");
  res.append(""String_Node_Str"");
  res.append(""String_Node_Str"");
  res.append(""String_Node_Str"");
  res.append(""String_Node_Str"");
  res.append(name);
  res.append(""String_Node_Str"");
  res.append(machineUserLogin());
  res.append(""String_Node_Str"");
  res.append(getConfDirPath());
  res.append(""String_Node_Str"");
  res.append(osInstallDatabase());
  res.append(""String_Node_Str"");
  res.append(""String_Node_Str"");
  res.append(""String_Node_Str"");
  res.append(machineUserLogin());
  res.append(""String_Node_Str"");
  res.append(getConfDirPath());
  res.append(""String_Node_Str"");
  res.append(""String_Node_Str"");
  res.append(""String_Node_Str"");
  res.append(""String_Node_Str"");
  res.append(""String_Node_Str"");
  res.append(machineUserLogin());
  res.append(""String_Node_Str"");
  res.append(getConfDirPath());
  res.append(""String_Node_Str"");
  res.append(""String_Node_Str"");
  return res.toString();
}",0.919698314108252
90089,"/** 
 * Checks if a specific directory for the database is given in the settings, and thus if the database should be installed on this machine. If no specific database is given (databaseFileName = null) then use the  standard database extracted from NetarchiveSuite.zip. Else send the given new database to the standard database location. Extract the database in the standard database location to the specified database directory.
 * @return The script for installing the database (if needed).
 */
@Override protected String osInstallDatabase(){
  StringBuilder res=new StringBuilder();
  String databaseDir=machineParameters.getDatabaseDirValue();
  if (databaseDir == null || databaseDir.equalsIgnoreCase(""String_Node_Str"")) {
    return ""String_Node_Str"";
  }
  if (databaseFile != null) {
    res.append(""String_Node_Str"" + ""String_Node_Str"");
    res.append(""String_Node_Str"");
    res.append(databaseFile.getAbsolutePath());
    res.append(""String_Node_Str"");
    res.append(machineUserLogin());
    res.append(""String_Node_Str"");
    res.append(getInstallDirPath());
    res.append(""String_Node_Str"");
    res.append(Constants.DATABASE_BASE_PATH);
    res.append(""String_Node_Str"");
  }
  res.append(""String_Node_Str"" + ""String_Node_Str"");
  res.append(""String_Node_Str"");
  res.append(machineUserLogin());
  res.append(""String_Node_Str"");
  res.append(getInstallDirPath());
  res.append(""String_Node_Str"");
  res.append(databaseDir);
  res.append(""String_Node_Str"");
  res.append(databaseDir);
  res.append(""String_Node_Str"");
  res.append(databaseDir);
  res.append(""String_Node_Str"");
  res.append(Constants.DATABASE_ERROR_PROMPT_DIR_NOT_EMPTY);
  res.append(""String_Node_Str"");
  res.append(Constants.DATABASE_BASE_PATH);
  res.append(""String_Node_Str"");
  res.append(databaseDir);
  res.append(""String_Node_Str"");
  res.append(""String_Node_Str"");
  return res.toString();
}","/** 
 * Checks if a specific directory for the database is given in the settings, and thus if the database should be installed on this machine. If no specific database is given (databaseFileName = null) then use the  standard database extracted from NetarchiveSuite.zip. Else send the given new database to the standard database location. Extract the database in the standard database location to the specified database directory.
 * @return The script for installing the database (if needed).
 */
@Override protected String osInstallDatabase(){
  StringBuilder res=new StringBuilder();
  String databaseDir=machineParameters.getDatabaseDirValue();
  if (databaseDir == null || databaseDir.equalsIgnoreCase(""String_Node_Str"")) {
    return ""String_Node_Str"";
  }
  if (databaseFile != null) {
    res.append(""String_Node_Str"" + ""String_Node_Str"");
    res.append(""String_Node_Str"");
    res.append(databaseFile.getAbsolutePath());
    res.append(""String_Node_Str"");
    res.append(machineUserLogin());
    res.append(""String_Node_Str"");
    res.append(getInstallDirPath());
    res.append(""String_Node_Str"");
    res.append(Constants.DATABASE_BASE_PATH);
    res.append(""String_Node_Str"");
  }
  res.append(""String_Node_Str"" + ""String_Node_Str"");
  res.append(""String_Node_Str"");
  res.append(machineUserLogin());
  res.append(""String_Node_Str"");
  res.append(getInstallDirPath());
  res.append(""String_Node_Str"");
  res.append(databaseDir);
  res.append(""String_Node_Str"");
  res.append(Constants.DATABASE_ERROR_PROMPT_DIR_NOT_EMPTY);
  res.append(""String_Node_Str"");
  res.append(Constants.DATABASE_BASE_PATH);
  res.append(""String_Node_Str"");
  res.append(databaseDir);
  res.append(""String_Node_Str"");
  res.append(""String_Node_Str"");
  return res.toString();
}",0.9671232876712328
90090,"/** 
 * Function to create the script which installs the new directories. This is only used for windows machines!
 * @param directory The directory to put the file
 */
@Override protected void createInstallDirScript(File directory){
  File dirScript=new File(directory,""String_Node_Str"" + name + scriptExtension);
  try {
    PrintWriter dirPrint=new PrintWriter(dirScript);
    try {
      dirPrint.print(""String_Node_Str"");
      dirPrint.print(getInstallDirPath());
      dirPrint.print(""String_Node_Str"");
      String dir;
      dir=settings.getLeafValue(Constants.SETTINGS_ARCHIVE_BP_BASEDIR_LEAF);
      if (dir != null && !dir.equalsIgnoreCase(""String_Node_Str"") && !dir.equalsIgnoreCase(""String_Node_Str"")) {
        dirPrint.print(scriptCreateDir(dir,false));
      }
      dir=settings.getLeafValue(Constants.SETTINGS_ARCHIVE_ARC_BASEDIR_LEAF);
      if (dir != null && !dir.equalsIgnoreCase(""String_Node_Str"") && !dir.equalsIgnoreCase(""String_Node_Str"")) {
        dirPrint.print(scriptCreateDir(dir,false));
      }
      dirPrint.print(getAppDirectories());
      dir=settings.getLeafValue(Constants.SETTINGS_TEMP_DIR_LEAF);
      if (dir != null && !dir.equalsIgnoreCase(""String_Node_Str"") && !dir.equalsIgnoreCase(""String_Node_Str"")) {
        dirPrint.print(scriptCreateDir(dir,resetTempDir));
      }
    }
  finally {
      dirPrint.close();
    }
  }
 catch (  IOException e) {
    log.trace(""String_Node_Str"" + e);
    throw new IOFailure(""String_Node_Str"" + ""String_Node_Str"" + e);
  }
}","/** 
 * Function to create the script which installs the new directories. This is only used for windows machines!
 * @param directory The directory to put the file
 */
@Override protected void createInstallDirScript(File directory){
  File dirScript=new File(directory,getMakeDirectoryName());
  try {
    PrintWriter dirPrint=new PrintWriter(dirScript);
    try {
      dirPrint.print(""String_Node_Str"");
      dirPrint.print(getInstallDirPath());
      dirPrint.print(""String_Node_Str"");
      String dir;
      dir=settings.getLeafValue(Constants.SETTINGS_ARCHIVE_BP_BASEDIR_LEAF);
      if (dir != null && !dir.equalsIgnoreCase(""String_Node_Str"") && !dir.equalsIgnoreCase(""String_Node_Str"")) {
        dirPrint.print(scriptCreateDir(dir,false));
      }
      dir=settings.getLeafValue(Constants.SETTINGS_ARCHIVE_ARC_BASEDIR_LEAF);
      if (dir != null && !dir.equalsIgnoreCase(""String_Node_Str"") && !dir.equalsIgnoreCase(""String_Node_Str"")) {
        dirPrint.print(scriptCreateDir(dir,false));
      }
      dirPrint.print(getAppDirectories());
      dir=settings.getLeafValue(Constants.SETTINGS_TEMP_DIR_LEAF);
      if (dir != null && !dir.equalsIgnoreCase(""String_Node_Str"") && !dir.equalsIgnoreCase(""String_Node_Str"")) {
        dirPrint.print(scriptCreateDir(dir,resetTempDir));
      }
    }
  finally {
      dirPrint.close();
    }
  }
 catch (  IOException e) {
    log.trace(""String_Node_Str"" + e);
    throw new IOFailure(""String_Node_Str"" + ""String_Node_Str"" + e);
  }
}",0.981320880587058
90091,"/** 
 * Creates the operation system specific installation script for  this machine.
 * @return Operation system specific part of the installscript
 */
@Override protected String osInstallScript(){
  StringBuilder res=new StringBuilder(""String_Node_Str"");
  res.append(""String_Node_Str"");
  res.append(netarchiveSuiteFileName);
  res.append(""String_Node_Str"");
  res.append(name);
  res.append(""String_Node_Str"");
  res.append(""String_Node_Str"");
  res.append(netarchiveSuiteFileName);
  res.append(""String_Node_Str"");
  res.append(machineUserLogin());
  res.append(""String_Node_Str"");
  res.append(""String_Node_Str"");
  res.append(""String_Node_Str"");
  res.append(netarchiveSuiteFileName);
  res.append(""String_Node_Str"");
  res.append(name);
  res.append(""String_Node_Str"");
  res.append(""String_Node_Str"");
  res.append(machineUserLogin());
  res.append(""String_Node_Str"");
  res.append(getEnvironmentName());
  res.append(""String_Node_Str"");
  res.append(netarchiveSuiteFileName);
  res.append(""String_Node_Str"");
  res.append(osInstallScriptCreateDir());
  res.append(""String_Node_Str"");
  res.append(""String_Node_Str"");
  res.append(""String_Node_Str"");
  res.append(name);
  res.append(""String_Node_Str"");
  res.append(machineUserLogin());
  res.append(""String_Node_Str"");
  res.append(changeToScriptPath(getLocalConfDirPath()));
  res.append(""String_Node_Str"");
  res.append(osInstallDatabase());
  res.append(""String_Node_Str"");
  res.append(""String_Node_Str"");
  res.append(""String_Node_Str"");
  res.append(machineUserLogin());
  res.append(""String_Node_Str"");
  res.append(changeToScriptPath(getLocalConfDirPath()));
  res.append(""String_Node_Str"");
  res.append(machineParameters.getMachineUserName().getText());
  res.append(""String_Node_Str"");
  res.append(""String_Node_Str"");
  return res.toString();
}","/** 
 * Creates the operation system specific installation script for  this machine.
 * @return Operation system specific part of the installscript
 */
@Override protected String osInstallScript(){
  StringBuilder res=new StringBuilder(""String_Node_Str"");
  res.append(""String_Node_Str"");
  res.append(netarchiveSuiteFileName);
  res.append(""String_Node_Str"");
  res.append(name);
  res.append(""String_Node_Str"");
  res.append(""String_Node_Str"");
  res.append(netarchiveSuiteFileName);
  res.append(""String_Node_Str"");
  res.append(machineUserLogin());
  res.append(""String_Node_Str"");
  res.append(""String_Node_Str"");
  res.append(""String_Node_Str"");
  res.append(netarchiveSuiteFileName);
  res.append(""String_Node_Str"");
  res.append(name);
  res.append(""String_Node_Str"");
  res.append(""String_Node_Str"");
  res.append(machineUserLogin());
  res.append(""String_Node_Str"");
  res.append(getEnvironmentName());
  res.append(""String_Node_Str"");
  res.append(netarchiveSuiteFileName);
  res.append(""String_Node_Str"");
  res.append(osInstallScriptCreateDir());
  res.append(""String_Node_Str"");
  res.append(""String_Node_Str"");
  res.append(""String_Node_Str"");
  res.append(machineUserLogin());
  res.append(""String_Node_Str"");
  res.append(changeToScriptPath(getLocalConfDirPath()));
  res.append(""String_Node_Str"");
  res.append(""String_Node_Str"");
  res.append(""String_Node_Str"");
  res.append(""String_Node_Str"");
  res.append(machineUserLogin());
  res.append(""String_Node_Str"");
  res.append(changeToScriptPath(getLocalConfDirPath()));
  res.append(""String_Node_Str"");
  res.append(machineParameters.getMachineUserName().getText());
  res.append(""String_Node_Str"");
  res.append(""String_Node_Str"");
  res.append(""String_Node_Str"");
  res.append(""String_Node_Str"");
  res.append(""String_Node_Str"");
  res.append(""String_Node_Str"");
  res.append(name);
  res.append(""String_Node_Str"");
  res.append(machineUserLogin());
  res.append(""String_Node_Str"");
  res.append(changeToScriptPath(getLocalConfDirPath()));
  res.append(""String_Node_Str"");
  res.append(osInstallDatabase());
  res.append(""String_Node_Str"");
  res.append(""String_Node_Str"");
  res.append(""String_Node_Str"");
  res.append(machineUserLogin());
  res.append(""String_Node_Str"");
  res.append(changeToScriptPath(getLocalConfDirPath()));
  res.append(""String_Node_Str"");
  res.append(machineParameters.getMachineUserName().getText());
  res.append(""String_Node_Str"");
  res.append(""String_Node_Str"");
  return res.toString();
}",0.8432783840260042
90092,"/** 
 * Find Job status to be shown based on parameters, including possibility for All statuses
 * @param dfltRequest contains defaulted parameters
 * @return Integer value being the ordinal of a JobStatus or -1 for ALL (job statuses)
 * @throws ArgumentNotValid , IllegalArgumentException
 */
public static Set<Integer> getSelectedJobStatusCodes(DefaultedRequest dfltRequest){
  ArgumentNotValid.checkNotNull(dfltRequest,""String_Node_Str"");
  String[] values=dfltRequest.getParameter(Constants.JOBSTATUS_PARAM);
  if (values == null || values.length == 0) {
    throw new ArgumentNotValid(""String_Node_Str"");
  }
  Set<Integer> selectedJobStatusCodesSet=new HashSet<Integer>();
  for (  String value : values) {
    if (value.equals(JOBSTATUS_ALL)) {
      selectedJobStatusCodesSet=new HashSet<Integer>(JobStatus.ALL_STATUS_CODE);
      break;
    }
 else {
      selectedJobStatusCodesSet.add(JobStatus.valueOf(value).ordinal());
    }
  }
  return selectedJobStatusCodesSet;
}","/** 
 * Find Job status to be shown based on parameters, including possibility for All statuses
 * @param dfltRequest contains defaulted parameters
 * @return Integer value being the ordinal of a JobStatus or -1 for ALL (job statuses)
 * @throws ArgumentNotValid , IllegalArgumentException
 */
public static Set<Integer> getSelectedJobStatusCodes(DefaultedRequest dfltRequest){
  ArgumentNotValid.checkNotNull(dfltRequest,""String_Node_Str"");
  String[] values=dfltRequest.getParameter(Constants.JOBSTATUS_PARAM);
  if (values == null || values.length == 0) {
    throw new ArgumentNotValid(""String_Node_Str"");
  }
  Set<Integer> selectedJobStatusCodesSet=new HashSet<Integer>();
  for (  String value : values) {
    if (value.equals(JOBSTATUS_ALL)) {
      selectedJobStatusCodesSet=new HashSet<Integer>();
      selectedJobStatusCodesSet.add(JobStatus.ALL_STATUS_CODE);
      break;
    }
 else {
      selectedJobStatusCodesSet.add(JobStatus.valueOf(value).ordinal());
    }
  }
  return selectedJobStatusCodesSet;
}",0.9804902451225612
90093,"/** 
 * Function to apply the variables.
 * @param offset The input offset value (1-9 below httpPort).
 * @param httpPort The new value for the HTTP port.
 * @param environmentName The new value for the environment name.
 * @param mailReceiver The new value for the mailReceiver.
 */
public void applyTestArguments(String offset,String httpPort,String environmentName,String mailReceiver){
  ArgumentNotValid.checkNotNullOrEmpty(offset,""String_Node_Str"");
  ArgumentNotValid.checkNotNullOrEmpty(httpPort,""String_Node_Str"");
  ArgumentNotValid.checkNotNullOrEmpty(environmentName,""String_Node_Str"");
  ArgumentNotValid.checkNotNullOrEmpty(mailReceiver,""String_Node_Str"");
  int offsetInt=(new Integer(httpPort)).intValue() - (new Integer(offset)).intValue();
  if (offsetInt > 9 || offsetInt < 0) {
    System.err.print(Constants.MSG_ERROR_TEST_OFFSET);
    System.out.println();
    System.exit(0);
  }
  offsetVal=new String(""String_Node_Str"" + offsetInt);
  httpPortVal=httpPort;
  environmentNameVal=environmentName;
  mailReceiverVal=mailReceiver;
  httpPortPath=Constants.SETTINGS_HTTP_PORT_PATH;
  environmentNamePath=Constants.ENVIRONMENT_NAME_TOTAL_PATH_LEAF;
  mailReceiverPath=Constants.SETTINGS_NOTIFICATION_RECEIVER_PATH;
  offsetPaths=new OffsetSystem[]{new OffsetSystem(2,Constants.TEXT_JMX_PORT_PATH),new OffsetSystem(2,Constants.TEXT_JMX_RMI_PORT_PATH),new OffsetSystem(1,Constants.TEXT_HARVEST_HETRIX_GUI_PORT),new OffsetSystem(1,Constants.TEXT_HARVEST_HETRIX_JMX_PORT)};
  apply();
}","/** 
 * Function to apply the variables.
 * @param offset The input offset value (1-9 below httpPort).
 * @param httpPort The new value for the HTTP port.
 * @param environmentName The new value for the environment name.
 * @param mailReceiver The new value for the mailReceiver.
 */
public void applyTestArguments(String offset,String httpPort,String environmentName,String mailReceiver){
  ArgumentNotValid.checkNotNullOrEmpty(offset,""String_Node_Str"");
  ArgumentNotValid.checkNotNullOrEmpty(httpPort,""String_Node_Str"");
  ArgumentNotValid.checkNotNullOrEmpty(environmentName,""String_Node_Str"");
  ArgumentNotValid.checkNotNullOrEmpty(mailReceiver,""String_Node_Str"");
  int offsetInt=(new Integer(httpPort)).intValue() - (new Integer(offset)).intValue();
  if (offsetInt > Constants.TEST_OFFSET_INTEGER_MAXIMUM_VALUE || offsetInt < 0) {
    System.err.print(Constants.MSG_ERROR_TEST_OFFSET);
    System.out.println();
    System.exit(0);
  }
  offsetVal=new String(""String_Node_Str"" + offsetInt);
  httpPortVal=httpPort;
  environmentNameVal=environmentName;
  mailReceiverVal=mailReceiver;
  httpPortPath=Constants.SETTINGS_HTTP_PORT_PATH;
  environmentNamePath=Constants.ENVIRONMENT_NAME_TOTAL_PATH_LEAF;
  mailReceiverPath=Constants.SETTINGS_NOTIFICATION_RECEIVER_PATH;
  offsetPaths=new OffsetSystem[]{new OffsetSystem(2,Constants.TEXT_JMX_PORT_PATH),new OffsetSystem(2,Constants.TEXT_JMX_RMI_PORT_PATH),new OffsetSystem(1,Constants.TEXT_HARVEST_HETRIX_GUI_PORT),new OffsetSystem(1,Constants.TEXT_HARVEST_HETRIX_JMX_PORT)};
  apply();
}",0.985545335085414
90094,"/** 
 * Applies the new variables on a specific element.
 * @param e The element where the variables are to be applied.
 */
private void applyOnElement(Element e){
  ArgumentNotValid.checkNotNull(e,""String_Node_Str"");
  set.overWriteOnly(e,httpPortVal,httpPortPath);
  set.overWriteOnly(e,environmentNameVal,environmentNamePath);
  set.overWriteOnly(e,mailReceiverVal,mailReceiverPath);
  for (  OffsetSystem ofs : offsetPaths) {
    set.overWriteOnlyInt(e,ofs.index,offsetVal.charAt(0),ofs.path);
  }
}","/** 
 * Applies the new variables on a specific element.
 * @param e The element where the variables are to be applied.
 */
private void applyOnElement(Element e){
  ArgumentNotValid.checkNotNull(e,""String_Node_Str"");
  set.overWriteOnly(e,httpPortVal,httpPortPath);
  set.overWriteOnly(e,environmentNameVal,environmentNamePath);
  set.overWriteOnly(e,mailReceiverVal,mailReceiverPath);
  for (  OffsetSystem ofs : offsetPaths) {
    set.overWriteOnlyInt(e,ofs.getIndex(),offsetVal.charAt(0),ofs.getPath());
  }
}",0.9803149606299212
90095,"/** 
 * Applies the test arguments. If the test arguments are given correctly, the configuration file is  loaded and changed appropriately, then written to a test configuration  file. The new test configuration file has the same name as the original  configuration file, except "".xml"" is replaced by ""_text.xml"". Thus ""path/config.xml"" -> ""path/config_test.xml"".  
 * @param testArguments The test arguments.
 */
private static void initTestArguments(String testArguments){
  if (testArguments == null || testArguments.equalsIgnoreCase(""String_Node_Str"")) {
    return;
  }
  String[] changes=testArguments.split(""String_Node_Str"");
  if (changes.length != Constants.TEST_ARGUMENTS_REQUIRED) {
    System.err.print(Constants.MSG_ERROR_TEST_ARGUMENTS);
    System.exit(0);
  }
  try {
    CreateTestInstance cti=new CreateTestInstance(itConfigFile);
    cti.applyTestArguments(changes[0],changes[1],changes[2],changes[3]);
    String tmp=itConfigFile.getPath();
    String[] configFile=tmp.split(""String_Node_Str"");
    String nameOfNewConfig=configFile[0] + Constants.TEST_CONFIG_FILE_REPLACE_ENDING;
    cti.createSettingsFile(nameOfNewConfig);
    itConfigFile=new File(nameOfNewConfig);
  }
 catch (  IOException e) {
    System.out.println(""String_Node_Str"" + e);
    System.exit(0);
  }
}","/** 
 * Applies the test arguments. If the test arguments are given correctly, the configuration file is  loaded and changed appropriately, then written to a test configuration  file. The new test configuration file has the same name as the original  configuration file, except "".xml"" is replaced by ""_text.xml"". Thus ""path/config.xml"" -> ""path/config_test.xml"".  
 * @param testArguments The test arguments.
 */
private static void initTestArguments(String testArguments){
  if (testArguments == null || testArguments.equalsIgnoreCase(""String_Node_Str"")) {
    return;
  }
  String[] changes=testArguments.split(""String_Node_Str"");
  if (changes.length != Constants.TEST_ARGUMENTS_REQUIRED) {
    System.err.print(Constants.MSG_ERROR_TEST_ARGUMENTS);
    System.exit(0);
  }
  try {
    CreateTestInstance cti=new CreateTestInstance(itConfigFile);
    cti.applyTestArguments(changes[0],changes[1],changes[2],changes[2 + 1]);
    String tmp=itConfigFile.getPath();
    String[] configFile=tmp.split(""String_Node_Str"");
    String nameOfNewConfig=configFile[0] + Constants.TEST_CONFIG_FILE_REPLACE_ENDING;
    cti.createSettingsFile(nameOfNewConfig);
    itConfigFile=new File(nameOfNewConfig);
  }
 catch (  IOException e) {
    System.out.println(""String_Node_Str"" + e);
    System.exit(0);
  }
}",0.9976833976833976
90096,"/** 
 * Run the new deploy.
 * @param args The Command-line arguments in no particular order:-C  The it-configuration file (ends with .xml). -Z  The NetarchiveSuite file to be unpacked (ends with .zip). -S  The security policy file (ends with .policy). -L  The logging property file (ends with .prop). -O  [OPTIONAL] The output directory -D  [OPTIONAL] The database -T  [OPTIONAL] The test arguments (httpportoffset, port,  environmentName, mailReciever) 
 */
public static void main(String[] args){
  try {
    if (!ap.parseParameters(args)) {
      System.err.print(Constants.MSG_ERROR_PARSE_ARGUMENTS);
      System.out.println();
      System.exit(0);
    }
    if (ap.cmd.getOptions().length < Constants.ARGUMENTS_REQUIRED) {
      System.err.print(Constants.MSG_ERROR_NOT_ENOUGH_ARGUMENTS);
      System.out.println();
      System.out.println(""String_Node_Str"");
      System.out.println(ap.listArguments());
      System.out.println(""String_Node_Str"" + ""String_Node_Str"");
      System.out.println(""String_Node_Str"" + ""String_Node_Str"");
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
      System.exit(0);
    }
    if (args.length > ap.options.getOptions().size()) {
      System.err.print(Constants.MSG_ERROR_TOO_MANY_ARGUMENTS);
      System.out.println();
      System.out.println(""String_Node_Str"" + ap.options.getOptions().size() + ""String_Node_Str"");
      System.exit(0);
    }
    String itConfigFileName=ap.cmd.getOptionValue(Constants.ARG_CONFIG_FILE);
    String netarchiveSuiteFileName=ap.cmd.getOptionValue(Constants.ARG_NETARCHIVE_SUITE_FILE);
    String secPolicyFileName=ap.cmd.getOptionValue(Constants.ARG_SECURITY_FILE);
    String logPropFileName=ap.cmd.getOptionValue(Constants.ARG_LOG_PROPERTY_FILE);
    String outputDir=ap.cmd.getOptionValue(Constants.ARG_OUTPUT_DIRECTORY);
    String databaseFileName=ap.cmd.getOptionValue(Constants.ARG_DATABASE_FILE);
    String testArguments=ap.cmd.getOptionValue(Constants.ARG_TEST);
    String resetArgument=ap.cmd.getOptionValue(Constants.ARG_RESET);
    String evaluateArgument=ap.cmd.getOptionValue(Constants.ARG_EVALUATE);
    initConfigFile(itConfigFileName);
    initNetarchiveSuiteFile(netarchiveSuiteFileName);
    initSecPolicyFile(secPolicyFileName);
    initLogPropFile(logPropFileName);
    initDatabase(databaseFileName);
    initTestArguments(testArguments);
    initReset(resetArgument);
    initEvaluate(evaluateArgument);
    itConfig=new DeployConfiguration(itConfigFile,netarchiveSuiteFile,secPolicyFile,logPropFile,outputDir,dbFile,resetDirectory);
    itConfig.write();
  }
 catch (  SecurityException e) {
    System.out.println(""String_Node_Str"" + e);
  }
catch (  Exception e) {
    System.err.println(""String_Node_Str"" + e);
  }
}","/** 
 * Run the new deploy.
 * @param args The Command-line arguments in no particular order:-C  The it-configuration file (ends with .xml). -Z  The NetarchiveSuite file to be unpacked (ends with .zip). -S  The security policy file (ends with .policy). -L  The logging property file (ends with .prop). -O  [OPTIONAL] The output directory -D  [OPTIONAL] The database -T  [OPTIONAL] The test arguments (httpportoffset, port,  environmentName, mailReciever) 
 */
public static void main(String[] args){
  try {
    if (!ap.parseParameters(args)) {
      System.err.print(Constants.MSG_ERROR_PARSE_ARGUMENTS);
      System.out.println();
      System.exit(0);
    }
    if (ap.getCommandLine().getOptions().length < Constants.ARGUMENTS_REQUIRED) {
      System.err.print(Constants.MSG_ERROR_NOT_ENOUGH_ARGUMENTS);
      System.out.println();
      System.out.println(""String_Node_Str"");
      System.out.println(ap.listArguments());
      System.out.println(""String_Node_Str"" + ""String_Node_Str"");
      System.out.println(""String_Node_Str"" + ""String_Node_Str"");
      System.out.println(""String_Node_Str"");
      System.out.println(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
      System.exit(0);
    }
    if (args.length > ap.getOptions().getOptions().size()) {
      System.err.print(Constants.MSG_ERROR_TOO_MANY_ARGUMENTS);
      System.out.println();
      System.out.println(""String_Node_Str"" + ap.getOptions().getOptions().size() + ""String_Node_Str"");
      System.exit(0);
    }
    String itConfigFileName=ap.getCommandLine().getOptionValue(Constants.ARG_CONFIG_FILE);
    String netarchiveSuiteFileName=ap.getCommandLine().getOptionValue(Constants.ARG_NETARCHIVE_SUITE_FILE);
    String secPolicyFileName=ap.getCommandLine().getOptionValue(Constants.ARG_SECURITY_FILE);
    String logPropFileName=ap.getCommandLine().getOptionValue(Constants.ARG_LOG_PROPERTY_FILE);
    String outputDir=ap.getCommandLine().getOptionValue(Constants.ARG_OUTPUT_DIRECTORY);
    String databaseFileName=ap.getCommandLine().getOptionValue(Constants.ARG_DATABASE_FILE);
    String testArguments=ap.getCommandLine().getOptionValue(Constants.ARG_TEST);
    String resetArgument=ap.getCommandLine().getOptionValue(Constants.ARG_RESET);
    String evaluateArgument=ap.getCommandLine().getOptionValue(Constants.ARG_EVALUATE);
    initConfigFile(itConfigFileName);
    initNetarchiveSuiteFile(netarchiveSuiteFileName);
    initSecPolicyFile(secPolicyFileName);
    initLogPropFile(logPropFileName);
    initDatabase(databaseFileName);
    initTestArguments(testArguments);
    initReset(resetArgument);
    initEvaluate(evaluateArgument);
    itConfig=new DeployConfiguration(itConfigFile,netarchiveSuiteFile,secPolicyFile,logPropFile,outputDir,dbFile,resetDirectory);
    itConfig.write();
  }
 catch (  SecurityException e) {
    System.out.println(""String_Node_Str"" + e);
  }
catch (  Exception e) {
    System.err.println(""String_Node_Str"" + e);
  }
}",0.9609455292908532
90097,"/** 
 * Dummy function. This is only used for windows machines!
 * @param dir The directory to put the file
 */
@Override protected void createInstallDirScript(File dir){
  return;
}","/** 
 * Dummy function on linux machine. This is only used for windows machines!
 * @param dir The directory to put the file.
 */
@Override protected void createInstallDirScript(File dir){
  return;
}",0.9528795811518324
90098,"/** 
 * This function creates the script to kill all applications on this  machine. The scripts calls all the kill script for each application. 
 * @param directory The directory for this machine (use global variable?).
 */
@Override protected void createOSLocalKillAllScript(File directory){
  ArgumentNotValid.checkNotNull(directory,""String_Node_Str"");
  File killAllScript=new File(directory,""String_Node_Str"" + scriptExtension);
  try {
    PrintWriter killPrinter=new PrintWriter(killAllScript);
    try {
      killPrinter.println(""String_Node_Str"" + name);
      killPrinter.println(""String_Node_Str"");
      killPrinter.println(""String_Node_Str"" + getConfDirPath());
      for (      Application app : applications) {
        String appScript=""String_Node_Str"" + app.getIdentification() + scriptExtension;
        killPrinter.println(""String_Node_Str"" + appScript + ""String_Node_Str"");
        killPrinter.println(""String_Node_Str"" + appScript);
        killPrinter.println(""String_Node_Str"");
      }
    }
  finally {
      killPrinter.close();
    }
  }
 catch (  IOException e) {
    log.trace(""String_Node_Str"");
    throw new IOFailure(""String_Node_Str"" + e);
  }
catch (  Exception e) {
    log.trace(""String_Node_Str"" + e);
    System.out.println(""String_Node_Str"" + e);
  }
}","/** 
 * This function creates the script to kill all applications on this  machine. The scripts calls all the kill script for each application.  pseudo code: - echo Killing all applications at machine: mac - if [ -e ./kill_app.sh ] -    ./kill_app.sh - fi - ... where: mac = machine name. app = application name. ... = the same for other applications.
 * @param directory The directory for this machine (use global variable?).
 */
@Override protected void createOSLocalKillAllScript(File directory){
  ArgumentNotValid.checkNotNull(directory,""String_Node_Str"");
  File killAllScript=new File(directory,""String_Node_Str"" + scriptExtension);
  try {
    PrintWriter killPrinter=new PrintWriter(killAllScript);
    try {
      killPrinter.println(""String_Node_Str"" + name);
      killPrinter.println(""String_Node_Str"");
      killPrinter.println(""String_Node_Str"" + getConfDirPath());
      for (      Application app : applications) {
        String appScript=""String_Node_Str"" + app.getIdentification() + scriptExtension;
        killPrinter.println(""String_Node_Str"" + appScript + ""String_Node_Str"");
        killPrinter.println(""String_Node_Str"" + appScript);
        killPrinter.println(""String_Node_Str"");
      }
    }
  finally {
      killPrinter.close();
    }
  }
 catch (  IOException e) {
    log.trace(""String_Node_Str"");
    throw new IOFailure(""String_Node_Str"" + e);
  }
catch (  Exception e) {
    log.trace(""String_Node_Str"" + e);
    System.out.println(""String_Node_Str"" + e);
  }
}",0.9258330347545682
90099,"/** 
 * Creates the operation system specific starting script for this machine.
 * @return Operation system specific part of the startscript.
 */
@Override protected String osStartScript(){
  StringBuilder res=new StringBuilder(""String_Node_Str"");
  res.append(""String_Node_Str"");
  res.append(machineUserLogin());
  res.append(""String_Node_Str"");
  res.append(getConfDirPath());
  res.append(""String_Node_Str"");
  res.append(scriptExtension);
  res.append(""String_Node_Str"");
  res.append(getInstallDirPath());
  res.append(""String_Node_Str"");
  res.append(""String_Node_Str"");
  return res.toString();
}","/** 
 * Creates the operation system specific starting script for this machine. pseudo code: - ssh maclogin "". /etc/profile; conf/startall.sh; sleep 5;  cat install/*.log"" where: maclogin = login for machine (username@machine). conf = path to /conf directory. install = path to install directory.
 * @return Operation system specific part of the startscript.
 */
@Override protected String osStartScript(){
  StringBuilder res=new StringBuilder(""String_Node_Str"");
  res.append(""String_Node_Str"");
  res.append(machineUserLogin());
  res.append(""String_Node_Str"");
  res.append(getConfDirPath());
  res.append(""String_Node_Str"");
  res.append(scriptExtension);
  res.append(""String_Node_Str"");
  res.append(getInstallDirPath());
  res.append(""String_Node_Str"");
  res.append(""String_Node_Str"");
  return res.toString();
}",0.847719298245614
90100,"/** 
 * Creates the start scripts for all the applications. The application should only be started, if it is not running already. The script starts by finding all running processes of the application. If any processes are found, a new application should not be started. Otherwise start the application. The start_app.sh should have the following structure: - echo Starting linux application. - cd path - #!/bin/bash - PIDS = $(ps -wwfe | grep fullapp | grep -v grep | grep  path\settings_app.xml | awk ""{print \\$2}"") - if [ -n ""$PIDS"" ]; then -     echo Application already running. - else -     export CLASSPATH = cp:$CLASSPATH; -     JAVA - fi where: path = the path to the install directory. fullapp = the full name application with path. app = the name of the application. cp = the classpaths for the application. JAVA = the command to run the java application.
 * @param directory The directory for this machine (use global variable?).
 */
@Override protected void createApplicationStartScripts(File directory){
  ArgumentNotValid.checkNotNull(directory,""String_Node_Str"");
  for (  Application app : applications) {
    File appStartScript=new File(directory,""String_Node_Str"" + app.getIdentification() + scriptExtension);
    try {
      PrintWriter appPrint=new PrintWriter(appStartScript);
      try {
        appPrint.println(""String_Node_Str"");
        appPrint.println(""String_Node_Str"" + app.installPathLinux());
        appPrint.println(""String_Node_Str"" + app.getTotalName() + ""String_Node_Str""+ getConfDirPath()+ ""String_Node_Str""+ app.getIdentification()+ ""String_Node_Str""+ ""String_Node_Str"");
        appPrint.println(""String_Node_Str"");
        appPrint.println(""String_Node_Str"");
        appPrint.println(""String_Node_Str"");
        appPrint.println(""String_Node_Str"" + osGetClassPath(app) + ""String_Node_Str"");
        appPrint.println(""String_Node_Str"" + app.getMachineParameters().writeJavaOptions() + ""String_Node_Str""+ getConfDirPath()+ ""String_Node_Str""+ app.getIdentification()+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ getConfDirPath()+ ""String_Node_Str""+ app.getIdentification()+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ getConfDirPath()+ ""String_Node_Str""+ app.getTotalName()+ ""String_Node_Str""+ ""String_Node_Str""+ app.getIdentification()+ ""String_Node_Str""+ ""String_Node_Str"");
        appPrint.println(""String_Node_Str"");
      }
  finally {
        appPrint.close();
      }
    }
 catch (    IOException e) {
      log.trace(""String_Node_Str"");
      throw new IOFailure(""String_Node_Str"" + ""String_Node_Str"" + e);
    }
catch (    Exception e) {
      log.trace(""String_Node_Str"" + e);
      System.out.println(""String_Node_Str"" + ""String_Node_Str"" + e);
    }
  }
}","/** 
 * Creates the start scripts for all the applications. The application should only be started, if it is not running already. The script starts by finding all running processes of the application. If any processes are found, a new application should not be started. Otherwise start the application. The start_app.sh should have the following structure: - echo Starting linux application: app - cd path - #!/bin/bash - PIDS = $(ps -wwfe | grep fullapp | grep -v grep | grep  path\settings_app.xml | awk ""{print \\$2}"") - if [ -n ""$PIDS"" ]; then -     echo Application already running. - else -     export CLASSPATH = cp:$CLASSPATH; -     JAVA - fi where: path = the path to the install directory. fullapp = the full name application with java path. app = the name of the application. cp = the classpaths for the application. JAVA = the command to run the java application.
 * @param directory The directory for this machine (use global variable?).
 */
@Override protected void createApplicationStartScripts(File directory){
  ArgumentNotValid.checkNotNull(directory,""String_Node_Str"");
  for (  Application app : applications) {
    File appStartScript=new File(directory,""String_Node_Str"" + app.getIdentification() + scriptExtension);
    try {
      PrintWriter appPrint=new PrintWriter(appStartScript);
      try {
        appPrint.println(""String_Node_Str"" + app.getIdentification());
        appPrint.println(""String_Node_Str"" + app.installPathLinux());
        appPrint.println(""String_Node_Str"" + app.getTotalName() + ""String_Node_Str""+ getConfDirPath()+ ""String_Node_Str""+ app.getIdentification()+ ""String_Node_Str""+ ""String_Node_Str"");
        appPrint.println(""String_Node_Str"");
        appPrint.println(""String_Node_Str"");
        appPrint.println(""String_Node_Str"");
        appPrint.println(""String_Node_Str"" + osGetClassPath(app) + ""String_Node_Str"");
        appPrint.println(""String_Node_Str"" + app.getMachineParameters().writeJavaOptions() + ""String_Node_Str""+ getConfDirPath()+ ""String_Node_Str""+ app.getIdentification()+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ getConfDirPath()+ ""String_Node_Str""+ app.getIdentification()+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ getConfDirPath()+ ""String_Node_Str""+ app.getTotalName()+ ""String_Node_Str""+ ""String_Node_Str""+ app.getIdentification()+ ""String_Node_Str""+ ""String_Node_Str"");
        appPrint.println(""String_Node_Str"");
      }
  finally {
        appPrint.close();
      }
    }
 catch (    IOException e) {
      log.trace(""String_Node_Str"");
      throw new IOFailure(""String_Node_Str"" + ""String_Node_Str"" + e);
    }
catch (    Exception e) {
      log.trace(""String_Node_Str"" + e);
      System.out.println(""String_Node_Str"" + ""String_Node_Str"" + e);
    }
  }
}",0.993327321911632
90101,"/** 
 * This function creates the script to start all applications on this  machine. The scripts calls all the start script for each application. 
 * @param directory The directory for this machine (use global variable?).
 */
@Override protected void createOSLocalStartAllScript(File directory){
  ArgumentNotValid.checkNotNull(directory,""String_Node_Str"");
  File startAllScript=new File(directory,""String_Node_Str"" + scriptExtension);
  try {
    PrintWriter startPrinter=new PrintWriter(startAllScript);
    try {
      startPrinter.println(""String_Node_Str"" + name);
      startPrinter.println(""String_Node_Str"");
      startPrinter.println(""String_Node_Str"" + getConfDirPath());
      for (      Application app : applications) {
        String appScript=""String_Node_Str"" + app.getIdentification() + scriptExtension;
        startPrinter.println(""String_Node_Str"" + appScript + ""String_Node_Str"");
        startPrinter.println(""String_Node_Str"" + appScript);
        startPrinter.println(""String_Node_Str"");
      }
    }
  finally {
      startPrinter.close();
    }
  }
 catch (  IOException e) {
    log.trace(""String_Node_Str"");
    throw new IOFailure(""String_Node_Str"" + e);
  }
catch (  Exception e) {
    log.trace(""String_Node_Str"" + e);
    System.out.println(""String_Node_Str"" + e);
  }
}","/** 
 * This function creates the script to start all applications on this  machine. The scripts calls all the start script for each application.  pseudo code: - echo Starting all applications at machine: mac - if [ -e ./start_app.sh ] -    ./start_app.sh - fi - ... where: mac = machine name. app = application name. ... = the same for other applications.
 * @param directory The directory for this machine (use global variable?).
 */
@Override protected void createOSLocalStartAllScript(File directory){
  ArgumentNotValid.checkNotNull(directory,""String_Node_Str"");
  File startAllScript=new File(directory,""String_Node_Str"" + scriptExtension);
  try {
    PrintWriter startPrinter=new PrintWriter(startAllScript);
    try {
      startPrinter.println(""String_Node_Str"" + name);
      startPrinter.println(""String_Node_Str"");
      startPrinter.println(""String_Node_Str"" + getConfDirPath());
      for (      Application app : applications) {
        String appScript=""String_Node_Str"" + app.getIdentification() + scriptExtension;
        startPrinter.println(""String_Node_Str"" + appScript + ""String_Node_Str"");
        startPrinter.println(""String_Node_Str"" + appScript);
        startPrinter.println(""String_Node_Str"");
      }
    }
  finally {
      startPrinter.close();
    }
  }
 catch (  IOException e) {
    log.trace(""String_Node_Str"");
    throw new IOFailure(""String_Node_Str"" + e);
  }
catch (  Exception e) {
    log.trace(""String_Node_Str"" + e);
    System.out.println(""String_Node_Str"" + e);
  }
}",0.925531914893617
90102,"/** 
 * Look up a given URI and return the contents as an InputStream.
 * @param uri The URI to find in the archive.  If the URI does notmatch any entries in the archive, IOFailure is thrown.
 * @return An InputStream Containing all the data in the entry, ornull if the entry was not found
 * @throws IOFailure If the ARC file was found in the Lucene index but notin the bit archive, or if some other failure happened while finding the file.
 */
public InputStream lookup(URI uri){
  ArgumentNotValid.checkNotNull(uri,""String_Node_Str"");
  ARCKey key=luceneLookup(uri.toString());
  if (key == null) {
    return null;
  }
 else {
    final BitarchiveRecord bitarchiveRecord=arcRepositoryClient.get(key.getFile().getName(),key.getOffset());
    if (bitarchiveRecord == null) {
      String message=""String_Node_Str"" + key.getFile().getName() + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
      log.debug(message);
      throw new IOFailure(message);
    }
    return bitarchiveRecord.getData();
  }
}","/** 
 * Look up a given URI and return the contents as an InputStream.
 * @param uri The URI to find in the archive.  If the URI does notmatch any entries in the archive, IOFailure is thrown.
 * @return An InputStream Containing all the data in the entry, ornull if the entry was not found
 * @throws IOFailure If the ARC file was found in the Lucene index but notin the bit archive, or if some other failure happened while finding the file.
 */
public InputStream lookup(URI uri){
  ArgumentNotValid.checkNotNull(uri,""String_Node_Str"");
  ARCKey key=luceneLookup(uri.getScheme() + ""String_Node_Str"" + uri.getSchemeSpecificPart());
  if (key == null) {
    return null;
  }
 else {
    final BitarchiveRecord bitarchiveRecord=arcRepositoryClient.get(key.getFile().getName(),key.getOffset());
    if (bitarchiveRecord == null) {
      String message=""String_Node_Str"" + key.getFile().getName() + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"";
      log.debug(message);
      throw new IOFailure(message);
    }
    return bitarchiveRecord.getData();
  }
}",0.96888063167673
90103,"/** 
 * Get the URI from this request. In contrast to javax.servlet.HttpServletResponse this includes the query string.
 * @return The URI from this request.
 * @throws IOFailure if the URI is invalid. This should never happen.
 */
public URI getURI(){
  try {
    if (hr.getQueryString() != null) {
      return new URI(hr.getRequestURL().toString() + ""String_Node_Str"" + hr.getQueryString());
    }
 else {
      return new URI(hr.getRequestURL().toString());
    }
  }
 catch (  URISyntaxException e) {
    throw new IOFailure(""String_Node_Str"",e);
  }
}","/** 
 * Get the URI from this request. In contrast to javax.servlet.HttpServletResponse this includes the query string.
 * @return The URI from this request.
 * @throws IOFailure if the URI is invalid. This should never happen.
 */
public URI getURI(){
  String uri_string;
  if (hr.getQueryString() != null) {
    uri_string=hr.getRequestURL().toString() + ""String_Node_Str"" + uriEncode(hr.getQueryString());
  }
 else {
    uri_string=hr.getRequestURL().toString();
  }
  try {
    return new URI(uri_string);
  }
 catch (  URISyntaxException e) {
    throw new IOFailure(""String_Node_Str"" + uri_string + ""String_Node_Str"",e);
  }
}",0.6801007556675063
90104,"public void setUp() throws Exception {
  rs.setUp();
  JMSConnectionTestMQ.useJMSConnectionTestMQ();
  super.setUp();
}","public void setUp() throws Exception {
  rs.setUp();
  JMSConnectionTestMQ.useJMSConnectionTestMQ();
  Settings.set(CommonSettings.ENVIRONMENT_LOCATION_NAMES,""String_Node_Str"",""String_Node_Str"");
  if (!Location.isKnownLocation(""String_Node_Str"") || !Location.isKnownLocation(""String_Node_Str"")) {
    fail(""String_Node_Str"");
  }
  super.setUp();
}",0.5085470085470085
90105,"public void testProcessMissingRequest() throws Exception {
  Settings.set(ArchiveSettings.DIR_ARCREPOSITORY_BITPRESERVATION,TestInfo.WORKING_DIR.getAbsolutePath());
  Settings.set(ArchiveSettings.DIRS_ARCREPOSITORY_ADMIN,TestInfo.WORKING_DIR.getAbsolutePath());
  AdminData.getUpdateableInstance();
  MockFileBasedActiveBitPreservation mockabp=new MockFileBasedActiveBitPreservation();
  MockHttpServletRequest request=new MockHttpServletRequest();
  String ba1=""String_Node_Str"";
  String ba2=""String_Node_Str"";
  String filename1=""String_Node_Str"";
  String filename2=""String_Node_Str"";
  Locale defaultLocale=new Locale(""String_Node_Str"");
  Map<String,String[]> args=new HashMap<String,String[]>();
  args.put(ADD_COMMAND,new String[]{ba1 + Constants.STRING_FILENAME_SEPARATOR + filename1});
  request.setupAddParameter(ADD_COMMAND,new String[]{ba1 + Constants.STRING_FILENAME_SEPARATOR + filename1});
  args.put(GET_INFO_COMMAND,new String[]{filename1});
  request.setupAddParameter(GET_INFO_COMMAND,new String[]{filename1});
  args.put(BITARCHIVE_NAME_PARAM,new String[]{Location.get(ba1).getName()});
  request.setupAddParameter(BITARCHIVE_NAME_PARAM,new String[]{Location.get(ba1).getName()});
  request.setupGetParameterMap(args);
  request.setupGetParameterNames(new Vector(args.keySet()).elements());
  Map<String,FilePreservationState> status=BitpreserveFileState.processMissingRequest(getDummyPageContext(defaultLocale,request),new StringBuilder());
  assertEquals(""String_Node_Str"",1,mockabp.getCallCount(ADD_METHOD));
  assertEquals(""String_Node_Str"",1,mockabp.getCallCount(GET_INFO_METHOD));
  assertEquals(""String_Node_Str"",null,status.get(filename1));
  mockabp.calls.clear();
  request=new MockHttpServletRequest();
  args.clear();
  args.put(BITARCHIVE_NAME_PARAM,new String[]{Location.get(ba1).getName()});
  request.setupAddParameter(BITARCHIVE_NAME_PARAM,new String[]{Location.get(ba1).getName()});
  request.setupGetParameterMap(args);
  status=BitpreserveFileState.processMissingRequest(getDummyPageContext(defaultLocale,request),new StringBuilder());
  assertEquals(""String_Node_Str"",0,mockabp.getCallCount(ADD_METHOD));
  assertEquals(""String_Node_Str"",0,mockabp.getCallCount(GET_INFO_METHOD));
  assertEquals(""String_Node_Str"",0,status.size());
  mockabp.calls.clear();
  request=new MockHttpServletRequest();
  args.clear();
  args.put(BITARCHIVE_NAME_PARAM,new String[]{Location.get(ba2).getName()});
  request.setupAddParameter(BITARCHIVE_NAME_PARAM,new String[]{Location.get(ba2).getName()});
  request.setupAddParameter(ADD_COMMAND,new String[]{ba2 + Constants.STRING_FILENAME_SEPARATOR + filename1,ba2 + Constants.STRING_FILENAME_SEPARATOR + filename1});
  args.put(ADD_COMMAND,new String[]{ba2 + Constants.STRING_FILENAME_SEPARATOR + filename1,ba2 + Constants.STRING_FILENAME_SEPARATOR + filename1});
  request.setupAddParameter(GET_INFO_COMMAND,new String[]{filename1,filename2,filename1});
  args.put(GET_INFO_COMMAND,new String[]{filename1,filename2,filename1});
  request.setupGetParameterMap(args);
  status=BitpreserveFileState.processMissingRequest(getDummyPageContext(defaultLocale,request),new StringBuilder());
  assertEquals(""String_Node_Str"",2,mockabp.getCallCount(ADD_METHOD));
  assertEquals(""String_Node_Str"",3,mockabp.getCallCount(GET_INFO_METHOD));
  assertEquals(""String_Node_Str"",2,status.size());
  assertEquals(""String_Node_Str"",null,status.get(filename1));
  assertEquals(""String_Node_Str"",null,status.get(filename2));
  CollectionAsserts.assertIteratorEquals(""String_Node_Str"",Arrays.asList(new String[]{filename1 + ""String_Node_Str"" + ba2,filename1 + ""String_Node_Str"" + ba2}).iterator(),mockabp.calls.get(ADD_METHOD).iterator());
  CollectionAsserts.assertIteratorEquals(""String_Node_Str"",Arrays.asList(new String[]{filename1,filename2,filename1}).iterator(),mockabp.calls.get(GET_INFO_METHOD).iterator());
}","public void testProcessMissingRequest() throws Exception {
  Settings.set(ArchiveSettings.DIR_ARCREPOSITORY_BITPRESERVATION,TestInfo.WORKING_DIR.getAbsolutePath());
  Settings.set(ArchiveSettings.DIRS_ARCREPOSITORY_ADMIN,TestInfo.WORKING_DIR.getAbsolutePath());
  AdminData.getUpdateableInstance();
  MockFileBasedActiveBitPreservation mockabp=new MockFileBasedActiveBitPreservation();
  MockHttpServletRequest request=new MockHttpServletRequest();
  String ba1=""String_Node_Str"";
  String ba2=""String_Node_Str"";
  String filename1=""String_Node_Str"";
  String filename2=""String_Node_Str"";
  Locale defaultLocale=new Locale(""String_Node_Str"");
  Map<String,String[]> args=new HashMap<String,String[]>();
  args.put(ADD_COMMAND,new String[]{ba1 + Constants.STRING_FILENAME_SEPARATOR + filename1});
  request.setupAddParameter(ADD_COMMAND,new String[]{ba1 + Constants.STRING_FILENAME_SEPARATOR + filename1});
  args.put(GET_INFO_COMMAND,new String[]{filename1});
  request.setupAddParameter(GET_INFO_COMMAND,new String[]{filename1});
  args.put(BITARCHIVE_NAME_PARAM,new String[]{Location.get(ba1).getName()});
  request.setupAddParameter(BITARCHIVE_NAME_PARAM,new String[]{Location.get(ba1).getName()});
  request.setupGetParameterMap(args);
  request.setupGetParameterNames(new Vector<String>(args.keySet()).elements());
  Map<String,FilePreservationState> status=BitpreserveFileState.processMissingRequest(getDummyPageContext(defaultLocale,request),new StringBuilder());
  assertEquals(""String_Node_Str"",1,mockabp.getCallCount(ADD_METHOD));
  assertEquals(""String_Node_Str"",1,mockabp.getCallCount(GET_INFO_METHOD));
  assertEquals(""String_Node_Str"",null,status.get(filename1));
  mockabp.calls.clear();
  request=new MockHttpServletRequest();
  args.clear();
  args.put(BITARCHIVE_NAME_PARAM,new String[]{Location.get(ba1).getName()});
  request.setupAddParameter(BITARCHIVE_NAME_PARAM,new String[]{Location.get(ba1).getName()});
  request.setupGetParameterMap(args);
  status=BitpreserveFileState.processMissingRequest(getDummyPageContext(defaultLocale,request),new StringBuilder());
  assertEquals(""String_Node_Str"",0,mockabp.getCallCount(ADD_METHOD));
  assertEquals(""String_Node_Str"",0,mockabp.getCallCount(GET_INFO_METHOD));
  assertEquals(""String_Node_Str"",0,status.size());
  mockabp.calls.clear();
  request=new MockHttpServletRequest();
  args.clear();
  args.put(BITARCHIVE_NAME_PARAM,new String[]{Location.get(ba2).getName()});
  request.setupAddParameter(BITARCHIVE_NAME_PARAM,new String[]{Location.get(ba2).getName()});
  request.setupAddParameter(ADD_COMMAND,new String[]{ba2 + Constants.STRING_FILENAME_SEPARATOR + filename1,ba2 + Constants.STRING_FILENAME_SEPARATOR + filename1});
  args.put(ADD_COMMAND,new String[]{ba2 + Constants.STRING_FILENAME_SEPARATOR + filename1,ba2 + Constants.STRING_FILENAME_SEPARATOR + filename1});
  request.setupAddParameter(GET_INFO_COMMAND,new String[]{filename1,filename2,filename1});
  args.put(GET_INFO_COMMAND,new String[]{filename1,filename2,filename1});
  request.setupGetParameterMap(args);
  status=BitpreserveFileState.processMissingRequest(getDummyPageContext(defaultLocale,request),new StringBuilder());
  assertEquals(""String_Node_Str"",2,mockabp.getCallCount(ADD_METHOD));
  assertEquals(""String_Node_Str"",3,mockabp.getCallCount(GET_INFO_METHOD));
  assertEquals(""String_Node_Str"",2,status.size());
  assertEquals(""String_Node_Str"",null,status.get(filename1));
  assertEquals(""String_Node_Str"",null,status.get(filename2));
  CollectionAsserts.assertIteratorEquals(""String_Node_Str"",Arrays.asList(new String[]{filename1 + ""String_Node_Str"" + ba2,filename1 + ""String_Node_Str"" + ba2}).iterator(),mockabp.calls.get(ADD_METHOD).iterator());
  CollectionAsserts.assertIteratorEquals(""String_Node_Str"",Arrays.asList(new String[]{filename1,filename2,filename1}).iterator(),mockabp.calls.get(GET_INFO_METHOD).iterator());
}",0.9989669421487604
90106,"/** 
 * Return a description of where an object is used otherwhere in the database, or null.
 * @param select A select statement finding the names of other uses.  Thestatement should result in exactly one column of string values.
 * @param victim The object being used.
 * @param args Any objects that may be used to prepare the select statement.
 * @return A string describing the usages, or null if no usages were found.
 */
public static String getUsages(String select,Object victim,Object... args){
  Connection c=DBConnect.getDBConnection();
  PreparedStatement s=null;
  try {
    s=prepareStatement(c,select,args);
    ResultSet res=s.executeQuery();
    if (res.next()) {
      List<String> used_in=new ArrayList<String>();
      do {
        used_in.add(res.getString(1));
      }
 while (res.next());
      return used_in.toString();
    }
    return null;
  }
 catch (  SQLException e) {
    final String message=""String_Node_Str"" + victim;
    log.warn(message,e);
    throw new IOFailure(message,e);
  }
 finally {
    closeStatementIfOpen(s);
  }
}","/** 
 * Return a description of where an object is used elsewhere in the database, or null.
 * @param select A select statement finding the names of other uses.  Thestatement should result in exactly one column of string values.
 * @param victim The object being used.
 * @param args Any objects that may be used to prepare the select statement.
 * @return A string describing the usages, or null if no usages were found.
 */
public static String getUsages(String select,Object victim,Object... args){
  Connection c=DBConnect.getDBConnection();
  PreparedStatement s=null;
  try {
    s=prepareStatement(c,select,args);
    ResultSet res=s.executeQuery();
    if (res.next()) {
      List<String> usedIn=new ArrayList<String>();
      do {
        usedIn.add(res.getString(1));
      }
 while (res.next());
      return usedIn.toString();
    }
    return null;
  }
 catch (  SQLException e) {
    final String message=""String_Node_Str"" + victim;
    log.warn(message,e);
    throw new IOFailure(message,e);
  }
 finally {
    closeStatementIfOpen(s);
  }
}",0.991509433962264
90107,"/** 
 * Set the CLOB maxlength. If contents.length() > maxSize, contents is truncated to contain the first maxSize characters of the contents, and a warning is logged.
 * @param s a prepared statement
 * @param fieldNum the field-index, where the contents are inserted
 * @param contents the contents
 * @param maxSize the maxsize for this contents
 * @param o the Object, which assumedly have a field named fieldName
 * @param fieldName a given field (Assumedly in Object o)
 * @throws SQLException
 */
public static void setClobMaxLength(PreparedStatement s,int fieldNum,String contents,long maxSize,Object o,String fieldName) throws SQLException {
  if (contents != null) {
    if (contents.length() > maxSize) {
      log.warn(fieldName + ""String_Node_Str"" + o+ ""String_Node_Str""+ maxSize+ ""String_Node_Str""+ maxSize+ ""String_Node_Str""+ contents);
      if (maxSize > Integer.MAX_VALUE) {
        maxSize=Integer.MAX_VALUE;
      }
      contents=contents.substring(0,(int)maxSize);
    }
    s.setCharacterStream(fieldNum,new StringReader(contents),contents.length());
    s.setString(fieldNum,contents);
  }
 else {
    s.setNull(fieldNum,Types.CLOB);
  }
}","/** 
 * Set the CLOB maxlength. If contents.length() > maxSize, contents is truncated to contain the first maxSize characters of the contents, and a warning is logged.
 * @param s a prepared statement
 * @param fieldNum the field-index, where the contents are inserted
 * @param contents the contents
 * @param maxSize the maxsize for this contents
 * @param o the Object, which assumedly have a field named fieldName
 * @param fieldName a given field (Assumedly in Object o)
 * @throws SQLException
 */
public static void setClobMaxLength(PreparedStatement s,int fieldNum,String contents,long maxSize,Object o,String fieldName) throws SQLException {
  if (contents != null) {
    if (contents.length() > maxSize) {
      log.warn(fieldName + ""String_Node_Str"" + o+ ""String_Node_Str""+ maxSize+ ""String_Node_Str""+ ""String_Node_Str""+ maxSize+ ""String_Node_Str""+ contents);
      if (maxSize > Integer.MAX_VALUE) {
        maxSize=Integer.MAX_VALUE;
      }
      contents=contents.substring(0,(int)maxSize);
    }
    s.setCharacterStream(fieldNum,new StringReader(contents),contents.length());
    s.setString(fieldNum,contents);
  }
 else {
    s.setNull(fieldNum,Types.CLOB);
  }
}",0.9918976545842216
90108,"/** 
 * Check whether an object is used elsewhere in the database.
 * @param select A select statement finding the names of other uses.  Thestatement should result in exactly one column of string values.
 * @param victim The object being used.
 * @param args Any objects that may be used to prepare the select statement.
 * @throws PermissionDenied if the object has usages.
 */
public static void checkForUses(String select,Object victim,Object... args){
  String usages=DBUtils.getUsages(select,victim,args);
  if (usages != null) {
    String message=""String_Node_Str"" + victim + ""String_Node_Str""+ usages;
    throw new PermissionDenied(message);
  }
  Connection c=DBConnect.getDBConnection();
  PreparedStatement s=null;
  try {
    s=prepareStatement(c,select,args);
    ResultSet res=s.executeQuery();
    if (res.next()) {
      List<String> used_in=new ArrayList<String>();
      do {
        used_in.add(res.getString(1));
      }
 while (res.next());
    }
  }
 catch (  SQLException e) {
    final String message=""String_Node_Str"" + victim;
    log.warn(message,e);
    throw new IOFailure(message,e);
  }
 finally {
    closeStatementIfOpen(s);
  }
}","/** 
 * Check whether an object is used elsewhere in the database.
 * @param select A select statement finding the names of other uses.  Thestatement should result in exactly one column of string values.
 * @param victim The object being used.
 * @param args Any objects that may be used to prepare the select statement.
 * @throws PermissionDenied if the object has usages.
 */
public static void checkForUses(String select,Object victim,Object... args){
  String usages=DBUtils.getUsages(select,victim,args);
  if (usages != null) {
    String message=""String_Node_Str"" + victim + ""String_Node_Str""+ usages;
    throw new PermissionDenied(message);
  }
  Connection c=DBConnect.getDBConnection();
  PreparedStatement s=null;
  try {
    s=prepareStatement(c,select,args);
    ResultSet res=s.executeQuery();
    if (res.next()) {
      List<String> usedIn=new ArrayList<String>();
      do {
        usedIn.add(res.getString(1));
      }
 while (res.next());
    }
  }
 catch (  SQLException e) {
    final String message=""String_Node_Str"" + victim;
    log.warn(message,e);
    throw new IOFailure(message,e);
  }
 finally {
    closeStatementIfOpen(s);
  }
}",0.9974204643164232
90109,"/** 
 * Accept 1 to 4 parameters and checks them for validity.
 * @param args the arguments
 * @return true, if given arguments are validreturns false otherwise
 */
public boolean checkArgs(String... args){
  if (args.length < 1) {
    System.err.println(""String_Node_Str"");
    return false;
  }
  if (args.length > 4) {
    System.err.println(""String_Node_Str"");
    return false;
  }
  if (!new File(args[0]).canRead()) {
    System.err.println(""String_Node_Str"" + args[0] + ""String_Node_Str"");
    return false;
  }
  if (args.length > 1) {
    try {
      Pattern.compile(args[1]);
    }
 catch (    PatternSyntaxException e) {
      System.err.println(""String_Node_Str"" + args[1] + ""String_Node_Str"");
      return false;
    }
  }
  if (args.length > 2 && !Location.isKnownLocation(args[2])) {
    System.err.println(""String_Node_Str"" + args[2] + ""String_Node_Str""+ Location.getKnown());
    return false;
  }
  if (args.length > 3 && !new File(args[3]).canWrite()) {
    System.err.println(""String_Node_Str"" + args[3] + ""String_Node_Str"");
    return false;
  }
  return true;
}","/** 
 * Accept 1 to 4 parameters and checks them for validity.
 * @param args the arguments
 * @return true, if given arguments are validreturns false otherwise
 */
public boolean checkArgs(String... args){
  if (args.length < 1) {
    System.err.println(""String_Node_Str"");
    return false;
  }
  if (args.length > 4) {
    System.err.println(""String_Node_Str"");
    return false;
  }
  if (!new File(args[0]).canRead()) {
    System.err.println(""String_Node_Str"" + args[0] + ""String_Node_Str"");
    return false;
  }
  if (args.length > 1) {
    try {
      Pattern.compile(args[1]);
    }
 catch (    PatternSyntaxException e) {
      System.err.println(""String_Node_Str"" + args[1] + ""String_Node_Str"");
      return false;
    }
  }
  if (args.length > 2 && !Location.isKnownLocation(args[2])) {
    System.err.println(""String_Node_Str"" + args[2] + ""String_Node_Str""+ Location.getKnown());
    return false;
  }
  if (args.length > 3) {
    if (new File(args[3]).exists()) {
      System.err.println(""String_Node_Str"" + args[3] + ""String_Node_Str"");
      return false;
    }
 else {
      try {
        File tmpFile=new File(args[3]);
        tmpFile.createNewFile();
        if (!tmpFile.canWrite()) {
          System.err.println(""String_Node_Str"" + args[3] + ""String_Node_Str"");
          return false;
        }
      }
 catch (      IOException e) {
        System.err.println(""String_Node_Str"" + args[3] + ""String_Node_Str"");
        return false;
      }
    }
  }
  return true;
}",0.810077519379845
90110,"/** 
 * Process reporting of a checksum from a bitarchive for a specific file as part of a store operation for the file. Verify that the checksum is correct, update the BitArchiveStoreState state.
 * @param arcFileName The file being stored
 * @param bitarchiveName The bitarchive reporting a checksum
 * @param orgChecksum The original checksum
 * @param reportedChecksum The checksum calculated by the bitarchive This value is """", if arcfileName does not exist in bitarchive.
 */
synchronized private void processCheckSum(String arcFileName,String bitarchiveName,String orgChecksum,String reportedChecksum){
  log.debug(""String_Node_Str"");
  ArgumentNotValid.checkNotNullOrEmpty(arcFileName,""String_Node_Str"");
  ArgumentNotValid.checkNotNullOrEmpty(bitarchiveName,""String_Node_Str"");
  ArgumentNotValid.checkNotNullOrEmpty(orgChecksum,""String_Node_Str"");
  ArgumentNotValid.checkNotNull(reportedChecksum,""String_Node_Str"");
  if (orgChecksum.equals(reportedChecksum)) {
    ad.setState(arcFileName,bitarchiveName,BitArchiveStoreState.UPLOAD_COMPLETED);
    considerReplyingOnStore(arcFileName);
  }
 else {
    if (reportedChecksum.equals(""String_Node_Str"") && retryOk(bitarchiveName,arcFileName)) {
      RemoteFile rf=outstandingRemoteFiles.get(arcFileName);
      if (rf != null) {
        log.debug(""String_Node_Str"" + arcFileName + ""String_Node_Str"");
        ad.setState(rf.getName(),bitarchiveName,BitArchiveStoreState.UPLOAD_STARTED);
        connectedBitarchives.get(bitarchiveName).upload(rf);
        incRetry(bitarchiveName,arcFileName);
        return;
      }
    }
    log.warn(""String_Node_Str"" + arcFileName + ""String_Node_Str""+ bitarchiveName+ ""String_Node_Str""+ reportedChecksum+ ""String_Node_Str"");
    ad.setState(arcFileName,bitarchiveName,BitArchiveStoreState.UPLOAD_FAILED);
    considerReplyingOnStore(arcFileName);
  }
}","/** 
 * Process reporting of a checksum from a bitarchive for a specific file as part of a store operation for the file. Verify that the checksum is correct, update the BitArchiveStoreState state.
 * @param arcFileName The file being stored
 * @param bitarchiveName The bitarchive reporting a checksum
 * @param orgChecksum The original checksum
 * @param reportedChecksum The checksum calculated by the bitarchive This value is """", if arcfileName does not exist in bitarchive.
 */
private synchronized void processCheckSum(String arcFileName,String bitarchiveName,String orgChecksum,String reportedChecksum){
  log.debug(""String_Node_Str"");
  ArgumentNotValid.checkNotNullOrEmpty(arcFileName,""String_Node_Str"");
  ArgumentNotValid.checkNotNullOrEmpty(bitarchiveName,""String_Node_Str"");
  ArgumentNotValid.checkNotNullOrEmpty(orgChecksum,""String_Node_Str"");
  ArgumentNotValid.checkNotNull(reportedChecksum,""String_Node_Str"");
  if (orgChecksum.equals(reportedChecksum)) {
    ad.setState(arcFileName,bitarchiveName,BitArchiveStoreState.UPLOAD_COMPLETED);
    considerReplyingOnStore(arcFileName);
  }
 else {
    if (reportedChecksum.equals(""String_Node_Str"") && retryOk(bitarchiveName,arcFileName)) {
      RemoteFile rf=outstandingRemoteFiles.get(arcFileName);
      if (rf != null) {
        log.debug(""String_Node_Str"" + arcFileName + ""String_Node_Str"");
        ad.setState(rf.getName(),bitarchiveName,BitArchiveStoreState.UPLOAD_STARTED);
        connectedBitarchives.get(bitarchiveName).upload(rf);
        incRetry(bitarchiveName,arcFileName);
        return;
      }
    }
    log.warn(""String_Node_Str"" + arcFileName + ""String_Node_Str""+ bitarchiveName+ ""String_Node_Str""+ reportedChecksum+ ""String_Node_Str"");
    ad.setState(arcFileName,bitarchiveName,BitArchiveStoreState.UPLOAD_FAILED);
    considerReplyingOnStore(arcFileName);
  }
}",0.995673336938886
90111,"/** 
 * Process the report by a bitarchive that a file was correctly uploaded. 1. Update the upload, and store states appropriately 2. Verify that data are correctly stored in the archive by running a batch job on the archived file to perform a MD5 checksum comparison 3. Check if store operation is completed and update admin data if so
 * @param arcfileName The arcfile that was uploaded
 * @param bitarchiveName The bitarchive that uploaded it
 */
synchronized private void processDataUploaded(String arcfileName,String bitarchiveName){
  log.debug(""String_Node_Str"" + arcfileName + ""String_Node_Str""+ bitarchiveName);
  ad.setState(arcfileName,bitarchiveName,BitArchiveStoreState.DATA_UPLOADED);
  sendChecksumJob(arcfileName,connectedBitarchives.get(bitarchiveName));
}","/** 
 * Process the report by a bitarchive that a file was correctly uploaded. 1. Update the upload, and store states appropriately 2. Verify that data are correctly stored in the archive by running a batch job on the archived file to perform a MD5 checksum comparison 3. Check if store operation is completed and update admin data if so
 * @param arcfileName The arcfile that was uploaded
 * @param bitarchiveName The bitarchive that uploaded it
 */
private synchronized void processDataUploaded(String arcfileName,String bitarchiveName){
  log.debug(""String_Node_Str"" + arcfileName + ""String_Node_Str""+ bitarchiveName);
  ad.setState(arcfileName,bitarchiveName,BitArchiveStoreState.DATA_UPLOADED);
  sendChecksumJob(arcfileName,connectedBitarchives.get(bitarchiveName));
}",0.9896640826873384
90112,"/** 
 * Test whether the current state is such that we may send a reply for the file we are currently processing, and send the reply if it is. We reply only when there is an outstanding message to reply to, and a) The file is reported complete in all bitarchives or b) No bitarchive has outstanding reply messages AND some bitarchive has reported failure.
 * @param arcFileName The arcfile we consider replying to.
 */
synchronized private void considerReplyingOnStore(String arcFileName){
  if (ad.hasReplyInfo(arcFileName)) {
    if (isStoreCompleted(arcFileName)) {
      replyOK(arcFileName,ad.removeReplyInfo(arcFileName));
    }
 else     if (oneBitArchiveHasFailed(arcFileName) && noBitArchiveInStateUploadStarted(arcFileName)) {
      replyNotOK(arcFileName,ad.removeReplyInfo(arcFileName));
    }
  }
}","/** 
 * Test whether the current state is such that we may send a reply for the file we are currently processing, and send the reply if it is. We reply only when there is an outstanding message to reply to, and a) The file is reported complete in all bitarchives or b) No bitarchive has outstanding reply messages AND some bitarchive has reported failure.
 * @param arcFileName The arcfile we consider replying to.
 */
private synchronized void considerReplyingOnStore(String arcFileName){
  if (ad.hasReplyInfo(arcFileName)) {
    if (isStoreCompleted(arcFileName)) {
      replyOK(arcFileName,ad.removeReplyInfo(arcFileName));
    }
 else     if (oneBitArchiveHasFailed(arcFileName) && noBitArchiveInStateUploadStarted(arcFileName)) {
      replyNotOK(arcFileName,ad.removeReplyInfo(arcFileName));
    }
  }
}",0.9901356350184956
90113,"/** 
 * Sanity check for data consistency in the construction of the ArcRepository, specifically that the number of ALL_BA, ANY_BA, and THE_BAMON queues are all equal to the number of credentials.
 * @param allBas The topics for bitarchives
 * @param anyBas The queues for biatarchives
 * @param theBamons The queues for biatrchive monitors
 * @throws PermissionDenied if inconsistent data is found
 */
private void checkChannels(ChannelID[] allBas,ChannelID[] anyBas,ChannelID[] theBamons) throws PermissionDenied {
  if (theBamons.length != allBas.length || theBamons.length != anyBas.length) {
    StringBuilder values=new StringBuilder(""String_Node_Str"" + ""String_Node_Str"");
    values.append(""String_Node_Str"");
    values.append(Arrays.toString(allBas));
    values.append(""String_Node_Str"");
    values.append(Arrays.toString(anyBas));
    values.append(""String_Node_Str"");
    values.append(Arrays.toString(theBamons));
    throw new PermissionDenied(values.toString());
  }
}","/** 
 * Sanity check for data consistency in the construction of the ArcRepository, specifically that the number of ALL_BA, ANY_BA, and THE_BAMON queues are all equal to the number of credentials.
 * @param allBas The topics for bitarchives
 * @param anyBas The queues for bitarchives
 * @param theBamons The queues for bitarchive monitors
 * @throws PermissionDenied if inconsistent data is found
 */
private void checkChannels(ChannelID[] allBas,ChannelID[] anyBas,ChannelID[] theBamons) throws PermissionDenied {
  if (theBamons.length != allBas.length || theBamons.length != anyBas.length) {
    StringBuilder values=new StringBuilder(""String_Node_Str"" + ""String_Node_Str"");
    values.append(""String_Node_Str"");
    values.append(Arrays.toString(allBas));
    values.append(""String_Node_Str"");
    values.append(Arrays.toString(anyBas));
    values.append(""String_Node_Str"");
    values.append(Arrays.toString(theBamons));
    throw new PermissionDenied(values.toString());
  }
}",0.9974606399187405
90114,"/** 
 * Called when we receive replies on our checksum batch jobs.
 * @param msg a BatchReplyMessage
 */
synchronized public void onBatchReply(BatchReplyMessage msg){
  ArgumentNotValid.checkNotNull(msg,""String_Node_Str"");
  log.debug(""String_Node_Str"" + msg + ""String_Node_Str"");
  String arcfileName=outstandingChecksumFiles.remove(msg.getReplyOfId());
  if (arcfileName != null) {
    if (!msg.isOk()) {
      log.warn(""String_Node_Str"" + msg.getID() + ""String_Node_Str""+ ""String_Node_Str""+ msg.getErrMsg()+ ""String_Node_Str""+ ""String_Node_Str"");
    }
    String reportedChecksum;
    RemoteFile rf=msg.getResultFile();
    if (rf == null || rf instanceof NullRemoteFile) {
      log.debug(""String_Node_Str"" + msg.getID() + ""String_Node_Str""+ ""String_Node_Str""+ arcfileName+ ""String_Node_Str"");
      reportedChecksum=""String_Node_Str"";
    }
 else {
      File outputFile=new File(FileUtils.getTempDir(),msg.getReplyTo().getName() + ""String_Node_Str"" + arcfileName+ ""String_Node_Str"");
      try {
        rf.copyTo(outputFile);
        reportedChecksum=readChecksum(outputFile,arcfileName);
      }
 catch (      IOFailure e) {
        log.warn(""String_Node_Str"" + ""String_Node_Str"" + arcfileName + ""String_Node_Str"",e);
        reportedChecksum=""String_Node_Str"";
      }
      try {
        FileUtils.removeRecursively(outputFile);
      }
 catch (      IOFailure e) {
        log.warn(""String_Node_Str"" + ""String_Node_Str"" + outputFile + ""String_Node_Str"",e);
      }
      try {
        rf.cleanup();
      }
 catch (      IOFailure e) {
        log.warn(""String_Node_Str"" + ""String_Node_Str"" + rf.getName() + ""String_Node_Str"",e);
      }
    }
    String orgCheckSum=ad.getCheckSum(arcfileName);
    String bitarchive=resolveBitarchiveID(msg.getReplyTo().getName());
    processCheckSum(arcfileName,bitarchive,orgCheckSum,reportedChecksum);
  }
 else {
    log.warn(""String_Node_Str"" + ""String_Node_Str"" + msg.getReplyOfId() + ""String_Node_Str""+ msg.toString()+ ""String_Node_Str""+ outstandingChecksumFiles.keySet().toString());
  }
}","/** 
 * Called when we receive replies on our checksum batch jobs.
 * @param msg a BatchReplyMessage
 */
public synchronized void onBatchReply(BatchReplyMessage msg){
  ArgumentNotValid.checkNotNull(msg,""String_Node_Str"");
  log.debug(""String_Node_Str"" + msg + ""String_Node_Str"");
  String arcfileName=outstandingChecksumFiles.remove(msg.getReplyOfId());
  if (arcfileName != null) {
    if (!msg.isOk()) {
      log.warn(""String_Node_Str"" + msg.getID() + ""String_Node_Str""+ ""String_Node_Str""+ msg.getErrMsg()+ ""String_Node_Str""+ ""String_Node_Str"");
    }
    String reportedChecksum;
    RemoteFile rf=msg.getResultFile();
    if (rf == null || rf instanceof NullRemoteFile) {
      log.debug(""String_Node_Str"" + msg.getID() + ""String_Node_Str""+ ""String_Node_Str""+ arcfileName+ ""String_Node_Str"");
      reportedChecksum=""String_Node_Str"";
    }
 else {
      File outputFile=new File(FileUtils.getTempDir(),msg.getReplyTo().getName() + ""String_Node_Str"" + arcfileName+ ""String_Node_Str"");
      try {
        rf.copyTo(outputFile);
        reportedChecksum=readChecksum(outputFile,arcfileName);
      }
 catch (      IOFailure e) {
        log.warn(""String_Node_Str"" + ""String_Node_Str"" + arcfileName + ""String_Node_Str"",e);
        reportedChecksum=""String_Node_Str"";
      }
      try {
        FileUtils.removeRecursively(outputFile);
      }
 catch (      IOFailure e) {
        log.warn(""String_Node_Str"" + ""String_Node_Str"" + outputFile + ""String_Node_Str"",e);
      }
      try {
        rf.cleanup();
      }
 catch (      IOFailure e) {
        log.warn(""String_Node_Str"" + ""String_Node_Str"" + rf.getName() + ""String_Node_Str"",e);
      }
    }
    String orgCheckSum=ad.getCheckSum(arcfileName);
    String bitarchive=resolveBitarchiveID(msg.getReplyTo().getName());
    processCheckSum(arcfileName,bitarchive,orgCheckSum,reportedChecksum);
  }
 else {
    log.warn(""String_Node_Str"" + ""String_Node_Str"" + msg.getReplyOfId() + ""String_Node_Str""+ msg.toString()+ ""String_Node_Str""+ outstandingChecksumFiles.keySet().toString());
  }
}",0.9965770171149144
90115,"/** 
 * Stores a file in all known Bitarchives. This runs asynchronously, and returns immediately. Sideeffects: 1) The RemoteFile added to List outstandingRemoteFiles 2) TODO: Document other sideeffects.
 * @param rf A remotefile to be stored.
 * @param replyInfo A StoreMessage used to reply with succes or failure.
 * @throws IOFailure If file couldn't be stores.
 */
synchronized public void store(RemoteFile rf,StoreMessage replyInfo) throws IOFailure {
  final String filename=rf.getName();
  log.info(""String_Node_Str"" + filename + ""String_Node_Str"");
  outstandingRemoteFiles.put(filename,rf);
  if (ad.hasEntry(filename)) {
    if (!rf.getChecksum().equals(ad.getCheckSum(filename))) {
      String msg=""String_Node_Str"" + filename + ""String_Node_Str""+ ""String_Node_Str""+ ad.getCheckSum(filename)+ ""String_Node_Str""+ rf.getChecksum();
      log.warn(msg);
      replyNotOK(filename,replyInfo);
      return;
    }
    log.debug(""String_Node_Str"" + filename + ""String_Node_Str""+ ""String_Node_Str""+ isStoreCompleted(filename));
    ad.setReplyInfo(filename,replyInfo);
  }
 else {
    ad.addEntry(filename,replyInfo,rf.getChecksum());
  }
  for (  Map.Entry<String,BitarchiveClient> entry : connectedBitarchives.entrySet()) {
    startUpload(rf,entry.getValue(),entry.getKey());
  }
  considerReplyingOnStore(filename);
}","/** 
 * Stores a file in all known Bitarchives. This runs asynchronously, and returns immediately. Side effects: 1) The RemoteFile added to List outstandingRemoteFiles 2) TODO: Document other side effects.
 * @param rf A remotefile to be stored.
 * @param replyInfo A StoreMessage used to reply with success or failure.
 * @throws IOFailure If file couldn't be stores.
 */
public synchronized void store(RemoteFile rf,StoreMessage replyInfo) throws IOFailure {
  final String filename=rf.getName();
  log.info(""String_Node_Str"" + filename + ""String_Node_Str"");
  outstandingRemoteFiles.put(filename,rf);
  if (ad.hasEntry(filename)) {
    if (!rf.getChecksum().equals(ad.getCheckSum(filename))) {
      String msg=""String_Node_Str"" + filename + ""String_Node_Str""+ ""String_Node_Str""+ ad.getCheckSum(filename)+ ""String_Node_Str""+ rf.getChecksum();
      log.warn(msg);
      replyNotOK(filename,replyInfo);
      return;
    }
    log.debug(""String_Node_Str"" + filename + ""String_Node_Str""+ ""String_Node_Str""+ isStoreCompleted(filename));
    ad.setReplyInfo(filename,replyInfo);
  }
 else {
    ad.addEntry(filename,replyInfo,rf.getChecksum());
  }
  for (  Map.Entry<String,BitarchiveClient> entry : connectedBitarchives.entrySet()) {
    startUpload(rf,entry.getValue(),entry.getKey());
  }
  considerReplyingOnStore(filename);
}",0.9936018065487392
90116,"/** 
 * Initiate uploading of file to a specific bitarchive. The corresponding upload record in admin data is created.
 * @param rf remotefile to upload to bitarchive.
 * @param bitarchiveClient The bitarchive client to upload to.
 * @param bitarchiveName The name of the bitarchive, where RemoteFile is to be stored.
 */
synchronized private void startUpload(RemoteFile rf,BitarchiveClient bitarchiveClient,String bitarchiveName){
  final String filename=rf.getName();
  log.debug(""String_Node_Str"" + filename + ""String_Node_Str""+ bitarchiveName+ ""String_Node_Str"");
  if (!ad.hasState(filename,bitarchiveName)) {
    ad.setState(filename,bitarchiveName,BitArchiveStoreState.UPLOAD_STARTED);
    bitarchiveClient.upload(rf);
  }
 else {
    BitArchiveStoreState storeState=ad.getState(filename,bitarchiveName);
    log.trace(""String_Node_Str"" + storeState);
switch (storeState) {
case UPLOAD_FAILED:
case UPLOAD_STARTED:
case DATA_UPLOADED:
      if (storeState == BitArchiveStoreState.UPLOAD_FAILED) {
        ad.setState(filename,bitarchiveName,BitArchiveStoreState.UPLOAD_STARTED);
      }
    sendChecksumJob(filename,bitarchiveClient);
  break;
case UPLOAD_COMPLETED:
break;
default :
throw new UnknownID(""String_Node_Str"" + storeState + ""String_Node_Str"");
}
}
}","/** 
 * Initiate uploading of file to a specific bitarchive. The corresponding upload record in admin data is created.
 * @param rf remotefile to upload to bitarchive.
 * @param bitarchiveClient The bitarchive client to upload to.
 * @param bitarchiveName The name of the bitarchive, where RemoteFile is to be stored.
 */
private synchronized void startUpload(RemoteFile rf,BitarchiveClient bitarchiveClient,String bitarchiveName){
  final String filename=rf.getName();
  log.debug(""String_Node_Str"" + filename + ""String_Node_Str""+ bitarchiveName+ ""String_Node_Str"");
  if (!ad.hasState(filename,bitarchiveName)) {
    ad.setState(filename,bitarchiveName,BitArchiveStoreState.UPLOAD_STARTED);
    bitarchiveClient.upload(rf);
  }
 else {
    BitArchiveStoreState storeState=ad.getState(filename,bitarchiveName);
    log.trace(""String_Node_Str"" + storeState);
switch (storeState) {
case UPLOAD_FAILED:
case UPLOAD_STARTED:
case DATA_UPLOADED:
      if (storeState == BitArchiveStoreState.UPLOAD_FAILED) {
        ad.setState(filename,bitarchiveName,BitArchiveStoreState.UPLOAD_STARTED);
      }
    sendChecksumJob(filename,bitarchiveClient);
  break;
case UPLOAD_COMPLETED:
break;
default :
throw new UnknownID(""String_Node_Str"" + storeState + ""String_Node_Str"");
}
}
}",0.9936958234830576
90117,"/** 
 * Reply to a store message with status Not Ok.
 * @param arcFileName The file for which we are replying
 * @param msg The message to reply to
 */
synchronized private void replyNotOK(String arcFileName,StoreMessage msg){
  outstandingRemoteFiles.remove(arcFileName);
  clearRetries(arcFileName);
  msg.setNotOk(""String_Node_Str"" + arcFileName);
  log.warn(""String_Node_Str"" + arcFileName + ""String_Node_Str"");
  log.debug(""String_Node_Str"" + msg + ""String_Node_Str"");
  con.reply(msg);
}","/** 
 * Reply to a store message with status Not Ok.
 * @param arcFileName The file for which we are replying
 * @param msg The message to reply to
 */
private synchronized void replyNotOK(String arcFileName,StoreMessage msg){
  outstandingRemoteFiles.remove(arcFileName);
  clearRetries(arcFileName);
  msg.setNotOk(""String_Node_Str"" + arcFileName);
  log.warn(""String_Node_Str"" + arcFileName + ""String_Node_Str"");
  log.debug(""String_Node_Str"" + msg + ""String_Node_Str"");
  con.reply(msg);
}",0.9837728194726166
90118,"/** 
 * Event handler for upload messages reporting the upload result. Checks the success status of the upload and updates admin data accordingly
 * @param msg an UploadMessage
 */
synchronized public void onUpload(UploadMessage msg){
  log.debug(""String_Node_Str"" + msg.toString());
  ArgumentNotValid.checkNotNull(msg,""String_Node_Str"");
  String bitarchiveName=resolveBitarchiveID(msg.getTo().getName());
  if (msg.isOk()) {
    processDataUploaded(msg.getArcfileName(),bitarchiveName);
  }
 else {
    processUploadFailed(msg.getArcfileName(),bitarchiveName);
  }
}","/** 
 * Event handler for upload messages reporting the upload result. Checks the success status of the upload and updates admin data accordingly
 * @param msg an UploadMessage
 */
public synchronized void onUpload(UploadMessage msg){
  ArgumentNotValid.checkNotNull(msg,""String_Node_Str"");
  log.debug(""String_Node_Str"" + msg.toString());
  String bitarchiveName=resolveBitarchiveID(msg.getTo().getName());
  if (msg.isOk()) {
    processDataUploaded(msg.getArcfileName(),bitarchiveName);
  }
 else {
    processUploadFailed(msg.getArcfileName(),bitarchiveName);
  }
}",0.9015817223198594
90119,"/** 
 * Reply to a store message with status Ok.
 * @param arcFileName The file for which we are replying
 * @param msg The message to reply to
 */
synchronized private void replyOK(String arcFileName,StoreMessage msg){
  outstandingRemoteFiles.remove(arcFileName);
  clearRetries(arcFileName);
  log.info(""String_Node_Str"" + arcFileName + ""String_Node_Str"");
  log.debug(""String_Node_Str"" + msg + ""String_Node_Str"");
  con.reply(msg);
}","/** 
 * Reply to a store message with status Ok.
 * @param arcFileName The file for which we are replying
 * @param msg The message to reply to
 */
private synchronized void replyOK(String arcFileName,StoreMessage msg){
  outstandingRemoteFiles.remove(arcFileName);
  clearRetries(arcFileName);
  log.info(""String_Node_Str"" + arcFileName + ""String_Node_Str"");
  log.debug(""String_Node_Str"" + msg + ""String_Node_Str"");
  con.reply(msg);
}",0.9816933638443937
90120,"/** 
 * Connects to the given host, and lists all mbeans matching the query. For each of these mbeans, registers a proxymbean, that on any invocation will connect to the remote host, and return the result of invocing the method on the remote object.
 * @param hostEntry The host to connect to.
 * @throws IOFailure if remote host cannot be connected to.
 */
private synchronized void createProxyMBeansForHost(HostEntry hostEntry){
  Set<ObjectName> remoteObjectNames;
  JMXProxyConnection connection=connectionFactory.getConnection(hostEntry.getName(),hostEntry.getJmxPort(),hostEntry.getRmiPort(),JMX_MONITOR_ROLE_USERNAME,jmxPassword);
  remoteObjectNames=(Set<ObjectName>)connection.query(mBeanQuery);
  for (  ObjectName name : remoteObjectNames) {
    try {
      ProxyMBeanInvocationHandler handler=new ProxyMBeanInvocationHandler(name,hostEntry);
      Class<T> proxyClass=(Class<T>)Proxy.getProxyClass(asInterface.getClassLoader(),new Class[]{asInterface});
      T mbean=proxyClass.getConstructor(InvocationHandler.class).newInstance(handler);
      SingleMBeanObject<T> singleMBeanObject=new SingleMBeanObject<T>(name,mbean,asInterface,mBeanServer);
      singleMBeanObject.register();
    }
 catch (    Exception e) {
      log.warn(""String_Node_Str"",e);
    }
  }
}","/** 
 * Connects to the given host, and lists all mbeans matching the query. For each of these mbeans, registers a proxymbean, that on any invocation will connect to the remote host, and return the result of invoking the method on the remote object.
 * @param hostEntry The host to connect to.
 * @throws IOFailure if remote host cannot be connected to.
 */
private synchronized void createProxyMBeansForHost(HostEntry hostEntry){
  Set<ObjectName> remoteObjectNames;
  JMXProxyConnection connection=connectionFactory.getConnection(hostEntry.getName(),hostEntry.getJmxPort(),hostEntry.getRmiPort(),JMX_MONITOR_ROLE_USERNAME,jmxPassword);
  remoteObjectNames=(Set<ObjectName>)connection.query(mBeanQuery);
  for (  ObjectName name : remoteObjectNames) {
    try {
      ProxyMBeanInvocationHandler handler=new ProxyMBeanInvocationHandler(name,hostEntry);
      Class<T> proxyClass=(Class<T>)Proxy.getProxyClass(asInterface.getClassLoader(),new Class[]{asInterface});
      T mbean=proxyClass.getConstructor(InvocationHandler.class).newInstance(handler);
      SingleMBeanObject<T> singleMBeanObject=new SingleMBeanObject<T>(name,mbean,asInterface,mBeanServer);
      singleMBeanObject.register();
    }
 catch (    Exception e) {
      log.warn(""String_Node_Str"",e);
    }
  }
}",0.999216914643696
90121,"/** 
 * Initialises a connection to a remote bean. Then invokes the method on that bean.
 * @param proxy This proxying object. Ignored.
 * @param method The method invoked. This is called on the remote mbean.
 * @param args The arguments to the method. These are given to theremote mbean.
 * @return Whatever the remote mbean returns.
 * @throws IOFailure On trouble establishing the connection.
 * @throws javax.management.RuntimeMBeanException On exceptions in thembean invokations
 * @throws Throwable What ever the remote mbean has thrown.
 */
public Object invoke(Object proxy,Method method,Object[] args) throws Throwable {
  JMXProxyConnection connection;
  try {
    connection=connectionFactory.getConnection(hostEntry.getName(),hostEntry.getJmxPort(),hostEntry.getRmiPort(),JMX_MONITOR_ROLE_USERNAME,jmxPassword);
  }
 catch (  Exception e) {
    throw new IOFailure(""String_Node_Str"" + hostEntry.getName() + ""String_Node_Str""+ hostEntry.getJmxPort()+ ""String_Node_Str""+ hostEntry.getTime()+ ""String_Node_Str"",e);
  }
  T mBean=connection.createProxy(name,asInterface);
  return method.invoke(mBean,args);
}","/** 
 * Initialises a connection to a remote bean. Then invokes the method on that bean.
 * @param proxy This proxying object. Ignored.
 * @param method The method invoked. This is called on the remote mbean.
 * @param args The arguments to the method. These are given to theremote mbean.
 * @return Whatever the remote mbean returns.
 * @throws IOFailure On trouble establishing the connection.
 * @throws javax.management.RuntimeMBeanException On exceptions in thembean invocations
 * @throws Throwable What ever the remote mbean has thrown.
 */
public Object invoke(Object proxy,Method method,Object[] args) throws Throwable {
  JMXProxyConnection connection;
  try {
    connection=connectionFactory.getConnection(hostEntry.getName(),hostEntry.getJmxPort(),hostEntry.getRmiPort(),JMX_MONITOR_ROLE_USERNAME,jmxPassword);
  }
 catch (  Exception e) {
    throw new IOFailure(""String_Node_Str"" + hostEntry.getName() + ""String_Node_Str""+ hostEntry.getJmxPort()+ ""String_Node_Str""+ hostEntry.getTime()+ ""String_Node_Str"",e);
  }
  T mBean=connection.createProxy(name,asInterface);
  return method.invoke(mBean,args);
}",0.999104744852283
90122,"/** 
 * Writes the name of the arcfile to the OutputStream.
 * @param file an arcfile
 * @param os the OutputStream to which data is to be written
 * @return false If listing of this arcfile fails; otherwise true
 */
public boolean processFile(File file,OutputStream os){
  String result=file.getName() + ""String_Node_Str"";
  ArgumentNotValid.checkNotNull(file,""String_Node_Str"");
  try {
    os.write(result.getBytes());
  }
 catch (  IOException e) {
    log.warn(""String_Node_Str"" + file.getName() + ""String_Node_Str"",e);
    return false;
  }
  return true;
}","/** 
 * Writes the name of the arcfile to the OutputStream.
 * @param file an arcfile
 * @param os the OutputStream to which data is to be written
 * @return false If listing of this arcfile fails; otherwise true
 */
public boolean processFile(File file,OutputStream os){
  ArgumentNotValid.checkNotNull(file,""String_Node_Str"");
  String result=file.getName() + ""String_Node_Str"";
  try {
    os.write(result.getBytes());
  }
 catch (  IOException e) {
    log.warn(""String_Node_Str"" + file.getName() + ""String_Node_Str"",e);
    return false;
  }
  return true;
}",0.8987566607460036
90123,"/** 
 * In this constructor, the server creates an instance of the HarvestController, uploads any arc-files from incomplete harvests. Then it starts listening for new doOneCrawl messages, unless there is no available space. In that case, it sends a notication to the administrator and pauses.
 * @throws PermissionDenied If the serverdir or oldjobsdir can't be created
 * @throws IOFailure If harvestInfoFile contains invalid data
 * @throws UnknownID if the settings file does not specify a valid queuepriority.
 */
private HarvestControllerServer() throws IOFailure {
  log.info(STARTING_MESSAGE);
  File serverDir=new File(Settings.get(HarvesterSettings.HARVEST_CONTROLLER_SERVERDIR));
  ApplicationUtils.dirMustExist(serverDir);
  log.info(""String_Node_Str"" + serverDir + ""String_Node_Str"");
  minSpaceRequired=Settings.getLong(HarvesterSettings.HARVEST_SERVERDIR_MINSPACE);
  if (minSpaceRequired <= 0L) {
    log.warn(""String_Node_Str"" + minSpaceRequired);
    throw new ArgumentNotValid(""String_Node_Str"" + minSpaceRequired);
  }
  log.info(""String_Node_Str"" + minSpaceRequired + ""String_Node_Str"");
  controller=HarvestController.getInstance();
  System.setProperty(HERITRIX_VERSION_PROPERTY,Constants.getHeritrixVersionString());
  System.setProperty(HERITRIX_QUEUE_ASSIGNMENT_POLICY_PROPERTY,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  con=JMSConnectionFactory.getInstance();
  log.debug(""String_Node_Str"");
  processOldJobs();
  JobPriority p=JobPriority.valueOf(Settings.get(HarvesterSettings.HARVEST_CONTROLLER_PRIORITY));
switch (p) {
case HIGHPRIORITY:
    jobChannel=Channels.getAnyHighpriorityHaco();
  break;
case LOWPRIORITY:
jobChannel=Channels.getAnyLowpriorityHaco();
break;
default :
throw new UnknownID(p + ""String_Node_Str"");
}
long availableSpace=FileUtils.getBytesFree(serverDir);
if (availableSpace > minSpaceRequired) {
log.info(""String_Node_Str"" + jobChannel + ""String_Node_Str"");
con.setListener(jobChannel,this);
log.info(STARTED_MESSAGE);
}
 else {
String PAUSED_MESSAGE=""String_Node_Str"" + availableSpace + ""String_Node_Str"";
log.warn(PAUSED_MESSAGE);
NotificationsFactory.getInstance().errorEvent(PAUSED_MESSAGE);
}
}","/** 
 * In this constructor, the server creates an instance of the HarvestController, uploads any arc-files from incomplete harvests. Then it starts listening for new doOneCrawl messages, unless there is no available space. In that case, it sends a notification to the administrator and pauses.
 * @throws PermissionDenied If the serverdir or oldjobsdir can't be created
 * @throws IOFailure If harvestInfoFile contains invalid data
 * @throws UnknownID if the settings file does not specify a valid queuepriority.
 */
private HarvestControllerServer() throws IOFailure {
  log.info(STARTING_MESSAGE);
  File serverDir=new File(Settings.get(HarvesterSettings.HARVEST_CONTROLLER_SERVERDIR));
  ApplicationUtils.dirMustExist(serverDir);
  log.info(""String_Node_Str"" + serverDir + ""String_Node_Str"");
  minSpaceRequired=Settings.getLong(HarvesterSettings.HARVEST_SERVERDIR_MINSPACE);
  if (minSpaceRequired <= 0L) {
    log.warn(""String_Node_Str"" + minSpaceRequired);
    throw new ArgumentNotValid(""String_Node_Str"" + minSpaceRequired);
  }
  log.info(""String_Node_Str"" + minSpaceRequired + ""String_Node_Str"");
  controller=HarvestController.getInstance();
  System.setProperty(HERITRIX_VERSION_PROPERTY,Constants.getHeritrixVersionString());
  System.setProperty(HERITRIX_QUEUE_ASSIGNMENT_POLICY_PROPERTY,""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str""+ ""String_Node_Str"");
  con=JMSConnectionFactory.getInstance();
  log.debug(""String_Node_Str"");
  processOldJobs();
  JobPriority p=JobPriority.valueOf(Settings.get(HarvesterSettings.HARVEST_CONTROLLER_PRIORITY));
switch (p) {
case HIGHPRIORITY:
    jobChannel=Channels.getAnyHighpriorityHaco();
  break;
case LOWPRIORITY:
jobChannel=Channels.getAnyLowpriorityHaco();
break;
default :
throw new UnknownID(p + ""String_Node_Str"");
}
long availableSpace=FileUtils.getBytesFree(serverDir);
if (availableSpace > minSpaceRequired) {
log.info(""String_Node_Str"" + jobChannel + ""String_Node_Str"");
con.setListener(jobChannel,this);
log.info(STARTED_MESSAGE);
}
 else {
String PAUSED_MESSAGE=""String_Node_Str"" + availableSpace + ""String_Node_Str"";
log.warn(PAUSED_MESSAGE);
NotificationsFactory.getInstance().errorEvent(PAUSED_MESSAGE);
}
}",0.9995473064735174
90124,"/** 
 * Adds error messages from an exception to the status message errors.
 * @param csm The message we're setting messages on.
 * @param crawlException The exception that got thrown from further in,possibly as far in as Heritrix.
 * @param errorMessage Description of errors that happened during upload.
 * @param missingHostsReport If true, no hosts report was found.
 * @param failedFiles List of files that failed to upload.
 */
private void setErrorMessages(CrawlStatusMessage csm,Throwable crawlException,String errorMessage,boolean missingHostsReport,int failedFiles){
  String fullError=""String_Node_Str"";
  if (crawlException != null) {
    fullError=crawlException + ""String_Node_Str"";
    csm.setHarvestErrors(crawlException.toString());
    csm.setHarvestErrorDetails(ExceptionUtils.getStackTrace(crawlException));
  }
  if (errorMessage.length() > 0) {
    String shortDesc=""String_Node_Str"";
    if (missingHostsReport) {
      shortDesc=""String_Node_Str"";
    }
    if (failedFiles > 0) {
      if (shortDesc.length() > 0) {
        shortDesc+=""String_Node_Str"";
      }
      shortDesc+=failedFiles + ""String_Node_Str"";
    }
    csm.setUploadErrors(shortDesc);
    csm.setUploadErrorDetails(errorMessage);
  }
  fullError+=errorMessage;
  csm.setNotOk(fullError);
}","/** 
 * Adds error messages from an exception to the status message errors.
 * @param csm The message we're setting messages on.
 * @param crawlException The exception that got thrown from further in,possibly as far in as Heritrix.
 * @param errorMessage Description of errors that happened during upload.
 * @param missingHostsReport If true, no hosts report was found.
 * @param failedFiles List of files that failed to upload.
 */
private void setErrorMessages(CrawlStatusMessage csm,Throwable crawlException,String errorMessage,boolean missingHostsReport,int failedFiles){
  if (crawlException != null) {
    csm.setHarvestErrors(crawlException.toString());
    csm.setHarvestErrorDetails(ExceptionUtils.getStackTrace(crawlException));
  }
  if (errorMessage.length() > 0) {
    String shortDesc=""String_Node_Str"";
    if (missingHostsReport) {
      shortDesc=""String_Node_Str"";
    }
    if (failedFiles > 0) {
      if (shortDesc.length() > 0) {
        shortDesc+=""String_Node_Str"";
      }
      shortDesc+=failedFiles + ""String_Node_Str"";
    }
    csm.setUploadErrors(shortDesc);
    csm.setUploadErrorDetails(errorMessage);
  }
}",0.9414191419141914
90125,"/** 
 * Returns or creates the unique instance of this singleton The server creates an instance of the HarvestController, uploads arc-files from unfinshed harvests, and starts to listen to JMS messages on the incoming jms queues.
 * @return The instance
 * @throws PermissionDenied If the serverdir or oldjobsdir can't be created
 * @throws IOFailure if data from old harvests exist, but contain illegal data
 */
public static synchronized HarvestControllerServer getInstance() throws IOFailure {
  if (instance == null) {
    instance=new HarvestControllerServer();
  }
  return instance;
}","/** 
 * Returns or creates the unique instance of this singleton The server creates an instance of the HarvestController, uploads arc-files from unfinished harvests, and starts to listen to JMS messages on the incoming jms queues.
 * @return The instance
 * @throws PermissionDenied If the serverdir or oldjobsdir can't be created
 * @throws IOFailure if data from old harvests exist, but contain illegal data
 */
public static synchronized HarvestControllerServer getInstance() throws IOFailure {
  if (instance == null) {
    instance=new HarvestControllerServer();
  }
  return instance;
}",0.9991546914623838
90126,"/** 
 * Cleanup method. Resets HarvestSchedulerMonitorServer singleton. Note: this cleanup() methodm is called from HarvestScheduler.cleanup(), therefore it needs to be public
 */
public void cleanup(){
  instance=null;
}","/** 
 * Cleanup method. Resets HarvestSchedulerMonitorServer singleton. Note: this cleanup() method is called from HarvestScheduler.cleanup(), therefore it needs to be public
 */
public void cleanup(){
  instance=null;
}",0.9977324263038548
90127,"/** 
 * Updates the job status from the current status to that specified in message if it legal to do so. Logs a warning if messages arrive out of order.
 * @param cmsg The CrawlStatusMessage received
 * @throws ArgumentNotValid if the current job status is Job.STATUS_NEW
 */
private void processCrawlStatusMessage(CrawlStatusMessage cmsg) throws ArgumentNotValid {
  long jobID=cmsg.getJobID();
  JobStatus new_status=cmsg.getStatusCode();
  Job job=jobDAO.read(new Long(jobID));
  JobStatus old_status=job.getStatus();
  if (old_status == JobStatus.NEW) {
    String msg=""String_Node_Str"" + job;
    log.warn(msg);
  }
switch (new_status) {
case RESUBMITTED:
case SUBMITTED:
case NEW:
    String msg=""String_Node_Str"" + job + ""String_Node_Str""+ new_status;
  log.warn(msg);
throw new ArgumentNotValid(msg);
case STARTED:
if (old_status == JobStatus.SUBMITTED || old_status == JobStatus.NEW) {
if (old_status == JobStatus.NEW) {
  log.warn(""String_Node_Str"" + ""String_Node_Str"" + old_status + ""String_Node_Str""+ new_status+ ""String_Node_Str""+ job.toString());
}
job.setStatus(new_status);
log.debug(job + ""String_Node_Str"");
jobDAO.update(job);
}
 else {
log.warn(""String_Node_Str"" + ""String_Node_Str"" + job.getJobID() + ""String_Node_Str""+ old_status+ ""String_Node_Str""+ new_status+ ""String_Node_Str"");
}
break;
case DONE:
case FAILED:
if (old_status == JobStatus.STARTED || old_status == JobStatus.SUBMITTED || old_status == JobStatus.RESUBMITTED || old_status == JobStatus.NEW) {
if (old_status != JobStatus.STARTED) {
log.warn(""String_Node_Str"" + ""String_Node_Str"" + old_status + ""String_Node_Str""+ new_status+ ""String_Node_Str""+ job.toString());
}
if (new_status == JobStatus.FAILED) {
log.warn(""String_Node_Str"" + jobID + ""String_Node_Str""+ cmsg.getErrMsg());
}
 else {
log.info(""String_Node_Str"" + jobID + ""String_Node_Str"");
}
job.setStatus(new_status);
job.appendHarvestErrors(cmsg.getHarvestErrors());
job.appendHarvestErrorDetails(cmsg.getHarvestErrorDetails());
job.appendUploadErrors(cmsg.getUploadErrors());
job.appendUploadErrorDetails(cmsg.getUploadErrorDetails());
jobDAO.update(job);
}
 else {
String message=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + old_status + ""String_Node_Str""+ new_status+ ""String_Node_Str"";
log.warn(message);
job.setStatus(JobStatus.FAILED);
job.appendHarvestErrors(cmsg.getHarvestErrors());
job.appendHarvestErrors(message);
job.appendHarvestErrorDetails(cmsg.getHarvestErrors());
job.appendHarvestErrorDetails(message);
log.warn(""String_Node_Str"" + jobID + ""String_Node_Str""+ job.getHarvestErrorDetails());
jobDAO.update(job);
}
processCrawlData(job,cmsg.getDomainHarvestReport());
break;
default :
log.warn(""String_Node_Str"" + ""String_Node_Str"" + new_status);
break;
}
}","/** 
 * Updates the job status from the current status to that specified in message if it legal to do so. Logs a warning if messages arrive out of order.
 * @param cmsg The CrawlStatusMessage received
 * @throws ArgumentNotValid if the current job status is Job.STATUS_NEW
 */
private void processCrawlStatusMessage(CrawlStatusMessage cmsg) throws ArgumentNotValid {
  long jobID=cmsg.getJobID();
  JobStatus newStatus=cmsg.getStatusCode();
  Job job=jobDAO.read(new Long(jobID));
  JobStatus oldStatus=job.getStatus();
  if (oldStatus == JobStatus.NEW) {
    String msg=""String_Node_Str"" + job;
    log.warn(msg);
  }
switch (newStatus) {
case RESUBMITTED:
case SUBMITTED:
case NEW:
    String msg=""String_Node_Str"" + job + ""String_Node_Str""+ newStatus;
  log.warn(msg);
throw new ArgumentNotValid(msg);
case STARTED:
if (oldStatus == JobStatus.SUBMITTED || oldStatus == JobStatus.NEW) {
if (oldStatus == JobStatus.NEW) {
  log.warn(""String_Node_Str"" + ""String_Node_Str"" + oldStatus + ""String_Node_Str""+ newStatus+ ""String_Node_Str""+ job.toString());
}
job.setStatus(newStatus);
log.debug(job + ""String_Node_Str"");
jobDAO.update(job);
}
 else {
log.warn(""String_Node_Str"" + ""String_Node_Str"" + job.getJobID() + ""String_Node_Str""+ oldStatus+ ""String_Node_Str""+ newStatus+ ""String_Node_Str"");
}
break;
case DONE:
case FAILED:
if (oldStatus == JobStatus.STARTED || oldStatus == JobStatus.SUBMITTED || oldStatus == JobStatus.RESUBMITTED || oldStatus == JobStatus.NEW) {
if (oldStatus != JobStatus.STARTED) {
log.warn(""String_Node_Str"" + ""String_Node_Str"" + oldStatus + ""String_Node_Str""+ newStatus+ ""String_Node_Str""+ job.toString());
}
if (newStatus == JobStatus.FAILED) {
String errors=""String_Node_Str"" + cmsg.getHarvestErrors() + ""String_Node_Str""+ cmsg.getHarvestErrorDetails()+ ""String_Node_Str""+ cmsg.getUploadErrors()+ ""String_Node_Str""+ cmsg.getUploadErrorDetails();
log.warn(""String_Node_Str"" + jobID + ""String_Node_Str""+ errors);
}
 else {
log.info(""String_Node_Str"" + jobID + ""String_Node_Str"");
}
job.setStatus(newStatus);
job.appendHarvestErrors(cmsg.getHarvestErrors());
job.appendHarvestErrorDetails(cmsg.getHarvestErrorDetails());
job.appendUploadErrors(cmsg.getUploadErrors());
job.appendUploadErrorDetails(cmsg.getUploadErrorDetails());
jobDAO.update(job);
}
 else {
String message=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + oldStatus + ""String_Node_Str""+ newStatus+ ""String_Node_Str"";
log.warn(message);
job.setStatus(JobStatus.FAILED);
job.appendHarvestErrors(cmsg.getHarvestErrors());
job.appendHarvestErrors(message);
job.appendHarvestErrorDetails(cmsg.getHarvestErrors());
job.appendHarvestErrorDetails(message);
log.warn(""String_Node_Str"" + jobID + ""String_Node_Str""+ job.getHarvestErrorDetails());
jobDAO.update(job);
}
processCrawlData(job,cmsg.getDomainHarvestReport());
break;
default :
log.warn(""String_Node_Str"" + ""String_Node_Str"" + newStatus);
break;
}
}",0.9047027506654836
90128,"/** 
 * Tests processing of leftover jobs in the case where some uploads fail.
 */
public void testProcessHarvestInfoFileFails(){
  CrawlStatusMessage crawlStatusMessage=testProcessingOfLeftoverJobs(TestInfo.LEFTOVER_CRAWLDIR_2,TestInfo.FILES_IN_LEFTOVER_JOB_DIR_2.length + 1,TestInfo.FILES_IN_LEFTOVER_JOB_DIR_2[1]);
  assertNotNull(""String_Node_Str"",crawlStatusMessage.getErrMsg());
  assertEquals(""String_Node_Str"",""String_Node_Str"",crawlStatusMessage.getUploadErrors());
  StringAsserts.assertStringMatches(""String_Node_Str"",""String_Node_Str"" + TestInfo.LEFTOVER_JOB_DIR_2_SOME_FILE_PATTERN,crawlStatusMessage.getUploadErrorDetails());
  StringAsserts.assertStringContains(""String_Node_Str"",""String_Node_Str"",crawlStatusMessage.getHarvestErrors());
  StringAsserts.assertStringMatches(""String_Node_Str"",""String_Node_Str"",crawlStatusMessage.getHarvestErrorDetails());
  assertFalse(crawlStatusMessage.isOk());
  String oldjobsdir=Settings.get(HarvesterSettings.HARVEST_CONTROLLER_OLDJOBSDIR);
  FileUtils.removeRecursively(new File(oldjobsdir));
  crawlStatusMessage=testProcessingOfLeftoverJobs(TestInfo.LEFTOVER_CRAWLDIR_3,0,null);
  assertFalse(crawlStatusMessage.isOk());
  assertNotNull(""String_Node_Str"",crawlStatusMessage.getErrMsg());
  assertTrue(""String_Node_Str"",new File(new File(oldjobsdir,TestInfo.LEFTOVER_CRAWLDIR_3.getName()),""String_Node_Str"").exists());
  assertTrue(""String_Node_Str"",new File(new File(oldjobsdir,TestInfo.LEFTOVER_CRAWLDIR_3.getName()),""String_Node_Str"").exists());
}","/** 
 * Tests processing of leftover jobs in the case where some uploads fail.
 */
public void testProcessHarvestInfoFileFails(){
  CrawlStatusMessage crawlStatusMessage=testProcessingOfLeftoverJobs(TestInfo.LEFTOVER_CRAWLDIR_2,TestInfo.FILES_IN_LEFTOVER_JOB_DIR_2.length + 1,TestInfo.FILES_IN_LEFTOVER_JOB_DIR_2[1]);
  assertEquals(""String_Node_Str"",""String_Node_Str"",crawlStatusMessage.getUploadErrors());
  StringAsserts.assertStringMatches(""String_Node_Str"",""String_Node_Str"" + TestInfo.LEFTOVER_JOB_DIR_2_SOME_FILE_PATTERN,crawlStatusMessage.getUploadErrorDetails());
  StringAsserts.assertStringContains(""String_Node_Str"",""String_Node_Str"",crawlStatusMessage.getHarvestErrors());
  StringAsserts.assertStringMatches(""String_Node_Str"",""String_Node_Str"",crawlStatusMessage.getHarvestErrorDetails());
  assertTrue(""String_Node_Str"",crawlStatusMessage.isOk());
  String oldjobsdir=Settings.get(HarvesterSettings.HARVEST_CONTROLLER_OLDJOBSDIR);
  FileUtils.removeRecursively(new File(oldjobsdir));
  crawlStatusMessage=testProcessingOfLeftoverJobs(TestInfo.LEFTOVER_CRAWLDIR_3,0,null);
  assertTrue(""String_Node_Str"",crawlStatusMessage.isOk());
  assertTrue(""String_Node_Str"",new File(new File(oldjobsdir,TestInfo.LEFTOVER_CRAWLDIR_3.getName()),""String_Node_Str"").exists());
  assertTrue(""String_Node_Str"",new File(new File(oldjobsdir,TestInfo.LEFTOVER_CRAWLDIR_3.getName()),""String_Node_Str"").exists());
}",0.9341111873713108
90129,"/** 
 * Creates an instance of a BitarchiveMonitorServer.
 * @throws IOFailure - if an error with the JMSConnection occurs
 */
protected BitarchiveMonitorServer() throws IOFailure {
  con.setListener(Channels.getTheBamon(),this);
  bamon=new BitarchiveMonitor();
  bamon.addObserver(this);
  log.info(""String_Node_Str"" + ""String_Node_Str"" + Channels.getTheBamon() + ""String_Node_Str"");
}","/** 
 * Creates an instance of a BitarchiveMonitorServer.
 * @throws IOFailure - if an error with the JMSConnection occurs
 */
protected BitarchiveMonitorServer() throws IOFailure {
  bamon=new BitarchiveMonitor();
  bamon.addObserver(this);
  con.setListener(Channels.getTheBamon(),this);
  log.info(""String_Node_Str"" + ""String_Node_Str"" + Channels.getTheBamon() + ""String_Node_Str"");
}",0.875968992248062
90130,"/** 
 * Unzip a zipFile into a directory.  This will create subdirectories as needed.
 * @param zipFile The file to unzip
 * @param toDir The directory to create the files under.  This directorywill be created if necessary.  Files in it will be overwritten if the filenames match.
 */
public static void unzip(File zipFile,File toDir){
  ArgumentNotValid.checkNotNull(zipFile,""String_Node_Str"");
  ArgumentNotValid.checkNotNull(toDir,""String_Node_Str"");
  ArgumentNotValid.checkTrue(toDir.getAbsoluteFile().getParentFile().canWrite(),""String_Node_Str"" + toDir + ""String_Node_Str"");
  ArgumentNotValid.checkTrue(zipFile.canRead(),""String_Node_Str"" + zipFile + ""String_Node_Str"");
  try {
    ZipFile unzipper=new ZipFile(zipFile);
    try {
      Enumeration<? extends ZipEntry> entries=unzipper.entries();
      while (entries.hasMoreElements()) {
        ZipEntry ze=entries.nextElement();
        File target=new File(toDir,ze.getName());
        FileUtils.createDir(target.getCanonicalFile().getParentFile());
        InputStream inputStream=unzipper.getInputStream(ze);
        FileUtils.writeStreamToFile(inputStream,target);
        inputStream.close();
      }
    }
  finally {
      unzipper.close();
    }
  }
 catch (  IOException e) {
    throw new IOFailure(""String_Node_Str"" + zipFile + ""String_Node_Str"",e);
  }
}","/** 
 * Unzip a zipFile into a directory.  This will create subdirectories as needed.
 * @param zipFile The file to unzip
 * @param toDir The directory to create the files under.  This directorywill be created if necessary.  Files in it will be overwritten if the filenames match.
 */
public static void unzip(File zipFile,File toDir){
  ArgumentNotValid.checkNotNull(zipFile,""String_Node_Str"");
  ArgumentNotValid.checkNotNull(toDir,""String_Node_Str"");
  ArgumentNotValid.checkTrue(toDir.getAbsoluteFile().getParentFile().canWrite(),""String_Node_Str"" + toDir + ""String_Node_Str"");
  ArgumentNotValid.checkTrue(zipFile.canRead(),""String_Node_Str"" + zipFile + ""String_Node_Str"");
  InputStream inputStream=null;
  ZipFile unzipper=null;
  try {
    try {
      unzipper=new ZipFile(zipFile);
      Enumeration<? extends ZipEntry> entries=unzipper.entries();
      while (entries.hasMoreElements()) {
        ZipEntry ze=entries.nextElement();
        File target=new File(toDir,ze.getName());
        FileUtils.createDir(target.getCanonicalFile().getParentFile());
        if (ze.isDirectory()) {
          target.mkdir();
        }
 else {
          inputStream=unzipper.getInputStream(ze);
          FileUtils.writeStreamToFile(inputStream,target);
          inputStream.close();
        }
      }
    }
  finally {
      if (unzipper != null) {
        unzipper.close();
      }
      if (inputStream != null) {
        inputStream.close();
      }
    }
  }
 catch (  IOException e) {
    throw new IOFailure(""String_Node_Str"" + zipFile + ""String_Node_Str"",e);
  }
}",0.782878840179496
90131,"public void testUnzip() throws IOException {
  File unzipDir=new File(TestInfo.TEMPDIR,""String_Node_Str"");
  assertFalse(""String_Node_Str"",unzipDir.exists());
  ZipUtils.unzip(TestInfo.ZIPPED_DIR,unzipDir);
  assertTrue(""String_Node_Str"",unzipDir.exists());
  Set<String> files=getFileListNonDirectory();
  for (  String s : new ArrayList<String>(files)) {
    if (!s.equals(TestInfo.ZIPPED_DIR.getName())) {
      File unpackedFile=new File(unzipDir,s);
      assertTrue(""String_Node_Str"" + s + ""String_Node_Str"",unpackedFile.exists());
      File originalFile=new File(TestInfo.ZIPDIR,s);
      assertEquals(""String_Node_Str"" + s + ""String_Node_Str"",originalFile.length(),unpackedFile.length());
      assertEquals(""String_Node_Str"",MD5.generateMD5onFile(originalFile),MD5.generateMD5onFile(unpackedFile));
    }
    files.remove(s);
  }
  assertTrue(""String_Node_Str"" + files,files.isEmpty());
  try {
    ZipUtils.unzip(null,unzipDir);
    fail(""String_Node_Str"");
  }
 catch (  ArgumentNotValid e) {
  }
  try {
    ZipUtils.unzip(TestInfo.ZIPPED_DIR,null);
    fail(""String_Node_Str"");
  }
 catch (  ArgumentNotValid e) {
  }
  try {
    ZipUtils.unzip(TestInfo.ZIPPED_DIR,TestInfo.ZIPPED_DIR);
    fail(""String_Node_Str"");
  }
 catch (  PermissionDenied e) {
  }
  try {
    ZipUtils.unzip(unzipDir,unzipDir);
    fail(""String_Node_Str"");
  }
 catch (  IOFailure e) {
  }
  try {
    ZipUtils.unzip(new File(TestInfo.ZIPDIR,""String_Node_Str""),unzipDir);
    fail(""String_Node_Str"");
  }
 catch (  IOFailure e) {
  }
}","public void testUnzip() throws IOException {
  File unzipDir=new File(TestInfo.TEMPDIR,""String_Node_Str"");
  assertFalse(""String_Node_Str"",unzipDir.exists());
  ZipUtils.unzip(TestInfo.ZIPPED_DIR,unzipDir);
  assertTrue(""String_Node_Str"",unzipDir.exists());
  Set<String> files=getFileListNonDirectory();
  for (  String s : new ArrayList<String>(files)) {
    if (!s.equals(TestInfo.ZIPPED_DIR.getName())) {
      File unpackedFile=new File(unzipDir,s);
      assertTrue(""String_Node_Str"" + s + ""String_Node_Str"",unpackedFile.exists());
      File originalFile=new File(TestInfo.ZIPDIR,s);
      assertEquals(""String_Node_Str"" + s + ""String_Node_Str"",originalFile.length(),unpackedFile.length());
      assertEquals(""String_Node_Str"",MD5.generateMD5onFile(originalFile),MD5.generateMD5onFile(unpackedFile));
    }
    files.remove(s);
  }
  assertTrue(""String_Node_Str"" + files,files.isEmpty());
  FileUtils.removeRecursively(unzipDir);
  ZipUtils.unzip(TestInfo.ZIPPED_DIR_WITH_SUBDIRS,unzipDir);
  assertTrue(""String_Node_Str"",new File(unzipDir,""String_Node_Str"").isDirectory());
  assertTrue(""String_Node_Str"",new File(new File(unzipDir,""String_Node_Str""),""String_Node_Str"").isFile());
  assertEquals(""String_Node_Str"",4,new File(new File(unzipDir,""String_Node_Str""),""String_Node_Str"").length());
  assertTrue(""String_Node_Str"",new File(new File(unzipDir,""String_Node_Str""),""String_Node_Str"").isDirectory());
  assertTrue(""String_Node_Str"",new File(new File(new File(unzipDir,""String_Node_Str""),""String_Node_Str""),""String_Node_Str"").isFile());
  assertEquals(""String_Node_Str"",7,new File(new File(new File(unzipDir,""String_Node_Str""),""String_Node_Str""),""String_Node_Str"").length());
  try {
    ZipUtils.unzip(null,unzipDir);
    fail(""String_Node_Str"");
  }
 catch (  ArgumentNotValid e) {
  }
  try {
    ZipUtils.unzip(TestInfo.ZIPPED_DIR,null);
    fail(""String_Node_Str"");
  }
 catch (  ArgumentNotValid e) {
  }
  try {
    ZipUtils.unzip(TestInfo.ZIPPED_DIR,TestInfo.ZIPPED_DIR);
    fail(""String_Node_Str"");
  }
 catch (  PermissionDenied e) {
  }
  try {
    ZipUtils.unzip(unzipDir,unzipDir);
    fail(""String_Node_Str"");
  }
 catch (  IOFailure e) {
  }
  try {
    ZipUtils.unzip(new File(TestInfo.ZIPDIR,""String_Node_Str""),unzipDir);
    fail(""String_Node_Str"");
  }
 catch (  IOFailure e) {
  }
}",0.7295466388744137
90132,"/** 
 * Check if the crawl has ended, either because Heritrix finished of its own, or because we terminated it.
 * @return True if the crawl has ended, either because Heritrix finishedor because we terminated it. Otherwise we return false.
 */
public synchronized boolean crawlIsEnded(){
  if (processHasExited()) {
    return true;
  }
  TabularData jobs=(TabularData)executeHeritrixCommand(COMPLETED_JOBS_COMMAND);
  if (jobs != null && jobs.size() > 0) {
    for (    CompositeData value : (Collection<CompositeData>)jobs.values()) {
      String thisJobID=value.get(JmxUtils.NAME) + ""String_Node_Str"" + value.get(UID_PROPERTY);
      if (thisJobID.equals(jobName)) {
        return true;
      }
    }
  }
  String status=(String)getCrawlJobAttribute(STATUS_ATTRIBUTE);
  return status == null || status.startsWith(FINISHED_STATUS_PREFIX) || status.equals(CrawlJob.STATUS_MISCONFIGURED) || status.equals(CrawlJob.STATUS_DELETED);
}","/** 
 * Check if the crawl has ended, either because Heritrix finished of its own, or because we terminated it.
 * @return True if the crawl has ended, either because Heritrix finishedor because we terminated it. Otherwise we return false.
 */
public synchronized boolean crawlIsEnded(){
  if (processHasExited()) {
    return true;
  }
  TabularData jobs=(TabularData)executeHeritrixCommand(COMPLETED_JOBS_COMMAND);
  if (jobs != null && jobs.size() > 0) {
    for (    CompositeData value : (Collection<CompositeData>)jobs.values()) {
      String thisJobID=value.get(JmxUtils.NAME) + ""String_Node_Str"" + value.get(UID_PROPERTY);
      if (thisJobID.equals(jobName)) {
        return true;
      }
    }
  }
  String status=(String)getCrawlJobAttribute(STATUS_ATTRIBUTE);
  return status == null || status.equals(FINISHED_STATUS) || status.equals(ILLEGAL_STATUS);
}",0.9433962264150944
90133,"/** 
 * @see HeritrixController#isPaused()  
 */
public boolean isPaused(){
  String status=(String)getCrawlJobAttribute(STATUS_ATTRIBUTE);
  return status.equals(CrawlJob.STATUS_PAUSED) || status.equals(CrawlJob.STATUS_WAITING_FOR_PAUSE);
}","/** 
 * @see HeritrixController#isPaused()  
 */
public boolean isPaused(){
  String status=(String)getCrawlJobAttribute(STATUS_ATTRIBUTE);
  log.debug(""String_Node_Str"" + status + ""String_Node_Str"");
  return status.equals(PAUSED_STATUS) || status.equals(PAUSING_STATUS);
}",0.7106796116504854
90134,"/** 
 * Forgiving index generating method, that returns a file with an index of the greatest possible subset of a given id. If the type I for instance is a Set, you may get an index of only a subset. If I is a File, null may be seen as a subset.
 * @see #cache for more information.Please note that you will not know what the actual subset is.
 * @param id The requested index.
 * @return An index over the greatest possible subset.
 */
public File getIndex(I id){
  I response=id;
  I lastResponse=null;
  while (response != null && !response.equals(lastResponse)) {
    if (lastResponse != null) {
      log.info(""String_Node_Str"" + this.getCacheDir().getName() + ""String_Node_Str""+ lastResponse+ ""String_Node_Str""+ response+ ""String_Node_Str"");
    }
    lastResponse=response;
    response=cache(lastResponse);
  }
  File cacheFile=getCacheFile(response);
  log.info(""String_Node_Str"" + cacheFile + ""String_Node_Str""+ response+ ""String_Node_Str""+ id+ ""String_Node_Str"");
  return cacheFile;
}","/** 
 * Forgiving index generating method, that returns a file with an index of the greatest possible subset of a given id. If the type I for instance is a Set, you may get an index of only a subset. If I is a File, null may be seen as a subset.
 * @see #cache for more information.Please note that you will not know what the actual subset is.
 * @param id The requested index.
 * @return An index over the greatest possible subset.
 */
public JobIndexCache.JobIndex<I> getIndex(I id){
  I response=id;
  I lastResponse=null;
  while (response != null && !response.equals(lastResponse)) {
    if (lastResponse != null) {
      log.info(""String_Node_Str"" + this.getCacheDir().getName() + ""String_Node_Str""+ lastResponse+ ""String_Node_Str""+ response+ ""String_Node_Str"");
    }
    lastResponse=response;
    response=cache(lastResponse);
  }
  File cacheFile=getCacheFile(response);
  log.info(""String_Node_Str"" + cacheFile + ""String_Node_Str""+ response+ ""String_Node_Str""+ id+ ""String_Node_Str"");
  return new JobIndexCache.JobIndex(cacheFile,response);
}",0.9678048780487803
90135,"private void testNormalDirResponse(IndexRequestClient client,RequestType t,Set<Long> jobSet) throws IOException {
  mis.tearDown();
  mis=new MockupIndexServer(TestInfo.DUMMY_CACHEDIR);
  mis.setUp();
  mis.resetMsgList();
  mis.setResponseSuccessfull(true);
  Set<Long> jobSet2=new HashSet<Long>();
  jobSet2.addAll(jobSet);
  jobSet2.add(6L);
  List<IndexRequestMessage> sent=mis.getMsgList();
  File result=client.getIndex(jobSet2);
  assertEquals(""String_Node_Str"",1,sent.size());
  IndexRequestMessage msg=sent.get(0);
  assertTrue(""String_Node_Str"",msg.isOk());
  assertEquals(""String_Node_Str"",jobSet2,msg.getRequestedJobs());
  assertEquals(""String_Node_Str"",t,msg.getRequestType());
  assertTrue(""String_Node_Str"",result.isDirectory());
  assertEquals(""String_Node_Str"",FileUtils.readFile(mtf.working(TestInfo.DUMMY_INDEX_FILE)),FileUtils.readFile(new File(result,TestInfo.DUMMY_INDEX_FILE.getName())));
}","private void testNormalDirResponse(IndexRequestClient client,RequestType t,Set<Long> jobSet) throws IOException {
  mis.tearDown();
  mis=new MockupIndexServer(TestInfo.DUMMY_CACHEDIR);
  mis.setUp();
  mis.resetMsgList();
  mis.setResponseSuccessfull(true);
  Set<Long> jobSet2=new HashSet<Long>();
  jobSet2.addAll(jobSet);
  jobSet2.add(6L);
  List<IndexRequestMessage> sent=mis.getMsgList();
  File result=client.getIndex(jobSet2).getIndex();
  assertEquals(""String_Node_Str"",1,sent.size());
  IndexRequestMessage msg=sent.get(0);
  assertTrue(""String_Node_Str"",msg.isOk());
  assertEquals(""String_Node_Str"",jobSet2,msg.getRequestedJobs());
  assertEquals(""String_Node_Str"",t,msg.getRequestType());
  assertTrue(""String_Node_Str"",result.isDirectory());
  assertEquals(""String_Node_Str"",FileUtils.readFile(mtf.working(TestInfo.DUMMY_INDEX_FILE)),FileUtils.readFile(new File(result,TestInfo.DUMMY_INDEX_FILE.getName())));
}",0.9940184883088636
90136,"private void testNormalFileResponse(IndexRequestClient client,RequestType t,Set<Long> jobSet) throws IOException {
  mis.tearDown();
  mis=new MockupIndexServer(TestInfo.DUMMY_CACHEFILE);
  mis.setUp();
  mis.resetMsgList();
  mis.setResponseSuccessfull(true);
  File result=client.getIndex(jobSet);
  List<IndexRequestMessage> sent=mis.getMsgList();
  assertEquals(""String_Node_Str"",1,sent.size());
  IndexRequestMessage msg=sent.get(0);
  assertTrue(""String_Node_Str"",msg.isOk());
  assertEquals(""String_Node_Str"",jobSet,msg.getRequestedJobs());
  assertEquals(""String_Node_Str"",t,msg.getRequestType());
  assertEquals(""String_Node_Str"",FileUtils.readFile(mtf.working(TestInfo.DUMMY_INDEX_FILE)),FileUtils.readFile(result));
}","private void testNormalFileResponse(IndexRequestClient client,RequestType t,Set<Long> jobSet) throws IOException {
  mis.tearDown();
  mis=new MockupIndexServer(TestInfo.DUMMY_CACHEFILE);
  mis.setUp();
  mis.resetMsgList();
  mis.setResponseSuccessfull(true);
  File result=client.getIndex(jobSet).getIndex();
  List<IndexRequestMessage> sent=mis.getMsgList();
  assertEquals(""String_Node_Str"",1,sent.size());
  IndexRequestMessage msg=sent.get(0);
  assertTrue(""String_Node_Str"",msg.isOk());
  assertEquals(""String_Node_Str"",jobSet,msg.getRequestedJobs());
  assertEquals(""String_Node_Str"",t,msg.getRequestType());
  assertEquals(""String_Node_Str"",FileUtils.readFile(mtf.working(TestInfo.DUMMY_INDEX_FILE)),FileUtils.readFile(result));
}",0.992501704158146
90137,"/** 
 * Get an index for the given list of job IDs. The resulting file contains a suitably sorted list. This method should always be safe for asynchronous calling. This method may use a cached version of the file.
 * @param jobIDs Set of job IDs to generate index for.
 * @return A file containing the index. This file must not be modified ordeleted, since it is part of the cache of data.
 */
public File getIndex(Set<Long> jobIDs);","public File getIndex(){
  return index;
}",0.1097046413502109
90138,"/** 
 * Get an index for the given list of job IDs. The resulting file contains a suitably sorted list. This method should always be safe for asynchronous calling. This method may use a cached version of the file.
 * @param jobIDs Set of job IDs to generate index for.
 * @return A file containing the index. This file must not be modified ordeleted, since it is part of the cache of data.
 */
public File getIndex(Set<Long> jobIDs){
  ArgumentNotValid.checkNotNull(jobIDs,""String_Node_Str"");
  File cacheFile=new File(dir,StringUtils.conjoin(""String_Node_Str"",jobIDs) + ""String_Node_Str"" + requestType+ ""String_Node_Str"");
  if (jobIDs.isEmpty()) {
    cacheFile=new File(dir,""String_Node_Str"" + requestType + ""String_Node_Str"");
  }
  if (!cacheFile.exists()) {
    log.warn(""String_Node_Str"" + cacheFile + ""String_Node_Str""+ jobIDs);
  }
  return cacheFile;
}","/** 
 * Get an index for the given list of job IDs. The resulting file contains a suitably sorted list. This method should always be safe for asynchronous calling. This method may use a cached version of the file.
 * @param jobIDs Set of job IDs to generate index for.
 * @return A file containing the index. This file must not be modified ordeleted, since it is part of the cache of data.
 */
public JobIndex<Set<Long>> getIndex(Set<Long> jobIDs){
  ArgumentNotValid.checkNotNull(jobIDs,""String_Node_Str"");
  File cacheFile=new File(dir,StringUtils.conjoin(""String_Node_Str"",jobIDs) + ""String_Node_Str"" + requestType+ ""String_Node_Str"");
  if (jobIDs.isEmpty()) {
    cacheFile=new File(dir,""String_Node_Str"" + requestType + ""String_Node_Str"");
  }
  if (!cacheFile.exists()) {
    log.warn(""String_Node_Str"" + cacheFile + ""String_Node_Str""+ jobIDs);
  }
  return new JobIndex(cacheFile,jobIDs);
}",0.975
90139,"public void testCacheData() throws Exception {
  JobIndexCache cache=new TrivialJobIndexCache(RequestType.DEDUP_CRAWL_LOG);
  assertEquals(""String_Node_Str"",""String_Node_Str"",cache.getIndex(Collections.singleton(1L)).getName());
  TestFileUtils.copyDirectoryNonCVS(new File(TestInfo.WORKING_DIR,""String_Node_Str""),new File(new File(Settings.get(Settings.CACHE_DIR),""String_Node_Str""),""String_Node_Str""));
  Set<Long> jobs=new HashSet<Long>();
  jobs.add(2L);
  jobs.add(3L);
  assertEquals(""String_Node_Str"",""String_Node_Str"",cache.getIndex(jobs).getName());
}","public void testCacheData() throws Exception {
  JobIndexCache cache=new TrivialJobIndexCache(RequestType.DEDUP_CRAWL_LOG);
  assertEquals(""String_Node_Str"",""String_Node_Str"",cache.getIndex(Collections.singleton(1L)).getIndex().getName());
  TestFileUtils.copyDirectoryNonCVS(new File(TestInfo.WORKING_DIR,""String_Node_Str""),new File(new File(Settings.get(Settings.CACHE_DIR),""String_Node_Str""),""String_Node_Str""));
  Set<Long> jobs=new HashSet<Long>();
  jobs.add(2L);
  jobs.add(3L);
  assertEquals(""String_Node_Str"",""String_Node_Str"",cache.getIndex(jobs).getIndex().getName());
}",0.9807355516637478
90140,"public void testBuilder(){
  StringBuilder result=new StringBuilder();
  DeploymentBuilder builder=new JmxHostsDeploymentBuilder(result);
  ItConfigParser itconfigHandler=new ItConfigParser(builder);
  SAXParserFactory factory=SAXParserFactory.newInstance();
  try {
    SAXParser saxParser=factory.newSAXParser();
    saxParser.parse(TestInfo.IT_CONF_FILE,itconfigHandler);
  }
 catch (  Exception e) {
    throw new IOFailure(""String_Node_Str"",e);
  }
  builder.done();
}","public void testBuilder() throws DocumentException {
  StringBuilder result=new StringBuilder();
  DeploymentBuilder builder=new JmxHostsDeploymentBuilder(result);
  ItConfigParser itconfigHandler=new ItConfigParser(builder);
  SAXParserFactory factory=SAXParserFactory.newInstance();
  try {
    SAXParser saxParser=factory.newSAXParser();
    saxParser.parse(TestInfo.IT_CONF_FILE,itconfigHandler);
  }
 catch (  Exception e) {
    throw new IOFailure(""String_Node_Str"",e);
  }
  builder.done();
  Document d=DocumentHelper.parseText(result.toString());
  Document d2=DocumentHelper.parseText(""String_Node_Str"");
  d.normalize();
  d2.normalize();
  assertEquals(""String_Node_Str"" + ""String_Node_Str"",d.asXML(),d2.asXML());
}",0.7883333333333333
90141,"/** 
 * Get an index for deduplication.  This will make a call to the index server, requesting an index for the given IDs.  The files will then be cached locally. If we request index for IDs that don't exist/have problems, we get a smaller set of IDs in our cache files, and next time we ask for the same index, we will call the index server again. This will be handled well, though, because if the ids are still missing, we will get a reply telling us to use the cached smaller index anyway.
 * @param metadataEntries list of metadataEntries top get jobIDs from.
 * @return a directory  containing the index itself
 * @throws IOFailure on errors retrieving the index from the client.TODO: Better forgiving handling of no index available
 */
private File fetchDeduplicateIndex(List<MetadataEntry> metadataEntries){
  List<Long> jobIDsForDuplicateReduction=parseJobIDsForDuplicateReduction(metadataEntries);
  return IndexClientFactory.getDedupCrawllogInstance().getIndex(new HashSet<Long>(jobIDsForDuplicateReduction));
}","/** 
 * Get an index for deduplication.  This will make a call to the index server, requesting an index for the given IDs.  The files will then be cached locally. If we request index for IDs that don't exist/have problems, we get a smaller set of IDs in our cache files, and next time we ask for the same index, we will call the index server again. This will be handled well, though, because if the ids are still missing, we will get a reply telling us to use the cached smaller index anyway.
 * @param metadataEntries list of metadataEntries top get jobIDs from.
 * @return a directory  containing the index itself
 * @throws IOFailure on errors retrieving the index from the client.TODO: Better forgiving handling of no index available
 */
private File fetchDeduplicateIndex(List<MetadataEntry> metadataEntries){
  List<Long> jobIDsForDuplicateReduction=parseJobIDsForDuplicateReduction(metadataEntries);
  return IndexClientFactory.getDedupCrawllogInstance().getIndex(new HashSet<Long>(jobIDsForDuplicateReduction)).getIndex();
}",0.9946419873356064
90142,"/** 
 * Change index to use an index based on a list of jobs. Note: Does not check arguments. This is a task for the mediated classes, ArcArchiveAccess and CDXCache.
 * @param jobSet List of jobs to get an index for.
 * @param label The label this index should be known as
 */
public void changeIndex(Set<Long> jobSet,String label){
  aaa.setIndex(cc.getIndex(jobSet));
  this.jobSet=jobSet;
  this.indexLabel=label;
}","/** 
 * Change index to use an index based on a list of jobs. Note: Does not check arguments. This is a task for the mediated classes, ArcArchiveAccess and CDXCache.
 * @param jobSet List of jobs to get an index for.
 * @param label The label this index should be known as
 */
public void changeIndex(Set<Long> jobSet,String label){
  JobIndexCache.JobIndex<Set<Long>> jobindex=cc.getIndex(jobSet);
  aaa.setIndex(jobindex.getIndex());
  this.availableSet=jobindex.getAvailableJobs();
  this.jobSet=jobSet;
  this.indexLabel=label;
}",0.8370136698212408
90143,"/** 
 * Get a human readable status of the viewer proxy.
 * @return A human readable status string.
 * @param locale The locale used to generate the string
 */
public String getStatus(Locale locale){
  ArgumentNotValid.checkNotNull(locale,""String_Node_Str"");
  StringBuilder status=new StringBuilder();
  if (mur.isRecordingURIs()) {
    status.append(I18N.getString(locale,""String_Node_Str""));
  }
 else {
    status.append(I18N.getString(locale,""String_Node_Str""));
  }
  status.append('\n');
  status.append(I18N.getString(locale,""String_Node_Str"",mur.getRecordedURIs().size()));
  status.append('\n');
  if (jobSet == null) {
    status.append(I18N.getString(locale,""String_Node_Str""));
  }
 else {
    List<Long> jobList=new ArrayList<Long>(jobSet);
    Collections.sort(jobList);
    status.append(I18N.getString(locale,""String_Node_Str"",indexLabel,StringUtils.conjoin(""String_Node_Str"",jobList)));
  }
  return status.toString();
}","/** 
 * Get a human readable status of the viewer proxy.
 * @return A human readable status string.
 * @param locale The locale used to generate the string
 */
public String getStatus(Locale locale){
  ArgumentNotValid.checkNotNull(locale,""String_Node_Str"");
  StringBuilder status=new StringBuilder();
  if (mur.isRecordingURIs()) {
    status.append(I18N.getString(locale,""String_Node_Str""));
  }
 else {
    status.append(I18N.getString(locale,""String_Node_Str""));
  }
  status.append('\n');
  status.append(I18N.getString(locale,""String_Node_Str"",mur.getRecordedURIs().size()));
  status.append('\n');
  if (jobSet == null) {
    status.append(I18N.getString(locale,""String_Node_Str""));
  }
 else {
    List<Long> availableList=new ArrayList<Long>(availableSet);
    Collections.sort(availableList);
    status.append(I18N.getString(locale,""String_Node_Str"",indexLabel,StringUtils.conjoin(""String_Node_Str"",availableList)));
    if (!availableSet.containsAll(jobSet)) {
      Set<Long> missingSet=new HashSet<Long>(jobSet);
      missingSet.removeAll(availableSet);
      List<Long> jobList=new ArrayList<Long>(jobSet);
      Collections.sort(jobList);
      List<Long> missingList=new ArrayList<Long>(missingSet);
      Collections.sort(missingList);
      status.append('\n');
      status.append(I18N.getString(locale,""String_Node_Str"",StringUtils.conjoin(""String_Node_Str"",jobList),StringUtils.conjoin(""String_Node_Str"",availableList),StringUtils.conjoin(""String_Node_Str"",missingList)));
    }
  }
  return status.toString();
}",0.7227162489894907
90144,"/** 
 * Get a job index for the given list of IDs.  The resulting file contains a sorted list of the CDX lines for the jobs in question. This method is safe for asynchronous calling. This method may use a cached version of the file.
 * @param jobIDs List of job IDs to generate index for.
 * @return A file containing the index.
 */
public File getIndex(Set<Long> jobIDs){
  FileUtils.createDir(CACHE_DIR);
  ArgumentNotValid.checkNotNullOrEmpty(jobIDs,""String_Node_Str"");
  File indexFile=getIndexFile(jobIDs);
  File workFile=new File(indexFile.getAbsolutePath() + WORK_SUFFIX);
  workFile.deleteOnExit();
  try {
    if (workFile.createNewFile()) {
      if (indexFile.exists()) {
        return indexFile;
      }
      OutputStream tmpOutput=new FileOutputStream(workFile);
      retrieveIndex(jobIDs,tmpOutput);
      tmpOutput.close();
      ProcessUtils.runProcess(new String[]{""String_Node_Str""},""String_Node_Str"",workFile.getAbsolutePath(),""String_Node_Str"",indexFile.getAbsolutePath());
    }
 else {
      while (workFile.exists()) {
        try {
          Thread.sleep(SLEEP_INTERVAL);
        }
 catch (        InterruptedException e) {
          log.debug(""String_Node_Str"",e);
        }
      }
    }
  }
 catch (  IOException e) {
    throw new IOFailure(""String_Node_Str"",e);
  }
 finally {
    FileUtils.remove(workFile);
  }
  if (!indexFile.exists()) {
    throw new IOFailure(""String_Node_Str"" + jobIDs);
  }
  return indexFile;
}","/** 
 * Get a job index for the given list of IDs.  The resulting file contains a sorted list of the CDX lines for the jobs in question. This method is safe for asynchronous calling. This method may use a cached version of the file.
 * @param jobIDs List of job IDs to generate index for.
 * @return A file containing the index.
 */
public JobIndex<Set<Long>> getIndex(Set<Long> jobIDs){
  FileUtils.createDir(CACHE_DIR);
  ArgumentNotValid.checkNotNullOrEmpty(jobIDs,""String_Node_Str"");
  File indexFile=getIndexFile(jobIDs);
  File workFile=new File(indexFile.getAbsolutePath() + WORK_SUFFIX);
  workFile.deleteOnExit();
  try {
    if (workFile.createNewFile()) {
      if (indexFile.exists()) {
        return new JobIndex(indexFile,jobIDs);
      }
      OutputStream tmpOutput=new FileOutputStream(workFile);
      retrieveIndex(jobIDs,tmpOutput);
      tmpOutput.close();
      ProcessUtils.runProcess(new String[]{""String_Node_Str""},""String_Node_Str"",workFile.getAbsolutePath(),""String_Node_Str"",indexFile.getAbsolutePath());
    }
 else {
      while (workFile.exists()) {
        try {
          Thread.sleep(SLEEP_INTERVAL);
        }
 catch (        InterruptedException e) {
          log.debug(""String_Node_Str"",e);
        }
      }
    }
  }
 catch (  IOException e) {
    throw new IOFailure(""String_Node_Str"",e);
  }
 finally {
    FileUtils.remove(workFile);
  }
  if (!indexFile.exists()) {
    throw new IOFailure(""String_Node_Str"" + jobIDs);
  }
  return new JobIndex(indexFile,jobIDs);
}",0.965912926088424
90145,"/** 
 * Looks up a URI in our lucene index and extracts a key.
 * @param uri A URI to look for.
 * @return The file and offset where that URI can be found, or null if itdoesn't exist.
 * @throws IllegalState If a URL is found with a malformed origin field.
 * @throws IOFailure if no index is set or Lucene gives problems.
 */
private ARCKey luceneLookup(String uri){
  if (luceneSearcher == null) {
    throw new IOFailure(""String_Node_Str"" + uri + ""String_Node_Str"");
  }
  Query query=new ConstantScoreQuery(new RangeFilter(DigestIndexer.FIELD_URL,uri,uri,true,true));
  try {
    Hits hits=luceneSearcher.search(query);
    Document doc=null;
    if (hits != null) {
      log.debug(""String_Node_Str"" + hits.length() + ""String_Node_Str""+ uri);
      for (int i=0; i < hits.length(); i++) {
        doc=hits.doc(i);
        String origin=doc.get(DigestIndexer.FIELD_ORIGIN);
        if (origin == null) {
          log.debug(""String_Node_Str"" + uri + ""String_Node_Str""+ i);
          continue;
        }
        String[] originParts=origin.split(""String_Node_Str"");
        if (originParts.length != 2) {
          throw new IllegalState(""String_Node_Str"" + uri + ""String_Node_Str""+ origin+ ""String_Node_Str"");
        }
        log.debug(""String_Node_Str"" + origin);
        return new ARCKey(originParts[0],Long.parseLong(originParts[1]));
      }
    }
  }
 catch (  IOException e) {
    throw new IOFailure(""String_Node_Str"" + uri + ""String_Node_Str"",e);
  }
  return null;
}","/** 
 * Looks up a URI in our lucene index and extracts a key.
 * @param uri A URI to look for.
 * @return The file and offset where that URI can be found, or null if itdoesn't exist.
 * @throws IllegalState If a URL is found with a malformed origin field.
 * @throws IOFailure if no index is set or Lucene gives problems.
 */
private ARCKey luceneLookup(String uri){
  if (luceneSearcher == null) {
    throw new IOFailure(""String_Node_Str"" + uri + ""String_Node_Str"");
  }
  Query query=new ConstantScoreQuery(new SparseRangeFilter(DigestIndexer.FIELD_URL,uri,uri,true,true));
  try {
    Hits hits=luceneSearcher.search(query);
    Document doc=null;
    if (hits != null) {
      log.debug(""String_Node_Str"" + hits.length() + ""String_Node_Str""+ uri);
      for (int i=0; i < hits.length(); i++) {
        doc=hits.doc(i);
        String origin=doc.get(DigestIndexer.FIELD_ORIGIN);
        if (origin == null) {
          log.debug(""String_Node_Str"" + uri + ""String_Node_Str""+ i);
          continue;
        }
        String[] originParts=origin.split(""String_Node_Str"");
        if (originParts.length != 2) {
          throw new IllegalState(""String_Node_Str"" + uri + ""String_Node_Str""+ origin+ ""String_Node_Str"");
        }
        log.debug(""String_Node_Str"" + origin);
        return new ARCKey(originParts[0],Long.parseLong(originParts[1]));
      }
    }
  }
 catch (  IOException e) {
    throw new IOFailure(""String_Node_Str"" + uri + ""String_Node_Str"",e);
  }
  return null;
}",0.997979797979798
90146,"/** 
 * Generate a map of checksums for these file in the bitarchives.
 * @param filenames The filenames to get the checksums for.
 * @return Map containing the output of checksum jobs from the bitarchives.
 */
private Map<String,Map<Location,List<String>>> getChecksumMaps(Set<String> filenames){
  Map<String,Map<Location,List<String>>> checksummaps=new HashMap<String,Map<Location,List<String>>>();
  for (  Location ba : Location.getKnown()) {
    Map<String,List<String>> checksums=getChecksums(ba,filenames);
    log.debug(""String_Node_Str"" + checksums + ""String_Node_Str""+ ba+ ""String_Node_Str"");
    for (    String filename : filenames) {
      Map<Location,List<String>> locationMap;
      if (checksummaps.containsKey(filename)) {
        locationMap=checksummaps.get(filename);
      }
 else {
        locationMap=new HashMap<Location,List<String>>();
        checksummaps.put(filename,locationMap);
      }
      locationMap.put(ba,checksums.get(filename));
    }
  }
  return checksummaps;
}","/** 
 * Generate a map of checksums for these filenames in the bitarchives.
 * @param filenames The filenames to get the checksums for.
 * @return Map containing the output of checksum jobs from the bitarchives.
 */
private Map<String,Map<Location,List<String>>> getChecksumMaps(Set<String> filenames){
  Map<String,Map<Location,List<String>>> checksummaps=new HashMap<String,Map<Location,List<String>>>();
  for (  Location ba : Location.getKnown()) {
    Map<String,List<String>> checksums=getChecksums(ba,filenames);
    log.debug(""String_Node_Str"" + ba + ""String_Node_Str""+ StringUtils.conjoin(""String_Node_Str"",filenames));
    for (    String filename : filenames) {
      Map<Location,List<String>> locationMap;
      if (checksummaps.containsKey(filename)) {
        locationMap=checksummaps.get(filename);
      }
 else {
        locationMap=new HashMap<Location,List<String>>();
        checksummaps.put(filename,locationMap);
      }
      List<String> checksumsForFileOnBa=checksums.get(filename);
      if (checksumsForFileOnBa == null) {
        checksumsForFileOnBa=new ArrayList<String>();
      }
      locationMap.put(ba,checksumsForFileOnBa);
    }
  }
  return checksummaps;
}",0.878691503861881
90147,"/** 
 * Get the checksum of a list of files in a bitarchive. Note that this method runs a batch job on the bitarchives, and therefore may take a long time, depending on network delays.
 * @param ba       The bitarchive to ask for checksum
 * @param filenames The names of the files to ask for checksums for
 * @return The MD5 checksums of the files, or the empty string if the filewas not in the bitarchive.
 * @see ChecksumJob#parseLine(String)
 */
private Map<String,List<String>> getChecksums(Location ba,Set<String> filenames){
  ChecksumJob checksumJob=new ChecksumJob();
  checksumJob.processOnlyFilesNamed(new ArrayList<String>(filenames));
  String batchResult;
  try {
    PreservationArcRepositoryClient arcrep=ArcRepositoryClientFactory.getPreservationInstance();
    BatchStatus batchStatus=arcrep.batch(checksumJob,ba.getName());
    if (batchStatus.hasResultFile()) {
      ByteArrayOutputStream buf=new ByteArrayOutputStream();
      batchStatus.appendResults(buf);
      try {
        batchResult=buf.toString(""String_Node_Str"");
      }
 catch (      UnsupportedEncodingException e) {
        throw new IOFailure(""String_Node_Str"",e);
      }
    }
 else {
      batchResult=""String_Node_Str"";
    }
  }
 catch (  NetarkivetException e) {
    log.warn(""String_Node_Str"" + ba + ""String_Node_Str"",e);
    return Collections.emptyMap();
  }
  Map<String,List<String>> filesAndChecksums=new HashMap<String,List<String>>();
  if (batchResult.length() > 0) {
    String[] lines=batchResult.split(""String_Node_Str"");
    List<String> checksums=new ArrayList<String>();
    for (    String s : lines) {
      try {
        KeyValuePair<String,String> fileChecksum=ChecksumJob.parseLine(s);
        if (!filenames.contains(fileChecksum.getKey())) {
          log.debug(""String_Node_Str"" + fileChecksum.getKey() + ""String_Node_Str""+ ""String_Node_Str""+ ba+ ""String_Node_Str""+ filenames+ ""String_Node_Str"");
        }
 else {
          checksums.add(fileChecksum.getValue());
        }
      }
 catch (      ArgumentNotValid e) {
        log.warn(""String_Node_Str"" + s + ""String_Node_Str""+ ba+ ""String_Node_Str""+ filenames+ ""String_Node_Str"");
      }
    }
  }
 else {
    log.debug(""String_Node_Str"" + checksumJob);
  }
  return filesAndChecksums;
}","/** 
 * Get the checksum of a list of files in a bitarchive. Note that this method runs a batch job on the bitarchives, and therefore may take a long time, depending on network delays.
 * @param ba       The bitarchive to ask for checksum
 * @param filenames The names of the files to ask for checksums for
 * @return The MD5 checksums of the files, or the empty string if the filewas not in the bitarchive.
 * @see ChecksumJob#parseLine(String)
 */
private Map<String,List<String>> getChecksums(Location ba,Set<String> filenames){
  ChecksumJob checksumJob=new ChecksumJob();
  checksumJob.processOnlyFilesNamed(new ArrayList<String>(filenames));
  String batchResult;
  try {
    PreservationArcRepositoryClient arcrep=ArcRepositoryClientFactory.getPreservationInstance();
    BatchStatus batchStatus=arcrep.batch(checksumJob,ba.getName());
    if (batchStatus.hasResultFile()) {
      ByteArrayOutputStream buf=new ByteArrayOutputStream();
      batchStatus.appendResults(buf);
      try {
        batchResult=buf.toString(""String_Node_Str"");
      }
 catch (      UnsupportedEncodingException e) {
        throw new IOFailure(""String_Node_Str"",e);
      }
    }
 else {
      batchResult=""String_Node_Str"";
    }
  }
 catch (  NetarkivetException e) {
    log.warn(""String_Node_Str"" + ba + ""String_Node_Str"",e);
    return Collections.emptyMap();
  }
  Map<String,List<String>> filesAndChecksums=new HashMap<String,List<String>>();
  if (batchResult.length() > 0) {
    String[] lines=batchResult.split(""String_Node_Str"");
    for (    String s : lines) {
      try {
        KeyValuePair<String,String> fileChecksum=ChecksumJob.parseLine(s);
        final String filename=fileChecksum.getKey();
        final String checksum=fileChecksum.getValue();
        if (!filenames.contains(filename)) {
          log.debug(""String_Node_Str"" + filename + ""String_Node_Str""+ ""String_Node_Str""+ ba+ ""String_Node_Str""+ filenames+ ""String_Node_Str"");
        }
 else {
          List<String> checksums;
          if (filesAndChecksums.containsKey(filename)) {
            checksums=filesAndChecksums.get(filename);
          }
 else {
            checksums=new ArrayList<String>();
            filesAndChecksums.put(filename,checksums);
          }
          checksums.add(checksum);
        }
      }
 catch (      ArgumentNotValid e) {
        log.warn(""String_Node_Str"" + s + ""String_Node_Str""+ ba+ ""String_Node_Str""+ filenames+ ""String_Node_Str"");
      }
    }
  }
 else {
    log.debug(""String_Node_Str"" + checksumJob);
  }
  return filesAndChecksums;
}",0.7751196172248804
90148,"/** 
 * Retrieve the preservation status for the files with the given filenames.  This will ask for a fresh checksum from the bitarchives and admin data.
 * @param filenames List of filenames
 * @return a map the preservation status for the files with a givenfilename. The preservationstate is null, if the file named does not exist in admin data.
 * @throws ArgumentNotValid if argument is null
 */
public Map<String,FilePreservationState> getFilePreservationStateMap(String... filenames){
  ArgumentNotValid.checkNotNull(filenames,""String_Node_Str"");
  admin.synchronize();
  Map<String,FilePreservationState> filepreservationStates=new HashMap<String,FilePreservationState>();
  Map<String,ArcRepositoryEntry> adminInfo=new HashMap<String,ArcRepositoryEntry>();
  Set<String> missingInAdmindata=new HashSet<String>();
  for (  String filename : filenames) {
    ArcRepositoryEntry ae=admin.getEntry(filename);
    if (ae != null) {
      adminInfo.put(filename,ae);
    }
 else {
      missingInAdmindata.add(filename);
    }
  }
  for (  String missing : missingInAdmindata) {
    filepreservationStates.put(missing,null);
  }
  if (missingInAdmindata.size() > 0) {
    log.warn(""String_Node_Str"" + missingInAdmindata.size() + ""String_Node_Str""+ StringUtils.conjoin(""String_Node_Str"",missingInAdmindata));
  }
  Map<String,Map<Location,List<String>>> checksumMaps=getChecksumMaps(adminInfo.keySet());
  for (  String filename : adminInfo.keySet()) {
    filepreservationStates.put(filename,new FilePreservationState(filename,adminInfo.get(filename),checksumMaps.get(filename)));
  }
  return filepreservationStates;
}","/** 
 * Retrieve the preservation status for the files with the given filenames.  This will ask for a fresh checksum from the bitarchives and admin data.
 * @param filenames List of filenames
 * @return a map of the preservation status for the given files.The preservationstate is null, if the file named does not exist in admin data.
 * @throws ArgumentNotValid if argument is null
 */
public Map<String,FilePreservationState> getFilePreservationStateMap(String... filenames){
  ArgumentNotValid.checkNotNull(filenames,""String_Node_Str"");
  admin.synchronize();
  Map<String,ArcRepositoryEntry> adminInfo=new HashMap<String,ArcRepositoryEntry>();
  Set<String> missingInAdmindata=new HashSet<String>();
  for (  String filename : filenames) {
    ArcRepositoryEntry ae=admin.getEntry(filename);
    if (ae != null) {
      adminInfo.put(filename,ae);
    }
 else {
      missingInAdmindata.add(filename);
    }
  }
  Map<String,FilePreservationState> filepreservationStates=new HashMap<String,FilePreservationState>();
  for (  String missing : missingInAdmindata) {
    filepreservationStates.put(missing,null);
  }
  if (missingInAdmindata.size() > 0) {
    log.warn(""String_Node_Str"" + missingInAdmindata.size() + ""String_Node_Str""+ StringUtils.conjoin(""String_Node_Str"",missingInAdmindata));
  }
  Map<String,Map<Location,List<String>>> checksumMaps=getChecksumMaps(adminInfo.keySet());
  for (  String filename : adminInfo.keySet()) {
    filepreservationStates.put(filename,new FilePreservationState(filename,adminInfo.get(filename),checksumMaps.get(filename)));
  }
  return filepreservationStates;
}",0.7445029420873336
90149,"/** 
 * Create new instance of the preservation status for a file.  Note that this involves calls to both bitarchives, and so should not be lightly undertaken.
 * @param filename The filename to get status for
 * @param admindata The admin data for the file
 * @param checksumMap The map with the checksums for this file in all bitarchives
 * @throws ArgumentNotValid if filename is null or empty string, or if admindata is null.
 */
FilePreservationState(String filename,ArcRepositoryEntry admindata,Map<Location,List<String>> checksumMap){
  ArgumentNotValid.checkNotNullOrEmpty(filename,""String_Node_Str"");
  ArgumentNotValid.checkNotNull(admindata,""String_Node_Str"");
  this.filename=filename;
  adminStatus=admindata;
  bitarchive2checksum=checksumMap;
}","/** 
 * Create new instance of the preservation status for a file.
 * @param filename The filename to get status for
 * @param admindata The admin data for the file
 * @param checksumMap The map with the checksums for this file in all bitarchives
 * @throws ArgumentNotValid if filename is null or empty string, or if admindata is null.
 */
FilePreservationState(String filename,ArcRepositoryEntry admindata,Map<Location,List<String>> checksumMap){
  ArgumentNotValid.checkNotNullOrEmpty(filename,""String_Node_Str"");
  ArgumentNotValid.checkNotNull(admindata,""String_Node_Str"");
  this.filename=filename;
  adminStatus=admindata;
  bitarchive2checksum=checksumMap;
}",0.9347368421052632
90150,"public void testGetBitarchiveChecksum() throws Exception {
  if (!TestUtils.runningAs(""String_Node_Str"")) {
    return;
  }
  AdminData.getUpdateableInstance().addEntry(""String_Node_Str"",null,""String_Node_Str"");
  AdminData.getUpdateableInstance().addEntry(""String_Node_Str"",null,""String_Node_Str"");
  final Map<Location,String> results=new HashMap<Location,String>();
  MockupArcRepositoryClient.instance=new MockupArcRepositoryClient(){
    public BatchStatus batch(    FileBatchJob job,    String locationName){
      if (job.getClass().equals(ChecksumJob.class)) {
        if (results.containsKey(Location.get(locationName))) {
          return new BatchStatus(""String_Node_Str"",Collections.<File>emptyList(),1,new StringRemoteFile(results.get(Location.get(locationName))));
        }
 else {
          return new BatchStatus(""String_Node_Str"",Collections.<File>emptyList(),0,null);
        }
      }
 else {
        return super.batch(job,locationName);
      }
    }
  }
;
  results.put(SB,""String_Node_Str"");
  results.put(KB,""String_Node_Str"");
  FilePreservationState fps=FileBasedActiveBitPreservation.getInstance().getFilePreservationState(""String_Node_Str"");
  assertFalse(""String_Node_Str"",fps.getBitarchiveChecksum(SB) == null);
  assertEquals(""String_Node_Str"",1,fps.getBitarchiveChecksum(SB).size());
  assertEquals(""String_Node_Str"",""String_Node_Str"",fps.getBitarchiveChecksum(SB).get(0));
  assertFalse(""String_Node_Str"",fps.getBitarchiveChecksum(KB) == null);
  assertEquals(""String_Node_Str"",1,fps.getBitarchiveChecksum(KB).size());
  assertEquals(""String_Node_Str"",""String_Node_Str"",fps.getBitarchiveChecksum(KB).get(0));
  results.clear();
  results.put(SB,""String_Node_Str"");
  fps=FileBasedActiveBitPreservation.getInstance().getFilePreservationState(""String_Node_Str"");
  assertEquals(""String_Node_Str"",0,fps.getBitarchiveChecksum(SB).size());
  assertEquals(""String_Node_Str"",0,fps.getBitarchiveChecksum(KB).size());
  LogUtils.flushLogs(getClass().getName());
  FileAsserts.assertFileNotContains(""String_Node_Str"",TestInfo.LOG_FILE,""String_Node_Str"");
  FileAsserts.assertFileNotContains(""String_Node_Str"",TestInfo.LOG_FILE,""String_Node_Str"");
  results.clear();
  results.put(SB,""String_Node_Str"");
  results.put(KB,""String_Node_Str"");
  fps=FileBasedActiveBitPreservation.getInstance().getFilePreservationState(""String_Node_Str"");
  assertEquals(""String_Node_Str"",0,fps.getBitarchiveChecksum(SB).size());
  assertEquals(""String_Node_Str"",0,fps.getBitarchiveChecksum(KB).size());
  LogUtils.flushLogs(getClass().getName());
  FileAsserts.assertFileContains(""String_Node_Str"",""String_Node_Str"",TestInfo.LOG_FILE);
  FileAsserts.assertFileContains(""String_Node_Str"",""String_Node_Str"",TestInfo.LOG_FILE);
  results.clear();
  results.put(SB,""String_Node_Str"");
  results.put(KB,""String_Node_Str"");
  fps=FileBasedActiveBitPreservation.getInstance().getFilePreservationState(""String_Node_Str"");
  assertEquals(""String_Node_Str"",2,fps.getBitarchiveChecksum(SB).size());
  assertEquals(""String_Node_Str"",3,fps.getBitarchiveChecksum(KB).size());
  LogUtils.flushLogs(getClass().getName());
  FileAsserts.assertFileContains(""String_Node_Str"",""String_Node_Str"",TestInfo.LOG_FILE);
  FileAsserts.assertFileContains(""String_Node_Str"",""String_Node_Str"",TestInfo.LOG_FILE);
}","public void testGetBitarchiveChecksum() throws Exception {
  if (!TestUtils.runningAs(""String_Node_Str"")) {
    return;
  }
  AdminData.getUpdateableInstance().addEntry(""String_Node_Str"",null,""String_Node_Str"");
  AdminData.getUpdateableInstance().addEntry(""String_Node_Str"",null,""String_Node_Str"");
  final Map<Location,String> results=new HashMap<Location,String>();
  MockupArcRepositoryClient.instance=new MockupArcRepositoryClient(){
    public BatchStatus batch(    FileBatchJob job,    String locationName){
      if (job.getClass().equals(ChecksumJob.class)) {
        if (results.containsKey(Location.get(locationName))) {
          return new BatchStatus(""String_Node_Str"",Collections.<File>emptyList(),1,new StringRemoteFile(results.get(Location.get(locationName))));
        }
 else {
          return new BatchStatus(""String_Node_Str"",Collections.<File>emptyList(),0,null);
        }
      }
 else {
        return super.batch(job,locationName);
      }
    }
  }
;
  results.put(SB,""String_Node_Str"");
  results.put(KB,""String_Node_Str"");
  FilePreservationState fps=FileBasedActiveBitPreservation.getInstance().getFilePreservationState(""String_Node_Str"");
  assertFalse(""String_Node_Str"",fps.getBitarchiveChecksum(SB) == null);
  assertEquals(""String_Node_Str"",1,fps.getBitarchiveChecksum(SB).size());
  assertEquals(""String_Node_Str"",""String_Node_Str"",fps.getBitarchiveChecksum(SB).get(0));
  assertFalse(""String_Node_Str"",fps.getBitarchiveChecksum(KB) == null);
  assertEquals(""String_Node_Str"",1,fps.getBitarchiveChecksum(KB).size());
  assertEquals(""String_Node_Str"",""String_Node_Str"",fps.getBitarchiveChecksum(KB).get(0));
  results.clear();
  results.put(SB,""String_Node_Str"");
  fps=FileBasedActiveBitPreservation.getInstance().getFilePreservationState(""String_Node_Str"");
  assertFalse(""String_Node_Str"",fps.getBitarchiveChecksum(SB) == null);
  assertEquals(""String_Node_Str"",0,fps.getBitarchiveChecksum(SB).size());
  assertEquals(""String_Node_Str"",0,fps.getBitarchiveChecksum(KB).size());
  LogUtils.flushLogs(getClass().getName());
  FileAsserts.assertFileNotContains(""String_Node_Str"",TestInfo.LOG_FILE,""String_Node_Str"");
  FileAsserts.assertFileNotContains(""String_Node_Str"",TestInfo.LOG_FILE,""String_Node_Str"");
  results.clear();
  results.put(SB,""String_Node_Str"");
  results.put(KB,""String_Node_Str"");
  fps=FileBasedActiveBitPreservation.getInstance().getFilePreservationState(""String_Node_Str"");
  assertEquals(""String_Node_Str"",0,fps.getBitarchiveChecksum(SB).size());
  assertEquals(""String_Node_Str"",0,fps.getBitarchiveChecksum(KB).size());
  LogUtils.flushLogs(getClass().getName());
  FileAsserts.assertFileContains(""String_Node_Str"",""String_Node_Str"",TestInfo.LOG_FILE);
  FileAsserts.assertFileContains(""String_Node_Str"",""String_Node_Str"",TestInfo.LOG_FILE);
  results.clear();
  results.put(SB,""String_Node_Str"");
  results.put(KB,""String_Node_Str"");
  fps=FileBasedActiveBitPreservation.getInstance().getFilePreservationState(""String_Node_Str"");
  assertEquals(""String_Node_Str"",2,fps.getBitarchiveChecksum(SB).size());
  assertEquals(""String_Node_Str"",3,fps.getBitarchiveChecksum(KB).size());
  LogUtils.flushLogs(getClass().getName());
  FileAsserts.assertFileContains(""String_Node_Str"",""String_Node_Str"",TestInfo.LOG_FILE);
  FileAsserts.assertFileContains(""String_Node_Str"",""String_Node_Str"",TestInfo.LOG_FILE);
}",0.989176187612748
90151,"/** 
 * Test that we can call onMessage with the expected sequence of messages for a successful crawl job.
 */
public void testOnMessageGoodJob(){
  JMSConnectionTestMQ con=(JMSConnectionTestMQ)JMSConnectionFactory.getInstance();
  Job j1=dk.netarkivet.harvester.scheduler.TestInfo.getJob();
  the_dao.create(j1);
  j1.setStatus(JobStatus.NEW);
  the_dao.update(j1);
  HarvestSchedulerMonitorServer hsms=HarvestSchedulerMonitorServer.getInstance();
  long j1ID=j1.getJobID().longValue();
  j1.setStatus(JobStatus.SUBMITTED);
  the_dao.update(j1);
  CrawlStatusMessage csm_start=new CrawlStatusMessage(j1ID,JobStatus.STARTED);
  hsms.onMessage(con.getObjectMessage(csm_start));
  DomainHarvestReport hhr=new HeritrixDomainHarvestReport(CRAWL_REPORT,DEFAULT_STOPREASON);
  CrawlStatusMessage csm_done=new CrawlStatusMessage(j1ID,JobStatus.DONE,hhr);
  hsms.onMessage(con.getObjectMessage(csm_done));
  j1=the_dao.read(new Long(j1ID));
  assertEquals(""String_Node_Str"",JobStatus.DONE,j1.getStatus());
  Domain nk_domain=DomainDAO.getInstance().read(""String_Node_Str"");
  Iterator hist=nk_domain.getHistory().getHarvestInfo();
  assertTrue(""String_Node_Str"",hist.hasNext());
  HarvestInfo dh=(HarvestInfo)hist.next();
  assertEquals(""String_Node_Str"",22,dh.getCountObjectRetrieved());
  assertEquals(""String_Node_Str"",270,dh.getSizeDataRetrieved());
  assertFalse(""String_Node_Str"",hist.hasNext());
}","/** 
 * Test that we can call onMessage with the expected sequence of messages for a successful crawl job.
 */
public void testOnMessageGoodJob(){
  JMSConnectionTestMQ con=(JMSConnectionTestMQ)JMSConnectionFactory.getInstance();
  Job j1=dk.netarkivet.harvester.scheduler.TestInfo.getJob();
  the_dao.create(j1);
  j1.setStatus(JobStatus.NEW);
  the_dao.update(j1);
  HarvestSchedulerMonitorServer hsms=HarvestSchedulerMonitorServer.getInstance();
  long j1ID=j1.getJobID().longValue();
  j1.setStatus(JobStatus.SUBMITTED);
  the_dao.update(j1);
  CrawlStatusMessage csm_start=new CrawlStatusMessage(j1ID,JobStatus.STARTED);
  hsms.onMessage(con.getObjectMessage(csm_start));
  DomainHarvestReport hhr=new HeritrixDomainHarvestReport(CRAWL_REPORT,DEFAULT_STOPREASON);
  CrawlStatusMessage csm_done=new CrawlStatusMessage(j1ID,JobStatus.DONE,hhr);
  hsms.onMessage(con.getObjectMessage(csm_done));
  j1=the_dao.read(new Long(j1ID));
  assertEquals(""String_Node_Str"",JobStatus.DONE,j1.getStatus());
  Domain nk_domain=DomainDAO.getInstance().read(""String_Node_Str"");
  Iterator<HarvestInfo> hist=nk_domain.getHistory().getHarvestInfo();
  assertTrue(""String_Node_Str"",hist.hasNext());
  HarvestInfo dh=(HarvestInfo)hist.next();
  assertEquals(""String_Node_Str"",22,dh.getCountObjectRetrieved());
  assertEquals(""String_Node_Str"",270,dh.getSizeDataRetrieved());
  assertFalse(""String_Node_Str"",hist.hasNext());
}",0.9953654188948308
90152,"/** 
 * If DONE arrives after FAILED, the job should be marked FAILED.
 */
public void testDoneAfterFailed(){
  JMSConnectionTestMQ con=(JMSConnectionTestMQ)JMSConnectionFactory.getInstance();
  Job j1=TestInfo.getJob();
  the_dao.create(j1);
  j1.setStatus(JobStatus.NEW);
  the_dao.update(j1);
  HarvestSchedulerMonitorServer hsms=HarvestSchedulerMonitorServer.getInstance();
  long j1ID=j1.getJobID().longValue();
  j1.setStatus(JobStatus.SUBMITTED);
  the_dao.update(j1);
  CrawlStatusMessage csm_start=new CrawlStatusMessage(j1ID,JobStatus.STARTED);
  hsms.onMessage(con.getObjectMessage(csm_start));
  CrawlStatusMessage csm_failed=new CrawlStatusMessage(j1ID,JobStatus.FAILED,null);
  csm_failed.setNotOk(""String_Node_Str"");
  hsms.onMessage(con.getObjectMessage(csm_failed));
  DomainHarvestReport hhr=new HeritrixDomainHarvestReport(CRAWL_REPORT,DEFAULT_STOPREASON);
  CrawlStatusMessage csm_done=new CrawlStatusMessage(j1ID,JobStatus.DONE,hhr);
  hsms.onMessage(con.getObjectMessage(csm_done));
  j1=the_dao.read(new Long(j1ID));
  assertEquals(""String_Node_Str"",JobStatus.FAILED,j1.getStatus());
  Domain nk_domain=DomainDAO.getInstance().read(""String_Node_Str"");
  Iterator hist=nk_domain.getHistory().getHarvestInfo();
  assertTrue(""String_Node_Str"",hist.hasNext());
  HarvestInfo dh=(HarvestInfo)hist.next();
  assertFalse(""String_Node_Str"",hist.hasNext());
  assertEquals(""String_Node_Str"",22,dh.getCountObjectRetrieved());
  assertEquals(""String_Node_Str"",270,dh.getSizeDataRetrieved());
}","/** 
 * If DONE arrives after FAILED, the job should be marked FAILED.
 */
public void testDoneAfterFailed(){
  JMSConnectionTestMQ con=(JMSConnectionTestMQ)JMSConnectionFactory.getInstance();
  Job j1=TestInfo.getJob();
  the_dao.create(j1);
  j1.setStatus(JobStatus.NEW);
  the_dao.update(j1);
  HarvestSchedulerMonitorServer hsms=HarvestSchedulerMonitorServer.getInstance();
  long j1ID=j1.getJobID().longValue();
  j1.setStatus(JobStatus.SUBMITTED);
  the_dao.update(j1);
  CrawlStatusMessage csm_start=new CrawlStatusMessage(j1ID,JobStatus.STARTED);
  hsms.onMessage(con.getObjectMessage(csm_start));
  CrawlStatusMessage csm_failed=new CrawlStatusMessage(j1ID,JobStatus.FAILED,null);
  csm_failed.setNotOk(""String_Node_Str"");
  hsms.onMessage(con.getObjectMessage(csm_failed));
  DomainHarvestReport hhr=new HeritrixDomainHarvestReport(CRAWL_REPORT,DEFAULT_STOPREASON);
  CrawlStatusMessage csm_done=new CrawlStatusMessage(j1ID,JobStatus.DONE,hhr);
  hsms.onMessage(con.getObjectMessage(csm_done));
  j1=the_dao.read(new Long(j1ID));
  assertEquals(""String_Node_Str"",JobStatus.FAILED,j1.getStatus());
  Domain nk_domain=DomainDAO.getInstance().read(""String_Node_Str"");
  Iterator<HarvestInfo> hist=nk_domain.getHistory().getHarvestInfo();
  assertTrue(""String_Node_Str"",hist.hasNext());
  HarvestInfo dh=(HarvestInfo)hist.next();
  assertFalse(""String_Node_Str"",hist.hasNext());
  assertEquals(""String_Node_Str"",22,dh.getCountObjectRetrieved());
  assertEquals(""String_Node_Str"",270,dh.getSizeDataRetrieved());
}",0.9956996361230566
90153,"/** 
 * Tests what happens if a FAILED message arrives with a crawl report. The behavioour should be identical to the case with a DONE message.
 */
public void testOnMessageFailedJobWithReport(){
  JMSConnectionTestMQ con=(JMSConnectionTestMQ)JMSConnectionFactory.getInstance();
  Job j1=TestInfo.getJob();
  JobDAO.getInstance().create(j1);
  j1.setStatus(JobStatus.NEW);
  the_dao.update(j1);
  HarvestSchedulerMonitorServer hsms=HarvestSchedulerMonitorServer.getInstance();
  long j1ID=j1.getJobID().longValue();
  j1.setStatus(JobStatus.SUBMITTED);
  the_dao.update(j1);
  CrawlStatusMessage csm_start=new CrawlStatusMessage(j1ID,JobStatus.STARTED);
  hsms.onMessage(con.getObjectMessage(csm_start));
  DomainHarvestReport hhr=new HeritrixDomainHarvestReport(CRAWL_REPORT,DEFAULT_STOPREASON);
  CrawlStatusMessage csm_failed=new CrawlStatusMessage(j1ID,JobStatus.FAILED,hhr);
  csm_failed.setNotOk(""String_Node_Str"");
  hsms.onMessage(con.getObjectMessage(csm_failed));
  j1=the_dao.read(new Long(j1ID));
  assertEquals(""String_Node_Str"",JobStatus.FAILED,j1.getStatus());
  Domain nk_domain=DomainDAO.getInstance().read(""String_Node_Str"");
  Iterator hist=nk_domain.getHistory().getHarvestInfo();
  assertTrue(""String_Node_Str"",hist.hasNext());
  HarvestInfo dh=(HarvestInfo)hist.next();
  assertEquals(""String_Node_Str"",22,dh.getCountObjectRetrieved());
  assertFalse(""String_Node_Str"",hist.hasNext());
}","/** 
 * Tests what happens if a FAILED message arrives with a crawl report. The behavior should be identical to the case with a DONE message.
 */
public void testOnMessageFailedJobWithReport(){
  JMSConnectionTestMQ con=(JMSConnectionTestMQ)JMSConnectionFactory.getInstance();
  Job j1=TestInfo.getJob();
  JobDAO.getInstance().create(j1);
  j1.setStatus(JobStatus.NEW);
  the_dao.update(j1);
  HarvestSchedulerMonitorServer hsms=HarvestSchedulerMonitorServer.getInstance();
  long j1ID=j1.getJobID().longValue();
  j1.setStatus(JobStatus.SUBMITTED);
  the_dao.update(j1);
  CrawlStatusMessage csm_start=new CrawlStatusMessage(j1ID,JobStatus.STARTED);
  hsms.onMessage(con.getObjectMessage(csm_start));
  DomainHarvestReport hhr=new HeritrixDomainHarvestReport(CRAWL_REPORT,DEFAULT_STOPREASON);
  CrawlStatusMessage csm_failed=new CrawlStatusMessage(j1ID,JobStatus.FAILED,hhr);
  csm_failed.setNotOk(""String_Node_Str"");
  hsms.onMessage(con.getObjectMessage(csm_failed));
  j1=the_dao.read(new Long(j1ID));
  assertEquals(""String_Node_Str"",JobStatus.FAILED,j1.getStatus());
  Domain nk_domain=DomainDAO.getInstance().read(""String_Node_Str"");
  Iterator<HarvestInfo> hist=nk_domain.getHistory().getHarvestInfo();
  assertTrue(""String_Node_Str"",hist.hasNext());
  HarvestInfo dh=(HarvestInfo)hist.next();
  assertEquals(""String_Node_Str"",22,dh.getCountObjectRetrieved());
  assertFalse(""String_Node_Str"",hist.hasNext());
}",0.9946977730646872
90154,"/** 
 * Send a STARTED message after a DONE message. The STARTED message should be ignored.
 */
public void testStartedAfterDone(){
  JMSConnectionTestMQ con=(JMSConnectionTestMQ)JMSConnectionFactory.getInstance();
  Job j1=TestInfo.getJob();
  JobDAO.getInstance().create(j1);
  j1.setStatus(JobStatus.NEW);
  the_dao.update(j1);
  HarvestSchedulerMonitorServer hsms=HarvestSchedulerMonitorServer.getInstance();
  long j1ID=j1.getJobID().longValue();
  j1.setStatus(JobStatus.SUBMITTED);
  the_dao.update(j1);
  DomainHarvestReport hhr=new HeritrixDomainHarvestReport(CRAWL_REPORT,DEFAULT_STOPREASON);
  CrawlStatusMessage csm_done=new CrawlStatusMessage(j1ID,JobStatus.DONE,hhr);
  hsms.onMessage(con.getObjectMessage(csm_done));
  CrawlStatusMessage csm_start=new CrawlStatusMessage(j1ID,JobStatus.STARTED);
  hsms.onMessage(con.getObjectMessage(csm_start));
  j1=the_dao.read(new Long(j1ID));
  assertEquals(""String_Node_Str"",JobStatus.DONE,j1.getStatus());
  Domain nk_domain=DomainDAO.getInstance().read(""String_Node_Str"");
  Iterator hist=nk_domain.getHistory().getHarvestInfo();
  assertTrue(""String_Node_Str"",hist.hasNext());
  HarvestInfo dh=(HarvestInfo)hist.next();
  assertEquals(""String_Node_Str"",22,dh.getCountObjectRetrieved());
  assertFalse(""String_Node_Str"",hist.hasNext());
  LogUtils.flushLogs(hsms.getClass().getName());
  FileAsserts.assertFileContains(""String_Node_Str"",""String_Node_Str"",LOG_FILE);
}","/** 
 * Send a STARTED message after a DONE message. The STARTED message should be ignored.
 */
public void testStartedAfterDone(){
  JMSConnectionTestMQ con=(JMSConnectionTestMQ)JMSConnectionFactory.getInstance();
  Job j1=TestInfo.getJob();
  JobDAO.getInstance().create(j1);
  j1.setStatus(JobStatus.NEW);
  the_dao.update(j1);
  HarvestSchedulerMonitorServer hsms=HarvestSchedulerMonitorServer.getInstance();
  long j1ID=j1.getJobID().longValue();
  j1.setStatus(JobStatus.SUBMITTED);
  the_dao.update(j1);
  DomainHarvestReport hhr=new HeritrixDomainHarvestReport(CRAWL_REPORT,DEFAULT_STOPREASON);
  CrawlStatusMessage csm_done=new CrawlStatusMessage(j1ID,JobStatus.DONE,hhr);
  hsms.onMessage(con.getObjectMessage(csm_done));
  CrawlStatusMessage csm_start=new CrawlStatusMessage(j1ID,JobStatus.STARTED);
  hsms.onMessage(con.getObjectMessage(csm_start));
  j1=the_dao.read(new Long(j1ID));
  assertEquals(""String_Node_Str"",JobStatus.DONE,j1.getStatus());
  Domain nk_domain=DomainDAO.getInstance().read(""String_Node_Str"");
  Iterator<HarvestInfo> hist=nk_domain.getHistory().getHarvestInfo();
  assertTrue(""String_Node_Str"",hist.hasNext());
  HarvestInfo dh=(HarvestInfo)hist.next();
  assertEquals(""String_Node_Str"",22,dh.getCountObjectRetrieved());
  assertFalse(""String_Node_Str"",hist.hasNext());
  LogUtils.flushLogs(hsms.getClass().getName());
  FileAsserts.assertFileContains(""String_Node_Str"",""String_Node_Str"",LOG_FILE);
}",0.9954561342188046
90155,"/** 
 * Send a STARTED CrawlStatusMessage after a Failed message. This STARTED message should be ignored.
 */
public void testStartedAfterFailed(){
  JMSConnectionTestMQ con=(JMSConnectionTestMQ)JMSConnectionFactory.getInstance();
  Job j1=TestInfo.getJob();
  JobDAO.getInstance().create(j1);
  j1.setStatus(JobStatus.NEW);
  the_dao.update(j1);
  HarvestSchedulerMonitorServer hsms=HarvestSchedulerMonitorServer.getInstance();
  long j1ID=j1.getJobID().longValue();
  j1.setStatus(JobStatus.SUBMITTED);
  the_dao.update(j1);
  DomainHarvestReport hhr=new HeritrixDomainHarvestReport(CRAWL_REPORT,DEFAULT_STOPREASON);
  CrawlStatusMessage csm_failed=new CrawlStatusMessage(j1ID,JobStatus.FAILED,hhr);
  csm_failed.setNotOk(""String_Node_Str"");
  hsms.onMessage(con.getObjectMessage(csm_failed));
  CrawlStatusMessage csm_start=new CrawlStatusMessage(j1ID,JobStatus.STARTED);
  hsms.onMessage(con.getObjectMessage(csm_start));
  j1=the_dao.read(new Long(j1ID));
  assertEquals(""String_Node_Str"",JobStatus.FAILED,j1.getStatus());
  Domain nk_domain=DomainDAO.getInstance().read(""String_Node_Str"");
  Iterator hist=nk_domain.getHistory().getHarvestInfo();
  assertTrue(""String_Node_Str"",hist.hasNext());
  HarvestInfo dh=(HarvestInfo)hist.next();
  assertEquals(""String_Node_Str"",22,dh.getCountObjectRetrieved());
  assertFalse(""String_Node_Str"",hist.hasNext());
}","/** 
 * Send a STARTED CrawlStatusMessage after a Failed message. This STARTED message should be ignored.
 */
public void testStartedAfterFailed(){
  JMSConnectionTestMQ con=(JMSConnectionTestMQ)JMSConnectionFactory.getInstance();
  Job j1=TestInfo.getJob();
  JobDAO.getInstance().create(j1);
  j1.setStatus(JobStatus.NEW);
  the_dao.update(j1);
  HarvestSchedulerMonitorServer hsms=HarvestSchedulerMonitorServer.getInstance();
  long j1ID=j1.getJobID().longValue();
  j1.setStatus(JobStatus.SUBMITTED);
  the_dao.update(j1);
  DomainHarvestReport hhr=new HeritrixDomainHarvestReport(CRAWL_REPORT,DEFAULT_STOPREASON);
  CrawlStatusMessage csm_failed=new CrawlStatusMessage(j1ID,JobStatus.FAILED,hhr);
  csm_failed.setNotOk(""String_Node_Str"");
  hsms.onMessage(con.getObjectMessage(csm_failed));
  CrawlStatusMessage csm_start=new CrawlStatusMessage(j1ID,JobStatus.STARTED);
  hsms.onMessage(con.getObjectMessage(csm_start));
  j1=the_dao.read(new Long(j1ID));
  assertEquals(""String_Node_Str"",JobStatus.FAILED,j1.getStatus());
  Domain nk_domain=DomainDAO.getInstance().read(""String_Node_Str"");
  Iterator<HarvestInfo> hist=nk_domain.getHistory().getHarvestInfo();
  assertTrue(""String_Node_Str"",hist.hasNext());
  HarvestInfo dh=(HarvestInfo)hist.next();
  assertEquals(""String_Node_Str"",22,dh.getCountObjectRetrieved());
  assertFalse(""String_Node_Str"",hist.hasNext());
}",0.9952468007312614
90156,"/** 
 * If FAILED arrives after DONE, the jobis marked as FAILED.
 */
public void testFailedAfterDone(){
  JMSConnectionTestMQ con=(JMSConnectionTestMQ)JMSConnectionFactory.getInstance();
  Job j1=TestInfo.getJob();
  the_dao.create(j1);
  j1.setStatus(JobStatus.NEW);
  the_dao.update(j1);
  HarvestSchedulerMonitorServer hsms=HarvestSchedulerMonitorServer.getInstance();
  long j1ID=j1.getJobID().longValue();
  j1.setStatus(JobStatus.SUBMITTED);
  the_dao.update(j1);
  CrawlStatusMessage csm_start=new CrawlStatusMessage(j1ID,JobStatus.STARTED);
  hsms.onMessage(con.getObjectMessage(csm_start));
  DomainHarvestReport hhr=new HeritrixDomainHarvestReport(CRAWL_REPORT,DEFAULT_STOPREASON);
  CrawlStatusMessage csm_done=new CrawlStatusMessage(j1ID,JobStatus.DONE,hhr);
  hsms.onMessage(con.getObjectMessage(csm_done));
  CrawlStatusMessage csm_failed=new CrawlStatusMessage(j1ID,JobStatus.FAILED,null);
  csm_failed.setNotOk(""String_Node_Str"");
  hsms.onMessage(con.getObjectMessage(csm_failed));
  j1=the_dao.read(new Long(j1ID));
  assertEquals(""String_Node_Str"",JobStatus.FAILED,j1.getStatus());
  Domain nk_domain=DomainDAO.getInstance().read(""String_Node_Str"");
  Iterator hist=nk_domain.getHistory().getHarvestInfo();
  assertTrue(""String_Node_Str"",hist.hasNext());
  HarvestInfo dh=(HarvestInfo)hist.next();
  assertFalse(""String_Node_Str"",hist.hasNext());
  assertEquals(""String_Node_Str"",22,dh.getCountObjectRetrieved());
  assertEquals(""String_Node_Str"",270,dh.getSizeDataRetrieved());
  LogUtils.flushLogs(hsms.getClass().getName());
  FileAsserts.assertFileContains(""String_Node_Str"",""String_Node_Str"",LOG_FILE);
}","/** 
 * If FAILED arrives after DONE, the job is marked as FAILED.
 */
public void testFailedAfterDone(){
  JMSConnectionTestMQ con=(JMSConnectionTestMQ)JMSConnectionFactory.getInstance();
  Job j1=TestInfo.getJob();
  the_dao.create(j1);
  j1.setStatus(JobStatus.NEW);
  the_dao.update(j1);
  HarvestSchedulerMonitorServer hsms=HarvestSchedulerMonitorServer.getInstance();
  long j1ID=j1.getJobID().longValue();
  j1.setStatus(JobStatus.SUBMITTED);
  the_dao.update(j1);
  CrawlStatusMessage csm_start=new CrawlStatusMessage(j1ID,JobStatus.STARTED);
  hsms.onMessage(con.getObjectMessage(csm_start));
  DomainHarvestReport hhr=new HeritrixDomainHarvestReport(CRAWL_REPORT,DEFAULT_STOPREASON);
  CrawlStatusMessage csm_done=new CrawlStatusMessage(j1ID,JobStatus.DONE,hhr);
  hsms.onMessage(con.getObjectMessage(csm_done));
  CrawlStatusMessage csm_failed=new CrawlStatusMessage(j1ID,JobStatus.FAILED,null);
  csm_failed.setNotOk(""String_Node_Str"");
  hsms.onMessage(con.getObjectMessage(csm_failed));
  j1=the_dao.read(new Long(j1ID));
  assertEquals(""String_Node_Str"",JobStatus.FAILED,j1.getStatus());
  Domain nk_domain=DomainDAO.getInstance().read(""String_Node_Str"");
  Iterator<HarvestInfo> hist=nk_domain.getHistory().getHarvestInfo();
  assertTrue(""String_Node_Str"",hist.hasNext());
  HarvestInfo dh=(HarvestInfo)hist.next();
  assertFalse(""String_Node_Str"",hist.hasNext());
  assertEquals(""String_Node_Str"",22,dh.getCountObjectRetrieved());
  assertEquals(""String_Node_Str"",270,dh.getSizeDataRetrieved());
  LogUtils.flushLogs(hsms.getClass().getName());
  FileAsserts.assertFileContains(""String_Node_Str"",""String_Node_Str"",LOG_FILE);
}",0.9957212713936432
90157,"/** 
 * Test that receiving a ""DONE"" directly after a ""SUBMITTED"" runs ok but is logged.
 */
public void testDoneAfterSubmitted(){
  JMSConnectionTestMQ con=(JMSConnectionTestMQ)JMSConnectionFactory.getInstance();
  Job j1=TestInfo.getJob();
  the_dao.create(j1);
  j1.setStatus(JobStatus.NEW);
  the_dao.update(j1);
  HarvestSchedulerMonitorServer hsms=HarvestSchedulerMonitorServer.getInstance();
  long j1ID=j1.getJobID().longValue();
  j1.setStatus(JobStatus.SUBMITTED);
  the_dao.update(j1);
  DomainHarvestReport hhr=new HeritrixDomainHarvestReport(CRAWL_REPORT,DEFAULT_STOPREASON);
  CrawlStatusMessage csm_done=new CrawlStatusMessage(j1ID,JobStatus.DONE,hhr);
  hsms.onMessage(con.getObjectMessage(csm_done));
  j1=the_dao.read(new Long(j1ID));
  assertEquals(""String_Node_Str"",JobStatus.DONE,j1.getStatus());
  Domain nk_domain=DomainDAO.getInstance().read(""String_Node_Str"");
  Iterator hist=nk_domain.getHistory().getHarvestInfo();
  assertTrue(""String_Node_Str"",hist.hasNext());
  HarvestInfo dh=(HarvestInfo)hist.next();
  assertFalse(""String_Node_Str"",hist.hasNext());
  assertEquals(""String_Node_Str"",22,dh.getCountObjectRetrieved());
  assertEquals(""String_Node_Str"",270,dh.getSizeDataRetrieved());
  LogUtils.flushLogs(hsms.getClass().getName());
  FileAsserts.assertFileContains(""String_Node_Str"",""String_Node_Str"",LOG_FILE);
}","/** 
 * Test that receiving a ""DONE"" directly after a ""SUBMITTED"" runs ok but is logged.
 */
public void testDoneAfterSubmitted(){
  JMSConnectionTestMQ con=(JMSConnectionTestMQ)JMSConnectionFactory.getInstance();
  Job j1=TestInfo.getJob();
  the_dao.create(j1);
  j1.setStatus(JobStatus.NEW);
  the_dao.update(j1);
  HarvestSchedulerMonitorServer hsms=HarvestSchedulerMonitorServer.getInstance();
  long j1ID=j1.getJobID().longValue();
  j1.setStatus(JobStatus.SUBMITTED);
  the_dao.update(j1);
  DomainHarvestReport hhr=new HeritrixDomainHarvestReport(CRAWL_REPORT,DEFAULT_STOPREASON);
  CrawlStatusMessage csm_done=new CrawlStatusMessage(j1ID,JobStatus.DONE,hhr);
  hsms.onMessage(con.getObjectMessage(csm_done));
  j1=the_dao.read(new Long(j1ID));
  assertEquals(""String_Node_Str"",JobStatus.DONE,j1.getStatus());
  Domain nk_domain=DomainDAO.getInstance().read(""String_Node_Str"");
  Iterator<HarvestInfo> hist=nk_domain.getHistory().getHarvestInfo();
  assertTrue(""String_Node_Str"",hist.hasNext());
  HarvestInfo dh=(HarvestInfo)hist.next();
  assertFalse(""String_Node_Str"",hist.hasNext());
  assertEquals(""String_Node_Str"",22,dh.getCountObjectRetrieved());
  assertEquals(""String_Node_Str"",270,dh.getSizeDataRetrieved());
  LogUtils.flushLogs(hsms.getClass().getName());
  FileAsserts.assertFileContains(""String_Node_Str"",""String_Node_Str"",LOG_FILE);
}",0.9951905290418054
90158,"/** 
 * Print a table row with current state of a file in a given bitarchive.
 * @param out    The stream to print state to.
 * @param l      The location of the files.
 * @param fs     The file preservation state for that file.
 * @param locale Locale of the labels.
 * @throws IOException
 */
private static void printFileStateForBitarchive(JspWriter out,Location l,FilePreservationState fs,Locale locale) throws IOException {
  String baLocation=l.getName();
  out.print(HTMLUtils.makeTableRow(HTMLUtils.makeTableElement(baLocation),HTMLUtils.makeTableElement(fs.getAdminBitarchiveState(l)),HTMLUtils.makeTableElement(presentChecksum(fs.getBitarchiveChecksum(l),locale))));
}","/** 
 * Print a table row with current state of a file in a given bitarchive.
 * @param out    The stream to print state to.
 * @param baLocation The location of the files.
 * @param fs     The file preservation state for that file.
 * @param locale Locale of the labels.
 * @throws IOException
 */
private static void printFileStateForBitarchive(JspWriter out,Location baLocation,FilePreservationState fs,Locale locale) throws IOException {
  log.debug(""String_Node_Str"" + baLocation.getName() + ""String_Node_Str"");
  if (fs.getBitarchiveChecksum(baLocation) == null) {
    log.fatal(""String_Node_Str"" + baLocation);
  }
  out.print(HTMLUtils.makeTableRow(HTMLUtils.makeTableElement(baLocation.getName()),HTMLUtils.makeTableElement(fs.getAdminBitarchiveState(baLocation)),HTMLUtils.makeTableElement(presentChecksum(fs.getBitarchiveChecksum(baLocation),locale))));
}",0.8406735751295337
90159,"/** 
 * Present a list of checksums in a human-readable form.
 * @param csum   List of checksum strings
 * @param locale
 * @return String presenting the checksums.
 */
public static String presentChecksum(List<String> csum,Locale locale){
  ArgumentNotValid.checkNotNull(csum,""String_Node_Str"");
  ArgumentNotValid.checkNotNull(locale,""String_Node_Str"");
  String csumString=csum.toString();
  if (csum.isEmpty()) {
    csumString=I18N.getString(locale,""String_Node_Str"");
  }
 else   if (csum.size() == 1) {
    csumString=csum.get(0);
  }
  return csumString;
}","/** 
 * Present a list of checksums in a human-readable form. If size of list is 0, it returns ""No checksum"". If size of list is 1, it returns the one available checksum. Otherwise, it returns toString of the list. 
 * @param csum   List of checksum strings
 * @param locale The given locale.
 * @return String presenting the checksums.
 */
public static String presentChecksum(List<String> csum,Locale locale){
  ArgumentNotValid.checkNotNull(csum,""String_Node_Str"");
  ArgumentNotValid.checkNotNull(locale,""String_Node_Str"");
  String csumString=csum.toString();
  if (csum.isEmpty()) {
    csumString=I18N.getString(locale,""String_Node_Str"");
  }
 else   if (csum.size() == 1) {
    csumString=csum.get(0);
  }
  return csumString;
}",0.8676923076923077
90160,"/** 
 * Writes the files involved with a harvests.
 * @param crawldir        The directory that the crawl should take placein.
 * @param job             The Job object containing various harvest setupdata.
 * @param metadataEntries Any metadata entries sent along with the job thatshould be stored for later use.
 * @return An object encapsulating where these files have been written.
 */
public HeritrixFiles writeHarvestFiles(File crawldir,Job job,List<MetadataEntry> metadataEntries){
  final HeritrixFiles files=new HeritrixFiles(crawldir,job.getJobID(),job.getOrigHarvestDefinitionID());
  log.debug(""String_Node_Str"" + job.getJobID());
  new PersistentJobData(files.getCrawlDir()).write(job);
  writePreharvestMetadata(job,metadataEntries,crawldir);
  files.writeSeedsTxt(job.getSeedListAsString());
  files.writeOrderXml(job.getOrderXMLdoc());
  files.setIndexDir(fetchDeduplicateIndex(metadataEntries));
  return files;
}","/** 
 * Writes the files involved with a harvests.
 * @param crawldir        The directory that the crawl should take placein.
 * @param job             The Job object containing various harvest setupdata.
 * @param metadataEntries Any metadata entries sent along with the job thatshould be stored for later use.
 * @return An object encapsulating where these files have been written.
 */
public HeritrixFiles writeHarvestFiles(File crawldir,Job job,List<MetadataEntry> metadataEntries){
  final HeritrixFiles files=new HeritrixFiles(crawldir,job.getJobID(),job.getOrigHarvestDefinitionID());
  log.debug(""String_Node_Str"" + job.getJobID());
  new PersistentJobData(files.getCrawlDir()).write(job);
  writePreharvestMetadata(job,metadataEntries,crawldir);
  files.writeSeedsTxt(job.getSeedListAsString());
  files.writeOrderXml(job.getOrderXMLdoc());
  files.setIndexDir(fetchDeduplicateIndex(metadataEntries));
  boolean created=files.getArcsDir().mkdir();
  if (!created) {
    log.warn(""String_Node_Str"" + files.getArcsDir());
  }
  return files;
}",0.9383838383838384
90161,"/** 
 * Controls storing all files involved in a job.  The files are 1) The actual ARC files, 2) The metadata files The crawl.log is parsed and information for each domain is generated and stored in a DomainHarvestReport object which is sent along in the crawlstatusmessage. Additionally, any leftover open ARC files are closed and harvest documentation is extracted before upload starts.
 * @param files The HeritrixFiles object for this crawl.
 * @param errorMessage A place where error messages accumulate.
 * @param failedFiles  List of files that failed to upload.
 * @return An object containing info about the domains harvested.
 */
public DomainHarvestReport storeFiles(HeritrixFiles files,StringBuilder errorMessage,List<File> failedFiles){
  ArgumentNotValid.checkNotNull(files,""String_Node_Str"");
  ArgumentNotValid.checkNotNull(errorMessage,""String_Node_Str"");
  ArgumentNotValid.checkNotNull(failedFiles,""String_Node_Str"");
  long jobID=files.getJobID();
  long harvestID=files.getHarvestID();
  File crawlDir=files.getCrawlDir();
  try {
    IngestableFiles inf=new IngestableFiles(crawlDir,jobID);
    inf.closeOpenFiles(WAIT_FOR_HERITRIX_TIMEOUT_SECS);
    HarvestDocumentation.documentHarvest(crawlDir,jobID,harvestID);
    uploadFiles(inf.getArcFiles(),errorMessage,failedFiles);
    uploadFiles(inf.getMetadataArcFiles(),errorMessage,failedFiles);
    return generateHeritrixDomainHarvestReport(files,errorMessage);
  }
 catch (  IOFailure e) {
    String errMsg=""String_Node_Str"";
    log.warn(errMsg,e);
    throw new IOFailure(errMsg,e);
  }
}","/** 
 * Controls storing all files involved in a job.  The files are 1) The actual ARC files, 2) The metadata files The crawl.log is parsed and information for each domain is generated and stored in a DomainHarvestReport object which is sent along in the crawlstatusmessage. Additionally, any leftover open ARC files are closed and harvest documentation is extracted before upload starts.
 * @param files The HeritrixFiles object for this crawl.
 * @param errorMessage A place where error messages accumulate.
 * @param failedFiles  List of files that failed to upload.
 * @return An object containing info about the domains harvested.
 */
public DomainHarvestReport storeFiles(HeritrixFiles files,StringBuilder errorMessage,List<File> failedFiles){
  ArgumentNotValid.checkNotNull(files,""String_Node_Str"");
  ArgumentNotValid.checkNotNull(errorMessage,""String_Node_Str"");
  ArgumentNotValid.checkNotNull(failedFiles,""String_Node_Str"");
  long jobID=files.getJobID();
  long harvestID=files.getHarvestID();
  File crawlDir=files.getCrawlDir();
  try {
    IngestableFiles inf=new IngestableFiles(crawlDir,jobID);
    inf.closeOpenFiles(WAIT_FOR_HERITRIX_TIMEOUT_SECS);
    HarvestDocumentation.documentHarvest(crawlDir,jobID,harvestID);
    if (inf.getArcFiles().isEmpty()) {
      String errMsg=""String_Node_Str"" + ""String_Node_Str"" + jobID;
      log.warn(errMsg);
      NotificationsFactory.getInstance().errorEvent(errMsg);
    }
 else {
      uploadFiles(inf.getArcFiles(),errorMessage,failedFiles);
    }
    uploadFiles(inf.getMetadataArcFiles(),errorMessage,failedFiles);
    return generateHeritrixDomainHarvestReport(files,errorMessage);
  }
 catch (  IOFailure e) {
    String errMsg=""String_Node_Str"";
    log.warn(errMsg,e);
    throw new IOFailure(errMsg,e);
  }
}",0.7998803469937182
90162,"/** 
 * Iterates over the ARC files in the given dir and moves away files that do not belong to the given job.  Files whose jobid we can parse will be moved to a directory under oldjobs named with that jobid, otherwise they will go into a directory under oldjobs named with a timestamp.
 * @param dir A directory containing one or more ARC files.
 * @param jobID ID of the job whose directory we're in.
 * @throws UnknownID If ?????????????????????????????????????
 */
private static void moveAwayForeignFiles(File dir,long jobID) throws UnknownID {
  File[] arcFiles=dir.listFiles(FileUtils.ARCS_FILTER);
  File oldJobsDir=new File(Settings.get(Settings.HARVEST_CONTROLLER_OLDJOBSDIR));
  File unknownJobDir=new File(oldJobsDir,""String_Node_Str"" + new Date().getTime());
  List<File> movedFiles=new ArrayList<File>();
  for (  File arcFile : arcFiles) {
    long foundJobID=-1;
    try {
      FileUtils.FilenameParser parser=new FilenameParser(arcFile);
      foundJobID=Long.parseLong(parser.getJobID());
    }
 catch (    UnknownID e) {
      Matcher matcher=metadataFilenamePattern.matcher(arcFile.getName());
      if (matcher.matches()) {
        foundJobID=Long.parseLong(matcher.group(1));
      }
    }
    if (foundJobID != jobID) {
      File arcsDir;
      if (foundJobID == -1) {
        arcsDir=new File(unknownJobDir,""String_Node_Str"");
      }
 else {
        arcsDir=new File(oldJobsDir,foundJobID + ""String_Node_Str"");
      }
      try {
        FileUtils.createDir(arcsDir);
        File moveTo=new File(arcsDir,arcFile.getName());
        arcFile.renameTo(moveTo);
        movedFiles.add(moveTo);
      }
 catch (      PermissionDenied e) {
        log.warn(""String_Node_Str"" + arcsDir.getAbsolutePath() + ""String_Node_Str"",e);
      }
    }
  }
  if (!movedFiles.isEmpty()) {
    log.warn(""String_Node_Str"" + jobID + ""String_Node_Str""+ movedFiles);
  }
}","/** 
 * Iterates over the ARC files in the given dir and moves away files that do not belong to the given job.  Files whose jobid we can parse will be moved to a directory under oldjobs named with that jobid, otherwise they will go into a directory under oldjobs named with a timestamp.
 * @param dir A directory containing one or more ARC files.
 * @param jobID ID of the job whose directory we're in.
 * @throws UnknownID If ?????????????????????????????????????
 */
private static void moveAwayForeignFiles(File dir,long jobID) throws UnknownID {
  File[] arcFiles=dir.listFiles(FileUtils.ARCS_FILTER);
  File oldJobsDir=new File(Settings.get(Settings.HARVEST_CONTROLLER_OLDJOBSDIR));
  File unknownJobDir=new File(oldJobsDir,""String_Node_Str"" + new Date().getTime());
  List<File> movedFiles=new ArrayList<File>();
  for (  File arcFile : arcFiles) {
    long foundJobID=-1;
    try {
      FileUtils.FilenameParser parser=new FilenameParser(arcFile);
      foundJobID=Long.parseLong(parser.getJobID());
    }
 catch (    UnknownID e) {
      Matcher matcher=metadataFilenamePattern.matcher(arcFile.getName());
      if (matcher.matches()) {
        foundJobID=Long.parseLong(matcher.group(1));
      }
    }
    if (foundJobID != jobID) {
      File arcsDir;
      if (foundJobID == -1) {
        arcsDir=new File(unknownJobDir,Constants.ARCDIRECTORY_NAME);
      }
 else {
        arcsDir=new File(oldJobsDir,foundJobID + ""String_Node_Str"" + Constants.ARCDIRECTORY_NAME);
      }
      try {
        FileUtils.createDir(arcsDir);
        File moveTo=new File(arcsDir,arcFile.getName());
        arcFile.renameTo(moveTo);
        movedFiles.add(moveTo);
      }
 catch (      PermissionDenied e) {
        log.warn(""String_Node_Str"" + arcsDir.getAbsolutePath() + ""String_Node_Str"",e);
      }
    }
  }
  if (!movedFiles.isEmpty()) {
    log.warn(""String_Node_Str"" + jobID + ""String_Node_Str""+ movedFiles);
  }
}",0.7785977859778598
90163,"/** 
 * Simple test that construction works as intended with or without verification.
 */
public void testHeritrixTemplate(){
  Document doc=null;
  try {
    new HeritrixTemplate(doc);
    fail(""String_Node_Str"");
  }
 catch (  ArgumentNotValid e) {
  }
  doc=DocumentFactory.getInstance().createDocument();
  try {
    new HeritrixTemplate(doc);
    fail(""String_Node_Str"");
  }
 catch (  ArgumentNotValid e) {
  }
  try {
    new HeritrixTemplate(doc,false);
  }
 catch (  ArgumentNotValid e) {
    fail(""String_Node_Str"" + e);
  }
  File f=new File(TestInfo.TOPDATADIR,""String_Node_Str"");
  doc=XmlUtils.getXmlDoc(f);
  try {
    new HeritrixTemplate(doc,true);
  }
 catch (  ArgumentNotValid e) {
    fail(""String_Node_Str"" + e);
  }
  doc=XmlUtils.getXmlDoc(f);
  List<Node> nodes=doc.selectNodes(HeritrixTemplate.QUEUE_TOTAL_BUDGET_XPATH);
  for (  Node n : nodes) {
    n.detach();
    doc.remove(n);
  }
  try {
    new HeritrixTemplate(doc,true);
    fail(""String_Node_Str"");
  }
 catch (  ArgumentNotValid e) {
  }
  doc=XmlUtils.getXmlDoc(f);
  checkLegalValues(""String_Node_Str"",doc,HeritrixTemplate.QUEUE_TOTAL_BUDGET_XPATH,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  checkIllegalValues(""String_Node_Str"",doc,HeritrixTemplate.QUEUE_TOTAL_BUDGET_XPATH,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  doc=XmlUtils.getXmlDoc(f);
  checkLegalValues(""String_Node_Str"",doc,HeritrixTemplate.GROUP_MAX_ALL_KB_XPATH,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  checkIllegalValues(""String_Node_Str"",doc,HeritrixTemplate.GROUP_MAX_ALL_KB_XPATH,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  doc=XmlUtils.getXmlDoc(f);
  checkLegalValues(""String_Node_Str"",doc,HeritrixTemplate.DECIDERULES_MAP_XPATH,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  doc=XmlUtils.getXmlDoc(f);
  checkLegalValues(""String_Node_Str"",doc,HeritrixTemplate.HERITRIX_USER_AGENT_XPATH,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"");
  checkIllegalValues(""String_Node_Str"",doc,HeritrixTemplate.HERITRIX_USER_AGENT_XPATH,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  doc=XmlUtils.getXmlDoc(f);
  checkLegalValues(""String_Node_Str"",doc,HeritrixTemplate.HERITRIX_FROM_XPATH,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  checkIllegalValues(""String_Node_Str"",doc,HeritrixTemplate.HERITRIX_FROM_XPATH,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
}","/** 
 * Simple test that construction works as intended with or without verification.
 */
public void testHeritrixTemplate(){
  Document doc=null;
  try {
    new HeritrixTemplate(doc);
    fail(""String_Node_Str"");
  }
 catch (  ArgumentNotValid e) {
  }
  doc=DocumentFactory.getInstance().createDocument();
  try {
    new HeritrixTemplate(doc);
    fail(""String_Node_Str"");
  }
 catch (  ArgumentNotValid e) {
  }
  try {
    new HeritrixTemplate(doc,false);
  }
 catch (  ArgumentNotValid e) {
    fail(""String_Node_Str"" + e);
  }
  File f=new File(TestInfo.TOPDATADIR,""String_Node_Str"");
  doc=XmlUtils.getXmlDoc(f);
  try {
    new HeritrixTemplate(doc,true);
  }
 catch (  ArgumentNotValid e) {
    fail(""String_Node_Str"" + e);
  }
  doc=XmlUtils.getXmlDoc(f);
  List<Node> nodes=doc.selectNodes(HeritrixTemplate.QUEUE_TOTAL_BUDGET_XPATH);
  for (  Node n : nodes) {
    n.detach();
    doc.remove(n);
  }
  try {
    new HeritrixTemplate(doc,true);
    fail(""String_Node_Str"");
  }
 catch (  ArgumentNotValid e) {
  }
  doc=XmlUtils.getXmlDoc(f);
  checkLegalValues(""String_Node_Str"",doc,HeritrixTemplate.QUEUE_TOTAL_BUDGET_XPATH,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  checkIllegalValues(""String_Node_Str"",doc,HeritrixTemplate.QUEUE_TOTAL_BUDGET_XPATH,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  doc=XmlUtils.getXmlDoc(f);
  checkLegalValues(""String_Node_Str"",doc,HeritrixTemplate.GROUP_MAX_ALL_KB_XPATH,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  checkIllegalValues(""String_Node_Str"",doc,HeritrixTemplate.GROUP_MAX_ALL_KB_XPATH,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  doc=XmlUtils.getXmlDoc(f);
  checkLegalValues(""String_Node_Str"",doc,HeritrixTemplate.DECIDERULES_MAP_XPATH,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  doc=XmlUtils.getXmlDoc(f);
  checkLegalValues(""String_Node_Str"",doc,HeritrixTemplate.HERITRIX_USER_AGENT_XPATH,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"" + ""String_Node_Str"");
  checkIllegalValues(""String_Node_Str"",doc,HeritrixTemplate.HERITRIX_USER_AGENT_XPATH,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  doc=XmlUtils.getXmlDoc(f);
  checkLegalValues(""String_Node_Str"",doc,HeritrixTemplate.HERITRIX_FROM_XPATH,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  checkIllegalValues(""String_Node_Str"",doc,HeritrixTemplate.HERITRIX_FROM_XPATH,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
  doc=XmlUtils.getXmlDoc(f);
  checkLegalValues(""String_Node_Str"",doc,HeritrixTemplate.ARCHIVER_PATH_XPATH,dk.netarkivet.common.Constants.ARCDIRECTORY_NAME);
  checkIllegalValues(""String_Node_Str"",doc,HeritrixTemplate.ARCHIVER_PATH_XPATH,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
}",0.9467969598262758
90164,"/** 
 * Tests the writeHarvestFiles method.
 * @throws Exception
 */
public void testWriteHarvestFiles() throws Exception {
  Job j=TestInfo.getJob();
  j.setJobID(1L);
  assertTrue(""String_Node_Str"",j.getSeedListAsString() != ""String_Node_Str"");
  assertTrue(""String_Node_Str"",j.getOrderXMLdoc().hasContent());
  File crawlDir=new File(TestInfo.WORKING_DIR,""String_Node_Str"");
  FileUtils.createDir(crawlDir);
  List<MetadataEntry> metadata=Arrays.asList(new MetadataEntry[]{TestInfo.sampleEntry});
  File harvestInfo=new File(crawlDir,""String_Node_Str"");
  File seedsTxt=new File(crawlDir,""String_Node_Str"");
  File orderXml=new File(crawlDir,""String_Node_Str"");
  File metadataFile=new File(crawlDir,j.getJobID() + ""String_Node_Str"");
  assertFalse(""String_Node_Str"",metadataFile.exists());
  assertFalse(""String_Node_Str"",harvestInfo.exists());
  assertFalse(""String_Node_Str"",seedsTxt.exists());
  assertFalse(""String_Node_Str"",orderXml.exists());
  HarvestController controller=HarvestController.getInstance();
  HeritrixFiles files=controller.writeHarvestFiles(crawlDir,j,metadata);
  assertTrue(""String_Node_Str"",harvestInfo.exists());
  assertTrue(""String_Node_Str"",seedsTxt.exists());
  assertTrue(""String_Node_Str"",orderXml.exists());
  assertTrue(""String_Node_Str"",metadataFile.exists());
  FileAsserts.assertFileContains(""String_Node_Str"",""String_Node_Str"" + j.getJobID() + ""String_Node_Str"",harvestInfo);
  FileAsserts.assertFileContains(""String_Node_Str"",""String_Node_Str"" + j.getOrigHarvestDefinitionID() + ""String_Node_Str"",harvestInfo);
  FileAsserts.assertFileContains(""String_Node_Str"",""String_Node_Str"",orderXml);
  Document order=XmlUtils.getXmlDoc(orderXml);
  HeritrixTemplate template=new HeritrixTemplate(order,true);
  FileAsserts.assertFileContains(""String_Node_Str"",j.getSeedListAsString(),seedsTxt);
  FileAsserts.assertFileContains(""String_Node_Str"",""String_Node_Str"",metadataFile);
  FileAsserts.assertFileContains(""String_Node_Str"",""String_Node_Str"",metadataFile);
  FileAsserts.assertFileContains(""String_Node_Str"",""String_Node_Str"",metadataFile);
  assertEquals(""String_Node_Str"",crawlDir,files.getCrawlDir());
  assertEquals(""String_Node_Str"",orderXml,files.getOrderXmlFile());
  assertEquals(""String_Node_Str"",seedsTxt,files.getSeedsTxtFile());
  assertTrue(""String_Node_Str"",files.getIndexDir().isDirectory());
  assertEquals(""String_Node_Str"",3,files.getIndexDir().listFiles().length);
}","/** 
 * Tests the writeHarvestFiles method.
 * @throws Exception
 */
public void testWriteHarvestFiles() throws Exception {
  Job j=TestInfo.getJob();
  j.setJobID(1L);
  assertTrue(""String_Node_Str"",j.getSeedListAsString() != ""String_Node_Str"");
  assertTrue(""String_Node_Str"",j.getOrderXMLdoc().hasContent());
  File crawlDir=new File(TestInfo.WORKING_DIR,""String_Node_Str"");
  FileUtils.createDir(crawlDir);
  List<MetadataEntry> metadata=Arrays.asList(new MetadataEntry[]{TestInfo.sampleEntry});
  File harvestInfo=new File(crawlDir,""String_Node_Str"");
  File seedsTxt=new File(crawlDir,""String_Node_Str"");
  File orderXml=new File(crawlDir,""String_Node_Str"");
  File metadataFile=new File(crawlDir,j.getJobID() + ""String_Node_Str"");
  assertFalse(""String_Node_Str"",metadataFile.exists());
  assertFalse(""String_Node_Str"",harvestInfo.exists());
  assertFalse(""String_Node_Str"",seedsTxt.exists());
  assertFalse(""String_Node_Str"",orderXml.exists());
  HarvestController controller=HarvestController.getInstance();
  HeritrixFiles files=controller.writeHarvestFiles(crawlDir,j,metadata);
  assertTrue(""String_Node_Str"",harvestInfo.exists());
  assertTrue(""String_Node_Str"",seedsTxt.exists());
  assertTrue(""String_Node_Str"",orderXml.exists());
  assertTrue(""String_Node_Str"",metadataFile.exists());
  FileAsserts.assertFileContains(""String_Node_Str"",""String_Node_Str"" + j.getJobID() + ""String_Node_Str"",harvestInfo);
  FileAsserts.assertFileContains(""String_Node_Str"",""String_Node_Str"" + j.getOrigHarvestDefinitionID() + ""String_Node_Str"",harvestInfo);
  FileAsserts.assertFileContains(""String_Node_Str"",""String_Node_Str"",orderXml);
  new HeritrixTemplate(XmlUtils.getXmlDoc(orderXml),true);
  FileAsserts.assertFileContains(""String_Node_Str"",j.getSeedListAsString(),seedsTxt);
  FileAsserts.assertFileContains(""String_Node_Str"",""String_Node_Str"",metadataFile);
  FileAsserts.assertFileContains(""String_Node_Str"",""String_Node_Str"",metadataFile);
  FileAsserts.assertFileContains(""String_Node_Str"",""String_Node_Str"",metadataFile);
  assertEquals(""String_Node_Str"",crawlDir,files.getCrawlDir());
  assertEquals(""String_Node_Str"",orderXml,files.getOrderXmlFile());
  assertEquals(""String_Node_Str"",seedsTxt,files.getSeedsTxtFile());
  assertTrue(""String_Node_Str"",files.getIndexDir().isDirectory());
  assertEquals(""String_Node_Str"",3,files.getIndexDir().listFiles().length);
  assertTrue(""String_Node_Str"",files.getArcsDir().isDirectory());
}",0.9679539852095316
90165,"/** 
 * @param objectCount The objectCount to set.
 * @throws ArgumentNotValid If objectCount is a negative number.
 */
public void setObjectCount(long objectCount){
  ArgumentNotValid.checkNotNegative(objectCount,""String_Node_Str"");
  this.objectCount=objectCount;
}","/** 
 * Set objectcount to something new.
 * @param objectCount The objectCount to set.
 * @throws ArgumentNotValid If objectCount is a negative number.
 */
public void setObjectCount(long objectCount){
  ArgumentNotValid.checkNotNegative(objectCount,""String_Node_Str"");
  this.objectCount=objectCount;
}",0.935201401050788
90166,"/** 
 * Constructor for a DomainStats object.
 * @param initObjectCount Start counting objects from this number
 * @param initByteCount  Start counting bytes from this number
 * @param defaultStopReason The default StopReason for a given domain.
 * @throws ArgumentNotValid If initObjectCount < 0, initByteCount < 0, ordefaultStopReason is null.
 */
public DomainStats(long initObjectCount,long initByteCount,StopReason defaultStopReason){
  ArgumentNotValid.checkNotNegative(initByteCount,""String_Node_Str"");
  ArgumentNotValid.checkNotNegative(objectCount,""String_Node_Str"");
  ArgumentNotValid.checkNotNull(defaultStopReason,""String_Node_Str"");
  this.objectCount=initObjectCount;
  this.byteCount=initByteCount;
  this.stopReason=defaultStopReason;
}","/** 
 * Constructor for a DomainStats object.
 * @param initObjectCount Start counting objects from this number
 * @param initByteCount  Start counting bytes from this number
 * @param defaultStopReason The default StopReason for a given domain.
 * @throws ArgumentNotValid If initObjectCount < 0, initByteCount < 0, ordefaultStopReason is null.
 */
public DomainStats(long initObjectCount,long initByteCount,StopReason defaultStopReason){
  ArgumentNotValid.checkNotNegative(initObjectCount,""String_Node_Str"");
  ArgumentNotValid.checkNotNegative(initByteCount,""String_Node_Str"");
  ArgumentNotValid.checkNotNull(defaultStopReason,""String_Node_Str"");
  this.objectCount=initObjectCount;
  this.byteCount=initByteCount;
  this.stopReason=defaultStopReason;
}",0.984126984126984
90167,"/** 
 * @param stopReason The stopReason to set.
 * @throws dk.netarkivet.common.exceptions.ArgumentNotValid If argument is null
 */
public void setStopReason(StopReason stopReason){
  ArgumentNotValid.checkNotNull(stopReason,""String_Node_Str"");
  this.stopReason=stopReason;
}","/** 
 * Set stopreason to something new.
 * @param stopReason The stopReason to set.
 * @throws ArgumentNotValid If argument is null
 */
public void setStopReason(StopReason stopReason){
  ArgumentNotValid.checkNotNull(stopReason,""String_Node_Str"");
  this.stopReason=stopReason;
}",0.8781362007168458
90168,"private void rescheduleJobs(){
  final JobDAO dao=JobDAO.getInstance();
  final Iterator<Long> jobs=dao.getAllJobIds(JobStatus.SUBMITTED);
  int resubmitcount=0;
  while (jobs.hasNext()) {
    long oldID=jobs.next();
    long newID=dao.rescheduleJob(oldID);
    log.info(""String_Node_Str"" + oldID + ""String_Node_Str""+ newID);
    resubmitcount++;
  }
  log.info(resubmitcount + ""String_Node_Str"");
}","/** 
 * Reschedule all jobs with JobStatus SUBMITTED.
 */
private void rescheduleJobs(){
  final JobDAO dao=JobDAO.getInstance();
  final Iterator<Long> jobs=dao.getAllJobIds(JobStatus.SUBMITTED);
  int resubmitcount=0;
  while (jobs.hasNext()) {
    long oldID=jobs.next();
    long newID=dao.rescheduleJob(oldID);
    log.info(""String_Node_Str"" + oldID + ""String_Node_Str""+ newID);
    resubmitcount++;
  }
  log.info(resubmitcount + ""String_Node_Str"");
}",0.647196261682243
90169,"/** 
 * Create new instance of the HarvestScheduler.
 */
private HarvestScheduler(){
  log.info(""String_Node_Str"");
  hcc=HarvestControllerClient.getInstance();
  hsmon=HarvestSchedulerMonitorServer.getInstance();
  backupInitHour=Settings.getInt(Settings.DB_BACKUP_INIT_HOUR);
  if (backupInitHour < 0 || backupInitHour > 23) {
    log.warn(""String_Node_Str"" + backupInitHour);
    log.info(""String_Node_Str"");
    backupInitHour=0;
  }
 else {
    log.info(""String_Node_Str"" + backupInitHour);
  }
}","/** 
 * Create new instance of the HarvestScheduler.
 */
private HarvestScheduler(){
  log.info(""String_Node_Str"");
  hcc=HarvestControllerClient.getInstance();
  hsmon=HarvestSchedulerMonitorServer.getInstance();
  backupInitHour=Settings.getInt(Settings.DB_BACKUP_INIT_HOUR);
  if (backupInitHour < 0 || backupInitHour > 23) {
    log.warn(""String_Node_Str"" + ""String_Node_Str"" + backupInitHour);
    log.info(""String_Node_Str"");
    backupInitHour=0;
  }
 else {
    log.info(""String_Node_Str"" + backupInitHour);
  }
}",0.980430528375734
90170,"/** 
 * Schedule all jobs ready for execution and perform backup if required. 
 */
private void scheduleJobs(){
synchronized (this) {
    if (running) {
      log.debug(""String_Node_Str"" + ""String_Node_Str"");
      return;
    }
    running=true;
  }
  if (backupNow()) {
    File backupDir=new File(""String_Node_Str"" + System.currentTimeMillis());
    try {
      DBSpecifics.getInstance().backupDatabase(backupDir);
      lastBackupDate=new Date();
    }
 catch (    SQLException e) {
      log.warn(""String_Node_Str"" + backupDir,e);
    }
  }
  try {
    final HarvestDefinitionDAO hddao=HarvestDefinitionDAO.getInstance();
    hddao.generateJobs(new Date());
    submitNewJobs();
  }
  finally {
synchronized (this) {
      running=false;
    }
  }
}","/** 
 * Schedule all jobs ready for execution and perform backup if required. 
 */
private void scheduleJobs(){
synchronized (this) {
    if (running) {
      log.debug(""String_Node_Str"" + ""String_Node_Str"");
      return;
    }
    running=true;
  }
  if (backupNow()) {
    File backupDir=new File(""String_Node_Str"" + System.currentTimeMillis());
    try {
      DBSpecifics.getInstance().backupDatabase(backupDir);
      lastBackupDate=new Date();
    }
 catch (    SQLException e) {
      String errMsg=""String_Node_Str"" + backupDir;
      log.warn(errMsg,e);
      NotificationsFactory.getInstance().errorEvent(errMsg,e);
    }
  }
  try {
    final HarvestDefinitionDAO hddao=HarvestDefinitionDAO.getInstance();
    hddao.generateJobs(new Date());
    submitNewJobs();
  }
  finally {
synchronized (this) {
      running=false;
    }
  }
}",0.9318323952470294
90171,"/** 
 * Constructor for the JMXStatusEntry. 
 * @param mBeanName The ObjectName to be assigned to the MBean representing this JMXStatusEntry.
 */
public JMXStatusEntry(ObjectName mBeanName){
  ArgumentNotValid.checkNotNull(mBeanName,""String_Node_Str"");
  this.mBeanName=mBeanName;
}","/** 
 * Constructor for the JMXStatusEntry. 
 * @param mBeanName The ObjectName to be assigned to the MBean representingthis JMXStatusEntry.
 */
public JMXStatusEntry(ObjectName mBeanName){
  ArgumentNotValid.checkNotNull(mBeanName,""String_Node_Str"");
  this.mBeanName=mBeanName;
}",0.9982238010657194
90172,"/** 
 * Update a security policy file with required permissions. Known code already has permission to do anything, while third-party code (submitted for batch) must be allowed to read bitarchive files.
 * @param securityFile File to add permissions to.
 */
public void updateSecurityFile(File securityFile){
  ArgumentNotValid.checkNotNull(securityFile,""String_Node_Str"");
  if (isType(Type.bitarchive) && properties.get(Constants.BITARCHIVE_FILEDIR_PROPERTY) != null) {
    FileUtils.appendToFile(securityFile,""String_Node_Str"");
    List<String> fileDirs=properties.get(Constants.BITARCHIVE_FILEDIR_PROPERTY);
    String dirSep=""String_Node_Str"";
    if (getOS() == OS.WINDOWS) {
      dirSep=""String_Node_Str"";
    }
    for (    String dir : fileDirs) {
      final String archivePath=StringUtils.conjoin(dirSep,dir,""String_Node_Str"",""String_Node_Str"");
      FileUtils.appendToFile(securityFile,""String_Node_Str"" + archivePath + ""String_Node_Str"");
    }
    FileUtils.appendToFile(securityFile,""String_Node_Str"");
  }
}","/** 
 * Update a security policy file with required permissions. Known code already has permission to do anything, while third-party code (submitted for batch) must be allowed to read bitarchive files.
 * @see http://java.sun.com/j2se/1.5.0/docs/guide/security/PolicyFiles.html
 * @param securityFile File to add permissions to.
 */
public void updateSecurityFile(File securityFile){
  ArgumentNotValid.checkNotNull(securityFile,""String_Node_Str"");
  if (isType(Type.bitarchive) && properties.get(Constants.BITARCHIVE_FILEDIR_PROPERTY) != null) {
    FileUtils.appendToFile(securityFile,""String_Node_Str"");
    List<String> fileDirs=properties.get(Constants.BITARCHIVE_FILEDIR_PROPERTY);
    for (    String dir : fileDirs) {
      String archivePath=StringUtils.conjoin(""String_Node_Str"",dir,""String_Node_Str"",""String_Node_Str"");
      archivePath=archivePath.replaceAll(""String_Node_Str"",""String_Node_Str"");
      FileUtils.appendToFile(securityFile,""String_Node_Str"" + archivePath + ""String_Node_Str"");
    }
    FileUtils.appendToFile(securityFile,""String_Node_Str"");
  }
}",0.6355851569933397
90173,"/** 
 * Update a security policy file with required permissions. Known code already has permission to do anything, while third-party code (submitted for batch) must be allowed to read bitarchive files.
 * @param securityFile File to add permissions to.
 */
public void updateSecurityFile(File securityFile){
  ArgumentNotValid.checkNotNull(securityFile,""String_Node_Str"");
  if (isType(Type.bitarchive) && properties.get(Constants.BITARCHIVE_FILEDIR_PROPERTY) != null) {
    FileUtils.appendToFile(securityFile,""String_Node_Str"");
    List<String> fileDirs=properties.get(Constants.BITARCHIVE_FILEDIR_PROPERTY);
    for (    String dir : fileDirs) {
      FileUtils.appendToFile(securityFile,""String_Node_Str"" + ""String_Node_Str"" + dir + ""String_Node_Str"");
    }
    FileUtils.appendToFile(securityFile,""String_Node_Str"");
  }
}","/** 
 * Update a security policy file with required permissions. Known code already has permission to do anything, while third-party code (submitted for batch) must be allowed to read bitarchive files.
 * @param securityFile File to add permissions to.
 */
public void updateSecurityFile(File securityFile){
  ArgumentNotValid.checkNotNull(securityFile,""String_Node_Str"");
  if (isType(Type.bitarchive) && properties.get(Constants.BITARCHIVE_FILEDIR_PROPERTY) != null) {
    FileUtils.appendToFile(securityFile,""String_Node_Str"");
    List<String> fileDirs=properties.get(Constants.BITARCHIVE_FILEDIR_PROPERTY);
    String dirSep=""String_Node_Str"";
    if (getOS() == OS.WINDOWS) {
      dirSep=""String_Node_Str"";
    }
    for (    String dir : fileDirs) {
      final String archivePath=StringUtils.conjoin(dirSep,dir,""String_Node_Str"",""String_Node_Str"");
      FileUtils.appendToFile(securityFile,""String_Node_Str"" + archivePath + ""String_Node_Str"");
    }
    FileUtils.appendToFile(securityFile,""String_Node_Str"");
  }
}",0.8651564185544768
90174,"/** 
 * Write a windows start bat file.
 * @param dir               The directory to write the bat file to
 * @param appName           the java class to start
 * @param settingsfn        the settings file to use
 * @param logpropDir        the directory to place the log.prop file
 * @param loggingProperties the contents of the log.prop file
 */
private void writeStartBat(File dir,String appName,String settingsfn,File logpropDir,String loggingProperties){
  String logfn=writeLogPropertiesFile(appName,dir,logpropDir,loggingProperties).replace(""String_Node_Str"",""String_Node_Str"");
  try {
    File vbs=new File(dir,""String_Node_Str"");
    File batHelper=new File(dir,""String_Node_Str"");
    File res=new File(dir,""String_Node_Str"");
    PrintWriter pwRes=null;
    PrintWriter pwBat=null;
    PrintWriter pwVbs=null;
    try {
      pwRes=new PrintWriter(new FileWriter(res));
      pwBat=new PrintWriter(new FileWriter(batHelper));
      pwVbs=new PrintWriter(new FileWriter(vbs));
      pwBat.println(""String_Node_Str"" + ""String_Node_Str"" + installDirWindows + ""String_Node_Str"");
      pwBat.println(""String_Node_Str"" + StringUtils.surjoin(getJarFiles(appName),installDirWindows + ""String_Node_Str"",""String_Node_Str""));
      String settingsFile=""String_Node_Str"" + Settings.SETTINGS_FILE_NAME_PROPERTY + ""String_Node_Str""+ settingsfn+ ""String_Node_Str"";
      String logFile=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"" + logfn + ""String_Node_Str"";
      String jmxPasswordFile=installDirWindows + ""String_Node_Str"" + Constants.JMX_PASSWORD_FILENAME;
      String jmxArgs=getJMXPortParameter() + ""String_Node_Str"" + jmxPasswordFile+ ""String_Node_Str"";
      String httpTransferPortArgs=getHttpFileTransferArgs();
      String jmvArgs=""String_Node_Str"" + StringUtils.surjoin(getJarFiles(appName),installDirWindows + ""String_Node_Str"",""String_Node_Str"") + ""String_Node_Str"";
      String securityArgs=""String_Node_Str"" + ""String_Node_Str"" + installDirWindows + ""String_Node_Str""+ Constants.SECURITY_POLICY_FILE_NAME;
      String cmdline=StringUtils.conjoin(""String_Node_Str"",""String_Node_Str"",jmvArgs,settingsFile,logFile,jmxArgs,httpTransferPortArgs,securityArgs,appName);
      cmdline=cmdline.replaceAll(""String_Node_Str"",""String_Node_Str"");
      cmdline=cmdline.replaceAll(""String_Node_Str"",""String_Node_Str"");
      pwVbs.println(""String_Node_Str"");
      pwVbs.println(""String_Node_Str"" + ""String_Node_Str"" + cmdline + ""String_Node_Str"");
      pwVbs.println(""String_Node_Str"");
      pwVbs.println(""String_Node_Str"" + ""String_Node_Str"");
      pwVbs.println(""String_Node_Str"");
      pwVbs.println(""String_Node_Str"");
      pwRes.println(""String_Node_Str"" + ""String_Node_Str"" + installDirWindows + ""String_Node_Str"");
      pwRes.println(""String_Node_Str"" + ""String_Node_Str"" + vbs.getName());
    }
  finally {
      if (pwBat != null) {
        pwBat.close();
      }
      if (pwVbs != null) {
        pwVbs.close();
      }
      if (pwRes != null) {
        pwRes.close();
      }
    }
    appsToStart.add(res.getName());
  }
 catch (  IOException e) {
    throw new IOFailure(""String_Node_Str"" + appName,e);
  }
}","/** 
 * Write a windows start bat file.
 * @param dir               The directory to write the bat file to
 * @param appName           the java class to start
 * @param settingsfn        the settings file to use
 * @param logpropDir        the directory to place the log.prop file
 * @param loggingProperties the contents of the log.prop file
 */
private void writeStartBat(File dir,String appName,String settingsfn,File logpropDir,String loggingProperties){
  String logfn=writeLogPropertiesFile(appName,dir,logpropDir,loggingProperties).replace(""String_Node_Str"",""String_Node_Str"");
  try {
    File vbs=new File(dir,""String_Node_Str"");
    File batHelper=new File(dir,""String_Node_Str"");
    File res=new File(dir,""String_Node_Str"");
    PrintWriter pwRes=null;
    PrintWriter pwBat=null;
    PrintWriter pwVbs=null;
    try {
      pwRes=new PrintWriter(new FileWriter(res));
      pwBat=new PrintWriter(new FileWriter(batHelper));
      pwVbs=new PrintWriter(new FileWriter(vbs));
      pwBat.println(""String_Node_Str"" + ""String_Node_Str"" + installDirWindows + ""String_Node_Str"");
      pwBat.println(""String_Node_Str"" + StringUtils.surjoin(getJarFiles(appName),installDirWindows + ""String_Node_Str"",""String_Node_Str""));
      String settingsFile=""String_Node_Str"" + Settings.SETTINGS_FILE_NAME_PROPERTY + ""String_Node_Str""+ settingsfn+ ""String_Node_Str"";
      String logFile=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"" + logfn + ""String_Node_Str"";
      String jmxPasswordFile=installDirWindows + ""String_Node_Str"" + Constants.JMX_PASSWORD_FILENAME;
      String jmxArgs=getJMXPortParameter() + ""String_Node_Str"" + jmxPasswordFile+ ""String_Node_Str"";
      String httpTransferPortArgs=getHttpFileTransferArgs();
      String jmvArgs=""String_Node_Str"" + StringUtils.surjoin(getJarFiles(appName),installDirWindows + ""String_Node_Str"",""String_Node_Str"") + ""String_Node_Str"";
      String securityArgs=""String_Node_Str"" + ""String_Node_Str"" + installDirWindows + ""String_Node_Str""+ Constants.SECURITY_POLICY_FILE_NAME+ ""String_Node_Str"";
      String cmdline=StringUtils.conjoin(""String_Node_Str"",""String_Node_Str"",jmvArgs,settingsFile,logFile,jmxArgs,httpTransferPortArgs,securityArgs,appName);
      cmdline=cmdline.replaceAll(""String_Node_Str"",""String_Node_Str"");
      cmdline=cmdline.replaceAll(""String_Node_Str"",""String_Node_Str"");
      pwVbs.println(""String_Node_Str"");
      pwVbs.println(""String_Node_Str"" + ""String_Node_Str"" + cmdline + ""String_Node_Str"");
      pwVbs.println(""String_Node_Str"");
      pwVbs.println(""String_Node_Str"" + ""String_Node_Str"");
      pwVbs.println(""String_Node_Str"");
      pwVbs.println(""String_Node_Str"");
      pwRes.println(""String_Node_Str"" + ""String_Node_Str"" + installDirWindows + ""String_Node_Str"");
      pwRes.println(""String_Node_Str"" + ""String_Node_Str"" + vbs.getName());
    }
  finally {
      if (pwBat != null) {
        pwBat.close();
      }
      if (pwVbs != null) {
        pwVbs.close();
      }
      if (pwRes != null) {
        pwRes.close();
      }
    }
    appsToStart.add(res.getName());
  }
 catch (  IOException e) {
    throw new IOFailure(""String_Node_Str"" + appName,e);
  }
}",0.9970092869510468
90175,"/** 
 * Get the checksum of a single file in a bitarchive. Note that this method runs a batch job on the bitarchives, and therefore takes a long time.
 * @param ba The bitarchive to ask for checksum
 * @param filename
 * @return The MD5 checksums of the file, or the empty string if the file wasnot in the bitarchive.
 * @see ChecksumJob#parseLine(String)
 */
private List<String> getChecksums(Location ba,String filename){
  ChecksumJob checksumJob=new ChecksumJob();
  checksumJob.processOnlyFileNamed(filename);
  String res;
  try {
    PreservationArcRepositoryClient arcrep=ArcRepositoryClientFactory.getPreservationInstance();
    BatchStatus batchStatus=arcrep.batch(checksumJob,ba.getName());
    if (batchStatus.hasResultFile()) {
      ByteArrayOutputStream buf=new ByteArrayOutputStream();
      batchStatus.appendResults(buf);
      res=buf.toString();
    }
 else {
      res=""String_Node_Str"";
    }
  }
 catch (  NetarkivetException e) {
    log.warn(""String_Node_Str"" + ba + ""String_Node_Str"",e);
    return Collections.emptyList();
  }
  List<String> checksums=new ArrayList<String>();
  if (res.length() > 0) {
    String[] lines=res.split(""String_Node_Str"");
    for (    String s : lines) {
      try {
        KeyValuePair<String,String> fileChecksum=ChecksumJob.parseLine(s);
        if (!fileChecksum.getKey().equals(filename)) {
          log.debug(""String_Node_Str"" + fileChecksum.getKey() + ""String_Node_Str""+ ba+ ""String_Node_Str""+ filename+ ""String_Node_Str"");
        }
 else {
          checksums.add(fileChecksum.getValue());
        }
      }
 catch (      ArgumentNotValid e) {
        log.warn(""String_Node_Str"" + res + ""String_Node_Str""+ ba+ ""String_Node_Str""+ filename+ ""String_Node_Str"");
      }
    }
  }
  return checksums;
}","/** 
 * Get the checksum of a single file in a bitarchive. Note that this method runs a batch job on the bitarchives, and therefore takes a long time.
 * @param ba The bitarchive to ask for checksum
 * @param filename
 * @return The MD5 checksums of the file, or the empty string if the file wasnot in the bitarchive.
 * @see ChecksumJob#parseLine(String)
 */
static List<String> getChecksums(Location ba,String filename){
  ChecksumJob checksumJob=new ChecksumJob();
  checksumJob.processOnlyFileNamed(filename);
  String res;
  try {
    PreservationArcRepositoryClient arcrep=ArcRepositoryClientFactory.getPreservationInstance();
    BatchStatus batchStatus=arcrep.batch(checksumJob,ba.getName());
    if (batchStatus.hasResultFile()) {
      ByteArrayOutputStream buf=new ByteArrayOutputStream();
      batchStatus.appendResults(buf);
      res=buf.toString();
    }
 else {
      res=""String_Node_Str"";
    }
  }
 catch (  NetarkivetException e) {
    log.warn(""String_Node_Str"" + ba + ""String_Node_Str"",e);
    return Collections.emptyList();
  }
  List<String> checksums=new ArrayList<String>();
  if (res.length() > 0) {
    String[] lines=res.split(""String_Node_Str"");
    for (    String s : lines) {
      try {
        KeyValuePair<String,String> fileChecksum=ChecksumJob.parseLine(s);
        if (!fileChecksum.getKey().equals(filename)) {
          log.debug(""String_Node_Str"" + fileChecksum.getKey() + ""String_Node_Str""+ ba+ ""String_Node_Str""+ filename+ ""String_Node_Str"");
        }
 else {
          checksums.add(fileChecksum.getValue());
        }
      }
 catch (      ArgumentNotValid e) {
        log.warn(""String_Node_Str"" + res + ""String_Node_Str""+ ba+ ""String_Node_Str""+ filename+ ""String_Node_Str"");
      }
    }
  }
  return checksums;
}",0.9963183234211272
90176,"/** 
 * Generate a map of checksums for this file in the bitarchive.
 * @return Map containing the output of checksum jobs from the bitarchives.
 * @param filename
 */
private Map<Location,List<String>> getChecksumMap(String filename){
  Map<Location,List<String>> baname2checksum=new HashMap<Location,List<String>>();
  for (  Location ba : Location.getKnown()) {
    List<String> checksum=getChecksums(ba,filename);
    log.debug(""String_Node_Str"" + checksum + ""String_Node_Str""+ ba);
    baname2checksum.put(ba,checksum);
  }
  return baname2checksum;
}","/** 
 * Generate a map of checksums for this file in the bitarchive.
 * @return Map containing the output of checksum jobs from the bitarchives.
 * @param filename
 */
static Map<Location,List<String>> getChecksumMap(String filename){
  Map<Location,List<String>> baname2checksum=new HashMap<Location,List<String>>();
  for (  Location ba : Location.getKnown()) {
    List<String> checksum=getChecksums(ba,filename);
    log.debug(""String_Node_Str"" + checksum + ""String_Node_Str""+ ba);
    baname2checksum.put(ba,checksum);
  }
  return baname2checksum;
}",0.9882988298829884
90177,"public void run(){
synchronized (waitThread) {
    waitThread.interrupt();
  }
}","public void run(){
synchronized (waitThread) {
    if (!doneWaiting.get()) {
      waitThread.interrupt();
    }
  }
}",0.8080808080808081
90178,"/** 
 * Wait for the end of a process, but only for a limited time.  This method takes care of the ways waitFor can get interrupted.
 * @param p Process to wait for
 * @param maxWait
 * @return Exit value for process, or null if the process didn't exitwithin the expected time.
 */
public static Integer waitFor(Process p,long maxWait){
  long startTime=System.currentTimeMillis();
  Timer timer=new Timer(true);
  final Thread waitThread=Thread.currentThread();
  boolean wakeupScheduled=false;
  while (System.currentTimeMillis() < startTime + maxWait) {
    try {
      if (!wakeupScheduled) {
synchronized (waitThread) {
          timer.schedule(new TimerTask(){
            public void run(){
synchronized (waitThread) {
                waitThread.interrupt();
              }
            }
          }
,maxWait);
          wakeupScheduled=true;
          return p.waitFor();
        }
      }
 else {
        return p.waitFor();
      }
    }
 catch (    InterruptedException e) {
    }
  }
  return null;
}","/** 
 * Wait for the end of a process, but only for a limited time.  This method takes care of the ways waitFor can get interrupted.
 * @param p Process to wait for
 * @param maxWait
 * @return Exit value for process, or null if the process didn't exitwithin the expected time.
 */
public static Integer waitFor(final Process p,long maxWait){
  long startTime=System.currentTimeMillis();
  Timer timer=new Timer(true);
  final Thread waitThread=Thread.currentThread();
  boolean wakeupScheduled=false;
  final AtomicBoolean doneWaiting=new AtomicBoolean(false);
  while (System.currentTimeMillis() < startTime + maxWait) {
    try {
      if (!wakeupScheduled) {
synchronized (waitThread) {
          timer.schedule(new TimerTask(){
            public void run(){
synchronized (waitThread) {
                if (!doneWaiting.get()) {
                  waitThread.interrupt();
                }
              }
            }
          }
,maxWait);
          wakeupScheduled=true;
        }
      }
      p.waitFor();
      break;
    }
 catch (    InterruptedException e) {
    }
  }
synchronized (waitThread) {
    timer.cancel();
    doneWaiting.set(true);
    Thread.interrupted();
  }
  try {
    return p.exitValue();
  }
 catch (  IllegalThreadStateException e) {
    log.warn(""String_Node_Str"" + p + ""String_Node_Str""+ (System.currentTimeMillis() - startTime)+ ""String_Node_Str"");
    return null;
  }
}",0.7530966143682907
90179,"public static void addToSuite(TestSuite suite){
  suite.addTestSuite(ApplicationUtilsTester.class);
  suite.addTestSuite(ExceptionUtilsTester.class);
  suite.addTestSuite(FileUtilsTester.class);
  suite.addTestSuite(FilterIteratorTester.class);
  suite.addTestSuite(MD5Tester.class);
  suite.addTestSuite(SimpleXmlTester.class);
  suite.addTestSuite(StringUtilsTester.class);
  suite.addTestSuite(SystemUtilsTester.class);
  suite.addTestSuite(XmlUtilsTester.class);
  suite.addTestSuite(ZipUtilsTester.class);
  suite.addTestSuite(LargeFileGZIPInputStreamTester.class);
}","public static void addToSuite(TestSuite suite){
  suite.addTestSuite(ApplicationUtilsTester.class);
  suite.addTestSuite(ExceptionUtilsTester.class);
  suite.addTestSuite(FileUtilsTester.class);
  suite.addTestSuite(FilterIteratorTester.class);
  suite.addTestSuite(LargeFileGZIPInputStreamTester.class);
  suite.addTestSuite(MD5Tester.class);
  suite.addTestSuite(ProcessUtilsTester.class);
  suite.addTestSuite(SettingsFactoryTester.class);
  suite.addTestSuite(SimpleXmlTester.class);
  suite.addTestSuite(StreamUtilsTester.class);
  suite.addTestSuite(StringUtilsTester.class);
  suite.addTestSuite(SystemUtilsTester.class);
  suite.addTestSuite(XmlTreeTester.class);
  suite.addTestSuite(XmlUtilsTester.class);
  suite.addTestSuite(ZipUtilsTester.class);
}",0.4591147786946736
90180,"/** 
 * Submit an ObjectMessage to the destination channel.
 * @param nMsg the NetarkivetMessage to be wrapped and send as an ObjectMessage
 * @param to the destination channel
 * @throws IOFailure if message failed to be sent.
 */
protected void sendMessage(NetarkivetMessage nMsg,ChannelID to) throws IOFailure {
  JMSException lastException=null;
  boolean operationSuccessful=false;
  int tries=0;
  while (!operationSuccessful || tries < JMS_MAXTRIES) {
    tries++;
    try {
      if (to.isTopic()) {
        sendToTopic(nMsg,to);
      }
 else {
        sendToQueue(nMsg,to);
      }
      operationSuccessful=true;
    }
 catch (    JMSException e) {
      log.warn(""String_Node_Str"" + tries + ""String_Node_Str""+ e);
      lastException=e;
    }
  }
  if (!operationSuccessful) {
    throw new IOFailure(""String_Node_Str"",lastException);
  }
}","/** 
 * Submit an ObjectMessage to the destination channel.
 * @param nMsg the NetarkivetMessage to be wrapped and send as an ObjectMessage
 * @param to the destination channel
 * @throws IOFailure if message failed to be sent.
 */
protected void sendMessage(NetarkivetMessage nMsg,ChannelID to) throws IOFailure {
  JMSException lastException=null;
  boolean operationSuccessful=false;
  int tries=0;
  while (!operationSuccessful && tries < JMS_MAXTRIES) {
    tries++;
    while (reconnectInProgress.get() != false) {
      log.warn(""String_Node_Str"");
      exponentialBackoffSleep(tries);
    }
    try {
      if (to.isTopic()) {
        sendToTopic(nMsg,to);
      }
 else {
        sendToQueue(nMsg,to);
      }
      operationSuccessful=true;
    }
 catch (    JMSException e) {
      log.warn(""String_Node_Str"" + tries + ""String_Node_Str""+ e);
      lastException=e;
    }
  }
  if (!operationSuccessful) {
    throw new IOFailure(""String_Node_Str"",lastException);
  }
}",0.9279475982532752
90181,"/** 
 * Clean up.
 */
public void cleanup(){
  try {
    if (myQConn != null) {
      myQConn.close();
    }
    myQConn=null;
    if (myTConn != null) {
      myTConn.close();
    }
    myTConn=null;
    if (consumers != null) {
      consumers.clear();
    }
    consumers=null;
    if (senders != null) {
      senders.clear();
    }
    senders=null;
    if (publishers != null) {
      publishers.clear();
    }
  }
 catch (  JMSException e) {
    throw new IOFailure(""String_Node_Str"",e);
  }
}","/** 
 * Clean up.
 */
public void cleanup(){
  while (reconnectInProgress.get() != false) {
    log.warn(""String_Node_Str"");
    exponentialBackoffSleep(1);
  }
  try {
    if (myQConn != null) {
      myQConn.close();
    }
    myQConn=null;
    if (myTConn != null) {
      myTConn.close();
    }
    myTConn=null;
    if (consumers != null) {
      consumers.clear();
    }
    consumers=null;
    if (senders != null) {
      senders.clear();
    }
    senders=null;
    if (publishers != null) {
      publishers.clear();
    }
  }
 catch (  JMSException e) {
    throw new IOFailure(""String_Node_Str"",e);
  }
}",0.8960573476702509
90182,"/** 
 * Remove all messages waiting in a queue/topic. When this method ends, there are no messages on the queue/topic (though some can still arrive afterwards). For a queue, this does not ensure that all messages disappear, other processes could still make it in and take some. For a topic, this does not ensure that nobody will receive these messages.
 * @param mq The queue/topic to remove messages from
 * @return A list of all messages removed from the queue/topic.
 */
public List<Message> removeAllMessages(ChannelID mq){
  throw new NotImplementedException(""String_Node_Str"");
}","/** 
 * Remove all messages waiting in a queue/topic. When this method ends, there are no messages on the queue/topic (though some can still arrive afterwards). For a queue, this does not ensure that all messages disappear, other processes could still make it in and take some. For a topic, this does not ensure that nobody will receive these messages.
 * @param mq The queue/topic to remove messages from
 * @return A list of all messages removed from the queue/topic.
 */
public List<Message> removeAllMessages(ChannelID mq){
  ArgumentNotValid.checkNotNull(mq,""String_Node_Str"");
  log.info(""String_Node_Str"" + mq);
  MessageConsumer consumer=null;
  List<Message> messages=null;
  String message=""String_Node_Str"" + mq + ""String_Node_Str"";
  int tries=0;
  JMSException lastException=null;
  boolean operationSuccessful=false;
  while (!operationSuccessful && tries < JMS_MAXTRIES) {
    tries++;
    while (reconnectInProgress.get() != false) {
      log.warn(""String_Node_Str"");
      exponentialBackoffSleep(1);
    }
    try {
      messages=new ArrayList<Message>();
      if (mq.isTopic()) {
        consumer=myTSess.createSubscriber(getTopic(mq.getName()));
      }
 else {
        consumer=myQSess.createReceiver(getQueue(mq.getName()));
      }
      Message msg;
      while ((msg=consumer.receiveNoWait()) != null) {
        messages.add(msg);
      }
      consumer.close();
      operationSuccessful=true;
    }
 catch (    JMSException e) {
      lastException=e;
      if (consumer != null) {
        try {
          consumer.close();
        }
 catch (        JMSException e1) {
        }
      }
      log.warn(message,e);
      exponentialBackoffSleep(tries);
    }
  }
  if (!operationSuccessful) {
    throw new IOFailure(message,lastException);
  }
  return messages;
}",0.474989491382934
90183,"/** 
 * Method adds a listener to the given queue or topic.
 * @param mq the messagequeue to listen to
 * @param ml the messagelistener
 * @throws IOFailure if the operation failed.
 */
public void setListener(ChannelID mq,MessageListener ml) throws IOFailure {
  ArgumentNotValid.checkNotNull(mq,""String_Node_Str"");
  ArgumentNotValid.checkNotNull(ml,""String_Node_Str"");
  log.debug(""String_Node_Str"" + ml.toString() + ""String_Node_Str""+ mq.toString());
  String errMsg=""String_Node_Str"" + mq.getName();
  String key=getConsumerKey(mq,ml);
  int tries=0;
  boolean operationSuccessful=false;
  JMSException lastException=null;
  while (!operationSuccessful || tries < JMS_MAXTRIES) {
    tries++;
    try {
      if (mq.isTopic()) {
        TopicSubscriber myTopicSubscriber=myTSess.createSubscriber(getTopic(mq.getName()));
        myTopicSubscriber.setMessageListener(ml);
        if (consumers.get(key) == null) {
          consumers.put(key,myTopicSubscriber);
        }
      }
 else {
        Queue queue=getQueue(mq.getName());
        QueueReceiver myQueueReceiver=myQSess.createReceiver(queue);
        myQueueReceiver.setMessageListener(ml);
        if (consumers.get(key) == null) {
          consumers.put(key,myQueueReceiver);
        }
      }
      operationSuccessful=true;
    }
 catch (    JMSException e) {
      lastException=e;
      log.warn(errMsg,e);
    }
  }
  if (!operationSuccessful) {
    throw new IOFailure(errMsg,lastException);
  }
}","/** 
 * Method adds a listener to the given queue or topic.
 * @param mq the messagequeue to listen to
 * @param ml the messagelistener
 * @throws IOFailure if the operation failed.
 */
public void setListener(ChannelID mq,MessageListener ml) throws IOFailure {
  ArgumentNotValid.checkNotNull(mq,""String_Node_Str"");
  ArgumentNotValid.checkNotNull(ml,""String_Node_Str"");
  log.debug(""String_Node_Str"" + ml.toString() + ""String_Node_Str""+ mq.toString());
  String errMsg=""String_Node_Str"" + mq.getName();
  String key=getConsumerKey(mq,ml);
  int tries=0;
  boolean operationSuccessful=false;
  JMSException lastException=null;
  while (!operationSuccessful && tries < JMS_MAXTRIES) {
    tries++;
    while (reconnectInProgress.get() != false) {
      log.warn(""String_Node_Str"");
      exponentialBackoffSleep(tries);
    }
    try {
      if (mq.isTopic()) {
        TopicSubscriber myTopicSubscriber=myTSess.createSubscriber(getTopic(mq.getName()));
        myTopicSubscriber.setMessageListener(ml);
        if (consumers.get(key) == null) {
          consumers.put(key,myTopicSubscriber);
        }
      }
 else {
        Queue queue=getQueue(mq.getName());
        QueueReceiver myQueueReceiver=myQSess.createReceiver(queue);
        myQueueReceiver.setMessageListener(ml);
        if (consumers.get(key) == null) {
          consumers.put(key,myQueueReceiver);
        }
      }
      operationSuccessful=true;
    }
 catch (    JMSException e) {
      lastException=e;
      log.warn(errMsg,e);
      exponentialBackoffSleep(tries);
    }
  }
  if (!operationSuccessful) {
    throw new IOFailure(errMsg,lastException);
  }
}",0.9451966473243067
90184,"/** 
 * Submit an object to the reply queue. We try to do it JMX_MAXTRIES times before giving up.
 * @param nMsg The NetarkivetMessage to send to the reply queue (null not allowed)
 * @throws ArgumentNotValid if nMsg is null.
 * @throws IOFailure if the operation failed.
 */
public void reply(NetarkivetMessage nMsg){
  ArgumentNotValid.checkNotNull(nMsg,""String_Node_Str"");
  JMSException lastException=null;
  boolean operationSuccessful=false;
  int tries=0;
  while (!operationSuccessful || tries < JMS_MAXTRIES) {
    tries++;
    try {
      tries++;
      ObjectMessage msg=myQSess.createObjectMessage(nMsg);
      String queueName=nMsg.getReplyTo().getName();
      QueueSender queueSender=senders.get(queueName);
      if (queueSender == null) {
        queueSender=myQSess.createSender(getQueue(queueName));
        senders.put(queueName,queueSender);
      }
synchronized (nMsg) {
        log.debug(""String_Node_Str"" + queueName + ""String_Node_Str""+ nMsg.replyOfId);
        queueSender.send(msg);
        log.debug(""String_Node_Str"" + queueSender.getQueue().getQueueName());
        nMsg.updateId(msg.getJMSMessageID());
      }
      operationSuccessful=true;
    }
 catch (    JMSException e) {
      log.warn(""String_Node_Str"" + tries + ""String_Node_Str""+ e);
      lastException=e;
    }
  }
  if (!operationSuccessful) {
    throw new IOFailure(""String_Node_Str"",lastException);
  }
}","/** 
 * Submit an object to the reply queue. We try to do it JMX_MAXTRIES times before giving up.
 * @param nMsg The NetarkivetMessage to send to the reply queue (null not allowed)
 * @throws ArgumentNotValid if nMsg is null.
 * @throws IOFailure if the operation failed.
 */
public void reply(NetarkivetMessage nMsg){
  ArgumentNotValid.checkNotNull(nMsg,""String_Node_Str"");
  JMSException lastException=null;
  boolean operationSuccessful=false;
  int tries=0;
  while (!operationSuccessful && tries < JMS_MAXTRIES) {
    if (reconnectInProgress.get() != true) {
      try {
        tries++;
        ObjectMessage msg=myQSess.createObjectMessage(nMsg);
        String queueName=nMsg.getReplyTo().getName();
        QueueSender queueSender=senders.get(queueName);
        if (queueSender == null) {
          queueSender=myQSess.createSender(getQueue(queueName));
          senders.put(queueName,queueSender);
        }
synchronized (nMsg) {
          log.debug(""String_Node_Str"" + queueName + ""String_Node_Str""+ nMsg.replyOfId);
          queueSender.send(msg);
          log.debug(""String_Node_Str"" + queueSender.getQueue().getQueueName());
          nMsg.updateId(msg.getJMSMessageID());
        }
        operationSuccessful=true;
      }
 catch (      JMSException e) {
        log.warn(""String_Node_Str"" + tries + ""String_Node_Str""+ e);
        lastException=e;
      }
    }
  }
  if (!operationSuccessful) {
    throw new IOFailure(""String_Node_Str"",lastException);
  }
}",0.95558639833449
90185,"/** 
 * Exceptionhandler for the JMSConnection. Only handles exceptions, if reconnectInProgress is false. Only handles exceptions with errorcode PACKET_ACK_FAILED or SESSION_IS_CLOSED.
 * @param e an JMSException
 */
public void onException(JMSException e){
  ArgumentNotValid.checkNotNull(e,""String_Node_Str"");
  final String errorcode=e.getErrorCode();
  log.warn(""String_Node_Str"" + errorcode + ""String_Node_Str""+ e);
  if (!reconnectInProgress) {
    handleJMSException(e);
  }
}","/** 
 * Exceptionhandler for the JMSConnection. Only handles exceptions, if reconnectInProgress is false. Only handles exceptions with errorcode PACKET_ACK_FAILED or SESSION_IS_CLOSED.
 * @param e an JMSException
 */
public void onException(JMSException e){
  ArgumentNotValid.checkNotNull(e,""String_Node_Str"");
  final String errorcode=e.getErrorCode();
  log.warn(""String_Node_Str"" + errorcode + ""String_Node_Str""+ e);
  if (errorcode.equals(PACKET_ACK_FAILED) || errorcode.equals(SESSION_IS_CLOSED) || errorcode.equals(RECEIVED_GOODBYE_FROM_BROKER)) {
    if (reconnectInProgress.compareAndSet(false,true)) {
      performReconnect(e);
    }
 else {
      log.warn(""String_Node_Str"" + e);
    }
  }
 else {
    log.warn(""String_Node_Str"" + errorcode);
  }
}",0.7176186645213194
90186,"/** 
 * Updates the harvest definition with posted values.
 * @param context The context that the web request processing happens in
 * @param i18n Translation information for this site section.
 * @param unknownDomains List to add unknown but legal domains to.
 * @param illegalDomains List to add illegal domains to.
 * @return The updated harvest definition.  This object holds an editionthat is legal to use for further updates (adding or deleting domains)
 */
private static PartialHarvest updateHarvestDefinition(PageContext context,I18n i18n,List<String> unknownDomains,List<String> illegalDomains){
  ServletRequest request=context.getRequest();
  HTMLUtils.forwardOnEmptyParameter(context,Constants.HARVEST_PARAM,Constants.SCHEDULE_PARAM);
  String name=request.getParameter(Constants.HARVEST_PARAM);
  HTMLUtils.forwardOnMissingParameter(context,Constants.COMMENTS_PARAM,Constants.DOMAINLIST_PARAM);
  String scheduleName=request.getParameter(Constants.SCHEDULE_PARAM);
  Schedule sched=ScheduleDAO.getInstance().read(scheduleName);
  if (sched == null) {
    HTMLUtils.forwardWithErrorMessage(context,i18n,""String_Node_Str"",sched);
    throw new ForwardedToErrorPage(""String_Node_Str"" + sched + ""String_Node_Str"");
  }
  String comments=request.getParameter(Constants.COMMENTS_PARAM);
  List<DomainConfiguration> dc=getDomainConfigurations(request.getParameterMap());
  addDomainsToConfigurations(dc,request.getParameter(Constants.DOMAINLIST_PARAM),unknownDomains,illegalDomains);
  HarvestDefinitionDAO hddao=HarvestDefinitionDAO.getInstance();
  if ((request.getParameter(Constants.CREATENEW_PARAM) != null)) {
    if (hddao.getHarvestDefinition(name) != null) {
      HTMLUtils.forwardWithErrorMessage(context,i18n,""String_Node_Str"",name);
      throw new ForwardedToErrorPage(""String_Node_Str"" + ""String_Node_Str"" + name + ""String_Node_Str"");
    }
    PartialHarvest hdd=new PartialHarvest(dc,sched,name,comments);
    hdd.setActive(false);
    hddao.create(hdd);
    return hdd;
  }
 else {
    long edition=HTMLUtils.parseOptionalLong(context,Constants.EDITION_PARAM,Constants.NO_EDITION);
    PartialHarvest hdd=(PartialHarvest)hddao.getHarvestDefinition(name);
    if (hdd.getEdition() != edition) {
      HTMLUtils.forwardWithRawErrorMessage(context,i18n,""String_Node_Str"",""String_Node_Str"" + Constants.HARVEST_PARAM + ""String_Node_Str""+ HTMLUtils.encodeAndEscapeHTML(name)+ ""String_Node_Str"",""String_Node_Str"");
      throw new ForwardedToErrorPage(""String_Node_Str"" + name + ""String_Node_Str"");
    }
    hdd.setDomainConfigurations(dc);
    hdd.setSchedule(sched);
    hdd.setComments(comments);
    hddao.update(hdd);
    return hdd;
  }
}","/** 
 * Updates the harvest definition with posted values.
 * @param context The context that the web request processing happens in
 * @param i18n Translation information for this site section.
 * @param unknownDomains List to add unknown but legal domains to.
 * @param illegalDomains List to add illegal domains to.
 * @return The updated harvest definition.  This object holds an editionthat is legal to use for further updates (adding or deleting domains)
 */
private static PartialHarvest updateHarvestDefinition(PageContext context,I18n i18n,List<String> unknownDomains,List<String> illegalDomains){
  ServletRequest request=context.getRequest();
  HTMLUtils.forwardOnEmptyParameter(context,Constants.HARVEST_PARAM,Constants.SCHEDULE_PARAM);
  String name=request.getParameter(Constants.HARVEST_PARAM);
  HTMLUtils.forwardOnMissingParameter(context,Constants.COMMENTS_PARAM,Constants.DOMAINLIST_PARAM);
  String scheduleName=request.getParameter(Constants.SCHEDULE_PARAM);
  Schedule sched=ScheduleDAO.getInstance().read(scheduleName);
  if (sched == null) {
    HTMLUtils.forwardWithErrorMessage(context,i18n,""String_Node_Str"",scheduleName);
    throw new ForwardedToErrorPage(""String_Node_Str"" + scheduleName + ""String_Node_Str"");
  }
  String comments=request.getParameter(Constants.COMMENTS_PARAM);
  List<DomainConfiguration> dc=getDomainConfigurations(request.getParameterMap());
  addDomainsToConfigurations(dc,request.getParameter(Constants.DOMAINLIST_PARAM),unknownDomains,illegalDomains);
  HarvestDefinitionDAO hddao=HarvestDefinitionDAO.getInstance();
  if ((request.getParameter(Constants.CREATENEW_PARAM) != null)) {
    if (hddao.getHarvestDefinition(name) != null) {
      HTMLUtils.forwardWithErrorMessage(context,i18n,""String_Node_Str"",name);
      throw new ForwardedToErrorPage(""String_Node_Str"" + ""String_Node_Str"" + name + ""String_Node_Str"");
    }
    PartialHarvest hdd=new PartialHarvest(dc,sched,name,comments);
    hdd.setActive(false);
    hddao.create(hdd);
    return hdd;
  }
 else {
    long edition=HTMLUtils.parseOptionalLong(context,Constants.EDITION_PARAM,Constants.NO_EDITION);
    PartialHarvest hdd=(PartialHarvest)hddao.getHarvestDefinition(name);
    if (hdd.getEdition() != edition) {
      HTMLUtils.forwardWithRawErrorMessage(context,i18n,""String_Node_Str"",""String_Node_Str"" + Constants.HARVEST_PARAM + ""String_Node_Str""+ HTMLUtils.encodeAndEscapeHTML(name)+ ""String_Node_Str"",""String_Node_Str"");
      throw new ForwardedToErrorPage(""String_Node_Str"" + name + ""String_Node_Str"");
    }
    hdd.setDomainConfigurations(dc);
    hdd.setSchedule(sched);
    hdd.setComments(comments);
    hddao.update(hdd);
    return hdd;
  }
}",0.997378277153558
90187,"/** 
 * Given a list of domain configurations and a list of domains, add the default configurations for the domains to the configuration list. If any of the domains are unknown, their names are instead appended to the argument unknownDomains (with newline separation)
 * @param dc the initial list of configurations
 * @param extraDomains the domains to be added to dc with defaultconfigurations
 * @param unknownDomains a list to add unknonw, legal domains to
 * @param illegalDomains a list to add illegal domains to
 */
private static void addDomainsToConfigurations(List<DomainConfiguration> dc,String extraDomains,List<String> unknownDomains,List<String> illegalDomains){
  String[] domains=extraDomains.split(""String_Node_Str"");
  DomainDAO ddao=DomainDAO.getInstance();
  for (  String domain : domains) {
    domain=domain.trim();
    if (domain.length() > 0) {
      if (ddao.exists(domain)) {
        Domain d=ddao.read(domain);
        if (!dc.contains(d.getDefaultConfiguration())) {
          dc.add(d.getDefaultConfiguration());
        }
      }
 else {
        if (Domain.isValidDomainName(domain)) {
          unknownDomains.add(domain);
        }
 else {
          illegalDomains.add(domain);
        }
      }
    }
  }
}","/** 
 * Given a list of domain configurations and a list of domains, add the default configurations for the domains to the configuration list. If any of the domains are unknown, their names are instead appended to the argument unknownDomains (with newline separation)
 * @param dc the initial list of configurations
 * @param extraDomains the domains to be added to dc with defaultconfigurations
 * @param unknownDomains a list to add unknown, legal domains to
 * @param illegalDomains a list to add illegal domains to
 */
private static void addDomainsToConfigurations(List<DomainConfiguration> dc,String extraDomains,List<String> unknownDomains,List<String> illegalDomains){
  String[] domains=extraDomains.split(""String_Node_Str"");
  DomainDAO ddao=DomainDAO.getInstance();
  for (  String domain : domains) {
    domain=domain.trim();
    if (domain.length() > 0) {
      if (ddao.exists(domain)) {
        Domain d=ddao.read(domain);
        if (!dc.contains(d.getDefaultConfiguration())) {
          dc.add(d.getDefaultConfiguration());
        }
      }
 else {
        if (Domain.isValidDomainName(domain)) {
          unknownDomains.add(domain);
        }
 else {
          illegalDomains.add(domain);
        }
      }
    }
  }
}",0.9991935483870968
90188,"/** 
 * Constructs a channel name according to the specifications in distributed_architecture.doc.
 * @param app The name of the applications listening to the channel.
 * @param locationName Name of the location, or ChannelID.COMMON ifchannel common to both locations.
 * @param useNodeId Whether that IP address of the local node shouldbe included in the channel name.
 * @param useProcId Whether process identifier (= IP port# used for communication) should be included in the channel name.
 * @return The properly concatenated channel name.
 * @throws UnknownID if looking up the local IP number failed.
 */
private static String constructName(String app,String locationName,boolean useNodeId,boolean useProcId){
  String userId=environmentName;
  String id=""String_Node_Str"";
  if (useNodeId) {
    id=SystemUtils.getLocalIP().replace('.','_');
    if (useProcId) {
      id+=(""String_Node_Str"" + httpPortNumber);
    }
  }
  return userId + ""String_Node_Str"" + locationName+ ""String_Node_Str""+ app+ (id.equals(""String_Node_Str"") ? ""String_Node_Str"" : (""String_Node_Str"" + id));
}","/** 
 * Constructs a channel name according to the specifications in distributed_architecture.doc.
 * @param app The name of the applications listening to the channel.
 * @param locationName Name of the location, or ChannelID.COMMON ifchannel common to both locations.
 * @param useNodeId Whether that IP address of the local node shouldbe included in the channel name.
 * @param useProcId Whether process identifier (= IP port# used for communication) should be included in the channel name.
 * @return The properly concatenated channel name.
 * @throws UnknownID if looking up the local IP number failed.
 */
private String constructName(String app,String locationName,boolean useNodeId,boolean useProcId){
  String userId=environmentName;
  String id=""String_Node_Str"";
  if (useNodeId) {
    id=SystemUtils.getLocalIP().replace('.','_');
    if (useProcId) {
      id+=(""String_Node_Str"" + httpPortNumber);
    }
  }
  return userId + ""String_Node_Str"" + locationName+ ""String_Node_Str""+ app+ (id.equals(""String_Node_Str"") ? ""String_Node_Str"" : (""String_Node_Str"" + id));
}",0.996760758907913
90189,"/** 
 * Given an location, returns the BAMON queue to which batch jobs must be sent in order to run them on that locations bitarchive.
 * @param location the location
 * @return the channel
 * @throws ArgumentNotValid if the location is null, unknown, or empty string
 */
public static ChannelID getBaMonForLocation(String location) throws ArgumentNotValid {
  ArgumentNotValid.checkNotNullOrEmpty(location,""String_Node_Str"");
  ChannelID[] bamons=getAllArchives_BAMONs();
  for (  ChannelID bamon : bamons) {
    if ((bamon.getName().split(""String_Node_Str"")[1]).equals(location)) {
      return bamon;
    }
  }
  throw new ArgumentNotValid(""String_Node_Str"" + location);
}","/** 
 * Given an location, returns the BAMON queue to which batch jobs must be sent in order to run them on that locations bitarchive.
 * @param location the location
 * @return the channel
 * @throws ArgumentNotValid if the location is null, unknown, or empty string
 */
public static ChannelID getBaMonForLocation(String location) throws ArgumentNotValid {
  ArgumentNotValid.checkNotNullOrEmpty(location,""String_Node_Str"");
  ChannelID[] bamons=getAllArchives_BAMONs();
  for (  ChannelID bamon : bamons) {
    if (bamon.getName().equals(Settings.get(Settings.ENVIRONMENT_NAME) + ""String_Node_Str"" + location+ ""String_Node_Str"")) {
      return bamon;
    }
  }
  throw new ArgumentNotValid(""String_Node_Str"" + location);
}",0.9236259814418272
90190,"/** 
 * Test method to get BAMOn channel for a particular location.
 */
public void testGetBAMONForLocation(){
  ChannelID ch1=Channels.getBaMonForLocation(""String_Node_Str"");
  assertFalse(""String_Node_Str"" + ch1.getName(),ch1.getName().lastIndexOf(""String_Node_Str"") == -1);
  ChannelID ch2=Channels.getBaMonForLocation(""String_Node_Str"");
  assertFalse(""String_Node_Str"" + ch2.getName(),ch2.getName().lastIndexOf(""String_Node_Str"") == -1);
  try {
    ChannelID ch3=Channels.getBaMonForLocation(""String_Node_Str"");
    fail(""String_Node_Str"" + ch3.getName());
  }
 catch (  ArgumentNotValid e) {
  }
}","/** 
 * Test method to get BAMOn channel for a particular location.
 */
public void testGetBAMONForLocation(){
  ChannelID ch1=Channels.getBaMonForLocation(""String_Node_Str"");
  assertFalse(""String_Node_Str"" + ch1.getName(),ch1.getName().lastIndexOf(""String_Node_Str"") == -1);
  ChannelID ch2=Channels.getBaMonForLocation(""String_Node_Str"");
  assertFalse(""String_Node_Str"" + ch2.getName(),ch2.getName().lastIndexOf(""String_Node_Str"") == -1);
  try {
    ChannelID ch3=Channels.getBaMonForLocation(""String_Node_Str"");
    fail(""String_Node_Str"" + ch3.getName());
  }
 catch (  ArgumentNotValid e) {
  }
  Settings.set(Settings.ENVIRONMENT_NAME,""String_Node_Str"");
  Channels.reset();
  ChannelID ch=Channels.getBaMonForLocation(""String_Node_Str"");
  StringAsserts.assertStringContains(""String_Node_Str"",""String_Node_Str"",ch.getName());
}",0.8383067314365025
90191,"/** 
 * Strips a path prefix from a file name.
 * @param dir The path prefix to remove from the given file's name.
 * @param f   The file to remove the path prefix from.
 * @return The name of the file without the specified path prefix.
 */
private static String removePrefixDir(File dir,File f){
  String key=f.getAbsolutePath().replaceAll(dir.getAbsolutePath(),""String_Node_Str"");
  return key;
}","/** 
 * Strips a path prefix from a file name.
 * @param dir The path prefix to remove from the given file's name.
 * @param f   The file to remove the path prefix from.
 * @return The name of the file without the specified path prefix.
 */
private static String removePrefixDir(File dir,File f){
  return f.getAbsolutePath().replaceAll(dir.getAbsolutePath(),""String_Node_Str"");
}",0.9588688946015425
90192,"/** 
 * Copy an entire directory from one location to another, skipping CVS directories. Note that this will silently overwrite old files, just like copyFile().
 * @param from Original directory (or file, for that matter) to copy.
 * @param to   Destination directory, i.e. the 'new name' of the copy of thefrom directory.
 * @throws IOFailure
 */
public static final void copyDirectoryNonCVS(File from,File to) throws IOFailure {
  if (from.isFile()) {
    try {
      FileUtils.copyFile(from,to);
    }
 catch (    Exception e) {
      throw new IOFailure(""String_Node_Str"" + from.getAbsolutePath() + ""String_Node_Str""+ to.getAbsolutePath());
    }
  }
 else {
    if (from.getName().equals(""String_Node_Str"")) {
      return;
    }
    if (from.getName().equals(""String_Node_Str"")) {
      return;
    }
    if (!from.exists()) {
      throw new IOFailure(""String_Node_Str"" + from);
    }
    if (!from.isDirectory()) {
      throw new IOFailure(""String_Node_Str"" + from);
    }
    to.mkdir();
    if (!to.exists()) {
      throw new IOFailure(""String_Node_Str"" + to);
    }
    File[] subfiles=from.listFiles();
    for (int i=0; i < subfiles.length; i++) {
      copyDirectoryNonCVS(subfiles[i],new File(to,subfiles[i].getName()));
    }
  }
}","/** 
 * Copy an entire directory from one location to another, skipping CVS directories. Note that this will silently overwrite old files, just like copyFile().
 * @param from Original directory (or file, for that matter) to copy.
 * @param to   Destination directory, i.e. the 'new name' of the copy of thefrom directory.
 * @throws IOFailure
 */
public static final void copyDirectoryNonCVS(File from,File to) throws IOFailure {
  if (from.isFile()) {
    try {
      FileUtils.copyFile(from,to);
    }
 catch (    Exception e) {
      throw new IOFailure(""String_Node_Str"" + from.getAbsolutePath() + ""String_Node_Str""+ to.getAbsolutePath(),e);
    }
  }
 else {
    if (from.getName().equals(""String_Node_Str"")) {
      return;
    }
    if (from.getName().equals(""String_Node_Str"")) {
      return;
    }
    if (!from.exists()) {
      throw new IOFailure(""String_Node_Str"" + from);
    }
    if (!from.isDirectory()) {
      throw new IOFailure(""String_Node_Str"" + from);
    }
    to.mkdir();
    if (!to.exists()) {
      throw new IOFailure(""String_Node_Str"" + to);
    }
    File[] subfiles=from.listFiles();
    for (    File subfile : subfiles) {
      copyDirectoryNonCVS(subfile,new File(to,subfile.getName()));
    }
  }
}",0.9782783588093322
90193,"/** 
 * Parse a crawl.log line into a valid CrawlDataItem. If CrawlLogIterator is ok with this line, we must make sure that it has an origin by finding missing ones in the CDX file. If multiple origins are found in the CDX files, the one that was harvested last is chosen. If no origin can be found, the item is rejected. We assume that super.parseLine() delivers us the items in the crawl.log in the given (sorted) order with non-null URLs, though we admit that some undeclared exceptions can be thrown by it.
 * @param line A crawl.log line to parse.
 * @return A CrawlDataItem with a valid origin field, or null if we couldnot determine an appropriate origin.
 * @throws IOFailure if there is an error reading the files.
 */
protected CrawlDataItem parseLine(String line){
  CrawlDataItem item;
  log.trace(""String_Node_Str"" + line);
  try {
    item=super.parseLine(line);
  }
 catch (  RuntimeException e) {
    log.debug(""String_Node_Str"" + line + ""String_Node_Str"",e);
    return null;
  }
  if (item != null && item.getContentDigest() != null) {
    if (item.getContentDigest().toLowerCase().startsWith(SHA1_PREFIX)) {
      item.setContentDigest(item.getContentDigest().substring(SHA1_PREFIX.length()));
    }
  }
  if (item != null && item.getOrigin() == null) {
    CDXRecord foundRecord=null;
    while (lastRecord == null || lastRecord.getURL().compareTo(item.getURL()) <= 0) {
      if (lastRecord != null && lastRecord.getURL().equals(item.getURL())) {
        if (foundRecord == null || lastRecord.getArcfile().compareTo(foundRecord.getArcfile()) > 0 || (lastRecord.getArcfile().equals(foundRecord.getArcfile())) && (lastRecord.getOffset() > foundRecord.getOffset())) {
          foundRecord=lastRecord;
          log.trace(""String_Node_Str"" + foundRecord.getArcfile() + ""String_Node_Str""+ foundRecord.getOffset()+ ""String_Node_Str"");
        }
      }
      try {
        String record=reader.readLine();
        if (record == null) {
          break;
        }
        if (record.length() == 0) {
          continue;
        }
        try {
          lastRecord=new CDXRecord(record);
        }
 catch (        ArgumentNotValid e) {
          log.debug(""String_Node_Str"" + record + ""String_Node_Str"",e);
          continue;
        }
        log.trace(""String_Node_Str"" + record + ""String_Node_Str"");
      }
 catch (      IOException e) {
        throw new IOFailure(""String_Node_Str"",e);
      }
    }
    if (foundRecord == null) {
      log.debug(""String_Node_Str"" + item.getURL() + ""String_Node_Str""+ (lastRecord == null ? ""String_Node_Str"" : lastRecord.getURL())+ ""String_Node_Str"");
      return null;
    }
    String origin=foundRecord.getArcfile() + ""String_Node_Str"" + foundRecord.getOffset();
    item.setOrigin(origin);
    log.debug(""String_Node_Str"" + item.getURL() + ""String_Node_Str""+ origin+ ""String_Node_Str"");
  }
  return item;
}","/** 
 * Parse a crawl.log line into a valid CrawlDataItem. If CrawlLogIterator is ok with this line, we must make sure that it has an origin by finding missing ones in the CDX file. If multiple origins are found in the CDX files, the one that was harvested last is chosen. If no origin can be found, the item is rejected. We assume that super.parseLine() delivers us the items in the crawl.log in the given (sorted) order with non-null URLs, though we admit that some undeclared exceptions can be thrown by it.
 * @param line A crawl.log line to parse.
 * @return A CrawlDataItem with a valid origin field, or null if we couldnot determine an appropriate origin.
 * @throws IOFailure if there is an error reading the files.
 */
protected CrawlDataItem parseLine(String line){
  CrawlDataItem item;
  log.trace(""String_Node_Str"" + line);
  try {
    item=super.parseLine(line);
  }
 catch (  RuntimeException e) {
    log.debug(""String_Node_Str"" + line + ""String_Node_Str"",e);
    return null;
  }
  if (item != null && item.getContentDigest() != null) {
    if (item.getContentDigest().toLowerCase().startsWith(SHA1_PREFIX)) {
      item.setContentDigest(item.getContentDigest().substring(SHA1_PREFIX.length()));
    }
  }
  if (item != null && item.getOrigin() == null) {
    CDXRecord foundRecord=null;
    while (lastRecord == null || lastRecord.getURL().compareTo(item.getURL()) <= 0) {
      if (lastRecord != null && lastRecord.getURL().equals(item.getURL())) {
        if (foundRecord == null || lastRecord.getDate().compareTo(foundRecord.getDate()) > 0) {
          foundRecord=lastRecord;
          log.trace(""String_Node_Str"" + foundRecord.getArcfile() + ""String_Node_Str""+ foundRecord.getOffset()+ ""String_Node_Str"");
        }
      }
      try {
        String record=reader.readLine();
        if (record == null) {
          break;
        }
        if (record.length() == 0) {
          continue;
        }
        try {
          lastRecord=new CDXRecord(record);
        }
 catch (        ArgumentNotValid e) {
          log.debug(""String_Node_Str"" + record + ""String_Node_Str"",e);
          continue;
        }
        log.trace(""String_Node_Str"" + record + ""String_Node_Str"");
      }
 catch (      IOException e) {
        throw new IOFailure(""String_Node_Str"",e);
      }
    }
    if (foundRecord == null) {
      log.debug(""String_Node_Str"" + item.getURL() + ""String_Node_Str""+ (lastRecord == null ? ""String_Node_Str"" : lastRecord.getURL())+ ""String_Node_Str"");
      return null;
    }
    String origin=foundRecord.getArcfile() + ""String_Node_Str"" + foundRecord.getOffset();
    item.setOrigin(origin);
    log.debug(""String_Node_Str"" + item.getURL() + ""String_Node_Str""+ origin+ ""String_Node_Str"");
  }
  return item;
}",0.97613110081938
90194,"/** 
 * Checks, if the CDXOriginCrawlLogIterator works with password protected contents, where one crawl.log corresponds with two CDXlines, and the correct one, (the last one) needs to be selected. bug 680
 * @throws Exception
 */
public void testbug680() throws Exception {
  Method sortCDX=ReflectUtils.getPrivateMethod(CrawlLogIndexCache.class,""String_Node_Str"",File.class,File.class);
  Method sortCrawlLog=ReflectUtils.getPrivateMethod(CrawlLogIndexCache.class,""String_Node_Str"",File.class,File.class);
  File unsortedCrawlLogFile=new File(TestInfo.CRAWLLOGS_DIR,""String_Node_Str"");
  File sortedCrawlLogFile=new File(TestInfo.CRAWLLOGS_DIR,""String_Node_Str"");
  File unsortedCDXFile=new File(TestInfo.CDXDATACACHE_DIR,""String_Node_Str"");
  File sortedCDXFile=new File(TestInfo.CDXDATACACHE_DIR,""String_Node_Str"");
  sortCrawlLog.invoke(null,unsortedCrawlLogFile,sortedCrawlLogFile);
  sortCDX.invoke(null,unsortedCDXFile,sortedCDXFile);
  BufferedReader cdx=new BufferedReader(new FileReader(sortedCDXFile));
  CDXOriginCrawlLogIterator it=new CDXOriginCrawlLogIterator(sortedCrawlLogFile,cdx);
  String privateUrl=""String_Node_Str"";
  assertTrue(""String_Node_Str"",it.hasNext());
  boolean foundPrivateUrl=false;
  CrawlDataItem item=null;
  while (!foundPrivateUrl && it.hasNext()) {
    item=it.next();
    if (item.getURL().equals(privateUrl)) {
      foundPrivateUrl=true;
    }
  }
  assertTrue(""String_Node_Str"",foundPrivateUrl);
  String correctOrigin=""String_Node_Str"";
  assertTrue(""String_Node_Str"",item.getOrigin().equals(correctOrigin));
}","/** 
 * Checks, if the CDXOriginCrawlLogIterator works with password protected contents, where one crawl.log corresponds with two CDXlines, and the correct one, (the last one) needs to be selected. bug 680
 * @throws Exception
 */
public void testbug680() throws Exception {
  Method sortCDX=ReflectUtils.getPrivateMethod(CrawlLogIndexCache.class,""String_Node_Str"",File.class,File.class);
  Method sortCrawlLog=ReflectUtils.getPrivateMethod(CrawlLogIndexCache.class,""String_Node_Str"",File.class,File.class);
  File unsortedCrawlLogFile=new File(TestInfo.CRAWLLOGS_DIR,""String_Node_Str"");
  File sortedCrawlLogFile=new File(TestInfo.CRAWLLOGS_DIR,""String_Node_Str"");
  File unsortedCDXFile=new File(TestInfo.CDXDATACACHE_DIR,""String_Node_Str"");
  File sortedCDXFile=new File(TestInfo.CDXDATACACHE_DIR,""String_Node_Str"");
  sortCrawlLog.invoke(null,unsortedCrawlLogFile,sortedCrawlLogFile);
  sortCDX.invoke(null,unsortedCDXFile,sortedCDXFile);
  BufferedReader cdx=new BufferedReader(new FileReader(sortedCDXFile));
  CDXOriginCrawlLogIterator it=new CDXOriginCrawlLogIterator(sortedCrawlLogFile,cdx);
  String privateUrl=""String_Node_Str"";
  assertTrue(""String_Node_Str"",it.hasNext());
  boolean foundPrivateUrl=false;
  CrawlDataItem item=null;
  while (!foundPrivateUrl && it.hasNext()) {
    item=it.next();
    if (item.getURL().equals(privateUrl)) {
      foundPrivateUrl=true;
    }
  }
  assertTrue(""String_Node_Str"",foundPrivateUrl);
  String correctOrigin=""String_Node_Str"";
  assertTrue(""String_Node_Str"",item.getOrigin().equals(correctOrigin));
  unsortedCrawlLogFile=new File(TestInfo.CRAWLLOGS_DIR,""String_Node_Str"");
  sortedCrawlLogFile=new File(TestInfo.CRAWLLOGS_DIR,""String_Node_Str"");
  unsortedCDXFile=new File(TestInfo.CDXDATACACHE_DIR,""String_Node_Str"");
  sortedCDXFile=new File(TestInfo.CDXDATACACHE_DIR,""String_Node_Str"");
  sortCrawlLog.invoke(null,unsortedCrawlLogFile,sortedCrawlLogFile);
  sortCDX.invoke(null,unsortedCDXFile,sortedCDXFile);
  cdx=new BufferedReader(new FileReader(sortedCDXFile));
  it=new CDXOriginCrawlLogIterator(sortedCrawlLogFile,cdx);
  assertTrue(""String_Node_Str"",it.hasNext());
  foundPrivateUrl=false;
  item=null;
  while (!foundPrivateUrl && it.hasNext()) {
    item=it.next();
    if (item.getURL().equals(privateUrl)) {
      foundPrivateUrl=true;
    }
  }
  assertTrue(""String_Node_Str"",foundPrivateUrl);
  correctOrigin=""String_Node_Str"";
  assertTrue(""String_Node_Str"" + correctOrigin + ""String_Node_Str""+ item.getOrigin()+ ""String_Node_Str"",item.getOrigin().equals(correctOrigin));
}",0.75840233804189
90195,"/** 
 * Auxiliary method to modify the orderXMLdoc Document with respect to setting the maximum number of bytes to retrieve per domain. This method updates 'group-max-all-kb' element of the 'QuotaEnforcer' node, which again is a subelement of 'pre-fetch-processors' node. with the value of the argument forceMaxBytesPerDomain
 * @param forceMaxBytesPerDomain The maximum number of byte to retrieve per domain, or -1 for no limit. Note that the number is divided by 1024 before being inserted into the orderXml, as Heritrix expects KB.
 * @throws PermissionDenied If unable to replace the QuotaEnforcer node of the orderXMLdoc Document
 * @throws IOFailure If the group-max-all-kb element cannot be found. TODO: This group-max-all-kb check also be performed in  TemplateDAO.create, TemplateDAO.update
 */
private void editOrderXML_maxBytesPerDomain(long forceMaxBytesPerDomain){
  String xpath=HeritrixTemplate.GroupMaxAllKbXpath;
  Node groupMaxSuccessKbNode=orderXMLdoc.selectSingleNode(xpath);
  if (groupMaxSuccessKbNode != null) {
    if (forceMaxBytesPerDomain != Constants.HERITRIX_MAXBYTES_INFINITY) {
      groupMaxSuccessKbNode.setText(Long.toString((forceMaxBytesPerDomain / BYTES_PER_HERITRIX_BYTELIMIT_UNIT) + 1));
    }
 else {
      groupMaxSuccessKbNode.setText(String.valueOf(Constants.HERITRIX_MAXBYTES_INFINITY));
    }
  }
 else {
    throw new IOFailure(""String_Node_Str"" + orderXMLdoc.asXML());
  }
}","/** 
 * Auxiliary method to modify the orderXMLdoc Document with respect to setting the maximum number of bytes to retrieve per domain. This method updates 'group-max-all-kb' element of the 'QuotaEnforcer' node, which again is a subelement of 'pre-fetch-processors' node. with the value of the argument forceMaxBytesPerDomain
 * @param forceMaxBytesPerDomain The maximum number of byte to retrieve per domain, or -1 for no limit. Note that the number is divided by 1024 before being inserted into the orderXml, as Heritrix expects KB.
 * @throws PermissionDenied If unable to replace the QuotaEnforcer node of the orderXMLdoc Document
 * @throws IOFailure If the group-max-all-kb element cannot be found. TODO: This group-max-all-kb check also be performed in TemplateDAO.create, TemplateDAO.update
 */
private void editOrderXML_maxBytesPerDomain(long forceMaxBytesPerDomain){
  String xpath=HeritrixTemplate.GROUP_MAX_ALL_KB_XPATH;
  Node groupMaxSuccessKbNode=orderXMLdoc.selectSingleNode(xpath);
  if (groupMaxSuccessKbNode != null) {
    if (forceMaxBytesPerDomain != Constants.HERITRIX_MAXBYTES_INFINITY) {
      groupMaxSuccessKbNode.setText(Long.toString((forceMaxBytesPerDomain / BYTES_PER_HERITRIX_BYTELIMIT_UNIT) + 1));
    }
 else {
      groupMaxSuccessKbNode.setText(String.valueOf(Constants.HERITRIX_MAXBYTES_INFINITY));
    }
  }
 else {
    throw new IOFailure(""String_Node_Str"" + orderXMLdoc.asXML());
  }
}",0.9884007029876976
90196,"/** 
 * Auxiliary method to modify the orderXMLdoc Document with respect to setting the maximum number of objects to be retrieved per domain. This method updates 'queue-total-budget' element of the frontier node (org.archive.crawler.frontier.BdbFrontier) with the value of the argument forceMaxObjectsPerDomain
 * @param forceMaxObjectsPerDomain The maximum number of objects to retrieve per domain, or 0 for no limit.
 * @throws PermissionDenied If unable to replace the frontier node of the orderXMLdoc Document
 * @throws IOFailure If the queue-total-budget element is not found in the orderXml. TODO: The queue-total-budget check should also be performed in TemplateDAO.create, TemplateDAO.update
 */
private void editOrderXML_maxObjectsPerDomain(long forceMaxObjectsPerDomain){
  String xpath=HeritrixTemplate.QueueTotalBudgetXpath;
  Node queueTotalBudgetNode=orderXMLdoc.selectSingleNode(xpath);
  if (queueTotalBudgetNode != null) {
    queueTotalBudgetNode.setText(String.valueOf(forceMaxObjectsPerDomain));
  }
 else {
    throw new IOFailure(""String_Node_Str"" + orderXMLdoc.asXML());
  }
}","/** 
 * Auxiliary method to modify the orderXMLdoc Document with respect to setting the maximum number of objects to be retrieved per domain. This method updates 'queue-total-budget' element of the frontier node (org.archive.crawler.frontier.BdbFrontier) with the value of the argument forceMaxObjectsPerDomain
 * @param forceMaxObjectsPerDomain The maximum number of objects to retrieve per domain, or 0 for no limit.
 * @throws PermissionDenied If unable to replace the frontier node of the orderXMLdoc Document
 * @throws IOFailure If the queue-total-budget element is not found in the orderXml. TODO: The queue-total-budget check should also be performed in TemplateDAO.create, TemplateDAO.update
 */
private void editOrderXML_maxObjectsPerDomain(long forceMaxObjectsPerDomain){
  String xpath=HeritrixTemplate.QUEUE_TOTAL_BUDGET_XPATH;
  Node queueTotalBudgetNode=orderXMLdoc.selectSingleNode(xpath);
  if (queueTotalBudgetNode != null) {
    queueTotalBudgetNode.setText(String.valueOf(forceMaxObjectsPerDomain));
  }
 else {
    throw new IOFailure(""String_Node_Str"" + orderXMLdoc.asXML());
  }
}",0.982296867907399
90197,"/** 
 * Updates this jobs order.xml to include filters defined by crawler traps for the given domain. The added nodes have the form <newObject name=""domain.dk{0,1,2,..}"" class=""org.archive.crawler.filter.URIRegExpFilter""> <boolean name=""enabled"">true</boolean> <boolean name=""if-match-return"">true</boolean> <string name=""regexp"">theregexp</string> </newObject>
 * @param d The domain for which to generate crawler traps.
 * @throws ArgumentNotValid If unable to order.xml due to wrong order.xml format
 */
private void editOrderXML_crawlerTraps(Domain d) throws ArgumentNotValid {
  List<String> crawlerTraps=d.getCrawlerTraps();
  if (crawlerTraps.size() == 0) {
    return;
  }
  String filterMapXpath=HeritrixTemplate.ExcludeFilterMapXpath;
  Node filterMapNode=orderXMLdoc.selectSingleNode(filterMapXpath);
  if (filterMapNode == null || !(filterMapNode instanceof Element)) {
    throw new PermissionDenied(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  }
  Element filterMap=(Element)filterMapNode;
  int count=0;
  for (  String trap : crawlerTraps) {
    Element filter=filterMap.addElement(""String_Node_Str"");
    filter.addAttribute(""String_Node_Str"",d.getName() + count);
    filter.addAttribute(""String_Node_Str"",""String_Node_Str"");
    Element enabled=filter.addElement(""String_Node_Str"");
    enabled.addAttribute(""String_Node_Str"",""String_Node_Str"");
    enabled.addText(""String_Node_Str"");
    Element ifMatchReturn=filter.addElement(""String_Node_Str"");
    ifMatchReturn.addAttribute(""String_Node_Str"",""String_Node_Str"");
    ifMatchReturn.addText(""String_Node_Str"");
    Element regexp=filter.addElement(""String_Node_Str"");
    regexp.addAttribute(""String_Node_Str"",""String_Node_Str"");
    regexp.addText(trap);
    count++;
  }
}","/** 
 * Updates this jobs order.xml to include filters defined by crawler traps for the given domain. The added nodes have the form <newObject name=""domain.dk{0,1,2,..}"" class=""org.archive.crawler.filter.URIRegExpFilter""> <boolean name=""enabled"">true</boolean> <boolean name=""if-match-return"">true</boolean> <string name=""regexp"">theregexp</string> </newObject>
 * @param d The domain for which to generate crawler traps.
 * @throws ArgumentNotValid If unable to order.xml due to wrong order.xml format
 */
private void editOrderXML_crawlerTraps(Domain d) throws ArgumentNotValid {
  List<String> crawlerTraps=d.getCrawlerTraps();
  if (crawlerTraps.size() == 0) {
    return;
  }
  String filterMapXpath=HeritrixTemplate.EXCLUDE_FILTER_MAP_XPATH;
  Node filterMapNode=orderXMLdoc.selectSingleNode(filterMapXpath);
  if (filterMapNode == null || !(filterMapNode instanceof Element)) {
    throw new PermissionDenied(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
  }
  Element filterMap=(Element)filterMapNode;
  int count=0;
  for (  String trap : crawlerTraps) {
    Element filter=filterMap.addElement(""String_Node_Str"");
    filter.addAttribute(""String_Node_Str"",d.getName() + count);
    filter.addAttribute(""String_Node_Str"",""String_Node_Str"");
    Element enabled=filter.addElement(""String_Node_Str"");
    enabled.addAttribute(""String_Node_Str"",""String_Node_Str"");
    enabled.addText(""String_Node_Str"");
    Element ifMatchReturn=filter.addElement(""String_Node_Str"");
    ifMatchReturn.addAttribute(""String_Node_Str"",""String_Node_Str"");
    ifMatchReturn.addText(""String_Node_Str"");
    Element regexp=filter.addElement(""String_Node_Str"");
    regexp.addAttribute(""String_Node_Str"",""String_Node_Str"");
    regexp.addText(trap);
    count++;
  }
}",0.9895213820447464
90198,"/** 
 * Returns a set of sorted seeds for this job. The sorting is done by domain. 
 * @return a set of sorted seeds for this job.
 */
public List<String> getSortedSeedList(){
  Map<String,Set> urlMap=new HashMap<String,Set>();
  for (  String seed : seedListSet) {
    String url;
    if (!seed.matches(Constants.NO_PROTOCOL_REGEXP)) {
      url=""String_Node_Str"" + seed;
    }
 else {
      url=seed;
    }
    String domain=getDomain(url);
    TreeSet set;
    if (urlMap.containsKey(domain)) {
      set=(TreeSet)urlMap.get(domain);
    }
 else {
      set=new TreeSet();
    }
    set.add(seed);
    urlMap.put(domain,set);
  }
  List<String> resultSet=new ArrayList<String>();
  for (  Set set : urlMap.values()) {
    resultSet.addAll(set);
  }
  return resultSet;
}","/** 
 * Returns a set of sorted seeds for this job. The sorting is done by domain.
 * @return a set of sorted seeds for this job.
 */
public List<String> getSortedSeedList(){
  Map<String,Set> urlMap=new HashMap<String,Set>();
  for (  String seed : seedListSet) {
    String url;
    if (!seed.matches(Constants.NO_PROTOCOL_REGEXP)) {
      url=""String_Node_Str"" + seed;
    }
 else {
      url=seed;
    }
    String domain=getDomain(url);
    TreeSet set;
    if (urlMap.containsKey(domain)) {
      set=(TreeSet)urlMap.get(domain);
    }
 else {
      set=new TreeSet();
    }
    set.add(seed);
    urlMap.put(domain,set);
  }
  List<String> resultSet=new ArrayList<String>();
  for (  Set set : urlMap.values()) {
    resultSet.addAll(set);
  }
  return resultSet;
}",0.9993527508090616
90199,"/** 
 * Get the list of harvest error details for this job. If no harvest error details, null is returned This value is not meaningful until the job is finished (FAILED,DONE, RESUBMITTED)
 * @return the list of harvest error details for this job or null if no harvest error details.
 */
public String getHarvestErrorDetails(){
  return harvestErrorDetails;
}","/** 
 * Get the list of harvest error details for this job. If no harvest error details, null is returned This value is not meaningful until the job is finished (FAILED,DONE, RESUBMITTED)
 * @return the list of harvest error details for this jobor null if no harvest error details.
 */
public String getHarvestErrorDetails(){
  return harvestErrorDetails;
}",0.9986013986013986
90200,"/** 
 * Get a file for a given arcFileID.
 * @param arcFileID name of the file to be retrieved.
 * @return The file requested or null if not found
 * @throws ArgumentNotValid If arcFileID was null or empty.
 */
public File getFile(String arcFileID) throws ArgumentNotValid {
  log.info(""String_Node_Str"" + arcFileID + ""String_Node_Str"");
  ArgumentNotValid.checkNotNullOrEmpty(arcFileID,""String_Node_Str"");
  BitarchiveARCFile barc=admin.lookup(arcFileID);
  if (barc == null) {
    return null;
  }
  File path=barc.getFilePath();
  log.info(""String_Node_Str"" + path + ""String_Node_Str"");
  return path;
}","/** 
 * Get a file for a given arcFileID.
 * @param arcFileID name of the file to be retrieved.
 * @return The file requested or null if not found
 * @throws ArgumentNotValid If arcFileID was null or empty.
 */
public File getFile(String arcFileID) throws ArgumentNotValid {
  log.info(""String_Node_Str"" + arcFileID + ""String_Node_Str"");
  ArgumentNotValid.checkNotNullOrEmpty(arcFileID,""String_Node_Str"");
  BitarchiveARCFile barc=admin.lookup(arcFileID);
  if (barc == null) {
    log.debug(""String_Node_Str"" + arcFileID + ""String_Node_Str"");
    return null;
  }
  File path=barc.getFilePath();
  log.info(""String_Node_Str"" + path + ""String_Node_Str"");
  return path;
}",0.9483568075117372
90201,"/** 
 */
public void setUp(){
  job=new TestBatchJob();
}","/** 
 */
public void setUp() throws Exception {
  job=new TestBatchJob();
  super.setUp();
}",0.7651006711409396
90202,"/** 
 * Create Bitarchive
 * @throws Exception
 */
protected void setUp() throws Exception {
  super.setUp();
  FileUtils.removeRecursively(ARCHIVE_DIR);
  try {
    Settings.set(Settings.BITARCHIVE_SERVER_FILEDIR,ARCHIVE_DIR.getAbsolutePath());
    archive=Bitarchive.getInstance();
  }
 catch (  PermissionDenied e) {
    fail(""String_Node_Str"" + e);
  }
  rf.setUp();
}","/** 
 * Create Bitarchive
 * @throws Exception
 */
public void setUp() throws Exception {
  super.setUp();
}",0.4333333333333333
90203,"/** 
 * Verify that uploading a file adds the appropriate record to admin data.
 * @throws FileNotFoundException
 * @throws PermissionDenied
 * @throws IOException
 */
public void testUploadAdminAdded() throws PermissionDenied, FileNotFoundException, IOException {
  BitarchiveAdmin admin=BitarchiveAdmin.getInstance();
  assertNotNull(""String_Node_Str"",admin);
  BitarchiveARCFile arcfile=admin.lookup(ARC_FILE_NAME);
  assertNull(""String_Node_Str"",arcfile);
  archive.upload(new TestRemoteFile(ARC_FILE,false,false,false),ARC_FILE_NAME);
  archive.close();
  arcfile=admin.lookup(ARC_FILE_NAME);
  assertNotNull(""String_Node_Str"",arcfile);
}","/** 
 * Verify that uploading a file adds the appropriate record to admin data.
 * @throws FileNotFoundException
 * @throws PermissionDenied
 * @throws IOException
 */
public void testUploadAdminAdded() throws PermissionDenied, IOException {
  BitarchiveAdmin admin=BitarchiveAdmin.getInstance();
  assertNotNull(""String_Node_Str"",admin);
  BitarchiveARCFile arcfile=admin.lookup(ARC_FILE_NAME);
  assertNull(""String_Node_Str"",arcfile);
  archive.upload(new TestRemoteFile(ARC_FILE,false,false,false),ARC_FILE_NAME);
  archive.close();
  arcfile=admin.lookup(ARC_FILE_NAME);
  assertNotNull(""String_Node_Str"",arcfile);
}",0.9817893903404592
90204,"protected void tearDown() throws Exception {
  super.tearDown();
  if (archive != null) {
    archive.close();
  }
  FileUtils.removeRecursively(ARCHIVE_DIR);
  rf.tearDown();
  Settings.reload();
}","public void tearDown() throws Exception {
  super.tearDown();
}",0.4521072796934866
90205,"/** 
 * est that the batch code actually runs, that it enters each of the initialize() and finish() methods, and that process() is called at least once.
 */
public void testBatchCodeRuns(){
  TestFileBatchJob job=new TestFileBatchJob();
  BatchStatus lbs=archive.batch(TestInfo.baAppId,job);
  assertTrue(""String_Node_Str"",job.initialized);
  assertEquals(""String_Node_Str"",TestInfo.arcFiles.size(),job.processedFileList.size());
  assertTrue(""String_Node_Str"",job.finished);
  lbs.getResultFile().copyTo(TestInfo.BATCH_OUTPUT_FILE);
  FileAsserts.assertFileContains(""String_Node_Str"",""String_Node_Str"",TestInfo.BATCH_OUTPUT_FILE);
  FileAsserts.assertFileContains(""String_Node_Str"",""String_Node_Str"",TestInfo.BATCH_OUTPUT_FILE);
  FileAsserts.assertFileContains(""String_Node_Str"",""String_Node_Str"",TestInfo.BATCH_OUTPUT_FILE);
}","/** 
 * est that the batch code actually runs, that it enters each of the initialize() and finish() methods, and that process() is called at least once.
 */
public void testBatchCodeRuns(){
  TestFileBatchJob job=new TestFileBatchJob();
  BatchStatus lbs=archive.batch(TestInfo.baAppId,job);
  assertTrue(""String_Node_Str"",job.initialized);
  assertEquals(""String_Node_Str"",arcFiles.size(),job.processedFileList.size());
  assertTrue(""String_Node_Str"",job.finished);
  lbs.getResultFile().copyTo(TestInfo.BATCH_OUTPUT_FILE);
  FileAsserts.assertFileContains(""String_Node_Str"",""String_Node_Str"",TestInfo.BATCH_OUTPUT_FILE);
  FileAsserts.assertFileContains(""String_Node_Str"",""String_Node_Str"",TestInfo.BATCH_OUTPUT_FILE);
  FileAsserts.assertFileContains(""String_Node_Str"",""String_Node_Str"",TestInfo.BATCH_OUTPUT_FILE);
}",0.9945421467556096
90206,"/** 
 * At end of test, remove any files we managed to upload.
 */
public void tearDown(){
  archive.close();
  FileUtils.removeRecursively(TestInfo.ARCHIVE_DIR);
  rf.tearDown();
  Settings.reload();
}","/** 
 * At end of test, remove any files we managed to upload.
 */
public void tearDown() throws Exception {
  super.tearDown();
}",0.6506024096385542
90207,"/** 
 * Test that the batch code runs once for each entry. Both for multiple entries in a file and in several files.
 */
public void testBatchCodeRunsAll(){
  TestFileBatchJob job=new TestFileBatchJob();
  archive.batch(TestInfo.baAppId,job);
  assertEquals(""String_Node_Str"",TestInfo.ARCHIVE_SIZE,job.processedFileList.size());
}","/** 
 * Test that the batch code runs once for each entry. Both for multiple entries in a file and in several files.
 */
public void testBatchCodeRunsAll(){
  TestFileBatchJob job=new TestFileBatchJob();
  archive.batch(TestInfo.baAppId,job);
  assertEquals(""String_Node_Str"",ARCHIVE_SIZE,job.processedFileList.size());
}",0.9861751152073732
90208,"/** 
 * At start of test, set up an archive we can run against.
 */
public void setUp() throws PermissionDenied {
  FileUtils.removeRecursively(TestInfo.ARCHIVE_DIR);
  try {
    FileInputStream fis=new FileInputStream(TestInfo.TESTLOGPROP);
    LogManager.getLogManager().readConfiguration(fis);
    fis.close();
  }
 catch (  IOException e) {
    fail(""String_Node_Str"" + e);
  }
  FileUtils.createDir(TestInfo.ARCHIVE_DIR);
  Settings.set(Settings.REMOTE_FILE_CLASS,TestRemoteFile.class.getName());
  Settings.set(Settings.BITARCHIVE_SERVER_FILEDIR,TestInfo.ARCHIVE_DIR.getAbsolutePath());
  archive=Bitarchive.getInstance();
  for (  String filename : TestInfo.arcFiles) {
    FileUtils.copyFile(new File(TestInfo.ORIGINALS_DIR,filename),new File(new File(TestInfo.ARCHIVE_DIR,""String_Node_Str""),filename));
  }
  rf.setUp();
}","/** 
 * At start of test, set up an archive we can run against.
 */
public void setUp() throws Exception {
  super.setUp();
  File fileDir=new File(TestInfo.WORKING_DIR,""String_Node_Str"");
  for (  String filename : arcFiles) {
    FileUtils.copyFile(new File(getOriginalsDir(),filename),new File(fileDir,filename));
  }
}",0.2220294882914137
90209,"private Constants(){
}","/** 
 * The contructor for this class. Making the constructor private prevents the class from being instantiated.
 */
private Constants(){
}",0.2716049382716049
90210,"/** 
 * Return the path used to store files that are removed by RemoveAndGetFileMessage.
 * @param existingFile
 * @return The full path of the file in the attic dir
 */
public File getAtticPath(File existingFile){
  String arcFileName=existingFile.getName();
  File parentDir=existingFile.getParentFile().getParentFile();
  if (!isBitarchiveDirectory(parentDir)) {
    log.warn(""String_Node_Str"" + existingFile + ""String_Node_Str"");
    throw new ArgumentNotValid(""String_Node_Str"" + ""String_Node_Str"" + existingFile + ""String_Node_Str"");
  }
  File atticdir=new File(parentDir,ATTIC_DIRECTORY_NAME);
  ApplicationUtils.dirMustExist(atticdir);
  return new File(atticdir,arcFileName);
}","/** 
 * Return the path used to store files that are removed by RemoveAndGetFileMessage.
 * @param existingFile
 * @return The full path of the file in the attic dir
 */
public File getAtticPath(File existingFile){
  existingFile=existingFile.getAbsoluteFile();
  String arcFileName=existingFile.getName();
  File parentDir=existingFile.getParentFile().getParentFile();
  if (!isBitarchiveDirectory(parentDir)) {
    log.warn(""String_Node_Str"" + existingFile + ""String_Node_Str"");
    throw new ArgumentNotValid(""String_Node_Str"" + ""String_Node_Str"" + existingFile + ""String_Node_Str"");
  }
  File atticdir=new File(parentDir,ATTIC_DIRECTORY_NAME);
  ApplicationUtils.dirMustExist(atticdir);
  return new File(atticdir,arcFileName);
}",0.9669247009148488
90211,"/** 
 * Moves a file from temporary storage to file storage. Note: It is checked, if tempLocation resides in directory TEMPORARY_DIRECTORY_NAME and whether the parent of tempLocation is a Bitarchive directory.
 * @param tempLocation The temporary location where the file was stored.This must be a path returned from getTemporaryPath
 * @return The location where the file is now stored
 * @throws IOFailure if tempLocation is not created from getTemporaryPathor file cannot be moved to Storage location.
 */
public File moveToStorage(File tempLocation){
  ArgumentNotValid.checkNotNull(tempLocation,""String_Node_Str"");
  String arcFileName=tempLocation.getName();
  File arcFilePath=tempLocation.getParentFile();
  if (arcFilePath == null || !arcFilePath.getName().equals(TEMPORARY_DIRECTORY_NAME)) {
    throw new IOFailure(""String_Node_Str"" + tempLocation + ""String_Node_Str""+ ""String_Node_Str""+ TEMPORARY_DIRECTORY_NAME+ ""String_Node_Str"");
  }
  File archivedir=arcFilePath.getParentFile();
  if (archivedir == null || !isBitarchiveDirectory(archivedir)) {
    throw new IOFailure(""String_Node_Str"" + tempLocation + ""String_Node_Str""+ ""String_Node_Str"");
  }
  File storagePath=new File(archivedir,FILE_DIRECTORY_NAME);
  File storageFile=new File(storagePath,arcFileName);
  if (!tempLocation.renameTo(storageFile)) {
    throw new IOFailure(""String_Node_Str"" + tempLocation.getPath() + ""String_Node_Str""+ storageFile.getPath()+ ""String_Node_Str"");
  }
  return storageFile;
}","/** 
 * Moves a file from temporary storage to file storage. Note: It is checked, if tempLocation resides in directory TEMPORARY_DIRECTORY_NAME and whether the parent of tempLocation is a Bitarchive directory.
 * @param tempLocation The temporary location where the file was stored.This must be a path returned from getTemporaryPath
 * @return The location where the file is now stored
 * @throws IOFailure if tempLocation is not created from getTemporaryPathor file cannot be moved to Storage location.
 */
public File moveToStorage(File tempLocation){
  ArgumentNotValid.checkNotNull(tempLocation,""String_Node_Str"");
  tempLocation=tempLocation.getAbsoluteFile();
  String arcFileName=tempLocation.getName();
  File arcFilePath=tempLocation.getParentFile();
  if (arcFilePath == null || !arcFilePath.getName().equals(TEMPORARY_DIRECTORY_NAME)) {
    throw new IOFailure(""String_Node_Str"" + tempLocation + ""String_Node_Str""+ ""String_Node_Str""+ TEMPORARY_DIRECTORY_NAME+ ""String_Node_Str"");
  }
  File archivedir=arcFilePath.getParentFile();
  if (archivedir == null || !isBitarchiveDirectory(archivedir)) {
    throw new IOFailure(""String_Node_Str"" + tempLocation + ""String_Node_Str""+ ""String_Node_Str"");
  }
  File storagePath=new File(archivedir,FILE_DIRECTORY_NAME);
  File storageFile=new File(storagePath,arcFileName);
  if (!tempLocation.renameTo(storageFile)) {
    throw new IOFailure(""String_Node_Str"" + tempLocation.getPath() + ""String_Node_Str""+ storageFile.getPath()+ ""String_Node_Str"");
  }
  return storageFile;
}",0.9843801927550682
90212,"/** 
 * Creates a new FileBasedCache object.  This creates a directory under the main cache directory holding cached files.
 * @param cacheName Name of this cache (enabling sharing among processes).The directoriy creating in the cachedir will have this name.
 */
public FileBasedCache(String cacheName){
  ArgumentNotValid.checkNotNullOrEmpty(cacheName,""String_Node_Str"");
  this.cacheDir=new File(new File(Settings.get(Settings.CACHE_DIR)),cacheName);
  log.info(""String_Node_Str"" + cacheName + ""String_Node_Str""+ getCacheDir().getAbsolutePath()+ ""String_Node_Str"");
  FileUtils.createDir(getCacheDir());
}","/** 
 * Creates a new FileBasedCache object.  This creates a directory under the main cache directory holding cached files.
 * @param cacheName Name of this cache (enabling sharing among processes).The directoriy creating in the cachedir will have this name.
 */
public FileBasedCache(String cacheName){
  ArgumentNotValid.checkNotNullOrEmpty(cacheName,""String_Node_Str"");
  this.cacheDir=new File(new File(Settings.get(Settings.CACHE_DIR)),cacheName).getAbsoluteFile();
  log.info(""String_Node_Str"" + cacheName + ""String_Node_Str""+ getCacheDir().getAbsolutePath()+ ""String_Node_Str"");
  FileUtils.createDir(getCacheDir());
}",0.8603896103896104
90213,"public void testGetSortedFile() throws Exception {
  File f=new File(TestInfo.WORKING_DIR,""String_Node_Str"");
  assertFalse(""String_Node_Str"",f.exists());
  final List<String> list1=Arrays.asList(new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
  FileUtils.writeCollectionToFile(f,list1);
  File sortedFileRaw=new File(TestInfo.WORKING_DIR,""String_Node_Str"");
  assertFalse(""String_Node_Str"",sortedFileRaw.exists());
  File sortedFileGen=WorkFiles.getSortedFile(f);
  assertEquals(""String_Node_Str"",sortedFileRaw,sortedFileGen);
  assertTrue(""String_Node_Str"",sortedFileGen.exists());
  Collections.sort(list1);
  CollectionAsserts.assertIteratorEquals(""String_Node_Str"",list1.iterator(),FileUtils.readListFromFile(sortedFileGen).iterator());
  final List<String> list2=Arrays.asList(new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
  FileUtils.writeCollectionToFile(f,list2);
  File sortedFileGen2=WorkFiles.getSortedFile(f);
  assertEquals(""String_Node_Str"",sortedFileRaw,sortedFileGen2);
  assertTrue(""String_Node_Str"",sortedFileGen2.exists());
  Collections.sort(list2);
  CollectionAsserts.assertIteratorEquals(""String_Node_Str"",list2.iterator(),FileUtils.readListFromFile(sortedFileGen2).iterator());
  sortedFileGen2.delete();
  FileUtils.writeCollectionToFile(f,list1);
  assertFalse(""String_Node_Str"",sortedFileRaw.exists());
  sortedFileGen=WorkFiles.getSortedFile(f);
  assertEquals(""String_Node_Str"",sortedFileRaw,sortedFileGen);
  assertTrue(""String_Node_Str"",sortedFileGen.exists());
  Collections.sort(list1);
  CollectionAsserts.assertIteratorEquals(""String_Node_Str"",list1.iterator(),FileUtils.readListFromFile(sortedFileGen).iterator());
  f.delete();
  try {
    sortedFileGen=WorkFiles.getSortedFile(f);
    fail(""String_Node_Str"");
  }
 catch (  IOFailure e) {
  }
  final List<String> empty=Collections.emptyList();
  FileUtils.writeCollectionToFile(f,empty);
  sortedFileGen=WorkFiles.getSortedFile(f);
  assertEquals(""String_Node_Str"",empty,FileUtils.readListFromFile(sortedFileGen));
}","public void testGetSortedFile() throws Exception {
  File f=new File(TestInfo.WORKING_DIR,""String_Node_Str"");
  assertFalse(""String_Node_Str"",f.exists());
  final List<String> list1=Arrays.asList(new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
  FileUtils.writeCollectionToFile(f,list1);
  File sortedFileRaw=new File(TestInfo.WORKING_DIR,""String_Node_Str"").getAbsoluteFile();
  assertFalse(""String_Node_Str"",sortedFileRaw.exists());
  File sortedFileGen=WorkFiles.getSortedFile(f).getAbsoluteFile();
  assertEquals(""String_Node_Str"",sortedFileRaw,sortedFileGen);
  assertTrue(""String_Node_Str"",sortedFileGen.exists());
  Collections.sort(list1);
  CollectionAsserts.assertIteratorEquals(""String_Node_Str"",list1.iterator(),FileUtils.readListFromFile(sortedFileGen).iterator());
  final List<String> list2=Arrays.asList(new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""});
  FileUtils.writeCollectionToFile(f,list2);
  File sortedFileGen2=WorkFiles.getSortedFile(f);
  assertEquals(""String_Node_Str"",sortedFileRaw,sortedFileGen2);
  assertTrue(""String_Node_Str"",sortedFileGen2.exists());
  Collections.sort(list2);
  CollectionAsserts.assertIteratorEquals(""String_Node_Str"",list2.iterator(),FileUtils.readListFromFile(sortedFileGen2).iterator());
  sortedFileGen2.delete();
  FileUtils.writeCollectionToFile(f,list1);
  assertFalse(""String_Node_Str"",sortedFileRaw.exists());
  sortedFileGen=WorkFiles.getSortedFile(f);
  assertEquals(""String_Node_Str"",sortedFileRaw,sortedFileGen);
  assertTrue(""String_Node_Str"",sortedFileGen.exists());
  Collections.sort(list1);
  CollectionAsserts.assertIteratorEquals(""String_Node_Str"",list1.iterator(),FileUtils.readListFromFile(sortedFileGen).iterator());
  f.delete();
  try {
    sortedFileGen=WorkFiles.getSortedFile(f);
    fail(""String_Node_Str"");
  }
 catch (  IOFailure e) {
  }
  final List<String> empty=Collections.emptyList();
  FileUtils.writeCollectionToFile(f,empty);
  sortedFileGen=WorkFiles.getSortedFile(f);
  assertEquals(""String_Node_Str"",empty,FileUtils.readListFromFile(sortedFileGen));
}",0.9915966386554622
90214,"/** 
 * Copy this remote file to the given file. This method will make a fileoutputstream, and use appendTo to write the remote file to this stream.
 * @param destFile The file to write the remote file to.
 * @throws ArgumentNotValid on null destFile, or parent to destfile is nota writeable directory, or destfile exists and cannot be overwritten.
 * @throws IOFailure on I/O trouble writing remote file to destination.
 */
public void copyTo(File destFile){
  ArgumentNotValid.checkNotNull(destFile,""String_Node_Str"");
  if ((!destFile.isFile() || !destFile.canWrite()) && (!destFile.getParentFile().isDirectory() || !destFile.getParentFile().canWrite())) {
    throw new ArgumentNotValid(""String_Node_Str"" + destFile + ""String_Node_Str""+ file+ ""String_Node_Str"");
  }
  FileOutputStream fos=null;
  try {
    try {
      fos=new FileOutputStream(destFile);
      appendTo(fos);
    }
  finally {
      if (fos != null) {
        fos.close();
      }
    }
  }
 catch (  Exception e) {
    try {
      FileUtils.remove(destFile);
    }
 catch (    IOFailure e1) {
    }
    throw new IOFailure(""String_Node_Str"",e);
  }
}","/** 
 * Copy this remote file to the given file. This method will make a fileoutputstream, and use appendTo to write the remote file to this stream.
 * @param destFile The file to write the remote file to.
 * @throws ArgumentNotValid on null destFile, or parent to destfile is nota writeable directory, or destfile exists and cannot be overwritten.
 * @throws IOFailure on I/O trouble writing remote file to destination.
 */
public void copyTo(File destFile){
  ArgumentNotValid.checkNotNull(destFile,""String_Node_Str"");
  destFile=destFile.getAbsoluteFile();
  if ((!destFile.isFile() || !destFile.canWrite()) && (!destFile.getParentFile().isDirectory() || !destFile.getParentFile().canWrite())) {
    throw new ArgumentNotValid(""String_Node_Str"" + destFile + ""String_Node_Str""+ file+ ""String_Node_Str"");
  }
  FileOutputStream fos=null;
  try {
    try {
      fos=new FileOutputStream(destFile);
      appendTo(fos);
    }
  finally {
      if (fos != null) {
        fos.close();
      }
    }
  }
 catch (  Exception e) {
    try {
      FileUtils.remove(destFile);
    }
 catch (    IOFailure e1) {
    }
    throw new IOFailure(""String_Node_Str"",e);
  }
}",0.9829321663019692
90215,"/** 
 * Copy this remote file to the given file. If the file resides on the current machine, remote file transfer is done locally. Otherwise, the remote file is transferred over http. If the file is not set to be able to be transferred multiple times, it is cleaned up after the transfer.
 * @param destFile The file to write the remote file to.
 * @throws ArgumentNotValid on null destFile, or parent to destfile is nota writeable directory, or destfile exists and cannot be overwritten.
 * @throws IOFailure on I/O trouble writing remote file to destination.
 */
public void copyTo(File destFile){
  ArgumentNotValid.checkNotNull(destFile,""String_Node_Str"");
  if ((!destFile.isFile() || !destFile.canWrite()) && (!destFile.getParentFile().isDirectory() || !destFile.getParentFile().canWrite())) {
    throw new ArgumentNotValid(""String_Node_Str"" + destFile + ""String_Node_Str""+ file+ ""String_Node_Str"");
  }
  if (isLocal() && fileDeletable && !multipleDownloads&& !useChecksums) {
    if (file.renameTo(destFile)) {
      cleanup();
      return;
    }
  }
  super.copyTo(destFile);
}","/** 
 * Copy this remote file to the given file. If the file resides on the current machine, remote file transfer is done locally. Otherwise, the remote file is transferred over http. If the file is not set to be able to be transferred multiple times, it is cleaned up after the transfer.
 * @param destFile The file to write the remote file to.
 * @throws ArgumentNotValid on null destFile, or parent to destfile is nota writeable directory, or destfile exists and cannot be overwritten.
 * @throws IOFailure on I/O trouble writing remote file to destination.
 */
public void copyTo(File destFile){
  ArgumentNotValid.checkNotNull(destFile,""String_Node_Str"");
  destFile=destFile.getAbsoluteFile();
  if ((!destFile.isFile() || !destFile.canWrite()) && (!destFile.getParentFile().isDirectory() || !destFile.getParentFile().canWrite())) {
    throw new ArgumentNotValid(""String_Node_Str"" + destFile + ""String_Node_Str""+ file+ ""String_Node_Str"");
  }
  if (isLocal() && fileDeletable && !multipleDownloads&& !useChecksums) {
    if (file.renameTo(destFile)) {
      cleanup();
      return;
    }
  }
  super.copyTo(destFile);
}",0.982392776523702
90216,"/** 
 * A method for handling Jetty requests.
 * @see AbstractHandler#handle(String,HttpServletRequest,HttpServletResponse,int)
 * @param string Unused domain.
 * @param httpServletRequest request object.
 * @param httpServletResponse the response to write to.
 * @param i Unused state.
 * @throws IOException On trouble in communication.
 * @throws ServletException On servlet trouble.
 */
public void handle(String string,HttpServletRequest httpServletRequest,HttpServletResponse httpServletResponse,int i) throws IOException, ServletException {
  Request request=((Request)httpServletRequest);
  String urlString=httpServletRequest.getRequestURL().toString();
  if (urlString.endsWith(UNREGISTER_URL_POSTFIX)) {
    URL url=new URL(urlString.substring(0,urlString.length() - UNREGISTER_URL_POSTFIX.length()));
    FileInfo fileInfo=registeredFiles.remove(url);
    if (fileInfo != null && fileInfo.deletable && fileInfo.file.exists()) {
      FileUtils.remove(fileInfo.file);
      log.debug(""String_Node_Str"" + fileInfo.file.getPath() + ""String_Node_Str""+ url+ ""String_Node_Str"");
    }
    httpServletResponse.setStatus(200);
    request.setHandled(true);
  }
 else {
    URL url=new URL(urlString);
    FileInfo fileInfo=registeredFiles.get(url);
    if (fileInfo != null) {
      httpServletResponse.setStatus(200);
      FileUtils.writeFileToStream(fileInfo.file,httpServletResponse.getOutputStream());
      request.setHandled(true);
    }
 else {
      httpServletResponse.sendError(404);
    }
    log.debug(""String_Node_Str"" + fileInfo.file.getPath() + ""String_Node_Str""+ url+ ""String_Node_Str"");
  }
}","/** 
 * A method for handling Jetty requests.
 * @see AbstractHandler#handle(String,HttpServletRequest,HttpServletResponse,int)
 * @param string Unused domain.
 * @param httpServletRequest request object.
 * @param httpServletResponse the response to write to.
 * @param i Unused state.
 * @throws IOException On trouble in communication.
 * @throws ServletException On servlet trouble.
 */
public void handle(String string,HttpServletRequest httpServletRequest,HttpServletResponse httpServletResponse,int i) throws IOException, ServletException {
  Request request=((Request)httpServletRequest);
  String urlString=httpServletRequest.getRequestURL().toString();
  if (urlString.endsWith(UNREGISTER_URL_POSTFIX)) {
    URL url=new URL(urlString.substring(0,urlString.length() - UNREGISTER_URL_POSTFIX.length()));
    FileInfo fileInfo=registeredFiles.remove(url);
    if (fileInfo != null && fileInfo.deletable && fileInfo.file.exists()) {
      FileUtils.remove(fileInfo.file);
      log.debug(""String_Node_Str"" + fileInfo.file.getPath() + ""String_Node_Str""+ url+ ""String_Node_Str"");
    }
    httpServletResponse.setStatus(200);
    request.setHandled(true);
  }
 else {
    URL url=new URL(urlString);
    FileInfo fileInfo=registeredFiles.get(url);
    if (fileInfo != null) {
      httpServletResponse.setStatus(200);
      FileUtils.writeFileToStream(fileInfo.file,httpServletResponse.getOutputStream());
      request.setHandled(true);
      log.debug(""String_Node_Str"" + fileInfo.file.getPath() + ""String_Node_Str""+ url+ ""String_Node_Str"");
    }
 else {
      httpServletResponse.sendError(404);
      log.debug(""String_Node_Str"" + url + ""String_Node_Str"");
    }
  }
}",0.9173754556500608
90217,"/** 
 * Create a new ARCLookup object.
 * @param arcRepositoryClient The interface to the ArcRepository
 * @param indexDir Where the index will be placed.  This directoryshould be unique to this instance.
 * @throws ArgumentNotValid if arcRepositoryClient is null.
 */
public ARCLookup(ViewerArcRepositoryClient arcRepositoryClient,File indexDir){
  ArgumentNotValid.checkNotNull(arcRepositoryClient,""String_Node_Str"");
  this.arcRepositoryClient=arcRepositoryClient;
  this.luceneIndexDir=indexDir;
  FileUtils.createDir(luceneIndexDir.getParentFile());
  luceneSearcher=null;
}","/** 
 * Create a new ARCLookup object.
 * @param arcRepositoryClient The interface to the ArcRepository
 * @param indexDir Where the index will be placed.  This directoryshould be unique to this instance.
 * @throws ArgumentNotValid if arcRepositoryClient is null.
 */
public ARCLookup(ViewerArcRepositoryClient arcRepositoryClient,File indexDir){
  ArgumentNotValid.checkNotNull(arcRepositoryClient,""String_Node_Str"");
  this.arcRepositoryClient=arcRepositoryClient;
  this.luceneIndexDir=indexDir.getAbsoluteFile();
  FileUtils.createDir(luceneIndexDir.getParentFile());
  luceneSearcher=null;
}",0.9846938775510204
90218,"/** 
 * Verifies that the filename (absolute path) points to an existing file and that it is an arc file.
 * @param filename The filename to verify.
 * @return The arc file, as a File.
 */
private static File toArcFile(String filename){
  File f;
  try {
    f=FileUtils.makeValidFileFromExisting(filename);
    if (!FileUtils.ARCS_FILTER.accept(f.getParentFile(),f.getName())) {
      dieWithError(""String_Node_Str"" + filename + ""String_Node_Str"");
    }
    return f;
  }
 catch (  IOFailure e) {
    dieWithError(""String_Node_Str"" + filename + ""String_Node_Str""+ e);
    return null;
  }
}","/** 
 * Verifies that the filename (absolute path) points to an existing file and that it is an arc file.
 * @param filename The filename to verify.
 * @return The arc file, as a File.
 */
private static File toArcFile(String filename){
  File f;
  try {
    f=FileUtils.makeValidFileFromExisting(filename).getAbsoluteFile();
    if (!FileUtils.ARCS_FILTER.accept(f.getParentFile(),f.getName())) {
      dieWithError(""String_Node_Str"" + filename + ""String_Node_Str"");
    }
    return f;
  }
 catch (  IOFailure e) {
    dieWithError(""String_Node_Str"" + filename + ""String_Node_Str""+ e);
    return null;
  }
}",0.9850249584026622
90219,"/** 
 * @param theFile A file to make relative
 * @param crawlDir A directory
 * @return the filepath of the theFile relative to crawldir. null, iftheFile is not relative to crawldir. null, if crawldir is not a directory.
 */
public static String relativeTo(File theFile,File crawlDir){
  if (!crawlDir.isDirectory()) {
    return null;
  }
  List<String> filePathList=new ArrayList<String>();
  List<String> crawlDirPath=new ArrayList<String>();
  File tempFile=theFile;
  filePathList.add(tempFile.getName());
  while ((tempFile=tempFile.getParentFile()) != null) {
    filePathList.add(tempFile.getName());
  }
  tempFile=crawlDir;
  crawlDirPath.add(tempFile.getName());
  while ((tempFile=tempFile.getParentFile()) != null) {
    crawlDirPath.add(tempFile.getName());
  }
  List sublist=filePathList.subList(crawlDirPath.size() - 2,filePathList.size());
  if (!crawlDirPath.equals(sublist)) {
    return null;
  }
  List<String> relativeList=filePathList.subList(0,crawlDirPath.size() - 2);
  StringBuffer sb=new StringBuffer();
  Collections.reverse(relativeList);
  for (  String aRelativeList : relativeList) {
    sb.append(aRelativeList);
    sb.append(File.separatorChar);
  }
  sb.deleteCharAt(sb.length() - 1);
  return sb.toString();
}","/** 
 * @param theFile A file to make relative
 * @param crawlDir A directory
 * @return the filepath of the theFile relative to crawldir. null, iftheFile is not relative to crawldir. null, if crawldir is not a directory.
 */
public static String relativeTo(File theFile,File crawlDir){
  if (!crawlDir.isDirectory()) {
    return null;
  }
  List<String> filePathList=new ArrayList<String>();
  List<String> crawlDirPath=new ArrayList<String>();
  File tempFile=theFile.getAbsoluteFile();
  filePathList.add(tempFile.getName());
  while ((tempFile=tempFile.getParentFile()) != null) {
    filePathList.add(tempFile.getName());
  }
  tempFile=crawlDir.getAbsoluteFile();
  crawlDirPath.add(tempFile.getName());
  while ((tempFile=tempFile.getParentFile()) != null) {
    crawlDirPath.add(tempFile.getName());
  }
  List sublist=filePathList.subList(crawlDirPath.size() - 2,filePathList.size());
  if (!crawlDirPath.equals(sublist)) {
    return null;
  }
  List<String> relativeList=filePathList.subList(0,crawlDirPath.size() - 2);
  StringBuffer sb=new StringBuffer();
  Collections.reverse(relativeList);
  for (  String aRelativeList : relativeList) {
    sb.append(aRelativeList);
    sb.append(File.separatorChar);
  }
  sb.deleteCharAt(sb.length() - 1);
  return sb.toString();
}",0.9857932123125492
90220,"/** 
 * Return the number of bytes free on the disk that the given file resides on. This method only works on Linux. Assumes that df -B 1 <filename> gives output of the format Filesystem 1-blocks Used Available Use% Mounted on /dev/sda3 9852805120 5572796416 3779502080 60% / <p/> Method is slow - starts an external process.
 * @param f A file.
 * @return Number of bytes free on the disk that the file is on
 */
private static long getBytesFreeLinux(File f){
  try {
    if (!f.isDirectory()) {
      f=f.getParentFile();
    }
    Process p=Runtime.getRuntime().exec(new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",f.getAbsolutePath()});
    final int exitValue=p.waitFor();
    String outputText=readProcessOutput(p.getInputStream());
    String errorText=readProcessOutput(p.getErrorStream());
    if (exitValue != 0) {
      throw new IOFailure(""String_Node_Str"" + exitValue + ""String_Node_Str""+ errorText+ ""String_Node_Str"");
    }
    BufferedReader lines=new BufferedReader(new StringReader(outputText));
    lines.readLine();
    String kline=lines.readLine();
    String[] lineparts=kline.split(""String_Node_Str"");
    if (lineparts.length < 6) {
      throw new IOFailure(""String_Node_Str"" + kline);
    }
    return Long.parseLong(lineparts[3]);
  }
 catch (  NumberFormatException e) {
    throw new IOFailure(""String_Node_Str"",e);
  }
catch (  IOException e) {
    throw new IOFailure(""String_Node_Str"",e);
  }
catch (  InterruptedException e) {
    throw new IOFailure(""String_Node_Str"",e);
  }
}","/** 
 * Return the number of bytes free on the disk that the given file resides on. This method only works on Linux. Assumes that df -B 1 <filename> gives output of the format Filesystem 1-blocks Used Available Use% Mounted on /dev/sda3 9852805120 5572796416 3779502080 60% / <p/> Method is slow - starts an external process.
 * @param f A file.
 * @return Number of bytes free on the disk that the file is on
 */
private static long getBytesFreeLinux(File f){
  try {
    if (!f.isDirectory()) {
      f=f.getAbsoluteFile().getParentFile();
    }
    Process p=Runtime.getRuntime().exec(new String[]{""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",f.getAbsolutePath()});
    final int exitValue=p.waitFor();
    String outputText=readProcessOutput(p.getInputStream());
    String errorText=readProcessOutput(p.getErrorStream());
    if (exitValue != 0) {
      throw new IOFailure(""String_Node_Str"" + exitValue + ""String_Node_Str""+ errorText+ ""String_Node_Str"");
    }
    BufferedReader lines=new BufferedReader(new StringReader(outputText));
    lines.readLine();
    String kline=lines.readLine();
    String[] lineparts=kline.split(""String_Node_Str"");
    if (lineparts.length < 6) {
      throw new IOFailure(""String_Node_Str"" + kline);
    }
    return Long.parseLong(lineparts[3]);
  }
 catch (  NumberFormatException e) {
    throw new IOFailure(""String_Node_Str"",e);
  }
catch (  IOException e) {
    throw new IOFailure(""String_Node_Str"",e);
  }
catch (  InterruptedException e) {
    throw new IOFailure(""String_Node_Str"",e);
  }
}",0.9942233632862644
90221,"/** 
 * Return the number of bytes free on the disk that the given file resides on. This method only works on Windows. <p/> Method is slow - creates a file and starts an external process.
 * @param f A file.
 * @return Number of bytes free on the disk that the file is on
 */
private static long getFreeSpaceOnWindows(File f){
  final String scriptFileName=""String_Node_Str"";
  String outputText=null;
  File scriptFile=null;
  try {
    if (!f.isDirectory()) {
      f=f.getParentFile();
    }
    scriptFile=File.createTempFile(scriptFileName,""String_Node_Str"");
    PrintWriter writer=new PrintWriter(new FileWriter(scriptFile,false));
    writer.println(""String_Node_Str"" + f.getAbsolutePath() + ""String_Node_Str"");
    writer.close();
    Process p=Runtime.getRuntime().exec(scriptFile.getAbsolutePath());
    InputStream reader=new BufferedInputStream(p.getInputStream());
    try {
      StringBuffer buffer=new StringBuffer();
      for (; ; ) {
        int c=reader.read();
        if (c == -1) {
          break;
        }
        buffer.append((char)c);
      }
      outputText=buffer.toString();
    }
  finally {
      reader.close();
    }
    String[] lineparts=outputText.split(""String_Node_Str"");
    String[] lastLineParts=lineparts[lineparts.length - 1].split(""String_Node_Str"");
    for (int i=0; i < lastLineParts.length; i++) {
      if (i > 0 && lastLineParts[i].endsWith(""String_Node_Str"")) {
        return Long.parseLong(lastLineParts[i - 1].replaceAll(""String_Node_Str"",""String_Node_Str""));
      }
    }
    throw new IOFailure(""String_Node_Str"" + outputText);
  }
 catch (  NumberFormatException e) {
    throw new IOFailure(""String_Node_Str"" + outputText,e);
  }
catch (  IOException e) {
    throw new IOFailure(""String_Node_Str"",e);
  }
 finally {
    scriptFile.delete();
  }
}","/** 
 * Return the number of bytes free on the disk that the given file resides on. This method only works on Windows. <p/> Method is slow - creates a file and starts an external process.
 * @param f A file.
 * @return Number of bytes free on the disk that the file is on
 */
private static long getFreeSpaceOnWindows(File f){
  final String scriptFileName=""String_Node_Str"";
  String outputText=null;
  File scriptFile=null;
  try {
    if (!f.isDirectory()) {
      f=f.getAbsoluteFile().getParentFile();
    }
    scriptFile=File.createTempFile(scriptFileName,""String_Node_Str"");
    PrintWriter writer=new PrintWriter(new FileWriter(scriptFile,false));
    writer.println(""String_Node_Str"" + f.getAbsolutePath() + ""String_Node_Str"");
    writer.close();
    Process p=Runtime.getRuntime().exec(scriptFile.getAbsolutePath());
    InputStream reader=new BufferedInputStream(p.getInputStream());
    try {
      StringBuffer buffer=new StringBuffer();
      for (; ; ) {
        int c=reader.read();
        if (c == -1) {
          break;
        }
        buffer.append((char)c);
      }
      outputText=buffer.toString();
    }
  finally {
      reader.close();
    }
    String[] lineparts=outputText.split(""String_Node_Str"");
    String[] lastLineParts=lineparts[lineparts.length - 1].split(""String_Node_Str"");
    for (int i=0; i < lastLineParts.length; i++) {
      if (i > 0 && lastLineParts[i].endsWith(""String_Node_Str"")) {
        return Long.parseLong(lastLineParts[i - 1].replaceAll(""String_Node_Str"",""String_Node_Str""));
      }
    }
    throw new IOFailure(""String_Node_Str"" + outputText);
  }
 catch (  NumberFormatException e) {
    throw new IOFailure(""String_Node_Str"" + outputText,e);
  }
catch (  IOException e) {
    throw new IOFailure(""String_Node_Str"",e);
  }
 finally {
    scriptFile.delete();
  }
}",0.9950549450549452
90222,"/** 
 * Gunzip all .gz files in a given directory into another.  Files in fromDir not ending in .gz or not real files will be skipped with a log entry.
 * @param fromDir The directory containing .gz files
 * @param toDir The directory to place the unzipped files in.  Thisdirectory must not exist beforehand.
 * @throws IOFailure if there are problems creating the output directoryor gunzipping the files.
 */
public static void gunzipFiles(File fromDir,File toDir){
  ArgumentNotValid.checkNotNull(fromDir,""String_Node_Str"");
  ArgumentNotValid.checkNotNull(toDir,""String_Node_Str"");
  ArgumentNotValid.checkTrue(fromDir.isDirectory(),""String_Node_Str"" + fromDir + ""String_Node_Str"");
  ArgumentNotValid.checkTrue(!toDir.exists(),""String_Node_Str"" + toDir + ""String_Node_Str"");
  File tempDir=FileUtils.createUniqueTempDir(toDir.getParentFile(),toDir.getName());
  try {
    File[] gzippedFiles=fromDir.listFiles();
    for (    File f : gzippedFiles) {
      if (f.isFile() && f.getName().endsWith(GZIP_SUFFIX)) {
        gunzipInto(f,tempDir);
      }
 else {
        log.trace(""String_Node_Str"" + f + ""String_Node_Str"");
      }
    }
    if (!tempDir.renameTo(toDir)) {
      throw new IOFailure(""String_Node_Str"" + tempDir + ""String_Node_Str""+ toDir);
    }
  }
  finally {
    FileUtils.removeRecursively(tempDir);
  }
}","/** 
 * Gunzip all .gz files in a given directory into another.  Files in fromDir not ending in .gz or not real files will be skipped with a log entry.
 * @param fromDir The directory containing .gz files
 * @param toDir The directory to place the unzipped files in.  Thisdirectory must not exist beforehand.
 * @throws IOFailure if there are problems creating the output directoryor gunzipping the files.
 */
public static void gunzipFiles(File fromDir,File toDir){
  ArgumentNotValid.checkNotNull(fromDir,""String_Node_Str"");
  ArgumentNotValid.checkNotNull(toDir,""String_Node_Str"");
  ArgumentNotValid.checkTrue(fromDir.isDirectory(),""String_Node_Str"" + fromDir + ""String_Node_Str"");
  ArgumentNotValid.checkTrue(!toDir.exists(),""String_Node_Str"" + toDir + ""String_Node_Str"");
  File tempDir=FileUtils.createUniqueTempDir(toDir.getAbsoluteFile().getParentFile(),toDir.getName());
  try {
    File[] gzippedFiles=fromDir.listFiles();
    for (    File f : gzippedFiles) {
      if (f.isFile() && f.getName().endsWith(GZIP_SUFFIX)) {
        gunzipInto(f,tempDir);
      }
 else {
        log.trace(""String_Node_Str"" + f + ""String_Node_Str"");
      }
    }
    if (!tempDir.renameTo(toDir)) {
      throw new IOFailure(""String_Node_Str"" + tempDir + ""String_Node_Str""+ toDir);
    }
  }
  finally {
    FileUtils.removeRecursively(tempDir);
  }
}",0.9932634730538922
90223,"/** 
 * GZip each of the files in fromDir, placing the result in toDir (which will be created) with names having .gz appended.  All non-file (directory, link, etc) entries in the source directory will be skipped with a quiet little log message.
 * @param fromDir An existing directory
 * @param toDir A directory where gzipped files will be placed.  Thisdirectory must not previously exist. If the operation is not successfull, the directory will not be created.
 */
public static void gzipFiles(File fromDir,File toDir){
  ArgumentNotValid.checkNotNull(fromDir,""String_Node_Str"");
  ArgumentNotValid.checkNotNull(toDir,""String_Node_Str"");
  ArgumentNotValid.checkTrue(fromDir.isDirectory(),""String_Node_Str"" + fromDir + ""String_Node_Str"");
  ArgumentNotValid.checkTrue(!toDir.exists(),""String_Node_Str"" + toDir + ""String_Node_Str"");
  File tmpDir=null;
  try {
    tmpDir=FileUtils.createUniqueTempDir(toDir.getParentFile(),toDir.getName());
    File[] fromFiles=fromDir.listFiles();
    for (    File f : fromFiles) {
      if (f.isFile()) {
        gzipFileInto(f,tmpDir);
      }
 else {
        log.trace(""String_Node_Str"" + f + ""String_Node_Str"");
      }
    }
    if (!tmpDir.renameTo(toDir)) {
      throw new IOFailure(""String_Node_Str"" + tmpDir + ""String_Node_Str""+ toDir+ ""String_Node_Str"");
    }
  }
  finally {
    if (tmpDir != null) {
      try {
        FileUtils.removeRecursively(tmpDir);
      }
 catch (      IOFailure e) {
        log.debug(""String_Node_Str"" + ""String_Node_Str"" + tmpDir + ""String_Node_Str""+ toDir+ ""String_Node_Str"",e);
      }
    }
  }
}","/** 
 * GZip each of the files in fromDir, placing the result in toDir (which will be created) with names having .gz appended.  All non-file (directory, link, etc) entries in the source directory will be skipped with a quiet little log message.
 * @param fromDir An existing directory
 * @param toDir A directory where gzipped files will be placed.  Thisdirectory must not previously exist. If the operation is not successfull, the directory will not be created.
 */
public static void gzipFiles(File fromDir,File toDir){
  ArgumentNotValid.checkNotNull(fromDir,""String_Node_Str"");
  ArgumentNotValid.checkNotNull(toDir,""String_Node_Str"");
  ArgumentNotValid.checkTrue(fromDir.isDirectory(),""String_Node_Str"" + fromDir + ""String_Node_Str"");
  ArgumentNotValid.checkTrue(!toDir.exists(),""String_Node_Str"" + toDir + ""String_Node_Str"");
  File tmpDir=null;
  try {
    tmpDir=FileUtils.createUniqueTempDir(toDir.getAbsoluteFile().getParentFile(),toDir.getName());
    File[] fromFiles=fromDir.listFiles();
    for (    File f : fromFiles) {
      if (f.isFile()) {
        gzipFileInto(f,tmpDir);
      }
 else {
        log.trace(""String_Node_Str"" + f + ""String_Node_Str"");
      }
    }
    if (!tmpDir.renameTo(toDir)) {
      throw new IOFailure(""String_Node_Str"" + tmpDir + ""String_Node_Str""+ toDir+ ""String_Node_Str"");
    }
  }
  finally {
    if (tmpDir != null) {
      try {
        FileUtils.removeRecursively(tmpDir);
      }
 catch (      IOFailure e) {
        log.debug(""String_Node_Str"" + ""String_Node_Str"" + tmpDir + ""String_Node_Str""+ toDir+ ""String_Node_Str"",e);
      }
    }
  }
}",0.9943360604153556
90224,"public void testCopyto() throws Exception {
  HTTPRemoteFile rf=new ForceRemoteHTTPRemoteFile(TestInfo.FILE1,false,false,true);
  File tempFile=File.createTempFile(""String_Node_Str"",""String_Node_Str"",TestInfo.WORKING_DIR);
  rf.copyTo(tempFile);
  String contents=FileUtils.readFile(TestInfo.FILE1);
  assertEquals(""String_Node_Str"",contents,FileUtils.readFile(tempFile));
  assertTrue(""String_Node_Str"",TestInfo.FILE1.exists());
  File tempFile2=File.createTempFile(""String_Node_Str"",""String_Node_Str"",TestInfo.WORKING_DIR);
  rf.copyTo(tempFile2);
  assertEquals(""String_Node_Str"",contents,FileUtils.readFile(tempFile));
  assertTrue(""String_Node_Str"",TestInfo.FILE1.exists());
  rf=new ForceRemoteHTTPRemoteFile(TestInfo.FILE1,false,false,false);
  tempFile=File.createTempFile(""String_Node_Str"",""String_Node_Str"",TestInfo.WORKING_DIR);
  rf.copyTo(tempFile);
  assertEquals(""String_Node_Str"",contents,FileUtils.readFile(tempFile));
  assertTrue(""String_Node_Str"",TestInfo.FILE1.exists());
  tempFile2=File.createTempFile(""String_Node_Str"",""String_Node_Str"",TestInfo.WORKING_DIR);
  try {
    rf.copyTo(tempFile2);
    fail(""String_Node_Str"");
  }
 catch (  IOFailure e) {
  }
  rf=new ForceRemoteHTTPRemoteFile(TestInfo.FILE1,false,true,false);
  tempFile=File.createTempFile(""String_Node_Str"",""String_Node_Str"",TestInfo.WORKING_DIR);
  rf.copyTo(tempFile);
  assertEquals(""String_Node_Str"",contents,FileUtils.readFile(tempFile));
  assertFalse(""String_Node_Str"",TestInfo.FILE1.exists());
}","public void testCopyto() throws Exception {
  HTTPRemoteFile rf=new ForceRemoteHTTPRemoteFile(TestInfo.FILE1,false,false,true);
  File tempFile=File.createTempFile(""String_Node_Str"",""String_Node_Str"",TestInfo.WORKING_DIR);
  rf.copyTo(tempFile);
  String contents=FileUtils.readFile(TestInfo.FILE1);
  assertEquals(""String_Node_Str"",contents,FileUtils.readFile(tempFile));
  assertTrue(""String_Node_Str"",TestInfo.FILE1.exists());
  File tempFile2=File.createTempFile(""String_Node_Str"",""String_Node_Str"",TestInfo.WORKING_DIR);
  rf.copyTo(tempFile2);
  assertEquals(""String_Node_Str"",contents,FileUtils.readFile(tempFile));
  assertTrue(""String_Node_Str"",TestInfo.FILE1.exists());
  rf=new ForceRemoteHTTPRemoteFile(TestInfo.FILE1,false,false,false);
  tempFile=File.createTempFile(""String_Node_Str"",""String_Node_Str"",TestInfo.WORKING_DIR);
  rf.copyTo(tempFile);
  assertEquals(""String_Node_Str"",contents,FileUtils.readFile(tempFile));
  assertTrue(""String_Node_Str"",TestInfo.FILE1.exists());
  tempFile2=File.createTempFile(""String_Node_Str"",""String_Node_Str"",TestInfo.WORKING_DIR);
  try {
    rf.copyTo(tempFile2);
    fail(""String_Node_Str"");
  }
 catch (  IOFailure e) {
  }
  rf=new ForceRemoteHTTPRemoteFile(TestInfo.FILE1,false,true,false);
  tempFile=File.createTempFile(""String_Node_Str"",""String_Node_Str"",TestInfo.WORKING_DIR);
  rf.copyTo(tempFile);
  assertEquals(""String_Node_Str"",contents,FileUtils.readFile(tempFile));
  assertFalse(""String_Node_Str"",TestInfo.FILE1.exists());
  tempFile.renameTo(TestInfo.FILE1);
  rf=new ForceRemoteHTTPRemoteFile(TestInfo.FILE1,false,true,false);
  tempFile=new File(""String_Node_Str"");
  tempFile.deleteOnExit();
  rf.copyTo(tempFile);
  assertEquals(""String_Node_Str"",contents,FileUtils.readFile(tempFile));
  assertFalse(""String_Node_Str"",TestInfo.FILE1.exists());
  FileUtils.remove(tempFile);
}",0.8932735426008969
90225,"/** 
 * Run the application.
 * @param args Command-line arguments:First arg is the it-conf.xml file to base the installation on. Second arg is the settings.xml file to use as base. Third arg is the name of the environment this will be used in, e.g. test or prod. Fourth (optional) arg is the directory to output files to.  If not given, files will be placed in a subdirectory of the current directory named the same as the envorinment arg.
 */
public static void main(String[] args){
  if (args.length < 3) {
    System.out.println(""String_Node_Str"" + ""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
    System.exit(0);
  }
  String fname=args[0];
  String fnNameSettings=args[1];
  String environmentName=args[2];
  String outputdir=""String_Node_Str"" + environmentName + ""String_Node_Str"";
  if (args.length == 4) {
    outputdir=args[3];
  }
  ItConfiguration itConfig=new ItConfiguration(new File(fname));
  itConfig.setEnvironment(environmentName);
  itConfig.calculateDefaultSettings(new File(fnNameSettings).getParentFile());
  itConfig.loadDefaultSettings(new File(fnNameSettings),environmentName);
  File subdir=new File(outputdir);
  itConfig.writeSettings(subdir);
  for (  String loc : itConfig.locations) {
    itConfig.writeInstallAllSSH(new File(subdir,""String_Node_Str"" + loc + ""String_Node_Str""),new File(subdir,""String_Node_Str"" + loc + ""String_Node_Str""),new File(subdir,""String_Node_Str"" + loc + ""String_Node_Str""),loc);
  }
}","/** 
 * Run the application.
 * @param args Command-line arguments:First arg is the it-conf.xml file to base the installation on. Second arg is the settings.xml file to use as base. Third arg is the name of the environment this will be used in, e.g. test or prod. Fourth (optional) arg is the directory to output files to.  If not given, files will be placed in a subdirectory of the current directory named the same as the envorinment arg.
 */
public static void main(String[] args){
  if (args.length < 3) {
    System.out.println(""String_Node_Str"" + ""String_Node_Str"");
    System.out.println(""String_Node_Str"");
    System.out.println(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"");
    System.exit(0);
  }
  String fname=args[0];
  String fnNameSettings=args[1];
  String environmentName=args[2];
  String outputdir=""String_Node_Str"" + environmentName + ""String_Node_Str"";
  if (args.length == 4) {
    outputdir=args[3];
  }
  ItConfiguration itConfig=new ItConfiguration(new File(fname));
  itConfig.setEnvironment(environmentName);
  itConfig.calculateDefaultSettings(new File(fnNameSettings).getAbsoluteFile().getParentFile());
  itConfig.loadDefaultSettings(new File(fnNameSettings),environmentName);
  File subdir=new File(outputdir);
  itConfig.writeSettings(subdir);
  for (  String loc : itConfig.locations) {
    itConfig.writeInstallAllSSH(new File(subdir,""String_Node_Str"" + loc + ""String_Node_Str""),new File(subdir,""String_Node_Str"" + loc + ""String_Node_Str""),new File(subdir,""String_Node_Str"" + loc + ""String_Node_Str""),loc);
  }
}",0.9942047649710238
90226,"/** 
 * Create the start scripts for the harvester applications. Expected to be called once for each harvester instance.
 * @param res   The file to write the harvester script to. Note that thisfilename, with ""harvester"" replaced by ""sidekick"" will also be used to write the sidekick start script.
 * @param setfn the name of the settings file to use.
 */
public void writeStartHarvesterApps(File res,String setfn){
  File logdir=new File(installDir + ""String_Node_Str"");
  String settingsfn=installDir + ""String_Node_Str"" + setfn;
  writeStart(res,HarvestControllerApplication.class.getName(),settingsfn,logdir,logProperties,getHeritrixUiPortArgs() + ""String_Node_Str"" + getHeritrixJmxPortArgs());
  String sidekick=SideKick.class.getName() + ""String_Node_Str"" + HarvestControllerServerMonitorHook.class.getName()+ ""String_Node_Str""+ res.getName()+ ""String_Node_Str"";
  File dir=res.getParentFile();
  String fn=res.getName().replaceAll(""String_Node_Str"",""String_Node_Str"");
  writeStart(new File(dir,fn),sidekick,settingsfn,logdir,logProperties,""String_Node_Str"");
}","/** 
 * Create the start scripts for the harvester applications. Expected to be called once for each harvester instance.
 * @param res   The file to write the harvester script to. Note that thisfilename, with ""harvester"" replaced by ""sidekick"" will also be used to write the sidekick start script.
 * @param setfn the name of the settings file to use.
 */
public void writeStartHarvesterApps(File res,String setfn){
  File logdir=new File(installDir + ""String_Node_Str"");
  String settingsfn=installDir + ""String_Node_Str"" + setfn;
  writeStart(res,HarvestControllerApplication.class.getName(),settingsfn,logdir,logProperties,getHeritrixUiPortArgs() + ""String_Node_Str"" + getHeritrixJmxPortArgs());
  String sidekick=SideKick.class.getName() + ""String_Node_Str"" + HarvestControllerServerMonitorHook.class.getName()+ ""String_Node_Str""+ res.getName()+ ""String_Node_Str"";
  File dir=res.getAbsoluteFile().getParentFile();
  String fn=res.getName().replaceAll(""String_Node_Str"",""String_Node_Str"");
  writeStart(new File(dir,fn),sidekick,settingsfn,logdir,logProperties,""String_Node_Str"");
}",0.9916434540389972
90227,"/** 
 * Write a linux start script.
 * @param res               The file to write the script to
 * @param appName           the class name to start
 * @param settingsfn        the settings file to use
 * @param logpropDir        the directory to store the logging propertiesfile in
 * @param loggingProperties the content of the logging-properties file
 * @param extraOptions      Any extra options to the java process.  Theseoptions are inserted <em>before</em> the name of the Java class, so they cannot be used to pass command-line options to the application.
 */
private void writeStart(File res,String appName,String settingsfn,File logpropDir,String loggingProperties,String extraOptions){
  String logfn=writeLogPropertiesFile(appName,res.getParentFile(),logpropDir,loggingProperties);
  PrintWriter pw=null;
  PrintWriter pw2=null;
  try {
    try {
      pw=new PrintWriter(new FileWriter(res));
      String JVMARGS=""String_Node_Str"";
      String SETTINGSFILE=""String_Node_Str"" + Settings.SETTINGS_FILE_NAME_PROPERTY + ""String_Node_Str""+ settingsfn;
      String LOGFILE=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ logfn;
      File JMXPasswordFile=new File(installDir + ""String_Node_Str"",Constants.JMX_PASSWORD_FILENAME);
      String JMXArgs=getJMXPortParameter() + ""String_Node_Str"" + JMXPasswordFile.getAbsolutePath();
      String httpFileTransferArgs=getHttpFileTransferArgs();
      String OPTIONS=extraOptions + ""String_Node_Str"" + SETTINGSFILE+ ""String_Node_Str""+ LOGFILE+ ""String_Node_Str""+ JMXArgs+ httpFileTransferArgs;
      pw.println(""String_Node_Str"");
      pw.println(""String_Node_Str"" + StringUtils.surjoin(getJarFiles(appName),installDir + ""String_Node_Str"",""String_Node_Str"") + ""String_Node_Str"");
      pw.println(""String_Node_Str"" + installDir);
      pw.println(""String_Node_Str"" + JVMARGS + ""String_Node_Str""+ OPTIONS+ ""String_Node_Str""+ appName+ ""String_Node_Str""+ res.getName()+ ""String_Node_Str"");
      pw.close();
      String killAppName=res.getName().replaceAll(""String_Node_Str"",""String_Node_Str"");
      String[] temp=appName.split(""String_Node_Str"");
      appName=temp[0];
      pw2=new PrintWriter(new FileWriter(new File(res.getParentFile(),killAppName)));
      pw2.println(""String_Node_Str"");
      pw2.println(""String_Node_Str"" + appName + ""String_Node_Str""+ settingsfn+ ""String_Node_Str"");
      pw2.println(""String_Node_Str"");
      pw2.println(""String_Node_Str"");
      pw2.println(""String_Node_Str"");
      if (HarvestControllerApplication.class.getName().equals(appName)) {
        pw2.println(""String_Node_Str"" + Heritrix.class.getName() + ""String_Node_Str""+ settingsfn+ ""String_Node_Str"");
        pw2.println(""String_Node_Str"");
        pw2.println(""String_Node_Str"");
        pw2.println(""String_Node_Str"");
      }
      pw2.close();
      appsToStart.add(res.getName());
    }
  finally {
      if (pw != null) {
        pw.close();
      }
      if (pw2 != null) {
        pw2.close();
      }
    }
  }
 catch (  IOException e) {
    throw new IOFailure(""String_Node_Str"" + res + ""String_Node_Str""+ appName,e);
  }
}","/** 
 * Write a linux start script.
 * @param res               The file to write the script to
 * @param appName           the class name to start
 * @param settingsfn        the settings file to use
 * @param logpropDir        the directory to store the logging propertiesfile in
 * @param loggingProperties the content of the logging-properties file
 * @param extraOptions      Any extra options to the java process.  Theseoptions are inserted <em>before</em> the name of the Java class, so they cannot be used to pass command-line options to the application.
 */
private void writeStart(File res,String appName,String settingsfn,File logpropDir,String loggingProperties,String extraOptions){
  String logfn=writeLogPropertiesFile(appName,res.getAbsoluteFile().getParentFile(),logpropDir,loggingProperties);
  PrintWriter pw=null;
  PrintWriter pw2=null;
  try {
    try {
      pw=new PrintWriter(new FileWriter(res));
      String JVMARGS=""String_Node_Str"";
      String SETTINGSFILE=""String_Node_Str"" + Settings.SETTINGS_FILE_NAME_PROPERTY + ""String_Node_Str""+ settingsfn;
      String LOGFILE=""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ logfn;
      File JMXPasswordFile=new File(installDir + ""String_Node_Str"",Constants.JMX_PASSWORD_FILENAME);
      String JMXArgs=getJMXPortParameter() + ""String_Node_Str"" + JMXPasswordFile.getAbsolutePath();
      String httpFileTransferArgs=getHttpFileTransferArgs();
      String OPTIONS=extraOptions + ""String_Node_Str"" + SETTINGSFILE+ ""String_Node_Str""+ LOGFILE+ ""String_Node_Str""+ JMXArgs+ httpFileTransferArgs;
      pw.println(""String_Node_Str"");
      pw.println(""String_Node_Str"" + StringUtils.surjoin(getJarFiles(appName),installDir + ""String_Node_Str"",""String_Node_Str"") + ""String_Node_Str"");
      pw.println(""String_Node_Str"" + installDir);
      pw.println(""String_Node_Str"" + JVMARGS + ""String_Node_Str""+ OPTIONS+ ""String_Node_Str""+ appName+ ""String_Node_Str""+ res.getName()+ ""String_Node_Str"");
      pw.close();
      String killAppName=res.getName().replaceAll(""String_Node_Str"",""String_Node_Str"");
      String[] temp=appName.split(""String_Node_Str"");
      appName=temp[0];
      pw2=new PrintWriter(new FileWriter(new File(res.getAbsoluteFile().getParentFile(),killAppName)));
      pw2.println(""String_Node_Str"");
      pw2.println(""String_Node_Str"" + appName + ""String_Node_Str""+ settingsfn+ ""String_Node_Str"");
      pw2.println(""String_Node_Str"");
      pw2.println(""String_Node_Str"");
      pw2.println(""String_Node_Str"");
      if (HarvestControllerApplication.class.getName().equals(appName)) {
        pw2.println(""String_Node_Str"" + Heritrix.class.getName() + ""String_Node_Str""+ settingsfn+ ""String_Node_Str"");
        pw2.println(""String_Node_Str"");
        pw2.println(""String_Node_Str"");
        pw2.println(""String_Node_Str"");
      }
      pw2.close();
      appsToStart.add(res.getName());
    }
  finally {
      if (pw != null) {
        pw.close();
      }
      if (pw2 != null) {
        pw2.close();
      }
    }
  }
 catch (  IOException e) {
    throw new IOFailure(""String_Node_Str"" + res + ""String_Node_Str""+ appName,e);
  }
}",0.9942196531791908
90228,"/** 
 * @see HeritrixController#getProgressStats() 
 */
public String getProgressStats(){
  String statistics=(String)executeCrawlJobCommand(PROGRESS_STATISTICS_COMMAND);
  if (statistics == null) {
    return ""String_Node_Str"";
  }
  return statistics;
}","/** 
 * @see HeritrixController#getProgressStats() 
 */
public String getProgressStats(){
  String status=(String)getCrawlJobAttribute(STATUS_ATTRIBUTE);
  if (status == null) {
    status=""String_Node_Str"";
  }
  String progressStatistics=(String)executeCrawlJobCommand(PROGRESS_STATISTICS_COMMAND);
  if (progressStatistics == null) {
    return ""String_Node_Str"";
  }
  return status + ""String_Node_Str"" + progressStatistics;
}",0.7416058394160584
90229,"/** 
 * Return status information for all jobs for a given harvest definition.
 * @param harvestId The ID of a harvest definition.
 * @param numEvent The harvest run number
 * @return A list of status objects with the pertinent information forall jobs for a given harvest definition.
 */
public abstract List<JobStatusInfo> getStatusInfo(long harvestId,long numEvent);","/** 
 * /** Return status information for all jobs with given job status.
 * @param status The status asked for.
 * @return  A list of status objects with the pertinent information for all jobs with given job status.
 */
public abstract List<JobStatusInfo> getStatusInfo(JobStatus status);",0.3835616438356164
90230,"/** 
 * Change an environment to be suitable for running Heritrix. At the moment, this involves the following: Use Jar files from the lib/heritrix/lib dir. Make sure the Heritrix jar file is at the front.
 * @param environment The environment from a process builder
 */
private void updateEnvironment(Map<String,String> environment){
  final String[] pathArray=environment.get(""String_Node_Str"").split(""String_Node_Str"");
  List<String> pathParts=new ArrayList<String>(Arrays.asList(pathArray));
  File heritrixLibDir=new File(""String_Node_Str"");
  File[] jars=heritrixLibDir.listFiles(new FilenameFilter(){
    public boolean accept(    File file,    String string){
      return string.endsWith(""String_Node_Str"");
    }
  }
);
  Arrays.sort(jars,new Comparator<File>(){
    public int compare(    File file,    File file1){
      return file1.compareTo(file);
    }
  }
);
  String heritixJar=null;
  for (  File lib : jars) {
    final String jarPath=new File(heritrixLibDir,lib.getName()).getAbsolutePath();
    if (lib.getName().startsWith(""String_Node_Str"")) {
      heritixJar=jarPath;
    }
 else {
      pathParts.add(0,jarPath);
    }
  }
  if (heritixJar != null) {
    pathParts.add(0,heritixJar);
  }
 else {
    throw new IOFailure(""String_Node_Str"");
  }
  environment.put(""String_Node_Str"",StringUtils.conjoin(pathParts,""String_Node_Str""));
}","/** 
 * Change an environment to be suitable for running Heritrix. At the moment, this involves the following: Use Jar files from the lib/heritrix/lib dir. Make sure the Heritrix jar file is at the front.
 * @param environment The environment from a process builder
 */
private void updateEnvironment(Map<String,String> environment){
  List<String> pathParts=SystemUtils.getCurrentClasspath();
  File heritrixLibDir=new File(""String_Node_Str"");
  File[] jars=heritrixLibDir.listFiles(new FilenameFilter(){
    public boolean accept(    File file,    String string){
      return string.endsWith(""String_Node_Str"");
    }
  }
);
  Arrays.sort(jars,new Comparator<File>(){
    public int compare(    File file,    File file1){
      return file1.compareTo(file);
    }
  }
);
  String heritixJar=null;
  for (  File lib : jars) {
    final String jarPath=new File(heritrixLibDir,lib.getName()).getAbsolutePath();
    if (lib.getName().startsWith(""String_Node_Str"")) {
      heritixJar=jarPath;
    }
 else {
      pathParts.add(0,jarPath);
    }
  }
  if (heritixJar != null) {
    pathParts.add(0,heritixJar);
  }
 else {
    throw new IOFailure(""String_Node_Str"");
  }
  environment.put(""String_Node_Str"",StringUtils.conjoin(pathParts,""String_Node_Str""));
}",0.9197247706422018
90231,"/** 
 * This method sets the current Lucene index this object works on, replacing and closing the current index if one is already set.
 * @param indexDir The new index, a directory containing Lucene files.
 * @throws ArgumentNotValid If argument is null, or the indexDir argumentisn't a directory
 */
public void setIndex(File indexDir){
  ArgumentNotValid.checkNotNull(indexDir,""String_Node_Str"");
  ArgumentNotValid.checkTrue(indexDir.isDirectory(),""String_Node_Str"" + indexDir + ""String_Node_Str"");
  if (luceneSearcher != null) {
    try {
      luceneSearcher.close();
    }
 catch (    IOException e) {
      throw new IOFailure(""String_Node_Str"" + luceneSearcher,e);
    }
 finally {
      luceneSearcher=null;
    }
  }
  try {
    luceneSearcher=new IndexSearcher(indexDir.getAbsolutePath());
  }
 catch (  IOException e) {
    throw new IOFailure(""String_Node_Str"" + indexDir,e);
  }
}","/** 
 * This method sets the current Lucene index this object works on, replacing and closing the current index if one is already set.
 * @param indexDir The new index, a directory containing Lucene files.
 * @throws ArgumentNotValid If argument is null
 */
public void setIndex(File indexDir){
  ArgumentNotValid.checkNotNull(indexDir,""String_Node_Str"");
  ArgumentNotValid.checkTrue(indexDir.isDirectory(),""String_Node_Str"" + indexDir + ""String_Node_Str"");
  if (luceneSearcher != null) {
    try {
      luceneSearcher.close();
    }
 catch (    IOException e) {
      throw new IOFailure(""String_Node_Str"" + luceneSearcher,e);
    }
 finally {
      luceneSearcher=null;
    }
  }
  try {
    luceneSearcher=new IndexSearcher(indexDir.getAbsolutePath());
  }
 catch (  IOException e) {
    throw new IOFailure(""String_Node_Str"" + indexDir,e);
  }
}",0.9753863766456784
90232,"/** 
 * Looks up a URI in our lucene index and extracts a key.
 * @param uri A URI to look for.
 * @return The file and offset where that URI can be found, or null if itdoesn't exist.
 * @throws IllegalState If a URL is found with a malformed origin field.
 * @throws IOFailure if no index is set or Lucene gives problems.
 */
private ARCKey luceneLookup(String uri){
  if (luceneSearcher == null) {
    throw new IOFailure(""String_Node_Str"" + uri + ""String_Node_Str"");
  }
  Query query=new TermQuery(new Term(DigestIndexer.FIELD_URL,uri));
  try {
    Hits hits=luceneSearcher.search(query);
    Document doc=null;
    if (hits != null) {
      log.debug(""String_Node_Str"" + hits.length() + ""String_Node_Str""+ uri+ ""String_Node_Str"");
      for (int i=0; i < hits.length(); i++) {
        Document nextDoc=hits.doc(i);
        String origin=nextDoc.get(DigestIndexer.FIELD_ORIGIN);
        if (origin == null) {
          log.debug(""String_Node_Str"" + uri + ""String_Node_Str""+ i);
          continue;
        }
 else {
          doc=chooseBestPotentialCandidate(doc,nextDoc,uri);
        }
      }
      if (doc != null) {
        return makeARCKey(doc.get(DigestIndexer.FIELD_ORIGIN),uri);
      }
    }
  }
 catch (  IOException e) {
    throw new IOFailure(""String_Node_Str"" + uri + ""String_Node_Str"",e);
  }
  log.debug(""String_Node_Str"" + uri + ""String_Node_Str"");
  return null;
}","/** 
 * Looks up a URI in our lucene index and extracts a key.
 * @param uri A URI to look for.
 * @return The file and offset where that URI can be found, or null if itdoesn't exist.
 * @throws IllegalState If a URL is found with a malformed origin field.
 * @throws IOFailure if no index is set or Lucene gives problems.
 */
private ARCKey luceneLookup(String uri){
  if (luceneSearcher == null) {
    throw new IOFailure(""String_Node_Str"" + uri + ""String_Node_Str"");
  }
  Query query=new TermQuery(new Term(DigestIndexer.FIELD_URL,uri));
  try {
    Hits hits=luceneSearcher.search(query);
    Document doc=null;
    if (hits != null) {
      for (int i=0; i < hits.length(); i++) {
        doc=hits.doc(i);
        String origin=doc.get(DigestIndexer.FIELD_ORIGIN);
        if (origin == null) {
          log.debug(""String_Node_Str"" + uri + ""String_Node_Str""+ i);
          continue;
        }
        String[] originParts=origin.split(""String_Node_Str"");
        if (originParts.length != 2) {
          throw new IllegalState(""String_Node_Str"" + uri + ""String_Node_Str""+ origin+ ""String_Node_Str"");
        }
        return new ARCKey(originParts[0],Long.parseLong(originParts[1]));
      }
    }
  }
 catch (  IOException e) {
    throw new IOFailure(""String_Node_Str"" + uri + ""String_Node_Str"",e);
  }
  return null;
}",0.7842415316642121
90233,"/** 
 * Create a new ARCLookup object.
 * @param arcRepositoryClient The interface to the ArcRepository
 * @throws ArgumentNotValid if argument arcRepositoryClient is null.
 */
public ARCLookup(ViewerArcRepositoryClient arcRepositoryClient){
  ArgumentNotValid.checkNotNull(arcRepositoryClient,""String_Node_Str"");
  this.arcRepositoryClient=arcRepositoryClient;
  luceneSearcher=null;
}","/** 
 * Create a new ARCLookup object.
 * @param arcRepositoryClient The interface to the ArcRepository
 * @throws ArgumentNotValid if arcRepositoryClient is null.
 */
public ARCLookup(ViewerArcRepositoryClient arcRepositoryClient){
  ArgumentNotValid.checkNotNull(arcRepositoryClient,""String_Node_Str"");
  this.arcRepositoryClient=arcRepositoryClient;
  luceneSearcher=null;
}",0.9882044560943644
90234,"/** 
 * Run a batch job on all ARC entries in the archive. <p/> This currently runs synchronously, and returns only after finish() has been called.
 * @param bitarchiveAppId A String representing the bitarchive AppId.
 * @param job An object that implements the ARCBatchJob interface. The initialize() method will be called before processing and the finish() method will be called afterwards. The process() method will be called with each ARC entry.
 * @throws ArgumentNotValid if job or file is null.
 * @throws IOFailure if there was problems writing to the RemoteFile
 * @return A localBatchStatus
 */
public BatchStatus batch(String bitarchiveAppId,FileBatchJob job){
  ArgumentNotValid.checkNotNull(job,""String_Node_Str"");
  log.info(""String_Node_Str"" + job.getClass().getName());
  BatchStatus returnStatus;
  File tmpFile=null;
  try {
    tmpFile=File.createTempFile(""String_Node_Str"",""String_Node_Str"",FileUtils.getTempDir());
    OutputStream os=new FileOutputStream(tmpFile);
    try {
      log.debug(""String_Node_Str"" + job + ""String_Node_Str""+ new Date());
      File[] processFiles=admin.getFilesMatching(job.getFilenamePattern());
      BatchLocalFiles localBatchRunner=new BatchLocalFiles(processFiles);
      localBatchRunner.run(job,os);
      log.debug(""String_Node_Str"" + job + ""String_Node_Str""+ new Date());
    }
  finally {
      try {
        os.close();
      }
 catch (      IOException e) {
        log.warn(""String_Node_Str"");
      }
    }
    returnStatus=new BatchStatus(bitarchiveAppId,job.getFilesFailed(),job.getNoOfFilesProcessed(),RemoteFileFactory.getMovefileInstance(tmpFile));
  }
 catch (  IOException e) {
    log.fatal(""String_Node_Str"" + job,e);
    throw new IOFailure(""String_Node_Str"" + job,e);
  }
  return returnStatus;
}","/** 
 * Run a batch job on all ARC entries in the archive. <p/> This currently runs synchronously, and returns only after finish() has been called.
 * @param bitarchiveAppId A String representing the bitarchive AppId.
 * @param job An object that implements the ARCBatchJob interface. The initialize() method will be called before processing and the finish() method will be called afterwards. The process() method will be called with each ARC entry.
 * @throws ArgumentNotValid if job or file is null.
 * @throws IOFailure if there was problems writing to the RemoteFile
 * @return A localBatchStatus
 */
public BatchStatus batch(String bitarchiveAppId,FileBatchJob job){
  ArgumentNotValid.checkNotNull(job,""String_Node_Str"");
  log.info(""String_Node_Str"" + job.getClass().getName());
  BatchStatus returnStatus;
  File tmpFile=null;
  try {
    tmpFile=File.createTempFile(""String_Node_Str"",""String_Node_Str"",FileUtils.getTempDir());
    OutputStream os=new FileOutputStream(tmpFile);
    try {
      log.debug(""String_Node_Str"" + job + ""String_Node_Str""+ new Date());
      File[] processFiles=admin.getFilesMatching(job.getFilenamePattern());
      BatchLocalFiles localBatchRunner=new BatchLocalFiles(processFiles);
      localBatchRunner.run(job,os);
      log.debug(""String_Node_Str"" + job + ""String_Node_Str""+ new Date());
    }
  finally {
      try {
        os.close();
      }
 catch (      IOException e) {
        log.warn(""String_Node_Str"");
      }
    }
    returnStatus=new BatchStatus(bitarchiveAppId,job.getFilesFailed(),job.getNoOfFilesProcessed(),RemoteFileFactory.getMovefileInstance(tmpFile));
  }
 catch (  IOException e) {
    log.fatal(""String_Node_Str"" + job,e);
    throw new IOFailure(""String_Node_Str"" + job,e);
  }
  log.info(""String_Node_Str"" + job.getClass().getName() + ""String_Node_Str""+ returnStatus);
  return returnStatus;
}",0.9642267473858008
90235,"/** 
 * Get a file for a given arcFileID.
 * @param arcFileID name of the file to be retrieved.
 * @return The file requested or null if not found
 * @throws ArgumentNotValid If arcFileID was null or empty.
 */
public File getFile(String arcFileID) throws ArgumentNotValid {
  log.info(""String_Node_Str"" + arcFileID);
  ArgumentNotValid.checkNotNullOrEmpty(arcFileID,""String_Node_Str"");
  BitarchiveARCFile barc=admin.lookup(arcFileID);
  if (barc == null) {
    return null;
  }
  return barc.getFilePath();
}","/** 
 * Get a file for a given arcFileID.
 * @param arcFileID name of the file to be retrieved.
 * @return The file requested or null if not found
 * @throws ArgumentNotValid If arcFileID was null or empty.
 */
public File getFile(String arcFileID) throws ArgumentNotValid {
  log.info(""String_Node_Str"" + arcFileID + ""String_Node_Str"");
  ArgumentNotValid.checkNotNullOrEmpty(arcFileID,""String_Node_Str"");
  BitarchiveARCFile barc=admin.lookup(arcFileID);
  if (barc == null) {
    return null;
  }
  File path=barc.getFilePath();
  log.info(""String_Node_Str"" + path + ""String_Node_Str"");
  return path;
}",0.9014336917562724
90236,"public void testLogBatch(){
  try {
    String logtxt=FileUtils.readFile(LOG_FILE);
    assertNotStringContains(""String_Node_Str"",logtxt,""String_Node_Str"");
    try {
      archive.batch(TestInfo.baAppId,new ARCBatchJob(){
        public BatchFilter getFilter(){
          return BatchFilter.NO_FILTER;
        }
        public void initialize(        OutputStream os){
        }
        public void processRecord(        ARCRecord record,        OutputStream os){
        }
        public void finish(        OutputStream os){
        }
      }
);
    }
 catch (    Exception e) {
      fail(""String_Node_Str"" + e);
    }
    FileAsserts.assertFileContains(""String_Node_Str"",""String_Node_Str"",LOG_FILE);
    FileAsserts.assertFileContains(""String_Node_Str"",""String_Node_Str"",LOG_FILE);
  }
 catch (  IOException e) {
    fail(""String_Node_Str"" + e);
  }
}","public void testLogBatch(){
  try {
    String logtxt=FileUtils.readFile(LOG_FILE);
    assertNotStringContains(""String_Node_Str"",logtxt,""String_Node_Str"");
    try {
      archive.batch(TestInfo.baAppId,new ARCBatchJob(){
        public BatchFilter getFilter(){
          return BatchFilter.NO_FILTER;
        }
        public void initialize(        OutputStream os){
        }
        public void processRecord(        ARCRecord record,        OutputStream os){
        }
        public void finish(        OutputStream os){
        }
      }
);
    }
 catch (    Exception e) {
      fail(""String_Node_Str"" + e);
    }
    FileAsserts.assertFileContains(""String_Node_Str"",""String_Node_Str"",LOG_FILE);
    FileAsserts.assertFileContains(""String_Node_Str"",""String_Node_Str"",LOG_FILE);
    FileAsserts.assertFileContains(""String_Node_Str"",""String_Node_Str"",LOG_FILE);
    FileAsserts.assertFileContains(""String_Node_Str"",""String_Node_Str"",LOG_FILE);
    FileAsserts.assertFileContains(""String_Node_Str"",""String_Node_Str"",LOG_FILE);
  }
 catch (  IOException e) {
    fail(""String_Node_Str"" + e);
  }
}",0.874361593462717
90237,"/** 
 * Verify that multiple messages sent almost simultaneously works
 */
public void testLotsOfMessages(){
  MessageTestHandler handler=new MessageTestHandler();
  JMSConnectionFactory.getInstance().setListener(Channels.getTheArcrepos(),handler);
  JMSConnectionFactory.getInstance().setListener(Channels.getThisHaco(),handler);
  Settings.set(Settings.REMOTE_FILE_CLASS,""String_Node_Str"");
  assertTrue(""String_Node_Str"" + FILE_TO_UPLOAD,FILE_TO_UPLOAD.exists());
  int beforeCount=Thread.activeCount();
  for (int i=0; i < LARGE_MESSAGE_COUNT; ++i) {
    bac.get(FILENAME_TO_GET,0);
    bac.upload(RemoteFileFactory.getInstance(FILE_TO_UPLOAD,true,false,true));
    BatchMessage bMsg=new BatchMessage(THE_BAMON,Channels.getThisHaco(),new TestBatchJobRuns(),Settings.get(Settings.ENVIRONMENT_THIS_LOCATION));
    bac.batch(bMsg);
    RemoveAndGetFileMessage rMsg=new RemoveAndGetFileMessage(FILENAME_TO_GET,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    bac.removeAndGetFile(rMsg);
  }
  while (Thread.activeCount() > beforeCount) {
    try {
      Thread.sleep(1000);
    }
 catch (    InterruptedException e) {
    }
  }
  ((JMSConnectionTestMQ)JMSConnectionFactory.getInstance()).waitForConcurrentTasksToFinish();
  assertEquals(""String_Node_Str"" + LARGE_MESSAGE_COUNT + ""String_Node_Str""+ handler.getMsg,LARGE_MESSAGE_COUNT,handler.getMsg.size());
  assertEquals(""String_Node_Str"" + LARGE_MESSAGE_COUNT + ""String_Node_Str""+ handler.uploadMsg,LARGE_MESSAGE_COUNT,handler.uploadMsg.size());
  assertEquals(""String_Node_Str"" + LARGE_MESSAGE_COUNT + ""String_Node_Str""+ handler.removeMsg,LARGE_MESSAGE_COUNT,handler.removeMsg.size());
  assertEquals(""String_Node_Str"" + LARGE_MESSAGE_COUNT + ""String_Node_Str""+ handler.batchReplyMsg,LARGE_MESSAGE_COUNT,handler.batchReplyMsg.size());
  assertEquals(""String_Node_Str"",LARGE_MESSAGE_COUNT * 4,handler.getTotalCount());
  int countok=0;
  for (int i=0; i < LARGE_MESSAGE_COUNT; ++i) {
    GetMessage msg=handler.getMsg.get(i);
    if (msg.isOk()) {
      ++countok;
    }
  }
  assertEquals(""String_Node_Str"" + handler.getMsg,LARGE_MESSAGE_COUNT,countok);
  countok=0;
  for (int i=0; i < LARGE_MESSAGE_COUNT; ++i) {
    UploadMessage msg=handler.uploadMsg.get(i);
    if (msg.isOk()) {
      ++countok;
    }
  }
  assertEquals(""String_Node_Str"" + handler.uploadMsg,1,countok);
  countok=0;
  for (int i=0; i < LARGE_MESSAGE_COUNT; ++i) {
    BatchReplyMessage msg=handler.batchReplyMsg.get(i);
    if (msg.isOk()) {
      ++countok;
    }
  }
  assertEquals(""String_Node_Str"" + handler.batchReplyMsg,LARGE_MESSAGE_COUNT,countok);
  countok=0;
  for (int i=0; i < LARGE_MESSAGE_COUNT; ++i) {
    RemoveAndGetFileMessage msg=handler.removeMsg.get(i);
    if (!msg.isOk()) {
      ++countok;
    }
  }
  assertEquals(""String_Node_Str"" + handler.removeMsg,LARGE_MESSAGE_COUNT,countok);
}","/** 
 * Verify that multiple messages sent almost simultaneously works
 */
public void testLotsOfMessages(){
  MessageTestHandler handler=new MessageTestHandler();
  JMSConnectionFactory.getInstance().setListener(Channels.getTheArcrepos(),handler);
  JMSConnectionFactory.getInstance().setListener(Channels.getThisHaco(),handler);
  assertTrue(""String_Node_Str"" + FILE_TO_UPLOAD,FILE_TO_UPLOAD.exists());
  int beforeCount=Thread.activeCount();
  for (int i=0; i < LARGE_MESSAGE_COUNT; ++i) {
    bac.get(FILENAME_TO_GET,0);
    bac.upload(RemoteFileFactory.getInstance(FILE_TO_UPLOAD,true,false,true));
    BatchMessage bMsg=new BatchMessage(THE_BAMON,Channels.getThisHaco(),new TestBatchJobRuns(),Settings.get(Settings.ENVIRONMENT_THIS_LOCATION));
    bac.batch(bMsg);
    RemoveAndGetFileMessage rMsg=new RemoveAndGetFileMessage(FILENAME_TO_GET,""String_Node_Str"",""String_Node_Str"",""String_Node_Str"");
    bac.removeAndGetFile(rMsg);
  }
  while (Thread.activeCount() > beforeCount) {
    try {
      Thread.sleep(1000);
    }
 catch (    InterruptedException e) {
    }
  }
  ((JMSConnectionTestMQ)JMSConnectionFactory.getInstance()).waitForConcurrentTasksToFinish();
  try {
    Thread.sleep(1000);
  }
 catch (  InterruptedException e) {
  }
  ((JMSConnectionTestMQ)JMSConnectionFactory.getInstance()).waitForConcurrentTasksToFinish();
  assertEquals(""String_Node_Str"" + LARGE_MESSAGE_COUNT + ""String_Node_Str""+ handler.getMsg,LARGE_MESSAGE_COUNT,handler.getMsg.size());
  assertEquals(""String_Node_Str"" + LARGE_MESSAGE_COUNT + ""String_Node_Str""+ handler.uploadMsg,LARGE_MESSAGE_COUNT,handler.uploadMsg.size());
  assertEquals(""String_Node_Str"" + LARGE_MESSAGE_COUNT + ""String_Node_Str""+ handler.removeMsg,LARGE_MESSAGE_COUNT,handler.removeMsg.size());
  assertEquals(""String_Node_Str"" + LARGE_MESSAGE_COUNT + ""String_Node_Str""+ handler.batchReplyMsg,LARGE_MESSAGE_COUNT,handler.batchReplyMsg.size());
  assertEquals(""String_Node_Str"",LARGE_MESSAGE_COUNT * 4,handler.getTotalCount());
  int countok=0;
  for (int i=0; i < LARGE_MESSAGE_COUNT; ++i) {
    GetMessage msg=handler.getMsg.get(i);
    if (msg.isOk()) {
      ++countok;
    }
  }
  assertEquals(""String_Node_Str"" + handler.getMsg,LARGE_MESSAGE_COUNT,countok);
  countok=0;
  for (int i=0; i < LARGE_MESSAGE_COUNT; ++i) {
    UploadMessage msg=handler.uploadMsg.get(i);
    if (msg.isOk()) {
      ++countok;
    }
  }
  assertEquals(""String_Node_Str"" + handler.uploadMsg,1,countok);
  countok=0;
  for (int i=0; i < LARGE_MESSAGE_COUNT; ++i) {
    BatchReplyMessage msg=handler.batchReplyMsg.get(i);
    if (msg.isOk()) {
      ++countok;
    }
  }
  assertEquals(""String_Node_Str"" + handler.batchReplyMsg,LARGE_MESSAGE_COUNT,countok);
  countok=0;
  for (int i=0; i < LARGE_MESSAGE_COUNT; ++i) {
    RemoveAndGetFileMessage msg=handler.removeMsg.get(i);
    if (!msg.isOk()) {
      ++countok;
    }
  }
  assertEquals(""String_Node_Str"" + handler.removeMsg,LARGE_MESSAGE_COUNT,countok);
}",0.9600137883488452
90238,"/** 
 * Test that monitor can receive and aggregate data from more than one BitarchiveServer and aggregate the data and upload it via FTPRemoteFile
 */
public void testBatchEndedMessageAggregation(){
  Settings.set(Settings.REMOTE_FILE_CLASS,FTPRemoteFile.class.getName());
  bas.close();
  JMSConnection con=JMSConnectionFactory.getInstance();
  TestMessageListener listener=new TestMessageListener();
  con.setListener(Channels.getTheArcrepos(),listener);
  con.setListener(Channels.getAllBa(),listener);
  File output_file=new File(WORKING,""String_Node_Str"");
  BatchMessage bm=new BatchMessage(Channels.getTheBamon(),Channels.getTheArcrepos(),new ChecksumJob(),Settings.get(Settings.ENVIRONMENT_THIS_LOCATION));
  JMSConnectionTestMQ.updateMsgID(bm,""String_Node_Str"");
  String baID1=""String_Node_Str"";
  HeartBeatMessage hbm=new HeartBeatMessage(Channels.getTheBamon(),baID1);
  JMSConnectionTestMQ.updateMsgID(hbm,""String_Node_Str"");
  String baID2=""String_Node_Str"";
  HeartBeatMessage hbm2=new HeartBeatMessage(Channels.getTheBamon(),baID2);
  JMSConnectionTestMQ.updateMsgID(hbm2,""String_Node_Str"");
  bam.visit(hbm);
  bam.visit(hbm2);
  ((JMSConnectionTestMQ)con).waitForConcurrentTasksToFinish();
  bam.visit(bm);
  ((JMSConnectionTestMQ)con).waitForConcurrentTasksToFinish();
  String forwardedID=((BatchMessage)listener.getAllReceived().get(0)).getID();
  File data1=new File(WORKING,""String_Node_Str"");
  File data2=new File(WORKING,""String_Node_Str"");
  RemoteFile rf1=RemoteFileFactory.getInstance(data1,true,false,true);
  BatchEndedMessage bem1=new BatchEndedMessage(Channels.getTheBamon(),baID1,forwardedID,rf1);
  RemoteFile rf2=RemoteFileFactory.getInstance(data2,true,false,true);
  BatchEndedMessage bem2=new BatchEndedMessage(Channels.getTheBamon(),baID2,forwardedID,rf2);
  JMSConnectionTestMQ.updateMsgID(bem1,""String_Node_Str"");
  bam.visit(bem1);
  JMSConnectionTestMQ.updateMsgID(bem2,""String_Node_Str"");
  bam.visit(bem2);
  ((JMSConnectionTestMQ)con).waitForConcurrentTasksToFinish();
  assertEquals(""String_Node_Str"" + listener.getAllReceived(),2,listener.getNumReceived());
  List received=listener.getAllReceived();
  for (Iterator i=received.iterator(); i.hasNext(); ) {
    Object o=i.next();
    if (o instanceof BatchReplyMessage) {
      ((BatchReplyMessage)o).getResultFile().copyTo(output_file);
    }
  }
  FileAsserts.assertFileNumberOfLines(""String_Node_Str"" + ""String_Node_Str"",output_file,2);
  FileAsserts.assertFileContains(""String_Node_Str"",""String_Node_Str"",output_file);
  FileAsserts.assertFileContains(""String_Node_Str"",""String_Node_Str"",output_file);
  int expected_length=FileUtils.readBinaryFile(data1).length + FileUtils.readBinaryFile(data2).length;
  int actual_length=FileUtils.readBinaryFile(output_file).length;
  assertEquals(""String_Node_Str"",expected_length,actual_length);
  File a_file=new File(WORKING,""String_Node_Str"");
  try {
    rf1.copyTo(a_file);
    fail(""String_Node_Str"" + rf1.toString());
  }
 catch (  IOFailure e) {
  }
  try {
    rf2.copyTo(a_file);
    fail(""String_Node_Str"" + rf2.toString());
  }
 catch (  IOFailure e) {
  }
  con.removeListener(Channels.getTheArcrepos(),listener);
  con.removeListener(Channels.getAllBa(),listener);
}","/** 
 * Test that monitor can receive and aggregate data from more than one BitarchiveServer and aggregate the data and upload it via FTPRemoteFile
 */
public void testBatchEndedMessageAggregation() throws InterruptedException {
  Settings.set(Settings.REMOTE_FILE_CLASS,FTPRemoteFile.class.getName());
  bas.close();
  JMSConnection con=JMSConnectionFactory.getInstance();
  TestMessageListener listener=new TestMessageListener();
  con.setListener(Channels.getTheArcrepos(),listener);
  con.setListener(Channels.getAllBa(),listener);
  File output_file=new File(WORKING,""String_Node_Str"");
  BatchMessage bm=new BatchMessage(Channels.getTheBamon(),Channels.getTheArcrepos(),new ChecksumJob(),Settings.get(Settings.ENVIRONMENT_THIS_LOCATION));
  JMSConnectionTestMQ.updateMsgID(bm,""String_Node_Str"");
  String baID1=""String_Node_Str"";
  HeartBeatMessage hbm=new HeartBeatMessage(Channels.getTheBamon(),baID1);
  JMSConnectionTestMQ.updateMsgID(hbm,""String_Node_Str"");
  String baID2=""String_Node_Str"";
  HeartBeatMessage hbm2=new HeartBeatMessage(Channels.getTheBamon(),baID2);
  JMSConnectionTestMQ.updateMsgID(hbm2,""String_Node_Str"");
  bam.visit(hbm);
  bam.visit(hbm2);
  ((JMSConnectionTestMQ)con).waitForConcurrentTasksToFinish();
  bam.visit(bm);
  ((JMSConnectionTestMQ)con).waitForConcurrentTasksToFinish();
  String forwardedID=((BatchMessage)listener.getAllReceived().get(0)).getID();
  File data1=new File(WORKING,""String_Node_Str"");
  File data2=new File(WORKING,""String_Node_Str"");
  RemoteFile rf1=RemoteFileFactory.getInstance(data1,true,false,true);
  BatchEndedMessage bem1=new BatchEndedMessage(Channels.getTheBamon(),baID1,forwardedID,rf1);
  RemoteFile rf2=RemoteFileFactory.getInstance(data2,true,false,true);
  BatchEndedMessage bem2=new BatchEndedMessage(Channels.getTheBamon(),baID2,forwardedID,rf2);
  JMSConnectionTestMQ.updateMsgID(bem1,""String_Node_Str"");
  bam.visit(bem1);
  JMSConnectionTestMQ.updateMsgID(bem2,""String_Node_Str"");
  bam.visit(bem2);
  ((JMSConnectionTestMQ)con).waitForConcurrentTasksToFinish();
  Thread.sleep(5000);
  ((JMSConnectionTestMQ)con).waitForConcurrentTasksToFinish();
  assertEquals(""String_Node_Str"" + listener.getAllReceived(),2,listener.getNumReceived());
  List received=listener.getAllReceived();
  for (Iterator i=received.iterator(); i.hasNext(); ) {
    Object o=i.next();
    if (o instanceof BatchReplyMessage) {
      ((BatchReplyMessage)o).getResultFile().copyTo(output_file);
    }
  }
  FileAsserts.assertFileNumberOfLines(""String_Node_Str"" + ""String_Node_Str"",output_file,2);
  FileAsserts.assertFileContains(""String_Node_Str"",""String_Node_Str"",output_file);
  FileAsserts.assertFileContains(""String_Node_Str"",""String_Node_Str"",output_file);
  int expected_length=FileUtils.readBinaryFile(data1).length + FileUtils.readBinaryFile(data2).length;
  int actual_length=FileUtils.readBinaryFile(output_file).length;
  assertEquals(""String_Node_Str"",expected_length,actual_length);
  File a_file=new File(WORKING,""String_Node_Str"");
  try {
    rf1.copyTo(a_file);
    fail(""String_Node_Str"" + rf1.toString());
  }
 catch (  IOFailure e) {
  }
  try {
    rf2.copyTo(a_file);
    fail(""String_Node_Str"" + rf2.toString());
  }
 catch (  IOFailure e) {
  }
  con.removeListener(Channels.getTheArcrepos(),listener);
  con.removeListener(Channels.getAllBa(),listener);
}",0.982627247790308
90239,"/** 
 * Clean up.
 */
public void cleanup(){
  try {
    if (myQConn != null) {
      myQConn.close();
    }
    if (myTConn != null) {
      myTConn.close();
    }
    if (consumers != null) {
      consumers.clear();
    }
    if (senders != null) {
      senders.clear();
    }
    if (publishers != null) {
      publishers.clear();
    }
  }
 catch (  JMSException e) {
    throw new IOFailure(""String_Node_Str"",e);
  }
}","/** 
 * Clean up.
 */
public void cleanup(){
  try {
    if (myQConn != null) {
      myQConn.close();
    }
    myQConn=null;
    if (myTConn != null) {
      myTConn.close();
    }
    myTConn=null;
    if (consumers != null) {
      consumers.clear();
    }
    consumers=null;
    if (senders != null) {
      senders.clear();
    }
    senders=null;
    if (publishers != null) {
      publishers.clear();
    }
  }
 catch (  JMSException e) {
    throw new IOFailure(""String_Node_Str"",e);
  }
}",0.9200863930885528
90240,"/** 
 * Returns a new TopicConnectionFactory. This is an SunMQ implementation of TopicConnectionFactory. Notice: The return type is explicitly defined with package prefix to avoid name collision with javax.jms.TopicConnectionFactory
 * @throws JMSException
 * @return TopicConnectionFactory
 */
protected javax.jms.TopicConnectionFactory getTopicConnectionFactory() throws JMSException {
  TopicConnectionFactory cFactory=new TopicConnectionFactory();
  ((com.sun.messaging.ConnectionFactory)cFactory).setProperty(com.sun.messaging.ConnectionConfiguration.imqBrokerHostName,getHost());
  ((com.sun.messaging.ConnectionFactory)cFactory).setProperty(com.sun.messaging.ConnectionConfiguration.imqBrokerHostPort,String.valueOf(getPort()));
  ((com.sun.messaging.ConnectionFactory)cFactory).setProperty(com.sun.messaging.ConnectionConfiguration.imqConsumerFlowLimit,""String_Node_Str"");
  return cFactory;
}","/** 
 * Returns a new TopicConnectionFactory. This is an SunMQ implementation of TopicConnectionFactory. Notice: The return type is explicitly defined with package prefix to avoid name collision with javax.jms.TopicConnectionFactory
 * @throws JMSException
 * @return TopicConnectionFactory
 */
protected TopicConnectionFactory getTopicConnectionFactory() throws JMSException {
  TopicConnectionFactory cFactory=new TopicConnectionFactory();
  ((ConnectionFactory)cFactory).setProperty(ConnectionConfiguration.imqBrokerHostName,getHost());
  ((ConnectionFactory)cFactory).setProperty(ConnectionConfiguration.imqBrokerHostPort,String.valueOf(getPort()));
  ((ConnectionFactory)cFactory).setProperty(ConnectionConfiguration.imqConsumerFlowLimit,""String_Node_Str"");
  return cFactory;
}",0.9299287410926366
90241,"/** 
 * Returns a new QueueConnectionFactory. This is an SunMQ implementation of QueueConnectionFactory. Notice: The return type is explicitly defined with package prefix to avoid name collision with javax.jms.QueueConnectionFactory
 * @throws JMSException
 * @return QueueConnectionFactory
 */
protected javax.jms.QueueConnectionFactory getQueueConnectionFactory() throws JMSException {
  QueueConnectionFactory cFactory=new QueueConnectionFactory();
  ((com.sun.messaging.ConnectionFactory)cFactory).setProperty(com.sun.messaging.ConnectionConfiguration.imqBrokerHostName,getHost());
  ((com.sun.messaging.ConnectionFactory)cFactory).setProperty(com.sun.messaging.ConnectionConfiguration.imqBrokerHostPort,String.valueOf(getPort()));
  ((com.sun.messaging.ConnectionFactory)cFactory).setProperty(com.sun.messaging.ConnectionConfiguration.imqConsumerFlowLimit,""String_Node_Str"");
  return cFactory;
}","/** 
 * Returns a new QueueConnectionFactory. This is an SunMQ implementation of QueueConnectionFactory. Notice: The return type is explicitly defined with package prefix to avoid name collision with javax.jms.QueueConnectionFactory
 * @throws JMSException
 * @return QueueConnectionFactory
 */
protected QueueConnectionFactory getQueueConnectionFactory() throws JMSException {
  QueueConnectionFactory cFactory=new QueueConnectionFactory();
  ((ConnectionFactory)cFactory).setProperty(ConnectionConfiguration.imqBrokerHostName,getHost());
  ((ConnectionFactory)cFactory).setProperty(ConnectionConfiguration.imqBrokerHostPort,String.valueOf(getPort()));
  ((ConnectionFactory)cFactory).setProperty(ConnectionConfiguration.imqConsumerFlowLimit,""String_Node_Str"");
  return cFactory;
}",0.9299287410926366
90242,"/** 
 * Intialises a Open Message Queue JMS connection.
 * @return A JMSConnection
 * @throws IOFailure when connection to JMS broker failed
 */
public static JMSConnectionSunMQ getInstance() throws UnknownID, IOFailure {
  if (instance == null) {
    instance=new JMSConnectionSunMQ();
  }
  return instance;
}","/** 
 * Intialises a Open Message Queue JMS connection.
 * @return A JMSConnection
 * @throws IOFailure when connection to JMS broker failed
 */
public static synchronized JMSConnectionSunMQ getInstance() throws UnknownID, IOFailure {
  if (instance == null) {
    instance=new JMSConnectionSunMQ();
  }
  return instance;
}",0.979527559055118
90243,"/** 
 * Test that files larger than 2GB can be copied! 
 */
public void testCopyLargeFiles() throws IOException {
  byte[] block=new byte[BLOCKSIZE];
  SUBDIR.mkdirs();
  File largeFile=new File(SUBDIR,LARGE_FILE);
  OutputStream os=new FileOutputStream(largeFile);
  System.out.println(""String_Node_Str"");
  for (long l=0; l < LARGE / ((long)BLOCKSIZE) + 1L; l++) {
    os.write(block);
  }
  System.out.println(""String_Node_Str"");
  FileUtils.copyDirectory(SUBDIR,SUBDIR2);
  File file1=new File(SUBDIR,LARGE_FILE);
  File file2=new File(SUBDIR2,LARGE_FILE);
  assertEquals(""String_Node_Str"",file1.length(),file2.length());
}","/** 
 * Test that files larger than 2GB can be copied! 
 */
public void testCopyLargeFiles() throws IOException {
  byte[] block=new byte[BLOCKSIZE];
  SUBDIR.mkdirs();
  File largeFile=new File(SUBDIR,LARGE_FILE);
  OutputStream os=new BufferedOutputStream(new FileOutputStream(largeFile));
  System.out.println(""String_Node_Str"");
  for (long l=0; l < LARGE / ((long)BLOCKSIZE) + 1L; l++) {
    os.write(block);
  }
  System.out.println(""String_Node_Str"");
  FileUtils.copyDirectory(SUBDIR,SUBDIR2);
  File file1=new File(SUBDIR,LARGE_FILE);
  File file2=new File(SUBDIR2,LARGE_FILE);
  assertEquals(""String_Node_Str"",file1.length(),file2.length());
}",0.959375
90244,"/** 
 * Tests that a class has a static factory method getInstance() and that it acts as a singleton. NB This method will create an instance of the class. It is your responsibility to clean up after yourself.
 * @param c the class to test
 * @return the singleton
 */
public static <T>T assertSingleton(Class<T> c){
  assertHasFactoryMethod(c);
  assertPrivateConstructor(c);
  T o1=null;
  T o2=null;
  try {
    Method m=c.getDeclaredMethod(""String_Node_Str"");
    o1=(T)m.invoke(null);
    o2=(T)m.invoke(null);
  }
 catch (  Exception e) {
    throw new PermissionDenied(""String_Node_Str"",e);
  }
  TestCase.assertEquals(""String_Node_Str"" + ""String_Node_Str"" + c.getName(),o1,o2);
  if (o1 instanceof CleanupIF) {
    ((CleanupIF)o1).cleanup();
  }
  return o1;
}","/** 
 * Tests that a class has a static factory method getInstance() and that it acts as a singleton. NB This method will create an instance of the class. It is your responsibility to clean up after yourself.
 * @param c the class to test
 * @return the singleton
 */
public static <T>T assertSingleton(Class<T> c){
  assertHasFactoryMethod(c);
  assertPrivateConstructor(c);
  T o1=null;
  T o2=null;
  try {
    Method m=c.getDeclaredMethod(""String_Node_Str"");
    o1=(T)m.invoke(null);
    o2=(T)m.invoke(null);
  }
 catch (  Exception e) {
    throw new PermissionDenied(""String_Node_Str"",e);
  }
  TestCase.assertSame(""String_Node_Str"" + ""String_Node_Str"" + c.getName(),o1,o2);
  if (o1 instanceof CleanupIF) {
    ((CleanupIF)o1).cleanup();
  }
  return o1;
}",0.9934725848563968
90245,"public void tearDown() throws Exception {
  super.tearDown();
  Settings.reload();
  System.setSecurityManager(m);
  if (gui != null) {
    gui.close();
  }
}","public void tearDown() throws Exception {
  super.tearDown();
  Settings.reload();
  System.setSecurityManager(m);
  if (gui != null) {
    gui.cleanup();
  }
}",0.981132075471698
90246,"public void testRun() throws IOException, SAXException {
  gui=HarvestDefinitionGUI.getInstance();
  WebConversation conv=new WebConversation();
  conv.setExceptionsThrownOnErrorStatus(false);
  WebResponse resp=conv.getResponse(""String_Node_Str"" + Integer.toString(TestInfo.GUI_WEB_SERVER_PORT) + ""String_Node_Str""+ TestInfo.GUI_WEB_SERVER_WEBBASE);
  assertTrue(""String_Node_Str"" + resp.getURL() + ""String_Node_Str""+ resp.getResponseCode(),resp.getResponseCode() == 200);
}","public void testRun() throws IOException, SAXException {
  gui=GUIWebServer.getInstance();
  WebConversation conv=new WebConversation();
  conv.setExceptionsThrownOnErrorStatus(false);
  WebResponse resp=conv.getResponse(""String_Node_Str"" + Integer.toString(TestInfo.GUI_WEB_SERVER_PORT) + ""String_Node_Str""+ TestInfo.GUI_WEB_SERVER_WEBBASE);
  assertTrue(""String_Node_Str"" + resp.getURL() + ""String_Node_Str""+ resp.getResponseCode(),resp.getResponseCode() == 200);
}",0.9723991507430998
90247,"/** 
 * Tests what happens if we have a blocking listener. It appears that by default, a listener may pre-queue messages even while it is blocked processing the previous message. This is not desirable behaviour.
 * @throws InterruptedException
 * @throws JMSException
 */
public void testNotListeningWhileProcessingSunMQ() throws InterruptedException, JMSException {
  if (!Settings.get(Settings.JMS_BROKER_CLASS).equals(""String_Node_Str"")) {
    return;
  }
  JMSConnectionFactory.getInstance().cleanup();
  JMSConnectionFactory.getInstance();
  long blockingTime=1000l;
  int messagesSent=10;
  BlockingListener nonBlocker=new BlockingListener();
  BlockingListener blocker=new BlockingListener(true,blockingTime);
  ChannelID theQueue=Channels.getTheBamon();
  JMSConnection con=JMSConnectionFactory.getInstance();
  MiniConnectionSunMQ con2=new MiniConnectionSunMQ();
  con.setListener(theQueue,blocker);
  con2.setListener(theQueue,nonBlocker);
  for (int i=0; i < messagesSent; i++) {
    NetarkivetMessage msg=new BatchMessage(theQueue,new ChecksumJob(),""String_Node_Str"");
    con.send(msg);
  }
  while (HangingListenerTest.messages_received < messagesSent) {
  }
  Thread.sleep(2 * blockingTime);
  assertEquals(""String_Node_Str"",1,blocker.called);
  System.out.println(""String_Node_Str"");
  for (int i=0; i < messagesSent; i++) {
    NetarkivetMessage msg=new BatchMessage(theQueue,new ChecksumJob(),""String_Node_Str"");
    con.send(msg);
  }
  while (HangingListenerTest.messages_received < messagesSent) {
  }
  Thread.sleep(2 * blockingTime);
  assertEquals(""String_Node_Str"",2,blocker.called);
  con.cleanup();
  con2.cleanup();
}","/** 
 * Tests what happens if we have a blocking listener. It appears that by default, a listener may pre-queue messages even while it is blocked processing the previous message. This is not desirable behaviour.
 * @throws InterruptedException
 * @throws JMSException
 */
public void testNotListeningWhileProcessingSunMQ() throws InterruptedException, JMSException {
  if (!Settings.get(Settings.JMS_BROKER_CLASS).equals(JMSConnectionSunMQ.class.getName())) {
    fail(""String_Node_Str"");
  }
  JMSConnectionFactory.getInstance().cleanup();
  JMSConnectionFactory.getInstance();
  long blockingTime=1000l;
  int messagesSent=10;
  BlockingListener nonBlocker=new BlockingListener();
  BlockingListener blocker=new BlockingListener(true,blockingTime);
  ChannelID theQueue=Channels.getTheBamon();
  JMSConnection con=JMSConnectionFactory.getInstance();
  MiniConnectionSunMQ con2=new MiniConnectionSunMQ();
  con.setListener(theQueue,blocker);
  con2.setListener(theQueue,nonBlocker);
  for (int i=0; i < messagesSent; i++) {
    NetarkivetMessage msg=new BatchMessage(theQueue,new ChecksumJob(),""String_Node_Str"");
    con.send(msg);
  }
  while (HangingListenerTest.messages_received < messagesSent) {
  }
  Thread.sleep(2 * blockingTime);
  assertEquals(""String_Node_Str"",1,blocker.called);
  System.out.println(""String_Node_Str"");
  for (int i=0; i < messagesSent; i++) {
    NetarkivetMessage msg=new BatchMessage(theQueue,new ChecksumJob(),""String_Node_Str"");
    con.send(msg);
  }
  while (HangingListenerTest.messages_received < messagesSent) {
  }
  Thread.sleep(2 * blockingTime);
  assertEquals(""String_Node_Str"",2,blocker.called);
  con.cleanup();
  con2.cleanup();
}",0.9813477737665464
90248,"/** 
 * Constructor.
 */
private JMSConnectionSunMQ(){
  super();
  log.info(""String_Node_Str"");
  initConnection();
}","/** 
 * Constructor.
 */
private JMSConnectionSunMQ(){
  super();
  log.info(""String_Node_Str"" + getClass().getName());
  initConnection();
}",0.9111969111969112
90249,"/** 
 * Monitors the crawling performed by Heritrix. Regularly checks whether any progress is made. If no progress has been made for too long, the crawl is ended.
 */
private void doCrawlLoop(){
  long lastNonZeroActiveQueuesTime=System.currentTimeMillis();
  long lastTimeReceivedData=System.currentTimeMillis();
  try {
    while (!heritrixController.crawlIsEnded()) {
      log.info(""String_Node_Str"" + files.getJobID() + ""String_Node_Str""+ this.files.getHarvestID()+ ""String_Node_Str""+ heritrixController.getProgressStats());
      if (heritrixController.getCurrentProcessedKBPerSec() > 0 || heritrixController.isPaused()) {
        lastTimeReceivedData=System.currentTimeMillis();
      }
      if (heritrixController.getActiveToeCount() > 0 || heritrixController.isPaused()) {
        lastNonZeroActiveQueuesTime=System.currentTimeMillis();
      }
      if ((lastNonZeroActiveQueuesTime + timeOutInMillis < System.currentTimeMillis()) || (lastTimeReceivedData + timeOutInMillisReceivedData < System.currentTimeMillis())) {
        final double timeoutInSeconds=timeOutInMillis / 1000.0;
        log.warn(""String_Node_Str"" + ""String_Node_Str"" + ((System.currentTimeMillis() - lastNonZeroActiveQueuesTime) / 1000.0) + ""String_Node_Str""+ timeoutInSeconds+ ""String_Node_Str""+ ((System.currentTimeMillis() - lastTimeReceivedData) / 1000.0)+ ""String_Node_Str""+ timeoutInSeconds+ ""String_Node_Str""+ heritrixController.getQueuedUriCount());
        heritrixController.requestCrawlStop(""String_Node_Str"");
      }
      if (!heritrixController.crawlIsEnded()) {
        try {
synchronized (this) {
            wait(WAIT_PERIOD);
          }
        }
 catch (        InterruptedException e) {
          log.trace(""String_Node_Str"" + e.getMessage());
        }
      }
    }
  }
  finally {
    heritrixController.cleanup();
  }
}","/** 
 * Monitors the crawling performed by Heritrix. Regularly checks whether any progress is made. If no progress has been made for too long, the crawl is ended.
 */
private void doCrawlLoop(){
  long lastNonZeroActiveQueuesTime=System.currentTimeMillis();
  long lastTimeReceivedData=System.currentTimeMillis();
  try {
    while (!heritrixController.crawlIsEnded()) {
      log.info(""String_Node_Str"" + files.getJobID() + ""String_Node_Str""+ this.files.getHarvestID()+ ""String_Node_Str""+ heritrixController.getProgressStats());
      if (heritrixController.getCurrentProcessedKBPerSec() > 0 || heritrixController.isPaused()) {
        lastTimeReceivedData=System.currentTimeMillis();
      }
      if (heritrixController.getActiveToeCount() > 0 || heritrixController.isPaused()) {
        lastNonZeroActiveQueuesTime=System.currentTimeMillis();
      }
      if ((lastNonZeroActiveQueuesTime + timeOutInMillis < System.currentTimeMillis()) || (lastTimeReceivedData + timeOutInMillisReceivedData < System.currentTimeMillis())) {
        final double noActiveQueuesTimeoutInSeconds=timeOutInMillis / 1000.0;
        final double noDataReceivedTimeoutInSeconds=timeOutInMillisReceivedData / 1000.0;
        log.warn(""String_Node_Str"" + ""String_Node_Str"" + ((System.currentTimeMillis() - lastNonZeroActiveQueuesTime) / 1000.0) + ""String_Node_Str""+ noActiveQueuesTimeoutInSeconds+ ""String_Node_Str""+ ((System.currentTimeMillis() - lastTimeReceivedData) / 1000.0)+ ""String_Node_Str""+ noDataReceivedTimeoutInSeconds+ ""String_Node_Str""+ heritrixController.getQueuedUriCount());
        heritrixController.requestCrawlStop(""String_Node_Str"");
      }
      if (!heritrixController.crawlIsEnded()) {
        try {
synchronized (this) {
            wait(WAIT_PERIOD);
          }
        }
 catch (        InterruptedException e) {
          log.trace(""String_Node_Str"" + e.getMessage());
        }
      }
    }
  }
  finally {
    heritrixController.cleanup();
  }
}",0.8674062334918119
90250,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_main);
  mTutorial=new TutorialOverlayHelper(this,""String_Node_Str"").setBackgroundColor(R.color.popup_background).setFocusable(true).setTouchable(true).setOutsideTouchable(true).setContentView(R.layout.popup_view).show(this,500L);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_main);
  mTutorial=new TutorialOverlayHelper(this,""String_Node_Str"").setBackgroundColorResource(R.color.popup_background).setFocusable(true).setTouchable(true).setOutsideTouchable(true).setContentView(R.layout.popup_view).show(this,500L);
}",0.9892183288409704
90251,"/** 
 * Used to receive and process incoming JavaScript events
 */
void handleEvent(String event,String data){
  List<EventListener> listeners=mEventListenerMap.get(event);
  if (listeners != null) {
    for (    EventListener listener : listeners) {
      listener.onEvent(event,data);
    }
  }
}","/** 
 * Used to receive and process incoming JavaScript events
 */
void handleEvent(String event,String data){
  Set<EventListener> listeners=mEventListenerMap.get(event);
  if (listeners != null) {
    for (    EventListener listener : listeners) {
      listener.onEvent(event,data);
    }
  }
}",0.9915966386554622
90252,"/** 
 * Stop listening for the given event.
 * @param event The event to stop listening for.
 * @param listener The listener
 */
public void removeListener(String event,EventListener listener){
  List<EventListener> currentListener=mEventListenerMap.get(event);
  if (currentListener == null) {
    currentListener=new ArrayList<EventListener>();
  }
  currentListener.remove(listener);
  mEventListenerMap.put(event,currentListener);
}","/** 
 * Stop listening for the given event.
 * @param event The event to stop listening for.
 * @param listener The listener
 */
public void removeListener(String event,EventListener listener){
  Set<EventListener> currentListener=mEventListenerMap.get(event);
  if (currentListener == null) {
    currentListener=new HashSet<EventListener>();
  }
  currentListener.remove(listener);
  mEventListenerMap.put(event,currentListener);
}",0.9781357882623706
90253,"/** 
 * Register a listener for the given event.
 * @param event The event to listen for.
 * @param listener The listener
 */
public void addListener(String event,EventListener listener){
  List<EventListener> currentListeners=mEventListenerMap.get(event);
  if (currentListeners == null) {
    currentListeners=new ArrayList<EventListener>();
  }
  currentListeners.add(listener);
  mEventListenerMap.put(event,currentListeners);
}","/** 
 * Register a listener for the given event.
 * @param event The event to listen for.
 * @param listener The listener
 */
public void addListener(String event,EventListener listener){
  Set<EventListener> currentListeners=mEventListenerMap.get(event);
  if (currentListeners == null) {
    currentListeners=new HashSet<EventListener>();
  }
  currentListeners.add(listener);
  mEventListenerMap.put(event,currentListeners);
}",0.9779326364692218
90254,"@ExceptionHandler(Exception.class) public void handleException(Exception e,HttpServletResponse response,HttpServletRequest request) throws IOException {
  storeException(request,response,e);
  ResponseStatus responseStatus=AnnotationUtils.findAnnotation(e.getClass(),ResponseStatus.class);
  if (responseStatus != null) {
    HttpStatus httpStatus=responseStatus.value();
    logger.error(httpStatus.getReasonPhrase(),e);
    String message=e.getMessage();
    if (message == null || message.trim().isEmpty()) {
      message=responseStatus.reason();
    }
    response.sendError(httpStatus.value(),message);
  }
 else {
    logger.error(""String_Node_Str"",e);
    response.sendError(HttpStatus.INTERNAL_SERVER_ERROR.value(),e.getMessage());
  }
}","@ExceptionHandler(Exception.class) public void handleException(Exception e,HttpServletResponse response,HttpServletRequest request) throws IOException {
  storeException(request,response,e);
  ResponseStatus responseStatus=AnnotationUtils.findAnnotation(e.getClass(),ResponseStatus.class);
  if (responseStatus != null) {
    HttpStatus httpStatus=responseStatus.value();
    if (httpStatus.is5xxServerError()) {
      logger.error(httpStatus.getReasonPhrase(),e);
    }
 else     if (httpStatus != HttpStatus.NOT_FOUND) {
      logger.error(httpStatus.getReasonPhrase() + ""String_Node_Str"" + e.toString());
    }
    String message=e.getMessage();
    if (message == null || message.trim().isEmpty()) {
      message=responseStatus.reason();
    }
    response.sendError(httpStatus.value(),message);
  }
 else {
    logger.error(""String_Node_Str"",e);
    response.sendError(HttpStatus.INTERNAL_SERVER_ERROR.value(),e.getMessage());
  }
}",0.8859857482185273
90255,"private void doSearchImage(Context ctx,Bitmap image,Algorithm type) throws Exception {
  startSearch(ctx,image);
  do {
    optimize(type);
  }
 while (false == checkConvergence());
}","private void doSearchImage(Context ctx,Bitmap image,Algorithm type) throws Exception {
  startSearch(ctx,image);
  do {
    optimize(type);
  }
 while (false == checkConvergence(type));
}",0.9891891891891892
90256,"public void drawTestInfo(Canvas canvas){
  ShapeModel s=mModel.shapeModel;
  PathModel path=mModel.pathModel;
  if (test_PlotPatch) {
    Paint pt=new Paint();
    byte[] patches=cropPatches();
    int offsetX=-(SEARCH_WIN_W + mModel.patchModel.sampleWidth - 1) / 2;
    int offsetY=-(SEARCH_WIN_H + mModel.patchModel.sampleHeight - 1) / 2;
    for (int i=0; i < mModel.numPts; i++) {
      double centX=mCropPositions.get(i * 2);
      double centY=mCropPositions.get(i * 2 + 1);
      for (int j=0; j < SEARCH_WIN_H + mModel.patchModel.sampleHeight - 1; j++) {
        for (int k=0; k < (SEARCH_WIN_W + mModel.patchModel.sampleWidth - 1); k++) {
          int color=(patches[i * (SEARCH_WIN_W + mModel.patchModel.sampleWidth - 1) * (SEARCH_WIN_H + mModel.patchModel.sampleHeight - 1) + (SEARCH_WIN_W + mModel.patchModel.sampleWidth - 1) * j + k]) & 0xFF;
          double left=(centX + k + offsetX) / mScaleFactor;
          double top=(centY + j + offsetY) / mScaleFactor;
          double right=(centX + k + offsetX+ 1) / mScaleFactor;
          double bottom=(centY + j + offsetY+ 1) / mScaleFactor;
          pt.setARGB(0xff,color,color,color);
          canvas.drawRect((float)left,(float)top,(float)right,(float)bottom,pt);
        }
      }
    }
  }
 else   if (test_PlotResponse) {
    Paint pt=new Paint();
    float[] responses=mFilter.gerResponseImages();
    int offsetX=-(SEARCH_WIN_W - 1) / 2;
    int offsetY=-(SEARCH_WIN_H - 1) / 2;
    for (int i=27; i < 28; i++) {
      double centX=mCropPositions.get(i * 2);
      double centY=mCropPositions.get(i * 2 + 1);
      for (int j=0; j < SEARCH_WIN_H; j++) {
        for (int k=0; k < SEARCH_WIN_W; k++) {
          int color=(int)((255 * responses[i * SEARCH_WIN_W * SEARCH_WIN_H + j * SEARCH_WIN_W + k]));
          double left=(centX + k + offsetX) / mScaleFactor;
          double top=(centY + j + offsetY) / mScaleFactor;
          double right=(centX + k + offsetX+ 1) / mScaleFactor;
          double bottom=(centY + j + offsetY+ 1) / mScaleFactor;
          pt.setARGB(0xff,color,color,color);
          canvas.drawRect((float)left,(float)top,(float)right,(float)bottom,pt);
        }
      }
    }
  }
  if (test_PlotContour) {
    for (int i=0; i < path.paths.length; i++) {
      Paint pt=new Paint();
      pt.setStrokeWidth(2);
      if (test_PlotOriginal) {
        pt.setColor(0xFFFF0000);
        for (int j=1; j < path.paths[i].length; j++) {
          double startX=mOriginalPositions.get(path.paths[i][j - 1] * 2);
          double startY=mOriginalPositions.get(path.paths[i][j - 1] * 2 + 1);
          double endX=mOriginalPositions.get(path.paths[i][j] * 2);
          double endY=mOriginalPositions.get(path.paths[i][j] * 2 + 1);
          canvas.drawLine((float)(startX / mScaleFactor),(float)(startY / mScaleFactor),(float)(endX / mScaleFactor),(float)(endY / mScaleFactor),pt);
        }
      }
      pt.setColor(0xFF00FF00);
      for (int j=1; j < path.paths[i].length; j++) {
        double startX=mCurrentPositions.get(path.paths[i][j - 1] * 2);
        double startY=mCurrentPositions.get(path.paths[i][j - 1] * 2 + 1);
        double endX=mCurrentPositions.get(path.paths[i][j] * 2);
        double endY=mCurrentPositions.get(path.paths[i][j] * 2 + 1);
        canvas.drawLine((float)(startX / mScaleFactor),(float)(startY / mScaleFactor),(float)(endX / mScaleFactor),(float)(endY / mScaleFactor),pt);
      }
    }
  }
 else   if (test_PlotPts) {
    Paint pt=new Paint();
    if (test_PlotOriginal) {
      pt.setColor(0xFFFF0000);
      for (int i=0; i < mModel.numPts; i++) {
        double centX=mOriginalPositions.get(i * 2);
        double centY=mOriginalPositions.get(i * 2 + 1);
        canvas.drawText(""String_Node_Str"" + i,(float)(centX / mScaleFactor),(float)(centY / mScaleFactor),pt);
      }
    }
    pt.setColor(0xFF00FF00);
    for (int i=0; i < mModel.numPts; i++) {
      double centX=mCurrentPositions.get(i * 2);
      double centY=mCurrentPositions.get(i * 2 + 1);
      canvas.drawText(""String_Node_Str"" + i,(float)(centX / mScaleFactor),(float)(centY / mScaleFactor),pt);
    }
  }
  if (test_PlotParams) {
    Paint pt=new Paint();
    pt.setColor(0xFF00FF00);
    pt.setTextSize(30);
    String text=new String();
    for (int i=0; i < mModel.shapeModel.mEigenConstraints.length(); i++) {
      int value=(int)((mCurrentParams.get(i + 4) * 50) / mModel.shapeModel.mEigenConstraints.get(i)) + 50;
      canvas.drawText(Parameter.fromInteger(i).desciption() + ""String_Node_Str"" + value+ ""String_Node_Str"",0,(i + 1) * (30 + 5),pt);
    }
  }
}","public void drawTestInfo(Canvas canvas,float scale,float translateX,float translateY){
  FuncTracer.startFunc();
  ShapeModel s=mModel.shapeModel;
  PathModel path=mModel.pathModel;
  if (test_PlotPatch) {
    Paint pt=new Paint();
    byte[] patches=cropPatches();
    int offsetX=-(SEARCH_WIN_W + mModel.patchModel.sampleWidth - 1) / 2;
    int offsetY=-(SEARCH_WIN_H + mModel.patchModel.sampleHeight - 1) / 2;
    for (int i=0; i < mModel.numPts; i++) {
      double centX=mCropPositions.get(i * 2);
      double centY=mCropPositions.get(i * 2 + 1);
      for (int j=0; j < SEARCH_WIN_H + mModel.patchModel.sampleHeight - 1; j++) {
        for (int k=0; k < (SEARCH_WIN_W + mModel.patchModel.sampleWidth - 1); k++) {
          int color=(patches[i * (SEARCH_WIN_W + mModel.patchModel.sampleWidth - 1) * (SEARCH_WIN_H + mModel.patchModel.sampleHeight - 1) + (SEARCH_WIN_W + mModel.patchModel.sampleWidth - 1) * j + k]) & 0xFF;
          double left=(centX + k + offsetX) / mScaleFactor;
          double top=(centY + j + offsetY) / mScaleFactor;
          double right=(centX + k + offsetX+ 1) / mScaleFactor;
          double bottom=(centY + j + offsetY+ 1) / mScaleFactor;
          left=left * scale + translateX;
          top=top * scale + translateY;
          right=right * scale + translateX;
          bottom=bottom * scale + translateY;
          pt.setARGB(0xFF,color,color,color);
          canvas.drawRect((float)left,(float)top,(float)right,(float)bottom,pt);
        }
      }
    }
  }
 else   if (test_PlotResponse) {
    Paint pt=new Paint();
    float[] responses=mFilter.gerResponseImages();
    int offsetX=-(SEARCH_WIN_W - 1) / 2;
    int offsetY=-(SEARCH_WIN_H - 1) / 2;
    for (int i=27; i < 28; i++) {
      double centX=mCropPositions.get(i * 2);
      double centY=mCropPositions.get(i * 2 + 1);
      for (int j=0; j < SEARCH_WIN_H; j++) {
        for (int k=0; k < SEARCH_WIN_W; k++) {
          int color=(int)((255 * responses[i * SEARCH_WIN_W * SEARCH_WIN_H + j * SEARCH_WIN_W + k]));
          double left=(centX + k + offsetX) / mScaleFactor;
          double top=(centY + j + offsetY) / mScaleFactor;
          double right=(centX + k + offsetX+ 1) / mScaleFactor;
          double bottom=(centY + j + offsetY+ 1) / mScaleFactor;
          left=left * scale + translateX;
          top=top * scale + translateY;
          right=right * scale + translateX;
          bottom=bottom * scale + translateY;
          pt.setARGB(0xff,color,color,color);
          canvas.drawRect((float)left,(float)top,(float)right,(float)bottom,pt);
        }
      }
    }
  }
  if (test_PlotContour) {
    for (int i=0; i < path.paths.length; i++) {
      Paint pt=new Paint();
      pt.setStrokeWidth(2);
      if (test_PlotOriginal) {
        pt.setColor(0xFFFF0000);
        for (int j=1; j < path.paths[i].length; j++) {
          double startX=mOriginalPositions.get(path.paths[i][j - 1] * 2) / mScaleFactor;
          double startY=mOriginalPositions.get(path.paths[i][j - 1] * 2 + 1) / mScaleFactor;
          double endX=mOriginalPositions.get(path.paths[i][j] * 2) / mScaleFactor;
          double endY=mOriginalPositions.get(path.paths[i][j] * 2 + 1) / mScaleFactor;
          startX=startX * scale + translateX;
          endX=endX * scale + translateX;
          startY=startY * scale + translateY;
          endY=endY * scale + translateY;
          canvas.drawLine((float)startX,(float)startY,(float)endX,(float)endY,pt);
        }
      }
      pt.setColor(0xFF00FF00);
      for (int j=1; j < path.paths[i].length; j++) {
        double startX=mCurrentPositions.get(path.paths[i][j - 1] * 2) / mScaleFactor;
        double startY=mCurrentPositions.get(path.paths[i][j - 1] * 2 + 1) / mScaleFactor;
        double endX=mCurrentPositions.get(path.paths[i][j] * 2) / mScaleFactor;
        double endY=mCurrentPositions.get(path.paths[i][j] * 2 + 1) / mScaleFactor;
        startX=startX * scale + translateX;
        endX=endX * scale + translateX;
        startY=startY * scale + translateY;
        endY=endY * scale + translateY;
        canvas.drawLine((float)startX,(float)startY,(float)endX,(float)endY,pt);
      }
    }
  }
 else   if (test_PlotPts) {
    Paint pt=new Paint();
    if (test_PlotOriginal) {
      pt.setColor(0xFFFF0000);
      for (int i=0; i < mModel.numPts; i++) {
        double centX=mOriginalPositions.get(i * 2) / mScaleFactor;
        double centY=mOriginalPositions.get(i * 2 + 1) / mScaleFactor;
        centX=centX * scale + translateX;
        centY=centY * scale + translateY;
        canvas.drawText(""String_Node_Str"" + i,(float)centX,(float)centY,pt);
      }
    }
    pt.setColor(0xFF00FF00);
    for (int i=0; i < mModel.numPts; i++) {
      double centX=mCurrentPositions.get(i * 2) / mScaleFactor;
      double centY=mCurrentPositions.get(i * 2 + 1) / mScaleFactor;
      centX=centX * scale + translateX;
      centY=centY * scale + translateY;
      canvas.drawText(""String_Node_Str"" + i,(float)centX,(float)centY,pt);
    }
  }
  if (test_PlotParams) {
    Paint pt=new Paint();
    pt.setColor(0xFF00FF00);
    pt.setTextSize(30);
    String text=new String();
    for (int i=0; i < mModel.shapeModel.mEigenConstraints.length(); i++) {
      int value=(int)((mCurrentParams.get(i + 4) * 50) / mModel.shapeModel.mEigenConstraints.get(i)) + 50;
      canvas.drawText(Parameter.fromInteger(i).desciption() + ""String_Node_Str"" + value+ ""String_Node_Str"",0,(i + 1) * (30 + 5),pt);
    }
  }
  FuncTracer.endFunc();
}",0.8671704116126466
90257,"private boolean checkConvergence(){
  if (mOptCount > OPTIMIZATION_LIMIT) {
    return true;
  }
  if (mParamHist.size() >= 3) {
    QMatrix currentParam=mParamHist.get(mParamHist.size() - 1);
    QMatrix lastParam=mParamHist.get(mParamHist.size() - 2);
    QMatrix lastlastParam=mParamHist.get(mParamHist.size() - 3);
    float currDiff=currentParam.minus(lastParam).innerProduct();
    float lastDiff=currentParam.minus(lastlastParam).innerProduct();
    Log.v(TAG,""String_Node_Str"" + currDiff + ""String_Node_Str""+ lastDiff);
    if (currDiff > lastDiff || currDiff < CONVERGENCE_THRESHOLD) {
      return true;
    }
  }
  return false;
}","private boolean checkConvergence(Algorithm type){
  if (Algorithm.QUICK == type && mOptCount >= QUICK_OPTIMIZATION_LIMIT) {
    return true;
  }
 else   if (mOptCount >= OPTIMIZATION_LIMIT) {
    return true;
  }
  if (mParamHist.size() >= 3) {
    QMatrix currentParam=mParamHist.get(mParamHist.size() - 1);
    QMatrix lastParam=mParamHist.get(mParamHist.size() - 2);
    QMatrix lastlastParam=mParamHist.get(mParamHist.size() - 3);
    float currDiff=currentParam.minus(lastParam).innerProduct();
    float lastDiff=currentParam.minus(lastlastParam).innerProduct();
    Log.v(TAG,""String_Node_Str"" + currDiff + ""String_Node_Str""+ lastDiff);
    if (currDiff > lastDiff || currDiff < CONVERGENCE_THRESHOLD) {
      return true;
    }
  }
  return false;
}",0.9170243204577968
90258,"@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_camera);
}","@Override protected void onCreate(Bundle savedInstanceState){
  super.onCreate(savedInstanceState);
  setContentView(R.layout.activity_camera);
  mCameraID=1;
  mCamera=getCameraInstance();
  mCamera.setDisplayOrientation(90);
  mPreview=new CameraPreview(this,mCamera,this,this);
  FrameLayout preview=(FrameLayout)findViewById(R.id.CameraPreview);
  preview.addView(mPreview);
  getWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);
}",0.4857621440536013
90259,"public void init(Context ctx,FaceModel model){
  mModel=model;
  mFilter=new Filter2D(ctx,mModel.patchModel.weightsList,mModel.patchModel.biasList,null,mModel.numPts,mModel.patchModel.sampleWidth,mModel.patchModel.sampleHeight,(mModel.patchModel.sampleWidth + SEARCH_WIN_W - 1),(mModel.patchModel.sampleHeight + SEARCH_WIN_H - 1));
  QMatrix.init(ctx);
}","public void init(Context ctx,FaceModel model){
  QMatrix.init(ctx);
  mModel=model;
  mFilter=new Filter2D(ctx,mModel.patchModel.weightsList,mModel.patchModel.biasList,null,mModel.numPts,mModel.patchModel.sampleWidth,mModel.patchModel.sampleHeight,(mModel.patchModel.sampleWidth + SEARCH_WIN_W - 1),(mModel.patchModel.sampleHeight + SEARCH_WIN_H - 1));
  mParamHist=new ArrayList<QMatrix>();
}",0.923694779116466
90260,"private QMatrix createInvCovariance(QMatrix meanPos,float[] responseImg){
  QMatrix result=new QMatrix(mModel.numPts * 2,mModel.numPts * 2);
  QMatrix currPtsConv=new QMatrix(2,2);
  float[] zeros=new float[]{0,0,0,0};
  for (int i=0; i < mModel.numPts; i++) {
    float meanX=meanPos.get(i * 2) - mCropPositions.get(i * 2) + (SEARCH_WIN_W - 1);
    float meanY=meanPos.get(i * 2 + 1) - mCropPositions.get(i * 2 + 1) + (SEARCH_WIN_H - 1);
    currPtsConv.set(0,zeros);
    int respImgOffset=i * SEARCH_WIN_W * SEARCH_WIN_H;
    for (int j=0; j < SEARCH_WIN_W; j++) {
      for (int k=0; k < SEARCH_WIN_H; k++) {
        float a=responseImg[respImgOffset + k * SEARCH_WIN_H + j];
        float dx=j - meanX;
        float dy=k - meanY;
        currPtsConv.set(0,currPtsConv.get(0) + a * dx * dx);
        currPtsConv.set(1,currPtsConv.get(1) + a * dx * dy);
        currPtsConv.set(3,currPtsConv.get(3) + a * dy * dy);
      }
    }
    currPtsConv.set(2,currPtsConv.get(1));
    QMatrix invConvPts=currPtsConv.invert();
    result.set(i * 2,i * 2,invConvPts.get(0));
    result.set(i * 2 + 1,i * 2,invConvPts.get(1));
    result.set(i * 2,i * 2 + 1,invConvPts.get(2));
    result.set(i * 2 + 1,i * 2 + 1,invConvPts.get(3));
  }
  return result;
}","private QMatrix createInvCovariance(QMatrix meanPos,float[] responseImg){
  QMatrix result=new QMatrix(mModel.numPts * 2,mModel.numPts * 2);
  QMatrix currPtsConv=new QMatrix(2,2);
  float[] zeros=new float[]{0,0,0,0};
  for (int i=0; i < mModel.numPts; i++) {
    float meanX=meanPos.get(i * 2) - mCropPositions.get(i * 2) + (SEARCH_WIN_W - 1);
    float meanY=meanPos.get(i * 2 + 1) - mCropPositions.get(i * 2 + 1) + (SEARCH_WIN_H - 1);
    currPtsConv.set(0,zeros);
    int respImgOffset=i * SEARCH_WIN_W * SEARCH_WIN_H;
    for (int j=0; j < SEARCH_WIN_W; j++) {
      for (int k=0; k < SEARCH_WIN_H; k++) {
        float a=responseImg[respImgOffset + k * SEARCH_WIN_H + j];
        float dx=j - meanX;
        float dy=k - meanY;
        currPtsConv.set(0,currPtsConv.get(0) + a * dx * dx);
        currPtsConv.set(1,currPtsConv.get(1) + a * dx * dy);
        currPtsConv.set(3,currPtsConv.get(3) + a * dy * dy);
      }
    }
    currPtsConv.set(2,currPtsConv.get(1));
    QMatrix invConvPts=currPtsConv.invert();
    if (Float.isNaN(invConvPts.get(0)) || Float.isNaN(invConvPts.get(1)) || Float.isNaN(invConvPts.get(2))|| Float.isNaN(invConvPts.get(3))) {
      invConvPts.set(0,zeros);
    }
    result.set(i * 2,i * 2,invConvPts.get(0));
    result.set(i * 2 + 1,i * 2,invConvPts.get(1));
    result.set(i * 2,i * 2 + 1,invConvPts.get(2));
    result.set(i * 2 + 1,i * 2 + 1,invConvPts.get(3));
  }
  return result;
}",0.8285928143712575
90261,"private void updateCurrent(QMatrix newPositions){
  FuncTracer.startFunc();
  QMatrix jacob=createJacobian(mCurrentParams);
  QMatrix transJacob=jacob.transpose();
  QMatrix deltaParams=transJacob.mult(jacob).invert().mult(transJacob).mult(newPositions.minusSelf(mCurrentPositions));
  mCurrentParams=regularizeParams(deltaParams.plusSelf(mCurrentParams));
  mCurrentPositions=getShape(mCurrentParams);
  FuncTracer.endFunc();
}","private void updateCurrent(QMatrix newPositions){
  FuncTracer.startFunc();
  QMatrix jacob=createJacobian(mCurrentParams);
  QMatrix transJacob=jacob.transpose();
  QMatrix deltaParams=transJacob.mult(jacob).invert().mult(transJacob).mult(newPositions.minusSelf(mCurrentPositions));
  Log.i(TAG,""String_Node_Str"" + deltaParams.innerProduct());
  mCurrentParams=regularizeParams(deltaParams.plusSelf(mCurrentParams));
  mCurrentPositions=getShape(mCurrentParams);
  FuncTracer.endFunc();
}",0.9334787350054524
90262,"public void optimize(Algorithm type) throws Exception {
  FuncTracer.startFunc();
  mFilter.setPatches(cropPatches());
  if (Algorithm.ASM == type) {
    mFilter.process(ResponseType.RAW);
    searchPeak(mFilter.gerResponseImages());
  }
 else   if (Algorithm.CQF == type) {
    mFilter.process(ResponseType.REG_NORMALIZED);
    searchConvQuadFit(mFilter.gerResponseImages());
  }
 else   if (Algorithm.KDE == type) {
    mFilter.process(ResponseType.REGULARIZED);
    searchMeanShift(mFilter.gerResponseImages());
  }
 else {
    throw new Exception(""String_Node_Str"");
  }
  FuncTracer.endFunc();
}","private void optimize(Algorithm type) throws Exception {
  FuncTracer.startFunc();
  mFilter.setPatches(cropPatches());
switch (type) {
case CQF:
    mFilter.process(ResponseType.REG_NORMALIZED);
  searchConvQuadFit(mFilter.gerResponseImages());
break;
case KDE:
mFilter.process(ResponseType.REGULARIZED);
searchMeanShift(mFilter.gerResponseImages());
break;
case ASM:
default :
mFilter.process(ResponseType.RAW);
searchPeak(mFilter.gerResponseImages());
break;
}
mParamHist.add(new QMatrix(mCurrentParams,true));
while (mParamHist.size() > PARAM_HIST_SIZE) {
mParamHist.remove(0);
}
mOptCount++;
FuncTracer.endFunc();
}",0.5754098360655737
90263,"private byte[] cropPatches(){
  FuncTracer.startFunc();
  QMatrix currShape=getCurrentShape();
  int filterW=mModel.patchModel.sampleWidth;
  int filterH=mModel.patchModel.sampleHeight;
  int patchW=filterW + SEARCH_WIN_W - 1;
  int patchH=filterH + SEARCH_WIN_H - 1;
  int shiftW=-(patchW - 1) / 2;
  int shiftH=-(patchH - 1) / 2;
  byte[] ret=new byte[mModel.numPts * patchW * patchH];
  mCropPositions=currShape;
  for (int i=0; i < mModel.numPts; i++) {
    int centerX=(int)(currShape.get(i * 2));
    int centerY=(int)(currShape.get(i * 2 + 1));
    for (int j=0; j < patchH; j++) {
      for (int k=0; k < patchW; k++) {
        int posX=centerX + shiftW + k;
        int posY=centerY + shiftH + j;
        if (posX < 0 || posY < 0 || posX > mImageW || posY > mImageH) {
          ret[i * patchW * patchH + j * patchW + k]=0;
        }
 else {
          ret[i * patchW * patchH + j * patchW + k]=(mImgGrayScaled[(int)(posY * mImageW) + posX]);
        }
      }
    }
  }
  FuncTracer.endFunc();
  return ret;
}","private byte[] cropPatches(){
  FuncTracer.startFunc();
  QMatrix currShape=getCurrentShape();
  int filterW=mModel.patchModel.sampleWidth;
  int filterH=mModel.patchModel.sampleHeight;
  int patchW=filterW + SEARCH_WIN_W - 1;
  int patchH=filterH + SEARCH_WIN_H - 1;
  int shiftW=-(patchW - 1) / 2;
  int shiftH=-(patchH - 1) / 2;
  byte[] ret=new byte[mModel.numPts * patchW * patchH];
  mCropPositions=currShape;
  for (int i=0; i < mModel.numPts; i++) {
    int centerX=(int)(currShape.get(i * 2));
    int centerY=(int)(currShape.get(i * 2 + 1));
    for (int j=0; j < patchH; j++) {
      for (int k=0; k < patchW; k++) {
        int posX=centerX + shiftW + k;
        int posY=centerY + shiftH + j;
        if (posX < 0 || posY < 0 || posX > mImageW || posY > mImageH) {
          ret[i * patchW * patchH + j * patchW + k]=100;
        }
 else {
          ret[i * patchW * patchH + j * patchW + k]=(mImgGrayScaled[(int)(posY * mImageW) + posX]);
        }
      }
    }
  }
  FuncTracer.endFunc();
  return ret;
}",0.9990186457311088
90264,"private void updateCurrentCQF(QMatrix newPositions,float[] responseImg){
  FuncTracer.startFunc();
  QMatrix jacob=createJacobian(mCurrentParams);
  QMatrix transJacob=jacob.transpose();
  QMatrix invCovariance=createInvCovariance(newPositions,responseImg);
  invCovariance.printOut();
  QMatrix deltaParams=transJacob.mult(invCovariance).mult(jacob).invert().mult(transJacob).mult(invCovariance).mult(newPositions.minusSelf(mCurrentPositions));
  mCurrentParams=regularizeParams(deltaParams.plusSelf(mCurrentParams));
  mCurrentPositions=getShape(mCurrentParams);
  FuncTracer.endFunc();
}","private void updateCurrentCQF(QMatrix newPositions,float[] responseImg){
  FuncTracer.startFunc();
  QMatrix jacob=createJacobian(mCurrentParams);
  QMatrix transJacob=jacob.transpose();
  QMatrix invCovariance=createInvCovariance(newPositions,responseImg);
  newPositions.printOut();
  invCovariance.printOut();
  QMatrix deltaParams=transJacob.mult(invCovariance).mult(jacob).invert().mult(transJacob).mult(invCovariance).mult(newPositions.minusSelf(mCurrentPositions));
  mCurrentParams=regularizeParams(deltaParams.plusSelf(mCurrentParams));
  mCurrentPositions=getShape(mCurrentParams);
  FuncTracer.endFunc();
}",0.9776304888152444
90265,"public void searchInImage(Context ctx,Bitmap image,float leftX,float leftY,float rightX,float rightY) throws Exception {
  if (null == mModel) {
    throw new Exception(""String_Node_Str"");
  }
  int leftEyeIndex=mModel.pathModel.paths[mModel.pathModel.paths.length - 2][0];
  int rightEyeIndex=mModel.pathModel.paths[mModel.pathModel.paths.length - 1][0];
  double meanLeftX=mModel.shapeModel.mMeanShape.get(leftEyeIndex * 2);
  double meanLeftY=mModel.shapeModel.mMeanShape.get(leftEyeIndex * 2 + 1);
  double meanRightX=mModel.shapeModel.mMeanShape.get(rightEyeIndex * 2);
  double meanRightY=mModel.shapeModel.mMeanShape.get(rightEyeIndex * 2 + 1);
  double meanAngle=Math.atan((meanRightY - meanLeftY) / (meanRightX - meanLeftX));
  double currAngle=Math.atan((rightY - leftY) / (rightX - leftX));
  double diffAngle=currAngle - meanAngle;
  double meanDist=Math.hypot(meanRightX - meanLeftX,meanRightY - meanLeftY);
  double currDist=Math.hypot(rightX - leftX,rightY - leftY);
  double scale=meanDist / currDist;
  mScaleFactor=scale;
  Bitmap imgProcess=Bitmap.createScaledBitmap(image,(int)(image.getWidth() * scale),(int)(image.getHeight() * scale),true);
  leftX*=scale;
  leftY*=scale;
  rightX*=scale;
  rightY*=scale;
  mCurrentParams=new QMatrix(mModel.numEVectors + 4,1);
  mCurrentParams.set(0,(float)Math.cos(diffAngle));
  mCurrentParams.set(1,(float)Math.sin(diffAngle));
  mCurrentParams.set(2,(float)((rightX + leftX) / 2 - (meanRightX + meanLeftX) / 2));
  mCurrentParams.set(3,(float)((rightY + leftY) / 2 - (meanRightY + meanLeftY) / 2));
  mImageW=imgProcess.getWidth();
  mImageH=imgProcess.getHeight();
  RenderScript rs=RenderScript.create(ctx);
  ScriptC_im2float script=new ScriptC_im2float(rs);
  Allocation inAlloc=Allocation.createFromBitmap(rs,imgProcess);
  Type.Builder tb=new Type.Builder(rs,Element.U8(rs));
  tb.setX(mImageW).setY(mImageH);
  mImgGrayScaled=new byte[mImageW * mImageH];
  Allocation outAlloc=Allocation.createTyped(rs,tb.create());
  script.forEach_root(inAlloc,outAlloc);
  outAlloc.copyTo(mImgGrayScaled);
  mCurrentPositions=getCurrentShape();
  mOriginalPositions=new QMatrix(mCurrentPositions,true);
}","public void searchInImage(Context ctx,Bitmap image,Algorithm type) throws Exception {
  FuncTracer.startFunc();
  startSearch(ctx,image);
  do {
    optimize(type);
  }
 while (false == checkConvergence());
  FuncTracer.endFunc();
}",0.0484747179272879
90266,"public float[] gerResponseImages(){
  return mResponse;
}","public float[] gerResponseImages(){
  for (int i=0; i < mResponse.length; i++) {
    if (Float.isNaN(mResponse[i])) {
      mResponse[i]=0;
    }
  }
  return mResponse;
}",0.5
90267,"@Override protected void onActivityResult(int requestCode,int resultCode,Intent data){
  if (GALLERY_INTENT_ID == requestCode) {
    try {
      currPic=Media.getBitmap(getContentResolver(),data.getData());
      if (currPic.getWidth() > 1080) {
        currPic=Bitmap.createScaledBitmap(currPic,1080,1920,false);
      }
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
    imgFrame.setImageBitmap(currPic);
    try {
      FuncTracer.startProc(""String_Node_Str"");
      if (null == proc) {
        proc=new FaceAlignProc();
        proc.init(appCntx,model);
      }
      proc.searchInImage(appCntx,currPic);
      for (int t=0; t < 5; t++) {
        proc.optimize(Algorithm.CQF);
      }
      FuncTracer.endProc(""String_Node_Str"");
      imgFrame.addPlot(proc);
    }
 catch (    Exception e) {
      FuncTracer.procException(e);
      e.printStackTrace();
    }
  }
}","@Override protected void onActivityResult(int requestCode,int resultCode,Intent data){
  if (GALLERY_INTENT_ID == requestCode) {
    try {
      currPic=Media.getBitmap(getContentResolver(),data.getData());
      if (currPic.getWidth() > 1080) {
        currPic=Bitmap.createScaledBitmap(currPic,1080,1920,false);
      }
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
    imgFrame.setImageBitmap(currPic);
    try {
      FuncTracer.startProc(""String_Node_Str"");
      if (null == proc) {
        proc=new FaceAlignProc();
        proc.init(appCntx,model);
      }
      proc.searchInImage(appCntx,currPic,Algorithm.CQF);
      FuncTracer.endProc(""String_Node_Str"");
      imgFrame.addPlot(proc);
    }
 catch (    Exception e) {
      FuncTracer.procException(e);
      e.printStackTrace();
    }
  }
}",0.9602803738317756
90268,"public void init(Context ctx,FaceModel model){
  mModel=model;
  mCurrentParams=new Mat(mModel.numEVectors + 4,1,CvType.CV_32F,new Scalar(0));
  mCurrentParams.put(0,0,1.0);
  mFilter=new Filter2D(ctx,mModel.patchModel.weightsList,mModel.patchModel.biasList,null,mModel.numPts,mModel.patchModel.sampleWidth,mModel.patchModel.sampleHeight,(mModel.patchModel.sampleWidth + SEARCH_WIN_W - 1),(mModel.patchModel.sampleHeight + SEARCH_WIN_H - 1));
}","public void init(Context ctx,FaceModel model){
  mModel=model;
  mFilter=new Filter2D(ctx,mModel.patchModel.weightsList,mModel.patchModel.biasList,null,mModel.numPts,mModel.patchModel.sampleWidth,mModel.patchModel.sampleHeight,(mModel.patchModel.sampleWidth + SEARCH_WIN_W - 1),(mModel.patchModel.sampleHeight + SEARCH_WIN_H - 1));
}",0.8571428571428571
90269,"public void searchInImage(Context ctx,Bitmap image,float leftX,float leftY,float rightX,int rightY) throws Exception {
  if (null == mModel) {
    throw new Exception(""String_Node_Str"");
  }
  int leftEyeIndex=mModel.pathModel.paths[mModel.pathModel.paths.length - 2][0];
  int rightEyeIndex=mModel.pathModel.paths[mModel.pathModel.paths.length - 1][0];
  float meanLeftX=(float)((mModel.shapeModel.cvData.meanShape.get(leftEyeIndex * 2,0))[0]);
  float meanLeftY=(float)((mModel.shapeModel.cvData.meanShape.get(leftEyeIndex * 2 + 1,0))[0]);
  float meanRightX=(float)((mModel.shapeModel.cvData.meanShape.get(rightEyeIndex * 2,0))[0]);
  float meanRightY=(float)((mModel.shapeModel.cvData.meanShape.get(rightEyeIndex * 2 + 1,0))[0]);
  float meanAngle=(float)(Math.atan((meanRightY - meanLeftY) / (meanRightX - meanLeftX)));
  float currAngle=(float)(Math.atan((rightY - leftY) / (rightX - leftX)));
  float diffAngle=currAngle - meanAngle;
  float meanDist=(float)(Math.hypot(meanRightX - meanLeftX,meanRightY - meanLeftY));
  float currDist=(float)(Math.hypot(rightX - leftX,rightY - leftY));
  float scale=meanDist / currDist;
  mScaleFactor=scale;
  Bitmap imgProcess=Bitmap.createScaledBitmap(image,(int)(image.getWidth() * scale),(int)(image.getHeight() * scale),true);
  leftX*=scale;
  leftY*=scale;
  rightX*=scale;
  rightY*=scale;
  mCurrentParams.put(0,0,Math.cos(diffAngle));
  mCurrentParams.put(1,0,Math.sin(diffAngle));
  mCurrentParams.put(2,0,(rightX + leftX) / 2 - (meanRightX + meanLeftX) / 2);
  mCurrentParams.put(3,0,(rightY + leftY) / 2 - (meanRightY + meanLeftY) / 2);
  mImageW=imgProcess.getWidth();
  mImageH=imgProcess.getHeight();
  RenderScript rs=RenderScript.create(ctx);
  ScriptC_im2float script=new ScriptC_im2float(rs);
  Allocation inAlloc=Allocation.createFromBitmap(rs,imgProcess);
  Type.Builder tb=new Type.Builder(rs,Element.U8(rs));
  tb.setX(mImageW).setY(mImageH);
  mImgGrayScaled=new byte[mImageW * mImageH];
  Allocation outAlloc=Allocation.createTyped(rs,tb.create());
  script.forEach_root(inAlloc,outAlloc);
  outAlloc.copyTo(mImgGrayScaled);
  mCurrentPositions=getCurrentShape();
  mOriginalPositions=mCurrentPositions.clone();
}","public void searchInImage(Context ctx,Bitmap image,float leftX,float leftY,float rightX,float rightY) throws Exception {
  if (null == mModel) {
    throw new Exception(""String_Node_Str"");
  }
  int leftEyeIndex=mModel.pathModel.paths[mModel.pathModel.paths.length - 2][0];
  int rightEyeIndex=mModel.pathModel.paths[mModel.pathModel.paths.length - 1][0];
  float meanLeftX=(float)((mModel.shapeModel.cvData.meanShape.get(leftEyeIndex * 2,0))[0]);
  float meanLeftY=(float)((mModel.shapeModel.cvData.meanShape.get(leftEyeIndex * 2 + 1,0))[0]);
  float meanRightX=(float)((mModel.shapeModel.cvData.meanShape.get(rightEyeIndex * 2,0))[0]);
  float meanRightY=(float)((mModel.shapeModel.cvData.meanShape.get(rightEyeIndex * 2 + 1,0))[0]);
  float meanAngle=(float)(Math.atan((meanRightY - meanLeftY) / (meanRightX - meanLeftX)));
  float currAngle=(float)(Math.atan((rightY - leftY) / (rightX - leftX)));
  float diffAngle=currAngle - meanAngle;
  float meanDist=(float)(Math.hypot(meanRightX - meanLeftX,meanRightY - meanLeftY));
  float currDist=(float)(Math.hypot(rightX - leftX,rightY - leftY));
  float scale=meanDist / currDist;
  mScaleFactor=scale;
  Bitmap imgProcess=Bitmap.createScaledBitmap(image,(int)(image.getWidth() * scale),(int)(image.getHeight() * scale),true);
  leftX*=scale;
  leftY*=scale;
  rightX*=scale;
  rightY*=scale;
  mCurrentParams=new Mat(mModel.numEVectors + 4,1,CvType.CV_32F,new Scalar(0));
  mCurrentParams.put(0,0,Math.cos(diffAngle));
  mCurrentParams.put(1,0,Math.sin(diffAngle));
  mCurrentParams.put(2,0,(rightX + leftX) / 2 - (meanRightX + meanLeftX) / 2);
  mCurrentParams.put(3,0,(rightY + leftY) / 2 - (meanRightY + meanLeftY) / 2);
  mImageW=imgProcess.getWidth();
  mImageH=imgProcess.getHeight();
  RenderScript rs=RenderScript.create(ctx);
  ScriptC_im2float script=new ScriptC_im2float(rs);
  Allocation inAlloc=Allocation.createFromBitmap(rs,imgProcess);
  Type.Builder tb=new Type.Builder(rs,Element.U8(rs));
  tb.setX(mImageW).setY(mImageH);
  mImgGrayScaled=new byte[mImageW * mImageH];
  Allocation outAlloc=Allocation.createTyped(rs,tb.create());
  script.forEach_root(inAlloc,outAlloc);
  outAlloc.copyTo(mImgGrayScaled);
  mCurrentPositions=getCurrentShape();
  mOriginalPositions=mCurrentPositions.clone();
}",0.9806654676258992
90270,"@Override protected void onActivityResult(int requestCode,int resultCode,Intent data){
  if (GALLERY_INTENT_ID == requestCode) {
    try {
      currPic=Media.getBitmap(getContentResolver(),data.getData());
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
    imgFrame.setImageBitmap(currPic);
    if (null == proc) {
      try {
        proc=new FaceAlignProc();
        proc.init(appCntx,model);
        float[] eyes=makeInitialGuess(currPic);
        if (true) {
          proc.searchInImage(appCntx,currPic,(int)eyes[0],(int)eyes[1],(int)eyes[2],(int)eyes[3]);
        }
 else {
          String temp=data.getData().toString();
          if (temp.contains(""String_Node_Str"")) {
            proc.searchInImage(appCntx,currPic,418,952,611,945);
          }
 else           if (temp.contains(""String_Node_Str"")) {
            proc.searchInImage(appCntx,currPic,388,946,636,956);
          }
 else           if (temp.contains(""String_Node_Str"")) {
            proc.searchInImage(appCntx,currPic,365,840,689,844);
          }
 else           if (temp.contains(""String_Node_Str"")) {
            proc.searchInImage(appCntx,currPic,444,1076,672,1060);
          }
 else           if (temp.contains(""String_Node_Str"")) {
            proc.searchInImage(appCntx,currPic,438,968,744,948);
          }
 else           if (temp.contains(""String_Node_Str"")) {
            proc.searchInImage(appCntx,currPic,1016,1152,1288,1136);
          }
 else           if (temp.contains(""String_Node_Str"")) {
            proc.searchInImage(appCntx,currPic,902,908,1191,946);
          }
 else {
            proc.searchInImage(appCntx,currPic,418,952,611,945);
          }
        }
        for (int t=0; t < 3; t++) {
          proc.optimize(Algorithm.ASM);
        }
        imgFrame.addPlot(proc);
      }
 catch (      Exception e) {
        e.printStackTrace();
      }
    }
  }
}","@Override protected void onActivityResult(int requestCode,int resultCode,Intent data){
  if (GALLERY_INTENT_ID == requestCode) {
    try {
      currPic=Media.getBitmap(getContentResolver(),data.getData());
      if (currPic.getWidth() > 1080) {
        currPic=Bitmap.createScaledBitmap(currPic,1080,1920,false);
      }
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
    imgFrame.setImageBitmap(currPic);
    try {
      if (null == proc) {
        proc=new FaceAlignProc();
        proc.init(appCntx,model);
      }
      proc.searchInImage(appCntx,currPic);
      for (int t=0; t < 3; t++) {
        proc.optimize(Algorithm.ASM);
      }
      imgFrame.addPlot(proc);
    }
 catch (    Exception e) {
      e.printStackTrace();
    }
  }
}",0.3468383188186293
90271,"synchronized void onSizeChanged(){
  this.destroy();
  this.mapViewCanvas=new Canvas();
  this.width=this.mapView.getWidth();
  this.height=this.mapView.getHeight();
  this.mapViewBitmap1=Bitmap.createBitmap(this.width,this.height,Bitmap.Config.RGB_565);
  this.mapViewBitmap2=Bitmap.createBitmap(this.width,this.height,Bitmap.Config.RGB_565);
  clear();
  this.mapViewCanvas.setBitmap(this.mapViewBitmap1);
}","synchronized void onSizeChanged(){
  this.width=this.mapView.getWidth();
  this.height=this.mapView.getHeight();
  this.mapViewBitmap1=Bitmap.createBitmap(this.width,this.height,Bitmap.Config.RGB_565);
  this.mapViewBitmap2=Bitmap.createBitmap(this.width,this.height,Bitmap.Config.RGB_565);
  clear();
  this.mapViewCanvas.setBitmap(this.mapViewBitmap1);
}",0.930718954248366
90272,"synchronized void destroy(){
  if (this.mapViewBitmap1 != null) {
    this.mapViewBitmap1.recycle();
  }
  if (this.mapViewBitmap2 != null) {
    this.mapViewBitmap2.recycle();
  }
  this.mapViewCanvas=null;
}","synchronized void destroy(){
  if (this.mapViewBitmap1 != null) {
    this.mapViewBitmap1.recycle();
  }
  if (this.mapViewBitmap2 != null) {
    this.mapViewBitmap2.recycle();
  }
}",0.9309462915601024
90273,"void destroy(){
  this.overlayController.interrupt();
  this.mapMover.interrupt();
  this.mapWorker.interrupt();
  this.zoomAnimator.interrupt();
  try {
    this.mapWorker.join();
  }
 catch (  InterruptedException e) {
    Thread.currentThread().interrupt();
  }
  this.frameBuffer.destroy();
  this.mapScaleBar.destroy();
  this.inMemoryTileCache.destroy();
  this.fileSystemTileCache.destroy();
  this.databaseRenderer.destroy();
  this.mapDatabase.closeFile();
}","void destroy(){
  this.overlayController.interrupt();
  this.mapMover.interrupt();
  this.mapWorker.interrupt();
  this.zoomAnimator.interrupt();
  try {
    this.mapWorker.join();
  }
 catch (  InterruptedException e) {
    Thread.currentThread().interrupt();
  }
  this.frameBuffer.destroy();
  this.mapScaleBar.destroy();
  this.inMemoryTileCache.destroy();
  this.fileSystemTileCache.destroy();
  this.mapDatabase.closeFile();
}",0.9521690767519466
90274,"/** 
 * Called when a job needs to be executed.
 * @param mapGeneratorJob the job that should be executed.
 * @param bitmap the bitmap for the generated map tile.
 * @return true if the job was executed successfully, false otherwise.
 */
public boolean executeJob(MapGeneratorJob mapGeneratorJob,android.graphics.Bitmap bitmap){
  this.currentTile=mapGeneratorJob.tile;
  XmlRenderTheme jobTheme=mapGeneratorJob.jobParameters.jobTheme;
  if (!jobTheme.equals(this.previousJobTheme)) {
    if (this.renderTheme != null) {
      this.renderTheme.destroy();
    }
    this.renderTheme=getRenderTheme(jobTheme);
    if (this.renderTheme == null) {
      this.previousJobTheme=null;
      return false;
    }
    createWayLists();
    this.previousJobTheme=jobTheme;
    this.previousZoomLevel=Byte.MIN_VALUE;
  }
  byte zoomLevel=this.currentTile.zoomLevel;
  if (zoomLevel != this.previousZoomLevel) {
    setScaleStrokeWidth(zoomLevel);
    this.previousZoomLevel=zoomLevel;
  }
  float textScale=mapGeneratorJob.jobParameters.textScale;
  if (Float.compare(textScale,this.previousTextScale) != 0) {
    this.renderTheme.scaleTextSize(textScale);
    this.previousTextScale=textScale;
  }
  if (this.mapDatabase != null) {
    MapReadResult mapReadResult=this.mapDatabase.readMapData(this.currentTile);
    processReadMapData(mapReadResult);
  }
  this.nodes=this.labelPlacement.placeLabels(this.nodes,this.pointSymbols,this.areaLabels,this.currentTile);
  this.canvasRasterer.setCanvasBitmap(bitmap);
  this.canvasRasterer.fill(this.renderTheme.getMapBackground());
  this.canvasRasterer.drawWays(this.ways);
  this.canvasRasterer.drawSymbols(this.waySymbols);
  this.canvasRasterer.drawSymbols(this.pointSymbols);
  this.canvasRasterer.drawWayNames(this.wayNames);
  this.canvasRasterer.drawNodes(this.nodes);
  this.canvasRasterer.drawNodes(this.areaLabels);
  if (mapGeneratorJob.debugSettings.drawTileFrames) {
    this.canvasRasterer.drawTileFrame();
  }
  if (mapGeneratorJob.debugSettings.drawTileCoordinates) {
    this.canvasRasterer.drawTileCoordinates(this.currentTile);
  }
  clearLists();
  return true;
}","/** 
 * Called when a job needs to be executed.
 * @param mapGeneratorJob the job that should be executed.
 * @param bitmap the bitmap for the generated map tile.
 * @return true if the job was executed successfully, false otherwise.
 */
public boolean executeJob(MapGeneratorJob mapGeneratorJob,android.graphics.Bitmap bitmap){
  this.currentTile=mapGeneratorJob.tile;
  XmlRenderTheme jobTheme=mapGeneratorJob.jobParameters.jobTheme;
  if (!jobTheme.equals(this.previousJobTheme)) {
    this.renderTheme=getRenderTheme(jobTheme);
    if (this.renderTheme == null) {
      this.previousJobTheme=null;
      return false;
    }
    createWayLists();
    this.previousJobTheme=jobTheme;
    this.previousZoomLevel=Byte.MIN_VALUE;
  }
  byte zoomLevel=this.currentTile.zoomLevel;
  if (zoomLevel != this.previousZoomLevel) {
    setScaleStrokeWidth(zoomLevel);
    this.previousZoomLevel=zoomLevel;
  }
  float textScale=mapGeneratorJob.jobParameters.textScale;
  if (Float.compare(textScale,this.previousTextScale) != 0) {
    this.renderTheme.scaleTextSize(textScale);
    this.previousTextScale=textScale;
  }
  if (this.mapDatabase != null) {
    MapReadResult mapReadResult=this.mapDatabase.readMapData(this.currentTile);
    processReadMapData(mapReadResult);
  }
  this.nodes=this.labelPlacement.placeLabels(this.nodes,this.pointSymbols,this.areaLabels,this.currentTile);
  this.canvasRasterer.setCanvasBitmap(bitmap);
  this.canvasRasterer.fill(this.renderTheme.getMapBackground());
  this.canvasRasterer.drawWays(this.ways);
  this.canvasRasterer.drawSymbols(this.waySymbols);
  this.canvasRasterer.drawSymbols(this.pointSymbols);
  this.canvasRasterer.drawWayNames(this.wayNames);
  this.canvasRasterer.drawNodes(this.nodes);
  this.canvasRasterer.drawNodes(this.areaLabels);
  if (mapGeneratorJob.debugSettings.drawTileFrames) {
    this.canvasRasterer.drawTileFrame();
  }
  if (mapGeneratorJob.debugSettings.drawTileCoordinates) {
    this.canvasRasterer.drawTileCoordinates(this.currentTile);
  }
  clearLists();
  return true;
}",0.9817219817219818
90275,"private boolean checkSize(){
  this.sizeChange.writeLock().lock();
  try {
    if (this.changeSizeNeeded) {
      return changeSize();
    }
    return true;
  }
  finally {
    this.sizeChange.writeLock().unlock();
  }
}","private boolean checkSize(){
  if (this.changeSizeNeeded) {
    return changeSize();
  }
  return true;
}",0.6441717791411042
90276,"private void recycleBitmaps(){
  if (this.bitmap1 != null) {
    this.bitmap1.recycle();
    this.bitmap1=null;
  }
  if (this.bitmap2 != null) {
    this.bitmap2.recycle();
    this.bitmap2=null;
  }
  this.overlayCanvas=null;
}","private void recycleBitmaps(){
  recycleBitmap(this.bitmap1);
  recycleBitmap(this.bitmap2);
}",0.4953560371517028
90277,"@Override protected void afterRun(){
  this.recycleBitmaps();
}","@Override protected void afterRun(){
  recycleBitmaps();
}",0.9586776859504132
90278,"private void redraw(){
  if (this.overlayCanvas == null) {
    this.overlayCanvas=new Canvas();
  }
  this.bitmap2.eraseColor(Color.TRANSPARENT);
  this.overlayCanvas.setBitmap(this.bitmap2);
  MapPosition mapPositionBefore=this.mapView.getMapViewPosition().getMapPosition();
  BoundingBox boundingBox=this.mapView.getMapViewPosition().getBoundingBox();
  List<Overlay> overlays=this.mapView.getOverlays();
synchronized (overlays) {
    for (    Overlay overlay : overlays) {
      overlay.draw(boundingBox,mapPositionBefore.zoomLevel,this.overlayCanvas);
    }
  }
  MapPosition mapPositionAfter=this.mapView.getMapViewPosition().getMapPosition();
synchronized (this.matrix) {
    adjustMatrix(mapPositionBefore,mapPositionAfter);
    swapBitmaps();
  }
  this.mapView.postInvalidate();
}","private void redraw(){
  this.bitmap2.eraseColor(Color.TRANSPARENT);
  this.overlayCanvas.setBitmap(this.bitmap2);
  MapPosition mapPositionBefore=this.mapView.getMapViewPosition().getMapPosition();
  BoundingBox boundingBox=this.mapView.getMapViewPosition().getBoundingBox();
  List<Overlay> overlays=this.mapView.getOverlays();
synchronized (overlays) {
    for (    Overlay overlay : overlays) {
      overlay.draw(boundingBox,mapPositionBefore.zoomLevel,this.overlayCanvas);
    }
  }
  MapPosition mapPositionAfter=this.mapView.getMapViewPosition().getMapPosition();
synchronized (this.matrix) {
    adjustMatrix(mapPositionBefore,mapPositionAfter);
    swapBitmaps();
  }
  this.mapView.postInvalidate();
}",0.9487008660892738
90279,"public OverlayController(MapView mapView){
  super();
  this.mapView=mapView;
  this.matrix=new Matrix();
  this.changeSizeNeeded=true;
}","public OverlayController(MapView mapView){
  super();
  this.mapView=mapView;
  this.matrix=new Matrix();
  this.overlayCanvas=new Canvas();
  this.changeSizeNeeded=true;
}",0.8867313915857605
90280,"private boolean changeSize(){
  int newWidth=this.mapView.getWidth();
  int newHeight=this.mapView.getHeight();
  if (newWidth > 0 && newHeight > 0) {
    if (this.width == newWidth && this.height == newHeight) {
      this.changeSizeNeeded=false;
      this.redrawNeeded=false;
      return false;
    }
    recycleBitmaps();
    this.width=newWidth;
    this.height=newHeight;
    this.bitmap1=Bitmap.createBitmap(newWidth,newHeight,Bitmap.Config.ARGB_8888);
    this.bitmap2=Bitmap.createBitmap(newWidth,newHeight,Bitmap.Config.ARGB_8888);
    this.changeSizeNeeded=false;
    this.redrawNeeded=true;
    return true;
  }
  return false;
}","private boolean changeSize(){
  recycleBitmaps();
  int width=this.mapView.getWidth();
  int height=this.mapView.getHeight();
  if (width > 0 && height > 0) {
    this.bitmap1=Bitmap.createBitmap(width,height,Bitmap.Config.ARGB_8888);
    this.bitmap2=Bitmap.createBitmap(width,height,Bitmap.Config.ARGB_8888);
    this.changeSizeNeeded=false;
    this.redrawNeeded=true;
    return true;
  }
  return false;
}",0.6501901140684411
90281,"private void checkRedraw(){
  this.sizeChange.readLock().lock();
  try {
    if (this.redrawNeeded) {
      this.redrawNeeded=false;
      redraw();
    }
  }
  finally {
    this.sizeChange.readLock().unlock();
  }
}","private void checkRedraw(){
  if (this.redrawNeeded) {
    this.redrawNeeded=false;
    redraw();
  }
}",0.64375
90282,"@Override public void setBitmapShader(org.mapsforge.map.graphics.Bitmap bitmap){
  if (bitmap == null) {
    return;
  }
  this.bitmap=bitmap;
  android.graphics.Bitmap androidBitmap=android.graphics.Bitmap.createBitmap(bitmap.getPixels(),bitmap.getWidth(),bitmap.getHeight(),Config.ARGB_8888);
  Shader shader=new BitmapShader(androidBitmap,TileMode.REPEAT,TileMode.REPEAT);
  this.paint.setShader(shader);
}","@Override public void setBitmapShader(org.mapsforge.map.graphics.Bitmap bitmap){
  if (bitmap == null) {
    return;
  }
  android.graphics.Bitmap androidBitmap=android.graphics.Bitmap.createBitmap(bitmap.getPixels(),bitmap.getWidth(),bitmap.getHeight(),Config.ARGB_8888);
  Shader shader=new BitmapShader(androidBitmap,TileMode.REPEAT,TileMode.REPEAT);
  this.paint.setShader(shader);
}",0.9723618090452262
90283,"@Override public void destroy(){
  this.fill.destroy();
  this.stroke.destroy();
}","@Override public void destroy(){
}",0.5862068965517241
90284,"@Override public void destroy(){
  this.stroke.destroy();
}","@Override public void destroy(){
}",0.7311827956989247
90285,"@Override public synchronized void destroy(){
  if (this.bitmapGet != null) {
    this.bitmapGet.recycle();
  }
  if (this.capacity == 0) {
    return;
  }
  if (!this.persistent || !serializeMap(this.cacheDirectory,this.map)) {
    for (    File file : this.map.values()) {
      if (!file.delete()) {
        file.deleteOnExit();
      }
    }
    this.map.clear();
    if (this.cacheDirectory != null) {
      File[] filesToDelete=this.cacheDirectory.listFiles(ImageFileNameFilter.INSTANCE);
      if (filesToDelete != null) {
        for (        File file : filesToDelete) {
          if (!file.delete()) {
            file.deleteOnExit();
          }
        }
      }
      if (!this.cacheDirectory.delete()) {
        this.cacheDirectory.deleteOnExit();
      }
    }
  }
}","@Override public synchronized void destroy(){
  if (!this.persistent || !serializeMap(this.cacheDirectory,this.map)) {
    for (    File file : this.map.values()) {
      if (!file.delete()) {
        file.deleteOnExit();
      }
    }
    this.map.clear();
    File[] filesToDelete=this.cacheDirectory.listFiles(ImageFileNameFilter.INSTANCE);
    if (filesToDelete != null) {
      for (      File file : filesToDelete) {
        if (!file.delete()) {
          file.deleteOnExit();
        }
      }
    }
    if (!this.cacheDirectory.delete()) {
      this.cacheDirectory.deleteOnExit();
    }
  }
}",0.8300795372378886
90286,"@Override public synchronized void put(MapGeneratorJob mapGeneratorJob,Bitmap bitmap){
  if (this.capacity == 0) {
    return;
  }
  FileOutputStream fileOutputStream=null;
  try {
    File outputFile;
    do {
      ++this.cacheId;
      outputFile=new File(this.cacheDirectory,this.cacheId + IMAGE_FILE_NAME_EXTENSION);
    }
 while (outputFile.exists());
    this.byteBuffer.rewind();
    bitmap.copyPixelsToBuffer(this.byteBuffer);
    byte[] array=this.byteBuffer.array();
    fileOutputStream=new FileOutputStream(outputFile);
    fileOutputStream.write(array,0,array.length);
    this.map.put(mapGeneratorJob,outputFile);
  }
 catch (  IOException e) {
    LOGGER.log(Level.SEVERE,""String_Node_Str"",e);
    this.capacity=0;
  }
 finally {
    try {
      if (fileOutputStream != null) {
        fileOutputStream.close();
      }
    }
 catch (    IOException e) {
      LOGGER.log(Level.SEVERE,null,e);
    }
  }
}","@Override public synchronized void put(MapGeneratorJob mapGeneratorJob,Bitmap bitmap){
  if (this.capacity == 0) {
    return;
  }
  FileOutputStream fileOutputStream=null;
  try {
    File outputFile;
    do {
      ++this.cacheId;
      outputFile=new File(this.cacheDirectory,this.cacheId + IMAGE_FILE_NAME_EXTENSION);
    }
 while (outputFile.exists());
    this.byteBuffer.rewind();
    bitmap.copyPixelsToBuffer(this.byteBuffer);
    byte[] array=this.byteBuffer.array();
    fileOutputStream=new FileOutputStream(outputFile);
    fileOutputStream.write(array,0,array.length);
    this.map.put(mapGeneratorJob,outputFile);
  }
 catch (  IOException e) {
    LOGGER.log(Level.SEVERE,null,e);
  }
 finally {
    try {
      if (fileOutputStream != null) {
        fileOutputStream.close();
      }
    }
 catch (    IOException e) {
      LOGGER.log(Level.SEVERE,null,e);
    }
  }
}",0.9767699115044248
90287,"/** 
 * @param capacity the maximum number of entries in this cache.
 * @param mapViewId the ID of the MapView to separate caches for different MapViews.
 * @throws IllegalArgumentException if the capacity is negative.
 */
public FileSystemTileCache(int capacity,int mapViewId){
  this.mapViewId=mapViewId;
  this.capacity=checkCapacity(capacity);
  if (this.capacity > 0 && this.cacheDirectory != null) {
    Map<MapGeneratorJob,File> deserializedMap=deserializeMap(this.cacheDirectory);
    if (deserializedMap == null) {
      this.map=createMap(this.capacity);
    }
 else {
      this.map=deserializedMap;
    }
    this.byteBuffer=ByteBuffer.allocate(TILE_SIZE_IN_BYTES);
    this.bitmapGet=Bitmap.createBitmap(Tile.TILE_SIZE,Tile.TILE_SIZE,Config.RGB_565);
  }
 else {
    this.byteBuffer=null;
    this.bitmapGet=null;
    this.map=createMap(0);
  }
}","/** 
 * @param capacity the maximum number of entries in this cache.
 * @param mapViewId the ID of the MapView to separate caches for different MapViews.
 * @throws IllegalArgumentException if the capacity is negative.
 */
public FileSystemTileCache(int capacity,int mapViewId){
  this.capacity=getCapacity(capacity);
  String externalStorageDirectory=Environment.getExternalStorageDirectory().getAbsolutePath();
  String cacheDirectoryPath=externalStorageDirectory + CACHE_DIRECTORY + mapViewId;
  this.cacheDirectory=createDirectory(cacheDirectoryPath);
  Map<MapGeneratorJob,File> deserializedMap=deserializeMap(this.cacheDirectory);
  if (deserializedMap == null) {
    this.map=createMap(this.capacity);
  }
 else {
    this.map=deserializedMap;
  }
  this.byteBuffer=ByteBuffer.allocate(TILE_SIZE_IN_BYTES);
  this.bitmapGet=Bitmap.createBitmap(Tile.TILE_SIZE,Tile.TILE_SIZE,Config.RGB_565);
}",0.7417519908987485
90288,"@Override public synchronized void setCapacity(int capacity){
  if (this.capacity == capacity) {
    return;
  }
  this.capacity=checkCapacity(capacity);
  if (this.capacity != 0) {
    Map<MapGeneratorJob,File> newMap=createMap(this.capacity);
    if (this.map != null) {
      newMap.putAll(this.map);
    }
    this.map=newMap;
  }
}","@Override public synchronized void setCapacity(int capacity){
  if (this.capacity == capacity) {
    return;
  }
  this.capacity=getCapacity(capacity);
  Map<MapGeneratorJob,File> newMap=createMap(this.capacity);
  newMap.putAll(this.map);
  this.map=newMap;
}",0.7651006711409396
90289,"/** 
 * Called when a job needs to be executed.
 * @param mapGeneratorJob the job that should be executed.
 * @param bitmap the bitmap for the generated map tile.
 * @return true if the job was executed successfully, false otherwise.
 */
public boolean executeJob(MapGeneratorJob mapGeneratorJob,android.graphics.Bitmap bitmap){
  this.currentTile=mapGeneratorJob.tile;
  XmlRenderTheme jobTheme=mapGeneratorJob.jobParameters.jobTheme;
  if (!jobTheme.equals(this.previousJobTheme)) {
    if (this.renderTheme != null) {
      this.renderTheme.destroy();
    }
    this.renderTheme=getRenderTheme(jobTheme);
    if (this.renderTheme == null) {
      this.previousJobTheme=null;
      return false;
    }
    createWayLists();
    this.previousJobTheme=jobTheme;
    this.previousZoomLevel=Byte.MIN_VALUE;
    this.previousTextScale=-1;
  }
  byte zoomLevel=this.currentTile.zoomLevel;
  if (zoomLevel != this.previousZoomLevel) {
    setScaleStrokeWidth(zoomLevel);
    this.previousZoomLevel=zoomLevel;
  }
  float textScale=mapGeneratorJob.jobParameters.textScale;
  if (Float.compare(textScale,this.previousTextScale) != 0) {
    this.renderTheme.scaleTextSize(textScale);
    this.previousTextScale=textScale;
  }
  if (this.mapDatabase != null) {
    MapReadResult mapReadResult=this.mapDatabase.readMapData(this.currentTile);
    processReadMapData(mapReadResult);
  }
  this.nodes=this.labelPlacement.placeLabels(this.nodes,this.pointSymbols,this.areaLabels,this.currentTile);
  this.canvasRasterer.setCanvasBitmap(bitmap);
  this.canvasRasterer.fill(this.renderTheme.getMapBackground());
  this.canvasRasterer.drawWays(this.ways);
  this.canvasRasterer.drawSymbols(this.waySymbols);
  this.canvasRasterer.drawSymbols(this.pointSymbols);
  this.canvasRasterer.drawWayNames(this.wayNames);
  this.canvasRasterer.drawNodes(this.nodes);
  this.canvasRasterer.drawNodes(this.areaLabels);
  if (mapGeneratorJob.debugSettings.drawTileFrames) {
    this.canvasRasterer.drawTileFrame();
  }
  if (mapGeneratorJob.debugSettings.drawTileCoordinates) {
    this.canvasRasterer.drawTileCoordinates(this.currentTile);
  }
  clearLists();
  return true;
}","/** 
 * Called when a job needs to be executed.
 * @param mapGeneratorJob the job that should be executed.
 * @param bitmap the bitmap for the generated map tile.
 * @return true if the job was executed successfully, false otherwise.
 */
public boolean executeJob(MapGeneratorJob mapGeneratorJob,android.graphics.Bitmap bitmap){
  this.currentTile=mapGeneratorJob.tile;
  XmlRenderTheme jobTheme=mapGeneratorJob.jobParameters.jobTheme;
  if (!jobTheme.equals(this.previousJobTheme)) {
    if (this.renderTheme != null) {
      this.renderTheme.destroy();
    }
    this.renderTheme=getRenderTheme(jobTheme);
    if (this.renderTheme == null) {
      this.previousJobTheme=null;
      return false;
    }
    createWayLists();
    this.previousJobTheme=jobTheme;
    this.previousZoomLevel=Byte.MIN_VALUE;
  }
  byte zoomLevel=this.currentTile.zoomLevel;
  if (zoomLevel != this.previousZoomLevel) {
    setScaleStrokeWidth(zoomLevel);
    this.previousZoomLevel=zoomLevel;
  }
  float textScale=mapGeneratorJob.jobParameters.textScale;
  if (Float.compare(textScale,this.previousTextScale) != 0) {
    this.renderTheme.scaleTextSize(textScale);
    this.previousTextScale=textScale;
  }
  if (this.mapDatabase != null) {
    MapReadResult mapReadResult=this.mapDatabase.readMapData(this.currentTile);
    processReadMapData(mapReadResult);
  }
  this.nodes=this.labelPlacement.placeLabels(this.nodes,this.pointSymbols,this.areaLabels,this.currentTile);
  this.canvasRasterer.setCanvasBitmap(bitmap);
  this.canvasRasterer.fill(this.renderTheme.getMapBackground());
  this.canvasRasterer.drawWays(this.ways);
  this.canvasRasterer.drawSymbols(this.waySymbols);
  this.canvasRasterer.drawSymbols(this.pointSymbols);
  this.canvasRasterer.drawWayNames(this.wayNames);
  this.canvasRasterer.drawNodes(this.nodes);
  this.canvasRasterer.drawNodes(this.areaLabels);
  if (mapGeneratorJob.debugSettings.drawTileFrames) {
    this.canvasRasterer.drawTileFrame();
  }
  if (mapGeneratorJob.debugSettings.drawTileCoordinates) {
    this.canvasRasterer.drawTileCoordinates(this.currentTile);
  }
  clearLists();
  return true;
}",0.9927315357561548
90290,"/** 
 * Gets the center point of the dimension.
 * @return the center point
 */
public Point getCenter(){
  return new Point(this.width / 2,this.height / 2);
}","/** 
 * Gets the center point of the dimension.
 * @return the center point
 */
public Point getCenter(){
  return new Point((float)this.width / 2,(float)this.height / 2);
}",0.9578313253012049
90291,"/** 
 * Calculates the zoom level that allows to display the   {@link BoundingBox} on aview with the  {@link Dimension} and tile size.
 * @param dimension the {@link Dimension} of the view
 * @param boundingBox the {@link BoundingBox} to display
 * @param tileSize the size of the tiles
 * @return the zoom level that allows to display the {@link BoundingBox} on aview with the  {@link Dimension} and tile size
 */
public static byte zoomForBounds(Dimension dimension,BoundingBox boundingBox,int tileSize){
  double dxMax=MercatorProjection.longitudeToPixelX(boundingBox.maxLongitude,(byte)0,tileSize) / tileSize;
  double dxMin=MercatorProjection.longitudeToPixelX(boundingBox.minLongitude,(byte)0,tileSize) / tileSize;
  double zoomX=Math.floor(-Math.log(3.8) * Math.log(Math.abs(dxMax - dxMin)) + dimension.width / tileSize);
  double dyMax=MercatorProjection.latitudeToPixelY(boundingBox.maxLatitude,(byte)0,tileSize) / tileSize;
  double dyMin=MercatorProjection.latitudeToPixelY(boundingBox.minLatitude,(byte)0,tileSize) / tileSize;
  double zoomY=Math.floor(-Math.log(3.8) * Math.log(Math.abs(dyMax - dyMin)) + dimension.height / tileSize);
  return (byte)Double.valueOf(Math.min(zoomX,zoomY)).intValue();
}","/** 
 * Calculates the zoom level that allows to display the   {@link BoundingBox} on aview with the  {@link Dimension} and tile size.
 * @param dimension the {@link Dimension} of the view
 * @param boundingBox the {@link BoundingBox} to display
 * @param tileSize the size of the tiles
 * @return the zoom level that allows to display the {@link BoundingBox} on aview with the  {@link Dimension} and tile size
 */
public static byte zoomForBounds(Dimension dimension,BoundingBox boundingBox,int tileSize){
  double dxMax=MercatorProjection.longitudeToPixelX(boundingBox.maxLongitude,(byte)0,tileSize) / tileSize;
  double dxMin=MercatorProjection.longitudeToPixelX(boundingBox.minLongitude,(byte)0,tileSize) / tileSize;
  double zoomX=Math.floor(-Math.log(3.8) * Math.log(Math.abs(dxMax - dxMin)) + (float)dimension.width / tileSize);
  double dyMax=MercatorProjection.latitudeToPixelY(boundingBox.maxLatitude,(byte)0,tileSize) / tileSize;
  double dyMin=MercatorProjection.latitudeToPixelY(boundingBox.minLatitude,(byte)0,tileSize) / tileSize;
  double zoomY=Math.floor(-Math.log(3.8) * Math.log(Math.abs(dyMax - dyMin)) + (float)dimension.height / tileSize);
  return (byte)Math.min(zoomX,zoomY);
}",0.9830227743271222
90292,"/** 
 * Get LatLong form Pixels.
 * @Author Stephan Brandt <stephan@contagt.com>
 */
public static LatLong fromPixels(double pixelX,double pixelY,byte zoomLevel,int tileSize){
  return new LatLong(pixelYToLatitude(pixelY,zoomLevel,tileSize),pixelXToLongitude(pixelX,zoomLevel,tileSize));
}","/** 
 * Get LatLong form Pixels.
 * @author Stephan Brandt <stephan@contagt.com>
 */
public static LatLong fromPixels(double pixelX,double pixelY,byte zoomLevel,int tileSize){
  return new LatLong(pixelYToLatitude(pixelY,zoomLevel,tileSize),pixelXToLongitude(pixelX,zoomLevel,tileSize));
}",0.9965397923875432
90293,"@Test public void latitudeToPixelYTest(){
  for (  int tileSize : TILE_SIZES) {
    for (byte zoomLevel=ZOOM_LEVEL_MIN; zoomLevel <= ZOOM_LEVEL_MAX; ++zoomLevel) {
      double pixelY=MercatorProjection.latitudeToPixelY(MercatorProjection.LATITUDE_MAX,zoomLevel,tileSize);
      Assert.assertEquals(0,pixelY,0);
      long mapSize=MercatorProjection.getMapSize(zoomLevel,tileSize);
      pixelY=MercatorProjection.latitudeToPixelY(0,zoomLevel,tileSize);
      Assert.assertEquals(mapSize / 2,pixelY,0);
      pixelY=MercatorProjection.latitudeToPixelY(MercatorProjection.LATITUDE_MIN,zoomLevel,tileSize);
      Assert.assertEquals(mapSize,pixelY,0);
    }
  }
}","@Test public void latitudeToPixelYTest(){
  for (  int tileSize : TILE_SIZES) {
    for (byte zoomLevel=ZOOM_LEVEL_MIN; zoomLevel <= ZOOM_LEVEL_MAX; ++zoomLevel) {
      double pixelY=MercatorProjection.latitudeToPixelY(MercatorProjection.LATITUDE_MAX,zoomLevel,tileSize);
      Assert.assertEquals(0,pixelY,0);
      long mapSize=MercatorProjection.getMapSize(zoomLevel,tileSize);
      pixelY=MercatorProjection.latitudeToPixelY(0,zoomLevel,tileSize);
      Assert.assertEquals((float)mapSize / 2,pixelY,0);
      pixelY=MercatorProjection.latitudeToPixelY(MercatorProjection.LATITUDE_MIN,zoomLevel,tileSize);
      Assert.assertEquals(mapSize,pixelY,0);
    }
  }
}",0.9947328818660648
90294,"@Test public void pixelXToLongitudeTest(){
  for (  int tileSize : TILE_SIZES) {
    for (byte zoomLevel=ZOOM_LEVEL_MIN; zoomLevel <= ZOOM_LEVEL_MAX; ++zoomLevel) {
      double longitude=MercatorProjection.pixelXToLongitude(0,zoomLevel,tileSize);
      Assert.assertEquals(LatLongUtils.LONGITUDE_MIN,longitude,0);
      long mapSize=MercatorProjection.getMapSize(zoomLevel,tileSize);
      longitude=MercatorProjection.pixelXToLongitude(mapSize / 2,zoomLevel,tileSize);
      Assert.assertEquals(0,longitude,0);
      longitude=MercatorProjection.pixelXToLongitude(mapSize,zoomLevel,tileSize);
      Assert.assertEquals(LatLongUtils.LONGITUDE_MAX,longitude,0);
    }
    verifyInvalidPixelXToLongitude(-1,(byte)0,tileSize);
    verifyInvalidPixelXToLongitude(tileSize + 1,(byte)0,tileSize);
  }
}","@Test public void pixelXToLongitudeTest(){
  for (  int tileSize : TILE_SIZES) {
    for (byte zoomLevel=ZOOM_LEVEL_MIN; zoomLevel <= ZOOM_LEVEL_MAX; ++zoomLevel) {
      double longitude=MercatorProjection.pixelXToLongitude(0,zoomLevel,tileSize);
      Assert.assertEquals(LatLongUtils.LONGITUDE_MIN,longitude,0);
      long mapSize=MercatorProjection.getMapSize(zoomLevel,tileSize);
      longitude=MercatorProjection.pixelXToLongitude((float)mapSize / 2,zoomLevel,tileSize);
      Assert.assertEquals(0,longitude,0);
      longitude=MercatorProjection.pixelXToLongitude(mapSize,zoomLevel,tileSize);
      Assert.assertEquals(LatLongUtils.LONGITUDE_MAX,longitude,0);
    }
    verifyInvalidPixelXToLongitude(-1,(byte)0,tileSize);
    verifyInvalidPixelXToLongitude(tileSize + 1,(byte)0,tileSize);
  }
}",0.995627732667083
90295,"@Test public void longitudeToPixelXTest(){
  for (  int tileSize : TILE_SIZES) {
    for (byte zoomLevel=ZOOM_LEVEL_MIN; zoomLevel <= ZOOM_LEVEL_MAX; ++zoomLevel) {
      double pixelX=MercatorProjection.longitudeToPixelX(LatLongUtils.LONGITUDE_MIN,zoomLevel,tileSize);
      Assert.assertEquals(0,pixelX,0);
      long mapSize=MercatorProjection.getMapSize(zoomLevel,tileSize);
      pixelX=MercatorProjection.longitudeToPixelX(0,zoomLevel,tileSize);
      Assert.assertEquals(mapSize / 2,pixelX,0);
      pixelX=MercatorProjection.longitudeToPixelX(LatLongUtils.LONGITUDE_MAX,zoomLevel,tileSize);
      Assert.assertEquals(mapSize,pixelX,0);
    }
  }
}","@Test public void longitudeToPixelXTest(){
  for (  int tileSize : TILE_SIZES) {
    for (byte zoomLevel=ZOOM_LEVEL_MIN; zoomLevel <= ZOOM_LEVEL_MAX; ++zoomLevel) {
      double pixelX=MercatorProjection.longitudeToPixelX(LatLongUtils.LONGITUDE_MIN,zoomLevel,tileSize);
      Assert.assertEquals(0,pixelX,0);
      long mapSize=MercatorProjection.getMapSize(zoomLevel,tileSize);
      pixelX=MercatorProjection.longitudeToPixelX(0,zoomLevel,tileSize);
      Assert.assertEquals((float)mapSize / 2,pixelX,0);
      pixelX=MercatorProjection.longitudeToPixelX(LatLongUtils.LONGITUDE_MAX,zoomLevel,tileSize);
      Assert.assertEquals(mapSize,pixelX,0);
    }
  }
}",0.9946848899012908
90296,"@Test public void pixelYToLatitudeTest(){
  for (  int tileSize : TILE_SIZES) {
    for (byte zoomLevel=ZOOM_LEVEL_MIN; zoomLevel <= ZOOM_LEVEL_MAX; ++zoomLevel) {
      double latitude=MercatorProjection.pixelYToLatitude(0,zoomLevel,tileSize);
      Assert.assertEquals(MercatorProjection.LATITUDE_MAX,latitude,0);
      long mapSize=MercatorProjection.getMapSize(zoomLevel,tileSize);
      latitude=MercatorProjection.pixelYToLatitude(mapSize / 2,zoomLevel,tileSize);
      Assert.assertEquals(0,latitude,0);
      latitude=MercatorProjection.pixelYToLatitude(mapSize,zoomLevel,tileSize);
      Assert.assertEquals(MercatorProjection.LATITUDE_MIN,latitude,0);
    }
    verifyInvalidPixelYToLatitude(-1,(byte)0,tileSize);
    verifyInvalidPixelYToLatitude(tileSize + 1,(byte)0,tileSize);
  }
}","@Test public void pixelYToLatitudeTest(){
  for (  int tileSize : TILE_SIZES) {
    for (byte zoomLevel=ZOOM_LEVEL_MIN; zoomLevel <= ZOOM_LEVEL_MAX; ++zoomLevel) {
      double latitude=MercatorProjection.pixelYToLatitude(0,zoomLevel,tileSize);
      Assert.assertEquals(MercatorProjection.LATITUDE_MAX,latitude,0);
      long mapSize=MercatorProjection.getMapSize(zoomLevel,tileSize);
      latitude=MercatorProjection.pixelYToLatitude((float)mapSize / 2,zoomLevel,tileSize);
      Assert.assertEquals(0,latitude,0);
      latitude=MercatorProjection.pixelYToLatitude(mapSize,zoomLevel,tileSize);
      Assert.assertEquals(MercatorProjection.LATITUDE_MIN,latitude,0);
    }
    verifyInvalidPixelYToLatitude(-1,(byte)0,tileSize);
    verifyInvalidPixelYToLatitude(tileSize + 1,(byte)0,tileSize);
  }
}",0.9956167814652472
90297,"@Override public void setBitmapShader(org.mapsforge.core.graphics.Bitmap bitmap){
  if (bitmap == null) {
    return;
  }
  if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {
  }
  this.paint.setColor(AndroidGraphicFactory.getColor(Color.WHITE));
  this.paint.setShader(new BitmapShader(AndroidGraphicFactory.getBitmap(bitmap),TileMode.REPEAT,TileMode.REPEAT));
}","@Override public void setBitmapShader(org.mapsforge.core.graphics.Bitmap bitmap){
  if (bitmap == null) {
    return;
  }
  if (!AndroidGraphicFactory.keepResourceBitmaps && Build.VERSION.SDK_INT >= Build.VERSION_CODES.HONEYCOMB) {
    bitmap.incrementRefCount();
  }
  this.paint.setColor(AndroidGraphicFactory.getColor(Color.WHITE));
  this.paint.setShader(new BitmapShader(AndroidGraphicFactory.getBitmap(bitmap),TileMode.REPEAT,TileMode.REPEAT));
}",0.9055690072639224
90298,"/** 
 * Sets the maximum zoom level of the map. <p> The maximum possible zoom level of the MapView depends also on the current   {@link DatabaseRenderer}. For example, downloading map tiles may only be possible up to a certain zoom level. Setting a higher maximum zoom level has no effect in this case.
 * @param zoomLevelMax the maximum zoom level.
 * @throws IllegalArgumentException if the maximum zoom level is smaller than the current minimum zoom level.
 */
public void setZoomLevelMax(byte zoomLevelMax){
  if (zoomLevelMax < this.zoomLevelMin) {
    throw new IllegalArgumentException();
  }
  this.zoomLevelMax=zoomLevelMax;
}","/** 
 * Sets the maximum zoom level of the map. <p> The maximum possible zoom level of the MapView depends also on other elements. For example, downloading map tiles may only be possible up to a certain zoom level. Setting a higher maximum zoom level has no effect in this case.
 * @param zoomLevelMax the maximum zoom level.
 * @throws IllegalArgumentException if the maximum zoom level is smaller than the current minimum zoom level.
 */
public void setZoomLevelMax(byte zoomLevelMax){
  if (zoomLevelMax < this.zoomLevelMin) {
    throw new IllegalArgumentException();
  }
  this.zoomLevelMax=zoomLevelMax;
}",0.9582664526484752
90299,"private PoiWayBundle processBlock(QueryParameters queryParameters,SubFileParameter subFileParameter){
  if (!processBlockSignature()) {
    return null;
  }
  int[][] zoomTable=readZoomTable(subFileParameter);
  if (zoomTable == null) {
    return null;
  }
  int zoomTableRow=queryParameters.queryZoomLevel - subFileParameter.zoomLevelMin;
  int poisOnQueryZoomLevel=zoomTable[zoomTableRow][0];
  int waysOnQueryZoomLevel=zoomTable[zoomTableRow][1];
  int firstWayOffset=this.readBuffer.readUnsignedInt();
  if (firstWayOffset < 0) {
    LOGGER.warning(INVALID_FIRST_WAY_OFFSET + firstWayOffset);
    if (this.mapFileHeader.getMapFileInfo().debugFile) {
      LOGGER.warning(DEBUG_SIGNATURE_BLOCK + this.signatureBlock);
    }
    return null;
  }
  firstWayOffset+=this.readBuffer.getBufferPosition();
  if (firstWayOffset > this.readBuffer.getBufferSize()) {
    LOGGER.warning(INVALID_FIRST_WAY_OFFSET + firstWayOffset);
    if (this.mapFileHeader.getMapFileInfo().debugFile) {
      LOGGER.warning(DEBUG_SIGNATURE_BLOCK + this.signatureBlock);
    }
    return null;
  }
  List<PointOfInterest> pois=processPOIs(poisOnQueryZoomLevel);
  if (pois == null) {
    return null;
  }
  if (this.readBuffer.getBufferPosition() > firstWayOffset) {
    LOGGER.warning(""String_Node_Str"" + this.readBuffer.getBufferPosition());
    if (this.mapFileHeader.getMapFileInfo().debugFile) {
      LOGGER.warning(DEBUG_SIGNATURE_BLOCK + this.signatureBlock);
    }
    return null;
  }
  this.readBuffer.setBufferPosition(firstWayOffset);
  List<Way> ways=processWays(queryParameters,waysOnQueryZoomLevel);
  if (ways == null) {
    return null;
  }
  return new PoiWayBundle(pois,ways);
}","private PoiWayBundle processBlock(QueryParameters queryParameters,SubFileParameter subFileParameter){
  if (!processBlockSignature()) {
    return null;
  }
  int[][] zoomTable=readZoomTable(subFileParameter);
  int zoomTableRow=queryParameters.queryZoomLevel - subFileParameter.zoomLevelMin;
  int poisOnQueryZoomLevel=zoomTable[zoomTableRow][0];
  int waysOnQueryZoomLevel=zoomTable[zoomTableRow][1];
  int firstWayOffset=this.readBuffer.readUnsignedInt();
  if (firstWayOffset < 0) {
    LOGGER.warning(INVALID_FIRST_WAY_OFFSET + firstWayOffset);
    if (this.mapFileHeader.getMapFileInfo().debugFile) {
      LOGGER.warning(DEBUG_SIGNATURE_BLOCK + this.signatureBlock);
    }
    return null;
  }
  firstWayOffset+=this.readBuffer.getBufferPosition();
  if (firstWayOffset > this.readBuffer.getBufferSize()) {
    LOGGER.warning(INVALID_FIRST_WAY_OFFSET + firstWayOffset);
    if (this.mapFileHeader.getMapFileInfo().debugFile) {
      LOGGER.warning(DEBUG_SIGNATURE_BLOCK + this.signatureBlock);
    }
    return null;
  }
  List<PointOfInterest> pois=processPOIs(poisOnQueryZoomLevel);
  if (pois == null) {
    return null;
  }
  if (this.readBuffer.getBufferPosition() > firstWayOffset) {
    LOGGER.warning(""String_Node_Str"" + this.readBuffer.getBufferPosition());
    if (this.mapFileHeader.getMapFileInfo().debugFile) {
      LOGGER.warning(DEBUG_SIGNATURE_BLOCK + this.signatureBlock);
    }
    return null;
  }
  this.readBuffer.setBufferPosition(firstWayOffset);
  List<Way> ways=processWays(queryParameters,waysOnQueryZoomLevel);
  if (ways == null) {
    return null;
  }
  return new PoiWayBundle(pois,ways);
}",0.9854721549636803
90300,"private static Dimension calculateFrameBufferDimension(Dimension mapViewDimension,double overdrawFactor){
  int width=(int)(mapViewDimension.width * overdrawFactor);
  int height=(int)(mapViewDimension.height * overdrawFactor);
  if (useSquareFrameBuffer) {
    float aspectRatio=mapViewDimension.width / mapViewDimension.height;
    if (aspectRatio < maxAspectRatio && aspectRatio > maxAspectRatio / 1) {
      width=Math.max(width,height);
      height=width;
    }
  }
  return new Dimension(width,height);
}","private static Dimension calculateFrameBufferDimension(Dimension mapViewDimension,double overdrawFactor){
  int width=(int)(mapViewDimension.width * overdrawFactor);
  int height=(int)(mapViewDimension.height * overdrawFactor);
  if (useSquareFrameBuffer) {
    float aspectRatio=((float)mapViewDimension.width) / mapViewDimension.height;
    if (aspectRatio < maxAspectRatio && aspectRatio > maxAspectRatio / 1) {
      width=Math.max(width,height);
      height=width;
    }
  }
  return new Dimension(width,height);
}",0.991270611057226
90301,"public TileDownloadLayer(TileCache tileCache,MapViewPosition mapViewPosition,TileSource tileSource,GraphicFactory graphicFactory){
  super(tileCache,mapViewPosition,graphicFactory.createMatrix(),tileSource.hasAlpha());
  if (tileSource == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  this.tileCache=tileCache;
  this.tileSource=tileSource;
  this.graphicFactory=graphicFactory;
}","public TileDownloadLayer(TileCache tileCache,MapViewPosition mapViewPosition,TileSource tileSource,GraphicFactory graphicFactory){
  super(tileCache,mapViewPosition,graphicFactory.createMatrix(),tileSource.hasAlpha());
  this.tileCache=tileCache;
  this.tileSource=tileSource;
  this.graphicFactory=graphicFactory;
}",0.8741355463347165
90302,"@Override public void onDestroy(){
  if (this.bitmap != null) {
    this.bitmap.decrementRefCount();
  }
}","@Override public synchronized void onDestroy(){
  if (this.bitmap != null) {
    this.bitmap.decrementRefCount();
  }
}",0.9422222222222222
90303,"public boolean contains(Point center,Point point){
  Rectangle r=new Rectangle(center.x - bitmap.getWidth() / 2 + this.horizontalOffset,center.y - bitmap.getHeight() / 2 + this.verticalOffset,center.x + bitmap.getWidth() / 2 + this.horizontalOffset,center.y + bitmap.getHeight() / 2 + this.verticalOffset);
  return r.contains(point);
}","public synchronized boolean contains(Point center,Point point){
  Rectangle r=new Rectangle(center.x - (float)bitmap.getWidth() / 2 + this.horizontalOffset,center.y - (float)bitmap.getHeight() / 2 + this.verticalOffset,center.x + (float)bitmap.getWidth() / 2 + this.horizontalOffset,center.y + (float)bitmap.getHeight() / 2 + this.verticalOffset);
  return r.contains(point);
}",0.9424964936886396
90304,"/** 
 * This method uses an adapted greedy strategy for the fixed four position model, above, under left and right form the point of interest. It uses no priority search tree, because it will not function with symbols only with points. Instead it uses two minimum heaps. They work similar to a sweep line algorithm but have not a O(n log n +k) runtime. To find the rectangle that has the top edge, I use also a minimum Heap. The rectangles are sorted by their y coordinates.
 * @param labels label positions and text
 * @param symbols symbol positions
 * @param areaLabels area label positions and text
 * @return list of labels without overlaps with symbols and other labels by the four fixed position greedy strategy
 */
private List<PointTextContainer> processFourPointGreedy(List<PointTextContainer> labels,List<SymbolContainer> symbols,List<PointTextContainer> areaLabels,int tileSize){
  List<PointTextContainer> resolutionSet=new ArrayList<PointTextContainer>();
  ReferencePosition[] refPos=new ReferencePosition[(labels.size()) * 4];
  PriorityQueue<ReferencePosition> priorUp=new PriorityQueue<ReferencePosition>(labels.size() * 4 * 2 + labels.size() / 10 * 2,ReferencePositionYComparator.INSTANCE);
  PriorityQueue<ReferencePosition> priorDown=new PriorityQueue<ReferencePosition>(labels.size() * 4 * 2 + labels.size() / 10 * 2,ReferencePositionHeightComparator.INSTANCE);
  PointTextContainer tmp;
  int dis=START_DISTANCE_TO_SYMBOLS;
  for (int z=0; z < labels.size(); z++) {
    if (labels.get(z) != null) {
      if (labels.get(z).symbol != null) {
        tmp=labels.get(z);
        refPos[z * 4]=new ReferencePosition(tmp.x - tmp.boundary.getWidth() / 2,tmp.y - tmp.symbol.symbol.getHeight() / 2 - dis,z,tmp.boundary.getWidth(),tmp.boundary.getHeight());
        refPos[z * 4 + 1]=new ReferencePosition(tmp.x - tmp.boundary.getWidth() / 2,tmp.y + tmp.symbol.symbol.getHeight() / 2 + tmp.boundary.getHeight() + dis,z,tmp.boundary.getWidth(),tmp.boundary.getHeight());
        refPos[z * 4 + 2]=new ReferencePosition(tmp.x - tmp.symbol.symbol.getWidth() / 2 - tmp.boundary.getWidth() - dis,tmp.y + tmp.boundary.getHeight() / 2,z,tmp.boundary.getWidth(),tmp.boundary.getHeight());
        refPos[z * 4 + 3]=new ReferencePosition(tmp.x + tmp.symbol.symbol.getWidth() / 2 + dis,tmp.y + tmp.boundary.getHeight() / 2 - 0.1f,z,tmp.boundary.getWidth(),tmp.boundary.getHeight());
      }
 else {
        refPos[z * 4]=new ReferencePosition(labels.get(z).x - ((labels.get(z).boundary.getWidth()) / 2),labels.get(z).y,z,labels.get(z).boundary.getWidth(),labels.get(z).boundary.getHeight());
        refPos[z * 4 + 1]=null;
        refPos[z * 4 + 2]=null;
        refPos[z * 4 + 3]=null;
      }
    }
  }
  removeNonValidateReferencePosition(refPos,symbols,areaLabels,tileSize);
  for (int i=0; i < refPos.length; i++) {
    this.referencePosition=refPos[i];
    if (this.referencePosition != null) {
      priorUp.add(this.referencePosition);
      priorDown.add(this.referencePosition);
    }
  }
  while (priorUp.size() != 0) {
    this.referencePosition=priorUp.remove();
    this.label=labels.get(this.referencePosition.nodeNumber);
    resolutionSet.add(new PointTextContainer(this.label.text,this.referencePosition.x,this.referencePosition.y,this.label.paintFront,this.label.paintBack,this.label.symbol));
    if (priorUp.size() == 0) {
      return resolutionSet;
    }
    priorUp.remove(refPos[this.referencePosition.nodeNumber * 4 + 0]);
    priorUp.remove(refPos[this.referencePosition.nodeNumber * 4 + 1]);
    priorUp.remove(refPos[this.referencePosition.nodeNumber * 4 + 2]);
    priorUp.remove(refPos[this.referencePosition.nodeNumber * 4 + 3]);
    priorDown.remove(refPos[this.referencePosition.nodeNumber * 4 + 0]);
    priorDown.remove(refPos[this.referencePosition.nodeNumber * 4 + 1]);
    priorDown.remove(refPos[this.referencePosition.nodeNumber * 4 + 2]);
    priorDown.remove(refPos[this.referencePosition.nodeNumber * 4 + 3]);
    LinkedList<ReferencePosition> linkedRef=new LinkedList<ReferencePosition>();
    while (priorDown.size() != 0) {
      if (priorDown.peek().x < this.referencePosition.x + this.referencePosition.width) {
        linkedRef.add(priorDown.remove());
      }
 else {
        break;
      }
    }
    for (int i=0; i < linkedRef.size(); i++) {
      if ((linkedRef.get(i).x <= this.referencePosition.x + this.referencePosition.width) && (linkedRef.get(i).y >= this.referencePosition.y - linkedRef.get(i).height) && (linkedRef.get(i).y <= this.referencePosition.y + linkedRef.get(i).height)) {
        priorUp.remove(linkedRef.get(i));
        linkedRef.remove(i);
        i--;
      }
    }
    priorDown.addAll(linkedRef);
  }
  return resolutionSet;
}","/** 
 * This method uses an adapted greedy strategy for the fixed four position model, above, under left and right form the point of interest. It uses no priority search tree, because it will not function with symbols only with points. Instead it uses two minimum heaps. They work similar to a sweep line algorithm but have not a O(n log n +k) runtime. To find the rectangle that has the top edge, I use also a minimum Heap. The rectangles are sorted by their y coordinates.
 * @param labels label positions and text
 * @param symbols symbol positions
 * @param areaLabels area label positions and text
 * @return list of labels without overlaps with symbols and other labels by the four fixed position greedy strategy
 */
private List<PointTextContainer> processFourPointGreedy(List<PointTextContainer> labels,List<SymbolContainer> symbols,List<PointTextContainer> areaLabels,int tileSize){
  List<PointTextContainer> resolutionSet=new ArrayList<PointTextContainer>();
  ReferencePosition[] refPos=new ReferencePosition[(labels.size()) * 4];
  PriorityQueue<ReferencePosition> priorUp=new PriorityQueue<ReferencePosition>(labels.size() * 4 * 2 + labels.size() / 10 * 2,ReferencePositionYComparator.INSTANCE);
  PriorityQueue<ReferencePosition> priorDown=new PriorityQueue<ReferencePosition>(labels.size() * 4 * 2 + labels.size() / 10 * 2,ReferencePositionHeightComparator.INSTANCE);
  PointTextContainer tmp;
  int dis=START_DISTANCE_TO_SYMBOLS;
  for (int z=0; z < labels.size(); z++) {
    if (labels.get(z) != null) {
      if (labels.get(z).symbol != null) {
        tmp=labels.get(z);
        refPos[z * 4]=new ReferencePosition(tmp.x - (float)tmp.boundary.getWidth() / 2,tmp.y - (float)tmp.symbol.symbol.getHeight() / 2 - dis,z,tmp.boundary.getWidth(),tmp.boundary.getHeight());
        refPos[z * 4 + 1]=new ReferencePosition(tmp.x - (float)tmp.boundary.getWidth() / 2,tmp.y + (float)tmp.symbol.symbol.getHeight() / 2 + (float)tmp.boundary.getHeight() + dis,z,tmp.boundary.getWidth(),tmp.boundary.getHeight());
        refPos[z * 4 + 2]=new ReferencePosition(tmp.x - (float)tmp.symbol.symbol.getWidth() / 2 - tmp.boundary.getWidth() - dis,tmp.y + (float)tmp.boundary.getHeight() / 2,z,tmp.boundary.getWidth(),tmp.boundary.getHeight());
        refPos[z * 4 + 3]=new ReferencePosition(tmp.x + (float)tmp.symbol.symbol.getWidth() / 2 + dis,tmp.y + (float)tmp.boundary.getHeight() / 2 - 0.1f,z,tmp.boundary.getWidth(),tmp.boundary.getHeight());
      }
 else {
        refPos[z * 4]=new ReferencePosition(labels.get(z).x - (((float)labels.get(z).boundary.getWidth()) / 2),labels.get(z).y,z,labels.get(z).boundary.getWidth(),labels.get(z).boundary.getHeight());
        refPos[z * 4 + 1]=null;
        refPos[z * 4 + 2]=null;
        refPos[z * 4 + 3]=null;
      }
    }
  }
  removeNonValidateReferencePosition(refPos,symbols,areaLabels,tileSize);
  for (int i=0; i < refPos.length; i++) {
    this.referencePosition=refPos[i];
    if (this.referencePosition != null) {
      priorUp.add(this.referencePosition);
      priorDown.add(this.referencePosition);
    }
  }
  while (priorUp.size() != 0) {
    this.referencePosition=priorUp.remove();
    this.label=labels.get(this.referencePosition.nodeNumber);
    resolutionSet.add(new PointTextContainer(this.label.text,this.referencePosition.x,this.referencePosition.y,this.label.paintFront,this.label.paintBack,this.label.symbol));
    if (priorUp.size() == 0) {
      return resolutionSet;
    }
    priorUp.remove(refPos[this.referencePosition.nodeNumber * 4 + 0]);
    priorUp.remove(refPos[this.referencePosition.nodeNumber * 4 + 1]);
    priorUp.remove(refPos[this.referencePosition.nodeNumber * 4 + 2]);
    priorUp.remove(refPos[this.referencePosition.nodeNumber * 4 + 3]);
    priorDown.remove(refPos[this.referencePosition.nodeNumber * 4 + 0]);
    priorDown.remove(refPos[this.referencePosition.nodeNumber * 4 + 1]);
    priorDown.remove(refPos[this.referencePosition.nodeNumber * 4 + 2]);
    priorDown.remove(refPos[this.referencePosition.nodeNumber * 4 + 3]);
    LinkedList<ReferencePosition> linkedRef=new LinkedList<ReferencePosition>();
    while (priorDown.size() != 0) {
      if (priorDown.peek().x < this.referencePosition.x + this.referencePosition.width) {
        linkedRef.add(priorDown.remove());
      }
 else {
        break;
      }
    }
    for (int i=0; i < linkedRef.size(); i++) {
      if ((linkedRef.get(i).x <= this.referencePosition.x + this.referencePosition.width) && (linkedRef.get(i).y >= this.referencePosition.y - linkedRef.get(i).height) && (linkedRef.get(i).y <= this.referencePosition.y + linkedRef.get(i).height)) {
        priorUp.remove(linkedRef.get(i));
        linkedRef.remove(i);
        i--;
      }
    }
    priorDown.addAll(linkedRef);
  }
  return resolutionSet;
}",0.9926238145416229
90305,"public MapWorker(TileCache tileCache,JobQueue<RendererJob> jobQueue,DatabaseRenderer databaseRenderer,Layer layer){
  super();
  this.tileCache=tileCache;
  this.jobQueue=jobQueue;
  this.databaseRenderer=databaseRenderer;
  this.layer=layer;
}","public MapWorker(TileCache tileCache,JobQueue<RendererJob> jobQueue,DatabaseRenderer databaseRenderer,Layer layer){
  super();
  if (DEBUG_TIMING) {
    totalTime=new AtomicLong();
    totalExecutions=new AtomicLong();
  }
 else {
    totalTime=null;
    totalExecutions=null;
  }
  this.tileCache=tileCache;
  this.jobQueue=jobQueue;
  this.databaseRenderer=databaseRenderer;
  this.layer=layer;
}",0.7601246105919003
90306,"public DisplayModel(){
  this.setTileSize();
}","public DisplayModel(){
  super();
  this.setTileSize();
}",0.8932038834951457
90307,"public RenderThemeBuilder(GraphicFactory graphicFactory,DisplayModel displayModel1,String elementName,Attributes attributes) throws SAXException {
  this.baseStrokeWidth=1f;
  this.baseTextSize=1f;
  this.mapBackground=graphicFactory.createColor(Color.WHITE);
  extractValues(graphicFactory,elementName,attributes);
}","public RenderThemeBuilder(GraphicFactory graphicFactory,String elementName,Attributes attributes) throws SAXException {
  this.baseStrokeWidth=1f;
  this.baseTextSize=1f;
  this.mapBackground=graphicFactory.createColor(Color.WHITE);
  extractValues(graphicFactory,elementName,attributes);
}",0.9555189456342668
90308,"@Override public void startElement(String uri,String localName,String qName,Attributes attributes) throws SAXException {
  try {
    if (""String_Node_Str"".equals(qName)) {
      checkState(qName,Element.RENDER_THEME);
      this.renderTheme=new RenderThemeBuilder(this.graphicFactory,this.displayModel,qName,attributes).build();
    }
 else     if (ELEMENT_NAME_RULE.equals(qName)) {
      checkState(qName,Element.RULE);
      Rule rule=new RuleBuilder(qName,attributes,this.ruleStack).build();
      if (!this.ruleStack.empty()) {
        this.currentRule.addSubRule(rule);
      }
      this.currentRule=rule;
      this.ruleStack.push(this.currentRule);
    }
 else     if (""String_Node_Str"".equals(qName)) {
      checkState(qName,Element.RENDERING_INSTRUCTION);
      Area area=new AreaBuilder(this.graphicFactory,this.displayModel,qName,attributes,this.level++,this.relativePathPrefix).build();
      this.currentRule.addRenderingInstruction(area);
    }
 else     if (""String_Node_Str"".equals(qName)) {
      checkState(qName,Element.RENDERING_INSTRUCTION);
      Caption caption=new CaptionBuilder(this.graphicFactory,this.displayModel,qName,attributes).build();
      this.currentRule.addRenderingInstruction(caption);
    }
 else     if (""String_Node_Str"".equals(qName)) {
      checkState(qName,Element.RENDERING_INSTRUCTION);
      Circle circle=new CircleBuilder(this.graphicFactory,this.displayModel,qName,attributes,this.level++).build();
      this.currentRule.addRenderingInstruction(circle);
    }
 else     if (""String_Node_Str"".equals(qName)) {
      checkState(qName,Element.RENDERING_INSTRUCTION);
      Line line=new LineBuilder(this.graphicFactory,this.displayModel,qName,attributes,this.level++,this.relativePathPrefix).build();
      this.currentRule.addRenderingInstruction(line);
    }
 else     if (""String_Node_Str"".equals(qName)) {
      checkState(qName,Element.RENDERING_INSTRUCTION);
      LineSymbol lineSymbol=new LineSymbolBuilder(this.graphicFactory,this.displayModel,qName,attributes,this.relativePathPrefix).build();
      this.currentRule.addRenderingInstruction(lineSymbol);
    }
 else     if (""String_Node_Str"".equals(qName)) {
      checkState(qName,Element.RENDERING_INSTRUCTION);
      PathText pathText=new PathTextBuilder(this.graphicFactory,this.displayModel,qName,attributes).build();
      this.currentRule.addRenderingInstruction(pathText);
    }
 else     if (""String_Node_Str"".equals(qName)) {
      checkState(qName,Element.RENDERING_INSTRUCTION);
      Symbol symbol=new SymbolBuilder(this.graphicFactory,this.displayModel,qName,attributes,this.relativePathPrefix).build();
      this.currentRule.addRenderingInstruction(symbol);
    }
 else {
      throw new SAXException(""String_Node_Str"" + qName);
    }
  }
 catch (  IOException e) {
    LOGGER.warning(""String_Node_Str"" + e.getMessage());
  }
}","@Override public void startElement(String uri,String localName,String qName,Attributes attributes) throws SAXException {
  try {
    if (""String_Node_Str"".equals(qName)) {
      checkState(qName,Element.RENDER_THEME);
      this.renderTheme=new RenderThemeBuilder(this.graphicFactory,qName,attributes).build();
    }
 else     if (ELEMENT_NAME_RULE.equals(qName)) {
      checkState(qName,Element.RULE);
      Rule rule=new RuleBuilder(qName,attributes,this.ruleStack).build();
      if (!this.ruleStack.empty()) {
        this.currentRule.addSubRule(rule);
      }
      this.currentRule=rule;
      this.ruleStack.push(this.currentRule);
    }
 else     if (""String_Node_Str"".equals(qName)) {
      checkState(qName,Element.RENDERING_INSTRUCTION);
      Area area=new AreaBuilder(this.graphicFactory,this.displayModel,qName,attributes,this.level++,this.relativePathPrefix).build();
      this.currentRule.addRenderingInstruction(area);
    }
 else     if (""String_Node_Str"".equals(qName)) {
      checkState(qName,Element.RENDERING_INSTRUCTION);
      Caption caption=new CaptionBuilder(this.graphicFactory,this.displayModel,qName,attributes).build();
      this.currentRule.addRenderingInstruction(caption);
    }
 else     if (""String_Node_Str"".equals(qName)) {
      checkState(qName,Element.RENDERING_INSTRUCTION);
      Circle circle=new CircleBuilder(this.graphicFactory,this.displayModel,qName,attributes,this.level++).build();
      this.currentRule.addRenderingInstruction(circle);
    }
 else     if (""String_Node_Str"".equals(qName)) {
      checkState(qName,Element.RENDERING_INSTRUCTION);
      Line line=new LineBuilder(this.graphicFactory,this.displayModel,qName,attributes,this.level++,this.relativePathPrefix).build();
      this.currentRule.addRenderingInstruction(line);
    }
 else     if (""String_Node_Str"".equals(qName)) {
      checkState(qName,Element.RENDERING_INSTRUCTION);
      LineSymbol lineSymbol=new LineSymbolBuilder(this.graphicFactory,this.displayModel,qName,attributes,this.relativePathPrefix).build();
      this.currentRule.addRenderingInstruction(lineSymbol);
    }
 else     if (""String_Node_Str"".equals(qName)) {
      checkState(qName,Element.RENDERING_INSTRUCTION);
      PathText pathText=new PathTextBuilder(this.graphicFactory,this.displayModel,qName,attributes).build();
      this.currentRule.addRenderingInstruction(pathText);
    }
 else     if (""String_Node_Str"".equals(qName)) {
      checkState(qName,Element.RENDERING_INSTRUCTION);
      Symbol symbol=new SymbolBuilder(this.graphicFactory,this.displayModel,qName,attributes,this.relativePathPrefix).build();
      this.currentRule.addRenderingInstruction(symbol);
    }
 else {
      throw new SAXException(""String_Node_Str"" + qName);
    }
  }
 catch (  IOException e) {
    LOGGER.warning(""String_Node_Str"" + e.getMessage());
  }
}",0.9968398876404494
90309,"@Override public void draw(BoundingBox boundingBox,byte zoomLevel,Canvas canvas,Point topLeftPoint){
  List<TilePosition> tilePositions=LayerUtil.getTilePositions(boundingBox,zoomLevel,topLeftPoint,this.displayModel.getTileSize());
  if (!isTransparent) {
    canvas.fillColor(this.displayModel.getBackgroundColor());
  }
  for (int i=tilePositions.size() - 1; i >= 0; --i) {
    TilePosition tilePosition=tilePositions.get(i);
    Point point=tilePosition.point;
    Tile tile=tilePosition.tile;
    Bitmap bitmap=this.tileCache.get(createJob(tile));
    if (bitmap == null) {
      this.jobQueue.add(createJob(tile));
      drawParentTileBitmap(canvas,point,tile);
    }
 else {
      canvas.drawBitmap(bitmap,(int)Math.round(point.x),(int)Math.round(point.y));
      bitmap.decrementRefCount();
    }
  }
  this.jobQueue.notifyWorkers();
}","@Override public void draw(BoundingBox boundingBox,byte zoomLevel,Canvas canvas,Point topLeftPoint){
  List<TilePosition> tilePositions=LayerUtil.getTilePositions(boundingBox,zoomLevel,topLeftPoint,this.displayModel.getTileSize());
  canvas.resetClip();
  if (!isTransparent) {
    canvas.fillColor(this.displayModel.getBackgroundColor());
  }
  for (int i=tilePositions.size() - 1; i >= 0; --i) {
    TilePosition tilePosition=tilePositions.get(i);
    Point point=tilePosition.point;
    Tile tile=tilePosition.tile;
    Bitmap bitmap=this.tileCache.get(createJob(tile));
    if (bitmap == null) {
      this.jobQueue.add(createJob(tile));
      drawParentTileBitmap(canvas,point,tile);
    }
 else {
      canvas.drawBitmap(bitmap,(int)Math.round(point.x),(int)Math.round(point.y));
      bitmap.decrementRefCount();
    }
  }
  this.jobQueue.notifyWorkers();
}",0.9871043376318874
90310,"/** 
 * Get the number of tiles that can be stored on the file system
 * @param directory where the cache will reside
 * @param fileSize average size of tile to be cached
 * @return number of tiles that can be stored without running out of space
 */
@SuppressWarnings(""String_Node_Str"") @TargetApi(18) public static long getAvailableCacheSlots(String directory,int fileSize){
  StatFs statfs=new StatFs(directory);
  if (android.os.Build.VERSION.SDK_INT >= 18) {
    return statfs.getAvailableBytes() / fileSize;
  }
  int result=statfs.getAvailableBlocks() / (fileSize / statfs.getBlockSize());
  return result;
}","/** 
 * Get the number of tiles that can be stored on the file system
 * @param directory where the cache will reside
 * @param fileSize average size of tile to be cached
 * @return number of tiles that can be stored without running out of space
 */
@SuppressWarnings(""String_Node_Str"") @TargetApi(18) public static long getAvailableCacheSlots(String directory,int fileSize){
  StatFs statfs=new StatFs(directory);
  if (android.os.Build.VERSION.SDK_INT >= 18) {
    return statfs.getAvailableBytes() / fileSize;
  }
  int blocksPerFile=Math.max(fileSize / statfs.getBlockSize(),1);
  return statfs.getAvailableBlocks() / blocksPerFile;
}",0.8961661341853036
90311,"/** 
 * Utility function to create a two-level tile cache with the right size. When the cache is created we do not actually know the size of the mapview, so the screenRatio is an approximation of the required size
 * @param c              the Android context
 * @param id             name for the storage directory
 * @param tileSize       tile size
 * @param screenRatio    part of the screen the view takes up
 * @param overdraw       overdraw allowance
 * @return a new cache created on the external storage
 */
public static TileCache createTileCache(Context c,String id,int tileSize,float screenRatio,double overdraw){
  int cacheSize=(int)Math.round(AndroidUtil.getMinimumCacheSize(c,tileSize,overdraw,screenRatio));
  return createExternalStorageTileCache(c,id,cacheSize,tileSize);
}","/** 
 * Utility function to create a two-level tile cache with the right size. When the cache is created we do not actually know the size of the mapview, so the screenRatio is an approximation of the required size
 * @param c              the Android context
 * @param id             name for the storage directory
 * @param tileSize       tile size
 * @param screenRatio    part of the screen the view takes up
 * @param overdraw       overdraw allowance
 * @return a new cache created on the external storage
 */
public static TileCache createTileCache(Context c,String id,int tileSize,float screenRatio,double overdraw){
  int cacheSize=Math.round(AndroidUtil.getMinimumCacheSize(c,tileSize,overdraw,screenRatio));
  return createExternalStorageTileCache(c,id,cacheSize,tileSize);
}",0.9968253968253968
90312,"/** 
 * @see List#add(Object)
 */
public synchronized void add(Layer layer){
  checkIsNull(layer);
  layer.setDisplayModel(this.displayModel);
  this.layersList.add(layer);
  layer.assign(this.redrawer);
}","/** 
 * @see List#add(Object)
 */
public synchronized void add(Layer layer){
  checkIsNull(layer);
  layer.setDisplayModel(this.displayModel);
  this.layersList.add(layer);
  layer.assign(this.redrawer);
  this.redrawer.redrawLayers();
}",0.9276018099547512
90313,"/** 
 * @see List#addAll(int,Collection)
 */
public synchronized void addAll(int index,Collection<Layer> layers){
  checkIsNull(layers);
  this.layersList.addAll(index,layers);
  for (  Layer layer : layers) {
    layer.setDisplayModel(this.displayModel);
    layer.assign(this.redrawer);
  }
}","/** 
 * @see List#addAll(int,Collection)
 */
public synchronized void addAll(int index,Collection<Layer> layers){
  checkIsNull(layers);
  this.layersList.addAll(index,layers);
  for (  Layer layer : layers) {
    layer.setDisplayModel(this.displayModel);
    layer.assign(this.redrawer);
  }
  this.redrawer.redrawLayers();
}",0.9483870967741936
90314,"/** 
 * @see List#clear()
 */
public synchronized void clear(){
  for (  Layer layer : this.layersList) {
    layer.unassign();
  }
  this.layersList.clear();
}","/** 
 * @see List#clear()
 */
public synchronized void clear(){
  for (  Layer layer : this.layersList) {
    layer.unassign();
  }
  this.layersList.clear();
  this.redrawer.redrawLayers();
}",0.9090909090909092
90315,"/** 
 * @see List#remove(Object)
 */
public synchronized boolean remove(Layer layer){
  checkIsNull(layer);
  if (this.layersList.remove(layer)) {
    layer.unassign();
    return true;
  }
  return false;
}","/** 
 * @see List#remove(Object)
 */
public synchronized boolean remove(Layer layer){
  checkIsNull(layer);
  if (this.layersList.remove(layer)) {
    layer.unassign();
    this.redrawer.redrawLayers();
    return true;
  }
  return false;
}",0.9241071428571428
90316,"@Override public void renderArea(Paint fill,Paint stroke,int level){
  List<ShapePaintContainer> list=this.drawingLayers.get(level);
  list.add(new ShapePaintContainer(this.shapeContainer,fill));
  list.add(new ShapePaintContainer(this.shapeContainer,stroke));
}","@Override public void renderArea(Paint fill,Paint stroke,int level){
  List<ShapePaintContainer> list=this.drawingLayers.get(level);
  list.add(new ShapePaintContainer(this.shapeContainer,stroke));
  list.add(new ShapePaintContainer(this.shapeContainer,fill));
}",0.7519083969465649
90317,"public static Point getTopLeftPoint(MapPosition mapPosition,Dimension canvasDimension){
  LatLong centerPoint=mapPosition.latLong;
  byte zoomLevel=mapPosition.zoomLevel;
  int halfCanvasWidth=canvasDimension.width / 2;
  int halfCanvasHeight=canvasDimension.height / 2;
  double pixelX=MercatorProjection.longitudeToPixelX(centerPoint.longitude,zoomLevel) - halfCanvasWidth;
  double pixelY=MercatorProjection.latitudeToPixelY(centerPoint.latitude,zoomLevel) - halfCanvasHeight;
  return new Point(pixelX,pixelY);
}","public static Point getTopLeftPoint(MapPosition mapPosition,Dimension canvasDimension){
  LatLong centerPoint=mapPosition.latLong;
  byte zoomLevel=mapPosition.zoomLevel;
  int halfCanvasWidth=canvasDimension.width / 2;
  int halfCanvasHeight=canvasDimension.height / 2;
  double pixelX=Math.round(MercatorProjection.longitudeToPixelX(centerPoint.longitude,zoomLevel));
  double pixelY=Math.round(MercatorProjection.latitudeToPixelY(centerPoint.latitude,zoomLevel));
  return new Point((int)pixelX - halfCanvasWidth,(int)pixelY - halfCanvasHeight);
}",0.8705440900562852
90318,"@Override protected void init(){
  super.init();
  this.mapView2.getModel().mapViewPosition.setZoomLevel((byte)12);
  this.observer=new MapViewPositionObserver(this.mapView.getModel().mapViewPosition,this.mapView2.getModel().mapViewPosition){
    Polyline lastLine;
    @Override protected void setCenter(){
      super.setCenter();
      BoundingBox bbox=MapPositionUtil.getBoundingBox(DualOverviewMapViewer.this.mapView.getModel().mapViewPosition.getMapPosition(),DualOverviewMapViewer.this.mapView.getDimension());
      Paint paintStroke=Utils.createPaint(AndroidGraphicFactory.INSTANCE.createColor(Color.RED),2,Style.STROKE);
      Polyline polygon=new Polyline(paintStroke);
      polygon.getLatLongs().add(new LatLong(bbox.minLatitude,bbox.minLongitude));
      polygon.getLatLongs().add(new LatLong(bbox.minLatitude,bbox.maxLongitude));
      polygon.getLatLongs().add(new LatLong(bbox.maxLatitude,bbox.maxLongitude));
      polygon.getLatLongs().add(new LatLong(bbox.maxLatitude,bbox.minLongitude));
      polygon.getLatLongs().add(new LatLong(bbox.minLatitude,bbox.minLongitude));
      if (this.lastLine != null) {
        DualOverviewMapViewer.this.mapView2.getLayerManager().getLayers().remove(this.lastLine);
      }
      DualOverviewMapViewer.this.mapView2.getLayerManager().getLayers().add(polygon);
      this.lastLine=polygon;
    }
    @Override protected void setZoom(){
    }
  }
;
}","@Override protected void init(){
  super.init();
  this.mapView2.getModel().mapViewPosition.setZoomLevel((byte)12);
  this.observer=new MapViewPositionObserver(this.mapView.getModel().mapViewPosition,this.mapView2.getModel().mapViewPosition){
    Polyline lastLine;
    @Override protected void setCenter(){
      super.setCenter();
      BoundingBox bbox=MapPositionUtil.getBoundingBox(DualOverviewMapViewer.this.mapView.getModel().mapViewPosition.getMapPosition(),DualOverviewMapViewer.this.mapView.getDimension());
      Paint paintStroke=Utils.createPaint(AndroidGraphicFactory.INSTANCE.createColor(Color.RED),2,Style.STROKE);
      Polyline polygon=new Polyline(paintStroke,AndroidGraphicFactory.INSTANCE);
      polygon.getLatLongs().add(new LatLong(bbox.minLatitude,bbox.minLongitude));
      polygon.getLatLongs().add(new LatLong(bbox.minLatitude,bbox.maxLongitude));
      polygon.getLatLongs().add(new LatLong(bbox.maxLatitude,bbox.maxLongitude));
      polygon.getLatLongs().add(new LatLong(bbox.maxLatitude,bbox.minLongitude));
      polygon.getLatLongs().add(new LatLong(bbox.minLatitude,bbox.minLongitude));
      if (this.lastLine != null) {
        DualOverviewMapViewer.this.mapView2.getLayerManager().getLayers().remove(this.lastLine);
      }
      DualOverviewMapViewer.this.mapView2.getLayerManager().getLayers().add(polygon);
      this.lastLine=polygon;
    }
    @Override protected void setZoom(){
    }
  }
;
}",0.9890883491728264
90319,"@Override protected void setCenter(){
  super.setCenter();
  BoundingBox bbox=MapPositionUtil.getBoundingBox(DualOverviewMapViewer.this.mapView.getModel().mapViewPosition.getMapPosition(),DualOverviewMapViewer.this.mapView.getDimension());
  Paint paintStroke=Utils.createPaint(AndroidGraphicFactory.INSTANCE.createColor(Color.RED),2,Style.STROKE);
  Polyline polygon=new Polyline(paintStroke);
  polygon.getLatLongs().add(new LatLong(bbox.minLatitude,bbox.minLongitude));
  polygon.getLatLongs().add(new LatLong(bbox.minLatitude,bbox.maxLongitude));
  polygon.getLatLongs().add(new LatLong(bbox.maxLatitude,bbox.maxLongitude));
  polygon.getLatLongs().add(new LatLong(bbox.maxLatitude,bbox.minLongitude));
  polygon.getLatLongs().add(new LatLong(bbox.minLatitude,bbox.minLongitude));
  if (this.lastLine != null) {
    DualOverviewMapViewer.this.mapView2.getLayerManager().getLayers().remove(this.lastLine);
  }
  DualOverviewMapViewer.this.mapView2.getLayerManager().getLayers().add(polygon);
  this.lastLine=polygon;
}","@Override protected void setCenter(){
  super.setCenter();
  BoundingBox bbox=MapPositionUtil.getBoundingBox(DualOverviewMapViewer.this.mapView.getModel().mapViewPosition.getMapPosition(),DualOverviewMapViewer.this.mapView.getDimension());
  Paint paintStroke=Utils.createPaint(AndroidGraphicFactory.INSTANCE.createColor(Color.RED),2,Style.STROKE);
  Polyline polygon=new Polyline(paintStroke,AndroidGraphicFactory.INSTANCE);
  polygon.getLatLongs().add(new LatLong(bbox.minLatitude,bbox.minLongitude));
  polygon.getLatLongs().add(new LatLong(bbox.minLatitude,bbox.maxLongitude));
  polygon.getLatLongs().add(new LatLong(bbox.maxLatitude,bbox.maxLongitude));
  polygon.getLatLongs().add(new LatLong(bbox.maxLatitude,bbox.minLongitude));
  polygon.getLatLongs().add(new LatLong(bbox.minLatitude,bbox.minLongitude));
  if (this.lastLine != null) {
    DualOverviewMapViewer.this.mapView2.getLayerManager().getLayers().remove(this.lastLine);
  }
  DualOverviewMapViewer.this.mapView2.getLayerManager().getLayers().add(polygon);
  this.lastLine=polygon;
}",0.9850458273034248
90320,"protected void addOverlayLayers(List<Layer> layers){
  LatLong latLong1=new LatLong(52.5,13.4);
  LatLong latLong2=new LatLong(52.499,13.402);
  LatLong latLong3=new LatLong(52.503,13.399);
  LatLong latLong4=new LatLong(52.51,13.401);
  LatLong latLong5=new LatLong(52.508,13.408);
  Polyline polyline=new Polyline(Utils.createPaint(AndroidGraphicFactory.INSTANCE.createColor(Color.BLUE),8,Style.STROKE));
  List<LatLong> latLongs=polyline.getLatLongs();
  latLongs.add(latLong1);
  latLongs.add(latLong2);
  latLongs.add(latLong3);
  Paint paintFill=Utils.createPaint(AndroidGraphicFactory.INSTANCE.createColor(Color.GREEN),2,Style.STROKE);
  Paint paintStroke=Utils.createPaint(AndroidGraphicFactory.INSTANCE.createColor(Color.BLACK),2,Style.STROKE);
  Polygon polygon=new Polygon(paintFill,paintStroke,AndroidGraphicFactory.INSTANCE);
  latLongs=polygon.getLatLongs();
  latLongs.add(latLong2);
  latLongs.add(latLong3);
  latLongs.add(latLong4);
  latLongs.add(latLong5);
  Marker marker1=Utils.createMarker(this,R.drawable.marker_red,latLong1);
  Circle circle=new Circle(latLong3,300,Utils.createPaint(AndroidGraphicFactory.INSTANCE.createColor(Color.WHITE),0,Style.FILL),null);
  layers.add(polyline);
  layers.add(polygon);
  layers.add(circle);
  layers.add(marker1);
}","protected void addOverlayLayers(List<Layer> layers){
  LatLong latLong1=new LatLong(52.5,13.4);
  LatLong latLong2=new LatLong(52.499,13.402);
  LatLong latLong3=new LatLong(52.503,13.399);
  LatLong latLong4=new LatLong(52.51,13.401);
  LatLong latLong5=new LatLong(52.508,13.408);
  Polyline polyline=new Polyline(Utils.createPaint(AndroidGraphicFactory.INSTANCE.createColor(Color.BLUE),8,Style.STROKE),AndroidGraphicFactory.INSTANCE);
  List<LatLong> latLongs=polyline.getLatLongs();
  latLongs.add(latLong1);
  latLongs.add(latLong2);
  latLongs.add(latLong3);
  Paint paintFill=Utils.createPaint(AndroidGraphicFactory.INSTANCE.createColor(Color.GREEN),2,Style.STROKE);
  Paint paintStroke=Utils.createPaint(AndroidGraphicFactory.INSTANCE.createColor(Color.BLACK),2,Style.STROKE);
  Polygon polygon=new Polygon(paintFill,paintStroke,AndroidGraphicFactory.INSTANCE);
  latLongs=polygon.getLatLongs();
  latLongs.add(latLong2);
  latLongs.add(latLong3);
  latLongs.add(latLong4);
  latLongs.add(latLong5);
  Marker marker1=Utils.createMarker(this,R.drawable.marker_red,latLong1);
  Circle circle=new Circle(latLong3,300,Utils.createPaint(AndroidGraphicFactory.INSTANCE.createColor(Color.WHITE),0,Style.FILL),null);
  layers.add(polyline);
  layers.add(polygon);
  layers.add(circle);
  layers.add(marker1);
}",0.9880262649671688
90321,"private TileCache createTileCache(){
  TileCache firstLevelTileCache=new InMemoryTileCache(32);
  File cacheDirectory=getDir(""String_Node_Str"",MODE_PRIVATE);
  TileCache secondLevelTileCache=new FileSystemTileCache(1024,cacheDirectory,AndroidGraphics.INSTANCE);
  return new TwoLevelTileCache(firstLevelTileCache,secondLevelTileCache);
}","private TileCache createTileCache(){
  TileCache firstLevelTileCache=new InMemoryTileCache(64);
  File cacheDirectory=getDir(""String_Node_Str"",MODE_PRIVATE);
  TileCache secondLevelTileCache=new FileSystemTileCache(1024,cacheDirectory,AndroidGraphics.INSTANCE);
  return new TwoLevelTileCache(firstLevelTileCache,secondLevelTileCache);
}",0.9940652818991098
90322,"private static Layer createTileDownloadLayer(TileCache tileCache,MapViewPosition mapViewPosition,LayerManager layerManager){
  TileSource tileSource=OpenStreetMapMapnik.INSTANCE;
  return new TileDownloadLayer(tileCache,mapViewPosition,tileSource,layerManager,GRAPHIC_FACTORY);
}","private static Layer createTileDownloadLayer(TileCache tileCache,MapViewPosition mapViewPosition,LayerManager layerManager){
  TileSource tileSource=OpenStreetMapMapnik.INSTANCE;
  TileDownloadLayer tileDownloadLayer=new TileDownloadLayer(tileCache,mapViewPosition,tileSource,layerManager,GRAPHIC_FACTORY);
  tileDownloadLayer.start();
  return tileDownloadLayer;
}",0.84472049689441
90323,"@Override public void drawCircle(int x,int y,int radius,Paint paint){
  AwtPaint awtPaint=AwtGraphicFactory.getAwtPaint(paint);
  setColorAndStroke(awtPaint);
  int doubleRadius=radius * 2;
  Style style=awtPaint.style;
switch (style) {
case FILL:
    this.graphics2D.fillOval(x - radius,y - radius,doubleRadius,doubleRadius);
  return;
case STROKE:
this.graphics2D.drawOval(x - radius,y - radius,doubleRadius,doubleRadius);
return;
}
throw new IllegalArgumentException(""String_Node_Str"" + style);
}","@Override public void drawCircle(int x,int y,int radius,Paint paint){
  AwtPaint awtPaint=AwtGraphicFactory.getAwtPaint(paint);
  setColorAndStroke(awtPaint);
  int doubleRadius=radius * 2;
  Style style=awtPaint.style;
switch (style) {
case FILL:
    this.graphics2D.fillOval(x - radius,y - radius,doubleRadius,doubleRadius);
  return;
case STROKE:
this.graphics2D.drawOval(x - radius,y - radius,doubleRadius,doubleRadius);
return;
}
throw new IllegalArgumentException(UNKNOWN_STYLE + style);
}",0.9758551307847082
90324,"@Override public void drawPath(Path path,Paint paint){
  AwtPaint awtPaint=AwtGraphicFactory.getAwtPaint(paint);
  AwtPath awtPath=AwtGraphicFactory.getAwtPath(path);
  setColorAndStroke(awtPaint);
  this.graphics2D.setPaint(awtPaint.texturePaint);
  Style style=awtPaint.style;
switch (style) {
case FILL:
    this.graphics2D.fill(awtPath.path2D);
  return;
case STROKE:
this.graphics2D.draw(awtPath.path2D);
return;
}
throw new IllegalArgumentException(""String_Node_Str"" + style);
}","@Override public void drawPath(Path path,Paint paint){
  AwtPaint awtPaint=AwtGraphicFactory.getAwtPaint(paint);
  AwtPath awtPath=AwtGraphicFactory.getAwtPath(path);
  setColorAndStroke(awtPaint);
  this.graphics2D.setPaint(awtPaint.texturePaint);
  Style style=awtPaint.style;
switch (style) {
case FILL:
    this.graphics2D.fill(awtPath.path2D);
  return;
case STROKE:
this.graphics2D.draw(awtPath.path2D);
return;
}
throw new IllegalArgumentException(UNKNOWN_STYLE + style);
}",0.975103734439834
90325,"static AwtPaint getAwtPaint(Paint paint){
  return ((AwtPaint)paint);
}","static AwtPaint getAwtPaint(Paint paint){
  return (AwtPaint)paint;
}",0.9857142857142858
90326,"static AwtPath getAwtPath(Path path){
  return ((AwtPath)path);
}","static AwtPath getAwtPath(Path path){
  return (AwtPath)path;
}",0.984375
90327,"public TileDownloadLayer(TileCache tileCache,MapViewPosition mapViewPosition,TileSource tileSource,LayerManager layerManager,GraphicFactory graphicFactory){
  super(tileCache,mapViewPosition,graphicFactory);
  if (tileSource == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
 else   if (layerManager == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  this.tileSource=tileSource;
  int numberOfDownloadThreads=Math.min(tileSource.getParallelRequestsLimit(),DOWNLOAD_THREADS_MAX);
  this.tileDownloadThreads=new TileDownloadThread[numberOfDownloadThreads];
  for (int i=0; i < numberOfDownloadThreads; ++i) {
    TileDownloadThread tileDownloadThread=new TileDownloadThread(tileCache,this.jobQueue,layerManager,graphicFactory);
    tileDownloadThread.start();
    this.tileDownloadThreads[i]=tileDownloadThread;
  }
}","public TileDownloadLayer(TileCache tileCache,MapViewPosition mapViewPosition,TileSource tileSource,LayerManager layerManager,GraphicFactory graphicFactory){
  super(tileCache,mapViewPosition,graphicFactory);
  if (tileSource == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
 else   if (layerManager == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  this.tileSource=tileSource;
  int numberOfDownloadThreads=Math.min(tileSource.getParallelRequestsLimit(),DOWNLOAD_THREADS_MAX);
  this.tileDownloadThreads=new TileDownloadThread[numberOfDownloadThreads];
  for (int i=0; i < numberOfDownloadThreads; ++i) {
    this.tileDownloadThreads[i]=new TileDownloadThread(tileCache,this.jobQueue,layerManager,graphicFactory);
  }
}",0.9094247246022032
90328,"@Override public synchronized void draw(BoundingBox boundingBox,byte zoomLevel,Canvas canvas,Point canvasPosition){
  if (this.latLong == null || this.bitmap == null) {
    return;
  }
  double pixelX=MercatorProjection.longitudeToPixelX(this.latLong.longitude,zoomLevel);
  double pixelY=MercatorProjection.latitudeToPixelY(this.latLong.latitude,zoomLevel);
  int left=(int)(pixelX - canvasPosition.x + this.dx - (this.bitmap.getWidth() / 2));
  int top=(int)(pixelY - canvasPosition.y + this.dy - (this.bitmap.getHeight() / 2));
  int right=left + this.bitmap.getWidth();
  int bottom=top + this.bitmap.getHeight();
  Rectangle bitmapRectangle=new Rectangle(left,top,right,bottom);
  Rectangle canvasRectangle=new Rectangle(0,0,canvas.getWidth(),canvas.getHeight());
  if (!canvasRectangle.intersects(bitmapRectangle)) {
    return;
  }
  canvas.drawBitmap(this.bitmap,left,top);
}","@Override public synchronized void draw(BoundingBox boundingBox,byte zoomLevel,Canvas canvas,Point canvasPosition){
  if (this.latLong == null || this.bitmap == null) {
    return;
  }
  double pixelX=MercatorProjection.longitudeToPixelX(this.latLong.longitude,zoomLevel);
  double pixelY=MercatorProjection.latitudeToPixelY(this.latLong.latitude,zoomLevel);
  int halfBitmapWidth=this.bitmap.getWidth() / 2;
  int halfBitmapHeight=this.bitmap.getHeight() / 2;
  int left=(int)(pixelX - canvasPosition.x - halfBitmapWidth + this.dx);
  int top=(int)(pixelY - canvasPosition.y - halfBitmapHeight + this.dy);
  int right=left + this.bitmap.getWidth();
  int bottom=top + this.bitmap.getHeight();
  Rectangle bitmapRectangle=new Rectangle(left,top,right,bottom);
  Rectangle canvasRectangle=new Rectangle(0,0,canvas.getWidth(),canvas.getHeight());
  if (!canvasRectangle.intersects(bitmapRectangle)) {
    return;
  }
  canvas.drawBitmap(this.bitmap,left,top);
}",0.8371335504885994
90329,"@Override public void destroy(){
  this.mapWorker.interrupt();
  this.mapDatabase.closeFile();
  super.destroy();
}","@Override public void destroy(){
  new DestroyThread(this.mapWorker,this.mapDatabase).start();
  super.destroy();
}",0.7913043478260869
90330,"private MapReadResult processBlocks(QueryParameters queryParameters,SubFileParameter subFileParameter) throws IOException {
  boolean queryIsWater=true;
  boolean queryReadWaterInfo=false;
  MapReadResultBuilder mapReadResultBuilder=new MapReadResultBuilder();
  for (long row=queryParameters.fromBlockY; row <= queryParameters.toBlockY; ++row) {
    for (long column=queryParameters.fromBlockX; column <= queryParameters.toBlockX; ++column) {
      long blockNumber=row * subFileParameter.blocksWidth + column;
      long currentBlockIndexEntry=this.databaseIndexCache.getIndexEntry(subFileParameter,blockNumber);
      if (queryIsWater) {
        queryIsWater&=(currentBlockIndexEntry & BITMASK_INDEX_WATER) != 0;
        queryReadWaterInfo=true;
      }
      long currentBlockPointer=currentBlockIndexEntry & BITMASK_INDEX_OFFSET;
      if (currentBlockPointer < 1 || currentBlockPointer > subFileParameter.subFileSize) {
        LOGGER.warning(""String_Node_Str"" + currentBlockPointer);
        LOGGER.warning(""String_Node_Str"" + subFileParameter.subFileSize);
        return null;
      }
      long nextBlockPointer;
      if (blockNumber + 1 == subFileParameter.numberOfBlocks) {
        nextBlockPointer=subFileParameter.subFileSize;
      }
 else {
        nextBlockPointer=this.databaseIndexCache.getIndexEntry(subFileParameter,blockNumber + 1) & BITMASK_INDEX_OFFSET;
        if (nextBlockPointer > subFileParameter.subFileSize) {
          LOGGER.warning(""String_Node_Str"" + nextBlockPointer);
          LOGGER.warning(""String_Node_Str"" + subFileParameter.subFileSize);
          return null;
        }
      }
      int currentBlockSize=(int)(nextBlockPointer - currentBlockPointer);
      if (currentBlockSize < 0) {
        LOGGER.warning(""String_Node_Str"" + currentBlockSize);
        return null;
      }
 else       if (currentBlockSize == 0) {
        continue;
      }
 else       if (currentBlockSize > ReadBuffer.MAXIMUM_BUFFER_SIZE) {
        LOGGER.warning(""String_Node_Str"" + currentBlockSize);
        continue;
      }
 else       if (currentBlockPointer + currentBlockSize > this.fileSize) {
        LOGGER.warning(""String_Node_Str"" + currentBlockSize);
        return null;
      }
      this.inputFile.seek(subFileParameter.startAddress + currentBlockPointer);
      if (!this.readBuffer.readFromFile(currentBlockSize)) {
        LOGGER.warning(""String_Node_Str"" + currentBlockSize);
        return null;
      }
      this.tileLatitude=MercatorProjection.tileYToLatitude(subFileParameter.boundaryTileTop + row,subFileParameter.baseZoomLevel);
      this.tileLongitude=MercatorProjection.tileXToLongitude(subFileParameter.boundaryTileLeft + column,subFileParameter.baseZoomLevel);
      try {
        PoiWayBundle poiWayBundle=processBlock(queryParameters,subFileParameter);
        mapReadResultBuilder.add(poiWayBundle);
      }
 catch (      ArrayIndexOutOfBoundsException e) {
        LOGGER.log(Level.SEVERE,null,e);
      }
    }
  }
  if (queryIsWater && queryReadWaterInfo) {
    mapReadResultBuilder.isWater=true;
  }
  return mapReadResultBuilder.build();
}","private MapReadResult processBlocks(QueryParameters queryParameters,SubFileParameter subFileParameter) throws IOException {
  boolean queryIsWater=true;
  boolean queryReadWaterInfo=false;
  MapReadResultBuilder mapReadResultBuilder=new MapReadResultBuilder();
  for (long row=queryParameters.fromBlockY; row <= queryParameters.toBlockY; ++row) {
    for (long column=queryParameters.fromBlockX; column <= queryParameters.toBlockX; ++column) {
      long blockNumber=row * subFileParameter.blocksWidth + column;
      long currentBlockIndexEntry=this.databaseIndexCache.getIndexEntry(subFileParameter,blockNumber);
      if (queryIsWater) {
        queryIsWater&=(currentBlockIndexEntry & BITMASK_INDEX_WATER) != 0;
        queryReadWaterInfo=true;
      }
      long currentBlockPointer=currentBlockIndexEntry & BITMASK_INDEX_OFFSET;
      if (currentBlockPointer < 1 || currentBlockPointer > subFileParameter.subFileSize) {
        LOGGER.warning(""String_Node_Str"" + currentBlockPointer);
        LOGGER.warning(""String_Node_Str"" + subFileParameter.subFileSize);
        return null;
      }
      long nextBlockPointer;
      if (blockNumber + 1 == subFileParameter.numberOfBlocks) {
        nextBlockPointer=subFileParameter.subFileSize;
      }
 else {
        nextBlockPointer=this.databaseIndexCache.getIndexEntry(subFileParameter,blockNumber + 1) & BITMASK_INDEX_OFFSET;
        if (nextBlockPointer > subFileParameter.subFileSize) {
          LOGGER.warning(""String_Node_Str"" + nextBlockPointer);
          LOGGER.warning(""String_Node_Str"" + subFileParameter.subFileSize);
          return null;
        }
      }
      int currentBlockSize=(int)(nextBlockPointer - currentBlockPointer);
      if (currentBlockSize < 0) {
        LOGGER.warning(""String_Node_Str"" + currentBlockSize);
        return null;
      }
 else       if (currentBlockSize == 0) {
        continue;
      }
 else       if (currentBlockSize > ReadBuffer.MAXIMUM_BUFFER_SIZE) {
        LOGGER.warning(""String_Node_Str"" + currentBlockSize);
        continue;
      }
 else       if (currentBlockPointer + currentBlockSize > this.fileSize) {
        LOGGER.warning(""String_Node_Str"" + currentBlockSize);
        return null;
      }
      this.inputFile.seek(subFileParameter.startAddress + currentBlockPointer);
      if (!this.readBuffer.readFromFile(currentBlockSize)) {
        LOGGER.warning(""String_Node_Str"" + currentBlockSize);
        return null;
      }
      this.tileLatitude=MercatorProjection.tileYToLatitude(subFileParameter.boundaryTileTop + row,subFileParameter.baseZoomLevel);
      this.tileLongitude=MercatorProjection.tileXToLongitude(subFileParameter.boundaryTileLeft + column,subFileParameter.baseZoomLevel);
      try {
        PoiWayBundle poiWayBundle=processBlock(queryParameters,subFileParameter);
        if (poiWayBundle != null) {
          mapReadResultBuilder.add(poiWayBundle);
        }
      }
 catch (      ArrayIndexOutOfBoundsException e) {
        LOGGER.log(Level.SEVERE,null,e);
      }
    }
  }
  if (queryIsWater && queryReadWaterInfo) {
    mapReadResultBuilder.isWater=true;
  }
  return mapReadResultBuilder.build();
}",0.9923101570009611
90331,"synchronized void onSizeChanged(){
  this.width=this.mapView.getWidth();
  this.height=this.mapView.getHeight();
  this.mapViewBitmap1=Bitmap.createBitmap(this.width,this.height,Bitmap.Config.RGB_565);
  this.mapViewBitmap2=Bitmap.createBitmap(this.width,this.height,Bitmap.Config.RGB_565);
  clear();
  this.mapViewCanvas.setBitmap(this.mapViewBitmap1);
}","synchronized void onSizeChanged(){
  this.destroy();
  this.mapViewCanvas=new Canvas();
  this.width=this.mapView.getWidth();
  this.height=this.mapView.getHeight();
  this.mapViewBitmap1=Bitmap.createBitmap(this.width,this.height,Bitmap.Config.RGB_565);
  this.mapViewBitmap2=Bitmap.createBitmap(this.width,this.height,Bitmap.Config.RGB_565);
  clear();
  this.mapViewCanvas.setBitmap(this.mapViewBitmap1);
}",0.930718954248366
90332,"synchronized void destroy(){
  if (this.mapViewBitmap1 != null) {
    this.mapViewBitmap1.recycle();
  }
  if (this.mapViewBitmap2 != null) {
    this.mapViewBitmap2.recycle();
  }
}","synchronized void destroy(){
  if (this.mapViewBitmap1 != null) {
    this.mapViewBitmap1.recycle();
  }
  if (this.mapViewBitmap2 != null) {
    this.mapViewBitmap2.recycle();
  }
  this.mapViewCanvas=null;
}",0.9309462915601024
90333,"void destroy(){
  this.overlayController.interrupt();
  this.mapMover.interrupt();
  this.mapWorker.interrupt();
  this.zoomAnimator.interrupt();
  try {
    this.mapWorker.join();
  }
 catch (  InterruptedException e) {
    Thread.currentThread().interrupt();
  }
  this.frameBuffer.destroy();
  this.mapScaleBar.destroy();
  this.inMemoryTileCache.destroy();
  this.fileSystemTileCache.destroy();
  this.mapDatabase.closeFile();
}","void destroy(){
  this.overlayController.interrupt();
  this.mapMover.interrupt();
  this.mapWorker.interrupt();
  this.zoomAnimator.interrupt();
  try {
    this.mapWorker.join();
  }
 catch (  InterruptedException e) {
    Thread.currentThread().interrupt();
  }
  this.frameBuffer.destroy();
  this.mapScaleBar.destroy();
  this.inMemoryTileCache.destroy();
  this.fileSystemTileCache.destroy();
  this.databaseRenderer.destroy();
  this.mapDatabase.closeFile();
}",0.9610678531701892
90334,"/** 
 * Called when a job needs to be executed.
 * @param mapGeneratorJob the job that should be executed.
 * @param bitmap the bitmap for the generated map tile.
 * @return true if the job was executed successfully, false otherwise.
 */
public boolean executeJob(MapGeneratorJob mapGeneratorJob,android.graphics.Bitmap bitmap){
  this.currentTile=mapGeneratorJob.tile;
  XmlRenderTheme jobTheme=mapGeneratorJob.jobParameters.jobTheme;
  if (!jobTheme.equals(this.previousJobTheme)) {
    this.renderTheme=getRenderTheme(jobTheme);
    if (this.renderTheme == null) {
      this.previousJobTheme=null;
      return false;
    }
    createWayLists();
    this.previousJobTheme=jobTheme;
    this.previousZoomLevel=Byte.MIN_VALUE;
  }
  byte zoomLevel=this.currentTile.zoomLevel;
  if (zoomLevel != this.previousZoomLevel) {
    setScaleStrokeWidth(zoomLevel);
    this.previousZoomLevel=zoomLevel;
  }
  float textScale=mapGeneratorJob.jobParameters.textScale;
  if (Float.compare(textScale,this.previousTextScale) != 0) {
    this.renderTheme.scaleTextSize(textScale);
    this.previousTextScale=textScale;
  }
  if (this.mapDatabase != null) {
    MapReadResult mapReadResult=this.mapDatabase.readMapData(this.currentTile);
    processReadMapData(mapReadResult);
  }
  this.nodes=this.labelPlacement.placeLabels(this.nodes,this.pointSymbols,this.areaLabels,this.currentTile);
  this.canvasRasterer.setCanvasBitmap(bitmap);
  this.canvasRasterer.fill(this.renderTheme.getMapBackground());
  this.canvasRasterer.drawWays(this.ways);
  this.canvasRasterer.drawSymbols(this.waySymbols);
  this.canvasRasterer.drawSymbols(this.pointSymbols);
  this.canvasRasterer.drawWayNames(this.wayNames);
  this.canvasRasterer.drawNodes(this.nodes);
  this.canvasRasterer.drawNodes(this.areaLabels);
  if (mapGeneratorJob.debugSettings.drawTileFrames) {
    this.canvasRasterer.drawTileFrame();
  }
  if (mapGeneratorJob.debugSettings.drawTileCoordinates) {
    this.canvasRasterer.drawTileCoordinates(this.currentTile);
  }
  clearLists();
  return true;
}","/** 
 * Called when a job needs to be executed.
 * @param mapGeneratorJob the job that should be executed.
 * @param bitmap the bitmap for the generated map tile.
 * @return true if the job was executed successfully, false otherwise.
 */
public boolean executeJob(MapGeneratorJob mapGeneratorJob,android.graphics.Bitmap bitmap){
  this.currentTile=mapGeneratorJob.tile;
  XmlRenderTheme jobTheme=mapGeneratorJob.jobParameters.jobTheme;
  if (!jobTheme.equals(this.previousJobTheme)) {
    if (this.renderTheme != null) {
      this.renderTheme.destroy();
    }
    this.renderTheme=getRenderTheme(jobTheme);
    if (this.renderTheme == null) {
      this.previousJobTheme=null;
      return false;
    }
    createWayLists();
    this.previousJobTheme=jobTheme;
    this.previousZoomLevel=Byte.MIN_VALUE;
  }
  byte zoomLevel=this.currentTile.zoomLevel;
  if (zoomLevel != this.previousZoomLevel) {
    setScaleStrokeWidth(zoomLevel);
    this.previousZoomLevel=zoomLevel;
  }
  float textScale=mapGeneratorJob.jobParameters.textScale;
  if (Float.compare(textScale,this.previousTextScale) != 0) {
    this.renderTheme.scaleTextSize(textScale);
    this.previousTextScale=textScale;
  }
  if (this.mapDatabase != null) {
    MapReadResult mapReadResult=this.mapDatabase.readMapData(this.currentTile);
    processReadMapData(mapReadResult);
  }
  this.nodes=this.labelPlacement.placeLabels(this.nodes,this.pointSymbols,this.areaLabels,this.currentTile);
  this.canvasRasterer.setCanvasBitmap(bitmap);
  this.canvasRasterer.fill(this.renderTheme.getMapBackground());
  this.canvasRasterer.drawWays(this.ways);
  this.canvasRasterer.drawSymbols(this.waySymbols);
  this.canvasRasterer.drawSymbols(this.pointSymbols);
  this.canvasRasterer.drawWayNames(this.wayNames);
  this.canvasRasterer.drawNodes(this.nodes);
  this.canvasRasterer.drawNodes(this.areaLabels);
  if (mapGeneratorJob.debugSettings.drawTileFrames) {
    this.canvasRasterer.drawTileFrame();
  }
  if (mapGeneratorJob.debugSettings.drawTileCoordinates) {
    this.canvasRasterer.drawTileCoordinates(this.currentTile);
  }
  clearLists();
  return true;
}",0.9817219817219818
90335,"private boolean checkSize(){
  if (this.changeSizeNeeded) {
    return changeSize();
  }
  return true;
}","private boolean checkSize(){
  this.sizeChange.writeLock().lock();
  try {
    if (this.changeSizeNeeded) {
      return changeSize();
    }
    return true;
  }
  finally {
    this.sizeChange.writeLock().unlock();
  }
}",0.5337423312883436
90336,"private void recycleBitmaps(){
  recycleBitmap(this.bitmap1);
  recycleBitmap(this.bitmap2);
}","private void recycleBitmaps(){
  if (this.bitmap1 != null) {
    this.bitmap1.recycle();
    this.bitmap1=null;
  }
  if (this.bitmap2 != null) {
    this.bitmap2.recycle();
    this.bitmap2=null;
  }
  this.overlayCanvas=null;
}",0.3715170278637771
90337,"@Override protected void afterRun(){
  recycleBitmaps();
}","@Override protected void afterRun(){
  this.recycleBitmaps();
}",0.9586776859504132
90338,"private void redraw(){
  this.bitmap2.eraseColor(Color.TRANSPARENT);
  this.overlayCanvas.setBitmap(this.bitmap2);
  MapPosition mapPositionBefore=this.mapView.getMapViewPosition().getMapPosition();
  BoundingBox boundingBox=this.mapView.getMapViewPosition().getBoundingBox();
  List<Overlay> overlays=this.mapView.getOverlays();
synchronized (overlays) {
    for (    Overlay overlay : overlays) {
      overlay.draw(boundingBox,mapPositionBefore.zoomLevel,this.overlayCanvas);
    }
  }
  MapPosition mapPositionAfter=this.mapView.getMapViewPosition().getMapPosition();
synchronized (this.matrix) {
    adjustMatrix(mapPositionBefore,mapPositionAfter);
    swapBitmaps();
  }
  this.mapView.postInvalidate();
}","private void redraw(){
  if (this.overlayCanvas == null) {
    this.overlayCanvas=new Canvas();
  }
  this.bitmap2.eraseColor(Color.TRANSPARENT);
  this.overlayCanvas.setBitmap(this.bitmap2);
  MapPosition mapPositionBefore=this.mapView.getMapViewPosition().getMapPosition();
  BoundingBox boundingBox=this.mapView.getMapViewPosition().getBoundingBox();
  List<Overlay> overlays=this.mapView.getOverlays();
synchronized (overlays) {
    for (    Overlay overlay : overlays) {
      overlay.draw(boundingBox,mapPositionBefore.zoomLevel,this.overlayCanvas);
    }
  }
  MapPosition mapPositionAfter=this.mapView.getMapViewPosition().getMapPosition();
synchronized (this.matrix) {
    adjustMatrix(mapPositionBefore,mapPositionAfter);
    swapBitmaps();
  }
  this.mapView.postInvalidate();
}",0.9487008660892738
90339,"public OverlayController(MapView mapView){
  super();
  this.mapView=mapView;
  this.matrix=new Matrix();
  this.overlayCanvas=new Canvas();
  this.changeSizeNeeded=true;
}","public OverlayController(MapView mapView){
  super();
  this.mapView=mapView;
  this.matrix=new Matrix();
  this.changeSizeNeeded=true;
}",0.8867313915857605
90340,"private boolean changeSize(){
  recycleBitmaps();
  int width=this.mapView.getWidth();
  int height=this.mapView.getHeight();
  if (width > 0 && height > 0) {
    this.bitmap1=Bitmap.createBitmap(width,height,Bitmap.Config.ARGB_8888);
    this.bitmap2=Bitmap.createBitmap(width,height,Bitmap.Config.ARGB_8888);
    this.changeSizeNeeded=false;
    this.redrawNeeded=true;
    return true;
  }
  return false;
}","private boolean changeSize(){
  int newWidth=this.mapView.getWidth();
  int newHeight=this.mapView.getHeight();
  if (newWidth > 0 && newHeight > 0) {
    if (this.width == newWidth && this.height == newHeight) {
      this.changeSizeNeeded=false;
      this.redrawNeeded=false;
      return false;
    }
    recycleBitmaps();
    this.width=newWidth;
    this.height=newHeight;
    this.bitmap1=Bitmap.createBitmap(newWidth,newHeight,Bitmap.Config.ARGB_8888);
    this.bitmap2=Bitmap.createBitmap(newWidth,newHeight,Bitmap.Config.ARGB_8888);
    this.changeSizeNeeded=false;
    this.redrawNeeded=true;
    return true;
  }
  return false;
}",0.591254752851711
90341,"private void checkRedraw(){
  if (this.redrawNeeded) {
    this.redrawNeeded=false;
    redraw();
  }
}","private void checkRedraw(){
  this.sizeChange.readLock().lock();
  try {
    if (this.redrawNeeded) {
      this.redrawNeeded=false;
      redraw();
    }
  }
  finally {
    this.sizeChange.readLock().unlock();
  }
}",0.55
90342,"@Override public void setBitmapShader(org.mapsforge.map.graphics.Bitmap bitmap){
  if (bitmap == null) {
    return;
  }
  android.graphics.Bitmap androidBitmap=android.graphics.Bitmap.createBitmap(bitmap.getPixels(),bitmap.getWidth(),bitmap.getHeight(),Config.ARGB_8888);
  Shader shader=new BitmapShader(androidBitmap,TileMode.REPEAT,TileMode.REPEAT);
  this.paint.setShader(shader);
}","@Override public void setBitmapShader(org.mapsforge.map.graphics.Bitmap bitmap){
  if (bitmap == null) {
    return;
  }
  this.bitmap=bitmap;
  android.graphics.Bitmap androidBitmap=android.graphics.Bitmap.createBitmap(bitmap.getPixels(),bitmap.getWidth(),bitmap.getHeight(),Config.ARGB_8888);
  Shader shader=new BitmapShader(androidBitmap,TileMode.REPEAT,TileMode.REPEAT);
  this.paint.setShader(shader);
}",0.9723618090452262
90343,"@Override public void destroy(){
}","@Override public void destroy(){
  this.fill.destroy();
  this.stroke.destroy();
}",0.5862068965517241
90344,"@Override public void destroy(){
}","@Override public void destroy(){
  this.stroke.destroy();
}",0.7311827956989247
90345,"void scale(float scaleX,float scaleY,float pivotX,float pivotY);","void scale(float scaleX,float scaleY);",0.7450980392156863
90346,"@Override public void scale(float scaleX,float scaleY,float pivotX,float pivotY){
  this.matrix.preScale(scaleX,scaleY,pivotX,pivotY);
}","@Override public void scale(float scaleX,float scaleY){
  this.matrix.preScale(scaleX,scaleY);
}",0.8275862068965517
90347,"@Override public void scale(float scaleX,float scaleY,float pivotX,float pivotY){
  this.affineTransform.scale(scaleX,scaleY);
}","@Override public void scale(float scaleX,float scaleY){
  this.affineTransform.scale(scaleX,scaleY);
}",0.8869565217391304
90348,"private void drawParentTileBitmap(Canvas canvas,Point point,Tile tile){
  Tile cachedParentTile=getCachedParentTile(tile,4);
  if (cachedParentTile != null) {
    Bitmap bitmap=this.tileCache.get(createJob(cachedParentTile));
    if (bitmap != null) {
      long translateX=tile.getShiftX(cachedParentTile) * Tile.TILE_SIZE;
      long translateY=tile.getShiftY(cachedParentTile) * Tile.TILE_SIZE;
      byte zoomLevelDiff=(byte)(tile.zoomLevel - cachedParentTile.zoomLevel);
      float scaleFactor=(float)Math.pow(2,zoomLevelDiff);
      this.matrix.reset();
      this.matrix.scale(scaleFactor,scaleFactor);
      this.matrix.translate((float)(point.x - translateX),(float)(point.y - translateY));
      canvas.drawBitmap(bitmap,this.matrix);
    }
  }
}","private void drawParentTileBitmap(Canvas canvas,Point point,Tile tile){
  Tile cachedParentTile=getCachedParentTile(tile,4);
  if (cachedParentTile != null) {
    Bitmap bitmap=this.tileCache.get(createJob(cachedParentTile));
    if (bitmap != null) {
      long translateX=tile.getShiftX(cachedParentTile) * Tile.TILE_SIZE;
      long translateY=tile.getShiftY(cachedParentTile) * Tile.TILE_SIZE;
      byte zoomLevelDiff=(byte)(tile.zoomLevel - cachedParentTile.zoomLevel);
      float scaleFactor=(float)Math.pow(2,zoomLevelDiff);
      this.matrix.reset();
      this.matrix.translate((float)(point.x - translateX),(float)(point.y - translateY));
      this.matrix.scale(scaleFactor,scaleFactor);
      canvas.drawBitmap(bitmap,this.matrix);
    }
  }
}",0.8811096433289299
90349,"public void setOverdrawFactor(double overdrawFactor){
  if (overdrawFactor <= 0) {
    throw new IllegalArgumentException(""String_Node_Str"" + overdrawFactor);
  }
synchronized (this) {
    this.overdrawFactor=overdrawFactor;
  }
  notifyObservers();
}","/** 
 * @throws IllegalArgumentException if the  {@code overdrawFactor} is less or equal zero.
 */
public void setOverdrawFactor(double overdrawFactor){
  if (overdrawFactor <= 0) {
    throw new IllegalArgumentException(""String_Node_Str"" + overdrawFactor);
  }
synchronized (this) {
    this.overdrawFactor=overdrawFactor;
  }
  notifyObservers();
}",0.8352745424292846
90350,"public synchronized void adjustMatrix(float diffX,float diffY,float scaleFactor,Dimension mapViewDimension){
  if (this.dimension == null) {
    return;
  }
  int pivotX=this.dimension.width / 2;
  int pivotY=this.dimension.height / 2;
  this.matrix.reset();
  this.matrix.scale(scaleFactor,scaleFactor,pivotX,pivotY);
  this.matrix.translate(diffX,diffY);
  float dx=(this.dimension.width - mapViewDimension.width) / -2f;
  float dy=(this.dimension.height - mapViewDimension.height) / -2f;
  this.matrix.translate(dx,dy);
}","public synchronized void adjustMatrix(float diffX,float diffY,float scaleFactor,Dimension mapViewDimension){
  if (this.dimension == null) {
    return;
  }
  this.matrix.reset();
  centerFrameBufferToMapView(mapViewDimension);
  scale(scaleFactor);
  this.matrix.translate(diffX,diffY);
}",0.5092250922509225
90351,"@Override public synchronized void destroy(){
  if (!this.persistent || !serializeMap(this.cacheDirectory,this.map)) {
    for (    File file : this.map.values()) {
      if (!file.delete()) {
        file.deleteOnExit();
      }
    }
    this.map.clear();
    File[] filesToDelete=this.cacheDirectory.listFiles(ImageFileNameFilter.INSTANCE);
    if (filesToDelete != null) {
      for (      File file : filesToDelete) {
        if (!file.delete()) {
          file.deleteOnExit();
        }
      }
    }
    if (!this.cacheDirectory.delete()) {
      this.cacheDirectory.deleteOnExit();
    }
  }
}","@Override public synchronized void destroy(){
  if (this.bitmapGet != null) {
    this.bitmapGet.recycle();
  }
  if (this.capacity == 0) {
    return;
  }
  if (!this.persistent || !serializeMap(this.cacheDirectory,this.map)) {
    for (    File file : this.map.values()) {
      if (!file.delete()) {
        file.deleteOnExit();
      }
    }
    this.map.clear();
    if (this.cacheDirectory != null) {
      File[] filesToDelete=this.cacheDirectory.listFiles(ImageFileNameFilter.INSTANCE);
      if (filesToDelete != null) {
        for (        File file : filesToDelete) {
          if (!file.delete()) {
            file.deleteOnExit();
          }
        }
      }
      if (!this.cacheDirectory.delete()) {
        this.cacheDirectory.deleteOnExit();
      }
    }
  }
}",0.8300795372378886
90352,"@Override public synchronized void put(MapGeneratorJob mapGeneratorJob,Bitmap bitmap){
  if (this.capacity == 0) {
    return;
  }
  FileOutputStream fileOutputStream=null;
  try {
    File outputFile;
    do {
      ++this.cacheId;
      outputFile=new File(this.cacheDirectory,this.cacheId + IMAGE_FILE_NAME_EXTENSION);
    }
 while (outputFile.exists());
    this.byteBuffer.rewind();
    bitmap.copyPixelsToBuffer(this.byteBuffer);
    byte[] array=this.byteBuffer.array();
    fileOutputStream=new FileOutputStream(outputFile);
    fileOutputStream.write(array,0,array.length);
    this.map.put(mapGeneratorJob,outputFile);
  }
 catch (  IOException e) {
    LOGGER.log(Level.SEVERE,null,e);
  }
 finally {
    try {
      if (fileOutputStream != null) {
        fileOutputStream.close();
      }
    }
 catch (    IOException e) {
      LOGGER.log(Level.SEVERE,null,e);
    }
  }
}","@Override public synchronized void put(MapGeneratorJob mapGeneratorJob,Bitmap bitmap){
  if (this.capacity == 0) {
    return;
  }
  FileOutputStream fileOutputStream=null;
  try {
    File outputFile;
    do {
      ++this.cacheId;
      outputFile=new File(this.cacheDirectory,this.cacheId + IMAGE_FILE_NAME_EXTENSION);
    }
 while (outputFile.exists());
    this.byteBuffer.rewind();
    bitmap.copyPixelsToBuffer(this.byteBuffer);
    byte[] array=this.byteBuffer.array();
    fileOutputStream=new FileOutputStream(outputFile);
    fileOutputStream.write(array,0,array.length);
    this.map.put(mapGeneratorJob,outputFile);
  }
 catch (  IOException e) {
    LOGGER.log(Level.SEVERE,""String_Node_Str"",e);
    this.capacity=0;
  }
 finally {
    try {
      if (fileOutputStream != null) {
        fileOutputStream.close();
      }
    }
 catch (    IOException e) {
      LOGGER.log(Level.SEVERE,null,e);
    }
  }
}",0.9767699115044248
90353,"/** 
 * @param capacity the maximum number of entries in this cache.
 * @param mapViewId the ID of the MapView to separate caches for different MapViews.
 * @throws IllegalArgumentException if the capacity is negative.
 */
public FileSystemTileCache(int capacity,int mapViewId){
  this.capacity=getCapacity(capacity);
  String externalStorageDirectory=Environment.getExternalStorageDirectory().getAbsolutePath();
  String cacheDirectoryPath=externalStorageDirectory + CACHE_DIRECTORY + mapViewId;
  this.cacheDirectory=createDirectory(cacheDirectoryPath);
  Map<MapGeneratorJob,File> deserializedMap=deserializeMap(this.cacheDirectory);
  if (deserializedMap == null) {
    this.map=createMap(this.capacity);
  }
 else {
    this.map=deserializedMap;
  }
  this.byteBuffer=ByteBuffer.allocate(TILE_SIZE_IN_BYTES);
  this.bitmapGet=Bitmap.createBitmap(Tile.TILE_SIZE,Tile.TILE_SIZE,Config.RGB_565);
}","/** 
 * @param capacity the maximum number of entries in this cache.
 * @param mapViewId the ID of the MapView to separate caches for different MapViews.
 * @throws IllegalArgumentException if the capacity is negative.
 */
public FileSystemTileCache(int capacity,int mapViewId){
  this.mapViewId=mapViewId;
  this.capacity=checkCapacity(capacity);
  if (this.capacity > 0 && this.cacheDirectory != null) {
    Map<MapGeneratorJob,File> deserializedMap=deserializeMap(this.cacheDirectory);
    if (deserializedMap == null) {
      this.map=createMap(this.capacity);
    }
 else {
      this.map=deserializedMap;
    }
    this.byteBuffer=ByteBuffer.allocate(TILE_SIZE_IN_BYTES);
    this.bitmapGet=Bitmap.createBitmap(Tile.TILE_SIZE,Tile.TILE_SIZE,Config.RGB_565);
  }
 else {
    this.byteBuffer=null;
    this.bitmapGet=null;
    this.map=createMap(0);
  }
}",0.7531285551763367
90354,"@Override public synchronized void setCapacity(int capacity){
  if (this.capacity == capacity) {
    return;
  }
  this.capacity=getCapacity(capacity);
  Map<MapGeneratorJob,File> newMap=createMap(this.capacity);
  newMap.putAll(this.map);
  this.map=newMap;
}","@Override public synchronized void setCapacity(int capacity){
  if (this.capacity == capacity) {
    return;
  }
  this.capacity=checkCapacity(capacity);
  if (this.capacity != 0) {
    Map<MapGeneratorJob,File> newMap=createMap(this.capacity);
    if (this.map != null) {
      newMap.putAll(this.map);
    }
    this.map=newMap;
  }
}",0.8624161073825504
90355,"private void restoreMapView(MapView mapView){
  SharedPreferences sharedPreferences=getSharedPreferences(PREFERENCES_FILE,MODE_PRIVATE);
  if (containsMapViewPosition(sharedPreferences)) {
    if (sharedPreferences.contains(KEY_MAP_FILE)) {
      mapView.setMapFile(new File(sharedPreferences.getString(KEY_MAP_FILE,null)));
    }
    float latitude=sharedPreferences.getFloat(KEY_LATITUDE,0);
    float longitude=sharedPreferences.getFloat(KEY_LONGITUDE,0);
    int zoomLevel=sharedPreferences.getInt(KEY_ZOOM_LEVEL,-1);
    GeoPoint geoPoint=new GeoPoint(latitude,longitude);
    MapPosition mapPosition=new MapPosition(geoPoint,(byte)zoomLevel);
    mapView.getMapViewPosition().setMapPosition(mapPosition);
  }
}","private void restoreMapView(MapView mapView){
  SharedPreferences sharedPreferences=getSharedPreferences(PREFERENCES_FILE,MODE_PRIVATE);
  if (isCompatible(sharedPreferences) && containsMapViewPosition(sharedPreferences)) {
    if (sharedPreferences.contains(KEY_MAP_FILE)) {
      mapView.setMapFile(new File(sharedPreferences.getString(KEY_MAP_FILE,null)));
    }
    float latitude=sharedPreferences.getFloat(KEY_LATITUDE,0);
    float longitude=sharedPreferences.getFloat(KEY_LONGITUDE,0);
    int zoomLevel=sharedPreferences.getInt(KEY_ZOOM_LEVEL,-1);
    GeoPoint geoPoint=new GeoPoint(latitude,longitude);
    MapPosition mapPosition=new MapPosition(geoPoint,(byte)zoomLevel);
    mapView.getMapViewPosition().setMapPosition(mapPosition);
  }
}",0.9761417859577368
90356,"@Override protected void onPause(){
  super.onPause();
  if (this.mapViews.isEmpty()) {
    return;
  }
  for (int i=0, n=this.mapViews.size(); i < n; ++i) {
    this.mapViews.get(i).onPause();
  }
  Editor editor=getSharedPreferences(PREFERENCES_FILE,MODE_PRIVATE).edit();
  editor.clear();
  MapView mapView=this.mapViews.get(0);
  MapPosition mapPosition=mapView.getMapViewPosition().getMapPosition();
  GeoPoint geoPoint=mapPosition.geoPoint;
  editor.putFloat(KEY_LATITUDE,(float)geoPoint.latitude);
  editor.putFloat(KEY_LONGITUDE,(float)geoPoint.longitude);
  editor.putInt(KEY_ZOOM_LEVEL,mapPosition.zoomLevel);
  if (mapView.getMapFile() != null) {
    editor.putString(KEY_MAP_FILE,mapView.getMapFile().getAbsolutePath());
  }
  editor.commit();
}","@Override protected void onPause(){
  super.onPause();
  if (this.mapViews.isEmpty()) {
    return;
  }
  for (int i=0, n=this.mapViews.size(); i < n; ++i) {
    this.mapViews.get(i).onPause();
  }
  Editor editor=getSharedPreferences(PREFERENCES_FILE,MODE_PRIVATE).edit();
  editor.clear();
  editor.putInt(PREFERENCES_VERSION_KEY,PREFERENCES_VERSION_NUMBER);
  MapView mapView=this.mapViews.get(0);
  MapPosition mapPosition=mapView.getMapViewPosition().getMapPosition();
  GeoPoint geoPoint=mapPosition.geoPoint;
  editor.putFloat(KEY_LATITUDE,(float)geoPoint.latitude);
  editor.putFloat(KEY_LONGITUDE,(float)geoPoint.longitude);
  editor.putInt(KEY_ZOOM_LEVEL,mapPosition.zoomLevel);
  if (mapView.getMapFile() != null) {
    editor.putString(KEY_MAP_FILE,mapView.getMapFile().getAbsolutePath());
  }
  editor.commit();
}",0.95641187618446
90357,"/** 
 * Called when a job needs to be executed.
 * @param mapGeneratorJob the job that should be executed.
 * @param bitmap the bitmap for the generated map tile.
 * @return true if the job was executed successfully, false otherwise.
 */
public boolean executeJob(MapGeneratorJob mapGeneratorJob,android.graphics.Bitmap bitmap){
  this.currentTile=mapGeneratorJob.tile;
  XmlRenderTheme jobTheme=mapGeneratorJob.jobParameters.jobTheme;
  if (!jobTheme.equals(this.previousJobTheme)) {
    if (this.renderTheme != null) {
      this.renderTheme.destroy();
    }
    this.renderTheme=getRenderTheme(jobTheme);
    if (this.renderTheme == null) {
      this.previousJobTheme=null;
      return false;
    }
    createWayLists();
    this.previousJobTheme=jobTheme;
    this.previousZoomLevel=Byte.MIN_VALUE;
  }
  byte zoomLevel=this.currentTile.zoomLevel;
  if (zoomLevel != this.previousZoomLevel) {
    setScaleStrokeWidth(zoomLevel);
    this.previousZoomLevel=zoomLevel;
  }
  float textScale=mapGeneratorJob.jobParameters.textScale;
  if (Float.compare(textScale,this.previousTextScale) != 0) {
    this.renderTheme.scaleTextSize(textScale);
    this.previousTextScale=textScale;
  }
  if (this.mapDatabase != null) {
    MapReadResult mapReadResult=this.mapDatabase.readMapData(this.currentTile);
    processReadMapData(mapReadResult);
  }
  this.nodes=this.labelPlacement.placeLabels(this.nodes,this.pointSymbols,this.areaLabels,this.currentTile);
  this.canvasRasterer.setCanvasBitmap(bitmap);
  this.canvasRasterer.fill(this.renderTheme.getMapBackground());
  this.canvasRasterer.drawWays(this.ways);
  this.canvasRasterer.drawSymbols(this.waySymbols);
  this.canvasRasterer.drawSymbols(this.pointSymbols);
  this.canvasRasterer.drawWayNames(this.wayNames);
  this.canvasRasterer.drawNodes(this.nodes);
  this.canvasRasterer.drawNodes(this.areaLabels);
  if (mapGeneratorJob.debugSettings.drawTileFrames) {
    this.canvasRasterer.drawTileFrame();
  }
  if (mapGeneratorJob.debugSettings.drawTileCoordinates) {
    this.canvasRasterer.drawTileCoordinates(this.currentTile);
  }
  clearLists();
  return true;
}","/** 
 * Called when a job needs to be executed.
 * @param mapGeneratorJob the job that should be executed.
 * @param bitmap the bitmap for the generated map tile.
 * @return true if the job was executed successfully, false otherwise.
 */
public boolean executeJob(MapGeneratorJob mapGeneratorJob,android.graphics.Bitmap bitmap){
  this.currentTile=mapGeneratorJob.tile;
  XmlRenderTheme jobTheme=mapGeneratorJob.jobParameters.jobTheme;
  if (!jobTheme.equals(this.previousJobTheme)) {
    if (this.renderTheme != null) {
      this.renderTheme.destroy();
    }
    this.renderTheme=getRenderTheme(jobTheme);
    if (this.renderTheme == null) {
      this.previousJobTheme=null;
      return false;
    }
    createWayLists();
    this.previousJobTheme=jobTheme;
    this.previousZoomLevel=Byte.MIN_VALUE;
    this.previousTextScale=-1;
  }
  byte zoomLevel=this.currentTile.zoomLevel;
  if (zoomLevel != this.previousZoomLevel) {
    setScaleStrokeWidth(zoomLevel);
    this.previousZoomLevel=zoomLevel;
  }
  float textScale=mapGeneratorJob.jobParameters.textScale;
  if (Float.compare(textScale,this.previousTextScale) != 0) {
    this.renderTheme.scaleTextSize(textScale);
    this.previousTextScale=textScale;
  }
  if (this.mapDatabase != null) {
    MapReadResult mapReadResult=this.mapDatabase.readMapData(this.currentTile);
    processReadMapData(mapReadResult);
  }
  this.nodes=this.labelPlacement.placeLabels(this.nodes,this.pointSymbols,this.areaLabels,this.currentTile);
  this.canvasRasterer.setCanvasBitmap(bitmap);
  this.canvasRasterer.fill(this.renderTheme.getMapBackground());
  this.canvasRasterer.drawWays(this.ways);
  this.canvasRasterer.drawSymbols(this.waySymbols);
  this.canvasRasterer.drawSymbols(this.pointSymbols);
  this.canvasRasterer.drawWayNames(this.wayNames);
  this.canvasRasterer.drawNodes(this.nodes);
  this.canvasRasterer.drawNodes(this.areaLabels);
  if (mapGeneratorJob.debugSettings.drawTileFrames) {
    this.canvasRasterer.drawTileFrame();
  }
  if (mapGeneratorJob.debugSettings.drawTileCoordinates) {
    this.canvasRasterer.drawTileCoordinates(this.currentTile);
  }
  clearLists();
  return true;
}",0.9927315357561548
90358,"/** 
 * @param source name of the data source
 * @param vertexMap map of sentence index to list of vertices created from the sentence
 * @return list of edges created
 */
private List<Edge> getEdges(String source,Map<Integer,List<Vertex>> vertexMap){
  List<Edge> edges=new ArrayList<Edge>();
  Map<String,Edge> edgeIdMap=new HashMap<String,Edge>();
  for (  Integer sentNum : vertexMap.keySet()) {
    List<Vertex> sentVertices=new ArrayList<Vertex>();
    int lastSentNum=Math.min(vertexMap.size(),(sentNum.intValue() + RELATIONSHIP_SENTENCE_DISTANCE));
    for (int n=sentNum.intValue(); n < lastSentNum; n++) {
      sentVertices.addAll(vertexMap.get(Integer.valueOf(n)));
    }
    for (int i=0; i < sentVertices.size(); i++) {
      Vertex v1=sentVertices.get(i);
      for (int j=i + 1; j < sentVertices.size(); j++) {
        Vertex v2=sentVertices.get(j);
        Vertex inV=v1;
        Vertex outV=v2;
        Item matchingEdge=ontology.getProperties().getEdges().findPropertyValues(""String_Node_Str"",v1.getVertexType(),""String_Node_Str"",v2.getVertexType());
        if (matchingEdge == null) {
          matchingEdge=ontology.getProperties().getEdges().findPropertyValues(""String_Node_Str"",v1.getVertexType(),""String_Node_Str"",v2.getVertexType());
          inV=v2;
          outV=v1;
        }
        if (matchingEdge != null) {
          String edgeId=outV.get_id() + ""String_Node_Str"" + inV.get_id();
          Edge newEdge=new Edge(edgeId,matchingEdge.getTitle());
          newEdge.setSource(source);
          newEdge.set_inV(inV.get_id());
          newEdge.set_outV(outV.get_id());
          newEdge.setInVType(inV.getVertexType());
          newEdge.setOutVType(outV.getVertexType());
          edgeIdMap.put(edgeId,newEdge);
        }
 else         if (inV.getVertexType().equalsIgnoreCase(outV.getVertexType())) {
          String edgeId=outV.get_id() + ""String_Node_Str"" + inV.get_id();
          Edge newEdge=new Edge(edgeId,""String_Node_Str"");
          newEdge.setSource(source);
          newEdge.set_inV(inV.get_id());
          newEdge.set_outV(outV.get_id());
          newEdge.setInVType(inV.getVertexType());
          newEdge.setOutVType(outV.getVertexType());
          edgeIdMap.put(edgeId,newEdge);
        }
      }
    }
  }
  edges.addAll(edgeIdMap.values());
  return edges;
}","/** 
 * @param source name of the data source
 * @param vertexMap map of sentence index to list of vertices created from the sentence
 * @return list of edges created
 */
private List<Edge> getEdges(String source,Map<Integer,List<Vertex>> vertexMap){
  List<Edge> edges=new ArrayList<Edge>();
  Map<String,Edge> edgeIdMap=new HashMap<String,Edge>();
  for (  Integer sentNum : vertexMap.keySet()) {
    List<Vertex> sentVertices=new ArrayList<Vertex>();
    int lastSentNum=Math.min(vertexMap.size(),(sentNum.intValue() + RELATIONSHIP_SENTENCE_DISTANCE));
    for (int n=sentNum.intValue(); n < lastSentNum; n++) {
      Integer sentKey=Integer.valueOf(n);
      if (vertexMap.containsKey(sentKey)) {
        sentVertices.addAll(vertexMap.get(sentKey));
      }
    }
    for (int i=0; i < sentVertices.size(); i++) {
      Vertex v1=sentVertices.get(i);
      for (int j=i + 1; j < sentVertices.size(); j++) {
        Vertex v2=sentVertices.get(j);
        Vertex inV=v1;
        Vertex outV=v2;
        Item matchingEdge=ontology.getProperties().getEdges().findPropertyValues(""String_Node_Str"",v1.getVertexType(),""String_Node_Str"",v2.getVertexType());
        if (matchingEdge == null) {
          matchingEdge=ontology.getProperties().getEdges().findPropertyValues(""String_Node_Str"",v1.getVertexType(),""String_Node_Str"",v2.getVertexType());
          inV=v2;
          outV=v1;
        }
        if (matchingEdge != null) {
          String edgeId=outV.get_id() + ""String_Node_Str"" + inV.get_id();
          Edge newEdge=new Edge(edgeId,matchingEdge.getTitle());
          newEdge.setSource(source);
          newEdge.set_inV(inV.get_id());
          newEdge.set_outV(outV.get_id());
          newEdge.setInVType(inV.getVertexType());
          newEdge.setOutVType(outV.getVertexType());
          edgeIdMap.put(edgeId,newEdge);
        }
 else         if (inV.getVertexType().equalsIgnoreCase(outV.getVertexType())) {
          String edgeId=outV.get_id() + ""String_Node_Str"" + inV.get_id();
          Edge newEdge=new Edge(edgeId,""String_Node_Str"");
          newEdge.setSource(source);
          newEdge.set_inV(inV.get_id());
          newEdge.set_outV(outV.get_id());
          newEdge.setInVType(inV.getVertexType());
          newEdge.setOutVType(outV.getVertexType());
          edgeIdMap.put(edgeId,newEdge);
        }
      }
    }
  }
  edges.addAll(edgeIdMap.values());
  return edges;
}",0.973087518542064
90359,"/** 
 * @param vertices list of current vertices created from the sentence
 * @param sentNum index of the current sentence from the list of sentences
 * @param source name of the data source
 * @param phrase property value to be added to the vertex
 * @param label property of the vertex
 * @return new list of vertices the sentence
 */
private List<Vertex> updateVertexList(List<Vertex> vertices,int sentNum,String source,String phrase,String label){
  if (label.startsWith(""String_Node_Str"")) {
    String vertexType=""String_Node_Str"";
    label=label.replace(""String_Node_Str"",""String_Node_Str"");
    Item matchingSchema=ontology.getProperties().getVertices().findPropertyKey(vertexType,label);
    if (matchingSchema != null) {
      boolean updated=false;
      for (int i=vertices.size() - 1; i >= 0; i--) {
        Vertex currentVertex=vertices.get(i);
        if ((currentVertex.getVertexType().equalsIgnoreCase(""String_Node_Str"")) && (!currentVertex.getProperties().containsKey(label))) {
          currentVertex.addProperty(label,phrase);
          updated=true;
          break;
        }
      }
      if (!updated) {
        String id=""String_Node_Str"" + sentNum + ""String_Node_Str""+ vertices.size();
        Vertex newVertex=new Vertex(id,vertexType);
        newVertex.addProperty(label,phrase);
        newVertex.addProperty(""String_Node_Str"",source);
        vertices.add(newVertex);
      }
    }
 else {
      System.err.println(""String_Node_Str"" + label + ""String_Node_Str""+ phrase+ ""String_Node_Str"");
    }
  }
 else   if (label.startsWith(""String_Node_Str"")) {
    String vertexType=""String_Node_Str"";
    if (label.equalsIgnoreCase(""String_Node_Str"")) {
      label=""String_Node_Str"";
    }
 else     if ((label.equalsIgnoreCase(""String_Node_Str"")) || (label.equalsIgnoreCase(""String_Node_Str""))) {
      label=""String_Node_Str"";
    }
    Item matchingSchema=ontology.getProperties().getVertices().findPropertyKey(vertexType,label);
    if (matchingSchema != null) {
      boolean updated=false;
      for (int i=vertices.size() - 1; i >= 0; i--) {
        Vertex currentVertex=vertices.get(i);
        if ((currentVertex.getVertexType().equalsIgnoreCase(""String_Node_Str"")) && (!currentVertex.getProperties().containsKey(label))) {
          currentVertex.addProperty(label,phrase);
          updated=true;
          break;
        }
      }
      if (!updated) {
        String id=""String_Node_Str"" + sentNum + ""String_Node_Str""+ vertices.size();
        Vertex newVertex=new Vertex(id,vertexType);
        newVertex.addProperty(label,phrase);
        newVertex.addProperty(""String_Node_Str"",source);
        vertices.add(newVertex);
      }
    }
 else     if (label.equalsIgnoreCase(""String_Node_Str"")) {
      Vertex newVertex=new Vertex(phrase,vertexType);
      newVertex.addProperty(""String_Node_Str"",source);
      vertices.add(newVertex);
    }
 else {
      System.err.println(""String_Node_Str"" + label + ""String_Node_Str""+ phrase+ ""String_Node_Str"");
    }
  }
 else {
    System.err.println(""String_Node_Str"" + label + ""String_Node_Str""+ phrase+ ""String_Node_Str"");
  }
  return vertices;
}","/** 
 * @param vertices list of current vertices created from the sentence
 * @param sentNum index of the current sentence from the list of sentences
 * @param source name of the data source
 * @param phrase property value to be added to the vertex
 * @param label property of the vertex
 * @return new list of vertices the sentence
 */
private List<Vertex> updateVertexList(List<Vertex> vertices,int sentNum,String source,String phrase,String label){
  if (label.startsWith(""String_Node_Str"")) {
    String vertexType=""String_Node_Str"";
    label=label.replace(""String_Node_Str"",""String_Node_Str"");
    Item matchingSchema=ontology.getProperties().getVertices().findPropertyKey(vertexType,label);
    if (matchingSchema != null) {
      boolean updated=false;
      for (int i=vertices.size() - 1; i >= 0; i--) {
        Vertex currentVertex=vertices.get(i);
        if ((currentVertex.getVertexType().equalsIgnoreCase(""String_Node_Str"")) && (!currentVertex.getProperties().containsKey(label))) {
          currentVertex.addProperty(label,phrase);
          updated=true;
          break;
        }
      }
      if (!updated) {
        String id=""String_Node_Str"" + sentNum + ""String_Node_Str""+ vertices.size();
        Vertex newVertex=new Vertex(id,vertexType);
        newVertex.addProperty(label,phrase);
        newVertex.addProperty(""String_Node_Str"",source);
        vertices.add(newVertex);
      }
    }
 else {
      System.err.println(""String_Node_Str"" + label + ""String_Node_Str""+ phrase+ ""String_Node_Str"");
    }
  }
 else   if (label.startsWith(""String_Node_Str"")) {
    String vertexType=""String_Node_Str"";
    if (label.equalsIgnoreCase(""String_Node_Str"")) {
      label=""String_Node_Str"";
    }
 else     if ((label.equalsIgnoreCase(""String_Node_Str"")) || (label.equalsIgnoreCase(""String_Node_Str""))) {
      label=""String_Node_Str"";
    }
    Item matchingSchema=ontology.getProperties().getVertices().findPropertyKey(vertexType,label);
    if (matchingSchema != null) {
      boolean updated=false;
      for (int i=vertices.size() - 1; i >= 0; i--) {
        Vertex currentVertex=vertices.get(i);
        if ((currentVertex.getVertexType().equalsIgnoreCase(""String_Node_Str"")) && (!currentVertex.getProperties().containsKey(label))) {
          currentVertex.addProperty(label,phrase);
          updated=true;
          break;
        }
      }
      if (!updated) {
        String id=""String_Node_Str"" + sentNum + ""String_Node_Str""+ vertices.size();
        Vertex newVertex=new Vertex(id,vertexType);
        newVertex.addProperty(label,phrase);
        newVertex.addProperty(""String_Node_Str"",source);
        vertices.add(newVertex);
      }
    }
 else     if (label.equalsIgnoreCase(""String_Node_Str"")) {
      Vertex newVertex=new Vertex(phrase,vertexType);
      newVertex.addProperty(""String_Node_Str"",source);
      vertices.add(newVertex);
    }
 else {
      System.err.println(""String_Node_Str"" + label + ""String_Node_Str""+ phrase+ ""String_Node_Str"");
    }
  }
 else {
  }
  return vertices;
}",0.9840857421240664
90360,"@Override public void init(){
  try {
    String[] addresses=address.split(""String_Node_Str"");
    List<JedisShardInfo> shardInfos=Lists.newArrayListWithCapacity(addresses.length);
    for (    String addr : addresses) {
      String[] pair=addr.split(""String_Node_Str"");
      shardInfos.add(new JedisShardInfo(pair[0],Integer.parseInt(pair[1])));
    }
    Map<String,String> properties=getProperties();
    JedisPoolConfig poolConfig=new JedisPoolConfig();
    poolConfig.setTestWhileIdle(true);
    poolConfig.setMaxIdle(6);
    if (properties.containsKey(""String_Node_Str"")) {
      poolConfig.setMaxIdle(Integer.parseInt(properties.get(""String_Node_Str"")));
    }
    poolConfig.setMaxTotal(2000);
    if (properties.containsKey(""String_Node_Str"")) {
      poolConfig.setMaxTotal(Integer.parseInt(properties.get(""String_Node_Str"")));
    }
    poolConfig.setMinEvictableIdleTimeMillis(60000);
    if (properties.containsKey(""String_Node_Str"")) {
      poolConfig.setMinEvictableIdleTimeMillis(Long.parseLong(""String_Node_Str""));
    }
    poolConfig.setTimeBetweenEvictionRunsMillis(30000);
    if (properties.containsKey(""String_Node_Str"")) {
      poolConfig.setTimeBetweenEvictionRunsMillis(Long.parseLong(""String_Node_Str""));
    }
    poolConfig.setNumTestsPerEvictionRun(-1);
    this.jedisPool=new ShardedJedisPool(poolConfig,shardInfos);
  }
 catch (  Exception e) {
    throw new RuntimeException(""String_Node_Str"",e);
  }
}","@Override public void init(){
  try {
    String[] addresses=address.split(""String_Node_Str"");
    List<JedisShardInfo> shardInfos=Lists.newArrayListWithCapacity(addresses.length);
    JedisShardInfo shardInfo=null;
    for (    String addr : addresses) {
      int firstSplitPos=addr.indexOf(':');
      int secondSplitPos=addr.indexOf(':',firstSplitPos + 1);
      String host=addr.substring(0,firstSplitPos);
      if (secondSplitPos == -1) {
        int port=Integer.parseInt(addr.substring(firstSplitPos + 1));
        shardInfo=new JedisShardInfo(host,port);
      }
 else {
        int port=Integer.parseInt(addr.substring(firstSplitPos + 1,secondSplitPos));
        String pwd=addr.substring(secondSplitPos + 1);
        shardInfo=new JedisShardInfo(host,port);
        shardInfo.setPassword(pwd);
      }
      shardInfos.add(shardInfo);
    }
    Map<String,String> properties=getProperties();
    JedisPoolConfig poolConfig=new JedisPoolConfig();
    poolConfig.setTestWhileIdle(true);
    poolConfig.setMaxIdle(6);
    if (properties.containsKey(""String_Node_Str"")) {
      poolConfig.setMaxIdle(Integer.parseInt(properties.get(""String_Node_Str"")));
    }
    poolConfig.setMaxTotal(2000);
    if (properties.containsKey(""String_Node_Str"")) {
      poolConfig.setMaxTotal(Integer.parseInt(properties.get(""String_Node_Str"")));
    }
    poolConfig.setMinEvictableIdleTimeMillis(60000);
    if (properties.containsKey(""String_Node_Str"")) {
      poolConfig.setMinEvictableIdleTimeMillis(Long.parseLong(""String_Node_Str""));
    }
    poolConfig.setTimeBetweenEvictionRunsMillis(30000);
    if (properties.containsKey(""String_Node_Str"")) {
      poolConfig.setTimeBetweenEvictionRunsMillis(Long.parseLong(""String_Node_Str""));
    }
    poolConfig.setNumTestsPerEvictionRun(-1);
    this.jedisPool=new ShardedJedisPool(poolConfig,shardInfos);
  }
 catch (  Exception e) {
    throw new RuntimeException(""String_Node_Str"",e);
  }
}",0.7979857819905213
90361,"@Override public Number save(Object entity){
  CheckUtil.checkShardingEntity(entity);
  String clusterName=entityMetaManager.getClusterName(entity.getClass());
  Object shardingKey=entityMetaManager.getShardingValue(entity);
  IShardingKey<Object> sk=new ShardingKey<Object>(clusterName,shardingKey);
  CheckUtil.checkShardingKey(sk);
  return this.shardingUpdater.save(entity,sk).getValueAsNumber();
}","@Override public Number save(Object entity){
  CheckUtil.checkShardingEntity(entity);
  String clusterName=entityMetaManager.getClusterName(entity.getClass());
  Object shardingKey=entityMetaManager.getShardingValue(entity);
  IShardingKey<Object> sk=new ShardingKey<Object>(clusterName,shardingKey);
  CheckUtil.checkShardingKey(sk);
  PKValue pkValue=this.shardingUpdater.save(entity,sk);
  if (pkValue != null) {
    return pkValue.getValueAsNumber();
  }
  return null;
}",0.9007981755986316
90362,"@Test public void testSave() throws Exception {
  TestGlobalEntity globalEntity=createGlobalEntity();
  globalEntity.setId(pinusClient.genClusterUniqueLongId(""String_Node_Str""));
  TestGlobalUnionKeyEntity globalUKEntity=createGlobalUnionKeyEntity();
  TestEntity shardingEntity=createEntity();
  shardingEntity.setId(pinusClient.genClusterUniqueLongId(""String_Node_Str""));
  pinusClient.save(globalEntity);
  System.out.println(globalEntity.getId());
  pinusClient.save(globalUKEntity);
  System.out.println(globalUKEntity);
  pinusClient.save(shardingEntity);
  System.out.println(shardingEntity.getId());
}","@Test public void testSave() throws Exception {
  TestGlobalEntity globalEntity=createGlobalEntity();
  globalEntity.setId(pinusClient.genClusterUniqueLongId(""String_Node_Str""));
  TestGlobalUnionKeyEntity globalUKEntity=createGlobalUnionKeyEntity();
  TestEntity shardingEntity=createEntity();
  shardingEntity.setId(pinusClient.genClusterUniqueLongId(""String_Node_Str""));
  System.out.println(globalEntity.getId());
  pinusClient.save(globalUKEntity);
  System.out.println(globalUKEntity);
  System.out.println(shardingEntity.getId());
}",0.789198606271777
90363,"/** 
 * relase resource. include database connection,zookeeper connection and cache connection.
 */
@Override public void shutdown() throws DBClusterException {
  if (this.primaryCache != null)   this.primaryCache.close();
  if (this.secondCache != null)   this.secondCache.close();
  try {
    for (    DBClusterInfo dbClusterInfo : this.dbClusterInfoC.values()) {
      DBInfo masterGlobal=dbClusterInfo.getMasterGlobalDBInfo();
      if (masterGlobal != null)       closeDataSource(masterGlobal);
      List<DBInfo> slaveDbs=dbClusterInfo.getSlaveGlobalDBInfo();
      if (slaveDbs != null && !slaveDbs.isEmpty()) {
        for (        DBInfo slaveGlobal : slaveDbs) {
          closeDataSource(slaveGlobal);
        }
      }
      for (      DBRegionInfo regionInfo : dbClusterInfo.getDbRegions()) {
        for (        DBInfo dbConnInfo : regionInfo.getMasterDBInfos()) {
          closeDataSource(dbConnInfo);
        }
        for (        List<DBInfo> dbConnInfos : regionInfo.getSlaveDBInfos()) {
          for (          DBInfo dbConnInfo : dbConnInfos) {
            closeDataSource(dbConnInfo);
          }
        }
      }
    }
  }
 catch (  Exception e) {
    throw new DBClusterException(""String_Node_Str"",e);
  }
  DBResourceCache.clear();
  CloseableUtils.closeQuietly(this.curatorClient);
}","/** 
 * relase resource. include database connection,zookeeper connection and cache connection.
 */
@Override public void shutdown() throws DBClusterException {
  if (this.primaryCache != null)   this.primaryCache.close();
  if (this.secondCache != null)   this.secondCache.close();
  try {
    for (    DBClusterInfo dbClusterInfo : this.dbClusterInfoC.values()) {
      DBInfo masterGlobal=dbClusterInfo.getMasterGlobalDBInfo();
      if (masterGlobal != null)       closeDataSource(masterGlobal);
      List<DBInfo> slaveDbs=dbClusterInfo.getSlaveGlobalDBInfo();
      if (slaveDbs != null && !slaveDbs.isEmpty()) {
        for (        DBInfo slaveGlobal : slaveDbs) {
          closeDataSource(slaveGlobal);
        }
      }
      for (      DBRegionInfo regionInfo : dbClusterInfo.getDbRegions()) {
        for (        DBInfo dbConnInfo : regionInfo.getMasterDBInfos()) {
          closeDataSource(dbConnInfo);
        }
        for (        List<DBInfo> dbConnInfos : regionInfo.getSlaveDBInfos()) {
          for (          DBInfo dbConnInfo : dbConnInfos) {
            closeDataSource(dbConnInfo);
          }
        }
      }
    }
  }
 catch (  Exception e) {
    throw new DBClusterException(""String_Node_Str"",e);
  }
  CloseableUtils.closeQuietly(this.curatorClient);
}",0.954213158907272
90364,"/** 
 * singleton
 * @param dbInfo
 * @return
 */
public static IDBResource valueOf(ITransaction tx,DBInfo dbInfo,String tableName) throws SQLException {
  IResourceId resId=new DBResourceId(dbInfo.getClusterName(),dbInfo.getDbName(),tableName,dbInfo.getMasterSlave());
  GlobalDBResource dbResource=null;
  if (tx != null && tx.isContain(resId)) {
    dbResource=(GlobalDBResource)tx.getDBResource(resId);
  }
 else {
    dbResource=(GlobalDBResource)DBResourceCache.getGlobalDBResource(resId);
    Connection conn=dbInfo.getDatasource().getConnection();
    conn.setAutoCommit(false);
    if (dbResource == null) {
      dbResource=new GlobalDBResource();
      dbResource.setId(resId);
      dbResource.setClusterName(dbInfo.getClusterName());
      dbResource.setDbName(dbInfo.getDbName());
      dbResource.setMasterSlave(dbInfo.getMasterSlave());
      DatabaseMetaData dbMeta=conn.getMetaData();
      String databaseProductName=dbMeta.getDatabaseProductName();
      String url=dbMeta.getURL().substring(13);
      String host=url.substring(0,url.indexOf(""String_Node_Str""));
      String catalog=conn.getCatalog();
      dbResource.setDatabaseProductName(databaseProductName);
      dbResource.setHost(host);
      dbResource.setCatalog(catalog);
      DBResourceCache.putGlobalDBResource(resId,dbResource);
    }
    dbResource.setConnection(conn);
  }
  return dbResource;
}","/** 
 * singleton
 * @param dbInfo
 * @return
 */
public static IDBResource valueOf(ITransaction tx,DBInfo dbInfo,String tableName) throws SQLException {
  IResourceId resId=new DBResourceId(dbInfo.getClusterName(),dbInfo.getDbName(),tableName,dbInfo.getMasterSlave());
  GlobalDBResource dbResource=null;
  if (tx != null && tx.isContain(resId)) {
    dbResource=(GlobalDBResource)tx.getDBResource(resId);
  }
 else {
    Connection conn=dbInfo.getDatasource().getConnection();
    conn.setAutoCommit(false);
    dbResource=new GlobalDBResource();
    dbResource.setId(resId);
    dbResource.setClusterName(dbInfo.getClusterName());
    dbResource.setDbName(dbInfo.getDbName());
    dbResource.setMasterSlave(dbInfo.getMasterSlave());
    dbResource.setConnection(conn);
  }
  return dbResource;
}",0.4232707283554741
90365,"public static ShardingDBResource valueOf(ITransaction tx,DBInfo dbInfo,DBRegionInfo regionInfo,String tableName,int tableIndex) throws SQLException {
  IResourceId resId=new DBResourceId(dbInfo.getClusterName(),dbInfo.getDbName(),regionInfo.getCapacity(),tableName,tableIndex,dbInfo.getMasterSlave());
  ShardingDBResource dbResource=null;
  if (tx != null && tx.isContain(resId)) {
    dbResource=(ShardingDBResource)tx.getDBResource(resId);
  }
 else {
    dbResource=(ShardingDBResource)DBResourceCache.getShardingDBResource(resId);
    Connection conn=dbInfo.getDatasource().getConnection();
    conn.setAutoCommit(false);
    if (dbResource == null) {
      dbResource=new ShardingDBResource();
      dbResource.setId(resId);
      dbResource.setClusterName(dbInfo.getClusterName());
      dbResource.setDbName(dbInfo.getDbName());
      dbResource.setRegionCapacity(regionInfo.getCapacity());
      dbResource.setTableName(tableName);
      dbResource.setTableIndex(tableIndex);
      dbResource.setMasterSlave(dbInfo.getMasterSlave());
      DatabaseMetaData dbMeta=conn.getMetaData();
      String databaseProductName=dbMeta.getDatabaseProductName();
      String url=dbMeta.getURL().substring(13);
      String host=url.substring(0,url.indexOf(""String_Node_Str""));
      String catalog=conn.getCatalog();
      dbResource.setDatabaseProductName(databaseProductName);
      dbResource.setHost(host);
      dbResource.setCatalog(catalog);
      DBResourceCache.putShardingDBResource(resId,dbResource);
    }
    dbResource.setConnection(conn);
  }
  return dbResource;
}","public static ShardingDBResource valueOf(ITransaction tx,DBInfo dbInfo,DBRegionInfo regionInfo,String tableName,int tableIndex) throws SQLException {
  IResourceId resId=new DBResourceId(dbInfo.getClusterName(),dbInfo.getDbName(),regionInfo.getCapacity(),tableName,tableIndex,dbInfo.getMasterSlave());
  ShardingDBResource dbResource=null;
  if (tx != null && tx.isContain(resId)) {
    dbResource=(ShardingDBResource)tx.getDBResource(resId);
  }
 else {
    Connection conn=dbInfo.getDatasource().getConnection();
    conn.setAutoCommit(false);
    dbResource=new ShardingDBResource();
    dbResource.setId(resId);
    dbResource.setClusterName(dbInfo.getClusterName());
    dbResource.setDbName(dbInfo.getDbName());
    dbResource.setRegionCapacity(regionInfo.getCapacity());
    dbResource.setTableName(tableName);
    dbResource.setTableIndex(tableIndex);
    dbResource.setMasterSlave(dbInfo.getMasterSlave());
    dbResource.setConnection(conn);
  }
  return dbResource;
}",0.3851272015655577
90366,"@Override public String toString(){
  return ""String_Node_Str"" + clusterName + ""String_Node_Str""+ dbName+ ""String_Node_Str""+ tableName+ ""String_Node_Str""+ tableIndex+ ""String_Node_Str""+ regionCapacity+ ""String_Node_Str""+ masterSlave+ ""String_Node_Str""+ databaseProductName+ ""String_Node_Str""+ host+ ""String_Node_Str""+ catalog+ ""String_Node_Str"";
}","@Override public String toString(){
  return ""String_Node_Str"" + clusterName + ""String_Node_Str""+ dbName+ ""String_Node_Str""+ tableName+ ""String_Node_Str""+ tableIndex+ ""String_Node_Str""+ regionCapacity+ ""String_Node_Str""+ masterSlave+ ""String_Node_Str"";
}",0.8452579034941764
90367,"@SuppressWarnings(""String_Node_Str"") private <T>List<T> _findByQuery(IQuery<T> query,IDBResource dbResource,Class<T> clazz,boolean useCache,EnumDBMasterSlave masterSlave){
  List<T> result=Lists.newArrayList();
  Transaction tx=null;
  try {
    tx=txManager.getTransaction();
    if (tx != null) {
      tx.enlistResource((XAResource)dbResource);
    }
    Map<EntityPK,T> data=null;
    if (isSecondCacheAvailable(clazz,useCache)) {
      String sCacheKey=((DefaultQueryImpl<T>)query).getWhereSql().getSecondCacheKey();
      List<T> sCacheData=(List<T>)secondCache.get(sCacheKey,(ShardingDBResource)dbResource);
      if (sCacheData != null && !sCacheData.isEmpty()) {
        result.addAll(sCacheData);
      }
    }
    if (result == null || result.isEmpty()) {
      if (isCacheAvailable(clazz,useCache)) {
        EntityPK[] entityPks=selectPksByQuery((ShardingDBResource)dbResource,query,clazz);
        data=selectByPksWithCache(dbResource,clazz,entityPks,((DefaultQueryImpl<T>)query).getOrderList(),useCache);
        result.addAll(data.values());
      }
 else {
        result=selectByQuery((ShardingDBResource)dbResource,query,clazz);
      }
      if (isSecondCacheAvailable(clazz,useCache)) {
        String sCacheKey=((DefaultQueryImpl<T>)query).getWhereSql().getSecondCacheKey();
        secondCache.put(sCacheKey,(ShardingDBResource)dbResource,result);
      }
    }
    List<T> filteResult=new ArrayList<T>(data.size());
    if (((DefaultQueryImpl<T>)query).hasQueryFields()) {
      for (      T obj : result) {
        try {
          filteResult.add((T)BeansUtil.cloneWithGivenField(obj,((DefaultQueryImpl<T>)query).getFields()));
        }
 catch (        Exception e) {
          throw new DBOperationException(e);
        }
      }
      result=filteResult;
    }
    return result;
  }
 catch (  Exception e) {
    if (tx != null) {
      try {
        tx.rollback();
      }
 catch (      Exception e1) {
        throw new DBOperationException(e1);
      }
    }
    throw new DBOperationException(e);
  }
 finally {
    if (tx == null && dbResource != null) {
      dbResource.close();
    }
  }
}","@SuppressWarnings(""String_Node_Str"") private <T>List<T> _findByQuery(IQuery<T> query,IDBResource dbResource,Class<T> clazz,boolean useCache,EnumDBMasterSlave masterSlave){
  List<T> result=Lists.newArrayList();
  Transaction tx=null;
  try {
    tx=txManager.getTransaction();
    if (tx != null) {
      tx.enlistResource((XAResource)dbResource);
    }
    Map<EntityPK,T> data=null;
    if (isSecondCacheAvailable(clazz,useCache)) {
      String sCacheKey=((DefaultQueryImpl<T>)query).getWhereSql().getSecondCacheKey();
      List<T> sCacheData=(List<T>)secondCache.get(sCacheKey,(ShardingDBResource)dbResource);
      if (sCacheData != null && !sCacheData.isEmpty()) {
        result.addAll(sCacheData);
      }
    }
    if (result == null || result.isEmpty()) {
      if (isCacheAvailable(clazz,useCache)) {
        EntityPK[] entityPks=selectPksByQuery((ShardingDBResource)dbResource,query,clazz);
        data=selectByPksWithCache(dbResource,clazz,entityPks,((DefaultQueryImpl<T>)query).getOrderList(),useCache);
        result.addAll(data.values());
      }
 else {
        result=selectByQuery((ShardingDBResource)dbResource,query,clazz);
      }
      if (isSecondCacheAvailable(clazz,useCache)) {
        String sCacheKey=((DefaultQueryImpl<T>)query).getWhereSql().getSecondCacheKey();
        secondCache.put(sCacheKey,(ShardingDBResource)dbResource,result);
      }
    }
    List<T> filteResult=new ArrayList<T>(result.size());
    if (((DefaultQueryImpl<T>)query).hasQueryFields()) {
      for (      T obj : result) {
        try {
          filteResult.add((T)BeansUtil.cloneWithGivenField(obj,((DefaultQueryImpl<T>)query).getFields()));
        }
 catch (        Exception e) {
          throw new DBOperationException(e);
        }
      }
      result=filteResult;
    }
    return result;
  }
 catch (  Exception e) {
    if (tx != null) {
      try {
        tx.rollback();
      }
 catch (      Exception e1) {
        throw new DBOperationException(e1);
      }
    }
    throw new DBOperationException(e);
  }
 finally {
    if (tx == null && dbResource != null) {
      dbResource.close();
    }
  }
}",0.997648165569144
90368,"@Test public void testConcurrent() throws Exception {
  List<Thread> threads=Lists.newArrayList();
  for (int i=0; i < 500; i++) {
    Thread t=new Thread(new Runnable(){
      @Override public void run(){
        IQuery<TestGlobalEntity> globalQuery=pinusClient.createQuery(TestGlobalEntity.class);
        for (int i=0; i < 10000; i++) {
          globalQuery.limit(100).list();
        }
      }
    }
);
    t.start();
    threads.add(t);
    Thread.sleep(100);
  }
  for (  Thread t : threads) {
    t.join();
  }
}","@Test public void testConcurrent() throws Exception {
  List<Thread> threads=Lists.newArrayList();
  for (int i=0; i < Runtime.getRuntime().availableProcessors(); i++) {
    Thread t=new Thread(new Runnable(){
      @Override public void run(){
        IQuery<TestGlobalEntity> globalQuery=pinusClient.createQuery(TestGlobalEntity.class);
        IQuery<TestEntity> query=pinusClient.createQuery(TestEntity.class);
        for (int i=0; i < 10000; i++) {
          globalQuery.limit(10).list();
          query.limit(100,10).list();
        }
      }
    }
);
    t.start();
    threads.add(t);
    Thread.sleep(100);
  }
  for (  Thread t : threads) {
    t.join();
  }
}",0.8674496644295302
90369,"@Override public void run(){
  IQuery<TestGlobalEntity> globalQuery=pinusClient.createQuery(TestGlobalEntity.class);
  for (int i=0; i < 10000; i++) {
    globalQuery.limit(100).list();
  }
}","@Override public void run(){
  IQuery<TestGlobalEntity> globalQuery=pinusClient.createQuery(TestGlobalEntity.class);
  IQuery<TestEntity> query=pinusClient.createQuery(TestEntity.class);
  for (int i=0; i < 10000; i++) {
    globalQuery.limit(10).list();
    query.limit(100,10).list();
  }
}",0.7908902691511387
90370,"@Override public String toString(){
  return ""String_Node_Str"" + username + ""String_Node_Str""+ url+ ""String_Node_Str""+ id+ ""String_Node_Str""+ clusterName+ ""String_Node_Str""+ dbName+ ""String_Node_Str""+ masterSlave+ ""String_Node_Str"";
}","@Override public String toString(){
  return ""String_Node_Str"" + url + ""String_Node_Str""+ id+ ""String_Node_Str""+ clusterName+ ""String_Node_Str""+ dbName+ ""String_Node_Str""+ masterSlave+ ""String_Node_Str"";
}",0.9202733485193622
90371,"protected void setConnectionParam(DataSource obj,String propertyName,String value){
  Method[] setMethods=obj.getClass().getMethods();
  for (  Method setMethod : setMethods) {
    if (!setMethod.getName().equals(""String_Node_Str"" + StringUtil.upperFirstLetter(propertyName))) {
      continue;
    }
    if (setMethod.getParameterTypes().length > 1) {
      continue;
    }
    Class<?> paramType=setMethod.getParameterTypes()[0];
    try {
      if (paramType == Boolean.TYPE || paramType == Boolean.class) {
        Boolean v=(Boolean.valueOf(value)).booleanValue();
        setMethod.invoke(obj,v);
      }
 else       if (paramType == Integer.TYPE || paramType == Integer.class) {
        Integer v=Integer.parseInt(value);
        setMethod.invoke(obj,v);
      }
 else       if (paramType == Byte.TYPE || paramType == Byte.class) {
        Byte v=Byte.parseByte(value);
        setMethod.invoke(obj,v);
      }
 else       if (paramType == Long.TYPE || paramType == Long.class) {
        Long v=Long.parseLong(value);
        setMethod.invoke(obj,v);
      }
 else       if (paramType == Short.TYPE || paramType == Short.class) {
        Short v=Short.valueOf(value);
        setMethod.invoke(obj,v);
      }
 else       if (paramType == Float.TYPE || paramType == Float.class) {
        Float v=Float.valueOf(value);
        setMethod.invoke(obj,v);
      }
 else       if (paramType == Double.TYPE || paramType == Double.class) {
        Double v=Double.valueOf(value);
        setMethod.invoke(obj,v);
      }
 else       if (paramType == Character.TYPE || paramType == Character.class) {
        Character v=value.charAt(0);
        setMethod.invoke(obj,v);
      }
 else {
        setMethod.invoke(obj,value);
      }
    }
 catch (    Exception e) {
      throw new RuntimeException(e);
    }
    return;
  }
}","protected void setConnectionParam(DataSource obj,String propertyName,String value) throws IntrospectionException, IllegalAccessException, IllegalArgumentException, InvocationTargetException {
  PropertyDescriptor pd=ReflectUtil.getPropertyDescriptor(obj.getClass(),propertyName);
  Method writeMethod=null;
  if (pd != null) {
    writeMethod=pd.getWriteMethod();
  }
 else {
    LOG.warn(""String_Node_Str"",propertyName);
    return;
  }
  Class<?> paramType=pd.getPropertyType();
  try {
    if (paramType == Boolean.TYPE || paramType == Boolean.class) {
      Boolean v=(Boolean.valueOf(value)).booleanValue();
      writeMethod.invoke(obj,v);
    }
 else     if (paramType == Integer.TYPE || paramType == Integer.class) {
      Integer v=Integer.parseInt(value);
      writeMethod.invoke(obj,v);
    }
 else     if (paramType == Byte.TYPE || paramType == Byte.class) {
      Byte v=Byte.parseByte(value);
      writeMethod.invoke(obj,v);
    }
 else     if (paramType == Long.TYPE || paramType == Long.class) {
      Long v=Long.parseLong(value);
      writeMethod.invoke(obj,v);
    }
 else     if (paramType == Short.TYPE || paramType == Short.class) {
      Short v=Short.valueOf(value);
      writeMethod.invoke(obj,v);
    }
 else     if (paramType == Float.TYPE || paramType == Float.class) {
      Float v=Float.valueOf(value);
      writeMethod.invoke(obj,v);
    }
 else     if (paramType == Double.TYPE || paramType == Double.class) {
      Double v=Double.valueOf(value);
      writeMethod.invoke(obj,v);
    }
 else     if (paramType == Character.TYPE || paramType == Character.class) {
      Character v=value.charAt(0);
      writeMethod.invoke(obj,v);
    }
 else {
      writeMethod.invoke(obj,value);
    }
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
}",0.8057474440453164
90372,"@Override public DataSource buildAppDataSource(AppDBInfo dbInfo) throws LoadConfigException {
  BasicDataSource ds=new BasicDataSource();
  ds.setDriverClassName(dbInfo.getDbCatalog().getDriverClass());
  ds.setUsername(dbInfo.getUsername());
  ds.setPassword(dbInfo.getPassword());
  ds.setUrl(dbInfo.getUrl());
  ds.setValidationQuery(""String_Node_Str"");
  for (  Map.Entry<String,String> entry : dbInfo.getConnPoolInfo().entrySet()) {
    try {
      setConnectionParam(ds,entry.getKey(),entry.getValue());
    }
 catch (    Exception e) {
      LOG.warn(""String_Node_Str"" + entry);
    }
  }
  return ds;
}","@Override public DataSource buildAppDataSource(AppDBInfo dbInfo) throws LoadConfigException {
  BasicDataSource ds=new BasicDataSource();
  ds.setDriverClassName(dbInfo.getDbCatalog().getDriverClass());
  ds.setUsername(dbInfo.getUsername());
  ds.setPassword(dbInfo.getPassword());
  ds.setUrl(dbInfo.getUrl());
  ds.setValidationQuery(""String_Node_Str"");
  for (  Map.Entry<String,String> entry : dbInfo.getConnPoolInfo().entrySet()) {
    try {
      setConnectionParam(ds,entry.getKey(),entry.getValue());
    }
 catch (    Exception e) {
      throw new LoadConfigException(e);
    }
  }
  return ds;
}",0.9482333607230896
90373,"@Override public DataSource buildAppDataSource(AppDBInfo dbInfo) throws LoadConfigException {
  DruidDataSource ds=new DruidDataSource();
  ds.setDriverClassName(dbInfo.getDbCatalog().getDriverClass());
  ds.setUsername(dbInfo.getUsername());
  ds.setPassword(dbInfo.getPassword());
  ds.setUrl(dbInfo.getUrl());
  for (  Map.Entry<String,String> entry : dbInfo.getConnPoolInfo().entrySet()) {
    if (entry.getKey().equals(""String_Node_Str"")) {
      try {
        BeansUtil.setProperty(ds,entry.getKey(),Class.forName(entry.getValue()).newInstance());
      }
 catch (      Exception e) {
        throw new LoadConfigException(""String_Node_Str"");
      }
    }
 else {
      try {
        setConnectionParam(ds,entry.getKey(),entry.getValue());
      }
 catch (      Exception e) {
        LOG.warn(""String_Node_Str"" + entry);
      }
    }
  }
  ds.setValidationQuery(""String_Node_Str"");
  return ds;
}","@Override public DataSource buildAppDataSource(AppDBInfo dbInfo) throws LoadConfigException {
  DruidDataSource ds=new DruidDataSource();
  ds.setDriverClassName(dbInfo.getDbCatalog().getDriverClass());
  ds.setUsername(dbInfo.getUsername());
  ds.setPassword(dbInfo.getPassword());
  ds.setUrl(dbInfo.getUrl());
  for (  Map.Entry<String,String> entry : dbInfo.getConnPoolInfo().entrySet()) {
    if (entry.getKey().equals(""String_Node_Str"")) {
      try {
        BeansUtil.setProperty(ds,entry.getKey(),Class.forName(entry.getValue()).newInstance());
      }
 catch (      Exception e) {
        throw new LoadConfigException(""String_Node_Str"");
      }
    }
 else {
      try {
        setConnectionParam(ds,entry.getKey(),entry.getValue());
      }
 catch (      Exception e) {
        throw new LoadConfigException(e);
      }
    }
  }
  ds.setValidationQuery(""String_Node_Str"");
  return ds;
}",0.8987271721084671
90374,"@Override public void afterPropertiesSet() throws Exception {
  super.init();
  DefaultListableBeanFactory beanFactory=(DefaultListableBeanFactory)appCtx.getAutowireCapableBeanFactory();
  IDBConnectionPool dbConnectionPool=this.getDBCluster().getDBConnectionPool();
  IContainer<DataSource> dsC=dbConnectionPool.getAllDataSources();
  BeanDefinition dsBean=null;
  DataSource ds=null;
  for (  String key : dsC.keys()) {
    ds=dsC.find(key);
    dsBean=createBeanDef(ds);
    ((AbstractBeanDefinition)dsBean).setDestroyMethodName(""String_Node_Str"");
    beanFactory.registerBeanDefinition(key,dsBean);
    if (LOG.isDebugEnabled()) {
      LOG.debug(""String_Node_Str"",key);
    }
  }
}","@Override public void afterPropertiesSet() throws Exception {
  super.init();
  DefaultListableBeanFactory beanFactory=(DefaultListableBeanFactory)appCtx.getAutowireCapableBeanFactory();
  IDBConnectionPool dbConnectionPool=this.getDBCluster().getDBConnectionPool();
  IContainer<DataSource> dsC=dbConnectionPool.getAllDataSources();
  BeanDefinition dsBean=null;
  DataSource ds=null;
  for (  String key : dsC.keys()) {
    ds=dsC.find(key);
    dsBean=createBeanDef(ds);
    ((AbstractBeanDefinition)dsBean).setDestroyMethodName(""String_Node_Str"");
    beanFactory.registerBeanDefinition(key,dsBean);
    LOG.info(""String_Node_Str"",key);
  }
}",0.964741185296324
90375,"@Override public IDBResource getSlaveGlobalDBResource(String clusterName,String tableName,EnumDBMasterSlave masterSlave) throws DBClusterException {
  DBClusterInfo dbClusterInfo=this.dbClusterInfoC.find(clusterName);
  if (dbClusterInfo == null) {
    throw new DBClusterException(""String_Node_Str"" + clusterName);
  }
  List<DBInfo> slaveDbs=dbClusterInfo.getSlaveGlobalDBInfo();
  if (slaveDbs == null || slaveDbs.isEmpty()) {
    throw new DBClusterException(""String_Node_Str"" + clusterName);
  }
  DBInfo slaveDBInfo=null;
  if (EnumDBMasterSlave.AUTO == masterSlave) {
    slaveDBInfo=slaveDbs.get(r.nextInt(slaveDbs.size() - 1));
  }
 else {
    slaveDBInfo=slaveDbs.get(masterSlave.getValue());
  }
  IDBResource slaveDBResource;
  try {
    ITransaction tx=(ITransaction)txManager.getTransaction();
    slaveDBResource=GlobalDBResource.valueOf(tx,slaveDBInfo,tableName);
  }
 catch (  SQLException e) {
    throw new DBClusterException(e);
  }
catch (  SystemException e) {
    throw new DBOperationException(e);
  }
  return slaveDBResource;
}","@Override public IDBResource getSlaveGlobalDBResource(String clusterName,String tableName,EnumDBMasterSlave masterSlave) throws DBClusterException {
  DBClusterInfo dbClusterInfo=this.dbClusterInfoC.find(clusterName);
  if (dbClusterInfo == null) {
    throw new DBClusterException(""String_Node_Str"" + clusterName);
  }
  List<DBInfo> slaveDbs=dbClusterInfo.getSlaveGlobalDBInfo();
  if (slaveDbs == null || slaveDbs.isEmpty()) {
    throw new DBClusterException(""String_Node_Str"" + clusterName);
  }
  DBInfo slaveDBInfo=null;
  if (EnumDBMasterSlave.AUTO == masterSlave) {
    slaveDBInfo=slaveDbs.get(r.nextInt(slaveDbs.size()));
  }
 else {
    slaveDBInfo=slaveDbs.get(masterSlave.getValue());
  }
  IDBResource slaveDBResource;
  try {
    ITransaction tx=(ITransaction)txManager.getTransaction();
    slaveDBResource=GlobalDBResource.valueOf(tx,slaveDBInfo,tableName);
  }
 catch (  SQLException e) {
    throw new DBClusterException(e);
  }
catch (  SystemException e) {
    throw new DBOperationException(e);
  }
  return slaveDBResource;
}",0.9980970504281635
90376,"/** 
 * 获取集群从库列表.
 * @param clazz 数据对象
 * @param slave 从库号
 */
List<IDBResource> getAllSlaveShardingDBResource(Class<?> clazz,EnumDBMasterSlave slave) throws SQLException, DBClusterException ;","/** 
 * 获取集群从库列表.
 * @param clazz 数据对象
 * @param slave 从库号
 */
List<IDBResource> getAllSlaveShardingDBResource(Class<?> clazz,EnumDBMasterSlave slave) throws SQLException, DBClusterException, SystemException ;",0.9576059850374063
90377,"/** 
 * get all master sharding info.
 * @param tableNum
 * @param clusterName
 * @param tableName
 * @return
 */
List<IDBResource> getAllMasterShardingDBResource(int tableNum,String clusterName,String tableName) throws SQLException, DBClusterException ;","/** 
 * get all master sharding info.
 * @param tableNum
 * @param clusterName
 * @param tableName
 * @return
 */
List<IDBResource> getAllMasterShardingDBResource(int tableNum,String clusterName,String tableName) throws SQLException, SystemException ;",0.9702970297029704
90378,"@Override public DataSource buildDataSource(String driverClass,String userName,String password,String url,Map<String,String> connectParam) throws LoadConfigException {
  BasicDataSource ds=new BasicDataSource();
  ds.setDriverClassName(driverClass);
  ds.setUsername(userName);
  ds.setPassword(password);
  ds.setUrl(url);
  ds.setValidationQuery(""String_Node_Str"");
  for (  Map.Entry<String,String> entry : connectParam.entrySet()) {
    try {
      BeansUtil.setProperty(ds,entry.getKey(),entry.getValue());
    }
 catch (    Exception e) {
      LOG.warn(""String_Node_Str"" + entry);
    }
  }
  return ds;
}","@Override public DataSource buildDataSource(String driverClass,String userName,String password,String url,Map<String,String> connectParam) throws LoadConfigException {
  BasicDataSource ds=new BasicDataSource();
  ds.setDriverClassName(driverClass);
  ds.setUsername(userName);
  ds.setPassword(password);
  ds.setUrl(url);
  ds.setValidationQuery(""String_Node_Str"");
  for (  Map.Entry<String,String> entry : connectParam.entrySet()) {
    try {
      setConnectionParam(ds,entry.getKey(),entry.getValue());
    }
 catch (    Exception e) {
      LOG.warn(""String_Node_Str"" + entry);
    }
  }
  return ds;
}",0.9696969696969696
90379,"@Override public DataSource buildDataSource(String driverClass,String userName,String password,String url,Map<String,String> connectParam) throws LoadConfigException {
  DruidDataSource ds=new DruidDataSource();
  ds.setDriverClassName(driverClass);
  ds.setUsername(userName);
  ds.setPassword(password);
  ds.setUrl(url);
  for (  Map.Entry<String,String> entry : connectParam.entrySet()) {
    if (entry.getKey().equals(""String_Node_Str"")) {
      try {
        BeansUtil.setProperty(ds,entry.getKey(),Class.forName(entry.getValue()).newInstance());
      }
 catch (      Exception e) {
        throw new LoadConfigException(""String_Node_Str"");
      }
    }
 else {
      try {
        BeansUtil.setProperty(ds,entry.getKey(),entry.getValue());
      }
 catch (      Exception e) {
        LOG.warn(""String_Node_Str"" + entry);
      }
    }
  }
  ds.setValidationQuery(""String_Node_Str"");
  return ds;
}","@Override public DataSource buildDataSource(String driverClass,String userName,String password,String url,Map<String,String> connectParam) throws LoadConfigException {
  DruidDataSource ds=new DruidDataSource();
  ds.setDriverClassName(driverClass);
  ds.setUsername(userName);
  ds.setPassword(password);
  ds.setUrl(url);
  for (  Map.Entry<String,String> entry : connectParam.entrySet()) {
    if (entry.getKey().equals(""String_Node_Str"")) {
      try {
        BeansUtil.setProperty(ds,entry.getKey(),Class.forName(entry.getValue()).newInstance());
      }
 catch (      Exception e) {
        throw new LoadConfigException(""String_Node_Str"");
      }
    }
 else {
      try {
        setConnectionParam(ds,entry.getKey(),entry.getValue());
      }
 catch (      Exception e) {
        LOG.warn(""String_Node_Str"" + entry);
      }
    }
  }
  ds.setValidationQuery(""String_Node_Str"");
  return ds;
}",0.9795692987299834
90380,"@Override public ShardingDBResource selectDBResourceFromSlave(String tableName,IShardingKey<?> value,EnumDBMasterSlave slaveNum) throws DBClusterException {
  RouteInfo routeInfo=null;
  try {
    String clusterName=value.getClusterName();
    IClusterRouter router=this.dbRouterC.find(clusterName);
    if (router == null) {
      throw new IllegalStateException(""String_Node_Str"" + clusterName);
    }
    routeInfo=router.select(slaveNum,tableName,value);
  }
 catch (  DBRouteException e) {
    throw new DBClusterException(e);
  }
  String clusterName=routeInfo.getClusterName();
  DBInfo dbInfo=routeInfo.getDbInfo();
  int tableIndex=routeInfo.getTableIndex();
  DBClusterInfo dbClusterInfo=this.dbClusterInfoC.find(clusterName);
  if (dbClusterInfo == null) {
    throw new DBClusterException(""String_Node_Str"" + clusterName + ""String_Node_Str""+ value+ ""String_Node_Str""+ tableName+ ""String_Node_Str""+ slaveNum.getValue());
  }
  DBRegionInfo regionInfo=dbClusterInfo.getDbRegions().get(routeInfo.getRegionIndex());
  if (regionInfo == null) {
    throw new DBClusterException(""String_Node_Str"" + clusterName + ""String_Node_Str""+ value+ ""String_Node_Str""+ tableName+ ""String_Node_Str""+ slaveNum.getValue());
  }
  ShardingDBResource db;
  try {
    db=ShardingDBResource.valueOf(dbInfo,regionInfo,tableName,tableIndex);
  }
 catch (  SQLException e) {
    throw new DBClusterException(e);
  }
  return db;
}","@Override public ShardingDBResource selectDBResourceFromSlave(String tableName,IShardingKey<?> value,EnumDBMasterSlave slaveNum) throws DBClusterException {
  RouteInfo routeInfo=null;
  try {
    String clusterName=value.getClusterName();
    IClusterRouter router=this.dbRouterC.find(clusterName);
    if (router == null) {
      throw new IllegalStateException(""String_Node_Str"" + clusterName);
    }
    routeInfo=router.select(slaveNum,tableName,value);
  }
 catch (  DBRouteException e) {
    throw new DBClusterException(e);
  }
  String clusterName=routeInfo.getClusterName();
  DBInfo dbInfo=routeInfo.getDbInfo();
  int tableIndex=routeInfo.getTableIndex();
  DBClusterInfo dbClusterInfo=this.dbClusterInfoC.find(clusterName);
  if (dbClusterInfo == null) {
    throw new DBClusterException(""String_Node_Str"" + clusterName + ""String_Node_Str""+ value+ ""String_Node_Str""+ tableName+ ""String_Node_Str""+ slaveNum.getValue());
  }
  DBRegionInfo regionInfo=dbClusterInfo.getDbRegions().get(routeInfo.getRegionIndex());
  if (regionInfo == null) {
    throw new DBClusterException(""String_Node_Str"" + clusterName + ""String_Node_Str""+ value+ ""String_Node_Str""+ tableName+ ""String_Node_Str""+ slaveNum.getValue());
  }
  ShardingDBResource db;
  try {
    ITransaction tx=(ITransaction)txManager.getTransaction();
    db=ShardingDBResource.valueOf(tx,dbInfo,regionInfo,tableName,tableIndex);
  }
 catch (  SQLException e) {
    throw new DBClusterException(e);
  }
catch (  SystemException e) {
    throw new DBOperationException(e);
  }
  return db;
}",0.944743935309973
90381,"@Override public IDBResource getMasterGlobalDBResource(String clusterName,String tableName) throws DBClusterException {
  DBClusterInfo dbClusterInfo=this.dbClusterInfoC.find(clusterName);
  if (dbClusterInfo == null) {
    throw new DBClusterException(""String_Node_Str"" + clusterName);
  }
  DBInfo masterDBInfo=dbClusterInfo.getMasterGlobalDBInfo();
  if (masterDBInfo == null) {
    throw new DBClusterException(""String_Node_Str"" + clusterName);
  }
  IDBResource masterDBResource;
  try {
    masterDBResource=GlobalDBResource.valueOf(masterDBInfo,tableName);
  }
 catch (  SQLException e) {
    throw new DBClusterException(e);
  }
  return masterDBResource;
}","@Override public IDBResource getMasterGlobalDBResource(String clusterName,String tableName) throws DBClusterException {
  DBClusterInfo dbClusterInfo=this.dbClusterInfoC.find(clusterName);
  if (dbClusterInfo == null) {
    throw new DBClusterException(""String_Node_Str"" + clusterName);
  }
  DBInfo masterDBInfo=dbClusterInfo.getMasterGlobalDBInfo();
  if (masterDBInfo == null) {
    throw new DBClusterException(""String_Node_Str"" + clusterName);
  }
  IDBResource masterDBResource;
  try {
    ITransaction tx=(ITransaction)txManager.getTransaction();
    masterDBResource=GlobalDBResource.valueOf(tx,masterDBInfo,tableName);
  }
 catch (  SQLException e) {
    throw new DBClusterException(e);
  }
catch (  SystemException e) {
    throw new DBOperationException(e);
  }
  return masterDBResource;
}",0.9059945504087192
90382,"@Override public IDBResource getSlaveGlobalDBResource(String clusterName,String tableName,EnumDBMasterSlave masterSlave) throws DBClusterException {
  DBClusterInfo dbClusterInfo=this.dbClusterInfoC.find(clusterName);
  if (dbClusterInfo == null) {
    throw new DBClusterException(""String_Node_Str"" + clusterName);
  }
  List<DBInfo> slaveDbs=dbClusterInfo.getSlaveGlobalDBInfo();
  if (slaveDbs == null || slaveDbs.isEmpty()) {
    throw new DBClusterException(""String_Node_Str"" + clusterName);
  }
  DBInfo slaveDBInfo=null;
  if (EnumDBMasterSlave.AUTO == masterSlave) {
    slaveDBInfo=slaveDbs.get(r.nextInt(slaveDbs.size() - 1));
  }
 else {
    slaveDBInfo=slaveDbs.get(masterSlave.getValue());
  }
  IDBResource slaveDBResource;
  try {
    slaveDBResource=GlobalDBResource.valueOf(slaveDBInfo,tableName);
  }
 catch (  SQLException e) {
    throw new DBClusterException(e);
  }
  return slaveDBResource;
}","@Override public IDBResource getSlaveGlobalDBResource(String clusterName,String tableName,EnumDBMasterSlave masterSlave) throws DBClusterException {
  DBClusterInfo dbClusterInfo=this.dbClusterInfoC.find(clusterName);
  if (dbClusterInfo == null) {
    throw new DBClusterException(""String_Node_Str"" + clusterName);
  }
  List<DBInfo> slaveDbs=dbClusterInfo.getSlaveGlobalDBInfo();
  if (slaveDbs == null || slaveDbs.isEmpty()) {
    throw new DBClusterException(""String_Node_Str"" + clusterName);
  }
  DBInfo slaveDBInfo=null;
  if (EnumDBMasterSlave.AUTO == masterSlave) {
    slaveDBInfo=slaveDbs.get(r.nextInt(slaveDbs.size() - 1));
  }
 else {
    slaveDBInfo=slaveDbs.get(masterSlave.getValue());
  }
  IDBResource slaveDBResource;
  try {
    ITransaction tx=(ITransaction)txManager.getTransaction();
    slaveDBResource=GlobalDBResource.valueOf(tx,slaveDBInfo,tableName);
  }
 catch (  SQLException e) {
    throw new DBClusterException(e);
  }
catch (  SystemException e) {
    throw new DBOperationException(e);
  }
  return slaveDBResource;
}",0.929878048780488
90383,"/** 
 * get all master sharding info.
 * @param tableNum
 * @param clusterName
 * @param tableName
 * @return
 * @throws SQLException
 */
public List<IDBResource> getAllMasterShardingDBResource(int tableNum,String clusterName,String tableName) throws SQLException {
  List<IDBResource> dbResources=new ArrayList<IDBResource>();
  if (tableNum == 0) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  IDBResource dbResource=null;
  DBClusterInfo dbClusterInfo=this.getDBClusterInfo(clusterName);
  for (  DBRegionInfo region : dbClusterInfo.getDbRegions()) {
    for (    DBInfo dbInfo : region.getMasterDBInfos()) {
      for (int tableIndex=0; tableIndex < tableNum; tableIndex++) {
        dbResource=ShardingDBResource.valueOf(dbInfo,region,tableName,tableIndex);
        dbResources.add(dbResource);
      }
    }
  }
  return dbResources;
}","/** 
 * get all master sharding info.
 * @param tableNum
 * @param clusterName
 * @param tableName
 * @return
 * @throws SQLException
 * @throws SystemException
 */
public List<IDBResource> getAllMasterShardingDBResource(int tableNum,String clusterName,String tableName) throws SQLException, SystemException {
  List<IDBResource> dbResources=new ArrayList<IDBResource>();
  if (tableNum == 0) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  ITransaction tx=(ITransaction)txManager.getTransaction();
  IDBResource dbResource=null;
  DBClusterInfo dbClusterInfo=this.getDBClusterInfo(clusterName);
  for (  DBRegionInfo region : dbClusterInfo.getDbRegions()) {
    for (    DBInfo dbInfo : region.getMasterDBInfos()) {
      for (int tableIndex=0; tableIndex < tableNum; tableIndex++) {
        dbResource=ShardingDBResource.valueOf(tx,dbInfo,region,tableName,tableIndex);
        dbResources.add(dbResource);
      }
    }
  }
  return dbResources;
}",0.918266593527153
90384,"@Override public List<DBTable> getDBTableFromZk(){
  List<DBTable> tables=new ArrayList<DBTable>();
  try {
    ZooKeeper zkClient=this.curatorClient.getZookeeperClient().getZooKeeper();
    List<String> zkTableNodes=zkClient.getChildren(Const.ZK_SHARDINGINFO,false);
    byte[] tableData=null;
    for (    String zkTableNode : zkTableNodes) {
      tableData=zkClient.getData(Const.ZK_SHARDINGINFO + ""String_Node_Str"" + zkTableNode,false,null);
      tables.add(IOUtil.getObject(tableData,DBTable.class));
    }
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
  return tables;
}","@Override public List<DBTable> getDBTableFromZk(){
  List<DBTable> tables=new ArrayList<DBTable>();
  try {
    ZooKeeper zkClient=this.curatorClient.getZookeeperClient().getZooKeeper();
    List<String> zkTableNodes=zkClient.getChildren(Const.ZK_SHARDINGINFO,false);
    byte[] tableData=null;
    for (    String zkTableNode : zkTableNodes) {
      tableData=zkClient.getData(Const.ZK_SHARDINGINFO + ""String_Node_Str"" + zkTableNode,false,null);
      tables.add(IOUtil.getObjectByJava(tableData,DBTable.class));
    }
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
  return tables;
}",0.9950248756218906
90385,"/** 
 * 将表分片信息同步到zookeeper.
 */
private void _syncToZookeeper(List<DBTable> tables) throws Exception {
  try {
    ZooKeeper zkClient=this.curatorClient.getZookeeperClient().getZooKeeper();
    Stat stat=zkClient.exists(Const.ZK_SHARDINGINFO,false);
    if (stat == null) {
      zkClient.create(Const.ZK_SHARDINGINFO,new byte[0],ZooDefs.Ids.OPEN_ACL_UNSAFE,CreateMode.PERSISTENT);
    }
    byte[] tableData=null;
    String tableName=null;
    for (    DBTable table : tables) {
      tableData=IOUtil.getBytes(table);
      tableName=table.getName();
      String zkTableNode=Const.ZK_SHARDINGINFO + ""String_Node_Str"" + tableName;
      stat=zkClient.exists(zkTableNode,false);
      if (stat == null) {
        zkClient.create(zkTableNode,tableData,ZooDefs.Ids.OPEN_ACL_UNSAFE,CreateMode.PERSISTENT);
      }
 else {
        zkClient.setData(zkTableNode,tableData,-1);
      }
    }
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
  LOG.info(""String_Node_Str"");
}","/** 
 * 将表分片信息同步到zookeeper.
 */
private void _syncToZookeeper(List<DBTable> tables) throws Exception {
  try {
    ZooKeeper zkClient=this.curatorClient.getZookeeperClient().getZooKeeper();
    Stat stat=zkClient.exists(Const.ZK_SHARDINGINFO,false);
    if (stat == null) {
      zkClient.create(Const.ZK_SHARDINGINFO,new byte[0],ZooDefs.Ids.OPEN_ACL_UNSAFE,CreateMode.PERSISTENT);
    }
    byte[] tableData=null;
    String tableName=null;
    for (    DBTable table : tables) {
      tableData=IOUtil.getBytesByJava(table);
      tableName=table.getName();
      String zkTableNode=Const.ZK_SHARDINGINFO + ""String_Node_Str"" + tableName;
      stat=zkClient.exists(zkTableNode,false);
      if (stat == null) {
        zkClient.create(zkTableNode,tableData,ZooDefs.Ids.OPEN_ACL_UNSAFE,CreateMode.PERSISTENT);
      }
 else {
        zkClient.setData(zkTableNode,tableData,-1);
      }
    }
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
  LOG.info(""String_Node_Str"");
}",0.996969696969697
90386,"@Override public List<IDBResource> getAllSlaveShardingDBResource(Class<?> clazz,EnumDBMasterSlave masterSlave) throws SQLException, DBClusterException {
  List<IDBResource> dbResources=new ArrayList<IDBResource>();
  int tableNum=entityMetaManager.getTableNum(clazz);
  if (tableNum == 0) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  String clusterName=entityMetaManager.getClusterName(clazz);
  String tableName=entityMetaManager.getTableName(clazz);
  IDBResource dbResource=null;
  DBClusterInfo dbClusterInfo=this.getDBClusterInfo(clusterName);
  for (  DBRegionInfo region : dbClusterInfo.getDbRegions()) {
    List<DBInfo> slaveDBInfos=null;
    if (EnumDBMasterSlave.AUTO == masterSlave) {
      slaveDBInfos=region.getSlaveDBInfos().get(r.nextInt(region.getSlaveDBInfos().size() - 1));
    }
 else {
      slaveDBInfos=region.getSlaveDBInfos().get(masterSlave.getValue());
    }
    if (slaveDBInfos == null || slaveDBInfos.isEmpty()) {
      throw new DBClusterException(""String_Node_Str"" + clusterName);
    }
    for (    DBInfo dbInfo : slaveDBInfos) {
      for (int tableIndex=0; tableIndex < tableNum; tableIndex++) {
        dbResource=ShardingDBResource.valueOf(dbInfo,region,tableName,tableIndex);
        dbResources.add(dbResource);
      }
    }
  }
  return dbResources;
}","@Override public List<IDBResource> getAllSlaveShardingDBResource(Class<?> clazz,EnumDBMasterSlave masterSlave) throws SQLException, DBClusterException, SystemException {
  List<IDBResource> dbResources=new ArrayList<IDBResource>();
  int tableNum=entityMetaManager.getTableNum(clazz);
  if (tableNum == 0) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  String clusterName=entityMetaManager.getClusterName(clazz);
  String tableName=entityMetaManager.getTableName(clazz);
  ITransaction tx=(ITransaction)txManager.getTransaction();
  IDBResource dbResource=null;
  DBClusterInfo dbClusterInfo=this.getDBClusterInfo(clusterName);
  for (  DBRegionInfo region : dbClusterInfo.getDbRegions()) {
    List<DBInfo> slaveDBInfos=null;
    if (EnumDBMasterSlave.AUTO == masterSlave) {
      slaveDBInfos=region.getSlaveDBInfos().get(r.nextInt(region.getSlaveDBInfos().size() - 1));
    }
 else {
      slaveDBInfos=region.getSlaveDBInfos().get(masterSlave.getValue());
    }
    if (slaveDBInfos == null || slaveDBInfos.isEmpty()) {
      throw new DBClusterException(""String_Node_Str"" + clusterName);
    }
    for (    DBInfo dbInfo : slaveDBInfos) {
      for (int tableIndex=0; tableIndex < tableNum; tableIndex++) {
        dbResource=ShardingDBResource.valueOf(tx,dbInfo,region,tableName,tableIndex);
        dbResources.add(dbResource);
      }
    }
  }
  return dbResources;
}",0.9615668883961568
90387,"@Override public ShardingDBResource selectDBResourceFromMaster(String tableName,IShardingKey<?> value) throws DBClusterException {
  RouteInfo routeInfo=null;
  try {
    String clusterName=value.getClusterName();
    IClusterRouter router=this.dbRouterC.find(clusterName);
    if (router == null) {
      throw new IllegalStateException(""String_Node_Str"" + clusterName);
    }
    routeInfo=router.select(EnumDBMasterSlave.MASTER,tableName,value);
  }
 catch (  DBRouteException e) {
    throw new DBClusterException(e);
  }
  String clusterName=routeInfo.getClusterName();
  DBInfo dbInfo=routeInfo.getDbInfo();
  int tableIndex=routeInfo.getTableIndex();
  DBClusterInfo dbClusterInfo=this.dbClusterInfoC.find(clusterName);
  if (dbClusterInfo == null) {
    throw new DBClusterException(""String_Node_Str"" + value + ""String_Node_Str""+ tableName);
  }
  DBRegionInfo regionInfo=dbClusterInfo.getDbRegions().get(routeInfo.getRegionIndex());
  if (regionInfo == null) {
    throw new DBClusterException(""String_Node_Str"" + value + ""String_Node_Str""+ tableName);
  }
  ShardingDBResource db;
  try {
    db=ShardingDBResource.valueOf(dbInfo,regionInfo,tableName,tableIndex);
  }
 catch (  SQLException e) {
    throw new DBClusterException(e);
  }
  return db;
}","@Override public ShardingDBResource selectDBResourceFromMaster(String tableName,IShardingKey<?> value) throws DBClusterException {
  RouteInfo routeInfo=null;
  try {
    String clusterName=value.getClusterName();
    IClusterRouter router=this.dbRouterC.find(clusterName);
    if (router == null) {
      throw new IllegalStateException(""String_Node_Str"" + clusterName);
    }
    routeInfo=router.select(EnumDBMasterSlave.MASTER,tableName,value);
  }
 catch (  DBRouteException e) {
    throw new DBClusterException(e);
  }
  String clusterName=routeInfo.getClusterName();
  DBInfo dbInfo=routeInfo.getDbInfo();
  int tableIndex=routeInfo.getTableIndex();
  DBClusterInfo dbClusterInfo=this.dbClusterInfoC.find(clusterName);
  if (dbClusterInfo == null) {
    throw new DBClusterException(""String_Node_Str"" + value + ""String_Node_Str""+ tableName);
  }
  DBRegionInfo regionInfo=dbClusterInfo.getDbRegions().get(routeInfo.getRegionIndex());
  if (regionInfo == null) {
    throw new DBClusterException(""String_Node_Str"" + value + ""String_Node_Str""+ tableName);
  }
  ShardingDBResource db;
  try {
    ITransaction tx=(ITransaction)txManager.getTransaction();
    db=ShardingDBResource.valueOf(tx,dbInfo,regionInfo,tableName,tableIndex);
  }
 catch (  SQLException e) {
    throw new DBClusterException(e);
  }
catch (  SystemException e) {
    throw new DBOperationException(e);
  }
  return db;
}",0.938345864661654
90388,"/** 
 * singleton
 * @param dbInfo
 * @return
 */
public static IDBResource valueOf(DBInfo dbInfo,String tableName) throws SQLException {
  IResourceId resId=new DBResourceId(dbInfo.getClusterName(),dbInfo.getDbName(),tableName,dbInfo.getMasterSlave());
  GlobalDBResource instance=(GlobalDBResource)DBResourceCache.getGlobalDBResource(resId);
  Connection conn=dbInfo.getDatasource().getConnection();
  conn.setAutoCommit(false);
  if (instance == null) {
    instance=new GlobalDBResource();
    instance.setId(resId);
    instance.setClusterName(dbInfo.getClusterName());
    instance.setDbName(dbInfo.getDbName());
    instance.setMasterSlave(dbInfo.getMasterSlave());
    DatabaseMetaData dbMeta=conn.getMetaData();
    String databaseProductName=dbMeta.getDatabaseProductName();
    String url=dbMeta.getURL().substring(13);
    String host=url.substring(0,url.indexOf(""String_Node_Str""));
    String catalog=conn.getCatalog();
    instance.setDatabaseProductName(databaseProductName);
    instance.setHost(host);
    instance.setCatalog(catalog);
    DBResourceCache.putGlobalDBResource(resId,instance);
  }
  instance.setConnection(conn);
  return instance;
}","/** 
 * singleton
 * @param dbInfo
 * @return
 */
public static IDBResource valueOf(ITransaction tx,DBInfo dbInfo,String tableName) throws SQLException {
  IResourceId resId=new DBResourceId(dbInfo.getClusterName(),dbInfo.getDbName(),tableName,dbInfo.getMasterSlave());
  GlobalDBResource dbResource=null;
  if (tx != null && tx.isContain(resId)) {
    dbResource=(GlobalDBResource)tx.getDBResource(resId);
  }
 else {
    dbResource=(GlobalDBResource)DBResourceCache.getGlobalDBResource(resId);
    Connection conn=dbInfo.getDatasource().getConnection();
    conn.setAutoCommit(false);
    if (dbResource == null) {
      dbResource=new GlobalDBResource();
      dbResource.setId(resId);
      dbResource.setClusterName(dbInfo.getClusterName());
      dbResource.setDbName(dbInfo.getDbName());
      dbResource.setMasterSlave(dbInfo.getMasterSlave());
      DatabaseMetaData dbMeta=conn.getMetaData();
      String databaseProductName=dbMeta.getDatabaseProductName();
      String url=dbMeta.getURL().substring(13);
      String host=url.substring(0,url.indexOf(""String_Node_Str""));
      String catalog=conn.getCatalog();
      dbResource.setDatabaseProductName(databaseProductName);
      dbResource.setHost(host);
      dbResource.setCatalog(catalog);
      DBResourceCache.putGlobalDBResource(resId,dbResource);
    }
    dbResource.setConnection(conn);
  }
  return dbResource;
}",0.8213166144200627
90389,"@Override public void closeDataSource(DBInfo dbInfo){
  dbConnectionPool.releaseDataSource(dbInfo.getDatasource());
}","@Override public void closeDataSource(DBInfo dbInfo){
  if (dbInfo instanceof AppDBInfo) {
    dbConnectionPool.releaseDataSource(dbInfo.getDatasource());
  }
 else   if (dbInfo instanceof EnvDBInfo) {
  }
}",0.7222222222222222
90390,"/** 
 * 构造方法.
 * @param enumDb 数据库类型
 */
public DBClusterImpl(EnumDB enumDb,IDBConnectionPool dbConnectionPool){
  super(enumDb);
  this.dbConnectionPool=dbConnectionPool;
}","/** 
 * 构造方法.
 * @param enumDb 数据库类型
 */
public DBClusterImpl(EnumDB enumDb,IDBConnectionPool dbConnectionPool){
  super(enumDb);
  this.dbConnectionPool=dbConnectionPool;
  try {
    this.initCtx=new InitialContext();
  }
 catch (  NamingException e) {
    throw new RuntimeException(e);
  }
}",0.7408993576017131
90391,"@Override public void buildDataSource(DBInfo dbConnInfo) throws LoadConfigException {
  AppDBInfo appDBInfo=(AppDBInfo)dbConnInfo;
  LOG.info(dbConnInfo.toString());
  DataSource ds=this.dbConnectionPool.buildDataSource(enumDb.getDriverClass(),appDBInfo.getUsername(),appDBInfo.getPassword(),appDBInfo.getUrl(),appDBInfo.getConnPoolInfo());
  dbConnInfo.setDatasource(ds);
}","@Override public void buildDataSource(DBInfo dbConnInfo) throws LoadConfigException {
  LOG.info(dbConnInfo.toString());
  DataSource ds=null;
  if (dbConnInfo instanceof AppDBInfo) {
    AppDBInfo appDBInfo=(AppDBInfo)dbConnInfo;
    ds=this.dbConnectionPool.buildDataSource(enumDb.getDriverClass(),appDBInfo.getUsername(),appDBInfo.getPassword(),appDBInfo.getUrl(),appDBInfo.getConnPoolInfo());
  }
 else   if (dbConnInfo instanceof EnvDBInfo) {
    EnvDBInfo envDbConnInfo=(EnvDBInfo)dbConnInfo;
    try {
      ds=(DataSource)this.initCtx.lookup(envDbConnInfo.getEnvDsName());
    }
 catch (    NamingException e) {
      throw new LoadConfigException(""String_Node_Str"" + envDbConnInfo.getEnvDsName());
    }
  }
 else {
    throw new LoadConfigException(""String_Node_Str"" + dbConnInfo.getClass());
  }
  dbConnInfo.setDatasource(ds);
}",0.4958813838550247
90392,"/** 
 * 读取分片缓存.
 * @param query 查询条件
 * @return 结果集.
 */
public List get(String whereSql,ShardingDBResource db);","/** 
 * 读取分片缓存.
 * @param query 查询条件
 * @return 结果集.
 */
public List get(String whereKey,ShardingDBResource db);",0.9732142857142856
90393,"/** 
 * 添加到全局缓存
 * @param query 查询条件
 * @param clusterName 集群名
 * @param clazz 对象class
 */
public void putGlobal(String whereSql,String clusterName,String tableName,List data);","/** 
 * 添加到全局缓存
 * @param query 查询条件
 * @param clusterName 集群名
 * @param clazz 对象class
 */
public void putGlobal(String whereKey,String clusterName,String tableName,List data);",0.9829545454545454
90394,"/** 
 * 读取全局缓存
 * @param query 查询条件
 * @param clusterName 集群名
 * @param clazz 对象class
 * @return 结果集
 */
public List getGlobal(String whereSql,String clusterName,String tableName);","/** 
 * 读取全局缓存
 * @param query 查询条件
 * @param clusterName 集群名
 * @param clazz 对象class
 * @return 结果集
 */
public List getGlobal(String whereKey,String clusterName,String tableName);",0.9833333333333332
90395,"/** 
 * 添加到分片缓存.
 * @param query 查询条件
 * @param data 结果集
 */
public void put(String whereSql,ShardingDBResource db,List data);","/** 
 * 添加到分片缓存.
 * @param query 查询条件
 * @param data 结果集
 */
public void put(String whereKey,ShardingDBResource db,List data);",0.9761904761904762
90396,"@Override public List get(String whereSql,ShardingDBResource db){
  if (StringUtil.isBlank(whereSql)) {
    return null;
  }
  try {
    String versionKey=_buildShardingVersion(db);
    if (_exists(versionKey)) {
      int version=Integer.parseInt((String)this.memClient.get(versionKey));
      String cacheKey=_buildShardingCacheKey(whereSql,db,version);
      List data=(List)this.memClient.get(cacheKey);
      if (LOG.isDebugEnabled() && data != null) {
        LOG.debug(""String_Node_Str"" + cacheKey + ""String_Node_Str"");
      }
      return data;
    }
  }
 catch (  Exception e) {
    LOG.warn(""String_Node_Str"");
  }
  return null;
}","@Override public List get(String whereKey,ShardingDBResource db){
  if (StringUtil.isBlank(whereKey)) {
    return null;
  }
  try {
    String versionKey=_buildShardingVersion(db);
    if (_exists(versionKey)) {
      int version=Integer.parseInt((String)this.memClient.get(versionKey));
      String cacheKey=_buildShardingCacheKey(whereKey,db,version);
      List data=(List)this.memClient.get(cacheKey);
      if (LOG.isDebugEnabled() && data != null) {
        LOG.debug(""String_Node_Str"" + cacheKey + ""String_Node_Str"");
      }
      return data;
    }
  }
 catch (  Exception e) {
    LOG.warn(""String_Node_Str"");
  }
  return null;
}",0.985981308411215
90397,"@Override public void putGlobal(String whereSql,String clusterName,String tableName,List data){
  if (StringUtil.isBlank(whereSql) || data == null || data.isEmpty()) {
    return;
  }
  try {
    String versionKey=_buildGlobalVersion(clusterName,tableName);
    int version=r.nextInt(10000);
    if (!_exists(versionKey)) {
      this.memClient.incr(versionKey,0,version);
    }
 else {
      version=Integer.parseInt((String)this.memClient.get(versionKey));
    }
    String cacheKey=_buildGlobalCacheKey(whereSql,clusterName,tableName,version);
    this.memClient.set(cacheKey,expire,data);
    if (LOG.isDebugEnabled()) {
      LOG.debug(""String_Node_Str"" + cacheKey);
    }
  }
 catch (  Exception e) {
    LOG.warn(""String_Node_Str"");
  }
}","@Override public void putGlobal(String whereKey,String clusterName,String tableName,List data){
  if (StringUtil.isBlank(whereKey) || data == null || data.isEmpty()) {
    return;
  }
  try {
    String versionKey=_buildGlobalVersion(clusterName,tableName);
    int version=r.nextInt(10000);
    if (!_exists(versionKey)) {
      this.memClient.incr(versionKey,0,version);
    }
 else {
      version=Integer.parseInt((String)this.memClient.get(versionKey));
    }
    String cacheKey=_buildGlobalCacheKey(whereKey,clusterName,tableName,version);
    this.memClient.set(cacheKey,expire,data);
    if (LOG.isDebugEnabled()) {
      LOG.debug(""String_Node_Str"" + cacheKey);
    }
  }
 catch (  Exception e) {
    LOG.warn(""String_Node_Str"");
  }
}",0.9879194630872484
90398,"@Override public List getGlobal(String whereSql,String clusterName,String tableName){
  if (StringUtil.isBlank(whereSql)) {
    return null;
  }
  try {
    String versionKey=_buildGlobalVersion(clusterName,tableName);
    if (_exists(versionKey)) {
      int version=Integer.parseInt((String)this.memClient.get(versionKey));
      String cacheKey=_buildGlobalCacheKey(whereSql,clusterName,tableName,version);
      List data=(List)this.memClient.get(cacheKey);
      if (LOG.isDebugEnabled() && data != null) {
        LOG.debug(""String_Node_Str"" + cacheKey + ""String_Node_Str"");
      }
      return data;
    }
  }
 catch (  Exception e) {
    LOG.warn(""String_Node_Str"");
  }
  return null;
}","@Override public List getGlobal(String whereKey,String clusterName,String tableName){
  if (StringUtil.isBlank(whereKey)) {
    return null;
  }
  try {
    String versionKey=_buildGlobalVersion(clusterName,tableName);
    if (_exists(versionKey)) {
      int version=Integer.parseInt((String)this.memClient.get(versionKey));
      String cacheKey=_buildGlobalCacheKey(whereKey,clusterName,tableName,version);
      List data=(List)this.memClient.get(cacheKey);
      if (LOG.isDebugEnabled() && data != null) {
        LOG.debug(""String_Node_Str"" + cacheKey + ""String_Node_Str"");
      }
      return data;
    }
  }
 catch (  Exception e) {
    LOG.warn(""String_Node_Str"");
  }
  return null;
}",0.9870689655172412
90399,"/** 
 * sharding second cache key. sec.[clustername].[startend].[tablename + tableIndex].[version].hashCode
 */
private String _buildShardingCacheKey(String whereSql,ShardingDBResource shardingDBResource,int version){
  StringBuilder cacheKey=new StringBuilder(""String_Node_Str"");
  cacheKey.append(shardingDBResource.getClusterName());
  cacheKey.append(""String_Node_Str"");
  cacheKey.append(shardingDBResource.getDbName());
  cacheKey.append(""String_Node_Str"");
  cacheKey.append(shardingDBResource.getRegionCapacity());
  cacheKey.append(""String_Node_Str"");
  cacheKey.append(shardingDBResource.getTableName()).append(shardingDBResource.getTableIndex());
  cacheKey.append(""String_Node_Str"");
  cacheKey.append(version).append(""String_Node_Str"");
  cacheKey.append(SecurityUtil.md5(whereSql));
  return cacheKey.toString();
}","/** 
 * sharding second cache key. sec.[clustername].[startend].[tablename + tableIndex].[version].hashCode
 */
private String _buildShardingCacheKey(String whereKey,ShardingDBResource shardingDBResource,int version){
  StringBuilder cacheKey=new StringBuilder(""String_Node_Str"");
  cacheKey.append(shardingDBResource.getClusterName());
  cacheKey.append(""String_Node_Str"");
  cacheKey.append(shardingDBResource.getDbName());
  cacheKey.append(""String_Node_Str"");
  cacheKey.append(shardingDBResource.getRegionCapacity());
  cacheKey.append(""String_Node_Str"");
  cacheKey.append(shardingDBResource.getTableName()).append(shardingDBResource.getTableIndex());
  cacheKey.append(""String_Node_Str"");
  cacheKey.append(version).append(""String_Node_Str"");
  cacheKey.append(SecurityUtil.md5(whereKey));
  return cacheKey.toString();
}",0.9927536231884058
90400,"/** 
 * global second cache key. sec.[clustername].[tablename].[version].hashCode
 */
private String _buildGlobalCacheKey(String whereSql,String clusterName,String tableName,int version){
  StringBuilder cacheKey=new StringBuilder(""String_Node_Str"");
  cacheKey.append(clusterName).append(""String_Node_Str"");
  cacheKey.append(tableName).append(""String_Node_Str"");
  cacheKey.append(version).append(""String_Node_Str"");
  cacheKey.append(SecurityUtil.md5(whereSql));
  return cacheKey.toString();
}","/** 
 * global second cache key. sec.[clustername].[tablename].[version].hashCode
 */
private String _buildGlobalCacheKey(String whereKey,String clusterName,String tableName,int version){
  StringBuilder cacheKey=new StringBuilder(""String_Node_Str"");
  cacheKey.append(clusterName).append(""String_Node_Str"");
  cacheKey.append(tableName).append(""String_Node_Str"");
  cacheKey.append(version).append(""String_Node_Str"");
  cacheKey.append(SecurityUtil.md5(whereKey));
  return cacheKey.toString();
}",0.9879275653923542
90401,"@Override public void put(String whereSql,ShardingDBResource db,List data){
  if (StringUtil.isBlank(whereSql) || data == null || data.isEmpty()) {
    return;
  }
  try {
    String versionKey=_buildShardingVersion(db);
    int version=r.nextInt(10000);
    if (!_exists(versionKey)) {
      this.memClient.incr(versionKey,0,version);
    }
 else {
      version=Integer.parseInt((String)this.memClient.get(versionKey));
    }
    String cacheKey=_buildShardingCacheKey(whereSql,db,version);
    this.memClient.set(cacheKey,expire,data);
    if (LOG.isDebugEnabled()) {
      LOG.debug(""String_Node_Str"" + cacheKey);
    }
  }
 catch (  Exception e) {
    LOG.warn(""String_Node_Str"");
  }
}","@Override public void put(String whereKey,ShardingDBResource db,List data){
  if (StringUtil.isBlank(whereKey) || data == null || data.isEmpty()) {
    return;
  }
  try {
    String versionKey=_buildShardingVersion(db);
    int version=r.nextInt(10000);
    if (!_exists(versionKey)) {
      this.memClient.incr(versionKey,0,version);
    }
 else {
      version=Integer.parseInt((String)this.memClient.get(versionKey));
    }
    String cacheKey=_buildShardingCacheKey(whereKey,db,version);
    this.memClient.set(cacheKey,expire,data);
    if (LOG.isDebugEnabled()) {
      LOG.debug(""String_Node_Str"" + cacheKey);
    }
  }
 catch (  Exception e) {
    LOG.warn(""String_Node_Str"");
  }
}",0.9869753979739508
90402,"@Override public List get(String whereSql,ShardingDBResource db){
  if (StringUtil.isBlank(whereSql)) {
    return null;
  }
  ShardedJedis redisClient=null;
  try {
    redisClient=jedisPool.getResource();
    String cacheKey=_buildShardingCacheKey(whereSql,db);
    List data=IOUtil.getObject(redisClient.get(cacheKey.getBytes()),List.class);
    if (LOG.isDebugEnabled() && data != null) {
      LOG.debug(""String_Node_Str"" + cacheKey + ""String_Node_Str"");
    }
    return data;
  }
 catch (  Exception e) {
    LOG.warn(""String_Node_Str"");
  }
 finally {
    if (redisClient != null)     redisClient.close();
  }
  return null;
}","@Override public List get(String whereKey,ShardingDBResource db){
  if (StringUtil.isBlank(whereKey)) {
    return null;
  }
  ShardedJedis redisClient=null;
  try {
    redisClient=jedisPool.getResource();
    String cacheKey=_buildShardingCacheKey(whereKey,db);
    List data=IOUtil.getObject(redisClient.get(cacheKey.getBytes()),List.class);
    if (LOG.isDebugEnabled() && data != null) {
      LOG.debug(""String_Node_Str"" + cacheKey + ""String_Node_Str"");
    }
    return data;
  }
 catch (  Exception e) {
    LOG.warn(""String_Node_Str"");
  }
 finally {
    if (redisClient != null)     redisClient.close();
  }
  return null;
}",0.9858044164037856
90403,"@Override public void putGlobal(String whereSql,String clusterName,String tableName,List data){
  if (StringUtil.isBlank(whereSql) || data == null || data.isEmpty()) {
    return;
  }
  ShardedJedis redisClient=null;
  try {
    redisClient=jedisPool.getResource();
    String cacheKey=_buildGlobalCacheKey(whereSql,clusterName,tableName);
    redisClient.set(cacheKey.getBytes(),IOUtil.getBytes(data));
    redisClient.expire(cacheKey.getBytes(),expire);
    if (LOG.isDebugEnabled()) {
      LOG.debug(""String_Node_Str"" + cacheKey);
    }
  }
 catch (  Exception e) {
    LOG.warn(""String_Node_Str"");
  }
 finally {
    if (redisClient != null)     redisClient.close();
  }
}","@Override public void putGlobal(String whereKey,String clusterName,String tableName,List data){
  if (StringUtil.isBlank(whereKey) || data == null || data.isEmpty()) {
    return;
  }
  ShardedJedis redisClient=null;
  try {
    redisClient=jedisPool.getResource();
    String cacheKey=_buildGlobalCacheKey(whereKey,clusterName,tableName);
    redisClient.set(cacheKey.getBytes(),IOUtil.getBytes(data));
    redisClient.expire(cacheKey.getBytes(),expire);
    if (LOG.isDebugEnabled()) {
      LOG.debug(""String_Node_Str"" + cacheKey);
    }
  }
 catch (  Exception e) {
    LOG.warn(""String_Node_Str"");
  }
 finally {
    if (redisClient != null)     redisClient.close();
  }
}",0.9867060561299852
90404,"@Override public List getGlobal(String whereSql,String clusterName,String tableName){
  if (StringUtil.isBlank(whereSql)) {
    return null;
  }
  ShardedJedis redisClient=null;
  try {
    redisClient=jedisPool.getResource();
    String cacheKey=_buildGlobalCacheKey(whereSql,clusterName,tableName);
    List data=IOUtil.getObject(redisClient.get(cacheKey.getBytes()),List.class);
    if (LOG.isDebugEnabled() && data != null) {
      LOG.debug(""String_Node_Str"" + cacheKey + ""String_Node_Str"");
    }
    return data;
  }
 catch (  Exception e) {
    e.printStackTrace();
    LOG.warn(""String_Node_Str"");
  }
 finally {
    if (redisClient != null)     redisClient.close();
  }
  return null;
}","@Override public List getGlobal(String whereKey,String clusterName,String tableName){
  if (StringUtil.isBlank(whereKey)) {
    return null;
  }
  ShardedJedis redisClient=null;
  try {
    redisClient=jedisPool.getResource();
    String cacheKey=_buildGlobalCacheKey(whereKey,clusterName,tableName);
    List data=IOUtil.getObject(redisClient.get(cacheKey.getBytes()),List.class);
    if (LOG.isDebugEnabled() && data != null) {
      LOG.debug(""String_Node_Str"" + cacheKey + ""String_Node_Str"");
    }
    return data;
  }
 catch (  Exception e) {
    e.printStackTrace();
    LOG.warn(""String_Node_Str"");
  }
 finally {
    if (redisClient != null)     redisClient.close();
  }
  return null;
}",0.9870689655172412
90405,"/** 
 * sharding second cache key. sec.[clustername].[startend].[tablename + tableIndex].hashCode
 */
private String _buildShardingCacheKey(String whereSql,ShardingDBResource shardingDBResource){
  StringBuilder cacheKey=new StringBuilder(""String_Node_Str"");
  cacheKey.append(shardingDBResource.getClusterName());
  cacheKey.append(""String_Node_Str"");
  cacheKey.append(shardingDBResource.getDbName());
  cacheKey.append(""String_Node_Str"");
  cacheKey.append(shardingDBResource.getRegionCapacity());
  cacheKey.append(""String_Node_Str"");
  cacheKey.append(shardingDBResource.getTableName()).append(shardingDBResource.getTableIndex());
  cacheKey.append(""String_Node_Str"");
  if (StringUtil.isNotBlank(whereSql))   cacheKey.append(SecurityUtil.md5(whereSql));
 else   cacheKey.append(""String_Node_Str"");
  return cacheKey.toString();
}","/** 
 * sharding second cache key. sec.[clustername].[startend].[tablename + tableIndex].hashCode
 */
private String _buildShardingCacheKey(String whereKey,ShardingDBResource shardingDBResource){
  StringBuilder cacheKey=new StringBuilder(""String_Node_Str"");
  cacheKey.append(shardingDBResource.getClusterName());
  cacheKey.append(""String_Node_Str"");
  cacheKey.append(shardingDBResource.getDbName());
  cacheKey.append(""String_Node_Str"");
  cacheKey.append(shardingDBResource.getRegionCapacity());
  cacheKey.append(""String_Node_Str"");
  cacheKey.append(shardingDBResource.getTableName()).append(shardingDBResource.getTableIndex());
  cacheKey.append(""String_Node_Str"");
  if (StringUtil.isNotBlank(whereKey))   cacheKey.append(SecurityUtil.md5(whereKey));
 else   cacheKey.append(""String_Node_Str"");
  return cacheKey.toString();
}",0.9892215568862276
90406,"/** 
 * global second cache key. sec.[clustername].[tablename].hashCode
 */
private String _buildGlobalCacheKey(String whereSql,String clusterName,String tableName){
  StringBuilder cacheKey=new StringBuilder(""String_Node_Str"");
  cacheKey.append(clusterName).append(""String_Node_Str"");
  cacheKey.append(tableName).append(""String_Node_Str"");
  if (StringUtil.isNotBlank(whereSql))   cacheKey.append(SecurityUtil.md5(whereSql));
 else   cacheKey.append(""String_Node_Str"");
  return cacheKey.toString();
}","/** 
 * global second cache key. sec.[clustername].[tablename].hashCode
 */
private String _buildGlobalCacheKey(String whereKey,String clusterName,String tableName){
  StringBuilder cacheKey=new StringBuilder(""String_Node_Str"");
  cacheKey.append(clusterName).append(""String_Node_Str"");
  cacheKey.append(tableName).append(""String_Node_Str"");
  if (StringUtil.isNotBlank(whereKey))   cacheKey.append(SecurityUtil.md5(whereKey));
 else   cacheKey.append(""String_Node_Str"");
  return cacheKey.toString();
}",0.9821428571428572
90407,"@Override public void put(String whereSql,ShardingDBResource db,List data){
  if (StringUtil.isBlank(whereSql) || data == null || data.isEmpty()) {
    return;
  }
  ShardedJedis redisClient=null;
  try {
    redisClient=jedisPool.getResource();
    String cacheKey=_buildShardingCacheKey(whereSql,db);
    redisClient.set(cacheKey.getBytes(),IOUtil.getBytes(data));
    redisClient.expire(cacheKey.getBytes(),expire);
    if (LOG.isDebugEnabled()) {
      LOG.debug(""String_Node_Str"" + cacheKey);
    }
  }
 catch (  Exception e) {
    LOG.warn(""String_Node_Str"");
  }
 finally {
    if (redisClient != null)     redisClient.close();
  }
}","@Override public void put(String whereKey,ShardingDBResource db,List data){
  if (StringUtil.isBlank(whereKey) || data == null || data.isEmpty()) {
    return;
  }
  ShardedJedis redisClient=null;
  try {
    redisClient=jedisPool.getResource();
    String cacheKey=_buildShardingCacheKey(whereKey,db);
    redisClient.set(cacheKey.getBytes(),IOUtil.getBytes(data));
    redisClient.expire(cacheKey.getBytes(),expire);
    if (LOG.isDebugEnabled()) {
      LOG.debug(""String_Node_Str"" + cacheKey);
    }
  }
 catch (  Exception e) {
    LOG.warn(""String_Node_Str"");
  }
 finally {
    if (redisClient != null)     redisClient.close();
  }
}",0.9859375
90408,"/** 
 * 获取实体的自增主键信息，如果没有则返回null;
 * @return
 */
public DBTablePK getNotUnionPrimaryKey(Class<?> clazz);","/** 
 * 获取实体的非联合主键信息，如果没有则返回null;
 * @return
 */
public DBTablePK getNotUnionPrimaryKey(Class<?> clazz);",0.9758454106280192
90409,"/** 
 * 获取联合主键的主键名
 * @param clazz
 * @return
 */
public PKName getNotUnionPkName(Class<?> clazz);","/** 
 * 获取非联合主键的主键名
 * @param clazz
 * @return
 */
public PKName getNotUnionPkName(Class<?> clazz);",0.9949238578680204
90410,"/** 
 * 将数据转换为数据对象
 * @param clazz 数据对象
 * @param rs 结果集
 * @return {pkValue, Object}
 * @throws SQLException
 */
public static <T>Map<EntityPK,T> createResultObjectAsMap(Class<T> clazz,ResultSet rs) throws SQLException {
  Map<EntityPK,T> map=Maps.newLinkedHashMap();
  ResultSetMetaData rsmd=rs.getMetaData();
  T one=null;
  String fieldName=null;
  PKName[] pkNames=entityMetaManager.getPkName(clazz);
  PKValue[] pkValues=null;
  Field f=null;
  Object value=null;
  while (rs.next()) {
    try {
      one=(T)clazz.newInstance();
      for (int i=1; i <= rsmd.getColumnCount(); i++) {
        fieldName=rsmd.getColumnName(i);
        f=BeansUtil.getField(clazz,fieldName);
        value=_getRsValue(rs,f,i);
        BeansUtil.setProperty(one,fieldName,value);
      }
      pkValues=new PKValue[pkNames.length];
      for (int i=0; i < pkNames.length; i++) {
        pkValues[i]=PKValue.valueOf(rs.getObject(pkNames[i].getValue()));
      }
      map.put(EntityPK.valueOf(pkNames,pkValues),one);
    }
 catch (    Exception e) {
      throw new SQLException(e);
    }
  }
  return map;
}","/** 
 * 将数据转换为数据对象
 * @param clazz 数据对象
 * @param rs 结果集
 * @return {pkValue, Object}
 * @throws SQLException
 */
public static <T>Map<EntityPK,T> createResultObjectAsMap(Class<T> clazz,ResultSet rs) throws SQLException {
  Map<EntityPK,T> map=Maps.newLinkedHashMap();
  ResultSetMetaData rsmd=rs.getMetaData();
  T one=null;
  String fieldName=null;
  PKName[] pkNames=entityMetaManager.getPkName(clazz);
  PKValue[] pkValues=null;
  Field f=null;
  Object value=null;
  while (rs.next()) {
    try {
      one=(T)clazz.newInstance();
      for (int i=1; i <= rsmd.getColumnCount(); i++) {
        fieldName=rsmd.getColumnName(i);
        f=BeansUtil.getField(clazz,fieldName);
        if (f == null) {
          continue;
        }
        value=_getRsValue(rs,f,i);
        BeansUtil.setProperty(one,fieldName,value);
      }
      pkValues=new PKValue[pkNames.length];
      for (int i=0; i < pkNames.length; i++) {
        pkValues[i]=PKValue.valueOf(rs.getObject(pkNames[i].getValue()));
      }
      map.put(EntityPK.valueOf(pkNames,pkValues),one);
    }
 catch (    Exception e) {
      throw new SQLException(e);
    }
  }
  return map;
}",0.9754573850959392
90411,"/** 
 * 给定数据库查询结果集创建数据对性.
 * @param clazz 数据对象class
 * @param rs 数据库查询结果集
 * @return 数据对象列表
 */
public static <T>List<T> createResultObject(Class<T> clazz,ResultSet rs) throws SQLException {
  List<T> list=new ArrayList<T>();
  ResultSetMetaData rsmd=rs.getMetaData();
  T one=null;
  while (rs.next()) {
    try {
      one=(T)clazz.newInstance();
      String fieldName=null;
      Field f=null;
      Object value=null;
      for (int i=1; i <= rsmd.getColumnCount(); i++) {
        fieldName=rsmd.getColumnName(i);
        f=BeansUtil.getField(clazz,fieldName);
        value=_getRsValue(rs,f,i);
        BeansUtil.setProperty(one,fieldName,value);
      }
      list.add(one);
    }
 catch (    Exception e) {
      throw new SQLException(e);
    }
  }
  return list;
}","/** 
 * 给定数据库查询结果集创建数据对性.
 * @param clazz 数据对象class
 * @param rs 数据库查询结果集
 * @return 数据对象列表
 */
public static <T>List<T> createResultObject(Class<T> clazz,ResultSet rs) throws SQLException {
  List<T> list=new ArrayList<T>();
  ResultSetMetaData rsmd=rs.getMetaData();
  T one=null;
  while (rs.next()) {
    try {
      one=(T)clazz.newInstance();
      String fieldName=null;
      Field f=null;
      Object value=null;
      for (int i=1; i <= rsmd.getColumnCount(); i++) {
        fieldName=rsmd.getColumnName(i);
        f=BeansUtil.getField(clazz,fieldName);
        if (f == null) {
          continue;
        }
        value=_getRsValue(rs,f,i);
        BeansUtil.setProperty(one,fieldName,value);
      }
      list.add(one);
    }
 catch (    Exception e) {
      throw new SQLException(e);
    }
  }
  return list;
}",0.9656893325015596
90412,"/** 
 * 获取多条记录.
 * @param db 分库分表
 * @param ids 主键
 * @return 多条数据
 */
public <T>List<T> get(ShardingDBResource db,EntityPK[] ids);","/** 
 * 获取多条记录.
 * @param db 分库分表
 * @param ids 主键
 * @return 多条数据
 */
public <T>Map<EntityPK,T> get(ShardingDBResource db,EntityPK[] ids);",0.9481481481481482
90413,"/** 
 * 获取多条记录.
 * @param db 分库分表
 * @param pks 主键
 * @return 多条数据
 */
public <T>List<T> getGlobal(String clusterName,String tableName,EntityPK[] pks);","/** 
 * 获取多条记录.
 * @param db 分库分表
 * @param pks 主键
 * @return 多条数据
 */
public <T>Map<EntityPK,T> getGlobal(String clusterName,String tableName,EntityPK[] pks);",0.9548387096774194
90414,"/** 
 * build sharding count key [clusterName + dbIndex].[start + end].[tableName + tableIndex].c
 */
protected String buildCountKey(ShardingDBResource shardingDBResource){
  StringBuilder key=new StringBuilder();
  key.append(shardingDBResource.getClusterName()).append(shardingDBResource.getDbName());
  key.append(""String_Node_Str"");
  key.append(shardingDBResource.getRegionCapacity());
  key.append(""String_Node_Str"");
  key.append(shardingDBResource.getTableName()).append(shardingDBResource.getTableIndex());
  key.append(""String_Node_Str"");
  return key.toString();
}","/** 
 * build sharding count key [clusterName + dbIndex].[start + end].[tableName + tableIndex].c
 */
protected String buildCountKey(ShardingDBResource shardingDBResource){
  StringBuilder key=new StringBuilder();
  key.append(shardingDBResource.getClusterName());
  key.append(""String_Node_Str"");
  key.append(shardingDBResource.getDbName());
  key.append(""String_Node_Str"");
  key.append(shardingDBResource.getRegionCapacity());
  key.append(""String_Node_Str"");
  key.append(shardingDBResource.getTableName()).append(shardingDBResource.getTableIndex());
  key.append(""String_Node_Str"");
  return key.toString();
}",0.9663865546218487
90415,"/** 
 * build sharding cache key [clusterName + dbIndex].[start + end].[tableName + tableIndex].[id]
 */
protected String buildKey(ShardingDBResource shardingDBResource,EntityPK entityPk){
  StringBuilder key=new StringBuilder();
  key.append(shardingDBResource.getClusterName()).append(shardingDBResource.getDbName());
  key.append(""String_Node_Str"");
  key.append(shardingDBResource.getRegionCapacity());
  key.append(""String_Node_Str"");
  key.append(shardingDBResource.getTableName()).append(shardingDBResource.getTableIndex());
  key.append(""String_Node_Str"");
  StringBuilder pks=new StringBuilder();
  for (  PKValue pkValue : entityPk.getPkValues()) {
    pks.append(pkValue.getValueAsString());
  }
  key.append(pks.toString());
  return key.toString();
}","/** 
 * build sharding cache key [clusterName + dbIndex].[start + end].[tableName + tableIndex].[id]
 */
protected String buildKey(ShardingDBResource shardingDBResource,EntityPK entityPk){
  StringBuilder key=new StringBuilder();
  key.append(shardingDBResource.getClusterName());
  key.append(""String_Node_Str"");
  key.append(shardingDBResource.getDbName());
  key.append(""String_Node_Str"");
  key.append(shardingDBResource.getRegionCapacity());
  key.append(""String_Node_Str"");
  key.append(shardingDBResource.getTableName()).append(shardingDBResource.getTableIndex());
  if (entityPk != null) {
    key.append(""String_Node_Str"");
    StringBuilder pks=new StringBuilder();
    for (    PKValue pkValue : entityPk.getPkValues()) {
      pks.append(pkValue.getValueAsString());
    }
    key.append(pks.toString());
  }
  return key.toString();
}",0.8819875776397516
90416,"/** 
 * build global cache key [clusterName].[tableName].[id]
 */
protected String buildGlobalKey(String clusterName,String tableName,EntityPK entityPk){
  StringBuilder key=new StringBuilder();
  key.append(clusterName).append(""String_Node_Str"").append(tableName).append(""String_Node_Str"");
  StringBuilder pks=new StringBuilder();
  for (  PKValue pkValue : entityPk.getPkValues()) {
    pks.append(pkValue.getValueAsString());
  }
  key.append(pks.toString());
  return key.toString();
}","/** 
 * build global cache key [clusterName].[tableName].[id]
 */
protected String buildGlobalKey(String clusterName,String tableName,EntityPK entityPk){
  StringBuilder key=new StringBuilder();
  key.append(clusterName).append(""String_Node_Str"").append(tableName);
  if (entityPk != null) {
    key.append(""String_Node_Str"");
    StringBuilder pks=new StringBuilder();
    for (    PKValue pkValue : entityPk.getPkValues()) {
      pks.append(pkValue.getValueAsString());
    }
    key.append(pks.toString());
  }
  return key.toString();
}",0.8477206595538312
90417,"private void _put(List<String> keys,List<? extends Object> data){
  try {
    for (int i=0; i < keys.size(); i++) {
      memClient.set(keys.get(i),expire,data.get(i));
    }
  }
 catch (  Exception e) {
    LOG.warn(""String_Node_Str"" + e.getMessage());
  }
  if (LOG.isDebugEnabled()) {
    LOG.debug(""String_Node_Str"" + keys.size() + ""String_Node_Str""+ keys);
  }
}","private void _put(List<String> keys,List<? extends Object> data){
  if (data == null || data.isEmpty()) {
    return;
  }
  try {
    for (int i=0; i < keys.size(); i++) {
      memClient.set(keys.get(i),expire,data.get(i));
    }
  }
 catch (  Exception e) {
    LOG.warn(""String_Node_Str"" + e.getMessage());
  }
  if (LOG.isDebugEnabled()) {
    LOG.debug(""String_Node_Str"" + keys.size() + ""String_Node_Str""+ keys);
  }
}",0.9291139240506328
90418,"@Override public void putGlobal(String whereSql,String clusterName,String tableName,List data){
  if (StringUtil.isBlank(whereSql)) {
    return;
  }
  try {
    String versionKey=_buildGlobalVersion(clusterName,tableName);
    int version=r.nextInt(10000);
    if (!_exists(versionKey)) {
      this.memClient.incr(versionKey,0,version);
    }
 else {
      version=Integer.parseInt((String)this.memClient.get(versionKey));
    }
    String cacheKey=_buildGlobalCacheKey(whereSql,clusterName,tableName,version);
    this.memClient.set(cacheKey,expire,data);
    if (LOG.isDebugEnabled()) {
      LOG.debug(""String_Node_Str"" + cacheKey);
    }
  }
 catch (  Exception e) {
    LOG.warn(""String_Node_Str"");
  }
}","@Override public void putGlobal(String whereSql,String clusterName,String tableName,List data){
  if (StringUtil.isBlank(whereSql) || data == null || data.isEmpty()) {
    return;
  }
  try {
    String versionKey=_buildGlobalVersion(clusterName,tableName);
    int version=r.nextInt(10000);
    if (!_exists(versionKey)) {
      this.memClient.incr(versionKey,0,version);
    }
 else {
      version=Integer.parseInt((String)this.memClient.get(versionKey));
    }
    String cacheKey=_buildGlobalCacheKey(whereSql,clusterName,tableName,version);
    this.memClient.set(cacheKey,expire,data);
    if (LOG.isDebugEnabled()) {
      LOG.debug(""String_Node_Str"" + cacheKey);
    }
  }
 catch (  Exception e) {
    LOG.warn(""String_Node_Str"");
  }
}",0.9766483516483516
90419,"@Override public void put(String whereSql,ShardingDBResource db,List data){
  if (StringUtil.isBlank(whereSql)) {
    return;
  }
  try {
    String versionKey=_buildShardingVersion(db);
    int version=r.nextInt(10000);
    if (!_exists(versionKey)) {
      this.memClient.incr(versionKey,0,version);
    }
 else {
      version=Integer.parseInt((String)this.memClient.get(versionKey));
    }
    String cacheKey=_buildShardingCacheKey(whereSql,db,version);
    this.memClient.set(cacheKey,expire,data);
    if (LOG.isDebugEnabled()) {
      LOG.debug(""String_Node_Str"" + cacheKey);
    }
  }
 catch (  Exception e) {
    LOG.warn(""String_Node_Str"");
  }
}","@Override public void put(String whereSql,ShardingDBResource db,List data){
  if (StringUtil.isBlank(whereSql) || data == null || data.isEmpty()) {
    return;
  }
  try {
    String versionKey=_buildShardingVersion(db);
    int version=r.nextInt(10000);
    if (!_exists(versionKey)) {
      this.memClient.incr(versionKey,0,version);
    }
 else {
      version=Integer.parseInt((String)this.memClient.get(versionKey));
    }
    String cacheKey=_buildShardingCacheKey(whereSql,db,version);
    this.memClient.set(cacheKey,expire,data);
    if (LOG.isDebugEnabled()) {
      LOG.debug(""String_Node_Str"" + cacheKey);
    }
  }
 catch (  Exception e) {
    LOG.warn(""String_Node_Str"");
  }
}",0.9747774480712166
90420,"private void _put(List<String> keys,List<? extends Object> data){
  try {
    for (int i=0; i < keys.size(); i++) {
      _put(keys.get(i),data.get(i));
    }
  }
 catch (  Exception e) {
    LOG.warn(""String_Node_Str"" + e.getMessage());
  }
  if (LOG.isDebugEnabled()) {
    LOG.debug(""String_Node_Str"" + keys.size() + ""String_Node_Str""+ keys);
  }
}","private void _put(List<String> keys,List<? extends Object> data){
  if (data == null || data.isEmpty()) {
    return;
  }
  try {
    for (int i=0; i < keys.size(); i++) {
      _put(keys.get(i),data.get(i));
    }
  }
 catch (  Exception e) {
    LOG.warn(""String_Node_Str"" + e.getMessage());
  }
  if (LOG.isDebugEnabled()) {
    LOG.debug(""String_Node_Str"" + keys.size() + ""String_Node_Str""+ keys);
  }
}",0.9261213720316622
90421,"@Override public void removeGlobal(String clusterName,String tableName){
  ShardedJedis redisClient=null;
  try {
    redisClient=jedisPool.getResource();
    List<String> keys=new ArrayList<String>();
    Collection<Jedis> shards=redisClient.getAllShards();
    String cacheKey=_buildGlobalCacheKey(null,clusterName,tableName);
    for (    Jedis shard : shards) {
      keys.addAll(shard.keys(cacheKey));
      shard.del(keys.toArray(new String[0]));
    }
    if (LOG.isDebugEnabled()) {
      LOG.debug(""String_Node_Str"" + cacheKey + ""String_Node_Str"");
    }
  }
 catch (  Exception e) {
    LOG.warn(""String_Node_Str"");
  }
 finally {
    if (redisClient != null)     redisClient.close();
  }
}","@Override public void removeGlobal(String clusterName,String tableName){
  ShardedJedis redisClient=null;
  String cacheKey=_buildGlobalCacheKey(null,clusterName,tableName);
  try {
    redisClient=jedisPool.getResource();
    Collection<Jedis> shards=redisClient.getAllShards();
    Set<String> keys=null;
    for (    Jedis shard : shards) {
      keys=shard.keys(cacheKey);
      if (keys != null && !keys.isEmpty())       shard.del(keys.toArray(new String[keys.size()]));
    }
    if (LOG.isDebugEnabled()) {
      LOG.debug(""String_Node_Str"" + cacheKey + ""String_Node_Str"");
    }
  }
 catch (  Exception e) {
    LOG.warn(""String_Node_Str"");
  }
 finally {
    if (redisClient != null)     redisClient.close();
  }
}",0.6872803935347856
90422,"@Override public void putGlobal(String whereSql,String clusterName,String tableName,List data){
  if (StringUtil.isBlank(whereSql)) {
    return;
  }
  ShardedJedis redisClient=null;
  try {
    redisClient=jedisPool.getResource();
    String cacheKey=_buildGlobalCacheKey(whereSql,clusterName,tableName);
    redisClient.set(cacheKey.getBytes(),IOUtil.getBytes(data));
    redisClient.expire(cacheKey.getBytes(),expire);
    if (LOG.isDebugEnabled()) {
      LOG.debug(""String_Node_Str"" + cacheKey);
    }
  }
 catch (  Exception e) {
    LOG.warn(""String_Node_Str"");
  }
 finally {
    if (redisClient != null)     redisClient.close();
  }
}","@Override public void putGlobal(String whereSql,String clusterName,String tableName,List data){
  if (StringUtil.isBlank(whereSql) || data == null || data.isEmpty()) {
    return;
  }
  ShardedJedis redisClient=null;
  try {
    redisClient=jedisPool.getResource();
    String cacheKey=_buildGlobalCacheKey(whereSql,clusterName,tableName);
    redisClient.set(cacheKey.getBytes(),IOUtil.getBytes(data));
    redisClient.expire(cacheKey.getBytes(),expire);
    if (LOG.isDebugEnabled()) {
      LOG.debug(""String_Node_Str"" + cacheKey);
    }
  }
 catch (  Exception e) {
    LOG.warn(""String_Node_Str"");
  }
 finally {
    if (redisClient != null)     redisClient.close();
  }
}",0.9742424242424242
90423,"@Override public void put(String whereSql,ShardingDBResource db,List data){
  if (StringUtil.isBlank(whereSql)) {
    return;
  }
  ShardedJedis redisClient=null;
  try {
    redisClient=jedisPool.getResource();
    String cacheKey=_buildShardingCacheKey(whereSql,db);
    redisClient.set(cacheKey.getBytes(),IOUtil.getBytes(data));
    redisClient.expire(cacheKey.getBytes(),expire);
    if (LOG.isDebugEnabled()) {
      LOG.debug(""String_Node_Str"" + cacheKey);
    }
  }
 catch (  Exception e) {
    LOG.warn(""String_Node_Str"");
  }
 finally {
    if (redisClient != null)     redisClient.close();
  }
}","@Override public void put(String whereSql,ShardingDBResource db,List data){
  if (StringUtil.isBlank(whereSql) || data == null || data.isEmpty()) {
    return;
  }
  ShardedJedis redisClient=null;
  try {
    redisClient=jedisPool.getResource();
    String cacheKey=_buildShardingCacheKey(whereSql,db);
    redisClient.set(cacheKey.getBytes(),IOUtil.getBytes(data));
    redisClient.expire(cacheKey.getBytes(),expire);
    if (LOG.isDebugEnabled()) {
      LOG.debug(""String_Node_Str"" + cacheKey);
    }
  }
 catch (  Exception e) {
    LOG.warn(""String_Node_Str"");
  }
 finally {
    if (redisClient != null)     redisClient.close();
  }
}",0.9727126805778492
90424,"@Override public void remove(ShardingDBResource db){
  ShardedJedis redisClient=null;
  try {
    redisClient=jedisPool.getResource();
    List<String> keys=new ArrayList<String>();
    Collection<Jedis> shards=redisClient.getAllShards();
    String cacheKey=_buildShardingCacheKey(null,db);
    for (    Jedis shard : shards) {
      keys.addAll(shard.keys(cacheKey));
      shard.del(keys.toArray(new String[0]));
    }
    if (LOG.isDebugEnabled()) {
      LOG.debug(""String_Node_Str"" + cacheKey + ""String_Node_Str"");
    }
  }
 catch (  Exception e) {
    LOG.warn(""String_Node_Str"");
  }
 finally {
    if (redisClient != null)     redisClient.close();
  }
}","@Override public void remove(ShardingDBResource db){
  ShardedJedis redisClient=null;
  String cacheKey=_buildShardingCacheKey(null,db);
  try {
    redisClient=jedisPool.getResource();
    Collection<Jedis> shards=redisClient.getAllShards();
    Set<String> keys=null;
    for (    Jedis shard : shards) {
      keys=shard.keys(cacheKey);
      if (keys != null && !keys.isEmpty())       shard.del(keys.toArray(new String[keys.size()]));
    }
    if (LOG.isDebugEnabled()) {
      LOG.debug(""String_Node_Str"" + cacheKey + ""String_Node_Str"");
    }
  }
 catch (  Exception e) {
    LOG.warn(""String_Node_Str"" + cacheKey);
  }
 finally {
    if (redisClient != null)     redisClient.close();
  }
}",0.6867647058823529
90425,"/** 
 * @param clazz
 * @param field
 * @return
 */
public static Field getField(Class<?> clazz,String fieldName){
  Field field=_aliasFieldCache.get(clazz.getName() + fieldName);
  if (field == null) {
    try {
      field=clazz.getDeclaredField(fieldName);
    }
 catch (    Exception e) {
    }
  }
  if (field == null) {
    Class<?> superClass=clazz.getSuperclass();
    if (superClass != null) {
      field=getField(superClass,fieldName);
    }
  }
  return field;
}","/** 
 * 支持通过别名获取Field
 * @param clazz
 * @param field
 * @return
 */
public static Field getField(Class<?> clazz,String fieldName){
  Field field=_aliasFieldCache.get(clazz.getName() + fieldName);
  if (field == null) {
    try {
      field=clazz.getDeclaredField(fieldName);
    }
 catch (    Exception e) {
    }
  }
  if (field == null) {
    Class<?> superClass=clazz.getSuperclass();
    if (superClass != null) {
      field=getField(superClass,fieldName);
    }
  }
  return field;
}",0.9823834196891192
90426,"public OrderBy(String field,Order order,Class<?> clazz){
  if (clazz != null)   this.field=BeansUtil.getFieldName(BeansUtil.getField(clazz,field));
 else   this.field=field;
  this.order=order;
}","public OrderBy(String field,Order order,Class<?> clazz){
  Field f=BeansUtil.getField(clazz,field);
  if (clazz != null)   this.field=BeansUtil.getFieldName(f);
 else   this.field=field;
  this.fieldType=f.getType();
  this.order=order;
}",0.6327944572748267
90427,"@Override public String toString(){
  StringBuilder info=new StringBuilder();
  if (fields != null && fields.length > 0) {
    info.append(""String_Node_Str"");
    for (    String field : fields) {
      info.append(field).append(""String_Node_Str"");
    }
    info.deleteCharAt(info.length() - 1);
  }
  if (StringUtil.isNotBlank(getWhereSql())) {
    info.append(""String_Node_Str"").append(getWhereSql());
  }
  return info.toString();
}","@Override public String toString(){
  return ""String_Node_Str"" + field + ""String_Node_Str""+ fieldType+ ""String_Node_Str""+ order+ ""String_Node_Str"";
}",0.4136752136752136
90428,"public ResultSetableQueryImpl(Class<T> clazz){
  this.clazz=clazz;
}","public ResultSetableQueryImpl(Class<T> clazz){
  super.clazz=clazz;
}",0.948905109489051
90429,"protected void setConnectionParam(DataSource obj,String propertyName,String value){
  Method[] setMethods=obj.getClass().getMethods();
  for (  Method setMethod : setMethods) {
    if (setMethod.getName().equals(""String_Node_Str"" + StringUtil.upperFirstLetter(propertyName))) {
      if (setMethod.getParameterTypes().length == 1) {
        Class<?> paramType=setMethod.getParameterTypes()[0];
        try {
          if (paramType == Boolean.TYPE || paramType == Boolean.class) {
            setMethod.invoke(obj,(Boolean.valueOf(value)).booleanValue());
          }
 else           if (paramType == Integer.TYPE || paramType == Integer.class) {
            setMethod.invoke(obj,Integer.parseInt(value));
          }
 else           if (paramType == Byte.TYPE || paramType == Byte.class) {
            setMethod.invoke(obj,Byte.parseByte(value));
          }
 else           if (paramType == Long.TYPE || paramType == Long.class) {
            setMethod.invoke(obj,Long.parseLong(value));
          }
 else           if (paramType == Short.TYPE || paramType == Short.class) {
            setMethod.invoke(obj,Short.valueOf(value));
          }
 else           if (paramType == Float.TYPE || paramType == Float.class) {
            setMethod.invoke(obj,Float.valueOf(value));
          }
 else           if (paramType == Double.TYPE || paramType == Double.class) {
            setMethod.invoke(obj,Double.valueOf(value));
          }
 else           if (paramType == Character.TYPE || paramType == Character.class) {
            setMethod.invoke(obj,value.charAt(0));
          }
 else {
            setMethod.invoke(obj,value);
          }
        }
 catch (        Exception e) {
          throw new RuntimeException(e);
        }
        return;
      }
    }
  }
}","protected void setConnectionParam(DataSource obj,String propertyName,String value){
  Method[] setMethods=obj.getClass().getMethods();
  for (  Method setMethod : setMethods) {
    if (!setMethod.getName().equals(""String_Node_Str"" + StringUtil.upperFirstLetter(propertyName))) {
      continue;
    }
    if (setMethod.getParameterTypes().length > 1) {
      continue;
    }
    Class<?> paramType=setMethod.getParameterTypes()[0];
    try {
      if (paramType == Boolean.TYPE || paramType == Boolean.class) {
        Boolean v=(Boolean.valueOf(value)).booleanValue();
        setMethod.invoke(obj,v);
      }
 else       if (paramType == Integer.TYPE || paramType == Integer.class) {
        Integer v=Integer.parseInt(value);
        setMethod.invoke(obj,v);
      }
 else       if (paramType == Byte.TYPE || paramType == Byte.class) {
        Byte v=Byte.parseByte(value);
        setMethod.invoke(obj,v);
      }
 else       if (paramType == Long.TYPE || paramType == Long.class) {
        Long v=Long.parseLong(value);
        setMethod.invoke(obj,v);
      }
 else       if (paramType == Short.TYPE || paramType == Short.class) {
        Short v=Short.valueOf(value);
        setMethod.invoke(obj,v);
      }
 else       if (paramType == Float.TYPE || paramType == Float.class) {
        Float v=Float.valueOf(value);
        setMethod.invoke(obj,v);
      }
 else       if (paramType == Double.TYPE || paramType == Double.class) {
        Double v=Double.valueOf(value);
        setMethod.invoke(obj,v);
      }
 else       if (paramType == Character.TYPE || paramType == Character.class) {
        Character v=value.charAt(0);
        setMethod.invoke(obj,v);
      }
 else {
        setMethod.invoke(obj,value);
      }
    }
 catch (    Exception e) {
      throw new RuntimeException(e);
    }
    return;
  }
}",0.8047897521581732
90430,"/** 
 * 通过反射获取对象的属性值.
 * @param obj 被反射对象
 * @param propertyName 属性名
 * @return 属性值
 * @throws Exception 操作失败
 */
public static Object getProperty(Object obj,String propertyName){
  Field f=getField(obj.getClass(),propertyName);
  f.setAccessible(true);
  try {
    return f.get(obj);
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
}","/** 
 * 通过反射获取对象的属性值.
 * @param obj 被反射对象
 * @param propertyName 属性名
 * @return 属性值
 * @throws Exception 操作失败
 */
public static Object getProperty(Object obj,String propertyName){
  Field f=getField(obj.getClass(),propertyName);
  if (f == null) {
    throw new IllegalArgumentException(""String_Node_Str"" + propertyName + ""String_Node_Str""+ obj.getClass());
  }
  f.setAccessible(true);
  try {
    return f.get(obj);
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
}",0.8418549346016647
90431,"@Override public void afterPropertiesSet() throws Exception {
  super.init();
  DefaultListableBeanFactory beanFactory=(DefaultListableBeanFactory)appCtx.getAutowireCapableBeanFactory();
  IContainer<DataSource> dsC=this.getDBCluster().getDBConnectionPool().getAllDataSources();
  BeanDefinition dsBean=null;
  DataSource ds=null;
  for (  String key : dsC.keys()) {
    ds=dsC.find(key);
    dsBean=new RootBeanDefinition(ds.getClass());
    beanFactory.registerBeanDefinition(key,dsBean);
    if (LOG.isDebugEnabled()) {
      LOG.debug(""String_Node_Str"",key);
    }
  }
}","@Override public void afterPropertiesSet() throws Exception {
  super.init();
  DefaultListableBeanFactory beanFactory=(DefaultListableBeanFactory)appCtx.getAutowireCapableBeanFactory();
  IDBConnectionPool dbConnectionPool=this.getDBCluster().getDBConnectionPool();
  IContainer<DataSource> dsC=dbConnectionPool.getAllDataSources();
  BeanDefinition dsBean=null;
  DataSource ds=null;
  for (  String key : dsC.keys()) {
    ds=dsC.find(key);
    dsBean=createBeanDef(ds);
    ((AbstractBeanDefinition)dsBean).setDestroyMethodName(""String_Node_Str"");
    beanFactory.registerBeanDefinition(key,dsBean);
    if (LOG.isDebugEnabled()) {
      LOG.debug(""String_Node_Str"",key);
    }
  }
}",0.5646312450436162
90432,"@Test public void testInjectDaaSource(){
  DataSource pinusGlobal=(DataSource)appCtx.getBean(""String_Node_Str"");
  Assert.assertNotNull(pinusGlobal);
  DataSource pinusSharding1=(DataSource)appCtx.getBean(""String_Node_Str"");
  Assert.assertNotNull(pinusSharding1);
  DataSource pinusSharding2=(DataSource)appCtx.getBean(""String_Node_Str"");
  Assert.assertNotNull(pinusSharding2);
}","@Test public void testInjectDaaSource() throws Exception {
  DataSource pinusGlobal=(DataSource)appCtx.getBean(""String_Node_Str"");
  Assert.assertNotNull(pinusGlobal);
  Assert.assertFalse(pinusGlobal.getConnection().isClosed());
  DataSource pinusSharding1=(DataSource)appCtx.getBean(""String_Node_Str"");
  Assert.assertFalse(pinusSharding1.getConnection().isClosed());
  DataSource pinusSharding2=(DataSource)appCtx.getBean(""String_Node_Str"");
  Assert.assertNotNull(pinusSharding2);
  Assert.assertFalse(pinusSharding2.getConnection().isClosed());
}",0.8025751072961373
90433,"private <T>void _put(String key,Map<EntityPK,T> param){
  if (param == null || param.isEmpty()) {
    return;
  }
  ShardedJedis redisClient=null;
  try {
    redisClient=jedisPool.getResource();
    Map<byte[],byte[]> data=Maps.newLinkedHashMap();
    for (    Map.Entry<EntityPK,T> entry : param.entrySet()) {
      data.put(IOUtil.getBytesByJava(entry.getKey()),IOUtil.getBytes(entry.getValue()));
    }
    redisClient.hmset(key.getBytes(),data);
    redisClient.exists(key.getBytes());
    if (LOG.isDebugEnabled()) {
      LOG.debug(""String_Node_Str"" + data.size() + ""String_Node_Str""+ key);
    }
  }
 catch (  Exception e) {
    LOG.warn(""String_Node_Str"" + e.getMessage());
  }
 finally {
    if (redisClient != null)     redisClient.close();
  }
}","private <T>void _put(String key,Map<EntityPK,T> param){
  if (param == null || param.isEmpty()) {
    return;
  }
  ShardedJedis redisClient=null;
  try {
    redisClient=jedisPool.getResource();
    Map<byte[],byte[]> data=Maps.newLinkedHashMap();
    for (    Map.Entry<EntityPK,T> entry : param.entrySet()) {
      data.put(IOUtil.getBytesByJava(entry.getKey()),IOUtil.getBytes(entry.getValue()));
    }
    redisClient.hmset(key.getBytes(),data);
    redisClient.expire(key.getBytes(),expire);
    if (LOG.isDebugEnabled()) {
      LOG.debug(""String_Node_Str"" + data.size() + ""String_Node_Str""+ key);
    }
  }
 catch (  Exception e) {
    LOG.warn(""String_Node_Str"" + e.getMessage());
  }
 finally {
    if (redisClient != null)     redisClient.close();
  }
}",0.990138067061144
90434,"/** 
 * 通过翻身将class转换为DBTable对象
 */
protected DBTable converTo(Class<?> defClass){
  if (defClass == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  Class<?> clazz;
  try {
    clazz=defClass.newInstance().getClass();
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
  Table annoTable=clazz.getAnnotation(Table.class);
  if (annoTable == null) {
    throw new IllegalArgumentException(clazz + ""String_Node_Str"");
  }
  String tableName=StringUtil.isBlank(annoTable.name()) ? clazz.getSimpleName() : annoTable.name();
  DBTable table=new DBTable(tableName.toLowerCase());
  String cluster=annoTable.cluster();
  if (StringUtil.isBlank(cluster)) {
    throw new IllegalArgumentException(clazz + ""String_Node_Str"");
  }
  table.setCluster(cluster);
  String shardingBy=annoTable.shardingBy();
  table.setShardingBy(shardingBy);
  int shardingNum=annoTable.shardingNum();
  table.setShardingNum(shardingNum);
  boolean isCache=annoTable.cache();
  table.setCache(isCache);
  _parseDBIndex(table,clazz);
  DBTablePK primaryKey=null;
  DBTableColumn column=null;
  org.pinus4j.entity.annotations.Field dbField=null;
  PrimaryKey pk=null;
  UpdateTime updateTime=null;
  DateTime datetime=null;
  for (  Field f : clazz.getDeclaredFields()) {
    datetime=f.getAnnotation(DateTime.class);
    if (datetime != null) {
      if (f.getType() != Date.class) {
        throw new IllegalArgumentException(clazz + ""String_Node_Str"" + f.getName()+ ""String_Node_Str""+ f.getType()+ ""String_Node_Str"");
      }
      String fieldName=f.getName();
      if (StringUtil.isNotBlank(datetime.name())) {
        fieldName=datetime.name();
      }
      BeansUtil.putAliasField(clazz,fieldName,f);
      column=new DBTableColumn();
      column.setField(fieldName);
      column.setType(DataTypeBind.DATETIME.getDBType());
      column.setHasDefault(datetime.hasDefault());
      if (column.isHasDefault())       column.setDefaultValue(DataTypeBind.DATETIME.getDefaultValue());
      column.setComment(datetime.comment());
      table.addColumn(column);
    }
    updateTime=f.getAnnotation(UpdateTime.class);
    if (updateTime != null) {
      if (f.getType() != java.sql.Timestamp.class) {
        throw new IllegalArgumentException(clazz + ""String_Node_Str"" + f.getName()+ ""String_Node_Str""+ f.getType()+ ""String_Node_Str"");
      }
      String fieldName=f.getName();
      if (StringUtil.isNotBlank(updateTime.name())) {
        fieldName=updateTime.name();
      }
      BeansUtil._aliasFieldCache.put(clazz.getName() + fieldName,f);
      column=new DBTableColumn();
      column.setField(fieldName);
      column.setType(DataTypeBind.UPDATETIME.getDBType());
      column.setHasDefault(true);
      column.setDefaultValue(DataTypeBind.UPDATETIME.getDefaultValue());
      column.setComment(updateTime.comment());
      table.addColumn(column);
    }
    dbField=f.getAnnotation(org.pinus4j.entity.annotations.Field.class);
    if (dbField != null) {
      if (f.getType() == java.sql.Timestamp.class) {
        throw new IllegalArgumentException(clazz + ""String_Node_Str"" + f.getName()+ ""String_Node_Str"");
      }
      String fieldName=f.getName();
      if (StringUtil.isNotBlank(dbField.name())) {
        fieldName=dbField.name();
      }
      BeansUtil._aliasFieldCache.put(clazz.getName() + fieldName,f);
      boolean isCanNull=dbField.isCanNull();
      int length=_getLength(f,dbField.length());
      boolean hasDefault=dbField.hasDefault();
      column=new DBTableColumn();
      column.setField(fieldName);
      column.setType(DataTypeBind.getEnum(f.getType()).getDBType());
      column.setCanNull(isCanNull);
      column.setLength(length);
      column.setHasDefault(hasDefault);
      column.setComment(dbField.comment());
      if (column.isHasDefault())       column.setDefaultValue(DataTypeBind.getEnum(f.getType()).getDefaultValue());
      if (column.getType().equals(DataTypeBind.STRING.getDBType()) && column.getLength() > Const.COLUMN_TEXT_LENGTH) {
        column.setType(DataTypeBind.TEXT.getDBType());
        column.setHasDefault(false);
        column.setLength(0);
        column.setDefaultValue(DataTypeBind.TEXT.getDefaultValue());
      }
      if (column.getType().equals(DataTypeBind.BOOL.getDBType())) {
        column.setLength(1);
      }
      table.addColumn(column);
    }
    pk=f.getAnnotation(PrimaryKey.class);
    if (pk != null) {
      String fieldName=f.getName();
      if (StringUtil.isNotBlank(pk.name())) {
        fieldName=pk.name();
      }
      BeansUtil._aliasFieldCache.put(clazz.getName() + fieldName,f);
      primaryKey=new DBTablePK();
      primaryKey.setField(fieldName);
      DataTypeBind dbType=DataTypeBind.getEnum(f.getType());
      primaryKey.setType(dbType.getDBType());
      int length=_getLength(f,pk.length());
      primaryKey.setLength(length);
      primaryKey.setComment(pk.comment());
      primaryKey.setAutoIncrement(pk.isAutoIncrement());
      table.addPrimaryKey(primaryKey);
      table.addColumn(primaryKey.toTableColumn());
    }
  }
  table.checkPrimaryKey();
  if (table.getColumns().isEmpty()) {
    throw new IllegalStateException(clazz + ""String_Node_Str"" + defClass);
  }
  return table;
}","/** 
 * 通过翻身将class转换为DBTable对象
 */
protected DBTable converTo(Class<?> defClass){
  if (defClass == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  Class<?> clazz;
  try {
    clazz=defClass.newInstance().getClass();
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
  Table annoTable=clazz.getAnnotation(Table.class);
  if (annoTable == null) {
    throw new IllegalArgumentException(clazz + ""String_Node_Str"");
  }
  String tableName=StringUtil.isBlank(annoTable.name()) ? clazz.getSimpleName() : annoTable.name();
  DBTable table=new DBTable(tableName.toLowerCase());
  String cluster=annoTable.cluster();
  if (StringUtil.isBlank(cluster)) {
    throw new IllegalArgumentException(clazz + ""String_Node_Str"");
  }
  table.setCluster(cluster);
  String shardingBy=annoTable.shardingBy();
  table.setShardingBy(shardingBy);
  int shardingNum=annoTable.shardingNum();
  table.setShardingNum(shardingNum);
  boolean isCache=annoTable.cache();
  table.setCache(isCache);
  _parseDBIndex(table,clazz);
  DBTablePK primaryKey=null;
  DBTableColumn column=null;
  org.pinus4j.entity.annotations.Field dbField=null;
  PrimaryKey pk=null;
  UpdateTime updateTime=null;
  DateTime datetime=null;
  for (  Field f : clazz.getDeclaredFields()) {
    datetime=f.getAnnotation(DateTime.class);
    if (datetime != null) {
      if (f.getType() != Date.class) {
        throw new IllegalArgumentException(clazz + ""String_Node_Str"" + f.getName()+ ""String_Node_Str""+ f.getType()+ ""String_Node_Str"");
      }
      String fieldName=f.getName();
      if (StringUtil.isNotBlank(datetime.name())) {
        fieldName=datetime.name();
      }
      BeansUtil.putAliasField(clazz,fieldName,f);
      column=new DBTableColumn();
      column.setField(fieldName);
      column.setType(DataTypeBind.DATETIME.getDBType());
      column.setHasDefault(datetime.hasDefault());
      if (column.isHasDefault())       column.setDefaultValue(DataTypeBind.DATETIME.getDefaultValue());
      column.setComment(datetime.comment());
      table.addColumn(column);
    }
    updateTime=f.getAnnotation(UpdateTime.class);
    if (updateTime != null) {
      if (f.getType() != java.sql.Timestamp.class) {
        throw new IllegalArgumentException(clazz + ""String_Node_Str"" + f.getName()+ ""String_Node_Str""+ f.getType()+ ""String_Node_Str"");
      }
      String fieldName=f.getName();
      if (StringUtil.isNotBlank(updateTime.name())) {
        fieldName=updateTime.name();
      }
      BeansUtil._aliasFieldCache.put(clazz.getName() + fieldName,f);
      column=new DBTableColumn();
      column.setField(fieldName);
      column.setType(DataTypeBind.UPDATETIME.getDBType());
      column.setHasDefault(true);
      column.setDefaultValue(DataTypeBind.UPDATETIME.getDefaultValue());
      column.setComment(updateTime.comment());
      table.addColumn(column);
    }
    dbField=f.getAnnotation(org.pinus4j.entity.annotations.Field.class);
    if (dbField != null) {
      if (f.getType() == java.sql.Timestamp.class) {
        throw new IllegalArgumentException(clazz + ""String_Node_Str"" + f.getName()+ ""String_Node_Str"");
      }
      if (f.getType() == java.util.Date.class) {
        throw new IllegalArgumentException(clazz + ""String_Node_Str"" + f.getName()+ ""String_Node_Str"");
      }
      String fieldName=f.getName();
      if (StringUtil.isNotBlank(dbField.name())) {
        fieldName=dbField.name();
      }
      BeansUtil._aliasFieldCache.put(clazz.getName() + fieldName,f);
      boolean isCanNull=dbField.isCanNull();
      int length=_getLength(f,dbField.length());
      boolean hasDefault=dbField.hasDefault();
      column=new DBTableColumn();
      column.setField(fieldName);
      column.setType(DataTypeBind.getEnum(f.getType()).getDBType());
      column.setCanNull(isCanNull);
      column.setLength(length);
      column.setHasDefault(hasDefault);
      column.setComment(dbField.comment());
      if (column.isHasDefault())       column.setDefaultValue(DataTypeBind.getEnum(f.getType()).getDefaultValue());
      if (column.getType().equals(DataTypeBind.STRING.getDBType()) && column.getLength() > Const.COLUMN_TEXT_LENGTH) {
        column.setType(DataTypeBind.TEXT.getDBType());
        column.setHasDefault(false);
        column.setLength(0);
        column.setDefaultValue(DataTypeBind.TEXT.getDefaultValue());
      }
      if (column.getType().equals(DataTypeBind.BOOL.getDBType())) {
        column.setLength(1);
      }
      table.addColumn(column);
    }
    pk=f.getAnnotation(PrimaryKey.class);
    if (pk != null) {
      String fieldName=f.getName();
      if (StringUtil.isNotBlank(pk.name())) {
        fieldName=pk.name();
      }
      BeansUtil._aliasFieldCache.put(clazz.getName() + fieldName,f);
      primaryKey=new DBTablePK();
      primaryKey.setField(fieldName);
      DataTypeBind dbType=DataTypeBind.getEnum(f.getType());
      primaryKey.setType(dbType.getDBType());
      int length=_getLength(f,pk.length());
      primaryKey.setLength(length);
      primaryKey.setComment(pk.comment());
      primaryKey.setAutoIncrement(pk.isAutoIncrement());
      table.addPrimaryKey(primaryKey);
      table.addColumn(primaryKey.toTableColumn());
    }
  }
  table.checkPrimaryKey();
  if (table.getColumns().isEmpty()) {
    throw new IllegalStateException(clazz + ""String_Node_Str"" + defClass);
  }
  return table;
}",0.984807020854959
90435,"public static void setProperty(Object obj,String propertyName,String value){
  if (obj == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  Class<?> clazz=obj.getClass();
  Field f=getField(clazz,propertyName);
  if (f != null) {
    try {
      f.setAccessible(true);
      if (value == null) {
        f.set(obj,null);
        return;
      }
      if (f.getType() == Boolean.TYPE || f.getType() == Boolean.class) {
        f.setBoolean(obj,(Boolean.valueOf(value)).booleanValue());
      }
 else       if (f.getType() == Integer.TYPE || f.getType() == Integer.class) {
        f.setInt(obj,Integer.parseInt(value));
      }
 else       if (f.getType() == Byte.TYPE || f.getType() == Byte.class) {
        f.setByte(obj,Byte.parseByte(value));
      }
 else       if (f.getType() == Long.TYPE || f.getType() == Long.class) {
        f.setLong(obj,Long.parseLong(value));
      }
 else       if (f.getType() == Short.TYPE || f.getType() == Short.class) {
        f.setShort(obj,Short.valueOf(value));
      }
 else       if (f.getType() == Float.TYPE || f.getType() == Float.class) {
        f.setFloat(obj,Float.valueOf(value));
      }
 else       if (f.getType() == Double.TYPE || f.getType() == Double.class) {
        f.setDouble(obj,Double.valueOf(value));
      }
 else       if (f.getType() == Character.TYPE || f.getType() == Character.class) {
        f.setChar(obj,value.charAt(0));
      }
 else {
        f.set(obj,value);
      }
    }
 catch (    Exception e) {
      throw new RuntimeException(e);
    }
  }
 else {
    Method[] setMethods=clazz.getMethods();
    for (    Method setMethod : setMethods) {
      if (setMethod.getName().equals(""String_Node_Str"" + StringUtil.upperFirstLetter(propertyName))) {
        if (setMethod.getParameterTypes().length == 1) {
          Class<?> paramType=setMethod.getParameterTypes()[0];
          try {
            if (paramType == Boolean.TYPE || paramType == Boolean.class) {
              setMethod.invoke(obj,(Boolean.valueOf(value)).booleanValue());
            }
 else             if (paramType == Integer.TYPE || paramType == Integer.class) {
              setMethod.invoke(obj,Integer.parseInt(value));
            }
 else             if (paramType == Byte.TYPE || paramType == Byte.class) {
              setMethod.invoke(obj,Byte.parseByte(value));
            }
 else             if (paramType == Long.TYPE || paramType == Long.class) {
              setMethod.invoke(obj,Long.parseLong(value));
            }
 else             if (paramType == Short.TYPE || paramType == Short.class) {
              setMethod.invoke(obj,Short.valueOf(value));
            }
 else             if (paramType == Float.TYPE || paramType == Float.class) {
              setMethod.invoke(obj,Float.valueOf(value));
            }
 else             if (paramType == Double.TYPE || paramType == Double.class) {
              setMethod.invoke(obj,Double.valueOf(value));
            }
 else             if (paramType == Character.TYPE || paramType == Character.class) {
              setMethod.invoke(obj,value.charAt(0));
            }
 else {
              setMethod.invoke(obj,value);
            }
          }
 catch (          Exception e) {
            throw new RuntimeException(e);
          }
          return;
        }
      }
    }
  }
}","@Deprecated public static void setProperty(Object obj,String propertyName,String value){
  if (obj == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  Class<?> clazz=obj.getClass();
  Field f=getField(clazz,propertyName);
  if (f != null) {
    try {
      f.setAccessible(true);
      if (value == null) {
        f.set(obj,null);
        return;
      }
      if (f.getType() == Boolean.TYPE || f.getType() == Boolean.class) {
        f.setBoolean(obj,(Boolean.valueOf(value)).booleanValue());
      }
 else       if (f.getType() == Integer.TYPE || f.getType() == Integer.class) {
        f.setInt(obj,Integer.parseInt(value));
      }
 else       if (f.getType() == Byte.TYPE || f.getType() == Byte.class) {
        f.setByte(obj,Byte.parseByte(value));
      }
 else       if (f.getType() == Long.TYPE || f.getType() == Long.class) {
        f.setLong(obj,Long.parseLong(value));
      }
 else       if (f.getType() == Short.TYPE || f.getType() == Short.class) {
        f.setShort(obj,Short.valueOf(value));
      }
 else       if (f.getType() == Float.TYPE || f.getType() == Float.class) {
        f.setFloat(obj,Float.valueOf(value));
      }
 else       if (f.getType() == Double.TYPE || f.getType() == Double.class) {
        f.setDouble(obj,Double.valueOf(value));
      }
 else       if (f.getType() == Character.TYPE || f.getType() == Character.class) {
        f.setChar(obj,value.charAt(0));
      }
 else {
        f.set(obj,value);
      }
    }
 catch (    Exception e) {
      throw new RuntimeException(e);
    }
  }
 else {
    Method[] setMethods=clazz.getMethods();
    for (    Method setMethod : setMethods) {
      if (setMethod.getName().equals(""String_Node_Str"" + StringUtil.upperFirstLetter(propertyName))) {
        if (setMethod.getParameterTypes().length == 1) {
          Class<?> paramType=setMethod.getParameterTypes()[0];
          try {
            if (paramType == Boolean.TYPE || paramType == Boolean.class) {
              setMethod.invoke(obj,(Boolean.valueOf(value)).booleanValue());
            }
 else             if (paramType == Integer.TYPE || paramType == Integer.class) {
              setMethod.invoke(obj,Integer.parseInt(value));
            }
 else             if (paramType == Byte.TYPE || paramType == Byte.class) {
              setMethod.invoke(obj,Byte.parseByte(value));
            }
 else             if (paramType == Long.TYPE || paramType == Long.class) {
              setMethod.invoke(obj,Long.parseLong(value));
            }
 else             if (paramType == Short.TYPE || paramType == Short.class) {
              setMethod.invoke(obj,Short.valueOf(value));
            }
 else             if (paramType == Float.TYPE || paramType == Float.class) {
              setMethod.invoke(obj,Float.valueOf(value));
            }
 else             if (paramType == Double.TYPE || paramType == Double.class) {
              setMethod.invoke(obj,Double.valueOf(value));
            }
 else             if (paramType == Character.TYPE || paramType == Character.class) {
              setMethod.invoke(obj,value.charAt(0));
            }
 else {
              setMethod.invoke(obj,value);
            }
          }
 catch (          Exception e) {
            throw new RuntimeException(e);
          }
          return;
        }
      }
    }
  }
}",0.9981944026482096
90436,"/** 
 * 获取当前使用的数据库集群.
 * @return 数据库集群
 */
IDBCluster getDBCluster();","/** 
 * / 获取当前使用的数据库集群.
 * @return 数据库集群
 */
IDBCluster getDBCluster();",0.9857142857142858
90437,"@Override public Number count(){
  Number count=0;
  if (entityMetaManager.isShardingEntity(clazz)) {
    count=this.shardingQuery.getCountByQuery(this,this.clazz,this.useCache,this.masterSlave);
  }
 else {
    count=this.globalQuery.getCountByQuery(this,this.clazz,this.useCache,this.masterSlave);
  }
  return count;
}","@Override public Number count(){
  Number count=0;
  if (entityMetaManager.isShardingEntity(clazz)) {
    if (this.shardingKey != null)     count=this.shardingQuery.getCountByQuery(this,this.shardingKey,this.clazz,this.useCache,this.masterSlave);
 else     count=this.shardingQuery.getCountByQuery(this,this.clazz,this.useCache,this.masterSlave);
  }
 else {
    count=this.globalQuery.getCountByQuery(this,this.clazz,this.useCache,this.masterSlave);
  }
  return count;
}",0.7969735182849937
90438,"@Override public IQuery<T> clone(){
  ResultSetableQueryImpl<T> clone=new ResultSetableQueryImpl<T>(this.clazz);
  clone.fields=this.fields;
  clone.condList.addAll(this.condList);
  clone.orderList.addAll(this.orderList);
  clone.start=this.start;
  clone.limit=this.limit;
  clone.globalQuery=this.globalQuery;
  clone.shardingQuery=this.shardingQuery;
  clone.useCache=this.useCache;
  clone.masterSlave=this.masterSlave;
  clone.entityMetaManager=this.entityMetaManager;
  return clone;
}","@Override public IQuery<T> clone(){
  ResultSetableQueryImpl<T> clone=new ResultSetableQueryImpl<T>(this.clazz);
  clone.fields=this.fields;
  clone.condList.addAll(this.condList);
  clone.orderList.addAll(this.orderList);
  clone.start=this.start;
  clone.limit=this.limit;
  clone.globalQuery=this.globalQuery;
  clone.shardingQuery=this.shardingQuery;
  clone.shardingKey=this.shardingKey;
  clone.useCache=this.useCache;
  clone.masterSlave=this.masterSlave;
  clone.entityMetaManager=this.entityMetaManager;
  return clone;
}",0.9628180039138944
90439,"@Override public List<T> list(){
  List<T> result=null;
  List<EntityPK> entityPkList=coverToEntityPK();
  if (entityMetaManager.isShardingEntity(clazz)) {
    if (entityPkList != null && !entityPkList.isEmpty())     result=this.shardingQuery.findByPkList(entityPkList,this.clazz,this.useCache,this.masterSlave);
 else     result=this.shardingQuery.findByQuery(this,this.clazz,this.useCache,this.masterSlave);
  }
 else {
    if (entityPkList != null && !entityPkList.isEmpty())     result=this.globalQuery.findByPkList(entityPkList,this.clazz,this.useCache,this.masterSlave);
 else     result=this.globalQuery.findByQuery(this,this.clazz,this.useCache,this.masterSlave);
  }
  return result;
}","@Override public List<T> list(){
  List<T> result=null;
  List<EntityPK> entityPkList=coverToEntityPK();
  if (entityMetaManager.isShardingEntity(clazz)) {
    if (entityPkList != null && !entityPkList.isEmpty())     if (this.shardingKey != null)     result=this.shardingQuery.findByPkList(entityPkList,this.shardingKey,this.clazz,this.useCache,this.masterSlave);
 else     result=this.shardingQuery.findByPkList(entityPkList,this.clazz,this.useCache,this.masterSlave);
 else     if (this.shardingKey != null)     result=this.shardingQuery.findByQuery(this,this.shardingKey,this.clazz,this.useCache,this.masterSlave);
 else     result=this.shardingQuery.findByQuery(this,this.clazz,this.useCache,this.masterSlave);
  }
 else {
    if (entityPkList != null && !entityPkList.isEmpty())     result=this.globalQuery.findByPkList(entityPkList,this.clazz,this.useCache,this.masterSlave);
 else     result=this.globalQuery.findByQuery(this,this.clazz,this.useCache,this.masterSlave);
  }
  return result;
}",0.819846426461902
90440,"/** 
 * 执行保存数据操作.
 * @param conn 数据库连接
 * @param entities 需要被保存的数据
 * @param tableIndex 分片表下标. 当-1时忽略下标
 * @throws SQLException
 */
protected List<PKValue> _saveBatchWithAutoGeneratedKeys(Connection conn,List<? extends Object> entities,int tableIndex) throws SQLException {
  List<PKValue> pks=Lists.newArrayList();
  Statement st=null;
  String sql=null;
  Class<?> clazz=null;
  for (  Object entity : entities) {
    try {
      st=conn.createStatement();
      sql=SQLBuilder.getInsert(entity,tableIndex);
      st.execute(sql,Statement.RETURN_GENERATED_KEYS);
      clazz=entity.getClass();
      if (!entityMetaManager.isUnionKey(clazz)) {
        ResultSet rs=st.getGeneratedKeys();
        PKName pkName=entityMetaManager.getNotUnionPkName(clazz);
        Field f=BeansUtil.getField(clazz,pkName.getValue());
        Object incrPK=null;
        if (rs.next()) {
          incrPK=rs.getObject(1);
          if (f.getType() == Integer.TYPE || f.getType() == Integer.class) {
            BeansUtil.setProperty(entity,pkName.getValue(),((Long)incrPK).intValue());
            pks.add(PKValue.valueOf(((Long)incrPK).intValue()));
          }
 else {
            BeansUtil.setProperty(entity,pkName.getValue(),incrPK);
            pks.add(PKValue.valueOf(incrPK));
          }
        }
      }
    }
  finally {
      JdbcUtil.close(st);
    }
  }
  return pks;
}","/** 
 * 执行保存数据操作.
 * @param conn 数据库连接
 * @param entities 需要被保存的数据
 * @param tableIndex 分片表下标. 当-1时忽略下标
 * @throws SQLException
 */
protected List<PKValue> _saveBatchWithAutoGeneratedKeys(Connection conn,List<? extends Object> entities,int tableIndex) throws SQLException {
  List<PKValue> pks=Lists.newArrayList();
  Statement st=null;
  String sql=null;
  Class<?> clazz=null;
  for (  Object entity : entities) {
    try {
      st=conn.createStatement();
      sql=SQLBuilder.getInsert(entity,tableIndex);
      st.execute(sql,Statement.RETURN_GENERATED_KEYS);
      clazz=entity.getClass();
      if (!entityMetaManager.isUnionKey(clazz)) {
        DBTablePK dbTablePK=entityMetaManager.getNotUnionPrimaryKey(clazz);
        if (dbTablePK.isAutoIncrement()) {
          ResultSet rs=st.getGeneratedKeys();
          Field f=BeansUtil.getField(clazz,dbTablePK.getField());
          Object incrPK=null;
          if (rs.next()) {
            incrPK=rs.getObject(1);
            if (f.getType() == Integer.TYPE || f.getType() == Integer.class) {
              BeansUtil.setProperty(entity,dbTablePK.getField(),((Long)incrPK).intValue());
              pks.add(PKValue.valueOf(((Long)incrPK).intValue()));
            }
 else {
              BeansUtil.setProperty(entity,dbTablePK.getField(),incrPK);
              pks.add(PKValue.valueOf(incrPK));
            }
          }
        }
 else {
          pks.add(PKValue.valueOf(BeansUtil.getProperty(entity,dbTablePK.getField())));
        }
      }
    }
  finally {
      JdbcUtil.close(st);
    }
  }
  return pks;
}",0.5449591280653951
90441,"public static PinusClient getPinusClient(){
  PinusClient pinusClient=new DefaultPinusClient();
  pinusClient.setScanPackage(""String_Node_Str"");
  try {
    pinusClient.init();
  }
 catch (  LoadConfigException e) {
    throw new RuntimeException(e);
  }
  return pinusClient;
}","public static PinusClient getPinusClient(){
  PinusClient pinusClient=new DefaultPinusClient();
  pinusClient.setScanPackage(""String_Node_Str"");
  pinusClient.setSyncAction(EnumSyncAction.UPDATE);
  try {
    pinusClient.init();
  }
 catch (  LoadConfigException e) {
    throw new RuntimeException(e);
  }
  return pinusClient;
}",0.9144736842105264
90442,"@Test public void testSave() throws Exception {
  TestGlobalEntity globalEntity=createGlobalEntity();
  TestGlobalUnionKeyEntity globalUKEntity=createGlobalUnionKeyEntity();
  TestEntity shardingEntity=createEntity();
  pinusClient.save(globalEntity);
  System.out.println(globalEntity.getId());
  pinusClient.save(globalUKEntity);
  System.out.println(globalUKEntity);
  pinusClient.save(shardingEntity);
  System.out.println(shardingEntity.getId());
}","@Test public void testSave() throws Exception {
  TestGlobalEntity globalEntity=createGlobalEntity();
  globalEntity.setId(pinusClient.genClusterUniqueLongId(""String_Node_Str""));
  TestGlobalUnionKeyEntity globalUKEntity=createGlobalUnionKeyEntity();
  TestEntity shardingEntity=createEntity();
  shardingEntity.setId(pinusClient.genClusterUniqueLongId(""String_Node_Str""));
  pinusClient.save(globalEntity);
  System.out.println(globalEntity.getId());
  pinusClient.save(globalUKEntity);
  System.out.println(globalUKEntity);
  pinusClient.save(shardingEntity);
  System.out.println(shardingEntity.getId());
}",0.8531073446327684
90443,"@Test public void testSave(){
  TestEntity entity=createEntity();
  TestGlobalEntity globalEntity=createGlobalEntity();
  TestGlobalUnionKeyEntity globalUKEntity=createGlobalUnionKeyEntity();
  globalUKEntity.setId(""String_Node_Str"");
  globalUKEntity.setIndex(""String_Node_Str"");
  try {
    storageClient.beginTransaction();
    storageClient.save(entity);
    storageClient.globalSave(globalEntity);
    storageClient.globalSave(globalUKEntity);
    storageClient.commit();
  }
 catch (  Exception e) {
    e.printStackTrace();
    storageClient.rollback();
  }
}","@Test public void testSave(){
  TestEntity entity=createEntity();
  TestGlobalEntity globalEntity=createGlobalEntity();
  TestGlobalUnionKeyEntity globalUKEntity=createGlobalUnionKeyEntity();
  globalUKEntity.setId(""String_Node_Str"");
  try {
    storageClient.beginTransaction();
    storageClient.globalSave(globalEntity);
    storageClient.commit();
  }
 catch (  Exception e) {
    e.printStackTrace();
    storageClient.rollback();
  }
}",0.7301587301587301
90444,"@Override public List<IDBResource> getAllSlaveShardingDBResource(Class<?> clazz,EnumDBMasterSlave masterSlave) throws SQLException, DBClusterException, SystemException {
  List<IDBResource> dbResources=new ArrayList<IDBResource>();
  int tableNum=entityMetaManager.getTableNum(clazz);
  if (tableNum == 0) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  String clusterName=entityMetaManager.getClusterName(clazz);
  String tableName=entityMetaManager.getTableName(clazz);
  ITransaction tx=(ITransaction)txManager.getTransaction();
  IDBResource dbResource=null;
  DBClusterInfo dbClusterInfo=this.getDBClusterInfo(clusterName);
  for (  DBRegionInfo region : dbClusterInfo.getDbRegions()) {
    List<DBInfo> slaveDBInfos=null;
    if (EnumDBMasterSlave.AUTO == masterSlave) {
      slaveDBInfos=region.getSlaveDBInfos().get(r.nextInt(region.getSlaveDBInfos().size() - 1));
    }
 else {
      slaveDBInfos=region.getSlaveDBInfos().get(masterSlave.getValue());
    }
    if (slaveDBInfos == null || slaveDBInfos.isEmpty()) {
      throw new DBClusterException(""String_Node_Str"" + clusterName);
    }
    for (    DBInfo dbInfo : slaveDBInfos) {
      for (int tableIndex=0; tableIndex < tableNum; tableIndex++) {
        dbResource=ShardingDBResource.valueOf(tx,dbInfo,region,tableName,tableIndex);
        dbResources.add(dbResource);
      }
    }
  }
  return dbResources;
}","@Override public List<IDBResource> getAllSlaveShardingDBResource(Class<?> clazz,EnumDBMasterSlave masterSlave) throws SQLException, DBClusterException, SystemException {
  List<IDBResource> dbResources=new ArrayList<IDBResource>();
  int tableNum=entityMetaManager.getTableNum(clazz);
  if (tableNum == 0) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  String clusterName=entityMetaManager.getClusterName(clazz);
  String tableName=entityMetaManager.getTableName(clazz);
  ITransaction tx=(ITransaction)txManager.getTransaction();
  IDBResource dbResource=null;
  DBClusterInfo dbClusterInfo=this.getDBClusterInfo(clusterName);
  for (  DBRegionInfo region : dbClusterInfo.getDbRegions()) {
    List<DBInfo> slaveDBInfos=null;
    if (EnumDBMasterSlave.AUTO == masterSlave) {
      slaveDBInfos=region.getSlaveDBInfos().get(r.nextInt(region.getSlaveDBInfos().size()));
    }
 else {
      slaveDBInfos=region.getSlaveDBInfos().get(masterSlave.getValue());
    }
    if (slaveDBInfos == null || slaveDBInfos.isEmpty()) {
      throw new DBClusterException(""String_Node_Str"" + clusterName);
    }
    for (    DBInfo dbInfo : slaveDBInfos) {
      for (int tableIndex=0; tableIndex < tableNum; tableIndex++) {
        dbResource=ShardingDBResource.valueOf(tx,dbInfo,region,tableName,tableIndex);
        dbResources.add(dbResource);
      }
    }
  }
  return dbResources;
}",0.9985621854780732
90445,"@Override public RouteInfo select(EnumDBMasterSlave masterSlave,String tableName,IShardingKey<?> value) throws DBRouteException {
  RouteInfo dbRouteInfo=new RouteInfo();
  long shardingValue=getShardingValue(value);
  String clusterName=value.getClusterName();
  DBClusterInfo dbClusterInfo=this.dbCluster.getDBClusterInfo(clusterName);
  if (dbClusterInfo == null) {
    throw new IllegalStateException(""String_Node_Str"" + clusterName);
  }
  List<DBRegionInfo> regionInfos=dbClusterInfo.getDbRegions();
  if (regionInfos == null || regionInfos.isEmpty()) {
    throw new DBRouteException(""String_Node_Str"" + clusterName);
  }
  DBRegionInfo regionInfo=null;
  int regionIndex=0;
  for (  DBRegionInfo region : regionInfos) {
    if (region.isMatch(shardingValue)) {
      regionInfo=region;
      break;
    }
    regionIndex++;
  }
  if (regionInfo == null) {
    throw new DBRouteException(""String_Node_Str"" + clusterName + ""String_Node_Str""+ shardingValue);
  }
  List<DBInfo> dbInfos=null;
switch (masterSlave) {
case MASTER:
    dbInfos=regionInfo.getMasterDBInfos();
  break;
case AUTO:
List<List<DBInfo>> multiSlaveDBInfos=regionInfo.getSlaveDBInfos();
if (multiSlaveDBInfos == null || multiSlaveDBInfos.isEmpty()) {
throw new DBRouteException(""String_Node_Str"" + clusterName);
}
int slaveIndex=AbstractDBCluster.r.nextInt(multiSlaveDBInfos.size() - 1);
dbInfos=multiSlaveDBInfos.get(slaveIndex);
break;
default :
multiSlaveDBInfos=regionInfo.getSlaveDBInfos();
if (multiSlaveDBInfos == null || multiSlaveDBInfos.isEmpty()) {
throw new DBRouteException(""String_Node_Str"" + clusterName);
}
slaveIndex=masterSlave.getValue();
dbInfos=multiSlaveDBInfos.get(slaveIndex);
break;
}
if (dbInfos == null || dbInfos.isEmpty()) {
throw new DBRouteException(""String_Node_Str"" + clusterName);
}
DBInfo dbInfo=doSelect(dbInfos,value);
dbRouteInfo.setDbInfo(dbInfo);
dbRouteInfo.setClusterName(clusterName);
dbRouteInfo.setRegionIndex(regionIndex);
try {
int tableNum=tableCluster.getTableNumber(clusterName,tableName);
int tableIndex=(int)shardingValue % tableNum;
dbRouteInfo.setTableName(tableName);
dbRouteInfo.setTableIndex(tableIndex);
}
 catch (Exception e) {
throw new DBRouteException(""String_Node_Str"" + dbRouteInfo.getClusterName() + ""String_Node_Str""+ dbRouteInfo.getDbInfo().getDbName()+ ""String_Node_Str""+ tableName);
}
return dbRouteInfo;
}","@Override public RouteInfo select(EnumDBMasterSlave masterSlave,String tableName,IShardingKey<?> value) throws DBRouteException {
  RouteInfo dbRouteInfo=new RouteInfo();
  long shardingValue=getShardingValue(value);
  String clusterName=value.getClusterName();
  DBClusterInfo dbClusterInfo=this.dbCluster.getDBClusterInfo(clusterName);
  if (dbClusterInfo == null) {
    throw new IllegalStateException(""String_Node_Str"" + clusterName);
  }
  List<DBRegionInfo> regionInfos=dbClusterInfo.getDbRegions();
  if (regionInfos == null || regionInfos.isEmpty()) {
    throw new DBRouteException(""String_Node_Str"" + clusterName);
  }
  DBRegionInfo regionInfo=null;
  int regionIndex=0;
  for (  DBRegionInfo region : regionInfos) {
    if (region.isMatch(shardingValue)) {
      regionInfo=region;
      break;
    }
    regionIndex++;
  }
  if (regionInfo == null) {
    throw new DBRouteException(""String_Node_Str"" + clusterName + ""String_Node_Str""+ shardingValue);
  }
  List<DBInfo> dbInfos=null;
switch (masterSlave) {
case MASTER:
    dbInfos=regionInfo.getMasterDBInfos();
  break;
case AUTO:
List<List<DBInfo>> multiSlaveDBInfos=regionInfo.getSlaveDBInfos();
if (multiSlaveDBInfos == null || multiSlaveDBInfos.isEmpty()) {
throw new DBRouteException(""String_Node_Str"" + clusterName);
}
int slaveIndex=AbstractDBCluster.r.nextInt(multiSlaveDBInfos.size());
dbInfos=multiSlaveDBInfos.get(slaveIndex);
break;
default :
multiSlaveDBInfos=regionInfo.getSlaveDBInfos();
if (multiSlaveDBInfos == null || multiSlaveDBInfos.isEmpty()) {
throw new DBRouteException(""String_Node_Str"" + clusterName);
}
slaveIndex=masterSlave.getValue();
dbInfos=multiSlaveDBInfos.get(slaveIndex);
break;
}
if (dbInfos == null || dbInfos.isEmpty()) {
throw new DBRouteException(""String_Node_Str"" + clusterName);
}
DBInfo dbInfo=doSelect(dbInfos,value);
dbRouteInfo.setDbInfo(dbInfo);
dbRouteInfo.setClusterName(clusterName);
dbRouteInfo.setRegionIndex(regionIndex);
try {
int tableNum=tableCluster.getTableNumber(clusterName,tableName);
int tableIndex=(int)shardingValue % tableNum;
dbRouteInfo.setTableName(tableName);
dbRouteInfo.setTableIndex(tableIndex);
}
 catch (Exception e) {
throw new DBRouteException(""String_Node_Str"" + dbRouteInfo.getClusterName() + ""String_Node_Str""+ dbRouteInfo.getDbInfo().getDbName()+ ""String_Node_Str""+ tableName);
}
return dbRouteInfo;
}",0.9991485738612176
90446,"@Override public PKValue save(Object entity,IShardingKey<?> shardingKey){
  PKValue[] pkValues=saveBatch(Lists.newArrayList(entity),shardingKey,true);
  if (pkValues != null && pkValues.length > 1) {
    return pkValues[0];
  }
  return null;
}","@Override public PKValue save(Object entity,IShardingKey<?> shardingKey){
  PKValue[] pkValues=saveBatch(Lists.newArrayList(entity),shardingKey,true);
  if (pkValues != null && pkValues.length > 0) {
    return pkValues[0];
  }
  return null;
}",0.9959016393442623
90447,"@SuppressWarnings(""String_Node_Str"") private DBClusterInfo _getDBClusterInfo(String clusterName,Node clusterNode) throws LoadConfigException {
  DBClusterInfo dbClusterInfo=new DBClusterInfo();
  dbClusterInfo.setClusterName(clusterName);
  try {
    String classFullPath=xmlUtil.getAttributeValue(clusterNode,""String_Node_Str"");
    if (StringUtil.isBlank(classFullPath)) {
      classFullPath=DEFAULT_CLUSTER_ROUTER_CLASS;
    }
    Class<IClusterRouter> clazz=(Class<IClusterRouter>)Class.forName(classFullPath);
    dbClusterInfo.setRouterClass(clazz);
  }
 catch (  Exception e) {
    throw new LoadConfigException(e);
  }
  Node global=xmlUtil.getFirstChildByName(clusterNode,""String_Node_Str"");
  if (global != null) {
    Node masterGlobal=xmlUtil.getFirstChildByName(global,""String_Node_Str"");
    String dsId=masterGlobal.getTextContent().trim();
    DBInfo masterGlobalDBInfo=dsBucketMap.get(dsId);
    if (masterGlobalDBInfo == null) {
      throw new LoadConfigException(""String_Node_Str"" + dsId);
    }
    masterGlobalDBInfo.setClusterName(clusterName);
    masterGlobalDBInfo.setMasterSlave(EnumDBMasterSlave.MASTER);
    Map<String,String> propMap=xmlUtil.getAttributeAsMap(masterGlobal);
    masterGlobalDBInfo.setCustomProperties(propMap);
    masterGlobalDBInfo.check();
    dbClusterInfo.setMasterGlobalDBInfo(masterGlobalDBInfo);
    List<Node> slaveGlobalList=xmlUtil.getChildByName(global,""String_Node_Str"");
    if (slaveGlobalList != null && !slaveGlobalList.isEmpty()) {
      List<DBInfo> slaveGlobalConnection=new ArrayList<DBInfo>();
      int slaveIndex=0;
      for (      Node slaveGlobal : slaveGlobalList) {
        dsId=slaveGlobal.getTextContent().trim();
        DBInfo slaveGlobalDBInfo=dsBucketMap.get(dsId);
        if (slaveGlobalDBInfo == null) {
          throw new LoadConfigException(""String_Node_Str"" + dsId);
        }
        slaveGlobalDBInfo.setClusterName(clusterName);
        slaveGlobalDBInfo.setMasterSlave(EnumDBMasterSlave.getSlaveEnum(slaveIndex++));
        propMap=xmlUtil.getAttributeAsMap(slaveGlobal);
        slaveGlobalDBInfo.setCustomProperties(propMap);
        slaveGlobalDBInfo.check();
        slaveGlobalConnection.add(slaveGlobalDBInfo);
      }
      dbClusterInfo.setSlaveGlobalDBInfo(slaveGlobalConnection);
    }
  }
  List<DBRegionInfo> dbRegions=new ArrayList<DBRegionInfo>();
  List<Node> regionNodeList=xmlUtil.getChildByName(clusterNode,""String_Node_Str"");
  DBRegionInfo regionInfo=null;
  for (  Node regionNode : regionNodeList) {
    regionInfo=new DBRegionInfo();
    String regionCapacity=xmlUtil.getAttributeValue(regionNode,""String_Node_Str"");
    if (regionCapacity == null) {
      throw new LoadConfigException(""String_Node_Str"");
    }
    List<Value> values=_parseCapacity(clusterName,regionCapacity);
    regionInfo.setValues(values);
    regionInfo.setCapacity(regionCapacity);
    List<DBInfo> regionMasterConnection=new ArrayList<DBInfo>();
    Node master=xmlUtil.getFirstChildByName(regionNode,""String_Node_Str"");
    List<Node> shardingNodeList=xmlUtil.getChildByName(master,""String_Node_Str"");
    for (    Node shardingNode : shardingNodeList) {
      String dsId=shardingNode.getTextContent().trim();
      DBInfo masterShardingDBInfo=dsBucketMap.get(dsId);
      if (masterShardingDBInfo == null) {
        throw new LoadConfigException(""String_Node_Str"" + dsId);
      }
      masterShardingDBInfo.setClusterName(clusterName);
      masterShardingDBInfo.setMasterSlave(EnumDBMasterSlave.MASTER);
      Map<String,String> propMap=xmlUtil.getAttributeAsMap(shardingNode);
      masterShardingDBInfo.setCustomProperties(propMap);
      masterShardingDBInfo.check();
      regionMasterConnection.add(masterShardingDBInfo);
    }
    regionInfo.setMasterDBInfos(regionMasterConnection);
    List<List<DBInfo>> regionSlaveConnection=new ArrayList<List<DBInfo>>();
    List<Node> slaveNodeList=xmlUtil.getChildByName(regionNode,""String_Node_Str"");
    int slaveIndex=0;
    for (    Node slaveNode : slaveNodeList) {
      shardingNodeList=xmlUtil.getChildByName(slaveNode,""String_Node_Str"");
      List<DBInfo> slaveConnections=new ArrayList<DBInfo>();
      for (      Node shardingNode : shardingNodeList) {
        String dsId=shardingNode.getTextContent().trim();
        DBInfo slaveShardingDBInfo=dsBucketMap.get(dsId);
        if (slaveShardingDBInfo == null) {
          throw new LoadConfigException(""String_Node_Str"" + dsId);
        }
        slaveShardingDBInfo.setClusterName(clusterName);
        slaveShardingDBInfo.setMasterSlave(EnumDBMasterSlave.getSlaveEnum(slaveIndex++));
        Map<String,String> propMap=xmlUtil.getAttributeAsMap(shardingNode);
        slaveShardingDBInfo.setCustomProperties(propMap);
        slaveShardingDBInfo.check();
        slaveConnections.add(slaveShardingDBInfo);
      }
      regionSlaveConnection.add(slaveConnections);
    }
    regionInfo.setSlaveDBInfos(regionSlaveConnection);
    dbRegions.add(regionInfo);
  }
  dbClusterInfo.setDbRegions(dbRegions);
  return dbClusterInfo;
}","@SuppressWarnings(""String_Node_Str"") private DBClusterInfo _getDBClusterInfo(String clusterName,Node clusterNode) throws LoadConfigException {
  DBClusterInfo dbClusterInfo=new DBClusterInfo();
  dbClusterInfo.setClusterName(clusterName);
  try {
    String classFullPath=xmlUtil.getAttributeValue(clusterNode,""String_Node_Str"");
    if (StringUtil.isBlank(classFullPath)) {
      classFullPath=DEFAULT_CLUSTER_ROUTER_CLASS;
    }
    Class<IClusterRouter> clazz=(Class<IClusterRouter>)Class.forName(classFullPath);
    dbClusterInfo.setRouterClass(clazz);
  }
 catch (  Exception e) {
    throw new LoadConfigException(e);
  }
  Node global=xmlUtil.getFirstChildByName(clusterNode,""String_Node_Str"");
  if (global != null) {
    Node masterGlobal=xmlUtil.getFirstChildByName(global,""String_Node_Str"");
    String dsId=masterGlobal.getTextContent().trim();
    if (dsBucketMap.get(dsId) == null) {
      throw new LoadConfigException(""String_Node_Str"" + dsId);
    }
    DBInfo masterGlobalDBInfo=dsBucketMap.get(dsId).clone();
    masterGlobalDBInfo.setClusterName(clusterName);
    masterGlobalDBInfo.setMasterSlave(EnumDBMasterSlave.MASTER);
    Map<String,String> propMap=xmlUtil.getAttributeAsMap(masterGlobal);
    masterGlobalDBInfo.setCustomProperties(propMap);
    masterGlobalDBInfo.check();
    dbClusterInfo.setMasterGlobalDBInfo(masterGlobalDBInfo);
    List<Node> slaveGlobalList=xmlUtil.getChildByName(global,""String_Node_Str"");
    if (slaveGlobalList != null && !slaveGlobalList.isEmpty()) {
      List<DBInfo> slaveGlobalConnection=new ArrayList<DBInfo>();
      int slaveIndex=0;
      for (      Node slaveGlobal : slaveGlobalList) {
        dsId=slaveGlobal.getTextContent().trim();
        if (dsBucketMap.get(dsId) == null) {
          throw new LoadConfigException(""String_Node_Str"" + dsId);
        }
        DBInfo slaveGlobalDBInfo=dsBucketMap.get(dsId).clone();
        slaveGlobalDBInfo.setClusterName(clusterName);
        slaveGlobalDBInfo.setMasterSlave(EnumDBMasterSlave.getSlaveEnum(slaveIndex++));
        propMap=xmlUtil.getAttributeAsMap(slaveGlobal);
        slaveGlobalDBInfo.setCustomProperties(propMap);
        slaveGlobalDBInfo.check();
        slaveGlobalConnection.add(slaveGlobalDBInfo);
      }
      dbClusterInfo.setSlaveGlobalDBInfo(slaveGlobalConnection);
    }
  }
  List<DBRegionInfo> dbRegions=new ArrayList<DBRegionInfo>();
  List<Node> regionNodeList=xmlUtil.getChildByName(clusterNode,""String_Node_Str"");
  DBRegionInfo regionInfo=null;
  for (  Node regionNode : regionNodeList) {
    regionInfo=new DBRegionInfo();
    String regionCapacity=xmlUtil.getAttributeValue(regionNode,""String_Node_Str"");
    if (regionCapacity == null) {
      throw new LoadConfigException(""String_Node_Str"");
    }
    List<Value> values=_parseCapacity(clusterName,regionCapacity);
    regionInfo.setValues(values);
    regionInfo.setCapacity(regionCapacity);
    List<DBInfo> regionMasterConnection=new ArrayList<DBInfo>();
    Node master=xmlUtil.getFirstChildByName(regionNode,""String_Node_Str"");
    List<Node> shardingNodeList=xmlUtil.getChildByName(master,""String_Node_Str"");
    for (    Node shardingNode : shardingNodeList) {
      String dsId=shardingNode.getTextContent().trim();
      if (dsBucketMap.get(dsId) == null) {
        throw new LoadConfigException(""String_Node_Str"" + dsId);
      }
      DBInfo masterShardingDBInfo=dsBucketMap.get(dsId).clone();
      masterShardingDBInfo.setClusterName(clusterName);
      masterShardingDBInfo.setMasterSlave(EnumDBMasterSlave.MASTER);
      Map<String,String> propMap=xmlUtil.getAttributeAsMap(shardingNode);
      masterShardingDBInfo.setCustomProperties(propMap);
      masterShardingDBInfo.check();
      regionMasterConnection.add(masterShardingDBInfo);
    }
    regionInfo.setMasterDBInfos(regionMasterConnection);
    List<List<DBInfo>> regionSlaveConnection=new ArrayList<List<DBInfo>>();
    List<Node> slaveNodeList=xmlUtil.getChildByName(regionNode,""String_Node_Str"");
    int slaveIndex=0;
    for (    Node slaveNode : slaveNodeList) {
      shardingNodeList=xmlUtil.getChildByName(slaveNode,""String_Node_Str"");
      List<DBInfo> slaveConnections=new ArrayList<DBInfo>();
      for (      Node shardingNode : shardingNodeList) {
        String dsId=shardingNode.getTextContent().trim();
        if (dsBucketMap.get(dsId) == null) {
          throw new LoadConfigException(""String_Node_Str"" + dsId);
        }
        DBInfo slaveShardingDBInfo=dsBucketMap.get(dsId).clone();
        slaveShardingDBInfo.setClusterName(clusterName);
        slaveShardingDBInfo.setMasterSlave(EnumDBMasterSlave.getSlaveEnum(slaveIndex++));
        Map<String,String> propMap=xmlUtil.getAttributeAsMap(shardingNode);
        slaveShardingDBInfo.setCustomProperties(propMap);
        slaveShardingDBInfo.check();
        slaveConnections.add(slaveShardingDBInfo);
      }
      regionSlaveConnection.add(slaveConnections);
    }
    regionInfo.setSlaveDBInfos(regionSlaveConnection);
    dbRegions.add(regionInfo);
  }
  dbClusterInfo.setDbRegions(dbRegions);
  return dbClusterInfo;
}",0.950375642546461
90448,"@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) @Override public void updateBatch(List<? extends Object> entityList){
  if (entityList == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  List<Object> globalList=Lists.newArrayList();
  List<Object> shardingList=Lists.newArrayList();
  for (  Object entity : entityList) {
    if (entityMetaManager.isShardingEntity(entity.getClass())) {
      shardingList.add(entity);
    }
 else {
      globalList.add(entity);
    }
  }
  if (!globalList.isEmpty()) {
    Map<String,List<Object>> theSameClusterNameMap=Maps.newHashMap();
    String clusterName=null;
    for (    Object globalEntity : globalList) {
      clusterName=entityMetaManager.getClusterName(globalEntity.getClass());
      List<Object> theSameClusterNameList=theSameClusterNameMap.get(clusterName);
      if (theSameClusterNameList != null) {
        theSameClusterNameList.add(globalEntity);
      }
 else {
        theSameClusterNameList=Lists.newArrayList(globalEntity);
        theSameClusterNameMap.put(clusterName,theSameClusterNameList);
      }
    }
    for (    Map.Entry<String,List<Object>> entry : theSameClusterNameMap.entrySet()) {
      this.globalUpdater.updateBatch(entry.getValue(),entry.getKey());
    }
  }
  if (!shardingList.isEmpty()) {
    Map<IShardingKey<?>,List<Object>> theSameShardingKeyMap=Maps.newHashMap();
    ShardingKey<?> shardingKey=null;
    for (    Object shardingEntity : shardingList) {
      shardingKey=new ShardingKey(entityMetaManager.getClusterName(shardingEntity.getClass()),entityMetaManager.getShardingValue(shardingEntity));
      List<Object> theSameShardingKeyList=theSameShardingKeyMap.get(shardingKey);
      if (theSameShardingKeyList != null) {
        theSameShardingKeyList.add(shardingEntity);
      }
 else {
        theSameShardingKeyList=Lists.newArrayList(shardingEntity);
        theSameShardingKeyMap.put(shardingKey,theSameShardingKeyList);
      }
    }
    for (    Map.Entry<IShardingKey<?>,List<Object>> entry : theSameShardingKeyMap.entrySet()) {
      this.shardingUpdater.updateBatch(entry.getValue(),entry.getKey());
    }
  }
}","@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) @Override public void updateBatch(List<? extends Object> entityList){
  if (entityList == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  List<Object> globalList=Lists.newArrayList();
  List<Object> shardingList=Lists.newArrayList();
  for (  Object entity : entityList) {
    if (entityMetaManager.isShardingEntity(entity.getClass())) {
      shardingList.add(entity);
    }
 else {
      globalList.add(entity);
    }
  }
  if (!globalList.isEmpty()) {
    Map<String,List<Object>> theSameClusterNameMap=Maps.newHashMap();
    String clusterName=null;
    for (    Object globalEntity : globalList) {
      clusterName=entityMetaManager.getClusterName(globalEntity.getClass());
      List<Object> theSameClusterNameList=theSameClusterNameMap.get(clusterName);
      if (theSameClusterNameList != null) {
        theSameClusterNameList.add(globalEntity);
      }
 else {
        theSameClusterNameList=Lists.newArrayList(globalEntity);
        theSameClusterNameMap.put(clusterName,theSameClusterNameList);
      }
    }
    for (    Map.Entry<String,List<Object>> entry : theSameClusterNameMap.entrySet()) {
      this.globalUpdater.updateBatch(entry.getValue(),entry.getKey());
    }
  }
  if (!shardingList.isEmpty()) {
    Map<IShardingKey<?>,List<Object>> theSameShardingKeyMap=Maps.newHashMap();
    IShardingKey<?> shardingKey=null;
    for (    Object shardingEntity : shardingList) {
      shardingKey=entityMetaManager.getShardingKey(shardingEntity);
      List<Object> theSameShardingKeyList=theSameShardingKeyMap.get(shardingKey);
      if (theSameShardingKeyList != null) {
        theSameShardingKeyList.add(shardingEntity);
      }
 else {
        theSameShardingKeyList=Lists.newArrayList(shardingEntity);
        theSameShardingKeyMap.put(shardingKey,theSameShardingKeyList);
      }
    }
    for (    Map.Entry<IShardingKey<?>,List<Object>> entry : theSameShardingKeyMap.entrySet()) {
      this.shardingUpdater.updateBatch(entry.getValue(),entry.getKey());
    }
  }
}",0.9710900473933648
90449,"@Override public void save(Object entity){
  if (entity == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  Class<?> clazz=entity.getClass();
  if (entityMetaManager.isShardingEntity(clazz)) {
    CheckUtil.checkShardingEntity(entity);
    String clusterName=entityMetaManager.getClusterName(clazz);
    Object shardingKey=entityMetaManager.getShardingValue(entity);
    IShardingKey<Object> sk=new ShardingKey<Object>(clusterName,shardingKey);
    CheckUtil.checkShardingKey(sk);
    this.shardingUpdater.save(entity,sk);
  }
 else {
    CheckUtil.checkGlobalEntity(entity);
    String clusterName=entityMetaManager.getClusterName(entity.getClass());
    CheckUtil.checkClusterName(clusterName);
    this.globalUpdater.save(entity,clusterName);
  }
}","@Override public void save(Object entity){
  if (entity == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  Class<?> clazz=entity.getClass();
  if (entityMetaManager.isShardingEntity(clazz)) {
    CheckUtil.checkShardingEntity(entity);
    IShardingKey<?> sk=entityMetaManager.getShardingKey(entity);
    CheckUtil.checkShardingKey(sk);
    this.shardingUpdater.save(entity,sk);
  }
 else {
    CheckUtil.checkGlobalEntity(entity);
    String clusterName=entityMetaManager.getClusterName(entity.getClass());
    CheckUtil.checkClusterName(clusterName);
    this.globalUpdater.save(entity,clusterName);
  }
}",0.8620199146514936
90450,"@Override public void update(Object entity){
  if (entity == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  Class<?> clazz=entity.getClass();
  if (entityMetaManager.isShardingEntity(clazz)) {
    CheckUtil.checkShardingEntity(entity);
    String clusterName=entityMetaManager.getClusterName(entity.getClass());
    Object shardingKey=entityMetaManager.getShardingValue(entity);
    IShardingKey<Object> sk=new ShardingKey<Object>(clusterName,shardingKey);
    CheckUtil.checkShardingKey(sk);
    this.shardingUpdater.update(entity,sk);
  }
 else {
    CheckUtil.checkGlobalEntity(entity);
    String clusterName=entityMetaManager.getClusterName(entity.getClass());
    CheckUtil.checkClusterName(clusterName);
    this.globalUpdater.update(entity,clusterName);
  }
}","@Override public void update(Object entity){
  if (entity == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  Class<?> clazz=entity.getClass();
  if (entityMetaManager.isShardingEntity(clazz)) {
    CheckUtil.checkShardingEntity(entity);
    IShardingKey<?> sk=entityMetaManager.getShardingKey(entity);
    CheckUtil.checkShardingKey(sk);
    this.shardingUpdater.update(entity,sk);
  }
 else {
    CheckUtil.checkGlobalEntity(entity);
    String clusterName=entityMetaManager.getClusterName(entity.getClass());
    CheckUtil.checkClusterName(clusterName);
    this.globalUpdater.update(entity,clusterName);
  }
}",0.855944055944056
90451,"@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) @Override public void delete(List<? extends Object> entityList){
  if (entityList == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  List<Object> globalList=Lists.newArrayList();
  List<Object> shardingList=Lists.newArrayList();
  for (  Object entity : entityList) {
    if (entityMetaManager.isShardingEntity(entity.getClass())) {
      shardingList.add(entity);
    }
 else {
      globalList.add(entity);
    }
  }
  if (!globalList.isEmpty()) {
    Map<String,List<Object>> theSameClusterNameMap=Maps.newHashMap();
    String clusterName=null;
    for (    Object globalEntity : globalList) {
      clusterName=entityMetaManager.getClusterName(globalEntity.getClass());
      List<Object> theSameClusterNameList=theSameClusterNameMap.get(clusterName);
      if (theSameClusterNameList != null) {
        theSameClusterNameList.add(globalEntity);
      }
 else {
        theSameClusterNameList=Lists.newArrayList(globalEntity);
        theSameClusterNameMap.put(clusterName,theSameClusterNameList);
      }
    }
    for (    Map.Entry<String,List<Object>> sameClusterNameEntry : theSameClusterNameMap.entrySet()) {
      Map<Class<?>,List<Object>> theSameClassMap=Maps.newHashMap();
      Class<?> clazz=null;
      for (      Object sameClusterNameEntity : sameClusterNameEntry.getValue()) {
        clazz=sameClusterNameEntity.getClass();
        List<Object> theSameClassList=theSameClassMap.get(clazz);
        if (theSameClassList != null) {
          theSameClassList.add(sameClusterNameEntity);
        }
 else {
          theSameClassMap.put(clazz,Lists.newArrayList(sameClusterNameEntity));
        }
        for (        Map.Entry<Class<?>,List<Object>> sameClassEntry : theSameClassMap.entrySet()) {
          List<EntityPK> pks=Lists.newArrayList();
          for (          Object sameClassEntity : sameClassEntry.getValue()) {
            pks.add(entityMetaManager.getEntityPK(sameClassEntity));
          }
          this.globalUpdater.removeByPks(pks,sameClassEntry.getKey(),sameClusterNameEntry.getKey());
        }
      }
    }
  }
  if (!shardingList.isEmpty()) {
    Map<IShardingKey<?>,List<Object>> theSameShardingKeyMap=Maps.newHashMap();
    ShardingKey<?> shardingKey=null;
    for (    Object shardingEntity : shardingList) {
      shardingKey=new ShardingKey(entityMetaManager.getClusterName(shardingEntity.getClass()),entityMetaManager.getShardingValue(shardingEntity));
      List<Object> theSameShardingKeyList=theSameShardingKeyMap.get(shardingKey);
      if (theSameShardingKeyList != null) {
        theSameShardingKeyList.add(shardingEntity);
      }
 else {
        theSameShardingKeyList=Lists.newArrayList(shardingEntity);
        theSameShardingKeyMap.put(shardingKey,theSameShardingKeyList);
      }
    }
    for (    Map.Entry<IShardingKey<?>,List<Object>> sameShardingKeyEntry : theSameShardingKeyMap.entrySet()) {
      Map<Class<?>,List<Object>> theSameClassMap=Maps.newHashMap();
      Class<?> clazz=null;
      for (      Object sameShardingKeyEntity : sameShardingKeyEntry.getValue()) {
        clazz=sameShardingKeyEntity.getClass();
        List<Object> theSameClassList=theSameClassMap.get(clazz);
        if (theSameClassList != null) {
          theSameClassList.add(sameShardingKeyEntity);
        }
 else {
          theSameClassMap.put(clazz,Lists.newArrayList(sameShardingKeyEntity));
        }
        for (        Map.Entry<Class<?>,List<Object>> sameClassEntry : theSameClassMap.entrySet()) {
          List<EntityPK> pks=Lists.newArrayList();
          for (          Object sameClassEntity : sameClassEntry.getValue()) {
            pks.add(entityMetaManager.getEntityPK(sameClassEntity));
          }
          this.shardingUpdater.removeByPks(pks,sameShardingKeyEntry.getKey(),sameClassEntry.getKey());
        }
      }
    }
  }
}","@Override public void delete(List<? extends Object> entityList){
  if (entityList == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  List<Object> globalList=Lists.newArrayList();
  List<Object> shardingList=Lists.newArrayList();
  for (  Object entity : entityList) {
    if (entityMetaManager.isShardingEntity(entity.getClass())) {
      shardingList.add(entity);
    }
 else {
      globalList.add(entity);
    }
  }
  if (!globalList.isEmpty()) {
    Map<String,List<Object>> theSameClusterNameMap=Maps.newHashMap();
    String clusterName=null;
    for (    Object globalEntity : globalList) {
      clusterName=entityMetaManager.getClusterName(globalEntity.getClass());
      List<Object> theSameClusterNameList=theSameClusterNameMap.get(clusterName);
      if (theSameClusterNameList != null) {
        theSameClusterNameList.add(globalEntity);
      }
 else {
        theSameClusterNameList=Lists.newArrayList(globalEntity);
        theSameClusterNameMap.put(clusterName,theSameClusterNameList);
      }
    }
    for (    Map.Entry<String,List<Object>> sameClusterNameEntry : theSameClusterNameMap.entrySet()) {
      Map<Class<?>,List<Object>> theSameClassMap=Maps.newHashMap();
      Class<?> clazz=null;
      for (      Object sameClusterNameEntity : sameClusterNameEntry.getValue()) {
        clazz=sameClusterNameEntity.getClass();
        List<Object> theSameClassList=theSameClassMap.get(clazz);
        if (theSameClassList != null) {
          theSameClassList.add(sameClusterNameEntity);
        }
 else {
          theSameClassMap.put(clazz,Lists.newArrayList(sameClusterNameEntity));
        }
        for (        Map.Entry<Class<?>,List<Object>> sameClassEntry : theSameClassMap.entrySet()) {
          List<EntityPK> pks=Lists.newArrayList();
          for (          Object sameClassEntity : sameClassEntry.getValue()) {
            pks.add(entityMetaManager.getEntityPK(sameClassEntity));
          }
          this.globalUpdater.removeByPks(pks,sameClassEntry.getKey(),sameClusterNameEntry.getKey());
        }
      }
    }
  }
  if (!shardingList.isEmpty()) {
    Map<IShardingKey<?>,List<Object>> theSameShardingKeyMap=Maps.newHashMap();
    IShardingKey<?> shardingKey=null;
    for (    Object shardingEntity : shardingList) {
      shardingKey=entityMetaManager.getShardingKey(shardingEntity);
      List<Object> theSameShardingKeyList=theSameShardingKeyMap.get(shardingKey);
      if (theSameShardingKeyList != null) {
        theSameShardingKeyList.add(shardingEntity);
      }
 else {
        theSameShardingKeyList=Lists.newArrayList(shardingEntity);
        theSameShardingKeyMap.put(shardingKey,theSameShardingKeyList);
      }
    }
    for (    Map.Entry<IShardingKey<?>,List<Object>> sameShardingKeyEntry : theSameShardingKeyMap.entrySet()) {
      Map<Class<?>,List<Object>> theSameClassMap=Maps.newHashMap();
      Class<?> clazz=null;
      for (      Object sameShardingKeyEntity : sameShardingKeyEntry.getValue()) {
        clazz=sameShardingKeyEntity.getClass();
        List<Object> theSameClassList=theSameClassMap.get(clazz);
        if (theSameClassList != null) {
          theSameClassList.add(sameShardingKeyEntity);
        }
 else {
          theSameClassMap.put(clazz,Lists.newArrayList(sameShardingKeyEntity));
        }
        for (        Map.Entry<Class<?>,List<Object>> sameClassEntry : theSameClassMap.entrySet()) {
          List<EntityPK> pks=Lists.newArrayList();
          for (          Object sameClassEntity : sameClassEntry.getValue()) {
            pks.add(entityMetaManager.getEntityPK(sameClassEntity));
          }
          this.shardingUpdater.removeByPks(pks,sameShardingKeyEntry.getKey(),sameClassEntry.getKey());
        }
      }
    }
  }
}",0.972880911830211
90452,"@Override public void load(Object entity,boolean useCache,EnumDBMasterSlave masterSlave){
  if (entity == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  EntityPK entityPk=entityMetaManager.getEntityPK(entity);
  List<?> resultList=null;
  Class<?> clazz=entity.getClass();
  if (entityMetaManager.isShardingEntity(clazz)) {
    resultList=this.shardingQuery.findByPkList(Lists.newArrayList(entityPk),clazz,useCache,masterSlave);
  }
 else {
    resultList=this.globalQuery.findByPkList(Lists.newArrayList(entityPk),clazz,useCache,masterSlave);
  }
  if (resultList.isEmpty()) {
    throw new DBOperationException(""String_Node_Str"" + entityPk);
  }
  if (resultList.size() > 1) {
    throw new DBOperationException(""String_Node_Str"");
  }
  try {
    BeansUtil.copyProperties(resultList.get(0),entity);
  }
 catch (  Exception e) {
    throw new DBOperationException(e);
  }
}","@Override public void load(Object entity,boolean useCache,EnumDBMasterSlave masterSlave){
  if (entity == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  EntityPK entityPk=entityMetaManager.getEntityPK(entity);
  Object loadEntity=null;
  Class<?> clazz=entity.getClass();
  if (entityMetaManager.isShardingEntity(clazz)) {
    IShardingKey<?> shardingKey=entityMetaManager.getShardingKey(entity);
    loadEntity=this.shardingQuery.findByPk(entityPk,shardingKey,clazz,useCache,masterSlave);
  }
 else {
    loadEntity=this.globalQuery.findByPk(entityPk,clazz,useCache,masterSlave);
  }
  if (loadEntity == null) {
    throw new DBOperationException(""String_Node_Str"" + entityPk);
  }
  try {
    BeansUtil.copyProperties(loadEntity,entity);
  }
 catch (  Exception e) {
    throw new DBOperationException(e);
  }
}",0.4471264367816092
90453,"@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) @Override public void saveBatch(List<? extends Object> entityList,boolean autoGeneratedKeys){
  if (entityList == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  List<Object> globalList=Lists.newArrayList();
  List<Object> shardingList=Lists.newArrayList();
  for (  Object entity : entityList) {
    if (entityMetaManager.isShardingEntity(entity.getClass())) {
      shardingList.add(entity);
    }
 else {
      globalList.add(entity);
    }
  }
  if (!globalList.isEmpty()) {
    Map<String,List<Object>> clusterEntityMap=Maps.newHashMap();
    String clusterName=null;
    for (    Object globalEntity : globalList) {
      clusterName=entityMetaManager.getClusterName(globalEntity.getClass());
      List<Object> theSameClusterNameList=clusterEntityMap.get(clusterName);
      if (theSameClusterNameList != null) {
        theSameClusterNameList.add(globalEntity);
      }
 else {
        theSameClusterNameList=Lists.newArrayList(globalEntity);
        clusterEntityMap.put(clusterName,theSameClusterNameList);
      }
    }
    for (    Map.Entry<String,List<Object>> entry : clusterEntityMap.entrySet()) {
      this.globalUpdater.saveBatch(entry.getValue(),entry.getKey(),autoGeneratedKeys);
    }
  }
  if (!shardingList.isEmpty()) {
    Map<IShardingKey<?>,List<Object>> theSameShardingKeyMap=Maps.newHashMap();
    ShardingKey<?> shardingKey=null;
    for (    Object shardingEntity : shardingList) {
      shardingKey=new ShardingKey(entityMetaManager.getClusterName(shardingEntity.getClass()),entityMetaManager.getShardingValue(shardingEntity));
      List<Object> theSameShardingKeyList=theSameShardingKeyMap.get(shardingKey);
      if (theSameShardingKeyList != null) {
        theSameShardingKeyList.add(shardingEntity);
      }
 else {
        theSameShardingKeyList=Lists.newArrayList(shardingEntity);
        theSameShardingKeyMap.put(shardingKey,theSameShardingKeyList);
      }
    }
    for (    Map.Entry<IShardingKey<?>,List<Object>> entry : theSameShardingKeyMap.entrySet()) {
      this.shardingUpdater.saveBatch(entry.getValue(),entry.getKey(),autoGeneratedKeys);
    }
  }
}","@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) @Override public void saveBatch(List<? extends Object> entityList,boolean autoGeneratedKeys){
  if (entityList == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  List<Object> globalList=Lists.newArrayList();
  List<Object> shardingList=Lists.newArrayList();
  for (  Object entity : entityList) {
    if (entityMetaManager.isShardingEntity(entity.getClass())) {
      shardingList.add(entity);
    }
 else {
      globalList.add(entity);
    }
  }
  if (!globalList.isEmpty()) {
    Map<String,List<Object>> clusterEntityMap=Maps.newHashMap();
    String clusterName=null;
    for (    Object globalEntity : globalList) {
      clusterName=entityMetaManager.getClusterName(globalEntity.getClass());
      List<Object> theSameClusterNameList=clusterEntityMap.get(clusterName);
      if (theSameClusterNameList != null) {
        theSameClusterNameList.add(globalEntity);
      }
 else {
        theSameClusterNameList=Lists.newArrayList(globalEntity);
        clusterEntityMap.put(clusterName,theSameClusterNameList);
      }
    }
    for (    Map.Entry<String,List<Object>> entry : clusterEntityMap.entrySet()) {
      this.globalUpdater.saveBatch(entry.getValue(),entry.getKey(),autoGeneratedKeys);
    }
  }
  if (!shardingList.isEmpty()) {
    Map<IShardingKey<?>,List<Object>> theSameShardingKeyMap=Maps.newHashMap();
    IShardingKey<?> shardingKey=null;
    for (    Object shardingEntity : shardingList) {
      shardingKey=entityMetaManager.getShardingKey(shardingEntity);
      List<Object> theSameShardingKeyList=theSameShardingKeyMap.get(shardingKey);
      if (theSameShardingKeyList != null) {
        theSameShardingKeyList.add(shardingEntity);
      }
 else {
        theSameShardingKeyList=Lists.newArrayList(shardingEntity);
        theSameShardingKeyMap.put(shardingKey,theSameShardingKeyList);
      }
    }
    for (    Map.Entry<IShardingKey<?>,List<Object>> entry : theSameShardingKeyMap.entrySet()) {
      this.shardingUpdater.saveBatch(entry.getValue(),entry.getKey(),autoGeneratedKeys);
    }
  }
}",0.9715750232991612
90454,"/** 
 * 如果存在则更新，否则保存.
 */
public void saveOrUpdate(){
  Class<?> clazz=this.getClass();
  PinusClient pinusClient=DefaultPinusClient.instance;
  EntityPK entityPK=entityMetaManager.getEntityPK(this);
  IQuery<?> query=pinusClient.createQuery(clazz);
  List<Condition> orCond=Lists.newArrayList();
  PKName[] pkNames=entityPK.getPkNames();
  PKValue[] pkValues=entityPK.getPkValues();
  for (int i=0; i < pkNames.length; i++) {
    orCond.add(Condition.eq(pkNames[i].getValue(),pkValues[i].getValue()));
  }
  query.and(Condition.or(orCond.toArray(new Condition[orCond.size()])));
  if (entityMetaManager.isShardingEntity(clazz)) {
    String clusterName=entityMetaManager.getClusterName(clazz);
    Object shardingValue=entityMetaManager.getShardingValue(this);
    IShardingKey<Object> sk=new ShardingKey<Object>(clusterName,shardingValue);
    query.setShardingKey(sk);
  }
  Object obj=query.load();
  if (obj != null) {
    update();
  }
 else {
    save();
  }
}","/** 
 * 如果存在则更新，否则保存.
 */
public void saveOrUpdate(){
  Class<?> clazz=this.getClass();
  PinusClient pinusClient=DefaultPinusClient.instance;
  EntityPK entityPK=entityMetaManager.getEntityPK(this);
  IQuery<?> query=pinusClient.createQuery(clazz);
  List<Condition> orCond=Lists.newArrayList();
  PKName[] pkNames=entityPK.getPkNames();
  PKValue[] pkValues=entityPK.getPkValues();
  for (int i=0; i < pkNames.length; i++) {
    orCond.add(Condition.eq(pkNames[i].getValue(),pkValues[i].getValue()));
  }
  query.and(Condition.or(orCond.toArray(new Condition[orCond.size()])));
  if (entityMetaManager.isShardingEntity(clazz)) {
    IShardingKey<?> sk=entityMetaManager.getShardingKey(this);
    query.setShardingKey(sk);
  }
  Object obj=query.load();
  if (obj != null) {
    update();
  }
 else {
    save();
  }
}",0.7793952967525196
90455,"private PKValue(Object pkValue){
  this.pkValue=pkValue;
}","private PKValue(Object value){
  this.value=value;
}",0.8909090909090909
90456,"public Number getValueAsNumber(){
  if (this.pkValue instanceof Number) {
    return (Number)this.pkValue;
  }
 else {
    throw new ClassCastException(""String_Node_Str"");
  }
}","public Number getValueAsNumber(){
  if (this.value instanceof Number) {
    return (Number)this.value;
  }
 else {
    throw new ClassCastException(""String_Node_Str"");
  }
}",0.9771428571428572
90457,"public int getValueAsInt(){
  if (this.pkValue instanceof Number) {
    return ((Number)this.pkValue).intValue();
  }
 else {
    throw new ClassCastException(""String_Node_Str"");
  }
}","public int getValueAsInt(){
  if (this.value instanceof Number) {
    return ((Number)this.value).intValue();
  }
 else {
    throw new ClassCastException(""String_Node_Str"");
  }
}",0.978021978021978
90458,"public static PKValue valueOf(Object pkValue){
  PKValue pk=new PKValue(pkValue);
  return pk;
}","public static PKValue valueOf(Object value){
  PKValue pk=new PKValue(value);
  return pk;
}",0.9574468085106383
90459,"@Override public int hashCode(){
  final int prime=31;
  int result=1;
  result=prime * result + ((pkValue == null) ? 0 : pkValue.hashCode());
  return result;
}","@Override public int hashCode(){
  final int prime=31;
  int result=1;
  result=prime * result + ((value == null) ? 0 : value.hashCode());
  return result;
}",0.9748427672955976
90460,"@Override public boolean equals(Object obj){
  if (this == obj)   return true;
  if (obj == null)   return false;
  if (getClass() != obj.getClass())   return false;
  PKValue other=(PKValue)obj;
  if (pkValue == null) {
    if (other.pkValue != null)     return false;
  }
 else   if (!pkValue.equals(other.pkValue))   return false;
  return true;
}","@Override public boolean equals(Object obj){
  if (this == obj)   return true;
  if (obj == null)   return false;
  if (getClass() != obj.getClass())   return false;
  PKValue other=(PKValue)obj;
  if (value == null) {
    if (other.value != null)     return false;
  }
 else   if (!value.equals(other.value))   return false;
  return true;
}",0.976878612716763
90461,"@Override public String toString(){
  return ""String_Node_Str"" + pkValue + ""String_Node_Str"";
}","@Override public String toString(){
  return ""String_Node_Str"" + value + ""String_Node_Str"";
}",0.9787234042553192
90462,"public String getValueAsString(){
  return this.pkValue.toString();
}","public String getValueAsString(){
  return this.value.toString();
}",0.9705882352941176
90463,"public long getValueAsLong(){
  if (this.pkValue instanceof Number) {
    return ((Number)this.pkValue).longValue();
  }
 else {
    throw new ClassCastException(""String_Node_Str"");
  }
}","public long getValueAsLong(){
  if (this.value instanceof Number) {
    return ((Number)this.value).longValue();
  }
 else {
    throw new ClassCastException(""String_Node_Str"");
  }
}",0.9783783783783784
90464,"/** 
 * 获取update PreparedStatement.
 * @param conn 数据库连接
 * @param entities 数据对象
 * @param tableIndex 分表下标
 * @return PreparedStatement
 * @throws SQLException
 */
public static Statement getUpdate(Connection conn,List<? extends Object> entities,int tableIndex) throws SQLException {
  Object entity=entities.get(0);
  String tableName=ReflectUtil.getTableName(entity,tableIndex);
  Statement st=conn.createStatement();
  Map<String,Object> entityProperty=null;
  for (  Object dbEntity : entities) {
    try {
      entityProperty=ReflectUtil.describe(dbEntity,true);
    }
 catch (    Exception e) {
      throw new SQLException(""String_Node_Str"",e);
    }
    EntityPK entityPk=ReflectUtil.getPkValue(dbEntity);
    StringBuilder pkWhereSql=new StringBuilder();
    for (int i=0; i < entityPk.getPkNames().length; i++) {
      pkWhereSql.append(entityPk.getPkNames()[i].getValue());
      pkWhereSql.append(""String_Node_Str"");
      pkWhereSql.append(entityPk.getPkValues()[i].getValueAsString());
      pkWhereSql.append(""String_Node_Str"");
    }
    pkWhereSql.delete(pkWhereSql.length() - 5,pkWhereSql.length());
    Set<Map.Entry<String,Object>> propertyEntrySet=entityProperty.entrySet();
    StringBuilder SQL=new StringBuilder(""String_Node_Str"" + tableName + ""String_Node_Str"");
    Object value=null;
    for (    Map.Entry<String,Object> propertyEntry : propertyEntrySet) {
      value=propertyEntry.getValue();
      SQL.append(propertyEntry.getKey()).append(""String_Node_Str"");
      SQL.append(formatValue(value));
      SQL.append(""String_Node_Str"");
    }
    SQL.deleteCharAt(SQL.length() - 1);
    SQL.append(""String_Node_Str"").append(pkWhereSql.toString());
    st.addBatch(SQL.toString());
    debugSQL(SQL.toString());
  }
  return st;
}","/** 
 * 获取update PreparedStatement.
 * @param conn 数据库连接
 * @param entities 数据对象
 * @param tableIndex 分表下标
 * @return PreparedStatement
 * @throws SQLException
 */
public static Statement getUpdate(Connection conn,List<? extends Object> entities,int tableIndex) throws SQLException {
  Object entity=entities.get(0);
  String tableName=ReflectUtil.getTableName(entity,tableIndex);
  Statement st=conn.createStatement();
  Map<String,Object> entityProperty=null;
  for (  Object dbEntity : entities) {
    try {
      entityProperty=ReflectUtil.describe(dbEntity,true);
    }
 catch (    Exception e) {
      throw new SQLException(""String_Node_Str"",e);
    }
    EntityPK entityPk=ReflectUtil.getPkValue(dbEntity);
    StringBuilder pkWhereSql=new StringBuilder();
    for (int i=0; i < entityPk.getPkNames().length; i++) {
      pkWhereSql.append(entityPk.getPkNames()[i].getValue());
      pkWhereSql.append(""String_Node_Str"");
      pkWhereSql.append(formatValue(entityPk.getPkValues()[i].getValue()));
      pkWhereSql.append(""String_Node_Str"");
    }
    pkWhereSql.delete(pkWhereSql.length() - 5,pkWhereSql.length());
    Set<Map.Entry<String,Object>> propertyEntrySet=entityProperty.entrySet();
    StringBuilder SQL=new StringBuilder(""String_Node_Str"" + tableName + ""String_Node_Str"");
    Object value=null;
    for (    Map.Entry<String,Object> propertyEntry : propertyEntrySet) {
      value=propertyEntry.getValue();
      SQL.append(propertyEntry.getKey()).append(""String_Node_Str"");
      SQL.append(formatValue(value));
      SQL.append(""String_Node_Str"");
    }
    SQL.deleteCharAt(SQL.length() - 1);
    SQL.append(""String_Node_Str"").append(pkWhereSql.toString());
    st.addBatch(SQL.toString());
    debugSQL(SQL.toString());
  }
  return st;
}",0.9934714731762704
90465,"/** 
 * 拼装select sql. SELECT field... FROM tableName WHERE pk = ?
 * @param pk 主键
 * @param clazz 数据对象class
 * @param tableIndex 表下标
 * @return sql语句
 */
public static String buildSelectByPk(EntityPK pk,Class<?> clazz,int tableIndex) throws SQLException {
  Field[] fields=ReflectUtil.getFields(clazz);
  String tableName=ReflectUtil.getTableName(clazz,tableIndex);
  StringBuilder whereSql=new StringBuilder();
  for (int i=0; i < pk.getPkNames().length; i++) {
    whereSql.append(pk.getPkNames()[i].getValue()).append(""String_Node_Str"").append(pk.getPkValues()[i].getValueAsString());
    whereSql.append(""String_Node_Str"");
  }
  whereSql.delete(whereSql.length() - 5,whereSql.length());
  StringBuilder SQL=new StringBuilder(""String_Node_Str"");
  for (  Field field : fields) {
    SQL.append(ReflectUtil.getFieldName(field)).append(""String_Node_Str"");
  }
  SQL.deleteCharAt(SQL.length() - 1);
  SQL.append(""String_Node_Str"").append(tableName);
  SQL.append(""String_Node_Str"").append(whereSql.toString());
  debugSQL(SQL.toString());
  return SQL.toString();
}","/** 
 * 拼装select sql. SELECT field... FROM tableName WHERE pk = ?
 * @param pk 主键
 * @param clazz 数据对象class
 * @param tableIndex 表下标
 * @return sql语句
 */
public static String buildSelectByPk(EntityPK pk,Class<?> clazz,int tableIndex) throws SQLException {
  Field[] fields=ReflectUtil.getFields(clazz);
  String tableName=ReflectUtil.getTableName(clazz,tableIndex);
  StringBuilder whereSql=new StringBuilder();
  for (int i=0; i < pk.getPkNames().length; i++) {
    whereSql.append(pk.getPkNames()[i].getValue()).append(""String_Node_Str"").append(formatValue(pk.getPkValues()[i].getValue()));
    whereSql.append(""String_Node_Str"");
  }
  whereSql.delete(whereSql.length() - 5,whereSql.length());
  StringBuilder SQL=new StringBuilder(""String_Node_Str"");
  for (  Field field : fields) {
    SQL.append(ReflectUtil.getFieldName(field)).append(""String_Node_Str"");
  }
  SQL.deleteCharAt(SQL.length() - 1);
  SQL.append(""String_Node_Str"").append(tableName);
  SQL.append(""String_Node_Str"").append(whereSql.toString());
  debugSQL(SQL.toString());
  return SQL.toString();
}",0.9892372484791764
90466,"/** 
 * 拼装select sql. SELECT field, field FROM tableName WHERE pk in (?, ?, ?)
 * @param clazz 数据对象
 * @param tableIndex 表下标
 * @param pks 主键
 * @param query 保证in顺序
 * @return sql语句
 * @throws SQLException
 */
public static String buildSelectByPks(EntityPK[] pks,Class<?> clazz,int tableIndex) throws SQLException {
  Field[] fields=ReflectUtil.getFields(clazz);
  String tableName=ReflectUtil.getTableName(clazz,tableIndex);
  StringBuilder whereSql=new StringBuilder();
  for (  EntityPK pk : pks) {
    whereSql.append(""String_Node_Str"");
    for (int i=0; i < pk.getPkNames().length; i++) {
      whereSql.append(pk.getPkNames()[i].getValue()).append(""String_Node_Str"").append(pk.getPkValues()[i].getValueAsString());
      whereSql.append(""String_Node_Str"");
    }
    whereSql.delete(whereSql.length() - 5,whereSql.length());
    whereSql.append(""String_Node_Str"");
    whereSql.append(""String_Node_Str"");
  }
  whereSql.delete(whereSql.length() - 4,whereSql.length());
  StringBuilder SQL=new StringBuilder(""String_Node_Str"");
  for (  Field field : fields) {
    SQL.append(ReflectUtil.getFieldName(field)).append(""String_Node_Str"");
  }
  SQL.deleteCharAt(SQL.length() - 1);
  SQL.append(""String_Node_Str"").append(tableName);
  SQL.append(""String_Node_Str"").append(whereSql.toString());
  debugSQL(SQL.toString());
  return SQL.toString();
}","/** 
 * 拼装select sql. SELECT field, field FROM tableName WHERE pk in (?, ?, ?)
 * @param clazz 数据对象
 * @param tableIndex 表下标
 * @param pks 主键
 * @param query 保证in顺序
 * @return sql语句
 * @throws SQLException
 */
public static String buildSelectByPks(EntityPK[] pks,Class<?> clazz,int tableIndex) throws SQLException {
  Field[] fields=ReflectUtil.getFields(clazz);
  String tableName=ReflectUtil.getTableName(clazz,tableIndex);
  StringBuilder whereSql=new StringBuilder();
  for (  EntityPK pk : pks) {
    whereSql.append(""String_Node_Str"");
    for (int i=0; i < pk.getPkNames().length; i++) {
      whereSql.append(pk.getPkNames()[i].getValue()).append(""String_Node_Str"").append(formatValue(pk.getPkValues()[i].getValue()));
      whereSql.append(""String_Node_Str"");
    }
    whereSql.delete(whereSql.length() - 5,whereSql.length());
    whereSql.append(""String_Node_Str"");
    whereSql.append(""String_Node_Str"");
  }
  whereSql.delete(whereSql.length() - 4,whereSql.length());
  StringBuilder SQL=new StringBuilder(""String_Node_Str"");
  for (  Field field : fields) {
    SQL.append(ReflectUtil.getFieldName(field)).append(""String_Node_Str"");
  }
  SQL.deleteCharAt(SQL.length() - 1);
  SQL.append(""String_Node_Str"").append(tableName);
  SQL.append(""String_Node_Str"").append(whereSql.toString());
  debugSQL(SQL.toString());
  return SQL.toString();
}",0.9914972273567468
90467,"public static TestGlobalUnionKeyEntity createGlobalUnionKeyEntity(){
  TestGlobalUnionKeyEntity testEntity=new TestGlobalUnionKeyEntity();
  testEntity.setId(r.nextInt());
  testEntity.setTestBool(r.nextBoolean());
  testEntity.setoTestBool(r.nextBoolean());
  testEntity.setTestByte((byte)255);
  testEntity.setoTestByte((byte)255);
  testEntity.setTestChar('b');
  testEntity.setoTestChar('b');
  testEntity.setTestDate(new Date());
  testEntity.setTestDouble(1.0);
  testEntity.setoTestDouble(1.0);
  testEntity.setTestFloat(2.0f);
  testEntity.setoTestFloat(2.0f);
  testEntity.setTestInt(5);
  testEntity.setoTestInt(5);
  testEntity.setTestLong(6l);
  testEntity.setoTestLong(6l);
  testEntity.setTestShort((short)7);
  testEntity.setoTestShort((short)7);
  testEntity.setTestString(getContent(r.nextInt(100)));
  testEntity.setTestTime(new Timestamp(System.currentTimeMillis()));
  return testEntity;
}","public static TestGlobalUnionKeyEntity createGlobalUnionKeyEntity(){
  TestGlobalUnionKeyEntity testEntity=new TestGlobalUnionKeyEntity();
  testEntity.setTestBool(r.nextBoolean());
  testEntity.setoTestBool(r.nextBoolean());
  testEntity.setTestByte((byte)255);
  testEntity.setoTestByte((byte)255);
  testEntity.setTestChar('b');
  testEntity.setoTestChar('b');
  testEntity.setTestDate(new Date());
  testEntity.setTestDouble(1.0);
  testEntity.setoTestDouble(1.0);
  testEntity.setTestFloat(2.0f);
  testEntity.setoTestFloat(2.0f);
  testEntity.setTestInt(5);
  testEntity.setoTestInt(5);
  testEntity.setTestLong(6l);
  testEntity.setoTestLong(6l);
  testEntity.setTestShort((short)7);
  testEntity.setoTestShort((short)7);
  testEntity.setTestString(getContent(r.nextInt(100)));
  testEntity.setTestTime(new Timestamp(System.currentTimeMillis()));
  return testEntity;
}",0.9815126050420168
90468,"@Test public void testSave(){
  TestEntity entity=createEntity();
  TestGlobalEntity globalEntity=createGlobalEntity();
  TestGlobalUnionKeyEntity globalUKEntity=createGlobalUnionKeyEntity();
  try {
    storageClient.beginTransaction();
    storageClient.save(entity);
    storageClient.globalSave(globalEntity);
    storageClient.globalSave(globalUKEntity);
    storageClient.commit();
  }
 catch (  Exception e) {
    e.printStackTrace();
    storageClient.rollback();
  }
}","@Test public void testSave(){
  TestEntity entity=createEntity();
  TestGlobalEntity globalEntity=createGlobalEntity();
  TestGlobalUnionKeyEntity globalUKEntity=createGlobalUnionKeyEntity();
  globalUKEntity.setId(""String_Node_Str"");
  try {
    storageClient.beginTransaction();
    storageClient.save(entity);
    storageClient.globalSave(globalEntity);
    storageClient.globalSave(globalUKEntity);
    storageClient.commit();
  }
 catch (  Exception e) {
    e.printStackTrace();
    storageClient.rollback();
  }
}",0.6579739217652959
90469,"@Test public void testUpdate(){
  try {
    storageClient.beginTransaction();
    TestGlobalEntity globalEntity=storageClient.findByPk(14,TestGlobalEntity.class);
    storageClient.globalUpdate(globalEntity);
    IQuery query=storageClient.createQuery();
    query.add(Condition.eq(""String_Node_Str"",1349897939));
    query.add(Condition.eq(""String_Node_Str"",(byte)-1));
    TestGlobalUnionKeyEntity globalUnionKeyEntity=storageClient.findOneByQuery(query,TestGlobalUnionKeyEntity.class);
    storageClient.globalUpdate(globalUnionKeyEntity);
    storageClient.commit();
  }
 catch (  Exception e) {
    e.printStackTrace();
    storageClient.rollback();
  }
}","@Test public void testUpdate(){
  try {
    storageClient.beginTransaction();
    IQuery query=storageClient.createQuery();
    query.add(Condition.eq(""String_Node_Str"",""String_Node_Str""));
    query.add(Condition.eq(""String_Node_Str"",(byte)-1));
    TestGlobalUnionKeyEntity globalUnionKeyEntity=storageClient.findOneByQuery(query,TestGlobalUnionKeyEntity.class);
    storageClient.globalUpdate(globalUnionKeyEntity);
    storageClient.commit();
  }
 catch (  Exception e) {
    e.printStackTrace();
    storageClient.rollback();
  }
}",0.5501672240802675
90470,"public long getId(){
  return id;
}","public String getId(){
  return id;
}",0.9166666666666666
90471,"public void setId(long id){
  this.id=id;
}","public void setId(String id){
  this.id=id;
}",0.9318181818181818
90472,"private List<Object> _get(List<String> keys){
  List<Object> datas=new ArrayList<Object>();
  try {
    Object value=null;
    for (    String key : keys) {
      value=_get(key);
      if (value != null)       datas.add(value);
    }
  }
 catch (  Exception e) {
    LOG.warn(""String_Node_Str"" + e.getMessage());
  }
  if (LOG.isDebugEnabled()) {
    LOG.debug(""String_Node_Str"" + keys + ""String_Node_Str""+ datas.size());
  }
  return datas;
}","private List<Object> _get(List<String> keys){
  List<Object> datas=new ArrayList<Object>();
  try {
    Object value=null;
    for (    String key : keys) {
      value=_get(key);
      if (value != null)       datas.add(value);
    }
  }
 catch (  Exception e) {
    LOG.warn(""String_Node_Str"" + e.getMessage());
  }
  return datas;
}",0.8241335044929397
90473,"@Override public void load(Object entity,boolean useCache,EnumDBMasterSlave masterSlave){
  if (entity == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  Object loadedEntity=null;
  EntityPK entityPk=entityMetaManager.getEntityPK(entity);
  Class<?> clazz=entity.getClass();
  if (entityMetaManager.isShardingEntity(clazz)) {
    loadedEntity=this.shardingQuery.findByPkList(Lists.newArrayList(entityPk),clazz,useCache,masterSlave);
  }
 else {
    loadedEntity=this.globalQuery.findByPkList(Lists.newArrayList(entityPk),clazz,useCache,masterSlave);
  }
  if (loadedEntity == null) {
    throw new DBOperationException(""String_Node_Str"" + entityPk);
  }
  try {
    BeansUtil.copyProperties(loadedEntity,entity);
  }
 catch (  Exception e) {
    throw new DBOperationException(e);
  }
}","@Override public void load(Object entity,boolean useCache,EnumDBMasterSlave masterSlave){
  if (entity == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  EntityPK entityPk=entityMetaManager.getEntityPK(entity);
  List<?> resultList=null;
  Class<?> clazz=entity.getClass();
  if (entityMetaManager.isShardingEntity(clazz)) {
    resultList=this.shardingQuery.findByPkList(Lists.newArrayList(entityPk),clazz,useCache,masterSlave);
  }
 else {
    resultList=this.globalQuery.findByPkList(Lists.newArrayList(entityPk),clazz,useCache,masterSlave);
  }
  if (resultList.isEmpty()) {
    throw new DBOperationException(""String_Node_Str"" + entityPk);
  }
  if (resultList.size() > 1) {
    throw new DBOperationException(""String_Node_Str"");
  }
  try {
    BeansUtil.copyProperties(resultList.get(0),entity);
  }
 catch (  Exception e) {
    throw new DBOperationException(e);
  }
}",0.7616822429906542
90474,"/** 
 * 将当前Query查询转换为PK查询，提高缓存的命中率.
 * @return
 */
private List<EntityPK> coverToEntityPK(){
  List<EntityPK> entityPkList=Lists.newArrayList();
  PKName[] pkNames=entityMetaManager.getPkName(this.clazz);
  if (pkNames.length != this.condList.size()) {
    return null;
  }
  boolean isMatch=true;
  Condition cond=null;
  for (int i=0; i < this.condList.size(); i++) {
    cond=this.condList.get(i);
    if (i > 0 && cond.getConditionRelation() != ConditionRelation.OR) {
      isMatch=false;
      break;
    }
    if (pkNames.length == 1 && cond.getOrCond().length == 0 && cond.getAndCond().length == 0 && cond.getOpt() == QueryOpt.EQ) {
      PKValue[] pkValues=new PKValue[]{PKValue.valueOf(cond.getValue())};
      entityPkList.add(EntityPK.valueOf(pkNames,pkValues));
    }
 else {
      isMatch=false;
      break;
    }
    if (pkNames.length > 1 && cond.getOrCond().length == 0 && cond.getAndCond().length == pkNames.length && cond.isAndCondAllEQ()) {
      PKValue[] pkValues=new PKValue[cond.getAndCond().length];
      for (int j=0; j < cond.getAndCond().length; j++) {
        pkValues[j]=PKValue.valueOf(cond.getAndCond()[j].getValue());
      }
      entityPkList.add(EntityPK.valueOf(pkNames,pkValues));
    }
 else {
      isMatch=false;
    }
  }
  if (!isMatch) {
    return null;
  }
  return entityPkList;
}","/** 
 * 将当前Query查询转换为PK查询，提高缓存的命中率.
 * @return
 */
private List<EntityPK> coverToEntityPK(){
  List<EntityPK> entityPkList=Lists.newArrayList();
  PKName[] pkNames=entityMetaManager.getPkName(this.clazz);
  if (pkNames.length != this.condList.size()) {
    return null;
  }
  boolean isMatch=true;
  Condition cond=null;
  for (int i=0; i < this.condList.size(); i++) {
    cond=this.condList.get(i);
    if (i > 0 && cond.getConditionRelation() != ConditionRelation.OR) {
      isMatch=false;
      break;
    }
    if (pkNames.length == 1 && (cond.getOrCond() == null || cond.getOrCond().length == 0) && (cond.getAndCond() == null || cond.getAndCond().length == 0) && cond.getOpt() == QueryOpt.EQ && cond.getField().equals(pkNames[0].getValue())) {
      PKValue[] pkValues=new PKValue[]{PKValue.valueOf(cond.getValue())};
      entityPkList.add(EntityPK.valueOf(pkNames,pkValues));
    }
 else {
      isMatch=false;
      break;
    }
    if (pkNames.length > 1 && (cond.getOrCond() == null || cond.getOrCond().length == 0) && cond.getAndCond() != null && cond.getAndCond().length == pkNames.length && cond.isAndCondAllEQ()) {
      PKValue[] pkValues=new PKValue[cond.getAndCond().length];
      for (int j=0; j < cond.getAndCond().length; j++) {
        if (!pkNames[j].getValue().equals(cond.getAndCond()[j].getField())) {
          isMatch=false;
          break;
        }
        pkValues[j]=PKValue.valueOf(cond.getAndCond()[j].getValue());
      }
      entityPkList.add(EntityPK.valueOf(pkNames,pkValues));
    }
 else {
      isMatch=false;
    }
  }
  if (!isMatch) {
    return null;
  }
  return entityPkList;
}",0.8576259722691918
90475,"/** 
 * 执行保存数据操作.
 * @param conn 数据库连接
 * @param entities 需要被保存的数据
 * @param tableIndex 分片表下标. 当-1时忽略下标
 */
protected List<PKValue> _saveBatch(Connection conn,List<? extends Object> entities,int tableIndex){
  List<PKValue> pks=Lists.newArrayList();
  Statement st=null;
  String sql=null;
  Class<?> clazz=null;
  for (  Object entity : entities) {
    try {
      st=conn.createStatement();
      sql=SQLBuilder.getInsert(conn,entity,tableIndex);
      st.execute(sql,Statement.RETURN_GENERATED_KEYS);
      clazz=entity.getClass();
      if (!entityMetaManager.isUnionKey(clazz)) {
        ResultSet rs=st.getGeneratedKeys();
        PKName pkName=entityMetaManager.getNotUnionPkName(clazz);
        if (rs.next()) {
          BeansUtil.setProperty(entity,pkName.getValue(),rs.getObject(1));
          pks.add(PKValue.valueOf(rs.getObject(1)));
        }
      }
    }
 catch (    SQLException e) {
      try {
        conn.rollback();
      }
 catch (      SQLException e1) {
        LOG.error(e1.getMessage());
      }
      throw new DBOperationException(e);
    }
 finally {
      JdbcUtil.close(st);
    }
  }
  return pks;
}","/** 
 * 执行保存数据操作.
 * @param conn 数据库连接
 * @param entities 需要被保存的数据
 * @param tableIndex 分片表下标. 当-1时忽略下标
 */
protected List<PKValue> _saveBatch(Connection conn,List<? extends Object> entities,int tableIndex){
  List<PKValue> pks=Lists.newArrayList();
  Statement st=null;
  String sql=null;
  Class<?> clazz=null;
  for (  Object entity : entities) {
    try {
      st=conn.createStatement();
      sql=SQLBuilder.getInsert(conn,entity,tableIndex);
      st.execute(sql,Statement.RETURN_GENERATED_KEYS);
      clazz=entity.getClass();
      if (!entityMetaManager.isUnionKey(clazz)) {
        ResultSet rs=st.getGeneratedKeys();
        PKName pkName=entityMetaManager.getNotUnionPkName(clazz);
        Field f=BeansUtil.getField(clazz,pkName.getValue());
        Object incrPK=null;
        if (rs.next()) {
          incrPK=rs.getObject(1);
          if (f.getType() == Integer.TYPE || f.getType() == Integer.class) {
            BeansUtil.setProperty(entity,pkName.getValue(),((Long)incrPK).intValue());
            pks.add(PKValue.valueOf(((Long)incrPK).intValue()));
          }
 else {
            BeansUtil.setProperty(entity,pkName.getValue(),incrPK);
            pks.add(PKValue.valueOf(incrPK));
          }
        }
      }
    }
 catch (    SQLException e) {
      try {
        conn.rollback();
      }
 catch (      SQLException e1) {
        LOG.error(e1.getMessage());
      }
      throw new DBOperationException(e);
    }
 finally {
      JdbcUtil.close(st);
    }
  }
  return pks;
}",0.8057663125948407
90476,"public static TestGlobalEntity createGlobalEntity(){
  TestGlobalEntity testEntity=new TestGlobalEntity();
  testEntity.setTestBool(r.nextBoolean());
  testEntity.setoTestBool(r.nextBoolean());
  testEntity.setTestByte((byte)255);
  testEntity.setoTestByte((byte)255);
  testEntity.setTestChar('b');
  testEntity.setoTestChar('b');
  testEntity.setTestDate(new Date());
  testEntity.setTestDouble(1.0);
  testEntity.setoTestDouble(1.0);
  testEntity.setTestFloat(2.0f);
  testEntity.setoTestFloat(2.0f);
  testEntity.setTestInt(5);
  testEntity.setoTestInt(5);
  testEntity.setTestLong(6l);
  testEntity.setoTestLong(6l);
  testEntity.setTestShort((short)7);
  testEntity.setoTestShort((short)7);
  testEntity.setTestString(getContent(r.nextInt(100)));
  testEntity.setTestTime(new Timestamp(System.currentTimeMillis()));
  return testEntity;
}","public static TestGlobalEntity createGlobalEntity(){
  TestGlobalEntity testEntity=new TestGlobalEntity();
  testEntity.setTestBool(true);
  testEntity.setoTestBool(false);
  testEntity.setTestByte((byte)255);
  testEntity.setoTestByte((byte)255);
  testEntity.setTestChar('b');
  testEntity.setoTestChar('b');
  testEntity.setTestDate(new Date());
  testEntity.setTestDouble(1.0);
  testEntity.setoTestDouble(1.0);
  testEntity.setTestFloat(2.0f);
  testEntity.setoTestFloat(2.0f);
  testEntity.setTestInt(5);
  testEntity.setoTestInt(5);
  testEntity.setTestLong(6l);
  testEntity.setoTestLong(6l);
  testEntity.setTestShort((short)7);
  testEntity.setoTestShort((short)7);
  testEntity.setTestString(getContent(r.nextInt(100)));
  testEntity.setTestTime(new Timestamp(System.currentTimeMillis()));
  return testEntity;
}",0.9478104379124176
90477,"public static TestGlobalUnionKeyEntity createGlobalUnionKeyEntity(){
  TestGlobalUnionKeyEntity testEntity=new TestGlobalUnionKeyEntity();
  testEntity.setTestBool(r.nextBoolean());
  testEntity.setoTestBool(r.nextBoolean());
  testEntity.setTestByte((byte)255);
  testEntity.setoTestByte((byte)255);
  testEntity.setTestChar('b');
  testEntity.setoTestChar('b');
  testEntity.setTestDate(new Date());
  testEntity.setTestDouble(1.0);
  testEntity.setoTestDouble(1.0);
  testEntity.setTestFloat(2.0f);
  testEntity.setoTestFloat(2.0f);
  testEntity.setTestInt(5);
  testEntity.setoTestInt(5);
  testEntity.setTestLong(6l);
  testEntity.setoTestLong(6l);
  testEntity.setTestShort((short)7);
  testEntity.setoTestShort((short)7);
  testEntity.setTestString(getContent(r.nextInt(100)));
  testEntity.setTestTime(new Timestamp(System.currentTimeMillis()));
  return testEntity;
}","public static TestGlobalUnionKeyEntity createGlobalUnionKeyEntity(){
  TestGlobalUnionKeyEntity testEntity=new TestGlobalUnionKeyEntity();
  testEntity.setTestBool(true);
  testEntity.setoTestBool(false);
  testEntity.setTestByte((byte)255);
  testEntity.setoTestByte((byte)255);
  testEntity.setTestChar('b');
  testEntity.setoTestChar('b');
  testEntity.setTestDate(new Date());
  testEntity.setTestDouble(1.0);
  testEntity.setoTestDouble(1.0);
  testEntity.setTestFloat(2.0f);
  testEntity.setoTestFloat(2.0f);
  testEntity.setTestInt(5);
  testEntity.setoTestInt(5);
  testEntity.setTestLong(6l);
  testEntity.setoTestLong(6l);
  testEntity.setTestShort((short)7);
  testEntity.setoTestShort((short)7);
  testEntity.setTestString(getContent(r.nextInt(100)));
  testEntity.setTestTime(new Timestamp(System.currentTimeMillis()));
  return testEntity;
}",0.949740034662045
90478,"public static TestEntity createEntity(){
  TestEntity testEntity=new TestEntity();
  testEntity.setTestBool(r.nextBoolean());
  testEntity.setOTestBool(r.nextBoolean());
  testEntity.setTestByte((byte)255);
  testEntity.setOTestByte((byte)255);
  testEntity.setTestChar('a');
  testEntity.setOTestChar('a');
  testEntity.setTestDate(new Date());
  testEntity.setTestDouble(1.0);
  testEntity.setOTestDouble(1.0);
  testEntity.setTestFloat(2.0f);
  testEntity.setOTestFloat(2.0f);
  testEntity.setTestInt(5);
  testEntity.setOTestInt(5);
  testEntity.setTestLong(6l);
  testEntity.setOTestLong(6l);
  testEntity.setTestShort((short)7);
  testEntity.setOTestShort((short)7);
  testEntity.setTestString(getContent(r.nextInt(100)));
  testEntity.setTestTime(new Timestamp(System.currentTimeMillis()));
  return testEntity;
}","public static TestEntity createEntity(){
  TestEntity testEntity=new TestEntity();
  testEntity.setTestBool(true);
  testEntity.setOTestBool(false);
  testEntity.setTestByte((byte)255);
  testEntity.setOTestByte((byte)255);
  testEntity.setTestChar('a');
  testEntity.setOTestChar('a');
  testEntity.setTestDate(new Date());
  testEntity.setTestDouble(1.0);
  testEntity.setOTestDouble(1.0);
  testEntity.setTestFloat(2.0f);
  testEntity.setOTestFloat(2.0f);
  testEntity.setTestInt(5);
  testEntity.setOTestInt(5);
  testEntity.setTestLong(6l);
  testEntity.setOTestLong(6l);
  testEntity.setTestShort((short)7);
  testEntity.setOTestShort((short)7);
  testEntity.setTestString(getContent(r.nextInt(100)));
  testEntity.setTestTime(new Timestamp(System.currentTimeMillis()));
  return testEntity;
}",0.9462631253860408
90479,"public long getId(){
  return id;
}","public Integer getId(){
  return id;
}",0.9041095890410958
90480,"public void setId(long id){
  this.id=id;
}","public void setId(Integer id){
  this.id=id;
}",0.9213483146067416
90481,"@Transactional public void saveDataWithException(long globalId,long shardingId){
  TestGlobalEntity testGlobalEntity=new TestGlobalEntity();
  testGlobalEntity.setId(globalId);
  TestEntity testEntity=new TestEntity();
  testEntity.setId(shardingId);
  testEntity.setTestInt(10);
  storageClient.globalSave(testGlobalEntity);
  storageClient.save(testEntity);
  throw new RuntimeException();
}","@Transactional public void saveDataWithException(long globalId,long shardingId){
  TestGlobalEntity testGlobalEntity=new TestGlobalEntity();
  testGlobalEntity.setId((int)globalId);
  TestEntity testEntity=new TestEntity();
  testEntity.setId(shardingId);
  testEntity.setTestInt(10);
  storageClient.globalSave(testGlobalEntity);
  storageClient.save(testEntity);
  throw new RuntimeException();
}",0.9936788874841972
90482,"@Transactional public void saveData(long globalId,long shardingId){
  TestGlobalEntity testGlobalEntity=new TestGlobalEntity();
  testGlobalEntity.setId(globalId);
  TestEntity testEntity=new TestEntity();
  testEntity.setId(shardingId);
  testEntity.setTestInt(10);
  storageClient.globalSave(testGlobalEntity);
  storageClient.save(testEntity);
}","@Transactional public void saveData(long globalId,long shardingId){
  TestGlobalEntity testGlobalEntity=new TestGlobalEntity();
  testGlobalEntity.setId((int)globalId);
  TestEntity testEntity=new TestEntity();
  testEntity.setId(shardingId);
  testEntity.setTestInt(10);
  storageClient.globalSave(testGlobalEntity);
  storageClient.save(testEntity);
}",0.992867332382311
90483,"@Test public void testRollback(){
  long globalId=1;
  long shardingId=1;
  TestGlobalEntity testGlobalEntity=createGlobalEntity();
  testGlobalEntity.setId(globalId);
  TestEntity testEntity=createEntity();
  testEntity.setId(shardingId);
  storageClient.beginTransaction();
  try {
    storageClient.globalSave(testGlobalEntity).longValue();
    storageClient.save(testEntity).longValue();
    throw new RuntimeException();
  }
 catch (  Exception e) {
    storageClient.rollback();
  }
  TestGlobalEntity a=storageClient.findByPk(globalId,TestGlobalEntity.class);
  IShardingKey<Integer> sk=new ShardingKey<Integer>(CLUSTER_KLSTORAGE,testEntity.getTestInt());
  TestEntity b=storageClient.findByPk(shardingId,sk,TestEntity.class);
  Assert.assertNull(a);
  Assert.assertNull(b);
}","@Test public void testRollback(){
  int globalId=1;
  long shardingId=1;
  TestGlobalEntity testGlobalEntity=createGlobalEntity();
  testGlobalEntity.setId(globalId);
  TestEntity testEntity=createEntity();
  testEntity.setId(shardingId);
  storageClient.beginTransaction();
  try {
    storageClient.globalSave(testGlobalEntity).longValue();
    storageClient.save(testEntity).longValue();
    throw new RuntimeException();
  }
 catch (  Exception e) {
    storageClient.rollback();
  }
  TestGlobalEntity a=storageClient.findByPk(globalId,TestGlobalEntity.class);
  IShardingKey<Integer> sk=new ShardingKey<Integer>(CLUSTER_KLSTORAGE,testEntity.getTestInt());
  TestEntity b=storageClient.findByPk(shardingId,sk,TestEntity.class);
  Assert.assertNull(a);
  Assert.assertNull(b);
}",0.9955271565495208
90484,"/** 
 * 通过反射给对象属性赋值.
 * @param obj 被反射的对象
 * @param propertyName 赋值的属性名
 * @param value 值
 * @throws Exception 操作失败
 */
public static void setProperty(Object obj,String propertyName,Object value) throws Exception {
  Field f=getField(obj.getClass(),propertyName);
  if (f == null) {
    f=obj.getClass().getDeclaredField(propertyName);
  }
  f.setAccessible(true);
  if (f.getType() == Boolean.TYPE || f.getType() == Boolean.class) {
    f.setBoolean(obj,((Boolean)value).booleanValue());
  }
 else   if (f.getType() == Integer.TYPE || f.getType() == Integer.class) {
    f.setInt(obj,((Number)value).intValue());
  }
 else   if (f.getType() == Byte.TYPE || f.getType() == Byte.class) {
    f.setByte(obj,((Number)value).byteValue());
  }
 else   if (f.getType() == Long.TYPE || f.getType() == Long.class) {
    f.setLong(obj,((Number)value).longValue());
  }
 else   if (f.getType() == Short.TYPE || f.getType() == Short.class) {
    f.setShort(obj,((Number)value).shortValue());
  }
 else   if (f.getType() == Float.TYPE || f.getType() == Short.class) {
    f.setFloat(obj,((Number)value).floatValue());
  }
 else   if (f.getType() == Double.TYPE || f.getType() == Double.class) {
    f.setDouble(obj,((Number)value).doubleValue());
  }
 else {
    f.set(obj,value);
  }
}","/** 
 * 通过反射给对象属性赋值.
 * @param obj 被反射的对象
 * @param propertyName 赋值的属性名
 * @param value 值
 * @throws Exception 操作失败
 */
public static void setProperty(Object obj,String propertyName,Object value) throws Exception {
  Field f=getField(obj.getClass(),propertyName);
  if (f == null) {
    f=obj.getClass().getDeclaredField(propertyName);
  }
  f.setAccessible(true);
  if (f.getType() == Boolean.TYPE) {
    f.setBoolean(obj,((Boolean)value).booleanValue());
  }
 else   if (f.getType() == Integer.TYPE) {
    f.setInt(obj,((Number)value).intValue());
  }
 else   if (f.getType() == Byte.TYPE) {
    f.setByte(obj,((Number)value).byteValue());
  }
 else   if (f.getType() == Long.TYPE) {
    f.setLong(obj,((Number)value).longValue());
  }
 else   if (f.getType() == Short.TYPE) {
    f.setShort(obj,((Number)value).shortValue());
  }
 else   if (f.getType() == Float.TYPE) {
    f.setFloat(obj,((Number)value).floatValue());
  }
 else   if (f.getType() == Double.TYPE) {
    f.setDouble(obj,((Number)value).doubleValue());
  }
 else   if (f.getType() == Character.TYPE) {
    f.setChar(obj,((Character)value).charValue());
  }
 else {
    f.set(obj,value);
  }
}",0.8640657084188912
90485,"@Test public void testSetProperty() throws Exception {
  TestEntity entity=new TestEntity();
  ReflectUtil.setProperty(entity,""String_Node_Str"",""String_Node_Str"");
  Assert.assertEquals(""String_Node_Str"",entity.getTestString());
}","@Test public void testSetProperty() throws Exception {
  TestEntity entity=new TestEntity();
  ReflectUtil.setProperty(entity,""String_Node_Str"",""String_Node_Str"");
  Assert.assertEquals(""String_Node_Str"",entity.getTestString());
  ReflectUtil.setProperty(entity,""String_Node_Str"",1);
  Assert.assertEquals(1,entity.getOTestInt().intValue());
}",0.8027923211169284
90486,"@Override public void load(Object entity,boolean useCache,EnumDBMasterSlave masterSlave){
  if (entity == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  Object loadedEntity=null;
  EntityPK entityPk=entityMetaManager.getEntityPK(entity);
  Class<?> clazz=entity.getClass();
  if (entityMetaManager.isShardingEntity(clazz)) {
    loadedEntity=this.shardingQuery.findByPk(entityPk,clazz,useCache,masterSlave);
  }
 else {
    loadedEntity=this.globalQuery.findByPk(entityPk,clazz,useCache,masterSlave);
  }
  if (loadedEntity == null) {
    throw new DBOperationException(""String_Node_Str"" + entityPk);
  }
  try {
    BeansUtil.copyProperties(loadedEntity,entity);
  }
 catch (  Exception e) {
    throw new DBOperationException(e);
  }
}","@Override public void load(Object entity,boolean useCache,EnumDBMasterSlave masterSlave){
  if (entity == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  Object loadedEntity=null;
  EntityPK entityPk=entityMetaManager.getEntityPK(entity);
  Class<?> clazz=entity.getClass();
  if (entityMetaManager.isShardingEntity(clazz)) {
    loadedEntity=this.shardingQuery.findByPkList(Lists.newArrayList(entityPk),clazz,useCache,masterSlave);
  }
 else {
    loadedEntity=this.globalQuery.findByPkList(Lists.newArrayList(entityPk),clazz,useCache,masterSlave);
  }
  if (loadedEntity == null) {
    throw new DBOperationException(""String_Node_Str"" + entityPk);
  }
  try {
    BeansUtil.copyProperties(loadedEntity,entity);
  }
 catch (  Exception e) {
    throw new DBOperationException(e);
  }
}",0.9695044472681068
90487,"/** 
 * 返回当前条件对象表示的sql语句.
 * @return sql语句
 */
public String getSql(){
  StringBuilder SQL=new StringBuilder();
  if (orCond != null && orCond.length > 0) {
    SQL.append(""String_Node_Str"");
    for (    Condition cond : orCond) {
      SQL.append(cond.getSql()).append(""String_Node_Str"");
    }
    SQL.delete(SQL.lastIndexOf(""String_Node_Str""),SQL.length());
    SQL.append(""String_Node_Str"");
    return SQL.toString();
  }
 else {
    SQL.append(field).append(""String_Node_Str"").append(opt.getSymbol()).append(""String_Node_Str"");
switch (opt) {
case IN:
      SQL.append(""String_Node_Str"");
    for (int i=0; i < Array.getLength(this.value); i++) {
      Object val=Array.get(this.value,i);
      Class<?> clazz=val.getClass();
      if (clazz == String.class) {
        SQL.append(""String_Node_Str"").append(val).append(""String_Node_Str"");
      }
 else       if (clazz == Boolean.class || clazz == Boolean.TYPE) {
        if ((Boolean)val) {
          SQL.append(""String_Node_Str"").append(""String_Node_Str"").append(""String_Node_Str"");
        }
 else {
          SQL.append(""String_Node_Str"").append(""String_Node_Str"").append(""String_Node_Str"");
        }
      }
 else {
        SQL.append(val);
      }
      SQL.append(""String_Node_Str"");
    }
  SQL.deleteCharAt(SQL.length() - 1);
SQL.append(""String_Node_Str"");
break;
case ISNULL:
break;
case ISNOTNULL:
break;
default :
Object value=this.value;
if (value instanceof String) {
SQL.append(value);
}
 else if (value instanceof Boolean) {
if ((Boolean)value) {
SQL.append(""String_Node_Str"").append(""String_Node_Str"").append(""String_Node_Str"");
}
 else {
SQL.append(""String_Node_Str"").append(""String_Node_Str"").append(""String_Node_Str"");
}
}
 else {
SQL.append(value);
}
break;
}
return SQL.toString();
}
}","/** 
 * 返回当前条件对象表示的sql语句.
 * @return sql语句
 */
public String getSql(){
  StringBuilder SQL=new StringBuilder();
  if (orCond != null && orCond.length > 0) {
    SQL.append(""String_Node_Str"");
    for (    Condition cond : orCond) {
      SQL.append(cond.getSql()).append(""String_Node_Str"");
    }
    SQL.delete(SQL.lastIndexOf(""String_Node_Str""),SQL.length());
    SQL.append(""String_Node_Str"");
    return SQL.toString();
  }
 else {
    SQL.append(field).append(""String_Node_Str"").append(opt.getSymbol()).append(""String_Node_Str"");
switch (opt) {
case IN:
      SQL.append(""String_Node_Str"");
    for (int i=0; i < Array.getLength(this.value); i++) {
      Object val=Array.get(this.value,i);
      Class<?> clazz=val.getClass();
      if (clazz == String.class) {
        SQL.append(""String_Node_Str"").append(val).append(""String_Node_Str"");
      }
 else       if (clazz == Boolean.class || clazz == Boolean.TYPE) {
        if ((Boolean)val) {
          SQL.append(""String_Node_Str"").append(""String_Node_Str"").append(""String_Node_Str"");
        }
 else {
          SQL.append(""String_Node_Str"").append(""String_Node_Str"").append(""String_Node_Str"");
        }
      }
 else {
        SQL.append(val);
      }
      SQL.append(""String_Node_Str"");
    }
  SQL.deleteCharAt(SQL.length() - 1);
SQL.append(""String_Node_Str"");
break;
case ISNULL:
break;
case ISNOTNULL:
break;
default :
Object value=this.value;
if (value instanceof String) {
SQL.append(value);
}
 else if (value instanceof Boolean) {
if ((Boolean)value) {
SQL.append(""String_Node_Str"").append(""String_Node_Str"").append(""String_Node_Str"");
}
 else {
SQL.append(""String_Node_Str"").append(""String_Node_Str"").append(""String_Node_Str"");
}
}
 else {
SQL.append(value);
}
break;
}
return SQL.toString().trim();
}
}",0.998019801980198
90488,"/** 
 * 将数据转换为数据对象
 * @param clazz 数据对象
 * @param rs 结果集
 * @return {pkValue, Object}
 * @throws SQLException
 */
public static <T>Map<EntityPK,T> buildResultObjectAsMap(Class<T> clazz,ResultSet rs) throws SQLException {
  Map<EntityPK,T> map=Maps.newHashMap();
  ResultSetMetaData rsmd=rs.getMetaData();
  T one=null;
  String fieldName=null;
  PKName[] pkNames=entityMetaManager.getPkName(clazz);
  PKValue[] pkValues=new PKValue[pkNames.length];
  Field f=null;
  Object value=null;
  while (rs.next()) {
    try {
      one=(T)clazz.newInstance();
      for (int i=1; i <= rsmd.getColumnCount(); i++) {
        fieldName=rsmd.getColumnName(i);
        f=BeansUtil.getField(clazz,fieldName);
        value=_getRsValue(rs,f,i);
        BeansUtil.setProperty(one,fieldName,value);
      }
      for (int i=0; i < pkNames.length; i++) {
        pkValues[i]=PKValue.valueOf(rs.getObject(pkNames[i].getValue()));
      }
      map.put(EntityPK.valueOf(pkNames,pkValues),one);
    }
 catch (    Exception e) {
      throw new SQLException(e);
    }
  }
  return map;
}","/** 
 * 将数据转换为数据对象
 * @param clazz 数据对象
 * @param rs 结果集
 * @return {pkValue, Object}
 * @throws SQLException
 */
public static <T>Map<EntityPK,T> buildResultObjectAsMap(Class<T> clazz,ResultSet rs) throws SQLException {
  Map<EntityPK,T> map=Maps.newHashMap();
  ResultSetMetaData rsmd=rs.getMetaData();
  T one=null;
  String fieldName=null;
  PKName[] pkNames=entityMetaManager.getPkName(clazz);
  PKValue[] pkValues=null;
  Field f=null;
  Object value=null;
  while (rs.next()) {
    try {
      one=(T)clazz.newInstance();
      for (int i=1; i <= rsmd.getColumnCount(); i++) {
        fieldName=rsmd.getColumnName(i);
        f=BeansUtil.getField(clazz,fieldName);
        value=_getRsValue(rs,f,i);
        BeansUtil.setProperty(one,fieldName,value);
      }
      pkValues=new PKValue[pkNames.length];
      for (int i=0; i < pkNames.length; i++) {
        pkValues[i]=PKValue.valueOf(rs.getObject(pkNames[i].getValue()));
      }
      map.put(EntityPK.valueOf(pkNames,pkValues),one);
    }
 catch (    Exception e) {
      throw new SQLException(e);
    }
  }
  return map;
}",0.9660622966062296
90489,"public Integer getId(){
  return id;
}","public long getId(){
  return id;
}",0.9041095890410958
90490,"public void setId(Integer id){
  this.id=id;
}","public void setId(long id){
  this.id=id;
}",0.9213483146067416
90491,"@Transactional public void saveDataWithException(long globalId,long shardingId){
  TestGlobalEntity testGlobalEntity=new TestGlobalEntity();
  testGlobalEntity.setId((int)globalId);
  TestEntity testEntity=new TestEntity();
  testEntity.setId(shardingId);
  testEntity.setTestInt(10);
  storageClient.globalSave(testGlobalEntity);
  storageClient.save(testEntity);
  throw new RuntimeException();
}","@Transactional public void saveDataWithException(long globalId,long shardingId){
  TestGlobalEntity testGlobalEntity=new TestGlobalEntity();
  testGlobalEntity.setId(globalId);
  TestEntity testEntity=new TestEntity();
  testEntity.setId(shardingId);
  testEntity.setTestInt(10);
  storageClient.globalSave(testGlobalEntity);
  storageClient.save(testEntity);
  throw new RuntimeException();
}",0.9936788874841972
90492,"@Transactional public void saveData(long globalId,long shardingId){
  TestGlobalEntity testGlobalEntity=new TestGlobalEntity();
  testGlobalEntity.setId((int)globalId);
  TestEntity testEntity=new TestEntity();
  testEntity.setId(shardingId);
  testEntity.setTestInt(10);
  storageClient.globalSave(testGlobalEntity);
  storageClient.save(testEntity);
}","@Transactional public void saveData(long globalId,long shardingId){
  TestGlobalEntity testGlobalEntity=new TestGlobalEntity();
  testGlobalEntity.setId(globalId);
  TestEntity testEntity=new TestEntity();
  testEntity.setId(shardingId);
  testEntity.setTestInt(10);
  storageClient.globalSave(testGlobalEntity);
  storageClient.save(testEntity);
}",0.992867332382311
90493,"@Test public void testRollback(){
  int globalId=1;
  long shardingId=1;
  TestGlobalEntity testGlobalEntity=createGlobalEntity();
  testGlobalEntity.setId(globalId);
  TestEntity testEntity=createEntity();
  testEntity.setId(shardingId);
  storageClient.beginTransaction();
  try {
    storageClient.globalSave(testGlobalEntity).longValue();
    storageClient.save(testEntity).longValue();
    throw new RuntimeException();
  }
 catch (  Exception e) {
    storageClient.rollback();
  }
  TestGlobalEntity a=storageClient.findByPk(globalId,TestGlobalEntity.class);
  IShardingKey<Integer> sk=new ShardingKey<Integer>(CLUSTER_KLSTORAGE,testEntity.getTestInt());
  TestEntity b=storageClient.findByPk(shardingId,sk,TestEntity.class);
  Assert.assertNull(a);
  Assert.assertNull(b);
}","@Test public void testRollback(){
  long globalId=1;
  long shardingId=1;
  TestGlobalEntity testGlobalEntity=createGlobalEntity();
  testGlobalEntity.setId(globalId);
  TestEntity testEntity=createEntity();
  testEntity.setId(shardingId);
  storageClient.beginTransaction();
  try {
    storageClient.globalSave(testGlobalEntity).longValue();
    storageClient.save(testEntity).longValue();
    throw new RuntimeException();
  }
 catch (  Exception e) {
    storageClient.rollback();
  }
  TestGlobalEntity a=storageClient.findByPk(globalId,TestGlobalEntity.class);
  IShardingKey<Integer> sk=new ShardingKey<Integer>(CLUSTER_KLSTORAGE,testEntity.getTestInt());
  TestEntity b=storageClient.findByPk(shardingId,sk,TestEntity.class);
  Assert.assertNull(a);
  Assert.assertNull(b);
}",0.9955271565495208
90494,"/** 
 * 通过翻身将class转换为DBTable对象
 */
protected DBTable converTo(Class<?> defClass){
  if (defClass == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  Class<?> clazz;
  try {
    clazz=defClass.newInstance().getClass();
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
  Table annoTable=clazz.getAnnotation(Table.class);
  if (annoTable == null) {
    throw new IllegalArgumentException(clazz + ""String_Node_Str"");
  }
  String tableName=ReflectUtil.getTableName(clazz);
  DBTable table=new DBTable(tableName.toLowerCase());
  String cluster=annoTable.cluster();
  if (StringUtils.isBlank(cluster)) {
    throw new IllegalArgumentException(clazz + ""String_Node_Str"");
  }
  table.setCluster(cluster);
  String shardingBy=annoTable.shardingBy();
  table.setShardingBy(shardingBy);
  int shardingNum=annoTable.shardingNum();
  table.setShardingNum(shardingNum);
  _parseDBIndex(table,clazz);
  DBTableColumn column=null;
  org.pinus.generator.annotation.Field dbField=null;
  PrimaryKey pk=null;
  UpdateTime updateTime=null;
  DateTime datetime=null;
  boolean isSetPrimaryKey=false;
  for (  Field f : clazz.getDeclaredFields()) {
    column=new DBTableColumn();
    datetime=f.getAnnotation(DateTime.class);
    if (datetime != null) {
      if (f.getType() != Date.class) {
        throw new IllegalArgumentException(clazz + ""String_Node_Str"" + f.getName()+ ""String_Node_Str""+ f.getType()+ ""String_Node_Str"");
      }
      column.setField(f.getName());
      column.setType(DataTypeBind.getEnum(f.getType()).getDBType());
      column.setHasDefault(datetime.hasDefault());
      if (column.isHasDefault())       column.setDefaultValue(DataTypeBind.getEnum(f.getType()).getDefaultValue());
      column.setComment(datetime.comment());
      table.addColumn(column);
    }
    updateTime=f.getAnnotation(UpdateTime.class);
    if (updateTime != null) {
      if (f.getType() != java.sql.Timestamp.class) {
        throw new IllegalArgumentException(clazz + ""String_Node_Str"" + f.getName()+ ""String_Node_Str""+ f.getType()+ ""String_Node_Str"");
      }
      column.setField(f.getName());
      column.setType(DataTypeBind.UPDATETIME.getDBType());
      column.setHasDefault(true);
      column.setDefaultValue(DataTypeBind.UPDATETIME.getDefaultValue());
      column.setComment(updateTime.comment());
      table.addColumn(column);
    }
    dbField=f.getAnnotation(org.pinus.generator.annotation.Field.class);
    if (dbField != null) {
      if (f.getType() == java.sql.Timestamp.class) {
        throw new IllegalArgumentException(clazz + ""String_Node_Str"" + f.getName()+ ""String_Node_Str"");
      }
      String fieldName=f.getName();
      boolean isCanNull=dbField.isCanNull();
      int length=_getLength(f,dbField);
      boolean hasDefault=dbField.hasDefault();
      column.setField(fieldName);
      column.setType(DataTypeBind.getEnum(f.getType()).getDBType());
      column.setCanNull(isCanNull);
      column.setLength(length);
      column.setHasDefault(hasDefault);
      column.setComment(dbField.comment());
      if (column.isHasDefault())       column.setDefaultValue(DataTypeBind.getEnum(f.getType()).getDefaultValue());
      if (column.getType().equals(DataTypeBind.STRING.getDBType()) && column.getLength() > Const.COLUMN_TEXT_LENGTH) {
        column.setType(DataTypeBind.TEXT.getDBType());
        column.setLength(0);
        column.setDefaultValue(DataTypeBind.TEXT.getDefaultValue());
      }
      if (column.getType().equals(DataTypeBind.BOOL.getDBType())) {
        column.setLength(1);
      }
      table.addColumn(column);
    }
    pk=f.getAnnotation(PrimaryKey.class);
    if (pk != null) {
      if (!isSetPrimaryKey) {
        column.setField(f.getName());
        DataTypeBind dbType=DataTypeBind.getEnum(f.getType());
        column.setType(dbType.getDBType());
        column.setPrimaryKey(true);
        column.setAutoIncrement(false);
        column.setCanNull(false);
        int length=_getDbLength(dbType);
        column.setLength(length);
        column.setDefaultValue(null);
        isSetPrimaryKey=true;
        column.setComment(pk.comment());
      }
 else {
        throw new IllegalArgumentException(clazz + ""String_Node_Str"");
      }
      table.addColumn(column);
    }
  }
  if (table.getColumns().isEmpty()) {
    throw new IllegalStateException(clazz + ""String_Node_Str"" + defClass);
  }
  return table;
}","/** 
 * 通过翻身将class转换为DBTable对象
 */
protected DBTable converTo(Class<?> defClass){
  if (defClass == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  Class<?> clazz;
  try {
    clazz=defClass.newInstance().getClass();
  }
 catch (  Exception e) {
    throw new RuntimeException(e);
  }
  Table annoTable=clazz.getAnnotation(Table.class);
  if (annoTable == null) {
    throw new IllegalArgumentException(clazz + ""String_Node_Str"");
  }
  String tableName=ReflectUtil.getTableName(clazz);
  DBTable table=new DBTable(tableName.toLowerCase());
  String cluster=annoTable.cluster();
  if (StringUtils.isBlank(cluster)) {
    throw new IllegalArgumentException(clazz + ""String_Node_Str"");
  }
  table.setCluster(cluster);
  String shardingBy=annoTable.shardingBy();
  table.setShardingBy(shardingBy);
  int shardingNum=annoTable.shardingNum();
  table.setShardingNum(shardingNum);
  _parseDBIndex(table,clazz);
  DBTableColumn column=null;
  org.pinus.generator.annotation.Field dbField=null;
  PrimaryKey pk=null;
  UpdateTime updateTime=null;
  DateTime datetime=null;
  boolean isSetPrimaryKey=false;
  for (  Field f : clazz.getDeclaredFields()) {
    column=new DBTableColumn();
    datetime=f.getAnnotation(DateTime.class);
    if (datetime != null) {
      if (f.getType() != Date.class) {
        throw new IllegalArgumentException(clazz + ""String_Node_Str"" + f.getName()+ ""String_Node_Str""+ f.getType()+ ""String_Node_Str"");
      }
      column.setField(f.getName());
      column.setType(DataTypeBind.getEnum(f.getType()).getDBType());
      column.setHasDefault(datetime.hasDefault());
      if (column.isHasDefault())       column.setDefaultValue(DataTypeBind.getEnum(f.getType()).getDefaultValue());
      column.setComment(datetime.comment());
      table.addColumn(column);
    }
    updateTime=f.getAnnotation(UpdateTime.class);
    if (updateTime != null) {
      if (f.getType() != java.sql.Timestamp.class) {
        throw new IllegalArgumentException(clazz + ""String_Node_Str"" + f.getName()+ ""String_Node_Str""+ f.getType()+ ""String_Node_Str"");
      }
      column.setField(f.getName());
      column.setType(DataTypeBind.UPDATETIME.getDBType());
      column.setHasDefault(true);
      column.setDefaultValue(DataTypeBind.UPDATETIME.getDefaultValue());
      column.setComment(updateTime.comment());
      table.addColumn(column);
    }
    dbField=f.getAnnotation(org.pinus.generator.annotation.Field.class);
    if (dbField != null) {
      if (f.getType() == java.sql.Timestamp.class) {
        throw new IllegalArgumentException(clazz + ""String_Node_Str"" + f.getName()+ ""String_Node_Str"");
      }
      String fieldName=f.getName();
      boolean isCanNull=dbField.isCanNull();
      int length=_getLength(f,dbField);
      boolean hasDefault=dbField.hasDefault();
      column.setField(fieldName);
      column.setType(DataTypeBind.getEnum(f.getType()).getDBType());
      column.setCanNull(isCanNull);
      column.setLength(length);
      column.setHasDefault(hasDefault);
      column.setComment(dbField.comment());
      if (column.isHasDefault())       column.setDefaultValue(DataTypeBind.getEnum(f.getType()).getDefaultValue());
      if (column.getType().equals(DataTypeBind.STRING.getDBType()) && column.getLength() > Const.COLUMN_TEXT_LENGTH) {
        column.setType(DataTypeBind.TEXT.getDBType());
        column.setHasDefault(false);
        column.setLength(0);
        column.setDefaultValue(DataTypeBind.TEXT.getDefaultValue());
      }
      if (column.getType().equals(DataTypeBind.BOOL.getDBType())) {
        column.setLength(1);
      }
      table.addColumn(column);
    }
    pk=f.getAnnotation(PrimaryKey.class);
    if (pk != null) {
      if (!isSetPrimaryKey) {
        column.setField(f.getName());
        DataTypeBind dbType=DataTypeBind.getEnum(f.getType());
        column.setType(dbType.getDBType());
        column.setPrimaryKey(true);
        column.setAutoIncrement(false);
        column.setCanNull(false);
        int length=_getDbLength(dbType);
        column.setLength(length);
        column.setDefaultValue(null);
        isSetPrimaryKey=true;
        column.setComment(pk.comment());
      }
 else {
        throw new IllegalArgumentException(clazz + ""String_Node_Str"");
      }
      table.addColumn(column);
    }
  }
  if (table.getColumns().isEmpty()) {
    throw new IllegalStateException(clazz + ""String_Node_Str"" + defClass);
  }
  return table;
}",0.9958196813919332
90495,"/** 
 * 初始化方法
 */
public void init() throws LoadConfigException {
  IClusterConfig clusterConfig=XmlClusterConfigImpl.getInstance();
  EnumDbConnectionPoolCatalog enumDbCpCatalog=clusterConfig.getDbConnectionPoolCatalog();
switch (enumDbCpCatalog) {
case APP:
    this.dbCluster=new AppDBClusterImpl(enumDb);
  break;
case ENV:
this.dbCluster=new EnvDBClusterImpl(enumDb);
break;
default :
this.dbCluster=new AppDBClusterImpl(enumDb);
break;
}
this.dbCluster.setDbRouteAlg(this.enumDBRouteAlg);
this.dbCluster.setSyncAction(syncAction);
this.dbCluster.setScanPackage(this.scanPackage);
try {
this.dbCluster.startup();
}
 catch (DBClusterException e) {
throw new RuntimeException(e);
}
IDataLayerBuilder dataLayerBuilder=this.dbCluster.getDataLayerBuilder();
this.globalUpdater=dataLayerBuilder.buildGlobalUpdate(this.dbCluster.getIdGenerator());
this.globalMasterQuery=dataLayerBuilder.buildGlobalMasterQuery();
this.globalSlaveQuery=dataLayerBuilder.buildGlobalSlaveQuery();
this.shardingUpdater=dataLayerBuilder.buildShardingUpdate(this.dbCluster.getIdGenerator());
this.masterQueryer=new ShardingJdbcMasterQueryImpl();
this.slaveQueryer=new ShardingJdbcSlaveQueryImpl();
instance=this;
}","/** 
 * 初始化方法
 */
public void init() throws LoadConfigException {
  IClusterConfig clusterConfig=XmlClusterConfigImpl.getInstance();
  EnumDbConnectionPoolCatalog enumDbCpCatalog=clusterConfig.getDbConnectionPoolCatalog();
switch (enumDbCpCatalog) {
case APP:
    this.dbCluster=new AppDBClusterImpl(enumDb);
  break;
case ENV:
this.dbCluster=new EnvDBClusterImpl(enumDb);
break;
default :
this.dbCluster=new AppDBClusterImpl(enumDb);
break;
}
this.dbCluster.setDbRouteAlg(this.enumDBRouteAlg);
this.dbCluster.setSyncAction(syncAction);
this.dbCluster.setScanPackage(this.scanPackage);
try {
this.dbCluster.startup();
}
 catch (DBClusterException e) {
throw new RuntimeException(e);
}
this.idGenerator=this.dbCluster.getIdGenerator();
IDataLayerBuilder dataLayerBuilder=this.dbCluster.getDataLayerBuilder();
this.globalUpdater=dataLayerBuilder.buildGlobalUpdate(this.dbCluster.getIdGenerator());
this.globalMasterQuery=dataLayerBuilder.buildGlobalMasterQuery();
this.globalSlaveQuery=dataLayerBuilder.buildGlobalSlaveQuery();
this.shardingUpdater=dataLayerBuilder.buildShardingUpdate(this.dbCluster.getIdGenerator());
this.masterQueryer=dataLayerBuilder.buildShardingMasterQuery();
this.slaveQueryer=dataLayerBuilder.buildShardingSlaveQuery();
instance=this;
}",0.9518367346938776
90496,"@Override public void startup(String xmlFilePath) throws DBClusterException {
  LOG.info(""String_Node_Str"");
  try {
    config=_getConfig(xmlFilePath);
    LOG.info(""String_Node_Str"" + xmlFilePath + ""String_Node_Str"");
  }
 catch (  LoadConfigException e) {
    throw new RuntimeException(e);
  }
  this.curatorClient=CuratorFrameworkFactory.newClient(config.getZookeeperUrl(),new RetryNTimes(5,1000));
  this.curatorClient.start();
  try {
    ZooKeeper zkClient=this.curatorClient.getZookeeperClient().getZooKeeper();
    Stat stat=zkClient.exists(Const.ZK_ROOT,false);
    if (stat == null) {
      zkClient.create(Const.ZK_ROOT,new byte[0],ZooDefs.Ids.OPEN_ACL_UNSAFE,CreateMode.PERSISTENT);
    }
  }
 catch (  Exception e) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  this.idGenerator=new DistributedSequenceIdGeneratorImpl(config,this.curatorClient);
  LOG.info(""String_Node_Str"");
  ICacheBuilder cacheBuilder=MemCachedCacheBuilder.valueOf(config);
  this.primaryCache=cacheBuilder.buildPrimaryCache();
  this.secondCache=cacheBuilder.buildSecondCache();
switch (enumDBRouteAlg) {
case SIMPLE_HASH:
    dbRouter=new SimpleHashClusterRouterImpl();
  break;
default :
dbRouter=new SimpleHashClusterRouterImpl();
break;
}
if (this.dbRouter == null) {
throw new DBClusterException(""String_Node_Str"");
}
this.dbRouter.setDbClusterInfo(dbClusterInfo);
this.dbRouter.setHashAlgo(config.getHashAlgo());
IDBGeneratorBuilder dbGeneratorBuilder=DefaultDBGeneratorBuilder.valueOf(this.syncAction,this.enumDb);
this.dbGenerator=dbGeneratorBuilder.build();
dbClusterInfo=config.getDBClusterInfo();
try {
_initDBCluster(this.dbClusterInfo);
List<DBTable> tables=null;
if (isShardInfoFromZk) {
tables=getDBTableFromZk();
}
 else {
if (StringUtils.isBlank(scanPackage)) {
throw new DBClusterException(""String_Node_Str"");
}
tables=getDBTableFromJvm();
_syncToZookeeper(tables);
}
if (tables.isEmpty()) {
throw new DBClusterException(""String_Node_Str"" + scanPackage);
}
_initTableCluster(dbClusterInfo,tables);
if (this.syncAction != EnumSyncAction.NONE) {
LOG.info(""String_Node_Str"");
long start=System.currentTimeMillis();
_createTable(tables);
LOG.info(""String_Node_Str"" + (System.currentTimeMillis() - start) + ""String_Node_Str"");
}
}
 catch (Exception e) {
throw new DBClusterException(""String_Node_Str"",e);
}
LOG.info(""String_Node_Str"");
}","@Override public void startup(String xmlFilePath) throws DBClusterException {
  LOG.info(""String_Node_Str"");
  try {
    config=_getConfig(xmlFilePath);
  }
 catch (  LoadConfigException e) {
    throw new RuntimeException(e);
  }
  this.curatorClient=CuratorFrameworkFactory.newClient(config.getZookeeperUrl(),new RetryNTimes(5,1000));
  this.curatorClient.start();
  try {
    ZooKeeper zkClient=this.curatorClient.getZookeeperClient().getZooKeeper();
    Stat stat=zkClient.exists(Const.ZK_ROOT,false);
    if (stat == null) {
      zkClient.create(Const.ZK_ROOT,new byte[0],ZooDefs.Ids.OPEN_ACL_UNSAFE,CreateMode.PERSISTENT);
    }
  }
 catch (  Exception e) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  this.idGenerator=new DistributedSequenceIdGeneratorImpl(config,this.curatorClient);
  LOG.info(""String_Node_Str"");
  ICacheBuilder cacheBuilder=MemCachedCacheBuilder.valueOf(config);
  this.primaryCache=cacheBuilder.buildPrimaryCache();
  this.secondCache=cacheBuilder.buildSecondCache();
  IDBGeneratorBuilder dbGeneratorBuilder=DefaultDBGeneratorBuilder.valueOf(this.syncAction,this.enumDb);
  this.dbGenerator=dbGeneratorBuilder.build();
  dbClusterInfo=config.getDBClusterInfo();
  try {
    _initDBCluster(this.dbClusterInfo);
    List<DBTable> tables=null;
    if (isShardInfoFromZk) {
      tables=getDBTableFromZk();
    }
 else {
      if (StringUtils.isBlank(scanPackage)) {
        throw new DBClusterException(""String_Node_Str"");
      }
      tables=getDBTableFromJvm();
      _syncToZookeeper(tables);
    }
    if (tables.isEmpty()) {
      throw new DBClusterException(""String_Node_Str"" + scanPackage);
    }
    _initTableCluster(dbClusterInfo,tables);
    if (this.syncAction != EnumSyncAction.NONE) {
      LOG.info(""String_Node_Str"");
      long start=System.currentTimeMillis();
      _createTable(tables);
      LOG.info(""String_Node_Str"" + (System.currentTimeMillis() - start) + ""String_Node_Str"");
    }
  }
 catch (  Exception e) {
    throw new DBClusterException(""String_Node_Str"",e);
  }
switch (enumDBRouteAlg) {
case SIMPLE_HASH:
    dbRouter=new SimpleHashClusterRouterImpl();
  break;
default :
dbRouter=new SimpleHashClusterRouterImpl();
break;
}
this.dbRouter.setDbClusterInfo(dbClusterInfo);
this.dbRouter.setTableCluster(tableCluster);
this.dbRouter.setHashAlgo(config.getHashAlgo());
LOG.info(""String_Node_Str"");
}",0.5469146238377007
90497,"/** 
 * 创建数据库表.
 * @throws
	 * @throws IOException
 */
private void _createTable(List<DBTable> tables) throws Exception {
  Map<String,Map<Integer,Map<String,Integer>>> tableCluster=this.dbRouter.getTableCluster();
  String clusterName=null;
  Map<Integer,Map<String,Integer>> oneDbTables=null;
  for (  DBTable table : tables) {
    clusterName=table.getCluster();
    if (table.getShardingNum() > 0) {
      oneDbTables=tableCluster.get(clusterName);
      DBClusterInfo dbClusterInfo=this.dbClusterInfo.get(clusterName);
      if (oneDbTables == null || dbClusterInfo == null) {
        throw new DBClusterException(""String_Node_Str"" + clusterName);
      }
      for (      Integer dbIndex : oneDbTables.keySet()) {
        for (        DBClusterRegionInfo region : dbClusterInfo.getDbRegions()) {
          Connection dbConn=region.getMasterConnection().get(dbIndex).getDatasource().getConnection();
          int tableNum=oneDbTables.get(dbIndex).get(table.getName());
          this.dbGenerator.syncTable(dbConn,table,tableNum);
          dbConn.close();
        }
        for (        DBClusterRegionInfo region : dbClusterInfo.getDbRegions()) {
          List<List<DBConnectionInfo>> slaveDbs=region.getSlaveConnection();
          for (          List<DBConnectionInfo> slaveConns : slaveDbs) {
            for (            DBConnectionInfo dbConnInfo : slaveConns) {
              Connection dbConn=dbConnInfo.getDatasource().getConnection();
              int tableNum=oneDbTables.get(dbIndex).get(table.getName());
              this.dbGenerator.syncTable(dbConn,table,tableNum);
              dbConn.close();
            }
          }
        }
      }
    }
 else {
      DBClusterInfo dbClusterInfo=this.dbClusterInfo.get(clusterName);
      if (dbClusterInfo == null) {
        throw new DBClusterException(""String_Node_Str"" + clusterName);
      }
      DBConnectionInfo dbConnInfo=dbClusterInfo.getMasterGlobalConnection();
      if (dbConnInfo != null) {
        DataSource globalDs=dbConnInfo.getDatasource();
        if (globalDs != null) {
          Connection conn=globalDs.getConnection();
          this.dbGenerator.syncTable(conn,table);
          conn.close();
        }
      }
      List<DBConnectionInfo> slaveDbs=dbClusterInfo.getSlaveGlobalConnection();
      if (slaveDbs != null && !slaveDbs.isEmpty()) {
        for (        DBConnectionInfo slaveConnInfo : slaveDbs) {
          Connection conn=slaveConnInfo.getDatasource().getConnection();
          this.dbGenerator.syncTable(conn,table);
          conn.close();
        }
      }
    }
  }
}","/** 
 * 创建数据库表.
 * @throws
	 * @throws IOException
 */
private void _createTable(List<DBTable> tables) throws Exception {
  String clusterName=null;
  Map<Integer,Map<String,Integer>> oneDbTables=null;
  for (  DBTable table : tables) {
    clusterName=table.getCluster();
    if (table.getShardingNum() > 0) {
      oneDbTables=tableCluster.get(clusterName);
      DBClusterInfo dbClusterInfo=this.dbClusterInfo.get(clusterName);
      if (oneDbTables == null || dbClusterInfo == null) {
        throw new DBClusterException(""String_Node_Str"" + clusterName);
      }
      for (      Integer dbIndex : oneDbTables.keySet()) {
        for (        DBClusterRegionInfo region : dbClusterInfo.getDbRegions()) {
          Connection dbConn=region.getMasterConnection().get(dbIndex).getDatasource().getConnection();
          int tableNum=oneDbTables.get(dbIndex).get(table.getName());
          this.dbGenerator.syncTable(dbConn,table,tableNum);
          dbConn.close();
        }
        for (        DBClusterRegionInfo region : dbClusterInfo.getDbRegions()) {
          List<List<DBConnectionInfo>> slaveDbs=region.getSlaveConnection();
          for (          List<DBConnectionInfo> slaveConns : slaveDbs) {
            for (            DBConnectionInfo dbConnInfo : slaveConns) {
              Connection dbConn=dbConnInfo.getDatasource().getConnection();
              int tableNum=oneDbTables.get(dbIndex).get(table.getName());
              this.dbGenerator.syncTable(dbConn,table,tableNum);
              dbConn.close();
            }
          }
        }
      }
    }
 else {
      DBClusterInfo dbClusterInfo=this.dbClusterInfo.get(clusterName);
      if (dbClusterInfo == null) {
        throw new DBClusterException(""String_Node_Str"" + clusterName);
      }
      DBConnectionInfo dbConnInfo=dbClusterInfo.getMasterGlobalConnection();
      if (dbConnInfo != null) {
        DataSource globalDs=dbConnInfo.getDatasource();
        if (globalDs != null) {
          Connection conn=globalDs.getConnection();
          this.dbGenerator.syncTable(conn,table);
          conn.close();
        }
      }
      List<DBConnectionInfo> slaveDbs=dbClusterInfo.getSlaveGlobalConnection();
      if (slaveDbs != null && !slaveDbs.isEmpty()) {
        for (        DBConnectionInfo slaveConnInfo : slaveDbs) {
          Connection conn=slaveConnInfo.getDatasource().getConnection();
          this.dbGenerator.syncTable(conn,table);
          conn.close();
        }
      }
    }
  }
}",0.9662655356086012
90498,"/** 
 * 初始化分表. 并将分表信息设置到分库分表路由器, 主库和从库的分表信息是相同的，因此使用主库集群进行设置.
 * @throws DBClusterException 初始化失败
 */
private void _initTableCluster(Map<String,DBClusterInfo> dbCluster,List<DBTable> tables) throws DBClusterException {
  Map<Integer,Map<String,Integer>> oneDbTable=null;
  Map<String,Integer> tableNum=null;
  for (  Map.Entry<String,DBClusterInfo> entry : dbClusterInfo.entrySet()) {
    oneDbTable=new HashMap<Integer,Map<String,Integer>>();
    String clusterName=entry.getKey();
    int dbNum=0;
    List<DBClusterRegionInfo> regions=entry.getValue().getDbRegions();
    if (!regions.isEmpty())     dbNum=regions.get(0).getMasterConnection().size();
    for (int i=0; i < dbNum; i++) {
      tableNum=_loadTableCluster(clusterName,tables);
      oneDbTable.put(i,tableNum);
    }
    tableCluster.put(clusterName,oneDbTable);
  }
  this.dbRouter.setTableCluster(tableCluster);
}","/** 
 * 初始化分表. 并将分表信息设置到分库分表路由器, 主库和从库的分表信息是相同的，因此使用主库集群进行设置.
 * @throws DBClusterException 初始化失败
 */
private void _initTableCluster(Map<String,DBClusterInfo> dbCluster,List<DBTable> tables) throws DBClusterException {
  Map<Integer,Map<String,Integer>> oneDbTable=null;
  Map<String,Integer> tableNum=null;
  for (  Map.Entry<String,DBClusterInfo> entry : dbClusterInfo.entrySet()) {
    oneDbTable=new HashMap<Integer,Map<String,Integer>>();
    String clusterName=entry.getKey();
    int dbNum=0;
    List<DBClusterRegionInfo> regions=entry.getValue().getDbRegions();
    if (!regions.isEmpty())     dbNum=regions.get(0).getMasterConnection().size();
    for (int i=0; i < dbNum; i++) {
      tableNum=_loadTableCluster(clusterName,tables);
      oneDbTable.put(i,tableNum);
    }
    tableCluster.put(clusterName,oneDbTable);
  }
}",0.9726266744321492
90499,"private SQL(String sql,Object... params){
  if (sql != null)   this.sql=sql.toLowerCase();
  this.params=params;
}","private SQL(String sql,Object... params){
  this.sql=sql;
  this.params=params;
}",0.8307692307692308
90500,"@Test public void testSaveBatch(){
  List<TestEntity> entities=new ArrayList<TestEntity>();
  TestEntity entity1=createEntity();
  TestEntity entity2=createEntity();
  entities.add(entity1);
  entities.add(entity2);
  IShardingKey<Number> key=new ShardingKey<Number>(CLUSTER_KLSTORAGE,1000001);
  Number[] pks=cacheClient.saveBatch(entities,key);
  List<TestEntity> entitiesFromDB=cacheClient.findByPks(key,TestEntity.class,pks);
  for (int i=0; i < entitiesFromDB.size(); i++) {
    Assert.assertEquals(entities.get(i),entitiesFromDB.get(i));
  }
  cacheClient.removeByPks(pks,key,TestEntity.class);
  entitiesFromDB=cacheClient.findByPks(key,TestEntity.class,pks);
  Assert.assertTrue(entitiesFromDB.isEmpty());
}","@Test public void testSaveBatch(){
  List<TestEntity> entities=new ArrayList<TestEntity>();
  TestEntity entity1=createEntity();
  TestEntity entity2=createEntity();
  entities.add(entity1);
  entities.add(entity2);
  IShardingKey<Number> key=new ShardingKey<Number>(CLUSTER_KLSTORAGE,1000001);
  Number[] pks=cacheClient.saveBatch(entities,key);
  List<TestEntity> entitiesFromDB=cacheClient.findByPks(key,TestEntity.class,pks);
  for (int i=0; i < entitiesFromDB.size(); i++) {
    Assert.assertEquals(entities.get(i),entitiesFromDB.get(i));
  }
  cacheClient.removeByPks(key,TestEntity.class,pks);
  entitiesFromDB=cacheClient.findByPks(key,TestEntity.class,pks);
  Assert.assertTrue(entitiesFromDB.isEmpty());
}",0.9706293706293706
90501,"@Test public void testGlobalUpdateBatch(){
  List<TestGlobalEntity> entities=new ArrayList<TestGlobalEntity>();
  TestGlobalEntity entity1=createGlobalEntity();
  TestGlobalEntity entity2=createGlobalEntity();
  entities.add(entity1);
  entities.add(entity2);
  Number[] pks=cacheClient.globalSaveBatch(entities,CLUSTER_KLSTORAGE);
  List<TestGlobalEntity> before=cacheClient.findGlobalByPks(CLUSTER_KLSTORAGE,TestGlobalEntity.class,pks);
  for (  TestGlobalEntity entity : before) {
    entity.setTestString(""String_Node_Str"");
  }
  cacheClient.globalUpdateBatch(before,CLUSTER_KLSTORAGE);
  List<TestGlobalEntity> after=cacheClient.findGlobalByPks(CLUSTER_KLSTORAGE,TestGlobalEntity.class,pks);
  for (int i=0; i < after.size(); i++) {
    Assert.assertEquals(before.get(i),after.get(i));
  }
  cacheClient.globalRemoveByPks(pks,TestGlobalEntity.class,CLUSTER_KLSTORAGE);
  List<TestGlobalEntity> entitiesFromDB=cacheClient.findGlobalByPks(CLUSTER_KLSTORAGE,TestGlobalEntity.class,pks);
  Assert.assertTrue(entitiesFromDB.isEmpty());
}","@Test public void testGlobalUpdateBatch(){
  List<TestGlobalEntity> entities=new ArrayList<TestGlobalEntity>();
  TestGlobalEntity entity1=createGlobalEntity();
  TestGlobalEntity entity2=createGlobalEntity();
  entities.add(entity1);
  entities.add(entity2);
  Number[] pks=cacheClient.globalSaveBatch(entities,CLUSTER_KLSTORAGE);
  List<TestGlobalEntity> before=cacheClient.findGlobalByPks(CLUSTER_KLSTORAGE,TestGlobalEntity.class,pks);
  for (  TestGlobalEntity entity : before) {
    entity.setTestString(""String_Node_Str"");
  }
  cacheClient.globalUpdateBatch(before,CLUSTER_KLSTORAGE);
  List<TestGlobalEntity> after=cacheClient.findGlobalByPks(CLUSTER_KLSTORAGE,TestGlobalEntity.class,pks);
  for (int i=0; i < after.size(); i++) {
    Assert.assertEquals(before.get(i),after.get(i));
  }
  cacheClient.globalRemoveByPks(CLUSTER_KLSTORAGE,TestGlobalEntity.class,pks);
  List<TestGlobalEntity> entitiesFromDB=cacheClient.findGlobalByPks(CLUSTER_KLSTORAGE,TestGlobalEntity.class,pks);
  Assert.assertTrue(entitiesFromDB.isEmpty());
}",0.9605009633911368
90502,"@Test public void testGlobalSaveBatch(){
  List<TestGlobalEntity> entities=new ArrayList<TestGlobalEntity>();
  TestGlobalEntity entity1=createGlobalEntity();
  TestGlobalEntity entity2=createGlobalEntity();
  entities.add(entity1);
  entities.add(entity2);
  Number[] pks=cacheClient.globalSaveBatch(entities,CLUSTER_KLSTORAGE);
  List<TestGlobalEntity> entitiesFromDB=cacheClient.findGlobalByPks(CLUSTER_KLSTORAGE,TestGlobalEntity.class,pks);
  for (int i=0; i < entitiesFromDB.size(); i++) {
    Assert.assertEquals(entities.get(i),entitiesFromDB.get(i));
  }
  cacheClient.globalRemoveByPks(pks,TestGlobalEntity.class,CLUSTER_KLSTORAGE);
  entitiesFromDB=cacheClient.findGlobalByPks(CLUSTER_KLSTORAGE,TestGlobalEntity.class,pks);
  Assert.assertTrue(entitiesFromDB.isEmpty());
}","@Test public void testGlobalSaveBatch(){
  List<TestGlobalEntity> entities=new ArrayList<TestGlobalEntity>();
  TestGlobalEntity entity1=createGlobalEntity();
  TestGlobalEntity entity2=createGlobalEntity();
  entities.add(entity1);
  entities.add(entity2);
  Number[] pks=cacheClient.globalSaveBatch(entities,CLUSTER_KLSTORAGE);
  List<TestGlobalEntity> entitiesFromDB=cacheClient.findGlobalByPks(CLUSTER_KLSTORAGE,TestGlobalEntity.class,pks);
  for (int i=0; i < entitiesFromDB.size(); i++) {
    Assert.assertEquals(entities.get(i),entitiesFromDB.get(i));
  }
  cacheClient.globalRemoveByPks(CLUSTER_KLSTORAGE,TestGlobalEntity.class,pks);
  entitiesFromDB=cacheClient.findGlobalByPks(CLUSTER_KLSTORAGE,TestGlobalEntity.class,pks);
  Assert.assertTrue(entitiesFromDB.isEmpty());
}",0.8593350383631714
90503,"@Test public void testUpdateBatch(){
  List<TestEntity> entities=new ArrayList<TestEntity>();
  TestEntity entity1=createEntity();
  TestEntity entity2=createEntity();
  entities.add(entity1);
  entities.add(entity2);
  IShardingKey<Number> key=new ShardingKey<Number>(CLUSTER_KLSTORAGE,1000001);
  Number[] pks=cacheClient.saveBatch(entities,key);
  List<TestEntity> before=cacheClient.findByPks(key,TestEntity.class,pks);
  for (  TestEntity entity : before) {
    entity.setTestDate(new Date());
  }
  cacheClient.updateBatch(before,key);
  List<TestEntity> after=cacheClient.findByPks(key,TestEntity.class,pks);
  for (int i=0; i < after.size(); i++) {
    Assert.assertEquals(before.get(i),after.get(i));
  }
  cacheClient.removeByPks(pks,key,TestEntity.class);
  List<TestEntity> entitiesFromDB=cacheClient.findByPks(key,TestEntity.class,pks);
  Assert.assertTrue(entitiesFromDB.isEmpty());
}","@Test public void testUpdateBatch(){
  List<TestEntity> entities=new ArrayList<TestEntity>();
  TestEntity entity1=createEntity();
  TestEntity entity2=createEntity();
  entities.add(entity1);
  entities.add(entity2);
  IShardingKey<Number> key=new ShardingKey<Number>(CLUSTER_KLSTORAGE,1000001);
  Number[] pks=cacheClient.saveBatch(entities,key);
  List<TestEntity> before=cacheClient.findByPks(key,TestEntity.class,pks);
  for (  TestEntity entity : before) {
    entity.setTestDate(new Date());
  }
  cacheClient.updateBatch(before,key);
  List<TestEntity> after=cacheClient.findByPks(key,TestEntity.class,pks);
  for (int i=0; i < after.size(); i++) {
    Assert.assertEquals(before.get(i),after.get(i));
  }
  cacheClient.removeByPks(key,TestEntity.class,pks);
  List<TestEntity> entitiesFromDB=cacheClient.findByPks(key,TestEntity.class,pks);
  Assert.assertTrue(entitiesFromDB.isEmpty());
}",0.9766146993318484
90504,"@Test public void remove() throws Exception {
  IShardingKey<?> shardingValue=new ShardingKey<Integer>(CLUSTER_KLSTORAGE,1);
  DB db=cacheClient.getDbCluster().selectDbFromMaster(""String_Node_Str"",shardingValue);
  primaryCache.remove(db,1);
  Assert.assertNull(primaryCache.get(db,1));
  for (int i=2; i <= 10; i++) {
    primaryCache.remove(db,2,3,4,5,6,7,8,9,10);
  }
  for (int i=2; i <= 10; i++) {
    Assert.assertNull(primaryCache.get(db,i));
  }
}","@Test public void remove() throws Exception {
  IShardingKey<?> shardingValue=new ShardingKey<Integer>(CLUSTER_KLSTORAGE,1);
  DB db=cacheClient.getDbCluster().selectDbFromMaster(""String_Node_Str"",shardingValue);
  primaryCache.remove(db,1);
  Assert.assertNull(primaryCache.get(db,1));
  for (int i=2; i <= 10; i++) {
    primaryCache.remove(db,Arrays.asList(new Number[]{2,3,4,5,5,6}));
  }
  for (int i=2; i <= 10; i++) {
    Assert.assertNull(primaryCache.get(db,i));
  }
}",0.8969957081545065
90505,"@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) @Override public Number save(Object entity,IShardingKey shardingKey){
  String tableName=ReflectUtil.getTableName(entity.getClass());
  long pk=this.idGenerator.genClusterUniqueLongId(dbCluster,shardingKey.getClusterName(),tableName);
  try {
    if (shardingKey.getValue() == null) {
      ReflectUtil.setPkValue(entity,pk);
      shardingKey.setValue(pk);
    }
 else     if (shardingKey.getValue() instanceof Number) {
      if (((Number)shardingKey.getValue()).intValue() == 0) {
        ReflectUtil.setPkValue(entity,pk);
        shardingKey.setValue(pk);
      }
    }
  }
 catch (  Exception e) {
    throw new DBOperationException(e);
  }
  DB db=_getDbFromMaster(tableName,shardingKey);
  List<Object> entities=new ArrayList<Object>(1);
  entities.add(entity);
  Connection conn=null;
  try {
    conn=db.getDatasource().getConnection();
    _saveBatch(conn,entities,db.getTableIndex());
  }
 catch (  Exception e) {
    throw new DBOperationException(e);
  }
 finally {
    SQLBuilder.close(conn);
  }
  if (primaryCache != null) {
    primaryCache.put(db,pk,entity);
    primaryCache.incrCount(db,1);
  }
  return pk;
}","@SuppressWarnings({""String_Node_Str"",""String_Node_Str""}) @Override public Number save(Object entity,IShardingKey shardingKey){
  String tableName=ReflectUtil.getTableName(entity.getClass());
  long pk=this.idGenerator.genClusterUniqueLongId(dbCluster,shardingKey.getClusterName(),tableName);
  try {
    ReflectUtil.setPkValue(entity,pk);
  }
 catch (  Exception e) {
    throw new DBOperationException(e);
  }
  if (shardingKey.getValue() instanceof Number) {
    if (shardingKey.getValue() == null || ((Number)shardingKey.getValue()).intValue() == 0) {
      shardingKey.setValue(pk);
    }
  }
 else   if (shardingKey.getValue() instanceof String) {
    if (shardingKey.getValue() == null) {
      throw new DBOperationException(""String_Node_Str"");
    }
  }
 else {
    throw new DBOperationException(""String_Node_Str"");
  }
  DB db=_getDbFromMaster(tableName,shardingKey);
  List<Object> entities=new ArrayList<Object>(1);
  entities.add(entity);
  Connection conn=null;
  try {
    conn=db.getDatasource().getConnection();
    _saveBatch(conn,entities,db.getTableIndex());
  }
 catch (  Exception e) {
    throw new DBOperationException(e);
  }
 finally {
    SQLBuilder.close(conn);
  }
  if (primaryCache != null) {
    primaryCache.put(db,pk,entity);
    primaryCache.incrCount(db,1);
  }
  return pk;
}",0.7154861944777912
90506,"/** 
 * 通过反射给对象属性赋值.
 * @param obj 被反射的对象
 * @param propertyName 赋值的属性名
 * @param value 值
 * @throws Exception 操作失败
 */
public static void setProperty(Object obj,String propertyName,Object value) throws Exception {
  Field f=obj.getClass().getDeclaredField(propertyName);
  f.setAccessible(true);
  f.set(obj,value);
}","/** 
 * 通过反射给对象属性赋值.
 * @param obj 被反射的对象
 * @param propertyName 赋值的属性名
 * @param value 值
 * @throws Exception 操作失败
 */
public static void setProperty(Object obj,String propertyName,Object value) throws Exception {
  Field f=obj.getClass().getDeclaredField(propertyName);
  f.setAccessible(true);
  if (value instanceof Number) {
    Number numValue=(Number)value;
    if (f.getType() == Integer.TYPE || f.getType() == Integer.class) {
      f.setInt(obj,numValue.intValue());
    }
 else     if (f.getType() == Long.TYPE || f.getType() == Long.class) {
      f.setLong(obj,numValue.longValue());
    }
 else     if (f.getType() == Short.TYPE || f.getType() == Short.class) {
      f.setShort(obj,numValue.shortValue());
    }
 else     if (f.getType() == Float.TYPE || f.getType() == Float.class) {
      f.setFloat(obj,numValue.floatValue());
    }
 else     if (f.getType() == Double.TYPE || f.getType() == Double.class) {
      f.setDouble(obj,numValue.doubleValue());
    }
 else {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
  }
 else {
    f.set(obj,value);
  }
}",0.4507441530829199
90507,"/** 
 * Returns the portlet session. <p> Note that since portlet request instance is created everytime the portlet container receives an incoming request, the portlet session instance held by the request instance is also re-created for each incoming request. </p>
 */
@Override public PortletSession getPortletSession(boolean create){
  if (isDebug) {
    LOG.debug(""String_Node_Str"" + create + ""String_Node_Str"");
  }
  if (portletConfig == null) {
    throw new IllegalStateException(EXCEPTIONS.getString(""String_Node_Str""));
  }
  HttpSession httpSession=getServletRequest().getSession(create);
  if (httpSession != null) {
    int maxInactiveInterval=httpSession.getMaxInactiveInterval();
    long lastAccesstime=httpSession.getLastAccessedTime();
    if (maxInactiveInterval >= 0 && lastAccesstime > 0) {
      long maxInactiveTime=httpSession.getMaxInactiveInterval() * 1000L;
      long currentInactiveTime=System.currentTimeMillis() - lastAccesstime;
      if (currentInactiveTime > maxInactiveTime) {
        if (isDebug) {
          LOG.debug(""String_Node_Str"" + ""String_Node_Str"");
        }
        httpSession.invalidate();
        httpSession=getServletRequest().getSession(create);
      }
    }
  }
  if (httpSession == null) {
    if (isDebug) {
      LOG.debug(""String_Node_Str"" + ""String_Node_Str"");
    }
    return null;
  }
  final ContainerServices containerServices=container.getContainerServices();
  final PortletEnvironmentService portletEnvironmentService=containerServices.getPortletEnvironmentService();
  PortletSession portletSession=portletEnvironmentService.createPortletSession(portletConfig.getPortletContext(),getPortletWindow(),httpSession);
  return portletSession;
}","/** 
 * Returns the portlet session. <p> Note that since portlet request instance is created everytime the portlet container receives an incoming request, the portlet session instance held by the request instance is also re-created for each incoming request. </p>
 */
@Override public PortletSession getPortletSession(boolean create){
  if (isDebug) {
    LOG.debug(""String_Node_Str"" + create + ""String_Node_Str"");
  }
  if ((cachedPortletSession == null) || cachedPortletSession.isInvalidated()) {
    if (portletConfig == null) {
      throw new IllegalStateException(EXCEPTIONS.getString(""String_Node_Str""));
    }
    HttpSession httpSession=getServletRequest().getSession(create);
    if (httpSession != null) {
      int maxInactiveInterval=httpSession.getMaxInactiveInterval();
      long lastAccesstime=httpSession.getLastAccessedTime();
      if (maxInactiveInterval >= 0 && lastAccesstime > 0) {
        long maxInactiveTime=httpSession.getMaxInactiveInterval() * 1000L;
        long currentInactiveTime=System.currentTimeMillis() - lastAccesstime;
        if (currentInactiveTime > maxInactiveTime) {
          if (isDebug) {
            LOG.debug(""String_Node_Str"" + ""String_Node_Str"");
          }
          httpSession.invalidate();
          httpSession=getServletRequest().getSession(create);
        }
      }
    }
    if (httpSession == null) {
      if (isDebug) {
        LOG.debug(""String_Node_Str"" + ""String_Node_Str"");
      }
      return null;
    }
    final ContainerServices containerServices=container.getContainerServices();
    final PortletEnvironmentService portletEnvironmentService=containerServices.getPortletEnvironmentService();
    cachedPortletSession=new CachedPortletSessionImpl(portletEnvironmentService.createPortletSession(portletConfig.getPortletContext(),getPortletWindow(),httpSession));
  }
  return cachedPortletSession;
}",0.9332215702710256
90508,"@Override public void processAction(ActionRequest portletReq,ActionResponse portletResp) throws PortletException, IOException {
}","@Override @ActionMethod(portletName=""String_Node_Str"",publishingEvents={@PortletQName(namespaceURI=""String_Node_Str"",localPart=""String_Node_Str"")}) public void processAction(ActionRequest portletReq,ActionResponse portletResp) throws PortletException, IOException {
  MutableRenderParameters mrp=portletResp.getRenderParameters();
  String testcase=mrp.getValue(""String_Node_Str"");
  ActionParameters ap=portletReq.getActionParameters();
  if (testcase == null || testcase.isEmpty()) {
    mrp.setValue(""String_Node_Str"",""String_Node_Str"");
  }
 else   if (testcase.equals(V3PORTLETHUBTESTS_SPEC_23_JSACTION_ACTION1)) {
    mrp.setValue(""String_Node_Str"",""String_Node_Str"");
  }
 else   if (testcase.equals(V3PORTLETHUBTESTS_SPEC_23_JSACTION_ACTION2)) {
    String param=ap.getValue(""String_Node_Str"");
    String status=""String_Node_Str"";
    if (param == null || !param.equals(""String_Node_Str"")) {
      status=""String_Node_Str"" + param;
    }
    mrp.setValue(""String_Node_Str"",status);
  }
 else   if (testcase.equals(V3PORTLETHUBTESTS_SPEC_23_JSACTION_ACTION3)) {
    String formParam=ap.getValue(""String_Node_Str"");
    String status=""String_Node_Str"";
    if (formParam == null || !formParam.equals(V3PORTLETHUBTESTS_SPEC_23_JSACTION_ACTION3)) {
      status=""String_Node_Str"" + formParam;
    }
    mrp.setValue(""String_Node_Str"",status);
  }
 else   if (testcase.equals(V3PORTLETHUBTESTS_SPEC_23_JSACTION_ACTION4)) {
    String param=ap.getValue(""String_Node_Str"");
    String formParam=ap.getValue(""String_Node_Str"");
    String status=""String_Node_Str"";
    if (formParam == null || !formParam.equals(V3PORTLETHUBTESTS_SPEC_23_JSACTION_ACTION4)) {
      status=""String_Node_Str"" + formParam;
    }
 else     if (param == null || !param.equals(""String_Node_Str"")) {
      status=""String_Node_Str"" + param;
    }
    mrp.setValue(""String_Node_Str"",status);
  }
 else   if (testcase.equals(V3PORTLETHUBTESTS_SPEC_23_JSACTION_ACTION5)) {
    mrp.setValue(""String_Node_Str"",""String_Node_Str"");
  }
 else   if (testcase.equals(V3PORTLETHUBTESTS_SPEC_23_JSACTION_ACTION6)) {
    QName qname=new QName(""String_Node_Str"",""String_Node_Str"");
    portletResp.setEvent(qname,""String_Node_Str"");
    ;
  }
 else   if (testcase.equals(V3PORTLETHUBTESTS_SPEC_23_JSACTION_ACTION7)) {
    mrp.setValue(""String_Node_Str"",""String_Node_Str"");
  }
}",0.1044957472660996
90509,"/** 
 * Invoke the method with the arguments provided. It is expected that this method is called  is called by a proxy or facade for the method / class.
 * @param args    Arguments
 * @return        Object returned by method
 * @throws IllegalAccessException
 * @throws IllegalArgumentException
 * @throws InvocationTargetException
 */
public Object invoke(Object... args) throws IllegalAccessException, IllegalArgumentException, InvocationTargetException {
  if (!isPortletClass) {
    beanInstance=beanMgr.getReference(bean,bean.getBeanClass(),beanMgr.createCreationalContext(bean));
  }
  return meth.invoke(beanInstance,args);
}","/** 
 * Invoke the method with the arguments provided. It is expected that this method is called  is called by a proxy or facade for the method / class.
 * @param args    Arguments
 * @return        Object returned by method
 * @throws IllegalAccessException
 * @throws IllegalArgumentException
 * @throws InvocationTargetException
 */
public Object invoke(Object... args) throws IllegalAccessException, IllegalArgumentException, InvocationTargetException {
  if (!isPortletClass) {
    if (isTrace) {
      StringBuilder txt=new StringBuilder();
      txt.append(""String_Node_Str"").append(toString());
      txt.append(""String_Node_Str"").append(beanMgr == null);
      txt.append(""String_Node_Str"").append(bean == null);
      LOG.trace(txt.toString());
    }
    beanInstance=beanMgr.getReference(bean,bean.getBeanClass(),beanMgr.createCreationalContext(bean));
  }
  return meth.invoke(beanInstance,args);
}",0.8197146562905318
90510,"/** 
 * Scans the servlet context classes and libraries for portlet method annotations.
 * @param ctx     the servlet context
 */
public void scanContext(ServletContext ctx){
  Set<File> files;
  files=getClassFilesForPath(ctx,CLASSDIR);
  scanFiles(files);
  files=getLibFilesForPath(ctx,LIBDIR);
  scanFiles(files);
  activateAnnotatedMethods(null);
}","/** 
 * Scans the servlet context classes and libraries for portlet method annotations.
 * @param ctx     the servlet context
 */
public void scanContext(ServletContext ctx){
  Set<File> files;
  files=getClassFilesForPath(ctx,CLASSDIR);
  scanFiles(files);
  files=getLibFilesForPath(ctx,LIBDIR);
  scanFiles(files);
}",0.949404761904762
90511,"/** 
 * After the bean container has validated the deployment from its point of view, do some checking from the portlet point of view. Activate the portlet deployment by passing in a bean manager in order to create the required portlet bean instances.
 * @param adv
 * @param bm
 * @throws InvalidAnnotationException
 */
void afterDeploymentValidation(@Observes AfterDeploymentValidation adv,BeanManager bm) throws InvalidAnnotationException {
  par.activateCustomScopes(bm);
  par.activateAnnotatedMethods(bm);
  LOG.trace(""String_Node_Str"");
  Set<Bean<?>> beans=bm.getBeans(AnnotatedConfigBean.class);
  @SuppressWarnings(""String_Node_Str"") Bean<AnnotatedConfigBean> bean=(Bean<AnnotatedConfigBean>)bm.resolve(beans);
  if (bean != null) {
    LOG.trace(""String_Node_Str"" + bean.getBeanClass().getCanonicalName());
    try {
      CreationalContext<AnnotatedConfigBean> cc=bm.createCreationalContext(bean);
      acb=(AnnotatedConfigBean)bm.getReference(bean,AnnotatedConfigBean.class,cc);
      LOG.trace(""String_Node_Str"");
      acb.setMethodStore(ams);
      acb.setSummary(summary);
      acb.setStateScopedConfig(par.getStateScopedConfig());
      acb.setSessionScopedConfig(par.getSessionScopedConfig());
    }
 catch (    Exception e) {
      StringBuilder txt=new StringBuilder(128);
      txt.append(""String_Node_Str"");
      txt.append(e.toString());
      LOG.warn(txt.toString());
    }
  }
 else {
    LOG.warn(""String_Node_Str"");
  }
  LOG.info(""String_Node_Str"" + acb);
}","/** 
 * After the bean container has validated the deployment from its point of view, do some checking from the portlet point of view. Activate the portlet deployment by passing in a bean manager in order to create the required portlet bean instances.
 * @param adv
 * @param bm
 * @throws InvalidAnnotationException
 */
void afterDeploymentValidation(@Observes AfterDeploymentValidation adv,BeanManager bm) throws InvalidAnnotationException {
  par.activateCustomScopes(bm);
  LOG.trace(""String_Node_Str"");
  Set<Bean<?>> beans=bm.getBeans(AnnotatedConfigBean.class);
  @SuppressWarnings(""String_Node_Str"") Bean<AnnotatedConfigBean> bean=(Bean<AnnotatedConfigBean>)bm.resolve(beans);
  if (bean != null) {
    LOG.trace(""String_Node_Str"" + bean.getBeanClass().getCanonicalName());
    try {
      CreationalContext<AnnotatedConfigBean> cc=bm.createCreationalContext(bean);
      acb=(AnnotatedConfigBean)bm.getReference(bean,AnnotatedConfigBean.class,cc);
      LOG.trace(""String_Node_Str"");
      acb.setMethodStore(ams);
      acb.setSummary(summary);
      acb.setStateScopedConfig(par.getStateScopedConfig());
      acb.setSessionScopedConfig(par.getSessionScopedConfig());
    }
 catch (    Exception e) {
      StringBuilder txt=new StringBuilder(128);
      txt.append(""String_Node_Str"");
      txt.append(e.toString());
      LOG.warn(txt.toString());
    }
  }
 else {
    LOG.warn(""String_Node_Str"");
  }
  LOG.info(""String_Node_Str"" + acb);
}",0.9877717391304348
90512,"/** 
 * Scans list of files for method annotations. (unit test execution path)
 * @param files   the set of files to scan
 */
public void scanMethodAnnotations(Set<File> files){
  MethodAnnotationRecognizer mar=new MethodAnnotationRecognizer(methodStore,configSummary);
  mar.scanFiles(files);
  mar.activateAnnotatedMethods(null);
  LOG.debug(""String_Node_Str"" + methodStore.getMethodsAsString());
}","/** 
 * Scans list of files for method annotations. (unit test execution path)
 * @param files   the set of files to scan
 */
public void scanMethodAnnotations(Set<File> files){
  MethodAnnotationRecognizer mar=new MethodAnnotationRecognizer(methodStore,configSummary);
  mar.scanFiles(files);
  LOG.debug(""String_Node_Str"" + methodStore.getMethodsAsString());
}",0.9501312335958004
90513,"/** 
 * Reconciles the bean configuration with the config from annotations & portlet DD.
 */
public void reconcileBeanConfig(AnnotatedMethodStore ams){
  if (jcp == null) {
    jcp=new JSR362ConfigurationProcessor(pad);
  }
  jcp.reconcileBeanConfig(ams);
  jcp.instantiatePortlets(ams,ams.getBeanMgr());
}","/** 
 * Reconciles the bean configuration with the config from annotations & portlet DD.
 */
public void reconcileBeanConfig(){
  if (jcp == null) {
    jcp=new JSR362ConfigurationProcessor(pad);
  }
  jcp.reconcileBeanConfig(methodStore);
}",0.8446069469835467
90514,"/** 
 * reconciles the given annotated method store containing the bean configuration with the configuration as read from the portlet deployment descriptor and the corresponding type annotations. <p> Portlets that are defined in the bean config are added to the portlet application definition if not already present. Event reference information from the annotations is verified and added to the corresponding portlet definition. <p> Methods from portlet classes definied in the portlet definitions are added to the annotated method store.
 * @param ams
 */
public void reconcileBeanConfig(AnnotatedMethodStore ams){
  Set<String> portletNames=ams.getPortletNames();
  portletNames.remove(""String_Node_Str"");
  if (isDebug) {
    StringBuilder txt=new StringBuilder();
    txt.append(""String_Node_Str"").append(portletNames.toString());
    LOG.debug(txt.toString());
  }
  ams.setDefaultNamespace(pad.getDefaultNamespace());
  for (  String pn : portletNames) {
    PortletDefinition pd=pad.getPortlet(pn);
    if (pd == null) {
      pd=new PortletDefinitionImpl(pn,pad);
    }
    if (pd.getSupports().isEmpty()) {
      Map<String,Supports> mimeSupps=new HashMap<String,Supports>();
      Set<MethodIdentifier> mis=ams.getMethodIDsForPortlet(pn);
      for (      MethodIdentifier mi : mis) {
        if (mi.getType() == MethodType.RENDER) {
          String mode=(String)mi.getId();
          if (mode.equalsIgnoreCase(""String_Node_Str"") || mode.equalsIgnoreCase(""String_Node_Str"") || mode.equalsIgnoreCase(""String_Node_Str"")) {
            List<AnnotatedMethod> meths=ams.getMethods(mi);
            for (            AnnotatedMethod meth : meths) {
              RenderMethod rm=(RenderMethod)meth.getAnnotation();
              String mimeType=""String_Node_Str"";
              if (rm != null) {
                mimeType=rm.contentType().replaceAll(""String_Node_Str"",""String_Node_Str"").replaceAll(""String_Node_Str"",""String_Node_Str"").toLowerCase();
                mimeType=mimeType.equals(""String_Node_Str"") ? ""String_Node_Str"" : mimeType;
              }
              Supports sup=mimeSupps.get(mimeType);
              if (sup == null) {
                sup=new SupportsImpl(mimeType);
                mimeSupps.put(mimeType,sup);
              }
              if (!sup.getPortletModes().contains(mode)) {
                sup.addPortletMode(mode);
              }
            }
          }
        }
      }
      for (      Supports sup : mimeSupps.values()) {
        pd.addSupports(sup);
      }
      if (isDebug) {
        StringBuilder txt=new StringBuilder();
        txt.append(""String_Node_Str"").append(mimeSupps.size()).append(""String_Node_Str"");
        for (        String mt : mimeSupps.keySet()) {
          txt.append(""String_Node_Str"").append(mt);
          txt.append(""String_Node_Str"");
          txt.append(((Supports)mimeSupps.get(mt)).getPortletModes().toString());
        }
        LOG.debug(txt.toString());
      }
    }
    Set<MethodIdentifier> mis=ams.getMethodIDsForPortlet(pn);
    for (    MethodIdentifier mi : mis) {
      if (mi.getType() == MethodType.RESOURCE) {
        List<AnnotatedMethod> meths=ams.getMethods(mi);
        for (        AnnotatedMethod meth : meths) {
          ServeResourceMethod srm=(ServeResourceMethod)meth.getAnnotation();
          if (srm != null && srm.asyncSupported()) {
            pd.setAsyncSupported(true);
          }
        }
      }
    }
    List<EventDefinitionReference> edrs=pd.getSupportedProcessingEvents();
    for (    QName qn : ams.getProcessingEventRefs(pn)) {
      EventDefinition ed=pad.getEventDefinition(qn);
      if (ed == null) {
        StringBuilder txt=new StringBuilder(128);
        txt.append(""String_Node_Str"");
        txt.append(""String_Node_Str"").append(pn);
        txt.append(""String_Node_Str"").append(qn);
        LOG.warn(txt.toString());
        MethodIdentifier mi=new MethodIdentifier(pd.getPortletName(),qn,MethodType.EVENT);
        ams.removeMethod(mi);
        continue;
      }
      EventDefinitionReference newedr=new EventDefinitionReferenceImpl(qn);
      if (!edrs.contains(newedr)) {
        pd.addSupportedProcessingEvent(newedr);
      }
    }
    edrs=pd.getSupportedPublishingEvents();
    for (    QName qn : ams.getPublishingEventRefs(pn)) {
      EventDefinition ed=pad.getEventDefinition(qn);
      if (ed == null) {
        StringBuilder txt=new StringBuilder(128);
        txt.append(""String_Node_Str"");
        txt.append(""String_Node_Str"").append(pn);
        txt.append(""String_Node_Str"").append(qn);
        LOG.warn(txt.toString());
        continue;
      }
      EventDefinitionReference newedr=new EventDefinitionReferenceImpl(qn);
      if (!edrs.contains(newedr)) {
        pd.addSupportedPublishingEvent(newedr);
      }
    }
    pad.addPortlet(pd);
  }
  List<PortletDefinition> badPortlets=new ArrayList<PortletDefinition>();
  for (  PortletDefinition pd : pad.getPortlets()) {
    Class<?> cls=null;
    String clsName=pd.getPortletClass();
    if (isValidIdentifier(clsName)) {
      Class<?> valClass=null;
      StringBuilder txt=new StringBuilder(128);
      try {
        ClassLoader cl=Thread.currentThread().getContextClassLoader();
        if (cl == null) {
          cl=this.getClass().getClassLoader();
        }
        valClass=cl.loadClass(clsName);
        if (Portlet.class.isAssignableFrom(valClass)) {
          cls=valClass;
        }
 else {
          txt.append(""String_Node_Str"");
        }
      }
 catch (      Exception e) {
        txt.append(""String_Node_Str"");
      }
 finally {
        if (cls == null) {
          txt.append(""String_Node_Str"").append(pd.getPortletName());
          txt.append(""String_Node_Str"").append(clsName);
          LOG.warn(txt.toString());
        }
      }
    }
    if (cls != null) {
      AnnotatedMethod am;
      am=getMethod(cls,""String_Node_Str"",METH_INI);
      if (am != null) {
        MethodIdentifier mi=new MethodIdentifier(pd.getPortletName(),""String_Node_Str"",MethodType.INIT);
        if (ams.getMethods(mi).size() == 0) {
          ams.addMethod(mi,am);
        }
      }
      am=getMethod(cls,""String_Node_Str"",METH_DES);
      if (am != null) {
        MethodIdentifier mi=new MethodIdentifier(pd.getPortletName(),""String_Node_Str"",MethodType.DESTROY);
        if (ams.getMethods(mi).size() == 0) {
          ams.addMethod(mi,am);
        }
      }
      am=getMethod(cls,""String_Node_Str"",METH_ACT);
      if (am != null) {
        MethodIdentifier mi=new MethodIdentifier(pd.getPortletName(),""String_Node_Str"",MethodType.ACTION);
        if (ams.getMethods(mi).size() == 0) {
          ams.addMethod(mi,am);
        }
      }
      am=getMethod(cls,""String_Node_Str"",METH_EVT);
      if (am != null) {
        MethodIdentifier mi=new MethodIdentifier(pd.getPortletName(),""String_Node_Str"",MethodType.EVENT);
        if (ams.getMethods(mi).size() == 0) {
          ams.addMethod(mi,am);
        }
      }
      am=getMethod(cls,""String_Node_Str"",METH_REN);
      if (am != null) {
        MethodIdentifier mi=new MethodIdentifier(pd.getPortletName(),""String_Node_Str"",MethodType.RENDER);
        if (ams.getMethods(mi).size() == 0) {
          ams.addMethod(mi,am);
        }
      }
      am=getMethod(cls,""String_Node_Str"",METH_HDR);
      if (am != null) {
        MethodIdentifier mi=new MethodIdentifier(pd.getPortletName(),""String_Node_Str"",MethodType.HEADER);
        if (ams.getMethods(mi).size() == 0) {
          ams.addMethod(mi,am);
        }
      }
      am=getMethod(cls,""String_Node_Str"",METH_RES);
      if (am != null) {
        MethodIdentifier mi=new MethodIdentifier(pd.getPortletName(),""String_Node_Str"",MethodType.RESOURCE);
        if (ams.getMethods(mi).size() == 0) {
          ams.addMethod(mi,am);
        }
      }
    }
    boolean methodsOK=false;
    for (    MethodIdentifier mi : ams.getMethodIDsForPortlet(pd.getPortletName())) {
      if ((mi.getType() == MethodType.RENDER) || (mi.getType() == MethodType.RESOURCE) || (mi.getType() == MethodType.HEADER)) {
        methodsOK=true;
        break;
      }
    }
    if (!methodsOK) {
      ams.removeMethodsForPortlet(pd.getPortletName());
      badPortlets.add(pd);
      StringBuilder txt=new StringBuilder();
      txt.append(""String_Node_Str"");
      txt.append(""String_Node_Str"").append(pd.getPortletName());
      LOG.warn(txt.toString());
    }
  }
  for (  PortletDefinition pd : badPortlets) {
    pad.removePortlet(pd);
  }
  if (isDebug) {
    StringBuilder txt=new StringBuilder();
    txt.append(""String_Node_Str"");
    Set<String> finalNames=ams.getPortletNames();
    finalNames.remove(""String_Node_Str"");
    txt.append(""String_Node_Str"").append(finalNames.toString());
    LOG.debug(txt.toString());
  }
}","/** 
 * reconciles the given annotated method store containing the bean configuration with the configuration as read from the portlet deployment descriptor and the corresponding type annotations. <p> Portlets that are defined in the bean config are added to the portlet application definition if not already present. Event reference information from the annotations is verified and added to the corresponding portlet definition. <p> Methods from portlet classes definied in the portlet definitions are added to the annotated method store.
 * @param ams
 */
public void reconcileBeanConfig(AnnotatedMethodStore ams){
  Set<String> portletNames=ams.getPortletNames();
  portletNames.remove(""String_Node_Str"");
  if (isDebug) {
    StringBuilder txt=new StringBuilder();
    txt.append(""String_Node_Str"").append(portletNames.toString());
    LOG.debug(txt.toString());
  }
  ams.setDefaultNamespace(pad.getDefaultNamespace());
  for (  String pn : portletNames) {
    PortletDefinition pd=pad.getPortlet(pn);
    if (pd == null) {
      pd=new PortletDefinitionImpl(pn,pad);
    }
    if (pd.getSupports().isEmpty()) {
      Map<String,Supports> mimeSupps=new HashMap<String,Supports>();
      Set<MethodIdentifier> mis=ams.getMethodIDsForPortlet(pn);
      for (      MethodIdentifier mi : mis) {
        if (mi.getType() == MethodType.RENDER) {
          String mode=(String)mi.getId();
          if (mode.equalsIgnoreCase(""String_Node_Str"") || mode.equalsIgnoreCase(""String_Node_Str"") || mode.equalsIgnoreCase(""String_Node_Str"")) {
            List<AnnotatedMethod> meths=ams.getMethods(mi);
            for (            AnnotatedMethod meth : meths) {
              RenderMethod rm=(RenderMethod)meth.getAnnotation();
              String mimeType=""String_Node_Str"";
              if (rm != null) {
                mimeType=rm.contentType().replaceAll(""String_Node_Str"",""String_Node_Str"").replaceAll(""String_Node_Str"",""String_Node_Str"").toLowerCase();
                mimeType=mimeType.equals(""String_Node_Str"") ? ""String_Node_Str"" : mimeType;
              }
              Supports sup=mimeSupps.get(mimeType);
              if (sup == null) {
                sup=new SupportsImpl(mimeType);
                mimeSupps.put(mimeType,sup);
              }
              if (!sup.getPortletModes().contains(mode)) {
                sup.addPortletMode(mode);
              }
            }
          }
        }
      }
      for (      Supports sup : mimeSupps.values()) {
        pd.addSupports(sup);
      }
      if (isDebug) {
        StringBuilder txt=new StringBuilder();
        txt.append(""String_Node_Str"").append(mimeSupps.size()).append(""String_Node_Str"");
        for (        String mt : mimeSupps.keySet()) {
          txt.append(""String_Node_Str"").append(mt);
          txt.append(""String_Node_Str"");
          txt.append(((Supports)mimeSupps.get(mt)).getPortletModes().toString());
        }
        LOG.debug(txt.toString());
      }
    }
    Set<MethodIdentifier> mis=ams.getMethodIDsForPortlet(pn);
    for (    MethodIdentifier mi : mis) {
      if (mi.getType() == MethodType.RESOURCE) {
        List<AnnotatedMethod> meths=ams.getMethods(mi);
        for (        AnnotatedMethod meth : meths) {
          ServeResourceMethod srm=(ServeResourceMethod)meth.getAnnotation();
          if (srm != null && srm.asyncSupported()) {
            pd.setAsyncSupported(true);
          }
        }
      }
    }
    List<EventDefinitionReference> edrs=pd.getSupportedProcessingEvents();
    for (    QName qn : ams.getProcessingEventRefs(pn)) {
      EventDefinition ed=pad.getEventDefinition(qn);
      if (ed == null) {
        StringBuilder txt=new StringBuilder(128);
        txt.append(""String_Node_Str"");
        txt.append(""String_Node_Str"").append(pn);
        txt.append(""String_Node_Str"").append(qn);
        LOG.warn(txt.toString());
        MethodIdentifier mi=new MethodIdentifier(pd.getPortletName(),qn,MethodType.EVENT);
        ams.removeMethod(mi);
        continue;
      }
      EventDefinitionReference newedr=new EventDefinitionReferenceImpl(qn);
      if (!edrs.contains(newedr)) {
        pd.addSupportedProcessingEvent(newedr);
      }
    }
    edrs=pd.getSupportedPublishingEvents();
    for (    QName qn : ams.getPublishingEventRefs(pn)) {
      EventDefinition ed=pad.getEventDefinition(qn);
      if (ed == null) {
        StringBuilder txt=new StringBuilder(128);
        txt.append(""String_Node_Str"");
        txt.append(""String_Node_Str"").append(pn);
        txt.append(""String_Node_Str"").append(qn);
        LOG.warn(txt.toString());
        continue;
      }
      EventDefinitionReference newedr=new EventDefinitionReferenceImpl(qn);
      if (!edrs.contains(newedr)) {
        pd.addSupportedPublishingEvent(newedr);
      }
    }
    pad.addPortlet(pd);
  }
  for (  PortletDefinition pd : pad.getPortlets()) {
    Class<?> cls=null;
    String clsName=pd.getPortletClass();
    if (isValidIdentifier(clsName)) {
      Class<?> valClass=null;
      StringBuilder txt=new StringBuilder(128);
      try {
        ClassLoader cl=Thread.currentThread().getContextClassLoader();
        if (cl == null) {
          cl=this.getClass().getClassLoader();
        }
        valClass=cl.loadClass(clsName);
        if (Portlet.class.isAssignableFrom(valClass)) {
          cls=valClass;
        }
 else {
          txt.append(""String_Node_Str"");
        }
      }
 catch (      Exception e) {
        txt.append(""String_Node_Str"");
      }
 finally {
        if (cls == null) {
          txt.append(""String_Node_Str"").append(pd.getPortletName());
          txt.append(""String_Node_Str"").append(clsName);
          LOG.warn(txt.toString());
        }
      }
    }
    if (cls != null) {
      AnnotatedMethod am;
      am=getMethod(cls,""String_Node_Str"",METH_INI);
      if (am != null) {
        MethodIdentifier mi=new MethodIdentifier(pd.getPortletName(),""String_Node_Str"",MethodType.INIT);
        if (ams.getMethods(mi).size() == 0) {
          ams.addMethod(mi,am);
        }
      }
      am=getMethod(cls,""String_Node_Str"",METH_DES);
      if (am != null) {
        MethodIdentifier mi=new MethodIdentifier(pd.getPortletName(),""String_Node_Str"",MethodType.DESTROY);
        if (ams.getMethods(mi).size() == 0) {
          ams.addMethod(mi,am);
        }
      }
      am=getMethod(cls,""String_Node_Str"",METH_ACT);
      if (am != null) {
        MethodIdentifier mi=new MethodIdentifier(pd.getPortletName(),""String_Node_Str"",MethodType.ACTION);
        if (ams.getMethods(mi).size() == 0) {
          ams.addMethod(mi,am);
        }
      }
      am=getMethod(cls,""String_Node_Str"",METH_EVT);
      if (am != null) {
        MethodIdentifier mi=new MethodIdentifier(pd.getPortletName(),""String_Node_Str"",MethodType.EVENT);
        if (ams.getMethods(mi).size() == 0) {
          ams.addMethod(mi,am);
        }
      }
      am=getMethod(cls,""String_Node_Str"",METH_REN);
      if (am != null) {
        MethodIdentifier mi=new MethodIdentifier(pd.getPortletName(),""String_Node_Str"",MethodType.RENDER);
        if (ams.getMethods(mi).size() == 0) {
          ams.addMethod(mi,am);
        }
      }
      am=getMethod(cls,""String_Node_Str"",METH_HDR);
      if (am != null) {
        MethodIdentifier mi=new MethodIdentifier(pd.getPortletName(),""String_Node_Str"",MethodType.HEADER);
        if (ams.getMethods(mi).size() == 0) {
          ams.addMethod(mi,am);
        }
      }
      am=getMethod(cls,""String_Node_Str"",METH_RES);
      if (am != null) {
        MethodIdentifier mi=new MethodIdentifier(pd.getPortletName(),""String_Node_Str"",MethodType.RESOURCE);
        if (ams.getMethods(mi).size() == 0) {
          ams.addMethod(mi,am);
        }
      }
    }
  }
  Set<MethodIdentifier> mis=ams.getMethodIDsForPortlet(""String_Node_Str"");
  if (isDebug) {
    StringBuilder txt=new StringBuilder();
    txt.append(""String_Node_Str"");
    String sep=""String_Node_Str"";
    for (    MethodIdentifier mi : mis) {
      txt.append(sep).append(mi.toString());
      sep=""String_Node_Str"";
    }
    LOG.debug(txt.toString());
  }
  for (  MethodIdentifier mi : mis) {
    List<AnnotatedMethod> meths=ams.getMethods(mi);
    for (    PortletDefinition pd : pad.getPortlets()) {
      MethodIdentifier newMi=new MethodIdentifier(pd.getPortletName(),mi.getId(),mi.getType());
      for (      AnnotatedMethod meth : meths) {
        ams.addMethod(newMi,meth);
      }
    }
  }
  List<PortletDefinition> badPortlets=new ArrayList<PortletDefinition>();
  for (  PortletDefinition pd : pad.getPortlets()) {
    boolean methodsOK=false;
    for (    MethodIdentifier mi : ams.getMethodIDsForPortlet(pd.getPortletName())) {
      if ((mi.getType() == MethodType.RENDER) || (mi.getType() == MethodType.RESOURCE) || (mi.getType() == MethodType.HEADER)) {
        methodsOK=true;
        break;
      }
    }
    if (!methodsOK) {
      ams.removeMethodsForPortlet(pd.getPortletName());
      badPortlets.add(pd);
      StringBuilder txt=new StringBuilder();
      txt.append(""String_Node_Str"");
      txt.append(""String_Node_Str"").append(pd.getPortletName());
      LOG.warn(txt.toString());
    }
  }
  for (  PortletDefinition pd : badPortlets) {
    pad.removePortlet(pd);
  }
  if (isDebug) {
    StringBuilder txt=new StringBuilder();
    txt.append(""String_Node_Str"");
    Set<String> finalNames=ams.getPortletNames();
    finalNames.remove(""String_Node_Str"");
    txt.append(""String_Node_Str"").append(finalNames.toString());
    LOG.debug(txt.toString());
  }
  if (isTrace) {
    StringBuilder txt=new StringBuilder();
    txt.append(ams.getMethodsAsString());
    LOG.trace(txt.toString());
  }
}",0.9429877053639428
90515,"public void processAction(ActionRequest req,ActionResponse resp) throws PortletException, IOException {
  ActionParameters ap=req.getActionParameters();
  MutableRenderParameters mrp=resp.getRenderParameters();
  Set<? extends String> rpNames=mrp.getNames();
  if (isDebug) {
    StringBuffer sb=new StringBuffer();
    sb.append(""String_Node_Str"");
    for (    String k : ap.getNames()) {
      sb.append(""String_Node_Str"").append(k);
      sb.append(""String_Node_Str"").append(Arrays.toString(ap.getValues(k)));
    }
    logger.fine(sb.toString());
  }
  String setType=ap.getValue(PARAM_SETTYPE);
  setType=(setType == null) ? PARAM_SETTYPE_VARRAY : setType;
  mrp.setValue(PARAM_SETTYPE,setType);
  String remType=ap.getValue(PARAM_REMTYPE);
  remType=(remType == null) ? PARAM_REMTYPE_SET : remType;
  mrp.setValue(PARAM_REMTYPE,remType);
  String pn=ap.getValue(PARAM_NAME);
  String pv=ap.getValue(PARAM_VALUES);
  String[] parsedVals=null;
  StringBuilder txt=new StringBuilder(""String_Node_Str"");
  if (pn != null && pn.length() > 0 && pv != null) {
    parsedVals=pv.split(""String_Node_Str"",-1);
    if (pv.length() == 0) {
      txt.append(""String_Node_Str"");
      parsedVals=new String[]{""String_Node_Str""};
    }
 else     if (parsedVals.length == 1) {
      if (parsedVals[0].equals(""String_Node_Str"")) {
        txt.append(""String_Node_Str"");
        parsedVals=null;
      }
 else       if (parsedVals[0].equals(""String_Node_Str"")) {
        txt.append(""String_Node_Str"");
        parsedVals=new String[0];
      }
 else {
        txt.append(""String_Node_Str"");
      }
    }
 else {
      txt.append(""String_Node_Str"");
      for (int ii=0; ii < parsedVals.length; ii++) {
        if (parsedVals[ii].equals(""String_Node_Str"")) {
          parsedVals[ii]=null;
        }
      }
    }
    try {
      if (remType.equals(PARAM_REMTYPE_REM)) {
        txt.append(""String_Node_Str"");
        mrp.removeParameter(pn);
      }
 else {
        if (setType.equals(PARAM_SETTYPE_VARRAY)) {
          txt.append(""String_Node_Str"");
          mrp.setValues(pn,parsedVals);
        }
 else {
          txt.append(""String_Node_Str"");
          String tval=(parsedVals == null) ? null : parsedVals[0];
          mrp.setValue(pn,tval);
        }
      }
    }
 catch (    Exception e) {
      StringBuilder err=new StringBuilder(""String_Node_Str"");
      err.append(e.toString());
      mrp.setValue(""String_Node_Str"",""String_Node_Str"" + err.toString() + ""String_Node_Str"");
    }
  }
 else   if (rpNames.isEmpty()) {
    txt.append(""String_Node_Str"");
    mrp.setValue(""String_Node_Str"",""String_Node_Str"");
  }
  if (isDebug) {
    logger.fine(txt.toString());
    txt=new StringBuilder(""String_Node_Str"");
    txt.append(""String_Node_Str"").append(pn);
    txt.append(""String_Node_Str"").append(pv).append(""String_Node_Str"");
    txt.append(""String_Node_Str"").append(Arrays.toString(parsedVals));
    logger.fine(txt.toString());
  }
}","public void processAction(ActionRequest req,ActionResponse resp) throws PortletException, IOException {
  ActionParameters ap=req.getActionParameters();
  MutableRenderParameters mrp=resp.getRenderParameters();
  Set<? extends String> rpNames=mrp.getNames();
  if (isDebug) {
    StringBuffer sb=new StringBuffer();
    sb.append(""String_Node_Str"");
    for (    String k : ap.getNames()) {
      sb.append(""String_Node_Str"").append(k);
      sb.append(""String_Node_Str"").append(Arrays.toString(ap.getValues(k)));
    }
    logger.fine(sb.toString());
  }
  String setType=ap.getValue(PARAM_SETTYPE);
  setType=(setType == null) ? PARAM_SETTYPE_VARRAY : setType;
  mrp.setValue(PARAM_SETTYPE,setType);
  String remType=ap.getValue(PARAM_REMTYPE);
  remType=(remType == null) ? PARAM_REMTYPE_SET : remType;
  mrp.setValue(PARAM_REMTYPE,remType);
  String pn=ap.getValue(PARAM_NAME);
  String pv=ap.getValue(PARAM_VALUES);
  String[] parsedVals=null;
  StringBuilder txt=new StringBuilder(""String_Node_Str"");
  if (pn != null && pn.length() > 0 && pv != null) {
    if (pn.equals(""String_Node_Str"")) {
      pn=null;
    }
    parsedVals=pv.split(""String_Node_Str"",-1);
    if (pv.length() == 0) {
      txt.append(""String_Node_Str"");
      parsedVals=new String[]{""String_Node_Str""};
    }
 else     if (parsedVals.length == 1) {
      if (parsedVals[0].equals(""String_Node_Str"")) {
        txt.append(""String_Node_Str"");
        parsedVals=null;
      }
 else       if (parsedVals[0].equals(""String_Node_Str"")) {
        txt.append(""String_Node_Str"");
        parsedVals=new String[0];
      }
 else {
        txt.append(""String_Node_Str"");
      }
    }
 else {
      txt.append(""String_Node_Str"");
      for (int ii=0; ii < parsedVals.length; ii++) {
        if (parsedVals[ii].equals(""String_Node_Str"")) {
          parsedVals[ii]=null;
        }
      }
    }
    try {
      if (remType.equals(PARAM_REMTYPE_REM)) {
        txt.append(""String_Node_Str"");
        mrp.removeParameter(pn);
      }
 else {
        if (setType.equals(PARAM_SETTYPE_VARRAY)) {
          txt.append(""String_Node_Str"");
          mrp.setValues(pn,parsedVals);
        }
 else {
          txt.append(""String_Node_Str"");
          String tval=(parsedVals == null) ? null : parsedVals[0];
          mrp.setValue(pn,tval);
        }
      }
    }
 catch (    Exception e) {
      StringBuilder err=new StringBuilder(""String_Node_Str"");
      err.append(e.toString());
      mrp.setValue(""String_Node_Str"",""String_Node_Str"" + err.toString() + ""String_Node_Str"");
    }
  }
 else   if (rpNames.isEmpty()) {
    txt.append(""String_Node_Str"");
    mrp.setValue(""String_Node_Str"",""String_Node_Str"");
  }
  if (isDebug) {
    logger.fine(txt.toString());
    txt=new StringBuilder(""String_Node_Str"");
    txt.append(""String_Node_Str"").append(pn);
    txt.append(""String_Node_Str"").append(pv).append(""String_Node_Str"");
    txt.append(""String_Node_Str"").append(Arrays.toString(parsedVals));
    logger.fine(txt.toString());
  }
}",0.9897289105910084
90516,"/** 
 * Throws exception if argument is null.
 * @param msg
 * @param vals
 */
protected void checkNull(String msg,Object... vals){
  if (vals == null) {
    throw new IllegalArgumentException(""String_Node_Str"" + msg + ""String_Node_Str"");
  }
}","/** 
 * Throws exception if argument is null.
 * @param msg
 * @param val
 */
protected void checkNull(String msg,Object val){
  if (val == null) {
    throw new IllegalArgumentException(""String_Node_Str"" + msg + ""String_Node_Str"");
  }
}",0.970954356846473
90517,"/** 
 * Checks if the specified content type is valid (supported by the portlet). The specified content type should be a tripped mime type without any character encoding suffix.
 * @param contentType  the content type to check.
 * @return true if the content type is valid, false otherwise.
 */
protected boolean isValidContentType(String contentType){
  boolean valid=false;
  for (  String supportedType : getResponseContentTypes()) {
    if (supportedType.equals(contentType)) {
      valid=true;
    }
 else     if (supportedType.indexOf(""String_Node_Str"") >= 0) {
      int index=supportedType.indexOf(""String_Node_Str"");
      String supportedPrefix=supportedType.substring(0,index);
      String supportedSuffix=supportedType.substring(index + 1);
      index=contentType.indexOf(""String_Node_Str"");
      String typePrefix=contentType.substring(0,index);
      String typeSuffix=contentType.substring(index + 1);
      if (supportedPrefix.equals(""String_Node_Str"") || supportedPrefix.equals(typePrefix)) {
        if (supportedSuffix.equals(""String_Node_Str"") || supportedSuffix.equals(typeSuffix)) {
          valid=true;
        }
      }
    }
  }
  return valid;
}","/** 
 * Checks if the specified content type is valid (supported by the portlet). The specified content type should be a tripped mime type without any character encoding suffix.
 * @param contentType the content type to check.
 * @return true if the content type is valid, false otherwise.
 */
protected boolean isValidContentType(String contentType){
}",0.4617396991497711
90518,"@Override public void setContentType(String contentType){
  ArgumentUtility.validateNotNull(""String_Node_Str"",contentType);
  int index=contentType.indexOf(';');
  if (index != -1) {
    contentType=contentType.substring(0,index);
  }
  contentType=contentType.trim();
  if (!isValidContentType(contentType)) {
    throw new IllegalArgumentException(""String_Node_Str"" + contentType + ""String_Node_Str"");
  }
  super.setContentType(contentType);
}","@Override public void setContentType(String contentType){
  ArgumentUtility.validateNotNull(""String_Node_Str"",contentType);
  contentType=contentType.replaceAll(""String_Node_Str"",""String_Node_Str"").replaceAll(""String_Node_Str"",""String_Node_Str"");
  if (!isValidContentType(contentType)) {
    throw new IllegalArgumentException(""String_Node_Str"" + contentType + ""String_Node_Str"");
  }
  super.setContentType(contentType);
}",0.3080459770114943
90519,"/** 
 * Returns the portlet session. <p> Note that since portlet request instance is created everytime the portlet container receives an incoming request, the portlet session instance held by the request instance is also re-created for each incoming request. </p>
 */
@Override public PortletSession getPortletSession(boolean create){
  return requestContext.getPortletSession(true);
}","/** 
 * Returns the portlet session. <p> Note that since portlet request instance is created everytime the portlet container receives an incoming request, the portlet session instance held by the request instance is also re-created for each incoming request. </p>
 */
@Override public PortletSession getPortletSession(boolean create){
  return requestContext.getPortletSession(create);
}",0.9896373056994818
90520,"/** 
 * Checks if the specified content type is valid (supported by the portlet). The specified content type should be a tripped mime type without any character encoding suffix.
 * @param contentType  the content type to check.
 * @return true if the content type is valid, false otherwise.
 */
protected boolean isValidContentType(String contentType){
  boolean valid=false;
  for (  String supportedType : getResponseContentTypes()) {
    if (supportedType.equals(contentType)) {
      valid=true;
    }
 else     if (supportedType.indexOf(""String_Node_Str"") >= 0) {
      int index=supportedType.indexOf(""String_Node_Str"");
      String supportedPrefix=supportedType.substring(0,index);
      String supportedSuffix=supportedType.substring(index + 1);
      index=contentType.indexOf(""String_Node_Str"");
      String typePrefix=contentType.substring(0,index);
      String typeSuffix=contentType.substring(index + 1);
      if (supportedPrefix.equals(""String_Node_Str"") || supportedPrefix.equals(typePrefix)) {
        if (supportedSuffix.equals(""String_Node_Str"") || supportedSuffix.equals(typeSuffix)) {
          valid=true;
        }
      }
    }
  }
  return valid;
}","/** 
 * Checks if the specified content type is valid (supported by the portlet). The specified content type should be a tripped mime type without any character encoding suffix.
 * @param contentType the content type to check.
 * @return true if the content type is valid, false otherwise.
 */
protected boolean isValidContentType(String contentType){
}",0.4617396991497711
90521,"@Override public void setContentType(String contentType){
  ArgumentUtility.validateNotNull(""String_Node_Str"",contentType);
  int index=contentType.indexOf(';');
  if (index != -1) {
    contentType=contentType.substring(0,index);
  }
  contentType=contentType.trim();
  if (!isValidContentType(contentType)) {
    throw new IllegalArgumentException(""String_Node_Str"" + contentType + ""String_Node_Str"");
  }
  super.setContentType(contentType);
}","@Override public void setContentType(String contentType){
  ArgumentUtility.validateNotNull(""String_Node_Str"",contentType);
  contentType=contentType.replaceAll(""String_Node_Str"",""String_Node_Str"").replaceAll(""String_Node_Str"",""String_Node_Str"");
  if (!isValidContentType(contentType)) {
    throw new IllegalArgumentException(""String_Node_Str"" + contentType + ""String_Node_Str"");
  }
  super.setContentType(contentType);
}",0.3080459770114943
90522,"@RenderMode(name=""String_Node_Str"") public void doView(RenderRequest portletReq,RenderResponse portletResp) throws PortletException, IOException {
  PrintWriter writer=portletResp.getWriter();
  ModuleTestCaseDetails tcd=new ModuleTestCaseDetails();
  RenderParameters renderParams=portletReq.getRenderParameters();
  if (renderParams.getValue(""String_Node_Str"") != null && renderParams.getValue(""String_Node_Str"").equals(""String_Node_Str"")) {
    TestResult result=tcd.getTestResultFailed(V3RENDERSTATETESTS_SPEC2_12_MUTABLERENDERSTATE_SETPORTLETMODE2);
    if (portletReq.getPortletMode().equals(new PortletMode(""String_Node_Str""))) {
      result.setTcSuccess(true);
    }
 else {
      result.appendTcDetail(""String_Node_Str"" + portletReq.getPortletMode().toString());
    }
    result.writeTo(writer);
  }
}","@RenderMode(name=""String_Node_Str"") public void doView(RenderRequest portletReq,RenderResponse portletResp) throws PortletException, IOException {
  PrintWriter writer=portletResp.getWriter();
  ModuleTestCaseDetails tcd=new ModuleTestCaseDetails();
  RenderParameters renderParams=portletReq.getRenderParameters();
  if (renderParams.getValue(""String_Node_Str"") != null && renderParams.getValue(""String_Node_Str"").equals(""String_Node_Str"")) {
    TestResult result=tcd.getTestResultFailed(V3RENDERSTATETESTS_SPEC2_12_MUTABLERENDERSTATE_SETPORTLETMODE2);
    if (portletReq.getPortletMode().equals(new PortletMode(""String_Node_Str""))) {
      result.setTcSuccess(true);
    }
 else {
      result.appendTcDetail(""String_Node_Str"" + portletReq.getPortletMode().toString());
    }
    result.writeTo(writer);
  }
  if (renderParams.getValue(""String_Node_Str"") != null && renderParams.getValue(""String_Node_Str"").equals(""String_Node_Str"")) {
    TestResult result=tcd.getTestResultFailed(V3RENDERSTATETESTS_SPEC2_12_MUTABLERENDERSTATE_SETWINDOWSTATE2);
    if (portletReq.getWindowState().equals(new WindowState(""String_Node_Str""))) {
      result.setTcSuccess(true);
    }
 else {
      result.appendTcDetail(""String_Node_Str"" + portletReq.getWindowState().toString());
    }
    result.writeTo(writer);
  }
}",0.7663992449268523
90523,"@Override public void render(RenderRequest portletReq,RenderResponse portletResp) throws PortletException, IOException {
  portletResp.setContentType(""String_Node_Str"");
  PrintWriter writer=portletResp.getWriter();
  ModuleTestCaseDetails tcd=new ModuleTestCaseDetails();
  PortletSession ps=portletReq.getPortletSession();
  String msg=(String)ps.getAttribute(Constants.RESULT_ATTR_PREFIX + ""String_Node_Str"");
  ps.removeAttribute(Constants.RESULT_ATTR_PREFIX + ""String_Node_Str"");
  if (msg != null && msg.length() > 0) {
    writer.write(""String_Node_Str"" + msg + ""String_Node_Str"");
  }
  RenderParameters renderParams=portletReq.getRenderParameters();
{
    ActionURL actionURL=portletResp.createActionURL();
    MutableRenderParameters mutableRenderParams=actionURL.getRenderParameters();
    mutableRenderParams.setValue(""String_Node_Str"",""String_Node_Str"");
    mutableRenderParams.setValue(""String_Node_Str"",""String_Node_Str"");
    TestButton tb=new TestButton(V3RENDERSTATETESTS_SPEC2_12_MUTABLERENDERSTATE_GETRENDERPARAMETERS,actionURL);
    tb.writeTo(writer);
  }
  if (renderParams.getValue(""String_Node_Str"") != null && renderParams.getValue(""String_Node_Str"").equals(""String_Node_Str"")) {
    TestResult result=tcd.getTestResultFailed(V3RENDERSTATETESTS_SPEC2_12_MUTABLERENDERSTATE_GETRENDERPARAMETERS2);
    result.setTcSuccess(true);
    result.writeTo(writer);
  }
 else {
    ActionURL actionURL=portletResp.createActionURL();
    TestButton tb=new TestButton(V3RENDERSTATETESTS_SPEC2_12_MUTABLERENDERSTATE_GETRENDERPARAMETERS2,actionURL);
    tb.writeTo(writer);
  }
  if (portletReq.getPortletMode().equals(PortletMode.HELP)) {
    TestResult result=tcd.getTestResultFailed(V3RENDERSTATETESTS_SPEC2_12_MUTABLERENDERSTATE_SETPORTLETMODE);
    result.setTcSuccess(true);
    result.writeTo(writer);
  }
 else {
    ActionURL actionURL=portletResp.createActionURL();
    TestButton tb=new TestButton(V3RENDERSTATETESTS_SPEC2_12_MUTABLERENDERSTATE_SETPORTLETMODE,actionURL);
    tb.writeTo(writer);
  }
  if (renderParams.getValue(""String_Node_Str"") == null) {
    ActionURL actionURL=portletResp.createActionURL();
    TestButton tb=new TestButton(V3RENDERSTATETESTS_SPEC2_12_MUTABLERENDERSTATE_SETPORTLETMODE2,actionURL);
    tb.writeTo(writer);
  }
 else {
    super.render(portletReq,portletResp);
  }
  if (portletReq.getPortletMode().equals(PortletMode.HELP)) {
    TestResult result=tcd.getTestResultFailed(V3RENDERSTATETESTS_SPEC2_12_MUTABLERENDERSTATE_SETPORTLETMODE3);
    result.setTcSuccess(true);
    result.writeTo(writer);
  }
 else {
    ActionURL actionURL=portletResp.createActionURL();
    TestButton tb=new TestButton(V3RENDERSTATETESTS_SPEC2_12_MUTABLERENDERSTATE_SETPORTLETMODE3,actionURL);
    tb.writeTo(writer);
  }
{
    ActionURL actionURL=portletResp.createActionURL();
    TestButton tb=new TestButton(V3RENDERSTATETESTS_SPEC2_12_MUTABLERENDERSTATE_SETPORTLETMODE4,actionURL);
    tb.writeTo(writer);
  }
{
    ActionURL actionURL=portletResp.createActionURL();
    TestButton tb=new TestButton(V3RENDERSTATETESTS_SPEC2_12_MUTABLERENDERSTATE_SETPORTLETMODE5,actionURL);
    tb.writeTo(writer);
  }
{
    ActionURL actionURL=portletResp.createActionURL();
    TestButton tb=new TestButton(V3RENDERSTATETESTS_SPEC2_12_MUTABLERENDERSTATE_SETPORTLETMODE6,actionURL);
    tb.writeTo(writer);
  }
  if (renderParams.getValue(""String_Node_Str"") != null && renderParams.getValue(""String_Node_Str"").equals(""String_Node_Str"") && portletReq.getWindowState().equals(WindowState.NORMAL)) {
    TestResult result=tcd.getTestResultFailed(V3RENDERSTATETESTS_SPEC2_12_MUTABLERENDERSTATE_SETWINDOWSTATE);
    result.setTcSuccess(true);
    result.writeTo(writer);
  }
 else {
    ActionURL actionURL=portletResp.createActionURL();
    TestButton tb=new TestButton(V3RENDERSTATETESTS_SPEC2_12_MUTABLERENDERSTATE_SETWINDOWSTATE,actionURL);
    tb.writeTo(writer);
  }
  if (renderParams.getValue(""String_Node_Str"") != null && renderParams.getValue(""String_Node_Str"").equals(""String_Node_Str"") && portletReq.getWindowState().equals(new WindowState(""String_Node_Str""))) {
    TestResult result=tcd.getTestResultFailed(V3RENDERSTATETESTS_SPEC2_12_MUTABLERENDERSTATE_SETWINDOWSTATE2);
    result.setTcSuccess(true);
    result.writeTo(writer);
  }
 else {
    ActionURL actionURL=portletResp.createActionURL();
    TestButton tb=new TestButton(V3RENDERSTATETESTS_SPEC2_12_MUTABLERENDERSTATE_SETWINDOWSTATE2,actionURL);
    tb.writeTo(writer);
  }
  if (renderParams.getValue(""String_Node_Str"") != null && renderParams.getValue(""String_Node_Str"").equals(""String_Node_Str"") && portletReq.getWindowState().equals(WindowState.NORMAL)) {
    TestResult result=tcd.getTestResultFailed(V3RENDERSTATETESTS_SPEC2_12_MUTABLERENDERSTATE_SETWINDOWSTATE3);
    result.setTcSuccess(true);
    result.writeTo(writer);
  }
 else {
    ActionURL actionURL=portletResp.createActionURL();
    TestButton tb=new TestButton(V3RENDERSTATETESTS_SPEC2_12_MUTABLERENDERSTATE_SETWINDOWSTATE3,actionURL);
    tb.writeTo(writer);
  }
{
    ActionURL actionURL=portletResp.createActionURL();
    TestButton tb=new TestButton(V3RENDERSTATETESTS_SPEC2_12_MUTABLERENDERSTATE_SETWINDOWSTATE4,actionURL);
    tb.writeTo(writer);
  }
{
    ActionURL actionURL=portletResp.createActionURL();
    TestButton tb=new TestButton(V3RENDERSTATETESTS_SPEC2_12_MUTABLERENDERSTATE_SETWINDOWSTATE5,actionURL);
    tb.writeTo(writer);
  }
{
    ActionURL actionURL=portletResp.createActionURL();
    TestButton tb=new TestButton(V3RENDERSTATETESTS_SPEC2_12_MUTABLERENDERSTATE_SETWINDOWSTATE6,actionURL);
    tb.writeTo(writer);
  }
}","@Override public void render(RenderRequest portletReq,RenderResponse portletResp) throws PortletException, IOException {
  portletResp.setContentType(""String_Node_Str"");
  PrintWriter writer=portletResp.getWriter();
  ModuleTestCaseDetails tcd=new ModuleTestCaseDetails();
  PortletSession ps=portletReq.getPortletSession();
  String msg=(String)ps.getAttribute(Constants.RESULT_ATTR_PREFIX + ""String_Node_Str"");
  ps.removeAttribute(Constants.RESULT_ATTR_PREFIX + ""String_Node_Str"");
  if (msg != null && msg.length() > 0) {
    writer.write(""String_Node_Str"" + msg + ""String_Node_Str"");
  }
  RenderParameters renderParams=portletReq.getRenderParameters();
{
    ActionURL actionURL=portletResp.createActionURL();
    MutableRenderParameters mutableRenderParams=actionURL.getRenderParameters();
    mutableRenderParams.setValue(""String_Node_Str"",""String_Node_Str"");
    mutableRenderParams.setValue(""String_Node_Str"",""String_Node_Str"");
    TestButton tb=new TestButton(V3RENDERSTATETESTS_SPEC2_12_MUTABLERENDERSTATE_GETRENDERPARAMETERS,actionURL);
    tb.writeTo(writer);
  }
  if (renderParams.getValue(""String_Node_Str"") != null && renderParams.getValue(""String_Node_Str"").equals(""String_Node_Str"")) {
    TestResult result=tcd.getTestResultFailed(V3RENDERSTATETESTS_SPEC2_12_MUTABLERENDERSTATE_GETRENDERPARAMETERS2);
    result.setTcSuccess(true);
    result.writeTo(writer);
  }
 else {
    ActionURL actionURL=portletResp.createActionURL();
    TestButton tb=new TestButton(V3RENDERSTATETESTS_SPEC2_12_MUTABLERENDERSTATE_GETRENDERPARAMETERS2,actionURL);
    tb.writeTo(writer);
  }
  if (portletReq.getPortletMode().equals(PortletMode.HELP)) {
    TestResult result=tcd.getTestResultFailed(V3RENDERSTATETESTS_SPEC2_12_MUTABLERENDERSTATE_SETPORTLETMODE);
    result.setTcSuccess(true);
    result.writeTo(writer);
  }
 else {
    ActionURL actionURL=portletResp.createActionURL();
    TestButton tb=new TestButton(V3RENDERSTATETESTS_SPEC2_12_MUTABLERENDERSTATE_SETPORTLETMODE,actionURL);
    tb.writeTo(writer);
  }
  if (renderParams.getValue(""String_Node_Str"") == null) {
    ActionURL actionURL=portletResp.createActionURL();
    TestButton tb=new TestButton(V3RENDERSTATETESTS_SPEC2_12_MUTABLERENDERSTATE_SETPORTLETMODE2,actionURL);
    tb.writeTo(writer);
  }
 else {
    super.render(portletReq,portletResp);
  }
  if (portletReq.getPortletMode().equals(PortletMode.HELP)) {
    TestResult result=tcd.getTestResultFailed(V3RENDERSTATETESTS_SPEC2_12_MUTABLERENDERSTATE_SETPORTLETMODE3);
    result.setTcSuccess(true);
    result.writeTo(writer);
  }
 else {
    ActionURL actionURL=portletResp.createActionURL();
    TestButton tb=new TestButton(V3RENDERSTATETESTS_SPEC2_12_MUTABLERENDERSTATE_SETPORTLETMODE3,actionURL);
    tb.writeTo(writer);
  }
{
    ActionURL actionURL=portletResp.createActionURL();
    TestButton tb=new TestButton(V3RENDERSTATETESTS_SPEC2_12_MUTABLERENDERSTATE_SETPORTLETMODE4,actionURL);
    tb.writeTo(writer);
  }
{
    ActionURL actionURL=portletResp.createActionURL();
    TestButton tb=new TestButton(V3RENDERSTATETESTS_SPEC2_12_MUTABLERENDERSTATE_SETPORTLETMODE5,actionURL);
    tb.writeTo(writer);
  }
{
    ActionURL actionURL=portletResp.createActionURL();
    TestButton tb=new TestButton(V3RENDERSTATETESTS_SPEC2_12_MUTABLERENDERSTATE_SETPORTLETMODE6,actionURL);
    tb.writeTo(writer);
  }
  if (renderParams.getValue(""String_Node_Str"") != null && renderParams.getValue(""String_Node_Str"").equals(""String_Node_Str"") && portletReq.getWindowState().equals(WindowState.NORMAL)) {
    TestResult result=tcd.getTestResultFailed(V3RENDERSTATETESTS_SPEC2_12_MUTABLERENDERSTATE_SETWINDOWSTATE);
    result.setTcSuccess(true);
    result.writeTo(writer);
  }
 else {
    ActionURL actionURL=portletResp.createActionURL();
    TestButton tb=new TestButton(V3RENDERSTATETESTS_SPEC2_12_MUTABLERENDERSTATE_SETWINDOWSTATE,actionURL);
    tb.writeTo(writer);
  }
  if (renderParams.getValue(""String_Node_Str"") == null) {
    ActionURL actionURL=portletResp.createActionURL();
    TestButton tb=new TestButton(V3RENDERSTATETESTS_SPEC2_12_MUTABLERENDERSTATE_SETWINDOWSTATE2,actionURL);
    tb.writeTo(writer);
  }
 else {
    super.render(portletReq,portletResp);
  }
  if (renderParams.getValue(""String_Node_Str"") != null && renderParams.getValue(""String_Node_Str"").equals(""String_Node_Str"") && portletReq.getWindowState().equals(WindowState.NORMAL)) {
    TestResult result=tcd.getTestResultFailed(V3RENDERSTATETESTS_SPEC2_12_MUTABLERENDERSTATE_SETWINDOWSTATE3);
    result.setTcSuccess(true);
    result.writeTo(writer);
  }
 else {
    ActionURL actionURL=portletResp.createActionURL();
    TestButton tb=new TestButton(V3RENDERSTATETESTS_SPEC2_12_MUTABLERENDERSTATE_SETWINDOWSTATE3,actionURL);
    tb.writeTo(writer);
  }
{
    ActionURL actionURL=portletResp.createActionURL();
    TestButton tb=new TestButton(V3RENDERSTATETESTS_SPEC2_12_MUTABLERENDERSTATE_SETWINDOWSTATE4,actionURL);
    tb.writeTo(writer);
  }
{
    ActionURL actionURL=portletResp.createActionURL();
    TestButton tb=new TestButton(V3RENDERSTATETESTS_SPEC2_12_MUTABLERENDERSTATE_SETWINDOWSTATE5,actionURL);
    tb.writeTo(writer);
  }
{
    ActionURL actionURL=portletResp.createActionURL();
    TestButton tb=new TestButton(V3RENDERSTATETESTS_SPEC2_12_MUTABLERENDERSTATE_SETWINDOWSTATE6,actionURL);
    tb.writeTo(writer);
  }
}",0.8984474885844749
90524,"/** 
 * Producer method for the resource parameters.
 */
@Produces @PortletRequestScoped @Named(""String_Node_Str"") public static ResourceParameters getResourceParameters(){
}","/** 
 * Producer method for the resource parameters.
 */
@Produces @PortletRequestScoped @Named(""String_Node_Str"") @Typed(ResourceParameters.class) public static ResourceParameters getResourceParameters(){
}",0.9133858267716536
90525,"/** 
 * Producer method for the action parameters.
 */
@Produces @PortletRequestScoped @Named(""String_Node_Str"") public static ActionParameters getActionParameters(){
}","/** 
 * Producer method for the action parameters.
 */
@Produces @PortletRequestScoped @Named(""String_Node_Str"") @Typed(ActionParameters.class) public static ActionParameters getActionParameters(){
}",0.9155313351498636
90526,"/** 
 * Producer method for the render paramters.
 */
@Produces @PortletRequestScoped @Named(""String_Node_Str"") public static RenderParameters getRenderParameters(){
}","/** 
 * Producer method for the render paramters.
 */
@Produces @PortletRequestScoped @Named(""String_Node_Str"") @Typed(RenderParameters.class) public static RenderParameters getRenderParameters(){
}",0.915068493150685
90527,"/** 
 * Producer method for the mutable render parameters.
 */
@Produces @PortletRequestScoped @Named(""String_Node_Str"") public static MutableRenderParameters getMutableRenderParameters(){
}","/** 
 * Producer method for the mutable render parameters.
 */
@Produces @PortletRequestScoped @Named(""String_Node_Str"") @Typed(MutableRenderParameters.class) public static MutableRenderParameters getMutableRenderParameters(){
}",0.9090909090909092
90528,"@Override public void render(RenderRequest portletReq,RenderResponse portletResp) throws PortletException, IOException {
  long tid=Thread.currentThread().getId();
  portletReq.setAttribute(THREADID_ATTR,tid);
  PrintWriter writer=portletResp.getWriter();
  Map<String,String[]> oldmap=new HashMap<String,String[]>();
  for (  String name : portletReq.getParameterMap().keySet()) {
    String[] vals=portletReq.getParameterValues(name);
    vals=(vals == null) ? null : vals.clone();
    oldmap.put(name,vals);
  }
  String target=JSP_PREFIX + ""String_Node_Str"" + JSP_SUFFIX+ ""String_Node_Str""+ QUERY_STRING;
  PortletRequestDispatcher rd=portletConfig.getPortletContext().getRequestDispatcher(target);
  rd.forward(portletReq,portletResp);
  Map<String,String[]> newmap=new HashMap<String,String[]>();
  for (  String name : portletReq.getParameterMap().keySet()) {
    String[] vals=portletReq.getParameterValues(name);
    vals=(vals == null) ? null : vals.clone();
    newmap.put(name,vals);
  }
  JSR286DispatcherTestCaseDetails tcd=new JSR286DispatcherTestCaseDetails();
  TestResult tr0=tcd.getTestResultFailed(V2DISPATCHERTESTS3S_SPEC2_19_FORWARDJSPRENDER_DISPATCH4);
  CompareUtils.mapsEqual(""String_Node_Str"",oldmap,""String_Node_Str"",newmap,tr0);
  tr0.writeTo(writer);
}","@Override public void render(RenderRequest portletReq,RenderResponse portletResp) throws PortletException, IOException {
  long tid=Thread.currentThread().getId();
  portletReq.setAttribute(THREADID_ATTR,tid);
  String msg=(String)portletReq.getPortletSession().getAttribute(RESULT_ATTR_PREFIX + V2DISPATCHERTESTS3S_SPEC2_19_FORWARDJSPRENDER_DISPATCH4,APPLICATION_SCOPE);
  if (msg != null) {
    PrintWriter writer=portletResp.getWriter();
    writer.write(msg);
    portletReq.getPortletSession().removeAttribute(RESULT_ATTR_PREFIX + V2DISPATCHERTESTS3S_SPEC2_19_FORWARDJSPRENDER_DISPATCH4,APPLICATION_SCOPE);
  }
 else {
    StringWriter writer=new StringWriter();
    Map<String,String[]> oldmap=new HashMap<String,String[]>();
    for (    String name : portletReq.getParameterMap().keySet()) {
      String[] vals=portletReq.getParameterValues(name);
      vals=(vals == null) ? null : vals.clone();
      oldmap.put(name,vals);
    }
    String target=JSP_PREFIX + ""String_Node_Str"" + JSP_SUFFIX+ ""String_Node_Str""+ QUERY_STRING;
    PortletRequestDispatcher rd=portletConfig.getPortletContext().getRequestDispatcher(target);
    rd.forward(portletReq,portletResp);
    Map<String,String[]> newmap=new HashMap<String,String[]>();
    for (    String name : portletReq.getParameterMap().keySet()) {
      String[] vals=portletReq.getParameterValues(name);
      vals=(vals == null) ? null : vals.clone();
      newmap.put(name,vals);
    }
    JSR286DispatcherTestCaseDetails tcd=new JSR286DispatcherTestCaseDetails();
    TestResult tr0=tcd.getTestResultFailed(V2DISPATCHERTESTS3S_SPEC2_19_FORWARDJSPRENDER_DISPATCH4);
    CompareUtils.mapsEqual(""String_Node_Str"",oldmap,""String_Node_Str"",newmap,tr0);
    tr0.writeTo(writer);
    portletReq.getPortletSession().setAttribute(Constants.RESULT_ATTR_PREFIX + V2DISPATCHERTESTS3S_SPEC2_19_FORWARDJSPRENDER_DISPATCH4,writer.toString(),APPLICATION_SCOPE);
  }
}",0.7992483557782649
90529,"@Override public void render(RenderRequest portletReq,RenderResponse portletResp) throws PortletException, IOException {
  PrintWriter writer=portletResp.getWriter();
  String msg=(String)portletReq.getPortletSession().getAttribute(RESULT_ATTR_PREFIX + V2DISPATCHERTESTS3S_SPEC2_19_FORWARDJSPRESOURCE_DISPATCH4,APPLICATION_SCOPE);
  if (msg == null) {
    writer.write(""String_Node_Str"");
    PortletURL purl=portletResp.createRenderURL();
    TestLink tl=new TestLink(V2DISPATCHERTESTS3S_SPEC2_19_FORWARDJSPRESOURCE_DISPATCH4,purl);
    tl.writeTo(writer);
    writer.write(""String_Node_Str"");
    ResourceURL resurl=portletResp.createResourceURL();
    resurl.setCacheability(PAGE);
    writer.write(""String_Node_Str"");
    writer.write(""String_Node_Str"");
    writer.write(""String_Node_Str"");
    writer.write(""String_Node_Str"");
    writer.write(""String_Node_Str"");
    writer.write(""String_Node_Str"");
    writer.write(""String_Node_Str"");
    writer.write(""String_Node_Str"");
    writer.write(""String_Node_Str"" + resurl.toString() + ""String_Node_Str"");
    writer.write(""String_Node_Str"");
    writer.write(""String_Node_Str"");
    writer.write(""String_Node_Str"");
  }
 else {
    portletReq.getPortletSession().removeAttribute(RESULT_ATTR_PREFIX + V2DISPATCHERTESTS3S_SPEC2_19_FORWARDJSPRESOURCE_DISPATCH4,APPLICATION_SCOPE);
    writer.write(""String_Node_Str"" + msg + ""String_Node_Str"");
  }
}","@Override public void render(RenderRequest portletReq,RenderResponse portletResp) throws PortletException, IOException {
  PrintWriter writer=portletResp.getWriter();
  String msg=(String)portletReq.getPortletSession().getAttribute(RESULT_ATTR_PREFIX + V2DISPATCHERTESTS3S_SPEC2_19_FORWARDJSPRESOURCE_DISPATCH4,APPLICATION_SCOPE);
  if (msg == null) {
    writer.write(""String_Node_Str"");
    writer.write(""String_Node_Str"");
    ResourceURL resurl=portletResp.createResourceURL();
    resurl.setCacheability(PAGE);
    writer.write(""String_Node_Str"");
    writer.write(""String_Node_Str"");
    writer.write(""String_Node_Str"");
    writer.write(""String_Node_Str"");
    writer.write(""String_Node_Str"");
    writer.write(""String_Node_Str"");
    writer.write(""String_Node_Str"");
    writer.write(""String_Node_Str"");
    writer.write(""String_Node_Str"" + resurl.toString() + ""String_Node_Str"");
    writer.write(""String_Node_Str"");
    writer.write(""String_Node_Str"");
    writer.write(""String_Node_Str"");
  }
 else {
    portletReq.getPortletSession().removeAttribute(RESULT_ATTR_PREFIX + V2DISPATCHERTESTS3S_SPEC2_19_FORWARDJSPRESOURCE_DISPATCH4,APPLICATION_SCOPE);
    writer.write(""String_Node_Str"" + msg + ""String_Node_Str"");
  }
}",0.4404716622289844
90530,"@Override public void processAction(ActionRequest portletReq,ActionResponse portletResp) throws PortletException, IOException {
  portletResp.setRenderParameters(portletReq.getParameterMap());
  long tid=Thread.currentThread().getId();
  portletReq.setAttribute(THREADID_ATTR,tid);
  new StringWriter();
}","@Override public void processAction(ActionRequest portletReq,ActionResponse portletResp) throws PortletException, IOException {
  portletResp.setRenderParameters(portletReq.getParameterMap());
  long tid=Thread.currentThread().getId();
  portletReq.setAttribute(THREADID_ATTR,tid);
}",0.9625850340136054
90531,"@Override public void render(RenderRequest portletReq,RenderResponse portletResp) throws PortletException, IOException {
  PrintWriter writer=portletResp.getWriter();
  String msg=(String)portletReq.getPortletSession().getAttribute(RESULT_ATTR_PREFIX + V2DISPATCHERTESTS3S_SPEC2_19_FORWARDSERVLETRESOURCE_DISPATCH4,APPLICATION_SCOPE);
  if (msg == null) {
    writer.write(""String_Node_Str"");
    PortletURL purl=portletResp.createRenderURL();
    TestLink tl=new TestLink(V2DISPATCHERTESTS3S_SPEC2_19_FORWARDSERVLETRESOURCE_DISPATCH4,purl);
    tl.writeTo(writer);
    writer.write(""String_Node_Str"");
    ResourceURL resurl=portletResp.createResourceURL();
    resurl.setCacheability(PAGE);
    writer.write(""String_Node_Str"");
    writer.write(""String_Node_Str"");
    writer.write(""String_Node_Str"");
    writer.write(""String_Node_Str"");
    writer.write(""String_Node_Str"");
    writer.write(""String_Node_Str"");
    writer.write(""String_Node_Str"");
    writer.write(""String_Node_Str"");
    writer.write(""String_Node_Str"" + resurl.toString() + ""String_Node_Str"");
    writer.write(""String_Node_Str"");
    writer.write(""String_Node_Str"");
    writer.write(""String_Node_Str"");
  }
 else {
    portletReq.getPortletSession().removeAttribute(RESULT_ATTR_PREFIX + V2DISPATCHERTESTS3S_SPEC2_19_FORWARDSERVLETRESOURCE_DISPATCH4,APPLICATION_SCOPE);
    writer.write(""String_Node_Str"" + msg + ""String_Node_Str"");
  }
}","@Override public void render(RenderRequest portletReq,RenderResponse portletResp) throws PortletException, IOException {
  PrintWriter writer=portletResp.getWriter();
  String msg=(String)portletReq.getPortletSession().getAttribute(RESULT_ATTR_PREFIX + V2DISPATCHERTESTS3S_SPEC2_19_FORWARDSERVLETRESOURCE_DISPATCH4,APPLICATION_SCOPE);
  if (msg == null) {
    writer.write(""String_Node_Str"");
    writer.write(""String_Node_Str"");
    ResourceURL resurl=portletResp.createResourceURL();
    resurl.setCacheability(PAGE);
    writer.write(""String_Node_Str"");
    writer.write(""String_Node_Str"");
    writer.write(""String_Node_Str"");
    writer.write(""String_Node_Str"");
    writer.write(""String_Node_Str"");
    writer.write(""String_Node_Str"");
    writer.write(""String_Node_Str"");
    writer.write(""String_Node_Str"");
    writer.write(""String_Node_Str"" + resurl.toString() + ""String_Node_Str"");
    writer.write(""String_Node_Str"");
    writer.write(""String_Node_Str"");
    writer.write(""String_Node_Str"");
  }
 else {
    portletReq.getPortletSession().removeAttribute(RESULT_ATTR_PREFIX + V2DISPATCHERTESTS3S_SPEC2_19_FORWARDSERVLETRESOURCE_DISPATCH4,APPLICATION_SCOPE);
    writer.write(""String_Node_Str"" + msg + ""String_Node_Str"");
  }
}",0.4431861079652699
90532,"protected void processTCKReq(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException {
  PortletRequest portletReq=(PortletRequest)request.getAttribute(""String_Node_Str"");
  request.getAttribute(""String_Node_Str"");
  request.getAttribute(""String_Node_Str"");
  Thread.currentThread().getId();
  portletReq.getAttribute(THREADID_ATTR);
  new StringWriter();
  new JSR286DispatcherTestCaseDetails();
}","protected void processTCKReq(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException {
  PortletRequest portletReq=(PortletRequest)request.getAttribute(""String_Node_Str"");
  request.getAttribute(""String_Node_Str"");
  request.getAttribute(""String_Node_Str"");
  Thread.currentThread().getId();
  portletReq.getAttribute(THREADID_ATTR);
}",0.9221260815822002
90533,"protected void processTCKReq(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException {
  PortletRequest portletReq=(PortletRequest)request.getAttribute(""String_Node_Str"");
  request.getAttribute(""String_Node_Str"");
  request.getAttribute(""String_Node_Str"");
  Thread.currentThread().getId();
  portletReq.getAttribute(THREADID_ATTR);
  new StringWriter();
  new JSR286DispatcherTestCaseDetails();
}","protected void processTCKReq(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException {
  PortletRequest portletReq=(PortletRequest)request.getAttribute(""String_Node_Str"");
  request.getAttribute(""String_Node_Str"");
  request.getAttribute(""String_Node_Str"");
  Thread.currentThread().getId();
  portletReq.getAttribute(THREADID_ATTR);
}",0.9221260815822002
90534,"protected void processTCKReq(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException {
  PortletRequest portletReq=(PortletRequest)request.getAttribute(""String_Node_Str"");
  PortletResponse portletResp=(PortletResponse)request.getAttribute(""String_Node_Str"");
  request.getAttribute(""String_Node_Str"");
  Thread.currentThread().getId();
  portletReq.getAttribute(THREADID_ATTR);
  ((MimeResponse)portletResp).getWriter();
  new JSR286DispatcherTestCaseDetails();
}","protected void processTCKReq(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException {
  PortletResponse portletResp=(PortletResponse)request.getAttribute(""String_Node_Str"");
  PrintWriter writer=((MimeResponse)portletResp).getWriter();
  PortletURL purl=((MimeResponse)portletResp).createRenderURL();
  TestLink tl=new TestLink(V2DISPATCHERTESTS3S_SPEC2_19_FORWARDSERVLETRENDER_DISPATCH4,purl);
  tl.writeTo(writer);
}",0.4796663190823775
90535,"protected void processTCKReq(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException {
  PortletRequest portletReq=(PortletRequest)request.getAttribute(""String_Node_Str"");
  PortletResponse portletResp=(PortletResponse)request.getAttribute(""String_Node_Str"");
  request.getAttribute(""String_Node_Str"");
  Thread.currentThread().getId();
  portletReq.getAttribute(THREADID_ATTR);
  ((MimeResponse)portletResp).getWriter();
  new JSR286DispatcherTestCaseDetails();
}","protected void processTCKReq(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException {
  PortletRequest portletReq=(PortletRequest)request.getAttribute(""String_Node_Str"");
  PortletResponse portletResp=(PortletResponse)request.getAttribute(""String_Node_Str"");
  request.getAttribute(""String_Node_Str"");
  Thread.currentThread().getId();
  portletReq.getAttribute(THREADID_ATTR);
  PrintWriter writer=((MimeResponse)portletResp).getWriter();
  PortletURL purl=((MimeResponse)portletResp).createRenderURL();
  TestLink tl=new TestLink(V2DISPATCHERTESTS3S_SPEC2_19_FORWARDSERVLETRESOURCE_DISPATCH4,purl);
  tl.writeTo(writer);
}",0.8137339055793992
90536,"protected void processTCKReq(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException {
  PortletRequest portletReq=(PortletRequest)request.getAttribute(""String_Node_Str"");
  request.getAttribute(""String_Node_Str"");
  request.getAttribute(""String_Node_Str"");
  Thread.currentThread().getId();
  portletReq.getAttribute(THREADID_ATTR);
  new StringWriter();
  new JSR286DispatcherTestCaseDetails();
}","protected void processTCKReq(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException {
  PortletRequest portletReq=(PortletRequest)request.getAttribute(""String_Node_Str"");
  request.getAttribute(""String_Node_Str"");
  request.getAttribute(""String_Node_Str"");
  Thread.currentThread().getId();
  portletReq.getAttribute(THREADID_ATTR);
}",0.9221260815822002
90537,"protected void processTCKReq(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException {
  PortletRequest portletReq=(PortletRequest)request.getAttribute(""String_Node_Str"");
  request.getAttribute(""String_Node_Str"");
  request.getAttribute(""String_Node_Str"");
  Thread.currentThread().getId();
  portletReq.getAttribute(THREADID_ATTR);
  new StringWriter();
  new JSR286DispatcherTestCaseDetails();
}","protected void processTCKReq(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException {
  PortletRequest portletReq=(PortletRequest)request.getAttribute(""String_Node_Str"");
  request.getAttribute(""String_Node_Str"");
  request.getAttribute(""String_Node_Str"");
  Thread.currentThread().getId();
  portletReq.getAttribute(THREADID_ATTR);
}",0.9221260815822002
90538,"protected void processTCKReq(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException {
  PortletRequest portletReq=(PortletRequest)request.getAttribute(""String_Node_Str"");
  PortletResponse portletResp=(PortletResponse)request.getAttribute(""String_Node_Str"");
  request.getAttribute(""String_Node_Str"");
  Thread.currentThread().getId();
  portletReq.getAttribute(THREADID_ATTR);
  ((MimeResponse)portletResp).getWriter();
  new JSR286DispatcherTestCaseDetails();
}","protected void processTCKReq(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException {
  PortletRequest portletReq=(PortletRequest)request.getAttribute(""String_Node_Str"");
  request.getAttribute(""String_Node_Str"");
  request.getAttribute(""String_Node_Str"");
  Thread.currentThread().getId();
  portletReq.getAttribute(THREADID_ATTR);
  new JSR286DispatcherTestCaseDetails();
}",0.9039301310043668
90539,"@Override public int doStartTag() throws JspException {
  Object obj=pageContext.getRequest().getAttribute(Constants.PORTLET_RESPONSE);
  if ((obj == null) || !(obj instanceof MimeResponse)) {
    throw new JspException(""String_Node_Str"");
  }
  MimeResponse resp=(MimeResponse)obj;
  ActionURL aurl=null;
  if (getCopyCurrentRenderParameters() == true) {
    aurl=resp.createActionURL(Copy.ALL);
  }
 else {
    aurl=resp.createActionURL(Copy.NONE);
  }
  rparams=aurl.getRenderParameters();
  aparams=aurl.getActionParameters();
  setUrl(aurl);
  handlePMandWS();
  handleDefaultEscapeXML();
  handleSecureFlag();
  return EVAL_BODY_INCLUDE;
}","@Override public int doStartTag() throws JspException {
  Object obj=pageContext.getRequest().getAttribute(Constants.PORTLET_RESPONSE);
  if ((obj == null) || !(obj instanceof MimeResponse)) {
    throw new JspException(""String_Node_Str"");
  }
  MimeResponse resp=(MimeResponse)obj;
  ActionURL aurl=null;
  if (isCopyCurrentRenderParameters() == true) {
    aurl=resp.createActionURL(Copy.ALL);
  }
 else {
    aurl=resp.createActionURL(Copy.NONE);
  }
  rparams=aurl.getRenderParameters();
  aparams=aurl.getActionParameters();
  setUrl(aurl);
  handlePMandWS();
  handleDefaultEscapeXML();
  handleSecureFlag();
  return EVAL_BODY_INCLUDE;
}",0.9961210240496507
90540,"/** 
 * Sets the escapeXml property.
 * @param escapeXml
 * @return void
 */
public void setEscapeXml(Boolean escapeXml){
  this.escapeXml=escapeXml;
}","/** 
 * Sets the escapeXml property.
 * @param escapeXml
 * @return void
 */
public void setEscapeXml(String escapeXml){
  this.escapeXml=escapeXml;
}",0.9634551495016612
90541,"/** 
 * Sets the secure flag on the URl as required
 * @throws JspException
 */
protected void handleSecureFlag() throws JspException {
  BaseURL url=getUrl();
  if (url == null) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  if (var != null) {
    pageContext.removeAttribute(var,PageContext.PAGE_SCOPE);
  }
  if (secure != null) {
    try {
      url.setSecure(getSecureBoolean());
    }
 catch (    PortletSecurityException e) {
    }
  }
}","/** 
 * Sets the secure flag on the URl as required
 * @throws JspException
 */
protected void handleSecureFlag() throws JspException {
  BaseURL url=getUrl();
  if (secure != null && !secure.equalsIgnoreCase(""String_Node_Str"") && !secure.equalsIgnoreCase(""String_Node_Str"")) {
    StringBuilder txt=new StringBuilder(128);
    txt.append(""String_Node_Str"").append(secure);
    txt.append(""String_Node_Str"");
    throw new JspException(txt.toString());
  }
  if (url == null) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  if (var != null) {
    pageContext.removeAttribute(var,PageContext.PAGE_SCOPE);
  }
  if (secure != null) {
    try {
      url.setSecure(isSecure());
    }
 catch (    PortletSecurityException e) {
    }
  }
}",0.7349298100743188
90542,"@Override public int doEndTag() throws JspException {
  BaseURL url=getUrl();
  if (url == null) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  setUrlParameters(url);
  setUrlProperties(url);
  HttpServletResponse response=(HttpServletResponse)pageContext.getResponse();
  String urlString=response.encodeURL(url.toString());
  if (escapeXml) {
    urlString=doEscapeXml(urlString);
  }
  if (var == null) {
    try {
      JspWriter writer=pageContext.getOut();
      writer.print(urlString);
    }
 catch (    IOException ioe) {
      throw new JspException(""String_Node_Str"");
    }
  }
 else {
    pageContext.setAttribute(var,urlString,PageContext.PAGE_SCOPE);
  }
  propertiesMap.clear();
  parametersMap.clear();
  removedParametersList.clear();
  setUrl(null);
  return EVAL_PAGE;
}","@Override public int doEndTag() throws JspException {
  BaseURL url=getUrl();
  if (url == null) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  setUrlParameters(url);
  setUrlProperties(url);
  HttpServletResponse response=(HttpServletResponse)pageContext.getResponse();
  String urlString=response.encodeURL(url.toString());
  if (Boolean.parseBoolean(escapeXml)) {
    urlString=doEscapeXml(urlString);
  }
  if (var == null) {
    try {
      JspWriter writer=pageContext.getOut();
      writer.print(urlString);
    }
 catch (    IOException ioe) {
      throw new JspException(""String_Node_Str"");
    }
  }
 else {
    pageContext.setAttribute(var,urlString,PageContext.PAGE_SCOPE);
  }
  propertiesMap.clear();
  parametersMap.clear();
  removedParametersList.clear();
  setUrl(null);
  return EVAL_PAGE;
}",0.9865525672371638
90543,"@Override public int doStartTag() throws JspException {
  handleSecureFlag();
  return EVAL_BODY_INCLUDE;
}","@Override public int doStartTag() throws JspException {
  handleSecureFlag();
  if (escapeXml != null && !escapeXml.equalsIgnoreCase(""String_Node_Str"") && !escapeXml.equalsIgnoreCase(""String_Node_Str"")) {
    StringBuilder txt=new StringBuilder(128);
    txt.append(""String_Node_Str"").append(escapeXml);
    txt.append(""String_Node_Str"");
    throw new JspException(txt.toString());
  }
  return EVAL_BODY_INCLUDE;
}",0.4091778202676864
90544,"/** 
 * Returns escapeXml property.
 * @return Boolean
 */
public Boolean getEscapeXml(){
  return escapeXml;
}","/** 
 * Returns escapeXml property.
 * @return Boolean
 */
public String getEscapeXml(){
  return escapeXml;
}",0.9502262443438914
90545,"@Override public int doStartTag() throws JspException {
  handleDefaultEscapeXML();
  return super.doStartTag();
}","@Override public int doStartTag() throws JspException {
  handleDefaultEscapeXML();
  if (copyCurrentRenderParameters != null && !copyCurrentRenderParameters.equalsIgnoreCase(""String_Node_Str"") && !copyCurrentRenderParameters.equalsIgnoreCase(""String_Node_Str"")) {
    StringBuilder txt=new StringBuilder(128);
    txt.append(""String_Node_Str"").append(copyCurrentRenderParameters);
    txt.append(""String_Node_Str"");
    throw new JspException(txt.toString());
  }
  return super.doStartTag();
}",0.3743842364532019
90546,"/** 
 * Sets copyCurrentRenderParameters property.
 * @param copyCurrentRenderParameters
 * @return void
 */
public void setCopyCurrentRenderParameters(Boolean copyCurrentRenderParameters){
  this.copyCurrentRenderParameters=copyCurrentRenderParameters;
}","/** 
 * Sets copyCurrentRenderParameters property.
 * @param copyCurrentRenderParameters
 * @return void
 */
public void setCopyCurrentRenderParameters(String copyCurrentRenderParameters){
  this.copyCurrentRenderParameters=copyCurrentRenderParameters;
}",0.974459724950884
90547,"public PortletURLTag286(){
  super();
  this.escapeXml=true;
}","public PortletURLTag286(){
  super();
  setEscapeXml(Boolean.TRUE.toString());
}",0.7605633802816901
90548,"protected void handleDefaultEscapeXML(){
  PortletConfig portletConfig=(PortletConfig)pageContext.getRequest().getAttribute(Constants.PORTLET_CONFIG);
  Map<String,String[]> containerRuntimeOptions=portletConfig.getContainerRuntimeOptions();
  if (containerRuntimeOptions != null) {
    String[] result=containerRuntimeOptions.get(Constants.ESCAPE_XML_RUNTIME_OPTION);
    if (result != null) {
      if (result.length > 0) {
        escapeXml=Boolean.parseBoolean(result[0]);
      }
    }
  }
}","protected void handleDefaultEscapeXML(){
  PortletConfig portletConfig=(PortletConfig)pageContext.getRequest().getAttribute(Constants.PORTLET_CONFIG);
  Map<String,String[]> containerRuntimeOptions=portletConfig.getContainerRuntimeOptions();
  if (containerRuntimeOptions != null) {
    String[] result=containerRuntimeOptions.get(Constants.ESCAPE_XML_RUNTIME_OPTION);
    if (result != null) {
      if (result.length > 0) {
        setEscapeXml(result[0]);
      }
    }
  }
}",0.973305954825462
90549,"/** 
 * Returns the copyCurrentRenderParameters property.
 * @return Boolean
 */
public Boolean getCopyCurrentRenderParameters(){
  return copyCurrentRenderParameters;
}","/** 
 * Returns the copyCurrentRenderParameters property.
 * @return Boolean
 */
public String getCopyCurrentRenderParameters(){
  return copyCurrentRenderParameters;
}",0.9673590504451038
90550,"@Override public int doEndTag() throws JspException {
  if (copyCurrentRenderParameters) {
    doCopyCurrentRenderParameters();
  }
  return super.doEndTag();
}","@Override public int doEndTag() throws JspException {
  if (Boolean.parseBoolean(copyCurrentRenderParameters)) {
    doCopyCurrentRenderParameters();
  }
  return super.doEndTag();
}",0.935672514619883
90551,"@Override public int doStartTag() throws JspException {
  Object obj=pageContext.getRequest().getAttribute(Constants.PORTLET_RESPONSE);
  if ((obj == null) || !(obj instanceof MimeResponse)) {
    throw new JspException(""String_Node_Str"");
  }
  MimeResponse resp=(MimeResponse)obj;
  RenderURL rurl=null;
  if (getCopyCurrentRenderParameters() == true) {
    rurl=resp.createRenderURL(Copy.ALL);
  }
 else {
    rurl=resp.createRenderURL(Copy.NONE);
  }
  params=rurl.getRenderParameters();
  setUrl(rurl);
  handlePMandWS();
  handleDefaultEscapeXML();
  handleSecureFlag();
  return EVAL_BODY_INCLUDE;
}","@Override public int doStartTag() throws JspException {
  Object obj=pageContext.getRequest().getAttribute(Constants.PORTLET_RESPONSE);
  if ((obj == null) || !(obj instanceof MimeResponse)) {
    throw new JspException(""String_Node_Str"");
  }
  MimeResponse resp=(MimeResponse)obj;
  RenderURL rurl=null;
  if (isCopyCurrentRenderParameters() == true) {
    rurl=resp.createRenderURL(Copy.ALL);
  }
 else {
    rurl=resp.createRenderURL(Copy.NONE);
  }
  params=rurl.getRenderParameters();
  setUrl(rurl);
  handlePMandWS();
  handleDefaultEscapeXML();
  handleSecureFlag();
  return EVAL_BODY_INCLUDE;
}",0.9958711808422792
90552,"/** 
 * Fire Event for the portlet associated with the given portlet window and eventName
 * @param portletWindow  the portlet window.
 * @param request  the servlet request.
 * @param response  the servlet response.
 * @param event the event
 * @throws PortletException
 * @throws IOException
 * @throws PortletContainerException
 * @see javax.portlet.EventPortlet#processEvent(javax.portlet.EventRequest,javax.portlet.EventResponse)
 */
public void doEvent(PortletWindow portletWindow,HttpServletRequest request,HttpServletResponse response,Event event) throws PortletException, IOException, PortletContainerException {
  ensureInitialized();
  debugWithName(""String_Node_Str"" + event.getName() + ""String_Node_Str""+ portletWindow.getPortletDefinition().getPortletName());
  PortletRequestContextService rcService=getContainerServices().getPortletRequestContextService();
  PortletEnvironmentService envService=getContainerServices().getPortletEnvironmentService();
  PortletInvokerService invoker=getContainerServices().getPortletInvokerService();
  PortletRequestContext requestContext=rcService.getPortletEventRequestContext(this,request,response,portletWindow);
  PortletEventResponseContext responseContext=rcService.getPortletEventResponseContext(this,request,response,portletWindow,requestContext);
  EventRequest portletRequest=envService.createEventRequest(requestContext,responseContext,event);
  EventResponse portletResponse=envService.createEventResponse(responseContext);
  FilterManager filterManager=filterInitialisation(portletWindow,PortletRequest.EVENT_PHASE);
  List<Event> events=null;
  try {
    invoker.event(requestContext,portletRequest,portletResponse,filterManager);
    debugWithName(""String_Node_Str"" + portletWindow.getPortletDefinition().getPortletName());
    responseContext.close();
    events=responseContext.getEvents();
  }
  finally {
    responseContext.release();
  }
  if (events != null && !events.isEmpty()) {
    getContainerServices().getEventCoordinationService().processEvents(this,portletWindow,request,response,events);
  }
  debugWithName(""String_Node_Str"" + event.getName() + ""String_Node_Str""+ portletWindow.getPortletDefinition().getPortletName());
}","/** 
 * Fire Event for the portlet associated with the given portlet window and eventName
 * @param portletWindow  the portlet window.
 * @param request  the servlet request.
 * @param response  the servlet response.
 * @param event the event
 * @throws PortletException
 * @throws IOException
 * @throws PortletContainerException
 * @see javax.portlet.EventPortlet#processEvent(javax.portlet.EventRequest,javax.portlet.EventResponse)
 */
public void doEvent(PortletWindow portletWindow,HttpServletRequest request,HttpServletResponse response,Event event) throws PortletException, IOException, PortletContainerException {
  ensureInitialized();
  debugWithName(""String_Node_Str"" + event.getName() + ""String_Node_Str""+ portletWindow.getPortletDefinition().getPortletName());
  PortletRequestContextService rcService=getContainerServices().getPortletRequestContextService();
  PortletEnvironmentService envService=getContainerServices().getPortletEnvironmentService();
  PortletInvokerService invoker=getContainerServices().getPortletInvokerService();
  PortletRequestContext requestContext=rcService.getPortletEventRequestContext(this,request,response,portletWindow);
  PortletEventResponseContext responseContext=rcService.getPortletEventResponseContext(this,request,response,portletWindow,requestContext);
  EventRequest portletRequest=envService.createEventRequest(requestContext,responseContext,event);
  EventResponse portletResponse=envService.createEventResponse(responseContext);
  FilterManager filterManager=filterInitialisation(portletWindow,PortletRequest.EVENT_PHASE);
  List<Event> events=null;
  try {
    invoker.event(requestContext,portletRequest,portletResponse,filterManager);
    debugWithName(""String_Node_Str"" + portletWindow.getPortletDefinition().getPortletName());
    responseContext.close();
    events=responseContext.getEvents();
  }
 catch (  Throwable t) {
    responseContext.reset();
    StringBuilder txt=new StringBuilder(128);
    txt.append(""String_Node_Str"");
    StringWriter sw=new StringWriter();
    PrintWriter pw=new PrintWriter(sw);
    t.printStackTrace(pw);
    pw.flush();
    txt.append(sw.toString());
    LOG.warn(txt.toString());
  }
 finally {
    responseContext.release();
  }
  if (events != null && !events.isEmpty()) {
    getContainerServices().getEventCoordinationService().processEvents(this,portletWindow,request,response,events);
  }
  debugWithName(""String_Node_Str"" + event.getName() + ""String_Node_Str""+ portletWindow.getPortletDefinition().getPortletName());
}",0.9319526627218936
90553,"/** 
 * Process action for the portlet associated with the given portlet window.
 * @param portletWindow  the portlet window.
 * @param request      the servlet request.
 * @param response     the servlet response.
 * @param isRedirect   Flag indicating whether redirect is to be performed. should be true for Action request and false for Ajax Action or  Partial Action requests.
 * @throws PortletException
 * @throws IOException
 * @throws PortletContainerException
 * @see javax.portlet.Portlet#processAction(ActionRequest,ActionResponse)
 */
public void doAction(PortletWindow portletWindow,HttpServletRequest request,HttpServletResponse response,boolean isRedirect) throws PortletException, IOException, PortletContainerException {
  ensureInitialized();
  debugWithName(""String_Node_Str"" + portletWindow.getPortletDefinition().getPortletName());
  PortletRequestContextService rcService=getContainerServices().getPortletRequestContextService();
  PortletEnvironmentService envService=getContainerServices().getPortletEnvironmentService();
  PortletInvokerService invoker=getContainerServices().getPortletInvokerService();
  PortletRequestContext requestContext=rcService.getPortletActionRequestContext(this,request,response,portletWindow);
  PortletActionResponseContext responseContext=rcService.getPortletActionResponseContext(this,request,response,portletWindow,requestContext);
  responseContext.setPropsAllowed(true);
  ActionRequest portletRequest=envService.createActionRequest(requestContext,responseContext);
  ActionResponse portletResponse=envService.createActionResponse(responseContext);
  FilterManager filterManager=filterInitialisation(portletWindow,PortletRequest.ACTION_PHASE);
  String location=null;
  String logtxt=""String_Node_Str"";
  if (!isRedirect) {
    logtxt=""String_Node_Str"";
  }
  try {
    invoker.action(requestContext,portletRequest,portletResponse,filterManager);
    debugWithName(logtxt + ""String_Node_Str"" + portletWindow.getPortletDefinition().getPortletName());
    responseContext.close();
    if (!responseContext.isRedirect()) {
      List<Event> events=responseContext.getEvents();
      if (!events.isEmpty()) {
        getContainerServices().getEventCoordinationService().processEvents(this,portletWindow,request,response,events);
      }
    }
    location=response.encodeRedirectURL(responseContext.getResponseURL());
  }
  finally {
    responseContext.release();
  }
  if (isRedirect) {
    redirect(request,response,location);
  }
  debugWithName(logtxt + ""String_Node_Str"" + portletWindow.getPortletDefinition().getPortletName());
}","/** 
 * Process action for the portlet associated with the given portlet window.
 * @param portletWindow  the portlet window.
 * @param request      the servlet request.
 * @param response     the servlet response.
 * @param isRedirect   Flag indicating whether redirect is to be performed. should be true for Action request and false for Ajax Action or  Partial Action requests.
 * @throws PortletException
 * @throws IOException
 * @throws PortletContainerException
 * @see javax.portlet.Portlet#processAction(ActionRequest,ActionResponse)
 */
public void doAction(PortletWindow portletWindow,HttpServletRequest request,HttpServletResponse response,boolean isRedirect) throws PortletException, IOException, PortletContainerException {
  ensureInitialized();
  debugWithName(""String_Node_Str"" + portletWindow.getPortletDefinition().getPortletName());
  PortletRequestContextService rcService=getContainerServices().getPortletRequestContextService();
  PortletEnvironmentService envService=getContainerServices().getPortletEnvironmentService();
  PortletInvokerService invoker=getContainerServices().getPortletInvokerService();
  PortletRequestContext requestContext=rcService.getPortletActionRequestContext(this,request,response,portletWindow);
  PortletActionResponseContext responseContext=rcService.getPortletActionResponseContext(this,request,response,portletWindow,requestContext);
  responseContext.setPropsAllowed(true);
  ActionRequest portletRequest=envService.createActionRequest(requestContext,responseContext);
  ActionResponse portletResponse=envService.createActionResponse(responseContext);
  FilterManager filterManager=filterInitialisation(portletWindow,PortletRequest.ACTION_PHASE);
  String location=null;
  String logtxt=""String_Node_Str"";
  if (!isRedirect) {
    logtxt=""String_Node_Str"";
  }
  try {
    invoker.action(requestContext,portletRequest,portletResponse,filterManager);
    debugWithName(logtxt + ""String_Node_Str"" + portletWindow.getPortletDefinition().getPortletName());
    responseContext.close();
    if (!responseContext.isRedirect()) {
      List<Event> events=responseContext.getEvents();
      if (!events.isEmpty()) {
        getContainerServices().getEventCoordinationService().processEvents(this,portletWindow,request,response,events);
      }
    }
  }
 catch (  Throwable t) {
    responseContext.reset();
    StringBuilder txt=new StringBuilder(128);
    txt.append(""String_Node_Str"");
    StringWriter sw=new StringWriter();
    PrintWriter pw=new PrintWriter(sw);
    t.printStackTrace(pw);
    pw.flush();
    txt.append(sw.toString());
    LOG.warn(txt.toString());
  }
 finally {
    location=response.encodeRedirectURL(responseContext.getResponseURL());
    responseContext.release();
  }
  if (isRedirect) {
    redirect(request,response,location);
  }
  debugWithName(logtxt + ""String_Node_Str"" + portletWindow.getPortletDefinition().getPortletName());
}",0.935659760087241
90554,"private static void init(ServletContext servletContext){
  try {
    InputStream in=servletContext.getResourceAsStream(ResourceConfigReader.CONFIG_FILE);
    resourceConfig=ResourceConfigReader.getFactory().parse(in);
    resourceConfig.traceConfig();
  }
 catch (  Exception e) {
    throw new DriverConfigurationException(e);
  }
}","private static void init(ServletContext servletContext){
  try {
    InputStream in=servletContext.getResourceAsStream(ResourceConfigReader.CONFIG_FILE);
    resourceConfig=ResourceConfigReader.getFactory().parse(in);
    resourceConfig.initialized();
  }
 catch (  Exception e) {
    throw new DriverConfigurationException(e);
  }
}",0.9669669669669668
90555,"public void addResource(PageResourceId id,Type type,String source){
  if (id.getName() != null && id.getScope() != null && type != null && id.getVersion() != null && source != null) {
    resources.put(id,new Source(type,source));
  }
 else {
    StringBuilder txt=new StringBuilder(128);
    txt.append(""String_Node_Str"");
    txt.append(""String_Node_Str"").append(id.toString());
    txt.append(""String_Node_Str"").append((type == null) ? ""String_Node_Str"" : type.toString());
    txt.append(""String_Node_Str"").append(source);
    LOG.warn(txt.toString());
  }
  if (isDebug) {
    StringBuilder txt=new StringBuilder(128);
    txt.append(""String_Node_Str"");
    txt.append(""String_Node_Str"").append(id.toString());
    txt.append(""String_Node_Str"").append((type == null) ? ""String_Node_Str"" : type.toString());
    txt.append(""String_Node_Str"").append(source);
    LOG.debug(txt.toString());
  }
}","/** 
 * adds a resource
 */
public void addResource(PageResourceId id,Type type,String source){
  if (id.getName() != null && id.getScope() != null && type != null && id.getVersion() != null && source != null) {
    resources.put(id,new Source(type,source));
  }
 else {
    StringBuilder txt=new StringBuilder(128);
    txt.append(""String_Node_Str"");
    txt.append(""String_Node_Str"").append(id.toString());
    txt.append(""String_Node_Str"").append((type == null) ? ""String_Node_Str"" : type.toString());
    txt.append(""String_Node_Str"").append(source);
    LOG.warn(txt.toString());
  }
  if (isDebug) {
    StringBuilder txt=new StringBuilder(128);
    txt.append(""String_Node_Str"");
    txt.append(""String_Node_Str"").append(id.toString());
    txt.append(""String_Node_Str"").append((type == null) ? ""String_Node_Str"" : type.toString());
    txt.append(""String_Node_Str"").append(source);
    LOG.debug(txt.toString());
  }
}",0.9846491228070176
90556,"@Override public void processAction(ActionRequest portletReq,ActionResponse portletResp) throws PortletException, IOException {
  LOGGER.entering(LOG_CLASS,""String_Node_Str"");
  portletResp.setRenderParameters(portletReq.getParameterMap());
  long tid=Thread.currentThread().getId();
  portletReq.setAttribute(THREADID_ATTR,tid);
  StringWriter writer=new StringWriter();
  JSR286SpecTestCaseDetails tcd=new JSR286SpecTestCaseDetails();
  TestResult tr0=tcd.getTestResultFailed(V2ADDLREQUESTTESTS_SPEC2_11_ACTIONREQ_CONTENTTYPE1);
  if (portletReq.getResponseContentType() != null && !portletReq.getResponseContentType().isEmpty())   tr0.setTcSuccess(true);
  tr0.writeTo(writer);
  TestResult tr1=tcd.getTestResultFailed(V2ADDLREQUESTTESTS_SPEC2_11_ACTIONREQ_CONTENTTYPE2);
  Enumeration<String> contentTypesTr1=portletReq.getResponseContentTypes();
  if (contentTypesTr1 != null && contentTypesTr1.hasMoreElements() && !contentTypesTr1.nextElement().isEmpty())   tr1.setTcSuccess(true);
  tr1.writeTo(writer);
  TestResult tr2=tcd.getTestResultFailed(V2ADDLREQUESTTESTS_SPEC2_11_ACTIONREQ_CONTENTTYPE3);
  if (portletReq.getResponseContentTypes().nextElement().equals(portletReq.getResponseContentType()))   tr2.setTcSuccess(true);
  tr2.writeTo(writer);
  TestResult tr3=tcd.getTestResultFailed(V2ADDLREQUESTTESTS_SPEC2_11_ACTIONREQ_CONTENTTYPE4);
  if (portletReq.getResponseContentType().equals(""String_Node_Str"")) {
    tr3.setTcSuccess(true);
  }
 else {
    tr3.appendTcDetail(""String_Node_Str"" + portletReq.getResponseContentType());
  }
  tr3.writeTo(writer);
  TestResult tr4=tcd.getTestResultFailed(V2ADDLREQUESTTESTS_SPEC2_11_ACTIONREQ_CONTENTTYPE5);
  if (portletReq.getResponseContentType().equals(""String_Node_Str"")) {
    tr4.setTcSuccess(true);
  }
 else {
    tr4.appendTcDetail(""String_Node_Str"" + portletReq.getResponseContentType());
  }
  tr4.writeTo(writer);
  TestResult tr5=tcd.getTestResultFailed(V2ADDLREQUESTTESTS_SPEC2_11_ACTIONREQ_WINDOWID4);
  String tr5SessionAttribute=(String)portletReq.getPortletSession().getAttribute(""String_Node_Str"" + portletReq.getWindowID() + ""String_Node_Str"",APPLICATION_SCOPE);
  if (tr5SessionAttribute != null && tr5SessionAttribute.equals(portletReq.getWindowID())) {
    tr5.setTcSuccess(true);
  }
 else {
    tr5.appendTcDetail(""String_Node_Str"" + portletReq.getWindowID() + ""String_Node_Str"");
  }
  tr5.writeTo(writer);
  TestResult tr6=tcd.getTestResultFailed(V2ADDLREQUESTTESTS_SPEC2_11_ACTIONREQ_CONTENTTYPE6);
  if (!StringUtils.containsIgnoreCase(portletReq.getResponseContentType(),portletReq.getCharacterEncoding()))   tr6.setTcSuccess(true);
  tr6.writeTo(writer);
  TestResult tr7=tcd.getTestResultFailed(V2ADDLREQUESTTESTS_SPEC2_11_ACTIONREQ_CONTENTTYPE7);
  Enumeration<String> contentTypesTr7=portletReq.getResponseContentTypes();
  if (contentTypesTr7.nextElement().equals(""String_Node_Str"") && !contentTypesTr7.hasMoreElements())   tr7.setTcSuccess(true);
  tr7.writeTo(writer);
  portletReq.getPortletSession().setAttribute(Constants.RESULT_ATTR_PREFIX + ""String_Node_Str"",writer.toString(),APPLICATION_SCOPE);
}","@Override public void processAction(ActionRequest portletReq,ActionResponse portletResp) throws PortletException, IOException {
  LOGGER.entering(LOG_CLASS,""String_Node_Str"");
  portletResp.setRenderParameters(portletReq.getParameterMap());
  long tid=Thread.currentThread().getId();
  portletReq.setAttribute(THREADID_ATTR,tid);
  StringWriter writer=new StringWriter();
  JSR286SpecTestCaseDetails tcd=new JSR286SpecTestCaseDetails();
  TestResult tr0=tcd.getTestResultFailed(V2ADDLREQUESTTESTS_SPEC2_11_ACTIONREQ_CONTENTTYPE1);
  if (portletReq.getResponseContentType() != null && !portletReq.getResponseContentType().isEmpty())   tr0.setTcSuccess(true);
  tr0.writeTo(writer);
  TestResult tr1=tcd.getTestResultFailed(V2ADDLREQUESTTESTS_SPEC2_11_ACTIONREQ_CONTENTTYPE2);
  Enumeration<String> contentTypesTr1=portletReq.getResponseContentTypes();
  if (contentTypesTr1 != null) {
    List<String> list=Collections.list(contentTypesTr1);
    if (list.isEmpty()) {
      tr1.appendTcDetail(""String_Node_Str"");
    }
 else {
      if (list.get(0).isEmpty()) {
        tr1.appendTcDetail(""String_Node_Str"");
      }
 else {
        tr1.setTcSuccess(true);
      }
    }
  }
 else {
    tr1.appendTcDetail(""String_Node_Str"");
  }
  tr1.writeTo(writer);
  TestResult tr2=tcd.getTestResultFailed(V2ADDLREQUESTTESTS_SPEC2_11_ACTIONREQ_CONTENTTYPE3);
  Enumeration<String> contentTypesTr2=portletReq.getResponseContentTypes();
  if (contentTypesTr2 != null) {
    List<String> list=Collections.list(contentTypesTr2);
    if (list.isEmpty()) {
      tr2.appendTcDetail(""String_Node_Str"");
    }
 else {
      if (!list.get(0).equals(portletReq.getResponseContentType())) {
        tr2.appendTcDetail(""String_Node_Str"");
      }
 else {
        tr2.setTcSuccess(true);
      }
    }
  }
 else {
    tr2.appendTcDetail(""String_Node_Str"");
  }
  tr2.writeTo(writer);
  TestResult tr3=tcd.getTestResultFailed(V2ADDLREQUESTTESTS_SPEC2_11_ACTIONREQ_CONTENTTYPE4);
  if (portletReq.getResponseContentType().equals(""String_Node_Str"")) {
    tr3.setTcSuccess(true);
  }
 else {
    tr3.appendTcDetail(""String_Node_Str"" + portletReq.getResponseContentType());
  }
  tr3.writeTo(writer);
  TestResult tr4=tcd.getTestResultFailed(V2ADDLREQUESTTESTS_SPEC2_11_ACTIONREQ_CONTENTTYPE5);
  if (portletReq.getResponseContentType().equals(""String_Node_Str"")) {
    tr4.setTcSuccess(true);
  }
 else {
    tr4.appendTcDetail(""String_Node_Str"" + portletReq.getResponseContentType());
  }
  tr4.writeTo(writer);
  TestResult tr5=tcd.getTestResultFailed(V2ADDLREQUESTTESTS_SPEC2_11_ACTIONREQ_WINDOWID4);
  String tr5SessionAttribute=(String)portletReq.getPortletSession().getAttribute(""String_Node_Str"" + portletReq.getWindowID() + ""String_Node_Str"",APPLICATION_SCOPE);
  if (tr5SessionAttribute != null && tr5SessionAttribute.equals(portletReq.getWindowID())) {
    tr5.setTcSuccess(true);
  }
 else {
    tr5.appendTcDetail(""String_Node_Str"" + portletReq.getWindowID() + ""String_Node_Str"");
  }
  tr5.writeTo(writer);
  TestResult tr6=tcd.getTestResultFailed(V2ADDLREQUESTTESTS_SPEC2_11_ACTIONREQ_CONTENTTYPE6);
  if (!StringUtils.containsIgnoreCase(portletReq.getResponseContentType(),portletReq.getCharacterEncoding()))   tr6.setTcSuccess(true);
  tr6.writeTo(writer);
  TestResult tr7=tcd.getTestResultFailed(V2ADDLREQUESTTESTS_SPEC2_11_ACTIONREQ_CONTENTTYPE7);
  Enumeration<String> contentTypesTr7=portletReq.getResponseContentTypes();
  if (contentTypesTr7.nextElement().equals(""String_Node_Str"") && !contentTypesTr7.hasMoreElements())   tr7.setTcSuccess(true);
  tr7.writeTo(writer);
  portletReq.getPortletSession().setAttribute(Constants.RESULT_ATTR_PREFIX + ""String_Node_Str"",writer.toString(),APPLICATION_SCOPE);
}",0.8635761589403973
90557,"/** 
 * checks if class name is valid by trying to load it. If the optional argument <code>assignable</code> is provided, the method will check if the class can be assigned.
 * @param clsName Class name string from configuration
 * @param assignable Interface to which the class should be assignable
 * @param msg Error message used when exception is thrown.
 */
protected void checkValidClass(String clsName,Class<?> assignable,String msg){
  StringBuilder txt=new StringBuilder(128);
  txt.append(msg).append(""String_Node_Str"");
  txt.append(clsName);
  if (!isValidIdentifier(clsName)) {
    txt.append(""String_Node_Str"");
    LOG.warn(txt.toString());
    throw new IllegalArgumentException(txt.toString());
  }
  Class<?> valClass=null;
  try {
    ClassLoader cl=Thread.currentThread().getContextClassLoader();
    if (cl == null) {
      cl=this.getClass().getClassLoader();
    }
    valClass=cl.loadClass(clsName);
    if (assignable != null && !assignable.isAssignableFrom(valClass)) {
      txt.append(""String_Node_Str"");
      txt.append(assignable.getCanonicalName());
      throw new Exception();
    }
  }
 catch (  Exception e) {
    LOG.warn(txt.toString());
    throw new IllegalArgumentException(txt.toString(),e);
  }
}","/** 
 * checks if class name is valid by trying to load it. If the optional argument <code>assignable</code> is provided, the method will check if the class can be assigned.
 * @param clsName Class name string from configuration
 * @param assignable Interface to which the class should be assignable
 * @param msg Error message used when exception is thrown.
 */
protected void checkValidClass(String clsName,Class<?> assignable,String msg){
  StringBuilder txt=new StringBuilder(128);
  txt.append(msg).append(""String_Node_Str"");
  txt.append(clsName);
  if (!isValidIdentifier(clsName)) {
    txt.append(""String_Node_Str"");
    LOG.warn(txt.toString());
    throw new IllegalArgumentException(txt.toString());
  }
  Class<?> valClass=null;
  try {
    ClassLoader cl=Thread.currentThread().getContextClassLoader();
    if (cl == null) {
      cl=this.getClass().getClassLoader();
    }
    valClass=cl.loadClass(clsName);
    if (assignable != null && !assignable.isAssignableFrom(valClass)) {
      txt.append(""String_Node_Str"");
      txt.append(assignable.getCanonicalName());
      throw new Exception();
    }
  }
 catch (  Exception e) {
    txt.append(""String_Node_Str"").append(e.toString());
    if (isDebug) {
      StringWriter sw=new StringWriter();
      PrintWriter pw=new PrintWriter(sw);
      e.printStackTrace(pw);
      pw.flush();
      txt.append(""String_Node_Str"").append(sw.toString());
    }
    LOG.warn(txt.toString());
    throw new IllegalArgumentException(txt.toString(),e);
  }
}",0.9014186977082576
90558,"public EventProviderImpl(PortletWindow portletWindow,PortletRegistryService portletRegistry){
  this.portletWindow=portletWindow;
  this.portletRegistry=portletRegistry;
}","public EventProviderImpl(PortletWindow portletWindow,PortletRegistryService portletRegistry){
  this.portletWindow=portletWindow;
  this.portletRegistry=portletRegistry;
  if (LOG.isTraceEnabled()) {
    StringBuilder txt=new StringBuilder(128);
    txt.append(""String_Node_Str"").append(portletWindow.getId().getStringId());
    LOG.debug(txt.toString());
  }
}",0.6428571428571429
90559,"@SuppressWarnings(""String_Node_Str"") public Event createEvent(QName qname,Serializable value) throws IllegalArgumentException {
  if (isDeclaredAsPublishingEvent(qname)) {
    if (value != null && !isValueInstanceOfDefinedClass(qname,value)) {
      throw new IllegalArgumentException(""String_Node_Str"" + value.getClass().getCanonicalName() + ""String_Node_Str"");
    }
    try {
      if (value == null) {
        return new EventImpl(qname,value);
      }
 else {
        ClassLoader cl=Thread.currentThread().getContextClassLoader();
        Writer out=new StringWriter();
        Class clazz=value.getClass();
        try {
          Thread.currentThread().setContextClassLoader(this.getClass().getClassLoader());
          JAXBContext jc=JAXBContext.newInstance(clazz);
          Marshaller marshaller=jc.createMarshaller();
          JAXBElement<Serializable> element=new JAXBElement<Serializable>(qname,clazz,value);
          marshaller.marshal(element,out);
        }
  finally {
          Thread.currentThread().setContextClassLoader(cl);
        }
        return new EventImpl(qname,out.toString());
      }
    }
 catch (    JAXBException e) {
      LOG.error(""String_Node_Str"",e);
    }
catch (    FactoryConfigurationError e) {
      LOG.warn(e.getMessage(),e);
    }
  }
  return null;
}","@SuppressWarnings(""String_Node_Str"") public Event createEvent(QName qname,Serializable value) throws IllegalArgumentException {
  if (LOG.isDebugEnabled()) {
    StringBuilder txt=new StringBuilder(128);
    txt.append(""String_Node_Str"").append(qname.toString());
    txt.append(""String_Node_Str"").append((value == null) ? ""String_Node_Str"" : value.getClass().getCanonicalName());
    LOG.debug(txt.toString());
  }
  if (isDeclaredAsPublishingEvent(qname)) {
    if (value != null && !isValueInstanceOfDefinedClass(qname,value)) {
      throw new IllegalArgumentException(""String_Node_Str"" + value.getClass().getCanonicalName() + ""String_Node_Str"");
    }
    try {
      if (value == null) {
        return new EventImpl(qname,value);
      }
 else {
        boolean debug=false;
        if (LOG.isDebugEnabled() && (value instanceof HashMap)) {
          debug=true;
          StringBuilder txt=new StringBuilder(128);
          txt.append(""String_Node_Str"");
          Map<String,String[]> pmap=(HashMap<String,String[]>)value;
          for (          String name : pmap.keySet()) {
            txt.append(""String_Node_Str"").append(name);
            txt.append(""String_Node_Str"").append(Arrays.toString(pmap.get(name)));
          }
          LOG.debug(txt.toString());
        }
        ClassLoader cl=Thread.currentThread().getContextClassLoader();
        Writer out=new StringWriter();
        @SuppressWarnings(""String_Node_Str"") Class clazz=value.getClass();
        try {
          Thread.currentThread().setContextClassLoader(this.getClass().getClassLoader());
          JAXBContext jc=JAXBContext.newInstance(clazz);
          Marshaller marshaller=jc.createMarshaller();
          JAXBElement<Serializable> element=new JAXBElement<Serializable>(qname,clazz,value);
          marshaller.marshal(element,out);
        }
  finally {
          Thread.currentThread().setContextClassLoader(cl);
        }
        if (debug) {
          LOG.debug(""String_Node_Str"" + out.toString());
        }
        return new EventImpl(qname,out.toString());
      }
    }
 catch (    JAXBException e) {
      LOG.error(""String_Node_Str"",e);
    }
catch (    FactoryConfigurationError e) {
      LOG.warn(e.getMessage(),e);
    }
  }
  return null;
}",0.7333709131905298
90560,"private boolean isValueInstanceOfDefinedClass(QName qname,Serializable value){
  PortletApplicationDefinition app=portletWindow.getPortletDefinition().getApplication();
  List<? extends EventDefinition> events=app.getEventDefinitions();
  if (events != null) {
    for (    EventDefinition def : events) {
      if (def.getQName().equals(qname)) {
        return value.getClass().getName().equals(def.getValueType());
      }
    }
  }
  return true;
}","private boolean isValueInstanceOfDefinedClass(QName qname,Serializable value){
  PortletApplicationDefinition app=portletWindow.getPortletDefinition().getApplication();
  List<? extends EventDefinition> events=app.getEventDefinitions();
  if (events != null) {
    for (    EventDefinition def : events) {
      if (def.getQName().equals(qname)) {
        Class<?> declaredPayload=null;
        try {
          ClassLoader cl=Thread.currentThread().getContextClassLoader();
          if (cl == null) {
            cl=this.getClass().getClassLoader();
          }
          declaredPayload=cl.loadClass(def.getValueType());
          if (!declaredPayload.isAssignableFrom(value.getClass())) {
            StringBuilder txt=new StringBuilder(128);
            txt.append(""String_Node_Str"");
            txt.append(""String_Node_Str"").append(value.getClass().getCanonicalName());
            txt.append(""String_Node_Str"").append(declaredPayload.getCanonicalName());
            LOG.warn(txt.toString());
            return false;
          }
        }
 catch (        Exception e) {
          StringBuilder txt=new StringBuilder(128);
          txt.append(""String_Node_Str"");
          txt.append(""String_Node_Str"").append(e.toString());
          StringWriter sw=new StringWriter();
          PrintWriter pw=new PrintWriter(sw);
          e.printStackTrace(pw);
          pw.flush();
          txt.append(""String_Node_Str"").append(sw.toString());
          LOG.warn(txt.toString());
          return false;
        }
        return true;
      }
    }
  }
  return false;
}",0.400593471810089
90561,"public EventProvider getEventProvider(){
  return isClosed() ? null : new EventProviderImpl(getPortletWindow(),PlutoServices.getServices().getPortletRegistryService());
}","public EventProvider getEventProvider(){
  return isClosed() ? null : eventProviderImpl;
}",0.6923076923076923
90562,"public PortletStateAwareResponseContextImpl(PortletContainer container,HttpServletRequest containerRequest,HttpServletResponse containerResponse,PortletWindow window,PortletRequestContext requestContext){
  super(container,containerRequest,containerResponse,window,requestContext);
  this.portletURLProvider=new PortletURLProviderImpl(getPortalURL(),PortletURLProvider.TYPE.RENDER,window,getRequestContext());
  if (isDebug) {
    LOGGER.debug(""String_Node_Str"");
  }
}","public PortletStateAwareResponseContextImpl(PortletContainer container,HttpServletRequest containerRequest,HttpServletResponse containerResponse,PortletWindow window,PortletRequestContext requestContext){
  super(container,containerRequest,containerResponse,window,requestContext);
  this.portletURLProvider=new PortletURLProviderImpl(getPortalURL(),PortletURLProvider.TYPE.RENDER,window,getRequestContext());
  this.eventProviderImpl=new EventProviderImpl(getPortletWindow(),PlutoServices.getServices().getPortletRegistryService());
  if (isDebug) {
    LOGGER.debug(""String_Node_Str"");
  }
}",0.8832391713747646
90563,"/** 
 * Sets the secure flag on the URl as required
 * @throws JspException
 */
protected void handleSecureFlag() throws JspException {
  BaseURL url=getUrl();
  if (url == null) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  if (var != null) {
    pageContext.removeAttribute(var,PageContext.PAGE_SCOPE);
  }
  if (secure != null) {
    try {
      url.setSecure(getSecureBoolean());
    }
 catch (    PortletSecurityException e) {
      throw new JspException(e);
    }
  }
}","/** 
 * Sets the secure flag on the URl as required
 * @throws JspException
 */
protected void handleSecureFlag() throws JspException {
  BaseURL url=getUrl();
  if (url == null) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  if (var != null) {
    pageContext.removeAttribute(var,PageContext.PAGE_SCOPE);
  }
  if (secure != null) {
    try {
      url.setSecure(getSecureBoolean());
    }
 catch (    PortletSecurityException e) {
    }
  }
}",0.950785340314136
90564,"@Override public void init(PortletConfig config) throws PortletException {
  this.portletConfig=config;
}","@Override public void init(PortletConfig config) throws PortletException {
}",0.8397790055248618
90565,"@Override public void processAction(ActionRequest portletReq,ActionResponse portletResp) throws PortletException, IOException {
  LOGGER.entering(LOG_CLASS,""String_Node_Str"");
  portletResp.setRenderParameters(portletReq.getParameterMap());
  long tid=Thread.currentThread().getId();
  portletReq.setAttribute(THREADID_ATTR,tid);
  StringWriter writer=new StringWriter();
}","@Override public void processAction(ActionRequest portletReq,ActionResponse portletResp) throws PortletException, IOException {
  LOGGER.entering(LOG_CLASS,""String_Node_Str"");
  portletResp.setRenderParameters(portletReq.getParameterMap());
  long tid=Thread.currentThread().getId();
  portletReq.setAttribute(THREADID_ATTR,tid);
}",0.9403409090909092
90566,"@Override public void serveResource(ResourceRequest portletReq,ResourceResponse portletResp) throws PortletException, IOException {
  LOGGER.entering(LOG_CLASS,""String_Node_Str"");
  long tid=Thread.currentThread().getId();
  portletReq.setAttribute(THREADID_ATTR,tid);
  PrintWriter writer=portletResp.getWriter();
}","@Override public void serveResource(ResourceRequest portletReq,ResourceResponse portletResp) throws PortletException, IOException {
  LOGGER.entering(LOG_CLASS,""String_Node_Str"");
  long tid=Thread.currentThread().getId();
  portletReq.setAttribute(THREADID_ATTR,tid);
}",0.9215017064846416
90567,"@Override public void render(RenderRequest portletReq,RenderResponse portletResp) throws PortletException, IOException {
  LOGGER.entering(LOG_CLASS,""String_Node_Str"");
  long tid=Thread.currentThread().getId();
  portletReq.setAttribute(THREADID_ATTR,tid);
  PrintWriter writer=portletResp.getWriter();
  JSR286ApiTestCaseDetails tcd=new JSR286ApiTestCaseDetails();
  ClassChecker cc=new ClassChecker(portletResp.getCacheControl().getClass());
  CacheControl chc=portletResp.getCacheControl();
  TestResult tr0=tcd.getTestResultFailed(V2ENVIRONMENTTESTS_CACHECONTROL_APIRENDER_GETEXPIRATIONTIME1);
  chc.setExpirationTime(10);
  int getExpTime1=chc.getExpirationTime();
  if (getExpTime1 == 10) {
    tr0.setTcSuccess(true);
  }
 else {
    tr0.appendTcDetail(""String_Node_Str"" + getExpTime1);
  }
  tr0.writeTo(writer);
  TestResult tr1=tcd.getTestResultFailed(V2ENVIRONMENTTESTS_CACHECONTROL_APIRENDER_GETEXPIRATIONTIME2);
  tr1.setTcSuccess(true);
  tr1.appendTcDetail(""String_Node_Str"");
  tr1.writeTo(writer);
  TestResult tr2=tcd.getTestResultFailed(V2ENVIRONMENTTESTS_CACHECONTROL_APIRENDER_GETEXPIRATIONTIME3);
  tr2.setTcSuccess(true);
  tr2.appendTcDetail(""String_Node_Str"");
  tr2.writeTo(writer);
  TestResult tr3=tcd.getTestResultFailed(V2ENVIRONMENTTESTS_CACHECONTROL_APIRENDER_SETEXPIRATIONTIME1);
  int setExpTime1=chc.getExpirationTime();
  if (setExpTime1 == 10) {
    tr3.setTcSuccess(true);
  }
 else {
    tr3.appendTcDetail(""String_Node_Str"" + setExpTime1);
  }
  tr3.writeTo(writer);
  TestResult tr4=tcd.getTestResultFailed(V2ENVIRONMENTTESTS_CACHECONTROL_APIRENDER_SETEXPIRATIONTIME2);
  tr4.setTcSuccess(true);
  tr4.appendTcDetail(""String_Node_Str"");
  tr4.writeTo(writer);
  TestResult tr5=tcd.getTestResultFailed(V2ENVIRONMENTTESTS_CACHECONTROL_APIRENDER_SETEXPIRATIONTIME3);
  tr5.setTcSuccess(true);
  tr5.appendTcDetail(""String_Node_Str"");
  tr5.writeTo(writer);
  TestResult tr6=tcd.getTestResultFailed(V2ENVIRONMENTTESTS_CACHECONTROL_APIRENDER_ISPUBLICSCOPE1);
  chc.setPublicScope(true);
  if (chc.isPublicScope() == true) {
    tr6.setTcSuccess(true);
  }
 else {
    tr6.appendTcDetail(""String_Node_Str"");
  }
  tr6.writeTo(writer);
  TestResult tr7=tcd.getTestResultFailed(V2ENVIRONMENTTESTS_CACHECONTROL_APIRENDER_ISPUBLICSCOPE2);
  if (chc.isPublicScope() == true) {
    tr7.setTcSuccess(true);
  }
 else {
    tr7.appendTcDetail(""String_Node_Str"");
  }
  tr7.writeTo(writer);
  TestResult tr8=tcd.getTestResultFailed(V2ENVIRONMENTTESTS_CACHECONTROL_APIRENDER_ISPUBLICSCOPE3);
  chc.setPublicScope(false);
  if (chc.isPublicScope() == false) {
    tr8.setTcSuccess(true);
  }
 else {
    tr8.appendTcDetail(""String_Node_Str"");
  }
  tr8.writeTo(writer);
  TestResult tr9=tcd.getTestResultFailed(V2ENVIRONMENTTESTS_CACHECONTROL_APIRENDER_ISPUBLICSCOPE5);
  if (chc.isPublicScope() == false) {
    tr9.setTcSuccess(true);
  }
 else {
    tr9.appendTcDetail(""String_Node_Str"");
  }
  tr9.writeTo(writer);
  TestResult tr10=tcd.getTestResultFailed(V2ENVIRONMENTTESTS_CACHECONTROL_APIRENDER_SETPUBLICSCOPE1);
  chc.setPublicScope(true);
  if (chc.isPublicScope() == true) {
    tr10.setTcSuccess(true);
  }
 else {
    tr10.appendTcDetail(""String_Node_Str"");
  }
  tr10.writeTo(writer);
  TestResult tr11=tcd.getTestResultFailed(V2ENVIRONMENTTESTS_CACHECONTROL_APIRENDER_SETPUBLICSCOPE2);
  chc.setPublicScope(false);
  if (chc.isPublicScope() == false) {
    tr11.setTcSuccess(true);
  }
 else {
    tr11.appendTcDetail(""String_Node_Str"");
  }
  tr11.writeTo(writer);
  TestResult tr12=tcd.getTestResultFailed(V2ENVIRONMENTTESTS_CACHECONTROL_APIRENDER_GETETAG1);
  chc.setETag(""String_Node_Str"");
  String tag=chc.getETag();
  if (tag.equals(""String_Node_Str"")) {
    tr12.setTcSuccess(true);
  }
 else {
    tr12.appendTcDetail(""String_Node_Str"" + tag);
  }
  tr12.writeTo(writer);
  TestResult tr13=tcd.getTestResultFailed(V2ENVIRONMENTTESTS_CACHECONTROL_APIRENDER_GETETAG2);
  tr13.setTcSuccess(true);
  tr13.appendTcDetail(""String_Node_Str"");
  tr13.writeTo(writer);
  TestResult tr14=tcd.getTestResultFailed(V2ENVIRONMENTTESTS_CACHECONTROL_APIRENDER_SETETAG1);
  chc.setETag(""String_Node_Str"");
  String tag1=chc.getETag();
  if (tag1.equals(""String_Node_Str"")) {
    tr14.setTcSuccess(true);
  }
 else {
    tr14.appendTcDetail(""String_Node_Str"" + tag1);
  }
  tr14.writeTo(writer);
  TestResult tr15=tcd.getTestResultFailed(V2ENVIRONMENTTESTS_CACHECONTROL_APIRENDER_SETETAG2);
  chc.setETag(""String_Node_Str"");
  String tag2=chc.getETag();
  if (tag2.equals(""String_Node_Str"")) {
    tr15.setTcSuccess(true);
  }
 else {
    tr15.appendTcDetail(""String_Node_Str"" + tag2);
  }
  tr15.writeTo(writer);
  TestResult tr16=tcd.getTestResultFailed(V2ENVIRONMENTTESTS_CACHECONTROL_APIRENDER_SETETAG3);
  chc.setETag(null);
  String tag3=chc.getETag();
  if (tag3 == null) {
    tr16.setTcSuccess(true);
  }
  tr16.writeTo(writer);
  TestResult tr17=tcd.getTestResultFailed(V2ENVIRONMENTTESTS_CACHECONTROL_APIRENDER_USECACHEDCONTENT1);
  chc.setUseCachedContent(true);
  if (chc.useCachedContent() == true) {
    tr17.setTcSuccess(true);
  }
 else {
    tr17.appendTcDetail(""String_Node_Str"");
  }
  tr17.writeTo(writer);
  TestResult tr18=tcd.getTestResultFailed(V2ENVIRONMENTTESTS_CACHECONTROL_APIRENDER_USECACHEDCONTENT2);
  chc.setUseCachedContent(false);
  if (chc.useCachedContent() == false) {
    tr18.setTcSuccess(true);
  }
 else {
    tr18.appendTcDetail(""String_Node_Str"");
  }
  tr18.writeTo(writer);
  TestResult tr19=tcd.getTestResultFailed(V2ENVIRONMENTTESTS_CACHECONTROL_APIRENDER_USECACHEDCONTENT3);
  if (chc.useCachedContent() == false) {
    tr19.setTcSuccess(true);
  }
  tr19.writeTo(writer);
  TestResult tr20=tcd.getTestResultFailed(V2ENVIRONMENTTESTS_CACHECONTROL_APIRENDER_SETUSECACHEDCONTENT1);
  chc.setUseCachedContent(true);
  if (chc.useCachedContent() == true) {
    tr20.setTcSuccess(true);
  }
 else {
    tr20.appendTcDetail(""String_Node_Str"");
  }
  tr20.writeTo(writer);
  TestResult tr21=tcd.getTestResultFailed(V2ENVIRONMENTTESTS_CACHECONTROL_APIRENDER_SETUSECACHEDCONTENT2);
  chc.setUseCachedContent(false);
  if (chc.useCachedContent() == false) {
    tr21.setTcSuccess(true);
  }
 else {
    tr21.appendTcDetail(""String_Node_Str"");
  }
  tr21.writeTo(writer);
}","@Override public void render(RenderRequest portletReq,RenderResponse portletResp) throws PortletException, IOException {
  LOGGER.entering(LOG_CLASS,""String_Node_Str"");
  long tid=Thread.currentThread().getId();
  portletReq.setAttribute(THREADID_ATTR,tid);
  PrintWriter writer=portletResp.getWriter();
  JSR286ApiTestCaseDetails tcd=new JSR286ApiTestCaseDetails();
  CacheControl chc=portletResp.getCacheControl();
  TestResult tr0=tcd.getTestResultFailed(V2ENVIRONMENTTESTS_CACHECONTROL_APIRENDER_GETEXPIRATIONTIME1);
  chc.setExpirationTime(10);
  int getExpTime1=chc.getExpirationTime();
  if (getExpTime1 == 10) {
    tr0.setTcSuccess(true);
  }
 else {
    tr0.appendTcDetail(""String_Node_Str"" + getExpTime1);
  }
  tr0.writeTo(writer);
  TestResult tr1=tcd.getTestResultFailed(V2ENVIRONMENTTESTS_CACHECONTROL_APIRENDER_GETEXPIRATIONTIME2);
  tr1.setTcSuccess(true);
  tr1.appendTcDetail(""String_Node_Str"");
  tr1.writeTo(writer);
  TestResult tr2=tcd.getTestResultFailed(V2ENVIRONMENTTESTS_CACHECONTROL_APIRENDER_GETEXPIRATIONTIME3);
  tr2.setTcSuccess(true);
  tr2.appendTcDetail(""String_Node_Str"");
  tr2.writeTo(writer);
  TestResult tr3=tcd.getTestResultFailed(V2ENVIRONMENTTESTS_CACHECONTROL_APIRENDER_SETEXPIRATIONTIME1);
  int setExpTime1=chc.getExpirationTime();
  if (setExpTime1 == 10) {
    tr3.setTcSuccess(true);
  }
 else {
    tr3.appendTcDetail(""String_Node_Str"" + setExpTime1);
  }
  tr3.writeTo(writer);
  TestResult tr4=tcd.getTestResultFailed(V2ENVIRONMENTTESTS_CACHECONTROL_APIRENDER_SETEXPIRATIONTIME2);
  tr4.setTcSuccess(true);
  tr4.appendTcDetail(""String_Node_Str"");
  tr4.writeTo(writer);
  TestResult tr5=tcd.getTestResultFailed(V2ENVIRONMENTTESTS_CACHECONTROL_APIRENDER_SETEXPIRATIONTIME3);
  tr5.setTcSuccess(true);
  tr5.appendTcDetail(""String_Node_Str"");
  tr5.writeTo(writer);
  TestResult tr6=tcd.getTestResultFailed(V2ENVIRONMENTTESTS_CACHECONTROL_APIRENDER_ISPUBLICSCOPE1);
  chc.setPublicScope(true);
  if (chc.isPublicScope() == true) {
    tr6.setTcSuccess(true);
  }
 else {
    tr6.appendTcDetail(""String_Node_Str"");
  }
  tr6.writeTo(writer);
  TestResult tr7=tcd.getTestResultFailed(V2ENVIRONMENTTESTS_CACHECONTROL_APIRENDER_ISPUBLICSCOPE2);
  if (chc.isPublicScope() == true) {
    tr7.setTcSuccess(true);
  }
 else {
    tr7.appendTcDetail(""String_Node_Str"");
  }
  tr7.writeTo(writer);
  TestResult tr8=tcd.getTestResultFailed(V2ENVIRONMENTTESTS_CACHECONTROL_APIRENDER_ISPUBLICSCOPE3);
  chc.setPublicScope(false);
  if (chc.isPublicScope() == false) {
    tr8.setTcSuccess(true);
  }
 else {
    tr8.appendTcDetail(""String_Node_Str"");
  }
  tr8.writeTo(writer);
  TestResult tr9=tcd.getTestResultFailed(V2ENVIRONMENTTESTS_CACHECONTROL_APIRENDER_ISPUBLICSCOPE5);
  if (chc.isPublicScope() == false) {
    tr9.setTcSuccess(true);
  }
 else {
    tr9.appendTcDetail(""String_Node_Str"");
  }
  tr9.writeTo(writer);
  TestResult tr10=tcd.getTestResultFailed(V2ENVIRONMENTTESTS_CACHECONTROL_APIRENDER_SETPUBLICSCOPE1);
  chc.setPublicScope(true);
  if (chc.isPublicScope() == true) {
    tr10.setTcSuccess(true);
  }
 else {
    tr10.appendTcDetail(""String_Node_Str"");
  }
  tr10.writeTo(writer);
  TestResult tr11=tcd.getTestResultFailed(V2ENVIRONMENTTESTS_CACHECONTROL_APIRENDER_SETPUBLICSCOPE2);
  chc.setPublicScope(false);
  if (chc.isPublicScope() == false) {
    tr11.setTcSuccess(true);
  }
 else {
    tr11.appendTcDetail(""String_Node_Str"");
  }
  tr11.writeTo(writer);
  TestResult tr12=tcd.getTestResultFailed(V2ENVIRONMENTTESTS_CACHECONTROL_APIRENDER_GETETAG1);
  chc.setETag(""String_Node_Str"");
  String tag=chc.getETag();
  if (tag.equals(""String_Node_Str"")) {
    tr12.setTcSuccess(true);
  }
 else {
    tr12.appendTcDetail(""String_Node_Str"" + tag);
  }
  tr12.writeTo(writer);
  TestResult tr13=tcd.getTestResultFailed(V2ENVIRONMENTTESTS_CACHECONTROL_APIRENDER_GETETAG2);
  tr13.setTcSuccess(true);
  tr13.appendTcDetail(""String_Node_Str"");
  tr13.writeTo(writer);
  TestResult tr14=tcd.getTestResultFailed(V2ENVIRONMENTTESTS_CACHECONTROL_APIRENDER_SETETAG1);
  chc.setETag(""String_Node_Str"");
  String tag1=chc.getETag();
  if (tag1.equals(""String_Node_Str"")) {
    tr14.setTcSuccess(true);
  }
 else {
    tr14.appendTcDetail(""String_Node_Str"" + tag1);
  }
  tr14.writeTo(writer);
  TestResult tr15=tcd.getTestResultFailed(V2ENVIRONMENTTESTS_CACHECONTROL_APIRENDER_SETETAG2);
  chc.setETag(""String_Node_Str"");
  String tag2=chc.getETag();
  if (tag2.equals(""String_Node_Str"")) {
    tr15.setTcSuccess(true);
  }
 else {
    tr15.appendTcDetail(""String_Node_Str"" + tag2);
  }
  tr15.writeTo(writer);
  TestResult tr16=tcd.getTestResultFailed(V2ENVIRONMENTTESTS_CACHECONTROL_APIRENDER_SETETAG3);
  chc.setETag(null);
  String tag3=chc.getETag();
  if (tag3 == null) {
    tr16.setTcSuccess(true);
  }
  tr16.writeTo(writer);
  TestResult tr17=tcd.getTestResultFailed(V2ENVIRONMENTTESTS_CACHECONTROL_APIRENDER_USECACHEDCONTENT1);
  chc.setUseCachedContent(true);
  if (chc.useCachedContent() == true) {
    tr17.setTcSuccess(true);
  }
 else {
    tr17.appendTcDetail(""String_Node_Str"");
  }
  tr17.writeTo(writer);
  TestResult tr18=tcd.getTestResultFailed(V2ENVIRONMENTTESTS_CACHECONTROL_APIRENDER_USECACHEDCONTENT2);
  chc.setUseCachedContent(false);
  if (chc.useCachedContent() == false) {
    tr18.setTcSuccess(true);
  }
 else {
    tr18.appendTcDetail(""String_Node_Str"");
  }
  tr18.writeTo(writer);
  TestResult tr19=tcd.getTestResultFailed(V2ENVIRONMENTTESTS_CACHECONTROL_APIRENDER_USECACHEDCONTENT3);
  if (chc.useCachedContent() == false) {
    tr19.setTcSuccess(true);
  }
  tr19.writeTo(writer);
  TestResult tr20=tcd.getTestResultFailed(V2ENVIRONMENTTESTS_CACHECONTROL_APIRENDER_SETUSECACHEDCONTENT1);
  chc.setUseCachedContent(true);
  if (chc.useCachedContent() == true) {
    tr20.setTcSuccess(true);
  }
 else {
    tr20.appendTcDetail(""String_Node_Str"");
  }
  tr20.writeTo(writer);
  TestResult tr21=tcd.getTestResultFailed(V2ENVIRONMENTTESTS_CACHECONTROL_APIRENDER_SETUSECACHEDCONTENT2);
  chc.setUseCachedContent(false);
  if (chc.useCachedContent() == false) {
    tr21.setTcSuccess(true);
  }
 else {
    tr21.appendTcDetail(""String_Node_Str"");
  }
  tr21.writeTo(writer);
}",0.9937117059013222
90568,"@Override public void init(PortletConfig config) throws PortletException {
  this.portletConfig=config;
}","@Override public void init(PortletConfig config) throws PortletException {
}",0.8397790055248618
90569,"@Override public void processAction(ActionRequest portletReq,ActionResponse portletResp) throws PortletException, IOException {
  LOGGER.entering(LOG_CLASS,""String_Node_Str"");
  portletResp.setRenderParameters(portletReq.getParameterMap());
  long tid=Thread.currentThread().getId();
  portletReq.setAttribute(THREADID_ATTR,tid);
  StringWriter writer=new StringWriter();
  QName eventQName=new QName(TCKNAMESPACE,""String_Node_Str"");
  portletResp.setEvent(eventQName,""String_Node_Str"");
}","@Override public void processAction(ActionRequest portletReq,ActionResponse portletResp) throws PortletException, IOException {
  LOGGER.entering(LOG_CLASS,""String_Node_Str"");
  portletResp.setRenderParameters(portletReq.getParameterMap());
  long tid=Thread.currentThread().getId();
  portletReq.setAttribute(THREADID_ATTR,tid);
  QName eventQName=new QName(TCKNAMESPACE,""String_Node_Str"");
  portletResp.setEvent(eventQName,""String_Node_Str"");
}",0.9551282051282052
90570,"@Override public void serveResource(ResourceRequest portletReq,ResourceResponse portletResp) throws PortletException, IOException {
  LOGGER.entering(LOG_CLASS,""String_Node_Str"");
  long tid=Thread.currentThread().getId();
  portletReq.setAttribute(THREADID_ATTR,tid);
  PrintWriter writer=portletResp.getWriter();
}","@Override public void serveResource(ResourceRequest portletReq,ResourceResponse portletResp) throws PortletException, IOException {
  LOGGER.entering(LOG_CLASS,""String_Node_Str"");
  long tid=Thread.currentThread().getId();
  portletReq.setAttribute(THREADID_ATTR,tid);
}",0.9215017064846416
90571,"@Override public void init(PortletConfig config) throws PortletException {
  this.portletConfig=config;
}","@Override public void init(PortletConfig config) throws PortletException {
}",0.8397790055248618
90572,"@Override public void processEvent(EventRequest portletReq,EventResponse portletResp) throws PortletException, IOException {
  LOGGER.entering(LOG_CLASS,""String_Node_Str"");
  portletResp.setRenderParameters(portletReq);
  long tid=Thread.currentThread().getId();
  portletReq.setAttribute(THREADID_ATTR,tid);
  StringWriter writer=new StringWriter();
  JSR286ApiTestCaseDetails tcd=new JSR286ApiTestCaseDetails();
  ClassChecker cc=new ClassChecker(GenericPortlet.class);
  TestResult tr0=tcd.getTestResultFailed(V2PORTLETTESTS_EVENTPORTLET_APIEVENT_PROCESSEVENT);
  try {
    tr0.setTcSuccess(true);
  }
 catch (  Exception e) {
    tr0.appendTcDetail(e.toString());
  }
  tr0.writeTo(writer);
  portletReq.getPortletSession().setAttribute(Constants.RESULT_ATTR_PREFIX + ""String_Node_Str"",writer.toString(),APPLICATION_SCOPE);
}","@Override public void processEvent(EventRequest portletReq,EventResponse portletResp) throws PortletException, IOException {
  LOGGER.entering(LOG_CLASS,""String_Node_Str"");
  portletResp.setRenderParameters(portletReq);
  long tid=Thread.currentThread().getId();
  portletReq.setAttribute(THREADID_ATTR,tid);
  StringWriter writer=new StringWriter();
  JSR286ApiTestCaseDetails tcd=new JSR286ApiTestCaseDetails();
  TestResult tr0=tcd.getTestResultFailed(V2PORTLETTESTS_EVENTPORTLET_APIEVENT_PROCESSEVENT);
  try {
    tr0.setTcSuccess(true);
  }
 catch (  Exception e) {
    tr0.appendTcDetail(e.toString());
  }
  tr0.writeTo(writer);
  portletReq.getPortletSession().setAttribute(Constants.RESULT_ATTR_PREFIX + ""String_Node_Str"",writer.toString(),APPLICATION_SCOPE);
}",0.96375
90573,"@Override public void init(PortletConfig config) throws PortletException {
  this.portletConfig=config;
}","@Override public void init(PortletConfig config) throws PortletException {
}",0.8397790055248618
90574,"@Override public void processAction(ActionRequest portletReq,ActionResponse portletResp) throws PortletException, IOException {
  LOGGER.entering(LOG_CLASS,""String_Node_Str"");
  portletResp.setRenderParameters(portletReq.getParameterMap());
  long tid=Thread.currentThread().getId();
  portletReq.setAttribute(THREADID_ATTR,tid);
  StringWriter writer=new StringWriter();
  QName eventQName=new QName(TCKNAMESPACE,""String_Node_Str"");
  String val=portletReq.getParameter(BUTTON_PARAM_NAME);
  if (val != null && val.equals(V2PORTLETTESTS_EVENT_APIEVENT_GETVALUE2)) {
    portletResp.setEvent(eventQName,null);
  }
 else {
    portletResp.setEvent(eventQName,""String_Node_Str"");
  }
}","@Override public void processAction(ActionRequest portletReq,ActionResponse portletResp) throws PortletException, IOException {
  LOGGER.entering(LOG_CLASS,""String_Node_Str"");
  portletResp.setRenderParameters(portletReq.getParameterMap());
  long tid=Thread.currentThread().getId();
  portletReq.setAttribute(THREADID_ATTR,tid);
  QName eventQName=new QName(TCKNAMESPACE,""String_Node_Str"");
  String val=portletReq.getParameter(BUTTON_PARAM_NAME);
  if (val != null && val.equals(V2PORTLETTESTS_EVENT_APIEVENT_GETVALUE2)) {
    portletResp.setEvent(eventQName,null);
  }
 else {
    portletResp.setEvent(eventQName,""String_Node_Str"");
  }
}",0.9682779456193352
90575,"@Override public void serveResource(ResourceRequest portletReq,ResourceResponse portletResp) throws PortletException, IOException {
  LOGGER.entering(LOG_CLASS,""String_Node_Str"");
  long tid=Thread.currentThread().getId();
  portletReq.setAttribute(THREADID_ATTR,tid);
  PrintWriter writer=portletResp.getWriter();
}","@Override public void serveResource(ResourceRequest portletReq,ResourceResponse portletResp) throws PortletException, IOException {
  LOGGER.entering(LOG_CLASS,""String_Node_Str"");
  long tid=Thread.currentThread().getId();
  portletReq.setAttribute(THREADID_ATTR,tid);
}",0.9215017064846416
90576,"@Override public void init(PortletConfig config) throws PortletException {
  this.portletConfig=config;
}","@Override public void init(PortletConfig config) throws PortletException {
}",0.8397790055248618
90577,"@Override public void processEvent(EventRequest portletReq,EventResponse portletResp) throws PortletException, IOException {
  LOGGER.entering(LOG_CLASS,""String_Node_Str"");
  portletResp.setRenderParameters(portletReq);
  long tid=Thread.currentThread().getId();
  portletReq.setAttribute(THREADID_ATTR,tid);
  StringWriter writer=new StringWriter();
  JSR286ApiTestCaseDetails tcd=new JSR286ApiTestCaseDetails();
  ClassChecker cc=new ClassChecker(portletReq.getEvent().getClass());
  Event evt=portletReq.getEvent();
  TestResult tr0=tcd.getTestResultSucceeded(V2PORTLETTESTS_EVENT_APIEVENT_GETQNAME1);
  QName qn=evt.getQName();
  QName xmlqn=new QName(""String_Node_Str"",""String_Node_Str"");
  if (qn == null) {
    tr0.appendTcDetail(""String_Node_Str"");
  }
 else   if (!qn.equals(xmlqn)) {
    StringBuilder txt=new StringBuilder(128);
    txt.append(""String_Node_Str"");
    txt.append(""String_Node_Str"").append(xmlqn);
    txt.append(""String_Node_Str"").append(qn);
    tr0.appendTcDetail(txt.toString());
  }
  tr0.writeTo(writer);
  TestResult tr1=tcd.getTestResultSucceeded(V2PORTLETTESTS_EVENT_APIEVENT_GETQNAME2);
  QName qn1=evt.getQName();
  StringBuilder txt1=new StringBuilder(128);
  txt1.append(qn1);
  if (qn1 == null) {
    tr1.appendTcDetail(""String_Node_Str"");
    tr1.appendTcDetail(txt1.toString());
  }
  tr1.writeTo(writer);
  TestResult tr2=tcd.getTestResultSucceeded(V2PORTLETTESTS_EVENT_APIEVENT_GETNAME1);
  String qn2=evt.getName();
  String evtname=""String_Node_Str"";
  if (qn2 == null) {
    tr2.appendTcDetail(""String_Node_Str"");
  }
 else   if (!qn2.equals(evtname)) {
    StringBuilder txt2=new StringBuilder(128);
    txt2.append(""String_Node_Str"");
    txt2.append(""String_Node_Str"").append(evtname);
    txt2.append(""String_Node_Str"").append(qn2);
    tr2.appendTcDetail(txt2.toString());
  }
  tr2.writeTo(writer);
  TestResult tr3=tcd.getTestResultSucceeded(V2PORTLETTESTS_EVENT_APIEVENT_GETNAME2);
  if (qn2 == null) {
    tr3.appendTcDetail(""String_Node_Str"");
  }
  tr3.writeTo(writer);
  TestResult tr4=tcd.getTestResultFailed(V2PORTLETTESTS_EVENT_APIEVENT_GETVALUE1);
  try {
    Object val=evt.getValue();
    if (val == null) {
      tr4.appendTcDetail(""String_Node_Str"");
    }
    if ((val instanceof String)) {
      String txt4=(String)val;
      if (txt4.equals(""String_Node_Str"")) {
        tr4.setTcSuccess(true);
      }
 else {
        tr4.appendTcDetail(""String_Node_Str"" + txt4);
      }
    }
  }
 catch (  Exception e) {
    tr4.appendTcDetail(e.toString());
  }
  tr4.writeTo(writer);
  TestResult tr5=tcd.getTestResultFailed(V2PORTLETTESTS_EVENT_APIEVENT_GETVALUE2);
  Serializable val1=evt.getValue();
  if (val1 == null) {
    tr5.setTcSuccess(true);
  }
 else {
    tr5.appendTcDetail(""String_Node_Str"" + val1.toString());
  }
  tr5.writeTo(writer);
  portletReq.getPortletSession().setAttribute(Constants.RESULT_ATTR_PREFIX + ""String_Node_Str"",writer.toString(),APPLICATION_SCOPE);
}","@Override public void processEvent(EventRequest portletReq,EventResponse portletResp) throws PortletException, IOException {
  LOGGER.entering(LOG_CLASS,""String_Node_Str"");
  portletResp.setRenderParameters(portletReq);
  long tid=Thread.currentThread().getId();
  portletReq.setAttribute(THREADID_ATTR,tid);
  StringWriter writer=new StringWriter();
  JSR286ApiTestCaseDetails tcd=new JSR286ApiTestCaseDetails();
  Event evt=portletReq.getEvent();
  TestResult tr0=tcd.getTestResultSucceeded(V2PORTLETTESTS_EVENT_APIEVENT_GETQNAME1);
  QName qn=evt.getQName();
  QName xmlqn=new QName(""String_Node_Str"",""String_Node_Str"");
  if (qn == null) {
    tr0.appendTcDetail(""String_Node_Str"");
  }
 else   if (!qn.equals(xmlqn)) {
    StringBuilder txt=new StringBuilder(128);
    txt.append(""String_Node_Str"");
    txt.append(""String_Node_Str"").append(xmlqn);
    txt.append(""String_Node_Str"").append(qn);
    tr0.appendTcDetail(txt.toString());
  }
  tr0.writeTo(writer);
  TestResult tr1=tcd.getTestResultSucceeded(V2PORTLETTESTS_EVENT_APIEVENT_GETQNAME2);
  QName qn1=evt.getQName();
  StringBuilder txt1=new StringBuilder(128);
  txt1.append(qn1);
  if (qn1 == null) {
    tr1.appendTcDetail(""String_Node_Str"");
    tr1.appendTcDetail(txt1.toString());
  }
  tr1.writeTo(writer);
  TestResult tr2=tcd.getTestResultSucceeded(V2PORTLETTESTS_EVENT_APIEVENT_GETNAME1);
  String qn2=evt.getName();
  String evtname=""String_Node_Str"";
  if (qn2 == null) {
    tr2.appendTcDetail(""String_Node_Str"");
  }
 else   if (!qn2.equals(evtname)) {
    StringBuilder txt2=new StringBuilder(128);
    txt2.append(""String_Node_Str"");
    txt2.append(""String_Node_Str"").append(evtname);
    txt2.append(""String_Node_Str"").append(qn2);
    tr2.appendTcDetail(txt2.toString());
  }
  tr2.writeTo(writer);
  TestResult tr3=tcd.getTestResultSucceeded(V2PORTLETTESTS_EVENT_APIEVENT_GETNAME2);
  if (qn2 == null) {
    tr3.appendTcDetail(""String_Node_Str"");
  }
  tr3.writeTo(writer);
  TestResult tr4=tcd.getTestResultFailed(V2PORTLETTESTS_EVENT_APIEVENT_GETVALUE1);
  try {
    Object val=evt.getValue();
    if (val == null) {
      tr4.appendTcDetail(""String_Node_Str"");
    }
    if ((val instanceof String)) {
      String txt4=(String)val;
      if (txt4.equals(""String_Node_Str"")) {
        tr4.setTcSuccess(true);
      }
 else {
        tr4.appendTcDetail(""String_Node_Str"" + txt4);
      }
    }
  }
 catch (  Exception e) {
    tr4.appendTcDetail(e.toString());
  }
  tr4.writeTo(writer);
  TestResult tr5=tcd.getTestResultFailed(V2PORTLETTESTS_EVENT_APIEVENT_GETVALUE2);
  Serializable val1=evt.getValue();
  if (val1 == null) {
    tr5.setTcSuccess(true);
  }
 else {
    tr5.appendTcDetail(""String_Node_Str"" + val1.toString());
  }
  tr5.writeTo(writer);
  portletReq.getPortletSession().setAttribute(Constants.RESULT_ATTR_PREFIX + ""String_Node_Str"",writer.toString(),APPLICATION_SCOPE);
}",0.9879807692307692
90578,"@Override public void init(PortletConfig config) throws PortletException {
  this.portletConfig=config;
}","@Override public void init(PortletConfig config) throws PortletException {
}",0.8397790055248618
90579,"@Override public void serveResource(ResourceRequest portletReq,ResourceResponse portletResp) throws PortletException, IOException {
  LOGGER.entering(LOG_CLASS,""String_Node_Str"");
  long tid=Thread.currentThread().getId();
  portletReq.setAttribute(THREADID_ATTR,tid);
  PrintWriter writer=portletResp.getWriter();
}","@Override public void serveResource(ResourceRequest portletReq,ResourceResponse portletResp) throws PortletException, IOException {
  LOGGER.entering(LOG_CLASS,""String_Node_Str"");
  long tid=Thread.currentThread().getId();
  portletReq.setAttribute(THREADID_ATTR,tid);
}",0.9215017064846416
90580,"@Override public void init(PortletConfig config) throws PortletException {
  this.portletConfig=config;
}","@Override public void init(PortletConfig config) throws PortletException {
}",0.8397790055248618
90581,"@Override public void processAction(ActionRequest portletReq,ActionResponse portletResp) throws PortletException, IOException {
  LOGGER.entering(LOG_CLASS,""String_Node_Str"");
  portletResp.setRenderParameters(portletReq.getParameterMap());
  long tid=Thread.currentThread().getId();
  portletReq.setAttribute(THREADID_ATTR,tid);
  StringWriter writer=new StringWriter();
  JSR286ApiTestCaseDetails tcd=new JSR286ApiTestCaseDetails();
  ClassChecker cc=new ClassChecker(portletReq.getClass());
  TestResult tr0=tcd.getTestResultFailed(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_GETPORTLETINPUTSTREAM1);
  String getparm1=portletReq.getParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_GETPORTLETINPUTSTREAM1);
  if (getparm1 != null && getparm1.equals(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_GETPORTLETINPUTSTREAM1)) {
    tr0.setTcSuccess(true);
    tr0.appendTcDetail(""String_Node_Str"");
  }
 else {
    portletResp.setRenderParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_GETPORTLETINPUTSTREAM1,V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_GETPORTLETINPUTSTREAM1);
  }
  tr0.writeTo(writer);
  TestResult tr1=tcd.getTestResultFailed(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_GETPORTLETINPUTSTREAM2);
  String getparm2=portletReq.getParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_GETPORTLETINPUTSTREAM2);
  if (getparm2 != null && getparm2.equals(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_GETPORTLETINPUTSTREAM2)) {
    try {
      portletReq.getReader();
      portletReq.getPortletInputStream();
      tr1.appendTcDetail(""String_Node_Str"");
    }
 catch (    IllegalStateException iae) {
      tr1.setTcSuccess(true);
    }
  }
 else {
    portletResp.setRenderParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_GETPORTLETINPUTSTREAM2,V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_GETPORTLETINPUTSTREAM2);
  }
  tr1.writeTo(writer);
  TestResult tr2=tcd.getTestResultFailed(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_GETPORTLETINPUTSTREAM3);
  String getparm3=portletReq.getParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_GETPORTLETINPUTSTREAM3);
  if (getparm3 != null && getparm3.equals(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_GETPORTLETINPUTSTREAM3)) {
    try {
      portletReq.getPortletInputStream();
      tr2.appendTcDetail(""String_Node_Str"");
    }
 catch (    IllegalStateException iae) {
      tr2.setTcSuccess(true);
    }
  }
 else {
    portletResp.setRenderParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_GETPORTLETINPUTSTREAM3,V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_GETPORTLETINPUTSTREAM3);
  }
  tr2.writeTo(writer);
  TestResult tr3=tcd.getTestResultFailed(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_SETCHARACTERENCODING1);
  String setchar1=portletReq.getParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_SETCHARACTERENCODING1);
  if (setchar1 != null && setchar1.equals(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_SETCHARACTERENCODING1)) {
    portletReq.setCharacterEncoding(""String_Node_Str"");
    String getcharcode=portletReq.getCharacterEncoding();
    if (getcharcode != null && getcharcode.equals(""String_Node_Str"")) {
      tr3.setTcSuccess(true);
    }
 else {
      tr3.appendTcDetail(""String_Node_Str"" + getcharcode);
    }
  }
 else {
    portletResp.setRenderParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_SETCHARACTERENCODING1,V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_SETCHARACTERENCODING1);
  }
  tr3.writeTo(writer);
  TestResult tr4=tcd.getTestResultFailed(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_SETCHARACTERENCODING2);
  String setchar2=portletReq.getParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_SETCHARACTERENCODING2);
  if (setchar2 != null && setchar2.equals(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_SETCHARACTERENCODING2)) {
    try {
      portletReq.getParameter(""String_Node_Str"");
      portletReq.setCharacterEncoding(""String_Node_Str"");
      tr4.setTcSuccess(true);
      tr4.appendTcDetail(""String_Node_Str"");
    }
 catch (    IllegalStateException iae) {
      tr4.setTcSuccess(true);
    }
  }
 else {
    portletResp.setRenderParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_SETCHARACTERENCODING2,V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_SETCHARACTERENCODING2);
  }
  tr4.writeTo(writer);
  TestResult tr5=tcd.getTestResultFailed(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_SETCHARACTERENCODING3);
  String setchar3=portletReq.getParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_SETCHARACTERENCODING3);
  if (setchar3 != null && setchar3.equals(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_SETCHARACTERENCODING3)) {
    try {
      portletReq.getReader();
      portletReq.setCharacterEncoding(""String_Node_Str"");
      tr5.appendTcDetail(""String_Node_Str"");
    }
 catch (    IllegalStateException iae) {
      tr5.setTcSuccess(true);
    }
  }
 else {
    portletResp.setRenderParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_SETCHARACTERENCODING3,V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_SETCHARACTERENCODING3);
  }
  tr5.writeTo(writer);
  TestResult tr6=tcd.getTestResultFailed(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_SETCHARACTERENCODING4);
  String setchar4=portletReq.getParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_SETCHARACTERENCODING4);
  if (setchar4 != null && setchar4.equals(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_SETCHARACTERENCODING4)) {
    try {
      portletReq.setCharacterEncoding(""String_Node_Str"");
      tr6.appendTcDetail(""String_Node_Str"");
    }
 catch (    UnsupportedEncodingException une) {
      tr6.setTcSuccess(true);
    }
  }
 else {
    portletResp.setRenderParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_SETCHARACTERENCODING4,V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_SETCHARACTERENCODING4);
  }
  tr6.writeTo(writer);
  TestResult tr7=tcd.getTestResultFailed(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_GETREADER1);
  String getRead1=portletReq.getParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_GETREADER1);
  if (getRead1 != null && getRead1.equals(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_GETREADER1)) {
    tr7.setTcSuccess(true);
    tr7.appendTcDetail(""String_Node_Str"");
  }
 else {
    portletResp.setRenderParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_GETREADER1,V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_GETREADER1);
  }
  tr7.writeTo(writer);
  TestResult tr8=tcd.getTestResultFailed(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_GETREADER2);
  String getRead2=portletReq.getParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_GETREADER2);
  if (getRead2 != null && getRead2.equals(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_GETREADER2)) {
    try {
      portletReq.getPortletInputStream();
      tr8.appendTcDetail(""String_Node_Str"");
    }
 catch (    IllegalStateException iae) {
      tr8.setTcSuccess(true);
    }
  }
 else {
    portletResp.setRenderParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_GETREADER2,V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_GETREADER2);
  }
  tr8.writeTo(writer);
  TestResult tr9=tcd.getTestResultFailed(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_GETREADER3);
  String getRead3=portletReq.getParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_GETREADER3);
  if (getRead3 != null && getRead3.equals(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_GETREADER3)) {
    try {
      portletReq.getReader();
      tr9.appendTcDetail(""String_Node_Str"");
    }
 catch (    IllegalStateException iae) {
      tr9.setTcSuccess(true);
    }
  }
 else {
    portletResp.setRenderParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_GETREADER3,V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_GETREADER3);
  }
  tr9.writeTo(writer);
  TestResult tr10=tcd.getTestResultFailed(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_GETREADER5);
  String getRead5=portletReq.getParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_GETREADER5);
  if (getRead5 != null && getRead5.equals(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_GETREADER5)) {
    try {
      portletReq.setCharacterEncoding(""String_Node_Str"");
      portletReq.getReader();
      tr6.appendTcDetail(""String_Node_Str"");
    }
 catch (    UnsupportedEncodingException une) {
      tr10.setTcSuccess(true);
    }
  }
 else {
    portletResp.setRenderParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_GETREADER5,V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_GETREADER5);
  }
  tr10.writeTo(writer);
  TestResult tr11=tcd.getTestResultFailed(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_GETCHARACTERENCODING1);
  String getChar1=portletReq.getParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_GETCHARACTERENCODING1);
  if (getChar1 != null && getChar1.equals(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_GETCHARACTERENCODING1)) {
    String getCharEncde=portletReq.getCharacterEncoding();
    if (getCharEncde != null) {
      tr11.setTcSuccess(true);
    }
 else {
      tr11.appendTcDetail(""String_Node_Str"");
    }
  }
 else {
    portletResp.setRenderParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_GETCHARACTERENCODING1,V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_GETCHARACTERENCODING1);
  }
  tr11.writeTo(writer);
  TestResult tr12=tcd.getTestResultFailed(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_GETCHARACTERENCODING2);
  String getChar2=portletReq.getParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_GETCHARACTERENCODING2);
  if (getChar2 != null && getChar2.equals(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_GETCHARACTERENCODING2)) {
    tr12.setTcSuccess(true);
    tr12.appendTcDetail(""String_Node_Str"");
  }
 else {
    portletResp.setRenderParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_GETCHARACTERENCODING2,V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_GETCHARACTERENCODING2);
  }
  tr12.writeTo(writer);
  TestResult tr13=tcd.getTestResultFailed(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_GETCONTENTTYPE1);
  String getCnt1=portletReq.getParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_GETCONTENTTYPE1);
  if (getCnt1 != null && getCnt1.equals(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_GETCONTENTTYPE1)) {
    String getContype=portletReq.getContentType();
    if (getContype != null) {
      tr13.setTcSuccess(true);
    }
 else {
      tr13.appendTcDetail(""String_Node_Str"" + getContype);
    }
  }
 else {
    portletResp.setRenderParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_GETCONTENTTYPE1,V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_GETCONTENTTYPE1);
  }
  tr13.writeTo(writer);
  TestResult tr14=tcd.getTestResultFailed(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_GETCONTENTTYPE2);
  String getCnt2=portletReq.getParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_GETCONTENTTYPE2);
  if (getCnt2 != null && getCnt2.equals(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_GETCONTENTTYPE2)) {
    tr14.setTcSuccess(true);
    tr14.appendTcDetail(""String_Node_Str"");
  }
 else {
    portletResp.setRenderParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_GETCONTENTTYPE2,V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_GETCONTENTTYPE2);
  }
  tr14.writeTo(writer);
  TestResult tr15=tcd.getTestResultFailed(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_GETCONTENTLENGTH1);
  String getCntl1=portletReq.getParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_GETCONTENTLENGTH1);
  if (getCntl1 != null && getCntl1.equals(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_GETCONTENTLENGTH1)) {
    int getConLgt=portletReq.getContentLength();
    if (getConLgt != -1) {
      tr15.setTcSuccess(true);
    }
 else {
      tr15.appendTcDetail(""String_Node_Str"" + getConLgt);
    }
  }
 else {
    portletResp.setRenderParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_GETCONTENTLENGTH1,V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_GETCONTENTLENGTH1);
  }
  tr15.writeTo(writer);
  TestResult tr16=tcd.getTestResultFailed(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_GETCONTENTLENGTH2);
  String getCntl2=portletReq.getParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_GETCONTENTLENGTH2);
  if (getCntl2 != null && getCntl2.equals(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_GETCONTENTLENGTH2)) {
    tr16.setTcSuccess(true);
    tr16.appendTcDetail(""String_Node_Str"");
  }
 else {
    portletResp.setRenderParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_GETCONTENTLENGTH2,V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_GETCONTENTLENGTH2);
  }
  tr16.writeTo(writer);
  TestResult tr17=tcd.getTestResultFailed(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_GETMETHOD);
  String getMethd=portletReq.getParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_GETMETHOD);
  if (getMethd != null && getMethd.equals(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_GETMETHOD)) {
    String getmethod=portletReq.getMethod();
    if (getmethod != null && getmethod.equals(""String_Node_Str"")) {
      tr17.setTcSuccess(true);
    }
 else {
      tr17.appendTcDetail(""String_Node_Str"" + getmethod);
    }
  }
 else {
    portletResp.setRenderParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_GETMETHOD,V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_GETMETHOD);
  }
  tr17.writeTo(writer);
  portletReq.getPortletSession().setAttribute(Constants.RESULT_ATTR_PREFIX + ""String_Node_Str"",writer.toString(),APPLICATION_SCOPE);
}","@Override public void processAction(ActionRequest portletReq,ActionResponse portletResp) throws PortletException, IOException {
  LOGGER.entering(LOG_CLASS,""String_Node_Str"");
  portletResp.setRenderParameters(portletReq.getParameterMap());
  long tid=Thread.currentThread().getId();
  portletReq.setAttribute(THREADID_ATTR,tid);
  StringWriter writer=new StringWriter();
  JSR286ApiTestCaseDetails tcd=new JSR286ApiTestCaseDetails();
  TestResult tr0=tcd.getTestResultFailed(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_GETPORTLETINPUTSTREAM1);
  String getparm1=portletReq.getParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_GETPORTLETINPUTSTREAM1);
  if (getparm1 != null && getparm1.equals(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_GETPORTLETINPUTSTREAM1)) {
    tr0.setTcSuccess(true);
    tr0.appendTcDetail(""String_Node_Str"");
  }
 else {
    portletResp.setRenderParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_GETPORTLETINPUTSTREAM1,V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_GETPORTLETINPUTSTREAM1);
  }
  tr0.writeTo(writer);
  TestResult tr1=tcd.getTestResultFailed(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_GETPORTLETINPUTSTREAM2);
  String getparm2=portletReq.getParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_GETPORTLETINPUTSTREAM2);
  if (getparm2 != null && getparm2.equals(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_GETPORTLETINPUTSTREAM2)) {
    try {
      portletReq.getReader();
      portletReq.getPortletInputStream();
      tr1.appendTcDetail(""String_Node_Str"");
    }
 catch (    IllegalStateException iae) {
      tr1.setTcSuccess(true);
    }
  }
 else {
    portletResp.setRenderParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_GETPORTLETINPUTSTREAM2,V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_GETPORTLETINPUTSTREAM2);
  }
  tr1.writeTo(writer);
  TestResult tr2=tcd.getTestResultFailed(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_GETPORTLETINPUTSTREAM3);
  String getparm3=portletReq.getParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_GETPORTLETINPUTSTREAM3);
  if (getparm3 != null && getparm3.equals(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_GETPORTLETINPUTSTREAM3)) {
    try {
      portletReq.getPortletInputStream();
      tr2.appendTcDetail(""String_Node_Str"");
    }
 catch (    IllegalStateException iae) {
      tr2.setTcSuccess(true);
    }
  }
 else {
    portletResp.setRenderParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_GETPORTLETINPUTSTREAM3,V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_GETPORTLETINPUTSTREAM3);
  }
  tr2.writeTo(writer);
  TestResult tr3=tcd.getTestResultFailed(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_SETCHARACTERENCODING1);
  String setchar1=portletReq.getParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_SETCHARACTERENCODING1);
  if (setchar1 != null && setchar1.equals(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_SETCHARACTERENCODING1)) {
    portletReq.setCharacterEncoding(""String_Node_Str"");
    String getcharcode=portletReq.getCharacterEncoding();
    if (getcharcode != null && getcharcode.equals(""String_Node_Str"")) {
      tr3.setTcSuccess(true);
    }
 else {
      tr3.appendTcDetail(""String_Node_Str"" + getcharcode);
    }
  }
 else {
    portletResp.setRenderParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_SETCHARACTERENCODING1,V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_SETCHARACTERENCODING1);
  }
  tr3.writeTo(writer);
  TestResult tr4=tcd.getTestResultFailed(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_SETCHARACTERENCODING2);
  String setchar2=portletReq.getParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_SETCHARACTERENCODING2);
  if (setchar2 != null && setchar2.equals(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_SETCHARACTERENCODING2)) {
    try {
      portletReq.getParameter(""String_Node_Str"");
      portletReq.setCharacterEncoding(""String_Node_Str"");
      tr4.setTcSuccess(true);
      tr4.appendTcDetail(""String_Node_Str"");
    }
 catch (    IllegalStateException iae) {
      tr4.setTcSuccess(true);
    }
  }
 else {
    portletResp.setRenderParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_SETCHARACTERENCODING2,V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_SETCHARACTERENCODING2);
  }
  tr4.writeTo(writer);
  TestResult tr5=tcd.getTestResultFailed(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_SETCHARACTERENCODING3);
  String setchar3=portletReq.getParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_SETCHARACTERENCODING3);
  if (setchar3 != null && setchar3.equals(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_SETCHARACTERENCODING3)) {
    try {
      portletReq.getReader();
      portletReq.setCharacterEncoding(""String_Node_Str"");
      tr5.appendTcDetail(""String_Node_Str"");
    }
 catch (    IllegalStateException iae) {
      tr5.setTcSuccess(true);
    }
  }
 else {
    portletResp.setRenderParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_SETCHARACTERENCODING3,V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_SETCHARACTERENCODING3);
  }
  tr5.writeTo(writer);
  TestResult tr6=tcd.getTestResultFailed(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_SETCHARACTERENCODING4);
  String setchar4=portletReq.getParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_SETCHARACTERENCODING4);
  if (setchar4 != null && setchar4.equals(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_SETCHARACTERENCODING4)) {
    try {
      portletReq.setCharacterEncoding(""String_Node_Str"");
      tr6.appendTcDetail(""String_Node_Str"");
    }
 catch (    UnsupportedEncodingException une) {
      tr6.setTcSuccess(true);
    }
  }
 else {
    portletResp.setRenderParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_SETCHARACTERENCODING4,V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_SETCHARACTERENCODING4);
  }
  tr6.writeTo(writer);
  TestResult tr7=tcd.getTestResultFailed(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_GETREADER1);
  String getRead1=portletReq.getParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_GETREADER1);
  if (getRead1 != null && getRead1.equals(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_GETREADER1)) {
    tr7.setTcSuccess(true);
    tr7.appendTcDetail(""String_Node_Str"");
  }
 else {
    portletResp.setRenderParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_GETREADER1,V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_GETREADER1);
  }
  tr7.writeTo(writer);
  TestResult tr8=tcd.getTestResultFailed(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_GETREADER2);
  String getRead2=portletReq.getParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_GETREADER2);
  if (getRead2 != null && getRead2.equals(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_GETREADER2)) {
    try {
      portletReq.getPortletInputStream();
      tr8.appendTcDetail(""String_Node_Str"");
    }
 catch (    IllegalStateException iae) {
      tr8.setTcSuccess(true);
    }
  }
 else {
    portletResp.setRenderParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_GETREADER2,V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_GETREADER2);
  }
  tr8.writeTo(writer);
  TestResult tr9=tcd.getTestResultFailed(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_GETREADER3);
  String getRead3=portletReq.getParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_GETREADER3);
  if (getRead3 != null && getRead3.equals(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_GETREADER3)) {
    try {
      portletReq.getReader();
      tr9.appendTcDetail(""String_Node_Str"");
    }
 catch (    IllegalStateException iae) {
      tr9.setTcSuccess(true);
    }
  }
 else {
    portletResp.setRenderParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_GETREADER3,V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_GETREADER3);
  }
  tr9.writeTo(writer);
  TestResult tr10=tcd.getTestResultFailed(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_GETREADER5);
  String getRead5=portletReq.getParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_GETREADER5);
  if (getRead5 != null && getRead5.equals(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_GETREADER5)) {
    try {
      portletReq.setCharacterEncoding(""String_Node_Str"");
      portletReq.getReader();
      tr6.appendTcDetail(""String_Node_Str"");
    }
 catch (    UnsupportedEncodingException une) {
      tr10.setTcSuccess(true);
    }
  }
 else {
    portletResp.setRenderParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_GETREADER5,V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_GETREADER5);
  }
  tr10.writeTo(writer);
  TestResult tr11=tcd.getTestResultFailed(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_GETCHARACTERENCODING1);
  String getChar1=portletReq.getParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_GETCHARACTERENCODING1);
  if (getChar1 != null && getChar1.equals(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_GETCHARACTERENCODING1)) {
    String getCharEncde=portletReq.getCharacterEncoding();
    if (getCharEncde != null) {
      tr11.setTcSuccess(true);
    }
 else {
      tr11.appendTcDetail(""String_Node_Str"");
    }
  }
 else {
    portletResp.setRenderParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_GETCHARACTERENCODING1,V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_GETCHARACTERENCODING1);
  }
  tr11.writeTo(writer);
  TestResult tr12=tcd.getTestResultFailed(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_GETCHARACTERENCODING2);
  String getChar2=portletReq.getParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_GETCHARACTERENCODING2);
  if (getChar2 != null && getChar2.equals(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_GETCHARACTERENCODING2)) {
    tr12.setTcSuccess(true);
    tr12.appendTcDetail(""String_Node_Str"");
  }
 else {
    portletResp.setRenderParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_GETCHARACTERENCODING2,V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_GETCHARACTERENCODING2);
  }
  tr12.writeTo(writer);
  TestResult tr13=tcd.getTestResultFailed(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_GETCONTENTTYPE1);
  String getCnt1=portletReq.getParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_GETCONTENTTYPE1);
  if (getCnt1 != null && getCnt1.equals(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_GETCONTENTTYPE1)) {
    String getContype=portletReq.getContentType();
    if (getContype != null) {
      tr13.setTcSuccess(true);
    }
 else {
      tr13.appendTcDetail(""String_Node_Str"" + getContype);
    }
  }
 else {
    portletResp.setRenderParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_GETCONTENTTYPE1,V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_GETCONTENTTYPE1);
  }
  tr13.writeTo(writer);
  TestResult tr14=tcd.getTestResultFailed(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_GETCONTENTTYPE2);
  String getCnt2=portletReq.getParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_GETCONTENTTYPE2);
  if (getCnt2 != null && getCnt2.equals(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_GETCONTENTTYPE2)) {
    tr14.setTcSuccess(true);
    tr14.appendTcDetail(""String_Node_Str"");
  }
 else {
    portletResp.setRenderParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_GETCONTENTTYPE2,V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_GETCONTENTTYPE2);
  }
  tr14.writeTo(writer);
  TestResult tr15=tcd.getTestResultFailed(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_GETCONTENTLENGTH1);
  String getCntl1=portletReq.getParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_GETCONTENTLENGTH1);
  if (getCntl1 != null && getCntl1.equals(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_GETCONTENTLENGTH1)) {
    int getConLgt=portletReq.getContentLength();
    if (getConLgt != -1) {
      tr15.setTcSuccess(true);
    }
 else {
      tr15.appendTcDetail(""String_Node_Str"" + getConLgt);
    }
  }
 else {
    portletResp.setRenderParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_GETCONTENTLENGTH1,V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_GETCONTENTLENGTH1);
  }
  tr15.writeTo(writer);
  TestResult tr16=tcd.getTestResultFailed(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_GETCONTENTLENGTH2);
  String getCntl2=portletReq.getParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_GETCONTENTLENGTH2);
  if (getCntl2 != null && getCntl2.equals(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_GETCONTENTLENGTH2)) {
    tr16.setTcSuccess(true);
    tr16.appendTcDetail(""String_Node_Str"");
  }
 else {
    portletResp.setRenderParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_GETCONTENTLENGTH2,V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_GETCONTENTLENGTH2);
  }
  tr16.writeTo(writer);
  TestResult tr17=tcd.getTestResultFailed(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_GETMETHOD);
  String getMethd=portletReq.getParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_GETMETHOD);
  if (getMethd != null && getMethd.equals(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_GETMETHOD)) {
    String getmethod=portletReq.getMethod();
    if (getmethod != null && getmethod.equals(""String_Node_Str"")) {
      tr17.setTcSuccess(true);
    }
 else {
      tr17.appendTcDetail(""String_Node_Str"" + getmethod);
    }
  }
 else {
    portletResp.setRenderParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_GETMETHOD,V2REQUESTTESTS_CLIENTDATAREQUEST_APIACTION_GETMETHOD);
  }
  tr17.writeTo(writer);
  portletReq.getPortletSession().setAttribute(Constants.RESULT_ATTR_PREFIX + ""String_Node_Str"",writer.toString(),APPLICATION_SCOPE);
}",0.9977263092990096
90582,"@Override public void serveResource(ResourceRequest portletReq,ResourceResponse portletResp) throws PortletException, IOException {
  LOGGER.entering(LOG_CLASS,""String_Node_Str"");
  long tid=Thread.currentThread().getId();
  portletReq.setAttribute(THREADID_ATTR,tid);
  PrintWriter writer=portletResp.getWriter();
}","@Override public void serveResource(ResourceRequest portletReq,ResourceResponse portletResp) throws PortletException, IOException {
  LOGGER.entering(LOG_CLASS,""String_Node_Str"");
  long tid=Thread.currentThread().getId();
  portletReq.setAttribute(THREADID_ATTR,tid);
}",0.9215017064846416
90583,"@Override public void init(PortletConfig config) throws PortletException {
  this.portletConfig=config;
}","@Override public void init(PortletConfig config) throws PortletException {
}",0.8397790055248618
90584,"@Override public void processAction(ActionRequest portletReq,ActionResponse portletResp) throws PortletException, IOException {
  LOGGER.entering(LOG_CLASS,""String_Node_Str"");
  portletResp.setRenderParameters(portletReq.getParameterMap());
  long tid=Thread.currentThread().getId();
  portletReq.setAttribute(THREADID_ATTR,tid);
  StringWriter writer=new StringWriter();
}","@Override public void processAction(ActionRequest portletReq,ActionResponse portletResp) throws PortletException, IOException {
  LOGGER.entering(LOG_CLASS,""String_Node_Str"");
  portletResp.setRenderParameters(portletReq.getParameterMap());
  long tid=Thread.currentThread().getId();
  portletReq.setAttribute(THREADID_ATTR,tid);
}",0.9403409090909092
90585,"@Override public void serveResource(ResourceRequest portletReq,ResourceResponse portletResp) throws PortletException, IOException {
  LOGGER.entering(LOG_CLASS,""String_Node_Str"");
  long tid=Thread.currentThread().getId();
  portletReq.setAttribute(THREADID_ATTR,tid);
  PrintWriter writer=portletResp.getWriter();
  JSR286ApiTestCaseDetails tcd=new JSR286ApiTestCaseDetails();
  ClassChecker cc=new ClassChecker(portletReq.getClass());
  TestResult tr0=tcd.getTestResultFailed(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_GETPORTLETINPUTSTREAM1);
  String parm=portletReq.getParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_GETPORTLETINPUTSTREAM1);
  if (parm == null) {
    PortletURL rurl=portletResp.createActionURL();
    rurl.setParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_GETPORTLETINPUTSTREAM1,V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_GETPORTLETINPUTSTREAM1);
    TestButton tb=new TestButton(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_GETPORTLETINPUTSTREAM1,rurl);
    tb.writeTo(writer);
  }
 else {
    tr0.setTcSuccess(true);
    tr0.appendTcDetail(""String_Node_Str"");
  }
  tr0.writeTo(writer);
  TestResult tr1=tcd.getTestResultFailed(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_GETPORTLETINPUTSTREAM2);
  String parm1=portletReq.getParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_GETPORTLETINPUTSTREAM2);
  if (parm1 == null) {
    PortletURL rurl=portletResp.createActionURL();
    rurl.setParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_GETPORTLETINPUTSTREAM2,V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_GETPORTLETINPUTSTREAM2);
    TestButton tb=new TestButton(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_GETPORTLETINPUTSTREAM2,rurl);
    tb.writeTo(writer);
  }
 else {
    try {
      portletReq.getReader();
      portletReq.getPortletInputStream();
      tr1.appendTcDetail(""String_Node_Str"");
    }
 catch (    IllegalStateException iae) {
      tr1.setTcSuccess(true);
    }
  }
  tr1.writeTo(writer);
  TestResult tr2=tcd.getTestResultFailed(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_GETPORTLETINPUTSTREAM3);
  String parm2=portletReq.getParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_GETPORTLETINPUTSTREAM3);
  if (parm2 == null) {
    PortletURL rurl=portletResp.createActionURL();
    rurl.setParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_GETPORTLETINPUTSTREAM3,V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_GETPORTLETINPUTSTREAM3);
    TestButton tb=new TestButton(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_GETPORTLETINPUTSTREAM3,rurl);
    tb.writeTo(writer);
  }
 else {
    try {
      portletReq.getPortletInputStream();
      tr2.setTcSuccess(true);
      tr2.appendTcDetail(""String_Node_Str"");
    }
 catch (    IllegalStateException iae) {
      tr2.setTcSuccess(true);
    }
  }
  tr2.writeTo(writer);
  TestResult tr3=tcd.getTestResultFailed(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_SETCHARACTERENCODING1);
  String setchar1=portletReq.getParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_SETCHARACTERENCODING1);
  if (setchar1 == null) {
    PortletURL rurl=portletResp.createActionURL();
    rurl.setParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_SETCHARACTERENCODING1,V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_SETCHARACTERENCODING1);
    TestButton tb=new TestButton(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_SETCHARACTERENCODING1,rurl);
    tb.writeTo(writer);
  }
 else {
    portletReq.setCharacterEncoding(""String_Node_Str"");
    String getcharcode=portletReq.getCharacterEncoding();
    if (getcharcode != null && getcharcode.equals(""String_Node_Str"")) {
      tr3.setTcSuccess(true);
    }
 else {
      tr3.appendTcDetail(""String_Node_Str"" + getcharcode);
    }
  }
  tr3.writeTo(writer);
  TestResult tr4=tcd.getTestResultFailed(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_SETCHARACTERENCODING2);
  String setchar2=portletReq.getParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_SETCHARACTERENCODING2);
  if (setchar2 == null) {
    PortletURL rurl=portletResp.createActionURL();
    rurl.setParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_SETCHARACTERENCODING2,V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_SETCHARACTERENCODING2);
    TestButton tb=new TestButton(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_SETCHARACTERENCODING2,rurl);
    tb.writeTo(writer);
  }
 else {
    try {
      portletReq.getParameter(""String_Node_Str"");
      portletReq.setCharacterEncoding(""String_Node_Str"");
      tr4.setTcSuccess(true);
      tr4.appendTcDetail(""String_Node_Str"");
    }
 catch (    IllegalStateException iae) {
      tr4.setTcSuccess(true);
    }
  }
  tr4.writeTo(writer);
  TestResult tr5=tcd.getTestResultFailed(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_SETCHARACTERENCODING3);
  String setchar3=portletReq.getParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_SETCHARACTERENCODING3);
  if (setchar3 == null) {
    PortletURL rurl=portletResp.createActionURL();
    rurl.setParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_SETCHARACTERENCODING3,V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_SETCHARACTERENCODING3);
    TestButton tb=new TestButton(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_SETCHARACTERENCODING3,rurl);
    tb.writeTo(writer);
  }
 else {
    try {
      portletReq.getReader();
      portletReq.setCharacterEncoding(""String_Node_Str"");
      tr5.appendTcDetail(""String_Node_Str"");
    }
 catch (    IllegalStateException iae) {
      tr5.setTcSuccess(true);
    }
  }
  tr5.writeTo(writer);
  TestResult tr6=tcd.getTestResultFailed(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_SETCHARACTERENCODING4);
  String setchar4=portletReq.getParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_SETCHARACTERENCODING4);
  if (setchar4 == null) {
    PortletURL rurl=portletResp.createActionURL();
    rurl.setParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_SETCHARACTERENCODING4,V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_SETCHARACTERENCODING4);
    TestButton tb=new TestButton(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_SETCHARACTERENCODING4,rurl);
    tb.writeTo(writer);
  }
 else {
    try {
      portletReq.setCharacterEncoding(""String_Node_Str"");
      tr6.appendTcDetail(""String_Node_Str"");
    }
 catch (    UnsupportedEncodingException une) {
      tr6.setTcSuccess(true);
    }
  }
  tr6.writeTo(writer);
  TestResult tr7=tcd.getTestResultFailed(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_GETREADER1);
  String getread1=portletReq.getParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_GETREADER1);
  if (getread1 == null) {
    PortletURL rurl=portletResp.createActionURL();
    rurl.setParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_GETREADER1,V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_GETREADER1);
    TestButton tb=new TestButton(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_GETREADER1,rurl);
    tb.writeTo(writer);
  }
 else {
    tr7.setTcSuccess(true);
    tr7.appendTcDetail(""String_Node_Str"");
  }
  tr7.writeTo(writer);
  TestResult tr8=tcd.getTestResultFailed(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_GETREADER2);
  String getread2=portletReq.getParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_GETREADER2);
  if (getread2 == null) {
    PortletURL rurl=portletResp.createActionURL();
    rurl.setParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_GETREADER2,V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_GETREADER2);
    TestButton tb=new TestButton(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_GETREADER2,rurl);
    tb.writeTo(writer);
  }
 else {
    try {
      portletReq.getPortletInputStream();
      portletReq.getReader();
      tr8.appendTcDetail(""String_Node_Str"");
    }
 catch (    IllegalStateException iae) {
      tr8.setTcSuccess(true);
    }
catch (    Throwable t) {
      tr8.appendTcDetail(""String_Node_Str"" + t.toString());
    }
  }
  tr8.writeTo(writer);
  TestResult tr9=tcd.getTestResultFailed(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_GETREADER3);
  String getread3=portletReq.getParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_GETREADER3);
  if (getread3 == null) {
    PortletURL rurl=portletResp.createActionURL();
    rurl.setParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_GETREADER3,V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_GETREADER3);
    TestButton tb=new TestButton(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_GETREADER3,rurl);
    tb.writeTo(writer);
  }
 else {
    try {
      portletReq.getReader();
      tr9.setTcSuccess(true);
      tr9.appendTcDetail(""String_Node_Str"");
    }
 catch (    IllegalStateException iae) {
      tr9.setTcSuccess(true);
    }
  }
  tr9.writeTo(writer);
  TestResult tr10=tcd.getTestResultFailed(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_GETREADER5);
  String getread5=portletReq.getParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_GETREADER5);
  if (getread5 == null) {
    PortletURL rurl=portletResp.createActionURL();
    rurl.setParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_GETREADER5,V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_GETREADER5);
    TestButton tb=new TestButton(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_GETREADER5,rurl);
    tb.writeTo(writer);
  }
 else {
    try {
      portletReq.setCharacterEncoding(""String_Node_Str"");
      portletReq.getReader();
      tr6.appendTcDetail(""String_Node_Str"");
    }
 catch (    UnsupportedEncodingException une) {
      tr10.setTcSuccess(true);
    }
  }
  tr10.writeTo(writer);
  TestResult tr11=tcd.getTestResultFailed(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_GETCHARACTERENCODING1);
  String getchar1=portletReq.getParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_GETCHARACTERENCODING1);
  if (getchar1 == null) {
    PortletURL rurl=portletResp.createActionURL();
    rurl.setParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_GETCHARACTERENCODING1,V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_GETCHARACTERENCODING1);
    TestButton tb=new TestButton(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_GETCHARACTERENCODING1,rurl);
    tb.writeTo(writer);
  }
 else {
    String getCharEncde=portletReq.getCharacterEncoding();
    if (getCharEncde != null) {
      tr11.setTcSuccess(true);
    }
 else {
      tr11.appendTcDetail(""String_Node_Str"");
    }
  }
  tr11.writeTo(writer);
  TestResult tr12=tcd.getTestResultFailed(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_GETCHARACTERENCODING2);
  String getchar2=portletReq.getParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_GETCHARACTERENCODING2);
  if (getchar2 == null) {
    PortletURL rurl=portletResp.createActionURL();
    rurl.setParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_GETCHARACTERENCODING2,V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_GETCHARACTERENCODING2);
    TestButton tb=new TestButton(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_GETCHARACTERENCODING2,rurl);
    tb.writeTo(writer);
  }
 else {
    tr12.setTcSuccess(true);
    tr12.appendTcDetail(""String_Node_Str"");
  }
  tr12.writeTo(writer);
  TestResult tr13=tcd.getTestResultFailed(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_GETCONTENTTYPE1);
  String getCnt1=portletReq.getParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_GETCONTENTTYPE1);
  if (getCnt1 == null) {
    PortletURL rurl=portletResp.createActionURL();
    rurl.setParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_GETCONTENTTYPE1,V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_GETCONTENTTYPE1);
    TestButton tb=new TestButton(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_GETCONTENTTYPE1,rurl);
    tb.writeTo(writer);
  }
 else {
    tr13.setTcSuccess(true);
    tr13.appendTcDetail(""String_Node_Str"");
  }
  tr13.writeTo(writer);
  TestResult tr14=tcd.getTestResultFailed(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_GETCONTENTTYPE2);
  String getCnt2=portletReq.getParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_GETCONTENTTYPE2);
  if (getCnt2 == null) {
    PortletURL rurl=portletResp.createActionURL();
    rurl.setParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_GETCONTENTTYPE2,V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_GETCONTENTTYPE2);
    TestButton tb=new TestButton(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_GETCONTENTTYPE2,rurl);
    tb.writeTo(writer);
  }
 else {
    tr14.setTcSuccess(true);
    tr14.appendTcDetail(""String_Node_Str"");
  }
  tr14.writeTo(writer);
  TestResult tr15=tcd.getTestResultFailed(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_GETCONTENTLENGTH1);
  String getLngt1=portletReq.getParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_GETCONTENTLENGTH1);
  if (getLngt1 == null) {
    PortletURL rurl=portletResp.createActionURL();
    rurl.setParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_GETCONTENTLENGTH1,V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_GETCONTENTLENGTH1);
    TestButton tb=new TestButton(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_GETCONTENTLENGTH1,rurl);
    tb.writeTo(writer);
  }
 else {
    tr15.setTcSuccess(true);
  }
  tr15.writeTo(writer);
  TestResult tr16=tcd.getTestResultFailed(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_GETCONTENTLENGTH2);
  String getLngt2=portletReq.getParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_GETCONTENTLENGTH2);
  if (getLngt2 == null) {
    PortletURL rurl=portletResp.createActionURL();
    rurl.setParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_GETCONTENTLENGTH2,V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_GETCONTENTLENGTH2);
    TestButton tb=new TestButton(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_GETCONTENTLENGTH2,rurl);
    tb.writeTo(writer);
  }
 else {
    int getConLgt=portletReq.getContentLength();
    if (getConLgt == -1) {
      tr16.setTcSuccess(true);
    }
 else {
      tr16.appendTcDetail(""String_Node_Str"" + getConLgt);
    }
  }
  tr16.writeTo(writer);
  TestResult tr17=tcd.getTestResultFailed(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_GETMETHOD);
  String getMethd=portletReq.getParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_GETMETHOD);
  if (getMethd == null) {
    PortletURL rurl=portletResp.createActionURL();
    rurl.setParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_GETMETHOD,V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_GETMETHOD);
    TestButton tb=new TestButton(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_GETMETHOD,rurl);
    tb.writeTo(writer);
  }
 else {
    String getmethod=portletReq.getMethod();
    if (getmethod != null) {
      tr17.setTcSuccess(true);
    }
 else {
      tr17.appendTcDetail(""String_Node_Str"" + getmethod);
    }
  }
  tr17.writeTo(writer);
}","@Override public void serveResource(ResourceRequest portletReq,ResourceResponse portletResp) throws PortletException, IOException {
  LOGGER.entering(LOG_CLASS,""String_Node_Str"");
  long tid=Thread.currentThread().getId();
  portletReq.setAttribute(THREADID_ATTR,tid);
  PrintWriter writer=portletResp.getWriter();
  JSR286ApiTestCaseDetails tcd=new JSR286ApiTestCaseDetails();
  TestResult tr0=tcd.getTestResultFailed(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_GETPORTLETINPUTSTREAM1);
  String parm=portletReq.getParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_GETPORTLETINPUTSTREAM1);
  if (parm == null) {
    PortletURL rurl=portletResp.createActionURL();
    rurl.setParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_GETPORTLETINPUTSTREAM1,V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_GETPORTLETINPUTSTREAM1);
    TestButton tb=new TestButton(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_GETPORTLETINPUTSTREAM1,rurl);
    tb.writeTo(writer);
  }
 else {
    tr0.setTcSuccess(true);
    tr0.appendTcDetail(""String_Node_Str"");
  }
  tr0.writeTo(writer);
  TestResult tr1=tcd.getTestResultFailed(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_GETPORTLETINPUTSTREAM2);
  String parm1=portletReq.getParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_GETPORTLETINPUTSTREAM2);
  if (parm1 == null) {
    PortletURL rurl=portletResp.createActionURL();
    rurl.setParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_GETPORTLETINPUTSTREAM2,V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_GETPORTLETINPUTSTREAM2);
    TestButton tb=new TestButton(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_GETPORTLETINPUTSTREAM2,rurl);
    tb.writeTo(writer);
  }
 else {
    try {
      portletReq.getReader();
      portletReq.getPortletInputStream();
      tr1.appendTcDetail(""String_Node_Str"");
    }
 catch (    IllegalStateException iae) {
      tr1.setTcSuccess(true);
    }
  }
  tr1.writeTo(writer);
  TestResult tr2=tcd.getTestResultFailed(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_GETPORTLETINPUTSTREAM3);
  String parm2=portletReq.getParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_GETPORTLETINPUTSTREAM3);
  if (parm2 == null) {
    PortletURL rurl=portletResp.createActionURL();
    rurl.setParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_GETPORTLETINPUTSTREAM3,V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_GETPORTLETINPUTSTREAM3);
    TestButton tb=new TestButton(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_GETPORTLETINPUTSTREAM3,rurl);
    tb.writeTo(writer);
  }
 else {
    try {
      portletReq.getPortletInputStream();
      tr2.setTcSuccess(true);
      tr2.appendTcDetail(""String_Node_Str"");
    }
 catch (    IllegalStateException iae) {
      tr2.setTcSuccess(true);
    }
  }
  tr2.writeTo(writer);
  TestResult tr3=tcd.getTestResultFailed(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_SETCHARACTERENCODING1);
  String setchar1=portletReq.getParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_SETCHARACTERENCODING1);
  if (setchar1 == null) {
    PortletURL rurl=portletResp.createActionURL();
    rurl.setParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_SETCHARACTERENCODING1,V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_SETCHARACTERENCODING1);
    TestButton tb=new TestButton(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_SETCHARACTERENCODING1,rurl);
    tb.writeTo(writer);
  }
 else {
    portletReq.setCharacterEncoding(""String_Node_Str"");
    String getcharcode=portletReq.getCharacterEncoding();
    if (getcharcode != null && getcharcode.equals(""String_Node_Str"")) {
      tr3.setTcSuccess(true);
    }
 else {
      tr3.appendTcDetail(""String_Node_Str"" + getcharcode);
    }
  }
  tr3.writeTo(writer);
  TestResult tr4=tcd.getTestResultFailed(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_SETCHARACTERENCODING2);
  String setchar2=portletReq.getParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_SETCHARACTERENCODING2);
  if (setchar2 == null) {
    PortletURL rurl=portletResp.createActionURL();
    rurl.setParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_SETCHARACTERENCODING2,V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_SETCHARACTERENCODING2);
    TestButton tb=new TestButton(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_SETCHARACTERENCODING2,rurl);
    tb.writeTo(writer);
  }
 else {
    try {
      portletReq.getParameter(""String_Node_Str"");
      portletReq.setCharacterEncoding(""String_Node_Str"");
      tr4.setTcSuccess(true);
      tr4.appendTcDetail(""String_Node_Str"");
    }
 catch (    IllegalStateException iae) {
      tr4.setTcSuccess(true);
    }
  }
  tr4.writeTo(writer);
  TestResult tr5=tcd.getTestResultFailed(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_SETCHARACTERENCODING3);
  String setchar3=portletReq.getParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_SETCHARACTERENCODING3);
  if (setchar3 == null) {
    PortletURL rurl=portletResp.createActionURL();
    rurl.setParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_SETCHARACTERENCODING3,V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_SETCHARACTERENCODING3);
    TestButton tb=new TestButton(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_SETCHARACTERENCODING3,rurl);
    tb.writeTo(writer);
  }
 else {
    try {
      portletReq.getReader();
      portletReq.setCharacterEncoding(""String_Node_Str"");
      tr5.appendTcDetail(""String_Node_Str"");
    }
 catch (    IllegalStateException iae) {
      tr5.setTcSuccess(true);
    }
  }
  tr5.writeTo(writer);
  TestResult tr6=tcd.getTestResultFailed(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_SETCHARACTERENCODING4);
  String setchar4=portletReq.getParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_SETCHARACTERENCODING4);
  if (setchar4 == null) {
    PortletURL rurl=portletResp.createActionURL();
    rurl.setParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_SETCHARACTERENCODING4,V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_SETCHARACTERENCODING4);
    TestButton tb=new TestButton(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_SETCHARACTERENCODING4,rurl);
    tb.writeTo(writer);
  }
 else {
    try {
      portletReq.setCharacterEncoding(""String_Node_Str"");
      tr6.appendTcDetail(""String_Node_Str"");
    }
 catch (    UnsupportedEncodingException une) {
      tr6.setTcSuccess(true);
    }
  }
  tr6.writeTo(writer);
  TestResult tr7=tcd.getTestResultFailed(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_GETREADER1);
  String getread1=portletReq.getParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_GETREADER1);
  if (getread1 == null) {
    PortletURL rurl=portletResp.createActionURL();
    rurl.setParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_GETREADER1,V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_GETREADER1);
    TestButton tb=new TestButton(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_GETREADER1,rurl);
    tb.writeTo(writer);
  }
 else {
    tr7.setTcSuccess(true);
    tr7.appendTcDetail(""String_Node_Str"");
  }
  tr7.writeTo(writer);
  TestResult tr8=tcd.getTestResultFailed(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_GETREADER2);
  String getread2=portletReq.getParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_GETREADER2);
  if (getread2 == null) {
    PortletURL rurl=portletResp.createActionURL();
    rurl.setParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_GETREADER2,V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_GETREADER2);
    TestButton tb=new TestButton(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_GETREADER2,rurl);
    tb.writeTo(writer);
  }
 else {
    try {
      portletReq.getPortletInputStream();
      portletReq.getReader();
      tr8.appendTcDetail(""String_Node_Str"");
    }
 catch (    IllegalStateException iae) {
      tr8.setTcSuccess(true);
    }
catch (    Throwable t) {
      tr8.appendTcDetail(""String_Node_Str"" + t.toString());
    }
  }
  tr8.writeTo(writer);
  TestResult tr9=tcd.getTestResultFailed(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_GETREADER3);
  String getread3=portletReq.getParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_GETREADER3);
  if (getread3 == null) {
    PortletURL rurl=portletResp.createActionURL();
    rurl.setParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_GETREADER3,V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_GETREADER3);
    TestButton tb=new TestButton(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_GETREADER3,rurl);
    tb.writeTo(writer);
  }
 else {
    try {
      portletReq.getReader();
      tr9.setTcSuccess(true);
      tr9.appendTcDetail(""String_Node_Str"");
    }
 catch (    IllegalStateException iae) {
      tr9.setTcSuccess(true);
    }
  }
  tr9.writeTo(writer);
  TestResult tr10=tcd.getTestResultFailed(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_GETREADER5);
  String getread5=portletReq.getParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_GETREADER5);
  if (getread5 == null) {
    PortletURL rurl=portletResp.createActionURL();
    rurl.setParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_GETREADER5,V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_GETREADER5);
    TestButton tb=new TestButton(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_GETREADER5,rurl);
    tb.writeTo(writer);
  }
 else {
    try {
      portletReq.setCharacterEncoding(""String_Node_Str"");
      portletReq.getReader();
      tr6.appendTcDetail(""String_Node_Str"");
    }
 catch (    UnsupportedEncodingException une) {
      tr10.setTcSuccess(true);
    }
  }
  tr10.writeTo(writer);
  TestResult tr11=tcd.getTestResultFailed(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_GETCHARACTERENCODING1);
  String getchar1=portletReq.getParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_GETCHARACTERENCODING1);
  if (getchar1 == null) {
    PortletURL rurl=portletResp.createActionURL();
    rurl.setParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_GETCHARACTERENCODING1,V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_GETCHARACTERENCODING1);
    TestButton tb=new TestButton(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_GETCHARACTERENCODING1,rurl);
    tb.writeTo(writer);
  }
 else {
    String getCharEncde=portletReq.getCharacterEncoding();
    if (getCharEncde != null) {
      tr11.setTcSuccess(true);
    }
 else {
      tr11.appendTcDetail(""String_Node_Str"");
    }
  }
  tr11.writeTo(writer);
  TestResult tr12=tcd.getTestResultFailed(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_GETCHARACTERENCODING2);
  String getchar2=portletReq.getParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_GETCHARACTERENCODING2);
  if (getchar2 == null) {
    PortletURL rurl=portletResp.createActionURL();
    rurl.setParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_GETCHARACTERENCODING2,V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_GETCHARACTERENCODING2);
    TestButton tb=new TestButton(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_GETCHARACTERENCODING2,rurl);
    tb.writeTo(writer);
  }
 else {
    tr12.setTcSuccess(true);
    tr12.appendTcDetail(""String_Node_Str"");
  }
  tr12.writeTo(writer);
  TestResult tr13=tcd.getTestResultFailed(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_GETCONTENTTYPE1);
  String getCnt1=portletReq.getParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_GETCONTENTTYPE1);
  if (getCnt1 == null) {
    PortletURL rurl=portletResp.createActionURL();
    rurl.setParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_GETCONTENTTYPE1,V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_GETCONTENTTYPE1);
    TestButton tb=new TestButton(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_GETCONTENTTYPE1,rurl);
    tb.writeTo(writer);
  }
 else {
    tr13.setTcSuccess(true);
    tr13.appendTcDetail(""String_Node_Str"");
  }
  tr13.writeTo(writer);
  TestResult tr14=tcd.getTestResultFailed(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_GETCONTENTTYPE2);
  String getCnt2=portletReq.getParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_GETCONTENTTYPE2);
  if (getCnt2 == null) {
    PortletURL rurl=portletResp.createActionURL();
    rurl.setParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_GETCONTENTTYPE2,V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_GETCONTENTTYPE2);
    TestButton tb=new TestButton(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_GETCONTENTTYPE2,rurl);
    tb.writeTo(writer);
  }
 else {
    tr14.setTcSuccess(true);
    tr14.appendTcDetail(""String_Node_Str"");
  }
  tr14.writeTo(writer);
  TestResult tr15=tcd.getTestResultFailed(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_GETCONTENTLENGTH1);
  String getLngt1=portletReq.getParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_GETCONTENTLENGTH1);
  if (getLngt1 == null) {
    PortletURL rurl=portletResp.createActionURL();
    rurl.setParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_GETCONTENTLENGTH1,V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_GETCONTENTLENGTH1);
    TestButton tb=new TestButton(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_GETCONTENTLENGTH1,rurl);
    tb.writeTo(writer);
  }
 else {
    tr15.setTcSuccess(true);
  }
  tr15.writeTo(writer);
  TestResult tr16=tcd.getTestResultFailed(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_GETCONTENTLENGTH2);
  String getLngt2=portletReq.getParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_GETCONTENTLENGTH2);
  if (getLngt2 == null) {
    PortletURL rurl=portletResp.createActionURL();
    rurl.setParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_GETCONTENTLENGTH2,V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_GETCONTENTLENGTH2);
    TestButton tb=new TestButton(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_GETCONTENTLENGTH2,rurl);
    tb.writeTo(writer);
  }
 else {
    int getConLgt=portletReq.getContentLength();
    if (getConLgt == -1) {
      tr16.setTcSuccess(true);
    }
 else {
      tr16.appendTcDetail(""String_Node_Str"" + getConLgt);
    }
  }
  tr16.writeTo(writer);
  TestResult tr17=tcd.getTestResultFailed(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_GETMETHOD);
  String getMethd=portletReq.getParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_GETMETHOD);
  if (getMethd == null) {
    PortletURL rurl=portletResp.createActionURL();
    rurl.setParameter(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_GETMETHOD,V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_GETMETHOD);
    TestButton tb=new TestButton(V2REQUESTTESTS_CLIENTDATAREQUEST_APIRESOURCE_GETMETHOD,rurl);
    tb.writeTo(writer);
  }
 else {
    String getmethod=portletReq.getMethod();
    if (getmethod != null) {
      tr17.setTcSuccess(true);
    }
 else {
      tr17.appendTcDetail(""String_Node_Str"" + getmethod);
    }
  }
  tr17.writeTo(writer);
}",0.9979518866942064
90586,"@Override public void init(PortletConfig config) throws PortletException {
  this.portletConfig=config;
}","@Override public void init(PortletConfig config) throws PortletException {
}",0.8397790055248618
90587,"@Override public void processAction(ActionRequest portletReq,ActionResponse portletResp) throws PortletException, IOException {
  LOGGER.entering(LOG_CLASS,""String_Node_Str"");
  portletResp.setRenderParameters(portletReq.getParameterMap());
  long tid=Thread.currentThread().getId();
  portletReq.setAttribute(THREADID_ATTR,tid);
  StringWriter writer=new StringWriter();
  QName eventQName=new QName(TCKNAMESPACE,""String_Node_Str"");
  portletResp.setEvent(eventQName,""String_Node_Str"");
}","@Override public void processAction(ActionRequest portletReq,ActionResponse portletResp) throws PortletException, IOException {
  LOGGER.entering(LOG_CLASS,""String_Node_Str"");
  portletResp.setRenderParameters(portletReq.getParameterMap());
  long tid=Thread.currentThread().getId();
  portletReq.setAttribute(THREADID_ATTR,tid);
  QName eventQName=new QName(TCKNAMESPACE,""String_Node_Str"");
  portletResp.setEvent(eventQName,""String_Node_Str"");
}",0.9551282051282052
90588,"@Override public void serveResource(ResourceRequest portletReq,ResourceResponse portletResp) throws PortletException, IOException {
  LOGGER.entering(LOG_CLASS,""String_Node_Str"");
  long tid=Thread.currentThread().getId();
  portletReq.setAttribute(THREADID_ATTR,tid);
  PrintWriter writer=portletResp.getWriter();
}","@Override public void serveResource(ResourceRequest portletReq,ResourceResponse portletResp) throws PortletException, IOException {
  LOGGER.entering(LOG_CLASS,""String_Node_Str"");
  long tid=Thread.currentThread().getId();
  portletReq.setAttribute(THREADID_ATTR,tid);
}",0.9215017064846416
90589,"public PathDisplay(PortletRequest req,String caller){
  this.caller=caller;
  async_request_uri=(String)req.getAttribute(""String_Node_Str"");
  async_context_path=(String)req.getAttribute(""String_Node_Str"");
  async_servlet_path=(String)req.getAttribute(""String_Node_Str"");
  async_path_info=(String)req.getAttribute(""String_Node_Str"");
  async_query_string=(String)req.getAttribute(""String_Node_Str"");
  forward_request_uri=(String)req.getAttribute(""String_Node_Str"");
  forward_context_path=(String)req.getAttribute(""String_Node_Str"");
  forward_servlet_path=(String)req.getAttribute(""String_Node_Str"");
  forward_path_info=(String)req.getAttribute(""String_Node_Str"");
  forward_query_string=(String)req.getAttribute(""String_Node_Str"");
  include_request_uri=(String)req.getAttribute(""String_Node_Str"");
  include_context_path=(String)req.getAttribute(""String_Node_Str"");
  include_servlet_path=(String)req.getAttribute(""String_Node_Str"");
  include_path_info=(String)req.getAttribute(""String_Node_Str"");
  include_query_string=(String)req.getAttribute(""String_Node_Str"");
  method_request_uri=""String_Node_Str"";
  method_context_path=req.getContextPath();
  method_servlet_path=""String_Node_Str"";
  method_path_info=""String_Node_Str"";
  method_query_string=""String_Node_Str"";
  type=""String_Node_Str"";
}","public PathDisplay(PortletRequest req,String caller){
  this.caller=caller;
  async_request_uri=(String)req.getAttribute(""String_Node_Str"");
  async_context_path=(String)req.getAttribute(""String_Node_Str"");
  async_servlet_path=(String)req.getAttribute(""String_Node_Str"");
  async_path_info=(String)req.getAttribute(""String_Node_Str"");
  async_query_string=(String)req.getAttribute(""String_Node_Str"");
  forward_request_uri=(String)req.getAttribute(""String_Node_Str"");
  forward_context_path=(String)req.getAttribute(""String_Node_Str"");
  forward_servlet_path=(String)req.getAttribute(""String_Node_Str"");
  forward_path_info=(String)req.getAttribute(""String_Node_Str"");
  forward_query_string=(String)req.getAttribute(""String_Node_Str"");
  include_request_uri=(String)req.getAttribute(""String_Node_Str"");
  include_context_path=(String)req.getAttribute(""String_Node_Str"");
  include_servlet_path=(String)req.getAttribute(""String_Node_Str"");
  include_path_info=(String)req.getAttribute(""String_Node_Str"");
  include_query_string=(String)req.getAttribute(""String_Node_Str"");
  method_request_uri=""String_Node_Str"";
  method_context_path=req.getContextPath();
  method_servlet_path=""String_Node_Str"";
  method_path_info=""String_Node_Str"";
  method_path_xlated=""String_Node_Str"";
  method_query_string=""String_Node_Str"";
  type=""String_Node_Str"";
}",0.9849056603773584
90590,"public String toMarkup(){
  StringBuilder txt=new StringBuilder(128);
  txt.append(""String_Node_Str"");
  txt.append(""String_Node_Str"").append(caller).append(""String_Node_Str"");
  txt.append(""String_Node_Str"");
  txt.append(""String_Node_Str"").append(type).append(""String_Node_Str"");
  txt.append(""String_Node_Str"");
  if ((async_request_uri == null) && (async_context_path == null) && (async_servlet_path == null)&& (async_path_info == null)&& (async_query_string == null)) {
    txt.append(""String_Node_Str"");
  }
 else {
    txt.append(""String_Node_Str"").append(async_request_uri).append(""String_Node_Str"");
    txt.append(""String_Node_Str"");
    txt.append(""String_Node_Str"").append(async_context_path).append(""String_Node_Str"");
    txt.append(""String_Node_Str"");
    txt.append(""String_Node_Str"").append(async_servlet_path).append(""String_Node_Str"");
    txt.append(""String_Node_Str"");
    txt.append(""String_Node_Str"").append(async_path_info).append(""String_Node_Str"");
    txt.append(""String_Node_Str"");
    txt.append(""String_Node_Str"").append(async_query_string).append(""String_Node_Str"");
  }
  txt.append(""String_Node_Str"");
  txt.append(""String_Node_Str"").append(isAsyncSupported).append(""String_Node_Str"");
  txt.append(""String_Node_Str"");
  if ((forward_request_uri == null) && (forward_context_path == null) && (forward_servlet_path == null)&& (forward_path_info == null)&& (forward_query_string == null)) {
    txt.append(""String_Node_Str"");
  }
 else {
    txt.append(""String_Node_Str"").append(forward_request_uri).append(""String_Node_Str"");
    txt.append(""String_Node_Str"");
    txt.append(""String_Node_Str"").append(forward_context_path).append(""String_Node_Str"");
    txt.append(""String_Node_Str"");
    txt.append(""String_Node_Str"").append(forward_servlet_path).append(""String_Node_Str"");
    txt.append(""String_Node_Str"");
    txt.append(""String_Node_Str"").append(forward_path_info).append(""String_Node_Str"");
    txt.append(""String_Node_Str"");
    txt.append(""String_Node_Str"").append(forward_query_string).append(""String_Node_Str"");
  }
  txt.append(""String_Node_Str"");
  if ((include_request_uri == null) && (include_context_path == null) && (include_servlet_path == null)&& (include_path_info == null)&& (include_query_string == null)) {
    txt.append(""String_Node_Str"");
  }
 else {
    txt.append(""String_Node_Str"").append(include_request_uri).append(""String_Node_Str"");
    txt.append(""String_Node_Str"");
    txt.append(""String_Node_Str"").append(include_context_path).append(""String_Node_Str"");
    txt.append(""String_Node_Str"");
    txt.append(""String_Node_Str"").append(include_servlet_path).append(""String_Node_Str"");
    txt.append(""String_Node_Str"");
    txt.append(""String_Node_Str"").append(include_path_info).append(""String_Node_Str"");
    txt.append(""String_Node_Str"");
    txt.append(""String_Node_Str"").append(include_query_string).append(""String_Node_Str"");
  }
  txt.append(""String_Node_Str"");
  txt.append(""String_Node_Str"").append(method_request_uri).append(""String_Node_Str"");
  txt.append(""String_Node_Str"");
  txt.append(""String_Node_Str"").append(method_context_path).append(""String_Node_Str"");
  txt.append(""String_Node_Str"");
  txt.append(""String_Node_Str"").append(method_servlet_path).append(""String_Node_Str"");
  txt.append(""String_Node_Str"");
  txt.append(""String_Node_Str"").append(method_path_info).append(""String_Node_Str"");
  txt.append(""String_Node_Str"");
  txt.append(""String_Node_Str"").append(method_query_string).append(""String_Node_Str"");
  txt.append(""String_Node_Str"");
  return txt.toString();
}","public String toMarkup(){
  StringBuilder txt=new StringBuilder(128);
  txt.append(""String_Node_Str"");
  txt.append(""String_Node_Str"").append(caller).append(""String_Node_Str"");
  txt.append(""String_Node_Str"");
  txt.append(""String_Node_Str"").append(type).append(""String_Node_Str"");
  txt.append(""String_Node_Str"");
  if ((async_request_uri == null) && (async_context_path == null) && (async_servlet_path == null)&& (async_path_info == null)&& (async_query_string == null)) {
    txt.append(""String_Node_Str"");
  }
 else {
    txt.append(""String_Node_Str"").append(async_request_uri).append(""String_Node_Str"");
    txt.append(""String_Node_Str"");
    txt.append(""String_Node_Str"").append(async_context_path).append(""String_Node_Str"");
    txt.append(""String_Node_Str"");
    txt.append(""String_Node_Str"").append(async_servlet_path).append(""String_Node_Str"");
    txt.append(""String_Node_Str"");
    txt.append(""String_Node_Str"").append(async_path_info).append(""String_Node_Str"");
    txt.append(""String_Node_Str"");
    txt.append(""String_Node_Str"").append(async_query_string).append(""String_Node_Str"");
  }
  txt.append(""String_Node_Str"");
  txt.append(""String_Node_Str"").append(isAsyncSupported).append(""String_Node_Str"");
  txt.append(""String_Node_Str"");
  if ((forward_request_uri == null) && (forward_context_path == null) && (forward_servlet_path == null)&& (forward_path_info == null)&& (forward_query_string == null)) {
    txt.append(""String_Node_Str"");
  }
 else {
    txt.append(""String_Node_Str"").append(forward_request_uri).append(""String_Node_Str"");
    txt.append(""String_Node_Str"");
    txt.append(""String_Node_Str"").append(forward_context_path).append(""String_Node_Str"");
    txt.append(""String_Node_Str"");
    txt.append(""String_Node_Str"").append(forward_servlet_path).append(""String_Node_Str"");
    txt.append(""String_Node_Str"");
    txt.append(""String_Node_Str"").append(forward_path_info).append(""String_Node_Str"");
    txt.append(""String_Node_Str"");
    txt.append(""String_Node_Str"").append(forward_query_string).append(""String_Node_Str"");
  }
  txt.append(""String_Node_Str"");
  if ((include_request_uri == null) && (include_context_path == null) && (include_servlet_path == null)&& (include_path_info == null)&& (include_query_string == null)) {
    txt.append(""String_Node_Str"");
  }
 else {
    txt.append(""String_Node_Str"").append(include_request_uri).append(""String_Node_Str"");
    txt.append(""String_Node_Str"");
    txt.append(""String_Node_Str"").append(include_context_path).append(""String_Node_Str"");
    txt.append(""String_Node_Str"");
    txt.append(""String_Node_Str"").append(include_servlet_path).append(""String_Node_Str"");
    txt.append(""String_Node_Str"");
    txt.append(""String_Node_Str"").append(include_path_info).append(""String_Node_Str"");
    txt.append(""String_Node_Str"");
    txt.append(""String_Node_Str"").append(include_query_string).append(""String_Node_Str"");
  }
  txt.append(""String_Node_Str"");
  txt.append(""String_Node_Str"").append(method_request_uri).append(""String_Node_Str"");
  txt.append(""String_Node_Str"");
  txt.append(""String_Node_Str"").append(method_context_path).append(""String_Node_Str"");
  txt.append(""String_Node_Str"");
  txt.append(""String_Node_Str"").append(method_servlet_path).append(""String_Node_Str"");
  txt.append(""String_Node_Str"");
  txt.append(""String_Node_Str"").append(method_path_info).append(""String_Node_Str"");
  txt.append(""String_Node_Str"");
  txt.append(""String_Node_Str"").append(method_path_xlated).append(""String_Node_Str"");
  txt.append(""String_Node_Str"");
  txt.append(""String_Node_Str"").append(method_query_string).append(""String_Node_Str"");
  txt.append(""String_Node_Str"");
  return txt.toString();
}",0.9835339698353396
90591,"@RenderMethod(portletNames={""String_Node_Str""},ordinal=100) public String getImageInclude(){
  StringBuilder txt=new StringBuilder(128);
  txt.append(""String_Node_Str"");
  txt.append(""String_Node_Str"");
  ResourceURL resurl=uf.createResourceURL();
  txt.append(""String_Node_Str"").append(pid).append(""String_Node_Str"");
  txt.append(""String_Node_Str"");
  txt.append(""String_Node_Str"");
  txt.append(""String_Node_Str"");
  txt.append(""String_Node_Str"");
  txt.append(""String_Node_Str"");
  txt.append(""String_Node_Str"").append(pid).append(""String_Node_Str"");
  txt.append(""String_Node_Str"");
  txt.append(""String_Node_Str"");
  txt.append(""String_Node_Str"").append(resurl.toString()).append(""String_Node_Str"");
  txt.append(""String_Node_Str"");
  txt.append(""String_Node_Str"");
  txt.append(""String_Node_Str"");
  txt.append(""String_Node_Str"");
  resurl=uf.createResourceURL();
  resurl.setResourceID(""String_Node_Str"");
  txt.append(""String_Node_Str"").append(pid).append(""String_Node_Str"");
  txt.append(""String_Node_Str"");
  txt.append(""String_Node_Str"");
  txt.append(""String_Node_Str"");
  txt.append(""String_Node_Str"");
  txt.append(""String_Node_Str"");
  txt.append(""String_Node_Str"").append(pid).append(""String_Node_Str"");
  txt.append(""String_Node_Str"");
  txt.append(""String_Node_Str"");
  txt.append(""String_Node_Str"").append(resurl.toString()).append(""String_Node_Str"");
  txt.append(""String_Node_Str"");
  txt.append(""String_Node_Str"");
  txt.append(""String_Node_Str"");
  return txt.toString();
}","@RenderMethod(portletNames={""String_Node_Str""},ordinal=100) public void getImageInclude(RenderRequest req,RenderResponse resp) throws IOException {
  resp.setContentType(""String_Node_Str"");
  PrintWriter writer=resp.getWriter();
  writer.append(""String_Node_Str"");
  writer.append(""String_Node_Str"");
  ResourceURL resurl=uf.createResourceURL();
  writer.append(""String_Node_Str"").append(pid).append(""String_Node_Str"");
  writer.append(""String_Node_Str"");
  writer.append(""String_Node_Str"");
  writer.append(""String_Node_Str"");
  writer.append(""String_Node_Str"");
  writer.append(""String_Node_Str"");
  writer.append(""String_Node_Str"").append(pid).append(""String_Node_Str"");
  writer.append(""String_Node_Str"");
  writer.append(""String_Node_Str"");
  writer.append(""String_Node_Str"").append(resurl.toString()).append(""String_Node_Str"");
  writer.append(""String_Node_Str"");
  writer.append(""String_Node_Str"");
  writer.append(""String_Node_Str"");
  writer.append(""String_Node_Str"");
  resurl=uf.createResourceURL();
  resurl.setResourceID(""String_Node_Str"");
  writer.append(""String_Node_Str"").append(pid).append(""String_Node_Str"");
  writer.append(""String_Node_Str"");
  writer.append(""String_Node_Str"");
  writer.append(""String_Node_Str"");
  writer.append(""String_Node_Str"");
  writer.append(""String_Node_Str"");
  writer.append(""String_Node_Str"").append(pid).append(""String_Node_Str"");
  writer.append(""String_Node_Str"");
  writer.append(""String_Node_Str"");
  writer.append(""String_Node_Str"").append(resurl.toString()).append(""String_Node_Str"");
  writer.append(""String_Node_Str"");
  writer.append(""String_Node_Str"");
  writer.append(""String_Node_Str"");
  PortletRequestDispatcher rd=req.getPortletContext().getNamedDispatcher(""String_Node_Str"");
  try {
    rd.include(req,resp);
  }
 catch (  Exception e) {
    writer.append(""String_Node_Str"");
    writer.append(""String_Node_Str"").append(e.toString());
    writer.append(""String_Node_Str"");
  }
}",0.2067963984896892
90592,"/** 
 * Dispatch the request to the appropriate portlet methods. This method assumes that the following attributes are set in the servlet request scope: <ul> <li>METHOD_ID: indicating which method to dispatch.</li> <li>PORTLET_REQUEST: the internal portlet request.</li> <li>PORTLET_RESPONSE: the internal portlet response.</li> </ul>
 * @param request the servlet request.
 * @param response the servlet response.
 * @throws ServletException
 * @throws IOException
 */
private void dispatch(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException {
  if (LOG.isDebugEnabled()) {
    StringBuilder txt=new StringBuilder();
    txt.append(""String_Node_Str"");
    txt.append(""String_Node_Str"").append(request.getDispatcherType());
    txt.append(""String_Node_Str"").append(request.getRequestURI());
    LOG.debug(txt.toString());
  }
  if (invoker == null) {
    throw new javax.servlet.UnavailableException(""String_Node_Str"" + portletName + ""String_Node_Str"");
  }
  Integer methodId=(Integer)request.getAttribute(PortletInvokerService.METHOD_ID);
  final PortletRequest portletRequest=(PortletRequest)request.getAttribute(PortletInvokerService.PORTLET_REQUEST);
  final PortletResponse portletResponse=(PortletResponse)request.getAttribute(PortletInvokerService.PORTLET_RESPONSE);
  final PortletRequestContext requestContext=(PortletRequestContext)portletRequest.getAttribute(PortletInvokerService.REQUEST_CONTEXT);
  final PortletResponseContext responseContext=(PortletResponseContext)portletRequest.getAttribute(PortletInvokerService.RESPONSE_CONTEXT);
  final FilterManager filterManager=(FilterManager)request.getAttribute(PortletInvokerService.FILTER_MANAGER);
  if (LOG.isTraceEnabled()) {
    StringBuilder txt=new StringBuilder(128);
    txt.append(""String_Node_Str"");
    ServletRequest wreq=request;
    ServletRequest tstreq=requestContext.getServletRequest();
    int n=1;
    while (wreq instanceof ServletRequestWrapper) {
      txt.append(""String_Node_Str"").append(n++).append(""String_Node_Str"").append(wreq.getClass().getCanonicalName());
      txt.append(""String_Node_Str"").append(wreq.getDispatcherType());
      txt.append(""String_Node_Str"").append(wreq == tstreq);
      wreq=((ServletRequestWrapper)wreq).getRequest();
    }
    txt.append(""String_Node_Str"").append(n++).append(""String_Node_Str"").append(wreq.getClass().getCanonicalName());
    txt.append(""String_Node_Str"").append(wreq.getDispatcherType());
    txt.append(""String_Node_Str"").append(wreq == tstreq);
    txt.append(""String_Node_Str"");
    ServletResponse wresp=response;
    ServletResponse tstresp=requestContext.getServletResponse();
    n=1;
    while (wresp instanceof ServletResponseWrapper) {
      txt.append(""String_Node_Str"").append(n++).append(""String_Node_Str"").append(wresp.getClass().getCanonicalName());
      txt.append(""String_Node_Str"").append(wresp == tstresp);
      wresp=((ServletResponseWrapper)wresp).getResponse();
    }
    txt.append(""String_Node_Str"").append(n++).append(""String_Node_Str"").append(wresp.getClass().getCanonicalName());
    txt.append(""String_Node_Str"").append(wresp == tstresp);
    LOG.debug(txt.toString());
  }
  if (request.getDispatcherType() == DispatcherType.ASYNC) {
    ServletRequest wreq=request;
    while ((wreq instanceof ServletRequestWrapper) && !(wreq instanceof PortletAsyncRequestWrapper)) {
      wreq=((ServletRequestWrapper)wreq).getRequest();
    }
    if (wreq instanceof PortletAsyncRequestWrapper) {
      HttpServletRequest hreq=(HttpServletRequest)((PortletAsyncRequestWrapper)wreq).getRequest();
      HttpServletResponse hresp=requestContext.getServletResponse();
      LOG.debug(""String_Node_Str"" + hreq.getDispatcherType());
      requestContext.init(portletConfig,getServletContext(),hreq,hresp);
      responseContext.init(hreq,hresp);
    }
 else {
      LOG.debug(""String_Node_Str"");
    }
  }
 else {
    requestContext.init(portletConfig,getServletContext(),request,response);
    responseContext.init(request,response);
  }
  PortletWindow window=requestContext.getPortletWindow();
  PortletInvocationEvent event=new PortletInvocationEvent(portletRequest,window,methodId.intValue());
  notify(event,true,null);
  try {
    if (methodId == PortletInvokerService.METHOD_RENDER) {
      RenderRequest renderRequest=(RenderRequest)portletRequest;
      String rh=requestContext.getRenderHeaders();
      if (rh != null) {
        renderRequest.setAttribute(PortletRequest.RENDER_PART,rh);
      }
      RenderResponse renderResponse=(RenderResponse)portletResponse;
      filterManager.processFilter(renderRequest,renderResponse,invoker,portletContext);
    }
 else     if (methodId == PortletInvokerService.METHOD_HEADER) {
      HeaderRequest headerRequest=(HeaderRequest)portletRequest;
      HeaderResponse headerResponse=(HeaderResponse)portletResponse;
      filterManager.processFilter(headerRequest,headerResponse,invoker,portletContext);
    }
 else     if (methodId == PortletInvokerService.METHOD_RESOURCE) {
      ResourceRequest resourceRequest=(ResourceRequest)portletRequest;
      PortletResourceRequestContext rc=(PortletResourceRequestContext)requestContext;
      String ps=rc.getPageState();
      if (ps != null) {
        resourceRequest.setAttribute(ResourceRequest.PAGE_STATE,ps);
      }
      ResourceResponse resourceResponse=(ResourceResponse)portletResponse;
      filterManager.processFilter(resourceRequest,resourceResponse,invoker,portletContext);
    }
 else     if (methodId == PortletInvokerService.METHOD_ACTION) {
      ActionRequest actionRequest=(ActionRequest)portletRequest;
      ActionResponse actionResponse=(ActionResponse)portletResponse;
      filterManager.processFilter(actionRequest,actionResponse,invoker,portletContext);
    }
 else     if (methodId == PortletInvokerService.METHOD_EVENT) {
      EventRequest eventRequest=(EventRequest)portletRequest;
      EventResponse eventResponse=(EventResponse)portletResponse;
      filterManager.processFilter(eventRequest,eventResponse,invoker,portletContext);
    }
 else     if (methodId == PortletInvokerService.METHOD_ADMIN) {
      PortalAdministrationService pas=PlutoServices.getServices().getPortalAdministrationService();
      for (      AdministrativeRequestListener l : pas.getAdministrativeRequestListeners()) {
        l.administer(portletRequest,portletResponse);
      }
    }
 else     if (methodId == PortletInvokerService.METHOD_LOAD) {
    }
    notify(event,false,null);
  }
 catch (  UnavailableException ex) {
    try {
      invoker.destroy();
    }
 catch (    Throwable th) {
      this.getServletContext().log(""String_Node_Str"",th);
    }
    invoker=null;
    throw new javax.servlet.UnavailableException(ex.getMessage());
  }
catch (  PortletException ex) {
    notify(event,false,ex);
    throw new ServletException(ex);
  }
 finally {
    if (!request.isAsyncStarted() && (request.getDispatcherType() != DispatcherType.ASYNC)) {
      request.removeAttribute(PortletInvokerService.METHOD_ID);
      request.removeAttribute(PortletInvokerService.PORTLET_REQUEST);
      request.removeAttribute(PortletInvokerService.PORTLET_RESPONSE);
      request.removeAttribute(PortletInvokerService.FILTER_MANAGER);
    }
  }
}","/** 
 * Dispatch the request to the appropriate portlet methods. This method assumes that the following attributes are set in the servlet request scope: <ul> <li>METHOD_ID: indicating which method to dispatch.</li> <li>PORTLET_REQUEST: the internal portlet request.</li> <li>PORTLET_RESPONSE: the internal portlet response.</li> </ul>
 * @param request the servlet request.
 * @param response the servlet response.
 * @throws ServletException
 * @throws IOException
 */
private void dispatch(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException {
  if (LOG.isDebugEnabled()) {
    StringBuilder txt=new StringBuilder();
    txt.append(""String_Node_Str"");
    txt.append(""String_Node_Str"").append(request.getDispatcherType());
    txt.append(""String_Node_Str"").append(request.getRequestURI());
    LOG.debug(txt.toString());
  }
  if (invoker == null) {
    throw new javax.servlet.UnavailableException(""String_Node_Str"" + portletName + ""String_Node_Str"");
  }
  Integer methodId=(Integer)request.getAttribute(PortletInvokerService.METHOD_ID);
  final PortletRequest portletRequest=(PortletRequest)request.getAttribute(PortletInvokerService.PORTLET_REQUEST);
  final PortletResponse portletResponse=(PortletResponse)request.getAttribute(PortletInvokerService.PORTLET_RESPONSE);
  final PortletRequestContext requestContext=(PortletRequestContext)portletRequest.getAttribute(PortletInvokerService.REQUEST_CONTEXT);
  final PortletResponseContext responseContext=(PortletResponseContext)portletRequest.getAttribute(PortletInvokerService.RESPONSE_CONTEXT);
  final FilterManager filterManager=(FilterManager)request.getAttribute(PortletInvokerService.FILTER_MANAGER);
  if (LOG.isTraceEnabled()) {
    StringBuilder txt=new StringBuilder(128);
    txt.append(""String_Node_Str"");
    ServletRequest wreq=request;
    ServletRequest tstreq=requestContext.getServletRequest();
    int n=1;
    while (wreq instanceof ServletRequestWrapper) {
      txt.append(""String_Node_Str"").append(n++).append(""String_Node_Str"").append(wreq.getClass().getCanonicalName());
      txt.append(""String_Node_Str"").append(wreq.getDispatcherType());
      txt.append(""String_Node_Str"").append(wreq == tstreq);
      wreq=((ServletRequestWrapper)wreq).getRequest();
    }
    txt.append(""String_Node_Str"").append(n++).append(""String_Node_Str"").append(wreq.getClass().getCanonicalName());
    txt.append(""String_Node_Str"").append(wreq.getDispatcherType());
    txt.append(""String_Node_Str"").append(wreq == tstreq);
    txt.append(""String_Node_Str"");
    ServletResponse wresp=response;
    ServletResponse tstresp=requestContext.getServletResponse();
    n=1;
    while (wresp instanceof ServletResponseWrapper) {
      txt.append(""String_Node_Str"").append(n++).append(""String_Node_Str"").append(wresp.getClass().getCanonicalName());
      txt.append(""String_Node_Str"").append(wresp == tstresp);
      wresp=((ServletResponseWrapper)wresp).getResponse();
    }
    txt.append(""String_Node_Str"").append(n++).append(""String_Node_Str"").append(wresp.getClass().getCanonicalName());
    txt.append(""String_Node_Str"").append(wresp == tstresp);
    LOG.debug(txt.toString());
  }
  if (request.getDispatcherType() == DispatcherType.ASYNC) {
    ServletRequest wreq=request;
    while ((wreq instanceof ServletRequestWrapper) && !(wreq instanceof PortletAsyncRequestWrapper)) {
      wreq=((ServletRequestWrapper)wreq).getRequest();
    }
    if (wreq instanceof PortletAsyncRequestWrapper) {
      HttpServletRequest hreq=(HttpServletRequest)((PortletAsyncRequestWrapper)wreq).getRequest();
      HttpServletResponse hresp=requestContext.getServletResponse();
      LOG.debug(""String_Node_Str"" + hreq.getDispatcherType());
      requestContext.init(portletConfig,getServletContext(),hreq,hresp);
      responseContext.init(hreq,hresp);
    }
 else {
      LOG.debug(""String_Node_Str"");
    }
  }
 else {
    requestContext.init(portletConfig,getServletContext(),request,response);
    requestContext.setExecutingRequestBody(true);
    responseContext.init(request,response);
  }
  PortletWindow window=requestContext.getPortletWindow();
  PortletInvocationEvent event=new PortletInvocationEvent(portletRequest,window,methodId.intValue());
  notify(event,true,null);
  try {
    if (methodId == PortletInvokerService.METHOD_RENDER) {
      RenderRequest renderRequest=(RenderRequest)portletRequest;
      String rh=requestContext.getRenderHeaders();
      if (rh != null) {
        renderRequest.setAttribute(PortletRequest.RENDER_PART,rh);
      }
      RenderResponse renderResponse=(RenderResponse)portletResponse;
      filterManager.processFilter(renderRequest,renderResponse,invoker,portletContext);
    }
 else     if (methodId == PortletInvokerService.METHOD_HEADER) {
      HeaderRequest headerRequest=(HeaderRequest)portletRequest;
      HeaderResponse headerResponse=(HeaderResponse)portletResponse;
      filterManager.processFilter(headerRequest,headerResponse,invoker,portletContext);
    }
 else     if (methodId == PortletInvokerService.METHOD_RESOURCE) {
      ResourceRequest resourceRequest=(ResourceRequest)portletRequest;
      PortletResourceRequestContext rc=(PortletResourceRequestContext)requestContext;
      String ps=rc.getPageState();
      if (ps != null) {
        resourceRequest.setAttribute(ResourceRequest.PAGE_STATE,ps);
      }
      ResourceResponse resourceResponse=(ResourceResponse)portletResponse;
      filterManager.processFilter(resourceRequest,resourceResponse,invoker,portletContext);
    }
 else     if (methodId == PortletInvokerService.METHOD_ACTION) {
      ActionRequest actionRequest=(ActionRequest)portletRequest;
      ActionResponse actionResponse=(ActionResponse)portletResponse;
      filterManager.processFilter(actionRequest,actionResponse,invoker,portletContext);
    }
 else     if (methodId == PortletInvokerService.METHOD_EVENT) {
      EventRequest eventRequest=(EventRequest)portletRequest;
      EventResponse eventResponse=(EventResponse)portletResponse;
      filterManager.processFilter(eventRequest,eventResponse,invoker,portletContext);
    }
 else     if (methodId == PortletInvokerService.METHOD_ADMIN) {
      PortalAdministrationService pas=PlutoServices.getServices().getPortalAdministrationService();
      for (      AdministrativeRequestListener l : pas.getAdministrativeRequestListeners()) {
        l.administer(portletRequest,portletResponse);
      }
    }
 else     if (methodId == PortletInvokerService.METHOD_LOAD) {
    }
    notify(event,false,null);
  }
 catch (  UnavailableException ex) {
    try {
      invoker.destroy();
    }
 catch (    Throwable th) {
      this.getServletContext().log(""String_Node_Str"",th);
    }
    invoker=null;
    throw new javax.servlet.UnavailableException(ex.getMessage());
  }
catch (  PortletException ex) {
    notify(event,false,ex);
    throw new ServletException(ex);
  }
 finally {
    requestContext.setExecutingRequestBody(false);
    if (!request.isAsyncStarted()) {
      LOG.debug(""String_Node_Str"" + requestContext.isExecutingRequestBody());
      if (request.getDispatcherType() != DispatcherType.ASYNC) {
        request.removeAttribute(PortletInvokerService.METHOD_ID);
        request.removeAttribute(PortletInvokerService.PORTLET_REQUEST);
        request.removeAttribute(PortletInvokerService.PORTLET_RESPONSE);
        request.removeAttribute(PortletInvokerService.FILTER_MANAGER);
      }
    }
 else {
      LOG.debug(""String_Node_Str"" + requestContext.isExecutingRequestBody());
    }
  }
}",0.9793737742611752
90593,"private void doDispatch(PortletRequest request,PortletResponse response,boolean included) throws PortletException, IOException {
  boolean needsFlushAfterForward=false;
  if (!included) {
    String lifecyclePhase=(String)request.getAttribute(PortletRequest.LIFECYCLE_PHASE);
    if (PortletRequest.RENDER_PHASE.equals(lifecyclePhase) || PortletRequest.RESOURCE_PHASE.equals(lifecyclePhase)) {
      needsFlushAfterForward=true;
      ((MimeResponse)response).resetBuffer();
    }
  }
  PortletRequestContext requestContext=(PortletRequestContext)request.getAttribute(PortletInvokerService.REQUEST_CONTEXT);
  HttpSession session=null;
  if (isPortletScopeSessionConfigured(requestContext)) {
    String portletWindowId=requestContext.getPortletWindow().getId().getStringId();
    session=ServletPortletSessionProxy.createProxy(requestContext.getServletRequest(),portletWindowId);
  }
  HttpServletPortletRequestWrapper req=new HttpServletPortletRequestWrapper(requestContext.getServletRequest(),requestContext.getServletContext(),session,request,included,namedDispatch);
  HttpServletPortletResponseWrapper res=new HttpServletPortletResponseWrapper(requestContext.getServletResponse(),request,response,included);
  try {
    request.setAttribute(PortletInvokerService.PORTLET_CONFIG,requestContext.getPortletConfig());
    request.setAttribute(PortletInvokerService.PORTLET_REQUEST,request);
    request.setAttribute(PortletInvokerService.PORTLET_RESPONSE,response);
    if (!included && req.isForwardingPossible()) {
      requestDispatcher.forward(req,res);
    }
 else {
      requestDispatcher.include(req,res);
    }
    if (needsFlushAfterForward) {
      ((MimeResponse)response).flushBuffer();
    }
  }
 catch (  ServletException sex) {
    if (sex.getRootCause() != null) {
      throw new PortletException(sex.getRootCause());
    }
    throw new PortletException(sex);
  }
 finally {
    request.removeAttribute(PortletInvokerService.PORTLET_CONFIG);
    request.removeAttribute(PortletInvokerService.PORTLET_REQUEST);
    request.removeAttribute(PortletInvokerService.PORTLET_RESPONSE);
  }
}","private void doDispatch(PortletRequest request,PortletResponse response,boolean included) throws PortletException, IOException {
  boolean needsFlushAfterForward=false;
  if (!included) {
    String lifecyclePhase=(String)request.getAttribute(PortletRequest.LIFECYCLE_PHASE);
    if (PortletRequest.RENDER_PHASE.equals(lifecyclePhase) || PortletRequest.RESOURCE_PHASE.equals(lifecyclePhase)) {
      needsFlushAfterForward=true;
      ((MimeResponse)response).resetBuffer();
    }
  }
  PortletRequestContext requestContext=(PortletRequestContext)request.getAttribute(PortletInvokerService.REQUEST_CONTEXT);
  HttpSession session=null;
  if (isPortletScopeSessionConfigured(requestContext)) {
    String portletWindowId=requestContext.getPortletWindow().getId().getStringId();
    session=ServletPortletSessionProxy.createProxy(requestContext.getServletRequest(),portletWindowId);
  }
  HttpServletPortletRequestWrapper req=new HttpServletPortletRequestWrapper(requestContext.getServletRequest(),requestContext.getServletContext(),session,request,included,namedDispatch);
  HttpServletPortletResponseWrapper res=new HttpServletPortletResponseWrapper(requestContext.getServletResponse(),request,response,included);
  boolean executingReqBody=requestContext.isExecutingRequestBody();
  requestContext.setExecutingRequestBody(false);
  try {
    request.setAttribute(PortletInvokerService.PORTLET_CONFIG,requestContext.getPortletConfig());
    request.setAttribute(PortletInvokerService.PORTLET_REQUEST,request);
    request.setAttribute(PortletInvokerService.PORTLET_RESPONSE,response);
    if (!included && req.isForwardingPossible()) {
      requestDispatcher.forward(req,res);
    }
 else {
      requestDispatcher.include(req,res);
    }
    if (needsFlushAfterForward) {
      ((MimeResponse)response).flushBuffer();
    }
  }
 catch (  ServletException sex) {
    if (sex.getRootCause() != null) {
      throw new PortletException(sex.getRootCause());
    }
    throw new PortletException(sex);
  }
 finally {
    request.removeAttribute(PortletInvokerService.PORTLET_CONFIG);
    request.removeAttribute(PortletInvokerService.PORTLET_REQUEST);
    request.removeAttribute(PortletInvokerService.PORTLET_RESPONSE);
    requestContext.setExecutingRequestBody(executingReqBody);
  }
}",0.9592347984513778
90594,"public void setResourceID(String resourceID){
  url.setCacheability(resourceID);
}","public void setResourceID(String resourceID){
  url.setResourceID(resourceID);
}",0.8888888888888888
90595,"/** 
 * Sets values based on form input
 */
@ActionMethod(portletName=""String_Node_Str"") public void handleDialog(ActionRequest req,ActionResponse resp) throws PortletException, IOException {
  msg=null;
  String strType=req.getActionParameters().getValue(PARAM_TYPE);
  if (strType != null) {
    try {
      type=OutputType.valueOf(strType);
    }
 catch (    Exception e) {
      msg=""String_Node_Str"" + strType;
    }
  }
  String strReps=req.getActionParameters().getValue(PARAM_REPS);
  if (strReps != null) {
    try {
      reps=Integer.parseInt(strReps);
      if (reps <= 0 || reps > 8)       throw new Exception(""String_Node_Str"");
    }
 catch (    Exception e) {
      msg=""String_Node_Str"";
    }
  }
  String strDelay=req.getActionParameters().getValue(PARAM_DELAY);
  if (strDelay != null) {
    try {
      delay=Integer.parseInt(strDelay);
      if (delay < 0)       throw new Exception(""String_Node_Str"");
    }
 catch (    Exception e) {
      msg=""String_Node_Str"";
    }
  }
  String auto=req.getActionParameters().getValue(PARAM_AUTO);
  if (auto != null) {
    autoDispatch=true;
  }
 else {
    autoDispatch=false;
    if (reps > 1) {
      msg=""String_Node_Str"";
      reps=1;
    }
  }
  String[] state={""String_Node_Str"" + delay,""String_Node_Str"" + reps,type.toString(),msg,""String_Node_Str"" + autoDispatch};
  LOGGER.fine(""String_Node_Str"" + Arrays.asList(state).toString());
}","/** 
 * Sets values based on form input
 */
@ActionMethod(portletName=""String_Node_Str"") public void handleDialog(ActionRequest req,ActionResponse resp) throws PortletException, IOException {
  msg=null;
  String strReps=req.getActionParameters().getValue(PARAM_REPS);
  if (strReps != null) {
    try {
      reps=Integer.parseInt(strReps);
      if (reps <= 0 || reps > 8)       throw new Exception(""String_Node_Str"");
    }
 catch (    Exception e) {
      msg=""String_Node_Str"";
    }
  }
  String strDelay=req.getActionParameters().getValue(PARAM_DELAY);
  if (strDelay != null) {
    try {
      delay=Integer.parseInt(strDelay);
      if (delay < 0)       throw new Exception(""String_Node_Str"");
    }
 catch (    Exception e) {
      msg=""String_Node_Str"";
    }
  }
  String strType=req.getActionParameters().getValue(PARAM_TYPE);
  if (strType != null) {
    try {
      type=OutputType.valueOf(strType);
      if (type == OutputType.FWD && reps > 1) {
        msg=""String_Node_Str"";
        reps=1;
      }
    }
 catch (    Exception e) {
      msg=""String_Node_Str"" + strType;
    }
  }
  String auto=req.getActionParameters().getValue(PARAM_AUTO);
  if (auto != null) {
    autoDispatch=true;
  }
 else {
    autoDispatch=false;
    if (reps > 1) {
      msg=""String_Node_Str"";
      reps=1;
    }
  }
  String[] state={""String_Node_Str"" + delay,""String_Node_Str"" + reps,type.toString(),msg,""String_Node_Str"" + autoDispatch};
  LOGGER.fine(""String_Node_Str"" + Arrays.asList(state).toString());
}",0.5728987993138936
90596,"@ServeResourceMethod(portletNames=""String_Node_Str"",asyncSupported=true) public void getResource(ResourceRequest req,ResourceResponse resp) throws IOException, PortletException {
  Integer reps=(Integer)req.getAttribute(ATTRIB_REPS);
  if (reps == null) {
    reps=adb.getReps();
  }
  boolean done=false;
  if (--reps <= 0 || !adb.isAutoDispatch()) {
    done=true;
  }
  req.setAttribute(ATTRIB_REPS,reps);
  Boolean auto=(Boolean)req.getAttribute(ATTRIB_AUTO);
  req.removeAttribute(ATTRIB_AUTO);
  if ((adb.getDelay() <= 0) || (auto != null)) {
    PortletRequestDispatcher rd;
    AsyncContext ctx=null;
    try {
      ctx=req.getAsyncContext();
    }
 catch (    Exception e) {
    }
    StringBuilder txt=new StringBuilder(128);
    txt.append(""String_Node_Str"");
    txt.append(""String_Node_Str"").append(adb.getDelay());
    txt.append(""String_Node_Str"").append(adb.getType());
    txt.append(""String_Node_Str"").append(reps);
    txt.append(""String_Node_Str"").append(adb.getReps());
    txt.append(""String_Node_Str"").append(adb.isAutoDispatch());
    txt.append(""String_Node_Str"").append(auto);
    txt.append(""String_Node_Str"").append((ctx == null) ? ""String_Node_Str"" : ""String_Node_Str"");
    LOGGER.fine(txt.toString());
switch (adb.getType()) {
case DISPATCH:
      LOGGER.fine(""String_Node_Str"");
    if (ctx != null) {
      ctx.dispatch(JSP);
    }
  break;
case FWD:
LOGGER.fine(""String_Node_Str"");
req.setAttribute(ATTRIB_TITLE,""String_Node_Str"");
rd=req.getPortletContext().getRequestDispatcher(JSP);
rd.forward(req,resp);
if (done && ctx != null) {
ctx.complete();
}
break;
case INC:
LOGGER.fine(""String_Node_Str"");
req.setAttribute(ATTRIB_TITLE,""String_Node_Str"");
rd=req.getPortletContext().getRequestDispatcher(JSP);
rd.include(req,resp);
if (done && ctx != null) {
ctx.complete();
}
break;
default :
LOGGER.fine(""String_Node_Str"");
txt.setLength(0);
txt.append(""String_Node_Str"");
txt.append(""String_Node_Str"").append(req.getDispatcherType().toString());
txt.append(""String_Node_Str"");
resp.getWriter().write(txt.toString());
if (done && ctx != null) {
ctx.complete();
}
break;
}
}
if (adb.getDelay() > 0 && (!done || auto == null)) {
AsyncContext ctx=req.startAsync();
ctx.setTimeout(4000);
OutputType type=adb.getType();
if (adb.isAutoDispatch()) {
type=OutputType.AUTO;
}
AsyncRunnable ar=new AsyncRunnable(ctx,adb.getDelay(),type,done);
ctx.start(ar);
}
}","@ServeResourceMethod(portletNames=""String_Node_Str"",asyncSupported=true) public void getResource(ResourceRequest req,ResourceResponse resp) throws IOException, PortletException {
  Boolean auto=(Boolean)req.getAttribute(ATTRIB_AUTO);
  if (auto == null) {
    auto=false;
  }
  req.removeAttribute(ATTRIB_AUTO);
  Integer reps=(Integer)req.getAttribute(ATTRIB_REPS);
  boolean done=false;
  if (reps == null) {
    reps=adb.getReps();
  }
  if (reps <= 0) {
    done=true;
  }
  StringBuilder txt=new StringBuilder(128);
  txt.append(""String_Node_Str"");
  txt.append(""String_Node_Str"").append(adb.getDelay());
  txt.append(""String_Node_Str"").append(adb.getType());
  txt.append(""String_Node_Str"").append(reps);
  txt.append(""String_Node_Str"").append(adb.getReps());
  txt.append(""String_Node_Str"").append(adb.isAutoDispatch());
  txt.append(""String_Node_Str"").append(auto);
  txt.append(""String_Node_Str"").append(done);
  LOGGER.fine(txt.toString());
  AsyncContext ctx=null;
  if (!done) {
    reps--;
    req.setAttribute(ATTRIB_REPS,reps);
    ctx=req.startAsync();
    ctx.setTimeout(4000);
  }
  if (auto || (adb.getDelay() <= 0)) {
    PortletRequestDispatcher rd;
    if (ctx == null) {
      try {
        ctx=req.getAsyncContext();
      }
 catch (      Exception e) {
        txt.setLength(0);
        txt.append(""String_Node_Str"").append(e.toString());
        LOGGER.warning(txt.toString());
        resp.getWriter().write(txt.toString());
        return;
      }
    }
    HttpServletRequest hreq=(HttpServletRequest)req.getAttribute(""String_Node_Str"");
{
      List<String> attrNames=Collections.list(hreq.getAttributeNames());
      StringBuilder txt2=new StringBuilder(128);
      txt2.append(""String_Node_Str"");
      txt2.append(""String_Node_Str"").append(attrNames);
      txt2.append(""String_Node_Str"").append((String)hreq.getAttribute(""String_Node_Str""));
      txt2.append(""String_Node_Str"").append((String)hreq.getAttribute(""String_Node_Str""));
      txt2.append(""String_Node_Str"").append((String)hreq.getAttribute(""String_Node_Str""));
      txt2.append(""String_Node_Str"").append((String)hreq.getAttribute(""String_Node_Str""));
      txt2.append(""String_Node_Str"").append((String)hreq.getAttribute(""String_Node_Str""));
      txt2.append(""String_Node_Str"").append((String)hreq.getAttribute(""String_Node_Str""));
      txt2.append(""String_Node_Str"").append((String)hreq.getAttribute(""String_Node_Str""));
      txt2.append(""String_Node_Str"").append((String)hreq.getAttribute(""String_Node_Str""));
      txt2.append(""String_Node_Str"").append((String)hreq.getAttribute(""String_Node_Str""));
      txt2.append(""String_Node_Str"").append((String)hreq.getAttribute(""String_Node_Str""));
      txt2.append(""String_Node_Str"").append((String)hreq.getAttribute(""String_Node_Str""));
      txt2.append(""String_Node_Str"").append((String)hreq.getAttribute(""String_Node_Str""));
      txt2.append(""String_Node_Str"").append((String)hreq.getAttribute(""String_Node_Str""));
      txt2.append(""String_Node_Str"").append((String)hreq.getAttribute(""String_Node_Str""));
      txt2.append(""String_Node_Str"").append((String)hreq.getAttribute(""String_Node_Str""));
      txt2.append(""String_Node_Str"").append(hreq.getRequestURI());
      txt2.append(""String_Node_Str"").append(hreq.getContextPath());
      txt2.append(""String_Node_Str"").append(hreq.getServletPath());
      txt2.append(""String_Node_Str"").append(hreq.getPathInfo());
      txt2.append(""String_Node_Str"").append(hreq.getQueryString());
      LOGGER.fine(txt2.toString());
    }
    PortletConfig config=(PortletConfig)req.getAttribute(""String_Node_Str"");
    String portletName=""String_Node_Str"";
    if (config != null) {
      portletName=config.getPortletName();
    }
switch (adb.getType()) {
case DISPATCH:
      LOGGER.fine(""String_Node_Str"");
    ctx.dispatch(JSP);
  break;
case FWD:
LOGGER.fine(""String_Node_Str"");
req.setAttribute(ATTRIB_TITLE,""String_Node_Str"");
rd=req.getPortletContext().getRequestDispatcher(JSP);
rd.forward(req,resp);
resp.flushBuffer();
if (!auto) {
ctx.complete();
}
break;
case INC:
LOGGER.fine(""String_Node_Str"");
req.setAttribute(ATTRIB_TITLE,""String_Node_Str"");
rd=req.getPortletContext().getRequestDispatcher(JSP);
rd.include(req,resp);
resp.flushBuffer();
if (!auto) {
ctx.complete();
}
break;
default :
LOGGER.fine(""String_Node_Str"");
txt.setLength(0);
txt.append(""String_Node_Str"" + portletName + ""String_Node_Str"");
txt.append(""String_Node_Str"").append(req.getDispatcherType().toString());
txt.append(""String_Node_Str"");
resp.getWriter().write(txt.toString());
resp.flushBuffer();
if (!auto) {
ctx.complete();
}
break;
}
}
if (adb.getDelay() > 0 && req.isAsyncStarted()) {
OutputType type=adb.getType();
if (adb.isAutoDispatch()) {
type=OutputType.AUTO;
}
AsyncRunnable ar=new AsyncRunnable(ctx,adb.getDelay(),type,(reps <= 0));
ctx.start(ar);
}
}",0.3798449612403101
90597,"@Override public void run(){
  try {
    Thread.sleep(delay);
    HttpServletRequest hreq=(HttpServletRequest)ctx.getRequest();
    HttpServletResponse hresp=(HttpServletResponse)ctx.getResponse();
    RequestDispatcher rd;
switch (type) {
case TEXT:
      LOGGER.fine(""String_Node_Str"");
    StringBuilder txt=new StringBuilder(128);
  txt.append(""String_Node_Str"");
txt.append(""String_Node_Str"").append(hreq.getDispatcherType().toString());
txt.append(""String_Node_Str"");
hresp.getWriter().write(txt.toString());
if (done) {
ctx.complete();
}
break;
case AUTO:
LOGGER.fine(""String_Node_Str"");
hreq.setAttribute(ATTRIB_AUTO,new Boolean(true));
ctx.dispatch();
break;
case DISPATCH:
LOGGER.fine(""String_Node_Str"");
hreq.setAttribute(ATTRIB_TITLE,""String_Node_Str"");
ctx.dispatch(JSP);
break;
case FWD:
LOGGER.fine(""String_Node_Str"");
hreq.setAttribute(ATTRIB_TITLE,""String_Node_Str"");
rd=hreq.getRequestDispatcher(JSP);
rd.forward(hreq,hresp);
if (done) {
ctx.complete();
}
break;
case INC:
LOGGER.fine(""String_Node_Str"");
hreq.setAttribute(ATTRIB_TITLE,""String_Node_Str"");
rd=hreq.getRequestDispatcher(JSP);
rd.include(hreq,hresp);
if (done) {
ctx.complete();
}
break;
}
}
 catch (Exception e) {
LOGGER.warning(""String_Node_Str"" + e.toString());
}
}","@Override public void run(){
  try {
    Thread.sleep(delay);
    HttpServletRequest hreq=(HttpServletRequest)ctx.getRequest();
    HttpServletResponse hresp=(HttpServletResponse)ctx.getResponse();
    RequestDispatcher rd;
{
      List<String> attrNames=Collections.list(hreq.getAttributeNames());
      StringBuilder txt=new StringBuilder(128);
      txt.append(""String_Node_Str"");
      txt.append(""String_Node_Str"").append(attrNames);
      txt.append(""String_Node_Str"").append((String)hreq.getAttribute(""String_Node_Str""));
      txt.append(""String_Node_Str"").append((String)hreq.getAttribute(""String_Node_Str""));
      txt.append(""String_Node_Str"").append((String)hreq.getAttribute(""String_Node_Str""));
      txt.append(""String_Node_Str"").append((String)hreq.getAttribute(""String_Node_Str""));
      txt.append(""String_Node_Str"").append((String)hreq.getAttribute(""String_Node_Str""));
      txt.append(""String_Node_Str"").append((String)hreq.getAttribute(""String_Node_Str""));
      txt.append(""String_Node_Str"").append((String)hreq.getAttribute(""String_Node_Str""));
      txt.append(""String_Node_Str"").append((String)hreq.getAttribute(""String_Node_Str""));
      txt.append(""String_Node_Str"").append((String)hreq.getAttribute(""String_Node_Str""));
      txt.append(""String_Node_Str"").append((String)hreq.getAttribute(""String_Node_Str""));
      txt.append(""String_Node_Str"").append((String)hreq.getAttribute(""String_Node_Str""));
      txt.append(""String_Node_Str"").append((String)hreq.getAttribute(""String_Node_Str""));
      txt.append(""String_Node_Str"").append((String)hreq.getAttribute(""String_Node_Str""));
      txt.append(""String_Node_Str"").append((String)hreq.getAttribute(""String_Node_Str""));
      txt.append(""String_Node_Str"").append((String)hreq.getAttribute(""String_Node_Str""));
      txt.append(""String_Node_Str"").append(hreq.getRequestURI());
      txt.append(""String_Node_Str"").append(hreq.getContextPath());
      txt.append(""String_Node_Str"").append(hreq.getServletPath());
      txt.append(""String_Node_Str"").append(hreq.getPathInfo());
      txt.append(""String_Node_Str"").append(hreq.getQueryString());
      LOGGER.fine(txt.toString());
    }
    PortletConfig config=(PortletConfig)hreq.getAttribute(""String_Node_Str"");
    String portletName=""String_Node_Str"";
    if (config != null) {
      portletName=config.getPortletName();
    }
switch (type) {
case TEXT:
      LOGGER.fine(""String_Node_Str"");
    StringBuilder txt=new StringBuilder(128);
  txt.append(""String_Node_Str"" + portletName + ""String_Node_Str"");
txt.append(""String_Node_Str"").append(hreq.getDispatcherType().toString());
txt.append(""String_Node_Str"");
hresp.getWriter().write(txt.toString());
if (done) {
ctx.complete();
}
 else {
hresp.flushBuffer();
}
break;
case AUTO:
StringBuilder str=new StringBuilder(128);
str.append(""String_Node_Str"");
str.append(""String_Node_Str"").append(hreq.getServletContext().getContextPath());
str.append(""String_Node_Str"").append(hreq.getServletPath());
LOGGER.fine(str.toString());
hreq.setAttribute(ATTRIB_AUTO,new Boolean(true));
ctx.dispatch(hreq.getServletContext(),hreq.getServletPath());
break;
case DISPATCH:
LOGGER.fine(""String_Node_Str"");
hreq.setAttribute(ATTRIB_TITLE,""String_Node_Str"");
ctx.dispatch(hreq.getServletContext(),JSP);
break;
case FWD:
LOGGER.fine(""String_Node_Str"");
hreq.setAttribute(ATTRIB_TITLE,""String_Node_Str"");
rd=hreq.getRequestDispatcher(JSP);
rd.forward(hreq,hresp);
if (done) {
ctx.complete();
}
 else {
hresp.flushBuffer();
}
break;
case INC:
LOGGER.fine(""String_Node_Str"");
hreq.setAttribute(ATTRIB_TITLE,""String_Node_Str"");
rd=hreq.getRequestDispatcher(JSP);
rd.include(hreq,hresp);
if (done) {
ctx.complete();
}
 else {
hresp.flushBuffer();
}
break;
}
}
 catch (Exception e) {
LOGGER.warning(""String_Node_Str"" + e.toString());
}
}",0.3732645775485918
90598,"/** 
 * Sets values based on form input
 */
@ActionMethod(portletName=""String_Node_Str"") public void handleDialog(ActionRequest req,ActionResponse resp) throws PortletException, IOException {
  msg=null;
  String strReps=req.getActionParameters().getValue(PARAM_REPS);
  if (strReps != null) {
    try {
      reps=Integer.parseInt(strReps);
      if (reps <= 0 || reps > 8)       throw new Exception(""String_Node_Str"");
    }
 catch (    Exception e) {
      msg=""String_Node_Str"";
    }
  }
  String strDelay=req.getActionParameters().getValue(PARAM_DELAY);
  if (strDelay != null) {
    try {
      delay=Integer.parseInt(strDelay);
      if (delay < 0)       throw new Exception(""String_Node_Str"");
    }
 catch (    Exception e) {
      msg=""String_Node_Str"";
    }
  }
  String strType=req.getActionParameters().getValue(PARAM_TYPE);
  if (strType != null) {
    try {
      type=OutputType.valueOf(strType);
      if (type == OutputType.FWD && reps > 1) {
        msg=""String_Node_Str"";
        reps=1;
      }
    }
 catch (    Exception e) {
      msg=""String_Node_Str"" + strType;
    }
  }
  String auto=req.getActionParameters().getValue(PARAM_AUTO);
  if (auto != null) {
    autoDispatch=true;
  }
 else {
    autoDispatch=false;
    if (reps > 1) {
      msg=""String_Node_Str"";
      reps=1;
    }
  }
  String[] state={""String_Node_Str"" + delay,""String_Node_Str"" + reps,type.toString(),msg,""String_Node_Str"" + autoDispatch};
  LOGGER.fine(""String_Node_Str"" + Arrays.asList(state).toString());
}","/** 
 * Sets values based on form input
 */
@ActionMethod(portletName=""String_Node_Str"") public void handleDialog(ActionRequest req,ActionResponse resp) throws PortletException, IOException {
  msg=null;
  String strReps=req.getActionParameters().getValue(PARAM_REPS);
  if (strReps != null) {
    try {
      reps=Integer.parseInt(strReps);
      if (reps <= 0 || reps > 8)       throw new Exception(""String_Node_Str"");
    }
 catch (    Exception e) {
      msg=""String_Node_Str"";
    }
  }
  String strDelay=req.getActionParameters().getValue(PARAM_DELAY);
  if (strDelay != null) {
    try {
      delay=Integer.parseInt(strDelay);
      if (delay < 0)       throw new Exception(""String_Node_Str"");
    }
 catch (    Exception e) {
      msg=""String_Node_Str"";
    }
  }
  String strType=req.getActionParameters().getValue(PARAM_TYPE);
  if (strType != null) {
    try {
      type=OutputType.valueOf(strType);
      if (reps > 1) {
        if ((type == OutputType.FWD) || (type == OutputType.DISPATCH)) {
          msg=""String_Node_Str"";
          reps=1;
        }
      }
    }
 catch (    Exception e) {
      msg=""String_Node_Str"" + strType;
    }
  }
  String auto=req.getActionParameters().getValue(PARAM_AUTO);
  if (auto != null) {
    autoDispatch=true;
  }
 else {
    autoDispatch=false;
    if (reps > 1) {
      msg=""String_Node_Str"";
      reps=1;
    }
  }
  String[] state={""String_Node_Str"" + delay,""String_Node_Str"" + reps,type.toString(),msg,""String_Node_Str"" + autoDispatch};
  LOGGER.fine(""String_Node_Str"" + Arrays.asList(state).toString());
}",0.940565118544982
90599,"@ServeResourceMethod(portletNames=""String_Node_Str"",asyncSupported=true) public void getResource(ResourceRequest req,ResourceResponse resp) throws IOException, PortletException {
  Boolean auto=(Boolean)req.getAttribute(ATTRIB_AUTO);
  if (auto == null) {
    auto=false;
  }
  req.removeAttribute(ATTRIB_AUTO);
  Integer reps=(Integer)req.getAttribute(ATTRIB_REPS);
  if (reps == null) {
    reps=adb.getReps();
  }
  StringBuilder txt=new StringBuilder(128);
  txt.append(""String_Node_Str"");
  txt.append(""String_Node_Str"").append(adb.getDelay());
  txt.append(""String_Node_Str"").append(adb.getType());
  txt.append(""String_Node_Str"").append(reps);
  txt.append(""String_Node_Str"").append(adb.getReps());
  txt.append(""String_Node_Str"").append(adb.isAutoDispatch());
  txt.append(""String_Node_Str"").append(auto);
  LOGGER.fine(txt.toString());
  AsyncContext ctx=null;
  if (reps > 0) {
    reps--;
    req.setAttribute(ATTRIB_REPS,reps);
    ctx=req.startAsync();
    ctx.setTimeout(4000);
  }
  if (auto || (adb.getDelay() <= 0)) {
    PortletRequestDispatcher rd;
    if (ctx == null) {
      LOGGER.fine(""String_Node_Str"");
      try {
        ctx=req.getAsyncContext();
      }
 catch (      Exception e) {
        txt.setLength(0);
        txt.append(""String_Node_Str"").append(e.toString());
        LOGGER.warning(txt.toString());
        resp.getWriter().write(txt.toString());
        return;
      }
    }
    HttpServletRequest hreq=(HttpServletRequest)req.getAttribute(""String_Node_Str"");
    trace(hreq,""String_Node_Str"");
    PortletConfig config=(PortletConfig)req.getAttribute(""String_Node_Str"");
    String portletName=""String_Node_Str"";
    if (config != null) {
      portletName=config.getPortletName();
    }
switch (adb.getType()) {
case DISPATCH:
      LOGGER.fine(""String_Node_Str"");
    ctx.dispatch(JSP);
  break;
case FWD:
LOGGER.fine(""String_Node_Str"");
req.setAttribute(ATTRIB_TITLE,""String_Node_Str"");
rd=req.getPortletContext().getRequestDispatcher(JSP);
rd.forward(req,resp);
resp.flushBuffer();
if (!auto) {
ctx.complete();
}
break;
case INC:
LOGGER.fine(""String_Node_Str"");
req.setAttribute(ATTRIB_TITLE,""String_Node_Str"");
rd=req.getPortletContext().getRequestDispatcher(JSP);
rd.include(req,resp);
resp.flushBuffer();
if (!auto) {
ctx.complete();
}
break;
default :
LOGGER.fine(""String_Node_Str"");
txt.setLength(0);
txt.append(""String_Node_Str"" + portletName + ""String_Node_Str"");
txt.append(""String_Node_Str"").append(req.getDispatcherType().toString());
txt.append(""String_Node_Str"");
resp.getWriter().write(txt.toString());
resp.flushBuffer();
if (!auto) {
ctx.complete();
}
break;
}
}
if (adb.getDelay() > 0 && req.isAsyncStarted()) {
OutputType type=adb.getType();
if (adb.isAutoDispatch()) {
type=OutputType.AUTO;
}
AsyncRunnable ar=new AsyncRunnable(ctx,adb.getDelay(),type);
ctx.start(ar);
}
}","@ServeResourceMethod(portletNames=""String_Node_Str"",asyncSupported=true) public void getResource(ResourceRequest req,ResourceResponse resp) throws IOException, PortletException {
  Boolean auto=(Boolean)req.getAttribute(ATTRIB_AUTO);
  if (auto == null) {
    auto=false;
  }
  req.removeAttribute(ATTRIB_AUTO);
  Integer reps=(Integer)req.getAttribute(ATTRIB_REPS);
  if (reps == null) {
    reps=adb.getReps();
  }
  boolean done=(reps <= 0) || (adb.getDelay() <= 0);
  reps--;
  req.setAttribute(ATTRIB_REPS,reps);
  StringBuilder txt=new StringBuilder(128);
  txt.append(""String_Node_Str"");
  txt.append(""String_Node_Str"").append(adb.getDelay());
  txt.append(""String_Node_Str"").append(adb.getType());
  txt.append(""String_Node_Str"").append(reps);
  txt.append(""String_Node_Str"").append(adb.getReps());
  txt.append(""String_Node_Str"").append(adb.isAutoDispatch());
  txt.append(""String_Node_Str"").append(auto);
  LOGGER.fine(txt.toString());
  AsyncContext ctx=req.startAsync();
  ctx.setTimeout(4000);
  if (auto || (adb.getDelay() <= 0)) {
    PortletRequestDispatcher rd;
    HttpServletRequest hreq=(HttpServletRequest)req.getAttribute(""String_Node_Str"");
    trace(hreq,""String_Node_Str"");
    PortletConfig config=(PortletConfig)req.getAttribute(""String_Node_Str"");
    String portletName=""String_Node_Str"";
    if (config != null) {
      portletName=config.getPortletName();
    }
switch (adb.getType()) {
case DISPATCH:
      LOGGER.fine(""String_Node_Str"");
    req.setAttribute(ATTRIB_TITLE,""String_Node_Str"");
  ctx.dispatch(hreq.getServletContext(),JSP);
break;
case FWD:
LOGGER.fine(""String_Node_Str"");
req.setAttribute(ATTRIB_TITLE,""String_Node_Str"");
rd=req.getPortletContext().getRequestDispatcher(JSP);
rd.forward(req,resp);
resp.flushBuffer();
if (done) {
ctx.complete();
}
break;
case INC:
LOGGER.fine(""String_Node_Str"");
req.setAttribute(ATTRIB_TITLE,""String_Node_Str"");
rd=req.getPortletContext().getRequestDispatcher(JSP);
rd.include(req,resp);
resp.flushBuffer();
if (done) {
ctx.complete();
}
break;
default :
LOGGER.fine(""String_Node_Str"");
txt.setLength(0);
txt.append(""String_Node_Str"" + portletName + ""String_Node_Str"");
txt.append(""String_Node_Str"").append(req.getDispatcherType().toString());
txt.append(""String_Node_Str"");
resp.getWriter().write(txt.toString());
resp.flushBuffer();
if (done) {
ctx.complete();
}
break;
}
}
if (!done) {
OutputType type=adb.getType();
if (adb.isAutoDispatch()) {
type=OutputType.AUTO;
}
AsyncRunnable ar=new AsyncRunnable(ctx,adb.getDelay(),type);
ctx.start(ar);
}
}",0.5071681251163657
90600,"private void dumpParameters(PortletRequest req){
  if (logger.isLoggable(Level.FINEST)) {
    StringBuilder sb=new StringBuilder();
    sb.append(""String_Node_Str"");
    Map<String,String[]> parms=req.getParameterMap();
    for (    String name : parms.keySet()) {
      sb.append(""String_Node_Str"").append(name);
      sb.append(""String_Node_Str"").append(Arrays.toString(parms.get(name)));
    }
    logger.finest(sb.toString());
  }
}","private void dumpParameters(String type,PortletParameters parms){
  if (logger.isLoggable(Level.FINEST)) {
    StringBuilder sb=new StringBuilder();
    sb.append(""String_Node_Str"").append(type).append(""String_Node_Str"");
    for (    String name : parms.getNames()) {
      sb.append(""String_Node_Str"").append(name);
      sb.append(""String_Node_Str"").append(Arrays.toString(parms.getValues(name)));
    }
    logger.finest(sb.toString());
  }
}",0.3968253968253968
90601,"public void processAction(ActionRequest req,ActionResponse resp) throws PortletException, IOException {
  dumpParameters(req);
  String[] vals=req.getParameterValues(PARAM_FG_COLOR);
  String r=""String_Node_Str"";
  String g=""String_Node_Str"";
  String b=""String_Node_Str"";
  if (vals != null) {
    for (    String v : vals) {
      if (v.equals(PARAM_FG_RED))       r=""String_Node_Str"";
      if (v.equals(PARAM_FG_GREEN))       g=""String_Node_Str"";
      if (v.equals(PARAM_FG_BLUE))       b=""String_Node_Str"";
    }
  }
  String clr=""String_Node_Str"" + r + g+ b;
  if (vals != null) {
    resp.setRenderParameter(PARAM_FG_COLOR,vals);
  }
  String subType=req.getParameter(PARAM_SUBTYPE);
  if (subType != null) {
    resp.setRenderParameter(PARAM_SUBTYPE,subType);
  }
  String text=req.getParameter(PARAM_MSG_INPUT);
  if (text != null) {
    resp.setRenderParameter(PARAM_MSG_INPUT,text);
  }
  String msg=text + DELIM + clr;
  Enumeration<QName> eqn=getPublishingEventQNames();
  if (eqn.hasMoreElements()) {
    QName qn=eqn.nextElement();
    resp.setEvent(qn,msg);
    logger.fine(""String_Node_Str"" + qn.toString());
  }
 else {
    logger.warning(""String_Node_Str"");
  }
  StringBuilder sb=new StringBuilder(""String_Node_Str"").append(Arrays.toString(vals));
  sb.append(""String_Node_Str"").append(subType);
  sb.append(""String_Node_Str"").append(text);
  logger.fine(sb.toString());
}","@ActionMethod(portletName=""String_Node_Str"",publishingEvents={@PortletQName(namespaceURI=""String_Node_Str"",localPart=""String_Node_Str"")}) public void processAction(ActionRequest req,ActionResponse resp) throws PortletException, IOException {
  dumpParameters(""String_Node_Str"",req.getActionParameters());
  dumpParameters(""String_Node_Str"",req.getRenderParameters());
  String[] vals=req.getActionParameters().getValues(PARAM_FG_COLOR);
  String r=""String_Node_Str"";
  String g=""String_Node_Str"";
  String b=""String_Node_Str"";
  if (vals != null) {
    for (    String v : vals) {
      if (v.equals(PARAM_FG_RED))       r=""String_Node_Str"";
      if (v.equals(PARAM_FG_GREEN))       g=""String_Node_Str"";
      if (v.equals(PARAM_FG_BLUE))       b=""String_Node_Str"";
    }
  }
  String clr=""String_Node_Str"" + r + g+ b;
  if (vals != null) {
    resp.getRenderParameters().setValues(PARAM_FG_COLOR,vals);
  }
  String subType=req.getActionParameters().getValue(PARAM_SUBTYPE);
  if (subType != null) {
    resp.getRenderParameters().setValue(PARAM_SUBTYPE,subType);
  }
  String text=req.getActionParameters().getValue(PARAM_MSG_INPUT);
  if (text != null) {
    resp.getRenderParameters().setValue(PARAM_MSG_INPUT,text);
  }
  String msg=text + DELIM + clr;
  Enumeration<QName> eqn=getPublishingEventQNames();
  if (eqn.hasMoreElements()) {
    QName qn=eqn.nextElement();
    resp.setEvent(qn,msg);
    logger.fine(""String_Node_Str"" + qn.toString());
  }
 else {
    logger.warning(""String_Node_Str"");
  }
  StringBuilder sb=new StringBuilder(""String_Node_Str"").append(Arrays.toString(vals));
  sb.append(""String_Node_Str"").append(subType);
  sb.append(""String_Node_Str"").append(text);
  logger.fine(sb.toString());
}",0.8429168005139737
90602,"@Override public void serveResource(ResourceRequest req,ResourceResponse resp) throws PortletException, IOException {
  resp.setContentType(""String_Node_Str"");
  PrintWriter writer=resp.getWriter();
  String pid=resp.getNamespace();
  Set<String> names=imgMap.keySet();
  String selType=req.getParameter(PARAM_SELTYPE);
  selType=(selType == null) ? PARAM_SELTYPE_RADIO : selType;
  String imgName=req.getParameter(PARAM_IMGNAME);
  imgName=(imgName == null) ? ""String_Node_Str"" : imgName;
  if (selType.equals(PARAM_SELTYPE_RADIO)) {
    for (    String name : names) {
      writer.write(""String_Node_Str"" + PARAM_IMGNAME + ""String_Node_Str""+ name+ ""String_Node_Str""+ (name.equals(imgName) ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str""+ name);
    }
  }
 else {
    writer.write(""String_Node_Str"" + pid + ""String_Node_Str""+ PARAM_IMGNAME+ ""String_Node_Str"");
    writer.write(""String_Node_Str"" + (""String_Node_Str"".equals(imgName) ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"");
    for (    String name : names) {
      writer.write(""String_Node_Str"" + name + ""String_Node_Str""+ (name.equals(imgName) ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str""+ name+ ""String_Node_Str"");
    }
    writer.write(""String_Node_Str"");
  }
}","@Override public void serveResource(ResourceRequest req,ResourceResponse resp) throws PortletException, IOException {
  resp.setContentType(""String_Node_Str"");
  PrintWriter writer=resp.getWriter();
  String pid=resp.getNamespace();
  Set<String> names=imgMap.keySet();
  String selType=req.getRenderParameters().getValue(PARAM_SELTYPE);
  selType=(selType == null) ? PARAM_SELTYPE_RADIO : selType;
  String imgName=req.getRenderParameters().getValue(PARAM_IMGNAME);
  imgName=(imgName == null) ? ""String_Node_Str"" : imgName;
  if (selType.equals(PARAM_SELTYPE_RADIO)) {
    for (    String name : names) {
      writer.write(""String_Node_Str"" + PARAM_IMGNAME + ""String_Node_Str""+ name+ ""String_Node_Str""+ (name.equals(imgName) ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str""+ name);
    }
  }
 else {
    writer.write(""String_Node_Str"" + pid + ""String_Node_Str""+ PARAM_IMGNAME+ ""String_Node_Str"");
    writer.write(""String_Node_Str"" + (""String_Node_Str"".equals(imgName) ? ""String_Node_Str"" : ""String_Node_Str"") + ""String_Node_Str"");
    for (    String name : names) {
      writer.write(""String_Node_Str"" + name + ""String_Node_Str""+ (name.equals(imgName) ? ""String_Node_Str"" : ""String_Node_Str"")+ ""String_Node_Str""+ name+ ""String_Node_Str"");
    }
    writer.write(""String_Node_Str"");
  }
}",0.9860031104199068
90603,"@Override public void processAction(ActionRequest req,ActionResponse resp) throws PortletException, IOException {
  String actionName=req.getParameter(""String_Node_Str"");
  logger.fine(""String_Node_Str"" + actionName);
  ArrayList<String> msgs=new ArrayList<String>();
  StringBuffer sb=new StringBuffer();
  sb.append(""String_Node_Str"" + ""String_Node_Str"");
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  msgs.add(sb.toString());
  resp.setRenderParameter(PARAM_NUM_MSGS,""String_Node_Str"");
  req.getPortletSession().setAttribute(ATTRIB_MSGS,msgs);
}","@Override public void processAction(ActionRequest req,ActionResponse resp) throws PortletException, IOException {
  String actionName=req.getActionParameters().getValue(ActionRequest.ACTION_NAME);
  logger.fine(""String_Node_Str"" + actionName);
  ArrayList<String> msgs=new ArrayList<String>();
  StringBuffer sb=new StringBuffer();
  sb.append(""String_Node_Str"" + ""String_Node_Str"");
  sb.append(""String_Node_Str"");
  sb.append(""String_Node_Str"");
  msgs.add(sb.toString());
  resp.getRenderParameters().setValue(PARAM_NUM_MSGS,""String_Node_Str"");
  req.getPortletSession().setAttribute(ATTRIB_MSGS,msgs);
}",0.935374149659864
90604,"@SuppressWarnings(""String_Node_Str"") @Override public void processEvent(EventRequest req,EventResponse resp) throws PortletException, IOException {
  ArrayList<String> msgs=(ArrayList<String>)req.getPortletSession().getAttribute(ATTRIB_MSGS);
  if (msgs == null) {
    msgs=new ArrayList<String>();
  }
  String[] msg;
  int numMsgs=0;
  try {
    numMsgs=Integer.parseInt(req.getParameter(PARAM_NUM_MSGS));
  }
 catch (  Exception e) {
  }
  if (numMsgs == 0) {
    msgs.clear();
  }
  logger.fine(""String_Node_Str"" + msgs.size());
  try {
    String val=(String)req.getEvent().getValue();
    msg=val.split(DELIM);
  }
 catch (  Exception e) {
    msg=new String[2];
    msg[0]=""String_Node_Str"";
    msg[1]=""String_Node_Str"";
  }
  String clr=req.getParameter(PARAM_COLOR);
  clr=(clr == null) ? ""String_Node_Str"" : clr;
  StringBuffer sb=new StringBuffer();
  sb.append(""String_Node_Str"" + msg[1] + ""String_Node_Str""+ clr+ ""String_Node_Str"");
  sb.append(""String_Node_Str"" + (msgs.size() + 1) + ""String_Node_Str""+ msg[0]);
  sb.append(""String_Node_Str"");
  msgs.add(sb.toString());
  logger.fine(""String_Node_Str"" + sb.toString());
  resp.setRenderParameter(PARAM_NUM_MSGS,Integer.toString(msgs.size()));
  req.getPortletSession().setAttribute(ATTRIB_MSGS,msgs);
}","@EventMethod(portletName=""String_Node_Str"",processingEvents={@PortletQName(namespaceURI=""String_Node_Str"",localPart=""String_Node_Str"")}) @Override public void processEvent(EventRequest req,EventResponse resp) throws PortletException, IOException {
  @SuppressWarnings(""String_Node_Str"") ArrayList<String> msgs=(ArrayList<String>)req.getPortletSession().getAttribute(ATTRIB_MSGS);
  if (msgs == null) {
    msgs=new ArrayList<String>();
  }
  String[] msg;
  int numMsgs=0;
  try {
    numMsgs=Integer.parseInt(req.getRenderParameters().getValue(PARAM_NUM_MSGS));
  }
 catch (  Exception e) {
  }
  if (numMsgs == 0) {
    msgs.clear();
  }
  logger.fine(""String_Node_Str"" + msgs.size());
  try {
    String val=(String)req.getEvent().getValue();
    msg=val.split(DELIM);
  }
 catch (  Exception e) {
    msg=new String[2];
    msg[0]=""String_Node_Str"";
    msg[1]=""String_Node_Str"";
  }
  String clr=req.getRenderParameters().getValue(PARAM_COLOR);
  clr=(clr == null) ? ""String_Node_Str"" : clr;
  StringBuffer sb=new StringBuffer();
  sb.append(""String_Node_Str"" + msg[1] + ""String_Node_Str""+ clr+ ""String_Node_Str"");
  sb.append(""String_Node_Str"" + (msgs.size() + 1) + ""String_Node_Str""+ msg[0]);
  sb.append(""String_Node_Str"");
  msgs.add(sb.toString());
  logger.fine(""String_Node_Str"" + sb.toString());
  resp.getRenderParameters().setValue(PARAM_NUM_MSGS,Integer.toString(msgs.size()));
  req.getPortletSession().setAttribute(ATTRIB_MSGS,msgs);
}",0.906284454244763
90605,"@Override public void serveResource(ResourceRequest req,ResourceResponse resp) throws PortletException, IOException {
  String key=req.getParameter(PARAM_IMGNAME);
  String imgDir=DEFAULT_IMAGE;
  if ((key != null) && imgMap.containsKey(key)) {
    imgDir=imgMap.get(key);
  }
  String bc=req.getParameter(PARAM_BORDER_COLOR);
  String imgStyle=""String_Node_Str"";
  if (bc != null) {
    imgStyle=""String_Node_Str"" + bc + ""String_Node_Str"";
  }
  String ctx=req.getContextPath();
  String ca=req.getCacheability();
  resp.setContentType(""String_Node_Str"");
  PrintWriter writer=resp.getWriter();
  String clr=req.getParameter(PARAM_COLOR);
  clr=(clr == null) ? ""String_Node_Str"" : clr;
  PortletURL aurl=null;
  String bmu=""String_Node_Str"";
  try {
    aurl=resp.createActionURL();
  }
 catch (  Exception e) {
  }
  if (aurl != null) {
    bmu=""String_Node_Str"" + aurl + ""String_Node_Str"";
  }
  writer.write(""String_Node_Str"" + clr + ""String_Node_Str"");
  writer.write(""String_Node_Str"" + clr + ""String_Node_Str"");
  writer.write(""String_Node_Str"" + clr + ""String_Node_Str"");
  writer.write(""String_Node_Str"" + ctx + imgDir+ ""String_Node_Str""+ imgStyle+ ""String_Node_Str"");
  writer.write(""String_Node_Str"" + clr + ""String_Node_Str"");
  writer.write(""String_Node_Str"" + bmu + ""String_Node_Str"");
  writer.write(""String_Node_Str"" + ca + ""String_Node_Str"");
  writer.write(""String_Node_Str"");
  writer.write(""String_Node_Str"");
  writer.write(""String_Node_Str"");
}","@Override public void serveResource(ResourceRequest req,ResourceResponse resp) throws PortletException, IOException {
  String key=req.getRenderParameters().getValue(PARAM_IMGNAME);
  String imgDir=DEFAULT_IMAGE;
  if ((key != null) && imgMap.containsKey(key)) {
    imgDir=imgMap.get(key);
  }
  String bc=req.getResourceParameters().getValue(PARAM_BORDER_COLOR);
  String imgStyle=""String_Node_Str"";
  if (bc != null) {
    imgStyle=""String_Node_Str"" + bc + ""String_Node_Str"";
  }
  String ctx=req.getContextPath();
  String ca=req.getCacheability();
  resp.setContentType(""String_Node_Str"");
  PrintWriter writer=resp.getWriter();
  String clr=req.getRenderParameters().getValue(PARAM_COLOR);
  clr=(clr == null) ? ""String_Node_Str"" : clr;
  PortletURL aurl=null;
  String bmu=""String_Node_Str"";
  try {
    aurl=resp.createActionURL();
  }
 catch (  Exception e) {
  }
  if (aurl != null) {
    bmu=""String_Node_Str"" + aurl + ""String_Node_Str"";
  }
  writer.write(""String_Node_Str"" + clr + ""String_Node_Str"");
  writer.write(""String_Node_Str"" + clr + ""String_Node_Str"");
  writer.write(""String_Node_Str"" + clr + ""String_Node_Str"");
  writer.write(""String_Node_Str"" + ctx + imgDir+ ""String_Node_Str""+ imgStyle+ ""String_Node_Str"");
  writer.write(""String_Node_Str"" + clr + ""String_Node_Str"");
  writer.write(""String_Node_Str"" + bmu + ""String_Node_Str"");
  writer.write(""String_Node_Str"" + ca + ""String_Node_Str"");
  writer.write(""String_Node_Str"");
  writer.write(""String_Node_Str"");
  writer.write(""String_Node_Str"");
}",0.9812583668005356
90606,"/** 
 * Sets the bean instance for all annotated methods that are members of a configured portlet class to ensure that all annotated methods of the portlet class use the same bean instance.
 * @param cls
 * @param beanInstance
 */
public void setPortletClassInstance(Class<?> cls,Object beanInstance){
  for (  List<AnnotatedMethod> list : methods.values()) {
    for (    AnnotatedMethod am : list) {
      if (am.getJavaMethod().getDeclaringClass().equals(cls)) {
        am.setPortletClassInstance(beanInstance);
      }
    }
  }
}","/** 
 * Sets the bean instance for all annotated methods for a given portlet that are members of  a configured portlet class to ensure that all annotated methods of the portlet class use  the same bean instance.
 * @param portletName      The portlet name
 * @param cls              The class
 * @param beanInstance     The instance to use
 */
public void setPortletClassInstance(String portletName,Class<?> cls,Object beanInstance){
  for (  MethodIdentifier mi : getMethodIDsForPortlet(portletName)) {
    List<AnnotatedMethod> list=methods.get(mi);
    for (    AnnotatedMethod am : list) {
      if (am.getJavaMethod().getDeclaringClass().equals(cls)) {
        am.setPortletClassInstance(beanInstance);
      }
    }
  }
}",0.7115689381933439
90607,"/** 
 * reconciles the given annotated method store containing the bean configuration with the configuration as read from the portlet deployment descriptor and  the corresponding type annotations. <p> Portlets that are defined in the bean config are added to the portlet application definition if not already present. Event reference information from the  annotations is verified and added to the corresponding portlet definition. <p> Methods from portlet classes definied in the portlet definitions are added to the annotated method store.
 * @param ams
 */
public void reconcileBeanConfig(AnnotatedMethodStore ams){
  if (isDebug) {
    StringBuilder txt=new StringBuilder();
    txt.append(""String_Node_Str"").append(ams.getPortletNames().toString());
    LOG.debug(txt.toString());
  }
  ams.setDefaultNamespace(pad.getDefaultNamespace());
  for (  String pn : ams.getPortletNames()) {
    PortletDefinition pd=pad.getPortlet(pn);
    if (pd == null) {
      pd=new PortletDefinitionImpl(pn,pad);
    }
    List<EventDefinitionReference> edrs=pd.getSupportedProcessingEvents();
    for (    QName qn : ams.getProcessingEventRefs(pn)) {
      EventDefinition ed=pad.getEventDefinition(qn);
      if (ed == null) {
        StringBuilder txt=new StringBuilder(128);
        txt.append(""String_Node_Str"");
        txt.append(""String_Node_Str"").append(pn);
        txt.append(""String_Node_Str"").append(qn);
        LOG.warn(txt.toString());
        MethodIdentifier mi=new MethodIdentifier(pd.getPortletName(),qn,MethodType.EVENT);
        ams.removeMethod(mi);
        continue;
      }
      EventDefinitionReference newedr=new EventDefinitionReferenceImpl(qn);
      if (!edrs.contains(newedr)) {
        pd.addSupportedProcessingEvent(newedr);
      }
    }
    edrs=pd.getSupportedPublishingEvents();
    for (    QName qn : ams.getPublishingEventRefs(pn)) {
      EventDefinition ed=pad.getEventDefinition(qn);
      if (ed == null) {
        StringBuilder txt=new StringBuilder(128);
        txt.append(""String_Node_Str"");
        txt.append(""String_Node_Str"").append(pn);
        txt.append(""String_Node_Str"").append(qn);
        LOG.warn(txt.toString());
        continue;
      }
      EventDefinitionReference newedr=new EventDefinitionReferenceImpl(qn);
      if (!edrs.contains(newedr)) {
        pd.addSupportedPublishingEvent(newedr);
      }
    }
    pad.addPortlet(pd);
  }
  List<PortletDefinition> badPortlets=new ArrayList<PortletDefinition>();
  for (  PortletDefinition pd : pad.getPortlets()) {
    Class<?> cls=null;
    String clsName=pd.getPortletClass();
    if (isValidIdentifier(clsName)) {
      Class<?> valClass=null;
      StringBuilder txt=new StringBuilder(128);
      try {
        ClassLoader cl=Thread.currentThread().getContextClassLoader();
        if (cl == null) {
          cl=this.getClass().getClassLoader();
        }
        valClass=cl.loadClass(clsName);
        if (Portlet.class.isAssignableFrom(valClass)) {
          cls=valClass;
        }
 else {
          txt.append(""String_Node_Str"");
        }
      }
 catch (      Exception e) {
        txt.append(""String_Node_Str"");
      }
 finally {
        if (cls == null) {
          txt.append(""String_Node_Str"").append(pd.getPortletName());
          txt.append(""String_Node_Str"").append(clsName);
          LOG.warn(txt.toString());
        }
      }
    }
    Object instance=null;
    if (cls != null) {
      StringBuilder txt=new StringBuilder(128);
      BeanManager bm=ams.getBeanMgr();
      if (bm == null) {
        txt.append(""String_Node_Str"");
      }
 else {
        Set<Bean<?>> beans=bm.getBeans(cls);
        if (beans == null || beans.size() == 0) {
          txt.append(""String_Node_Str"");
        }
 else {
          Bean<?> bean=bm.resolve(beans);
          if (bean == null) {
            txt.append(""String_Node_Str"");
          }
 else {
            instance=bm.getReference(bean,bean.getBeanClass(),bm.createCreationalContext(bean));
            if (instance == null) {
              txt.append(""String_Node_Str"");
            }
          }
        }
      }
      if (instance == null) {
        LOG.debug(""String_Node_Str"" + cls.getCanonicalName());
        try {
          instance=cls.newInstance();
        }
 catch (        Exception e) {
          txt.append(""String_Node_Str"").append(e.toString());
        }
      }
      if ((instance == null) && (txt.length() > 0)) {
        txt.append(""String_Node_Str"").append(pd.getPortletName());
        txt.append(""String_Node_Str"").append(cls);
        LOG.warn(txt.toString());
      }
    }
    if (instance != null) {
      ams.setPortletClassInstance(cls,instance);
      AnnotatedMethod am;
      am=getMethod(instance,""String_Node_Str"",METH_INI);
      if (am != null) {
        MethodIdentifier mi=new MethodIdentifier(pd.getPortletName(),""String_Node_Str"",MethodType.INIT);
        if (ams.getMethods(mi).size() == 0) {
          ams.addMethod(mi,am);
        }
      }
      am=getMethod(instance,""String_Node_Str"",METH_DES);
      if (am != null) {
        MethodIdentifier mi=new MethodIdentifier(pd.getPortletName(),""String_Node_Str"",MethodType.DESTROY);
        if (ams.getMethods(mi).size() == 0) {
          ams.addMethod(mi,am);
        }
      }
      am=getMethod(instance,""String_Node_Str"",METH_ACT);
      if (am != null) {
        MethodIdentifier mi=new MethodIdentifier(pd.getPortletName(),""String_Node_Str"",MethodType.ACTION);
        if (ams.getMethods(mi).size() == 0) {
          ams.addMethod(mi,am);
        }
      }
      am=getMethod(instance,""String_Node_Str"",METH_EVT);
      if (am != null) {
        MethodIdentifier mi=new MethodIdentifier(pd.getPortletName(),""String_Node_Str"",MethodType.EVENT);
        if (ams.getMethods(mi).size() == 0) {
          ams.addMethod(mi,am);
        }
      }
      am=getMethod(instance,""String_Node_Str"",METH_REN);
      if (am != null) {
        MethodIdentifier mi=new MethodIdentifier(pd.getPortletName(),""String_Node_Str"",MethodType.RENDER);
        if (ams.getMethods(mi).size() == 0) {
          ams.addMethod(mi,am);
        }
      }
      am=getMethod(instance,""String_Node_Str"",METH_HDR);
      if (am != null) {
        MethodIdentifier mi=new MethodIdentifier(pd.getPortletName(),""String_Node_Str"",MethodType.HEADER);
        if (ams.getMethods(mi).size() == 0) {
          ams.addMethod(mi,am);
        }
      }
      am=getMethod(instance,""String_Node_Str"",METH_RES);
      if (am != null) {
        MethodIdentifier mi=new MethodIdentifier(pd.getPortletName(),""String_Node_Str"",MethodType.RESOURCE);
        if (ams.getMethods(mi).size() == 0) {
          ams.addMethod(mi,am);
        }
      }
    }
    boolean methodsOK=false;
    for (    MethodIdentifier mi : ams.getMethodIDsForPortlet(pd.getPortletName())) {
      if ((mi.getType() == MethodType.RENDER) || (mi.getType() == MethodType.RESOURCE) || (mi.getType() == MethodType.HEADER)) {
        methodsOK=true;
        break;
      }
    }
    if (!methodsOK) {
      ams.removeMethodsForPortlet(pd.getPortletName());
      badPortlets.add(pd);
      StringBuilder txt=new StringBuilder();
      txt.append(""String_Node_Str"");
      txt.append(""String_Node_Str"").append(pd.getPortletName());
      LOG.warn(txt.toString());
    }
  }
  for (  PortletDefinition pd : badPortlets) {
    pad.removePortlet(pd);
  }
  if (isDebug) {
    StringBuilder txt=new StringBuilder();
    txt.append(""String_Node_Str"");
    txt.append(""String_Node_Str"").append(ams.getPortletNames().toString());
    LOG.debug(txt.toString());
  }
}","/** 
 * reconciles the given annotated method store containing the bean configuration with the configuration as read from the portlet deployment descriptor and  the corresponding type annotations. <p> Portlets that are defined in the bean config are added to the portlet application definition if not already present. Event reference information from the  annotations is verified and added to the corresponding portlet definition. <p> Methods from portlet classes definied in the portlet definitions are added to the annotated method store.
 * @param ams
 */
public void reconcileBeanConfig(AnnotatedMethodStore ams){
  if (isDebug) {
    StringBuilder txt=new StringBuilder();
    txt.append(""String_Node_Str"").append(ams.getPortletNames().toString());
    LOG.debug(txt.toString());
  }
  ams.setDefaultNamespace(pad.getDefaultNamespace());
  for (  String pn : ams.getPortletNames()) {
    PortletDefinition pd=pad.getPortlet(pn);
    if (pd == null) {
      pd=new PortletDefinitionImpl(pn,pad);
    }
    List<EventDefinitionReference> edrs=pd.getSupportedProcessingEvents();
    for (    QName qn : ams.getProcessingEventRefs(pn)) {
      EventDefinition ed=pad.getEventDefinition(qn);
      if (ed == null) {
        StringBuilder txt=new StringBuilder(128);
        txt.append(""String_Node_Str"");
        txt.append(""String_Node_Str"").append(pn);
        txt.append(""String_Node_Str"").append(qn);
        LOG.warn(txt.toString());
        MethodIdentifier mi=new MethodIdentifier(pd.getPortletName(),qn,MethodType.EVENT);
        ams.removeMethod(mi);
        continue;
      }
      EventDefinitionReference newedr=new EventDefinitionReferenceImpl(qn);
      if (!edrs.contains(newedr)) {
        pd.addSupportedProcessingEvent(newedr);
      }
    }
    edrs=pd.getSupportedPublishingEvents();
    for (    QName qn : ams.getPublishingEventRefs(pn)) {
      EventDefinition ed=pad.getEventDefinition(qn);
      if (ed == null) {
        StringBuilder txt=new StringBuilder(128);
        txt.append(""String_Node_Str"");
        txt.append(""String_Node_Str"").append(pn);
        txt.append(""String_Node_Str"").append(qn);
        LOG.warn(txt.toString());
        continue;
      }
      EventDefinitionReference newedr=new EventDefinitionReferenceImpl(qn);
      if (!edrs.contains(newedr)) {
        pd.addSupportedPublishingEvent(newedr);
      }
    }
    pad.addPortlet(pd);
  }
  List<PortletDefinition> badPortlets=new ArrayList<PortletDefinition>();
  for (  PortletDefinition pd : pad.getPortlets()) {
    Class<?> cls=null;
    String clsName=pd.getPortletClass();
    if (isValidIdentifier(clsName)) {
      Class<?> valClass=null;
      StringBuilder txt=new StringBuilder(128);
      try {
        ClassLoader cl=Thread.currentThread().getContextClassLoader();
        if (cl == null) {
          cl=this.getClass().getClassLoader();
        }
        valClass=cl.loadClass(clsName);
        if (Portlet.class.isAssignableFrom(valClass)) {
          cls=valClass;
        }
 else {
          txt.append(""String_Node_Str"");
        }
      }
 catch (      Exception e) {
        txt.append(""String_Node_Str"");
      }
 finally {
        if (cls == null) {
          txt.append(""String_Node_Str"").append(pd.getPortletName());
          txt.append(""String_Node_Str"").append(clsName);
          LOG.warn(txt.toString());
        }
      }
    }
    Object instance=null;
    if (cls != null) {
      StringBuilder txt=new StringBuilder(128);
      BeanManager bm=ams.getBeanMgr();
      if (bm == null) {
        txt.append(""String_Node_Str"");
      }
 else {
        Set<Bean<?>> beans=bm.getBeans(cls);
        if (beans == null || beans.size() == 0) {
          txt.append(""String_Node_Str"");
        }
 else {
          Bean<?> bean=bm.resolve(beans);
          if (bean == null) {
            txt.append(""String_Node_Str"");
          }
 else {
            instance=bm.getReference(bean,bean.getBeanClass(),bm.createCreationalContext(bean));
            if (instance == null) {
              txt.append(""String_Node_Str"");
            }
          }
        }
      }
      if (instance == null) {
        LOG.debug(""String_Node_Str"" + cls.getCanonicalName());
        try {
          instance=cls.newInstance();
        }
 catch (        Exception e) {
          txt.append(""String_Node_Str"").append(e.toString());
        }
      }
      if ((instance == null) && (txt.length() > 0)) {
        txt.append(""String_Node_Str"").append(pd.getPortletName());
        txt.append(""String_Node_Str"").append(cls);
        LOG.warn(txt.toString());
      }
    }
    if (instance != null) {
      ams.setPortletClassInstance(pd.getPortletName(),cls,instance);
      AnnotatedMethod am;
      am=getMethod(instance,""String_Node_Str"",METH_INI);
      if (am != null) {
        MethodIdentifier mi=new MethodIdentifier(pd.getPortletName(),""String_Node_Str"",MethodType.INIT);
        if (ams.getMethods(mi).size() == 0) {
          ams.addMethod(mi,am);
        }
      }
      am=getMethod(instance,""String_Node_Str"",METH_DES);
      if (am != null) {
        MethodIdentifier mi=new MethodIdentifier(pd.getPortletName(),""String_Node_Str"",MethodType.DESTROY);
        if (ams.getMethods(mi).size() == 0) {
          ams.addMethod(mi,am);
        }
      }
      am=getMethod(instance,""String_Node_Str"",METH_ACT);
      if (am != null) {
        MethodIdentifier mi=new MethodIdentifier(pd.getPortletName(),""String_Node_Str"",MethodType.ACTION);
        if (ams.getMethods(mi).size() == 0) {
          ams.addMethod(mi,am);
        }
      }
      am=getMethod(instance,""String_Node_Str"",METH_EVT);
      if (am != null) {
        MethodIdentifier mi=new MethodIdentifier(pd.getPortletName(),""String_Node_Str"",MethodType.EVENT);
        if (ams.getMethods(mi).size() == 0) {
          ams.addMethod(mi,am);
        }
      }
      am=getMethod(instance,""String_Node_Str"",METH_REN);
      if (am != null) {
        MethodIdentifier mi=new MethodIdentifier(pd.getPortletName(),""String_Node_Str"",MethodType.RENDER);
        if (ams.getMethods(mi).size() == 0) {
          ams.addMethod(mi,am);
        }
      }
      am=getMethod(instance,""String_Node_Str"",METH_HDR);
      if (am != null) {
        MethodIdentifier mi=new MethodIdentifier(pd.getPortletName(),""String_Node_Str"",MethodType.HEADER);
        if (ams.getMethods(mi).size() == 0) {
          ams.addMethod(mi,am);
        }
      }
      am=getMethod(instance,""String_Node_Str"",METH_RES);
      if (am != null) {
        MethodIdentifier mi=new MethodIdentifier(pd.getPortletName(),""String_Node_Str"",MethodType.RESOURCE);
        if (ams.getMethods(mi).size() == 0) {
          ams.addMethod(mi,am);
        }
      }
    }
    boolean methodsOK=false;
    for (    MethodIdentifier mi : ams.getMethodIDsForPortlet(pd.getPortletName())) {
      if ((mi.getType() == MethodType.RENDER) || (mi.getType() == MethodType.RESOURCE) || (mi.getType() == MethodType.HEADER)) {
        methodsOK=true;
        break;
      }
    }
    if (!methodsOK) {
      ams.removeMethodsForPortlet(pd.getPortletName());
      badPortlets.add(pd);
      StringBuilder txt=new StringBuilder();
      txt.append(""String_Node_Str"");
      txt.append(""String_Node_Str"").append(pd.getPortletName());
      LOG.warn(txt.toString());
    }
  }
  for (  PortletDefinition pd : badPortlets) {
    pad.removePortlet(pd);
  }
  if (isDebug) {
    StringBuilder txt=new StringBuilder();
    txt.append(""String_Node_Str"");
    txt.append(""String_Node_Str"").append(ams.getPortletNames().toString());
    LOG.debug(txt.toString());
  }
}",0.99867637326274
90608,"public void addProperty(String key,String value){
  if (value == null) {
    StringBuilder txt=new StringBuilder(128);
    txt.append(""String_Node_Str"").append(key);
    LOG.warn(txt.toString());
  }
 else   if (!key.matches(VALID_HEADER_CHARS)) {
    StringBuilder txt=new StringBuilder(128);
    txt.append(""String_Node_Str"").append(key);
    txt.append(""String_Node_Str"").append(value);
    LOG.warn(txt.toString());
  }
 else {
    if (disallowedHeaders.contains(key.toUpperCase())) {
      StringBuilder txt=new StringBuilder(128);
      txt.append(""String_Node_Str"").append(key);
      txt.append(""String_Node_Str"").append(value);
      LOG.warn(txt.toString());
    }
 else {
      if (!isClosed() && isSetPropsAllowed) {
        headerData.addHttpHeader(key,value);
      }
    }
  }
}","public void addProperty(String key,String value){
  if (value == null) {
    StringBuilder txt=new StringBuilder(128);
    txt.append(""String_Node_Str"").append(key);
    LOG.warn(txt.toString());
  }
 else   if (!key.matches(VALID_HEADER_CHARS)) {
    StringBuilder txt=new StringBuilder(128);
    txt.append(""String_Node_Str"").append(key);
    txt.append(""String_Node_Str"").append(value);
    LOG.warn(txt.toString());
  }
 else {
    if (!lifecycle.matches(RESOURCE_PHASE) && disallowedHeaders.contains(key.toUpperCase())) {
      StringBuilder txt=new StringBuilder(128);
      txt.append(""String_Node_Str"").append(key);
      txt.append(""String_Node_Str"").append(value);
      LOG.warn(txt.toString());
    }
 else {
      if (!isClosed() && isSetPropsAllowed) {
        headerData.addHttpHeader(key,value);
      }
    }
  }
}",0.9766009852216748
90609,"public void setProperty(String key,String value){
  if (value == null) {
    StringBuilder txt=new StringBuilder(128);
    txt.append(""String_Node_Str"").append(key);
    LOG.warn(txt.toString());
  }
 else   if (!key.matches(VALID_HEADER_CHARS)) {
    StringBuilder txt=new StringBuilder(128);
    txt.append(""String_Node_Str"").append(key);
    txt.append(""String_Node_Str"").append(value);
    LOG.warn(txt.toString());
  }
 else {
    if (disallowedHeaders.contains(key.toUpperCase())) {
      StringBuilder txt=new StringBuilder(128);
      txt.append(""String_Node_Str"").append(key);
      txt.append(""String_Node_Str"").append(value);
      LOG.warn(txt.toString());
    }
 else {
      if (!isClosed() && isSetPropsAllowed) {
        headerData.setHttpHeader(key,value);
      }
    }
  }
}","public void setProperty(String key,String value){
  if (value == null) {
    StringBuilder txt=new StringBuilder(128);
    txt.append(""String_Node_Str"").append(key);
    LOG.warn(txt.toString());
  }
 else   if (!key.matches(VALID_HEADER_CHARS)) {
    StringBuilder txt=new StringBuilder(128);
    txt.append(""String_Node_Str"").append(key);
    txt.append(""String_Node_Str"").append(value);
    LOG.warn(txt.toString());
  }
 else {
    if (!lifecycle.matches(RESOURCE_PHASE) && disallowedHeaders.contains(key.toUpperCase())) {
      StringBuilder txt=new StringBuilder(128);
      txt.append(""String_Node_Str"").append(key);
      txt.append(""String_Node_Str"").append(value);
      LOG.warn(txt.toString());
    }
 else {
      if (!isClosed() && isSetPropsAllowed) {
        headerData.setHttpHeader(key,value);
      }
    }
  }
}",0.9766009852216748
90610,"/** 
 * Read the Web Application Deployment Descriptor.
 * @return WebAppDD instance representing the descriptor.
 * @throws java.io.IOException
 */
public PortletApplicationDefinition read(String name,String contextPath,InputStream in) throws IOException {
  if (in == null) {
    throw new IOException(""String_Node_Str"");
  }
  try {
    confHolder.processPortletDD(in);
    pad=confHolder.getPad();
  }
 catch (  XMLStreamException|IllegalArgumentException|JAXBException e) {
    final IOException ioe=new IOException(e.getLocalizedMessage());
    ioe.initCause(e);
    throw ioe;
  }
  pad.setName(name);
  pad.setContextPath(contextPath);
  return pad;
}","/** 
 * Read the Web Application Deployment Descriptor.
 * @return WebAppDD instance representing the descriptor.
 * @throws java.io.IOException
 */
public PortletApplicationDefinition read(String name,String contextPath,InputStream in) throws IOException {
  if (in == null) {
    throw new IOException(""String_Node_Str"");
  }
  PortletApplicationDefinition pad=null;
  ConfigurationHolder confHolder=new ConfigurationHolder();
  try {
    confHolder.processPortletDD(in);
    pad=confHolder.getPad();
  }
 catch (  XMLStreamException|IllegalArgumentException|JAXBException e) {
    final IOException ioe=new IOException(e.getLocalizedMessage());
    ioe.initCause(e);
    throw ioe;
  }
  pad.setName(name);
  pad.setContextPath(contextPath);
  return pad;
}",0.9288231148696264
90611,"public void mergeWebDescriptor(PortletApplicationDefinition pa,InputStream webDescriptor) throws Exception {
  confHolder=new ConfigurationHolder(pa);
  confHolder.processWebDD(webDescriptor);
}","public void mergeWebDescriptor(PortletApplicationDefinition pad,InputStream webDescriptor) throws Exception {
  ConfigurationHolder confHolder=new ConfigurationHolder(pad);
  confHolder.processWebDD(webDescriptor);
  if (isDebug) {
    StringBuilder txt=new StringBuilder(128);
    txt.append(""String_Node_Str"").append(pad.getName());
    txt.append(""String_Node_Str"").append(pad.getContextPath());
    txt.append(""String_Node_Str"").append(pad.getPortlets().size());
    txt.append(""String_Node_Str"");
    String sep=""String_Node_Str"";
    for (    PortletDefinition pd : pad.getPortlets()) {
      txt.append(sep).append(pd.getPortletName());
      sep=""String_Node_Str"";
    }
    LOG.debug(txt.toString());
  }
}",0.4268426842684268
90612,"/** 
 * Processes the portlet deployment descriptor represented by the given input stream. <p> The data is merged into an existing configuration data structure if one is provided. This capability is used by version 3 portlets for merging config data from the files into config data that has been read from annotations. <p> If no existing configuration data is provides, or if a version 1.0 or version 2.0 deployment descriptor is being processed, a new configuration data structure is created. <p> The class also performs validity checking and throws exceptions for invalid data. To maintain compatibility with the earlier Pluto implementation, an <code>IllegalArgumentException</code> is thrown in such cases.
 * @param stream Input stream pointing to deployment descriptor
 * @return The resulting portlet application definition
 * @throws IOException If an I/O error occurs
 * @throws IllegalArgumentException If data validation fails
 * @throws XMLStreamException 
 */
public void processPortletDD(InputStream stream) throws IOException, IllegalArgumentException, JAXBException, XMLStreamException {
  if (isDebug) {
    StringBuilder txt=new StringBuilder(128);
    txt.append(""String_Node_Str"");
    ClassLoader mycl=this.getClass().getClassLoader();
    ClassLoader jaxbcl=JAXBContext.class.getClassLoader();
    ClassLoader ofcl=org.apache.pluto.container.om.portlet20.impl.ObjectFactory.class.getClassLoader();
    ClassLoader syscl=null;
    try {
      syscl=ClassLoader.getSystemClassLoader();
    }
 catch (    Exception e) {
    }
    txt.append(""String_Node_Str"").append((mycl != null) ? mycl.toString() : ""String_Node_Str"");
    txt.append(""String_Node_Str"").append((jaxbcl != null) ? jaxbcl.toString() : ""String_Node_Str"");
    txt.append(""String_Node_Str"").append((ofcl != null) ? ofcl.toString() : ""String_Node_Str"");
    txt.append(""String_Node_Str"").append((syscl != null) ? syscl.toString() : ""String_Node_Str"");
    Class<?> myof=null;
    Class<?> jaxbof=null;
    Class<?> ofof=null;
    Class<?> sysof=null;
    String clsName=""String_Node_Str"";
    try {
      myof=mycl.loadClass(clsName);
    }
 catch (    Exception e) {
    }
    try {
      jaxbof=jaxbcl.loadClass(clsName);
    }
 catch (    Exception e) {
    }
    try {
      ofof=ofcl.loadClass(clsName);
    }
 catch (    Exception e) {
    }
    try {
      sysof=syscl.loadClass(clsName);
    }
 catch (    Exception e) {
    }
    txt.append(""String_Node_Str"").append(clsName);
    txt.append(""String_Node_Str"").append(myof != null);
    txt.append(""String_Node_Str"").append(jaxbof != null);
    txt.append(""String_Node_Str"").append(ofof != null);
    txt.append(""String_Node_Str"").append(sysof != null);
    LOG.debug(txt.toString());
  }
  ClassLoader mycl=this.getClass().getClassLoader();
  JAXBContext cntxt=JAXBContext.newInstance(JAXB_CONTEXT,mycl);
  Unmarshaller um=cntxt.createUnmarshaller();
  XMLInputFactory xif=XMLInputFactory.newFactory();
  XMLStreamReader xsr=xif.createXMLStreamReader(stream);
  JAXBElement<?> jel=(JAXBElement<?>)um.unmarshal(xsr);
  if (jel == null) {
    String warning=""String_Node_Str"";
    LOG.warn(warning);
    throw new IOException(warning);
  }
  if (isDebug) {
    StringBuilder txt=new StringBuilder();
    txt.append(""String_Node_Str"");
    txt.append(jel.getValue().getClass().getCanonicalName());
    LOG.debug(txt.toString());
  }
  if (jel.getValue() instanceof org.apache.pluto.container.om.portlet10.impl.PortletAppType) {
    pad=new PortletApplicationDefinitionImpl();
    jcp=new JSR168ConfigurationProcessor();
  }
 else   if (jel.getValue() instanceof org.apache.pluto.container.om.portlet20.impl.PortletAppType) {
    pad=new PortletApplicationDefinitionImpl();
    jcp=new JSR286ConfigurationProcessor();
  }
 else   if (jel.getValue() instanceof org.apache.pluto.container.om.portlet30.impl.PortletAppType) {
    if (pad == null) {
      pad=new PortletApplicationDefinitionImpl();
    }
    jcp=new JSR362ConfigurationProcessor();
  }
 else {
    String warning=""String_Node_Str"" + jel.getValue().getClass().getCanonicalName();
    LOG.warn(warning);
    throw new IOException(warning);
  }
  pad=jcp.process(jel);
}","/** 
 * Processes the portlet deployment descriptor represented by the given input stream. <p> The data is merged into an existing configuration data structure if one is provided. This capability is used by version 3 portlets for merging config data from the files into config data that has been read from annotations. <p> If no existing configuration data is provides, or if a version 1.0 or version 2.0 deployment descriptor is being processed, a new configuration data structure is created. <p> The class also performs validity checking and throws exceptions for invalid data. To maintain compatibility with the earlier Pluto implementation, an <code>IllegalArgumentException</code> is thrown in such cases.
 * @param stream Input stream pointing to deployment descriptor
 * @return The resulting portlet application definition
 * @throws IOException If an I/O error occurs
 * @throws IllegalArgumentException If data validation fails
 * @throws XMLStreamException 
 */
public void processPortletDD(InputStream stream) throws IOException, IllegalArgumentException, JAXBException, XMLStreamException {
  if (isDebug) {
    StringBuilder txt=new StringBuilder(128);
    txt.append(""String_Node_Str"");
    ClassLoader mycl=this.getClass().getClassLoader();
    ClassLoader jaxbcl=JAXBContext.class.getClassLoader();
    ClassLoader ofcl=org.apache.pluto.container.om.portlet20.impl.ObjectFactory.class.getClassLoader();
    ClassLoader syscl=null;
    try {
      syscl=ClassLoader.getSystemClassLoader();
    }
 catch (    Exception e) {
    }
    txt.append(""String_Node_Str"").append((mycl != null) ? mycl.toString() : ""String_Node_Str"");
    txt.append(""String_Node_Str"").append((jaxbcl != null) ? jaxbcl.toString() : ""String_Node_Str"");
    txt.append(""String_Node_Str"").append((ofcl != null) ? ofcl.toString() : ""String_Node_Str"");
    txt.append(""String_Node_Str"").append((syscl != null) ? syscl.toString() : ""String_Node_Str"");
    Class<?> myof=null;
    Class<?> jaxbof=null;
    Class<?> ofof=null;
    Class<?> sysof=null;
    String clsName=""String_Node_Str"";
    try {
      myof=mycl.loadClass(clsName);
    }
 catch (    Exception e) {
    }
    try {
      jaxbof=jaxbcl.loadClass(clsName);
    }
 catch (    Exception e) {
    }
    try {
      ofof=ofcl.loadClass(clsName);
    }
 catch (    Exception e) {
    }
    try {
      sysof=syscl.loadClass(clsName);
    }
 catch (    Exception e) {
    }
    txt.append(""String_Node_Str"").append(clsName);
    txt.append(""String_Node_Str"").append(myof != null);
    txt.append(""String_Node_Str"").append(jaxbof != null);
    txt.append(""String_Node_Str"").append(ofof != null);
    txt.append(""String_Node_Str"").append(sysof != null);
    LOG.debug(txt.toString());
  }
  ClassLoader mycl=this.getClass().getClassLoader();
  JAXBContext cntxt=JAXBContext.newInstance(JAXB_CONTEXT,mycl);
  Unmarshaller um=cntxt.createUnmarshaller();
  XMLInputFactory xif=XMLInputFactory.newFactory();
  XMLStreamReader xsr=xif.createXMLStreamReader(stream);
  JAXBElement<?> jel=(JAXBElement<?>)um.unmarshal(xsr);
  if (jel == null) {
    String warning=""String_Node_Str"";
    LOG.warn(warning);
    throw new IOException(warning);
  }
  if (isDebug) {
    StringBuilder txt=new StringBuilder();
    txt.append(""String_Node_Str"");
    txt.append(jel.getValue().getClass().getCanonicalName());
    LOG.debug(txt.toString());
  }
  if (jel.getValue() instanceof org.apache.pluto.container.om.portlet10.impl.PortletAppType) {
    pad=new PortletApplicationDefinitionImpl();
    jcp=new JSR168ConfigurationProcessor();
  }
 else   if (jel.getValue() instanceof org.apache.pluto.container.om.portlet20.impl.PortletAppType) {
    pad=new PortletApplicationDefinitionImpl();
    jcp=new JSR286ConfigurationProcessor();
  }
 else   if (jel.getValue() instanceof org.apache.pluto.container.om.portlet30.impl.PortletAppType) {
    if (pad == null) {
      pad=new PortletApplicationDefinitionImpl();
    }
    jcp=new JSR362ConfigurationProcessor();
  }
 else {
    String warning=""String_Node_Str"" + jel.getValue().getClass().getCanonicalName();
    LOG.warn(warning);
    throw new IOException(warning);
  }
  pad=jcp.process(jel);
  if (isDebug) {
    StringBuilder txt=new StringBuilder(128);
    txt.append(""String_Node_Str"").append(pad.getName());
    txt.append(""String_Node_Str"").append(pad.getPortlets().size());
    txt.append(""String_Node_Str"");
    String sep=""String_Node_Str"";
    for (    PortletDefinition pd : pad.getPortlets()) {
      txt.append(sep).append(pd.getPortletName());
      sep=""String_Node_Str"";
    }
    LOG.debug(txt.toString());
  }
}",0.9504273504273504
90613,"/** 
 * Retrieves the PortletContext associated with the given ServletContext. If one does not exist, it is created.
 * @param config the servlet config.
 * @return the InternalPortletContext associated with the ServletContext.
 * @throws PortletContainerException
 */
public String register(ServletConfig config) throws PortletContainerException {
  ServletContext servletContext=config.getServletContext();
  String contextPath=getContextPath(servletContext);
  if (!portletContexts.containsKey(contextPath)) {
    PortletApplicationDefinition portletApp=portletRegistry.getPortletAppDD(servletContext,contextPath,contextPath);
    DriverPortletContext portletContext=new DriverPortletContextImpl(servletContext,portletApp,rdService);
    portletContexts.put(contextPath,portletContext);
    fireRegistered(portletContext);
    if (LOG.isInfoEnabled()) {
      LOG.info(""String_Node_Str"" + contextPath + ""String_Node_Str"");
      LOG.info(""String_Node_Str"" + portletApp.getPortlets().size() + ""String_Node_Str""+ portletContext.getApplicationName());
    }
    classLoaders.put(portletApp.getName(),Thread.currentThread().getContextClassLoader());
    for (    PortletDefinition portlet : portletApp.getPortlets()) {
      String appName=portletContext.getApplicationName();
      if (appName == null) {
        throw new PortletContainerException(""String_Node_Str"");
      }
      portletConfigs.put(portletContext.getApplicationName() + ""String_Node_Str"" + portlet.getPortletName(),new DriverPortletConfigImpl(portletContext,portlet));
    }
  }
 else {
    if (LOG.isInfoEnabled()) {
      LOG.info(""String_Node_Str"" + contextPath + ""String_Node_Str"");
    }
  }
  return contextPath;
}","/** 
 * Retrieves the PortletContext associated with the given ServletContext. If one does not exist, it is created.
 * @param config the servlet config.
 * @return the InternalPortletContext associated with the ServletContext.
 * @throws PortletContainerException
 */
public String register(ServletConfig config) throws PortletContainerException {
  ServletContext servletContext=config.getServletContext();
  String contextPath=getContextPath(servletContext);
  if (!portletContexts.containsKey(contextPath)) {
    PortletApplicationDefinition portletApp=portletRegistry.getPortletAppDD(servletContext,contextPath,contextPath);
    if (isDebug) {
      StringBuilder txt=new StringBuilder(128);
      txt.append(""String_Node_Str"").append(portletApp.getName());
      txt.append(""String_Node_Str"").append(portletApp.getContextPath());
      txt.append(""String_Node_Str"").append(portletApp.getPortlets().size());
      txt.append(""String_Node_Str"");
      String sep=""String_Node_Str"";
      for (      PortletDefinition pd : portletApp.getPortlets()) {
        txt.append(sep).append(pd.getPortletName());
        sep=""String_Node_Str"";
      }
      LOG.debug(txt.toString());
    }
    DriverPortletContext portletContext=new DriverPortletContextImpl(servletContext,portletApp,rdService);
    portletContexts.put(contextPath,portletContext);
    fireRegistered(portletContext);
    if (LOG.isInfoEnabled()) {
      LOG.info(""String_Node_Str"" + contextPath + ""String_Node_Str"");
      LOG.info(""String_Node_Str"" + portletApp.getPortlets().size() + ""String_Node_Str""+ portletContext.getApplicationName());
    }
    classLoaders.put(portletApp.getName(),Thread.currentThread().getContextClassLoader());
    for (    PortletDefinition portlet : portletApp.getPortlets()) {
      String appName=portletContext.getApplicationName();
      if (appName == null) {
        throw new PortletContainerException(""String_Node_Str"");
      }
      portletConfigs.put(portletContext.getApplicationName() + ""String_Node_Str"" + portlet.getPortletName(),new DriverPortletConfigImpl(portletContext,portlet));
    }
  }
 else {
    if (LOG.isInfoEnabled()) {
      LOG.info(""String_Node_Str"" + contextPath + ""String_Node_Str"");
    }
  }
  return contextPath;
}",0.7278271918678526
90614,"@Override public String getParameter(String name){
  String val=super.getParameter(name);
  if (LOG.isDebugEnabled()) {
    Map<String,String[]> pmap=super.getParameterMap();
    StringBuffer txt=new StringBuffer(1024);
    txt.append(""String_Node_Str"");
    for (    String n : pmap.keySet()) {
      txt.append(""String_Node_Str"" + n + ""String_Node_Str"");
      String[] vals=pmap.get(n);
      String sep=""String_Node_Str"";
      for (      String v : vals) {
        txt.append(sep + v);
        sep=""String_Node_Str"";
      }
      txt.append(""String_Node_Str"");
    }
    LOG.debug(txt.toString());
  }
  return val;
}","@Override public String getParameter(String name){
  String val=super.getParameter(name);
  if (LOG.isDebugEnabled()) {
    Map<String,String[]> pmap=super.getParameterMap();
    StringBuffer txt=new StringBuffer(1024);
    txt.append(""String_Node_Str"");
    for (    String n : pmap.keySet()) {
      txt.append(""String_Node_Str"" + n + ""String_Node_Str"");
      String[] vals=pmap.get(n);
      String sep=""String_Node_Str"";
      for (      String v : vals) {
        txt.append(sep + v);
        sep=""String_Node_Str"";
      }
    }
    LOG.debug(txt.toString());
  }
  return val;
}",0.9693961952026467
90615,"public PortalURL apply(){
  if (isDebug) {
    StringBuilder txt=new StringBuilder(""String_Node_Str"");
    txt.append(""String_Node_Str"").append(type);
    txt.append(""String_Node_Str"").append(url.getType());
    txt.append(""String_Node_Str"").append(url.getTargetWindow());
    LOGGER.debug(txt.toString());
  }
  return url;
}","public PortalURL apply(){
  if (isDebug) {
    StringBuilder txt=new StringBuilder(""String_Node_Str"");
    txt.append(""String_Node_Str"").append(type);
    txt.append(""String_Node_Str"").append(url.getType());
    txt.append(""String_Node_Str"").append(url.getTargetWindow());
    LOGGER.debug(txt.toString());
  }
  if (isDebug) {
    StringBuilder txt=new StringBuilder(""String_Node_Str"");
    txt.append(window);
    for (    PortalURLParameter p : url.getParameters()) {
      if (p.getWindowId().equals(window)) {
        txt.append(""String_Node_Str"").append(p.getName());
        txt.append(""String_Node_Str"").append(p.getType());
        txt.append(""String_Node_Str"").append(Arrays.toString(p.getValues()));
      }
    }
    LOGGER.debug(txt.toString());
  }
  return url;
}",0.5688405797101449
90616,"public PortletURLProviderImpl(PortalURL url,TYPE type,PortletWindow portletWindow){
  this.url=url.clone();
  this.type=type;
  this.window=portletWindow.getId().getStringId();
  if (isDebug) {
    StringBuilder txt=new StringBuilder(""String_Node_Str"");
    txt.append(""String_Node_Str"").append(type);
    txt.append(""String_Node_Str"").append(url.getType());
    txt.append(""String_Node_Str"").append(window);
    txt.append(""String_Node_Str"").append(url.getTargetWindow());
    LOGGER.debug(txt.toString());
  }
  this.url.setTargetWindow(window);
switch (type) {
case ACTION:
    this.url.setType(URLType.Action);
  break;
case RESOURCE:
this.url.setType(URLType.Resource);
this.url.clearResourceParameters(window);
this.url.setCacheability(ResourceURL.PAGE);
break;
default :
this.url.setType(URLType.Render);
this.url.clearParameters(window);
}
if (isTrace) {
StringBuilder txt=new StringBuilder(""String_Node_Str"");
txt.append(""String_Node_Str"").append(this.url.getType());
LOGGER.debug(txt.toString());
}
}","public PortletURLProviderImpl(PortalURL url,TYPE type,PortletWindow portletWindow){
  this.url=url.clone();
  this.type=type;
  this.window=portletWindow.getId().getStringId();
  if (isDebug) {
    StringBuilder txt=new StringBuilder(""String_Node_Str"");
    txt.append(""String_Node_Str"").append(type);
    txt.append(""String_Node_Str"").append(url.getType());
    txt.append(""String_Node_Str"").append(window);
    txt.append(""String_Node_Str"").append(url.getTargetWindow());
    LOGGER.debug(txt.toString());
  }
  if (isTrace) {
    StringBuilder txt=new StringBuilder(""String_Node_Str"");
    txt.append(window);
    for (    PortalURLParameter p : this.url.getParameters()) {
      if (p.getWindowId().equals(window)) {
        txt.append(""String_Node_Str"").append(p.getName());
        txt.append(""String_Node_Str"").append(p.getType());
        txt.append(""String_Node_Str"").append(Arrays.toString(p.getValues()));
      }
    }
    LOGGER.debug(txt.toString());
  }
  this.url.setTargetWindow(window);
switch (type) {
case ACTION:
    this.url.setType(URLType.Action);
  break;
case RESOURCE:
this.url.setType(URLType.Resource);
this.url.clearResourceParameters(window);
this.url.setCacheability(ResourceURL.PAGE);
break;
default :
this.url.setType(URLType.Render);
this.url.clearParameters(window);
}
if (isTrace) {
StringBuilder txt=new StringBuilder(""String_Node_Str"");
txt.append(""String_Node_Str"").append(this.url.getType());
LOGGER.debug(txt.toString());
}
}",0.8155026241421074
90617,"protected void handleServletRequestParams(){
  if (!reqParamsProcessed && servletRequest != null && targetWindow != null && type != URLType.Portal) {
    reqParamsProcessed=true;
    try {
      servletRequest.setCharacterEncoding(""String_Node_Str"");
    }
 catch (    Exception e) {
    }
    Map<String,String[]> parms=servletRequest.getParameterMap();
    if (!parms.isEmpty()) {
      String ptype=PortalURLParameter.PARAM_TYPE_RENDER;
      if (type == URLType.Action || type == URLType.AjaxAction || type == URLType.PartialAction) {
        ptype=PortalURLParameter.PARAM_TYPE_ACTION;
      }
 else       if (type == URLType.Resource) {
        ptype=PortalURLParameter.PARAM_TYPE_RESOURCE;
      }
      for (      String parm : parms.keySet()) {
        if (type == URLType.Render && targetWindow != null) {
          int index=prpMapper.getIndex(targetWindow,parm);
          if (index >= 0) {
            prpMapper.setValues(index,parms.get(parm));
            if (isDebug) {
              StringBuilder txt=new StringBuilder(""String_Node_Str"");
              txt.append(parm).append(""String_Node_Str"").append(Arrays.toString(parms.get(parm)));
              txt.append(""String_Node_Str"" + cloneId);
              LOG.debug(txt.toString());
            }
            continue;
          }
        }
        PortalURLParameter pup=new PortalURLParameter(targetWindow,parm,parms.get(parm),ptype);
        if (parameters.contains(pup)) {
          parameters.remove(pup);
        }
        parameters.add(pup);
        if (isDebug) {
          StringBuilder txt=new StringBuilder(""String_Node_Str"");
          txt.append(parm).append(""String_Node_Str"").append(Arrays.toString(parms.get(parm)));
          txt.append(parm).append(""String_Node_Str"").append(ptype);
          txt.append(""String_Node_Str"" + cloneId);
          LOG.debug(txt.toString());
        }
      }
    }
  }
}","protected void handleServletRequestParams(){
  if (!reqParamsProcessed && servletRequest != null && targetWindow != null && type != URLType.Portal) {
    reqParamsProcessed=true;
    try {
      servletRequest.setCharacterEncoding(""String_Node_Str"");
    }
 catch (    Exception e) {
    }
    Map<String,String[]> parms=servletRequest.getParameterMap();
    if (!parms.isEmpty()) {
      String ptype=PortalURLParameter.PARAM_TYPE_RENDER;
      if (type == URLType.Action || type == URLType.AjaxAction || type == URLType.PartialAction) {
        ptype=PortalURLParameter.PARAM_TYPE_ACTION;
      }
 else       if (type == URLType.Resource) {
        ptype=PortalURLParameter.PARAM_TYPE_RESOURCE;
      }
      for (      String parm : parms.keySet()) {
        if (type == URLType.Render && targetWindow != null) {
          int index=prpMapper.getIndex(targetWindow,parm);
          if (index >= 0) {
            prpMapper.setValues(index,parms.get(parm));
            if (isDebug) {
              StringBuilder txt=new StringBuilder(""String_Node_Str"");
              txt.append(parm).append(""String_Node_Str"").append(Arrays.toString(parms.get(parm)));
              txt.append(""String_Node_Str"" + cloneId);
              LOG.debug(txt.toString());
            }
            continue;
          }
        }
        PortalURLParameter pup=new PortalURLParameter(targetWindow,parm,parms.get(parm),ptype);
        if (parameters.contains(pup)) {
          parameters.remove(pup);
        }
        parameters.add(pup);
        if (isDebug) {
          StringBuilder txt=new StringBuilder(""String_Node_Str"");
          txt.append(parm).append(""String_Node_Str"").append(Arrays.toString(parms.get(parm)));
          txt.append(""String_Node_Str"").append(ptype);
          txt.append(""String_Node_Str"" + cloneId);
          LOG.debug(txt.toString());
        }
      }
    }
  }
}",0.9965434724807232
90618,"/** 
 * This V2.0 method returns the private parameters for the given window ID. In the case of a render URL, it returns only the private render parameters. In the case of an action or resource URL, it returns the action or resource  parameters combined with the render parameters, with the action or resource parameters taking precedence. Note that the  latter circumstance will only occur with V3.0 portlets.
 * @param windowId
 * @return
 */
public Map<String,String[]> getPrivateParameterMap(String windowId){
  HashMap<String,String[]> parameters=new HashMap<String,String[]>();
  processParams();
  if (wid2Action.containsKey(windowId)) {
    for (    PortalURLParameter parm : wid2Action.get(windowId)) {
      parameters.put(parm.getName(),parm.getValues().clone());
    }
  }
 else   if (wid2Resource.containsKey(windowId)) {
    for (    PortalURLParameter parm : wid2Resource.get(windowId)) {
      parameters.put(parm.getName(),parm.getValues().clone());
    }
  }
  if (wid2Render.containsKey(windowId)) {
    for (    PortalURLParameter parm : wid2Render.get(windowId)) {
      if (parameters.containsKey(parm.getName())) {
        ArrayList<String> vals=new ArrayList<String>(Arrays.asList(parameters.get(parm.getName())));
        vals.addAll(Arrays.asList(parm.getValues()));
        parameters.put(parm.getName(),vals.toArray(new String[0]));
      }
 else {
        parameters.put(parm.getName(),parm.getValues().clone());
      }
    }
  }
  if (isDebug) {
    StringBuffer sb=new StringBuffer();
    sb.append(""String_Node_Str"");
    for (    String k : parameters.keySet()) {
      sb.append(""String_Node_Str"" + k + ""String_Node_Str"");
      String sep=""String_Node_Str"";
      for (      String v : parameters.get(k)) {
        sb.append(sep + v);
        sep=""String_Node_Str"";
      }
    }
    LOGGER.debug(sb.toString());
  }
  return parameters;
}","/** 
 * This V2.0 method returns the private parameters for the given window ID. In the case of a render URL, it returns only the private render parameters. In the case of an action or resource URL, it returns the action or resource  parameters combined with the render parameters, with the action or resource parameters taking precedence. Note that the  latter circumstance will only occur with V3.0 portlets.
 * @param windowId
 * @return
 */
public Map<String,String[]> getPrivateParameterMap(String windowId){
  HashMap<String,String[]> parameters=new HashMap<String,String[]>();
  processParams();
  boolean isV3=url.isVersion3(windowId);
  if (wid2Action.containsKey(windowId)) {
    for (    PortalURLParameter parm : wid2Action.get(windowId)) {
      parameters.put(parm.getName(),parm.getValues().clone());
    }
  }
 else   if (wid2Resource.containsKey(windowId)) {
    for (    PortalURLParameter parm : wid2Resource.get(windowId)) {
      parameters.put(parm.getName(),parm.getValues().clone());
    }
  }
  if (isV3 || !actionTypes.contains(url.getType())) {
    if (wid2Render.containsKey(windowId)) {
      for (      PortalURLParameter parm : wid2Render.get(windowId)) {
        if (parameters.containsKey(parm.getName())) {
          ArrayList<String> vals=new ArrayList<String>(Arrays.asList(parameters.get(parm.getName())));
          vals.addAll(Arrays.asList(parm.getValues()));
          parameters.put(parm.getName(),vals.toArray(new String[0]));
        }
 else {
          parameters.put(parm.getName(),parm.getValues().clone());
        }
      }
    }
  }
  if (isDebug) {
    StringBuffer sb=new StringBuffer();
    sb.append(""String_Node_Str"");
    for (    String k : parameters.keySet()) {
      sb.append(""String_Node_Str"" + k + ""String_Node_Str"");
      String sep=""String_Node_Str"";
      for (      String v : parameters.get(k)) {
        sb.append(sep + v);
        sep=""String_Node_Str"";
      }
    }
    LOGGER.debug(sb.toString());
  }
  return parameters;
}",0.9682416731216112
90619,"protected static Map<String,String[]> cloneParameterMap(Map<String,String[]> map){
  if (!map.isEmpty()) {
    Map<String,String[]> result=new HashMap<String,String[]>(map.size());
    for (    Map.Entry<String,String[]> entry : map.entrySet()) {
      if (entry.getValue() != null) {
        result.put(entry.getKey(),entry.getValue().clone());
      }
    }
    return Collections.unmodifiableMap(result);
  }
  return Collections.emptyMap();
}","protected static Map<String,String[]> cloneParameterMap(Map<String,String[]> map){
  Map<String,String[]> newMap=new HashMap<String,String[]>();
  for (  String pn : map.keySet()) {
    newMap.put(pn,map.get(pn).clone());
  }
  return newMap;
}",0.4231884057971014
90620,"public PortletURLProviderImpl(PortalURL url,TYPE type,PortletWindow portletWindow){
  this.url=url.clone();
  this.type=type;
  this.window=portletWindow.getId().getStringId();
  this.paramFactory=url.getPortletParameterFactory();
  if (isDebug) {
    StringBuilder txt=new StringBuilder(""String_Node_Str"");
    txt.append(""String_Node_Str"").append(type);
    txt.append(""String_Node_Str"").append(url.getType());
    txt.append(""String_Node_Str"").append(window);
    txt.append(""String_Node_Str"").append(url.getTargetWindow());
    LOGGER.debug(txt.toString());
  }
  if (isDebug) {
    StringBuilder txt=new StringBuilder(""String_Node_Str"");
    txt.append(window);
    for (    PortalURLParameter p : this.url.getParameters()) {
      if (p.getWindowId().equals(window)) {
        txt.append(""String_Node_Str"").append(p.getName());
        txt.append(""String_Node_Str"").append(p.getType());
        txt.append(""String_Node_Str"").append(Arrays.toString(p.getValues()));
      }
    }
    txt.append(""String_Node_Str"");
    PublicRenderParameterMapper mapper=this.url.getPublicRenderParameterMapper();
    List<PortalURLPublicParameter> pups=mapper.getPRPsForWindow(window,false);
    for (    PortalURLPublicParameter p : pups) {
      txt.append(""String_Node_Str"").append(p.getName());
      txt.append(""String_Node_Str"").append(p.getType());
      txt.append(""String_Node_Str"").append(p.isRemoved());
      txt.append(""String_Node_Str"").append(Arrays.toString(p.getValues()));
    }
    LOGGER.debug(txt.toString());
  }
  this.url.setTargetWindow(window);
switch (type) {
case ACTION:
    this.url.setType(URLType.Action);
  break;
case RESOURCE:
this.url.setType(URLType.Resource);
this.url.clearResourceParameters(window);
this.url.setCacheability(ResourceURL.PAGE);
break;
default :
this.url.setType(URLType.Render);
this.url.clearParameters(window);
}
if (isTrace) {
StringBuilder txt=new StringBuilder(""String_Node_Str"");
txt.append(""String_Node_Str"").append(this.url.getType());
LOGGER.debug(txt.toString());
}
}","public PortletURLProviderImpl(PortalURL url,TYPE type,PortletWindow portletWindow){
  this.url=url.clone();
  this.type=type;
  this.window=portletWindow.getId().getStringId();
  this.paramFactory=this.url.getPortletParameterFactory();
  if (isDebug) {
    StringBuilder txt=new StringBuilder(""String_Node_Str"");
    txt.append(""String_Node_Str"").append(type);
    txt.append(""String_Node_Str"").append(url.getType());
    txt.append(""String_Node_Str"").append(window);
    txt.append(""String_Node_Str"").append(url.getTargetWindow());
    LOGGER.debug(txt.toString());
  }
  if (isDebug) {
    StringBuilder txt=new StringBuilder(""String_Node_Str"");
    txt.append(window);
    for (    PortalURLParameter p : this.url.getParameters()) {
      if (p.getWindowId().equals(window)) {
        txt.append(""String_Node_Str"").append(p.getName());
        txt.append(""String_Node_Str"").append(p.getType());
        txt.append(""String_Node_Str"").append(Arrays.toString(p.getValues()));
      }
    }
    txt.append(""String_Node_Str"");
    PublicRenderParameterMapper mapper=this.url.getPublicRenderParameterMapper();
    List<PortalURLPublicParameter> pups=mapper.getPRPsForWindow(window,false);
    for (    PortalURLPublicParameter p : pups) {
      txt.append(""String_Node_Str"").append(p.getName());
      txt.append(""String_Node_Str"").append(p.getType());
      txt.append(""String_Node_Str"").append(p.isRemoved());
      txt.append(""String_Node_Str"").append(Arrays.toString(p.getValues()));
    }
    LOGGER.debug(txt.toString());
  }
  this.url.setTargetWindow(window);
switch (type) {
case ACTION:
    this.url.setType(URLType.Action);
  break;
case RESOURCE:
this.url.setType(URLType.Resource);
this.url.clearResourceParameters(window);
this.url.setCacheability(ResourceURL.PAGE);
break;
default :
this.url.setType(URLType.Render);
this.url.clearParameters(window);
}
if (isTrace) {
StringBuilder txt=new StringBuilder(""String_Node_Str"");
txt.append(""String_Node_Str"").append(this.url.getType());
LOGGER.debug(txt.toString());
}
}",0.9987651271918992
90621,"public void clearResourceParameters(String window){
  handleServletRequestParams();
  HashSet<PortalURLParameter> rem=new HashSet<PortalURLParameter>();
  for (  PortalURLParameter pup : parameters) {
    if (pup.getType().equals(PortalURLParameter.PARAM_TYPE_RESOURCE) && pup.getWindowId().equals(window)) {
      rem.add(pup);
    }
  }
  if (isTrace) {
    StringBuilder txt=new StringBuilder(""String_Node_Str"");
    txt.append(rem.size()).append(""String_Node_Str"").append(window);
    LOG.debug(txt.toString());
  }
  parameters.removeAll(rem);
}","public void clearResourceParameters(String window){
  HashSet<PortalURLParameter> rem=new HashSet<PortalURLParameter>();
  for (  PortalURLParameter pup : parameters) {
    if (pup.getType().equals(PortalURLParameter.PARAM_TYPE_RESOURCE) && pup.getWindowId().equals(window)) {
      rem.add(pup);
    }
  }
  if (isTrace) {
    StringBuilder txt=new StringBuilder(""String_Node_Str"");
    txt.append(rem.size()).append(""String_Node_Str"").append(window);
    LOG.debug(txt.toString());
  }
  parameters.removeAll(rem);
}",0.9700374531835206
90622,"public void setRenderParameter(String key,String... values){
  ArgumentUtility.validateNotEmpty(""String_Node_Str"",key);
  ArgumentUtility.validateNotNull(""String_Node_Str"",values);
  checkSetStateChanged();
  if (values == null) {
    responseContext.removeParameter(windowId,key);
  }
 else {
    responseContext.setParameter(windowId,key,values.clone());
  }
}","public void setRenderParameter(String key,String... values){
  ArgumentUtility.validateNotEmpty(""String_Node_Str"",key);
  checkSetStateChanged();
  if (values == null) {
    responseContext.removeParameter(windowId,key);
  }
 else {
    responseContext.setParameter(windowId,key,values.clone());
  }
}",0.9079939668174962
90623,"public void processEvents(PortletContainer container,PortletWindow portletWindow,HttpServletRequest request,HttpServletResponse response,List<Event> events){
  ServletContext containerServletContext=PortalRequestContext.getContext(request).getServletContext();
  DriverConfiguration driverConfig=(DriverConfiguration)containerServletContext.getAttribute(AttributeKeys.DRIVER_CONFIG);
  PortalURL portalURL=PortalURLParserImpl.getParser().parse(request);
  for (  Event event : events) {
    List<String> portletNames=getAllPortletsRegisteredForEvent(event,driverConfig,containerServletContext);
    Collection<PortletWindowConfig> portlets=new ArrayList<PortletWindowConfig>();
    for (    String pid : portalURL.getPortletIds()) {
      portlets.add(PortletWindowConfig.fromId(pid));
    }
    for (    PortletWindowConfig config : portlets) {
      PortletWindow window=new PortletWindowImpl(container,config,portalURL);
      if (portletNames != null) {
        for (        String portlet : portletNames) {
          if (portlet.equals(config.getId())) {
            doEvent(container,window,event,request,response);
          }
        }
      }
    }
  }
}","public void processEvents(PortletContainer container,PortletWindow portletWindow,HttpServletRequest request,HttpServletResponse response,List<Event> events){
  ServletContext containerServletContext=PortalRequestContext.getContext(request).getServletContext();
  DriverConfiguration driverConfig=(DriverConfiguration)containerServletContext.getAttribute(AttributeKeys.DRIVER_CONFIG);
  PortalURL portalURL=PortalRequestContext.getContext(request).createPortalURL();
  for (  Event event : events) {
    List<String> portletNames=getAllPortletsRegisteredForEvent(event,driverConfig,containerServletContext);
    Collection<PortletWindowConfig> portlets=new ArrayList<PortletWindowConfig>();
    for (    String pid : portalURL.getPortletIds()) {
      portlets.add(PortletWindowConfig.fromId(pid));
    }
    for (    PortletWindowConfig config : portlets) {
      PortletWindow window=new PortletWindowImpl(container,config,portalURL);
      if (portletNames != null) {
        for (        String portlet : portletNames) {
          if (portlet.equals(config.getId())) {
            doEvent(container,window,event,request,response);
          }
        }
      }
    }
  }
}",0.9640718562874252
90624,"public PortletRequestContextImpl(PortletContainer container,HttpServletRequest containerRequest,HttpServletResponse containerResponse,PortletWindow window,boolean useRequestParameters){
  this.container=container;
  this.containerRequest=containerRequest;
  this.containerResponse=containerResponse;
  this.window=window;
  this.url=PortalRequestContext.getContext(containerRequest).createPortalURL();
  this.paramFactory=new PortletParameterFactory(url);
}","public PortletRequestContextImpl(PortletContainer container,HttpServletRequest containerRequest,HttpServletResponse containerResponse,PortletWindow window,boolean useRequestParameters){
  this.container=container;
  this.containerRequest=containerRequest;
  this.containerResponse=containerResponse;
  this.window=window;
  this.url=PortalRequestContext.getContext(containerRequest).createPortalURL();
  this.paramFactory=url.getPortletParameterFactory();
}",0.9846827133479212
90625,"public void addPublicRenderParameter(QName qn,String identifier,String[] values){
  LOGGER.debug(""String_Node_Str"" + qn.toString() + ""String_Node_Str""+ identifier+ ""String_Node_Str""+ Arrays.toString(values));
  portletURLProvider.addPublicRenderParameter(qn,identifier,values);
}","public void addPublicRenderParameter(QName qn,String identifier,String[] values){
  if (isDebug) {
    StringBuilder txt=new StringBuilder(""String_Node_Str"");
    txt.append(qn.toString()).append(""String_Node_Str"").append(identifier).append(""String_Node_Str"").append(Arrays.toString(values));
    LOGGER.debug(txt.toString());
  }
  portletURLProvider.addPublicRenderParameter(qn,identifier,values);
}",0.5029411764705882
90626,"public void removePublicRenderParameter(QName qn,String id){
  LOGGER.debug(""String_Node_Str"" + qn.toString());
  portletURLProvider.removePublicRenderParameter(qn,id);
}","public void removePublicRenderParameter(QName qn,String id){
  if (isDebug) {
    LOGGER.debug(""String_Node_Str"" + qn.toString());
  }
  portletURLProvider.removePublicRenderParameter(qn,id);
}",0.9366391184573004
90627,"public void addPublicRenderParameter(QName qn,String identifier,String[] values){
  LOGGER.debug(""String_Node_Str"" + qn.toString() + ""String_Node_Str""+ identifier+ ""String_Node_Str""+ Arrays.toString(values));
  PortalURLPublicParameter pupp=new PortalURLPublicParameter(window,identifier,qn,values);
  prpSet.add(pupp);
}","public void addPublicRenderParameter(QName qn,String identifier,String[] values){
  if (isDebug) {
    StringBuilder txt=new StringBuilder(""String_Node_Str"");
    txt.append(qn.toString()).append(""String_Node_Str"").append(identifier).append(""String_Node_Str"").append(Arrays.toString(values));
    LOGGER.debug(txt.toString());
  }
  PortalURLPublicParameter pupp=new PortalURLPublicParameter(window,identifier,qn,values);
  prpSet.add(pupp);
}",0.5575916230366492
90628,"public PortalURL apply(){
  PortalURL url=this.url.clone();
  if (PortletURLProvider.TYPE.ACTION == type) {
    url.setTargetWindow(window);
    url.setType(URLType.Action);
  }
 else   if (PortletURLProvider.TYPE.RESOURCE == type) {
    url.setTargetWindow(window);
    url.setType(URLType.Resource);
    url.clearResourceParameters(window);
  }
 else {
    url.setTargetWindow(window);
    url.setType(URLType.Render);
    url.clearParameters(window);
  }
  if (portletMode != null) {
    url.setPortletMode(window,portletMode);
  }
  if (windowState != null) {
    url.setWindowState(window,windowState);
  }
  if (renderParameters != null) {
    for (    Map.Entry<String,String[]> entry : renderParameters.entrySet()) {
      if (!isPRP(entry.getKey())) {
        url.addParameter(new PortalURLParameter(window,entry.getKey(),entry.getValue()));
      }
    }
  }
  for (  PortalURLPublicParameter prp : prpSet) {
    url.addPublicRenderParameter(prp);
  }
  url.setResourceID(resourceID);
  url.setCacheability(cacheLevel);
  return url;
}","public PortalURL apply(){
  if (PortletURLProvider.TYPE.ACTION == type) {
    url.setTargetWindow(window);
    url.setType(URLType.Action);
  }
 else   if (PortletURLProvider.TYPE.RESOURCE == type) {
    url.setTargetWindow(window);
    url.setType(URLType.Resource);
    url.clearResourceParameters(window);
  }
 else {
    url.setTargetWindow(window);
    url.setType(URLType.Render);
    url.clearParameters(window);
  }
  if (portletMode != null) {
    url.setPortletMode(window,portletMode);
  }
  if (windowState != null) {
    url.setWindowState(window,windowState);
  }
  if (renderParameters != null) {
    for (    Map.Entry<String,String[]> entry : renderParameters.entrySet()) {
      if (!isPRP(entry.getKey())) {
        url.addParameter(new PortalURLParameter(window,entry.getKey(),entry.getValue()));
      }
    }
  }
  for (  PortalURLPublicParameter prp : prpSet) {
    url.addPublicRenderParameter(prp);
  }
  url.setResourceID(resourceID);
  url.setCacheability(cacheLevel);
  return url;
}",0.9834630350194552
90629,"public PortletURLProviderImpl(PortalURL url,TYPE type,PortletWindow portletWindow){
  this.url=url;
  this.type=type;
  this.window=portletWindow.getId().getStringId();
}","public PortletURLProviderImpl(PortalURL url,TYPE type,PortletWindow portletWindow){
  this.url=url.clone();
  this.type=type;
  this.window=portletWindow.getId().getStringId();
}",0.9770114942528736
90630,"public void removePublicRenderParameter(QName qn,String identifier){
  LOGGER.debug(""String_Node_Str"" + qn.toString());
  PortalURLPublicParameter pupp=new PortalURLPublicParameter(window,identifier,qn);
  pupp.setRemoved(true);
  prpSet.add(pupp);
}","public void removePublicRenderParameter(QName qn,String identifier){
  if (isDebug) {
    LOGGER.debug(""String_Node_Str"" + qn.toString());
  }
  PortalURLPublicParameter pupp=new PortalURLPublicParameter(window,identifier,qn);
  pupp.setRemoved(true);
  prpSet.add(pupp);
}",0.9560229445506692
90631,"/** 
 * Converts a portal URL to a URL string.
 * @param portalURL  the portal URL to convert.
 * @return a URL string representing the portal URL.
 */
public String toString(PortalURL portalURL){
  StringBuilder buffer=new StringBuilder();
  String targetWindow=portalURL.getTargetWindow();
  portalURL.handleServletRequestParams();
  buffer.append(portalURL.getServletPath().startsWith(""String_Node_Str"") ? ""String_Node_Str"" : ""String_Node_Str"").append(portalURL.getServletPath());
  if (portalURL.getRenderPath() != null) {
    buffer.append(portalURL.getRenderPath());
  }
  ArrayList<String> pids=new ArrayList<String>();
  for (  String pid : portalURL.getPortletIds()) {
    pids.add(pid);
    buffer.append(""String_Node_Str"").append(PREFIX).append(PORTLET_ID);
    try {
      buffer.append(URLEncoder.encode(pid,""String_Node_Str""));
    }
 catch (    Exception e) {
      LOG.warn(""String_Node_Str"" + pid);
    }
    buffer.append(DELIM).append(String.valueOf(pids.indexOf(pid)));
  }
  if (portalURL.getType() == URLType.Resource) {
    int index=pids.indexOf(targetWindow);
    if (index < 0) {
      LOG.warn(""String_Node_Str"" + targetWindow);
    }
 else {
      buffer.append(""String_Node_Str"");
      buffer.append(PREFIX).append(RESOURCE).append(String.valueOf(index));
    }
  }
  if (portalURL.getType() == URLType.Render) {
    int index=pids.indexOf(targetWindow);
    if (index < 0) {
      LOG.warn(""String_Node_Str"" + targetWindow);
    }
 else {
      buffer.append(""String_Node_Str"");
      buffer.append(PREFIX).append(RENDER).append(String.valueOf(index));
    }
  }
  if (portalURL.getType() == URLType.Action) {
    int index=pids.indexOf(targetWindow);
    if (index < 0) {
      LOG.warn(""String_Node_Str"" + targetWindow);
    }
 else {
      buffer.append(""String_Node_Str"");
      buffer.append(PREFIX).append(ACTION).append(String.valueOf(index));
    }
  }
  String reswin=null;
  if (portalURL.getType() == URLType.Resource) {
    if (portalURL.getCacheability() != null) {
      buffer.append(""String_Node_Str"");
      buffer.append(PREFIX).append(CACHE_LEVEL).append(urlEncode(portalURL.getCacheability()));
    }
    if (portalURL.getResourceID() != null) {
      buffer.append(""String_Node_Str"");
      buffer.append(PREFIX).append(RESOURCE_ID).append(urlEncode(portalURL.getResourceID()));
    }
    if (portalURL.getCacheability().equals(ResourceURL.FULL)) {
      return buffer.toString();
    }
 else     if (portalURL.getCacheability().equals(ResourceURL.PORTLET)) {
      reswin=portalURL.getTargetWindow();
    }
  }
  for (  String pid : portalURL.getPortletModes().keySet()) {
    if (reswin != null && !reswin.equals(pid)) {
      continue;
    }
    int index=pids.indexOf(pid);
    PortletMode pm=portalURL.getPortletMode(pid);
    if (index < 0) {
      LOG.warn(""String_Node_Str"" + pid + ""String_Node_Str""+ pm.toString());
      LOG.warn(""String_Node_Str"" + Arrays.toString(pids.toArray()));
    }
 else {
      buffer.append(""String_Node_Str"").append(PREFIX).append(PORTLET_MODE).append(String.valueOf(index)).append(DELIM).append(urlEncode(pm.toString()));
    }
  }
  for (  String pid : portalURL.getWindowStates().keySet()) {
    if (reswin != null && !reswin.equals(pid)) {
      continue;
    }
    int index=pids.indexOf(pid);
    WindowState ws=portalURL.getWindowState(pid);
    if (index < 0) {
      LOG.warn(""String_Node_Str"" + pid + ""String_Node_Str""+ ws.toString());
    }
 else {
      buffer.append(""String_Node_Str"").append(PREFIX).append(WINDOW_STATE).append(String.valueOf(index)).append(DELIM).append(urlEncode(ws.toString()));
    }
  }
  for (  PortalURLParameter param : portalURL.getParameters()) {
    if (reswin != null && !reswin.equals(param.getWindowId())) {
      continue;
    }
    int index=pids.indexOf(param.getWindowId());
    if (index < 0) {
      LOG.warn(""String_Node_Str"" + param.getWindowId() + ""String_Node_Str""+ param.getName());
      continue;
    }
    if (param.getName() != null && param.getValues() != null && param.getValues().length > 0) {
      String valueString=encodeMultiValues(param.getValues());
      if (valueString.length() > 0) {
        String ptype=RENDER_PARAM;
        if (param.getType().equals(PortalURLParameter.PARAM_TYPE_ACTION)) {
          ptype=ACTION_PARAM;
        }
 else         if (param.getType().equals(PortalURLParameter.PARAM_TYPE_RESOURCE)) {
          ptype=RESOURCE_PARAM;
        }
        buffer.append(""String_Node_Str"").append(PREFIX).append(ptype).append(String.valueOf(index)).append(DELIM).append(urlEncode(param.getName())).append(VALUE_DELIM).append(valueString);
      }
    }
  }
  PublicRenderParameterMapper mapper=portalURL.getPublicRenderParameterMapper();
  List<Integer> activeIndexes=mapper.getActiveIndexes();
  if (reswin != null) {
    List<PortalURLPublicParameter> pups=mapper.getPRPsForWindow(reswin,true);
    activeIndexes=new ArrayList<Integer>();
    for (    PortalURLPublicParameter pup : pups) {
      activeIndexes.add(mapper.getIndex(pup));
    }
  }
  for (  int i : activeIndexes) {
    String[] values=mapper.getValues(i);
    String valstr=encodeMultiValues(values);
    List<PortalURLPublicParameter> prplist=mapper.getPublicParameterGroup(i);
    if (prplist.size() > 0) {
      PortalURLPublicParameter prp=prplist.get(0);
      int index=pids.indexOf(prp.getWindowId());
      if (index >= 0) {
        buffer.append(""String_Node_Str"").append(PREFIX).append(PUBLIC_RENDER_PARAM).append(String.valueOf(index)).append(DELIM).append(String.valueOf(i)).append(DELIM).append(urlEncode(prp.getName())).append(valstr);
      }
 else {
        LOG.warn(""String_Node_Str"" + prp.toString());
      }
    }
  }
  return buffer.toString();
}","/** 
 * Converts a portal URL to a URL string.
 * @param portalURL  the portal URL to convert.
 * @return a URL string representing the portal URL.
 */
public String toString(PortalURL portalURL){
  StringBuilder buffer=new StringBuilder();
  String targetWindow=portalURL.getTargetWindow();
  portalURL.handleServletRequestParams();
  buffer.append(portalURL.getServletPath().startsWith(""String_Node_Str"") ? ""String_Node_Str"" : ""String_Node_Str"").append(portalURL.getServletPath());
  if (portalURL.getRenderPath() != null) {
    buffer.append(portalURL.getRenderPath());
  }
  ArrayList<String> pids=new ArrayList<String>();
  for (  String pid : portalURL.getPortletIds()) {
    pids.add(pid);
    buffer.append(""String_Node_Str"").append(PREFIX).append(PORTLET_ID);
    try {
      buffer.append(URLEncoder.encode(pid,""String_Node_Str""));
    }
 catch (    Exception e) {
      LOG.warn(""String_Node_Str"" + pid);
    }
    buffer.append(DELIM).append(String.valueOf(pids.indexOf(pid)));
  }
  if (portalURL.getType() == URLType.Resource) {
    int index=pids.indexOf(targetWindow);
    if (index < 0) {
      LOG.warn(""String_Node_Str"" + targetWindow);
    }
 else {
      buffer.append(""String_Node_Str"");
      buffer.append(PREFIX).append(RESOURCE).append(String.valueOf(index));
    }
  }
  if (portalURL.getType() == URLType.Render) {
    int index=pids.indexOf(targetWindow);
    if (index < 0) {
      LOG.warn(""String_Node_Str"" + targetWindow);
    }
 else {
      buffer.append(""String_Node_Str"");
      buffer.append(PREFIX).append(RENDER).append(String.valueOf(index));
    }
  }
  if (portalURL.getType() == URLType.Action) {
    int index=pids.indexOf(targetWindow);
    if (index < 0) {
      LOG.warn(""String_Node_Str"" + targetWindow);
    }
 else {
      buffer.append(""String_Node_Str"");
      buffer.append(PREFIX).append(ACTION).append(String.valueOf(index));
    }
  }
  String reswin=null;
  if (portalURL.getType() == URLType.Resource) {
    if (portalURL.getCacheability() != null) {
      buffer.append(""String_Node_Str"");
      buffer.append(PREFIX).append(CACHE_LEVEL).append(urlEncode(portalURL.getCacheability()));
    }
    if (portalURL.getResourceID() != null) {
      buffer.append(""String_Node_Str"");
      buffer.append(PREFIX).append(RESOURCE_ID).append(urlEncode(portalURL.getResourceID()));
    }
    if (portalURL.getCacheability().equals(ResourceURL.FULL)) {
      return buffer.toString();
    }
 else     if (portalURL.getCacheability().equals(ResourceURL.PORTLET)) {
      reswin=portalURL.getTargetWindow();
    }
  }
  for (  String pid : portalURL.getPortletModes().keySet()) {
    if (reswin != null && !reswin.equals(pid)) {
      continue;
    }
    int index=pids.indexOf(pid);
    PortletMode pm=portalURL.getPortletMode(pid);
    if (index < 0) {
      LOG.warn(""String_Node_Str"" + pid + ""String_Node_Str""+ pm.toString());
      LOG.warn(""String_Node_Str"" + Arrays.toString(pids.toArray()));
    }
 else {
      buffer.append(""String_Node_Str"").append(PREFIX).append(PORTLET_MODE).append(String.valueOf(index)).append(DELIM).append(urlEncode(pm.toString()));
    }
  }
  for (  String pid : portalURL.getWindowStates().keySet()) {
    if (reswin != null && !reswin.equals(pid)) {
      continue;
    }
    int index=pids.indexOf(pid);
    WindowState ws=portalURL.getWindowState(pid);
    if (index < 0) {
      LOG.warn(""String_Node_Str"" + pid + ""String_Node_Str""+ ws.toString());
    }
 else {
      buffer.append(""String_Node_Str"").append(PREFIX).append(WINDOW_STATE).append(String.valueOf(index)).append(DELIM).append(urlEncode(ws.toString()));
    }
  }
  for (  PortalURLParameter param : portalURL.getParameters()) {
    if (reswin != null && !reswin.equals(param.getWindowId())) {
      continue;
    }
    int index=pids.indexOf(param.getWindowId());
    if (index < 0) {
      LOG.warn(""String_Node_Str"" + param.getWindowId() + ""String_Node_Str""+ param.getName());
      continue;
    }
    if (param.getName() != null && param.getValues() != null && param.getValues().length > 0) {
      String valueString=encodeMultiValues(param.getValues());
      if (valueString.length() > 0) {
        String ptype=RENDER_PARAM;
        if (param.getType().equals(PortalURLParameter.PARAM_TYPE_ACTION)) {
          ptype=ACTION_PARAM;
        }
 else         if (param.getType().equals(PortalURLParameter.PARAM_TYPE_RESOURCE)) {
          ptype=RESOURCE_PARAM;
        }
        buffer.append(""String_Node_Str"").append(PREFIX).append(ptype).append(String.valueOf(index)).append(DELIM).append(urlEncode(param.getName())).append(VALUE_DELIM).append(valueString);
      }
    }
  }
  PublicRenderParameterMapper mapper=portalURL.getPublicRenderParameterMapper();
  List<Integer> activeIndexes=mapper.getActiveIndexes();
  if (reswin != null) {
    List<PortalURLPublicParameter> pups=mapper.getPRPsForWindow(reswin,true);
    activeIndexes=new ArrayList<Integer>();
    for (    PortalURLPublicParameter pup : pups) {
      activeIndexes.add(mapper.getIndex(pup));
    }
  }
  for (  int i : activeIndexes) {
    String[] values=mapper.getValues(i);
    String valstr=encodeMultiValues(values);
    List<PortalURLPublicParameter> prplist=mapper.getPublicParameterGroup(i);
    if (prplist.size() > 0) {
      PortalURLPublicParameter prp=prplist.get(0);
      int index=pids.indexOf(prp.getWindowId());
      if (index >= 0) {
        buffer.append(""String_Node_Str"").append(PREFIX).append(PUBLIC_RENDER_PARAM).append(String.valueOf(index)).append(DELIM).append(String.valueOf(i)).append(DELIM).append(urlEncode(prp.getName())).append(VALUE_DELIM).append(valstr);
      }
 else {
        LOG.warn(""String_Node_Str"" + prp.toString());
      }
    }
  }
  return buffer.toString();
}",0.9982523593149248
90632,"/** 
 * Parse a servlet request to a portal URL.
 * @param request  the servlet request to parse.
 * @return the portal URL.
 */
public PortalURL parse(HttpServletRequest request){
  if (LOG.isDebugEnabled()) {
    LOG.debug(""String_Node_Str"" + request.getRequestURI());
  }
  String contextPath=request.getContextPath();
  String servletName=request.getServletPath();
  String urlBase=request.getScheme() + ""String_Node_Str"" + request.getServerName()+ ""String_Node_Str""+ request.getServerPort();
  PortalURL portalURL=new RelativePortalURLImpl(urlBase,contextPath,servletName,this,request);
  String pathInfo=request.getPathInfo();
  if (pathInfo == null) {
    if (servletName.contains(""String_Node_Str"") && !servletName.endsWith(""String_Node_Str"")) {
      int idx=servletName.indexOf(""String_Node_Str"") + ""String_Node_Str"".length();
      pathInfo=servletName.substring(idx);
      servletName=servletName.substring(0,idx);
      portalURL=new RelativePortalURLImpl(urlBase,contextPath,servletName,this,request);
    }
 else {
      return portalURL;
    }
  }
  if (LOG.isDebugEnabled()) {
    LOG.debug(""String_Node_Str"" + pathInfo);
  }
  StringBuilder renderPath=new StringBuilder();
  if (pathInfo.charAt(0) != '/') {
    renderPath.append('/');
  }
  int ind=pathInfo.indexOf(""String_Node_Str"" + PREFIX);
  if (ind < 0) {
    renderPath.append(pathInfo);
    pathInfo=""String_Node_Str"";
  }
 else {
    renderPath.append(pathInfo.substring(0,ind));
    pathInfo=pathInfo.substring(ind);
  }
  portalURL.setRenderPath(renderPath.toString());
  if (LOG.isDebugEnabled()) {
    LOG.debug(""String_Node_Str"" + renderPath.toString() + ""String_Node_Str""+ pathInfo);
  }
  ServletContext sc=request.getServletContext();
  DriverConfiguration dc=(DriverConfiguration)sc.getAttribute(AttributeKeys.DRIVER_CONFIG);
  PublicRenderParameterMapper prpm=dc.getPublicRenderParameterService().getPRPMapper(renderPath.toString());
  portalURL.setPublicRenderParameterMapper(prpm);
  Collection<String> pids=dc.getPageConfig(renderPath.toString()).getPortletIds();
  portalURL.setPortletIds(pids);
  StringBuilder vstr=new StringBuilder();
  if (LOG.isDebugEnabled()) {
    vstr.append(""String_Node_Str"");
  }
  for (  String pid : pids) {
    String appName=PortletWindowConfig.fromId(pid).getContextPath();
    try {
      String pv=dc.getPortletRegistryService().getPortletApplication(appName).getVersion();
      portalURL.setVersion(pid,pv);
      if (LOG.isDebugEnabled()) {
        vstr.append(pid).append(""String_Node_Str"").append(pv).append(""String_Node_Str"");
      }
    }
 catch (    Exception e) {
      LOG.error(""String_Node_Str"" + appName);
    }
  }
  if (LOG.isDebugEnabled()) {
    LOG.debug(vstr.toString());
  }
  ArrayList<String> portletIds=new ArrayList<String>();
  if (pathInfo.length() > 2) {
    String[] tokens=pathInfo.split(""String_Node_Str"" + PREFIX);
    for (    String t : tokens) {
      String type, val;
      String[] vals;
      if (t.length() < 3) {
        continue;
      }
 else {
        type=t.substring(0,2);
        val=t.substring(2);
        vals=val.split(DELIM);
      }
      int index=-1;
      String pid=null;
      if ((vals[0].length() > 0) && vals[0].matches(""String_Node_Str"")) {
        try {
          index=Integer.parseInt(vals[0]);
          if ((index >= 0) && (index < portletIds.size())) {
            pid=portletIds.get(index);
          }
        }
 catch (        Exception e) {
          LOG.error(""String_Node_Str"" + vals[0] + ""String_Node_Str""+ e.toString());
        }
      }
      if (type.equals(PORTLET_ID)) {
        portletIds.add(Integer.parseInt(vals[1]),urlDecode(vals[0]));
        continue;
      }
      if (type.equals(CACHE_LEVEL)) {
        portalURL.setCacheability(urlDecode(vals[0]));
        continue;
      }
      if (type.equals(RESOURCE_ID)) {
        portalURL.setResourceID(urlDecode(vals[0]));
        continue;
      }
      if (type.equals(RESOURCE)) {
        portalURL.setTargetWindow(pid);
        portalURL.setType(URLType.Resource);
        continue;
      }
      if (type.equals(RENDER)) {
        portalURL.setTargetWindow(pid);
        portalURL.setType(URLType.Render);
        continue;
      }
      if (type.equals(ACTION)) {
        portalURL.setTargetWindow(pid);
        portalURL.setType(URLType.Action);
        continue;
      }
      if (type.equals(AJAX_ACTION)) {
        portalURL.setTargetWindow(pid);
        portalURL.setType(URLType.AjaxAction);
        continue;
      }
      if (type.equals(PARTIAL_ACTION)) {
        portalURL.setTargetWindow(pid);
        portalURL.setType(URLType.PartialAction);
        continue;
      }
      if (type.equals(WINDOW_STATE)) {
        portalURL.setWindowState(pid,new WindowState(urlDecode(vals[1])));
        continue;
      }
      if (type.equals(PORTLET_MODE)) {
        portalURL.setPortletMode(pid,new PortletMode(urlDecode(vals[1])));
        continue;
      }
      StringBuilder dbgstr=new StringBuilder();
      if (LOG.isDebugEnabled()) {
        dbgstr.append(""String_Node_Str"").append(pid).append(""String_Node_Str"").append(vals[1]);
      }
      String values=vals[1];
      if (type.equals(PUBLIC_RENDER_PARAM)) {
        if (vals.length != 3) {
          LOG.warn(""String_Node_Str"" + val);
        }
 else {
          values=vals[2];
        }
      }
      String[] pVals=values.split(VALUE_DELIM);
      String[] paramValues=null;
      String paramName=null;
      if (pVals.length > 2) {
        for (int i=0; i < pVals.length; i++) {
          if (pVals[i].equals(VALUE_NULL)) {
            pVals[i]=null;
          }
 else {
            pVals[i]=urlDecode(pVals[i]);
          }
        }
        paramName=pVals[0];
        paramValues=Arrays.copyOfRange(pVals,1,pVals.length);
      }
      if (LOG.isDebugEnabled()) {
        dbgstr.append(""String_Node_Str"").append(paramName);
        dbgstr.append(""String_Node_Str"").append(Arrays.toString(paramValues));
        LOG.debug(dbgstr.toString());
      }
      if (type.equals(RENDER_PARAM)) {
        portalURL.addParameter(new PortalURLParameter(pid,paramName,paramValues));
        continue;
      }
      if (type.equals(ACTION_PARAM)) {
        portalURL.addParameter(new PortalURLParameter(pid,paramName,paramValues,PortalURLParameter.PARAM_TYPE_ACTION));
        continue;
      }
      if (type.equals(RESOURCE_PARAM)) {
        portalURL.addParameter(new PortalURLParameter(pid,paramName,paramValues,PortalURLParameter.PARAM_TYPE_RESOURCE));
        continue;
      }
      if (type.equals(PUBLIC_RENDER_PARAM)) {
        PublicRenderParameterMapper mapper=portalURL.getPublicRenderParameterMapper();
        int prpGroup=mapper.getIndex(pid,paramName);
        if (prpGroup >= 0) {
          mapper.setValues(prpGroup,paramValues);
        }
 else {
          StringBuilder sb=new StringBuilder(""String_Node_Str"");
          sb.append(pid).append(""String_Node_Str"").append(paramName);
          LOG.warn(sb.toString());
        }
        continue;
      }
    }
  }
  if (LOG.isDebugEnabled()) {
    LOG.debug(""String_Node_Str"" + portletIds.size() + ""String_Node_Str""+ Arrays.toString(portletIds.toArray()));
  }
  return portalURL;
}","/** 
 * Parse a servlet request to a portal URL.
 * @param request  the servlet request to parse.
 * @return the portal URL.
 */
public PortalURL parse(HttpServletRequest request){
  if (LOG.isDebugEnabled()) {
    LOG.debug(""String_Node_Str"" + request.getRequestURI());
  }
  String contextPath=request.getContextPath();
  String servletName=request.getServletPath();
  String urlBase=request.getScheme() + ""String_Node_Str"" + request.getServerName()+ ""String_Node_Str""+ request.getServerPort();
  PortalURL portalURL=new RelativePortalURLImpl(urlBase,contextPath,servletName,this,request);
  String pathInfo=request.getPathInfo();
  if (pathInfo == null) {
    if (servletName.contains(""String_Node_Str"") && !servletName.endsWith(""String_Node_Str"")) {
      int idx=servletName.indexOf(""String_Node_Str"") + ""String_Node_Str"".length();
      pathInfo=servletName.substring(idx);
      servletName=servletName.substring(0,idx);
      portalURL=new RelativePortalURLImpl(urlBase,contextPath,servletName,this,request);
    }
 else {
      return portalURL;
    }
  }
  if (LOG.isDebugEnabled()) {
    LOG.debug(""String_Node_Str"" + pathInfo);
  }
  StringBuilder renderPath=new StringBuilder();
  if (pathInfo.charAt(0) != '/') {
    renderPath.append('/');
  }
  int ind=pathInfo.indexOf(""String_Node_Str"" + PREFIX);
  if (ind < 0) {
    renderPath.append(pathInfo);
    pathInfo=""String_Node_Str"";
  }
 else {
    renderPath.append(pathInfo.substring(0,ind));
    pathInfo=pathInfo.substring(ind);
  }
  portalURL.setRenderPath(renderPath.toString());
  if (LOG.isDebugEnabled()) {
    LOG.debug(""String_Node_Str"" + renderPath.toString() + ""String_Node_Str""+ pathInfo);
  }
  ServletContext sc=request.getServletContext();
  DriverConfiguration dc=(DriverConfiguration)sc.getAttribute(AttributeKeys.DRIVER_CONFIG);
  PublicRenderParameterMapper prpm=dc.getPublicRenderParameterService().getPRPMapper(renderPath.toString());
  portalURL.setPublicRenderParameterMapper(prpm);
  Collection<String> pids=dc.getPageConfig(renderPath.toString()).getPortletIds();
  portalURL.setPortletIds(pids);
  StringBuilder vstr=new StringBuilder();
  if (LOG.isDebugEnabled()) {
    vstr.append(""String_Node_Str"");
  }
  for (  String pid : pids) {
    String appName=PortletWindowConfig.fromId(pid).getContextPath();
    try {
      String pv=dc.getPortletRegistryService().getPortletApplication(appName).getVersion();
      portalURL.setVersion(pid,pv);
      if (LOG.isDebugEnabled()) {
        vstr.append(pid).append(""String_Node_Str"").append(pv).append(""String_Node_Str"");
      }
    }
 catch (    Exception e) {
      LOG.error(""String_Node_Str"" + appName);
    }
  }
  if (LOG.isDebugEnabled()) {
    LOG.debug(vstr.toString());
  }
  ArrayList<String> portletIds=new ArrayList<String>();
  if (pathInfo.length() > 2) {
    String[] tokens=pathInfo.split(""String_Node_Str"" + PREFIX);
    for (    String t : tokens) {
      String type, val;
      String[] vals;
      if (t.length() < 3) {
        continue;
      }
 else {
        type=t.substring(0,2);
        val=t.substring(2);
        vals=val.split(DELIM);
      }
      int index=-1;
      String pid=null;
      if ((vals[0].length() > 0) && vals[0].matches(""String_Node_Str"")) {
        try {
          index=Integer.parseInt(vals[0]);
          if ((index >= 0) && (index < portletIds.size())) {
            pid=portletIds.get(index);
          }
        }
 catch (        Exception e) {
          LOG.error(""String_Node_Str"" + vals[0] + ""String_Node_Str""+ e.toString());
        }
      }
      if (type.equals(PORTLET_ID)) {
        portletIds.add(Integer.parseInt(vals[1]),urlDecode(vals[0]));
        continue;
      }
      if (type.equals(CACHE_LEVEL)) {
        portalURL.setCacheability(urlDecode(vals[0]));
        continue;
      }
      if (type.equals(RESOURCE_ID)) {
        portalURL.setResourceID(urlDecode(vals[0]));
        continue;
      }
      if (type.equals(RESOURCE)) {
        portalURL.setTargetWindow(pid);
        portalURL.setType(URLType.Resource);
        continue;
      }
      if (type.equals(RENDER)) {
        portalURL.setTargetWindow(pid);
        portalURL.setType(URLType.Render);
        continue;
      }
      if (type.equals(ACTION)) {
        portalURL.setTargetWindow(pid);
        portalURL.setType(URLType.Action);
        continue;
      }
      if (type.equals(AJAX_ACTION)) {
        portalURL.setTargetWindow(pid);
        portalURL.setType(URLType.AjaxAction);
        continue;
      }
      if (type.equals(PARTIAL_ACTION)) {
        portalURL.setTargetWindow(pid);
        portalURL.setType(URLType.PartialAction);
        continue;
      }
      if (type.equals(WINDOW_STATE)) {
        portalURL.setWindowState(pid,new WindowState(urlDecode(vals[1])));
        continue;
      }
      if (type.equals(PORTLET_MODE)) {
        portalURL.setPortletMode(pid,new PortletMode(urlDecode(vals[1])));
        continue;
      }
      StringBuilder dbgstr=new StringBuilder();
      if (LOG.isDebugEnabled()) {
        dbgstr.append(""String_Node_Str"").append(pid).append(""String_Node_Str"").append(vals[1]);
      }
      String values=vals[1];
      if (type.equals(PUBLIC_RENDER_PARAM)) {
        if (vals.length != 3) {
          LOG.warn(""String_Node_Str"" + val);
        }
 else {
          values=vals[2];
        }
      }
      String[] pVals=values.split(VALUE_DELIM);
      String[] paramValues=new String[0];
      String paramName=""String_Node_Str"";
      if (pVals.length > 1) {
        for (int i=0; i < pVals.length; i++) {
          if (pVals[i].equals(VALUE_NULL)) {
            pVals[i]=null;
          }
 else {
            pVals[i]=urlDecode(pVals[i]);
          }
        }
      }
      if (pVals.length <= 1 || pVals[0] == null) {
        LOG.warn(""String_Node_Str"" + values);
      }
 else {
        paramName=pVals[0];
        paramValues=Arrays.copyOfRange(pVals,1,pVals.length);
      }
      if (LOG.isDebugEnabled()) {
        dbgstr.append(""String_Node_Str"").append(paramName);
        dbgstr.append(""String_Node_Str"").append(Arrays.toString(paramValues));
        LOG.debug(dbgstr.toString());
      }
      if (type.equals(RENDER_PARAM)) {
        portalURL.addParameter(new PortalURLParameter(pid,paramName,paramValues));
        continue;
      }
      if (type.equals(ACTION_PARAM)) {
        portalURL.addParameter(new PortalURLParameter(pid,paramName,paramValues,PortalURLParameter.PARAM_TYPE_ACTION));
        continue;
      }
      if (type.equals(RESOURCE_PARAM)) {
        portalURL.addParameter(new PortalURLParameter(pid,paramName,paramValues,PortalURLParameter.PARAM_TYPE_RESOURCE));
        continue;
      }
      if (type.equals(PUBLIC_RENDER_PARAM)) {
        PublicRenderParameterMapper mapper=portalURL.getPublicRenderParameterMapper();
        int prpGroup=mapper.getIndex(pid,paramName);
        if (prpGroup >= 0) {
          mapper.setValues(prpGroup,paramValues);
        }
 else {
          StringBuilder sb=new StringBuilder(""String_Node_Str"");
          sb.append(pid).append(""String_Node_Str"").append(paramName);
          LOG.warn(sb.toString());
        }
        continue;
      }
    }
  }
  if (portalURL.getType() == URLType.Render || portalURL.getType() == URLType.Portal) {
    portalURL.handleServletRequestParams();
  }
  if (LOG.isDebugEnabled()) {
    LOG.debug(""String_Node_Str"" + portletIds.size() + ""String_Node_Str""+ Arrays.toString(portletIds.toArray()));
  }
  return portalURL;
}",0.9798455967752956
90633,"public PublicRenderParameterMapperImpl(PageConfig paco,PortletRegistryService pore){
  Collection<String> pids=paco.getPortletIds();
  LOGGER.debug(""String_Node_Str"" + pids.size() + ""String_Node_Str"");
  StringBuilder dbgstr=new StringBuilder(1024);
  boolean isDebug=LOGGER.isDebugEnabled();
  for (  String pid : pids) {
    if (isDebug) {
      dbgstr.append(""String_Node_Str"" + pid);
    }
    PortletWindowConfig pwc=null;
    PortletApplicationDefinition pad=null;
    PortletDefinition pd=null;
    pwc=PortletWindowConfig.fromId(pid);
    String cxtpa=pwc.getContextPath();
    String portletName=pwc.getPortletName();
    try {
      pad=pore.getPortletApplication(cxtpa);
      pd=pore.getPortlet(cxtpa,portletName);
      if (isDebug) {
        dbgstr.append(""String_Node_Str"" + cxtpa + ""String_Node_Str""+ pad.getName()+ ""String_Node_Str""+ pd.getPortletName());
      }
      Collection<String> prpIds=pd.getSupportedPublicRenderParameters();
      if (prpIds != null && prpIds.size() > 0) {
        Collection<? extends PublicRenderParameter> prpDefs=pad.getPublicRenderParameters();
        String namespace=pad.getDefaultNamespace();
        for (        String prpId : prpIds) {
          Iterator<? extends PublicRenderParameter> i=prpDefs.iterator();
          QName qn=null;
          while (qn == null && i.hasNext()) {
            PublicRenderParameter prpDef=i.next();
            if (prpDef.getIdentifier().equals(prpId)) {
              qn=prpDef.getQName();
              if (qn == null) {
                String name=prpDef.getName();
                if (name == null) {
                  LOGGER.error(""String_Node_Str"");
                }
 else {
                  qn=new QName(namespace,name);
                }
              }
            }
          }
          if (qn == null) {
            LOGGER.error(""String_Node_Str"");
          }
 else {
            PortalURLPublicParameter pupp=new PortalURLPublicParameter(pid,prpId,qn);
            prpList.add(pupp);
            if (qn2PRP.containsKey(qn)) {
              qn2PRP.get(qn).add(pupp);
            }
 else {
              List<PortalURLPublicParameter> s=new ArrayList<PortalURLPublicParameter>();
              s.add(pupp);
              qn2PRP.put(qn,s);
              qnList.add(qn);
            }
            if (isDebug) {
              dbgstr.append(""String_Node_Str"" + pid + ""String_Node_Str""+ qn.toString()+ ""String_Node_Str""+ prpId);
            }
          }
        }
      }
    }
 catch (    Exception e) {
      if (pad == null) {
        LOGGER.error(""String_Node_Str"" + cxtpa);
      }
 else {
        LOGGER.error(""String_Node_Str"" + portletName);
      }
    }
  }
  if (isDebug) {
    LOGGER.debug(dbgstr.toString());
  }
}","public PublicRenderParameterMapperImpl(PageConfig paco,PortletRegistryService pore){
  Collection<String> pids=paco.getPortletIds();
  LOGGER.debug(""String_Node_Str"" + pids.size() + ""String_Node_Str"");
  StringBuilder dbgstr=new StringBuilder(1024);
  boolean isDebug=LOGGER.isDebugEnabled();
  for (  String pid : pids) {
    if (isDebug) {
      dbgstr.append(""String_Node_Str"" + pid);
    }
    PortletWindowConfig pwc=null;
    PortletApplicationDefinition pad=null;
    PortletDefinition pd=null;
    pwc=PortletWindowConfig.fromId(pid);
    String cxtpa=pwc.getContextPath();
    String portletName=pwc.getPortletName();
    try {
      pad=pore.getPortletApplication(cxtpa);
      pd=pore.getPortlet(cxtpa,portletName);
      if (isDebug) {
        dbgstr.append(""String_Node_Str"" + cxtpa + ""String_Node_Str""+ pad.getName()+ ""String_Node_Str""+ pd.getPortletName());
      }
      Collection<String> prpIds=pd.getSupportedPublicRenderParameters();
      if (prpIds != null && prpIds.size() > 0) {
        Collection<? extends PublicRenderParameter> prpDefs=pad.getPublicRenderParameters();
        String namespace=pad.getDefaultNamespace();
        for (        String prpId : prpIds) {
          Iterator<? extends PublicRenderParameter> i=prpDefs.iterator();
          QName qn=null;
          while (qn == null && i.hasNext()) {
            PublicRenderParameter prpDef=i.next();
            if (prpDef.getIdentifier().equals(prpId)) {
              qn=prpDef.getQName();
              if (qn == null) {
                String name=prpDef.getName();
                if (name == null) {
                  LOGGER.error(""String_Node_Str"");
                }
 else {
                  qn=new QName(namespace,name);
                }
              }
            }
          }
          if (qn == null) {
            LOGGER.error(""String_Node_Str"");
          }
 else {
            PortalURLPublicParameter pupp=new PortalURLPublicParameter(pid,prpId,qn);
            prpList.add(pupp);
            if (qn2PRP.containsKey(qn)) {
              qn2PRP.get(qn).add(pupp);
            }
 else {
              List<PortalURLPublicParameter> s=new ArrayList<PortalURLPublicParameter>();
              s.add(pupp);
              qn2PRP.put(qn,s);
              qnList.add(qn);
            }
            if (isDebug) {
              dbgstr.append(""String_Node_Str"" + pid + ""String_Node_Str""+ qn.toString()+ ""String_Node_Str""+ prpId);
            }
          }
        }
      }
    }
 catch (    Exception e) {
      if (pad == null) {
        LOGGER.error(""String_Node_Str"" + cxtpa);
      }
 else {
        LOGGER.error(""String_Node_Str"" + portletName);
      }
    }
  }
  if (isDebug) {
    dbgstr.append(""String_Node_Str"" + paco.getName() + ""String_Node_Str""+ prpList.size()+ ""String_Node_Str""+ qnList.size()+ ""String_Node_Str"");
    String prefix=""String_Node_Str"";
    for (    List<PortalURLPublicParameter> lp : qn2PRP.values()) {
      dbgstr.append(prefix + lp.size());
      prefix=""String_Node_Str"";
    }
    LOGGER.debug(dbgstr.toString());
  }
}",0.9433114414103008
90634,"public List<PortalURLPublicParameter> getPublicParameterGroup(int index){
  List<PortalURLPublicParameter> oprps=new ArrayList<PortalURLPublicParameter>();
  for (  PortalURLPublicParameter prp : qn2PRP.get(qnList.get(index))) {
    PortalURLPublicParameter p=prp.clone();
    if (!prp.isRemoved()) {
      p.setValues(prp.getValues().clone());
      oprps.add(p);
    }
  }
  if (LOGGER.isDebugEnabled()) {
    LOGGER.debug(""String_Node_Str"" + oprps.size() + ""String_Node_Str"");
  }
  return oprps;
}","public List<PortalURLPublicParameter> getPublicParameterGroup(int index){
  List<PortalURLPublicParameter> oprps=new ArrayList<PortalURLPublicParameter>();
  QName qn=qnList.get(index);
  for (  PortalURLPublicParameter prp : qn2PRP.get(qn)) {
    PortalURLPublicParameter p=prp.clone();
    String[] vals=(prp.getValues() == null) ? null : prp.getValues().clone();
    p.setValues(vals);
    oprps.add(p);
  }
  if (LOGGER.isDebugEnabled()) {
    LOGGER.debug(""String_Node_Str"" + index + ""String_Node_Str""+ qn+ ""String_Node_Str""+ oprps.size());
  }
  return oprps;
}",0.7752808988764045
90635,"@Override public Object getAttribute(String name){
  if (pathInfoAttributes.contains(name)) {
    if (includedPathInfo != null && !includedPathInfo.isNamedRequestDispatcher()) {
      if (INCLUDE_CONTEXT_PATH.equals(name)) {
        return getContextPath();
      }
 else       if (INCLUDE_PATH_INFO.equals(name)) {
        return includedPathInfo.getPathInfo();
      }
 else       if (INCLUDE_QUERY_STRING.equals(name)) {
        return includedPathInfo.getQueryString();
      }
 else       if (INCLUDE_REQUEST_URI.equals(name)) {
        return includedPathInfo.getRequestURI();
      }
 else       if (INCLUDE_SERVLET_PATH.equals(name)) {
        return includedPathInfo.getServletPath();
      }
    }
    if (forwardedPathInfo != null && !forwardedPathInfo.isNamedRequestDispatcher()) {
      if (FORWARD_CONTEXT_PATH.equals(name)) {
        return getContextPath();
      }
 else       if (FORWARD_PATH_INFO.equals(name)) {
        return forwardedPathInfo.getPathInfo();
      }
 else       if (FORWARD_QUERY_STRING.equals(name)) {
        return forwardedPathInfo.getQueryString();
      }
 else       if (FORWARD_REQUEST_URI.equals(name)) {
        return forwardedPathInfo.getRequestURI();
      }
 else       if (FORWARD_SERVLET_PATH.equals(name)) {
        return forwardedPathInfo.getServletPath();
      }
    }
    return null;
  }
  Object value=getRequest().getAttribute(name);
  return value != null ? value : portletRequest.getAttribute(name);
}","@Override public Object getAttribute(String name){
  Object value=(dispatching ? getRequest().getAttribute(name) : null);
  if (value == null && pathInfoAttributes.contains(name)) {
    if (includedPathInfo != null && !includedPathInfo.isNamedRequestDispatcher()) {
      if (INCLUDE_CONTEXT_PATH.equals(name)) {
        return getContextPath();
      }
 else       if (INCLUDE_PATH_INFO.equals(name)) {
        return includedPathInfo.getPathInfo();
      }
 else       if (INCLUDE_QUERY_STRING.equals(name)) {
        return includedPathInfo.getQueryString();
      }
 else       if (INCLUDE_REQUEST_URI.equals(name)) {
        return includedPathInfo.getRequestURI();
      }
 else       if (INCLUDE_SERVLET_PATH.equals(name)) {
        return includedPathInfo.getServletPath();
      }
    }
    if (forwardedPathInfo != null && !forwardedPathInfo.isNamedRequestDispatcher()) {
      if (FORWARD_CONTEXT_PATH.equals(name)) {
        return getContextPath();
      }
 else       if (FORWARD_PATH_INFO.equals(name)) {
        return forwardedPathInfo.getPathInfo();
      }
 else       if (FORWARD_QUERY_STRING.equals(name)) {
        return forwardedPathInfo.getQueryString();
      }
 else       if (FORWARD_REQUEST_URI.equals(name)) {
        return forwardedPathInfo.getRequestURI();
      }
 else       if (FORWARD_SERVLET_PATH.equals(name)) {
        return forwardedPathInfo.getServletPath();
      }
    }
    return null;
  }
  if (value == null && !dispatching) {
    value=getRequest().getAttribute(name);
  }
  return value != null ? value : portletRequest.getAttribute(name);
}",0.933943754087639
90636,"public RequestDispatcherPathInfo getPathInfo(String contextPath,String path){
  String servletPath=null;
  String pathInfo=null;
  String queryString=null;
  int index=path.indexOf('?');
  if (index != -1) {
    queryString=path.substring(index + 1,path.length());
    path=path.substring(0,index);
  }
  if (exactServletMappingURLPatterns.contains(path)) {
    servletPath=path;
  }
 else   if (path.length() == 1 && defaultServletMapping) {
    servletPath=path;
  }
 else {
    String sub=path;
    index=path.lastIndexOf('/');
    while (index > 0) {
      sub=sub.substring(0,index);
      if (pathServletMappingURLPatterns.contains(sub)) {
        servletPath=sub;
        if (sub.length() < path.length()) {
          pathInfo=path.substring(sub.length());
        }
        break;
      }
      index=sub.lastIndexOf('/');
    }
  }
  if (servletPath == null) {
    index=path.lastIndexOf('/');
    int ext=path.indexOf('.',index);
    if (ext != -1 && ext < path.length() - 1 && extServletMappingURLPatterns.contains(path.substring(ext))) {
      servletPath=index > 0 ? path.substring(0,index) : ""String_Node_Str"";
      pathInfo=path.substring(index);
    }
  }
  if (servletPath == null) {
    servletPath=path;
  }
  return new RequestDispatcherPathInfoImpl(contextPath,servletPath,pathInfo,queryString);
}","public RequestDispatcherPathInfo getPathInfo(String contextPath,String path){
  String servletPath=null;
  String pathInfo=null;
  String queryString=null;
  int index=path.indexOf('?');
  if (index != -1) {
    queryString=path.substring(index + 1,path.length());
    path=path.substring(0,index);
  }
  if (exactServletMappingURLPatterns.contains(path)) {
    servletPath=path;
  }
 else   if (path.length() == 1 && defaultServletMapping) {
    servletPath=path;
  }
 else {
    String sub=path;
    index=path.lastIndexOf('/');
    while (index > 0) {
      sub=sub.substring(0,index);
      if (pathServletMappingURLPatterns.contains(sub)) {
        servletPath=sub;
        if (sub.length() < path.length()) {
          pathInfo=path.substring(sub.length());
        }
        break;
      }
      index=sub.lastIndexOf('/');
    }
  }
  if (servletPath == null) {
    servletPath=path;
  }
  return new RequestDispatcherPathInfoImpl(contextPath,servletPath,pathInfo,queryString);
}",0.8560277536860365
90637,"private RequestDispatcherPathInfoProviderImpl(Set<String> servletMappingURLPatterns){
  for (  String pat : servletMappingURLPatterns) {
    if (pat.startsWith(""String_Node_Str"")) {
      if (pat.equals(""String_Node_Str"") || pat.equals(""String_Node_Str"")) {
        defaultServletMapping=true;
      }
 else       if (pat.endsWith(""String_Node_Str"")) {
        pathServletMappingURLPatterns.add(pat.substring(0,pat.length() - 2));
      }
 else {
        exactServletMappingURLPatterns.add(pat);
      }
    }
 else     if (pat.startsWith(""String_Node_Str"")) {
      extServletMappingURLPatterns.add(pat.substring(1));
    }
 else {
      exactServletMappingURLPatterns.add(pat);
    }
  }
}","private RequestDispatcherPathInfoProviderImpl(Set<String> servletMappingURLPatterns){
  for (  String pat : servletMappingURLPatterns) {
    if (pat.startsWith(""String_Node_Str"")) {
      if (pat.equals(""String_Node_Str"") || pat.equals(""String_Node_Str"")) {
        defaultServletMapping=true;
      }
 else       if (pat.endsWith(""String_Node_Str"")) {
        pathServletMappingURLPatterns.add(pat.substring(0,pat.length() - 2));
      }
 else {
        exactServletMappingURLPatterns.add(pat);
      }
    }
 else     if (pat.startsWith(""String_Node_Str"")) {
    }
 else {
      exactServletMappingURLPatterns.add(pat);
    }
  }
}",0.9259818731117824
90638,"protected boolean isPortletModeAllowedByPortlet(PortletMode mode){
  PortletDefinition dd=getPortletWindow().getPortletEntity().getPortletDefinition();
  Iterator supports=dd.getSupports().iterator();
  while (supports.hasNext()) {
    Supports sup=(Supports)supports.next();
    List<String> portletModes=sup.getPortletModes();
    if (portletModes == null)     return false;
    Iterator modes=portletModes.iterator();
    while (modes.hasNext()) {
      if (modes.next().toString().equalsIgnoreCase(mode.toString())) {
        return true;
      }
    }
  }
  return false;
}","protected boolean isPortletModeAllowedByPortlet(PortletMode mode){
  if (PortletMode.VIEW.equals(mode))   return true;
  PortletDefinition dd=getPortletWindow().getPortletEntity().getPortletDefinition();
  Iterator supports=dd.getSupports().iterator();
  while (supports.hasNext()) {
    Supports sup=(Supports)supports.next();
    List<String> portletModes=sup.getPortletModes();
    if (portletModes == null)     return false;
    Iterator modes=portletModes.iterator();
    while (modes.hasNext()) {
      if (modes.next().toString().equalsIgnoreCase(mode.toString())) {
        return true;
      }
    }
  }
  return false;
}",0.956953642384106
90639,"/** 
 * Dispatch the request to the appropriate portlet methods. This method assumes that the following attributes are set in the servlet request scope: <ul> <li>METHOD_ID: indicating which method to dispatch.</li> <li>PORTLET_REQUEST: the internal portlet request.</li> <li>PORTLET_RESPONSE: the internal portlet response.</li> </ul>
 * @param request the servlet request.
 * @param response the servlet response.
 * @throws ServletException
 * @throws IOException
 */
private void dispatch(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException {
  InternalPortletRequest portletRequest=null;
  InternalPortletResponse portletResponse=null;
  request.setAttribute(Constants.PORTLET_CONFIG,portletConfig);
  Integer methodId=(Integer)request.getAttribute(Constants.METHOD_ID);
  portletRequest=(InternalPortletRequest)request.getAttribute(Constants.PORTLET_REQUEST);
  portletResponse=(InternalPortletResponse)request.getAttribute(Constants.PORTLET_RESPONSE);
  FilterManager filterManager=(FilterManager)request.getAttribute(Constants.FILTER_MANAGER);
  portletRequest.init(portletContext,request);
  PortletWindow window=containerInvocationService.getInvocation().getPortletWindow();
  PortletInvocationEvent event=new PortletInvocationEvent(portletRequest,window,methodId.intValue());
  notify(event,true,null);
  ClassLoader loader=Thread.currentThread().getContextClassLoader();
  try {
    if (methodId == Constants.METHOD_RENDER) {
      RenderRequest renderRequest=(RenderRequest)portletRequest;
      RenderResponse renderResponse=(RenderResponse)portletResponse;
      filterManager.processFilter(renderRequest,renderResponse,loader,portlet,portletContext);
    }
 else     if (methodId == Constants.METHOD_RESOURCE) {
      ResourceRequest resourceRequest=(ResourceRequest)portletRequest;
      ResourceResponse resourceResponse=(ResourceResponse)portletResponse;
      filterManager.processFilter(resourceRequest,resourceResponse,loader,resourceServingPortlet,portletContext);
    }
 else     if (methodId == Constants.METHOD_ACTION) {
      ActionRequest actionRequest=(ActionRequest)portletRequest;
      ActionResponse actionResponse=(ActionResponse)portletResponse;
      filterManager.processFilter(actionRequest,actionResponse,loader,portlet,portletContext);
    }
 else     if (methodId == Constants.METHOD_EVENT) {
      EventRequest eventRequest=(EventRequest)portletRequest;
      EventResponse eventResponse=(EventResponse)portletResponse;
      filterManager.processFilter(eventRequest,eventResponse,loader,eventPortlet,portletContext);
    }
 else     if (methodId == Constants.METHOD_ADMIN) {
      ContainerInvocation inv=containerInvocationService.getInvocation();
      PortalAdministrationService pas=inv.getPortletContainer().getOptionalContainerServices().getPortalAdministrationService();
      Iterator it=pas.getAdministrativeRequestListeners().iterator();
      while (it.hasNext()) {
        AdministrativeRequestListener l=(AdministrativeRequestListener)it.next();
        l.administer(portletRequest,portletResponse);
      }
    }
 else     if (methodId == Constants.METHOD_NOOP) {
    }
    notify(event,false,null);
  }
 catch (  javax.portlet.UnavailableException ex) {
    System.err.println(ex.getMessage());
    try {
      portlet.destroy();
    }
 catch (    Throwable th) {
      System.err.println(ex.getMessage());
    }
    throw new javax.servlet.UnavailableException(ex.getMessage());
  }
catch (  PortletException ex) {
    notify(event,false,ex);
    System.err.println(ex.getMessage());
    throw new ServletException(ex);
  }
 finally {
    request.removeAttribute(Constants.PORTLET_CONFIG);
    if (portletRequest != null) {
      portletRequest.release();
    }
  }
}","/** 
 * Dispatch the request to the appropriate portlet methods. This method assumes that the following attributes are set in the servlet request scope: <ul> <li>METHOD_ID: indicating which method to dispatch.</li> <li>PORTLET_REQUEST: the internal portlet request.</li> <li>PORTLET_RESPONSE: the internal portlet response.</li> </ul>
 * @param request the servlet request.
 * @param response the servlet response.
 * @throws ServletException
 * @throws IOException
 */
private void dispatch(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException {
  if (portlet == null) {
    throw new javax.servlet.UnavailableException(""String_Node_Str"" + portletName + ""String_Node_Str"");
  }
  InternalPortletRequest portletRequest=null;
  InternalPortletResponse portletResponse=null;
  request.setAttribute(Constants.PORTLET_CONFIG,portletConfig);
  Integer methodId=(Integer)request.getAttribute(Constants.METHOD_ID);
  portletRequest=(InternalPortletRequest)request.getAttribute(Constants.PORTLET_REQUEST);
  portletResponse=(InternalPortletResponse)request.getAttribute(Constants.PORTLET_RESPONSE);
  FilterManager filterManager=(FilterManager)request.getAttribute(Constants.FILTER_MANAGER);
  portletRequest.init(portletContext,request);
  PortletWindow window=containerInvocationService.getInvocation().getPortletWindow();
  PortletInvocationEvent event=new PortletInvocationEvent(portletRequest,window,methodId.intValue());
  notify(event,true,null);
  ClassLoader loader=Thread.currentThread().getContextClassLoader();
  try {
    if (methodId == Constants.METHOD_RENDER) {
      RenderRequest renderRequest=(RenderRequest)portletRequest;
      RenderResponse renderResponse=(RenderResponse)portletResponse;
      filterManager.processFilter(renderRequest,renderResponse,loader,portlet,portletContext);
    }
 else     if (methodId == Constants.METHOD_RESOURCE) {
      ResourceRequest resourceRequest=(ResourceRequest)portletRequest;
      ResourceResponse resourceResponse=(ResourceResponse)portletResponse;
      filterManager.processFilter(resourceRequest,resourceResponse,loader,resourceServingPortlet,portletContext);
    }
 else     if (methodId == Constants.METHOD_ACTION) {
      ActionRequest actionRequest=(ActionRequest)portletRequest;
      ActionResponse actionResponse=(ActionResponse)portletResponse;
      filterManager.processFilter(actionRequest,actionResponse,loader,portlet,portletContext);
    }
 else     if (methodId == Constants.METHOD_EVENT) {
      EventRequest eventRequest=(EventRequest)portletRequest;
      EventResponse eventResponse=(EventResponse)portletResponse;
      filterManager.processFilter(eventRequest,eventResponse,loader,eventPortlet,portletContext);
    }
 else     if (methodId == Constants.METHOD_ADMIN) {
      ContainerInvocation inv=containerInvocationService.getInvocation();
      PortalAdministrationService pas=inv.getPortletContainer().getOptionalContainerServices().getPortalAdministrationService();
      Iterator it=pas.getAdministrativeRequestListeners().iterator();
      while (it.hasNext()) {
        AdministrativeRequestListener l=(AdministrativeRequestListener)it.next();
        l.administer(portletRequest,portletResponse);
      }
    }
 else     if (methodId == Constants.METHOD_NOOP) {
    }
    notify(event,false,null);
  }
 catch (  javax.portlet.UnavailableException ex) {
    System.err.println(ex.getMessage());
    try {
      portlet.destroy();
    }
 catch (    Throwable th) {
      System.err.println(ex.getMessage());
    }
    portlet=null;
    throw new javax.servlet.UnavailableException(ex.getMessage());
  }
catch (  PortletException ex) {
    notify(event,false,ex);
    System.err.println(ex.getMessage());
    throw new ServletException(ex);
  }
 finally {
    request.removeAttribute(Constants.PORTLET_CONFIG);
    if (portletRequest != null) {
      portletRequest.release();
    }
  }
}",0.9804789172306092
90640,"protected boolean attemptRegistration(ServletContext context,ClassLoader paClassLoader){
  if (PlutoServices.getServices() != null) {
    contextService=PlutoServices.getServices().getPortletContextService();
    containerInvocationService=PlutoServices.getServices().getContainerInvocationService();
    try {
      ServletConfig sConfig=getServletConfig();
      if (sConfig == null) {
        String msg=""String_Node_Str"";
        context.log(msg);
        return true;
      }
      String applicationName=contextService.register(sConfig);
      started=true;
      portletContext=(InternalPortletContext)contextService.getPortletContext(applicationName);
      portletConfig=(InternalPortletConfig)contextService.getPortletConfig(applicationName,portletName);
    }
 catch (    PortletContainerException ex) {
      context.log(ex.getMessage(),ex);
      return true;
    }
    PortletDefinition portletDD=portletConfig.getPortletDefinition();
    try {
      Class clazz=paClassLoader.loadClass((portletDD.getPortletClass()));
      portlet=(Portlet)clazz.newInstance();
      portlet.init(portletConfig);
      initializeEventPortlet();
      initializeResourceServingPortlet();
      return true;
    }
 catch (    Exception ex) {
      context.log(ex.getMessage(),ex);
      return true;
    }
  }
  return false;
}","protected boolean attemptRegistration(ServletContext context,ClassLoader paClassLoader){
  if (PlutoServices.getServices() != null) {
    contextService=PlutoServices.getServices().getPortletContextService();
    containerInvocationService=PlutoServices.getServices().getContainerInvocationService();
    try {
      ServletConfig sConfig=getServletConfig();
      if (sConfig == null) {
        String msg=""String_Node_Str"";
        context.log(msg);
        return true;
      }
      String applicationName=contextService.register(sConfig);
      started=true;
      portletContext=(InternalPortletContext)contextService.getPortletContext(applicationName);
      portletConfig=(InternalPortletConfig)contextService.getPortletConfig(applicationName,portletName);
    }
 catch (    PortletContainerException ex) {
      context.log(ex.getMessage(),ex);
      return true;
    }
    PortletDefinition portletDD=portletConfig.getPortletDefinition();
    try {
      Class clazz=paClassLoader.loadClass((portletDD.getPortletClass()));
      portlet=(Portlet)clazz.newInstance();
      portlet.init(portletConfig);
      initializeEventPortlet();
      initializeResourceServingPortlet();
      return true;
    }
 catch (    Exception ex) {
      context.log(ex.getMessage(),ex);
      portlet=null;
      portletConfig=null;
      return true;
    }
  }
  return false;
}",0.9829250185597624
90641,"public void destroy(){
synchronized (getServletContext()) {
    if (startTimer != null) {
      startTimer.cancel();
      startTimer=null;
    }
 else     if (started && portletContext != null) {
      started=false;
      contextService.unregister(portletContext);
      if (portlet != null) {
        portlet.destroy();
      }
    }
    super.destroy();
  }
}","public void destroy(){
synchronized (getServletContext()) {
    if (startTimer != null) {
      startTimer.cancel();
      startTimer=null;
    }
 else     if (started && portletContext != null) {
      started=false;
      contextService.unregister(portletContext);
      if (portlet != null) {
        try {
          portlet.destroy();
        }
 catch (        Exception e) {
        }
        portlet=null;
      }
    }
    super.destroy();
  }
}",0.8907975460122699
90642,"/** 
 * Parse a servlet request to a portal URL.
 * @param request  the servlet request to parse.
 * @return the portal URL.
 */
public PortalURL parse(HttpServletRequest request){
  if (LOG.isDebugEnabled()) {
    LOG.debug(""String_Node_Str"" + request.getRequestURI());
  }
  String contextPath=request.getContextPath();
  String servletName=request.getServletPath();
  PortalURL portalURL=new RelativePortalURLImpl(contextPath,servletName,this);
  String pathInfo=request.getPathInfo();
  if (pathInfo == null) {
    if (servletName.contains(""String_Node_Str"") && !servletName.endsWith(""String_Node_Str"")) {
      int idx=servletName.indexOf(""String_Node_Str"") + ""String_Node_Str"".length();
      pathInfo=servletName.substring(idx);
      servletName=servletName.substring(0,idx);
      portalURL=new RelativePortalURLImpl(contextPath,servletName,this);
    }
 else {
      return portalURL;
    }
  }
  if (LOG.isDebugEnabled()) {
    LOG.debug(""String_Node_Str"" + pathInfo);
  }
  StringBuffer renderPath=new StringBuffer();
  StringTokenizer st=new StringTokenizer(pathInfo,""String_Node_Str"",false);
  while (st.hasMoreTokens()) {
    String token=st.nextToken();
    if (!token.startsWith(PREFIX)) {
      renderPath.append('/').append(token);
    }
 else     if (token.startsWith(PREFIX + RESOURCE)) {
      portalURL.setResourceWindow(decodeControlParameter(token)[0]);
    }
 else     if (token.startsWith(PREFIX + ACTION)) {
      portalURL.setActionWindow(decodeControlParameter(token)[0]);
    }
 else     if (token.startsWith(PREFIX + WINDOW_STATE)) {
      String[] decoded=decodeControlParameter(token);
      portalURL.setWindowState(decoded[0],new WindowState(decoded[1]));
    }
 else     if (token.startsWith(PREFIX + PORTLET_MODE)) {
      String[] decoded=decodeControlParameter(token);
      portalURL.setPortletMode(decoded[0],new PortletMode(decoded[1]));
    }
 else     if (token.startsWith(PREFIX + RENDER_PARAM)) {
      String value=null;
      if (st.hasMoreTokens()) {
        value=st.nextToken();
      }
      PortalURLParameter param=decodeParameter(token,value);
      portalURL.addParameter(param);
    }
 else {
      String value=null;
      if (st.hasMoreTokens()) {
        value=st.nextToken();
      }
      PortalURLParameter param=decodePublicParameter(token,value);
      if (param != null) {
        portalURL.addParameter(param);
      }
      portalURL.addPublicParameterCurrent(param.getName(),param.getValues());
    }
  }
  if (renderPath.length() > 0) {
    portalURL.setRenderPath(renderPath.toString());
  }
  return portalURL;
}","/** 
 * Parse a servlet request to a portal URL.
 * @param request  the servlet request to parse.
 * @return the portal URL.
 */
public PortalURL parse(HttpServletRequest request){
  if (LOG.isDebugEnabled()) {
    LOG.debug(""String_Node_Str"" + request.getRequestURI());
  }
  String contextPath=request.getContextPath();
  String servletName=request.getServletPath();
  PortalURL portalURL=new RelativePortalURLImpl(contextPath,servletName,this);
  String pathInfo=request.getPathInfo();
  if (pathInfo == null) {
    if (servletName.contains(""String_Node_Str"") && !servletName.endsWith(""String_Node_Str"")) {
      int idx=servletName.indexOf(""String_Node_Str"") + ""String_Node_Str"".length();
      pathInfo=servletName.substring(idx);
      servletName=servletName.substring(0,idx);
      portalURL=new RelativePortalURLImpl(contextPath,servletName,this);
    }
 else {
      return portalURL;
    }
  }
  if (LOG.isDebugEnabled()) {
    LOG.debug(""String_Node_Str"" + pathInfo);
  }
  StringBuffer renderPath=new StringBuffer();
  StringTokenizer st=new StringTokenizer(pathInfo,""String_Node_Str"",false);
  while (st.hasMoreTokens()) {
    String token=st.nextToken();
    if (!token.startsWith(PREFIX)) {
      renderPath.append('/').append(token);
    }
 else     if (token.startsWith(PREFIX + RESOURCE)) {
      portalURL.setResourceWindow(decodeControlParameter(token)[0]);
    }
 else     if (token.startsWith(PREFIX + ACTION)) {
      portalURL.setActionWindow(decodeControlParameter(token)[0]);
    }
 else     if (token.startsWith(PREFIX + WINDOW_STATE)) {
      String[] decoded=decodeControlParameter(token);
      portalURL.setWindowState(decoded[0],new WindowState(decoded[1]));
    }
 else     if (token.startsWith(PREFIX + PORTLET_MODE)) {
      String[] decoded=decodeControlParameter(token);
      portalURL.setPortletMode(decoded[0],new PortletMode(decoded[1]));
    }
 else     if (token.startsWith(PREFIX + RENDER_PARAM)) {
      String value=null;
      if (st.hasMoreTokens()) {
        value=st.nextToken();
      }
      PortalURLParameter param=decodeParameter(token,value);
      portalURL.addParameter(param);
    }
 else {
      String value=null;
      if (st.hasMoreTokens()) {
        value=st.nextToken();
      }
      PortalURLParameter param=decodePublicParameter(token,value);
      if (param != null) {
        portalURL.addPublicParameterCurrent(param.getName(),param.getValues());
      }
    }
  }
  if (renderPath.length() > 0) {
    portalURL.setRenderPath(renderPath.toString());
  }
  return portalURL;
}",0.9335671147477108
90643,"/** 
 * Converts a portal URL to a URL string.
 * @param portalURL  the portal URL to convert.
 * @return a URL string representing the portal URL.
 */
public String toString(PortalURL portalURL){
  StringBuffer buffer=new StringBuffer();
  buffer.append(portalURL.getServletPath().startsWith(""String_Node_Str"") ? ""String_Node_Str"" : ""String_Node_Str"").append(portalURL.getServletPath());
  if (portalURL.getRenderPath() != null) {
    buffer.append(""String_Node_Str"").append(portalURL.getRenderPath());
  }
  if (portalURL.getResourceWindow() != null) {
    buffer.append(""String_Node_Str"");
    buffer.append(PREFIX).append(RESOURCE).append(encodeCharacters(portalURL.getResourceWindow()));
  }
  if (portalURL.getActionWindow() != null) {
    buffer.append(""String_Node_Str"");
    buffer.append(PREFIX).append(ACTION).append(encodeCharacters(portalURL.getActionWindow()));
  }
  for (Iterator it=portalURL.getPortletModes().entrySet().iterator(); it.hasNext(); ) {
    Map.Entry entry=(Map.Entry)it.next();
    buffer.append(""String_Node_Str"").append(encodeControlParameter(PORTLET_MODE,entry.getKey().toString(),entry.getValue().toString()));
  }
  for (Iterator it=portalURL.getWindowStates().entrySet().iterator(); it.hasNext(); ) {
    Map.Entry entry=(Map.Entry)it.next();
    buffer.append(""String_Node_Str"").append(encodeControlParameter(WINDOW_STATE,entry.getKey().toString(),entry.getValue().toString()));
  }
  StringBuffer query=new StringBuffer(""String_Node_Str"");
  boolean firstParam=true;
  for (Iterator it=portalURL.getParameters().iterator(); it.hasNext(); ) {
    PortalURLParameter param=(PortalURLParameter)it.next();
    if (portalURL.getActionWindow() != null && portalURL.getActionWindow().equals(param.getWindowId()) || (portalURL.getResourceWindow() != null && portalURL.getResourceWindow().equals(param.getWindowId()))) {
      for (int i=0; i < param.getValues().length; i++) {
        if (firstParam) {
          firstParam=false;
        }
 else {
          query.append(""String_Node_Str"");
        }
        query.append(encodeQueryParam(param.getName())).append(""String_Node_Str"").append(encodeQueryParam(param.getValues()[i]));
      }
    }
 else     if (param.getValues() != null && param.getValues().length > 0) {
      String valueString=encodeMultiValues(param.getValues());
      if (valueString.length() > 0) {
        buffer.append(""String_Node_Str"").append(encodeControlParameter(RENDER_PARAM,param.getWindowId(),param.getName()));
        buffer.append(""String_Node_Str"").append(valueString);
      }
    }
  }
  StringUtils.encode(buffer);
  if (query.length() > 1) {
    return buffer.append(query).toString();
  }
  Map<String,String[]> publicParamList=portalURL.getPublicParameters();
  if (publicParamList != null) {
    for (Iterator iter=publicParamList.keySet().iterator(); iter.hasNext(); ) {
      String paramname=(String)iter.next();
      String[] tmp=(String[])publicParamList.get(paramname);
      String valueString=encodeMultiValues(tmp);
      if (valueString.length() > 0) {
        buffer.append(""String_Node_Str"").append(encodePublicParamname(PUBLIC_RENDER_PARAM,paramname));
        buffer.append(""String_Node_Str"").append(valueString);
      }
    }
  }
  return buffer.append(query).toString();
}","/** 
 * Converts a portal URL to a URL string.
 * @param portalURL  the portal URL to convert.
 * @return a URL string representing the portal URL.
 */
public String toString(PortalURL portalURL){
  StringBuffer buffer=new StringBuffer();
  buffer.append(portalURL.getServletPath().startsWith(""String_Node_Str"") ? ""String_Node_Str"" : ""String_Node_Str"").append(portalURL.getServletPath());
  if (portalURL.getRenderPath() != null) {
    buffer.append(""String_Node_Str"").append(portalURL.getRenderPath());
  }
  if (portalURL.getResourceWindow() != null) {
    buffer.append(""String_Node_Str"");
    buffer.append(PREFIX).append(RESOURCE).append(encodeCharacters(portalURL.getResourceWindow()));
  }
  if (portalURL.getActionWindow() != null) {
    buffer.append(""String_Node_Str"");
    buffer.append(PREFIX).append(ACTION).append(encodeCharacters(portalURL.getActionWindow()));
  }
  for (Iterator it=portalURL.getPortletModes().entrySet().iterator(); it.hasNext(); ) {
    Map.Entry entry=(Map.Entry)it.next();
    buffer.append(""String_Node_Str"").append(encodeControlParameter(PORTLET_MODE,entry.getKey().toString(),entry.getValue().toString()));
  }
  for (Iterator it=portalURL.getWindowStates().entrySet().iterator(); it.hasNext(); ) {
    Map.Entry entry=(Map.Entry)it.next();
    buffer.append(""String_Node_Str"").append(encodeControlParameter(WINDOW_STATE,entry.getKey().toString(),entry.getValue().toString()));
  }
  StringBuffer query=new StringBuffer(""String_Node_Str"");
  boolean firstParam=true;
  for (Iterator it=portalURL.getParameters().iterator(); it.hasNext(); ) {
    PortalURLParameter param=(PortalURLParameter)it.next();
    if (portalURL.getActionWindow() != null && portalURL.getActionWindow().equals(param.getWindowId()) || (portalURL.getResourceWindow() != null && portalURL.getResourceWindow().equals(param.getWindowId()))) {
      for (int i=0; i < param.getValues().length; i++) {
        if (firstParam) {
          firstParam=false;
        }
 else {
          query.append(""String_Node_Str"");
        }
        query.append(encodeQueryParam(param.getName())).append(""String_Node_Str"").append(encodeQueryParam(param.getValues()[i]));
      }
    }
 else     if (param.getValues() != null && param.getValues().length > 0) {
      String valueString=encodeMultiValues(param.getValues());
      if (valueString.length() > 0) {
        buffer.append(""String_Node_Str"").append(encodeControlParameter(RENDER_PARAM,param.getWindowId(),param.getName()));
        buffer.append(""String_Node_Str"").append(valueString);
      }
    }
  }
  StringUtils.encode(buffer);
  Map<String,String[]> publicParamList=portalURL.getPublicParameters();
  if (publicParamList != null) {
    for (Iterator iter=publicParamList.keySet().iterator(); iter.hasNext(); ) {
      String paramname=(String)iter.next();
      String[] tmp=(String[])publicParamList.get(paramname);
      String valueString=encodeMultiValues(tmp);
      if (valueString.length() > 0) {
        buffer.append(""String_Node_Str"").append(encodePublicParamname(PUBLIC_RENDER_PARAM,paramname));
        buffer.append(""String_Node_Str"").append(valueString);
      }
    }
  }
  if (query.length() > 1) {
    return buffer.append(query).toString();
  }
  return buffer.append(query).toString();
}",0.9767299448867116
90644,"public void setParameters(Map<String,String[]> parameters){
  if (parameters == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  for (Iterator iter=parameters.entrySet().iterator(); iter.hasNext(); ) {
    Map.Entry entry=(Map.Entry)iter.next();
    if (!(entry.getKey() instanceof String)) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
    if (!(entry.getValue() instanceof String[])) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
  }
  this.parameters.clear();
  this.publicRenderParameters.clear();
  List<String> publicPortletRenderParameterNames=internalPortletWindow.getPortletEntity().getPortletDefinition().getPublicRenderParameter();
  if (parameters.keySet() != null) {
    for (    Object key : parameters.keySet()) {
      if (publicPortletRenderParameterNames == null)       this.setParameter((String)key,(String[])parameters.get(key));
 else {
        if (publicPortletRenderParameterNames.contains(key))         publicRenderParameters.put((String)key,(String[])parameters.get(key));
 else         this.setParameter((String)key,(String[])parameters.get(key));
      }
    }
  }
}","public void setParameters(Map<String,String[]> parameters){
  if (parameters == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  for (Iterator iter=parameters.entrySet().iterator(); iter.hasNext(); ) {
    Map.Entry entry=(Map.Entry)iter.next();
    if (!(entry.getKey() instanceof String)) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
    if (!(entry.getValue() instanceof String[])) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
  }
  this.parameters.clear();
  this.publicRenderParameters.clear();
  List<String> publicPortletRenderParameterNames=internalPortletWindow.getPortletEntity().getPortletDefinition().getPublicRenderParameter();
  if (parameters.keySet() != null) {
    for (    Object key : parameters.keySet()) {
      if (publicPortletRenderParameterNames == null)       this.setParameter((String)key,(String[])parameters.get(key));
 else {
        if (publicPortletRenderParameterNames.contains(key) && !this.isAction && !this.isResourceServing)         publicRenderParameters.put((String)key,(String[])parameters.get(key));
 else         this.setParameter((String)key,(String[])parameters.get(key));
      }
    }
  }
}",0.9810206663854912
90645,"public void setParameter(String name,String[] values){
  if (name == null || values == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  List<String> publicRenderParameterNames=internalPortletWindow.getPortletEntity().getPortletDefinition().getPublicRenderParameter();
  if (publicRenderParameterNames == null) {
    parameters.put(name,StringUtils.copy(values));
  }
 else {
    if (publicRenderParameterNames.contains(name)) {
      publicRenderParameters.put(name,StringUtils.copy(values));
    }
 else {
      parameters.put(name,StringUtils.copy(values));
    }
  }
}","public void setParameter(String name,String[] values){
  if (name == null || values == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  List<String> publicRenderParameterNames=internalPortletWindow.getPortletEntity().getPortletDefinition().getPublicRenderParameter();
  if (publicRenderParameterNames == null) {
    parameters.put(name,StringUtils.copy(values));
  }
 else {
    if (publicRenderParameterNames.contains(name) && !this.isAction && !this.isResourceServing) {
      publicRenderParameters.put(name,StringUtils.copy(values));
    }
 else {
      parameters.put(name,StringUtils.copy(values));
    }
  }
}",0.9635627530364372
90646,"public Map<String,String[]> getPublicParameterMap(){
  Map<String,String[]> map=new HashMap<String,String[]>();
  PortletURLProvider urlProvider=container.getRequiredContainerServices().getPortalCallbackService().getPortletURLProvider(getHttpServletRequest(),internalPortletWindow);
  List<String> publicRenderParameterNames=internalPortletWindow.getPortletEntity().getPortletDefinition().getPublicRenderParameter();
  String[] values=null;
  for (  String string : publicRenderParameterNames) {
    values=urlProvider.getPublicRenderParameters(string);
    if (values != null) {
      map.put(string,values);
    }
  }
  return Collections.unmodifiableMap(map);
}","public Map<String,String[]> getPublicParameterMap(){
  Map<String,String[]> map=new HashMap<String,String[]>();
  PortletURLProvider urlProvider=container.getRequiredContainerServices().getPortalCallbackService().getPortletURLProvider(getHttpServletRequest(),internalPortletWindow);
  List<String> publicRenderParameterNames=internalPortletWindow.getPortletEntity().getPortletDefinition().getPublicRenderParameter();
  String[] values=null;
  if (publicRenderParameterNames != null) {
    for (    String string : publicRenderParameterNames) {
      values=urlProvider.getPublicRenderParameters(string);
      if (values != null) {
        map.put(string,values);
      }
    }
  }
  return Collections.unmodifiableMap(map);
}",0.814388489208633
90647,"public void removePublicRenderParameter(String name){
  List<String> publicRenderParameterNames=super.getInternalPortletWindow().getPortletEntity().getPortletDefinition().getPublicRenderParameter();
  if (publicRenderParameterNames != null) {
    if (publicRenderParameterNames.contains(name)) {
      publicRenderParameter.put(name,new String[]{null});
    }
 else {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
  }
}","public void removePublicRenderParameter(String name){
  List<String> publicRenderParameterNames=super.getInternalPortletWindow().getPortletEntity().getPortletDefinition().getPublicRenderParameter();
  if (publicRenderParameterNames != null) {
    if (publicRenderParameterNames.contains(name)) {
      publicRenderParameter.put(name,new String[]{null});
    }
 else {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
  }
  redirectAllowed=false;
}",0.9723756906077348
90648,"public void setEvent(String name,Serializable value){
  String contextPath=getInternalPortletWindow().getContextPath();
  String defaultNamespace;
  try {
    defaultNamespace=getContainer().getPortletApplicationDescriptor(contextPath).getDefaultNamespace();
  }
 catch (  PortletContainerException e) {
    LOG.error(contextPath,e);
    defaultNamespace=XMLConstants.NULL_NS_URI;
  }
  QName qname=new QName(defaultNamespace,name);
  setEvent(qname,value);
}","public void setEvent(String name,Serializable value){
  String contextPath=getInternalPortletWindow().getContextPath();
  String defaultNamespace;
  try {
    defaultNamespace=getContainer().getPortletApplicationDescriptor(contextPath).getDefaultNamespace();
  }
 catch (  PortletContainerException e) {
    LOG.error(contextPath,e);
    defaultNamespace=XMLConstants.NULL_NS_URI;
  }
  QName qname=new QName(defaultNamespace,name);
  setEvent(qname,value);
  redirectAllowed=false;
}",0.9734888653234358
90649,"/** 
 * Handle all requests. All POST requests are passed to this method.
 * @param request  the incoming HttpServletRequest.
 * @param response  the incoming HttpServletResponse.
 * @throws ServletException  if an internal error occurs.
 * @throws IOException  if an error occurs writing to the response.
 */
public void doGet(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException {
  PortalRequestContext portalRequestContext=new PortalRequestContext(getServletContext(),request,response);
  PortalURL portalURL=portalRequestContext.getRequestedPortalURL();
  String actionWindowId=portalURL.getActionWindow();
  String resourceWindowId=portalURL.getResourceWindow();
  PortletWindowConfig actionWindowConfig=null;
  PortletWindowConfig resourceWindowConfig=null;
  if (resourceWindowId != null) {
    resourceWindowConfig=PortletWindowConfig.fromId(resourceWindowId);
  }
 else   if (actionWindowId != null) {
    actionWindowConfig=PortletWindowConfig.fromId(actionWindowId);
  }
  if (actionWindowConfig != null) {
    try {
      if (request.getParameterNames().hasMoreElements()) {
        setPublicRenderParameter(request,portalURL,portalURL.getActionWindow());
      }
    }
 catch (    PortletContainerException e) {
      LOG.warn(e);
    }
    PortletWindowImpl portletWindow=new PortletWindowImpl(actionWindowConfig,portalURL);
    if (LOG.isDebugEnabled()) {
      LOG.debug(""String_Node_Str"" + portletWindow.getId().getStringId());
    }
    try {
      container.doAction(portletWindow,request,response);
    }
 catch (    PortletContainerException ex) {
      throw new ServletException(ex);
    }
catch (    PortletException ex) {
      throw new ServletException(ex);
    }
    if (LOG.isDebugEnabled()) {
      LOG.debug(""String_Node_Str"");
    }
  }
 else   if (resourceWindowConfig != null) {
    try {
      if (request.getParameterNames().hasMoreElements())       setPublicRenderParameter(request,portalURL,portalURL.getResourceWindow());
    }
 catch (    PortletContainerException e) {
      LOG.warn(e);
    }
    PortletWindowImpl portletWindow=new PortletWindowImpl(resourceWindowConfig,portalURL);
    if (LOG.isDebugEnabled()) {
      LOG.debug(""String_Node_Str"" + portletWindow.getId().getStringId());
    }
    try {
      container.doServeResource(portletWindow,request,response);
    }
 catch (    PortletContainerException ex) {
      throw new ServletException(ex);
    }
catch (    PortletException ex) {
      throw new ServletException(ex);
    }
    if (LOG.isDebugEnabled()) {
      LOG.debug(""String_Node_Str"");
    }
  }
 else {
    if (LOG.isDebugEnabled()) {
      LOG.debug(""String_Node_Str"");
    }
    PageConfig pageConfig=portalURL.getPageConfig(servletContext);
    if (pageConfig == null) {
      LOG.error(""String_Node_Str"" + portalURL.getRenderPath() + ""String_Node_Str"");
    }
    request.setAttribute(AttributeKeys.CURRENT_PAGE,pageConfig);
    String uri=(pageConfig.getUri() != null) ? pageConfig.getUri() : DEFAULT_PAGE_URI;
    if (LOG.isDebugEnabled()) {
      LOG.debug(""String_Node_Str"" + uri);
    }
    RequestDispatcher dispatcher=request.getRequestDispatcher(uri);
    dispatcher.forward(request,response);
    if (LOG.isDebugEnabled()) {
      LOG.debug(""String_Node_Str"");
    }
  }
}","/** 
 * Handle all requests. All POST requests are passed to this method.
 * @param request  the incoming HttpServletRequest.
 * @param response  the incoming HttpServletResponse.
 * @throws ServletException  if an internal error occurs.
 * @throws IOException  if an error occurs writing to the response.
 */
public void doGet(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException {
  PortalRequestContext portalRequestContext=new PortalRequestContext(getServletContext(),request,response);
  PortalURL portalURL=portalRequestContext.getRequestedPortalURL();
  String actionWindowId=portalURL.getActionWindow();
  String resourceWindowId=portalURL.getResourceWindow();
  PortletWindowConfig actionWindowConfig=null;
  PortletWindowConfig resourceWindowConfig=null;
  if (resourceWindowId != null) {
    resourceWindowConfig=PortletWindowConfig.fromId(resourceWindowId);
  }
 else   if (actionWindowId != null) {
    actionWindowConfig=PortletWindowConfig.fromId(actionWindowId);
  }
  if (actionWindowConfig != null) {
    PortletWindowImpl portletWindow=new PortletWindowImpl(actionWindowConfig,portalURL);
    if (LOG.isDebugEnabled()) {
      LOG.debug(""String_Node_Str"" + portletWindow.getId().getStringId());
    }
    try {
      container.doAction(portletWindow,request,response);
    }
 catch (    PortletContainerException ex) {
      throw new ServletException(ex);
    }
catch (    PortletException ex) {
      throw new ServletException(ex);
    }
    if (LOG.isDebugEnabled()) {
      LOG.debug(""String_Node_Str"");
    }
  }
 else   if (resourceWindowConfig != null) {
    try {
      if (request.getParameterNames().hasMoreElements())       setPublicRenderParameter(request,portalURL,portalURL.getResourceWindow());
    }
 catch (    PortletContainerException e) {
      LOG.warn(e);
    }
    PortletWindowImpl portletWindow=new PortletWindowImpl(resourceWindowConfig,portalURL);
    if (LOG.isDebugEnabled()) {
      LOG.debug(""String_Node_Str"" + portletWindow.getId().getStringId());
    }
    try {
      container.doServeResource(portletWindow,request,response);
    }
 catch (    PortletContainerException ex) {
      throw new ServletException(ex);
    }
catch (    PortletException ex) {
      throw new ServletException(ex);
    }
    if (LOG.isDebugEnabled()) {
      LOG.debug(""String_Node_Str"");
    }
  }
 else {
    if (LOG.isDebugEnabled()) {
      LOG.debug(""String_Node_Str"");
    }
    PageConfig pageConfig=portalURL.getPageConfig(servletContext);
    if (pageConfig == null) {
      LOG.error(""String_Node_Str"" + portalURL.getRenderPath() + ""String_Node_Str"");
    }
    request.setAttribute(AttributeKeys.CURRENT_PAGE,pageConfig);
    String uri=(pageConfig.getUri() != null) ? pageConfig.getUri() : DEFAULT_PAGE_URI;
    if (LOG.isDebugEnabled()) {
      LOG.debug(""String_Node_Str"" + uri);
    }
    RequestDispatcher dispatcher=request.getRequestDispatcher(uri);
    dispatcher.forward(request,response);
    if (LOG.isDebugEnabled()) {
      LOG.debug(""String_Node_Str"");
    }
  }
}",0.9635105379050016
90650,"/** 
 * Clear parameters of the specified window.
 * @param windowId  the window ID.
 */
public void clearParameters(String windowId){
  for (Iterator it=parameters.entrySet().iterator(); it.hasNext(); ) {
    Map.Entry entry=(Map.Entry)it.next();
    PortalURLParameter param=(PortalURLParameter)entry.getValue();
    if (param.getWindowId().equals(windowId)) {
      it.remove();
    }
  }
}","/** 
 * Clear parameters of the specified window.
 * @param windowId  the window ID.
 */
public void clearParameters(String windowId){
  for (Iterator it=parameters.entrySet().iterator(); it.hasNext(); ) {
    Map.Entry entry=(Map.Entry)it.next();
    PortalURLParameter param=(PortalURLParameter)entry.getValue();
    if (param.getWindowId() != null) {
      if (param.getWindowId().equals(windowId)) {
        it.remove();
      }
    }
  }
}",0.9390681003584228
90651,"/** 
 * Handle all requests. All POST requests are passed to this method.
 * @param request  the incoming HttpServletRequest.
 * @param response  the incoming HttpServletResponse.
 * @throws ServletException  if an internal error occurs.
 * @throws IOException  if an error occurs writing to the response.
 */
public void doGet(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException {
  PortalRequestContext portalRequestContext=new PortalRequestContext(getServletContext(),request,response);
  PortalURL portalURL=portalRequestContext.getRequestedPortalURL();
  String actionWindowId=portalURL.getActionWindow();
  String resourceWindowId=portalURL.getResourceWindow();
  PortletWindowConfig actionWindowConfig=null;
  PortletWindowConfig resourceWindowConfig=null;
  if (resourceWindowId != null) {
    resourceWindowConfig=PortletWindowConfig.fromId(resourceWindowId);
  }
 else   if (actionWindowId != null) {
    actionWindowConfig=PortletWindowConfig.fromId(actionWindowId);
  }
  if (actionWindowConfig != null) {
    PortletWindowImpl portletWindow=new PortletWindowImpl(actionWindowConfig,portalURL);
    if (LOG.isDebugEnabled()) {
      LOG.debug(""String_Node_Str"" + portletWindow.getId().getStringId());
    }
    try {
      container.doAction(portletWindow,request,response);
    }
 catch (    PortletContainerException ex) {
      throw new ServletException(ex);
    }
catch (    PortletException ex) {
      throw new ServletException(ex);
    }
    if (LOG.isDebugEnabled()) {
      LOG.debug(""String_Node_Str"");
    }
  }
 else   if (resourceWindowConfig != null) {
    PortletWindowImpl portletWindow=new PortletWindowImpl(resourceWindowConfig,portalURL);
    if (LOG.isDebugEnabled()) {
      LOG.debug(""String_Node_Str"" + portletWindow.getId().getStringId());
    }
    try {
      container.doServeResource(portletWindow,request,response);
    }
 catch (    PortletContainerException ex) {
      throw new ServletException(ex);
    }
catch (    PortletException ex) {
      throw new ServletException(ex);
    }
    if (LOG.isDebugEnabled()) {
      LOG.debug(""String_Node_Str"");
    }
  }
 else {
    if (LOG.isDebugEnabled()) {
      LOG.debug(""String_Node_Str"");
    }
    PageConfig pageConfig=portalURL.getPageConfig(servletContext);
    if (pageConfig == null) {
      LOG.error(""String_Node_Str"" + portalURL.getRenderPath() + ""String_Node_Str"");
    }
    request.setAttribute(AttributeKeys.CURRENT_PAGE,pageConfig);
    String uri=(pageConfig.getUri() != null) ? pageConfig.getUri() : DEFAULT_PAGE_URI;
    if (LOG.isDebugEnabled()) {
      LOG.debug(""String_Node_Str"" + uri);
    }
    RequestDispatcher dispatcher=request.getRequestDispatcher(uri);
    dispatcher.forward(request,response);
    if (LOG.isDebugEnabled()) {
      LOG.debug(""String_Node_Str"");
    }
  }
}","/** 
 * Handle all requests. All POST requests are passed to this method.
 * @param request  the incoming HttpServletRequest.
 * @param response  the incoming HttpServletResponse.
 * @throws ServletException  if an internal error occurs.
 * @throws IOException  if an error occurs writing to the response.
 */
public void doGet(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException {
  PortalRequestContext portalRequestContext=new PortalRequestContext(getServletContext(),request,response);
  PortalURL portalURL=portalRequestContext.getRequestedPortalURL();
  String actionWindowId=portalURL.getActionWindow();
  String resourceWindowId=portalURL.getResourceWindow();
  PortletWindowConfig actionWindowConfig=null;
  PortletWindowConfig resourceWindowConfig=null;
  if (resourceWindowId != null) {
    resourceWindowConfig=PortletWindowConfig.fromId(resourceWindowId);
  }
 else   if (actionWindowId != null) {
    actionWindowConfig=PortletWindowConfig.fromId(actionWindowId);
  }
  if (actionWindowConfig != null) {
    try {
      if (request.getParameterNames().hasMoreElements()) {
        setPublicRenderParameter(request,portalURL,portalURL.getActionWindow());
      }
    }
 catch (    PortletContainerException e) {
      e.printStackTrace();
    }
    PortletWindowImpl portletWindow=new PortletWindowImpl(actionWindowConfig,portalURL);
    if (LOG.isDebugEnabled()) {
      LOG.debug(""String_Node_Str"" + portletWindow.getId().getStringId());
    }
    try {
      container.doAction(portletWindow,request,response);
    }
 catch (    PortletContainerException ex) {
      throw new ServletException(ex);
    }
catch (    PortletException ex) {
      throw new ServletException(ex);
    }
    if (LOG.isDebugEnabled()) {
      LOG.debug(""String_Node_Str"");
    }
  }
 else   if (resourceWindowConfig != null) {
    try {
      if (request.getParameterNames().hasMoreElements())       setPublicRenderParameter(request,portalURL,portalURL.getResourceWindow());
    }
 catch (    PortletContainerException e) {
      e.printStackTrace();
    }
    PortletWindowImpl portletWindow=new PortletWindowImpl(resourceWindowConfig,portalURL);
    if (LOG.isDebugEnabled()) {
      LOG.debug(""String_Node_Str"" + portletWindow.getId().getStringId());
    }
    try {
      container.doServeResource(portletWindow,request,response);
    }
 catch (    PortletContainerException ex) {
      throw new ServletException(ex);
    }
catch (    PortletException ex) {
      throw new ServletException(ex);
    }
    if (LOG.isDebugEnabled()) {
      LOG.debug(""String_Node_Str"");
    }
  }
 else {
    if (LOG.isDebugEnabled()) {
      LOG.debug(""String_Node_Str"");
    }
    PageConfig pageConfig=portalURL.getPageConfig(servletContext);
    if (pageConfig == null) {
      LOG.error(""String_Node_Str"" + portalURL.getRenderPath() + ""String_Node_Str"");
    }
    request.setAttribute(AttributeKeys.CURRENT_PAGE,pageConfig);
    String uri=(pageConfig.getUri() != null) ? pageConfig.getUri() : DEFAULT_PAGE_URI;
    if (LOG.isDebugEnabled()) {
      LOG.debug(""String_Node_Str"" + uri);
    }
    RequestDispatcher dispatcher=request.getRequestDispatcher(uri);
    dispatcher.forward(request,response);
    if (LOG.isDebugEnabled()) {
      LOG.debug(""String_Node_Str"");
    }
  }
}",0.9014954486345904
90652,"/** 
 * @param name The name to set.
 */
public void setName(QName qname){
  this.qname=qname;
}","/** 
 * @param name The qName to set.
 */
public void setName(String name){
  this.name=name;
}",0.9109947643979056
90653,"/** 
 * @return Returns the name.
 */
public QName getName(){
  return (qname == null) ? new QName(name) : qname;
}","/** 
 * @return Returns the name.
 */
public String getName(){
  return name;
}",0.7525773195876289
90654,"private boolean isValueInstanceOfDefinedClass(QName qname,Serializable value){
  PortletAppDD portletAppDD=null;
  try {
    portletAppDD=container.getPortletApplicationDescriptor(portletWindow.getContextPath());
    if (portletAppDD.getEvents() != null) {
      for (      EventDefinitionDD event : portletAppDD.getEvents()) {
        if (event.getName().toString().equals(qname.toString())) {
          return value.getClass().getName().equals(event.getJavaClass());
        }
      }
    }
  }
 catch (  PortletContainerException e) {
    LOG.error(qname,e);
  }
  return true;
}","private boolean isValueInstanceOfDefinedClass(QName qname,Serializable value){
  PortletAppDD portletAppDD=null;
  try {
    portletAppDD=container.getPortletApplicationDescriptor(portletWindow.getContextPath());
    if (portletAppDD.getEvents() != null) {
      for (      EventDefinitionDD def : portletAppDD.getEvents()) {
        if (def.getQName() != null) {
          if (def.getQName().equals(qname))           return value.getClass().getName().equals(def.getJavaClass());
        }
 else {
          QName tmp=new QName(portletAppDD.getDefaultNamespace(),def.getName());
          if (tmp.equals(qname))           return value.getClass().getName().equals(def.getJavaClass());
        }
      }
    }
  }
 catch (  PortletContainerException e) {
    LOG.error(qname,e);
  }
  return true;
}",0.7759245830311821
90655,"private List<QName> getAllAliases(QName eventName,PortletAppDD portletAppDD){
  if (portletAppDD.getEvents() != null) {
    for (    EventDefinitionDD eventDefinition : portletAppDD.getEvents()) {
      if (eventName.toString().equals(eventDefinition.getName().toString())) {
        return eventDefinition.getAlias();
      }
    }
  }
  return null;
}","private List<QName> getAllAliases(QName eventName,PortletAppDD portletAppDD){
  if (portletAppDD.getEvents() != null) {
    for (    EventDefinitionDD def : portletAppDD.getEvents()) {
      if (def.getQName() != null) {
        if (def.getQName().equals(eventName))         return def.getAlias();
      }
 else {
        QName tmp=new QName(portletAppDD.getDefaultNamespace(),def.getName());
        if (tmp.equals(eventName))         return def.getAlias();
      }
    }
  }
  return null;
}",0.6028368794326241
90656,"private EventDefinitionDD getEventDefintion(QName name) throws PortletContainerException {
  PortalRequestContext context=PortalRequestContext.getContext(eventProvider.getRequest());
  ServletContext servletContext=context.getServletContext();
  PortletContainer container=(PortletContainer)servletContext.getAttribute(AttributeKeys.PORTLET_CONTAINER);
  PortletAppDD appDD=container.getPortletApplicationDescriptor(portletWindow.getContextPath());
  for (  EventDefinitionDD def : appDD.getEvents()) {
    if (def.getName().equals(name)) {
      return def;
    }
  }
  throw new IllegalStateException();
}","private EventDefinitionDD getEventDefintion(QName name) throws PortletContainerException {
  PortalRequestContext context=PortalRequestContext.getContext(eventProvider.getRequest());
  ServletContext servletContext=context.getServletContext();
  PortletContainer container=(PortletContainer)servletContext.getAttribute(AttributeKeys.PORTLET_CONTAINER);
  PortletAppDD appDD=container.getPortletApplicationDescriptor(portletWindow.getContextPath());
  for (  EventDefinitionDD def : appDD.getEvents()) {
    if (def.getQName() != null) {
      if (def.getQName().equals(name))       return def;
    }
 else {
      QName tmp=new QName(appDD.getDefaultNamespace(),def.getName());
      if (tmp.equals(name))       return def;
    }
  }
  throw new IllegalStateException();
}",0.8701957940536621
90657,"public Map<String,String[]> getPublicParameterMap(){
  throw new UnsupportedOperationException(""String_Node_Str"");
}","public Map<String,String[]> getPublicParameterMap(){
  Map<String,String[]> map=new HashMap<String,String[]>();
  PortletURLProvider urlProvider=container.getRequiredContainerServices().getPortalCallbackService().getPortletURLProvider(getHttpServletRequest(),internalPortletWindow);
  List<String> publicRenderParameterNames=internalPortletWindow.getPortletEntity().getPortletDefinition().getPublicRenderParameter();
  String[] values=null;
  for (  String string : publicRenderParameterNames) {
    values=urlProvider.getPublicRenderParameters(string);
    if (values != null) {
      map.put(string,values);
    }
  }
  return Collections.unmodifiableMap(map);
}",0.1666666666666666
90658,"/** 
 * Converts a portal URL to a URL string.
 * @param portalURL  the portal URL to convert.
 * @return a URL string representing the portal URL.
 */
public String toString(PortalURL portalURL){
  StringBuffer buffer=new StringBuffer();
  buffer.append(portalURL.getServletPath().startsWith(""String_Node_Str"") ? ""String_Node_Str"" : ""String_Node_Str"").append(portalURL.getServletPath());
  if (portalURL.getRenderPath() != null) {
    buffer.append(""String_Node_Str"").append(portalURL.getRenderPath());
  }
  if (portalURL.getResourceWindow() != null) {
    buffer.append(""String_Node_Str"");
    buffer.append(PREFIX).append(RESOURCE).append(encodeCharacters(portalURL.getResourceWindow()));
  }
  if (portalURL.getActionWindow() != null) {
    buffer.append(""String_Node_Str"");
    buffer.append(PREFIX).append(ACTION).append(encodeCharacters(portalURL.getActionWindow()));
  }
  for (Iterator it=portalURL.getPortletModes().entrySet().iterator(); it.hasNext(); ) {
    Map.Entry entry=(Map.Entry)it.next();
    buffer.append(""String_Node_Str"").append(encodeControlParameter(PORTLET_MODE,entry.getKey().toString(),entry.getValue().toString()));
  }
  for (Iterator it=portalURL.getWindowStates().entrySet().iterator(); it.hasNext(); ) {
    Map.Entry entry=(Map.Entry)it.next();
    buffer.append(""String_Node_Str"").append(encodeControlParameter(WINDOW_STATE,entry.getKey().toString(),entry.getValue().toString()));
  }
  StringBuffer query=new StringBuffer(""String_Node_Str"");
  boolean firstParam=true;
  for (Iterator it=portalURL.getParameters().iterator(); it.hasNext(); ) {
    PortalURLParameter param=(PortalURLParameter)it.next();
    if (portalURL.getActionWindow() != null && portalURL.getActionWindow().equals(param.getWindowId()) || (portalURL.getResourceWindow() != null && portalURL.getResourceWindow().equals(param.getWindowId()))) {
      for (int i=0; i < param.getValues().length; i++) {
        if (firstParam) {
          firstParam=false;
        }
 else {
          query.append(""String_Node_Str"");
        }
        query.append(encodeQueryParam(param.getName())).append(""String_Node_Str"").append(encodeQueryParam(param.getValues()[i]));
      }
    }
 else     if (param.getValues() != null && param.getValues().length > 0) {
      String valueString=encodeMultiValues(param.getValues());
      if (valueString.length() > 0) {
        buffer.append(""String_Node_Str"").append(encodeControlParameter(RENDER_PARAM,param.getWindowId(),param.getName()));
        buffer.append(""String_Node_Str"").append(valueString);
      }
    }
  }
  if (query.length() > 1) {
    return buffer.append(query).toString();
  }
  Map<String,String[]> publicParamList=portalURL.getPublicParameters();
  if (publicParamList != null) {
    for (Iterator iter=publicParamList.keySet().iterator(); iter.hasNext(); ) {
      String paramname=(String)iter.next();
      String[] tmp=(String[])publicParamList.get(paramname);
      String valueString=encodeMultiValues(tmp);
      if (valueString.length() > 0) {
        buffer.append(""String_Node_Str"").append(encodePublicParamname(PUBLIC_RENDER_PARAM,paramname));
        buffer.append(""String_Node_Str"").append(valueString);
      }
    }
  }
  return buffer.append(query).toString();
}","/** 
 * Converts a portal URL to a URL string.
 * @param portalURL  the portal URL to convert.
 * @return a URL string representing the portal URL.
 */
public String toString(PortalURL portalURL){
  StringBuffer buffer=new StringBuffer();
  buffer.append(portalURL.getServletPath().startsWith(""String_Node_Str"") ? ""String_Node_Str"" : ""String_Node_Str"").append(portalURL.getServletPath());
  if (portalURL.getRenderPath() != null) {
    buffer.append(""String_Node_Str"").append(portalURL.getRenderPath());
  }
  if (portalURL.getResourceWindow() != null) {
    buffer.append(""String_Node_Str"");
    buffer.append(PREFIX).append(RESOURCE).append(encodeCharacters(portalURL.getResourceWindow()));
  }
  if (portalURL.getActionWindow() != null) {
    buffer.append(""String_Node_Str"");
    buffer.append(PREFIX).append(ACTION).append(encodeCharacters(portalURL.getActionWindow()));
  }
  for (Iterator it=portalURL.getPortletModes().entrySet().iterator(); it.hasNext(); ) {
    Map.Entry entry=(Map.Entry)it.next();
    buffer.append(""String_Node_Str"").append(encodeControlParameter(PORTLET_MODE,entry.getKey().toString(),entry.getValue().toString()));
  }
  for (Iterator it=portalURL.getWindowStates().entrySet().iterator(); it.hasNext(); ) {
    Map.Entry entry=(Map.Entry)it.next();
    buffer.append(""String_Node_Str"").append(encodeControlParameter(WINDOW_STATE,entry.getKey().toString(),entry.getValue().toString()));
  }
  StringBuffer query=new StringBuffer(""String_Node_Str"");
  boolean firstParam=true;
  for (Iterator it=portalURL.getParameters().iterator(); it.hasNext(); ) {
    PortalURLParameter param=(PortalURLParameter)it.next();
    if (portalURL.getActionWindow() != null && portalURL.getActionWindow().equals(param.getWindowId()) || (portalURL.getResourceWindow() != null && portalURL.getResourceWindow().equals(param.getWindowId()))) {
      for (int i=0; i < param.getValues().length; i++) {
        if (firstParam) {
          firstParam=false;
        }
 else {
          query.append(""String_Node_Str"");
        }
        query.append(encodeQueryParam(param.getName())).append(""String_Node_Str"").append(encodeQueryParam(param.getValues()[i]));
      }
    }
 else     if (param.getValues() != null && param.getValues().length > 0) {
      String valueString=encodeMultiValues(param.getValues());
      if (valueString.length() > 0) {
        buffer.append(""String_Node_Str"").append(encodeControlParameter(RENDER_PARAM,param.getWindowId(),param.getName()));
        buffer.append(""String_Node_Str"").append(valueString);
      }
    }
  }
  StringUtils.encode(buffer);
  if (query.length() > 1) {
    return buffer.append(query).toString();
  }
  Map<String,String[]> publicParamList=portalURL.getPublicParameters();
  if (publicParamList != null) {
    for (Iterator iter=publicParamList.keySet().iterator(); iter.hasNext(); ) {
      String paramname=(String)iter.next();
      String[] tmp=(String[])publicParamList.get(paramname);
      String valueString=encodeMultiValues(tmp);
      if (valueString.length() > 0) {
        buffer.append(""String_Node_Str"").append(encodePublicParamname(PUBLIC_RENDER_PARAM,paramname));
        buffer.append(""String_Node_Str"").append(valueString);
      }
    }
  }
  return buffer.append(query).toString();
}",0.9953860350661335
90659,"/** 
 * Initialize parameters for this request.  We must be careful to make sure that render parameters are only made available if they were targeted for this specific window.
 */
private void initParameterMap(){
  portletParameters=new HashMap();
  Iterator iterator=url.getParameters().iterator();
  while (iterator.hasNext()) {
    PortalURLParameter param=(PortalURLParameter)iterator.next();
    String name=param.getName();
    String[] values=param.getValues();
    if (param.getWindowId().equals(portletWindow.getId().getStringId())) {
      portletParameters.put(name,values);
    }
  }
  String id=url.getActionWindow();
  if (portletWindow.getId().getStringId().equals(id)) {
    Enumeration params=super.getParameterNames();
    while (params.hasMoreElements()) {
      String name=params.nextElement().toString();
      String[] values=super.getParameterValues(name);
      if (portletParameters.containsKey(name)) {
        String[] temp=(String[])portletParameters.get(name);
        String[] all=new String[values.length + temp.length];
        System.arraycopy(values,0,all,0,values.length);
        System.arraycopy(temp,0,all,values.length,temp.length);
      }
      portletParameters.put(name,values);
    }
  }
  if (LOG.isDebugEnabled()) {
    LOG.debug(""String_Node_Str"" + portletWindow.getId().getStringId() + ""String_Node_Str"");
  }
}","/** 
 * Initialize parameters for this request.  We must be careful to make sure that render parameters are only made available if they were targeted for this specific window.
 */
private void initParameterMap(){
  portletParameters=new HashMap();
  Iterator iterator=url.getParameters().iterator();
  while (iterator.hasNext()) {
    PortalURLParameter param=(PortalURLParameter)iterator.next();
    String name=param.getName();
    String[] values=param.getValues();
    if (param.getWindowId() != null) {
      if (param.getWindowId().equals(portletWindow.getId().getStringId())) {
        portletParameters.put(name,values);
      }
    }
  }
  String id=url.getActionWindow();
  if (portletWindow.getId().getStringId().equals(id)) {
    Enumeration params=super.getParameterNames();
    while (params.hasMoreElements()) {
      String name=params.nextElement().toString();
      String[] values=super.getParameterValues(name);
      if (portletParameters.containsKey(name)) {
        String[] temp=(String[])portletParameters.get(name);
        String[] all=new String[values.length + temp.length];
        System.arraycopy(values,0,all,0,values.length);
        System.arraycopy(temp,0,all,values.length,temp.length);
      }
      portletParameters.put(name,values);
    }
  }
  if (LOG.isDebugEnabled()) {
    LOG.debug(""String_Node_Str"" + portletWindow.getId().getStringId() + ""String_Node_Str"");
  }
}",0.98159509202454
90660,"/** 
 * Handle all requests. All POST requests are passed to this method.
 * @param request  the incoming HttpServletRequest.
 * @param response  the incoming HttpServletResponse.
 * @throws ServletException  if an internal error occurs.
 * @throws IOException  if an error occurs writing to the response.
 */
public void doGet(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException {
  PortalRequestContext portalRequestContext=new PortalRequestContext(getServletContext(),request,response);
  PortalURL portalURL=portalRequestContext.getRequestedPortalURL();
  String actionWindowId=portalURL.getActionWindow();
  String resourceWindowId=portalURL.getResourceWindow();
  PortletWindowConfig actionWindowConfig=actionWindowId == null ? null : PortletWindowConfig.fromId(actionWindowId);
  PortletWindowConfig resourceWindowConfig=null;
  request.setAttribute(""String_Node_Str"",container.getRequiredContainerServices().getPortalCallbackService().getFilterManager());
  if (actionWindowConfig != null) {
    PortletWindowImpl portletWindow=new PortletWindowImpl(actionWindowConfig,portalURL);
    if (LOG.isDebugEnabled()) {
      LOG.debug(""String_Node_Str"" + portletWindow.getId().getStringId());
    }
    try {
      container.doAction(portletWindow,request,response);
    }
 catch (    PortletContainerException ex) {
      throw new ServletException(ex);
    }
catch (    PortletException ex) {
      throw new ServletException(ex);
    }
    if (LOG.isDebugEnabled()) {
      LOG.debug(""String_Node_Str"");
    }
  }
 else   if (resourceWindowConfig != null) {
    PortletWindowImpl portletWindow=new PortletWindowImpl(resourceWindowConfig,portalURL);
    if (LOG.isDebugEnabled()) {
      LOG.debug(""String_Node_Str"" + portletWindow.getId().getStringId());
    }
    try {
      container.doServeResource(portletWindow,request,response);
    }
 catch (    PortletContainerException ex) {
      throw new ServletException(ex);
    }
catch (    PortletException ex) {
      throw new ServletException(ex);
    }
    if (LOG.isDebugEnabled()) {
      LOG.debug(""String_Node_Str"");
    }
  }
 else {
    if (LOG.isDebugEnabled()) {
      LOG.debug(""String_Node_Str"");
    }
    PageConfig pageConfig=portalURL.getPageConfig(servletContext);
    if (pageConfig == null) {
      LOG.error(""String_Node_Str"" + portalURL.getRenderPath() + ""String_Node_Str"");
    }
    request.setAttribute(AttributeKeys.CURRENT_PAGE,pageConfig);
    String uri=(pageConfig.getUri() != null) ? pageConfig.getUri() : DEFAULT_PAGE_URI;
    if (LOG.isDebugEnabled()) {
      LOG.debug(""String_Node_Str"" + uri);
    }
    RequestDispatcher dispatcher=request.getRequestDispatcher(uri);
    dispatcher.forward(request,response);
    if (LOG.isDebugEnabled()) {
      LOG.debug(""String_Node_Str"");
    }
  }
}","/** 
 * Handle all requests. All POST requests are passed to this method.
 * @param request  the incoming HttpServletRequest.
 * @param response  the incoming HttpServletResponse.
 * @throws ServletException  if an internal error occurs.
 * @throws IOException  if an error occurs writing to the response.
 */
public void doGet(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException {
  PortalRequestContext portalRequestContext=new PortalRequestContext(getServletContext(),request,response);
  PortalURL portalURL=portalRequestContext.getRequestedPortalURL();
  String actionWindowId=portalURL.getActionWindow();
  String resourceWindowId=portalURL.getResourceWindow();
  PortletWindowConfig actionWindowConfig=null;
  PortletWindowConfig resourceWindowConfig=null;
  request.setAttribute(""String_Node_Str"",container.getRequiredContainerServices().getPortalCallbackService().getFilterManager());
  if (resourceWindowId != null) {
    resourceWindowConfig=PortletWindowConfig.fromId(resourceWindowId);
  }
 else   if (actionWindowId != null) {
    actionWindowConfig=PortletWindowConfig.fromId(actionWindowId);
  }
  if (actionWindowConfig != null) {
    PortletWindowImpl portletWindow=new PortletWindowImpl(actionWindowConfig,portalURL);
    if (LOG.isDebugEnabled()) {
      LOG.debug(""String_Node_Str"" + portletWindow.getId().getStringId());
    }
    try {
      container.doAction(portletWindow,request,response);
    }
 catch (    PortletContainerException ex) {
      throw new ServletException(ex);
    }
catch (    PortletException ex) {
      throw new ServletException(ex);
    }
    if (LOG.isDebugEnabled()) {
      LOG.debug(""String_Node_Str"");
    }
  }
 else   if (resourceWindowConfig != null) {
    PortletWindowImpl portletWindow=new PortletWindowImpl(resourceWindowConfig,portalURL);
    if (LOG.isDebugEnabled()) {
      LOG.debug(""String_Node_Str"" + portletWindow.getId().getStringId());
    }
    try {
      container.doServeResource(portletWindow,request,response);
    }
 catch (    PortletContainerException ex) {
      throw new ServletException(ex);
    }
catch (    PortletException ex) {
      throw new ServletException(ex);
    }
    if (LOG.isDebugEnabled()) {
      LOG.debug(""String_Node_Str"");
    }
  }
 else {
    if (LOG.isDebugEnabled()) {
      LOG.debug(""String_Node_Str"");
    }
    PageConfig pageConfig=portalURL.getPageConfig(servletContext);
    if (pageConfig == null) {
      LOG.error(""String_Node_Str"" + portalURL.getRenderPath() + ""String_Node_Str"");
    }
    request.setAttribute(AttributeKeys.CURRENT_PAGE,pageConfig);
    String uri=(pageConfig.getUri() != null) ? pageConfig.getUri() : DEFAULT_PAGE_URI;
    if (LOG.isDebugEnabled()) {
      LOG.debug(""String_Node_Str"" + uri);
    }
    RequestDispatcher dispatcher=request.getRequestDispatcher(uri);
    dispatcher.forward(request,response);
    if (LOG.isDebugEnabled()) {
      LOG.debug(""String_Node_Str"");
    }
  }
}",0.91439420089748
90661,"/** 
 * Fire Event for the portlet associated with the given portlet window and eventName
 * @param portletWindow  the portlet window.
 * @param request  the servlet request.
 * @param response  the servlet response.
 * @param eventName the event name
 * @throws PortletException
 * @throws IOException
 * @throws PortletContainerException
 * @see {@link javax.portlet.EventPortlet#processEvent(javax.portlet.EventRequest,javax.portlet.EventResponse)}
 */
public void fireEvent(HttpServletRequest request,HttpServletResponse response,PortletWindow window,Event event) throws PortletException, IOException {
  ensureInitialized();
  InternalPortletWindow internalPortletWindow=new PortletWindowImpl(servletContext,window);
  debugWithName(""String_Node_Str"" + window.getPortletName());
  EventRequestImpl eventRequest=new EventRequestImpl(this,internalPortletWindow,request,event);
  EventResponseImpl eventResponse=new EventResponseImpl(this,internalPortletWindow,request,response);
  PortletInvoker invoker=new PortletInvoker(internalPortletWindow);
  invoker.event(eventRequest,eventResponse);
  debugWithName(""String_Node_Str"" + window.getPortletName());
  String location=eventResponse.getRedirectLocation();
  if (location == null) {
    debugWithName(""String_Node_Str"");
    PortletURLProvider redirectURL=requiredContainerServices.getPortalCallbackService().getPortletURLProvider(request,internalPortletWindow);
    saveChangedParameters(eventRequest,eventResponse,redirectURL);
    redirectURL.savePortalURL(request);
  }
}","/** 
 * Fire Event for the portlet associated with the given portlet window and eventName
 * @param portletWindow  the portlet window.
 * @param request  the servlet request.
 * @param response  the servlet response.
 * @param eventName the event name
 * @throws PortletException
 * @throws IOException
 * @throws PortletContainerException
 * @see {@link javax.portlet.EventPortlet#processEvent(javax.portlet.EventRequest,javax.portlet.EventResponse)}
 */
public void fireEvent(HttpServletRequest request,HttpServletResponse response,PortletWindow window,Event event) throws PortletException, IOException {
  ensureInitialized();
  InternalPortletWindow internalPortletWindow=new InternalPortletWindowImpl(PortletContextManager.getPortletContext(servletContext,window.getContextPath()),window);
  debugWithName(""String_Node_Str"" + window.getPortletName());
  EventRequestImpl eventRequest=new EventRequestImpl(this,internalPortletWindow,request,event);
  EventResponseImpl eventResponse=new EventResponseImpl(this,internalPortletWindow,request,response);
  PortletInvokerService invoker=optionalContainerServices.getPortletInvokerService();
  try {
    ContainerInvocation.setInvocation(this,internalPortletWindow);
    invoker.event(request,response,internalPortletWindow);
  }
  finally {
    ContainerInvocation.clearInvocation();
  }
  debugWithName(""String_Node_Str"" + window.getPortletName());
  String location=eventResponse.getRedirectLocation();
  if (location == null) {
    debugWithName(""String_Node_Str"");
    PortletURLProvider redirectURL=requiredContainerServices.getPortalCallbackService().getPortletURLProvider(request,internalPortletWindow);
    saveChangedParameters(eventRequest,eventResponse,redirectURL);
    redirectURL.savePortalURL(request);
  }
}",0.9094762337269148
90662,"/** 
 * Indicates that a portlet resource Serving occured in the current request and calls the processServeResource method of this portlet.
 * @param internalPortletWindow the portlet Window
 * @param request               the servlet request
 * @param response              the servlet response
 * @throws PortletException          if one portlet has trouble fulfillingthe request
 * @throws PortletContainerException if the portlet container implementationhas trouble fulfilling the request
 */
public void doServeResource(PortletWindow portletWindow,HttpServletRequest request,HttpServletResponse response) throws PortletException, IOException, PortletContainerException {
  ensureInitialized();
  InternalPortletWindow internalPortletWindow=new InternalPortletWindowImpl(PortletContextManager.getPortletContext(servletContext,portletWindow.getContextPath()),portletWindow);
  debugWithName(""String_Node_Str"" + portletWindow.getPortletName());
  InternalResourceRequest resourceRequest=getOptionalContainerServices().getPortletEnvironmentService().createResourceRequest(this,request,response,internalPortletWindow);
  InternalResourceResponse resourceResponse=getOptionalContainerServices().getPortletEnvironmentService().createResourceResponse(this,request,response,internalPortletWindow);
  PortletInvokerService invoker=optionalContainerServices.getPortletInvokerService();
  try {
    ContainerInvocation.setInvocation(this,internalPortletWindow);
    invoker.render(resourceRequest,resourceResponse,internalPortletWindow);
  }
  finally {
    ContainerInvocation.clearInvocation();
  }
  debugWithName(""String_Node_Str"" + portletWindow.getPortletName());
}","/** 
 * Indicates that a portlet resource Serving occured in the current request and calls the processServeResource method of this portlet.
 * @param internalPortletWindow the portlet Window
 * @param request               the servlet request
 * @param response              the servlet response
 * @throws PortletException          if one portlet has trouble fulfillingthe request
 * @throws PortletContainerException if the portlet container implementationhas trouble fulfilling the request
 */
public void doServeResource(PortletWindow portletWindow,HttpServletRequest request,HttpServletResponse response) throws PortletException, IOException, PortletContainerException {
  ensureInitialized();
  InternalPortletWindow internalPortletWindow=new InternalPortletWindowImpl(PortletContextManager.getPortletContext(servletContext,portletWindow.getContextPath()),portletWindow);
  debugWithName(""String_Node_Str"" + portletWindow.getPortletName());
  InternalResourceRequest resourceRequest=getOptionalContainerServices().getPortletEnvironmentService().createResourceRequest(this,request,response,internalPortletWindow);
  InternalResourceResponse resourceResponse=getOptionalContainerServices().getPortletEnvironmentService().createResourceResponse(this,request,response,internalPortletWindow);
  PortletInvokerService invoker=optionalContainerServices.getPortletInvokerService();
  try {
    ContainerInvocation.setInvocation(this,internalPortletWindow);
    invoker.serveResource(resourceRequest,resourceResponse,internalPortletWindow);
  }
  finally {
    ContainerInvocation.clearInvocation();
  }
  debugWithName(""String_Node_Str"" + portletWindow.getPortletName());
}",0.9943028485757122
90663,"/** 
 * Process action for the portlet associated with the given portlet window.
 * @param portletWindow  the portlet window.
 * @param request  the servlet request.
 * @param response  the servlet response.
 * @throws PortletException
 * @throws IOException
 * @throws PortletContainerException
 * @see javax.portlet.Portlet#processAction(ActionRequest,ActionResponse)
 */
public void doAction(PortletWindow portletWindow,HttpServletRequest request,HttpServletResponse response) throws PortletException, IOException, PortletContainerException {
  ensureInitialized();
  InternalPortletWindow internalPortletWindow=new InternalPortletWindowImpl(PortletContextManager.getPortletContext(servletContext,portletWindow.getContextPath()),portletWindow);
  debugWithName(""String_Node_Str"" + portletWindow.getPortletName());
  InternalActionRequest actionRequest=getOptionalContainerServices().getPortletEnvironmentService().createActionRequest(this,request,response,internalPortletWindow);
  InternalActionResponse actionResponse=getOptionalContainerServices().getPortletEnvironmentService().createActionResponse(this,request,response,internalPortletWindow);
  PortletInvokerService invoker=optionalContainerServices.getPortletInvokerService();
  try {
    ContainerInvocation.setInvocation(this,internalPortletWindow);
    invoker.action(actionRequest,actionResponse,internalPortletWindow);
  }
  finally {
    ContainerInvocation.clearInvocation();
  }
  debugWithName(""String_Node_Str"" + portletWindow.getPortletName());
  PortletURLProvider portletURLProvider=requiredContainerServices.getPortalCallbackService().getPortletURLProvider(request,internalPortletWindow);
  portletURLProvider.savePortalURL(request);
  saveChangedParameters(actionRequest,actionResponse,portletURLProvider);
  EventProvider provider=this.getRequiredContainerServices().getPortalCallbackService().getEventProvider(request,portletWindow);
  provider.fireEvents(this);
  String location=actionResponse.getRedirectLocation();
  if (location == null) {
    debugWithName(""String_Node_Str"");
    PortletURLProvider redirectURL=requiredContainerServices.getPortalCallbackService().getPortletURLProvider(request,internalPortletWindow);
    saveChangedParameters(actionRequest,actionResponse,redirectURL);
    location=actionResponse.encodeRedirectURL(redirectURL.toString());
  }
  response.sendRedirect(location);
  debugWithName(""String_Node_Str"");
}","/** 
 * Process action for the portlet associated with the given portlet window.
 * @param portletWindow  the portlet window.
 * @param request  the servlet request.
 * @param response  the servlet response.
 * @throws PortletException
 * @throws IOException
 * @throws PortletContainerException
 * @see javax.portlet.Portlet#processAction(ActionRequest,ActionResponse)
 */
public void doAction(PortletWindow portletWindow,HttpServletRequest request,HttpServletResponse response) throws PortletException, IOException, PortletContainerException {
  ensureInitialized();
  InternalPortletWindow internalPortletWindow=new InternalPortletWindowImpl(PortletContextManager.getPortletContext(servletContext,portletWindow.getContextPath()),portletWindow);
  debugWithName(""String_Node_Str"" + portletWindow.getPortletName());
  InternalActionRequest actionRequest=getOptionalContainerServices().getPortletEnvironmentService().createActionRequest(this,request,response,internalPortletWindow);
  InternalActionResponse actionResponse=getOptionalContainerServices().getPortletEnvironmentService().createActionResponse(this,request,response,internalPortletWindow);
  PortletInvokerService invoker=optionalContainerServices.getPortletInvokerService();
  try {
    ContainerInvocation.setInvocation(this,internalPortletWindow);
    invoker.action(actionRequest,actionResponse,internalPortletWindow);
  }
  finally {
    ContainerInvocation.clearInvocation();
  }
  debugWithName(""String_Node_Str"" + portletWindow.getPortletName());
  PortletURLProvider portletURLProvider=requiredContainerServices.getPortalCallbackService().getPortletURLProvider(request,internalPortletWindow);
  portletURLProvider.savePortalURL(request);
  saveChangedParameters((PortletRequest)actionRequest,(StateAwareResponseImpl)actionResponse,portletURLProvider);
  EventProvider provider=this.getRequiredContainerServices().getPortalCallbackService().getEventProvider(request,portletWindow);
  provider.fireEvents(this);
  String location=actionResponse.getRedirectLocation();
  if (location == null) {
    debugWithName(""String_Node_Str"");
    PortletURLProvider redirectURL=requiredContainerServices.getPortalCallbackService().getPortletURLProvider(request,internalPortletWindow);
    saveChangedParameters((PortletRequest)actionRequest,(StateAwareResponseImpl)actionResponse,redirectURL);
    location=actionResponse.encodeRedirectURL(redirectURL.toString());
  }
  response.sendRedirect(location);
  debugWithName(""String_Node_Str"");
}",0.9788531923546157
90664,"public void testContainerMinorVersion(){
  assertTrue(Environment.getPortletContainerVersion().endsWith(Environment.getPortletContainerMinorVersion()));
}","public void testContainerMinorVersion(){
}",0.4285714285714285
90665,"public void testContainerVersion(){
  assertEquals(props.getProperty(""String_Node_Str""),Environment.getPortletContainerVersion());
}","public void testContainerVersion(){
}",0.4378698224852071
90666,"public void testServerInfo(){
  assertContains(""String_Node_Str"",props.getProperty(""String_Node_Str""),Environment.getServerInfo());
  assertContains(""String_Node_Str"",props.getProperty(""String_Node_Str""),Environment.getServerInfo());
}","public void testServerInfo(){
}",0.2330827067669172
90667,"public void testContainerMajorVersion(){
  assertEquals(""String_Node_Str"",Environment.getPortletContainerMajorVersion());
}","public void testContainerMajorVersion(){
}",0.509090909090909
90668,"/** 
 */
private Collection<PortletWindowConfig> getAllPortlets(DriverConfiguration driverConfig){
  Collection<PortletApplicationConfig> apps=driverConfig.getPortletApplications();
  Collection<PortletWindowConfig> portlets=new ArrayList<PortletWindowConfig>();
  for (  PortletApplicationConfig app : apps) {
    portlets.addAll(app.getPortlets());
  }
  return portlets;
}","/** 
 */
private Collection<PortletWindowConfig> getAllPortlets(DriverConfiguration driverConfig){
  Collection<PortletWindowConfig> portlets=new ArrayList<PortletWindowConfig>();
  return portlets;
}",0.6469565217391304
90669,"/** 
 * Constructs an instance.
 * @param servletContext  the servlet context in which we are contained.
 * @param portletAppDD  the portlet application descriptor.
 */
public PortletContextImpl(String portletApplicationId,ServletContext servletContext,PortletAppDD portletAppDD,String portletName){
  this.servletContext=servletContext;
  this.portletAppDD=portletAppDD;
  this.applicationId=portletApplicationId;
  this.applicationName=servletContext.getServletContextName();
  if (applicationName == null) {
    applicationName=applicationId;
  }
  for (  PortletDD portletDD : (List<PortletDD>)portletAppDD.getPortlets()) {
    if (portletDD.getPortletName().equals(portletName))     this.portletDD=portletDD;
    break;
  }
  assert(portletDD != null);
  init();
}","/** 
 * Constructs an instance.
 * @param servletContext  the servlet context in which we are contained.
 * @param portletAppDD  the portlet application descriptor.
 */
public PortletContextImpl(String portletApplicationId,ServletContext servletContext,PortletAppDD portletAppDD){
  this.servletContext=servletContext;
  this.portletAppDD=portletAppDD;
  this.applicationId=portletApplicationId;
  this.applicationName=servletContext.getServletContextName();
  if (applicationName == null) {
    applicationName=applicationId;
  }
  init();
}",0.8268497330282227
90670,"private EventDefinitionDD getEventDefintion(QName name) throws PortletContainerException {
  PortletAppDD appDD=container.getPortletApplicationDescriptor(window.getContextPath());
  for (  EventDefinitionDD def : appDD.getEvents()) {
    if (def.getName().equals(name)) {
      return def;
    }
  }
  return null;
}","private EventDefinitionDD getEventDefintion(QName name) throws PortletContainerException {
  PortletAppDD appDD=container.getPortletApplicationDescriptor(window.getContextPath());
  for (  EventDefinitionDD def : appDD.getEvents()) {
    if (def.getName().equals(name)) {
      return def;
    }
    if (def.getName().getNamespaceURI() != null && (def.getName().getNamespaceURI().equals(""String_Node_Str""))) {
      QName qname=new QName(appDD.getDefaultNamespace(),def.getName().getLocalPart());
      if (qname.equals(name))       return def;
    }
  }
  return null;
}",0.7125140924464487
90671,"private boolean isDeclaredAsPublishingEvent(QName qname){
  List<QName> events=internalPortletWindow.getPortletEntity().getPortletDefinition().getPublishingEvents();
  return events != null && events.contains(qname);
}","private boolean isDeclaredAsPublishingEvent(QName qname){
  List<QName> events=internalPortletWindow.getPortletEntity().getPortletDefinition().getPublishingEvents();
  List<QName> tempEvents=new ArrayList<QName>();
  if (events == null)   return false;
  for (  QName name : events) {
    if (name.getNamespaceURI() != null && !(name.getNamespaceURI().equals(""String_Node_Str"")))     tempEvents.add(name);
 else     tempEvents.add(new QName(getDefaultEventNamespace(),name.getLocalPart()));
  }
  return tempEvents.contains(qname);
}",0.5059920106524634
90672,"public String getShortTitle(PortletWindow window){
  if (window instanceof InternalPortletWindow) {
    return getPortletDefinition((InternalPortletWindow)window).getPortletInfo().getTitle();
  }
  return null;
}","public String getShortTitle(PortletWindow window){
  if (window instanceof InternalPortletWindow) {
    return getPortletDefinition((InternalPortletWindow)window).getPortletInfo().getShortTitle();
  }
  return null;
}",0.9883449883449884
90673,"public String getKeywords(PortletWindow window){
  if (window instanceof InternalPortletWindow) {
    return getPortletDefinition((InternalPortletWindow)window).getPortletInfo().getTitle();
  }
  return null;
}","public String getKeywords(PortletWindow window){
  if (window instanceof InternalPortletWindow) {
    return getPortletDefinition((InternalPortletWindow)window).getPortletInfo().getKeywords();
  }
  return null;
}",0.9692671394799054
90674,"public PortalServletRequest(HttpServletRequest request,PortletWindow window){
  super(request);
  this.portletWindow=window;
  url=PortalRequestContext.getPortalEnvironment(request).getRequestedPortalURL();
}","public PortalServletRequest(HttpServletRequest request,PortletWindow window){
  super(request);
  this.portletWindow=window;
  url=PortalRequestContext.getContext(request).getRequestedPortalURL();
}",0.9605911330049262
90675,"/** 
 * Method invoked when the start tag is encountered.
 * @throws JspException  if an error occurs.
 */
public int doStartTag() throws JspException {
  evaluatePortletId();
  ServletContext servletContext=pageContext.getServletContext();
  DriverConfiguration driverConfig=(DriverConfiguration)servletContext.getAttribute(AttributeKeys.DRIVER_CONFIG);
  PortletWindowConfig windowConfig=driverConfig.getPortletWindowConfig(evaluatedPortletId);
  if (LOG.isDebugEnabled()) {
    LOG.debug(""String_Node_Str"" + windowConfig);
  }
  PortalRequestContext portalEnv=PortalRequestContext.getPortalEnvironment((HttpServletRequest)pageContext.getRequest());
  PortalURL portalURL=portalEnv.getRequestedPortalURL();
  PortletWindow window=new PortletWindowImpl(windowConfig,portalURL);
  Map windowStates=portalURL.getWindowStates();
  for (Iterator it=windowStates.keySet().iterator(); it.hasNext(); ) {
    String windowId=(String)it.next();
    WindowState windowState=(WindowState)windowStates.get(windowId);
    if (WindowState.MAXIMIZED.equals(windowState) && !window.getId().getStringId().equals(windowId)) {
      return SKIP_BODY;
    }
  }
  PortalServletRequest portalRequest=new PortalServletRequest((HttpServletRequest)pageContext.getRequest(),window);
  PortalServletResponse portalResponse=new PortalServletResponse((HttpServletResponse)pageContext.getResponse());
  PortletContainer container=(PortletContainer)servletContext.getAttribute(AttributeKeys.PORTLET_CONTAINER);
  try {
    container.doRender(window,portalRequest,portalResponse);
    response=portalResponse;
    status=SUCCESS;
  }
 catch (  Throwable th) {
    status=FAILED;
    throwable=th;
  }
  return EVAL_BODY_INCLUDE;
}","/** 
 * Method invoked when the start tag is encountered.
 * @throws JspException  if an error occurs.
 */
public int doStartTag() throws JspException {
  evaluatePortletId();
  ServletContext servletContext=pageContext.getServletContext();
  DriverConfiguration driverConfig=(DriverConfiguration)servletContext.getAttribute(AttributeKeys.DRIVER_CONFIG);
  PortletWindowConfig windowConfig=driverConfig.getPortletWindowConfig(evaluatedPortletId);
  if (LOG.isDebugEnabled()) {
    LOG.debug(""String_Node_Str"" + windowConfig);
  }
  PortalRequestContext portalEnv=PortalRequestContext.getContext((HttpServletRequest)pageContext.getRequest());
  PortalURL portalURL=portalEnv.getRequestedPortalURL();
  PortletWindow window=new PortletWindowImpl(windowConfig,portalURL);
  Map windowStates=portalURL.getWindowStates();
  for (Iterator it=windowStates.keySet().iterator(); it.hasNext(); ) {
    String windowId=(String)it.next();
    WindowState windowState=(WindowState)windowStates.get(windowId);
    if (WindowState.MAXIMIZED.equals(windowState) && !window.getId().getStringId().equals(windowId)) {
      return SKIP_BODY;
    }
  }
  PortalServletRequest portalRequest=new PortalServletRequest((HttpServletRequest)pageContext.getRequest(),window);
  PortalServletResponse portalResponse=new PortalServletResponse((HttpServletResponse)pageContext.getResponse());
  PortletContainer container=(PortletContainer)servletContext.getAttribute(AttributeKeys.PORTLET_CONTAINER);
  try {
    container.doRender(window,portalRequest,portalResponse);
    response=portalResponse;
    status=SUCCESS;
  }
 catch (  Throwable th) {
    status=FAILED;
    throwable=th;
  }
  return EVAL_BODY_INCLUDE;
}",0.993510324483776
90676,"public PortletSession getPortletSession(boolean create){
  if (LOG.isDebugEnabled()) {
    LOG.debug(""String_Node_Str"" + create + ""String_Node_Str"");
  }
  if (portletContext == null) {
    throw new IllegalStateException(EXCEPTIONS.getString(""String_Node_Str""));
  }
  HttpSession httpSession=getHttpServletRequest().getSession(create);
  if (httpSession == null) {
    if (LOG.isDebugEnabled()) {
      LOG.debug(""String_Node_Str"");
    }
    return null;
  }
  if (portletSession == null) {
    portletSession=new PortletSessionImpl(portletContext,internalPortletWindow,httpSession);
  }
  return portletSession;
}","/** 
 * Returns the portlet session. <p> Note that since portlet request instance is created everytime the portlet container receives an incoming request, the portlet session instance held by the request instance is also re-created for each incoming request. </p>
 */
public PortletSession getPortletSession(boolean create){
  if (LOG.isDebugEnabled()) {
    LOG.debug(""String_Node_Str"" + create + ""String_Node_Str"");
  }
  if (portletContext == null) {
    throw new IllegalStateException(EXCEPTIONS.getString(""String_Node_Str""));
  }
  HttpSession httpSession=getHttpServletRequest().getSession(create);
  if (httpSession != null) {
    long maxInactiveTime=httpSession.getMaxInactiveInterval() * 1000L;
    long currentInactiveTime=System.currentTimeMillis() - httpSession.getLastAccessedTime();
    if (currentInactiveTime > maxInactiveTime) {
      if (LOG.isDebugEnabled()) {
        LOG.debug(""String_Node_Str"" + ""String_Node_Str"");
      }
      httpSession.invalidate();
      httpSession=getHttpServletRequest().getSession(create);
    }
  }
  if (httpSession == null) {
    if (LOG.isDebugEnabled()) {
      LOG.debug(""String_Node_Str"" + ""String_Node_Str"");
    }
    return null;
  }
  if (portletSession == null) {
    if (LOG.isDebugEnabled()) {
      LOG.debug(""String_Node_Str"");
    }
    portletSession=new PortletSessionImpl(portletContext,internalPortletWindow,httpSession);
  }
  return portletSession;
}",0.5817825661116552
90677,"public void setMaxInactiveInterval(int interval){
  httpSession.setMaxInactiveInterval(interval);
  if (LOG.isDebugEnabled()) {
    LOG.debug(""String_Node_Str"" + interval);
  }
}","/** 
 * Specifies the time, in seconds, between client requests, before the portlet container invalidates this session. A negative time indicates the session should never timeout. <p> [Portlet Spec. PLT. 15.4.] If the PortletSession object is invalidated by a portlet, the portlet container must invalidate the associated HttpSession object. </p>
 * @param interval  an integer specifying the number of seconds.
 */
public void setMaxInactiveInterval(int interval){
  httpSession.setMaxInactiveInterval(interval);
  if (LOG.isDebugEnabled()) {
    LOG.debug(""String_Node_Str"" + interval);
  }
}",0.4611398963730569
90678,"protected TestResult checkSessionInvalidated(PortletRequest request){
  TestResult result=new TestResult();
  result.setDescription(""String_Node_Str"" + ""String_Node_Str"");
  result.setSpecPLT(""String_Node_Str"");
  String maxInactiveIntervalSet=request.getParameter(MAX_INACTIVE_INTERVAL_SET);
  if (LOG.isDebugEnabled()) {
    LOG.debug(""String_Node_Str"" + MAX_INACTIVE_INTERVAL_SET + ""String_Node_Str""+ maxInactiveIntervalSet);
  }
  if (Boolean.TRUE.toString().equals(maxInactiveIntervalSet)) {
    if (LOG.isDebugEnabled()) {
      LOG.debug(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + System.currentTimeMillis() + ""String_Node_Str"");
    }
    PortletSession session=request.getPortletSession(false);
    if (session == null) {
      result.setReturnCode(TestResult.PASSED);
    }
 else {
      result.setReturnCode(TestResult.FAILED);
      result.setResultMessage(""String_Node_Str"" + ""String_Node_Str"");
    }
  }
 else {
    if (LOG.isDebugEnabled()) {
      LOG.debug(""String_Node_Str"" + ""String_Node_Str"" + System.currentTimeMillis() + ""String_Node_Str"");
    }
    PortletSession session=request.getPortletSession(true);
    session.setMaxInactiveInterval(5);
    result.setReturnCode(TestResult.WARNING);
    result.setResultMessage(""String_Node_Str"");
  }
  return result;
}","protected TestResult checkSessionInvalidated(PortletRequest request){
  TestResult result=new TestResult();
  result.setDescription(""String_Node_Str"" + ""String_Node_Str"");
  result.setSpecPLT(""String_Node_Str"");
  String maxInactiveIntervalSet=request.getParameter(MAX_INACTIVE_INTERVAL_SET);
  if (LOG.isDebugEnabled()) {
    LOG.debug(""String_Node_Str"" + MAX_INACTIVE_INTERVAL_SET + ""String_Node_Str""+ maxInactiveIntervalSet);
  }
  if (Boolean.TRUE.toString().equals(maxInactiveIntervalSet)) {
    if (LOG.isDebugEnabled()) {
      LOG.debug(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"" + System.currentTimeMillis() + ""String_Node_Str"");
    }
    PortletSession session=request.getPortletSession(false);
    if (session == null) {
      result.setReturnCode(TestResult.PASSED);
    }
 else {
      result.setReturnCode(TestResult.FAILED);
      result.setResultMessage(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str""+ ""String_Node_Str"");
    }
  }
 else {
    if (LOG.isDebugEnabled()) {
      LOG.debug(""String_Node_Str"" + ""String_Node_Str"" + System.currentTimeMillis() + ""String_Node_Str"");
    }
    PortletSession session=request.getPortletSession(true);
    session.setMaxInactiveInterval(5);
    result.setReturnCode(TestResult.WARNING);
    result.setResultMessage(""String_Node_Str"");
  }
  return result;
}",0.985244040862656
90679,"public void setLocale(java.util.Locale loc){
  getHttpServletResponse().setLocale(loc);
}","public void setLocale(Locale locale){
  getHttpServletResponse().setLocale(locale);
}",0.9080459770114944
90680,"/** 
 * @todo is it appropriate to throw an illegal state if content type is not set.  how do we set automatically
 * @return
 * @throws IOException
 * @throws IllegalStateException
 */
public OutputStream getPortletOutputStream() throws IOException, IllegalStateException {
  if (currentContentType == null) {
    String message=EXCEPTIONS.getString(""String_Node_Str"");
    if (LOG.isWarnEnabled()) {
      LOG.warn(message);
    }
  }
  return getOutputStream();
}","public OutputStream getPortletOutputStream() throws IOException, IllegalStateException {
  if (currentContentType == null) {
    String message=EXCEPTIONS.getString(""String_Node_Str"");
    if (LOG.isWarnEnabled()) {
      LOG.warn(""String_Node_Str"");
    }
    throw new IllegalStateException(message);
  }
  return getOutputStream();
}",0.6807980049875312
90681,"/** 
 * TODO: is it appropriate to throw an illegal state if content type is not set.  how do we set automatically
 */
public PrintWriter getWriter() throws IOException, IllegalStateException {
  if (currentContentType == null) {
    String message=EXCEPTIONS.getString(""String_Node_Str"");
    if (LOG.isWarnEnabled()) {
      LOG.warn(""String_Node_Str"" + message);
    }
  }
  return super.getWriter();
}","public PrintWriter getWriter() throws IOException, IllegalStateException {
  if (currentContentType == null) {
    String message=EXCEPTIONS.getString(""String_Node_Str"");
    if (LOG.isWarnEnabled()) {
      LOG.warn(""String_Node_Str"");
    }
    throw new IllegalStateException(message);
  }
  return super.getWriter();
}",0.6905089408528198
90682,"public void setContentType(String type){
  String mimeType=StringUtils.stringCharacterEncoding(type);
  if (!isValidContentType(mimeType)) {
    throw new IllegalArgumentException(mimeType);
  }
  this.getHttpServletResponse().setContentType(mimeType);
  currentContentType=mimeType;
}","public void setContentType(String type){
  String mimeType=StringUtils.stringCharacterEncoding(type);
  if (!isValidContentType(mimeType)) {
    throw new IllegalArgumentException(mimeType);
  }
  this.getHttpServletResponse().setContentType(mimeType);
  this.currentContentType=mimeType;
}",0.991304347826087
90683,"/** 
 * Returns all preferences of this portlet The return value cannot be NULL.
 * @return the preference set
 */
public PortletPreference[] getDefaultPreferences(){
  if (defaultPreferences == null) {
    PortletDD portletDD=getPortletDefinition();
    PortletPreferencesDD prefsDD=portletDD.getPortletPreferences();
    if (prefsDD != null) {
      List prefs=new ArrayList();
      for (Iterator it=prefsDD.getPortletPreferences().iterator(); it.hasNext(); ) {
        PortletPreferenceDD prefDD=(PortletPreferenceDD)it.next();
        String[] values=(String[])prefDD.getValues().toArray(new String[prefDD.getValues().size()]);
        PortletPreferenceImpl pref=new PortletPreferenceImpl(prefDD.getName(),values,prefDD.isReadOnly());
        prefs.add(pref);
      }
      defaultPreferences=(PortletPreference[])prefs.toArray(new PortletPreference[prefs.size()]);
    }
  }
  return defaultPreferences;
}","/** 
 * Returns an array of default preferences of this portlet. The default preferences are retrieved from the portlet application descriptor. <p> Data retrieved from <code>portlet.xml</code> are injected into the domain object <code>PortletPreferenceDD</code>. This method converts the domain objects into <code>PortletPreference</code> objects. </p> <p> Note that if no value is bound to a given preference key, <code>PortletPreferenceDD.getValues()</code> will return an empty string list, but the value array of <code>PortletPreference</code> should be set to null (instead of an empty array). </p> <p> This method never returns null. </p>
 * @return the preference set
 * @see org.apache.pluto.descriptors.portlet.PortletPreferenceDD
 */
public PortletPreference[] getDefaultPreferences(){
  if (defaultPreferences == null) {
    PortletDD portletDD=getPortletDefinition();
    PortletPreferencesDD prefsDD=portletDD.getPortletPreferences();
    if (prefsDD != null) {
      List prefs=new ArrayList();
      for (Iterator it=prefsDD.getPortletPreferences().iterator(); it.hasNext(); ) {
        PortletPreferenceDD prefDD=(PortletPreferenceDD)it.next();
        String[] values=null;
        if (prefDD.getValues().size() > 0) {
          values=(String[])prefDD.getValues().toArray(new String[prefDD.getValues().size()]);
        }
        PortletPreferenceImpl pref=new PortletPreferenceImpl(prefDD.getName(),values,prefDD.isReadOnly());
        prefs.add(pref);
      }
      defaultPreferences=(PortletPreference[])prefs.toArray(new PortletPreference[prefs.size()]);
    }
  }
  return defaultPreferences;
}",0.6998813760379596
90684,"public String getValue(String key,String defaultValue){
  String[] values=getValues(key,new String[]{defaultValue});
  return (values != null && values.length > 0) ? values[0] : null;
}","public String getValue(String key,String defaultValue){
  String[] values=getValues(key,new String[]{defaultValue});
  String value=null;
  if (values != null && values.length > 0) {
    value=values[0];
  }
  if (value == null) {
    value=defaultValue;
  }
  return value;
}",0.7245119305856833
90685,"public String[] getValues(String key,String[] defaultValues){
  if (key == null) {
    throw new IllegalArgumentException(EXCEPTIONS.getString(""String_Node_Str"",""String_Node_Str""));
  }
  String[] values=null;
  PortletPreference pref=(PortletPreference)preferences.get(key);
  if (pref != null) {
    values=pref.getValues();
  }
 else {
    values=defaultValues;
  }
  return values;
}","public String[] getValues(String key,String[] defaultValues){
  if (key == null) {
    throw new IllegalArgumentException(EXCEPTIONS.getString(""String_Node_Str"",""String_Node_Str""));
  }
  String[] values=null;
  PortletPreference pref=(PortletPreference)preferences.get(key);
  if (pref != null) {
    values=pref.getValues();
  }
  if (values == null) {
    values=defaultValues;
  }
  return values;
}",0.9696202531645568
90686,"public PortletRequestDispatcher getRequestDispatcher(String path){
  if (LOG.isDebugEnabled()) {
    LOG.debug(""String_Node_Str"" + path);
  }
  if (path == null || !path.startsWith(""String_Node_Str"")) {
    if (LOG.isInfoEnabled()) {
      LOG.info(""String_Node_Str"" + ""String_Node_Str"");
    }
    return null;
  }
  String dispatchingPath=null;
  Map params=null;
  int index=path.indexOf(""String_Node_Str"");
  if (index > 0) {
    dispatchingPath=path.substring(0,index);
    if (index < path.length() - 1) {
      params=parseQueryParams(path.substring(index + 1));
    }
  }
 else {
    dispatchingPath=path;
  }
  PortletRequestDispatcher portletRequestDispatcher=null;
  try {
    RequestDispatcher servletRequestDispatcher=servletContext.getRequestDispatcher(dispatchingPath);
    if (servletRequestDispatcher != null) {
      portletRequestDispatcher=new PortletRequestDispatcherImpl(servletRequestDispatcher,params);
    }
 else {
      if (LOG.isInfoEnabled()) {
        LOG.info(""String_Node_Str"" + dispatchingPath);
      }
    }
  }
 catch (  Exception ex) {
    if (LOG.isInfoEnabled()) {
      LOG.info(""String_Node_Str"" + ex.getMessage());
    }
    portletRequestDispatcher=null;
  }
  return portletRequestDispatcher;
}","public PortletRequestDispatcher getRequestDispatcher(String path){
  if (LOG.isDebugEnabled()) {
    LOG.debug(""String_Node_Str"" + path);
  }
  if (path == null || !path.startsWith(""String_Node_Str"")) {
    if (LOG.isInfoEnabled()) {
      LOG.info(""String_Node_Str"" + ""String_Node_Str"");
    }
    return null;
  }
  Map appendedParameters=null;
  int index=path.indexOf(""String_Node_Str"");
  if (index > 0 && index < path.length() - 1) {
    appendedParameters=parseQueryString(path.substring(index + 1));
  }
  PortletRequestDispatcher portletRequestDispatcher=null;
  try {
    RequestDispatcher servletRequestDispatcher=servletContext.getRequestDispatcher(path);
    if (servletRequestDispatcher != null) {
      portletRequestDispatcher=new PortletRequestDispatcherImpl(servletRequestDispatcher,appendedParameters);
    }
 else {
      if (LOG.isInfoEnabled()) {
        LOG.info(""String_Node_Str"" + path);
      }
    }
  }
 catch (  Exception ex) {
    if (LOG.isInfoEnabled()) {
      LOG.info(""String_Node_Str"" + ex.getMessage());
    }
    portletRequestDispatcher=null;
  }
  return portletRequestDispatcher;
}",0.7372881355932204
90687,"public PortletRequestDispatcherImpl(RequestDispatcher requestDispatcher,Map queryParams){
  this(requestDispatcher);
  this.queryParams=queryParams;
}","/** 
 * Creates an instance. This constructor should be called to construct a portlet request dispatcher.
 * @param requestDispatcher  the servlet request dispatcher.
 * @param queryParams  the appended query parameters.
 * @see javax.portlet.PortletContext#getRequestDispatcher(String)
 */
public PortletRequestDispatcherImpl(RequestDispatcher requestDispatcher,Map queryParams){
  this(requestDispatcher);
  this.queryParams=queryParams;
  if (LOG.isDebugEnabled()) {
    LOG.debug(""String_Node_Str"");
  }
}",0.4552352048558422
90688,"public void include(RenderRequest request,RenderResponse response) throws PortletException, IOException {
  InternalRenderRequest internalRequest=(InternalRenderRequest)InternalImplConverter.getInternalRequest(request);
  InternalRenderResponse internalResponse=(InternalRenderResponse)InternalImplConverter.getInternalResponse(response);
  if (queryParams != null) {
    if (LOG.isDebugEnabled()) {
      LOG.debug(""String_Node_Str"");
    }
    internalRequest=new IncludedRenderRequestImpl(internalRequest,queryParams);
  }
  boolean isIncluded=(internalRequest.isIncluded() || internalResponse.isIncluded());
  try {
    internalRequest.setIncluded(true);
    internalResponse.setIncluded(true);
    requestDispatcher.include((HttpServletRequest)internalRequest,(HttpServletResponse)internalResponse);
  }
 catch (  IOException ex) {
    throw ex;
  }
catch (  ServletException ex) {
    if (ex.getRootCause() != null) {
      throw new PortletException(ex.getRootCause());
    }
 else {
      throw new PortletException(ex);
    }
  }
 finally {
    internalRequest.setIncluded(isIncluded);
    internalResponse.setIncluded(isIncluded);
  }
}","public void include(RenderRequest request,RenderResponse response) throws PortletException, IOException {
  InternalRenderRequest internalRequest=(InternalRenderRequest)InternalImplConverter.getInternalRequest(request);
  InternalRenderResponse internalResponse=(InternalRenderResponse)InternalImplConverter.getInternalResponse(response);
  boolean isIncluded=(internalRequest.isIncluded() || internalResponse.isIncluded());
  try {
    internalRequest.setIncluded(true);
    internalRequest.setAppendedParameters(queryParams);
    internalResponse.setIncluded(true);
    requestDispatcher.include((HttpServletRequest)internalRequest,(HttpServletResponse)internalResponse);
  }
 catch (  IOException ex) {
    throw ex;
  }
catch (  ServletException ex) {
    if (ex.getRootCause() != null) {
      throw new PortletException(ex.getRootCause());
    }
 else {
      throw new PortletException(ex);
    }
  }
 finally {
    internalRequest.setIncluded(isIncluded);
    internalResponse.setIncluded(isIncluded);
  }
}",0.3535400277649236
90689,"public String getParameter(String name){
  ArgumentUtility.validateNotNull(""String_Node_Str"",name);
  bodyAccessed=true;
  Map parameters=this.getHttpServletRequest().getParameterMap();
  String[] values=(String[])parameters.get(name);
  if (values != null) {
    return values[0];
  }
  return null;
}","public String getParameter(String name){
  ArgumentUtility.validateNotNull(""String_Node_Str"",name);
  bodyAccessed=true;
  Map parameters=this.getHttpServletRequest().getParameterMap();
  String[] values=(String[])parameters.get(name);
  if (values != null) {
    return values[0];
  }
 else {
    return null;
  }
}",0.9320388349514565
90690,"/** 
 * FIXME: portlet preference method ID!
 */
public PortletPreferences getPreferences(){
  if (portletPreferences == null) {
    portletPreferences=new PortletPreferencesImpl(getPortletContainer(),getInternalPortletWindow(),this,Constants.METHOD_RENDER);
  }
  return portletPreferences;
}","public PortletPreferences getPreferences(){
  if (portletPreferences == null) {
    portletPreferences=new PortletPreferencesImpl(getPortletContainer(),getInternalPortletWindow(),this,Constants.METHOD_RENDER);
  }
  return portletPreferences;
}",0.9087523277467412
90691,"public void setIncluded(boolean included){
  this.included=included;
}","public void setIncluded(boolean included){
  this.included=included;
  if (!included) {
    this.parameters=null;
  }
  if (LOG.isDebugEnabled()) {
    LOG.debug(""String_Node_Str"" + included);
  }
}",0.5223880597014925
90692,"public PortletPreference[] getStoredPreferences(PortletWindow portletWindow,PortletRequest request) throws PortletContainerException {
  String key=getFormattedKey(portletWindow,request.getRemoteUser());
  PortletPreference[] prefs=(PortletPreference[])storage.get(key);
  if (prefs == null) {
    if (LOG.isDebugEnabled()) {
      LOG.debug(""String_Node_Str"" + key);
    }
    return new PortletPreference[0];
  }
 else {
    return prefs;
  }
}","/** 
 * Returns the stored portlet preferences array. The preferences managed by this service should be protected from being directly accessed, so this method returns a cloned copy of the stored preferences.
 * @see org.apache.pluto.core.PortletPreference#clone()
 * @param portletWindow  the portlet window.
 * @param request  the portlet request from which the remote user is retrieved.
 * @return a copy of the stored portlet preferences array.
 * @throws PortletContainerException
 */
public PortletPreference[] getStoredPreferences(PortletWindow portletWindow,PortletRequest request) throws PortletContainerException {
  String key=getFormattedKey(portletWindow,request);
  PortletPreference[] preferences=(PortletPreference[])storage.get(key);
  if (preferences == null) {
    if (LOG.isDebugEnabled()) {
      LOG.debug(""String_Node_Str"" + key);
    }
    return new PortletPreference[0];
  }
 else {
    if (LOG.isDebugEnabled()) {
      LOG.debug(""String_Node_Str"" + preferences.length + ""String_Node_Str"");
    }
    return clonePreferences(preferences);
  }
}",0.5514511873350924
90693,"/** 
 * Formats the preference key for the portlet preference using specified portlet window and remote user. TODO: this method depends on the impl of PortletWindow.toString()!
 * @param portletWindow  the portlet window.
 * @param user  the remote user.
 */
private String getFormattedKey(PortletWindow portletWindow,String user){
  StringBuffer buffer=new StringBuffer();
  buffer.append(""String_Node_Str"").append(user).append(""String_Node_Str"");
  buffer.append(""String_Node_Str"").append(portletWindow.getPortletName());
  return buffer.toString();
}","/** 
 * Formats the preference key for the portlet preference using specified portlet window and remote user.
 * @param portletWindow  the portlet window.
 * @param user  the remote user.
 */
private String getFormattedKey(PortletWindow portletWindow,PortletRequest request){
  StringBuffer buffer=new StringBuffer();
  buffer.append(""String_Node_Str"").append(request.getRemoteUser()).append(""String_Node_Str"");
  buffer.append(""String_Node_Str"").append(portletWindow.getPortletName());
  return buffer.toString();
}",0.8811973807296539
90694,"/** 
 * Stores the portlet preferences to the in-memory storage. This method should be invoked after the portlet preferences are validated by the preference validator (if defined).
 * @see javax.portlet.PortletPreferences#store()
 */
public void store(PortletWindow portletWindow,PortletRequest request,PortletPreference[] preferences) throws PortletContainerException {
  String key=getFormattedKey(portletWindow,request.getRemoteUser());
  storage.put(key,preferences);
  if (LOG.isDebugEnabled()) {
    LOG.debug(""String_Node_Str"" + key);
  }
}","/** 
 * Stores the portlet preferences to the in-memory storage. This method should be invoked after the portlet preferences are validated by the preference validator (if defined). <p> The preferences managed by this service should be protected from being directly accessed, so this method clones the passed-in preferences array and saves it. </p>
 * @see javax.portlet.PortletPreferences#store()
 * @see org.apache.pluto.core.PortletPreference#clone()
 * @param portletWindow  the portlet window
 * @param request  the portlet request from which the remote user is retrieved.
 * @param preferences  the portlet preferences to store.
 * @throws PortletContainerException
 */
public void store(PortletWindow portletWindow,PortletRequest request,PortletPreference[] preferences) throws PortletContainerException {
  String key=getFormattedKey(portletWindow,request);
  storage.put(key,clonePreferences(preferences));
  if (LOG.isDebugEnabled()) {
    LOG.debug(""String_Node_Str"" + key);
  }
}",0.6766428106701367
90695,"/** 
 * Stores the portlet preferences to a persistent storage.
 * @throws ValidatorException  if the portlet preferences are not valid.
 * @throws IOException  if an error occurs with the persistence mechanism.
 */
public void store() throws IOException, ValidatorException {
  if (!Constants.METHOD_ACTION.equals(methodId)) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  PreferencesValidator validator=window.getPortletEntity().getPreferencesValidator();
  if (validator != null) {
    validator.validate(this);
  }
  PortletPreference[] prefs=(PortletPreference[])new ArrayList(preferences.values()).toArray(new PortletPreference[preferences.size()]);
  try {
    preferencesService.store(window,request,prefs);
  }
 catch (  PortletContainerException ex) {
    LOG.error(""String_Node_Str"",ex);
    throw new IOException(""String_Node_Str"" + ex.getMessage());
  }
}","/** 
 * Stores the portlet preferences to a persistent storage. If a preferences validator is defined for this portlet, this method firstly validates the portlet preferences.
 * @throws ValidatorException  if the portlet preferences are not valid.
 * @throws IOException  if an error occurs with the persistence mechanism.
 */
public void store() throws IOException, ValidatorException {
  if (!Constants.METHOD_ACTION.equals(methodId)) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  PreferencesValidator validator=window.getPortletEntity().getPreferencesValidator();
  if (validator != null) {
    validator.validate(this);
  }
  PortletPreference[] prefs=(PortletPreference[])(new ArrayList(preferences.values())).toArray(new PortletPreference[preferences.size()]);
  try {
    preferencesService.store(window,request,prefs);
  }
 catch (  PortletContainerException ex) {
    LOG.error(""String_Node_Str"",ex);
    throw new IOException(""String_Node_Str"" + ex.getMessage());
  }
}",0.9399255715045188
90696,"/** 
 * Constructs an instance.
 * @param container  the portlet container.
 * @param portletWindow  the internal portlet window.
 * @param request  the internal portlet request.
 * @param methodId  the request method ID: render request or action request.
 */
public PortletPreferencesImpl(PortletContainer container,InternalPortletWindow window,InternalPortletRequest request,Integer methodId){
  this.window=window;
  this.request=request;
  this.methodId=methodId;
  preferencesService=container.getOptionalContainerServices().getPortletPreferencesService();
  if (LOG.isDebugEnabled()) {
    LOG.debug(""String_Node_Str"" + preferencesService.getClass().getName());
  }
  PortletEntity entity=window.getPortletEntity();
  defaultPreferences=entity.getDefaultPreferences();
  for (int i=0; i < defaultPreferences.length; i++) {
    preferences.put(defaultPreferences[i].getName(),(PortletPreference)defaultPreferences[i].clone());
  }
  if (LOG.isDebugEnabled()) {
    LOG.debug(""String_Node_Str"" + toString());
  }
  try {
    PortletPreference[] prefs=preferencesService.getStoredPreferences(window,request);
    for (int i=0; i < prefs.length; i++) {
      preferences.put(prefs[i].getName(),prefs[i]);
    }
    store();
  }
 catch (  PortletContainerException ex) {
    LOG.error(""String_Node_Str"",ex);
  }
catch (  IOException ex) {
    LOG.error(""String_Node_Str"",ex);
  }
catch (  ValidatorException ex) {
    LOG.warn(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",ex);
  }
}","/** 
 * Constructs an instance.
 * @param container  the portlet container.
 * @param portletWindow  the internal portlet window.
 * @param request  the internal portlet request.
 * @param methodId  the request method ID: render request or action request.
 */
public PortletPreferencesImpl(PortletContainer container,InternalPortletWindow window,InternalPortletRequest request,Integer methodId){
  this.window=window;
  this.request=request;
  this.methodId=methodId;
  preferencesService=container.getOptionalContainerServices().getPortletPreferencesService();
  if (LOG.isDebugEnabled()) {
    LOG.debug(""String_Node_Str"" + preferencesService.getClass().getName());
  }
  PortletEntity entity=window.getPortletEntity();
  defaultPreferences=entity.getDefaultPreferences();
  for (int i=0; i < defaultPreferences.length; i++) {
    preferences.put(defaultPreferences[i].getName(),(PortletPreference)defaultPreferences[i].clone());
  }
  if (LOG.isDebugEnabled()) {
    LOG.debug(""String_Node_Str"" + toString());
  }
  try {
    PortletPreference[] storedPreferences=preferencesService.getStoredPreferences(window,request);
    for (int i=0; i < storedPreferences.length; i++) {
      if (LOG.isDebugEnabled()) {
        LOG.debug(""String_Node_Str"" + storedPreferences[i].getName());
      }
      preferences.put(storedPreferences[i].getName(),storedPreferences[i]);
    }
    store();
  }
 catch (  PortletContainerException ex) {
    LOG.error(""String_Node_Str"",ex);
  }
catch (  IOException ex) {
    LOG.error(""String_Node_Str"",ex);
  }
catch (  ValidatorException ex) {
    LOG.warn(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",ex);
  }
  if (LOG.isDebugEnabled()) {
    LOG.debug(""String_Node_Str"" + toString());
  }
}",0.9053803339517624
90697,"/** 
 * Invoke test methods using java reflection. All 'check*' methods are invoked and test results are saved into <code>TestResults</code> object.
 * @param config  the portlet config.
 * @param context  the portlet context.
 * @param request  the portlet request.
 * @param response  the portlet response.
 * @return the test results including several TestResult instances. 
 */
public TestResults doTest(PortletConfig config,PortletContext context,PortletRequest request,PortletResponse response){
  TestResults results=new TestResults(getTestSuiteName());
  Method[] methods=getClass().getDeclaredMethods();
  for (int i=0; i < methods.length; i++) {
    if (methods[i].getName().startsWith(""String_Node_Str"")) {
      debugWithName(""String_Node_Str"" + methods[i].getName());
      try {
        TestResult result=invoke(methods[i],config,context,request,response);
        if (result.getName() == null) {
          result.setName(methods[i].getName());
        }
        results.add(result);
        debugWithName(""String_Node_Str"" + result);
      }
 catch (      Throwable th) {
        String message=""String_Node_Str"" + methods[i].getName() + ""String_Node_Str""+ th.getClass().getName()+ ""String_Node_Str""+ th.getMessage();
        errorWithName(message,th);
        TestResult result=new TestResult();
        result.setName(methods[i].getName());
        result.setReturnCode(TestResult.FAILED);
        result.setResultMessage(message);
        results.add(result);
      }
    }
  }
  return results;
}","/** 
 * Invoke test methods using java reflection. All 'check*' methods are invoked and test results are saved into <code>TestResults</code> object.
 * @param config  the portlet config.
 * @param context  the portlet context.
 * @param request  the portlet request.
 * @param response  the portlet response.
 * @return the test results including several TestResult instances. 
 */
public TestResults doTest(PortletConfig config,PortletContext context,PortletRequest request,PortletResponse response){
  TestResults results=new TestResults(getTestSuiteName());
  for (Iterator it=getCheckMethods().iterator(); it.hasNext(); ) {
    Method method=(Method)it.next();
    debugWithName(""String_Node_Str"" + method.getName());
    try {
      TestResult result=invoke(method,config,context,request,response);
      if (result.getName() == null) {
        result.setName(method.getName());
      }
      results.add(result);
      debugWithName(""String_Node_Str"" + result);
    }
 catch (    Throwable th) {
      String message=""String_Node_Str"" + method.getName() + ""String_Node_Str""+ th.getClass().getName()+ ""String_Node_Str""+ th.getMessage();
      errorWithName(message,th);
      TestResult result=new TestResult();
      result.setName(method.getName());
      result.setReturnCode(TestResult.FAILED);
      result.setResultMessage(message);
      results.add(result);
    }
  }
  return results;
}",0.6662092624356776
90698,"/** 
 * @param context  the servlet context from which this window isbeing invoked.
 * @param portletWindow  the underlying portlet window instance.
 */
public InternalPortletWindow(ServletContext context,PortletWindow portletWindow){
  this.servletContext=context.getContext(portletWindow.getContextPath());
  if (servletContext == null) {
    throw new PortletContainerRuntimeException(EXCEPTIONS.getString(""String_Node_Str"",portletWindow.getPortletName(),portletWindow.getContextPath()));
  }
  this.portletWindow=portletWindow;
}","/** 
 * Constructs an internal portlet window that wraps a portlet window. An internal portlet window instance is created everytime when the portlet container's <code>doRender()</code> or <code>doAction()</code> method is invoked.
 * @param context  the servlet context from which this window isbeing invoked.
 * @param portletWindow  the underlying portlet window instance.
 */
public InternalPortletWindow(ServletContext context,PortletWindow portletWindow){
  this.servletContext=context.getContext(portletWindow.getContextPath());
  if (servletContext == null) {
    throw new PortletContainerRuntimeException(EXCEPTIONS.getString(""String_Node_Str"",portletWindow.getPortletName(),portletWindow.getContextPath()));
  }
  this.portletWindow=portletWindow;
}",0.8250773993808049
90699,"public static PortletDescriptorRegistry getRegistry(){
  if (instance == null) {
    instance=new PortletDescriptorRegistry();
  }
  return instance;
}","/** 
 * Returns the singleton registry instance.
 * @return the singleton registry instance.
 */
public static PortletDescriptorRegistry getRegistry(){
  return REGISTRY;
}",0.4148606811145511
90700,"/** 
 * We must modify the context class loader in order for the Configuration utility to find the properties file.
 */
private PortletDescriptorRegistry(){
  String className=Configuration.getPortletAppDescriptorServiceImpl();
  try {
    Class cl=Class.forName(className);
    Object instance=cl.newInstance();
    portletDDService=(PortletAppDescriptorService)instance;
  }
 catch (  ClassNotFoundException e) {
    throw new PlutoConfigurationException(""String_Node_Str"" + className,e);
  }
catch (  InstantiationException e) {
    throw new PlutoConfigurationException(""String_Node_Str"" + className,e);
  }
catch (  IllegalAccessException e) {
    throw new PlutoConfigurationException(""String_Node_Str"" + className,e);
  }
}","/** 
 * Private constructor that prevents external instantiation. We must modify the context class loader in order for the Configuration utility to find the properties file.
 * @throws PlutoConfigurationException  if fail to instantiate portletapplication descriptor service.
 */
private PortletDescriptorRegistry() throws PlutoConfigurationException {
  String className=Configuration.getPortletAppDescriptorServiceImpl();
  try {
    Class clazz=Class.forName(className);
    portletDDService=(PortletAppDescriptorService)clazz.newInstance();
  }
 catch (  ClassNotFoundException ex) {
    throw new PlutoConfigurationException(""String_Node_Str"" + className,ex);
  }
catch (  InstantiationException ex) {
    throw new PlutoConfigurationException(""String_Node_Str"" + className,ex);
  }
catch (  IllegalAccessException ex) {
    throw new PlutoConfigurationException(""String_Node_Str"" + className,ex);
  }
}",0.8351648351648352
90701,"/** 
 * Retrieve the Portlet Application Deployment Descriptor for the given servlet context.  Create it if it does not allready exist.
 * @param context
 * @return The portlet application deployment descriptor.
 * @throws PortletContainerException
 */
public PortletAppDD getPortletAppDD(ServletContext context) throws PortletContainerException {
  PortletAppDD dd=(PortletAppDD)cache.get(context);
  if (dd == null) {
    dd=createDefinition(context);
    cache.put(context,dd);
  }
  return dd;
}","/** 
 * Retrieve the Portlet Application Deployment Descriptor for the given servlet context.  Create it if it does not allready exist.
 * @param servletContext  the servlet context.
 * @return The portlet application deployment descriptor.
 * @throws PortletContainerException
 */
public PortletAppDD getPortletAppDD(ServletContext servletContext) throws PortletContainerException {
  PortletAppDD portletAppDD=(PortletAppDD)cache.get(servletContext);
  if (portletAppDD == null) {
    portletAppDD=createDefinition(servletContext);
    cache.put(servletContext,portletAppDD);
  }
  return portletAppDD;
}",0.865158371040724
90702,"/** 
 * Create the portlet.xml deployment descriptor representation.
 * @param ctx the servlet context for which the DD is requested.
 * @return the Portlet Application Deployment Descriptor info.
 * @throws org.apache.pluto.PortletContainerException
 */
private PortletAppDD createDefinition(ServletContext ctx) throws PortletContainerException {
  PortletAppDD app=null;
  try {
    InputStream in=ctx.getResourceAsStream(PORTLET_XML);
    app=this.portletDDService.read(in);
  }
 catch (  IOException io) {
    throw new PortletContainerException(EXCEPTIONS.getString(""String_Node_Str"",new String[]{ctx.getServletContextName()}),io);
  }
  return app;
}","/** 
 * Creates the portlet.xml deployment descriptor representation.
 * @param servletContext  the servlet context for which the DD is requested.
 * @return the Portlet Application Deployment Descriptor.
 * @throws PortletContainerException
 */
private PortletAppDD createDefinition(ServletContext servletContext) throws PortletContainerException {
  PortletAppDD portletAppDD=null;
  try {
    InputStream in=servletContext.getResourceAsStream(PORTLET_XML);
    portletAppDD=portletDDService.read(in);
  }
 catch (  IOException ex) {
    throw new PortletContainerException(EXCEPTIONS.getString(""String_Node_Str"",new String[]{servletContext.getServletContextName()}),ex);
  }
  return portletAppDD;
}",0.8895434462444771
90703,"/** 
 * Stores the portlet preferences to a persistent storage.
 * @throws ValidatorException  if the portlet preferences are not valid.
 * @throws IOException  if an error occurs with the persistence mechanism.
 */
public void store() throws IOException, ValidatorException {
  if (!Constants.METHOD_ACTION.equals(methodId)) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  String validatorClass=window.getPortletEntity().getPortletDefinition().getPortletPreferences().getPreferencesValidator();
  if (validatorClass != null) {
    ClassLoader loader=Thread.currentThread().getContextClassLoader();
    try {
      Class clazz=loader.loadClass(validatorClass);
      PreferencesValidator validator=(PreferencesValidator)clazz.newInstance();
      validator.validate(this);
    }
 catch (    InstantiationException ex) {
      LOG.error(""String_Node_Str"",ex);
      throw new ValidatorException(ex,null);
    }
catch (    IllegalAccessException ex) {
      LOG.error(""String_Node_Str"",ex);
      throw new ValidatorException(ex,null);
    }
catch (    ClassNotFoundException ex) {
      LOG.error(""String_Node_Str"",ex);
      throw new ValidatorException(ex,null);
    }
catch (    ValidatorException ex) {
      LOG.error(""String_Node_Str"" + ex.getMessage());
      throw ex;
    }
  }
  PortletPreference[] prefs=(PortletPreference[])new ArrayList(preferences.values()).toArray(new PortletPreference[preferences.size()]);
  try {
    preferencesService.store(window,request,prefs);
  }
 catch (  PortletContainerException ex) {
    LOG.error(""String_Node_Str"",ex);
    throw new IOException(""String_Node_Str"" + ex.getMessage());
  }
}","/** 
 * Stores the portlet preferences to a persistent storage.
 * @throws ValidatorException  if the portlet preferences are not valid.
 * @throws IOException  if an error occurs with the persistence mechanism.
 */
public void store() throws IOException, ValidatorException {
  if (!Constants.METHOD_ACTION.equals(methodId)) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  PreferencesValidator validator=window.getPortletEntity().getPreferencesValidator();
  if (validator != null) {
    validator.validate(this);
  }
  PortletPreference[] prefs=(PortletPreference[])new ArrayList(preferences.values()).toArray(new PortletPreference[preferences.size()]);
  try {
    preferencesService.store(window,request,prefs);
  }
 catch (  PortletContainerException ex) {
    LOG.error(""String_Node_Str"",ex);
    throw new IOException(""String_Node_Str"" + ex.getMessage());
  }
}",0.3913214990138067
90704,"/** 
 * Stores the portlet preferences to a persistent storage. If a preferences validator is defined for this portlet, this method firstly validates the portlet preferences.
 * @throws ValidatorException  if the portlet preferences are not valid.
 * @throws IOException  if an error occurs with the persistence mechanism.
 */
public void store() throws IOException, ValidatorException {
  if (!Constants.METHOD_ACTION.equals(methodId)) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  PreferencesValidator validator=window.getPortletEntity().getPreferencesValidator();
  if (validator != null) {
    validator.validate(this);
  }
  PortletPreference[] prefs=(PortletPreference[])(new ArrayList(preferences.values())).toArray(new PortletPreference[preferences.size()]);
  try {
    preferencesService.store(window,request,prefs);
  }
 catch (  PortletContainerException ex) {
    LOG.error(""String_Node_Str"",ex);
    throw new IOException(""String_Node_Str"" + ex.getMessage());
  }
}","/** 
 * Stores the portlet preferences to a persistent storage. This method should only be invoked within <code>processAction()</code> method.
 * @see #internalStore()
 * @throws IllegalStateException  if this method is not invoked within<code>processAction()</code> method.
 * @throws ValidatorException  if the portlet preferences are not valid.
 * @throws IOException  if an error occurs with the persistence mechanism.
 */
public void store() throws IOException, ValidatorException {
  if (!Constants.METHOD_ACTION.equals(methodId)) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  internalStore();
}",0.504950495049505
90705,"/** 
 * Constructs an instance.
 * @param container  the portlet container.
 * @param portletWindow  the internal portlet window.
 * @param request  the internal portlet request.
 * @param methodId  the request method ID: render request or action request.
 */
public PortletPreferencesImpl(PortletContainer container,InternalPortletWindow window,InternalPortletRequest request,Integer methodId){
  this.window=window;
  this.request=request;
  this.methodId=methodId;
  preferencesService=container.getOptionalContainerServices().getPortletPreferencesService();
  if (LOG.isDebugEnabled()) {
    LOG.debug(""String_Node_Str"" + preferencesService.getClass().getName());
  }
  PortletEntity entity=window.getPortletEntity();
  defaultPreferences=entity.getDefaultPreferences();
  for (int i=0; i < defaultPreferences.length; i++) {
    preferences.put(defaultPreferences[i].getName(),(PortletPreference)defaultPreferences[i].clone());
  }
  if (LOG.isDebugEnabled()) {
    LOG.debug(""String_Node_Str"" + toString());
  }
  try {
    PortletPreference[] storedPreferences=preferencesService.getStoredPreferences(window,request);
    for (int i=0; i < storedPreferences.length; i++) {
      if (LOG.isDebugEnabled()) {
        LOG.debug(""String_Node_Str"" + storedPreferences[i].getName());
      }
      preferences.put(storedPreferences[i].getName(),storedPreferences[i]);
    }
    store();
  }
 catch (  PortletContainerException ex) {
    LOG.error(""String_Node_Str"",ex);
  }
catch (  IOException ex) {
    LOG.error(""String_Node_Str"",ex);
  }
catch (  ValidatorException ex) {
    LOG.warn(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",ex);
  }
  if (LOG.isDebugEnabled()) {
    LOG.debug(""String_Node_Str"" + toString());
  }
}","/** 
 * Constructs an instance.
 * @param container  the portlet container.
 * @param portletWindow  the internal portlet window.
 * @param request  the internal portlet request.
 * @param methodId  the request method ID: render request or action request.
 */
public PortletPreferencesImpl(PortletContainer container,InternalPortletWindow window,InternalPortletRequest request,Integer methodId){
  this.window=window;
  this.request=request;
  this.methodId=methodId;
  preferencesService=container.getOptionalContainerServices().getPortletPreferencesService();
  if (LOG.isDebugEnabled()) {
    LOG.debug(""String_Node_Str"" + preferencesService.getClass().getName());
  }
  PortletEntity entity=window.getPortletEntity();
  defaultPreferences=entity.getDefaultPreferences();
  for (int i=0; i < defaultPreferences.length; i++) {
    preferences.put(defaultPreferences[i].getName(),(PortletPreference)defaultPreferences[i].clone());
  }
  if (LOG.isDebugEnabled()) {
    LOG.debug(""String_Node_Str"" + toString());
  }
  try {
    PortletPreference[] storedPreferences=preferencesService.getStoredPreferences(window,request);
    for (int i=0; i < storedPreferences.length; i++) {
      if (LOG.isDebugEnabled()) {
        LOG.debug(""String_Node_Str"" + storedPreferences[i].getName());
      }
      preferences.put(storedPreferences[i].getName(),storedPreferences[i]);
    }
    internalStore();
  }
 catch (  PortletContainerException ex) {
    LOG.error(""String_Node_Str"",ex);
  }
catch (  IOException ex) {
    LOG.error(""String_Node_Str"",ex);
  }
catch (  ValidatorException ex) {
    LOG.warn(""String_Node_Str"" + ""String_Node_Str"" + ""String_Node_Str"",ex);
  }
  if (LOG.isDebugEnabled()) {
    LOG.debug(""String_Node_Str"" + toString());
  }
}",0.997129735935706
90706,"/** 
 * FIXME: portlet preference method ID!
 */
public PortletPreferences getPreferences(){
  if (portletPreferences == null) {
    portletPreferences=new PortletPreferencesImpl(getContainer(),getWindow(),this,Constants.METHOD_ACTION);
  }
  return portletPreferences;
}","/** 
 * FIXME: portlet preference method ID!
 */
public PortletPreferences getPreferences(){
  if (portletPreferences == null) {
    portletPreferences=new PortletPreferencesImpl(getContainer(),getWindow(),this,Constants.METHOD_RENDER);
  }
  return portletPreferences;
}",0.981549815498155
90707,"public Object getAttribute(String name,int scope){
  ArgumentUtility.validateNotNull(""String_Node_Str"",name);
  if (scope == PortletSession.APPLICATION_SCOPE) {
    return httpSession.getAttribute(name);
  }
 else {
    String key=createPortletScopedId(name);
    Object attribute=httpSession.getAttribute(key);
    if (LOG.isDebugEnabled()) {
      LOG.debug(""String_Node_Str"" + key);
      LOG.debug(""String_Node_Str"" + attribute);
      Enumeration enumer=httpSession.getAttributeNames();
      while (enumer.hasMoreElements()) {
        LOG.debug(""String_Node_Str"" + enumer.nextElement());
      }
    }
    if (attribute == null) {
      attribute=httpSession.getAttribute(name);
    }
    return attribute;
  }
}","/** 
 * Returns the attribute of the specified name under the given scope.
 * @param name  the attribute name.
 * @param scope  the scope under which the attribute object is stored.
 * @return the attribute object.
 */
public Object getAttribute(String name,int scope){
  ArgumentUtility.validateNotNull(""String_Node_Str"",name);
  if (scope == PortletSession.APPLICATION_SCOPE) {
    return httpSession.getAttribute(name);
  }
 else {
    String key=createPortletScopedId(name);
    Object attribute=httpSession.getAttribute(key);
    return attribute;
  }
}",0.5062695924764891
90708,"public Enumeration getAttributeNames(int scope){
  if (scope == PortletSession.APPLICATION_SCOPE) {
    return httpSession.getAttributeNames();
  }
 else {
    Enumeration attributes=httpSession.getAttributeNames();
    Vector portletAttributes=new Vector();
    while (attributes.hasMoreElements()) {
      String attribute=(String)attributes.nextElement();
      int scp=PortletSessionUtil.decodeScope(attribute);
      if (LOG.isDebugEnabled()) {
        LOG.debug(""String_Node_Str"" + attribute);
        LOG.debug(""String_Node_Str"" + (scp == PortletSession.PORTLET_SCOPE));
      }
      if (scp == PortletSession.PORTLET_SCOPE) {
        portletAttributes.add(PortletSessionUtil.decodeAttributeName(attribute));
      }
    }
    return portletAttributes.elements();
  }
}","public Enumeration getAttributeNames(int scope){
  if (scope == PortletSession.APPLICATION_SCOPE) {
    return httpSession.getAttributeNames();
  }
 else {
    Vector portletScopedNames=new Vector();
    for (Enumeration en=httpSession.getAttributeNames(); en.hasMoreElements(); ) {
      String name=(String)en.nextElement();
      if (isInCurrentPortletScope(name)) {
        portletScopedNames.add(PortletSessionUtil.decodeAttributeName(name));
      }
    }
    return portletScopedNames.elements();
  }
}",0.3716951788491446
90709,"/** 
 * Creates portlet-scoped ID for the specified attribute name.
 * @param name  the attribute name.
 * @return portlet-scoped ID for the attribute name.
 */
private String createPortletScopedId(String name){
  StringBuffer buffer=new StringBuffer();
  buffer.append(""String_Node_Str"");
  buffer.append(internalPortletWindow.getId()).append(""String_Node_Str"");
  buffer.append(name);
  return buffer.toString();
}","/** 
 * Creates portlet-scoped ID for the specified attribute name. Portlet-scoped ID for a given attribute name has the following form: <code>javax.portlet.p.&lt;ID&gt;?&lt;name&gt;</code> where <code>ID</code> is a unique identification for the portlet window (assigned by the portal/portlet-container) that must not contain a '?' character. <code>name</code> is the attribute name. <p> Refer to Portlet Specification PLT. 15.3 for more details. </p>
 * @param name  the attribute name.
 * @return portlet-scoped ID for the attribute name.
 */
private String createPortletScopedId(String name){
  StringBuffer buffer=new StringBuffer();
  buffer.append(PORTLET_SCOPE_NAMESPACE);
  buffer.append(internalPortletWindow.getId());
  buffer.append(ID_NAME_SEPARATOR);
  buffer.append(name);
  return buffer.toString();
}",0.5498783454987834
90710,"/** 
 * Override of toString() that prints out  name and values of fields.
 * @see java.lang.Object#toString()
 */
public String toString(){
  StringBuffer str=new StringBuffer();
  str.append(getClass().getName());
  str.append(""String_Node_Str"");
  str.append(""String_Node_Str"" + name + ""String_Node_Str"");
  for (int i=0; i < values.length; i++) {
    str.append(""String_Node_Str"" + i + ""String_Node_Str""+ values[i]);
    if (i < values.length) {
      str.append(""String_Node_Str"");
    }
  }
  str.append(""String_Node_Str"");
  str.append(""String_Node_Str"" + readOnly);
  str.append(""String_Node_Str"");
  return str.toString();
}","/** 
 * Override of toString() that prints out  name and values of fields.
 * @see java.lang.Object#toString()
 */
public String toString(){
  StringBuffer buffer=new StringBuffer();
  buffer.append(getClass().getName());
  buffer.append(""String_Node_Str"");
  buffer.append(""String_Node_Str"" + name + ""String_Node_Str"");
  for (int i=0; i < values.length; i++) {
    buffer.append(""String_Node_Str"" + i + ""String_Node_Str""+ values[i]);
  }
  buffer.append(""String_Node_Str"");
  buffer.append(""String_Node_Str"" + readOnly);
  buffer.append(""String_Node_Str"");
  return buffer.toString();
}",0.6339066339066339
90711,"public PortletPreferenceImpl(String name,String[] values,boolean readOnly){
  this.name=name;
  this.values=values;
  this.readOnly=readOnly;
}","/** 
 * FIXME: change to private!
 */
public PortletPreferenceImpl(){
}",0.308411214953271
90712,"public void reset(String key) throws ReadOnlyException {
  if (isReadOnly(key)) {
    throw new ReadOnlyException(EXCEPTIONS.getString(""String_Node_Str"",""String_Node_Str""));
  }
  for (int i=0; i < defaultPreferences.length; i++) {
    if (key.equals(defaultPreferences[i].getName())) {
      if (LOG.isDebugEnabled()) {
        LOG.debug(""String_Node_Str"" + key);
      }
      preferences.put(key,defaultPreferences[i]);
      return;
    }
  }
  if (LOG.isDebugEnabled()) {
    LOG.debug(""String_Node_Str"" + key);
  }
}","public void reset(String key) throws ReadOnlyException {
  if (isReadOnly(key)) {
    throw new ReadOnlyException(EXCEPTIONS.getString(""String_Node_Str"",""String_Node_Str""));
  }
  boolean resetDone=false;
  for (int i=0; !resetDone && i < defaultPreferences.length; i++) {
    if (key.equals(defaultPreferences[i].getName())) {
      if (LOG.isDebugEnabled()) {
        LOG.debug(""String_Node_Str"" + key);
      }
      preferences.put(key,(PortletPreference)defaultPreferences[i].clone());
      resetDone=true;
    }
  }
  if (!resetDone) {
    if (LOG.isDebugEnabled()) {
      LOG.debug(""String_Node_Str"" + key);
    }
    preferences.remove(key);
  }
}",0.8481764206955047
90713,"/** 
 * Returns the string representation of this object. Preferences are separated by ';' character, while values in one preference are separated by ',' character.
 * @return the string representation of this object.
 */
public String toString(){
  StringBuffer buffer=new StringBuffer(""String_Node_Str"");
  for (Enumeration en=getNames(); en.hasMoreElements(); ) {
    String name=(String)en.nextElement();
    buffer.append(name).append(""String_Node_Str"");
    String[] values=getValues(name,null);
    if (values != null) {
      for (int i=0; i < values.length; i++) {
        buffer.append(values[i]).append(""String_Node_Str"");
      }
    }
 else {
      buffer.append(""String_Node_Str"");
    }
    buffer.append(""String_Node_Str"");
    buffer.append(isReadOnly(name));
    buffer.append(""String_Node_Str"");
  }
  buffer.append(""String_Node_Str"");
  return buffer.toString();
}","/** 
 * Returns the string representation of this object. Preferences are separated by ';' character, while values in one preference are separated by ',' character.
 * @return the string representation of this object.
 */
public String toString(){
  StringBuffer buffer=new StringBuffer();
  buffer.append(getClass().getName()).append(""String_Node_Str"");
  for (Enumeration en=getNames(); en.hasMoreElements(); ) {
    String name=(String)en.nextElement();
    buffer.append(name).append(""String_Node_Str"");
    String[] values=getValues(name,null);
    if (values != null) {
      for (int i=0; i < values.length; i++) {
        buffer.append(values[i]).append(""String_Node_Str"");
      }
    }
 else {
      buffer.append(""String_Node_Str"");
    }
    buffer.append(""String_Node_Str"");
    buffer.append(isReadOnly(name));
    buffer.append(""String_Node_Str"");
  }
  buffer.append(""String_Node_Str"");
  return buffer.toString();
}",0.973568281938326
90714,"/** 
 * Retrieve an invoker for the specified PortletWindow.
 * @param window the InternalPortletWindow used for invocation
 * @return an invoker which can be used to service the indicated portlet
 */
PortletInvokerService getPortletInvokerService(InternalPortletWindow window);","/** 
 * Returns an invoker for the specified PortletWindow.
 * @param portletWindow  the InternalPortletWindow used for invocation.
 * @return an invoker which can be used to service the indicated portlet.
 */
PortletInvokerService getPortletInvokerService(InternalPortletWindow portletWindow);",0.93006993006993
90715,PortletPreferencesService getPortletPreferencesService();,"/** 
 * Returns the portlet preferences service implementation.
 * @return the portlet preferences service implementation.
 */
PortletPreferencesService getPortletPreferencesService();",0.4730290456431535
90716,"public PortletInvokerService getPortletInvokerService(InternalPortletWindow window){
  return null;
}","/** 
 * TODO:
 */
public PortletInvokerService getPortletInvokerService(InternalPortletWindow window){
  return null;
}",0.9181818181818182
90717,"public PortletEnvironmentService getPortletEnvironmentService(){
  return null;
}","/** 
 * TODO:
 */
public PortletEnvironmentService getPortletEnvironmentService(){
  return null;
}",0.9
90718,"public DefaultOptionalContainerServices(OptionalContainerServices root){
  this();
  if (root.getPortletPreferencesService() != null) {
    this.preferenceService=root.getPortletPreferencesService();
  }
}","/** 
 * Constructs an instance using specified optional container services implementation. If the portlet preferences service is provided, it will be used. Otherwise, the default portlet preferences service will be used.
 * @param root  the root optional container services implementation.
 */
public DefaultOptionalContainerServices(OptionalContainerServices root){
  if (root.getPortletPreferencesService() != null) {
    preferenceService=root.getPortletPreferencesService();
  }
 else {
    preferenceService=new DefaultPortletPreferencesService();
  }
}",0.3066841415465268
90719,String getName();,"/** 
 * Returns the name of this portlet preference.
 * @return the name of this portlet preference.
 */
public String getName();",0.2328767123287671
90720,boolean isReadOnly();,"/** 
 * Returns true if this portlet preference is marked as read-only.
 * @return true if this portlet preference is marked as read-only.
 */
public boolean isReadOnly();",0.21875
90721,String[] getValues();,"/** 
 * Returns the values of this portlet preference, which is a string array.
 * @return the values of this portlet preference as a string array.
 */
public String[] getValues();",0.208955223880597
90722,void setValues(String[] values);,"/** 
 * Sets values of this portlet preference.
 * @param values  values of this portlet preference to set.
 */
public void setValues(String[] values);",0.3497267759562841
90723,"private void load(){
  String context=window.getContextPath();
  if (LOG.isDebugEnabled()) {
    LOG.debug(""String_Node_Str"" + context);
  }
  ServletContext ctx=this.ctx.getContext(context);
  if (LOG.isDebugEnabled()) {
    LOG.debug(""String_Node_Str"" + ctx);
  }
  try {
    PortletAppDD appDD=PortletDescriptorRegistry.getRegistry().getPortletAppDD(ctx);
    Iterator dds=appDD.getPortlets().iterator();
    while (dds.hasNext()) {
      PortletDD pd=(PortletDD)dds.next();
      if (pd.getPortletName().equals(window.getPortletName())) {
        dd=pd;
      }
    }
  }
 catch (  PortletContainerException e) {
    String msg=""String_Node_Str"";
    LOG.error(msg,e);
    throw new NullPointerException(msg + e.getMessage());
  }
}","/** 
 * Loads the portlet definition.
 */
private void load(){
  String contextPath=portletWindow.getContextPath();
  if (LOG.isDebugEnabled()) {
    LOG.debug(""String_Node_Str"" + contextPath);
  }
  ServletContext crossContext=servletContext.getContext(contextPath);
  if (LOG.isDebugEnabled()) {
    LOG.debug(""String_Node_Str"" + crossContext);
  }
  try {
    PortletAppDD appDD=PortletDescriptorRegistry.getRegistry().getPortletAppDD(crossContext);
    for (Iterator it=appDD.getPortlets().iterator(); it.hasNext(); ) {
      PortletDD portletDD=(PortletDD)it.next();
      if (portletDD.getPortletName().equals(portletWindow.getPortletName())) {
        portletDefinition=portletDD;
        break;
      }
    }
  }
 catch (  PortletContainerException ex) {
    String message=""String_Node_Str"" + ex.getMessage();
    LOG.error(message,ex);
    throw new NullPointerException(message);
  }
}",0.7867647058823529
90724,"/** 
 * Returns the portlet description The return value cannot be NULL.
 * @return the portlet description
 */
public PortletDD getPortletDefinition(){
  if (dd == null) {
    load();
  }
  return dd;
}","/** 
 * Returns the portlet description. The return value cannot be NULL.
 * @return the portlet description.
 */
public PortletDD getPortletDefinition(){
  if (portletDefinition == null) {
    load();
  }
  return portletDefinition;
}",0.908675799086758
90725,"public String getControllerServletUri(){
  return PREFIX + window.getPortletName();
}","/** 
 * Returns the URI to the controller servlet that wraps this portlet.
 * @return the URI to the controller servlet that wraps this portlet.
 */
public String getControllerServletUri(){
  return PREFIX + portletWindow.getPortletName();
}",0.5153374233128835
90726,"/** 
 * Returns all preferences of this portlet The return value cannot be NULL.
 * @return the preference set
 */
public PortletPreference[] getDefaultPreferences(){
  if (prefs == null) {
    PortletDD dd=getPortletDefinition();
    PortletPreferencesDD ppdd=dd.getPortletPreferences();
    if (ppdd != null) {
      prefs=new PortletPreference[ppdd.getPortletPreferences().size()];
      Iterator pds=ppdd.getPortletPreferences().iterator();
      for (int i=0; pds.hasNext(); i++) {
        PortletPreferenceDD pd=(PortletPreferenceDD)pds.next();
        String[] values=(String[])pd.getValues().toArray(new String[pd.getValues().size()]);
        prefs[i]=new PortletPreferenceImpl(pd.getName(),values);
      }
    }
  }
  return prefs;
}","/** 
 * Returns all preferences of this portlet The return value cannot be NULL.
 * @return the preference set
 */
public PortletPreference[] getDefaultPreferences(){
  if (defaultPreferences == null) {
    PortletDD portletDD=getPortletDefinition();
    PortletPreferencesDD prefsDD=portletDD.getPortletPreferences();
    if (prefsDD != null) {
      List prefs=new ArrayList();
      for (Iterator it=prefsDD.getPortletPreferences().iterator(); it.hasNext(); ) {
        PortletPreferenceDD prefDD=(PortletPreferenceDD)it.next();
        String[] values=(String[])prefDD.getValues().toArray(new String[prefDD.getValues().size()]);
        PortletPreferenceImpl pref=new PortletPreferenceImpl(prefDD.getName(),values,prefDD.isReadOnly());
        prefs.add(pref);
      }
      defaultPreferences=(PortletPreference[])prefs.toArray(new PortletPreference[prefs.size()]);
    }
  }
  return defaultPreferences;
}",0.6815709969788519
90727,"PortletEntity(ServletContext ctx,PortletWindow window){
  this.ctx=ctx;
  this.window=window;
}","PortletEntity(ServletContext servletContext,PortletWindow portletWindow){
  this.servletContext=servletContext;
  this.portletWindow=portletWindow;
}",0.7295081967213115
90728,"/** 
 * Override of toString() that prints out  name and values of fields.
 * @see java.lang.Object#toString()
 */
public String toString(){
  StringBuffer buffer=new StringBuffer();
  buffer.append(getClass().getName());
  buffer.append(""String_Node_Str"");
  buffer.append(""String_Node_Str"" + name + ""String_Node_Str"");
  for (int i=0; i < values.length; i++) {
    buffer.append(""String_Node_Str"" + i + ""String_Node_Str""+ values[i]);
  }
  buffer.append(""String_Node_Str"");
  buffer.append(""String_Node_Str"" + readOnly);
  buffer.append(""String_Node_Str"");
  return buffer.toString();
}","/** 
 * Override of toString() that prints out name and values of fields.
 * @see java.lang.Object#toString()
 */
public String toString(){
  StringBuffer buffer=new StringBuffer();
  buffer.append(getClass().getName());
  buffer.append(""String_Node_Str"").append(name).append(""String_Node_Str"");
  if (values != null) {
    for (int i=0; i < values.length; i++) {
      buffer.append(""String_Node_Str"").append(i).append(""String_Node_Str"").append(values[i]).append(""String_Node_Str"");
    }
  }
 else {
    buffer.append(""String_Node_Str"");
  }
  buffer.append(""String_Node_Str"").append(readOnly).append(""String_Node_Str"");
  return buffer.toString();
}",0.6241935483870967
90729,"/** 
 * Returns the string representation of this object. Preferences are separated by ';' character, while values in one preference are separated by ',' character.
 * @return the string representation of this object.
 */
public String toString(){
  StringBuffer buffer=new StringBuffer();
  buffer.append(getClass().getName()).append(""String_Node_Str"");
  for (Enumeration en=getNames(); en.hasMoreElements(); ) {
    String name=(String)en.nextElement();
    buffer.append(name).append(""String_Node_Str"");
    String[] values=getValues(name,null);
    if (values != null) {
      for (int i=0; i < values.length; i++) {
        buffer.append(values[i]).append(""String_Node_Str"");
      }
    }
 else {
      buffer.append(""String_Node_Str"");
    }
    buffer.append(""String_Node_Str"");
    buffer.append(isReadOnly(name));
    buffer.append(""String_Node_Str"");
  }
  buffer.append(""String_Node_Str"");
  return buffer.toString();
}","/** 
 * Returns the string representation of this object. Preferences are separated by ';' character, while values in one preference are separated by ',' character.
 * @return the string representation of this object.
 * @see java.lang.Object#toString()
 */
public String toString(){
  StringBuffer buffer=new StringBuffer();
  buffer.append(getClass().getName()).append(""String_Node_Str"");
  for (Enumeration en=getNames(); en.hasMoreElements(); ) {
    String name=(String)en.nextElement();
    buffer.append(name);
    buffer.append(""String_Node_Str"").append(isReadOnly(name)).append(""String_Node_Str"");
    String[] values=getValues(name,null);
    if (values != null) {
      for (int i=0; i < values.length; i++) {
        buffer.append(values[i]);
        if (i < values.length - 1) {
          buffer.append(""String_Node_Str"");
        }
      }
    }
 else {
      buffer.append(""String_Node_Str"");
    }
    buffer.append(""String_Node_Str"");
  }
  buffer.append(""String_Node_Str"");
  return buffer.toString();
}",0.8489503328213006
90730,"private boolean isPortletModeAllowedByPortlet(PortletMode mode){
  PortletDD dd=internalPortletWindow.getPortletEntity().getPortletDefinition();
  Iterator mimes=dd.getSupports().iterator();
  while (mimes.hasNext()) {
    Iterator modes=((SupportsDD)mimes.next()).getPortletModes().iterator();
    while (modes.hasNext()) {
      String m=(String)modes.next();
      if (m.equals(mode.toString())) {
        return true;
      }
    }
  }
  return false;
}","private boolean isPortletModeAllowedByPortlet(PortletMode mode){
  if (isPortletModeMandatory(mode)) {
    return true;
  }
  PortletDD dd=internalPortletWindow.getPortletEntity().getPortletDefinition();
  Iterator mimes=dd.getSupports().iterator();
  while (mimes.hasNext()) {
    Iterator modes=((SupportsDD)mimes.next()).getPortletModes().iterator();
    while (modes.hasNext()) {
      String m=(String)modes.next();
      if (m.equals(mode.toString())) {
        return true;
      }
    }
  }
  return false;
}",0.9393627954779034
90731,"public PortletContainer createContainer(String containerName,PortletContainerServices services,OptionalPortletContainerServices optionalServices){
  ArgumentUtility.validateNotNull(""String_Node_Str"",services);
  ArgumentUtility.validateNotEmpty(""String_Node_Str"",containerName);
  PortletContainer container=new PortletContainerImpl(containerName,services,optionalServices);
  if (LOG.isInfoEnabled()) {
    LOG.info(""String_Node_Str"" + containerName + ""String_Node_Str"");
  }
  return container;
}","public PortletContainer createContainer(String containerName,PortletContainerServices services,OptionalPortletContainerServices optionalServices){
  ArgumentUtility.validateNotNull(""String_Node_Str"",services);
  ArgumentUtility.validateNotEmpty(""String_Node_Str"",containerName);
  DefaultOptionalServices optional=new DefaultOptionalServices(optionalServices);
  PortletContainer container=new PortletContainerImpl(containerName,services,optional);
  if (LOG.isInfoEnabled()) {
    LOG.info(""String_Node_Str"" + containerName + ""String_Node_Str"");
  }
  return container;
}",0.9158878504672896
90732,"public boolean isRequestedSessionIdValid(){
  return this.getHttpServletRequest().isRequestedSessionIdValid();
}","public boolean isRequestedSessionIdValid(){
  return getHttpServletRequest().isRequestedSessionIdValid();
}",0.9771689497716894
90733,"public String toString(PortalURL url){
  StringBuffer sb=new StringBuffer();
  sb.append(url.getServerUri()).append(url.getControllerPath());
  if (url.getRenderPath() != null) {
    sb.append(""String_Node_Str"");
    sb.append(url.getRenderPath());
  }
  if (url.getActionWindow() != null) {
    sb.append(""String_Node_Str"");
    sb.append(PREFIX).append(ACTION).append(encode(url.getActionWindow()));
  }
  Iterator it=url.getPortletModes().entrySet().iterator();
  while (it.hasNext()) {
    Map.Entry entry=(Map.Entry)it.next();
    sb.append(""String_Node_Str"").append(encode(PORTLET_MODE,entry.getKey().toString(),entry.getValue().toString()));
  }
  it=url.getWindowStates().entrySet().iterator();
  while (it.hasNext()) {
    Map.Entry entry=(Map.Entry)it.next();
    sb.append(""String_Node_Str"").append(encode(WINDOW_STATE,entry.getKey().toString(),entry.getValue().toString()));
  }
  StringBuffer query=new StringBuffer(""String_Node_Str"");
  it=url.getParameters().iterator();
  while (it.hasNext()) {
    PortalUrlParameter param=(PortalUrlParameter)it.next();
    if (url.getActionWindow() != null && url.getActionWindow().equals(param.getWindowId())) {
      query.append(""String_Node_Str"").append(param.getName()).append(""String_Node_Str"").append(convert(param.getValues()));
    }
 else     if (param.getValues() != null && param.getValues().length > 0) {
      String valueString=encode(param.getValues());
      if (valueString.length() > 0) {
        sb.append(""String_Node_Str"").append(encode(RENDER_PARAM,param.getWindowId(),param.getName()));
        sb.append(""String_Node_Str"").append(valueString);
      }
    }
  }
  return sb.append(query).toString();
}","public String toString(PortalURL url){
  StringBuffer sb=new StringBuffer();
  sb.append(url.getServerUri()).append(url.getControllerPath());
  if (url.getRenderPath() != null) {
    sb.append(""String_Node_Str"");
    sb.append(url.getRenderPath());
  }
  if (url.getActionWindow() != null) {
    sb.append(""String_Node_Str"");
    sb.append(PREFIX).append(ACTION).append(encode(url.getActionWindow()));
  }
  Iterator it=url.getPortletModes().entrySet().iterator();
  while (it.hasNext()) {
    Map.Entry entry=(Map.Entry)it.next();
    sb.append(""String_Node_Str"").append(encode(PORTLET_MODE,entry.getKey().toString(),entry.getValue().toString()));
  }
  it=url.getWindowStates().entrySet().iterator();
  while (it.hasNext()) {
    Map.Entry entry=(Map.Entry)it.next();
    sb.append(""String_Node_Str"").append(encode(WINDOW_STATE,entry.getKey().toString(),entry.getValue().toString()));
  }
  StringBuffer query=new StringBuffer(""String_Node_Str"");
  it=url.getParameters().iterator();
  while (it.hasNext()) {
    PortalUrlParameter param=(PortalUrlParameter)it.next();
    if (url.getActionWindow() != null && url.getActionWindow().equals(param.getWindowId())) {
      for (int i=0; i < param.getValues().length; i++) {
        query.append(""String_Node_Str"").append(param.getName()).append(""String_Node_Str"").append(param.getValues()[i]);
      }
    }
 else     if (param.getValues() != null && param.getValues().length > 0) {
      String valueString=encode(param.getValues());
      if (valueString.length() > 0) {
        sb.append(""String_Node_Str"").append(encode(RENDER_PARAM,param.getWindowId(),param.getName()));
        sb.append(""String_Node_Str"").append(valueString);
      }
    }
  }
  return sb.append(query).toString();
}",0.9757096868598184
90734,"public PortalURL parse(HttpServletRequest req){
  String protocol=req.isSecure() ? ""String_Node_Str"" : ""String_Node_Str"";
  String server=req.getServerName();
  int port=req.getServerPort();
  PortalURL url;
  if ((req.isSecure() && port != 443) || (!req.isSecure() && port != 80)) {
    url=new PortalURL(protocol,server,port);
  }
 else {
    url=new PortalURL(protocol,server);
  }
  url.setControllerPath(req.getContextPath(),req.getServletPath());
  StringBuffer renderPath=new StringBuffer();
  if (req.getPathInfo() == null) {
    return url;
  }
  StringTokenizer st=new StringTokenizer(req.getPathInfo(),""String_Node_Str"",false);
  while (st.hasMoreTokens()) {
    String token=st.nextToken();
    if (!token.startsWith(PREFIX)) {
      renderPath.append(token);
    }
 else     if (token.startsWith(PREFIX + ACTION)) {
      url.setActionWindow(decode(token)[0]);
    }
 else     if (token.startsWith(PREFIX + WINDOW_STATE)) {
      String[] decoded=decode(token);
      url.setWindowState(decoded[0],new WindowState(decoded[1]));
    }
 else     if (token.startsWith(PREFIX + PORTLET_MODE)) {
      String[] decoded=decode(token);
      url.setPortletMode(decoded[0],new PortletMode(decoded[1]));
    }
 else {
      String value=null;
      if (st.hasMoreTokens()) {
        value=st.nextToken();
      }
      url.addParameter(decode(token,value));
    }
  }
  if (renderPath.length() > 0) {
    url.setRenderPath(renderPath.toString());
  }
  return url;
}","public PortalURL parse(HttpServletRequest req){
  if (LOG.isDebugEnabled()) {
    LOG.debug(""String_Node_Str"" + req.getRequestURI());
  }
  String protocol=req.isSecure() ? ""String_Node_Str"" : ""String_Node_Str"";
  String server=req.getServerName();
  int port=req.getServerPort();
  PortalURL url;
  if ((req.isSecure() && port != 443) || (!req.isSecure() && port != 80)) {
    url=new PortalURL(protocol,server,port);
  }
 else {
    url=new PortalURL(protocol,server);
  }
  url.setControllerPath(req.getContextPath(),req.getServletPath());
  if (LOG.isDebugEnabled()) {
    LOG.debug(""String_Node_Str"" + req.getPathInfo());
  }
  StringBuffer renderPath=new StringBuffer();
  if (req.getPathInfo() == null) {
    return url;
  }
  StringTokenizer st=new StringTokenizer(req.getPathInfo(),""String_Node_Str"",false);
  while (st.hasMoreTokens()) {
    String token=st.nextToken();
    if (!token.startsWith(PREFIX)) {
      renderPath.append(token);
    }
 else     if (token.startsWith(PREFIX + ACTION)) {
      url.setActionWindow(decode(token)[0]);
    }
 else     if (token.startsWith(PREFIX + WINDOW_STATE)) {
      String[] decoded=decode(token);
      url.setWindowState(decoded[0],new WindowState(decoded[1]));
    }
 else     if (token.startsWith(PREFIX + PORTLET_MODE)) {
      String[] decoded=decode(token);
      url.setPortletMode(decoded[0],new PortletMode(decoded[1]));
    }
 else {
      String value=null;
      if (st.hasMoreTokens()) {
        value=st.nextToken();
      }
      url.addParameter(decode(token,value));
    }
  }
  if (renderPath.length() > 0) {
    url.setRenderPath(renderPath.toString());
  }
  return url;
}",0.9429121231558693
90735,"/** 
 * Decode a parameter
 * @param name
 * @param value
 * @return url parameter
 */
private PortalUrlParameter decode(String name,String value){
  String nopre=name.substring((PREFIX + PORTLET_ID).length());
  String windowId=nopre.substring(0,nopre.indexOf(DELIM));
  String param=nopre.substring(nopre.indexOf(DELIM) + 1);
  ArrayList values=new ArrayList();
  for (int i=0; i < ENCODINGS.length; i++) {
    windowId=StringUtils.replace(windowId,ENCODINGS[i][1],ENCODINGS[i][0]);
    if (value != null) {
      value=StringUtils.replace(value,ENCODINGS[i][1],ENCODINGS[i][0]);
    }
    int idx, start=0;
    while ((idx=value.indexOf(VALUE_DELIM,start)) > 0) {
      values.add(value.substring(start,idx));
      start=idx;
    }
  }
  String[] vals=values.size() > 0 ? (String[])values.toArray(new String[values.size()]) : new String[]{value};
  return new PortalUrlParameter(windowId,param,vals);
}","/** 
 * Decode a parameter
 * @param name
 * @param value
 * @return url parameter
 */
private PortalUrlParameter decode(String name,String value){
  if (LOG.isDebugEnabled()) {
    LOG.debug(""String_Node_Str"" + name + ""String_Node_Str""+ value+ ""String_Node_Str"");
  }
  String nopre=name.substring((PREFIX + PORTLET_ID).length());
  String windowId=nopre.substring(0,nopre.indexOf(DELIM));
  String param=nopre.substring(nopre.indexOf(DELIM) + 1);
  ArrayList values=new ArrayList();
  for (int i=0; i < ENCODINGS.length; i++) {
    windowId=StringUtils.replace(windowId,ENCODINGS[i][1],ENCODINGS[i][0]);
    if (value != null) {
      value=StringUtils.replace(value,ENCODINGS[i][1],ENCODINGS[i][0]);
    }
    StringTokenizer st=new StringTokenizer(value,VALUE_DELIM,false);
    while (st.hasMoreTokens()) {
      values.add(st.nextToken());
    }
  }
  String[] vals=(String[])values.toArray(new String[values.size()]);
  return new PortalUrlParameter(windowId,param,vals);
}",0.6663129973474801
90736,"public ResourceBundle getResourceBundle(java.util.Locale locale){
  if (bundles == null) {
    bundles=new ResourceBundleFactory(portletDD);
  }
  return bundles.getResourceBundle(locale);
}","public ResourceBundle getResourceBundle(Locale locale){
  if (LOG.isDebugEnabled()) {
    LOG.debug(""String_Node_Str"" + locale);
  }
  if (bundles == null) {
    bundles=new ResourceBundleFactory(portletDD);
  }
  return bundles.getResourceBundle(locale);
}",0.7472035794183445
90737,"public ResourceBundleFactory(PortletDD dd){
  bundleName=dd.getResourceBundle();
  PortletInfoDD info=dd.getPortletInfo();
  if (info != null) {
    defaultBundle=createDefaultBundle(info.getTitle(),info.getShortTitle(),info.getKeywords());
  }
 else {
    defaultBundle=EMPTY_BUNDLE;
  }
}","public ResourceBundleFactory(PortletDD dd){
  bundleName=dd.getResourceBundle();
  if (LOG.isDebugEnabled()) {
    LOG.debug(""String_Node_Str"" + bundleName);
  }
  PortletInfoDD info=dd.getPortletInfo();
  if (info != null) {
    defaultBundle=new InlinePortletResourceBundle(info.getTitle(),info.getShortTitle(),info.getKeywords());
  }
 else {
    defaultBundle=new InlinePortletResourceBundle(new Object[][]{{""String_Node_Str"",""String_Node_Str""}});
  }
}",0.714859437751004
90738,"public ResourceBundle getResourceBundle(Locale locale){
  if (bundles.containsKey(locale)) {
    return (ResourceBundle)bundles.get(locale);
  }
  try {
    if (bundleName != null) {
      ClassLoader loader=Thread.currentThread().getContextClassLoader();
      ResourceBundle bundle=ResourceBundle.getBundle(bundleName,locale,loader);
      if (bundle != null) {
        bundles.put(locale,bundle);
        return bundle;
      }
    }
  }
 catch (  MissingResourceException mre) {
    LOG.info(EXCEPTIONS.getString(""String_Node_Str"",bundleName,mre.getMessage()));
  }
  bundles.put(locale,defaultBundle);
  return defaultBundle;
}","public ResourceBundle getResourceBundle(Locale locale){
  if (LOG.isDebugEnabled()) {
    LOG.debug(""String_Node_Str"" + bundleName + ""String_Node_Str""+ locale+ ""String_Node_Str"");
  }
  if (bundles.containsKey(locale)) {
    return (ResourceBundle)bundles.get(locale);
  }
  try {
    ResourceBundle bundle=null;
    if (bundleName != null) {
      ClassLoader loader=Thread.currentThread().getContextClassLoader();
      bundle=ResourceBundle.getBundle(bundleName,locale,loader);
      bundles.put(locale,new CombinedPortletResourceBundle(defaultBundle,bundle));
    }
 else {
      bundles.put(locale,defaultBundle);
    }
  }
 catch (  MissingResourceException mre) {
    if (bundleName != null && LOG.isWarnEnabled()) {
      LOG.info(EXCEPTIONS.getString(""String_Node_Str"",bundleName,mre.getMessage()));
    }
    if (LOG.isDebugEnabled()) {
      LOG.debug(""String_Node_Str"" + locale + ""String_Node_Str"");
    }
    bundles.put(locale,defaultBundle);
  }
  return (ResourceBundle)bundles.get(locale);
}",0.5829268292682926
90739,"public void testGetResourceBundleNoBundleNullValues(){
  validDD.setResourceBundle(null);
  validDD.getPortletInfo().setTitle(null);
  validDD.getPortletInfo().setShortTitle(null);
  validDD.getPortletInfo().setKeywords(null);
  ResourceBundleFactory factory=new ResourceBundleFactory(validDD);
  ResourceBundle bundle=factory.getResourceBundle(Locale.getDefault());
  Assert.assertEquals(""String_Node_Str"",bundle.getString(""String_Node_Str""));
  Assert.assertEquals(""String_Node_Str"",bundle.getString(""String_Node_Str""));
  Assert.assertEquals(""String_Node_Str"",bundle.getString(""String_Node_Str""));
}","public void testGetResourceBundleNoBundleNullValues(){
  validDD.setResourceBundle(null);
  validDD.getPortletInfo().setTitle(null);
  validDD.getPortletInfo().setShortTitle(null);
  validDD.getPortletInfo().setKeywords(null);
  ResourceBundleFactory factory=new ResourceBundleFactory(validDD);
  ResourceBundle bundle=factory.getResourceBundle(Locale.getDefault());
  try {
    Assert.assertEquals(null,bundle.getString(""String_Node_Str""));
    fail(""String_Node_Str"");
  }
 catch (  Throwable t) {
  }
  try {
    Assert.assertEquals(null,bundle.getString(""String_Node_Str""));
    fail(""String_Node_Str"");
  }
 catch (  Throwable t) {
  }
  try {
    Assert.assertEquals(null,bundle.getString(""String_Node_Str""));
    fail(""String_Node_Str"");
  }
 catch (  Throwable t) {
  }
}",0.7979724837074583
90740,"public boolean isRequestedSessionIdValid(){
  return getHttpServletRequest().isRequestedSessionIdValid();
}","public boolean isRequestedSessionIdValid(){
  if (LOG.isDebugEnabled()) {
    LOG.debug(""String_Node_Str"" + getHttpServletRequest().isRequestedSessionIdValid());
  }
  return getHttpServletRequest().isRequestedSessionIdValid();
}",0.6011904761904762
90741,"/** 
 * Decode a parameter
 * @param name
 * @param value
 * @return url parameter
 */
private PortalUrlParameter decode(String name,String value){
  if (LOG.isDebugEnabled()) {
    LOG.debug(""String_Node_Str"" + name + ""String_Node_Str""+ value+ ""String_Node_Str"");
  }
  String nopre=name.substring((PREFIX + PORTLET_ID).length());
  String windowId=nopre.substring(0,nopre.indexOf(DELIM));
  String param=nopre.substring(nopre.indexOf(DELIM) + 1);
  ArrayList values=new ArrayList();
  for (int i=0; i < ENCODINGS.length; i++) {
    windowId=StringUtils.replace(windowId,ENCODINGS[i][1],ENCODINGS[i][0]);
    if (value != null) {
      value=StringUtils.replace(value,ENCODINGS[i][1],ENCODINGS[i][0]);
    }
    StringTokenizer st=new StringTokenizer(value,VALUE_DELIM,false);
    while (st.hasMoreTokens()) {
      values.add(st.nextToken());
    }
  }
  String[] vals=(String[])values.toArray(new String[values.size()]);
  return new PortalUrlParameter(windowId,param,vals);
}","/** 
 * Decode a parameter
 * @param name
 * @param value
 * @return url parameter
 */
private PortalUrlParameter decode(String name,String value){
  if (LOG.isDebugEnabled()) {
    LOG.debug(""String_Node_Str"" + name + ""String_Node_Str""+ value+ ""String_Node_Str"");
  }
  String nopre=name.substring((PREFIX + PORTLET_ID).length());
  String windowId=nopre.substring(0,nopre.indexOf(DELIM));
  String param=nopre.substring(nopre.indexOf(DELIM) + 1);
  ArrayList values=new ArrayList();
  for (int i=0; i < ENCODINGS.length; i++) {
    windowId=StringUtils.replace(windowId,ENCODINGS[i][1],ENCODINGS[i][0]);
    if (value != null) {
      value=StringUtils.replace(value,ENCODINGS[i][1],ENCODINGS[i][0]);
    }
  }
  StringTokenizer st=new StringTokenizer(value,VALUE_DELIM,false);
  while (st.hasMoreTokens()) {
    values.add(st.nextToken());
  }
  String[] vals=(String[])values.toArray(new String[values.size()]);
  return new PortalUrlParameter(windowId,param,vals);
}",0.8697435897435898
90742,"public EmbeddedDataSourceManager(String systemDirectory,String connectionString){
  this.connectionString=connectionString;
  System.setProperty(""String_Node_Str"",systemDirectory);
  if (LOG.isDebugEnabled()) {
    LOG.debug(""String_Node_Str"" + systemDirectory);
  }
}","public EmbeddedDataSourceManager(File systemDirectory,String connectionString){
  this.connectionString=connectionString;
  LOG.debug(""String_Node_Str"" + DEFAULT_SYS_DIR);
  LOG.debug(""String_Node_Str"" + systemDirectory);
  LOG.debug(""String_Node_Str"" + connectionString);
  System.setProperty(""String_Node_Str"",systemDirectory.getAbsolutePath());
  if (LOG.isDebugEnabled()) {
    File sysDir=systemDirectory;
    LOG.debug(""String_Node_Str"" + System.getProperty(""String_Node_Str""));
    LOG.debug(""String_Node_Str"" + sysDir.getAbsolutePath());
  }
}",0.4395604395604395
90743,"/** 
 * Updates web.xml with servlet and servlet-mapping records related to PortletServlet.
 * @param context
 */
void updateWebXml(String context){
  final String[] PRIOR_ELEMENTS_SERVLET={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  final String[] PRIOR_ELEMENTS_SERVLET_MAPPING={""String_Node_Str"",""String_Node_Str""};
  String webapps=PlutoAdminContext.getDeploymentPath();
  File webXml=new File(webapps + PlutoAdminConstants.FS + context+ PlutoAdminConstants.FS+ ""String_Node_Str""+ PlutoAdminConstants.FS+ ""String_Node_Str"");
  DeployWarService svc=new DeployWarService();
  String contents=svc.readFileToString(webXml);
  File portletXml=new File(webapps + PlutoAdminConstants.FS + context+ PlutoAdminConstants.FS+ ""String_Node_Str""+ PlutoAdminConstants.FS+ ""String_Node_Str"");
  List plist=null;
  try {
    InputStream ins=new FileInputStream(portletXml);
    PortletConfigService pcsvc=new PortletConfigService(ins);
    plist=pcsvc.getPortletDDList();
  }
 catch (  FileNotFoundException e) {
    e.printStackTrace();
  }
  String newWebXml=svc.addRecordsToWebXml(context,contents,PRIOR_ELEMENTS_SERVLET,plist);
  contents=newWebXml;
  newWebXml=svc.addRecordsToWebXml(context,contents,PRIOR_ELEMENTS_SERVLET_MAPPING,plist);
  System.out.println(newWebXml);
  writeStringToFile(webXml,newWebXml);
}","/** 
 * Updates web.xml with servlet and servlet-mapping records related to PortletServlet.
 * @param context
 */
void updateWebXml(String context){
  String METHOD_NAME=""String_Node_Str"";
  final String[] PRIOR_ELEMENTS_SERVLET={""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str"",""String_Node_Str""};
  final String[] PRIOR_ELEMENTS_SERVLET_MAPPING={""String_Node_Str"",""String_Node_Str""};
  String webapps=PlutoAdminContext.getDeploymentPath();
  File webXml=new File(webapps + PlutoAdminConstants.FS + context+ PlutoAdminConstants.FS+ ""String_Node_Str""+ PlutoAdminConstants.FS+ ""String_Node_Str"");
  DeployWarService svc=new DeployWarService();
  String contents=svc.readFileToString(webXml);
  File portletXml=new File(webapps + PlutoAdminConstants.FS + context+ PlutoAdminConstants.FS+ ""String_Node_Str""+ PlutoAdminConstants.FS+ ""String_Node_Str"");
  List plist=null;
  try {
    InputStream ins=new FileInputStream(portletXml);
    PortletConfigService pcsvc=new PortletConfigService(ins);
    plist=pcsvc.getPortletDDList();
  }
 catch (  FileNotFoundException e) {
    logError(METHOD_NAME,e);
    throw new PlutoAdminException(e);
  }
  String newWebXml=svc.addRecordsToWebXml(context,contents,PRIOR_ELEMENTS_SERVLET,plist);
  contents=newWebXml;
  newWebXml=svc.addRecordsToWebXml(context,contents,PRIOR_ELEMENTS_SERVLET_MAPPING,plist);
  writeStringToFile(webXml,newWebXml);
}",0.9343760625637538
90744,"/** 
 * Gets the web.xml servlet-mapping record for PortletServlet from portlet.xml data
 * @param portletData Data from portlet.xml
 */
private String getServletMappingRecord(PortletDD portletData){
  StringBuffer record=new StringBuffer();
  record.append(""String_Node_Str"" + PlutoAdminConstants.LS);
  record.append(""String_Node_Str"" + portletData.getPortletName() + ""String_Node_Str""+ PlutoAdminConstants.LS);
  record.append(""String_Node_Str"" + portletData.getPortletName() + ""String_Node_Str""+ PlutoAdminConstants.LS);
  record.append(""String_Node_Str"" + PlutoAdminConstants.LS);
  return record.toString();
}","/** 
 * Gets the web.xml servlet-mapping record for PortletServlet from portlet.xml data
 * @param context Context name
 * @param portletData Data from portlet.xml
 * @return
 */
private String getServletMappingRecord(PortletDD portletData){
  StringBuffer record=new StringBuffer();
  record.append(""String_Node_Str"" + PlutoAdminConstants.LS);
  record.append(""String_Node_Str"" + portletData.getPortletName() + ""String_Node_Str""+ PlutoAdminConstants.LS);
  record.append(""String_Node_Str"" + portletData.getPortletName() + ""String_Node_Str""+ PlutoAdminConstants.LS);
  record.append(""String_Node_Str"" + PlutoAdminConstants.LS);
  return record.toString();
}",0.9669811320754716
90745,"public String readFileToString(File file){
  final String METHOD_NAME=""String_Node_Str"";
  String contents=null;
  FileInputStream fis=null;
  try {
    fis=new FileInputStream(file);
    int c;
    char b;
    StringBuffer sb=new StringBuffer();
    while ((c=fis.read()) != -1) {
      b=(char)c;
      sb.append(b);
    }
    contents=sb.toString().trim();
  }
 catch (  FileNotFoundException e) {
    logError(METHOD_NAME,e);
    throw new PlutoAdminException(e);
  }
catch (  IOException e) {
    logError(METHOD_NAME,e);
    throw new PlutoAdminException(e);
  }
 finally {
    if (fis != null) {
      try {
        fis.close();
      }
 catch (      IOException e) {
        logError(METHOD_NAME,e);
        throw new PlutoAdminException(e);
      }
    }
  }
  return contents;
}","/** 
 * Puts the contents of a file into a String. This only works with text files.
 * @param file The File to read
 * @return A String containing the contents of the file.
 */
public String readFileToString(File file){
  final String METHOD_NAME=""String_Node_Str"";
  String contents=null;
  FileInputStream fis=null;
  try {
    fis=new FileInputStream(file);
    int c;
    char b;
    StringBuffer sb=new StringBuffer();
    while ((c=fis.read()) != -1) {
      b=(char)c;
      sb.append(b);
    }
    contents=sb.toString().trim();
  }
 catch (  FileNotFoundException e) {
    logError(METHOD_NAME,e);
    throw new PlutoAdminException(e);
  }
catch (  IOException e) {
    logError(METHOD_NAME,e);
    throw new PlutoAdminException(e);
  }
 finally {
    if (fis != null) {
      try {
        fis.close();
      }
 catch (      IOException e) {
        logError(METHOD_NAME,e);
        throw new PlutoAdminException(e);
      }
    }
  }
  return contents;
}",0.899030233884769
90746,"public void writeStringToFile(File file,String contents){
  final String METHOD_NAME=""String_Node_Str"";
  FileOutputStream fos=null;
  try {
    fos=new FileOutputStream(file);
    byte[] bytes=contents.getBytes();
    fos.write(bytes);
  }
 catch (  FileNotFoundException e) {
    logError(METHOD_NAME,e);
    throw new PlutoAdminException(e);
  }
catch (  IOException e) {
    logError(METHOD_NAME,e);
    throw new PlutoAdminException(e);
  }
 finally {
    if (fos != null) {
      try {
        fos.close();
      }
 catch (      IOException e) {
        logError(METHOD_NAME,e);
        throw new PlutoAdminException(e);
      }
    }
  }
}","/** 
 * Writes the contents of a file into a String.
 * @param file Te File to write.
 * @param contents The String to add to the file.
 */
public void writeStringToFile(File file,String contents){
  final String METHOD_NAME=""String_Node_Str"";
  FileOutputStream fos=null;
  try {
    fos=new FileOutputStream(file);
    byte[] bytes=contents.getBytes();
    fos.write(bytes);
  }
 catch (  FileNotFoundException e) {
    logError(METHOD_NAME,e);
    throw new PlutoAdminException(e);
  }
catch (  IOException e) {
    logError(METHOD_NAME,e);
    throw new PlutoAdminException(e);
  }
 finally {
    if (fos != null) {
      try {
        fos.close();
      }
 catch (      IOException e) {
        logError(METHOD_NAME,e);
        throw new PlutoAdminException(e);
      }
    }
  }
}",0.9022346368715084
90747,"/** 
 * Gets the web.xml servlet record for PortletServlet from portlet.xml data
 * @param context Context name
 * @param portletData Data from portlet.xml
 * @return The servlet record
 */
private String getServletRecord(String context,PortletDD portletData){
  StringBuffer record=new StringBuffer();
  record.append(""String_Node_Str"" + PlutoAdminConstants.LS);
  record.append(""String_Node_Str"" + portletData.getPortletName() + ""String_Node_Str""+ PlutoAdminConstants.LS);
  record.append(""String_Node_Str"" + portletData.getPortletName() + ""String_Node_Str""+ PlutoAdminConstants.LS);
  record.append(""String_Node_Str"" + PlutoAdminConstants.LS);
  record.append(""String_Node_Str"" + PlutoAdminConstants.LS);
  record.append(""String_Node_Str"" + PlutoAdminConstants.LS);
  record.append(""String_Node_Str"" + PlutoAdminConstants.LS);
  record.append(""String_Node_Str"" + context + ""String_Node_Str""+ portletData.getPortletName()+ ""String_Node_Str""+ PlutoAdminConstants.LS);
  record.append(""String_Node_Str"" + PlutoAdminConstants.LS);
  record.append(""String_Node_Str"" + PlutoAdminConstants.LS);
  record.append(""String_Node_Str"" + PlutoAdminConstants.LS);
  record.append(""String_Node_Str"" + portletData.getPortletClass() + ""String_Node_Str""+ PlutoAdminConstants.LS);
  record.append(""String_Node_Str"" + PlutoAdminConstants.LS);
  String securityRef=getSecurityRoleRefRecord(context,portletData);
  if (securityRef != null && !securityRef.equals(""String_Node_Str"")) {
    record.append(securityRef);
  }
  record.append(""String_Node_Str"" + PlutoAdminConstants.LS);
  return record.toString();
}","/** 
 * Gets the web.xml servlet record for PortletServlet from portlet.xml data
 * @param context Context name
 * @param portletData Data from portlet.xml
 * @return
 */
private String getServletRecord(String context,PortletDD portletData){
  StringBuffer record=new StringBuffer();
  record.append(""String_Node_Str"" + PlutoAdminConstants.LS);
  record.append(""String_Node_Str"" + portletData.getPortletName() + ""String_Node_Str""+ PlutoAdminConstants.LS);
  record.append(""String_Node_Str"" + portletData.getPortletName() + ""String_Node_Str""+ PlutoAdminConstants.LS);
  record.append(""String_Node_Str"" + PlutoAdminConstants.LS);
  record.append(""String_Node_Str"" + PlutoAdminConstants.LS);
  record.append(""String_Node_Str"" + PlutoAdminConstants.LS);
  record.append(""String_Node_Str"" + PlutoAdminConstants.LS);
  record.append(""String_Node_Str"" + context + ""String_Node_Str""+ portletData.getPortletName()+ ""String_Node_Str""+ PlutoAdminConstants.LS);
  record.append(""String_Node_Str"" + PlutoAdminConstants.LS);
  record.append(""String_Node_Str"" + PlutoAdminConstants.LS);
  record.append(""String_Node_Str"" + PlutoAdminConstants.LS);
  record.append(""String_Node_Str"" + portletData.getPortletClass() + ""String_Node_Str""+ PlutoAdminConstants.LS);
  record.append(""String_Node_Str"" + PlutoAdminConstants.LS);
  String securityRef=getSecurityRoleRefRecord(context,portletData);
  if (securityRef != null && !securityRef.equals(""String_Node_Str"")) {
    record.append(securityRef);
  }
  record.append(""String_Node_Str"" + PlutoAdminConstants.LS);
  return record.toString();
}",0.993989243910155
90748,"/** 
 * Adds ServletPortlet servlet or servlet-mapping records to web.xml  for new portlet deployment.
 * @param context Web context or directory under webapps
 * @param contents Current contents of the web.xml file
 * @param elements Elements in web.xml to search for. If found, newelements will be inserted to the contents String. NOTE: First element (elements[0] signals the kind of record to add (servlet or servlet-mapping).
 * @param portletData List of portlet names in order that they appear in portlet.xml TODO: Add security-role-ref param for servlet record
 */
String addRecordsToWebXml(String context,String contents,String[] elements,List portletData){
  StringBuffer results=new StringBuffer(contents);
  int index=-1;
  int len=portletData.size();
  int lenElements=elements.length;
  String before=null;
  String newRecord=null;
  String remainder=null;
  for (int i=0; i < len; i++) {
    for (int j=0; j < lenElements; j++) {
      if ((index=results.lastIndexOf(""String_Node_Str"" + elements[j] + ""String_Node_Str"")) != -1) {
        int elementLen=elements[j].length() + 3;
        if (i == 0 & elements[j].equals(""String_Node_Str"")) {
          index=results.indexOf(""String_Node_Str"" + elements[j] + ""String_Node_Str"");
          elementLen=elements[j].length() + 2;
        }
        before=results.substring(0,index + elementLen);
        remainder=results.substring(index + elementLen);
        if (elements[0].equals(""String_Node_Str"")) {
          newRecord=getServletRecord(context,(PortletDD)portletData.get(i));
        }
 else         if (elements[0].equals(""String_Node_Str"")) {
          newRecord=getServletMappingRecord((PortletDD)portletData.get(i));
        }
        results=new StringBuffer();
        results.append(before);
        results.append(PlutoAdminConstants.LS);
        results.append(newRecord);
        results.append(remainder);
        break;
      }
    }
  }
  return results.toString();
}","/** 
 * Adds ServletPortlet servlet or servlet-mapping records to web.xml  for new portlet deployment.
 * @param context Web context or directory under webapps
 * @param contents Current contents of the web.xml file
 * @param elements Elements in web.xml to search for. If found, newelements will be inserted to the contents String. NOTE: First element (elements[0] signals the kind of record to add (servlet or servlet-mapping).
 * @param portletData A List of PortletDD items containing the data of portlets to be deployed.
 */
String addRecordsToWebXml(String context,String contents,String[] elements,List portletData){
  String METHOD_NAME=""String_Node_Str"";
  StringBuffer results=new StringBuffer(contents);
  int index=-1;
  int len=portletData.size();
  int lenElements=elements.length;
  String before=null;
  String newRecord=null;
  String remainder=null;
  String rest=null;
  for (int i=0; i < len; i++) {
    for (int j=0; j < lenElements; j++) {
      if ((index=results.lastIndexOf(""String_Node_Str"" + elements[j])) != -1) {
        rest=results.substring(index);
        int elementLen=rest.indexOf('>') + 1;
        if (i == 0 & elements[j].equals(""String_Node_Str"")) {
          index=results.indexOf(""String_Node_Str"");
          rest=results.substring(index);
          elementLen=rest.indexOf('>') + 1;
        }
        logDebug(METHOD_NAME,""String_Node_Str"" + elements[j] + ""String_Node_Str""+ elementLen);
        before=results.substring(0,index + elementLen);
        remainder=results.substring(index + elementLen);
        if (elements[0].equals(""String_Node_Str"")) {
          newRecord=getServletRecord(context,(PortletDD)portletData.get(i));
        }
 else         if (elements[0].equals(""String_Node_Str"")) {
          newRecord=getServletMappingRecord((PortletDD)portletData.get(i));
        }
        results=new StringBuffer();
        results.append(before);
        results.append(PlutoAdminConstants.LS);
        results.append(newRecord);
        results.append(remainder);
        break;
      }
    }
  }
  return results.toString();
}",0.7735520755654984
90749,"/** 
 * Gets the web.xml security-role-ref record for PortletServlet from portlet.xml data
 * @param context Context name
 * @param portletData Data from portlet.xml
 */
private String getSecurityRoleRefRecord(String context,PortletDD portletData){
  StringBuffer record=new StringBuffer(""String_Node_Str"");
  List refs=portletData.getSecurityRoleRefs();
  String link=null;
  for (Iterator iter=refs.iterator(); iter.hasNext(); ) {
    PortletConfigService.RoleRef ref=(PortletConfigService.RoleRef)iter.next();
    record.append(""String_Node_Str"" + PlutoAdminConstants.LS);
    record.append(""String_Node_Str"" + ref.roleName + ""String_Node_Str""+ PlutoAdminConstants.LS);
    link=ref.roleLink;
    if (link != null && !link.equals(""String_Node_Str"")) {
      record.append(""String_Node_Str"" + link + ""String_Node_Str""+ PlutoAdminConstants.LS);
    }
    record.append(""String_Node_Str"" + PlutoAdminConstants.LS);
  }
  return record.toString();
}","/** 
 * Gets the web.xml security-role-ref record for PortletServlet from portlet.xml data
 * @param context Context name
 * @param portletData Data from portlet.xml
 * @return
 */
private String getSecurityRoleRefRecord(String context,PortletDD portletData){
  StringBuffer record=new StringBuffer(""String_Node_Str"");
  List refs=portletData.getSecurityRoleRefs();
  String link=null;
  for (Iterator iter=refs.iterator(); iter.hasNext(); ) {
    PortletConfigService.RoleRef ref=(PortletConfigService.RoleRef)iter.next();
    record.append(""String_Node_Str"" + PlutoAdminConstants.LS);
    record.append(""String_Node_Str"" + ref.roleName + ""String_Node_Str""+ PlutoAdminConstants.LS);
    link=ref.roleLink;
    if (link != null && !link.equals(""String_Node_Str"")) {
      record.append(""String_Node_Str"" + link + ""String_Node_Str""+ PlutoAdminConstants.LS);
    }
    record.append(""String_Node_Str"" + PlutoAdminConstants.LS);
  }
  return record.toString();
}",0.994231777661248
90750,"public String getMethod(){
  return this._getHttpServletRequest().getMethod();
}","public String getMethod(){
  if (included) {
    return ""String_Node_Str"";
  }
 else {
    return this._getHttpServletRequest().getMethod();
  }
}",0.7079646017699115
90751,"public String toString(PortalControlParameter controlParam,Boolean p_secure){
  StringBuffer urlBase=new StringBuffer(256);
  boolean secure=false;
  if (p_secure != null) {
    secure=p_secure.booleanValue();
  }
 else {
    secure=environment.getRequest().isSecure();
  }
  urlBase.append(environment.getRequest().getContextPath());
  urlBase.append(secure ? secureServlet : insecureServlet);
  String url=urlBase.toString();
  String global=getGlobalNavigationAsString();
  if (global.length() > 0) {
    url+=""String_Node_Str"";
    url+=global;
  }
  String control=getControlParameterAsString(controlParam);
  if (control.length() > 0) {
    url+=control;
  }
  String requestParam=getRequestParameterAsString(controlParam);
  if (requestParam.length() > 0) {
    url+=requestParam;
  }
  String local=getLocalNavigationAsString();
  if (local.length() > 0) {
    url+=""String_Node_Str"";
    url+=local;
  }
  return environment.getResponse().encodeURL(url);
}","public String toString(PortalControlParameter controlParam,Boolean p_secure){
  StringBuffer urlBase=new StringBuffer(256);
  boolean secure=false;
  if (p_secure != null) {
    secure=p_secure.booleanValue();
  }
 else {
    secure=environment.getRequest().isSecure();
  }
  urlBase.append(environment.getRequest().getContextPath());
  urlBase.append(secure ? secureServlet : insecureServlet);
  String url=urlBase.toString();
  String global=getGlobalNavigationAsString();
  if (global.length() > 0) {
    url+=""String_Node_Str"";
    url+=global;
  }
  String control=getControlParameterAsString(controlParam);
  if (control.length() > 0) {
    control=URLEncoder.encode(control);
    control=control.replace(""String_Node_Str"",""String_Node_Str"");
    url+=control;
  }
  String requestParam=getRequestParameterAsString(controlParam);
  if (requestParam.length() > 0) {
    url+=requestParam;
  }
  String local=getLocalNavigationAsString();
  if (local.length() > 0) {
    url+=""String_Node_Str"";
    url+=local;
  }
  return environment.getResponse().encodeURL(url);
}",0.6394891944990176
90752,"public static void prepareWebArchive(String webAppsDir,String warFile) throws Exception, IOException {
  String webModule=warFile;
  if (webModule.indexOf(""String_Node_Str"") != -1)   webModule=webModule.substring(webModule.lastIndexOf(""String_Node_Str"") + 1);
  if (webModule.indexOf(dirDelim) != -1)   webModule=webModule.substring(webModule.lastIndexOf(dirDelim) + 1);
  if (webModule.endsWith(""String_Node_Str""))   webModule=webModule.substring(0,webModule.lastIndexOf(""String_Node_Str""));
  System.out.println(""String_Node_Str"" + webModule + ""String_Node_Str"");
  Mapping mappingPortletXml=null;
  Mapping mappingWebXml=null;
  String _portlet_mapping=webAppsDir + portalImplWebDir + ""String_Node_Str""+ dirDelim+ ""String_Node_Str""+ dirDelim+ ""String_Node_Str""+ dirDelim+ ""String_Node_Str"";
  mappingPortletXml=new Mapping();
  try {
    mappingPortletXml.loadMapping(_portlet_mapping);
  }
 catch (  Exception e) {
    System.out.println(""String_Node_Str"" + e);
    throw new IOException(""String_Node_Str"" + _web_mapping + ""String_Node_Str""+ e.getMessage());
  }
  File portletXml=new File(webAppsDir + webModule + webInfDir+ ""String_Node_Str"");
  String _web_mapping=webAppsDir + portalImplWebDir + ""String_Node_Str""+ dirDelim+ ""String_Node_Str""+ dirDelim+ ""String_Node_Str""+ dirDelim+ ""String_Node_Str"";
  mappingWebXml=new Mapping();
  try {
    mappingWebXml.loadMapping(_web_mapping);
  }
 catch (  Exception e) {
    throw new IOException(""String_Node_Str"" + _web_mapping + ""String_Node_Str""+ e.getMessage());
  }
  File webXml=new File(webAppsDir + webModule + webInfDir+ ""String_Node_Str"");
  try {
    org.w3c.dom.Document portletDocument=XmlParser.parsePortletXml(new FileInputStream(portletXml));
    Unmarshaller unmarshaller=new Unmarshaller(mappingPortletXml);
    unmarshaller.setIgnoreExtraElements(true);
    unmarshaller.setIgnoreExtraAttributes(true);
    PortletApplicationDefinitionImpl portletApp=(PortletApplicationDefinitionImpl)unmarshaller.unmarshal(portletDocument);
    Vector structure=new Vector();
    structure.add(webModule);
    structure.add(null);
    structure.add(null);
    portletApp.preBuild(structure);
    if (debug) {
      System.out.println(portletApp);
    }
    WebApplicationDefinitionImpl webApp=null;
    if (webXml.exists()) {
      org.w3c.dom.Document webDocument=XmlParser.parseWebXml(new FileInputStream(webXml));
      Unmarshaller unmarshallerWeb=new Unmarshaller(mappingWebXml);
      unmarshallerWeb.setIgnoreExtraElements(true);
      unmarshallerWeb.setIgnoreExtraAttributes(true);
      webApp=(WebApplicationDefinitionImpl)unmarshallerWeb.unmarshal(webDocument);
    }
 else {
      webApp=new WebApplicationDefinitionImpl();
      DisplayNameImpl dispName=new DisplayNameImpl();
      dispName.setDisplayName(webModule);
      dispName.setLocale(Locale.ENGLISH);
      DisplayNameSetImpl dispSet=new DisplayNameSetImpl();
      dispSet.add(dispName);
      webApp.setDisplayNames(dispSet);
      DescriptionImpl desc=new DescriptionImpl();
      desc.setDescription(""String_Node_Str"");
      desc.setLocale(Locale.ENGLISH);
      DescriptionSetImpl descSet=new DescriptionSetImpl();
      descSet.add(desc);
      webApp.setDescriptions(descSet);
    }
    org.apache.pluto.om.ControllerFactory controllerFactory=new org.apache.pluto.portalImpl.om.ControllerFactoryImpl();
    ServletDefinitionListCtrl servletDefinitionSetCtrl=(ServletDefinitionListCtrl)controllerFactory.get(webApp.getServletDefinitionList());
    Collection servletMappings=webApp.getServletMappings();
    Iterator portlets=portletApp.getPortletDefinitionList().iterator();
    while (portlets.hasNext()) {
      PortletDefinition portlet=(PortletDefinition)portlets.next();
      ServletDefinition servlet=webApp.getServletDefinitionList().get(portlet.getName());
      if (servlet != null) {
        if (!servlet.getServletClass().equals(""String_Node_Str"")) {
          System.out.println(""String_Node_Str"" + portlet.getName() + ""String_Node_Str"");
        }
        ServletDefinitionCtrl _servletCtrl=(ServletDefinitionCtrl)controllerFactory.get(servlet);
        _servletCtrl.setServletClass(""String_Node_Str"");
      }
 else {
        servlet=servletDefinitionSetCtrl.add(portlet.getName(),""String_Node_Str"");
      }
      ServletDefinitionCtrl servletCtrl=(ServletDefinitionCtrl)controllerFactory.get(servlet);
      DisplayNameImpl dispName=new DisplayNameImpl();
      dispName.setDisplayName(portlet.getName() + ""String_Node_Str"");
      dispName.setLocale(Locale.ENGLISH);
      DisplayNameSetImpl dispSet=new DisplayNameSetImpl();
      dispSet.add(dispName);
      servletCtrl.setDisplayNames(dispSet);
      DescriptionImpl desc=new DescriptionImpl();
      desc.setDescription(""String_Node_Str"");
      desc.setLocale(Locale.ENGLISH);
      DescriptionSetImpl descSet=new DescriptionSetImpl();
      descSet.add(desc);
      servletCtrl.setDescriptions(descSet);
      ParameterSet parameters=servlet.getInitParameterSet();
      ParameterSetCtrl parameterSetCtrl=(ParameterSetCtrl)controllerFactory.get(parameters);
      Parameter parameter1=parameters.get(""String_Node_Str"");
      if (parameter1 == null) {
        parameterSetCtrl.add(""String_Node_Str"",portlet.getClassName());
      }
 else {
        ParameterCtrl parameterCtrl=(ParameterCtrl)controllerFactory.get(parameter1);
        parameterCtrl.setValue(portlet.getClassName());
      }
      Parameter parameter2=parameters.get(""String_Node_Str"");
      if (parameter2 == null) {
        parameterSetCtrl.add(""String_Node_Str"",portlet.getId().toString());
      }
 else {
        ParameterCtrl parameterCtrl=(ParameterCtrl)controllerFactory.get(parameter2);
        parameterCtrl.setValue(portlet.getId().toString());
      }
      boolean found=false;
      Iterator mappings=servletMappings.iterator();
      while (mappings.hasNext()) {
        ServletMappingImpl servletMapping=(ServletMappingImpl)mappings.next();
        if (servletMapping.getServletName().equals(portlet.getName())) {
          found=true;
          servletMapping.setUrlPattern(""String_Node_Str"" + portlet.getName().replace(' ','_') + ""String_Node_Str"");
        }
      }
      if (!found) {
        ServletMappingImpl servletMapping=new ServletMappingImpl();
        servletMapping.setServletName(portlet.getName());
        servletMapping.setUrlPattern(""String_Node_Str"" + portlet.getName().replace(' ','_') + ""String_Node_Str"");
        servletMappings.add(servletMapping);
      }
      SecurityRoleRefSet servletSecurityRoleRefs=((ServletDefinitionImpl)servlet).getInitSecurityRoleRefSet();
      SecurityRoleRefSetCtrl servletSecurityRoleRefSetCtrl=(SecurityRoleRefSetCtrl)controllerFactory.get(servletSecurityRoleRefs);
      SecurityRoleSet webAppSecurityRoles=webApp.getSecurityRoles();
      SecurityRoleRefSet portletSecurityRoleRefs=portlet.getInitSecurityRoleRefSet();
      Iterator p=portletSecurityRoleRefs.iterator();
      while (p.hasNext()) {
        SecurityRoleRef portletSecurityRoleRef=(SecurityRoleRef)p.next();
        if (portletSecurityRoleRef.getRoleLink() == null && webAppSecurityRoles.get(portletSecurityRoleRef.getRoleName()) == null) {
          System.out.println(""String_Node_Str"" + portletSecurityRoleRef.getRoleName() + ""String_Node_Str""+ portlet.getName()+ ""String_Node_Str"");
          break;
        }
        SecurityRoleRef servletSecurityRoleRef=servletSecurityRoleRefs.get(portletSecurityRoleRef.getRoleName());
        if (null != servletSecurityRoleRef) {
          System.out.println(""String_Node_Str"" + portletSecurityRoleRef.getRoleName() + ""String_Node_Str""+ portlet.getName()+ ""String_Node_Str"");
          servletSecurityRoleRefSetCtrl.remove(servletSecurityRoleRef);
        }
        servletSecurityRoleRefSetCtrl.add(portletSecurityRoleRef);
      }
    }
    if (debug) {
      System.out.println(webApp);
    }
    OutputFormat of=new OutputFormat();
    of.setIndenting(true);
    of.setIndent(4);
    of.setLineWidth(16384);
    of.setDoctype(Constants.WEB_PORTLET_PUBLIC_ID,Constants.WEB_PORTLET_DTD);
    FileWriter writer=new FileWriter(webAppsDir + webModule + System.getProperty(""String_Node_Str"")+ ""String_Node_Str""+ System.getProperty(""String_Node_Str"")+ ""String_Node_Str"");
    XMLSerializer serializer=new XMLSerializer(writer,of);
    try {
      Marshaller marshaller=new Marshaller(serializer.asDocumentHandler());
      marshaller.setMapping(mappingWebXml);
      marshaller.marshal(webApp);
    }
 catch (    Exception e) {
      writer.close();
      e.printStackTrace(System.out);
      throw new PlutoAdminException(""String_Node_Str"",e);
    }
  }
 catch (  Exception e) {
    e.printStackTrace(System.out);
    throw new PlutoAdminException(""String_Node_Str"",e);
  }
  System.out.println(""String_Node_Str"");
}","public static void prepareWebArchive(String webAppsDir,String warFile) throws Exception, IOException {
  String webModule=warFile;
  if (webModule.indexOf(""String_Node_Str"") != -1)   webModule=webModule.substring(webModule.lastIndexOf(""String_Node_Str"") + 1);
  if (webModule.indexOf(dirDelim) != -1)   webModule=webModule.substring(webModule.lastIndexOf(dirDelim) + 1);
  if (webModule.endsWith(""String_Node_Str""))   webModule=webModule.substring(0,webModule.lastIndexOf(""String_Node_Str""));
  System.out.println(""String_Node_Str"" + webModule + ""String_Node_Str"");
  Mapping mappingPortletXml=null;
  Mapping mappingWebXml=null;
  String _portlet_mapping=webAppsDir + portalImplWebDir + ""String_Node_Str""+ dirDelim+ ""String_Node_Str""+ dirDelim+ ""String_Node_Str""+ dirDelim+ ""String_Node_Str"";
  mappingPortletXml=new Mapping();
  try {
    mappingPortletXml.loadMapping(_portlet_mapping);
  }
 catch (  Exception e) {
    System.out.println(""String_Node_Str"" + e);
    throw new IOException(""String_Node_Str"" + _portlet_mapping + ""String_Node_Str""+ e.getMessage());
  }
  File portletXml=new File(webAppsDir + webModule + webInfDir+ ""String_Node_Str"");
  String _web_mapping=webAppsDir + portalImplWebDir + ""String_Node_Str""+ dirDelim+ ""String_Node_Str""+ dirDelim+ ""String_Node_Str""+ dirDelim+ ""String_Node_Str"";
  mappingWebXml=new Mapping();
  try {
    mappingWebXml.loadMapping(_web_mapping);
  }
 catch (  Exception e) {
    throw new IOException(""String_Node_Str"" + _web_mapping + ""String_Node_Str""+ e.getMessage());
  }
  File webXml=new File(webAppsDir + webModule + webInfDir+ ""String_Node_Str"");
  try {
    org.w3c.dom.Document portletDocument=XmlParser.parsePortletXml(new FileInputStream(portletXml));
    Unmarshaller unmarshaller=new Unmarshaller(mappingPortletXml);
    unmarshaller.setIgnoreExtraElements(true);
    unmarshaller.setIgnoreExtraAttributes(true);
    PortletApplicationDefinitionImpl portletApp=(PortletApplicationDefinitionImpl)unmarshaller.unmarshal(portletDocument);
    Vector structure=new Vector();
    structure.add(webModule);
    structure.add(null);
    structure.add(null);
    portletApp.preBuild(structure);
    if (debug) {
      System.out.println(portletApp);
    }
    WebApplicationDefinitionImpl webApp=null;
    if (webXml.exists()) {
      org.w3c.dom.Document webDocument=XmlParser.parseWebXml(new FileInputStream(webXml));
      Unmarshaller unmarshallerWeb=new Unmarshaller(mappingWebXml);
      unmarshallerWeb.setIgnoreExtraElements(true);
      unmarshallerWeb.setIgnoreExtraAttributes(true);
      webApp=(WebApplicationDefinitionImpl)unmarshallerWeb.unmarshal(webDocument);
    }
 else {
      webApp=new WebApplicationDefinitionImpl();
      DisplayNameImpl dispName=new DisplayNameImpl();
      dispName.setDisplayName(webModule);
      dispName.setLocale(Locale.ENGLISH);
      DisplayNameSetImpl dispSet=new DisplayNameSetImpl();
      dispSet.add(dispName);
      webApp.setDisplayNames(dispSet);
      DescriptionImpl desc=new DescriptionImpl();
      desc.setDescription(""String_Node_Str"");
      desc.setLocale(Locale.ENGLISH);
      DescriptionSetImpl descSet=new DescriptionSetImpl();
      descSet.add(desc);
      webApp.setDescriptions(descSet);
    }
    org.apache.pluto.om.ControllerFactory controllerFactory=new org.apache.pluto.portalImpl.om.ControllerFactoryImpl();
    ServletDefinitionListCtrl servletDefinitionSetCtrl=(ServletDefinitionListCtrl)controllerFactory.get(webApp.getServletDefinitionList());
    Collection servletMappings=webApp.getServletMappings();
    Iterator portlets=portletApp.getPortletDefinitionList().iterator();
    while (portlets.hasNext()) {
      PortletDefinition portlet=(PortletDefinition)portlets.next();
      ServletDefinition servlet=webApp.getServletDefinitionList().get(portlet.getName());
      if (servlet != null) {
        if (!servlet.getServletClass().equals(""String_Node_Str"")) {
          System.out.println(""String_Node_Str"" + portlet.getName() + ""String_Node_Str"");
        }
        ServletDefinitionCtrl _servletCtrl=(ServletDefinitionCtrl)controllerFactory.get(servlet);
        _servletCtrl.setServletClass(""String_Node_Str"");
      }
 else {
        servlet=servletDefinitionSetCtrl.add(portlet.getName(),""String_Node_Str"");
      }
      ServletDefinitionCtrl servletCtrl=(ServletDefinitionCtrl)controllerFactory.get(servlet);
      DisplayNameImpl dispName=new DisplayNameImpl();
      dispName.setDisplayName(portlet.getName() + ""String_Node_Str"");
      dispName.setLocale(Locale.ENGLISH);
      DisplayNameSetImpl dispSet=new DisplayNameSetImpl();
      dispSet.add(dispName);
      servletCtrl.setDisplayNames(dispSet);
      DescriptionImpl desc=new DescriptionImpl();
      desc.setDescription(""String_Node_Str"");
      desc.setLocale(Locale.ENGLISH);
      DescriptionSetImpl descSet=new DescriptionSetImpl();
      descSet.add(desc);
      servletCtrl.setDescriptions(descSet);
      ParameterSet parameters=servlet.getInitParameterSet();
      ParameterSetCtrl parameterSetCtrl=(ParameterSetCtrl)controllerFactory.get(parameters);
      Parameter parameter1=parameters.get(""String_Node_Str"");
      if (parameter1 == null) {
        parameterSetCtrl.add(""String_Node_Str"",portlet.getClassName());
      }
 else {
        ParameterCtrl parameterCtrl=(ParameterCtrl)controllerFactory.get(parameter1);
        parameterCtrl.setValue(portlet.getClassName());
      }
      Parameter parameter2=parameters.get(""String_Node_Str"");
      if (parameter2 == null) {
        parameterSetCtrl.add(""String_Node_Str"",portlet.getId().toString());
      }
 else {
        ParameterCtrl parameterCtrl=(ParameterCtrl)controllerFactory.get(parameter2);
        parameterCtrl.setValue(portlet.getId().toString());
      }
      boolean found=false;
      Iterator mappings=servletMappings.iterator();
      while (mappings.hasNext()) {
        ServletMappingImpl servletMapping=(ServletMappingImpl)mappings.next();
        if (servletMapping.getServletName().equals(portlet.getName())) {
          found=true;
          servletMapping.setUrlPattern(""String_Node_Str"" + portlet.getName().replace(' ','_') + ""String_Node_Str"");
        }
      }
      if (!found) {
        ServletMappingImpl servletMapping=new ServletMappingImpl();
        servletMapping.setServletName(portlet.getName());
        servletMapping.setUrlPattern(""String_Node_Str"" + portlet.getName().replace(' ','_') + ""String_Node_Str"");
        servletMappings.add(servletMapping);
      }
      SecurityRoleRefSet servletSecurityRoleRefs=((ServletDefinitionImpl)servlet).getInitSecurityRoleRefSet();
      SecurityRoleRefSetCtrl servletSecurityRoleRefSetCtrl=(SecurityRoleRefSetCtrl)controllerFactory.get(servletSecurityRoleRefs);
      SecurityRoleSet webAppSecurityRoles=webApp.getSecurityRoles();
      SecurityRoleRefSet portletSecurityRoleRefs=portlet.getInitSecurityRoleRefSet();
      Iterator p=portletSecurityRoleRefs.iterator();
      while (p.hasNext()) {
        SecurityRoleRef portletSecurityRoleRef=(SecurityRoleRef)p.next();
        if (portletSecurityRoleRef.getRoleLink() == null && webAppSecurityRoles.get(portletSecurityRoleRef.getRoleName()) == null) {
          System.out.println(""String_Node_Str"" + portletSecurityRoleRef.getRoleName() + ""String_Node_Str""+ portlet.getName()+ ""String_Node_Str"");
          break;
        }
        SecurityRoleRef servletSecurityRoleRef=servletSecurityRoleRefs.get(portletSecurityRoleRef.getRoleName());
        if (null != servletSecurityRoleRef) {
          System.out.println(""String_Node_Str"" + portletSecurityRoleRef.getRoleName() + ""String_Node_Str""+ portlet.getName()+ ""String_Node_Str"");
          servletSecurityRoleRefSetCtrl.remove(servletSecurityRoleRef);
        }
        servletSecurityRoleRefSetCtrl.add(portletSecurityRoleRef);
      }
    }
    if (debug) {
      System.out.println(webApp);
    }
    OutputFormat of=new OutputFormat();
    of.setIndenting(true);
    of.setIndent(4);
    of.setLineWidth(16384);
    of.setDoctype(Constants.WEB_PORTLET_PUBLIC_ID,Constants.WEB_PORTLET_DTD);
    FileWriter writer=new FileWriter(webAppsDir + webModule + System.getProperty(""String_Node_Str"")+ ""String_Node_Str""+ System.getProperty(""String_Node_Str"")+ ""String_Node_Str"");
    XMLSerializer serializer=new XMLSerializer(writer,of);
    try {
      Marshaller marshaller=new Marshaller(serializer.asDocumentHandler());
      marshaller.setMapping(mappingWebXml);
      marshaller.marshal(webApp);
    }
 catch (    Exception e) {
      writer.close();
      e.printStackTrace(System.out);
      throw new PlutoAdminException(""String_Node_Str"",e);
    }
  }
 catch (  Exception e) {
    e.printStackTrace(System.out);
    throw new PlutoAdminException(""String_Node_Str"",e);
  }
  System.out.println(""String_Node_Str"");
}",0.9994307184333372
90753,"static private void addToEntityReg(String[] args){
  File portletAppFile=new File(args[2]);
  String portletAppFileName=portletAppFile.getName();
  String portletApp=portletAppFileName.substring(0,portletAppFileName.lastIndexOf(""String_Node_Str""));
  int o=(args[4].equals(""String_Node_Str"") ? 5 : 6);
  String appId=args[o++];
  try {
    String entityMapping=webAppsDir + portalImplWebDir + ""String_Node_Str"";
    File file=new File(entityMapping);
    RandomAccessFile ras=new RandomAccessFile(file,""String_Node_Str"");
    long length=ras.length();
    byte[] contentByte=new byte[(int)length];
    ras.read(contentByte);
    String contentString=new String(contentByte);
    long pos=contentString.lastIndexOf(""String_Node_Str"");
    ras.seek(pos);
    ras.writeBytes(""String_Node_Str"" + appId + ""String_Node_Str"");
    ras.writeBytes(""String_Node_Str"" + portletApp + ""String_Node_Str"");
    StringTokenizer tokenizer;
    for (int i=o; i < args.length; ++i) {
      tokenizer=new StringTokenizer(args[i],""String_Node_Str"");
      String portletId=tokenizer.nextToken();
      String portletName=tokenizer.nextToken();
      ras.writeBytes(""String_Node_Str"" + portletId + ""String_Node_Str"");
      ras.writeBytes(""String_Node_Str"" + portletApp + ""String_Node_Str""+ portletName+ ""String_Node_Str"");
      ras.writeBytes(""String_Node_Str"");
    }
    ras.writeBytes(""String_Node_Str"");
    ras.writeBytes(""String_Node_Str"");
    ras.close();
  }
 catch (  Exception e) {
    e.printStackTrace(System.out);
    throw PlutoAdminException(""String_Node_Str"",e);
  }
}","static private void addToEntityReg(String[] args){
  File portletAppFile=new File(args[2]);
  String portletAppFileName=portletAppFile.getName();
  String portletApp=portletAppFileName.substring(0,portletAppFileName.lastIndexOf(""String_Node_Str""));
  int o=(args[4].equals(""String_Node_Str"") ? 5 : 6);
  String appId=args[o++];
  try {
    String entityMapping=webAppsDir + portalImplWebDir + ""String_Node_Str"";
    File file=new File(entityMapping);
    RandomAccessFile ras=new RandomAccessFile(file,""String_Node_Str"");
    long length=ras.length();
    byte[] contentByte=new byte[(int)length];
    ras.read(contentByte);
    String contentString=new String(contentByte);
    long pos=contentString.lastIndexOf(""String_Node_Str"");
    ras.seek(pos);
    ras.writeBytes(""String_Node_Str"" + appId + ""String_Node_Str"");
    ras.writeBytes(""String_Node_Str"" + portletApp + ""String_Node_Str"");
    StringTokenizer tokenizer;
    for (int i=o; i < args.length; ++i) {
      tokenizer=new StringTokenizer(args[i],""String_Node_Str"");
      String portletId=tokenizer.nextToken();
      String portletName=tokenizer.nextToken();
      ras.writeBytes(""String_Node_Str"" + portletId + ""String_Node_Str"");
      ras.writeBytes(""String_Node_Str"" + portletApp + ""String_Node_Str""+ portletName+ ""String_Node_Str"");
      ras.writeBytes(""String_Node_Str"");
    }
    ras.writeBytes(""String_Node_Str"");
    ras.writeBytes(""String_Node_Str"");
    ras.close();
  }
 catch (  Exception e) {
    e.printStackTrace(System.out);
    throw new PlutoAdminException(""String_Node_Str"",e);
  }
}",0.9987236758136566
90754,"public javax.portlet.PortletRequestDispatcher getRequestDispatcher(String path){
  try {
    javax.servlet.RequestDispatcher rd=servletContext.getRequestDispatcher(path);
    if (rd == null) {
      return null;
    }
    return new PortletRequestDispatcherImpl(rd);
  }
 catch (  Exception e) {
    return null;
  }
}","public javax.portlet.PortletRequestDispatcher getRequestDispatcher(String path){
  Map parms=parseQueryParams(path);
  try {
    RequestDispatcher rd=servletContext.getRequestDispatcher(path);
    return rd == null ? null : new PortletRequestDispatcherImpl(rd,parms);
  }
 catch (  Exception e) {
    return null;
  }
}",0.8163265306122449
90755,"public PortletRequestDispatcherImpl(javax.servlet.RequestDispatcher requestDispatcher){
  this.requestDispatcher=requestDispatcher;
}","public PortletRequestDispatcherImpl(RequestDispatcher disp,Map queryParams){
  this(disp);
  this.queryParams=queryParams;
}",0.622568093385214
90756,"public void include(RenderRequest request,RenderResponse response) throws PortletException, java.io.IOException {
  InternalPortletRequest internalRequest=CoreUtils.getInternalRequest(request);
  InternalPortletResponse internalResponse=CoreUtils.getInternalResponse(response);
  try {
    internalRequest.setIncluded(true);
    internalResponse.setIncluded(true);
    this.requestDispatcher.include((javax.servlet.http.HttpServletRequest)request,(javax.servlet.http.HttpServletResponse)response);
  }
 catch (  java.io.IOException e) {
    throw e;
  }
catch (  javax.servlet.ServletException e) {
    if (e.getRootCause() != null) {
      throw new PortletException(e.getRootCause());
    }
 else {
      throw new PortletException(e);
    }
  }
 finally {
    internalRequest.setIncluded(false);
    internalResponse.setIncluded(false);
  }
}","public void include(RenderRequest request,RenderResponse response) throws PortletException, java.io.IOException {
  InternalPortletRequest internalRequest=CoreUtils.getInternalRequest(request);
  InternalPortletResponse internalResponse=CoreUtils.getInternalResponse(response);
  if (queryParams != null) {
    internalRequest=new IncludedRenderRequestImpl(internalRequest,queryParams);
  }
  try {
    internalRequest.setIncluded(true);
    internalResponse.setIncluded(true);
    this.requestDispatcher.include((javax.servlet.http.HttpServletRequest)request,(javax.servlet.http.HttpServletResponse)response);
  }
 catch (  java.io.IOException e) {
    throw e;
  }
catch (  javax.servlet.ServletException e) {
    if (e.getRootCause() != null) {
      throw new PortletException(e.getRootCause());
    }
 else {
      throw new PortletException(e);
    }
  }
 finally {
    internalRequest.setIncluded(false);
    internalResponse.setIncluded(false);
  }
}",0.93732667775929
90757,"public String getParameter(String name){
  if (name == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  bodyAccessed=true;
  Map parameters=this._getHttpServletRequest().getParameterMap();
  String[] values=(String[])parameters.get(name);
  if (values != null) {
    return values[0];
  }
  return null;
}","public String getParameter(String name){
  if (name == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  bodyAccessed=true;
  Map parameters=getParameterMap();
  String[] values=(String[])parameters.get(name);
  if (values != null) {
    return values[0];
  }
  return null;
}",0.9522292993630572
90758,"public java.util.Enumeration getParameterNames(){
  bodyAccessed=true;
  Map parameters=this._getHttpServletRequest().getParameterMap();
  return Collections.enumeration(parameters.keySet());
}","public java.util.Enumeration getParameterNames(){
  bodyAccessed=true;
  Map parameters=getParameterMap();
  return Collections.enumeration(parameters.keySet());
}",0.9157303370786516
90759,"public String[] getParameterValues(String name){
  if (name == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  bodyAccessed=true;
  String[] values=(String[])this._getHttpServletRequest().getParameterMap().get(name);
  if (values != null)   values=StringUtils.copy(values);
  return values;
}","public String[] getParameterValues(String name){
  if (name == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  bodyAccessed=true;
  String[] values=(String[])getParameterMap().get(name);
  if (values != null)   values=StringUtils.copy(values);
  return values;
}",0.7185430463576159
90760,"public Enumeration getAttributeNames(){
  Enumeration attributes=this._getHttpServletRequest().getAttributeNames();
  Vector portletAttributes=new Vector();
  while (attributes.hasMoreElements()) {
    String attribute=(String)attributes.nextElement();
    String portletAttribute=NamespaceMapperAccess.getNamespaceMapper().decode(portletWindow.getId(),attribute);
    if (portletAttribute != null) {
      portletAttributes.add(portletAttribute);
    }
  }
  return portletAttributes.elements();
}","public Enumeration getAttributeNames(){
  Enumeration attributes=this._getHttpServletRequest().getAttributeNames();
  Vector portletAttributes=new Vector();
  while (attributes.hasMoreElements()) {
    String attribute=(String)attributes.nextElement();
    String portletAttribute=NamespaceMapperAccess.getNamespaceMapper().decode(portletWindow.getId(),attribute);
    if (portletAttribute != null) {
      portletAttributes.add(portletAttribute);
    }
 else {
      portletAttributes.add(attribute);
    }
  }
  return portletAttributes.elements();
}",0.878095238095238
90761,public InternalPortletWindow getInternalPortletWindow();,InternalPortletWindow getInternalPortletWindow();,0.9333333333333332
90762,public void setIncluded(boolean included);,void setIncluded(boolean included);,0.9090909090909092
90763,public boolean isIncluded();,boolean isIncluded();,0.8571428571428571
90764,"private void dispatch(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException {
  try {
    request.setAttribute(org.apache.pluto.Constants.PORTLET_CONFIG,portletConfig);
    Integer method_id=(Integer)request.getAttribute(org.apache.pluto.Constants.METHOD_ID);
    if (method_id == org.apache.pluto.Constants.METHOD_RENDER) {
      RenderRequestImpl renderRequest=(RenderRequestImpl)request.getAttribute(org.apache.pluto.Constants.PORTLET_REQUEST);
      RenderResponseImpl renderResponse=(RenderResponseImpl)request.getAttribute(org.apache.pluto.Constants.PORTLET_RESPONSE);
      portlet.render(renderRequest,renderResponse);
    }
 else     if (method_id == org.apache.pluto.Constants.METHOD_ACTION) {
      ActionRequestImpl actionRequest=(ActionRequestImpl)request.getAttribute(org.apache.pluto.Constants.PORTLET_REQUEST);
      ActionResponseImpl actionResponse=(ActionResponseImpl)request.getAttribute(org.apache.pluto.Constants.PORTLET_RESPONSE);
      portlet.processAction(actionRequest,actionResponse);
    }
 else     if (method_id == org.apache.pluto.Constants.METHOD_NOOP) {
    }
  }
 catch (  javax.portlet.UnavailableException e) {
    e.printStackTrace();
    try {
      portlet.destroy();
    }
 catch (    Throwable t) {
    }
    throw new javax.servlet.UnavailableException(e.getMessage());
  }
catch (  PortletException e) {
    e.printStackTrace();
    throw new ServletException(e);
  }
 finally {
    request.removeAttribute(org.apache.pluto.Constants.PORTLET_CONFIG);
  }
}","private void dispatch(HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException {
  try {
    request.setAttribute(org.apache.pluto.Constants.PORTLET_CONFIG,portletConfig);
    Integer method_id=(Integer)request.getAttribute(org.apache.pluto.Constants.METHOD_ID);
    InternalPortletRequest pRequest=(InternalPortletRequest)request.getAttribute(Constants.PORTLET_REQUEST);
    InternalPortletResponse pResponse=(InternalPortletResponse)request.getAttribute(Constants.PORTLET_RESPONSE);
    pRequest.setPortletContext(portletContext);
    if (method_id == org.apache.pluto.Constants.METHOD_RENDER) {
      RenderRequestImpl renderRequest=(RenderRequestImpl)pRequest;
      RenderResponseImpl renderResponse=(RenderResponseImpl)pResponse;
      portlet.render(renderRequest,renderResponse);
    }
 else     if (method_id == org.apache.pluto.Constants.METHOD_ACTION) {
      ActionRequestImpl actionRequest=(ActionRequestImpl)pRequest;
      ActionResponseImpl actionResponse=(ActionResponseImpl)pResponse;
      portlet.processAction(actionRequest,actionResponse);
    }
 else     if (method_id == org.apache.pluto.Constants.METHOD_NOOP) {
    }
  }
 catch (  javax.portlet.UnavailableException e) {
    e.printStackTrace();
    try {
      portlet.destroy();
    }
 catch (    Throwable t) {
    }
    throw new javax.servlet.UnavailableException(e.getMessage());
  }
catch (  PortletException e) {
    e.printStackTrace();
    throw new ServletException(e);
  }
 finally {
    request.removeAttribute(org.apache.pluto.Constants.PORTLET_CONFIG);
  }
}",0.744721689059501
90765,"public String getServerInfo(){
  return Environment.getServerInfo();
}","/** 
 * Retrieve the PortletContainer's server info.
 * @return the server info in the form of <i>Server/Version</i>
 * @see Environment#getServerInfo()
 */
public String getServerInfo(){
  return Environment.getServerInfo();
}",0.4713804713804714
90766,"public java.io.InputStream getResourceAsStream(String path){
  return servletContext.getResourceAsStream(path);
}","public InputStream getResourceAsStream(String path){
  return servletContext.getResourceAsStream(path);
}",0.963302752293578
90767,"public PortletRequestDispatcher getRequestDispatcher(String path){
  try {
    RequestDispatcher rd=servletContext.getRequestDispatcher(path);
    return new PortletRequestDispatcherImpl(rd);
  }
 catch (  Exception e) {
    return null;
  }
}","public PortletRequestDispatcher getRequestDispatcher(String path){
  try {
    RequestDispatcher rd=servletContext.getRequestDispatcher(path);
    if (rd != null) {
      return new PortletRequestDispatcherImpl(rd);
    }
  }
 catch (  Exception e) {
  }
  return null;
}",0.926070038910506
90768,"public PortletContextImpl(ServletContext servletContext,PortletAppDD portletAppDD){
  this.servletContext=servletContext;
  this.portletAppDD=portletAppDD;
}","/** 
 * Sole constructor.
 * @param servletContext the servlet context in which we are contained.
 * @param portletAppDD the application descriptor.
 */
public PortletContextImpl(ServletContext servletContext,PortletAppDD portletAppDD){
  this.servletContext=servletContext;
  this.portletAppDD=portletAppDD;
}",0.6723768736616702
90769,"public PortletRequestDispatcher getNamedDispatcher(String name){
  javax.servlet.RequestDispatcher rd=servletContext.getNamedDispatcher(name);
  return rd != null ? new PortletRequestDispatcherImpl(rd) : null;
}","public PortletRequestDispatcher getNamedDispatcher(String name){
  RequestDispatcher rd=servletContext.getNamedDispatcher(name);
  if (rd != null) {
    return new PortletRequestDispatcherImpl(rd);
  }
  return null;
}",0.8438228438228438
90770,"public javax.servlet.ServletContext getServletContext(){
  return httpSession.getServletContext();
}","/** 
 * HttpSession Implementation.
 * @return
 */
public ServletContext getServletContext(){
  return httpSession.getServletContext();
}",0.7257383966244726
90771,"public PortletContext getPortletContext(){
  return getInternalPortletContext();
}","public PortletContext getPortletContext(){
  return portletContext;
}",0.9006622516556292
90772,"public javax.servlet.http.HttpSessionContext getSessionContext(){
  return httpSession.getSessionContext();
}","/** 
 * Implemented for backwards compatability.
 * @deprecated
 * @return
 */
public HttpSessionContext getSessionContext(){
  return httpSession.getSessionContext();
}",0.6474820143884892
90773,"public String[] getValueNames(){
  return null;
}","/** 
 * Implemented for backwards compatibility with HttpSession.
 * @deprecated
 * @return
 */
public String[] getValueNames(){
  return httpSession.getValueNames();
}",0.4331797235023041
90774,"public Object getAttribute(String name){
  if (name == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  Object attribute=this.getHttpServletRequest().getAttribute(mapper.encode(internalPortletWindow.getId(),name));
  if (attribute == null && isNameReserved(name)) {
    attribute=this.getHttpServletRequest().getAttribute(name);
  }
  return attribute;
}","public Object getAttribute(String name){
  if (name == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  Object attribute=this.getHttpServletRequest().getAttribute(mapper.encode(internalPortletWindow.getId(),name));
  if (attribute == null) {
    attribute=this.getHttpServletRequest().getAttribute(name);
  }
  return attribute;
}",0.8633879781420765
90775,"public boolean isUserInRole(String role){
  return this._getHttpServletRequest().isUserInRole(role);
}","/** 
 * Determines whether a user is mapped to the specified role.  As specified in PLT-20-3, we must reference the &lt;security-role-ref&gt; mappings within the deployment descriptor. If no mapping is available, then, and only then, do we check use the actual role name specified against the web application deployment descriptor.
 * @param roleName the name of the role
 * @return true if it is determined the user has the given role.
 */
public boolean isUserInRole(String roleName){
  PortletEntity entity=portletWindow.getPortletEntity();
  PortletDefinition def=entity.getPortletDefinition();
  SecurityRoleRefSet set=def.getInitSecurityRoleRefSet();
  SecurityRoleRef ref=set.get(roleName);
  String link=null;
  if (ref != null && ref.getRoleLink() != null) {
    link=ref.getRoleLink();
  }
 else {
    link=roleName;
  }
  return this._getHttpServletRequest().isUserInRole(link);
}",0.1873111782477341
90776,"public void setRenderParameter(String key,String[] values){
  if (redirected) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  if (key == null || values == null || values.length == 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  renderParameters.put(key,values);
  redirectAllowed=false;
}","public void setRenderParameter(String key,String[] values){
  if (redirected) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  if (key == null || values == null || values.length == 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  renderParameters.put(key,StringUtils.copy(values));
  redirectAllowed=false;
}",0.9552238805970148
90777,"public void setRenderParameters(Map parameters){
  if (redirected) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  if (parameters == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  for (Iterator iter=parameters.entrySet().iterator(); iter.hasNext(); ) {
    Map.Entry entry=(Map.Entry)iter.next();
    if (!(entry.getKey() instanceof String)) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
    if (!(entry.getValue() instanceof String[])) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
  }
  renderParameters.putAll(parameters);
  redirectAllowed=false;
}","public void setRenderParameters(Map parameters){
  if (redirected) {
    throw new IllegalStateException(""String_Node_Str"");
  }
  if (parameters == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  for (Iterator iter=parameters.entrySet().iterator(); iter.hasNext(); ) {
    Map.Entry entry=(Map.Entry)iter.next();
    if (!(entry.getKey() instanceof String)) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
    if (!(entry.getValue() instanceof String[])) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
  }
  renderParameters=StringUtils.copyParameters(parameters);
  redirectAllowed=false;
}",0.9384615384615383
90778,"public String[] getValues(String key,String[] def){
  if (key == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (changedPreferences.containsKey(key)) {
    return (String[])changedPreferences.get(key);
  }
  ListIterator iter=preferenceSetList.listIterator();
  if (removedPreferences.contains(key)) {
    iter.next();
  }
  Preference preference=null;
  while ((preference == null) && (iter.hasNext())) {
    preference=((PreferenceSet)iter.next()).get(key);
  }
  if (preference == null || !preference.isValueSet()) {
    return def;
  }
 else {
    return this.getValuesFromPreference(preference);
  }
}","public String[] getValues(String key,String[] def){
  if (key == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (changedPreferences.containsKey(key)) {
    return StringUtils.copy((String[])changedPreferences.get(key));
  }
  ListIterator iter=preferenceSetList.listIterator();
  if (removedPreferences.contains(key)) {
    iter.next();
  }
  Preference preference=null;
  while ((preference == null) && (iter.hasNext())) {
    preference=((PreferenceSet)iter.next()).get(key);
  }
  if (preference == null || !preference.isValueSet()) {
    return def;
  }
 else {
    String[] result=this.getValuesFromPreference(preference);
    if (result != null)     result=StringUtils.copy(result);
    return result;
  }
}",0.9121278140885984
90779,"public void setValues(String key,String[] values) throws ReadOnlyException {
  if (key == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (isReadOnly(key)) {
    throw new ReadOnlyException(""String_Node_Str"" + key + ""String_Node_Str"");
  }
  changedPreferences.put(key,values);
  removedPreferences.remove(key);
}","public void setValues(String key,String[] values) throws ReadOnlyException {
  if (key == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (isReadOnly(key)) {
    throw new ReadOnlyException(""String_Node_Str"" + key + ""String_Node_Str"");
  }
  changedPreferences.put(key,StringUtils.copy(values));
  removedPreferences.remove(key);
}",0.9571428571428572
90780,"public Map getParameterMap(){
  bodyAccessed=true;
  return Collections.unmodifiableMap(this._getHttpServletRequest().getParameterMap());
}","public Map getParameterMap(){
  bodyAccessed=true;
  Map result=StringUtils.copyParameters(this._getHttpServletRequest().getParameterMap());
  return result;
}",0.7248322147651006
90781,"public String[] getParameterValues(String name){
  if (name == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  bodyAccessed=true;
  Map parameters=this._getHttpServletRequest().getParameterMap();
  return (String[])parameters.get(name);
}","public String[] getParameterValues(String name){
  if (name == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  bodyAccessed=true;
  String[] values=(String[])this._getHttpServletRequest().getParameterMap().get(name);
  if (values != null)   values=StringUtils.copy(values);
  return values;
}",0.7482758620689656
90782,"public void setParameters(Map parameters){
  if (parameters == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  for (Iterator iter=parameters.entrySet().iterator(); iter.hasNext(); ) {
    Map.Entry entry=(Map.Entry)iter.next();
    if (!(entry.getKey() instanceof String)) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
    if (!(entry.getValue() instanceof String[])) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
  }
  this.parameters=new HashMap(parameters);
}","public void setParameters(Map parameters){
  if (parameters == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  for (Iterator iter=parameters.entrySet().iterator(); iter.hasNext(); ) {
    Map.Entry entry=(Map.Entry)iter.next();
    if (!(entry.getKey() instanceof String)) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
    if (!(entry.getValue() instanceof String[])) {
      throw new IllegalArgumentException(""String_Node_Str"");
    }
  }
  this.parameters=StringUtils.copyParameters(parameters);
}",0.96577243293247
90783,"public void setParameter(String name,String[] values){
  if (name == null || values == null || values.length == 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  parameters.put(name,values);
}","public void setParameter(String name,String[] values){
  if (name == null || values == null || values.length == 0) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  parameters.put(name,StringUtils.copy(values));
}",0.9321266968325792
90784,"private boolean isValidContentType(String type){
  return true;
}","private boolean isValidContentType(String type){
  type=stripCharacterEncoding(type);
  String wildcard=null;
  int index=type.indexOf(""String_Node_Str"");
  if (index > -1) {
    wildcard=type.substring(0,index);
  }
  PortletEntity entity=portletWindow.getPortletEntity();
  PortletDefinition def=entity.getPortletDefinition();
  ContentTypeSet contentTypes=def.getContentTypeSet();
  Iterator it=contentTypes.iterator();
  while (it.hasNext()) {
    ContentType ct=(ContentType)it.next();
    if (ct.getContentType().equals(type)) {
      return true;
    }
 else     if (ct.getContentType().equals(wildcard)) {
      return true;
    }
  }
  return false;
}",0.1434482758620689
90785,"public void init(ServletConfig config) throws ServletException {
  super.init(config);
  try {
    ServiceManager.init(config);
  }
 catch (  Throwable exc) {
    log(""String_Node_Str"",exc);
    throw (new javax.servlet.UnavailableException(""String_Node_Str""));
  }
  try {
    ServiceManager.postInit(config);
  }
 catch (  Throwable expos) {
    log(""String_Node_Str"",expos);
    throw (new javax.servlet.UnavailableException(""String_Node_Str""));
  }
  log=Log.getService().getLogger(getClass());
  if (!PortletContainerFactory.getPortletContainer().isInitialized()) {
    String uniqueContainerName=Config.getParameters().getString(""String_Node_Str"",""String_Node_Str"");
    if (log.isInfoEnabled())     log.info(""String_Node_Str"" + uniqueContainerName + ""String_Node_Str"");
    PortletContainerEnvironment environment=new PortletContainerEnvironment();
    environment.addContainerService(Log.getService());
    environment.addContainerService(FactoryManager.getService());
    environment.addContainerService(FactoryAccess.getInformationProviderContainerService());
    environment.addContainerService(FactoryAccess.getDynamicTitleContainerService());
    Properties properties=new Properties();
    try {
      PortletContainerFactory.getPortletContainer().init(uniqueContainerName,config,environment,properties);
    }
 catch (    PortletContainerException exc) {
      log.error(""String_Node_Str"",exc);
      throw (new javax.servlet.UnavailableException(""String_Node_Str""));
    }
  }
 else   if (log.isInfoEnabled()) {
    log.info(""String_Node_Str"");
  }
  log.debug(""String_Node_Str"");
}","public void init(ServletConfig config) throws ServletException {
  super.init(config);
  String charset=config.getInitParameter(""String_Node_Str"");
  if (charset != null && charset.length() > 0) {
    CONTENT_TYPE=""String_Node_Str"" + charset;
  }
  try {
    ServiceManager.init(config);
  }
 catch (  Throwable exc) {
    log(""String_Node_Str"",exc);
    throw (new javax.servlet.UnavailableException(""String_Node_Str""));
  }
  try {
    ServiceManager.postInit(config);
  }
 catch (  Throwable expos) {
    log(""String_Node_Str"",expos);
    throw (new javax.servlet.UnavailableException(""String_Node_Str""));
  }
  log=Log.getService().getLogger(getClass());
  if (!PortletContainerFactory.getPortletContainer().isInitialized()) {
    String uniqueContainerName=Config.getParameters().getString(""String_Node_Str"",""String_Node_Str"");
    if (log.isInfoEnabled())     log.info(""String_Node_Str"" + uniqueContainerName + ""String_Node_Str"");
    PortletContainerEnvironment environment=new PortletContainerEnvironment();
    environment.addContainerService(Log.getService());
    environment.addContainerService(FactoryManager.getService());
    environment.addContainerService(FactoryAccess.getInformationProviderContainerService());
    environment.addContainerService(FactoryAccess.getDynamicTitleContainerService());
    Properties properties=new Properties();
    try {
      PortletContainerFactory.getPortletContainer().init(uniqueContainerName,config,environment,properties);
    }
 catch (    PortletContainerException exc) {
      log.error(""String_Node_Str"",exc);
      throw (new javax.servlet.UnavailableException(""String_Node_Str""));
    }
  }
 else   if (log.isInfoEnabled()) {
    log.info(""String_Node_Str"");
  }
  log.debug(""String_Node_Str"");
}",0.9523241954707986
90786,"public void doGet(HttpServletRequest servletRequest,HttpServletResponse servletResponse) throws IOException, ServletException {
  servletResponse.setContentType(""String_Node_Str"");
  PortalEnvironment env=new PortalEnvironment(servletRequest,servletResponse,getServletConfig());
  PortalURL currentURL=env.getRequestedPortalURL();
  PortalControlParameter control=new PortalControlParameter(currentURL);
  PortletWindow actionWindow=control.getPortletWindowOfAction();
  if (actionWindow != null) {
    try {
      PortletContainerFactory.getPortletContainer().processPortletAction(actionWindow,ServletObjectAccess.getServletRequest(servletRequest,actionWindow),ServletObjectAccess.getServletResponse(servletResponse));
    }
 catch (    PortletException e) {
      e.printStackTrace(System.err);
    }
catch (    PortletContainerException e) {
      e.printStackTrace(System.err);
    }
catch (    Exception e) {
      e.printStackTrace(System.err);
    }
    return;
  }
  try {
    RootFragment root=PageRegistry.getRootFragment();
    root.service(servletRequest,servletResponse);
  }
 catch (  Throwable t) {
    ;
  }
 finally {
  }
}","public void doGet(HttpServletRequest servletRequest,HttpServletResponse servletResponse) throws IOException, ServletException {
  servletResponse.setContentType(CONTENT_TYPE);
  PortalEnvironment env=new PortalEnvironment(servletRequest,servletResponse,getServletConfig());
  PortalURL currentURL=env.getRequestedPortalURL();
  PortalControlParameter control=new PortalControlParameter(currentURL);
  PortletWindow actionWindow=control.getPortletWindowOfAction();
  if (actionWindow != null) {
    try {
      PortletContainerFactory.getPortletContainer().processPortletAction(actionWindow,ServletObjectAccess.getServletRequest(servletRequest,actionWindow),ServletObjectAccess.getServletResponse(servletResponse));
    }
 catch (    PortletException e) {
      e.printStackTrace(System.err);
    }
catch (    PortletContainerException e) {
      e.printStackTrace(System.err);
    }
catch (    Exception e) {
      e.printStackTrace(System.err);
    }
    return;
  }
  try {
    RootFragment root=PageRegistry.getRootFragment();
    root.service(servletRequest,servletResponse);
  }
 catch (  Throwable t) {
    ;
  }
 finally {
  }
}",0.9881318681318682
90787,"public void processPortletAction(PortletWindow portletWindow,HttpServletRequest servletRequest,HttpServletResponse servletResponse) throws PortletException, IOException, PortletContainerException {
  PortletContainerServices.prepare(uniqueContainerName);
  PortletInvoker invoker=null;
  if (log.isDebugEnabled()) {
    log.debug(""String_Node_Str"" + portletWindow.getId() + ""String_Node_Str"");
  }
  String location=null;
  InternalActionResponse _actionResponse=null;
  ActionRequest actionRequest=null;
  try {
    actionRequest=PortletObjectAccess.getActionRequest(portletWindow,servletRequest,servletResponse);
    ActionResponse actionResponse=PortletObjectAccess.getActionResponse(portletWindow,servletRequest,servletResponse);
    invoker=PortletInvokerAccess.getPortletInvoker(portletWindow.getPortletEntity().getPortletDefinition());
    _actionResponse=(InternalActionResponse)actionResponse;
    invoker.action(actionRequest,actionResponse);
    location=_actionResponse.getRedirectLocation();
  }
 catch (  PortletException e) {
    throw e;
  }
catch (  IOException e) {
    throw e;
  }
catch (  RuntimeException e) {
    throw e;
  }
 finally {
    try {
      if (location == null && _actionResponse != null) {
        DynamicInformationProvider provider=InformationProviderAccess.getDynamicProvider(servletRequest);
        if (_actionResponse.getChangedPortletMode() != null) {
          InformationProviderAccess.getDynamicProvider(servletRequest).getPortletActionProvider(portletWindow).changePortletMode(_actionResponse.getChangedPortletMode());
        }
        if (_actionResponse.getChangedWindowState() != null) {
          InformationProviderAccess.getDynamicProvider(servletRequest).getPortletActionProvider(portletWindow).changePortletWindowState(_actionResponse.getChangedWindowState());
        }
        Map renderParameter=_actionResponse.getRenderParameters();
        PortletURLProvider redirectURL=provider.getPortletURLProvider(portletWindow);
        if (provider.getPortletMode(portletWindow) != null) {
          redirectURL.setPortletMode(provider.getPortletMode(portletWindow));
        }
        if (provider.getWindowState(portletWindow) != null) {
          redirectURL.setWindowState(provider.getWindowState(portletWindow));
        }
        redirectURL.clearParameters();
        redirectURL.setParameters(renderParameter);
        location=servletResponse.encodeRedirectURL(redirectURL.toString());
      }
      javax.servlet.http.HttpServletResponse redirectResponse=servletResponse;
      while (redirectResponse instanceof javax.servlet.http.HttpServletResponseWrapper) {
        redirectResponse=(javax.servlet.http.HttpServletResponse)((javax.servlet.http.HttpServletResponseWrapper)redirectResponse).getResponse();
      }
      redirectResponse.sendRedirect(location);
    }
  finally {
      PortletInvokerAccess.releasePortletInvoker(invoker);
      PortletContainerServices.release();
    }
  }
}","public void processPortletAction(PortletWindow portletWindow,HttpServletRequest servletRequest,HttpServletResponse servletResponse) throws PortletException, IOException, PortletContainerException {
  PortletContainerServices.prepare(uniqueContainerName);
  PortletInvoker invoker=null;
  if (log.isDebugEnabled()) {
    log.debug(""String_Node_Str"" + portletWindow.getId() + ""String_Node_Str"");
  }
  String location=null;
  InternalActionResponse _actionResponse=null;
  ActionRequest actionRequest=null;
  try {
    actionRequest=PortletObjectAccess.getActionRequest(portletWindow,servletRequest,servletResponse);
    ActionResponse actionResponse=PortletObjectAccess.getActionResponse(portletWindow,servletRequest,servletResponse);
    invoker=PortletInvokerAccess.getPortletInvoker(portletWindow.getPortletEntity().getPortletDefinition());
    _actionResponse=(InternalActionResponse)actionResponse;
    invoker.action(actionRequest,actionResponse);
    location=_actionResponse.getRedirectLocation();
  }
 catch (  PortletException e) {
    throw e;
  }
catch (  IOException e) {
    throw e;
  }
catch (  RuntimeException e) {
    throw e;
  }
 finally {
    try {
      redirect(location,portletWindow,servletRequest,servletResponse,_actionResponse);
    }
  finally {
      PortletInvokerAccess.releasePortletInvoker(invoker);
      PortletContainerServices.release();
    }
  }
}",0.5539949343771586
90788,"public void postLoad(Object parameter) throws Exception {
  locales.addAll((Collection)parameter);
  initInlinedInfos();
}","public void postLoad(Object parameter) throws Exception {
  locales.addAll((Collection)parameter);
  initInlinedInfos();
  if (resources != null)   initResourceBundle();
}",0.8327645051194539
90789,"public static void prepareWebArchive(String webAppsDir,String warFile) throws Exception, IOException {
  String webModule=warFile;
  if (webModule.indexOf(""String_Node_Str"") != -1)   webModule=webModule.substring(webModule.lastIndexOf(""String_Node_Str"") + 1);
  if (webModule.indexOf(dirDelim) != -1)   webModule=webModule.substring(webModule.lastIndexOf(dirDelim) + 1);
  if (webModule.endsWith(""String_Node_Str""))   webModule=webModule.substring(0,webModule.lastIndexOf(""String_Node_Str""));
  System.out.println(""String_Node_Str"" + webModule + ""String_Node_Str"");
  Mapping mappingPortletXml=null;
  Mapping mappingWebXml=null;
  String _portlet_mapping=webAppsDir + portalImplWebDir + ""String_Node_Str""+ dirDelim+ ""String_Node_Str""+ dirDelim+ ""String_Node_Str""+ dirDelim+ ""String_Node_Str"";
  mappingPortletXml=new Mapping();
  try {
    mappingPortletXml.loadMapping(_portlet_mapping);
  }
 catch (  Exception e) {
    System.out.println(""String_Node_Str"" + e);
    throw new IOException(""String_Node_Str"" + _portlet_mapping);
  }
  File portletXml=new File(webAppsDir + webModule + webInfDir+ ""String_Node_Str"");
  String _web_mapping=webAppsDir + portalImplWebDir + ""String_Node_Str""+ dirDelim+ ""String_Node_Str""+ dirDelim+ ""String_Node_Str""+ dirDelim+ ""String_Node_Str"";
  mappingWebXml=new Mapping();
  try {
    mappingWebXml.loadMapping(_web_mapping);
  }
 catch (  Exception e) {
    throw new IOException(""String_Node_Str"" + _web_mapping);
  }
  File webXml=new File(webAppsDir + webModule + webInfDir+ ""String_Node_Str"");
  try {
    org.w3c.dom.Document portletDocument=XmlParser.parsePortletXml(new FileInputStream(portletXml));
    Unmarshaller unmarshaller=new Unmarshaller(mappingPortletXml);
    PortletApplicationDefinitionImpl portletApp=(PortletApplicationDefinitionImpl)unmarshaller.unmarshal(portletDocument);
    Vector structure=new Vector();
    structure.add(webModule);
    structure.add(null);
    structure.add(null);
    portletApp.preBuild(structure);
    if (debug) {
      System.out.println(portletApp);
    }
    WebApplicationDefinitionImpl webApp=null;
    if (webXml.exists()) {
      org.w3c.dom.Document webDocument=XmlParser.parseWebXml(new FileInputStream(webXml));
      Unmarshaller unmarshallerWeb=new Unmarshaller(mappingWebXml);
      webApp=(WebApplicationDefinitionImpl)unmarshallerWeb.unmarshal(webDocument);
    }
 else {
      webApp=new WebApplicationDefinitionImpl();
      DisplayNameImpl dispName=new DisplayNameImpl();
      dispName.setDisplayName(webModule);
      dispName.setLocale(Locale.ENGLISH);
      DisplayNameSetImpl dispSet=new DisplayNameSetImpl();
      dispSet.add(dispName);
      webApp.setDisplayNames((DisplayNameSet)dispSet);
      DescriptionImpl desc=new DescriptionImpl();
      desc.setDescription(""String_Node_Str"");
      desc.setLocale(Locale.ENGLISH);
      DescriptionSetImpl descSet=new DescriptionSetImpl();
      descSet.add(desc);
      webApp.setDescriptions((DescriptionSet)descSet);
    }
    org.apache.pluto.om.ControllerFactory controllerFactory=new org.apache.pluto.portalImpl.om.ControllerFactoryImpl();
    ServletDefinitionListCtrl servletDefinitionSetCtrl=(ServletDefinitionListCtrl)controllerFactory.get(webApp.getServletDefinitionList());
    Collection servletMappings=webApp.getServletMappings();
    Iterator portlets=portletApp.getPortletDefinitionList().iterator();
    while (portlets.hasNext()) {
      PortletDefinition portlet=(PortletDefinition)portlets.next();
      ServletDefinition servlet=webApp.getServletDefinitionList().get(portlet.getName());
      if (servlet != null) {
        if (!servlet.getServletClass().equals(""String_Node_Str"")) {
          System.out.println(""String_Node_Str"" + portlet.getName() + ""String_Node_Str"");
        }
        ServletDefinitionCtrl _servletCtrl=(ServletDefinitionCtrl)controllerFactory.get(servlet);
        _servletCtrl.setServletClass(""String_Node_Str"");
      }
 else {
        servlet=servletDefinitionSetCtrl.add(portlet.getName(),""String_Node_Str"");
      }
      ServletDefinitionCtrl servletCtrl=(ServletDefinitionCtrl)controllerFactory.get(servlet);
      DisplayNameImpl dispName=new DisplayNameImpl();
      dispName.setDisplayName(portlet.getName() + ""String_Node_Str"");
      dispName.setLocale(Locale.ENGLISH);
      DisplayNameSetImpl dispSet=new DisplayNameSetImpl();
      dispSet.add(dispName);
      servletCtrl.setDisplayNames((DisplayNameSet)dispSet);
      DescriptionImpl desc=new DescriptionImpl();
      desc.setDescription(""String_Node_Str"");
      desc.setLocale(Locale.ENGLISH);
      DescriptionSetImpl descSet=new DescriptionSetImpl();
      descSet.add(desc);
      servletCtrl.setDescriptions(descSet);
      ParameterSet parameters=servlet.getInitParameterSet();
      ParameterSetCtrl parameterSetCtrl=(ParameterSetCtrl)controllerFactory.get(parameters);
      Parameter parameter1=parameters.get(""String_Node_Str"");
      if (parameter1 == null) {
        parameterSetCtrl.add(""String_Node_Str"",portlet.getClassName());
      }
 else {
        ParameterCtrl parameterCtrl=(ParameterCtrl)controllerFactory.get(parameter1);
        parameterCtrl.setValue(portlet.getClassName());
      }
      Parameter parameter2=parameters.get(""String_Node_Str"");
      if (parameter2 == null) {
        parameterSetCtrl.add(""String_Node_Str"",portlet.getId().toString());
      }
 else {
        ParameterCtrl parameterCtrl=(ParameterCtrl)controllerFactory.get(parameter2);
        parameterCtrl.setValue(portlet.getId().toString());
      }
      boolean found=false;
      Iterator mappings=servletMappings.iterator();
      while (mappings.hasNext()) {
        ServletMappingImpl servletMapping=(ServletMappingImpl)mappings.next();
        if (servletMapping.getServletName().equals(portlet.getName())) {
          found=true;
          servletMapping.setUrlPattern(""String_Node_Str"" + portlet.getName().replace(' ','_') + ""String_Node_Str"");
        }
      }
      if (!found) {
        ServletMappingImpl servletMapping=new ServletMappingImpl();
        servletMapping.setServletName(portlet.getName());
        servletMapping.setUrlPattern(""String_Node_Str"" + portlet.getName().replace(' ','_') + ""String_Node_Str"");
        servletMappings.add(servletMapping);
      }
      SecurityRoleRefSet servletSecurityRoleRefs=((ServletDefinitionImpl)servlet).getInitSecurityRoleRefSet();
      SecurityRoleRefSetCtrl servletSecurityRoleRefSetCtrl=(SecurityRoleRefSetCtrl)controllerFactory.get(servletSecurityRoleRefs);
      SecurityRoleSet webAppSecurityRoles=webApp.getSecurityRoles();
      SecurityRoleRefSet portletSecurityRoleRefs=portlet.getInitSecurityRoleRefSet();
      SecurityRoleRefSetCtrl portletSecurityRoleRefSetCtrl=(SecurityRoleRefSetCtrl)controllerFactory.get(portletSecurityRoleRefs);
      Iterator p=portletSecurityRoleRefs.iterator();
      while (p.hasNext()) {
        SecurityRoleRef portletSecurityRoleRef=(SecurityRoleRef)p.next();
        if (portletSecurityRoleRef.getRoleLink() == null && webAppSecurityRoles.get(portletSecurityRoleRef.getRoleName()) == null) {
          System.out.println(""String_Node_Str"" + portletSecurityRoleRef.getRoleName() + ""String_Node_Str""+ portlet.getName()+ ""String_Node_Str"");
          break;
        }
        SecurityRoleRef servletSecurityRoleRef=servletSecurityRoleRefs.get(portletSecurityRoleRef.getRoleName());
        if (null != servletSecurityRoleRef) {
          System.out.println(""String_Node_Str"" + portletSecurityRoleRef.getRoleName() + ""String_Node_Str""+ portlet.getName()+ ""String_Node_Str"");
          servletSecurityRoleRefSetCtrl.remove(servletSecurityRoleRef);
        }
        servletSecurityRoleRefSetCtrl.add(portletSecurityRoleRef);
      }
    }
    if (debug) {
      System.out.println(webApp);
    }
    OutputFormat of=new OutputFormat();
    of.setIndenting(true);
    of.setIndent(4);
    of.setLineWidth(16384);
    of.setDoctype(Constants.WEB_PORTLET_PUBLIC_ID,Constants.WEB_PORTLET_DTD);
    FileWriter writer=new FileWriter(webAppsDir + webModule + System.getProperty(""String_Node_Str"")+ ""String_Node_Str""+ System.getProperty(""String_Node_Str"")+ ""String_Node_Str"");
    XMLSerializer serializer=new XMLSerializer(writer,of);
    try {
      Marshaller marshaller=new Marshaller(serializer.asDocumentHandler());
      marshaller.setMapping(mappingWebXml);
      marshaller.marshal(webApp);
    }
 catch (    Exception e) {
      writer.close();
      e.printStackTrace(System.out);
      throw new Exception();
    }
    String strTo=dirDelim + ""String_Node_Str"" + dirDelim+ ""String_Node_Str""+ dirDelim+ ""String_Node_Str"";
    String strFrom=""String_Node_Str"" + dirDelim + ""String_Node_Str""+ strTo;
    copy(strFrom,webAppsDir + webModule + strTo);
  }
 catch (  Exception e) {
    e.printStackTrace(System.out);
    throw new Exception();
  }
  System.out.println(""String_Node_Str"");
}","public static void prepareWebArchive(String webAppsDir,String warFile) throws Exception, IOException {
  String webModule=warFile;
  if (webModule.indexOf(""String_Node_Str"") != -1)   webModule=webModule.substring(webModule.lastIndexOf(""String_Node_Str"") + 1);
  if (webModule.indexOf(dirDelim) != -1)   webModule=webModule.substring(webModule.lastIndexOf(dirDelim) + 1);
  if (webModule.endsWith(""String_Node_Str""))   webModule=webModule.substring(0,webModule.lastIndexOf(""String_Node_Str""));
  System.out.println(""String_Node_Str"" + webModule + ""String_Node_Str"");
  Mapping mappingPortletXml=null;
  Mapping mappingWebXml=null;
  String _portlet_mapping=webAppsDir + portalImplWebDir + ""String_Node_Str""+ dirDelim+ ""String_Node_Str""+ dirDelim+ ""String_Node_Str""+ dirDelim+ ""String_Node_Str"";
  mappingPortletXml=new Mapping();
  try {
    mappingPortletXml.loadMapping(_portlet_mapping);
  }
 catch (  Exception e) {
    System.out.println(""String_Node_Str"" + e);
    throw new IOException(""String_Node_Str"" + _portlet_mapping);
  }
  File portletXml=new File(webAppsDir + webModule + webInfDir+ ""String_Node_Str"");
  String _web_mapping=webAppsDir + portalImplWebDir + ""String_Node_Str""+ dirDelim+ ""String_Node_Str""+ dirDelim+ ""String_Node_Str""+ dirDelim+ ""String_Node_Str"";
  mappingWebXml=new Mapping();
  try {
    mappingWebXml.loadMapping(_web_mapping);
  }
 catch (  Exception e) {
    throw new IOException(""String_Node_Str"" + _web_mapping);
  }
  File webXml=new File(webAppsDir + webModule + webInfDir+ ""String_Node_Str"");
  try {
    org.w3c.dom.Document portletDocument=XmlParser.parsePortletXml(new FileInputStream(portletXml));
    Unmarshaller unmarshaller=new Unmarshaller(mappingPortletXml);
    PortletApplicationDefinitionImpl portletApp=(PortletApplicationDefinitionImpl)unmarshaller.unmarshal(portletDocument);
    Vector structure=new Vector();
    structure.add(webModule);
    structure.add(null);
    structure.add(null);
    portletApp.preBuild(structure);
    if (debug) {
      System.out.println(portletApp);
    }
    WebApplicationDefinitionImpl webApp=null;
    if (webXml.exists()) {
      org.w3c.dom.Document webDocument=XmlParser.parseWebXml(new FileInputStream(webXml));
      Unmarshaller unmarshallerWeb=new Unmarshaller(mappingWebXml);
      webApp=(WebApplicationDefinitionImpl)unmarshallerWeb.unmarshal(webDocument);
    }
 else {
      webApp=new WebApplicationDefinitionImpl();
      DisplayNameImpl dispName=new DisplayNameImpl();
      dispName.setDisplayName(webModule);
      dispName.setLocale(Locale.ENGLISH);
      DisplayNameSetImpl dispSet=new DisplayNameSetImpl();
      dispSet.add(dispName);
      webApp.setDisplayNames((DisplayNameSet)dispSet);
      DescriptionImpl desc=new DescriptionImpl();
      desc.setDescription(""String_Node_Str"");
      desc.setLocale(Locale.ENGLISH);
      DescriptionSetImpl descSet=new DescriptionSetImpl();
      descSet.add(desc);
      webApp.setDescriptions((DescriptionSet)descSet);
    }
    org.apache.pluto.om.ControllerFactory controllerFactory=new org.apache.pluto.portalImpl.om.ControllerFactoryImpl();
    ServletDefinitionListCtrl servletDefinitionSetCtrl=(ServletDefinitionListCtrl)controllerFactory.get(webApp.getServletDefinitionList());
    Collection servletMappings=webApp.getServletMappings();
    Iterator portlets=portletApp.getPortletDefinitionList().iterator();
    while (portlets.hasNext()) {
      PortletDefinition portlet=(PortletDefinition)portlets.next();
      ServletDefinition servlet=webApp.getServletDefinitionList().get(portlet.getName());
      if (servlet != null) {
        if (!servlet.getServletClass().equals(""String_Node_Str"")) {
          System.out.println(""String_Node_Str"" + portlet.getName() + ""String_Node_Str"");
        }
        ServletDefinitionCtrl _servletCtrl=(ServletDefinitionCtrl)controllerFactory.get(servlet);
        _servletCtrl.setServletClass(""String_Node_Str"");
      }
 else {
        servlet=servletDefinitionSetCtrl.add(portlet.getName(),""String_Node_Str"");
      }
      ServletDefinitionCtrl servletCtrl=(ServletDefinitionCtrl)controllerFactory.get(servlet);
      DisplayNameImpl dispName=new DisplayNameImpl();
      dispName.setDisplayName(portlet.getName() + ""String_Node_Str"");
      dispName.setLocale(Locale.ENGLISH);
      DisplayNameSetImpl dispSet=new DisplayNameSetImpl();
      dispSet.add(dispName);
      servletCtrl.setDisplayNames((DisplayNameSet)dispSet);
      DescriptionImpl desc=new DescriptionImpl();
      desc.setDescription(""String_Node_Str"");
      desc.setLocale(Locale.ENGLISH);
      DescriptionSetImpl descSet=new DescriptionSetImpl();
      descSet.add(desc);
      servletCtrl.setDescriptions(descSet);
      ParameterSet parameters=servlet.getInitParameterSet();
      ParameterSetCtrl parameterSetCtrl=(ParameterSetCtrl)controllerFactory.get(parameters);
      Parameter parameter1=parameters.get(""String_Node_Str"");
      if (parameter1 == null) {
        parameterSetCtrl.add(""String_Node_Str"",portlet.getClassName());
      }
 else {
        ParameterCtrl parameterCtrl=(ParameterCtrl)controllerFactory.get(parameter1);
        parameterCtrl.setValue(portlet.getClassName());
      }
      Parameter parameter2=parameters.get(""String_Node_Str"");
      if (parameter2 == null) {
        parameterSetCtrl.add(""String_Node_Str"",portlet.getId().toString());
      }
 else {
        ParameterCtrl parameterCtrl=(ParameterCtrl)controllerFactory.get(parameter2);
        parameterCtrl.setValue(portlet.getId().toString());
      }
      boolean found=false;
      Iterator mappings=servletMappings.iterator();
      while (mappings.hasNext()) {
        ServletMappingImpl servletMapping=(ServletMappingImpl)mappings.next();
        if (servletMapping.getServletName().equals(portlet.getName())) {
          found=true;
          servletMapping.setUrlPattern(""String_Node_Str"" + portlet.getName().replace(' ','_') + ""String_Node_Str"");
        }
      }
      if (!found) {
        ServletMappingImpl servletMapping=new ServletMappingImpl();
        servletMapping.setServletName(portlet.getName());
        servletMapping.setUrlPattern(""String_Node_Str"" + portlet.getName().replace(' ','_') + ""String_Node_Str"");
        servletMappings.add(servletMapping);
      }
      SecurityRoleRefSet servletSecurityRoleRefs=((ServletDefinitionImpl)servlet).getInitSecurityRoleRefSet();
      SecurityRoleRefSetCtrl servletSecurityRoleRefSetCtrl=(SecurityRoleRefSetCtrl)controllerFactory.get(servletSecurityRoleRefs);
      SecurityRoleSet webAppSecurityRoles=webApp.getSecurityRoles();
      SecurityRoleRefSet portletSecurityRoleRefs=portlet.getInitSecurityRoleRefSet();
      SecurityRoleRefSetCtrl portletSecurityRoleRefSetCtrl=(SecurityRoleRefSetCtrl)controllerFactory.get(portletSecurityRoleRefs);
      Iterator p=portletSecurityRoleRefs.iterator();
      while (p.hasNext()) {
        SecurityRoleRef portletSecurityRoleRef=(SecurityRoleRef)p.next();
        if (portletSecurityRoleRef.getRoleLink() == null && webAppSecurityRoles.get(portletSecurityRoleRef.getRoleName()) == null) {
          System.out.println(""String_Node_Str"" + portletSecurityRoleRef.getRoleName() + ""String_Node_Str""+ portlet.getName()+ ""String_Node_Str"");
          break;
        }
        SecurityRoleRef servletSecurityRoleRef=servletSecurityRoleRefs.get(portletSecurityRoleRef.getRoleName());
        if (null != servletSecurityRoleRef) {
          System.out.println(""String_Node_Str"" + portletSecurityRoleRef.getRoleName() + ""String_Node_Str""+ portlet.getName()+ ""String_Node_Str"");
          servletSecurityRoleRefSetCtrl.remove(servletSecurityRoleRef);
        }
        servletSecurityRoleRefSetCtrl.add(portletSecurityRoleRef);
      }
    }
    if (debug) {
      System.out.println(webApp);
    }
    OutputFormat of=new OutputFormat();
    of.setIndenting(true);
    of.setIndent(4);
    of.setLineWidth(16384);
    of.setDoctype(Constants.WEB_PORTLET_PUBLIC_ID,Constants.WEB_PORTLET_DTD);
    FileWriter writer=new FileWriter(webAppsDir + webModule + System.getProperty(""String_Node_Str"")+ ""String_Node_Str""+ System.getProperty(""String_Node_Str"")+ ""String_Node_Str"");
    XMLSerializer serializer=new XMLSerializer(writer,of);
    try {
      Marshaller marshaller=new Marshaller(serializer.asDocumentHandler());
      marshaller.setMapping(mappingWebXml);
      marshaller.marshal(webApp);
    }
 catch (    Exception e) {
      writer.close();
      e.printStackTrace(System.out);
      throw new Exception();
    }
    String strTo=dirDelim + ""String_Node_Str"" + dirDelim+ ""String_Node_Str""+ dirDelim+ ""String_Node_Str"";
    String strFrom=""String_Node_Str"" + dirDelim + ""String_Node_Str""+ dirDelim+ ""String_Node_Str""+ dirDelim+ ""String_Node_Str""+ strTo;
    copy(strFrom,webAppsDir + webModule + strTo);
  }
 catch (  Exception e) {
    e.printStackTrace(System.out);
    throw new Exception();
  }
  System.out.println(""String_Node_Str"");
}",0.9967390082087034
90790,"public void addProperty(String key,String value){
  if (key == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  Map map=PropertyManager.getRequestProperties(portletWindow,this.getHttpServletRequest());
  if (map == null) {
    map=new HashMap();
  }
  String[] properties=(String[])map.get(key);
  if (properties == null) {
    properties=new String[]{value};
  }
 else {
    properties[properties.length]=value;
  }
  map.put(key,properties);
  PropertyManager.setResponseProperties(portletWindow,this.getHttpServletRequest(),_getHttpServletResponse(),map);
}","public void addProperty(String key,String value){
  if (key == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  Map props=getProperties();
  String[] oldValues=(String[])props.get(key);
  String[] newValues=null;
  if (oldValues == null) {
    newValues=new String[]{value};
  }
 else {
    int len=oldValues.length;
    newValues=new String[len + 1];
    System.arraycopy(oldValues,0,newValues,0,len);
    newValues[len]=value;
  }
  props.put(key,newValues);
  PropertyManager.setResponseProperties(portletWindow,this.getHttpServletRequest(),_getHttpServletResponse(),props);
}",0.4262847514743049
90791,"public void setProperty(String key,String value){
  if (key == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  Map map=PropertyManager.getRequestProperties(portletWindow,this.getHttpServletRequest());
  if (map == null) {
    map=new HashMap();
  }
  String[] properties=new String[]{value};
  map.put(key,properties);
  PropertyManager.setResponseProperties(portletWindow,getHttpServletRequest(),_getHttpServletResponse(),map);
}","public void setProperty(String key,String value){
  if (key == null) {
    throw new IllegalArgumentException(""String_Node_Str"");
  }
  Map props=getProperties();
  String[] newValues=new String[]{value};
  props.put(key,newValues);
  PropertyManager.setResponseProperties(portletWindow,this.getHttpServletRequest(),_getHttpServletResponse(),props);
}",0.7642679900744417
90792,"/** 
 * Returns the elements of this set
 * @return An iterator containg all elements
 */
public java.util.Iterator iterator(){
  return windows.entrySet().iterator();
}","/** 
 * Returns the elements of this set
 * @return An iterator containg all elements
 */
public java.util.Iterator iterator(){
  return windows.values().iterator();
}",0.9642857142857144
90793,"public String evaluateOldValue() throws ExpressionEvaluationException {
  try {
    String value=oldValueEvaluator.evaluate();
    logger.info(""String_Node_Str"" + expression + ""String_Node_Str""+ value);
    return value;
  }
 catch (  EvaluationException e) {
    throw new ExpressionEvaluationException(""String_Node_Str"" + expression + ""String_Node_Str"",e);
  }
}","public String evaluateOldValue() throws ExpressionEvaluationException {
  try {
    String value=oldValueEvaluator.evaluate();
    logger.log(Level.INFO,""String_Node_Str"",new Object[]{expression,value,value.startsWith(""String_Node_Str"") ? ""String_Node_Str"" : ""String_Node_Str""});
    return value;
  }
 catch (  EvaluationException e) {
    throw new ExpressionEvaluationException(""String_Node_Str"" + expression + ""String_Node_Str"",e);
  }
}",0.4919254658385093
90794,"public String evaluateValue() throws ExpressionEvaluationException {
  try {
    String value=valueEvaluator.evaluate();
    logger.info(""String_Node_Str"" + expression + ""String_Node_Str""+ value);
    return value;
  }
 catch (  EvaluationException e) {
    throw new ExpressionEvaluationException(""String_Node_Str"" + expression + ""String_Node_Str"",e);
  }
}","public String evaluateValue() throws ExpressionEvaluationException {
  try {
    String value=valueEvaluator.evaluate();
    logger.log(Level.INFO,""String_Node_Str"",new Object[]{expression,value,value.startsWith(""String_Node_Str"") ? ""String_Node_Str"" : ""String_Node_Str""});
    return value;
  }
 catch (  EvaluationException e) {
    throw new ExpressionEvaluationException(""String_Node_Str"" + expression + ""String_Node_Str"",e);
  }
}",0.4842370744010088
90795,"public Object evaluateOldValue() throws ExpressionEvaluationException {
  try {
    FunctionElementArgument<?> evaluate=this.oldEval.evaluate();
    logger.info(""String_Node_Str"" + expression + ""String_Node_Str""+ evaluate.getValue());
    return evaluate.getValue();
  }
 catch (  RuntimeException e) {
    throw new ExpressionEvaluationException(""String_Node_Str"" + expression + ""String_Node_Str"",e);
  }
}","public Object evaluateOldValue() throws ExpressionEvaluationException {
  try {
    FunctionElementArgument<?> evaluate=this.oldEval.evaluate();
    logger.log(Level.INFO,""String_Node_Str"",new Object[]{expression,evaluate.getValue(),evaluate.getType()});
    return evaluate.getValue();
  }
 catch (  RuntimeException e) {
    throw new ExpressionEvaluationException(""String_Node_Str"" + expression + ""String_Node_Str"",e);
  }
}",0.4940047961630695
90796,"public Object evaluateValue() throws ExpressionEvaluationException {
  try {
    FunctionElementArgument<?> evaluate=this.newEval.evaluate();
    logger.info(""String_Node_Str"" + expression + ""String_Node_Str""+ evaluate.getValue());
    return evaluate.getValue();
  }
 catch (  RuntimeException e) {
    throw new ExpressionEvaluationException(""String_Node_Str"" + expression + ""String_Node_Str"",e);
  }
}","public Object evaluateValue() throws ExpressionEvaluationException {
  try {
    FunctionElementArgument<?> evaluate=this.newEval.evaluate();
    logger.log(Level.INFO,""String_Node_Str"",new Object[]{expression,evaluate.getValue(),evaluate.getType()});
    return evaluate.getValue();
  }
 catch (  RuntimeException e) {
    throw new ExpressionEvaluationException(""String_Node_Str"" + expression + ""String_Node_Str"",e);
  }
}",0.4903381642512077
90797,"@Override public Object getValue() throws ExpressionEvaluationException {
  try {
    return this.expression.evaluateValue();
  }
 catch (  Exception e) {
    logger.log(Level.SEVERE,""String_Node_Str"" + expression.getExpression(),e);
    throw new ExpressionEvaluationException(e);
  }
}","@Override public Object getValue() throws ExpressionEvaluationException {
  try {
    return doCast(this.expression.evaluateValue());
  }
 catch (  Exception e) {
    logger.log(Level.SEVERE,""String_Node_Str"" + expression.getExpression(),e);
    throw new ExpressionEvaluationException(e);
  }
}",0.986254295532646
90798,"@Override public Object getOldValue() throws ExpressionEvaluationException {
  try {
    return this.expression.evaluateOldValue();
  }
 catch (  Exception e) {
    logger.log(Level.SEVERE,""String_Node_Str"" + expression.getExpression(),e);
    throw new ExpressionEvaluationException(e);
  }
}","@Override public Object getOldValue() throws ExpressionEvaluationException {
  try {
    return doCast(this.expression.evaluateOldValue());
  }
 catch (  Exception e) {
    logger.log(Level.SEVERE,""String_Node_Str"" + expression.getExpression(),e);
    throw new ExpressionEvaluationException(e);
  }
}",0.9865319865319864
90799,"@Override protected FunctionElementArgument<String> execute(FunctionElementArgument<String> a,FunctionElementArgument<String> b) throws IllegalArgumentException {
  SimpleDateFormat dateFormat=new SimpleDateFormat(""String_Node_Str"");
  Date d=null;
  try {
    d=dateFormat.parse(b.getValue());
  }
 catch (  ParseException e) {
    throw new IllegalArgumentException(e);
  }
  Long date=d.getTime();
  Calendar calendar=Calendar.getInstance();
  calendar.setTimeInMillis(date);
  int year=calendar.get(Calendar.YEAR);
  int month=calendar.get(Calendar.MONTH);
  calendar.clear();
  calendar.set(Calendar.YEAR,year);
  if (a.getValue().equalsIgnoreCase(MODE_MONTH)) {
    calendar.set(Calendar.MONTH,month);
  }
  date=calendar.getTimeInMillis();
  return FunctionArgumentFactory.createString(date.toString());
}","@Override protected FunctionElementArgument<Date> execute(FunctionElementArgument<String> a,FunctionElementArgument<Date> b) throws IllegalArgumentException {
  Long date=b.getValue().getTime();
  Calendar calendar=Calendar.getInstance();
  calendar.setTimeInMillis(date);
  int year=calendar.get(Calendar.YEAR);
  int month=calendar.get(Calendar.MONTH);
  calendar.clear();
  calendar.set(Calendar.YEAR,year);
  if (a.getValue().equalsIgnoreCase(MODE_MONTH)) {
    calendar.set(Calendar.MONTH,month);
  }
  date=calendar.getTimeInMillis();
  return FunctionArgumentFactory.createObject(new Date(date));
}",0.8016937191249118
90800,"private FunctionElementArgument<?> replaceVariable(Object value){
  if (value instanceof Integer) {
    return FunctionArgumentFactory.createObject((Integer)value);
  }
  if (value instanceof Double) {
    return FunctionArgumentFactory.createObject((Double)value);
  }
  if (value instanceof String) {
    return FunctionArgumentFactory.createString((String)value);
  }
  if (value instanceof Boolean) {
    return FunctionArgumentFactory.createObject((Boolean)value);
  }
  if (value instanceof Object) {
    return FunctionArgumentFactory.createObject(value);
  }
  return new NullArgument();
}","private FunctionElementArgument<?> replaceVariable(Object value){
  if (value instanceof Integer) {
    return FunctionArgumentFactory.createObject((Integer)value);
  }
  if (value instanceof Double) {
    return FunctionArgumentFactory.createObject((Double)value);
  }
  if (value instanceof Long) {
    return FunctionArgumentFactory.createObject((Long)value);
  }
  if (value instanceof Date) {
    return FunctionArgumentFactory.createObject((Date)value);
  }
  if (value instanceof String) {
    return FunctionArgumentFactory.createString((String)value);
  }
  if (value instanceof Boolean) {
    return FunctionArgumentFactory.createObject((Boolean)value);
  }
  if (value instanceof Object) {
    return FunctionArgumentFactory.createObject(value);
  }
  return new NullArgument();
}",0.80835734870317
90801,"public FunctionElementArgument<?> evaluate(){
  if (expression == null || expression.isEmpty()) {
    throw new RuntimeException(""String_Node_Str"");
  }
  LinkedList<ExpressionElement> stack=new LinkedList<ExpressionElement>();
  for (  ExpressionElement element : expression) {
    if (element instanceof FunctionElementArgument) {
      stack.push(element);
    }
 else     if (element instanceof FunctionElement) {
      FunctionElement function=(FunctionElement)element;
      int numArgs=function.getNumberOfParameters();
      FunctionElementArgument<?> args[]=new FunctionElementArgument<?>[numArgs];
      for (int i=0; i < numArgs; i++) {
        ExpressionElement arg=stack.pop();
        if (arg instanceof FunctionElementArgument) {
          int argIndex=numArgs - 1 - i;
          args[argIndex]=(FunctionElementArgument<?>)arg;
          if (arg instanceof VariableArgument) {
            VariableArgument variable=(VariableArgument)arg;
            Variable boundVariable=boundVariables.get(variable.getName());
            args[argIndex]=replaceVariable(boundVariable.getValue());
          }
        }
 else {
          throw new IllegalArgumentException(""String_Node_Str"" + arg.getClass().getName());
        }
      }
      FunctionElementArgument<?> result=function.execute(args);
      stack.push(result);
    }
 else {
      throw new IllegalArgumentException(""String_Node_Str"" + element.getClass().getName());
    }
  }
  if (stack.size() != 1) {
    throw new IllegalArgumentException(""String_Node_Str"" + stack.size());
  }
  ExpressionElement element=stack.pop();
  if (element instanceof FunctionElementArgument) {
    return (FunctionElementArgument<?>)element;
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"" + element.getClass().getName());
  }
}","public FunctionElementArgument<?> evaluate(){
  if (expression == null || expression.isEmpty()) {
    throw new RuntimeException(""String_Node_Str"");
  }
  LinkedList<ExpressionElement> stack=new LinkedList<ExpressionElement>();
  for (  ExpressionElement element : expression) {
    if (element instanceof FunctionElementArgument) {
      stack.push(element);
    }
 else     if (element instanceof FunctionElement) {
      FunctionElement function=(FunctionElement)element;
      int numArgs=function.getNumberOfParameters();
      FunctionElementArgument<?> args[]=new FunctionElementArgument<?>[numArgs];
      for (int i=0; i < numArgs; i++) {
        ExpressionElement arg=stack.pop();
        if (arg instanceof FunctionElementArgument) {
          int argIndex=numArgs - 1 - i;
          args[argIndex]=(FunctionElementArgument<?>)arg;
          if (arg instanceof VariableArgument) {
            VariableArgument variable=(VariableArgument)arg;
            Variable boundVariable=boundVariables.get(variable.getName());
            args[argIndex]=replaceVariable(boundVariable.getValue());
          }
        }
 else {
          throw new IllegalArgumentException(""String_Node_Str"" + arg.getClass().getName());
        }
      }
      FunctionElementArgument<?> result=function.execute(args);
      if (logger.isLoggable(Level.INFO)) {
        String message=""String_Node_Str"" + result.getValue() + ""String_Node_Str""+ result.getType()+ ""String_Node_Str""+ function.getName()+ ""String_Node_Str"";
        for (int i=0; i < numArgs; i++) {
          message+=args[i].getValue() + ""String_Node_Str"" + args[i].getType()+ ""String_Node_Str"";
          if (i + 1 < numArgs) {
            message+=""String_Node_Str"";
          }
        }
        message+=""String_Node_Str"";
        logger.info(message);
      }
      stack.push(result);
    }
 else {
      throw new IllegalArgumentException(""String_Node_Str"" + element.getClass().getName());
    }
  }
  if (stack.size() != 1) {
    throw new IllegalArgumentException(""String_Node_Str"" + stack.size());
  }
  ExpressionElement element=stack.pop();
  if (element instanceof FunctionElementArgument) {
    return (FunctionElementArgument<?>)element;
  }
 else {
    throw new IllegalArgumentException(""String_Node_Str"" + element.getClass().getName());
  }
}",0.8757309941520468
90802,"public Evaluator(){
  this.variables=new HashMap<String,Variable>();
  this.expression=null;
}","public Evaluator(){
  this.boundVariables=new HashMap<String,Variable>();
  this.functions=new HashMap<String,Function>();
  this.huntingYardParser=null;
  this.expression=null;
}",0.6813186813186813
90803,"public void bindVariable(Variable variable){
  variables.put(variable.getName(),variable);
}","public void bindVariable(Variable variable){
  boundVariables.put(variable.getName(),variable);
}",0.9629629629629628
90804,"BooleanArgument(Boolean booleanValue){
  this.booleanValue=booleanValue;
}","public BooleanArgument(Boolean booleanValue){
  this.booleanValue=booleanValue;
}",0.9548387096774194
90805,"protected ObjectArgument(Object objectValue){
  super();
  this.objectValue=objectValue;
}","ObjectArgument(Object objectValue){
  super();
  this.objectValue=objectValue;
}",0.9411764705882352
90806,"@Override public Object getValue(){
  return value;
}","@Override public Object getValue(){
  throw new NotImplementedException();
}",0.7131782945736435
90807,"@Override public ArgumentType getType(){
  if (value instanceof Integer) {
    return ArgumentType.INTEGER;
  }
  if (value instanceof Double) {
    return ArgumentType.DOUBLE;
  }
  if (value instanceof String) {
    return ArgumentType.STRING;
  }
  if (value instanceof Object) {
    return ArgumentType.OBJECT;
  }
  if (value instanceof Boolean) {
    return ArgumentType.BOOLEAN;
  }
  return ArgumentType.NULL;
}","@Override public ArgumentType getType(){
  throw new NotImplementedException();
}",0.236
90808,"VariableArgument(String variableName){
  super();
  this.variableName=variableName;
}","public VariableArgument(String variableName){
  super();
  this.variableName=variableName;
}",0.96045197740113
90809,"private String exportJsonDataSource() throws Exception {
  return getExporter(DESIGN_REPORT_JSON,""String_Node_Str"",""String_Node_Str"").addSubreport(""String_Node_Str"",""String_Node_Str"").addJSONParams(""String_Node_Str"",""String_Node_Str"",Locale.ENGLISH,Locale.US).exportPdf();
}","private String exportJsonDataSource() throws Exception {
  return getExporter(DESIGN_REPORT_JSON,""String_Node_Str"",""String_Node_Str"").addSubreport(""String_Node_Str"",""String_Node_Str"").addJSONParams(""String_Node_Str"",""String_Node_Str"",Locale.ENGLISH,Locale.US).setJsonSource().exportPdf();
}",0.9716312056737588
90810,"@Test public void exportJsonDataSource() throws Exception {
  getExporter(DESIGN_REPORT_JSON_CUSTOMERS,""String_Node_Str"",""String_Node_Str"").addSubreport(""String_Node_Str"",""String_Node_Str"").addJSONParams(""String_Node_Str"",""String_Node_Str"",Locale.ENGLISH,Locale.US).exportPdf();
}","@Test public void exportJsonDataSource() throws Exception {
  getExporter(DESIGN_REPORT_JSON_CUSTOMERS,""String_Node_Str"",""String_Node_Str"").addSubreport(""String_Node_Str"",""String_Node_Str"").addJSONParams(""String_Node_Str"",""String_Node_Str"",Locale.ENGLISH,Locale.US).setJsonSource().exportPdf();
}",0.9722222222222222
90811,"@Override public FunctionResult execute(Evaluator evaluator,String arguments) throws FunctionException {
  Object[] params=arguments.split(""String_Node_Str"");
  String text=(String)params[0];
  text=text.substring(1,text.length() - 2);
  Object[] args=Arrays.copyOfRange(params,1,params.length);
  String result=MessageFormat.format(text,args);
  return new FunctionResult(result,FunctionConstants.FUNCTION_RESULT_TYPE_STRING);
}","@Override public FunctionResult execute(Evaluator evaluator,String arguments) throws FunctionException {
  Object[] params=arguments.split(""String_Node_Str"");
  String text=(String)params[0];
  if (text.length() == 2) {
    text=""String_Node_Str"";
  }
 else {
    text=text.substring(1,text.length() - 2);
  }
  Object[] args=Arrays.copyOfRange(params,1,params.length);
  String result=MessageFormat.format(text,args);
  return new FunctionResult(result,FunctionConstants.FUNCTION_RESULT_TYPE_STRING);
}",0.9206008583690988
90812,"private void registerPdfInternalFonts(){
  List<IFont> base14Fonts=Base14Font.getList(this);
  for (  IFont font : base14Fonts) {
    addFont(new FontKey(font),font);
  }
  Set<Entry<String,String>> fontEntrySet=Base14Font.getLogicalFontNames().entrySet();
  for (  Map.Entry<String,String> logicalFontEntry : fontEntrySet) {
    String fontName=logicalFontEntry.getValue();
    String alias=logicalFontEntry.getKey();
    addFontAlias(fontName,alias,FontStyle.PLAIN);
    addFontAlias(fontName,alias,FontStyle.BOLD);
    addFontAlias(fontName,alias,FontStyle.OBLIQUE);
    addFontAlias(fontName,alias,FontStyle.BOLD_OBLIQUE);
  }
}","private void registerPdfInternalFonts(){
  List<IFont> base14Fonts=Base14Font.getList(this);
  for (  IFont font : base14Fonts) {
    addFont(new FontKey(font),font);
  }
  Map<String,String> fontsByName=Base14Font.getLogicalFontNames();
  for (  Map.Entry<String,String> logicalFontEntry : fontsByName.entrySet()) {
    String fontName=logicalFontEntry.getValue();
    String alias=logicalFontEntry.getKey();
    addFontAlias(fontName,alias,FontStyle.PLAIN);
    addFontAlias(fontName,alias,FontStyle.BOLD);
    addFontAlias(fontName,alias,FontStyle.OBLIQUE);
    addFontAlias(fontName,alias,FontStyle.BOLD_OBLIQUE);
  }
}",0.9402390438247012
90813,"public static <V extends Vertex<E> & HasTimepoint,E extends Edge<V>>void installActionBindings(final Behaviours behaviours,final TrackSchemePanel panel){
  final TrackSchemeZoom<V,E> zoom=new TrackSchemeZoom<>(panel);
  zoom.transformChanged(panel.getDisplay().getTransformEventHandler().getTransform());
  zoom.updateHeadersVisibility(panel.getOffsetDecorations().isVisibleX(),panel.getOffsetDecorations().getWidth(),panel.getOffsetDecorations().isVisibleY(),panel.getOffsetDecorations().getHeight());
  panel.getDisplay().addOverlayRenderer(zoom.overlay);
  panel.getDisplay().addTransformListener(zoom);
  panel.getOffsetDecorations().addOffsetHeadersListener(zoom);
  behaviours.namedBehaviour(zoom,TOGGLE_ZOOM_KEYS);
}","public static <V extends Vertex<E> & HasTimepoint,E extends Edge<V>>void installActionBindings(final Behaviours behaviours,final TrackSchemePanel panel){
  final TrackSchemeZoom<V,E> zoom=new TrackSchemeZoom<>(panel);
  zoom.transformChanged(panel.getDisplay().getTransformEventHandler().getTransform());
  zoom.updateHeaderSize(panel.getOffsetHeaders().getWidth(),panel.getOffsetHeaders().getHeight());
  panel.getDisplay().addOverlayRenderer(zoom.overlay);
  panel.getDisplay().addTransformListener(zoom);
  panel.getOffsetHeaders().listeners().add(zoom);
  behaviours.namedBehaviour(zoom,TOGGLE_ZOOM_KEYS);
}",0.8470764617691154
90814,"@Override public void click(final int x,final int y){
  final V ref=overlayGraph.vertexRef();
  lock.readLock().lock();
  try {
    final V vertex=renderer.getVertexAt(x,y,POINT_SELECT_DISTANCE_TOLERANCE,ref);
    if (vertex != null) {
      vertex.getCovariance(mat);
      LinAlgHelpers.scale(mat,1 + factor,mat);
      eig.decomposeSymmetric(mat);
      final double[] eigVals=eig.getRealEigenvalues();
      for (      final double eigVal : eigVals)       if (eigVal < MIN_RADIUS)       return;
      vertex.setCovariance(mat);
      lastRadius=Math.max(MIN_RADIUS,vertex.getBoundingSphereRadiusSquared());
      overlayGraph.notifyGraphChanged();
      undo.setUndoPoint();
    }
  }
  finally {
    lock.readLock().unlock();
    overlayGraph.releaseRef(ref);
  }
}","@Override public void click(final int x,final int y){
  final V ref=overlayGraph.vertexRef();
  lock.readLock().lock();
  try {
    final V vertex=renderer.getVertexAt(x,y,POINT_SELECT_DISTANCE_TOLERANCE,ref);
    if (vertex != null) {
      vertex.getCovariance(mat);
      LinAlgHelpers.scale(mat,1 + factor,mat);
      eig.decomposeSymmetric(mat);
      final double[] eigVals=eig.getRealEigenvalues();
      for (      final double eigVal : eigVals)       if (eigVal < MIN_RADIUS)       return;
      vertex.setCovariance(mat);
      lastRadius=Math.max(MIN_RADIUS,Math.sqrt(vertex.getBoundingSphereRadiusSquared()));
      overlayGraph.notifyGraphChanged();
      undo.setUndoPoint();
    }
  }
  finally {
    lock.readLock().unlock();
    overlayGraph.releaseRef(ref);
  }
}",0.9929078014184396
90815,"public BehaviourTransformEventHandler3DMamut(final TransformListener<AffineTransform3D> listener){
  this.listener=listener;
  drageTranslateBehaviour=new TranslateXY(DRAG_TRANSLATE);
  zoomBehaviour=new Zoom(ZOOM_NORMAL);
  selectRotationAxisXBehaviour=new SelectRotationAxis(SELECT_AXIS_X,0);
  selectRotationAxisYBehaviour=new SelectRotationAxis(SELECT_AXIS_Y,1);
  selectRotationAxisZBehaviour=new SelectRotationAxis(SELECT_AXIS_Z,2);
  dragRotateBehaviour=new Rotate(DRAG_ROTATE,speed[0]);
  dragRotateFastBehaviour=new Rotate(DRAG_ROTATE_FAST,speed[1]);
  dragRotateSlowBehaviour=new Rotate(DRAG_ROTATE_SLOW,speed[2]);
  translateZBehaviour=new TranslateZ(SCROLL_Z,speed[0]);
  translateZFastBehaviour=new TranslateZ(SCROLL_Z_FAST,speed[1]);
  translateZSlowBehaviour=new TranslateZ(SCROLL_Z_SLOW,speed[2]);
  rotateLeftBehaviour=new KeyRotate(ROTATE_LEFT,speed[0]);
  rotateLeftFastBehaviour=new KeyRotate(ROTATE_LEFT_FAST,speed[1]);
  rotateLeftSlowBehaviour=new KeyRotate(ROTATE_LEFT_SLOW,speed[2]);
  rotateRightBehaviour=new KeyRotate(ROTATE_RIGHT,-speed[0]);
  rotateRightFastBehaviour=new KeyRotate(ROTATE_RIGHT_FAST,-speed[1]);
  rotateRightSlowBehaviour=new KeyRotate(ROTATE_RIGHT_SLOW,-speed[2]);
  keyZoomInBehaviour=new KeyZoom(KEY_ZOOM_IN,speed[0]);
  keyZoomInFastBehaviour=new KeyZoom(KEY_ZOOM_IN_FAST,speed[1]);
  keyZoomInSlowBehaviour=new KeyZoom(KEY_ZOOM_IN_SLOW,speed[2]);
  keyZoomOutBehaviour=new KeyZoom(KEY_ZOOM_OUT,-speed[0]);
  keyZoomOutFastBehaviour=new KeyZoom(KEY_ZOOM_OUT_FAST,-speed[1]);
  keyZoomOutSlowBehaviour=new KeyZoom(KEY_ZOOM_OUT_SLOW,-speed[2]);
  keyForwardZBehaviour=new KeyTranslateZ(KEY_FORWARD_Z,speed[0]);
  keyForwardZFastBehaviour=new KeyTranslateZ(KEY_FORWARD_Z_FAST,speed[1]);
  keyForwardZSlowBehaviour=new KeyTranslateZ(KEY_FORWARD_Z_SLOW,speed[2]);
  keyBackwardZBehaviour=new KeyTranslateZ(KEY_BACKWARD_Z,-speed[0]);
  keyBackwardZFastBehaviour=new KeyTranslateZ(KEY_BACKWARD_Z_FAST,-speed[0]);
  keyBackwardZSlowBehaviour=new KeyTranslateZ(KEY_BACKWARD_Z_SLOW,-speed[0]);
}","public BehaviourTransformEventHandler3DMamut(final TransformListener<AffineTransform3D> listener){
  this.listener=listener;
  drageTranslateBehaviour=new TranslateXY(DRAG_TRANSLATE);
  zoomBehaviour=new Zoom(ZOOM_NORMAL);
  selectRotationAxisXBehaviour=new SelectRotationAxis(SELECT_AXIS_X,0);
  selectRotationAxisYBehaviour=new SelectRotationAxis(SELECT_AXIS_Y,1);
  selectRotationAxisZBehaviour=new SelectRotationAxis(SELECT_AXIS_Z,2);
  dragRotateBehaviour=new Rotate(DRAG_ROTATE,speed[0]);
  dragRotateFastBehaviour=new Rotate(DRAG_ROTATE_FAST,speed[1]);
  dragRotateSlowBehaviour=new Rotate(DRAG_ROTATE_SLOW,speed[2]);
  translateZBehaviour=new TranslateZ(SCROLL_Z,speed[0]);
  translateZFastBehaviour=new TranslateZ(SCROLL_Z_FAST,speed[1]);
  translateZSlowBehaviour=new TranslateZ(SCROLL_Z_SLOW,speed[2]);
  rotateLeftBehaviour=new KeyRotate(ROTATE_LEFT,speed[0]);
  rotateLeftFastBehaviour=new KeyRotate(ROTATE_LEFT_FAST,speed[1]);
  rotateLeftSlowBehaviour=new KeyRotate(ROTATE_LEFT_SLOW,speed[2]);
  rotateRightBehaviour=new KeyRotate(ROTATE_RIGHT,-speed[0]);
  rotateRightFastBehaviour=new KeyRotate(ROTATE_RIGHT_FAST,-speed[1]);
  rotateRightSlowBehaviour=new KeyRotate(ROTATE_RIGHT_SLOW,-speed[2]);
  keyZoomInBehaviour=new KeyZoom(KEY_ZOOM_IN,speed[0]);
  keyZoomInFastBehaviour=new KeyZoom(KEY_ZOOM_IN_FAST,speed[1]);
  keyZoomInSlowBehaviour=new KeyZoom(KEY_ZOOM_IN_SLOW,speed[2]);
  keyZoomOutBehaviour=new KeyZoom(KEY_ZOOM_OUT,-speed[0]);
  keyZoomOutFastBehaviour=new KeyZoom(KEY_ZOOM_OUT_FAST,-speed[1]);
  keyZoomOutSlowBehaviour=new KeyZoom(KEY_ZOOM_OUT_SLOW,-speed[2]);
  keyForwardZBehaviour=new KeyTranslateZ(KEY_FORWARD_Z,speed[0]);
  keyForwardZFastBehaviour=new KeyTranslateZ(KEY_FORWARD_Z_FAST,speed[1]);
  keyForwardZSlowBehaviour=new KeyTranslateZ(KEY_FORWARD_Z_SLOW,speed[2]);
  keyBackwardZBehaviour=new KeyTranslateZ(KEY_BACKWARD_Z,-speed[0]);
  keyBackwardZFastBehaviour=new KeyTranslateZ(KEY_BACKWARD_Z_FAST,-speed[1]);
  keyBackwardZSlowBehaviour=new KeyTranslateZ(KEY_BACKWARD_Z_SLOW,-speed[2]);
}",0.9990176817288802
90816,"@Override public void run(){
  if (mode != Mode.INACTIVE)   return;
  inputMap.clear();
  actionMap.clear();
  final KeyStroke abortKey=KeyStroke.getKeyStroke(KeyEvent.VK_ESCAPE,0);
  final Action abortAction=new AbstractAction(""String_Node_Str""){
    @Override public void actionPerformed(    final ActionEvent e){
      abort();
    }
    private static final long serialVersionUID=1L;
  }
;
  inputMap.put(abortKey,""String_Node_Str"");
  actionMap.put(""String_Node_Str"",abortAction);
  int i=1;
  for (  final TagSet tagSet : tagModel.getTagSetStructure().getTagSets()) {
    final String actionName=""String_Node_Str"" + i;
    final KeyStroke tagKeyStroke=KeyStroke.getKeyStroke((char)('0' + i));
    final AbstractAction action=new AbstractAction(actionName){
      @Override public void actionPerformed(      final ActionEvent e){
        selectTagSet(tagSet);
      }
      private static final long serialVersionUID=1L;
    }
;
    inputMap.put(tagKeyStroke,actionName);
    actionMap.put(actionName,action);
    i++;
  }
  bindings.addInputMap(""String_Node_Str"",inputMap);
  bindings.addActionMap(""String_Node_Str"",actionMap);
  mode=Mode.PICK_TAGSET;
  renderer.addOverlayRenderer(overlay);
  panel.repaint();
}","@Override public void run(){
  if (mode != Mode.INACTIVE)   return;
  inputMap.clear();
  actionMap.clear();
  final KeyStroke abortKey=KeyStroke.getKeyStroke(KeyEvent.VK_ESCAPE,0);
  final Action abortAction=new AbstractAction(""String_Node_Str""){
    @Override public void actionPerformed(    final ActionEvent e){
      abort();
    }
    private static final long serialVersionUID=1L;
  }
;
  inputMap.put(abortKey,""String_Node_Str"");
  actionMap.put(""String_Node_Str"",abortAction);
  int i=1;
  for (  final TagSet tagSet : tagModel.getTagSetStructure().getTagSets()) {
    final String actionName=""String_Node_Str"" + i;
    final KeyStroke tagKeyStroke=KeyStroke.getKeyStroke((char)('0' + i));
    final AbstractAction action=new AbstractAction(actionName){
      @Override public void actionPerformed(      final ActionEvent e){
        selectTagSet(tagSet);
      }
      private static final long serialVersionUID=1L;
    }
;
    inputMap.put(tagKeyStroke,actionName);
    actionMap.put(actionName,action);
    i++;
  }
  bindings.addInputMap(PICK_TAGS_MAP,inputMap);
  bindings.addActionMap(PICK_TAGS_MAP,actionMap);
  mode=Mode.PICK_TAGSET;
  renderer.addOverlayRenderer(overlay);
  panel.repaint();
}",0.9251028806584364
90817,"private synchronized void selectTagSet(final TagSet tagSet){
  if (null == tagSet || !tagModel.getTagSetStructure().getTagSets().contains(tagSet))   return;
  inputMap.clear();
  actionMap.clear();
  final KeyStroke abortKey=KeyStroke.getKeyStroke(KeyEvent.VK_ESCAPE,0);
  final Action abortAction=new AbstractAction(""String_Node_Str""){
    @Override public void actionPerformed(    final ActionEvent e){
      abort();
    }
    private static final long serialVersionUID=1L;
  }
;
  inputMap.put(abortKey,""String_Node_Str"");
  actionMap.put(""String_Node_Str"",abortAction);
  final KeyStroke removeKey=KeyStroke.getKeyStroke(KeyEvent.VK_0,0);
  final Action removeAction=new AbstractAction(""String_Node_Str""){
    @Override public void actionPerformed(    final ActionEvent e){
      removeLabels();
    }
    private static final long serialVersionUID=1L;
  }
;
  inputMap.put(removeKey,""String_Node_Str"");
  actionMap.put(""String_Node_Str"",removeAction);
  final KeyStroke clearAllKey=KeyStroke.getKeyStroke(KeyEvent.VK_DELETE,KeyEvent.SHIFT_DOWN_MASK);
  final Action clearAllAction=new AbstractAction(""String_Node_Str""){
    @Override public void actionPerformed(    final ActionEvent e){
      clearAllLabels();
    }
    private static final long serialVersionUID=1L;
  }
;
  inputMap.put(clearAllKey,""String_Node_Str"");
  actionMap.put(""String_Node_Str"",clearAllAction);
  int i=1;
  for (  final Tag tag : tagSet.getTags()) {
    final String actionName=""String_Node_Str"" + i;
    final KeyStroke takKeyStroke=KeyStroke.getKeyStroke((char)('0' + i));
    final AbstractAction action=new AbstractAction(actionName){
      @Override public void actionPerformed(      final ActionEvent e){
        selectTag(tag);
      }
      private static final long serialVersionUID=1L;
    }
;
    inputMap.put(takKeyStroke,actionName);
    actionMap.put(actionName,action);
    i++;
  }
  bindings.addInputMap(""String_Node_Str"",inputMap);
  bindings.addActionMap(""String_Node_Str"",actionMap);
  this.tagSet=tagSet;
  mode=Mode.PICK_TAG;
  panel.repaint();
}","private synchronized void selectTagSet(final TagSet tagSet){
  if (null == tagSet || !tagModel.getTagSetStructure().getTagSets().contains(tagSet))   return;
  inputMap.clear();
  actionMap.clear();
  final KeyStroke abortKey=KeyStroke.getKeyStroke(KeyEvent.VK_ESCAPE,0);
  final Action abortAction=new AbstractAction(""String_Node_Str""){
    @Override public void actionPerformed(    final ActionEvent e){
      abort();
    }
    private static final long serialVersionUID=1L;
  }
;
  inputMap.put(abortKey,""String_Node_Str"");
  actionMap.put(""String_Node_Str"",abortAction);
  final KeyStroke removeKey=KeyStroke.getKeyStroke(KeyEvent.VK_0,0);
  final Action removeAction=new AbstractAction(""String_Node_Str""){
    @Override public void actionPerformed(    final ActionEvent e){
      removeLabels();
    }
    private static final long serialVersionUID=1L;
  }
;
  inputMap.put(removeKey,""String_Node_Str"");
  actionMap.put(""String_Node_Str"",removeAction);
  final KeyStroke clearAllKey=KeyStroke.getKeyStroke(KeyEvent.VK_DELETE,KeyEvent.SHIFT_DOWN_MASK);
  final Action clearAllAction=new AbstractAction(""String_Node_Str""){
    @Override public void actionPerformed(    final ActionEvent e){
      clearAllLabels();
    }
    private static final long serialVersionUID=1L;
  }
;
  inputMap.put(clearAllKey,""String_Node_Str"");
  actionMap.put(""String_Node_Str"",clearAllAction);
  int i=1;
  for (  final Tag tag : tagSet.getTags()) {
    final String actionName=""String_Node_Str"" + i;
    final KeyStroke takKeyStroke=KeyStroke.getKeyStroke((char)('0' + i));
    final AbstractAction action=new AbstractAction(actionName){
      @Override public void actionPerformed(      final ActionEvent e){
        selectTag(tag);
      }
      private static final long serialVersionUID=1L;
    }
;
    inputMap.put(takKeyStroke,actionName);
    actionMap.put(actionName,action);
    i++;
  }
  bindings.addInputMap(PICK_TAGS_MAP,inputMap);
  bindings.addActionMap(PICK_TAGS_MAP,actionMap);
  this.tagSet=tagSet;
  mode=Mode.PICK_TAG;
  panel.repaint();
}",0.9448511469009272
90818,"private synchronized void done(){
  mode=Mode.INACTIVE;
  bindings.removeActionMap(PICK_TAGS);
  bindings.removeInputMap(PICK_TAGS);
  renderer.removeOverlayRenderer(overlay);
  panel.repaint();
}","private synchronized void done(){
  mode=Mode.INACTIVE;
  bindings.removeActionMap(PICK_TAGS_MAP);
  bindings.removeInputMap(PICK_TAGS_MAP);
  renderer.removeOverlayRenderer(overlay);
  panel.repaint();
}",0.98
90819,"public TagSetDialog(final Frame owner,final TagSetManager manager){
  super(owner,""String_Node_Str"",false);
  this.manager=manager;
  tagSetPanel=new TagSetPanel();
  tagSetPanel.setTagSetStructure(manager.getTagSetStructure());
  final SimpleSettingsPage page=new SimpleSettingsPage(""String_Node_Str"",tagSetPanel);
  tagSetPanel.updateListeners().add(() -> page.notifyModified());
  page.onApply(() -> manager.setTagSetStructure(tagSetPanel.getTagSetStructure()));
  page.onCancel(() -> tagSetPanel.setTagSetStructure(manager.getTagSetStructure()));
  final SingleSettingsPanel settingsPanel=new SingleSettingsPanel(page);
  settingsPanel.onOk(() -> setVisible(false));
  settingsPanel.onCancel(() -> setVisible(false));
  setDefaultCloseOperation(WindowConstants.DO_NOTHING_ON_CLOSE);
  addWindowListener(new WindowAdapter(){
    @Override public void windowClosing(    final WindowEvent e){
      settingsPanel.cancel();
    }
  }
);
  getContentPane().add(settingsPanel,BorderLayout.CENTER);
  pack();
}","public TagSetDialog(final Frame owner,final TagSetManager manager){
  super(owner,""String_Node_Str"",false);
  this.manager=manager;
  tagSetPanel=new TagSetPanel();
  tagSetPanel.setTagSetStructure(manager.getTagSetStructure());
  final SimpleSettingsPage page=new SimpleSettingsPage(""String_Node_Str"",tagSetPanel);
  tagSetPanel.updateListeners().add(() -> page.notifyModified());
  page.onApply(() -> {
    tagSetPanel.stopEditing();
    manager.setTagSetStructure(tagSetPanel.getTagSetStructure());
  }
);
  page.onCancel(() -> {
    tagSetPanel.cancelEditing();
    tagSetPanel.setTagSetStructure(manager.getTagSetStructure());
  }
);
  final SingleSettingsPanel settingsPanel=new SingleSettingsPanel(page);
  settingsPanel.onOk(() -> setVisible(false));
  settingsPanel.onCancel(() -> setVisible(false));
  setDefaultCloseOperation(WindowConstants.DO_NOTHING_ON_CLOSE);
  addWindowListener(new WindowAdapter(){
    @Override public void windowClosing(    final WindowEvent e){
      settingsPanel.cancel();
    }
  }
);
  getContentPane().add(settingsPanel,BorderLayout.CENTER);
  pack();
}",0.9581351094196005
90820,"public TagSetPanel(final TagSetStructure tagSetStructure){
  super(new BorderLayout(0,0));
  this.tagSetStructure=tagSetStructure;
  updateListeners=new Listeners.SynchronizedList<>();
  tagSetTable=new TagTable<>(tagSetStructure,tss -> tss.createTagSet(makeNewName(""String_Node_Str"")),tss -> tss.getTagSets().size(),TagSetStructure::remove,(tss,i) -> tss.getTagSets().get(i),TagSet::setName,TagSet::getName);
  final ColorTagTable<TagSet,Tag> tagTable=new ColorTagTable<>(null,ts -> ts.createTag(""String_Node_Str"",colorGenerator.next()),ts -> ts.getTags().size(),TagSet::removeTag,(ts,i) -> ts.getTags().get(i),Tag::setLabel,Tag::label,(t,color) -> t.setColor(color.getRGB()),t -> new Color(t.color(),true));
  tagSetTable.updateListeners().add(this::notifyListeners);
  tagTable.updateListeners().add(this::notifyListeners);
  tagSetTable.selectionListeners().add(tagTable::setElements);
  final JSplitPane splitPane=new JSplitPane(JSplitPane.HORIZONTAL_SPLIT,tagSetTable.getTable(),tagTable.getTable());
  splitPane.setResizeWeight(0);
  splitPane.setContinuousLayout(true);
  splitPane.setDividerSize(10);
  splitPane.setDividerLocation(300);
  splitPane.setBorder(new MatteBorder(0,0,1,0,Color.LIGHT_GRAY));
  this.add(splitPane,BorderLayout.CENTER);
}","public TagSetPanel(final TagSetStructure tagSetStructure){
  super(new BorderLayout(0,0));
  this.tagSetStructure=tagSetStructure;
  updateListeners=new Listeners.SynchronizedList<>();
  tagSetTable=new TagTable<>(tagSetStructure,tss -> tss.createTagSet(makeNewName(""String_Node_Str"")),tss -> tss.getTagSets().size(),TagSetStructure::remove,(tss,i) -> tss.getTagSets().get(i),TagSet::setName,TagSet::getName);
  tagTable=new ColorTagTable<>(null,ts -> ts.createTag(""String_Node_Str"",colorGenerator.next()),ts -> ts.getTags().size(),TagSet::removeTag,(ts,i) -> ts.getTags().get(i),Tag::setLabel,Tag::label,(t,color) -> t.setColor(color.getRGB()),t -> new Color(t.color(),true));
  tagSetTable.updateListeners().add(this::notifyListeners);
  tagTable.updateListeners().add(this::notifyListeners);
  tagSetTable.selectionListeners().add(tagTable::setElements);
  final JSplitPane splitPane=new JSplitPane(JSplitPane.HORIZONTAL_SPLIT,tagSetTable.getTable(),tagTable.getTable());
  splitPane.setResizeWeight(0);
  splitPane.setContinuousLayout(true);
  splitPane.setDividerSize(10);
  splitPane.setDividerLocation(300);
  splitPane.setBorder(new MatteBorder(0,0,1,0,Color.LIGHT_GRAY));
  this.add(splitPane,BorderLayout.CENTER);
}",0.9871071716357775
90821,"@Override public void setTagSetStructure(final TagSetStructure tss){
  final Set<Integer> removedIds=tagSetStructure.getTagSets().stream().flatMap(ts -> ts.getTags().stream()).map(Tag::id).collect(Collectors.toSet());
  final Set<Integer> newIds=tss.getTagSets().stream().flatMap(ts -> ts.getTags().stream()).map(Tag::id).collect(Collectors.toSet());
  removedIds.removeAll(newIds);
  final LabelSet<V,Integer> vref=vertexIdLabelSets.createRef();
  for (  final Integer id : removedIds) {
    final RefSet<V> labeledWithId=RefCollections.createRefSet(graph.vertices());
    labeledWithId.addAll(vertexIdLabelSets.getLabeledWith(id));
    labeledWithId.forEach(v -> vertexIdLabelSets.getLabels(v,vref).remove(id));
  }
  vertexIdLabelSets.releaseRef(vref);
  final LabelSet<E,Integer> eref=edgeIdLabelSets.createRef();
  for (  final Integer id : removedIds) {
    final RefSet<E> labeledWithId=RefCollections.createRefSet(graph.edges());
    labeledWithId.addAll(edgeIdLabelSets.getLabeledWith(id));
    labeledWithId.forEach(e -> edgeIdLabelSets.getLabels(e,eref).remove(id));
  }
  edgeIdLabelSets.releaseRef(eref);
  if (editRecorder != null) {
    editRecorder.record(new SetTagSetStructureUndoableEdit(this,tagSetStructure,tss));
  }
  tagSetStructure.set(tss);
  listeners.list.forEach(TagSetModelListener::tagSetStructureChanged);
  vertexTags.update(tagSetStructure);
  edgeTags.update(tagSetStructure);
}","@Override public void setTagSetStructure(final TagSetStructure tss){
  final Set<Integer> removedIds=tagSetStructure.getTagSets().stream().flatMap(ts -> ts.getTags().stream()).map(Tag::id).collect(Collectors.toSet());
  final Set<Integer> newIds=tss.getTagSets().stream().flatMap(ts -> ts.getTags().stream()).map(Tag::id).collect(Collectors.toSet());
  removedIds.removeAll(newIds);
  final LabelSet<V,Integer> vref=vertexIdLabelSets.createRef();
  for (  final Integer id : removedIds) {
    final RefSet<V> labeledWithId=RefCollections.createRefSet(graph.vertices());
    labeledWithId.addAll(vertexIdLabelSets.getLabeledWith(id));
    labeledWithId.forEach(v -> vertexIdLabelSets.getLabels(v,vref).remove(id));
  }
  vertexIdLabelSets.releaseRef(vref);
  final LabelSet<E,Integer> eref=edgeIdLabelSets.createRef();
  for (  final Integer id : removedIds) {
    final RefSet<E> labeledWithId=RefCollections.createRefSet(graph.edges());
    labeledWithId.addAll(edgeIdLabelSets.getLabeledWith(id));
    labeledWithId.forEach(e -> edgeIdLabelSets.getLabels(e,eref).remove(id));
  }
  edgeIdLabelSets.releaseRef(eref);
  if (editRecorder != null) {
    editRecorder.record(new SetTagSetStructureUndoableEdit(this,tagSetStructure,tss));
  }
  tagSetStructure.set(tss);
  vertexTags.update(tagSetStructure);
  edgeTags.update(tagSetStructure);
  listeners.list.forEach(TagSetModelListener::tagSetStructureChanged);
}",0.9476291578202406
90822,"public synchronized void loadProject(){
  final String fn=proposedProjectFolder == null ? (project == null ? null : project.getProjectFolder().getAbsolutePath()) : proposedProjectFolder.getAbsolutePath();
  final Component parent=null;
  final File file=FileChooser.chooseFile(parent,fn,null,""String_Node_Str"",FileChooser.DialogType.LOAD,SelectionMode.DIRECTORIES_ONLY);
  if (file == null)   return;
  try {
    proposedProjectFolder=file;
    final MamutProject project=new MamutProjectIO().load(file.getAbsolutePath());
    open(project);
  }
 catch (  final IOException|SpimDataException e) {
    e.printStackTrace();
  }
}","public synchronized void loadProject(){
  String fn=null;
  if (proposedProjectFolder != null)   fn=proposedProjectFolder.getAbsolutePath();
 else   if (project != null && project.getProjectFolder() != null)   fn=project.getProjectFolder().getAbsolutePath();
  final Component parent=null;
  final File file=FileChooser.chooseFile(parent,fn,null,""String_Node_Str"",FileChooser.DialogType.LOAD,SelectionMode.DIRECTORIES_ONLY);
  if (file == null)   return;
  try {
    proposedProjectFolder=file;
    final MamutProject project=new MamutProjectIO().load(file.getAbsolutePath());
    open(project);
  }
 catch (  final IOException|SpimDataException e) {
    e.printStackTrace();
  }
}",0.7828746177370031
90823,"private void select(final int x,final int y,final boolean addToSelection){
  selection.pauseListeners();
  final V vertex=overlayGraph.vertexRef();
  final E edge=overlayGraph.edgeRef();
  if (renderer.getVertexAt(x,y,POINT_SELECT_DISTANCE_TOLERANCE,vertex) != null) {
    final boolean selected=selection.isSelected(vertex);
    if (!addToSelection)     selection.clearSelection();
    selection.setSelected(vertex,!selected);
  }
 else   if (renderer.getEdgeAt(x,y,EDGE_SELECT_DISTANCE_TOLERANCE,edge) != null) {
    final boolean selected=selection.isSelected(vertex);
    if (!addToSelection)     selection.clearSelection();
    selection.setSelected(edge,!selected);
  }
 else   if (!addToSelection)   selection.clearSelection();
  overlayGraph.releaseRef(vertex);
  overlayGraph.releaseRef(edge);
  selection.resumeListeners();
}","private void select(final int x,final int y,final boolean addToSelection){
  selection.pauseListeners();
  final V vertex=overlayGraph.vertexRef();
  final E edge=overlayGraph.edgeRef();
  if (renderer.getVertexAt(x,y,POINT_SELECT_DISTANCE_TOLERANCE,vertex) != null) {
    final boolean selected=selection.isSelected(vertex);
    if (!addToSelection)     selection.clearSelection();
    selection.setSelected(vertex,!selected);
  }
 else   if (renderer.getEdgeAt(x,y,EDGE_SELECT_DISTANCE_TOLERANCE,edge) != null) {
    final boolean selected=selection.isSelected(edge);
    if (!addToSelection)     selection.clearSelection();
    selection.setSelected(edge,!selected);
  }
 else   if (!addToSelection)   selection.clearSelection();
  overlayGraph.releaseRef(vertex);
  overlayGraph.releaseRef(edge);
  selection.resumeListeners();
}",0.9940047961630696
90824,"JMenu menu(final String path){
  final String[] parts=path.split(""String_Node_Str"");
  MenuElement root=menubar;
  for (  final String part : parts) {
    final String text=part.trim();
    JMenuItem next=null;
    for (    final MenuElement me : root.getSubElements()) {
      if (me instanceof JMenu) {
        final JMenuItem mi=(JMenuItem)me;
        if (mi.getText().equals(text)) {
          next=mi;
          break;
        }
      }
    }
    if (next == null) {
      next=new JMenu(text);
      if (root == menubar)       menubar.add(next);
 else       if (root instanceof JMenu)       ((JMenu)root).add(next);
 else       throw new IllegalArgumentException(""String_Node_Str"");
    }
    if (next instanceof JMenu)     root=next;
 else     throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (root instanceof JMenu)   return (JMenu)root;
 else   throw new IllegalArgumentException(""String_Node_Str"");
}","JMenu menu(final String path){
  final String[] parts=path.split(""String_Node_Str"");
  MenuElement root=menubar;
  for (  final String part : parts) {
    final String text=part.trim();
    JMenuItem next=null;
    A:     for (    final MenuElement me : root.getSubElements()) {
      if (me instanceof JPopupMenu) {
        final JPopupMenu pm=(JPopupMenu)me;
        for (        final MenuElement pme : pm.getSubElements()) {
          if (pme instanceof JMenu) {
            final JMenuItem mi=(JMenuItem)pme;
            if (mi.getText().equals(text)) {
              next=mi;
              break A;
            }
          }
        }
      }
      if (me instanceof JMenu) {
        final JMenuItem mi=(JMenuItem)me;
        if (mi.getText().equals(text)) {
          next=mi;
          break;
        }
      }
    }
    if (next == null) {
      next=new JMenu(text);
      if (root == menubar)       menubar.add(next);
 else       if (root instanceof JMenu)       ((JMenu)root).add(next);
 else       throw new IllegalArgumentException(""String_Node_Str"");
    }
    if (next instanceof JMenu)     root=next;
 else     throw new IllegalArgumentException(""String_Node_Str"");
  }
  if (root instanceof JMenu)   return (JMenu)root;
 else   throw new IllegalArgumentException(""String_Node_Str"");
}",0.8307139649753031
90825,"public static void main(final String[] args) throws IOException {
  final String bdvFile=""String_Node_Str"";
  final String modelFile=""String_Node_Str"";
  final MamutProject project=new MamutProject(new File(""String_Node_Str""),new File(bdvFile),new File(modelFile));
  final Model model=new Model();
  model.loadRaw(project.getRawModelFile());
  final File target=new File(""String_Node_Str"");
  export(target,model,project);
}","public static void main(final String[] args) throws IOException {
  final String projectFolder=""String_Node_Str"";
  final String bdvFile=""String_Node_Str"";
  final MamutProject project=new MamutProject(new File(projectFolder),new File(bdvFile));
  final Model model=new Model();
  model.loadRaw(project.getRawModelFile());
  final File target=new File(""String_Node_Str"");
  export(target,model,project);
}",0.3542168674698795
90826,"public static void main(final String[] args) throws IOException, JDOMException, SpimDataException {
  final String bdvFile=""String_Node_Str"";
  final String modelFile=""String_Node_Str"";
  final MamutProject project=new MamutProject(new File(""String_Node_Str""),new File(bdvFile),new File(modelFile));
  final Model model=new Model();
  model.loadRaw(project.getRawModelFile());
  final Context context=new Context(MamutFeatureComputerService.class);
  final MamutFeatureComputerService featureComputerService=context.getService(MamutFeatureComputerService.class);
  final Set<FeatureComputer<Model>> featureComputers=new HashSet<>(featureComputerService.getFeatureComputers());
  final ProgressListener pl=new ProgressListener(){
    @Override public void showStatus(    final String string){
      System.out.println(""String_Node_Str"" + string);
    }
    @Override public void showProgress(    final int current,    final int total){
    }
    @Override public void clearStatus(){
    }
  }
;
  System.out.println(""String_Node_Str"");
  final boolean computed=featureComputerService.compute(model,model.getFeatureModel(),featureComputers,pl);
  if (!computed) {
    System.err.println(""String_Node_Str"");
    return;
  }
  final File target=new File(""String_Node_Str"");
  MamutExporter.export(target,model,project);
  final Model importedModel=new Model();
  TrackMateImporter.importModel(target,importedModel);
  System.out.println(MastodonUtil.dump(importedModel));
}","public static void main(final String[] args) throws IOException, JDOMException, SpimDataException {
  final String projectFolder=""String_Node_Str"";
  final String bdvFile=""String_Node_Str"";
  final MamutProject project=new MamutProject(new File(projectFolder),new File(bdvFile));
  final Model model=new Model();
  model.loadRaw(project.getRawModelFile());
  final Context context=new Context(MamutFeatureComputerService.class);
  final MamutFeatureComputerService featureComputerService=context.getService(MamutFeatureComputerService.class);
  final Set<FeatureComputer<Model>> featureComputers=new HashSet<>(featureComputerService.getFeatureComputers());
  final ProgressListener pl=new ProgressListener(){
    @Override public void showStatus(    final String string){
      System.out.println(""String_Node_Str"" + string);
    }
    @Override public void showProgress(    final int current,    final int total){
    }
    @Override public void clearStatus(){
    }
  }
;
  System.out.println(""String_Node_Str"");
  final boolean computed=featureComputerService.compute(model,model.getFeatureModel(),featureComputers,pl);
  if (!computed) {
    System.err.println(""String_Node_Str"");
    return;
  }
  final File target=new File(""String_Node_Str"");
  MamutExporter.export(target,model,project);
  final Model importedModel=new Model();
  TrackMateImporter.importModel(target,importedModel);
  System.out.println(MastodonUtil.dump(importedModel));
}",0.4050719671007539
90827,"public static void main(final String[] args) throws IOException {
  final String projectFolder=""String_Node_Str"";
  final String bdvFile=""String_Node_Str"";
  final MamutProject project=new MamutProject(new File(projectFolder),new File(bdvFile));
  final Model model=new Model();
  model.loadRaw(project.getRawModelFile());
  final File target=new File(""String_Node_Str"");
  export(target,model,project);
}","public static void main(final String[] args) throws IOException {
  final String projectFolder=""String_Node_Str"";
  final String bdvFile=""String_Node_Str"";
  final MamutProject project=new MamutProject(new File(projectFolder),new File(bdvFile));
  final Model model=new Model();
  model.loadRaw(project);
  final File target=new File(""String_Node_Str"");
  export(target,model,project);
}",0.9772727272727272
90828,"public static void main(final String[] args) throws IOException, JDOMException, SpimDataException {
  final String projectFolder=""String_Node_Str"";
  final String bdvFile=""String_Node_Str"";
  final MamutProject project=new MamutProject(new File(projectFolder),new File(bdvFile));
  final Model model=new Model();
  model.loadRaw(project.getRawModelFile());
  final Context context=new Context(MamutFeatureComputerService.class);
  final MamutFeatureComputerService featureComputerService=context.getService(MamutFeatureComputerService.class);
  final Set<FeatureComputer<Model>> featureComputers=new HashSet<>(featureComputerService.getFeatureComputers());
  final ProgressListener pl=new ProgressListener(){
    @Override public void showStatus(    final String string){
      System.out.println(""String_Node_Str"" + string);
    }
    @Override public void showProgress(    final int current,    final int total){
    }
    @Override public void clearStatus(){
    }
  }
;
  System.out.println(""String_Node_Str"");
  final boolean computed=featureComputerService.compute(model,model.getFeatureModel(),featureComputers,pl);
  if (!computed) {
    System.err.println(""String_Node_Str"");
    return;
  }
  final File target=new File(""String_Node_Str"");
  MamutExporter.export(target,model,project);
  final Model importedModel=new Model();
  TrackMateImporter.importModel(target,importedModel);
  System.out.println(MastodonUtil.dump(importedModel));
}","public static void main(final String[] args) throws IOException, JDOMException, SpimDataException {
  final String projectFolder=""String_Node_Str"";
  final String bdvFile=""String_Node_Str"";
  final MamutProject project=new MamutProject(new File(projectFolder),new File(bdvFile));
  final Model model=new Model();
  model.loadRaw(project);
  final Context context=new Context(MamutFeatureComputerService.class);
  final MamutFeatureComputerService featureComputerService=context.getService(MamutFeatureComputerService.class);
  final Set<FeatureComputer<Model>> featureComputers=new HashSet<>(featureComputerService.getFeatureComputers());
  final ProgressListener pl=new ProgressListener(){
    @Override public void showStatus(    final String string){
      System.out.println(""String_Node_Str"" + string);
    }
    @Override public void showProgress(    final int current,    final int total){
    }
    @Override public void clearStatus(){
    }
  }
;
  System.out.println(""String_Node_Str"");
  final boolean computed=featureComputerService.compute(model,model.getFeatureModel(),featureComputers,pl);
  if (!computed) {
    System.err.println(""String_Node_Str"");
    return;
  }
  final File target=new File(""String_Node_Str"");
  MamutExporter.export(target,model,project);
  final Model importedModel=new Model();
  TrackMateImporter.importModel(target,importedModel);
  System.out.println(MastodonUtil.dump(importedModel));
}",0.99375
90829,"private void deleteSelected(){
  final Item selected=(Item)comboBox.getSelectedItem();
  if (selected != null) {
    manager.delete(selected.profile);
    makeModel();
  }
}","private void deleteSelected(){
  final Item selected=(Item)comboBox.getSelectedItem();
  if (selected != null) {
    manager.delete(selected.profile);
    selectionListeners.list.forEach(l -> l.deselected(selected.profile));
    selectionListeners.list.forEach(l -> l.selected(manager.getSelectedProfile()));
    editor.loadProfile(manager.getSelectedProfile());
    makeModel();
  }
}",0.6200716845878136
90830,"private void duplicateSelected(){
  final Item selected=(Item)comboBox.getSelectedItem();
  if (selected != null) {
    editor.storeProfile(selected.profile);
    final T duplicate=manager.duplicate(selected.profile);
    manager.select(duplicate);
    editor.loadProfile(duplicate);
    makeModel();
  }
}","private void duplicateSelected(){
  final Item selected=(Item)comboBox.getSelectedItem();
  if (selected != null) {
    if (selected.profile.isBuiltin()) {
      final T duplicate=manager.duplicate(selected.profile);
      editor.storeProfile(duplicate);
      manager.select(duplicate);
      selectionListeners.list.forEach(l -> l.deselected(selected.profile));
      selectionListeners.list.forEach(l -> l.selected(duplicate));
    }
 else {
      editor.storeProfile(selected.profile);
      final T duplicate=manager.duplicate(selected.profile);
      manager.select(duplicate);
      selectionListeners.list.forEach(l -> l.deselected(selected.profile));
      selectionListeners.list.forEach(l -> l.selected(duplicate));
      editor.loadProfile(duplicate);
    }
    makeModel();
  }
}",0.5227686703096539
90831,"/** 
 * @param treePath path of this page in the settings tree.
 * @param profileManager
 * @param profileEditPanel
 */
public SelectAndEditProfileSettingsPage(final String treePath,final ProfileManager<T> profileManager,final ProfileEditPanel<T> profileEditPanel){
  this.treePath=treePath;
  this.profileManager=profileManager;
  this.profileEditPanel=profileEditPanel;
  final ProfileSelectionPanel<T> profileSelectionPanel=new ProfileSelectionPanel<>(profileManager,profileEditPanel);
  profileSelectionPanel.setBorder(new EmptyBorder(0,0,10,0));
  profileEditPanel.modificationListeners().add(profileSelectionPanel);
  modificationListeners=new Listeners.SynchronizedList<>();
  profileEditPanel.modificationListeners().add(() -> modificationListeners.list.forEach(ModificationListener::modified));
  profileSelectionPanel.selectionListeners().add(p -> modificationListeners.list.forEach(ModificationListener::modified));
  contentPanel=new JPanel(new BorderLayout());
  contentPanel.add(profileSelectionPanel,BorderLayout.NORTH);
  contentPanel.add(profileEditPanel.getJPanel(),BorderLayout.CENTER);
}","/** 
 * @param treePath path of this page in the settings tree.
 * @param profileManager
 * @param profileEditPanel
 */
public SelectAndEditProfileSettingsPage(final String treePath,final ProfileManager<T> profileManager,final ProfileEditPanel<T> profileEditPanel){
  this.treePath=treePath;
  this.profileManager=profileManager;
  this.profileEditPanel=profileEditPanel;
  profileSelectionPanel=new ProfileSelectionPanel<>(profileManager,profileEditPanel);
  profileSelectionPanel.setBorder(new EmptyBorder(0,0,10,0));
  profileEditPanel.modificationListeners().add(profileSelectionPanel);
  modificationListeners=new Listeners.SynchronizedList<>();
  profileEditPanel.modificationListeners().add(() -> modificationListeners.list.forEach(ModificationListener::modified));
  profileSelectionPanel.selectionListeners().add(p -> modificationListeners.list.forEach(ModificationListener::modified));
  contentPanel=new JPanel(new BorderLayout());
  contentPanel.add(profileSelectionPanel,BorderLayout.NORTH);
  contentPanel.add(profileEditPanel.getJPanel(),BorderLayout.CENTER);
}",0.9857993586807148
90832,"private void renameSelected(){
  final Item selected=(Item)comboBox.getSelectedItem();
  if (selected != null) {
    final String oldName=selected.getName();
    final String newName=(String)JOptionPane.showInputDialog(this,""String_Node_Str"",""String_Node_Str"",JOptionPane.PLAIN_MESSAGE,null,null,oldName);
    if (newName != null && !newName.equals(oldName)) {
      try {
        manager.rename(selected.profile,newName);
        makeModel();
      }
 catch (      final IllegalArgumentException e) {
        JOptionPane.showMessageDialog(this,e.getMessage(),""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
      }
    }
  }
}","private void renameSelected(){
  final Item selected=(Item)comboBox.getSelectedItem();
  if (selected != null) {
    final String oldName=selected.getName();
    final String newName=(String)JOptionPane.showInputDialog(this,""String_Node_Str"",""String_Node_Str"",JOptionPane.PLAIN_MESSAGE,null,null,oldName);
    if (newName != null && !newName.equals(oldName)) {
      try {
        manager.rename(selected.profile,newName);
        selectionListeners.list.forEach(l -> l.selected(selected.profile));
        makeModel();
      }
 catch (      final IllegalArgumentException e) {
        JOptionPane.showMessageDialog(this,e.getMessage(),""String_Node_Str"",JOptionPane.ERROR_MESSAGE);
      }
    }
  }
}",0.942684766214178
90833,"private void removeSelectedRow(){
  int row=table.getSelectedRow();
  if (row >= 0 || row < elements.size()) {
    elements.remove(elements.get(row));
    notifyListeners();
    tableModel.fireTableRowsDeleted(row,row);
    int s=Math.max(row - 1,0);
    table.setRowSelectionInterval(s,s);
    update();
  }
}","private void removeSelectedRow(){
  int row=table.getSelectedRow();
  if (row >= 0 && row < elements.size()) {
    elements.remove(elements.get(row));
    notifyListeners();
    tableModel.fireTableRowsDeleted(row,row);
    int s=Math.max(row - 1,0);
    table.setRowSelectionInterval(s,s);
    update();
  }
}",0.9935483870967742
90834,"private void editSelectedRow(){
  final int row=table.getSelectedRow();
  if (row < 0)   return;
 else   if (row == elements.size())   addAndEditRow();
 else   table.editCellAt(row,0);
}","private void editSelectedRow(){
  final int row=table.getSelectedRow();
  if (row == elements.size())   addAndEditRow();
 else   if (row >= 0)   table.editCellAt(row,0);
}",0.8683473389355743
90835,"public NavigationActionsMamut(final ViewerPanelMamut viewer){
  this.viewer=viewer;
}","public NavigationActionsMamut(final ViewerPanelMamut viewer){
  this.viewer=viewer;
  this.vg=viewer.getVisibilityAndGrouping();
}",0.7906976744186046
90836,"public ProfileSelectionPanel(final ProfileManager<T> manager,final ProfileEditPanel<T> editor){
  this.manager=manager;
  this.editor=editor;
  selectionListeners=new Listeners.SynchronizedList<>();
  comboBox=new JComboBox<>();
  comboBox.setEditable(false);
  final Dimension dim=new Dimension(300,comboBox.getPreferredSize().height);
  comboBox.setPreferredSize(dim);
  comboBox.setMaximumSize(dim);
  buttonDuplicate=new JButton(""String_Node_Str"");
  buttonRename=new JButton(""String_Node_Str"");
  buttonDelete=new JButton(""String_Node_Str"");
  comboBox.addItemListener(e -> {
    final T profile=((Item)e.getItem()).profile;
    if (e.getStateChange() == ItemEvent.SELECTED) {
      manager.select(profile);
      buttonDelete.setEnabled(!profile.isBuiltin());
      buttonRename.setEnabled(!profile.isBuiltin());
      selectionListeners.list.forEach(l -> l.selected(profile));
      editor.loadProfile(profile);
    }
 else {
      selectionListeners.list.forEach(l -> l.deselected(profile));
      editor.storeProfile(profile);
    }
  }
);
  buttonDuplicate.addActionListener(e -> duplicateSelected());
  buttonRename.addActionListener(e -> renameSelected());
  buttonDelete.addActionListener(e -> deleteSelected());
  setLayout(new BoxLayout(this,BoxLayout.LINE_AXIS));
  add(Box.createHorizontalGlue());
  add(comboBox);
  add(buttonDuplicate);
  add(buttonRename);
  add(buttonDelete);
  add(Box.createHorizontalGlue());
  makeModel();
}","public ProfileSelectionPanel(final ProfileManager<T> manager,final ProfileEditPanel<T> editor){
  this.manager=manager;
  this.editor=editor;
  selectionListeners=new Listeners.SynchronizedList<>();
  comboBox=new JComboBox<>();
  comboBox.setEditable(false);
  final Dimension dim=new Dimension(300,comboBox.getPreferredSize().height);
  comboBox.setPreferredSize(dim);
  comboBox.setMaximumSize(dim);
  buttonDuplicate=new JButton(""String_Node_Str"");
  buttonRename=new JButton(""String_Node_Str"");
  buttonDelete=new JButton(""String_Node_Str"");
  comboBox.addItemListener(e -> {
    if (blockComboBoxItemListener)     return;
    final T profile=((Item)e.getItem()).profile;
    if (e.getStateChange() == ItemEvent.SELECTED) {
      manager.select(profile);
      buttonDelete.setEnabled(!profile.isBuiltin());
      buttonRename.setEnabled(!profile.isBuiltin());
      selectionListeners.list.forEach(l -> l.selected(profile));
      editor.loadProfile(profile);
    }
 else {
      selectionListeners.list.forEach(l -> l.deselected(profile));
      editor.storeProfile(profile);
    }
  }
);
  buttonDuplicate.addActionListener(e -> duplicateSelected());
  buttonRename.addActionListener(e -> renameSelected());
  buttonDelete.addActionListener(e -> deleteSelected());
  setLayout(new BoxLayout(this,BoxLayout.LINE_AXIS));
  add(Box.createHorizontalGlue());
  add(comboBox);
  add(buttonDuplicate);
  add(buttonRename);
  add(buttonDelete);
  add(Box.createHorizontalGlue());
  makeModel();
}",0.9840407470288624
90837,"private void duplicateSelected(){
  final Item selected=(Item)comboBox.getSelectedItem();
  if (selected != null) {
    final T duplicate=manager.duplicate(selected.profile);
    editor.storeProfile(duplicate);
    manager.select(duplicate);
    editor.loadProfile(selected.profile);
    makeModel();
  }
}","private void duplicateSelected(){
  final Item selected=(Item)comboBox.getSelectedItem();
  if (selected != null) {
    editor.storeProfile(selected.profile);
    final T duplicate=manager.duplicate(selected.profile);
    manager.select(duplicate);
    editor.loadProfile(duplicate);
    makeModel();
  }
}",0.7222222222222222
90838,"private void makeModel(){
  final Vector<Item> items=new Vector<>();
  manager.getProfiles().forEach(profile -> items.add(new Item(profile)));
  comboBox.setModel(new DefaultComboBoxModel<>(items));
  final Item selectedItem=new Item(manager.getSelectedProfile());
  buttonDelete.setEnabled(!selectedItem.isBuiltin());
  buttonRename.setEnabled(!selectedItem.isBuiltin());
  comboBox.setSelectedIndex(items.indexOf(selectedItem));
}","private void makeModel(){
  final Vector<Item> items=new Vector<>();
  manager.getProfiles().forEach(profile -> items.add(new Item(profile)));
  comboBox.setModel(new DefaultComboBoxModel<>(items));
  final Item selectedItem=new Item(manager.getSelectedProfile());
  buttonDelete.setEnabled(!selectedItem.isBuiltin());
  buttonRename.setEnabled(!selectedItem.isBuiltin());
  blockComboBoxItemListener=true;
  comboBox.setSelectedIndex(items.indexOf(selectedItem));
  blockComboBoxItemListener=false;
}",0.9260450160771704
90839,"public SettingsPanel(){
  root=new DefaultMutableTreeNode(new SettingsNodeData(""String_Node_Str"",null));
  model=new DefaultTreeModel(root);
  tree=new FullWidthSelectionJTree(model);
  breadcrumbs=new JPanel();
  breadcrumbs.setLayout(new BoxLayout(breadcrumbs,BoxLayout.LINE_AXIS));
  breadcrumbs.setBorder(new EmptyBorder(5,5,5,0));
  setBreadCrumbs(root);
  final CardLayout cardLayout=new CardLayout();
  pages=new JPanel(cardLayout);
  tree.setEditable(false);
  tree.setSelectionRow(0);
  tree.setRootVisible(false);
  tree.setShowsRootHandles(true);
  tree.setExpandsSelectedPaths(true);
  tree.getSelectionModel().setSelectionMode(TreeSelectionModel.SINGLE_TREE_SELECTION);
  final DefaultTreeCellRenderer renderer=new DefaultTreeCellRenderer();
  renderer.setIcon(null);
  renderer.setLeafIcon(null);
  renderer.setOpenIcon(null);
  renderer.setClosedIcon(null);
  renderer.setBackgroundNonSelectionColor(tree.getBackground());
  final Color bg=renderer.getBackgroundSelectionColor();
  tree.setBackgroundSelectionColor(bg);
  tree.setCellRenderer(renderer);
  tree.getSelectionModel().addTreeSelectionListener(new TreeSelectionListener(){
    @Override public void valueChanged(    final TreeSelectionEvent e){
      final DefaultMutableTreeNode selectedNode=(DefaultMutableTreeNode)tree.getLastSelectedPathComponent();
      if (selectedNode != null) {
        setBreadCrumbs(selectedNode);
        final SettingsNodeData data=(SettingsNodeData)selectedNode.getUserObject();
        if (data.page != null)         cardLayout.show(pages,data.page.getTreePath());
      }
    }
  }
);
  final JButton cancel=new JButton(""String_Node_Str"");
  final JButton apply=new JButton(""String_Node_Str"");
  final JButton ok=new JButton(""String_Node_Str"");
  final JPanel buttons=new JPanel();
  buttons.setLayout(new BoxLayout(buttons,BoxLayout.LINE_AXIS));
  buttons.add(Box.createHorizontalGlue());
  buttons.add(cancel);
  buttons.add(apply);
  buttons.add(ok);
  final JPanel content=new JPanel(new BorderLayout());
  content.add(breadcrumbs,BorderLayout.NORTH);
  content.add(pages,BorderLayout.CENTER);
  content.setBorder(new EmptyBorder(10,0,10,10));
  final JScrollPane treeScrollPane=new JScrollPane(tree);
  treeScrollPane.setPreferredSize(new Dimension(500,500));
  treeScrollPane.setBorder(new MatteBorder(0,0,0,1,Color.LIGHT_GRAY));
  final JSplitPane splitPane=new JSplitPane(JSplitPane.HORIZONTAL_SPLIT,treeScrollPane,content);
  splitPane.setResizeWeight(0);
  splitPane.setContinuousLayout(true);
  splitPane.setDividerSize(10);
  splitPane.setDividerLocation(300);
  splitPane.setBorder(new MatteBorder(0,0,1,0,Color.LIGHT_GRAY));
  this.setLayout(new BorderLayout());
  this.add(splitPane,BorderLayout.CENTER);
  buttons.setBorder(new EmptyBorder(10,0,5,10));
  this.add(buttons,BorderLayout.SOUTH);
  runOnCancel=new ArrayList<>();
  runOnOk=new ArrayList<>();
  cancel.addActionListener(e -> cancel());
  ok.addActionListener(e -> {
    getPages().forEach(SettingsPage::apply);
    runOnOk.forEach(Runnable::run);
  }
);
  apply.setEnabled(false);
  modificationListener=() -> apply.setEnabled(true);
  apply.addActionListener(e -> {
    apply.setEnabled(false);
    getPages().forEach(SettingsPage::apply);
  }
);
}","public SettingsPanel(){
  root=new DefaultMutableTreeNode(new SettingsNodeData(""String_Node_Str"",null));
  model=new DefaultTreeModel(root);
  tree=new FullWidthSelectionJTree(model);
  breadcrumbs=new JPanel();
  breadcrumbs.setLayout(new BoxLayout(breadcrumbs,BoxLayout.LINE_AXIS));
  breadcrumbs.setBorder(new EmptyBorder(5,5,5,0));
  setBreadCrumbs(root);
  final CardLayout cardLayout=new CardLayout();
  pages=new JPanel(cardLayout);
  tree.setEditable(false);
  tree.setSelectionRow(0);
  tree.setRootVisible(false);
  tree.setShowsRootHandles(true);
  tree.setExpandsSelectedPaths(true);
  tree.getSelectionModel().setSelectionMode(TreeSelectionModel.SINGLE_TREE_SELECTION);
  final DefaultTreeCellRenderer renderer=new DefaultTreeCellRenderer();
  renderer.setIcon(null);
  renderer.setLeafIcon(null);
  renderer.setOpenIcon(null);
  renderer.setClosedIcon(null);
  renderer.setBackgroundNonSelectionColor(tree.isOpaque() ? tree.getBackground() : this.getBackground());
  final Color bg=renderer.getBackgroundSelectionColor();
  tree.setBackgroundSelectionColor(bg);
  tree.setCellRenderer(renderer);
  tree.getSelectionModel().addTreeSelectionListener(new TreeSelectionListener(){
    @Override public void valueChanged(    final TreeSelectionEvent e){
      final DefaultMutableTreeNode selectedNode=(DefaultMutableTreeNode)tree.getLastSelectedPathComponent();
      if (selectedNode != null) {
        setBreadCrumbs(selectedNode);
        final SettingsNodeData data=(SettingsNodeData)selectedNode.getUserObject();
        if (data.page != null)         cardLayout.show(pages,data.page.getTreePath());
      }
    }
  }
);
  final JButton cancel=new JButton(""String_Node_Str"");
  final JButton apply=new JButton(""String_Node_Str"");
  final JButton ok=new JButton(""String_Node_Str"");
  final JPanel buttons=new JPanel();
  buttons.setLayout(new BoxLayout(buttons,BoxLayout.LINE_AXIS));
  buttons.add(Box.createHorizontalGlue());
  buttons.add(cancel);
  buttons.add(apply);
  buttons.add(ok);
  final JPanel content=new JPanel(new BorderLayout());
  content.add(breadcrumbs,BorderLayout.NORTH);
  content.add(pages,BorderLayout.CENTER);
  content.setBorder(new EmptyBorder(10,0,10,10));
  final JScrollPane treeScrollPane=new JScrollPane(tree);
  treeScrollPane.setPreferredSize(new Dimension(500,500));
  treeScrollPane.setBorder(new MatteBorder(0,0,0,1,Color.LIGHT_GRAY));
  final JSplitPane splitPane=new JSplitPane(JSplitPane.HORIZONTAL_SPLIT,treeScrollPane,content);
  splitPane.setResizeWeight(0);
  splitPane.setContinuousLayout(true);
  splitPane.setDividerSize(10);
  splitPane.setDividerLocation(300);
  splitPane.setBorder(new MatteBorder(0,0,1,0,Color.LIGHT_GRAY));
  this.setLayout(new BorderLayout());
  this.add(splitPane,BorderLayout.CENTER);
  buttons.setBorder(new EmptyBorder(10,0,5,10));
  this.add(buttons,BorderLayout.SOUTH);
  runOnCancel=new ArrayList<>();
  runOnOk=new ArrayList<>();
  cancel.addActionListener(e -> cancel());
  ok.addActionListener(e -> {
    getPages().forEach(SettingsPage::apply);
    runOnOk.forEach(Runnable::run);
  }
);
  apply.setEnabled(false);
  modificationListener=() -> apply.setEnabled(true);
  apply.addActionListener(e -> {
    apply.setEnabled(false);
    getPages().forEach(SettingsPage::apply);
  }
);
}",0.9937068303914044
90840,"public SettingsPanel(){
  root=new DefaultMutableTreeNode(new SettingsNodeData(""String_Node_Str"",null));
  model=new DefaultTreeModel(root);
  tree=new FullWidthSelectionJTree(model);
  breadcrumbs=new JPanel();
  breadcrumbs.setLayout(new BoxLayout(breadcrumbs,BoxLayout.LINE_AXIS));
  breadcrumbs.setBorder(new EmptyBorder(5,5,5,0));
  setBreadCrumbs(root);
  final CardLayout cardLayout=new CardLayout();
  pages=new JPanel(cardLayout);
  tree.setEditable(false);
  tree.setSelectionRow(0);
  tree.setRootVisible(false);
  tree.setShowsRootHandles(true);
  tree.setExpandsSelectedPaths(true);
  tree.getSelectionModel().setSelectionMode(TreeSelectionModel.SINGLE_TREE_SELECTION);
  final DefaultTreeCellRenderer renderer=new DefaultTreeCellRenderer();
  renderer.setIcon(null);
  renderer.setLeafIcon(null);
  renderer.setOpenIcon(null);
  renderer.setClosedIcon(null);
  renderer.setBackgroundNonSelectionColor(tree.isOpaque() ? tree.getBackground() : this.getBackground());
  final Color bg=renderer.getBackgroundSelectionColor();
  tree.setBackgroundSelectionColor(bg);
  tree.setCellRenderer(renderer);
  tree.getSelectionModel().addTreeSelectionListener(new TreeSelectionListener(){
    @Override public void valueChanged(    final TreeSelectionEvent e){
      final DefaultMutableTreeNode selectedNode=(DefaultMutableTreeNode)tree.getLastSelectedPathComponent();
      if (selectedNode != null) {
        setBreadCrumbs(selectedNode);
        final SettingsNodeData data=(SettingsNodeData)selectedNode.getUserObject();
        if (data.page != null)         cardLayout.show(pages,data.page.getTreePath());
      }
    }
  }
);
  final JButton cancel=new JButton(""String_Node_Str"");
  final JButton apply=new JButton(""String_Node_Str"");
  final JButton ok=new JButton(""String_Node_Str"");
  final JPanel buttons=new JPanel();
  buttons.setLayout(new BoxLayout(buttons,BoxLayout.LINE_AXIS));
  buttons.add(Box.createHorizontalGlue());
  buttons.add(cancel);
  buttons.add(apply);
  buttons.add(ok);
  final JPanel content=new JPanel(new BorderLayout());
  content.add(breadcrumbs,BorderLayout.NORTH);
  content.add(pages,BorderLayout.CENTER);
  content.setBorder(new EmptyBorder(10,0,10,10));
  final JScrollPane treeScrollPane=new JScrollPane(tree);
  treeScrollPane.setPreferredSize(new Dimension(500,500));
  treeScrollPane.setBorder(new MatteBorder(0,0,0,1,Color.LIGHT_GRAY));
  final JSplitPane splitPane=new JSplitPane(JSplitPane.HORIZONTAL_SPLIT,treeScrollPane,content);
  splitPane.setResizeWeight(0);
  splitPane.setContinuousLayout(true);
  splitPane.setDividerSize(10);
  splitPane.setDividerLocation(300);
  splitPane.setBorder(new MatteBorder(0,0,1,0,Color.LIGHT_GRAY));
  this.setLayout(new BorderLayout());
  this.add(splitPane,BorderLayout.CENTER);
  buttons.setBorder(new EmptyBorder(10,0,5,10));
  this.add(buttons,BorderLayout.SOUTH);
  runOnCancel=new ArrayList<>();
  runOnOk=new ArrayList<>();
  cancel.addActionListener(e -> cancel());
  ok.addActionListener(e -> {
    getPages().forEach(SettingsPage::apply);
    runOnOk.forEach(Runnable::run);
  }
);
  apply.setEnabled(false);
  modificationListener=() -> apply.setEnabled(true);
  apply.addActionListener(e -> {
    apply.setEnabled(false);
    getPages().forEach(SettingsPage::apply);
  }
);
}","public SettingsPanel(){
  root=new DefaultMutableTreeNode(new SettingsNodeData(""String_Node_Str"",null));
  model=new DefaultTreeModel(root);
  tree=new FullWidthSelectionJTree(model);
  breadcrumbs=new JPanel();
  breadcrumbs.setLayout(new BoxLayout(breadcrumbs,BoxLayout.LINE_AXIS));
  breadcrumbs.setBorder(new EmptyBorder(5,5,5,0));
  setBreadCrumbs(root);
  final CardLayout cardLayout=new CardLayout();
  pages=new JPanel(cardLayout);
  tree.setEditable(false);
  tree.setSelectionRow(0);
  tree.setRootVisible(false);
  tree.setShowsRootHandles(true);
  tree.setExpandsSelectedPaths(true);
  tree.getSelectionModel().setSelectionMode(TreeSelectionModel.SINGLE_TREE_SELECTION);
  final DefaultTreeCellRenderer renderer=new DefaultTreeCellRenderer();
  renderer.setIcon(null);
  renderer.setLeafIcon(null);
  renderer.setOpenIcon(null);
  renderer.setClosedIcon(null);
  final Color bg=renderer.getBackgroundSelectionColor();
  tree.setBackgroundSelectionColor(bg);
  tree.setCellRenderer(renderer);
  tree.getSelectionModel().addTreeSelectionListener(new TreeSelectionListener(){
    @Override public void valueChanged(    final TreeSelectionEvent e){
      final DefaultMutableTreeNode selectedNode=(DefaultMutableTreeNode)tree.getLastSelectedPathComponent();
      if (selectedNode != null) {
        setBreadCrumbs(selectedNode);
        final SettingsNodeData data=(SettingsNodeData)selectedNode.getUserObject();
        if (data.page != null)         cardLayout.show(pages,data.page.getTreePath());
      }
    }
  }
);
  final JButton cancel=new JButton(""String_Node_Str"");
  final JButton apply=new JButton(""String_Node_Str"");
  final JButton ok=new JButton(""String_Node_Str"");
  final JPanel buttons=new JPanel();
  buttons.setLayout(new BoxLayout(buttons,BoxLayout.LINE_AXIS));
  buttons.add(Box.createHorizontalGlue());
  buttons.add(cancel);
  buttons.add(apply);
  buttons.add(ok);
  final JPanel content=new JPanel(new BorderLayout());
  content.add(breadcrumbs,BorderLayout.NORTH);
  content.add(pages,BorderLayout.CENTER);
  content.setBorder(new EmptyBorder(10,0,10,10));
  final JScrollPane treeScrollPane=new JScrollPane(tree);
  treeScrollPane.setPreferredSize(new Dimension(500,500));
  treeScrollPane.setBorder(new MatteBorder(0,0,0,1,Color.LIGHT_GRAY));
  renderer.setBackgroundNonSelectionColor(treeScrollPane.getBackground());
  final JSplitPane splitPane=new JSplitPane(JSplitPane.HORIZONTAL_SPLIT,treeScrollPane,content);
  splitPane.setResizeWeight(0);
  splitPane.setContinuousLayout(true);
  splitPane.setDividerSize(10);
  splitPane.setDividerLocation(300);
  splitPane.setBorder(new MatteBorder(0,0,1,0,Color.LIGHT_GRAY));
  this.setLayout(new BorderLayout());
  this.add(splitPane,BorderLayout.CENTER);
  buttons.setBorder(new EmptyBorder(10,0,5,10));
  this.add(buttons,BorderLayout.SOUTH);
  runOnCancel=new ArrayList<>();
  runOnOk=new ArrayList<>();
  cancel.addActionListener(e -> cancel());
  ok.addActionListener(e -> {
    getPages().forEach(SettingsPage::apply);
    runOnOk.forEach(Runnable::run);
  }
);
  apply.setEnabled(false);
  modificationListener=() -> apply.setEnabled(true);
  apply.addActionListener(e -> {
    apply.setEnabled(false);
    getPages().forEach(SettingsPage::apply);
  }
);
}",0.9722605363984674
90841,"public SettingsPanel(){
  root=new DefaultMutableTreeNode(new SettingsNodeData(""String_Node_Str"",null));
  model=new DefaultTreeModel(root);
  tree=new FullWidthSelectionJTree(model);
  breadcrumbs=new JPanel();
  breadcrumbs.setLayout(new BoxLayout(breadcrumbs,BoxLayout.LINE_AXIS));
  breadcrumbs.setBorder(new EmptyBorder(5,5,5,0));
  setBreadCrumbs(root);
  final CardLayout cardLayout=new CardLayout();
  pages=new JPanel(cardLayout);
  tree.setEditable(false);
  tree.setSelectionRow(0);
  tree.setRootVisible(false);
  tree.setShowsRootHandles(true);
  tree.setExpandsSelectedPaths(true);
  tree.getSelectionModel().setSelectionMode(TreeSelectionModel.SINGLE_TREE_SELECTION);
  final DefaultTreeCellRenderer renderer=new DefaultTreeCellRenderer();
  renderer.setIcon(null);
  renderer.setLeafIcon(null);
  renderer.setOpenIcon(null);
  renderer.setClosedIcon(null);
  renderer.setBackgroundNonSelectionColor(getBackground());
  final Color bg=renderer.getBackgroundSelectionColor();
  tree.setBackgroundSelectionColor(bg);
  tree.setCellRenderer(renderer);
  tree.getSelectionModel().addTreeSelectionListener(new TreeSelectionListener(){
    @Override public void valueChanged(    final TreeSelectionEvent e){
      final DefaultMutableTreeNode selectedNode=(DefaultMutableTreeNode)tree.getLastSelectedPathComponent();
      if (selectedNode != null) {
        setBreadCrumbs(selectedNode);
        final SettingsNodeData data=(SettingsNodeData)selectedNode.getUserObject();
        if (data.page != null)         cardLayout.show(pages,data.page.getTreePath());
      }
    }
  }
);
  final JButton cancel=new JButton(""String_Node_Str"");
  final JButton apply=new JButton(""String_Node_Str"");
  final JButton ok=new JButton(""String_Node_Str"");
  final JPanel buttons=new JPanel();
  buttons.setLayout(new BoxLayout(buttons,BoxLayout.LINE_AXIS));
  buttons.add(Box.createHorizontalGlue());
  buttons.add(cancel);
  buttons.add(apply);
  buttons.add(ok);
  final JPanel content=new JPanel(new BorderLayout());
  content.add(breadcrumbs,BorderLayout.NORTH);
  content.add(pages,BorderLayout.CENTER);
  content.setBorder(new EmptyBorder(10,0,10,10));
  final JScrollPane treeScrollPane=new JScrollPane(tree);
  treeScrollPane.setPreferredSize(new Dimension(500,500));
  treeScrollPane.setBorder(new MatteBorder(0,0,0,1,Color.LIGHT_GRAY));
  final JSplitPane splitPane=new JSplitPane(JSplitPane.HORIZONTAL_SPLIT,treeScrollPane,content);
  splitPane.setResizeWeight(0);
  splitPane.setContinuousLayout(true);
  splitPane.setDividerSize(10);
  splitPane.setDividerLocation(300);
  splitPane.setBorder(new MatteBorder(0,0,1,0,Color.LIGHT_GRAY));
  this.setLayout(new BorderLayout());
  this.add(splitPane,BorderLayout.CENTER);
  buttons.setBorder(new EmptyBorder(10,0,5,10));
  this.add(buttons,BorderLayout.SOUTH);
  runOnCancel=new ArrayList<>();
  runOnOk=new ArrayList<>();
  cancel.addActionListener(e -> cancel());
  ok.addActionListener(e -> {
    getPages().forEach(SettingsPage::apply);
    runOnOk.forEach(Runnable::run);
  }
);
  apply.setEnabled(false);
  modificationListener=() -> apply.setEnabled(true);
  apply.addActionListener(e -> {
    apply.setEnabled(false);
    getPages().forEach(SettingsPage::apply);
  }
);
}","public SettingsPanel(){
  root=new DefaultMutableTreeNode(new SettingsNodeData(""String_Node_Str"",null));
  model=new DefaultTreeModel(root);
  tree=new FullWidthSelectionJTree(model);
  breadcrumbs=new JPanel();
  breadcrumbs.setLayout(new BoxLayout(breadcrumbs,BoxLayout.LINE_AXIS));
  breadcrumbs.setBorder(new EmptyBorder(5,5,5,0));
  setBreadCrumbs(root);
  final CardLayout cardLayout=new CardLayout();
  pages=new JPanel(cardLayout);
  tree.setEditable(false);
  tree.setSelectionRow(0);
  tree.setRootVisible(false);
  tree.setShowsRootHandles(true);
  tree.setExpandsSelectedPaths(true);
  tree.getSelectionModel().setSelectionMode(TreeSelectionModel.SINGLE_TREE_SELECTION);
  final DefaultTreeCellRenderer renderer=new DefaultTreeCellRenderer();
  renderer.setIcon(null);
  renderer.setLeafIcon(null);
  renderer.setOpenIcon(null);
  renderer.setClosedIcon(null);
  renderer.setBackgroundNonSelectionColor(tree.getBackground());
  final Color bg=renderer.getBackgroundSelectionColor();
  tree.setBackgroundSelectionColor(bg);
  tree.setCellRenderer(renderer);
  tree.getSelectionModel().addTreeSelectionListener(new TreeSelectionListener(){
    @Override public void valueChanged(    final TreeSelectionEvent e){
      final DefaultMutableTreeNode selectedNode=(DefaultMutableTreeNode)tree.getLastSelectedPathComponent();
      if (selectedNode != null) {
        setBreadCrumbs(selectedNode);
        final SettingsNodeData data=(SettingsNodeData)selectedNode.getUserObject();
        if (data.page != null)         cardLayout.show(pages,data.page.getTreePath());
      }
    }
  }
);
  final JButton cancel=new JButton(""String_Node_Str"");
  final JButton apply=new JButton(""String_Node_Str"");
  final JButton ok=new JButton(""String_Node_Str"");
  final JPanel buttons=new JPanel();
  buttons.setLayout(new BoxLayout(buttons,BoxLayout.LINE_AXIS));
  buttons.add(Box.createHorizontalGlue());
  buttons.add(cancel);
  buttons.add(apply);
  buttons.add(ok);
  final JPanel content=new JPanel(new BorderLayout());
  content.add(breadcrumbs,BorderLayout.NORTH);
  content.add(pages,BorderLayout.CENTER);
  content.setBorder(new EmptyBorder(10,0,10,10));
  final JScrollPane treeScrollPane=new JScrollPane(tree);
  treeScrollPane.setPreferredSize(new Dimension(500,500));
  treeScrollPane.setBorder(new MatteBorder(0,0,0,1,Color.LIGHT_GRAY));
  final JSplitPane splitPane=new JSplitPane(JSplitPane.HORIZONTAL_SPLIT,treeScrollPane,content);
  splitPane.setResizeWeight(0);
  splitPane.setContinuousLayout(true);
  splitPane.setDividerSize(10);
  splitPane.setDividerLocation(300);
  splitPane.setBorder(new MatteBorder(0,0,1,0,Color.LIGHT_GRAY));
  this.setLayout(new BorderLayout());
  this.add(splitPane,BorderLayout.CENTER);
  buttons.setBorder(new EmptyBorder(10,0,5,10));
  this.add(buttons,BorderLayout.SOUTH);
  runOnCancel=new ArrayList<>();
  runOnOk=new ArrayList<>();
  cancel.addActionListener(e -> cancel());
  ok.addActionListener(e -> {
    getPages().forEach(SettingsPage::apply);
    runOnOk.forEach(Runnable::run);
  }
);
  apply.setEnabled(false);
  modificationListener=() -> apply.setEnabled(true);
  apply.addActionListener(e -> {
    apply.setEnabled(false);
    getPages().forEach(SettingsPage::apply);
  }
);
}",0.9992270830112846
90842,"private void duplicateSelected(){
  final Item selected=(Item)comboBox.getSelectedItem();
  if (selected != null) {
    final T duplicate=manager.duplicate(selected.profile);
    manager.select(duplicate);
    editor.storeProfile(duplicate);
    editor.loadProfile(selected.profile);
    makeModel();
  }
}","private void duplicateSelected(){
  final Item selected=(Item)comboBox.getSelectedItem();
  if (selected != null) {
    final T duplicate=manager.duplicate(selected.profile);
    editor.storeProfile(duplicate);
    manager.select(duplicate);
    editor.loadProfile(selected.profile);
    makeModel();
  }
}",0.869281045751634
90843,"/** 
 * Returns the   {@link TrackSchemeEdge} currently painted on this display atscreen coordinates specified by  {@code x} and {@code y} and within adistance tolerance. <p> This method exists to facilitate writing mouse handlers. <p> Note that this really only looks at edges that are individually painted on the screen. Edges inside dense ranges are ignored.
 * @param x the x screen coordinate
 * @param y the y screen coordinate
 * @param tolerance the maximal distance to the closest edge.
 * @param ref a reference that will be used to retrieve the result.
 * @return the {@link TrackSchemeEdge} at {@code (x, y)}, or   {@code null} ifthere is no edge within the distance tolerance.
 */
public TrackSchemeEdge getEdgeAt(final int x,final int y,final double tolerance,final TrackSchemeEdge ref){
synchronized (entities) {
    final RealPoint pos=new RealPoint(x,y);
    final RefList<ScreenVertex> vertices=entities.getVertices();
    final ScreenVertex vt=vertices.createRef();
    final ScreenVertex vs=vertices.createRef();
    int i=-1;
    for (    final ScreenEdge e : entities.getEdges()) {
      vertices.get(e.getSourceScreenVertexIndex(),vs);
      vertices.get(e.getTargetScreenVertexIndex(),vt);
      if (distanceToPaintedEdge(pos,e,vs,vt) <= tolerance) {
        i=e.getTrackSchemeEdgeId();
        break;
      }
    }
    vertices.releaseRef(vs);
    vertices.releaseRef(vt);
    if (i < 0)     return null;
    graph.getEdgePool().getObject(i,ref);
    return ref;
  }
}","/** 
 * Returns the   {@link TrackSchemeEdge} currently painted on this display atscreen coordinates specified by  {@code x} and {@code y} and within adistance tolerance. <p> This method exists to facilitate writing mouse handlers. <p> Note that this really only looks at edges that are individually painted on the screen. Edges inside dense ranges are ignored.
 * @param x the x screen coordinate
 * @param y the y screen coordinate
 * @param tolerance the maximal distance to the closest edge.
 * @param ref a reference that will be used to retrieve the result.
 * @return the {@link TrackSchemeEdge} at {@code (x, y)}, or   {@code null} ifthere is no edge within the distance tolerance.
 */
public TrackSchemeEdge getEdgeAt(final int x,final int y,final double tolerance,final TrackSchemeEdge ref){
synchronized (entities) {
    final RealPoint pos=new RealPoint(x,y);
    final RefList<ScreenVertex> vertices=entities.getVertices();
    final ScreenVertex vt=vertices.createRef();
    final ScreenVertex vs=vertices.createRef();
    int i=-1;
    for (    final ScreenEdge e : entities.getEdges()) {
      vertices.get(e.getSourceScreenVertexIndex(),vs);
      vertices.get(e.getTargetScreenVertexIndex(),vt);
      if (distanceToPaintedEdge(pos,e,vs,vt) <= tolerance) {
        i=e.getTrackSchemeEdgeId();
        break;
      }
    }
    vertices.releaseRef(vs);
    vertices.releaseRef(vt);
    return (i >= 0) ? graph.getEdgePool().getObjectIfExists(i,ref) : null;
  }
}",0.9761023224503534
90844,"/** 
 * Returns the   {@link TrackSchemeVertex} currently painted on this displayat screen coordinates specified by  {@code x} and {@code y}. <p> This method exists to facilitate writing mouse handlers. <p> Note that this really only looks at vertices that are individually painted on the screen. Vertices inside dense ranges are ignored.
 * @param x the x screen coordinate
 * @param y the y screen coordinate
 * @param ref a reference that will be used to retrieve the result.
 * @return the {@link TrackSchemeVertex} at{@code (x, y)}, or   {@code null} if there is no vertex at this position.
 */
public TrackSchemeVertex getVertexAt(final int x,final int y,final TrackSchemeVertex ref){
synchronized (entities) {
    double d2Best=Double.POSITIVE_INFINITY;
    int iBest=-1;
    final RealPoint pos=new RealPoint(x,y);
    for (    final ScreenVertex v : entities.getVertices()) {
      if (isInsidePaintedVertex(pos,v)) {
        final int i=v.getTrackSchemeVertexId();
        if (i >= 0) {
          final double dx=v.getX() - x;
          final double dy=v.getY() - y;
          final double d2=dx * dx + dy * dy;
          if (d2 < d2Best) {
            d2Best=d2;
            iBest=i;
          }
        }
      }
    }
    if (iBest >= 0) {
      graph.getVertexPool().getObject(iBest,ref);
      return ref;
    }
    return null;
  }
}","/** 
 * Returns the   {@link TrackSchemeVertex} currently painted on this displayat screen coordinates specified by  {@code x} and {@code y}. <p> This method exists to facilitate writing mouse handlers. <p> Note that this really only looks at vertices that are individually painted on the screen. Vertices inside dense ranges are ignored.
 * @param x the x screen coordinate
 * @param y the y screen coordinate
 * @param ref a reference that will be used to retrieve the result.
 * @return the {@link TrackSchemeVertex} at{@code (x, y)}, or   {@code null} if there is no vertex at this position.
 */
public TrackSchemeVertex getVertexAt(final int x,final int y,final TrackSchemeVertex ref){
synchronized (entities) {
    double d2Best=Double.POSITIVE_INFINITY;
    int iBest=-1;
    final RealPoint pos=new RealPoint(x,y);
    for (    final ScreenVertex v : entities.getVertices()) {
      if (isInsidePaintedVertex(pos,v)) {
        final int i=v.getTrackSchemeVertexId();
        if (i >= 0) {
          final double dx=v.getX() - x;
          final double dy=v.getY() - y;
          final double d2=dx * dx + dy * dy;
          if (d2 < d2Best) {
            d2Best=d2;
            iBest=i;
          }
        }
      }
    }
    return (iBest >= 0) ? graph.getVertexPool().getObjectIfExists(iBest,ref) : null;
  }
}",0.9730337078651684
90845,"/** 
 * Saves this model to the specified raw file using the specified serializer.
 * @param file the raw file to save.
 * @param serializer the serializer used for writing individual vertices.
 * @param vertexFeaturesToSerialize the vertex features to serialize.
 * @param edgeFeaturesToSerialize the edge features to serialize.
 * @throws IOException if an I/O error occurs while writing the file.
 */
public void saveRaw(final File file,final GraphSerializer<V,E> serializer) throws IOException {
  final FileOutputStream fos=new FileOutputStream(file);
  final ObjectOutputStream oos=new ObjectOutputStream(new BufferedOutputStream(fos,1024 * 1024));
  final GraphToFileIdMap<V,E> fileIdMap=RawGraphIO.write(this,idmap,serializer,oos);
  RawPropertyIO.writePropertyMaps(fileIdMap.vertices(),vertexPropertySerializers,oos);
  oos.close();
}","/** 
 * Saves this model to the specified raw file using the specified serializer.
 * @param file the raw file to save.
 * @param serializer the serializer used for writing individual vertices. //	 * @param vertexFeaturesToSerialize //	 *            the vertex features to serialize. //	 * @param edgeFeaturesToSerialize //	 *            the edge features to serialize.
 * @throws IOException if an I/O error occurs while writing the file.
 */
public void saveRaw(final File file,final GraphSerializer<V,E> serializer) throws IOException {
  final FileOutputStream fos=new FileOutputStream(file);
  final ObjectOutputStream oos=new ObjectOutputStream(new BufferedOutputStream(fos,1024 * 1024));
  final GraphToFileIdMap<V,E> fileIdMap=RawGraphIO.write(this,idmap,serializer,oos);
  RawPropertyIO.writePropertyMaps(fileIdMap.vertices(),vertexPropertySerializers,oos);
  oos.close();
}",0.9745075318655853
90846,"/** 
 * Sets the selected state of an edge.
 * @param e an edge.
 * @param selected selected state to set for specified edge.
 */
public void setSelected(final E edge,final boolean selected);","/** 
 * Sets the selected state of an edge.
 * @param edge an edge.
 * @param selected selected state to set for specified edge.
 */
public void setSelected(final E edge,final boolean selected);",0.9922077922077922
90847,"/** 
 * Get the selected state of an edge.
 * @param e an edge.
 * @return {@code true} if specified edge is selected.
 */
public boolean isSelected(final E edge);","/** 
 * Get the selected state of an edge.
 * @param edge an edge.
 * @return {@code true} if specified edge is selected.
 */
public boolean isSelected(final E edge);",0.9908814589665652
90848,"/** 
 * Toggles the selected state of an edge.
 * @param e an edge.
 */
public void toggle(final E edge);","/** 
 * Toggles the selected state of an edge.
 * @param edge an edge.
 */
public void toggle(final E edge);",0.9859154929577464
90849,"/** 
 * Get the   {@link ConvexPolytope} bounding the visible region of globalspace, extended by a large enough border to ensure that it contains center of every ellipsoid that intersects the visible volume.
 * @param transform
 * @param timepoint
 * @return
 */
ConvexPolytope getVisiblePolytopeGlobal(final AffineTransform3D transform,final int timepoint){
  return getOverlappingPolytopeGlobal(0,width,0,height,transform,timepoint);
}","/** 
 * Get the   {@link ConvexPolytope} bounding the visible region of globalspace, extended by a large enough border to ensure that it contains the center of every ellipsoid that intersects the visible volume.
 * @param transform
 * @param timepoint
 * @return
 */
ConvexPolytope getVisiblePolytopeGlobal(final AffineTransform3D transform,final int timepoint){
  return getOverlappingPolytopeGlobal(0,width,0,height,transform,timepoint);
}",0.9954441913439636
90850,"public V getVertexAt(final int x,final int y,final double tolerance,final V ref){
  final AffineTransform3D transform=getRenderTransformCopy();
  final int currentTimepoint=renderTimepoint;
  final double[] lPos=new double[]{x,y,0};
  final double[] gPos=new double[3];
  final ScreenVertexMath svm=new ScreenVertexMath();
  transform.applyInverse(gPos,lPos);
  boolean found=false;
  index.readLock().lock();
  if (drawEllipsoidSliceProjection) {
    final ConvexPolytope cropPolytopeGlobal=getSurroundingPolytopeGlobal(x,y,transform,currentTimepoint);
    final ClipConvexPolytope<V> ccp=index.getSpatialIndex(currentTimepoint).getClipConvexPolytope();
    ccp.clip(cropPolytopeGlobal);
    final double[] xy=new double[]{x,y};
    final double[] vPos=new double[3];
    double minDist=Double.MAX_VALUE;
    for (    final V v : ccp.getInsideValues()) {
      svm.init(v,transform);
      if (svm.projectionContainsView(xy)) {
        found=true;
        v.localize(vPos);
        final double d=LinAlgHelpers.squareDistance(vPos,gPos);
        if (d < minDist) {
          minDist=d;
          ref.refTo(v);
        }
      }
    }
  }
  if (!found) {
    final NearestNeighborSearch<V> nns=index.getSpatialIndex(currentTimepoint).getNearestNeighborSearch();
    nns.search(RealPoint.wrap(gPos));
    final V v=nns.getSampler().get();
    if (v != null) {
      svm.init(v,transform);
      if (drawEllipsoidSliceIntersection) {
        if (svm.containsGlobal(gPos)) {
          found=true;
          ref.refTo(v);
        }
      }
      if (!found && drawPoints) {
        final double[] p=svm.getViewPos();
        final double dx=p[0] - x;
        final double dy=p[1] - y;
        final double dr=pointRadius + tolerance;
        if (dx * dx + dy * dy <= dr * dr) {
          found=true;
          ref.refTo(v);
        }
      }
    }
  }
  index.readLock().unlock();
  return found ? ref : null;
}","public V getVertexAt(final int x,final int y,final double tolerance,final V ref){
  final AffineTransform3D transform=getRenderTransformCopy();
  final int currentTimepoint=renderTimepoint;
  final double[] lPos=new double[]{x,y,0};
  final double[] gPos=new double[3];
  final ScreenVertexMath svm=new ScreenVertexMath();
  transform.applyInverse(gPos,lPos);
  boolean found=false;
  index.readLock().lock();
  if (drawEllipsoidSliceProjection) {
    final ConvexPolytope cropPolytopeGlobal=getSurroundingPolytopeGlobal(x,y,transform,currentTimepoint);
    final ClipConvexPolytope<V> ccp=index.getSpatialIndex(currentTimepoint).getClipConvexPolytope();
    ccp.clip(cropPolytopeGlobal);
    final double[] xy=new double[]{x,y};
    final double[] vPos=new double[3];
    double minDist=Double.MAX_VALUE;
    for (    final V v : ccp.getInsideValues()) {
      svm.init(v,transform);
      if (svm.projectionContainsView(xy)) {
        found=true;
        v.localize(vPos);
        final double d=LinAlgHelpers.squareDistance(vPos,gPos);
        if (d < minDist) {
          minDist=d;
          ref.refTo(v);
        }
      }
    }
  }
  if (!found && drawEllipsoidSliceIntersection) {
    final IncrementalNearestNeighborSearch<V> inns=index.getSpatialIndex(currentTimepoint).getIncrementalNearestNeighborSearch();
    final double maxSquDist=graph.getMaxBoundingSphereRadiusSquared(currentTimepoint);
    inns.search(RealPoint.wrap(gPos));
    while (inns.hasNext()) {
      final V v=inns.next();
      if (inns.getSquareDistance() > maxSquDist)       break;
      svm.init(v,transform);
      if (svm.containsGlobal(gPos)) {
        found=true;
        ref.refTo(v);
        break;
      }
    }
  }
  if (!found && drawPoints) {
    final NearestNeighborSearch<V> nns=index.getSpatialIndex(currentTimepoint).getNearestNeighborSearch();
    nns.search(RealPoint.wrap(gPos));
    final V v=nns.getSampler().get();
    if (v != null) {
      svm.init(v,transform);
      final double[] p=svm.getViewPos();
      final double dx=p[0] - x;
      final double dy=p[1] - y;
      final double dr=pointRadius + tolerance;
      if (dx * dx + dy * dy <= dr * dr) {
        found=true;
        ref.refTo(v);
      }
    }
  }
  index.readLock().unlock();
  return found ? ref : null;
}",0.7823389021479714
90851,"/** 
 * Get the   {@link ConvexPolytope} around the specified viewer coordinatethat is large enough border to ensure that it contains center of every ellipsoid containing the specified coordinate.
 * @param x position on the z=0 plane in viewer coordinates.
 * @param y position on the z=0 plane in viewer coordinates.
 * @param transform
 * @param timepoint
 * @return
 */
private ConvexPolytope getSurroundingPolytopeGlobal(final double x,final double y,final AffineTransform3D transform,final int timepoint){
  return getOverlappingPolytopeGlobal(x,x,y,y,transform,timepoint);
}","/** 
 * Get the   {@link ConvexPolytope} around the specified viewer coordinatethat is large enough to ensure that it contains the center of every ellipsoid containing the specified coordinate.
 * @param x position on the z=0 plane in viewer coordinates.
 * @param y position on the z=0 plane in viewer coordinates.
 * @param transform
 * @param timepoint
 * @return
 */
private ConvexPolytope getSurroundingPolytopeGlobal(final double x,final double y,final AffineTransform3D transform,final int timepoint){
  return getOverlappingPolytopeGlobal(x,x,y,y,transform,timepoint);
}",0.9456427955133736
90852,"@Override public double getDistance(){
  return wrappedNNS.getDistance();
}","@Override public double getDistance(){
  return wrappedINNS.getDistance();
}",0.9933774834437086
90853,"@Override public double getSquareDistance(){
  return wrappedNNS.getSquareDistance();
}","@Override public double getSquareDistance(){
  return wrappedINNS.getSquareDistance();
}",0.9942857142857144
90854,"@Override public void search(final RealLocalizable pos){
  wrappedNNS.search(pos);
}","@Override public void search(final RealLocalizable reference){
  wrappedINNS.search(reference);
}",0.861878453038674
90855,"@Override public OverlayVertexWrapper<V,E> get(){
  final V nnv=wrappedNNS.getSampler().get();
  if (nnv == null)   return null;
  final int id=graphWrapper.idmap.getVertexId(nnv);
  v.wv=graphWrapper.idmap.getVertex(id,v.ref);
  return v;
}","@Override public OverlayVertexWrapper<V,E> get(){
  final V nnv=wrappedINNS.get();
  if (nnv == null)   return null;
  final int id=graphWrapper.idmap.getVertexId(nnv);
  v.wv=graphWrapper.idmap.getVertex(id,v.ref);
  return v;
}",0.9702127659574468
90856,"@Override public NNS copy(){
  return new NNS(this);
}","@Override public INNS copy(){
  return new INNS(this);
}",0.9818181818181818
90857,"/** 
 * Imports the specified TrackMate file as a MaMuT   {@link Model}.
 * @param file the path to the TrackMate file.
 * @return a new model.
 * @throws JDOMException if an error happens while parsing the XML file.
 * @throws IOException if an IO error prevents the XML file to be parsed.
 */
public static Model importModel(final File file) throws JDOMException, IOException {
  final Model model=new Model();
  final ModelGraph graph=model.getGraph();
  final SAXBuilder sb=new SAXBuilder();
  final Document document=sb.build(file);
  final Element root=document.getRootElement();
  final Element modelEl=root.getChild(MODEL_TAG);
  if (null == modelEl) {
    return null;
  }
  final Element featureDeclarationEl=modelEl.getChild(FEATURE_DECLARATION_TAG);
  final Element spotFeatureDeclarationEl=featureDeclarationEl.getChild(SPOT_FEATURE_DECLARATION_TAG);
  final List<Element> spotFeatureEls=spotFeatureDeclarationEl.getChildren(FEATURE_TAG);
  final Map<String,DoubleFeature<Spot>> spotDoubleFeatureMap=new HashMap<>();
  final Map<String,IntFeature<Spot>> spotIntFeatureMap=new HashMap<>();
  for (  final Element featureEl : spotFeatureEls) {
    final String featureKey=featureEl.getAttributeValue(FEATURE_ATTRIBUTE_NAME);
    final boolean featureIsInt=Boolean.parseBoolean(featureEl.getAttributeValue(FEATURE_ISINT_ATTRIBUTE_NAME));
    if (featureIsInt) {
      final IntFeature<Spot> feature=new IntFeature<>(SPOT_FEATURE_PREFIX + featureKey,Integer.MIN_VALUE);
      spotIntFeatureMap.put(featureKey,feature);
    }
 else {
      final DoubleFeature<Spot> feature=new DoubleFeature<>(SPOT_FEATURE_PREFIX + featureKey,Double.NaN);
      spotDoubleFeatureMap.put(featureKey,feature);
    }
  }
  final Element edgeFeatureDeclarationEl=featureDeclarationEl.getChild(EDGE_FEATURE_DECLARATION_TAG);
  final List<Element> edgeFeatureEls=edgeFeatureDeclarationEl.getChildren(FEATURE_TAG);
  final Map<String,DoubleFeature<Link>> edgeDoubleFeatureMap=new HashMap<>();
  final Map<String,IntFeature<Link>> edgeIntFeatureMap=new HashMap<>();
  for (  final Element featureEl : edgeFeatureEls) {
    final String featureKey=featureEl.getAttributeValue(FEATURE_ATTRIBUTE_NAME);
    final boolean featureIsInt=Boolean.parseBoolean(featureEl.getAttributeValue(FEATURE_ISINT_ATTRIBUTE_NAME));
    if (featureIsInt) {
      final IntFeature<Link> feature=new IntFeature<>(EDGE_FEATURE_PREFIX + featureKey,Integer.MIN_VALUE);
      edgeIntFeatureMap.put(featureKey,feature);
    }
 else {
      final DoubleFeature<Link> feature=new DoubleFeature<>(EDGE_FEATURE_PREFIX + featureKey,Double.NaN);
      edgeDoubleFeatureMap.put(featureKey,feature);
    }
  }
  final Spot ref=graph.vertexRef();
  final Spot putRef=graph.vertexRef();
  final Spot sourceRef=graph.vertexRef();
  final Spot targetRef=graph.vertexRef();
  final Link edgeRef=graph.edgeRef();
  try {
    final double[] pos=new double[3];
    final IntRefMap<Spot> idToSpotIDmap=RefCollections.createIntRefMap(graph.vertices(),-1);
    final Element allSpotsEl=modelEl.getChild(SPOT_COLLECTION_TAG);
    final List<Element> allFramesEl=allSpotsEl.getChildren(SPOT_FRAME_COLLECTION_TAG);
    for (    final Element frameEl : allFramesEl) {
      final List<Element> frameSpotsEl=frameEl.getChildren(SPOT_ELEMENT_TAG);
      for (      final Element spotEl : frameSpotsEl) {
        final boolean visible=Integer.parseInt(spotEl.getAttributeValue(VISIBILITY_ATTRIBUTE_NAME)) != 0;
        if (!visible)         continue;
        pos[0]=Double.parseDouble(spotEl.getAttributeValue(X_ATTRIBUTE_NAME));
        pos[1]=Double.parseDouble(spotEl.getAttributeValue(Y_ATTRIBUTE_NAME));
        pos[2]=Double.parseDouble(spotEl.getAttributeValue(Z_ATTRIBUTE_NAME));
        final double radius=Double.parseDouble(spotEl.getAttributeValue(RADIUS_ATTRIBUTE_NAME));
        final int frame=Integer.parseInt(spotEl.getAttributeValue(FRAME_ATTRIBUTE_NAME));
        final int id=Integer.parseInt(spotEl.getAttributeValue(ID_ATTRIBUTE_NAME));
        final String label=spotEl.getAttributeValue(LABEL_ATTRIBUTE_NAME);
        final Spot spot=graph.addVertex(ref).init(frame,pos,radius);
        spot.setLabel(label);
        idToSpotIDmap.put(id,spot,putRef);
        for (        final String featureKey : spotDoubleFeatureMap.keySet()) {
          final String attributeValue=spotEl.getAttributeValue(featureKey);
          if (null != attributeValue) {
            final double val=Double.parseDouble(attributeValue);
            final DoubleFeature<Spot> feature=spotDoubleFeatureMap.get(featureKey);
            spot.feature(feature).set(val);
          }
        }
        for (        final String featureKey : spotIntFeatureMap.keySet()) {
          final String attributeValue=spotEl.getAttributeValue(featureKey);
          if (null != attributeValue) {
            final int val=Integer.parseInt(attributeValue);
            final IntFeature<Spot> feature=spotIntFeatureMap.get(featureKey);
            spot.feature(feature).set(val);
          }
        }
      }
    }
    final Element trackCollectionEl=modelEl.getChild(TRACK_COLLECTION_TAG);
    final List<Element> trakEls=trackCollectionEl.getChildren(TRACK_TAG);
    for (    final Element trackEl : trakEls) {
      final List<Element> edgeEls=trackEl.getChildren(EDGE_TAG);
      for (      final Element edgeEl : edgeEls) {
        final int sourceID=Integer.parseInt(edgeEl.getAttributeValue(EDGE_SOURCE_ATTRIBUTE_NAME));
        final Spot source=idToSpotIDmap.get(sourceID,sourceRef);
        final int targetID=Integer.parseInt(edgeEl.getAttributeValue(EDGE_TARGET_ATTRIBUTE_NAME));
        final Spot target=idToSpotIDmap.get(targetID,targetRef);
        final Link link=graph.addEdge(source,target,edgeRef).init();
        for (        final String featureKey : edgeDoubleFeatureMap.keySet()) {
          final String attributeValue=edgeEl.getAttributeValue(featureKey);
          if (null != attributeValue) {
            final double val=Double.parseDouble(attributeValue);
            final DoubleFeature<Link> feature=edgeDoubleFeatureMap.get(featureKey);
            link.feature(feature).set(val);
          }
        }
        for (        final String featureKey : edgeIntFeatureMap.keySet()) {
          final String attributeValue=edgeEl.getAttributeValue(featureKey);
          if (null != attributeValue) {
            final int val=Integer.parseInt(attributeValue);
            final IntFeature<Link> feature=edgeIntFeatureMap.get(featureKey);
            link.feature(feature).set(val);
          }
        }
      }
    }
    return model;
  }
  finally {
    graph.releaseRef(ref);
    graph.releaseRef(putRef);
    graph.releaseRef(sourceRef);
    graph.releaseRef(targetRef);
    graph.releaseRef(edgeRef);
  }
}","/** 
 * Imports the specified TrackMate file as a MaMuT   {@link Model}.
 * @param file the path to the TrackMate file.
 * @return a new model.
 * @throws JDOMException if an error happens while parsing the XML file.
 * @throws IOException if an IO error prevents the XML file to be parsed.
 */
public static TrackMateModel importModel(final File file) throws JDOMException, IOException {
  final Model model=new Model();
  final ModelGraph graph=model.getGraph();
  final SAXBuilder sb=new SAXBuilder();
  final Document document=sb.build(file);
  final Element root=document.getRootElement();
  final Element modelEl=root.getChild(MODEL_TAG);
  if (null == modelEl) {
    return null;
  }
  final Element featureDeclarationEl=modelEl.getChild(FEATURE_DECLARATION_TAG);
  final Element spotFeatureDeclarationEl=featureDeclarationEl.getChild(SPOT_FEATURE_DECLARATION_TAG);
  final List<Element> spotFeatureEls=spotFeatureDeclarationEl.getChildren(FEATURE_TAG);
  final Map<String,DoublePropertyMap<Spot>> spotDoubleFeatureMap=new HashMap<>();
  final Map<String,IntPropertyMap<Spot>> spotIntFeatureMap=new HashMap<>();
  for (  final Element featureEl : spotFeatureEls) {
    final String featureKey=featureEl.getAttributeValue(FEATURE_ATTRIBUTE_NAME);
    final boolean featureIsInt=Boolean.parseBoolean(featureEl.getAttributeValue(FEATURE_ISINT_ATTRIBUTE_NAME));
    if (featureIsInt) {
      final IntPropertyMap<Spot> feature=new IntPropertyMap<>(graph.vertices(),Integer.MIN_VALUE);
      spotIntFeatureMap.put(featureKey,feature);
    }
 else {
      final DoublePropertyMap<Spot> feature=new DoublePropertyMap<>(graph.vertices(),Double.NaN);
      spotDoubleFeatureMap.put(featureKey,feature);
    }
  }
  final Element edgeFeatureDeclarationEl=featureDeclarationEl.getChild(EDGE_FEATURE_DECLARATION_TAG);
  final List<Element> edgeFeatureEls=edgeFeatureDeclarationEl.getChildren(FEATURE_TAG);
  final Map<String,DoublePropertyMap<Link>> edgeDoubleFeatureMap=new HashMap<>();
  final Map<String,IntPropertyMap<Link>> edgeIntFeatureMap=new HashMap<>();
  for (  final Element featureEl : edgeFeatureEls) {
    final String featureKey=featureEl.getAttributeValue(FEATURE_ATTRIBUTE_NAME);
    final boolean featureIsInt=Boolean.parseBoolean(featureEl.getAttributeValue(FEATURE_ISINT_ATTRIBUTE_NAME));
    if (featureIsInt) {
      final IntPropertyMap<Link> feature=new IntPropertyMap<>(graph.edges(),Integer.MIN_VALUE);
      edgeIntFeatureMap.put(featureKey,feature);
    }
 else {
      final DoublePropertyMap<Link> feature=new DoublePropertyMap<>(graph.edges(),Double.NaN);
      edgeDoubleFeatureMap.put(featureKey,feature);
    }
  }
  final Spot ref=graph.vertexRef();
  final Spot putRef=graph.vertexRef();
  final Spot sourceRef=graph.vertexRef();
  final Spot targetRef=graph.vertexRef();
  final Link edgeRef=graph.edgeRef();
  try {
    final double[] pos=new double[3];
    final IntRefMap<Spot> idToSpotIDmap=RefCollections.createIntRefMap(graph.vertices(),-1);
    final Element allSpotsEl=modelEl.getChild(SPOT_COLLECTION_TAG);
    final List<Element> allFramesEl=allSpotsEl.getChildren(SPOT_FRAME_COLLECTION_TAG);
    for (    final Element frameEl : allFramesEl) {
      final List<Element> frameSpotsEl=frameEl.getChildren(SPOT_ELEMENT_TAG);
      for (      final Element spotEl : frameSpotsEl) {
        final boolean visible=Integer.parseInt(spotEl.getAttributeValue(VISIBILITY_ATTRIBUTE_NAME)) != 0;
        if (!visible)         continue;
        pos[0]=Double.parseDouble(spotEl.getAttributeValue(X_ATTRIBUTE_NAME));
        pos[1]=Double.parseDouble(spotEl.getAttributeValue(Y_ATTRIBUTE_NAME));
        pos[2]=Double.parseDouble(spotEl.getAttributeValue(Z_ATTRIBUTE_NAME));
        final double radius=Double.parseDouble(spotEl.getAttributeValue(RADIUS_ATTRIBUTE_NAME));
        final int frame=Integer.parseInt(spotEl.getAttributeValue(FRAME_ATTRIBUTE_NAME));
        final int id=Integer.parseInt(spotEl.getAttributeValue(ID_ATTRIBUTE_NAME));
        final String label=spotEl.getAttributeValue(LABEL_ATTRIBUTE_NAME);
        final Spot spot=graph.addVertex(ref).init(frame,pos,radius);
        spot.setLabel(label);
        idToSpotIDmap.put(id,spot,putRef);
        for (        final String featureKey : spotDoubleFeatureMap.keySet()) {
          final String attributeValue=spotEl.getAttributeValue(featureKey);
          if (null != attributeValue) {
            final double val=Double.parseDouble(attributeValue);
            final DoublePropertyMap<Spot> feature=spotDoubleFeatureMap.get(featureKey);
            feature.set(spot,val);
          }
        }
        for (        final String featureKey : spotIntFeatureMap.keySet()) {
          final String attributeValue=spotEl.getAttributeValue(featureKey);
          if (null != attributeValue) {
            final int val=Integer.parseInt(attributeValue);
            final IntPropertyMap<Spot> feature=spotIntFeatureMap.get(featureKey);
            feature.set(spot,val);
          }
        }
      }
    }
    final Element trackCollectionEl=modelEl.getChild(TRACK_COLLECTION_TAG);
    final List<Element> trakEls=trackCollectionEl.getChildren(TRACK_TAG);
    for (    final Element trackEl : trakEls) {
      final List<Element> edgeEls=trackEl.getChildren(EDGE_TAG);
      for (      final Element edgeEl : edgeEls) {
        final int sourceID=Integer.parseInt(edgeEl.getAttributeValue(EDGE_SOURCE_ATTRIBUTE_NAME));
        final Spot source=idToSpotIDmap.get(sourceID,sourceRef);
        final int targetID=Integer.parseInt(edgeEl.getAttributeValue(EDGE_TARGET_ATTRIBUTE_NAME));
        final Spot target=idToSpotIDmap.get(targetID,targetRef);
        final Link link=graph.addEdge(source,target,edgeRef).init();
        for (        final String featureKey : edgeDoubleFeatureMap.keySet()) {
          final String attributeValue=edgeEl.getAttributeValue(featureKey);
          if (null != attributeValue) {
            final double val=Double.parseDouble(attributeValue);
            final DoublePropertyMap<Link> feature=edgeDoubleFeatureMap.get(featureKey);
            feature.set(link,val);
          }
        }
        for (        final String featureKey : edgeIntFeatureMap.keySet()) {
          final String attributeValue=edgeEl.getAttributeValue(featureKey);
          if (null != attributeValue) {
            final int val=Integer.parseInt(attributeValue);
            final IntPropertyMap<Link> feature=edgeIntFeatureMap.get(featureKey);
            feature.set(link,val);
          }
        }
      }
    }
    return new TrackMateModel(model,spotDoubleFeatureMap,spotIntFeatureMap,edgeDoubleFeatureMap,edgeIntFeatureMap);
  }
  finally {
    graph.releaseRef(ref);
    graph.releaseRef(putRef);
    graph.releaseRef(sourceRef);
    graph.releaseRef(targetRef);
    graph.releaseRef(edgeRef);
  }
}",0.9457010240919472
90858,"public static void compute(final Model model){
  final ListenableGraph<Spot,Link> graph=model.getGraph();
  final Spot tmp1=graph.vertexRef();
  final Spot tmp2=graph.vertexRef();
  final double[] s=new double[3];
  final double[] t=new double[3];
  for (  final Link link : graph.edges()) {
    link.getSource(tmp1).localize(s);
    link.getTarget(tmp2).localize(t);
    double dr2=0.;
    for (int d=0; d < 3; d++) {
      final double dx=s[d] - t[d];
      dr2=dx * dx;
    }
    link.feature(DISP).set(Math.sqrt(dr2));
  }
  final RefSet<Spot> roots=RefCollections.createRefSet(graph.vertices());
  for (  final Spot spot : graph.vertices()) {
    if (spot.incomingEdges().isEmpty())     roots.add(spot);
  }
  final DepthFirstSearch<Spot,Link> linkCollector=new DepthFirstSearch<>(graph,SearchDirection.UNDIRECTED);
  for (  final Spot root : roots) {
    final DoubleType dr=new DoubleType(0);
    final DoubleType tmp=new DoubleType(0);
    final LongType n=new LongType(0);
    linkCollector.setTraversalListener(new SearchListener<Spot,Link,DepthFirstSearch<Spot,Link>>(){
      @Override public void processVertexLate(      final Spot vertex,      final DepthFirstSearch<Spot,Link> search){
      }
      @Override public void processVertexEarly(      final Spot vertex,      final DepthFirstSearch<Spot,Link> search){
      }
      @Override public void processEdge(      final Link edge,      final Spot from,      final Spot to,      final DepthFirstSearch<Spot,Link> search){
        tmp.set(edge.feature(DISP).getDouble());
        dr.add(tmp);
        n.inc();
      }
    }
);
    linkCollector.start(root);
    if (linkCollector.wasAborted())     System.out.println(""String_Node_Str"" + root.getLabel() + ""String_Node_Str"");
 else     System.out.println(String.format(Locale.US,""String_Node_Str"",root.getLabel(),(dr.get() / n.get()),n.get()));
  }
}","public static void compute(final Model model){
  final ListenableGraph<Spot,Link> graph=model.getGraph();
  final DoublePropertyMap<Link> displacement=new DoublePropertyMap<>(graph.edges(),Double.NaN);
  final Spot tmp1=graph.vertexRef();
  final Spot tmp2=graph.vertexRef();
  final double[] s=new double[3];
  final double[] t=new double[3];
  for (  final Link link : graph.edges()) {
    link.getSource(tmp1).localize(s);
    link.getTarget(tmp2).localize(t);
    double dr2=0.;
    for (int d=0; d < 3; d++) {
      final double dx=s[d] - t[d];
      dr2=dx * dx;
    }
    displacement.set(link,Math.sqrt(dr2));
  }
  final RefSet<Spot> roots=RefCollections.createRefSet(graph.vertices());
  for (  final Spot spot : graph.vertices()) {
    if (spot.incomingEdges().isEmpty())     roots.add(spot);
  }
  final DepthFirstSearch<Spot,Link> linkCollector=new DepthFirstSearch<>(graph,SearchDirection.UNDIRECTED);
  for (  final Spot root : roots) {
    final DoubleType dr=new DoubleType(0);
    final DoubleType tmp=new DoubleType(0);
    final LongType n=new LongType(0);
    linkCollector.setTraversalListener(new SearchListener<Spot,Link,DepthFirstSearch<Spot,Link>>(){
      @Override public void processVertexLate(      final Spot vertex,      final DepthFirstSearch<Spot,Link> search){
      }
      @Override public void processVertexEarly(      final Spot vertex,      final DepthFirstSearch<Spot,Link> search){
      }
      @Override public void processEdge(      final Link edge,      final Spot from,      final Spot to,      final DepthFirstSearch<Spot,Link> search){
        tmp.set(displacement.getDouble(edge));
        dr.add(tmp);
        n.inc();
      }
    }
);
    linkCollector.start(root);
    if (linkCollector.wasAborted())     System.out.println(""String_Node_Str"" + root.getLabel() + ""String_Node_Str"");
 else     System.out.println(String.format(Locale.US,""String_Node_Str"",root.getLabel(),(dr.get() / n.get()),n.get()));
  }
}",0.9511111111111112
90859,"@Override public void processEdge(final Link edge,final Spot from,final Spot to,final DepthFirstSearch<Spot,Link> search){
  tmp.set(edge.feature(DISP).getDouble());
  dr.add(tmp);
  n.inc();
}","@Override public void processEdge(final Link edge,final Spot from,final Spot to,final DepthFirstSearch<Spot,Link> search){
  tmp.set(displacement.getDouble(edge));
  dr.add(tmp);
  n.inc();
}",0.9270833333333334
90860,"@Override public void releaseRef(final OverlayEdgeWrapper<V,E> e){
  releaseRef(e);
}","@Override public void releaseRef(final OverlayEdgeWrapper<V,E> e){
  OverlayGraphWrapper.this.releaseRef(e);
}",0.8717948717948718
90861,"@Override public void notifySet(final Spot spot){
  spot.modelGraph.notifyBeforeVertexCovarianceChange(spot);
}","@Override public void notifySet(final Spot spot){
  spot.modelGraph.notifyRadiusChanged(spot);
}",0.8792270531400966
90862,"static AttributeUndoSerializer<Spot> createCovarianceAttributeSerializer(){
  return new PoolObjectAttributeSerializer<Spot>(COVARIANCE_OFFSET,6 * DOUBLE_SIZE + DOUBLE_SIZE){
    @Override public void notifySet(    final Spot spot){
      spot.modelGraph.notifyBeforeVertexCovarianceChange(spot);
    }
  }
;
}","static AttributeUndoSerializer<Spot> createCovarianceAttributeSerializer(){
  return new PoolObjectAttributeSerializer<Spot>(COVARIANCE_OFFSET,6 * DOUBLE_SIZE + DOUBLE_SIZE){
    @Override public void notifySet(    final Spot spot){
      spot.modelGraph.notifyRadiusChanged(spot);
    }
  }
;
}",0.9520661157024792
90863,"/** 
 * Create Undo/Redo actions and install them in the specified  {@link InputActionBindings}.
 * @param inputActionBindings {@link InputMap} and {@link ActionMap} are installed here.
 * @param model Actions are targeted at this  {@link Model}s   {@code undo()} and{@code redo()} methods.
 * @param keyProperties user-defined key-bindings.
 */
public static void installActionBindings(final InputActionBindings inputActionBindings,final Model model,final KeyStrokeAdder.Factory keyConfig){
  final UndoActions actions=new UndoActions(keyConfig);
  actions.runnableAction(model::undo,UNDO,UNDO_KEYS);
  actions.runnableAction(model::redo,REDO,REDO_KEYS);
  actions.install(inputActionBindings,""String_Node_Str"");
}","/** 
 * Create Undo/Redo actions and install them in the specified  {@link InputActionBindings}.
 * @param inputActionBindings {@link InputMap} and {@link ActionMap} are installed here.
 * @param model Actions are targeted at this  {@link Model}s   {@code undo()} and{@code redo()} methods.
 */
public static void installActionBindings(final InputActionBindings inputActionBindings,final Model model,final KeyStrokeAdder.Factory keyConfig){
  final UndoActions actions=new UndoActions(keyConfig);
  actions.runnableAction(model::undo,UNDO,UNDO_KEYS);
  actions.runnableAction(model::redo,REDO,REDO_KEYS);
  actions.install(inputActionBindings,""String_Node_Str"");
}",0.9630166787527192
90864,"/** 
 * Create TrackScheme actions and install them in the specified  {@link InputActionBindings}.
 * @param inputActionBindings {@link InputMap} and {@link ActionMap} are installed here.
 * @param keyProperties user-defined key-bindings.
 */
public static void installActionBindings(final InputActionBindings inputActionBindings,final TrackSchemeFrame frame,final KeyStrokeAdder.Factory keyConfig){
  final TrackSchemeActions actions=new TrackSchemeActions(keyConfig);
  actions.runnableAction(frame.getEditFocusVertex(),EDIT_FOCUS,EDIT_FOCUS_KEYS);
  actions.runnableAction(() -> frame.setSettingsPanelVisible(!frame.isSettingsPanelVisible()),TOGGLE_SETTINGS_PANEL,TOGGLE_SETTINGS_PANEL_KEYS);
  actions.install(inputActionBindings,""String_Node_Str"");
}","/** 
 * Create TrackScheme actions and install them in the specified  {@link InputActionBindings}.
 * @param inputActionBindings {@link InputMap} and {@link ActionMap} are installed here.
 */
public static void installActionBindings(final InputActionBindings inputActionBindings,final TrackSchemeFrame frame,final KeyStrokeAdder.Factory keyConfig){
  final TrackSchemeActions actions=new TrackSchemeActions(keyConfig);
  actions.runnableAction(frame.getEditFocusVertex(),EDIT_FOCUS,EDIT_FOCUS_KEYS);
  actions.runnableAction(() -> frame.setSettingsPanelVisible(!frame.isSettingsPanelVisible()),TOGGLE_SETTINGS_PANEL,TOGGLE_SETTINGS_PANEL_KEYS);
  actions.install(inputActionBindings,""String_Node_Str"");
}",0.9650445510623716
90865,"public Element toXml(final MamutProject project,final File xmlFileDirectory){
  final Element root=new Element(MAMUTPROJECT_TAG);
  root.setAttribute(SPIMDATA_VERSION_ATTRIBUTE_NAME,SPIMDATA_VERSION_ATTRIBUTE_CURRENT);
  root.addContent(XmlHelpers.pathElement(BASEPATH_TAG,project.getBasePath(),xmlFileDirectory));
  root.addContent(XmlHelpers.pathElement(SPIMDATAFILE_TAG,project.getDatasetXmlFile(),project.getBasePath()));
  root.addContent(XmlHelpers.pathElement(RAWMODELFILE_TAG,project.getRawModelFile(),project.getBasePath()));
  return root;
}","public Element toXml(final MamutProject project,final File xmlFileDirectory){
  final Element root=new Element(MAMUTPROJECT_TAG);
  root.setAttribute(MAMUTPROJECT_VERSION_ATTRIBUTE_NAME,MAMUTPROJECT_VERSION_ATTRIBUTE_CURRENT);
  root.addContent(XmlHelpers.pathElement(BASEPATH_TAG,project.getBasePath(),xmlFileDirectory));
  root.addContent(XmlHelpers.pathElement(SPIMDATAFILE_TAG,project.getDatasetXmlFile(),project.getBasePath()));
  root.addContent(XmlHelpers.pathElement(RAWMODELFILE_TAG,project.getRawModelFile(),project.getBasePath()));
  return root;
}",0.963963963963964
90866,"@Override protected V targetOf(E edge,V ref){
  return edge.getSource(ref);
}","@Override protected V targetOf(final E edge,final V ref){
  return edge.getSource(ref);
}",0.927710843373494
90867,"@Override protected V targetOf(E edge,V ref){
  return edge.getSource(ref);
}","@Override protected V targetOf(final E edge,final V ref){
  return edge.getSource(ref);
}",0.927710843373494
90868,"/** 
 * Clear resources associated with thie UndoableEdit. Currently, this is only implemented in   {@link Other}, where it is used to remove non-ref edits from   {@link UndoableEditList#nonRefEdits}.
 */
public default void clear(){
}","/** 
 * Clear resources associated with thie UndoableEdit. Currently, this is only implemented in   {@code UndoableEditList.Other}, where it is used to remove non-ref edits from   {@link UndoableEditList#nonRefEdits}.
 */
public default void clear(){
}",0.944558521560575
90869,"/** 
 * Notify that bytes have been written (  {@link #setBytes(Object,byte[])}) to   {@code obj}. <p> Note: Currently nothing is ever done in between   {@code setBytes()} and{@code notifySet()}, so maybe this will be removed later and notifications directly linked to   {@codes setBytes}. For now, we keep it explicit.
 */
public void notifySet(final O obj);","/** 
 * Notify that bytes have been written (  {@link #setBytes(Object,byte[])}) to   {@code obj}. <p> Note: Currently nothing is ever done in between   {@code setBytes()} and{@code notifySet()}, so maybe this will be removed later and notifications directly linked to   {@code setBytes()}. For now, we keep it explicit.
 */
public void notifySet(final O obj);",0.995827538247566
90870,"@Override public void drag(final int x,final int y){
  renderer.getGlobalPosition(x,y,pos);
  LinAlgHelpers.add(pos,start,pos);
  vertex.setPosition(pos);
}","@Override public void drag(final int x,final int y){
  if (moving) {
    renderer.getGlobalPosition(x,y,pos);
    LinAlgHelpers.add(pos,start,pos);
    vertex.setPosition(pos);
  }
}",0.9230769230769232
90871,"@Override public OverlayEdgeWrapper<V,E> next(){
  edge.we=idmap.getEdge(idmap.getEdgeId(wrappedIterator.next()),edge.we);
  return edge;
}","@Override public OverlayEdgeWrapper<V,E> next(){
  edge.we=idmap.getEdge(idmap.getEdgeId(wrappedIterator.next()),edge.ref);
  return edge;
}",0.989247311827957
90872,"OverlayEdgeWrapper(final OverlayGraphWrapper<V,E> wrapper){
  this.wrapper=wrapper;
  we=wrapper.wrappedGraph.edgeRef();
  overlayProperties=wrapper.overlayProperties;
}","OverlayEdgeWrapper(final OverlayGraphWrapper<V,E> wrapper){
  this.wrapper=wrapper;
  ref=wrapper.wrappedGraph.edgeRef();
  overlayProperties=wrapper.overlayProperties;
}",0.991150442477876
90873,"@Override public OverlayVertexWrapper<V,E> getTarget(final OverlayVertexWrapper<V,E> vertex){
  vertex.wv=we.getTarget(vertex.wv);
  return vertex;
}","@Override public OverlayVertexWrapper<V,E> getTarget(final OverlayVertexWrapper<V,E> vertex){
  vertex.wv=we.getTarget(vertex.ref);
  return vertex;
}",0.9832775919732442
90874,"@Override public OverlayVertexWrapper<V,E> getSource(final OverlayVertexWrapper<V,E> vertex){
  vertex.wv=we.getSource(vertex.wv);
  return vertex;
}","@Override public OverlayVertexWrapper<V,E> getSource(final OverlayVertexWrapper<V,E> vertex){
  vertex.wv=we.getSource(vertex.ref);
  return vertex;
}",0.9832775919732442
90875,"@Override public OverlayEdgeWrapper<V,E> refTo(final OverlayEdgeWrapper<V,E> obj){
  we=wrapper.idmap.getEdge(obj.getInternalPoolIndex(),we);
  return this;
}","@Override public OverlayEdgeWrapper<V,E> refTo(final OverlayEdgeWrapper<V,E> obj){
  we=wrapper.idmap.getEdge(obj.getInternalPoolIndex(),ref);
  return this;
}",0.9905362776025236
90876,"@Override public OverlayVertexWrapper<V,E> getFocusedVertex(final OverlayVertexWrapper<V,E> ref){
  final V h=wrappedFocusModel.getFocusedVertex(ref.wv);
  if (h == null)   return null;
 else {
    ref.wv=idmap.getVertex(idmap.getVertexId(h),ref.wv);
    return ref;
  }
}","@Override public OverlayVertexWrapper<V,E> getFocusedVertex(final OverlayVertexWrapper<V,E> ref){
  ref.wv=wrappedFocusModel.getFocusedVertex(ref.ref);
  return ref.orNull();
}",0.7098214285714286
90877,"@Override public void focusVertex(final OverlayVertexWrapper<V,E> vertex){
  if (vertex == null)   wrappedFocusModel.focusVertex(null);
 else   wrappedFocusModel.focusVertex(vertex.wv);
}","@Override public void focusVertex(final OverlayVertexWrapper<V,E> vertex){
  wrappedFocusModel.focusVertex(OverlayVertexWrapper.wrappedOrNull(vertex));
}",0.7647058823529411
90878,"@Override public OverlayEdgeWrapper<V,E> getObject(final int index,final OverlayEdgeWrapper<V,E> e){
  e.we=idmap.getEdge(index,e.we);
  return e;
}","@Override public OverlayEdgeWrapper<V,E> getObject(final int index,final OverlayEdgeWrapper<V,E> e){
  e.we=idmap.getEdge(index,e.ref);
  return e;
}",0.98989898989899
90879,"@Override public OverlayEdgeWrapper<V,E> getEdge(final OverlayVertexWrapper<V,E> source,final OverlayVertexWrapper<V,E> target,final OverlayEdgeWrapper<V,E> edge){
  final E we=wrappedGraph.getEdge(source.wv,target.wv,edge.we);
  return we == null ? null : edge;
}","@Override public OverlayEdgeWrapper<V,E> getEdge(final OverlayVertexWrapper<V,E> source,final OverlayVertexWrapper<V,E> target,final OverlayEdgeWrapper<V,E> edge){
  edge.we=wrappedGraph.getEdge(source.wv,target.wv,edge.ref);
  return edge.orNull();
}",0.8932038834951457
90880,"@Override public OverlayVertexWrapper<V,E> addVertex(final int timepoint,final double[] position,final double[][] covariance,final OverlayVertexWrapper<V,E> ref){
  ref.wv=overlayProperties.addVertex(timepoint,position,covariance,ref.wv);
  return ref;
}","@Override public OverlayVertexWrapper<V,E> addVertex(final int timepoint,final double[] position,final double[][] covariance,final OverlayVertexWrapper<V,E> ref){
  ref.wv=overlayProperties.addVertex(timepoint,position,covariance,ref.ref);
  return ref;
}",0.9901768172888016
90881,"@Override public OverlayEdgeWrapper<V,E> addEdge(final OverlayVertexWrapper<V,E> source,final OverlayVertexWrapper<V,E> target,final OverlayEdgeWrapper<V,E> ref){
  ref.we=overlayProperties.addEdge(source.wv,target.wv,ref.we);
  return ref;
}","@Override public OverlayEdgeWrapper<V,E> addEdge(final OverlayVertexWrapper<V,E> source,final OverlayVertexWrapper<V,E> target,final OverlayEdgeWrapper<V,E> ref){
  ref.we=overlayProperties.addEdge(source.wv,target.wv,ref.ref);
  return ref;
}",0.9896907216494846
90882,"@Override public OverlayEdgeWrapper<V,E> getHighlightedEdge(final OverlayEdgeWrapper<V,E> ref){
  final E h=wrappedHighlightModel.getHighlightedEdge(ref.we);
  if (h == null)   return null;
 else {
    ref.we=idmap.getEdge(idmap.getEdgeId(h),ref.we);
    return ref;
  }
}","@Override public OverlayEdgeWrapper<V,E> getHighlightedEdge(final OverlayEdgeWrapper<V,E> ref){
  ref.we=wrappedHighlightModel.getHighlightedEdge(ref.ref);
  return ref.orNull();
}",0.7256637168141593
90883,"@Override public OverlayVertexWrapper<V,E> getHighlightedVertex(final OverlayVertexWrapper<V,E> ref){
  final V h=wrappedHighlightModel.getHighlightedVertex(ref.wv);
  if (h == null)   return null;
 else {
    ref.wv=idmap.getVertex(idmap.getVertexId(h),ref.wv);
    return ref;
  }
}","@Override public OverlayVertexWrapper<V,E> getHighlightedVertex(final OverlayVertexWrapper<V,E> ref){
  ref.wv=wrappedHighlightModel.getHighlightedVertex(ref.ref);
  return ref.orNull();
}",0.7245762711864406
90884,"@Override public void highlightEdge(final OverlayEdgeWrapper<V,E> edge){
  if (edge == null)   wrappedHighlightModel.highlightEdge(null);
 else   wrappedHighlightModel.highlightEdge(edge.we);
}","@Override public void highlightEdge(final OverlayEdgeWrapper<V,E> edge){
  wrappedHighlightModel.highlightEdge(OverlayEdgeWrapper.wrappedOrNull(edge));
}",0.7630057803468208
90885,"@Override public void highlightVertex(final OverlayVertexWrapper<V,E> vertex){
  if (vertex == null)   wrappedHighlightModel.highlightVertex(null);
 else   wrappedHighlightModel.highlightVertex(vertex.wv);
}","@Override public void highlightVertex(final OverlayVertexWrapper<V,E> vertex){
  wrappedHighlightModel.highlightVertex(OverlayVertexWrapper.wrappedOrNull(vertex));
}",0.7634408602150538
90886,"@Override public OverlayVertexWrapper<V,E> next(){
  vertex.wv=idmap.getVertex(idmap.getVertexId(wrappedIterator.next()),vertex.wv);
  return vertex;
}","@Override public OverlayVertexWrapper<V,E> next(){
  vertex.wv=idmap.getVertex(idmap.getVertexId(wrappedIterator.next()),vertex.ref);
  return vertex;
}",0.9834983498349836
90887,"@Override public Iterator<OverlayEdgeWrapper<V,E>> safe_iterator(){
  return new OverlayEdgeIteratorWrapper<V,E>(wrapper,wrapper.edgeRef(),edges.iterator());
}","@Override public Iterator<OverlayEdgeWrapper<V,E>> safe_iterator(){
  return new OverlayEdgeIteratorWrapper<>(wrapper,wrapper.edgeRef(),wrappedEdges.iterator());
}",0.968944099378882
90888,"@Override public Iterator<OverlayEdgeWrapper<V,E>> iterator(){
  if (iterator == null)   iterator=new OverlayEdgeIteratorWrapper<V,E>(wrapper,wrapper.edgeRef(),edges.iterator());
 else   iterator.wrap(edges.iterator());
  return iterator;
}","@Override public Iterator<OverlayEdgeWrapper<V,E>> iterator(){
  if (iterator == null)   iterator=new OverlayEdgeIteratorWrapper<>(wrapper,wrapper.edgeRef(),wrappedEdges.iterator());
 else   iterator.wrap(wrappedEdges.iterator());
  return iterator;
}",0.8757637474541752
90889,"@Override public Edges<OverlayEdgeWrapper<V,E>> incomingEdges(){
  return incomingEdges;
}","@Override public Edges<OverlayEdgeWrapper<V,E>> incomingEdges(){
  incomingEdges.wrap(wv.incomingEdges());
  return incomingEdges;
}",0.8108108108108109
90890,"@Override public OverlayEdgeWrapper<V,E> get(final int i,final OverlayEdgeWrapper<V,E> edge){
  edge.we=edges.get(i,edge.we);
  return edge;
}","@Override public OverlayEdgeWrapper<V,E> get(final int i,final OverlayEdgeWrapper<V,E> edge){
  edge.we=wrappedEdges.get(i,edge.ref);
  return edge;
}",0.9657534246575342
90891,"@Override public OverlayVertexWrapper<V,E> refTo(final OverlayVertexWrapper<V,E> obj){
  wv=wrapper.idmap.getVertex(obj.getInternalPoolIndex(),wv);
  return this;
}","@Override public OverlayVertexWrapper<V,E> refTo(final OverlayVertexWrapper<V,E> obj){
  wv=wrapper.idmap.getVertex(obj.getInternalPoolIndex(),ref);
  return this;
}",0.9848024316109424
90892,"@Override public Edges<OverlayEdgeWrapper<V,E>> edges(){
  return edges;
}","@Override public Edges<OverlayEdgeWrapper<V,E>> edges(){
  edges.wrap(wv.edges());
  return edges;
}",0.8505747126436781
90893,"@Override public boolean isEmpty(){
  return edges.isEmpty();
}","@Override public boolean isEmpty(){
  return wrappedEdges.isEmpty();
}",0.9473684210526316
90894,"@Override public Edges<OverlayEdgeWrapper<V,E>> outgoingEdges(){
  return outgoingEdges;
}","@Override public Edges<OverlayEdgeWrapper<V,E>> outgoingEdges(){
  outgoingEdges.wrap(wv.outgoingEdges());
  return outgoingEdges;
}",0.8108108108108109
90895,"@Override public int size(){
  return edges.size();
}","@Override public int size(){
  return wrappedEdges.size();
}",0.9380530973451328
90896,"OverlayVertexWrapper(final OverlayGraphWrapper<V,E> wrapper){
  this.wrapper=wrapper;
  wv=wrapper.wrappedGraph.vertexRef();
  incomingEdges=new EdgesWrapper(wv.incomingEdges());
  outgoingEdges=new EdgesWrapper(wv.outgoingEdges());
  edges=new EdgesWrapper(wv.edges());
  overlayProperties=wrapper.overlayProperties;
}","OverlayVertexWrapper(final OverlayGraphWrapper<V,E> wrapper){
  this.wrapper=wrapper;
  ref=wrapper.wrappedGraph.vertexRef();
  incomingEdges=new EdgesWrapper();
  outgoingEdges=new EdgesWrapper();
  edges=new EdgesWrapper();
  overlayProperties=wrapper.overlayProperties;
}",0.8195615514333895
90897,"@Override public void vertexAdded(final Spot v){
  writeLock.lock();
  try {
    final int t=v.getTimepoint();
    Stats stats=timepointToStats.get(t);
    if (stats == null) {
      stats=new Stats(graph.vertexRef());
      timepointToStats.put(t,stats);
    }
    stats.add(v);
  }
  finally {
    writeLock.lock();
  }
}","@Override public void vertexAdded(final Spot v){
  writeLock.lock();
  try {
    final int t=v.getTimepoint();
    Stats stats=timepointToStats.get(t);
    if (stats == null) {
      stats=new Stats(graph.vertexRef());
      timepointToStats.put(t,stats);
    }
    stats.add(v);
  }
  finally {
    writeLock.unlock();
  }
}",0.9969135802469136
90898,"public TrackSchemePanel(final TrackSchemeGraph<?,?> graph,final TrackSchemeHighlight highlight,final TrackSchemeFocus focus,final TrackSchemeSelection selection,final TrackSchemeNavigation navigation,final TrackSchemeOptions optional){
  super(new BorderLayout(),false);
  this.graph=graph;
  this.focus=focus;
  final Values options=optional.values;
  graph.addGraphChangeListener(this);
  navigation.addNavigationListener(this);
  final int w=options.getWidth();
  final int h=options.getHeight();
  display=new InteractiveDisplayCanvasComponent<ScreenTransform>(w,h,options.getTransformEventHandlerFactory());
  display.addTransformListener(this);
  highlight.addHighlightListener(this);
  focus.addFocusListener(this);
  selection.addSelectionListener(this);
  style=TrackSchemeStyle.defaultStyle();
  graphOverlay=new DefaultTrackSchemeOverlay(graph,highlight,focus,optional,style);
  display.addOverlayRenderer(graphOverlay);
  display.addOverlayRenderer(new OverlayRenderer(){
    @Override public void setCanvasSize(    final int width,    final int height){
    }
    @Override public void drawOverlays(    final Graphics g){
      checkAnimate();
    }
  }
);
  screenTransform=new ScreenTransform();
  layout=new LineageTreeLayout(graph);
  contextLayout=new ContextLayout(graph,layout);
  final TransformEventHandler<ScreenTransform> tevl=display.getTransformEventHandler();
  if (tevl instanceof LayoutListener) {
    final LayoutListener ll=(LayoutListener)tevl;
    layout.addLayoutListener(ll);
  }
  entityAnimator=new ScreenEntityAnimator();
  painterThread=new PainterThread(this);
  flags=new Flags();
  final MouseHighlightHandler highlightHandler=new MouseHighlightHandler(graphOverlay,highlight,graph);
  display.addMouseMotionListener(highlightHandler);
  display.addMouseListener(highlightHandler);
  display.addTransformListener(highlightHandler);
  navigator=new TrackSchemeNavigator(graph,layout,focus,navigation,selection);
  display.addTransformListener(navigator);
  selectionBehaviours=new SelectionBehaviours(display,graph,layout,graphOverlay,focus,navigation,selection);
  display.addTransformListener(selectionBehaviours);
  offsetHeaders=new OffsetHeaders();
  offsetHeaders.addOffsetHeadersListener((InertialScreenTransformEventHandler)display.getTransformEventHandler());
  offsetHeaders.addOffsetHeadersListener(graphOverlay);
  offsetHeaders.addOffsetHeadersListener(selectionBehaviours);
  offsetHeaders.addOffsetHeadersListener(highlightHandler);
  offsetHeaders.setHeaderVisibleX(true,25);
  offsetHeaders.setHeaderVisibleY(true,20);
  xScrollBar=new JScrollBar(JScrollBar.HORIZONTAL);
  yScrollBar=new JScrollBar(JScrollBar.VERTICAL);
  xScrollBar.addAdjustmentListener(new AdjustmentListener(){
    @Override public void adjustmentValueChanged(    final AdjustmentEvent e){
      if (ignoreScrollBarChanges)       return;
      final double s=xScrollBar.getValue() / xScrollScale;
synchronized (screenTransform) {
        screenTransform.shiftLayoutX(s - screenTransform.getMinX());
        display.getTransformEventHandler().setTransform(screenTransform);
      }
      flags.setTransformChanged();
      painterThread.requestRepaint();
    }
  }
);
  yScrollBar.addAdjustmentListener(new AdjustmentListener(){
    @Override public void adjustmentValueChanged(    final AdjustmentEvent e){
      if (ignoreScrollBarChanges)       return;
      final double s=yScrollBar.getValue() / yScrollScale;
synchronized (screenTransform) {
        screenTransform.shiftLayoutY(s - screenTransform.getMinY());
        display.getTransformEventHandler().setTransform(screenTransform);
      }
      flags.setTransformChanged();
      painterThread.requestRepaint();
    }
  }
);
  add(display,BorderLayout.CENTER);
  add(yScrollBar,BorderLayout.EAST);
  final JPanel xScrollPanel=new JPanel(new BorderLayout());
  xScrollPanel.add(xScrollBar,BorderLayout.CENTER);
  final int space=(Integer)UIManager.getDefaults().get(""String_Node_Str"");
  xScrollPanel.add(Box.createRigidArea(new Dimension(space,0)),BorderLayout.EAST);
  add(xScrollPanel,BorderLayout.SOUTH);
  setNavigationEtiquette(options.getNavigationEtiquette());
  painterThread.start();
}","public TrackSchemePanel(final TrackSchemeGraph<?,?> graph,final TrackSchemeHighlight highlight,final TrackSchemeFocus focus,final TrackSchemeSelection selection,final TrackSchemeNavigation navigation,final TrackSchemeOptions optional){
  super(new BorderLayout(),false);
  this.graph=graph;
  this.focus=focus;
  final Values options=optional.values;
  graph.addGraphChangeListener(this);
  navigation.addNavigationListener(this);
  final int w=options.getWidth();
  final int h=options.getHeight();
  display=new InteractiveDisplayCanvasComponent<>(w,h,options.getTransformEventHandlerFactory());
  display.addTransformListener(this);
  highlight.addHighlightListener(this);
  focus.addFocusListener(this);
  selection.addSelectionListener(this);
  style=TrackSchemeStyle.defaultStyle().copy(""String_Node_Str"");
  graphOverlay=new DefaultTrackSchemeOverlay(graph,highlight,focus,optional,style);
  display.addOverlayRenderer(graphOverlay);
  display.addOverlayRenderer(new OverlayRenderer(){
    @Override public void setCanvasSize(    final int width,    final int height){
    }
    @Override public void drawOverlays(    final Graphics g){
      checkAnimate();
    }
  }
);
  screenTransform=new ScreenTransform();
  layout=new LineageTreeLayout(graph);
  contextLayout=new ContextLayout(graph,layout);
  final TransformEventHandler<ScreenTransform> tevl=display.getTransformEventHandler();
  if (tevl instanceof LayoutListener) {
    final LayoutListener ll=(LayoutListener)tevl;
    layout.addLayoutListener(ll);
  }
  entityAnimator=new ScreenEntityAnimator();
  painterThread=new PainterThread(this);
  flags=new Flags();
  final MouseHighlightHandler highlightHandler=new MouseHighlightHandler(graphOverlay,highlight,graph);
  display.addMouseMotionListener(highlightHandler);
  display.addMouseListener(highlightHandler);
  display.addTransformListener(highlightHandler);
  navigator=new TrackSchemeNavigator(graph,layout,focus,navigation,selection);
  display.addTransformListener(navigator);
  selectionBehaviours=new SelectionBehaviours(display,graph,layout,graphOverlay,focus,navigation,selection);
  display.addTransformListener(selectionBehaviours);
  offsetHeaders=new OffsetHeaders();
  offsetHeaders.addOffsetHeadersListener((InertialScreenTransformEventHandler)display.getTransformEventHandler());
  offsetHeaders.addOffsetHeadersListener(graphOverlay);
  offsetHeaders.addOffsetHeadersListener(selectionBehaviours);
  offsetHeaders.addOffsetHeadersListener(highlightHandler);
  offsetHeaders.setHeaderVisibleX(true,25);
  offsetHeaders.setHeaderVisibleY(true,20);
  xScrollBar=new JScrollBar(JScrollBar.HORIZONTAL);
  yScrollBar=new JScrollBar(JScrollBar.VERTICAL);
  xScrollBar.addAdjustmentListener(new AdjustmentListener(){
    @Override public void adjustmentValueChanged(    final AdjustmentEvent e){
      if (ignoreScrollBarChanges)       return;
      final double s=xScrollBar.getValue() / xScrollScale;
synchronized (screenTransform) {
        screenTransform.shiftLayoutX(s - screenTransform.getMinX());
        display.getTransformEventHandler().setTransform(screenTransform);
      }
      flags.setTransformChanged();
      painterThread.requestRepaint();
    }
  }
);
  yScrollBar.addAdjustmentListener(new AdjustmentListener(){
    @Override public void adjustmentValueChanged(    final AdjustmentEvent e){
      if (ignoreScrollBarChanges)       return;
      final double s=yScrollBar.getValue() / yScrollScale;
synchronized (screenTransform) {
        screenTransform.shiftLayoutY(s - screenTransform.getMinY());
        display.getTransformEventHandler().setTransform(screenTransform);
      }
      flags.setTransformChanged();
      painterThread.requestRepaint();
    }
  }
);
  add(display,BorderLayout.CENTER);
  add(yScrollBar,BorderLayout.EAST);
  final JPanel xScrollPanel=new JPanel(new BorderLayout());
  xScrollPanel.add(xScrollBar,BorderLayout.CENTER);
  final int space=(Integer)UIManager.getDefaults().get(""String_Node_Str"");
  xScrollPanel.add(Box.createRigidArea(new Dimension(space,0)),BorderLayout.EAST);
  add(xScrollPanel,BorderLayout.SOUTH);
  setNavigationEtiquette(options.getNavigationEtiquette());
  painterThread.start();
}",0.9953421712647796
90899,"public ModelSpotUndoRecorder(final AbstractModelGraph<?,?,?,Spot,Link,?> graph,final GraphFeatures<Spot,Link> graphFeatures,final GraphIdBimap<Spot,Link> idmap,final UndoSerializer<Spot,Link> serializer){
  super(graph,graphFeatures,new ModelSpotUndoableEditList(defaultCapacity,graph,graphFeatures,serializer,new UndoIdBimap<>(idmap.vertexIdBimap()),new UndoIdBimap<>(idmap.edgeIdBimap())));
  graph.addAbstractSpotListener(this);
}","public ModelSpotUndoRecorder(final AbstractModelGraph<?,?,?,Spot,Link,?> graph,final Features<Spot> vertexFeatures,final Features<Link> edgeFeatures,final GraphIdBimap<Spot,Link> idmap,final UndoSerializer<Spot,Link> serializer){
  super(graph,vertexFeatures,edgeFeatures,new ModelSpotUndoableEditList(defaultCapacity,graph,vertexFeatures,edgeFeatures,serializer,new UndoIdBimap<>(idmap.vertexIdBimap()),new UndoIdBimap<>(idmap.edgeIdBimap())));
  graph.addAbstractSpotListener(this);
}",0.8683351468988031
90900,"@Override public SetVertexCovariance createInstance(final UndoableEditRef<Spot,Link> ref){
  return new SetVertexCovariance(ref,typeIndex());
}","@Override public SetVertexCovariance createInstance(final UndoableEditRef ref){
  return new SetVertexCovariance(ref,typeIndex());
}",0.96
90901,"public ModelSpotUndoableEditList(final int initialCapacity,final ListenableGraph<Spot,Link> graph,final GraphFeatures<Spot,Link> graphFeatures,final UndoSerializer<Spot,Link> serializer,final UndoIdBimap<Spot> vertexUndoIdBimap,final UndoIdBimap<Link> edgeUndoIdBimap){
  super(initialCapacity,graph,graphFeatures,serializer,vertexUndoIdBimap,edgeUndoIdBimap);
}","public ModelSpotUndoableEditList(final int initialCapacity,final ListenableGraph<Spot,Link> graph,final Features<Spot> vertexFeatures,final Features<Link> edgeFeatures,final UndoSerializer<Spot,Link> serializer,final UndoIdBimap<Spot> vertexUndoIdBimap,final UndoIdBimap<Link> edgeUndoIdBimap){
  super(initialCapacity,graph,vertexFeatures,edgeFeatures,serializer,vertexUndoIdBimap,edgeUndoIdBimap);
}",0.872870249017038
90902,"public void recordSetCovariance(final Spot vertex){
  final UndoableEditRef<Spot,Link> ref=createRef();
  boolean createNewEdit=true;
  if (nextEditIndex > 0) {
    final UndoableEditRef<Spot,Link> edit=get(nextEditIndex - 1,ref);
    createNewEdit=!setVertexPosition.isInstance(edit) || edit.isUndoPoint();
  }
  if (createNewEdit)   create(ref).getEdit(setVertexCovariance).init(vertex);
  releaseRef(ref);
}","public void recordSetCovariance(final Spot vertex){
  final UndoableEditRef ref=createRef();
  boolean createNewEdit=true;
  if (nextEditIndex > 0) {
    final UndoableEditRef edit=get(nextEditIndex - 1,ref);
    createNewEdit=!setVertexPosition.isInstance(edit) || edit.isUndoPoint();
  }
  if (createNewEdit)   create(ref).getEdit(setVertexCovariance).init(vertex);
  releaseRef(ref);
}",0.7343358395989975
90903,"SetVertexCovariance(final UndoableEditRef<Spot,Link> ref,final int typeIndex){
  super(ref,typeIndex);
  mat=new double[numDimensions][numDimensions];
  tmp=new double[numDimensions][numDimensions];
}","SetVertexCovariance(final UndoableEditRef ref,final int typeIndex){
  super(ref,typeIndex);
  mat=new double[numDimensions][numDimensions];
  tmp=new double[numDimensions][numDimensions];
}",0.9717223650385604
90904,"public void recordSetCovariance(final Spot vertex){
  final UndoableEditRef ref=createRef();
  boolean createNewEdit=true;
  if (nextEditIndex > 0) {
    final UndoableEditRef edit=get(nextEditIndex - 1,ref);
    createNewEdit=!setVertexPosition.isInstance(edit) || edit.isUndoPoint();
  }
  if (createNewEdit)   create(ref).getEdit(setVertexCovariance).init(vertex);
  releaseRef(ref);
}","public void recordSetCovariance(final Spot vertex){
  final UndoableEditRef ref=createRef();
  boolean createNewEdit=true;
  if (nextEditIndex > 0) {
    final UndoableEditRef edit=get(nextEditIndex - 1,ref);
    createNewEdit=!setVertexCovariance.isInstance(edit) || edit.isUndoPoint();
  }
  if (createNewEdit)   create(ref).getEdit(setVertexCovariance).init(vertex);
  releaseRef(ref);
}",0.9768637532133676
90905,"public <F extends FeatureValue<?>,M>F feature(final EdgeFeature<M,E,F> feature);","public <F extends FeatureValue<?>,M>F feature(final Feature<M,E,F> feature);",0.9743589743589745
90906,"public IntRefMap<O> createIntRefMap(final int noEntryKey,final int initialCapacity);","public static <O>IntRefMap<O> createIntRefMap(final RefCollection<O> collection,final int noEntryKey,final int initialCapacity){
  if (collection instanceof MapCreator)   return ((MapCreator<O>)collection).createIntRefMap(noEntryKey,initialCapacity);
 else   return new IntRefMapWrapper<O>(noEntryKey,initialCapacity);
}",0.4158415841584158
90907,"public RefRefMap<O,O> createRefRefMap(final int initialCapacity);","public static <O>RefRefMap<O,O> createRefRefMap(final RefCollection<O> collection,final int initialCapacity){
  if (collection instanceof MapCreator)   return ((MapCreator<O>)collection).createRefRefMap(initialCapacity);
 else   return wrap(new HashMap<O,O>(initialCapacity));
}",0.3790087463556851
90908,public RefSet<O> createRefSet(final int initialCapacity);,"public static <O>RefSet<O> createRefSet(final RefCollection<O> collection,final int initialCapacity){
  if (collection instanceof SetCreator)   return ((SetCreator<O>)collection).createRefSet(initialCapacity);
 else   return wrap(new HashSet<O>(initialCapacity));
}",0.2111801242236025
90909,"public RefIntMap<O> createRefIntMap(final int noEntryValue,final int initialCapacity);","public static <O>RefIntMap<O> createRefIntMap(final RefCollection<O> collection,final int noEntryValue,final int initialCapacity){
  if (collection instanceof MapCreator)   return ((MapCreator<O>)collection).createRefIntMap(noEntryValue,initialCapacity);
 else   return new RefIntMapWrapper<O>(noEntryValue,initialCapacity);
}",0.4174757281553398
90910,"public <T>RefObjectMap<O,T> createRefObjectMap(final int initialCapacity);","public static <O,T>RefObjectMap<O,T> createRefObjectMap(final RefCollection<O> collection,final int initialCapacity){
  if (collection instanceof MapCreator)   return ((MapCreator<O>)collection).createRefObjectMap(initialCapacity);
 else   return wrap(new HashMap<O,T>(initialCapacity));
}",0.4022038567493113
90911,public RefList<O> createRefList(final int initialCapacity);,"public static <O>RefList<O> createRefList(final RefCollection<O> collection,final int initialCapacity){
  if (collection instanceof ListCreator)   return ((ListCreator<O>)collection).createRefList(initialCapacity);
 else   return wrap(new ArrayList<O>(initialCapacity));
}",0.1450151057401812
90912,public RefDeque<O> createRefDeque(final int initialCapacity);,"public static <O>RefDeque<O> createRefDeque(final RefCollection<O> collection,final int initialCapacity){
  if (collection instanceof DequeCreator)   return ((DequeCreator<O>)collection).createRefDeque(initialCapacity);
 else   return wrap(new ArrayDeque<O>(initialCapacity));
}",0.1415929203539823
90913,"public RefDoubleMap<O> createRefDoubleMap(final double noEntryValue,final int initialCapacity);","public static <O>RefDoubleMap<O> createRefDoubleMap(final RefCollection<O> collection,final double noEntryValue,final int initialCapacity){
  if (collection instanceof MapCreator)   return ((MapCreator<O>)collection).createRefDoubleMap(noEntryValue,initialCapacity);
 else   return new RefDoubleMapWrapper<O>(noEntryValue,initialCapacity);
}",0.4357798165137614
90914,public RefStack<O> createRefStack(final int initialCapacity);,"public static <O>RefStack<O> createRefStack(final RefCollection<O> collection,final int initialCapacity){
  if (collection instanceof StackCreator)   return ((StackCreator<O>)collection).createRefStack(initialCapacity);
 else   return wrapAsStack(new ArrayDeque<O>(initialCapacity));
}",0.1387283236994219
90915,"@Override public void focusVertex(final int id){
  if (id < 0)   focus.focusVertex(null);
 else {
    final V v=graph.vertexRef();
    focus.focusVertex(idmap.getVertex(id,v));
    graph.releaseRef(v);
  }
}","@Override public void focusVertex(final int id){
  if (id < 0)   focus.focusVertex(null);
 else {
    final V ref=graph.vertexRef();
    focus.focusVertex(idmap.getVertex(id,ref));
    graph.releaseRef(ref);
  }
}",0.9714285714285714
90916,"@Override public int getFocusedVertexId(){
  final V v=graph.vertexRef();
  final V h=focus.getFocusedVertex(v);
  final int id=(h == null) ? -1 : idmap.getVertexId(v);
  graph.releaseRef(v);
  return id;
}","@Override public int getFocusedVertexId(){
  final V ref=graph.vertexRef();
  final V focused=focus.getFocusedVertex(ref);
  final int id=(focused == null) ? -1 : idmap.getVertexId(focused);
  graph.releaseRef(ref);
  return id;
}",0.7981651376146789
90917,"@Override public Iterator<E> iterator(){
  final Iterator<E> itin=incoming.iterator();
  final Iterator<E> itout=incoming.iterator();
  return new Iterator<E>(){
    E next=fetch();
    E fetch(){
      if (itin.hasNext())       return itin.next();
 else       if (itout.hasNext())       return itout.next();
 else       return null;
    }
    @Override public boolean hasNext(){
      return next != null;
    }
    @Override public E next(){
      final E edge=next;
      next=fetch();
      return edge;
    }
  }
;
}","@Override public Iterator<E> iterator(){
  final Iterator<E> itin=incoming.iterator();
  final Iterator<E> itout=outgoing.iterator();
  return new Iterator<E>(){
    E next=fetch();
    E fetch(){
      if (itin.hasNext())       return itin.next();
 else       if (itout.hasNext())       return itout.next();
 else       return null;
    }
    @Override public boolean hasNext(){
      return next != null;
    }
    @Override public E next(){
      final E edge=next;
      next=fetch();
      return edge;
    }
  }
;
}",0.9904030710172744
90918,"@Test public void testLoopStdObjects(){
  final GraphTestBundle<ObjectVertex<Integer>,ObjectEdge<Integer>> bundle=GraphsForTests.loopStdObjects();
  final ObjectVertex<Integer> first=bundle.vertices.get(0);
  final BreadthFirstSearch<ObjectVertex<Integer>,ObjectEdge<Integer>> bfs=new BreadthFirstSearch<ObjectVertex<Integer>,ObjectEdge<Integer>>(bundle.graph,false);
  final List<ObjectVertex<Integer>> expectedVertices=new ArrayList<ObjectVertex<Integer>>(7);
  expectedVertices.add(bundle.vertices.get(0));
  expectedVertices.add(bundle.vertices.get(1));
  expectedVertices.add(bundle.vertices.get(6));
  expectedVertices.add(bundle.vertices.get(2));
  expectedVertices.add(bundle.vertices.get(5));
  expectedVertices.add(bundle.vertices.get(3));
  expectedVertices.add(bundle.vertices.get(4));
  final List<ObjectEdge<Integer>> expectedEdges=new ArrayList<ObjectEdge<Integer>>(7);
  expectedEdges.add(bundle.edges.get(0));
  expectedEdges.add(bundle.edges.get(6));
  expectedEdges.add(bundle.edges.get(1));
  expectedEdges.add(bundle.edges.get(5));
  expectedEdges.add(bundle.edges.get(2));
  expectedEdges.add(bundle.edges.get(4));
  expectedEdges.add(bundle.edges.get(3));
  final List<EdgeClass> edgeClass=Arrays.asList(new EdgeClass[]{TREE,TREE,TREE,TREE,TREE,TREE,CROSS});
  final TraversalTester<ObjectVertex<Integer>,ObjectEdge<Integer>,BreadthFirstSearch<ObjectVertex<Integer>,ObjectEdge<Integer>>> traversalTester=new TraversalTester<ObjectVertex<Integer>,ObjectEdge<Integer>,BreadthFirstSearch<ObjectVertex<Integer>,ObjectEdge<Integer>>>(expectedVertices.iterator(),expectedVertices.iterator(),expectedEdges.iterator(),edgeClass.iterator());
  bfs.setTraversalListener(traversalTester);
  bfs.start(first);
  traversalTester.searchDone();
}","@Test public void testLoopStdObjects(){
  final GraphTestBundle<ObjectVertex<Integer>,ObjectEdge<Integer>> bundle=GraphsForTests.loopStdObjects();
  final ObjectVertex<Integer> first=bundle.vertices.get(0);
  final BreadthFirstSearch<ObjectVertex<Integer>,ObjectEdge<Integer>> bfs=new BreadthFirstSearch<ObjectVertex<Integer>,ObjectEdge<Integer>>(bundle.graph,false);
  final List<ObjectVertex<Integer>> expectedVertices=new ArrayList<ObjectVertex<Integer>>(7);
  expectedVertices.add(bundle.vertices.get(0));
  expectedVertices.add(bundle.vertices.get(6));
  expectedVertices.add(bundle.vertices.get(1));
  expectedVertices.add(bundle.vertices.get(5));
  expectedVertices.add(bundle.vertices.get(2));
  expectedVertices.add(bundle.vertices.get(4));
  expectedVertices.add(bundle.vertices.get(3));
  final List<ObjectEdge<Integer>> expectedEdges=new ArrayList<ObjectEdge<Integer>>(7);
  expectedEdges.add(bundle.edges.get(6));
  expectedEdges.add(bundle.edges.get(0));
  expectedEdges.add(bundle.edges.get(5));
  expectedEdges.add(bundle.edges.get(1));
  expectedEdges.add(bundle.edges.get(4));
  expectedEdges.add(bundle.edges.get(2));
  expectedEdges.add(bundle.edges.get(3));
  final List<EdgeClass> edgeClass=Arrays.asList(new EdgeClass[]{TREE,TREE,TREE,TREE,TREE,TREE,CROSS});
  final TraversalTester<ObjectVertex<Integer>,ObjectEdge<Integer>,BreadthFirstSearch<ObjectVertex<Integer>,ObjectEdge<Integer>>> traversalTester=new TraversalTester<ObjectVertex<Integer>,ObjectEdge<Integer>,BreadthFirstSearch<ObjectVertex<Integer>,ObjectEdge<Integer>>>(expectedVertices.iterator(),expectedVertices.iterator(),expectedEdges.iterator(),edgeClass.iterator());
  bfs.setTraversalListener(traversalTester);
  bfs.start(first);
  traversalTester.searchDone();
}",0.9464082098061574
90919,"@Test public void testLoopStdObjects(){
  final GraphTestBundle<ObjectVertex<Integer>,ObjectEdge<Integer>> bundle=GraphsForTests.loopStdObjects();
  final ObjectVertex<Integer> first=bundle.vertices.get(0);
  final DepthFirstSearch<ObjectVertex<Integer>,ObjectEdge<Integer>> dfs=new DepthFirstSearch<ObjectVertex<Integer>,ObjectEdge<Integer>>(bundle.graph,false);
  final List<EdgeClass> edgeClass=Arrays.asList(new EdgeClass[]{TREE,TREE,TREE,TREE,TREE,TREE,BACK});
  final List<ObjectVertex<Integer>> processedVertices=new ArrayList<ObjectVertex<Integer>>(7);
  processedVertices.add(bundle.vertices.get(6));
  processedVertices.add(bundle.vertices.get(5));
  processedVertices.add(bundle.vertices.get(4));
  processedVertices.add(bundle.vertices.get(3));
  processedVertices.add(bundle.vertices.get(2));
  processedVertices.add(bundle.vertices.get(1));
  processedVertices.add(bundle.vertices.get(0));
  final TraversalTester<ObjectVertex<Integer>,ObjectEdge<Integer>,DepthFirstSearch<ObjectVertex<Integer>,ObjectEdge<Integer>>> traversalTester=new TraversalTester<ObjectVertex<Integer>,ObjectEdge<Integer>,DepthFirstSearch<ObjectVertex<Integer>,ObjectEdge<Integer>>>(bundle.vertices.iterator(),processedVertices.iterator(),bundle.edges.iterator(),edgeClass.iterator());
  dfs.setTraversalListener(traversalTester);
  dfs.start(first);
  traversalTester.searchDone();
}","@SuppressWarnings(""String_Node_Str"") @Test public void testLoopStdObjects(){
  final GraphTestBundle<ObjectVertex<Integer>,ObjectEdge<Integer>> bundle=GraphsForTests.loopStdObjects();
  final ObjectVertex<Integer> first=bundle.vertices.get(0);
  final DepthFirstSearch<ObjectVertex<Integer>,ObjectEdge<Integer>> dfs=new DepthFirstSearch<ObjectVertex<Integer>,ObjectEdge<Integer>>(bundle.graph,false);
  final List<EdgeClass> edgeClass=Arrays.asList(new EdgeClass[]{TREE,TREE,TREE,TREE,TREE,TREE,BACK});
  final List<ObjectVertex<Integer>> discoveredVertices=Arrays.asList(new ObjectVertex[]{bundle.vertices.get(0),bundle.vertices.get(6),bundle.vertices.get(5),bundle.vertices.get(4),bundle.vertices.get(3),bundle.vertices.get(2),bundle.vertices.get(1)});
  final List<ObjectVertex<Integer>> processedVertices=Arrays.asList(new ObjectVertex[]{bundle.vertices.get(1),bundle.vertices.get(2),bundle.vertices.get(3),bundle.vertices.get(4),bundle.vertices.get(5),bundle.vertices.get(6),bundle.vertices.get(0)});
  final List<ObjectEdge<Integer>> expectedEdges=Arrays.asList(new ObjectEdge[]{bundle.edges.get(6),bundle.edges.get(5),bundle.edges.get(4),bundle.edges.get(3),bundle.edges.get(2),bundle.edges.get(1),bundle.edges.get(0)});
  final TraversalTester<ObjectVertex<Integer>,ObjectEdge<Integer>,DepthFirstSearch<ObjectVertex<Integer>,ObjectEdge<Integer>>> traversalTester=new TraversalTester<ObjectVertex<Integer>,ObjectEdge<Integer>,DepthFirstSearch<ObjectVertex<Integer>,ObjectEdge<Integer>>>(discoveredVertices.iterator(),processedVertices.iterator(),expectedEdges.iterator(),edgeClass.iterator());
  dfs.setTraversalListener(traversalTester);
  dfs.start(first);
  traversalTester.searchDone();
}",0.6703583061889251
90920,"@Override protected Map<V,T> createFeatureMap(final RefCollection<V> pool){
  return CollectionUtils.createRefObjectMap(pool);
}","@Override protected Map<O,T> createFeatureMap(final RefCollection<O> pool){
  return CollectionUtils.createRefObjectMap(pool);
}",0.984375
90921,"@Override public FeatureValue<T> createFeatureValue(final V object,final Features<V> features){
  return new ObjFeatureValue<>(features.getFeatureMap(this),object,new NotifyValueChange<>(features,this,object));
}","@Override public FeatureValue<T> createFeatureValue(final O object,final Features<O> features){
  return new ObjFeatureValue<>(features.getFeatureMap(this),object,new NotifyValueChange<>(features,this,object));
}",0.8820754716981132
90922,"@Override protected FeatureCleanup<V> createFeatureCleanup(final Map<V,T> featureMap){
  return new FeatureCleanup<V>(){
    @Override public void delete(    final V vertex){
      featureMap.remove(vertex);
    }
  }
;
}","@Override protected FeatureCleanup<O> createFeatureCleanup(final Map<O,T> featureMap){
  return new FeatureCleanup<O>(){
    @Override public void delete(    final O object){
      featureMap.remove(object);
    }
  }
;
}",0.9230769230769232
90923,"@Override public ObjUndoFeatureMap<V,T> createUndoFeatureMap(final Map<V,T> featureMap){
  return new ObjUndoFeatureMap<>(featureMap);
}","@Override public ObjUndoFeatureMap<O,T> createUndoFeatureMap(final Map<O,T> featureMap){
  return new ObjUndoFeatureMap<>(featureMap);
}",0.9852941176470588
90924,"/** 
 * Create a new feature.
 * @param name the unique name of the feature.
 * @throws DuplicateKeyException if a  {@link VertexFeature} with the same {@code name} alreadyexists.
 */
public ObjFeature(final String name) throws DuplicateKeyException {
  super(name);
}","/** 
 * Create a new feature.
 * @param name the unique name of the feature.
 * @throws DuplicateKeyException if a  {@link Feature} with the same {@code name} alreadyexists.
 */
public ObjFeature(final String name) throws DuplicateKeyException {
  super(name);
}",0.9886792452830188
90925,"@Override public void delete(final V vertex){
  featureMap.remove(vertex);
}","@Override public void delete(final O object){
  featureMap.remove(object);
}",0.881578947368421
90926,"/** 
 * For internal use only. <p> This is only public because it needs to be accessed from  {@link RawFeatureIO}. <p> Returns the feature map for the given   {@code feature}. If the feature map doesn't exist yet, it is created (  {@link Feature#createFeatureMap(RefCollection)}) and  {@link CreateFeatureMapListener}s are notified.
 * @return feature map for the given {@code feature}.
 */
@SuppressWarnings(""String_Node_Str"") public <M>M getFeatureMap(final Feature<M,O,?> feature){
  M fmap=(M)featureMaps.get(feature);
  if (fmap == null) {
    fmap=feature.createFeatureMap(collection);
    featureMaps.put(feature,fmap);
    featureCleanups.add(feature.createFeatureCleanup(fmap));
    for (    final CreateFeatureMapListener<O> l : createFeatureMapListeners)     l.createFeatureMap(feature,fmap);
  }
  return fmap;
}","/** 
 * For internal use only. <p> This is only public because it needs to be accessed from  {@link RawFeatureIO}. <p> Returns the feature map for the given   {@code feature}. If the feature map doesn't exist yet, it is created (  {@link Feature#createFeatureMap(RefCollection)}) and  {@link CreateFeatureMapListener}s are notified.
 * @return feature map for the given {@code feature}.
 */
@SuppressWarnings(""String_Node_Str"") public <M>M getFeatureMap(final Feature<M,O,?> feature){
  M fmap=(M)featureMaps.get(feature);
  if (fmap == null) {
    fmap=feature.createFeatureMap(pool);
    featureMaps.put(feature,fmap);
    featureCleanups.add(feature.createFeatureCleanup(fmap));
    for (    final CreateFeatureMapListener<O> l : createFeatureMapListeners)     l.createFeatureMap(feature,fmap);
  }
  return fmap;
}",0.9914738124238732
90927,"public Features(final RefCollection<O> collection){
  this.collection=collection;
  featureMaps=new UniqueHashcodeArrayMap<>();
  featureCleanups=new ArrayList<>();
  createFeatureMapListeners=new ArrayList<>();
  featureChangeListeners=new ArrayList<>();
}","public Features(final RefCollection<O> pool){
  this.pool=pool;
  featureMaps=new UniqueHashcodeArrayMap<>();
  featureCleanups=new ArrayList<>();
  createFeatureMapListeners=new ArrayList<>();
  featureChangeListeners=new ArrayList<>();
}",0.9112903225806452
90928,"private static void readFeatureValue(final Model model,final int[] storage,final IntVertexFeature<Spot> feature){
  int index=0;
  for (  final Spot spot : model.getGraph().vertices()) {
    storage[index++]=spot.feature(feature).getInt();
  }
}","private static void readFeatureValue(final Model model,final int[] storage,final IntFeature<Spot> feature){
  int index=0;
  for (  final Spot spot : model.getGraph().vertices()) {
    storage[index++]=spot.feature(feature).getInt();
  }
}",0.987603305785124
90929,"public static void main(final String[] args){
  final int N_RUNS=100;
  System.out.println(""String_Node_Str"");
  final long s=System.currentTimeMillis();
  final Model model=new CreateLargeModelExample().run(6,18,8);
  final int size=model.getGraph().vertices().size();
  final long e=System.currentTimeMillis();
  System.out.println(String.format(""String_Node_Str"",size,((double)e - s) / 1000.));
  final int[] storage=new int[size];
  final IntVertexFeature<Spot> POSITIVE_NUMBER=new IntVertexFeature<>(""String_Node_Str"",-1);
  System.out.println();
  final long s1=System.currentTimeMillis();
  BenchmarkHelper.benchmarkAndPrint(N_RUNS,false,() -> putFeatureValue(model,POSITIVE_NUMBER));
  final long e1=System.currentTimeMillis();
  System.out.println(String.format(""String_Node_Str"",size,((double)e1 - s1) / N_RUNS));
  System.out.println();
  final long s2=System.currentTimeMillis();
  BenchmarkHelper.benchmarkAndPrint(N_RUNS,false,() -> readGraphValue(model,storage));
  final long e2=System.currentTimeMillis();
  System.out.println(String.format(""String_Node_Str"",size,((double)e2 - s2) / N_RUNS));
  System.out.println();
  final long s3=System.currentTimeMillis();
  BenchmarkHelper.benchmarkAndPrint(N_RUNS,false,() -> readFeatureValue(model,storage,POSITIVE_NUMBER));
  final long e3=System.currentTimeMillis();
  System.out.println(String.format(""String_Node_Str"",size,((double)e3 - s3) / N_RUNS));
}","public static void main(final String[] args){
  final int N_RUNS=100;
  System.out.println(""String_Node_Str"");
  final long s=System.currentTimeMillis();
  final Model model=new CreateLargeModelExample().run(6,18,8);
  final int size=model.getGraph().vertices().size();
  final long e=System.currentTimeMillis();
  System.out.println(String.format(""String_Node_Str"",size,((double)e - s) / 1000.));
  final int[] storage=new int[size];
  final IntFeature<Spot> POSITIVE_NUMBER=new IntFeature<>(""String_Node_Str"",-1);
  System.out.println();
  final long s1=System.currentTimeMillis();
  BenchmarkHelper.benchmarkAndPrint(N_RUNS,false,() -> putFeatureValue(model,POSITIVE_NUMBER));
  final long e1=System.currentTimeMillis();
  System.out.println(String.format(""String_Node_Str"",size,((double)e1 - s1) / N_RUNS));
  System.out.println();
  final long s2=System.currentTimeMillis();
  BenchmarkHelper.benchmarkAndPrint(N_RUNS,false,() -> readGraphValue(model,storage));
  final long e2=System.currentTimeMillis();
  System.out.println(String.format(""String_Node_Str"",size,((double)e2 - s2) / N_RUNS));
  System.out.println();
  final long s3=System.currentTimeMillis();
  BenchmarkHelper.benchmarkAndPrint(N_RUNS,false,() -> readFeatureValue(model,storage,POSITIVE_NUMBER));
  final long e3=System.currentTimeMillis();
  System.out.println(String.format(""String_Node_Str"",size,((double)e3 - s3) / N_RUNS));
}",0.9957476966690292
90930,"private static void putFeatureValue(final Model model,final IntVertexFeature<Spot> feature){
  for (  final Spot spot : model.getGraph().vertices()) {
    spot.feature(feature).set(spot.getTimepoint());
  }
}","private static void putFeatureValue(final Model model,final IntFeature<Spot> feature){
  for (  final Spot spot : model.getGraph().vertices()) {
    spot.feature(feature).set(spot.getTimepoint());
  }
}",0.9853658536585366
90931,"@Override public int getHighlightedVertexId(){
  final V v=graph.vertexRef();
  final V h=highlight.getHighlightedVertex(v);
  final int id=(h == null) ? -1 : idmap.getVertexId(v);
  graph.releaseRef(v);
  return id;
}","@Override public int getHighlightedVertexId(){
  final V v=graph.vertexRef();
  final V h=highlight.getHighlightedVertex(v);
  final int id=(h == null) ? -1 : idmap.getVertexId(h);
  graph.releaseRef(v);
  return id;
}",0.9954128440366972
90932,"@Override public int getHighlightedEdgeId(){
  final E e=graph.edgeRef();
  final E h=highlight.getHighlightedEdge(e);
  final int id=(h == null) ? -1 : idmap.getEdgeId(e);
  graph.releaseRef(e);
  return id;
}","@Override public int getHighlightedEdgeId(){
  final E e=graph.edgeRef();
  final E h=highlight.getHighlightedEdge(e);
  final int id=(h == null) ? -1 : idmap.getEdgeId(h);
  graph.releaseRef(e);
  return id;
}",0.9952380952380953
90933,"/** 
 * Partition a sublist of KDTreeNodes such that the k-th smallest value is at position   {@code k}, elements before the k-th are smaller or equal and elements after the k-th are larger or equal. Elements are compared by their coordinate in the specified dimension.s Note, that is is assumed that the   {@link KDTreeNode}s are stored with consecutive indices in the pool.
 * @param i index of first element of the sublist
 * @param j index of last element of the sublist
 * @param k index for k-th smallest value. i <= k <= j.
 * @param compare_d dimension by which to compare.
 * @param pivot temporary  {@link KDTreeNode} reference.
 * @param ti temporary  {@link KDTreeNode} reference.
 * @param tj temporary  {@link KDTreeNode} reference.
 */
private void kthElement(int i,int j,final int k,final int compare_d,final KDTreeNode<O,T> pivot,final KDTreeNode<O,T> ti,final KDTreeNode<O,T> tj){
  while (true) {
    final int pivotpos=partitionSubList(i,j,compare_d,pivot,ti,tj);
    if (pivotpos > k) {
      j=pivotpos - 1;
    }
 else     if (pivotpos < k) {
      i=pivotpos + 1;
    }
 else     break;
  }
}","/** 
 * Partition a sublist of KDTreeNodes such that the k-th smallest value is at position   {@code k}, elements before the k-th are smaller or equal and elements after the k-th are larger or equal. Elements are compared by their coordinate in the specified dimension.s Note, that is is assumed that the   {@link KDTreeNode}s are stored with consecutive indices in the pool.
 * @param i index of first element of the sublist
 * @param j index of last element of the sublist
 * @param k index for k-th smallest value. i &lt;= k &lt;= j.
 * @param compare_d dimension by which to compare.
 * @param pivot temporary  {@link KDTreeNode} reference.
 * @param ti temporary  {@link KDTreeNode} reference.
 * @param tj temporary  {@link KDTreeNode} reference.
 */
private void kthElement(int i,int j,final int k,final int compare_d,final KDTreeNode<O,T> pivot,final KDTreeNode<O,T> ti,final KDTreeNode<O,T> tj){
  while (true) {
    final int pivotpos=partitionSubList(i,j,compare_d,pivot,ti,tj);
    if (pivotpos > k) {
      j=pivotpos - 1;
    }
 else     if (pivotpos < k) {
      i=pivotpos + 1;
    }
 else     break;
  }
}",0.9955317247542448
90934,"/** 
 * Return signed distance of timepoint t to t0, truncated at cutoff and scaled by 1/cutoff. t=t0 has d=0. t<=t0-cutoff has d=-1. t=>t0+cutoff has d=1.
 */
private static double timeDistance(final double t,final double t0,final double cutoff){
  final double d=t - t0;
  if (d > 0)   return Math.min(d,cutoff) / cutoff;
 else   return Math.max(d,-cutoff) / cutoff;
}","/** 
 * Return signed distance of timepoint t to t0, truncated at cutoff and scaled by 1/cutoff. t=t0 has d=0. t&lt;=t0-cutoff has d=-1. t=&gt;t0+cutoff has d=1.
 */
private static double timeDistance(final double t,final double t0,final double cutoff){
  final double d=t - t0;
  if (d > 0)   return Math.min(d,cutoff) / cutoff;
 else   return Math.max(d,-cutoff) / cutoff;
}",0.9865951742627346
90935,"/** 
 * Follow backwards along incoming edges until <ul> <li>(A) a vertex is reached that is already marked with ghostmark or mark, or <li>(B) vertex is reached that has timepoint <= minTimepoint. </ul> Mark all recursively visited vertices as ghosts. In case (B), add the final vertex to set of roots.
 */
private void buildContextTraceParents(final TrackSchemeVertex tv,final int ghostmark,final int minTimepoint,final RefList<TrackSchemeVertex> roots){
  if (tv.incomingEdges().isEmpty())   roots.add(tv);
 else {
    final TrackSchemeVertex ref=graph.vertexRef();
    for (    final TrackSchemeEdge te : tv.incomingEdges()) {
      final TrackSchemeVertex parent=te.getSource(ref);
      if (parent.getLayoutTimestamp() < ghostmark) {
        parent.setLayoutTimestamp(ghostmark);
        if (parent.getTimepoint() <= minTimepoint)         roots.add(parent);
 else         buildContextTraceParents(parent,ghostmark,minTimepoint,roots);
      }
    }
    graph.releaseRef(ref);
  }
}","/** 
 * Follow backwards along incoming edges until <ul> <li>(A) a vertex is reached that is already marked with ghostmark or mark, or <li>(B) vertex is reached that has timepoint &lt;= minTimepoint. </ul> Mark all recursively visited vertices as ghosts. In case (B), add the final vertex to set of roots.
 */
private void buildContextTraceParents(final TrackSchemeVertex tv,final int ghostmark,final int minTimepoint,final RefList<TrackSchemeVertex> roots){
  if (tv.incomingEdges().isEmpty())   roots.add(tv);
 else {
    final TrackSchemeVertex ref=graph.vertexRef();
    for (    final TrackSchemeEdge te : tv.incomingEdges()) {
      final TrackSchemeVertex parent=te.getSource(ref);
      if (parent.getLayoutTimestamp() < ghostmark) {
        parent.setLayoutTimestamp(ghostmark);
        if (parent.getTimepoint() <= minTimepoint)         roots.add(parent);
 else         buildContextTraceParents(parent,ghostmark,minTimepoint,roots);
      }
    }
    graph.releaseRef(ref);
  }
}",0.9974683544303796
90936,"private void addBranch(final Spot start,final double vx,final double vy,final int iteration,final int nDivisions,final int nFramesPerDivision){
  if (iteration >= nDivisions) {
    return;
  }
  final Spot previousSpot=model.getGraph().vertexRef();
  final Spot spot=model.getGraph().vertexRef();
  final Spot daughter=model.getGraph().vertexRef();
  final Link link=model.getGraph().edgeRef();
  final double[] pos=new double[3];
  final double[][] cov=new double[][]{{RADIUS,0,0},{0,RADIUS,0},{0,0,RADIUS}};
  previousSpot.refTo(start);
  for (int it=0; it < nFramesPerDivision; it++) {
    pos[0]=previousSpot.getDoublePosition(0) + vx;
    pos[1]=previousSpot.getDoublePosition(1) + vy;
    pos[2]=previousSpot.getDoublePosition(2);
    final int frame=previousSpot.getTimepoint() + 1;
    model.addSpot(frame,pos,cov,spot);
    model.addLink(previousSpot,spot,link);
    previousSpot.refTo(spot);
  }
  for (int id=0; id < 2; id++) {
    final double sign=id == 0 ? 1 : -1;
    final double x;
    final double y;
    final double z;
    if (iteration % 2 == 0) {
      x=previousSpot.getDoublePosition(0);
      y=previousSpot.getDoublePosition(1);
      z=previousSpot.getDoublePosition(2) + sign * VELOCITY * (1 - 0.5d * iteration / nDivisions)* 2;
    }
 else {
      x=previousSpot.getDoublePosition(0) - sign * vy * (1 - 0.5d * iteration / nDivisions)* 2;
      y=previousSpot.getDoublePosition(1) + sign * vx * (1 - 0.5d * iteration / nDivisions)* 2;
      z=previousSpot.getDoublePosition(2);
    }
    final int frame=previousSpot.getTimepoint() + 1;
    pos[0]=x;
    pos[1]=y;
    pos[2]=z;
    model.addSpot(frame,pos,cov,daughter);
    model.addLink(previousSpot,daughter,link);
    addBranch(daughter,vx,vy,iteration + 1,nDivisions,nFramesPerDivision);
  }
  model.getGraph().releaseRef(previousSpot);
  model.getGraph().releaseRef(spot);
  model.getGraph().releaseRef(daughter);
  model.getGraph().releaseRef(link);
}","private void addBranch(final Spot start,final double vx,final double vy,final int iteration,final int nDivisions,final int nFramesPerDivision){
  if (iteration >= nDivisions) {
    return;
  }
  final Spot previousSpot=model.getGraph().vertexRef();
  final Spot spot=model.getGraph().vertexRef();
  final Spot daughter=model.getGraph().vertexRef();
  final Link link=model.getGraph().edgeRef();
  final double[] pos=new double[3];
  final double[][] cov=new double[][]{{RADIUS,0,0},{0,RADIUS,0},{0,0,RADIUS}};
  previousSpot.refTo(start);
  for (int it=0; it < nFramesPerDivision; it++) {
    pos[0]=previousSpot.getDoublePosition(0) + vx;
    pos[1]=previousSpot.getDoublePosition(1) + vy;
    pos[2]=previousSpot.getDoublePosition(2);
    final int frame=previousSpot.getTimepoint() + 1;
    model.getGraph().addVertex(spot).init(frame,pos,cov);
    model.getGraph().addEdge(previousSpot,spot,link).init();
    previousSpot.refTo(spot);
  }
  for (int id=0; id < 2; id++) {
    final double sign=id == 0 ? 1 : -1;
    final double x;
    final double y;
    final double z;
    if (iteration % 2 == 0) {
      x=previousSpot.getDoublePosition(0);
      y=previousSpot.getDoublePosition(1);
      z=previousSpot.getDoublePosition(2) + sign * VELOCITY * (1 - 0.5d * iteration / nDivisions)* 2;
    }
 else {
      x=previousSpot.getDoublePosition(0) - sign * vy * (1 - 0.5d * iteration / nDivisions)* 2;
      y=previousSpot.getDoublePosition(1) + sign * vx * (1 - 0.5d * iteration / nDivisions)* 2;
      z=previousSpot.getDoublePosition(2);
    }
    final int frame=previousSpot.getTimepoint() + 1;
    pos[0]=x;
    pos[1]=y;
    pos[2]=z;
    model.getGraph().addVertex(daughter).init(frame,pos,cov);
    model.getGraph().addEdge(previousSpot,daughter,link).init();
    addBranch(daughter,vx,vy,iteration + 1,nDivisions,nFramesPerDivision);
  }
  model.getGraph().releaseRef(previousSpot);
  model.getGraph().releaseRef(spot);
  model.getGraph().releaseRef(daughter);
  model.getGraph().releaseRef(link);
}",0.9326241134751772
90937,"public Model run(final int nStartingCells,final int nDivisions,final int nFramesPerDivision){
  final Spot mother=model.getGraph().vertexRef();
  for (int ic=0; ic < nStartingCells; ic++) {
    final double angle=2d * ic * Math.PI / N_STARTING_CELLS;
    final double vx=VELOCITY * Math.cos(angle);
    final double vy=VELOCITY * Math.sin(angle);
    final double x=0.;
    final double y=0.;
    final double z=N_DIVISIONS * VELOCITY;
    final double[] pos=new double[]{x,y,z};
    final double[][] cov=new double[][]{{RADIUS,0,0},{0,RADIUS,0},{0,0,RADIUS}};
    model.addSpot(0,pos,cov,mother);
    addBranch(mother,vx,vy,1,nDivisions,nFramesPerDivision);
  }
  model.getGraph().releaseRef(mother);
  return model;
}","public Model run(final int nStartingCells,final int nDivisions,final int nFramesPerDivision){
  final Spot tmp=model.getGraph().vertexRef();
  for (int ic=0; ic < nStartingCells; ic++) {
    final double angle=2d * ic * Math.PI / N_STARTING_CELLS;
    final double vx=VELOCITY * Math.cos(angle);
    final double vy=VELOCITY * Math.sin(angle);
    final double x=0.;
    final double y=0.;
    final double z=N_DIVISIONS * VELOCITY;
    final double[] pos=new double[]{x,y,z};
    final double[][] cov=new double[][]{{RADIUS,0,0},{0,RADIUS,0},{0,0,RADIUS}};
    final Spot mother=model.getGraph().addVertex(tmp).init(0,pos,cov);
    addBranch(mother,vx,vy,1,nDivisions,nFramesPerDivision);
  }
  model.getGraph().releaseRef(tmp);
  return model;
}",0.9236016371077762
90938,"public static void main(final String[] args){
  final Model model=new Model();
  final Spot ref=model.getGraph().vertexRef();
  final Random random=new Random();
  final double[] pos=new double[3];
  final double[][] cov=new double[3][3];
  for (int i=0; i < 1000000; ++i) {
    for (int d=0; d < 3; ++d)     pos[d]=random.nextDouble();
    final Spot spot=model.addSpot(0,pos,cov,ref);
    spot.feature(LABEL).set(""String_Node_Str"" + i);
    spot.feature(TRACKLENGTH).set(3);
  }
  model.getGraph().releaseRef(ref);
  while (true) {
    try {
      final File file=new File(""String_Node_Str"");
      long t0=System.currentTimeMillis();
      model.saveRaw(file);
      long t1=System.currentTimeMillis();
      System.out.println(""String_Node_Str"" + (t1 - t0) + ""String_Node_Str"");
      final Model loaded=new Model();
      final Spot s=loaded.addSpot(0,pos,cov,loaded.getGraph().vertexRef());
      s.feature(LABEL);
      s.feature(TRACKLENGTH);
      t0=System.currentTimeMillis();
      loaded.loadRaw(file);
      t1=System.currentTimeMillis();
      System.out.println(""String_Node_Str"" + (t1 - t0) + ""String_Node_Str"");
      final Spot next=model.getGraph().vertices().iterator().next();
      System.out.println(next.feature(LABEL).get());
      System.out.println(next.feature(TRACKLENGTH).get());
    }
 catch (    final IOException e) {
      e.printStackTrace();
    }
  }
}","public static void main(final String[] args){
  final Model model=new Model();
  final Spot ref=model.getGraph().vertexRef();
  final Random random=new Random();
  final double[] pos=new double[3];
  final double[][] cov=new double[3][3];
  for (int i=0; i < 1000000; ++i) {
    for (int d=0; d < 3; ++d)     pos[d]=random.nextDouble();
    final Spot spot=model.getGraph().addVertex(ref).init(0,pos,cov);
    spot.feature(LABEL).set(""String_Node_Str"" + i);
    spot.feature(TRACKLENGTH).set(3);
  }
  model.getGraph().releaseRef(ref);
  while (true) {
    try {
      final File file=new File(""String_Node_Str"");
      long t0=System.currentTimeMillis();
      model.saveRaw(file);
      long t1=System.currentTimeMillis();
      System.out.println(""String_Node_Str"" + (t1 - t0) + ""String_Node_Str"");
      final Model loaded=new Model();
      final Spot tmp=loaded.getGraph().vertexRef();
      final Spot s=loaded.getGraph().addVertex(tmp).init(0,pos,cov);
      s.feature(LABEL);
      s.feature(TRACKLENGTH);
      t0=System.currentTimeMillis();
      loaded.loadRaw(file);
      t1=System.currentTimeMillis();
      System.out.println(""String_Node_Str"" + (t1 - t0) + ""String_Node_Str"");
      final Spot next=model.getGraph().vertices().iterator().next();
      System.out.println(next.feature(LABEL).get());
      System.out.println(next.feature(TRACKLENGTH).get());
      loaded.getGraph().releaseRef(ref);
    }
 catch (    final IOException e) {
      e.printStackTrace();
    }
  }
}",0.925476603119584
90939,"public E getEdge(final AbstractVertex<?,?,?> source,final AbstractVertex<?,?,?> target,final E edge){
  int nextSourceEdgeIndex=source.getFirstOutEdgeIndex();
  if (nextSourceEdgeIndex < 0)   return null;
  getObject(nextSourceEdgeIndex,edge);
  do {
    if (edge.getTargetVertexInternalPoolIndex() == target.getInternalPoolIndex())     return edge;
    getObject(nextSourceEdgeIndex,edge);
    nextSourceEdgeIndex=edge.getNextSourceEdgeIndex();
  }
 while (nextSourceEdgeIndex >= 0);
  return null;
}","public E getEdge(final AbstractVertex<?,?,?> source,final AbstractVertex<?,?,?> target,final E edge){
  int nextSourceEdgeIndex=source.getFirstOutEdgeIndex();
  if (nextSourceEdgeIndex < 0)   return null;
  do {
    getObject(nextSourceEdgeIndex,edge);
    if (edge.getTargetVertexInternalPoolIndex() == target.getInternalPoolIndex())     return edge;
    nextSourceEdgeIndex=edge.getNextSourceEdgeIndex();
  }
 while (nextSourceEdgeIndex >= 0);
  return null;
}",0.940809968847352
90940,"/** 
 * Create BigDataViewer actions and install them in the specified  {@link InputActionBindings}.
 * @param inputActionBindings {@link InputMap} and {@link ActionMap} are installed here.
 * @param bdv Actions are targeted at this  {@link BigDataViewerMaMuT}.
 * @param keyProperties user-defined key-bindings.
 */
public static void installActionBindings(final InputActionBindings inputActionBindings,final Model model,final KeyStrokeAdder.Factory keyProperties){
  final UndoActions actions=new UndoActions(inputActionBindings,keyProperties);
  actions.runnableAction(model::undo,UNDO,UNDO_KEYS);
  actions.runnableAction(model::redo,REDO,REDO_KEYS);
}","/** 
 * Create Undo/Redo actions and install them in the specified  {@link InputActionBindings}.
 * @param inputActionBindings {@link InputMap} and {@link ActionMap} are installed here.
 * @param model Actions are targeted at this  {@link Model}s   {@code undo()} and{@code redo()} methods.
 * @param keyProperties user-defined key-bindings.
 */
public static void installActionBindings(final InputActionBindings inputActionBindings,final Model model,final KeyStrokeAdder.Factory keyProperties){
  final UndoActions actions=new UndoActions(inputActionBindings,keyProperties);
  actions.runnableAction(model::undo,UNDO,UNDO_KEYS);
  actions.runnableAction(model::redo,REDO,REDO_KEYS);
}",0.9291573452647278
90941,"/** 
 * Sends   {@link GraphListener#vertexAdded(net.trackmate.graph.zzgraphinterfaces.Vertex)} forthe specified vertex. Must be called, after {@link #addVertex(AbstractVertex)} and {@code Vertex.init(...)} has beencalled.
 * @param vertex vertex for which to send {@link GraphListener#vertexAdded(net.trackmate.graph.zzgraphinterfaces.Vertex)}.
 * @return the specified {@code vertex} argument.
 */
public V notifyVertexAdded(final V vertex);","/** 
 * Sends   {@link GraphListener#vertexAdded(Vertex)} for the specified vertex.Must be called, after {code addVertex(...)} and  {@code Vertex.init(...)}have been called.
 * @param vertex vertex for which to send {@link GraphListener#vertexAdded(Vertex)}.
 * @return the specified {@code vertex} argument.
 */
public V notifyVertexAdded(final V vertex);",0.4680851063829787
90942,"public void init(final VertexFeature<?,V,?> feature,final V vertex){
  super.init();
  final int vi=vertexUndoIdBimap.getId(vertex);
  final int fi=featureStore.createFeatureUndoId();
  final int fuid=feature.getUniqueFeatureId();
  featureStore.store(fi,feature,vertex);
  final int dataIndex=dataStack.getNextDataIndex();
  dataStack.out.writeInt(vi);
  dataStack.out.writeInt(fi);
  dataStack.out.writeInt(fuid);
  ref.setDataIndex(dataIndex);
}","public void init(final VertexFeature<?,V,?> feature,final V vertex){
  super.init();
  final int vi=vertexUndoIdBimap.getId(vertex);
  final int fi=featureStore.createFeatureUndoId();
  final int fuid=feature.getUniqueFeatureId();
  featureStore.store(fi,feature,vertex);
  final long dataIndex=dataStack.getWriteDataIndex();
  dataStack.out.writeInt(vi);
  dataStack.out.writeInt(fi);
  dataStack.out.writeInt(fuid);
  ref.setDataIndex(dataIndex);
}",0.9821826280623608
90943,"public synchronized void doAddVertex(final long dataIndex){
  dataStack.setDataIndex(dataIndex);
  final int vi=dataStack.in.readInt();
  final int fi=dataStack.in.readInt();
  dataStack.in.readFully(data);
  final V ref=graph.vertexRef();
  final V vertex=graph.addVertex(ref);
  vertexUndoIdBimap.put(vi,vertex);
  serializer.setBytes(vertex,data);
  featureStore.retrieveAll(fi,vertex);
  graph.notifyVertexAdded(vertex);
  graph.releaseRef(ref);
}","public long doAddVertex(final long dataIndex){
  dataStack.setReadDataIndex(dataIndex);
  final int vi=dataStack.in.readInt();
  final int fi=dataStack.in.readInt();
  dataStack.in.readFully(data);
  final V ref=graph.vertexRef();
  final V vertex=graph.addVertex(ref);
  vertexUndoIdBimap.put(vi,vertex);
  serializer.setBytes(vertex,data);
  featureStore.retrieveAll(fi,vertex);
  graph.notifyVertexAdded(vertex);
  graph.releaseRef(ref);
  return dataStack.getReadDataIndex();
}",0.8240343347639485
90944,"public AddRemoveVertexRecord(){
  data=new byte[serializer.getVertexNumBytes()];
  ;
}","public AddRemoveVertexRecord(){
  data=new byte[serializer.getVertexNumBytes()];
}",0.9761904761904762
90945,"public void doAddEdge(final long dataIndex){
  dataStack.setDataIndex(dataIndex);
  final int ei=dataStack.in.readInt();
  final int fi=dataStack.in.readInt();
  final int si=dataStack.in.readInt();
  final int sOutIndex=dataStack.in.readInt();
  final int ti=dataStack.in.readInt();
  final int tInIndex=dataStack.in.readInt();
  dataStack.in.readFully(data);
  final V vref1=graph.vertexRef();
  final V vref2=graph.vertexRef();
  final E eref=graph.edgeRef();
  final V source=vertexUndoIdBimap.getObject(si,vref1);
  final V target=vertexUndoIdBimap.getObject(ti,vref2);
  final E edge=graph.insertEdge(source,sOutIndex,target,tInIndex,eref);
  edgeUndoIdBimap.put(ei,edge);
  serializer.setBytes(edge,data);
  featureStore.retrieveAll(fi,edge);
  graph.releaseRef(eref);
  graph.releaseRef(vref2);
  graph.releaseRef(vref1);
}","public long doAddEdge(final long dataIndex){
  dataStack.setReadDataIndex(dataIndex);
  final int ei=dataStack.in.readInt();
  final int fi=dataStack.in.readInt();
  final int si=dataStack.in.readInt();
  final int sOutIndex=dataStack.in.readInt();
  final int ti=dataStack.in.readInt();
  final int tInIndex=dataStack.in.readInt();
  dataStack.in.readFully(data);
  final V vref1=graph.vertexRef();
  final V vref2=graph.vertexRef();
  final E eref=graph.edgeRef();
  final V source=vertexUndoIdBimap.getObject(si,vref1);
  final V target=vertexUndoIdBimap.getObject(ti,vref2);
  final E edge=graph.insertEdge(source,sOutIndex,target,tInIndex,eref);
  edgeUndoIdBimap.put(ei,edge);
  serializer.setBytes(edge,data);
  featureStore.retrieveAll(fi,edge);
  graph.releaseRef(eref);
  graph.releaseRef(vref2);
  graph.releaseRef(vref1);
  return dataStack.getReadDataIndex();
}",0.9712609970674488
90946,"@Override public void redo(){
  undo();
}","@Override public void redo(){
  final long d0=ref.getDataIndex();
  final long d1=swap(d0);
  dataStack.setWriteDataIndex(d1);
}",0.4615384615384615
90947,"public void initAdd(final E edge,final UndoableEditRef<V,E> ref){
  final int ei=edgeUndoIdBimap.getId(edge);
  final int fi=featureStore.createFeatureUndoId();
  final int dataIndex=dataStack.getNextDataIndex();
  dataStack.out.writeInt(ei);
  dataStack.out.writeInt(fi);
  dataStack.out.skip(16 + data.length);
  ref.setDataIndex(dataIndex);
}","public void initAdd(final E edge,final UndoableEditRef<V,E> ref){
  final int ei=edgeUndoIdBimap.getId(edge);
  final int fi=featureStore.createFeatureUndoId();
  final long dataIndex=dataStack.getWriteDataIndex();
  dataStack.out.writeInt(ei);
  dataStack.out.writeInt(fi);
  dataStack.out.skip(16 + data.length);
  ref.setDataIndex(dataIndex);
}",0.976878612716763
90948,"public void initRemove(final E edge,final UndoableEditRef<V,E> ref){
  final V vref=graph.vertexRef();
  final int ei=edgeUndoIdBimap.getId(edge);
  final int fi=featureStore.createFeatureUndoId();
  final int si=vertexUndoIdBimap.getId(edge.getSource(vref));
  final int sOutIndex=edge.getSourceOutIndex();
  final int ti=vertexUndoIdBimap.getId(edge.getTarget(vref));
  final int tInIndex=edge.getTargetInIndex();
  graph.releaseRef(vref);
  serializer.getBytes(edge,data);
  featureStore.storeAll(fi,edge);
  final int dataIndex=dataStack.getNextDataIndex();
  dataStack.out.writeInt(ei);
  dataStack.out.writeInt(fi);
  dataStack.out.writeInt(si);
  dataStack.out.writeInt(sOutIndex);
  dataStack.out.writeInt(ti);
  dataStack.out.writeInt(tInIndex);
  dataStack.out.write(data);
  ref.setDataIndex(dataIndex);
}","public void initRemove(final E edge,final UndoableEditRef<V,E> ref){
  final V vref=graph.vertexRef();
  final int ei=edgeUndoIdBimap.getId(edge);
  final int fi=featureStore.createFeatureUndoId();
  final int si=vertexUndoIdBimap.getId(edge.getSource(vref));
  final int sOutIndex=edge.getSourceOutIndex();
  final int ti=vertexUndoIdBimap.getId(edge.getTarget(vref));
  final int tInIndex=edge.getTargetInIndex();
  graph.releaseRef(vref);
  serializer.getBytes(edge,data);
  featureStore.storeAll(fi,edge);
  final long dataIndex=dataStack.getWriteDataIndex();
  dataStack.out.writeInt(ei);
  dataStack.out.writeInt(fi);
  dataStack.out.writeInt(si);
  dataStack.out.writeInt(sOutIndex);
  dataStack.out.writeInt(ti);
  dataStack.out.writeInt(tInIndex);
  dataStack.out.write(data);
  ref.setDataIndex(dataIndex);
}",0.9902080783353732
90949,"@Override public void undo(){
  final long dataIndex=ref.getDataIndex();
  dataStack.setDataIndex(dataIndex);
  final int vi=dataStack.in.readInt();
  final int fi=dataStack.in.readInt();
  final int fuid=dataStack.in.readInt();
  final V ref=graph.vertexRef();
  final V vertex=vertexUndoIdBimap.getObject(vi,ref);
  @SuppressWarnings(""String_Node_Str"") final VertexFeature<?,V,?> feature=(VertexFeature<?,V,?>)FeatureRegistry.getVertexFeature(fuid);
  featureStore.swap(fi,feature,vertex);
  graph.releaseRef(ref);
}","@Override public void undo(){
  final long d0=ref.getDataIndex();
  swap(d0);
  dataStack.setWriteDataIndex(d0);
}",0.300632911392405
90950,"public synchronized void doRemoveVertex(final long dataIndex){
  dataStack.setDataIndex(dataIndex);
  final int vi=dataStack.in.readInt();
  final int fi=dataStack.in.readInt();
  final V vref=graph.vertexRef();
  final V vertex=vertexUndoIdBimap.getObject(vi,vref);
  serializer.getBytes(vertex,data);
  featureStore.storeAll(fi,vertex);
  dataStack.setDataIndex(dataIndex);
  dataStack.out.skip(8);
  dataStack.out.write(data);
  graph.remove(vertex);
  graph.releaseRef(vref);
}","public long doRemoveVertex(final long dataIndex){
  dataStack.setReadDataIndex(dataIndex);
  final int vi=dataStack.in.readInt();
  final int fi=dataStack.in.readInt();
  final V vref=graph.vertexRef();
  final V vertex=vertexUndoIdBimap.getObject(vi,vref);
  serializer.getBytes(vertex,data);
  featureStore.storeAll(fi,vertex);
  dataStack.setWriteDataIndex(dataIndex);
  dataStack.out.skip(8);
  dataStack.out.write(data);
  graph.remove(vertex);
  graph.releaseRef(vref);
  return dataStack.getWriteDataIndex();
}",0.9298597194388778
90951,"public void doRemoveEdge(final long dataIndex){
  dataStack.setDataIndex(dataIndex);
  final int ei=dataStack.in.readInt();
  final int fi=dataStack.in.readInt();
  final E ref=graph.edgeRef();
  final E edge=edgeUndoIdBimap.getObject(ei,ref);
  final V vref=graph.vertexRef();
  final int si=vertexUndoIdBimap.getId(edge.getSource(vref));
  final int sOutIndex=edge.getSourceOutIndex();
  final int ti=vertexUndoIdBimap.getId(edge.getTarget(vref));
  final int tInIndex=edge.getTargetInIndex();
  graph.releaseRef(vref);
  serializer.getBytes(edge,data);
  featureStore.storeAll(fi,edge);
  dataStack.setDataIndex(dataIndex);
  dataStack.out.skip(8);
  dataStack.out.writeInt(si);
  dataStack.out.writeInt(sOutIndex);
  dataStack.out.writeInt(ti);
  dataStack.out.writeInt(tInIndex);
  dataStack.out.write(data);
  graph.remove(edge);
  graph.releaseRef(ref);
}","public long doRemoveEdge(final long dataIndex){
  dataStack.setReadDataIndex(dataIndex);
  final int ei=dataStack.in.readInt();
  final int fi=dataStack.in.readInt();
  final E ref=graph.edgeRef();
  final E edge=edgeUndoIdBimap.getObject(ei,ref);
  final V vref=graph.vertexRef();
  final int si=vertexUndoIdBimap.getId(edge.getSource(vref));
  final int sOutIndex=edge.getSourceOutIndex();
  final int ti=vertexUndoIdBimap.getId(edge.getTarget(vref));
  final int tInIndex=edge.getTargetInIndex();
  graph.releaseRef(vref);
  serializer.getBytes(edge,data);
  featureStore.storeAll(fi,edge);
  dataStack.setWriteDataIndex(dataIndex);
  dataStack.out.skip(8);
  dataStack.out.writeInt(si);
  dataStack.out.writeInt(sOutIndex);
  dataStack.out.writeInt(ti);
  dataStack.out.writeInt(tInIndex);
  dataStack.out.write(data);
  graph.remove(edge);
  graph.releaseRef(ref);
  return dataStack.getWriteDataIndex();
}",0.9125775521714607
90952,"/** 
 * Returns the number of remaining bytes that can be read (or skipped over) from this input stream. <p> The value returned is <code>count&nbsp;- pos</code>, which is the number of bytes remaining to be read from the input buffer.
 * @return the number of remaining bytes that can be read (or skippedover) from this input stream without blocking.
 */
@Override public synchronized int available(){
  return rcount - pos;
}","/** 
 * Returns the number of remaining bytes that can be read (or skipped over) from this input stream. <p> The value returned is <code>count&nbsp;- pos</code>, which is the number of bytes remaining to be read from the input buffer.
 * @return the number of remaining bytes that can be read (or skippedover) from this input stream without blocking.
 */
@Override public synchronized int available(){
  return buf.length - pos;
}",0.9813084112149532
90953,"/** 
 * Reads up to <code>len</code> bytes of data into an array of bytes from this input stream. If <code>pos</code> equals <code>count</code> , then <code>-1</code> is returned to indicate end of file. Otherwise, the number <code>k</code> of bytes read is equal to the smaller of <code>len</code> and <code>count-pos</code>. If <code>k</code> is positive, then bytes <code>buf[pos]</code> through <code>buf[pos+k-1]</code> are copied into <code>b[off]</code> through <code>b[off+k-1]</code> in the manner performed by <code>System.arraycopy</code>. The value <code>k</code> is added into <code>pos</code> and <code>k</code> is returned. <p> This <code>read</code> method cannot block.
 * @param b the buffer into which the data is read.
 * @param off the start offset in the destination array <code>b</code>
 * @param len the maximum number of bytes read.
 * @return the total number of bytes read into the buffer, or<code>-1</code> if there is no more data because the end of the stream has been reached.
 * @exception NullPointerException If <code>b</code> is <code>null</code>.
 * @exception IndexOutOfBoundsException If <code>off</code> is negative, <code>len</code> is negative, or <code>len</code> is greater than <code>b.length - off</code>
 */
@Override public int read(final byte b[],final int off,int len){
  if (b == null) {
    throw new NullPointerException();
  }
 else   if (off < 0 || len < 0 || len > b.length - off) {
    throw new IndexOutOfBoundsException();
  }
  if (pos >= rcount) {
    return -1;
  }
  final int avail=rcount - pos;
  if (len > avail) {
    len=avail;
  }
  if (len <= 0) {
    return 0;
  }
  System.arraycopy(buf,pos,b,off,len);
  pos+=len;
  return len;
}","/** 
 * Reads up to <code>len</code> bytes of data into an array of bytes from this input stream. If <code>pos</code> equals <code>count</code> , then <code>-1</code> is returned to indicate end of file. Otherwise, the number <code>k</code> of bytes read is equal to the smaller of <code>len</code> and <code>count-pos</code>. If <code>k</code> is positive, then bytes <code>buf[pos]</code> through <code>buf[pos+k-1]</code> are copied into <code>b[off]</code> through <code>b[off+k-1]</code> in the manner performed by <code>System.arraycopy</code>. The value <code>k</code> is added into <code>pos</code> and <code>k</code> is returned. <p> This <code>read</code> method cannot block.
 * @param b the buffer into which the data is read.
 * @param off the start offset in the destination array <code>b</code>
 * @param len the maximum number of bytes read.
 * @return the total number of bytes read into the buffer, or<code>-1</code> if there is no more data because the end of the stream has been reached.
 * @exception NullPointerException If <code>b</code> is <code>null</code>.
 * @exception IndexOutOfBoundsException If <code>off</code> is negative, <code>len</code> is negative, or <code>len</code> is greater than <code>b.length - off</code>
 */
@Override public int read(final byte b[],final int off,int len){
  if (b == null) {
    throw new NullPointerException();
  }
 else   if (off < 0 || len < 0 || len > b.length - off) {
    throw new IndexOutOfBoundsException();
  }
  if (pos >= buf.length) {
    return -1;
  }
  final int avail=buf.length - pos;
  if (len > avail) {
    len=avail;
  }
  if (len <= 0) {
    return 0;
  }
  System.arraycopy(buf,pos,b,off,len);
  pos+=len;
  return len;
}",0.990615835777126
90954,"private UndoableEditList(final int initialCapacity,final Factory<V,E> f,final ModelGraph_HACK_FIX_ME<V,E> graph,final GraphFeatures<V,E> graphFeatures,final UndoSerializer<V,E> serializer,final UndoIdBimap<V> vertexUndoIdBimap,final UndoIdBimap<E> edgeUndoIdBimap){
  super(initialCapacity,f);
  f.pool=this;
  f.graph=graph;
  f.graphFeatures=graphFeatures;
  f.serializer=serializer;
  f.vertexUndoIdBimap=vertexUndoIdBimap;
  f.edgeUndoIdBimap=edgeUndoIdBimap;
  f.nonRefEdits=nonRefEdits;
}","private UndoableEditList(final int initialCapacity,final Factory<V,E> f,final ModelGraph_HACK_FIX_ME<V,E> graph,final GraphFeatures<V,E> graphFeatures,final UndoSerializer<V,E> serializer,final UndoIdBimap<V> vertexUndoIdBimap,final UndoIdBimap<E> edgeUndoIdBimap){
  super(initialCapacity,f);
  f.pool=this;
  this.graph=graph;
  this.serializer=serializer;
  this.vertexUndoIdBimap=vertexUndoIdBimap;
  this.edgeUndoIdBimap=edgeUndoIdBimap;
  this.dataStack=new UndoDataStack(1024 * 1024 * 32);
  this.featureStore=new UndoFeatureStore<>(graphFeatures);
  this.nonRefEdits=new ArrayList<>();
  f.graph=graph;
  f.graphFeatures=graphFeatures;
  f.serializer=serializer;
  f.vertexUndoIdBimap=vertexUndoIdBimap;
  f.edgeUndoIdBimap=edgeUndoIdBimap;
  f.dataStack=dataStack;
  f.featureStore=featureStore;
  f.nonRefEdits=nonRefEdits;
}",0.7042889390519187
90955,"protected UndoableEditRef(final Pool<UndoableEditRef<V,E>,ByteMappedElement> pool,final ModelGraph_HACK_FIX_ME<V,E> graph,final GraphFeatures<V,E> graphFeatures,final UndoSerializer<V,E> serializer,final UndoIdBimap<V> vertexUndoIdBimap,final UndoIdBimap<E> edgeUndoIdBimap,final ArrayList<UndoableEdit> nonRefEdits){
  super(pool);
  this.graph=graph;
  this.serializer=serializer;
  this.vertexUndoIdBimap=vertexUndoIdBimap;
  this.edgeUndoIdBimap=edgeUndoIdBimap;
  this.nonRefEdits=nonRefEdits;
  dataStack=new UndoDataStack(1024 * 1024 * 32);
  featureStore=new UndoFeatureStore<>(graphFeatures);
  addRemoveVertex=new AddRemoveVertexRecord();
  addRemoveEdge=new AddRemoveEdgeRecord();
  addVertex=new AddVertex();
  removeVertex=new RemoveVertex();
  addEdge=new AddEdge();
  removeEdge=new RemoveEdge();
}","protected UndoableEditRef(final Pool<UndoableEditRef<V,E>,ByteMappedElement> pool,final ModelGraph_HACK_FIX_ME<V,E> graph,final GraphFeatures<V,E> graphFeatures,final UndoSerializer<V,E> serializer,final UndoIdBimap<V> vertexUndoIdBimap,final UndoIdBimap<E> edgeUndoIdBimap,final UndoDataStack dataStack,final UndoFeatureStore<V,E> featureStore,final ArrayList<UndoableEdit> nonRefEdits){
  super(pool);
  this.graph=graph;
  this.serializer=serializer;
  this.vertexUndoIdBimap=vertexUndoIdBimap;
  this.edgeUndoIdBimap=edgeUndoIdBimap;
  this.dataStack=dataStack;
  this.featureStore=featureStore;
  this.nonRefEdits=nonRefEdits;
  addRemoveVertex=new AddRemoveVertexRecord();
  addRemoveEdge=new AddRemoveEdgeRecord();
  addVertex=new AddVertex();
  removeVertex=new RemoveVertex();
  addEdge=new AddEdge();
  removeEdge=new RemoveEdge();
}",0.8804347826086957
90956,"@Override public UndoableEditRef<V,E> createEmptyRef(){
  return new UndoableEditRef<V,E>(pool,graph,graphFeatures,serializer,vertexUndoIdBimap,edgeUndoIdBimap,nonRefEdits);
}","@Override public UndoableEditRef<V,E> createEmptyRef(){
  return new UndoableEditRef<V,E>(pool,graph,graphFeatures,serializer,vertexUndoIdBimap,edgeUndoIdBimap,dataStack,featureStore,nonRefEdits);
}",0.938337801608579
90957,"public UndoableEditTypeImp(){
  typeIndex=idgen;
  undoableEditTypes.put(typeIndex,this);
}","public UndoableEditTypeImp(){
  typeIndex=idgen++;
  undoableEditTypes.put(typeIndex,this);
}",0.9891304347826086
90958,"/** 
 * Remove an object from the index.
 * @param obj object to remove.
 * @return {@code true} if this index contained the specified object.
 */
public boolean remove(final O obj){
  final KDTreeNode<O,DoubleMappedElement> n=nodeMap.get(obj,node);
  if (n != null) {
    if (n.isValid()) {
      n.setValid(false);
      --size;
      return true;
    }
  }
 else   if (added.remove(obj)) {
    --size;
    return true;
  }
  return false;
}","/** 
 * Remove an object from the index.
 * @param obj object to remove.
 * @return {@code true} if this index contained the specified object.
 */
public boolean remove(final O obj){
  final KDTreeNode<O,DoubleMappedElement> n=nodeMap.get(obj,node);
  if (n != null) {
    if (n.isValid()) {
      n.setValid(false);
      final KDTreeNode<O,DoubleMappedElement> ref=nodeMap.createValueRef();
      nodeMap.removeWithRef(obj,ref);
      nodeMap.releaseValueRef(ref);
      --size;
      return true;
    }
  }
 else   if (added.remove(obj)) {
    --size;
    return true;
  }
  return false;
}",0.8552123552123552
90959,"public static File chooseFile(boolean useJFileChooser,final Component parent,final String selectedFile,final FileFilter fileFilter,final String dialogTitle,final DialogType dialogType,final SelectionMode selectionMode){
  final boolean isSaveDialog=(dialogType == DialogType.SAVE);
  final boolean isDirectoriesOnly=(selectionMode == SelectionMode.DIRECTORIES_ONLY);
  if (isSaveDialog && isDirectoriesOnly)   useJFileChooser=true;
  String title=dialogTitle;
  if (title == null)   title=(isSaveDialog ? ""String_Node_Str"" : ""String_Node_Str"") + (fileFilter == null ? ""String_Node_Str"" : ""String_Node_Str"" + fileFilter.getDescription());
  File file=null;
  if (useJFileChooser) {
    final JFileChooser fileChooser=new JFileChooser();
    fileChooser.setDialogTitle(title);
    if (selectedFile != null)     fileChooser.setSelectedFile(new File(selectedFile));
    fileChooser.setFileSelectionMode(isDirectoriesOnly ? JFileChooser.DIRECTORIES_ONLY : JFileChooser.FILES_ONLY);
    fileChooser.setFileFilter(fileFilter);
    final int returnVal=isSaveDialog ? fileChooser.showSaveDialog(parent) : fileChooser.showOpenDialog(parent);
    if (returnVal == JFileChooser.APPROVE_OPTION)     file=fileChooser.getSelectedFile();
  }
 else {
    final int fdMode=isSaveDialog ? FileDialog.SAVE : FileDialog.LOAD;
    final FileDialog fd;
    if (parent != null || parent instanceof Frame)     fd=new FileDialog((Frame)parent,title,fdMode);
 else     if (parent != null || parent instanceof Dialog)     fd=new FileDialog((Dialog)parent,title,fdMode);
 else     fd=new FileDialog((Frame)null,title,fdMode);
    if (selectedFile != null) {
      fd.setDirectory(new File(selectedFile).getParent());
      fd.setFile(new File(selectedFile).getName());
    }
    System.setProperty(""String_Node_Str"",isDirectoriesOnly ? ""String_Node_Str"" : ""String_Node_Str"");
    final AtomicBoolean workedWithFilenameFilter=new AtomicBoolean(false);
    if (fileFilter != null) {
      final FilenameFilter filenameFilter=new FilenameFilter(){
        private boolean firstTime=true;
        @Override public boolean accept(        final File dir,        final String name){
          if (firstTime) {
            workedWithFilenameFilter.set(true);
            firstTime=false;
          }
          return fileFilter.accept(new File(dir,name));
        }
      }
;
      fd.setFilenameFilter(filenameFilter);
      fd.setVisible(true);
    }
    if (fileFilter == null || (isMac() && !workedWithFilenameFilter.get())) {
      fd.setFilenameFilter(null);
      fd.setVisible(true);
    }
    final String filename=fd.getFile();
    if (filename != null) {
      file=new File(fd.getDirectory() + filename);
    }
  }
  return file;
}","public static File chooseFile(boolean useJFileChooser,final Component parent,final String selectedFile,final FileFilter fileFilter,final String dialogTitle,final DialogType dialogType,final SelectionMode selectionMode){
  final boolean isSaveDialog=(dialogType == DialogType.SAVE);
  final boolean isDirectoriesOnly=(selectionMode == SelectionMode.DIRECTORIES_ONLY);
  if (isSaveDialog && isDirectoriesOnly)   useJFileChooser=true;
  String title=dialogTitle;
  if (title == null)   title=(isSaveDialog ? ""String_Node_Str"" : ""String_Node_Str"") + (fileFilter == null ? ""String_Node_Str"" : ""String_Node_Str"" + fileFilter.getDescription());
  File file=null;
  if (useJFileChooser) {
    final JFileChooser fileChooser=new JFileChooser();
    fileChooser.setDialogTitle(title);
    if (selectedFile != null)     fileChooser.setSelectedFile(new File(selectedFile));
    fileChooser.setFileSelectionMode(isDirectoriesOnly ? JFileChooser.DIRECTORIES_ONLY : JFileChooser.FILES_ONLY);
    fileChooser.setFileFilter(fileFilter);
    final int returnVal=isSaveDialog ? fileChooser.showSaveDialog(parent) : fileChooser.showOpenDialog(parent);
    if (returnVal == JFileChooser.APPROVE_OPTION)     file=fileChooser.getSelectedFile();
  }
 else {
    final int fdMode=isSaveDialog ? FileDialog.SAVE : FileDialog.LOAD;
    final FileDialog fd;
    if (parent != null && parent instanceof Frame)     fd=new FileDialog((Frame)parent,title,fdMode);
 else     if (parent != null && parent instanceof Dialog)     fd=new FileDialog((Dialog)parent,title,fdMode);
 else     fd=new FileDialog((Frame)null,title,fdMode);
    if (selectedFile != null) {
      fd.setDirectory(new File(selectedFile).getParent());
      fd.setFile(new File(selectedFile).getName());
    }
    System.setProperty(""String_Node_Str"",isDirectoriesOnly ? ""String_Node_Str"" : ""String_Node_Str"");
    final AtomicBoolean workedWithFilenameFilter=new AtomicBoolean(false);
    if (fileFilter != null) {
      final FilenameFilter filenameFilter=new FilenameFilter(){
        private boolean firstTime=true;
        @Override public boolean accept(        final File dir,        final String name){
          if (firstTime) {
            workedWithFilenameFilter.set(true);
            firstTime=false;
          }
          return fileFilter.accept(new File(dir,name));
        }
      }
;
      fd.setFilenameFilter(filenameFilter);
      fd.setVisible(true);
    }
    if (fileFilter == null || (isMac() && !workedWithFilenameFilter.get())) {
      fd.setFilenameFilter(null);
      fd.setVisible(true);
    }
    final String filename=fd.getFile();
    if (filename != null) {
      file=new File(fd.getDirectory() + filename);
    }
  }
  return file;
}",0.9985218033998522
90960,"public RenderSettingsPanel(final RenderSettings renderSettings){
  super(new GridBagLayout());
  this.renderSettings=renderSettings;
  final GridBagConstraints c=new GridBagConstraints();
  c.insets=new Insets(0,5,0,5);
  c.gridwidth=1;
  c.gridy=0;
  antialiasingBox=new JCheckBox();
  antialiasingBox.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    final ActionEvent e){
      renderSettings.setUseAntialiasing(antialiasingBox.isSelected());
    }
  }
);
  c.anchor=GridBagConstraints.LINE_END;
  c.gridx=0;
  add(antialiasingBox,c);
  c.anchor=GridBagConstraints.LINE_START;
  c.gridx=1;
  add(new JLabel(""String_Node_Str""),c);
  c.gridy++;
  add(Box.createVerticalStrut(15),c);
  c.gridy++;
  linksBox=new JCheckBox();
  linksBox.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    final ActionEvent e){
      renderSettings.setDrawLinks(linksBox.isSelected());
    }
  }
);
  c.anchor=GridBagConstraints.LINE_END;
  c.gridx=0;
  add(linksBox,c);
  c.anchor=GridBagConstraints.LINE_START;
  c.gridx=1;
  add(new JLabel(""String_Node_Str""),c);
  c.gridy++;
  timeLimit=new BoundedValue(0,100,10){
    @Override public void setCurrentValue(    final int value){
      super.setCurrentValue(value);
      renderSettings.setTimeLimit(getCurrentValue());
    }
  }
;
  timeLimitSlider=new SliderPanel(null,timeLimit,1);
  timeLimitSlider.setNumColummns(tfCols);
  timeLimitSlider.setBorder(new EmptyBorder(0,0,0,6));
  c.anchor=GridBagConstraints.LINE_END;
  c.gridx=0;
  add(timeLimitSlider,c);
  c.anchor=GridBagConstraints.LINE_START;
  c.gridx=1;
  add(new JLabel(""String_Node_Str""),c);
  c.gridy++;
  gradientBox=new JCheckBox();
  gradientBox.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    final ActionEvent e){
      renderSettings.setUseGradient(gradientBox.isSelected());
    }
  }
);
  c.anchor=GridBagConstraints.LINE_END;
  c.gridx=0;
  add(gradientBox,c);
  c.anchor=GridBagConstraints.LINE_START;
  c.gridx=1;
  add(new JLabel(""String_Node_Str""),c);
  c.gridy++;
  add(Box.createVerticalStrut(15),c);
  c.gridy++;
  spotsBox=new JCheckBox();
  spotsBox.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    final ActionEvent e){
      renderSettings.setDrawSpots(spotsBox.isSelected());
    }
  }
);
  c.anchor=GridBagConstraints.LINE_END;
  c.gridx=0;
  add(spotsBox,c);
  c.anchor=GridBagConstraints.LINE_START;
  c.gridx=1;
  add(new JLabel(""String_Node_Str""),c);
  c.gridy++;
  intersectionBox=new JCheckBox();
  intersectionBox.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    final ActionEvent e){
      renderSettings.setDrawEllipsoidSliceIntersection(intersectionBox.isSelected());
    }
  }
);
  c.anchor=GridBagConstraints.LINE_END;
  c.gridx=0;
  add(intersectionBox,c);
  c.anchor=GridBagConstraints.LINE_START;
  c.gridx=1;
  add(new JLabel(""String_Node_Str""),c);
  c.gridy++;
  projectionBox=new JCheckBox();
  projectionBox.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    final ActionEvent e){
      renderSettings.setDrawEllipsoidSliceProjection(projectionBox.isSelected());
    }
  }
);
  c.anchor=GridBagConstraints.LINE_END;
  c.gridx=0;
  add(projectionBox,c);
  c.anchor=GridBagConstraints.LINE_START;
  c.gridx=1;
  add(new JLabel(""String_Node_Str""),c);
  c.gridy++;
  centersBox=new JCheckBox();
  centersBox.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    final ActionEvent e){
      renderSettings.setDrawSpotCenters(centersBox.isSelected());
    }
  }
);
  c.anchor=GridBagConstraints.LINE_END;
  c.gridx=0;
  add(centersBox,c);
  c.anchor=GridBagConstraints.LINE_START;
  c.gridx=1;
  add(new JLabel(""String_Node_Str""),c);
  c.gridy++;
  centersForEllipsesBox=new JCheckBox();
  centersForEllipsesBox.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    final ActionEvent e){
      renderSettings.setDrawEllipsoidSliceProjection(centersForEllipsesBox.isSelected());
    }
  }
);
  c.anchor=GridBagConstraints.LINE_END;
  c.gridx=0;
  add(centersForEllipsesBox,c);
  c.anchor=GridBagConstraints.LINE_START;
  c.gridx=1;
  add(new JLabel(""String_Node_Str""),c);
  c.gridy++;
  add(Box.createVerticalStrut(15),c);
  c.gridy++;
  focusLimit=new BoundedValueDouble(0,2000,100){
    @Override public void setCurrentValue(    final double value){
      super.setCurrentValue(value);
      renderSettings.setFocusLimit(getCurrentValue());
    }
  }
;
  focusLimitSlider=new SliderPanelDouble(null,focusLimit,1);
  focusLimitSlider.setDecimalFormat(""String_Node_Str"");
  focusLimitSlider.setNumColummns(tfCols);
  focusLimitSlider.setBorder(new EmptyBorder(0,0,0,6));
  c.anchor=GridBagConstraints.LINE_END;
  c.gridx=0;
  add(focusLimitSlider,c);
  c.anchor=GridBagConstraints.LINE_START;
  c.gridx=1;
  add(new JLabel(""String_Node_Str""),c);
  c.gridy++;
  focusLimitRelativeBox=new JCheckBox();
  focusLimitRelativeBox.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    final ActionEvent e){
      renderSettings.setFocusLimitViewRelative(focusLimitRelativeBox.isSelected());
    }
  }
);
  c.anchor=GridBagConstraints.LINE_END;
  c.gridx=0;
  add(focusLimitRelativeBox,c);
  c.anchor=GridBagConstraints.LINE_START;
  c.gridx=1;
  add(new JLabel(""String_Node_Str""),c);
  c.gridy++;
  add(Box.createVerticalStrut(15),c);
  c.gridy++;
  ellipsoidFadeDepth=new BoundedValueDouble(0,1,0.2){
    @Override public void setCurrentValue(    final double value){
      super.setCurrentValue(value);
      renderSettings.setEllipsoidFadeDepth(getCurrentValue());
    }
  }
;
  ellipsoidFadeDepthSlider=new SliderPanelDouble(null,ellipsoidFadeDepth,0.05);
  ellipsoidFadeDepthSlider.setDecimalFormat(""String_Node_Str"");
  ellipsoidFadeDepthSlider.setNumColummns(tfCols);
  ellipsoidFadeDepthSlider.setBorder(new EmptyBorder(0,0,0,6));
  c.anchor=GridBagConstraints.LINE_END;
  c.gridx=0;
  add(ellipsoidFadeDepthSlider,c);
  c.anchor=GridBagConstraints.LINE_START;
  c.gridx=1;
  add(new JLabel(""String_Node_Str""),c);
  c.gridy++;
  pointFadeDepth=new BoundedValueDouble(0,1,0.2){
    @Override public void setCurrentValue(    final double value){
      super.setCurrentValue(value);
      renderSettings.setPointFadeDepth(getCurrentValue());
    }
  }
;
  pointFadeDepthSlider=new SliderPanelDouble(null,pointFadeDepth,0.05);
  pointFadeDepthSlider.setDecimalFormat(""String_Node_Str"");
  pointFadeDepthSlider.setNumColummns(tfCols);
  pointFadeDepthSlider.setBorder(new EmptyBorder(0,0,0,6));
  c.anchor=GridBagConstraints.LINE_END;
  c.gridx=0;
  add(pointFadeDepthSlider,c);
  c.anchor=GridBagConstraints.LINE_START;
  c.gridx=1;
  add(new JLabel(""String_Node_Str""),c);
  update();
}","public RenderSettingsPanel(final RenderSettings renderSettings){
  super(new GridBagLayout());
  this.renderSettings=renderSettings;
  final GridBagConstraints c=new GridBagConstraints();
  c.insets=new Insets(0,5,0,5);
  c.gridwidth=1;
  c.gridy=0;
  antialiasingBox=new JCheckBox();
  antialiasingBox.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    final ActionEvent e){
      renderSettings.setUseAntialiasing(antialiasingBox.isSelected());
    }
  }
);
  c.anchor=GridBagConstraints.LINE_END;
  c.gridx=0;
  add(antialiasingBox,c);
  c.anchor=GridBagConstraints.LINE_START;
  c.gridx=1;
  add(new JLabel(""String_Node_Str""),c);
  c.gridy++;
  add(Box.createVerticalStrut(15),c);
  c.gridy++;
  linksBox=new JCheckBox();
  linksBox.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    final ActionEvent e){
      renderSettings.setDrawLinks(linksBox.isSelected());
    }
  }
);
  c.anchor=GridBagConstraints.LINE_END;
  c.gridx=0;
  add(linksBox,c);
  c.anchor=GridBagConstraints.LINE_START;
  c.gridx=1;
  add(new JLabel(""String_Node_Str""),c);
  c.gridy++;
  timeLimit=new BoundedValue(0,100,10){
    @Override public void setCurrentValue(    final int value){
      super.setCurrentValue(value);
      renderSettings.setTimeLimit(getCurrentValue());
    }
  }
;
  timeLimitSlider=new SliderPanel(null,timeLimit,1);
  timeLimitSlider.setNumColummns(tfCols);
  timeLimitSlider.setBorder(new EmptyBorder(0,0,0,6));
  c.anchor=GridBagConstraints.LINE_END;
  c.gridx=0;
  add(timeLimitSlider,c);
  c.anchor=GridBagConstraints.LINE_START;
  c.gridx=1;
  add(new JLabel(""String_Node_Str""),c);
  c.gridy++;
  gradientBox=new JCheckBox();
  gradientBox.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    final ActionEvent e){
      renderSettings.setUseGradient(gradientBox.isSelected());
    }
  }
);
  c.anchor=GridBagConstraints.LINE_END;
  c.gridx=0;
  add(gradientBox,c);
  c.anchor=GridBagConstraints.LINE_START;
  c.gridx=1;
  add(new JLabel(""String_Node_Str""),c);
  c.gridy++;
  add(Box.createVerticalStrut(15),c);
  c.gridy++;
  spotsBox=new JCheckBox();
  spotsBox.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    final ActionEvent e){
      renderSettings.setDrawSpots(spotsBox.isSelected());
    }
  }
);
  c.anchor=GridBagConstraints.LINE_END;
  c.gridx=0;
  add(spotsBox,c);
  c.anchor=GridBagConstraints.LINE_START;
  c.gridx=1;
  add(new JLabel(""String_Node_Str""),c);
  c.gridy++;
  intersectionBox=new JCheckBox();
  intersectionBox.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    final ActionEvent e){
      renderSettings.setDrawEllipsoidSliceIntersection(intersectionBox.isSelected());
    }
  }
);
  c.anchor=GridBagConstraints.LINE_END;
  c.gridx=0;
  add(intersectionBox,c);
  c.anchor=GridBagConstraints.LINE_START;
  c.gridx=1;
  add(new JLabel(""String_Node_Str""),c);
  c.gridy++;
  projectionBox=new JCheckBox();
  projectionBox.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    final ActionEvent e){
      renderSettings.setDrawEllipsoidSliceProjection(projectionBox.isSelected());
    }
  }
);
  c.anchor=GridBagConstraints.LINE_END;
  c.gridx=0;
  add(projectionBox,c);
  c.anchor=GridBagConstraints.LINE_START;
  c.gridx=1;
  add(new JLabel(""String_Node_Str""),c);
  c.gridy++;
  centersBox=new JCheckBox();
  centersBox.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    final ActionEvent e){
      renderSettings.setDrawSpotCenters(centersBox.isSelected());
    }
  }
);
  c.anchor=GridBagConstraints.LINE_END;
  c.gridx=0;
  add(centersBox,c);
  c.anchor=GridBagConstraints.LINE_START;
  c.gridx=1;
  add(new JLabel(""String_Node_Str""),c);
  c.gridy++;
  centersForEllipsesBox=new JCheckBox();
  centersForEllipsesBox.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    final ActionEvent e){
      renderSettings.setDrawSpotCentersForEllipses(centersForEllipsesBox.isSelected());
    }
  }
);
  c.anchor=GridBagConstraints.LINE_END;
  c.gridx=0;
  add(centersForEllipsesBox,c);
  c.anchor=GridBagConstraints.LINE_START;
  c.gridx=1;
  add(new JLabel(""String_Node_Str""),c);
  c.gridy++;
  add(Box.createVerticalStrut(15),c);
  c.gridy++;
  focusLimit=new BoundedValueDouble(0,2000,100){
    @Override public void setCurrentValue(    final double value){
      super.setCurrentValue(value);
      renderSettings.setFocusLimit(getCurrentValue());
    }
  }
;
  focusLimitSlider=new SliderPanelDouble(null,focusLimit,1);
  focusLimitSlider.setDecimalFormat(""String_Node_Str"");
  focusLimitSlider.setNumColummns(tfCols);
  focusLimitSlider.setBorder(new EmptyBorder(0,0,0,6));
  c.anchor=GridBagConstraints.LINE_END;
  c.gridx=0;
  add(focusLimitSlider,c);
  c.anchor=GridBagConstraints.LINE_START;
  c.gridx=1;
  add(new JLabel(""String_Node_Str""),c);
  c.gridy++;
  focusLimitRelativeBox=new JCheckBox();
  focusLimitRelativeBox.addActionListener(new ActionListener(){
    @Override public void actionPerformed(    final ActionEvent e){
      renderSettings.setFocusLimitViewRelative(focusLimitRelativeBox.isSelected());
    }
  }
);
  c.anchor=GridBagConstraints.LINE_END;
  c.gridx=0;
  add(focusLimitRelativeBox,c);
  c.anchor=GridBagConstraints.LINE_START;
  c.gridx=1;
  add(new JLabel(""String_Node_Str""),c);
  c.gridy++;
  add(Box.createVerticalStrut(15),c);
  c.gridy++;
  ellipsoidFadeDepth=new BoundedValueDouble(0,1,0.2){
    @Override public void setCurrentValue(    final double value){
      super.setCurrentValue(value);
      renderSettings.setEllipsoidFadeDepth(getCurrentValue());
    }
  }
;
  ellipsoidFadeDepthSlider=new SliderPanelDouble(null,ellipsoidFadeDepth,0.05);
  ellipsoidFadeDepthSlider.setDecimalFormat(""String_Node_Str"");
  ellipsoidFadeDepthSlider.setNumColummns(tfCols);
  ellipsoidFadeDepthSlider.setBorder(new EmptyBorder(0,0,0,6));
  c.anchor=GridBagConstraints.LINE_END;
  c.gridx=0;
  add(ellipsoidFadeDepthSlider,c);
  c.anchor=GridBagConstraints.LINE_START;
  c.gridx=1;
  add(new JLabel(""String_Node_Str""),c);
  c.gridy++;
  pointFadeDepth=new BoundedValueDouble(0,1,0.2){
    @Override public void setCurrentValue(    final double value){
      super.setCurrentValue(value);
      renderSettings.setPointFadeDepth(getCurrentValue());
    }
  }
;
  pointFadeDepthSlider=new SliderPanelDouble(null,pointFadeDepth,0.05);
  pointFadeDepthSlider.setDecimalFormat(""String_Node_Str"");
  pointFadeDepthSlider.setNumColummns(tfCols);
  pointFadeDepthSlider.setBorder(new EmptyBorder(0,0,0,6));
  c.anchor=GridBagConstraints.LINE_END;
  c.gridx=0;
  add(pointFadeDepthSlider,c);
  c.anchor=GridBagConstraints.LINE_START;
  c.gridx=1;
  add(new JLabel(""String_Node_Str""),c);
  update();
}",0.9975106164885048
90961,"@Override public void graphRebuilt(){
  idToTrackSchemeVertex.clear();
  idToTrackSchemeEdge.clear();
  for (  final V v : modelGraph.vertices()) {
    final int id=idmap.getVertexId(v);
    final int timepoint=v.getTimepoint();
    addVertex(tsv).init(id,timepoint);
    idToTrackSchemeVertex.put(id,tsv);
    if (v.incomingEdges().isEmpty())     roots.add(tsv);
  }
  for (  final E e : modelGraph.edges()) {
    final int id=idmap.getEdgeId(e);
    idToTrackSchemeVertex.get(idmap.getVertexId(e.getSource(mv)),tsv);
    idToTrackSchemeVertex.get(idmap.getVertexId(e.getTarget(mv)),tsv2);
    addEdge(tsv,tsv2,tse).init(id);
    idToTrackSchemeEdge.put(id,tse);
  }
}","@Override public void graphRebuilt(){
  idToTrackSchemeVertex.clear();
  idToTrackSchemeEdge.clear();
  roots.clear();
  for (  final V v : modelGraph.vertices()) {
    final int id=idmap.getVertexId(v);
    final int timepoint=v.getTimepoint();
    addVertex(tsv).init(id,timepoint);
    idToTrackSchemeVertex.put(id,tsv);
    if (v.incomingEdges().isEmpty())     roots.add(tsv);
  }
  for (  final E e : modelGraph.edges()) {
    final int id=idmap.getEdgeId(e);
    idToTrackSchemeVertex.get(idmap.getVertexId(e.getSource(mv)),tsv);
    idToTrackSchemeVertex.get(idmap.getVertexId(e.getTarget(mv)),tsv2);
    addEdge(tsv,tsv2,tse).init(id);
    idToTrackSchemeEdge.put(id,tse);
  }
}",0.9874538745387452
90962,"@Override public ScreenTransform concatenate(final ScreenTransform a){
  final double cMinX=a.minX + minX / scaleX;
  final double cMaxX=(screenWidth - 1) / (a.scaleX * scaleX) + cMinX;
  final double cMinY=a.minY + minY / scaleY;
  final double cMaxY=(screenHeight - 1) / (a.scaleY * scaleY) + cMinY;
  return new ScreenTransform(cMinX,cMaxX,cMinY,cMaxY,screenWidth,screenHeight);
}","@Override public ScreenTransform concatenate(final ScreenTransform a){
  final double cMinX=a.minX + minX / a.scaleX;
  final double cMaxX=(screenWidth - 1) / (a.scaleX * scaleX) + cMinX;
  final double cMinY=a.minY + minY / a.scaleY;
  final double cMaxY=(screenHeight - 1) / (a.scaleY * scaleY) + cMinY;
  return new ScreenTransform(cMinX,cMaxX,cMinY,cMaxY,screenWidth,screenHeight);
}",0.9948051948051948
90963,"@Override public ScreenTransform preConcatenate(final ScreenTransform a){
  final double cMinX=minX + a.minX / a.scaleX;
  final double cMaxX=(screenWidth - 1) / (scaleX * a.scaleX) + cMinX;
  final double cMinY=minY + a.minY / a.scaleY;
  final double cMaxY=(screenHeight - 1) / (scaleY * a.scaleY) + cMinY;
  return new ScreenTransform(cMinX,cMaxX,cMinY,cMaxY,screenWidth,screenHeight);
}","@Override public ScreenTransform preConcatenate(final ScreenTransform a){
  final double cMinX=minX + a.minX / scaleX;
  final double cMaxX=(screenWidth - 1) / (scaleX * a.scaleX) + cMinX;
  final double cMinY=minY + a.minY / scaleY;
  final double cMaxY=(screenHeight - 1) / (scaleY * a.scaleY) + cMinY;
  return new ScreenTransform(cMinX,cMaxX,cMinY,cMaxY,screenWidth,screenHeight);
}",0.729381443298969
90964,"/** 
 * Check whether the given   {@link ScreenTransform} covers an area havingwidth greater or equal to the specified  {@code maxSizeY}.
 * @param transform
 * @param maxSizeX
 * @return true, iff {@code transform} covers greater than or equal to{@code maxSizeY}.
 */
public static boolean hasMaxSizeY(final ScreenTransform transform,final double maxSizeY){
  return transform.getMaxY() - transform.getMinY() >= maxSizeY;
}","/** 
 * Check whether the given   {@link ScreenTransform} covers an area havingwidth greater or equal to the specified  {@code maxSizeY}.
 * @param transform
 * @param maxSizeY
 * @return true, iff {@code transform} covers greater than or equal to{@code maxSizeY}.
 */
public static boolean hasMaxSizeY(final ScreenTransform transform,final double maxSizeY){
  return transform.getMaxY() - transform.getMinY() >= maxSizeY;
}",0.9976415094339622
90965,"/** 
 * Check whether the given   {@link ScreenTransform} covers an area havingwidth less or equal to the specified  {@code minSizeY}.
 * @param transform
 * @param minSizeX
 * @return true, iff {@code transform} covers less than or equal to{@code minSizeY}.
 */
public static boolean hasMinSizeY(final ScreenTransform transform,final double minSizeY){
  return transform.getMaxY() - transform.getMinY() <= minSizeY;
}","/** 
 * Check whether the given   {@link ScreenTransform} covers an area havingwidth less or equal to the specified  {@code minSizeY}.
 * @param transform
 * @param minSizeY
 * @return true, iff {@code transform} covers less than or equal to{@code minSizeY}.
 */
public static boolean hasMinSizeY(final ScreenTransform transform,final double minSizeY){
  return transform.getMaxY() - transform.getMinY() <= minSizeY;
}",0.9976076555023924
90966,"/** 
 * Set this transform to linear interpolation   {@code (1 - ratio) * start + ratio * end}.
 */
public void interpolate(final ScreenTransform start,final ScreenTransform end,final double ratio){
  this.minX=(1 - ratio) * start.minX + ratio * end.minX;
  this.maxX=(1 - ratio) * start.maxX + ratio * end.maxX;
  this.minY=(1 - ratio) * start.minY + ratio * end.minY;
  this.maxY=(1 - ratio) * start.maxY + ratio * end.maxY;
  this.screenWidth=(int)((1 - ratio) * start.screenWidth + ratio * end.screenWidth);
  this.screenHeight=(int)((1 - ratio) * start.screenHeight + ratio * end.screenHeight);
  update();
}","/** 
 * Set this transform to linear interpolation   {@code (1 - ratio) * start + ratio * end}.
 */
public void interpolate(final ScreenTransform start,final ScreenTransform end,final double ratio){
  this.minX=(1 - ratio) * start.minX + ratio * end.minX;
  this.maxX=(1 - ratio) * start.maxX + ratio * end.maxX;
  this.minY=(1 - ratio) * start.minY + ratio * end.minY;
  this.maxY=(1 - ratio) * start.maxY + ratio * end.maxY;
  this.screenWidth=(int)Math.round(((1 - ratio) * start.screenWidth + ratio * end.screenWidth));
  this.screenHeight=(int)Math.round(((1 - ratio) * start.screenHeight + ratio * end.screenHeight));
  update();
}",0.9808
90967,"/** 
 * Returns the set of all the vertices in the rectangle with two corners  {@code (lx1, ly1)} and {@code (lx2, ly2)} in layoutcoordinates.
 * @param lx1 the x coordinate of the first corner.
 * @param ly1 the y coordinate of the first corner.
 * @param lx2 the x coordinate of the second corner.
 * @param ly2 the y coordinate of the second corner.
 * @return a new set.
 */
public RefSet<TrackSchemeVertex> getVerticesWithin(final double lx1,final double ly1,final double lx2,final double ly2){
  final int tStart=(int)Math.ceil(Math.min(ly1,ly2));
  final int tEnd=(int)Math.floor(Math.max(ly1,ly2)) + 1;
  final double x1=Math.min(lx1,lx2) - 1;
  final double x2=Math.max(lx1,lx2);
  final RefSet<TrackSchemeVertex> vertexSet=graph.createVertexSet();
  int start=timepoints.binarySearch(tStart);
  if (start < 0)   start=-start - 1;
  int end=timepoints.binarySearch(tEnd);
  if (end < 0)   end=-end - 1;
  for (int tpIndex=start; tpIndex < end; ++tpIndex) {
    final TrackSchemeVertexList vertexList=timepointToOrderedVertices.get(timepoints.get(tpIndex));
    final int left=vertexList.binarySearch(x1) + 1;
    final int right=vertexList.binarySearch(x2,left,vertexList.size());
    vertexSet.addAll(vertexList.subList(left,right + 1));
  }
  return vertexSet;
}","/** 
 * Returns the set of all the vertices in the rectangle with two corners  {@code (lx1, ly1)} and {@code (lx2, ly2)} in layoutcoordinates.
 * @param lx1 the x coordinate of the first corner.
 * @param ly1 the y coordinate of the first corner.
 * @param lx2 the x coordinate of the second corner.
 * @param ly2 the y coordinate of the second corner.
 * @return a new set.
 */
public RefSet<TrackSchemeVertex> getVerticesWithin(final double lx1,final double ly1,final double lx2,final double ly2){
  final int tStart=(int)Math.ceil(Math.min(ly1,ly2));
  final int tEnd=(int)Math.floor(Math.max(ly1,ly2)) + 1;
  final double x1=Math.min(lx1,lx2);
  final double x2=Math.max(lx1,lx2);
  final RefSet<TrackSchemeVertex> vertexSet=graph.createVertexSet();
  int start=timepoints.binarySearch(tStart);
  if (start < 0)   start=-start - 1;
  int end=timepoints.binarySearch(tEnd);
  if (end < 0)   end=-end - 1;
  for (int tpIndex=start; tpIndex < end; ++tpIndex) {
    final TrackSchemeVertexList vertexList=timepointToOrderedVertices.get(timepoints.get(tpIndex));
    final int left=vertexList.binarySearch(x1) + 1;
    final int right=vertexList.binarySearch(x2,left,vertexList.size());
    vertexSet.addAll(vertexList.subList(left,right + 1));
  }
  return vertexSet;
}",0.998426435877262
90968,"/** 
 * Returns the set of all the vertices in the rectangle with two corners  {@code (lx1, ly1)} and {@code (lx2, ly2)} in layoutcoordinates.
 * @param lx1 the x coordinate of the first corner.
 * @param ly1 the y coordinate of the first corner.
 * @param lx2 the x coordinate of the second corner.
 * @param ly2 the y coordinate of the second corner.
 * @return a new set.
 */
public RefSet<TrackSchemeVertex> getVerticesWithin(final double lx1,final double ly1,final double lx2,final double ly2){
  final int tStart=(int)Math.ceil(Math.min(ly1,ly2));
  final int tEnd=(int)Math.floor(Math.max(ly1,ly2)) + 1;
  final double x1=Math.min(lx1,lx2) - 1;
  final double x2=Math.max(lx1,lx2);
  final RefSet<TrackSchemeVertex> vertexSet=graph.createVertexSet();
  int start=timepoints.binarySearch(tStart);
  if (start < 0)   start=-start - 1;
  int end=timepoints.binarySearch(tEnd);
  if (end < 0)   end=-end - 1;
  for (int tpIndex=start; tpIndex < end; ++tpIndex) {
    final TrackSchemeVertexList vertexList=timepointToOrderedVertices.get(timepoints.get(tpIndex));
    final int left=vertexList.binarySearch(x1) + 1;
    final int right=vertexList.binarySearch(x2,left,vertexList.size());
    vertexSet.addAll(vertexList.subList(left,right + 1));
  }
  return vertexSet;
}","/** 
 * Returns the set of all the vertices in the rectangle with two corners  {@code (lx1, ly1)} and {@code (lx2, ly2)} in layoutcoordinates.
 * @param lx1 the x coordinate of the first corner.
 * @param ly1 the y coordinate of the first corner.
 * @param lx2 the x coordinate of the second corner.
 * @param ly2 the y coordinate of the second corner.
 * @return a new set.
 */
public RefSet<TrackSchemeVertex> getVerticesWithin(final double lx1,final double ly1,final double lx2,final double ly2){
  final int tStart=(int)Math.ceil(Math.min(ly1,ly2));
  final int tEnd=(int)Math.floor(Math.max(ly1,ly2)) + 1;
  final double x1=Math.min(lx1,lx2);
  final double x2=Math.max(lx1,lx2);
  final RefSet<TrackSchemeVertex> vertexSet=graph.createVertexSet();
  int start=timepoints.binarySearch(tStart);
  if (start < 0)   start=-start - 1;
  int end=timepoints.binarySearch(tEnd);
  if (end < 0)   end=-end - 1;
  for (int tpIndex=start; tpIndex < end; ++tpIndex) {
    final TrackSchemeVertexList vertexList=timepointToOrderedVertices.get(timepoints.get(tpIndex));
    final int left=vertexList.binarySearch(x1) + 1;
    final int right=vertexList.binarySearch(x2,left,vertexList.size());
    vertexSet.addAll(vertexList.subList(left,right + 1));
  }
  return vertexSet;
}",0.998426435877262
90969,"/** 
 * Retrieves and removes the head of this queue, or returns <code>null</code> if this queue is empty.
 * @return the head of this queue, or <code>null</code> if this queue isempty
 */
public O poll(final O obj){
  if (queue.isEmpty()) {
    return null;
  }
  return element(obj);
}","/** 
 * Retrieves and removes the head of this queue, or returns  {@code null} if this queue is empty.
 * @return the head of this queue, or {@code null} if this queue isempty
 */
public O poll(final O obj){
  if (queue.isEmpty()) {
    return null;
  }
  return element(obj);
}",0.9238938053097344
90970,"/** 
 * Retrieves, but does not remove the head of this queue.
 * @param obj the pool object ref to update with the content of the top item.
 * @return the given object, updated to be the item at the top of thisqueue, or <code>null</code> if this queue is empty.
 */
public O peek(final O obj){
  if (queue.isEmpty()) {
    return null;
  }
  final int index=queue.get(0);
  pool.getByInternalPoolIndex(index,obj);
  return obj;
}","/** 
 * Retrieves, but does not remove the head of this queue.
 * @param obj the pool object ref to update with the content of the top item.
 * @return the given object, updated to be the item at the top of thisqueue, or  {@code null} if this queue is empty.
 */
public O peek(final O obj){
  if (queue.isEmpty()) {
    return null;
  }
  final int index=queue.get(0);
  pool.getByInternalPoolIndex(index,obj);
  return obj;
}",0.9742990654205608
90971,"/** 
 * Returns the connected component with the specified id, or <code>null</code> if the specified id does not exist.
 * @param id the id of the connected component.
 * @return the connected component.
 */
public RefSet<V> get(final int id){
  return ccMap.get(id);
}","/** 
 * Returns the connected component with the specified id, or  {@code null} if the specified id does not exist.
 * @param id the id of the connected component.
 * @return the connected component.
 */
public RefSet<V> get(final int id){
  return ccMap.get(id);
}",0.9438202247191012
90972,"/** 
 * Returns a new array containing the ids of the connected components of the graph.
 * @return a new <code>int</code> array.
 */
public int[] ids(){
  return ccMap.keys();
}","/** 
 * Returns a new array containing the ids of the connected components of the graph.
 * @return a new {@code int} array.
 */
public int[] ids(){
  return ccMap.keys();
}",0.9629629629629628
90973,"/** 
 * Finds the path between the specified vertices. <p> The success and result of this search strongly depends on whether this search is directed or undirected.
 * @param from the vertex to start search from.
 * @param to the vertex to reach.
 * @return a new {@link RefList}, containing the path found <b>in reverse order</b> (<code>to → from</code>). Returns <code>null</code> if a path cannot be found between the specified vertices.
 */
public RefList<V> findPath(final V from,final V to){
  final BreadthFirstSearch<V,E> search=new BreadthFirstSearch<V,E>(graph,directed);
  final VertexFinderListener vfl=new VertexFinderListener(to);
  search.setTraversalListener(vfl);
  search.start(from);
  if (search.wasAborted()) {
    V tmp=vertexRef();
    final RefList<V> path=createVertexList(search.depthOf(to) + 1);
    tmp=assign(to,tmp);
    path.add(tmp);
    while (!tmp.equals(from)) {
      tmp=assign(search.parent(tmp),tmp);
      path.add(tmp);
    }
    releaseRef(tmp);
    return path;
  }
 else {
    return null;
  }
}","/** 
 * Finds the path between the specified vertices. <p> The success and result of this search strongly depends on whether this search is directed or undirected.
 * @param from the vertex to start search from.
 * @param to the vertex to reach.
 * @return a new {@link RefList}, containing the path found <b>in reverse order</b> (  {@code to → from}). Returns   {@code null} ifa path cannot be found between the specified vertices.
 */
public RefList<V> findPath(final V from,final V to){
  final BreadthFirstSearch<V,E> search=new BreadthFirstSearch<V,E>(graph,directed);
  final VertexFinderListener vfl=new VertexFinderListener(to);
  search.setTraversalListener(vfl);
  search.start(from);
  if (search.wasAborted()) {
    V tmp=vertexRef();
    final RefList<V> path=createVertexList(search.depthOf(to) + 1);
    tmp=assign(to,tmp);
    path.add(tmp);
    while (!tmp.equals(from)) {
      tmp=assign(search.parent(tmp),tmp);
      path.add(tmp);
    }
    releaseRef(tmp);
    return path;
  }
 else {
    return null;
  }
}",0.9705171580473658
90974,"/** 
 * Returns <code>true</code> if the graph iterated has a cycle.
 * @return <code>true</code> if the graph iterated is not a directed acyclicgraph.
 */
public boolean hasFailed(){
  return failed;
}","/** 
 * Returns   {@code true} if the graph iterated has a cycle.
 * @return {@code true} if the graph iterated is not a directed acyclicgraph.
 */
public boolean hasFailed(){
  return failed;
}",0.9292929292929292
90975,"/** 
 * Creates an object reference that can be used for processing with this map. Depending on concrete implementation, the object return can be <code>null</code>.
 * @return a new object empty reference.
 */
public V createRef();","/** 
 * Creates an object reference that can be used for processing with this map. Depending on concrete implementation, the object return can be  {@code null}.
 * @return a new object empty reference.
 */
public V createRef();",0.9519650655021834
90976,"/** 
 * Generates an object reference that can be used for retrieval. Depending on concrete implementation, this object returned can be <code>null.</code>
 * @return a new, uninitialized, reference object.
 */
public O createRef();","/** 
 * Generates an object reference that can be used for retrieval. Depending on concrete implementation, this object returned can be  {@code null.}
 * @return a new, uninitialized, reference object.
 */
public O createRef();",0.9519650655021834
90977,"/** 
 * Executes <tt>procedure</tt> for each key/value entry in the map.
 * @param procedure a <code>TOIntIntProcedure</code> value.
 * @param ref an object reference that can be used for retrieval. Depending on concrete implementation, this object can be cleared, ignored or re-used.
 * @return <code>false</code> if the loop over the entries terminatedbecause the procedure returned false for some entry.
 */
public boolean forEachEntry(TObjectIntProcedure<? super K> procedure,K ref);","/** 
 * Executes <tt>procedure</tt> for each key/value entry in the map.
 * @param procedure a  {@code TOIntIntProcedure} value.
 * @param ref an object reference that can be used for retrieval. Depending on concrete implementation, this object can be cleared, ignored or re-used.
 * @return {@code false} if the loop over the entries terminatedbecause the procedure returned false for some entry.
 */
public boolean forEachEntry(TObjectIntProcedure<? super K> procedure,K ref);",0.945077720207254
90978,"/** 
 * Executes <tt>procedure</tt> for each key in the map.
 * @param procedure a <code>TIntProcedure</code> value.
 * @param ref an object reference that can be used for retrieval. Depending on concrete implementation, this object can be cleared, ignored or re-used.
 * @return <code>false</code> if the loop over the keys terminated becausethe procedure returned false for some key.
 */
public boolean forEachKey(TObjectProcedure<? super K> procedure,K ref);","/** 
 * Executes <tt>procedure</tt> for each key in the map.
 * @param procedure a  {@code TIntProcedure} value.
 * @param ref an object reference that can be used for retrieval. Depending on concrete implementation, this object can be cleared, ignored or re-used.
 * @return {@code false} if the loop over the keys terminated becausethe procedure returned false for some key.
 */
public boolean forEachKey(TObjectProcedure<? super K> procedure,K ref);",0.9419496166484118
90979,"/** 
 * Retains only those entries in the map for which the procedure returns a true value.
 * @param procedure determines which entries to keep.
 * @param ref an object reference that can be used for retrieval. Depending on concrete implementation, this object can be cleared, ignored or re-used.
 * @return <code>true</code> if the map was modified.
 */
public boolean retainEntries(TObjectIntProcedure<? super K> procedure,K ref);","/** 
 * Retains only those entries in the map for which the procedure returns a true value.
 * @param procedure determines which entries to keep.
 * @param ref an object reference that can be used for retrieval. Depending on concrete implementation, this object can be cleared, ignored or re-used.
 * @return {@code true} if the map was modified.
 */
public boolean retainEntries(TObjectIntProcedure<? super K> procedure,K ref);",0.9663182346109176
90980,"/** 
 * Creates an object reference that can be used for processing with this map. Depending on concrete implementation, the object return can be <code>null</code>.
 * @return a new object empty reference.
 */
public K createRef();","/** 
 * Creates an object reference that can be used for processing with this map. Depending on concrete implementation, the object return can be  {@code null}.
 * @return a new object empty reference.
 */
public K createRef();",0.9519650655021834
90981,"@Test public void testPutAll(){
  final PoolObjectPoolObjectMap<TestVertex,TestVertex> extraMap=new PoolObjectPoolObjectMap<TestVertex,TestVertex>(graph.vertexPool,graph.vertexPool);
  extraMap.put(Ak,Bk);
  extraMap.put(Bk,Ak);
  final int initSize=map.size();
  map.putAll(extraMap);
  assertEquals(""String_Node_Str"",initSize + 1,map.size());
  assertEquals(""String_Node_Str"",Bk.getInternalPoolIndex(),map.get(Ak).getInternalPoolIndex());
  assertEquals(""String_Node_Str"",Ak.getInternalPoolIndex(),map.get(Bk).getInternalPoolIndex());
}","@Test public void testPutAll(){
  final PoolObjectPoolObjectMap<TestVertex,TestVertex> extraMap=new PoolObjectPoolObjectMap<TestVertex,TestVertex>(graph.vertexPool,graph.vertexPool);
  extraMap.put(Ak,Bk);
  extraMap.put(Bk,Ak);
  final int initSize=map.size();
  map.putAll(extraMap);
  assertEquals(""String_Node_Str"",initSize + 1,map.size());
  assertEquals(""String_Node_Str"",Bk,map.get(Ak));
  assertEquals(""String_Node_Str"",Ak,map.get(Bk));
}",0.9065040650406504
90982,"/** 
 * Set entities for painting into the specified double-buffered  {@link AbstractTrackSchemeOverlay}. (This swaps  {@link #screenEntities} with pending entities from the overlay.)
 */
public void setPaintEntities(final AbstractTrackSchemeOverlay overlay){
  final ScreenEntities tmp=overlay.setScreenEntities(screenEntities);
  if (tmp == null)   screenEntities=new ScreenEntities(graph,capacity);
 else   screenEntities=tmp;
  screenEntities.clear();
}","/** 
 * Set entities for painting into the specified double-buffered  {@link AbstractTrackSchemeOverlay}. (This swaps  {@link #screenEntities} with pending entities from the overlay.)
 */
public void setPaintEntities(final AbstractTrackSchemeOverlay overlay){
  if (lastComputedScreenEntities == screenEntities) {
    final ScreenEntities tmp=overlay.setScreenEntities(screenEntities);
    if (tmp == null) {
      screenEntities=new ScreenEntities(graph,capacity);
    }
 else     screenEntities=tmp;
    screenEntities.clear();
  }
}",0.9133064516129032
90983,"/** 
 * Set entities for painting into the specified double-buffered  {@link AbstractTrackSchemeOverlay}. (This swaps  {@link #screenEntities} with pending entities from the overlay.)
 */
public void setPaintEntities(final AbstractTrackSchemeOverlay overlay){
  final ScreenEntities tmp=overlay.setScreenEntities(screenEntities);
  if (tmp == null)   screenEntities=new ScreenEntities(graph,capacity);
 else   screenEntities=tmp;
  screenEntities.clear();
}","/** 
 * Set entities for painting into the specified double-buffered  {@link AbstractTrackSchemeOverlay}. (This swaps  {@link #screenEntities} with pending entities from the overlay.)
 */
public void setPaintEntities(final AbstractTrackSchemeOverlay overlay){
  if (lastComputedScreenEntities == screenEntities) {
    final ScreenEntities tmp=overlay.setScreenEntities(screenEntities);
    if (tmp == null) {
      screenEntities=new ScreenEntities(graph,capacity);
    }
 else     screenEntities=tmp;
    screenEntities.clear();
  }
}",0.9133064516129032
90984,"/** 
 * Returns the set of all the vertices in the rectangle with two corners <code>(lx1, ly1)</code> and <code>(lx2, ly2)</code> in layout coordinates.
 * @param lx1 the x coordinate of the first corner.
 * @param ly1 the y coordinate of the first corner.
 * @param lx2 the x coordinate of the second corner.
 * @param ly2 the y coordinate of the second corner.
 * @return a new set.
 */
public RefSet<TrackSchemeVertex> getVerticesWithin(final double lx1,final double ly1,final double lx2,final double ly2){
  final int tStart=Math.max(0,(int)Math.ceil(Math.min(ly1,ly2)));
  final int tEnd=(int)Math.floor(Math.max(ly1,ly2));
  final double x1=Math.min(lx1,lx2);
  final double x2=Math.max(lx1,lx2);
  TrackSchemeVertex v=graph.vertexRef();
  final RefSet<TrackSchemeVertex> vertexSet=graph.createVertexSet();
  final TIntIterator tpIter=timepoints.subList(tStart,tEnd + 1).iterator();
  while (tpIter.hasNext()) {
    final TrackSchemeVertexList vertexList=timepointToOrderedVertices.get(tpIter.next());
    int left=vertexList.binarySearch(x1) + 1;
    if (left < 0)     left=0;
    int right=vertexList.binarySearch(x2,left,vertexList.size());
    if (right >= vertexList.size())     right=vertexList.size() - 1;
    for (int i=left; i <= right; i++) {
      v=vertexList.get(i,v);
      vertexSet.add(v);
    }
  }
  graph.releaseRef(v);
  return vertexSet;
}","/** 
 * Returns the set of all the vertices in the rectangle with two corners <code>(lx1, ly1)</code> and <code>(lx2, ly2)</code> in layout coordinates.
 * @param lx1 the x coordinate of the first corner.
 * @param ly1 the y coordinate of the first corner.
 * @param lx2 the x coordinate of the second corner.
 * @param ly2 the y coordinate of the second corner.
 * @return a new set.
 */
public RefSet<TrackSchemeVertex> getVerticesWithin(final double lx1,final double ly1,final double lx2,final double ly2){
  final int tStart=Math.max(0,(int)Math.ceil(Math.min(ly1,ly2)));
  final int tEnd=(int)Math.floor(Math.max(ly1,ly2));
  final double x1=Math.min(lx1,lx2);
  final double x2=Math.max(lx1,lx2);
  TrackSchemeVertex v=graph.vertexRef();
  final RefSet<TrackSchemeVertex> vertexSet=graph.createVertexSet();
  int iStart=timepoints.binarySearch(tStart);
  if (iStart < 0)   iStart=-(1 + iStart);
  int iEnd=timepoints.binarySearch(tEnd);
  if (iEnd < 0)   iEnd=-(1 + iEnd);
  final TIntIterator tpIter=timepoints.subList(iStart,iEnd + 1).iterator();
  while (tpIter.hasNext()) {
    final TrackSchemeVertexList vertexList=timepointToOrderedVertices.get(tpIter.next());
    int left=vertexList.binarySearch(x1) + 1;
    if (left < 0)     left=0;
    int right=vertexList.binarySearch(x2,left,vertexList.size());
    if (right >= vertexList.size())     right=vertexList.size() - 1;
    for (int i=left; i <= right; i++) {
      v=vertexList.get(i,v);
      vertexSet.add(v);
    }
  }
  graph.releaseRef(v);
  return vertexSet;
}",0.9413388543823328
90985,"@Override public void edgeAdded(final E edge){
  final int id=idmap.getEdgeId(edge);
  idToTrackSchemeVertex.get(idmap.getVertexId(edge.getSource(mv)),tsv);
  idToTrackSchemeVertex.get(idmap.getVertexId(edge.getTarget(mv)),tsv2);
  if (tsv2.incomingEdges().isEmpty())   roots.remove(tsv2);
  addEdge(tsv,tsv2,tse);
  idToTrackSchemeEdge.put(id,tse);
}","@Override public void edgeAdded(final E edge){
  final int id=idmap.getEdgeId(edge);
  idToTrackSchemeVertex.get(idmap.getVertexId(edge.getSource(mv)),tsv);
  idToTrackSchemeVertex.get(idmap.getVertexId(edge.getTarget(mv)),tsv2);
  if (tsv2.incomingEdges().isEmpty())   roots.remove(tsv2);
  addEdge(tsv,tsv2,tse).init(id);
  idToTrackSchemeEdge.put(id,tse);
}",0.9873417721518988
90986,"@Override public void graphRebuilt(){
  idToTrackSchemeVertex.clear();
  idToTrackSchemeEdge.clear();
  for (  final V v : modelGraph.vertices()) {
    final int id=idmap.getVertexId(v);
    final int timepoint=v.getTimepoint();
    addVertex(tsv).init(id,timepoint);
    idToTrackSchemeVertex.put(id,tsv);
    if (v.incomingEdges().isEmpty())     roots.add(tsv);
  }
  for (  final E e : modelGraph.edges()) {
    final int id=idmap.getEdgeId(e);
    idToTrackSchemeVertex.get(idmap.getVertexId(e.getSource(mv)),tsv);
    idToTrackSchemeVertex.get(idmap.getVertexId(e.getTarget(mv)),tsv2);
    addEdge(tsv,tsv2,tse);
    idToTrackSchemeEdge.put(id,tse);
  }
}","@Override public void graphRebuilt(){
  idToTrackSchemeVertex.clear();
  idToTrackSchemeEdge.clear();
  for (  final V v : modelGraph.vertices()) {
    final int id=idmap.getVertexId(v);
    final int timepoint=v.getTimepoint();
    addVertex(tsv).init(id,timepoint);
    idToTrackSchemeVertex.put(id,tsv);
    if (v.incomingEdges().isEmpty())     roots.add(tsv);
  }
  for (  final E e : modelGraph.edges()) {
    final int id=idmap.getEdgeId(e);
    idToTrackSchemeVertex.get(idmap.getVertexId(e.getSource(mv)),tsv);
    idToTrackSchemeVertex.get(idmap.getVertexId(e.getTarget(mv)),tsv2);
    addEdge(tsv,tsv2,tse).init(id);
    idToTrackSchemeEdge.put(id,tse);
  }
}",0.9932279909706546
90987,"/** 
 * Returns the internal pool index of the   {@link TrackSchemeVertex}currently painted on this display at screen coordinates specified by  {@code x} and {@code y}. <p> This method exists to facilitate writing mouse handlers.
 * @param x the x screen coordinate
 * @param y the y screen coordinate
 * @return the internal pool index of the {@link TrackSchemeVertex} at{@code (x, y)}, or -1 if there is no vertex at this position.
 */
public int getVertexIdAt(final int x,final int y){
  final ScreenEntities ent=getScreenEntities();
  if (ent != null) {
    final RealPoint pos=new RealPoint(x,y);
    for (    final ScreenVertex v : ent.getVertices())     if (isInsidePaintedVertex(pos,v))     return v.getTrackSchemeVertexId();
  }
  return -1;
}","/** 
 * Returns the internal pool index of the   {@link TrackSchemeVertex}currently painted on this display at screen coordinates specified by  {@code x} and {@code y}. <p> This method exists to facilitate writing mouse handlers.
 * @param x the x screen coordinate
 * @param y the y screen coordinate
 * @return the internal pool index of the {@link TrackSchemeVertex} at{@code (x, y)}, or -1 if there is no vertex at this position.
 */
public int getVertexIdAt(final int x,final int y){
synchronized (entities) {
    final RealPoint pos=new RealPoint(x,y);
    for (    final ScreenVertex v : entities.getVertices())     if (isInsidePaintedVertex(pos,v))     return v.getTrackSchemeVertexId();
    return -1;
  }
}",0.8528610354223434
90988,"@Override public void drawOverlays(final Graphics g){
  final Graphics2D g2=(Graphics2D)g;
  final ScreenEntities ent=getScreenEntities();
  if (ent != null) {
    highlightedVertexId=highlight.getHighlightedVertexId();
    paintBackground(g2,ent);
    final RefList<ScreenEdge> edges=ent.getEdges();
    final RefList<ScreenVertex> vertices=ent.getVertices();
    final RefList<ScreenVertexRange> vertexRanges=ent.getRanges();
    final ScreenVertex vt=vertices.createRef();
    final ScreenVertex vs=vertices.createRef();
    beforeDrawEdge(g2);
    for (    final ScreenEdge edge : edges) {
      vertices.get(edge.getSourceScreenVertexIndex(),vs);
      vertices.get(edge.getTargetScreenVertexIndex(),vt);
      drawEdge(g2,edge,vs,vt);
    }
    beforeDrawVertex(g2);
    for (    final ScreenVertex vertex : vertices) {
      drawVertex(g2,vertex);
    }
    beforeDrawVertexRange(g2);
    for (    final ScreenVertexRange range : vertexRanges) {
      drawVertexRange(g2,range);
    }
    vertices.releaseRef(vs);
    vertices.releaseRef(vt);
  }
}","@Override public void drawOverlays(final Graphics g){
  final Graphics2D g2=(Graphics2D)g;
  swapScreenEntities();
  highlightedVertexId=highlight.getHighlightedVertexId();
  paintBackground(g2,entities);
  final RefList<ScreenEdge> edges=entities.getEdges();
  final RefList<ScreenVertex> vertices=entities.getVertices();
  final RefList<ScreenVertexRange> vertexRanges=entities.getRanges();
  final ScreenVertex vt=vertices.createRef();
  final ScreenVertex vs=vertices.createRef();
  beforeDrawEdge(g2);
  for (  final ScreenEdge edge : edges) {
    vertices.get(edge.getSourceScreenVertexIndex(),vs);
    vertices.get(edge.getTargetScreenVertexIndex(),vt);
    drawEdge(g2,edge,vs,vt);
  }
  beforeDrawVertex(g2);
  for (  final ScreenVertex vertex : vertices) {
    drawVertex(g2,vertex);
  }
  beforeDrawVertexRange(g2);
  for (  final ScreenVertexRange range : vertexRanges) {
    drawVertexRange(g2,range);
  }
  vertices.releaseRef(vs);
  vertices.releaseRef(vt);
}",0.8102513553474618
90989,"public AbstractTrackSchemeOverlay(final TrackSchemeHighlight highlight,final TrackSchemeOptions options){
  this.highlight=highlight;
  width=options.values.getWidth();
  height=options.values.getHeight();
  entities=null;
}","public AbstractTrackSchemeOverlay(final TrackSchemeGraph<?,?> graph,final TrackSchemeHighlight highlight,final TrackSchemeOptions options){
  this.highlight=highlight;
  width=options.values.getWidth();
  height=options.values.getHeight();
  entities=new ScreenEntities(graph);
}",0.8031809145129225
90990,"public int getEdgeIdAt(final int x,final int y,final double tolerance){
  final ScreenEntities ent=getScreenEntities();
  if (ent != null) {
    final RealPoint pos=new RealPoint(x,y);
    final RefList<ScreenVertex> vertices=ent.getVertices();
    final ScreenVertex vt=vertices.createRef();
    final ScreenVertex vs=vertices.createRef();
    for (    final ScreenEdge e : ent.getEdges()) {
      vertices.get(e.getSourceScreenVertexIndex(),vs);
      vertices.get(e.getTargetScreenVertexIndex(),vt);
      if (distanceToPaintedEdge(pos,e,vs,vt) <= tolerance) {
        return e.getTrackSchemeEdgeId();
      }
    }
  }
  return -1;
}","public int getEdgeIdAt(final int x,final int y,final double tolerance){
synchronized (entities) {
    final RealPoint pos=new RealPoint(x,y);
    final RefList<ScreenVertex> vertices=entities.getVertices();
    final ScreenVertex vt=vertices.createRef();
    final ScreenVertex vs=vertices.createRef();
    for (    final ScreenEdge e : entities.getEdges()) {
      vertices.get(e.getSourceScreenVertexIndex(),vs);
      vertices.get(e.getTargetScreenVertexIndex(),vt);
      if (distanceToPaintedEdge(pos,e,vs,vt) <= tolerance) {
        return e.getTrackSchemeEdgeId();
      }
    }
  }
  return -1;
}",0.5753424657534246
90991,"public TrackSchemePanel(final TrackSchemeGraph<?,?> graph,final TrackSchemeHighlight highlight,final TrackSchemeSelection selection,final TrackSchemeOptions optional){
  super(new BorderLayout(),false);
  this.graph=graph;
  this.selection=selection;
  options=optional.values;
  graph.addGraphChangeListener(this);
  final int w=options.getWidth();
  final int h=options.getHeight();
  display=new InteractiveDisplayCanvasComponent<ScreenTransform>(w,h,options.getTransformEventHandlerFactory());
  display.addTransformListener(this);
  highlight.addHighlightListener(this);
  selection.addSelectionListener(this);
  graphOverlay=new DefaultTrackSchemeOverlay(highlight,optional);
  display.addOverlayRenderer(graphOverlay);
  display.addOverlayRenderer(new OverlayRenderer(){
    @Override public void setCanvasSize(    final int width,    final int height){
    }
    @Override public void drawOverlays(    final Graphics g){
      checkAnimate();
    }
  }
);
  screenTransform=new ScreenTransform();
  layout=new LineageTreeLayout(graph);
  entityAnimator=new ScreenEntityAnimator();
  painterThread=new PainterThread(this);
  flags=new Flags();
  display.addMouseMotionListener(new MouseOverListener(graphOverlay,highlight));
  final MouseSelectionHandler mouseSelectionHandler=new MouseSelectionHandler(graphOverlay,selection,display);
  display.addHandler(mouseSelectionHandler);
  display.addOverlayRenderer(mouseSelectionHandler);
  xScrollBar=new JScrollBar(JScrollBar.HORIZONTAL);
  yScrollBar=new JScrollBar(JScrollBar.VERTICAL);
  xScrollBar.addAdjustmentListener(new AdjustmentListener(){
    @Override public void adjustmentValueChanged(    final AdjustmentEvent e){
      if (ignoreScrollBarChanges)       return;
      final double s=xScrollBar.getValue() / xScrollScale;
synchronized (screenTransform) {
        screenTransform.shiftLayoutX(s - screenTransform.getMinX());
        display.getTransformEventHandler().setTransform(screenTransform);
      }
      flags.setTransformChanged();
      painterThread.requestRepaint();
    }
  }
);
  yScrollBar.addAdjustmentListener(new AdjustmentListener(){
    @Override public void adjustmentValueChanged(    final AdjustmentEvent e){
      if (ignoreScrollBarChanges)       return;
      final double s=yScrollBar.getValue() / yScrollScale;
synchronized (screenTransform) {
        screenTransform.shiftLayoutY(s - screenTransform.getMinY());
        display.getTransformEventHandler().setTransform(screenTransform);
      }
      flags.setTransformChanged();
      painterThread.requestRepaint();
    }
  }
);
  add(display,BorderLayout.CENTER);
  add(yScrollBar,BorderLayout.EAST);
  final JPanel xScrollPanel=new JPanel(new BorderLayout());
  xScrollPanel.add(xScrollBar,BorderLayout.CENTER);
  final int space=(Integer)UIManager.getDefaults().get(""String_Node_Str"");
  xScrollPanel.add(Box.createRigidArea(new Dimension(space,0)),BorderLayout.EAST);
  add(xScrollPanel,BorderLayout.SOUTH);
  painterThread.start();
}","public TrackSchemePanel(final TrackSchemeGraph<?,?> graph,final TrackSchemeHighlight highlight,final TrackSchemeSelection selection,final TrackSchemeOptions optional){
  super(new BorderLayout(),false);
  this.graph=graph;
  this.selection=selection;
  options=optional.values;
  graph.addGraphChangeListener(this);
  final int w=options.getWidth();
  final int h=options.getHeight();
  display=new InteractiveDisplayCanvasComponent<ScreenTransform>(w,h,options.getTransformEventHandlerFactory());
  display.addTransformListener(this);
  highlight.addHighlightListener(this);
  selection.addSelectionListener(this);
  graphOverlay=new DefaultTrackSchemeOverlay(graph,highlight,optional);
  display.addOverlayRenderer(graphOverlay);
  display.addOverlayRenderer(new OverlayRenderer(){
    @Override public void setCanvasSize(    final int width,    final int height){
    }
    @Override public void drawOverlays(    final Graphics g){
      checkAnimate();
    }
  }
);
  screenTransform=new ScreenTransform();
  layout=new LineageTreeLayout(graph);
  entityAnimator=new ScreenEntityAnimator();
  painterThread=new PainterThread(this);
  flags=new Flags();
  display.addMouseMotionListener(new MouseOverListener(graphOverlay,highlight));
  final MouseSelectionHandler mouseSelectionHandler=new MouseSelectionHandler(graphOverlay,selection,display);
  display.addHandler(mouseSelectionHandler);
  display.addOverlayRenderer(mouseSelectionHandler);
  xScrollBar=new JScrollBar(JScrollBar.HORIZONTAL);
  yScrollBar=new JScrollBar(JScrollBar.VERTICAL);
  xScrollBar.addAdjustmentListener(new AdjustmentListener(){
    @Override public void adjustmentValueChanged(    final AdjustmentEvent e){
      if (ignoreScrollBarChanges)       return;
      final double s=xScrollBar.getValue() / xScrollScale;
synchronized (screenTransform) {
        screenTransform.shiftLayoutX(s - screenTransform.getMinX());
        display.getTransformEventHandler().setTransform(screenTransform);
      }
      flags.setTransformChanged();
      painterThread.requestRepaint();
    }
  }
);
  yScrollBar.addAdjustmentListener(new AdjustmentListener(){
    @Override public void adjustmentValueChanged(    final AdjustmentEvent e){
      if (ignoreScrollBarChanges)       return;
      final double s=yScrollBar.getValue() / yScrollScale;
synchronized (screenTransform) {
        screenTransform.shiftLayoutY(s - screenTransform.getMinY());
        display.getTransformEventHandler().setTransform(screenTransform);
      }
      flags.setTransformChanged();
      painterThread.requestRepaint();
    }
  }
);
  add(display,BorderLayout.CENTER);
  add(yScrollBar,BorderLayout.EAST);
  final JPanel xScrollPanel=new JPanel(new BorderLayout());
  xScrollPanel.add(xScrollBar,BorderLayout.CENTER);
  final int space=(Integer)UIManager.getDefaults().get(""String_Node_Str"");
  xScrollPanel.add(Box.createRigidArea(new Dimension(space,0)),BorderLayout.EAST);
  add(xScrollPanel,BorderLayout.SOUTH);
  painterThread.start();
}",0.9989963198394112
90992,"public DefaultTrackSchemeOverlay(final TrackSchemeHighlight highlight,final TrackSchemeOptions options){
  super(highlight,options);
}","public DefaultTrackSchemeOverlay(final TrackSchemeGraph<?,?> graph,final TrackSchemeHighlight highlight,final TrackSchemeOptions options){
  super(graph,highlight,options);
}",0.8701298701298701
90993,"@Override public void mouseWheelMoved(final MouseWheelEvent e){
  final int x=e.getX();
  final int y=e.getY();
  final V ref=graph.vertexRef();
  final V v=graphOverlay.getVertexAt(x,y,ref);
  graph.releaseRef(ref);
  highlight.highlightVertex(v);
}","@Override public void mouseWheelMoved(final MouseWheelEvent e){
  final int x=e.getX();
  final int y=e.getY();
  final V ref=graph.vertexRef();
  final V v=graphOverlay.getVertexAt(x,y,ref);
  highlight.highlightVertex(v);
  graph.releaseRef(ref);
}",0.872
90994,"@Override public void mouseMoved(final MouseEvent e){
  final int x=e.getX();
  final int y=e.getY();
  final V ref=graph.vertexRef();
  final V v=graphOverlay.getVertexAt(x,y,ref);
  graph.releaseRef(ref);
  highlight.highlightVertex(v);
}","@Override public void mouseMoved(final MouseEvent e){
  final int x=e.getX();
  final int y=e.getY();
  final V ref=graph.vertexRef();
  final V v=graphOverlay.getVertexAt(x,y,ref);
  highlight.highlightVertex(v);
  graph.releaseRef(ref);
}",0.8666666666666667
90995,"@Override public void search(final RealLocalizable pos){
  bestSquDistance=Double.MAX_VALUE;
  bestVertexIndex=-1;
  search.search(pos);
  if (search.get() != null) {
    bestSquDistance=search.getSquareDistance();
    bestVertexIndex=search.get().getInternalPoolIndex();
  }
  final double[] p=new double[n];
  for (  final O v : added) {
    double sum=0;
    for (int d=0; d < n; ++d) {
      final double diff=v.getDoublePosition(d) - p[d];
      sum+=diff * diff;
    }
    if (sum < bestSquDistance) {
      bestSquDistance=sum;
      bestVertexIndex=v.getInternalPoolIndex();
    }
  }
  if (bestVertexIndex >= 0)   objPool.getByInternalPoolIndex(bestVertexIndex,bestVertex);
}","@Override public void search(final RealLocalizable pos){
  bestSquDistance=Double.MAX_VALUE;
  bestVertexIndex=-1;
  search.search(pos);
  if (search.get() != null) {
    bestSquDistance=search.getSquareDistance();
    bestVertexIndex=search.get().getInternalPoolIndex();
  }
  final double[] p=new double[n];
  pos.localize(p);
  for (  final O v : added) {
    double sum=0;
    for (int d=0; d < n; ++d) {
      final double diff=v.getDoublePosition(d) - p[d];
      sum+=diff * diff;
    }
    if (sum < bestSquDistance) {
      bestSquDistance=sum;
      bestVertexIndex=v.getInternalPoolIndex();
    }
  }
  if (bestVertexIndex >= 0)   objPool.getByInternalPoolIndex(bestVertexIndex,bestVertex);
}",0.9863013698630136
90996,"public void mouseOverHighlight(final int x,final int y){
  final AffineTransform3D transform=new AffineTransform3D();
synchronized (renderTransform) {
    transform.set(renderTransform);
  }
  final int currentTimepoint=viewer.getState().getCurrentTimepoint();
  final double[] lPos=new double[]{x,y,0};
  final double[] gPos=new double[3];
  final ScreenVertexMath svm=new ScreenVertexMath(nSigmas);
  transform.applyInverse(gPos,lPos);
  final SpatioTemporalIndex<V> index=graph.getIndex();
  index.readLock().lock();
  try {
    if (drawSliceIntersection) {
      final NearestNeighborSearch<V> nns=index.getSpatialIndex(currentTimepoint).getNearestNeighborSearch();
      nns.search(RealPoint.wrap(gPos));
      final V v=nns.getSampler().get();
      if (v != null) {
        svm.init(v,transform);
        if (svm.containsGlobal(gPos)) {
          highlight.highlightVertex(v);
          return;
        }
      }
    }
 else {
      final double globalToViewerScale=Affine3DHelpers.extractScale(transform,0);
      final double border=globalToViewerScale * Math.sqrt(graph.getMaxBoundingSphereRadiusSquared(currentTimepoint));
      final ConvexPolytope cropPolytopeViewer=new ConvexPolytope(new HyperPlane(0,0,1,-focusLimit),new HyperPlane(0,0,-1,-focusLimit),new HyperPlane(1,0,0,x - border),new HyperPlane(-1,0,0,-x - border),new HyperPlane(0,1,0,y - border),new HyperPlane(0,-1,0,-y - border));
      final ConvexPolytope cropPolytopeGlobal=ConvexPolytope.transform(cropPolytopeViewer,transform.inverse());
      final ClipConvexPolytope<V> ccp=index.getSpatialIndex(currentTimepoint).getClipConvexPolytope();
      ccp.clip(cropPolytopeGlobal);
      final double[] xy=new double[]{x,y};
      final double[] vPos=new double[3];
      double minDist=Double.MAX_VALUE;
      final V minV=graph.vertexRef();
      boolean found=false;
      for (      final V v : ccp.getInsideValues()) {
        svm.init(v,transform);
        if (svm.projectionContainsView(xy)) {
          v.localize(vPos);
          final double d=LinAlgHelpers.squareDistance(vPos,gPos);
          if (d < minDist) {
            minDist=d;
            minV.refTo(v);
          }
        }
        found=true;
      }
      if (found) {
        highlight.highlightVertex(minV);
        graph.releaseRef(minV);
        return;
      }
      graph.releaseRef(minV);
    }
  }
  finally {
    index.readLock().unlock();
  }
  highlight.highlightVertex(null);
}","public void mouseOverHighlight(final int x,final int y){
  final AffineTransform3D transform=new AffineTransform3D();
synchronized (renderTransform) {
    transform.set(renderTransform);
  }
  final int currentTimepoint=viewer.getState().getCurrentTimepoint();
  final double[] lPos=new double[]{x,y,0};
  final double[] gPos=new double[3];
  final ScreenVertexMath svm=new ScreenVertexMath(nSigmas);
  transform.applyInverse(gPos,lPos);
  final SpatioTemporalIndex<V> index=graph.getIndex();
  index.readLock().lock();
  try {
    if (drawSliceIntersection) {
      final NearestNeighborSearch<V> nns=index.getSpatialIndex(currentTimepoint).getNearestNeighborSearch();
      nns.search(RealPoint.wrap(gPos));
      final V v=nns.getSampler().get();
      if (v != null) {
        svm.init(v,transform);
        if (svm.containsGlobal(gPos)) {
          highlight.highlightVertex(v);
          return;
        }
      }
    }
 else {
      final double globalToViewerScale=Affine3DHelpers.extractScale(transform,0);
      final double border=globalToViewerScale * Math.sqrt(graph.getMaxBoundingSphereRadiusSquared(currentTimepoint));
      final ConvexPolytope cropPolytopeViewer=new ConvexPolytope(new HyperPlane(0,0,1,-focusLimit),new HyperPlane(0,0,-1,-focusLimit),new HyperPlane(1,0,0,x - border),new HyperPlane(-1,0,0,-x - border),new HyperPlane(0,1,0,y - border),new HyperPlane(0,-1,0,-y - border));
      final ConvexPolytope cropPolytopeGlobal=ConvexPolytope.transform(cropPolytopeViewer,transform.inverse());
      final ClipConvexPolytope<V> ccp=index.getSpatialIndex(currentTimepoint).getClipConvexPolytope();
      ccp.clip(cropPolytopeGlobal);
      final double[] xy=new double[]{x,y};
      final double[] vPos=new double[3];
      double minDist=Double.MAX_VALUE;
      final V minV=graph.vertexRef();
      boolean found=false;
      for (      final V v : ccp.getInsideValues()) {
        svm.init(v,transform);
        if (svm.projectionContainsView(xy)) {
          found=true;
          v.localize(vPos);
          final double d=LinAlgHelpers.squareDistance(vPos,gPos);
          if (d < minDist) {
            minDist=d;
            minV.refTo(v);
          }
        }
      }
      if (found) {
        highlight.highlightVertex(minV);
        graph.releaseRef(minV);
        return;
      }
      graph.releaseRef(minV);
    }
  }
  finally {
    index.readLock().unlock();
  }
  highlight.highlightVertex(null);
}",0.991389913899139
90997,"@Override public void vertexAdded(final V vertex){
  writeLock.lock();
  try {
    final int tp=vertex.getTimepoint();
    SpatialIndexImp<V> index=timepointToSpatialIndex.get(tp);
    if (index == null) {
      index=new SpatialIndexImp<V>(CollectionUtils.createVertexSet(graph),vertexPool);
      timepointToSpatialIndex.put(tp,index);
    }
    index.add(vertex);
  }
  finally {
    writeLock.lock();
  }
}","@Override public void vertexAdded(final V vertex){
  writeLock.lock();
  try {
    final int tp=vertex.getTimepoint();
    SpatialIndexImp<V> index=timepointToSpatialIndex.get(tp);
    if (index == null) {
      index=new SpatialIndexImp<V>(CollectionUtils.createVertexSet(graph),vertexPool);
      timepointToSpatialIndex.put(tp,index);
    }
    index.add(vertex);
  }
  finally {
    writeLock.unlock();
  }
}",0.9975669099756692
90998,"public NodeFactory(final Collection<O> objects,final RefPool<O> objectPool,final MemPool.Factory<T> poolFactory){
  this.poolFactory=poolFactory;
  this.numDimensions=objects.iterator().next().numDimensions();
  this.sizeInBytes=KDTreeNode.sizeInBytes(numDimensions);
  final int capacity=objects.size();
  kdtree=new KDTree<O,T>(capacity,this,numDimensions,objects,objectPool);
}","public NodeFactory(final Collection<O> objects,final RefPool<O> objectPool,final MemPool.Factory<T> poolFactory){
  this.poolFactory=poolFactory;
  if (objects.isEmpty()) {
    final O ref=objectPool.createRef();
    this.numDimensions=ref.numDimensions();
    objectPool.releaseRef(ref);
  }
 else   this.numDimensions=objects.iterator().next().numDimensions();
  this.sizeInBytes=KDTreeNode.sizeInBytes(numDimensions);
  final int capacity=objects.size();
  kdtree=new KDTree<O,T>(capacity,this,numDimensions,objects,objectPool);
}",0.8324205914567361
90999,"@Override public SpatialIndex<OverlayVertexWrapper<V,E>> getSpatialIndex(final int fromTimepoint,final int toTimepoint){
  return new SpatialIndexWrapper<V,E>(graphWrapper,wrappedIndex.getSpatialIndex(fromTimepoint,toTimepoint));
}","@Override public SpatialIndex<OverlayVertexWrapper<V,E>> getSpatialIndex(final int fromTimepoint,final int toTimepoint){
  final SpatialIndex<V> index=wrappedIndex.getSpatialIndex(fromTimepoint,toTimepoint);
  if (index == null)   return null;
 else   return new SpatialIndexWrapper<V,E>(graphWrapper,index);
}",0.6506469500924215
91000,"@Override public L remove(final Object key,final L ref){
  return remove(key);
}","@Override public L remove(final Object key){
  return map.remove(key);
}",0.8947368421052632
